// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 684 0 0
// InitMacro ;
  19: CALL 56354 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49090 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49090 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49090 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49090 0 9
// PrepareArabian ;
 168: CALL 4001 0 0
// PrepareRussian ;
 172: CALL 2972 0 0
// PrepareAlliance ;
 176: CALL 894 0 0
// MC_Start ( ) ;
 180: CALL 58526 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7359 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 85
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 86
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: LD_INT 20
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: PPUSH
 263: LD_INT 7
 265: PPUSH
 266: CALL 80264 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 270: LD_INT 1
 272: PPUSH
 273: LD_EXP 56
 277: PPUSH
 278: CALL 80690 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 282: LD_INT 1
 284: PPUSH
 285: LD_INT 6
 287: PPUSH
 288: CALL 81148 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 9
 297: PUSH
 298: EMPTY
 299: LIST
 300: PPUSH
 301: CALL 81417 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 13
 310: PUSH
 311: LD_INT 1
 313: PUSH
 314: LD_INT 2
 316: PUSH
 317: LD_INT 32
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: LIST
 324: LIST
 325: PUSH
 326: LD_INT 13
 328: PUSH
 329: LD_INT 1
 331: PUSH
 332: LD_INT 2
 334: PUSH
 335: LD_INT 88
 337: PUSH
 338: EMPTY
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: PPUSH
 348: CALL 80630 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 352: LD_INT 2
 354: PPUSH
 355: LD_INT 12
 357: PUSH
 358: LD_INT 14
 360: PUSH
 361: LD_INT 10
 363: PUSH
 364: LD_INT 11
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: LIST
 371: LIST
 372: PPUSH
 373: CALL 81324 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 377: LD_INT 2
 379: PPUSH
 380: LD_EXP 53
 384: PPUSH
 385: CALL 80690 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 389: LD_INT 2
 391: PPUSH
 392: LD_INT 8
 394: PPUSH
 395: CALL 81148 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 399: LD_INT 2
 401: PPUSH
 402: LD_INT 10
 404: PUSH
 405: EMPTY
 406: LIST
 407: PPUSH
 408: CALL 81417 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 412: LD_INT 2
 414: PPUSH
 415: LD_INT 6
 417: PUSH
 418: LD_INT 71
 420: PUSH
 421: LD_INT 116
 423: PUSH
 424: LD_INT 4
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 4
 435: PUSH
 436: LD_INT 85
 438: PUSH
 439: LD_INT 116
 441: PUSH
 442: LD_INT 4
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: PUSH
 451: LD_INT 32
 453: PUSH
 454: LD_INT 83
 456: PUSH
 457: LD_INT 111
 459: PUSH
 460: LD_INT 4
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 87
 474: PUSH
 475: LD_INT 121
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 33
 489: PUSH
 490: LD_INT 88
 492: PUSH
 493: LD_INT 128
 495: PUSH
 496: LD_INT 4
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 32
 507: PUSH
 508: LD_INT 59
 510: PUSH
 511: LD_INT 89
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 33
 525: PUSH
 526: LD_INT 69
 528: PUSH
 529: LD_INT 98
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_INT 33
 543: PUSH
 544: LD_INT 77
 546: PUSH
 547: LD_INT 103
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 33
 561: PUSH
 562: LD_INT 83
 564: PUSH
 565: LD_INT 105
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 33
 579: PUSH
 580: LD_INT 71
 582: PUSH
 583: LD_INT 125
 585: PUSH
 586: LD_INT 5
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PPUSH
 607: CALL 80474 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 611: LD_INT 2
 613: PPUSH
 614: LD_INT 43
 616: PUSH
 617: LD_INT 47
 619: PUSH
 620: LD_INT 46
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL 81735 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 632: LD_INT 2
 634: PPUSH
 635: LD_INT 21
 637: PUSH
 638: LD_INT 1
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 51
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 22
 655: PUSH
 656: LD_INT 1
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 52
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PPUSH
 675: CALL 80630 0 2
// end ;
 679: LD_VAR 0 1
 683: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 684: LD_INT 0
 686: PPUSH
// debug := false ;
 687: LD_ADDR_EXP 1
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// game := true ;
 695: LD_ADDR_EXP 2
 699: PUSH
 700: LD_INT 1
 702: ST_TO_ADDR
// gossudarov_arrive := false ;
 703: LD_ADDR_EXP 4
 707: PUSH
 708: LD_INT 0
 710: ST_TO_ADDR
// ru_lab_builded := false ;
 711: LD_ADDR_EXP 5
 715: PUSH
 716: LD_INT 0
 718: ST_TO_ADDR
// player_spotted := false ;
 719: LD_ADDR_EXP 6
 723: PUSH
 724: LD_INT 0
 726: ST_TO_ADDR
// first_attack := false ;
 727: LD_ADDR_EXP 7
 731: PUSH
 732: LD_INT 0
 734: ST_TO_ADDR
// ru_attackers := [ ] ;
 735: LD_ADDR_EXP 54
 739: PUSH
 740: EMPTY
 741: ST_TO_ADDR
// ar_base_spotted := false ;
 742: LD_ADDR_EXP 8
 746: PUSH
 747: LD_INT 0
 749: ST_TO_ADDR
// ar_active_attack := false ;
 750: LD_ADDR_EXP 9
 754: PUSH
 755: LD_INT 0
 757: ST_TO_ADDR
// ar_attackers := [ ] ;
 758: LD_ADDR_EXP 11
 762: PUSH
 763: EMPTY
 764: ST_TO_ADDR
// first_powell_attack := false ;
 765: LD_ADDR_EXP 12
 769: PUSH
 770: LD_INT 0
 772: ST_TO_ADDR
// masha_killed := false ;
 773: LD_ADDR_EXP 10
 777: PUSH
 778: LD_INT 0
 780: ST_TO_ADDR
// abdul_escaped := true ;
 781: LD_ADDR_EXP 13
 785: PUSH
 786: LD_INT 1
 788: ST_TO_ADDR
// loss_counter := 0 ;
 789: LD_ADDR_EXP 14
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// hack_counter := 0 ;
 797: LD_ADDR_EXP 15
 801: PUSH
 802: LD_INT 0
 804: ST_TO_ADDR
// end ;
 805: LD_VAR 0 1
 809: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 810: LD_EXP 50
 814: PPUSH
 815: CALL_OW 255
 819: PUSH
 820: LD_INT 7
 822: EQUAL
 823: PUSH
 824: LD_EXP 49
 828: PPUSH
 829: CALL_OW 255
 833: PUSH
 834: LD_INT 7
 836: EQUAL
 837: AND
 838: PUSH
 839: LD_EXP 50
 843: PPUSH
 844: CALL_OW 302
 848: AND
 849: PUSH
 850: LD_EXP 49
 854: PPUSH
 855: CALL_OW 302
 859: AND
 860: IFFALSE 872
 862: GO 864
 864: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 865: LD_STRING ACH_COMRADE
 867: PPUSH
 868: CALL_OW 543
 872: END
// every 0 0$1 trigger hack_counter >= 10 do
 873: LD_EXP 15
 877: PUSH
 878: LD_INT 10
 880: GREATEREQUAL
 881: IFFALSE 893
 883: GO 885
 885: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 886: LD_STRING ACH_HACK
 888: PPUSH
 889: CALL_OW 543
 893: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 894: LD_INT 0
 896: PPUSH
 897: PPUSH
 898: PPUSH
 899: PPUSH
// uc_side := 7 ;
 900: LD_ADDR_OWVAR 20
 904: PUSH
 905: LD_INT 7
 907: ST_TO_ADDR
// uc_nation := 1 ;
 908: LD_ADDR_OWVAR 21
 912: PUSH
 913: LD_INT 1
 915: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 16
 920: PUSH
 921: LD_STRING JMM
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 14933 0 3
 937: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 938: LD_EXP 16
 942: PPUSH
 943: LD_INT 71
 945: PPUSH
 946: LD_INT 23
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 956: LD_EXP 16
 960: PPUSH
 961: LD_INT 2
 963: PPUSH
 964: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 968: LD_ADDR_EXP 17
 972: PUSH
 973: LD_STRING Roth
 975: PPUSH
 976: LD_EXP 1
 980: NOT
 981: PPUSH
 982: LD_STRING 12a_
 984: PPUSH
 985: CALL 14933 0 3
 989: ST_TO_ADDR
// if Roth then
 990: LD_EXP 17
 994: IFFALSE 1014
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 996: LD_EXP 17
1000: PPUSH
1001: LD_INT 71
1003: PPUSH
1004: LD_INT 21
1006: PPUSH
1007: LD_INT 0
1009: PPUSH
1010: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1014: LD_ADDR_EXP 33
1018: PUSH
1019: LD_STRING Mike
1021: PPUSH
1022: LD_EXP 1
1026: NOT
1027: PPUSH
1028: LD_STRING 12a_
1030: PPUSH
1031: CALL 14933 0 3
1035: ST_TO_ADDR
// if Mike then
1036: LD_EXP 33
1040: IFFALSE 1057
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1042: LD_EXP 33
1046: PPUSH
1047: LD_INT 13
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1057: LD_ADDR_EXP 18
1061: PUSH
1062: LD_STRING Lisa
1064: PPUSH
1065: LD_EXP 1
1069: NOT
1070: PPUSH
1071: LD_STRING 12a_
1073: PPUSH
1074: CALL 14933 0 3
1078: ST_TO_ADDR
// if Lisa then
1079: LD_EXP 18
1083: IFFALSE 1100
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1085: LD_EXP 18
1089: PPUSH
1090: LD_INT 13
1092: PPUSH
1093: LD_INT 0
1095: PPUSH
1096: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1100: LD_ADDR_EXP 19
1104: PUSH
1105: LD_STRING Donaldson
1107: PPUSH
1108: LD_EXP 1
1112: NOT
1113: PPUSH
1114: LD_STRING 12a_
1116: PPUSH
1117: CALL 14933 0 3
1121: ST_TO_ADDR
// if Donaldson then
1122: LD_EXP 19
1126: IFFALSE 1143
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1128: LD_EXP 19
1132: PPUSH
1133: LD_INT 13
1135: PPUSH
1136: LD_INT 0
1138: PPUSH
1139: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1143: LD_ADDR_EXP 20
1147: PUSH
1148: LD_STRING Bobby
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: LD_STRING 12a_
1159: PPUSH
1160: CALL 14933 0 3
1164: ST_TO_ADDR
// if Bobby then
1165: LD_EXP 20
1169: IFFALSE 1186
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1171: LD_EXP 20
1175: PPUSH
1176: LD_INT 13
1178: PPUSH
1179: LD_INT 0
1181: PPUSH
1182: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1186: LD_ADDR_EXP 21
1190: PUSH
1191: LD_STRING Cyrus
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_STRING 12a_
1202: PPUSH
1203: CALL 14933 0 3
1207: ST_TO_ADDR
// if Cyrus then
1208: LD_EXP 21
1212: IFFALSE 1229
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1214: LD_EXP 21
1218: PPUSH
1219: LD_INT 13
1221: PPUSH
1222: LD_INT 0
1224: PPUSH
1225: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1229: LD_ADDR_EXP 22
1233: PUSH
1234: LD_STRING Denis
1236: PPUSH
1237: LD_EXP 1
1241: NOT
1242: PPUSH
1243: LD_STRING 12a_
1245: PPUSH
1246: CALL 14933 0 3
1250: ST_TO_ADDR
// if Denis then
1251: LD_EXP 22
1255: IFFALSE 1272
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1257: LD_EXP 22
1261: PPUSH
1262: LD_INT 13
1264: PPUSH
1265: LD_INT 0
1267: PPUSH
1268: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1272: LD_ADDR_EXP 23
1276: PUSH
1277: LD_STRING Brown
1279: PPUSH
1280: LD_EXP 1
1284: NOT
1285: PPUSH
1286: LD_STRING 12a_
1288: PPUSH
1289: CALL 14933 0 3
1293: ST_TO_ADDR
// if Brown then
1294: LD_EXP 23
1298: IFFALSE 1315
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1300: LD_EXP 23
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: LD_INT 0
1310: PPUSH
1311: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1315: LD_ADDR_EXP 24
1319: PUSH
1320: LD_STRING Gladstone
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_STRING 12a_
1331: PPUSH
1332: CALL 14933 0 3
1336: ST_TO_ADDR
// if Gladstone then
1337: LD_EXP 24
1341: IFFALSE 1358
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1343: LD_EXP 24
1347: PPUSH
1348: LD_INT 13
1350: PPUSH
1351: LD_INT 0
1353: PPUSH
1354: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1358: LD_ADDR_EXP 25
1362: PUSH
1363: LD_STRING Houten
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 12a_
1374: PPUSH
1375: CALL 14933 0 3
1379: ST_TO_ADDR
// if Houten then
1380: LD_EXP 25
1384: IFFALSE 1401
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1386: LD_EXP 25
1390: PPUSH
1391: LD_INT 13
1393: PPUSH
1394: LD_INT 0
1396: PPUSH
1397: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1401: LD_ADDR_EXP 26
1405: PUSH
1406: LD_STRING Cornell
1408: PPUSH
1409: LD_EXP 1
1413: NOT
1414: PPUSH
1415: LD_STRING 12a_
1417: PPUSH
1418: CALL 14933 0 3
1422: ST_TO_ADDR
// if Cornel then
1423: LD_EXP 26
1427: IFFALSE 1444
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1429: LD_EXP 26
1433: PPUSH
1434: LD_INT 13
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1444: LD_ADDR_EXP 27
1448: PUSH
1449: LD_STRING Gary
1451: PPUSH
1452: LD_EXP 1
1456: NOT
1457: PPUSH
1458: LD_STRING 12a_
1460: PPUSH
1461: CALL 14933 0 3
1465: ST_TO_ADDR
// if Gary then
1466: LD_EXP 27
1470: IFFALSE 1487
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1472: LD_EXP 27
1476: PPUSH
1477: LD_INT 13
1479: PPUSH
1480: LD_INT 0
1482: PPUSH
1483: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1487: LD_ADDR_EXP 28
1491: PUSH
1492: LD_STRING Frank
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 12a_
1503: PPUSH
1504: CALL 14933 0 3
1508: ST_TO_ADDR
// if Frank then
1509: LD_EXP 28
1513: IFFALSE 1530
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1515: LD_EXP 28
1519: PPUSH
1520: LD_INT 13
1522: PPUSH
1523: LD_INT 0
1525: PPUSH
1526: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1530: LD_ADDR_EXP 29
1534: PUSH
1535: LD_STRING Kikuchi
1537: PPUSH
1538: LD_EXP 1
1542: NOT
1543: PPUSH
1544: LD_STRING 12a_
1546: PPUSH
1547: CALL 14933 0 3
1551: ST_TO_ADDR
// if Kikuchi then
1552: LD_EXP 29
1556: IFFALSE 1573
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1558: LD_EXP 29
1562: PPUSH
1563: LD_INT 13
1565: PPUSH
1566: LD_INT 0
1568: PPUSH
1569: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1573: LD_ADDR_EXP 30
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 12a_
1589: PPUSH
1590: CALL 14933 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 30
1599: IFFALSE 1616
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1601: LD_EXP 30
1605: PPUSH
1606: LD_INT 13
1608: PPUSH
1609: LD_INT 0
1611: PPUSH
1612: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1616: LD_ADDR_EXP 31
1620: PUSH
1621: LD_STRING Joan
1623: PPUSH
1624: LD_EXP 1
1628: NOT
1629: PPUSH
1630: LD_STRING 12a_
1632: PPUSH
1633: CALL 14933 0 3
1637: ST_TO_ADDR
// if Joan then
1638: LD_EXP 31
1642: IFFALSE 1659
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1644: LD_EXP 31
1648: PPUSH
1649: LD_INT 13
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1659: LD_ADDR_EXP 32
1663: PUSH
1664: LD_STRING DeltaDoctor
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 12a_
1675: PPUSH
1676: CALL 14933 0 3
1680: ST_TO_ADDR
// if DeltaDoctor then
1681: LD_EXP 32
1685: IFFALSE 1702
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1687: LD_EXP 32
1691: PPUSH
1692: LD_INT 13
1694: PPUSH
1695: LD_INT 0
1697: PPUSH
1698: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1702: LD_ADDR_VAR 0 4
1706: PUSH
1707: LD_STRING 12a_others
1709: PPUSH
1710: CALL_OW 31
1714: ST_TO_ADDR
// if tmp then
1715: LD_VAR 0 4
1719: IFFALSE 1753
// for i in tmp do
1721: LD_ADDR_VAR 0 3
1725: PUSH
1726: LD_VAR 0 4
1730: PUSH
1731: FOR_IN
1732: IFFALSE 1751
// PlaceUnitArea ( i , alliance_start , false ) ;
1734: LD_VAR 0 3
1738: PPUSH
1739: LD_INT 13
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL_OW 49
1749: GO 1731
1751: POP
1752: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1753: LD_INT 3
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: LD_INT 12
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 19948 0 5
// veh := CreateVehicle ;
1772: LD_ADDR_VAR 0 2
1776: PUSH
1777: CALL_OW 45
1781: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 2
1789: PPUSH
1790: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1794: LD_VAR 0 2
1798: PPUSH
1799: LD_INT 60
1801: PPUSH
1802: LD_INT 6
1804: PPUSH
1805: LD_INT 0
1807: PPUSH
1808: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1812: LD_VAR 0 2
1816: PPUSH
1817: LD_INT 4
1819: PPUSH
1820: LD_INT 30
1822: PPUSH
1823: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1827: LD_STRING 11_artifact_captured
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 30
1837: IFFALSE 1913
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1839: LD_INT 3
1841: PPUSH
1842: LD_INT 3
1844: PPUSH
1845: LD_INT 3
1847: PPUSH
1848: LD_INT 12
1850: PPUSH
1851: LD_INT 100
1853: PPUSH
1854: CALL 19948 0 5
// veh := CreateVehicle ;
1858: LD_ADDR_VAR 0 2
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1868: LD_VAR 0 2
1872: PPUSH
1873: LD_INT 3
1875: PPUSH
1876: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1880: LD_VAR 0 2
1884: PPUSH
1885: LD_INT 75
1887: PPUSH
1888: LD_INT 6
1890: PPUSH
1891: LD_INT 0
1893: PPUSH
1894: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1898: LD_VAR 0 2
1902: PPUSH
1903: LD_INT 4
1905: PPUSH
1906: LD_INT 50
1908: PPUSH
1909: CALL_OW 290
// end ; end ;
1913: LD_VAR 0 1
1917: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1918: LD_INT 0
1920: PPUSH
1921: PPUSH
1922: PPUSH
1923: PPUSH
// uc_side := 6 ;
1924: LD_ADDR_OWVAR 20
1928: PUSH
1929: LD_INT 6
1931: ST_TO_ADDR
// uc_nation := 3 ;
1932: LD_ADDR_OWVAR 21
1936: PUSH
1937: LD_INT 3
1939: ST_TO_ADDR
// InitHc ;
1940: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1944: LD_ADDR_EXP 34
1948: PUSH
1949: LD_STRING Gossudarov
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1957: LD_ADDR_EXP 35
1961: PUSH
1962: LD_STRING Kirilenkova
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1970: LD_ADDR_EXP 36
1974: PUSH
1975: LD_STRING Titov
1977: PPUSH
1978: CALL_OW 25
1982: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1983: LD_ADDR_EXP 41
1987: PUSH
1988: LD_STRING Oblukov
1990: PPUSH
1991: CALL_OW 25
1995: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1996: LD_ADDR_EXP 38
2000: PUSH
2001: LD_STRING Dolgov
2003: PPUSH
2004: CALL_OW 25
2008: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2009: LD_ADDR_EXP 39
2013: PUSH
2014: LD_STRING Petrosyan
2016: PPUSH
2017: CALL_OW 25
2021: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2022: LD_ADDR_EXP 40
2026: PUSH
2027: LD_STRING Scholtze
2029: PPUSH
2030: CALL_OW 25
2034: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2035: LD_ADDR_EXP 42
2039: PUSH
2040: LD_STRING Kapitsova
2042: PPUSH
2043: CALL_OW 25
2047: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2048: LD_ADDR_VAR 0 2
2052: PUSH
2053: LD_EXP 34
2057: PUSH
2058: LD_EXP 35
2062: PUSH
2063: LD_EXP 36
2067: PUSH
2068: LD_EXP 41
2072: PUSH
2073: LD_EXP 38
2077: PUSH
2078: LD_EXP 39
2082: PUSH
2083: LD_EXP 40
2087: PUSH
2088: LD_EXP 42
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2103: LD_INT 1
2105: PPUSH
2106: LD_INT 4
2108: PPUSH
2109: LD_INT 8
2111: PPUSH
2112: CALL_OW 380
// un := CreateHuman ;
2116: LD_ADDR_VAR 0 4
2120: PUSH
2121: CALL_OW 44
2125: ST_TO_ADDR
// tmp := tmp ^ un ;
2126: LD_ADDR_VAR 0 2
2130: PUSH
2131: LD_VAR 0 2
2135: PUSH
2136: LD_VAR 0 4
2140: ADD
2141: ST_TO_ADDR
// for i in tmp do
2142: LD_ADDR_VAR 0 3
2146: PUSH
2147: LD_VAR 0 2
2151: PUSH
2152: FOR_IN
2153: IFFALSE 2172
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2155: LD_VAR 0 3
2159: PPUSH
2160: LD_INT 14
2162: PPUSH
2163: LD_INT 0
2165: PPUSH
2166: CALL_OW 49
2170: GO 2152
2172: POP
2173: POP
// if freedom then
2174: LD_EXP 3
2178: IFFALSE 2211
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2180: LD_VAR 0 2
2184: PPUSH
2185: LD_EXP 3
2189: PPUSH
2190: CALL_OW 250
2194: PPUSH
2195: LD_EXP 3
2199: PPUSH
2200: CALL_OW 251
2204: PPUSH
2205: CALL_OW 111
2209: GO 2226
// ComMoveXY ( tmp , 70 , 48 ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_INT 70
2218: PPUSH
2219: LD_INT 48
2221: PPUSH
2222: CALL_OW 111
// end ;
2226: LD_VAR 0 1
2230: RET
// export function PrepareBelkov ; begin
2231: LD_INT 0
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2254: LD_ADDR_EXP 49
2258: PUSH
2259: LD_STRING Belkov
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2267: LD_EXP 49
2271: PPUSH
2272: LD_INT 14
2274: PPUSH
2275: LD_INT 0
2277: PPUSH
2278: CALL_OW 49
// end ;
2282: LD_VAR 0 1
2286: RET
// export function PrepareGnyevko ; begin
2287: LD_INT 0
2289: PPUSH
// uc_side := 4 ;
2290: LD_ADDR_OWVAR 20
2294: PUSH
2295: LD_INT 4
2297: ST_TO_ADDR
// uc_nation := 3 ;
2298: LD_ADDR_OWVAR 21
2302: PUSH
2303: LD_INT 3
2305: ST_TO_ADDR
// InitHc ;
2306: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2310: LD_ADDR_EXP 50
2314: PUSH
2315: LD_STRING Gnyevko
2317: PPUSH
2318: CALL_OW 25
2322: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2323: LD_EXP 50
2327: PPUSH
2328: LD_INT 14
2330: PPUSH
2331: LD_INT 0
2333: PPUSH
2334: CALL_OW 49
// end ;
2338: LD_VAR 0 1
2342: RET
// export function PrepareBurlak ; var i , tmp ; begin
2343: LD_INT 0
2345: PPUSH
2346: PPUSH
2347: PPUSH
// uc_side := 4 ;
2348: LD_ADDR_OWVAR 20
2352: PUSH
2353: LD_INT 4
2355: ST_TO_ADDR
// uc_nation := 3 ;
2356: LD_ADDR_OWVAR 21
2360: PUSH
2361: LD_INT 3
2363: ST_TO_ADDR
// InitHc ;
2364: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2368: LD_ADDR_EXP 48
2372: PUSH
2373: LD_STRING Burlak
2375: PPUSH
2376: CALL_OW 25
2380: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2381: LD_INT 24
2383: PUSH
2384: LD_INT 23
2386: PUSH
2387: LD_INT 22
2389: PUSH
2390: LD_INT 22
2392: PUSH
2393: EMPTY
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: PUSH
2399: LD_OWVAR 67
2403: ARRAY
2404: PPUSH
2405: LD_INT 1
2407: PPUSH
2408: LD_INT 1
2410: PPUSH
2411: LD_INT 45
2413: PUSH
2414: LD_INT 44
2416: PUSH
2417: LD_INT 43
2419: PUSH
2420: LD_INT 42
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: LIST
2427: LIST
2428: PUSH
2429: LD_OWVAR 67
2433: ARRAY
2434: PPUSH
2435: LD_INT 0
2437: PPUSH
2438: CALL 19948 0 5
// Masha := CreateVehicle ;
2442: LD_ADDR_EXP 51
2446: PUSH
2447: CALL_OW 45
2451: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2452: LD_EXP 51
2456: PUSH
2457: LD_EXP 48
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: PPUSH
2466: LD_INT 499
2468: PPUSH
2469: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2473: LD_EXP 51
2477: PPUSH
2478: LD_INT 3
2480: PPUSH
2481: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2485: LD_EXP 51
2489: PPUSH
2490: LD_INT 1
2492: PPUSH
2493: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2497: LD_INT 1
2499: PPUSH
2500: LD_INT 18
2502: PPUSH
2503: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2514: LD_ADDR_VAR 0 3
2518: PUSH
2519: LD_INT 18
2521: PPUSH
2522: EMPTY
2523: PPUSH
2524: CALL_OW 70
2528: ST_TO_ADDR
// if tmp then
2529: LD_VAR 0 3
2533: IFFALSE 2567
// for i in tmp do
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 3
2544: PUSH
2545: FOR_IN
2546: IFFALSE 2565
// ComMoveXY ( i , 114 , 9 ) ;
2548: LD_VAR 0 2
2552: PPUSH
2553: LD_INT 114
2555: PPUSH
2556: LD_INT 9
2558: PPUSH
2559: CALL_OW 111
2563: GO 2545
2565: POP
2566: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2567: LD_INT 18
2569: PPUSH
2570: EMPTY
2571: PPUSH
2572: CALL_OW 70
2576: NOT
2577: PUSH
2578: LD_INT 123
2580: PPUSH
2581: LD_INT 3
2583: PPUSH
2584: CALL_OW 428
2588: PUSH
2589: LD_INT 0
2591: EQUAL
2592: AND
2593: IFFALSE 2507
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2595: LD_EXP 51
2599: PPUSH
2600: LD_INT 123
2602: PPUSH
2603: LD_INT 3
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2613: LD_EXP 48
2617: PPUSH
2618: LD_INT 125
2620: PPUSH
2621: LD_INT 1
2623: PPUSH
2624: LD_INT 0
2626: PPUSH
2627: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2631: LD_EXP 48
2635: PPUSH
2636: LD_EXP 51
2640: PPUSH
2641: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2645: LD_INT 10
2647: PPUSH
2648: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2652: LD_EXP 51
2656: PPUSH
2657: LD_INT 110
2659: PPUSH
2660: LD_INT 10
2662: PPUSH
2663: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2667: LD_ADDR_EXP 44
2671: PUSH
2672: LD_STRING Petrovova
2674: PPUSH
2675: CALL_OW 25
2679: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2680: LD_ADDR_EXP 46
2684: PUSH
2685: LD_STRING Kuzmov
2687: PPUSH
2688: CALL_OW 25
2692: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2693: LD_ADDR_EXP 45
2697: PUSH
2698: LD_STRING Kovalyuk
2700: PPUSH
2701: CALL_OW 25
2705: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2706: LD_ADDR_EXP 43
2710: PUSH
2711: LD_STRING Lipshchin
2713: PPUSH
2714: CALL_OW 25
2718: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2719: LD_ADDR_EXP 47
2723: PUSH
2724: LD_STRING Karamazov
2726: PPUSH
2727: CALL_OW 25
2731: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2732: LD_ADDR_VAR 0 3
2736: PUSH
2737: LD_EXP 44
2741: PUSH
2742: LD_EXP 46
2746: PUSH
2747: LD_EXP 45
2751: PUSH
2752: LD_EXP 43
2756: PUSH
2757: LD_EXP 47
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: LIST
2767: LIST
2768: ST_TO_ADDR
// for i in tmp do
2769: LD_ADDR_VAR 0 2
2773: PUSH
2774: LD_VAR 0 3
2778: PUSH
2779: FOR_IN
2780: IFFALSE 2819
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2782: LD_VAR 0 2
2786: PPUSH
2787: LD_INT 399
2789: PPUSH
2790: LD_INT 799
2792: PPUSH
2793: CALL_OW 12
2797: PPUSH
2798: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2802: LD_VAR 0 2
2806: PPUSH
2807: LD_INT 19
2809: PPUSH
2810: LD_INT 0
2812: PPUSH
2813: CALL_OW 49
// end ;
2817: GO 2779
2819: POP
2820: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2821: LD_VAR 0 3
2825: PPUSH
2826: LD_INT 112
2828: PPUSH
2829: LD_INT 5
2831: PPUSH
2832: CALL_OW 111
// AddComHold ( tmp ) ;
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2845: LD_ADDR_VAR 0 2
2849: PUSH
2850: LD_VAR 0 3
2854: PPUSH
2855: LD_INT 25
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 72
2869: PUSH
2870: FOR_IN
2871: IFFALSE 2911
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2873: LD_VAR 0 2
2877: PPUSH
2878: LD_INT 20
2880: PPUSH
2881: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2885: LD_VAR 0 2
2889: PPUSH
2890: LD_INT 147
2892: PPUSH
2893: LD_INT 45
2895: PPUSH
2896: CALL_OW 178
// AddComCrawl ( i ) ;
2900: LD_VAR 0 2
2904: PPUSH
2905: CALL_OW 197
// end ;
2909: GO 2870
2911: POP
2912: POP
// repeat wait ( 0 0$1 ) ;
2913: LD_INT 35
2915: PPUSH
2916: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2920: LD_EXP 51
2924: PPUSH
2925: LD_INT 110
2927: PPUSH
2928: LD_INT 10
2930: PPUSH
2931: CALL_OW 307
2935: PUSH
2936: LD_EXP 51
2940: PPUSH
2941: CALL_OW 305
2945: NOT
2946: OR
2947: IFFALSE 2913
// ComStop ( Burlak ) ;
2949: LD_EXP 48
2953: PPUSH
2954: CALL_OW 141
// AddComHold ( Burlak ) ;
2958: LD_EXP 48
2962: PPUSH
2963: CALL_OW 200
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2972: LD_INT 0
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
// uc_side := 3 ;
2979: LD_ADDR_OWVAR 20
2983: PUSH
2984: LD_INT 3
2986: ST_TO_ADDR
// uc_nation := 3 ;
2987: LD_ADDR_OWVAR 21
2991: PUSH
2992: LD_INT 3
2994: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2995: LD_ADDR_EXP 52
2999: PUSH
3000: LD_INT 47
3002: PPUSH
3003: LD_INT 4
3005: PPUSH
3006: LD_STRING 
3008: PPUSH
3009: LD_INT 7
3011: PUSH
3012: LD_INT 8
3014: PUSH
3015: LD_INT 9
3017: PUSH
3018: LD_INT 10
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: PUSH
3027: LD_OWVAR 67
3031: ARRAY
3032: PPUSH
3033: LD_INT 10000
3035: PUSH
3036: LD_INT 3000
3038: PUSH
3039: LD_INT 300
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 5
3052: PUSH
3053: LD_INT 6
3055: PUSH
3056: LD_INT 6
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: PPUSH
3065: CALL 23392 0 6
3069: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3070: LD_ADDR_EXP 61
3074: PUSH
3075: LD_EXP 61
3079: PPUSH
3080: LD_INT 2
3082: PPUSH
3083: LD_EXP 52
3087: PPUSH
3088: CALL_OW 1
3092: ST_TO_ADDR
// tmp := [ ] ;
3093: LD_ADDR_VAR 0 4
3097: PUSH
3098: EMPTY
3099: ST_TO_ADDR
// for i = 1 to 4 do
3100: LD_ADDR_VAR 0 2
3104: PUSH
3105: DOUBLE
3106: LD_INT 1
3108: DEC
3109: ST_TO_ADDR
3110: LD_INT 4
3112: PUSH
3113: FOR_TO
3114: IFFALSE 3207
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3116: LD_INT 22
3118: PPUSH
3119: LD_INT 3
3121: PPUSH
3122: LD_INT 3
3124: PPUSH
3125: LD_INT 43
3127: PUSH
3128: LD_INT 45
3130: PUSH
3131: LD_INT 45
3133: PUSH
3134: LD_INT 44
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PUSH
3143: LD_VAR 0 2
3147: PUSH
3148: LD_INT 4
3150: MOD
3151: PUSH
3152: LD_INT 1
3154: PLUS
3155: ARRAY
3156: PPUSH
3157: LD_INT 100
3159: PPUSH
3160: CALL 19948 0 5
// veh := CreateVehicle ;
3164: LD_ADDR_VAR 0 3
3168: PUSH
3169: CALL_OW 45
3173: ST_TO_ADDR
// tmp := tmp ^ veh ;
3174: LD_ADDR_VAR 0 4
3178: PUSH
3179: LD_VAR 0 4
3183: PUSH
3184: LD_VAR 0 3
3188: ADD
3189: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3190: LD_VAR 0 3
3194: PPUSH
3195: LD_INT 2
3197: PPUSH
3198: LD_INT 0
3200: PPUSH
3201: CALL_OW 49
// end ;
3205: GO 3113
3207: POP
3208: POP
// russian_guard := tmp ;
3209: LD_ADDR_EXP 53
3213: PUSH
3214: LD_VAR 0 4
3218: ST_TO_ADDR
// if Difficulty >= 3 then
3219: LD_OWVAR 67
3223: PUSH
3224: LD_INT 3
3226: GREATEREQUAL
3227: IFFALSE 3291
// begin bc_type := b_breastwork ;
3229: LD_ADDR_OWVAR 42
3233: PUSH
3234: LD_INT 31
3236: ST_TO_ADDR
// bc_level := 10 ;
3237: LD_ADDR_OWVAR 43
3241: PUSH
3242: LD_INT 10
3244: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_INT 96
3252: PPUSH
3253: LD_INT 105
3255: PPUSH
3256: LD_INT 3
3258: PPUSH
3259: CALL_OW 47
3263: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3264: LD_INT 0
3266: PPUSH
3267: LD_INT 9
3269: PPUSH
3270: LD_INT 10
3272: PPUSH
3273: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3277: CALL_OW 44
3281: PPUSH
3282: LD_VAR 0 5
3286: PPUSH
3287: CALL_OW 52
// end ; end ;
3291: LD_VAR 0 1
3295: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3296: LD_INT 47
3298: PPUSH
3299: CALL_OW 302
3303: PUSH
3304: LD_EXP 6
3308: AND
3309: IFFALSE 3998
3311: GO 3313
3313: DISABLE
3314: LD_INT 0
3316: PPUSH
3317: PPUSH
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
// begin enable ;
3323: ENABLE
// base := 2 ;
3324: LD_ADDR_VAR 0 2
3328: PUSH
3329: LD_INT 2
3331: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3332: LD_ADDR_VAR 0 4
3336: PUSH
3337: LD_INT 0
3339: PUSH
3340: LD_INT 0
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: LD_INT 0
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 1
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: LIST
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3379: LD_ADDR_VAR 0 3
3383: PUSH
3384: LD_INT 22
3386: PUSH
3387: LD_INT 1
3389: PUSH
3390: LD_INT 3
3392: PUSH
3393: LD_INT 45
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: PUSH
3402: LD_INT 21
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 22
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 23
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 46
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: EMPTY
3457: LIST
3458: LIST
3459: LIST
3460: LIST
3461: ST_TO_ADDR
// amount := Difficulty ;
3462: LD_ADDR_VAR 0 7
3466: PUSH
3467: LD_OWVAR 67
3471: ST_TO_ADDR
// if tick > 30 30$00 then
3472: LD_OWVAR 1
3476: PUSH
3477: LD_INT 63000
3479: GREATER
3480: IFFALSE 3517
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3482: LD_ADDR_VAR 0 7
3486: PUSH
3487: LD_VAR 0 7
3491: PUSH
3492: LD_INT 2
3494: PUSH
3495: LD_INT 3
3497: PUSH
3498: LD_INT 4
3500: PUSH
3501: LD_INT 4
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: PUSH
3510: LD_OWVAR 67
3514: ARRAY
3515: PLUS
3516: ST_TO_ADDR
// for i = 1 to amount do
3517: LD_ADDR_VAR 0 1
3521: PUSH
3522: DOUBLE
3523: LD_INT 1
3525: DEC
3526: ST_TO_ADDR
3527: LD_VAR 0 7
3531: PUSH
3532: FOR_TO
3533: IFFALSE 3621
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3535: LD_ADDR_VAR 0 3
3539: PUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: LD_VAR 0 3
3549: PUSH
3550: LD_INT 1
3552: PLUS
3553: PPUSH
3554: LD_INT 23
3556: PUSH
3557: LD_INT 24
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 2
3569: PPUSH
3570: CALL_OW 12
3574: ARRAY
3575: PUSH
3576: LD_INT 1
3578: PUSH
3579: LD_INT 3
3581: PUSH
3582: LD_INT 46
3584: PUSH
3585: LD_INT 47
3587: PUSH
3588: LD_INT 45
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: LD_INT 1
3598: PPUSH
3599: LD_INT 3
3601: PPUSH
3602: CALL_OW 12
3606: ARRAY
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 2
3618: ST_TO_ADDR
3619: GO 3532
3621: POP
3622: POP
// MC_InsertProduceList ( base , tmp ) ;
3623: LD_VAR 0 2
3627: PPUSH
3628: LD_VAR 0 3
3632: PPUSH
3633: CALL 80630 0 2
// repeat wait ( 0 0$1 ) ;
3637: LD_INT 35
3639: PPUSH
3640: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3644: LD_VAR 0 2
3648: PPUSH
3649: LD_INT 1
3651: PPUSH
3652: CALL 82048 0 2
3656: PUSH
3657: LD_VAR 0 7
3661: GREATEREQUAL
3662: IFFALSE 3637
// wait ( 0 0$30 ) ;
3664: LD_INT 1050
3666: PPUSH
3667: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3671: LD_ADDR_VAR 0 5
3675: PUSH
3676: LD_INT 71
3678: PUSH
3679: LD_INT 19
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: LD_INT 91
3688: PUSH
3689: LD_INT 67
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: LD_INT 44
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: LD_INT 68
3708: PUSH
3709: LD_INT 48
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: PUSH
3716: EMPTY
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_EXP 80
3731: PUSH
3732: LD_VAR 0 2
3736: ARRAY
3737: PUSH
3738: LD_EXP 80
3742: PUSH
3743: LD_VAR 0 2
3747: ARRAY
3748: PPUSH
3749: LD_INT 2
3751: PUSH
3752: LD_INT 34
3754: PUSH
3755: LD_INT 51
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 34
3764: PUSH
3765: LD_INT 52
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 72
3781: DIFF
3782: ST_TO_ADDR
// if not attackers then
3783: LD_VAR 0 6
3787: NOT
3788: IFFALSE 3792
// exit ;
3790: GO 3998
// ru_attackers := attackers ;
3792: LD_ADDR_EXP 54
3796: PUSH
3797: LD_VAR 0 6
3801: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3802: LD_ADDR_EXP 80
3806: PUSH
3807: LD_EXP 80
3811: PPUSH
3812: LD_VAR 0 2
3816: PPUSH
3817: LD_EXP 80
3821: PUSH
3822: LD_VAR 0 2
3826: ARRAY
3827: PUSH
3828: LD_VAR 0 6
3832: DIFF
3833: PPUSH
3834: CALL_OW 1
3838: ST_TO_ADDR
// for i = 1 to attackers do
3839: LD_ADDR_VAR 0 1
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_VAR 0 6
3853: PUSH
3854: FOR_TO
3855: IFFALSE 3932
// begin case i mod 3 of 0 :
3857: LD_VAR 0 1
3861: PUSH
3862: LD_INT 3
3864: MOD
3865: PUSH
3866: LD_INT 0
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3877
3874: POP
// ; 1 :
3875: GO 3930
3877: LD_INT 1
3879: DOUBLE
3880: EQUAL
3881: IFTRUE 3885
3883: GO 3903
3885: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3886: LD_VAR 0 1
3890: PPUSH
3891: LD_INT 32
3893: PPUSH
3894: LD_INT 49
3896: PPUSH
3897: CALL_OW 114
3901: GO 3930
3903: LD_INT 2
3905: DOUBLE
3906: EQUAL
3907: IFTRUE 3911
3909: GO 3929
3911: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3912: LD_VAR 0 1
3916: PPUSH
3917: LD_INT 117
3919: PPUSH
3920: LD_INT 107
3922: PPUSH
3923: CALL_OW 114
3927: GO 3930
3929: POP
// end ;
3930: GO 3854
3932: POP
3933: POP
// repeat wait ( 0 0$1 ) ;
3934: LD_INT 35
3936: PPUSH
3937: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3941: LD_VAR 0 6
3945: PPUSH
3946: LD_INT 60
3948: PUSH
3949: EMPTY
3950: LIST
3951: PPUSH
3952: CALL_OW 72
3956: NOT
3957: IFFALSE 3934
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3959: LD_VAR 0 2
3963: PPUSH
3964: LD_VAR 0 6
3968: PPUSH
3969: LD_VAR 0 5
3973: PPUSH
3974: LD_VAR 0 4
3978: PPUSH
3979: CALL 80815 0 4
// if not first_attack then
3983: LD_EXP 7
3987: NOT
3988: IFFALSE 3998
// first_attack := true ;
3990: LD_ADDR_EXP 7
3994: PUSH
3995: LD_INT 1
3997: ST_TO_ADDR
// end ; end_of_file
3998: PPOPN 7
4000: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4001: LD_INT 0
4003: PPUSH
4004: PPUSH
4005: PPUSH
4006: PPUSH
4007: PPUSH
4008: PPUSH
4009: PPUSH
// uc_side := 2 ;
4010: LD_ADDR_OWVAR 20
4014: PUSH
4015: LD_INT 2
4017: ST_TO_ADDR
// uc_nation := 2 ;
4018: LD_ADDR_OWVAR 21
4022: PUSH
4023: LD_INT 2
4025: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4026: LD_ADDR_EXP 57
4030: PUSH
4031: LD_STRING Abdul
4033: PPUSH
4034: CALL_OW 25
4038: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4039: LD_EXP 57
4043: PPUSH
4044: LD_INT 11
4046: PPUSH
4047: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4051: LD_EXP 57
4055: PPUSH
4056: LD_INT 1
4058: PPUSH
4059: CALL_OW 52
// vc_chassis := 31 ;
4063: LD_ADDR_OWVAR 37
4067: PUSH
4068: LD_INT 31
4070: ST_TO_ADDR
// vc_control := control_rider ;
4071: LD_ADDR_OWVAR 38
4075: PUSH
4076: LD_INT 4
4078: ST_TO_ADDR
// mastodont := CreateVehicle ;
4079: LD_ADDR_EXP 58
4083: PUSH
4084: CALL_OW 45
4088: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4089: LD_EXP 58
4093: PPUSH
4094: LD_INT 153
4096: PPUSH
4097: LD_INT 71
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 48
// InitVc ;
4107: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4111: LD_ADDR_EXP 55
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: LD_STRING 
4124: PPUSH
4125: LD_INT 7
4127: PUSH
4128: LD_INT 8
4130: PUSH
4131: LD_INT 9
4133: PUSH
4134: LD_INT 10
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PPUSH
4149: LD_INT 5000
4151: PUSH
4152: LD_INT 1000
4154: PUSH
4155: LD_INT 300
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: LIST
4162: PPUSH
4163: LD_INT 18
4165: PUSH
4166: LD_INT 5
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: LIST
4180: PPUSH
4181: CALL 23392 0 6
4185: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4186: LD_ADDR_EXP 61
4190: PUSH
4191: LD_EXP 61
4195: PPUSH
4196: LD_INT 1
4198: PPUSH
4199: LD_EXP 55
4203: PPUSH
4204: CALL_OW 1
4208: ST_TO_ADDR
// tmp := [ ] ;
4209: LD_ADDR_VAR 0 4
4213: PUSH
4214: EMPTY
4215: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4216: LD_ADDR_OWVAR 37
4220: PUSH
4221: LD_INT 14
4223: ST_TO_ADDR
// vc_engine := engine_siberite ;
4224: LD_ADDR_OWVAR 39
4228: PUSH
4229: LD_INT 3
4231: ST_TO_ADDR
// vc_control := control_manual ;
4232: LD_ADDR_OWVAR 38
4236: PUSH
4237: LD_INT 1
4239: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4240: LD_ADDR_OWVAR 40
4244: PUSH
4245: LD_INT 31
4247: ST_TO_ADDR
// for i = 1 to 3 do
4248: LD_ADDR_VAR 0 2
4252: PUSH
4253: DOUBLE
4254: LD_INT 1
4256: DEC
4257: ST_TO_ADDR
4258: LD_INT 3
4260: PUSH
4261: FOR_TO
4262: IFFALSE 4510
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4264: LD_ADDR_VAR 0 5
4268: PUSH
4269: LD_INT 153
4271: PUSH
4272: LD_INT 71
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 155
4281: PUSH
4282: LD_INT 81
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_VAR 0 2
4297: PUSH
4298: LD_INT 2
4300: MOD
4301: PUSH
4302: LD_INT 1
4304: PLUS
4305: ARRAY
4306: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4307: LD_INT 0
4309: PPUSH
4310: LD_INT 3
4312: PPUSH
4313: LD_INT 7
4315: PUSH
4316: LD_INT 8
4318: PUSH
4319: LD_INT 10
4321: PUSH
4322: LD_INT 10
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: LD_OWVAR 67
4335: ARRAY
4336: PPUSH
4337: CALL_OW 380
// un := CreateVehicle ;
4341: LD_ADDR_VAR 0 6
4345: PUSH
4346: CALL_OW 45
4350: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4351: LD_VAR 0 6
4355: PPUSH
4356: LD_INT 0
4358: PPUSH
4359: LD_INT 5
4361: PPUSH
4362: CALL_OW 12
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4371: LD_VAR 0 6
4375: PPUSH
4376: LD_VAR 0 5
4380: PUSH
4381: LD_INT 1
4383: ARRAY
4384: PPUSH
4385: LD_VAR 0 5
4389: PUSH
4390: LD_INT 2
4392: ARRAY
4393: PPUSH
4394: LD_INT 6
4396: PPUSH
4397: LD_INT 0
4399: PPUSH
4400: CALL_OW 50
// un2 := CreateHuman ;
4404: LD_ADDR_VAR 0 7
4408: PUSH
4409: CALL_OW 44
4413: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4414: LD_VAR 0 7
4418: PPUSH
4419: LD_VAR 0 6
4423: PPUSH
4424: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4428: LD_ADDR_EXP 61
4432: PUSH
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 1
4440: PUSH
4441: LD_EXP 61
4445: PUSH
4446: LD_INT 1
4448: ARRAY
4449: PUSH
4450: LD_INT 1
4452: PLUS
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PPUSH
4458: LD_VAR 0 6
4462: PPUSH
4463: CALL 20070 0 3
4467: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4468: LD_ADDR_EXP 61
4472: PUSH
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 1
4480: PUSH
4481: LD_EXP 61
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PUSH
4490: LD_INT 1
4492: PLUS
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PPUSH
4498: LD_VAR 0 7
4502: PPUSH
4503: CALL 20070 0 3
4507: ST_TO_ADDR
// end ;
4508: GO 4261
4510: POP
4511: POP
// for i = 1 to 5 do
4512: LD_ADDR_VAR 0 2
4516: PUSH
4517: DOUBLE
4518: LD_INT 1
4520: DEC
4521: ST_TO_ADDR
4522: LD_INT 5
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4619
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4528: LD_INT 14
4530: PPUSH
4531: LD_INT 3
4533: PPUSH
4534: LD_INT 1
4536: PPUSH
4537: LD_INT 25
4539: PUSH
4540: LD_INT 28
4542: PUSH
4543: LD_INT 28
4545: PUSH
4546: LD_INT 26
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: PUSH
4555: LD_VAR 0 2
4559: PUSH
4560: LD_INT 4
4562: MOD
4563: PUSH
4564: LD_INT 1
4566: PLUS
4567: ARRAY
4568: PPUSH
4569: LD_INT 100
4571: PPUSH
4572: CALL 19948 0 5
// veh := CreateVehicle ;
4576: LD_ADDR_VAR 0 3
4580: PUSH
4581: CALL_OW 45
4585: ST_TO_ADDR
// tmp := tmp ^ veh ;
4586: LD_ADDR_VAR 0 4
4590: PUSH
4591: LD_VAR 0 4
4595: PUSH
4596: LD_VAR 0 3
4600: ADD
4601: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4602: LD_VAR 0 3
4606: PPUSH
4607: LD_INT 1
4609: PPUSH
4610: LD_INT 0
4612: PPUSH
4613: CALL_OW 49
// end ;
4617: GO 4525
4619: POP
4620: POP
// arabian_guard := tmp ;
4621: LD_ADDR_EXP 56
4625: PUSH
4626: LD_VAR 0 4
4630: ST_TO_ADDR
// end ;
4631: LD_VAR 0 1
4635: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4636: LD_INT 22
4638: PUSH
4639: LD_INT 7
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 91
4648: PUSH
4649: LD_INT 1
4651: PUSH
4652: LD_INT 12
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PPUSH
4664: CALL_OW 69
4668: PUSH
4669: LD_EXP 58
4673: PPUSH
4674: CALL_OW 256
4678: PUSH
4679: LD_INT 990
4681: LESS
4682: OR
4683: PUSH
4684: LD_EXP 57
4688: PPUSH
4689: CALL_OW 256
4693: PUSH
4694: LD_INT 990
4696: LESS
4697: OR
4698: IFFALSE 4841
4700: GO 4702
4702: DISABLE
// begin if IsInUnit ( Abdul ) then
4703: LD_EXP 57
4707: PPUSH
4708: CALL_OW 310
4712: IFFALSE 4723
// ComExitBuilding ( Abdul ) ;
4714: LD_EXP 57
4718: PPUSH
4719: CALL_OW 122
// if Mastodont then
4723: LD_EXP 58
4727: IFFALSE 4744
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4729: LD_EXP 58
4733: PPUSH
4734: LD_INT 205
4736: PPUSH
4737: LD_INT 132
4739: PPUSH
4740: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4744: LD_EXP 57
4748: PPUSH
4749: LD_INT 205
4751: PPUSH
4752: LD_INT 132
4754: PPUSH
4755: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4759: LD_INT 35
4761: PPUSH
4762: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4766: LD_EXP 57
4770: PPUSH
4771: LD_INT 21
4773: PPUSH
4774: CALL_OW 308
4778: IFFALSE 4759
// RemoveUnit ( Abdul ) ;
4780: LD_EXP 57
4784: PPUSH
4785: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4789: LD_INT 35
4791: PPUSH
4792: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4796: LD_EXP 58
4800: PPUSH
4801: LD_INT 21
4803: PPUSH
4804: CALL_OW 308
4808: PUSH
4809: LD_EXP 58
4813: PPUSH
4814: CALL_OW 301
4818: OR
4819: IFFALSE 4789
// if IsOk ( Mastodont ) then
4821: LD_EXP 58
4825: PPUSH
4826: CALL_OW 302
4830: IFFALSE 4841
// RemoveUnit ( Mastodont ) ;
4832: LD_EXP 58
4836: PPUSH
4837: CALL_OW 64
// end ;
4841: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4842: LD_EXP 57
4846: PPUSH
4847: CALL_OW 301
4851: PUSH
4852: LD_INT 22
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 2
4864: PUSH
4865: LD_INT 25
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 25
4877: PUSH
4878: LD_INT 2
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 25
4887: PUSH
4888: LD_INT 3
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PUSH
4895: LD_INT 25
4897: PUSH
4898: LD_INT 4
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 8
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 69
4931: PUSH
4932: LD_INT 16
4934: PUSH
4935: LD_INT 19
4937: PUSH
4938: LD_INT 22
4940: PUSH
4941: LD_INT 22
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: PUSH
4950: LD_OWVAR 67
4954: ARRAY
4955: LESS
4956: OR
4957: IFFALSE 5630
4959: GO 4961
4961: DISABLE
4962: LD_INT 0
4964: PPUSH
4965: PPUSH
4966: PPUSH
4967: PPUSH
4968: PPUSH
4969: PPUSH
// begin MC_Kill ( 1 ) ;
4970: LD_INT 1
4972: PPUSH
4973: CALL 56603 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4977: LD_ADDR_VAR 0 2
4981: PUSH
4982: LD_INT 22
4984: PUSH
4985: LD_INT 2
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: PUSH
4992: LD_INT 2
4994: PUSH
4995: LD_INT 25
4997: PUSH
4998: LD_INT 1
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 25
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: LD_INT 25
5017: PUSH
5018: LD_INT 3
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 25
5027: PUSH
5028: LD_INT 4
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 25
5037: PUSH
5038: LD_INT 8
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: LIST
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 69
5061: ST_TO_ADDR
// for i in tmp do
5062: LD_ADDR_VAR 0 5
5066: PUSH
5067: LD_VAR 0 2
5071: PUSH
5072: FOR_IN
5073: IFFALSE 5089
// SetTag ( i , 10 ) ;
5075: LD_VAR 0 5
5079: PPUSH
5080: LD_INT 10
5082: PPUSH
5083: CALL_OW 109
5087: GO 5072
5089: POP
5090: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5091: LD_ADDR_VAR 0 3
5095: PUSH
5096: LD_INT 22
5098: PUSH
5099: LD_INT 2
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 21
5108: PUSH
5109: LD_INT 1
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: PUSH
5125: LD_VAR 0 2
5129: DIFF
5130: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5131: LD_ADDR_VAR 0 1
5135: PUSH
5136: LD_INT 22
5138: PUSH
5139: LD_INT 2
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PUSH
5146: LD_INT 21
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 24
5158: PUSH
5159: LD_INT 300
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: PPUSH
5171: CALL_OW 69
5175: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5176: LD_ADDR_VAR 0 4
5180: PUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: LD_INT 33
5188: PUSH
5189: LD_INT 1
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 58
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// for i in tmp do
5211: LD_ADDR_VAR 0 5
5215: PUSH
5216: LD_VAR 0 2
5220: PUSH
5221: FOR_IN
5222: IFFALSE 5406
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 55
5231: PUSH
5232: EMPTY
5233: LIST
5234: PPUSH
5235: CALL_OW 69
5239: IN
5240: IFFALSE 5259
// begin AddComMoveXY ( i , 209 , 132 ) ;
5242: LD_VAR 0 5
5246: PPUSH
5247: LD_INT 209
5249: PPUSH
5250: LD_INT 132
5252: PPUSH
5253: CALL_OW 171
// continue ;
5257: GO 5221
// end ; if IsInUnit ( i ) then
5259: LD_VAR 0 5
5263: PPUSH
5264: CALL_OW 310
5268: IFFALSE 5286
// begin ComExitBuilding ( i ) ;
5270: LD_VAR 0 5
5274: PPUSH
5275: CALL_OW 122
// wait ( 3 ) ;
5279: LD_INT 3
5281: PPUSH
5282: CALL_OW 67
// end ; if tmp_empty then
5286: LD_VAR 0 4
5290: IFFALSE 5389
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5292: LD_VAR 0 5
5296: PPUSH
5297: LD_VAR 0 4
5301: PPUSH
5302: LD_VAR 0 5
5306: PPUSH
5307: CALL_OW 74
5311: PPUSH
5312: CALL_OW 296
5316: PUSH
5317: LD_INT 25
5319: LESS
5320: IFFALSE 5389
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5322: LD_ADDR_VAR 0 6
5326: PUSH
5327: LD_VAR 0 4
5331: PPUSH
5332: LD_VAR 0 5
5336: PPUSH
5337: CALL_OW 74
5341: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5342: LD_VAR 0 5
5346: PPUSH
5347: LD_VAR 0 6
5351: PPUSH
5352: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5356: LD_VAR 0 5
5360: PPUSH
5361: LD_INT 209
5363: PPUSH
5364: LD_INT 132
5366: PPUSH
5367: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5371: LD_ADDR_VAR 0 4
5375: PUSH
5376: LD_VAR 0 4
5380: PUSH
5381: LD_VAR 0 6
5385: DIFF
5386: ST_TO_ADDR
// continue ;
5387: GO 5221
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5389: LD_VAR 0 5
5393: PPUSH
5394: LD_INT 201
5396: PPUSH
5397: LD_INT 132
5399: PPUSH
5400: CALL_OW 171
// end ;
5404: GO 5221
5406: POP
5407: POP
// for i in tmp_ape do
5408: LD_ADDR_VAR 0 5
5412: PUSH
5413: LD_VAR 0 3
5417: PUSH
5418: FOR_IN
5419: IFFALSE 5458
// begin if IsInUnit ( i ) then
5421: LD_VAR 0 5
5425: PPUSH
5426: CALL_OW 310
5430: IFFALSE 5441
// ComExitBuilding ( i ) ;
5432: LD_VAR 0 5
5436: PPUSH
5437: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_INT 201
5448: PPUSH
5449: LD_INT 132
5451: PPUSH
5452: CALL_OW 171
// end ;
5456: GO 5418
5458: POP
5459: POP
// repeat wait ( 0 0$1 ) ;
5460: LD_INT 35
5462: PPUSH
5463: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5467: LD_ADDR_VAR 0 5
5471: PUSH
5472: LD_VAR 0 2
5476: PUSH
5477: LD_VAR 0 3
5481: UNION
5482: PUSH
5483: LD_VAR 0 1
5487: UNION
5488: PUSH
5489: FOR_IN
5490: IFFALSE 5521
// if not HasTask ( i ) then
5492: LD_VAR 0 5
5496: PPUSH
5497: CALL_OW 314
5501: NOT
5502: IFFALSE 5519
// ComMoveXY ( i , 201 , 132 ) ;
5504: LD_VAR 0 5
5508: PPUSH
5509: LD_INT 201
5511: PPUSH
5512: LD_INT 132
5514: PPUSH
5515: CALL_OW 111
5519: GO 5489
5521: POP
5522: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5523: LD_INT 21
5525: PPUSH
5526: LD_INT 22
5528: PUSH
5529: LD_INT 2
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PPUSH
5536: CALL_OW 70
5540: IFFALSE 5581
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 21
5549: PPUSH
5550: LD_INT 22
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL_OW 70
5564: PUSH
5565: FOR_IN
5566: IFFALSE 5579
// RemoveUnit ( i ) ;
5568: LD_VAR 0 5
5572: PPUSH
5573: CALL_OW 64
5577: GO 5565
5579: POP
5580: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5581: LD_INT 22
5583: PUSH
5584: LD_INT 2
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 21
5596: PUSH
5597: LD_INT 1
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 21
5606: PUSH
5607: LD_INT 2
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: CALL_OW 69
5627: NOT
5628: IFFALSE 5460
// end ;
5630: PPOPN 6
5632: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5633: LD_EXP 9
5637: PUSH
5638: LD_INT 92
5640: PPUSH
5641: LD_INT 40
5643: PPUSH
5644: CALL_OW 428
5648: PPUSH
5649: CALL_OW 266
5653: PUSH
5654: LD_INT 30
5656: EQUAL
5657: AND
5658: IFFALSE 5854
5660: GO 5662
5662: DISABLE
5663: LD_INT 0
5665: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5666: LD_ADDR_VAR 0 1
5670: PUSH
5671: LD_EXP 61
5675: PUSH
5676: LD_INT 1
5678: ARRAY
5679: PPUSH
5680: LD_INT 25
5682: PUSH
5683: LD_INT 4
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PPUSH
5690: CALL_OW 72
5694: ST_TO_ADDR
// if not sci then
5695: LD_VAR 0 1
5699: NOT
5700: IFFALSE 5704
// exit ;
5702: GO 5854
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5704: LD_ADDR_EXP 61
5708: PUSH
5709: LD_EXP 61
5713: PPUSH
5714: LD_INT 1
5716: PPUSH
5717: LD_EXP 61
5721: PUSH
5722: LD_INT 1
5724: ARRAY
5725: PUSH
5726: LD_VAR 0 1
5730: PUSH
5731: LD_INT 1
5733: ARRAY
5734: DIFF
5735: PPUSH
5736: CALL_OW 1
5740: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5741: LD_VAR 0 1
5745: PUSH
5746: LD_INT 1
5748: ARRAY
5749: PPUSH
5750: CALL_OW 310
5754: IFFALSE 5769
// ComExitBuilding ( sci [ 1 ] ) ;
5756: LD_VAR 0 1
5760: PUSH
5761: LD_INT 1
5763: ARRAY
5764: PPUSH
5765: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5769: LD_INT 2
5771: PPUSH
5772: LD_INT 105
5774: PPUSH
5775: LD_INT 14
5777: PPUSH
5778: LD_INT 20
5780: PPUSH
5781: CALL 20966 0 4
5785: PUSH
5786: LD_INT 4
5788: ARRAY
5789: PUSH
5790: LD_INT 10
5792: LESS
5793: IFFALSE 5816
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5795: LD_VAR 0 1
5799: PUSH
5800: LD_INT 1
5802: ARRAY
5803: PPUSH
5804: LD_INT 105
5806: PPUSH
5807: LD_INT 14
5809: PPUSH
5810: CALL_OW 171
5814: GO 5835
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5816: LD_VAR 0 1
5820: PUSH
5821: LD_INT 1
5823: ARRAY
5824: PPUSH
5825: LD_INT 118
5827: PPUSH
5828: LD_INT 77
5830: PPUSH
5831: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5835: LD_VAR 0 1
5839: PUSH
5840: LD_INT 1
5842: ARRAY
5843: PPUSH
5844: LD_INT 92
5846: PPUSH
5847: LD_INT 40
5849: PPUSH
5850: CALL_OW 218
// end ;
5854: PPOPN 1
5856: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5857: LD_INT 1
5859: PPUSH
5860: CALL_OW 302
5864: PUSH
5865: LD_EXP 9
5869: AND
5870: IFFALSE 6347
5872: GO 5874
5874: DISABLE
5875: LD_INT 0
5877: PPUSH
5878: PPUSH
5879: PPUSH
5880: PPUSH
5881: PPUSH
5882: PPUSH
// begin enable ;
5883: ENABLE
// base := 1 ;
5884: LD_ADDR_VAR 0 2
5888: PUSH
5889: LD_INT 1
5891: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5892: LD_ADDR_VAR 0 4
5896: PUSH
5897: LD_INT 0
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: LD_INT 0
5905: PUSH
5906: LD_INT 0
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: LD_INT 0
5914: PUSH
5915: LD_INT 0
5917: PUSH
5918: LD_INT 0
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 0
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5939: LD_ADDR_VAR 0 3
5943: PUSH
5944: LD_INT 14
5946: PUSH
5947: LD_INT 1
5949: PUSH
5950: LD_INT 2
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: PUSH
5962: LD_INT 14
5964: PUSH
5965: LD_INT 1
5967: PUSH
5968: LD_INT 2
5970: PUSH
5971: LD_INT 28
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 13
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 29
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: LIST
5996: LIST
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6003: LD_ADDR_VAR 0 1
6007: PUSH
6008: DOUBLE
6009: LD_INT 1
6011: DEC
6012: ST_TO_ADDR
6013: LD_OWVAR 67
6017: PUSH
6018: LD_OWVAR 1
6022: PUSH
6023: LD_INT 21000
6025: DIV
6026: PLUS
6027: PUSH
6028: FOR_TO
6029: IFFALSE 6121
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6031: LD_ADDR_VAR 0 3
6035: PUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: LD_VAR 0 3
6045: PUSH
6046: LD_INT 1
6048: PLUS
6049: PPUSH
6050: LD_INT 13
6052: PUSH
6053: LD_INT 14
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PUSH
6060: LD_INT 1
6062: PPUSH
6063: LD_INT 2
6065: PPUSH
6066: CALL_OW 12
6070: ARRAY
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: LD_INT 2
6077: PUSH
6078: LD_INT 28
6080: PUSH
6081: LD_INT 29
6083: PUSH
6084: LD_INT 25
6086: PUSH
6087: LD_INT 26
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 1
6098: PPUSH
6099: LD_INT 4
6101: PPUSH
6102: CALL_OW 12
6106: ARRAY
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 2
6118: ST_TO_ADDR
6119: GO 6028
6121: POP
6122: POP
// MC_InsertProduceList ( base , tmp ) ;
6123: LD_VAR 0 2
6127: PPUSH
6128: LD_VAR 0 3
6132: PPUSH
6133: CALL 80630 0 2
// repeat wait ( 0 0$1 ) ;
6137: LD_INT 35
6139: PPUSH
6140: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6144: LD_EXP 80
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PUSH
6155: LD_INT 6
6157: GREATER
6158: IFFALSE 6137
// wait ( 0 0$20 ) ;
6160: LD_INT 700
6162: PPUSH
6163: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6167: LD_ADDR_VAR 0 5
6171: PUSH
6172: LD_INT 124
6174: PUSH
6175: LD_INT 85
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: LD_INT 90
6184: PUSH
6185: LD_INT 61
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 69
6194: PUSH
6195: LD_INT 48
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 68
6204: PUSH
6205: LD_INT 48
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6218: LD_ADDR_VAR 0 6
6222: PUSH
6223: LD_EXP 80
6227: PUSH
6228: LD_VAR 0 2
6232: ARRAY
6233: PUSH
6234: LD_EXP 80
6238: PUSH
6239: LD_VAR 0 2
6243: ARRAY
6244: PPUSH
6245: LD_INT 2
6247: PUSH
6248: LD_INT 34
6250: PUSH
6251: LD_INT 32
6253: PUSH
6254: EMPTY
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 34
6260: PUSH
6261: LD_INT 88
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 72
6277: DIFF
6278: ST_TO_ADDR
// if not attackers then
6279: LD_VAR 0 6
6283: NOT
6284: IFFALSE 6288
// exit ;
6286: GO 6347
// ar_attackers := attackers ;
6288: LD_ADDR_EXP 11
6292: PUSH
6293: LD_VAR 0 6
6297: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6298: LD_INT 35
6300: PPUSH
6301: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6305: LD_VAR 0 6
6309: PPUSH
6310: LD_INT 60
6312: PUSH
6313: EMPTY
6314: LIST
6315: PPUSH
6316: CALL_OW 72
6320: NOT
6321: IFFALSE 6298
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6323: LD_VAR 0 2
6327: PPUSH
6328: LD_VAR 0 6
6332: PPUSH
6333: LD_VAR 0 5
6337: PPUSH
6338: LD_VAR 0 4
6342: PPUSH
6343: CALL 80815 0 4
// end ;
6347: PPOPN 6
6349: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6350: LD_INT 1
6352: PPUSH
6353: CALL_OW 302
6357: PUSH
6358: LD_EXP 9
6362: AND
6363: PUSH
6364: LD_EXP 51
6368: PPUSH
6369: LD_INT 22
6371: PPUSH
6372: CALL_OW 308
6376: AND
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: CALL 80978 0 1
6385: PUSH
6386: LD_INT 0
6388: EQUAL
6389: AND
6390: PUSH
6391: LD_EXP 11
6395: NOT
6396: AND
6397: IFFALSE 6883
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
6407: PPUSH
6408: PPUSH
6409: PPUSH
6410: PPUSH
// begin base := 1 ;
6411: LD_ADDR_VAR 0 2
6415: PUSH
6416: LD_INT 1
6418: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6419: LD_ADDR_VAR 0 4
6423: PUSH
6424: LD_INT 0
6426: PUSH
6427: LD_INT 0
6429: PUSH
6430: LD_INT 0
6432: PUSH
6433: LD_INT 0
6435: PUSH
6436: LD_INT 0
6438: PUSH
6439: LD_INT 0
6441: PUSH
6442: LD_INT 0
6444: PUSH
6445: LD_INT 0
6447: PUSH
6448: LD_INT 1
6450: PUSH
6451: LD_INT 0
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6466: LD_ADDR_VAR 0 3
6470: PUSH
6471: LD_INT 13
6473: PUSH
6474: LD_INT 1
6476: PUSH
6477: LD_INT 2
6479: PUSH
6480: LD_INT 28
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 13
6491: PUSH
6492: LD_INT 1
6494: PUSH
6495: LD_INT 2
6497: PUSH
6498: LD_INT 27
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_INT 13
6509: PUSH
6510: LD_INT 1
6512: PUSH
6513: LD_INT 2
6515: PUSH
6516: LD_INT 25
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: PUSH
6525: LD_INT 11
6527: PUSH
6528: LD_INT 2
6530: PUSH
6531: LD_INT 2
6533: PUSH
6534: LD_INT 24
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: LIST
6541: LIST
6542: PUSH
6543: LD_INT 11
6545: PUSH
6546: LD_INT 2
6548: PUSH
6549: LD_INT 2
6551: PUSH
6552: LD_INT 24
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: LIST
6566: LIST
6567: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6568: LD_VAR 0 2
6572: PPUSH
6573: LD_VAR 0 3
6577: PPUSH
6578: CALL 80630 0 2
// repeat wait ( 0 0$1 ) ;
6582: LD_INT 35
6584: PPUSH
6585: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6589: LD_EXP 80
6593: PUSH
6594: LD_VAR 0 2
6598: ARRAY
6599: PUSH
6600: LD_INT 6
6602: GREATEREQUAL
6603: IFFALSE 6582
// wait ( 0 0$20 ) ;
6605: LD_INT 700
6607: PPUSH
6608: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6612: LD_ADDR_VAR 0 5
6616: PUSH
6617: LD_INT 119
6619: PUSH
6620: LD_INT 9
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6630: LD_ADDR_VAR 0 6
6634: PUSH
6635: LD_EXP 80
6639: PUSH
6640: LD_VAR 0 2
6644: ARRAY
6645: PUSH
6646: LD_EXP 80
6650: PUSH
6651: LD_VAR 0 2
6655: ARRAY
6656: PPUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 34
6662: PUSH
6663: LD_INT 32
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: PUSH
6670: LD_INT 34
6672: PUSH
6673: LD_INT 88
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL_OW 72
6689: DIFF
6690: ST_TO_ADDR
// if not attackers then
6691: LD_VAR 0 6
6695: NOT
6696: IFFALSE 6700
// exit ;
6698: GO 6883
// uc_side := 2 ;
6700: LD_ADDR_OWVAR 20
6704: PUSH
6705: LD_INT 2
6707: ST_TO_ADDR
// uc_nation := 2 ;
6708: LD_ADDR_OWVAR 21
6712: PUSH
6713: LD_INT 2
6715: ST_TO_ADDR
// InitHc ;
6716: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6720: LD_ADDR_VAR 0 1
6724: PUSH
6725: DOUBLE
6726: LD_INT 1
6728: DEC
6729: ST_TO_ADDR
6730: LD_INT 4
6732: PUSH
6733: LD_INT 5
6735: PUSH
6736: LD_INT 6
6738: PUSH
6739: LD_INT 6
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: LIST
6746: LIST
6747: PUSH
6748: LD_OWVAR 67
6752: ARRAY
6753: PUSH
6754: FOR_TO
6755: IFFALSE 6832
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6757: LD_INT 0
6759: PPUSH
6760: LD_INT 15
6762: PUSH
6763: LD_INT 17
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: PUSH
6770: LD_INT 1
6772: PPUSH
6773: LD_INT 2
6775: PPUSH
6776: CALL_OW 12
6780: ARRAY
6781: PPUSH
6782: LD_INT 8
6784: PPUSH
6785: CALL_OW 380
// un := CreateHuman ;
6789: LD_ADDR_VAR 0 7
6793: PUSH
6794: CALL_OW 44
6798: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6799: LD_VAR 0 7
6803: PPUSH
6804: LD_INT 23
6806: PPUSH
6807: LD_INT 0
6809: PPUSH
6810: CALL_OW 49
// attackers := attackers union un ;
6814: LD_ADDR_VAR 0 6
6818: PUSH
6819: LD_VAR 0 6
6823: PUSH
6824: LD_VAR 0 7
6828: UNION
6829: ST_TO_ADDR
// end ;
6830: GO 6754
6832: POP
6833: POP
// repeat wait ( 0 0$1 ) ;
6834: LD_INT 35
6836: PPUSH
6837: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6841: LD_VAR 0 6
6845: PPUSH
6846: LD_INT 60
6848: PUSH
6849: EMPTY
6850: LIST
6851: PPUSH
6852: CALL_OW 72
6856: NOT
6857: IFFALSE 6834
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6859: LD_VAR 0 2
6863: PPUSH
6864: LD_VAR 0 6
6868: PPUSH
6869: LD_VAR 0 5
6873: PPUSH
6874: LD_VAR 0 4
6878: PPUSH
6879: CALL 80815 0 4
// end ; end_of_file
6883: PPOPN 7
6885: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
6890: PPUSH
6891: PPUSH
6892: PPUSH
6893: PPUSH
// uc_side := 1 ;
6894: LD_ADDR_OWVAR 20
6898: PUSH
6899: LD_INT 1
6901: ST_TO_ADDR
// uc_nation := 1 ;
6902: LD_ADDR_OWVAR 21
6906: PUSH
6907: LD_INT 1
6909: ST_TO_ADDR
// InitHc ;
6910: CALL_OW 19
// InitVc ;
6914: CALL_OW 20
// tmp := [ ] ;
6918: LD_ADDR_VAR 0 3
6922: PUSH
6923: EMPTY
6924: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: DOUBLE
6931: LD_INT 1
6933: DEC
6934: ST_TO_ADDR
6935: LD_INT 6
6937: PUSH
6938: LD_INT 8
6940: PUSH
6941: LD_INT 10
6943: PUSH
6944: LD_INT 10
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: PUSH
6953: LD_OWVAR 67
6957: ARRAY
6958: PUSH
6959: FOR_TO
6960: IFFALSE 7234
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6962: LD_ADDR_VAR 0 5
6966: PUSH
6967: LD_INT 2
6969: PUSH
6970: LD_INT 4
6972: PUSH
6973: LD_INT 5
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 1
6983: PPUSH
6984: LD_INT 3
6986: PPUSH
6987: CALL_OW 12
6991: ARRAY
6992: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6993: LD_VAR 0 5
6997: PUSH
6998: LD_INT 2
7000: DOUBLE
7001: EQUAL
7002: IFTRUE 7006
7004: GO 7040
7006: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7007: LD_ADDR_VAR 0 6
7011: PUSH
7012: LD_INT 9
7014: PUSH
7015: LD_INT 5
7017: PUSH
7018: LD_INT 7
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 1
7028: PPUSH
7029: LD_INT 3
7031: PPUSH
7032: CALL_OW 12
7036: ARRAY
7037: ST_TO_ADDR
7038: GO 7129
7040: LD_INT 4
7042: DOUBLE
7043: EQUAL
7044: IFTRUE 7048
7046: GO 7086
7048: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7049: LD_ADDR_VAR 0 6
7053: PUSH
7054: LD_INT 9
7056: PUSH
7057: LD_INT 6
7059: PUSH
7060: LD_INT 6
7062: PUSH
7063: LD_INT 7
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 4
7077: PPUSH
7078: CALL_OW 12
7082: ARRAY
7083: ST_TO_ADDR
7084: GO 7129
7086: LD_INT 5
7088: DOUBLE
7089: EQUAL
7090: IFTRUE 7094
7092: GO 7128
7094: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7095: LD_ADDR_VAR 0 6
7099: PUSH
7100: LD_INT 9
7102: PUSH
7103: LD_INT 6
7105: PUSH
7106: LD_INT 7
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 3
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: ST_TO_ADDR
7126: GO 7129
7128: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7129: LD_VAR 0 5
7133: PPUSH
7134: LD_INT 1
7136: PUSH
7137: LD_INT 3
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: LD_INT 1
7146: PPUSH
7147: LD_INT 2
7149: PPUSH
7150: CALL_OW 12
7154: ARRAY
7155: PPUSH
7156: LD_INT 3
7158: PPUSH
7159: LD_VAR 0 6
7163: PPUSH
7164: LD_INT 70
7166: PPUSH
7167: LD_INT 90
7169: PPUSH
7170: CALL_OW 12
7174: PPUSH
7175: CALL 19948 0 5
// veh := CreateVehicle ;
7179: LD_ADDR_VAR 0 4
7183: PUSH
7184: CALL_OW 45
7188: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7189: LD_VAR 0 4
7193: PPUSH
7194: LD_INT 2
7196: PPUSH
7197: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7201: LD_VAR 0 4
7205: PPUSH
7206: LD_INT 17
7208: PPUSH
7209: LD_INT 0
7211: PPUSH
7212: CALL_OW 49
// tmp := tmp ^ veh ;
7216: LD_ADDR_VAR 0 3
7220: PUSH
7221: LD_VAR 0 3
7225: PUSH
7226: LD_VAR 0 4
7230: ADD
7231: ST_TO_ADDR
// end ;
7232: GO 6959
7234: POP
7235: POP
// if not tmp then
7236: LD_VAR 0 3
7240: NOT
7241: IFFALSE 7245
// exit ;
7243: GO 7354
// if not first_powell_attack then
7245: LD_EXP 12
7249: NOT
7250: IFFALSE 7260
// first_powell_attack := true ;
7252: LD_ADDR_EXP 12
7256: PUSH
7257: LD_INT 1
7259: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7260: LD_INT 70
7262: PPUSH
7263: CALL_OW 67
// for i in tmp do
7267: LD_ADDR_VAR 0 2
7271: PUSH
7272: LD_VAR 0 3
7276: PUSH
7277: FOR_IN
7278: IFFALSE 7345
// if IsOk ( i ) then
7280: LD_VAR 0 2
7284: PPUSH
7285: CALL_OW 302
7289: IFFALSE 7327
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7291: LD_VAR 0 2
7295: PPUSH
7296: LD_INT 81
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PPUSH
7306: CALL_OW 69
7310: PPUSH
7311: LD_VAR 0 2
7315: PPUSH
7316: CALL_OW 74
7320: PPUSH
7321: CALL_OW 115
7325: GO 7343
// tmp := tmp diff i ;
7327: LD_ADDR_VAR 0 3
7331: PUSH
7332: LD_VAR 0 3
7336: PUSH
7337: LD_VAR 0 2
7341: DIFF
7342: ST_TO_ADDR
7343: GO 7277
7345: POP
7346: POP
// until not tmp ;
7347: LD_VAR 0 3
7351: NOT
7352: IFFALSE 7260
// end ; end_of_file
7354: LD_VAR 0 1
7358: RET
// export function Action ; var tmp , i , un ; begin
7359: LD_INT 0
7361: PPUSH
7362: PPUSH
7363: PPUSH
7364: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7365: LD_INT 68
7367: PPUSH
7368: LD_INT 39
7370: PPUSH
7371: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7375: LD_ADDR_VAR 0 2
7379: PUSH
7380: LD_INT 22
7382: PUSH
7383: LD_INT 7
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PPUSH
7390: CALL_OW 69
7394: ST_TO_ADDR
// InGameOn ;
7395: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7399: LD_VAR 0 2
7403: PPUSH
7404: LD_INT 71
7406: PPUSH
7407: LD_INT 49
7409: PPUSH
7410: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7414: LD_INT 35
7416: PPUSH
7417: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7421: LD_INT 7
7423: PPUSH
7424: LD_INT 71
7426: PPUSH
7427: LD_INT 51
7429: PPUSH
7430: CALL_OW 293
7434: IFFALSE 7414
// DialogueOn ;
7436: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7440: LD_EXP 16
7444: PPUSH
7445: LD_STRING D1-JMM-1
7447: PPUSH
7448: CALL_OW 88
// if Joan then
7452: LD_EXP 31
7456: IFFALSE 7470
// Say ( Joan , D1-Joan-1 ) ;
7458: LD_EXP 31
7462: PPUSH
7463: LD_STRING D1-Joan-1
7465: PPUSH
7466: CALL_OW 88
// if Lisa then
7470: LD_EXP 18
7474: IFFALSE 7488
// Say ( Lisa , D1-Lisa-1 ) ;
7476: LD_EXP 18
7480: PPUSH
7481: LD_STRING D1-Lisa-1
7483: PPUSH
7484: CALL_OW 88
// if Joan or Lisa then
7488: LD_EXP 31
7492: PUSH
7493: LD_EXP 18
7497: OR
7498: IFFALSE 7512
// Say ( JMM , D1-JMM-2 ) ;
7500: LD_EXP 16
7504: PPUSH
7505: LD_STRING D1-JMM-2
7507: PPUSH
7508: CALL_OW 88
// DialogueOff ;
7512: CALL_OW 7
// InGameOff ;
7516: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7520: LD_INT 71
7522: PPUSH
7523: LD_INT 50
7525: PPUSH
7526: LD_INT 7
7528: PPUSH
7529: LD_INT 30
7531: NEG
7532: PPUSH
7533: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7537: LD_INT 71
7539: PPUSH
7540: LD_INT 50
7542: PPUSH
7543: LD_INT 7
7545: PPUSH
7546: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7550: LD_STRING M1
7552: PPUSH
7553: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7557: LD_INT 35
7559: PPUSH
7560: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7564: LD_EXP 3
7568: PUSH
7569: LD_OWVAR 1
7573: PUSH
7574: LD_INT 2100
7576: GREATER
7577: OR
7578: IFFALSE 7557
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7580: LD_INT 350
7582: PPUSH
7583: LD_INT 700
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareGossudarov ;
7595: CALL 1918 0 0
// repeat wait ( 0 0$1 ) ;
7599: LD_INT 35
7601: PPUSH
7602: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7606: LD_INT 22
7608: PUSH
7609: LD_INT 6
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: LD_INT 3
7618: PUSH
7619: LD_INT 24
7621: PUSH
7622: LD_INT 1000
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL_OW 69
7641: PUSH
7642: LD_INT 7
7644: PPUSH
7645: LD_EXP 34
7649: PPUSH
7650: CALL_OW 292
7654: OR
7655: IFFALSE 7599
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7657: LD_ADDR_VAR 0 2
7661: PUSH
7662: LD_INT 22
7664: PUSH
7665: LD_INT 6
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: ST_TO_ADDR
// for i in tmp do
7677: LD_ADDR_VAR 0 3
7681: PUSH
7682: LD_VAR 0 2
7686: PUSH
7687: FOR_IN
7688: IFFALSE 7704
// SetSide ( i , 7 ) ;
7690: LD_VAR 0 3
7694: PPUSH
7695: LD_INT 7
7697: PPUSH
7698: CALL_OW 235
7702: GO 7687
7704: POP
7705: POP
// DialogueOn ;
7706: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7710: LD_EXP 16
7714: PUSH
7715: LD_EXP 17
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PPUSH
7724: LD_EXP 34
7728: PPUSH
7729: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7733: LD_EXP 34
7737: PPUSH
7738: CALL_OW 87
// if not Roth then
7742: LD_EXP 17
7746: NOT
7747: IFFALSE 7839
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7749: LD_VAR 0 2
7753: PPUSH
7754: LD_INT 3
7756: PUSH
7757: LD_INT 24
7759: PUSH
7760: LD_INT 1000
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: PPUSH
7771: CALL_OW 72
7775: IFFALSE 7789
// Say ( JMM , D2-JMM-1 ) ;
7777: LD_EXP 16
7781: PPUSH
7782: LD_STRING D2-JMM-1
7784: PPUSH
7785: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7789: LD_EXP 16
7793: PPUSH
7794: LD_STRING D2-JMM-1b
7796: PPUSH
7797: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7801: LD_EXP 34
7805: PPUSH
7806: LD_STRING D2-Gos-1
7808: PPUSH
7809: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7813: LD_EXP 16
7817: PPUSH
7818: LD_STRING D2-JMM-2
7820: PPUSH
7821: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7825: LD_EXP 34
7829: PPUSH
7830: LD_STRING D2-Gos-2
7832: PPUSH
7833: CALL_OW 88
// end else
7837: GO 7991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7839: LD_VAR 0 2
7843: PPUSH
7844: LD_INT 3
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 1000
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 72
7865: IFFALSE 7891
// begin Say ( Roth , D2-Roth-2 ) ;
7867: LD_EXP 17
7871: PPUSH
7872: LD_STRING D2-Roth-2
7874: PPUSH
7875: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7879: LD_EXP 16
7883: PPUSH
7884: LD_STRING D2-JMM-1a
7886: PPUSH
7887: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7891: LD_EXP 17
7895: PPUSH
7896: LD_STRING D2-Roth-2a
7898: PPUSH
7899: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7903: LD_EXP 17
7907: PPUSH
7908: LD_STRING D2-Roth-2b
7910: PPUSH
7911: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7915: LD_EXP 16
7919: PPUSH
7920: LD_STRING D2-JMM-3
7922: PPUSH
7923: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7927: LD_VAR 0 2
7931: PPUSH
7932: LD_INT 3
7934: PUSH
7935: LD_INT 24
7937: PUSH
7938: LD_INT 1000
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 72
7953: IFFALSE 7991
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7955: LD_EXP 34
7959: PPUSH
7960: LD_STRING D2-Gos-3
7962: PPUSH
7963: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7967: LD_EXP 16
7971: PPUSH
7972: LD_STRING D2-JMM-4
7974: PPUSH
7975: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7979: LD_EXP 34
7983: PPUSH
7984: LD_STRING D2-Gos-4
7986: PPUSH
7987: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7991: LD_EXP 16
7995: PPUSH
7996: LD_STRING D2-JMM-5
7998: PPUSH
7999: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8003: LD_EXP 34
8007: PPUSH
8008: LD_STRING D2-Gos-5
8010: PPUSH
8011: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8015: LD_EXP 16
8019: PPUSH
8020: LD_STRING D2-JMM-6
8022: PPUSH
8023: CALL_OW 88
// DialogueOff ;
8027: CALL_OW 7
// wait ( 0 0$2 ) ;
8031: LD_INT 70
8033: PPUSH
8034: CALL_OW 67
// if Kirilenkova then
8038: LD_EXP 35
8042: IFFALSE 8056
// Say ( Kirilenkova , D3-Kir-1 ) ;
8044: LD_EXP 35
8048: PPUSH
8049: LD_STRING D3-Kir-1
8051: PPUSH
8052: CALL_OW 88
// gossudarov_arrive := true ;
8056: LD_ADDR_EXP 4
8060: PUSH
8061: LD_INT 1
8063: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8064: LD_INT 35
8066: PPUSH
8067: CALL_OW 67
// until ru_lab_builded ;
8071: LD_EXP 5
8075: IFFALSE 8064
// DialogueOn ;
8077: CALL_OW 6
// if Kirilenkova then
8081: LD_EXP 35
8085: IFFALSE 8101
// Say ( Kirilenkova , D3a-Kir-1 ) else
8087: LD_EXP 35
8091: PPUSH
8092: LD_STRING D3a-Kir-1
8094: PPUSH
8095: CALL_OW 88
8099: GO 8123
// begin un := SciRu ;
8101: LD_ADDR_VAR 0 4
8105: PUSH
8106: CALL 13317 0 0
8110: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8111: LD_VAR 0 4
8115: PPUSH
8116: LD_STRING D3a-Sci1-1
8118: PPUSH
8119: CALL_OW 88
// end ; if Kirilenkova or un then
8123: LD_EXP 35
8127: PUSH
8128: LD_VAR 0 4
8132: OR
8133: IFFALSE 8147
// Say ( JMM , D3a-JMM-1 ) ;
8135: LD_EXP 16
8139: PPUSH
8140: LD_STRING D3a-JMM-1
8142: PPUSH
8143: CALL_OW 88
// DialogueOff ;
8147: CALL_OW 7
// end ;
8151: LD_VAR 0 1
8155: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8156: LD_EXP 4
8160: PUSH
8161: LD_INT 22
8163: PUSH
8164: LD_INT 7
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 2
8173: PUSH
8174: LD_INT 25
8176: PUSH
8177: LD_INT 1
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: PUSH
8184: LD_INT 25
8186: PUSH
8187: LD_INT 2
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PUSH
8194: LD_INT 25
8196: PUSH
8197: LD_INT 3
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 25
8206: PUSH
8207: LD_INT 4
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 25
8216: PUSH
8217: LD_INT 5
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: LD_INT 25
8226: PUSH
8227: LD_INT 8
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 25
8236: PUSH
8237: LD_INT 9
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PPUSH
8258: CALL_OW 69
8262: PUSH
8263: LD_INT 7
8265: LESS
8266: AND
8267: IFFALSE 8279
8269: GO 8271
8271: DISABLE
// YouLost ( TooMany ) ;
8272: LD_STRING TooMany
8274: PPUSH
8275: CALL_OW 104
8279: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8280: LD_EXP 34
8284: PPUSH
8285: CALL_OW 255
8289: PUSH
8290: LD_INT 7
8292: EQUAL
8293: IFFALSE 8510
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
8301: PPUSH
8302: PPUSH
// begin uc_side := 3 ;
8303: LD_ADDR_OWVAR 20
8307: PUSH
8308: LD_INT 3
8310: ST_TO_ADDR
// uc_nation := 3 ;
8311: LD_ADDR_OWVAR 21
8315: PUSH
8316: LD_INT 3
8318: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8319: LD_INT 21
8321: PPUSH
8322: LD_INT 3
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 42
8330: PPUSH
8331: LD_INT 100
8333: PPUSH
8334: CALL 19948 0 5
// un := CreateVehicle ;
8338: LD_ADDR_VAR 0 3
8342: PUSH
8343: CALL_OW 45
8347: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8348: LD_VAR 0 3
8352: PPUSH
8353: LD_INT 15
8355: PPUSH
8356: LD_INT 0
8358: PPUSH
8359: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8363: LD_VAR 0 3
8367: PPUSH
8368: LD_INT 67
8370: PPUSH
8371: LD_INT 45
8373: PPUSH
8374: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8378: LD_VAR 0 3
8382: PPUSH
8383: LD_INT 70
8385: PPUSH
8386: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8390: LD_VAR 0 3
8394: PPUSH
8395: LD_INT 69
8397: PPUSH
8398: LD_INT 18
8400: PPUSH
8401: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 60
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8420: LD_INT 35
8422: PPUSH
8423: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8427: LD_VAR 0 3
8431: PPUSH
8432: CALL_OW 302
8436: NOT
8437: PUSH
8438: LD_VAR 0 3
8442: PPUSH
8443: LD_INT 17
8445: PPUSH
8446: CALL_OW 308
8450: OR
8451: PUSH
8452: LD_VAR 0 3
8456: PPUSH
8457: LD_INT 60
8459: PPUSH
8460: LD_INT 3
8462: PPUSH
8463: CALL_OW 307
8467: OR
8468: IFFALSE 8420
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8470: LD_VAR 0 3
8474: PPUSH
8475: LD_INT 17
8477: PPUSH
8478: CALL_OW 308
8482: PUSH
8483: LD_VAR 0 3
8487: PPUSH
8488: LD_INT 60
8490: PPUSH
8491: LD_INT 3
8493: PPUSH
8494: CALL_OW 307
8498: OR
8499: IFFALSE 8510
// RemoveUnit ( un ) ;
8501: LD_VAR 0 3
8505: PPUSH
8506: CALL_OW 64
// end ;
8510: PPOPN 3
8512: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8513: LD_EXP 4
8517: IFFALSE 8759
8519: GO 8521
8521: DISABLE
8522: LD_INT 0
8524: PPUSH
8525: PPUSH
8526: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8527: LD_INT 70
8529: PPUSH
8530: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: LD_INT 22
8541: PUSH
8542: LD_INT 7
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 101
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PPUSH
8563: CALL_OW 69
8567: ST_TO_ADDR
// until tmp ;
8568: LD_VAR 0 3
8572: IFFALSE 8527
// un := NearestUnitToUnit ( tmp , JMM ) ;
8574: LD_ADDR_VAR 0 2
8578: PUSH
8579: LD_VAR 0 3
8583: PPUSH
8584: LD_EXP 16
8588: PPUSH
8589: CALL_OW 74
8593: ST_TO_ADDR
// player_spotted := true ;
8594: LD_ADDR_EXP 6
8598: PUSH
8599: LD_INT 1
8601: ST_TO_ADDR
// tmp := SciRu ;
8602: LD_ADDR_VAR 0 3
8606: PUSH
8607: CALL 13317 0 0
8611: ST_TO_ADDR
// if not tmp then
8612: LD_VAR 0 3
8616: NOT
8617: IFFALSE 8629
// tmp := SolRu ;
8619: LD_ADDR_VAR 0 3
8623: PUSH
8624: CALL 13464 0 0
8628: ST_TO_ADDR
// DialogueOn ;
8629: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 250
8642: PPUSH
8643: LD_VAR 0 2
8647: PPUSH
8648: CALL_OW 251
8652: PPUSH
8653: LD_INT 7
8655: PPUSH
8656: LD_INT 8
8658: NEG
8659: PPUSH
8660: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8664: LD_VAR 0 2
8668: PPUSH
8669: CALL_OW 87
// if tmp then
8673: LD_VAR 0 3
8677: IFFALSE 8691
// Say ( tmp , D4-RSci1-1 ) ;
8679: LD_VAR 0 3
8683: PPUSH
8684: LD_STRING D4-RSci1-1
8686: PPUSH
8687: CALL_OW 88
// if Gossudarov then
8691: LD_EXP 34
8695: IFFALSE 8721
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8697: LD_EXP 34
8701: PPUSH
8702: LD_STRING D4-Gos-1
8704: PPUSH
8705: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8709: LD_EXP 16
8713: PPUSH
8714: LD_STRING D4-JMM-1
8716: PPUSH
8717: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8721: LD_VAR 0 2
8725: PPUSH
8726: CALL_OW 250
8730: PPUSH
8731: LD_VAR 0 2
8735: PPUSH
8736: CALL_OW 251
8740: PPUSH
8741: LD_INT 7
8743: PPUSH
8744: CALL_OW 331
// DialogueOff ;
8748: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8752: LD_STRING M5
8754: PPUSH
8755: CALL_OW 337
// end ;
8759: PPOPN 3
8761: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8762: LD_EXP 6
8766: IFFALSE 9359
8768: GO 8770
8770: DISABLE
8771: LD_INT 0
8773: PPUSH
8774: PPUSH
8775: PPUSH
// begin PrepareBelkov ;
8776: CALL 2231 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8780: LD_EXP 49
8784: PPUSH
8785: LD_INT 118
8787: PPUSH
8788: LD_INT 106
8790: PPUSH
8791: CALL_OW 111
// AddComHold ( Belkov ) ;
8795: LD_EXP 49
8799: PPUSH
8800: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8811: LD_EXP 49
8815: PPUSH
8816: LD_INT 118
8818: PPUSH
8819: LD_INT 106
8821: PPUSH
8822: CALL_OW 307
8826: IFFALSE 8804
// ChangeSideFog ( 4 , 7 ) ;
8828: LD_INT 4
8830: PPUSH
8831: LD_INT 7
8833: PPUSH
8834: CALL_OW 343
// if IsOk ( Belkov ) then
8838: LD_EXP 49
8842: PPUSH
8843: CALL_OW 302
8847: IFFALSE 8931
// begin InGameOn ;
8849: CALL_OW 8
// DialogueOn ;
8853: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8857: LD_EXP 49
8861: PPUSH
8862: LD_STRING D5-Bel-1
8864: PPUSH
8865: CALL_OW 94
// if Gossudarov then
8869: LD_EXP 34
8873: IFFALSE 8923
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8875: LD_EXP 34
8879: PPUSH
8880: LD_STRING D5-Gos-1
8882: PPUSH
8883: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8887: LD_EXP 16
8891: PPUSH
8892: LD_STRING D5-JMM-1
8894: PPUSH
8895: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8899: LD_EXP 34
8903: PPUSH
8904: LD_STRING D5-Gos-2
8906: PPUSH
8907: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8911: LD_EXP 16
8915: PPUSH
8916: LD_STRING D5-JMM-2
8918: PPUSH
8919: CALL_OW 88
// end ; DialogueOff ;
8923: CALL_OW 7
// InGameOff ;
8927: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8931: LD_STRING QSaveBelkov
8933: PPUSH
8934: CALL_OW 97
8938: PUSH
8939: LD_INT 1
8941: DOUBLE
8942: EQUAL
8943: IFTRUE 8947
8945: GO 8997
8947: POP
// begin DialogueOn ;
8948: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8952: LD_EXP 16
8956: PPUSH
8957: LD_STRING D5a-JMM-1
8959: PPUSH
8960: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8964: LD_EXP 49
8968: PPUSH
8969: LD_STRING D5a-Bel-1
8971: PPUSH
8972: CALL_OW 94
// DialogueOff ;
8976: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8980: LD_EXP 49
8984: PPUSH
8985: LD_INT 83
8987: PPUSH
8988: LD_INT 49
8990: PPUSH
8991: CALL_OW 111
// end ; 2 :
8995: GO 9030
8997: LD_INT 2
8999: DOUBLE
9000: EQUAL
9001: IFTRUE 9005
9003: GO 9029
9005: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9006: LD_EXP 16
9010: PPUSH
9011: LD_STRING D5a-JMM-2
9013: PPUSH
9014: CALL_OW 88
// ComHold ( Belkov ) ;
9018: LD_EXP 49
9022: PPUSH
9023: CALL_OW 140
// end ; end ;
9027: GO 9030
9029: POP
// time := 0 0$00 ;
9030: LD_ADDR_VAR 0 1
9034: PUSH
9035: LD_INT 0
9037: ST_TO_ADDR
// vehSpawned := false ;
9038: LD_ADDR_VAR 0 3
9042: PUSH
9043: LD_INT 0
9045: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9046: LD_INT 35
9048: PPUSH
9049: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9053: LD_VAR 0 1
9057: PUSH
9058: LD_INT 350
9060: PUSH
9061: LD_INT 175
9063: PUSH
9064: LD_INT 105
9066: PUSH
9067: LD_INT 70
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_OWVAR 67
9080: ARRAY
9081: GREATEREQUAL
9082: PUSH
9083: LD_VAR 0 3
9087: NOT
9088: AND
9089: IFFALSE 9179
// begin vehSpawned := true ;
9091: LD_ADDR_VAR 0 3
9095: PUSH
9096: LD_INT 1
9098: ST_TO_ADDR
// uc_side := 3 ;
9099: LD_ADDR_OWVAR 20
9103: PUSH
9104: LD_INT 3
9106: ST_TO_ADDR
// uc_nation := 3 ;
9107: LD_ADDR_OWVAR 21
9111: PUSH
9112: LD_INT 3
9114: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9115: LD_INT 22
9117: PPUSH
9118: LD_INT 3
9120: PPUSH
9121: LD_INT 3
9123: PPUSH
9124: LD_INT 43
9126: PPUSH
9127: LD_INT 100
9129: PPUSH
9130: CALL 19948 0 5
// veh := CreateVehicle ;
9134: LD_ADDR_VAR 0 2
9138: PUSH
9139: CALL_OW 45
9143: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9144: LD_VAR 0 2
9148: PPUSH
9149: LD_INT 130
9151: PPUSH
9152: LD_INT 131
9154: PPUSH
9155: LD_INT 0
9157: PPUSH
9158: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9162: LD_VAR 0 2
9166: PPUSH
9167: LD_INT 100
9169: PPUSH
9170: LD_INT 82
9172: PPUSH
9173: CALL_OW 114
// end else
9177: GO 9193
// time := time + 0 0$1 ;
9179: LD_ADDR_VAR 0 1
9183: PUSH
9184: LD_VAR 0 1
9188: PUSH
9189: LD_INT 35
9191: PLUS
9192: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9193: LD_EXP 49
9197: PPUSH
9198: CALL_OW 301
9202: PUSH
9203: LD_EXP 49
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_INT 4
9215: EQUAL
9216: AND
9217: PUSH
9218: LD_INT 22
9220: PUSH
9221: LD_INT 7
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: PPUSH
9228: CALL_OW 69
9232: PPUSH
9233: LD_EXP 49
9237: PPUSH
9238: CALL_OW 74
9242: PPUSH
9243: LD_EXP 49
9247: PPUSH
9248: CALL_OW 296
9252: PUSH
9253: LD_INT 10
9255: LESS
9256: OR
9257: IFFALSE 9046
// if IsDead ( Belkov ) then
9259: LD_EXP 49
9263: PPUSH
9264: CALL_OW 301
9268: IFFALSE 9293
// begin CenterNowOnUnits ( Belkov ) ;
9270: LD_EXP 49
9274: PPUSH
9275: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9279: LD_EXP 16
9283: PPUSH
9284: LD_STRING D5a-JMM-2a
9286: PPUSH
9287: CALL_OW 88
// exit ;
9291: GO 9359
// end ; if See ( 7 , Belkov ) then
9293: LD_INT 7
9295: PPUSH
9296: LD_EXP 49
9300: PPUSH
9301: CALL_OW 292
9305: IFFALSE 9319
// SetSide ( Belkov , 7 ) ;
9307: LD_EXP 49
9311: PPUSH
9312: LD_INT 7
9314: PPUSH
9315: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9319: LD_INT 35
9321: PPUSH
9322: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9326: LD_EXP 49
9330: PPUSH
9331: LD_INT 66
9333: PPUSH
9334: LD_INT 45
9336: PPUSH
9337: CALL_OW 297
9341: PUSH
9342: LD_INT 30
9344: LESS
9345: IFFALSE 9319
// Say ( Belkov , D6-Bel-1 ) ;
9347: LD_EXP 49
9351: PPUSH
9352: LD_STRING D6-Bel-1
9354: PPUSH
9355: CALL_OW 88
// end ;
9359: PPOPN 3
9361: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9362: LD_EXP 49
9366: PPUSH
9367: CALL_OW 302
9371: PUSH
9372: LD_EXP 49
9376: PPUSH
9377: CALL_OW 504
9381: PUSH
9382: LD_INT 2
9384: PUSH
9385: LD_INT 34
9387: PUSH
9388: LD_INT 47
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PUSH
9395: LD_INT 34
9397: PUSH
9398: LD_INT 45
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: IN
9415: AND
9416: IFFALSE 9433
9418: GO 9420
9420: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9421: LD_EXP 49
9425: PPUSH
9426: LD_STRING D7-Bel-1
9428: PPUSH
9429: CALL_OW 88
9433: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9434: LD_INT 22
9436: PUSH
9437: LD_INT 7
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: PUSH
9444: LD_INT 101
9446: PUSH
9447: LD_INT 2
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PPUSH
9458: CALL_OW 69
9462: PUSH
9463: LD_EXP 8
9467: NOT
9468: AND
9469: PUSH
9470: LD_EXP 48
9474: PPUSH
9475: CALL_OW 305
9479: NOT
9480: AND
9481: IFFALSE 9951
9483: GO 9485
9485: DISABLE
9486: LD_INT 0
9488: PPUSH
// begin ar_base_spotted := true ;
9489: LD_ADDR_EXP 8
9493: PUSH
9494: LD_INT 1
9496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9497: LD_ADDR_VAR 0 1
9501: PUSH
9502: LD_INT 22
9504: PUSH
9505: LD_INT 2
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 21
9514: PUSH
9515: LD_INT 3
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 69
9530: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9531: LD_ADDR_VAR 0 1
9535: PUSH
9536: LD_VAR 0 1
9540: PPUSH
9541: LD_EXP 16
9545: PPUSH
9546: CALL_OW 74
9550: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9551: LD_INT 7
9553: PPUSH
9554: LD_INT 3
9556: PPUSH
9557: CALL_OW 332
// DialogueOn ;
9561: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9565: LD_VAR 0 1
9569: PPUSH
9570: CALL_OW 250
9574: PPUSH
9575: LD_VAR 0 1
9579: PPUSH
9580: CALL_OW 251
9584: PPUSH
9585: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9589: LD_ADDR_VAR 0 1
9593: PUSH
9594: LD_INT 22
9596: PUSH
9597: LD_INT 7
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 23
9606: PUSH
9607: LD_INT 1
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 26
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PPUSH
9629: CALL_OW 69
9633: PUSH
9634: LD_EXP 16
9638: PUSH
9639: LD_EXP 20
9643: PUSH
9644: LD_EXP 21
9648: PUSH
9649: LD_EXP 28
9653: PUSH
9654: LD_EXP 17
9658: PUSH
9659: LD_EXP 26
9663: PUSH
9664: LD_EXP 22
9668: PUSH
9669: LD_EXP 24
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: DIFF
9684: ST_TO_ADDR
// if not tmp then
9685: LD_VAR 0 1
9689: NOT
9690: IFFALSE 9764
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9692: LD_ADDR_VAR 0 1
9696: PUSH
9697: LD_INT 22
9699: PUSH
9700: LD_INT 7
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 23
9709: PUSH
9710: LD_INT 1
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PUSH
9717: LD_INT 26
9719: PUSH
9720: LD_INT 2
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: PUSH
9727: EMPTY
9728: LIST
9729: LIST
9730: LIST
9731: PPUSH
9732: CALL_OW 69
9736: PUSH
9737: LD_EXP 31
9741: PUSH
9742: LD_EXP 18
9746: PUSH
9747: LD_EXP 29
9751: PUSH
9752: LD_EXP 30
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: DIFF
9763: ST_TO_ADDR
// if tmp then
9764: LD_VAR 0 1
9768: IFFALSE 9839
// case GetSex ( tmp [ 1 ] ) of sex_male :
9770: LD_VAR 0 1
9774: PUSH
9775: LD_INT 1
9777: ARRAY
9778: PPUSH
9779: CALL_OW 258
9783: PUSH
9784: LD_INT 1
9786: DOUBLE
9787: EQUAL
9788: IFTRUE 9792
9790: GO 9811
9792: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9793: LD_VAR 0 1
9797: PUSH
9798: LD_INT 1
9800: ARRAY
9801: PPUSH
9802: LD_STRING D9-Sol1-1
9804: PPUSH
9805: CALL_OW 88
9809: GO 9839
9811: LD_INT 2
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9838
9819: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9820: LD_VAR 0 1
9824: PUSH
9825: LD_INT 1
9827: ARRAY
9828: PPUSH
9829: LD_STRING D9-FSol1-1
9831: PPUSH
9832: CALL_OW 88
9836: GO 9839
9838: POP
// if Frank then
9839: LD_EXP 28
9843: IFFALSE 9947
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9845: LD_EXP 58
9849: PPUSH
9850: CALL_OW 250
9854: PPUSH
9855: LD_EXP 58
9859: PPUSH
9860: CALL_OW 251
9864: PPUSH
9865: LD_INT 7
9867: PPUSH
9868: LD_INT 8
9870: PPUSH
9871: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9875: LD_EXP 58
9879: PPUSH
9880: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9884: LD_EXP 28
9888: PPUSH
9889: LD_STRING D9-Frank-1
9891: PPUSH
9892: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9896: LD_EXP 16
9900: PPUSH
9901: LD_STRING D9-JMM-1
9903: PPUSH
9904: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9908: LD_EXP 28
9912: PPUSH
9913: LD_STRING D9-Frank-2
9915: PPUSH
9916: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9920: LD_EXP 58
9924: PPUSH
9925: CALL_OW 250
9929: PPUSH
9930: LD_EXP 58
9934: PPUSH
9935: CALL_OW 251
9939: PPUSH
9940: LD_INT 7
9942: PPUSH
9943: CALL_OW 331
// end ; DialogueOff ;
9947: CALL_OW 7
// end ;
9951: PPOPN 1
9953: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9954: LD_EXP 7
9958: PUSH
9959: LD_OWVAR 1
9963: PUSH
9964: LD_INT 42000
9966: GREATEREQUAL
9967: OR
9968: IFFALSE 10995
9970: GO 9972
9972: DISABLE
9973: LD_INT 0
9975: PPUSH
9976: PPUSH
// begin selected_option := 1 ;
9977: LD_ADDR_VAR 0 2
9981: PUSH
9982: LD_INT 1
9984: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9985: LD_INT 10500
9987: PPUSH
9988: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// until not ru_attackers ;
9999: LD_EXP 54
10003: NOT
10004: IFFALSE 9992
// PrepareBurlak ;
10006: CALL 2343 0 0
// repeat wait ( 0 0$2 ) ;
10010: LD_INT 70
10012: PPUSH
10013: CALL_OW 67
// until not HasTask ( Burlak ) ;
10017: LD_EXP 48
10021: PPUSH
10022: CALL_OW 314
10026: NOT
10027: IFFALSE 10010
// InGameOn ;
10029: CALL_OW 8
// DialogueOn ;
10033: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10037: LD_EXP 51
10041: PPUSH
10042: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bur-1
10053: PPUSH
10054: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10058: LD_EXP 49
10062: PUSH
10063: LD_EXP 49
10067: PPUSH
10068: CALL_OW 255
10072: PUSH
10073: LD_INT 7
10075: EQUAL
10076: AND
10077: IFFALSE 10091
// Say ( Belkov , D10-Bel-1 ) ;
10079: LD_EXP 49
10083: PPUSH
10084: LD_STRING D10-Bel-1
10086: PPUSH
10087: CALL_OW 88
// if Gossudarov then
10091: LD_EXP 34
10095: IFFALSE 10109
// Say ( Gossudarov , D10-Gos-1 ) ;
10097: LD_EXP 34
10101: PPUSH
10102: LD_STRING D10-Gos-1
10104: PPUSH
10105: CALL_OW 88
// if Kirilenkova then
10109: LD_EXP 35
10113: IFFALSE 10127
// Say ( Kirilenkova , D10-Kir-1 ) ;
10115: LD_EXP 35
10119: PPUSH
10120: LD_STRING D10-Kir-1
10122: PPUSH
10123: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10127: CALL 13464 0 0
10131: PPUSH
10132: LD_STRING D10-RSol1-1
10134: PPUSH
10135: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10139: LD_EXP 48
10143: PPUSH
10144: LD_STRING D10-Bur-2
10146: PPUSH
10147: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10151: LD_EXP 16
10155: PPUSH
10156: LD_STRING D10-JMM-2
10158: PPUSH
10159: CALL_OW 88
// if Kirilenkova then
10163: LD_EXP 35
10167: IFFALSE 10183
// Say ( Kirilenkova , D10-Kir-2 ) else
10169: LD_EXP 35
10173: PPUSH
10174: LD_STRING D10-Kir-2
10176: PPUSH
10177: CALL_OW 88
10181: GO 10195
// Say ( SolRu , D10-RSol1-2 ) ;
10183: CALL 13464 0 0
10187: PPUSH
10188: LD_STRING D10-RSol1-2
10190: PPUSH
10191: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10195: LD_EXP 16
10199: PPUSH
10200: LD_STRING D10-JMM-3
10202: PPUSH
10203: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10207: LD_EXP 48
10211: PPUSH
10212: LD_STRING D10-Bur-3
10214: PPUSH
10215: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10219: LD_EXP 16
10223: PPUSH
10224: LD_STRING D10-JMM-4
10226: PPUSH
10227: CALL_OW 88
// DialogueOff ;
10231: CALL_OW 7
// InGameOff ;
10235: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10239: LD_STRING M2
10241: PPUSH
10242: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10253: LD_INT 22
10255: PUSH
10256: LD_INT 7
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 91
10265: PUSH
10266: LD_EXP 48
10270: PUSH
10271: LD_INT 8
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: PPUSH
10283: CALL_OW 69
10287: IFFALSE 10246
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10289: LD_ADDR_VAR 0 1
10293: PUSH
10294: LD_INT 22
10296: PUSH
10297: LD_INT 4
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PPUSH
10304: CALL_OW 69
10308: PUSH
10309: FOR_IN
10310: IFFALSE 10326
// SetSide ( i , 7 ) ;
10312: LD_VAR 0 1
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 235
10324: GO 10309
10326: POP
10327: POP
// ChangeMissionObjectives ( M3 ) ;
10328: LD_STRING M3
10330: PPUSH
10331: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10335: LD_INT 35
10337: PPUSH
10338: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10342: LD_EXP 16
10346: PPUSH
10347: LD_EXP 48
10351: PPUSH
10352: CALL_OW 296
10356: PUSH
10357: LD_INT 8
10359: LESS
10360: IFFALSE 10335
// ComTurnUnit ( JMM , Burlak ) ;
10362: LD_EXP 16
10366: PPUSH
10367: LD_EXP 48
10371: PPUSH
10372: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10376: LD_EXP 48
10380: PPUSH
10381: LD_EXP 16
10385: PPUSH
10386: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10390: LD_INT 10
10392: PPUSH
10393: CALL_OW 67
// DialogueOn ;
10397: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10401: LD_EXP 16
10405: PPUSH
10406: LD_STRING D11-JMM-1
10408: PPUSH
10409: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10413: LD_EXP 48
10417: PPUSH
10418: LD_STRING D11-Bur-1
10420: PPUSH
10421: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10425: LD_EXP 16
10429: PPUSH
10430: LD_STRING D11-JMM-2
10432: PPUSH
10433: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10437: LD_EXP 48
10441: PPUSH
10442: LD_STRING D11-Bur-2
10444: PPUSH
10445: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10449: LD_EXP 16
10453: PPUSH
10454: LD_STRING D11-JMM-3
10456: PPUSH
10457: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10461: LD_EXP 48
10465: PPUSH
10466: LD_STRING D11-Bur-3
10468: PPUSH
10469: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10473: LD_EXP 16
10477: PPUSH
10478: LD_STRING D11-JMM-4
10480: PPUSH
10481: CALL_OW 88
// if ar_base_spotted then
10485: LD_EXP 8
10489: IFFALSE 10505
// Say ( Burlak , D12-Bur-1 ) else
10491: LD_EXP 48
10495: PPUSH
10496: LD_STRING D12-Bur-1
10498: PPUSH
10499: CALL_OW 88
10503: GO 10544
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10505: LD_INT 7
10507: PPUSH
10508: LD_INT 3
10510: PPUSH
10511: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10515: LD_INT 127
10517: PPUSH
10518: LD_INT 45
10520: PPUSH
10521: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10525: LD_EXP 48
10529: PPUSH
10530: LD_STRING D12-Bur-1a
10532: PPUSH
10533: CALL_OW 88
// dwait ( 0 0$2 ) ;
10537: LD_INT 70
10539: PPUSH
10540: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10544: LD_EXP 48
10548: PPUSH
10549: LD_STRING D12-Bur-1b
10551: PPUSH
10552: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10556: LD_EXP 16
10560: PPUSH
10561: LD_STRING D12-JMM-1
10563: PPUSH
10564: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10568: LD_EXP 48
10572: PPUSH
10573: LD_STRING D12-Bur-2
10575: PPUSH
10576: CALL_OW 88
// if Roth then
10580: LD_EXP 17
10584: IFFALSE 10600
// Say ( Roth , D12-Roth-2 ) else
10586: LD_EXP 17
10590: PPUSH
10591: LD_STRING D12-Roth-2
10593: PPUSH
10594: CALL_OW 88
10598: GO 10612
// Say ( SciRu , D12-RSci1-2 ) ;
10600: CALL 13317 0 0
10604: PPUSH
10605: LD_STRING D12-RSci1-2
10607: PPUSH
10608: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10612: LD_EXP 16
10616: PPUSH
10617: LD_STRING D12-JMM-2
10619: PPUSH
10620: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10624: LD_EXP 48
10628: PPUSH
10629: LD_STRING D12-Bur-3
10631: PPUSH
10632: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10636: LD_EXP 16
10640: PPUSH
10641: LD_STRING D12-JMM-3
10643: PPUSH
10644: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10648: LD_EXP 48
10652: PPUSH
10653: LD_STRING D12-Bur-4
10655: PPUSH
10656: CALL_OW 88
// case Query ( QBase ) of 1 :
10660: LD_STRING QBase
10662: PPUSH
10663: CALL_OW 97
10667: PUSH
10668: LD_INT 1
10670: DOUBLE
10671: EQUAL
10672: IFTRUE 10676
10674: GO 10794
10676: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10677: LD_EXP 16
10681: PPUSH
10682: LD_STRING D13a-JMM-1
10684: PPUSH
10685: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10689: LD_EXP 48
10693: PPUSH
10694: LD_STRING D13a-Bur-1
10696: PPUSH
10697: CALL_OW 88
// if Roth then
10701: LD_EXP 17
10705: IFFALSE 10721
// Say ( Roth , D13a-Roth-1 ) else
10707: LD_EXP 17
10711: PPUSH
10712: LD_STRING D13a-Roth-1
10714: PPUSH
10715: CALL_OW 88
10719: GO 10733
// Say ( SciRu , D13a-RSci1-1 ) ;
10721: CALL 13317 0 0
10725: PPUSH
10726: LD_STRING D13a-RSci1-1
10728: PPUSH
10729: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10733: LD_EXP 16
10737: PPUSH
10738: LD_STRING D13a-JMM-2
10740: PPUSH
10741: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10745: LD_STRING QBaseAgain
10747: PPUSH
10748: CALL_OW 97
10752: PUSH
10753: LD_INT 1
10755: DOUBLE
10756: EQUAL
10757: IFTRUE 10761
10759: GO 10772
10761: POP
// selected_option := 2 ; 2 :
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_INT 2
10769: ST_TO_ADDR
10770: GO 10792
10772: LD_INT 2
10774: DOUBLE
10775: EQUAL
10776: IFTRUE 10780
10778: GO 10791
10780: POP
// selected_option := 3 ; end ;
10781: LD_ADDR_VAR 0 2
10785: PUSH
10786: LD_INT 3
10788: ST_TO_ADDR
10789: GO 10792
10791: POP
// end ; 2 :
10792: GO 10833
10794: LD_INT 2
10796: DOUBLE
10797: EQUAL
10798: IFTRUE 10802
10800: GO 10813
10802: POP
// selected_option := 2 ; 3 :
10803: LD_ADDR_VAR 0 2
10807: PUSH
10808: LD_INT 2
10810: ST_TO_ADDR
10811: GO 10833
10813: LD_INT 3
10815: DOUBLE
10816: EQUAL
10817: IFTRUE 10821
10819: GO 10832
10821: POP
// selected_option := 3 ; end ;
10822: LD_ADDR_VAR 0 2
10826: PUSH
10827: LD_INT 3
10829: ST_TO_ADDR
10830: GO 10833
10832: POP
// if selected_option = 2 then
10833: LD_VAR 0 2
10837: PUSH
10838: LD_INT 2
10840: EQUAL
10841: IFFALSE 10935
// begin Say ( JMM , D13b-JMM-1 ) ;
10843: LD_EXP 16
10847: PPUSH
10848: LD_STRING D13b-JMM-1
10850: PPUSH
10851: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10855: LD_EXP 48
10859: PPUSH
10860: LD_STRING D13b-Bur-1
10862: PPUSH
10863: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10867: LD_EXP 16
10871: PPUSH
10872: LD_STRING D13b-JMM-2
10874: PPUSH
10875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10879: LD_EXP 57
10883: PPUSH
10884: LD_STRING D13b-Abd-2
10886: PPUSH
10887: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10891: LD_EXP 16
10895: PPUSH
10896: LD_STRING D13b-JMM-3
10898: PPUSH
10899: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10903: LD_EXP 57
10907: PPUSH
10908: LD_STRING D13b-Abd-3
10910: PPUSH
10911: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10915: LD_EXP 16
10919: PPUSH
10920: LD_STRING D13b-JMM-4
10922: PPUSH
10923: CALL_OW 88
// ar_active_attack := true ;
10927: LD_ADDR_EXP 9
10931: PUSH
10932: LD_INT 1
10934: ST_TO_ADDR
// end ; if selected_option = 3 then
10935: LD_VAR 0 2
10939: PUSH
10940: LD_INT 3
10942: EQUAL
10943: IFFALSE 10969
// begin Say ( JMM , D13c-JMM-1 ) ;
10945: LD_EXP 16
10949: PPUSH
10950: LD_STRING D13c-JMM-1
10952: PPUSH
10953: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10957: LD_EXP 48
10961: PPUSH
10962: LD_STRING D13c-Bur-1
10964: PPUSH
10965: CALL_OW 88
// end ; DialogueOff ;
10969: CALL_OW 7
// if not ar_active_attack then
10973: LD_EXP 9
10977: NOT
10978: IFFALSE 10995
// begin wait ( 6 6$00 ) ;
10980: LD_INT 12600
10982: PPUSH
10983: CALL_OW 67
// ar_active_attack := true ;
10987: LD_ADDR_EXP 9
10991: PUSH
10992: LD_INT 1
10994: ST_TO_ADDR
// end ; end ;
10995: PPOPN 2
10997: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10998: LD_EXP 48
11002: PPUSH
11003: CALL_OW 305
11007: PUSH
11008: LD_EXP 48
11012: PPUSH
11013: CALL_OW 255
11017: PUSH
11018: LD_INT 7
11020: EQUAL
11021: AND
11022: IFFALSE 11218
11024: GO 11026
11026: DISABLE
11027: LD_INT 0
11029: PPUSH
// begin wait ( 4 4$40 ) ;
11030: LD_INT 9800
11032: PPUSH
11033: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11037: LD_INT 35
11039: PPUSH
11040: CALL_OW 67
// until not ru_attackers ;
11044: LD_EXP 54
11048: NOT
11049: IFFALSE 11037
// PrepareGnyevko ;
11051: CALL 2287 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11055: LD_EXP 50
11059: PPUSH
11060: LD_INT 124
11062: PPUSH
11063: LD_INT 118
11065: PPUSH
11066: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11070: LD_EXP 50
11074: PPUSH
11075: CALL_OW 200
// time := 0 0$00 ;
11079: LD_ADDR_VAR 0 1
11083: PUSH
11084: LD_INT 0
11086: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11087: LD_INT 35
11089: PPUSH
11090: CALL_OW 67
// time := time + 0 0$1 ;
11094: LD_ADDR_VAR 0 1
11098: PUSH
11099: LD_VAR 0 1
11103: PUSH
11104: LD_INT 35
11106: PLUS
11107: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11108: LD_EXP 50
11112: PPUSH
11113: LD_INT 124
11115: PPUSH
11116: LD_INT 118
11118: PPUSH
11119: CALL_OW 307
11123: PUSH
11124: LD_VAR 0 1
11128: PUSH
11129: LD_INT 1050
11131: GREATEREQUAL
11132: OR
11133: IFFALSE 11087
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11135: LD_EXP 50
11139: PPUSH
11140: LD_STRING DBelkov-Gny-1
11142: PPUSH
11143: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11147: LD_EXP 48
11151: PPUSH
11152: LD_STRING DBelkov-Bur-1a
11154: PPUSH
11155: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11166: LD_EXP 50
11170: PPUSH
11171: LD_INT 22
11173: PUSH
11174: LD_INT 7
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PPUSH
11181: CALL_OW 69
11185: PPUSH
11186: LD_EXP 50
11190: PPUSH
11191: CALL_OW 74
11195: PPUSH
11196: CALL_OW 296
11200: PUSH
11201: LD_INT 8
11203: LESS
11204: IFFALSE 11159
// SetSide ( Gnyevko , 7 ) ;
11206: LD_EXP 50
11210: PPUSH
11211: LD_INT 7
11213: PPUSH
11214: CALL_OW 235
// end ;
11218: PPOPN 1
11220: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11221: LD_EXP 48
11225: PPUSH
11226: CALL_OW 255
11230: PUSH
11231: LD_INT 7
11233: EQUAL
11234: IFFALSE 11244
11236: GO 11238
11238: DISABLE
// begin enable ;
11239: ENABLE
// PrepareAmericanAttack ;
11240: CALL 6886 0 0
// end ;
11244: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11245: LD_INT 22
11247: PUSH
11248: LD_INT 1
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PPUSH
11255: CALL_OW 69
11259: IFFALSE 11443
11261: GO 11263
11263: DISABLE
11264: LD_INT 0
11266: PPUSH
11267: PPUSH
// begin while true do
11268: LD_INT 1
11270: IFFALSE 11327
// begin wait ( 0 0$1 ) ;
11272: LD_INT 35
11274: PPUSH
11275: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11279: LD_ADDR_VAR 0 2
11283: PUSH
11284: LD_INT 22
11286: PUSH
11287: LD_INT 1
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PPUSH
11294: CALL_OW 69
11298: PPUSH
11299: LD_EXP 16
11303: PPUSH
11304: CALL_OW 74
11308: ST_TO_ADDR
// if See ( 7 , tmp ) then
11309: LD_INT 7
11311: PPUSH
11312: LD_VAR 0 2
11316: PPUSH
11317: CALL_OW 292
11321: IFFALSE 11325
// break ;
11323: GO 11327
// end ;
11325: GO 11268
// DialogueOn ;
11327: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11331: LD_VAR 0 2
11335: PPUSH
11336: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11340: LD_VAR 0 2
11344: PPUSH
11345: CALL_OW 250
11349: PPUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: CALL_OW 251
11359: PPUSH
11360: LD_INT 7
11362: PPUSH
11363: LD_INT 8
11365: PPUSH
11366: CALL_OW 330
// if Denis then
11370: LD_EXP 22
11374: IFFALSE 11388
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11376: LD_EXP 22
11380: PPUSH
11381: LD_STRING DAmerAttack-Pet-1
11383: PPUSH
11384: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11388: LD_EXP 16
11392: PPUSH
11393: LD_STRING DAmerAttack-JMM-1
11395: PPUSH
11396: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11400: LD_EXP 48
11404: PPUSH
11405: LD_STRING DStop-Bur-1
11407: PPUSH
11408: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11412: LD_VAR 0 2
11416: PPUSH
11417: CALL_OW 250
11421: PPUSH
11422: LD_VAR 0 2
11426: PPUSH
11427: CALL_OW 251
11431: PPUSH
11432: LD_INT 7
11434: PPUSH
11435: CALL_OW 331
// DialogueOff ;
11439: CALL_OW 7
// end ;
11443: PPOPN 2
11445: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11446: LD_INT 22
11448: PUSH
11449: LD_INT 3
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: LD_INT 21
11458: PUSH
11459: LD_INT 1
11461: PUSH
11462: EMPTY
11463: LIST
11464: LIST
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PPUSH
11470: CALL_OW 69
11474: PUSH
11475: LD_INT 0
11477: EQUAL
11478: IFFALSE 11520
11480: GO 11482
11482: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11483: LD_STRING M5a
11485: PPUSH
11486: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11490: LD_EXP 16
11494: PPUSH
11495: LD_STRING D8-JMM-1
11497: PPUSH
11498: CALL_OW 88
// if Gossudarov then
11502: LD_EXP 34
11506: IFFALSE 11520
// Say ( Gossudarov , D8-Gos-1 ) ;
11508: LD_EXP 34
11512: PPUSH
11513: LD_STRING D8-Gos-1
11515: PPUSH
11516: CALL_OW 88
// end ;
11520: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11521: LD_INT 22
11523: PUSH
11524: LD_INT 2
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PUSH
11531: LD_INT 21
11533: PUSH
11534: LD_INT 1
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: PPUSH
11545: CALL_OW 69
11549: PUSH
11550: LD_INT 0
11552: EQUAL
11553: IFFALSE 11603
11555: GO 11557
11557: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11558: LD_STRING M4c
11560: PPUSH
11561: CALL_OW 337
// if Roth then
11565: LD_EXP 17
11569: IFFALSE 11585
// Say ( Roth , DStop-Roth-1 ) else
11571: LD_EXP 17
11575: PPUSH
11576: LD_STRING DStop-Roth-1
11578: PPUSH
11579: CALL_OW 88
11583: GO 11603
// if Gossudarov then
11585: LD_EXP 34
11589: IFFALSE 11603
// Say ( Gossudarov , D8-Gos-1a ) ;
11591: LD_EXP 34
11595: PPUSH
11596: LD_STRING D8-Gos-1a
11598: PPUSH
11599: CALL_OW 88
// end ;
11603: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11604: LD_INT 7
11606: PPUSH
11607: LD_INT 1
11609: PPUSH
11610: LD_INT 1
11612: PPUSH
11613: CALL 14996 0 3
11617: PUSH
11618: LD_INT 0
11620: EQUAL
11621: PUSH
11622: LD_INT 7
11624: PPUSH
11625: LD_INT 3
11627: PPUSH
11628: LD_INT 1
11630: PPUSH
11631: CALL 14996 0 3
11635: PUSH
11636: LD_INT 0
11638: EQUAL
11639: AND
11640: IFFALSE 11652
11642: GO 11644
11644: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11645: LD_STRING M1a
11647: PPUSH
11648: CALL_OW 337
// end ;
11652: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11653: LD_INT 22
11655: PUSH
11656: LD_INT 2
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: PUSH
11686: LD_INT 22
11688: PUSH
11689: LD_INT 3
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: LD_INT 21
11698: PUSH
11699: LD_INT 1
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PPUSH
11710: CALL_OW 69
11714: PUSH
11715: LD_INT 0
11717: EQUAL
11718: AND
11719: PUSH
11720: LD_INT 22
11722: PUSH
11723: LD_INT 1
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PPUSH
11730: CALL_OW 69
11734: PUSH
11735: LD_INT 0
11737: EQUAL
11738: AND
11739: PUSH
11740: LD_INT 7
11742: PPUSH
11743: LD_INT 1
11745: PPUSH
11746: LD_INT 1
11748: PPUSH
11749: CALL 14996 0 3
11753: PUSH
11754: LD_INT 0
11756: EQUAL
11757: AND
11758: PUSH
11759: LD_INT 7
11761: PPUSH
11762: LD_INT 3
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL 14996 0 3
11772: PUSH
11773: LD_INT 0
11775: EQUAL
11776: AND
11777: PUSH
11778: LD_EXP 48
11782: PPUSH
11783: CALL_OW 255
11787: PUSH
11788: LD_INT 7
11790: EQUAL
11791: AND
11792: PUSH
11793: LD_EXP 48
11797: PPUSH
11798: CALL_OW 302
11802: AND
11803: IFFALSE 13314
11805: GO 11807
11807: DISABLE
11808: LD_INT 0
11810: PPUSH
11811: PPUSH
11812: PPUSH
11813: PPUSH
11814: PPUSH
11815: PPUSH
// begin m1 := false ;
11816: LD_ADDR_VAR 0 4
11820: PUSH
11821: LD_INT 0
11823: ST_TO_ADDR
// m2 := false ;
11824: LD_ADDR_VAR 0 5
11828: PUSH
11829: LD_INT 0
11831: ST_TO_ADDR
// m3 := false ;
11832: LD_ADDR_VAR 0 6
11836: PUSH
11837: LD_INT 0
11839: ST_TO_ADDR
// if tick < 40 40$00 then
11840: LD_OWVAR 1
11844: PUSH
11845: LD_INT 84000
11847: LESS
11848: IFFALSE 11857
// SetAchievement ( ACH_ASPEED_17 ) ;
11850: LD_STRING ACH_ASPEED_17
11852: PPUSH
11853: CALL_OW 543
// wait ( 0 0$5 ) ;
11857: LD_INT 175
11859: PPUSH
11860: CALL_OW 67
// if not masha_killed then
11864: LD_EXP 10
11868: NOT
11869: IFFALSE 11891
// begin m1 := true ;
11871: LD_ADDR_VAR 0 4
11875: PUSH
11876: LD_INT 1
11878: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11879: LD_STRING Masha
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: CALL_OW 101
// end else
11889: GO 11902
// AddMedal ( Masha , - 1 ) ;
11891: LD_STRING Masha
11893: PPUSH
11894: LD_INT 1
11896: NEG
11897: PPUSH
11898: CALL_OW 101
// if abdul_escaped then
11902: LD_EXP 13
11906: IFFALSE 11921
// AddMedal ( Abdul , - 1 ) else
11908: LD_STRING Abdul
11910: PPUSH
11911: LD_INT 1
11913: NEG
11914: PPUSH
11915: CALL_OW 101
11919: GO 11939
// begin m2 := true ;
11921: LD_ADDR_VAR 0 5
11925: PUSH
11926: LD_INT 1
11928: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11929: LD_STRING Abdul
11931: PPUSH
11932: LD_INT 1
11934: PPUSH
11935: CALL_OW 101
// end ; if loss_counter = 0 then
11939: LD_EXP 14
11943: PUSH
11944: LD_INT 0
11946: EQUAL
11947: IFFALSE 11969
// begin m3 := true ;
11949: LD_ADDR_VAR 0 6
11953: PUSH
11954: LD_INT 1
11956: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11957: LD_STRING People
11959: PPUSH
11960: LD_INT 2
11962: PPUSH
11963: CALL_OW 101
// end else
11967: GO 12031
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11969: LD_EXP 14
11973: PUSH
11974: LD_INT 3
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: LD_INT 2
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: PUSH
11992: LD_OWVAR 67
11996: ARRAY
11997: LESSEQUAL
11998: IFFALSE 12020
// begin AddMedal ( People , 1 ) ;
12000: LD_STRING People
12002: PPUSH
12003: LD_INT 1
12005: PPUSH
12006: CALL_OW 101
// m3 := true ;
12010: LD_ADDR_VAR 0 6
12014: PUSH
12015: LD_INT 1
12017: ST_TO_ADDR
// end else
12018: GO 12031
// AddMedal ( People , - 1 ) ;
12020: LD_STRING People
12022: PPUSH
12023: LD_INT 1
12025: NEG
12026: PPUSH
12027: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12031: LD_OWVAR 67
12035: PUSH
12036: LD_INT 3
12038: GREATEREQUAL
12039: PUSH
12040: LD_VAR 0 4
12044: AND
12045: PUSH
12046: LD_VAR 0 5
12050: AND
12051: PUSH
12052: LD_VAR 0 6
12056: AND
12057: IFFALSE 12069
// SetAchievementEX ( ACH_AMER , 17 ) ;
12059: LD_STRING ACH_AMER
12061: PPUSH
12062: LD_INT 17
12064: PPUSH
12065: CALL_OW 564
// GiveMedals ( MAIN ) ;
12069: LD_STRING MAIN
12071: PPUSH
12072: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12076: LD_ADDR_VAR 0 2
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 7
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 50
12093: PUSH
12094: EMPTY
12095: LIST
12096: PUSH
12097: LD_INT 2
12099: PUSH
12100: LD_INT 25
12102: PUSH
12103: LD_INT 1
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: LD_INT 25
12112: PUSH
12113: LD_INT 2
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PUSH
12120: LD_INT 25
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 4
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: LD_INT 25
12142: PUSH
12143: LD_INT 5
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 25
12152: PUSH
12153: LD_INT 8
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 9
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: PPUSH
12185: CALL_OW 69
12189: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12190: LD_VAR 0 2
12194: PPUSH
12195: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12199: LD_ADDR_VAR 0 3
12203: PUSH
12204: LD_EXP 16
12208: PUSH
12209: LD_EXP 17
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 19
12223: PUSH
12224: LD_EXP 20
12228: PUSH
12229: LD_EXP 21
12233: PUSH
12234: LD_EXP 22
12238: PUSH
12239: LD_EXP 23
12243: PUSH
12244: LD_EXP 24
12248: PUSH
12249: LD_EXP 25
12253: PUSH
12254: LD_EXP 26
12258: PUSH
12259: LD_EXP 27
12263: PUSH
12264: LD_EXP 28
12268: PUSH
12269: LD_EXP 29
12273: PUSH
12274: LD_EXP 30
12278: PUSH
12279: LD_EXP 31
12283: PUSH
12284: LD_EXP 32
12288: PUSH
12289: LD_EXP 34
12293: PUSH
12294: LD_EXP 35
12298: PUSH
12299: LD_EXP 36
12303: PUSH
12304: LD_EXP 38
12308: PUSH
12309: LD_EXP 39
12313: PUSH
12314: LD_EXP 40
12318: PUSH
12319: LD_EXP 41
12323: PUSH
12324: LD_EXP 42
12328: PUSH
12329: LD_EXP 43
12333: PUSH
12334: LD_EXP 44
12338: PUSH
12339: LD_EXP 45
12343: PUSH
12344: LD_EXP 46
12348: PUSH
12349: LD_EXP 47
12353: PUSH
12354: LD_EXP 48
12358: PUSH
12359: LD_EXP 49
12363: PUSH
12364: LD_EXP 50
12368: PUSH
12369: LD_EXP 33
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: ST_TO_ADDR
// if tmp diff tmp2 then
12410: LD_VAR 0 2
12414: PUSH
12415: LD_VAR 0 3
12419: DIFF
12420: IFFALSE 12440
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12422: LD_VAR 0 2
12426: PUSH
12427: LD_VAR 0 3
12431: DIFF
12432: PPUSH
12433: LD_STRING 13a_others
12435: PPUSH
12436: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12440: LD_EXP 16
12444: PPUSH
12445: LD_STRING 13a_JMM
12447: PPUSH
12448: CALL_OW 38
// if IsOk ( Mike ) then
12452: LD_EXP 33
12456: PPUSH
12457: CALL_OW 302
12461: IFFALSE 12475
// SaveCharacters ( Mike , 13a_Mike ) ;
12463: LD_EXP 33
12467: PPUSH
12468: LD_STRING 13a_Mike
12470: PPUSH
12471: CALL_OW 38
// if Titov then
12475: LD_EXP 36
12479: IFFALSE 12493
// SaveCharacters ( Titov , 13a_Titov ) ;
12481: LD_EXP 36
12485: PPUSH
12486: LD_STRING 13a_Titov
12488: PPUSH
12489: CALL_OW 38
// if Dolgov then
12493: LD_EXP 38
12497: IFFALSE 12511
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12499: LD_EXP 38
12503: PPUSH
12504: LD_STRING 13a_Dolgov
12506: PPUSH
12507: CALL_OW 38
// if Petrosyan then
12511: LD_EXP 39
12515: IFFALSE 12529
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12517: LD_EXP 39
12521: PPUSH
12522: LD_STRING 13a_Petrosyan
12524: PPUSH
12525: CALL_OW 38
// if Scholtze then
12529: LD_EXP 40
12533: IFFALSE 12547
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12535: LD_EXP 40
12539: PPUSH
12540: LD_STRING 13a_Scholtze
12542: PPUSH
12543: CALL_OW 38
// if Oblukov then
12547: LD_EXP 41
12551: IFFALSE 12565
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12553: LD_EXP 41
12557: PPUSH
12558: LD_STRING 13a_Oblukov
12560: PPUSH
12561: CALL_OW 38
// if Kapitsova then
12565: LD_EXP 42
12569: IFFALSE 12583
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12571: LD_EXP 42
12575: PPUSH
12576: LD_STRING 13a_Kapitsova
12578: PPUSH
12579: CALL_OW 38
// if Lipshchin then
12583: LD_EXP 43
12587: IFFALSE 12601
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12589: LD_EXP 43
12593: PPUSH
12594: LD_STRING 13a_Lipshchin
12596: PPUSH
12597: CALL_OW 38
// if Petrovova then
12601: LD_EXP 44
12605: IFFALSE 12619
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12607: LD_EXP 44
12611: PPUSH
12612: LD_STRING 13a_Petrovova
12614: PPUSH
12615: CALL_OW 38
// if Kovalyuk then
12619: LD_EXP 45
12623: IFFALSE 12637
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12625: LD_EXP 45
12629: PPUSH
12630: LD_STRING 13a_Kovalyuk
12632: PPUSH
12633: CALL_OW 38
// if Kuzmov then
12637: LD_EXP 46
12641: IFFALSE 12655
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12643: LD_EXP 46
12647: PPUSH
12648: LD_STRING 13a_Kuzmov
12650: PPUSH
12651: CALL_OW 38
// if Karamazov then
12655: LD_EXP 47
12659: IFFALSE 12673
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12661: LD_EXP 47
12665: PPUSH
12666: LD_STRING 13a_Karamazov
12668: PPUSH
12669: CALL_OW 38
// if Burlak then
12673: LD_EXP 48
12677: IFFALSE 12691
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12679: LD_EXP 48
12683: PPUSH
12684: LD_STRING 13a_Burlak
12686: PPUSH
12687: CALL_OW 38
// if Belkov then
12691: LD_EXP 49
12695: IFFALSE 12709
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12697: LD_EXP 49
12701: PPUSH
12702: LD_STRING 13a_Belkov
12704: PPUSH
12705: CALL_OW 38
// if Gnyevko then
12709: LD_EXP 50
12713: IFFALSE 12727
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12715: LD_EXP 50
12719: PPUSH
12720: LD_STRING 13a_Gnyevko
12722: PPUSH
12723: CALL_OW 38
// if Lisa then
12727: LD_EXP 18
12731: IFFALSE 12745
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12733: LD_EXP 18
12737: PPUSH
12738: LD_STRING 13a_Lisa
12740: PPUSH
12741: CALL_OW 38
// if Donaldson then
12745: LD_EXP 19
12749: IFFALSE 12763
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12751: LD_EXP 19
12755: PPUSH
12756: LD_STRING 13a_Donaldson
12758: PPUSH
12759: CALL_OW 38
// if Bobby then
12763: LD_EXP 20
12767: IFFALSE 12781
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12769: LD_EXP 20
12773: PPUSH
12774: LD_STRING 13a_Bobby
12776: PPUSH
12777: CALL_OW 38
// if Cyrus then
12781: LD_EXP 21
12785: IFFALSE 12799
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12787: LD_EXP 21
12791: PPUSH
12792: LD_STRING 13a_Cyrus
12794: PPUSH
12795: CALL_OW 38
// if Denis then
12799: LD_EXP 22
12803: IFFALSE 12817
// SaveCharacters ( Denis , 13a_Denis ) ;
12805: LD_EXP 22
12809: PPUSH
12810: LD_STRING 13a_Denis
12812: PPUSH
12813: CALL_OW 38
// if Brown then
12817: LD_EXP 23
12821: IFFALSE 12835
// SaveCharacters ( Brown , 13a_Brown ) ;
12823: LD_EXP 23
12827: PPUSH
12828: LD_STRING 13a_Brown
12830: PPUSH
12831: CALL_OW 38
// if Gladstone then
12835: LD_EXP 24
12839: IFFALSE 12853
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12841: LD_EXP 24
12845: PPUSH
12846: LD_STRING 13a_Gladstone
12848: PPUSH
12849: CALL_OW 38
// if Houten then
12853: LD_EXP 25
12857: IFFALSE 12871
// SaveCharacters ( Houten , 13a_Houten ) ;
12859: LD_EXP 25
12863: PPUSH
12864: LD_STRING 13a_Houten
12866: PPUSH
12867: CALL_OW 38
// if Cornel then
12871: LD_EXP 26
12875: IFFALSE 12889
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12877: LD_EXP 26
12881: PPUSH
12882: LD_STRING 13a_Cornel
12884: PPUSH
12885: CALL_OW 38
// if Gary then
12889: LD_EXP 27
12893: IFFALSE 12907
// SaveCharacters ( Gary , 13a_Gary ) ;
12895: LD_EXP 27
12899: PPUSH
12900: LD_STRING 13a_Gary
12902: PPUSH
12903: CALL_OW 38
// if Frank then
12907: LD_EXP 28
12911: IFFALSE 12925
// SaveCharacters ( Frank , 13a_Frank ) ;
12913: LD_EXP 28
12917: PPUSH
12918: LD_STRING 13a_Frank
12920: PPUSH
12921: CALL_OW 38
// if Kikuchi then
12925: LD_EXP 29
12929: IFFALSE 12943
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12931: LD_EXP 29
12935: PPUSH
12936: LD_STRING 13a_Kikuchi
12938: PPUSH
12939: CALL_OW 38
// if Simms then
12943: LD_EXP 30
12947: IFFALSE 12961
// SaveCharacters ( Simms , 13a_Simms ) ;
12949: LD_EXP 30
12953: PPUSH
12954: LD_STRING 13a_Simms
12956: PPUSH
12957: CALL_OW 38
// if Joan then
12961: LD_EXP 31
12965: IFFALSE 12979
// SaveCharacters ( Joan , 13a_Joan ) ;
12967: LD_EXP 31
12971: PPUSH
12972: LD_STRING 13a_Joan
12974: PPUSH
12975: CALL_OW 38
// if DeltaDoctor then
12979: LD_EXP 32
12983: IFFALSE 12997
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12985: LD_EXP 32
12989: PPUSH
12990: LD_STRING 13a_DeltaDoctor
12992: PPUSH
12993: CALL_OW 38
// if Gossudarov then
12997: LD_EXP 34
13001: IFFALSE 13015
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13003: LD_EXP 34
13007: PPUSH
13008: LD_STRING 13a_Gossudarov
13010: PPUSH
13011: CALL_OW 38
// if Kirilenkova then
13015: LD_EXP 35
13019: IFFALSE 13033
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13021: LD_EXP 35
13025: PPUSH
13026: LD_STRING 13a_Kirilenkova
13028: PPUSH
13029: CALL_OW 38
// if Roth then
13033: LD_EXP 17
13037: IFFALSE 13051
// SaveCharacters ( Roth , 13a_Roth ) ;
13039: LD_EXP 17
13043: PPUSH
13044: LD_STRING 13a_Roth
13046: PPUSH
13047: CALL_OW 38
// if Masha then
13051: LD_EXP 51
13055: IFFALSE 13110
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13057: LD_EXP 51
13061: PPUSH
13062: CALL_OW 265
13066: PUSH
13067: LD_EXP 51
13071: PPUSH
13072: CALL_OW 262
13076: PUSH
13077: LD_EXP 51
13081: PPUSH
13082: CALL_OW 263
13086: PUSH
13087: LD_EXP 51
13091: PPUSH
13092: CALL_OW 264
13096: PUSH
13097: EMPTY
13098: LIST
13099: LIST
13100: LIST
13101: LIST
13102: PPUSH
13103: LD_STRING 13a_Masha
13105: PPUSH
13106: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 21
13117: PUSH
13118: LD_INT 3
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PPUSH
13125: CALL_OW 69
13129: ST_TO_ADDR
// tmp2 := [ ] ;
13130: LD_ADDR_VAR 0 3
13134: PUSH
13135: EMPTY
13136: ST_TO_ADDR
// if tmp then
13137: LD_VAR 0 2
13141: IFFALSE 13292
// for i in tmp do
13143: LD_ADDR_VAR 0 1
13147: PUSH
13148: LD_VAR 0 2
13152: PUSH
13153: FOR_IN
13154: IFFALSE 13290
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13156: LD_ADDR_VAR 0 3
13160: PUSH
13161: LD_VAR 0 3
13165: PUSH
13166: LD_VAR 0 1
13170: PPUSH
13171: CALL_OW 255
13175: PUSH
13176: LD_VAR 0 1
13180: PPUSH
13181: CALL_OW 248
13185: PUSH
13186: LD_VAR 0 1
13190: PPUSH
13191: CALL_OW 266
13195: PUSH
13196: LD_VAR 0 1
13200: PPUSH
13201: CALL_OW 250
13205: PUSH
13206: LD_VAR 0 1
13210: PPUSH
13211: CALL_OW 251
13215: PUSH
13216: LD_VAR 0 1
13220: PPUSH
13221: CALL_OW 254
13225: PUSH
13226: LD_VAR 0 1
13230: PPUSH
13231: CALL_OW 267
13235: PUSH
13236: LD_VAR 0 1
13240: PPUSH
13241: LD_INT 1
13243: PPUSH
13244: CALL_OW 268
13248: PUSH
13249: LD_VAR 0 1
13253: PPUSH
13254: LD_INT 2
13256: PPUSH
13257: CALL_OW 268
13261: PUSH
13262: LD_VAR 0 1
13266: PPUSH
13267: CALL_OW 269
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: ADD
13287: ST_TO_ADDR
13288: GO 13153
13290: POP
13291: POP
// if tmp2 then
13292: LD_VAR 0 3
13296: IFFALSE 13310
// SaveVariable ( tmp2 , 13a_buildings ) ;
13298: LD_VAR 0 3
13302: PPUSH
13303: LD_STRING 13a_buildings
13305: PPUSH
13306: CALL_OW 39
// YouWin ;
13310: CALL_OW 103
// end ;
13314: PPOPN 6
13316: END
// export function SciRu ; var tmp , t ; begin
13317: LD_INT 0
13319: PPUSH
13320: PPUSH
13321: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13322: LD_ADDR_VAR 0 3
13326: PUSH
13327: LD_EXP 34
13331: PUSH
13332: LD_EXP 48
13336: PUSH
13337: LD_EXP 36
13341: PUSH
13342: LD_EXP 49
13346: PUSH
13347: LD_EXP 50
13351: PUSH
13352: LD_EXP 39
13356: PUSH
13357: LD_EXP 40
13361: PUSH
13362: LD_EXP 38
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13377: LD_ADDR_VAR 0 2
13381: PUSH
13382: LD_INT 22
13384: PUSH
13385: LD_INT 7
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 23
13394: PUSH
13395: LD_INT 3
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: LD_INT 25
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: LD_INT 26
13414: PUSH
13415: LD_INT 1
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: PUSH
13433: LD_VAR 0 3
13437: DIFF
13438: ST_TO_ADDR
// if tmp then
13439: LD_VAR 0 2
13443: IFFALSE 13459
// result := tmp [ 1 ] ;
13445: LD_ADDR_VAR 0 1
13449: PUSH
13450: LD_VAR 0 2
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: ST_TO_ADDR
// end ;
13459: LD_VAR 0 1
13463: RET
// export function SolRu ; var tmp , t ; begin
13464: LD_INT 0
13466: PPUSH
13467: PPUSH
13468: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13469: LD_ADDR_VAR 0 3
13473: PUSH
13474: LD_EXP 34
13478: PUSH
13479: LD_EXP 48
13483: PUSH
13484: LD_EXP 36
13488: PUSH
13489: LD_EXP 49
13493: PUSH
13494: LD_EXP 50
13498: PUSH
13499: LD_EXP 39
13503: PUSH
13504: LD_EXP 40
13508: PUSH
13509: LD_EXP 38
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13524: LD_ADDR_VAR 0 2
13528: PUSH
13529: LD_INT 22
13531: PUSH
13532: LD_INT 7
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PUSH
13539: LD_INT 23
13541: PUSH
13542: LD_INT 3
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: PUSH
13549: LD_INT 25
13551: PUSH
13552: LD_INT 1
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 26
13561: PUSH
13562: LD_INT 1
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: PUSH
13580: LD_VAR 0 3
13584: DIFF
13585: ST_TO_ADDR
// if tmp then
13586: LD_VAR 0 2
13590: IFFALSE 13606
// result := tmp [ 1 ] ;
13592: LD_ADDR_VAR 0 1
13596: PUSH
13597: LD_VAR 0 2
13601: PUSH
13602: LD_INT 1
13604: ARRAY
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 1
13610: RET
// export function CustomEvent ( event ) ; begin
13611: LD_INT 0
13613: PPUSH
// end ;
13614: LD_VAR 0 2
13618: RET
// on UnitDestroyed ( un ) do var i , side ;
13619: LD_INT 0
13621: PPUSH
13622: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13623: LD_VAR 0 1
13627: PPUSH
13628: CALL 102817 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13632: LD_VAR 0 1
13636: PUSH
13637: LD_INT 22
13639: PUSH
13640: LD_INT 7
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: LD_INT 2
13649: PUSH
13650: LD_INT 25
13652: PUSH
13653: LD_INT 1
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PUSH
13660: LD_INT 25
13662: PUSH
13663: LD_INT 2
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: PUSH
13670: LD_INT 25
13672: PUSH
13673: LD_INT 3
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: LD_INT 25
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 25
13692: PUSH
13693: LD_INT 5
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: LD_INT 25
13702: PUSH
13703: LD_INT 8
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 25
13712: PUSH
13713: LD_INT 9
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PPUSH
13734: CALL_OW 69
13738: IN
13739: IFFALSE 13755
// loss_counter := loss_counter + 1 ;
13741: LD_ADDR_EXP 14
13745: PUSH
13746: LD_EXP 14
13750: PUSH
13751: LD_INT 1
13753: PLUS
13754: ST_TO_ADDR
// if un = Abdul then
13755: LD_VAR 0 1
13759: PUSH
13760: LD_EXP 57
13764: EQUAL
13765: IFFALSE 13775
// abdul_escaped := false ;
13767: LD_ADDR_EXP 13
13771: PUSH
13772: LD_INT 0
13774: ST_TO_ADDR
// if un in ru_attackers then
13775: LD_VAR 0 1
13779: PUSH
13780: LD_EXP 54
13784: IN
13785: IFFALSE 13803
// ru_attackers := ru_attackers diff un ;
13787: LD_ADDR_EXP 54
13791: PUSH
13792: LD_EXP 54
13796: PUSH
13797: LD_VAR 0 1
13801: DIFF
13802: ST_TO_ADDR
// if un in ar_attackers then
13803: LD_VAR 0 1
13807: PUSH
13808: LD_EXP 11
13812: IN
13813: IFFALSE 13831
// ar_attackers := ar_attackers diff un ;
13815: LD_ADDR_EXP 11
13819: PUSH
13820: LD_EXP 11
13824: PUSH
13825: LD_VAR 0 1
13829: DIFF
13830: ST_TO_ADDR
// if un = JMM then
13831: LD_VAR 0 1
13835: PUSH
13836: LD_EXP 16
13840: EQUAL
13841: IFFALSE 13852
// begin YouLost ( JMM ) ;
13843: LD_STRING JMM
13845: PPUSH
13846: CALL_OW 104
// exit ;
13850: GO 13949
// end ; if un = Burlak then
13852: LD_VAR 0 1
13856: PUSH
13857: LD_EXP 48
13861: EQUAL
13862: IFFALSE 13873
// begin YouLost ( Burlak ) ;
13864: LD_STRING Burlak
13866: PPUSH
13867: CALL_OW 104
// exit ;
13871: GO 13949
// end ; if un = freedom then
13873: LD_VAR 0 1
13877: PUSH
13878: LD_EXP 3
13882: EQUAL
13883: IFFALSE 13894
// begin YouLost ( Destroyed ) ;
13885: LD_STRING Destroyed
13887: PPUSH
13888: CALL_OW 104
// exit ;
13892: GO 13949
// end ; if un = Masha then
13894: LD_VAR 0 1
13898: PUSH
13899: LD_EXP 51
13903: EQUAL
13904: IFFALSE 13921
// begin ChangeMissionObjectives ( M4b ) ;
13906: LD_STRING M4b
13908: PPUSH
13909: CALL_OW 337
// masha_killed := true ;
13913: LD_ADDR_EXP 10
13917: PUSH
13918: LD_INT 1
13920: ST_TO_ADDR
// end ; if un = Mastodont then
13921: LD_VAR 0 1
13925: PUSH
13926: LD_EXP 58
13930: EQUAL
13931: IFFALSE 13940
// ChangeMissionObjectives ( M4a ) ;
13933: LD_STRING M4a
13935: PPUSH
13936: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13940: LD_VAR 0 1
13944: PPUSH
13945: CALL 84034 0 1
// end ;
13949: PPOPN 3
13951: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13952: LD_VAR 0 1
13956: PPUSH
13957: LD_VAR 0 2
13961: PPUSH
13962: CALL 86366 0 2
// end ;
13966: PPOPN 2
13968: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13969: LD_VAR 0 1
13973: PPUSH
13974: CALL 85434 0 1
// end ;
13978: PPOPN 1
13980: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13981: LD_VAR 0 1
13985: PUSH
13986: LD_INT 22
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 30
13998: PUSH
13999: LD_INT 0
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PPUSH
14010: CALL_OW 69
14014: IN
14015: IFFALSE 14054
// begin SetBName ( building , freedom ) ;
14017: LD_VAR 0 1
14021: PPUSH
14022: LD_STRING freedom
14024: PPUSH
14025: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14029: LD_INT 0
14031: PPUSH
14032: LD_INT 7
14034: PPUSH
14035: LD_INT 0
14037: PPUSH
14038: CALL_OW 324
// freedom := building ;
14042: LD_ADDR_EXP 3
14046: PUSH
14047: LD_VAR 0 1
14051: ST_TO_ADDR
// exit ;
14052: GO 14120
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14054: LD_VAR 0 1
14058: PUSH
14059: LD_INT 22
14061: PUSH
14062: LD_INT 7
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PUSH
14069: LD_INT 23
14071: PUSH
14072: LD_INT 3
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PUSH
14079: LD_INT 30
14081: PUSH
14082: LD_INT 6
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: PPUSH
14094: CALL_OW 69
14098: IN
14099: IFFALSE 14111
// begin ru_lab_builded := true ;
14101: LD_ADDR_EXP 5
14105: PUSH
14106: LD_INT 1
14108: ST_TO_ADDR
// exit ;
14109: GO 14120
// end ; MCE_BuildingComplete ( building ) ;
14111: LD_VAR 0 1
14115: PPUSH
14116: CALL 85675 0 1
// end ;
14120: PPOPN 1
14122: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14123: LD_VAR 0 1
14127: PPUSH
14128: LD_VAR 0 2
14132: PPUSH
14133: CALL 83730 0 2
// end ;
14137: PPOPN 2
14139: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_VAR 0 2
14149: PPUSH
14150: LD_VAR 0 3
14154: PPUSH
14155: LD_VAR 0 4
14159: PPUSH
14160: LD_VAR 0 5
14164: PPUSH
14165: CALL 83350 0 5
// end ;
14169: PPOPN 5
14171: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14172: LD_VAR 0 1
14176: PPUSH
14177: LD_VAR 0 2
14181: PPUSH
14182: CALL 102937 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14186: LD_VAR 0 1
14190: PPUSH
14191: LD_VAR 0 2
14195: PPUSH
14196: CALL 82941 0 2
// end ;
14200: PPOPN 2
14202: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14203: LD_VAR 0 1
14207: PPUSH
14208: CALL_OW 263
14212: PUSH
14213: LD_INT 3
14215: EQUAL
14216: PUSH
14217: LD_VAR 0 2
14221: PPUSH
14222: CALL_OW 263
14226: PUSH
14227: LD_INT 3
14229: EQUAL
14230: OR
14231: IFFALSE 14247
// hack_counter := hack_counter + 1 ;
14233: LD_ADDR_EXP 15
14237: PUSH
14238: LD_EXP 15
14242: PUSH
14243: LD_INT 1
14245: PLUS
14246: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14247: LD_VAR 0 1
14251: PPUSH
14252: LD_VAR 0 2
14256: PPUSH
14257: LD_VAR 0 3
14261: PPUSH
14262: LD_VAR 0 4
14266: PPUSH
14267: CALL 82779 0 4
// end ;
14271: PPOPN 4
14273: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14274: LD_VAR 0 1
14278: PPUSH
14279: LD_VAR 0 2
14283: PPUSH
14284: LD_VAR 0 3
14288: PPUSH
14289: CALL 82554 0 3
// end ;
14293: PPOPN 3
14295: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14296: LD_VAR 0 1
14300: PPUSH
14301: LD_VAR 0 2
14305: PPUSH
14306: CALL 82439 0 2
// end ;
14310: PPOPN 2
14312: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14313: LD_VAR 0 1
14317: PPUSH
14318: LD_VAR 0 2
14322: PPUSH
14323: CALL 86661 0 2
// end ;
14327: PPOPN 2
14329: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14330: LD_VAR 0 1
14334: PPUSH
14335: LD_VAR 0 2
14339: PPUSH
14340: LD_VAR 0 3
14344: PPUSH
14345: LD_VAR 0 4
14349: PPUSH
14350: CALL 86877 0 4
// end ;
14354: PPOPN 4
14356: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14357: LD_VAR 0 1
14361: PPUSH
14362: LD_VAR 0 2
14366: PPUSH
14367: CALL 82248 0 2
// end ;
14371: PPOPN 2
14373: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14374: LD_VAR 0 1
14378: PPUSH
14379: CALL 102921 0 1
// end ; end_of_file
14383: PPOPN 1
14385: END
// every 0 0$30 do var cr , time ;
14386: GO 14388
14388: DISABLE
14389: LD_INT 0
14391: PPUSH
14392: PPUSH
// begin time := 0 0$20 ;
14393: LD_ADDR_VAR 0 2
14397: PUSH
14398: LD_INT 700
14400: ST_TO_ADDR
// while game do
14401: LD_EXP 2
14405: IFFALSE 14508
// begin wait ( time ) ;
14407: LD_VAR 0 2
14411: PPUSH
14412: CALL_OW 67
// if tick > 2 2$00 then
14416: LD_OWVAR 1
14420: PUSH
14421: LD_INT 4200
14423: GREATER
14424: IFFALSE 14461
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14426: LD_ADDR_VAR 0 2
14430: PUSH
14431: LD_VAR 0 2
14435: PUSH
14436: LD_INT 140
14438: PUSH
14439: LD_INT 140
14441: PUSH
14442: LD_INT 210
14444: PUSH
14445: LD_INT 280
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: PUSH
14454: LD_OWVAR 67
14458: ARRAY
14459: PLUS
14460: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14461: LD_INT 1
14463: PPUSH
14464: LD_INT 5
14466: PPUSH
14467: CALL_OW 12
14471: PPUSH
14472: LD_INT 70
14474: PPUSH
14475: LD_INT 49
14477: PPUSH
14478: LD_INT 25
14480: PPUSH
14481: LD_INT 1
14483: PPUSH
14484: CALL_OW 56
// if time > 3 3$00 then
14488: LD_VAR 0 2
14492: PUSH
14493: LD_INT 6300
14495: GREATER
14496: IFFALSE 14506
// time := 0 0$30 ;
14498: LD_ADDR_VAR 0 2
14502: PUSH
14503: LD_INT 1050
14505: ST_TO_ADDR
// end ;
14506: GO 14401
// end ;
14508: PPOPN 2
14510: END
// every 0 0$30 do var cr , time ;
14511: GO 14513
14513: DISABLE
14514: LD_INT 0
14516: PPUSH
14517: PPUSH
// begin time := 0 0$20 ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 700
14525: ST_TO_ADDR
// while game do
14526: LD_EXP 2
14530: IFFALSE 14623
// begin wait ( time ) ;
14532: LD_VAR 0 2
14536: PPUSH
14537: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14541: LD_ADDR_VAR 0 2
14545: PUSH
14546: LD_VAR 0 2
14550: PUSH
14551: LD_INT 140
14553: PUSH
14554: LD_INT 175
14556: PUSH
14557: LD_INT 210
14559: PUSH
14560: LD_INT 280
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: PUSH
14569: LD_OWVAR 67
14573: ARRAY
14574: PLUS
14575: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14576: LD_INT 3
14578: PPUSH
14579: LD_INT 5
14581: PPUSH
14582: CALL_OW 12
14586: PPUSH
14587: LD_INT 26
14589: PPUSH
14590: LD_INT 9
14592: PPUSH
14593: LD_INT 30
14595: PPUSH
14596: LD_INT 1
14598: PPUSH
14599: CALL_OW 56
// if time > 3 3$00 then
14603: LD_VAR 0 2
14607: PUSH
14608: LD_INT 6300
14610: GREATER
14611: IFFALSE 14621
// time := 0 0$20 ;
14613: LD_ADDR_VAR 0 2
14617: PUSH
14618: LD_INT 700
14620: ST_TO_ADDR
// end ;
14621: GO 14526
// end ;
14623: PPOPN 2
14625: END
// every 0 0$30 do var cr , time ;
14626: GO 14628
14628: DISABLE
14629: LD_INT 0
14631: PPUSH
14632: PPUSH
// begin time := 0 0$20 ;
14633: LD_ADDR_VAR 0 2
14637: PUSH
14638: LD_INT 700
14640: ST_TO_ADDR
// while game do
14641: LD_EXP 2
14645: IFFALSE 14774
// begin wait ( time ) ;
14647: LD_VAR 0 2
14651: PPUSH
14652: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14656: LD_ADDR_VAR 0 2
14660: PUSH
14661: LD_VAR 0 2
14665: PUSH
14666: LD_INT 175
14668: PUSH
14669: LD_INT 210
14671: PUSH
14672: LD_INT 280
14674: PUSH
14675: LD_INT 350
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: PUSH
14684: LD_OWVAR 67
14688: ARRAY
14689: PLUS
14690: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14691: LD_INT 1
14693: PPUSH
14694: LD_INT 5
14696: PPUSH
14697: CALL_OW 12
14701: PPUSH
14702: LD_INT 179
14704: PPUSH
14705: LD_INT 101
14707: PPUSH
14708: LD_INT 20
14710: PPUSH
14711: LD_INT 1
14713: PPUSH
14714: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14718: LD_INT 350
14720: PPUSH
14721: LD_INT 525
14723: PPUSH
14724: CALL_OW 12
14728: PPUSH
14729: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14733: LD_INT 1
14735: PPUSH
14736: LD_INT 5
14738: PPUSH
14739: CALL_OW 12
14743: PPUSH
14744: LD_INT 9
14746: PPUSH
14747: LD_INT 1
14749: PPUSH
14750: CALL_OW 55
// if time > 4 4$00 then
14754: LD_VAR 0 2
14758: PUSH
14759: LD_INT 8400
14761: GREATER
14762: IFFALSE 14772
// time := 0 0$30 ;
14764: LD_ADDR_VAR 0 2
14768: PUSH
14769: LD_INT 1050
14771: ST_TO_ADDR
// end ;
14772: GO 14641
// end ;
14774: PPOPN 2
14776: END
// every 0 0$30 do var cr , time ;
14777: GO 14779
14779: DISABLE
14780: LD_INT 0
14782: PPUSH
14783: PPUSH
// begin time := 0 0$10 ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 350
14791: ST_TO_ADDR
// while game do
14792: LD_EXP 2
14796: IFFALSE 14930
// begin wait ( time ) ;
14798: LD_VAR 0 2
14802: PPUSH
14803: CALL_OW 67
// time := time + 0 0$10 ;
14807: LD_ADDR_VAR 0 2
14811: PUSH
14812: LD_VAR 0 2
14816: PUSH
14817: LD_INT 350
14819: PLUS
14820: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14821: LD_INT 1
14823: PPUSH
14824: LD_INT 5
14826: PPUSH
14827: CALL_OW 12
14831: PPUSH
14832: LD_INT 11
14834: PPUSH
14835: LD_INT 1
14837: PPUSH
14838: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14842: LD_ADDR_VAR 0 1
14846: PUSH
14847: LD_INT 1
14849: PPUSH
14850: LD_INT 3
14852: PPUSH
14853: CALL_OW 12
14857: ST_TO_ADDR
// if cr = 1 then
14858: LD_VAR 0 1
14862: PUSH
14863: LD_INT 1
14865: EQUAL
14866: IFFALSE 14910
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14868: LD_INT 700
14870: PPUSH
14871: LD_INT 1575
14873: PPUSH
14874: CALL_OW 12
14878: PPUSH
14879: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14883: LD_INT 1
14885: PPUSH
14886: LD_INT 5
14888: PPUSH
14889: CALL_OW 12
14893: PPUSH
14894: LD_INT 34
14896: PPUSH
14897: LD_INT 50
14899: PPUSH
14900: LD_INT 7
14902: PPUSH
14903: LD_INT 1
14905: PPUSH
14906: CALL_OW 56
// end ; if time > 4 4$00 then
14910: LD_VAR 0 2
14914: PUSH
14915: LD_INT 8400
14917: GREATER
14918: IFFALSE 14928
// time := 0 0$40 ;
14920: LD_ADDR_VAR 0 2
14924: PUSH
14925: LD_INT 1400
14927: ST_TO_ADDR
// end ;
14928: GO 14792
// end ; end_of_file
14930: PPOPN 2
14932: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14933: LD_INT 0
14935: PPUSH
14936: PPUSH
// if exist_mode then
14937: LD_VAR 0 2
14941: IFFALSE 14966
// unit := CreateCharacter ( prefix & ident ) else
14943: LD_ADDR_VAR 0 5
14947: PUSH
14948: LD_VAR 0 3
14952: PUSH
14953: LD_VAR 0 1
14957: STR
14958: PPUSH
14959: CALL_OW 34
14963: ST_TO_ADDR
14964: GO 14981
// unit := NewCharacter ( ident ) ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_VAR 0 1
14975: PPUSH
14976: CALL_OW 25
14980: ST_TO_ADDR
// result := unit ;
14981: LD_ADDR_VAR 0 4
14985: PUSH
14986: LD_VAR 0 5
14990: ST_TO_ADDR
// end ;
14991: LD_VAR 0 4
14995: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14996: LD_INT 0
14998: PPUSH
14999: PPUSH
// if not side or not nation then
15000: LD_VAR 0 1
15004: NOT
15005: PUSH
15006: LD_VAR 0 2
15010: NOT
15011: OR
15012: IFFALSE 15016
// exit ;
15014: GO 15784
// case nation of nation_american :
15016: LD_VAR 0 2
15020: PUSH
15021: LD_INT 1
15023: DOUBLE
15024: EQUAL
15025: IFTRUE 15029
15027: GO 15243
15029: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: LD_INT 35
15037: PUSH
15038: LD_INT 45
15040: PUSH
15041: LD_INT 46
15043: PUSH
15044: LD_INT 47
15046: PUSH
15047: LD_INT 82
15049: PUSH
15050: LD_INT 83
15052: PUSH
15053: LD_INT 84
15055: PUSH
15056: LD_INT 85
15058: PUSH
15059: LD_INT 86
15061: PUSH
15062: LD_INT 1
15064: PUSH
15065: LD_INT 2
15067: PUSH
15068: LD_INT 6
15070: PUSH
15071: LD_INT 15
15073: PUSH
15074: LD_INT 16
15076: PUSH
15077: LD_INT 7
15079: PUSH
15080: LD_INT 12
15082: PUSH
15083: LD_INT 13
15085: PUSH
15086: LD_INT 10
15088: PUSH
15089: LD_INT 14
15091: PUSH
15092: LD_INT 20
15094: PUSH
15095: LD_INT 21
15097: PUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 25
15103: PUSH
15104: LD_INT 32
15106: PUSH
15107: LD_INT 27
15109: PUSH
15110: LD_INT 36
15112: PUSH
15113: LD_INT 69
15115: PUSH
15116: LD_INT 39
15118: PUSH
15119: LD_INT 34
15121: PUSH
15122: LD_INT 40
15124: PUSH
15125: LD_INT 48
15127: PUSH
15128: LD_INT 49
15130: PUSH
15131: LD_INT 50
15133: PUSH
15134: LD_INT 51
15136: PUSH
15137: LD_INT 52
15139: PUSH
15140: LD_INT 53
15142: PUSH
15143: LD_INT 54
15145: PUSH
15146: LD_INT 55
15148: PUSH
15149: LD_INT 56
15151: PUSH
15152: LD_INT 57
15154: PUSH
15155: LD_INT 58
15157: PUSH
15158: LD_INT 59
15160: PUSH
15161: LD_INT 60
15163: PUSH
15164: LD_INT 61
15166: PUSH
15167: LD_INT 62
15169: PUSH
15170: LD_INT 80
15172: PUSH
15173: LD_INT 82
15175: PUSH
15176: LD_INT 83
15178: PUSH
15179: LD_INT 84
15181: PUSH
15182: LD_INT 85
15184: PUSH
15185: LD_INT 86
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: LIST
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: ST_TO_ADDR
15241: GO 15708
15243: LD_INT 2
15245: DOUBLE
15246: EQUAL
15247: IFTRUE 15251
15249: GO 15477
15251: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15252: LD_ADDR_VAR 0 4
15256: PUSH
15257: LD_INT 35
15259: PUSH
15260: LD_INT 45
15262: PUSH
15263: LD_INT 46
15265: PUSH
15266: LD_INT 47
15268: PUSH
15269: LD_INT 82
15271: PUSH
15272: LD_INT 83
15274: PUSH
15275: LD_INT 84
15277: PUSH
15278: LD_INT 85
15280: PUSH
15281: LD_INT 87
15283: PUSH
15284: LD_INT 70
15286: PUSH
15287: LD_INT 1
15289: PUSH
15290: LD_INT 11
15292: PUSH
15293: LD_INT 3
15295: PUSH
15296: LD_INT 4
15298: PUSH
15299: LD_INT 5
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: LD_INT 15
15307: PUSH
15308: LD_INT 18
15310: PUSH
15311: LD_INT 7
15313: PUSH
15314: LD_INT 17
15316: PUSH
15317: LD_INT 8
15319: PUSH
15320: LD_INT 20
15322: PUSH
15323: LD_INT 21
15325: PUSH
15326: LD_INT 22
15328: PUSH
15329: LD_INT 72
15331: PUSH
15332: LD_INT 26
15334: PUSH
15335: LD_INT 69
15337: PUSH
15338: LD_INT 39
15340: PUSH
15341: LD_INT 40
15343: PUSH
15344: LD_INT 41
15346: PUSH
15347: LD_INT 42
15349: PUSH
15350: LD_INT 43
15352: PUSH
15353: LD_INT 48
15355: PUSH
15356: LD_INT 49
15358: PUSH
15359: LD_INT 50
15361: PUSH
15362: LD_INT 51
15364: PUSH
15365: LD_INT 52
15367: PUSH
15368: LD_INT 53
15370: PUSH
15371: LD_INT 54
15373: PUSH
15374: LD_INT 55
15376: PUSH
15377: LD_INT 56
15379: PUSH
15380: LD_INT 60
15382: PUSH
15383: LD_INT 61
15385: PUSH
15386: LD_INT 62
15388: PUSH
15389: LD_INT 66
15391: PUSH
15392: LD_INT 67
15394: PUSH
15395: LD_INT 68
15397: PUSH
15398: LD_INT 81
15400: PUSH
15401: LD_INT 82
15403: PUSH
15404: LD_INT 83
15406: PUSH
15407: LD_INT 84
15409: PUSH
15410: LD_INT 85
15412: PUSH
15413: LD_INT 87
15415: PUSH
15416: LD_INT 88
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: ST_TO_ADDR
15475: GO 15708
15477: LD_INT 3
15479: DOUBLE
15480: EQUAL
15481: IFTRUE 15485
15483: GO 15707
15485: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15486: LD_ADDR_VAR 0 4
15490: PUSH
15491: LD_INT 46
15493: PUSH
15494: LD_INT 47
15496: PUSH
15497: LD_INT 1
15499: PUSH
15500: LD_INT 2
15502: PUSH
15503: LD_INT 82
15505: PUSH
15506: LD_INT 83
15508: PUSH
15509: LD_INT 84
15511: PUSH
15512: LD_INT 85
15514: PUSH
15515: LD_INT 86
15517: PUSH
15518: LD_INT 11
15520: PUSH
15521: LD_INT 9
15523: PUSH
15524: LD_INT 20
15526: PUSH
15527: LD_INT 19
15529: PUSH
15530: LD_INT 21
15532: PUSH
15533: LD_INT 24
15535: PUSH
15536: LD_INT 22
15538: PUSH
15539: LD_INT 25
15541: PUSH
15542: LD_INT 28
15544: PUSH
15545: LD_INT 29
15547: PUSH
15548: LD_INT 30
15550: PUSH
15551: LD_INT 31
15553: PUSH
15554: LD_INT 37
15556: PUSH
15557: LD_INT 38
15559: PUSH
15560: LD_INT 32
15562: PUSH
15563: LD_INT 27
15565: PUSH
15566: LD_INT 33
15568: PUSH
15569: LD_INT 69
15571: PUSH
15572: LD_INT 39
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 40
15580: PUSH
15581: LD_INT 71
15583: PUSH
15584: LD_INT 23
15586: PUSH
15587: LD_INT 44
15589: PUSH
15590: LD_INT 48
15592: PUSH
15593: LD_INT 49
15595: PUSH
15596: LD_INT 50
15598: PUSH
15599: LD_INT 51
15601: PUSH
15602: LD_INT 52
15604: PUSH
15605: LD_INT 53
15607: PUSH
15608: LD_INT 54
15610: PUSH
15611: LD_INT 55
15613: PUSH
15614: LD_INT 56
15616: PUSH
15617: LD_INT 57
15619: PUSH
15620: LD_INT 58
15622: PUSH
15623: LD_INT 59
15625: PUSH
15626: LD_INT 63
15628: PUSH
15629: LD_INT 64
15631: PUSH
15632: LD_INT 65
15634: PUSH
15635: LD_INT 82
15637: PUSH
15638: LD_INT 83
15640: PUSH
15641: LD_INT 84
15643: PUSH
15644: LD_INT 85
15646: PUSH
15647: LD_INT 86
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: LIST
15654: LIST
15655: LIST
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: LIST
15665: LIST
15666: LIST
15667: LIST
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: LIST
15700: LIST
15701: LIST
15702: LIST
15703: LIST
15704: ST_TO_ADDR
15705: GO 15708
15707: POP
// if state > - 1 and state < 3 then
15708: LD_VAR 0 3
15712: PUSH
15713: LD_INT 1
15715: NEG
15716: GREATER
15717: PUSH
15718: LD_VAR 0 3
15722: PUSH
15723: LD_INT 3
15725: LESS
15726: AND
15727: IFFALSE 15784
// for i in result do
15729: LD_ADDR_VAR 0 5
15733: PUSH
15734: LD_VAR 0 4
15738: PUSH
15739: FOR_IN
15740: IFFALSE 15782
// if GetTech ( i , side ) <> state then
15742: LD_VAR 0 5
15746: PPUSH
15747: LD_VAR 0 1
15751: PPUSH
15752: CALL_OW 321
15756: PUSH
15757: LD_VAR 0 3
15761: NONEQUAL
15762: IFFALSE 15780
// result := result diff i ;
15764: LD_ADDR_VAR 0 4
15768: PUSH
15769: LD_VAR 0 4
15773: PUSH
15774: LD_VAR 0 5
15778: DIFF
15779: ST_TO_ADDR
15780: GO 15739
15782: POP
15783: POP
// end ;
15784: LD_VAR 0 4
15788: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15789: LD_INT 0
15791: PPUSH
15792: PPUSH
15793: PPUSH
// result := true ;
15794: LD_ADDR_VAR 0 3
15798: PUSH
15799: LD_INT 1
15801: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15802: LD_ADDR_VAR 0 5
15806: PUSH
15807: LD_VAR 0 2
15811: PPUSH
15812: CALL_OW 480
15816: ST_TO_ADDR
// if not tmp then
15817: LD_VAR 0 5
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15875
// for i in tmp do
15826: LD_ADDR_VAR 0 4
15830: PUSH
15831: LD_VAR 0 5
15835: PUSH
15836: FOR_IN
15837: IFFALSE 15873
// if GetTech ( i , side ) <> state_researched then
15839: LD_VAR 0 4
15843: PPUSH
15844: LD_VAR 0 1
15848: PPUSH
15849: CALL_OW 321
15853: PUSH
15854: LD_INT 2
15856: NONEQUAL
15857: IFFALSE 15871
// begin result := false ;
15859: LD_ADDR_VAR 0 3
15863: PUSH
15864: LD_INT 0
15866: ST_TO_ADDR
// exit ;
15867: POP
15868: POP
15869: GO 15875
// end ;
15871: GO 15836
15873: POP
15874: POP
// end ;
15875: LD_VAR 0 3
15879: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15880: LD_INT 0
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
15887: PPUSH
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
15892: PPUSH
15893: PPUSH
15894: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15895: LD_VAR 0 1
15899: NOT
15900: PUSH
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 257
15910: PUSH
15911: LD_INT 9
15913: NONEQUAL
15914: OR
15915: IFFALSE 15919
// exit ;
15917: GO 16492
// side := GetSide ( unit ) ;
15919: LD_ADDR_VAR 0 9
15923: PUSH
15924: LD_VAR 0 1
15928: PPUSH
15929: CALL_OW 255
15933: ST_TO_ADDR
// tech_space := tech_spacanom ;
15934: LD_ADDR_VAR 0 12
15938: PUSH
15939: LD_INT 29
15941: ST_TO_ADDR
// tech_time := tech_taurad ;
15942: LD_ADDR_VAR 0 13
15946: PUSH
15947: LD_INT 28
15949: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15950: LD_ADDR_VAR 0 11
15954: PUSH
15955: LD_VAR 0 1
15959: PPUSH
15960: CALL_OW 310
15964: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15965: LD_VAR 0 11
15969: PPUSH
15970: CALL_OW 247
15974: PUSH
15975: LD_INT 2
15977: EQUAL
15978: IFFALSE 15982
// exit ;
15980: GO 16492
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15982: LD_ADDR_VAR 0 8
15986: PUSH
15987: LD_INT 81
15989: PUSH
15990: LD_VAR 0 9
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: LD_INT 3
16001: PUSH
16002: LD_INT 21
16004: PUSH
16005: LD_INT 3
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PPUSH
16020: CALL_OW 69
16024: ST_TO_ADDR
// if not tmp then
16025: LD_VAR 0 8
16029: NOT
16030: IFFALSE 16034
// exit ;
16032: GO 16492
// if in_unit then
16034: LD_VAR 0 11
16038: IFFALSE 16062
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16040: LD_ADDR_VAR 0 10
16044: PUSH
16045: LD_VAR 0 8
16049: PPUSH
16050: LD_VAR 0 11
16054: PPUSH
16055: CALL_OW 74
16059: ST_TO_ADDR
16060: GO 16082
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16062: LD_ADDR_VAR 0 10
16066: PUSH
16067: LD_VAR 0 8
16071: PPUSH
16072: LD_VAR 0 1
16076: PPUSH
16077: CALL_OW 74
16081: ST_TO_ADDR
// if not enemy then
16082: LD_VAR 0 10
16086: NOT
16087: IFFALSE 16091
// exit ;
16089: GO 16492
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16091: LD_VAR 0 11
16095: PUSH
16096: LD_VAR 0 11
16100: PPUSH
16101: LD_VAR 0 10
16105: PPUSH
16106: CALL_OW 296
16110: PUSH
16111: LD_INT 13
16113: GREATER
16114: AND
16115: PUSH
16116: LD_VAR 0 1
16120: PPUSH
16121: LD_VAR 0 10
16125: PPUSH
16126: CALL_OW 296
16130: PUSH
16131: LD_INT 12
16133: GREATER
16134: OR
16135: IFFALSE 16139
// exit ;
16137: GO 16492
// missile := [ 1 ] ;
16139: LD_ADDR_VAR 0 14
16143: PUSH
16144: LD_INT 1
16146: PUSH
16147: EMPTY
16148: LIST
16149: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16150: LD_VAR 0 9
16154: PPUSH
16155: LD_VAR 0 12
16159: PPUSH
16160: CALL_OW 325
16164: IFFALSE 16193
// missile := Replace ( missile , missile + 1 , 2 ) ;
16166: LD_ADDR_VAR 0 14
16170: PUSH
16171: LD_VAR 0 14
16175: PPUSH
16176: LD_VAR 0 14
16180: PUSH
16181: LD_INT 1
16183: PLUS
16184: PPUSH
16185: LD_INT 2
16187: PPUSH
16188: CALL_OW 1
16192: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16193: LD_VAR 0 9
16197: PPUSH
16198: LD_VAR 0 13
16202: PPUSH
16203: CALL_OW 325
16207: PUSH
16208: LD_VAR 0 10
16212: PPUSH
16213: CALL_OW 255
16217: PPUSH
16218: LD_VAR 0 13
16222: PPUSH
16223: CALL_OW 325
16227: NOT
16228: AND
16229: IFFALSE 16258
// missile := Replace ( missile , missile + 1 , 3 ) ;
16231: LD_ADDR_VAR 0 14
16235: PUSH
16236: LD_VAR 0 14
16240: PPUSH
16241: LD_VAR 0 14
16245: PUSH
16246: LD_INT 1
16248: PLUS
16249: PPUSH
16250: LD_INT 3
16252: PPUSH
16253: CALL_OW 1
16257: ST_TO_ADDR
// if missile < 2 then
16258: LD_VAR 0 14
16262: PUSH
16263: LD_INT 2
16265: LESS
16266: IFFALSE 16270
// exit ;
16268: GO 16492
// x := GetX ( enemy ) ;
16270: LD_ADDR_VAR 0 4
16274: PUSH
16275: LD_VAR 0 10
16279: PPUSH
16280: CALL_OW 250
16284: ST_TO_ADDR
// y := GetY ( enemy ) ;
16285: LD_ADDR_VAR 0 5
16289: PUSH
16290: LD_VAR 0 10
16294: PPUSH
16295: CALL_OW 251
16299: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16300: LD_ADDR_VAR 0 6
16304: PUSH
16305: LD_VAR 0 4
16309: PUSH
16310: LD_INT 1
16312: NEG
16313: PPUSH
16314: LD_INT 1
16316: PPUSH
16317: CALL_OW 12
16321: PLUS
16322: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16323: LD_ADDR_VAR 0 7
16327: PUSH
16328: LD_VAR 0 5
16332: PUSH
16333: LD_INT 1
16335: NEG
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 12
16344: PLUS
16345: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16346: LD_VAR 0 6
16350: PPUSH
16351: LD_VAR 0 7
16355: PPUSH
16356: CALL_OW 488
16360: NOT
16361: IFFALSE 16383
// begin _x := x ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 4
16372: ST_TO_ADDR
// _y := y ;
16373: LD_ADDR_VAR 0 7
16377: PUSH
16378: LD_VAR 0 5
16382: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16383: LD_ADDR_VAR 0 3
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_VAR 0 14
16395: PPUSH
16396: CALL_OW 12
16400: ST_TO_ADDR
// case i of 1 :
16401: LD_VAR 0 3
16405: PUSH
16406: LD_INT 1
16408: DOUBLE
16409: EQUAL
16410: IFTRUE 16414
16412: GO 16431
16414: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16415: LD_VAR 0 1
16419: PPUSH
16420: LD_VAR 0 10
16424: PPUSH
16425: CALL_OW 115
16429: GO 16492
16431: LD_INT 2
16433: DOUBLE
16434: EQUAL
16435: IFTRUE 16439
16437: GO 16461
16439: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16440: LD_VAR 0 1
16444: PPUSH
16445: LD_VAR 0 6
16449: PPUSH
16450: LD_VAR 0 7
16454: PPUSH
16455: CALL_OW 153
16459: GO 16492
16461: LD_INT 3
16463: DOUBLE
16464: EQUAL
16465: IFTRUE 16469
16467: GO 16491
16469: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16470: LD_VAR 0 1
16474: PPUSH
16475: LD_VAR 0 6
16479: PPUSH
16480: LD_VAR 0 7
16484: PPUSH
16485: CALL_OW 154
16489: GO 16492
16491: POP
// end ;
16492: LD_VAR 0 2
16496: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16497: LD_INT 0
16499: PPUSH
16500: PPUSH
16501: PPUSH
16502: PPUSH
16503: PPUSH
16504: PPUSH
// if not unit or not building then
16505: LD_VAR 0 1
16509: NOT
16510: PUSH
16511: LD_VAR 0 2
16515: NOT
16516: OR
16517: IFFALSE 16521
// exit ;
16519: GO 16679
// x := GetX ( building ) ;
16521: LD_ADDR_VAR 0 5
16525: PUSH
16526: LD_VAR 0 2
16530: PPUSH
16531: CALL_OW 250
16535: ST_TO_ADDR
// y := GetY ( building ) ;
16536: LD_ADDR_VAR 0 6
16540: PUSH
16541: LD_VAR 0 2
16545: PPUSH
16546: CALL_OW 251
16550: ST_TO_ADDR
// for i = 0 to 5 do
16551: LD_ADDR_VAR 0 4
16555: PUSH
16556: DOUBLE
16557: LD_INT 0
16559: DEC
16560: ST_TO_ADDR
16561: LD_INT 5
16563: PUSH
16564: FOR_TO
16565: IFFALSE 16677
// begin _x := ShiftX ( x , i , 3 ) ;
16567: LD_ADDR_VAR 0 7
16571: PUSH
16572: LD_VAR 0 5
16576: PPUSH
16577: LD_VAR 0 4
16581: PPUSH
16582: LD_INT 3
16584: PPUSH
16585: CALL_OW 272
16589: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16590: LD_ADDR_VAR 0 8
16594: PUSH
16595: LD_VAR 0 6
16599: PPUSH
16600: LD_VAR 0 4
16604: PPUSH
16605: LD_INT 3
16607: PPUSH
16608: CALL_OW 273
16612: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16613: LD_VAR 0 7
16617: PPUSH
16618: LD_VAR 0 8
16622: PPUSH
16623: CALL_OW 488
16627: NOT
16628: IFFALSE 16632
// continue ;
16630: GO 16564
// if HexInfo ( _x , _y ) = 0 then
16632: LD_VAR 0 7
16636: PPUSH
16637: LD_VAR 0 8
16641: PPUSH
16642: CALL_OW 428
16646: PUSH
16647: LD_INT 0
16649: EQUAL
16650: IFFALSE 16675
// begin ComMoveXY ( unit , _x , _y ) ;
16652: LD_VAR 0 1
16656: PPUSH
16657: LD_VAR 0 7
16661: PPUSH
16662: LD_VAR 0 8
16666: PPUSH
16667: CALL_OW 111
// exit ;
16671: POP
16672: POP
16673: GO 16679
// end ; end ;
16675: GO 16564
16677: POP
16678: POP
// end ;
16679: LD_VAR 0 3
16683: RET
// export function ScanBase ( side , base_area ) ; begin
16684: LD_INT 0
16686: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16687: LD_ADDR_VAR 0 3
16691: PUSH
16692: LD_VAR 0 2
16696: PPUSH
16697: LD_INT 81
16699: PUSH
16700: LD_VAR 0 1
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PPUSH
16709: CALL_OW 70
16713: ST_TO_ADDR
// end ;
16714: LD_VAR 0 3
16718: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16719: LD_INT 0
16721: PPUSH
16722: PPUSH
16723: PPUSH
16724: PPUSH
// result := false ;
16725: LD_ADDR_VAR 0 2
16729: PUSH
16730: LD_INT 0
16732: ST_TO_ADDR
// side := GetSide ( unit ) ;
16733: LD_ADDR_VAR 0 3
16737: PUSH
16738: LD_VAR 0 1
16742: PPUSH
16743: CALL_OW 255
16747: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16748: LD_ADDR_VAR 0 4
16752: PUSH
16753: LD_VAR 0 1
16757: PPUSH
16758: CALL_OW 248
16762: ST_TO_ADDR
// case nat of 1 :
16763: LD_VAR 0 4
16767: PUSH
16768: LD_INT 1
16770: DOUBLE
16771: EQUAL
16772: IFTRUE 16776
16774: GO 16787
16776: POP
// tech := tech_lassight ; 2 :
16777: LD_ADDR_VAR 0 5
16781: PUSH
16782: LD_INT 12
16784: ST_TO_ADDR
16785: GO 16826
16787: LD_INT 2
16789: DOUBLE
16790: EQUAL
16791: IFTRUE 16795
16793: GO 16806
16795: POP
// tech := tech_mortar ; 3 :
16796: LD_ADDR_VAR 0 5
16800: PUSH
16801: LD_INT 41
16803: ST_TO_ADDR
16804: GO 16826
16806: LD_INT 3
16808: DOUBLE
16809: EQUAL
16810: IFTRUE 16814
16812: GO 16825
16814: POP
// tech := tech_bazooka ; end ;
16815: LD_ADDR_VAR 0 5
16819: PUSH
16820: LD_INT 44
16822: ST_TO_ADDR
16823: GO 16826
16825: POP
// if Researched ( side , tech ) then
16826: LD_VAR 0 3
16830: PPUSH
16831: LD_VAR 0 5
16835: PPUSH
16836: CALL_OW 325
16840: IFFALSE 16867
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16842: LD_ADDR_VAR 0 2
16846: PUSH
16847: LD_INT 5
16849: PUSH
16850: LD_INT 8
16852: PUSH
16853: LD_INT 9
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: LIST
16860: PUSH
16861: LD_VAR 0 4
16865: ARRAY
16866: ST_TO_ADDR
// end ;
16867: LD_VAR 0 2
16871: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16872: LD_INT 0
16874: PPUSH
16875: PPUSH
16876: PPUSH
// if not mines then
16877: LD_VAR 0 2
16881: NOT
16882: IFFALSE 16886
// exit ;
16884: GO 17030
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16886: LD_ADDR_VAR 0 5
16890: PUSH
16891: LD_INT 81
16893: PUSH
16894: LD_VAR 0 1
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 3
16905: PUSH
16906: LD_INT 21
16908: PUSH
16909: LD_INT 3
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PPUSH
16924: CALL_OW 69
16928: ST_TO_ADDR
// for i in mines do
16929: LD_ADDR_VAR 0 4
16933: PUSH
16934: LD_VAR 0 2
16938: PUSH
16939: FOR_IN
16940: IFFALSE 17028
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16942: LD_VAR 0 4
16946: PUSH
16947: LD_INT 1
16949: ARRAY
16950: PPUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_INT 2
16958: ARRAY
16959: PPUSH
16960: CALL_OW 458
16964: NOT
16965: IFFALSE 16969
// continue ;
16967: GO 16939
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16969: LD_VAR 0 4
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PUSH
16983: LD_INT 2
16985: ARRAY
16986: PPUSH
16987: CALL_OW 428
16991: PUSH
16992: LD_VAR 0 5
16996: IN
16997: IFFALSE 17026
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16999: LD_VAR 0 4
17003: PUSH
17004: LD_INT 1
17006: ARRAY
17007: PPUSH
17008: LD_VAR 0 4
17012: PUSH
17013: LD_INT 2
17015: ARRAY
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: CALL_OW 456
// end ;
17026: GO 16939
17028: POP
17029: POP
// end ;
17030: LD_VAR 0 3
17034: RET
// export function Count ( array ) ; var i ; begin
17035: LD_INT 0
17037: PPUSH
17038: PPUSH
// result := 0 ;
17039: LD_ADDR_VAR 0 2
17043: PUSH
17044: LD_INT 0
17046: ST_TO_ADDR
// for i in array do
17047: LD_ADDR_VAR 0 3
17051: PUSH
17052: LD_VAR 0 1
17056: PUSH
17057: FOR_IN
17058: IFFALSE 17082
// if i then
17060: LD_VAR 0 3
17064: IFFALSE 17080
// result := result + 1 ;
17066: LD_ADDR_VAR 0 2
17070: PUSH
17071: LD_VAR 0 2
17075: PUSH
17076: LD_INT 1
17078: PLUS
17079: ST_TO_ADDR
17080: GO 17057
17082: POP
17083: POP
// end ;
17084: LD_VAR 0 2
17088: RET
// export function IsEmpty ( building ) ; begin
17089: LD_INT 0
17091: PPUSH
// if not building then
17092: LD_VAR 0 1
17096: NOT
17097: IFFALSE 17101
// exit ;
17099: GO 17144
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17101: LD_ADDR_VAR 0 2
17105: PUSH
17106: LD_VAR 0 1
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_VAR 0 1
17118: PPUSH
17119: CALL_OW 255
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PUSH
17128: LD_INT 58
17130: PUSH
17131: EMPTY
17132: LIST
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PPUSH
17138: CALL_OW 69
17142: IN
17143: ST_TO_ADDR
// end ;
17144: LD_VAR 0 2
17148: RET
// export function IsNotFull ( building ) ; var places ; begin
17149: LD_INT 0
17151: PPUSH
17152: PPUSH
// if not building then
17153: LD_VAR 0 1
17157: NOT
17158: IFFALSE 17162
// exit ;
17160: GO 17333
// result := false ;
17162: LD_ADDR_VAR 0 2
17166: PUSH
17167: LD_INT 0
17169: ST_TO_ADDR
// places := 0 ;
17170: LD_ADDR_VAR 0 3
17174: PUSH
17175: LD_INT 0
17177: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 266
17187: PUSH
17188: LD_INT 0
17190: DOUBLE
17191: EQUAL
17192: IFTRUE 17250
17194: LD_INT 1
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17250
17200: LD_INT 6
17202: DOUBLE
17203: EQUAL
17204: IFTRUE 17250
17206: LD_INT 7
17208: DOUBLE
17209: EQUAL
17210: IFTRUE 17250
17212: LD_INT 8
17214: DOUBLE
17215: EQUAL
17216: IFTRUE 17250
17218: LD_INT 4
17220: DOUBLE
17221: EQUAL
17222: IFTRUE 17250
17224: LD_INT 5
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17250
17230: LD_INT 2
17232: DOUBLE
17233: EQUAL
17234: IFTRUE 17250
17236: LD_INT 3
17238: DOUBLE
17239: EQUAL
17240: IFTRUE 17250
17242: LD_INT 35
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17261
17250: POP
// places := 6 ; b_bunker , b_breastwork :
17251: LD_ADDR_VAR 0 3
17255: PUSH
17256: LD_INT 6
17258: ST_TO_ADDR
17259: GO 17306
17261: LD_INT 32
17263: DOUBLE
17264: EQUAL
17265: IFTRUE 17275
17267: LD_INT 31
17269: DOUBLE
17270: EQUAL
17271: IFTRUE 17275
17273: GO 17286
17275: POP
// places := 1 ; b_control_tower :
17276: LD_ADDR_VAR 0 3
17280: PUSH
17281: LD_INT 1
17283: ST_TO_ADDR
17284: GO 17306
17286: LD_INT 36
17288: DOUBLE
17289: EQUAL
17290: IFTRUE 17294
17292: GO 17305
17294: POP
// places := 3 ; end ;
17295: LD_ADDR_VAR 0 3
17299: PUSH
17300: LD_INT 3
17302: ST_TO_ADDR
17303: GO 17306
17305: POP
// if places then
17306: LD_VAR 0 3
17310: IFFALSE 17333
// result := UnitsInside ( building ) < places ;
17312: LD_ADDR_VAR 0 2
17316: PUSH
17317: LD_VAR 0 1
17321: PPUSH
17322: CALL_OW 313
17326: PUSH
17327: LD_VAR 0 3
17331: LESS
17332: ST_TO_ADDR
// end ;
17333: LD_VAR 0 2
17337: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17338: LD_INT 0
17340: PPUSH
17341: PPUSH
17342: PPUSH
17343: PPUSH
// tmp := [ ] ;
17344: LD_ADDR_VAR 0 3
17348: PUSH
17349: EMPTY
17350: ST_TO_ADDR
// list := [ ] ;
17351: LD_ADDR_VAR 0 5
17355: PUSH
17356: EMPTY
17357: ST_TO_ADDR
// for i = 16 to 25 do
17358: LD_ADDR_VAR 0 4
17362: PUSH
17363: DOUBLE
17364: LD_INT 16
17366: DEC
17367: ST_TO_ADDR
17368: LD_INT 25
17370: PUSH
17371: FOR_TO
17372: IFFALSE 17445
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17374: LD_ADDR_VAR 0 3
17378: PUSH
17379: LD_VAR 0 3
17383: PUSH
17384: LD_INT 22
17386: PUSH
17387: LD_VAR 0 1
17391: PPUSH
17392: CALL_OW 255
17396: PUSH
17397: EMPTY
17398: LIST
17399: LIST
17400: PUSH
17401: LD_INT 91
17403: PUSH
17404: LD_VAR 0 1
17408: PUSH
17409: LD_INT 6
17411: PUSH
17412: EMPTY
17413: LIST
17414: LIST
17415: LIST
17416: PUSH
17417: LD_INT 30
17419: PUSH
17420: LD_VAR 0 4
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PUSH
17429: EMPTY
17430: LIST
17431: LIST
17432: LIST
17433: PUSH
17434: EMPTY
17435: LIST
17436: PPUSH
17437: CALL_OW 69
17441: ADD
17442: ST_TO_ADDR
17443: GO 17371
17445: POP
17446: POP
// for i = 1 to tmp do
17447: LD_ADDR_VAR 0 4
17451: PUSH
17452: DOUBLE
17453: LD_INT 1
17455: DEC
17456: ST_TO_ADDR
17457: LD_VAR 0 3
17461: PUSH
17462: FOR_TO
17463: IFFALSE 17551
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17465: LD_ADDR_VAR 0 5
17469: PUSH
17470: LD_VAR 0 5
17474: PUSH
17475: LD_VAR 0 3
17479: PUSH
17480: LD_VAR 0 4
17484: ARRAY
17485: PPUSH
17486: CALL_OW 266
17490: PUSH
17491: LD_VAR 0 3
17495: PUSH
17496: LD_VAR 0 4
17500: ARRAY
17501: PPUSH
17502: CALL_OW 250
17506: PUSH
17507: LD_VAR 0 3
17511: PUSH
17512: LD_VAR 0 4
17516: ARRAY
17517: PPUSH
17518: CALL_OW 251
17522: PUSH
17523: LD_VAR 0 3
17527: PUSH
17528: LD_VAR 0 4
17532: ARRAY
17533: PPUSH
17534: CALL_OW 254
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: PUSH
17545: EMPTY
17546: LIST
17547: ADD
17548: ST_TO_ADDR
17549: GO 17462
17551: POP
17552: POP
// result := list ;
17553: LD_ADDR_VAR 0 2
17557: PUSH
17558: LD_VAR 0 5
17562: ST_TO_ADDR
// end ;
17563: LD_VAR 0 2
17567: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17568: LD_INT 0
17570: PPUSH
17571: PPUSH
17572: PPUSH
17573: PPUSH
17574: PPUSH
17575: PPUSH
17576: PPUSH
// if not factory then
17577: LD_VAR 0 1
17581: NOT
17582: IFFALSE 17586
// exit ;
17584: GO 18179
// if control = control_apeman then
17586: LD_VAR 0 4
17590: PUSH
17591: LD_INT 5
17593: EQUAL
17594: IFFALSE 17703
// begin tmp := UnitsInside ( factory ) ;
17596: LD_ADDR_VAR 0 8
17600: PUSH
17601: LD_VAR 0 1
17605: PPUSH
17606: CALL_OW 313
17610: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17611: LD_VAR 0 8
17615: PPUSH
17616: LD_INT 25
17618: PUSH
17619: LD_INT 12
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: PPUSH
17626: CALL_OW 72
17630: NOT
17631: IFFALSE 17641
// control := control_manual ;
17633: LD_ADDR_VAR 0 4
17637: PUSH
17638: LD_INT 1
17640: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17641: LD_ADDR_VAR 0 8
17645: PUSH
17646: LD_VAR 0 1
17650: PPUSH
17651: CALL 17338 0 1
17655: ST_TO_ADDR
// if tmp then
17656: LD_VAR 0 8
17660: IFFALSE 17703
// begin for i in tmp do
17662: LD_ADDR_VAR 0 7
17666: PUSH
17667: LD_VAR 0 8
17671: PUSH
17672: FOR_IN
17673: IFFALSE 17701
// if i [ 1 ] = b_ext_radio then
17675: LD_VAR 0 7
17679: PUSH
17680: LD_INT 1
17682: ARRAY
17683: PUSH
17684: LD_INT 22
17686: EQUAL
17687: IFFALSE 17699
// begin control := control_remote ;
17689: LD_ADDR_VAR 0 4
17693: PUSH
17694: LD_INT 2
17696: ST_TO_ADDR
// break ;
17697: GO 17701
// end ;
17699: GO 17672
17701: POP
17702: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_VAR 0 2
17712: PPUSH
17713: LD_VAR 0 3
17717: PPUSH
17718: LD_VAR 0 4
17722: PPUSH
17723: LD_VAR 0 5
17727: PPUSH
17728: CALL_OW 448
17732: IFFALSE 17767
// begin result := [ chassis , engine , control , weapon ] ;
17734: LD_ADDR_VAR 0 6
17738: PUSH
17739: LD_VAR 0 2
17743: PUSH
17744: LD_VAR 0 3
17748: PUSH
17749: LD_VAR 0 4
17753: PUSH
17754: LD_VAR 0 5
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: ST_TO_ADDR
// exit ;
17765: GO 18179
// end ; _chassis := AvailableChassisList ( factory ) ;
17767: LD_ADDR_VAR 0 9
17771: PUSH
17772: LD_VAR 0 1
17776: PPUSH
17777: CALL_OW 475
17781: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17782: LD_ADDR_VAR 0 11
17786: PUSH
17787: LD_VAR 0 1
17791: PPUSH
17792: CALL_OW 476
17796: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17797: LD_ADDR_VAR 0 12
17801: PUSH
17802: LD_VAR 0 1
17806: PPUSH
17807: CALL_OW 477
17811: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17812: LD_ADDR_VAR 0 10
17816: PUSH
17817: LD_VAR 0 1
17821: PPUSH
17822: CALL_OW 478
17826: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17827: LD_VAR 0 9
17831: NOT
17832: PUSH
17833: LD_VAR 0 11
17837: NOT
17838: OR
17839: PUSH
17840: LD_VAR 0 12
17844: NOT
17845: OR
17846: PUSH
17847: LD_VAR 0 10
17851: NOT
17852: OR
17853: IFFALSE 17888
// begin result := [ chassis , engine , control , weapon ] ;
17855: LD_ADDR_VAR 0 6
17859: PUSH
17860: LD_VAR 0 2
17864: PUSH
17865: LD_VAR 0 3
17869: PUSH
17870: LD_VAR 0 4
17874: PUSH
17875: LD_VAR 0 5
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// exit ;
17886: GO 18179
// end ; if not chassis in _chassis then
17888: LD_VAR 0 2
17892: PUSH
17893: LD_VAR 0 9
17897: IN
17898: NOT
17899: IFFALSE 17925
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17901: LD_ADDR_VAR 0 2
17905: PUSH
17906: LD_VAR 0 9
17910: PUSH
17911: LD_INT 1
17913: PPUSH
17914: LD_VAR 0 9
17918: PPUSH
17919: CALL_OW 12
17923: ARRAY
17924: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17925: LD_VAR 0 2
17929: PPUSH
17930: LD_VAR 0 3
17934: PPUSH
17935: CALL 18184 0 2
17939: NOT
17940: IFFALSE 17999
// repeat engine := _engine [ 1 ] ;
17942: LD_ADDR_VAR 0 3
17946: PUSH
17947: LD_VAR 0 11
17951: PUSH
17952: LD_INT 1
17954: ARRAY
17955: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17956: LD_ADDR_VAR 0 11
17960: PUSH
17961: LD_VAR 0 11
17965: PPUSH
17966: LD_INT 1
17968: PPUSH
17969: CALL_OW 3
17973: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17974: LD_VAR 0 2
17978: PPUSH
17979: LD_VAR 0 3
17983: PPUSH
17984: CALL 18184 0 2
17988: PUSH
17989: LD_VAR 0 11
17993: PUSH
17994: EMPTY
17995: EQUAL
17996: OR
17997: IFFALSE 17942
// if not control in _control then
17999: LD_VAR 0 4
18003: PUSH
18004: LD_VAR 0 12
18008: IN
18009: NOT
18010: IFFALSE 18036
// control := _control [ rand ( 1 , _control ) ] ;
18012: LD_ADDR_VAR 0 4
18016: PUSH
18017: LD_VAR 0 12
18021: PUSH
18022: LD_INT 1
18024: PPUSH
18025: LD_VAR 0 12
18029: PPUSH
18030: CALL_OW 12
18034: ARRAY
18035: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18036: LD_VAR 0 2
18040: PPUSH
18041: LD_VAR 0 5
18045: PPUSH
18046: CALL 18404 0 2
18050: NOT
18051: IFFALSE 18110
// repeat weapon := _weapon [ 1 ] ;
18053: LD_ADDR_VAR 0 5
18057: PUSH
18058: LD_VAR 0 10
18062: PUSH
18063: LD_INT 1
18065: ARRAY
18066: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18067: LD_ADDR_VAR 0 10
18071: PUSH
18072: LD_VAR 0 10
18076: PPUSH
18077: LD_INT 1
18079: PPUSH
18080: CALL_OW 3
18084: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18085: LD_VAR 0 2
18089: PPUSH
18090: LD_VAR 0 5
18094: PPUSH
18095: CALL 18404 0 2
18099: PUSH
18100: LD_VAR 0 10
18104: PUSH
18105: EMPTY
18106: EQUAL
18107: OR
18108: IFFALSE 18053
// result := [ ] ;
18110: LD_ADDR_VAR 0 6
18114: PUSH
18115: EMPTY
18116: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18117: LD_VAR 0 1
18121: PPUSH
18122: LD_VAR 0 2
18126: PPUSH
18127: LD_VAR 0 3
18131: PPUSH
18132: LD_VAR 0 4
18136: PPUSH
18137: LD_VAR 0 5
18141: PPUSH
18142: CALL_OW 448
18146: IFFALSE 18179
// result := [ chassis , engine , control , weapon ] ;
18148: LD_ADDR_VAR 0 6
18152: PUSH
18153: LD_VAR 0 2
18157: PUSH
18158: LD_VAR 0 3
18162: PUSH
18163: LD_VAR 0 4
18167: PUSH
18168: LD_VAR 0 5
18172: PUSH
18173: EMPTY
18174: LIST
18175: LIST
18176: LIST
18177: LIST
18178: ST_TO_ADDR
// end ;
18179: LD_VAR 0 6
18183: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18184: LD_INT 0
18186: PPUSH
// if not chassis or not engine then
18187: LD_VAR 0 1
18191: NOT
18192: PUSH
18193: LD_VAR 0 2
18197: NOT
18198: OR
18199: IFFALSE 18203
// exit ;
18201: GO 18399
// case engine of engine_solar :
18203: LD_VAR 0 2
18207: PUSH
18208: LD_INT 2
18210: DOUBLE
18211: EQUAL
18212: IFTRUE 18216
18214: GO 18254
18216: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18217: LD_ADDR_VAR 0 3
18221: PUSH
18222: LD_INT 11
18224: PUSH
18225: LD_INT 12
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: LD_INT 1
18236: PUSH
18237: LD_INT 2
18239: PUSH
18240: LD_INT 3
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: ST_TO_ADDR
18252: GO 18383
18254: LD_INT 1
18256: DOUBLE
18257: EQUAL
18258: IFTRUE 18262
18260: GO 18324
18262: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18263: LD_ADDR_VAR 0 3
18267: PUSH
18268: LD_INT 11
18270: PUSH
18271: LD_INT 12
18273: PUSH
18274: LD_INT 13
18276: PUSH
18277: LD_INT 14
18279: PUSH
18280: LD_INT 1
18282: PUSH
18283: LD_INT 2
18285: PUSH
18286: LD_INT 3
18288: PUSH
18289: LD_INT 4
18291: PUSH
18292: LD_INT 5
18294: PUSH
18295: LD_INT 21
18297: PUSH
18298: LD_INT 23
18300: PUSH
18301: LD_INT 22
18303: PUSH
18304: LD_INT 24
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: LIST
18311: LIST
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: ST_TO_ADDR
18322: GO 18383
18324: LD_INT 3
18326: DOUBLE
18327: EQUAL
18328: IFTRUE 18332
18330: GO 18382
18332: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18333: LD_ADDR_VAR 0 3
18337: PUSH
18338: LD_INT 13
18340: PUSH
18341: LD_INT 14
18343: PUSH
18344: LD_INT 2
18346: PUSH
18347: LD_INT 3
18349: PUSH
18350: LD_INT 4
18352: PUSH
18353: LD_INT 5
18355: PUSH
18356: LD_INT 21
18358: PUSH
18359: LD_INT 22
18361: PUSH
18362: LD_INT 23
18364: PUSH
18365: LD_INT 24
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: LIST
18375: LIST
18376: LIST
18377: LIST
18378: LIST
18379: ST_TO_ADDR
18380: GO 18383
18382: POP
// result := ( chassis in result ) ;
18383: LD_ADDR_VAR 0 3
18387: PUSH
18388: LD_VAR 0 1
18392: PUSH
18393: LD_VAR 0 3
18397: IN
18398: ST_TO_ADDR
// end ;
18399: LD_VAR 0 3
18403: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18404: LD_INT 0
18406: PPUSH
// if not chassis or not weapon then
18407: LD_VAR 0 1
18411: NOT
18412: PUSH
18413: LD_VAR 0 2
18417: NOT
18418: OR
18419: IFFALSE 18423
// exit ;
18421: GO 19483
// case weapon of us_machine_gun :
18423: LD_VAR 0 2
18427: PUSH
18428: LD_INT 2
18430: DOUBLE
18431: EQUAL
18432: IFTRUE 18436
18434: GO 18466
18436: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18437: LD_ADDR_VAR 0 3
18441: PUSH
18442: LD_INT 1
18444: PUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 3
18450: PUSH
18451: LD_INT 4
18453: PUSH
18454: LD_INT 5
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: ST_TO_ADDR
18464: GO 19467
18466: LD_INT 3
18468: DOUBLE
18469: EQUAL
18470: IFTRUE 18474
18472: GO 18504
18474: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18475: LD_ADDR_VAR 0 3
18479: PUSH
18480: LD_INT 1
18482: PUSH
18483: LD_INT 2
18485: PUSH
18486: LD_INT 3
18488: PUSH
18489: LD_INT 4
18491: PUSH
18492: LD_INT 5
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: ST_TO_ADDR
18502: GO 19467
18504: LD_INT 11
18506: DOUBLE
18507: EQUAL
18508: IFTRUE 18512
18510: GO 18542
18512: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18513: LD_ADDR_VAR 0 3
18517: PUSH
18518: LD_INT 1
18520: PUSH
18521: LD_INT 2
18523: PUSH
18524: LD_INT 3
18526: PUSH
18527: LD_INT 4
18529: PUSH
18530: LD_INT 5
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: ST_TO_ADDR
18540: GO 19467
18542: LD_INT 4
18544: DOUBLE
18545: EQUAL
18546: IFTRUE 18550
18548: GO 18576
18550: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18551: LD_ADDR_VAR 0 3
18555: PUSH
18556: LD_INT 2
18558: PUSH
18559: LD_INT 3
18561: PUSH
18562: LD_INT 4
18564: PUSH
18565: LD_INT 5
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: ST_TO_ADDR
18574: GO 19467
18576: LD_INT 5
18578: DOUBLE
18579: EQUAL
18580: IFTRUE 18584
18582: GO 18610
18584: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_INT 2
18592: PUSH
18593: LD_INT 3
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: LD_INT 5
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: ST_TO_ADDR
18608: GO 19467
18610: LD_INT 9
18612: DOUBLE
18613: EQUAL
18614: IFTRUE 18618
18616: GO 18644
18618: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_INT 2
18626: PUSH
18627: LD_INT 3
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: LD_INT 5
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: ST_TO_ADDR
18642: GO 19467
18644: LD_INT 7
18646: DOUBLE
18647: EQUAL
18648: IFTRUE 18652
18650: GO 18678
18652: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18653: LD_ADDR_VAR 0 3
18657: PUSH
18658: LD_INT 2
18660: PUSH
18661: LD_INT 3
18663: PUSH
18664: LD_INT 4
18666: PUSH
18667: LD_INT 5
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
18676: GO 19467
18678: LD_INT 12
18680: DOUBLE
18681: EQUAL
18682: IFTRUE 18686
18684: GO 18712
18686: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18687: LD_ADDR_VAR 0 3
18691: PUSH
18692: LD_INT 2
18694: PUSH
18695: LD_INT 3
18697: PUSH
18698: LD_INT 4
18700: PUSH
18701: LD_INT 5
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
18710: GO 19467
18712: LD_INT 13
18714: DOUBLE
18715: EQUAL
18716: IFTRUE 18720
18718: GO 18746
18720: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18721: LD_ADDR_VAR 0 3
18725: PUSH
18726: LD_INT 2
18728: PUSH
18729: LD_INT 3
18731: PUSH
18732: LD_INT 4
18734: PUSH
18735: LD_INT 5
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: LIST
18742: LIST
18743: ST_TO_ADDR
18744: GO 19467
18746: LD_INT 14
18748: DOUBLE
18749: EQUAL
18750: IFTRUE 18754
18752: GO 18772
18754: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18755: LD_ADDR_VAR 0 3
18759: PUSH
18760: LD_INT 4
18762: PUSH
18763: LD_INT 5
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: ST_TO_ADDR
18770: GO 19467
18772: LD_INT 6
18774: DOUBLE
18775: EQUAL
18776: IFTRUE 18780
18778: GO 18798
18780: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18781: LD_ADDR_VAR 0 3
18785: PUSH
18786: LD_INT 4
18788: PUSH
18789: LD_INT 5
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: ST_TO_ADDR
18796: GO 19467
18798: LD_INT 10
18800: DOUBLE
18801: EQUAL
18802: IFTRUE 18806
18804: GO 18824
18806: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18807: LD_ADDR_VAR 0 3
18811: PUSH
18812: LD_INT 4
18814: PUSH
18815: LD_INT 5
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: ST_TO_ADDR
18822: GO 19467
18824: LD_INT 22
18826: DOUBLE
18827: EQUAL
18828: IFTRUE 18832
18830: GO 18858
18832: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18833: LD_ADDR_VAR 0 3
18837: PUSH
18838: LD_INT 11
18840: PUSH
18841: LD_INT 12
18843: PUSH
18844: LD_INT 13
18846: PUSH
18847: LD_INT 14
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: ST_TO_ADDR
18856: GO 19467
18858: LD_INT 23
18860: DOUBLE
18861: EQUAL
18862: IFTRUE 18866
18864: GO 18892
18866: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18867: LD_ADDR_VAR 0 3
18871: PUSH
18872: LD_INT 11
18874: PUSH
18875: LD_INT 12
18877: PUSH
18878: LD_INT 13
18880: PUSH
18881: LD_INT 14
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: ST_TO_ADDR
18890: GO 19467
18892: LD_INT 24
18894: DOUBLE
18895: EQUAL
18896: IFTRUE 18900
18898: GO 18926
18900: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18901: LD_ADDR_VAR 0 3
18905: PUSH
18906: LD_INT 11
18908: PUSH
18909: LD_INT 12
18911: PUSH
18912: LD_INT 13
18914: PUSH
18915: LD_INT 14
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: ST_TO_ADDR
18924: GO 19467
18926: LD_INT 30
18928: DOUBLE
18929: EQUAL
18930: IFTRUE 18934
18932: GO 18960
18934: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18935: LD_ADDR_VAR 0 3
18939: PUSH
18940: LD_INT 11
18942: PUSH
18943: LD_INT 12
18945: PUSH
18946: LD_INT 13
18948: PUSH
18949: LD_INT 14
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: ST_TO_ADDR
18958: GO 19467
18960: LD_INT 25
18962: DOUBLE
18963: EQUAL
18964: IFTRUE 18968
18966: GO 18986
18968: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18969: LD_ADDR_VAR 0 3
18973: PUSH
18974: LD_INT 13
18976: PUSH
18977: LD_INT 14
18979: PUSH
18980: EMPTY
18981: LIST
18982: LIST
18983: ST_TO_ADDR
18984: GO 19467
18986: LD_INT 27
18988: DOUBLE
18989: EQUAL
18990: IFTRUE 18994
18992: GO 19012
18994: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18995: LD_ADDR_VAR 0 3
18999: PUSH
19000: LD_INT 13
19002: PUSH
19003: LD_INT 14
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: ST_TO_ADDR
19010: GO 19467
19012: LD_INT 92
19014: DOUBLE
19015: EQUAL
19016: IFTRUE 19020
19018: GO 19046
19020: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19021: LD_ADDR_VAR 0 3
19025: PUSH
19026: LD_INT 11
19028: PUSH
19029: LD_INT 12
19031: PUSH
19032: LD_INT 13
19034: PUSH
19035: LD_INT 14
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: LIST
19043: ST_TO_ADDR
19044: GO 19467
19046: LD_INT 28
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19072
19054: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19055: LD_ADDR_VAR 0 3
19059: PUSH
19060: LD_INT 13
19062: PUSH
19063: LD_INT 14
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: ST_TO_ADDR
19070: GO 19467
19072: LD_INT 29
19074: DOUBLE
19075: EQUAL
19076: IFTRUE 19080
19078: GO 19098
19080: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_INT 13
19088: PUSH
19089: LD_INT 14
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: ST_TO_ADDR
19096: GO 19467
19098: LD_INT 31
19100: DOUBLE
19101: EQUAL
19102: IFTRUE 19106
19104: GO 19124
19106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19107: LD_ADDR_VAR 0 3
19111: PUSH
19112: LD_INT 13
19114: PUSH
19115: LD_INT 14
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: ST_TO_ADDR
19122: GO 19467
19124: LD_INT 26
19126: DOUBLE
19127: EQUAL
19128: IFTRUE 19132
19130: GO 19150
19132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19133: LD_ADDR_VAR 0 3
19137: PUSH
19138: LD_INT 13
19140: PUSH
19141: LD_INT 14
19143: PUSH
19144: EMPTY
19145: LIST
19146: LIST
19147: ST_TO_ADDR
19148: GO 19467
19150: LD_INT 42
19152: DOUBLE
19153: EQUAL
19154: IFTRUE 19158
19156: GO 19184
19158: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19159: LD_ADDR_VAR 0 3
19163: PUSH
19164: LD_INT 21
19166: PUSH
19167: LD_INT 22
19169: PUSH
19170: LD_INT 23
19172: PUSH
19173: LD_INT 24
19175: PUSH
19176: EMPTY
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: ST_TO_ADDR
19182: GO 19467
19184: LD_INT 43
19186: DOUBLE
19187: EQUAL
19188: IFTRUE 19192
19190: GO 19218
19192: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19193: LD_ADDR_VAR 0 3
19197: PUSH
19198: LD_INT 21
19200: PUSH
19201: LD_INT 22
19203: PUSH
19204: LD_INT 23
19206: PUSH
19207: LD_INT 24
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: LIST
19214: LIST
19215: ST_TO_ADDR
19216: GO 19467
19218: LD_INT 44
19220: DOUBLE
19221: EQUAL
19222: IFTRUE 19226
19224: GO 19252
19226: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19227: LD_ADDR_VAR 0 3
19231: PUSH
19232: LD_INT 21
19234: PUSH
19235: LD_INT 22
19237: PUSH
19238: LD_INT 23
19240: PUSH
19241: LD_INT 24
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 19467
19252: LD_INT 45
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19286
19260: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19261: LD_ADDR_VAR 0 3
19265: PUSH
19266: LD_INT 21
19268: PUSH
19269: LD_INT 22
19271: PUSH
19272: LD_INT 23
19274: PUSH
19275: LD_INT 24
19277: PUSH
19278: EMPTY
19279: LIST
19280: LIST
19281: LIST
19282: LIST
19283: ST_TO_ADDR
19284: GO 19467
19286: LD_INT 49
19288: DOUBLE
19289: EQUAL
19290: IFTRUE 19294
19292: GO 19320
19294: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19295: LD_ADDR_VAR 0 3
19299: PUSH
19300: LD_INT 21
19302: PUSH
19303: LD_INT 22
19305: PUSH
19306: LD_INT 23
19308: PUSH
19309: LD_INT 24
19311: PUSH
19312: EMPTY
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: ST_TO_ADDR
19318: GO 19467
19320: LD_INT 51
19322: DOUBLE
19323: EQUAL
19324: IFTRUE 19328
19326: GO 19354
19328: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19329: LD_ADDR_VAR 0 3
19333: PUSH
19334: LD_INT 21
19336: PUSH
19337: LD_INT 22
19339: PUSH
19340: LD_INT 23
19342: PUSH
19343: LD_INT 24
19345: PUSH
19346: EMPTY
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: ST_TO_ADDR
19352: GO 19467
19354: LD_INT 52
19356: DOUBLE
19357: EQUAL
19358: IFTRUE 19362
19360: GO 19388
19362: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19363: LD_ADDR_VAR 0 3
19367: PUSH
19368: LD_INT 21
19370: PUSH
19371: LD_INT 22
19373: PUSH
19374: LD_INT 23
19376: PUSH
19377: LD_INT 24
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: ST_TO_ADDR
19386: GO 19467
19388: LD_INT 53
19390: DOUBLE
19391: EQUAL
19392: IFTRUE 19396
19394: GO 19414
19396: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19397: LD_ADDR_VAR 0 3
19401: PUSH
19402: LD_INT 23
19404: PUSH
19405: LD_INT 24
19407: PUSH
19408: EMPTY
19409: LIST
19410: LIST
19411: ST_TO_ADDR
19412: GO 19467
19414: LD_INT 46
19416: DOUBLE
19417: EQUAL
19418: IFTRUE 19422
19420: GO 19440
19422: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19423: LD_ADDR_VAR 0 3
19427: PUSH
19428: LD_INT 23
19430: PUSH
19431: LD_INT 24
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: ST_TO_ADDR
19438: GO 19467
19440: LD_INT 47
19442: DOUBLE
19443: EQUAL
19444: IFTRUE 19448
19446: GO 19466
19448: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19449: LD_ADDR_VAR 0 3
19453: PUSH
19454: LD_INT 23
19456: PUSH
19457: LD_INT 24
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: ST_TO_ADDR
19464: GO 19467
19466: POP
// result := ( chassis in result ) ;
19467: LD_ADDR_VAR 0 3
19471: PUSH
19472: LD_VAR 0 1
19476: PUSH
19477: LD_VAR 0 3
19481: IN
19482: ST_TO_ADDR
// end ;
19483: LD_VAR 0 3
19487: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19488: LD_INT 0
19490: PPUSH
19491: PPUSH
19492: PPUSH
19493: PPUSH
19494: PPUSH
19495: PPUSH
19496: PPUSH
// result := array ;
19497: LD_ADDR_VAR 0 5
19501: PUSH
19502: LD_VAR 0 1
19506: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19507: LD_VAR 0 1
19511: NOT
19512: PUSH
19513: LD_VAR 0 2
19517: NOT
19518: OR
19519: PUSH
19520: LD_VAR 0 3
19524: NOT
19525: OR
19526: PUSH
19527: LD_VAR 0 2
19531: PUSH
19532: LD_VAR 0 1
19536: GREATER
19537: OR
19538: PUSH
19539: LD_VAR 0 3
19543: PUSH
19544: LD_VAR 0 1
19548: GREATER
19549: OR
19550: IFFALSE 19554
// exit ;
19552: GO 19850
// if direction then
19554: LD_VAR 0 4
19558: IFFALSE 19622
// begin d := 1 ;
19560: LD_ADDR_VAR 0 9
19564: PUSH
19565: LD_INT 1
19567: ST_TO_ADDR
// if i_from > i_to then
19568: LD_VAR 0 2
19572: PUSH
19573: LD_VAR 0 3
19577: GREATER
19578: IFFALSE 19604
// length := ( array - i_from ) + i_to else
19580: LD_ADDR_VAR 0 11
19584: PUSH
19585: LD_VAR 0 1
19589: PUSH
19590: LD_VAR 0 2
19594: MINUS
19595: PUSH
19596: LD_VAR 0 3
19600: PLUS
19601: ST_TO_ADDR
19602: GO 19620
// length := i_to - i_from ;
19604: LD_ADDR_VAR 0 11
19608: PUSH
19609: LD_VAR 0 3
19613: PUSH
19614: LD_VAR 0 2
19618: MINUS
19619: ST_TO_ADDR
// end else
19620: GO 19683
// begin d := - 1 ;
19622: LD_ADDR_VAR 0 9
19626: PUSH
19627: LD_INT 1
19629: NEG
19630: ST_TO_ADDR
// if i_from > i_to then
19631: LD_VAR 0 2
19635: PUSH
19636: LD_VAR 0 3
19640: GREATER
19641: IFFALSE 19661
// length := i_from - i_to else
19643: LD_ADDR_VAR 0 11
19647: PUSH
19648: LD_VAR 0 2
19652: PUSH
19653: LD_VAR 0 3
19657: MINUS
19658: ST_TO_ADDR
19659: GO 19683
// length := ( array - i_to ) + i_from ;
19661: LD_ADDR_VAR 0 11
19665: PUSH
19666: LD_VAR 0 1
19670: PUSH
19671: LD_VAR 0 3
19675: MINUS
19676: PUSH
19677: LD_VAR 0 2
19681: PLUS
19682: ST_TO_ADDR
// end ; if not length then
19683: LD_VAR 0 11
19687: NOT
19688: IFFALSE 19692
// exit ;
19690: GO 19850
// tmp := array ;
19692: LD_ADDR_VAR 0 10
19696: PUSH
19697: LD_VAR 0 1
19701: ST_TO_ADDR
// for i = 1 to length do
19702: LD_ADDR_VAR 0 6
19706: PUSH
19707: DOUBLE
19708: LD_INT 1
19710: DEC
19711: ST_TO_ADDR
19712: LD_VAR 0 11
19716: PUSH
19717: FOR_TO
19718: IFFALSE 19838
// begin for j = 1 to array do
19720: LD_ADDR_VAR 0 7
19724: PUSH
19725: DOUBLE
19726: LD_INT 1
19728: DEC
19729: ST_TO_ADDR
19730: LD_VAR 0 1
19734: PUSH
19735: FOR_TO
19736: IFFALSE 19824
// begin k := j + d ;
19738: LD_ADDR_VAR 0 8
19742: PUSH
19743: LD_VAR 0 7
19747: PUSH
19748: LD_VAR 0 9
19752: PLUS
19753: ST_TO_ADDR
// if k > array then
19754: LD_VAR 0 8
19758: PUSH
19759: LD_VAR 0 1
19763: GREATER
19764: IFFALSE 19774
// k := 1 ;
19766: LD_ADDR_VAR 0 8
19770: PUSH
19771: LD_INT 1
19773: ST_TO_ADDR
// if not k then
19774: LD_VAR 0 8
19778: NOT
19779: IFFALSE 19791
// k := array ;
19781: LD_ADDR_VAR 0 8
19785: PUSH
19786: LD_VAR 0 1
19790: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19791: LD_ADDR_VAR 0 10
19795: PUSH
19796: LD_VAR 0 10
19800: PPUSH
19801: LD_VAR 0 8
19805: PPUSH
19806: LD_VAR 0 1
19810: PUSH
19811: LD_VAR 0 7
19815: ARRAY
19816: PPUSH
19817: CALL_OW 1
19821: ST_TO_ADDR
// end ;
19822: GO 19735
19824: POP
19825: POP
// array := tmp ;
19826: LD_ADDR_VAR 0 1
19830: PUSH
19831: LD_VAR 0 10
19835: ST_TO_ADDR
// end ;
19836: GO 19717
19838: POP
19839: POP
// result := array ;
19840: LD_ADDR_VAR 0 5
19844: PUSH
19845: LD_VAR 0 1
19849: ST_TO_ADDR
// end ;
19850: LD_VAR 0 5
19854: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19855: LD_INT 0
19857: PPUSH
19858: PPUSH
// result := 0 ;
19859: LD_ADDR_VAR 0 3
19863: PUSH
19864: LD_INT 0
19866: ST_TO_ADDR
// if not array or not value in array then
19867: LD_VAR 0 1
19871: NOT
19872: PUSH
19873: LD_VAR 0 2
19877: PUSH
19878: LD_VAR 0 1
19882: IN
19883: NOT
19884: OR
19885: IFFALSE 19889
// exit ;
19887: GO 19943
// for i = 1 to array do
19889: LD_ADDR_VAR 0 4
19893: PUSH
19894: DOUBLE
19895: LD_INT 1
19897: DEC
19898: ST_TO_ADDR
19899: LD_VAR 0 1
19903: PUSH
19904: FOR_TO
19905: IFFALSE 19941
// if value = array [ i ] then
19907: LD_VAR 0 2
19911: PUSH
19912: LD_VAR 0 1
19916: PUSH
19917: LD_VAR 0 4
19921: ARRAY
19922: EQUAL
19923: IFFALSE 19939
// begin result := i ;
19925: LD_ADDR_VAR 0 3
19929: PUSH
19930: LD_VAR 0 4
19934: ST_TO_ADDR
// exit ;
19935: POP
19936: POP
19937: GO 19943
// end ;
19939: GO 19904
19941: POP
19942: POP
// end ;
19943: LD_VAR 0 3
19947: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19948: LD_INT 0
19950: PPUSH
// vc_chassis := chassis ;
19951: LD_ADDR_OWVAR 37
19955: PUSH
19956: LD_VAR 0 1
19960: ST_TO_ADDR
// vc_engine := engine ;
19961: LD_ADDR_OWVAR 39
19965: PUSH
19966: LD_VAR 0 2
19970: ST_TO_ADDR
// vc_control := control ;
19971: LD_ADDR_OWVAR 38
19975: PUSH
19976: LD_VAR 0 3
19980: ST_TO_ADDR
// vc_weapon := weapon ;
19981: LD_ADDR_OWVAR 40
19985: PUSH
19986: LD_VAR 0 4
19990: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19991: LD_ADDR_OWVAR 41
19995: PUSH
19996: LD_VAR 0 5
20000: ST_TO_ADDR
// end ;
20001: LD_VAR 0 6
20005: RET
// export function WantPlant ( unit ) ; var task ; begin
20006: LD_INT 0
20008: PPUSH
20009: PPUSH
// result := false ;
20010: LD_ADDR_VAR 0 2
20014: PUSH
20015: LD_INT 0
20017: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_VAR 0 1
20027: PPUSH
20028: CALL_OW 437
20032: ST_TO_ADDR
// if task then
20033: LD_VAR 0 3
20037: IFFALSE 20065
// if task [ 1 ] [ 1 ] = p then
20039: LD_VAR 0 3
20043: PUSH
20044: LD_INT 1
20046: ARRAY
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_STRING p
20054: EQUAL
20055: IFFALSE 20065
// result := true ;
20057: LD_ADDR_VAR 0 2
20061: PUSH
20062: LD_INT 1
20064: ST_TO_ADDR
// end ;
20065: LD_VAR 0 2
20069: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20070: LD_INT 0
20072: PPUSH
20073: PPUSH
20074: PPUSH
20075: PPUSH
// if pos < 1 then
20076: LD_VAR 0 2
20080: PUSH
20081: LD_INT 1
20083: LESS
20084: IFFALSE 20088
// exit ;
20086: GO 20391
// if pos = 1 then
20088: LD_VAR 0 2
20092: PUSH
20093: LD_INT 1
20095: EQUAL
20096: IFFALSE 20129
// result := Replace ( arr , pos [ 1 ] , value ) else
20098: LD_ADDR_VAR 0 4
20102: PUSH
20103: LD_VAR 0 1
20107: PPUSH
20108: LD_VAR 0 2
20112: PUSH
20113: LD_INT 1
20115: ARRAY
20116: PPUSH
20117: LD_VAR 0 3
20121: PPUSH
20122: CALL_OW 1
20126: ST_TO_ADDR
20127: GO 20391
// begin tmp := arr ;
20129: LD_ADDR_VAR 0 6
20133: PUSH
20134: LD_VAR 0 1
20138: ST_TO_ADDR
// s_arr := [ tmp ] ;
20139: LD_ADDR_VAR 0 7
20143: PUSH
20144: LD_VAR 0 6
20148: PUSH
20149: EMPTY
20150: LIST
20151: ST_TO_ADDR
// for i = 1 to pos - 1 do
20152: LD_ADDR_VAR 0 5
20156: PUSH
20157: DOUBLE
20158: LD_INT 1
20160: DEC
20161: ST_TO_ADDR
20162: LD_VAR 0 2
20166: PUSH
20167: LD_INT 1
20169: MINUS
20170: PUSH
20171: FOR_TO
20172: IFFALSE 20217
// begin tmp := tmp [ pos [ i ] ] ;
20174: LD_ADDR_VAR 0 6
20178: PUSH
20179: LD_VAR 0 6
20183: PUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_VAR 0 5
20193: ARRAY
20194: ARRAY
20195: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: LD_VAR 0 7
20205: PUSH
20206: LD_VAR 0 6
20210: PUSH
20211: EMPTY
20212: LIST
20213: ADD
20214: ST_TO_ADDR
// end ;
20215: GO 20171
20217: POP
20218: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20219: LD_ADDR_VAR 0 6
20223: PUSH
20224: LD_VAR 0 6
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_VAR 0 2
20238: ARRAY
20239: PPUSH
20240: LD_VAR 0 3
20244: PPUSH
20245: CALL_OW 1
20249: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20250: LD_ADDR_VAR 0 7
20254: PUSH
20255: LD_VAR 0 7
20259: PPUSH
20260: LD_VAR 0 7
20264: PPUSH
20265: LD_VAR 0 6
20269: PPUSH
20270: CALL_OW 1
20274: ST_TO_ADDR
// for i = s_arr downto 2 do
20275: LD_ADDR_VAR 0 5
20279: PUSH
20280: DOUBLE
20281: LD_VAR 0 7
20285: INC
20286: ST_TO_ADDR
20287: LD_INT 2
20289: PUSH
20290: FOR_DOWNTO
20291: IFFALSE 20375
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20293: LD_ADDR_VAR 0 6
20297: PUSH
20298: LD_VAR 0 7
20302: PUSH
20303: LD_VAR 0 5
20307: PUSH
20308: LD_INT 1
20310: MINUS
20311: ARRAY
20312: PPUSH
20313: LD_VAR 0 2
20317: PUSH
20318: LD_VAR 0 5
20322: PUSH
20323: LD_INT 1
20325: MINUS
20326: ARRAY
20327: PPUSH
20328: LD_VAR 0 7
20332: PUSH
20333: LD_VAR 0 5
20337: ARRAY
20338: PPUSH
20339: CALL_OW 1
20343: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20344: LD_ADDR_VAR 0 7
20348: PUSH
20349: LD_VAR 0 7
20353: PPUSH
20354: LD_VAR 0 5
20358: PUSH
20359: LD_INT 1
20361: MINUS
20362: PPUSH
20363: LD_VAR 0 6
20367: PPUSH
20368: CALL_OW 1
20372: ST_TO_ADDR
// end ;
20373: GO 20290
20375: POP
20376: POP
// result := s_arr [ 1 ] ;
20377: LD_ADDR_VAR 0 4
20381: PUSH
20382: LD_VAR 0 7
20386: PUSH
20387: LD_INT 1
20389: ARRAY
20390: ST_TO_ADDR
// end ; end ;
20391: LD_VAR 0 4
20395: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// if not list then
20400: LD_VAR 0 1
20404: NOT
20405: IFFALSE 20409
// exit ;
20407: GO 20500
// i := list [ pos1 ] ;
20409: LD_ADDR_VAR 0 5
20413: PUSH
20414: LD_VAR 0 1
20418: PUSH
20419: LD_VAR 0 2
20423: ARRAY
20424: ST_TO_ADDR
// if not i then
20425: LD_VAR 0 5
20429: NOT
20430: IFFALSE 20434
// exit ;
20432: GO 20500
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 1
20443: PPUSH
20444: LD_VAR 0 2
20448: PPUSH
20449: LD_VAR 0 1
20453: PUSH
20454: LD_VAR 0 3
20458: ARRAY
20459: PPUSH
20460: CALL_OW 1
20464: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20465: LD_ADDR_VAR 0 1
20469: PUSH
20470: LD_VAR 0 1
20474: PPUSH
20475: LD_VAR 0 3
20479: PPUSH
20480: LD_VAR 0 5
20484: PPUSH
20485: CALL_OW 1
20489: ST_TO_ADDR
// result := list ;
20490: LD_ADDR_VAR 0 4
20494: PUSH
20495: LD_VAR 0 1
20499: ST_TO_ADDR
// end ;
20500: LD_VAR 0 4
20504: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20505: LD_INT 0
20507: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20508: LD_ADDR_VAR 0 5
20512: PUSH
20513: LD_VAR 0 1
20517: PPUSH
20518: CALL_OW 250
20522: PPUSH
20523: LD_VAR 0 1
20527: PPUSH
20528: CALL_OW 251
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: LD_VAR 0 4
20547: PPUSH
20548: CALL 20558 0 5
20552: ST_TO_ADDR
// end ;
20553: LD_VAR 0 5
20557: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20558: LD_INT 0
20560: PPUSH
20561: PPUSH
20562: PPUSH
20563: PPUSH
// if not list then
20564: LD_VAR 0 3
20568: NOT
20569: IFFALSE 20573
// exit ;
20571: GO 20961
// result := [ ] ;
20573: LD_ADDR_VAR 0 6
20577: PUSH
20578: EMPTY
20579: ST_TO_ADDR
// for i in list do
20580: LD_ADDR_VAR 0 7
20584: PUSH
20585: LD_VAR 0 3
20589: PUSH
20590: FOR_IN
20591: IFFALSE 20793
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20593: LD_ADDR_VAR 0 9
20597: PUSH
20598: LD_VAR 0 7
20602: PPUSH
20603: LD_VAR 0 1
20607: PPUSH
20608: LD_VAR 0 2
20612: PPUSH
20613: CALL_OW 297
20617: ST_TO_ADDR
// if not result then
20618: LD_VAR 0 6
20622: NOT
20623: IFFALSE 20649
// result := [ [ i , tmp ] ] else
20625: LD_ADDR_VAR 0 6
20629: PUSH
20630: LD_VAR 0 7
20634: PUSH
20635: LD_VAR 0 9
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: ST_TO_ADDR
20647: GO 20791
// begin if result [ result ] [ 2 ] < tmp then
20649: LD_VAR 0 6
20653: PUSH
20654: LD_VAR 0 6
20658: ARRAY
20659: PUSH
20660: LD_INT 2
20662: ARRAY
20663: PUSH
20664: LD_VAR 0 9
20668: LESS
20669: IFFALSE 20711
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20671: LD_ADDR_VAR 0 6
20675: PUSH
20676: LD_VAR 0 6
20680: PPUSH
20681: LD_VAR 0 6
20685: PUSH
20686: LD_INT 1
20688: PLUS
20689: PPUSH
20690: LD_VAR 0 7
20694: PUSH
20695: LD_VAR 0 9
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: PPUSH
20704: CALL_OW 2
20708: ST_TO_ADDR
20709: GO 20791
// for j = 1 to result do
20711: LD_ADDR_VAR 0 8
20715: PUSH
20716: DOUBLE
20717: LD_INT 1
20719: DEC
20720: ST_TO_ADDR
20721: LD_VAR 0 6
20725: PUSH
20726: FOR_TO
20727: IFFALSE 20789
// begin if tmp < result [ j ] [ 2 ] then
20729: LD_VAR 0 9
20733: PUSH
20734: LD_VAR 0 6
20738: PUSH
20739: LD_VAR 0 8
20743: ARRAY
20744: PUSH
20745: LD_INT 2
20747: ARRAY
20748: LESS
20749: IFFALSE 20787
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20751: LD_ADDR_VAR 0 6
20755: PUSH
20756: LD_VAR 0 6
20760: PPUSH
20761: LD_VAR 0 8
20765: PPUSH
20766: LD_VAR 0 7
20770: PUSH
20771: LD_VAR 0 9
20775: PUSH
20776: EMPTY
20777: LIST
20778: LIST
20779: PPUSH
20780: CALL_OW 2
20784: ST_TO_ADDR
// break ;
20785: GO 20789
// end ; end ;
20787: GO 20726
20789: POP
20790: POP
// end ; end ;
20791: GO 20590
20793: POP
20794: POP
// if result and not asc then
20795: LD_VAR 0 6
20799: PUSH
20800: LD_VAR 0 4
20804: NOT
20805: AND
20806: IFFALSE 20881
// begin tmp := result ;
20808: LD_ADDR_VAR 0 9
20812: PUSH
20813: LD_VAR 0 6
20817: ST_TO_ADDR
// for i = tmp downto 1 do
20818: LD_ADDR_VAR 0 7
20822: PUSH
20823: DOUBLE
20824: LD_VAR 0 9
20828: INC
20829: ST_TO_ADDR
20830: LD_INT 1
20832: PUSH
20833: FOR_DOWNTO
20834: IFFALSE 20879
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20836: LD_ADDR_VAR 0 6
20840: PUSH
20841: LD_VAR 0 6
20845: PPUSH
20846: LD_VAR 0 9
20850: PUSH
20851: LD_VAR 0 7
20855: MINUS
20856: PUSH
20857: LD_INT 1
20859: PLUS
20860: PPUSH
20861: LD_VAR 0 9
20865: PUSH
20866: LD_VAR 0 7
20870: ARRAY
20871: PPUSH
20872: CALL_OW 1
20876: ST_TO_ADDR
20877: GO 20833
20879: POP
20880: POP
// end ; tmp := [ ] ;
20881: LD_ADDR_VAR 0 9
20885: PUSH
20886: EMPTY
20887: ST_TO_ADDR
// if mode then
20888: LD_VAR 0 5
20892: IFFALSE 20961
// begin for i = 1 to result do
20894: LD_ADDR_VAR 0 7
20898: PUSH
20899: DOUBLE
20900: LD_INT 1
20902: DEC
20903: ST_TO_ADDR
20904: LD_VAR 0 6
20908: PUSH
20909: FOR_TO
20910: IFFALSE 20949
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20912: LD_ADDR_VAR 0 9
20916: PUSH
20917: LD_VAR 0 9
20921: PPUSH
20922: LD_VAR 0 7
20926: PPUSH
20927: LD_VAR 0 6
20931: PUSH
20932: LD_VAR 0 7
20936: ARRAY
20937: PUSH
20938: LD_INT 1
20940: ARRAY
20941: PPUSH
20942: CALL_OW 1
20946: ST_TO_ADDR
20947: GO 20909
20949: POP
20950: POP
// result := tmp ;
20951: LD_ADDR_VAR 0 6
20955: PUSH
20956: LD_VAR 0 9
20960: ST_TO_ADDR
// end ; end ;
20961: LD_VAR 0 6
20965: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20966: LD_INT 0
20968: PPUSH
20969: PPUSH
20970: PPUSH
20971: PPUSH
20972: PPUSH
20973: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20974: LD_ADDR_VAR 0 5
20978: PUSH
20979: LD_INT 0
20981: PUSH
20982: LD_INT 0
20984: PUSH
20985: LD_INT 0
20987: PUSH
20988: EMPTY
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: ST_TO_ADDR
// if not x or not y then
20996: LD_VAR 0 2
21000: NOT
21001: PUSH
21002: LD_VAR 0 3
21006: NOT
21007: OR
21008: IFFALSE 21012
// exit ;
21010: GO 22662
// if not range then
21012: LD_VAR 0 4
21016: NOT
21017: IFFALSE 21027
// range := 10 ;
21019: LD_ADDR_VAR 0 4
21023: PUSH
21024: LD_INT 10
21026: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21027: LD_ADDR_VAR 0 8
21031: PUSH
21032: LD_INT 81
21034: PUSH
21035: LD_VAR 0 1
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: PUSH
21044: LD_INT 92
21046: PUSH
21047: LD_VAR 0 2
21051: PUSH
21052: LD_VAR 0 3
21056: PUSH
21057: LD_VAR 0 4
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: LIST
21066: LIST
21067: PUSH
21068: LD_INT 3
21070: PUSH
21071: LD_INT 21
21073: PUSH
21074: LD_INT 3
21076: PUSH
21077: EMPTY
21078: LIST
21079: LIST
21080: PUSH
21081: EMPTY
21082: LIST
21083: LIST
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: LIST
21089: PPUSH
21090: CALL_OW 69
21094: ST_TO_ADDR
// if not tmp then
21095: LD_VAR 0 8
21099: NOT
21100: IFFALSE 21104
// exit ;
21102: GO 22662
// for i in tmp do
21104: LD_ADDR_VAR 0 6
21108: PUSH
21109: LD_VAR 0 8
21113: PUSH
21114: FOR_IN
21115: IFFALSE 22637
// begin points := [ 0 , 0 , 0 ] ;
21117: LD_ADDR_VAR 0 9
21121: PUSH
21122: LD_INT 0
21124: PUSH
21125: LD_INT 0
21127: PUSH
21128: LD_INT 0
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: LIST
21135: ST_TO_ADDR
// bpoints := 1 ;
21136: LD_ADDR_VAR 0 10
21140: PUSH
21141: LD_INT 1
21143: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21144: LD_VAR 0 6
21148: PPUSH
21149: CALL_OW 247
21153: PUSH
21154: LD_INT 1
21156: DOUBLE
21157: EQUAL
21158: IFTRUE 21162
21160: GO 21740
21162: POP
// begin if GetClass ( i ) = 1 then
21163: LD_VAR 0 6
21167: PPUSH
21168: CALL_OW 257
21172: PUSH
21173: LD_INT 1
21175: EQUAL
21176: IFFALSE 21197
// points := [ 10 , 5 , 3 ] ;
21178: LD_ADDR_VAR 0 9
21182: PUSH
21183: LD_INT 10
21185: PUSH
21186: LD_INT 5
21188: PUSH
21189: LD_INT 3
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: LIST
21196: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21197: LD_VAR 0 6
21201: PPUSH
21202: CALL_OW 257
21206: PUSH
21207: LD_INT 2
21209: PUSH
21210: LD_INT 3
21212: PUSH
21213: LD_INT 4
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: LIST
21220: IN
21221: IFFALSE 21242
// points := [ 3 , 2 , 1 ] ;
21223: LD_ADDR_VAR 0 9
21227: PUSH
21228: LD_INT 3
21230: PUSH
21231: LD_INT 2
21233: PUSH
21234: LD_INT 1
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: LIST
21241: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21242: LD_VAR 0 6
21246: PPUSH
21247: CALL_OW 257
21251: PUSH
21252: LD_INT 5
21254: EQUAL
21255: IFFALSE 21276
// points := [ 130 , 5 , 2 ] ;
21257: LD_ADDR_VAR 0 9
21261: PUSH
21262: LD_INT 130
21264: PUSH
21265: LD_INT 5
21267: PUSH
21268: LD_INT 2
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: LIST
21275: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21276: LD_VAR 0 6
21280: PPUSH
21281: CALL_OW 257
21285: PUSH
21286: LD_INT 8
21288: EQUAL
21289: IFFALSE 21310
// points := [ 35 , 35 , 30 ] ;
21291: LD_ADDR_VAR 0 9
21295: PUSH
21296: LD_INT 35
21298: PUSH
21299: LD_INT 35
21301: PUSH
21302: LD_INT 30
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: LIST
21309: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21310: LD_VAR 0 6
21314: PPUSH
21315: CALL_OW 257
21319: PUSH
21320: LD_INT 9
21322: EQUAL
21323: IFFALSE 21344
// points := [ 20 , 55 , 40 ] ;
21325: LD_ADDR_VAR 0 9
21329: PUSH
21330: LD_INT 20
21332: PUSH
21333: LD_INT 55
21335: PUSH
21336: LD_INT 40
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: LIST
21343: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21344: LD_VAR 0 6
21348: PPUSH
21349: CALL_OW 257
21353: PUSH
21354: LD_INT 12
21356: PUSH
21357: LD_INT 16
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: IN
21364: IFFALSE 21385
// points := [ 5 , 3 , 2 ] ;
21366: LD_ADDR_VAR 0 9
21370: PUSH
21371: LD_INT 5
21373: PUSH
21374: LD_INT 3
21376: PUSH
21377: LD_INT 2
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: LIST
21384: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21385: LD_VAR 0 6
21389: PPUSH
21390: CALL_OW 257
21394: PUSH
21395: LD_INT 17
21397: EQUAL
21398: IFFALSE 21419
// points := [ 100 , 50 , 75 ] ;
21400: LD_ADDR_VAR 0 9
21404: PUSH
21405: LD_INT 100
21407: PUSH
21408: LD_INT 50
21410: PUSH
21411: LD_INT 75
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: LIST
21418: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21419: LD_VAR 0 6
21423: PPUSH
21424: CALL_OW 257
21428: PUSH
21429: LD_INT 15
21431: EQUAL
21432: IFFALSE 21453
// points := [ 10 , 5 , 3 ] ;
21434: LD_ADDR_VAR 0 9
21438: PUSH
21439: LD_INT 10
21441: PUSH
21442: LD_INT 5
21444: PUSH
21445: LD_INT 3
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: LIST
21452: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21453: LD_VAR 0 6
21457: PPUSH
21458: CALL_OW 257
21462: PUSH
21463: LD_INT 14
21465: EQUAL
21466: IFFALSE 21487
// points := [ 10 , 0 , 0 ] ;
21468: LD_ADDR_VAR 0 9
21472: PUSH
21473: LD_INT 10
21475: PUSH
21476: LD_INT 0
21478: PUSH
21479: LD_INT 0
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: LIST
21486: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21487: LD_VAR 0 6
21491: PPUSH
21492: CALL_OW 257
21496: PUSH
21497: LD_INT 11
21499: EQUAL
21500: IFFALSE 21521
// points := [ 30 , 10 , 5 ] ;
21502: LD_ADDR_VAR 0 9
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 10
21512: PUSH
21513: LD_INT 5
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21521: LD_VAR 0 1
21525: PPUSH
21526: LD_INT 5
21528: PPUSH
21529: CALL_OW 321
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21554
// bpoints := bpoints * 1.8 ;
21539: LD_ADDR_VAR 0 10
21543: PUSH
21544: LD_VAR 0 10
21548: PUSH
21549: LD_REAL  1.80000000000000E+0000
21552: MUL
21553: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21554: LD_VAR 0 6
21558: PPUSH
21559: CALL_OW 257
21563: PUSH
21564: LD_INT 1
21566: PUSH
21567: LD_INT 2
21569: PUSH
21570: LD_INT 3
21572: PUSH
21573: LD_INT 4
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: IN
21582: PUSH
21583: LD_VAR 0 1
21587: PPUSH
21588: LD_INT 51
21590: PPUSH
21591: CALL_OW 321
21595: PUSH
21596: LD_INT 2
21598: EQUAL
21599: AND
21600: IFFALSE 21617
// bpoints := bpoints * 1.2 ;
21602: LD_ADDR_VAR 0 10
21606: PUSH
21607: LD_VAR 0 10
21611: PUSH
21612: LD_REAL  1.20000000000000E+0000
21615: MUL
21616: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21617: LD_VAR 0 6
21621: PPUSH
21622: CALL_OW 257
21626: PUSH
21627: LD_INT 5
21629: PUSH
21630: LD_INT 7
21632: PUSH
21633: LD_INT 9
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: IN
21641: PUSH
21642: LD_VAR 0 1
21646: PPUSH
21647: LD_INT 52
21649: PPUSH
21650: CALL_OW 321
21654: PUSH
21655: LD_INT 2
21657: EQUAL
21658: AND
21659: IFFALSE 21676
// bpoints := bpoints * 1.5 ;
21661: LD_ADDR_VAR 0 10
21665: PUSH
21666: LD_VAR 0 10
21670: PUSH
21671: LD_REAL  1.50000000000000E+0000
21674: MUL
21675: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21676: LD_VAR 0 1
21680: PPUSH
21681: LD_INT 66
21683: PPUSH
21684: CALL_OW 321
21688: PUSH
21689: LD_INT 2
21691: EQUAL
21692: IFFALSE 21709
// bpoints := bpoints * 1.1 ;
21694: LD_ADDR_VAR 0 10
21698: PUSH
21699: LD_VAR 0 10
21703: PUSH
21704: LD_REAL  1.10000000000000E+0000
21707: MUL
21708: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21709: LD_ADDR_VAR 0 10
21713: PUSH
21714: LD_VAR 0 10
21718: PUSH
21719: LD_VAR 0 6
21723: PPUSH
21724: LD_INT 1
21726: PPUSH
21727: CALL_OW 259
21731: PUSH
21732: LD_REAL  1.15000000000000E+0000
21735: MUL
21736: MUL
21737: ST_TO_ADDR
// end ; unit_vehicle :
21738: GO 22566
21740: LD_INT 2
21742: DOUBLE
21743: EQUAL
21744: IFTRUE 21748
21746: GO 22554
21748: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21749: LD_VAR 0 6
21753: PPUSH
21754: CALL_OW 264
21758: PUSH
21759: LD_INT 2
21761: PUSH
21762: LD_INT 42
21764: PUSH
21765: LD_INT 24
21767: PUSH
21768: EMPTY
21769: LIST
21770: LIST
21771: LIST
21772: IN
21773: IFFALSE 21794
// points := [ 25 , 5 , 3 ] ;
21775: LD_ADDR_VAR 0 9
21779: PUSH
21780: LD_INT 25
21782: PUSH
21783: LD_INT 5
21785: PUSH
21786: LD_INT 3
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21794: LD_VAR 0 6
21798: PPUSH
21799: CALL_OW 264
21803: PUSH
21804: LD_INT 4
21806: PUSH
21807: LD_INT 43
21809: PUSH
21810: LD_INT 25
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: LIST
21817: IN
21818: IFFALSE 21839
// points := [ 40 , 15 , 5 ] ;
21820: LD_ADDR_VAR 0 9
21824: PUSH
21825: LD_INT 40
21827: PUSH
21828: LD_INT 15
21830: PUSH
21831: LD_INT 5
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: LIST
21838: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21839: LD_VAR 0 6
21843: PPUSH
21844: CALL_OW 264
21848: PUSH
21849: LD_INT 3
21851: PUSH
21852: LD_INT 23
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: IN
21859: IFFALSE 21880
// points := [ 7 , 25 , 8 ] ;
21861: LD_ADDR_VAR 0 9
21865: PUSH
21866: LD_INT 7
21868: PUSH
21869: LD_INT 25
21871: PUSH
21872: LD_INT 8
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21880: LD_VAR 0 6
21884: PPUSH
21885: CALL_OW 264
21889: PUSH
21890: LD_INT 5
21892: PUSH
21893: LD_INT 27
21895: PUSH
21896: LD_INT 44
21898: PUSH
21899: EMPTY
21900: LIST
21901: LIST
21902: LIST
21903: IN
21904: IFFALSE 21925
// points := [ 14 , 50 , 16 ] ;
21906: LD_ADDR_VAR 0 9
21910: PUSH
21911: LD_INT 14
21913: PUSH
21914: LD_INT 50
21916: PUSH
21917: LD_INT 16
21919: PUSH
21920: EMPTY
21921: LIST
21922: LIST
21923: LIST
21924: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21925: LD_VAR 0 6
21929: PPUSH
21930: CALL_OW 264
21934: PUSH
21935: LD_INT 6
21937: PUSH
21938: LD_INT 46
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: IN
21945: IFFALSE 21966
// points := [ 32 , 120 , 70 ] ;
21947: LD_ADDR_VAR 0 9
21951: PUSH
21952: LD_INT 32
21954: PUSH
21955: LD_INT 120
21957: PUSH
21958: LD_INT 70
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: LIST
21965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21966: LD_VAR 0 6
21970: PPUSH
21971: CALL_OW 264
21975: PUSH
21976: LD_INT 7
21978: PUSH
21979: LD_INT 28
21981: PUSH
21982: LD_INT 45
21984: PUSH
21985: LD_INT 92
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: IN
21994: IFFALSE 22015
// points := [ 35 , 20 , 45 ] ;
21996: LD_ADDR_VAR 0 9
22000: PUSH
22001: LD_INT 35
22003: PUSH
22004: LD_INT 20
22006: PUSH
22007: LD_INT 45
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22015: LD_VAR 0 6
22019: PPUSH
22020: CALL_OW 264
22024: PUSH
22025: LD_INT 47
22027: PUSH
22028: EMPTY
22029: LIST
22030: IN
22031: IFFALSE 22052
// points := [ 67 , 45 , 75 ] ;
22033: LD_ADDR_VAR 0 9
22037: PUSH
22038: LD_INT 67
22040: PUSH
22041: LD_INT 45
22043: PUSH
22044: LD_INT 75
22046: PUSH
22047: EMPTY
22048: LIST
22049: LIST
22050: LIST
22051: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22052: LD_VAR 0 6
22056: PPUSH
22057: CALL_OW 264
22061: PUSH
22062: LD_INT 26
22064: PUSH
22065: EMPTY
22066: LIST
22067: IN
22068: IFFALSE 22089
// points := [ 120 , 30 , 80 ] ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_INT 120
22077: PUSH
22078: LD_INT 30
22080: PUSH
22081: LD_INT 80
22083: PUSH
22084: EMPTY
22085: LIST
22086: LIST
22087: LIST
22088: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22089: LD_VAR 0 6
22093: PPUSH
22094: CALL_OW 264
22098: PUSH
22099: LD_INT 22
22101: PUSH
22102: EMPTY
22103: LIST
22104: IN
22105: IFFALSE 22126
// points := [ 40 , 1 , 1 ] ;
22107: LD_ADDR_VAR 0 9
22111: PUSH
22112: LD_INT 40
22114: PUSH
22115: LD_INT 1
22117: PUSH
22118: LD_INT 1
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: LIST
22125: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22126: LD_VAR 0 6
22130: PPUSH
22131: CALL_OW 264
22135: PUSH
22136: LD_INT 29
22138: PUSH
22139: EMPTY
22140: LIST
22141: IN
22142: IFFALSE 22163
// points := [ 70 , 200 , 400 ] ;
22144: LD_ADDR_VAR 0 9
22148: PUSH
22149: LD_INT 70
22151: PUSH
22152: LD_INT 200
22154: PUSH
22155: LD_INT 400
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: LIST
22162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22163: LD_VAR 0 6
22167: PPUSH
22168: CALL_OW 264
22172: PUSH
22173: LD_INT 14
22175: PUSH
22176: LD_INT 53
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: IN
22183: IFFALSE 22204
// points := [ 40 , 10 , 20 ] ;
22185: LD_ADDR_VAR 0 9
22189: PUSH
22190: LD_INT 40
22192: PUSH
22193: LD_INT 10
22195: PUSH
22196: LD_INT 20
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: LIST
22203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22204: LD_VAR 0 6
22208: PPUSH
22209: CALL_OW 264
22213: PUSH
22214: LD_INT 9
22216: PUSH
22217: EMPTY
22218: LIST
22219: IN
22220: IFFALSE 22241
// points := [ 5 , 70 , 20 ] ;
22222: LD_ADDR_VAR 0 9
22226: PUSH
22227: LD_INT 5
22229: PUSH
22230: LD_INT 70
22232: PUSH
22233: LD_INT 20
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: LIST
22240: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22241: LD_VAR 0 6
22245: PPUSH
22246: CALL_OW 264
22250: PUSH
22251: LD_INT 10
22253: PUSH
22254: EMPTY
22255: LIST
22256: IN
22257: IFFALSE 22278
// points := [ 35 , 110 , 70 ] ;
22259: LD_ADDR_VAR 0 9
22263: PUSH
22264: LD_INT 35
22266: PUSH
22267: LD_INT 110
22269: PUSH
22270: LD_INT 70
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: LIST
22277: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22278: LD_VAR 0 6
22282: PPUSH
22283: CALL_OW 265
22287: PUSH
22288: LD_INT 25
22290: EQUAL
22291: IFFALSE 22312
// points := [ 80 , 65 , 100 ] ;
22293: LD_ADDR_VAR 0 9
22297: PUSH
22298: LD_INT 80
22300: PUSH
22301: LD_INT 65
22303: PUSH
22304: LD_INT 100
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: LIST
22311: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22312: LD_VAR 0 6
22316: PPUSH
22317: CALL_OW 263
22321: PUSH
22322: LD_INT 1
22324: EQUAL
22325: IFFALSE 22360
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22327: LD_ADDR_VAR 0 10
22331: PUSH
22332: LD_VAR 0 10
22336: PUSH
22337: LD_VAR 0 6
22341: PPUSH
22342: CALL_OW 311
22346: PPUSH
22347: LD_INT 3
22349: PPUSH
22350: CALL_OW 259
22354: PUSH
22355: LD_INT 4
22357: MUL
22358: MUL
22359: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22360: LD_VAR 0 6
22364: PPUSH
22365: CALL_OW 263
22369: PUSH
22370: LD_INT 2
22372: EQUAL
22373: IFFALSE 22424
// begin j := IsControledBy ( i ) ;
22375: LD_ADDR_VAR 0 7
22379: PUSH
22380: LD_VAR 0 6
22384: PPUSH
22385: CALL_OW 312
22389: ST_TO_ADDR
// if j then
22390: LD_VAR 0 7
22394: IFFALSE 22424
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22396: LD_ADDR_VAR 0 10
22400: PUSH
22401: LD_VAR 0 10
22405: PUSH
22406: LD_VAR 0 7
22410: PPUSH
22411: LD_INT 3
22413: PPUSH
22414: CALL_OW 259
22418: PUSH
22419: LD_INT 3
22421: MUL
22422: MUL
22423: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22424: LD_VAR 0 6
22428: PPUSH
22429: CALL_OW 264
22433: PUSH
22434: LD_INT 5
22436: PUSH
22437: LD_INT 6
22439: PUSH
22440: LD_INT 46
22442: PUSH
22443: LD_INT 44
22445: PUSH
22446: LD_INT 47
22448: PUSH
22449: LD_INT 45
22451: PUSH
22452: LD_INT 28
22454: PUSH
22455: LD_INT 7
22457: PUSH
22458: LD_INT 27
22460: PUSH
22461: LD_INT 29
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: LIST
22470: LIST
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: IN
22476: PUSH
22477: LD_VAR 0 1
22481: PPUSH
22482: LD_INT 52
22484: PPUSH
22485: CALL_OW 321
22489: PUSH
22490: LD_INT 2
22492: EQUAL
22493: AND
22494: IFFALSE 22511
// bpoints := bpoints * 1.2 ;
22496: LD_ADDR_VAR 0 10
22500: PUSH
22501: LD_VAR 0 10
22505: PUSH
22506: LD_REAL  1.20000000000000E+0000
22509: MUL
22510: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22511: LD_VAR 0 6
22515: PPUSH
22516: CALL_OW 264
22520: PUSH
22521: LD_INT 6
22523: PUSH
22524: LD_INT 46
22526: PUSH
22527: LD_INT 47
22529: PUSH
22530: EMPTY
22531: LIST
22532: LIST
22533: LIST
22534: IN
22535: IFFALSE 22552
// bpoints := bpoints * 1.2 ;
22537: LD_ADDR_VAR 0 10
22541: PUSH
22542: LD_VAR 0 10
22546: PUSH
22547: LD_REAL  1.20000000000000E+0000
22550: MUL
22551: ST_TO_ADDR
// end ; unit_building :
22552: GO 22566
22554: LD_INT 3
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22565
22562: POP
// ; end ;
22563: GO 22566
22565: POP
// for j = 1 to 3 do
22566: LD_ADDR_VAR 0 7
22570: PUSH
22571: DOUBLE
22572: LD_INT 1
22574: DEC
22575: ST_TO_ADDR
22576: LD_INT 3
22578: PUSH
22579: FOR_TO
22580: IFFALSE 22633
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_VAR 0 5
22591: PPUSH
22592: LD_VAR 0 7
22596: PPUSH
22597: LD_VAR 0 5
22601: PUSH
22602: LD_VAR 0 7
22606: ARRAY
22607: PUSH
22608: LD_VAR 0 9
22612: PUSH
22613: LD_VAR 0 7
22617: ARRAY
22618: PUSH
22619: LD_VAR 0 10
22623: MUL
22624: PLUS
22625: PPUSH
22626: CALL_OW 1
22630: ST_TO_ADDR
22631: GO 22579
22633: POP
22634: POP
// end ;
22635: GO 21114
22637: POP
22638: POP
// result := Replace ( result , 4 , tmp ) ;
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_VAR 0 5
22648: PPUSH
22649: LD_INT 4
22651: PPUSH
22652: LD_VAR 0 8
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// end ;
22662: LD_VAR 0 5
22666: RET
// export function DangerAtRange ( unit , range ) ; begin
22667: LD_INT 0
22669: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22670: LD_ADDR_VAR 0 3
22674: PUSH
22675: LD_VAR 0 1
22679: PPUSH
22680: CALL_OW 255
22684: PPUSH
22685: LD_VAR 0 1
22689: PPUSH
22690: CALL_OW 250
22694: PPUSH
22695: LD_VAR 0 1
22699: PPUSH
22700: CALL_OW 251
22704: PPUSH
22705: LD_VAR 0 2
22709: PPUSH
22710: CALL 20966 0 4
22714: ST_TO_ADDR
// end ;
22715: LD_VAR 0 3
22719: RET
// export function DangerInArea ( side , area ) ; begin
22720: LD_INT 0
22722: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_VAR 0 2
22732: PPUSH
22733: LD_INT 81
22735: PUSH
22736: LD_VAR 0 1
22740: PUSH
22741: EMPTY
22742: LIST
22743: LIST
22744: PPUSH
22745: CALL_OW 70
22749: ST_TO_ADDR
// end ;
22750: LD_VAR 0 3
22754: RET
// export function IsExtension ( b ) ; begin
22755: LD_INT 0
22757: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22758: LD_ADDR_VAR 0 2
22762: PUSH
22763: LD_VAR 0 1
22767: PUSH
22768: LD_INT 23
22770: PUSH
22771: LD_INT 20
22773: PUSH
22774: LD_INT 22
22776: PUSH
22777: LD_INT 17
22779: PUSH
22780: LD_INT 24
22782: PUSH
22783: LD_INT 21
22785: PUSH
22786: LD_INT 19
22788: PUSH
22789: LD_INT 16
22791: PUSH
22792: LD_INT 25
22794: PUSH
22795: LD_INT 18
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: LIST
22808: LIST
22809: IN
22810: ST_TO_ADDR
// end ;
22811: LD_VAR 0 2
22815: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22816: LD_INT 0
22818: PPUSH
22819: PPUSH
22820: PPUSH
// result := [ ] ;
22821: LD_ADDR_VAR 0 4
22825: PUSH
22826: EMPTY
22827: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22828: LD_ADDR_VAR 0 5
22832: PUSH
22833: LD_VAR 0 2
22837: PPUSH
22838: LD_INT 21
22840: PUSH
22841: LD_INT 3
22843: PUSH
22844: EMPTY
22845: LIST
22846: LIST
22847: PPUSH
22848: CALL_OW 70
22852: ST_TO_ADDR
// if not tmp then
22853: LD_VAR 0 5
22857: NOT
22858: IFFALSE 22862
// exit ;
22860: GO 22926
// if checkLink then
22862: LD_VAR 0 3
22866: IFFALSE 22916
// begin for i in tmp do
22868: LD_ADDR_VAR 0 6
22872: PUSH
22873: LD_VAR 0 5
22877: PUSH
22878: FOR_IN
22879: IFFALSE 22914
// if GetBase ( i ) <> base then
22881: LD_VAR 0 6
22885: PPUSH
22886: CALL_OW 274
22890: PUSH
22891: LD_VAR 0 1
22895: NONEQUAL
22896: IFFALSE 22912
// ComLinkToBase ( base , i ) ;
22898: LD_VAR 0 1
22902: PPUSH
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 169
22912: GO 22878
22914: POP
22915: POP
// end ; result := tmp ;
22916: LD_ADDR_VAR 0 4
22920: PUSH
22921: LD_VAR 0 5
22925: ST_TO_ADDR
// end ;
22926: LD_VAR 0 4
22930: RET
// export function ComComplete ( units , b ) ; var i ; begin
22931: LD_INT 0
22933: PPUSH
22934: PPUSH
// if not units then
22935: LD_VAR 0 1
22939: NOT
22940: IFFALSE 22944
// exit ;
22942: GO 23034
// for i in units do
22944: LD_ADDR_VAR 0 4
22948: PUSH
22949: LD_VAR 0 1
22953: PUSH
22954: FOR_IN
22955: IFFALSE 23032
// if BuildingStatus ( b ) = bs_build then
22957: LD_VAR 0 2
22961: PPUSH
22962: CALL_OW 461
22966: PUSH
22967: LD_INT 1
22969: EQUAL
22970: IFFALSE 23030
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22972: LD_VAR 0 4
22976: PPUSH
22977: LD_STRING h
22979: PUSH
22980: LD_VAR 0 2
22984: PPUSH
22985: CALL_OW 250
22989: PUSH
22990: LD_VAR 0 2
22994: PPUSH
22995: CALL_OW 251
22999: PUSH
23000: LD_VAR 0 2
23004: PUSH
23005: LD_INT 0
23007: PUSH
23008: LD_INT 0
23010: PUSH
23011: LD_INT 0
23013: PUSH
23014: EMPTY
23015: LIST
23016: LIST
23017: LIST
23018: LIST
23019: LIST
23020: LIST
23021: LIST
23022: PUSH
23023: EMPTY
23024: LIST
23025: PPUSH
23026: CALL_OW 446
23030: GO 22954
23032: POP
23033: POP
// end ;
23034: LD_VAR 0 3
23038: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23039: LD_INT 0
23041: PPUSH
23042: PPUSH
23043: PPUSH
23044: PPUSH
23045: PPUSH
23046: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23047: LD_VAR 0 1
23051: NOT
23052: PUSH
23053: LD_VAR 0 1
23057: PPUSH
23058: CALL_OW 263
23062: PUSH
23063: LD_INT 2
23065: NONEQUAL
23066: OR
23067: IFFALSE 23071
// exit ;
23069: GO 23387
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23071: LD_ADDR_VAR 0 6
23075: PUSH
23076: LD_INT 22
23078: PUSH
23079: LD_VAR 0 1
23083: PPUSH
23084: CALL_OW 255
23088: PUSH
23089: EMPTY
23090: LIST
23091: LIST
23092: PUSH
23093: LD_INT 2
23095: PUSH
23096: LD_INT 30
23098: PUSH
23099: LD_INT 36
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: PUSH
23106: LD_INT 34
23108: PUSH
23109: LD_INT 31
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: LIST
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: PPUSH
23125: CALL_OW 69
23129: ST_TO_ADDR
// if not tmp then
23130: LD_VAR 0 6
23134: NOT
23135: IFFALSE 23139
// exit ;
23137: GO 23387
// result := [ ] ;
23139: LD_ADDR_VAR 0 2
23143: PUSH
23144: EMPTY
23145: ST_TO_ADDR
// for i in tmp do
23146: LD_ADDR_VAR 0 3
23150: PUSH
23151: LD_VAR 0 6
23155: PUSH
23156: FOR_IN
23157: IFFALSE 23228
// begin t := UnitsInside ( i ) ;
23159: LD_ADDR_VAR 0 4
23163: PUSH
23164: LD_VAR 0 3
23168: PPUSH
23169: CALL_OW 313
23173: ST_TO_ADDR
// if t then
23174: LD_VAR 0 4
23178: IFFALSE 23226
// for j in t do
23180: LD_ADDR_VAR 0 7
23184: PUSH
23185: LD_VAR 0 4
23189: PUSH
23190: FOR_IN
23191: IFFALSE 23224
// result := Replace ( result , result + 1 , j ) ;
23193: LD_ADDR_VAR 0 2
23197: PUSH
23198: LD_VAR 0 2
23202: PPUSH
23203: LD_VAR 0 2
23207: PUSH
23208: LD_INT 1
23210: PLUS
23211: PPUSH
23212: LD_VAR 0 7
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
23222: GO 23190
23224: POP
23225: POP
// end ;
23226: GO 23156
23228: POP
23229: POP
// if not result then
23230: LD_VAR 0 2
23234: NOT
23235: IFFALSE 23239
// exit ;
23237: GO 23387
// mech := result [ 1 ] ;
23239: LD_ADDR_VAR 0 5
23243: PUSH
23244: LD_VAR 0 2
23248: PUSH
23249: LD_INT 1
23251: ARRAY
23252: ST_TO_ADDR
// if result > 1 then
23253: LD_VAR 0 2
23257: PUSH
23258: LD_INT 1
23260: GREATER
23261: IFFALSE 23373
// begin for i = 2 to result do
23263: LD_ADDR_VAR 0 3
23267: PUSH
23268: DOUBLE
23269: LD_INT 2
23271: DEC
23272: ST_TO_ADDR
23273: LD_VAR 0 2
23277: PUSH
23278: FOR_TO
23279: IFFALSE 23371
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23281: LD_ADDR_VAR 0 4
23285: PUSH
23286: LD_VAR 0 2
23290: PUSH
23291: LD_VAR 0 3
23295: ARRAY
23296: PPUSH
23297: LD_INT 3
23299: PPUSH
23300: CALL_OW 259
23304: PUSH
23305: LD_VAR 0 2
23309: PUSH
23310: LD_VAR 0 3
23314: ARRAY
23315: PPUSH
23316: CALL_OW 432
23320: MINUS
23321: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23322: LD_VAR 0 4
23326: PUSH
23327: LD_VAR 0 5
23331: PPUSH
23332: LD_INT 3
23334: PPUSH
23335: CALL_OW 259
23339: PUSH
23340: LD_VAR 0 5
23344: PPUSH
23345: CALL_OW 432
23349: MINUS
23350: GREATEREQUAL
23351: IFFALSE 23369
// mech := result [ i ] ;
23353: LD_ADDR_VAR 0 5
23357: PUSH
23358: LD_VAR 0 2
23362: PUSH
23363: LD_VAR 0 3
23367: ARRAY
23368: ST_TO_ADDR
// end ;
23369: GO 23278
23371: POP
23372: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23373: LD_VAR 0 1
23377: PPUSH
23378: LD_VAR 0 5
23382: PPUSH
23383: CALL_OW 135
// end ;
23387: LD_VAR 0 2
23391: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23392: LD_INT 0
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
23404: PPUSH
23405: PPUSH
23406: PPUSH
// result := [ ] ;
23407: LD_ADDR_VAR 0 7
23411: PUSH
23412: EMPTY
23413: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23414: LD_VAR 0 1
23418: PPUSH
23419: CALL_OW 266
23423: PUSH
23424: LD_INT 0
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: IN
23434: NOT
23435: IFFALSE 23439
// exit ;
23437: GO 25073
// if name then
23439: LD_VAR 0 3
23443: IFFALSE 23459
// SetBName ( base_dep , name ) ;
23445: LD_VAR 0 1
23449: PPUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: CALL_OW 500
// base := GetBase ( base_dep ) ;
23459: LD_ADDR_VAR 0 15
23463: PUSH
23464: LD_VAR 0 1
23468: PPUSH
23469: CALL_OW 274
23473: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23474: LD_ADDR_VAR 0 16
23478: PUSH
23479: LD_VAR 0 1
23483: PPUSH
23484: CALL_OW 255
23488: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23489: LD_ADDR_VAR 0 17
23493: PUSH
23494: LD_VAR 0 1
23498: PPUSH
23499: CALL_OW 248
23503: ST_TO_ADDR
// if sources then
23504: LD_VAR 0 5
23508: IFFALSE 23555
// for i = 1 to 3 do
23510: LD_ADDR_VAR 0 8
23514: PUSH
23515: DOUBLE
23516: LD_INT 1
23518: DEC
23519: ST_TO_ADDR
23520: LD_INT 3
23522: PUSH
23523: FOR_TO
23524: IFFALSE 23553
// AddResourceType ( base , i , sources [ i ] ) ;
23526: LD_VAR 0 15
23530: PPUSH
23531: LD_VAR 0 8
23535: PPUSH
23536: LD_VAR 0 5
23540: PUSH
23541: LD_VAR 0 8
23545: ARRAY
23546: PPUSH
23547: CALL_OW 276
23551: GO 23523
23553: POP
23554: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23555: LD_ADDR_VAR 0 18
23559: PUSH
23560: LD_VAR 0 15
23564: PPUSH
23565: LD_VAR 0 2
23569: PPUSH
23570: LD_INT 1
23572: PPUSH
23573: CALL 22816 0 3
23577: ST_TO_ADDR
// InitHc ;
23578: CALL_OW 19
// InitUc ;
23582: CALL_OW 18
// uc_side := side ;
23586: LD_ADDR_OWVAR 20
23590: PUSH
23591: LD_VAR 0 16
23595: ST_TO_ADDR
// uc_nation := nation ;
23596: LD_ADDR_OWVAR 21
23600: PUSH
23601: LD_VAR 0 17
23605: ST_TO_ADDR
// if buildings then
23606: LD_VAR 0 18
23610: IFFALSE 24932
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23612: LD_ADDR_VAR 0 19
23616: PUSH
23617: LD_VAR 0 18
23621: PPUSH
23622: LD_INT 2
23624: PUSH
23625: LD_INT 30
23627: PUSH
23628: LD_INT 29
23630: PUSH
23631: EMPTY
23632: LIST
23633: LIST
23634: PUSH
23635: LD_INT 30
23637: PUSH
23638: LD_INT 30
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: LIST
23649: PPUSH
23650: CALL_OW 72
23654: ST_TO_ADDR
// if tmp then
23655: LD_VAR 0 19
23659: IFFALSE 23707
// for i in tmp do
23661: LD_ADDR_VAR 0 8
23665: PUSH
23666: LD_VAR 0 19
23670: PUSH
23671: FOR_IN
23672: IFFALSE 23705
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23674: LD_VAR 0 8
23678: PPUSH
23679: CALL_OW 250
23683: PPUSH
23684: LD_VAR 0 8
23688: PPUSH
23689: CALL_OW 251
23693: PPUSH
23694: LD_VAR 0 16
23698: PPUSH
23699: CALL_OW 441
23703: GO 23671
23705: POP
23706: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23707: LD_VAR 0 18
23711: PPUSH
23712: LD_INT 2
23714: PUSH
23715: LD_INT 30
23717: PUSH
23718: LD_INT 32
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: LD_INT 30
23727: PUSH
23728: LD_INT 33
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: IFFALSE 23832
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23746: LD_ADDR_VAR 0 8
23750: PUSH
23751: LD_VAR 0 18
23755: PPUSH
23756: LD_INT 2
23758: PUSH
23759: LD_INT 30
23761: PUSH
23762: LD_INT 32
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 30
23771: PUSH
23772: LD_INT 33
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: PPUSH
23784: CALL_OW 72
23788: PUSH
23789: FOR_IN
23790: IFFALSE 23830
// begin if not GetBWeapon ( i ) then
23792: LD_VAR 0 8
23796: PPUSH
23797: CALL_OW 269
23801: NOT
23802: IFFALSE 23828
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23804: LD_VAR 0 8
23808: PPUSH
23809: LD_VAR 0 8
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: CALL 25078 0 2
23823: PPUSH
23824: CALL_OW 431
// end ;
23828: GO 23789
23830: POP
23831: POP
// end ; for i = 1 to personel do
23832: LD_ADDR_VAR 0 8
23836: PUSH
23837: DOUBLE
23838: LD_INT 1
23840: DEC
23841: ST_TO_ADDR
23842: LD_VAR 0 6
23846: PUSH
23847: FOR_TO
23848: IFFALSE 24912
// begin if i > 4 then
23850: LD_VAR 0 8
23854: PUSH
23855: LD_INT 4
23857: GREATER
23858: IFFALSE 23862
// break ;
23860: GO 24912
// case i of 1 :
23862: LD_VAR 0 8
23866: PUSH
23867: LD_INT 1
23869: DOUBLE
23870: EQUAL
23871: IFTRUE 23875
23873: GO 23955
23875: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23876: LD_ADDR_VAR 0 12
23880: PUSH
23881: LD_VAR 0 18
23885: PPUSH
23886: LD_INT 22
23888: PUSH
23889: LD_VAR 0 16
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: LD_INT 58
23900: PUSH
23901: EMPTY
23902: LIST
23903: PUSH
23904: LD_INT 2
23906: PUSH
23907: LD_INT 30
23909: PUSH
23910: LD_INT 32
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 30
23919: PUSH
23920: LD_INT 4
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 30
23929: PUSH
23930: LD_INT 5
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: LIST
23947: PPUSH
23948: CALL_OW 72
23952: ST_TO_ADDR
23953: GO 24177
23955: LD_INT 2
23957: DOUBLE
23958: EQUAL
23959: IFTRUE 23963
23961: GO 24025
23963: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23964: LD_ADDR_VAR 0 12
23968: PUSH
23969: LD_VAR 0 18
23973: PPUSH
23974: LD_INT 22
23976: PUSH
23977: LD_VAR 0 16
23981: PUSH
23982: EMPTY
23983: LIST
23984: LIST
23985: PUSH
23986: LD_INT 2
23988: PUSH
23989: LD_INT 30
23991: PUSH
23992: LD_INT 0
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 30
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: LIST
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: PPUSH
24018: CALL_OW 72
24022: ST_TO_ADDR
24023: GO 24177
24025: LD_INT 3
24027: DOUBLE
24028: EQUAL
24029: IFTRUE 24033
24031: GO 24095
24033: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24034: LD_ADDR_VAR 0 12
24038: PUSH
24039: LD_VAR 0 18
24043: PPUSH
24044: LD_INT 22
24046: PUSH
24047: LD_VAR 0 16
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: PUSH
24056: LD_INT 2
24058: PUSH
24059: LD_INT 30
24061: PUSH
24062: LD_INT 2
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 3
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: LIST
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PPUSH
24088: CALL_OW 72
24092: ST_TO_ADDR
24093: GO 24177
24095: LD_INT 4
24097: DOUBLE
24098: EQUAL
24099: IFTRUE 24103
24101: GO 24176
24103: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24104: LD_ADDR_VAR 0 12
24108: PUSH
24109: LD_VAR 0 18
24113: PPUSH
24114: LD_INT 22
24116: PUSH
24117: LD_VAR 0 16
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: LD_INT 2
24128: PUSH
24129: LD_INT 30
24131: PUSH
24132: LD_INT 6
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: LD_INT 30
24141: PUSH
24142: LD_INT 7
24144: PUSH
24145: EMPTY
24146: LIST
24147: LIST
24148: PUSH
24149: LD_INT 30
24151: PUSH
24152: LD_INT 8
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PPUSH
24169: CALL_OW 72
24173: ST_TO_ADDR
24174: GO 24177
24176: POP
// if i = 1 then
24177: LD_VAR 0 8
24181: PUSH
24182: LD_INT 1
24184: EQUAL
24185: IFFALSE 24296
// begin tmp := [ ] ;
24187: LD_ADDR_VAR 0 19
24191: PUSH
24192: EMPTY
24193: ST_TO_ADDR
// for j in f do
24194: LD_ADDR_VAR 0 9
24198: PUSH
24199: LD_VAR 0 12
24203: PUSH
24204: FOR_IN
24205: IFFALSE 24278
// if GetBType ( j ) = b_bunker then
24207: LD_VAR 0 9
24211: PPUSH
24212: CALL_OW 266
24216: PUSH
24217: LD_INT 32
24219: EQUAL
24220: IFFALSE 24247
// tmp := Insert ( tmp , 1 , j ) else
24222: LD_ADDR_VAR 0 19
24226: PUSH
24227: LD_VAR 0 19
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: LD_VAR 0 9
24239: PPUSH
24240: CALL_OW 2
24244: ST_TO_ADDR
24245: GO 24276
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24247: LD_ADDR_VAR 0 19
24251: PUSH
24252: LD_VAR 0 19
24256: PPUSH
24257: LD_VAR 0 19
24261: PUSH
24262: LD_INT 1
24264: PLUS
24265: PPUSH
24266: LD_VAR 0 9
24270: PPUSH
24271: CALL_OW 2
24275: ST_TO_ADDR
24276: GO 24204
24278: POP
24279: POP
// if tmp then
24280: LD_VAR 0 19
24284: IFFALSE 24296
// f := tmp ;
24286: LD_ADDR_VAR 0 12
24290: PUSH
24291: LD_VAR 0 19
24295: ST_TO_ADDR
// end ; x := personel [ i ] ;
24296: LD_ADDR_VAR 0 13
24300: PUSH
24301: LD_VAR 0 6
24305: PUSH
24306: LD_VAR 0 8
24310: ARRAY
24311: ST_TO_ADDR
// if x = - 1 then
24312: LD_VAR 0 13
24316: PUSH
24317: LD_INT 1
24319: NEG
24320: EQUAL
24321: IFFALSE 24530
// begin for j in f do
24323: LD_ADDR_VAR 0 9
24327: PUSH
24328: LD_VAR 0 12
24332: PUSH
24333: FOR_IN
24334: IFFALSE 24526
// repeat InitHc ;
24336: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24340: LD_VAR 0 9
24344: PPUSH
24345: CALL_OW 266
24349: PUSH
24350: LD_INT 5
24352: EQUAL
24353: IFFALSE 24423
// begin if UnitsInside ( j ) < 3 then
24355: LD_VAR 0 9
24359: PPUSH
24360: CALL_OW 313
24364: PUSH
24365: LD_INT 3
24367: LESS
24368: IFFALSE 24404
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24370: LD_INT 0
24372: PPUSH
24373: LD_INT 5
24375: PUSH
24376: LD_INT 8
24378: PUSH
24379: LD_INT 9
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: LIST
24386: PUSH
24387: LD_VAR 0 17
24391: ARRAY
24392: PPUSH
24393: LD_VAR 0 4
24397: PPUSH
24398: CALL_OW 380
24402: GO 24421
// PrepareHuman ( false , i , skill ) ;
24404: LD_INT 0
24406: PPUSH
24407: LD_VAR 0 8
24411: PPUSH
24412: LD_VAR 0 4
24416: PPUSH
24417: CALL_OW 380
// end else
24421: GO 24440
// PrepareHuman ( false , i , skill ) ;
24423: LD_INT 0
24425: PPUSH
24426: LD_VAR 0 8
24430: PPUSH
24431: LD_VAR 0 4
24435: PPUSH
24436: CALL_OW 380
// un := CreateHuman ;
24440: LD_ADDR_VAR 0 14
24444: PUSH
24445: CALL_OW 44
24449: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24450: LD_ADDR_VAR 0 7
24454: PUSH
24455: LD_VAR 0 7
24459: PPUSH
24460: LD_INT 1
24462: PPUSH
24463: LD_VAR 0 14
24467: PPUSH
24468: CALL_OW 2
24472: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24473: LD_VAR 0 14
24477: PPUSH
24478: LD_VAR 0 9
24482: PPUSH
24483: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24487: LD_VAR 0 9
24491: PPUSH
24492: CALL_OW 313
24496: PUSH
24497: LD_INT 6
24499: EQUAL
24500: PUSH
24501: LD_VAR 0 9
24505: PPUSH
24506: CALL_OW 266
24510: PUSH
24511: LD_INT 32
24513: PUSH
24514: LD_INT 31
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: IN
24521: OR
24522: IFFALSE 24336
24524: GO 24333
24526: POP
24527: POP
// end else
24528: GO 24910
// for j = 1 to x do
24530: LD_ADDR_VAR 0 9
24534: PUSH
24535: DOUBLE
24536: LD_INT 1
24538: DEC
24539: ST_TO_ADDR
24540: LD_VAR 0 13
24544: PUSH
24545: FOR_TO
24546: IFFALSE 24908
// begin InitHc ;
24548: CALL_OW 19
// if not f then
24552: LD_VAR 0 12
24556: NOT
24557: IFFALSE 24646
// begin PrepareHuman ( false , i , skill ) ;
24559: LD_INT 0
24561: PPUSH
24562: LD_VAR 0 8
24566: PPUSH
24567: LD_VAR 0 4
24571: PPUSH
24572: CALL_OW 380
// un := CreateHuman ;
24576: LD_ADDR_VAR 0 14
24580: PUSH
24581: CALL_OW 44
24585: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24586: LD_ADDR_VAR 0 7
24590: PUSH
24591: LD_VAR 0 7
24595: PPUSH
24596: LD_INT 1
24598: PPUSH
24599: LD_VAR 0 14
24603: PPUSH
24604: CALL_OW 2
24608: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24609: LD_VAR 0 14
24613: PPUSH
24614: LD_VAR 0 1
24618: PPUSH
24619: CALL_OW 250
24623: PPUSH
24624: LD_VAR 0 1
24628: PPUSH
24629: CALL_OW 251
24633: PPUSH
24634: LD_INT 10
24636: PPUSH
24637: LD_INT 0
24639: PPUSH
24640: CALL_OW 50
// continue ;
24644: GO 24545
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24646: LD_VAR 0 12
24650: PUSH
24651: LD_INT 1
24653: ARRAY
24654: PPUSH
24655: CALL_OW 313
24659: PUSH
24660: LD_VAR 0 12
24664: PUSH
24665: LD_INT 1
24667: ARRAY
24668: PPUSH
24669: CALL_OW 266
24673: PUSH
24674: LD_INT 32
24676: PUSH
24677: LD_INT 31
24679: PUSH
24680: EMPTY
24681: LIST
24682: LIST
24683: IN
24684: AND
24685: PUSH
24686: LD_VAR 0 12
24690: PUSH
24691: LD_INT 1
24693: ARRAY
24694: PPUSH
24695: CALL_OW 313
24699: PUSH
24700: LD_INT 6
24702: EQUAL
24703: OR
24704: IFFALSE 24724
// f := Delete ( f , 1 ) ;
24706: LD_ADDR_VAR 0 12
24710: PUSH
24711: LD_VAR 0 12
24715: PPUSH
24716: LD_INT 1
24718: PPUSH
24719: CALL_OW 3
24723: ST_TO_ADDR
// if not f then
24724: LD_VAR 0 12
24728: NOT
24729: IFFALSE 24747
// begin x := x + 2 ;
24731: LD_ADDR_VAR 0 13
24735: PUSH
24736: LD_VAR 0 13
24740: PUSH
24741: LD_INT 2
24743: PLUS
24744: ST_TO_ADDR
// continue ;
24745: GO 24545
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24747: LD_VAR 0 12
24751: PUSH
24752: LD_INT 1
24754: ARRAY
24755: PPUSH
24756: CALL_OW 266
24760: PUSH
24761: LD_INT 5
24763: EQUAL
24764: IFFALSE 24838
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24766: LD_VAR 0 12
24770: PUSH
24771: LD_INT 1
24773: ARRAY
24774: PPUSH
24775: CALL_OW 313
24779: PUSH
24780: LD_INT 3
24782: LESS
24783: IFFALSE 24819
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24785: LD_INT 0
24787: PPUSH
24788: LD_INT 5
24790: PUSH
24791: LD_INT 8
24793: PUSH
24794: LD_INT 9
24796: PUSH
24797: EMPTY
24798: LIST
24799: LIST
24800: LIST
24801: PUSH
24802: LD_VAR 0 17
24806: ARRAY
24807: PPUSH
24808: LD_VAR 0 4
24812: PPUSH
24813: CALL_OW 380
24817: GO 24836
// PrepareHuman ( false , i , skill ) ;
24819: LD_INT 0
24821: PPUSH
24822: LD_VAR 0 8
24826: PPUSH
24827: LD_VAR 0 4
24831: PPUSH
24832: CALL_OW 380
// end else
24836: GO 24855
// PrepareHuman ( false , i , skill ) ;
24838: LD_INT 0
24840: PPUSH
24841: LD_VAR 0 8
24845: PPUSH
24846: LD_VAR 0 4
24850: PPUSH
24851: CALL_OW 380
// un := CreateHuman ;
24855: LD_ADDR_VAR 0 14
24859: PUSH
24860: CALL_OW 44
24864: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24865: LD_ADDR_VAR 0 7
24869: PUSH
24870: LD_VAR 0 7
24874: PPUSH
24875: LD_INT 1
24877: PPUSH
24878: LD_VAR 0 14
24882: PPUSH
24883: CALL_OW 2
24887: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24888: LD_VAR 0 14
24892: PPUSH
24893: LD_VAR 0 12
24897: PUSH
24898: LD_INT 1
24900: ARRAY
24901: PPUSH
24902: CALL_OW 52
// end ;
24906: GO 24545
24908: POP
24909: POP
// end ;
24910: GO 23847
24912: POP
24913: POP
// result := result ^ buildings ;
24914: LD_ADDR_VAR 0 7
24918: PUSH
24919: LD_VAR 0 7
24923: PUSH
24924: LD_VAR 0 18
24928: ADD
24929: ST_TO_ADDR
// end else
24930: GO 25073
// begin for i = 1 to personel do
24932: LD_ADDR_VAR 0 8
24936: PUSH
24937: DOUBLE
24938: LD_INT 1
24940: DEC
24941: ST_TO_ADDR
24942: LD_VAR 0 6
24946: PUSH
24947: FOR_TO
24948: IFFALSE 25071
// begin if i > 4 then
24950: LD_VAR 0 8
24954: PUSH
24955: LD_INT 4
24957: GREATER
24958: IFFALSE 24962
// break ;
24960: GO 25071
// x := personel [ i ] ;
24962: LD_ADDR_VAR 0 13
24966: PUSH
24967: LD_VAR 0 6
24971: PUSH
24972: LD_VAR 0 8
24976: ARRAY
24977: ST_TO_ADDR
// if x = - 1 then
24978: LD_VAR 0 13
24982: PUSH
24983: LD_INT 1
24985: NEG
24986: EQUAL
24987: IFFALSE 24991
// continue ;
24989: GO 24947
// PrepareHuman ( false , i , skill ) ;
24991: LD_INT 0
24993: PPUSH
24994: LD_VAR 0 8
24998: PPUSH
24999: LD_VAR 0 4
25003: PPUSH
25004: CALL_OW 380
// un := CreateHuman ;
25008: LD_ADDR_VAR 0 14
25012: PUSH
25013: CALL_OW 44
25017: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25018: LD_VAR 0 14
25022: PPUSH
25023: LD_VAR 0 1
25027: PPUSH
25028: CALL_OW 250
25032: PPUSH
25033: LD_VAR 0 1
25037: PPUSH
25038: CALL_OW 251
25042: PPUSH
25043: LD_INT 10
25045: PPUSH
25046: LD_INT 0
25048: PPUSH
25049: CALL_OW 50
// result := result ^ un ;
25053: LD_ADDR_VAR 0 7
25057: PUSH
25058: LD_VAR 0 7
25062: PUSH
25063: LD_VAR 0 14
25067: ADD
25068: ST_TO_ADDR
// end ;
25069: GO 24947
25071: POP
25072: POP
// end ; end ;
25073: LD_VAR 0 7
25077: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25078: LD_INT 0
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
25092: PPUSH
25093: PPUSH
25094: PPUSH
25095: PPUSH
// result := false ;
25096: LD_ADDR_VAR 0 3
25100: PUSH
25101: LD_INT 0
25103: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25104: LD_VAR 0 1
25108: NOT
25109: PUSH
25110: LD_VAR 0 1
25114: PPUSH
25115: CALL_OW 266
25119: PUSH
25120: LD_INT 32
25122: PUSH
25123: LD_INT 33
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: IN
25130: NOT
25131: OR
25132: IFFALSE 25136
// exit ;
25134: GO 26245
// nat := GetNation ( tower ) ;
25136: LD_ADDR_VAR 0 12
25140: PUSH
25141: LD_VAR 0 1
25145: PPUSH
25146: CALL_OW 248
25150: ST_TO_ADDR
// side := GetSide ( tower ) ;
25151: LD_ADDR_VAR 0 16
25155: PUSH
25156: LD_VAR 0 1
25160: PPUSH
25161: CALL_OW 255
25165: ST_TO_ADDR
// x := GetX ( tower ) ;
25166: LD_ADDR_VAR 0 10
25170: PUSH
25171: LD_VAR 0 1
25175: PPUSH
25176: CALL_OW 250
25180: ST_TO_ADDR
// y := GetY ( tower ) ;
25181: LD_ADDR_VAR 0 11
25185: PUSH
25186: LD_VAR 0 1
25190: PPUSH
25191: CALL_OW 251
25195: ST_TO_ADDR
// if not x or not y then
25196: LD_VAR 0 10
25200: NOT
25201: PUSH
25202: LD_VAR 0 11
25206: NOT
25207: OR
25208: IFFALSE 25212
// exit ;
25210: GO 26245
// weapon := 0 ;
25212: LD_ADDR_VAR 0 18
25216: PUSH
25217: LD_INT 0
25219: ST_TO_ADDR
// fac_list := [ ] ;
25220: LD_ADDR_VAR 0 17
25224: PUSH
25225: EMPTY
25226: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25227: LD_ADDR_VAR 0 6
25231: PUSH
25232: LD_VAR 0 1
25236: PPUSH
25237: CALL_OW 274
25241: PPUSH
25242: LD_VAR 0 2
25246: PPUSH
25247: LD_INT 0
25249: PPUSH
25250: CALL 22816 0 3
25254: PPUSH
25255: LD_INT 30
25257: PUSH
25258: LD_INT 3
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: PPUSH
25265: CALL_OW 72
25269: ST_TO_ADDR
// if not factories then
25270: LD_VAR 0 6
25274: NOT
25275: IFFALSE 25279
// exit ;
25277: GO 26245
// for i in factories do
25279: LD_ADDR_VAR 0 8
25283: PUSH
25284: LD_VAR 0 6
25288: PUSH
25289: FOR_IN
25290: IFFALSE 25315
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25292: LD_ADDR_VAR 0 17
25296: PUSH
25297: LD_VAR 0 17
25301: PUSH
25302: LD_VAR 0 8
25306: PPUSH
25307: CALL_OW 478
25311: UNION
25312: ST_TO_ADDR
25313: GO 25289
25315: POP
25316: POP
// if not fac_list then
25317: LD_VAR 0 17
25321: NOT
25322: IFFALSE 25326
// exit ;
25324: GO 26245
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25326: LD_ADDR_VAR 0 5
25330: PUSH
25331: LD_INT 4
25333: PUSH
25334: LD_INT 5
25336: PUSH
25337: LD_INT 9
25339: PUSH
25340: LD_INT 10
25342: PUSH
25343: LD_INT 6
25345: PUSH
25346: LD_INT 7
25348: PUSH
25349: LD_INT 11
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: LIST
25357: LIST
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 27
25363: PUSH
25364: LD_INT 28
25366: PUSH
25367: LD_INT 26
25369: PUSH
25370: LD_INT 30
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 43
25381: PUSH
25382: LD_INT 44
25384: PUSH
25385: LD_INT 46
25387: PUSH
25388: LD_INT 45
25390: PUSH
25391: LD_INT 47
25393: PUSH
25394: LD_INT 49
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: LIST
25409: PUSH
25410: LD_VAR 0 12
25414: ARRAY
25415: ST_TO_ADDR
// list := list isect fac_list ;
25416: LD_ADDR_VAR 0 5
25420: PUSH
25421: LD_VAR 0 5
25425: PUSH
25426: LD_VAR 0 17
25430: ISECT
25431: ST_TO_ADDR
// if not list then
25432: LD_VAR 0 5
25436: NOT
25437: IFFALSE 25441
// exit ;
25439: GO 26245
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25441: LD_VAR 0 12
25445: PUSH
25446: LD_INT 3
25448: EQUAL
25449: PUSH
25450: LD_INT 49
25452: PUSH
25453: LD_VAR 0 5
25457: IN
25458: AND
25459: PUSH
25460: LD_INT 31
25462: PPUSH
25463: LD_VAR 0 16
25467: PPUSH
25468: CALL_OW 321
25472: PUSH
25473: LD_INT 2
25475: EQUAL
25476: AND
25477: IFFALSE 25537
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25479: LD_INT 22
25481: PUSH
25482: LD_VAR 0 16
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 35
25493: PUSH
25494: LD_INT 49
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 91
25503: PUSH
25504: LD_VAR 0 1
25508: PUSH
25509: LD_INT 10
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: LIST
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: LIST
25521: PPUSH
25522: CALL_OW 69
25526: NOT
25527: IFFALSE 25537
// weapon := ru_time_lapser ;
25529: LD_ADDR_VAR 0 18
25533: PUSH
25534: LD_INT 49
25536: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25537: LD_VAR 0 12
25541: PUSH
25542: LD_INT 1
25544: PUSH
25545: LD_INT 2
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: IN
25552: PUSH
25553: LD_INT 11
25555: PUSH
25556: LD_VAR 0 5
25560: IN
25561: PUSH
25562: LD_INT 30
25564: PUSH
25565: LD_VAR 0 5
25569: IN
25570: OR
25571: AND
25572: PUSH
25573: LD_INT 6
25575: PPUSH
25576: LD_VAR 0 16
25580: PPUSH
25581: CALL_OW 321
25585: PUSH
25586: LD_INT 2
25588: EQUAL
25589: AND
25590: IFFALSE 25755
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25592: LD_INT 22
25594: PUSH
25595: LD_VAR 0 16
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: LD_INT 2
25606: PUSH
25607: LD_INT 35
25609: PUSH
25610: LD_INT 11
25612: PUSH
25613: EMPTY
25614: LIST
25615: LIST
25616: PUSH
25617: LD_INT 35
25619: PUSH
25620: LD_INT 30
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 91
25634: PUSH
25635: LD_VAR 0 1
25639: PUSH
25640: LD_INT 18
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: LIST
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: LIST
25652: PPUSH
25653: CALL_OW 69
25657: NOT
25658: PUSH
25659: LD_INT 22
25661: PUSH
25662: LD_VAR 0 16
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PUSH
25671: LD_INT 2
25673: PUSH
25674: LD_INT 30
25676: PUSH
25677: LD_INT 32
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 30
25686: PUSH
25687: LD_INT 33
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: LIST
25698: PUSH
25699: LD_INT 91
25701: PUSH
25702: LD_VAR 0 1
25706: PUSH
25707: LD_INT 12
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: LIST
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: PUSH
25720: EMPTY
25721: LIST
25722: PPUSH
25723: CALL_OW 69
25727: PUSH
25728: LD_INT 2
25730: GREATER
25731: AND
25732: IFFALSE 25755
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25734: LD_ADDR_VAR 0 18
25738: PUSH
25739: LD_INT 11
25741: PUSH
25742: LD_INT 30
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_VAR 0 12
25753: ARRAY
25754: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25755: LD_VAR 0 18
25759: NOT
25760: PUSH
25761: LD_INT 40
25763: PPUSH
25764: LD_VAR 0 16
25768: PPUSH
25769: CALL_OW 321
25773: PUSH
25774: LD_INT 2
25776: EQUAL
25777: AND
25778: PUSH
25779: LD_INT 7
25781: PUSH
25782: LD_VAR 0 5
25786: IN
25787: PUSH
25788: LD_INT 28
25790: PUSH
25791: LD_VAR 0 5
25795: IN
25796: OR
25797: PUSH
25798: LD_INT 45
25800: PUSH
25801: LD_VAR 0 5
25805: IN
25806: OR
25807: AND
25808: IFFALSE 26062
// begin hex := GetHexInfo ( x , y ) ;
25810: LD_ADDR_VAR 0 4
25814: PUSH
25815: LD_VAR 0 10
25819: PPUSH
25820: LD_VAR 0 11
25824: PPUSH
25825: CALL_OW 546
25829: ST_TO_ADDR
// if hex [ 1 ] then
25830: LD_VAR 0 4
25834: PUSH
25835: LD_INT 1
25837: ARRAY
25838: IFFALSE 25842
// exit ;
25840: GO 26245
// height := hex [ 2 ] ;
25842: LD_ADDR_VAR 0 15
25846: PUSH
25847: LD_VAR 0 4
25851: PUSH
25852: LD_INT 2
25854: ARRAY
25855: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25856: LD_ADDR_VAR 0 14
25860: PUSH
25861: LD_INT 0
25863: PUSH
25864: LD_INT 2
25866: PUSH
25867: LD_INT 3
25869: PUSH
25870: LD_INT 5
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: LIST
25877: LIST
25878: ST_TO_ADDR
// for i in tmp do
25879: LD_ADDR_VAR 0 8
25883: PUSH
25884: LD_VAR 0 14
25888: PUSH
25889: FOR_IN
25890: IFFALSE 26060
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25892: LD_ADDR_VAR 0 9
25896: PUSH
25897: LD_VAR 0 10
25901: PPUSH
25902: LD_VAR 0 8
25906: PPUSH
25907: LD_INT 5
25909: PPUSH
25910: CALL_OW 272
25914: PUSH
25915: LD_VAR 0 11
25919: PPUSH
25920: LD_VAR 0 8
25924: PPUSH
25925: LD_INT 5
25927: PPUSH
25928: CALL_OW 273
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25937: LD_VAR 0 9
25941: PUSH
25942: LD_INT 1
25944: ARRAY
25945: PPUSH
25946: LD_VAR 0 9
25950: PUSH
25951: LD_INT 2
25953: ARRAY
25954: PPUSH
25955: CALL_OW 488
25959: IFFALSE 26058
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25961: LD_ADDR_VAR 0 4
25965: PUSH
25966: LD_VAR 0 9
25970: PUSH
25971: LD_INT 1
25973: ARRAY
25974: PPUSH
25975: LD_VAR 0 9
25979: PUSH
25980: LD_INT 2
25982: ARRAY
25983: PPUSH
25984: CALL_OW 546
25988: ST_TO_ADDR
// if hex [ 1 ] then
25989: LD_VAR 0 4
25993: PUSH
25994: LD_INT 1
25996: ARRAY
25997: IFFALSE 26001
// continue ;
25999: GO 25889
// h := hex [ 2 ] ;
26001: LD_ADDR_VAR 0 13
26005: PUSH
26006: LD_VAR 0 4
26010: PUSH
26011: LD_INT 2
26013: ARRAY
26014: ST_TO_ADDR
// if h + 7 < height then
26015: LD_VAR 0 13
26019: PUSH
26020: LD_INT 7
26022: PLUS
26023: PUSH
26024: LD_VAR 0 15
26028: LESS
26029: IFFALSE 26058
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26031: LD_ADDR_VAR 0 18
26035: PUSH
26036: LD_INT 7
26038: PUSH
26039: LD_INT 28
26041: PUSH
26042: LD_INT 45
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: LIST
26049: PUSH
26050: LD_VAR 0 12
26054: ARRAY
26055: ST_TO_ADDR
// break ;
26056: GO 26060
// end ; end ; end ;
26058: GO 25889
26060: POP
26061: POP
// end ; if not weapon then
26062: LD_VAR 0 18
26066: NOT
26067: IFFALSE 26127
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26069: LD_ADDR_VAR 0 5
26073: PUSH
26074: LD_VAR 0 5
26078: PUSH
26079: LD_INT 11
26081: PUSH
26082: LD_INT 30
26084: PUSH
26085: LD_INT 49
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: LIST
26092: DIFF
26093: ST_TO_ADDR
// if not list then
26094: LD_VAR 0 5
26098: NOT
26099: IFFALSE 26103
// exit ;
26101: GO 26245
// weapon := list [ rand ( 1 , list ) ] ;
26103: LD_ADDR_VAR 0 18
26107: PUSH
26108: LD_VAR 0 5
26112: PUSH
26113: LD_INT 1
26115: PPUSH
26116: LD_VAR 0 5
26120: PPUSH
26121: CALL_OW 12
26125: ARRAY
26126: ST_TO_ADDR
// end ; if weapon then
26127: LD_VAR 0 18
26131: IFFALSE 26245
// begin tmp := CostOfWeapon ( weapon ) ;
26133: LD_ADDR_VAR 0 14
26137: PUSH
26138: LD_VAR 0 18
26142: PPUSH
26143: CALL_OW 451
26147: ST_TO_ADDR
// j := GetBase ( tower ) ;
26148: LD_ADDR_VAR 0 9
26152: PUSH
26153: LD_VAR 0 1
26157: PPUSH
26158: CALL_OW 274
26162: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26163: LD_VAR 0 9
26167: PPUSH
26168: LD_INT 1
26170: PPUSH
26171: CALL_OW 275
26175: PUSH
26176: LD_VAR 0 14
26180: PUSH
26181: LD_INT 1
26183: ARRAY
26184: GREATEREQUAL
26185: PUSH
26186: LD_VAR 0 9
26190: PPUSH
26191: LD_INT 2
26193: PPUSH
26194: CALL_OW 275
26198: PUSH
26199: LD_VAR 0 14
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: GREATEREQUAL
26208: AND
26209: PUSH
26210: LD_VAR 0 9
26214: PPUSH
26215: LD_INT 3
26217: PPUSH
26218: CALL_OW 275
26222: PUSH
26223: LD_VAR 0 14
26227: PUSH
26228: LD_INT 3
26230: ARRAY
26231: GREATEREQUAL
26232: AND
26233: IFFALSE 26245
// result := weapon ;
26235: LD_ADDR_VAR 0 3
26239: PUSH
26240: LD_VAR 0 18
26244: ST_TO_ADDR
// end ; end ;
26245: LD_VAR 0 3
26249: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26250: LD_INT 0
26252: PPUSH
26253: PPUSH
// result := true ;
26254: LD_ADDR_VAR 0 3
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// if array1 = array2 then
26262: LD_VAR 0 1
26266: PUSH
26267: LD_VAR 0 2
26271: EQUAL
26272: IFFALSE 26332
// begin for i = 1 to array1 do
26274: LD_ADDR_VAR 0 4
26278: PUSH
26279: DOUBLE
26280: LD_INT 1
26282: DEC
26283: ST_TO_ADDR
26284: LD_VAR 0 1
26288: PUSH
26289: FOR_TO
26290: IFFALSE 26328
// if array1 [ i ] <> array2 [ i ] then
26292: LD_VAR 0 1
26296: PUSH
26297: LD_VAR 0 4
26301: ARRAY
26302: PUSH
26303: LD_VAR 0 2
26307: PUSH
26308: LD_VAR 0 4
26312: ARRAY
26313: NONEQUAL
26314: IFFALSE 26326
// begin result := false ;
26316: LD_ADDR_VAR 0 3
26320: PUSH
26321: LD_INT 0
26323: ST_TO_ADDR
// break ;
26324: GO 26328
// end ;
26326: GO 26289
26328: POP
26329: POP
// end else
26330: GO 26340
// result := false ;
26332: LD_ADDR_VAR 0 3
26336: PUSH
26337: LD_INT 0
26339: ST_TO_ADDR
// end ;
26340: LD_VAR 0 3
26344: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26345: LD_INT 0
26347: PPUSH
26348: PPUSH
// if not array1 or not array2 then
26349: LD_VAR 0 1
26353: NOT
26354: PUSH
26355: LD_VAR 0 2
26359: NOT
26360: OR
26361: IFFALSE 26365
// exit ;
26363: GO 26429
// result := true ;
26365: LD_ADDR_VAR 0 3
26369: PUSH
26370: LD_INT 1
26372: ST_TO_ADDR
// for i = 1 to array1 do
26373: LD_ADDR_VAR 0 4
26377: PUSH
26378: DOUBLE
26379: LD_INT 1
26381: DEC
26382: ST_TO_ADDR
26383: LD_VAR 0 1
26387: PUSH
26388: FOR_TO
26389: IFFALSE 26427
// if array1 [ i ] <> array2 [ i ] then
26391: LD_VAR 0 1
26395: PUSH
26396: LD_VAR 0 4
26400: ARRAY
26401: PUSH
26402: LD_VAR 0 2
26406: PUSH
26407: LD_VAR 0 4
26411: ARRAY
26412: NONEQUAL
26413: IFFALSE 26425
// begin result := false ;
26415: LD_ADDR_VAR 0 3
26419: PUSH
26420: LD_INT 0
26422: ST_TO_ADDR
// break ;
26423: GO 26427
// end ;
26425: GO 26388
26427: POP
26428: POP
// end ;
26429: LD_VAR 0 3
26433: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26434: LD_INT 0
26436: PPUSH
26437: PPUSH
26438: PPUSH
// pom := GetBase ( fac ) ;
26439: LD_ADDR_VAR 0 5
26443: PUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 274
26453: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26454: LD_ADDR_VAR 0 4
26458: PUSH
26459: LD_VAR 0 2
26463: PUSH
26464: LD_INT 1
26466: ARRAY
26467: PPUSH
26468: LD_VAR 0 2
26472: PUSH
26473: LD_INT 2
26475: ARRAY
26476: PPUSH
26477: LD_VAR 0 2
26481: PUSH
26482: LD_INT 3
26484: ARRAY
26485: PPUSH
26486: LD_VAR 0 2
26490: PUSH
26491: LD_INT 4
26493: ARRAY
26494: PPUSH
26495: CALL_OW 449
26499: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26500: LD_ADDR_VAR 0 3
26504: PUSH
26505: LD_VAR 0 5
26509: PPUSH
26510: LD_INT 1
26512: PPUSH
26513: CALL_OW 275
26517: PUSH
26518: LD_VAR 0 4
26522: PUSH
26523: LD_INT 1
26525: ARRAY
26526: GREATEREQUAL
26527: PUSH
26528: LD_VAR 0 5
26532: PPUSH
26533: LD_INT 2
26535: PPUSH
26536: CALL_OW 275
26540: PUSH
26541: LD_VAR 0 4
26545: PUSH
26546: LD_INT 2
26548: ARRAY
26549: GREATEREQUAL
26550: AND
26551: PUSH
26552: LD_VAR 0 5
26556: PPUSH
26557: LD_INT 3
26559: PPUSH
26560: CALL_OW 275
26564: PUSH
26565: LD_VAR 0 4
26569: PUSH
26570: LD_INT 3
26572: ARRAY
26573: GREATEREQUAL
26574: AND
26575: ST_TO_ADDR
// end ;
26576: LD_VAR 0 3
26580: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26581: LD_INT 0
26583: PPUSH
26584: PPUSH
26585: PPUSH
26586: PPUSH
// pom := GetBase ( building ) ;
26587: LD_ADDR_VAR 0 3
26591: PUSH
26592: LD_VAR 0 1
26596: PPUSH
26597: CALL_OW 274
26601: ST_TO_ADDR
// if not pom then
26602: LD_VAR 0 3
26606: NOT
26607: IFFALSE 26611
// exit ;
26609: GO 26781
// btype := GetBType ( building ) ;
26611: LD_ADDR_VAR 0 5
26615: PUSH
26616: LD_VAR 0 1
26620: PPUSH
26621: CALL_OW 266
26625: ST_TO_ADDR
// if btype = b_armoury then
26626: LD_VAR 0 5
26630: PUSH
26631: LD_INT 4
26633: EQUAL
26634: IFFALSE 26644
// btype := b_barracks ;
26636: LD_ADDR_VAR 0 5
26640: PUSH
26641: LD_INT 5
26643: ST_TO_ADDR
// if btype = b_depot then
26644: LD_VAR 0 5
26648: PUSH
26649: LD_INT 0
26651: EQUAL
26652: IFFALSE 26662
// btype := b_warehouse ;
26654: LD_ADDR_VAR 0 5
26658: PUSH
26659: LD_INT 1
26661: ST_TO_ADDR
// if btype = b_workshop then
26662: LD_VAR 0 5
26666: PUSH
26667: LD_INT 2
26669: EQUAL
26670: IFFALSE 26680
// btype := b_factory ;
26672: LD_ADDR_VAR 0 5
26676: PUSH
26677: LD_INT 3
26679: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26680: LD_ADDR_VAR 0 4
26684: PUSH
26685: LD_VAR 0 5
26689: PPUSH
26690: LD_VAR 0 1
26694: PPUSH
26695: CALL_OW 248
26699: PPUSH
26700: CALL_OW 450
26704: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26705: LD_ADDR_VAR 0 2
26709: PUSH
26710: LD_VAR 0 3
26714: PPUSH
26715: LD_INT 1
26717: PPUSH
26718: CALL_OW 275
26722: PUSH
26723: LD_VAR 0 4
26727: PUSH
26728: LD_INT 1
26730: ARRAY
26731: GREATEREQUAL
26732: PUSH
26733: LD_VAR 0 3
26737: PPUSH
26738: LD_INT 2
26740: PPUSH
26741: CALL_OW 275
26745: PUSH
26746: LD_VAR 0 4
26750: PUSH
26751: LD_INT 2
26753: ARRAY
26754: GREATEREQUAL
26755: AND
26756: PUSH
26757: LD_VAR 0 3
26761: PPUSH
26762: LD_INT 3
26764: PPUSH
26765: CALL_OW 275
26769: PUSH
26770: LD_VAR 0 4
26774: PUSH
26775: LD_INT 3
26777: ARRAY
26778: GREATEREQUAL
26779: AND
26780: ST_TO_ADDR
// end ;
26781: LD_VAR 0 2
26785: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26786: LD_INT 0
26788: PPUSH
26789: PPUSH
26790: PPUSH
// pom := GetBase ( building ) ;
26791: LD_ADDR_VAR 0 4
26795: PUSH
26796: LD_VAR 0 1
26800: PPUSH
26801: CALL_OW 274
26805: ST_TO_ADDR
// if not pom then
26806: LD_VAR 0 4
26810: NOT
26811: IFFALSE 26815
// exit ;
26813: GO 26916
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26815: LD_ADDR_VAR 0 5
26819: PUSH
26820: LD_VAR 0 2
26824: PPUSH
26825: LD_VAR 0 1
26829: PPUSH
26830: CALL_OW 248
26834: PPUSH
26835: CALL_OW 450
26839: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26840: LD_ADDR_VAR 0 3
26844: PUSH
26845: LD_VAR 0 4
26849: PPUSH
26850: LD_INT 1
26852: PPUSH
26853: CALL_OW 275
26857: PUSH
26858: LD_VAR 0 5
26862: PUSH
26863: LD_INT 1
26865: ARRAY
26866: GREATEREQUAL
26867: PUSH
26868: LD_VAR 0 4
26872: PPUSH
26873: LD_INT 2
26875: PPUSH
26876: CALL_OW 275
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_INT 2
26888: ARRAY
26889: GREATEREQUAL
26890: AND
26891: PUSH
26892: LD_VAR 0 4
26896: PPUSH
26897: LD_INT 3
26899: PPUSH
26900: CALL_OW 275
26904: PUSH
26905: LD_VAR 0 5
26909: PUSH
26910: LD_INT 3
26912: ARRAY
26913: GREATEREQUAL
26914: AND
26915: ST_TO_ADDR
// end ;
26916: LD_VAR 0 3
26920: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26921: LD_INT 0
26923: PPUSH
26924: PPUSH
26925: PPUSH
26926: PPUSH
26927: PPUSH
26928: PPUSH
26929: PPUSH
26930: PPUSH
26931: PPUSH
26932: PPUSH
26933: PPUSH
// result := false ;
26934: LD_ADDR_VAR 0 8
26938: PUSH
26939: LD_INT 0
26941: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26942: LD_VAR 0 5
26946: NOT
26947: PUSH
26948: LD_VAR 0 1
26952: NOT
26953: OR
26954: PUSH
26955: LD_VAR 0 2
26959: NOT
26960: OR
26961: PUSH
26962: LD_VAR 0 3
26966: NOT
26967: OR
26968: IFFALSE 26972
// exit ;
26970: GO 27786
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26972: LD_ADDR_VAR 0 14
26976: PUSH
26977: LD_VAR 0 1
26981: PPUSH
26982: LD_VAR 0 2
26986: PPUSH
26987: LD_VAR 0 3
26991: PPUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_VAR 0 5
27001: PUSH
27002: LD_INT 1
27004: ARRAY
27005: PPUSH
27006: CALL_OW 248
27010: PPUSH
27011: LD_INT 0
27013: PPUSH
27014: CALL 29019 0 6
27018: ST_TO_ADDR
// if not hexes then
27019: LD_VAR 0 14
27023: NOT
27024: IFFALSE 27028
// exit ;
27026: GO 27786
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27028: LD_ADDR_VAR 0 17
27032: PUSH
27033: LD_VAR 0 5
27037: PPUSH
27038: LD_INT 22
27040: PUSH
27041: LD_VAR 0 13
27045: PPUSH
27046: CALL_OW 255
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 2
27057: PUSH
27058: LD_INT 30
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 30
27070: PUSH
27071: LD_INT 1
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: LIST
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PPUSH
27087: CALL_OW 72
27091: ST_TO_ADDR
// for i = 1 to hexes do
27092: LD_ADDR_VAR 0 9
27096: PUSH
27097: DOUBLE
27098: LD_INT 1
27100: DEC
27101: ST_TO_ADDR
27102: LD_VAR 0 14
27106: PUSH
27107: FOR_TO
27108: IFFALSE 27784
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27110: LD_ADDR_VAR 0 13
27114: PUSH
27115: LD_VAR 0 14
27119: PUSH
27120: LD_VAR 0 9
27124: ARRAY
27125: PUSH
27126: LD_INT 1
27128: ARRAY
27129: PPUSH
27130: LD_VAR 0 14
27134: PUSH
27135: LD_VAR 0 9
27139: ARRAY
27140: PUSH
27141: LD_INT 2
27143: ARRAY
27144: PPUSH
27145: CALL_OW 428
27149: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27150: LD_VAR 0 14
27154: PUSH
27155: LD_VAR 0 9
27159: ARRAY
27160: PUSH
27161: LD_INT 1
27163: ARRAY
27164: PPUSH
27165: LD_VAR 0 14
27169: PUSH
27170: LD_VAR 0 9
27174: ARRAY
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 351
27184: PUSH
27185: LD_VAR 0 14
27189: PUSH
27190: LD_VAR 0 9
27194: ARRAY
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: LD_VAR 0 14
27204: PUSH
27205: LD_VAR 0 9
27209: ARRAY
27210: PUSH
27211: LD_INT 2
27213: ARRAY
27214: PPUSH
27215: CALL_OW 488
27219: NOT
27220: OR
27221: PUSH
27222: LD_VAR 0 13
27226: PPUSH
27227: CALL_OW 247
27231: PUSH
27232: LD_INT 3
27234: EQUAL
27235: OR
27236: IFFALSE 27242
// exit ;
27238: POP
27239: POP
27240: GO 27786
// if not tmp then
27242: LD_VAR 0 13
27246: NOT
27247: IFFALSE 27251
// continue ;
27249: GO 27107
// result := true ;
27251: LD_ADDR_VAR 0 8
27255: PUSH
27256: LD_INT 1
27258: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27259: LD_VAR 0 6
27263: PUSH
27264: LD_VAR 0 13
27268: PPUSH
27269: CALL_OW 247
27273: PUSH
27274: LD_INT 2
27276: EQUAL
27277: AND
27278: PUSH
27279: LD_VAR 0 13
27283: PPUSH
27284: CALL_OW 263
27288: PUSH
27289: LD_INT 1
27291: EQUAL
27292: AND
27293: IFFALSE 27457
// begin if IsDrivenBy ( tmp ) then
27295: LD_VAR 0 13
27299: PPUSH
27300: CALL_OW 311
27304: IFFALSE 27308
// continue ;
27306: GO 27107
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27308: LD_VAR 0 6
27312: PPUSH
27313: LD_INT 3
27315: PUSH
27316: LD_INT 60
27318: PUSH
27319: EMPTY
27320: LIST
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: PUSH
27326: LD_INT 3
27328: PUSH
27329: LD_INT 55
27331: PUSH
27332: EMPTY
27333: LIST
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: PPUSH
27343: CALL_OW 72
27347: IFFALSE 27455
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27349: LD_ADDR_VAR 0 18
27353: PUSH
27354: LD_VAR 0 6
27358: PPUSH
27359: LD_INT 3
27361: PUSH
27362: LD_INT 60
27364: PUSH
27365: EMPTY
27366: LIST
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 3
27374: PUSH
27375: LD_INT 55
27377: PUSH
27378: EMPTY
27379: LIST
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PPUSH
27389: CALL_OW 72
27393: PUSH
27394: LD_INT 1
27396: ARRAY
27397: ST_TO_ADDR
// if IsInUnit ( driver ) then
27398: LD_VAR 0 18
27402: PPUSH
27403: CALL_OW 310
27407: IFFALSE 27418
// ComExit ( driver ) ;
27409: LD_VAR 0 18
27413: PPUSH
27414: CALL 52799 0 1
// AddComEnterUnit ( driver , tmp ) ;
27418: LD_VAR 0 18
27422: PPUSH
27423: LD_VAR 0 13
27427: PPUSH
27428: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27432: LD_VAR 0 18
27436: PPUSH
27437: LD_VAR 0 7
27441: PPUSH
27442: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27446: LD_VAR 0 18
27450: PPUSH
27451: CALL_OW 181
// end ; continue ;
27455: GO 27107
// end ; if not cleaners or not tmp in cleaners then
27457: LD_VAR 0 6
27461: NOT
27462: PUSH
27463: LD_VAR 0 13
27467: PUSH
27468: LD_VAR 0 6
27472: IN
27473: NOT
27474: OR
27475: IFFALSE 27782
// begin if dep then
27477: LD_VAR 0 17
27481: IFFALSE 27617
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27483: LD_ADDR_VAR 0 16
27487: PUSH
27488: LD_VAR 0 17
27492: PUSH
27493: LD_INT 1
27495: ARRAY
27496: PPUSH
27497: CALL_OW 250
27501: PPUSH
27502: LD_VAR 0 17
27506: PUSH
27507: LD_INT 1
27509: ARRAY
27510: PPUSH
27511: CALL_OW 254
27515: PPUSH
27516: LD_INT 5
27518: PPUSH
27519: CALL_OW 272
27523: PUSH
27524: LD_VAR 0 17
27528: PUSH
27529: LD_INT 1
27531: ARRAY
27532: PPUSH
27533: CALL_OW 251
27537: PPUSH
27538: LD_VAR 0 17
27542: PUSH
27543: LD_INT 1
27545: ARRAY
27546: PPUSH
27547: CALL_OW 254
27551: PPUSH
27552: LD_INT 5
27554: PPUSH
27555: CALL_OW 273
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27564: LD_VAR 0 16
27568: PUSH
27569: LD_INT 1
27571: ARRAY
27572: PPUSH
27573: LD_VAR 0 16
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: PPUSH
27582: CALL_OW 488
27586: IFFALSE 27617
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27588: LD_VAR 0 13
27592: PPUSH
27593: LD_VAR 0 16
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 16
27606: PUSH
27607: LD_INT 2
27609: ARRAY
27610: PPUSH
27611: CALL_OW 111
// continue ;
27615: GO 27107
// end ; end ; r := GetDir ( tmp ) ;
27617: LD_ADDR_VAR 0 15
27621: PUSH
27622: LD_VAR 0 13
27626: PPUSH
27627: CALL_OW 254
27631: ST_TO_ADDR
// if r = 5 then
27632: LD_VAR 0 15
27636: PUSH
27637: LD_INT 5
27639: EQUAL
27640: IFFALSE 27650
// r := 0 ;
27642: LD_ADDR_VAR 0 15
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// for j = r to 5 do
27650: LD_ADDR_VAR 0 10
27654: PUSH
27655: DOUBLE
27656: LD_VAR 0 15
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 5
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27780
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27668: LD_ADDR_VAR 0 11
27672: PUSH
27673: LD_VAR 0 13
27677: PPUSH
27678: CALL_OW 250
27682: PPUSH
27683: LD_VAR 0 10
27687: PPUSH
27688: LD_INT 2
27690: PPUSH
27691: CALL_OW 272
27695: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27696: LD_ADDR_VAR 0 12
27700: PUSH
27701: LD_VAR 0 13
27705: PPUSH
27706: CALL_OW 251
27710: PPUSH
27711: LD_VAR 0 10
27715: PPUSH
27716: LD_INT 2
27718: PPUSH
27719: CALL_OW 273
27723: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27724: LD_VAR 0 11
27728: PPUSH
27729: LD_VAR 0 12
27733: PPUSH
27734: CALL_OW 488
27738: PUSH
27739: LD_VAR 0 11
27743: PPUSH
27744: LD_VAR 0 12
27748: PPUSH
27749: CALL_OW 428
27753: NOT
27754: AND
27755: IFFALSE 27778
// begin ComMoveXY ( tmp , _x , _y ) ;
27757: LD_VAR 0 13
27761: PPUSH
27762: LD_VAR 0 11
27766: PPUSH
27767: LD_VAR 0 12
27771: PPUSH
27772: CALL_OW 111
// break ;
27776: GO 27780
// end ; end ;
27778: GO 27665
27780: POP
27781: POP
// end ; end ;
27782: GO 27107
27784: POP
27785: POP
// end ;
27786: LD_VAR 0 8
27790: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27791: LD_INT 0
27793: PPUSH
// result := true ;
27794: LD_ADDR_VAR 0 3
27798: PUSH
27799: LD_INT 1
27801: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27802: LD_VAR 0 2
27806: PUSH
27807: LD_INT 24
27809: DOUBLE
27810: EQUAL
27811: IFTRUE 27821
27813: LD_INT 33
27815: DOUBLE
27816: EQUAL
27817: IFTRUE 27821
27819: GO 27846
27821: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27822: LD_ADDR_VAR 0 3
27826: PUSH
27827: LD_INT 32
27829: PPUSH
27830: LD_VAR 0 1
27834: PPUSH
27835: CALL_OW 321
27839: PUSH
27840: LD_INT 2
27842: EQUAL
27843: ST_TO_ADDR
27844: GO 28162
27846: LD_INT 20
27848: DOUBLE
27849: EQUAL
27850: IFTRUE 27854
27852: GO 27879
27854: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27855: LD_ADDR_VAR 0 3
27859: PUSH
27860: LD_INT 6
27862: PPUSH
27863: LD_VAR 0 1
27867: PPUSH
27868: CALL_OW 321
27872: PUSH
27873: LD_INT 2
27875: EQUAL
27876: ST_TO_ADDR
27877: GO 28162
27879: LD_INT 22
27881: DOUBLE
27882: EQUAL
27883: IFTRUE 27893
27885: LD_INT 36
27887: DOUBLE
27888: EQUAL
27889: IFTRUE 27893
27891: GO 27918
27893: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27894: LD_ADDR_VAR 0 3
27898: PUSH
27899: LD_INT 15
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 321
27911: PUSH
27912: LD_INT 2
27914: EQUAL
27915: ST_TO_ADDR
27916: GO 28162
27918: LD_INT 30
27920: DOUBLE
27921: EQUAL
27922: IFTRUE 27926
27924: GO 27951
27926: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27927: LD_ADDR_VAR 0 3
27931: PUSH
27932: LD_INT 20
27934: PPUSH
27935: LD_VAR 0 1
27939: PPUSH
27940: CALL_OW 321
27944: PUSH
27945: LD_INT 2
27947: EQUAL
27948: ST_TO_ADDR
27949: GO 28162
27951: LD_INT 28
27953: DOUBLE
27954: EQUAL
27955: IFTRUE 27965
27957: LD_INT 21
27959: DOUBLE
27960: EQUAL
27961: IFTRUE 27965
27963: GO 27990
27965: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27966: LD_ADDR_VAR 0 3
27970: PUSH
27971: LD_INT 21
27973: PPUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 321
27983: PUSH
27984: LD_INT 2
27986: EQUAL
27987: ST_TO_ADDR
27988: GO 28162
27990: LD_INT 16
27992: DOUBLE
27993: EQUAL
27994: IFTRUE 27998
27996: GO 28023
27998: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27999: LD_ADDR_VAR 0 3
28003: PUSH
28004: LD_INT 84
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 321
28016: PUSH
28017: LD_INT 2
28019: EQUAL
28020: ST_TO_ADDR
28021: GO 28162
28023: LD_INT 19
28025: DOUBLE
28026: EQUAL
28027: IFTRUE 28037
28029: LD_INT 23
28031: DOUBLE
28032: EQUAL
28033: IFTRUE 28037
28035: GO 28062
28037: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28038: LD_ADDR_VAR 0 3
28042: PUSH
28043: LD_INT 83
28045: PPUSH
28046: LD_VAR 0 1
28050: PPUSH
28051: CALL_OW 321
28055: PUSH
28056: LD_INT 2
28058: EQUAL
28059: ST_TO_ADDR
28060: GO 28162
28062: LD_INT 17
28064: DOUBLE
28065: EQUAL
28066: IFTRUE 28070
28068: GO 28095
28070: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28071: LD_ADDR_VAR 0 3
28075: PUSH
28076: LD_INT 39
28078: PPUSH
28079: LD_VAR 0 1
28083: PPUSH
28084: CALL_OW 321
28088: PUSH
28089: LD_INT 2
28091: EQUAL
28092: ST_TO_ADDR
28093: GO 28162
28095: LD_INT 18
28097: DOUBLE
28098: EQUAL
28099: IFTRUE 28103
28101: GO 28128
28103: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28104: LD_ADDR_VAR 0 3
28108: PUSH
28109: LD_INT 40
28111: PPUSH
28112: LD_VAR 0 1
28116: PPUSH
28117: CALL_OW 321
28121: PUSH
28122: LD_INT 2
28124: EQUAL
28125: ST_TO_ADDR
28126: GO 28162
28128: LD_INT 27
28130: DOUBLE
28131: EQUAL
28132: IFTRUE 28136
28134: GO 28161
28136: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28137: LD_ADDR_VAR 0 3
28141: PUSH
28142: LD_INT 35
28144: PPUSH
28145: LD_VAR 0 1
28149: PPUSH
28150: CALL_OW 321
28154: PUSH
28155: LD_INT 2
28157: EQUAL
28158: ST_TO_ADDR
28159: GO 28162
28161: POP
// end ;
28162: LD_VAR 0 3
28166: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28167: LD_INT 0
28169: PPUSH
28170: PPUSH
28171: PPUSH
28172: PPUSH
28173: PPUSH
28174: PPUSH
28175: PPUSH
28176: PPUSH
28177: PPUSH
28178: PPUSH
28179: PPUSH
// result := false ;
28180: LD_ADDR_VAR 0 6
28184: PUSH
28185: LD_INT 0
28187: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28188: LD_VAR 0 1
28192: NOT
28193: PUSH
28194: LD_VAR 0 1
28198: PPUSH
28199: CALL_OW 266
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 1
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: IN
28214: NOT
28215: OR
28216: PUSH
28217: LD_VAR 0 2
28221: NOT
28222: OR
28223: PUSH
28224: LD_VAR 0 5
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: LD_INT 1
28234: PUSH
28235: LD_INT 2
28237: PUSH
28238: LD_INT 3
28240: PUSH
28241: LD_INT 4
28243: PUSH
28244: LD_INT 5
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: IN
28255: NOT
28256: OR
28257: PUSH
28258: LD_VAR 0 3
28262: PPUSH
28263: LD_VAR 0 4
28267: PPUSH
28268: CALL_OW 488
28272: NOT
28273: OR
28274: IFFALSE 28278
// exit ;
28276: GO 29014
// side := GetSide ( depot ) ;
28278: LD_ADDR_VAR 0 9
28282: PUSH
28283: LD_VAR 0 1
28287: PPUSH
28288: CALL_OW 255
28292: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28293: LD_VAR 0 9
28297: PPUSH
28298: LD_VAR 0 2
28302: PPUSH
28303: CALL 27791 0 2
28307: NOT
28308: IFFALSE 28312
// exit ;
28310: GO 29014
// pom := GetBase ( depot ) ;
28312: LD_ADDR_VAR 0 10
28316: PUSH
28317: LD_VAR 0 1
28321: PPUSH
28322: CALL_OW 274
28326: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28327: LD_ADDR_VAR 0 11
28331: PUSH
28332: LD_VAR 0 2
28336: PPUSH
28337: LD_VAR 0 1
28341: PPUSH
28342: CALL_OW 248
28346: PPUSH
28347: CALL_OW 450
28351: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28352: LD_VAR 0 10
28356: PPUSH
28357: LD_INT 1
28359: PPUSH
28360: CALL_OW 275
28364: PUSH
28365: LD_VAR 0 11
28369: PUSH
28370: LD_INT 1
28372: ARRAY
28373: GREATEREQUAL
28374: PUSH
28375: LD_VAR 0 10
28379: PPUSH
28380: LD_INT 2
28382: PPUSH
28383: CALL_OW 275
28387: PUSH
28388: LD_VAR 0 11
28392: PUSH
28393: LD_INT 2
28395: ARRAY
28396: GREATEREQUAL
28397: AND
28398: PUSH
28399: LD_VAR 0 10
28403: PPUSH
28404: LD_INT 3
28406: PPUSH
28407: CALL_OW 275
28411: PUSH
28412: LD_VAR 0 11
28416: PUSH
28417: LD_INT 3
28419: ARRAY
28420: GREATEREQUAL
28421: AND
28422: NOT
28423: IFFALSE 28427
// exit ;
28425: GO 29014
// if GetBType ( depot ) = b_depot then
28427: LD_VAR 0 1
28431: PPUSH
28432: CALL_OW 266
28436: PUSH
28437: LD_INT 0
28439: EQUAL
28440: IFFALSE 28452
// dist := 28 else
28442: LD_ADDR_VAR 0 14
28446: PUSH
28447: LD_INT 28
28449: ST_TO_ADDR
28450: GO 28460
// dist := 36 ;
28452: LD_ADDR_VAR 0 14
28456: PUSH
28457: LD_INT 36
28459: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28460: LD_VAR 0 1
28464: PPUSH
28465: LD_VAR 0 3
28469: PPUSH
28470: LD_VAR 0 4
28474: PPUSH
28475: CALL_OW 297
28479: PUSH
28480: LD_VAR 0 14
28484: GREATER
28485: IFFALSE 28489
// exit ;
28487: GO 29014
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28489: LD_ADDR_VAR 0 12
28493: PUSH
28494: LD_VAR 0 2
28498: PPUSH
28499: LD_VAR 0 3
28503: PPUSH
28504: LD_VAR 0 4
28508: PPUSH
28509: LD_VAR 0 5
28513: PPUSH
28514: LD_VAR 0 1
28518: PPUSH
28519: CALL_OW 248
28523: PPUSH
28524: LD_INT 0
28526: PPUSH
28527: CALL 29019 0 6
28531: ST_TO_ADDR
// if not hexes then
28532: LD_VAR 0 12
28536: NOT
28537: IFFALSE 28541
// exit ;
28539: GO 29014
// hex := GetHexInfo ( x , y ) ;
28541: LD_ADDR_VAR 0 15
28545: PUSH
28546: LD_VAR 0 3
28550: PPUSH
28551: LD_VAR 0 4
28555: PPUSH
28556: CALL_OW 546
28560: ST_TO_ADDR
// if hex [ 1 ] then
28561: LD_VAR 0 15
28565: PUSH
28566: LD_INT 1
28568: ARRAY
28569: IFFALSE 28573
// exit ;
28571: GO 29014
// height := hex [ 2 ] ;
28573: LD_ADDR_VAR 0 13
28577: PUSH
28578: LD_VAR 0 15
28582: PUSH
28583: LD_INT 2
28585: ARRAY
28586: ST_TO_ADDR
// for i = 1 to hexes do
28587: LD_ADDR_VAR 0 7
28591: PUSH
28592: DOUBLE
28593: LD_INT 1
28595: DEC
28596: ST_TO_ADDR
28597: LD_VAR 0 12
28601: PUSH
28602: FOR_TO
28603: IFFALSE 28933
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28605: LD_VAR 0 12
28609: PUSH
28610: LD_VAR 0 7
28614: ARRAY
28615: PUSH
28616: LD_INT 1
28618: ARRAY
28619: PPUSH
28620: LD_VAR 0 12
28624: PUSH
28625: LD_VAR 0 7
28629: ARRAY
28630: PUSH
28631: LD_INT 2
28633: ARRAY
28634: PPUSH
28635: CALL_OW 488
28639: NOT
28640: PUSH
28641: LD_VAR 0 12
28645: PUSH
28646: LD_VAR 0 7
28650: ARRAY
28651: PUSH
28652: LD_INT 1
28654: ARRAY
28655: PPUSH
28656: LD_VAR 0 12
28660: PUSH
28661: LD_VAR 0 7
28665: ARRAY
28666: PUSH
28667: LD_INT 2
28669: ARRAY
28670: PPUSH
28671: CALL_OW 428
28675: PUSH
28676: LD_INT 0
28678: GREATER
28679: OR
28680: PUSH
28681: LD_VAR 0 12
28685: PUSH
28686: LD_VAR 0 7
28690: ARRAY
28691: PUSH
28692: LD_INT 1
28694: ARRAY
28695: PPUSH
28696: LD_VAR 0 12
28700: PUSH
28701: LD_VAR 0 7
28705: ARRAY
28706: PUSH
28707: LD_INT 2
28709: ARRAY
28710: PPUSH
28711: CALL_OW 351
28715: OR
28716: IFFALSE 28722
// exit ;
28718: POP
28719: POP
28720: GO 29014
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28722: LD_ADDR_VAR 0 8
28726: PUSH
28727: LD_VAR 0 12
28731: PUSH
28732: LD_VAR 0 7
28736: ARRAY
28737: PUSH
28738: LD_INT 1
28740: ARRAY
28741: PPUSH
28742: LD_VAR 0 12
28746: PUSH
28747: LD_VAR 0 7
28751: ARRAY
28752: PUSH
28753: LD_INT 2
28755: ARRAY
28756: PPUSH
28757: CALL_OW 546
28761: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28762: LD_VAR 0 8
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_VAR 0 8
28775: PUSH
28776: LD_INT 2
28778: ARRAY
28779: PUSH
28780: LD_VAR 0 13
28784: PUSH
28785: LD_INT 2
28787: PLUS
28788: GREATER
28789: OR
28790: PUSH
28791: LD_VAR 0 8
28795: PUSH
28796: LD_INT 2
28798: ARRAY
28799: PUSH
28800: LD_VAR 0 13
28804: PUSH
28805: LD_INT 2
28807: MINUS
28808: LESS
28809: OR
28810: PUSH
28811: LD_VAR 0 8
28815: PUSH
28816: LD_INT 3
28818: ARRAY
28819: PUSH
28820: LD_INT 0
28822: PUSH
28823: LD_INT 8
28825: PUSH
28826: LD_INT 9
28828: PUSH
28829: LD_INT 10
28831: PUSH
28832: LD_INT 11
28834: PUSH
28835: LD_INT 12
28837: PUSH
28838: LD_INT 13
28840: PUSH
28841: LD_INT 16
28843: PUSH
28844: LD_INT 17
28846: PUSH
28847: LD_INT 18
28849: PUSH
28850: LD_INT 19
28852: PUSH
28853: LD_INT 20
28855: PUSH
28856: LD_INT 21
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: LIST
28873: IN
28874: NOT
28875: OR
28876: PUSH
28877: LD_VAR 0 8
28881: PUSH
28882: LD_INT 5
28884: ARRAY
28885: NOT
28886: OR
28887: PUSH
28888: LD_VAR 0 8
28892: PUSH
28893: LD_INT 6
28895: ARRAY
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 7
28905: PUSH
28906: LD_INT 9
28908: PUSH
28909: LD_INT 10
28911: PUSH
28912: LD_INT 11
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: IN
28923: NOT
28924: OR
28925: IFFALSE 28931
// exit ;
28927: POP
28928: POP
28929: GO 29014
// end ;
28931: GO 28602
28933: POP
28934: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28935: LD_VAR 0 9
28939: PPUSH
28940: LD_VAR 0 3
28944: PPUSH
28945: LD_VAR 0 4
28949: PPUSH
28950: LD_INT 20
28952: PPUSH
28953: CALL 20966 0 4
28957: PUSH
28958: LD_INT 4
28960: ARRAY
28961: IFFALSE 28965
// exit ;
28963: GO 29014
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28965: LD_VAR 0 2
28969: PUSH
28970: LD_INT 29
28972: PUSH
28973: LD_INT 30
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: IN
28980: PUSH
28981: LD_VAR 0 3
28985: PPUSH
28986: LD_VAR 0 4
28990: PPUSH
28991: LD_VAR 0 9
28995: PPUSH
28996: CALL_OW 440
29000: NOT
29001: AND
29002: IFFALSE 29006
// exit ;
29004: GO 29014
// result := true ;
29006: LD_ADDR_VAR 0 6
29010: PUSH
29011: LD_INT 1
29013: ST_TO_ADDR
// end ;
29014: LD_VAR 0 6
29018: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29019: LD_INT 0
29021: PPUSH
29022: PPUSH
29023: PPUSH
29024: PPUSH
29025: PPUSH
29026: PPUSH
29027: PPUSH
29028: PPUSH
29029: PPUSH
29030: PPUSH
29031: PPUSH
29032: PPUSH
29033: PPUSH
29034: PPUSH
29035: PPUSH
29036: PPUSH
29037: PPUSH
29038: PPUSH
29039: PPUSH
29040: PPUSH
29041: PPUSH
29042: PPUSH
29043: PPUSH
29044: PPUSH
29045: PPUSH
29046: PPUSH
29047: PPUSH
29048: PPUSH
29049: PPUSH
29050: PPUSH
29051: PPUSH
29052: PPUSH
29053: PPUSH
29054: PPUSH
29055: PPUSH
29056: PPUSH
29057: PPUSH
29058: PPUSH
29059: PPUSH
29060: PPUSH
29061: PPUSH
29062: PPUSH
29063: PPUSH
29064: PPUSH
29065: PPUSH
29066: PPUSH
29067: PPUSH
29068: PPUSH
29069: PPUSH
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
// result = [ ] ;
29079: LD_ADDR_VAR 0 7
29083: PUSH
29084: EMPTY
29085: ST_TO_ADDR
// temp_list = [ ] ;
29086: LD_ADDR_VAR 0 9
29090: PUSH
29091: EMPTY
29092: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29093: LD_VAR 0 4
29097: PUSH
29098: LD_INT 0
29100: PUSH
29101: LD_INT 1
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: LD_INT 3
29109: PUSH
29110: LD_INT 4
29112: PUSH
29113: LD_INT 5
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: LIST
29120: LIST
29121: LIST
29122: LIST
29123: IN
29124: NOT
29125: PUSH
29126: LD_VAR 0 1
29130: PUSH
29131: LD_INT 0
29133: PUSH
29134: LD_INT 1
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: IN
29141: PUSH
29142: LD_VAR 0 5
29146: PUSH
29147: LD_INT 1
29149: PUSH
29150: LD_INT 2
29152: PUSH
29153: LD_INT 3
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: LIST
29160: IN
29161: NOT
29162: AND
29163: OR
29164: IFFALSE 29168
// exit ;
29166: GO 47559
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29168: LD_VAR 0 1
29172: PUSH
29173: LD_INT 6
29175: PUSH
29176: LD_INT 7
29178: PUSH
29179: LD_INT 8
29181: PUSH
29182: LD_INT 13
29184: PUSH
29185: LD_INT 12
29187: PUSH
29188: LD_INT 15
29190: PUSH
29191: LD_INT 11
29193: PUSH
29194: LD_INT 14
29196: PUSH
29197: LD_INT 10
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: IN
29211: IFFALSE 29221
// btype = b_lab ;
29213: LD_ADDR_VAR 0 1
29217: PUSH
29218: LD_INT 6
29220: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29221: LD_VAR 0 6
29225: PUSH
29226: LD_INT 0
29228: PUSH
29229: LD_INT 1
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: LIST
29239: IN
29240: NOT
29241: PUSH
29242: LD_VAR 0 1
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: PUSH
29253: LD_INT 2
29255: PUSH
29256: LD_INT 3
29258: PUSH
29259: LD_INT 6
29261: PUSH
29262: LD_INT 36
29264: PUSH
29265: LD_INT 4
29267: PUSH
29268: LD_INT 5
29270: PUSH
29271: LD_INT 31
29273: PUSH
29274: LD_INT 32
29276: PUSH
29277: LD_INT 33
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: IN
29293: NOT
29294: PUSH
29295: LD_VAR 0 6
29299: PUSH
29300: LD_INT 1
29302: EQUAL
29303: AND
29304: OR
29305: PUSH
29306: LD_VAR 0 1
29310: PUSH
29311: LD_INT 2
29313: PUSH
29314: LD_INT 3
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: IN
29321: NOT
29322: PUSH
29323: LD_VAR 0 6
29327: PUSH
29328: LD_INT 2
29330: EQUAL
29331: AND
29332: OR
29333: IFFALSE 29343
// mode = 0 ;
29335: LD_ADDR_VAR 0 6
29339: PUSH
29340: LD_INT 0
29342: ST_TO_ADDR
// case mode of 0 :
29343: LD_VAR 0 6
29347: PUSH
29348: LD_INT 0
29350: DOUBLE
29351: EQUAL
29352: IFTRUE 29356
29354: GO 40809
29356: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29357: LD_ADDR_VAR 0 11
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: LD_INT 0
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 1
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: PUSH
29396: LD_INT 1
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: LD_INT 1
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 1
29415: NEG
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 1
29426: NEG
29427: PUSH
29428: LD_INT 1
29430: NEG
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 1
29438: NEG
29439: PUSH
29440: LD_INT 2
29442: NEG
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 2
29453: NEG
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 1
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 1
29472: PUSH
29473: LD_INT 2
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: LD_INT 2
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 1
29492: NEG
29493: PUSH
29494: LD_INT 1
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 3
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 3
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 1
29523: NEG
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: LIST
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29550: LD_ADDR_VAR 0 12
29554: PUSH
29555: LD_INT 0
29557: PUSH
29558: LD_INT 0
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 0
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: LD_INT 0
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 1
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: LD_INT 1
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 1
29619: NEG
29620: PUSH
29621: LD_INT 1
29623: NEG
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 1
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: PUSH
29653: LD_INT 1
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 1
29662: NEG
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 2
29673: NEG
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 2
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: LD_INT 1
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: PUSH
29705: LD_INT 3
29707: NEG
29708: PUSH
29709: LD_INT 0
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 3
29718: NEG
29719: PUSH
29720: LD_INT 1
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29746: LD_ADDR_VAR 0 13
29750: PUSH
29751: LD_INT 0
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 0
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: LD_INT 0
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 1
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 1
29804: NEG
29805: PUSH
29806: LD_INT 0
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: LD_INT 1
29819: NEG
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 1
29827: NEG
29828: PUSH
29829: LD_INT 2
29831: NEG
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 2
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 2
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 1
29859: PUSH
29860: LD_INT 2
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: LD_INT 2
29869: NEG
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: LD_INT 2
29881: NEG
29882: PUSH
29883: LD_INT 2
29885: NEG
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 2
29893: NEG
29894: PUSH
29895: LD_INT 3
29897: NEG
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 3
29905: NEG
29906: PUSH
29907: LD_INT 2
29909: NEG
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 3
29917: NEG
29918: PUSH
29919: LD_INT 3
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29945: LD_ADDR_VAR 0 14
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 0
29962: PUSH
29963: LD_INT 1
29965: NEG
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: LD_INT 0
29976: PUSH
29977: EMPTY
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: LD_INT 1
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 0
29993: PUSH
29994: LD_INT 1
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 1
30003: NEG
30004: PUSH
30005: LD_INT 0
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: LD_INT 1
30018: NEG
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: LD_INT 1
30026: NEG
30027: PUSH
30028: LD_INT 2
30030: NEG
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: PUSH
30061: LD_INT 2
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: LD_INT 2
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: LD_INT 3
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 0
30103: PUSH
30104: LD_INT 3
30106: NEG
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: LD_INT 2
30117: NEG
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30141: LD_ADDR_VAR 0 15
30145: PUSH
30146: LD_INT 0
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 1
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 1
30179: PUSH
30180: LD_INT 1
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 1
30199: NEG
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: NEG
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 1
30222: PUSH
30223: LD_INT 1
30225: NEG
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 2
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 1
30253: NEG
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 2
30275: NEG
30276: PUSH
30277: LD_INT 1
30279: NEG
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 2
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 3
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 3
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30334: LD_ADDR_VAR 0 16
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: PUSH
30373: LD_INT 1
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 0
30382: PUSH
30383: LD_INT 1
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: LD_INT 0
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: LD_INT 1
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 1
30415: NEG
30416: PUSH
30417: LD_INT 2
30419: NEG
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 2
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: LD_INT 2
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 2
30457: NEG
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: LD_INT 2
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 3
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 3
30491: PUSH
30492: LD_INT 3
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: LD_INT 3
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30527: LD_ADDR_VAR 0 17
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 1
30555: PUSH
30556: LD_INT 0
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 2
30623: NEG
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 2
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: LD_INT 2
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: LD_INT 2
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: LD_INT 1
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 2
30703: NEG
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: NEG
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 2
30726: NEG
30727: PUSH
30728: LD_INT 2
30730: NEG
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30757: LD_ADDR_VAR 0 18
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 0
30774: PUSH
30775: LD_INT 1
30777: NEG
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 0
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 1
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: NEG
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: NEG
30827: PUSH
30828: LD_INT 1
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 1
30838: NEG
30839: PUSH
30840: LD_INT 2
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 0
30850: PUSH
30851: LD_INT 2
30853: NEG
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: LD_INT 1
30861: PUSH
30862: LD_INT 1
30864: NEG
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 0
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: LD_INT 1
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PUSH
30890: LD_INT 2
30892: PUSH
30893: LD_INT 2
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 1
30902: PUSH
30903: LD_INT 2
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 0
30912: PUSH
30913: LD_INT 2
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: NEG
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: NEG
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: NEG
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 2
30956: NEG
30957: PUSH
30958: LD_INT 2
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30987: LD_ADDR_VAR 0 19
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 0
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31217: LD_ADDR_VAR 0 20
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: LD_INT 1
31237: NEG
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: LD_INT 0
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 1
31255: PUSH
31256: LD_INT 1
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 1
31275: NEG
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: LD_INT 1
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: LD_INT 2
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 0
31310: PUSH
31311: LD_INT 2
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 1
31321: PUSH
31322: LD_INT 1
31324: NEG
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 2
31352: PUSH
31353: LD_INT 2
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 1
31362: PUSH
31363: LD_INT 2
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 0
31372: PUSH
31373: LD_INT 2
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: NEG
31383: PUSH
31384: LD_INT 1
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 2
31393: NEG
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 2
31416: NEG
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31447: LD_ADDR_VAR 0 21
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 0
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: NEG
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: NEG
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: LD_INT 2
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: LD_INT 1
31554: NEG
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: LD_INT 0
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 2
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: LD_INT 2
31582: PUSH
31583: LD_INT 2
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 0
31602: PUSH
31603: LD_INT 2
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: LD_INT 1
31612: NEG
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 2
31623: NEG
31624: PUSH
31625: LD_INT 0
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: NEG
31635: PUSH
31636: LD_INT 1
31638: NEG
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 2
31646: NEG
31647: PUSH
31648: LD_INT 2
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31677: LD_ADDR_VAR 0 22
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 0
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 1
31735: NEG
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 1
31758: NEG
31759: PUSH
31760: LD_INT 2
31762: NEG
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 2
31773: NEG
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: LD_INT 1
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 0
31832: PUSH
31833: LD_INT 2
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: LD_INT 1
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 2
31853: NEG
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: NEG
31865: PUSH
31866: LD_INT 1
31868: NEG
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 2
31876: NEG
31877: PUSH
31878: LD_INT 2
31880: NEG
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31907: LD_ADDR_VAR 0 23
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 0
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 1
31935: PUSH
31936: LD_INT 0
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: LD_INT 1
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 1
31965: NEG
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 1
31976: NEG
31977: PUSH
31978: LD_INT 1
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 1
31988: NEG
31989: PUSH
31990: LD_INT 2
31992: NEG
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 2
32042: PUSH
32043: LD_INT 2
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: LD_INT 2
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: LD_INT 2
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 1
32072: NEG
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: NEG
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: NEG
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 2
32106: NEG
32107: PUSH
32108: LD_INT 2
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 2
32118: NEG
32119: PUSH
32120: LD_INT 3
32122: NEG
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 1
32130: NEG
32131: PUSH
32132: LD_INT 3
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 1
32142: PUSH
32143: LD_INT 2
32145: NEG
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 2
32153: PUSH
32154: LD_INT 1
32156: NEG
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32187: LD_ADDR_VAR 0 24
32191: PUSH
32192: LD_INT 0
32194: PUSH
32195: LD_INT 0
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 0
32204: PUSH
32205: LD_INT 1
32207: NEG
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 1
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: LD_INT 1
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 1
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 2
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 2
32322: PUSH
32323: LD_INT 2
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: LD_INT 2
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 0
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 1
32352: NEG
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 2
32363: NEG
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 2
32374: NEG
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: NEG
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 3
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 3
32430: PUSH
32431: LD_INT 2
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32463: LD_ADDR_VAR 0 25
32467: PUSH
32468: LD_INT 0
32470: PUSH
32471: LD_INT 0
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 0
32480: PUSH
32481: LD_INT 1
32483: NEG
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: LD_INT 0
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: NEG
32545: PUSH
32546: LD_INT 2
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: LD_INT 2
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 2
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: PUSH
32609: LD_INT 2
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: LD_INT 2
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 1
32628: NEG
32629: PUSH
32630: LD_INT 1
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: NEG
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 1
32654: NEG
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 2
32662: NEG
32663: PUSH
32664: LD_INT 2
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 3
32674: PUSH
32675: LD_INT 1
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 3
32684: PUSH
32685: LD_INT 2
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 2
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: LD_INT 3
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32737: LD_ADDR_VAR 0 26
32741: PUSH
32742: LD_INT 0
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 1
32765: PUSH
32766: LD_INT 0
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 1
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 1
32795: NEG
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 1
32806: NEG
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 0
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: LD_INT 1
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: PUSH
32873: LD_INT 2
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: LD_INT 2
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: LD_INT 2
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 2
32913: NEG
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: LD_INT 1
32928: NEG
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 2
32936: NEG
32937: PUSH
32938: LD_INT 2
32940: NEG
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 2
32948: PUSH
32949: LD_INT 3
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 1
32958: PUSH
32959: LD_INT 3
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: LD_INT 2
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33013: LD_ADDR_VAR 0 27
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: LD_INT 0
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 1
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 1
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: LD_INT 2
33109: NEG
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: PUSH
33129: LD_INT 0
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: LD_INT 2
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: LD_INT 2
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 2
33200: NEG
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 2
33212: NEG
33213: PUSH
33214: LD_INT 2
33216: NEG
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 1
33224: NEG
33225: PUSH
33226: LD_INT 2
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 3
33246: NEG
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 3
33258: NEG
33259: PUSH
33260: LD_INT 2
33262: NEG
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33293: LD_ADDR_VAR 0 28
33297: PUSH
33298: LD_INT 0
33300: PUSH
33301: LD_INT 0
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 0
33310: PUSH
33311: LD_INT 1
33313: NEG
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: LD_INT 0
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: LD_INT 1
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: LD_INT 1
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 1
33374: NEG
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 2
33389: NEG
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 1
33400: NEG
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 2
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 2
33418: PUSH
33419: LD_INT 1
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 2
33428: PUSH
33429: LD_INT 2
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 2
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 0
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 1
33458: NEG
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 2
33469: NEG
33470: PUSH
33471: LD_INT 0
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 2
33480: NEG
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 2
33492: NEG
33493: PUSH
33494: LD_INT 2
33496: NEG
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 2
33504: NEG
33505: PUSH
33506: LD_INT 3
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 3
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 3
33528: NEG
33529: PUSH
33530: LD_INT 1
33532: NEG
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33575: LD_ADDR_VAR 0 29
33579: PUSH
33580: LD_INT 0
33582: PUSH
33583: LD_INT 0
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 0
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 1
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: NEG
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: LD_INT 1
33648: NEG
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: LD_INT 2
33660: NEG
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 0
33668: PUSH
33669: LD_INT 2
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 1
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 2
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 2
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 2
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 2
33765: NEG
33766: PUSH
33767: LD_INT 3
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 3
33788: PUSH
33789: LD_INT 1
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 3
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 2
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 3
33819: NEG
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33854: LD_ADDR_VAR 0 30
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 0
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: LD_INT 0
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: LD_INT 1
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: LD_INT 0
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: LD_INT 2
33939: NEG
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: LD_INT 2
33950: NEG
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 1
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 2
33989: PUSH
33990: LD_INT 2
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: LD_INT 1
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: NEG
34044: PUSH
34045: LD_INT 3
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: LD_INT 2
34058: NEG
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 3
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 2
34076: PUSH
34077: LD_INT 3
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 3
34097: NEG
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34132: LD_ADDR_VAR 0 31
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 1
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 2
34236: PUSH
34237: LD_INT 0
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 2
34246: PUSH
34247: LD_INT 1
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 2
34256: PUSH
34257: LD_INT 2
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 2
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 2
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 2
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 2
34309: NEG
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 2
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 3
34344: PUSH
34345: LD_INT 1
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 3
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 3
34375: NEG
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34410: LD_ADDR_VAR 0 32
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 0
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 0
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 0
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 2
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 1
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 2
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 2
34535: PUSH
34536: LD_INT 2
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 2
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: LD_INT 2
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: NEG
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: NEG
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: LD_INT 3
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 3
34622: PUSH
34623: LD_INT 2
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 2
34632: PUSH
34633: LD_INT 3
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: NEG
34643: PUSH
34644: LD_INT 1
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 3
34653: NEG
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34688: LD_ADDR_VAR 0 33
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: LD_INT 0
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 1
34769: NEG
34770: PUSH
34771: LD_INT 2
34773: NEG
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: LD_INT 0
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 2
34802: PUSH
34803: LD_INT 1
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 2
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: LD_INT 1
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: NEG
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 2
34866: NEG
34867: PUSH
34868: LD_INT 2
34870: NEG
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: LD_INT 3
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 2
34890: PUSH
34891: LD_INT 1
34893: NEG
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 3
34901: PUSH
34902: LD_INT 1
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: LD_INT 3
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: LD_INT 2
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 3
34932: NEG
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34967: LD_ADDR_VAR 0 34
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: LD_INT 2
35052: NEG
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 2
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 1
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 2
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: LD_INT 2
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 2
35123: NEG
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 2
35134: NEG
35135: PUSH
35136: LD_INT 1
35138: NEG
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 2
35146: NEG
35147: PUSH
35148: LD_INT 2
35150: NEG
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: LD_INT 3
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: LD_INT 2
35173: NEG
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 3
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: LD_INT 3
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 2
35201: NEG
35202: PUSH
35203: LD_INT 1
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 3
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35247: LD_ADDR_VAR 0 35
35251: PUSH
35252: LD_INT 0
35254: PUSH
35255: LD_INT 0
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 0
35264: PUSH
35265: LD_INT 1
35267: NEG
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: LD_INT 0
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: LD_INT 1
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: LD_INT 1
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: NEG
35317: PUSH
35318: LD_INT 1
35320: NEG
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 2
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 2
35338: NEG
35339: PUSH
35340: LD_INT 1
35342: NEG
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35359: LD_ADDR_VAR 0 36
35363: PUSH
35364: LD_INT 0
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 1
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 1
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: NEG
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 1
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: NEG
35441: PUSH
35442: LD_INT 2
35444: NEG
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 1
35452: PUSH
35453: LD_INT 2
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35471: LD_ADDR_VAR 0 37
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: LD_INT 0
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: LD_INT 1
35555: NEG
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 1
35563: NEG
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35583: LD_ADDR_VAR 0 38
35587: PUSH
35588: LD_INT 0
35590: PUSH
35591: LD_INT 0
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 1
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: NEG
35642: PUSH
35643: LD_INT 0
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: LD_INT 1
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: LIST
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35695: LD_ADDR_VAR 0 39
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 0
35712: PUSH
35713: LD_INT 1
35715: NEG
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 0
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 1
35753: NEG
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: NEG
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: NEG
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 1
35788: PUSH
35789: LD_INT 2
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35807: LD_ADDR_VAR 0 40
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: LD_INT 1
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 0
35855: PUSH
35856: LD_INT 1
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 1
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35919: LD_ADDR_VAR 0 41
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 1
35947: PUSH
35948: LD_INT 0
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 1
35957: PUSH
35958: LD_INT 1
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 1
35977: NEG
35978: PUSH
35979: LD_INT 0
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: NEG
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 2
36004: NEG
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: LD_INT 0
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 2
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: PUSH
36054: LD_INT 2
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 2
36074: NEG
36075: PUSH
36076: LD_INT 0
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 2
36085: NEG
36086: PUSH
36087: LD_INT 1
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: NEG
36098: PUSH
36099: LD_INT 2
36101: NEG
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: LD_INT 3
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: PUSH
36122: LD_INT 1
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: PUSH
36133: LD_INT 0
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 3
36152: PUSH
36153: LD_INT 2
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 3
36162: PUSH
36163: LD_INT 3
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 2
36172: PUSH
36173: LD_INT 3
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 2
36182: NEG
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 3
36193: NEG
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 3
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 3
36216: NEG
36217: PUSH
36218: LD_INT 2
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 3
36228: NEG
36229: PUSH
36230: LD_INT 3
36232: NEG
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: LIST
36246: LIST
36247: LIST
36248: LIST
36249: LIST
36250: LIST
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36269: LD_ADDR_VAR 0 42
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: NEG
36328: PUSH
36329: LD_INT 0
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: LD_INT 2
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 2
36394: PUSH
36395: LD_INT 2
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 1
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 1
36424: NEG
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: NEG
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: NEG
36448: PUSH
36449: LD_INT 2
36451: NEG
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 2
36459: NEG
36460: PUSH
36461: LD_INT 3
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 3
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: LD_INT 3
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 3
36505: PUSH
36506: LD_INT 2
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 3
36515: PUSH
36516: LD_INT 3
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 2
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: LD_INT 3
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 0
36545: PUSH
36546: LD_INT 3
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 2
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: NEG
36567: PUSH
36568: LD_INT 2
36570: NEG
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 3
36578: NEG
36579: PUSH
36580: LD_INT 3
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36619: LD_ADDR_VAR 0 43
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 0
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 0
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 1
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 0
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: LD_INT 2
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 0
36712: PUSH
36713: LD_INT 2
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: LD_INT 3
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 0
36820: PUSH
36821: LD_INT 3
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 1
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 2
36842: PUSH
36843: LD_INT 1
36845: NEG
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 3
36863: PUSH
36864: LD_INT 1
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: PUSH
36874: LD_INT 3
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 0
36883: PUSH
36884: LD_INT 3
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 1
36893: NEG
36894: PUSH
36895: LD_INT 2
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 2
36904: NEG
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 3
36926: NEG
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36967: LD_ADDR_VAR 0 44
36971: PUSH
36972: LD_INT 0
36974: PUSH
36975: LD_INT 0
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: LD_INT 1
36987: NEG
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: PUSH
37006: LD_INT 1
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 1
37025: NEG
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: NEG
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 2
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: PUSH
37082: LD_INT 1
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 2
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 1
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 2
37122: NEG
37123: PUSH
37124: LD_INT 0
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: NEG
37134: PUSH
37135: LD_INT 1
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 2
37145: NEG
37146: PUSH
37147: LD_INT 2
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 2
37157: NEG
37158: PUSH
37159: LD_INT 3
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: LD_INT 1
37172: NEG
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 3
37190: PUSH
37191: LD_INT 1
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 3
37200: PUSH
37201: LD_INT 2
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 3
37210: PUSH
37211: LD_INT 3
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 2
37220: PUSH
37221: LD_INT 3
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 2
37230: NEG
37231: PUSH
37232: LD_INT 1
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 3
37264: NEG
37265: PUSH
37266: LD_INT 2
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 3
37276: NEG
37277: PUSH
37278: LD_INT 3
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37317: LD_ADDR_VAR 0 45
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 0
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 1
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 0
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: LD_INT 1
37375: NEG
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 1
37386: NEG
37387: PUSH
37388: LD_INT 1
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: NEG
37399: PUSH
37400: LD_INT 2
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: LD_INT 2
37413: NEG
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 2
37432: PUSH
37433: LD_INT 1
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 2
37442: PUSH
37443: LD_INT 2
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 2
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 2
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 2
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: LD_INT 3
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: PUSH
37554: LD_INT 2
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: LD_INT 3
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: LD_INT 3
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: LD_INT 3
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: LD_INT 2
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 3
37614: NEG
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 3
37626: NEG
37627: PUSH
37628: LD_INT 3
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37667: LD_ADDR_VAR 0 46
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 1
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 1
37725: NEG
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: LD_INT 1
37740: NEG
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: LD_INT 2
37752: NEG
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: LD_INT 2
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 2
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 2
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: LD_INT 2
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 2
37844: NEG
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: NEG
37857: PUSH
37858: LD_INT 3
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: LD_INT 3
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: LD_INT 2
37882: NEG
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: PUSH
37891: LD_INT 1
37893: NEG
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 3
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 3
37911: PUSH
37912: LD_INT 1
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 2
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 2
37952: NEG
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 3
37963: NEG
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 3
37974: NEG
37975: PUSH
37976: LD_INT 1
37978: NEG
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38015: LD_ADDR_VAR 0 47
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: LD_INT 0
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 1
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 1
38053: PUSH
38054: LD_INT 1
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: LD_INT 1
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: LD_INT 1
38088: NEG
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 1
38096: NEG
38097: PUSH
38098: LD_INT 2
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: LD_INT 2
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: LD_INT 1
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 2
38142: NEG
38143: PUSH
38144: LD_INT 2
38146: NEG
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: LIST
38158: LIST
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: LIST
38164: LIST
38165: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38166: LD_ADDR_VAR 0 48
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: LD_INT 1
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: NEG
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: LD_INT 2
38251: NEG
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: LD_INT 2
38262: NEG
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 1
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 2
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 2
38291: PUSH
38292: LD_INT 1
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38313: LD_ADDR_VAR 0 49
38317: PUSH
38318: LD_INT 0
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 0
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 1
38341: PUSH
38342: LD_INT 0
38344: PUSH
38345: EMPTY
38346: LIST
38347: LIST
38348: PUSH
38349: LD_INT 1
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: LD_INT 1
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: LD_INT 0
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: LD_INT 1
38386: NEG
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: LD_INT 0
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: LD_INT 2
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: LD_INT 2
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: LIST
38456: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38457: LD_ADDR_VAR 0 50
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 0
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 2
38538: PUSH
38539: LD_INT 1
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 2
38548: PUSH
38549: LD_INT 2
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 2
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 1
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38601: LD_ADDR_VAR 0 51
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 0
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: LD_INT 1
38621: NEG
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 1
38629: PUSH
38630: LD_INT 0
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: PUSH
38640: LD_INT 1
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 1
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 1
38659: NEG
38660: PUSH
38661: LD_INT 0
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: LD_INT 1
38674: NEG
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 1
38682: PUSH
38683: LD_INT 2
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: LD_INT 2
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 1
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 2
38713: NEG
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: NEG
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38748: LD_ADDR_VAR 0 52
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: LD_INT 0
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 0
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: NEG
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 1
38817: NEG
38818: PUSH
38819: LD_INT 1
38821: NEG
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 1
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 2
38852: NEG
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 2
38863: NEG
38864: PUSH
38865: LD_INT 1
38867: NEG
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 2
38875: NEG
38876: PUSH
38877: LD_INT 2
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38899: LD_ADDR_VAR 0 53
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 0
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 1
38968: NEG
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: LD_INT 2
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: LD_INT 1
39006: NEG
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: LD_INT 0
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 2
39034: PUSH
39035: LD_INT 2
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: LD_INT 2
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 0
39054: PUSH
39055: LD_INT 2
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 1
39064: NEG
39065: PUSH
39066: LD_INT 1
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: LD_INT 2
39075: NEG
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 2
39086: NEG
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 2
39098: NEG
39099: PUSH
39100: LD_INT 2
39102: NEG
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39129: LD_ADDR_VAR 0 54
39133: PUSH
39134: LD_INT 0
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: LD_INT 1
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: LD_INT 1
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 1
39198: NEG
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 0
39222: PUSH
39223: LD_INT 2
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: PUSH
39234: LD_INT 1
39236: NEG
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 2
39264: PUSH
39265: LD_INT 2
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 1
39274: PUSH
39275: LD_INT 2
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 0
39284: PUSH
39285: LD_INT 2
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: NEG
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 2
39305: NEG
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 2
39316: NEG
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 2
39328: NEG
39329: PUSH
39330: LD_INT 2
39332: NEG
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39359: LD_ADDR_VAR 0 55
39363: PUSH
39364: LD_INT 0
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 0
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: PUSH
39388: LD_INT 0
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 1
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 1
39428: NEG
39429: PUSH
39430: LD_INT 1
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 1
39440: NEG
39441: PUSH
39442: LD_INT 2
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: LD_INT 2
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 0
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 2
39494: PUSH
39495: LD_INT 2
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: LD_INT 2
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: LD_INT 2
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 1
39524: NEG
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: NEG
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 2
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 2
39558: NEG
39559: PUSH
39560: LD_INT 2
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39589: LD_ADDR_VAR 0 56
39593: PUSH
39594: LD_INT 0
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 0
39606: PUSH
39607: LD_INT 1
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 0
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 1
39647: NEG
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 1
39670: NEG
39671: PUSH
39672: LD_INT 2
39674: NEG
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 2
39685: NEG
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: PUSH
39694: LD_INT 1
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 2
39724: PUSH
39725: LD_INT 2
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 1
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 0
39744: PUSH
39745: LD_INT 2
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: NEG
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 2
39765: NEG
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 2
39776: NEG
39777: PUSH
39778: LD_INT 1
39780: NEG
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 2
39788: NEG
39789: PUSH
39790: LD_INT 2
39792: NEG
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39819: LD_ADDR_VAR 0 57
39823: PUSH
39824: LD_INT 0
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 1
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: PUSH
39858: LD_INT 1
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: LD_INT 1
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 1
39900: NEG
39901: PUSH
39902: LD_INT 2
39904: NEG
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 0
39912: PUSH
39913: LD_INT 2
39915: NEG
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: LD_INT 1
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: LD_INT 0
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 2
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 2
39954: PUSH
39955: LD_INT 2
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: LD_INT 2
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: LD_INT 2
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: NEG
39985: PUSH
39986: LD_INT 1
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 2
39995: NEG
39996: PUSH
39997: LD_INT 0
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: LD_INT 2
40022: NEG
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40049: LD_ADDR_VAR 0 58
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 1
40077: PUSH
40078: LD_INT 0
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: LD_INT 1
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 0
40097: PUSH
40098: LD_INT 1
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: NEG
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 1
40130: NEG
40131: PUSH
40132: LD_INT 2
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: LD_INT 2
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 1
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: PUSH
40165: LD_INT 0
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 2
40174: PUSH
40175: LD_INT 1
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 2
40184: PUSH
40185: LD_INT 2
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: LD_INT 2
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 0
40204: PUSH
40205: LD_INT 2
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 1
40214: NEG
40215: PUSH
40216: LD_INT 1
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 2
40225: NEG
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 2
40236: NEG
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: NEG
40249: PUSH
40250: LD_INT 2
40252: NEG
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40279: LD_ADDR_VAR 0 59
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: LD_INT 0
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: LD_INT 1
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 1
40337: NEG
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: NEG
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40367: LD_ADDR_VAR 0 60
40371: PUSH
40372: LD_INT 0
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 0
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 1
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 1
40405: PUSH
40406: LD_INT 1
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 0
40415: PUSH
40416: LD_INT 1
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 1
40425: NEG
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 1
40436: NEG
40437: PUSH
40438: LD_INT 1
40440: NEG
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40455: LD_ADDR_VAR 0 61
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: LD_INT 0
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 0
40472: PUSH
40473: LD_INT 1
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 1
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 1
40513: NEG
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40543: LD_ADDR_VAR 0 62
40547: PUSH
40548: LD_INT 0
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 1
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: PUSH
40572: LD_INT 0
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 1
40581: PUSH
40582: LD_INT 1
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_INT 1
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 0
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 1
40612: NEG
40613: PUSH
40614: LD_INT 1
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40631: LD_ADDR_VAR 0 63
40635: PUSH
40636: LD_INT 0
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 0
40648: PUSH
40649: LD_INT 1
40651: NEG
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: PUSH
40660: LD_INT 0
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 1
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 1
40689: NEG
40690: PUSH
40691: LD_INT 0
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40719: LD_ADDR_VAR 0 64
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: LD_INT 0
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 1
40757: PUSH
40758: LD_INT 1
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: LD_INT 1
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: ST_TO_ADDR
// end ; 1 :
40807: GO 46704
40809: LD_INT 1
40811: DOUBLE
40812: EQUAL
40813: IFTRUE 40817
40815: GO 43440
40817: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40818: LD_ADDR_VAR 0 11
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: LD_INT 3
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 1
40848: PUSH
40849: LD_INT 2
40851: NEG
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40862: LD_ADDR_VAR 0 12
40866: PUSH
40867: LD_INT 2
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 3
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40903: LD_ADDR_VAR 0 13
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: LIST
40942: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40943: LD_ADDR_VAR 0 14
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: LD_INT 3
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 0
40960: PUSH
40961: LD_INT 3
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 1
40970: NEG
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: LIST
40983: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40984: LD_ADDR_VAR 0 15
40988: PUSH
40989: LD_INT 2
40991: NEG
40992: PUSH
40993: LD_INT 1
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: LD_INT 0
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 3
41013: NEG
41014: PUSH
41015: LD_INT 1
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: LIST
41027: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41028: LD_ADDR_VAR 0 16
41032: PUSH
41033: LD_INT 2
41035: NEG
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: NEG
41048: PUSH
41049: LD_INT 2
41051: NEG
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 3
41059: NEG
41060: PUSH
41061: LD_INT 3
41063: NEG
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41074: LD_ADDR_VAR 0 17
41078: PUSH
41079: LD_INT 1
41081: NEG
41082: PUSH
41083: LD_INT 3
41085: NEG
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 3
41096: NEG
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 1
41104: PUSH
41105: LD_INT 2
41107: NEG
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: LIST
41117: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41118: LD_ADDR_VAR 0 18
41122: PUSH
41123: LD_INT 2
41125: PUSH
41126: LD_INT 1
41128: NEG
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 0
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 3
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41159: LD_ADDR_VAR 0 19
41163: PUSH
41164: LD_INT 3
41166: PUSH
41167: LD_INT 2
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 3
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 2
41186: PUSH
41187: LD_INT 3
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: LIST
41198: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41199: LD_ADDR_VAR 0 20
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 3
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 0
41216: PUSH
41217: LD_INT 3
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 1
41226: NEG
41227: PUSH
41228: LD_INT 2
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41240: LD_ADDR_VAR 0 21
41244: PUSH
41245: LD_INT 2
41247: NEG
41248: PUSH
41249: LD_INT 1
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: LD_INT 0
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 3
41269: NEG
41270: PUSH
41271: LD_INT 1
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: LIST
41283: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41284: LD_ADDR_VAR 0 22
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 3
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 3
41303: NEG
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 3
41315: NEG
41316: PUSH
41317: LD_INT 3
41319: NEG
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41330: LD_ADDR_VAR 0 23
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 3
41340: NEG
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 1
41348: NEG
41349: PUSH
41350: LD_INT 4
41352: NEG
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: LD_INT 3
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: LIST
41373: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41374: LD_ADDR_VAR 0 24
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 0
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 3
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 4
41402: PUSH
41403: LD_INT 1
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41415: LD_ADDR_VAR 0 25
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: LD_INT 3
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 3
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: LIST
41454: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41455: LD_ADDR_VAR 0 26
41459: PUSH
41460: LD_INT 0
41462: PUSH
41463: LD_INT 3
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 1
41482: NEG
41483: PUSH
41484: LD_INT 3
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: LIST
41495: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41496: LD_ADDR_VAR 0 27
41500: PUSH
41501: LD_INT 3
41503: NEG
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: LD_INT 1
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 4
41525: NEG
41526: PUSH
41527: LD_INT 1
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: LIST
41539: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41540: LD_ADDR_VAR 0 28
41544: PUSH
41545: LD_INT 3
41547: NEG
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 3
41559: NEG
41560: PUSH
41561: LD_INT 4
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 4
41571: NEG
41572: PUSH
41573: LD_INT 3
41575: NEG
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: LIST
41585: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41586: LD_ADDR_VAR 0 29
41590: PUSH
41591: LD_INT 1
41593: NEG
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: LD_INT 3
41608: NEG
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 1
41616: PUSH
41617: LD_INT 2
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 1
41627: NEG
41628: PUSH
41629: LD_INT 4
41631: NEG
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: LD_INT 4
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: LD_INT 1
41650: PUSH
41651: LD_INT 3
41653: NEG
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 1
41661: NEG
41662: PUSH
41663: LD_INT 5
41665: NEG
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: LD_INT 5
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 1
41684: PUSH
41685: LD_INT 4
41687: NEG
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: LD_INT 6
41699: NEG
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 0
41707: PUSH
41708: LD_INT 6
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: LD_INT 5
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41741: LD_ADDR_VAR 0 30
41745: PUSH
41746: LD_INT 2
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 3
41759: PUSH
41760: LD_INT 0
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: PUSH
41767: LD_INT 3
41769: PUSH
41770: LD_INT 1
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: PUSH
41777: LD_INT 3
41779: PUSH
41780: LD_INT 1
41782: NEG
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 4
41790: PUSH
41791: LD_INT 0
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 4
41800: PUSH
41801: LD_INT 1
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 4
41810: PUSH
41811: LD_INT 1
41813: NEG
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 5
41821: PUSH
41822: LD_INT 0
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 5
41831: PUSH
41832: LD_INT 1
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 5
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 6
41852: PUSH
41853: LD_INT 0
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 6
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: LIST
41875: LIST
41876: LIST
41877: LIST
41878: LIST
41879: LIST
41880: LIST
41881: LIST
41882: LIST
41883: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41884: LD_ADDR_VAR 0 31
41888: PUSH
41889: LD_INT 3
41891: PUSH
41892: LD_INT 2
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 3
41901: PUSH
41902: LD_INT 3
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: LD_INT 3
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 4
41921: PUSH
41922: LD_INT 3
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 4
41931: PUSH
41932: LD_INT 4
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 3
41941: PUSH
41942: LD_INT 4
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 5
41951: PUSH
41952: LD_INT 4
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 5
41961: PUSH
41962: LD_INT 5
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 4
41971: PUSH
41972: LD_INT 5
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 6
41981: PUSH
41982: LD_INT 5
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 6
41991: PUSH
41992: LD_INT 6
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: LD_INT 6
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42023: LD_ADDR_VAR 0 32
42027: PUSH
42028: LD_INT 1
42030: PUSH
42031: LD_INT 3
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 0
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 1
42050: NEG
42051: PUSH
42052: LD_INT 2
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: PUSH
42062: LD_INT 4
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 0
42071: PUSH
42072: LD_INT 4
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: LD_INT 3
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: PUSH
42090: LD_INT 1
42092: PUSH
42093: LD_INT 5
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 5
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 1
42112: NEG
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: LD_INT 6
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: LD_INT 6
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 1
42143: NEG
42144: PUSH
42145: LD_INT 5
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42166: LD_ADDR_VAR 0 33
42170: PUSH
42171: LD_INT 2
42173: NEG
42174: PUSH
42175: LD_INT 1
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 3
42195: NEG
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 4
42218: NEG
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 4
42229: NEG
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: LD_INT 4
42241: NEG
42242: PUSH
42243: LD_INT 1
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: LD_INT 5
42252: NEG
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 5
42263: NEG
42264: PUSH
42265: LD_INT 1
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 5
42275: NEG
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 6
42286: NEG
42287: PUSH
42288: LD_INT 0
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 6
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42321: LD_ADDR_VAR 0 34
42325: PUSH
42326: LD_INT 2
42328: NEG
42329: PUSH
42330: LD_INT 3
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: LD_INT 2
42344: NEG
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: LD_INT 3
42356: NEG
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 3
42364: NEG
42365: PUSH
42366: LD_INT 4
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 4
42376: NEG
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: LD_INT 4
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 4
42400: NEG
42401: PUSH
42402: LD_INT 5
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 5
42412: NEG
42413: PUSH
42414: LD_INT 4
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 5
42424: NEG
42425: PUSH
42426: LD_INT 5
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 5
42436: NEG
42437: PUSH
42438: LD_INT 6
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 6
42448: NEG
42449: PUSH
42450: LD_INT 5
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 6
42460: NEG
42461: PUSH
42462: LD_INT 6
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42484: LD_ADDR_VAR 0 41
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 2
42494: NEG
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PUSH
42500: LD_INT 1
42502: NEG
42503: PUSH
42504: LD_INT 3
42506: NEG
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: LD_INT 2
42517: NEG
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: LIST
42527: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42528: LD_ADDR_VAR 0 42
42532: PUSH
42533: LD_INT 2
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 2
42545: PUSH
42546: LD_INT 1
42548: NEG
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 3
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42569: LD_ADDR_VAR 0 43
42573: PUSH
42574: LD_INT 2
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: PUSH
42587: LD_INT 2
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 2
42596: PUSH
42597: LD_INT 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: LIST
42608: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42609: LD_ADDR_VAR 0 44
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: LD_INT 2
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 1
42626: PUSH
42627: LD_INT 3
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 1
42636: NEG
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: LIST
42649: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42650: LD_ADDR_VAR 0 45
42654: PUSH
42655: LD_INT 2
42657: NEG
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: LD_INT 1
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 3
42679: NEG
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: LIST
42693: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42694: LD_ADDR_VAR 0 46
42698: PUSH
42699: LD_INT 2
42701: NEG
42702: PUSH
42703: LD_INT 2
42705: NEG
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 2
42713: NEG
42714: PUSH
42715: LD_INT 3
42717: NEG
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 3
42725: NEG
42726: PUSH
42727: LD_INT 2
42729: NEG
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: LIST
42739: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42740: LD_ADDR_VAR 0 47
42744: PUSH
42745: LD_INT 2
42747: NEG
42748: PUSH
42749: LD_INT 3
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 1
42759: NEG
42760: PUSH
42761: LD_INT 3
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42773: LD_ADDR_VAR 0 48
42777: PUSH
42778: LD_INT 1
42780: PUSH
42781: LD_INT 2
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 2
42791: PUSH
42792: LD_INT 1
42794: NEG
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42804: LD_ADDR_VAR 0 49
42808: PUSH
42809: LD_INT 3
42811: PUSH
42812: LD_INT 1
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: LD_INT 3
42821: PUSH
42822: LD_INT 2
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42833: LD_ADDR_VAR 0 50
42837: PUSH
42838: LD_INT 2
42840: PUSH
42841: LD_INT 3
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: PUSH
42848: LD_INT 1
42850: PUSH
42851: LD_INT 3
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42862: LD_ADDR_VAR 0 51
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 2
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: LD_INT 1
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42893: LD_ADDR_VAR 0 52
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: LD_INT 1
42904: NEG
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 3
42912: NEG
42913: PUSH
42914: LD_INT 2
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42926: LD_ADDR_VAR 0 53
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: LD_INT 3
42937: NEG
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: LD_INT 3
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 1
42956: PUSH
42957: LD_INT 2
42959: NEG
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: LIST
42969: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42970: LD_ADDR_VAR 0 54
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: LD_INT 1
42980: NEG
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 3
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 3
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43011: LD_ADDR_VAR 0 55
43015: PUSH
43016: LD_INT 3
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 3
43028: PUSH
43029: LD_INT 3
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 2
43038: PUSH
43039: LD_INT 3
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: LIST
43050: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43051: LD_ADDR_VAR 0 56
43055: PUSH
43056: LD_INT 1
43058: PUSH
43059: LD_INT 3
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 0
43068: PUSH
43069: LD_INT 3
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: LD_INT 2
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: LIST
43091: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43092: LD_ADDR_VAR 0 57
43096: PUSH
43097: LD_INT 2
43099: NEG
43100: PUSH
43101: LD_INT 1
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 3
43110: NEG
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 3
43121: NEG
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: LIST
43135: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43136: LD_ADDR_VAR 0 58
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 3
43155: NEG
43156: PUSH
43157: LD_INT 2
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 3
43167: NEG
43168: PUSH
43169: LD_INT 3
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43182: LD_ADDR_VAR 0 59
43186: PUSH
43187: LD_INT 1
43189: NEG
43190: PUSH
43191: LD_INT 2
43193: NEG
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 0
43201: PUSH
43202: LD_INT 2
43204: NEG
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 1
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: LIST
43225: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43226: LD_ADDR_VAR 0 60
43230: PUSH
43231: LD_INT 1
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: PUSH
43245: LD_INT 0
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 2
43254: PUSH
43255: LD_INT 1
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43267: LD_ADDR_VAR 0 61
43271: PUSH
43272: LD_INT 2
43274: PUSH
43275: LD_INT 1
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 2
43284: PUSH
43285: LD_INT 2
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: LD_INT 2
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: LIST
43306: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43307: LD_ADDR_VAR 0 62
43311: PUSH
43312: LD_INT 1
43314: PUSH
43315: LD_INT 2
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 2
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 1
43334: NEG
43335: PUSH
43336: LD_INT 1
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: LIST
43347: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43348: LD_ADDR_VAR 0 63
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 1
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 2
43377: NEG
43378: PUSH
43379: LD_INT 1
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: LIST
43391: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43392: LD_ADDR_VAR 0 64
43396: PUSH
43397: LD_INT 1
43399: NEG
43400: PUSH
43401: LD_INT 2
43403: NEG
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 2
43411: NEG
43412: PUSH
43413: LD_INT 1
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 2
43423: NEG
43424: PUSH
43425: LD_INT 2
43427: NEG
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: LIST
43437: ST_TO_ADDR
// end ; 2 :
43438: GO 46704
43440: LD_INT 2
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43448
43446: GO 46703
43448: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43449: LD_ADDR_VAR 0 29
43453: PUSH
43454: LD_INT 4
43456: PUSH
43457: LD_INT 0
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 4
43466: PUSH
43467: LD_INT 1
43469: NEG
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 5
43477: PUSH
43478: LD_INT 0
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 5
43487: PUSH
43488: LD_INT 1
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 4
43497: PUSH
43498: LD_INT 1
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 3
43507: PUSH
43508: LD_INT 0
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 3
43517: PUSH
43518: LD_INT 1
43520: NEG
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: LD_INT 2
43531: NEG
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 5
43539: PUSH
43540: LD_INT 2
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 3
43549: PUSH
43550: LD_INT 3
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 3
43559: PUSH
43560: LD_INT 2
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 4
43569: PUSH
43570: LD_INT 3
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 4
43579: PUSH
43580: LD_INT 4
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 3
43589: PUSH
43590: LD_INT 4
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 2
43599: PUSH
43600: LD_INT 3
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 2
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 4
43619: PUSH
43620: LD_INT 2
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 0
43639: PUSH
43640: LD_INT 4
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 0
43649: PUSH
43650: LD_INT 3
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 1
43659: PUSH
43660: LD_INT 4
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 1
43669: PUSH
43670: LD_INT 5
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: LD_INT 0
43679: PUSH
43680: LD_INT 5
43682: PUSH
43683: EMPTY
43684: LIST
43685: LIST
43686: PUSH
43687: LD_INT 1
43689: NEG
43690: PUSH
43691: LD_INT 4
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: LD_INT 1
43700: NEG
43701: PUSH
43702: LD_INT 3
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: LD_INT 2
43711: PUSH
43712: LD_INT 5
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 2
43721: NEG
43722: PUSH
43723: LD_INT 3
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 3
43732: NEG
43733: PUSH
43734: LD_INT 0
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 3
43743: NEG
43744: PUSH
43745: LD_INT 1
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 2
43755: NEG
43756: PUSH
43757: LD_INT 0
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 2
43766: NEG
43767: PUSH
43768: LD_INT 1
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 3
43777: NEG
43778: PUSH
43779: LD_INT 1
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 4
43788: NEG
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 4
43799: NEG
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 4
43811: NEG
43812: PUSH
43813: LD_INT 2
43815: NEG
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 2
43823: NEG
43824: PUSH
43825: LD_INT 2
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 4
43834: NEG
43835: PUSH
43836: LD_INT 4
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 4
43846: NEG
43847: PUSH
43848: LD_INT 5
43850: NEG
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 3
43858: NEG
43859: PUSH
43860: LD_INT 4
43862: NEG
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 4
43882: NEG
43883: PUSH
43884: LD_INT 3
43886: NEG
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 5
43894: NEG
43895: PUSH
43896: LD_INT 4
43898: NEG
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: NEG
43907: PUSH
43908: LD_INT 5
43910: NEG
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 3
43918: NEG
43919: PUSH
43920: LD_INT 5
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 5
43930: NEG
43931: PUSH
43932: LD_INT 3
43934: NEG
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43987: LD_ADDR_VAR 0 30
43991: PUSH
43992: LD_INT 4
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 4
44004: PUSH
44005: LD_INT 3
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 5
44014: PUSH
44015: LD_INT 4
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: LD_INT 5
44024: PUSH
44025: LD_INT 5
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: LD_INT 5
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 3
44044: PUSH
44045: LD_INT 4
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 3
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 5
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: LD_INT 5
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 0
44084: PUSH
44085: LD_INT 3
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: LD_INT 2
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 1
44114: PUSH
44115: LD_INT 4
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: LD_INT 4
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 1
44134: NEG
44135: PUSH
44136: LD_INT 3
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 1
44145: NEG
44146: PUSH
44147: LD_INT 2
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 2
44156: PUSH
44157: LD_INT 4
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 2
44166: NEG
44167: PUSH
44168: LD_INT 2
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 4
44188: NEG
44189: PUSH
44190: LD_INT 1
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 3
44211: NEG
44212: PUSH
44213: LD_INT 1
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 4
44222: NEG
44223: PUSH
44224: LD_INT 1
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 5
44233: NEG
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 5
44244: NEG
44245: PUSH
44246: LD_INT 1
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 5
44256: NEG
44257: PUSH
44258: LD_INT 2
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 3
44268: NEG
44269: PUSH
44270: LD_INT 2
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 3
44279: NEG
44280: PUSH
44281: LD_INT 3
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 3
44291: NEG
44292: PUSH
44293: LD_INT 4
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 2
44303: NEG
44304: PUSH
44305: LD_INT 3
44307: NEG
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 2
44315: NEG
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 3
44327: NEG
44328: PUSH
44329: LD_INT 2
44331: NEG
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 4
44339: NEG
44340: PUSH
44341: LD_INT 3
44343: NEG
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 4
44351: NEG
44352: PUSH
44353: LD_INT 4
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 2
44363: NEG
44364: PUSH
44365: LD_INT 4
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: NEG
44376: PUSH
44377: LD_INT 2
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: LD_INT 4
44390: NEG
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: LD_INT 5
44401: NEG
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 1
44409: PUSH
44410: LD_INT 4
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 1
44420: PUSH
44421: LD_INT 3
44423: NEG
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: LD_INT 3
44434: NEG
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 1
44442: NEG
44443: PUSH
44444: LD_INT 4
44446: NEG
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 1
44454: NEG
44455: PUSH
44456: LD_INT 5
44458: NEG
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 2
44466: PUSH
44467: LD_INT 3
44469: NEG
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 2
44477: NEG
44478: PUSH
44479: LD_INT 5
44481: NEG
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: LIST
44513: LIST
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44534: LD_ADDR_VAR 0 31
44538: PUSH
44539: LD_INT 0
44541: PUSH
44542: LD_INT 4
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 0
44551: PUSH
44552: LD_INT 3
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 1
44561: PUSH
44562: LD_INT 4
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: PUSH
44572: LD_INT 5
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: LD_INT 5
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 1
44591: NEG
44592: PUSH
44593: LD_INT 4
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 1
44602: NEG
44603: PUSH
44604: LD_INT 3
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 2
44613: PUSH
44614: LD_INT 5
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 2
44623: NEG
44624: PUSH
44625: LD_INT 3
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 3
44634: NEG
44635: PUSH
44636: LD_INT 0
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 3
44645: NEG
44646: PUSH
44647: LD_INT 1
44649: NEG
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 2
44657: NEG
44658: PUSH
44659: LD_INT 0
44661: PUSH
44662: EMPTY
44663: LIST
44664: LIST
44665: PUSH
44666: LD_INT 2
44668: NEG
44669: PUSH
44670: LD_INT 1
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 3
44679: NEG
44680: PUSH
44681: LD_INT 1
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 4
44690: NEG
44691: PUSH
44692: LD_INT 0
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 4
44713: NEG
44714: PUSH
44715: LD_INT 2
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: LD_INT 2
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 4
44736: NEG
44737: PUSH
44738: LD_INT 4
44740: NEG
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 4
44748: NEG
44749: PUSH
44750: LD_INT 5
44752: NEG
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 3
44760: NEG
44761: PUSH
44762: LD_INT 4
44764: NEG
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 3
44772: NEG
44773: PUSH
44774: LD_INT 3
44776: NEG
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 4
44784: NEG
44785: PUSH
44786: LD_INT 3
44788: NEG
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 5
44796: NEG
44797: PUSH
44798: LD_INT 4
44800: NEG
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 5
44808: NEG
44809: PUSH
44810: LD_INT 5
44812: NEG
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 3
44820: NEG
44821: PUSH
44822: LD_INT 5
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 5
44832: NEG
44833: PUSH
44834: LD_INT 3
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 0
44844: PUSH
44845: LD_INT 3
44847: NEG
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: LD_INT 4
44858: NEG
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: LD_INT 3
44869: NEG
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 1
44877: PUSH
44878: LD_INT 2
44880: NEG
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: LD_INT 2
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 1
44899: NEG
44900: PUSH
44901: LD_INT 3
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 1
44911: NEG
44912: PUSH
44913: LD_INT 4
44915: NEG
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 2
44923: PUSH
44924: LD_INT 2
44926: NEG
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 2
44934: NEG
44935: PUSH
44936: LD_INT 4
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 4
44946: PUSH
44947: LD_INT 0
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 4
44956: PUSH
44957: LD_INT 1
44959: NEG
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 5
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 5
44977: PUSH
44978: LD_INT 1
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 4
44987: PUSH
44988: LD_INT 1
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 3
44997: PUSH
44998: LD_INT 0
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 3
45007: PUSH
45008: LD_INT 1
45010: NEG
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 3
45018: PUSH
45019: LD_INT 2
45021: NEG
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 5
45029: PUSH
45030: LD_INT 2
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: LIST
45052: LIST
45053: LIST
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45084: LD_ADDR_VAR 0 32
45088: PUSH
45089: LD_INT 4
45091: NEG
45092: PUSH
45093: LD_INT 0
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: LD_INT 4
45102: NEG
45103: PUSH
45104: LD_INT 1
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 3
45114: NEG
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 3
45125: NEG
45126: PUSH
45127: LD_INT 1
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 4
45136: NEG
45137: PUSH
45138: LD_INT 1
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 5
45147: NEG
45148: PUSH
45149: LD_INT 0
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: LD_INT 1
45162: NEG
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 5
45170: NEG
45171: PUSH
45172: LD_INT 2
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 3
45182: NEG
45183: PUSH
45184: LD_INT 2
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 3
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 4
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 2
45217: NEG
45218: PUSH
45219: LD_INT 3
45221: NEG
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: NEG
45230: PUSH
45231: LD_INT 2
45233: NEG
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: NEG
45242: PUSH
45243: LD_INT 2
45245: NEG
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 4
45253: NEG
45254: PUSH
45255: LD_INT 3
45257: NEG
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 4
45265: NEG
45266: PUSH
45267: LD_INT 4
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 2
45277: NEG
45278: PUSH
45279: LD_INT 4
45281: NEG
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 4
45289: NEG
45290: PUSH
45291: LD_INT 2
45293: NEG
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 0
45301: PUSH
45302: LD_INT 4
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 0
45312: PUSH
45313: LD_INT 5
45315: NEG
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 1
45323: PUSH
45324: LD_INT 4
45326: NEG
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 1
45334: PUSH
45335: LD_INT 3
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: LD_INT 3
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: NEG
45357: PUSH
45358: LD_INT 4
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 1
45368: NEG
45369: PUSH
45370: LD_INT 5
45372: NEG
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 2
45380: PUSH
45381: LD_INT 3
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 2
45391: NEG
45392: PUSH
45393: LD_INT 5
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 3
45403: PUSH
45404: LD_INT 0
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 3
45413: PUSH
45414: LD_INT 1
45416: NEG
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 4
45424: PUSH
45425: LD_INT 0
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 4
45434: PUSH
45435: LD_INT 1
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 2
45454: PUSH
45455: LD_INT 0
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 2
45464: PUSH
45465: LD_INT 1
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 2
45475: PUSH
45476: LD_INT 2
45478: NEG
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 4
45486: PUSH
45487: LD_INT 2
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 4
45496: PUSH
45497: LD_INT 4
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 4
45506: PUSH
45507: LD_INT 3
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 5
45516: PUSH
45517: LD_INT 4
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 5
45526: PUSH
45527: LD_INT 5
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 4
45536: PUSH
45537: LD_INT 5
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PUSH
45544: LD_INT 3
45546: PUSH
45547: LD_INT 4
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: PUSH
45557: LD_INT 3
45559: PUSH
45560: EMPTY
45561: LIST
45562: LIST
45563: PUSH
45564: LD_INT 5
45566: PUSH
45567: LD_INT 3
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: LD_INT 5
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: PUSH
45584: EMPTY
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: LIST
45595: LIST
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45631: LD_ADDR_VAR 0 33
45635: PUSH
45636: LD_INT 4
45638: NEG
45639: PUSH
45640: LD_INT 4
45642: NEG
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 4
45650: NEG
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: LD_INT 3
45662: NEG
45663: PUSH
45664: LD_INT 4
45666: NEG
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 3
45674: NEG
45675: PUSH
45676: LD_INT 3
45678: NEG
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 4
45686: NEG
45687: PUSH
45688: LD_INT 3
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 5
45698: NEG
45699: PUSH
45700: LD_INT 4
45702: NEG
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PUSH
45708: LD_INT 5
45710: NEG
45711: PUSH
45712: LD_INT 5
45714: NEG
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 3
45722: NEG
45723: PUSH
45724: LD_INT 5
45726: NEG
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 5
45734: NEG
45735: PUSH
45736: LD_INT 3
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 0
45746: PUSH
45747: LD_INT 3
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 0
45757: PUSH
45758: LD_INT 4
45760: NEG
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 1
45768: PUSH
45769: LD_INT 3
45771: NEG
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 1
45779: PUSH
45780: LD_INT 2
45782: NEG
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: LD_INT 2
45793: NEG
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 1
45801: NEG
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 1
45813: NEG
45814: PUSH
45815: LD_INT 4
45817: NEG
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: PUSH
45823: LD_INT 2
45825: PUSH
45826: LD_INT 2
45828: NEG
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 2
45836: NEG
45837: PUSH
45838: LD_INT 4
45840: NEG
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 4
45848: PUSH
45849: LD_INT 0
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 4
45858: PUSH
45859: LD_INT 1
45861: NEG
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 5
45869: PUSH
45870: LD_INT 0
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: LD_INT 5
45879: PUSH
45880: LD_INT 1
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 4
45889: PUSH
45890: LD_INT 1
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 3
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 3
45909: PUSH
45910: LD_INT 1
45912: NEG
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 3
45920: PUSH
45921: LD_INT 2
45923: NEG
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 5
45931: PUSH
45932: LD_INT 2
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 3
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 3
45951: PUSH
45952: LD_INT 2
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 4
45961: PUSH
45962: LD_INT 3
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 4
45971: PUSH
45972: LD_INT 4
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: LD_INT 4
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 2
45991: PUSH
45992: LD_INT 3
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: LD_INT 2
46001: PUSH
46002: LD_INT 2
46004: PUSH
46005: EMPTY
46006: LIST
46007: LIST
46008: PUSH
46009: LD_INT 4
46011: PUSH
46012: LD_INT 2
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 2
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 0
46031: PUSH
46032: LD_INT 4
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 0
46041: PUSH
46042: LD_INT 3
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 1
46051: PUSH
46052: LD_INT 4
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 1
46061: PUSH
46062: LD_INT 5
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: LD_INT 0
46071: PUSH
46072: LD_INT 5
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 1
46081: NEG
46082: PUSH
46083: LD_INT 4
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 1
46092: NEG
46093: PUSH
46094: LD_INT 3
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 2
46103: PUSH
46104: LD_INT 5
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 2
46113: NEG
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46169: LD_ADDR_VAR 0 34
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: LD_INT 4
46179: NEG
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 0
46187: PUSH
46188: LD_INT 5
46190: NEG
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 1
46198: PUSH
46199: LD_INT 4
46201: NEG
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 1
46209: PUSH
46210: LD_INT 3
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: LD_INT 3
46223: NEG
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 1
46231: NEG
46232: PUSH
46233: LD_INT 4
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 1
46243: NEG
46244: PUSH
46245: LD_INT 5
46247: NEG
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 2
46255: PUSH
46256: LD_INT 3
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 2
46266: NEG
46267: PUSH
46268: LD_INT 5
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: LD_INT 0
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 3
46288: PUSH
46289: LD_INT 1
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: LD_INT 0
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 4
46309: PUSH
46310: LD_INT 1
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: LD_INT 1
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 2
46329: PUSH
46330: LD_INT 0
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 2
46339: PUSH
46340: LD_INT 1
46342: NEG
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 2
46350: PUSH
46351: LD_INT 2
46353: NEG
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 4
46361: PUSH
46362: LD_INT 2
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: LD_INT 4
46371: PUSH
46372: LD_INT 4
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 4
46381: PUSH
46382: LD_INT 3
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 5
46391: PUSH
46392: LD_INT 4
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: PUSH
46399: LD_INT 5
46401: PUSH
46402: LD_INT 5
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: LD_INT 5
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 3
46421: PUSH
46422: LD_INT 4
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: PUSH
46432: LD_INT 3
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: PUSH
46439: LD_INT 5
46441: PUSH
46442: LD_INT 3
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: PUSH
46449: LD_INT 3
46451: PUSH
46452: LD_INT 5
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: PUSH
46459: LD_INT 0
46461: PUSH
46462: LD_INT 3
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 0
46471: PUSH
46472: LD_INT 2
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: LD_INT 1
46481: PUSH
46482: LD_INT 3
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 1
46491: PUSH
46492: LD_INT 4
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: LD_INT 0
46501: PUSH
46502: LD_INT 4
46504: PUSH
46505: EMPTY
46506: LIST
46507: LIST
46508: PUSH
46509: LD_INT 1
46511: NEG
46512: PUSH
46513: LD_INT 3
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 1
46522: NEG
46523: PUSH
46524: LD_INT 2
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 2
46533: PUSH
46534: LD_INT 4
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 2
46543: NEG
46544: PUSH
46545: LD_INT 2
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 4
46554: NEG
46555: PUSH
46556: LD_INT 0
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PUSH
46563: LD_INT 4
46565: NEG
46566: PUSH
46567: LD_INT 1
46569: NEG
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 3
46577: NEG
46578: PUSH
46579: LD_INT 0
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 3
46588: NEG
46589: PUSH
46590: LD_INT 1
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PUSH
46597: LD_INT 4
46599: NEG
46600: PUSH
46601: LD_INT 1
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 5
46610: NEG
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: LD_INT 5
46621: NEG
46622: PUSH
46623: LD_INT 1
46625: NEG
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 5
46633: NEG
46634: PUSH
46635: LD_INT 2
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 3
46645: NEG
46646: PUSH
46647: LD_INT 2
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: ST_TO_ADDR
// end ; end ;
46701: GO 46704
46703: POP
// case btype of b_depot , b_warehouse :
46704: LD_VAR 0 1
46708: PUSH
46709: LD_INT 0
46711: DOUBLE
46712: EQUAL
46713: IFTRUE 46723
46715: LD_INT 1
46717: DOUBLE
46718: EQUAL
46719: IFTRUE 46723
46721: GO 46924
46723: POP
// case nation of nation_american :
46724: LD_VAR 0 5
46728: PUSH
46729: LD_INT 1
46731: DOUBLE
46732: EQUAL
46733: IFTRUE 46737
46735: GO 46793
46737: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46738: LD_ADDR_VAR 0 9
46742: PUSH
46743: LD_VAR 0 11
46747: PUSH
46748: LD_VAR 0 12
46752: PUSH
46753: LD_VAR 0 13
46757: PUSH
46758: LD_VAR 0 14
46762: PUSH
46763: LD_VAR 0 15
46767: PUSH
46768: LD_VAR 0 16
46772: PUSH
46773: EMPTY
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: PUSH
46781: LD_VAR 0 4
46785: PUSH
46786: LD_INT 1
46788: PLUS
46789: ARRAY
46790: ST_TO_ADDR
46791: GO 46922
46793: LD_INT 2
46795: DOUBLE
46796: EQUAL
46797: IFTRUE 46801
46799: GO 46857
46801: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46802: LD_ADDR_VAR 0 9
46806: PUSH
46807: LD_VAR 0 17
46811: PUSH
46812: LD_VAR 0 18
46816: PUSH
46817: LD_VAR 0 19
46821: PUSH
46822: LD_VAR 0 20
46826: PUSH
46827: LD_VAR 0 21
46831: PUSH
46832: LD_VAR 0 22
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: PUSH
46845: LD_VAR 0 4
46849: PUSH
46850: LD_INT 1
46852: PLUS
46853: ARRAY
46854: ST_TO_ADDR
46855: GO 46922
46857: LD_INT 3
46859: DOUBLE
46860: EQUAL
46861: IFTRUE 46865
46863: GO 46921
46865: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46866: LD_ADDR_VAR 0 9
46870: PUSH
46871: LD_VAR 0 23
46875: PUSH
46876: LD_VAR 0 24
46880: PUSH
46881: LD_VAR 0 25
46885: PUSH
46886: LD_VAR 0 26
46890: PUSH
46891: LD_VAR 0 27
46895: PUSH
46896: LD_VAR 0 28
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: PUSH
46909: LD_VAR 0 4
46913: PUSH
46914: LD_INT 1
46916: PLUS
46917: ARRAY
46918: ST_TO_ADDR
46919: GO 46922
46921: POP
46922: GO 47477
46924: LD_INT 2
46926: DOUBLE
46927: EQUAL
46928: IFTRUE 46938
46930: LD_INT 3
46932: DOUBLE
46933: EQUAL
46934: IFTRUE 46938
46936: GO 46994
46938: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46939: LD_ADDR_VAR 0 9
46943: PUSH
46944: LD_VAR 0 29
46948: PUSH
46949: LD_VAR 0 30
46953: PUSH
46954: LD_VAR 0 31
46958: PUSH
46959: LD_VAR 0 32
46963: PUSH
46964: LD_VAR 0 33
46968: PUSH
46969: LD_VAR 0 34
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: PUSH
46982: LD_VAR 0 4
46986: PUSH
46987: LD_INT 1
46989: PLUS
46990: ARRAY
46991: ST_TO_ADDR
46992: GO 47477
46994: LD_INT 16
46996: DOUBLE
46997: EQUAL
46998: IFTRUE 47056
47000: LD_INT 17
47002: DOUBLE
47003: EQUAL
47004: IFTRUE 47056
47006: LD_INT 18
47008: DOUBLE
47009: EQUAL
47010: IFTRUE 47056
47012: LD_INT 19
47014: DOUBLE
47015: EQUAL
47016: IFTRUE 47056
47018: LD_INT 22
47020: DOUBLE
47021: EQUAL
47022: IFTRUE 47056
47024: LD_INT 20
47026: DOUBLE
47027: EQUAL
47028: IFTRUE 47056
47030: LD_INT 21
47032: DOUBLE
47033: EQUAL
47034: IFTRUE 47056
47036: LD_INT 23
47038: DOUBLE
47039: EQUAL
47040: IFTRUE 47056
47042: LD_INT 24
47044: DOUBLE
47045: EQUAL
47046: IFTRUE 47056
47048: LD_INT 25
47050: DOUBLE
47051: EQUAL
47052: IFTRUE 47056
47054: GO 47112
47056: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47057: LD_ADDR_VAR 0 9
47061: PUSH
47062: LD_VAR 0 35
47066: PUSH
47067: LD_VAR 0 36
47071: PUSH
47072: LD_VAR 0 37
47076: PUSH
47077: LD_VAR 0 38
47081: PUSH
47082: LD_VAR 0 39
47086: PUSH
47087: LD_VAR 0 40
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: PUSH
47100: LD_VAR 0 4
47104: PUSH
47105: LD_INT 1
47107: PLUS
47108: ARRAY
47109: ST_TO_ADDR
47110: GO 47477
47112: LD_INT 6
47114: DOUBLE
47115: EQUAL
47116: IFTRUE 47168
47118: LD_INT 7
47120: DOUBLE
47121: EQUAL
47122: IFTRUE 47168
47124: LD_INT 8
47126: DOUBLE
47127: EQUAL
47128: IFTRUE 47168
47130: LD_INT 13
47132: DOUBLE
47133: EQUAL
47134: IFTRUE 47168
47136: LD_INT 12
47138: DOUBLE
47139: EQUAL
47140: IFTRUE 47168
47142: LD_INT 15
47144: DOUBLE
47145: EQUAL
47146: IFTRUE 47168
47148: LD_INT 11
47150: DOUBLE
47151: EQUAL
47152: IFTRUE 47168
47154: LD_INT 14
47156: DOUBLE
47157: EQUAL
47158: IFTRUE 47168
47160: LD_INT 10
47162: DOUBLE
47163: EQUAL
47164: IFTRUE 47168
47166: GO 47224
47168: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47169: LD_ADDR_VAR 0 9
47173: PUSH
47174: LD_VAR 0 41
47178: PUSH
47179: LD_VAR 0 42
47183: PUSH
47184: LD_VAR 0 43
47188: PUSH
47189: LD_VAR 0 44
47193: PUSH
47194: LD_VAR 0 45
47198: PUSH
47199: LD_VAR 0 46
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: PUSH
47212: LD_VAR 0 4
47216: PUSH
47217: LD_INT 1
47219: PLUS
47220: ARRAY
47221: ST_TO_ADDR
47222: GO 47477
47224: LD_INT 36
47226: DOUBLE
47227: EQUAL
47228: IFTRUE 47232
47230: GO 47288
47232: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47233: LD_ADDR_VAR 0 9
47237: PUSH
47238: LD_VAR 0 47
47242: PUSH
47243: LD_VAR 0 48
47247: PUSH
47248: LD_VAR 0 49
47252: PUSH
47253: LD_VAR 0 50
47257: PUSH
47258: LD_VAR 0 51
47262: PUSH
47263: LD_VAR 0 52
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: PUSH
47276: LD_VAR 0 4
47280: PUSH
47281: LD_INT 1
47283: PLUS
47284: ARRAY
47285: ST_TO_ADDR
47286: GO 47477
47288: LD_INT 4
47290: DOUBLE
47291: EQUAL
47292: IFTRUE 47314
47294: LD_INT 5
47296: DOUBLE
47297: EQUAL
47298: IFTRUE 47314
47300: LD_INT 34
47302: DOUBLE
47303: EQUAL
47304: IFTRUE 47314
47306: LD_INT 37
47308: DOUBLE
47309: EQUAL
47310: IFTRUE 47314
47312: GO 47370
47314: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47315: LD_ADDR_VAR 0 9
47319: PUSH
47320: LD_VAR 0 53
47324: PUSH
47325: LD_VAR 0 54
47329: PUSH
47330: LD_VAR 0 55
47334: PUSH
47335: LD_VAR 0 56
47339: PUSH
47340: LD_VAR 0 57
47344: PUSH
47345: LD_VAR 0 58
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: PUSH
47358: LD_VAR 0 4
47362: PUSH
47363: LD_INT 1
47365: PLUS
47366: ARRAY
47367: ST_TO_ADDR
47368: GO 47477
47370: LD_INT 31
47372: DOUBLE
47373: EQUAL
47374: IFTRUE 47420
47376: LD_INT 32
47378: DOUBLE
47379: EQUAL
47380: IFTRUE 47420
47382: LD_INT 33
47384: DOUBLE
47385: EQUAL
47386: IFTRUE 47420
47388: LD_INT 27
47390: DOUBLE
47391: EQUAL
47392: IFTRUE 47420
47394: LD_INT 26
47396: DOUBLE
47397: EQUAL
47398: IFTRUE 47420
47400: LD_INT 28
47402: DOUBLE
47403: EQUAL
47404: IFTRUE 47420
47406: LD_INT 29
47408: DOUBLE
47409: EQUAL
47410: IFTRUE 47420
47412: LD_INT 30
47414: DOUBLE
47415: EQUAL
47416: IFTRUE 47420
47418: GO 47476
47420: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47421: LD_ADDR_VAR 0 9
47425: PUSH
47426: LD_VAR 0 59
47430: PUSH
47431: LD_VAR 0 60
47435: PUSH
47436: LD_VAR 0 61
47440: PUSH
47441: LD_VAR 0 62
47445: PUSH
47446: LD_VAR 0 63
47450: PUSH
47451: LD_VAR 0 64
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: PUSH
47464: LD_VAR 0 4
47468: PUSH
47469: LD_INT 1
47471: PLUS
47472: ARRAY
47473: ST_TO_ADDR
47474: GO 47477
47476: POP
// temp_list2 = [ ] ;
47477: LD_ADDR_VAR 0 10
47481: PUSH
47482: EMPTY
47483: ST_TO_ADDR
// for i in temp_list do
47484: LD_ADDR_VAR 0 8
47488: PUSH
47489: LD_VAR 0 9
47493: PUSH
47494: FOR_IN
47495: IFFALSE 47547
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47497: LD_ADDR_VAR 0 10
47501: PUSH
47502: LD_VAR 0 10
47506: PUSH
47507: LD_VAR 0 8
47511: PUSH
47512: LD_INT 1
47514: ARRAY
47515: PUSH
47516: LD_VAR 0 2
47520: PLUS
47521: PUSH
47522: LD_VAR 0 8
47526: PUSH
47527: LD_INT 2
47529: ARRAY
47530: PUSH
47531: LD_VAR 0 3
47535: PLUS
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: EMPTY
47542: LIST
47543: ADD
47544: ST_TO_ADDR
47545: GO 47494
47547: POP
47548: POP
// result = temp_list2 ;
47549: LD_ADDR_VAR 0 7
47553: PUSH
47554: LD_VAR 0 10
47558: ST_TO_ADDR
// end ;
47559: LD_VAR 0 7
47563: RET
// export function EnemyInRange ( unit , dist ) ; begin
47564: LD_INT 0
47566: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47567: LD_ADDR_VAR 0 3
47571: PUSH
47572: LD_VAR 0 1
47576: PPUSH
47577: CALL_OW 255
47581: PPUSH
47582: LD_VAR 0 1
47586: PPUSH
47587: CALL_OW 250
47591: PPUSH
47592: LD_VAR 0 1
47596: PPUSH
47597: CALL_OW 251
47601: PPUSH
47602: LD_VAR 0 2
47606: PPUSH
47607: CALL 20966 0 4
47611: PUSH
47612: LD_INT 4
47614: ARRAY
47615: ST_TO_ADDR
// end ;
47616: LD_VAR 0 3
47620: RET
// export function PlayerSeeMe ( unit ) ; begin
47621: LD_INT 0
47623: PPUSH
// result := See ( your_side , unit ) ;
47624: LD_ADDR_VAR 0 2
47628: PUSH
47629: LD_OWVAR 2
47633: PPUSH
47634: LD_VAR 0 1
47638: PPUSH
47639: CALL_OW 292
47643: ST_TO_ADDR
// end ;
47644: LD_VAR 0 2
47648: RET
// export function ReverseDir ( unit ) ; begin
47649: LD_INT 0
47651: PPUSH
// if not unit then
47652: LD_VAR 0 1
47656: NOT
47657: IFFALSE 47661
// exit ;
47659: GO 47684
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47661: LD_ADDR_VAR 0 2
47665: PUSH
47666: LD_VAR 0 1
47670: PPUSH
47671: CALL_OW 254
47675: PUSH
47676: LD_INT 3
47678: PLUS
47679: PUSH
47680: LD_INT 6
47682: MOD
47683: ST_TO_ADDR
// end ;
47684: LD_VAR 0 2
47688: RET
// export function ReverseArray ( array ) ; var i ; begin
47689: LD_INT 0
47691: PPUSH
47692: PPUSH
// if not array then
47693: LD_VAR 0 1
47697: NOT
47698: IFFALSE 47702
// exit ;
47700: GO 47757
// result := [ ] ;
47702: LD_ADDR_VAR 0 2
47706: PUSH
47707: EMPTY
47708: ST_TO_ADDR
// for i := array downto 1 do
47709: LD_ADDR_VAR 0 3
47713: PUSH
47714: DOUBLE
47715: LD_VAR 0 1
47719: INC
47720: ST_TO_ADDR
47721: LD_INT 1
47723: PUSH
47724: FOR_DOWNTO
47725: IFFALSE 47755
// result := Join ( result , array [ i ] ) ;
47727: LD_ADDR_VAR 0 2
47731: PUSH
47732: LD_VAR 0 2
47736: PPUSH
47737: LD_VAR 0 1
47741: PUSH
47742: LD_VAR 0 3
47746: ARRAY
47747: PPUSH
47748: CALL 52401 0 2
47752: ST_TO_ADDR
47753: GO 47724
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
// if not unit or not hexes then
47770: LD_VAR 0 1
47774: NOT
47775: PUSH
47776: LD_VAR 0 2
47780: NOT
47781: OR
47782: IFFALSE 47786
// exit ;
47784: GO 47909
// dist := 9999 ;
47786: LD_ADDR_VAR 0 5
47790: PUSH
47791: LD_INT 9999
47793: ST_TO_ADDR
// for i = 1 to hexes do
47794: LD_ADDR_VAR 0 4
47798: PUSH
47799: DOUBLE
47800: LD_INT 1
47802: DEC
47803: ST_TO_ADDR
47804: LD_VAR 0 2
47808: PUSH
47809: FOR_TO
47810: IFFALSE 47897
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47812: LD_ADDR_VAR 0 6
47816: PUSH
47817: LD_VAR 0 1
47821: PPUSH
47822: LD_VAR 0 2
47826: PUSH
47827: LD_VAR 0 4
47831: ARRAY
47832: PUSH
47833: LD_INT 1
47835: ARRAY
47836: PPUSH
47837: LD_VAR 0 2
47841: PUSH
47842: LD_VAR 0 4
47846: ARRAY
47847: PUSH
47848: LD_INT 2
47850: ARRAY
47851: PPUSH
47852: CALL_OW 297
47856: ST_TO_ADDR
// if tdist < dist then
47857: LD_VAR 0 6
47861: PUSH
47862: LD_VAR 0 5
47866: LESS
47867: IFFALSE 47895
// begin hex := hexes [ i ] ;
47869: LD_ADDR_VAR 0 8
47873: PUSH
47874: LD_VAR 0 2
47878: PUSH
47879: LD_VAR 0 4
47883: ARRAY
47884: ST_TO_ADDR
// dist := tdist ;
47885: LD_ADDR_VAR 0 5
47889: PUSH
47890: LD_VAR 0 6
47894: ST_TO_ADDR
// end ; end ;
47895: GO 47809
47897: POP
47898: POP
// result := hex ;
47899: LD_ADDR_VAR 0 3
47903: PUSH
47904: LD_VAR 0 8
47908: ST_TO_ADDR
// end ;
47909: LD_VAR 0 3
47913: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47914: LD_INT 0
47916: PPUSH
47917: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47918: LD_VAR 0 1
47922: NOT
47923: PUSH
47924: LD_VAR 0 1
47928: PUSH
47929: LD_INT 21
47931: PUSH
47932: LD_INT 2
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: PUSH
47939: LD_INT 23
47941: PUSH
47942: LD_INT 2
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PPUSH
47953: CALL_OW 69
47957: IN
47958: NOT
47959: OR
47960: IFFALSE 47964
// exit ;
47962: GO 48011
// for i = 1 to 3 do
47964: LD_ADDR_VAR 0 3
47968: PUSH
47969: DOUBLE
47970: LD_INT 1
47972: DEC
47973: ST_TO_ADDR
47974: LD_INT 3
47976: PUSH
47977: FOR_TO
47978: IFFALSE 48009
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47980: LD_VAR 0 1
47984: PPUSH
47985: CALL_OW 250
47989: PPUSH
47990: LD_VAR 0 1
47994: PPUSH
47995: CALL_OW 251
47999: PPUSH
48000: LD_INT 1
48002: PPUSH
48003: CALL_OW 453
48007: GO 47977
48009: POP
48010: POP
// end ;
48011: LD_VAR 0 2
48015: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48016: LD_INT 0
48018: PPUSH
48019: PPUSH
48020: PPUSH
48021: PPUSH
48022: PPUSH
48023: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48024: LD_VAR 0 1
48028: NOT
48029: PUSH
48030: LD_VAR 0 2
48034: NOT
48035: OR
48036: PUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: CALL_OW 314
48046: OR
48047: IFFALSE 48051
// exit ;
48049: GO 48518
// if GetLives ( i ) < 250 then
48051: LD_VAR 0 4
48055: PPUSH
48056: CALL_OW 256
48060: PUSH
48061: LD_INT 250
48063: LESS
48064: IFFALSE 48077
// begin ComAutodestruct ( i ) ;
48066: LD_VAR 0 4
48070: PPUSH
48071: CALL 47914 0 1
// exit ;
48075: GO 48518
// end ; x := GetX ( enemy_unit ) ;
48077: LD_ADDR_VAR 0 7
48081: PUSH
48082: LD_VAR 0 2
48086: PPUSH
48087: CALL_OW 250
48091: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48092: LD_ADDR_VAR 0 8
48096: PUSH
48097: LD_VAR 0 2
48101: PPUSH
48102: CALL_OW 251
48106: ST_TO_ADDR
// if not x or not y then
48107: LD_VAR 0 7
48111: NOT
48112: PUSH
48113: LD_VAR 0 8
48117: NOT
48118: OR
48119: IFFALSE 48123
// exit ;
48121: GO 48518
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48123: LD_ADDR_VAR 0 6
48127: PUSH
48128: LD_VAR 0 7
48132: PPUSH
48133: LD_INT 0
48135: PPUSH
48136: LD_INT 4
48138: PPUSH
48139: CALL_OW 272
48143: PUSH
48144: LD_VAR 0 8
48148: PPUSH
48149: LD_INT 0
48151: PPUSH
48152: LD_INT 4
48154: PPUSH
48155: CALL_OW 273
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_VAR 0 7
48168: PPUSH
48169: LD_INT 1
48171: PPUSH
48172: LD_INT 4
48174: PPUSH
48175: CALL_OW 272
48179: PUSH
48180: LD_VAR 0 8
48184: PPUSH
48185: LD_INT 1
48187: PPUSH
48188: LD_INT 4
48190: PPUSH
48191: CALL_OW 273
48195: PUSH
48196: EMPTY
48197: LIST
48198: LIST
48199: PUSH
48200: LD_VAR 0 7
48204: PPUSH
48205: LD_INT 2
48207: PPUSH
48208: LD_INT 4
48210: PPUSH
48211: CALL_OW 272
48215: PUSH
48216: LD_VAR 0 8
48220: PPUSH
48221: LD_INT 2
48223: PPUSH
48224: LD_INT 4
48226: PPUSH
48227: CALL_OW 273
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_VAR 0 7
48240: PPUSH
48241: LD_INT 3
48243: PPUSH
48244: LD_INT 4
48246: PPUSH
48247: CALL_OW 272
48251: PUSH
48252: LD_VAR 0 8
48256: PPUSH
48257: LD_INT 3
48259: PPUSH
48260: LD_INT 4
48262: PPUSH
48263: CALL_OW 273
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: PUSH
48272: LD_VAR 0 7
48276: PPUSH
48277: LD_INT 4
48279: PPUSH
48280: LD_INT 4
48282: PPUSH
48283: CALL_OW 272
48287: PUSH
48288: LD_VAR 0 8
48292: PPUSH
48293: LD_INT 4
48295: PPUSH
48296: LD_INT 4
48298: PPUSH
48299: CALL_OW 273
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: PUSH
48308: LD_VAR 0 7
48312: PPUSH
48313: LD_INT 5
48315: PPUSH
48316: LD_INT 4
48318: PPUSH
48319: CALL_OW 272
48323: PUSH
48324: LD_VAR 0 8
48328: PPUSH
48329: LD_INT 5
48331: PPUSH
48332: LD_INT 4
48334: PPUSH
48335: CALL_OW 273
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: EMPTY
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: LIST
48350: LIST
48351: ST_TO_ADDR
// for i = tmp downto 1 do
48352: LD_ADDR_VAR 0 4
48356: PUSH
48357: DOUBLE
48358: LD_VAR 0 6
48362: INC
48363: ST_TO_ADDR
48364: LD_INT 1
48366: PUSH
48367: FOR_DOWNTO
48368: IFFALSE 48469
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48370: LD_VAR 0 6
48374: PUSH
48375: LD_VAR 0 4
48379: ARRAY
48380: PUSH
48381: LD_INT 1
48383: ARRAY
48384: PPUSH
48385: LD_VAR 0 6
48389: PUSH
48390: LD_VAR 0 4
48394: ARRAY
48395: PUSH
48396: LD_INT 2
48398: ARRAY
48399: PPUSH
48400: CALL_OW 488
48404: NOT
48405: PUSH
48406: LD_VAR 0 6
48410: PUSH
48411: LD_VAR 0 4
48415: ARRAY
48416: PUSH
48417: LD_INT 1
48419: ARRAY
48420: PPUSH
48421: LD_VAR 0 6
48425: PUSH
48426: LD_VAR 0 4
48430: ARRAY
48431: PUSH
48432: LD_INT 2
48434: ARRAY
48435: PPUSH
48436: CALL_OW 428
48440: PUSH
48441: LD_INT 0
48443: NONEQUAL
48444: OR
48445: IFFALSE 48467
// tmp := Delete ( tmp , i ) ;
48447: LD_ADDR_VAR 0 6
48451: PUSH
48452: LD_VAR 0 6
48456: PPUSH
48457: LD_VAR 0 4
48461: PPUSH
48462: CALL_OW 3
48466: ST_TO_ADDR
48467: GO 48367
48469: POP
48470: POP
// j := GetClosestHex ( unit , tmp ) ;
48471: LD_ADDR_VAR 0 5
48475: PUSH
48476: LD_VAR 0 1
48480: PPUSH
48481: LD_VAR 0 6
48485: PPUSH
48486: CALL 47762 0 2
48490: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48491: LD_VAR 0 1
48495: PPUSH
48496: LD_VAR 0 5
48500: PUSH
48501: LD_INT 1
48503: ARRAY
48504: PPUSH
48505: LD_VAR 0 5
48509: PUSH
48510: LD_INT 2
48512: ARRAY
48513: PPUSH
48514: CALL_OW 111
// end ;
48518: LD_VAR 0 3
48522: RET
// export function PrepareApemanSoldier ( ) ; begin
48523: LD_INT 0
48525: PPUSH
// uc_nation := 0 ;
48526: LD_ADDR_OWVAR 21
48530: PUSH
48531: LD_INT 0
48533: ST_TO_ADDR
// hc_sex := sex_male ;
48534: LD_ADDR_OWVAR 27
48538: PUSH
48539: LD_INT 1
48541: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48542: LD_ADDR_OWVAR 28
48546: PUSH
48547: LD_INT 15
48549: ST_TO_ADDR
// hc_gallery :=  ;
48550: LD_ADDR_OWVAR 33
48554: PUSH
48555: LD_STRING 
48557: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48558: LD_ADDR_OWVAR 31
48562: PUSH
48563: LD_INT 0
48565: PPUSH
48566: LD_INT 3
48568: PPUSH
48569: CALL_OW 12
48573: PUSH
48574: LD_INT 0
48576: PPUSH
48577: LD_INT 3
48579: PPUSH
48580: CALL_OW 12
48584: PUSH
48585: LD_INT 0
48587: PUSH
48588: LD_INT 0
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: LIST
48595: LIST
48596: ST_TO_ADDR
// end ;
48597: LD_VAR 0 1
48601: RET
// export function PrepareApemanEngineer ( ) ; begin
48602: LD_INT 0
48604: PPUSH
// uc_nation := 0 ;
48605: LD_ADDR_OWVAR 21
48609: PUSH
48610: LD_INT 0
48612: ST_TO_ADDR
// hc_sex := sex_male ;
48613: LD_ADDR_OWVAR 27
48617: PUSH
48618: LD_INT 1
48620: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48621: LD_ADDR_OWVAR 28
48625: PUSH
48626: LD_INT 16
48628: ST_TO_ADDR
// hc_gallery :=  ;
48629: LD_ADDR_OWVAR 33
48633: PUSH
48634: LD_STRING 
48636: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48637: LD_ADDR_OWVAR 31
48641: PUSH
48642: LD_INT 0
48644: PPUSH
48645: LD_INT 3
48647: PPUSH
48648: CALL_OW 12
48652: PUSH
48653: LD_INT 0
48655: PPUSH
48656: LD_INT 3
48658: PPUSH
48659: CALL_OW 12
48663: PUSH
48664: LD_INT 0
48666: PUSH
48667: LD_INT 0
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: ST_TO_ADDR
// end ;
48676: LD_VAR 0 1
48680: RET
// export function PrepareApeman ( agressivity ) ; begin
48681: LD_INT 0
48683: PPUSH
// uc_side := 0 ;
48684: LD_ADDR_OWVAR 20
48688: PUSH
48689: LD_INT 0
48691: ST_TO_ADDR
// uc_nation := 0 ;
48692: LD_ADDR_OWVAR 21
48696: PUSH
48697: LD_INT 0
48699: ST_TO_ADDR
// hc_sex := sex_male ;
48700: LD_ADDR_OWVAR 27
48704: PUSH
48705: LD_INT 1
48707: ST_TO_ADDR
// hc_class := class_apeman ;
48708: LD_ADDR_OWVAR 28
48712: PUSH
48713: LD_INT 12
48715: ST_TO_ADDR
// hc_gallery :=  ;
48716: LD_ADDR_OWVAR 33
48720: PUSH
48721: LD_STRING 
48723: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48724: LD_ADDR_OWVAR 35
48728: PUSH
48729: LD_VAR 0 1
48733: NEG
48734: PPUSH
48735: LD_VAR 0 1
48739: PPUSH
48740: CALL_OW 12
48744: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48745: LD_ADDR_OWVAR 31
48749: PUSH
48750: LD_INT 0
48752: PPUSH
48753: LD_INT 3
48755: PPUSH
48756: CALL_OW 12
48760: PUSH
48761: LD_INT 0
48763: PPUSH
48764: LD_INT 3
48766: PPUSH
48767: CALL_OW 12
48771: PUSH
48772: LD_INT 0
48774: PUSH
48775: LD_INT 0
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: ST_TO_ADDR
// end ;
48784: LD_VAR 0 2
48788: RET
// export function PrepareTiger ( agressivity ) ; begin
48789: LD_INT 0
48791: PPUSH
// uc_side := 0 ;
48792: LD_ADDR_OWVAR 20
48796: PUSH
48797: LD_INT 0
48799: ST_TO_ADDR
// uc_nation := 0 ;
48800: LD_ADDR_OWVAR 21
48804: PUSH
48805: LD_INT 0
48807: ST_TO_ADDR
// hc_class := class_tiger ;
48808: LD_ADDR_OWVAR 28
48812: PUSH
48813: LD_INT 14
48815: ST_TO_ADDR
// hc_gallery :=  ;
48816: LD_ADDR_OWVAR 33
48820: PUSH
48821: LD_STRING 
48823: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48824: LD_ADDR_OWVAR 35
48828: PUSH
48829: LD_VAR 0 1
48833: NEG
48834: PPUSH
48835: LD_VAR 0 1
48839: PPUSH
48840: CALL_OW 12
48844: ST_TO_ADDR
// end ;
48845: LD_VAR 0 2
48849: RET
// export function PrepareEnchidna ( ) ; begin
48850: LD_INT 0
48852: PPUSH
// uc_side := 0 ;
48853: LD_ADDR_OWVAR 20
48857: PUSH
48858: LD_INT 0
48860: ST_TO_ADDR
// uc_nation := 0 ;
48861: LD_ADDR_OWVAR 21
48865: PUSH
48866: LD_INT 0
48868: ST_TO_ADDR
// hc_class := class_baggie ;
48869: LD_ADDR_OWVAR 28
48873: PUSH
48874: LD_INT 13
48876: ST_TO_ADDR
// hc_gallery :=  ;
48877: LD_ADDR_OWVAR 33
48881: PUSH
48882: LD_STRING 
48884: ST_TO_ADDR
// end ;
48885: LD_VAR 0 1
48889: RET
// export function PrepareFrog ( ) ; begin
48890: LD_INT 0
48892: PPUSH
// uc_side := 0 ;
48893: LD_ADDR_OWVAR 20
48897: PUSH
48898: LD_INT 0
48900: ST_TO_ADDR
// uc_nation := 0 ;
48901: LD_ADDR_OWVAR 21
48905: PUSH
48906: LD_INT 0
48908: ST_TO_ADDR
// hc_class := class_frog ;
48909: LD_ADDR_OWVAR 28
48913: PUSH
48914: LD_INT 19
48916: ST_TO_ADDR
// hc_gallery :=  ;
48917: LD_ADDR_OWVAR 33
48921: PUSH
48922: LD_STRING 
48924: ST_TO_ADDR
// end ;
48925: LD_VAR 0 1
48929: RET
// export function PrepareFish ( ) ; begin
48930: LD_INT 0
48932: PPUSH
// uc_side := 0 ;
48933: LD_ADDR_OWVAR 20
48937: PUSH
48938: LD_INT 0
48940: ST_TO_ADDR
// uc_nation := 0 ;
48941: LD_ADDR_OWVAR 21
48945: PUSH
48946: LD_INT 0
48948: ST_TO_ADDR
// hc_class := class_fish ;
48949: LD_ADDR_OWVAR 28
48953: PUSH
48954: LD_INT 20
48956: ST_TO_ADDR
// hc_gallery :=  ;
48957: LD_ADDR_OWVAR 33
48961: PUSH
48962: LD_STRING 
48964: ST_TO_ADDR
// end ;
48965: LD_VAR 0 1
48969: RET
// export function PrepareBird ( ) ; begin
48970: LD_INT 0
48972: PPUSH
// uc_side := 0 ;
48973: LD_ADDR_OWVAR 20
48977: PUSH
48978: LD_INT 0
48980: ST_TO_ADDR
// uc_nation := 0 ;
48981: LD_ADDR_OWVAR 21
48985: PUSH
48986: LD_INT 0
48988: ST_TO_ADDR
// hc_class := class_phororhacos ;
48989: LD_ADDR_OWVAR 28
48993: PUSH
48994: LD_INT 18
48996: ST_TO_ADDR
// hc_gallery :=  ;
48997: LD_ADDR_OWVAR 33
49001: PUSH
49002: LD_STRING 
49004: ST_TO_ADDR
// end ;
49005: LD_VAR 0 1
49009: RET
// export function PrepareHorse ( ) ; begin
49010: LD_INT 0
49012: PPUSH
// uc_side := 0 ;
49013: LD_ADDR_OWVAR 20
49017: PUSH
49018: LD_INT 0
49020: ST_TO_ADDR
// uc_nation := 0 ;
49021: LD_ADDR_OWVAR 21
49025: PUSH
49026: LD_INT 0
49028: ST_TO_ADDR
// hc_class := class_horse ;
49029: LD_ADDR_OWVAR 28
49033: PUSH
49034: LD_INT 21
49036: ST_TO_ADDR
// hc_gallery :=  ;
49037: LD_ADDR_OWVAR 33
49041: PUSH
49042: LD_STRING 
49044: ST_TO_ADDR
// end ;
49045: LD_VAR 0 1
49049: RET
// export function PrepareMastodont ( ) ; begin
49050: LD_INT 0
49052: PPUSH
// uc_side := 0 ;
49053: LD_ADDR_OWVAR 20
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// uc_nation := 0 ;
49061: LD_ADDR_OWVAR 21
49065: PUSH
49066: LD_INT 0
49068: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49069: LD_ADDR_OWVAR 37
49073: PUSH
49074: LD_INT 31
49076: ST_TO_ADDR
// vc_control := control_rider ;
49077: LD_ADDR_OWVAR 38
49081: PUSH
49082: LD_INT 4
49084: ST_TO_ADDR
// end ;
49085: LD_VAR 0 1
49089: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49090: LD_INT 0
49092: PPUSH
49093: PPUSH
49094: PPUSH
// uc_side = 0 ;
49095: LD_ADDR_OWVAR 20
49099: PUSH
49100: LD_INT 0
49102: ST_TO_ADDR
// uc_nation = 0 ;
49103: LD_ADDR_OWVAR 21
49107: PUSH
49108: LD_INT 0
49110: ST_TO_ADDR
// InitHc_All ( ) ;
49111: CALL_OW 584
// InitVc ;
49115: CALL_OW 20
// if mastodonts then
49119: LD_VAR 0 6
49123: IFFALSE 49190
// for i = 1 to mastodonts do
49125: LD_ADDR_VAR 0 11
49129: PUSH
49130: DOUBLE
49131: LD_INT 1
49133: DEC
49134: ST_TO_ADDR
49135: LD_VAR 0 6
49139: PUSH
49140: FOR_TO
49141: IFFALSE 49188
// begin vc_chassis := 31 ;
49143: LD_ADDR_OWVAR 37
49147: PUSH
49148: LD_INT 31
49150: ST_TO_ADDR
// vc_control := control_rider ;
49151: LD_ADDR_OWVAR 38
49155: PUSH
49156: LD_INT 4
49158: ST_TO_ADDR
// animal := CreateVehicle ;
49159: LD_ADDR_VAR 0 12
49163: PUSH
49164: CALL_OW 45
49168: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49169: LD_VAR 0 12
49173: PPUSH
49174: LD_VAR 0 8
49178: PPUSH
49179: LD_INT 0
49181: PPUSH
49182: CALL 51318 0 3
// end ;
49186: GO 49140
49188: POP
49189: POP
// if horses then
49190: LD_VAR 0 5
49194: IFFALSE 49261
// for i = 1 to horses do
49196: LD_ADDR_VAR 0 11
49200: PUSH
49201: DOUBLE
49202: LD_INT 1
49204: DEC
49205: ST_TO_ADDR
49206: LD_VAR 0 5
49210: PUSH
49211: FOR_TO
49212: IFFALSE 49259
// begin hc_class := 21 ;
49214: LD_ADDR_OWVAR 28
49218: PUSH
49219: LD_INT 21
49221: ST_TO_ADDR
// hc_gallery :=  ;
49222: LD_ADDR_OWVAR 33
49226: PUSH
49227: LD_STRING 
49229: ST_TO_ADDR
// animal := CreateHuman ;
49230: LD_ADDR_VAR 0 12
49234: PUSH
49235: CALL_OW 44
49239: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49240: LD_VAR 0 12
49244: PPUSH
49245: LD_VAR 0 8
49249: PPUSH
49250: LD_INT 0
49252: PPUSH
49253: CALL 51318 0 3
// end ;
49257: GO 49211
49259: POP
49260: POP
// if birds then
49261: LD_VAR 0 1
49265: IFFALSE 49332
// for i = 1 to birds do
49267: LD_ADDR_VAR 0 11
49271: PUSH
49272: DOUBLE
49273: LD_INT 1
49275: DEC
49276: ST_TO_ADDR
49277: LD_VAR 0 1
49281: PUSH
49282: FOR_TO
49283: IFFALSE 49330
// begin hc_class = 18 ;
49285: LD_ADDR_OWVAR 28
49289: PUSH
49290: LD_INT 18
49292: ST_TO_ADDR
// hc_gallery =  ;
49293: LD_ADDR_OWVAR 33
49297: PUSH
49298: LD_STRING 
49300: ST_TO_ADDR
// animal := CreateHuman ;
49301: LD_ADDR_VAR 0 12
49305: PUSH
49306: CALL_OW 44
49310: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49311: LD_VAR 0 12
49315: PPUSH
49316: LD_VAR 0 8
49320: PPUSH
49321: LD_INT 0
49323: PPUSH
49324: CALL 51318 0 3
// end ;
49328: GO 49282
49330: POP
49331: POP
// if tigers then
49332: LD_VAR 0 2
49336: IFFALSE 49420
// for i = 1 to tigers do
49338: LD_ADDR_VAR 0 11
49342: PUSH
49343: DOUBLE
49344: LD_INT 1
49346: DEC
49347: ST_TO_ADDR
49348: LD_VAR 0 2
49352: PUSH
49353: FOR_TO
49354: IFFALSE 49418
// begin hc_class = class_tiger ;
49356: LD_ADDR_OWVAR 28
49360: PUSH
49361: LD_INT 14
49363: ST_TO_ADDR
// hc_gallery =  ;
49364: LD_ADDR_OWVAR 33
49368: PUSH
49369: LD_STRING 
49371: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49372: LD_ADDR_OWVAR 35
49376: PUSH
49377: LD_INT 7
49379: NEG
49380: PPUSH
49381: LD_INT 7
49383: PPUSH
49384: CALL_OW 12
49388: ST_TO_ADDR
// animal := CreateHuman ;
49389: LD_ADDR_VAR 0 12
49393: PUSH
49394: CALL_OW 44
49398: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49399: LD_VAR 0 12
49403: PPUSH
49404: LD_VAR 0 8
49408: PPUSH
49409: LD_INT 0
49411: PPUSH
49412: CALL 51318 0 3
// end ;
49416: GO 49353
49418: POP
49419: POP
// if apemans then
49420: LD_VAR 0 3
49424: IFFALSE 49547
// for i = 1 to apemans do
49426: LD_ADDR_VAR 0 11
49430: PUSH
49431: DOUBLE
49432: LD_INT 1
49434: DEC
49435: ST_TO_ADDR
49436: LD_VAR 0 3
49440: PUSH
49441: FOR_TO
49442: IFFALSE 49545
// begin hc_class = class_apeman ;
49444: LD_ADDR_OWVAR 28
49448: PUSH
49449: LD_INT 12
49451: ST_TO_ADDR
// hc_gallery =  ;
49452: LD_ADDR_OWVAR 33
49456: PUSH
49457: LD_STRING 
49459: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49460: LD_ADDR_OWVAR 35
49464: PUSH
49465: LD_INT 2
49467: NEG
49468: PPUSH
49469: LD_INT 2
49471: PPUSH
49472: CALL_OW 12
49476: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49477: LD_ADDR_OWVAR 31
49481: PUSH
49482: LD_INT 1
49484: PPUSH
49485: LD_INT 3
49487: PPUSH
49488: CALL_OW 12
49492: PUSH
49493: LD_INT 1
49495: PPUSH
49496: LD_INT 3
49498: PPUSH
49499: CALL_OW 12
49503: PUSH
49504: LD_INT 0
49506: PUSH
49507: LD_INT 0
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: LIST
49514: LIST
49515: ST_TO_ADDR
// animal := CreateHuman ;
49516: LD_ADDR_VAR 0 12
49520: PUSH
49521: CALL_OW 44
49525: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49526: LD_VAR 0 12
49530: PPUSH
49531: LD_VAR 0 8
49535: PPUSH
49536: LD_INT 0
49538: PPUSH
49539: CALL 51318 0 3
// end ;
49543: GO 49441
49545: POP
49546: POP
// if enchidnas then
49547: LD_VAR 0 4
49551: IFFALSE 49618
// for i = 1 to enchidnas do
49553: LD_ADDR_VAR 0 11
49557: PUSH
49558: DOUBLE
49559: LD_INT 1
49561: DEC
49562: ST_TO_ADDR
49563: LD_VAR 0 4
49567: PUSH
49568: FOR_TO
49569: IFFALSE 49616
// begin hc_class = 13 ;
49571: LD_ADDR_OWVAR 28
49575: PUSH
49576: LD_INT 13
49578: ST_TO_ADDR
// hc_gallery =  ;
49579: LD_ADDR_OWVAR 33
49583: PUSH
49584: LD_STRING 
49586: ST_TO_ADDR
// animal := CreateHuman ;
49587: LD_ADDR_VAR 0 12
49591: PUSH
49592: CALL_OW 44
49596: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49597: LD_VAR 0 12
49601: PPUSH
49602: LD_VAR 0 8
49606: PPUSH
49607: LD_INT 0
49609: PPUSH
49610: CALL 51318 0 3
// end ;
49614: GO 49568
49616: POP
49617: POP
// if fishes then
49618: LD_VAR 0 7
49622: IFFALSE 49689
// for i = 1 to fishes do
49624: LD_ADDR_VAR 0 11
49628: PUSH
49629: DOUBLE
49630: LD_INT 1
49632: DEC
49633: ST_TO_ADDR
49634: LD_VAR 0 7
49638: PUSH
49639: FOR_TO
49640: IFFALSE 49687
// begin hc_class = 20 ;
49642: LD_ADDR_OWVAR 28
49646: PUSH
49647: LD_INT 20
49649: ST_TO_ADDR
// hc_gallery =  ;
49650: LD_ADDR_OWVAR 33
49654: PUSH
49655: LD_STRING 
49657: ST_TO_ADDR
// animal := CreateHuman ;
49658: LD_ADDR_VAR 0 12
49662: PUSH
49663: CALL_OW 44
49667: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49668: LD_VAR 0 12
49672: PPUSH
49673: LD_VAR 0 9
49677: PPUSH
49678: LD_INT 0
49680: PPUSH
49681: CALL 51318 0 3
// end ;
49685: GO 49639
49687: POP
49688: POP
// end ;
49689: LD_VAR 0 10
49693: RET
// export function WantHeal ( sci , unit ) ; begin
49694: LD_INT 0
49696: PPUSH
// if GetTaskList ( sci ) > 0 then
49697: LD_VAR 0 1
49701: PPUSH
49702: CALL_OW 437
49706: PUSH
49707: LD_INT 0
49709: GREATER
49710: IFFALSE 49780
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49712: LD_VAR 0 1
49716: PPUSH
49717: CALL_OW 437
49721: PUSH
49722: LD_INT 1
49724: ARRAY
49725: PUSH
49726: LD_INT 1
49728: ARRAY
49729: PUSH
49730: LD_STRING l
49732: EQUAL
49733: PUSH
49734: LD_VAR 0 1
49738: PPUSH
49739: CALL_OW 437
49743: PUSH
49744: LD_INT 1
49746: ARRAY
49747: PUSH
49748: LD_INT 4
49750: ARRAY
49751: PUSH
49752: LD_VAR 0 2
49756: EQUAL
49757: AND
49758: IFFALSE 49770
// result := true else
49760: LD_ADDR_VAR 0 3
49764: PUSH
49765: LD_INT 1
49767: ST_TO_ADDR
49768: GO 49778
// result := false ;
49770: LD_ADDR_VAR 0 3
49774: PUSH
49775: LD_INT 0
49777: ST_TO_ADDR
// end else
49778: GO 49788
// result := false ;
49780: LD_ADDR_VAR 0 3
49784: PUSH
49785: LD_INT 0
49787: ST_TO_ADDR
// end ;
49788: LD_VAR 0 3
49792: RET
// export function HealTarget ( sci ) ; begin
49793: LD_INT 0
49795: PPUSH
// if not sci then
49796: LD_VAR 0 1
49800: NOT
49801: IFFALSE 49805
// exit ;
49803: GO 49870
// result := 0 ;
49805: LD_ADDR_VAR 0 2
49809: PUSH
49810: LD_INT 0
49812: ST_TO_ADDR
// if GetTaskList ( sci ) then
49813: LD_VAR 0 1
49817: PPUSH
49818: CALL_OW 437
49822: IFFALSE 49870
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49824: LD_VAR 0 1
49828: PPUSH
49829: CALL_OW 437
49833: PUSH
49834: LD_INT 1
49836: ARRAY
49837: PUSH
49838: LD_INT 1
49840: ARRAY
49841: PUSH
49842: LD_STRING l
49844: EQUAL
49845: IFFALSE 49870
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49847: LD_ADDR_VAR 0 2
49851: PUSH
49852: LD_VAR 0 1
49856: PPUSH
49857: CALL_OW 437
49861: PUSH
49862: LD_INT 1
49864: ARRAY
49865: PUSH
49866: LD_INT 4
49868: ARRAY
49869: ST_TO_ADDR
// end ;
49870: LD_VAR 0 2
49874: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49875: LD_INT 0
49877: PPUSH
49878: PPUSH
49879: PPUSH
49880: PPUSH
// if not base_units then
49881: LD_VAR 0 1
49885: NOT
49886: IFFALSE 49890
// exit ;
49888: GO 49977
// result := false ;
49890: LD_ADDR_VAR 0 2
49894: PUSH
49895: LD_INT 0
49897: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49898: LD_ADDR_VAR 0 5
49902: PUSH
49903: LD_VAR 0 1
49907: PPUSH
49908: LD_INT 21
49910: PUSH
49911: LD_INT 3
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: PPUSH
49918: CALL_OW 72
49922: ST_TO_ADDR
// if not tmp then
49923: LD_VAR 0 5
49927: NOT
49928: IFFALSE 49932
// exit ;
49930: GO 49977
// for i in tmp do
49932: LD_ADDR_VAR 0 3
49936: PUSH
49937: LD_VAR 0 5
49941: PUSH
49942: FOR_IN
49943: IFFALSE 49975
// begin result := EnemyInRange ( i , 22 ) ;
49945: LD_ADDR_VAR 0 2
49949: PUSH
49950: LD_VAR 0 3
49954: PPUSH
49955: LD_INT 22
49957: PPUSH
49958: CALL 47564 0 2
49962: ST_TO_ADDR
// if result then
49963: LD_VAR 0 2
49967: IFFALSE 49973
// exit ;
49969: POP
49970: POP
49971: GO 49977
// end ;
49973: GO 49942
49975: POP
49976: POP
// end ;
49977: LD_VAR 0 2
49981: RET
// export function FilterByTag ( units , tag ) ; begin
49982: LD_INT 0
49984: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49985: LD_ADDR_VAR 0 3
49989: PUSH
49990: LD_VAR 0 1
49994: PPUSH
49995: LD_INT 120
49997: PUSH
49998: LD_VAR 0 2
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PPUSH
50007: CALL_OW 72
50011: ST_TO_ADDR
// end ;
50012: LD_VAR 0 3
50016: RET
// export function IsDriver ( un ) ; begin
50017: LD_INT 0
50019: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50020: LD_ADDR_VAR 0 2
50024: PUSH
50025: LD_VAR 0 1
50029: PUSH
50030: LD_INT 55
50032: PUSH
50033: EMPTY
50034: LIST
50035: PPUSH
50036: CALL_OW 69
50040: IN
50041: ST_TO_ADDR
// end ;
50042: LD_VAR 0 2
50046: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50047: LD_INT 0
50049: PPUSH
50050: PPUSH
// list := [ ] ;
50051: LD_ADDR_VAR 0 5
50055: PUSH
50056: EMPTY
50057: ST_TO_ADDR
// case d of 0 :
50058: LD_VAR 0 3
50062: PUSH
50063: LD_INT 0
50065: DOUBLE
50066: EQUAL
50067: IFTRUE 50071
50069: GO 50204
50071: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50072: LD_ADDR_VAR 0 5
50076: PUSH
50077: LD_VAR 0 1
50081: PUSH
50082: LD_INT 4
50084: MINUS
50085: PUSH
50086: LD_VAR 0 2
50090: PUSH
50091: LD_INT 4
50093: MINUS
50094: PUSH
50095: LD_INT 2
50097: PUSH
50098: EMPTY
50099: LIST
50100: LIST
50101: LIST
50102: PUSH
50103: LD_VAR 0 1
50107: PUSH
50108: LD_INT 3
50110: MINUS
50111: PUSH
50112: LD_VAR 0 2
50116: PUSH
50117: LD_INT 1
50119: PUSH
50120: EMPTY
50121: LIST
50122: LIST
50123: LIST
50124: PUSH
50125: LD_VAR 0 1
50129: PUSH
50130: LD_INT 4
50132: PLUS
50133: PUSH
50134: LD_VAR 0 2
50138: PUSH
50139: LD_INT 4
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: LIST
50146: PUSH
50147: LD_VAR 0 1
50151: PUSH
50152: LD_INT 3
50154: PLUS
50155: PUSH
50156: LD_VAR 0 2
50160: PUSH
50161: LD_INT 3
50163: PLUS
50164: PUSH
50165: LD_INT 5
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: LIST
50172: PUSH
50173: LD_VAR 0 1
50177: PUSH
50178: LD_VAR 0 2
50182: PUSH
50183: LD_INT 4
50185: PLUS
50186: PUSH
50187: LD_INT 0
50189: PUSH
50190: EMPTY
50191: LIST
50192: LIST
50193: LIST
50194: PUSH
50195: EMPTY
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: ST_TO_ADDR
// end ; 1 :
50202: GO 50902
50204: LD_INT 1
50206: DOUBLE
50207: EQUAL
50208: IFTRUE 50212
50210: GO 50345
50212: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50213: LD_ADDR_VAR 0 5
50217: PUSH
50218: LD_VAR 0 1
50222: PUSH
50223: LD_VAR 0 2
50227: PUSH
50228: LD_INT 4
50230: MINUS
50231: PUSH
50232: LD_INT 3
50234: PUSH
50235: EMPTY
50236: LIST
50237: LIST
50238: LIST
50239: PUSH
50240: LD_VAR 0 1
50244: PUSH
50245: LD_INT 3
50247: MINUS
50248: PUSH
50249: LD_VAR 0 2
50253: PUSH
50254: LD_INT 3
50256: MINUS
50257: PUSH
50258: LD_INT 2
50260: PUSH
50261: EMPTY
50262: LIST
50263: LIST
50264: LIST
50265: PUSH
50266: LD_VAR 0 1
50270: PUSH
50271: LD_INT 4
50273: MINUS
50274: PUSH
50275: LD_VAR 0 2
50279: PUSH
50280: LD_INT 1
50282: PUSH
50283: EMPTY
50284: LIST
50285: LIST
50286: LIST
50287: PUSH
50288: LD_VAR 0 1
50292: PUSH
50293: LD_VAR 0 2
50297: PUSH
50298: LD_INT 3
50300: PLUS
50301: PUSH
50302: LD_INT 0
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: LIST
50309: PUSH
50310: LD_VAR 0 1
50314: PUSH
50315: LD_INT 4
50317: PLUS
50318: PUSH
50319: LD_VAR 0 2
50323: PUSH
50324: LD_INT 4
50326: PLUS
50327: PUSH
50328: LD_INT 5
50330: PUSH
50331: EMPTY
50332: LIST
50333: LIST
50334: LIST
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: LIST
50340: LIST
50341: LIST
50342: ST_TO_ADDR
// end ; 2 :
50343: GO 50902
50345: LD_INT 2
50347: DOUBLE
50348: EQUAL
50349: IFTRUE 50353
50351: GO 50482
50353: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50354: LD_ADDR_VAR 0 5
50358: PUSH
50359: LD_VAR 0 1
50363: PUSH
50364: LD_VAR 0 2
50368: PUSH
50369: LD_INT 3
50371: MINUS
50372: PUSH
50373: LD_INT 3
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: LIST
50380: PUSH
50381: LD_VAR 0 1
50385: PUSH
50386: LD_INT 4
50388: PLUS
50389: PUSH
50390: LD_VAR 0 2
50394: PUSH
50395: LD_INT 4
50397: PUSH
50398: EMPTY
50399: LIST
50400: LIST
50401: LIST
50402: PUSH
50403: LD_VAR 0 1
50407: PUSH
50408: LD_VAR 0 2
50412: PUSH
50413: LD_INT 4
50415: PLUS
50416: PUSH
50417: LD_INT 0
50419: PUSH
50420: EMPTY
50421: LIST
50422: LIST
50423: LIST
50424: PUSH
50425: LD_VAR 0 1
50429: PUSH
50430: LD_INT 3
50432: MINUS
50433: PUSH
50434: LD_VAR 0 2
50438: PUSH
50439: LD_INT 1
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: LIST
50446: PUSH
50447: LD_VAR 0 1
50451: PUSH
50452: LD_INT 4
50454: MINUS
50455: PUSH
50456: LD_VAR 0 2
50460: PUSH
50461: LD_INT 4
50463: MINUS
50464: PUSH
50465: LD_INT 2
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: LIST
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: LIST
50477: LIST
50478: LIST
50479: ST_TO_ADDR
// end ; 3 :
50480: GO 50902
50482: LD_INT 3
50484: DOUBLE
50485: EQUAL
50486: IFTRUE 50490
50488: GO 50623
50490: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50491: LD_ADDR_VAR 0 5
50495: PUSH
50496: LD_VAR 0 1
50500: PUSH
50501: LD_INT 3
50503: PLUS
50504: PUSH
50505: LD_VAR 0 2
50509: PUSH
50510: LD_INT 4
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: LIST
50517: PUSH
50518: LD_VAR 0 1
50522: PUSH
50523: LD_INT 4
50525: PLUS
50526: PUSH
50527: LD_VAR 0 2
50531: PUSH
50532: LD_INT 4
50534: PLUS
50535: PUSH
50536: LD_INT 5
50538: PUSH
50539: EMPTY
50540: LIST
50541: LIST
50542: LIST
50543: PUSH
50544: LD_VAR 0 1
50548: PUSH
50549: LD_INT 4
50551: MINUS
50552: PUSH
50553: LD_VAR 0 2
50557: PUSH
50558: LD_INT 1
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: LIST
50565: PUSH
50566: LD_VAR 0 1
50570: PUSH
50571: LD_VAR 0 2
50575: PUSH
50576: LD_INT 4
50578: MINUS
50579: PUSH
50580: LD_INT 3
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: LIST
50587: PUSH
50588: LD_VAR 0 1
50592: PUSH
50593: LD_INT 3
50595: MINUS
50596: PUSH
50597: LD_VAR 0 2
50601: PUSH
50602: LD_INT 3
50604: MINUS
50605: PUSH
50606: LD_INT 2
50608: PUSH
50609: EMPTY
50610: LIST
50611: LIST
50612: LIST
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: LIST
50618: LIST
50619: LIST
50620: ST_TO_ADDR
// end ; 4 :
50621: GO 50902
50623: LD_INT 4
50625: DOUBLE
50626: EQUAL
50627: IFTRUE 50631
50629: GO 50764
50631: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50632: LD_ADDR_VAR 0 5
50636: PUSH
50637: LD_VAR 0 1
50641: PUSH
50642: LD_VAR 0 2
50646: PUSH
50647: LD_INT 4
50649: PLUS
50650: PUSH
50651: LD_INT 0
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: LIST
50658: PUSH
50659: LD_VAR 0 1
50663: PUSH
50664: LD_INT 3
50666: PLUS
50667: PUSH
50668: LD_VAR 0 2
50672: PUSH
50673: LD_INT 3
50675: PLUS
50676: PUSH
50677: LD_INT 5
50679: PUSH
50680: EMPTY
50681: LIST
50682: LIST
50683: LIST
50684: PUSH
50685: LD_VAR 0 1
50689: PUSH
50690: LD_INT 4
50692: PLUS
50693: PUSH
50694: LD_VAR 0 2
50698: PUSH
50699: LD_INT 4
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: LIST
50706: PUSH
50707: LD_VAR 0 1
50711: PUSH
50712: LD_VAR 0 2
50716: PUSH
50717: LD_INT 3
50719: MINUS
50720: PUSH
50721: LD_INT 3
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: LIST
50728: PUSH
50729: LD_VAR 0 1
50733: PUSH
50734: LD_INT 4
50736: MINUS
50737: PUSH
50738: LD_VAR 0 2
50742: PUSH
50743: LD_INT 4
50745: MINUS
50746: PUSH
50747: LD_INT 2
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: LIST
50754: PUSH
50755: EMPTY
50756: LIST
50757: LIST
50758: LIST
50759: LIST
50760: LIST
50761: ST_TO_ADDR
// end ; 5 :
50762: GO 50902
50764: LD_INT 5
50766: DOUBLE
50767: EQUAL
50768: IFTRUE 50772
50770: GO 50901
50772: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50773: LD_ADDR_VAR 0 5
50777: PUSH
50778: LD_VAR 0 1
50782: PUSH
50783: LD_INT 4
50785: MINUS
50786: PUSH
50787: LD_VAR 0 2
50791: PUSH
50792: LD_INT 1
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: LIST
50799: PUSH
50800: LD_VAR 0 1
50804: PUSH
50805: LD_VAR 0 2
50809: PUSH
50810: LD_INT 4
50812: MINUS
50813: PUSH
50814: LD_INT 3
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: LIST
50821: PUSH
50822: LD_VAR 0 1
50826: PUSH
50827: LD_INT 4
50829: PLUS
50830: PUSH
50831: LD_VAR 0 2
50835: PUSH
50836: LD_INT 4
50838: PLUS
50839: PUSH
50840: LD_INT 5
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: LIST
50847: PUSH
50848: LD_VAR 0 1
50852: PUSH
50853: LD_INT 3
50855: PLUS
50856: PUSH
50857: LD_VAR 0 2
50861: PUSH
50862: LD_INT 4
50864: PUSH
50865: EMPTY
50866: LIST
50867: LIST
50868: LIST
50869: PUSH
50870: LD_VAR 0 1
50874: PUSH
50875: LD_VAR 0 2
50879: PUSH
50880: LD_INT 3
50882: PLUS
50883: PUSH
50884: LD_INT 0
50886: PUSH
50887: EMPTY
50888: LIST
50889: LIST
50890: LIST
50891: PUSH
50892: EMPTY
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: ST_TO_ADDR
// end ; end ;
50899: GO 50902
50901: POP
// result := list ;
50902: LD_ADDR_VAR 0 4
50906: PUSH
50907: LD_VAR 0 5
50911: ST_TO_ADDR
// end ;
50912: LD_VAR 0 4
50916: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50917: LD_INT 0
50919: PPUSH
50920: PPUSH
50921: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50922: LD_VAR 0 1
50926: NOT
50927: PUSH
50928: LD_VAR 0 2
50932: PUSH
50933: LD_INT 1
50935: PUSH
50936: LD_INT 2
50938: PUSH
50939: LD_INT 3
50941: PUSH
50942: LD_INT 4
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: IN
50951: NOT
50952: OR
50953: IFFALSE 50957
// exit ;
50955: GO 51040
// tmp := [ ] ;
50957: LD_ADDR_VAR 0 5
50961: PUSH
50962: EMPTY
50963: ST_TO_ADDR
// for i in units do
50964: LD_ADDR_VAR 0 4
50968: PUSH
50969: LD_VAR 0 1
50973: PUSH
50974: FOR_IN
50975: IFFALSE 51009
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
50977: LD_ADDR_VAR 0 5
50981: PUSH
50982: LD_VAR 0 5
50986: PPUSH
50987: LD_VAR 0 4
50991: PPUSH
50992: LD_VAR 0 2
50996: PPUSH
50997: CALL_OW 259
51001: PPUSH
51002: CALL 52401 0 2
51006: ST_TO_ADDR
51007: GO 50974
51009: POP
51010: POP
// if not tmp then
51011: LD_VAR 0 5
51015: NOT
51016: IFFALSE 51020
// exit ;
51018: GO 51040
// result := SortListByListDesc ( units , tmp ) ;
51020: LD_ADDR_VAR 0 3
51024: PUSH
51025: LD_VAR 0 1
51029: PPUSH
51030: LD_VAR 0 5
51034: PPUSH
51035: CALL_OW 77
51039: ST_TO_ADDR
// end ;
51040: LD_VAR 0 3
51044: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51045: LD_INT 0
51047: PPUSH
51048: PPUSH
51049: PPUSH
// result := false ;
51050: LD_ADDR_VAR 0 3
51054: PUSH
51055: LD_INT 0
51057: ST_TO_ADDR
// if not building then
51058: LD_VAR 0 2
51062: NOT
51063: IFFALSE 51067
// exit ;
51065: GO 51205
// x := GetX ( building ) ;
51067: LD_ADDR_VAR 0 4
51071: PUSH
51072: LD_VAR 0 2
51076: PPUSH
51077: CALL_OW 250
51081: ST_TO_ADDR
// y := GetY ( building ) ;
51082: LD_ADDR_VAR 0 5
51086: PUSH
51087: LD_VAR 0 2
51091: PPUSH
51092: CALL_OW 251
51096: ST_TO_ADDR
// if not x or not y then
51097: LD_VAR 0 4
51101: NOT
51102: PUSH
51103: LD_VAR 0 5
51107: NOT
51108: OR
51109: IFFALSE 51113
// exit ;
51111: GO 51205
// if GetTaskList ( unit ) then
51113: LD_VAR 0 1
51117: PPUSH
51118: CALL_OW 437
51122: IFFALSE 51205
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51124: LD_STRING e
51126: PUSH
51127: LD_VAR 0 1
51131: PPUSH
51132: CALL_OW 437
51136: PUSH
51137: LD_INT 1
51139: ARRAY
51140: PUSH
51141: LD_INT 1
51143: ARRAY
51144: EQUAL
51145: PUSH
51146: LD_VAR 0 4
51150: PUSH
51151: LD_VAR 0 1
51155: PPUSH
51156: CALL_OW 437
51160: PUSH
51161: LD_INT 1
51163: ARRAY
51164: PUSH
51165: LD_INT 2
51167: ARRAY
51168: EQUAL
51169: AND
51170: PUSH
51171: LD_VAR 0 5
51175: PUSH
51176: LD_VAR 0 1
51180: PPUSH
51181: CALL_OW 437
51185: PUSH
51186: LD_INT 1
51188: ARRAY
51189: PUSH
51190: LD_INT 3
51192: ARRAY
51193: EQUAL
51194: AND
51195: IFFALSE 51205
// result := true end ;
51197: LD_ADDR_VAR 0 3
51201: PUSH
51202: LD_INT 1
51204: ST_TO_ADDR
// end ;
51205: LD_VAR 0 3
51209: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51210: LD_INT 0
51212: PPUSH
// result := false ;
51213: LD_ADDR_VAR 0 4
51217: PUSH
51218: LD_INT 0
51220: ST_TO_ADDR
// if GetTaskList ( unit ) then
51221: LD_VAR 0 1
51225: PPUSH
51226: CALL_OW 437
51230: IFFALSE 51313
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51232: LD_STRING M
51234: PUSH
51235: LD_VAR 0 1
51239: PPUSH
51240: CALL_OW 437
51244: PUSH
51245: LD_INT 1
51247: ARRAY
51248: PUSH
51249: LD_INT 1
51251: ARRAY
51252: EQUAL
51253: PUSH
51254: LD_VAR 0 2
51258: PUSH
51259: LD_VAR 0 1
51263: PPUSH
51264: CALL_OW 437
51268: PUSH
51269: LD_INT 1
51271: ARRAY
51272: PUSH
51273: LD_INT 2
51275: ARRAY
51276: EQUAL
51277: AND
51278: PUSH
51279: LD_VAR 0 3
51283: PUSH
51284: LD_VAR 0 1
51288: PPUSH
51289: CALL_OW 437
51293: PUSH
51294: LD_INT 1
51296: ARRAY
51297: PUSH
51298: LD_INT 3
51300: ARRAY
51301: EQUAL
51302: AND
51303: IFFALSE 51313
// result := true ;
51305: LD_ADDR_VAR 0 4
51309: PUSH
51310: LD_INT 1
51312: ST_TO_ADDR
// end ; end ;
51313: LD_VAR 0 4
51317: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51318: LD_INT 0
51320: PPUSH
51321: PPUSH
51322: PPUSH
51323: PPUSH
// if not unit or not area then
51324: LD_VAR 0 1
51328: NOT
51329: PUSH
51330: LD_VAR 0 2
51334: NOT
51335: OR
51336: IFFALSE 51340
// exit ;
51338: GO 51504
// tmp := AreaToList ( area , i ) ;
51340: LD_ADDR_VAR 0 6
51344: PUSH
51345: LD_VAR 0 2
51349: PPUSH
51350: LD_VAR 0 5
51354: PPUSH
51355: CALL_OW 517
51359: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51360: LD_ADDR_VAR 0 5
51364: PUSH
51365: DOUBLE
51366: LD_INT 1
51368: DEC
51369: ST_TO_ADDR
51370: LD_VAR 0 6
51374: PUSH
51375: LD_INT 1
51377: ARRAY
51378: PUSH
51379: FOR_TO
51380: IFFALSE 51502
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51382: LD_ADDR_VAR 0 7
51386: PUSH
51387: LD_VAR 0 6
51391: PUSH
51392: LD_INT 1
51394: ARRAY
51395: PUSH
51396: LD_VAR 0 5
51400: ARRAY
51401: PUSH
51402: LD_VAR 0 6
51406: PUSH
51407: LD_INT 2
51409: ARRAY
51410: PUSH
51411: LD_VAR 0 5
51415: ARRAY
51416: PUSH
51417: EMPTY
51418: LIST
51419: LIST
51420: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
51421: LD_VAR 0 7
51425: PUSH
51426: LD_INT 1
51428: ARRAY
51429: PPUSH
51430: LD_VAR 0 7
51434: PUSH
51435: LD_INT 2
51437: ARRAY
51438: PPUSH
51439: CALL_OW 428
51443: PUSH
51444: LD_INT 0
51446: EQUAL
51447: IFFALSE 51500
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
51449: LD_VAR 0 1
51453: PPUSH
51454: LD_VAR 0 7
51458: PUSH
51459: LD_INT 1
51461: ARRAY
51462: PPUSH
51463: LD_VAR 0 7
51467: PUSH
51468: LD_INT 2
51470: ARRAY
51471: PPUSH
51472: LD_VAR 0 3
51476: PPUSH
51477: CALL_OW 48
// result := IsPlaced ( unit ) ;
51481: LD_ADDR_VAR 0 4
51485: PUSH
51486: LD_VAR 0 1
51490: PPUSH
51491: CALL_OW 305
51495: ST_TO_ADDR
// exit ;
51496: POP
51497: POP
51498: GO 51504
// end ; end ;
51500: GO 51379
51502: POP
51503: POP
// end ;
51504: LD_VAR 0 4
51508: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51509: LD_INT 0
51511: PPUSH
51512: PPUSH
51513: PPUSH
// if not side or side > 8 then
51514: LD_VAR 0 1
51518: NOT
51519: PUSH
51520: LD_VAR 0 1
51524: PUSH
51525: LD_INT 8
51527: GREATER
51528: OR
51529: IFFALSE 51533
// exit ;
51531: GO 51720
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51533: LD_ADDR_VAR 0 4
51537: PUSH
51538: LD_INT 22
51540: PUSH
51541: LD_VAR 0 1
51545: PUSH
51546: EMPTY
51547: LIST
51548: LIST
51549: PUSH
51550: LD_INT 21
51552: PUSH
51553: LD_INT 3
51555: PUSH
51556: EMPTY
51557: LIST
51558: LIST
51559: PUSH
51560: EMPTY
51561: LIST
51562: LIST
51563: PPUSH
51564: CALL_OW 69
51568: ST_TO_ADDR
// if not tmp then
51569: LD_VAR 0 4
51573: NOT
51574: IFFALSE 51578
// exit ;
51576: GO 51720
// enable_addtolog := true ;
51578: LD_ADDR_OWVAR 81
51582: PUSH
51583: LD_INT 1
51585: ST_TO_ADDR
// AddToLog ( [ ) ;
51586: LD_STRING [
51588: PPUSH
51589: CALL_OW 561
// for i in tmp do
51593: LD_ADDR_VAR 0 3
51597: PUSH
51598: LD_VAR 0 4
51602: PUSH
51603: FOR_IN
51604: IFFALSE 51711
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51606: LD_STRING [
51608: PUSH
51609: LD_VAR 0 3
51613: PPUSH
51614: CALL_OW 266
51618: STR
51619: PUSH
51620: LD_STRING , 
51622: STR
51623: PUSH
51624: LD_VAR 0 3
51628: PPUSH
51629: CALL_OW 250
51633: STR
51634: PUSH
51635: LD_STRING , 
51637: STR
51638: PUSH
51639: LD_VAR 0 3
51643: PPUSH
51644: CALL_OW 251
51648: STR
51649: PUSH
51650: LD_STRING , 
51652: STR
51653: PUSH
51654: LD_VAR 0 3
51658: PPUSH
51659: CALL_OW 254
51663: STR
51664: PUSH
51665: LD_STRING , 
51667: STR
51668: PUSH
51669: LD_VAR 0 3
51673: PPUSH
51674: LD_INT 1
51676: PPUSH
51677: CALL_OW 268
51681: STR
51682: PUSH
51683: LD_STRING , 
51685: STR
51686: PUSH
51687: LD_VAR 0 3
51691: PPUSH
51692: LD_INT 2
51694: PPUSH
51695: CALL_OW 268
51699: STR
51700: PUSH
51701: LD_STRING ],
51703: STR
51704: PPUSH
51705: CALL_OW 561
// end ;
51709: GO 51603
51711: POP
51712: POP
// AddToLog ( ]; ) ;
51713: LD_STRING ];
51715: PPUSH
51716: CALL_OW 561
// end ;
51720: LD_VAR 0 2
51724: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51725: LD_INT 0
51727: PPUSH
51728: PPUSH
51729: PPUSH
51730: PPUSH
51731: PPUSH
// if not area or not rate or not max then
51732: LD_VAR 0 1
51736: NOT
51737: PUSH
51738: LD_VAR 0 2
51742: NOT
51743: OR
51744: PUSH
51745: LD_VAR 0 4
51749: NOT
51750: OR
51751: IFFALSE 51755
// exit ;
51753: GO 51944
// while 1 do
51755: LD_INT 1
51757: IFFALSE 51944
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51759: LD_ADDR_VAR 0 9
51763: PUSH
51764: LD_VAR 0 1
51768: PPUSH
51769: LD_INT 1
51771: PPUSH
51772: CALL_OW 287
51776: PUSH
51777: LD_INT 10
51779: MUL
51780: ST_TO_ADDR
// r := rate / 10 ;
51781: LD_ADDR_VAR 0 7
51785: PUSH
51786: LD_VAR 0 2
51790: PUSH
51791: LD_INT 10
51793: DIVREAL
51794: ST_TO_ADDR
// time := 1 1$00 ;
51795: LD_ADDR_VAR 0 8
51799: PUSH
51800: LD_INT 2100
51802: ST_TO_ADDR
// if amount < min then
51803: LD_VAR 0 9
51807: PUSH
51808: LD_VAR 0 3
51812: LESS
51813: IFFALSE 51831
// r := r * 2 else
51815: LD_ADDR_VAR 0 7
51819: PUSH
51820: LD_VAR 0 7
51824: PUSH
51825: LD_INT 2
51827: MUL
51828: ST_TO_ADDR
51829: GO 51857
// if amount > max then
51831: LD_VAR 0 9
51835: PUSH
51836: LD_VAR 0 4
51840: GREATER
51841: IFFALSE 51857
// r := r / 2 ;
51843: LD_ADDR_VAR 0 7
51847: PUSH
51848: LD_VAR 0 7
51852: PUSH
51853: LD_INT 2
51855: DIVREAL
51856: ST_TO_ADDR
// time := time / r ;
51857: LD_ADDR_VAR 0 8
51861: PUSH
51862: LD_VAR 0 8
51866: PUSH
51867: LD_VAR 0 7
51871: DIVREAL
51872: ST_TO_ADDR
// if time < 0 then
51873: LD_VAR 0 8
51877: PUSH
51878: LD_INT 0
51880: LESS
51881: IFFALSE 51898
// time := time * - 1 ;
51883: LD_ADDR_VAR 0 8
51887: PUSH
51888: LD_VAR 0 8
51892: PUSH
51893: LD_INT 1
51895: NEG
51896: MUL
51897: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51898: LD_VAR 0 8
51902: PUSH
51903: LD_INT 35
51905: PPUSH
51906: LD_INT 875
51908: PPUSH
51909: CALL_OW 12
51913: PLUS
51914: PPUSH
51915: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51919: LD_INT 1
51921: PPUSH
51922: LD_INT 5
51924: PPUSH
51925: CALL_OW 12
51929: PPUSH
51930: LD_VAR 0 1
51934: PPUSH
51935: LD_INT 1
51937: PPUSH
51938: CALL_OW 55
// end ;
51942: GO 51755
// end ;
51944: LD_VAR 0 5
51948: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51949: LD_INT 0
51951: PPUSH
51952: PPUSH
51953: PPUSH
51954: PPUSH
51955: PPUSH
51956: PPUSH
51957: PPUSH
51958: PPUSH
// if not turrets or not factories then
51959: LD_VAR 0 1
51963: NOT
51964: PUSH
51965: LD_VAR 0 2
51969: NOT
51970: OR
51971: IFFALSE 51975
// exit ;
51973: GO 52282
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51975: LD_ADDR_VAR 0 10
51979: PUSH
51980: LD_INT 5
51982: PUSH
51983: LD_INT 6
51985: PUSH
51986: EMPTY
51987: LIST
51988: LIST
51989: PUSH
51990: LD_INT 2
51992: PUSH
51993: LD_INT 4
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: PUSH
52000: LD_INT 3
52002: PUSH
52003: LD_INT 5
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: PUSH
52010: EMPTY
52011: LIST
52012: LIST
52013: LIST
52014: PUSH
52015: LD_INT 24
52017: PUSH
52018: LD_INT 25
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: PUSH
52025: LD_INT 23
52027: PUSH
52028: LD_INT 27
52030: PUSH
52031: EMPTY
52032: LIST
52033: LIST
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: LD_INT 42
52041: PUSH
52042: LD_INT 43
52044: PUSH
52045: EMPTY
52046: LIST
52047: LIST
52048: PUSH
52049: LD_INT 44
52051: PUSH
52052: LD_INT 46
52054: PUSH
52055: EMPTY
52056: LIST
52057: LIST
52058: PUSH
52059: LD_INT 45
52061: PUSH
52062: LD_INT 47
52064: PUSH
52065: EMPTY
52066: LIST
52067: LIST
52068: PUSH
52069: EMPTY
52070: LIST
52071: LIST
52072: LIST
52073: PUSH
52074: EMPTY
52075: LIST
52076: LIST
52077: LIST
52078: ST_TO_ADDR
// result := [ ] ;
52079: LD_ADDR_VAR 0 3
52083: PUSH
52084: EMPTY
52085: ST_TO_ADDR
// for i in turrets do
52086: LD_ADDR_VAR 0 4
52090: PUSH
52091: LD_VAR 0 1
52095: PUSH
52096: FOR_IN
52097: IFFALSE 52280
// begin nat := GetNation ( i ) ;
52099: LD_ADDR_VAR 0 7
52103: PUSH
52104: LD_VAR 0 4
52108: PPUSH
52109: CALL_OW 248
52113: ST_TO_ADDR
// weapon := 0 ;
52114: LD_ADDR_VAR 0 8
52118: PUSH
52119: LD_INT 0
52121: ST_TO_ADDR
// if not nat then
52122: LD_VAR 0 7
52126: NOT
52127: IFFALSE 52131
// continue ;
52129: GO 52096
// for j in list [ nat ] do
52131: LD_ADDR_VAR 0 5
52135: PUSH
52136: LD_VAR 0 10
52140: PUSH
52141: LD_VAR 0 7
52145: ARRAY
52146: PUSH
52147: FOR_IN
52148: IFFALSE 52189
// if GetBWeapon ( i ) = j [ 1 ] then
52150: LD_VAR 0 4
52154: PPUSH
52155: CALL_OW 269
52159: PUSH
52160: LD_VAR 0 5
52164: PUSH
52165: LD_INT 1
52167: ARRAY
52168: EQUAL
52169: IFFALSE 52187
// begin weapon := j [ 2 ] ;
52171: LD_ADDR_VAR 0 8
52175: PUSH
52176: LD_VAR 0 5
52180: PUSH
52181: LD_INT 2
52183: ARRAY
52184: ST_TO_ADDR
// break ;
52185: GO 52189
// end ;
52187: GO 52147
52189: POP
52190: POP
// if not weapon then
52191: LD_VAR 0 8
52195: NOT
52196: IFFALSE 52200
// continue ;
52198: GO 52096
// for k in factories do
52200: LD_ADDR_VAR 0 6
52204: PUSH
52205: LD_VAR 0 2
52209: PUSH
52210: FOR_IN
52211: IFFALSE 52276
// begin weapons := AvailableWeaponList ( k ) ;
52213: LD_ADDR_VAR 0 9
52217: PUSH
52218: LD_VAR 0 6
52222: PPUSH
52223: CALL_OW 478
52227: ST_TO_ADDR
// if not weapons then
52228: LD_VAR 0 9
52232: NOT
52233: IFFALSE 52237
// continue ;
52235: GO 52210
// if weapon in weapons then
52237: LD_VAR 0 8
52241: PUSH
52242: LD_VAR 0 9
52246: IN
52247: IFFALSE 52274
// begin result := [ i , weapon ] ;
52249: LD_ADDR_VAR 0 3
52253: PUSH
52254: LD_VAR 0 4
52258: PUSH
52259: LD_VAR 0 8
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: ST_TO_ADDR
// exit ;
52268: POP
52269: POP
52270: POP
52271: POP
52272: GO 52282
// end ; end ;
52274: GO 52210
52276: POP
52277: POP
// end ;
52278: GO 52096
52280: POP
52281: POP
// end ;
52282: LD_VAR 0 3
52286: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52287: LD_INT 0
52289: PPUSH
// if not side or side > 8 then
52290: LD_VAR 0 3
52294: NOT
52295: PUSH
52296: LD_VAR 0 3
52300: PUSH
52301: LD_INT 8
52303: GREATER
52304: OR
52305: IFFALSE 52309
// exit ;
52307: GO 52368
// if not range then
52309: LD_VAR 0 4
52313: NOT
52314: IFFALSE 52325
// range := - 12 ;
52316: LD_ADDR_VAR 0 4
52320: PUSH
52321: LD_INT 12
52323: NEG
52324: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52325: LD_VAR 0 1
52329: PPUSH
52330: LD_VAR 0 2
52334: PPUSH
52335: LD_VAR 0 3
52339: PPUSH
52340: LD_VAR 0 4
52344: PPUSH
52345: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52349: LD_VAR 0 1
52353: PPUSH
52354: LD_VAR 0 2
52358: PPUSH
52359: LD_VAR 0 3
52363: PPUSH
52364: CALL_OW 331
// end ;
52368: LD_VAR 0 5
52372: RET
// export function Video ( mode ) ; begin
52373: LD_INT 0
52375: PPUSH
// ingame_video = mode ;
52376: LD_ADDR_OWVAR 52
52380: PUSH
52381: LD_VAR 0 1
52385: ST_TO_ADDR
// interface_hidden = mode ;
52386: LD_ADDR_OWVAR 54
52390: PUSH
52391: LD_VAR 0 1
52395: ST_TO_ADDR
// end ;
52396: LD_VAR 0 2
52400: RET
// export function Join ( array , element ) ; begin
52401: LD_INT 0
52403: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52404: LD_ADDR_VAR 0 3
52408: PUSH
52409: LD_VAR 0 1
52413: PPUSH
52414: LD_VAR 0 1
52418: PUSH
52419: LD_INT 1
52421: PLUS
52422: PPUSH
52423: LD_VAR 0 2
52427: PPUSH
52428: CALL_OW 1
52432: ST_TO_ADDR
// end ;
52433: LD_VAR 0 3
52437: RET
// export function JoinUnion ( array , element ) ; begin
52438: LD_INT 0
52440: PPUSH
// result := array union element ;
52441: LD_ADDR_VAR 0 3
52445: PUSH
52446: LD_VAR 0 1
52450: PUSH
52451: LD_VAR 0 2
52455: UNION
52456: ST_TO_ADDR
// end ;
52457: LD_VAR 0 3
52461: RET
// export function GetBehemoths ( side ) ; begin
52462: LD_INT 0
52464: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52465: LD_ADDR_VAR 0 2
52469: PUSH
52470: LD_INT 22
52472: PUSH
52473: LD_VAR 0 1
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: PUSH
52482: LD_INT 31
52484: PUSH
52485: LD_INT 25
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: PPUSH
52496: CALL_OW 69
52500: ST_TO_ADDR
// end ;
52501: LD_VAR 0 2
52505: RET
// export function Shuffle ( array ) ; var i , index ; begin
52506: LD_INT 0
52508: PPUSH
52509: PPUSH
52510: PPUSH
// result := [ ] ;
52511: LD_ADDR_VAR 0 2
52515: PUSH
52516: EMPTY
52517: ST_TO_ADDR
// if not array then
52518: LD_VAR 0 1
52522: NOT
52523: IFFALSE 52527
// exit ;
52525: GO 52626
// Randomize ;
52527: CALL_OW 10
// for i = array downto 1 do
52531: LD_ADDR_VAR 0 3
52535: PUSH
52536: DOUBLE
52537: LD_VAR 0 1
52541: INC
52542: ST_TO_ADDR
52543: LD_INT 1
52545: PUSH
52546: FOR_DOWNTO
52547: IFFALSE 52624
// begin index := rand ( 1 , array ) ;
52549: LD_ADDR_VAR 0 4
52553: PUSH
52554: LD_INT 1
52556: PPUSH
52557: LD_VAR 0 1
52561: PPUSH
52562: CALL_OW 12
52566: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52567: LD_ADDR_VAR 0 2
52571: PUSH
52572: LD_VAR 0 2
52576: PPUSH
52577: LD_VAR 0 2
52581: PUSH
52582: LD_INT 1
52584: PLUS
52585: PPUSH
52586: LD_VAR 0 1
52590: PUSH
52591: LD_VAR 0 4
52595: ARRAY
52596: PPUSH
52597: CALL_OW 2
52601: ST_TO_ADDR
// array := Delete ( array , index ) ;
52602: LD_ADDR_VAR 0 1
52606: PUSH
52607: LD_VAR 0 1
52611: PPUSH
52612: LD_VAR 0 4
52616: PPUSH
52617: CALL_OW 3
52621: ST_TO_ADDR
// end ;
52622: GO 52546
52624: POP
52625: POP
// end ;
52626: LD_VAR 0 2
52630: RET
// export function GetBaseMaterials ( base ) ; begin
52631: LD_INT 0
52633: PPUSH
// result := [ 0 , 0 , 0 ] ;
52634: LD_ADDR_VAR 0 2
52638: PUSH
52639: LD_INT 0
52641: PUSH
52642: LD_INT 0
52644: PUSH
52645: LD_INT 0
52647: PUSH
52648: EMPTY
52649: LIST
52650: LIST
52651: LIST
52652: ST_TO_ADDR
// if not base then
52653: LD_VAR 0 1
52657: NOT
52658: IFFALSE 52662
// exit ;
52660: GO 52711
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52662: LD_ADDR_VAR 0 2
52666: PUSH
52667: LD_VAR 0 1
52671: PPUSH
52672: LD_INT 1
52674: PPUSH
52675: CALL_OW 275
52679: PUSH
52680: LD_VAR 0 1
52684: PPUSH
52685: LD_INT 2
52687: PPUSH
52688: CALL_OW 275
52692: PUSH
52693: LD_VAR 0 1
52697: PPUSH
52698: LD_INT 3
52700: PPUSH
52701: CALL_OW 275
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: LIST
52710: ST_TO_ADDR
// end ;
52711: LD_VAR 0 2
52715: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52716: LD_INT 0
52718: PPUSH
52719: PPUSH
// result := array ;
52720: LD_ADDR_VAR 0 3
52724: PUSH
52725: LD_VAR 0 1
52729: ST_TO_ADDR
// if size >= result then
52730: LD_VAR 0 2
52734: PUSH
52735: LD_VAR 0 3
52739: GREATEREQUAL
52740: IFFALSE 52744
// exit ;
52742: GO 52794
// if size then
52744: LD_VAR 0 2
52748: IFFALSE 52794
// for i := array downto size do
52750: LD_ADDR_VAR 0 4
52754: PUSH
52755: DOUBLE
52756: LD_VAR 0 1
52760: INC
52761: ST_TO_ADDR
52762: LD_VAR 0 2
52766: PUSH
52767: FOR_DOWNTO
52768: IFFALSE 52792
// result := Delete ( result , result ) ;
52770: LD_ADDR_VAR 0 3
52774: PUSH
52775: LD_VAR 0 3
52779: PPUSH
52780: LD_VAR 0 3
52784: PPUSH
52785: CALL_OW 3
52789: ST_TO_ADDR
52790: GO 52767
52792: POP
52793: POP
// end ;
52794: LD_VAR 0 3
52798: RET
// export function ComExit ( unit ) ; var tmp ; begin
52799: LD_INT 0
52801: PPUSH
52802: PPUSH
// if not IsInUnit ( unit ) then
52803: LD_VAR 0 1
52807: PPUSH
52808: CALL_OW 310
52812: NOT
52813: IFFALSE 52817
// exit ;
52815: GO 52877
// tmp := IsInUnit ( unit ) ;
52817: LD_ADDR_VAR 0 3
52821: PUSH
52822: LD_VAR 0 1
52826: PPUSH
52827: CALL_OW 310
52831: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52832: LD_VAR 0 3
52836: PPUSH
52837: CALL_OW 247
52841: PUSH
52842: LD_INT 2
52844: EQUAL
52845: IFFALSE 52858
// ComExitVehicle ( unit ) else
52847: LD_VAR 0 1
52851: PPUSH
52852: CALL_OW 121
52856: GO 52867
// ComExitBuilding ( unit ) ;
52858: LD_VAR 0 1
52862: PPUSH
52863: CALL_OW 122
// result := tmp ;
52867: LD_ADDR_VAR 0 2
52871: PUSH
52872: LD_VAR 0 3
52876: ST_TO_ADDR
// end ;
52877: LD_VAR 0 2
52881: RET
// export function ComExitAll ( units ) ; var i ; begin
52882: LD_INT 0
52884: PPUSH
52885: PPUSH
// if not units then
52886: LD_VAR 0 1
52890: NOT
52891: IFFALSE 52895
// exit ;
52893: GO 52921
// for i in units do
52895: LD_ADDR_VAR 0 3
52899: PUSH
52900: LD_VAR 0 1
52904: PUSH
52905: FOR_IN
52906: IFFALSE 52919
// ComExit ( i ) ;
52908: LD_VAR 0 3
52912: PPUSH
52913: CALL 52799 0 1
52917: GO 52905
52919: POP
52920: POP
// end ;
52921: LD_VAR 0 2
52925: RET
// export function ResetHc ; begin
52926: LD_INT 0
52928: PPUSH
// InitHc ;
52929: CALL_OW 19
// hc_importance := 0 ;
52933: LD_ADDR_OWVAR 32
52937: PUSH
52938: LD_INT 0
52940: ST_TO_ADDR
// end ;
52941: LD_VAR 0 1
52945: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52946: LD_INT 0
52948: PPUSH
52949: PPUSH
52950: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52951: LD_ADDR_VAR 0 6
52955: PUSH
52956: LD_VAR 0 1
52960: PUSH
52961: LD_VAR 0 3
52965: PLUS
52966: PUSH
52967: LD_INT 2
52969: DIV
52970: ST_TO_ADDR
// if _x < 0 then
52971: LD_VAR 0 6
52975: PUSH
52976: LD_INT 0
52978: LESS
52979: IFFALSE 52996
// _x := _x * - 1 ;
52981: LD_ADDR_VAR 0 6
52985: PUSH
52986: LD_VAR 0 6
52990: PUSH
52991: LD_INT 1
52993: NEG
52994: MUL
52995: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52996: LD_ADDR_VAR 0 7
53000: PUSH
53001: LD_VAR 0 2
53005: PUSH
53006: LD_VAR 0 4
53010: PLUS
53011: PUSH
53012: LD_INT 2
53014: DIV
53015: ST_TO_ADDR
// if _y < 0 then
53016: LD_VAR 0 7
53020: PUSH
53021: LD_INT 0
53023: LESS
53024: IFFALSE 53041
// _y := _y * - 1 ;
53026: LD_ADDR_VAR 0 7
53030: PUSH
53031: LD_VAR 0 7
53035: PUSH
53036: LD_INT 1
53038: NEG
53039: MUL
53040: ST_TO_ADDR
// result := [ _x , _y ] ;
53041: LD_ADDR_VAR 0 5
53045: PUSH
53046: LD_VAR 0 6
53050: PUSH
53051: LD_VAR 0 7
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: ST_TO_ADDR
// end ;
53060: LD_VAR 0 5
53064: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53065: LD_INT 0
53067: PPUSH
53068: PPUSH
53069: PPUSH
53070: PPUSH
// task := GetTaskList ( unit ) ;
53071: LD_ADDR_VAR 0 7
53075: PUSH
53076: LD_VAR 0 1
53080: PPUSH
53081: CALL_OW 437
53085: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53086: LD_VAR 0 7
53090: NOT
53091: PUSH
53092: LD_VAR 0 1
53096: PPUSH
53097: LD_VAR 0 2
53101: PPUSH
53102: CALL_OW 308
53106: NOT
53107: AND
53108: IFFALSE 53112
// exit ;
53110: GO 53230
// if IsInArea ( unit , area ) then
53112: LD_VAR 0 1
53116: PPUSH
53117: LD_VAR 0 2
53121: PPUSH
53122: CALL_OW 308
53126: IFFALSE 53144
// begin ComMoveToArea ( unit , goAway ) ;
53128: LD_VAR 0 1
53132: PPUSH
53133: LD_VAR 0 3
53137: PPUSH
53138: CALL_OW 113
// exit ;
53142: GO 53230
// end ; if task [ 1 ] [ 1 ] <> M then
53144: LD_VAR 0 7
53148: PUSH
53149: LD_INT 1
53151: ARRAY
53152: PUSH
53153: LD_INT 1
53155: ARRAY
53156: PUSH
53157: LD_STRING M
53159: NONEQUAL
53160: IFFALSE 53164
// exit ;
53162: GO 53230
// x := task [ 1 ] [ 2 ] ;
53164: LD_ADDR_VAR 0 5
53168: PUSH
53169: LD_VAR 0 7
53173: PUSH
53174: LD_INT 1
53176: ARRAY
53177: PUSH
53178: LD_INT 2
53180: ARRAY
53181: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53182: LD_ADDR_VAR 0 6
53186: PUSH
53187: LD_VAR 0 7
53191: PUSH
53192: LD_INT 1
53194: ARRAY
53195: PUSH
53196: LD_INT 3
53198: ARRAY
53199: ST_TO_ADDR
// if InArea ( x , y , area ) then
53200: LD_VAR 0 5
53204: PPUSH
53205: LD_VAR 0 6
53209: PPUSH
53210: LD_VAR 0 2
53214: PPUSH
53215: CALL_OW 309
53219: IFFALSE 53230
// ComStop ( unit ) ;
53221: LD_VAR 0 1
53225: PPUSH
53226: CALL_OW 141
// end ;
53230: LD_VAR 0 4
53234: RET
// export function Abs ( value ) ; begin
53235: LD_INT 0
53237: PPUSH
// result := value ;
53238: LD_ADDR_VAR 0 2
53242: PUSH
53243: LD_VAR 0 1
53247: ST_TO_ADDR
// if value < 0 then
53248: LD_VAR 0 1
53252: PUSH
53253: LD_INT 0
53255: LESS
53256: IFFALSE 53273
// result := value * - 1 ;
53258: LD_ADDR_VAR 0 2
53262: PUSH
53263: LD_VAR 0 1
53267: PUSH
53268: LD_INT 1
53270: NEG
53271: MUL
53272: ST_TO_ADDR
// end ;
53273: LD_VAR 0 2
53277: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53278: LD_INT 0
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
53287: PPUSH
// if not unit or not building then
53288: LD_VAR 0 1
53292: NOT
53293: PUSH
53294: LD_VAR 0 2
53298: NOT
53299: OR
53300: IFFALSE 53304
// exit ;
53302: GO 53530
// x := GetX ( building ) ;
53304: LD_ADDR_VAR 0 4
53308: PUSH
53309: LD_VAR 0 2
53313: PPUSH
53314: CALL_OW 250
53318: ST_TO_ADDR
// y := GetY ( building ) ;
53319: LD_ADDR_VAR 0 6
53323: PUSH
53324: LD_VAR 0 2
53328: PPUSH
53329: CALL_OW 251
53333: ST_TO_ADDR
// d := GetDir ( building ) ;
53334: LD_ADDR_VAR 0 8
53338: PUSH
53339: LD_VAR 0 2
53343: PPUSH
53344: CALL_OW 254
53348: ST_TO_ADDR
// r := 4 ;
53349: LD_ADDR_VAR 0 9
53353: PUSH
53354: LD_INT 4
53356: ST_TO_ADDR
// for i := 1 to 5 do
53357: LD_ADDR_VAR 0 10
53361: PUSH
53362: DOUBLE
53363: LD_INT 1
53365: DEC
53366: ST_TO_ADDR
53367: LD_INT 5
53369: PUSH
53370: FOR_TO
53371: IFFALSE 53528
// begin _x := ShiftX ( x , d , r + i ) ;
53373: LD_ADDR_VAR 0 5
53377: PUSH
53378: LD_VAR 0 4
53382: PPUSH
53383: LD_VAR 0 8
53387: PPUSH
53388: LD_VAR 0 9
53392: PUSH
53393: LD_VAR 0 10
53397: PLUS
53398: PPUSH
53399: CALL_OW 272
53403: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53404: LD_ADDR_VAR 0 7
53408: PUSH
53409: LD_VAR 0 6
53413: PPUSH
53414: LD_VAR 0 8
53418: PPUSH
53419: LD_VAR 0 9
53423: PUSH
53424: LD_VAR 0 10
53428: PLUS
53429: PPUSH
53430: CALL_OW 273
53434: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53435: LD_VAR 0 5
53439: PPUSH
53440: LD_VAR 0 7
53444: PPUSH
53445: CALL_OW 488
53449: PUSH
53450: LD_VAR 0 5
53454: PPUSH
53455: LD_VAR 0 7
53459: PPUSH
53460: CALL_OW 428
53464: PPUSH
53465: CALL_OW 247
53469: PUSH
53470: LD_INT 3
53472: PUSH
53473: LD_INT 2
53475: PUSH
53476: EMPTY
53477: LIST
53478: LIST
53479: IN
53480: NOT
53481: AND
53482: IFFALSE 53526
// begin ComMoveXY ( unit , _x , _y ) ;
53484: LD_VAR 0 1
53488: PPUSH
53489: LD_VAR 0 5
53493: PPUSH
53494: LD_VAR 0 7
53498: PPUSH
53499: CALL_OW 111
// result := [ _x , _y ] ;
53503: LD_ADDR_VAR 0 3
53507: PUSH
53508: LD_VAR 0 5
53512: PUSH
53513: LD_VAR 0 7
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: ST_TO_ADDR
// exit ;
53522: POP
53523: POP
53524: GO 53530
// end ; end ;
53526: GO 53370
53528: POP
53529: POP
// end ;
53530: LD_VAR 0 3
53534: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53535: LD_INT 0
53537: PPUSH
53538: PPUSH
53539: PPUSH
// result := 0 ;
53540: LD_ADDR_VAR 0 3
53544: PUSH
53545: LD_INT 0
53547: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53548: LD_VAR 0 1
53552: PUSH
53553: LD_INT 0
53555: LESS
53556: PUSH
53557: LD_VAR 0 1
53561: PUSH
53562: LD_INT 8
53564: GREATER
53565: OR
53566: PUSH
53567: LD_VAR 0 2
53571: PUSH
53572: LD_INT 0
53574: LESS
53575: OR
53576: PUSH
53577: LD_VAR 0 2
53581: PUSH
53582: LD_INT 8
53584: GREATER
53585: OR
53586: IFFALSE 53590
// exit ;
53588: GO 53665
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53590: LD_ADDR_VAR 0 4
53594: PUSH
53595: LD_INT 22
53597: PUSH
53598: LD_VAR 0 2
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: PPUSH
53607: CALL_OW 69
53611: PUSH
53612: FOR_IN
53613: IFFALSE 53663
// begin un := UnitShoot ( i ) ;
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: LD_VAR 0 4
53624: PPUSH
53625: CALL_OW 504
53629: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53630: LD_VAR 0 5
53634: PPUSH
53635: CALL_OW 255
53639: PUSH
53640: LD_VAR 0 1
53644: EQUAL
53645: IFFALSE 53661
// begin result := un ;
53647: LD_ADDR_VAR 0 3
53651: PUSH
53652: LD_VAR 0 5
53656: ST_TO_ADDR
// exit ;
53657: POP
53658: POP
53659: GO 53665
// end ; end ;
53661: GO 53612
53663: POP
53664: POP
// end ;
53665: LD_VAR 0 3
53669: RET
// export function GetCargoBay ( units ) ; begin
53670: LD_INT 0
53672: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53673: LD_ADDR_VAR 0 2
53677: PUSH
53678: LD_VAR 0 1
53682: PPUSH
53683: LD_INT 2
53685: PUSH
53686: LD_INT 34
53688: PUSH
53689: LD_INT 12
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: PUSH
53696: LD_INT 34
53698: PUSH
53699: LD_INT 51
53701: PUSH
53702: EMPTY
53703: LIST
53704: LIST
53705: PUSH
53706: LD_INT 34
53708: PUSH
53709: LD_INT 32
53711: PUSH
53712: EMPTY
53713: LIST
53714: LIST
53715: PUSH
53716: LD_INT 34
53718: PUSH
53719: LD_INT 89
53721: PUSH
53722: EMPTY
53723: LIST
53724: LIST
53725: PUSH
53726: EMPTY
53727: LIST
53728: LIST
53729: LIST
53730: LIST
53731: LIST
53732: PPUSH
53733: CALL_OW 72
53737: ST_TO_ADDR
// end ;
53738: LD_VAR 0 2
53742: RET
// export function Negate ( value ) ; begin
53743: LD_INT 0
53745: PPUSH
// result := not value ;
53746: LD_ADDR_VAR 0 2
53750: PUSH
53751: LD_VAR 0 1
53755: NOT
53756: ST_TO_ADDR
// end ;
53757: LD_VAR 0 2
53761: RET
// export function Inc ( value ) ; begin
53762: LD_INT 0
53764: PPUSH
// result := value + 1 ;
53765: LD_ADDR_VAR 0 2
53769: PUSH
53770: LD_VAR 0 1
53774: PUSH
53775: LD_INT 1
53777: PLUS
53778: ST_TO_ADDR
// end ;
53779: LD_VAR 0 2
53783: RET
// export function Dec ( value ) ; begin
53784: LD_INT 0
53786: PPUSH
// result := value - 1 ;
53787: LD_ADDR_VAR 0 2
53791: PUSH
53792: LD_VAR 0 1
53796: PUSH
53797: LD_INT 1
53799: MINUS
53800: ST_TO_ADDR
// end ;
53801: LD_VAR 0 2
53805: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53806: LD_INT 0
53808: PPUSH
53809: PPUSH
53810: PPUSH
53811: PPUSH
53812: PPUSH
53813: PPUSH
53814: PPUSH
53815: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53816: LD_VAR 0 1
53820: PPUSH
53821: LD_VAR 0 2
53825: PPUSH
53826: CALL_OW 488
53830: NOT
53831: PUSH
53832: LD_VAR 0 3
53836: PPUSH
53837: LD_VAR 0 4
53841: PPUSH
53842: CALL_OW 488
53846: NOT
53847: OR
53848: IFFALSE 53861
// begin result := - 1 ;
53850: LD_ADDR_VAR 0 5
53854: PUSH
53855: LD_INT 1
53857: NEG
53858: ST_TO_ADDR
// exit ;
53859: GO 54096
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53861: LD_ADDR_VAR 0 12
53865: PUSH
53866: LD_VAR 0 1
53870: PPUSH
53871: LD_VAR 0 2
53875: PPUSH
53876: LD_VAR 0 3
53880: PPUSH
53881: LD_VAR 0 4
53885: PPUSH
53886: CALL 52946 0 4
53890: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53891: LD_ADDR_VAR 0 11
53895: PUSH
53896: LD_VAR 0 1
53900: PPUSH
53901: LD_VAR 0 2
53905: PPUSH
53906: LD_VAR 0 12
53910: PUSH
53911: LD_INT 1
53913: ARRAY
53914: PPUSH
53915: LD_VAR 0 12
53919: PUSH
53920: LD_INT 2
53922: ARRAY
53923: PPUSH
53924: CALL_OW 298
53928: ST_TO_ADDR
// distance := 9999 ;
53929: LD_ADDR_VAR 0 10
53933: PUSH
53934: LD_INT 9999
53936: ST_TO_ADDR
// for i := 0 to 5 do
53937: LD_ADDR_VAR 0 6
53941: PUSH
53942: DOUBLE
53943: LD_INT 0
53945: DEC
53946: ST_TO_ADDR
53947: LD_INT 5
53949: PUSH
53950: FOR_TO
53951: IFFALSE 54094
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53953: LD_ADDR_VAR 0 7
53957: PUSH
53958: LD_VAR 0 1
53962: PPUSH
53963: LD_VAR 0 6
53967: PPUSH
53968: LD_VAR 0 11
53972: PPUSH
53973: CALL_OW 272
53977: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53978: LD_ADDR_VAR 0 8
53982: PUSH
53983: LD_VAR 0 2
53987: PPUSH
53988: LD_VAR 0 6
53992: PPUSH
53993: LD_VAR 0 11
53997: PPUSH
53998: CALL_OW 273
54002: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54003: LD_VAR 0 7
54007: PPUSH
54008: LD_VAR 0 8
54012: PPUSH
54013: CALL_OW 488
54017: NOT
54018: IFFALSE 54022
// continue ;
54020: GO 53950
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54022: LD_ADDR_VAR 0 9
54026: PUSH
54027: LD_VAR 0 12
54031: PUSH
54032: LD_INT 1
54034: ARRAY
54035: PPUSH
54036: LD_VAR 0 12
54040: PUSH
54041: LD_INT 2
54043: ARRAY
54044: PPUSH
54045: LD_VAR 0 7
54049: PPUSH
54050: LD_VAR 0 8
54054: PPUSH
54055: CALL_OW 298
54059: ST_TO_ADDR
// if tmp < distance then
54060: LD_VAR 0 9
54064: PUSH
54065: LD_VAR 0 10
54069: LESS
54070: IFFALSE 54092
// begin result := i ;
54072: LD_ADDR_VAR 0 5
54076: PUSH
54077: LD_VAR 0 6
54081: ST_TO_ADDR
// distance := tmp ;
54082: LD_ADDR_VAR 0 10
54086: PUSH
54087: LD_VAR 0 9
54091: ST_TO_ADDR
// end ; end ;
54092: GO 53950
54094: POP
54095: POP
// end ;
54096: LD_VAR 0 5
54100: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54101: LD_INT 0
54103: PPUSH
54104: PPUSH
// if not driver or not IsInUnit ( driver ) then
54105: LD_VAR 0 1
54109: NOT
54110: PUSH
54111: LD_VAR 0 1
54115: PPUSH
54116: CALL_OW 310
54120: NOT
54121: OR
54122: IFFALSE 54126
// exit ;
54124: GO 54216
// vehicle := IsInUnit ( driver ) ;
54126: LD_ADDR_VAR 0 3
54130: PUSH
54131: LD_VAR 0 1
54135: PPUSH
54136: CALL_OW 310
54140: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54141: LD_VAR 0 1
54145: PPUSH
54146: LD_STRING \
54148: PUSH
54149: LD_INT 0
54151: PUSH
54152: LD_INT 0
54154: PUSH
54155: LD_INT 0
54157: PUSH
54158: LD_INT 0
54160: PUSH
54161: LD_INT 0
54163: PUSH
54164: LD_INT 0
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: LIST
54171: LIST
54172: LIST
54173: LIST
54174: LIST
54175: PUSH
54176: LD_STRING E
54178: PUSH
54179: LD_INT 0
54181: PUSH
54182: LD_INT 0
54184: PUSH
54185: LD_VAR 0 3
54189: PUSH
54190: LD_INT 0
54192: PUSH
54193: LD_INT 0
54195: PUSH
54196: LD_INT 0
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: LIST
54203: LIST
54204: LIST
54205: LIST
54206: LIST
54207: PUSH
54208: EMPTY
54209: LIST
54210: LIST
54211: PPUSH
54212: CALL_OW 446
// end ;
54216: LD_VAR 0 2
54220: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54221: LD_INT 0
54223: PPUSH
54224: PPUSH
// if not driver or not IsInUnit ( driver ) then
54225: LD_VAR 0 1
54229: NOT
54230: PUSH
54231: LD_VAR 0 1
54235: PPUSH
54236: CALL_OW 310
54240: NOT
54241: OR
54242: IFFALSE 54246
// exit ;
54244: GO 54336
// vehicle := IsInUnit ( driver ) ;
54246: LD_ADDR_VAR 0 3
54250: PUSH
54251: LD_VAR 0 1
54255: PPUSH
54256: CALL_OW 310
54260: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54261: LD_VAR 0 1
54265: PPUSH
54266: LD_STRING \
54268: PUSH
54269: LD_INT 0
54271: PUSH
54272: LD_INT 0
54274: PUSH
54275: LD_INT 0
54277: PUSH
54278: LD_INT 0
54280: PUSH
54281: LD_INT 0
54283: PUSH
54284: LD_INT 0
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: LIST
54291: LIST
54292: LIST
54293: LIST
54294: LIST
54295: PUSH
54296: LD_STRING E
54298: PUSH
54299: LD_INT 0
54301: PUSH
54302: LD_INT 0
54304: PUSH
54305: LD_VAR 0 3
54309: PUSH
54310: LD_INT 0
54312: PUSH
54313: LD_INT 0
54315: PUSH
54316: LD_INT 0
54318: PUSH
54319: EMPTY
54320: LIST
54321: LIST
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: PUSH
54328: EMPTY
54329: LIST
54330: LIST
54331: PPUSH
54332: CALL_OW 447
// end ;
54336: LD_VAR 0 2
54340: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54341: LD_INT 0
54343: PPUSH
54344: PPUSH
54345: PPUSH
// tmp := [ ] ;
54346: LD_ADDR_VAR 0 5
54350: PUSH
54351: EMPTY
54352: ST_TO_ADDR
// for i in units do
54353: LD_ADDR_VAR 0 4
54357: PUSH
54358: LD_VAR 0 1
54362: PUSH
54363: FOR_IN
54364: IFFALSE 54402
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54366: LD_ADDR_VAR 0 5
54370: PUSH
54371: LD_VAR 0 5
54375: PPUSH
54376: LD_VAR 0 5
54380: PUSH
54381: LD_INT 1
54383: PLUS
54384: PPUSH
54385: LD_VAR 0 4
54389: PPUSH
54390: CALL_OW 256
54394: PPUSH
54395: CALL_OW 2
54399: ST_TO_ADDR
54400: GO 54363
54402: POP
54403: POP
// if not tmp then
54404: LD_VAR 0 5
54408: NOT
54409: IFFALSE 54413
// exit ;
54411: GO 54461
// if asc then
54413: LD_VAR 0 2
54417: IFFALSE 54441
// result := SortListByListAsc ( units , tmp ) else
54419: LD_ADDR_VAR 0 3
54423: PUSH
54424: LD_VAR 0 1
54428: PPUSH
54429: LD_VAR 0 5
54433: PPUSH
54434: CALL_OW 76
54438: ST_TO_ADDR
54439: GO 54461
// result := SortListByListDesc ( units , tmp ) ;
54441: LD_ADDR_VAR 0 3
54445: PUSH
54446: LD_VAR 0 1
54450: PPUSH
54451: LD_VAR 0 5
54455: PPUSH
54456: CALL_OW 77
54460: ST_TO_ADDR
// end ;
54461: LD_VAR 0 3
54465: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54466: LD_INT 0
54468: PPUSH
54469: PPUSH
// task := GetTaskList ( mech ) ;
54470: LD_ADDR_VAR 0 4
54474: PUSH
54475: LD_VAR 0 1
54479: PPUSH
54480: CALL_OW 437
54484: ST_TO_ADDR
// if not task then
54485: LD_VAR 0 4
54489: NOT
54490: IFFALSE 54494
// exit ;
54492: GO 54536
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54494: LD_ADDR_VAR 0 3
54498: PUSH
54499: LD_VAR 0 4
54503: PUSH
54504: LD_INT 1
54506: ARRAY
54507: PUSH
54508: LD_INT 1
54510: ARRAY
54511: PUSH
54512: LD_STRING r
54514: EQUAL
54515: PUSH
54516: LD_VAR 0 4
54520: PUSH
54521: LD_INT 1
54523: ARRAY
54524: PUSH
54525: LD_INT 4
54527: ARRAY
54528: PUSH
54529: LD_VAR 0 2
54533: EQUAL
54534: AND
54535: ST_TO_ADDR
// end ;
54536: LD_VAR 0 3
54540: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54541: LD_INT 0
54543: PPUSH
// SetDir ( unit , d ) ;
54544: LD_VAR 0 1
54548: PPUSH
54549: LD_VAR 0 4
54553: PPUSH
54554: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54558: LD_VAR 0 1
54562: PPUSH
54563: LD_VAR 0 2
54567: PPUSH
54568: LD_VAR 0 3
54572: PPUSH
54573: LD_VAR 0 5
54577: PPUSH
54578: CALL_OW 48
// end ;
54582: LD_VAR 0 6
54586: RET
// export function ToNaturalNumber ( number ) ; begin
54587: LD_INT 0
54589: PPUSH
// result := number div 1 ;
54590: LD_ADDR_VAR 0 2
54594: PUSH
54595: LD_VAR 0 1
54599: PUSH
54600: LD_INT 1
54602: DIV
54603: ST_TO_ADDR
// if number < 0 then
54604: LD_VAR 0 1
54608: PUSH
54609: LD_INT 0
54611: LESS
54612: IFFALSE 54622
// result := 0 ;
54614: LD_ADDR_VAR 0 2
54618: PUSH
54619: LD_INT 0
54621: ST_TO_ADDR
// end ;
54622: LD_VAR 0 2
54626: RET
// export function SortByClass ( units , class ) ; var un ; begin
54627: LD_INT 0
54629: PPUSH
54630: PPUSH
// if not units or not class then
54631: LD_VAR 0 1
54635: NOT
54636: PUSH
54637: LD_VAR 0 2
54641: NOT
54642: OR
54643: IFFALSE 54647
// exit ;
54645: GO 54742
// result := [ ] ;
54647: LD_ADDR_VAR 0 3
54651: PUSH
54652: EMPTY
54653: ST_TO_ADDR
// for un in units do
54654: LD_ADDR_VAR 0 4
54658: PUSH
54659: LD_VAR 0 1
54663: PUSH
54664: FOR_IN
54665: IFFALSE 54740
// if GetClass ( un ) = class then
54667: LD_VAR 0 4
54671: PPUSH
54672: CALL_OW 257
54676: PUSH
54677: LD_VAR 0 2
54681: EQUAL
54682: IFFALSE 54709
// result := Insert ( result , 1 , un ) else
54684: LD_ADDR_VAR 0 3
54688: PUSH
54689: LD_VAR 0 3
54693: PPUSH
54694: LD_INT 1
54696: PPUSH
54697: LD_VAR 0 4
54701: PPUSH
54702: CALL_OW 2
54706: ST_TO_ADDR
54707: GO 54738
// result := Replace ( result , result + 1 , un ) ;
54709: LD_ADDR_VAR 0 3
54713: PUSH
54714: LD_VAR 0 3
54718: PPUSH
54719: LD_VAR 0 3
54723: PUSH
54724: LD_INT 1
54726: PLUS
54727: PPUSH
54728: LD_VAR 0 4
54732: PPUSH
54733: CALL_OW 1
54737: ST_TO_ADDR
54738: GO 54664
54740: POP
54741: POP
// end ;
54742: LD_VAR 0 3
54746: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54747: LD_INT 0
54749: PPUSH
54750: PPUSH
54751: PPUSH
54752: PPUSH
54753: PPUSH
54754: PPUSH
54755: PPUSH
// result := [ ] ;
54756: LD_ADDR_VAR 0 4
54760: PUSH
54761: EMPTY
54762: ST_TO_ADDR
// if x - r < 0 then
54763: LD_VAR 0 1
54767: PUSH
54768: LD_VAR 0 3
54772: MINUS
54773: PUSH
54774: LD_INT 0
54776: LESS
54777: IFFALSE 54789
// min_x := 0 else
54779: LD_ADDR_VAR 0 8
54783: PUSH
54784: LD_INT 0
54786: ST_TO_ADDR
54787: GO 54805
// min_x := x - r ;
54789: LD_ADDR_VAR 0 8
54793: PUSH
54794: LD_VAR 0 1
54798: PUSH
54799: LD_VAR 0 3
54803: MINUS
54804: ST_TO_ADDR
// if y - r < 0 then
54805: LD_VAR 0 2
54809: PUSH
54810: LD_VAR 0 3
54814: MINUS
54815: PUSH
54816: LD_INT 0
54818: LESS
54819: IFFALSE 54831
// min_y := 0 else
54821: LD_ADDR_VAR 0 7
54825: PUSH
54826: LD_INT 0
54828: ST_TO_ADDR
54829: GO 54847
// min_y := y - r ;
54831: LD_ADDR_VAR 0 7
54835: PUSH
54836: LD_VAR 0 2
54840: PUSH
54841: LD_VAR 0 3
54845: MINUS
54846: ST_TO_ADDR
// max_x := x + r ;
54847: LD_ADDR_VAR 0 9
54851: PUSH
54852: LD_VAR 0 1
54856: PUSH
54857: LD_VAR 0 3
54861: PLUS
54862: ST_TO_ADDR
// max_y := y + r ;
54863: LD_ADDR_VAR 0 10
54867: PUSH
54868: LD_VAR 0 2
54872: PUSH
54873: LD_VAR 0 3
54877: PLUS
54878: ST_TO_ADDR
// for _x = min_x to max_x do
54879: LD_ADDR_VAR 0 5
54883: PUSH
54884: DOUBLE
54885: LD_VAR 0 8
54889: DEC
54890: ST_TO_ADDR
54891: LD_VAR 0 9
54895: PUSH
54896: FOR_TO
54897: IFFALSE 54998
// for _y = min_y to max_y do
54899: LD_ADDR_VAR 0 6
54903: PUSH
54904: DOUBLE
54905: LD_VAR 0 7
54909: DEC
54910: ST_TO_ADDR
54911: LD_VAR 0 10
54915: PUSH
54916: FOR_TO
54917: IFFALSE 54994
// begin if not ValidHex ( _x , _y ) then
54919: LD_VAR 0 5
54923: PPUSH
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 488
54933: NOT
54934: IFFALSE 54938
// continue ;
54936: GO 54916
// if GetResourceTypeXY ( _x , _y ) then
54938: LD_VAR 0 5
54942: PPUSH
54943: LD_VAR 0 6
54947: PPUSH
54948: CALL_OW 283
54952: IFFALSE 54992
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54954: LD_ADDR_VAR 0 4
54958: PUSH
54959: LD_VAR 0 4
54963: PPUSH
54964: LD_VAR 0 4
54968: PUSH
54969: LD_INT 1
54971: PLUS
54972: PPUSH
54973: LD_VAR 0 5
54977: PUSH
54978: LD_VAR 0 6
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PPUSH
54987: CALL_OW 1
54991: ST_TO_ADDR
// end ;
54992: GO 54916
54994: POP
54995: POP
54996: GO 54896
54998: POP
54999: POP
// end ;
55000: LD_VAR 0 4
55004: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55005: LD_INT 0
55007: PPUSH
55008: PPUSH
55009: PPUSH
55010: PPUSH
55011: PPUSH
55012: PPUSH
55013: PPUSH
55014: PPUSH
// if not units then
55015: LD_VAR 0 1
55019: NOT
55020: IFFALSE 55024
// exit ;
55022: GO 55548
// result := UnitFilter ( units , [ f_ok ] ) ;
55024: LD_ADDR_VAR 0 3
55028: PUSH
55029: LD_VAR 0 1
55033: PPUSH
55034: LD_INT 50
55036: PUSH
55037: EMPTY
55038: LIST
55039: PPUSH
55040: CALL_OW 72
55044: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55045: LD_ADDR_VAR 0 8
55049: PUSH
55050: LD_VAR 0 1
55054: PUSH
55055: LD_INT 1
55057: ARRAY
55058: PPUSH
55059: CALL_OW 255
55063: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55064: LD_ADDR_VAR 0 10
55068: PUSH
55069: LD_INT 29
55071: PUSH
55072: LD_INT 91
55074: PUSH
55075: LD_INT 49
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: LIST
55082: ST_TO_ADDR
// if not result then
55083: LD_VAR 0 3
55087: NOT
55088: IFFALSE 55092
// exit ;
55090: GO 55548
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55092: LD_ADDR_VAR 0 5
55096: PUSH
55097: LD_INT 81
55099: PUSH
55100: LD_VAR 0 8
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: PPUSH
55109: CALL_OW 69
55113: ST_TO_ADDR
// for i in result do
55114: LD_ADDR_VAR 0 4
55118: PUSH
55119: LD_VAR 0 3
55123: PUSH
55124: FOR_IN
55125: IFFALSE 55546
// begin tag := GetTag ( i ) + 1 ;
55127: LD_ADDR_VAR 0 9
55131: PUSH
55132: LD_VAR 0 4
55136: PPUSH
55137: CALL_OW 110
55141: PUSH
55142: LD_INT 1
55144: PLUS
55145: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55146: LD_ADDR_VAR 0 7
55150: PUSH
55151: LD_VAR 0 4
55155: PPUSH
55156: CALL_OW 250
55160: PPUSH
55161: LD_VAR 0 4
55165: PPUSH
55166: CALL_OW 251
55170: PPUSH
55171: LD_INT 6
55173: PPUSH
55174: CALL 54747 0 3
55178: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55179: LD_VAR 0 4
55183: PPUSH
55184: CALL_OW 247
55188: PUSH
55189: LD_INT 2
55191: EQUAL
55192: PUSH
55193: LD_VAR 0 7
55197: AND
55198: PUSH
55199: LD_VAR 0 4
55203: PPUSH
55204: CALL_OW 264
55208: PUSH
55209: LD_VAR 0 10
55213: IN
55214: NOT
55215: AND
55216: IFFALSE 55255
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55218: LD_VAR 0 4
55222: PPUSH
55223: LD_VAR 0 7
55227: PUSH
55228: LD_INT 1
55230: ARRAY
55231: PUSH
55232: LD_INT 1
55234: ARRAY
55235: PPUSH
55236: LD_VAR 0 7
55240: PUSH
55241: LD_INT 1
55243: ARRAY
55244: PUSH
55245: LD_INT 2
55247: ARRAY
55248: PPUSH
55249: CALL_OW 116
55253: GO 55544
// if path > tag then
55255: LD_VAR 0 2
55259: PUSH
55260: LD_VAR 0 9
55264: GREATER
55265: IFFALSE 55473
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55267: LD_ADDR_VAR 0 6
55271: PUSH
55272: LD_VAR 0 5
55276: PPUSH
55277: LD_INT 91
55279: PUSH
55280: LD_VAR 0 4
55284: PUSH
55285: LD_INT 8
55287: PUSH
55288: EMPTY
55289: LIST
55290: LIST
55291: LIST
55292: PPUSH
55293: CALL_OW 72
55297: ST_TO_ADDR
// if nearEnemy then
55298: LD_VAR 0 6
55302: IFFALSE 55371
// begin if GetWeapon ( i ) = ru_time_lapser then
55304: LD_VAR 0 4
55308: PPUSH
55309: CALL_OW 264
55313: PUSH
55314: LD_INT 49
55316: EQUAL
55317: IFFALSE 55345
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55319: LD_VAR 0 4
55323: PPUSH
55324: LD_VAR 0 6
55328: PPUSH
55329: LD_VAR 0 4
55333: PPUSH
55334: CALL_OW 74
55338: PPUSH
55339: CALL_OW 112
55343: GO 55369
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55345: LD_VAR 0 4
55349: PPUSH
55350: LD_VAR 0 6
55354: PPUSH
55355: LD_VAR 0 4
55359: PPUSH
55360: CALL_OW 74
55364: PPUSH
55365: CALL_OW 115
// end else
55369: GO 55471
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55371: LD_VAR 0 4
55375: PPUSH
55376: LD_VAR 0 2
55380: PUSH
55381: LD_VAR 0 9
55385: ARRAY
55386: PUSH
55387: LD_INT 1
55389: ARRAY
55390: PPUSH
55391: LD_VAR 0 2
55395: PUSH
55396: LD_VAR 0 9
55400: ARRAY
55401: PUSH
55402: LD_INT 2
55404: ARRAY
55405: PPUSH
55406: CALL_OW 297
55410: PUSH
55411: LD_INT 6
55413: GREATER
55414: IFFALSE 55457
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55416: LD_VAR 0 4
55420: PPUSH
55421: LD_VAR 0 2
55425: PUSH
55426: LD_VAR 0 9
55430: ARRAY
55431: PUSH
55432: LD_INT 1
55434: ARRAY
55435: PPUSH
55436: LD_VAR 0 2
55440: PUSH
55441: LD_VAR 0 9
55445: ARRAY
55446: PUSH
55447: LD_INT 2
55449: ARRAY
55450: PPUSH
55451: CALL_OW 114
55455: GO 55471
// SetTag ( i , tag ) ;
55457: LD_VAR 0 4
55461: PPUSH
55462: LD_VAR 0 9
55466: PPUSH
55467: CALL_OW 109
// end else
55471: GO 55544
// if enemy then
55473: LD_VAR 0 5
55477: IFFALSE 55544
// begin if GetWeapon ( i ) = ru_time_lapser then
55479: LD_VAR 0 4
55483: PPUSH
55484: CALL_OW 264
55488: PUSH
55489: LD_INT 49
55491: EQUAL
55492: IFFALSE 55520
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55494: LD_VAR 0 4
55498: PPUSH
55499: LD_VAR 0 5
55503: PPUSH
55504: LD_VAR 0 4
55508: PPUSH
55509: CALL_OW 74
55513: PPUSH
55514: CALL_OW 112
55518: GO 55544
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55520: LD_VAR 0 4
55524: PPUSH
55525: LD_VAR 0 5
55529: PPUSH
55530: LD_VAR 0 4
55534: PPUSH
55535: CALL_OW 74
55539: PPUSH
55540: CALL_OW 115
// end ; end ;
55544: GO 55124
55546: POP
55547: POP
// end ;
55548: LD_VAR 0 3
55552: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55553: LD_INT 0
55555: PPUSH
55556: PPUSH
55557: PPUSH
// if not unit or IsInUnit ( unit ) then
55558: LD_VAR 0 1
55562: NOT
55563: PUSH
55564: LD_VAR 0 1
55568: PPUSH
55569: CALL_OW 310
55573: OR
55574: IFFALSE 55578
// exit ;
55576: GO 55669
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55578: LD_ADDR_VAR 0 4
55582: PUSH
55583: LD_VAR 0 1
55587: PPUSH
55588: CALL_OW 250
55592: PPUSH
55593: LD_VAR 0 2
55597: PPUSH
55598: LD_INT 1
55600: PPUSH
55601: CALL_OW 272
55605: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55606: LD_ADDR_VAR 0 5
55610: PUSH
55611: LD_VAR 0 1
55615: PPUSH
55616: CALL_OW 251
55620: PPUSH
55621: LD_VAR 0 2
55625: PPUSH
55626: LD_INT 1
55628: PPUSH
55629: CALL_OW 273
55633: ST_TO_ADDR
// if ValidHex ( x , y ) then
55634: LD_VAR 0 4
55638: PPUSH
55639: LD_VAR 0 5
55643: PPUSH
55644: CALL_OW 488
55648: IFFALSE 55669
// ComTurnXY ( unit , x , y ) ;
55650: LD_VAR 0 1
55654: PPUSH
55655: LD_VAR 0 4
55659: PPUSH
55660: LD_VAR 0 5
55664: PPUSH
55665: CALL_OW 118
// end ;
55669: LD_VAR 0 3
55673: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55674: LD_INT 0
55676: PPUSH
55677: PPUSH
// result := false ;
55678: LD_ADDR_VAR 0 3
55682: PUSH
55683: LD_INT 0
55685: ST_TO_ADDR
// if not units then
55686: LD_VAR 0 2
55690: NOT
55691: IFFALSE 55695
// exit ;
55693: GO 55740
// for i in units do
55695: LD_ADDR_VAR 0 4
55699: PUSH
55700: LD_VAR 0 2
55704: PUSH
55705: FOR_IN
55706: IFFALSE 55738
// if See ( side , i ) then
55708: LD_VAR 0 1
55712: PPUSH
55713: LD_VAR 0 4
55717: PPUSH
55718: CALL_OW 292
55722: IFFALSE 55736
// begin result := true ;
55724: LD_ADDR_VAR 0 3
55728: PUSH
55729: LD_INT 1
55731: ST_TO_ADDR
// exit ;
55732: POP
55733: POP
55734: GO 55740
// end ;
55736: GO 55705
55738: POP
55739: POP
// end ;
55740: LD_VAR 0 3
55744: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55745: LD_INT 0
55747: PPUSH
55748: PPUSH
55749: PPUSH
55750: PPUSH
// if not unit or not points then
55751: LD_VAR 0 1
55755: NOT
55756: PUSH
55757: LD_VAR 0 2
55761: NOT
55762: OR
55763: IFFALSE 55767
// exit ;
55765: GO 55857
// dist := 99999 ;
55767: LD_ADDR_VAR 0 5
55771: PUSH
55772: LD_INT 99999
55774: ST_TO_ADDR
// for i in points do
55775: LD_ADDR_VAR 0 4
55779: PUSH
55780: LD_VAR 0 2
55784: PUSH
55785: FOR_IN
55786: IFFALSE 55855
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55788: LD_ADDR_VAR 0 6
55792: PUSH
55793: LD_VAR 0 1
55797: PPUSH
55798: LD_VAR 0 4
55802: PUSH
55803: LD_INT 1
55805: ARRAY
55806: PPUSH
55807: LD_VAR 0 4
55811: PUSH
55812: LD_INT 2
55814: ARRAY
55815: PPUSH
55816: CALL_OW 297
55820: ST_TO_ADDR
// if tmpDist < dist then
55821: LD_VAR 0 6
55825: PUSH
55826: LD_VAR 0 5
55830: LESS
55831: IFFALSE 55853
// begin result := i ;
55833: LD_ADDR_VAR 0 3
55837: PUSH
55838: LD_VAR 0 4
55842: ST_TO_ADDR
// dist := tmpDist ;
55843: LD_ADDR_VAR 0 5
55847: PUSH
55848: LD_VAR 0 6
55852: ST_TO_ADDR
// end ; end ;
55853: GO 55785
55855: POP
55856: POP
// end ;
55857: LD_VAR 0 3
55861: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55862: LD_INT 0
55864: PPUSH
// uc_side := side ;
55865: LD_ADDR_OWVAR 20
55869: PUSH
55870: LD_VAR 0 1
55874: ST_TO_ADDR
// uc_nation := 3 ;
55875: LD_ADDR_OWVAR 21
55879: PUSH
55880: LD_INT 3
55882: ST_TO_ADDR
// vc_chassis := 25 ;
55883: LD_ADDR_OWVAR 37
55887: PUSH
55888: LD_INT 25
55890: ST_TO_ADDR
// vc_engine := engine_siberite ;
55891: LD_ADDR_OWVAR 39
55895: PUSH
55896: LD_INT 3
55898: ST_TO_ADDR
// vc_control := control_computer ;
55899: LD_ADDR_OWVAR 38
55903: PUSH
55904: LD_INT 3
55906: ST_TO_ADDR
// vc_weapon := 59 ;
55907: LD_ADDR_OWVAR 40
55911: PUSH
55912: LD_INT 59
55914: ST_TO_ADDR
// result := CreateVehicle ;
55915: LD_ADDR_VAR 0 5
55919: PUSH
55920: CALL_OW 45
55924: ST_TO_ADDR
// SetDir ( result , d ) ;
55925: LD_VAR 0 5
55929: PPUSH
55930: LD_VAR 0 4
55934: PPUSH
55935: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55939: LD_VAR 0 5
55943: PPUSH
55944: LD_VAR 0 2
55948: PPUSH
55949: LD_VAR 0 3
55953: PPUSH
55954: LD_INT 0
55956: PPUSH
55957: CALL_OW 48
// end ;
55961: LD_VAR 0 5
55965: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55966: LD_INT 0
55968: PPUSH
55969: PPUSH
55970: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55971: LD_ADDR_VAR 0 2
55975: PUSH
55976: LD_INT 0
55978: PUSH
55979: LD_INT 0
55981: PUSH
55982: LD_INT 0
55984: PUSH
55985: LD_INT 0
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: LIST
55992: LIST
55993: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55994: LD_VAR 0 1
55998: NOT
55999: PUSH
56000: LD_VAR 0 1
56004: PPUSH
56005: CALL_OW 264
56009: PUSH
56010: LD_INT 12
56012: PUSH
56013: LD_INT 51
56015: PUSH
56016: LD_INT 32
56018: PUSH
56019: LD_INT 89
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: LIST
56026: LIST
56027: IN
56028: NOT
56029: OR
56030: IFFALSE 56034
// exit ;
56032: GO 56132
// for i := 1 to 3 do
56034: LD_ADDR_VAR 0 3
56038: PUSH
56039: DOUBLE
56040: LD_INT 1
56042: DEC
56043: ST_TO_ADDR
56044: LD_INT 3
56046: PUSH
56047: FOR_TO
56048: IFFALSE 56130
// begin tmp := GetCargo ( cargo , i ) ;
56050: LD_ADDR_VAR 0 4
56054: PUSH
56055: LD_VAR 0 1
56059: PPUSH
56060: LD_VAR 0 3
56064: PPUSH
56065: CALL_OW 289
56069: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56070: LD_ADDR_VAR 0 2
56074: PUSH
56075: LD_VAR 0 2
56079: PPUSH
56080: LD_VAR 0 3
56084: PPUSH
56085: LD_VAR 0 4
56089: PPUSH
56090: CALL_OW 1
56094: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56095: LD_ADDR_VAR 0 2
56099: PUSH
56100: LD_VAR 0 2
56104: PPUSH
56105: LD_INT 4
56107: PPUSH
56108: LD_VAR 0 2
56112: PUSH
56113: LD_INT 4
56115: ARRAY
56116: PUSH
56117: LD_VAR 0 4
56121: PLUS
56122: PPUSH
56123: CALL_OW 1
56127: ST_TO_ADDR
// end ;
56128: GO 56047
56130: POP
56131: POP
// end ;
56132: LD_VAR 0 2
56136: RET
// export function Length ( array ) ; begin
56137: LD_INT 0
56139: PPUSH
// result := array + 0 ;
56140: LD_ADDR_VAR 0 2
56144: PUSH
56145: LD_VAR 0 1
56149: PUSH
56150: LD_INT 0
56152: PLUS
56153: ST_TO_ADDR
// end ;
56154: LD_VAR 0 2
56158: RET
// export function PrepareArray ( array ) ; begin
56159: LD_INT 0
56161: PPUSH
// result := array diff 0 ;
56162: LD_ADDR_VAR 0 2
56166: PUSH
56167: LD_VAR 0 1
56171: PUSH
56172: LD_INT 0
56174: DIFF
56175: ST_TO_ADDR
// if not result [ 1 ] then
56176: LD_VAR 0 2
56180: PUSH
56181: LD_INT 1
56183: ARRAY
56184: NOT
56185: IFFALSE 56205
// result := Delete ( result , 1 ) ;
56187: LD_ADDR_VAR 0 2
56191: PUSH
56192: LD_VAR 0 2
56196: PPUSH
56197: LD_INT 1
56199: PPUSH
56200: CALL_OW 3
56204: ST_TO_ADDR
// end ;
56205: LD_VAR 0 2
56209: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56210: LD_INT 0
56212: PPUSH
56213: PPUSH
56214: PPUSH
56215: PPUSH
// sibRocketRange := 25 ;
56216: LD_ADDR_VAR 0 6
56220: PUSH
56221: LD_INT 25
56223: ST_TO_ADDR
// result := false ;
56224: LD_ADDR_VAR 0 4
56228: PUSH
56229: LD_INT 0
56231: ST_TO_ADDR
// for i := 0 to 5 do
56232: LD_ADDR_VAR 0 5
56236: PUSH
56237: DOUBLE
56238: LD_INT 0
56240: DEC
56241: ST_TO_ADDR
56242: LD_INT 5
56244: PUSH
56245: FOR_TO
56246: IFFALSE 56313
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56248: LD_VAR 0 1
56252: PPUSH
56253: LD_VAR 0 5
56257: PPUSH
56258: LD_VAR 0 6
56262: PPUSH
56263: CALL_OW 272
56267: PPUSH
56268: LD_VAR 0 2
56272: PPUSH
56273: LD_VAR 0 5
56277: PPUSH
56278: LD_VAR 0 6
56282: PPUSH
56283: CALL_OW 273
56287: PPUSH
56288: LD_VAR 0 3
56292: PPUSH
56293: CALL_OW 309
56297: IFFALSE 56311
// begin result := true ;
56299: LD_ADDR_VAR 0 4
56303: PUSH
56304: LD_INT 1
56306: ST_TO_ADDR
// exit ;
56307: POP
56308: POP
56309: GO 56315
// end ;
56311: GO 56245
56313: POP
56314: POP
// end ;
56315: LD_VAR 0 4
56319: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56320: LD_INT 0
56322: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56323: LD_VAR 0 1
56327: PPUSH
56328: LD_VAR 0 2
56332: PPUSH
56333: LD_INT 0
56335: PPUSH
56336: LD_INT 0
56338: PPUSH
56339: LD_INT 1
56341: PPUSH
56342: LD_INT 0
56344: PPUSH
56345: CALL_OW 587
// end ; end_of_file
56349: LD_VAR 0 3
56353: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
56354: LD_INT 0
56356: PPUSH
56357: PPUSH
// skirmish := false ;
56358: LD_ADDR_EXP 59
56362: PUSH
56363: LD_INT 0
56365: ST_TO_ADDR
// debug_mc := false ;
56366: LD_ADDR_EXP 60
56370: PUSH
56371: LD_INT 0
56373: ST_TO_ADDR
// mc_bases := [ ] ;
56374: LD_ADDR_EXP 61
56378: PUSH
56379: EMPTY
56380: ST_TO_ADDR
// mc_sides := [ ] ;
56381: LD_ADDR_EXP 87
56385: PUSH
56386: EMPTY
56387: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56388: LD_ADDR_EXP 62
56392: PUSH
56393: EMPTY
56394: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56395: LD_ADDR_EXP 63
56399: PUSH
56400: EMPTY
56401: ST_TO_ADDR
// mc_need_heal := [ ] ;
56402: LD_ADDR_EXP 64
56406: PUSH
56407: EMPTY
56408: ST_TO_ADDR
// mc_healers := [ ] ;
56409: LD_ADDR_EXP 65
56413: PUSH
56414: EMPTY
56415: ST_TO_ADDR
// mc_build_list := [ ] ;
56416: LD_ADDR_EXP 66
56420: PUSH
56421: EMPTY
56422: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56423: LD_ADDR_EXP 93
56427: PUSH
56428: EMPTY
56429: ST_TO_ADDR
// mc_builders := [ ] ;
56430: LD_ADDR_EXP 67
56434: PUSH
56435: EMPTY
56436: ST_TO_ADDR
// mc_construct_list := [ ] ;
56437: LD_ADDR_EXP 68
56441: PUSH
56442: EMPTY
56443: ST_TO_ADDR
// mc_turret_list := [ ] ;
56444: LD_ADDR_EXP 69
56448: PUSH
56449: EMPTY
56450: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56451: LD_ADDR_EXP 70
56455: PUSH
56456: EMPTY
56457: ST_TO_ADDR
// mc_miners := [ ] ;
56458: LD_ADDR_EXP 75
56462: PUSH
56463: EMPTY
56464: ST_TO_ADDR
// mc_mines := [ ] ;
56465: LD_ADDR_EXP 74
56469: PUSH
56470: EMPTY
56471: ST_TO_ADDR
// mc_minefields := [ ] ;
56472: LD_ADDR_EXP 76
56476: PUSH
56477: EMPTY
56478: ST_TO_ADDR
// mc_crates := [ ] ;
56479: LD_ADDR_EXP 77
56483: PUSH
56484: EMPTY
56485: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56486: LD_ADDR_EXP 78
56490: PUSH
56491: EMPTY
56492: ST_TO_ADDR
// mc_crates_area := [ ] ;
56493: LD_ADDR_EXP 79
56497: PUSH
56498: EMPTY
56499: ST_TO_ADDR
// mc_vehicles := [ ] ;
56500: LD_ADDR_EXP 80
56504: PUSH
56505: EMPTY
56506: ST_TO_ADDR
// mc_attack := [ ] ;
56507: LD_ADDR_EXP 81
56511: PUSH
56512: EMPTY
56513: ST_TO_ADDR
// mc_produce := [ ] ;
56514: LD_ADDR_EXP 82
56518: PUSH
56519: EMPTY
56520: ST_TO_ADDR
// mc_defender := [ ] ;
56521: LD_ADDR_EXP 83
56525: PUSH
56526: EMPTY
56527: ST_TO_ADDR
// mc_parking := [ ] ;
56528: LD_ADDR_EXP 85
56532: PUSH
56533: EMPTY
56534: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56535: LD_ADDR_EXP 71
56539: PUSH
56540: EMPTY
56541: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56542: LD_ADDR_EXP 73
56546: PUSH
56547: EMPTY
56548: ST_TO_ADDR
// mc_scan := [ ] ;
56549: LD_ADDR_EXP 84
56553: PUSH
56554: EMPTY
56555: ST_TO_ADDR
// mc_scan_area := [ ] ;
56556: LD_ADDR_EXP 86
56560: PUSH
56561: EMPTY
56562: ST_TO_ADDR
// mc_tech := [ ] ;
56563: LD_ADDR_EXP 88
56567: PUSH
56568: EMPTY
56569: ST_TO_ADDR
// mc_class := [ ] ;
56570: LD_ADDR_EXP 102
56574: PUSH
56575: EMPTY
56576: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56577: LD_ADDR_EXP 103
56581: PUSH
56582: EMPTY
56583: ST_TO_ADDR
// mc_is_defending := [ ] ;
56584: LD_ADDR_EXP 104
56588: PUSH
56589: EMPTY
56590: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
56591: LD_ADDR_EXP 95
56595: PUSH
56596: EMPTY
56597: ST_TO_ADDR
// end ;
56598: LD_VAR 0 1
56602: RET
// export function MC_Kill ( base ) ; begin
56603: LD_INT 0
56605: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56606: LD_ADDR_EXP 61
56610: PUSH
56611: LD_EXP 61
56615: PPUSH
56616: LD_VAR 0 1
56620: PPUSH
56621: EMPTY
56622: PPUSH
56623: CALL_OW 1
56627: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56628: LD_ADDR_EXP 62
56632: PUSH
56633: LD_EXP 62
56637: PPUSH
56638: LD_VAR 0 1
56642: PPUSH
56643: EMPTY
56644: PPUSH
56645: CALL_OW 1
56649: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56650: LD_ADDR_EXP 63
56654: PUSH
56655: LD_EXP 63
56659: PPUSH
56660: LD_VAR 0 1
56664: PPUSH
56665: EMPTY
56666: PPUSH
56667: CALL_OW 1
56671: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56672: LD_ADDR_EXP 64
56676: PUSH
56677: LD_EXP 64
56681: PPUSH
56682: LD_VAR 0 1
56686: PPUSH
56687: EMPTY
56688: PPUSH
56689: CALL_OW 1
56693: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56694: LD_ADDR_EXP 65
56698: PUSH
56699: LD_EXP 65
56703: PPUSH
56704: LD_VAR 0 1
56708: PPUSH
56709: EMPTY
56710: PPUSH
56711: CALL_OW 1
56715: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56716: LD_ADDR_EXP 66
56720: PUSH
56721: LD_EXP 66
56725: PPUSH
56726: LD_VAR 0 1
56730: PPUSH
56731: EMPTY
56732: PPUSH
56733: CALL_OW 1
56737: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56738: LD_ADDR_EXP 67
56742: PUSH
56743: LD_EXP 67
56747: PPUSH
56748: LD_VAR 0 1
56752: PPUSH
56753: EMPTY
56754: PPUSH
56755: CALL_OW 1
56759: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56760: LD_ADDR_EXP 68
56764: PUSH
56765: LD_EXP 68
56769: PPUSH
56770: LD_VAR 0 1
56774: PPUSH
56775: EMPTY
56776: PPUSH
56777: CALL_OW 1
56781: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56782: LD_ADDR_EXP 69
56786: PUSH
56787: LD_EXP 69
56791: PPUSH
56792: LD_VAR 0 1
56796: PPUSH
56797: EMPTY
56798: PPUSH
56799: CALL_OW 1
56803: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56804: LD_ADDR_EXP 70
56808: PUSH
56809: LD_EXP 70
56813: PPUSH
56814: LD_VAR 0 1
56818: PPUSH
56819: EMPTY
56820: PPUSH
56821: CALL_OW 1
56825: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56826: LD_ADDR_EXP 71
56830: PUSH
56831: LD_EXP 71
56835: PPUSH
56836: LD_VAR 0 1
56840: PPUSH
56841: EMPTY
56842: PPUSH
56843: CALL_OW 1
56847: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56848: LD_ADDR_EXP 72
56852: PUSH
56853: LD_EXP 72
56857: PPUSH
56858: LD_VAR 0 1
56862: PPUSH
56863: LD_INT 0
56865: PPUSH
56866: CALL_OW 1
56870: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56871: LD_ADDR_EXP 73
56875: PUSH
56876: LD_EXP 73
56880: PPUSH
56881: LD_VAR 0 1
56885: PPUSH
56886: EMPTY
56887: PPUSH
56888: CALL_OW 1
56892: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56893: LD_ADDR_EXP 74
56897: PUSH
56898: LD_EXP 74
56902: PPUSH
56903: LD_VAR 0 1
56907: PPUSH
56908: EMPTY
56909: PPUSH
56910: CALL_OW 1
56914: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56915: LD_ADDR_EXP 75
56919: PUSH
56920: LD_EXP 75
56924: PPUSH
56925: LD_VAR 0 1
56929: PPUSH
56930: EMPTY
56931: PPUSH
56932: CALL_OW 1
56936: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56937: LD_ADDR_EXP 76
56941: PUSH
56942: LD_EXP 76
56946: PPUSH
56947: LD_VAR 0 1
56951: PPUSH
56952: EMPTY
56953: PPUSH
56954: CALL_OW 1
56958: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56959: LD_ADDR_EXP 77
56963: PUSH
56964: LD_EXP 77
56968: PPUSH
56969: LD_VAR 0 1
56973: PPUSH
56974: EMPTY
56975: PPUSH
56976: CALL_OW 1
56980: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56981: LD_ADDR_EXP 78
56985: PUSH
56986: LD_EXP 78
56990: PPUSH
56991: LD_VAR 0 1
56995: PPUSH
56996: EMPTY
56997: PPUSH
56998: CALL_OW 1
57002: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57003: LD_ADDR_EXP 79
57007: PUSH
57008: LD_EXP 79
57012: PPUSH
57013: LD_VAR 0 1
57017: PPUSH
57018: EMPTY
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57025: LD_ADDR_EXP 80
57029: PUSH
57030: LD_EXP 80
57034: PPUSH
57035: LD_VAR 0 1
57039: PPUSH
57040: EMPTY
57041: PPUSH
57042: CALL_OW 1
57046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57047: LD_ADDR_EXP 81
57051: PUSH
57052: LD_EXP 81
57056: PPUSH
57057: LD_VAR 0 1
57061: PPUSH
57062: EMPTY
57063: PPUSH
57064: CALL_OW 1
57068: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57069: LD_ADDR_EXP 82
57073: PUSH
57074: LD_EXP 82
57078: PPUSH
57079: LD_VAR 0 1
57083: PPUSH
57084: EMPTY
57085: PPUSH
57086: CALL_OW 1
57090: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57091: LD_ADDR_EXP 83
57095: PUSH
57096: LD_EXP 83
57100: PPUSH
57101: LD_VAR 0 1
57105: PPUSH
57106: EMPTY
57107: PPUSH
57108: CALL_OW 1
57112: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57113: LD_ADDR_EXP 84
57117: PUSH
57118: LD_EXP 84
57122: PPUSH
57123: LD_VAR 0 1
57127: PPUSH
57128: EMPTY
57129: PPUSH
57130: CALL_OW 1
57134: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57135: LD_ADDR_EXP 85
57139: PUSH
57140: LD_EXP 85
57144: PPUSH
57145: LD_VAR 0 1
57149: PPUSH
57150: EMPTY
57151: PPUSH
57152: CALL_OW 1
57156: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57157: LD_ADDR_EXP 86
57161: PUSH
57162: LD_EXP 86
57166: PPUSH
57167: LD_VAR 0 1
57171: PPUSH
57172: EMPTY
57173: PPUSH
57174: CALL_OW 1
57178: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57179: LD_ADDR_EXP 88
57183: PUSH
57184: LD_EXP 88
57188: PPUSH
57189: LD_VAR 0 1
57193: PPUSH
57194: EMPTY
57195: PPUSH
57196: CALL_OW 1
57200: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57201: LD_ADDR_EXP 90
57205: PUSH
57206: LD_EXP 90
57210: PPUSH
57211: LD_VAR 0 1
57215: PPUSH
57216: EMPTY
57217: PPUSH
57218: CALL_OW 1
57222: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57223: LD_ADDR_EXP 91
57227: PUSH
57228: LD_EXP 91
57232: PPUSH
57233: LD_VAR 0 1
57237: PPUSH
57238: EMPTY
57239: PPUSH
57240: CALL_OW 1
57244: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57245: LD_ADDR_EXP 92
57249: PUSH
57250: LD_EXP 92
57254: PPUSH
57255: LD_VAR 0 1
57259: PPUSH
57260: EMPTY
57261: PPUSH
57262: CALL_OW 1
57266: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57267: LD_ADDR_EXP 93
57271: PUSH
57272: LD_EXP 93
57276: PPUSH
57277: LD_VAR 0 1
57281: PPUSH
57282: EMPTY
57283: PPUSH
57284: CALL_OW 1
57288: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57289: LD_ADDR_EXP 94
57293: PUSH
57294: LD_EXP 94
57298: PPUSH
57299: LD_VAR 0 1
57303: PPUSH
57304: EMPTY
57305: PPUSH
57306: CALL_OW 1
57310: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57311: LD_ADDR_EXP 95
57315: PUSH
57316: LD_EXP 95
57320: PPUSH
57321: LD_VAR 0 1
57325: PPUSH
57326: EMPTY
57327: PPUSH
57328: CALL_OW 1
57332: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57333: LD_ADDR_EXP 96
57337: PUSH
57338: LD_EXP 96
57342: PPUSH
57343: LD_VAR 0 1
57347: PPUSH
57348: EMPTY
57349: PPUSH
57350: CALL_OW 1
57354: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57355: LD_ADDR_EXP 97
57359: PUSH
57360: LD_EXP 97
57364: PPUSH
57365: LD_VAR 0 1
57369: PPUSH
57370: EMPTY
57371: PPUSH
57372: CALL_OW 1
57376: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57377: LD_ADDR_EXP 98
57381: PUSH
57382: LD_EXP 98
57386: PPUSH
57387: LD_VAR 0 1
57391: PPUSH
57392: EMPTY
57393: PPUSH
57394: CALL_OW 1
57398: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57399: LD_ADDR_EXP 99
57403: PUSH
57404: LD_EXP 99
57408: PPUSH
57409: LD_VAR 0 1
57413: PPUSH
57414: EMPTY
57415: PPUSH
57416: CALL_OW 1
57420: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57421: LD_ADDR_EXP 100
57425: PUSH
57426: LD_EXP 100
57430: PPUSH
57431: LD_VAR 0 1
57435: PPUSH
57436: EMPTY
57437: PPUSH
57438: CALL_OW 1
57442: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57443: LD_ADDR_EXP 101
57447: PUSH
57448: LD_EXP 101
57452: PPUSH
57453: LD_VAR 0 1
57457: PPUSH
57458: EMPTY
57459: PPUSH
57460: CALL_OW 1
57464: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57465: LD_ADDR_EXP 102
57469: PUSH
57470: LD_EXP 102
57474: PPUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: EMPTY
57481: PPUSH
57482: CALL_OW 1
57486: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57487: LD_ADDR_EXP 103
57491: PUSH
57492: LD_EXP 103
57496: PPUSH
57497: LD_VAR 0 1
57501: PPUSH
57502: LD_INT 0
57504: PPUSH
57505: CALL_OW 1
57509: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57510: LD_ADDR_EXP 104
57514: PUSH
57515: LD_EXP 104
57519: PPUSH
57520: LD_VAR 0 1
57524: PPUSH
57525: LD_INT 0
57527: PPUSH
57528: CALL_OW 1
57532: ST_TO_ADDR
// end ;
57533: LD_VAR 0 2
57537: RET
// export function MC_Add ( side , units ) ; var base ; begin
57538: LD_INT 0
57540: PPUSH
57541: PPUSH
// base := mc_bases + 1 ;
57542: LD_ADDR_VAR 0 4
57546: PUSH
57547: LD_EXP 61
57551: PUSH
57552: LD_INT 1
57554: PLUS
57555: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57556: LD_ADDR_EXP 87
57560: PUSH
57561: LD_EXP 87
57565: PPUSH
57566: LD_VAR 0 4
57570: PPUSH
57571: LD_VAR 0 1
57575: PPUSH
57576: CALL_OW 1
57580: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57581: LD_ADDR_EXP 61
57585: PUSH
57586: LD_EXP 61
57590: PPUSH
57591: LD_VAR 0 4
57595: PPUSH
57596: LD_VAR 0 2
57600: PPUSH
57601: CALL_OW 1
57605: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57606: LD_ADDR_EXP 62
57610: PUSH
57611: LD_EXP 62
57615: PPUSH
57616: LD_VAR 0 4
57620: PPUSH
57621: EMPTY
57622: PPUSH
57623: CALL_OW 1
57627: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57628: LD_ADDR_EXP 63
57632: PUSH
57633: LD_EXP 63
57637: PPUSH
57638: LD_VAR 0 4
57642: PPUSH
57643: EMPTY
57644: PPUSH
57645: CALL_OW 1
57649: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57650: LD_ADDR_EXP 64
57654: PUSH
57655: LD_EXP 64
57659: PPUSH
57660: LD_VAR 0 4
57664: PPUSH
57665: EMPTY
57666: PPUSH
57667: CALL_OW 1
57671: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57672: LD_ADDR_EXP 65
57676: PUSH
57677: LD_EXP 65
57681: PPUSH
57682: LD_VAR 0 4
57686: PPUSH
57687: EMPTY
57688: PPUSH
57689: CALL_OW 1
57693: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57694: LD_ADDR_EXP 66
57698: PUSH
57699: LD_EXP 66
57703: PPUSH
57704: LD_VAR 0 4
57708: PPUSH
57709: EMPTY
57710: PPUSH
57711: CALL_OW 1
57715: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57716: LD_ADDR_EXP 67
57720: PUSH
57721: LD_EXP 67
57725: PPUSH
57726: LD_VAR 0 4
57730: PPUSH
57731: EMPTY
57732: PPUSH
57733: CALL_OW 1
57737: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57738: LD_ADDR_EXP 68
57742: PUSH
57743: LD_EXP 68
57747: PPUSH
57748: LD_VAR 0 4
57752: PPUSH
57753: EMPTY
57754: PPUSH
57755: CALL_OW 1
57759: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57760: LD_ADDR_EXP 69
57764: PUSH
57765: LD_EXP 69
57769: PPUSH
57770: LD_VAR 0 4
57774: PPUSH
57775: EMPTY
57776: PPUSH
57777: CALL_OW 1
57781: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57782: LD_ADDR_EXP 70
57786: PUSH
57787: LD_EXP 70
57791: PPUSH
57792: LD_VAR 0 4
57796: PPUSH
57797: EMPTY
57798: PPUSH
57799: CALL_OW 1
57803: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57804: LD_ADDR_EXP 71
57808: PUSH
57809: LD_EXP 71
57813: PPUSH
57814: LD_VAR 0 4
57818: PPUSH
57819: EMPTY
57820: PPUSH
57821: CALL_OW 1
57825: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57826: LD_ADDR_EXP 72
57830: PUSH
57831: LD_EXP 72
57835: PPUSH
57836: LD_VAR 0 4
57840: PPUSH
57841: LD_INT 0
57843: PPUSH
57844: CALL_OW 1
57848: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57849: LD_ADDR_EXP 73
57853: PUSH
57854: LD_EXP 73
57858: PPUSH
57859: LD_VAR 0 4
57863: PPUSH
57864: EMPTY
57865: PPUSH
57866: CALL_OW 1
57870: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57871: LD_ADDR_EXP 74
57875: PUSH
57876: LD_EXP 74
57880: PPUSH
57881: LD_VAR 0 4
57885: PPUSH
57886: EMPTY
57887: PPUSH
57888: CALL_OW 1
57892: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57893: LD_ADDR_EXP 75
57897: PUSH
57898: LD_EXP 75
57902: PPUSH
57903: LD_VAR 0 4
57907: PPUSH
57908: EMPTY
57909: PPUSH
57910: CALL_OW 1
57914: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57915: LD_ADDR_EXP 76
57919: PUSH
57920: LD_EXP 76
57924: PPUSH
57925: LD_VAR 0 4
57929: PPUSH
57930: EMPTY
57931: PPUSH
57932: CALL_OW 1
57936: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57937: LD_ADDR_EXP 77
57941: PUSH
57942: LD_EXP 77
57946: PPUSH
57947: LD_VAR 0 4
57951: PPUSH
57952: EMPTY
57953: PPUSH
57954: CALL_OW 1
57958: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57959: LD_ADDR_EXP 78
57963: PUSH
57964: LD_EXP 78
57968: PPUSH
57969: LD_VAR 0 4
57973: PPUSH
57974: EMPTY
57975: PPUSH
57976: CALL_OW 1
57980: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57981: LD_ADDR_EXP 79
57985: PUSH
57986: LD_EXP 79
57990: PPUSH
57991: LD_VAR 0 4
57995: PPUSH
57996: EMPTY
57997: PPUSH
57998: CALL_OW 1
58002: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58003: LD_ADDR_EXP 80
58007: PUSH
58008: LD_EXP 80
58012: PPUSH
58013: LD_VAR 0 4
58017: PPUSH
58018: EMPTY
58019: PPUSH
58020: CALL_OW 1
58024: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58025: LD_ADDR_EXP 81
58029: PUSH
58030: LD_EXP 81
58034: PPUSH
58035: LD_VAR 0 4
58039: PPUSH
58040: EMPTY
58041: PPUSH
58042: CALL_OW 1
58046: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58047: LD_ADDR_EXP 82
58051: PUSH
58052: LD_EXP 82
58056: PPUSH
58057: LD_VAR 0 4
58061: PPUSH
58062: EMPTY
58063: PPUSH
58064: CALL_OW 1
58068: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58069: LD_ADDR_EXP 83
58073: PUSH
58074: LD_EXP 83
58078: PPUSH
58079: LD_VAR 0 4
58083: PPUSH
58084: EMPTY
58085: PPUSH
58086: CALL_OW 1
58090: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58091: LD_ADDR_EXP 84
58095: PUSH
58096: LD_EXP 84
58100: PPUSH
58101: LD_VAR 0 4
58105: PPUSH
58106: EMPTY
58107: PPUSH
58108: CALL_OW 1
58112: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58113: LD_ADDR_EXP 85
58117: PUSH
58118: LD_EXP 85
58122: PPUSH
58123: LD_VAR 0 4
58127: PPUSH
58128: EMPTY
58129: PPUSH
58130: CALL_OW 1
58134: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58135: LD_ADDR_EXP 86
58139: PUSH
58140: LD_EXP 86
58144: PPUSH
58145: LD_VAR 0 4
58149: PPUSH
58150: EMPTY
58151: PPUSH
58152: CALL_OW 1
58156: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58157: LD_ADDR_EXP 88
58161: PUSH
58162: LD_EXP 88
58166: PPUSH
58167: LD_VAR 0 4
58171: PPUSH
58172: EMPTY
58173: PPUSH
58174: CALL_OW 1
58178: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58179: LD_ADDR_EXP 90
58183: PUSH
58184: LD_EXP 90
58188: PPUSH
58189: LD_VAR 0 4
58193: PPUSH
58194: EMPTY
58195: PPUSH
58196: CALL_OW 1
58200: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58201: LD_ADDR_EXP 91
58205: PUSH
58206: LD_EXP 91
58210: PPUSH
58211: LD_VAR 0 4
58215: PPUSH
58216: EMPTY
58217: PPUSH
58218: CALL_OW 1
58222: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58223: LD_ADDR_EXP 92
58227: PUSH
58228: LD_EXP 92
58232: PPUSH
58233: LD_VAR 0 4
58237: PPUSH
58238: EMPTY
58239: PPUSH
58240: CALL_OW 1
58244: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58245: LD_ADDR_EXP 93
58249: PUSH
58250: LD_EXP 93
58254: PPUSH
58255: LD_VAR 0 4
58259: PPUSH
58260: EMPTY
58261: PPUSH
58262: CALL_OW 1
58266: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58267: LD_ADDR_EXP 94
58271: PUSH
58272: LD_EXP 94
58276: PPUSH
58277: LD_VAR 0 4
58281: PPUSH
58282: EMPTY
58283: PPUSH
58284: CALL_OW 1
58288: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58289: LD_ADDR_EXP 95
58293: PUSH
58294: LD_EXP 95
58298: PPUSH
58299: LD_VAR 0 4
58303: PPUSH
58304: EMPTY
58305: PPUSH
58306: CALL_OW 1
58310: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58311: LD_ADDR_EXP 96
58315: PUSH
58316: LD_EXP 96
58320: PPUSH
58321: LD_VAR 0 4
58325: PPUSH
58326: EMPTY
58327: PPUSH
58328: CALL_OW 1
58332: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58333: LD_ADDR_EXP 97
58337: PUSH
58338: LD_EXP 97
58342: PPUSH
58343: LD_VAR 0 4
58347: PPUSH
58348: EMPTY
58349: PPUSH
58350: CALL_OW 1
58354: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58355: LD_ADDR_EXP 98
58359: PUSH
58360: LD_EXP 98
58364: PPUSH
58365: LD_VAR 0 4
58369: PPUSH
58370: EMPTY
58371: PPUSH
58372: CALL_OW 1
58376: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58377: LD_ADDR_EXP 99
58381: PUSH
58382: LD_EXP 99
58386: PPUSH
58387: LD_VAR 0 4
58391: PPUSH
58392: EMPTY
58393: PPUSH
58394: CALL_OW 1
58398: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58399: LD_ADDR_EXP 100
58403: PUSH
58404: LD_EXP 100
58408: PPUSH
58409: LD_VAR 0 4
58413: PPUSH
58414: EMPTY
58415: PPUSH
58416: CALL_OW 1
58420: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58421: LD_ADDR_EXP 101
58425: PUSH
58426: LD_EXP 101
58430: PPUSH
58431: LD_VAR 0 4
58435: PPUSH
58436: EMPTY
58437: PPUSH
58438: CALL_OW 1
58442: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58443: LD_ADDR_EXP 102
58447: PUSH
58448: LD_EXP 102
58452: PPUSH
58453: LD_VAR 0 4
58457: PPUSH
58458: EMPTY
58459: PPUSH
58460: CALL_OW 1
58464: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58465: LD_ADDR_EXP 103
58469: PUSH
58470: LD_EXP 103
58474: PPUSH
58475: LD_VAR 0 4
58479: PPUSH
58480: LD_INT 0
58482: PPUSH
58483: CALL_OW 1
58487: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58488: LD_ADDR_EXP 104
58492: PUSH
58493: LD_EXP 104
58497: PPUSH
58498: LD_VAR 0 4
58502: PPUSH
58503: LD_INT 0
58505: PPUSH
58506: CALL_OW 1
58510: ST_TO_ADDR
// result := base ;
58511: LD_ADDR_VAR 0 3
58515: PUSH
58516: LD_VAR 0 4
58520: ST_TO_ADDR
// end ;
58521: LD_VAR 0 3
58525: RET
// export function MC_Start ( ) ; var i ; begin
58526: LD_INT 0
58528: PPUSH
58529: PPUSH
// for i = 1 to mc_bases do
58530: LD_ADDR_VAR 0 2
58534: PUSH
58535: DOUBLE
58536: LD_INT 1
58538: DEC
58539: ST_TO_ADDR
58540: LD_EXP 61
58544: PUSH
58545: FOR_TO
58546: IFFALSE 59646
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58548: LD_ADDR_EXP 61
58552: PUSH
58553: LD_EXP 61
58557: PPUSH
58558: LD_VAR 0 2
58562: PPUSH
58563: LD_EXP 61
58567: PUSH
58568: LD_VAR 0 2
58572: ARRAY
58573: PUSH
58574: LD_INT 0
58576: DIFF
58577: PPUSH
58578: CALL_OW 1
58582: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58583: LD_ADDR_EXP 62
58587: PUSH
58588: LD_EXP 62
58592: PPUSH
58593: LD_VAR 0 2
58597: PPUSH
58598: EMPTY
58599: PPUSH
58600: CALL_OW 1
58604: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58605: LD_ADDR_EXP 63
58609: PUSH
58610: LD_EXP 63
58614: PPUSH
58615: LD_VAR 0 2
58619: PPUSH
58620: EMPTY
58621: PPUSH
58622: CALL_OW 1
58626: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58627: LD_ADDR_EXP 64
58631: PUSH
58632: LD_EXP 64
58636: PPUSH
58637: LD_VAR 0 2
58641: PPUSH
58642: EMPTY
58643: PPUSH
58644: CALL_OW 1
58648: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58649: LD_ADDR_EXP 65
58653: PUSH
58654: LD_EXP 65
58658: PPUSH
58659: LD_VAR 0 2
58663: PPUSH
58664: EMPTY
58665: PUSH
58666: EMPTY
58667: PUSH
58668: EMPTY
58669: LIST
58670: LIST
58671: PPUSH
58672: CALL_OW 1
58676: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58677: LD_ADDR_EXP 66
58681: PUSH
58682: LD_EXP 66
58686: PPUSH
58687: LD_VAR 0 2
58691: PPUSH
58692: EMPTY
58693: PPUSH
58694: CALL_OW 1
58698: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58699: LD_ADDR_EXP 93
58703: PUSH
58704: LD_EXP 93
58708: PPUSH
58709: LD_VAR 0 2
58713: PPUSH
58714: EMPTY
58715: PPUSH
58716: CALL_OW 1
58720: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58721: LD_ADDR_EXP 67
58725: PUSH
58726: LD_EXP 67
58730: PPUSH
58731: LD_VAR 0 2
58735: PPUSH
58736: EMPTY
58737: PPUSH
58738: CALL_OW 1
58742: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58743: LD_ADDR_EXP 68
58747: PUSH
58748: LD_EXP 68
58752: PPUSH
58753: LD_VAR 0 2
58757: PPUSH
58758: EMPTY
58759: PPUSH
58760: CALL_OW 1
58764: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58765: LD_ADDR_EXP 69
58769: PUSH
58770: LD_EXP 69
58774: PPUSH
58775: LD_VAR 0 2
58779: PPUSH
58780: LD_EXP 61
58784: PUSH
58785: LD_VAR 0 2
58789: ARRAY
58790: PPUSH
58791: LD_INT 2
58793: PUSH
58794: LD_INT 30
58796: PUSH
58797: LD_INT 32
58799: PUSH
58800: EMPTY
58801: LIST
58802: LIST
58803: PUSH
58804: LD_INT 30
58806: PUSH
58807: LD_INT 33
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: PUSH
58814: EMPTY
58815: LIST
58816: LIST
58817: LIST
58818: PPUSH
58819: CALL_OW 72
58823: PPUSH
58824: CALL_OW 1
58828: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58829: LD_ADDR_EXP 70
58833: PUSH
58834: LD_EXP 70
58838: PPUSH
58839: LD_VAR 0 2
58843: PPUSH
58844: LD_EXP 61
58848: PUSH
58849: LD_VAR 0 2
58853: ARRAY
58854: PPUSH
58855: LD_INT 2
58857: PUSH
58858: LD_INT 30
58860: PUSH
58861: LD_INT 32
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: PUSH
58868: LD_INT 30
58870: PUSH
58871: LD_INT 31
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: LIST
58882: PUSH
58883: LD_INT 58
58885: PUSH
58886: EMPTY
58887: LIST
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: PPUSH
58893: CALL_OW 72
58897: PPUSH
58898: CALL_OW 1
58902: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58903: LD_ADDR_EXP 71
58907: PUSH
58908: LD_EXP 71
58912: PPUSH
58913: LD_VAR 0 2
58917: PPUSH
58918: EMPTY
58919: PPUSH
58920: CALL_OW 1
58924: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58925: LD_ADDR_EXP 75
58929: PUSH
58930: LD_EXP 75
58934: PPUSH
58935: LD_VAR 0 2
58939: PPUSH
58940: EMPTY
58941: PPUSH
58942: CALL_OW 1
58946: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58947: LD_ADDR_EXP 74
58951: PUSH
58952: LD_EXP 74
58956: PPUSH
58957: LD_VAR 0 2
58961: PPUSH
58962: EMPTY
58963: PPUSH
58964: CALL_OW 1
58968: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58969: LD_ADDR_EXP 76
58973: PUSH
58974: LD_EXP 76
58978: PPUSH
58979: LD_VAR 0 2
58983: PPUSH
58984: EMPTY
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58991: LD_ADDR_EXP 77
58995: PUSH
58996: LD_EXP 77
59000: PPUSH
59001: LD_VAR 0 2
59005: PPUSH
59006: EMPTY
59007: PPUSH
59008: CALL_OW 1
59012: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59013: LD_ADDR_EXP 78
59017: PUSH
59018: LD_EXP 78
59022: PPUSH
59023: LD_VAR 0 2
59027: PPUSH
59028: EMPTY
59029: PPUSH
59030: CALL_OW 1
59034: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59035: LD_ADDR_EXP 79
59039: PUSH
59040: LD_EXP 79
59044: PPUSH
59045: LD_VAR 0 2
59049: PPUSH
59050: EMPTY
59051: PPUSH
59052: CALL_OW 1
59056: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59057: LD_ADDR_EXP 80
59061: PUSH
59062: LD_EXP 80
59066: PPUSH
59067: LD_VAR 0 2
59071: PPUSH
59072: EMPTY
59073: PPUSH
59074: CALL_OW 1
59078: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59079: LD_ADDR_EXP 81
59083: PUSH
59084: LD_EXP 81
59088: PPUSH
59089: LD_VAR 0 2
59093: PPUSH
59094: EMPTY
59095: PPUSH
59096: CALL_OW 1
59100: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59101: LD_ADDR_EXP 82
59105: PUSH
59106: LD_EXP 82
59110: PPUSH
59111: LD_VAR 0 2
59115: PPUSH
59116: EMPTY
59117: PPUSH
59118: CALL_OW 1
59122: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59123: LD_ADDR_EXP 83
59127: PUSH
59128: LD_EXP 83
59132: PPUSH
59133: LD_VAR 0 2
59137: PPUSH
59138: EMPTY
59139: PPUSH
59140: CALL_OW 1
59144: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59145: LD_ADDR_EXP 72
59149: PUSH
59150: LD_EXP 72
59154: PPUSH
59155: LD_VAR 0 2
59159: PPUSH
59160: LD_INT 0
59162: PPUSH
59163: CALL_OW 1
59167: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59168: LD_ADDR_EXP 85
59172: PUSH
59173: LD_EXP 85
59177: PPUSH
59178: LD_VAR 0 2
59182: PPUSH
59183: LD_INT 0
59185: PPUSH
59186: CALL_OW 1
59190: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59191: LD_ADDR_EXP 73
59195: PUSH
59196: LD_EXP 73
59200: PPUSH
59201: LD_VAR 0 2
59205: PPUSH
59206: EMPTY
59207: PPUSH
59208: CALL_OW 1
59212: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59213: LD_ADDR_EXP 84
59217: PUSH
59218: LD_EXP 84
59222: PPUSH
59223: LD_VAR 0 2
59227: PPUSH
59228: LD_INT 0
59230: PPUSH
59231: CALL_OW 1
59235: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59236: LD_ADDR_EXP 86
59240: PUSH
59241: LD_EXP 86
59245: PPUSH
59246: LD_VAR 0 2
59250: PPUSH
59251: EMPTY
59252: PPUSH
59253: CALL_OW 1
59257: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59258: LD_ADDR_EXP 89
59262: PUSH
59263: LD_EXP 89
59267: PPUSH
59268: LD_VAR 0 2
59272: PPUSH
59273: LD_INT 0
59275: PPUSH
59276: CALL_OW 1
59280: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59281: LD_ADDR_EXP 90
59285: PUSH
59286: LD_EXP 90
59290: PPUSH
59291: LD_VAR 0 2
59295: PPUSH
59296: EMPTY
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59303: LD_ADDR_EXP 91
59307: PUSH
59308: LD_EXP 91
59312: PPUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: EMPTY
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59325: LD_ADDR_EXP 92
59329: PUSH
59330: LD_EXP 92
59334: PPUSH
59335: LD_VAR 0 2
59339: PPUSH
59340: EMPTY
59341: PPUSH
59342: CALL_OW 1
59346: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59347: LD_ADDR_EXP 94
59351: PUSH
59352: LD_EXP 94
59356: PPUSH
59357: LD_VAR 0 2
59361: PPUSH
59362: LD_EXP 61
59366: PUSH
59367: LD_VAR 0 2
59371: ARRAY
59372: PPUSH
59373: LD_INT 2
59375: PUSH
59376: LD_INT 30
59378: PUSH
59379: LD_INT 6
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: PUSH
59386: LD_INT 30
59388: PUSH
59389: LD_INT 7
59391: PUSH
59392: EMPTY
59393: LIST
59394: LIST
59395: PUSH
59396: LD_INT 30
59398: PUSH
59399: LD_INT 8
59401: PUSH
59402: EMPTY
59403: LIST
59404: LIST
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: LIST
59410: LIST
59411: PPUSH
59412: CALL_OW 72
59416: PPUSH
59417: CALL_OW 1
59421: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59422: LD_ADDR_EXP 95
59426: PUSH
59427: LD_EXP 95
59431: PPUSH
59432: LD_VAR 0 2
59436: PPUSH
59437: EMPTY
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59444: LD_ADDR_EXP 96
59448: PUSH
59449: LD_EXP 96
59453: PPUSH
59454: LD_VAR 0 2
59458: PPUSH
59459: EMPTY
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59466: LD_ADDR_EXP 97
59470: PUSH
59471: LD_EXP 97
59475: PPUSH
59476: LD_VAR 0 2
59480: PPUSH
59481: EMPTY
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59488: LD_ADDR_EXP 98
59492: PUSH
59493: LD_EXP 98
59497: PPUSH
59498: LD_VAR 0 2
59502: PPUSH
59503: EMPTY
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59510: LD_ADDR_EXP 99
59514: PUSH
59515: LD_EXP 99
59519: PPUSH
59520: LD_VAR 0 2
59524: PPUSH
59525: EMPTY
59526: PPUSH
59527: CALL_OW 1
59531: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59532: LD_ADDR_EXP 100
59536: PUSH
59537: LD_EXP 100
59541: PPUSH
59542: LD_VAR 0 2
59546: PPUSH
59547: EMPTY
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59554: LD_ADDR_EXP 101
59558: PUSH
59559: LD_EXP 101
59563: PPUSH
59564: LD_VAR 0 2
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59576: LD_ADDR_EXP 102
59580: PUSH
59581: LD_EXP 102
59585: PPUSH
59586: LD_VAR 0 2
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59598: LD_ADDR_EXP 103
59602: PUSH
59603: LD_EXP 103
59607: PPUSH
59608: LD_VAR 0 2
59612: PPUSH
59613: LD_INT 0
59615: PPUSH
59616: CALL_OW 1
59620: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59621: LD_ADDR_EXP 104
59625: PUSH
59626: LD_EXP 104
59630: PPUSH
59631: LD_VAR 0 2
59635: PPUSH
59636: LD_INT 0
59638: PPUSH
59639: CALL_OW 1
59643: ST_TO_ADDR
// end ;
59644: GO 58545
59646: POP
59647: POP
// MC_InitSides ( ) ;
59648: CALL 59934 0 0
// MC_InitResearch ( ) ;
59652: CALL 59673 0 0
// CustomInitMacro ( ) ;
59656: CALL 202 0 0
// skirmish := true ;
59660: LD_ADDR_EXP 59
59664: PUSH
59665: LD_INT 1
59667: ST_TO_ADDR
// end ;
59668: LD_VAR 0 1
59672: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59673: LD_INT 0
59675: PPUSH
59676: PPUSH
59677: PPUSH
59678: PPUSH
59679: PPUSH
59680: PPUSH
// if not mc_bases then
59681: LD_EXP 61
59685: NOT
59686: IFFALSE 59690
// exit ;
59688: GO 59929
// for i = 1 to 8 do
59690: LD_ADDR_VAR 0 2
59694: PUSH
59695: DOUBLE
59696: LD_INT 1
59698: DEC
59699: ST_TO_ADDR
59700: LD_INT 8
59702: PUSH
59703: FOR_TO
59704: IFFALSE 59730
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59706: LD_ADDR_EXP 88
59710: PUSH
59711: LD_EXP 88
59715: PPUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: EMPTY
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
59728: GO 59703
59730: POP
59731: POP
// tmp := [ ] ;
59732: LD_ADDR_VAR 0 5
59736: PUSH
59737: EMPTY
59738: ST_TO_ADDR
// for i = 1 to mc_sides do
59739: LD_ADDR_VAR 0 2
59743: PUSH
59744: DOUBLE
59745: LD_INT 1
59747: DEC
59748: ST_TO_ADDR
59749: LD_EXP 87
59753: PUSH
59754: FOR_TO
59755: IFFALSE 59813
// if not mc_sides [ i ] in tmp then
59757: LD_EXP 87
59761: PUSH
59762: LD_VAR 0 2
59766: ARRAY
59767: PUSH
59768: LD_VAR 0 5
59772: IN
59773: NOT
59774: IFFALSE 59811
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59776: LD_ADDR_VAR 0 5
59780: PUSH
59781: LD_VAR 0 5
59785: PPUSH
59786: LD_VAR 0 5
59790: PUSH
59791: LD_INT 1
59793: PLUS
59794: PPUSH
59795: LD_EXP 87
59799: PUSH
59800: LD_VAR 0 2
59804: ARRAY
59805: PPUSH
59806: CALL_OW 2
59810: ST_TO_ADDR
59811: GO 59754
59813: POP
59814: POP
// if not tmp then
59815: LD_VAR 0 5
59819: NOT
59820: IFFALSE 59824
// exit ;
59822: GO 59929
// for j in tmp do
59824: LD_ADDR_VAR 0 3
59828: PUSH
59829: LD_VAR 0 5
59833: PUSH
59834: FOR_IN
59835: IFFALSE 59927
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59837: LD_ADDR_VAR 0 6
59841: PUSH
59842: LD_INT 22
59844: PUSH
59845: LD_VAR 0 3
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PPUSH
59854: CALL_OW 69
59858: ST_TO_ADDR
// if not un then
59859: LD_VAR 0 6
59863: NOT
59864: IFFALSE 59868
// continue ;
59866: GO 59834
// nation := GetNation ( un [ 1 ] ) ;
59868: LD_ADDR_VAR 0 4
59872: PUSH
59873: LD_VAR 0 6
59877: PUSH
59878: LD_INT 1
59880: ARRAY
59881: PPUSH
59882: CALL_OW 248
59886: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59887: LD_ADDR_EXP 88
59891: PUSH
59892: LD_EXP 88
59896: PPUSH
59897: LD_VAR 0 3
59901: PPUSH
59902: LD_VAR 0 3
59906: PPUSH
59907: LD_VAR 0 4
59911: PPUSH
59912: LD_INT 1
59914: PPUSH
59915: CALL 14996 0 3
59919: PPUSH
59920: CALL_OW 1
59924: ST_TO_ADDR
// end ;
59925: GO 59834
59927: POP
59928: POP
// end ;
59929: LD_VAR 0 1
59933: RET
// export function MC_InitSides ( ) ; var i ; begin
59934: LD_INT 0
59936: PPUSH
59937: PPUSH
// if not mc_bases then
59938: LD_EXP 61
59942: NOT
59943: IFFALSE 59947
// exit ;
59945: GO 60021
// for i = 1 to mc_bases do
59947: LD_ADDR_VAR 0 2
59951: PUSH
59952: DOUBLE
59953: LD_INT 1
59955: DEC
59956: ST_TO_ADDR
59957: LD_EXP 61
59961: PUSH
59962: FOR_TO
59963: IFFALSE 60019
// if mc_bases [ i ] then
59965: LD_EXP 61
59969: PUSH
59970: LD_VAR 0 2
59974: ARRAY
59975: IFFALSE 60017
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59977: LD_ADDR_EXP 87
59981: PUSH
59982: LD_EXP 87
59986: PPUSH
59987: LD_VAR 0 2
59991: PPUSH
59992: LD_EXP 61
59996: PUSH
59997: LD_VAR 0 2
60001: ARRAY
60002: PUSH
60003: LD_INT 1
60005: ARRAY
60006: PPUSH
60007: CALL_OW 255
60011: PPUSH
60012: CALL_OW 1
60016: ST_TO_ADDR
60017: GO 59962
60019: POP
60020: POP
// end ;
60021: LD_VAR 0 1
60025: RET
// every 0 0$03 trigger skirmish do
60026: LD_EXP 59
60030: IFFALSE 60184
60032: GO 60034
60034: DISABLE
// begin enable ;
60035: ENABLE
// MC_CheckBuildings ( ) ;
60036: CALL 64682 0 0
// MC_CheckPeopleLife ( ) ;
60040: CALL 64843 0 0
// RaiseSailEvent ( 100 ) ;
60044: LD_INT 100
60046: PPUSH
60047: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60051: LD_INT 103
60053: PPUSH
60054: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60058: LD_INT 104
60060: PPUSH
60061: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60065: LD_INT 105
60067: PPUSH
60068: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60072: LD_INT 106
60074: PPUSH
60075: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60079: LD_INT 107
60081: PPUSH
60082: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60086: LD_INT 108
60088: PPUSH
60089: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60093: LD_INT 109
60095: PPUSH
60096: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60100: LD_INT 110
60102: PPUSH
60103: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60107: LD_INT 111
60109: PPUSH
60110: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60114: LD_INT 112
60116: PPUSH
60117: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60121: LD_INT 113
60123: PPUSH
60124: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60128: LD_INT 120
60130: PPUSH
60131: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60135: LD_INT 121
60137: PPUSH
60138: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60142: LD_INT 122
60144: PPUSH
60145: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60149: LD_INT 123
60151: PPUSH
60152: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60156: LD_INT 124
60158: PPUSH
60159: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60163: LD_INT 125
60165: PPUSH
60166: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60170: LD_INT 126
60172: PPUSH
60173: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60177: LD_INT 200
60179: PPUSH
60180: CALL_OW 427
// end ;
60184: END
// on SailEvent ( event ) do begin if event < 100 then
60185: LD_VAR 0 1
60189: PUSH
60190: LD_INT 100
60192: LESS
60193: IFFALSE 60204
// CustomEvent ( event ) ;
60195: LD_VAR 0 1
60199: PPUSH
60200: CALL 13611 0 1
// if event = 100 then
60204: LD_VAR 0 1
60208: PUSH
60209: LD_INT 100
60211: EQUAL
60212: IFFALSE 60218
// MC_ClassManager ( ) ;
60214: CALL 60610 0 0
// if event = 101 then
60218: LD_VAR 0 1
60222: PUSH
60223: LD_INT 101
60225: EQUAL
60226: IFFALSE 60232
// MC_RepairBuildings ( ) ;
60228: CALL 65428 0 0
// if event = 102 then
60232: LD_VAR 0 1
60236: PUSH
60237: LD_INT 102
60239: EQUAL
60240: IFFALSE 60246
// MC_Heal ( ) ;
60242: CALL 66363 0 0
// if event = 103 then
60246: LD_VAR 0 1
60250: PUSH
60251: LD_INT 103
60253: EQUAL
60254: IFFALSE 60260
// MC_Build ( ) ;
60256: CALL 66785 0 0
// if event = 104 then
60260: LD_VAR 0 1
60264: PUSH
60265: LD_INT 104
60267: EQUAL
60268: IFFALSE 60274
// MC_TurretWeapon ( ) ;
60270: CALL 68419 0 0
// if event = 105 then
60274: LD_VAR 0 1
60278: PUSH
60279: LD_INT 105
60281: EQUAL
60282: IFFALSE 60288
// MC_BuildUpgrade ( ) ;
60284: CALL 67970 0 0
// if event = 106 then
60288: LD_VAR 0 1
60292: PUSH
60293: LD_INT 106
60295: EQUAL
60296: IFFALSE 60302
// MC_PlantMines ( ) ;
60298: CALL 68849 0 0
// if event = 107 then
60302: LD_VAR 0 1
60306: PUSH
60307: LD_INT 107
60309: EQUAL
60310: IFFALSE 60316
// MC_CollectCrates ( ) ;
60312: CALL 69640 0 0
// if event = 108 then
60316: LD_VAR 0 1
60320: PUSH
60321: LD_INT 108
60323: EQUAL
60324: IFFALSE 60330
// MC_LinkRemoteControl ( ) ;
60326: CALL 71490 0 0
// if event = 109 then
60330: LD_VAR 0 1
60334: PUSH
60335: LD_INT 109
60337: EQUAL
60338: IFFALSE 60344
// MC_ProduceVehicle ( ) ;
60340: CALL 71671 0 0
// if event = 110 then
60344: LD_VAR 0 1
60348: PUSH
60349: LD_INT 110
60351: EQUAL
60352: IFFALSE 60358
// MC_SendAttack ( ) ;
60354: CALL 72137 0 0
// if event = 111 then
60358: LD_VAR 0 1
60362: PUSH
60363: LD_INT 111
60365: EQUAL
60366: IFFALSE 60372
// MC_Defend ( ) ;
60368: CALL 72245 0 0
// if event = 112 then
60372: LD_VAR 0 1
60376: PUSH
60377: LD_INT 112
60379: EQUAL
60380: IFFALSE 60386
// MC_Research ( ) ;
60382: CALL 73125 0 0
// if event = 113 then
60386: LD_VAR 0 1
60390: PUSH
60391: LD_INT 113
60393: EQUAL
60394: IFFALSE 60400
// MC_MinesTrigger ( ) ;
60396: CALL 74239 0 0
// if event = 120 then
60400: LD_VAR 0 1
60404: PUSH
60405: LD_INT 120
60407: EQUAL
60408: IFFALSE 60414
// MC_RepairVehicle ( ) ;
60410: CALL 74338 0 0
// if event = 121 then
60414: LD_VAR 0 1
60418: PUSH
60419: LD_INT 121
60421: EQUAL
60422: IFFALSE 60428
// MC_TameApe ( ) ;
60424: CALL 75107 0 0
// if event = 122 then
60428: LD_VAR 0 1
60432: PUSH
60433: LD_INT 122
60435: EQUAL
60436: IFFALSE 60442
// MC_ChangeApeClass ( ) ;
60438: CALL 75936 0 0
// if event = 123 then
60442: LD_VAR 0 1
60446: PUSH
60447: LD_INT 123
60449: EQUAL
60450: IFFALSE 60456
// MC_Bazooka ( ) ;
60452: CALL 76586 0 0
// if event = 124 then
60456: LD_VAR 0 1
60460: PUSH
60461: LD_INT 124
60463: EQUAL
60464: IFFALSE 60470
// MC_TeleportExit ( ) ;
60466: CALL 76784 0 0
// if event = 125 then
60470: LD_VAR 0 1
60474: PUSH
60475: LD_INT 125
60477: EQUAL
60478: IFFALSE 60484
// MC_Deposits ( ) ;
60480: CALL 77431 0 0
// if event = 126 then
60484: LD_VAR 0 1
60488: PUSH
60489: LD_INT 126
60491: EQUAL
60492: IFFALSE 60498
// MC_RemoteDriver ( ) ;
60494: CALL 78056 0 0
// if event = 200 then
60498: LD_VAR 0 1
60502: PUSH
60503: LD_INT 200
60505: EQUAL
60506: IFFALSE 60512
// MC_Idle ( ) ;
60508: CALL 80005 0 0
// end ;
60512: PPOPN 1
60514: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60515: LD_INT 0
60517: PPUSH
60518: PPUSH
// if not mc_bases [ base ] or not tag then
60519: LD_EXP 61
60523: PUSH
60524: LD_VAR 0 1
60528: ARRAY
60529: NOT
60530: PUSH
60531: LD_VAR 0 2
60535: NOT
60536: OR
60537: IFFALSE 60541
// exit ;
60539: GO 60605
// for i in mc_bases [ base ] union mc_ape [ base ] do
60541: LD_ADDR_VAR 0 4
60545: PUSH
60546: LD_EXP 61
60550: PUSH
60551: LD_VAR 0 1
60555: ARRAY
60556: PUSH
60557: LD_EXP 90
60561: PUSH
60562: LD_VAR 0 1
60566: ARRAY
60567: UNION
60568: PUSH
60569: FOR_IN
60570: IFFALSE 60603
// if GetTag ( i ) = tag then
60572: LD_VAR 0 4
60576: PPUSH
60577: CALL_OW 110
60581: PUSH
60582: LD_VAR 0 2
60586: EQUAL
60587: IFFALSE 60601
// SetTag ( i , 0 ) ;
60589: LD_VAR 0 4
60593: PPUSH
60594: LD_INT 0
60596: PPUSH
60597: CALL_OW 109
60601: GO 60569
60603: POP
60604: POP
// end ;
60605: LD_VAR 0 3
60609: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60610: LD_INT 0
60612: PPUSH
60613: PPUSH
60614: PPUSH
60615: PPUSH
60616: PPUSH
60617: PPUSH
60618: PPUSH
60619: PPUSH
// if not mc_bases then
60620: LD_EXP 61
60624: NOT
60625: IFFALSE 60629
// exit ;
60627: GO 61087
// for i = 1 to mc_bases do
60629: LD_ADDR_VAR 0 2
60633: PUSH
60634: DOUBLE
60635: LD_INT 1
60637: DEC
60638: ST_TO_ADDR
60639: LD_EXP 61
60643: PUSH
60644: FOR_TO
60645: IFFALSE 61085
// begin tmp := MC_ClassCheckReq ( i ) ;
60647: LD_ADDR_VAR 0 4
60651: PUSH
60652: LD_VAR 0 2
60656: PPUSH
60657: CALL 61092 0 1
60661: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60662: LD_ADDR_EXP 102
60666: PUSH
60667: LD_EXP 102
60671: PPUSH
60672: LD_VAR 0 2
60676: PPUSH
60677: LD_VAR 0 4
60681: PPUSH
60682: CALL_OW 1
60686: ST_TO_ADDR
// if not tmp then
60687: LD_VAR 0 4
60691: NOT
60692: IFFALSE 60696
// continue ;
60694: GO 60644
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60696: LD_ADDR_VAR 0 6
60700: PUSH
60701: LD_EXP 61
60705: PUSH
60706: LD_VAR 0 2
60710: ARRAY
60711: PPUSH
60712: LD_INT 2
60714: PUSH
60715: LD_INT 30
60717: PUSH
60718: LD_INT 4
60720: PUSH
60721: EMPTY
60722: LIST
60723: LIST
60724: PUSH
60725: LD_INT 30
60727: PUSH
60728: LD_INT 5
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: LIST
60739: PPUSH
60740: CALL_OW 72
60744: PUSH
60745: LD_EXP 61
60749: PUSH
60750: LD_VAR 0 2
60754: ARRAY
60755: PPUSH
60756: LD_INT 2
60758: PUSH
60759: LD_INT 30
60761: PUSH
60762: LD_INT 0
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 30
60771: PUSH
60772: LD_INT 1
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: LIST
60783: PPUSH
60784: CALL_OW 72
60788: PUSH
60789: LD_EXP 61
60793: PUSH
60794: LD_VAR 0 2
60798: ARRAY
60799: PPUSH
60800: LD_INT 30
60802: PUSH
60803: LD_INT 3
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PPUSH
60810: CALL_OW 72
60814: PUSH
60815: LD_EXP 61
60819: PUSH
60820: LD_VAR 0 2
60824: ARRAY
60825: PPUSH
60826: LD_INT 2
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 6
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: LD_INT 30
60841: PUSH
60842: LD_INT 7
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: PUSH
60849: LD_INT 30
60851: PUSH
60852: LD_INT 8
60854: PUSH
60855: EMPTY
60856: LIST
60857: LIST
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: LIST
60863: LIST
60864: PPUSH
60865: CALL_OW 72
60869: PUSH
60870: EMPTY
60871: LIST
60872: LIST
60873: LIST
60874: LIST
60875: ST_TO_ADDR
// for j = 1 to 4 do
60876: LD_ADDR_VAR 0 3
60880: PUSH
60881: DOUBLE
60882: LD_INT 1
60884: DEC
60885: ST_TO_ADDR
60886: LD_INT 4
60888: PUSH
60889: FOR_TO
60890: IFFALSE 61081
// begin if not tmp [ j ] then
60892: LD_VAR 0 4
60896: PUSH
60897: LD_VAR 0 3
60901: ARRAY
60902: NOT
60903: IFFALSE 60907
// continue ;
60905: GO 60889
// for p in tmp [ j ] do
60907: LD_ADDR_VAR 0 5
60911: PUSH
60912: LD_VAR 0 4
60916: PUSH
60917: LD_VAR 0 3
60921: ARRAY
60922: PUSH
60923: FOR_IN
60924: IFFALSE 61077
// begin if not b [ j ] then
60926: LD_VAR 0 6
60930: PUSH
60931: LD_VAR 0 3
60935: ARRAY
60936: NOT
60937: IFFALSE 60941
// break ;
60939: GO 61077
// e := 0 ;
60941: LD_ADDR_VAR 0 7
60945: PUSH
60946: LD_INT 0
60948: ST_TO_ADDR
// for k in b [ j ] do
60949: LD_ADDR_VAR 0 8
60953: PUSH
60954: LD_VAR 0 6
60958: PUSH
60959: LD_VAR 0 3
60963: ARRAY
60964: PUSH
60965: FOR_IN
60966: IFFALSE 60993
// if IsNotFull ( k ) then
60968: LD_VAR 0 8
60972: PPUSH
60973: CALL 17149 0 1
60977: IFFALSE 60991
// begin e := k ;
60979: LD_ADDR_VAR 0 7
60983: PUSH
60984: LD_VAR 0 8
60988: ST_TO_ADDR
// break ;
60989: GO 60993
// end ;
60991: GO 60965
60993: POP
60994: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60995: LD_VAR 0 7
60999: PUSH
61000: LD_VAR 0 5
61004: PPUSH
61005: LD_VAR 0 7
61009: PPUSH
61010: CALL 51045 0 2
61014: NOT
61015: AND
61016: IFFALSE 61075
// begin if IsInUnit ( p ) then
61018: LD_VAR 0 5
61022: PPUSH
61023: CALL_OW 310
61027: IFFALSE 61038
// ComExitBuilding ( p ) ;
61029: LD_VAR 0 5
61033: PPUSH
61034: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61038: LD_VAR 0 5
61042: PPUSH
61043: LD_VAR 0 7
61047: PPUSH
61048: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61052: LD_VAR 0 5
61056: PPUSH
61057: LD_VAR 0 3
61061: PPUSH
61062: CALL_OW 183
// AddComExitBuilding ( p ) ;
61066: LD_VAR 0 5
61070: PPUSH
61071: CALL_OW 182
// end ; end ;
61075: GO 60923
61077: POP
61078: POP
// end ;
61079: GO 60889
61081: POP
61082: POP
// end ;
61083: GO 60644
61085: POP
61086: POP
// end ;
61087: LD_VAR 0 1
61091: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61092: LD_INT 0
61094: PPUSH
61095: PPUSH
61096: PPUSH
61097: PPUSH
61098: PPUSH
61099: PPUSH
61100: PPUSH
61101: PPUSH
61102: PPUSH
61103: PPUSH
61104: PPUSH
61105: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61106: LD_VAR 0 1
61110: NOT
61111: PUSH
61112: LD_EXP 61
61116: PUSH
61117: LD_VAR 0 1
61121: ARRAY
61122: NOT
61123: OR
61124: PUSH
61125: LD_EXP 61
61129: PUSH
61130: LD_VAR 0 1
61134: ARRAY
61135: PPUSH
61136: LD_INT 2
61138: PUSH
61139: LD_INT 30
61141: PUSH
61142: LD_INT 0
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: PUSH
61149: LD_INT 30
61151: PUSH
61152: LD_INT 1
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: LIST
61163: PPUSH
61164: CALL_OW 72
61168: NOT
61169: OR
61170: IFFALSE 61174
// exit ;
61172: GO 64677
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61174: LD_ADDR_VAR 0 4
61178: PUSH
61179: LD_EXP 61
61183: PUSH
61184: LD_VAR 0 1
61188: ARRAY
61189: PPUSH
61190: LD_INT 2
61192: PUSH
61193: LD_INT 25
61195: PUSH
61196: LD_INT 1
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: PUSH
61203: LD_INT 25
61205: PUSH
61206: LD_INT 2
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: PUSH
61213: LD_INT 25
61215: PUSH
61216: LD_INT 3
61218: PUSH
61219: EMPTY
61220: LIST
61221: LIST
61222: PUSH
61223: LD_INT 25
61225: PUSH
61226: LD_INT 4
61228: PUSH
61229: EMPTY
61230: LIST
61231: LIST
61232: PUSH
61233: LD_INT 25
61235: PUSH
61236: LD_INT 5
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: LD_INT 25
61245: PUSH
61246: LD_INT 8
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 25
61255: PUSH
61256: LD_INT 9
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: LIST
61272: PPUSH
61273: CALL_OW 72
61277: ST_TO_ADDR
// if not tmp then
61278: LD_VAR 0 4
61282: NOT
61283: IFFALSE 61287
// exit ;
61285: GO 64677
// for i in tmp do
61287: LD_ADDR_VAR 0 3
61291: PUSH
61292: LD_VAR 0 4
61296: PUSH
61297: FOR_IN
61298: IFFALSE 61329
// if GetTag ( i ) then
61300: LD_VAR 0 3
61304: PPUSH
61305: CALL_OW 110
61309: IFFALSE 61327
// tmp := tmp diff i ;
61311: LD_ADDR_VAR 0 4
61315: PUSH
61316: LD_VAR 0 4
61320: PUSH
61321: LD_VAR 0 3
61325: DIFF
61326: ST_TO_ADDR
61327: GO 61297
61329: POP
61330: POP
// if not tmp then
61331: LD_VAR 0 4
61335: NOT
61336: IFFALSE 61340
// exit ;
61338: GO 64677
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61340: LD_ADDR_VAR 0 5
61344: PUSH
61345: LD_EXP 61
61349: PUSH
61350: LD_VAR 0 1
61354: ARRAY
61355: PPUSH
61356: LD_INT 2
61358: PUSH
61359: LD_INT 25
61361: PUSH
61362: LD_INT 1
61364: PUSH
61365: EMPTY
61366: LIST
61367: LIST
61368: PUSH
61369: LD_INT 25
61371: PUSH
61372: LD_INT 5
61374: PUSH
61375: EMPTY
61376: LIST
61377: LIST
61378: PUSH
61379: LD_INT 25
61381: PUSH
61382: LD_INT 8
61384: PUSH
61385: EMPTY
61386: LIST
61387: LIST
61388: PUSH
61389: LD_INT 25
61391: PUSH
61392: LD_INT 9
61394: PUSH
61395: EMPTY
61396: LIST
61397: LIST
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: LIST
61403: LIST
61404: LIST
61405: PPUSH
61406: CALL_OW 72
61410: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61411: LD_ADDR_VAR 0 6
61415: PUSH
61416: LD_EXP 61
61420: PUSH
61421: LD_VAR 0 1
61425: ARRAY
61426: PPUSH
61427: LD_INT 25
61429: PUSH
61430: LD_INT 2
61432: PUSH
61433: EMPTY
61434: LIST
61435: LIST
61436: PPUSH
61437: CALL_OW 72
61441: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61442: LD_ADDR_VAR 0 7
61446: PUSH
61447: LD_EXP 61
61451: PUSH
61452: LD_VAR 0 1
61456: ARRAY
61457: PPUSH
61458: LD_INT 25
61460: PUSH
61461: LD_INT 3
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: PPUSH
61468: CALL_OW 72
61472: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61473: LD_ADDR_VAR 0 8
61477: PUSH
61478: LD_EXP 61
61482: PUSH
61483: LD_VAR 0 1
61487: ARRAY
61488: PPUSH
61489: LD_INT 25
61491: PUSH
61492: LD_INT 4
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: LD_INT 24
61501: PUSH
61502: LD_INT 251
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PPUSH
61513: CALL_OW 72
61517: ST_TO_ADDR
// if mc_is_defending [ base ] then
61518: LD_EXP 104
61522: PUSH
61523: LD_VAR 0 1
61527: ARRAY
61528: IFFALSE 61989
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61530: LD_ADDR_EXP 103
61534: PUSH
61535: LD_EXP 103
61539: PPUSH
61540: LD_VAR 0 1
61544: PPUSH
61545: LD_INT 4
61547: PPUSH
61548: CALL_OW 1
61552: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61553: LD_ADDR_VAR 0 12
61557: PUSH
61558: LD_EXP 61
61562: PUSH
61563: LD_VAR 0 1
61567: ARRAY
61568: PPUSH
61569: LD_INT 2
61571: PUSH
61572: LD_INT 30
61574: PUSH
61575: LD_INT 4
61577: PUSH
61578: EMPTY
61579: LIST
61580: LIST
61581: PUSH
61582: LD_INT 30
61584: PUSH
61585: LD_INT 5
61587: PUSH
61588: EMPTY
61589: LIST
61590: LIST
61591: PUSH
61592: EMPTY
61593: LIST
61594: LIST
61595: LIST
61596: PPUSH
61597: CALL_OW 72
61601: ST_TO_ADDR
// if not b then
61602: LD_VAR 0 12
61606: NOT
61607: IFFALSE 61611
// exit ;
61609: GO 64677
// p := [ ] ;
61611: LD_ADDR_VAR 0 11
61615: PUSH
61616: EMPTY
61617: ST_TO_ADDR
// if sci >= 2 then
61618: LD_VAR 0 8
61622: PUSH
61623: LD_INT 2
61625: GREATEREQUAL
61626: IFFALSE 61657
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61628: LD_ADDR_VAR 0 8
61632: PUSH
61633: LD_VAR 0 8
61637: PUSH
61638: LD_INT 1
61640: ARRAY
61641: PUSH
61642: LD_VAR 0 8
61646: PUSH
61647: LD_INT 2
61649: ARRAY
61650: PUSH
61651: EMPTY
61652: LIST
61653: LIST
61654: ST_TO_ADDR
61655: GO 61718
// if sci = 1 then
61657: LD_VAR 0 8
61661: PUSH
61662: LD_INT 1
61664: EQUAL
61665: IFFALSE 61686
// sci := [ sci [ 1 ] ] else
61667: LD_ADDR_VAR 0 8
61671: PUSH
61672: LD_VAR 0 8
61676: PUSH
61677: LD_INT 1
61679: ARRAY
61680: PUSH
61681: EMPTY
61682: LIST
61683: ST_TO_ADDR
61684: GO 61718
// if sci = 0 then
61686: LD_VAR 0 8
61690: PUSH
61691: LD_INT 0
61693: EQUAL
61694: IFFALSE 61718
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61696: LD_ADDR_VAR 0 11
61700: PUSH
61701: LD_VAR 0 4
61705: PPUSH
61706: LD_INT 4
61708: PPUSH
61709: CALL 50917 0 2
61713: PUSH
61714: LD_INT 1
61716: ARRAY
61717: ST_TO_ADDR
// if eng > 4 then
61718: LD_VAR 0 6
61722: PUSH
61723: LD_INT 4
61725: GREATER
61726: IFFALSE 61772
// for i = eng downto 4 do
61728: LD_ADDR_VAR 0 3
61732: PUSH
61733: DOUBLE
61734: LD_VAR 0 6
61738: INC
61739: ST_TO_ADDR
61740: LD_INT 4
61742: PUSH
61743: FOR_DOWNTO
61744: IFFALSE 61770
// eng := eng diff eng [ i ] ;
61746: LD_ADDR_VAR 0 6
61750: PUSH
61751: LD_VAR 0 6
61755: PUSH
61756: LD_VAR 0 6
61760: PUSH
61761: LD_VAR 0 3
61765: ARRAY
61766: DIFF
61767: ST_TO_ADDR
61768: GO 61743
61770: POP
61771: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61772: LD_ADDR_VAR 0 4
61776: PUSH
61777: LD_VAR 0 4
61781: PUSH
61782: LD_VAR 0 5
61786: PUSH
61787: LD_VAR 0 6
61791: UNION
61792: PUSH
61793: LD_VAR 0 7
61797: UNION
61798: PUSH
61799: LD_VAR 0 8
61803: UNION
61804: DIFF
61805: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61806: LD_ADDR_VAR 0 13
61810: PUSH
61811: LD_EXP 61
61815: PUSH
61816: LD_VAR 0 1
61820: ARRAY
61821: PPUSH
61822: LD_INT 2
61824: PUSH
61825: LD_INT 30
61827: PUSH
61828: LD_INT 32
61830: PUSH
61831: EMPTY
61832: LIST
61833: LIST
61834: PUSH
61835: LD_INT 30
61837: PUSH
61838: LD_INT 31
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: LIST
61849: PPUSH
61850: CALL_OW 72
61854: PUSH
61855: LD_EXP 61
61859: PUSH
61860: LD_VAR 0 1
61864: ARRAY
61865: PPUSH
61866: LD_INT 2
61868: PUSH
61869: LD_INT 30
61871: PUSH
61872: LD_INT 4
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PUSH
61879: LD_INT 30
61881: PUSH
61882: LD_INT 5
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: LIST
61893: PPUSH
61894: CALL_OW 72
61898: PUSH
61899: LD_INT 6
61901: MUL
61902: PLUS
61903: ST_TO_ADDR
// if bcount < tmp then
61904: LD_VAR 0 13
61908: PUSH
61909: LD_VAR 0 4
61913: LESS
61914: IFFALSE 61960
// for i = tmp downto bcount do
61916: LD_ADDR_VAR 0 3
61920: PUSH
61921: DOUBLE
61922: LD_VAR 0 4
61926: INC
61927: ST_TO_ADDR
61928: LD_VAR 0 13
61932: PUSH
61933: FOR_DOWNTO
61934: IFFALSE 61958
// tmp := Delete ( tmp , tmp ) ;
61936: LD_ADDR_VAR 0 4
61940: PUSH
61941: LD_VAR 0 4
61945: PPUSH
61946: LD_VAR 0 4
61950: PPUSH
61951: CALL_OW 3
61955: ST_TO_ADDR
61956: GO 61933
61958: POP
61959: POP
// result := [ tmp , 0 , 0 , p ] ;
61960: LD_ADDR_VAR 0 2
61964: PUSH
61965: LD_VAR 0 4
61969: PUSH
61970: LD_INT 0
61972: PUSH
61973: LD_INT 0
61975: PUSH
61976: LD_VAR 0 11
61980: PUSH
61981: EMPTY
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: ST_TO_ADDR
// exit ;
61987: GO 64677
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61989: LD_EXP 61
61993: PUSH
61994: LD_VAR 0 1
61998: ARRAY
61999: PPUSH
62000: LD_INT 2
62002: PUSH
62003: LD_INT 30
62005: PUSH
62006: LD_INT 6
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: PUSH
62013: LD_INT 30
62015: PUSH
62016: LD_INT 7
62018: PUSH
62019: EMPTY
62020: LIST
62021: LIST
62022: PUSH
62023: LD_INT 30
62025: PUSH
62026: LD_INT 8
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: LIST
62037: LIST
62038: PPUSH
62039: CALL_OW 72
62043: NOT
62044: PUSH
62045: LD_EXP 61
62049: PUSH
62050: LD_VAR 0 1
62054: ARRAY
62055: PPUSH
62056: LD_INT 30
62058: PUSH
62059: LD_INT 3
62061: PUSH
62062: EMPTY
62063: LIST
62064: LIST
62065: PPUSH
62066: CALL_OW 72
62070: NOT
62071: AND
62072: IFFALSE 62144
// begin if eng = tmp then
62074: LD_VAR 0 6
62078: PUSH
62079: LD_VAR 0 4
62083: EQUAL
62084: IFFALSE 62088
// exit ;
62086: GO 64677
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62088: LD_ADDR_EXP 103
62092: PUSH
62093: LD_EXP 103
62097: PPUSH
62098: LD_VAR 0 1
62102: PPUSH
62103: LD_INT 1
62105: PPUSH
62106: CALL_OW 1
62110: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62111: LD_ADDR_VAR 0 2
62115: PUSH
62116: LD_INT 0
62118: PUSH
62119: LD_VAR 0 4
62123: PUSH
62124: LD_VAR 0 6
62128: DIFF
62129: PUSH
62130: LD_INT 0
62132: PUSH
62133: LD_INT 0
62135: PUSH
62136: EMPTY
62137: LIST
62138: LIST
62139: LIST
62140: LIST
62141: ST_TO_ADDR
// exit ;
62142: GO 64677
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62144: LD_EXP 88
62148: PUSH
62149: LD_EXP 87
62153: PUSH
62154: LD_VAR 0 1
62158: ARRAY
62159: ARRAY
62160: PUSH
62161: LD_EXP 61
62165: PUSH
62166: LD_VAR 0 1
62170: ARRAY
62171: PPUSH
62172: LD_INT 2
62174: PUSH
62175: LD_INT 30
62177: PUSH
62178: LD_INT 6
62180: PUSH
62181: EMPTY
62182: LIST
62183: LIST
62184: PUSH
62185: LD_INT 30
62187: PUSH
62188: LD_INT 7
62190: PUSH
62191: EMPTY
62192: LIST
62193: LIST
62194: PUSH
62195: LD_INT 30
62197: PUSH
62198: LD_INT 8
62200: PUSH
62201: EMPTY
62202: LIST
62203: LIST
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: LIST
62209: LIST
62210: PPUSH
62211: CALL_OW 72
62215: AND
62216: PUSH
62217: LD_EXP 61
62221: PUSH
62222: LD_VAR 0 1
62226: ARRAY
62227: PPUSH
62228: LD_INT 30
62230: PUSH
62231: LD_INT 3
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: PPUSH
62238: CALL_OW 72
62242: NOT
62243: AND
62244: IFFALSE 62458
// begin if sci >= 6 then
62246: LD_VAR 0 8
62250: PUSH
62251: LD_INT 6
62253: GREATEREQUAL
62254: IFFALSE 62258
// exit ;
62256: GO 64677
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62258: LD_ADDR_EXP 103
62262: PUSH
62263: LD_EXP 103
62267: PPUSH
62268: LD_VAR 0 1
62272: PPUSH
62273: LD_INT 2
62275: PPUSH
62276: CALL_OW 1
62280: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62281: LD_ADDR_VAR 0 9
62285: PUSH
62286: LD_VAR 0 4
62290: PUSH
62291: LD_VAR 0 8
62295: DIFF
62296: PPUSH
62297: LD_INT 4
62299: PPUSH
62300: CALL 50917 0 2
62304: ST_TO_ADDR
// p := [ ] ;
62305: LD_ADDR_VAR 0 11
62309: PUSH
62310: EMPTY
62311: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62312: LD_VAR 0 8
62316: PUSH
62317: LD_INT 6
62319: LESS
62320: PUSH
62321: LD_VAR 0 9
62325: PUSH
62326: LD_INT 6
62328: GREATER
62329: AND
62330: IFFALSE 62411
// begin for i = 1 to 6 - sci do
62332: LD_ADDR_VAR 0 3
62336: PUSH
62337: DOUBLE
62338: LD_INT 1
62340: DEC
62341: ST_TO_ADDR
62342: LD_INT 6
62344: PUSH
62345: LD_VAR 0 8
62349: MINUS
62350: PUSH
62351: FOR_TO
62352: IFFALSE 62407
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62354: LD_ADDR_VAR 0 11
62358: PUSH
62359: LD_VAR 0 11
62363: PPUSH
62364: LD_VAR 0 11
62368: PUSH
62369: LD_INT 1
62371: PLUS
62372: PPUSH
62373: LD_VAR 0 9
62377: PUSH
62378: LD_INT 1
62380: ARRAY
62381: PPUSH
62382: CALL_OW 2
62386: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62387: LD_ADDR_VAR 0 9
62391: PUSH
62392: LD_VAR 0 9
62396: PPUSH
62397: LD_INT 1
62399: PPUSH
62400: CALL_OW 3
62404: ST_TO_ADDR
// end ;
62405: GO 62351
62407: POP
62408: POP
// end else
62409: GO 62431
// if sort then
62411: LD_VAR 0 9
62415: IFFALSE 62431
// p := sort [ 1 ] ;
62417: LD_ADDR_VAR 0 11
62421: PUSH
62422: LD_VAR 0 9
62426: PUSH
62427: LD_INT 1
62429: ARRAY
62430: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62431: LD_ADDR_VAR 0 2
62435: PUSH
62436: LD_INT 0
62438: PUSH
62439: LD_INT 0
62441: PUSH
62442: LD_INT 0
62444: PUSH
62445: LD_VAR 0 11
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: ST_TO_ADDR
// exit ;
62456: GO 64677
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62458: LD_EXP 88
62462: PUSH
62463: LD_EXP 87
62467: PUSH
62468: LD_VAR 0 1
62472: ARRAY
62473: ARRAY
62474: PUSH
62475: LD_EXP 61
62479: PUSH
62480: LD_VAR 0 1
62484: ARRAY
62485: PPUSH
62486: LD_INT 2
62488: PUSH
62489: LD_INT 30
62491: PUSH
62492: LD_INT 6
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PUSH
62499: LD_INT 30
62501: PUSH
62502: LD_INT 7
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 30
62511: PUSH
62512: LD_INT 8
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: EMPTY
62520: LIST
62521: LIST
62522: LIST
62523: LIST
62524: PPUSH
62525: CALL_OW 72
62529: AND
62530: PUSH
62531: LD_EXP 61
62535: PUSH
62536: LD_VAR 0 1
62540: ARRAY
62541: PPUSH
62542: LD_INT 30
62544: PUSH
62545: LD_INT 3
62547: PUSH
62548: EMPTY
62549: LIST
62550: LIST
62551: PPUSH
62552: CALL_OW 72
62556: AND
62557: IFFALSE 63291
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62559: LD_ADDR_EXP 103
62563: PUSH
62564: LD_EXP 103
62568: PPUSH
62569: LD_VAR 0 1
62573: PPUSH
62574: LD_INT 3
62576: PPUSH
62577: CALL_OW 1
62581: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62582: LD_ADDR_VAR 0 2
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: LD_INT 0
62592: PUSH
62593: LD_INT 0
62595: PUSH
62596: LD_INT 0
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: LIST
62603: LIST
62604: ST_TO_ADDR
// if not eng then
62605: LD_VAR 0 6
62609: NOT
62610: IFFALSE 62673
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62612: LD_ADDR_VAR 0 11
62616: PUSH
62617: LD_VAR 0 4
62621: PPUSH
62622: LD_INT 2
62624: PPUSH
62625: CALL 50917 0 2
62629: PUSH
62630: LD_INT 1
62632: ARRAY
62633: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62634: LD_ADDR_VAR 0 2
62638: PUSH
62639: LD_VAR 0 2
62643: PPUSH
62644: LD_INT 2
62646: PPUSH
62647: LD_VAR 0 11
62651: PPUSH
62652: CALL_OW 1
62656: ST_TO_ADDR
// tmp := tmp diff p ;
62657: LD_ADDR_VAR 0 4
62661: PUSH
62662: LD_VAR 0 4
62666: PUSH
62667: LD_VAR 0 11
62671: DIFF
62672: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62673: LD_VAR 0 4
62677: PUSH
62678: LD_VAR 0 8
62682: PUSH
62683: LD_INT 6
62685: LESS
62686: AND
62687: IFFALSE 62875
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62689: LD_ADDR_VAR 0 9
62693: PUSH
62694: LD_VAR 0 4
62698: PUSH
62699: LD_VAR 0 8
62703: PUSH
62704: LD_VAR 0 7
62708: UNION
62709: DIFF
62710: PPUSH
62711: LD_INT 4
62713: PPUSH
62714: CALL 50917 0 2
62718: ST_TO_ADDR
// p := [ ] ;
62719: LD_ADDR_VAR 0 11
62723: PUSH
62724: EMPTY
62725: ST_TO_ADDR
// if sort then
62726: LD_VAR 0 9
62730: IFFALSE 62846
// for i = 1 to 6 - sci do
62732: LD_ADDR_VAR 0 3
62736: PUSH
62737: DOUBLE
62738: LD_INT 1
62740: DEC
62741: ST_TO_ADDR
62742: LD_INT 6
62744: PUSH
62745: LD_VAR 0 8
62749: MINUS
62750: PUSH
62751: FOR_TO
62752: IFFALSE 62844
// begin if i = sort then
62754: LD_VAR 0 3
62758: PUSH
62759: LD_VAR 0 9
62763: EQUAL
62764: IFFALSE 62768
// break ;
62766: GO 62844
// if GetClass ( i ) = 4 then
62768: LD_VAR 0 3
62772: PPUSH
62773: CALL_OW 257
62777: PUSH
62778: LD_INT 4
62780: EQUAL
62781: IFFALSE 62785
// continue ;
62783: GO 62751
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62785: LD_ADDR_VAR 0 11
62789: PUSH
62790: LD_VAR 0 11
62794: PPUSH
62795: LD_VAR 0 11
62799: PUSH
62800: LD_INT 1
62802: PLUS
62803: PPUSH
62804: LD_VAR 0 9
62808: PUSH
62809: LD_VAR 0 3
62813: ARRAY
62814: PPUSH
62815: CALL_OW 2
62819: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62820: LD_ADDR_VAR 0 4
62824: PUSH
62825: LD_VAR 0 4
62829: PUSH
62830: LD_VAR 0 9
62834: PUSH
62835: LD_VAR 0 3
62839: ARRAY
62840: DIFF
62841: ST_TO_ADDR
// end ;
62842: GO 62751
62844: POP
62845: POP
// if p then
62846: LD_VAR 0 11
62850: IFFALSE 62875
// result := Replace ( result , 4 , p ) ;
62852: LD_ADDR_VAR 0 2
62856: PUSH
62857: LD_VAR 0 2
62861: PPUSH
62862: LD_INT 4
62864: PPUSH
62865: LD_VAR 0 11
62869: PPUSH
62870: CALL_OW 1
62874: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62875: LD_VAR 0 4
62879: PUSH
62880: LD_VAR 0 7
62884: PUSH
62885: LD_INT 6
62887: LESS
62888: AND
62889: IFFALSE 63077
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62891: LD_ADDR_VAR 0 9
62895: PUSH
62896: LD_VAR 0 4
62900: PUSH
62901: LD_VAR 0 8
62905: PUSH
62906: LD_VAR 0 7
62910: UNION
62911: DIFF
62912: PPUSH
62913: LD_INT 3
62915: PPUSH
62916: CALL 50917 0 2
62920: ST_TO_ADDR
// p := [ ] ;
62921: LD_ADDR_VAR 0 11
62925: PUSH
62926: EMPTY
62927: ST_TO_ADDR
// if sort then
62928: LD_VAR 0 9
62932: IFFALSE 63048
// for i = 1 to 6 - mech do
62934: LD_ADDR_VAR 0 3
62938: PUSH
62939: DOUBLE
62940: LD_INT 1
62942: DEC
62943: ST_TO_ADDR
62944: LD_INT 6
62946: PUSH
62947: LD_VAR 0 7
62951: MINUS
62952: PUSH
62953: FOR_TO
62954: IFFALSE 63046
// begin if i = sort then
62956: LD_VAR 0 3
62960: PUSH
62961: LD_VAR 0 9
62965: EQUAL
62966: IFFALSE 62970
// break ;
62968: GO 63046
// if GetClass ( i ) = 3 then
62970: LD_VAR 0 3
62974: PPUSH
62975: CALL_OW 257
62979: PUSH
62980: LD_INT 3
62982: EQUAL
62983: IFFALSE 62987
// continue ;
62985: GO 62953
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62987: LD_ADDR_VAR 0 11
62991: PUSH
62992: LD_VAR 0 11
62996: PPUSH
62997: LD_VAR 0 11
63001: PUSH
63002: LD_INT 1
63004: PLUS
63005: PPUSH
63006: LD_VAR 0 9
63010: PUSH
63011: LD_VAR 0 3
63015: ARRAY
63016: PPUSH
63017: CALL_OW 2
63021: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63022: LD_ADDR_VAR 0 4
63026: PUSH
63027: LD_VAR 0 4
63031: PUSH
63032: LD_VAR 0 9
63036: PUSH
63037: LD_VAR 0 3
63041: ARRAY
63042: DIFF
63043: ST_TO_ADDR
// end ;
63044: GO 62953
63046: POP
63047: POP
// if p then
63048: LD_VAR 0 11
63052: IFFALSE 63077
// result := Replace ( result , 3 , p ) ;
63054: LD_ADDR_VAR 0 2
63058: PUSH
63059: LD_VAR 0 2
63063: PPUSH
63064: LD_INT 3
63066: PPUSH
63067: LD_VAR 0 11
63071: PPUSH
63072: CALL_OW 1
63076: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63077: LD_VAR 0 4
63081: PUSH
63082: LD_INT 6
63084: GREATER
63085: PUSH
63086: LD_VAR 0 6
63090: PUSH
63091: LD_INT 6
63093: LESS
63094: AND
63095: IFFALSE 63289
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63097: LD_ADDR_VAR 0 9
63101: PUSH
63102: LD_VAR 0 4
63106: PUSH
63107: LD_VAR 0 8
63111: PUSH
63112: LD_VAR 0 7
63116: UNION
63117: PUSH
63118: LD_VAR 0 6
63122: UNION
63123: DIFF
63124: PPUSH
63125: LD_INT 2
63127: PPUSH
63128: CALL 50917 0 2
63132: ST_TO_ADDR
// p := [ ] ;
63133: LD_ADDR_VAR 0 11
63137: PUSH
63138: EMPTY
63139: ST_TO_ADDR
// if sort then
63140: LD_VAR 0 9
63144: IFFALSE 63260
// for i = 1 to 6 - eng do
63146: LD_ADDR_VAR 0 3
63150: PUSH
63151: DOUBLE
63152: LD_INT 1
63154: DEC
63155: ST_TO_ADDR
63156: LD_INT 6
63158: PUSH
63159: LD_VAR 0 6
63163: MINUS
63164: PUSH
63165: FOR_TO
63166: IFFALSE 63258
// begin if i = sort then
63168: LD_VAR 0 3
63172: PUSH
63173: LD_VAR 0 9
63177: EQUAL
63178: IFFALSE 63182
// break ;
63180: GO 63258
// if GetClass ( i ) = 2 then
63182: LD_VAR 0 3
63186: PPUSH
63187: CALL_OW 257
63191: PUSH
63192: LD_INT 2
63194: EQUAL
63195: IFFALSE 63199
// continue ;
63197: GO 63165
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63199: LD_ADDR_VAR 0 11
63203: PUSH
63204: LD_VAR 0 11
63208: PPUSH
63209: LD_VAR 0 11
63213: PUSH
63214: LD_INT 1
63216: PLUS
63217: PPUSH
63218: LD_VAR 0 9
63222: PUSH
63223: LD_VAR 0 3
63227: ARRAY
63228: PPUSH
63229: CALL_OW 2
63233: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63234: LD_ADDR_VAR 0 4
63238: PUSH
63239: LD_VAR 0 4
63243: PUSH
63244: LD_VAR 0 9
63248: PUSH
63249: LD_VAR 0 3
63253: ARRAY
63254: DIFF
63255: ST_TO_ADDR
// end ;
63256: GO 63165
63258: POP
63259: POP
// if p then
63260: LD_VAR 0 11
63264: IFFALSE 63289
// result := Replace ( result , 2 , p ) ;
63266: LD_ADDR_VAR 0 2
63270: PUSH
63271: LD_VAR 0 2
63275: PPUSH
63276: LD_INT 2
63278: PPUSH
63279: LD_VAR 0 11
63283: PPUSH
63284: CALL_OW 1
63288: ST_TO_ADDR
// end ; exit ;
63289: GO 64677
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63291: LD_EXP 88
63295: PUSH
63296: LD_EXP 87
63300: PUSH
63301: LD_VAR 0 1
63305: ARRAY
63306: ARRAY
63307: NOT
63308: PUSH
63309: LD_EXP 61
63313: PUSH
63314: LD_VAR 0 1
63318: ARRAY
63319: PPUSH
63320: LD_INT 30
63322: PUSH
63323: LD_INT 3
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PPUSH
63330: CALL_OW 72
63334: AND
63335: PUSH
63336: LD_EXP 66
63340: PUSH
63341: LD_VAR 0 1
63345: ARRAY
63346: AND
63347: IFFALSE 63955
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63349: LD_ADDR_EXP 103
63353: PUSH
63354: LD_EXP 103
63358: PPUSH
63359: LD_VAR 0 1
63363: PPUSH
63364: LD_INT 5
63366: PPUSH
63367: CALL_OW 1
63371: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63372: LD_ADDR_VAR 0 2
63376: PUSH
63377: LD_INT 0
63379: PUSH
63380: LD_INT 0
63382: PUSH
63383: LD_INT 0
63385: PUSH
63386: LD_INT 0
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: ST_TO_ADDR
// if sci > 1 then
63395: LD_VAR 0 8
63399: PUSH
63400: LD_INT 1
63402: GREATER
63403: IFFALSE 63431
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63405: LD_ADDR_VAR 0 4
63409: PUSH
63410: LD_VAR 0 4
63414: PUSH
63415: LD_VAR 0 8
63419: PUSH
63420: LD_VAR 0 8
63424: PUSH
63425: LD_INT 1
63427: ARRAY
63428: DIFF
63429: DIFF
63430: ST_TO_ADDR
// if tmp and not sci then
63431: LD_VAR 0 4
63435: PUSH
63436: LD_VAR 0 8
63440: NOT
63441: AND
63442: IFFALSE 63511
// begin sort := SortBySkill ( tmp , 4 ) ;
63444: LD_ADDR_VAR 0 9
63448: PUSH
63449: LD_VAR 0 4
63453: PPUSH
63454: LD_INT 4
63456: PPUSH
63457: CALL 50917 0 2
63461: ST_TO_ADDR
// if sort then
63462: LD_VAR 0 9
63466: IFFALSE 63482
// p := sort [ 1 ] ;
63468: LD_ADDR_VAR 0 11
63472: PUSH
63473: LD_VAR 0 9
63477: PUSH
63478: LD_INT 1
63480: ARRAY
63481: ST_TO_ADDR
// if p then
63482: LD_VAR 0 11
63486: IFFALSE 63511
// result := Replace ( result , 4 , p ) ;
63488: LD_ADDR_VAR 0 2
63492: PUSH
63493: LD_VAR 0 2
63497: PPUSH
63498: LD_INT 4
63500: PPUSH
63501: LD_VAR 0 11
63505: PPUSH
63506: CALL_OW 1
63510: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63511: LD_ADDR_VAR 0 4
63515: PUSH
63516: LD_VAR 0 4
63520: PUSH
63521: LD_VAR 0 7
63525: DIFF
63526: ST_TO_ADDR
// if tmp and mech < 6 then
63527: LD_VAR 0 4
63531: PUSH
63532: LD_VAR 0 7
63536: PUSH
63537: LD_INT 6
63539: LESS
63540: AND
63541: IFFALSE 63729
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63543: LD_ADDR_VAR 0 9
63547: PUSH
63548: LD_VAR 0 4
63552: PUSH
63553: LD_VAR 0 8
63557: PUSH
63558: LD_VAR 0 7
63562: UNION
63563: DIFF
63564: PPUSH
63565: LD_INT 3
63567: PPUSH
63568: CALL 50917 0 2
63572: ST_TO_ADDR
// p := [ ] ;
63573: LD_ADDR_VAR 0 11
63577: PUSH
63578: EMPTY
63579: ST_TO_ADDR
// if sort then
63580: LD_VAR 0 9
63584: IFFALSE 63700
// for i = 1 to 6 - mech do
63586: LD_ADDR_VAR 0 3
63590: PUSH
63591: DOUBLE
63592: LD_INT 1
63594: DEC
63595: ST_TO_ADDR
63596: LD_INT 6
63598: PUSH
63599: LD_VAR 0 7
63603: MINUS
63604: PUSH
63605: FOR_TO
63606: IFFALSE 63698
// begin if i = sort then
63608: LD_VAR 0 3
63612: PUSH
63613: LD_VAR 0 9
63617: EQUAL
63618: IFFALSE 63622
// break ;
63620: GO 63698
// if GetClass ( i ) = 3 then
63622: LD_VAR 0 3
63626: PPUSH
63627: CALL_OW 257
63631: PUSH
63632: LD_INT 3
63634: EQUAL
63635: IFFALSE 63639
// continue ;
63637: GO 63605
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63639: LD_ADDR_VAR 0 11
63643: PUSH
63644: LD_VAR 0 11
63648: PPUSH
63649: LD_VAR 0 11
63653: PUSH
63654: LD_INT 1
63656: PLUS
63657: PPUSH
63658: LD_VAR 0 9
63662: PUSH
63663: LD_VAR 0 3
63667: ARRAY
63668: PPUSH
63669: CALL_OW 2
63673: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63674: LD_ADDR_VAR 0 4
63678: PUSH
63679: LD_VAR 0 4
63683: PUSH
63684: LD_VAR 0 9
63688: PUSH
63689: LD_VAR 0 3
63693: ARRAY
63694: DIFF
63695: ST_TO_ADDR
// end ;
63696: GO 63605
63698: POP
63699: POP
// if p then
63700: LD_VAR 0 11
63704: IFFALSE 63729
// result := Replace ( result , 3 , p ) ;
63706: LD_ADDR_VAR 0 2
63710: PUSH
63711: LD_VAR 0 2
63715: PPUSH
63716: LD_INT 3
63718: PPUSH
63719: LD_VAR 0 11
63723: PPUSH
63724: CALL_OW 1
63728: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63729: LD_ADDR_VAR 0 4
63733: PUSH
63734: LD_VAR 0 4
63738: PUSH
63739: LD_VAR 0 6
63743: DIFF
63744: ST_TO_ADDR
// if tmp and eng < 6 then
63745: LD_VAR 0 4
63749: PUSH
63750: LD_VAR 0 6
63754: PUSH
63755: LD_INT 6
63757: LESS
63758: AND
63759: IFFALSE 63953
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63761: LD_ADDR_VAR 0 9
63765: PUSH
63766: LD_VAR 0 4
63770: PUSH
63771: LD_VAR 0 8
63775: PUSH
63776: LD_VAR 0 7
63780: UNION
63781: PUSH
63782: LD_VAR 0 6
63786: UNION
63787: DIFF
63788: PPUSH
63789: LD_INT 2
63791: PPUSH
63792: CALL 50917 0 2
63796: ST_TO_ADDR
// p := [ ] ;
63797: LD_ADDR_VAR 0 11
63801: PUSH
63802: EMPTY
63803: ST_TO_ADDR
// if sort then
63804: LD_VAR 0 9
63808: IFFALSE 63924
// for i = 1 to 6 - eng do
63810: LD_ADDR_VAR 0 3
63814: PUSH
63815: DOUBLE
63816: LD_INT 1
63818: DEC
63819: ST_TO_ADDR
63820: LD_INT 6
63822: PUSH
63823: LD_VAR 0 6
63827: MINUS
63828: PUSH
63829: FOR_TO
63830: IFFALSE 63922
// begin if i = sort then
63832: LD_VAR 0 3
63836: PUSH
63837: LD_VAR 0 9
63841: EQUAL
63842: IFFALSE 63846
// break ;
63844: GO 63922
// if GetClass ( i ) = 2 then
63846: LD_VAR 0 3
63850: PPUSH
63851: CALL_OW 257
63855: PUSH
63856: LD_INT 2
63858: EQUAL
63859: IFFALSE 63863
// continue ;
63861: GO 63829
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63863: LD_ADDR_VAR 0 11
63867: PUSH
63868: LD_VAR 0 11
63872: PPUSH
63873: LD_VAR 0 11
63877: PUSH
63878: LD_INT 1
63880: PLUS
63881: PPUSH
63882: LD_VAR 0 9
63886: PUSH
63887: LD_VAR 0 3
63891: ARRAY
63892: PPUSH
63893: CALL_OW 2
63897: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63898: LD_ADDR_VAR 0 4
63902: PUSH
63903: LD_VAR 0 4
63907: PUSH
63908: LD_VAR 0 9
63912: PUSH
63913: LD_VAR 0 3
63917: ARRAY
63918: DIFF
63919: ST_TO_ADDR
// end ;
63920: GO 63829
63922: POP
63923: POP
// if p then
63924: LD_VAR 0 11
63928: IFFALSE 63953
// result := Replace ( result , 2 , p ) ;
63930: LD_ADDR_VAR 0 2
63934: PUSH
63935: LD_VAR 0 2
63939: PPUSH
63940: LD_INT 2
63942: PPUSH
63943: LD_VAR 0 11
63947: PPUSH
63948: CALL_OW 1
63952: ST_TO_ADDR
// end ; exit ;
63953: GO 64677
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63955: LD_EXP 88
63959: PUSH
63960: LD_EXP 87
63964: PUSH
63965: LD_VAR 0 1
63969: ARRAY
63970: ARRAY
63971: NOT
63972: PUSH
63973: LD_EXP 61
63977: PUSH
63978: LD_VAR 0 1
63982: ARRAY
63983: PPUSH
63984: LD_INT 30
63986: PUSH
63987: LD_INT 3
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: PPUSH
63994: CALL_OW 72
63998: AND
63999: PUSH
64000: LD_EXP 66
64004: PUSH
64005: LD_VAR 0 1
64009: ARRAY
64010: NOT
64011: AND
64012: IFFALSE 64677
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64014: LD_ADDR_EXP 103
64018: PUSH
64019: LD_EXP 103
64023: PPUSH
64024: LD_VAR 0 1
64028: PPUSH
64029: LD_INT 6
64031: PPUSH
64032: CALL_OW 1
64036: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64037: LD_ADDR_VAR 0 2
64041: PUSH
64042: LD_INT 0
64044: PUSH
64045: LD_INT 0
64047: PUSH
64048: LD_INT 0
64050: PUSH
64051: LD_INT 0
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: ST_TO_ADDR
// if sci >= 1 then
64060: LD_VAR 0 8
64064: PUSH
64065: LD_INT 1
64067: GREATEREQUAL
64068: IFFALSE 64090
// tmp := tmp diff sci [ 1 ] ;
64070: LD_ADDR_VAR 0 4
64074: PUSH
64075: LD_VAR 0 4
64079: PUSH
64080: LD_VAR 0 8
64084: PUSH
64085: LD_INT 1
64087: ARRAY
64088: DIFF
64089: ST_TO_ADDR
// if tmp and not sci then
64090: LD_VAR 0 4
64094: PUSH
64095: LD_VAR 0 8
64099: NOT
64100: AND
64101: IFFALSE 64170
// begin sort := SortBySkill ( tmp , 4 ) ;
64103: LD_ADDR_VAR 0 9
64107: PUSH
64108: LD_VAR 0 4
64112: PPUSH
64113: LD_INT 4
64115: PPUSH
64116: CALL 50917 0 2
64120: ST_TO_ADDR
// if sort then
64121: LD_VAR 0 9
64125: IFFALSE 64141
// p := sort [ 1 ] ;
64127: LD_ADDR_VAR 0 11
64131: PUSH
64132: LD_VAR 0 9
64136: PUSH
64137: LD_INT 1
64139: ARRAY
64140: ST_TO_ADDR
// if p then
64141: LD_VAR 0 11
64145: IFFALSE 64170
// result := Replace ( result , 4 , p ) ;
64147: LD_ADDR_VAR 0 2
64151: PUSH
64152: LD_VAR 0 2
64156: PPUSH
64157: LD_INT 4
64159: PPUSH
64160: LD_VAR 0 11
64164: PPUSH
64165: CALL_OW 1
64169: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64170: LD_ADDR_VAR 0 4
64174: PUSH
64175: LD_VAR 0 4
64179: PUSH
64180: LD_VAR 0 7
64184: DIFF
64185: ST_TO_ADDR
// if tmp and mech < 6 then
64186: LD_VAR 0 4
64190: PUSH
64191: LD_VAR 0 7
64195: PUSH
64196: LD_INT 6
64198: LESS
64199: AND
64200: IFFALSE 64382
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64202: LD_ADDR_VAR 0 9
64206: PUSH
64207: LD_VAR 0 4
64211: PUSH
64212: LD_VAR 0 7
64216: DIFF
64217: PPUSH
64218: LD_INT 3
64220: PPUSH
64221: CALL 50917 0 2
64225: ST_TO_ADDR
// p := [ ] ;
64226: LD_ADDR_VAR 0 11
64230: PUSH
64231: EMPTY
64232: ST_TO_ADDR
// if sort then
64233: LD_VAR 0 9
64237: IFFALSE 64353
// for i = 1 to 6 - mech do
64239: LD_ADDR_VAR 0 3
64243: PUSH
64244: DOUBLE
64245: LD_INT 1
64247: DEC
64248: ST_TO_ADDR
64249: LD_INT 6
64251: PUSH
64252: LD_VAR 0 7
64256: MINUS
64257: PUSH
64258: FOR_TO
64259: IFFALSE 64351
// begin if i = sort then
64261: LD_VAR 0 3
64265: PUSH
64266: LD_VAR 0 9
64270: EQUAL
64271: IFFALSE 64275
// break ;
64273: GO 64351
// if GetClass ( i ) = 3 then
64275: LD_VAR 0 3
64279: PPUSH
64280: CALL_OW 257
64284: PUSH
64285: LD_INT 3
64287: EQUAL
64288: IFFALSE 64292
// continue ;
64290: GO 64258
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64292: LD_ADDR_VAR 0 11
64296: PUSH
64297: LD_VAR 0 11
64301: PPUSH
64302: LD_VAR 0 11
64306: PUSH
64307: LD_INT 1
64309: PLUS
64310: PPUSH
64311: LD_VAR 0 9
64315: PUSH
64316: LD_VAR 0 3
64320: ARRAY
64321: PPUSH
64322: CALL_OW 2
64326: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64327: LD_ADDR_VAR 0 4
64331: PUSH
64332: LD_VAR 0 4
64336: PUSH
64337: LD_VAR 0 9
64341: PUSH
64342: LD_VAR 0 3
64346: ARRAY
64347: DIFF
64348: ST_TO_ADDR
// end ;
64349: GO 64258
64351: POP
64352: POP
// if p then
64353: LD_VAR 0 11
64357: IFFALSE 64382
// result := Replace ( result , 3 , p ) ;
64359: LD_ADDR_VAR 0 2
64363: PUSH
64364: LD_VAR 0 2
64368: PPUSH
64369: LD_INT 3
64371: PPUSH
64372: LD_VAR 0 11
64376: PPUSH
64377: CALL_OW 1
64381: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64382: LD_ADDR_VAR 0 4
64386: PUSH
64387: LD_VAR 0 4
64391: PUSH
64392: LD_VAR 0 6
64396: DIFF
64397: ST_TO_ADDR
// if tmp and eng < 4 then
64398: LD_VAR 0 4
64402: PUSH
64403: LD_VAR 0 6
64407: PUSH
64408: LD_INT 4
64410: LESS
64411: AND
64412: IFFALSE 64602
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64414: LD_ADDR_VAR 0 9
64418: PUSH
64419: LD_VAR 0 4
64423: PUSH
64424: LD_VAR 0 7
64428: PUSH
64429: LD_VAR 0 6
64433: UNION
64434: DIFF
64435: PPUSH
64436: LD_INT 2
64438: PPUSH
64439: CALL 50917 0 2
64443: ST_TO_ADDR
// p := [ ] ;
64444: LD_ADDR_VAR 0 11
64448: PUSH
64449: EMPTY
64450: ST_TO_ADDR
// if sort then
64451: LD_VAR 0 9
64455: IFFALSE 64571
// for i = 1 to 4 - eng do
64457: LD_ADDR_VAR 0 3
64461: PUSH
64462: DOUBLE
64463: LD_INT 1
64465: DEC
64466: ST_TO_ADDR
64467: LD_INT 4
64469: PUSH
64470: LD_VAR 0 6
64474: MINUS
64475: PUSH
64476: FOR_TO
64477: IFFALSE 64569
// begin if i = sort then
64479: LD_VAR 0 3
64483: PUSH
64484: LD_VAR 0 9
64488: EQUAL
64489: IFFALSE 64493
// break ;
64491: GO 64569
// if GetClass ( i ) = 2 then
64493: LD_VAR 0 3
64497: PPUSH
64498: CALL_OW 257
64502: PUSH
64503: LD_INT 2
64505: EQUAL
64506: IFFALSE 64510
// continue ;
64508: GO 64476
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64510: LD_ADDR_VAR 0 11
64514: PUSH
64515: LD_VAR 0 11
64519: PPUSH
64520: LD_VAR 0 11
64524: PUSH
64525: LD_INT 1
64527: PLUS
64528: PPUSH
64529: LD_VAR 0 9
64533: PUSH
64534: LD_VAR 0 3
64538: ARRAY
64539: PPUSH
64540: CALL_OW 2
64544: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64545: LD_ADDR_VAR 0 4
64549: PUSH
64550: LD_VAR 0 4
64554: PUSH
64555: LD_VAR 0 9
64559: PUSH
64560: LD_VAR 0 3
64564: ARRAY
64565: DIFF
64566: ST_TO_ADDR
// end ;
64567: GO 64476
64569: POP
64570: POP
// if p then
64571: LD_VAR 0 11
64575: IFFALSE 64600
// result := Replace ( result , 2 , p ) ;
64577: LD_ADDR_VAR 0 2
64581: PUSH
64582: LD_VAR 0 2
64586: PPUSH
64587: LD_INT 2
64589: PPUSH
64590: LD_VAR 0 11
64594: PPUSH
64595: CALL_OW 1
64599: ST_TO_ADDR
// end else
64600: GO 64646
// for i = eng downto 5 do
64602: LD_ADDR_VAR 0 3
64606: PUSH
64607: DOUBLE
64608: LD_VAR 0 6
64612: INC
64613: ST_TO_ADDR
64614: LD_INT 5
64616: PUSH
64617: FOR_DOWNTO
64618: IFFALSE 64644
// tmp := tmp union eng [ i ] ;
64620: LD_ADDR_VAR 0 4
64624: PUSH
64625: LD_VAR 0 4
64629: PUSH
64630: LD_VAR 0 6
64634: PUSH
64635: LD_VAR 0 3
64639: ARRAY
64640: UNION
64641: ST_TO_ADDR
64642: GO 64617
64644: POP
64645: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64646: LD_ADDR_VAR 0 2
64650: PUSH
64651: LD_VAR 0 2
64655: PPUSH
64656: LD_INT 1
64658: PPUSH
64659: LD_VAR 0 4
64663: PUSH
64664: LD_VAR 0 5
64668: DIFF
64669: PPUSH
64670: CALL_OW 1
64674: ST_TO_ADDR
// exit ;
64675: GO 64677
// end ; end ;
64677: LD_VAR 0 2
64681: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64682: LD_INT 0
64684: PPUSH
64685: PPUSH
64686: PPUSH
// if not mc_bases then
64687: LD_EXP 61
64691: NOT
64692: IFFALSE 64696
// exit ;
64694: GO 64838
// for i = 1 to mc_bases do
64696: LD_ADDR_VAR 0 2
64700: PUSH
64701: DOUBLE
64702: LD_INT 1
64704: DEC
64705: ST_TO_ADDR
64706: LD_EXP 61
64710: PUSH
64711: FOR_TO
64712: IFFALSE 64829
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64714: LD_ADDR_VAR 0 3
64718: PUSH
64719: LD_EXP 61
64723: PUSH
64724: LD_VAR 0 2
64728: ARRAY
64729: PPUSH
64730: LD_INT 21
64732: PUSH
64733: LD_INT 3
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 3
64742: PUSH
64743: LD_INT 2
64745: PUSH
64746: LD_INT 30
64748: PUSH
64749: LD_INT 29
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 30
64758: PUSH
64759: LD_INT 30
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: LIST
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: LD_INT 3
64777: PUSH
64778: LD_INT 24
64780: PUSH
64781: LD_INT 1000
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: LIST
64796: PPUSH
64797: CALL_OW 72
64801: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64802: LD_ADDR_EXP 62
64806: PUSH
64807: LD_EXP 62
64811: PPUSH
64812: LD_VAR 0 2
64816: PPUSH
64817: LD_VAR 0 3
64821: PPUSH
64822: CALL_OW 1
64826: ST_TO_ADDR
// end ;
64827: GO 64711
64829: POP
64830: POP
// RaiseSailEvent ( 101 ) ;
64831: LD_INT 101
64833: PPUSH
64834: CALL_OW 427
// end ;
64838: LD_VAR 0 1
64842: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64843: LD_INT 0
64845: PPUSH
64846: PPUSH
64847: PPUSH
64848: PPUSH
64849: PPUSH
64850: PPUSH
64851: PPUSH
// if not mc_bases then
64852: LD_EXP 61
64856: NOT
64857: IFFALSE 64861
// exit ;
64859: GO 65423
// for i = 1 to mc_bases do
64861: LD_ADDR_VAR 0 2
64865: PUSH
64866: DOUBLE
64867: LD_INT 1
64869: DEC
64870: ST_TO_ADDR
64871: LD_EXP 61
64875: PUSH
64876: FOR_TO
64877: IFFALSE 65414
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64879: LD_ADDR_VAR 0 5
64883: PUSH
64884: LD_EXP 61
64888: PUSH
64889: LD_VAR 0 2
64893: ARRAY
64894: PUSH
64895: LD_EXP 90
64899: PUSH
64900: LD_VAR 0 2
64904: ARRAY
64905: UNION
64906: PPUSH
64907: LD_INT 21
64909: PUSH
64910: LD_INT 1
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 1
64919: PUSH
64920: LD_INT 3
64922: PUSH
64923: LD_INT 54
64925: PUSH
64926: EMPTY
64927: LIST
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: PUSH
64933: LD_INT 3
64935: PUSH
64936: LD_INT 24
64938: PUSH
64939: LD_INT 1000
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: EMPTY
64951: LIST
64952: LIST
64953: LIST
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PPUSH
64959: CALL_OW 72
64963: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64964: LD_ADDR_VAR 0 6
64968: PUSH
64969: LD_EXP 61
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PPUSH
64980: LD_INT 21
64982: PUSH
64983: LD_INT 1
64985: PUSH
64986: EMPTY
64987: LIST
64988: LIST
64989: PUSH
64990: LD_INT 1
64992: PUSH
64993: LD_INT 3
64995: PUSH
64996: LD_INT 54
64998: PUSH
64999: EMPTY
65000: LIST
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 3
65008: PUSH
65009: LD_INT 24
65011: PUSH
65012: LD_INT 250
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: LIST
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PPUSH
65032: CALL_OW 72
65036: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65037: LD_ADDR_VAR 0 7
65041: PUSH
65042: LD_VAR 0 5
65046: PUSH
65047: LD_VAR 0 6
65051: DIFF
65052: ST_TO_ADDR
// if not need_heal_1 then
65053: LD_VAR 0 6
65057: NOT
65058: IFFALSE 65091
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65060: LD_ADDR_EXP 64
65064: PUSH
65065: LD_EXP 64
65069: PPUSH
65070: LD_VAR 0 2
65074: PUSH
65075: LD_INT 1
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PPUSH
65082: EMPTY
65083: PPUSH
65084: CALL 20070 0 3
65088: ST_TO_ADDR
65089: GO 65161
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65091: LD_ADDR_EXP 64
65095: PUSH
65096: LD_EXP 64
65100: PPUSH
65101: LD_VAR 0 2
65105: PUSH
65106: LD_INT 1
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: PPUSH
65113: LD_EXP 64
65117: PUSH
65118: LD_VAR 0 2
65122: ARRAY
65123: PUSH
65124: LD_INT 1
65126: ARRAY
65127: PPUSH
65128: LD_INT 3
65130: PUSH
65131: LD_INT 24
65133: PUSH
65134: LD_INT 1000
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PPUSH
65145: CALL_OW 72
65149: PUSH
65150: LD_VAR 0 6
65154: UNION
65155: PPUSH
65156: CALL 20070 0 3
65160: ST_TO_ADDR
// if not need_heal_2 then
65161: LD_VAR 0 7
65165: NOT
65166: IFFALSE 65199
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65168: LD_ADDR_EXP 64
65172: PUSH
65173: LD_EXP 64
65177: PPUSH
65178: LD_VAR 0 2
65182: PUSH
65183: LD_INT 2
65185: PUSH
65186: EMPTY
65187: LIST
65188: LIST
65189: PPUSH
65190: EMPTY
65191: PPUSH
65192: CALL 20070 0 3
65196: ST_TO_ADDR
65197: GO 65231
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65199: LD_ADDR_EXP 64
65203: PUSH
65204: LD_EXP 64
65208: PPUSH
65209: LD_VAR 0 2
65213: PUSH
65214: LD_INT 2
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PPUSH
65221: LD_VAR 0 7
65225: PPUSH
65226: CALL 20070 0 3
65230: ST_TO_ADDR
// if need_heal_2 then
65231: LD_VAR 0 7
65235: IFFALSE 65396
// for j in need_heal_2 do
65237: LD_ADDR_VAR 0 3
65241: PUSH
65242: LD_VAR 0 7
65246: PUSH
65247: FOR_IN
65248: IFFALSE 65394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65250: LD_ADDR_VAR 0 5
65254: PUSH
65255: LD_EXP 61
65259: PUSH
65260: LD_VAR 0 2
65264: ARRAY
65265: PPUSH
65266: LD_INT 2
65268: PUSH
65269: LD_INT 30
65271: PUSH
65272: LD_INT 6
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 30
65281: PUSH
65282: LD_INT 7
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 30
65291: PUSH
65292: LD_INT 8
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 30
65301: PUSH
65302: LD_INT 0
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 30
65311: PUSH
65312: LD_INT 1
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: PPUSH
65327: CALL_OW 72
65331: ST_TO_ADDR
// if tmp then
65332: LD_VAR 0 5
65336: IFFALSE 65392
// begin k := NearestUnitToUnit ( tmp , j ) ;
65338: LD_ADDR_VAR 0 4
65342: PUSH
65343: LD_VAR 0 5
65347: PPUSH
65348: LD_VAR 0 3
65352: PPUSH
65353: CALL_OW 74
65357: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65358: LD_VAR 0 3
65362: PPUSH
65363: LD_VAR 0 4
65367: PPUSH
65368: CALL_OW 296
65372: PUSH
65373: LD_INT 5
65375: GREATER
65376: IFFALSE 65392
// ComMoveToNearbyEntrance ( j , k ) ;
65378: LD_VAR 0 3
65382: PPUSH
65383: LD_VAR 0 4
65387: PPUSH
65388: CALL 53278 0 2
// end ; end ;
65392: GO 65247
65394: POP
65395: POP
// if not need_heal_1 and not need_heal_2 then
65396: LD_VAR 0 6
65400: NOT
65401: PUSH
65402: LD_VAR 0 7
65406: NOT
65407: AND
65408: IFFALSE 65412
// continue ;
65410: GO 64876
// end ;
65412: GO 64876
65414: POP
65415: POP
// RaiseSailEvent ( 102 ) ;
65416: LD_INT 102
65418: PPUSH
65419: CALL_OW 427
// end ;
65423: LD_VAR 0 1
65427: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65428: LD_INT 0
65430: PPUSH
65431: PPUSH
65432: PPUSH
65433: PPUSH
65434: PPUSH
65435: PPUSH
65436: PPUSH
65437: PPUSH
// if not mc_bases then
65438: LD_EXP 61
65442: NOT
65443: IFFALSE 65447
// exit ;
65445: GO 66358
// for i = 1 to mc_bases do
65447: LD_ADDR_VAR 0 2
65451: PUSH
65452: DOUBLE
65453: LD_INT 1
65455: DEC
65456: ST_TO_ADDR
65457: LD_EXP 61
65461: PUSH
65462: FOR_TO
65463: IFFALSE 66356
// begin if not mc_building_need_repair [ i ] then
65465: LD_EXP 62
65469: PUSH
65470: LD_VAR 0 2
65474: ARRAY
65475: NOT
65476: IFFALSE 65661
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65478: LD_ADDR_VAR 0 6
65482: PUSH
65483: LD_EXP 80
65487: PUSH
65488: LD_VAR 0 2
65492: ARRAY
65493: PPUSH
65494: LD_INT 3
65496: PUSH
65497: LD_INT 24
65499: PUSH
65500: LD_INT 1000
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: LD_INT 2
65513: PUSH
65514: LD_INT 34
65516: PUSH
65517: LD_INT 13
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 34
65526: PUSH
65527: LD_INT 52
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 34
65536: PUSH
65537: LD_INT 88
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: LIST
65548: LIST
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PPUSH
65554: CALL_OW 72
65558: ST_TO_ADDR
// if cranes then
65559: LD_VAR 0 6
65563: IFFALSE 65625
// for j in cranes do
65565: LD_ADDR_VAR 0 3
65569: PUSH
65570: LD_VAR 0 6
65574: PUSH
65575: FOR_IN
65576: IFFALSE 65623
// if not IsInArea ( j , mc_parking [ i ] ) then
65578: LD_VAR 0 3
65582: PPUSH
65583: LD_EXP 85
65587: PUSH
65588: LD_VAR 0 2
65592: ARRAY
65593: PPUSH
65594: CALL_OW 308
65598: NOT
65599: IFFALSE 65621
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65601: LD_VAR 0 3
65605: PPUSH
65606: LD_EXP 85
65610: PUSH
65611: LD_VAR 0 2
65615: ARRAY
65616: PPUSH
65617: CALL_OW 113
65621: GO 65575
65623: POP
65624: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65625: LD_ADDR_EXP 63
65629: PUSH
65630: LD_EXP 63
65634: PPUSH
65635: LD_VAR 0 2
65639: PPUSH
65640: EMPTY
65641: PPUSH
65642: CALL_OW 1
65646: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65647: LD_VAR 0 2
65651: PPUSH
65652: LD_INT 101
65654: PPUSH
65655: CALL 60515 0 2
// continue ;
65659: GO 65462
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65661: LD_ADDR_EXP 67
65665: PUSH
65666: LD_EXP 67
65670: PPUSH
65671: LD_VAR 0 2
65675: PPUSH
65676: EMPTY
65677: PPUSH
65678: CALL_OW 1
65682: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65683: LD_VAR 0 2
65687: PPUSH
65688: LD_INT 103
65690: PPUSH
65691: CALL 60515 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65695: LD_ADDR_VAR 0 5
65699: PUSH
65700: LD_EXP 61
65704: PUSH
65705: LD_VAR 0 2
65709: ARRAY
65710: PUSH
65711: LD_EXP 90
65715: PUSH
65716: LD_VAR 0 2
65720: ARRAY
65721: UNION
65722: PPUSH
65723: LD_INT 2
65725: PUSH
65726: LD_INT 25
65728: PUSH
65729: LD_INT 2
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 25
65738: PUSH
65739: LD_INT 16
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: EMPTY
65747: LIST
65748: LIST
65749: LIST
65750: PUSH
65751: EMPTY
65752: LIST
65753: PPUSH
65754: CALL_OW 72
65758: ST_TO_ADDR
// if mc_need_heal [ i ] then
65759: LD_EXP 64
65763: PUSH
65764: LD_VAR 0 2
65768: ARRAY
65769: IFFALSE 65813
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65771: LD_ADDR_VAR 0 5
65775: PUSH
65776: LD_VAR 0 5
65780: PUSH
65781: LD_EXP 64
65785: PUSH
65786: LD_VAR 0 2
65790: ARRAY
65791: PUSH
65792: LD_INT 1
65794: ARRAY
65795: PUSH
65796: LD_EXP 64
65800: PUSH
65801: LD_VAR 0 2
65805: ARRAY
65806: PUSH
65807: LD_INT 2
65809: ARRAY
65810: UNION
65811: DIFF
65812: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65813: LD_ADDR_VAR 0 6
65817: PUSH
65818: LD_EXP 80
65822: PUSH
65823: LD_VAR 0 2
65827: ARRAY
65828: PPUSH
65829: LD_INT 2
65831: PUSH
65832: LD_INT 34
65834: PUSH
65835: LD_INT 13
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PUSH
65842: LD_INT 34
65844: PUSH
65845: LD_INT 52
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 34
65854: PUSH
65855: LD_INT 88
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: PPUSH
65868: CALL_OW 72
65872: ST_TO_ADDR
// if cranes then
65873: LD_VAR 0 6
65877: IFFALSE 66045
// begin for j in cranes do
65879: LD_ADDR_VAR 0 3
65883: PUSH
65884: LD_VAR 0 6
65888: PUSH
65889: FOR_IN
65890: IFFALSE 66043
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65892: LD_VAR 0 3
65896: PPUSH
65897: CALL_OW 256
65901: PUSH
65902: LD_INT 1000
65904: EQUAL
65905: PUSH
65906: LD_VAR 0 3
65910: PPUSH
65911: CALL_OW 314
65915: NOT
65916: AND
65917: IFFALSE 65983
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
65919: LD_ADDR_VAR 0 8
65923: PUSH
65924: LD_EXP 62
65928: PUSH
65929: LD_VAR 0 2
65933: ARRAY
65934: PPUSH
65935: LD_VAR 0 3
65939: PPUSH
65940: CALL_OW 74
65944: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65945: LD_VAR 0 8
65949: PPUSH
65950: LD_INT 16
65952: PPUSH
65953: CALL 22667 0 2
65957: PUSH
65958: LD_INT 4
65960: ARRAY
65961: PUSH
65962: LD_INT 10
65964: LESS
65965: IFFALSE 65981
// ComRepairBuilding ( j , to_repair ) ;
65967: LD_VAR 0 3
65971: PPUSH
65972: LD_VAR 0 8
65976: PPUSH
65977: CALL_OW 130
// end else
65981: GO 66041
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65983: LD_VAR 0 3
65987: PPUSH
65988: CALL_OW 256
65992: PUSH
65993: LD_INT 500
65995: LESS
65996: PUSH
65997: LD_VAR 0 3
66001: PPUSH
66002: LD_EXP 85
66006: PUSH
66007: LD_VAR 0 2
66011: ARRAY
66012: PPUSH
66013: CALL_OW 308
66017: NOT
66018: AND
66019: IFFALSE 66041
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66021: LD_VAR 0 3
66025: PPUSH
66026: LD_EXP 85
66030: PUSH
66031: LD_VAR 0 2
66035: ARRAY
66036: PPUSH
66037: CALL_OW 113
// end ;
66041: GO 65889
66043: POP
66044: POP
// end ; if tmp > 3 then
66045: LD_VAR 0 5
66049: PUSH
66050: LD_INT 3
66052: GREATER
66053: IFFALSE 66073
// tmp := ShrinkArray ( tmp , 4 ) ;
66055: LD_ADDR_VAR 0 5
66059: PUSH
66060: LD_VAR 0 5
66064: PPUSH
66065: LD_INT 4
66067: PPUSH
66068: CALL 52716 0 2
66072: ST_TO_ADDR
// if not tmp then
66073: LD_VAR 0 5
66077: NOT
66078: IFFALSE 66082
// continue ;
66080: GO 65462
// for j in tmp do
66082: LD_ADDR_VAR 0 3
66086: PUSH
66087: LD_VAR 0 5
66091: PUSH
66092: FOR_IN
66093: IFFALSE 66352
// begin if IsInUnit ( j ) then
66095: LD_VAR 0 3
66099: PPUSH
66100: CALL_OW 310
66104: IFFALSE 66115
// ComExitBuilding ( j ) ;
66106: LD_VAR 0 3
66110: PPUSH
66111: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66115: LD_VAR 0 3
66119: PUSH
66120: LD_EXP 63
66124: PUSH
66125: LD_VAR 0 2
66129: ARRAY
66130: IN
66131: NOT
66132: IFFALSE 66190
// begin SetTag ( j , 101 ) ;
66134: LD_VAR 0 3
66138: PPUSH
66139: LD_INT 101
66141: PPUSH
66142: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66146: LD_ADDR_EXP 63
66150: PUSH
66151: LD_EXP 63
66155: PPUSH
66156: LD_VAR 0 2
66160: PUSH
66161: LD_EXP 63
66165: PUSH
66166: LD_VAR 0 2
66170: ARRAY
66171: PUSH
66172: LD_INT 1
66174: PLUS
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: PPUSH
66180: LD_VAR 0 3
66184: PPUSH
66185: CALL 20070 0 3
66189: ST_TO_ADDR
// end ; wait ( 1 ) ;
66190: LD_INT 1
66192: PPUSH
66193: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66197: LD_ADDR_VAR 0 7
66201: PUSH
66202: LD_EXP 62
66206: PUSH
66207: LD_VAR 0 2
66211: ARRAY
66212: ST_TO_ADDR
// if mc_scan [ i ] then
66213: LD_EXP 84
66217: PUSH
66218: LD_VAR 0 2
66222: ARRAY
66223: IFFALSE 66285
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66225: LD_ADDR_VAR 0 7
66229: PUSH
66230: LD_EXP 62
66234: PUSH
66235: LD_VAR 0 2
66239: ARRAY
66240: PPUSH
66241: LD_INT 3
66243: PUSH
66244: LD_INT 30
66246: PUSH
66247: LD_INT 32
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: LD_INT 30
66256: PUSH
66257: LD_INT 33
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 30
66266: PUSH
66267: LD_INT 31
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: EMPTY
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: PPUSH
66280: CALL_OW 72
66284: ST_TO_ADDR
// if not to_repair_tmp then
66285: LD_VAR 0 7
66289: NOT
66290: IFFALSE 66294
// continue ;
66292: GO 66092
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66294: LD_ADDR_VAR 0 8
66298: PUSH
66299: LD_VAR 0 7
66303: PPUSH
66304: LD_VAR 0 3
66308: PPUSH
66309: CALL_OW 74
66313: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66314: LD_VAR 0 8
66318: PPUSH
66319: LD_INT 16
66321: PPUSH
66322: CALL 22667 0 2
66326: PUSH
66327: LD_INT 4
66329: ARRAY
66330: PUSH
66331: LD_INT 14
66333: LESS
66334: IFFALSE 66350
// ComRepairBuilding ( j , to_repair ) ;
66336: LD_VAR 0 3
66340: PPUSH
66341: LD_VAR 0 8
66345: PPUSH
66346: CALL_OW 130
// end ;
66350: GO 66092
66352: POP
66353: POP
// end ;
66354: GO 65462
66356: POP
66357: POP
// end ;
66358: LD_VAR 0 1
66362: RET
// export function MC_Heal ; var i , j , tmp ; begin
66363: LD_INT 0
66365: PPUSH
66366: PPUSH
66367: PPUSH
66368: PPUSH
// if not mc_bases then
66369: LD_EXP 61
66373: NOT
66374: IFFALSE 66378
// exit ;
66376: GO 66780
// for i = 1 to mc_bases do
66378: LD_ADDR_VAR 0 2
66382: PUSH
66383: DOUBLE
66384: LD_INT 1
66386: DEC
66387: ST_TO_ADDR
66388: LD_EXP 61
66392: PUSH
66393: FOR_TO
66394: IFFALSE 66778
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66396: LD_EXP 64
66400: PUSH
66401: LD_VAR 0 2
66405: ARRAY
66406: PUSH
66407: LD_INT 1
66409: ARRAY
66410: NOT
66411: PUSH
66412: LD_EXP 64
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PUSH
66423: LD_INT 2
66425: ARRAY
66426: NOT
66427: AND
66428: IFFALSE 66466
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66430: LD_ADDR_EXP 65
66434: PUSH
66435: LD_EXP 65
66439: PPUSH
66440: LD_VAR 0 2
66444: PPUSH
66445: EMPTY
66446: PPUSH
66447: CALL_OW 1
66451: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66452: LD_VAR 0 2
66456: PPUSH
66457: LD_INT 102
66459: PPUSH
66460: CALL 60515 0 2
// continue ;
66464: GO 66393
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66466: LD_ADDR_VAR 0 4
66470: PUSH
66471: LD_EXP 61
66475: PUSH
66476: LD_VAR 0 2
66480: ARRAY
66481: PPUSH
66482: LD_INT 25
66484: PUSH
66485: LD_INT 4
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PPUSH
66492: CALL_OW 72
66496: ST_TO_ADDR
// if not tmp then
66497: LD_VAR 0 4
66501: NOT
66502: IFFALSE 66506
// continue ;
66504: GO 66393
// if mc_taming [ i ] then
66506: LD_EXP 92
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: IFFALSE 66540
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66518: LD_ADDR_EXP 92
66522: PUSH
66523: LD_EXP 92
66527: PPUSH
66528: LD_VAR 0 2
66532: PPUSH
66533: EMPTY
66534: PPUSH
66535: CALL_OW 1
66539: ST_TO_ADDR
// for j in tmp do
66540: LD_ADDR_VAR 0 3
66544: PUSH
66545: LD_VAR 0 4
66549: PUSH
66550: FOR_IN
66551: IFFALSE 66774
// begin if IsInUnit ( j ) then
66553: LD_VAR 0 3
66557: PPUSH
66558: CALL_OW 310
66562: IFFALSE 66573
// ComExitBuilding ( j ) ;
66564: LD_VAR 0 3
66568: PPUSH
66569: CALL_OW 122
// if not j in mc_healers [ i ] then
66573: LD_VAR 0 3
66577: PUSH
66578: LD_EXP 65
66582: PUSH
66583: LD_VAR 0 2
66587: ARRAY
66588: IN
66589: NOT
66590: IFFALSE 66636
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66592: LD_ADDR_EXP 65
66596: PUSH
66597: LD_EXP 65
66601: PPUSH
66602: LD_VAR 0 2
66606: PUSH
66607: LD_EXP 65
66611: PUSH
66612: LD_VAR 0 2
66616: ARRAY
66617: PUSH
66618: LD_INT 1
66620: PLUS
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PPUSH
66626: LD_VAR 0 3
66630: PPUSH
66631: CALL 20070 0 3
66635: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66636: LD_VAR 0 3
66640: PPUSH
66641: CALL_OW 110
66645: PUSH
66646: LD_INT 102
66648: NONEQUAL
66649: IFFALSE 66663
// SetTag ( j , 102 ) ;
66651: LD_VAR 0 3
66655: PPUSH
66656: LD_INT 102
66658: PPUSH
66659: CALL_OW 109
// Wait ( 3 ) ;
66663: LD_INT 3
66665: PPUSH
66666: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66670: LD_EXP 64
66674: PUSH
66675: LD_VAR 0 2
66679: ARRAY
66680: PUSH
66681: LD_INT 1
66683: ARRAY
66684: IFFALSE 66716
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66686: LD_VAR 0 3
66690: PPUSH
66691: LD_EXP 64
66695: PUSH
66696: LD_VAR 0 2
66700: ARRAY
66701: PUSH
66702: LD_INT 1
66704: ARRAY
66705: PUSH
66706: LD_INT 1
66708: ARRAY
66709: PPUSH
66710: CALL_OW 128
66714: GO 66772
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66716: LD_VAR 0 3
66720: PPUSH
66721: CALL_OW 314
66725: NOT
66726: PUSH
66727: LD_EXP 64
66731: PUSH
66732: LD_VAR 0 2
66736: ARRAY
66737: PUSH
66738: LD_INT 2
66740: ARRAY
66741: AND
66742: IFFALSE 66772
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66744: LD_VAR 0 3
66748: PPUSH
66749: LD_EXP 64
66753: PUSH
66754: LD_VAR 0 2
66758: ARRAY
66759: PUSH
66760: LD_INT 2
66762: ARRAY
66763: PUSH
66764: LD_INT 1
66766: ARRAY
66767: PPUSH
66768: CALL_OW 128
// end ;
66772: GO 66550
66774: POP
66775: POP
// end ;
66776: GO 66393
66778: POP
66779: POP
// end ;
66780: LD_VAR 0 1
66784: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
66785: LD_INT 0
66787: PPUSH
66788: PPUSH
66789: PPUSH
66790: PPUSH
66791: PPUSH
66792: PPUSH
// if not mc_bases then
66793: LD_EXP 61
66797: NOT
66798: IFFALSE 66802
// exit ;
66800: GO 67965
// for i = 1 to mc_bases do
66802: LD_ADDR_VAR 0 2
66806: PUSH
66807: DOUBLE
66808: LD_INT 1
66810: DEC
66811: ST_TO_ADDR
66812: LD_EXP 61
66816: PUSH
66817: FOR_TO
66818: IFFALSE 67963
// begin if mc_scan [ i ] then
66820: LD_EXP 84
66824: PUSH
66825: LD_VAR 0 2
66829: ARRAY
66830: IFFALSE 66834
// continue ;
66832: GO 66817
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66834: LD_EXP 66
66838: PUSH
66839: LD_VAR 0 2
66843: ARRAY
66844: NOT
66845: PUSH
66846: LD_EXP 68
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: NOT
66857: AND
66858: PUSH
66859: LD_EXP 67
66863: PUSH
66864: LD_VAR 0 2
66868: ARRAY
66869: AND
66870: IFFALSE 66908
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66872: LD_ADDR_EXP 67
66876: PUSH
66877: LD_EXP 67
66881: PPUSH
66882: LD_VAR 0 2
66886: PPUSH
66887: EMPTY
66888: PPUSH
66889: CALL_OW 1
66893: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66894: LD_VAR 0 2
66898: PPUSH
66899: LD_INT 103
66901: PPUSH
66902: CALL 60515 0 2
// continue ;
66906: GO 66817
// end ; if mc_construct_list [ i ] then
66908: LD_EXP 68
66912: PUSH
66913: LD_VAR 0 2
66917: ARRAY
66918: IFFALSE 67138
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66920: LD_ADDR_VAR 0 5
66924: PUSH
66925: LD_EXP 61
66929: PUSH
66930: LD_VAR 0 2
66934: ARRAY
66935: PPUSH
66936: LD_INT 25
66938: PUSH
66939: LD_INT 2
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PPUSH
66946: CALL_OW 72
66950: PUSH
66951: LD_EXP 63
66955: PUSH
66956: LD_VAR 0 2
66960: ARRAY
66961: DIFF
66962: ST_TO_ADDR
// if not tmp then
66963: LD_VAR 0 5
66967: NOT
66968: IFFALSE 66972
// continue ;
66970: GO 66817
// for j in tmp do
66972: LD_ADDR_VAR 0 3
66976: PUSH
66977: LD_VAR 0 5
66981: PUSH
66982: FOR_IN
66983: IFFALSE 67134
// begin if not mc_builders [ i ] then
66985: LD_EXP 67
66989: PUSH
66990: LD_VAR 0 2
66994: ARRAY
66995: NOT
66996: IFFALSE 67054
// begin SetTag ( j , 103 ) ;
66998: LD_VAR 0 3
67002: PPUSH
67003: LD_INT 103
67005: PPUSH
67006: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67010: LD_ADDR_EXP 67
67014: PUSH
67015: LD_EXP 67
67019: PPUSH
67020: LD_VAR 0 2
67024: PUSH
67025: LD_EXP 67
67029: PUSH
67030: LD_VAR 0 2
67034: ARRAY
67035: PUSH
67036: LD_INT 1
67038: PLUS
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PPUSH
67044: LD_VAR 0 3
67048: PPUSH
67049: CALL 20070 0 3
67053: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67054: LD_VAR 0 3
67058: PPUSH
67059: CALL_OW 310
67063: IFFALSE 67074
// ComExitBuilding ( j ) ;
67065: LD_VAR 0 3
67069: PPUSH
67070: CALL_OW 122
// wait ( 3 ) ;
67074: LD_INT 3
67076: PPUSH
67077: CALL_OW 67
// if not mc_construct_list [ i ] then
67081: LD_EXP 68
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: NOT
67092: IFFALSE 67096
// break ;
67094: GO 67134
// if not HasTask ( j ) then
67096: LD_VAR 0 3
67100: PPUSH
67101: CALL_OW 314
67105: NOT
67106: IFFALSE 67132
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67108: LD_VAR 0 3
67112: PPUSH
67113: LD_EXP 68
67117: PUSH
67118: LD_VAR 0 2
67122: ARRAY
67123: PUSH
67124: LD_INT 1
67126: ARRAY
67127: PPUSH
67128: CALL 22931 0 2
// end ;
67132: GO 66982
67134: POP
67135: POP
// end else
67136: GO 67961
// if mc_build_list [ i ] then
67138: LD_EXP 66
67142: PUSH
67143: LD_VAR 0 2
67147: ARRAY
67148: IFFALSE 67961
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67150: LD_EXP 66
67154: PUSH
67155: LD_VAR 0 2
67159: ARRAY
67160: PUSH
67161: LD_INT 1
67163: ARRAY
67164: PUSH
67165: LD_INT 1
67167: ARRAY
67168: PPUSH
67169: CALL 22755 0 1
67173: PUSH
67174: LD_EXP 61
67178: PUSH
67179: LD_VAR 0 2
67183: ARRAY
67184: PPUSH
67185: LD_INT 2
67187: PUSH
67188: LD_INT 30
67190: PUSH
67191: LD_INT 2
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 30
67200: PUSH
67201: LD_INT 3
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: LIST
67212: PPUSH
67213: CALL_OW 72
67217: NOT
67218: AND
67219: IFFALSE 67324
// begin for j = 1 to mc_build_list [ i ] do
67221: LD_ADDR_VAR 0 3
67225: PUSH
67226: DOUBLE
67227: LD_INT 1
67229: DEC
67230: ST_TO_ADDR
67231: LD_EXP 66
67235: PUSH
67236: LD_VAR 0 2
67240: ARRAY
67241: PUSH
67242: FOR_TO
67243: IFFALSE 67322
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67245: LD_EXP 66
67249: PUSH
67250: LD_VAR 0 2
67254: ARRAY
67255: PUSH
67256: LD_VAR 0 3
67260: ARRAY
67261: PUSH
67262: LD_INT 1
67264: ARRAY
67265: PUSH
67266: LD_INT 2
67268: EQUAL
67269: IFFALSE 67320
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67271: LD_ADDR_EXP 66
67275: PUSH
67276: LD_EXP 66
67280: PPUSH
67281: LD_VAR 0 2
67285: PPUSH
67286: LD_EXP 66
67290: PUSH
67291: LD_VAR 0 2
67295: ARRAY
67296: PPUSH
67297: LD_VAR 0 3
67301: PPUSH
67302: LD_INT 1
67304: PPUSH
67305: LD_INT 0
67307: PPUSH
67308: CALL 19488 0 4
67312: PPUSH
67313: CALL_OW 1
67317: ST_TO_ADDR
// break ;
67318: GO 67322
// end ;
67320: GO 67242
67322: POP
67323: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67324: LD_ADDR_VAR 0 6
67328: PUSH
67329: LD_EXP 61
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: PPUSH
67340: LD_INT 2
67342: PUSH
67343: LD_INT 30
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 30
67355: PUSH
67356: LD_INT 1
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: LIST
67367: PPUSH
67368: CALL_OW 72
67372: ST_TO_ADDR
// for k := 1 to depot do
67373: LD_ADDR_VAR 0 4
67377: PUSH
67378: DOUBLE
67379: LD_INT 1
67381: DEC
67382: ST_TO_ADDR
67383: LD_VAR 0 6
67387: PUSH
67388: FOR_TO
67389: IFFALSE 67959
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67391: LD_EXP 66
67395: PUSH
67396: LD_VAR 0 2
67400: ARRAY
67401: PUSH
67402: LD_INT 1
67404: ARRAY
67405: PUSH
67406: LD_INT 1
67408: ARRAY
67409: PUSH
67410: LD_INT 0
67412: EQUAL
67413: PUSH
67414: LD_VAR 0 6
67418: PUSH
67419: LD_VAR 0 4
67423: ARRAY
67424: PPUSH
67425: LD_EXP 66
67429: PUSH
67430: LD_VAR 0 2
67434: ARRAY
67435: PUSH
67436: LD_INT 1
67438: ARRAY
67439: PUSH
67440: LD_INT 1
67442: ARRAY
67443: PPUSH
67444: LD_EXP 66
67448: PUSH
67449: LD_VAR 0 2
67453: ARRAY
67454: PUSH
67455: LD_INT 1
67457: ARRAY
67458: PUSH
67459: LD_INT 2
67461: ARRAY
67462: PPUSH
67463: LD_EXP 66
67467: PUSH
67468: LD_VAR 0 2
67472: ARRAY
67473: PUSH
67474: LD_INT 1
67476: ARRAY
67477: PUSH
67478: LD_INT 3
67480: ARRAY
67481: PPUSH
67482: LD_EXP 66
67486: PUSH
67487: LD_VAR 0 2
67491: ARRAY
67492: PUSH
67493: LD_INT 1
67495: ARRAY
67496: PUSH
67497: LD_INT 4
67499: ARRAY
67500: PPUSH
67501: CALL 28167 0 5
67505: OR
67506: IFFALSE 67787
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67508: LD_ADDR_VAR 0 5
67512: PUSH
67513: LD_EXP 61
67517: PUSH
67518: LD_VAR 0 2
67522: ARRAY
67523: PPUSH
67524: LD_INT 25
67526: PUSH
67527: LD_INT 2
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PPUSH
67534: CALL_OW 72
67538: PUSH
67539: LD_EXP 63
67543: PUSH
67544: LD_VAR 0 2
67548: ARRAY
67549: DIFF
67550: ST_TO_ADDR
// if not tmp then
67551: LD_VAR 0 5
67555: NOT
67556: IFFALSE 67560
// continue ;
67558: GO 67388
// for j in tmp do
67560: LD_ADDR_VAR 0 3
67564: PUSH
67565: LD_VAR 0 5
67569: PUSH
67570: FOR_IN
67571: IFFALSE 67783
// begin if not mc_builders [ i ] then
67573: LD_EXP 67
67577: PUSH
67578: LD_VAR 0 2
67582: ARRAY
67583: NOT
67584: IFFALSE 67642
// begin SetTag ( j , 103 ) ;
67586: LD_VAR 0 3
67590: PPUSH
67591: LD_INT 103
67593: PPUSH
67594: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67598: LD_ADDR_EXP 67
67602: PUSH
67603: LD_EXP 67
67607: PPUSH
67608: LD_VAR 0 2
67612: PUSH
67613: LD_EXP 67
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PUSH
67624: LD_INT 1
67626: PLUS
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PPUSH
67632: LD_VAR 0 3
67636: PPUSH
67637: CALL 20070 0 3
67641: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67642: LD_VAR 0 3
67646: PPUSH
67647: CALL_OW 310
67651: IFFALSE 67662
// ComExitBuilding ( j ) ;
67653: LD_VAR 0 3
67657: PPUSH
67658: CALL_OW 122
// wait ( 3 ) ;
67662: LD_INT 3
67664: PPUSH
67665: CALL_OW 67
// if not mc_build_list [ i ] then
67669: LD_EXP 66
67673: PUSH
67674: LD_VAR 0 2
67678: ARRAY
67679: NOT
67680: IFFALSE 67684
// break ;
67682: GO 67783
// if not HasTask ( j ) then
67684: LD_VAR 0 3
67688: PPUSH
67689: CALL_OW 314
67693: NOT
67694: IFFALSE 67781
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67696: LD_VAR 0 3
67700: PPUSH
67701: LD_EXP 66
67705: PUSH
67706: LD_VAR 0 2
67710: ARRAY
67711: PUSH
67712: LD_INT 1
67714: ARRAY
67715: PUSH
67716: LD_INT 1
67718: ARRAY
67719: PPUSH
67720: LD_EXP 66
67724: PUSH
67725: LD_VAR 0 2
67729: ARRAY
67730: PUSH
67731: LD_INT 1
67733: ARRAY
67734: PUSH
67735: LD_INT 2
67737: ARRAY
67738: PPUSH
67739: LD_EXP 66
67743: PUSH
67744: LD_VAR 0 2
67748: ARRAY
67749: PUSH
67750: LD_INT 1
67752: ARRAY
67753: PUSH
67754: LD_INT 3
67756: ARRAY
67757: PPUSH
67758: LD_EXP 66
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: PUSH
67769: LD_INT 1
67771: ARRAY
67772: PUSH
67773: LD_INT 4
67775: ARRAY
67776: PPUSH
67777: CALL_OW 145
// end ;
67781: GO 67570
67783: POP
67784: POP
// end else
67785: GO 67957
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67787: LD_EXP 61
67791: PUSH
67792: LD_VAR 0 2
67796: ARRAY
67797: PPUSH
67798: LD_EXP 66
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: PUSH
67813: LD_INT 1
67815: ARRAY
67816: PPUSH
67817: LD_EXP 66
67821: PUSH
67822: LD_VAR 0 2
67826: ARRAY
67827: PUSH
67828: LD_INT 1
67830: ARRAY
67831: PUSH
67832: LD_INT 2
67834: ARRAY
67835: PPUSH
67836: LD_EXP 66
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PUSH
67847: LD_INT 1
67849: ARRAY
67850: PUSH
67851: LD_INT 3
67853: ARRAY
67854: PPUSH
67855: LD_EXP 66
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: PUSH
67866: LD_INT 1
67868: ARRAY
67869: PUSH
67870: LD_INT 4
67872: ARRAY
67873: PPUSH
67874: LD_EXP 61
67878: PUSH
67879: LD_VAR 0 2
67883: ARRAY
67884: PPUSH
67885: LD_INT 21
67887: PUSH
67888: LD_INT 3
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PPUSH
67895: CALL_OW 72
67899: PPUSH
67900: EMPTY
67901: PPUSH
67902: CALL 26921 0 7
67906: NOT
67907: IFFALSE 67957
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67909: LD_ADDR_EXP 66
67913: PUSH
67914: LD_EXP 66
67918: PPUSH
67919: LD_VAR 0 2
67923: PPUSH
67924: LD_EXP 66
67928: PUSH
67929: LD_VAR 0 2
67933: ARRAY
67934: PPUSH
67935: LD_INT 1
67937: PPUSH
67938: LD_INT 1
67940: NEG
67941: PPUSH
67942: LD_INT 0
67944: PPUSH
67945: CALL 19488 0 4
67949: PPUSH
67950: CALL_OW 1
67954: ST_TO_ADDR
// continue ;
67955: GO 67388
// end ; end ;
67957: GO 67388
67959: POP
67960: POP
// end ; end ;
67961: GO 66817
67963: POP
67964: POP
// end ;
67965: LD_VAR 0 1
67969: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67970: LD_INT 0
67972: PPUSH
67973: PPUSH
67974: PPUSH
67975: PPUSH
67976: PPUSH
67977: PPUSH
// if not mc_bases then
67978: LD_EXP 61
67982: NOT
67983: IFFALSE 67987
// exit ;
67985: GO 68414
// for i = 1 to mc_bases do
67987: LD_ADDR_VAR 0 2
67991: PUSH
67992: DOUBLE
67993: LD_INT 1
67995: DEC
67996: ST_TO_ADDR
67997: LD_EXP 61
68001: PUSH
68002: FOR_TO
68003: IFFALSE 68412
// begin tmp := mc_build_upgrade [ i ] ;
68005: LD_ADDR_VAR 0 4
68009: PUSH
68010: LD_EXP 93
68014: PUSH
68015: LD_VAR 0 2
68019: ARRAY
68020: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68021: LD_ADDR_VAR 0 6
68025: PUSH
68026: LD_EXP 94
68030: PUSH
68031: LD_VAR 0 2
68035: ARRAY
68036: PPUSH
68037: LD_INT 2
68039: PUSH
68040: LD_INT 30
68042: PUSH
68043: LD_INT 6
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 30
68052: PUSH
68053: LD_INT 7
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: LIST
68064: PPUSH
68065: CALL_OW 72
68069: ST_TO_ADDR
// if not tmp and not lab then
68070: LD_VAR 0 4
68074: NOT
68075: PUSH
68076: LD_VAR 0 6
68080: NOT
68081: AND
68082: IFFALSE 68086
// continue ;
68084: GO 68002
// if tmp then
68086: LD_VAR 0 4
68090: IFFALSE 68210
// for j in tmp do
68092: LD_ADDR_VAR 0 3
68096: PUSH
68097: LD_VAR 0 4
68101: PUSH
68102: FOR_IN
68103: IFFALSE 68208
// begin if UpgradeCost ( j ) then
68105: LD_VAR 0 3
68109: PPUSH
68110: CALL 26581 0 1
68114: IFFALSE 68206
// begin ComUpgrade ( j ) ;
68116: LD_VAR 0 3
68120: PPUSH
68121: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68125: LD_ADDR_EXP 93
68129: PUSH
68130: LD_EXP 93
68134: PPUSH
68135: LD_VAR 0 2
68139: PPUSH
68140: LD_EXP 93
68144: PUSH
68145: LD_VAR 0 2
68149: ARRAY
68150: PUSH
68151: LD_VAR 0 3
68155: DIFF
68156: PPUSH
68157: CALL_OW 1
68161: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68162: LD_ADDR_EXP 68
68166: PUSH
68167: LD_EXP 68
68171: PPUSH
68172: LD_VAR 0 2
68176: PUSH
68177: LD_EXP 68
68181: PUSH
68182: LD_VAR 0 2
68186: ARRAY
68187: PUSH
68188: LD_INT 1
68190: PLUS
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PPUSH
68196: LD_VAR 0 3
68200: PPUSH
68201: CALL 20070 0 3
68205: ST_TO_ADDR
// end ; end ;
68206: GO 68102
68208: POP
68209: POP
// if not lab or not mc_lab_upgrade [ i ] then
68210: LD_VAR 0 6
68214: NOT
68215: PUSH
68216: LD_EXP 95
68220: PUSH
68221: LD_VAR 0 2
68225: ARRAY
68226: NOT
68227: OR
68228: IFFALSE 68232
// continue ;
68230: GO 68002
// for j in lab do
68232: LD_ADDR_VAR 0 3
68236: PUSH
68237: LD_VAR 0 6
68241: PUSH
68242: FOR_IN
68243: IFFALSE 68408
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68245: LD_VAR 0 3
68249: PPUSH
68250: CALL_OW 266
68254: PUSH
68255: LD_INT 6
68257: PUSH
68258: LD_INT 7
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: IN
68265: PUSH
68266: LD_VAR 0 3
68270: PPUSH
68271: CALL_OW 461
68275: PUSH
68276: LD_INT 1
68278: NONEQUAL
68279: AND
68280: IFFALSE 68406
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68282: LD_VAR 0 3
68286: PPUSH
68287: LD_EXP 95
68291: PUSH
68292: LD_VAR 0 2
68296: ARRAY
68297: PUSH
68298: LD_INT 1
68300: ARRAY
68301: PPUSH
68302: CALL 26786 0 2
68306: IFFALSE 68406
// begin ComCancel ( j ) ;
68308: LD_VAR 0 3
68312: PPUSH
68313: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68317: LD_VAR 0 3
68321: PPUSH
68322: LD_EXP 95
68326: PUSH
68327: LD_VAR 0 2
68331: ARRAY
68332: PUSH
68333: LD_INT 1
68335: ARRAY
68336: PPUSH
68337: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68341: LD_VAR 0 3
68345: PUSH
68346: LD_EXP 68
68350: PUSH
68351: LD_VAR 0 2
68355: ARRAY
68356: IN
68357: NOT
68358: IFFALSE 68404
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68360: LD_ADDR_EXP 68
68364: PUSH
68365: LD_EXP 68
68369: PPUSH
68370: LD_VAR 0 2
68374: PUSH
68375: LD_EXP 68
68379: PUSH
68380: LD_VAR 0 2
68384: ARRAY
68385: PUSH
68386: LD_INT 1
68388: PLUS
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PPUSH
68394: LD_VAR 0 3
68398: PPUSH
68399: CALL 20070 0 3
68403: ST_TO_ADDR
// break ;
68404: GO 68408
// end ; end ; end ;
68406: GO 68242
68408: POP
68409: POP
// end ;
68410: GO 68002
68412: POP
68413: POP
// end ;
68414: LD_VAR 0 1
68418: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68419: LD_INT 0
68421: PPUSH
68422: PPUSH
68423: PPUSH
68424: PPUSH
68425: PPUSH
68426: PPUSH
68427: PPUSH
68428: PPUSH
68429: PPUSH
// if not mc_bases then
68430: LD_EXP 61
68434: NOT
68435: IFFALSE 68439
// exit ;
68437: GO 68844
// for i = 1 to mc_bases do
68439: LD_ADDR_VAR 0 2
68443: PUSH
68444: DOUBLE
68445: LD_INT 1
68447: DEC
68448: ST_TO_ADDR
68449: LD_EXP 61
68453: PUSH
68454: FOR_TO
68455: IFFALSE 68842
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68457: LD_EXP 69
68461: PUSH
68462: LD_VAR 0 2
68466: ARRAY
68467: NOT
68468: PUSH
68469: LD_EXP 61
68473: PUSH
68474: LD_VAR 0 2
68478: ARRAY
68479: PPUSH
68480: LD_INT 30
68482: PUSH
68483: LD_INT 3
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PPUSH
68490: CALL_OW 72
68494: NOT
68495: OR
68496: IFFALSE 68500
// continue ;
68498: GO 68454
// busy := false ;
68500: LD_ADDR_VAR 0 8
68504: PUSH
68505: LD_INT 0
68507: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68508: LD_ADDR_VAR 0 4
68512: PUSH
68513: LD_EXP 61
68517: PUSH
68518: LD_VAR 0 2
68522: ARRAY
68523: PPUSH
68524: LD_INT 30
68526: PUSH
68527: LD_INT 3
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PPUSH
68534: CALL_OW 72
68538: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68539: LD_ADDR_VAR 0 6
68543: PUSH
68544: LD_EXP 69
68548: PUSH
68549: LD_VAR 0 2
68553: ARRAY
68554: PPUSH
68555: LD_INT 2
68557: PUSH
68558: LD_INT 30
68560: PUSH
68561: LD_INT 32
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PUSH
68568: LD_INT 30
68570: PUSH
68571: LD_INT 33
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: LIST
68582: PPUSH
68583: CALL_OW 72
68587: ST_TO_ADDR
// if not t then
68588: LD_VAR 0 6
68592: NOT
68593: IFFALSE 68597
// continue ;
68595: GO 68454
// for j in tmp do
68597: LD_ADDR_VAR 0 3
68601: PUSH
68602: LD_VAR 0 4
68606: PUSH
68607: FOR_IN
68608: IFFALSE 68638
// if not BuildingStatus ( j ) = bs_idle then
68610: LD_VAR 0 3
68614: PPUSH
68615: CALL_OW 461
68619: PUSH
68620: LD_INT 2
68622: EQUAL
68623: NOT
68624: IFFALSE 68636
// begin busy := true ;
68626: LD_ADDR_VAR 0 8
68630: PUSH
68631: LD_INT 1
68633: ST_TO_ADDR
// break ;
68634: GO 68638
// end ;
68636: GO 68607
68638: POP
68639: POP
// if busy then
68640: LD_VAR 0 8
68644: IFFALSE 68648
// continue ;
68646: GO 68454
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68648: LD_ADDR_VAR 0 7
68652: PUSH
68653: LD_VAR 0 6
68657: PPUSH
68658: LD_INT 35
68660: PUSH
68661: LD_INT 0
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PPUSH
68668: CALL_OW 72
68672: ST_TO_ADDR
// if tw then
68673: LD_VAR 0 7
68677: IFFALSE 68754
// begin tw := tw [ 1 ] ;
68679: LD_ADDR_VAR 0 7
68683: PUSH
68684: LD_VAR 0 7
68688: PUSH
68689: LD_INT 1
68691: ARRAY
68692: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68693: LD_ADDR_VAR 0 9
68697: PUSH
68698: LD_VAR 0 7
68702: PPUSH
68703: LD_EXP 86
68707: PUSH
68708: LD_VAR 0 2
68712: ARRAY
68713: PPUSH
68714: CALL 25078 0 2
68718: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68719: LD_EXP 100
68723: PUSH
68724: LD_VAR 0 2
68728: ARRAY
68729: IFFALSE 68752
// if not weapon in mc_allowed_tower_weapons [ i ] then
68731: LD_VAR 0 9
68735: PUSH
68736: LD_EXP 100
68740: PUSH
68741: LD_VAR 0 2
68745: ARRAY
68746: IN
68747: NOT
68748: IFFALSE 68752
// continue ;
68750: GO 68454
// end else
68752: GO 68817
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68754: LD_ADDR_VAR 0 5
68758: PUSH
68759: LD_EXP 69
68763: PUSH
68764: LD_VAR 0 2
68768: ARRAY
68769: PPUSH
68770: LD_VAR 0 4
68774: PPUSH
68775: CALL 51949 0 2
68779: ST_TO_ADDR
// if not tmp2 then
68780: LD_VAR 0 5
68784: NOT
68785: IFFALSE 68789
// continue ;
68787: GO 68454
// tw := tmp2 [ 1 ] ;
68789: LD_ADDR_VAR 0 7
68793: PUSH
68794: LD_VAR 0 5
68798: PUSH
68799: LD_INT 1
68801: ARRAY
68802: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68803: LD_ADDR_VAR 0 9
68807: PUSH
68808: LD_VAR 0 5
68812: PUSH
68813: LD_INT 2
68815: ARRAY
68816: ST_TO_ADDR
// end ; if not weapon then
68817: LD_VAR 0 9
68821: NOT
68822: IFFALSE 68826
// continue ;
68824: GO 68454
// ComPlaceWeapon ( tw , weapon ) ;
68826: LD_VAR 0 7
68830: PPUSH
68831: LD_VAR 0 9
68835: PPUSH
68836: CALL_OW 148
// end ;
68840: GO 68454
68842: POP
68843: POP
// end ;
68844: LD_VAR 0 1
68848: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68849: LD_INT 0
68851: PPUSH
68852: PPUSH
68853: PPUSH
68854: PPUSH
68855: PPUSH
68856: PPUSH
68857: PPUSH
// if not mc_bases then
68858: LD_EXP 61
68862: NOT
68863: IFFALSE 68867
// exit ;
68865: GO 69635
// for i = 1 to mc_bases do
68867: LD_ADDR_VAR 0 2
68871: PUSH
68872: DOUBLE
68873: LD_INT 1
68875: DEC
68876: ST_TO_ADDR
68877: LD_EXP 61
68881: PUSH
68882: FOR_TO
68883: IFFALSE 69633
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68885: LD_EXP 74
68889: PUSH
68890: LD_VAR 0 2
68894: ARRAY
68895: NOT
68896: PUSH
68897: LD_EXP 74
68901: PUSH
68902: LD_VAR 0 2
68906: ARRAY
68907: PUSH
68908: LD_EXP 75
68912: PUSH
68913: LD_VAR 0 2
68917: ARRAY
68918: EQUAL
68919: OR
68920: PUSH
68921: LD_EXP 84
68925: PUSH
68926: LD_VAR 0 2
68930: ARRAY
68931: OR
68932: IFFALSE 68936
// continue ;
68934: GO 68882
// if mc_miners [ i ] then
68936: LD_EXP 75
68940: PUSH
68941: LD_VAR 0 2
68945: ARRAY
68946: IFFALSE 69320
// begin for j = mc_miners [ i ] downto 1 do
68948: LD_ADDR_VAR 0 3
68952: PUSH
68953: DOUBLE
68954: LD_EXP 75
68958: PUSH
68959: LD_VAR 0 2
68963: ARRAY
68964: INC
68965: ST_TO_ADDR
68966: LD_INT 1
68968: PUSH
68969: FOR_DOWNTO
68970: IFFALSE 69318
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68972: LD_EXP 75
68976: PUSH
68977: LD_VAR 0 2
68981: ARRAY
68982: PUSH
68983: LD_VAR 0 3
68987: ARRAY
68988: PPUSH
68989: CALL_OW 301
68993: PUSH
68994: LD_EXP 75
68998: PUSH
68999: LD_VAR 0 2
69003: ARRAY
69004: PUSH
69005: LD_VAR 0 3
69009: ARRAY
69010: PPUSH
69011: CALL_OW 257
69015: PUSH
69016: LD_INT 1
69018: NONEQUAL
69019: OR
69020: IFFALSE 69083
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69022: LD_ADDR_VAR 0 5
69026: PUSH
69027: LD_EXP 75
69031: PUSH
69032: LD_VAR 0 2
69036: ARRAY
69037: PUSH
69038: LD_EXP 75
69042: PUSH
69043: LD_VAR 0 2
69047: ARRAY
69048: PUSH
69049: LD_VAR 0 3
69053: ARRAY
69054: DIFF
69055: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69056: LD_ADDR_EXP 75
69060: PUSH
69061: LD_EXP 75
69065: PPUSH
69066: LD_VAR 0 2
69070: PPUSH
69071: LD_VAR 0 5
69075: PPUSH
69076: CALL_OW 1
69080: ST_TO_ADDR
// continue ;
69081: GO 68969
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69083: LD_EXP 75
69087: PUSH
69088: LD_VAR 0 2
69092: ARRAY
69093: PUSH
69094: LD_VAR 0 3
69098: ARRAY
69099: PPUSH
69100: CALL_OW 257
69104: PUSH
69105: LD_INT 1
69107: EQUAL
69108: PUSH
69109: LD_EXP 75
69113: PUSH
69114: LD_VAR 0 2
69118: ARRAY
69119: PUSH
69120: LD_VAR 0 3
69124: ARRAY
69125: PPUSH
69126: CALL_OW 459
69130: NOT
69131: AND
69132: PUSH
69133: LD_EXP 75
69137: PUSH
69138: LD_VAR 0 2
69142: ARRAY
69143: PUSH
69144: LD_VAR 0 3
69148: ARRAY
69149: PPUSH
69150: CALL_OW 314
69154: NOT
69155: AND
69156: IFFALSE 69316
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69158: LD_EXP 75
69162: PUSH
69163: LD_VAR 0 2
69167: ARRAY
69168: PUSH
69169: LD_VAR 0 3
69173: ARRAY
69174: PPUSH
69175: CALL_OW 310
69179: IFFALSE 69202
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69181: LD_EXP 75
69185: PUSH
69186: LD_VAR 0 2
69190: ARRAY
69191: PUSH
69192: LD_VAR 0 3
69196: ARRAY
69197: PPUSH
69198: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69202: LD_EXP 75
69206: PUSH
69207: LD_VAR 0 2
69211: ARRAY
69212: PUSH
69213: LD_VAR 0 3
69217: ARRAY
69218: PPUSH
69219: CALL_OW 314
69223: NOT
69224: IFFALSE 69316
// begin r := rand ( 1 , mc_mines [ i ] ) ;
69226: LD_ADDR_VAR 0 7
69230: PUSH
69231: LD_INT 1
69233: PPUSH
69234: LD_EXP 74
69238: PUSH
69239: LD_VAR 0 2
69243: ARRAY
69244: PPUSH
69245: CALL_OW 12
69249: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69250: LD_EXP 75
69254: PUSH
69255: LD_VAR 0 2
69259: ARRAY
69260: PUSH
69261: LD_VAR 0 3
69265: ARRAY
69266: PPUSH
69267: LD_EXP 74
69271: PUSH
69272: LD_VAR 0 2
69276: ARRAY
69277: PUSH
69278: LD_VAR 0 7
69282: ARRAY
69283: PUSH
69284: LD_INT 1
69286: ARRAY
69287: PPUSH
69288: LD_EXP 74
69292: PUSH
69293: LD_VAR 0 2
69297: ARRAY
69298: PUSH
69299: LD_VAR 0 7
69303: ARRAY
69304: PUSH
69305: LD_INT 2
69307: ARRAY
69308: PPUSH
69309: LD_INT 0
69311: PPUSH
69312: CALL_OW 193
// end ; end ; end ;
69316: GO 68969
69318: POP
69319: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69320: LD_ADDR_VAR 0 5
69324: PUSH
69325: LD_EXP 61
69329: PUSH
69330: LD_VAR 0 2
69334: ARRAY
69335: PPUSH
69336: LD_INT 2
69338: PUSH
69339: LD_INT 30
69341: PUSH
69342: LD_INT 4
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 30
69351: PUSH
69352: LD_INT 5
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 30
69361: PUSH
69362: LD_INT 32
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: LIST
69373: LIST
69374: PPUSH
69375: CALL_OW 72
69379: ST_TO_ADDR
// if not tmp then
69380: LD_VAR 0 5
69384: NOT
69385: IFFALSE 69389
// continue ;
69387: GO 68882
// list := [ ] ;
69389: LD_ADDR_VAR 0 6
69393: PUSH
69394: EMPTY
69395: ST_TO_ADDR
// for j in tmp do
69396: LD_ADDR_VAR 0 3
69400: PUSH
69401: LD_VAR 0 5
69405: PUSH
69406: FOR_IN
69407: IFFALSE 69476
// begin for k in UnitsInside ( j ) do
69409: LD_ADDR_VAR 0 4
69413: PUSH
69414: LD_VAR 0 3
69418: PPUSH
69419: CALL_OW 313
69423: PUSH
69424: FOR_IN
69425: IFFALSE 69472
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69427: LD_VAR 0 4
69431: PPUSH
69432: CALL_OW 257
69436: PUSH
69437: LD_INT 1
69439: EQUAL
69440: PUSH
69441: LD_VAR 0 4
69445: PPUSH
69446: CALL_OW 459
69450: NOT
69451: AND
69452: IFFALSE 69470
// list := list ^ k ;
69454: LD_ADDR_VAR 0 6
69458: PUSH
69459: LD_VAR 0 6
69463: PUSH
69464: LD_VAR 0 4
69468: ADD
69469: ST_TO_ADDR
69470: GO 69424
69472: POP
69473: POP
// end ;
69474: GO 69406
69476: POP
69477: POP
// list := list diff mc_miners [ i ] ;
69478: LD_ADDR_VAR 0 6
69482: PUSH
69483: LD_VAR 0 6
69487: PUSH
69488: LD_EXP 75
69492: PUSH
69493: LD_VAR 0 2
69497: ARRAY
69498: DIFF
69499: ST_TO_ADDR
// if not list then
69500: LD_VAR 0 6
69504: NOT
69505: IFFALSE 69509
// continue ;
69507: GO 68882
// k := mc_mines [ i ] - mc_miners [ i ] ;
69509: LD_ADDR_VAR 0 4
69513: PUSH
69514: LD_EXP 74
69518: PUSH
69519: LD_VAR 0 2
69523: ARRAY
69524: PUSH
69525: LD_EXP 75
69529: PUSH
69530: LD_VAR 0 2
69534: ARRAY
69535: MINUS
69536: ST_TO_ADDR
// if k > list then
69537: LD_VAR 0 4
69541: PUSH
69542: LD_VAR 0 6
69546: GREATER
69547: IFFALSE 69559
// k := list ;
69549: LD_ADDR_VAR 0 4
69553: PUSH
69554: LD_VAR 0 6
69558: ST_TO_ADDR
// for j = 1 to k do
69559: LD_ADDR_VAR 0 3
69563: PUSH
69564: DOUBLE
69565: LD_INT 1
69567: DEC
69568: ST_TO_ADDR
69569: LD_VAR 0 4
69573: PUSH
69574: FOR_TO
69575: IFFALSE 69629
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69577: LD_ADDR_EXP 75
69581: PUSH
69582: LD_EXP 75
69586: PPUSH
69587: LD_VAR 0 2
69591: PUSH
69592: LD_EXP 75
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_INT 1
69605: PLUS
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PPUSH
69611: LD_VAR 0 6
69615: PUSH
69616: LD_VAR 0 3
69620: ARRAY
69621: PPUSH
69622: CALL 20070 0 3
69626: ST_TO_ADDR
69627: GO 69574
69629: POP
69630: POP
// end ;
69631: GO 68882
69633: POP
69634: POP
// end ;
69635: LD_VAR 0 1
69639: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69640: LD_INT 0
69642: PPUSH
69643: PPUSH
69644: PPUSH
69645: PPUSH
69646: PPUSH
69647: PPUSH
69648: PPUSH
69649: PPUSH
69650: PPUSH
69651: PPUSH
69652: PPUSH
// if not mc_bases then
69653: LD_EXP 61
69657: NOT
69658: IFFALSE 69662
// exit ;
69660: GO 71485
// for i = 1 to mc_bases do
69662: LD_ADDR_VAR 0 2
69666: PUSH
69667: DOUBLE
69668: LD_INT 1
69670: DEC
69671: ST_TO_ADDR
69672: LD_EXP 61
69676: PUSH
69677: FOR_TO
69678: IFFALSE 71483
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69680: LD_EXP 61
69684: PUSH
69685: LD_VAR 0 2
69689: ARRAY
69690: NOT
69691: PUSH
69692: LD_EXP 68
69696: PUSH
69697: LD_VAR 0 2
69701: ARRAY
69702: OR
69703: IFFALSE 69707
// continue ;
69705: GO 69677
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69707: LD_EXP 77
69711: PUSH
69712: LD_VAR 0 2
69716: ARRAY
69717: NOT
69718: PUSH
69719: LD_EXP 78
69723: PUSH
69724: LD_VAR 0 2
69728: ARRAY
69729: AND
69730: IFFALSE 69768
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69732: LD_ADDR_EXP 78
69736: PUSH
69737: LD_EXP 78
69741: PPUSH
69742: LD_VAR 0 2
69746: PPUSH
69747: EMPTY
69748: PPUSH
69749: CALL_OW 1
69753: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69754: LD_VAR 0 2
69758: PPUSH
69759: LD_INT 107
69761: PPUSH
69762: CALL 60515 0 2
// continue ;
69766: GO 69677
// end ; target := [ ] ;
69768: LD_ADDR_VAR 0 7
69772: PUSH
69773: EMPTY
69774: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69775: LD_ADDR_VAR 0 6
69779: PUSH
69780: LD_EXP 61
69784: PUSH
69785: LD_VAR 0 2
69789: ARRAY
69790: PUSH
69791: LD_INT 1
69793: ARRAY
69794: PPUSH
69795: CALL_OW 255
69799: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69800: LD_ADDR_VAR 0 9
69804: PUSH
69805: LD_EXP 61
69809: PUSH
69810: LD_VAR 0 2
69814: ARRAY
69815: PPUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 30
69821: PUSH
69822: LD_INT 0
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 30
69831: PUSH
69832: LD_INT 1
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: LIST
69843: PPUSH
69844: CALL_OW 72
69848: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69849: LD_ADDR_VAR 0 3
69853: PUSH
69854: DOUBLE
69855: LD_EXP 77
69859: PUSH
69860: LD_VAR 0 2
69864: ARRAY
69865: INC
69866: ST_TO_ADDR
69867: LD_INT 1
69869: PUSH
69870: FOR_DOWNTO
69871: IFFALSE 70116
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69873: LD_EXP 77
69877: PUSH
69878: LD_VAR 0 2
69882: ARRAY
69883: PUSH
69884: LD_VAR 0 3
69888: ARRAY
69889: PUSH
69890: LD_INT 2
69892: ARRAY
69893: PPUSH
69894: LD_EXP 77
69898: PUSH
69899: LD_VAR 0 2
69903: ARRAY
69904: PUSH
69905: LD_VAR 0 3
69909: ARRAY
69910: PUSH
69911: LD_INT 3
69913: ARRAY
69914: PPUSH
69915: CALL_OW 488
69919: PUSH
69920: LD_EXP 77
69924: PUSH
69925: LD_VAR 0 2
69929: ARRAY
69930: PUSH
69931: LD_VAR 0 3
69935: ARRAY
69936: PUSH
69937: LD_INT 2
69939: ARRAY
69940: PPUSH
69941: LD_EXP 77
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_VAR 0 3
69956: ARRAY
69957: PUSH
69958: LD_INT 3
69960: ARRAY
69961: PPUSH
69962: CALL_OW 284
69966: PUSH
69967: LD_INT 0
69969: EQUAL
69970: AND
69971: IFFALSE 70026
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69973: LD_ADDR_VAR 0 5
69977: PUSH
69978: LD_EXP 77
69982: PUSH
69983: LD_VAR 0 2
69987: ARRAY
69988: PPUSH
69989: LD_VAR 0 3
69993: PPUSH
69994: CALL_OW 3
69998: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69999: LD_ADDR_EXP 77
70003: PUSH
70004: LD_EXP 77
70008: PPUSH
70009: LD_VAR 0 2
70013: PPUSH
70014: LD_VAR 0 5
70018: PPUSH
70019: CALL_OW 1
70023: ST_TO_ADDR
// continue ;
70024: GO 69870
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70026: LD_VAR 0 6
70030: PPUSH
70031: LD_EXP 77
70035: PUSH
70036: LD_VAR 0 2
70040: ARRAY
70041: PUSH
70042: LD_VAR 0 3
70046: ARRAY
70047: PUSH
70048: LD_INT 2
70050: ARRAY
70051: PPUSH
70052: LD_EXP 77
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: PUSH
70063: LD_VAR 0 3
70067: ARRAY
70068: PUSH
70069: LD_INT 3
70071: ARRAY
70072: PPUSH
70073: LD_INT 30
70075: PPUSH
70076: CALL 20966 0 4
70080: PUSH
70081: LD_INT 4
70083: ARRAY
70084: PUSH
70085: LD_INT 0
70087: EQUAL
70088: IFFALSE 70114
// begin target := mc_crates [ i ] [ j ] ;
70090: LD_ADDR_VAR 0 7
70094: PUSH
70095: LD_EXP 77
70099: PUSH
70100: LD_VAR 0 2
70104: ARRAY
70105: PUSH
70106: LD_VAR 0 3
70110: ARRAY
70111: ST_TO_ADDR
// break ;
70112: GO 70116
// end ; end ;
70114: GO 69870
70116: POP
70117: POP
// if not target then
70118: LD_VAR 0 7
70122: NOT
70123: IFFALSE 70127
// continue ;
70125: GO 69677
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70127: LD_ADDR_VAR 0 8
70131: PUSH
70132: LD_EXP 80
70136: PUSH
70137: LD_VAR 0 2
70141: ARRAY
70142: PPUSH
70143: LD_INT 2
70145: PUSH
70146: LD_INT 3
70148: PUSH
70149: LD_INT 58
70151: PUSH
70152: EMPTY
70153: LIST
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 61
70161: PUSH
70162: EMPTY
70163: LIST
70164: PUSH
70165: LD_INT 33
70167: PUSH
70168: LD_INT 5
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 33
70177: PUSH
70178: LD_INT 3
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: PUSH
70192: LD_INT 2
70194: PUSH
70195: LD_INT 34
70197: PUSH
70198: LD_INT 32
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 34
70207: PUSH
70208: LD_INT 51
70210: PUSH
70211: EMPTY
70212: LIST
70213: LIST
70214: PUSH
70215: LD_INT 34
70217: PUSH
70218: LD_INT 12
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PPUSH
70235: CALL_OW 72
70239: ST_TO_ADDR
// if not cargo then
70240: LD_VAR 0 8
70244: NOT
70245: IFFALSE 70951
// begin if mc_crates_collector [ i ] < 5 then
70247: LD_EXP 78
70251: PUSH
70252: LD_VAR 0 2
70256: ARRAY
70257: PUSH
70258: LD_INT 5
70260: LESS
70261: IFFALSE 70627
// begin if mc_ape [ i ] then
70263: LD_EXP 90
70267: PUSH
70268: LD_VAR 0 2
70272: ARRAY
70273: IFFALSE 70320
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70275: LD_ADDR_VAR 0 5
70279: PUSH
70280: LD_EXP 90
70284: PUSH
70285: LD_VAR 0 2
70289: ARRAY
70290: PPUSH
70291: LD_INT 25
70293: PUSH
70294: LD_INT 16
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 24
70303: PUSH
70304: LD_INT 750
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PPUSH
70315: CALL_OW 72
70319: ST_TO_ADDR
// if not tmp then
70320: LD_VAR 0 5
70324: NOT
70325: IFFALSE 70372
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70327: LD_ADDR_VAR 0 5
70331: PUSH
70332: LD_EXP 61
70336: PUSH
70337: LD_VAR 0 2
70341: ARRAY
70342: PPUSH
70343: LD_INT 25
70345: PUSH
70346: LD_INT 2
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 24
70355: PUSH
70356: LD_INT 750
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PPUSH
70367: CALL_OW 72
70371: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70372: LD_EXP 90
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: PUSH
70383: LD_EXP 61
70387: PUSH
70388: LD_VAR 0 2
70392: ARRAY
70393: PPUSH
70394: LD_INT 25
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 24
70406: PUSH
70407: LD_INT 750
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PPUSH
70418: CALL_OW 72
70422: AND
70423: PUSH
70424: LD_VAR 0 5
70428: PUSH
70429: LD_INT 5
70431: LESS
70432: AND
70433: IFFALSE 70515
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70435: LD_ADDR_VAR 0 3
70439: PUSH
70440: LD_EXP 61
70444: PUSH
70445: LD_VAR 0 2
70449: ARRAY
70450: PPUSH
70451: LD_INT 25
70453: PUSH
70454: LD_INT 2
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 24
70463: PUSH
70464: LD_INT 750
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PPUSH
70475: CALL_OW 72
70479: PUSH
70480: FOR_IN
70481: IFFALSE 70513
// begin tmp := tmp union j ;
70483: LD_ADDR_VAR 0 5
70487: PUSH
70488: LD_VAR 0 5
70492: PUSH
70493: LD_VAR 0 3
70497: UNION
70498: ST_TO_ADDR
// if tmp >= 5 then
70499: LD_VAR 0 5
70503: PUSH
70504: LD_INT 5
70506: GREATEREQUAL
70507: IFFALSE 70511
// break ;
70509: GO 70513
// end ;
70511: GO 70480
70513: POP
70514: POP
// end ; if not tmp then
70515: LD_VAR 0 5
70519: NOT
70520: IFFALSE 70524
// continue ;
70522: GO 69677
// for j in tmp do
70524: LD_ADDR_VAR 0 3
70528: PUSH
70529: LD_VAR 0 5
70533: PUSH
70534: FOR_IN
70535: IFFALSE 70625
// if not GetTag ( j ) then
70537: LD_VAR 0 3
70541: PPUSH
70542: CALL_OW 110
70546: NOT
70547: IFFALSE 70623
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70549: LD_ADDR_EXP 78
70553: PUSH
70554: LD_EXP 78
70558: PPUSH
70559: LD_VAR 0 2
70563: PUSH
70564: LD_EXP 78
70568: PUSH
70569: LD_VAR 0 2
70573: ARRAY
70574: PUSH
70575: LD_INT 1
70577: PLUS
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: PPUSH
70583: LD_VAR 0 3
70587: PPUSH
70588: CALL 20070 0 3
70592: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70593: LD_VAR 0 3
70597: PPUSH
70598: LD_INT 107
70600: PPUSH
70601: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70605: LD_EXP 78
70609: PUSH
70610: LD_VAR 0 2
70614: ARRAY
70615: PUSH
70616: LD_INT 5
70618: GREATEREQUAL
70619: IFFALSE 70623
// break ;
70621: GO 70625
// end ;
70623: GO 70534
70625: POP
70626: POP
// end ; if mc_crates_collector [ i ] and target then
70627: LD_EXP 78
70631: PUSH
70632: LD_VAR 0 2
70636: ARRAY
70637: PUSH
70638: LD_VAR 0 7
70642: AND
70643: IFFALSE 70949
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70645: LD_EXP 78
70649: PUSH
70650: LD_VAR 0 2
70654: ARRAY
70655: PUSH
70656: LD_VAR 0 7
70660: PUSH
70661: LD_INT 1
70663: ARRAY
70664: LESS
70665: IFFALSE 70685
// tmp := mc_crates_collector [ i ] else
70667: LD_ADDR_VAR 0 5
70671: PUSH
70672: LD_EXP 78
70676: PUSH
70677: LD_VAR 0 2
70681: ARRAY
70682: ST_TO_ADDR
70683: GO 70699
// tmp := target [ 1 ] ;
70685: LD_ADDR_VAR 0 5
70689: PUSH
70690: LD_VAR 0 7
70694: PUSH
70695: LD_INT 1
70697: ARRAY
70698: ST_TO_ADDR
// k := 0 ;
70699: LD_ADDR_VAR 0 4
70703: PUSH
70704: LD_INT 0
70706: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70707: LD_ADDR_VAR 0 3
70711: PUSH
70712: LD_EXP 78
70716: PUSH
70717: LD_VAR 0 2
70721: ARRAY
70722: PUSH
70723: FOR_IN
70724: IFFALSE 70947
// begin k := k + 1 ;
70726: LD_ADDR_VAR 0 4
70730: PUSH
70731: LD_VAR 0 4
70735: PUSH
70736: LD_INT 1
70738: PLUS
70739: ST_TO_ADDR
// if k > tmp then
70740: LD_VAR 0 4
70744: PUSH
70745: LD_VAR 0 5
70749: GREATER
70750: IFFALSE 70754
// break ;
70752: GO 70947
// if not GetClass ( j ) in [ 2 , 16 ] then
70754: LD_VAR 0 3
70758: PPUSH
70759: CALL_OW 257
70763: PUSH
70764: LD_INT 2
70766: PUSH
70767: LD_INT 16
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: IN
70774: NOT
70775: IFFALSE 70828
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70777: LD_ADDR_EXP 78
70781: PUSH
70782: LD_EXP 78
70786: PPUSH
70787: LD_VAR 0 2
70791: PPUSH
70792: LD_EXP 78
70796: PUSH
70797: LD_VAR 0 2
70801: ARRAY
70802: PUSH
70803: LD_VAR 0 3
70807: DIFF
70808: PPUSH
70809: CALL_OW 1
70813: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70814: LD_VAR 0 3
70818: PPUSH
70819: LD_INT 0
70821: PPUSH
70822: CALL_OW 109
// continue ;
70826: GO 70723
// end ; if IsInUnit ( j ) then
70828: LD_VAR 0 3
70832: PPUSH
70833: CALL_OW 310
70837: IFFALSE 70848
// ComExitBuilding ( j ) ;
70839: LD_VAR 0 3
70843: PPUSH
70844: CALL_OW 122
// wait ( 3 ) ;
70848: LD_INT 3
70850: PPUSH
70851: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70855: LD_VAR 0 3
70859: PPUSH
70860: CALL_OW 314
70864: PUSH
70865: LD_VAR 0 6
70869: PPUSH
70870: LD_VAR 0 7
70874: PUSH
70875: LD_INT 2
70877: ARRAY
70878: PPUSH
70879: LD_VAR 0 7
70883: PUSH
70884: LD_INT 3
70886: ARRAY
70887: PPUSH
70888: LD_INT 30
70890: PPUSH
70891: CALL 20966 0 4
70895: PUSH
70896: LD_INT 4
70898: ARRAY
70899: AND
70900: IFFALSE 70918
// ComStandNearbyBuilding ( j , depot ) else
70902: LD_VAR 0 3
70906: PPUSH
70907: LD_VAR 0 9
70911: PPUSH
70912: CALL 16497 0 2
70916: GO 70945
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70918: LD_VAR 0 3
70922: PPUSH
70923: LD_VAR 0 7
70927: PUSH
70928: LD_INT 2
70930: ARRAY
70931: PPUSH
70932: LD_VAR 0 7
70936: PUSH
70937: LD_INT 3
70939: ARRAY
70940: PPUSH
70941: CALL_OW 117
// end ;
70945: GO 70723
70947: POP
70948: POP
// end ; end else
70949: GO 71481
// begin for j in cargo do
70951: LD_ADDR_VAR 0 3
70955: PUSH
70956: LD_VAR 0 8
70960: PUSH
70961: FOR_IN
70962: IFFALSE 71479
// begin if GetTag ( j ) <> 0 then
70964: LD_VAR 0 3
70968: PPUSH
70969: CALL_OW 110
70973: PUSH
70974: LD_INT 0
70976: NONEQUAL
70977: IFFALSE 70981
// continue ;
70979: GO 70961
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70981: LD_VAR 0 3
70985: PPUSH
70986: CALL_OW 256
70990: PUSH
70991: LD_INT 1000
70993: LESS
70994: PUSH
70995: LD_VAR 0 3
70999: PPUSH
71000: LD_EXP 85
71004: PUSH
71005: LD_VAR 0 2
71009: ARRAY
71010: PPUSH
71011: CALL_OW 308
71015: NOT
71016: AND
71017: IFFALSE 71039
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71019: LD_VAR 0 3
71023: PPUSH
71024: LD_EXP 85
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: PPUSH
71035: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71039: LD_VAR 0 3
71043: PPUSH
71044: CALL_OW 256
71048: PUSH
71049: LD_INT 1000
71051: LESS
71052: PUSH
71053: LD_VAR 0 3
71057: PPUSH
71058: LD_EXP 85
71062: PUSH
71063: LD_VAR 0 2
71067: ARRAY
71068: PPUSH
71069: CALL_OW 308
71073: AND
71074: IFFALSE 71078
// continue ;
71076: GO 70961
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71078: LD_VAR 0 3
71082: PPUSH
71083: CALL_OW 262
71087: PUSH
71088: LD_INT 2
71090: EQUAL
71091: PUSH
71092: LD_VAR 0 3
71096: PPUSH
71097: CALL_OW 261
71101: PUSH
71102: LD_INT 15
71104: LESS
71105: AND
71106: IFFALSE 71110
// continue ;
71108: GO 70961
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71110: LD_VAR 0 3
71114: PPUSH
71115: CALL_OW 262
71119: PUSH
71120: LD_INT 1
71122: EQUAL
71123: PUSH
71124: LD_VAR 0 3
71128: PPUSH
71129: CALL_OW 261
71133: PUSH
71134: LD_INT 10
71136: LESS
71137: AND
71138: IFFALSE 71418
// begin if not depot then
71140: LD_VAR 0 9
71144: NOT
71145: IFFALSE 71149
// continue ;
71147: GO 70961
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71149: LD_VAR 0 3
71153: PPUSH
71154: LD_VAR 0 9
71158: PPUSH
71159: LD_VAR 0 3
71163: PPUSH
71164: CALL_OW 74
71168: PPUSH
71169: CALL_OW 296
71173: PUSH
71174: LD_INT 6
71176: LESS
71177: IFFALSE 71193
// SetFuel ( j , 100 ) else
71179: LD_VAR 0 3
71183: PPUSH
71184: LD_INT 100
71186: PPUSH
71187: CALL_OW 240
71191: GO 71418
// if GetFuel ( j ) = 0 then
71193: LD_VAR 0 3
71197: PPUSH
71198: CALL_OW 261
71202: PUSH
71203: LD_INT 0
71205: EQUAL
71206: IFFALSE 71418
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71208: LD_ADDR_EXP 80
71212: PUSH
71213: LD_EXP 80
71217: PPUSH
71218: LD_VAR 0 2
71222: PPUSH
71223: LD_EXP 80
71227: PUSH
71228: LD_VAR 0 2
71232: ARRAY
71233: PUSH
71234: LD_VAR 0 3
71238: DIFF
71239: PPUSH
71240: CALL_OW 1
71244: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71245: LD_VAR 0 3
71249: PPUSH
71250: CALL_OW 263
71254: PUSH
71255: LD_INT 1
71257: EQUAL
71258: IFFALSE 71274
// ComExitVehicle ( IsInUnit ( j ) ) ;
71260: LD_VAR 0 3
71264: PPUSH
71265: CALL_OW 310
71269: PPUSH
71270: CALL_OW 121
// if GetControl ( j ) = control_remote then
71274: LD_VAR 0 3
71278: PPUSH
71279: CALL_OW 263
71283: PUSH
71284: LD_INT 2
71286: EQUAL
71287: IFFALSE 71298
// ComUnlink ( j ) ;
71289: LD_VAR 0 3
71293: PPUSH
71294: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71298: LD_ADDR_VAR 0 10
71302: PUSH
71303: LD_VAR 0 2
71307: PPUSH
71308: LD_INT 3
71310: PPUSH
71311: CALL 81085 0 2
71315: ST_TO_ADDR
// if fac then
71316: LD_VAR 0 10
71320: IFFALSE 71416
// begin for k in fac do
71322: LD_ADDR_VAR 0 4
71326: PUSH
71327: LD_VAR 0 10
71331: PUSH
71332: FOR_IN
71333: IFFALSE 71414
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71335: LD_ADDR_VAR 0 11
71339: PUSH
71340: LD_VAR 0 10
71344: PPUSH
71345: LD_VAR 0 3
71349: PPUSH
71350: CALL_OW 265
71354: PPUSH
71355: LD_VAR 0 3
71359: PPUSH
71360: CALL_OW 262
71364: PPUSH
71365: LD_VAR 0 3
71369: PPUSH
71370: CALL_OW 263
71374: PPUSH
71375: LD_VAR 0 3
71379: PPUSH
71380: CALL_OW 264
71384: PPUSH
71385: CALL 17568 0 5
71389: ST_TO_ADDR
// if components then
71390: LD_VAR 0 11
71394: IFFALSE 71412
// begin MC_InsertProduceList ( i , components ) ;
71396: LD_VAR 0 2
71400: PPUSH
71401: LD_VAR 0 11
71405: PPUSH
71406: CALL 80630 0 2
// break ;
71410: GO 71414
// end ; end ;
71412: GO 71332
71414: POP
71415: POP
// end ; continue ;
71416: GO 70961
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71418: LD_VAR 0 3
71422: PPUSH
71423: LD_INT 1
71425: PPUSH
71426: CALL_OW 289
71430: PUSH
71431: LD_INT 100
71433: LESS
71434: PUSH
71435: LD_VAR 0 3
71439: PPUSH
71440: CALL_OW 314
71444: NOT
71445: AND
71446: IFFALSE 71475
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71448: LD_VAR 0 3
71452: PPUSH
71453: LD_VAR 0 7
71457: PUSH
71458: LD_INT 2
71460: ARRAY
71461: PPUSH
71462: LD_VAR 0 7
71466: PUSH
71467: LD_INT 3
71469: ARRAY
71470: PPUSH
71471: CALL_OW 117
// break ;
71475: GO 71479
// end ;
71477: GO 70961
71479: POP
71480: POP
// end ; end ;
71481: GO 69677
71483: POP
71484: POP
// end ;
71485: LD_VAR 0 1
71489: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71490: LD_INT 0
71492: PPUSH
71493: PPUSH
71494: PPUSH
71495: PPUSH
// if not mc_bases then
71496: LD_EXP 61
71500: NOT
71501: IFFALSE 71505
// exit ;
71503: GO 71666
// for i = 1 to mc_bases do
71505: LD_ADDR_VAR 0 2
71509: PUSH
71510: DOUBLE
71511: LD_INT 1
71513: DEC
71514: ST_TO_ADDR
71515: LD_EXP 61
71519: PUSH
71520: FOR_TO
71521: IFFALSE 71664
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71523: LD_ADDR_VAR 0 4
71527: PUSH
71528: LD_EXP 80
71532: PUSH
71533: LD_VAR 0 2
71537: ARRAY
71538: PUSH
71539: LD_EXP 83
71543: PUSH
71544: LD_VAR 0 2
71548: ARRAY
71549: UNION
71550: PPUSH
71551: LD_INT 33
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PPUSH
71561: CALL_OW 72
71565: ST_TO_ADDR
// if tmp then
71566: LD_VAR 0 4
71570: IFFALSE 71662
// for j in tmp do
71572: LD_ADDR_VAR 0 3
71576: PUSH
71577: LD_VAR 0 4
71581: PUSH
71582: FOR_IN
71583: IFFALSE 71660
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71585: LD_VAR 0 3
71589: PPUSH
71590: CALL_OW 312
71594: NOT
71595: PUSH
71596: LD_VAR 0 3
71600: PPUSH
71601: CALL_OW 256
71605: PUSH
71606: LD_INT 250
71608: GREATEREQUAL
71609: AND
71610: IFFALSE 71623
// Connect ( j ) else
71612: LD_VAR 0 3
71616: PPUSH
71617: CALL 23039 0 1
71621: GO 71658
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71623: LD_VAR 0 3
71627: PPUSH
71628: CALL_OW 256
71632: PUSH
71633: LD_INT 250
71635: LESS
71636: PUSH
71637: LD_VAR 0 3
71641: PPUSH
71642: CALL_OW 312
71646: AND
71647: IFFALSE 71658
// ComUnlink ( j ) ;
71649: LD_VAR 0 3
71653: PPUSH
71654: CALL_OW 136
71658: GO 71582
71660: POP
71661: POP
// end ;
71662: GO 71520
71664: POP
71665: POP
// end ;
71666: LD_VAR 0 1
71670: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71671: LD_INT 0
71673: PPUSH
71674: PPUSH
71675: PPUSH
71676: PPUSH
71677: PPUSH
// if not mc_bases then
71678: LD_EXP 61
71682: NOT
71683: IFFALSE 71687
// exit ;
71685: GO 72132
// for i = 1 to mc_bases do
71687: LD_ADDR_VAR 0 2
71691: PUSH
71692: DOUBLE
71693: LD_INT 1
71695: DEC
71696: ST_TO_ADDR
71697: LD_EXP 61
71701: PUSH
71702: FOR_TO
71703: IFFALSE 72130
// begin if not mc_produce [ i ] then
71705: LD_EXP 82
71709: PUSH
71710: LD_VAR 0 2
71714: ARRAY
71715: NOT
71716: IFFALSE 71720
// continue ;
71718: GO 71702
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71720: LD_ADDR_VAR 0 5
71724: PUSH
71725: LD_EXP 61
71729: PUSH
71730: LD_VAR 0 2
71734: ARRAY
71735: PPUSH
71736: LD_INT 30
71738: PUSH
71739: LD_INT 3
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PPUSH
71746: CALL_OW 72
71750: ST_TO_ADDR
// if not fac then
71751: LD_VAR 0 5
71755: NOT
71756: IFFALSE 71760
// continue ;
71758: GO 71702
// for j in fac do
71760: LD_ADDR_VAR 0 3
71764: PUSH
71765: LD_VAR 0 5
71769: PUSH
71770: FOR_IN
71771: IFFALSE 72126
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71773: LD_VAR 0 3
71777: PPUSH
71778: CALL_OW 461
71782: PUSH
71783: LD_INT 2
71785: NONEQUAL
71786: PUSH
71787: LD_VAR 0 3
71791: PPUSH
71792: LD_INT 15
71794: PPUSH
71795: CALL 22667 0 2
71799: PUSH
71800: LD_INT 4
71802: ARRAY
71803: OR
71804: IFFALSE 71808
// continue ;
71806: GO 71770
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71808: LD_VAR 0 3
71812: PPUSH
71813: LD_EXP 82
71817: PUSH
71818: LD_VAR 0 2
71822: ARRAY
71823: PUSH
71824: LD_INT 1
71826: ARRAY
71827: PUSH
71828: LD_INT 1
71830: ARRAY
71831: PPUSH
71832: LD_EXP 82
71836: PUSH
71837: LD_VAR 0 2
71841: ARRAY
71842: PUSH
71843: LD_INT 1
71845: ARRAY
71846: PUSH
71847: LD_INT 2
71849: ARRAY
71850: PPUSH
71851: LD_EXP 82
71855: PUSH
71856: LD_VAR 0 2
71860: ARRAY
71861: PUSH
71862: LD_INT 1
71864: ARRAY
71865: PUSH
71866: LD_INT 3
71868: ARRAY
71869: PPUSH
71870: LD_EXP 82
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PUSH
71881: LD_INT 1
71883: ARRAY
71884: PUSH
71885: LD_INT 4
71887: ARRAY
71888: PPUSH
71889: CALL_OW 448
71893: PUSH
71894: LD_VAR 0 3
71898: PPUSH
71899: LD_EXP 82
71903: PUSH
71904: LD_VAR 0 2
71908: ARRAY
71909: PUSH
71910: LD_INT 1
71912: ARRAY
71913: PUSH
71914: LD_INT 1
71916: ARRAY
71917: PUSH
71918: LD_EXP 82
71922: PUSH
71923: LD_VAR 0 2
71927: ARRAY
71928: PUSH
71929: LD_INT 1
71931: ARRAY
71932: PUSH
71933: LD_INT 2
71935: ARRAY
71936: PUSH
71937: LD_EXP 82
71941: PUSH
71942: LD_VAR 0 2
71946: ARRAY
71947: PUSH
71948: LD_INT 1
71950: ARRAY
71951: PUSH
71952: LD_INT 3
71954: ARRAY
71955: PUSH
71956: LD_EXP 82
71960: PUSH
71961: LD_VAR 0 2
71965: ARRAY
71966: PUSH
71967: LD_INT 1
71969: ARRAY
71970: PUSH
71971: LD_INT 4
71973: ARRAY
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: PPUSH
71981: CALL 26434 0 2
71985: AND
71986: IFFALSE 72124
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71988: LD_VAR 0 3
71992: PPUSH
71993: LD_EXP 82
71997: PUSH
71998: LD_VAR 0 2
72002: ARRAY
72003: PUSH
72004: LD_INT 1
72006: ARRAY
72007: PUSH
72008: LD_INT 1
72010: ARRAY
72011: PPUSH
72012: LD_EXP 82
72016: PUSH
72017: LD_VAR 0 2
72021: ARRAY
72022: PUSH
72023: LD_INT 1
72025: ARRAY
72026: PUSH
72027: LD_INT 2
72029: ARRAY
72030: PPUSH
72031: LD_EXP 82
72035: PUSH
72036: LD_VAR 0 2
72040: ARRAY
72041: PUSH
72042: LD_INT 1
72044: ARRAY
72045: PUSH
72046: LD_INT 3
72048: ARRAY
72049: PPUSH
72050: LD_EXP 82
72054: PUSH
72055: LD_VAR 0 2
72059: ARRAY
72060: PUSH
72061: LD_INT 1
72063: ARRAY
72064: PUSH
72065: LD_INT 4
72067: ARRAY
72068: PPUSH
72069: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72073: LD_ADDR_VAR 0 4
72077: PUSH
72078: LD_EXP 82
72082: PUSH
72083: LD_VAR 0 2
72087: ARRAY
72088: PPUSH
72089: LD_INT 1
72091: PPUSH
72092: CALL_OW 3
72096: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72097: LD_ADDR_EXP 82
72101: PUSH
72102: LD_EXP 82
72106: PPUSH
72107: LD_VAR 0 2
72111: PPUSH
72112: LD_VAR 0 4
72116: PPUSH
72117: CALL_OW 1
72121: ST_TO_ADDR
// break ;
72122: GO 72126
// end ; end ;
72124: GO 71770
72126: POP
72127: POP
// end ;
72128: GO 71702
72130: POP
72131: POP
// end ;
72132: LD_VAR 0 1
72136: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72137: LD_INT 0
72139: PPUSH
72140: PPUSH
72141: PPUSH
// if not mc_bases then
72142: LD_EXP 61
72146: NOT
72147: IFFALSE 72151
// exit ;
72149: GO 72240
// for i = 1 to mc_bases do
72151: LD_ADDR_VAR 0 2
72155: PUSH
72156: DOUBLE
72157: LD_INT 1
72159: DEC
72160: ST_TO_ADDR
72161: LD_EXP 61
72165: PUSH
72166: FOR_TO
72167: IFFALSE 72238
// begin if mc_attack [ i ] then
72169: LD_EXP 81
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: IFFALSE 72236
// begin tmp := mc_attack [ i ] [ 1 ] ;
72181: LD_ADDR_VAR 0 3
72185: PUSH
72186: LD_EXP 81
72190: PUSH
72191: LD_VAR 0 2
72195: ARRAY
72196: PUSH
72197: LD_INT 1
72199: ARRAY
72200: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72201: LD_ADDR_EXP 81
72205: PUSH
72206: LD_EXP 81
72210: PPUSH
72211: LD_VAR 0 2
72215: PPUSH
72216: EMPTY
72217: PPUSH
72218: CALL_OW 1
72222: ST_TO_ADDR
// Attack ( tmp ) ;
72223: LD_VAR 0 3
72227: PPUSH
72228: CALL 107106 0 1
// exit ;
72232: POP
72233: POP
72234: GO 72240
// end ; end ;
72236: GO 72166
72238: POP
72239: POP
// end ;
72240: LD_VAR 0 1
72244: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72245: LD_INT 0
72247: PPUSH
72248: PPUSH
72249: PPUSH
72250: PPUSH
72251: PPUSH
72252: PPUSH
72253: PPUSH
// if not mc_bases then
72254: LD_EXP 61
72258: NOT
72259: IFFALSE 72263
// exit ;
72261: GO 73120
// for i = 1 to mc_bases do
72263: LD_ADDR_VAR 0 2
72267: PUSH
72268: DOUBLE
72269: LD_INT 1
72271: DEC
72272: ST_TO_ADDR
72273: LD_EXP 61
72277: PUSH
72278: FOR_TO
72279: IFFALSE 73118
// begin if not mc_bases [ i ] then
72281: LD_EXP 61
72285: PUSH
72286: LD_VAR 0 2
72290: ARRAY
72291: NOT
72292: IFFALSE 72296
// continue ;
72294: GO 72278
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72296: LD_ADDR_VAR 0 7
72300: PUSH
72301: LD_EXP 61
72305: PUSH
72306: LD_VAR 0 2
72310: ARRAY
72311: PUSH
72312: LD_INT 1
72314: ARRAY
72315: PPUSH
72316: CALL 16719 0 1
72320: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72321: LD_ADDR_EXP 84
72325: PUSH
72326: LD_EXP 84
72330: PPUSH
72331: LD_VAR 0 2
72335: PPUSH
72336: LD_EXP 61
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: LD_INT 1
72349: ARRAY
72350: PPUSH
72351: CALL_OW 255
72355: PPUSH
72356: LD_EXP 86
72360: PUSH
72361: LD_VAR 0 2
72365: ARRAY
72366: PPUSH
72367: CALL 16684 0 2
72371: PPUSH
72372: CALL_OW 1
72376: ST_TO_ADDR
// if not mc_scan [ i ] then
72377: LD_EXP 84
72381: PUSH
72382: LD_VAR 0 2
72386: ARRAY
72387: NOT
72388: IFFALSE 72566
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72390: LD_ADDR_EXP 104
72394: PUSH
72395: LD_EXP 104
72399: PPUSH
72400: LD_VAR 0 2
72404: PPUSH
72405: LD_INT 0
72407: PPUSH
72408: CALL_OW 1
72412: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72413: LD_ADDR_VAR 0 4
72417: PUSH
72418: LD_EXP 61
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: PPUSH
72429: LD_INT 2
72431: PUSH
72432: LD_INT 25
72434: PUSH
72435: LD_INT 5
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 25
72444: PUSH
72445: LD_INT 8
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: LD_INT 25
72454: PUSH
72455: LD_INT 9
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: PPUSH
72468: CALL_OW 72
72472: ST_TO_ADDR
// if not tmp then
72473: LD_VAR 0 4
72477: NOT
72478: IFFALSE 72482
// continue ;
72480: GO 72278
// for j in tmp do
72482: LD_ADDR_VAR 0 3
72486: PUSH
72487: LD_VAR 0 4
72491: PUSH
72492: FOR_IN
72493: IFFALSE 72564
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72495: LD_VAR 0 3
72499: PPUSH
72500: CALL_OW 310
72504: PPUSH
72505: CALL_OW 266
72509: PUSH
72510: LD_INT 5
72512: EQUAL
72513: PUSH
72514: LD_VAR 0 3
72518: PPUSH
72519: CALL_OW 257
72523: PUSH
72524: LD_INT 1
72526: EQUAL
72527: AND
72528: PUSH
72529: LD_VAR 0 3
72533: PPUSH
72534: CALL_OW 459
72538: NOT
72539: AND
72540: PUSH
72541: LD_VAR 0 7
72545: AND
72546: IFFALSE 72562
// ComChangeProfession ( j , class ) ;
72548: LD_VAR 0 3
72552: PPUSH
72553: LD_VAR 0 7
72557: PPUSH
72558: CALL_OW 123
72562: GO 72492
72564: POP
72565: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72566: LD_EXP 84
72570: PUSH
72571: LD_VAR 0 2
72575: ARRAY
72576: PUSH
72577: LD_EXP 104
72581: PUSH
72582: LD_VAR 0 2
72586: ARRAY
72587: NOT
72588: AND
72589: PUSH
72590: LD_EXP 83
72594: PUSH
72595: LD_VAR 0 2
72599: ARRAY
72600: NOT
72601: AND
72602: PUSH
72603: LD_EXP 61
72607: PUSH
72608: LD_VAR 0 2
72612: ARRAY
72613: PPUSH
72614: LD_INT 50
72616: PUSH
72617: EMPTY
72618: LIST
72619: PUSH
72620: LD_INT 2
72622: PUSH
72623: LD_INT 30
72625: PUSH
72626: LD_INT 32
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 30
72635: PUSH
72636: LD_INT 33
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 30
72645: PUSH
72646: LD_INT 4
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 30
72655: PUSH
72656: LD_INT 5
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PPUSH
72674: CALL_OW 72
72678: PUSH
72679: LD_INT 4
72681: LESS
72682: PUSH
72683: LD_EXP 61
72687: PUSH
72688: LD_VAR 0 2
72692: ARRAY
72693: PPUSH
72694: LD_INT 3
72696: PUSH
72697: LD_INT 24
72699: PUSH
72700: LD_INT 1000
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 2
72713: PUSH
72714: LD_INT 30
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 30
72726: PUSH
72727: LD_INT 1
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: LIST
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PPUSH
72743: CALL_OW 72
72747: OR
72748: AND
72749: IFFALSE 73000
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72751: LD_ADDR_EXP 104
72755: PUSH
72756: LD_EXP 104
72760: PPUSH
72761: LD_VAR 0 2
72765: PPUSH
72766: LD_INT 1
72768: PPUSH
72769: CALL_OW 1
72773: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72774: LD_ADDR_VAR 0 4
72778: PUSH
72779: LD_EXP 61
72783: PUSH
72784: LD_VAR 0 2
72788: ARRAY
72789: PPUSH
72790: LD_INT 2
72792: PUSH
72793: LD_INT 25
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 25
72805: PUSH
72806: LD_INT 5
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 25
72815: PUSH
72816: LD_INT 8
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 25
72825: PUSH
72826: LD_INT 9
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: PPUSH
72840: CALL_OW 72
72844: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72845: LD_ADDR_VAR 0 4
72849: PUSH
72850: LD_VAR 0 4
72854: PUSH
72855: LD_VAR 0 4
72859: PPUSH
72860: LD_INT 18
72862: PPUSH
72863: CALL 49982 0 2
72867: DIFF
72868: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72869: LD_VAR 0 4
72873: NOT
72874: PUSH
72875: LD_EXP 61
72879: PUSH
72880: LD_VAR 0 2
72884: ARRAY
72885: PPUSH
72886: LD_INT 2
72888: PUSH
72889: LD_INT 30
72891: PUSH
72892: LD_INT 4
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 30
72901: PUSH
72902: LD_INT 5
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: LIST
72913: PPUSH
72914: CALL_OW 72
72918: NOT
72919: AND
72920: IFFALSE 72982
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72922: LD_ADDR_VAR 0 4
72926: PUSH
72927: LD_EXP 61
72931: PUSH
72932: LD_VAR 0 2
72936: ARRAY
72937: PPUSH
72938: LD_INT 2
72940: PUSH
72941: LD_INT 25
72943: PUSH
72944: LD_INT 2
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 25
72953: PUSH
72954: LD_INT 3
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 25
72963: PUSH
72964: LD_INT 4
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: PPUSH
72977: CALL_OW 72
72981: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72982: LD_VAR 0 2
72986: PPUSH
72987: LD_VAR 0 4
72991: PPUSH
72992: CALL 111815 0 2
// exit ;
72996: POP
72997: POP
72998: GO 73120
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
73000: LD_EXP 84
73004: PUSH
73005: LD_VAR 0 2
73009: ARRAY
73010: PUSH
73011: LD_EXP 104
73015: PUSH
73016: LD_VAR 0 2
73020: ARRAY
73021: NOT
73022: AND
73023: PUSH
73024: LD_EXP 83
73028: PUSH
73029: LD_VAR 0 2
73033: ARRAY
73034: AND
73035: IFFALSE 73116
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73037: LD_ADDR_EXP 104
73041: PUSH
73042: LD_EXP 104
73046: PPUSH
73047: LD_VAR 0 2
73051: PPUSH
73052: LD_INT 1
73054: PPUSH
73055: CALL_OW 1
73059: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73060: LD_ADDR_VAR 0 4
73064: PUSH
73065: LD_EXP 83
73069: PUSH
73070: LD_VAR 0 2
73074: ARRAY
73075: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73076: LD_ADDR_EXP 83
73080: PUSH
73081: LD_EXP 83
73085: PPUSH
73086: LD_VAR 0 2
73090: PPUSH
73091: EMPTY
73092: PPUSH
73093: CALL_OW 1
73097: ST_TO_ADDR
// Defend ( i , tmp ) ;
73098: LD_VAR 0 2
73102: PPUSH
73103: LD_VAR 0 4
73107: PPUSH
73108: CALL 112411 0 2
// exit ;
73112: POP
73113: POP
73114: GO 73120
// end ; end ;
73116: GO 72278
73118: POP
73119: POP
// end ;
73120: LD_VAR 0 1
73124: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73125: LD_INT 0
73127: PPUSH
73128: PPUSH
73129: PPUSH
73130: PPUSH
73131: PPUSH
73132: PPUSH
73133: PPUSH
73134: PPUSH
73135: PPUSH
73136: PPUSH
73137: PPUSH
// if not mc_bases then
73138: LD_EXP 61
73142: NOT
73143: IFFALSE 73147
// exit ;
73145: GO 74234
// for i = 1 to mc_bases do
73147: LD_ADDR_VAR 0 2
73151: PUSH
73152: DOUBLE
73153: LD_INT 1
73155: DEC
73156: ST_TO_ADDR
73157: LD_EXP 61
73161: PUSH
73162: FOR_TO
73163: IFFALSE 74232
// begin tmp := mc_lab [ i ] ;
73165: LD_ADDR_VAR 0 6
73169: PUSH
73170: LD_EXP 94
73174: PUSH
73175: LD_VAR 0 2
73179: ARRAY
73180: ST_TO_ADDR
// if not tmp then
73181: LD_VAR 0 6
73185: NOT
73186: IFFALSE 73190
// continue ;
73188: GO 73162
// idle_lab := 0 ;
73190: LD_ADDR_VAR 0 11
73194: PUSH
73195: LD_INT 0
73197: ST_TO_ADDR
// for j in tmp do
73198: LD_ADDR_VAR 0 3
73202: PUSH
73203: LD_VAR 0 6
73207: PUSH
73208: FOR_IN
73209: IFFALSE 74228
// begin researching := false ;
73211: LD_ADDR_VAR 0 10
73215: PUSH
73216: LD_INT 0
73218: ST_TO_ADDR
// side := GetSide ( j ) ;
73219: LD_ADDR_VAR 0 4
73223: PUSH
73224: LD_VAR 0 3
73228: PPUSH
73229: CALL_OW 255
73233: ST_TO_ADDR
// if not mc_tech [ side ] then
73234: LD_EXP 88
73238: PUSH
73239: LD_VAR 0 4
73243: ARRAY
73244: NOT
73245: IFFALSE 73249
// continue ;
73247: GO 73208
// if BuildingStatus ( j ) = bs_idle then
73249: LD_VAR 0 3
73253: PPUSH
73254: CALL_OW 461
73258: PUSH
73259: LD_INT 2
73261: EQUAL
73262: IFFALSE 73450
// begin if idle_lab and UnitsInside ( j ) < 6 then
73264: LD_VAR 0 11
73268: PUSH
73269: LD_VAR 0 3
73273: PPUSH
73274: CALL_OW 313
73278: PUSH
73279: LD_INT 6
73281: LESS
73282: AND
73283: IFFALSE 73354
// begin tmp2 := UnitsInside ( idle_lab ) ;
73285: LD_ADDR_VAR 0 9
73289: PUSH
73290: LD_VAR 0 11
73294: PPUSH
73295: CALL_OW 313
73299: ST_TO_ADDR
// if tmp2 then
73300: LD_VAR 0 9
73304: IFFALSE 73346
// for x in tmp2 do
73306: LD_ADDR_VAR 0 7
73310: PUSH
73311: LD_VAR 0 9
73315: PUSH
73316: FOR_IN
73317: IFFALSE 73344
// begin ComExitBuilding ( x ) ;
73319: LD_VAR 0 7
73323: PPUSH
73324: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73328: LD_VAR 0 7
73332: PPUSH
73333: LD_VAR 0 3
73337: PPUSH
73338: CALL_OW 180
// end ;
73342: GO 73316
73344: POP
73345: POP
// idle_lab := 0 ;
73346: LD_ADDR_VAR 0 11
73350: PUSH
73351: LD_INT 0
73353: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73354: LD_ADDR_VAR 0 5
73358: PUSH
73359: LD_EXP 88
73363: PUSH
73364: LD_VAR 0 4
73368: ARRAY
73369: PUSH
73370: FOR_IN
73371: IFFALSE 73431
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73373: LD_VAR 0 3
73377: PPUSH
73378: LD_VAR 0 5
73382: PPUSH
73383: CALL_OW 430
73387: PUSH
73388: LD_VAR 0 4
73392: PPUSH
73393: LD_VAR 0 5
73397: PPUSH
73398: CALL 15789 0 2
73402: AND
73403: IFFALSE 73429
// begin researching := true ;
73405: LD_ADDR_VAR 0 10
73409: PUSH
73410: LD_INT 1
73412: ST_TO_ADDR
// ComResearch ( j , t ) ;
73413: LD_VAR 0 3
73417: PPUSH
73418: LD_VAR 0 5
73422: PPUSH
73423: CALL_OW 124
// break ;
73427: GO 73431
// end ;
73429: GO 73370
73431: POP
73432: POP
// if not researching then
73433: LD_VAR 0 10
73437: NOT
73438: IFFALSE 73450
// idle_lab := j ;
73440: LD_ADDR_VAR 0 11
73444: PUSH
73445: LD_VAR 0 3
73449: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73450: LD_VAR 0 3
73454: PPUSH
73455: CALL_OW 461
73459: PUSH
73460: LD_INT 10
73462: EQUAL
73463: IFFALSE 74051
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73465: LD_EXP 90
73469: PUSH
73470: LD_VAR 0 2
73474: ARRAY
73475: NOT
73476: PUSH
73477: LD_EXP 91
73481: PUSH
73482: LD_VAR 0 2
73486: ARRAY
73487: NOT
73488: AND
73489: PUSH
73490: LD_EXP 88
73494: PUSH
73495: LD_VAR 0 4
73499: ARRAY
73500: PUSH
73501: LD_INT 1
73503: GREATER
73504: AND
73505: IFFALSE 73636
// begin ComCancel ( j ) ;
73507: LD_VAR 0 3
73511: PPUSH
73512: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73516: LD_ADDR_EXP 88
73520: PUSH
73521: LD_EXP 88
73525: PPUSH
73526: LD_VAR 0 4
73530: PPUSH
73531: LD_EXP 88
73535: PUSH
73536: LD_VAR 0 4
73540: ARRAY
73541: PPUSH
73542: LD_EXP 88
73546: PUSH
73547: LD_VAR 0 4
73551: ARRAY
73552: PUSH
73553: LD_INT 1
73555: MINUS
73556: PPUSH
73557: LD_EXP 88
73561: PUSH
73562: LD_VAR 0 4
73566: ARRAY
73567: PPUSH
73568: LD_INT 0
73570: PPUSH
73571: CALL 19488 0 4
73575: PPUSH
73576: CALL_OW 1
73580: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73581: LD_ADDR_EXP 88
73585: PUSH
73586: LD_EXP 88
73590: PPUSH
73591: LD_VAR 0 4
73595: PPUSH
73596: LD_EXP 88
73600: PUSH
73601: LD_VAR 0 4
73605: ARRAY
73606: PPUSH
73607: LD_EXP 88
73611: PUSH
73612: LD_VAR 0 4
73616: ARRAY
73617: PPUSH
73618: LD_INT 1
73620: PPUSH
73621: LD_INT 0
73623: PPUSH
73624: CALL 19488 0 4
73628: PPUSH
73629: CALL_OW 1
73633: ST_TO_ADDR
// continue ;
73634: GO 73208
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73636: LD_EXP 90
73640: PUSH
73641: LD_VAR 0 2
73645: ARRAY
73646: PUSH
73647: LD_EXP 91
73651: PUSH
73652: LD_VAR 0 2
73656: ARRAY
73657: NOT
73658: AND
73659: IFFALSE 73786
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73661: LD_ADDR_EXP 91
73665: PUSH
73666: LD_EXP 91
73670: PPUSH
73671: LD_VAR 0 2
73675: PUSH
73676: LD_EXP 91
73680: PUSH
73681: LD_VAR 0 2
73685: ARRAY
73686: PUSH
73687: LD_INT 1
73689: PLUS
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PPUSH
73695: LD_EXP 90
73699: PUSH
73700: LD_VAR 0 2
73704: ARRAY
73705: PUSH
73706: LD_INT 1
73708: ARRAY
73709: PPUSH
73710: CALL 20070 0 3
73714: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73715: LD_EXP 90
73719: PUSH
73720: LD_VAR 0 2
73724: ARRAY
73725: PUSH
73726: LD_INT 1
73728: ARRAY
73729: PPUSH
73730: LD_INT 112
73732: PPUSH
73733: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73737: LD_ADDR_VAR 0 9
73741: PUSH
73742: LD_EXP 90
73746: PUSH
73747: LD_VAR 0 2
73751: ARRAY
73752: PPUSH
73753: LD_INT 1
73755: PPUSH
73756: CALL_OW 3
73760: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73761: LD_ADDR_EXP 90
73765: PUSH
73766: LD_EXP 90
73770: PPUSH
73771: LD_VAR 0 2
73775: PPUSH
73776: LD_VAR 0 9
73780: PPUSH
73781: CALL_OW 1
73785: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73786: LD_EXP 90
73790: PUSH
73791: LD_VAR 0 2
73795: ARRAY
73796: PUSH
73797: LD_EXP 91
73801: PUSH
73802: LD_VAR 0 2
73806: ARRAY
73807: AND
73808: PUSH
73809: LD_EXP 91
73813: PUSH
73814: LD_VAR 0 2
73818: ARRAY
73819: PUSH
73820: LD_INT 1
73822: ARRAY
73823: PPUSH
73824: CALL_OW 310
73828: NOT
73829: AND
73830: PUSH
73831: LD_VAR 0 3
73835: PPUSH
73836: CALL_OW 313
73840: PUSH
73841: LD_INT 6
73843: EQUAL
73844: AND
73845: IFFALSE 73901
// begin tmp2 := UnitsInside ( j ) ;
73847: LD_ADDR_VAR 0 9
73851: PUSH
73852: LD_VAR 0 3
73856: PPUSH
73857: CALL_OW 313
73861: ST_TO_ADDR
// if tmp2 = 6 then
73862: LD_VAR 0 9
73866: PUSH
73867: LD_INT 6
73869: EQUAL
73870: IFFALSE 73901
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73872: LD_VAR 0 9
73876: PUSH
73877: LD_INT 1
73879: ARRAY
73880: PPUSH
73881: LD_INT 112
73883: PPUSH
73884: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73888: LD_VAR 0 9
73892: PUSH
73893: LD_INT 1
73895: ARRAY
73896: PPUSH
73897: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73901: LD_EXP 91
73905: PUSH
73906: LD_VAR 0 2
73910: ARRAY
73911: PUSH
73912: LD_EXP 91
73916: PUSH
73917: LD_VAR 0 2
73921: ARRAY
73922: PUSH
73923: LD_INT 1
73925: ARRAY
73926: PPUSH
73927: CALL_OW 314
73931: NOT
73932: AND
73933: PUSH
73934: LD_EXP 91
73938: PUSH
73939: LD_VAR 0 2
73943: ARRAY
73944: PUSH
73945: LD_INT 1
73947: ARRAY
73948: PPUSH
73949: CALL_OW 310
73953: NOT
73954: AND
73955: IFFALSE 73981
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73957: LD_EXP 91
73961: PUSH
73962: LD_VAR 0 2
73966: ARRAY
73967: PUSH
73968: LD_INT 1
73970: ARRAY
73971: PPUSH
73972: LD_VAR 0 3
73976: PPUSH
73977: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73981: LD_EXP 91
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: PUSH
73992: LD_INT 1
73994: ARRAY
73995: PPUSH
73996: CALL_OW 310
74000: PUSH
74001: LD_EXP 91
74005: PUSH
74006: LD_VAR 0 2
74010: ARRAY
74011: PUSH
74012: LD_INT 1
74014: ARRAY
74015: PPUSH
74016: CALL_OW 310
74020: PPUSH
74021: CALL_OW 461
74025: PUSH
74026: LD_INT 3
74028: NONEQUAL
74029: AND
74030: IFFALSE 74051
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74032: LD_EXP 91
74036: PUSH
74037: LD_VAR 0 2
74041: ARRAY
74042: PUSH
74043: LD_INT 1
74045: ARRAY
74046: PPUSH
74047: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74051: LD_VAR 0 3
74055: PPUSH
74056: CALL_OW 461
74060: PUSH
74061: LD_INT 6
74063: EQUAL
74064: PUSH
74065: LD_VAR 0 6
74069: PUSH
74070: LD_INT 1
74072: GREATER
74073: AND
74074: IFFALSE 74226
// begin sci := [ ] ;
74076: LD_ADDR_VAR 0 8
74080: PUSH
74081: EMPTY
74082: ST_TO_ADDR
// for x in ( tmp diff j ) do
74083: LD_ADDR_VAR 0 7
74087: PUSH
74088: LD_VAR 0 6
74092: PUSH
74093: LD_VAR 0 3
74097: DIFF
74098: PUSH
74099: FOR_IN
74100: IFFALSE 74152
// begin if sci = 6 then
74102: LD_VAR 0 8
74106: PUSH
74107: LD_INT 6
74109: EQUAL
74110: IFFALSE 74114
// break ;
74112: GO 74152
// if BuildingStatus ( x ) = bs_idle then
74114: LD_VAR 0 7
74118: PPUSH
74119: CALL_OW 461
74123: PUSH
74124: LD_INT 2
74126: EQUAL
74127: IFFALSE 74150
// sci := sci ^ UnitsInside ( x ) ;
74129: LD_ADDR_VAR 0 8
74133: PUSH
74134: LD_VAR 0 8
74138: PUSH
74139: LD_VAR 0 7
74143: PPUSH
74144: CALL_OW 313
74148: ADD
74149: ST_TO_ADDR
// end ;
74150: GO 74099
74152: POP
74153: POP
// if not sci then
74154: LD_VAR 0 8
74158: NOT
74159: IFFALSE 74163
// continue ;
74161: GO 73208
// for x in sci do
74163: LD_ADDR_VAR 0 7
74167: PUSH
74168: LD_VAR 0 8
74172: PUSH
74173: FOR_IN
74174: IFFALSE 74224
// if IsInUnit ( x ) and not HasTask ( x ) then
74176: LD_VAR 0 7
74180: PPUSH
74181: CALL_OW 310
74185: PUSH
74186: LD_VAR 0 7
74190: PPUSH
74191: CALL_OW 314
74195: NOT
74196: AND
74197: IFFALSE 74222
// begin ComExitBuilding ( x ) ;
74199: LD_VAR 0 7
74203: PPUSH
74204: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74208: LD_VAR 0 7
74212: PPUSH
74213: LD_VAR 0 3
74217: PPUSH
74218: CALL_OW 180
// end ;
74222: GO 74173
74224: POP
74225: POP
// end ; end ;
74226: GO 73208
74228: POP
74229: POP
// end ;
74230: GO 73162
74232: POP
74233: POP
// end ;
74234: LD_VAR 0 1
74238: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74239: LD_INT 0
74241: PPUSH
74242: PPUSH
// if not mc_bases then
74243: LD_EXP 61
74247: NOT
74248: IFFALSE 74252
// exit ;
74250: GO 74333
// for i = 1 to mc_bases do
74252: LD_ADDR_VAR 0 2
74256: PUSH
74257: DOUBLE
74258: LD_INT 1
74260: DEC
74261: ST_TO_ADDR
74262: LD_EXP 61
74266: PUSH
74267: FOR_TO
74268: IFFALSE 74331
// if mc_mines [ i ] and mc_miners [ i ] then
74270: LD_EXP 74
74274: PUSH
74275: LD_VAR 0 2
74279: ARRAY
74280: PUSH
74281: LD_EXP 75
74285: PUSH
74286: LD_VAR 0 2
74290: ARRAY
74291: AND
74292: IFFALSE 74329
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74294: LD_EXP 75
74298: PUSH
74299: LD_VAR 0 2
74303: ARRAY
74304: PUSH
74305: LD_INT 1
74307: ARRAY
74308: PPUSH
74309: CALL_OW 255
74313: PPUSH
74314: LD_EXP 74
74318: PUSH
74319: LD_VAR 0 2
74323: ARRAY
74324: PPUSH
74325: CALL 16872 0 2
74329: GO 74267
74331: POP
74332: POP
// end ;
74333: LD_VAR 0 1
74337: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74338: LD_INT 0
74340: PPUSH
74341: PPUSH
74342: PPUSH
74343: PPUSH
74344: PPUSH
74345: PPUSH
74346: PPUSH
74347: PPUSH
// if not mc_bases or not mc_parking then
74348: LD_EXP 61
74352: NOT
74353: PUSH
74354: LD_EXP 85
74358: NOT
74359: OR
74360: IFFALSE 74364
// exit ;
74362: GO 75102
// for i = 1 to mc_bases do
74364: LD_ADDR_VAR 0 2
74368: PUSH
74369: DOUBLE
74370: LD_INT 1
74372: DEC
74373: ST_TO_ADDR
74374: LD_EXP 61
74378: PUSH
74379: FOR_TO
74380: IFFALSE 75100
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74382: LD_EXP 61
74386: PUSH
74387: LD_VAR 0 2
74391: ARRAY
74392: NOT
74393: PUSH
74394: LD_EXP 85
74398: PUSH
74399: LD_VAR 0 2
74403: ARRAY
74404: NOT
74405: OR
74406: IFFALSE 74410
// continue ;
74408: GO 74379
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74410: LD_ADDR_VAR 0 5
74414: PUSH
74415: LD_EXP 61
74419: PUSH
74420: LD_VAR 0 2
74424: ARRAY
74425: PUSH
74426: LD_INT 1
74428: ARRAY
74429: PPUSH
74430: CALL_OW 255
74434: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74435: LD_ADDR_VAR 0 6
74439: PUSH
74440: LD_EXP 61
74444: PUSH
74445: LD_VAR 0 2
74449: ARRAY
74450: PPUSH
74451: LD_INT 30
74453: PUSH
74454: LD_INT 3
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PPUSH
74461: CALL_OW 72
74465: ST_TO_ADDR
// if not fac then
74466: LD_VAR 0 6
74470: NOT
74471: IFFALSE 74522
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74473: LD_ADDR_VAR 0 6
74477: PUSH
74478: LD_EXP 61
74482: PUSH
74483: LD_VAR 0 2
74487: ARRAY
74488: PPUSH
74489: LD_INT 2
74491: PUSH
74492: LD_INT 30
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 30
74504: PUSH
74505: LD_INT 1
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: LIST
74516: PPUSH
74517: CALL_OW 72
74521: ST_TO_ADDR
// if not fac then
74522: LD_VAR 0 6
74526: NOT
74527: IFFALSE 74531
// continue ;
74529: GO 74379
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74531: LD_ADDR_VAR 0 7
74535: PUSH
74536: LD_EXP 85
74540: PUSH
74541: LD_VAR 0 2
74545: ARRAY
74546: PPUSH
74547: LD_INT 22
74549: PUSH
74550: LD_VAR 0 5
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 21
74561: PUSH
74562: LD_INT 2
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 3
74571: PUSH
74572: LD_INT 60
74574: PUSH
74575: EMPTY
74576: LIST
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 3
74584: PUSH
74585: LD_INT 24
74587: PUSH
74588: LD_INT 1000
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: PPUSH
74605: CALL_OW 70
74609: ST_TO_ADDR
// for j in fac do
74610: LD_ADDR_VAR 0 3
74614: PUSH
74615: LD_VAR 0 6
74619: PUSH
74620: FOR_IN
74621: IFFALSE 74716
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74623: LD_ADDR_VAR 0 7
74627: PUSH
74628: LD_VAR 0 7
74632: PUSH
74633: LD_INT 22
74635: PUSH
74636: LD_VAR 0 5
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 91
74647: PUSH
74648: LD_VAR 0 3
74652: PUSH
74653: LD_INT 15
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 21
74663: PUSH
74664: LD_INT 2
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 3
74673: PUSH
74674: LD_INT 60
74676: PUSH
74677: EMPTY
74678: LIST
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 3
74686: PUSH
74687: LD_INT 24
74689: PUSH
74690: LD_INT 1000
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: LIST
74705: LIST
74706: LIST
74707: PPUSH
74708: CALL_OW 69
74712: UNION
74713: ST_TO_ADDR
74714: GO 74620
74716: POP
74717: POP
// if not vehs then
74718: LD_VAR 0 7
74722: NOT
74723: IFFALSE 74749
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74725: LD_ADDR_EXP 73
74729: PUSH
74730: LD_EXP 73
74734: PPUSH
74735: LD_VAR 0 2
74739: PPUSH
74740: EMPTY
74741: PPUSH
74742: CALL_OW 1
74746: ST_TO_ADDR
// continue ;
74747: GO 74379
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74749: LD_ADDR_VAR 0 8
74753: PUSH
74754: LD_EXP 61
74758: PUSH
74759: LD_VAR 0 2
74763: ARRAY
74764: PPUSH
74765: LD_INT 30
74767: PUSH
74768: LD_INT 3
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PPUSH
74775: CALL_OW 72
74779: ST_TO_ADDR
// if tmp then
74780: LD_VAR 0 8
74784: IFFALSE 74887
// begin for j in tmp do
74786: LD_ADDR_VAR 0 3
74790: PUSH
74791: LD_VAR 0 8
74795: PUSH
74796: FOR_IN
74797: IFFALSE 74885
// for k in UnitsInside ( j ) do
74799: LD_ADDR_VAR 0 4
74803: PUSH
74804: LD_VAR 0 3
74808: PPUSH
74809: CALL_OW 313
74813: PUSH
74814: FOR_IN
74815: IFFALSE 74881
// if k then
74817: LD_VAR 0 4
74821: IFFALSE 74879
// if not k in mc_repair_vehicle [ i ] then
74823: LD_VAR 0 4
74827: PUSH
74828: LD_EXP 73
74832: PUSH
74833: LD_VAR 0 2
74837: ARRAY
74838: IN
74839: NOT
74840: IFFALSE 74879
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74842: LD_ADDR_EXP 73
74846: PUSH
74847: LD_EXP 73
74851: PPUSH
74852: LD_VAR 0 2
74856: PPUSH
74857: LD_EXP 73
74861: PUSH
74862: LD_VAR 0 2
74866: ARRAY
74867: PUSH
74868: LD_VAR 0 4
74872: UNION
74873: PPUSH
74874: CALL_OW 1
74878: ST_TO_ADDR
74879: GO 74814
74881: POP
74882: POP
74883: GO 74796
74885: POP
74886: POP
// end ; if not mc_repair_vehicle [ i ] then
74887: LD_EXP 73
74891: PUSH
74892: LD_VAR 0 2
74896: ARRAY
74897: NOT
74898: IFFALSE 74902
// continue ;
74900: GO 74379
// for j in mc_repair_vehicle [ i ] do
74902: LD_ADDR_VAR 0 3
74906: PUSH
74907: LD_EXP 73
74911: PUSH
74912: LD_VAR 0 2
74916: ARRAY
74917: PUSH
74918: FOR_IN
74919: IFFALSE 75096
// begin if GetClass ( j ) <> 3 then
74921: LD_VAR 0 3
74925: PPUSH
74926: CALL_OW 257
74930: PUSH
74931: LD_INT 3
74933: NONEQUAL
74934: IFFALSE 74975
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74936: LD_ADDR_EXP 73
74940: PUSH
74941: LD_EXP 73
74945: PPUSH
74946: LD_VAR 0 2
74950: PPUSH
74951: LD_EXP 73
74955: PUSH
74956: LD_VAR 0 2
74960: ARRAY
74961: PUSH
74962: LD_VAR 0 3
74966: DIFF
74967: PPUSH
74968: CALL_OW 1
74972: ST_TO_ADDR
// continue ;
74973: GO 74918
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74975: LD_VAR 0 3
74979: PPUSH
74980: CALL_OW 311
74984: NOT
74985: PUSH
74986: LD_VAR 0 3
74990: PUSH
74991: LD_EXP 64
74995: PUSH
74996: LD_VAR 0 2
75000: ARRAY
75001: PUSH
75002: LD_INT 1
75004: ARRAY
75005: IN
75006: NOT
75007: AND
75008: PUSH
75009: LD_VAR 0 3
75013: PUSH
75014: LD_EXP 64
75018: PUSH
75019: LD_VAR 0 2
75023: ARRAY
75024: PUSH
75025: LD_INT 2
75027: ARRAY
75028: IN
75029: NOT
75030: AND
75031: IFFALSE 75094
// begin if IsInUnit ( j ) then
75033: LD_VAR 0 3
75037: PPUSH
75038: CALL_OW 310
75042: IFFALSE 75055
// ComExitBuilding ( j ) else
75044: LD_VAR 0 3
75048: PPUSH
75049: CALL_OW 122
75053: GO 75094
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75055: LD_VAR 0 3
75059: PPUSH
75060: LD_VAR 0 7
75064: PUSH
75065: LD_INT 1
75067: ARRAY
75068: PPUSH
75069: CALL 54466 0 2
75073: NOT
75074: IFFALSE 75094
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75076: LD_VAR 0 3
75080: PPUSH
75081: LD_VAR 0 7
75085: PUSH
75086: LD_INT 1
75088: ARRAY
75089: PPUSH
75090: CALL_OW 129
// end ; end ;
75094: GO 74918
75096: POP
75097: POP
// end ;
75098: GO 74379
75100: POP
75101: POP
// end ;
75102: LD_VAR 0 1
75106: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75107: LD_INT 0
75109: PPUSH
75110: PPUSH
75111: PPUSH
75112: PPUSH
75113: PPUSH
75114: PPUSH
75115: PPUSH
75116: PPUSH
75117: PPUSH
75118: PPUSH
75119: PPUSH
// if not mc_bases then
75120: LD_EXP 61
75124: NOT
75125: IFFALSE 75129
// exit ;
75127: GO 75931
// for i = 1 to mc_bases do
75129: LD_ADDR_VAR 0 2
75133: PUSH
75134: DOUBLE
75135: LD_INT 1
75137: DEC
75138: ST_TO_ADDR
75139: LD_EXP 61
75143: PUSH
75144: FOR_TO
75145: IFFALSE 75929
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75147: LD_EXP 89
75151: PUSH
75152: LD_VAR 0 2
75156: ARRAY
75157: NOT
75158: PUSH
75159: LD_EXP 64
75163: PUSH
75164: LD_VAR 0 2
75168: ARRAY
75169: PUSH
75170: LD_INT 1
75172: ARRAY
75173: OR
75174: PUSH
75175: LD_EXP 64
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: PUSH
75186: LD_INT 2
75188: ARRAY
75189: OR
75190: PUSH
75191: LD_EXP 87
75195: PUSH
75196: LD_VAR 0 2
75200: ARRAY
75201: PPUSH
75202: LD_INT 1
75204: PPUSH
75205: CALL_OW 325
75209: NOT
75210: OR
75211: PUSH
75212: LD_EXP 84
75216: PUSH
75217: LD_VAR 0 2
75221: ARRAY
75222: OR
75223: IFFALSE 75227
// continue ;
75225: GO 75144
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75227: LD_ADDR_VAR 0 8
75231: PUSH
75232: LD_EXP 61
75236: PUSH
75237: LD_VAR 0 2
75241: ARRAY
75242: PPUSH
75243: LD_INT 25
75245: PUSH
75246: LD_INT 4
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 50
75255: PUSH
75256: EMPTY
75257: LIST
75258: PUSH
75259: LD_INT 3
75261: PUSH
75262: LD_INT 60
75264: PUSH
75265: EMPTY
75266: LIST
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: LIST
75276: PPUSH
75277: CALL_OW 72
75281: PUSH
75282: LD_EXP 65
75286: PUSH
75287: LD_VAR 0 2
75291: ARRAY
75292: DIFF
75293: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75294: LD_ADDR_VAR 0 9
75298: PUSH
75299: LD_EXP 61
75303: PUSH
75304: LD_VAR 0 2
75308: ARRAY
75309: PPUSH
75310: LD_INT 2
75312: PUSH
75313: LD_INT 30
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 30
75325: PUSH
75326: LD_INT 1
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: LIST
75337: PPUSH
75338: CALL_OW 72
75342: ST_TO_ADDR
// if not tmp or not dep then
75343: LD_VAR 0 8
75347: NOT
75348: PUSH
75349: LD_VAR 0 9
75353: NOT
75354: OR
75355: IFFALSE 75359
// continue ;
75357: GO 75144
// side := GetSide ( tmp [ 1 ] ) ;
75359: LD_ADDR_VAR 0 11
75363: PUSH
75364: LD_VAR 0 8
75368: PUSH
75369: LD_INT 1
75371: ARRAY
75372: PPUSH
75373: CALL_OW 255
75377: ST_TO_ADDR
// dep := dep [ 1 ] ;
75378: LD_ADDR_VAR 0 9
75382: PUSH
75383: LD_VAR 0 9
75387: PUSH
75388: LD_INT 1
75390: ARRAY
75391: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75392: LD_ADDR_VAR 0 7
75396: PUSH
75397: LD_EXP 89
75401: PUSH
75402: LD_VAR 0 2
75406: ARRAY
75407: PPUSH
75408: LD_INT 22
75410: PUSH
75411: LD_INT 0
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 25
75420: PUSH
75421: LD_INT 12
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PPUSH
75432: CALL_OW 70
75436: PUSH
75437: LD_INT 22
75439: PUSH
75440: LD_INT 0
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 25
75449: PUSH
75450: LD_INT 12
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: PUSH
75457: LD_INT 91
75459: PUSH
75460: LD_VAR 0 9
75464: PUSH
75465: LD_INT 20
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: LIST
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: LIST
75477: PPUSH
75478: CALL_OW 69
75482: UNION
75483: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75484: LD_ADDR_VAR 0 10
75488: PUSH
75489: LD_EXP 89
75493: PUSH
75494: LD_VAR 0 2
75498: ARRAY
75499: PPUSH
75500: LD_INT 81
75502: PUSH
75503: LD_VAR 0 11
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PPUSH
75512: CALL_OW 70
75516: ST_TO_ADDR
// if not apes or danger_at_area then
75517: LD_VAR 0 7
75521: NOT
75522: PUSH
75523: LD_VAR 0 10
75527: OR
75528: IFFALSE 75578
// begin if mc_taming [ i ] then
75530: LD_EXP 92
75534: PUSH
75535: LD_VAR 0 2
75539: ARRAY
75540: IFFALSE 75576
// begin MC_Reset ( i , 121 ) ;
75542: LD_VAR 0 2
75546: PPUSH
75547: LD_INT 121
75549: PPUSH
75550: CALL 60515 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75554: LD_ADDR_EXP 92
75558: PUSH
75559: LD_EXP 92
75563: PPUSH
75564: LD_VAR 0 2
75568: PPUSH
75569: EMPTY
75570: PPUSH
75571: CALL_OW 1
75575: ST_TO_ADDR
// end ; continue ;
75576: GO 75144
// end ; for j in tmp do
75578: LD_ADDR_VAR 0 3
75582: PUSH
75583: LD_VAR 0 8
75587: PUSH
75588: FOR_IN
75589: IFFALSE 75925
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75591: LD_VAR 0 3
75595: PUSH
75596: LD_EXP 92
75600: PUSH
75601: LD_VAR 0 2
75605: ARRAY
75606: IN
75607: NOT
75608: PUSH
75609: LD_EXP 92
75613: PUSH
75614: LD_VAR 0 2
75618: ARRAY
75619: PUSH
75620: LD_INT 3
75622: LESS
75623: AND
75624: IFFALSE 75682
// begin SetTag ( j , 121 ) ;
75626: LD_VAR 0 3
75630: PPUSH
75631: LD_INT 121
75633: PPUSH
75634: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75638: LD_ADDR_EXP 92
75642: PUSH
75643: LD_EXP 92
75647: PPUSH
75648: LD_VAR 0 2
75652: PUSH
75653: LD_EXP 92
75657: PUSH
75658: LD_VAR 0 2
75662: ARRAY
75663: PUSH
75664: LD_INT 1
75666: PLUS
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PPUSH
75672: LD_VAR 0 3
75676: PPUSH
75677: CALL 20070 0 3
75681: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75682: LD_VAR 0 3
75686: PUSH
75687: LD_EXP 92
75691: PUSH
75692: LD_VAR 0 2
75696: ARRAY
75697: IN
75698: IFFALSE 75923
// begin if GetClass ( j ) <> 4 then
75700: LD_VAR 0 3
75704: PPUSH
75705: CALL_OW 257
75709: PUSH
75710: LD_INT 4
75712: NONEQUAL
75713: IFFALSE 75766
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75715: LD_ADDR_EXP 92
75719: PUSH
75720: LD_EXP 92
75724: PPUSH
75725: LD_VAR 0 2
75729: PPUSH
75730: LD_EXP 92
75734: PUSH
75735: LD_VAR 0 2
75739: ARRAY
75740: PUSH
75741: LD_VAR 0 3
75745: DIFF
75746: PPUSH
75747: CALL_OW 1
75751: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75752: LD_VAR 0 3
75756: PPUSH
75757: LD_INT 0
75759: PPUSH
75760: CALL_OW 109
// continue ;
75764: GO 75588
// end ; if IsInUnit ( j ) then
75766: LD_VAR 0 3
75770: PPUSH
75771: CALL_OW 310
75775: IFFALSE 75786
// ComExitBuilding ( j ) ;
75777: LD_VAR 0 3
75781: PPUSH
75782: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75786: LD_ADDR_VAR 0 6
75790: PUSH
75791: LD_VAR 0 7
75795: PPUSH
75796: LD_VAR 0 3
75800: PPUSH
75801: CALL_OW 74
75805: ST_TO_ADDR
// if not ape then
75806: LD_VAR 0 6
75810: NOT
75811: IFFALSE 75815
// break ;
75813: GO 75925
// x := GetX ( ape ) ;
75815: LD_ADDR_VAR 0 4
75819: PUSH
75820: LD_VAR 0 6
75824: PPUSH
75825: CALL_OW 250
75829: ST_TO_ADDR
// y := GetY ( ape ) ;
75830: LD_ADDR_VAR 0 5
75834: PUSH
75835: LD_VAR 0 6
75839: PPUSH
75840: CALL_OW 251
75844: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75845: LD_VAR 0 4
75849: PPUSH
75850: LD_VAR 0 5
75854: PPUSH
75855: CALL_OW 488
75859: NOT
75860: PUSH
75861: LD_VAR 0 11
75865: PPUSH
75866: LD_VAR 0 4
75870: PPUSH
75871: LD_VAR 0 5
75875: PPUSH
75876: LD_INT 20
75878: PPUSH
75879: CALL 20966 0 4
75883: PUSH
75884: LD_INT 4
75886: ARRAY
75887: OR
75888: IFFALSE 75892
// break ;
75890: GO 75925
// if not HasTask ( j ) then
75892: LD_VAR 0 3
75896: PPUSH
75897: CALL_OW 314
75901: NOT
75902: IFFALSE 75923
// ComTameXY ( j , x , y ) ;
75904: LD_VAR 0 3
75908: PPUSH
75909: LD_VAR 0 4
75913: PPUSH
75914: LD_VAR 0 5
75918: PPUSH
75919: CALL_OW 131
// end ; end ;
75923: GO 75588
75925: POP
75926: POP
// end ;
75927: GO 75144
75929: POP
75930: POP
// end ;
75931: LD_VAR 0 1
75935: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75936: LD_INT 0
75938: PPUSH
75939: PPUSH
75940: PPUSH
75941: PPUSH
75942: PPUSH
75943: PPUSH
75944: PPUSH
75945: PPUSH
// if not mc_bases then
75946: LD_EXP 61
75950: NOT
75951: IFFALSE 75955
// exit ;
75953: GO 76581
// for i = 1 to mc_bases do
75955: LD_ADDR_VAR 0 2
75959: PUSH
75960: DOUBLE
75961: LD_INT 1
75963: DEC
75964: ST_TO_ADDR
75965: LD_EXP 61
75969: PUSH
75970: FOR_TO
75971: IFFALSE 76579
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75973: LD_EXP 90
75977: PUSH
75978: LD_VAR 0 2
75982: ARRAY
75983: NOT
75984: PUSH
75985: LD_EXP 90
75989: PUSH
75990: LD_VAR 0 2
75994: ARRAY
75995: PPUSH
75996: LD_INT 25
75998: PUSH
75999: LD_INT 12
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PPUSH
76006: CALL_OW 72
76010: NOT
76011: OR
76012: IFFALSE 76016
// continue ;
76014: GO 75970
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76016: LD_ADDR_VAR 0 5
76020: PUSH
76021: LD_EXP 90
76025: PUSH
76026: LD_VAR 0 2
76030: ARRAY
76031: PUSH
76032: LD_INT 1
76034: ARRAY
76035: PPUSH
76036: CALL_OW 255
76040: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76041: LD_VAR 0 5
76045: PPUSH
76046: LD_INT 2
76048: PPUSH
76049: CALL_OW 325
76053: IFFALSE 76306
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76055: LD_ADDR_VAR 0 4
76059: PUSH
76060: LD_EXP 90
76064: PUSH
76065: LD_VAR 0 2
76069: ARRAY
76070: PPUSH
76071: LD_INT 25
76073: PUSH
76074: LD_INT 16
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PPUSH
76081: CALL_OW 72
76085: ST_TO_ADDR
// if tmp < 6 then
76086: LD_VAR 0 4
76090: PUSH
76091: LD_INT 6
76093: LESS
76094: IFFALSE 76306
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76096: LD_ADDR_VAR 0 6
76100: PUSH
76101: LD_EXP 61
76105: PUSH
76106: LD_VAR 0 2
76110: ARRAY
76111: PPUSH
76112: LD_INT 2
76114: PUSH
76115: LD_INT 30
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 30
76127: PUSH
76128: LD_INT 1
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: LIST
76139: PPUSH
76140: CALL_OW 72
76144: ST_TO_ADDR
// if depot then
76145: LD_VAR 0 6
76149: IFFALSE 76306
// begin selected := 0 ;
76151: LD_ADDR_VAR 0 7
76155: PUSH
76156: LD_INT 0
76158: ST_TO_ADDR
// for j in depot do
76159: LD_ADDR_VAR 0 3
76163: PUSH
76164: LD_VAR 0 6
76168: PUSH
76169: FOR_IN
76170: IFFALSE 76201
// begin if UnitsInside ( j ) < 6 then
76172: LD_VAR 0 3
76176: PPUSH
76177: CALL_OW 313
76181: PUSH
76182: LD_INT 6
76184: LESS
76185: IFFALSE 76199
// begin selected := j ;
76187: LD_ADDR_VAR 0 7
76191: PUSH
76192: LD_VAR 0 3
76196: ST_TO_ADDR
// break ;
76197: GO 76201
// end ; end ;
76199: GO 76169
76201: POP
76202: POP
// if selected then
76203: LD_VAR 0 7
76207: IFFALSE 76306
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76209: LD_ADDR_VAR 0 3
76213: PUSH
76214: LD_EXP 90
76218: PUSH
76219: LD_VAR 0 2
76223: ARRAY
76224: PPUSH
76225: LD_INT 25
76227: PUSH
76228: LD_INT 12
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PPUSH
76235: CALL_OW 72
76239: PUSH
76240: FOR_IN
76241: IFFALSE 76304
// if not HasTask ( j ) then
76243: LD_VAR 0 3
76247: PPUSH
76248: CALL_OW 314
76252: NOT
76253: IFFALSE 76302
// begin if not IsInUnit ( j ) then
76255: LD_VAR 0 3
76259: PPUSH
76260: CALL_OW 310
76264: NOT
76265: IFFALSE 76281
// ComEnterUnit ( j , selected ) ;
76267: LD_VAR 0 3
76271: PPUSH
76272: LD_VAR 0 7
76276: PPUSH
76277: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76281: LD_VAR 0 3
76285: PPUSH
76286: LD_INT 16
76288: PPUSH
76289: CALL_OW 183
// AddComExitBuilding ( j ) ;
76293: LD_VAR 0 3
76297: PPUSH
76298: CALL_OW 182
// end ;
76302: GO 76240
76304: POP
76305: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76306: LD_VAR 0 5
76310: PPUSH
76311: LD_INT 11
76313: PPUSH
76314: CALL_OW 325
76318: IFFALSE 76577
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76320: LD_ADDR_VAR 0 4
76324: PUSH
76325: LD_EXP 90
76329: PUSH
76330: LD_VAR 0 2
76334: ARRAY
76335: PPUSH
76336: LD_INT 25
76338: PUSH
76339: LD_INT 16
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PPUSH
76346: CALL_OW 72
76350: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76351: LD_VAR 0 4
76355: PUSH
76356: LD_INT 6
76358: GREATEREQUAL
76359: PUSH
76360: LD_VAR 0 5
76364: PPUSH
76365: LD_INT 2
76367: PPUSH
76368: CALL_OW 325
76372: NOT
76373: OR
76374: IFFALSE 76577
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76376: LD_ADDR_VAR 0 8
76380: PUSH
76381: LD_EXP 61
76385: PUSH
76386: LD_VAR 0 2
76390: ARRAY
76391: PPUSH
76392: LD_INT 2
76394: PUSH
76395: LD_INT 30
76397: PUSH
76398: LD_INT 4
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 30
76407: PUSH
76408: LD_INT 5
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: LIST
76419: PPUSH
76420: CALL_OW 72
76424: ST_TO_ADDR
// if barracks then
76425: LD_VAR 0 8
76429: IFFALSE 76577
// begin selected := 0 ;
76431: LD_ADDR_VAR 0 7
76435: PUSH
76436: LD_INT 0
76438: ST_TO_ADDR
// for j in barracks do
76439: LD_ADDR_VAR 0 3
76443: PUSH
76444: LD_VAR 0 8
76448: PUSH
76449: FOR_IN
76450: IFFALSE 76481
// begin if UnitsInside ( j ) < 6 then
76452: LD_VAR 0 3
76456: PPUSH
76457: CALL_OW 313
76461: PUSH
76462: LD_INT 6
76464: LESS
76465: IFFALSE 76479
// begin selected := j ;
76467: LD_ADDR_VAR 0 7
76471: PUSH
76472: LD_VAR 0 3
76476: ST_TO_ADDR
// break ;
76477: GO 76481
// end ; end ;
76479: GO 76449
76481: POP
76482: POP
// if selected then
76483: LD_VAR 0 7
76487: IFFALSE 76577
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76489: LD_ADDR_VAR 0 3
76493: PUSH
76494: LD_EXP 90
76498: PUSH
76499: LD_VAR 0 2
76503: ARRAY
76504: PPUSH
76505: LD_INT 25
76507: PUSH
76508: LD_INT 12
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PPUSH
76515: CALL_OW 72
76519: PUSH
76520: FOR_IN
76521: IFFALSE 76575
// if not IsInUnit ( j ) and not HasTask ( j ) then
76523: LD_VAR 0 3
76527: PPUSH
76528: CALL_OW 310
76532: NOT
76533: PUSH
76534: LD_VAR 0 3
76538: PPUSH
76539: CALL_OW 314
76543: NOT
76544: AND
76545: IFFALSE 76573
// begin ComEnterUnit ( j , selected ) ;
76547: LD_VAR 0 3
76551: PPUSH
76552: LD_VAR 0 7
76556: PPUSH
76557: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76561: LD_VAR 0 3
76565: PPUSH
76566: LD_INT 15
76568: PPUSH
76569: CALL_OW 183
// end ;
76573: GO 76520
76575: POP
76576: POP
// end ; end ; end ; end ; end ;
76577: GO 75970
76579: POP
76580: POP
// end ;
76581: LD_VAR 0 1
76585: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76586: LD_INT 0
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
// if not mc_bases then
76592: LD_EXP 61
76596: NOT
76597: IFFALSE 76601
// exit ;
76599: GO 76779
// for i = 1 to mc_bases do
76601: LD_ADDR_VAR 0 2
76605: PUSH
76606: DOUBLE
76607: LD_INT 1
76609: DEC
76610: ST_TO_ADDR
76611: LD_EXP 61
76615: PUSH
76616: FOR_TO
76617: IFFALSE 76777
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76619: LD_ADDR_VAR 0 4
76623: PUSH
76624: LD_EXP 61
76628: PUSH
76629: LD_VAR 0 2
76633: ARRAY
76634: PPUSH
76635: LD_INT 25
76637: PUSH
76638: LD_INT 9
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PPUSH
76645: CALL_OW 72
76649: ST_TO_ADDR
// if not tmp then
76650: LD_VAR 0 4
76654: NOT
76655: IFFALSE 76659
// continue ;
76657: GO 76616
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76659: LD_EXP 87
76663: PUSH
76664: LD_VAR 0 2
76668: ARRAY
76669: PPUSH
76670: LD_INT 29
76672: PPUSH
76673: CALL_OW 325
76677: NOT
76678: PUSH
76679: LD_EXP 87
76683: PUSH
76684: LD_VAR 0 2
76688: ARRAY
76689: PPUSH
76690: LD_INT 28
76692: PPUSH
76693: CALL_OW 325
76697: NOT
76698: AND
76699: IFFALSE 76703
// continue ;
76701: GO 76616
// for j in tmp do
76703: LD_ADDR_VAR 0 3
76707: PUSH
76708: LD_VAR 0 4
76712: PUSH
76713: FOR_IN
76714: IFFALSE 76773
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76716: LD_VAR 0 3
76720: PUSH
76721: LD_EXP 64
76725: PUSH
76726: LD_VAR 0 2
76730: ARRAY
76731: PUSH
76732: LD_INT 1
76734: ARRAY
76735: IN
76736: NOT
76737: PUSH
76738: LD_VAR 0 3
76742: PUSH
76743: LD_EXP 64
76747: PUSH
76748: LD_VAR 0 2
76752: ARRAY
76753: PUSH
76754: LD_INT 2
76756: ARRAY
76757: IN
76758: NOT
76759: AND
76760: IFFALSE 76771
// ComSpaceTimeShoot ( j ) ;
76762: LD_VAR 0 3
76766: PPUSH
76767: CALL 15880 0 1
76771: GO 76713
76773: POP
76774: POP
// end ;
76775: GO 76616
76777: POP
76778: POP
// end ;
76779: LD_VAR 0 1
76783: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76784: LD_INT 0
76786: PPUSH
76787: PPUSH
76788: PPUSH
76789: PPUSH
76790: PPUSH
76791: PPUSH
76792: PPUSH
76793: PPUSH
76794: PPUSH
// if not mc_bases then
76795: LD_EXP 61
76799: NOT
76800: IFFALSE 76804
// exit ;
76802: GO 77426
// for i = 1 to mc_bases do
76804: LD_ADDR_VAR 0 2
76808: PUSH
76809: DOUBLE
76810: LD_INT 1
76812: DEC
76813: ST_TO_ADDR
76814: LD_EXP 61
76818: PUSH
76819: FOR_TO
76820: IFFALSE 77424
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76822: LD_EXP 96
76826: PUSH
76827: LD_VAR 0 2
76831: ARRAY
76832: NOT
76833: PUSH
76834: LD_INT 38
76836: PPUSH
76837: LD_EXP 87
76841: PUSH
76842: LD_VAR 0 2
76846: ARRAY
76847: PPUSH
76848: CALL_OW 321
76852: PUSH
76853: LD_INT 2
76855: NONEQUAL
76856: OR
76857: IFFALSE 76861
// continue ;
76859: GO 76819
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76861: LD_ADDR_VAR 0 8
76865: PUSH
76866: LD_EXP 61
76870: PUSH
76871: LD_VAR 0 2
76875: ARRAY
76876: PPUSH
76877: LD_INT 30
76879: PUSH
76880: LD_INT 34
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PPUSH
76887: CALL_OW 72
76891: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76892: LD_ADDR_VAR 0 9
76896: PUSH
76897: LD_EXP 61
76901: PUSH
76902: LD_VAR 0 2
76906: ARRAY
76907: PPUSH
76908: LD_INT 25
76910: PUSH
76911: LD_INT 4
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PPUSH
76918: CALL_OW 72
76922: PPUSH
76923: LD_INT 0
76925: PPUSH
76926: CALL 49982 0 2
76930: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76931: LD_VAR 0 9
76935: NOT
76936: PUSH
76937: LD_VAR 0 8
76941: NOT
76942: OR
76943: PUSH
76944: LD_EXP 61
76948: PUSH
76949: LD_VAR 0 2
76953: ARRAY
76954: PPUSH
76955: LD_INT 124
76957: PPUSH
76958: CALL 49982 0 2
76962: OR
76963: IFFALSE 76967
// continue ;
76965: GO 76819
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76967: LD_EXP 97
76971: PUSH
76972: LD_VAR 0 2
76976: ARRAY
76977: PUSH
76978: LD_EXP 96
76982: PUSH
76983: LD_VAR 0 2
76987: ARRAY
76988: LESS
76989: PUSH
76990: LD_EXP 97
76994: PUSH
76995: LD_VAR 0 2
76999: ARRAY
77000: PUSH
77001: LD_VAR 0 8
77005: LESS
77006: AND
77007: IFFALSE 77422
// begin tmp := sci [ 1 ] ;
77009: LD_ADDR_VAR 0 7
77013: PUSH
77014: LD_VAR 0 9
77018: PUSH
77019: LD_INT 1
77021: ARRAY
77022: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77023: LD_VAR 0 7
77027: PPUSH
77028: LD_INT 124
77030: PPUSH
77031: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77035: LD_ADDR_VAR 0 3
77039: PUSH
77040: DOUBLE
77041: LD_EXP 96
77045: PUSH
77046: LD_VAR 0 2
77050: ARRAY
77051: INC
77052: ST_TO_ADDR
77053: LD_EXP 96
77057: PUSH
77058: LD_VAR 0 2
77062: ARRAY
77063: PUSH
77064: FOR_DOWNTO
77065: IFFALSE 77408
// begin if IsInUnit ( tmp ) then
77067: LD_VAR 0 7
77071: PPUSH
77072: CALL_OW 310
77076: IFFALSE 77087
// ComExitBuilding ( tmp ) ;
77078: LD_VAR 0 7
77082: PPUSH
77083: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77087: LD_INT 35
77089: PPUSH
77090: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77094: LD_VAR 0 7
77098: PPUSH
77099: CALL_OW 310
77103: NOT
77104: PUSH
77105: LD_VAR 0 7
77109: PPUSH
77110: CALL_OW 314
77114: NOT
77115: AND
77116: IFFALSE 77087
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77118: LD_ADDR_VAR 0 6
77122: PUSH
77123: LD_VAR 0 7
77127: PPUSH
77128: CALL_OW 250
77132: PUSH
77133: LD_VAR 0 7
77137: PPUSH
77138: CALL_OW 251
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77147: LD_INT 35
77149: PPUSH
77150: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77154: LD_ADDR_VAR 0 4
77158: PUSH
77159: LD_EXP 96
77163: PUSH
77164: LD_VAR 0 2
77168: ARRAY
77169: PUSH
77170: LD_VAR 0 3
77174: ARRAY
77175: PUSH
77176: LD_INT 1
77178: ARRAY
77179: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77180: LD_ADDR_VAR 0 5
77184: PUSH
77185: LD_EXP 96
77189: PUSH
77190: LD_VAR 0 2
77194: ARRAY
77195: PUSH
77196: LD_VAR 0 3
77200: ARRAY
77201: PUSH
77202: LD_INT 2
77204: ARRAY
77205: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77206: LD_VAR 0 7
77210: PPUSH
77211: LD_INT 10
77213: PPUSH
77214: CALL 22667 0 2
77218: PUSH
77219: LD_INT 4
77221: ARRAY
77222: IFFALSE 77260
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77224: LD_VAR 0 7
77228: PPUSH
77229: LD_VAR 0 6
77233: PUSH
77234: LD_INT 1
77236: ARRAY
77237: PPUSH
77238: LD_VAR 0 6
77242: PUSH
77243: LD_INT 2
77245: ARRAY
77246: PPUSH
77247: CALL_OW 111
// wait ( 0 0$10 ) ;
77251: LD_INT 350
77253: PPUSH
77254: CALL_OW 67
// end else
77258: GO 77286
// begin ComMoveXY ( tmp , x , y ) ;
77260: LD_VAR 0 7
77264: PPUSH
77265: LD_VAR 0 4
77269: PPUSH
77270: LD_VAR 0 5
77274: PPUSH
77275: CALL_OW 111
// wait ( 0 0$3 ) ;
77279: LD_INT 105
77281: PPUSH
77282: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77286: LD_VAR 0 7
77290: PPUSH
77291: LD_VAR 0 4
77295: PPUSH
77296: LD_VAR 0 5
77300: PPUSH
77301: CALL_OW 307
77305: IFFALSE 77147
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77307: LD_VAR 0 7
77311: PPUSH
77312: LD_VAR 0 4
77316: PPUSH
77317: LD_VAR 0 5
77321: PPUSH
77322: LD_VAR 0 8
77326: PUSH
77327: LD_VAR 0 3
77331: ARRAY
77332: PPUSH
77333: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77337: LD_INT 35
77339: PPUSH
77340: CALL_OW 67
// until not HasTask ( tmp ) ;
77344: LD_VAR 0 7
77348: PPUSH
77349: CALL_OW 314
77353: NOT
77354: IFFALSE 77337
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77356: LD_ADDR_EXP 97
77360: PUSH
77361: LD_EXP 97
77365: PPUSH
77366: LD_VAR 0 2
77370: PUSH
77371: LD_EXP 97
77375: PUSH
77376: LD_VAR 0 2
77380: ARRAY
77381: PUSH
77382: LD_INT 1
77384: PLUS
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PPUSH
77390: LD_VAR 0 8
77394: PUSH
77395: LD_VAR 0 3
77399: ARRAY
77400: PPUSH
77401: CALL 20070 0 3
77405: ST_TO_ADDR
// end ;
77406: GO 77064
77408: POP
77409: POP
// MC_Reset ( i , 124 ) ;
77410: LD_VAR 0 2
77414: PPUSH
77415: LD_INT 124
77417: PPUSH
77418: CALL 60515 0 2
// end ; end ;
77422: GO 76819
77424: POP
77425: POP
// end ;
77426: LD_VAR 0 1
77430: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77431: LD_INT 0
77433: PPUSH
77434: PPUSH
77435: PPUSH
// if not mc_bases then
77436: LD_EXP 61
77440: NOT
77441: IFFALSE 77445
// exit ;
77443: GO 78051
// for i = 1 to mc_bases do
77445: LD_ADDR_VAR 0 2
77449: PUSH
77450: DOUBLE
77451: LD_INT 1
77453: DEC
77454: ST_TO_ADDR
77455: LD_EXP 61
77459: PUSH
77460: FOR_TO
77461: IFFALSE 78049
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77463: LD_ADDR_VAR 0 3
77467: PUSH
77468: LD_EXP 61
77472: PUSH
77473: LD_VAR 0 2
77477: ARRAY
77478: PPUSH
77479: LD_INT 25
77481: PUSH
77482: LD_INT 4
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PPUSH
77489: CALL_OW 72
77493: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77494: LD_VAR 0 3
77498: NOT
77499: PUSH
77500: LD_EXP 98
77504: PUSH
77505: LD_VAR 0 2
77509: ARRAY
77510: NOT
77511: OR
77512: PUSH
77513: LD_EXP 61
77517: PUSH
77518: LD_VAR 0 2
77522: ARRAY
77523: PPUSH
77524: LD_INT 2
77526: PUSH
77527: LD_INT 30
77529: PUSH
77530: LD_INT 0
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 30
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: LIST
77551: PPUSH
77552: CALL_OW 72
77556: NOT
77557: OR
77558: IFFALSE 77608
// begin if mc_deposits_finder [ i ] then
77560: LD_EXP 99
77564: PUSH
77565: LD_VAR 0 2
77569: ARRAY
77570: IFFALSE 77606
// begin MC_Reset ( i , 125 ) ;
77572: LD_VAR 0 2
77576: PPUSH
77577: LD_INT 125
77579: PPUSH
77580: CALL 60515 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77584: LD_ADDR_EXP 99
77588: PUSH
77589: LD_EXP 99
77593: PPUSH
77594: LD_VAR 0 2
77598: PPUSH
77599: EMPTY
77600: PPUSH
77601: CALL_OW 1
77605: ST_TO_ADDR
// end ; continue ;
77606: GO 77460
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77608: LD_EXP 98
77612: PUSH
77613: LD_VAR 0 2
77617: ARRAY
77618: PUSH
77619: LD_INT 1
77621: ARRAY
77622: PUSH
77623: LD_INT 3
77625: ARRAY
77626: PUSH
77627: LD_INT 1
77629: EQUAL
77630: PUSH
77631: LD_INT 20
77633: PPUSH
77634: LD_EXP 87
77638: PUSH
77639: LD_VAR 0 2
77643: ARRAY
77644: PPUSH
77645: CALL_OW 321
77649: PUSH
77650: LD_INT 2
77652: NONEQUAL
77653: AND
77654: IFFALSE 77704
// begin if mc_deposits_finder [ i ] then
77656: LD_EXP 99
77660: PUSH
77661: LD_VAR 0 2
77665: ARRAY
77666: IFFALSE 77702
// begin MC_Reset ( i , 125 ) ;
77668: LD_VAR 0 2
77672: PPUSH
77673: LD_INT 125
77675: PPUSH
77676: CALL 60515 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77680: LD_ADDR_EXP 99
77684: PUSH
77685: LD_EXP 99
77689: PPUSH
77690: LD_VAR 0 2
77694: PPUSH
77695: EMPTY
77696: PPUSH
77697: CALL_OW 1
77701: ST_TO_ADDR
// end ; continue ;
77702: GO 77460
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77704: LD_EXP 98
77708: PUSH
77709: LD_VAR 0 2
77713: ARRAY
77714: PUSH
77715: LD_INT 1
77717: ARRAY
77718: PUSH
77719: LD_INT 1
77721: ARRAY
77722: PPUSH
77723: LD_EXP 98
77727: PUSH
77728: LD_VAR 0 2
77732: ARRAY
77733: PUSH
77734: LD_INT 1
77736: ARRAY
77737: PUSH
77738: LD_INT 2
77740: ARRAY
77741: PPUSH
77742: LD_EXP 87
77746: PUSH
77747: LD_VAR 0 2
77751: ARRAY
77752: PPUSH
77753: CALL_OW 440
77757: IFFALSE 77800
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77759: LD_ADDR_EXP 98
77763: PUSH
77764: LD_EXP 98
77768: PPUSH
77769: LD_VAR 0 2
77773: PPUSH
77774: LD_EXP 98
77778: PUSH
77779: LD_VAR 0 2
77783: ARRAY
77784: PPUSH
77785: LD_INT 1
77787: PPUSH
77788: CALL_OW 3
77792: PPUSH
77793: CALL_OW 1
77797: ST_TO_ADDR
77798: GO 78047
// begin if not mc_deposits_finder [ i ] then
77800: LD_EXP 99
77804: PUSH
77805: LD_VAR 0 2
77809: ARRAY
77810: NOT
77811: IFFALSE 77863
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77813: LD_ADDR_EXP 99
77817: PUSH
77818: LD_EXP 99
77822: PPUSH
77823: LD_VAR 0 2
77827: PPUSH
77828: LD_VAR 0 3
77832: PUSH
77833: LD_INT 1
77835: ARRAY
77836: PUSH
77837: EMPTY
77838: LIST
77839: PPUSH
77840: CALL_OW 1
77844: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77845: LD_VAR 0 3
77849: PUSH
77850: LD_INT 1
77852: ARRAY
77853: PPUSH
77854: LD_INT 125
77856: PPUSH
77857: CALL_OW 109
// end else
77861: GO 78047
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77863: LD_EXP 99
77867: PUSH
77868: LD_VAR 0 2
77872: ARRAY
77873: PUSH
77874: LD_INT 1
77876: ARRAY
77877: PPUSH
77878: CALL_OW 310
77882: IFFALSE 77905
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77884: LD_EXP 99
77888: PUSH
77889: LD_VAR 0 2
77893: ARRAY
77894: PUSH
77895: LD_INT 1
77897: ARRAY
77898: PPUSH
77899: CALL_OW 122
77903: GO 78047
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77905: LD_EXP 99
77909: PUSH
77910: LD_VAR 0 2
77914: ARRAY
77915: PUSH
77916: LD_INT 1
77918: ARRAY
77919: PPUSH
77920: CALL_OW 314
77924: NOT
77925: PUSH
77926: LD_EXP 99
77930: PUSH
77931: LD_VAR 0 2
77935: ARRAY
77936: PUSH
77937: LD_INT 1
77939: ARRAY
77940: PPUSH
77941: LD_EXP 98
77945: PUSH
77946: LD_VAR 0 2
77950: ARRAY
77951: PUSH
77952: LD_INT 1
77954: ARRAY
77955: PUSH
77956: LD_INT 1
77958: ARRAY
77959: PPUSH
77960: LD_EXP 98
77964: PUSH
77965: LD_VAR 0 2
77969: ARRAY
77970: PUSH
77971: LD_INT 1
77973: ARRAY
77974: PUSH
77975: LD_INT 2
77977: ARRAY
77978: PPUSH
77979: CALL_OW 297
77983: PUSH
77984: LD_INT 6
77986: GREATER
77987: AND
77988: IFFALSE 78047
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77990: LD_EXP 99
77994: PUSH
77995: LD_VAR 0 2
77999: ARRAY
78000: PUSH
78001: LD_INT 1
78003: ARRAY
78004: PPUSH
78005: LD_EXP 98
78009: PUSH
78010: LD_VAR 0 2
78014: ARRAY
78015: PUSH
78016: LD_INT 1
78018: ARRAY
78019: PUSH
78020: LD_INT 1
78022: ARRAY
78023: PPUSH
78024: LD_EXP 98
78028: PUSH
78029: LD_VAR 0 2
78033: ARRAY
78034: PUSH
78035: LD_INT 1
78037: ARRAY
78038: PUSH
78039: LD_INT 2
78041: ARRAY
78042: PPUSH
78043: CALL_OW 111
// end ; end ; end ;
78047: GO 77460
78049: POP
78050: POP
// end ;
78051: LD_VAR 0 1
78055: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78056: LD_INT 0
78058: PPUSH
78059: PPUSH
78060: PPUSH
78061: PPUSH
78062: PPUSH
78063: PPUSH
78064: PPUSH
78065: PPUSH
78066: PPUSH
78067: PPUSH
78068: PPUSH
// if not mc_bases then
78069: LD_EXP 61
78073: NOT
78074: IFFALSE 78078
// exit ;
78076: GO 79018
// for i = 1 to mc_bases do
78078: LD_ADDR_VAR 0 2
78082: PUSH
78083: DOUBLE
78084: LD_INT 1
78086: DEC
78087: ST_TO_ADDR
78088: LD_EXP 61
78092: PUSH
78093: FOR_TO
78094: IFFALSE 79016
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78096: LD_EXP 61
78100: PUSH
78101: LD_VAR 0 2
78105: ARRAY
78106: NOT
78107: PUSH
78108: LD_EXP 84
78112: PUSH
78113: LD_VAR 0 2
78117: ARRAY
78118: OR
78119: IFFALSE 78123
// continue ;
78121: GO 78093
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78123: LD_ADDR_VAR 0 7
78127: PUSH
78128: LD_EXP 61
78132: PUSH
78133: LD_VAR 0 2
78137: ARRAY
78138: PUSH
78139: LD_INT 1
78141: ARRAY
78142: PPUSH
78143: CALL_OW 248
78147: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78148: LD_VAR 0 7
78152: PUSH
78153: LD_INT 3
78155: EQUAL
78156: PUSH
78157: LD_EXP 80
78161: PUSH
78162: LD_VAR 0 2
78166: ARRAY
78167: PUSH
78168: LD_EXP 83
78172: PUSH
78173: LD_VAR 0 2
78177: ARRAY
78178: UNION
78179: PPUSH
78180: LD_INT 33
78182: PUSH
78183: LD_INT 2
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PPUSH
78190: CALL_OW 72
78194: NOT
78195: OR
78196: IFFALSE 78200
// continue ;
78198: GO 78093
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78200: LD_ADDR_VAR 0 9
78204: PUSH
78205: LD_EXP 61
78209: PUSH
78210: LD_VAR 0 2
78214: ARRAY
78215: PPUSH
78216: LD_INT 30
78218: PUSH
78219: LD_INT 36
78221: PUSH
78222: EMPTY
78223: LIST
78224: LIST
78225: PPUSH
78226: CALL_OW 72
78230: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78231: LD_ADDR_VAR 0 10
78235: PUSH
78236: LD_EXP 80
78240: PUSH
78241: LD_VAR 0 2
78245: ARRAY
78246: PPUSH
78247: LD_INT 34
78249: PUSH
78250: LD_INT 31
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PPUSH
78257: CALL_OW 72
78261: ST_TO_ADDR
// if not cts and not mcts then
78262: LD_VAR 0 9
78266: NOT
78267: PUSH
78268: LD_VAR 0 10
78272: NOT
78273: AND
78274: IFFALSE 78278
// continue ;
78276: GO 78093
// x := cts ;
78278: LD_ADDR_VAR 0 11
78282: PUSH
78283: LD_VAR 0 9
78287: ST_TO_ADDR
// if not x then
78288: LD_VAR 0 11
78292: NOT
78293: IFFALSE 78305
// x := mcts ;
78295: LD_ADDR_VAR 0 11
78299: PUSH
78300: LD_VAR 0 10
78304: ST_TO_ADDR
// if not x then
78305: LD_VAR 0 11
78309: NOT
78310: IFFALSE 78314
// continue ;
78312: GO 78093
// if mc_remote_driver [ i ] then
78314: LD_EXP 101
78318: PUSH
78319: LD_VAR 0 2
78323: ARRAY
78324: IFFALSE 78711
// for j in mc_remote_driver [ i ] do
78326: LD_ADDR_VAR 0 3
78330: PUSH
78331: LD_EXP 101
78335: PUSH
78336: LD_VAR 0 2
78340: ARRAY
78341: PUSH
78342: FOR_IN
78343: IFFALSE 78709
// begin if GetClass ( j ) <> 3 then
78345: LD_VAR 0 3
78349: PPUSH
78350: CALL_OW 257
78354: PUSH
78355: LD_INT 3
78357: NONEQUAL
78358: IFFALSE 78411
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78360: LD_ADDR_EXP 101
78364: PUSH
78365: LD_EXP 101
78369: PPUSH
78370: LD_VAR 0 2
78374: PPUSH
78375: LD_EXP 101
78379: PUSH
78380: LD_VAR 0 2
78384: ARRAY
78385: PUSH
78386: LD_VAR 0 3
78390: DIFF
78391: PPUSH
78392: CALL_OW 1
78396: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78397: LD_VAR 0 3
78401: PPUSH
78402: LD_INT 0
78404: PPUSH
78405: CALL_OW 109
// continue ;
78409: GO 78342
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78411: LD_EXP 80
78415: PUSH
78416: LD_VAR 0 2
78420: ARRAY
78421: PPUSH
78422: LD_INT 34
78424: PUSH
78425: LD_INT 31
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 58
78434: PUSH
78435: EMPTY
78436: LIST
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PPUSH
78442: CALL_OW 72
78446: PUSH
78447: LD_VAR 0 3
78451: PPUSH
78452: CALL 50017 0 1
78456: NOT
78457: AND
78458: IFFALSE 78529
// begin if IsInUnit ( j ) then
78460: LD_VAR 0 3
78464: PPUSH
78465: CALL_OW 310
78469: IFFALSE 78480
// ComExitBuilding ( j ) ;
78471: LD_VAR 0 3
78475: PPUSH
78476: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78480: LD_VAR 0 3
78484: PPUSH
78485: LD_EXP 80
78489: PUSH
78490: LD_VAR 0 2
78494: ARRAY
78495: PPUSH
78496: LD_INT 34
78498: PUSH
78499: LD_INT 31
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 58
78508: PUSH
78509: EMPTY
78510: LIST
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PPUSH
78516: CALL_OW 72
78520: PUSH
78521: LD_INT 1
78523: ARRAY
78524: PPUSH
78525: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78529: LD_VAR 0 3
78533: PPUSH
78534: CALL_OW 310
78538: NOT
78539: PUSH
78540: LD_VAR 0 3
78544: PPUSH
78545: CALL_OW 310
78549: PPUSH
78550: CALL_OW 266
78554: PUSH
78555: LD_INT 36
78557: NONEQUAL
78558: PUSH
78559: LD_VAR 0 3
78563: PPUSH
78564: CALL 50017 0 1
78568: NOT
78569: AND
78570: OR
78571: IFFALSE 78707
// begin if IsInUnit ( j ) then
78573: LD_VAR 0 3
78577: PPUSH
78578: CALL_OW 310
78582: IFFALSE 78593
// ComExitBuilding ( j ) ;
78584: LD_VAR 0 3
78588: PPUSH
78589: CALL_OW 122
// ct := 0 ;
78593: LD_ADDR_VAR 0 8
78597: PUSH
78598: LD_INT 0
78600: ST_TO_ADDR
// for k in x do
78601: LD_ADDR_VAR 0 4
78605: PUSH
78606: LD_VAR 0 11
78610: PUSH
78611: FOR_IN
78612: IFFALSE 78685
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78614: LD_VAR 0 4
78618: PPUSH
78619: CALL_OW 264
78623: PUSH
78624: LD_INT 31
78626: EQUAL
78627: PUSH
78628: LD_VAR 0 4
78632: PPUSH
78633: CALL_OW 311
78637: NOT
78638: AND
78639: PUSH
78640: LD_VAR 0 4
78644: PPUSH
78645: CALL_OW 266
78649: PUSH
78650: LD_INT 36
78652: EQUAL
78653: PUSH
78654: LD_VAR 0 4
78658: PPUSH
78659: CALL_OW 313
78663: PUSH
78664: LD_INT 3
78666: LESS
78667: AND
78668: OR
78669: IFFALSE 78683
// begin ct := k ;
78671: LD_ADDR_VAR 0 8
78675: PUSH
78676: LD_VAR 0 4
78680: ST_TO_ADDR
// break ;
78681: GO 78685
// end ;
78683: GO 78611
78685: POP
78686: POP
// if ct then
78687: LD_VAR 0 8
78691: IFFALSE 78707
// ComEnterUnit ( j , ct ) ;
78693: LD_VAR 0 3
78697: PPUSH
78698: LD_VAR 0 8
78702: PPUSH
78703: CALL_OW 120
// end ; end ;
78707: GO 78342
78709: POP
78710: POP
// places := 0 ;
78711: LD_ADDR_VAR 0 5
78715: PUSH
78716: LD_INT 0
78718: ST_TO_ADDR
// for j = 1 to x do
78719: LD_ADDR_VAR 0 3
78723: PUSH
78724: DOUBLE
78725: LD_INT 1
78727: DEC
78728: ST_TO_ADDR
78729: LD_VAR 0 11
78733: PUSH
78734: FOR_TO
78735: IFFALSE 78811
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78737: LD_VAR 0 11
78741: PUSH
78742: LD_VAR 0 3
78746: ARRAY
78747: PPUSH
78748: CALL_OW 264
78752: PUSH
78753: LD_INT 31
78755: EQUAL
78756: IFFALSE 78774
// places := places + 1 else
78758: LD_ADDR_VAR 0 5
78762: PUSH
78763: LD_VAR 0 5
78767: PUSH
78768: LD_INT 1
78770: PLUS
78771: ST_TO_ADDR
78772: GO 78809
// if GetBType ( x [ j ] ) = b_control_tower then
78774: LD_VAR 0 11
78778: PUSH
78779: LD_VAR 0 3
78783: ARRAY
78784: PPUSH
78785: CALL_OW 266
78789: PUSH
78790: LD_INT 36
78792: EQUAL
78793: IFFALSE 78809
// places := places + 3 ;
78795: LD_ADDR_VAR 0 5
78799: PUSH
78800: LD_VAR 0 5
78804: PUSH
78805: LD_INT 3
78807: PLUS
78808: ST_TO_ADDR
78809: GO 78734
78811: POP
78812: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78813: LD_VAR 0 5
78817: PUSH
78818: LD_INT 0
78820: EQUAL
78821: PUSH
78822: LD_VAR 0 5
78826: PUSH
78827: LD_EXP 101
78831: PUSH
78832: LD_VAR 0 2
78836: ARRAY
78837: LESSEQUAL
78838: OR
78839: IFFALSE 78843
// continue ;
78841: GO 78093
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78843: LD_ADDR_VAR 0 6
78847: PUSH
78848: LD_EXP 61
78852: PUSH
78853: LD_VAR 0 2
78857: ARRAY
78858: PPUSH
78859: LD_INT 25
78861: PUSH
78862: LD_INT 3
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PPUSH
78869: CALL_OW 72
78873: PUSH
78874: LD_EXP 101
78878: PUSH
78879: LD_VAR 0 2
78883: ARRAY
78884: DIFF
78885: PPUSH
78886: LD_INT 3
78888: PPUSH
78889: CALL 50917 0 2
78893: ST_TO_ADDR
// for j in tmp do
78894: LD_ADDR_VAR 0 3
78898: PUSH
78899: LD_VAR 0 6
78903: PUSH
78904: FOR_IN
78905: IFFALSE 78940
// if GetTag ( j ) > 0 then
78907: LD_VAR 0 3
78911: PPUSH
78912: CALL_OW 110
78916: PUSH
78917: LD_INT 0
78919: GREATER
78920: IFFALSE 78938
// tmp := tmp diff j ;
78922: LD_ADDR_VAR 0 6
78926: PUSH
78927: LD_VAR 0 6
78931: PUSH
78932: LD_VAR 0 3
78936: DIFF
78937: ST_TO_ADDR
78938: GO 78904
78940: POP
78941: POP
// if not tmp then
78942: LD_VAR 0 6
78946: NOT
78947: IFFALSE 78951
// continue ;
78949: GO 78093
// if places then
78951: LD_VAR 0 5
78955: IFFALSE 79014
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78957: LD_ADDR_EXP 101
78961: PUSH
78962: LD_EXP 101
78966: PPUSH
78967: LD_VAR 0 2
78971: PPUSH
78972: LD_EXP 101
78976: PUSH
78977: LD_VAR 0 2
78981: ARRAY
78982: PUSH
78983: LD_VAR 0 6
78987: PUSH
78988: LD_INT 1
78990: ARRAY
78991: UNION
78992: PPUSH
78993: CALL_OW 1
78997: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78998: LD_VAR 0 6
79002: PUSH
79003: LD_INT 1
79005: ARRAY
79006: PPUSH
79007: LD_INT 126
79009: PPUSH
79010: CALL_OW 109
// end ; end ;
79014: GO 78093
79016: POP
79017: POP
// end ;
79018: LD_VAR 0 1
79022: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79023: LD_INT 0
79025: PPUSH
79026: PPUSH
79027: PPUSH
79028: PPUSH
79029: PPUSH
79030: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79031: LD_VAR 0 1
79035: NOT
79036: PUSH
79037: LD_VAR 0 2
79041: NOT
79042: OR
79043: PUSH
79044: LD_VAR 0 3
79048: NOT
79049: OR
79050: PUSH
79051: LD_VAR 0 4
79055: PUSH
79056: LD_INT 1
79058: PUSH
79059: LD_INT 2
79061: PUSH
79062: LD_INT 3
79064: PUSH
79065: LD_INT 4
79067: PUSH
79068: LD_INT 5
79070: PUSH
79071: LD_INT 8
79073: PUSH
79074: LD_INT 9
79076: PUSH
79077: LD_INT 15
79079: PUSH
79080: LD_INT 16
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: IN
79094: NOT
79095: OR
79096: IFFALSE 79100
// exit ;
79098: GO 80000
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79100: LD_ADDR_VAR 0 2
79104: PUSH
79105: LD_VAR 0 2
79109: PPUSH
79110: LD_INT 21
79112: PUSH
79113: LD_INT 3
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 24
79122: PUSH
79123: LD_INT 250
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PPUSH
79134: CALL_OW 72
79138: ST_TO_ADDR
// case class of 1 , 15 :
79139: LD_VAR 0 4
79143: PUSH
79144: LD_INT 1
79146: DOUBLE
79147: EQUAL
79148: IFTRUE 79158
79150: LD_INT 15
79152: DOUBLE
79153: EQUAL
79154: IFTRUE 79158
79156: GO 79243
79158: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79159: LD_ADDR_VAR 0 8
79163: PUSH
79164: LD_VAR 0 2
79168: PPUSH
79169: LD_INT 2
79171: PUSH
79172: LD_INT 30
79174: PUSH
79175: LD_INT 32
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 30
79184: PUSH
79185: LD_INT 31
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: LIST
79196: PPUSH
79197: CALL_OW 72
79201: PUSH
79202: LD_VAR 0 2
79206: PPUSH
79207: LD_INT 2
79209: PUSH
79210: LD_INT 30
79212: PUSH
79213: LD_INT 4
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 30
79222: PUSH
79223: LD_INT 5
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: LIST
79234: PPUSH
79235: CALL_OW 72
79239: ADD
79240: ST_TO_ADDR
79241: GO 79489
79243: LD_INT 2
79245: DOUBLE
79246: EQUAL
79247: IFTRUE 79257
79249: LD_INT 16
79251: DOUBLE
79252: EQUAL
79253: IFTRUE 79257
79255: GO 79303
79257: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79258: LD_ADDR_VAR 0 8
79262: PUSH
79263: LD_VAR 0 2
79267: PPUSH
79268: LD_INT 2
79270: PUSH
79271: LD_INT 30
79273: PUSH
79274: LD_INT 0
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 30
79283: PUSH
79284: LD_INT 1
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: LIST
79295: PPUSH
79296: CALL_OW 72
79300: ST_TO_ADDR
79301: GO 79489
79303: LD_INT 3
79305: DOUBLE
79306: EQUAL
79307: IFTRUE 79311
79309: GO 79357
79311: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79312: LD_ADDR_VAR 0 8
79316: PUSH
79317: LD_VAR 0 2
79321: PPUSH
79322: LD_INT 2
79324: PUSH
79325: LD_INT 30
79327: PUSH
79328: LD_INT 2
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 30
79337: PUSH
79338: LD_INT 3
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: LIST
79349: PPUSH
79350: CALL_OW 72
79354: ST_TO_ADDR
79355: GO 79489
79357: LD_INT 4
79359: DOUBLE
79360: EQUAL
79361: IFTRUE 79365
79363: GO 79422
79365: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79366: LD_ADDR_VAR 0 8
79370: PUSH
79371: LD_VAR 0 2
79375: PPUSH
79376: LD_INT 2
79378: PUSH
79379: LD_INT 30
79381: PUSH
79382: LD_INT 6
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 30
79391: PUSH
79392: LD_INT 7
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 30
79401: PUSH
79402: LD_INT 8
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: PPUSH
79415: CALL_OW 72
79419: ST_TO_ADDR
79420: GO 79489
79422: LD_INT 5
79424: DOUBLE
79425: EQUAL
79426: IFTRUE 79442
79428: LD_INT 8
79430: DOUBLE
79431: EQUAL
79432: IFTRUE 79442
79434: LD_INT 9
79436: DOUBLE
79437: EQUAL
79438: IFTRUE 79442
79440: GO 79488
79442: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79443: LD_ADDR_VAR 0 8
79447: PUSH
79448: LD_VAR 0 2
79452: PPUSH
79453: LD_INT 2
79455: PUSH
79456: LD_INT 30
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 30
79468: PUSH
79469: LD_INT 5
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: LIST
79480: PPUSH
79481: CALL_OW 72
79485: ST_TO_ADDR
79486: GO 79489
79488: POP
// if not tmp then
79489: LD_VAR 0 8
79493: NOT
79494: IFFALSE 79498
// exit ;
79496: GO 80000
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79498: LD_VAR 0 4
79502: PUSH
79503: LD_INT 1
79505: PUSH
79506: LD_INT 15
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: IN
79513: PUSH
79514: LD_EXP 70
79518: PUSH
79519: LD_VAR 0 1
79523: ARRAY
79524: AND
79525: IFFALSE 79681
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79527: LD_ADDR_VAR 0 9
79531: PUSH
79532: LD_EXP 70
79536: PUSH
79537: LD_VAR 0 1
79541: ARRAY
79542: PUSH
79543: LD_INT 1
79545: ARRAY
79546: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79547: LD_VAR 0 9
79551: PUSH
79552: LD_EXP 71
79556: PUSH
79557: LD_VAR 0 1
79561: ARRAY
79562: IN
79563: NOT
79564: IFFALSE 79679
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79566: LD_ADDR_EXP 71
79570: PUSH
79571: LD_EXP 71
79575: PPUSH
79576: LD_VAR 0 1
79580: PUSH
79581: LD_EXP 71
79585: PUSH
79586: LD_VAR 0 1
79590: ARRAY
79591: PUSH
79592: LD_INT 1
79594: PLUS
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PPUSH
79600: LD_VAR 0 9
79604: PPUSH
79605: CALL 20070 0 3
79609: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79610: LD_ADDR_EXP 70
79614: PUSH
79615: LD_EXP 70
79619: PPUSH
79620: LD_VAR 0 1
79624: PPUSH
79625: LD_EXP 70
79629: PUSH
79630: LD_VAR 0 1
79634: ARRAY
79635: PUSH
79636: LD_VAR 0 9
79640: DIFF
79641: PPUSH
79642: CALL_OW 1
79646: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79647: LD_VAR 0 3
79651: PPUSH
79652: LD_EXP 71
79656: PUSH
79657: LD_VAR 0 1
79661: ARRAY
79662: PUSH
79663: LD_EXP 71
79667: PUSH
79668: LD_VAR 0 1
79672: ARRAY
79673: ARRAY
79674: PPUSH
79675: CALL_OW 120
// end ; exit ;
79679: GO 80000
// end ; if tmp > 1 then
79681: LD_VAR 0 8
79685: PUSH
79686: LD_INT 1
79688: GREATER
79689: IFFALSE 79793
// for i = 2 to tmp do
79691: LD_ADDR_VAR 0 6
79695: PUSH
79696: DOUBLE
79697: LD_INT 2
79699: DEC
79700: ST_TO_ADDR
79701: LD_VAR 0 8
79705: PUSH
79706: FOR_TO
79707: IFFALSE 79791
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79709: LD_VAR 0 8
79713: PUSH
79714: LD_VAR 0 6
79718: ARRAY
79719: PPUSH
79720: CALL_OW 461
79724: PUSH
79725: LD_INT 6
79727: EQUAL
79728: IFFALSE 79789
// begin x := tmp [ i ] ;
79730: LD_ADDR_VAR 0 9
79734: PUSH
79735: LD_VAR 0 8
79739: PUSH
79740: LD_VAR 0 6
79744: ARRAY
79745: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79746: LD_ADDR_VAR 0 8
79750: PUSH
79751: LD_VAR 0 8
79755: PPUSH
79756: LD_VAR 0 6
79760: PPUSH
79761: CALL_OW 3
79765: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79766: LD_ADDR_VAR 0 8
79770: PUSH
79771: LD_VAR 0 8
79775: PPUSH
79776: LD_INT 1
79778: PPUSH
79779: LD_VAR 0 9
79783: PPUSH
79784: CALL_OW 2
79788: ST_TO_ADDR
// end ;
79789: GO 79706
79791: POP
79792: POP
// for i in tmp do
79793: LD_ADDR_VAR 0 6
79797: PUSH
79798: LD_VAR 0 8
79802: PUSH
79803: FOR_IN
79804: IFFALSE 79873
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79806: LD_VAR 0 6
79810: PPUSH
79811: CALL_OW 313
79815: PUSH
79816: LD_INT 6
79818: LESS
79819: PUSH
79820: LD_VAR 0 6
79824: PPUSH
79825: CALL_OW 266
79829: PUSH
79830: LD_INT 31
79832: PUSH
79833: LD_INT 32
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: IN
79840: NOT
79841: AND
79842: PUSH
79843: LD_VAR 0 6
79847: PPUSH
79848: CALL_OW 313
79852: PUSH
79853: LD_INT 0
79855: EQUAL
79856: OR
79857: IFFALSE 79871
// begin j := i ;
79859: LD_ADDR_VAR 0 7
79863: PUSH
79864: LD_VAR 0 6
79868: ST_TO_ADDR
// break ;
79869: GO 79873
// end ; end ;
79871: GO 79803
79873: POP
79874: POP
// if j then
79875: LD_VAR 0 7
79879: IFFALSE 79897
// ComEnterUnit ( unit , j ) else
79881: LD_VAR 0 3
79885: PPUSH
79886: LD_VAR 0 7
79890: PPUSH
79891: CALL_OW 120
79895: GO 80000
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79897: LD_ADDR_VAR 0 10
79901: PUSH
79902: LD_VAR 0 2
79906: PPUSH
79907: LD_INT 2
79909: PUSH
79910: LD_INT 30
79912: PUSH
79913: LD_INT 0
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 30
79922: PUSH
79923: LD_INT 1
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: LIST
79934: PPUSH
79935: CALL_OW 72
79939: ST_TO_ADDR
// if depot then
79940: LD_VAR 0 10
79944: IFFALSE 80000
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79946: LD_ADDR_VAR 0 10
79950: PUSH
79951: LD_VAR 0 10
79955: PPUSH
79956: LD_VAR 0 3
79960: PPUSH
79961: CALL_OW 74
79965: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79966: LD_VAR 0 3
79970: PPUSH
79971: LD_VAR 0 10
79975: PPUSH
79976: CALL_OW 296
79980: PUSH
79981: LD_INT 10
79983: GREATER
79984: IFFALSE 80000
// ComStandNearbyBuilding ( unit , depot ) ;
79986: LD_VAR 0 3
79990: PPUSH
79991: LD_VAR 0 10
79995: PPUSH
79996: CALL 16497 0 2
// end ; end ; end ;
80000: LD_VAR 0 5
80004: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80005: LD_INT 0
80007: PPUSH
80008: PPUSH
80009: PPUSH
80010: PPUSH
// if not mc_bases then
80011: LD_EXP 61
80015: NOT
80016: IFFALSE 80020
// exit ;
80018: GO 80259
// for i = 1 to mc_bases do
80020: LD_ADDR_VAR 0 2
80024: PUSH
80025: DOUBLE
80026: LD_INT 1
80028: DEC
80029: ST_TO_ADDR
80030: LD_EXP 61
80034: PUSH
80035: FOR_TO
80036: IFFALSE 80257
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80038: LD_ADDR_VAR 0 4
80042: PUSH
80043: LD_EXP 61
80047: PUSH
80048: LD_VAR 0 2
80052: ARRAY
80053: PPUSH
80054: LD_INT 21
80056: PUSH
80057: LD_INT 1
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PPUSH
80064: CALL_OW 72
80068: PUSH
80069: LD_EXP 90
80073: PUSH
80074: LD_VAR 0 2
80078: ARRAY
80079: UNION
80080: ST_TO_ADDR
// if not tmp then
80081: LD_VAR 0 4
80085: NOT
80086: IFFALSE 80090
// continue ;
80088: GO 80035
// for j in tmp do
80090: LD_ADDR_VAR 0 3
80094: PUSH
80095: LD_VAR 0 4
80099: PUSH
80100: FOR_IN
80101: IFFALSE 80253
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80103: LD_VAR 0 3
80107: PPUSH
80108: CALL_OW 110
80112: NOT
80113: PUSH
80114: LD_VAR 0 3
80118: PPUSH
80119: CALL_OW 314
80123: NOT
80124: AND
80125: PUSH
80126: LD_VAR 0 3
80130: PPUSH
80131: CALL_OW 311
80135: NOT
80136: AND
80137: PUSH
80138: LD_VAR 0 3
80142: PPUSH
80143: CALL_OW 310
80147: NOT
80148: AND
80149: PUSH
80150: LD_VAR 0 3
80154: PUSH
80155: LD_EXP 64
80159: PUSH
80160: LD_VAR 0 2
80164: ARRAY
80165: PUSH
80166: LD_INT 1
80168: ARRAY
80169: IN
80170: NOT
80171: AND
80172: PUSH
80173: LD_VAR 0 3
80177: PUSH
80178: LD_EXP 64
80182: PUSH
80183: LD_VAR 0 2
80187: ARRAY
80188: PUSH
80189: LD_INT 2
80191: ARRAY
80192: IN
80193: NOT
80194: AND
80195: PUSH
80196: LD_VAR 0 3
80200: PUSH
80201: LD_EXP 73
80205: PUSH
80206: LD_VAR 0 2
80210: ARRAY
80211: IN
80212: NOT
80213: AND
80214: IFFALSE 80251
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80216: LD_VAR 0 2
80220: PPUSH
80221: LD_EXP 61
80225: PUSH
80226: LD_VAR 0 2
80230: ARRAY
80231: PPUSH
80232: LD_VAR 0 3
80236: PPUSH
80237: LD_VAR 0 3
80241: PPUSH
80242: CALL_OW 257
80246: PPUSH
80247: CALL 79023 0 4
// end ;
80251: GO 80100
80253: POP
80254: POP
// end ;
80255: GO 80035
80257: POP
80258: POP
// end ;
80259: LD_VAR 0 1
80263: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80264: LD_INT 0
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
// if not mc_bases [ base ] then
80272: LD_EXP 61
80276: PUSH
80277: LD_VAR 0 1
80281: ARRAY
80282: NOT
80283: IFFALSE 80287
// exit ;
80285: GO 80469
// tmp := [ ] ;
80287: LD_ADDR_VAR 0 6
80291: PUSH
80292: EMPTY
80293: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80294: LD_ADDR_VAR 0 7
80298: PUSH
80299: LD_VAR 0 3
80303: PPUSH
80304: LD_INT 0
80306: PPUSH
80307: CALL_OW 517
80311: ST_TO_ADDR
// if not list then
80312: LD_VAR 0 7
80316: NOT
80317: IFFALSE 80321
// exit ;
80319: GO 80469
// for i = 1 to amount do
80321: LD_ADDR_VAR 0 5
80325: PUSH
80326: DOUBLE
80327: LD_INT 1
80329: DEC
80330: ST_TO_ADDR
80331: LD_VAR 0 2
80335: PUSH
80336: FOR_TO
80337: IFFALSE 80417
// begin x := rand ( 1 , list [ 1 ] ) ;
80339: LD_ADDR_VAR 0 8
80343: PUSH
80344: LD_INT 1
80346: PPUSH
80347: LD_VAR 0 7
80351: PUSH
80352: LD_INT 1
80354: ARRAY
80355: PPUSH
80356: CALL_OW 12
80360: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80361: LD_ADDR_VAR 0 6
80365: PUSH
80366: LD_VAR 0 6
80370: PPUSH
80371: LD_VAR 0 5
80375: PPUSH
80376: LD_VAR 0 7
80380: PUSH
80381: LD_INT 1
80383: ARRAY
80384: PUSH
80385: LD_VAR 0 8
80389: ARRAY
80390: PUSH
80391: LD_VAR 0 7
80395: PUSH
80396: LD_INT 2
80398: ARRAY
80399: PUSH
80400: LD_VAR 0 8
80404: ARRAY
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PPUSH
80410: CALL_OW 1
80414: ST_TO_ADDR
// end ;
80415: GO 80336
80417: POP
80418: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80419: LD_ADDR_EXP 74
80423: PUSH
80424: LD_EXP 74
80428: PPUSH
80429: LD_VAR 0 1
80433: PPUSH
80434: LD_VAR 0 6
80438: PPUSH
80439: CALL_OW 1
80443: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80444: LD_ADDR_EXP 76
80448: PUSH
80449: LD_EXP 76
80453: PPUSH
80454: LD_VAR 0 1
80458: PPUSH
80459: LD_VAR 0 3
80463: PPUSH
80464: CALL_OW 1
80468: ST_TO_ADDR
// end ;
80469: LD_VAR 0 4
80473: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80474: LD_INT 0
80476: PPUSH
// if not mc_bases [ base ] then
80477: LD_EXP 61
80481: PUSH
80482: LD_VAR 0 1
80486: ARRAY
80487: NOT
80488: IFFALSE 80492
// exit ;
80490: GO 80517
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80492: LD_ADDR_EXP 66
80496: PUSH
80497: LD_EXP 66
80501: PPUSH
80502: LD_VAR 0 1
80506: PPUSH
80507: LD_VAR 0 2
80511: PPUSH
80512: CALL_OW 1
80516: ST_TO_ADDR
// end ;
80517: LD_VAR 0 3
80521: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80522: LD_INT 0
80524: PPUSH
// if not mc_bases [ base ] then
80525: LD_EXP 61
80529: PUSH
80530: LD_VAR 0 1
80534: ARRAY
80535: NOT
80536: IFFALSE 80540
// exit ;
80538: GO 80577
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80540: LD_ADDR_EXP 66
80544: PUSH
80545: LD_EXP 66
80549: PPUSH
80550: LD_VAR 0 1
80554: PPUSH
80555: LD_EXP 66
80559: PUSH
80560: LD_VAR 0 1
80564: ARRAY
80565: PUSH
80566: LD_VAR 0 2
80570: UNION
80571: PPUSH
80572: CALL_OW 1
80576: ST_TO_ADDR
// end ;
80577: LD_VAR 0 3
80581: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80582: LD_INT 0
80584: PPUSH
// if not mc_bases [ base ] then
80585: LD_EXP 61
80589: PUSH
80590: LD_VAR 0 1
80594: ARRAY
80595: NOT
80596: IFFALSE 80600
// exit ;
80598: GO 80625
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80600: LD_ADDR_EXP 82
80604: PUSH
80605: LD_EXP 82
80609: PPUSH
80610: LD_VAR 0 1
80614: PPUSH
80615: LD_VAR 0 2
80619: PPUSH
80620: CALL_OW 1
80624: ST_TO_ADDR
// end ;
80625: LD_VAR 0 3
80629: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80630: LD_INT 0
80632: PPUSH
// if not mc_bases [ base ] then
80633: LD_EXP 61
80637: PUSH
80638: LD_VAR 0 1
80642: ARRAY
80643: NOT
80644: IFFALSE 80648
// exit ;
80646: GO 80685
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80648: LD_ADDR_EXP 82
80652: PUSH
80653: LD_EXP 82
80657: PPUSH
80658: LD_VAR 0 1
80662: PPUSH
80663: LD_EXP 82
80667: PUSH
80668: LD_VAR 0 1
80672: ARRAY
80673: PUSH
80674: LD_VAR 0 2
80678: ADD
80679: PPUSH
80680: CALL_OW 1
80684: ST_TO_ADDR
// end ;
80685: LD_VAR 0 3
80689: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80690: LD_INT 0
80692: PPUSH
// if not mc_bases [ base ] then
80693: LD_EXP 61
80697: PUSH
80698: LD_VAR 0 1
80702: ARRAY
80703: NOT
80704: IFFALSE 80708
// exit ;
80706: GO 80762
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80708: LD_ADDR_EXP 83
80712: PUSH
80713: LD_EXP 83
80717: PPUSH
80718: LD_VAR 0 1
80722: PPUSH
80723: LD_VAR 0 2
80727: PPUSH
80728: CALL_OW 1
80732: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80733: LD_ADDR_EXP 72
80737: PUSH
80738: LD_EXP 72
80742: PPUSH
80743: LD_VAR 0 1
80747: PPUSH
80748: LD_VAR 0 2
80752: PUSH
80753: LD_INT 0
80755: PLUS
80756: PPUSH
80757: CALL_OW 1
80761: ST_TO_ADDR
// end ;
80762: LD_VAR 0 3
80766: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80767: LD_INT 0
80769: PPUSH
// if not mc_bases [ base ] then
80770: LD_EXP 61
80774: PUSH
80775: LD_VAR 0 1
80779: ARRAY
80780: NOT
80781: IFFALSE 80785
// exit ;
80783: GO 80810
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80785: LD_ADDR_EXP 72
80789: PUSH
80790: LD_EXP 72
80794: PPUSH
80795: LD_VAR 0 1
80799: PPUSH
80800: LD_VAR 0 2
80804: PPUSH
80805: CALL_OW 1
80809: ST_TO_ADDR
// end ;
80810: LD_VAR 0 3
80814: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80815: LD_INT 0
80817: PPUSH
80818: PPUSH
80819: PPUSH
80820: PPUSH
// if not mc_bases [ base ] then
80821: LD_EXP 61
80825: PUSH
80826: LD_VAR 0 1
80830: ARRAY
80831: NOT
80832: IFFALSE 80836
// exit ;
80834: GO 80901
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80836: LD_ADDR_EXP 81
80840: PUSH
80841: LD_EXP 81
80845: PPUSH
80846: LD_VAR 0 1
80850: PUSH
80851: LD_EXP 81
80855: PUSH
80856: LD_VAR 0 1
80860: ARRAY
80861: PUSH
80862: LD_INT 1
80864: PLUS
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PPUSH
80870: LD_VAR 0 1
80874: PUSH
80875: LD_VAR 0 2
80879: PUSH
80880: LD_VAR 0 3
80884: PUSH
80885: LD_VAR 0 4
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: PPUSH
80896: CALL 20070 0 3
80900: ST_TO_ADDR
// end ;
80901: LD_VAR 0 5
80905: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80906: LD_INT 0
80908: PPUSH
// if not mc_bases [ base ] then
80909: LD_EXP 61
80913: PUSH
80914: LD_VAR 0 1
80918: ARRAY
80919: NOT
80920: IFFALSE 80924
// exit ;
80922: GO 80949
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80924: LD_ADDR_EXP 98
80928: PUSH
80929: LD_EXP 98
80933: PPUSH
80934: LD_VAR 0 1
80938: PPUSH
80939: LD_VAR 0 2
80943: PPUSH
80944: CALL_OW 1
80948: ST_TO_ADDR
// end ;
80949: LD_VAR 0 3
80953: RET
// export function MC_GetMinesField ( base ) ; begin
80954: LD_INT 0
80956: PPUSH
// result := mc_mines [ base ] ;
80957: LD_ADDR_VAR 0 2
80961: PUSH
80962: LD_EXP 74
80966: PUSH
80967: LD_VAR 0 1
80971: ARRAY
80972: ST_TO_ADDR
// end ;
80973: LD_VAR 0 2
80977: RET
// export function MC_GetProduceList ( base ) ; begin
80978: LD_INT 0
80980: PPUSH
// result := mc_produce [ base ] ;
80981: LD_ADDR_VAR 0 2
80985: PUSH
80986: LD_EXP 82
80990: PUSH
80991: LD_VAR 0 1
80995: ARRAY
80996: ST_TO_ADDR
// end ;
80997: LD_VAR 0 2
81001: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81002: LD_INT 0
81004: PPUSH
81005: PPUSH
// if not mc_bases then
81006: LD_EXP 61
81010: NOT
81011: IFFALSE 81015
// exit ;
81013: GO 81080
// if mc_bases [ base ] then
81015: LD_EXP 61
81019: PUSH
81020: LD_VAR 0 1
81024: ARRAY
81025: IFFALSE 81080
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81027: LD_ADDR_VAR 0 3
81031: PUSH
81032: LD_EXP 61
81036: PUSH
81037: LD_VAR 0 1
81041: ARRAY
81042: PPUSH
81043: LD_INT 30
81045: PUSH
81046: LD_VAR 0 2
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PPUSH
81055: CALL_OW 72
81059: ST_TO_ADDR
// if result then
81060: LD_VAR 0 3
81064: IFFALSE 81080
// result := result [ 1 ] ;
81066: LD_ADDR_VAR 0 3
81070: PUSH
81071: LD_VAR 0 3
81075: PUSH
81076: LD_INT 1
81078: ARRAY
81079: ST_TO_ADDR
// end ; end ;
81080: LD_VAR 0 3
81084: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81085: LD_INT 0
81087: PPUSH
81088: PPUSH
// if not mc_bases then
81089: LD_EXP 61
81093: NOT
81094: IFFALSE 81098
// exit ;
81096: GO 81143
// if mc_bases [ base ] then
81098: LD_EXP 61
81102: PUSH
81103: LD_VAR 0 1
81107: ARRAY
81108: IFFALSE 81143
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81110: LD_ADDR_VAR 0 3
81114: PUSH
81115: LD_EXP 61
81119: PUSH
81120: LD_VAR 0 1
81124: ARRAY
81125: PPUSH
81126: LD_INT 30
81128: PUSH
81129: LD_VAR 0 2
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PPUSH
81138: CALL_OW 72
81142: ST_TO_ADDR
// end ;
81143: LD_VAR 0 3
81147: RET
// export function MC_SetTame ( base , area ) ; begin
81148: LD_INT 0
81150: PPUSH
// if not mc_bases or not base then
81151: LD_EXP 61
81155: NOT
81156: PUSH
81157: LD_VAR 0 1
81161: NOT
81162: OR
81163: IFFALSE 81167
// exit ;
81165: GO 81192
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81167: LD_ADDR_EXP 89
81171: PUSH
81172: LD_EXP 89
81176: PPUSH
81177: LD_VAR 0 1
81181: PPUSH
81182: LD_VAR 0 2
81186: PPUSH
81187: CALL_OW 1
81191: ST_TO_ADDR
// end ;
81192: LD_VAR 0 3
81196: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81197: LD_INT 0
81199: PPUSH
81200: PPUSH
// if not mc_bases or not base then
81201: LD_EXP 61
81205: NOT
81206: PUSH
81207: LD_VAR 0 1
81211: NOT
81212: OR
81213: IFFALSE 81217
// exit ;
81215: GO 81319
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81217: LD_ADDR_VAR 0 4
81221: PUSH
81222: LD_EXP 61
81226: PUSH
81227: LD_VAR 0 1
81231: ARRAY
81232: PPUSH
81233: LD_INT 30
81235: PUSH
81236: LD_VAR 0 2
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PPUSH
81245: CALL_OW 72
81249: ST_TO_ADDR
// if not tmp then
81250: LD_VAR 0 4
81254: NOT
81255: IFFALSE 81259
// exit ;
81257: GO 81319
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81259: LD_ADDR_EXP 93
81263: PUSH
81264: LD_EXP 93
81268: PPUSH
81269: LD_VAR 0 1
81273: PPUSH
81274: LD_EXP 93
81278: PUSH
81279: LD_VAR 0 1
81283: ARRAY
81284: PPUSH
81285: LD_EXP 93
81289: PUSH
81290: LD_VAR 0 1
81294: ARRAY
81295: PUSH
81296: LD_INT 1
81298: PLUS
81299: PPUSH
81300: LD_VAR 0 4
81304: PUSH
81305: LD_INT 1
81307: ARRAY
81308: PPUSH
81309: CALL_OW 2
81313: PPUSH
81314: CALL_OW 1
81318: ST_TO_ADDR
// end ;
81319: LD_VAR 0 3
81323: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81324: LD_INT 0
81326: PPUSH
81327: PPUSH
// if not mc_bases or not base or not kinds then
81328: LD_EXP 61
81332: NOT
81333: PUSH
81334: LD_VAR 0 1
81338: NOT
81339: OR
81340: PUSH
81341: LD_VAR 0 2
81345: NOT
81346: OR
81347: IFFALSE 81351
// exit ;
81349: GO 81412
// for i in kinds do
81351: LD_ADDR_VAR 0 4
81355: PUSH
81356: LD_VAR 0 2
81360: PUSH
81361: FOR_IN
81362: IFFALSE 81410
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81364: LD_ADDR_EXP 95
81368: PUSH
81369: LD_EXP 95
81373: PPUSH
81374: LD_VAR 0 1
81378: PUSH
81379: LD_EXP 95
81383: PUSH
81384: LD_VAR 0 1
81388: ARRAY
81389: PUSH
81390: LD_INT 1
81392: PLUS
81393: PUSH
81394: EMPTY
81395: LIST
81396: LIST
81397: PPUSH
81398: LD_VAR 0 4
81402: PPUSH
81403: CALL 20070 0 3
81407: ST_TO_ADDR
81408: GO 81361
81410: POP
81411: POP
// end ;
81412: LD_VAR 0 3
81416: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81417: LD_INT 0
81419: PPUSH
// if not mc_bases or not base or not areas then
81420: LD_EXP 61
81424: NOT
81425: PUSH
81426: LD_VAR 0 1
81430: NOT
81431: OR
81432: PUSH
81433: LD_VAR 0 2
81437: NOT
81438: OR
81439: IFFALSE 81443
// exit ;
81441: GO 81468
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81443: LD_ADDR_EXP 79
81447: PUSH
81448: LD_EXP 79
81452: PPUSH
81453: LD_VAR 0 1
81457: PPUSH
81458: LD_VAR 0 2
81462: PPUSH
81463: CALL_OW 1
81467: ST_TO_ADDR
// end ;
81468: LD_VAR 0 3
81472: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81473: LD_INT 0
81475: PPUSH
// if not mc_bases or not base or not teleports_exit then
81476: LD_EXP 61
81480: NOT
81481: PUSH
81482: LD_VAR 0 1
81486: NOT
81487: OR
81488: PUSH
81489: LD_VAR 0 2
81493: NOT
81494: OR
81495: IFFALSE 81499
// exit ;
81497: GO 81524
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81499: LD_ADDR_EXP 96
81503: PUSH
81504: LD_EXP 96
81508: PPUSH
81509: LD_VAR 0 1
81513: PPUSH
81514: LD_VAR 0 2
81518: PPUSH
81519: CALL_OW 1
81523: ST_TO_ADDR
// end ;
81524: LD_VAR 0 3
81528: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81529: LD_INT 0
81531: PPUSH
81532: PPUSH
81533: PPUSH
// if not mc_bases or not base or not ext_list then
81534: LD_EXP 61
81538: NOT
81539: PUSH
81540: LD_VAR 0 1
81544: NOT
81545: OR
81546: PUSH
81547: LD_VAR 0 5
81551: NOT
81552: OR
81553: IFFALSE 81557
// exit ;
81555: GO 81730
// tmp := GetFacExtXYD ( x , y , d ) ;
81557: LD_ADDR_VAR 0 8
81561: PUSH
81562: LD_VAR 0 2
81566: PPUSH
81567: LD_VAR 0 3
81571: PPUSH
81572: LD_VAR 0 4
81576: PPUSH
81577: CALL 50047 0 3
81581: ST_TO_ADDR
// if not tmp then
81582: LD_VAR 0 8
81586: NOT
81587: IFFALSE 81591
// exit ;
81589: GO 81730
// for i in tmp do
81591: LD_ADDR_VAR 0 7
81595: PUSH
81596: LD_VAR 0 8
81600: PUSH
81601: FOR_IN
81602: IFFALSE 81728
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81604: LD_ADDR_EXP 66
81608: PUSH
81609: LD_EXP 66
81613: PPUSH
81614: LD_VAR 0 1
81618: PPUSH
81619: LD_EXP 66
81623: PUSH
81624: LD_VAR 0 1
81628: ARRAY
81629: PPUSH
81630: LD_EXP 66
81634: PUSH
81635: LD_VAR 0 1
81639: ARRAY
81640: PUSH
81641: LD_INT 1
81643: PLUS
81644: PPUSH
81645: LD_VAR 0 5
81649: PUSH
81650: LD_INT 1
81652: ARRAY
81653: PUSH
81654: LD_VAR 0 7
81658: PUSH
81659: LD_INT 1
81661: ARRAY
81662: PUSH
81663: LD_VAR 0 7
81667: PUSH
81668: LD_INT 2
81670: ARRAY
81671: PUSH
81672: LD_VAR 0 7
81676: PUSH
81677: LD_INT 3
81679: ARRAY
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: PPUSH
81687: CALL_OW 2
81691: PPUSH
81692: CALL_OW 1
81696: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81697: LD_ADDR_VAR 0 5
81701: PUSH
81702: LD_VAR 0 5
81706: PPUSH
81707: LD_INT 1
81709: PPUSH
81710: CALL_OW 3
81714: ST_TO_ADDR
// if not ext_list then
81715: LD_VAR 0 5
81719: NOT
81720: IFFALSE 81726
// exit ;
81722: POP
81723: POP
81724: GO 81730
// end ;
81726: GO 81601
81728: POP
81729: POP
// end ;
81730: LD_VAR 0 6
81734: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81735: LD_INT 0
81737: PPUSH
// if not mc_bases or not base or not weapon_list then
81738: LD_EXP 61
81742: NOT
81743: PUSH
81744: LD_VAR 0 1
81748: NOT
81749: OR
81750: PUSH
81751: LD_VAR 0 2
81755: NOT
81756: OR
81757: IFFALSE 81761
// exit ;
81759: GO 81786
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81761: LD_ADDR_EXP 100
81765: PUSH
81766: LD_EXP 100
81770: PPUSH
81771: LD_VAR 0 1
81775: PPUSH
81776: LD_VAR 0 2
81780: PPUSH
81781: CALL_OW 1
81785: ST_TO_ADDR
// end ;
81786: LD_VAR 0 3
81790: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81791: LD_INT 0
81793: PPUSH
// if not mc_bases or not base or not tech_list then
81794: LD_EXP 61
81798: NOT
81799: PUSH
81800: LD_VAR 0 1
81804: NOT
81805: OR
81806: PUSH
81807: LD_VAR 0 2
81811: NOT
81812: OR
81813: IFFALSE 81817
// exit ;
81815: GO 81842
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81817: LD_ADDR_EXP 88
81821: PUSH
81822: LD_EXP 88
81826: PPUSH
81827: LD_VAR 0 1
81831: PPUSH
81832: LD_VAR 0 2
81836: PPUSH
81837: CALL_OW 1
81841: ST_TO_ADDR
// end ;
81842: LD_VAR 0 3
81846: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81847: LD_INT 0
81849: PPUSH
// if not mc_bases or not parking_area or not base then
81850: LD_EXP 61
81854: NOT
81855: PUSH
81856: LD_VAR 0 2
81860: NOT
81861: OR
81862: PUSH
81863: LD_VAR 0 1
81867: NOT
81868: OR
81869: IFFALSE 81873
// exit ;
81871: GO 81898
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81873: LD_ADDR_EXP 85
81877: PUSH
81878: LD_EXP 85
81882: PPUSH
81883: LD_VAR 0 1
81887: PPUSH
81888: LD_VAR 0 2
81892: PPUSH
81893: CALL_OW 1
81897: ST_TO_ADDR
// end ;
81898: LD_VAR 0 3
81902: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81903: LD_INT 0
81905: PPUSH
// if not mc_bases or not base or not scan_area then
81906: LD_EXP 61
81910: NOT
81911: PUSH
81912: LD_VAR 0 1
81916: NOT
81917: OR
81918: PUSH
81919: LD_VAR 0 2
81923: NOT
81924: OR
81925: IFFALSE 81929
// exit ;
81927: GO 81954
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81929: LD_ADDR_EXP 86
81933: PUSH
81934: LD_EXP 86
81938: PPUSH
81939: LD_VAR 0 1
81943: PPUSH
81944: LD_VAR 0 2
81948: PPUSH
81949: CALL_OW 1
81953: ST_TO_ADDR
// end ;
81954: LD_VAR 0 3
81958: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81959: LD_INT 0
81961: PPUSH
81962: PPUSH
// if not mc_bases or not base then
81963: LD_EXP 61
81967: NOT
81968: PUSH
81969: LD_VAR 0 1
81973: NOT
81974: OR
81975: IFFALSE 81979
// exit ;
81977: GO 82043
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81979: LD_ADDR_VAR 0 3
81983: PUSH
81984: LD_INT 1
81986: PUSH
81987: LD_INT 2
81989: PUSH
81990: LD_INT 3
81992: PUSH
81993: LD_INT 4
81995: PUSH
81996: LD_INT 11
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82006: LD_ADDR_EXP 88
82010: PUSH
82011: LD_EXP 88
82015: PPUSH
82016: LD_VAR 0 1
82020: PPUSH
82021: LD_EXP 88
82025: PUSH
82026: LD_VAR 0 1
82030: ARRAY
82031: PUSH
82032: LD_VAR 0 3
82036: DIFF
82037: PPUSH
82038: CALL_OW 1
82042: ST_TO_ADDR
// end ;
82043: LD_VAR 0 2
82047: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82048: LD_INT 0
82050: PPUSH
// result := mc_vehicles [ base ] ;
82051: LD_ADDR_VAR 0 3
82055: PUSH
82056: LD_EXP 80
82060: PUSH
82061: LD_VAR 0 1
82065: ARRAY
82066: ST_TO_ADDR
// if onlyCombat then
82067: LD_VAR 0 2
82071: IFFALSE 82243
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82073: LD_ADDR_VAR 0 3
82077: PUSH
82078: LD_VAR 0 3
82082: PUSH
82083: LD_VAR 0 3
82087: PPUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 34
82093: PUSH
82094: LD_INT 12
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 34
82103: PUSH
82104: LD_INT 51
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 34
82113: PUSH
82114: LD_INT 89
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 34
82123: PUSH
82124: LD_INT 32
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 34
82133: PUSH
82134: LD_INT 13
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 34
82143: PUSH
82144: LD_INT 52
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 34
82153: PUSH
82154: LD_INT 88
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 34
82163: PUSH
82164: LD_INT 14
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 34
82173: PUSH
82174: LD_INT 53
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: PUSH
82181: LD_INT 34
82183: PUSH
82184: LD_INT 98
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: LD_INT 34
82193: PUSH
82194: LD_INT 31
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 34
82203: PUSH
82204: LD_INT 48
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 34
82213: PUSH
82214: LD_INT 8
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: PPUSH
82237: CALL_OW 72
82241: DIFF
82242: ST_TO_ADDR
// end ; end_of_file
82243: LD_VAR 0 3
82247: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82248: LD_INT 0
82250: PPUSH
82251: PPUSH
82252: PPUSH
// if not mc_bases or not skirmish then
82253: LD_EXP 61
82257: NOT
82258: PUSH
82259: LD_EXP 59
82263: NOT
82264: OR
82265: IFFALSE 82269
// exit ;
82267: GO 82434
// for i = 1 to mc_bases do
82269: LD_ADDR_VAR 0 4
82273: PUSH
82274: DOUBLE
82275: LD_INT 1
82277: DEC
82278: ST_TO_ADDR
82279: LD_EXP 61
82283: PUSH
82284: FOR_TO
82285: IFFALSE 82432
// begin if sci in mc_bases [ i ] then
82287: LD_VAR 0 2
82291: PUSH
82292: LD_EXP 61
82296: PUSH
82297: LD_VAR 0 4
82301: ARRAY
82302: IN
82303: IFFALSE 82430
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82305: LD_ADDR_EXP 90
82309: PUSH
82310: LD_EXP 90
82314: PPUSH
82315: LD_VAR 0 4
82319: PUSH
82320: LD_EXP 90
82324: PUSH
82325: LD_VAR 0 4
82329: ARRAY
82330: PUSH
82331: LD_INT 1
82333: PLUS
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PPUSH
82339: LD_VAR 0 1
82343: PPUSH
82344: CALL 20070 0 3
82348: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82349: LD_ADDR_VAR 0 5
82353: PUSH
82354: LD_EXP 61
82358: PUSH
82359: LD_VAR 0 4
82363: ARRAY
82364: PPUSH
82365: LD_INT 2
82367: PUSH
82368: LD_INT 30
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 30
82380: PUSH
82381: LD_INT 1
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: LIST
82392: PPUSH
82393: CALL_OW 72
82397: PPUSH
82398: LD_VAR 0 1
82402: PPUSH
82403: CALL_OW 74
82407: ST_TO_ADDR
// if tmp then
82408: LD_VAR 0 5
82412: IFFALSE 82428
// ComStandNearbyBuilding ( ape , tmp ) ;
82414: LD_VAR 0 1
82418: PPUSH
82419: LD_VAR 0 5
82423: PPUSH
82424: CALL 16497 0 2
// break ;
82428: GO 82432
// end ; end ;
82430: GO 82284
82432: POP
82433: POP
// end ;
82434: LD_VAR 0 3
82438: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82439: LD_INT 0
82441: PPUSH
82442: PPUSH
82443: PPUSH
// if not mc_bases or not skirmish then
82444: LD_EXP 61
82448: NOT
82449: PUSH
82450: LD_EXP 59
82454: NOT
82455: OR
82456: IFFALSE 82460
// exit ;
82458: GO 82549
// for i = 1 to mc_bases do
82460: LD_ADDR_VAR 0 4
82464: PUSH
82465: DOUBLE
82466: LD_INT 1
82468: DEC
82469: ST_TO_ADDR
82470: LD_EXP 61
82474: PUSH
82475: FOR_TO
82476: IFFALSE 82547
// begin if building in mc_busy_turret_list [ i ] then
82478: LD_VAR 0 1
82482: PUSH
82483: LD_EXP 71
82487: PUSH
82488: LD_VAR 0 4
82492: ARRAY
82493: IN
82494: IFFALSE 82545
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82496: LD_ADDR_VAR 0 5
82500: PUSH
82501: LD_EXP 71
82505: PUSH
82506: LD_VAR 0 4
82510: ARRAY
82511: PUSH
82512: LD_VAR 0 1
82516: DIFF
82517: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82518: LD_ADDR_EXP 71
82522: PUSH
82523: LD_EXP 71
82527: PPUSH
82528: LD_VAR 0 4
82532: PPUSH
82533: LD_VAR 0 5
82537: PPUSH
82538: CALL_OW 1
82542: ST_TO_ADDR
// break ;
82543: GO 82547
// end ; end ;
82545: GO 82475
82547: POP
82548: POP
// end ;
82549: LD_VAR 0 3
82553: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82554: LD_INT 0
82556: PPUSH
82557: PPUSH
82558: PPUSH
// if not mc_bases or not skirmish then
82559: LD_EXP 61
82563: NOT
82564: PUSH
82565: LD_EXP 59
82569: NOT
82570: OR
82571: IFFALSE 82575
// exit ;
82573: GO 82774
// for i = 1 to mc_bases do
82575: LD_ADDR_VAR 0 5
82579: PUSH
82580: DOUBLE
82581: LD_INT 1
82583: DEC
82584: ST_TO_ADDR
82585: LD_EXP 61
82589: PUSH
82590: FOR_TO
82591: IFFALSE 82772
// if building in mc_bases [ i ] then
82593: LD_VAR 0 1
82597: PUSH
82598: LD_EXP 61
82602: PUSH
82603: LD_VAR 0 5
82607: ARRAY
82608: IN
82609: IFFALSE 82770
// begin tmp := mc_bases [ i ] diff building ;
82611: LD_ADDR_VAR 0 6
82615: PUSH
82616: LD_EXP 61
82620: PUSH
82621: LD_VAR 0 5
82625: ARRAY
82626: PUSH
82627: LD_VAR 0 1
82631: DIFF
82632: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82633: LD_ADDR_EXP 61
82637: PUSH
82638: LD_EXP 61
82642: PPUSH
82643: LD_VAR 0 5
82647: PPUSH
82648: LD_VAR 0 6
82652: PPUSH
82653: CALL_OW 1
82657: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82658: LD_VAR 0 1
82662: PUSH
82663: LD_EXP 69
82667: PUSH
82668: LD_VAR 0 5
82672: ARRAY
82673: IN
82674: IFFALSE 82713
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82676: LD_ADDR_EXP 69
82680: PUSH
82681: LD_EXP 69
82685: PPUSH
82686: LD_VAR 0 5
82690: PPUSH
82691: LD_EXP 69
82695: PUSH
82696: LD_VAR 0 5
82700: ARRAY
82701: PUSH
82702: LD_VAR 0 1
82706: DIFF
82707: PPUSH
82708: CALL_OW 1
82712: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82713: LD_VAR 0 1
82717: PUSH
82718: LD_EXP 70
82722: PUSH
82723: LD_VAR 0 5
82727: ARRAY
82728: IN
82729: IFFALSE 82768
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82731: LD_ADDR_EXP 70
82735: PUSH
82736: LD_EXP 70
82740: PPUSH
82741: LD_VAR 0 5
82745: PPUSH
82746: LD_EXP 70
82750: PUSH
82751: LD_VAR 0 5
82755: ARRAY
82756: PUSH
82757: LD_VAR 0 1
82761: DIFF
82762: PPUSH
82763: CALL_OW 1
82767: ST_TO_ADDR
// break ;
82768: GO 82772
// end ;
82770: GO 82590
82772: POP
82773: POP
// end ;
82774: LD_VAR 0 4
82778: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82779: LD_INT 0
82781: PPUSH
82782: PPUSH
82783: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82784: LD_EXP 61
82788: NOT
82789: PUSH
82790: LD_EXP 59
82794: NOT
82795: OR
82796: PUSH
82797: LD_VAR 0 3
82801: PUSH
82802: LD_EXP 87
82806: IN
82807: NOT
82808: OR
82809: IFFALSE 82813
// exit ;
82811: GO 82936
// for i = 1 to mc_vehicles do
82813: LD_ADDR_VAR 0 6
82817: PUSH
82818: DOUBLE
82819: LD_INT 1
82821: DEC
82822: ST_TO_ADDR
82823: LD_EXP 80
82827: PUSH
82828: FOR_TO
82829: IFFALSE 82934
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82831: LD_VAR 0 2
82835: PUSH
82836: LD_EXP 80
82840: PUSH
82841: LD_VAR 0 6
82845: ARRAY
82846: IN
82847: PUSH
82848: LD_VAR 0 1
82852: PUSH
82853: LD_EXP 80
82857: PUSH
82858: LD_VAR 0 6
82862: ARRAY
82863: IN
82864: OR
82865: IFFALSE 82932
// begin tmp := mc_vehicles [ i ] diff old ;
82867: LD_ADDR_VAR 0 7
82871: PUSH
82872: LD_EXP 80
82876: PUSH
82877: LD_VAR 0 6
82881: ARRAY
82882: PUSH
82883: LD_VAR 0 2
82887: DIFF
82888: ST_TO_ADDR
// tmp := tmp diff new ;
82889: LD_ADDR_VAR 0 7
82893: PUSH
82894: LD_VAR 0 7
82898: PUSH
82899: LD_VAR 0 1
82903: DIFF
82904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82905: LD_ADDR_EXP 80
82909: PUSH
82910: LD_EXP 80
82914: PPUSH
82915: LD_VAR 0 6
82919: PPUSH
82920: LD_VAR 0 7
82924: PPUSH
82925: CALL_OW 1
82929: ST_TO_ADDR
// break ;
82930: GO 82934
// end ;
82932: GO 82828
82934: POP
82935: POP
// end ;
82936: LD_VAR 0 5
82940: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82941: LD_INT 0
82943: PPUSH
82944: PPUSH
82945: PPUSH
82946: PPUSH
// if not mc_bases or not skirmish then
82947: LD_EXP 61
82951: NOT
82952: PUSH
82953: LD_EXP 59
82957: NOT
82958: OR
82959: IFFALSE 82963
// exit ;
82961: GO 83345
// side := GetSide ( vehicle ) ;
82963: LD_ADDR_VAR 0 5
82967: PUSH
82968: LD_VAR 0 1
82972: PPUSH
82973: CALL_OW 255
82977: ST_TO_ADDR
// for i = 1 to mc_bases do
82978: LD_ADDR_VAR 0 4
82982: PUSH
82983: DOUBLE
82984: LD_INT 1
82986: DEC
82987: ST_TO_ADDR
82988: LD_EXP 61
82992: PUSH
82993: FOR_TO
82994: IFFALSE 83343
// begin if factory in mc_bases [ i ] then
82996: LD_VAR 0 2
83000: PUSH
83001: LD_EXP 61
83005: PUSH
83006: LD_VAR 0 4
83010: ARRAY
83011: IN
83012: IFFALSE 83341
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
83014: LD_EXP 83
83018: PUSH
83019: LD_VAR 0 4
83023: ARRAY
83024: PUSH
83025: LD_EXP 72
83029: PUSH
83030: LD_VAR 0 4
83034: ARRAY
83035: LESS
83036: PUSH
83037: LD_VAR 0 1
83041: PPUSH
83042: CALL_OW 264
83046: PUSH
83047: LD_INT 31
83049: PUSH
83050: LD_INT 32
83052: PUSH
83053: LD_INT 51
83055: PUSH
83056: LD_INT 89
83058: PUSH
83059: LD_INT 12
83061: PUSH
83062: LD_INT 30
83064: PUSH
83065: LD_INT 98
83067: PUSH
83068: LD_INT 11
83070: PUSH
83071: LD_INT 53
83073: PUSH
83074: LD_INT 14
83076: PUSH
83077: LD_INT 91
83079: PUSH
83080: LD_INT 29
83082: PUSH
83083: LD_INT 99
83085: PUSH
83086: LD_INT 13
83088: PUSH
83089: LD_INT 52
83091: PUSH
83092: LD_INT 88
83094: PUSH
83095: LD_INT 48
83097: PUSH
83098: LD_INT 8
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: IN
83121: NOT
83122: AND
83123: IFFALSE 83171
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83125: LD_ADDR_EXP 83
83129: PUSH
83130: LD_EXP 83
83134: PPUSH
83135: LD_VAR 0 4
83139: PUSH
83140: LD_EXP 83
83144: PUSH
83145: LD_VAR 0 4
83149: ARRAY
83150: PUSH
83151: LD_INT 1
83153: PLUS
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PPUSH
83159: LD_VAR 0 1
83163: PPUSH
83164: CALL 20070 0 3
83168: ST_TO_ADDR
83169: GO 83215
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83171: LD_ADDR_EXP 80
83175: PUSH
83176: LD_EXP 80
83180: PPUSH
83181: LD_VAR 0 4
83185: PUSH
83186: LD_EXP 80
83190: PUSH
83191: LD_VAR 0 4
83195: ARRAY
83196: PUSH
83197: LD_INT 1
83199: PLUS
83200: PUSH
83201: EMPTY
83202: LIST
83203: LIST
83204: PPUSH
83205: LD_VAR 0 1
83209: PPUSH
83210: CALL 20070 0 3
83214: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83215: LD_VAR 0 1
83219: PPUSH
83220: CALL_OW 263
83224: PUSH
83225: LD_INT 2
83227: EQUAL
83228: IFFALSE 83257
// begin repeat wait ( 0 0$3 ) ;
83230: LD_INT 105
83232: PPUSH
83233: CALL_OW 67
// Connect ( vehicle ) ;
83237: LD_VAR 0 1
83241: PPUSH
83242: CALL 23039 0 1
// until IsControledBy ( vehicle ) ;
83246: LD_VAR 0 1
83250: PPUSH
83251: CALL_OW 312
83255: IFFALSE 83230
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83257: LD_VAR 0 1
83261: PPUSH
83262: LD_EXP 85
83266: PUSH
83267: LD_VAR 0 4
83271: ARRAY
83272: PPUSH
83273: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83277: LD_VAR 0 1
83281: PPUSH
83282: CALL_OW 263
83286: PUSH
83287: LD_INT 1
83289: NONEQUAL
83290: IFFALSE 83294
// break ;
83292: GO 83343
// repeat wait ( 0 0$1 ) ;
83294: LD_INT 35
83296: PPUSH
83297: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83301: LD_VAR 0 1
83305: PPUSH
83306: LD_EXP 85
83310: PUSH
83311: LD_VAR 0 4
83315: ARRAY
83316: PPUSH
83317: CALL_OW 308
83321: IFFALSE 83294
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83323: LD_VAR 0 1
83327: PPUSH
83328: CALL_OW 311
83332: PPUSH
83333: CALL_OW 121
// exit ;
83337: POP
83338: POP
83339: GO 83345
// end ; end ;
83341: GO 82993
83343: POP
83344: POP
// end ;
83345: LD_VAR 0 3
83349: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83350: LD_INT 0
83352: PPUSH
83353: PPUSH
83354: PPUSH
83355: PPUSH
// if not mc_bases or not skirmish then
83356: LD_EXP 61
83360: NOT
83361: PUSH
83362: LD_EXP 59
83366: NOT
83367: OR
83368: IFFALSE 83372
// exit ;
83370: GO 83725
// repeat wait ( 0 0$1 ) ;
83372: LD_INT 35
83374: PPUSH
83375: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83379: LD_VAR 0 2
83383: PPUSH
83384: LD_VAR 0 3
83388: PPUSH
83389: CALL_OW 284
83393: IFFALSE 83372
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83395: LD_VAR 0 2
83399: PPUSH
83400: LD_VAR 0 3
83404: PPUSH
83405: CALL_OW 283
83409: PUSH
83410: LD_INT 4
83412: EQUAL
83413: IFFALSE 83417
// exit ;
83415: GO 83725
// for i = 1 to mc_bases do
83417: LD_ADDR_VAR 0 7
83421: PUSH
83422: DOUBLE
83423: LD_INT 1
83425: DEC
83426: ST_TO_ADDR
83427: LD_EXP 61
83431: PUSH
83432: FOR_TO
83433: IFFALSE 83723
// begin if mc_crates_area [ i ] then
83435: LD_EXP 79
83439: PUSH
83440: LD_VAR 0 7
83444: ARRAY
83445: IFFALSE 83556
// for j in mc_crates_area [ i ] do
83447: LD_ADDR_VAR 0 8
83451: PUSH
83452: LD_EXP 79
83456: PUSH
83457: LD_VAR 0 7
83461: ARRAY
83462: PUSH
83463: FOR_IN
83464: IFFALSE 83554
// if InArea ( x , y , j ) then
83466: LD_VAR 0 2
83470: PPUSH
83471: LD_VAR 0 3
83475: PPUSH
83476: LD_VAR 0 8
83480: PPUSH
83481: CALL_OW 309
83485: IFFALSE 83552
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83487: LD_ADDR_EXP 77
83491: PUSH
83492: LD_EXP 77
83496: PPUSH
83497: LD_VAR 0 7
83501: PUSH
83502: LD_EXP 77
83506: PUSH
83507: LD_VAR 0 7
83511: ARRAY
83512: PUSH
83513: LD_INT 1
83515: PLUS
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PPUSH
83521: LD_VAR 0 4
83525: PUSH
83526: LD_VAR 0 2
83530: PUSH
83531: LD_VAR 0 3
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: LIST
83540: PPUSH
83541: CALL 20070 0 3
83545: ST_TO_ADDR
// exit ;
83546: POP
83547: POP
83548: POP
83549: POP
83550: GO 83725
// end ;
83552: GO 83463
83554: POP
83555: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83556: LD_ADDR_VAR 0 9
83560: PUSH
83561: LD_EXP 61
83565: PUSH
83566: LD_VAR 0 7
83570: ARRAY
83571: PPUSH
83572: LD_INT 2
83574: PUSH
83575: LD_INT 30
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 30
83587: PUSH
83588: LD_INT 1
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: LIST
83599: PPUSH
83600: CALL_OW 72
83604: ST_TO_ADDR
// if not depot then
83605: LD_VAR 0 9
83609: NOT
83610: IFFALSE 83614
// continue ;
83612: GO 83432
// for j in depot do
83614: LD_ADDR_VAR 0 8
83618: PUSH
83619: LD_VAR 0 9
83623: PUSH
83624: FOR_IN
83625: IFFALSE 83719
// if GetDistUnitXY ( j , x , y ) < 30 then
83627: LD_VAR 0 8
83631: PPUSH
83632: LD_VAR 0 2
83636: PPUSH
83637: LD_VAR 0 3
83641: PPUSH
83642: CALL_OW 297
83646: PUSH
83647: LD_INT 30
83649: LESS
83650: IFFALSE 83717
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83652: LD_ADDR_EXP 77
83656: PUSH
83657: LD_EXP 77
83661: PPUSH
83662: LD_VAR 0 7
83666: PUSH
83667: LD_EXP 77
83671: PUSH
83672: LD_VAR 0 7
83676: ARRAY
83677: PUSH
83678: LD_INT 1
83680: PLUS
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PPUSH
83686: LD_VAR 0 4
83690: PUSH
83691: LD_VAR 0 2
83695: PUSH
83696: LD_VAR 0 3
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: LIST
83705: PPUSH
83706: CALL 20070 0 3
83710: ST_TO_ADDR
// exit ;
83711: POP
83712: POP
83713: POP
83714: POP
83715: GO 83725
// end ;
83717: GO 83624
83719: POP
83720: POP
// end ;
83721: GO 83432
83723: POP
83724: POP
// end ;
83725: LD_VAR 0 6
83729: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83730: LD_INT 0
83732: PPUSH
83733: PPUSH
83734: PPUSH
83735: PPUSH
// if not mc_bases or not skirmish then
83736: LD_EXP 61
83740: NOT
83741: PUSH
83742: LD_EXP 59
83746: NOT
83747: OR
83748: IFFALSE 83752
// exit ;
83750: GO 84029
// side := GetSide ( lab ) ;
83752: LD_ADDR_VAR 0 4
83756: PUSH
83757: LD_VAR 0 2
83761: PPUSH
83762: CALL_OW 255
83766: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83767: LD_VAR 0 4
83771: PUSH
83772: LD_EXP 87
83776: IN
83777: NOT
83778: PUSH
83779: LD_EXP 88
83783: NOT
83784: OR
83785: PUSH
83786: LD_EXP 61
83790: NOT
83791: OR
83792: IFFALSE 83796
// exit ;
83794: GO 84029
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83796: LD_ADDR_EXP 88
83800: PUSH
83801: LD_EXP 88
83805: PPUSH
83806: LD_VAR 0 4
83810: PPUSH
83811: LD_EXP 88
83815: PUSH
83816: LD_VAR 0 4
83820: ARRAY
83821: PUSH
83822: LD_VAR 0 1
83826: DIFF
83827: PPUSH
83828: CALL_OW 1
83832: ST_TO_ADDR
// for i = 1 to mc_bases do
83833: LD_ADDR_VAR 0 5
83837: PUSH
83838: DOUBLE
83839: LD_INT 1
83841: DEC
83842: ST_TO_ADDR
83843: LD_EXP 61
83847: PUSH
83848: FOR_TO
83849: IFFALSE 84027
// begin if lab in mc_bases [ i ] then
83851: LD_VAR 0 2
83855: PUSH
83856: LD_EXP 61
83860: PUSH
83861: LD_VAR 0 5
83865: ARRAY
83866: IN
83867: IFFALSE 84025
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83869: LD_VAR 0 1
83873: PUSH
83874: LD_INT 11
83876: PUSH
83877: LD_INT 4
83879: PUSH
83880: LD_INT 3
83882: PUSH
83883: LD_INT 2
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: IN
83892: PUSH
83893: LD_EXP 91
83897: PUSH
83898: LD_VAR 0 5
83902: ARRAY
83903: AND
83904: IFFALSE 84025
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83906: LD_ADDR_VAR 0 6
83910: PUSH
83911: LD_EXP 91
83915: PUSH
83916: LD_VAR 0 5
83920: ARRAY
83921: PUSH
83922: LD_INT 1
83924: ARRAY
83925: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83926: LD_ADDR_EXP 91
83930: PUSH
83931: LD_EXP 91
83935: PPUSH
83936: LD_VAR 0 5
83940: PPUSH
83941: EMPTY
83942: PPUSH
83943: CALL_OW 1
83947: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83948: LD_VAR 0 6
83952: PPUSH
83953: LD_INT 0
83955: PPUSH
83956: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83960: LD_VAR 0 6
83964: PPUSH
83965: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83969: LD_ADDR_EXP 90
83973: PUSH
83974: LD_EXP 90
83978: PPUSH
83979: LD_VAR 0 5
83983: PPUSH
83984: LD_EXP 90
83988: PUSH
83989: LD_VAR 0 5
83993: ARRAY
83994: PPUSH
83995: LD_INT 1
83997: PPUSH
83998: LD_VAR 0 6
84002: PPUSH
84003: CALL_OW 2
84007: PPUSH
84008: CALL_OW 1
84012: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84013: LD_VAR 0 5
84017: PPUSH
84018: LD_INT 112
84020: PPUSH
84021: CALL 60515 0 2
// end ; end ; end ;
84025: GO 83848
84027: POP
84028: POP
// end ;
84029: LD_VAR 0 3
84033: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84034: LD_INT 0
84036: PPUSH
84037: PPUSH
84038: PPUSH
84039: PPUSH
84040: PPUSH
84041: PPUSH
84042: PPUSH
84043: PPUSH
// if not mc_bases or not skirmish then
84044: LD_EXP 61
84048: NOT
84049: PUSH
84050: LD_EXP 59
84054: NOT
84055: OR
84056: IFFALSE 84060
// exit ;
84058: GO 85429
// for i = 1 to mc_bases do
84060: LD_ADDR_VAR 0 3
84064: PUSH
84065: DOUBLE
84066: LD_INT 1
84068: DEC
84069: ST_TO_ADDR
84070: LD_EXP 61
84074: PUSH
84075: FOR_TO
84076: IFFALSE 85427
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84078: LD_VAR 0 1
84082: PUSH
84083: LD_EXP 61
84087: PUSH
84088: LD_VAR 0 3
84092: ARRAY
84093: IN
84094: PUSH
84095: LD_VAR 0 1
84099: PUSH
84100: LD_EXP 68
84104: PUSH
84105: LD_VAR 0 3
84109: ARRAY
84110: IN
84111: OR
84112: PUSH
84113: LD_VAR 0 1
84117: PUSH
84118: LD_EXP 83
84122: PUSH
84123: LD_VAR 0 3
84127: ARRAY
84128: IN
84129: OR
84130: PUSH
84131: LD_VAR 0 1
84135: PUSH
84136: LD_EXP 80
84140: PUSH
84141: LD_VAR 0 3
84145: ARRAY
84146: IN
84147: OR
84148: PUSH
84149: LD_VAR 0 1
84153: PUSH
84154: LD_EXP 90
84158: PUSH
84159: LD_VAR 0 3
84163: ARRAY
84164: IN
84165: OR
84166: PUSH
84167: LD_VAR 0 1
84171: PUSH
84172: LD_EXP 91
84176: PUSH
84177: LD_VAR 0 3
84181: ARRAY
84182: IN
84183: OR
84184: IFFALSE 85425
// begin if un in mc_ape [ i ] then
84186: LD_VAR 0 1
84190: PUSH
84191: LD_EXP 90
84195: PUSH
84196: LD_VAR 0 3
84200: ARRAY
84201: IN
84202: IFFALSE 84241
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84204: LD_ADDR_EXP 90
84208: PUSH
84209: LD_EXP 90
84213: PPUSH
84214: LD_VAR 0 3
84218: PPUSH
84219: LD_EXP 90
84223: PUSH
84224: LD_VAR 0 3
84228: ARRAY
84229: PUSH
84230: LD_VAR 0 1
84234: DIFF
84235: PPUSH
84236: CALL_OW 1
84240: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84241: LD_VAR 0 1
84245: PUSH
84246: LD_EXP 91
84250: PUSH
84251: LD_VAR 0 3
84255: ARRAY
84256: IN
84257: IFFALSE 84281
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84259: LD_ADDR_EXP 91
84263: PUSH
84264: LD_EXP 91
84268: PPUSH
84269: LD_VAR 0 3
84273: PPUSH
84274: EMPTY
84275: PPUSH
84276: CALL_OW 1
84280: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84281: LD_VAR 0 1
84285: PPUSH
84286: CALL_OW 247
84290: PUSH
84291: LD_INT 2
84293: EQUAL
84294: PUSH
84295: LD_VAR 0 1
84299: PPUSH
84300: CALL_OW 110
84304: PUSH
84305: LD_INT 20
84307: EQUAL
84308: PUSH
84309: LD_VAR 0 1
84313: PUSH
84314: LD_EXP 83
84318: PUSH
84319: LD_VAR 0 3
84323: ARRAY
84324: IN
84325: OR
84326: PUSH
84327: LD_VAR 0 1
84331: PPUSH
84332: CALL_OW 264
84336: PUSH
84337: LD_INT 12
84339: PUSH
84340: LD_INT 51
84342: PUSH
84343: LD_INT 89
84345: PUSH
84346: LD_INT 32
84348: PUSH
84349: LD_INT 13
84351: PUSH
84352: LD_INT 52
84354: PUSH
84355: LD_INT 31
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: IN
84367: OR
84368: AND
84369: IFFALSE 84677
// begin if un in mc_defender [ i ] then
84371: LD_VAR 0 1
84375: PUSH
84376: LD_EXP 83
84380: PUSH
84381: LD_VAR 0 3
84385: ARRAY
84386: IN
84387: IFFALSE 84426
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84389: LD_ADDR_EXP 83
84393: PUSH
84394: LD_EXP 83
84398: PPUSH
84399: LD_VAR 0 3
84403: PPUSH
84404: LD_EXP 83
84408: PUSH
84409: LD_VAR 0 3
84413: ARRAY
84414: PUSH
84415: LD_VAR 0 1
84419: DIFF
84420: PPUSH
84421: CALL_OW 1
84425: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84426: LD_ADDR_VAR 0 8
84430: PUSH
84431: LD_VAR 0 3
84435: PPUSH
84436: LD_INT 3
84438: PPUSH
84439: CALL 81085 0 2
84443: ST_TO_ADDR
// if fac then
84444: LD_VAR 0 8
84448: IFFALSE 84677
// begin for j in fac do
84450: LD_ADDR_VAR 0 4
84454: PUSH
84455: LD_VAR 0 8
84459: PUSH
84460: FOR_IN
84461: IFFALSE 84675
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84463: LD_ADDR_VAR 0 9
84467: PUSH
84468: LD_VAR 0 8
84472: PPUSH
84473: LD_VAR 0 1
84477: PPUSH
84478: CALL_OW 265
84482: PPUSH
84483: LD_VAR 0 1
84487: PPUSH
84488: CALL_OW 262
84492: PPUSH
84493: LD_VAR 0 1
84497: PPUSH
84498: CALL_OW 263
84502: PPUSH
84503: LD_VAR 0 1
84507: PPUSH
84508: CALL_OW 264
84512: PPUSH
84513: CALL 17568 0 5
84517: ST_TO_ADDR
// if components then
84518: LD_VAR 0 9
84522: IFFALSE 84673
// begin if GetWeapon ( un ) = ar_control_tower then
84524: LD_VAR 0 1
84528: PPUSH
84529: CALL_OW 264
84533: PUSH
84534: LD_INT 31
84536: EQUAL
84537: IFFALSE 84654
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84539: LD_VAR 0 1
84543: PPUSH
84544: CALL_OW 311
84548: PPUSH
84549: LD_INT 0
84551: PPUSH
84552: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84556: LD_ADDR_EXP 101
84560: PUSH
84561: LD_EXP 101
84565: PPUSH
84566: LD_VAR 0 3
84570: PPUSH
84571: LD_EXP 101
84575: PUSH
84576: LD_VAR 0 3
84580: ARRAY
84581: PUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: CALL_OW 311
84591: DIFF
84592: PPUSH
84593: CALL_OW 1
84597: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84598: LD_ADDR_VAR 0 7
84602: PUSH
84603: LD_EXP 82
84607: PUSH
84608: LD_VAR 0 3
84612: ARRAY
84613: PPUSH
84614: LD_INT 1
84616: PPUSH
84617: LD_VAR 0 9
84621: PPUSH
84622: CALL_OW 2
84626: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84627: LD_ADDR_EXP 82
84631: PUSH
84632: LD_EXP 82
84636: PPUSH
84637: LD_VAR 0 3
84641: PPUSH
84642: LD_VAR 0 7
84646: PPUSH
84647: CALL_OW 1
84651: ST_TO_ADDR
// end else
84652: GO 84671
// MC_InsertProduceList ( i , [ components ] ) ;
84654: LD_VAR 0 3
84658: PPUSH
84659: LD_VAR 0 9
84663: PUSH
84664: EMPTY
84665: LIST
84666: PPUSH
84667: CALL 80630 0 2
// break ;
84671: GO 84675
// end ; end ;
84673: GO 84460
84675: POP
84676: POP
// end ; end ; if GetType ( un ) = unit_building then
84677: LD_VAR 0 1
84681: PPUSH
84682: CALL_OW 247
84686: PUSH
84687: LD_INT 3
84689: EQUAL
84690: IFFALSE 85093
// begin btype := GetBType ( un ) ;
84692: LD_ADDR_VAR 0 5
84696: PUSH
84697: LD_VAR 0 1
84701: PPUSH
84702: CALL_OW 266
84706: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84707: LD_VAR 0 5
84711: PUSH
84712: LD_INT 29
84714: PUSH
84715: LD_INT 30
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: IN
84722: IFFALSE 84795
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84724: LD_VAR 0 1
84728: PPUSH
84729: CALL_OW 250
84733: PPUSH
84734: LD_VAR 0 1
84738: PPUSH
84739: CALL_OW 251
84743: PPUSH
84744: LD_VAR 0 1
84748: PPUSH
84749: CALL_OW 255
84753: PPUSH
84754: CALL_OW 440
84758: NOT
84759: IFFALSE 84795
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84761: LD_VAR 0 1
84765: PPUSH
84766: CALL_OW 250
84770: PPUSH
84771: LD_VAR 0 1
84775: PPUSH
84776: CALL_OW 251
84780: PPUSH
84781: LD_VAR 0 1
84785: PPUSH
84786: CALL_OW 255
84790: PPUSH
84791: CALL_OW 441
// end ; if btype = b_warehouse then
84795: LD_VAR 0 5
84799: PUSH
84800: LD_INT 1
84802: EQUAL
84803: IFFALSE 84821
// begin btype := b_depot ;
84805: LD_ADDR_VAR 0 5
84809: PUSH
84810: LD_INT 0
84812: ST_TO_ADDR
// pos := 1 ;
84813: LD_ADDR_VAR 0 6
84817: PUSH
84818: LD_INT 1
84820: ST_TO_ADDR
// end ; if btype = b_factory then
84821: LD_VAR 0 5
84825: PUSH
84826: LD_INT 3
84828: EQUAL
84829: IFFALSE 84847
// begin btype := b_workshop ;
84831: LD_ADDR_VAR 0 5
84835: PUSH
84836: LD_INT 2
84838: ST_TO_ADDR
// pos := 1 ;
84839: LD_ADDR_VAR 0 6
84843: PUSH
84844: LD_INT 1
84846: ST_TO_ADDR
// end ; if btype = b_barracks then
84847: LD_VAR 0 5
84851: PUSH
84852: LD_INT 5
84854: EQUAL
84855: IFFALSE 84865
// btype := b_armoury ;
84857: LD_ADDR_VAR 0 5
84861: PUSH
84862: LD_INT 4
84864: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84865: LD_VAR 0 5
84869: PUSH
84870: LD_INT 7
84872: PUSH
84873: LD_INT 8
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: IN
84880: IFFALSE 84890
// btype := b_lab ;
84882: LD_ADDR_VAR 0 5
84886: PUSH
84887: LD_INT 6
84889: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84890: LD_ADDR_EXP 66
84894: PUSH
84895: LD_EXP 66
84899: PPUSH
84900: LD_VAR 0 3
84904: PUSH
84905: LD_EXP 66
84909: PUSH
84910: LD_VAR 0 3
84914: ARRAY
84915: PUSH
84916: LD_INT 1
84918: PLUS
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PPUSH
84924: LD_VAR 0 5
84928: PUSH
84929: LD_VAR 0 1
84933: PPUSH
84934: CALL_OW 250
84938: PUSH
84939: LD_VAR 0 1
84943: PPUSH
84944: CALL_OW 251
84948: PUSH
84949: LD_VAR 0 1
84953: PPUSH
84954: CALL_OW 254
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: PPUSH
84965: CALL 20070 0 3
84969: ST_TO_ADDR
// if pos = 1 then
84970: LD_VAR 0 6
84974: PUSH
84975: LD_INT 1
84977: EQUAL
84978: IFFALSE 85093
// begin tmp := mc_build_list [ i ] ;
84980: LD_ADDR_VAR 0 7
84984: PUSH
84985: LD_EXP 66
84989: PUSH
84990: LD_VAR 0 3
84994: ARRAY
84995: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84996: LD_VAR 0 7
85000: PPUSH
85001: LD_INT 2
85003: PUSH
85004: LD_INT 30
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: LD_INT 30
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: LIST
85028: PPUSH
85029: CALL_OW 72
85033: IFFALSE 85043
// pos := 2 ;
85035: LD_ADDR_VAR 0 6
85039: PUSH
85040: LD_INT 2
85042: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85043: LD_ADDR_VAR 0 7
85047: PUSH
85048: LD_VAR 0 7
85052: PPUSH
85053: LD_VAR 0 6
85057: PPUSH
85058: LD_VAR 0 7
85062: PPUSH
85063: CALL 20396 0 3
85067: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85068: LD_ADDR_EXP 66
85072: PUSH
85073: LD_EXP 66
85077: PPUSH
85078: LD_VAR 0 3
85082: PPUSH
85083: LD_VAR 0 7
85087: PPUSH
85088: CALL_OW 1
85092: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85093: LD_VAR 0 1
85097: PUSH
85098: LD_EXP 61
85102: PUSH
85103: LD_VAR 0 3
85107: ARRAY
85108: IN
85109: IFFALSE 85148
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85111: LD_ADDR_EXP 61
85115: PUSH
85116: LD_EXP 61
85120: PPUSH
85121: LD_VAR 0 3
85125: PPUSH
85126: LD_EXP 61
85130: PUSH
85131: LD_VAR 0 3
85135: ARRAY
85136: PUSH
85137: LD_VAR 0 1
85141: DIFF
85142: PPUSH
85143: CALL_OW 1
85147: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85148: LD_VAR 0 1
85152: PUSH
85153: LD_EXP 68
85157: PUSH
85158: LD_VAR 0 3
85162: ARRAY
85163: IN
85164: IFFALSE 85203
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85166: LD_ADDR_EXP 68
85170: PUSH
85171: LD_EXP 68
85175: PPUSH
85176: LD_VAR 0 3
85180: PPUSH
85181: LD_EXP 68
85185: PUSH
85186: LD_VAR 0 3
85190: ARRAY
85191: PUSH
85192: LD_VAR 0 1
85196: DIFF
85197: PPUSH
85198: CALL_OW 1
85202: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85203: LD_VAR 0 1
85207: PUSH
85208: LD_EXP 80
85212: PUSH
85213: LD_VAR 0 3
85217: ARRAY
85218: IN
85219: IFFALSE 85258
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85221: LD_ADDR_EXP 80
85225: PUSH
85226: LD_EXP 80
85230: PPUSH
85231: LD_VAR 0 3
85235: PPUSH
85236: LD_EXP 80
85240: PUSH
85241: LD_VAR 0 3
85245: ARRAY
85246: PUSH
85247: LD_VAR 0 1
85251: DIFF
85252: PPUSH
85253: CALL_OW 1
85257: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85258: LD_VAR 0 1
85262: PUSH
85263: LD_EXP 83
85267: PUSH
85268: LD_VAR 0 3
85272: ARRAY
85273: IN
85274: IFFALSE 85313
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85276: LD_ADDR_EXP 83
85280: PUSH
85281: LD_EXP 83
85285: PPUSH
85286: LD_VAR 0 3
85290: PPUSH
85291: LD_EXP 83
85295: PUSH
85296: LD_VAR 0 3
85300: ARRAY
85301: PUSH
85302: LD_VAR 0 1
85306: DIFF
85307: PPUSH
85308: CALL_OW 1
85312: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85313: LD_VAR 0 1
85317: PUSH
85318: LD_EXP 70
85322: PUSH
85323: LD_VAR 0 3
85327: ARRAY
85328: IN
85329: IFFALSE 85368
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85331: LD_ADDR_EXP 70
85335: PUSH
85336: LD_EXP 70
85340: PPUSH
85341: LD_VAR 0 3
85345: PPUSH
85346: LD_EXP 70
85350: PUSH
85351: LD_VAR 0 3
85355: ARRAY
85356: PUSH
85357: LD_VAR 0 1
85361: DIFF
85362: PPUSH
85363: CALL_OW 1
85367: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85368: LD_VAR 0 1
85372: PUSH
85373: LD_EXP 69
85377: PUSH
85378: LD_VAR 0 3
85382: ARRAY
85383: IN
85384: IFFALSE 85423
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85386: LD_ADDR_EXP 69
85390: PUSH
85391: LD_EXP 69
85395: PPUSH
85396: LD_VAR 0 3
85400: PPUSH
85401: LD_EXP 69
85405: PUSH
85406: LD_VAR 0 3
85410: ARRAY
85411: PUSH
85412: LD_VAR 0 1
85416: DIFF
85417: PPUSH
85418: CALL_OW 1
85422: ST_TO_ADDR
// end ; break ;
85423: GO 85427
// end ;
85425: GO 84075
85427: POP
85428: POP
// end ;
85429: LD_VAR 0 2
85433: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85434: LD_INT 0
85436: PPUSH
85437: PPUSH
85438: PPUSH
// if not mc_bases or not skirmish then
85439: LD_EXP 61
85443: NOT
85444: PUSH
85445: LD_EXP 59
85449: NOT
85450: OR
85451: IFFALSE 85455
// exit ;
85453: GO 85670
// for i = 1 to mc_bases do
85455: LD_ADDR_VAR 0 3
85459: PUSH
85460: DOUBLE
85461: LD_INT 1
85463: DEC
85464: ST_TO_ADDR
85465: LD_EXP 61
85469: PUSH
85470: FOR_TO
85471: IFFALSE 85668
// begin if building in mc_construct_list [ i ] then
85473: LD_VAR 0 1
85477: PUSH
85478: LD_EXP 68
85482: PUSH
85483: LD_VAR 0 3
85487: ARRAY
85488: IN
85489: IFFALSE 85666
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85491: LD_ADDR_EXP 68
85495: PUSH
85496: LD_EXP 68
85500: PPUSH
85501: LD_VAR 0 3
85505: PPUSH
85506: LD_EXP 68
85510: PUSH
85511: LD_VAR 0 3
85515: ARRAY
85516: PUSH
85517: LD_VAR 0 1
85521: DIFF
85522: PPUSH
85523: CALL_OW 1
85527: ST_TO_ADDR
// if building in mc_lab [ i ] then
85528: LD_VAR 0 1
85532: PUSH
85533: LD_EXP 94
85537: PUSH
85538: LD_VAR 0 3
85542: ARRAY
85543: IN
85544: IFFALSE 85599
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85546: LD_ADDR_EXP 95
85550: PUSH
85551: LD_EXP 95
85555: PPUSH
85556: LD_VAR 0 3
85560: PPUSH
85561: LD_EXP 95
85565: PUSH
85566: LD_VAR 0 3
85570: ARRAY
85571: PPUSH
85572: LD_INT 1
85574: PPUSH
85575: LD_EXP 95
85579: PUSH
85580: LD_VAR 0 3
85584: ARRAY
85585: PPUSH
85586: LD_INT 0
85588: PPUSH
85589: CALL 19488 0 4
85593: PPUSH
85594: CALL_OW 1
85598: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85599: LD_VAR 0 1
85603: PUSH
85604: LD_EXP 61
85608: PUSH
85609: LD_VAR 0 3
85613: ARRAY
85614: IN
85615: NOT
85616: IFFALSE 85662
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85618: LD_ADDR_EXP 61
85622: PUSH
85623: LD_EXP 61
85627: PPUSH
85628: LD_VAR 0 3
85632: PUSH
85633: LD_EXP 61
85637: PUSH
85638: LD_VAR 0 3
85642: ARRAY
85643: PUSH
85644: LD_INT 1
85646: PLUS
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PPUSH
85652: LD_VAR 0 1
85656: PPUSH
85657: CALL 20070 0 3
85661: ST_TO_ADDR
// exit ;
85662: POP
85663: POP
85664: GO 85670
// end ; end ;
85666: GO 85470
85668: POP
85669: POP
// end ;
85670: LD_VAR 0 2
85674: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85675: LD_INT 0
85677: PPUSH
85678: PPUSH
85679: PPUSH
85680: PPUSH
85681: PPUSH
85682: PPUSH
85683: PPUSH
// if not mc_bases or not skirmish then
85684: LD_EXP 61
85688: NOT
85689: PUSH
85690: LD_EXP 59
85694: NOT
85695: OR
85696: IFFALSE 85700
// exit ;
85698: GO 86361
// for i = 1 to mc_bases do
85700: LD_ADDR_VAR 0 3
85704: PUSH
85705: DOUBLE
85706: LD_INT 1
85708: DEC
85709: ST_TO_ADDR
85710: LD_EXP 61
85714: PUSH
85715: FOR_TO
85716: IFFALSE 86359
// begin if building in mc_construct_list [ i ] then
85718: LD_VAR 0 1
85722: PUSH
85723: LD_EXP 68
85727: PUSH
85728: LD_VAR 0 3
85732: ARRAY
85733: IN
85734: IFFALSE 86357
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85736: LD_ADDR_EXP 68
85740: PUSH
85741: LD_EXP 68
85745: PPUSH
85746: LD_VAR 0 3
85750: PPUSH
85751: LD_EXP 68
85755: PUSH
85756: LD_VAR 0 3
85760: ARRAY
85761: PUSH
85762: LD_VAR 0 1
85766: DIFF
85767: PPUSH
85768: CALL_OW 1
85772: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85773: LD_ADDR_EXP 61
85777: PUSH
85778: LD_EXP 61
85782: PPUSH
85783: LD_VAR 0 3
85787: PUSH
85788: LD_EXP 61
85792: PUSH
85793: LD_VAR 0 3
85797: ARRAY
85798: PUSH
85799: LD_INT 1
85801: PLUS
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PPUSH
85807: LD_VAR 0 1
85811: PPUSH
85812: CALL 20070 0 3
85816: ST_TO_ADDR
// btype := GetBType ( building ) ;
85817: LD_ADDR_VAR 0 5
85821: PUSH
85822: LD_VAR 0 1
85826: PPUSH
85827: CALL_OW 266
85831: ST_TO_ADDR
// side := GetSide ( building ) ;
85832: LD_ADDR_VAR 0 8
85836: PUSH
85837: LD_VAR 0 1
85841: PPUSH
85842: CALL_OW 255
85846: ST_TO_ADDR
// if btype = b_lab then
85847: LD_VAR 0 5
85851: PUSH
85852: LD_INT 6
85854: EQUAL
85855: IFFALSE 85905
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85857: LD_ADDR_EXP 94
85861: PUSH
85862: LD_EXP 94
85866: PPUSH
85867: LD_VAR 0 3
85871: PUSH
85872: LD_EXP 94
85876: PUSH
85877: LD_VAR 0 3
85881: ARRAY
85882: PUSH
85883: LD_INT 1
85885: PLUS
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PPUSH
85891: LD_VAR 0 1
85895: PPUSH
85896: CALL 20070 0 3
85900: ST_TO_ADDR
// exit ;
85901: POP
85902: POP
85903: GO 86361
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85905: LD_VAR 0 5
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: LD_INT 4
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: LIST
85923: IN
85924: IFFALSE 86048
// begin if btype = b_armoury then
85926: LD_VAR 0 5
85930: PUSH
85931: LD_INT 4
85933: EQUAL
85934: IFFALSE 85944
// btype := b_barracks ;
85936: LD_ADDR_VAR 0 5
85940: PUSH
85941: LD_INT 5
85943: ST_TO_ADDR
// if btype = b_depot then
85944: LD_VAR 0 5
85948: PUSH
85949: LD_INT 0
85951: EQUAL
85952: IFFALSE 85962
// btype := b_warehouse ;
85954: LD_ADDR_VAR 0 5
85958: PUSH
85959: LD_INT 1
85961: ST_TO_ADDR
// if btype = b_workshop then
85962: LD_VAR 0 5
85966: PUSH
85967: LD_INT 2
85969: EQUAL
85970: IFFALSE 85980
// btype := b_factory ;
85972: LD_ADDR_VAR 0 5
85976: PUSH
85977: LD_INT 3
85979: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85980: LD_VAR 0 5
85984: PPUSH
85985: LD_VAR 0 8
85989: PPUSH
85990: CALL_OW 323
85994: PUSH
85995: LD_INT 1
85997: EQUAL
85998: IFFALSE 86044
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86000: LD_ADDR_EXP 93
86004: PUSH
86005: LD_EXP 93
86009: PPUSH
86010: LD_VAR 0 3
86014: PUSH
86015: LD_EXP 93
86019: PUSH
86020: LD_VAR 0 3
86024: ARRAY
86025: PUSH
86026: LD_INT 1
86028: PLUS
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PPUSH
86034: LD_VAR 0 1
86038: PPUSH
86039: CALL 20070 0 3
86043: ST_TO_ADDR
// exit ;
86044: POP
86045: POP
86046: GO 86361
// end ; if btype in [ b_bunker , b_turret ] then
86048: LD_VAR 0 5
86052: PUSH
86053: LD_INT 32
86055: PUSH
86056: LD_INT 33
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: IN
86063: IFFALSE 86353
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86065: LD_ADDR_EXP 69
86069: PUSH
86070: LD_EXP 69
86074: PPUSH
86075: LD_VAR 0 3
86079: PUSH
86080: LD_EXP 69
86084: PUSH
86085: LD_VAR 0 3
86089: ARRAY
86090: PUSH
86091: LD_INT 1
86093: PLUS
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PPUSH
86099: LD_VAR 0 1
86103: PPUSH
86104: CALL 20070 0 3
86108: ST_TO_ADDR
// if btype = b_bunker then
86109: LD_VAR 0 5
86113: PUSH
86114: LD_INT 32
86116: EQUAL
86117: IFFALSE 86353
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86119: LD_ADDR_EXP 70
86123: PUSH
86124: LD_EXP 70
86128: PPUSH
86129: LD_VAR 0 3
86133: PUSH
86134: LD_EXP 70
86138: PUSH
86139: LD_VAR 0 3
86143: ARRAY
86144: PUSH
86145: LD_INT 1
86147: PLUS
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PPUSH
86153: LD_VAR 0 1
86157: PPUSH
86158: CALL 20070 0 3
86162: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86163: LD_ADDR_VAR 0 6
86167: PUSH
86168: LD_EXP 61
86172: PUSH
86173: LD_VAR 0 3
86177: ARRAY
86178: PPUSH
86179: LD_INT 25
86181: PUSH
86182: LD_INT 1
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: LD_INT 3
86191: PUSH
86192: LD_INT 54
86194: PUSH
86195: EMPTY
86196: LIST
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: PPUSH
86206: CALL_OW 72
86210: ST_TO_ADDR
// if tmp then
86211: LD_VAR 0 6
86215: IFFALSE 86221
// exit ;
86217: POP
86218: POP
86219: GO 86361
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86221: LD_ADDR_VAR 0 6
86225: PUSH
86226: LD_EXP 61
86230: PUSH
86231: LD_VAR 0 3
86235: ARRAY
86236: PPUSH
86237: LD_INT 2
86239: PUSH
86240: LD_INT 30
86242: PUSH
86243: LD_INT 4
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 30
86252: PUSH
86253: LD_INT 5
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: LIST
86264: PPUSH
86265: CALL_OW 72
86269: ST_TO_ADDR
// if not tmp then
86270: LD_VAR 0 6
86274: NOT
86275: IFFALSE 86281
// exit ;
86277: POP
86278: POP
86279: GO 86361
// for j in tmp do
86281: LD_ADDR_VAR 0 4
86285: PUSH
86286: LD_VAR 0 6
86290: PUSH
86291: FOR_IN
86292: IFFALSE 86351
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86294: LD_ADDR_VAR 0 7
86298: PUSH
86299: LD_VAR 0 4
86303: PPUSH
86304: CALL_OW 313
86308: PPUSH
86309: LD_INT 25
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PPUSH
86319: CALL_OW 72
86323: ST_TO_ADDR
// if units then
86324: LD_VAR 0 7
86328: IFFALSE 86349
// begin ComExitBuilding ( units [ 1 ] ) ;
86330: LD_VAR 0 7
86334: PUSH
86335: LD_INT 1
86337: ARRAY
86338: PPUSH
86339: CALL_OW 122
// exit ;
86343: POP
86344: POP
86345: POP
86346: POP
86347: GO 86361
// end ; end ;
86349: GO 86291
86351: POP
86352: POP
// end ; end ; exit ;
86353: POP
86354: POP
86355: GO 86361
// end ; end ;
86357: GO 85715
86359: POP
86360: POP
// end ;
86361: LD_VAR 0 2
86365: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86366: LD_INT 0
86368: PPUSH
86369: PPUSH
86370: PPUSH
86371: PPUSH
86372: PPUSH
86373: PPUSH
86374: PPUSH
// if not mc_bases or not skirmish then
86375: LD_EXP 61
86379: NOT
86380: PUSH
86381: LD_EXP 59
86385: NOT
86386: OR
86387: IFFALSE 86391
// exit ;
86389: GO 86656
// btype := GetBType ( building ) ;
86391: LD_ADDR_VAR 0 6
86395: PUSH
86396: LD_VAR 0 1
86400: PPUSH
86401: CALL_OW 266
86405: ST_TO_ADDR
// x := GetX ( building ) ;
86406: LD_ADDR_VAR 0 7
86410: PUSH
86411: LD_VAR 0 1
86415: PPUSH
86416: CALL_OW 250
86420: ST_TO_ADDR
// y := GetY ( building ) ;
86421: LD_ADDR_VAR 0 8
86425: PUSH
86426: LD_VAR 0 1
86430: PPUSH
86431: CALL_OW 251
86435: ST_TO_ADDR
// d := GetDir ( building ) ;
86436: LD_ADDR_VAR 0 9
86440: PUSH
86441: LD_VAR 0 1
86445: PPUSH
86446: CALL_OW 254
86450: ST_TO_ADDR
// for i = 1 to mc_bases do
86451: LD_ADDR_VAR 0 4
86455: PUSH
86456: DOUBLE
86457: LD_INT 1
86459: DEC
86460: ST_TO_ADDR
86461: LD_EXP 61
86465: PUSH
86466: FOR_TO
86467: IFFALSE 86654
// begin if not mc_build_list [ i ] then
86469: LD_EXP 66
86473: PUSH
86474: LD_VAR 0 4
86478: ARRAY
86479: NOT
86480: IFFALSE 86484
// continue ;
86482: GO 86466
// for j := 1 to mc_build_list [ i ] do
86484: LD_ADDR_VAR 0 5
86488: PUSH
86489: DOUBLE
86490: LD_INT 1
86492: DEC
86493: ST_TO_ADDR
86494: LD_EXP 66
86498: PUSH
86499: LD_VAR 0 4
86503: ARRAY
86504: PUSH
86505: FOR_TO
86506: IFFALSE 86650
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86508: LD_VAR 0 6
86512: PUSH
86513: LD_VAR 0 7
86517: PUSH
86518: LD_VAR 0 8
86522: PUSH
86523: LD_VAR 0 9
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: PPUSH
86534: LD_EXP 66
86538: PUSH
86539: LD_VAR 0 4
86543: ARRAY
86544: PUSH
86545: LD_VAR 0 5
86549: ARRAY
86550: PPUSH
86551: CALL 26250 0 2
86555: IFFALSE 86648
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86557: LD_ADDR_EXP 66
86561: PUSH
86562: LD_EXP 66
86566: PPUSH
86567: LD_VAR 0 4
86571: PPUSH
86572: LD_EXP 66
86576: PUSH
86577: LD_VAR 0 4
86581: ARRAY
86582: PPUSH
86583: LD_VAR 0 5
86587: PPUSH
86588: CALL_OW 3
86592: PPUSH
86593: CALL_OW 1
86597: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86598: LD_ADDR_EXP 68
86602: PUSH
86603: LD_EXP 68
86607: PPUSH
86608: LD_VAR 0 4
86612: PUSH
86613: LD_EXP 68
86617: PUSH
86618: LD_VAR 0 4
86622: ARRAY
86623: PUSH
86624: LD_INT 1
86626: PLUS
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PPUSH
86632: LD_VAR 0 1
86636: PPUSH
86637: CALL 20070 0 3
86641: ST_TO_ADDR
// exit ;
86642: POP
86643: POP
86644: POP
86645: POP
86646: GO 86656
// end ;
86648: GO 86505
86650: POP
86651: POP
// end ;
86652: GO 86466
86654: POP
86655: POP
// end ;
86656: LD_VAR 0 3
86660: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86661: LD_INT 0
86663: PPUSH
86664: PPUSH
86665: PPUSH
// if not mc_bases or not skirmish then
86666: LD_EXP 61
86670: NOT
86671: PUSH
86672: LD_EXP 59
86676: NOT
86677: OR
86678: IFFALSE 86682
// exit ;
86680: GO 86872
// for i = 1 to mc_bases do
86682: LD_ADDR_VAR 0 4
86686: PUSH
86687: DOUBLE
86688: LD_INT 1
86690: DEC
86691: ST_TO_ADDR
86692: LD_EXP 61
86696: PUSH
86697: FOR_TO
86698: IFFALSE 86785
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86700: LD_VAR 0 1
86704: PUSH
86705: LD_EXP 69
86709: PUSH
86710: LD_VAR 0 4
86714: ARRAY
86715: IN
86716: PUSH
86717: LD_VAR 0 1
86721: PUSH
86722: LD_EXP 70
86726: PUSH
86727: LD_VAR 0 4
86731: ARRAY
86732: IN
86733: NOT
86734: AND
86735: IFFALSE 86783
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86737: LD_ADDR_EXP 70
86741: PUSH
86742: LD_EXP 70
86746: PPUSH
86747: LD_VAR 0 4
86751: PUSH
86752: LD_EXP 70
86756: PUSH
86757: LD_VAR 0 4
86761: ARRAY
86762: PUSH
86763: LD_INT 1
86765: PLUS
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PPUSH
86771: LD_VAR 0 1
86775: PPUSH
86776: CALL 20070 0 3
86780: ST_TO_ADDR
// break ;
86781: GO 86785
// end ; end ;
86783: GO 86697
86785: POP
86786: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86787: LD_VAR 0 1
86791: PPUSH
86792: CALL_OW 257
86796: PUSH
86797: LD_EXP 87
86801: IN
86802: PUSH
86803: LD_VAR 0 1
86807: PPUSH
86808: CALL_OW 266
86812: PUSH
86813: LD_INT 5
86815: EQUAL
86816: AND
86817: PUSH
86818: LD_VAR 0 2
86822: PPUSH
86823: CALL_OW 110
86827: PUSH
86828: LD_INT 18
86830: NONEQUAL
86831: AND
86832: IFFALSE 86872
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86834: LD_VAR 0 2
86838: PPUSH
86839: CALL_OW 257
86843: PUSH
86844: LD_INT 5
86846: PUSH
86847: LD_INT 8
86849: PUSH
86850: LD_INT 9
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: LIST
86857: IN
86858: IFFALSE 86872
// SetClass ( unit , 1 ) ;
86860: LD_VAR 0 2
86864: PPUSH
86865: LD_INT 1
86867: PPUSH
86868: CALL_OW 336
// end ;
86872: LD_VAR 0 3
86876: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86877: LD_INT 0
86879: PPUSH
86880: PPUSH
// if not mc_bases or not skirmish then
86881: LD_EXP 61
86885: NOT
86886: PUSH
86887: LD_EXP 59
86891: NOT
86892: OR
86893: IFFALSE 86897
// exit ;
86895: GO 87013
// if GetLives ( abandoned_vehicle ) > 250 then
86897: LD_VAR 0 2
86901: PPUSH
86902: CALL_OW 256
86906: PUSH
86907: LD_INT 250
86909: GREATER
86910: IFFALSE 86914
// exit ;
86912: GO 87013
// for i = 1 to mc_bases do
86914: LD_ADDR_VAR 0 6
86918: PUSH
86919: DOUBLE
86920: LD_INT 1
86922: DEC
86923: ST_TO_ADDR
86924: LD_EXP 61
86928: PUSH
86929: FOR_TO
86930: IFFALSE 87011
// begin if driver in mc_bases [ i ] then
86932: LD_VAR 0 1
86936: PUSH
86937: LD_EXP 61
86941: PUSH
86942: LD_VAR 0 6
86946: ARRAY
86947: IN
86948: IFFALSE 87009
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86950: LD_VAR 0 1
86954: PPUSH
86955: LD_EXP 61
86959: PUSH
86960: LD_VAR 0 6
86964: ARRAY
86965: PPUSH
86966: LD_INT 2
86968: PUSH
86969: LD_INT 30
86971: PUSH
86972: LD_INT 0
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 30
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: LIST
86993: PPUSH
86994: CALL_OW 72
86998: PUSH
86999: LD_INT 1
87001: ARRAY
87002: PPUSH
87003: CALL 53278 0 2
// break ;
87007: GO 87011
// end ; end ;
87009: GO 86929
87011: POP
87012: POP
// end ; end_of_file end_of_file
87013: LD_VAR 0 5
87017: RET
// every 0 0$1 do
87018: GO 87020
87020: DISABLE
// begin enable ;
87021: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87022: LD_STRING updateTimer(
87024: PUSH
87025: LD_OWVAR 1
87029: STR
87030: PUSH
87031: LD_STRING );
87033: STR
87034: PPUSH
87035: CALL_OW 559
// end ;
87039: END
// export function SOS_MapStart ( ) ; begin
87040: LD_INT 0
87042: PPUSH
// if streamModeActive then
87043: LD_EXP 106
87047: IFFALSE 87056
// DefineStreamItems ( true ) ;
87049: LD_INT 1
87051: PPUSH
87052: CALL 88860 0 1
// UpdateLuaVariables ( ) ;
87056: CALL 87073 0 0
// UpdateFactoryWaypoints ( ) ;
87060: CALL 101721 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87064: CALL 101978 0 0
// end ;
87068: LD_VAR 0 1
87072: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
87073: LD_INT 0
87075: PPUSH
// if not globalGameSaveCounter then
87076: LD_EXP 105
87080: NOT
87081: IFFALSE 87092
// ToLua ( setGameSaveCounter(0) ) else
87083: LD_STRING setGameSaveCounter(0)
87085: PPUSH
87086: CALL_OW 559
87090: GO 87124
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87092: LD_ADDR_EXP 105
87096: PUSH
87097: LD_EXP 105
87101: PPUSH
87102: CALL 53762 0 1
87106: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87107: LD_STRING setGameSaveCounter(
87109: PUSH
87110: LD_EXP 105
87114: STR
87115: PUSH
87116: LD_STRING )
87118: STR
87119: PPUSH
87120: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87124: LD_STRING setGameDifficulty(
87126: PUSH
87127: LD_OWVAR 67
87131: STR
87132: PUSH
87133: LD_STRING )
87135: STR
87136: PPUSH
87137: CALL_OW 559
// end ;
87141: LD_VAR 0 1
87145: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87146: LD_INT 0
87148: PPUSH
// if p2 = stream_mode then
87149: LD_VAR 0 2
87153: PUSH
87154: LD_INT 100
87156: EQUAL
87157: IFFALSE 88160
// begin if not StreamModeActive then
87159: LD_EXP 106
87163: NOT
87164: IFFALSE 87174
// StreamModeActive := true ;
87166: LD_ADDR_EXP 106
87170: PUSH
87171: LD_INT 1
87173: ST_TO_ADDR
// if p3 = 0 then
87174: LD_VAR 0 3
87178: PUSH
87179: LD_INT 0
87181: EQUAL
87182: IFFALSE 87188
// InitStreamMode ;
87184: CALL 88396 0 0
// if p3 = 1 then
87188: LD_VAR 0 3
87192: PUSH
87193: LD_INT 1
87195: EQUAL
87196: IFFALSE 87206
// sRocket := true ;
87198: LD_ADDR_EXP 111
87202: PUSH
87203: LD_INT 1
87205: ST_TO_ADDR
// if p3 = 2 then
87206: LD_VAR 0 3
87210: PUSH
87211: LD_INT 2
87213: EQUAL
87214: IFFALSE 87224
// sSpeed := true ;
87216: LD_ADDR_EXP 110
87220: PUSH
87221: LD_INT 1
87223: ST_TO_ADDR
// if p3 = 3 then
87224: LD_VAR 0 3
87228: PUSH
87229: LD_INT 3
87231: EQUAL
87232: IFFALSE 87242
// sEngine := true ;
87234: LD_ADDR_EXP 112
87238: PUSH
87239: LD_INT 1
87241: ST_TO_ADDR
// if p3 = 4 then
87242: LD_VAR 0 3
87246: PUSH
87247: LD_INT 4
87249: EQUAL
87250: IFFALSE 87260
// sSpec := true ;
87252: LD_ADDR_EXP 109
87256: PUSH
87257: LD_INT 1
87259: ST_TO_ADDR
// if p3 = 5 then
87260: LD_VAR 0 3
87264: PUSH
87265: LD_INT 5
87267: EQUAL
87268: IFFALSE 87278
// sLevel := true ;
87270: LD_ADDR_EXP 113
87274: PUSH
87275: LD_INT 1
87277: ST_TO_ADDR
// if p3 = 6 then
87278: LD_VAR 0 3
87282: PUSH
87283: LD_INT 6
87285: EQUAL
87286: IFFALSE 87296
// sArmoury := true ;
87288: LD_ADDR_EXP 114
87292: PUSH
87293: LD_INT 1
87295: ST_TO_ADDR
// if p3 = 7 then
87296: LD_VAR 0 3
87300: PUSH
87301: LD_INT 7
87303: EQUAL
87304: IFFALSE 87314
// sRadar := true ;
87306: LD_ADDR_EXP 115
87310: PUSH
87311: LD_INT 1
87313: ST_TO_ADDR
// if p3 = 8 then
87314: LD_VAR 0 3
87318: PUSH
87319: LD_INT 8
87321: EQUAL
87322: IFFALSE 87332
// sBunker := true ;
87324: LD_ADDR_EXP 116
87328: PUSH
87329: LD_INT 1
87331: ST_TO_ADDR
// if p3 = 9 then
87332: LD_VAR 0 3
87336: PUSH
87337: LD_INT 9
87339: EQUAL
87340: IFFALSE 87350
// sHack := true ;
87342: LD_ADDR_EXP 117
87346: PUSH
87347: LD_INT 1
87349: ST_TO_ADDR
// if p3 = 10 then
87350: LD_VAR 0 3
87354: PUSH
87355: LD_INT 10
87357: EQUAL
87358: IFFALSE 87368
// sFire := true ;
87360: LD_ADDR_EXP 118
87364: PUSH
87365: LD_INT 1
87367: ST_TO_ADDR
// if p3 = 11 then
87368: LD_VAR 0 3
87372: PUSH
87373: LD_INT 11
87375: EQUAL
87376: IFFALSE 87386
// sRefresh := true ;
87378: LD_ADDR_EXP 119
87382: PUSH
87383: LD_INT 1
87385: ST_TO_ADDR
// if p3 = 12 then
87386: LD_VAR 0 3
87390: PUSH
87391: LD_INT 12
87393: EQUAL
87394: IFFALSE 87404
// sExp := true ;
87396: LD_ADDR_EXP 120
87400: PUSH
87401: LD_INT 1
87403: ST_TO_ADDR
// if p3 = 13 then
87404: LD_VAR 0 3
87408: PUSH
87409: LD_INT 13
87411: EQUAL
87412: IFFALSE 87422
// sDepot := true ;
87414: LD_ADDR_EXP 121
87418: PUSH
87419: LD_INT 1
87421: ST_TO_ADDR
// if p3 = 14 then
87422: LD_VAR 0 3
87426: PUSH
87427: LD_INT 14
87429: EQUAL
87430: IFFALSE 87440
// sFlag := true ;
87432: LD_ADDR_EXP 122
87436: PUSH
87437: LD_INT 1
87439: ST_TO_ADDR
// if p3 = 15 then
87440: LD_VAR 0 3
87444: PUSH
87445: LD_INT 15
87447: EQUAL
87448: IFFALSE 87458
// sKamikadze := true ;
87450: LD_ADDR_EXP 130
87454: PUSH
87455: LD_INT 1
87457: ST_TO_ADDR
// if p3 = 16 then
87458: LD_VAR 0 3
87462: PUSH
87463: LD_INT 16
87465: EQUAL
87466: IFFALSE 87476
// sTroll := true ;
87468: LD_ADDR_EXP 131
87472: PUSH
87473: LD_INT 1
87475: ST_TO_ADDR
// if p3 = 17 then
87476: LD_VAR 0 3
87480: PUSH
87481: LD_INT 17
87483: EQUAL
87484: IFFALSE 87494
// sSlow := true ;
87486: LD_ADDR_EXP 132
87490: PUSH
87491: LD_INT 1
87493: ST_TO_ADDR
// if p3 = 18 then
87494: LD_VAR 0 3
87498: PUSH
87499: LD_INT 18
87501: EQUAL
87502: IFFALSE 87512
// sLack := true ;
87504: LD_ADDR_EXP 133
87508: PUSH
87509: LD_INT 1
87511: ST_TO_ADDR
// if p3 = 19 then
87512: LD_VAR 0 3
87516: PUSH
87517: LD_INT 19
87519: EQUAL
87520: IFFALSE 87530
// sTank := true ;
87522: LD_ADDR_EXP 135
87526: PUSH
87527: LD_INT 1
87529: ST_TO_ADDR
// if p3 = 20 then
87530: LD_VAR 0 3
87534: PUSH
87535: LD_INT 20
87537: EQUAL
87538: IFFALSE 87548
// sRemote := true ;
87540: LD_ADDR_EXP 136
87544: PUSH
87545: LD_INT 1
87547: ST_TO_ADDR
// if p3 = 21 then
87548: LD_VAR 0 3
87552: PUSH
87553: LD_INT 21
87555: EQUAL
87556: IFFALSE 87566
// sPowell := true ;
87558: LD_ADDR_EXP 137
87562: PUSH
87563: LD_INT 1
87565: ST_TO_ADDR
// if p3 = 22 then
87566: LD_VAR 0 3
87570: PUSH
87571: LD_INT 22
87573: EQUAL
87574: IFFALSE 87584
// sTeleport := true ;
87576: LD_ADDR_EXP 140
87580: PUSH
87581: LD_INT 1
87583: ST_TO_ADDR
// if p3 = 23 then
87584: LD_VAR 0 3
87588: PUSH
87589: LD_INT 23
87591: EQUAL
87592: IFFALSE 87602
// sOilTower := true ;
87594: LD_ADDR_EXP 142
87598: PUSH
87599: LD_INT 1
87601: ST_TO_ADDR
// if p3 = 24 then
87602: LD_VAR 0 3
87606: PUSH
87607: LD_INT 24
87609: EQUAL
87610: IFFALSE 87620
// sShovel := true ;
87612: LD_ADDR_EXP 143
87616: PUSH
87617: LD_INT 1
87619: ST_TO_ADDR
// if p3 = 25 then
87620: LD_VAR 0 3
87624: PUSH
87625: LD_INT 25
87627: EQUAL
87628: IFFALSE 87638
// sSheik := true ;
87630: LD_ADDR_EXP 144
87634: PUSH
87635: LD_INT 1
87637: ST_TO_ADDR
// if p3 = 26 then
87638: LD_VAR 0 3
87642: PUSH
87643: LD_INT 26
87645: EQUAL
87646: IFFALSE 87656
// sEarthquake := true ;
87648: LD_ADDR_EXP 146
87652: PUSH
87653: LD_INT 1
87655: ST_TO_ADDR
// if p3 = 27 then
87656: LD_VAR 0 3
87660: PUSH
87661: LD_INT 27
87663: EQUAL
87664: IFFALSE 87674
// sAI := true ;
87666: LD_ADDR_EXP 147
87670: PUSH
87671: LD_INT 1
87673: ST_TO_ADDR
// if p3 = 28 then
87674: LD_VAR 0 3
87678: PUSH
87679: LD_INT 28
87681: EQUAL
87682: IFFALSE 87692
// sCargo := true ;
87684: LD_ADDR_EXP 150
87688: PUSH
87689: LD_INT 1
87691: ST_TO_ADDR
// if p3 = 29 then
87692: LD_VAR 0 3
87696: PUSH
87697: LD_INT 29
87699: EQUAL
87700: IFFALSE 87710
// sDLaser := true ;
87702: LD_ADDR_EXP 151
87706: PUSH
87707: LD_INT 1
87709: ST_TO_ADDR
// if p3 = 30 then
87710: LD_VAR 0 3
87714: PUSH
87715: LD_INT 30
87717: EQUAL
87718: IFFALSE 87728
// sExchange := true ;
87720: LD_ADDR_EXP 152
87724: PUSH
87725: LD_INT 1
87727: ST_TO_ADDR
// if p3 = 31 then
87728: LD_VAR 0 3
87732: PUSH
87733: LD_INT 31
87735: EQUAL
87736: IFFALSE 87746
// sFac := true ;
87738: LD_ADDR_EXP 153
87742: PUSH
87743: LD_INT 1
87745: ST_TO_ADDR
// if p3 = 32 then
87746: LD_VAR 0 3
87750: PUSH
87751: LD_INT 32
87753: EQUAL
87754: IFFALSE 87764
// sPower := true ;
87756: LD_ADDR_EXP 154
87760: PUSH
87761: LD_INT 1
87763: ST_TO_ADDR
// if p3 = 33 then
87764: LD_VAR 0 3
87768: PUSH
87769: LD_INT 33
87771: EQUAL
87772: IFFALSE 87782
// sRandom := true ;
87774: LD_ADDR_EXP 155
87778: PUSH
87779: LD_INT 1
87781: ST_TO_ADDR
// if p3 = 34 then
87782: LD_VAR 0 3
87786: PUSH
87787: LD_INT 34
87789: EQUAL
87790: IFFALSE 87800
// sShield := true ;
87792: LD_ADDR_EXP 156
87796: PUSH
87797: LD_INT 1
87799: ST_TO_ADDR
// if p3 = 35 then
87800: LD_VAR 0 3
87804: PUSH
87805: LD_INT 35
87807: EQUAL
87808: IFFALSE 87818
// sTime := true ;
87810: LD_ADDR_EXP 157
87814: PUSH
87815: LD_INT 1
87817: ST_TO_ADDR
// if p3 = 36 then
87818: LD_VAR 0 3
87822: PUSH
87823: LD_INT 36
87825: EQUAL
87826: IFFALSE 87836
// sTools := true ;
87828: LD_ADDR_EXP 158
87832: PUSH
87833: LD_INT 1
87835: ST_TO_ADDR
// if p3 = 101 then
87836: LD_VAR 0 3
87840: PUSH
87841: LD_INT 101
87843: EQUAL
87844: IFFALSE 87854
// sSold := true ;
87846: LD_ADDR_EXP 123
87850: PUSH
87851: LD_INT 1
87853: ST_TO_ADDR
// if p3 = 102 then
87854: LD_VAR 0 3
87858: PUSH
87859: LD_INT 102
87861: EQUAL
87862: IFFALSE 87872
// sDiff := true ;
87864: LD_ADDR_EXP 124
87868: PUSH
87869: LD_INT 1
87871: ST_TO_ADDR
// if p3 = 103 then
87872: LD_VAR 0 3
87876: PUSH
87877: LD_INT 103
87879: EQUAL
87880: IFFALSE 87890
// sFog := true ;
87882: LD_ADDR_EXP 127
87886: PUSH
87887: LD_INT 1
87889: ST_TO_ADDR
// if p3 = 104 then
87890: LD_VAR 0 3
87894: PUSH
87895: LD_INT 104
87897: EQUAL
87898: IFFALSE 87908
// sReset := true ;
87900: LD_ADDR_EXP 128
87904: PUSH
87905: LD_INT 1
87907: ST_TO_ADDR
// if p3 = 105 then
87908: LD_VAR 0 3
87912: PUSH
87913: LD_INT 105
87915: EQUAL
87916: IFFALSE 87926
// sSun := true ;
87918: LD_ADDR_EXP 129
87922: PUSH
87923: LD_INT 1
87925: ST_TO_ADDR
// if p3 = 106 then
87926: LD_VAR 0 3
87930: PUSH
87931: LD_INT 106
87933: EQUAL
87934: IFFALSE 87944
// sTiger := true ;
87936: LD_ADDR_EXP 125
87940: PUSH
87941: LD_INT 1
87943: ST_TO_ADDR
// if p3 = 107 then
87944: LD_VAR 0 3
87948: PUSH
87949: LD_INT 107
87951: EQUAL
87952: IFFALSE 87962
// sBomb := true ;
87954: LD_ADDR_EXP 126
87958: PUSH
87959: LD_INT 1
87961: ST_TO_ADDR
// if p3 = 108 then
87962: LD_VAR 0 3
87966: PUSH
87967: LD_INT 108
87969: EQUAL
87970: IFFALSE 87980
// sWound := true ;
87972: LD_ADDR_EXP 134
87976: PUSH
87977: LD_INT 1
87979: ST_TO_ADDR
// if p3 = 109 then
87980: LD_VAR 0 3
87984: PUSH
87985: LD_INT 109
87987: EQUAL
87988: IFFALSE 87998
// sBetray := true ;
87990: LD_ADDR_EXP 138
87994: PUSH
87995: LD_INT 1
87997: ST_TO_ADDR
// if p3 = 110 then
87998: LD_VAR 0 3
88002: PUSH
88003: LD_INT 110
88005: EQUAL
88006: IFFALSE 88016
// sContamin := true ;
88008: LD_ADDR_EXP 139
88012: PUSH
88013: LD_INT 1
88015: ST_TO_ADDR
// if p3 = 111 then
88016: LD_VAR 0 3
88020: PUSH
88021: LD_INT 111
88023: EQUAL
88024: IFFALSE 88034
// sOil := true ;
88026: LD_ADDR_EXP 141
88030: PUSH
88031: LD_INT 1
88033: ST_TO_ADDR
// if p3 = 112 then
88034: LD_VAR 0 3
88038: PUSH
88039: LD_INT 112
88041: EQUAL
88042: IFFALSE 88052
// sStu := true ;
88044: LD_ADDR_EXP 145
88048: PUSH
88049: LD_INT 1
88051: ST_TO_ADDR
// if p3 = 113 then
88052: LD_VAR 0 3
88056: PUSH
88057: LD_INT 113
88059: EQUAL
88060: IFFALSE 88070
// sBazooka := true ;
88062: LD_ADDR_EXP 148
88066: PUSH
88067: LD_INT 1
88069: ST_TO_ADDR
// if p3 = 114 then
88070: LD_VAR 0 3
88074: PUSH
88075: LD_INT 114
88077: EQUAL
88078: IFFALSE 88088
// sMortar := true ;
88080: LD_ADDR_EXP 149
88084: PUSH
88085: LD_INT 1
88087: ST_TO_ADDR
// if p3 = 115 then
88088: LD_VAR 0 3
88092: PUSH
88093: LD_INT 115
88095: EQUAL
88096: IFFALSE 88106
// sRanger := true ;
88098: LD_ADDR_EXP 159
88102: PUSH
88103: LD_INT 1
88105: ST_TO_ADDR
// if p3 = 116 then
88106: LD_VAR 0 3
88110: PUSH
88111: LD_INT 116
88113: EQUAL
88114: IFFALSE 88124
// sComputer := true ;
88116: LD_ADDR_EXP 160
88120: PUSH
88121: LD_INT 1
88123: ST_TO_ADDR
// if p3 = 117 then
88124: LD_VAR 0 3
88128: PUSH
88129: LD_INT 117
88131: EQUAL
88132: IFFALSE 88142
// s30 := true ;
88134: LD_ADDR_EXP 161
88138: PUSH
88139: LD_INT 1
88141: ST_TO_ADDR
// if p3 = 118 then
88142: LD_VAR 0 3
88146: PUSH
88147: LD_INT 118
88149: EQUAL
88150: IFFALSE 88160
// s60 := true ;
88152: LD_ADDR_EXP 162
88156: PUSH
88157: LD_INT 1
88159: ST_TO_ADDR
// end ; if p2 = hack_mode then
88160: LD_VAR 0 2
88164: PUSH
88165: LD_INT 101
88167: EQUAL
88168: IFFALSE 88296
// begin case p3 of 1 :
88170: LD_VAR 0 3
88174: PUSH
88175: LD_INT 1
88177: DOUBLE
88178: EQUAL
88179: IFTRUE 88183
88181: GO 88190
88183: POP
// hHackUnlimitedResources ; 2 :
88184: CALL 100467 0 0
88188: GO 88296
88190: LD_INT 2
88192: DOUBLE
88193: EQUAL
88194: IFTRUE 88198
88196: GO 88205
88198: POP
// hHackSetLevel10 ; 3 :
88199: CALL 100600 0 0
88203: GO 88296
88205: LD_INT 3
88207: DOUBLE
88208: EQUAL
88209: IFTRUE 88213
88211: GO 88220
88213: POP
// hHackSetLevel10YourUnits ; 4 :
88214: CALL 100685 0 0
88218: GO 88296
88220: LD_INT 4
88222: DOUBLE
88223: EQUAL
88224: IFTRUE 88228
88226: GO 88235
88228: POP
// hHackInvincible ; 5 :
88229: CALL 101133 0 0
88233: GO 88296
88235: LD_INT 5
88237: DOUBLE
88238: EQUAL
88239: IFTRUE 88243
88241: GO 88250
88243: POP
// hHackInvisible ; 6 :
88244: CALL 101244 0 0
88248: GO 88296
88250: LD_INT 6
88252: DOUBLE
88253: EQUAL
88254: IFTRUE 88258
88256: GO 88265
88258: POP
// hHackChangeYourSide ; 7 :
88259: CALL 101301 0 0
88263: GO 88296
88265: LD_INT 7
88267: DOUBLE
88268: EQUAL
88269: IFTRUE 88273
88271: GO 88280
88273: POP
// hHackChangeUnitSide ; 8 :
88274: CALL 101343 0 0
88278: GO 88296
88280: LD_INT 8
88282: DOUBLE
88283: EQUAL
88284: IFTRUE 88288
88286: GO 88295
88288: POP
// hHackFog ; end ;
88289: CALL 101444 0 0
88293: GO 88296
88295: POP
// end ; if p2 = game_save_mode then
88296: LD_VAR 0 2
88300: PUSH
88301: LD_INT 102
88303: EQUAL
88304: IFFALSE 88369
// begin if p3 = 1 then
88306: LD_VAR 0 3
88310: PUSH
88311: LD_INT 1
88313: EQUAL
88314: IFFALSE 88326
// globalGameSaveCounter := p4 ;
88316: LD_ADDR_EXP 105
88320: PUSH
88321: LD_VAR 0 4
88325: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
88326: LD_VAR 0 3
88330: PUSH
88331: LD_INT 2
88333: EQUAL
88334: PUSH
88335: LD_EXP 105
88339: AND
88340: IFFALSE 88359
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
88342: LD_STRING setGameSaveCounter(
88344: PUSH
88345: LD_EXP 105
88349: STR
88350: PUSH
88351: LD_STRING )
88353: STR
88354: PPUSH
88355: CALL_OW 559
// display_strings := globalGameSaveCounter ;
88359: LD_ADDR_OWVAR 47
88363: PUSH
88364: LD_EXP 105
88368: ST_TO_ADDR
// end ; end ;
88369: LD_VAR 0 7
88373: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
88374: GO 88376
88376: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88377: LD_STRING initStreamRollete();
88379: PPUSH
88380: CALL_OW 559
// InitStreamMode ;
88384: CALL 88396 0 0
// DefineStreamItems ( false ) ;
88388: LD_INT 0
88390: PPUSH
88391: CALL 88860 0 1
// end ;
88395: END
// function InitStreamMode ; begin
88396: LD_INT 0
88398: PPUSH
// streamModeActive := false ;
88399: LD_ADDR_EXP 106
88403: PUSH
88404: LD_INT 0
88406: ST_TO_ADDR
// normalCounter := 36 ;
88407: LD_ADDR_EXP 107
88411: PUSH
88412: LD_INT 36
88414: ST_TO_ADDR
// hardcoreCounter := 18 ;
88415: LD_ADDR_EXP 108
88419: PUSH
88420: LD_INT 18
88422: ST_TO_ADDR
// sRocket := false ;
88423: LD_ADDR_EXP 111
88427: PUSH
88428: LD_INT 0
88430: ST_TO_ADDR
// sSpeed := false ;
88431: LD_ADDR_EXP 110
88435: PUSH
88436: LD_INT 0
88438: ST_TO_ADDR
// sEngine := false ;
88439: LD_ADDR_EXP 112
88443: PUSH
88444: LD_INT 0
88446: ST_TO_ADDR
// sSpec := false ;
88447: LD_ADDR_EXP 109
88451: PUSH
88452: LD_INT 0
88454: ST_TO_ADDR
// sLevel := false ;
88455: LD_ADDR_EXP 113
88459: PUSH
88460: LD_INT 0
88462: ST_TO_ADDR
// sArmoury := false ;
88463: LD_ADDR_EXP 114
88467: PUSH
88468: LD_INT 0
88470: ST_TO_ADDR
// sRadar := false ;
88471: LD_ADDR_EXP 115
88475: PUSH
88476: LD_INT 0
88478: ST_TO_ADDR
// sBunker := false ;
88479: LD_ADDR_EXP 116
88483: PUSH
88484: LD_INT 0
88486: ST_TO_ADDR
// sHack := false ;
88487: LD_ADDR_EXP 117
88491: PUSH
88492: LD_INT 0
88494: ST_TO_ADDR
// sFire := false ;
88495: LD_ADDR_EXP 118
88499: PUSH
88500: LD_INT 0
88502: ST_TO_ADDR
// sRefresh := false ;
88503: LD_ADDR_EXP 119
88507: PUSH
88508: LD_INT 0
88510: ST_TO_ADDR
// sExp := false ;
88511: LD_ADDR_EXP 120
88515: PUSH
88516: LD_INT 0
88518: ST_TO_ADDR
// sDepot := false ;
88519: LD_ADDR_EXP 121
88523: PUSH
88524: LD_INT 0
88526: ST_TO_ADDR
// sFlag := false ;
88527: LD_ADDR_EXP 122
88531: PUSH
88532: LD_INT 0
88534: ST_TO_ADDR
// sKamikadze := false ;
88535: LD_ADDR_EXP 130
88539: PUSH
88540: LD_INT 0
88542: ST_TO_ADDR
// sTroll := false ;
88543: LD_ADDR_EXP 131
88547: PUSH
88548: LD_INT 0
88550: ST_TO_ADDR
// sSlow := false ;
88551: LD_ADDR_EXP 132
88555: PUSH
88556: LD_INT 0
88558: ST_TO_ADDR
// sLack := false ;
88559: LD_ADDR_EXP 133
88563: PUSH
88564: LD_INT 0
88566: ST_TO_ADDR
// sTank := false ;
88567: LD_ADDR_EXP 135
88571: PUSH
88572: LD_INT 0
88574: ST_TO_ADDR
// sRemote := false ;
88575: LD_ADDR_EXP 136
88579: PUSH
88580: LD_INT 0
88582: ST_TO_ADDR
// sPowell := false ;
88583: LD_ADDR_EXP 137
88587: PUSH
88588: LD_INT 0
88590: ST_TO_ADDR
// sTeleport := false ;
88591: LD_ADDR_EXP 140
88595: PUSH
88596: LD_INT 0
88598: ST_TO_ADDR
// sOilTower := false ;
88599: LD_ADDR_EXP 142
88603: PUSH
88604: LD_INT 0
88606: ST_TO_ADDR
// sShovel := false ;
88607: LD_ADDR_EXP 143
88611: PUSH
88612: LD_INT 0
88614: ST_TO_ADDR
// sSheik := false ;
88615: LD_ADDR_EXP 144
88619: PUSH
88620: LD_INT 0
88622: ST_TO_ADDR
// sEarthquake := false ;
88623: LD_ADDR_EXP 146
88627: PUSH
88628: LD_INT 0
88630: ST_TO_ADDR
// sAI := false ;
88631: LD_ADDR_EXP 147
88635: PUSH
88636: LD_INT 0
88638: ST_TO_ADDR
// sCargo := false ;
88639: LD_ADDR_EXP 150
88643: PUSH
88644: LD_INT 0
88646: ST_TO_ADDR
// sDLaser := false ;
88647: LD_ADDR_EXP 151
88651: PUSH
88652: LD_INT 0
88654: ST_TO_ADDR
// sExchange := false ;
88655: LD_ADDR_EXP 152
88659: PUSH
88660: LD_INT 0
88662: ST_TO_ADDR
// sFac := false ;
88663: LD_ADDR_EXP 153
88667: PUSH
88668: LD_INT 0
88670: ST_TO_ADDR
// sPower := false ;
88671: LD_ADDR_EXP 154
88675: PUSH
88676: LD_INT 0
88678: ST_TO_ADDR
// sRandom := false ;
88679: LD_ADDR_EXP 155
88683: PUSH
88684: LD_INT 0
88686: ST_TO_ADDR
// sShield := false ;
88687: LD_ADDR_EXP 156
88691: PUSH
88692: LD_INT 0
88694: ST_TO_ADDR
// sTime := false ;
88695: LD_ADDR_EXP 157
88699: PUSH
88700: LD_INT 0
88702: ST_TO_ADDR
// sTools := false ;
88703: LD_ADDR_EXP 158
88707: PUSH
88708: LD_INT 0
88710: ST_TO_ADDR
// sSold := false ;
88711: LD_ADDR_EXP 123
88715: PUSH
88716: LD_INT 0
88718: ST_TO_ADDR
// sDiff := false ;
88719: LD_ADDR_EXP 124
88723: PUSH
88724: LD_INT 0
88726: ST_TO_ADDR
// sFog := false ;
88727: LD_ADDR_EXP 127
88731: PUSH
88732: LD_INT 0
88734: ST_TO_ADDR
// sReset := false ;
88735: LD_ADDR_EXP 128
88739: PUSH
88740: LD_INT 0
88742: ST_TO_ADDR
// sSun := false ;
88743: LD_ADDR_EXP 129
88747: PUSH
88748: LD_INT 0
88750: ST_TO_ADDR
// sTiger := false ;
88751: LD_ADDR_EXP 125
88755: PUSH
88756: LD_INT 0
88758: ST_TO_ADDR
// sBomb := false ;
88759: LD_ADDR_EXP 126
88763: PUSH
88764: LD_INT 0
88766: ST_TO_ADDR
// sWound := false ;
88767: LD_ADDR_EXP 134
88771: PUSH
88772: LD_INT 0
88774: ST_TO_ADDR
// sBetray := false ;
88775: LD_ADDR_EXP 138
88779: PUSH
88780: LD_INT 0
88782: ST_TO_ADDR
// sContamin := false ;
88783: LD_ADDR_EXP 139
88787: PUSH
88788: LD_INT 0
88790: ST_TO_ADDR
// sOil := false ;
88791: LD_ADDR_EXP 141
88795: PUSH
88796: LD_INT 0
88798: ST_TO_ADDR
// sStu := false ;
88799: LD_ADDR_EXP 145
88803: PUSH
88804: LD_INT 0
88806: ST_TO_ADDR
// sBazooka := false ;
88807: LD_ADDR_EXP 148
88811: PUSH
88812: LD_INT 0
88814: ST_TO_ADDR
// sMortar := false ;
88815: LD_ADDR_EXP 149
88819: PUSH
88820: LD_INT 0
88822: ST_TO_ADDR
// sRanger := false ;
88823: LD_ADDR_EXP 159
88827: PUSH
88828: LD_INT 0
88830: ST_TO_ADDR
// sComputer := false ;
88831: LD_ADDR_EXP 160
88835: PUSH
88836: LD_INT 0
88838: ST_TO_ADDR
// s30 := false ;
88839: LD_ADDR_EXP 161
88843: PUSH
88844: LD_INT 0
88846: ST_TO_ADDR
// s60 := false ;
88847: LD_ADDR_EXP 162
88851: PUSH
88852: LD_INT 0
88854: ST_TO_ADDR
// end ;
88855: LD_VAR 0 1
88859: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88860: LD_INT 0
88862: PPUSH
88863: PPUSH
88864: PPUSH
88865: PPUSH
88866: PPUSH
88867: PPUSH
88868: PPUSH
// result := [ ] ;
88869: LD_ADDR_VAR 0 2
88873: PUSH
88874: EMPTY
88875: ST_TO_ADDR
// if campaign_id = 1 then
88876: LD_OWVAR 69
88880: PUSH
88881: LD_INT 1
88883: EQUAL
88884: IFFALSE 92050
// begin case mission_number of 1 :
88886: LD_OWVAR 70
88890: PUSH
88891: LD_INT 1
88893: DOUBLE
88894: EQUAL
88895: IFTRUE 88899
88897: GO 88975
88899: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88900: LD_ADDR_VAR 0 2
88904: PUSH
88905: LD_INT 2
88907: PUSH
88908: LD_INT 4
88910: PUSH
88911: LD_INT 11
88913: PUSH
88914: LD_INT 12
88916: PUSH
88917: LD_INT 15
88919: PUSH
88920: LD_INT 16
88922: PUSH
88923: LD_INT 22
88925: PUSH
88926: LD_INT 23
88928: PUSH
88929: LD_INT 26
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 101
88945: PUSH
88946: LD_INT 102
88948: PUSH
88949: LD_INT 106
88951: PUSH
88952: LD_INT 116
88954: PUSH
88955: LD_INT 117
88957: PUSH
88958: LD_INT 118
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: ST_TO_ADDR
88973: GO 92048
88975: LD_INT 2
88977: DOUBLE
88978: EQUAL
88979: IFTRUE 88983
88981: GO 89067
88983: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88984: LD_ADDR_VAR 0 2
88988: PUSH
88989: LD_INT 2
88991: PUSH
88992: LD_INT 4
88994: PUSH
88995: LD_INT 11
88997: PUSH
88998: LD_INT 12
89000: PUSH
89001: LD_INT 15
89003: PUSH
89004: LD_INT 16
89006: PUSH
89007: LD_INT 22
89009: PUSH
89010: LD_INT 23
89012: PUSH
89013: LD_INT 26
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 101
89029: PUSH
89030: LD_INT 102
89032: PUSH
89033: LD_INT 105
89035: PUSH
89036: LD_INT 106
89038: PUSH
89039: LD_INT 108
89041: PUSH
89042: LD_INT 116
89044: PUSH
89045: LD_INT 117
89047: PUSH
89048: LD_INT 118
89050: PUSH
89051: EMPTY
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: ST_TO_ADDR
89065: GO 92048
89067: LD_INT 3
89069: DOUBLE
89070: EQUAL
89071: IFTRUE 89075
89073: GO 89163
89075: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89076: LD_ADDR_VAR 0 2
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: LD_INT 4
89086: PUSH
89087: LD_INT 5
89089: PUSH
89090: LD_INT 11
89092: PUSH
89093: LD_INT 12
89095: PUSH
89096: LD_INT 15
89098: PUSH
89099: LD_INT 16
89101: PUSH
89102: LD_INT 22
89104: PUSH
89105: LD_INT 26
89107: PUSH
89108: LD_INT 36
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 101
89125: PUSH
89126: LD_INT 102
89128: PUSH
89129: LD_INT 105
89131: PUSH
89132: LD_INT 106
89134: PUSH
89135: LD_INT 108
89137: PUSH
89138: LD_INT 116
89140: PUSH
89141: LD_INT 117
89143: PUSH
89144: LD_INT 118
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: ST_TO_ADDR
89161: GO 92048
89163: LD_INT 4
89165: DOUBLE
89166: EQUAL
89167: IFTRUE 89171
89169: GO 89267
89171: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89172: LD_ADDR_VAR 0 2
89176: PUSH
89177: LD_INT 2
89179: PUSH
89180: LD_INT 4
89182: PUSH
89183: LD_INT 5
89185: PUSH
89186: LD_INT 8
89188: PUSH
89189: LD_INT 11
89191: PUSH
89192: LD_INT 12
89194: PUSH
89195: LD_INT 15
89197: PUSH
89198: LD_INT 16
89200: PUSH
89201: LD_INT 22
89203: PUSH
89204: LD_INT 23
89206: PUSH
89207: LD_INT 26
89209: PUSH
89210: LD_INT 36
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: PUSH
89227: LD_INT 101
89229: PUSH
89230: LD_INT 102
89232: PUSH
89233: LD_INT 105
89235: PUSH
89236: LD_INT 106
89238: PUSH
89239: LD_INT 108
89241: PUSH
89242: LD_INT 116
89244: PUSH
89245: LD_INT 117
89247: PUSH
89248: LD_INT 118
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: ST_TO_ADDR
89265: GO 92048
89267: LD_INT 5
89269: DOUBLE
89270: EQUAL
89271: IFTRUE 89275
89273: GO 89387
89275: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89276: LD_ADDR_VAR 0 2
89280: PUSH
89281: LD_INT 2
89283: PUSH
89284: LD_INT 4
89286: PUSH
89287: LD_INT 5
89289: PUSH
89290: LD_INT 6
89292: PUSH
89293: LD_INT 8
89295: PUSH
89296: LD_INT 11
89298: PUSH
89299: LD_INT 12
89301: PUSH
89302: LD_INT 15
89304: PUSH
89305: LD_INT 16
89307: PUSH
89308: LD_INT 22
89310: PUSH
89311: LD_INT 23
89313: PUSH
89314: LD_INT 25
89316: PUSH
89317: LD_INT 26
89319: PUSH
89320: LD_INT 36
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: PUSH
89339: LD_INT 101
89341: PUSH
89342: LD_INT 102
89344: PUSH
89345: LD_INT 105
89347: PUSH
89348: LD_INT 106
89350: PUSH
89351: LD_INT 108
89353: PUSH
89354: LD_INT 109
89356: PUSH
89357: LD_INT 112
89359: PUSH
89360: LD_INT 116
89362: PUSH
89363: LD_INT 117
89365: PUSH
89366: LD_INT 118
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: ST_TO_ADDR
89385: GO 92048
89387: LD_INT 6
89389: DOUBLE
89390: EQUAL
89391: IFTRUE 89395
89393: GO 89527
89395: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89396: LD_ADDR_VAR 0 2
89400: PUSH
89401: LD_INT 2
89403: PUSH
89404: LD_INT 4
89406: PUSH
89407: LD_INT 5
89409: PUSH
89410: LD_INT 6
89412: PUSH
89413: LD_INT 8
89415: PUSH
89416: LD_INT 11
89418: PUSH
89419: LD_INT 12
89421: PUSH
89422: LD_INT 15
89424: PUSH
89425: LD_INT 16
89427: PUSH
89428: LD_INT 20
89430: PUSH
89431: LD_INT 21
89433: PUSH
89434: LD_INT 22
89436: PUSH
89437: LD_INT 23
89439: PUSH
89440: LD_INT 25
89442: PUSH
89443: LD_INT 26
89445: PUSH
89446: LD_INT 30
89448: PUSH
89449: LD_INT 31
89451: PUSH
89452: LD_INT 32
89454: PUSH
89455: LD_INT 36
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 101
89481: PUSH
89482: LD_INT 102
89484: PUSH
89485: LD_INT 105
89487: PUSH
89488: LD_INT 106
89490: PUSH
89491: LD_INT 108
89493: PUSH
89494: LD_INT 109
89496: PUSH
89497: LD_INT 112
89499: PUSH
89500: LD_INT 116
89502: PUSH
89503: LD_INT 117
89505: PUSH
89506: LD_INT 118
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: ST_TO_ADDR
89525: GO 92048
89527: LD_INT 7
89529: DOUBLE
89530: EQUAL
89531: IFTRUE 89535
89533: GO 89647
89535: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89536: LD_ADDR_VAR 0 2
89540: PUSH
89541: LD_INT 2
89543: PUSH
89544: LD_INT 4
89546: PUSH
89547: LD_INT 5
89549: PUSH
89550: LD_INT 7
89552: PUSH
89553: LD_INT 11
89555: PUSH
89556: LD_INT 12
89558: PUSH
89559: LD_INT 15
89561: PUSH
89562: LD_INT 16
89564: PUSH
89565: LD_INT 20
89567: PUSH
89568: LD_INT 21
89570: PUSH
89571: LD_INT 22
89573: PUSH
89574: LD_INT 23
89576: PUSH
89577: LD_INT 25
89579: PUSH
89580: LD_INT 26
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 101
89601: PUSH
89602: LD_INT 102
89604: PUSH
89605: LD_INT 103
89607: PUSH
89608: LD_INT 105
89610: PUSH
89611: LD_INT 106
89613: PUSH
89614: LD_INT 108
89616: PUSH
89617: LD_INT 112
89619: PUSH
89620: LD_INT 116
89622: PUSH
89623: LD_INT 117
89625: PUSH
89626: LD_INT 118
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: ST_TO_ADDR
89645: GO 92048
89647: LD_INT 8
89649: DOUBLE
89650: EQUAL
89651: IFTRUE 89655
89653: GO 89795
89655: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89656: LD_ADDR_VAR 0 2
89660: PUSH
89661: LD_INT 2
89663: PUSH
89664: LD_INT 4
89666: PUSH
89667: LD_INT 5
89669: PUSH
89670: LD_INT 6
89672: PUSH
89673: LD_INT 7
89675: PUSH
89676: LD_INT 8
89678: PUSH
89679: LD_INT 11
89681: PUSH
89682: LD_INT 12
89684: PUSH
89685: LD_INT 15
89687: PUSH
89688: LD_INT 16
89690: PUSH
89691: LD_INT 20
89693: PUSH
89694: LD_INT 21
89696: PUSH
89697: LD_INT 22
89699: PUSH
89700: LD_INT 23
89702: PUSH
89703: LD_INT 25
89705: PUSH
89706: LD_INT 26
89708: PUSH
89709: LD_INT 30
89711: PUSH
89712: LD_INT 31
89714: PUSH
89715: LD_INT 32
89717: PUSH
89718: LD_INT 36
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 101
89745: PUSH
89746: LD_INT 102
89748: PUSH
89749: LD_INT 103
89751: PUSH
89752: LD_INT 105
89754: PUSH
89755: LD_INT 106
89757: PUSH
89758: LD_INT 108
89760: PUSH
89761: LD_INT 109
89763: PUSH
89764: LD_INT 112
89766: PUSH
89767: LD_INT 116
89769: PUSH
89770: LD_INT 117
89772: PUSH
89773: LD_INT 118
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: ST_TO_ADDR
89793: GO 92048
89795: LD_INT 9
89797: DOUBLE
89798: EQUAL
89799: IFTRUE 89803
89801: GO 89951
89803: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89804: LD_ADDR_VAR 0 2
89808: PUSH
89809: LD_INT 2
89811: PUSH
89812: LD_INT 4
89814: PUSH
89815: LD_INT 5
89817: PUSH
89818: LD_INT 6
89820: PUSH
89821: LD_INT 7
89823: PUSH
89824: LD_INT 8
89826: PUSH
89827: LD_INT 11
89829: PUSH
89830: LD_INT 12
89832: PUSH
89833: LD_INT 15
89835: PUSH
89836: LD_INT 16
89838: PUSH
89839: LD_INT 20
89841: PUSH
89842: LD_INT 21
89844: PUSH
89845: LD_INT 22
89847: PUSH
89848: LD_INT 23
89850: PUSH
89851: LD_INT 25
89853: PUSH
89854: LD_INT 26
89856: PUSH
89857: LD_INT 28
89859: PUSH
89860: LD_INT 30
89862: PUSH
89863: LD_INT 31
89865: PUSH
89866: LD_INT 32
89868: PUSH
89869: LD_INT 36
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 101
89897: PUSH
89898: LD_INT 102
89900: PUSH
89901: LD_INT 103
89903: PUSH
89904: LD_INT 105
89906: PUSH
89907: LD_INT 106
89909: PUSH
89910: LD_INT 108
89912: PUSH
89913: LD_INT 109
89915: PUSH
89916: LD_INT 112
89918: PUSH
89919: LD_INT 114
89921: PUSH
89922: LD_INT 116
89924: PUSH
89925: LD_INT 117
89927: PUSH
89928: LD_INT 118
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: ST_TO_ADDR
89949: GO 92048
89951: LD_INT 10
89953: DOUBLE
89954: EQUAL
89955: IFTRUE 89959
89957: GO 90155
89959: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89960: LD_ADDR_VAR 0 2
89964: PUSH
89965: LD_INT 2
89967: PUSH
89968: LD_INT 4
89970: PUSH
89971: LD_INT 5
89973: PUSH
89974: LD_INT 6
89976: PUSH
89977: LD_INT 7
89979: PUSH
89980: LD_INT 8
89982: PUSH
89983: LD_INT 9
89985: PUSH
89986: LD_INT 10
89988: PUSH
89989: LD_INT 11
89991: PUSH
89992: LD_INT 12
89994: PUSH
89995: LD_INT 13
89997: PUSH
89998: LD_INT 14
90000: PUSH
90001: LD_INT 15
90003: PUSH
90004: LD_INT 16
90006: PUSH
90007: LD_INT 17
90009: PUSH
90010: LD_INT 18
90012: PUSH
90013: LD_INT 19
90015: PUSH
90016: LD_INT 20
90018: PUSH
90019: LD_INT 21
90021: PUSH
90022: LD_INT 22
90024: PUSH
90025: LD_INT 23
90027: PUSH
90028: LD_INT 24
90030: PUSH
90031: LD_INT 25
90033: PUSH
90034: LD_INT 26
90036: PUSH
90037: LD_INT 28
90039: PUSH
90040: LD_INT 30
90042: PUSH
90043: LD_INT 31
90045: PUSH
90046: LD_INT 32
90048: PUSH
90049: LD_INT 36
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 101
90085: PUSH
90086: LD_INT 102
90088: PUSH
90089: LD_INT 103
90091: PUSH
90092: LD_INT 104
90094: PUSH
90095: LD_INT 105
90097: PUSH
90098: LD_INT 106
90100: PUSH
90101: LD_INT 107
90103: PUSH
90104: LD_INT 108
90106: PUSH
90107: LD_INT 109
90109: PUSH
90110: LD_INT 110
90112: PUSH
90113: LD_INT 111
90115: PUSH
90116: LD_INT 112
90118: PUSH
90119: LD_INT 114
90121: PUSH
90122: LD_INT 116
90124: PUSH
90125: LD_INT 117
90127: PUSH
90128: LD_INT 118
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: ST_TO_ADDR
90153: GO 92048
90155: LD_INT 11
90157: DOUBLE
90158: EQUAL
90159: IFTRUE 90163
90161: GO 90367
90163: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90164: LD_ADDR_VAR 0 2
90168: PUSH
90169: LD_INT 2
90171: PUSH
90172: LD_INT 3
90174: PUSH
90175: LD_INT 4
90177: PUSH
90178: LD_INT 5
90180: PUSH
90181: LD_INT 6
90183: PUSH
90184: LD_INT 7
90186: PUSH
90187: LD_INT 8
90189: PUSH
90190: LD_INT 9
90192: PUSH
90193: LD_INT 10
90195: PUSH
90196: LD_INT 11
90198: PUSH
90199: LD_INT 12
90201: PUSH
90202: LD_INT 13
90204: PUSH
90205: LD_INT 14
90207: PUSH
90208: LD_INT 15
90210: PUSH
90211: LD_INT 16
90213: PUSH
90214: LD_INT 17
90216: PUSH
90217: LD_INT 18
90219: PUSH
90220: LD_INT 19
90222: PUSH
90223: LD_INT 20
90225: PUSH
90226: LD_INT 21
90228: PUSH
90229: LD_INT 22
90231: PUSH
90232: LD_INT 23
90234: PUSH
90235: LD_INT 24
90237: PUSH
90238: LD_INT 25
90240: PUSH
90241: LD_INT 26
90243: PUSH
90244: LD_INT 28
90246: PUSH
90247: LD_INT 30
90249: PUSH
90250: LD_INT 31
90252: PUSH
90253: LD_INT 32
90255: PUSH
90256: LD_INT 34
90258: PUSH
90259: LD_INT 36
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 101
90297: PUSH
90298: LD_INT 102
90300: PUSH
90301: LD_INT 103
90303: PUSH
90304: LD_INT 104
90306: PUSH
90307: LD_INT 105
90309: PUSH
90310: LD_INT 106
90312: PUSH
90313: LD_INT 107
90315: PUSH
90316: LD_INT 108
90318: PUSH
90319: LD_INT 109
90321: PUSH
90322: LD_INT 110
90324: PUSH
90325: LD_INT 111
90327: PUSH
90328: LD_INT 112
90330: PUSH
90331: LD_INT 114
90333: PUSH
90334: LD_INT 116
90336: PUSH
90337: LD_INT 117
90339: PUSH
90340: LD_INT 118
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: PUSH
90361: EMPTY
90362: LIST
90363: LIST
90364: ST_TO_ADDR
90365: GO 92048
90367: LD_INT 12
90369: DOUBLE
90370: EQUAL
90371: IFTRUE 90375
90373: GO 90595
90375: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90376: LD_ADDR_VAR 0 2
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: LD_INT 2
90386: PUSH
90387: LD_INT 3
90389: PUSH
90390: LD_INT 4
90392: PUSH
90393: LD_INT 5
90395: PUSH
90396: LD_INT 6
90398: PUSH
90399: LD_INT 7
90401: PUSH
90402: LD_INT 8
90404: PUSH
90405: LD_INT 9
90407: PUSH
90408: LD_INT 10
90410: PUSH
90411: LD_INT 11
90413: PUSH
90414: LD_INT 12
90416: PUSH
90417: LD_INT 13
90419: PUSH
90420: LD_INT 14
90422: PUSH
90423: LD_INT 15
90425: PUSH
90426: LD_INT 16
90428: PUSH
90429: LD_INT 17
90431: PUSH
90432: LD_INT 18
90434: PUSH
90435: LD_INT 19
90437: PUSH
90438: LD_INT 20
90440: PUSH
90441: LD_INT 21
90443: PUSH
90444: LD_INT 22
90446: PUSH
90447: LD_INT 23
90449: PUSH
90450: LD_INT 24
90452: PUSH
90453: LD_INT 25
90455: PUSH
90456: LD_INT 26
90458: PUSH
90459: LD_INT 27
90461: PUSH
90462: LD_INT 28
90464: PUSH
90465: LD_INT 30
90467: PUSH
90468: LD_INT 31
90470: PUSH
90471: LD_INT 32
90473: PUSH
90474: LD_INT 33
90476: PUSH
90477: LD_INT 34
90479: PUSH
90480: LD_INT 36
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 101
90521: PUSH
90522: LD_INT 102
90524: PUSH
90525: LD_INT 103
90527: PUSH
90528: LD_INT 104
90530: PUSH
90531: LD_INT 105
90533: PUSH
90534: LD_INT 106
90536: PUSH
90537: LD_INT 107
90539: PUSH
90540: LD_INT 108
90542: PUSH
90543: LD_INT 109
90545: PUSH
90546: LD_INT 110
90548: PUSH
90549: LD_INT 111
90551: PUSH
90552: LD_INT 112
90554: PUSH
90555: LD_INT 113
90557: PUSH
90558: LD_INT 114
90560: PUSH
90561: LD_INT 116
90563: PUSH
90564: LD_INT 117
90566: PUSH
90567: LD_INT 118
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: ST_TO_ADDR
90593: GO 92048
90595: LD_INT 13
90597: DOUBLE
90598: EQUAL
90599: IFTRUE 90603
90601: GO 90811
90603: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90604: LD_ADDR_VAR 0 2
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: LD_INT 2
90614: PUSH
90615: LD_INT 3
90617: PUSH
90618: LD_INT 4
90620: PUSH
90621: LD_INT 5
90623: PUSH
90624: LD_INT 8
90626: PUSH
90627: LD_INT 9
90629: PUSH
90630: LD_INT 10
90632: PUSH
90633: LD_INT 11
90635: PUSH
90636: LD_INT 12
90638: PUSH
90639: LD_INT 14
90641: PUSH
90642: LD_INT 15
90644: PUSH
90645: LD_INT 16
90647: PUSH
90648: LD_INT 17
90650: PUSH
90651: LD_INT 18
90653: PUSH
90654: LD_INT 19
90656: PUSH
90657: LD_INT 20
90659: PUSH
90660: LD_INT 21
90662: PUSH
90663: LD_INT 22
90665: PUSH
90666: LD_INT 23
90668: PUSH
90669: LD_INT 24
90671: PUSH
90672: LD_INT 25
90674: PUSH
90675: LD_INT 26
90677: PUSH
90678: LD_INT 27
90680: PUSH
90681: LD_INT 28
90683: PUSH
90684: LD_INT 30
90686: PUSH
90687: LD_INT 31
90689: PUSH
90690: LD_INT 32
90692: PUSH
90693: LD_INT 33
90695: PUSH
90696: LD_INT 34
90698: PUSH
90699: LD_INT 36
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 101
90737: PUSH
90738: LD_INT 102
90740: PUSH
90741: LD_INT 103
90743: PUSH
90744: LD_INT 104
90746: PUSH
90747: LD_INT 105
90749: PUSH
90750: LD_INT 106
90752: PUSH
90753: LD_INT 107
90755: PUSH
90756: LD_INT 108
90758: PUSH
90759: LD_INT 109
90761: PUSH
90762: LD_INT 110
90764: PUSH
90765: LD_INT 111
90767: PUSH
90768: LD_INT 112
90770: PUSH
90771: LD_INT 113
90773: PUSH
90774: LD_INT 114
90776: PUSH
90777: LD_INT 116
90779: PUSH
90780: LD_INT 117
90782: PUSH
90783: LD_INT 118
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: ST_TO_ADDR
90809: GO 92048
90811: LD_INT 14
90813: DOUBLE
90814: EQUAL
90815: IFTRUE 90819
90817: GO 91043
90819: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90820: LD_ADDR_VAR 0 2
90824: PUSH
90825: LD_INT 1
90827: PUSH
90828: LD_INT 2
90830: PUSH
90831: LD_INT 3
90833: PUSH
90834: LD_INT 4
90836: PUSH
90837: LD_INT 5
90839: PUSH
90840: LD_INT 6
90842: PUSH
90843: LD_INT 7
90845: PUSH
90846: LD_INT 8
90848: PUSH
90849: LD_INT 9
90851: PUSH
90852: LD_INT 10
90854: PUSH
90855: LD_INT 11
90857: PUSH
90858: LD_INT 12
90860: PUSH
90861: LD_INT 13
90863: PUSH
90864: LD_INT 14
90866: PUSH
90867: LD_INT 15
90869: PUSH
90870: LD_INT 16
90872: PUSH
90873: LD_INT 17
90875: PUSH
90876: LD_INT 18
90878: PUSH
90879: LD_INT 19
90881: PUSH
90882: LD_INT 20
90884: PUSH
90885: LD_INT 21
90887: PUSH
90888: LD_INT 22
90890: PUSH
90891: LD_INT 23
90893: PUSH
90894: LD_INT 24
90896: PUSH
90897: LD_INT 25
90899: PUSH
90900: LD_INT 26
90902: PUSH
90903: LD_INT 27
90905: PUSH
90906: LD_INT 28
90908: PUSH
90909: LD_INT 29
90911: PUSH
90912: LD_INT 30
90914: PUSH
90915: LD_INT 31
90917: PUSH
90918: LD_INT 32
90920: PUSH
90921: LD_INT 33
90923: PUSH
90924: LD_INT 34
90926: PUSH
90927: LD_INT 36
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 101
90969: PUSH
90970: LD_INT 102
90972: PUSH
90973: LD_INT 103
90975: PUSH
90976: LD_INT 104
90978: PUSH
90979: LD_INT 105
90981: PUSH
90982: LD_INT 106
90984: PUSH
90985: LD_INT 107
90987: PUSH
90988: LD_INT 108
90990: PUSH
90991: LD_INT 109
90993: PUSH
90994: LD_INT 110
90996: PUSH
90997: LD_INT 111
90999: PUSH
91000: LD_INT 112
91002: PUSH
91003: LD_INT 113
91005: PUSH
91006: LD_INT 114
91008: PUSH
91009: LD_INT 116
91011: PUSH
91012: LD_INT 117
91014: PUSH
91015: LD_INT 118
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: ST_TO_ADDR
91041: GO 92048
91043: LD_INT 15
91045: DOUBLE
91046: EQUAL
91047: IFTRUE 91051
91049: GO 91275
91051: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91052: LD_ADDR_VAR 0 2
91056: PUSH
91057: LD_INT 1
91059: PUSH
91060: LD_INT 2
91062: PUSH
91063: LD_INT 3
91065: PUSH
91066: LD_INT 4
91068: PUSH
91069: LD_INT 5
91071: PUSH
91072: LD_INT 6
91074: PUSH
91075: LD_INT 7
91077: PUSH
91078: LD_INT 8
91080: PUSH
91081: LD_INT 9
91083: PUSH
91084: LD_INT 10
91086: PUSH
91087: LD_INT 11
91089: PUSH
91090: LD_INT 12
91092: PUSH
91093: LD_INT 13
91095: PUSH
91096: LD_INT 14
91098: PUSH
91099: LD_INT 15
91101: PUSH
91102: LD_INT 16
91104: PUSH
91105: LD_INT 17
91107: PUSH
91108: LD_INT 18
91110: PUSH
91111: LD_INT 19
91113: PUSH
91114: LD_INT 20
91116: PUSH
91117: LD_INT 21
91119: PUSH
91120: LD_INT 22
91122: PUSH
91123: LD_INT 23
91125: PUSH
91126: LD_INT 24
91128: PUSH
91129: LD_INT 25
91131: PUSH
91132: LD_INT 26
91134: PUSH
91135: LD_INT 27
91137: PUSH
91138: LD_INT 28
91140: PUSH
91141: LD_INT 29
91143: PUSH
91144: LD_INT 30
91146: PUSH
91147: LD_INT 31
91149: PUSH
91150: LD_INT 32
91152: PUSH
91153: LD_INT 33
91155: PUSH
91156: LD_INT 34
91158: PUSH
91159: LD_INT 36
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 101
91201: PUSH
91202: LD_INT 102
91204: PUSH
91205: LD_INT 103
91207: PUSH
91208: LD_INT 104
91210: PUSH
91211: LD_INT 105
91213: PUSH
91214: LD_INT 106
91216: PUSH
91217: LD_INT 107
91219: PUSH
91220: LD_INT 108
91222: PUSH
91223: LD_INT 109
91225: PUSH
91226: LD_INT 110
91228: PUSH
91229: LD_INT 111
91231: PUSH
91232: LD_INT 112
91234: PUSH
91235: LD_INT 113
91237: PUSH
91238: LD_INT 114
91240: PUSH
91241: LD_INT 116
91243: PUSH
91244: LD_INT 117
91246: PUSH
91247: LD_INT 118
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: ST_TO_ADDR
91273: GO 92048
91275: LD_INT 16
91277: DOUBLE
91278: EQUAL
91279: IFTRUE 91283
91281: GO 91419
91283: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91284: LD_ADDR_VAR 0 2
91288: PUSH
91289: LD_INT 2
91291: PUSH
91292: LD_INT 4
91294: PUSH
91295: LD_INT 5
91297: PUSH
91298: LD_INT 7
91300: PUSH
91301: LD_INT 11
91303: PUSH
91304: LD_INT 12
91306: PUSH
91307: LD_INT 15
91309: PUSH
91310: LD_INT 16
91312: PUSH
91313: LD_INT 20
91315: PUSH
91316: LD_INT 21
91318: PUSH
91319: LD_INT 22
91321: PUSH
91322: LD_INT 23
91324: PUSH
91325: LD_INT 25
91327: PUSH
91328: LD_INT 26
91330: PUSH
91331: LD_INT 30
91333: PUSH
91334: LD_INT 31
91336: PUSH
91337: LD_INT 32
91339: PUSH
91340: LD_INT 33
91342: PUSH
91343: LD_INT 34
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 101
91369: PUSH
91370: LD_INT 102
91372: PUSH
91373: LD_INT 103
91375: PUSH
91376: LD_INT 106
91378: PUSH
91379: LD_INT 108
91381: PUSH
91382: LD_INT 112
91384: PUSH
91385: LD_INT 113
91387: PUSH
91388: LD_INT 114
91390: PUSH
91391: LD_INT 116
91393: PUSH
91394: LD_INT 117
91396: PUSH
91397: LD_INT 118
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: ST_TO_ADDR
91417: GO 92048
91419: LD_INT 17
91421: DOUBLE
91422: EQUAL
91423: IFTRUE 91427
91425: GO 91651
91427: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91428: LD_ADDR_VAR 0 2
91432: PUSH
91433: LD_INT 1
91435: PUSH
91436: LD_INT 2
91438: PUSH
91439: LD_INT 3
91441: PUSH
91442: LD_INT 4
91444: PUSH
91445: LD_INT 5
91447: PUSH
91448: LD_INT 6
91450: PUSH
91451: LD_INT 7
91453: PUSH
91454: LD_INT 8
91456: PUSH
91457: LD_INT 9
91459: PUSH
91460: LD_INT 10
91462: PUSH
91463: LD_INT 11
91465: PUSH
91466: LD_INT 12
91468: PUSH
91469: LD_INT 13
91471: PUSH
91472: LD_INT 14
91474: PUSH
91475: LD_INT 15
91477: PUSH
91478: LD_INT 16
91480: PUSH
91481: LD_INT 17
91483: PUSH
91484: LD_INT 18
91486: PUSH
91487: LD_INT 19
91489: PUSH
91490: LD_INT 20
91492: PUSH
91493: LD_INT 21
91495: PUSH
91496: LD_INT 22
91498: PUSH
91499: LD_INT 23
91501: PUSH
91502: LD_INT 24
91504: PUSH
91505: LD_INT 25
91507: PUSH
91508: LD_INT 26
91510: PUSH
91511: LD_INT 27
91513: PUSH
91514: LD_INT 28
91516: PUSH
91517: LD_INT 29
91519: PUSH
91520: LD_INT 30
91522: PUSH
91523: LD_INT 31
91525: PUSH
91526: LD_INT 32
91528: PUSH
91529: LD_INT 33
91531: PUSH
91532: LD_INT 34
91534: PUSH
91535: LD_INT 36
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: PUSH
91575: LD_INT 101
91577: PUSH
91578: LD_INT 102
91580: PUSH
91581: LD_INT 103
91583: PUSH
91584: LD_INT 104
91586: PUSH
91587: LD_INT 105
91589: PUSH
91590: LD_INT 106
91592: PUSH
91593: LD_INT 107
91595: PUSH
91596: LD_INT 108
91598: PUSH
91599: LD_INT 109
91601: PUSH
91602: LD_INT 110
91604: PUSH
91605: LD_INT 111
91607: PUSH
91608: LD_INT 112
91610: PUSH
91611: LD_INT 113
91613: PUSH
91614: LD_INT 114
91616: PUSH
91617: LD_INT 116
91619: PUSH
91620: LD_INT 117
91622: PUSH
91623: LD_INT 118
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: ST_TO_ADDR
91649: GO 92048
91651: LD_INT 18
91653: DOUBLE
91654: EQUAL
91655: IFTRUE 91659
91657: GO 91807
91659: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91660: LD_ADDR_VAR 0 2
91664: PUSH
91665: LD_INT 2
91667: PUSH
91668: LD_INT 4
91670: PUSH
91671: LD_INT 5
91673: PUSH
91674: LD_INT 7
91676: PUSH
91677: LD_INT 11
91679: PUSH
91680: LD_INT 12
91682: PUSH
91683: LD_INT 15
91685: PUSH
91686: LD_INT 16
91688: PUSH
91689: LD_INT 20
91691: PUSH
91692: LD_INT 21
91694: PUSH
91695: LD_INT 22
91697: PUSH
91698: LD_INT 23
91700: PUSH
91701: LD_INT 25
91703: PUSH
91704: LD_INT 26
91706: PUSH
91707: LD_INT 30
91709: PUSH
91710: LD_INT 31
91712: PUSH
91713: LD_INT 32
91715: PUSH
91716: LD_INT 33
91718: PUSH
91719: LD_INT 34
91721: PUSH
91722: LD_INT 35
91724: PUSH
91725: LD_INT 36
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 101
91753: PUSH
91754: LD_INT 102
91756: PUSH
91757: LD_INT 103
91759: PUSH
91760: LD_INT 106
91762: PUSH
91763: LD_INT 108
91765: PUSH
91766: LD_INT 112
91768: PUSH
91769: LD_INT 113
91771: PUSH
91772: LD_INT 114
91774: PUSH
91775: LD_INT 115
91777: PUSH
91778: LD_INT 116
91780: PUSH
91781: LD_INT 117
91783: PUSH
91784: LD_INT 118
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: ST_TO_ADDR
91805: GO 92048
91807: LD_INT 19
91809: DOUBLE
91810: EQUAL
91811: IFTRUE 91815
91813: GO 92047
91815: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91816: LD_ADDR_VAR 0 2
91820: PUSH
91821: LD_INT 1
91823: PUSH
91824: LD_INT 2
91826: PUSH
91827: LD_INT 3
91829: PUSH
91830: LD_INT 4
91832: PUSH
91833: LD_INT 5
91835: PUSH
91836: LD_INT 6
91838: PUSH
91839: LD_INT 7
91841: PUSH
91842: LD_INT 8
91844: PUSH
91845: LD_INT 9
91847: PUSH
91848: LD_INT 10
91850: PUSH
91851: LD_INT 11
91853: PUSH
91854: LD_INT 12
91856: PUSH
91857: LD_INT 13
91859: PUSH
91860: LD_INT 14
91862: PUSH
91863: LD_INT 15
91865: PUSH
91866: LD_INT 16
91868: PUSH
91869: LD_INT 17
91871: PUSH
91872: LD_INT 18
91874: PUSH
91875: LD_INT 19
91877: PUSH
91878: LD_INT 20
91880: PUSH
91881: LD_INT 21
91883: PUSH
91884: LD_INT 22
91886: PUSH
91887: LD_INT 23
91889: PUSH
91890: LD_INT 24
91892: PUSH
91893: LD_INT 25
91895: PUSH
91896: LD_INT 26
91898: PUSH
91899: LD_INT 27
91901: PUSH
91902: LD_INT 28
91904: PUSH
91905: LD_INT 29
91907: PUSH
91908: LD_INT 30
91910: PUSH
91911: LD_INT 31
91913: PUSH
91914: LD_INT 32
91916: PUSH
91917: LD_INT 33
91919: PUSH
91920: LD_INT 34
91922: PUSH
91923: LD_INT 35
91925: PUSH
91926: LD_INT 36
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: PUSH
91967: LD_INT 101
91969: PUSH
91970: LD_INT 102
91972: PUSH
91973: LD_INT 103
91975: PUSH
91976: LD_INT 104
91978: PUSH
91979: LD_INT 105
91981: PUSH
91982: LD_INT 106
91984: PUSH
91985: LD_INT 107
91987: PUSH
91988: LD_INT 108
91990: PUSH
91991: LD_INT 109
91993: PUSH
91994: LD_INT 110
91996: PUSH
91997: LD_INT 111
91999: PUSH
92000: LD_INT 112
92002: PUSH
92003: LD_INT 113
92005: PUSH
92006: LD_INT 114
92008: PUSH
92009: LD_INT 115
92011: PUSH
92012: LD_INT 116
92014: PUSH
92015: LD_INT 117
92017: PUSH
92018: LD_INT 118
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: ST_TO_ADDR
92045: GO 92048
92047: POP
// end else
92048: GO 92279
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92050: LD_ADDR_VAR 0 2
92054: PUSH
92055: LD_INT 1
92057: PUSH
92058: LD_INT 2
92060: PUSH
92061: LD_INT 3
92063: PUSH
92064: LD_INT 4
92066: PUSH
92067: LD_INT 5
92069: PUSH
92070: LD_INT 6
92072: PUSH
92073: LD_INT 7
92075: PUSH
92076: LD_INT 8
92078: PUSH
92079: LD_INT 9
92081: PUSH
92082: LD_INT 10
92084: PUSH
92085: LD_INT 11
92087: PUSH
92088: LD_INT 12
92090: PUSH
92091: LD_INT 13
92093: PUSH
92094: LD_INT 14
92096: PUSH
92097: LD_INT 15
92099: PUSH
92100: LD_INT 16
92102: PUSH
92103: LD_INT 17
92105: PUSH
92106: LD_INT 18
92108: PUSH
92109: LD_INT 19
92111: PUSH
92112: LD_INT 20
92114: PUSH
92115: LD_INT 21
92117: PUSH
92118: LD_INT 22
92120: PUSH
92121: LD_INT 23
92123: PUSH
92124: LD_INT 24
92126: PUSH
92127: LD_INT 25
92129: PUSH
92130: LD_INT 26
92132: PUSH
92133: LD_INT 27
92135: PUSH
92136: LD_INT 28
92138: PUSH
92139: LD_INT 29
92141: PUSH
92142: LD_INT 30
92144: PUSH
92145: LD_INT 31
92147: PUSH
92148: LD_INT 32
92150: PUSH
92151: LD_INT 33
92153: PUSH
92154: LD_INT 34
92156: PUSH
92157: LD_INT 35
92159: PUSH
92160: LD_INT 36
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 101
92203: PUSH
92204: LD_INT 102
92206: PUSH
92207: LD_INT 103
92209: PUSH
92210: LD_INT 104
92212: PUSH
92213: LD_INT 105
92215: PUSH
92216: LD_INT 106
92218: PUSH
92219: LD_INT 107
92221: PUSH
92222: LD_INT 108
92224: PUSH
92225: LD_INT 109
92227: PUSH
92228: LD_INT 110
92230: PUSH
92231: LD_INT 111
92233: PUSH
92234: LD_INT 112
92236: PUSH
92237: LD_INT 113
92239: PUSH
92240: LD_INT 114
92242: PUSH
92243: LD_INT 115
92245: PUSH
92246: LD_INT 116
92248: PUSH
92249: LD_INT 117
92251: PUSH
92252: LD_INT 118
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: ST_TO_ADDR
// if result then
92279: LD_VAR 0 2
92283: IFFALSE 93069
// begin normal :=  ;
92285: LD_ADDR_VAR 0 5
92289: PUSH
92290: LD_STRING 
92292: ST_TO_ADDR
// hardcore :=  ;
92293: LD_ADDR_VAR 0 6
92297: PUSH
92298: LD_STRING 
92300: ST_TO_ADDR
// active :=  ;
92301: LD_ADDR_VAR 0 7
92305: PUSH
92306: LD_STRING 
92308: ST_TO_ADDR
// for i = 1 to normalCounter do
92309: LD_ADDR_VAR 0 8
92313: PUSH
92314: DOUBLE
92315: LD_INT 1
92317: DEC
92318: ST_TO_ADDR
92319: LD_EXP 107
92323: PUSH
92324: FOR_TO
92325: IFFALSE 92426
// begin tmp := 0 ;
92327: LD_ADDR_VAR 0 3
92331: PUSH
92332: LD_STRING 0
92334: ST_TO_ADDR
// if result [ 1 ] then
92335: LD_VAR 0 2
92339: PUSH
92340: LD_INT 1
92342: ARRAY
92343: IFFALSE 92408
// if result [ 1 ] [ 1 ] = i then
92345: LD_VAR 0 2
92349: PUSH
92350: LD_INT 1
92352: ARRAY
92353: PUSH
92354: LD_INT 1
92356: ARRAY
92357: PUSH
92358: LD_VAR 0 8
92362: EQUAL
92363: IFFALSE 92408
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92365: LD_ADDR_VAR 0 2
92369: PUSH
92370: LD_VAR 0 2
92374: PPUSH
92375: LD_INT 1
92377: PPUSH
92378: LD_VAR 0 2
92382: PUSH
92383: LD_INT 1
92385: ARRAY
92386: PPUSH
92387: LD_INT 1
92389: PPUSH
92390: CALL_OW 3
92394: PPUSH
92395: CALL_OW 1
92399: ST_TO_ADDR
// tmp := 1 ;
92400: LD_ADDR_VAR 0 3
92404: PUSH
92405: LD_STRING 1
92407: ST_TO_ADDR
// end ; normal := normal & tmp ;
92408: LD_ADDR_VAR 0 5
92412: PUSH
92413: LD_VAR 0 5
92417: PUSH
92418: LD_VAR 0 3
92422: STR
92423: ST_TO_ADDR
// end ;
92424: GO 92324
92426: POP
92427: POP
// for i = 1 to hardcoreCounter do
92428: LD_ADDR_VAR 0 8
92432: PUSH
92433: DOUBLE
92434: LD_INT 1
92436: DEC
92437: ST_TO_ADDR
92438: LD_EXP 108
92442: PUSH
92443: FOR_TO
92444: IFFALSE 92549
// begin tmp := 0 ;
92446: LD_ADDR_VAR 0 3
92450: PUSH
92451: LD_STRING 0
92453: ST_TO_ADDR
// if result [ 2 ] then
92454: LD_VAR 0 2
92458: PUSH
92459: LD_INT 2
92461: ARRAY
92462: IFFALSE 92531
// if result [ 2 ] [ 1 ] = 100 + i then
92464: LD_VAR 0 2
92468: PUSH
92469: LD_INT 2
92471: ARRAY
92472: PUSH
92473: LD_INT 1
92475: ARRAY
92476: PUSH
92477: LD_INT 100
92479: PUSH
92480: LD_VAR 0 8
92484: PLUS
92485: EQUAL
92486: IFFALSE 92531
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92488: LD_ADDR_VAR 0 2
92492: PUSH
92493: LD_VAR 0 2
92497: PPUSH
92498: LD_INT 2
92500: PPUSH
92501: LD_VAR 0 2
92505: PUSH
92506: LD_INT 2
92508: ARRAY
92509: PPUSH
92510: LD_INT 1
92512: PPUSH
92513: CALL_OW 3
92517: PPUSH
92518: CALL_OW 1
92522: ST_TO_ADDR
// tmp := 1 ;
92523: LD_ADDR_VAR 0 3
92527: PUSH
92528: LD_STRING 1
92530: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92531: LD_ADDR_VAR 0 6
92535: PUSH
92536: LD_VAR 0 6
92540: PUSH
92541: LD_VAR 0 3
92545: STR
92546: ST_TO_ADDR
// end ;
92547: GO 92443
92549: POP
92550: POP
// if isGameLoad then
92551: LD_VAR 0 1
92555: IFFALSE 93030
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92557: LD_ADDR_VAR 0 4
92561: PUSH
92562: LD_EXP 111
92566: PUSH
92567: LD_EXP 110
92571: PUSH
92572: LD_EXP 112
92576: PUSH
92577: LD_EXP 109
92581: PUSH
92582: LD_EXP 113
92586: PUSH
92587: LD_EXP 114
92591: PUSH
92592: LD_EXP 115
92596: PUSH
92597: LD_EXP 116
92601: PUSH
92602: LD_EXP 117
92606: PUSH
92607: LD_EXP 118
92611: PUSH
92612: LD_EXP 119
92616: PUSH
92617: LD_EXP 120
92621: PUSH
92622: LD_EXP 121
92626: PUSH
92627: LD_EXP 122
92631: PUSH
92632: LD_EXP 130
92636: PUSH
92637: LD_EXP 131
92641: PUSH
92642: LD_EXP 132
92646: PUSH
92647: LD_EXP 133
92651: PUSH
92652: LD_EXP 135
92656: PUSH
92657: LD_EXP 136
92661: PUSH
92662: LD_EXP 137
92666: PUSH
92667: LD_EXP 140
92671: PUSH
92672: LD_EXP 142
92676: PUSH
92677: LD_EXP 143
92681: PUSH
92682: LD_EXP 144
92686: PUSH
92687: LD_EXP 146
92691: PUSH
92692: LD_EXP 147
92696: PUSH
92697: LD_EXP 150
92701: PUSH
92702: LD_EXP 151
92706: PUSH
92707: LD_EXP 152
92711: PUSH
92712: LD_EXP 153
92716: PUSH
92717: LD_EXP 154
92721: PUSH
92722: LD_EXP 155
92726: PUSH
92727: LD_EXP 156
92731: PUSH
92732: LD_EXP 157
92736: PUSH
92737: LD_EXP 158
92741: PUSH
92742: LD_EXP 123
92746: PUSH
92747: LD_EXP 124
92751: PUSH
92752: LD_EXP 127
92756: PUSH
92757: LD_EXP 128
92761: PUSH
92762: LD_EXP 129
92766: PUSH
92767: LD_EXP 125
92771: PUSH
92772: LD_EXP 126
92776: PUSH
92777: LD_EXP 134
92781: PUSH
92782: LD_EXP 138
92786: PUSH
92787: LD_EXP 139
92791: PUSH
92792: LD_EXP 141
92796: PUSH
92797: LD_EXP 145
92801: PUSH
92802: LD_EXP 148
92806: PUSH
92807: LD_EXP 149
92811: PUSH
92812: LD_EXP 159
92816: PUSH
92817: LD_EXP 160
92821: PUSH
92822: LD_EXP 161
92826: PUSH
92827: LD_EXP 162
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: ST_TO_ADDR
// tmp :=  ;
92888: LD_ADDR_VAR 0 3
92892: PUSH
92893: LD_STRING 
92895: ST_TO_ADDR
// for i = 1 to normalCounter do
92896: LD_ADDR_VAR 0 8
92900: PUSH
92901: DOUBLE
92902: LD_INT 1
92904: DEC
92905: ST_TO_ADDR
92906: LD_EXP 107
92910: PUSH
92911: FOR_TO
92912: IFFALSE 92948
// begin if flags [ i ] then
92914: LD_VAR 0 4
92918: PUSH
92919: LD_VAR 0 8
92923: ARRAY
92924: IFFALSE 92946
// tmp := tmp & i & ; ;
92926: LD_ADDR_VAR 0 3
92930: PUSH
92931: LD_VAR 0 3
92935: PUSH
92936: LD_VAR 0 8
92940: STR
92941: PUSH
92942: LD_STRING ;
92944: STR
92945: ST_TO_ADDR
// end ;
92946: GO 92911
92948: POP
92949: POP
// for i = 1 to hardcoreCounter do
92950: LD_ADDR_VAR 0 8
92954: PUSH
92955: DOUBLE
92956: LD_INT 1
92958: DEC
92959: ST_TO_ADDR
92960: LD_EXP 108
92964: PUSH
92965: FOR_TO
92966: IFFALSE 93012
// begin if flags [ normalCounter + i ] then
92968: LD_VAR 0 4
92972: PUSH
92973: LD_EXP 107
92977: PUSH
92978: LD_VAR 0 8
92982: PLUS
92983: ARRAY
92984: IFFALSE 93010
// tmp := tmp & ( 100 + i ) & ; ;
92986: LD_ADDR_VAR 0 3
92990: PUSH
92991: LD_VAR 0 3
92995: PUSH
92996: LD_INT 100
92998: PUSH
92999: LD_VAR 0 8
93003: PLUS
93004: STR
93005: PUSH
93006: LD_STRING ;
93008: STR
93009: ST_TO_ADDR
// end ;
93010: GO 92965
93012: POP
93013: POP
// if tmp then
93014: LD_VAR 0 3
93018: IFFALSE 93030
// active := tmp ;
93020: LD_ADDR_VAR 0 7
93024: PUSH
93025: LD_VAR 0 3
93029: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93030: LD_STRING getStreamItemsFromMission("
93032: PUSH
93033: LD_VAR 0 5
93037: STR
93038: PUSH
93039: LD_STRING ","
93041: STR
93042: PUSH
93043: LD_VAR 0 6
93047: STR
93048: PUSH
93049: LD_STRING ","
93051: STR
93052: PUSH
93053: LD_VAR 0 7
93057: STR
93058: PUSH
93059: LD_STRING ")
93061: STR
93062: PPUSH
93063: CALL_OW 559
// end else
93067: GO 93076
// ToLua ( getStreamItemsFromMission("","","") ) ;
93069: LD_STRING getStreamItemsFromMission("","","")
93071: PPUSH
93072: CALL_OW 559
// end ;
93076: LD_VAR 0 2
93080: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93081: LD_EXP 106
93085: PUSH
93086: LD_EXP 111
93090: AND
93091: IFFALSE 93215
93093: GO 93095
93095: DISABLE
93096: LD_INT 0
93098: PPUSH
93099: PPUSH
// begin enable ;
93100: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93101: LD_ADDR_VAR 0 2
93105: PUSH
93106: LD_INT 22
93108: PUSH
93109: LD_OWVAR 2
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 2
93120: PUSH
93121: LD_INT 34
93123: PUSH
93124: LD_INT 7
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 34
93133: PUSH
93134: LD_INT 45
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PUSH
93141: LD_INT 34
93143: PUSH
93144: LD_INT 28
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 34
93153: PUSH
93154: LD_INT 47
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: LIST
93165: LIST
93166: LIST
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PPUSH
93172: CALL_OW 69
93176: ST_TO_ADDR
// if not tmp then
93177: LD_VAR 0 2
93181: NOT
93182: IFFALSE 93186
// exit ;
93184: GO 93215
// for i in tmp do
93186: LD_ADDR_VAR 0 1
93190: PUSH
93191: LD_VAR 0 2
93195: PUSH
93196: FOR_IN
93197: IFFALSE 93213
// begin SetLives ( i , 0 ) ;
93199: LD_VAR 0 1
93203: PPUSH
93204: LD_INT 0
93206: PPUSH
93207: CALL_OW 234
// end ;
93211: GO 93196
93213: POP
93214: POP
// end ;
93215: PPOPN 2
93217: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93218: LD_EXP 106
93222: PUSH
93223: LD_EXP 112
93227: AND
93228: IFFALSE 93312
93230: GO 93232
93232: DISABLE
93233: LD_INT 0
93235: PPUSH
93236: PPUSH
// begin enable ;
93237: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93238: LD_ADDR_VAR 0 2
93242: PUSH
93243: LD_INT 22
93245: PUSH
93246: LD_OWVAR 2
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 32
93257: PUSH
93258: LD_INT 3
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PPUSH
93269: CALL_OW 69
93273: ST_TO_ADDR
// if not tmp then
93274: LD_VAR 0 2
93278: NOT
93279: IFFALSE 93283
// exit ;
93281: GO 93312
// for i in tmp do
93283: LD_ADDR_VAR 0 1
93287: PUSH
93288: LD_VAR 0 2
93292: PUSH
93293: FOR_IN
93294: IFFALSE 93310
// begin SetLives ( i , 0 ) ;
93296: LD_VAR 0 1
93300: PPUSH
93301: LD_INT 0
93303: PPUSH
93304: CALL_OW 234
// end ;
93308: GO 93293
93310: POP
93311: POP
// end ;
93312: PPOPN 2
93314: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93315: LD_EXP 106
93319: PUSH
93320: LD_EXP 109
93324: AND
93325: IFFALSE 93418
93327: GO 93329
93329: DISABLE
93330: LD_INT 0
93332: PPUSH
// begin enable ;
93333: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93334: LD_ADDR_VAR 0 1
93338: PUSH
93339: LD_INT 22
93341: PUSH
93342: LD_OWVAR 2
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 2
93353: PUSH
93354: LD_INT 25
93356: PUSH
93357: LD_INT 5
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 25
93366: PUSH
93367: LD_INT 9
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 25
93376: PUSH
93377: LD_INT 8
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PPUSH
93394: CALL_OW 69
93398: PUSH
93399: FOR_IN
93400: IFFALSE 93416
// begin SetClass ( i , 1 ) ;
93402: LD_VAR 0 1
93406: PPUSH
93407: LD_INT 1
93409: PPUSH
93410: CALL_OW 336
// end ;
93414: GO 93399
93416: POP
93417: POP
// end ;
93418: PPOPN 1
93420: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93421: LD_EXP 106
93425: PUSH
93426: LD_EXP 110
93430: AND
93431: PUSH
93432: LD_OWVAR 65
93436: PUSH
93437: LD_INT 7
93439: LESS
93440: AND
93441: IFFALSE 93455
93443: GO 93445
93445: DISABLE
// begin enable ;
93446: ENABLE
// game_speed := 7 ;
93447: LD_ADDR_OWVAR 65
93451: PUSH
93452: LD_INT 7
93454: ST_TO_ADDR
// end ;
93455: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93456: LD_EXP 106
93460: PUSH
93461: LD_EXP 113
93465: AND
93466: IFFALSE 93668
93468: GO 93470
93470: DISABLE
93471: LD_INT 0
93473: PPUSH
93474: PPUSH
93475: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93476: LD_ADDR_VAR 0 3
93480: PUSH
93481: LD_INT 81
93483: PUSH
93484: LD_OWVAR 2
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 21
93495: PUSH
93496: LD_INT 1
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PPUSH
93507: CALL_OW 69
93511: ST_TO_ADDR
// if not tmp then
93512: LD_VAR 0 3
93516: NOT
93517: IFFALSE 93521
// exit ;
93519: GO 93668
// if tmp > 5 then
93521: LD_VAR 0 3
93525: PUSH
93526: LD_INT 5
93528: GREATER
93529: IFFALSE 93541
// k := 5 else
93531: LD_ADDR_VAR 0 2
93535: PUSH
93536: LD_INT 5
93538: ST_TO_ADDR
93539: GO 93551
// k := tmp ;
93541: LD_ADDR_VAR 0 2
93545: PUSH
93546: LD_VAR 0 3
93550: ST_TO_ADDR
// for i := 1 to k do
93551: LD_ADDR_VAR 0 1
93555: PUSH
93556: DOUBLE
93557: LD_INT 1
93559: DEC
93560: ST_TO_ADDR
93561: LD_VAR 0 2
93565: PUSH
93566: FOR_TO
93567: IFFALSE 93666
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93569: LD_VAR 0 3
93573: PUSH
93574: LD_VAR 0 1
93578: ARRAY
93579: PPUSH
93580: LD_VAR 0 1
93584: PUSH
93585: LD_INT 4
93587: MOD
93588: PUSH
93589: LD_INT 1
93591: PLUS
93592: PPUSH
93593: CALL_OW 259
93597: PUSH
93598: LD_INT 10
93600: LESS
93601: IFFALSE 93664
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93603: LD_VAR 0 3
93607: PUSH
93608: LD_VAR 0 1
93612: ARRAY
93613: PPUSH
93614: LD_VAR 0 1
93618: PUSH
93619: LD_INT 4
93621: MOD
93622: PUSH
93623: LD_INT 1
93625: PLUS
93626: PPUSH
93627: LD_VAR 0 3
93631: PUSH
93632: LD_VAR 0 1
93636: ARRAY
93637: PPUSH
93638: LD_VAR 0 1
93642: PUSH
93643: LD_INT 4
93645: MOD
93646: PUSH
93647: LD_INT 1
93649: PLUS
93650: PPUSH
93651: CALL_OW 259
93655: PUSH
93656: LD_INT 1
93658: PLUS
93659: PPUSH
93660: CALL_OW 237
93664: GO 93566
93666: POP
93667: POP
// end ;
93668: PPOPN 3
93670: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93671: LD_EXP 106
93675: PUSH
93676: LD_EXP 114
93680: AND
93681: IFFALSE 93701
93683: GO 93685
93685: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93686: LD_INT 4
93688: PPUSH
93689: LD_OWVAR 2
93693: PPUSH
93694: LD_INT 0
93696: PPUSH
93697: CALL_OW 324
93701: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93702: LD_EXP 106
93706: PUSH
93707: LD_EXP 143
93711: AND
93712: IFFALSE 93732
93714: GO 93716
93716: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93717: LD_INT 19
93719: PPUSH
93720: LD_OWVAR 2
93724: PPUSH
93725: LD_INT 0
93727: PPUSH
93728: CALL_OW 324
93732: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93733: LD_EXP 106
93737: PUSH
93738: LD_EXP 115
93742: AND
93743: IFFALSE 93845
93745: GO 93747
93747: DISABLE
93748: LD_INT 0
93750: PPUSH
93751: PPUSH
// begin enable ;
93752: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93753: LD_ADDR_VAR 0 2
93757: PUSH
93758: LD_INT 22
93760: PUSH
93761: LD_OWVAR 2
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 2
93772: PUSH
93773: LD_INT 34
93775: PUSH
93776: LD_INT 11
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 34
93785: PUSH
93786: LD_INT 30
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: LIST
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: PPUSH
93802: CALL_OW 69
93806: ST_TO_ADDR
// if not tmp then
93807: LD_VAR 0 2
93811: NOT
93812: IFFALSE 93816
// exit ;
93814: GO 93845
// for i in tmp do
93816: LD_ADDR_VAR 0 1
93820: PUSH
93821: LD_VAR 0 2
93825: PUSH
93826: FOR_IN
93827: IFFALSE 93843
// begin SetLives ( i , 0 ) ;
93829: LD_VAR 0 1
93833: PPUSH
93834: LD_INT 0
93836: PPUSH
93837: CALL_OW 234
// end ;
93841: GO 93826
93843: POP
93844: POP
// end ;
93845: PPOPN 2
93847: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93848: LD_EXP 106
93852: PUSH
93853: LD_EXP 116
93857: AND
93858: IFFALSE 93878
93860: GO 93862
93862: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93863: LD_INT 32
93865: PPUSH
93866: LD_OWVAR 2
93870: PPUSH
93871: LD_INT 0
93873: PPUSH
93874: CALL_OW 324
93878: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93879: LD_EXP 106
93883: PUSH
93884: LD_EXP 117
93888: AND
93889: IFFALSE 94070
93891: GO 93893
93893: DISABLE
93894: LD_INT 0
93896: PPUSH
93897: PPUSH
93898: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93899: LD_ADDR_VAR 0 2
93903: PUSH
93904: LD_INT 22
93906: PUSH
93907: LD_OWVAR 2
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 33
93918: PUSH
93919: LD_INT 3
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PPUSH
93930: CALL_OW 69
93934: ST_TO_ADDR
// if not tmp then
93935: LD_VAR 0 2
93939: NOT
93940: IFFALSE 93944
// exit ;
93942: GO 94070
// side := 0 ;
93944: LD_ADDR_VAR 0 3
93948: PUSH
93949: LD_INT 0
93951: ST_TO_ADDR
// for i := 1 to 8 do
93952: LD_ADDR_VAR 0 1
93956: PUSH
93957: DOUBLE
93958: LD_INT 1
93960: DEC
93961: ST_TO_ADDR
93962: LD_INT 8
93964: PUSH
93965: FOR_TO
93966: IFFALSE 94014
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93968: LD_OWVAR 2
93972: PUSH
93973: LD_VAR 0 1
93977: NONEQUAL
93978: PUSH
93979: LD_OWVAR 2
93983: PPUSH
93984: LD_VAR 0 1
93988: PPUSH
93989: CALL_OW 81
93993: PUSH
93994: LD_INT 2
93996: EQUAL
93997: AND
93998: IFFALSE 94012
// begin side := i ;
94000: LD_ADDR_VAR 0 3
94004: PUSH
94005: LD_VAR 0 1
94009: ST_TO_ADDR
// break ;
94010: GO 94014
// end ;
94012: GO 93965
94014: POP
94015: POP
// if not side then
94016: LD_VAR 0 3
94020: NOT
94021: IFFALSE 94025
// exit ;
94023: GO 94070
// for i := 1 to tmp do
94025: LD_ADDR_VAR 0 1
94029: PUSH
94030: DOUBLE
94031: LD_INT 1
94033: DEC
94034: ST_TO_ADDR
94035: LD_VAR 0 2
94039: PUSH
94040: FOR_TO
94041: IFFALSE 94068
// if Prob ( 60 ) then
94043: LD_INT 60
94045: PPUSH
94046: CALL_OW 13
94050: IFFALSE 94066
// SetSide ( i , side ) ;
94052: LD_VAR 0 1
94056: PPUSH
94057: LD_VAR 0 3
94061: PPUSH
94062: CALL_OW 235
94066: GO 94040
94068: POP
94069: POP
// end ;
94070: PPOPN 3
94072: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94073: LD_EXP 106
94077: PUSH
94078: LD_EXP 119
94082: AND
94083: IFFALSE 94202
94085: GO 94087
94087: DISABLE
94088: LD_INT 0
94090: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94091: LD_ADDR_VAR 0 1
94095: PUSH
94096: LD_INT 22
94098: PUSH
94099: LD_OWVAR 2
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 21
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 3
94120: PUSH
94121: LD_INT 23
94123: PUSH
94124: LD_INT 0
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: EMPTY
94132: LIST
94133: LIST
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: LIST
94139: PPUSH
94140: CALL_OW 69
94144: PUSH
94145: FOR_IN
94146: IFFALSE 94200
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94148: LD_VAR 0 1
94152: PPUSH
94153: CALL_OW 257
94157: PUSH
94158: LD_INT 1
94160: PUSH
94161: LD_INT 2
94163: PUSH
94164: LD_INT 3
94166: PUSH
94167: LD_INT 4
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: IN
94176: IFFALSE 94198
// SetClass ( un , rand ( 1 , 4 ) ) ;
94178: LD_VAR 0 1
94182: PPUSH
94183: LD_INT 1
94185: PPUSH
94186: LD_INT 4
94188: PPUSH
94189: CALL_OW 12
94193: PPUSH
94194: CALL_OW 336
94198: GO 94145
94200: POP
94201: POP
// end ;
94202: PPOPN 1
94204: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94205: LD_EXP 106
94209: PUSH
94210: LD_EXP 118
94214: AND
94215: IFFALSE 94294
94217: GO 94219
94219: DISABLE
94220: LD_INT 0
94222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94223: LD_ADDR_VAR 0 1
94227: PUSH
94228: LD_INT 22
94230: PUSH
94231: LD_OWVAR 2
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: LD_INT 21
94242: PUSH
94243: LD_INT 3
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PPUSH
94254: CALL_OW 69
94258: ST_TO_ADDR
// if not tmp then
94259: LD_VAR 0 1
94263: NOT
94264: IFFALSE 94268
// exit ;
94266: GO 94294
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94268: LD_VAR 0 1
94272: PUSH
94273: LD_INT 1
94275: PPUSH
94276: LD_VAR 0 1
94280: PPUSH
94281: CALL_OW 12
94285: ARRAY
94286: PPUSH
94287: LD_INT 100
94289: PPUSH
94290: CALL_OW 234
// end ;
94294: PPOPN 1
94296: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94297: LD_EXP 106
94301: PUSH
94302: LD_EXP 120
94306: AND
94307: IFFALSE 94405
94309: GO 94311
94311: DISABLE
94312: LD_INT 0
94314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94315: LD_ADDR_VAR 0 1
94319: PUSH
94320: LD_INT 22
94322: PUSH
94323: LD_OWVAR 2
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 21
94334: PUSH
94335: LD_INT 1
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PPUSH
94346: CALL_OW 69
94350: ST_TO_ADDR
// if not tmp then
94351: LD_VAR 0 1
94355: NOT
94356: IFFALSE 94360
// exit ;
94358: GO 94405
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94360: LD_VAR 0 1
94364: PUSH
94365: LD_INT 1
94367: PPUSH
94368: LD_VAR 0 1
94372: PPUSH
94373: CALL_OW 12
94377: ARRAY
94378: PPUSH
94379: LD_INT 1
94381: PPUSH
94382: LD_INT 4
94384: PPUSH
94385: CALL_OW 12
94389: PPUSH
94390: LD_INT 3000
94392: PPUSH
94393: LD_INT 9000
94395: PPUSH
94396: CALL_OW 12
94400: PPUSH
94401: CALL_OW 492
// end ;
94405: PPOPN 1
94407: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94408: LD_EXP 106
94412: PUSH
94413: LD_EXP 121
94417: AND
94418: IFFALSE 94438
94420: GO 94422
94422: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94423: LD_INT 1
94425: PPUSH
94426: LD_OWVAR 2
94430: PPUSH
94431: LD_INT 0
94433: PPUSH
94434: CALL_OW 324
94438: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94439: LD_EXP 106
94443: PUSH
94444: LD_EXP 122
94448: AND
94449: IFFALSE 94532
94451: GO 94453
94453: DISABLE
94454: LD_INT 0
94456: PPUSH
94457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94458: LD_ADDR_VAR 0 2
94462: PUSH
94463: LD_INT 22
94465: PUSH
94466: LD_OWVAR 2
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 21
94477: PUSH
94478: LD_INT 3
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PPUSH
94489: CALL_OW 69
94493: ST_TO_ADDR
// if not tmp then
94494: LD_VAR 0 2
94498: NOT
94499: IFFALSE 94503
// exit ;
94501: GO 94532
// for i in tmp do
94503: LD_ADDR_VAR 0 1
94507: PUSH
94508: LD_VAR 0 2
94512: PUSH
94513: FOR_IN
94514: IFFALSE 94530
// SetBLevel ( i , 10 ) ;
94516: LD_VAR 0 1
94520: PPUSH
94521: LD_INT 10
94523: PPUSH
94524: CALL_OW 241
94528: GO 94513
94530: POP
94531: POP
// end ;
94532: PPOPN 2
94534: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94535: LD_EXP 106
94539: PUSH
94540: LD_EXP 123
94544: AND
94545: IFFALSE 94656
94547: GO 94549
94549: DISABLE
94550: LD_INT 0
94552: PPUSH
94553: PPUSH
94554: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94555: LD_ADDR_VAR 0 3
94559: PUSH
94560: LD_INT 22
94562: PUSH
94563: LD_OWVAR 2
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 25
94574: PUSH
94575: LD_INT 1
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PPUSH
94586: CALL_OW 69
94590: ST_TO_ADDR
// if not tmp then
94591: LD_VAR 0 3
94595: NOT
94596: IFFALSE 94600
// exit ;
94598: GO 94656
// un := tmp [ rand ( 1 , tmp ) ] ;
94600: LD_ADDR_VAR 0 2
94604: PUSH
94605: LD_VAR 0 3
94609: PUSH
94610: LD_INT 1
94612: PPUSH
94613: LD_VAR 0 3
94617: PPUSH
94618: CALL_OW 12
94622: ARRAY
94623: ST_TO_ADDR
// if Crawls ( un ) then
94624: LD_VAR 0 2
94628: PPUSH
94629: CALL_OW 318
94633: IFFALSE 94644
// ComWalk ( un ) ;
94635: LD_VAR 0 2
94639: PPUSH
94640: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94644: LD_VAR 0 2
94648: PPUSH
94649: LD_INT 5
94651: PPUSH
94652: CALL_OW 336
// end ;
94656: PPOPN 3
94658: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94659: LD_EXP 106
94663: PUSH
94664: LD_EXP 124
94668: AND
94669: PUSH
94670: LD_OWVAR 67
94674: PUSH
94675: LD_INT 4
94677: LESS
94678: AND
94679: IFFALSE 94698
94681: GO 94683
94683: DISABLE
// begin Difficulty := Difficulty + 1 ;
94684: LD_ADDR_OWVAR 67
94688: PUSH
94689: LD_OWVAR 67
94693: PUSH
94694: LD_INT 1
94696: PLUS
94697: ST_TO_ADDR
// end ;
94698: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94699: LD_EXP 106
94703: PUSH
94704: LD_EXP 125
94708: AND
94709: IFFALSE 94812
94711: GO 94713
94713: DISABLE
94714: LD_INT 0
94716: PPUSH
// begin for i := 1 to 5 do
94717: LD_ADDR_VAR 0 1
94721: PUSH
94722: DOUBLE
94723: LD_INT 1
94725: DEC
94726: ST_TO_ADDR
94727: LD_INT 5
94729: PUSH
94730: FOR_TO
94731: IFFALSE 94810
// begin uc_nation := nation_nature ;
94733: LD_ADDR_OWVAR 21
94737: PUSH
94738: LD_INT 0
94740: ST_TO_ADDR
// uc_side := 0 ;
94741: LD_ADDR_OWVAR 20
94745: PUSH
94746: LD_INT 0
94748: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94749: LD_ADDR_OWVAR 29
94753: PUSH
94754: LD_INT 12
94756: PUSH
94757: LD_INT 12
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: ST_TO_ADDR
// hc_agressivity := 20 ;
94764: LD_ADDR_OWVAR 35
94768: PUSH
94769: LD_INT 20
94771: ST_TO_ADDR
// hc_class := class_tiger ;
94772: LD_ADDR_OWVAR 28
94776: PUSH
94777: LD_INT 14
94779: ST_TO_ADDR
// hc_gallery :=  ;
94780: LD_ADDR_OWVAR 33
94784: PUSH
94785: LD_STRING 
94787: ST_TO_ADDR
// hc_name :=  ;
94788: LD_ADDR_OWVAR 26
94792: PUSH
94793: LD_STRING 
94795: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94796: CALL_OW 44
94800: PPUSH
94801: LD_INT 0
94803: PPUSH
94804: CALL_OW 51
// end ;
94808: GO 94730
94810: POP
94811: POP
// end ;
94812: PPOPN 1
94814: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94815: LD_EXP 106
94819: PUSH
94820: LD_EXP 126
94824: AND
94825: IFFALSE 94834
94827: GO 94829
94829: DISABLE
// StreamSibBomb ;
94830: CALL 94835 0 0
94834: END
// export function StreamSibBomb ; var i , x , y ; begin
94835: LD_INT 0
94837: PPUSH
94838: PPUSH
94839: PPUSH
94840: PPUSH
// result := false ;
94841: LD_ADDR_VAR 0 1
94845: PUSH
94846: LD_INT 0
94848: ST_TO_ADDR
// for i := 1 to 16 do
94849: LD_ADDR_VAR 0 2
94853: PUSH
94854: DOUBLE
94855: LD_INT 1
94857: DEC
94858: ST_TO_ADDR
94859: LD_INT 16
94861: PUSH
94862: FOR_TO
94863: IFFALSE 95062
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94865: LD_ADDR_VAR 0 3
94869: PUSH
94870: LD_INT 10
94872: PUSH
94873: LD_INT 20
94875: PUSH
94876: LD_INT 30
94878: PUSH
94879: LD_INT 40
94881: PUSH
94882: LD_INT 50
94884: PUSH
94885: LD_INT 60
94887: PUSH
94888: LD_INT 70
94890: PUSH
94891: LD_INT 80
94893: PUSH
94894: LD_INT 90
94896: PUSH
94897: LD_INT 100
94899: PUSH
94900: LD_INT 110
94902: PUSH
94903: LD_INT 120
94905: PUSH
94906: LD_INT 130
94908: PUSH
94909: LD_INT 140
94911: PUSH
94912: LD_INT 150
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: PUSH
94932: LD_INT 1
94934: PPUSH
94935: LD_INT 15
94937: PPUSH
94938: CALL_OW 12
94942: ARRAY
94943: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94944: LD_ADDR_VAR 0 4
94948: PUSH
94949: LD_INT 10
94951: PUSH
94952: LD_INT 20
94954: PUSH
94955: LD_INT 30
94957: PUSH
94958: LD_INT 40
94960: PUSH
94961: LD_INT 50
94963: PUSH
94964: LD_INT 60
94966: PUSH
94967: LD_INT 70
94969: PUSH
94970: LD_INT 80
94972: PUSH
94973: LD_INT 90
94975: PUSH
94976: LD_INT 100
94978: PUSH
94979: LD_INT 110
94981: PUSH
94982: LD_INT 120
94984: PUSH
94985: LD_INT 130
94987: PUSH
94988: LD_INT 140
94990: PUSH
94991: LD_INT 150
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 1
95013: PPUSH
95014: LD_INT 15
95016: PPUSH
95017: CALL_OW 12
95021: ARRAY
95022: ST_TO_ADDR
// if ValidHex ( x , y ) then
95023: LD_VAR 0 3
95027: PPUSH
95028: LD_VAR 0 4
95032: PPUSH
95033: CALL_OW 488
95037: IFFALSE 95060
// begin result := [ x , y ] ;
95039: LD_ADDR_VAR 0 1
95043: PUSH
95044: LD_VAR 0 3
95048: PUSH
95049: LD_VAR 0 4
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: ST_TO_ADDR
// break ;
95058: GO 95062
// end ; end ;
95060: GO 94862
95062: POP
95063: POP
// if result then
95064: LD_VAR 0 1
95068: IFFALSE 95128
// begin ToLua ( playSibBomb() ) ;
95070: LD_STRING playSibBomb()
95072: PPUSH
95073: CALL_OW 559
// wait ( 0 0$14 ) ;
95077: LD_INT 490
95079: PPUSH
95080: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95084: LD_VAR 0 1
95088: PUSH
95089: LD_INT 1
95091: ARRAY
95092: PPUSH
95093: LD_VAR 0 1
95097: PUSH
95098: LD_INT 2
95100: ARRAY
95101: PPUSH
95102: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95106: LD_VAR 0 1
95110: PUSH
95111: LD_INT 1
95113: ARRAY
95114: PPUSH
95115: LD_VAR 0 1
95119: PUSH
95120: LD_INT 2
95122: ARRAY
95123: PPUSH
95124: CALL_OW 429
// end ; end ;
95128: LD_VAR 0 1
95132: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95133: LD_EXP 106
95137: PUSH
95138: LD_EXP 128
95142: AND
95143: IFFALSE 95155
95145: GO 95147
95147: DISABLE
// YouLost (  ) ;
95148: LD_STRING 
95150: PPUSH
95151: CALL_OW 104
95155: END
// every 0 0$1 trigger StreamModeActive and sFog do
95156: LD_EXP 106
95160: PUSH
95161: LD_EXP 127
95165: AND
95166: IFFALSE 95180
95168: GO 95170
95170: DISABLE
// FogOff ( your_side ) ;
95171: LD_OWVAR 2
95175: PPUSH
95176: CALL_OW 344
95180: END
// every 0 0$1 trigger StreamModeActive and sSun do
95181: LD_EXP 106
95185: PUSH
95186: LD_EXP 129
95190: AND
95191: IFFALSE 95219
95193: GO 95195
95195: DISABLE
// begin solar_recharge_percent := 0 ;
95196: LD_ADDR_OWVAR 79
95200: PUSH
95201: LD_INT 0
95203: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95204: LD_INT 10500
95206: PPUSH
95207: CALL_OW 67
// solar_recharge_percent := 100 ;
95211: LD_ADDR_OWVAR 79
95215: PUSH
95216: LD_INT 100
95218: ST_TO_ADDR
// end ;
95219: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95220: LD_EXP 106
95224: PUSH
95225: LD_EXP 130
95229: AND
95230: IFFALSE 95469
95232: GO 95234
95234: DISABLE
95235: LD_INT 0
95237: PPUSH
95238: PPUSH
95239: PPUSH
// begin tmp := [ ] ;
95240: LD_ADDR_VAR 0 3
95244: PUSH
95245: EMPTY
95246: ST_TO_ADDR
// for i := 1 to 6 do
95247: LD_ADDR_VAR 0 1
95251: PUSH
95252: DOUBLE
95253: LD_INT 1
95255: DEC
95256: ST_TO_ADDR
95257: LD_INT 6
95259: PUSH
95260: FOR_TO
95261: IFFALSE 95366
// begin uc_nation := nation_nature ;
95263: LD_ADDR_OWVAR 21
95267: PUSH
95268: LD_INT 0
95270: ST_TO_ADDR
// uc_side := 0 ;
95271: LD_ADDR_OWVAR 20
95275: PUSH
95276: LD_INT 0
95278: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95279: LD_ADDR_OWVAR 29
95283: PUSH
95284: LD_INT 12
95286: PUSH
95287: LD_INT 12
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: ST_TO_ADDR
// hc_agressivity := 20 ;
95294: LD_ADDR_OWVAR 35
95298: PUSH
95299: LD_INT 20
95301: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95302: LD_ADDR_OWVAR 28
95306: PUSH
95307: LD_INT 17
95309: ST_TO_ADDR
// hc_gallery :=  ;
95310: LD_ADDR_OWVAR 33
95314: PUSH
95315: LD_STRING 
95317: ST_TO_ADDR
// hc_name :=  ;
95318: LD_ADDR_OWVAR 26
95322: PUSH
95323: LD_STRING 
95325: ST_TO_ADDR
// un := CreateHuman ;
95326: LD_ADDR_VAR 0 2
95330: PUSH
95331: CALL_OW 44
95335: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95336: LD_VAR 0 2
95340: PPUSH
95341: LD_INT 1
95343: PPUSH
95344: CALL_OW 51
// tmp := tmp ^ un ;
95348: LD_ADDR_VAR 0 3
95352: PUSH
95353: LD_VAR 0 3
95357: PUSH
95358: LD_VAR 0 2
95362: ADD
95363: ST_TO_ADDR
// end ;
95364: GO 95260
95366: POP
95367: POP
// repeat wait ( 0 0$1 ) ;
95368: LD_INT 35
95370: PPUSH
95371: CALL_OW 67
// for un in tmp do
95375: LD_ADDR_VAR 0 2
95379: PUSH
95380: LD_VAR 0 3
95384: PUSH
95385: FOR_IN
95386: IFFALSE 95460
// begin if IsDead ( un ) then
95388: LD_VAR 0 2
95392: PPUSH
95393: CALL_OW 301
95397: IFFALSE 95417
// begin tmp := tmp diff un ;
95399: LD_ADDR_VAR 0 3
95403: PUSH
95404: LD_VAR 0 3
95408: PUSH
95409: LD_VAR 0 2
95413: DIFF
95414: ST_TO_ADDR
// continue ;
95415: GO 95385
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95417: LD_VAR 0 2
95421: PPUSH
95422: LD_INT 3
95424: PUSH
95425: LD_INT 22
95427: PUSH
95428: LD_INT 0
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PPUSH
95439: CALL_OW 69
95443: PPUSH
95444: LD_VAR 0 2
95448: PPUSH
95449: CALL_OW 74
95453: PPUSH
95454: CALL_OW 115
// end ;
95458: GO 95385
95460: POP
95461: POP
// until not tmp ;
95462: LD_VAR 0 3
95466: NOT
95467: IFFALSE 95368
// end ;
95469: PPOPN 3
95471: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95472: LD_EXP 106
95476: PUSH
95477: LD_EXP 131
95481: AND
95482: IFFALSE 95536
95484: GO 95486
95486: DISABLE
// begin ToLua ( displayTroll(); ) ;
95487: LD_STRING displayTroll();
95489: PPUSH
95490: CALL_OW 559
// wait ( 3 3$00 ) ;
95494: LD_INT 6300
95496: PPUSH
95497: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95501: LD_STRING hideTroll();
95503: PPUSH
95504: CALL_OW 559
// wait ( 1 1$00 ) ;
95508: LD_INT 2100
95510: PPUSH
95511: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95515: LD_STRING displayTroll();
95517: PPUSH
95518: CALL_OW 559
// wait ( 1 1$00 ) ;
95522: LD_INT 2100
95524: PPUSH
95525: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95529: LD_STRING hideTroll();
95531: PPUSH
95532: CALL_OW 559
// end ;
95536: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95537: LD_EXP 106
95541: PUSH
95542: LD_EXP 132
95546: AND
95547: IFFALSE 95610
95549: GO 95551
95551: DISABLE
95552: LD_INT 0
95554: PPUSH
// begin p := 0 ;
95555: LD_ADDR_VAR 0 1
95559: PUSH
95560: LD_INT 0
95562: ST_TO_ADDR
// repeat game_speed := 1 ;
95563: LD_ADDR_OWVAR 65
95567: PUSH
95568: LD_INT 1
95570: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95571: LD_INT 35
95573: PPUSH
95574: CALL_OW 67
// p := p + 1 ;
95578: LD_ADDR_VAR 0 1
95582: PUSH
95583: LD_VAR 0 1
95587: PUSH
95588: LD_INT 1
95590: PLUS
95591: ST_TO_ADDR
// until p >= 60 ;
95592: LD_VAR 0 1
95596: PUSH
95597: LD_INT 60
95599: GREATEREQUAL
95600: IFFALSE 95563
// game_speed := 4 ;
95602: LD_ADDR_OWVAR 65
95606: PUSH
95607: LD_INT 4
95609: ST_TO_ADDR
// end ;
95610: PPOPN 1
95612: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95613: LD_EXP 106
95617: PUSH
95618: LD_EXP 133
95622: AND
95623: IFFALSE 95769
95625: GO 95627
95627: DISABLE
95628: LD_INT 0
95630: PPUSH
95631: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95632: LD_ADDR_VAR 0 1
95636: PUSH
95637: LD_INT 22
95639: PUSH
95640: LD_OWVAR 2
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 2
95651: PUSH
95652: LD_INT 30
95654: PUSH
95655: LD_INT 0
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: PUSH
95662: LD_INT 30
95664: PUSH
95665: LD_INT 1
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: LIST
95676: PUSH
95677: EMPTY
95678: LIST
95679: LIST
95680: PPUSH
95681: CALL_OW 69
95685: ST_TO_ADDR
// if not depot then
95686: LD_VAR 0 1
95690: NOT
95691: IFFALSE 95695
// exit ;
95693: GO 95769
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95695: LD_ADDR_VAR 0 2
95699: PUSH
95700: LD_VAR 0 1
95704: PUSH
95705: LD_INT 1
95707: PPUSH
95708: LD_VAR 0 1
95712: PPUSH
95713: CALL_OW 12
95717: ARRAY
95718: PPUSH
95719: CALL_OW 274
95723: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95724: LD_VAR 0 2
95728: PPUSH
95729: LD_INT 1
95731: PPUSH
95732: LD_INT 0
95734: PPUSH
95735: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95739: LD_VAR 0 2
95743: PPUSH
95744: LD_INT 2
95746: PPUSH
95747: LD_INT 0
95749: PPUSH
95750: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95754: LD_VAR 0 2
95758: PPUSH
95759: LD_INT 3
95761: PPUSH
95762: LD_INT 0
95764: PPUSH
95765: CALL_OW 277
// end ;
95769: PPOPN 2
95771: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95772: LD_EXP 106
95776: PUSH
95777: LD_EXP 134
95781: AND
95782: IFFALSE 95879
95784: GO 95786
95786: DISABLE
95787: LD_INT 0
95789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95790: LD_ADDR_VAR 0 1
95794: PUSH
95795: LD_INT 22
95797: PUSH
95798: LD_OWVAR 2
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 21
95809: PUSH
95810: LD_INT 1
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 3
95819: PUSH
95820: LD_INT 23
95822: PUSH
95823: LD_INT 0
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: LIST
95838: PPUSH
95839: CALL_OW 69
95843: ST_TO_ADDR
// if not tmp then
95844: LD_VAR 0 1
95848: NOT
95849: IFFALSE 95853
// exit ;
95851: GO 95879
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95853: LD_VAR 0 1
95857: PUSH
95858: LD_INT 1
95860: PPUSH
95861: LD_VAR 0 1
95865: PPUSH
95866: CALL_OW 12
95870: ARRAY
95871: PPUSH
95872: LD_INT 200
95874: PPUSH
95875: CALL_OW 234
// end ;
95879: PPOPN 1
95881: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95882: LD_EXP 106
95886: PUSH
95887: LD_EXP 135
95891: AND
95892: IFFALSE 95971
95894: GO 95896
95896: DISABLE
95897: LD_INT 0
95899: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95900: LD_ADDR_VAR 0 1
95904: PUSH
95905: LD_INT 22
95907: PUSH
95908: LD_OWVAR 2
95912: PUSH
95913: EMPTY
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 21
95919: PUSH
95920: LD_INT 2
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PPUSH
95931: CALL_OW 69
95935: ST_TO_ADDR
// if not tmp then
95936: LD_VAR 0 1
95940: NOT
95941: IFFALSE 95945
// exit ;
95943: GO 95971
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95945: LD_VAR 0 1
95949: PUSH
95950: LD_INT 1
95952: PPUSH
95953: LD_VAR 0 1
95957: PPUSH
95958: CALL_OW 12
95962: ARRAY
95963: PPUSH
95964: LD_INT 60
95966: PPUSH
95967: CALL_OW 234
// end ;
95971: PPOPN 1
95973: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95974: LD_EXP 106
95978: PUSH
95979: LD_EXP 136
95983: AND
95984: IFFALSE 96083
95986: GO 95988
95988: DISABLE
95989: LD_INT 0
95991: PPUSH
95992: PPUSH
// begin enable ;
95993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95994: LD_ADDR_VAR 0 1
95998: PUSH
95999: LD_INT 22
96001: PUSH
96002: LD_OWVAR 2
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 61
96013: PUSH
96014: EMPTY
96015: LIST
96016: PUSH
96017: LD_INT 33
96019: PUSH
96020: LD_INT 2
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: LIST
96031: PPUSH
96032: CALL_OW 69
96036: ST_TO_ADDR
// if not tmp then
96037: LD_VAR 0 1
96041: NOT
96042: IFFALSE 96046
// exit ;
96044: GO 96083
// for i in tmp do
96046: LD_ADDR_VAR 0 2
96050: PUSH
96051: LD_VAR 0 1
96055: PUSH
96056: FOR_IN
96057: IFFALSE 96081
// if IsControledBy ( i ) then
96059: LD_VAR 0 2
96063: PPUSH
96064: CALL_OW 312
96068: IFFALSE 96079
// ComUnlink ( i ) ;
96070: LD_VAR 0 2
96074: PPUSH
96075: CALL_OW 136
96079: GO 96056
96081: POP
96082: POP
// end ;
96083: PPOPN 2
96085: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96086: LD_EXP 106
96090: PUSH
96091: LD_EXP 137
96095: AND
96096: IFFALSE 96236
96098: GO 96100
96100: DISABLE
96101: LD_INT 0
96103: PPUSH
96104: PPUSH
// begin ToLua ( displayPowell(); ) ;
96105: LD_STRING displayPowell();
96107: PPUSH
96108: CALL_OW 559
// uc_side := 0 ;
96112: LD_ADDR_OWVAR 20
96116: PUSH
96117: LD_INT 0
96119: ST_TO_ADDR
// uc_nation := 2 ;
96120: LD_ADDR_OWVAR 21
96124: PUSH
96125: LD_INT 2
96127: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96128: LD_ADDR_OWVAR 37
96132: PUSH
96133: LD_INT 14
96135: ST_TO_ADDR
// vc_engine := engine_siberite ;
96136: LD_ADDR_OWVAR 39
96140: PUSH
96141: LD_INT 3
96143: ST_TO_ADDR
// vc_control := control_apeman ;
96144: LD_ADDR_OWVAR 38
96148: PUSH
96149: LD_INT 5
96151: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96152: LD_ADDR_OWVAR 40
96156: PUSH
96157: LD_INT 29
96159: ST_TO_ADDR
// un := CreateVehicle ;
96160: LD_ADDR_VAR 0 2
96164: PUSH
96165: CALL_OW 45
96169: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96170: LD_VAR 0 2
96174: PPUSH
96175: LD_INT 1
96177: PPUSH
96178: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96182: LD_INT 35
96184: PPUSH
96185: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96189: LD_VAR 0 2
96193: PPUSH
96194: LD_INT 22
96196: PUSH
96197: LD_OWVAR 2
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PPUSH
96206: CALL_OW 69
96210: PPUSH
96211: LD_VAR 0 2
96215: PPUSH
96216: CALL_OW 74
96220: PPUSH
96221: CALL_OW 115
// until IsDead ( un ) ;
96225: LD_VAR 0 2
96229: PPUSH
96230: CALL_OW 301
96234: IFFALSE 96182
// end ;
96236: PPOPN 2
96238: END
// every 0 0$1 trigger StreamModeActive and sStu do
96239: LD_EXP 106
96243: PUSH
96244: LD_EXP 145
96248: AND
96249: IFFALSE 96265
96251: GO 96253
96253: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96254: LD_STRING displayStucuk();
96256: PPUSH
96257: CALL_OW 559
// ResetFog ;
96261: CALL_OW 335
// end ;
96265: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96266: LD_EXP 106
96270: PUSH
96271: LD_EXP 138
96275: AND
96276: IFFALSE 96417
96278: GO 96280
96280: DISABLE
96281: LD_INT 0
96283: PPUSH
96284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96285: LD_ADDR_VAR 0 2
96289: PUSH
96290: LD_INT 22
96292: PUSH
96293: LD_OWVAR 2
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: LD_INT 21
96304: PUSH
96305: LD_INT 1
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PPUSH
96316: CALL_OW 69
96320: ST_TO_ADDR
// if not tmp then
96321: LD_VAR 0 2
96325: NOT
96326: IFFALSE 96330
// exit ;
96328: GO 96417
// un := tmp [ rand ( 1 , tmp ) ] ;
96330: LD_ADDR_VAR 0 1
96334: PUSH
96335: LD_VAR 0 2
96339: PUSH
96340: LD_INT 1
96342: PPUSH
96343: LD_VAR 0 2
96347: PPUSH
96348: CALL_OW 12
96352: ARRAY
96353: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96354: LD_VAR 0 1
96358: PPUSH
96359: LD_INT 0
96361: PPUSH
96362: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96366: LD_VAR 0 1
96370: PPUSH
96371: LD_OWVAR 3
96375: PUSH
96376: LD_VAR 0 1
96380: DIFF
96381: PPUSH
96382: LD_VAR 0 1
96386: PPUSH
96387: CALL_OW 74
96391: PPUSH
96392: CALL_OW 115
// wait ( 0 0$20 ) ;
96396: LD_INT 700
96398: PPUSH
96399: CALL_OW 67
// SetSide ( un , your_side ) ;
96403: LD_VAR 0 1
96407: PPUSH
96408: LD_OWVAR 2
96412: PPUSH
96413: CALL_OW 235
// end ;
96417: PPOPN 2
96419: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96420: LD_EXP 106
96424: PUSH
96425: LD_EXP 139
96429: AND
96430: IFFALSE 96536
96432: GO 96434
96434: DISABLE
96435: LD_INT 0
96437: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96438: LD_ADDR_VAR 0 1
96442: PUSH
96443: LD_INT 22
96445: PUSH
96446: LD_OWVAR 2
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 2
96457: PUSH
96458: LD_INT 30
96460: PUSH
96461: LD_INT 0
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 30
96470: PUSH
96471: LD_INT 1
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: LIST
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: PPUSH
96487: CALL_OW 69
96491: ST_TO_ADDR
// if not depot then
96492: LD_VAR 0 1
96496: NOT
96497: IFFALSE 96501
// exit ;
96499: GO 96536
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96501: LD_VAR 0 1
96505: PUSH
96506: LD_INT 1
96508: ARRAY
96509: PPUSH
96510: CALL_OW 250
96514: PPUSH
96515: LD_VAR 0 1
96519: PUSH
96520: LD_INT 1
96522: ARRAY
96523: PPUSH
96524: CALL_OW 251
96528: PPUSH
96529: LD_INT 70
96531: PPUSH
96532: CALL_OW 495
// end ;
96536: PPOPN 1
96538: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96539: LD_EXP 106
96543: PUSH
96544: LD_EXP 140
96548: AND
96549: IFFALSE 96760
96551: GO 96553
96553: DISABLE
96554: LD_INT 0
96556: PPUSH
96557: PPUSH
96558: PPUSH
96559: PPUSH
96560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96561: LD_ADDR_VAR 0 5
96565: PUSH
96566: LD_INT 22
96568: PUSH
96569: LD_OWVAR 2
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PUSH
96578: LD_INT 21
96580: PUSH
96581: LD_INT 1
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PPUSH
96592: CALL_OW 69
96596: ST_TO_ADDR
// if not tmp then
96597: LD_VAR 0 5
96601: NOT
96602: IFFALSE 96606
// exit ;
96604: GO 96760
// for i in tmp do
96606: LD_ADDR_VAR 0 1
96610: PUSH
96611: LD_VAR 0 5
96615: PUSH
96616: FOR_IN
96617: IFFALSE 96758
// begin d := rand ( 0 , 5 ) ;
96619: LD_ADDR_VAR 0 4
96623: PUSH
96624: LD_INT 0
96626: PPUSH
96627: LD_INT 5
96629: PPUSH
96630: CALL_OW 12
96634: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96635: LD_ADDR_VAR 0 2
96639: PUSH
96640: LD_VAR 0 1
96644: PPUSH
96645: CALL_OW 250
96649: PPUSH
96650: LD_VAR 0 4
96654: PPUSH
96655: LD_INT 3
96657: PPUSH
96658: LD_INT 12
96660: PPUSH
96661: CALL_OW 12
96665: PPUSH
96666: CALL_OW 272
96670: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96671: LD_ADDR_VAR 0 3
96675: PUSH
96676: LD_VAR 0 1
96680: PPUSH
96681: CALL_OW 251
96685: PPUSH
96686: LD_VAR 0 4
96690: PPUSH
96691: LD_INT 3
96693: PPUSH
96694: LD_INT 12
96696: PPUSH
96697: CALL_OW 12
96701: PPUSH
96702: CALL_OW 273
96706: ST_TO_ADDR
// if ValidHex ( x , y ) then
96707: LD_VAR 0 2
96711: PPUSH
96712: LD_VAR 0 3
96716: PPUSH
96717: CALL_OW 488
96721: IFFALSE 96756
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96723: LD_VAR 0 1
96727: PPUSH
96728: LD_VAR 0 2
96732: PPUSH
96733: LD_VAR 0 3
96737: PPUSH
96738: LD_INT 3
96740: PPUSH
96741: LD_INT 6
96743: PPUSH
96744: CALL_OW 12
96748: PPUSH
96749: LD_INT 1
96751: PPUSH
96752: CALL_OW 483
// end ;
96756: GO 96616
96758: POP
96759: POP
// end ;
96760: PPOPN 5
96762: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96763: LD_EXP 106
96767: PUSH
96768: LD_EXP 141
96772: AND
96773: IFFALSE 96867
96775: GO 96777
96777: DISABLE
96778: LD_INT 0
96780: PPUSH
96781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96782: LD_ADDR_VAR 0 2
96786: PUSH
96787: LD_INT 22
96789: PUSH
96790: LD_OWVAR 2
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: PUSH
96799: LD_INT 32
96801: PUSH
96802: LD_INT 1
96804: PUSH
96805: EMPTY
96806: LIST
96807: LIST
96808: PUSH
96809: LD_INT 21
96811: PUSH
96812: LD_INT 2
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: LIST
96823: PPUSH
96824: CALL_OW 69
96828: ST_TO_ADDR
// if not tmp then
96829: LD_VAR 0 2
96833: NOT
96834: IFFALSE 96838
// exit ;
96836: GO 96867
// for i in tmp do
96838: LD_ADDR_VAR 0 1
96842: PUSH
96843: LD_VAR 0 2
96847: PUSH
96848: FOR_IN
96849: IFFALSE 96865
// SetFuel ( i , 0 ) ;
96851: LD_VAR 0 1
96855: PPUSH
96856: LD_INT 0
96858: PPUSH
96859: CALL_OW 240
96863: GO 96848
96865: POP
96866: POP
// end ;
96867: PPOPN 2
96869: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96870: LD_EXP 106
96874: PUSH
96875: LD_EXP 142
96879: AND
96880: IFFALSE 96946
96882: GO 96884
96884: DISABLE
96885: LD_INT 0
96887: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96888: LD_ADDR_VAR 0 1
96892: PUSH
96893: LD_INT 22
96895: PUSH
96896: LD_OWVAR 2
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: PUSH
96905: LD_INT 30
96907: PUSH
96908: LD_INT 29
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PPUSH
96919: CALL_OW 69
96923: ST_TO_ADDR
// if not tmp then
96924: LD_VAR 0 1
96928: NOT
96929: IFFALSE 96933
// exit ;
96931: GO 96946
// DestroyUnit ( tmp [ 1 ] ) ;
96933: LD_VAR 0 1
96937: PUSH
96938: LD_INT 1
96940: ARRAY
96941: PPUSH
96942: CALL_OW 65
// end ;
96946: PPOPN 1
96948: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96949: LD_EXP 106
96953: PUSH
96954: LD_EXP 144
96958: AND
96959: IFFALSE 97088
96961: GO 96963
96963: DISABLE
96964: LD_INT 0
96966: PPUSH
// begin uc_side := 0 ;
96967: LD_ADDR_OWVAR 20
96971: PUSH
96972: LD_INT 0
96974: ST_TO_ADDR
// uc_nation := nation_arabian ;
96975: LD_ADDR_OWVAR 21
96979: PUSH
96980: LD_INT 2
96982: ST_TO_ADDR
// hc_gallery :=  ;
96983: LD_ADDR_OWVAR 33
96987: PUSH
96988: LD_STRING 
96990: ST_TO_ADDR
// hc_name :=  ;
96991: LD_ADDR_OWVAR 26
96995: PUSH
96996: LD_STRING 
96998: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96999: LD_INT 1
97001: PPUSH
97002: LD_INT 11
97004: PPUSH
97005: LD_INT 10
97007: PPUSH
97008: CALL_OW 380
// un := CreateHuman ;
97012: LD_ADDR_VAR 0 1
97016: PUSH
97017: CALL_OW 44
97021: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97022: LD_VAR 0 1
97026: PPUSH
97027: LD_INT 1
97029: PPUSH
97030: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97034: LD_INT 35
97036: PPUSH
97037: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97041: LD_VAR 0 1
97045: PPUSH
97046: LD_INT 22
97048: PUSH
97049: LD_OWVAR 2
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PPUSH
97058: CALL_OW 69
97062: PPUSH
97063: LD_VAR 0 1
97067: PPUSH
97068: CALL_OW 74
97072: PPUSH
97073: CALL_OW 115
// until IsDead ( un ) ;
97077: LD_VAR 0 1
97081: PPUSH
97082: CALL_OW 301
97086: IFFALSE 97034
// end ;
97088: PPOPN 1
97090: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97091: LD_EXP 106
97095: PUSH
97096: LD_EXP 146
97100: AND
97101: IFFALSE 97113
97103: GO 97105
97105: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97106: LD_STRING earthquake(getX(game), 0, 32)
97108: PPUSH
97109: CALL_OW 559
97113: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97114: LD_EXP 106
97118: PUSH
97119: LD_EXP 147
97123: AND
97124: IFFALSE 97215
97126: GO 97128
97128: DISABLE
97129: LD_INT 0
97131: PPUSH
// begin enable ;
97132: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97133: LD_ADDR_VAR 0 1
97137: PUSH
97138: LD_INT 22
97140: PUSH
97141: LD_OWVAR 2
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PUSH
97150: LD_INT 21
97152: PUSH
97153: LD_INT 2
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PUSH
97160: LD_INT 33
97162: PUSH
97163: LD_INT 3
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: LIST
97174: PPUSH
97175: CALL_OW 69
97179: ST_TO_ADDR
// if not tmp then
97180: LD_VAR 0 1
97184: NOT
97185: IFFALSE 97189
// exit ;
97187: GO 97215
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97189: LD_VAR 0 1
97193: PUSH
97194: LD_INT 1
97196: PPUSH
97197: LD_VAR 0 1
97201: PPUSH
97202: CALL_OW 12
97206: ARRAY
97207: PPUSH
97208: LD_INT 1
97210: PPUSH
97211: CALL_OW 234
// end ;
97215: PPOPN 1
97217: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97218: LD_EXP 106
97222: PUSH
97223: LD_EXP 148
97227: AND
97228: IFFALSE 97369
97230: GO 97232
97232: DISABLE
97233: LD_INT 0
97235: PPUSH
97236: PPUSH
97237: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97238: LD_ADDR_VAR 0 3
97242: PUSH
97243: LD_INT 22
97245: PUSH
97246: LD_OWVAR 2
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: PUSH
97255: LD_INT 25
97257: PUSH
97258: LD_INT 1
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PPUSH
97269: CALL_OW 69
97273: ST_TO_ADDR
// if not tmp then
97274: LD_VAR 0 3
97278: NOT
97279: IFFALSE 97283
// exit ;
97281: GO 97369
// un := tmp [ rand ( 1 , tmp ) ] ;
97283: LD_ADDR_VAR 0 2
97287: PUSH
97288: LD_VAR 0 3
97292: PUSH
97293: LD_INT 1
97295: PPUSH
97296: LD_VAR 0 3
97300: PPUSH
97301: CALL_OW 12
97305: ARRAY
97306: ST_TO_ADDR
// if Crawls ( un ) then
97307: LD_VAR 0 2
97311: PPUSH
97312: CALL_OW 318
97316: IFFALSE 97327
// ComWalk ( un ) ;
97318: LD_VAR 0 2
97322: PPUSH
97323: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97327: LD_VAR 0 2
97331: PPUSH
97332: LD_INT 9
97334: PPUSH
97335: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97339: LD_INT 28
97341: PPUSH
97342: LD_OWVAR 2
97346: PPUSH
97347: LD_INT 2
97349: PPUSH
97350: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97354: LD_INT 29
97356: PPUSH
97357: LD_OWVAR 2
97361: PPUSH
97362: LD_INT 2
97364: PPUSH
97365: CALL_OW 322
// end ;
97369: PPOPN 3
97371: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97372: LD_EXP 106
97376: PUSH
97377: LD_EXP 149
97381: AND
97382: IFFALSE 97493
97384: GO 97386
97386: DISABLE
97387: LD_INT 0
97389: PPUSH
97390: PPUSH
97391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97392: LD_ADDR_VAR 0 3
97396: PUSH
97397: LD_INT 22
97399: PUSH
97400: LD_OWVAR 2
97404: PUSH
97405: EMPTY
97406: LIST
97407: LIST
97408: PUSH
97409: LD_INT 25
97411: PUSH
97412: LD_INT 1
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PPUSH
97423: CALL_OW 69
97427: ST_TO_ADDR
// if not tmp then
97428: LD_VAR 0 3
97432: NOT
97433: IFFALSE 97437
// exit ;
97435: GO 97493
// un := tmp [ rand ( 1 , tmp ) ] ;
97437: LD_ADDR_VAR 0 2
97441: PUSH
97442: LD_VAR 0 3
97446: PUSH
97447: LD_INT 1
97449: PPUSH
97450: LD_VAR 0 3
97454: PPUSH
97455: CALL_OW 12
97459: ARRAY
97460: ST_TO_ADDR
// if Crawls ( un ) then
97461: LD_VAR 0 2
97465: PPUSH
97466: CALL_OW 318
97470: IFFALSE 97481
// ComWalk ( un ) ;
97472: LD_VAR 0 2
97476: PPUSH
97477: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97481: LD_VAR 0 2
97485: PPUSH
97486: LD_INT 8
97488: PPUSH
97489: CALL_OW 336
// end ;
97493: PPOPN 3
97495: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97496: LD_EXP 106
97500: PUSH
97501: LD_EXP 150
97505: AND
97506: IFFALSE 97650
97508: GO 97510
97510: DISABLE
97511: LD_INT 0
97513: PPUSH
97514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97515: LD_ADDR_VAR 0 2
97519: PUSH
97520: LD_INT 22
97522: PUSH
97523: LD_OWVAR 2
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_INT 21
97534: PUSH
97535: LD_INT 2
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: PUSH
97542: LD_INT 2
97544: PUSH
97545: LD_INT 34
97547: PUSH
97548: LD_INT 12
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PUSH
97555: LD_INT 34
97557: PUSH
97558: LD_INT 51
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 34
97567: PUSH
97568: LD_INT 32
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: LIST
97585: PPUSH
97586: CALL_OW 69
97590: ST_TO_ADDR
// if not tmp then
97591: LD_VAR 0 2
97595: NOT
97596: IFFALSE 97600
// exit ;
97598: GO 97650
// for i in tmp do
97600: LD_ADDR_VAR 0 1
97604: PUSH
97605: LD_VAR 0 2
97609: PUSH
97610: FOR_IN
97611: IFFALSE 97648
// if GetCargo ( i , mat_artifact ) = 0 then
97613: LD_VAR 0 1
97617: PPUSH
97618: LD_INT 4
97620: PPUSH
97621: CALL_OW 289
97625: PUSH
97626: LD_INT 0
97628: EQUAL
97629: IFFALSE 97646
// SetCargo ( i , mat_siberit , 100 ) ;
97631: LD_VAR 0 1
97635: PPUSH
97636: LD_INT 3
97638: PPUSH
97639: LD_INT 100
97641: PPUSH
97642: CALL_OW 290
97646: GO 97610
97648: POP
97649: POP
// end ;
97650: PPOPN 2
97652: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97653: LD_EXP 106
97657: PUSH
97658: LD_EXP 151
97662: AND
97663: IFFALSE 97846
97665: GO 97667
97667: DISABLE
97668: LD_INT 0
97670: PPUSH
97671: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97672: LD_ADDR_VAR 0 2
97676: PUSH
97677: LD_INT 22
97679: PUSH
97680: LD_OWVAR 2
97684: PUSH
97685: EMPTY
97686: LIST
97687: LIST
97688: PPUSH
97689: CALL_OW 69
97693: ST_TO_ADDR
// if not tmp then
97694: LD_VAR 0 2
97698: NOT
97699: IFFALSE 97703
// exit ;
97701: GO 97846
// for i := 1 to 2 do
97703: LD_ADDR_VAR 0 1
97707: PUSH
97708: DOUBLE
97709: LD_INT 1
97711: DEC
97712: ST_TO_ADDR
97713: LD_INT 2
97715: PUSH
97716: FOR_TO
97717: IFFALSE 97844
// begin uc_side := your_side ;
97719: LD_ADDR_OWVAR 20
97723: PUSH
97724: LD_OWVAR 2
97728: ST_TO_ADDR
// uc_nation := nation_american ;
97729: LD_ADDR_OWVAR 21
97733: PUSH
97734: LD_INT 1
97736: ST_TO_ADDR
// vc_chassis := us_morphling ;
97737: LD_ADDR_OWVAR 37
97741: PUSH
97742: LD_INT 5
97744: ST_TO_ADDR
// vc_engine := engine_siberite ;
97745: LD_ADDR_OWVAR 39
97749: PUSH
97750: LD_INT 3
97752: ST_TO_ADDR
// vc_control := control_computer ;
97753: LD_ADDR_OWVAR 38
97757: PUSH
97758: LD_INT 3
97760: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97761: LD_ADDR_OWVAR 40
97765: PUSH
97766: LD_INT 10
97768: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97769: LD_VAR 0 2
97773: PUSH
97774: LD_INT 1
97776: ARRAY
97777: PPUSH
97778: CALL_OW 310
97782: NOT
97783: IFFALSE 97830
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97785: CALL_OW 45
97789: PPUSH
97790: LD_VAR 0 2
97794: PUSH
97795: LD_INT 1
97797: ARRAY
97798: PPUSH
97799: CALL_OW 250
97803: PPUSH
97804: LD_VAR 0 2
97808: PUSH
97809: LD_INT 1
97811: ARRAY
97812: PPUSH
97813: CALL_OW 251
97817: PPUSH
97818: LD_INT 12
97820: PPUSH
97821: LD_INT 1
97823: PPUSH
97824: CALL_OW 50
97828: GO 97842
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97830: CALL_OW 45
97834: PPUSH
97835: LD_INT 1
97837: PPUSH
97838: CALL_OW 51
// end ;
97842: GO 97716
97844: POP
97845: POP
// end ;
97846: PPOPN 2
97848: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97849: LD_EXP 106
97853: PUSH
97854: LD_EXP 152
97858: AND
97859: IFFALSE 98081
97861: GO 97863
97863: DISABLE
97864: LD_INT 0
97866: PPUSH
97867: PPUSH
97868: PPUSH
97869: PPUSH
97870: PPUSH
97871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97872: LD_ADDR_VAR 0 6
97876: PUSH
97877: LD_INT 22
97879: PUSH
97880: LD_OWVAR 2
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: LD_INT 21
97891: PUSH
97892: LD_INT 1
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PUSH
97899: LD_INT 3
97901: PUSH
97902: LD_INT 23
97904: PUSH
97905: LD_INT 0
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: EMPTY
97913: LIST
97914: LIST
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: LIST
97920: PPUSH
97921: CALL_OW 69
97925: ST_TO_ADDR
// if not tmp then
97926: LD_VAR 0 6
97930: NOT
97931: IFFALSE 97935
// exit ;
97933: GO 98081
// s1 := rand ( 1 , 4 ) ;
97935: LD_ADDR_VAR 0 2
97939: PUSH
97940: LD_INT 1
97942: PPUSH
97943: LD_INT 4
97945: PPUSH
97946: CALL_OW 12
97950: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97951: LD_ADDR_VAR 0 4
97955: PUSH
97956: LD_VAR 0 6
97960: PUSH
97961: LD_INT 1
97963: ARRAY
97964: PPUSH
97965: LD_VAR 0 2
97969: PPUSH
97970: CALL_OW 259
97974: ST_TO_ADDR
// if s1 = 1 then
97975: LD_VAR 0 2
97979: PUSH
97980: LD_INT 1
97982: EQUAL
97983: IFFALSE 98003
// s2 := rand ( 2 , 4 ) else
97985: LD_ADDR_VAR 0 3
97989: PUSH
97990: LD_INT 2
97992: PPUSH
97993: LD_INT 4
97995: PPUSH
97996: CALL_OW 12
98000: ST_TO_ADDR
98001: GO 98011
// s2 := 1 ;
98003: LD_ADDR_VAR 0 3
98007: PUSH
98008: LD_INT 1
98010: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98011: LD_ADDR_VAR 0 5
98015: PUSH
98016: LD_VAR 0 6
98020: PUSH
98021: LD_INT 1
98023: ARRAY
98024: PPUSH
98025: LD_VAR 0 3
98029: PPUSH
98030: CALL_OW 259
98034: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98035: LD_VAR 0 6
98039: PUSH
98040: LD_INT 1
98042: ARRAY
98043: PPUSH
98044: LD_VAR 0 2
98048: PPUSH
98049: LD_VAR 0 5
98053: PPUSH
98054: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98058: LD_VAR 0 6
98062: PUSH
98063: LD_INT 1
98065: ARRAY
98066: PPUSH
98067: LD_VAR 0 3
98071: PPUSH
98072: LD_VAR 0 4
98076: PPUSH
98077: CALL_OW 237
// end ;
98081: PPOPN 6
98083: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98084: LD_EXP 106
98088: PUSH
98089: LD_EXP 153
98093: AND
98094: IFFALSE 98173
98096: GO 98098
98098: DISABLE
98099: LD_INT 0
98101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98102: LD_ADDR_VAR 0 1
98106: PUSH
98107: LD_INT 22
98109: PUSH
98110: LD_OWVAR 2
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: PUSH
98119: LD_INT 30
98121: PUSH
98122: LD_INT 3
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PPUSH
98133: CALL_OW 69
98137: ST_TO_ADDR
// if not tmp then
98138: LD_VAR 0 1
98142: NOT
98143: IFFALSE 98147
// exit ;
98145: GO 98173
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98147: LD_VAR 0 1
98151: PUSH
98152: LD_INT 1
98154: PPUSH
98155: LD_VAR 0 1
98159: PPUSH
98160: CALL_OW 12
98164: ARRAY
98165: PPUSH
98166: LD_INT 1
98168: PPUSH
98169: CALL_OW 234
// end ;
98173: PPOPN 1
98175: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98176: LD_EXP 106
98180: PUSH
98181: LD_EXP 154
98185: AND
98186: IFFALSE 98298
98188: GO 98190
98190: DISABLE
98191: LD_INT 0
98193: PPUSH
98194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98195: LD_ADDR_VAR 0 2
98199: PUSH
98200: LD_INT 22
98202: PUSH
98203: LD_OWVAR 2
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 2
98214: PUSH
98215: LD_INT 30
98217: PUSH
98218: LD_INT 27
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 30
98227: PUSH
98228: LD_INT 26
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: LD_INT 30
98237: PUSH
98238: LD_INT 28
98240: PUSH
98241: EMPTY
98242: LIST
98243: LIST
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PPUSH
98255: CALL_OW 69
98259: ST_TO_ADDR
// if not tmp then
98260: LD_VAR 0 2
98264: NOT
98265: IFFALSE 98269
// exit ;
98267: GO 98298
// for i in tmp do
98269: LD_ADDR_VAR 0 1
98273: PUSH
98274: LD_VAR 0 2
98278: PUSH
98279: FOR_IN
98280: IFFALSE 98296
// SetLives ( i , 1 ) ;
98282: LD_VAR 0 1
98286: PPUSH
98287: LD_INT 1
98289: PPUSH
98290: CALL_OW 234
98294: GO 98279
98296: POP
98297: POP
// end ;
98298: PPOPN 2
98300: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98301: LD_EXP 106
98305: PUSH
98306: LD_EXP 155
98310: AND
98311: IFFALSE 98598
98313: GO 98315
98315: DISABLE
98316: LD_INT 0
98318: PPUSH
98319: PPUSH
98320: PPUSH
// begin i := rand ( 1 , 7 ) ;
98321: LD_ADDR_VAR 0 1
98325: PUSH
98326: LD_INT 1
98328: PPUSH
98329: LD_INT 7
98331: PPUSH
98332: CALL_OW 12
98336: ST_TO_ADDR
// case i of 1 :
98337: LD_VAR 0 1
98341: PUSH
98342: LD_INT 1
98344: DOUBLE
98345: EQUAL
98346: IFTRUE 98350
98348: GO 98360
98350: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98351: LD_STRING earthquake(getX(game), 0, 32)
98353: PPUSH
98354: CALL_OW 559
98358: GO 98598
98360: LD_INT 2
98362: DOUBLE
98363: EQUAL
98364: IFTRUE 98368
98366: GO 98382
98368: POP
// begin ToLua ( displayStucuk(); ) ;
98369: LD_STRING displayStucuk();
98371: PPUSH
98372: CALL_OW 559
// ResetFog ;
98376: CALL_OW 335
// end ; 3 :
98380: GO 98598
98382: LD_INT 3
98384: DOUBLE
98385: EQUAL
98386: IFTRUE 98390
98388: GO 98494
98390: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98391: LD_ADDR_VAR 0 2
98395: PUSH
98396: LD_INT 22
98398: PUSH
98399: LD_OWVAR 2
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: PUSH
98408: LD_INT 25
98410: PUSH
98411: LD_INT 1
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: PPUSH
98422: CALL_OW 69
98426: ST_TO_ADDR
// if not tmp then
98427: LD_VAR 0 2
98431: NOT
98432: IFFALSE 98436
// exit ;
98434: GO 98598
// un := tmp [ rand ( 1 , tmp ) ] ;
98436: LD_ADDR_VAR 0 3
98440: PUSH
98441: LD_VAR 0 2
98445: PUSH
98446: LD_INT 1
98448: PPUSH
98449: LD_VAR 0 2
98453: PPUSH
98454: CALL_OW 12
98458: ARRAY
98459: ST_TO_ADDR
// if Crawls ( un ) then
98460: LD_VAR 0 3
98464: PPUSH
98465: CALL_OW 318
98469: IFFALSE 98480
// ComWalk ( un ) ;
98471: LD_VAR 0 3
98475: PPUSH
98476: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98480: LD_VAR 0 3
98484: PPUSH
98485: LD_INT 8
98487: PPUSH
98488: CALL_OW 336
// end ; 4 :
98492: GO 98598
98494: LD_INT 4
98496: DOUBLE
98497: EQUAL
98498: IFTRUE 98502
98500: GO 98576
98502: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98503: LD_ADDR_VAR 0 2
98507: PUSH
98508: LD_INT 22
98510: PUSH
98511: LD_OWVAR 2
98515: PUSH
98516: EMPTY
98517: LIST
98518: LIST
98519: PUSH
98520: LD_INT 30
98522: PUSH
98523: LD_INT 29
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: PUSH
98530: EMPTY
98531: LIST
98532: LIST
98533: PPUSH
98534: CALL_OW 69
98538: ST_TO_ADDR
// if not tmp then
98539: LD_VAR 0 2
98543: NOT
98544: IFFALSE 98548
// exit ;
98546: GO 98598
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98548: LD_VAR 0 2
98552: PUSH
98553: LD_INT 1
98555: ARRAY
98556: PPUSH
98557: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98561: LD_VAR 0 2
98565: PUSH
98566: LD_INT 1
98568: ARRAY
98569: PPUSH
98570: CALL_OW 65
// end ; 5 .. 7 :
98574: GO 98598
98576: LD_INT 5
98578: DOUBLE
98579: GREATEREQUAL
98580: IFFALSE 98588
98582: LD_INT 7
98584: DOUBLE
98585: LESSEQUAL
98586: IFTRUE 98590
98588: GO 98597
98590: POP
// StreamSibBomb ; end ;
98591: CALL 94835 0 0
98595: GO 98598
98597: POP
// end ;
98598: PPOPN 3
98600: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98601: LD_EXP 106
98605: PUSH
98606: LD_EXP 156
98610: AND
98611: IFFALSE 98767
98613: GO 98615
98615: DISABLE
98616: LD_INT 0
98618: PPUSH
98619: PPUSH
98620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98621: LD_ADDR_VAR 0 2
98625: PUSH
98626: LD_INT 81
98628: PUSH
98629: LD_OWVAR 2
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: PUSH
98638: LD_INT 2
98640: PUSH
98641: LD_INT 21
98643: PUSH
98644: LD_INT 1
98646: PUSH
98647: EMPTY
98648: LIST
98649: LIST
98650: PUSH
98651: LD_INT 21
98653: PUSH
98654: LD_INT 2
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: LIST
98665: PUSH
98666: EMPTY
98667: LIST
98668: LIST
98669: PPUSH
98670: CALL_OW 69
98674: ST_TO_ADDR
// if not tmp then
98675: LD_VAR 0 2
98679: NOT
98680: IFFALSE 98684
// exit ;
98682: GO 98767
// p := 0 ;
98684: LD_ADDR_VAR 0 3
98688: PUSH
98689: LD_INT 0
98691: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98692: LD_INT 35
98694: PPUSH
98695: CALL_OW 67
// p := p + 1 ;
98699: LD_ADDR_VAR 0 3
98703: PUSH
98704: LD_VAR 0 3
98708: PUSH
98709: LD_INT 1
98711: PLUS
98712: ST_TO_ADDR
// for i in tmp do
98713: LD_ADDR_VAR 0 1
98717: PUSH
98718: LD_VAR 0 2
98722: PUSH
98723: FOR_IN
98724: IFFALSE 98755
// if GetLives ( i ) < 1000 then
98726: LD_VAR 0 1
98730: PPUSH
98731: CALL_OW 256
98735: PUSH
98736: LD_INT 1000
98738: LESS
98739: IFFALSE 98753
// SetLives ( i , 1000 ) ;
98741: LD_VAR 0 1
98745: PPUSH
98746: LD_INT 1000
98748: PPUSH
98749: CALL_OW 234
98753: GO 98723
98755: POP
98756: POP
// until p > 20 ;
98757: LD_VAR 0 3
98761: PUSH
98762: LD_INT 20
98764: GREATER
98765: IFFALSE 98692
// end ;
98767: PPOPN 3
98769: END
// every 0 0$1 trigger StreamModeActive and sTime do
98770: LD_EXP 106
98774: PUSH
98775: LD_EXP 157
98779: AND
98780: IFFALSE 98815
98782: GO 98784
98784: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98785: LD_INT 28
98787: PPUSH
98788: LD_OWVAR 2
98792: PPUSH
98793: LD_INT 2
98795: PPUSH
98796: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98800: LD_INT 30
98802: PPUSH
98803: LD_OWVAR 2
98807: PPUSH
98808: LD_INT 2
98810: PPUSH
98811: CALL_OW 322
// end ;
98815: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98816: LD_EXP 106
98820: PUSH
98821: LD_EXP 158
98825: AND
98826: IFFALSE 98947
98828: GO 98830
98830: DISABLE
98831: LD_INT 0
98833: PPUSH
98834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98835: LD_ADDR_VAR 0 2
98839: PUSH
98840: LD_INT 22
98842: PUSH
98843: LD_OWVAR 2
98847: PUSH
98848: EMPTY
98849: LIST
98850: LIST
98851: PUSH
98852: LD_INT 21
98854: PUSH
98855: LD_INT 1
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: PUSH
98862: LD_INT 3
98864: PUSH
98865: LD_INT 23
98867: PUSH
98868: LD_INT 0
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: LIST
98883: PPUSH
98884: CALL_OW 69
98888: ST_TO_ADDR
// if not tmp then
98889: LD_VAR 0 2
98893: NOT
98894: IFFALSE 98898
// exit ;
98896: GO 98947
// for i in tmp do
98898: LD_ADDR_VAR 0 1
98902: PUSH
98903: LD_VAR 0 2
98907: PUSH
98908: FOR_IN
98909: IFFALSE 98945
// begin if Crawls ( i ) then
98911: LD_VAR 0 1
98915: PPUSH
98916: CALL_OW 318
98920: IFFALSE 98931
// ComWalk ( i ) ;
98922: LD_VAR 0 1
98926: PPUSH
98927: CALL_OW 138
// SetClass ( i , 2 ) ;
98931: LD_VAR 0 1
98935: PPUSH
98936: LD_INT 2
98938: PPUSH
98939: CALL_OW 336
// end ;
98943: GO 98908
98945: POP
98946: POP
// end ;
98947: PPOPN 2
98949: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98950: LD_EXP 106
98954: PUSH
98955: LD_EXP 159
98959: AND
98960: IFFALSE 99248
98962: GO 98964
98964: DISABLE
98965: LD_INT 0
98967: PPUSH
98968: PPUSH
98969: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98970: LD_OWVAR 2
98974: PPUSH
98975: LD_INT 9
98977: PPUSH
98978: LD_INT 1
98980: PPUSH
98981: LD_INT 1
98983: PPUSH
98984: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98988: LD_INT 9
98990: PPUSH
98991: LD_OWVAR 2
98995: PPUSH
98996: CALL_OW 343
// uc_side := 9 ;
99000: LD_ADDR_OWVAR 20
99004: PUSH
99005: LD_INT 9
99007: ST_TO_ADDR
// uc_nation := 2 ;
99008: LD_ADDR_OWVAR 21
99012: PUSH
99013: LD_INT 2
99015: ST_TO_ADDR
// hc_name := Dark Warrior ;
99016: LD_ADDR_OWVAR 26
99020: PUSH
99021: LD_STRING Dark Warrior
99023: ST_TO_ADDR
// hc_gallery :=  ;
99024: LD_ADDR_OWVAR 33
99028: PUSH
99029: LD_STRING 
99031: ST_TO_ADDR
// hc_noskilllimit := true ;
99032: LD_ADDR_OWVAR 76
99036: PUSH
99037: LD_INT 1
99039: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99040: LD_ADDR_OWVAR 31
99044: PUSH
99045: LD_INT 30
99047: PUSH
99048: LD_INT 30
99050: PUSH
99051: LD_INT 30
99053: PUSH
99054: LD_INT 30
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: ST_TO_ADDR
// un := CreateHuman ;
99063: LD_ADDR_VAR 0 3
99067: PUSH
99068: CALL_OW 44
99072: ST_TO_ADDR
// hc_noskilllimit := false ;
99073: LD_ADDR_OWVAR 76
99077: PUSH
99078: LD_INT 0
99080: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99081: LD_VAR 0 3
99085: PPUSH
99086: LD_INT 1
99088: PPUSH
99089: CALL_OW 51
// ToLua ( playRanger() ) ;
99093: LD_STRING playRanger()
99095: PPUSH
99096: CALL_OW 559
// p := 0 ;
99100: LD_ADDR_VAR 0 2
99104: PUSH
99105: LD_INT 0
99107: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99108: LD_INT 35
99110: PPUSH
99111: CALL_OW 67
// p := p + 1 ;
99115: LD_ADDR_VAR 0 2
99119: PUSH
99120: LD_VAR 0 2
99124: PUSH
99125: LD_INT 1
99127: PLUS
99128: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99129: LD_VAR 0 3
99133: PPUSH
99134: CALL_OW 256
99138: PUSH
99139: LD_INT 1000
99141: LESS
99142: IFFALSE 99156
// SetLives ( un , 1000 ) ;
99144: LD_VAR 0 3
99148: PPUSH
99149: LD_INT 1000
99151: PPUSH
99152: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99156: LD_VAR 0 3
99160: PPUSH
99161: LD_INT 81
99163: PUSH
99164: LD_OWVAR 2
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PUSH
99173: LD_INT 91
99175: PUSH
99176: LD_VAR 0 3
99180: PUSH
99181: LD_INT 30
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: LIST
99188: PUSH
99189: EMPTY
99190: LIST
99191: LIST
99192: PPUSH
99193: CALL_OW 69
99197: PPUSH
99198: LD_VAR 0 3
99202: PPUSH
99203: CALL_OW 74
99207: PPUSH
99208: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99212: LD_VAR 0 2
99216: PUSH
99217: LD_INT 80
99219: GREATER
99220: PUSH
99221: LD_VAR 0 3
99225: PPUSH
99226: CALL_OW 301
99230: OR
99231: IFFALSE 99108
// if un then
99233: LD_VAR 0 3
99237: IFFALSE 99248
// RemoveUnit ( un ) ;
99239: LD_VAR 0 3
99243: PPUSH
99244: CALL_OW 64
// end ;
99248: PPOPN 3
99250: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99251: LD_EXP 160
99255: IFFALSE 99371
99257: GO 99259
99259: DISABLE
99260: LD_INT 0
99262: PPUSH
99263: PPUSH
99264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99265: LD_ADDR_VAR 0 2
99269: PUSH
99270: LD_INT 81
99272: PUSH
99273: LD_OWVAR 2
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: PUSH
99282: LD_INT 21
99284: PUSH
99285: LD_INT 1
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PPUSH
99296: CALL_OW 69
99300: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99301: LD_STRING playComputer()
99303: PPUSH
99304: CALL_OW 559
// if not tmp then
99308: LD_VAR 0 2
99312: NOT
99313: IFFALSE 99317
// exit ;
99315: GO 99371
// for i in tmp do
99317: LD_ADDR_VAR 0 1
99321: PUSH
99322: LD_VAR 0 2
99326: PUSH
99327: FOR_IN
99328: IFFALSE 99369
// for j := 1 to 4 do
99330: LD_ADDR_VAR 0 3
99334: PUSH
99335: DOUBLE
99336: LD_INT 1
99338: DEC
99339: ST_TO_ADDR
99340: LD_INT 4
99342: PUSH
99343: FOR_TO
99344: IFFALSE 99365
// SetSkill ( i , j , 10 ) ;
99346: LD_VAR 0 1
99350: PPUSH
99351: LD_VAR 0 3
99355: PPUSH
99356: LD_INT 10
99358: PPUSH
99359: CALL_OW 237
99363: GO 99343
99365: POP
99366: POP
99367: GO 99327
99369: POP
99370: POP
// end ;
99371: PPOPN 3
99373: END
// every 0 0$1 trigger s30 do var i , tmp ;
99374: LD_EXP 161
99378: IFFALSE 99447
99380: GO 99382
99382: DISABLE
99383: LD_INT 0
99385: PPUSH
99386: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99387: LD_ADDR_VAR 0 2
99391: PUSH
99392: LD_INT 22
99394: PUSH
99395: LD_OWVAR 2
99399: PUSH
99400: EMPTY
99401: LIST
99402: LIST
99403: PPUSH
99404: CALL_OW 69
99408: ST_TO_ADDR
// if not tmp then
99409: LD_VAR 0 2
99413: NOT
99414: IFFALSE 99418
// exit ;
99416: GO 99447
// for i in tmp do
99418: LD_ADDR_VAR 0 1
99422: PUSH
99423: LD_VAR 0 2
99427: PUSH
99428: FOR_IN
99429: IFFALSE 99445
// SetLives ( i , 300 ) ;
99431: LD_VAR 0 1
99435: PPUSH
99436: LD_INT 300
99438: PPUSH
99439: CALL_OW 234
99443: GO 99428
99445: POP
99446: POP
// end ;
99447: PPOPN 2
99449: END
// every 0 0$1 trigger s60 do var i , tmp ;
99450: LD_EXP 162
99454: IFFALSE 99523
99456: GO 99458
99458: DISABLE
99459: LD_INT 0
99461: PPUSH
99462: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99463: LD_ADDR_VAR 0 2
99467: PUSH
99468: LD_INT 22
99470: PUSH
99471: LD_OWVAR 2
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PPUSH
99480: CALL_OW 69
99484: ST_TO_ADDR
// if not tmp then
99485: LD_VAR 0 2
99489: NOT
99490: IFFALSE 99494
// exit ;
99492: GO 99523
// for i in tmp do
99494: LD_ADDR_VAR 0 1
99498: PUSH
99499: LD_VAR 0 2
99503: PUSH
99504: FOR_IN
99505: IFFALSE 99521
// SetLives ( i , 600 ) ;
99507: LD_VAR 0 1
99511: PPUSH
99512: LD_INT 600
99514: PPUSH
99515: CALL_OW 234
99519: GO 99504
99521: POP
99522: POP
// end ;
99523: PPOPN 2
99525: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99526: LD_INT 0
99528: PPUSH
// case cmd of 301 :
99529: LD_VAR 0 1
99533: PUSH
99534: LD_INT 301
99536: DOUBLE
99537: EQUAL
99538: IFTRUE 99542
99540: GO 99574
99542: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99543: LD_VAR 0 6
99547: PPUSH
99548: LD_VAR 0 7
99552: PPUSH
99553: LD_VAR 0 8
99557: PPUSH
99558: LD_VAR 0 4
99562: PPUSH
99563: LD_VAR 0 5
99567: PPUSH
99568: CALL 100775 0 5
99572: GO 99695
99574: LD_INT 302
99576: DOUBLE
99577: EQUAL
99578: IFTRUE 99582
99580: GO 99619
99582: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99583: LD_VAR 0 6
99587: PPUSH
99588: LD_VAR 0 7
99592: PPUSH
99593: LD_VAR 0 8
99597: PPUSH
99598: LD_VAR 0 9
99602: PPUSH
99603: LD_VAR 0 4
99607: PPUSH
99608: LD_VAR 0 5
99612: PPUSH
99613: CALL 100866 0 6
99617: GO 99695
99619: LD_INT 303
99621: DOUBLE
99622: EQUAL
99623: IFTRUE 99627
99625: GO 99664
99627: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99628: LD_VAR 0 6
99632: PPUSH
99633: LD_VAR 0 7
99637: PPUSH
99638: LD_VAR 0 8
99642: PPUSH
99643: LD_VAR 0 9
99647: PPUSH
99648: LD_VAR 0 4
99652: PPUSH
99653: LD_VAR 0 5
99657: PPUSH
99658: CALL 99700 0 6
99662: GO 99695
99664: LD_INT 304
99666: DOUBLE
99667: EQUAL
99668: IFTRUE 99672
99670: GO 99694
99672: POP
// hHackTeleport ( unit , x , y ) ; end ;
99673: LD_VAR 0 2
99677: PPUSH
99678: LD_VAR 0 4
99682: PPUSH
99683: LD_VAR 0 5
99687: PPUSH
99688: CALL 101459 0 3
99692: GO 99695
99694: POP
// end ;
99695: LD_VAR 0 12
99699: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99700: LD_INT 0
99702: PPUSH
99703: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99704: LD_VAR 0 1
99708: PUSH
99709: LD_INT 1
99711: LESS
99712: PUSH
99713: LD_VAR 0 1
99717: PUSH
99718: LD_INT 3
99720: GREATER
99721: OR
99722: PUSH
99723: LD_VAR 0 5
99727: PPUSH
99728: LD_VAR 0 6
99732: PPUSH
99733: CALL_OW 428
99737: OR
99738: IFFALSE 99742
// exit ;
99740: GO 100462
// uc_side := your_side ;
99742: LD_ADDR_OWVAR 20
99746: PUSH
99747: LD_OWVAR 2
99751: ST_TO_ADDR
// uc_nation := nation ;
99752: LD_ADDR_OWVAR 21
99756: PUSH
99757: LD_VAR 0 1
99761: ST_TO_ADDR
// bc_level = 1 ;
99762: LD_ADDR_OWVAR 43
99766: PUSH
99767: LD_INT 1
99769: ST_TO_ADDR
// case btype of 1 :
99770: LD_VAR 0 2
99774: PUSH
99775: LD_INT 1
99777: DOUBLE
99778: EQUAL
99779: IFTRUE 99783
99781: GO 99794
99783: POP
// bc_type := b_depot ; 2 :
99784: LD_ADDR_OWVAR 42
99788: PUSH
99789: LD_INT 0
99791: ST_TO_ADDR
99792: GO 100406
99794: LD_INT 2
99796: DOUBLE
99797: EQUAL
99798: IFTRUE 99802
99800: GO 99813
99802: POP
// bc_type := b_warehouse ; 3 :
99803: LD_ADDR_OWVAR 42
99807: PUSH
99808: LD_INT 1
99810: ST_TO_ADDR
99811: GO 100406
99813: LD_INT 3
99815: DOUBLE
99816: EQUAL
99817: IFTRUE 99821
99819: GO 99832
99821: POP
// bc_type := b_lab ; 4 .. 9 :
99822: LD_ADDR_OWVAR 42
99826: PUSH
99827: LD_INT 6
99829: ST_TO_ADDR
99830: GO 100406
99832: LD_INT 4
99834: DOUBLE
99835: GREATEREQUAL
99836: IFFALSE 99844
99838: LD_INT 9
99840: DOUBLE
99841: LESSEQUAL
99842: IFTRUE 99846
99844: GO 99898
99846: POP
// begin bc_type := b_lab_half ;
99847: LD_ADDR_OWVAR 42
99851: PUSH
99852: LD_INT 7
99854: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99855: LD_ADDR_OWVAR 44
99859: PUSH
99860: LD_INT 10
99862: PUSH
99863: LD_INT 11
99865: PUSH
99866: LD_INT 12
99868: PUSH
99869: LD_INT 15
99871: PUSH
99872: LD_INT 14
99874: PUSH
99875: LD_INT 13
99877: PUSH
99878: EMPTY
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: PUSH
99886: LD_VAR 0 2
99890: PUSH
99891: LD_INT 3
99893: MINUS
99894: ARRAY
99895: ST_TO_ADDR
// end ; 10 .. 13 :
99896: GO 100406
99898: LD_INT 10
99900: DOUBLE
99901: GREATEREQUAL
99902: IFFALSE 99910
99904: LD_INT 13
99906: DOUBLE
99907: LESSEQUAL
99908: IFTRUE 99912
99910: GO 99989
99912: POP
// begin bc_type := b_lab_full ;
99913: LD_ADDR_OWVAR 42
99917: PUSH
99918: LD_INT 8
99920: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99921: LD_ADDR_OWVAR 44
99925: PUSH
99926: LD_INT 10
99928: PUSH
99929: LD_INT 12
99931: PUSH
99932: LD_INT 14
99934: PUSH
99935: LD_INT 13
99937: PUSH
99938: EMPTY
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: PUSH
99944: LD_VAR 0 2
99948: PUSH
99949: LD_INT 9
99951: MINUS
99952: ARRAY
99953: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99954: LD_ADDR_OWVAR 45
99958: PUSH
99959: LD_INT 11
99961: PUSH
99962: LD_INT 15
99964: PUSH
99965: LD_INT 12
99967: PUSH
99968: LD_INT 15
99970: PUSH
99971: EMPTY
99972: LIST
99973: LIST
99974: LIST
99975: LIST
99976: PUSH
99977: LD_VAR 0 2
99981: PUSH
99982: LD_INT 9
99984: MINUS
99985: ARRAY
99986: ST_TO_ADDR
// end ; 14 :
99987: GO 100406
99989: LD_INT 14
99991: DOUBLE
99992: EQUAL
99993: IFTRUE 99997
99995: GO 100008
99997: POP
// bc_type := b_workshop ; 15 :
99998: LD_ADDR_OWVAR 42
100002: PUSH
100003: LD_INT 2
100005: ST_TO_ADDR
100006: GO 100406
100008: LD_INT 15
100010: DOUBLE
100011: EQUAL
100012: IFTRUE 100016
100014: GO 100027
100016: POP
// bc_type := b_factory ; 16 :
100017: LD_ADDR_OWVAR 42
100021: PUSH
100022: LD_INT 3
100024: ST_TO_ADDR
100025: GO 100406
100027: LD_INT 16
100029: DOUBLE
100030: EQUAL
100031: IFTRUE 100035
100033: GO 100046
100035: POP
// bc_type := b_ext_gun ; 17 :
100036: LD_ADDR_OWVAR 42
100040: PUSH
100041: LD_INT 17
100043: ST_TO_ADDR
100044: GO 100406
100046: LD_INT 17
100048: DOUBLE
100049: EQUAL
100050: IFTRUE 100054
100052: GO 100082
100054: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100055: LD_ADDR_OWVAR 42
100059: PUSH
100060: LD_INT 19
100062: PUSH
100063: LD_INT 23
100065: PUSH
100066: LD_INT 19
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: LIST
100073: PUSH
100074: LD_VAR 0 1
100078: ARRAY
100079: ST_TO_ADDR
100080: GO 100406
100082: LD_INT 18
100084: DOUBLE
100085: EQUAL
100086: IFTRUE 100090
100088: GO 100101
100090: POP
// bc_type := b_ext_radar ; 19 :
100091: LD_ADDR_OWVAR 42
100095: PUSH
100096: LD_INT 20
100098: ST_TO_ADDR
100099: GO 100406
100101: LD_INT 19
100103: DOUBLE
100104: EQUAL
100105: IFTRUE 100109
100107: GO 100120
100109: POP
// bc_type := b_ext_radio ; 20 :
100110: LD_ADDR_OWVAR 42
100114: PUSH
100115: LD_INT 22
100117: ST_TO_ADDR
100118: GO 100406
100120: LD_INT 20
100122: DOUBLE
100123: EQUAL
100124: IFTRUE 100128
100126: GO 100139
100128: POP
// bc_type := b_ext_siberium ; 21 :
100129: LD_ADDR_OWVAR 42
100133: PUSH
100134: LD_INT 21
100136: ST_TO_ADDR
100137: GO 100406
100139: LD_INT 21
100141: DOUBLE
100142: EQUAL
100143: IFTRUE 100147
100145: GO 100158
100147: POP
// bc_type := b_ext_computer ; 22 :
100148: LD_ADDR_OWVAR 42
100152: PUSH
100153: LD_INT 24
100155: ST_TO_ADDR
100156: GO 100406
100158: LD_INT 22
100160: DOUBLE
100161: EQUAL
100162: IFTRUE 100166
100164: GO 100177
100166: POP
// bc_type := b_ext_track ; 23 :
100167: LD_ADDR_OWVAR 42
100171: PUSH
100172: LD_INT 16
100174: ST_TO_ADDR
100175: GO 100406
100177: LD_INT 23
100179: DOUBLE
100180: EQUAL
100181: IFTRUE 100185
100183: GO 100196
100185: POP
// bc_type := b_ext_laser ; 24 :
100186: LD_ADDR_OWVAR 42
100190: PUSH
100191: LD_INT 25
100193: ST_TO_ADDR
100194: GO 100406
100196: LD_INT 24
100198: DOUBLE
100199: EQUAL
100200: IFTRUE 100204
100202: GO 100215
100204: POP
// bc_type := b_control_tower ; 25 :
100205: LD_ADDR_OWVAR 42
100209: PUSH
100210: LD_INT 36
100212: ST_TO_ADDR
100213: GO 100406
100215: LD_INT 25
100217: DOUBLE
100218: EQUAL
100219: IFTRUE 100223
100221: GO 100234
100223: POP
// bc_type := b_breastwork ; 26 :
100224: LD_ADDR_OWVAR 42
100228: PUSH
100229: LD_INT 31
100231: ST_TO_ADDR
100232: GO 100406
100234: LD_INT 26
100236: DOUBLE
100237: EQUAL
100238: IFTRUE 100242
100240: GO 100253
100242: POP
// bc_type := b_bunker ; 27 :
100243: LD_ADDR_OWVAR 42
100247: PUSH
100248: LD_INT 32
100250: ST_TO_ADDR
100251: GO 100406
100253: LD_INT 27
100255: DOUBLE
100256: EQUAL
100257: IFTRUE 100261
100259: GO 100272
100261: POP
// bc_type := b_turret ; 28 :
100262: LD_ADDR_OWVAR 42
100266: PUSH
100267: LD_INT 33
100269: ST_TO_ADDR
100270: GO 100406
100272: LD_INT 28
100274: DOUBLE
100275: EQUAL
100276: IFTRUE 100280
100278: GO 100291
100280: POP
// bc_type := b_armoury ; 29 :
100281: LD_ADDR_OWVAR 42
100285: PUSH
100286: LD_INT 4
100288: ST_TO_ADDR
100289: GO 100406
100291: LD_INT 29
100293: DOUBLE
100294: EQUAL
100295: IFTRUE 100299
100297: GO 100310
100299: POP
// bc_type := b_barracks ; 30 :
100300: LD_ADDR_OWVAR 42
100304: PUSH
100305: LD_INT 5
100307: ST_TO_ADDR
100308: GO 100406
100310: LD_INT 30
100312: DOUBLE
100313: EQUAL
100314: IFTRUE 100318
100316: GO 100329
100318: POP
// bc_type := b_solar_power ; 31 :
100319: LD_ADDR_OWVAR 42
100323: PUSH
100324: LD_INT 27
100326: ST_TO_ADDR
100327: GO 100406
100329: LD_INT 31
100331: DOUBLE
100332: EQUAL
100333: IFTRUE 100337
100335: GO 100348
100337: POP
// bc_type := b_oil_power ; 32 :
100338: LD_ADDR_OWVAR 42
100342: PUSH
100343: LD_INT 26
100345: ST_TO_ADDR
100346: GO 100406
100348: LD_INT 32
100350: DOUBLE
100351: EQUAL
100352: IFTRUE 100356
100354: GO 100367
100356: POP
// bc_type := b_siberite_power ; 33 :
100357: LD_ADDR_OWVAR 42
100361: PUSH
100362: LD_INT 28
100364: ST_TO_ADDR
100365: GO 100406
100367: LD_INT 33
100369: DOUBLE
100370: EQUAL
100371: IFTRUE 100375
100373: GO 100386
100375: POP
// bc_type := b_oil_mine ; 34 :
100376: LD_ADDR_OWVAR 42
100380: PUSH
100381: LD_INT 29
100383: ST_TO_ADDR
100384: GO 100406
100386: LD_INT 34
100388: DOUBLE
100389: EQUAL
100390: IFTRUE 100394
100392: GO 100405
100394: POP
// bc_type := b_siberite_mine ; end ;
100395: LD_ADDR_OWVAR 42
100399: PUSH
100400: LD_INT 30
100402: ST_TO_ADDR
100403: GO 100406
100405: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100406: LD_ADDR_VAR 0 8
100410: PUSH
100411: LD_VAR 0 5
100415: PPUSH
100416: LD_VAR 0 6
100420: PPUSH
100421: LD_VAR 0 3
100425: PPUSH
100426: CALL_OW 47
100430: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100431: LD_OWVAR 42
100435: PUSH
100436: LD_INT 32
100438: PUSH
100439: LD_INT 33
100441: PUSH
100442: EMPTY
100443: LIST
100444: LIST
100445: IN
100446: IFFALSE 100462
// PlaceWeaponTurret ( b , weapon ) ;
100448: LD_VAR 0 8
100452: PPUSH
100453: LD_VAR 0 4
100457: PPUSH
100458: CALL_OW 431
// end ;
100462: LD_VAR 0 7
100466: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100467: LD_INT 0
100469: PPUSH
100470: PPUSH
100471: PPUSH
100472: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100473: LD_ADDR_VAR 0 4
100477: PUSH
100478: LD_INT 22
100480: PUSH
100481: LD_OWVAR 2
100485: PUSH
100486: EMPTY
100487: LIST
100488: LIST
100489: PUSH
100490: LD_INT 2
100492: PUSH
100493: LD_INT 30
100495: PUSH
100496: LD_INT 0
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: PUSH
100503: LD_INT 30
100505: PUSH
100506: LD_INT 1
100508: PUSH
100509: EMPTY
100510: LIST
100511: LIST
100512: PUSH
100513: EMPTY
100514: LIST
100515: LIST
100516: LIST
100517: PUSH
100518: EMPTY
100519: LIST
100520: LIST
100521: PPUSH
100522: CALL_OW 69
100526: ST_TO_ADDR
// if not tmp then
100527: LD_VAR 0 4
100531: NOT
100532: IFFALSE 100536
// exit ;
100534: GO 100595
// for i in tmp do
100536: LD_ADDR_VAR 0 2
100540: PUSH
100541: LD_VAR 0 4
100545: PUSH
100546: FOR_IN
100547: IFFALSE 100593
// for j = 1 to 3 do
100549: LD_ADDR_VAR 0 3
100553: PUSH
100554: DOUBLE
100555: LD_INT 1
100557: DEC
100558: ST_TO_ADDR
100559: LD_INT 3
100561: PUSH
100562: FOR_TO
100563: IFFALSE 100589
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100565: LD_VAR 0 2
100569: PPUSH
100570: CALL_OW 274
100574: PPUSH
100575: LD_VAR 0 3
100579: PPUSH
100580: LD_INT 99999
100582: PPUSH
100583: CALL_OW 277
100587: GO 100562
100589: POP
100590: POP
100591: GO 100546
100593: POP
100594: POP
// end ;
100595: LD_VAR 0 1
100599: RET
// export function hHackSetLevel10 ; var i , j ; begin
100600: LD_INT 0
100602: PPUSH
100603: PPUSH
100604: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100605: LD_ADDR_VAR 0 2
100609: PUSH
100610: LD_INT 21
100612: PUSH
100613: LD_INT 1
100615: PUSH
100616: EMPTY
100617: LIST
100618: LIST
100619: PPUSH
100620: CALL_OW 69
100624: PUSH
100625: FOR_IN
100626: IFFALSE 100678
// if IsSelected ( i ) then
100628: LD_VAR 0 2
100632: PPUSH
100633: CALL_OW 306
100637: IFFALSE 100676
// begin for j := 1 to 4 do
100639: LD_ADDR_VAR 0 3
100643: PUSH
100644: DOUBLE
100645: LD_INT 1
100647: DEC
100648: ST_TO_ADDR
100649: LD_INT 4
100651: PUSH
100652: FOR_TO
100653: IFFALSE 100674
// SetSkill ( i , j , 10 ) ;
100655: LD_VAR 0 2
100659: PPUSH
100660: LD_VAR 0 3
100664: PPUSH
100665: LD_INT 10
100667: PPUSH
100668: CALL_OW 237
100672: GO 100652
100674: POP
100675: POP
// end ;
100676: GO 100625
100678: POP
100679: POP
// end ;
100680: LD_VAR 0 1
100684: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100685: LD_INT 0
100687: PPUSH
100688: PPUSH
100689: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100690: LD_ADDR_VAR 0 2
100694: PUSH
100695: LD_INT 22
100697: PUSH
100698: LD_OWVAR 2
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: PUSH
100707: LD_INT 21
100709: PUSH
100710: LD_INT 1
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: PPUSH
100721: CALL_OW 69
100725: PUSH
100726: FOR_IN
100727: IFFALSE 100768
// begin for j := 1 to 4 do
100729: LD_ADDR_VAR 0 3
100733: PUSH
100734: DOUBLE
100735: LD_INT 1
100737: DEC
100738: ST_TO_ADDR
100739: LD_INT 4
100741: PUSH
100742: FOR_TO
100743: IFFALSE 100764
// SetSkill ( i , j , 10 ) ;
100745: LD_VAR 0 2
100749: PPUSH
100750: LD_VAR 0 3
100754: PPUSH
100755: LD_INT 10
100757: PPUSH
100758: CALL_OW 237
100762: GO 100742
100764: POP
100765: POP
// end ;
100766: GO 100726
100768: POP
100769: POP
// end ;
100770: LD_VAR 0 1
100774: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100775: LD_INT 0
100777: PPUSH
// uc_side := your_side ;
100778: LD_ADDR_OWVAR 20
100782: PUSH
100783: LD_OWVAR 2
100787: ST_TO_ADDR
// uc_nation := nation ;
100788: LD_ADDR_OWVAR 21
100792: PUSH
100793: LD_VAR 0 1
100797: ST_TO_ADDR
// InitHc ;
100798: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100802: LD_INT 0
100804: PPUSH
100805: LD_VAR 0 2
100809: PPUSH
100810: LD_VAR 0 3
100814: PPUSH
100815: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100819: LD_VAR 0 4
100823: PPUSH
100824: LD_VAR 0 5
100828: PPUSH
100829: CALL_OW 428
100833: PUSH
100834: LD_INT 0
100836: EQUAL
100837: IFFALSE 100861
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100839: CALL_OW 44
100843: PPUSH
100844: LD_VAR 0 4
100848: PPUSH
100849: LD_VAR 0 5
100853: PPUSH
100854: LD_INT 1
100856: PPUSH
100857: CALL_OW 48
// end ;
100861: LD_VAR 0 6
100865: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100866: LD_INT 0
100868: PPUSH
100869: PPUSH
// uc_side := your_side ;
100870: LD_ADDR_OWVAR 20
100874: PUSH
100875: LD_OWVAR 2
100879: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100880: LD_VAR 0 1
100884: PUSH
100885: LD_INT 1
100887: PUSH
100888: LD_INT 2
100890: PUSH
100891: LD_INT 3
100893: PUSH
100894: LD_INT 4
100896: PUSH
100897: LD_INT 5
100899: PUSH
100900: EMPTY
100901: LIST
100902: LIST
100903: LIST
100904: LIST
100905: LIST
100906: IN
100907: IFFALSE 100919
// uc_nation := nation_american else
100909: LD_ADDR_OWVAR 21
100913: PUSH
100914: LD_INT 1
100916: ST_TO_ADDR
100917: GO 100962
// if chassis in [ 11 , 12 , 13 , 14 ] then
100919: LD_VAR 0 1
100923: PUSH
100924: LD_INT 11
100926: PUSH
100927: LD_INT 12
100929: PUSH
100930: LD_INT 13
100932: PUSH
100933: LD_INT 14
100935: PUSH
100936: EMPTY
100937: LIST
100938: LIST
100939: LIST
100940: LIST
100941: IN
100942: IFFALSE 100954
// uc_nation := nation_arabian else
100944: LD_ADDR_OWVAR 21
100948: PUSH
100949: LD_INT 2
100951: ST_TO_ADDR
100952: GO 100962
// uc_nation := nation_russian ;
100954: LD_ADDR_OWVAR 21
100958: PUSH
100959: LD_INT 3
100961: ST_TO_ADDR
// vc_chassis := chassis ;
100962: LD_ADDR_OWVAR 37
100966: PUSH
100967: LD_VAR 0 1
100971: ST_TO_ADDR
// vc_engine := engine ;
100972: LD_ADDR_OWVAR 39
100976: PUSH
100977: LD_VAR 0 2
100981: ST_TO_ADDR
// vc_control := control ;
100982: LD_ADDR_OWVAR 38
100986: PUSH
100987: LD_VAR 0 3
100991: ST_TO_ADDR
// vc_weapon := weapon ;
100992: LD_ADDR_OWVAR 40
100996: PUSH
100997: LD_VAR 0 4
101001: ST_TO_ADDR
// un := CreateVehicle ;
101002: LD_ADDR_VAR 0 8
101006: PUSH
101007: CALL_OW 45
101011: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101012: LD_VAR 0 8
101016: PPUSH
101017: LD_INT 0
101019: PPUSH
101020: LD_INT 5
101022: PPUSH
101023: CALL_OW 12
101027: PPUSH
101028: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101032: LD_VAR 0 8
101036: PPUSH
101037: LD_VAR 0 5
101041: PPUSH
101042: LD_VAR 0 6
101046: PPUSH
101047: LD_INT 1
101049: PPUSH
101050: CALL_OW 48
// end ;
101054: LD_VAR 0 7
101058: RET
// export hInvincible ; every 1 do
101059: GO 101061
101061: DISABLE
// hInvincible := [ ] ;
101062: LD_ADDR_EXP 163
101066: PUSH
101067: EMPTY
101068: ST_TO_ADDR
101069: END
// every 10 do var i ;
101070: GO 101072
101072: DISABLE
101073: LD_INT 0
101075: PPUSH
// begin enable ;
101076: ENABLE
// if not hInvincible then
101077: LD_EXP 163
101081: NOT
101082: IFFALSE 101086
// exit ;
101084: GO 101130
// for i in hInvincible do
101086: LD_ADDR_VAR 0 1
101090: PUSH
101091: LD_EXP 163
101095: PUSH
101096: FOR_IN
101097: IFFALSE 101128
// if GetLives ( i ) < 1000 then
101099: LD_VAR 0 1
101103: PPUSH
101104: CALL_OW 256
101108: PUSH
101109: LD_INT 1000
101111: LESS
101112: IFFALSE 101126
// SetLives ( i , 1000 ) ;
101114: LD_VAR 0 1
101118: PPUSH
101119: LD_INT 1000
101121: PPUSH
101122: CALL_OW 234
101126: GO 101096
101128: POP
101129: POP
// end ;
101130: PPOPN 1
101132: END
// export function hHackInvincible ; var i ; begin
101133: LD_INT 0
101135: PPUSH
101136: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101137: LD_ADDR_VAR 0 2
101141: PUSH
101142: LD_INT 2
101144: PUSH
101145: LD_INT 21
101147: PUSH
101148: LD_INT 1
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: LD_INT 21
101157: PUSH
101158: LD_INT 2
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: PUSH
101165: EMPTY
101166: LIST
101167: LIST
101168: LIST
101169: PPUSH
101170: CALL_OW 69
101174: PUSH
101175: FOR_IN
101176: IFFALSE 101237
// if IsSelected ( i ) then
101178: LD_VAR 0 2
101182: PPUSH
101183: CALL_OW 306
101187: IFFALSE 101235
// begin if i in hInvincible then
101189: LD_VAR 0 2
101193: PUSH
101194: LD_EXP 163
101198: IN
101199: IFFALSE 101219
// hInvincible := hInvincible diff i else
101201: LD_ADDR_EXP 163
101205: PUSH
101206: LD_EXP 163
101210: PUSH
101211: LD_VAR 0 2
101215: DIFF
101216: ST_TO_ADDR
101217: GO 101235
// hInvincible := hInvincible union i ;
101219: LD_ADDR_EXP 163
101223: PUSH
101224: LD_EXP 163
101228: PUSH
101229: LD_VAR 0 2
101233: UNION
101234: ST_TO_ADDR
// end ;
101235: GO 101175
101237: POP
101238: POP
// end ;
101239: LD_VAR 0 1
101243: RET
// export function hHackInvisible ; var i , j ; begin
101244: LD_INT 0
101246: PPUSH
101247: PPUSH
101248: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101249: LD_ADDR_VAR 0 2
101253: PUSH
101254: LD_INT 21
101256: PUSH
101257: LD_INT 1
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: PPUSH
101264: CALL_OW 69
101268: PUSH
101269: FOR_IN
101270: IFFALSE 101294
// if IsSelected ( i ) then
101272: LD_VAR 0 2
101276: PPUSH
101277: CALL_OW 306
101281: IFFALSE 101292
// ComForceInvisible ( i ) ;
101283: LD_VAR 0 2
101287: PPUSH
101288: CALL_OW 496
101292: GO 101269
101294: POP
101295: POP
// end ;
101296: LD_VAR 0 1
101300: RET
// export function hHackChangeYourSide ; begin
101301: LD_INT 0
101303: PPUSH
// if your_side = 8 then
101304: LD_OWVAR 2
101308: PUSH
101309: LD_INT 8
101311: EQUAL
101312: IFFALSE 101324
// your_side := 0 else
101314: LD_ADDR_OWVAR 2
101318: PUSH
101319: LD_INT 0
101321: ST_TO_ADDR
101322: GO 101338
// your_side := your_side + 1 ;
101324: LD_ADDR_OWVAR 2
101328: PUSH
101329: LD_OWVAR 2
101333: PUSH
101334: LD_INT 1
101336: PLUS
101337: ST_TO_ADDR
// end ;
101338: LD_VAR 0 1
101342: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101343: LD_INT 0
101345: PPUSH
101346: PPUSH
101347: PPUSH
// for i in all_units do
101348: LD_ADDR_VAR 0 2
101352: PUSH
101353: LD_OWVAR 3
101357: PUSH
101358: FOR_IN
101359: IFFALSE 101437
// if IsSelected ( i ) then
101361: LD_VAR 0 2
101365: PPUSH
101366: CALL_OW 306
101370: IFFALSE 101435
// begin j := GetSide ( i ) ;
101372: LD_ADDR_VAR 0 3
101376: PUSH
101377: LD_VAR 0 2
101381: PPUSH
101382: CALL_OW 255
101386: ST_TO_ADDR
// if j = 8 then
101387: LD_VAR 0 3
101391: PUSH
101392: LD_INT 8
101394: EQUAL
101395: IFFALSE 101407
// j := 0 else
101397: LD_ADDR_VAR 0 3
101401: PUSH
101402: LD_INT 0
101404: ST_TO_ADDR
101405: GO 101421
// j := j + 1 ;
101407: LD_ADDR_VAR 0 3
101411: PUSH
101412: LD_VAR 0 3
101416: PUSH
101417: LD_INT 1
101419: PLUS
101420: ST_TO_ADDR
// SetSide ( i , j ) ;
101421: LD_VAR 0 2
101425: PPUSH
101426: LD_VAR 0 3
101430: PPUSH
101431: CALL_OW 235
// end ;
101435: GO 101358
101437: POP
101438: POP
// end ;
101439: LD_VAR 0 1
101443: RET
// export function hHackFog ; begin
101444: LD_INT 0
101446: PPUSH
// FogOff ( true ) ;
101447: LD_INT 1
101449: PPUSH
101450: CALL_OW 344
// end ;
101454: LD_VAR 0 1
101458: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101459: LD_INT 0
101461: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101462: LD_VAR 0 1
101466: PPUSH
101467: LD_VAR 0 2
101471: PPUSH
101472: LD_VAR 0 3
101476: PPUSH
101477: LD_INT 1
101479: PPUSH
101480: LD_INT 1
101482: PPUSH
101483: CALL_OW 483
// CenterOnXY ( x , y ) ;
101487: LD_VAR 0 2
101491: PPUSH
101492: LD_VAR 0 3
101496: PPUSH
101497: CALL_OW 84
// end ;
101501: LD_VAR 0 4
101505: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101506: LD_INT 0
101508: PPUSH
101509: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101510: LD_VAR 0 1
101514: NOT
101515: PUSH
101516: LD_VAR 0 2
101520: PPUSH
101521: LD_VAR 0 3
101525: PPUSH
101526: CALL_OW 488
101530: NOT
101531: OR
101532: PUSH
101533: LD_VAR 0 1
101537: PPUSH
101538: CALL_OW 266
101542: PUSH
101543: LD_INT 3
101545: NONEQUAL
101546: PUSH
101547: LD_VAR 0 1
101551: PPUSH
101552: CALL_OW 247
101556: PUSH
101557: LD_INT 1
101559: EQUAL
101560: NOT
101561: AND
101562: OR
101563: IFFALSE 101567
// exit ;
101565: GO 101716
// if GetType ( factory ) = unit_human then
101567: LD_VAR 0 1
101571: PPUSH
101572: CALL_OW 247
101576: PUSH
101577: LD_INT 1
101579: EQUAL
101580: IFFALSE 101597
// factory := IsInUnit ( factory ) ;
101582: LD_ADDR_VAR 0 1
101586: PUSH
101587: LD_VAR 0 1
101591: PPUSH
101592: CALL_OW 310
101596: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101597: LD_VAR 0 1
101601: PPUSH
101602: CALL_OW 266
101606: PUSH
101607: LD_INT 3
101609: NONEQUAL
101610: IFFALSE 101614
// exit ;
101612: GO 101716
// if HexInfo ( x , y ) = factory then
101614: LD_VAR 0 2
101618: PPUSH
101619: LD_VAR 0 3
101623: PPUSH
101624: CALL_OW 428
101628: PUSH
101629: LD_VAR 0 1
101633: EQUAL
101634: IFFALSE 101661
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101636: LD_ADDR_EXP 164
101640: PUSH
101641: LD_EXP 164
101645: PPUSH
101646: LD_VAR 0 1
101650: PPUSH
101651: LD_INT 0
101653: PPUSH
101654: CALL_OW 1
101658: ST_TO_ADDR
101659: GO 101712
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101661: LD_ADDR_EXP 164
101665: PUSH
101666: LD_EXP 164
101670: PPUSH
101671: LD_VAR 0 1
101675: PPUSH
101676: LD_VAR 0 1
101680: PPUSH
101681: CALL_OW 255
101685: PUSH
101686: LD_VAR 0 1
101690: PUSH
101691: LD_VAR 0 2
101695: PUSH
101696: LD_VAR 0 3
101700: PUSH
101701: EMPTY
101702: LIST
101703: LIST
101704: LIST
101705: LIST
101706: PPUSH
101707: CALL_OW 1
101711: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101712: CALL 101721 0 0
// end ;
101716: LD_VAR 0 4
101720: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101721: LD_INT 0
101723: PPUSH
101724: PPUSH
101725: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101726: LD_STRING resetFactoryWaypoint();
101728: PPUSH
101729: CALL_OW 559
// if factoryWaypoints then
101733: LD_EXP 164
101737: IFFALSE 101863
// begin list := PrepareArray ( factoryWaypoints ) ;
101739: LD_ADDR_VAR 0 3
101743: PUSH
101744: LD_EXP 164
101748: PPUSH
101749: CALL 56159 0 1
101753: ST_TO_ADDR
// for i := 1 to list do
101754: LD_ADDR_VAR 0 2
101758: PUSH
101759: DOUBLE
101760: LD_INT 1
101762: DEC
101763: ST_TO_ADDR
101764: LD_VAR 0 3
101768: PUSH
101769: FOR_TO
101770: IFFALSE 101861
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101772: LD_STRING setFactoryWaypointXY(
101774: PUSH
101775: LD_VAR 0 3
101779: PUSH
101780: LD_VAR 0 2
101784: ARRAY
101785: PUSH
101786: LD_INT 1
101788: ARRAY
101789: STR
101790: PUSH
101791: LD_STRING ,
101793: STR
101794: PUSH
101795: LD_VAR 0 3
101799: PUSH
101800: LD_VAR 0 2
101804: ARRAY
101805: PUSH
101806: LD_INT 2
101808: ARRAY
101809: STR
101810: PUSH
101811: LD_STRING ,
101813: STR
101814: PUSH
101815: LD_VAR 0 3
101819: PUSH
101820: LD_VAR 0 2
101824: ARRAY
101825: PUSH
101826: LD_INT 3
101828: ARRAY
101829: STR
101830: PUSH
101831: LD_STRING ,
101833: STR
101834: PUSH
101835: LD_VAR 0 3
101839: PUSH
101840: LD_VAR 0 2
101844: ARRAY
101845: PUSH
101846: LD_INT 4
101848: ARRAY
101849: STR
101850: PUSH
101851: LD_STRING )
101853: STR
101854: PPUSH
101855: CALL_OW 559
101859: GO 101769
101861: POP
101862: POP
// end ; end ;
101863: LD_VAR 0 1
101867: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101868: LD_INT 0
101870: PPUSH
// if HexInfo ( x , y ) = warehouse then
101871: LD_VAR 0 2
101875: PPUSH
101876: LD_VAR 0 3
101880: PPUSH
101881: CALL_OW 428
101885: PUSH
101886: LD_VAR 0 1
101890: EQUAL
101891: IFFALSE 101918
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101893: LD_ADDR_EXP 165
101897: PUSH
101898: LD_EXP 165
101902: PPUSH
101903: LD_VAR 0 1
101907: PPUSH
101908: LD_INT 0
101910: PPUSH
101911: CALL_OW 1
101915: ST_TO_ADDR
101916: GO 101969
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101918: LD_ADDR_EXP 165
101922: PUSH
101923: LD_EXP 165
101927: PPUSH
101928: LD_VAR 0 1
101932: PPUSH
101933: LD_VAR 0 1
101937: PPUSH
101938: CALL_OW 255
101942: PUSH
101943: LD_VAR 0 1
101947: PUSH
101948: LD_VAR 0 2
101952: PUSH
101953: LD_VAR 0 3
101957: PUSH
101958: EMPTY
101959: LIST
101960: LIST
101961: LIST
101962: LIST
101963: PPUSH
101964: CALL_OW 1
101968: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
101969: CALL 101978 0 0
// end ;
101973: LD_VAR 0 4
101977: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
101978: LD_INT 0
101980: PPUSH
101981: PPUSH
101982: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
101983: LD_STRING resetWarehouseGatheringPoints();
101985: PPUSH
101986: CALL_OW 559
// if warehouseGatheringPoints then
101990: LD_EXP 165
101994: IFFALSE 102120
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
101996: LD_ADDR_VAR 0 3
102000: PUSH
102001: LD_EXP 165
102005: PPUSH
102006: CALL 56159 0 1
102010: ST_TO_ADDR
// for i := 1 to list do
102011: LD_ADDR_VAR 0 2
102015: PUSH
102016: DOUBLE
102017: LD_INT 1
102019: DEC
102020: ST_TO_ADDR
102021: LD_VAR 0 3
102025: PUSH
102026: FOR_TO
102027: IFFALSE 102118
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102029: LD_STRING setWarehouseGatheringPointXY(
102031: PUSH
102032: LD_VAR 0 3
102036: PUSH
102037: LD_VAR 0 2
102041: ARRAY
102042: PUSH
102043: LD_INT 1
102045: ARRAY
102046: STR
102047: PUSH
102048: LD_STRING ,
102050: STR
102051: PUSH
102052: LD_VAR 0 3
102056: PUSH
102057: LD_VAR 0 2
102061: ARRAY
102062: PUSH
102063: LD_INT 2
102065: ARRAY
102066: STR
102067: PUSH
102068: LD_STRING ,
102070: STR
102071: PUSH
102072: LD_VAR 0 3
102076: PUSH
102077: LD_VAR 0 2
102081: ARRAY
102082: PUSH
102083: LD_INT 3
102085: ARRAY
102086: STR
102087: PUSH
102088: LD_STRING ,
102090: STR
102091: PUSH
102092: LD_VAR 0 3
102096: PUSH
102097: LD_VAR 0 2
102101: ARRAY
102102: PUSH
102103: LD_INT 4
102105: ARRAY
102106: STR
102107: PUSH
102108: LD_STRING )
102110: STR
102111: PPUSH
102112: CALL_OW 559
102116: GO 102026
102118: POP
102119: POP
// end ; end ;
102120: LD_VAR 0 1
102124: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102125: LD_EXP 165
102129: IFFALSE 102814
102131: GO 102133
102133: DISABLE
102134: LD_INT 0
102136: PPUSH
102137: PPUSH
102138: PPUSH
102139: PPUSH
102140: PPUSH
102141: PPUSH
102142: PPUSH
102143: PPUSH
102144: PPUSH
// begin enable ;
102145: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102146: LD_ADDR_VAR 0 3
102150: PUSH
102151: LD_EXP 165
102155: PPUSH
102156: CALL 56159 0 1
102160: ST_TO_ADDR
// if not list then
102161: LD_VAR 0 3
102165: NOT
102166: IFFALSE 102170
// exit ;
102168: GO 102814
// for i := 1 to list do
102170: LD_ADDR_VAR 0 1
102174: PUSH
102175: DOUBLE
102176: LD_INT 1
102178: DEC
102179: ST_TO_ADDR
102180: LD_VAR 0 3
102184: PUSH
102185: FOR_TO
102186: IFFALSE 102812
// begin depot := list [ i ] [ 2 ] ;
102188: LD_ADDR_VAR 0 8
102192: PUSH
102193: LD_VAR 0 3
102197: PUSH
102198: LD_VAR 0 1
102202: ARRAY
102203: PUSH
102204: LD_INT 2
102206: ARRAY
102207: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102208: LD_ADDR_VAR 0 5
102212: PUSH
102213: LD_VAR 0 3
102217: PUSH
102218: LD_VAR 0 1
102222: ARRAY
102223: PUSH
102224: LD_INT 1
102226: ARRAY
102227: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102228: LD_VAR 0 8
102232: PPUSH
102233: CALL_OW 301
102237: PUSH
102238: LD_VAR 0 5
102242: PUSH
102243: LD_VAR 0 8
102247: PPUSH
102248: CALL_OW 255
102252: NONEQUAL
102253: OR
102254: IFFALSE 102283
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102256: LD_ADDR_EXP 165
102260: PUSH
102261: LD_EXP 165
102265: PPUSH
102266: LD_VAR 0 8
102270: PPUSH
102271: LD_INT 0
102273: PPUSH
102274: CALL_OW 1
102278: ST_TO_ADDR
// exit ;
102279: POP
102280: POP
102281: GO 102814
// end ; x := list [ i ] [ 3 ] ;
102283: LD_ADDR_VAR 0 6
102287: PUSH
102288: LD_VAR 0 3
102292: PUSH
102293: LD_VAR 0 1
102297: ARRAY
102298: PUSH
102299: LD_INT 3
102301: ARRAY
102302: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102303: LD_ADDR_VAR 0 7
102307: PUSH
102308: LD_VAR 0 3
102312: PUSH
102313: LD_VAR 0 1
102317: ARRAY
102318: PUSH
102319: LD_INT 4
102321: ARRAY
102322: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102323: LD_ADDR_VAR 0 9
102327: PUSH
102328: LD_VAR 0 6
102332: PPUSH
102333: LD_VAR 0 7
102337: PPUSH
102338: LD_INT 16
102340: PPUSH
102341: CALL 54747 0 3
102345: ST_TO_ADDR
// if not cratesNearbyPoint then
102346: LD_VAR 0 9
102350: NOT
102351: IFFALSE 102357
// exit ;
102353: POP
102354: POP
102355: GO 102814
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102357: LD_ADDR_VAR 0 4
102361: PUSH
102362: LD_INT 22
102364: PUSH
102365: LD_VAR 0 5
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: PUSH
102374: LD_INT 3
102376: PUSH
102377: LD_INT 60
102379: PUSH
102380: EMPTY
102381: LIST
102382: PUSH
102383: EMPTY
102384: LIST
102385: LIST
102386: PUSH
102387: LD_INT 91
102389: PUSH
102390: LD_VAR 0 8
102394: PUSH
102395: LD_INT 6
102397: PUSH
102398: EMPTY
102399: LIST
102400: LIST
102401: LIST
102402: PUSH
102403: LD_INT 2
102405: PUSH
102406: LD_INT 25
102408: PUSH
102409: LD_INT 2
102411: PUSH
102412: EMPTY
102413: LIST
102414: LIST
102415: PUSH
102416: LD_INT 25
102418: PUSH
102419: LD_INT 16
102421: PUSH
102422: EMPTY
102423: LIST
102424: LIST
102425: PUSH
102426: EMPTY
102427: LIST
102428: LIST
102429: LIST
102430: PUSH
102431: EMPTY
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: PPUSH
102437: CALL_OW 69
102441: PUSH
102442: LD_VAR 0 8
102446: PPUSH
102447: CALL_OW 313
102451: PPUSH
102452: LD_INT 3
102454: PUSH
102455: LD_INT 60
102457: PUSH
102458: EMPTY
102459: LIST
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PUSH
102465: LD_INT 2
102467: PUSH
102468: LD_INT 25
102470: PUSH
102471: LD_INT 2
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: PUSH
102478: LD_INT 25
102480: PUSH
102481: LD_INT 16
102483: PUSH
102484: EMPTY
102485: LIST
102486: LIST
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: LIST
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PPUSH
102497: CALL_OW 72
102501: UNION
102502: ST_TO_ADDR
// if tmp then
102503: LD_VAR 0 4
102507: IFFALSE 102587
// begin tmp := ShrinkArray ( tmp , 3 ) ;
102509: LD_ADDR_VAR 0 4
102513: PUSH
102514: LD_VAR 0 4
102518: PPUSH
102519: LD_INT 3
102521: PPUSH
102522: CALL 52716 0 2
102526: ST_TO_ADDR
// for j in tmp do
102527: LD_ADDR_VAR 0 2
102531: PUSH
102532: LD_VAR 0 4
102536: PUSH
102537: FOR_IN
102538: IFFALSE 102581
// begin if IsInUnit ( j ) then
102540: LD_VAR 0 2
102544: PPUSH
102545: CALL_OW 310
102549: IFFALSE 102560
// ComExit ( j ) ;
102551: LD_VAR 0 2
102555: PPUSH
102556: CALL 52799 0 1
// AddComCollect ( j , x , y ) ;
102560: LD_VAR 0 2
102564: PPUSH
102565: LD_VAR 0 6
102569: PPUSH
102570: LD_VAR 0 7
102574: PPUSH
102575: CALL_OW 177
// end ;
102579: GO 102537
102581: POP
102582: POP
// exit ;
102583: POP
102584: POP
102585: GO 102814
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102587: LD_ADDR_VAR 0 4
102591: PUSH
102592: LD_INT 22
102594: PUSH
102595: LD_VAR 0 5
102599: PUSH
102600: EMPTY
102601: LIST
102602: LIST
102603: PUSH
102604: LD_INT 91
102606: PUSH
102607: LD_VAR 0 8
102611: PUSH
102612: LD_INT 8
102614: PUSH
102615: EMPTY
102616: LIST
102617: LIST
102618: LIST
102619: PUSH
102620: LD_INT 2
102622: PUSH
102623: LD_INT 34
102625: PUSH
102626: LD_INT 12
102628: PUSH
102629: EMPTY
102630: LIST
102631: LIST
102632: PUSH
102633: LD_INT 34
102635: PUSH
102636: LD_INT 51
102638: PUSH
102639: EMPTY
102640: LIST
102641: LIST
102642: PUSH
102643: LD_INT 34
102645: PUSH
102646: LD_INT 32
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: PUSH
102653: LD_INT 34
102655: PUSH
102656: LD_INT 89
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: LIST
102667: LIST
102668: LIST
102669: PUSH
102670: EMPTY
102671: LIST
102672: LIST
102673: LIST
102674: PPUSH
102675: CALL_OW 69
102679: ST_TO_ADDR
// if tmp then
102680: LD_VAR 0 4
102684: IFFALSE 102810
// begin for j in tmp do
102686: LD_ADDR_VAR 0 2
102690: PUSH
102691: LD_VAR 0 4
102695: PUSH
102696: FOR_IN
102697: IFFALSE 102808
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102699: LD_VAR 0 2
102703: PPUSH
102704: CALL_OW 262
102708: PUSH
102709: LD_INT 3
102711: EQUAL
102712: PUSH
102713: LD_VAR 0 2
102717: PPUSH
102718: CALL_OW 261
102722: PUSH
102723: LD_INT 20
102725: GREATER
102726: OR
102727: PUSH
102728: LD_VAR 0 2
102732: PPUSH
102733: CALL_OW 314
102737: NOT
102738: AND
102739: PUSH
102740: LD_VAR 0 2
102744: PPUSH
102745: CALL_OW 263
102749: PUSH
102750: LD_INT 1
102752: NONEQUAL
102753: PUSH
102754: LD_VAR 0 2
102758: PPUSH
102759: CALL_OW 311
102763: OR
102764: AND
102765: IFFALSE 102806
// begin ComCollect ( j , x , y ) ;
102767: LD_VAR 0 2
102771: PPUSH
102772: LD_VAR 0 6
102776: PPUSH
102777: LD_VAR 0 7
102781: PPUSH
102782: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102786: LD_VAR 0 2
102790: PPUSH
102791: LD_VAR 0 8
102795: PPUSH
102796: CALL_OW 172
// exit ;
102800: POP
102801: POP
102802: POP
102803: POP
102804: GO 102814
// end ;
102806: GO 102696
102808: POP
102809: POP
// end ; end ;
102810: GO 102185
102812: POP
102813: POP
// end ; end_of_file
102814: PPOPN 9
102816: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102817: LD_INT 0
102819: PPUSH
102820: PPUSH
102821: PPUSH
102822: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102823: LD_VAR 0 1
102827: PPUSH
102828: CALL_OW 264
102832: PUSH
102833: LD_INT 91
102835: EQUAL
102836: IFFALSE 102908
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102838: LD_INT 68
102840: PPUSH
102841: LD_VAR 0 1
102845: PPUSH
102846: CALL_OW 255
102850: PPUSH
102851: CALL_OW 321
102855: PUSH
102856: LD_INT 2
102858: EQUAL
102859: IFFALSE 102871
// eff := 70 else
102861: LD_ADDR_VAR 0 4
102865: PUSH
102866: LD_INT 70
102868: ST_TO_ADDR
102869: GO 102879
// eff := 30 ;
102871: LD_ADDR_VAR 0 4
102875: PUSH
102876: LD_INT 30
102878: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102879: LD_VAR 0 1
102883: PPUSH
102884: CALL_OW 250
102888: PPUSH
102889: LD_VAR 0 1
102893: PPUSH
102894: CALL_OW 251
102898: PPUSH
102899: LD_VAR 0 4
102903: PPUSH
102904: CALL_OW 495
// end ; end ;
102908: LD_VAR 0 2
102912: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102913: LD_INT 0
102915: PPUSH
// end ;
102916: LD_VAR 0 4
102920: RET
// export function SOS_Command ( cmd ) ; begin
102921: LD_INT 0
102923: PPUSH
// end ;
102924: LD_VAR 0 2
102928: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102929: LD_INT 0
102931: PPUSH
// end ;
102932: LD_VAR 0 6
102936: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102937: LD_INT 0
102939: PPUSH
102940: PPUSH
// if not vehicle or not factory then
102941: LD_VAR 0 1
102945: NOT
102946: PUSH
102947: LD_VAR 0 2
102951: NOT
102952: OR
102953: IFFALSE 102957
// exit ;
102955: GO 103188
// if factoryWaypoints >= factory then
102957: LD_EXP 164
102961: PUSH
102962: LD_VAR 0 2
102966: GREATEREQUAL
102967: IFFALSE 103188
// if factoryWaypoints [ factory ] then
102969: LD_EXP 164
102973: PUSH
102974: LD_VAR 0 2
102978: ARRAY
102979: IFFALSE 103188
// begin if GetControl ( vehicle ) = control_manual then
102981: LD_VAR 0 1
102985: PPUSH
102986: CALL_OW 263
102990: PUSH
102991: LD_INT 1
102993: EQUAL
102994: IFFALSE 103075
// begin driver := IsDrivenBy ( vehicle ) ;
102996: LD_ADDR_VAR 0 4
103000: PUSH
103001: LD_VAR 0 1
103005: PPUSH
103006: CALL_OW 311
103010: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103011: LD_VAR 0 4
103015: PPUSH
103016: LD_EXP 164
103020: PUSH
103021: LD_VAR 0 2
103025: ARRAY
103026: PUSH
103027: LD_INT 3
103029: ARRAY
103030: PPUSH
103031: LD_EXP 164
103035: PUSH
103036: LD_VAR 0 2
103040: ARRAY
103041: PUSH
103042: LD_INT 4
103044: ARRAY
103045: PPUSH
103046: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103050: LD_VAR 0 4
103054: PPUSH
103055: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103059: LD_VAR 0 4
103063: PPUSH
103064: LD_VAR 0 2
103068: PPUSH
103069: CALL_OW 180
// end else
103073: GO 103188
// if GetControl ( vehicle ) = control_remote then
103075: LD_VAR 0 1
103079: PPUSH
103080: CALL_OW 263
103084: PUSH
103085: LD_INT 2
103087: EQUAL
103088: IFFALSE 103149
// begin wait ( 0 0$2 ) ;
103090: LD_INT 70
103092: PPUSH
103093: CALL_OW 67
// if Connect ( vehicle ) then
103097: LD_VAR 0 1
103101: PPUSH
103102: CALL 23039 0 1
103106: IFFALSE 103147
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103108: LD_VAR 0 1
103112: PPUSH
103113: LD_EXP 164
103117: PUSH
103118: LD_VAR 0 2
103122: ARRAY
103123: PUSH
103124: LD_INT 3
103126: ARRAY
103127: PPUSH
103128: LD_EXP 164
103132: PUSH
103133: LD_VAR 0 2
103137: ARRAY
103138: PUSH
103139: LD_INT 4
103141: ARRAY
103142: PPUSH
103143: CALL_OW 171
// end else
103147: GO 103188
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103149: LD_VAR 0 1
103153: PPUSH
103154: LD_EXP 164
103158: PUSH
103159: LD_VAR 0 2
103163: ARRAY
103164: PUSH
103165: LD_INT 3
103167: ARRAY
103168: PPUSH
103169: LD_EXP 164
103173: PUSH
103174: LD_VAR 0 2
103178: ARRAY
103179: PUSH
103180: LD_INT 4
103182: ARRAY
103183: PPUSH
103184: CALL_OW 171
// end ; end ;
103188: LD_VAR 0 3
103192: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103193: LD_INT 0
103195: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103196: LD_VAR 0 1
103200: PUSH
103201: LD_INT 250
103203: EQUAL
103204: PUSH
103205: LD_VAR 0 2
103209: PPUSH
103210: CALL_OW 264
103214: PUSH
103215: LD_INT 81
103217: EQUAL
103218: AND
103219: IFFALSE 103240
// MinerPlaceMine ( unit , x , y ) ;
103221: LD_VAR 0 2
103225: PPUSH
103226: LD_VAR 0 4
103230: PPUSH
103231: LD_VAR 0 5
103235: PPUSH
103236: CALL 105625 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103240: LD_VAR 0 1
103244: PUSH
103245: LD_INT 251
103247: EQUAL
103248: PUSH
103249: LD_VAR 0 2
103253: PPUSH
103254: CALL_OW 264
103258: PUSH
103259: LD_INT 81
103261: EQUAL
103262: AND
103263: IFFALSE 103284
// MinerDetonateMine ( unit , x , y ) ;
103265: LD_VAR 0 2
103269: PPUSH
103270: LD_VAR 0 4
103274: PPUSH
103275: LD_VAR 0 5
103279: PPUSH
103280: CALL 105900 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103284: LD_VAR 0 1
103288: PUSH
103289: LD_INT 252
103291: EQUAL
103292: PUSH
103293: LD_VAR 0 2
103297: PPUSH
103298: CALL_OW 264
103302: PUSH
103303: LD_INT 81
103305: EQUAL
103306: AND
103307: IFFALSE 103328
// MinerCreateMinefield ( unit , x , y ) ;
103309: LD_VAR 0 2
103313: PPUSH
103314: LD_VAR 0 4
103318: PPUSH
103319: LD_VAR 0 5
103323: PPUSH
103324: CALL 106317 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103328: LD_VAR 0 1
103332: PUSH
103333: LD_INT 253
103335: EQUAL
103336: PUSH
103337: LD_VAR 0 2
103341: PPUSH
103342: CALL_OW 257
103346: PUSH
103347: LD_INT 5
103349: EQUAL
103350: AND
103351: IFFALSE 103372
// ComBinocular ( unit , x , y ) ;
103353: LD_VAR 0 2
103357: PPUSH
103358: LD_VAR 0 4
103362: PPUSH
103363: LD_VAR 0 5
103367: PPUSH
103368: CALL 106686 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103372: LD_VAR 0 1
103376: PUSH
103377: LD_INT 254
103379: EQUAL
103380: PUSH
103381: LD_VAR 0 2
103385: PPUSH
103386: CALL_OW 264
103390: PUSH
103391: LD_INT 99
103393: EQUAL
103394: AND
103395: PUSH
103396: LD_VAR 0 3
103400: PPUSH
103401: CALL_OW 263
103405: PUSH
103406: LD_INT 3
103408: EQUAL
103409: AND
103410: IFFALSE 103426
// HackDestroyVehicle ( unit , selectedUnit ) ;
103412: LD_VAR 0 2
103416: PPUSH
103417: LD_VAR 0 3
103421: PPUSH
103422: CALL 104989 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103426: LD_VAR 0 1
103430: PUSH
103431: LD_INT 255
103433: EQUAL
103434: PUSH
103435: LD_VAR 0 2
103439: PPUSH
103440: CALL_OW 264
103444: PUSH
103445: LD_INT 14
103447: PUSH
103448: LD_INT 53
103450: PUSH
103451: EMPTY
103452: LIST
103453: LIST
103454: IN
103455: AND
103456: PUSH
103457: LD_VAR 0 4
103461: PPUSH
103462: LD_VAR 0 5
103466: PPUSH
103467: CALL_OW 488
103471: AND
103472: IFFALSE 103496
// CutTreeXYR ( unit , x , y , 12 ) ;
103474: LD_VAR 0 2
103478: PPUSH
103479: LD_VAR 0 4
103483: PPUSH
103484: LD_VAR 0 5
103488: PPUSH
103489: LD_INT 12
103491: PPUSH
103492: CALL 103559 0 4
// if cmd = 256 then
103496: LD_VAR 0 1
103500: PUSH
103501: LD_INT 256
103503: EQUAL
103504: IFFALSE 103525
// SetFactoryWaypoint ( unit , x , y ) ;
103506: LD_VAR 0 2
103510: PPUSH
103511: LD_VAR 0 4
103515: PPUSH
103516: LD_VAR 0 5
103520: PPUSH
103521: CALL 101506 0 3
// if cmd = 257 then
103525: LD_VAR 0 1
103529: PUSH
103530: LD_INT 257
103532: EQUAL
103533: IFFALSE 103554
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103535: LD_VAR 0 2
103539: PPUSH
103540: LD_VAR 0 4
103544: PPUSH
103545: LD_VAR 0 5
103549: PPUSH
103550: CALL 101868 0 3
// end ;
103554: LD_VAR 0 6
103558: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103559: LD_INT 0
103561: PPUSH
103562: PPUSH
103563: PPUSH
103564: PPUSH
103565: PPUSH
103566: PPUSH
103567: PPUSH
103568: PPUSH
103569: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103570: LD_VAR 0 1
103574: NOT
103575: PUSH
103576: LD_VAR 0 2
103580: PPUSH
103581: LD_VAR 0 3
103585: PPUSH
103586: CALL_OW 488
103590: NOT
103591: OR
103592: PUSH
103593: LD_VAR 0 4
103597: NOT
103598: OR
103599: IFFALSE 103603
// exit ;
103601: GO 103943
// list := [ ] ;
103603: LD_ADDR_VAR 0 13
103607: PUSH
103608: EMPTY
103609: ST_TO_ADDR
// if x - r < 0 then
103610: LD_VAR 0 2
103614: PUSH
103615: LD_VAR 0 4
103619: MINUS
103620: PUSH
103621: LD_INT 0
103623: LESS
103624: IFFALSE 103636
// min_x := 0 else
103626: LD_ADDR_VAR 0 7
103630: PUSH
103631: LD_INT 0
103633: ST_TO_ADDR
103634: GO 103652
// min_x := x - r ;
103636: LD_ADDR_VAR 0 7
103640: PUSH
103641: LD_VAR 0 2
103645: PUSH
103646: LD_VAR 0 4
103650: MINUS
103651: ST_TO_ADDR
// if y - r < 0 then
103652: LD_VAR 0 3
103656: PUSH
103657: LD_VAR 0 4
103661: MINUS
103662: PUSH
103663: LD_INT 0
103665: LESS
103666: IFFALSE 103678
// min_y := 0 else
103668: LD_ADDR_VAR 0 8
103672: PUSH
103673: LD_INT 0
103675: ST_TO_ADDR
103676: GO 103694
// min_y := y - r ;
103678: LD_ADDR_VAR 0 8
103682: PUSH
103683: LD_VAR 0 3
103687: PUSH
103688: LD_VAR 0 4
103692: MINUS
103693: ST_TO_ADDR
// max_x := x + r ;
103694: LD_ADDR_VAR 0 9
103698: PUSH
103699: LD_VAR 0 2
103703: PUSH
103704: LD_VAR 0 4
103708: PLUS
103709: ST_TO_ADDR
// max_y := y + r ;
103710: LD_ADDR_VAR 0 10
103714: PUSH
103715: LD_VAR 0 3
103719: PUSH
103720: LD_VAR 0 4
103724: PLUS
103725: ST_TO_ADDR
// for _x = min_x to max_x do
103726: LD_ADDR_VAR 0 11
103730: PUSH
103731: DOUBLE
103732: LD_VAR 0 7
103736: DEC
103737: ST_TO_ADDR
103738: LD_VAR 0 9
103742: PUSH
103743: FOR_TO
103744: IFFALSE 103861
// for _y = min_y to max_y do
103746: LD_ADDR_VAR 0 12
103750: PUSH
103751: DOUBLE
103752: LD_VAR 0 8
103756: DEC
103757: ST_TO_ADDR
103758: LD_VAR 0 10
103762: PUSH
103763: FOR_TO
103764: IFFALSE 103857
// begin if not ValidHex ( _x , _y ) then
103766: LD_VAR 0 11
103770: PPUSH
103771: LD_VAR 0 12
103775: PPUSH
103776: CALL_OW 488
103780: NOT
103781: IFFALSE 103785
// continue ;
103783: GO 103763
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103785: LD_VAR 0 11
103789: PPUSH
103790: LD_VAR 0 12
103794: PPUSH
103795: CALL_OW 351
103799: PUSH
103800: LD_VAR 0 11
103804: PPUSH
103805: LD_VAR 0 12
103809: PPUSH
103810: CALL_OW 554
103814: AND
103815: IFFALSE 103855
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103817: LD_ADDR_VAR 0 13
103821: PUSH
103822: LD_VAR 0 13
103826: PPUSH
103827: LD_VAR 0 13
103831: PUSH
103832: LD_INT 1
103834: PLUS
103835: PPUSH
103836: LD_VAR 0 11
103840: PUSH
103841: LD_VAR 0 12
103845: PUSH
103846: EMPTY
103847: LIST
103848: LIST
103849: PPUSH
103850: CALL_OW 2
103854: ST_TO_ADDR
// end ;
103855: GO 103763
103857: POP
103858: POP
103859: GO 103743
103861: POP
103862: POP
// if not list then
103863: LD_VAR 0 13
103867: NOT
103868: IFFALSE 103872
// exit ;
103870: GO 103943
// for i in list do
103872: LD_ADDR_VAR 0 6
103876: PUSH
103877: LD_VAR 0 13
103881: PUSH
103882: FOR_IN
103883: IFFALSE 103941
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103885: LD_VAR 0 1
103889: PPUSH
103890: LD_STRING M
103892: PUSH
103893: LD_VAR 0 6
103897: PUSH
103898: LD_INT 1
103900: ARRAY
103901: PUSH
103902: LD_VAR 0 6
103906: PUSH
103907: LD_INT 2
103909: ARRAY
103910: PUSH
103911: LD_INT 0
103913: PUSH
103914: LD_INT 0
103916: PUSH
103917: LD_INT 0
103919: PUSH
103920: LD_INT 0
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: LIST
103927: LIST
103928: LIST
103929: LIST
103930: LIST
103931: PUSH
103932: EMPTY
103933: LIST
103934: PPUSH
103935: CALL_OW 447
103939: GO 103882
103941: POP
103942: POP
// end ;
103943: LD_VAR 0 5
103947: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103948: LD_EXP 167
103952: NOT
103953: IFFALSE 104003
103955: GO 103957
103957: DISABLE
// begin initHack := true ;
103958: LD_ADDR_EXP 167
103962: PUSH
103963: LD_INT 1
103965: ST_TO_ADDR
// hackTanks := [ ] ;
103966: LD_ADDR_EXP 168
103970: PUSH
103971: EMPTY
103972: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103973: LD_ADDR_EXP 169
103977: PUSH
103978: EMPTY
103979: ST_TO_ADDR
// hackLimit := 3 ;
103980: LD_ADDR_EXP 170
103984: PUSH
103985: LD_INT 3
103987: ST_TO_ADDR
// hackDist := 12 ;
103988: LD_ADDR_EXP 171
103992: PUSH
103993: LD_INT 12
103995: ST_TO_ADDR
// hackCounter := [ ] ;
103996: LD_ADDR_EXP 172
104000: PUSH
104001: EMPTY
104002: ST_TO_ADDR
// end ;
104003: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104004: LD_EXP 167
104008: PUSH
104009: LD_INT 34
104011: PUSH
104012: LD_INT 99
104014: PUSH
104015: EMPTY
104016: LIST
104017: LIST
104018: PPUSH
104019: CALL_OW 69
104023: AND
104024: IFFALSE 104277
104026: GO 104028
104028: DISABLE
104029: LD_INT 0
104031: PPUSH
104032: PPUSH
// begin enable ;
104033: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104034: LD_ADDR_VAR 0 1
104038: PUSH
104039: LD_INT 34
104041: PUSH
104042: LD_INT 99
104044: PUSH
104045: EMPTY
104046: LIST
104047: LIST
104048: PPUSH
104049: CALL_OW 69
104053: PUSH
104054: FOR_IN
104055: IFFALSE 104275
// begin if not i in hackTanks then
104057: LD_VAR 0 1
104061: PUSH
104062: LD_EXP 168
104066: IN
104067: NOT
104068: IFFALSE 104151
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104070: LD_ADDR_EXP 168
104074: PUSH
104075: LD_EXP 168
104079: PPUSH
104080: LD_EXP 168
104084: PUSH
104085: LD_INT 1
104087: PLUS
104088: PPUSH
104089: LD_VAR 0 1
104093: PPUSH
104094: CALL_OW 1
104098: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104099: LD_ADDR_EXP 169
104103: PUSH
104104: LD_EXP 169
104108: PPUSH
104109: LD_EXP 169
104113: PUSH
104114: LD_INT 1
104116: PLUS
104117: PPUSH
104118: EMPTY
104119: PPUSH
104120: CALL_OW 1
104124: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104125: LD_ADDR_EXP 172
104129: PUSH
104130: LD_EXP 172
104134: PPUSH
104135: LD_EXP 172
104139: PUSH
104140: LD_INT 1
104142: PLUS
104143: PPUSH
104144: EMPTY
104145: PPUSH
104146: CALL_OW 1
104150: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104151: LD_VAR 0 1
104155: PPUSH
104156: CALL_OW 302
104160: NOT
104161: IFFALSE 104174
// begin HackUnlinkAll ( i ) ;
104163: LD_VAR 0 1
104167: PPUSH
104168: CALL 104280 0 1
// continue ;
104172: GO 104054
// end ; HackCheckCapturedStatus ( i ) ;
104174: LD_VAR 0 1
104178: PPUSH
104179: CALL 104723 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104183: LD_ADDR_VAR 0 2
104187: PUSH
104188: LD_INT 81
104190: PUSH
104191: LD_VAR 0 1
104195: PPUSH
104196: CALL_OW 255
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PUSH
104205: LD_INT 33
104207: PUSH
104208: LD_INT 3
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: PUSH
104215: LD_INT 91
104217: PUSH
104218: LD_VAR 0 1
104222: PUSH
104223: LD_EXP 171
104227: PUSH
104228: EMPTY
104229: LIST
104230: LIST
104231: LIST
104232: PUSH
104233: LD_INT 50
104235: PUSH
104236: EMPTY
104237: LIST
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: LIST
104243: LIST
104244: PPUSH
104245: CALL_OW 69
104249: ST_TO_ADDR
// if not tmp then
104250: LD_VAR 0 2
104254: NOT
104255: IFFALSE 104259
// continue ;
104257: GO 104054
// HackLink ( i , tmp ) ;
104259: LD_VAR 0 1
104263: PPUSH
104264: LD_VAR 0 2
104268: PPUSH
104269: CALL 104416 0 2
// end ;
104273: GO 104054
104275: POP
104276: POP
// end ;
104277: PPOPN 2
104279: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104280: LD_INT 0
104282: PPUSH
104283: PPUSH
104284: PPUSH
// if not hack in hackTanks then
104285: LD_VAR 0 1
104289: PUSH
104290: LD_EXP 168
104294: IN
104295: NOT
104296: IFFALSE 104300
// exit ;
104298: GO 104411
// index := GetElementIndex ( hackTanks , hack ) ;
104300: LD_ADDR_VAR 0 4
104304: PUSH
104305: LD_EXP 168
104309: PPUSH
104310: LD_VAR 0 1
104314: PPUSH
104315: CALL 19855 0 2
104319: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104320: LD_EXP 169
104324: PUSH
104325: LD_VAR 0 4
104329: ARRAY
104330: IFFALSE 104411
// begin for i in hackTanksCaptured [ index ] do
104332: LD_ADDR_VAR 0 3
104336: PUSH
104337: LD_EXP 169
104341: PUSH
104342: LD_VAR 0 4
104346: ARRAY
104347: PUSH
104348: FOR_IN
104349: IFFALSE 104375
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104351: LD_VAR 0 3
104355: PUSH
104356: LD_INT 1
104358: ARRAY
104359: PPUSH
104360: LD_VAR 0 3
104364: PUSH
104365: LD_INT 2
104367: ARRAY
104368: PPUSH
104369: CALL_OW 235
104373: GO 104348
104375: POP
104376: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104377: LD_ADDR_EXP 169
104381: PUSH
104382: LD_EXP 169
104386: PPUSH
104387: LD_VAR 0 4
104391: PPUSH
104392: EMPTY
104393: PPUSH
104394: CALL_OW 1
104398: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104399: LD_VAR 0 1
104403: PPUSH
104404: LD_INT 0
104406: PPUSH
104407: CALL_OW 505
// end ; end ;
104411: LD_VAR 0 2
104415: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104416: LD_INT 0
104418: PPUSH
104419: PPUSH
104420: PPUSH
// if not hack in hackTanks or not vehicles then
104421: LD_VAR 0 1
104425: PUSH
104426: LD_EXP 168
104430: IN
104431: NOT
104432: PUSH
104433: LD_VAR 0 2
104437: NOT
104438: OR
104439: IFFALSE 104443
// exit ;
104441: GO 104718
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104443: LD_ADDR_VAR 0 2
104447: PUSH
104448: LD_VAR 0 1
104452: PPUSH
104453: LD_VAR 0 2
104457: PPUSH
104458: LD_INT 1
104460: PPUSH
104461: LD_INT 1
104463: PPUSH
104464: CALL 20505 0 4
104468: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104469: LD_ADDR_VAR 0 5
104473: PUSH
104474: LD_EXP 168
104478: PPUSH
104479: LD_VAR 0 1
104483: PPUSH
104484: CALL 19855 0 2
104488: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104489: LD_EXP 169
104493: PUSH
104494: LD_VAR 0 5
104498: ARRAY
104499: PUSH
104500: LD_EXP 170
104504: LESS
104505: IFFALSE 104694
// begin for i := 1 to vehicles do
104507: LD_ADDR_VAR 0 4
104511: PUSH
104512: DOUBLE
104513: LD_INT 1
104515: DEC
104516: ST_TO_ADDR
104517: LD_VAR 0 2
104521: PUSH
104522: FOR_TO
104523: IFFALSE 104692
// begin if hackTanksCaptured [ index ] = hackLimit then
104525: LD_EXP 169
104529: PUSH
104530: LD_VAR 0 5
104534: ARRAY
104535: PUSH
104536: LD_EXP 170
104540: EQUAL
104541: IFFALSE 104545
// break ;
104543: GO 104692
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104545: LD_ADDR_EXP 172
104549: PUSH
104550: LD_EXP 172
104554: PPUSH
104555: LD_VAR 0 5
104559: PPUSH
104560: LD_EXP 172
104564: PUSH
104565: LD_VAR 0 5
104569: ARRAY
104570: PUSH
104571: LD_INT 1
104573: PLUS
104574: PPUSH
104575: CALL_OW 1
104579: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104580: LD_ADDR_EXP 169
104584: PUSH
104585: LD_EXP 169
104589: PPUSH
104590: LD_VAR 0 5
104594: PUSH
104595: LD_EXP 169
104599: PUSH
104600: LD_VAR 0 5
104604: ARRAY
104605: PUSH
104606: LD_INT 1
104608: PLUS
104609: PUSH
104610: EMPTY
104611: LIST
104612: LIST
104613: PPUSH
104614: LD_VAR 0 2
104618: PUSH
104619: LD_VAR 0 4
104623: ARRAY
104624: PUSH
104625: LD_VAR 0 2
104629: PUSH
104630: LD_VAR 0 4
104634: ARRAY
104635: PPUSH
104636: CALL_OW 255
104640: PUSH
104641: EMPTY
104642: LIST
104643: LIST
104644: PPUSH
104645: CALL 20070 0 3
104649: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104650: LD_VAR 0 2
104654: PUSH
104655: LD_VAR 0 4
104659: ARRAY
104660: PPUSH
104661: LD_VAR 0 1
104665: PPUSH
104666: CALL_OW 255
104670: PPUSH
104671: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104675: LD_VAR 0 2
104679: PUSH
104680: LD_VAR 0 4
104684: ARRAY
104685: PPUSH
104686: CALL_OW 141
// end ;
104690: GO 104522
104692: POP
104693: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104694: LD_VAR 0 1
104698: PPUSH
104699: LD_EXP 169
104703: PUSH
104704: LD_VAR 0 5
104708: ARRAY
104709: PUSH
104710: LD_INT 0
104712: PLUS
104713: PPUSH
104714: CALL_OW 505
// end ;
104718: LD_VAR 0 3
104722: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104723: LD_INT 0
104725: PPUSH
104726: PPUSH
104727: PPUSH
104728: PPUSH
// if not hack in hackTanks then
104729: LD_VAR 0 1
104733: PUSH
104734: LD_EXP 168
104738: IN
104739: NOT
104740: IFFALSE 104744
// exit ;
104742: GO 104984
// index := GetElementIndex ( hackTanks , hack ) ;
104744: LD_ADDR_VAR 0 4
104748: PUSH
104749: LD_EXP 168
104753: PPUSH
104754: LD_VAR 0 1
104758: PPUSH
104759: CALL 19855 0 2
104763: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104764: LD_ADDR_VAR 0 3
104768: PUSH
104769: DOUBLE
104770: LD_EXP 169
104774: PUSH
104775: LD_VAR 0 4
104779: ARRAY
104780: INC
104781: ST_TO_ADDR
104782: LD_INT 1
104784: PUSH
104785: FOR_DOWNTO
104786: IFFALSE 104958
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104788: LD_ADDR_VAR 0 5
104792: PUSH
104793: LD_EXP 169
104797: PUSH
104798: LD_VAR 0 4
104802: ARRAY
104803: PUSH
104804: LD_VAR 0 3
104808: ARRAY
104809: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104810: LD_VAR 0 5
104814: PUSH
104815: LD_INT 1
104817: ARRAY
104818: PPUSH
104819: CALL_OW 302
104823: NOT
104824: PUSH
104825: LD_VAR 0 5
104829: PUSH
104830: LD_INT 1
104832: ARRAY
104833: PPUSH
104834: CALL_OW 255
104838: PUSH
104839: LD_VAR 0 1
104843: PPUSH
104844: CALL_OW 255
104848: NONEQUAL
104849: OR
104850: IFFALSE 104956
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104852: LD_VAR 0 5
104856: PUSH
104857: LD_INT 1
104859: ARRAY
104860: PPUSH
104861: CALL_OW 305
104865: PUSH
104866: LD_VAR 0 5
104870: PUSH
104871: LD_INT 1
104873: ARRAY
104874: PPUSH
104875: CALL_OW 255
104879: PUSH
104880: LD_VAR 0 1
104884: PPUSH
104885: CALL_OW 255
104889: EQUAL
104890: AND
104891: IFFALSE 104915
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104893: LD_VAR 0 5
104897: PUSH
104898: LD_INT 1
104900: ARRAY
104901: PPUSH
104902: LD_VAR 0 5
104906: PUSH
104907: LD_INT 2
104909: ARRAY
104910: PPUSH
104911: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104915: LD_ADDR_EXP 169
104919: PUSH
104920: LD_EXP 169
104924: PPUSH
104925: LD_VAR 0 4
104929: PPUSH
104930: LD_EXP 169
104934: PUSH
104935: LD_VAR 0 4
104939: ARRAY
104940: PPUSH
104941: LD_VAR 0 3
104945: PPUSH
104946: CALL_OW 3
104950: PPUSH
104951: CALL_OW 1
104955: ST_TO_ADDR
// end ; end ;
104956: GO 104785
104958: POP
104959: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104960: LD_VAR 0 1
104964: PPUSH
104965: LD_EXP 169
104969: PUSH
104970: LD_VAR 0 4
104974: ARRAY
104975: PUSH
104976: LD_INT 0
104978: PLUS
104979: PPUSH
104980: CALL_OW 505
// end ;
104984: LD_VAR 0 2
104988: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104989: LD_INT 0
104991: PPUSH
104992: PPUSH
104993: PPUSH
104994: PPUSH
// if not hack in hackTanks then
104995: LD_VAR 0 1
104999: PUSH
105000: LD_EXP 168
105004: IN
105005: NOT
105006: IFFALSE 105010
// exit ;
105008: GO 105095
// index := GetElementIndex ( hackTanks , hack ) ;
105010: LD_ADDR_VAR 0 5
105014: PUSH
105015: LD_EXP 168
105019: PPUSH
105020: LD_VAR 0 1
105024: PPUSH
105025: CALL 19855 0 2
105029: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105030: LD_ADDR_VAR 0 4
105034: PUSH
105035: DOUBLE
105036: LD_INT 1
105038: DEC
105039: ST_TO_ADDR
105040: LD_EXP 169
105044: PUSH
105045: LD_VAR 0 5
105049: ARRAY
105050: PUSH
105051: FOR_TO
105052: IFFALSE 105093
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105054: LD_EXP 169
105058: PUSH
105059: LD_VAR 0 5
105063: ARRAY
105064: PUSH
105065: LD_VAR 0 4
105069: ARRAY
105070: PUSH
105071: LD_INT 1
105073: ARRAY
105074: PUSH
105075: LD_VAR 0 2
105079: EQUAL
105080: IFFALSE 105091
// KillUnit ( vehicle ) ;
105082: LD_VAR 0 2
105086: PPUSH
105087: CALL_OW 66
105091: GO 105051
105093: POP
105094: POP
// end ;
105095: LD_VAR 0 3
105099: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105100: LD_EXP 173
105104: NOT
105105: IFFALSE 105140
105107: GO 105109
105109: DISABLE
// begin initMiner := true ;
105110: LD_ADDR_EXP 173
105114: PUSH
105115: LD_INT 1
105117: ST_TO_ADDR
// minersList := [ ] ;
105118: LD_ADDR_EXP 174
105122: PUSH
105123: EMPTY
105124: ST_TO_ADDR
// minerMinesList := [ ] ;
105125: LD_ADDR_EXP 175
105129: PUSH
105130: EMPTY
105131: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105132: LD_ADDR_EXP 176
105136: PUSH
105137: LD_INT 5
105139: ST_TO_ADDR
// end ;
105140: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105141: LD_EXP 173
105145: PUSH
105146: LD_INT 34
105148: PUSH
105149: LD_INT 81
105151: PUSH
105152: EMPTY
105153: LIST
105154: LIST
105155: PPUSH
105156: CALL_OW 69
105160: AND
105161: IFFALSE 105622
105163: GO 105165
105165: DISABLE
105166: LD_INT 0
105168: PPUSH
105169: PPUSH
105170: PPUSH
105171: PPUSH
// begin enable ;
105172: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105173: LD_ADDR_VAR 0 1
105177: PUSH
105178: LD_INT 34
105180: PUSH
105181: LD_INT 81
105183: PUSH
105184: EMPTY
105185: LIST
105186: LIST
105187: PPUSH
105188: CALL_OW 69
105192: PUSH
105193: FOR_IN
105194: IFFALSE 105266
// begin if not i in minersList then
105196: LD_VAR 0 1
105200: PUSH
105201: LD_EXP 174
105205: IN
105206: NOT
105207: IFFALSE 105264
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105209: LD_ADDR_EXP 174
105213: PUSH
105214: LD_EXP 174
105218: PPUSH
105219: LD_EXP 174
105223: PUSH
105224: LD_INT 1
105226: PLUS
105227: PPUSH
105228: LD_VAR 0 1
105232: PPUSH
105233: CALL_OW 1
105237: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105238: LD_ADDR_EXP 175
105242: PUSH
105243: LD_EXP 175
105247: PPUSH
105248: LD_EXP 175
105252: PUSH
105253: LD_INT 1
105255: PLUS
105256: PPUSH
105257: EMPTY
105258: PPUSH
105259: CALL_OW 1
105263: ST_TO_ADDR
// end end ;
105264: GO 105193
105266: POP
105267: POP
// for i := minerMinesList downto 1 do
105268: LD_ADDR_VAR 0 1
105272: PUSH
105273: DOUBLE
105274: LD_EXP 175
105278: INC
105279: ST_TO_ADDR
105280: LD_INT 1
105282: PUSH
105283: FOR_DOWNTO
105284: IFFALSE 105620
// begin if IsLive ( minersList [ i ] ) then
105286: LD_EXP 174
105290: PUSH
105291: LD_VAR 0 1
105295: ARRAY
105296: PPUSH
105297: CALL_OW 300
105301: IFFALSE 105329
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105303: LD_EXP 174
105307: PUSH
105308: LD_VAR 0 1
105312: ARRAY
105313: PPUSH
105314: LD_EXP 175
105318: PUSH
105319: LD_VAR 0 1
105323: ARRAY
105324: PPUSH
105325: CALL_OW 505
// if not minerMinesList [ i ] then
105329: LD_EXP 175
105333: PUSH
105334: LD_VAR 0 1
105338: ARRAY
105339: NOT
105340: IFFALSE 105344
// continue ;
105342: GO 105283
// for j := minerMinesList [ i ] downto 1 do
105344: LD_ADDR_VAR 0 2
105348: PUSH
105349: DOUBLE
105350: LD_EXP 175
105354: PUSH
105355: LD_VAR 0 1
105359: ARRAY
105360: INC
105361: ST_TO_ADDR
105362: LD_INT 1
105364: PUSH
105365: FOR_DOWNTO
105366: IFFALSE 105616
// begin side := GetSide ( minersList [ i ] ) ;
105368: LD_ADDR_VAR 0 3
105372: PUSH
105373: LD_EXP 174
105377: PUSH
105378: LD_VAR 0 1
105382: ARRAY
105383: PPUSH
105384: CALL_OW 255
105388: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105389: LD_ADDR_VAR 0 4
105393: PUSH
105394: LD_EXP 175
105398: PUSH
105399: LD_VAR 0 1
105403: ARRAY
105404: PUSH
105405: LD_VAR 0 2
105409: ARRAY
105410: PUSH
105411: LD_INT 1
105413: ARRAY
105414: PPUSH
105415: LD_EXP 175
105419: PUSH
105420: LD_VAR 0 1
105424: ARRAY
105425: PUSH
105426: LD_VAR 0 2
105430: ARRAY
105431: PUSH
105432: LD_INT 2
105434: ARRAY
105435: PPUSH
105436: CALL_OW 428
105440: ST_TO_ADDR
// if not tmp then
105441: LD_VAR 0 4
105445: NOT
105446: IFFALSE 105450
// continue ;
105448: GO 105365
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105450: LD_VAR 0 4
105454: PUSH
105455: LD_INT 81
105457: PUSH
105458: LD_VAR 0 3
105462: PUSH
105463: EMPTY
105464: LIST
105465: LIST
105466: PPUSH
105467: CALL_OW 69
105471: IN
105472: PUSH
105473: LD_EXP 175
105477: PUSH
105478: LD_VAR 0 1
105482: ARRAY
105483: PUSH
105484: LD_VAR 0 2
105488: ARRAY
105489: PUSH
105490: LD_INT 1
105492: ARRAY
105493: PPUSH
105494: LD_EXP 175
105498: PUSH
105499: LD_VAR 0 1
105503: ARRAY
105504: PUSH
105505: LD_VAR 0 2
105509: ARRAY
105510: PUSH
105511: LD_INT 2
105513: ARRAY
105514: PPUSH
105515: CALL_OW 458
105519: AND
105520: IFFALSE 105614
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105522: LD_EXP 175
105526: PUSH
105527: LD_VAR 0 1
105531: ARRAY
105532: PUSH
105533: LD_VAR 0 2
105537: ARRAY
105538: PUSH
105539: LD_INT 1
105541: ARRAY
105542: PPUSH
105543: LD_EXP 175
105547: PUSH
105548: LD_VAR 0 1
105552: ARRAY
105553: PUSH
105554: LD_VAR 0 2
105558: ARRAY
105559: PUSH
105560: LD_INT 2
105562: ARRAY
105563: PPUSH
105564: LD_VAR 0 3
105568: PPUSH
105569: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105573: LD_ADDR_EXP 175
105577: PUSH
105578: LD_EXP 175
105582: PPUSH
105583: LD_VAR 0 1
105587: PPUSH
105588: LD_EXP 175
105592: PUSH
105593: LD_VAR 0 1
105597: ARRAY
105598: PPUSH
105599: LD_VAR 0 2
105603: PPUSH
105604: CALL_OW 3
105608: PPUSH
105609: CALL_OW 1
105613: ST_TO_ADDR
// end ; end ;
105614: GO 105365
105616: POP
105617: POP
// end ;
105618: GO 105283
105620: POP
105621: POP
// end ;
105622: PPOPN 4
105624: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105625: LD_INT 0
105627: PPUSH
105628: PPUSH
// result := false ;
105629: LD_ADDR_VAR 0 4
105633: PUSH
105634: LD_INT 0
105636: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105637: LD_VAR 0 1
105641: PPUSH
105642: CALL_OW 264
105646: PUSH
105647: LD_INT 81
105649: EQUAL
105650: NOT
105651: IFFALSE 105655
// exit ;
105653: GO 105895
// index := GetElementIndex ( minersList , unit ) ;
105655: LD_ADDR_VAR 0 5
105659: PUSH
105660: LD_EXP 174
105664: PPUSH
105665: LD_VAR 0 1
105669: PPUSH
105670: CALL 19855 0 2
105674: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105675: LD_EXP 175
105679: PUSH
105680: LD_VAR 0 5
105684: ARRAY
105685: PUSH
105686: LD_EXP 176
105690: GREATEREQUAL
105691: IFFALSE 105695
// exit ;
105693: GO 105895
// ComMoveXY ( unit , x , y ) ;
105695: LD_VAR 0 1
105699: PPUSH
105700: LD_VAR 0 2
105704: PPUSH
105705: LD_VAR 0 3
105709: PPUSH
105710: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105714: LD_INT 35
105716: PPUSH
105717: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105721: LD_VAR 0 1
105725: PPUSH
105726: LD_VAR 0 2
105730: PPUSH
105731: LD_VAR 0 3
105735: PPUSH
105736: CALL 51210 0 3
105740: NOT
105741: PUSH
105742: LD_VAR 0 1
105746: PPUSH
105747: CALL_OW 314
105751: AND
105752: IFFALSE 105756
// exit ;
105754: GO 105895
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105756: LD_VAR 0 2
105760: PPUSH
105761: LD_VAR 0 3
105765: PPUSH
105766: CALL_OW 428
105770: PUSH
105771: LD_VAR 0 1
105775: EQUAL
105776: PUSH
105777: LD_VAR 0 1
105781: PPUSH
105782: CALL_OW 314
105786: NOT
105787: AND
105788: IFFALSE 105714
// PlaySoundXY ( x , y , PlantMine ) ;
105790: LD_VAR 0 2
105794: PPUSH
105795: LD_VAR 0 3
105799: PPUSH
105800: LD_STRING PlantMine
105802: PPUSH
105803: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105807: LD_VAR 0 2
105811: PPUSH
105812: LD_VAR 0 3
105816: PPUSH
105817: LD_VAR 0 1
105821: PPUSH
105822: CALL_OW 255
105826: PPUSH
105827: LD_INT 0
105829: PPUSH
105830: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105834: LD_ADDR_EXP 175
105838: PUSH
105839: LD_EXP 175
105843: PPUSH
105844: LD_VAR 0 5
105848: PUSH
105849: LD_EXP 175
105853: PUSH
105854: LD_VAR 0 5
105858: ARRAY
105859: PUSH
105860: LD_INT 1
105862: PLUS
105863: PUSH
105864: EMPTY
105865: LIST
105866: LIST
105867: PPUSH
105868: LD_VAR 0 2
105872: PUSH
105873: LD_VAR 0 3
105877: PUSH
105878: EMPTY
105879: LIST
105880: LIST
105881: PPUSH
105882: CALL 20070 0 3
105886: ST_TO_ADDR
// result := true ;
105887: LD_ADDR_VAR 0 4
105891: PUSH
105892: LD_INT 1
105894: ST_TO_ADDR
// end ;
105895: LD_VAR 0 4
105899: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105900: LD_INT 0
105902: PPUSH
105903: PPUSH
105904: PPUSH
// if not unit in minersList then
105905: LD_VAR 0 1
105909: PUSH
105910: LD_EXP 174
105914: IN
105915: NOT
105916: IFFALSE 105920
// exit ;
105918: GO 106312
// index := GetElementIndex ( minersList , unit ) ;
105920: LD_ADDR_VAR 0 6
105924: PUSH
105925: LD_EXP 174
105929: PPUSH
105930: LD_VAR 0 1
105934: PPUSH
105935: CALL 19855 0 2
105939: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105940: LD_ADDR_VAR 0 5
105944: PUSH
105945: DOUBLE
105946: LD_EXP 175
105950: PUSH
105951: LD_VAR 0 6
105955: ARRAY
105956: INC
105957: ST_TO_ADDR
105958: LD_INT 1
105960: PUSH
105961: FOR_DOWNTO
105962: IFFALSE 106123
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105964: LD_EXP 175
105968: PUSH
105969: LD_VAR 0 6
105973: ARRAY
105974: PUSH
105975: LD_VAR 0 5
105979: ARRAY
105980: PUSH
105981: LD_INT 1
105983: ARRAY
105984: PUSH
105985: LD_VAR 0 2
105989: EQUAL
105990: PUSH
105991: LD_EXP 175
105995: PUSH
105996: LD_VAR 0 6
106000: ARRAY
106001: PUSH
106002: LD_VAR 0 5
106006: ARRAY
106007: PUSH
106008: LD_INT 2
106010: ARRAY
106011: PUSH
106012: LD_VAR 0 3
106016: EQUAL
106017: AND
106018: IFFALSE 106121
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106020: LD_EXP 175
106024: PUSH
106025: LD_VAR 0 6
106029: ARRAY
106030: PUSH
106031: LD_VAR 0 5
106035: ARRAY
106036: PUSH
106037: LD_INT 1
106039: ARRAY
106040: PPUSH
106041: LD_EXP 175
106045: PUSH
106046: LD_VAR 0 6
106050: ARRAY
106051: PUSH
106052: LD_VAR 0 5
106056: ARRAY
106057: PUSH
106058: LD_INT 2
106060: ARRAY
106061: PPUSH
106062: LD_VAR 0 1
106066: PPUSH
106067: CALL_OW 255
106071: PPUSH
106072: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106076: LD_ADDR_EXP 175
106080: PUSH
106081: LD_EXP 175
106085: PPUSH
106086: LD_VAR 0 6
106090: PPUSH
106091: LD_EXP 175
106095: PUSH
106096: LD_VAR 0 6
106100: ARRAY
106101: PPUSH
106102: LD_VAR 0 5
106106: PPUSH
106107: CALL_OW 3
106111: PPUSH
106112: CALL_OW 1
106116: ST_TO_ADDR
// exit ;
106117: POP
106118: POP
106119: GO 106312
// end ; end ;
106121: GO 105961
106123: POP
106124: POP
// for i := minerMinesList [ index ] downto 1 do
106125: LD_ADDR_VAR 0 5
106129: PUSH
106130: DOUBLE
106131: LD_EXP 175
106135: PUSH
106136: LD_VAR 0 6
106140: ARRAY
106141: INC
106142: ST_TO_ADDR
106143: LD_INT 1
106145: PUSH
106146: FOR_DOWNTO
106147: IFFALSE 106310
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106149: LD_EXP 175
106153: PUSH
106154: LD_VAR 0 6
106158: ARRAY
106159: PUSH
106160: LD_VAR 0 5
106164: ARRAY
106165: PUSH
106166: LD_INT 1
106168: ARRAY
106169: PPUSH
106170: LD_EXP 175
106174: PUSH
106175: LD_VAR 0 6
106179: ARRAY
106180: PUSH
106181: LD_VAR 0 5
106185: ARRAY
106186: PUSH
106187: LD_INT 2
106189: ARRAY
106190: PPUSH
106191: LD_VAR 0 2
106195: PPUSH
106196: LD_VAR 0 3
106200: PPUSH
106201: CALL_OW 298
106205: PUSH
106206: LD_INT 6
106208: LESS
106209: IFFALSE 106308
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106211: LD_EXP 175
106215: PUSH
106216: LD_VAR 0 6
106220: ARRAY
106221: PUSH
106222: LD_VAR 0 5
106226: ARRAY
106227: PUSH
106228: LD_INT 1
106230: ARRAY
106231: PPUSH
106232: LD_EXP 175
106236: PUSH
106237: LD_VAR 0 6
106241: ARRAY
106242: PUSH
106243: LD_VAR 0 5
106247: ARRAY
106248: PUSH
106249: LD_INT 2
106251: ARRAY
106252: PPUSH
106253: LD_VAR 0 1
106257: PPUSH
106258: CALL_OW 255
106262: PPUSH
106263: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106267: LD_ADDR_EXP 175
106271: PUSH
106272: LD_EXP 175
106276: PPUSH
106277: LD_VAR 0 6
106281: PPUSH
106282: LD_EXP 175
106286: PUSH
106287: LD_VAR 0 6
106291: ARRAY
106292: PPUSH
106293: LD_VAR 0 5
106297: PPUSH
106298: CALL_OW 3
106302: PPUSH
106303: CALL_OW 1
106307: ST_TO_ADDR
// end ; end ;
106308: GO 106146
106310: POP
106311: POP
// end ;
106312: LD_VAR 0 4
106316: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106317: LD_INT 0
106319: PPUSH
106320: PPUSH
106321: PPUSH
106322: PPUSH
106323: PPUSH
106324: PPUSH
106325: PPUSH
106326: PPUSH
106327: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106328: LD_VAR 0 1
106332: PPUSH
106333: CALL_OW 264
106337: PUSH
106338: LD_INT 81
106340: EQUAL
106341: NOT
106342: PUSH
106343: LD_VAR 0 1
106347: PUSH
106348: LD_EXP 174
106352: IN
106353: NOT
106354: OR
106355: IFFALSE 106359
// exit ;
106357: GO 106681
// index := GetElementIndex ( minersList , unit ) ;
106359: LD_ADDR_VAR 0 6
106363: PUSH
106364: LD_EXP 174
106368: PPUSH
106369: LD_VAR 0 1
106373: PPUSH
106374: CALL 19855 0 2
106378: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106379: LD_ADDR_VAR 0 8
106383: PUSH
106384: LD_EXP 176
106388: PUSH
106389: LD_EXP 175
106393: PUSH
106394: LD_VAR 0 6
106398: ARRAY
106399: MINUS
106400: ST_TO_ADDR
// if not minesFreeAmount then
106401: LD_VAR 0 8
106405: NOT
106406: IFFALSE 106410
// exit ;
106408: GO 106681
// tmp := [ ] ;
106410: LD_ADDR_VAR 0 7
106414: PUSH
106415: EMPTY
106416: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106417: LD_ADDR_VAR 0 5
106421: PUSH
106422: DOUBLE
106423: LD_INT 1
106425: DEC
106426: ST_TO_ADDR
106427: LD_VAR 0 8
106431: PUSH
106432: FOR_TO
106433: IFFALSE 106628
// begin _d := rand ( 0 , 5 ) ;
106435: LD_ADDR_VAR 0 11
106439: PUSH
106440: LD_INT 0
106442: PPUSH
106443: LD_INT 5
106445: PPUSH
106446: CALL_OW 12
106450: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106451: LD_ADDR_VAR 0 12
106455: PUSH
106456: LD_INT 2
106458: PPUSH
106459: LD_INT 6
106461: PPUSH
106462: CALL_OW 12
106466: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106467: LD_ADDR_VAR 0 9
106471: PUSH
106472: LD_VAR 0 2
106476: PPUSH
106477: LD_VAR 0 11
106481: PPUSH
106482: LD_VAR 0 12
106486: PPUSH
106487: CALL_OW 272
106491: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106492: LD_ADDR_VAR 0 10
106496: PUSH
106497: LD_VAR 0 3
106501: PPUSH
106502: LD_VAR 0 11
106506: PPUSH
106507: LD_VAR 0 12
106511: PPUSH
106512: CALL_OW 273
106516: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106517: LD_VAR 0 9
106521: PPUSH
106522: LD_VAR 0 10
106526: PPUSH
106527: CALL_OW 488
106531: PUSH
106532: LD_VAR 0 9
106536: PUSH
106537: LD_VAR 0 10
106541: PUSH
106542: EMPTY
106543: LIST
106544: LIST
106545: PUSH
106546: LD_VAR 0 7
106550: IN
106551: NOT
106552: AND
106553: PUSH
106554: LD_VAR 0 9
106558: PPUSH
106559: LD_VAR 0 10
106563: PPUSH
106564: CALL_OW 458
106568: NOT
106569: AND
106570: IFFALSE 106612
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106572: LD_ADDR_VAR 0 7
106576: PUSH
106577: LD_VAR 0 7
106581: PPUSH
106582: LD_VAR 0 7
106586: PUSH
106587: LD_INT 1
106589: PLUS
106590: PPUSH
106591: LD_VAR 0 9
106595: PUSH
106596: LD_VAR 0 10
106600: PUSH
106601: EMPTY
106602: LIST
106603: LIST
106604: PPUSH
106605: CALL_OW 1
106609: ST_TO_ADDR
106610: GO 106626
// i := i - 1 ;
106612: LD_ADDR_VAR 0 5
106616: PUSH
106617: LD_VAR 0 5
106621: PUSH
106622: LD_INT 1
106624: MINUS
106625: ST_TO_ADDR
// end ;
106626: GO 106432
106628: POP
106629: POP
// for i in tmp do
106630: LD_ADDR_VAR 0 5
106634: PUSH
106635: LD_VAR 0 7
106639: PUSH
106640: FOR_IN
106641: IFFALSE 106679
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106643: LD_VAR 0 1
106647: PPUSH
106648: LD_VAR 0 5
106652: PUSH
106653: LD_INT 1
106655: ARRAY
106656: PPUSH
106657: LD_VAR 0 5
106661: PUSH
106662: LD_INT 2
106664: ARRAY
106665: PPUSH
106666: CALL 105625 0 3
106670: NOT
106671: IFFALSE 106677
// exit ;
106673: POP
106674: POP
106675: GO 106681
106677: GO 106640
106679: POP
106680: POP
// end ;
106681: LD_VAR 0 4
106685: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106686: LD_INT 0
106688: PPUSH
106689: PPUSH
106690: PPUSH
106691: PPUSH
106692: PPUSH
106693: PPUSH
106694: PPUSH
// if not GetClass ( unit ) = class_sniper then
106695: LD_VAR 0 1
106699: PPUSH
106700: CALL_OW 257
106704: PUSH
106705: LD_INT 5
106707: EQUAL
106708: NOT
106709: IFFALSE 106713
// exit ;
106711: GO 107101
// dist := 8 ;
106713: LD_ADDR_VAR 0 5
106717: PUSH
106718: LD_INT 8
106720: ST_TO_ADDR
// viewRange := 12 ;
106721: LD_ADDR_VAR 0 7
106725: PUSH
106726: LD_INT 12
106728: ST_TO_ADDR
// side := GetSide ( unit ) ;
106729: LD_ADDR_VAR 0 6
106733: PUSH
106734: LD_VAR 0 1
106738: PPUSH
106739: CALL_OW 255
106743: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106744: LD_INT 61
106746: PPUSH
106747: LD_VAR 0 6
106751: PPUSH
106752: CALL_OW 321
106756: PUSH
106757: LD_INT 2
106759: EQUAL
106760: IFFALSE 106770
// viewRange := 16 ;
106762: LD_ADDR_VAR 0 7
106766: PUSH
106767: LD_INT 16
106769: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106770: LD_VAR 0 1
106774: PPUSH
106775: LD_VAR 0 2
106779: PPUSH
106780: LD_VAR 0 3
106784: PPUSH
106785: CALL_OW 297
106789: PUSH
106790: LD_VAR 0 5
106794: GREATER
106795: IFFALSE 106874
// begin ComMoveXY ( unit , x , y ) ;
106797: LD_VAR 0 1
106801: PPUSH
106802: LD_VAR 0 2
106806: PPUSH
106807: LD_VAR 0 3
106811: PPUSH
106812: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106816: LD_INT 35
106818: PPUSH
106819: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106823: LD_VAR 0 1
106827: PPUSH
106828: LD_VAR 0 2
106832: PPUSH
106833: LD_VAR 0 3
106837: PPUSH
106838: CALL 51210 0 3
106842: NOT
106843: IFFALSE 106847
// exit ;
106845: GO 107101
// until GetDistUnitXY ( unit , x , y ) < dist ;
106847: LD_VAR 0 1
106851: PPUSH
106852: LD_VAR 0 2
106856: PPUSH
106857: LD_VAR 0 3
106861: PPUSH
106862: CALL_OW 297
106866: PUSH
106867: LD_VAR 0 5
106871: LESS
106872: IFFALSE 106816
// end ; ComTurnXY ( unit , x , y ) ;
106874: LD_VAR 0 1
106878: PPUSH
106879: LD_VAR 0 2
106883: PPUSH
106884: LD_VAR 0 3
106888: PPUSH
106889: CALL_OW 118
// wait ( 5 ) ;
106893: LD_INT 5
106895: PPUSH
106896: CALL_OW 67
// _d := GetDir ( unit ) ;
106900: LD_ADDR_VAR 0 10
106904: PUSH
106905: LD_VAR 0 1
106909: PPUSH
106910: CALL_OW 254
106914: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106915: LD_ADDR_VAR 0 8
106919: PUSH
106920: LD_VAR 0 1
106924: PPUSH
106925: CALL_OW 250
106929: PPUSH
106930: LD_VAR 0 10
106934: PPUSH
106935: LD_VAR 0 5
106939: PPUSH
106940: CALL_OW 272
106944: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106945: LD_ADDR_VAR 0 9
106949: PUSH
106950: LD_VAR 0 1
106954: PPUSH
106955: CALL_OW 251
106959: PPUSH
106960: LD_VAR 0 10
106964: PPUSH
106965: LD_VAR 0 5
106969: PPUSH
106970: CALL_OW 273
106974: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106975: LD_VAR 0 8
106979: PPUSH
106980: LD_VAR 0 9
106984: PPUSH
106985: CALL_OW 488
106989: NOT
106990: IFFALSE 106994
// exit ;
106992: GO 107101
// ComAnimCustom ( unit , 1 ) ;
106994: LD_VAR 0 1
106998: PPUSH
106999: LD_INT 1
107001: PPUSH
107002: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107006: LD_VAR 0 8
107010: PPUSH
107011: LD_VAR 0 9
107015: PPUSH
107016: LD_VAR 0 6
107020: PPUSH
107021: LD_VAR 0 7
107025: PPUSH
107026: CALL_OW 330
// repeat wait ( 1 ) ;
107030: LD_INT 1
107032: PPUSH
107033: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107037: LD_VAR 0 1
107041: PPUSH
107042: CALL_OW 316
107046: PUSH
107047: LD_VAR 0 1
107051: PPUSH
107052: CALL_OW 314
107056: OR
107057: PUSH
107058: LD_VAR 0 1
107062: PPUSH
107063: CALL_OW 302
107067: NOT
107068: OR
107069: PUSH
107070: LD_VAR 0 1
107074: PPUSH
107075: CALL_OW 301
107079: OR
107080: IFFALSE 107030
// RemoveSeeing ( _x , _y , side ) ;
107082: LD_VAR 0 8
107086: PPUSH
107087: LD_VAR 0 9
107091: PPUSH
107092: LD_VAR 0 6
107096: PPUSH
107097: CALL_OW 331
// end ; end_of_file
107101: LD_VAR 0 4
107105: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107106: LD_INT 0
107108: PPUSH
107109: PPUSH
107110: PPUSH
107111: PPUSH
107112: PPUSH
107113: PPUSH
107114: PPUSH
107115: PPUSH
107116: PPUSH
107117: PPUSH
107118: PPUSH
107119: PPUSH
107120: PPUSH
107121: PPUSH
107122: PPUSH
107123: PPUSH
107124: PPUSH
107125: PPUSH
107126: PPUSH
107127: PPUSH
107128: PPUSH
107129: PPUSH
107130: PPUSH
107131: PPUSH
107132: PPUSH
107133: PPUSH
107134: PPUSH
107135: PPUSH
107136: PPUSH
107137: PPUSH
107138: PPUSH
107139: PPUSH
107140: PPUSH
107141: PPUSH
// if not list then
107142: LD_VAR 0 1
107146: NOT
107147: IFFALSE 107151
// exit ;
107149: GO 111810
// base := list [ 1 ] ;
107151: LD_ADDR_VAR 0 3
107155: PUSH
107156: LD_VAR 0 1
107160: PUSH
107161: LD_INT 1
107163: ARRAY
107164: ST_TO_ADDR
// group := list [ 2 ] ;
107165: LD_ADDR_VAR 0 4
107169: PUSH
107170: LD_VAR 0 1
107174: PUSH
107175: LD_INT 2
107177: ARRAY
107178: ST_TO_ADDR
// path := list [ 3 ] ;
107179: LD_ADDR_VAR 0 5
107183: PUSH
107184: LD_VAR 0 1
107188: PUSH
107189: LD_INT 3
107191: ARRAY
107192: ST_TO_ADDR
// flags := list [ 4 ] ;
107193: LD_ADDR_VAR 0 6
107197: PUSH
107198: LD_VAR 0 1
107202: PUSH
107203: LD_INT 4
107205: ARRAY
107206: ST_TO_ADDR
// mined := [ ] ;
107207: LD_ADDR_VAR 0 27
107211: PUSH
107212: EMPTY
107213: ST_TO_ADDR
// bombed := [ ] ;
107214: LD_ADDR_VAR 0 28
107218: PUSH
107219: EMPTY
107220: ST_TO_ADDR
// healers := [ ] ;
107221: LD_ADDR_VAR 0 31
107225: PUSH
107226: EMPTY
107227: ST_TO_ADDR
// to_heal := [ ] ;
107228: LD_ADDR_VAR 0 30
107232: PUSH
107233: EMPTY
107234: ST_TO_ADDR
// repairs := [ ] ;
107235: LD_ADDR_VAR 0 33
107239: PUSH
107240: EMPTY
107241: ST_TO_ADDR
// to_repair := [ ] ;
107242: LD_ADDR_VAR 0 32
107246: PUSH
107247: EMPTY
107248: ST_TO_ADDR
// if not group or not path then
107249: LD_VAR 0 4
107253: NOT
107254: PUSH
107255: LD_VAR 0 5
107259: NOT
107260: OR
107261: IFFALSE 107265
// exit ;
107263: GO 111810
// side := GetSide ( group [ 1 ] ) ;
107265: LD_ADDR_VAR 0 35
107269: PUSH
107270: LD_VAR 0 4
107274: PUSH
107275: LD_INT 1
107277: ARRAY
107278: PPUSH
107279: CALL_OW 255
107283: ST_TO_ADDR
// if flags then
107284: LD_VAR 0 6
107288: IFFALSE 107432
// begin f_ignore_area := flags [ 1 ] ;
107290: LD_ADDR_VAR 0 17
107294: PUSH
107295: LD_VAR 0 6
107299: PUSH
107300: LD_INT 1
107302: ARRAY
107303: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107304: LD_ADDR_VAR 0 18
107308: PUSH
107309: LD_VAR 0 6
107313: PUSH
107314: LD_INT 2
107316: ARRAY
107317: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107318: LD_ADDR_VAR 0 19
107322: PUSH
107323: LD_VAR 0 6
107327: PUSH
107328: LD_INT 3
107330: ARRAY
107331: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107332: LD_ADDR_VAR 0 20
107336: PUSH
107337: LD_VAR 0 6
107341: PUSH
107342: LD_INT 4
107344: ARRAY
107345: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107346: LD_ADDR_VAR 0 21
107350: PUSH
107351: LD_VAR 0 6
107355: PUSH
107356: LD_INT 5
107358: ARRAY
107359: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107360: LD_ADDR_VAR 0 22
107364: PUSH
107365: LD_VAR 0 6
107369: PUSH
107370: LD_INT 6
107372: ARRAY
107373: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107374: LD_ADDR_VAR 0 23
107378: PUSH
107379: LD_VAR 0 6
107383: PUSH
107384: LD_INT 7
107386: ARRAY
107387: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107388: LD_ADDR_VAR 0 24
107392: PUSH
107393: LD_VAR 0 6
107397: PUSH
107398: LD_INT 8
107400: ARRAY
107401: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107402: LD_ADDR_VAR 0 25
107406: PUSH
107407: LD_VAR 0 6
107411: PUSH
107412: LD_INT 9
107414: ARRAY
107415: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107416: LD_ADDR_VAR 0 26
107420: PUSH
107421: LD_VAR 0 6
107425: PUSH
107426: LD_INT 10
107428: ARRAY
107429: ST_TO_ADDR
// end else
107430: GO 107512
// begin f_ignore_area := false ;
107432: LD_ADDR_VAR 0 17
107436: PUSH
107437: LD_INT 0
107439: ST_TO_ADDR
// f_capture := false ;
107440: LD_ADDR_VAR 0 18
107444: PUSH
107445: LD_INT 0
107447: ST_TO_ADDR
// f_ignore_civ := false ;
107448: LD_ADDR_VAR 0 19
107452: PUSH
107453: LD_INT 0
107455: ST_TO_ADDR
// f_murder := false ;
107456: LD_ADDR_VAR 0 20
107460: PUSH
107461: LD_INT 0
107463: ST_TO_ADDR
// f_mines := false ;
107464: LD_ADDR_VAR 0 21
107468: PUSH
107469: LD_INT 0
107471: ST_TO_ADDR
// f_repair := false ;
107472: LD_ADDR_VAR 0 22
107476: PUSH
107477: LD_INT 0
107479: ST_TO_ADDR
// f_heal := false ;
107480: LD_ADDR_VAR 0 23
107484: PUSH
107485: LD_INT 0
107487: ST_TO_ADDR
// f_spacetime := false ;
107488: LD_ADDR_VAR 0 24
107492: PUSH
107493: LD_INT 0
107495: ST_TO_ADDR
// f_attack_depot := false ;
107496: LD_ADDR_VAR 0 25
107500: PUSH
107501: LD_INT 0
107503: ST_TO_ADDR
// f_crawl := false ;
107504: LD_ADDR_VAR 0 26
107508: PUSH
107509: LD_INT 0
107511: ST_TO_ADDR
// end ; if f_heal then
107512: LD_VAR 0 23
107516: IFFALSE 107543
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107518: LD_ADDR_VAR 0 31
107522: PUSH
107523: LD_VAR 0 4
107527: PPUSH
107528: LD_INT 25
107530: PUSH
107531: LD_INT 4
107533: PUSH
107534: EMPTY
107535: LIST
107536: LIST
107537: PPUSH
107538: CALL_OW 72
107542: ST_TO_ADDR
// if f_repair then
107543: LD_VAR 0 22
107547: IFFALSE 107574
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107549: LD_ADDR_VAR 0 33
107553: PUSH
107554: LD_VAR 0 4
107558: PPUSH
107559: LD_INT 25
107561: PUSH
107562: LD_INT 3
107564: PUSH
107565: EMPTY
107566: LIST
107567: LIST
107568: PPUSH
107569: CALL_OW 72
107573: ST_TO_ADDR
// units_path := [ ] ;
107574: LD_ADDR_VAR 0 16
107578: PUSH
107579: EMPTY
107580: ST_TO_ADDR
// for i = 1 to group do
107581: LD_ADDR_VAR 0 7
107585: PUSH
107586: DOUBLE
107587: LD_INT 1
107589: DEC
107590: ST_TO_ADDR
107591: LD_VAR 0 4
107595: PUSH
107596: FOR_TO
107597: IFFALSE 107626
// units_path := Replace ( units_path , i , path ) ;
107599: LD_ADDR_VAR 0 16
107603: PUSH
107604: LD_VAR 0 16
107608: PPUSH
107609: LD_VAR 0 7
107613: PPUSH
107614: LD_VAR 0 5
107618: PPUSH
107619: CALL_OW 1
107623: ST_TO_ADDR
107624: GO 107596
107626: POP
107627: POP
// repeat for i = group downto 1 do
107628: LD_ADDR_VAR 0 7
107632: PUSH
107633: DOUBLE
107634: LD_VAR 0 4
107638: INC
107639: ST_TO_ADDR
107640: LD_INT 1
107642: PUSH
107643: FOR_DOWNTO
107644: IFFALSE 111766
// begin wait ( 5 ) ;
107646: LD_INT 5
107648: PPUSH
107649: CALL_OW 67
// tmp := [ ] ;
107653: LD_ADDR_VAR 0 14
107657: PUSH
107658: EMPTY
107659: ST_TO_ADDR
// attacking := false ;
107660: LD_ADDR_VAR 0 29
107664: PUSH
107665: LD_INT 0
107667: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107668: LD_VAR 0 4
107672: PUSH
107673: LD_VAR 0 7
107677: ARRAY
107678: PPUSH
107679: CALL_OW 301
107683: PUSH
107684: LD_VAR 0 4
107688: PUSH
107689: LD_VAR 0 7
107693: ARRAY
107694: NOT
107695: OR
107696: IFFALSE 107805
// begin if GetType ( group [ i ] ) = unit_human then
107698: LD_VAR 0 4
107702: PUSH
107703: LD_VAR 0 7
107707: ARRAY
107708: PPUSH
107709: CALL_OW 247
107713: PUSH
107714: LD_INT 1
107716: EQUAL
107717: IFFALSE 107763
// begin to_heal := to_heal diff group [ i ] ;
107719: LD_ADDR_VAR 0 30
107723: PUSH
107724: LD_VAR 0 30
107728: PUSH
107729: LD_VAR 0 4
107733: PUSH
107734: LD_VAR 0 7
107738: ARRAY
107739: DIFF
107740: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107741: LD_ADDR_VAR 0 31
107745: PUSH
107746: LD_VAR 0 31
107750: PUSH
107751: LD_VAR 0 4
107755: PUSH
107756: LD_VAR 0 7
107760: ARRAY
107761: DIFF
107762: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107763: LD_ADDR_VAR 0 4
107767: PUSH
107768: LD_VAR 0 4
107772: PPUSH
107773: LD_VAR 0 7
107777: PPUSH
107778: CALL_OW 3
107782: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107783: LD_ADDR_VAR 0 16
107787: PUSH
107788: LD_VAR 0 16
107792: PPUSH
107793: LD_VAR 0 7
107797: PPUSH
107798: CALL_OW 3
107802: ST_TO_ADDR
// continue ;
107803: GO 107643
// end ; if f_repair then
107805: LD_VAR 0 22
107809: IFFALSE 108298
// begin if GetType ( group [ i ] ) = unit_vehicle then
107811: LD_VAR 0 4
107815: PUSH
107816: LD_VAR 0 7
107820: ARRAY
107821: PPUSH
107822: CALL_OW 247
107826: PUSH
107827: LD_INT 2
107829: EQUAL
107830: IFFALSE 108020
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107832: LD_VAR 0 4
107836: PUSH
107837: LD_VAR 0 7
107841: ARRAY
107842: PPUSH
107843: CALL_OW 256
107847: PUSH
107848: LD_INT 700
107850: LESS
107851: PUSH
107852: LD_VAR 0 4
107856: PUSH
107857: LD_VAR 0 7
107861: ARRAY
107862: PUSH
107863: LD_VAR 0 32
107867: IN
107868: NOT
107869: AND
107870: IFFALSE 107894
// to_repair := to_repair union group [ i ] ;
107872: LD_ADDR_VAR 0 32
107876: PUSH
107877: LD_VAR 0 32
107881: PUSH
107882: LD_VAR 0 4
107886: PUSH
107887: LD_VAR 0 7
107891: ARRAY
107892: UNION
107893: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107894: LD_VAR 0 4
107898: PUSH
107899: LD_VAR 0 7
107903: ARRAY
107904: PPUSH
107905: CALL_OW 256
107909: PUSH
107910: LD_INT 1000
107912: EQUAL
107913: PUSH
107914: LD_VAR 0 4
107918: PUSH
107919: LD_VAR 0 7
107923: ARRAY
107924: PUSH
107925: LD_VAR 0 32
107929: IN
107930: AND
107931: IFFALSE 107955
// to_repair := to_repair diff group [ i ] ;
107933: LD_ADDR_VAR 0 32
107937: PUSH
107938: LD_VAR 0 32
107942: PUSH
107943: LD_VAR 0 4
107947: PUSH
107948: LD_VAR 0 7
107952: ARRAY
107953: DIFF
107954: ST_TO_ADDR
// if group [ i ] in to_repair then
107955: LD_VAR 0 4
107959: PUSH
107960: LD_VAR 0 7
107964: ARRAY
107965: PUSH
107966: LD_VAR 0 32
107970: IN
107971: IFFALSE 108018
// begin if not IsInArea ( group [ i ] , f_repair ) then
107973: LD_VAR 0 4
107977: PUSH
107978: LD_VAR 0 7
107982: ARRAY
107983: PPUSH
107984: LD_VAR 0 22
107988: PPUSH
107989: CALL_OW 308
107993: NOT
107994: IFFALSE 108016
// ComMoveToArea ( group [ i ] , f_repair ) ;
107996: LD_VAR 0 4
108000: PUSH
108001: LD_VAR 0 7
108005: ARRAY
108006: PPUSH
108007: LD_VAR 0 22
108011: PPUSH
108012: CALL_OW 113
// continue ;
108016: GO 107643
// end ; end else
108018: GO 108298
// if group [ i ] in repairs then
108020: LD_VAR 0 4
108024: PUSH
108025: LD_VAR 0 7
108029: ARRAY
108030: PUSH
108031: LD_VAR 0 33
108035: IN
108036: IFFALSE 108298
// begin if IsInUnit ( group [ i ] ) then
108038: LD_VAR 0 4
108042: PUSH
108043: LD_VAR 0 7
108047: ARRAY
108048: PPUSH
108049: CALL_OW 310
108053: IFFALSE 108121
// begin z := IsInUnit ( group [ i ] ) ;
108055: LD_ADDR_VAR 0 13
108059: PUSH
108060: LD_VAR 0 4
108064: PUSH
108065: LD_VAR 0 7
108069: ARRAY
108070: PPUSH
108071: CALL_OW 310
108075: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108076: LD_VAR 0 13
108080: PUSH
108081: LD_VAR 0 32
108085: IN
108086: PUSH
108087: LD_VAR 0 13
108091: PPUSH
108092: LD_VAR 0 22
108096: PPUSH
108097: CALL_OW 308
108101: AND
108102: IFFALSE 108119
// ComExitVehicle ( group [ i ] ) ;
108104: LD_VAR 0 4
108108: PUSH
108109: LD_VAR 0 7
108113: ARRAY
108114: PPUSH
108115: CALL_OW 121
// end else
108119: GO 108298
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108121: LD_ADDR_VAR 0 13
108125: PUSH
108126: LD_VAR 0 4
108130: PPUSH
108131: LD_INT 95
108133: PUSH
108134: LD_VAR 0 22
108138: PUSH
108139: EMPTY
108140: LIST
108141: LIST
108142: PUSH
108143: LD_INT 58
108145: PUSH
108146: EMPTY
108147: LIST
108148: PUSH
108149: EMPTY
108150: LIST
108151: LIST
108152: PPUSH
108153: CALL_OW 72
108157: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108158: LD_VAR 0 4
108162: PUSH
108163: LD_VAR 0 7
108167: ARRAY
108168: PPUSH
108169: CALL_OW 314
108173: NOT
108174: IFFALSE 108296
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108176: LD_ADDR_VAR 0 10
108180: PUSH
108181: LD_VAR 0 13
108185: PPUSH
108186: LD_VAR 0 4
108190: PUSH
108191: LD_VAR 0 7
108195: ARRAY
108196: PPUSH
108197: CALL_OW 74
108201: ST_TO_ADDR
// if not x then
108202: LD_VAR 0 10
108206: NOT
108207: IFFALSE 108211
// continue ;
108209: GO 107643
// if GetLives ( x ) < 1000 then
108211: LD_VAR 0 10
108215: PPUSH
108216: CALL_OW 256
108220: PUSH
108221: LD_INT 1000
108223: LESS
108224: IFFALSE 108248
// ComRepairVehicle ( group [ i ] , x ) else
108226: LD_VAR 0 4
108230: PUSH
108231: LD_VAR 0 7
108235: ARRAY
108236: PPUSH
108237: LD_VAR 0 10
108241: PPUSH
108242: CALL_OW 129
108246: GO 108296
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108248: LD_VAR 0 23
108252: PUSH
108253: LD_VAR 0 4
108257: PUSH
108258: LD_VAR 0 7
108262: ARRAY
108263: PPUSH
108264: CALL_OW 256
108268: PUSH
108269: LD_INT 1000
108271: LESS
108272: AND
108273: NOT
108274: IFFALSE 108296
// ComEnterUnit ( group [ i ] , x ) ;
108276: LD_VAR 0 4
108280: PUSH
108281: LD_VAR 0 7
108285: ARRAY
108286: PPUSH
108287: LD_VAR 0 10
108291: PPUSH
108292: CALL_OW 120
// end ; continue ;
108296: GO 107643
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108298: LD_VAR 0 23
108302: PUSH
108303: LD_VAR 0 4
108307: PUSH
108308: LD_VAR 0 7
108312: ARRAY
108313: PPUSH
108314: CALL_OW 247
108318: PUSH
108319: LD_INT 1
108321: EQUAL
108322: AND
108323: IFFALSE 108801
// begin if group [ i ] in healers then
108325: LD_VAR 0 4
108329: PUSH
108330: LD_VAR 0 7
108334: ARRAY
108335: PUSH
108336: LD_VAR 0 31
108340: IN
108341: IFFALSE 108614
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108343: LD_VAR 0 4
108347: PUSH
108348: LD_VAR 0 7
108352: ARRAY
108353: PPUSH
108354: LD_VAR 0 23
108358: PPUSH
108359: CALL_OW 308
108363: NOT
108364: PUSH
108365: LD_VAR 0 4
108369: PUSH
108370: LD_VAR 0 7
108374: ARRAY
108375: PPUSH
108376: CALL_OW 314
108380: NOT
108381: AND
108382: IFFALSE 108406
// ComMoveToArea ( group [ i ] , f_heal ) else
108384: LD_VAR 0 4
108388: PUSH
108389: LD_VAR 0 7
108393: ARRAY
108394: PPUSH
108395: LD_VAR 0 23
108399: PPUSH
108400: CALL_OW 113
108404: GO 108612
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108406: LD_VAR 0 4
108410: PUSH
108411: LD_VAR 0 7
108415: ARRAY
108416: PPUSH
108417: CALL 49793 0 1
108421: PPUSH
108422: CALL_OW 256
108426: PUSH
108427: LD_INT 1000
108429: EQUAL
108430: IFFALSE 108449
// ComStop ( group [ i ] ) else
108432: LD_VAR 0 4
108436: PUSH
108437: LD_VAR 0 7
108441: ARRAY
108442: PPUSH
108443: CALL_OW 141
108447: GO 108612
// if not HasTask ( group [ i ] ) and to_heal then
108449: LD_VAR 0 4
108453: PUSH
108454: LD_VAR 0 7
108458: ARRAY
108459: PPUSH
108460: CALL_OW 314
108464: NOT
108465: PUSH
108466: LD_VAR 0 30
108470: AND
108471: IFFALSE 108612
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108473: LD_ADDR_VAR 0 13
108477: PUSH
108478: LD_VAR 0 30
108482: PPUSH
108483: LD_INT 3
108485: PUSH
108486: LD_INT 54
108488: PUSH
108489: EMPTY
108490: LIST
108491: PUSH
108492: EMPTY
108493: LIST
108494: LIST
108495: PPUSH
108496: CALL_OW 72
108500: PPUSH
108501: LD_VAR 0 4
108505: PUSH
108506: LD_VAR 0 7
108510: ARRAY
108511: PPUSH
108512: CALL_OW 74
108516: ST_TO_ADDR
// if z then
108517: LD_VAR 0 13
108521: IFFALSE 108612
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108523: LD_INT 91
108525: PUSH
108526: LD_VAR 0 13
108530: PUSH
108531: LD_INT 10
108533: PUSH
108534: EMPTY
108535: LIST
108536: LIST
108537: LIST
108538: PUSH
108539: LD_INT 81
108541: PUSH
108542: LD_VAR 0 13
108546: PPUSH
108547: CALL_OW 255
108551: PUSH
108552: EMPTY
108553: LIST
108554: LIST
108555: PUSH
108556: EMPTY
108557: LIST
108558: LIST
108559: PPUSH
108560: CALL_OW 69
108564: PUSH
108565: LD_INT 0
108567: EQUAL
108568: IFFALSE 108592
// ComHeal ( group [ i ] , z ) else
108570: LD_VAR 0 4
108574: PUSH
108575: LD_VAR 0 7
108579: ARRAY
108580: PPUSH
108581: LD_VAR 0 13
108585: PPUSH
108586: CALL_OW 128
108590: GO 108612
// ComMoveToArea ( group [ i ] , f_heal ) ;
108592: LD_VAR 0 4
108596: PUSH
108597: LD_VAR 0 7
108601: ARRAY
108602: PPUSH
108603: LD_VAR 0 23
108607: PPUSH
108608: CALL_OW 113
// end ; continue ;
108612: GO 107643
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108614: LD_VAR 0 4
108618: PUSH
108619: LD_VAR 0 7
108623: ARRAY
108624: PPUSH
108625: CALL_OW 256
108629: PUSH
108630: LD_INT 700
108632: LESS
108633: PUSH
108634: LD_VAR 0 4
108638: PUSH
108639: LD_VAR 0 7
108643: ARRAY
108644: PUSH
108645: LD_VAR 0 30
108649: IN
108650: NOT
108651: AND
108652: IFFALSE 108676
// to_heal := to_heal union group [ i ] ;
108654: LD_ADDR_VAR 0 30
108658: PUSH
108659: LD_VAR 0 30
108663: PUSH
108664: LD_VAR 0 4
108668: PUSH
108669: LD_VAR 0 7
108673: ARRAY
108674: UNION
108675: ST_TO_ADDR
// if group [ i ] in to_heal then
108676: LD_VAR 0 4
108680: PUSH
108681: LD_VAR 0 7
108685: ARRAY
108686: PUSH
108687: LD_VAR 0 30
108691: IN
108692: IFFALSE 108801
// begin if GetLives ( group [ i ] ) = 1000 then
108694: LD_VAR 0 4
108698: PUSH
108699: LD_VAR 0 7
108703: ARRAY
108704: PPUSH
108705: CALL_OW 256
108709: PUSH
108710: LD_INT 1000
108712: EQUAL
108713: IFFALSE 108739
// to_heal := to_heal diff group [ i ] else
108715: LD_ADDR_VAR 0 30
108719: PUSH
108720: LD_VAR 0 30
108724: PUSH
108725: LD_VAR 0 4
108729: PUSH
108730: LD_VAR 0 7
108734: ARRAY
108735: DIFF
108736: ST_TO_ADDR
108737: GO 108801
// begin if not IsInArea ( group [ i ] , to_heal ) then
108739: LD_VAR 0 4
108743: PUSH
108744: LD_VAR 0 7
108748: ARRAY
108749: PPUSH
108750: LD_VAR 0 30
108754: PPUSH
108755: CALL_OW 308
108759: NOT
108760: IFFALSE 108784
// ComMoveToArea ( group [ i ] , f_heal ) else
108762: LD_VAR 0 4
108766: PUSH
108767: LD_VAR 0 7
108771: ARRAY
108772: PPUSH
108773: LD_VAR 0 23
108777: PPUSH
108778: CALL_OW 113
108782: GO 108799
// ComHold ( group [ i ] ) ;
108784: LD_VAR 0 4
108788: PUSH
108789: LD_VAR 0 7
108793: ARRAY
108794: PPUSH
108795: CALL_OW 140
// continue ;
108799: GO 107643
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108801: LD_VAR 0 4
108805: PUSH
108806: LD_VAR 0 7
108810: ARRAY
108811: PPUSH
108812: LD_INT 10
108814: PPUSH
108815: CALL 47564 0 2
108819: NOT
108820: PUSH
108821: LD_VAR 0 16
108825: PUSH
108826: LD_VAR 0 7
108830: ARRAY
108831: PUSH
108832: EMPTY
108833: EQUAL
108834: NOT
108835: AND
108836: IFFALSE 109102
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108838: LD_VAR 0 4
108842: PUSH
108843: LD_VAR 0 7
108847: ARRAY
108848: PPUSH
108849: CALL_OW 262
108853: PUSH
108854: LD_INT 1
108856: PUSH
108857: LD_INT 2
108859: PUSH
108860: EMPTY
108861: LIST
108862: LIST
108863: IN
108864: IFFALSE 108905
// if GetFuel ( group [ i ] ) < 10 then
108866: LD_VAR 0 4
108870: PUSH
108871: LD_VAR 0 7
108875: ARRAY
108876: PPUSH
108877: CALL_OW 261
108881: PUSH
108882: LD_INT 10
108884: LESS
108885: IFFALSE 108905
// SetFuel ( group [ i ] , 12 ) ;
108887: LD_VAR 0 4
108891: PUSH
108892: LD_VAR 0 7
108896: ARRAY
108897: PPUSH
108898: LD_INT 12
108900: PPUSH
108901: CALL_OW 240
// if units_path [ i ] then
108905: LD_VAR 0 16
108909: PUSH
108910: LD_VAR 0 7
108914: ARRAY
108915: IFFALSE 109100
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108917: LD_VAR 0 4
108921: PUSH
108922: LD_VAR 0 7
108926: ARRAY
108927: PPUSH
108928: LD_VAR 0 16
108932: PUSH
108933: LD_VAR 0 7
108937: ARRAY
108938: PUSH
108939: LD_INT 1
108941: ARRAY
108942: PUSH
108943: LD_INT 1
108945: ARRAY
108946: PPUSH
108947: LD_VAR 0 16
108951: PUSH
108952: LD_VAR 0 7
108956: ARRAY
108957: PUSH
108958: LD_INT 1
108960: ARRAY
108961: PUSH
108962: LD_INT 2
108964: ARRAY
108965: PPUSH
108966: CALL_OW 297
108970: PUSH
108971: LD_INT 6
108973: GREATER
108974: IFFALSE 109049
// begin if not HasTask ( group [ i ] ) then
108976: LD_VAR 0 4
108980: PUSH
108981: LD_VAR 0 7
108985: ARRAY
108986: PPUSH
108987: CALL_OW 314
108991: NOT
108992: IFFALSE 109047
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108994: LD_VAR 0 4
108998: PUSH
108999: LD_VAR 0 7
109003: ARRAY
109004: PPUSH
109005: LD_VAR 0 16
109009: PUSH
109010: LD_VAR 0 7
109014: ARRAY
109015: PUSH
109016: LD_INT 1
109018: ARRAY
109019: PUSH
109020: LD_INT 1
109022: ARRAY
109023: PPUSH
109024: LD_VAR 0 16
109028: PUSH
109029: LD_VAR 0 7
109033: ARRAY
109034: PUSH
109035: LD_INT 1
109037: ARRAY
109038: PUSH
109039: LD_INT 2
109041: ARRAY
109042: PPUSH
109043: CALL_OW 114
// end else
109047: GO 109100
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109049: LD_ADDR_VAR 0 15
109053: PUSH
109054: LD_VAR 0 16
109058: PUSH
109059: LD_VAR 0 7
109063: ARRAY
109064: PPUSH
109065: LD_INT 1
109067: PPUSH
109068: CALL_OW 3
109072: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109073: LD_ADDR_VAR 0 16
109077: PUSH
109078: LD_VAR 0 16
109082: PPUSH
109083: LD_VAR 0 7
109087: PPUSH
109088: LD_VAR 0 15
109092: PPUSH
109093: CALL_OW 1
109097: ST_TO_ADDR
// continue ;
109098: GO 107643
// end ; end ; end else
109100: GO 111764
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109102: LD_ADDR_VAR 0 14
109106: PUSH
109107: LD_INT 81
109109: PUSH
109110: LD_VAR 0 4
109114: PUSH
109115: LD_VAR 0 7
109119: ARRAY
109120: PPUSH
109121: CALL_OW 255
109125: PUSH
109126: EMPTY
109127: LIST
109128: LIST
109129: PPUSH
109130: CALL_OW 69
109134: ST_TO_ADDR
// if not tmp then
109135: LD_VAR 0 14
109139: NOT
109140: IFFALSE 109144
// continue ;
109142: GO 107643
// if f_ignore_area then
109144: LD_VAR 0 17
109148: IFFALSE 109236
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109150: LD_ADDR_VAR 0 15
109154: PUSH
109155: LD_VAR 0 14
109159: PPUSH
109160: LD_INT 3
109162: PUSH
109163: LD_INT 92
109165: PUSH
109166: LD_VAR 0 17
109170: PUSH
109171: LD_INT 1
109173: ARRAY
109174: PUSH
109175: LD_VAR 0 17
109179: PUSH
109180: LD_INT 2
109182: ARRAY
109183: PUSH
109184: LD_VAR 0 17
109188: PUSH
109189: LD_INT 3
109191: ARRAY
109192: PUSH
109193: EMPTY
109194: LIST
109195: LIST
109196: LIST
109197: LIST
109198: PUSH
109199: EMPTY
109200: LIST
109201: LIST
109202: PPUSH
109203: CALL_OW 72
109207: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109208: LD_VAR 0 14
109212: PUSH
109213: LD_VAR 0 15
109217: DIFF
109218: IFFALSE 109236
// tmp := tmp diff tmp2 ;
109220: LD_ADDR_VAR 0 14
109224: PUSH
109225: LD_VAR 0 14
109229: PUSH
109230: LD_VAR 0 15
109234: DIFF
109235: ST_TO_ADDR
// end ; if not f_murder then
109236: LD_VAR 0 20
109240: NOT
109241: IFFALSE 109299
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109243: LD_ADDR_VAR 0 15
109247: PUSH
109248: LD_VAR 0 14
109252: PPUSH
109253: LD_INT 3
109255: PUSH
109256: LD_INT 50
109258: PUSH
109259: EMPTY
109260: LIST
109261: PUSH
109262: EMPTY
109263: LIST
109264: LIST
109265: PPUSH
109266: CALL_OW 72
109270: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109271: LD_VAR 0 14
109275: PUSH
109276: LD_VAR 0 15
109280: DIFF
109281: IFFALSE 109299
// tmp := tmp diff tmp2 ;
109283: LD_ADDR_VAR 0 14
109287: PUSH
109288: LD_VAR 0 14
109292: PUSH
109293: LD_VAR 0 15
109297: DIFF
109298: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109299: LD_ADDR_VAR 0 14
109303: PUSH
109304: LD_VAR 0 4
109308: PUSH
109309: LD_VAR 0 7
109313: ARRAY
109314: PPUSH
109315: LD_VAR 0 14
109319: PPUSH
109320: LD_INT 1
109322: PPUSH
109323: LD_INT 1
109325: PPUSH
109326: CALL 20505 0 4
109330: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109331: LD_VAR 0 4
109335: PUSH
109336: LD_VAR 0 7
109340: ARRAY
109341: PPUSH
109342: CALL_OW 257
109346: PUSH
109347: LD_INT 1
109349: EQUAL
109350: IFFALSE 109798
// begin if WantPlant ( group [ i ] ) then
109352: LD_VAR 0 4
109356: PUSH
109357: LD_VAR 0 7
109361: ARRAY
109362: PPUSH
109363: CALL 20006 0 1
109367: IFFALSE 109371
// continue ;
109369: GO 107643
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109371: LD_VAR 0 18
109375: PUSH
109376: LD_VAR 0 4
109380: PUSH
109381: LD_VAR 0 7
109385: ARRAY
109386: PPUSH
109387: CALL_OW 310
109391: NOT
109392: AND
109393: PUSH
109394: LD_VAR 0 14
109398: PUSH
109399: LD_INT 1
109401: ARRAY
109402: PUSH
109403: LD_VAR 0 14
109407: PPUSH
109408: LD_INT 21
109410: PUSH
109411: LD_INT 2
109413: PUSH
109414: EMPTY
109415: LIST
109416: LIST
109417: PUSH
109418: LD_INT 58
109420: PUSH
109421: EMPTY
109422: LIST
109423: PUSH
109424: EMPTY
109425: LIST
109426: LIST
109427: PPUSH
109428: CALL_OW 72
109432: IN
109433: AND
109434: IFFALSE 109470
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109436: LD_VAR 0 4
109440: PUSH
109441: LD_VAR 0 7
109445: ARRAY
109446: PPUSH
109447: LD_VAR 0 14
109451: PUSH
109452: LD_INT 1
109454: ARRAY
109455: PPUSH
109456: CALL_OW 120
// attacking := true ;
109460: LD_ADDR_VAR 0 29
109464: PUSH
109465: LD_INT 1
109467: ST_TO_ADDR
// continue ;
109468: GO 107643
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109470: LD_VAR 0 26
109474: PUSH
109475: LD_VAR 0 4
109479: PUSH
109480: LD_VAR 0 7
109484: ARRAY
109485: PPUSH
109486: CALL_OW 257
109490: PUSH
109491: LD_INT 1
109493: EQUAL
109494: AND
109495: PUSH
109496: LD_VAR 0 4
109500: PUSH
109501: LD_VAR 0 7
109505: ARRAY
109506: PPUSH
109507: CALL_OW 256
109511: PUSH
109512: LD_INT 800
109514: LESS
109515: AND
109516: PUSH
109517: LD_VAR 0 4
109521: PUSH
109522: LD_VAR 0 7
109526: ARRAY
109527: PPUSH
109528: CALL_OW 318
109532: NOT
109533: AND
109534: IFFALSE 109551
// ComCrawl ( group [ i ] ) ;
109536: LD_VAR 0 4
109540: PUSH
109541: LD_VAR 0 7
109545: ARRAY
109546: PPUSH
109547: CALL_OW 137
// if f_mines then
109551: LD_VAR 0 21
109555: IFFALSE 109798
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109557: LD_VAR 0 14
109561: PUSH
109562: LD_INT 1
109564: ARRAY
109565: PPUSH
109566: CALL_OW 247
109570: PUSH
109571: LD_INT 3
109573: EQUAL
109574: PUSH
109575: LD_VAR 0 14
109579: PUSH
109580: LD_INT 1
109582: ARRAY
109583: PUSH
109584: LD_VAR 0 27
109588: IN
109589: NOT
109590: AND
109591: IFFALSE 109798
// begin x := GetX ( tmp [ 1 ] ) ;
109593: LD_ADDR_VAR 0 10
109597: PUSH
109598: LD_VAR 0 14
109602: PUSH
109603: LD_INT 1
109605: ARRAY
109606: PPUSH
109607: CALL_OW 250
109611: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109612: LD_ADDR_VAR 0 11
109616: PUSH
109617: LD_VAR 0 14
109621: PUSH
109622: LD_INT 1
109624: ARRAY
109625: PPUSH
109626: CALL_OW 251
109630: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109631: LD_ADDR_VAR 0 12
109635: PUSH
109636: LD_VAR 0 4
109640: PUSH
109641: LD_VAR 0 7
109645: ARRAY
109646: PPUSH
109647: CALL 47649 0 1
109651: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109652: LD_VAR 0 4
109656: PUSH
109657: LD_VAR 0 7
109661: ARRAY
109662: PPUSH
109663: LD_VAR 0 10
109667: PPUSH
109668: LD_VAR 0 11
109672: PPUSH
109673: LD_VAR 0 14
109677: PUSH
109678: LD_INT 1
109680: ARRAY
109681: PPUSH
109682: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109686: LD_VAR 0 4
109690: PUSH
109691: LD_VAR 0 7
109695: ARRAY
109696: PPUSH
109697: LD_VAR 0 10
109701: PPUSH
109702: LD_VAR 0 12
109706: PPUSH
109707: LD_INT 7
109709: PPUSH
109710: CALL_OW 272
109714: PPUSH
109715: LD_VAR 0 11
109719: PPUSH
109720: LD_VAR 0 12
109724: PPUSH
109725: LD_INT 7
109727: PPUSH
109728: CALL_OW 273
109732: PPUSH
109733: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109737: LD_VAR 0 4
109741: PUSH
109742: LD_VAR 0 7
109746: ARRAY
109747: PPUSH
109748: LD_INT 71
109750: PPUSH
109751: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109755: LD_ADDR_VAR 0 27
109759: PUSH
109760: LD_VAR 0 27
109764: PPUSH
109765: LD_VAR 0 27
109769: PUSH
109770: LD_INT 1
109772: PLUS
109773: PPUSH
109774: LD_VAR 0 14
109778: PUSH
109779: LD_INT 1
109781: ARRAY
109782: PPUSH
109783: CALL_OW 1
109787: ST_TO_ADDR
// attacking := true ;
109788: LD_ADDR_VAR 0 29
109792: PUSH
109793: LD_INT 1
109795: ST_TO_ADDR
// continue ;
109796: GO 107643
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109798: LD_VAR 0 4
109802: PUSH
109803: LD_VAR 0 7
109807: ARRAY
109808: PPUSH
109809: CALL_OW 257
109813: PUSH
109814: LD_INT 17
109816: EQUAL
109817: PUSH
109818: LD_VAR 0 4
109822: PUSH
109823: LD_VAR 0 7
109827: ARRAY
109828: PPUSH
109829: CALL_OW 110
109833: PUSH
109834: LD_INT 71
109836: EQUAL
109837: NOT
109838: AND
109839: IFFALSE 109985
// begin attacking := false ;
109841: LD_ADDR_VAR 0 29
109845: PUSH
109846: LD_INT 0
109848: ST_TO_ADDR
// k := 5 ;
109849: LD_ADDR_VAR 0 9
109853: PUSH
109854: LD_INT 5
109856: ST_TO_ADDR
// if tmp < k then
109857: LD_VAR 0 14
109861: PUSH
109862: LD_VAR 0 9
109866: LESS
109867: IFFALSE 109879
// k := tmp ;
109869: LD_ADDR_VAR 0 9
109873: PUSH
109874: LD_VAR 0 14
109878: ST_TO_ADDR
// for j = 1 to k do
109879: LD_ADDR_VAR 0 8
109883: PUSH
109884: DOUBLE
109885: LD_INT 1
109887: DEC
109888: ST_TO_ADDR
109889: LD_VAR 0 9
109893: PUSH
109894: FOR_TO
109895: IFFALSE 109983
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109897: LD_VAR 0 14
109901: PUSH
109902: LD_VAR 0 8
109906: ARRAY
109907: PUSH
109908: LD_VAR 0 14
109912: PPUSH
109913: LD_INT 58
109915: PUSH
109916: EMPTY
109917: LIST
109918: PPUSH
109919: CALL_OW 72
109923: IN
109924: NOT
109925: IFFALSE 109981
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109927: LD_VAR 0 4
109931: PUSH
109932: LD_VAR 0 7
109936: ARRAY
109937: PPUSH
109938: LD_VAR 0 14
109942: PUSH
109943: LD_VAR 0 8
109947: ARRAY
109948: PPUSH
109949: CALL_OW 115
// attacking := true ;
109953: LD_ADDR_VAR 0 29
109957: PUSH
109958: LD_INT 1
109960: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109961: LD_VAR 0 4
109965: PUSH
109966: LD_VAR 0 7
109970: ARRAY
109971: PPUSH
109972: LD_INT 71
109974: PPUSH
109975: CALL_OW 109
// continue ;
109979: GO 109894
// end ; end ;
109981: GO 109894
109983: POP
109984: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109985: LD_VAR 0 4
109989: PUSH
109990: LD_VAR 0 7
109994: ARRAY
109995: PPUSH
109996: CALL_OW 257
110000: PUSH
110001: LD_INT 8
110003: EQUAL
110004: PUSH
110005: LD_VAR 0 4
110009: PUSH
110010: LD_VAR 0 7
110014: ARRAY
110015: PPUSH
110016: CALL_OW 264
110020: PUSH
110021: LD_INT 28
110023: PUSH
110024: LD_INT 45
110026: PUSH
110027: LD_INT 7
110029: PUSH
110030: LD_INT 47
110032: PUSH
110033: EMPTY
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: IN
110039: OR
110040: IFFALSE 110296
// begin attacking := false ;
110042: LD_ADDR_VAR 0 29
110046: PUSH
110047: LD_INT 0
110049: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110050: LD_VAR 0 14
110054: PUSH
110055: LD_INT 1
110057: ARRAY
110058: PPUSH
110059: CALL_OW 266
110063: PUSH
110064: LD_INT 32
110066: PUSH
110067: LD_INT 31
110069: PUSH
110070: LD_INT 33
110072: PUSH
110073: LD_INT 4
110075: PUSH
110076: LD_INT 5
110078: PUSH
110079: EMPTY
110080: LIST
110081: LIST
110082: LIST
110083: LIST
110084: LIST
110085: IN
110086: IFFALSE 110272
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110088: LD_ADDR_VAR 0 9
110092: PUSH
110093: LD_VAR 0 14
110097: PUSH
110098: LD_INT 1
110100: ARRAY
110101: PPUSH
110102: CALL_OW 266
110106: PPUSH
110107: LD_VAR 0 14
110111: PUSH
110112: LD_INT 1
110114: ARRAY
110115: PPUSH
110116: CALL_OW 250
110120: PPUSH
110121: LD_VAR 0 14
110125: PUSH
110126: LD_INT 1
110128: ARRAY
110129: PPUSH
110130: CALL_OW 251
110134: PPUSH
110135: LD_VAR 0 14
110139: PUSH
110140: LD_INT 1
110142: ARRAY
110143: PPUSH
110144: CALL_OW 254
110148: PPUSH
110149: LD_VAR 0 14
110153: PUSH
110154: LD_INT 1
110156: ARRAY
110157: PPUSH
110158: CALL_OW 248
110162: PPUSH
110163: LD_INT 0
110165: PPUSH
110166: CALL 29019 0 6
110170: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110171: LD_ADDR_VAR 0 8
110175: PUSH
110176: LD_VAR 0 4
110180: PUSH
110181: LD_VAR 0 7
110185: ARRAY
110186: PPUSH
110187: LD_VAR 0 9
110191: PPUSH
110192: CALL 47762 0 2
110196: ST_TO_ADDR
// if j then
110197: LD_VAR 0 8
110201: IFFALSE 110270
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110203: LD_VAR 0 8
110207: PUSH
110208: LD_INT 1
110210: ARRAY
110211: PPUSH
110212: LD_VAR 0 8
110216: PUSH
110217: LD_INT 2
110219: ARRAY
110220: PPUSH
110221: CALL_OW 488
110225: IFFALSE 110270
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110227: LD_VAR 0 4
110231: PUSH
110232: LD_VAR 0 7
110236: ARRAY
110237: PPUSH
110238: LD_VAR 0 8
110242: PUSH
110243: LD_INT 1
110245: ARRAY
110246: PPUSH
110247: LD_VAR 0 8
110251: PUSH
110252: LD_INT 2
110254: ARRAY
110255: PPUSH
110256: CALL_OW 116
// attacking := true ;
110260: LD_ADDR_VAR 0 29
110264: PUSH
110265: LD_INT 1
110267: ST_TO_ADDR
// continue ;
110268: GO 107643
// end ; end else
110270: GO 110296
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110272: LD_VAR 0 4
110276: PUSH
110277: LD_VAR 0 7
110281: ARRAY
110282: PPUSH
110283: LD_VAR 0 14
110287: PUSH
110288: LD_INT 1
110290: ARRAY
110291: PPUSH
110292: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110296: LD_VAR 0 4
110300: PUSH
110301: LD_VAR 0 7
110305: ARRAY
110306: PPUSH
110307: CALL_OW 265
110311: PUSH
110312: LD_INT 11
110314: EQUAL
110315: IFFALSE 110593
// begin k := 10 ;
110317: LD_ADDR_VAR 0 9
110321: PUSH
110322: LD_INT 10
110324: ST_TO_ADDR
// x := 0 ;
110325: LD_ADDR_VAR 0 10
110329: PUSH
110330: LD_INT 0
110332: ST_TO_ADDR
// if tmp < k then
110333: LD_VAR 0 14
110337: PUSH
110338: LD_VAR 0 9
110342: LESS
110343: IFFALSE 110355
// k := tmp ;
110345: LD_ADDR_VAR 0 9
110349: PUSH
110350: LD_VAR 0 14
110354: ST_TO_ADDR
// for j = k downto 1 do
110355: LD_ADDR_VAR 0 8
110359: PUSH
110360: DOUBLE
110361: LD_VAR 0 9
110365: INC
110366: ST_TO_ADDR
110367: LD_INT 1
110369: PUSH
110370: FOR_DOWNTO
110371: IFFALSE 110446
// begin if GetType ( tmp [ j ] ) = unit_human then
110373: LD_VAR 0 14
110377: PUSH
110378: LD_VAR 0 8
110382: ARRAY
110383: PPUSH
110384: CALL_OW 247
110388: PUSH
110389: LD_INT 1
110391: EQUAL
110392: IFFALSE 110444
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110394: LD_VAR 0 4
110398: PUSH
110399: LD_VAR 0 7
110403: ARRAY
110404: PPUSH
110405: LD_VAR 0 14
110409: PUSH
110410: LD_VAR 0 8
110414: ARRAY
110415: PPUSH
110416: CALL 48016 0 2
// x := tmp [ j ] ;
110420: LD_ADDR_VAR 0 10
110424: PUSH
110425: LD_VAR 0 14
110429: PUSH
110430: LD_VAR 0 8
110434: ARRAY
110435: ST_TO_ADDR
// attacking := true ;
110436: LD_ADDR_VAR 0 29
110440: PUSH
110441: LD_INT 1
110443: ST_TO_ADDR
// end ; end ;
110444: GO 110370
110446: POP
110447: POP
// if not x then
110448: LD_VAR 0 10
110452: NOT
110453: IFFALSE 110593
// begin attacking := true ;
110455: LD_ADDR_VAR 0 29
110459: PUSH
110460: LD_INT 1
110462: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110463: LD_VAR 0 4
110467: PUSH
110468: LD_VAR 0 7
110472: ARRAY
110473: PPUSH
110474: CALL_OW 250
110478: PPUSH
110479: LD_VAR 0 4
110483: PUSH
110484: LD_VAR 0 7
110488: ARRAY
110489: PPUSH
110490: CALL_OW 251
110494: PPUSH
110495: CALL_OW 546
110499: PUSH
110500: LD_INT 2
110502: ARRAY
110503: PUSH
110504: LD_VAR 0 14
110508: PUSH
110509: LD_INT 1
110511: ARRAY
110512: PPUSH
110513: CALL_OW 250
110517: PPUSH
110518: LD_VAR 0 14
110522: PUSH
110523: LD_INT 1
110525: ARRAY
110526: PPUSH
110527: CALL_OW 251
110531: PPUSH
110532: CALL_OW 546
110536: PUSH
110537: LD_INT 2
110539: ARRAY
110540: EQUAL
110541: IFFALSE 110569
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110543: LD_VAR 0 4
110547: PUSH
110548: LD_VAR 0 7
110552: ARRAY
110553: PPUSH
110554: LD_VAR 0 14
110558: PUSH
110559: LD_INT 1
110561: ARRAY
110562: PPUSH
110563: CALL 48016 0 2
110567: GO 110593
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110569: LD_VAR 0 4
110573: PUSH
110574: LD_VAR 0 7
110578: ARRAY
110579: PPUSH
110580: LD_VAR 0 14
110584: PUSH
110585: LD_INT 1
110587: ARRAY
110588: PPUSH
110589: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110593: LD_VAR 0 4
110597: PUSH
110598: LD_VAR 0 7
110602: ARRAY
110603: PPUSH
110604: CALL_OW 264
110608: PUSH
110609: LD_INT 29
110611: EQUAL
110612: IFFALSE 110978
// begin if WantsToAttack ( group [ i ] ) in bombed then
110614: LD_VAR 0 4
110618: PUSH
110619: LD_VAR 0 7
110623: ARRAY
110624: PPUSH
110625: CALL_OW 319
110629: PUSH
110630: LD_VAR 0 28
110634: IN
110635: IFFALSE 110639
// continue ;
110637: GO 107643
// k := 8 ;
110639: LD_ADDR_VAR 0 9
110643: PUSH
110644: LD_INT 8
110646: ST_TO_ADDR
// x := 0 ;
110647: LD_ADDR_VAR 0 10
110651: PUSH
110652: LD_INT 0
110654: ST_TO_ADDR
// if tmp < k then
110655: LD_VAR 0 14
110659: PUSH
110660: LD_VAR 0 9
110664: LESS
110665: IFFALSE 110677
// k := tmp ;
110667: LD_ADDR_VAR 0 9
110671: PUSH
110672: LD_VAR 0 14
110676: ST_TO_ADDR
// for j = 1 to k do
110677: LD_ADDR_VAR 0 8
110681: PUSH
110682: DOUBLE
110683: LD_INT 1
110685: DEC
110686: ST_TO_ADDR
110687: LD_VAR 0 9
110691: PUSH
110692: FOR_TO
110693: IFFALSE 110825
// begin if GetType ( tmp [ j ] ) = unit_building then
110695: LD_VAR 0 14
110699: PUSH
110700: LD_VAR 0 8
110704: ARRAY
110705: PPUSH
110706: CALL_OW 247
110710: PUSH
110711: LD_INT 3
110713: EQUAL
110714: IFFALSE 110823
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110716: LD_VAR 0 14
110720: PUSH
110721: LD_VAR 0 8
110725: ARRAY
110726: PUSH
110727: LD_VAR 0 28
110731: IN
110732: NOT
110733: PUSH
110734: LD_VAR 0 14
110738: PUSH
110739: LD_VAR 0 8
110743: ARRAY
110744: PPUSH
110745: CALL_OW 313
110749: AND
110750: IFFALSE 110823
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110752: LD_VAR 0 4
110756: PUSH
110757: LD_VAR 0 7
110761: ARRAY
110762: PPUSH
110763: LD_VAR 0 14
110767: PUSH
110768: LD_VAR 0 8
110772: ARRAY
110773: PPUSH
110774: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110778: LD_ADDR_VAR 0 28
110782: PUSH
110783: LD_VAR 0 28
110787: PPUSH
110788: LD_VAR 0 28
110792: PUSH
110793: LD_INT 1
110795: PLUS
110796: PPUSH
110797: LD_VAR 0 14
110801: PUSH
110802: LD_VAR 0 8
110806: ARRAY
110807: PPUSH
110808: CALL_OW 1
110812: ST_TO_ADDR
// attacking := true ;
110813: LD_ADDR_VAR 0 29
110817: PUSH
110818: LD_INT 1
110820: ST_TO_ADDR
// break ;
110821: GO 110825
// end ; end ;
110823: GO 110692
110825: POP
110826: POP
// if not attacking and f_attack_depot then
110827: LD_VAR 0 29
110831: NOT
110832: PUSH
110833: LD_VAR 0 25
110837: AND
110838: IFFALSE 110933
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110840: LD_ADDR_VAR 0 13
110844: PUSH
110845: LD_VAR 0 14
110849: PPUSH
110850: LD_INT 2
110852: PUSH
110853: LD_INT 30
110855: PUSH
110856: LD_INT 0
110858: PUSH
110859: EMPTY
110860: LIST
110861: LIST
110862: PUSH
110863: LD_INT 30
110865: PUSH
110866: LD_INT 1
110868: PUSH
110869: EMPTY
110870: LIST
110871: LIST
110872: PUSH
110873: EMPTY
110874: LIST
110875: LIST
110876: LIST
110877: PPUSH
110878: CALL_OW 72
110882: ST_TO_ADDR
// if z then
110883: LD_VAR 0 13
110887: IFFALSE 110933
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110889: LD_VAR 0 4
110893: PUSH
110894: LD_VAR 0 7
110898: ARRAY
110899: PPUSH
110900: LD_VAR 0 13
110904: PPUSH
110905: LD_VAR 0 4
110909: PUSH
110910: LD_VAR 0 7
110914: ARRAY
110915: PPUSH
110916: CALL_OW 74
110920: PPUSH
110921: CALL_OW 115
// attacking := true ;
110925: LD_ADDR_VAR 0 29
110929: PUSH
110930: LD_INT 1
110932: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110933: LD_VAR 0 4
110937: PUSH
110938: LD_VAR 0 7
110942: ARRAY
110943: PPUSH
110944: CALL_OW 256
110948: PUSH
110949: LD_INT 500
110951: LESS
110952: IFFALSE 110978
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110954: LD_VAR 0 4
110958: PUSH
110959: LD_VAR 0 7
110963: ARRAY
110964: PPUSH
110965: LD_VAR 0 14
110969: PUSH
110970: LD_INT 1
110972: ARRAY
110973: PPUSH
110974: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110978: LD_VAR 0 4
110982: PUSH
110983: LD_VAR 0 7
110987: ARRAY
110988: PPUSH
110989: CALL_OW 264
110993: PUSH
110994: LD_INT 49
110996: EQUAL
110997: IFFALSE 111118
// begin if not HasTask ( group [ i ] ) then
110999: LD_VAR 0 4
111003: PUSH
111004: LD_VAR 0 7
111008: ARRAY
111009: PPUSH
111010: CALL_OW 314
111014: NOT
111015: IFFALSE 111118
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111017: LD_ADDR_VAR 0 9
111021: PUSH
111022: LD_INT 81
111024: PUSH
111025: LD_VAR 0 4
111029: PUSH
111030: LD_VAR 0 7
111034: ARRAY
111035: PPUSH
111036: CALL_OW 255
111040: PUSH
111041: EMPTY
111042: LIST
111043: LIST
111044: PPUSH
111045: CALL_OW 69
111049: PPUSH
111050: LD_VAR 0 4
111054: PUSH
111055: LD_VAR 0 7
111059: ARRAY
111060: PPUSH
111061: CALL_OW 74
111065: ST_TO_ADDR
// if k then
111066: LD_VAR 0 9
111070: IFFALSE 111118
// if GetDistUnits ( group [ i ] , k ) > 10 then
111072: LD_VAR 0 4
111076: PUSH
111077: LD_VAR 0 7
111081: ARRAY
111082: PPUSH
111083: LD_VAR 0 9
111087: PPUSH
111088: CALL_OW 296
111092: PUSH
111093: LD_INT 10
111095: GREATER
111096: IFFALSE 111118
// ComMoveUnit ( group [ i ] , k ) ;
111098: LD_VAR 0 4
111102: PUSH
111103: LD_VAR 0 7
111107: ARRAY
111108: PPUSH
111109: LD_VAR 0 9
111113: PPUSH
111114: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111118: LD_VAR 0 4
111122: PUSH
111123: LD_VAR 0 7
111127: ARRAY
111128: PPUSH
111129: CALL_OW 256
111133: PUSH
111134: LD_INT 250
111136: LESS
111137: PUSH
111138: LD_VAR 0 4
111142: PUSH
111143: LD_VAR 0 7
111147: ARRAY
111148: PUSH
111149: LD_INT 21
111151: PUSH
111152: LD_INT 2
111154: PUSH
111155: EMPTY
111156: LIST
111157: LIST
111158: PUSH
111159: LD_INT 23
111161: PUSH
111162: LD_INT 2
111164: PUSH
111165: EMPTY
111166: LIST
111167: LIST
111168: PUSH
111169: EMPTY
111170: LIST
111171: LIST
111172: PPUSH
111173: CALL_OW 69
111177: IN
111178: AND
111179: IFFALSE 111304
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111181: LD_ADDR_VAR 0 9
111185: PUSH
111186: LD_OWVAR 3
111190: PUSH
111191: LD_VAR 0 4
111195: PUSH
111196: LD_VAR 0 7
111200: ARRAY
111201: DIFF
111202: PPUSH
111203: LD_VAR 0 4
111207: PUSH
111208: LD_VAR 0 7
111212: ARRAY
111213: PPUSH
111214: CALL_OW 74
111218: ST_TO_ADDR
// if not k then
111219: LD_VAR 0 9
111223: NOT
111224: IFFALSE 111228
// continue ;
111226: GO 107643
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111228: LD_VAR 0 9
111232: PUSH
111233: LD_INT 81
111235: PUSH
111236: LD_VAR 0 4
111240: PUSH
111241: LD_VAR 0 7
111245: ARRAY
111246: PPUSH
111247: CALL_OW 255
111251: PUSH
111252: EMPTY
111253: LIST
111254: LIST
111255: PPUSH
111256: CALL_OW 69
111260: IN
111261: PUSH
111262: LD_VAR 0 9
111266: PPUSH
111267: LD_VAR 0 4
111271: PUSH
111272: LD_VAR 0 7
111276: ARRAY
111277: PPUSH
111278: CALL_OW 296
111282: PUSH
111283: LD_INT 5
111285: LESS
111286: AND
111287: IFFALSE 111304
// ComAutodestruct ( group [ i ] ) ;
111289: LD_VAR 0 4
111293: PUSH
111294: LD_VAR 0 7
111298: ARRAY
111299: PPUSH
111300: CALL 47914 0 1
// end ; if f_attack_depot then
111304: LD_VAR 0 25
111308: IFFALSE 111420
// begin k := 6 ;
111310: LD_ADDR_VAR 0 9
111314: PUSH
111315: LD_INT 6
111317: ST_TO_ADDR
// if tmp < k then
111318: LD_VAR 0 14
111322: PUSH
111323: LD_VAR 0 9
111327: LESS
111328: IFFALSE 111340
// k := tmp ;
111330: LD_ADDR_VAR 0 9
111334: PUSH
111335: LD_VAR 0 14
111339: ST_TO_ADDR
// for j = 1 to k do
111340: LD_ADDR_VAR 0 8
111344: PUSH
111345: DOUBLE
111346: LD_INT 1
111348: DEC
111349: ST_TO_ADDR
111350: LD_VAR 0 9
111354: PUSH
111355: FOR_TO
111356: IFFALSE 111418
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111358: LD_VAR 0 8
111362: PPUSH
111363: CALL_OW 266
111367: PUSH
111368: LD_INT 0
111370: PUSH
111371: LD_INT 1
111373: PUSH
111374: EMPTY
111375: LIST
111376: LIST
111377: IN
111378: IFFALSE 111416
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111380: LD_VAR 0 4
111384: PUSH
111385: LD_VAR 0 7
111389: ARRAY
111390: PPUSH
111391: LD_VAR 0 14
111395: PUSH
111396: LD_VAR 0 8
111400: ARRAY
111401: PPUSH
111402: CALL_OW 115
// attacking := true ;
111406: LD_ADDR_VAR 0 29
111410: PUSH
111411: LD_INT 1
111413: ST_TO_ADDR
// break ;
111414: GO 111418
// end ;
111416: GO 111355
111418: POP
111419: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111420: LD_VAR 0 4
111424: PUSH
111425: LD_VAR 0 7
111429: ARRAY
111430: PPUSH
111431: CALL_OW 302
111435: PUSH
111436: LD_VAR 0 29
111440: NOT
111441: AND
111442: IFFALSE 111764
// begin if GetTag ( group [ i ] ) = 71 then
111444: LD_VAR 0 4
111448: PUSH
111449: LD_VAR 0 7
111453: ARRAY
111454: PPUSH
111455: CALL_OW 110
111459: PUSH
111460: LD_INT 71
111462: EQUAL
111463: IFFALSE 111504
// begin if HasTask ( group [ i ] ) then
111465: LD_VAR 0 4
111469: PUSH
111470: LD_VAR 0 7
111474: ARRAY
111475: PPUSH
111476: CALL_OW 314
111480: IFFALSE 111486
// continue else
111482: GO 107643
111484: GO 111504
// SetTag ( group [ i ] , 0 ) ;
111486: LD_VAR 0 4
111490: PUSH
111491: LD_VAR 0 7
111495: ARRAY
111496: PPUSH
111497: LD_INT 0
111499: PPUSH
111500: CALL_OW 109
// end ; k := 8 ;
111504: LD_ADDR_VAR 0 9
111508: PUSH
111509: LD_INT 8
111511: ST_TO_ADDR
// x := 0 ;
111512: LD_ADDR_VAR 0 10
111516: PUSH
111517: LD_INT 0
111519: ST_TO_ADDR
// if tmp < k then
111520: LD_VAR 0 14
111524: PUSH
111525: LD_VAR 0 9
111529: LESS
111530: IFFALSE 111542
// k := tmp ;
111532: LD_ADDR_VAR 0 9
111536: PUSH
111537: LD_VAR 0 14
111541: ST_TO_ADDR
// for j = 1 to k do
111542: LD_ADDR_VAR 0 8
111546: PUSH
111547: DOUBLE
111548: LD_INT 1
111550: DEC
111551: ST_TO_ADDR
111552: LD_VAR 0 9
111556: PUSH
111557: FOR_TO
111558: IFFALSE 111656
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111560: LD_VAR 0 14
111564: PUSH
111565: LD_VAR 0 8
111569: ARRAY
111570: PPUSH
111571: CALL_OW 247
111575: PUSH
111576: LD_INT 1
111578: EQUAL
111579: PUSH
111580: LD_VAR 0 14
111584: PUSH
111585: LD_VAR 0 8
111589: ARRAY
111590: PPUSH
111591: CALL_OW 256
111595: PUSH
111596: LD_INT 250
111598: LESS
111599: PUSH
111600: LD_VAR 0 20
111604: AND
111605: PUSH
111606: LD_VAR 0 20
111610: NOT
111611: PUSH
111612: LD_VAR 0 14
111616: PUSH
111617: LD_VAR 0 8
111621: ARRAY
111622: PPUSH
111623: CALL_OW 256
111627: PUSH
111628: LD_INT 250
111630: GREATEREQUAL
111631: AND
111632: OR
111633: AND
111634: IFFALSE 111654
// begin x := tmp [ j ] ;
111636: LD_ADDR_VAR 0 10
111640: PUSH
111641: LD_VAR 0 14
111645: PUSH
111646: LD_VAR 0 8
111650: ARRAY
111651: ST_TO_ADDR
// break ;
111652: GO 111656
// end ;
111654: GO 111557
111656: POP
111657: POP
// if x then
111658: LD_VAR 0 10
111662: IFFALSE 111686
// ComAttackUnit ( group [ i ] , x ) else
111664: LD_VAR 0 4
111668: PUSH
111669: LD_VAR 0 7
111673: ARRAY
111674: PPUSH
111675: LD_VAR 0 10
111679: PPUSH
111680: CALL_OW 115
111684: GO 111710
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111686: LD_VAR 0 4
111690: PUSH
111691: LD_VAR 0 7
111695: ARRAY
111696: PPUSH
111697: LD_VAR 0 14
111701: PUSH
111702: LD_INT 1
111704: ARRAY
111705: PPUSH
111706: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111710: LD_VAR 0 4
111714: PUSH
111715: LD_VAR 0 7
111719: ARRAY
111720: PPUSH
111721: CALL_OW 314
111725: NOT
111726: IFFALSE 111764
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111728: LD_VAR 0 4
111732: PUSH
111733: LD_VAR 0 7
111737: ARRAY
111738: PPUSH
111739: LD_VAR 0 14
111743: PPUSH
111744: LD_VAR 0 4
111748: PUSH
111749: LD_VAR 0 7
111753: ARRAY
111754: PPUSH
111755: CALL_OW 74
111759: PPUSH
111760: CALL_OW 115
// end ; end ; end ;
111764: GO 107643
111766: POP
111767: POP
// wait ( 0 0$2 ) ;
111768: LD_INT 70
111770: PPUSH
111771: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111775: LD_VAR 0 4
111779: NOT
111780: PUSH
111781: LD_VAR 0 4
111785: PUSH
111786: EMPTY
111787: EQUAL
111788: OR
111789: PUSH
111790: LD_INT 81
111792: PUSH
111793: LD_VAR 0 35
111797: PUSH
111798: EMPTY
111799: LIST
111800: LIST
111801: PPUSH
111802: CALL_OW 69
111806: NOT
111807: OR
111808: IFFALSE 107628
// end ;
111810: LD_VAR 0 2
111814: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111815: LD_INT 0
111817: PPUSH
111818: PPUSH
111819: PPUSH
111820: PPUSH
111821: PPUSH
111822: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111823: LD_VAR 0 1
111827: NOT
111828: PUSH
111829: LD_EXP 61
111833: PUSH
111834: LD_VAR 0 1
111838: ARRAY
111839: NOT
111840: OR
111841: PUSH
111842: LD_VAR 0 2
111846: NOT
111847: OR
111848: IFFALSE 111852
// exit ;
111850: GO 112406
// side := mc_sides [ base ] ;
111852: LD_ADDR_VAR 0 6
111856: PUSH
111857: LD_EXP 87
111861: PUSH
111862: LD_VAR 0 1
111866: ARRAY
111867: ST_TO_ADDR
// if not side then
111868: LD_VAR 0 6
111872: NOT
111873: IFFALSE 111877
// exit ;
111875: GO 112406
// for i in solds do
111877: LD_ADDR_VAR 0 7
111881: PUSH
111882: LD_VAR 0 2
111886: PUSH
111887: FOR_IN
111888: IFFALSE 111949
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111890: LD_VAR 0 7
111894: PPUSH
111895: CALL_OW 310
111899: PPUSH
111900: CALL_OW 266
111904: PUSH
111905: LD_INT 32
111907: PUSH
111908: LD_INT 31
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: IN
111915: IFFALSE 111935
// solds := solds diff i else
111917: LD_ADDR_VAR 0 2
111921: PUSH
111922: LD_VAR 0 2
111926: PUSH
111927: LD_VAR 0 7
111931: DIFF
111932: ST_TO_ADDR
111933: GO 111947
// SetTag ( i , 18 ) ;
111935: LD_VAR 0 7
111939: PPUSH
111940: LD_INT 18
111942: PPUSH
111943: CALL_OW 109
111947: GO 111887
111949: POP
111950: POP
// if not solds then
111951: LD_VAR 0 2
111955: NOT
111956: IFFALSE 111960
// exit ;
111958: GO 112406
// repeat wait ( 0 0$2 ) ;
111960: LD_INT 70
111962: PPUSH
111963: CALL_OW 67
// enemy := mc_scan [ base ] ;
111967: LD_ADDR_VAR 0 4
111971: PUSH
111972: LD_EXP 84
111976: PUSH
111977: LD_VAR 0 1
111981: ARRAY
111982: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111983: LD_EXP 61
111987: PUSH
111988: LD_VAR 0 1
111992: ARRAY
111993: NOT
111994: PUSH
111995: LD_EXP 61
111999: PUSH
112000: LD_VAR 0 1
112004: ARRAY
112005: PUSH
112006: EMPTY
112007: EQUAL
112008: OR
112009: IFFALSE 112046
// begin for i in solds do
112011: LD_ADDR_VAR 0 7
112015: PUSH
112016: LD_VAR 0 2
112020: PUSH
112021: FOR_IN
112022: IFFALSE 112035
// ComStop ( i ) ;
112024: LD_VAR 0 7
112028: PPUSH
112029: CALL_OW 141
112033: GO 112021
112035: POP
112036: POP
// solds := [ ] ;
112037: LD_ADDR_VAR 0 2
112041: PUSH
112042: EMPTY
112043: ST_TO_ADDR
// exit ;
112044: GO 112406
// end ; for i in solds do
112046: LD_ADDR_VAR 0 7
112050: PUSH
112051: LD_VAR 0 2
112055: PUSH
112056: FOR_IN
112057: IFFALSE 112378
// begin if IsInUnit ( i ) then
112059: LD_VAR 0 7
112063: PPUSH
112064: CALL_OW 310
112068: IFFALSE 112079
// ComExitBuilding ( i ) ;
112070: LD_VAR 0 7
112074: PPUSH
112075: CALL_OW 122
// if GetLives ( i ) > 500 then
112079: LD_VAR 0 7
112083: PPUSH
112084: CALL_OW 256
112088: PUSH
112089: LD_INT 500
112091: GREATER
112092: IFFALSE 112145
// begin e := NearestUnitToUnit ( enemy , i ) ;
112094: LD_ADDR_VAR 0 5
112098: PUSH
112099: LD_VAR 0 4
112103: PPUSH
112104: LD_VAR 0 7
112108: PPUSH
112109: CALL_OW 74
112113: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112114: LD_VAR 0 7
112118: PPUSH
112119: LD_VAR 0 5
112123: PPUSH
112124: CALL_OW 250
112128: PPUSH
112129: LD_VAR 0 5
112133: PPUSH
112134: CALL_OW 251
112138: PPUSH
112139: CALL_OW 114
// end else
112143: GO 112376
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112145: LD_VAR 0 7
112149: PPUSH
112150: LD_EXP 61
112154: PUSH
112155: LD_VAR 0 1
112159: ARRAY
112160: PPUSH
112161: LD_INT 2
112163: PUSH
112164: LD_INT 30
112166: PUSH
112167: LD_INT 0
112169: PUSH
112170: EMPTY
112171: LIST
112172: LIST
112173: PUSH
112174: LD_INT 30
112176: PUSH
112177: LD_INT 1
112179: PUSH
112180: EMPTY
112181: LIST
112182: LIST
112183: PUSH
112184: LD_INT 30
112186: PUSH
112187: LD_INT 6
112189: PUSH
112190: EMPTY
112191: LIST
112192: LIST
112193: PUSH
112194: EMPTY
112195: LIST
112196: LIST
112197: LIST
112198: LIST
112199: PPUSH
112200: CALL_OW 72
112204: PPUSH
112205: LD_VAR 0 7
112209: PPUSH
112210: CALL_OW 74
112214: PPUSH
112215: CALL_OW 296
112219: PUSH
112220: LD_INT 10
112222: GREATER
112223: IFFALSE 112376
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112225: LD_ADDR_VAR 0 8
112229: PUSH
112230: LD_EXP 61
112234: PUSH
112235: LD_VAR 0 1
112239: ARRAY
112240: PPUSH
112241: LD_INT 2
112243: PUSH
112244: LD_INT 30
112246: PUSH
112247: LD_INT 0
112249: PUSH
112250: EMPTY
112251: LIST
112252: LIST
112253: PUSH
112254: LD_INT 30
112256: PUSH
112257: LD_INT 1
112259: PUSH
112260: EMPTY
112261: LIST
112262: LIST
112263: PUSH
112264: LD_INT 30
112266: PUSH
112267: LD_INT 6
112269: PUSH
112270: EMPTY
112271: LIST
112272: LIST
112273: PUSH
112274: EMPTY
112275: LIST
112276: LIST
112277: LIST
112278: LIST
112279: PPUSH
112280: CALL_OW 72
112284: PPUSH
112285: LD_VAR 0 7
112289: PPUSH
112290: CALL_OW 74
112294: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112295: LD_VAR 0 7
112299: PPUSH
112300: LD_VAR 0 8
112304: PPUSH
112305: CALL_OW 250
112309: PPUSH
112310: LD_INT 3
112312: PPUSH
112313: LD_INT 5
112315: PPUSH
112316: CALL_OW 272
112320: PPUSH
112321: LD_VAR 0 8
112325: PPUSH
112326: CALL_OW 251
112330: PPUSH
112331: LD_INT 3
112333: PPUSH
112334: LD_INT 5
112336: PPUSH
112337: CALL_OW 273
112341: PPUSH
112342: CALL_OW 111
// SetTag ( i , 0 ) ;
112346: LD_VAR 0 7
112350: PPUSH
112351: LD_INT 0
112353: PPUSH
112354: CALL_OW 109
// solds := solds diff i ;
112358: LD_ADDR_VAR 0 2
112362: PUSH
112363: LD_VAR 0 2
112367: PUSH
112368: LD_VAR 0 7
112372: DIFF
112373: ST_TO_ADDR
// continue ;
112374: GO 112056
// end ; end ;
112376: GO 112056
112378: POP
112379: POP
// until not solds or not enemy ;
112380: LD_VAR 0 2
112384: NOT
112385: PUSH
112386: LD_VAR 0 4
112390: NOT
112391: OR
112392: IFFALSE 111960
// MC_Reset ( base , 18 ) ;
112394: LD_VAR 0 1
112398: PPUSH
112399: LD_INT 18
112401: PPUSH
112402: CALL 60515 0 2
// end ;
112406: LD_VAR 0 3
112410: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112411: LD_INT 0
112413: PPUSH
112414: PPUSH
112415: PPUSH
112416: PPUSH
112417: PPUSH
112418: PPUSH
112419: PPUSH
112420: PPUSH
112421: PPUSH
112422: PPUSH
112423: PPUSH
112424: PPUSH
112425: PPUSH
112426: PPUSH
112427: PPUSH
112428: PPUSH
112429: PPUSH
112430: PPUSH
112431: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112432: LD_ADDR_VAR 0 12
112436: PUSH
112437: LD_EXP 61
112441: PUSH
112442: LD_VAR 0 1
112446: ARRAY
112447: PPUSH
112448: LD_INT 25
112450: PUSH
112451: LD_INT 3
112453: PUSH
112454: EMPTY
112455: LIST
112456: LIST
112457: PPUSH
112458: CALL_OW 72
112462: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112463: LD_EXP 101
112467: PUSH
112468: LD_VAR 0 1
112472: ARRAY
112473: IFFALSE 112497
// mechs := mechs diff mc_remote_driver [ base ] ;
112475: LD_ADDR_VAR 0 12
112479: PUSH
112480: LD_VAR 0 12
112484: PUSH
112485: LD_EXP 101
112489: PUSH
112490: LD_VAR 0 1
112494: ARRAY
112495: DIFF
112496: ST_TO_ADDR
// for i in mechs do
112497: LD_ADDR_VAR 0 4
112501: PUSH
112502: LD_VAR 0 12
112506: PUSH
112507: FOR_IN
112508: IFFALSE 112543
// if GetTag ( i ) > 0 then
112510: LD_VAR 0 4
112514: PPUSH
112515: CALL_OW 110
112519: PUSH
112520: LD_INT 0
112522: GREATER
112523: IFFALSE 112541
// mechs := mechs diff i ;
112525: LD_ADDR_VAR 0 12
112529: PUSH
112530: LD_VAR 0 12
112534: PUSH
112535: LD_VAR 0 4
112539: DIFF
112540: ST_TO_ADDR
112541: GO 112507
112543: POP
112544: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112545: LD_ADDR_VAR 0 8
112549: PUSH
112550: LD_EXP 61
112554: PUSH
112555: LD_VAR 0 1
112559: ARRAY
112560: PPUSH
112561: LD_INT 2
112563: PUSH
112564: LD_INT 25
112566: PUSH
112567: LD_INT 1
112569: PUSH
112570: EMPTY
112571: LIST
112572: LIST
112573: PUSH
112574: LD_INT 25
112576: PUSH
112577: LD_INT 5
112579: PUSH
112580: EMPTY
112581: LIST
112582: LIST
112583: PUSH
112584: LD_INT 25
112586: PUSH
112587: LD_INT 8
112589: PUSH
112590: EMPTY
112591: LIST
112592: LIST
112593: PUSH
112594: LD_INT 25
112596: PUSH
112597: LD_INT 9
112599: PUSH
112600: EMPTY
112601: LIST
112602: LIST
112603: PUSH
112604: EMPTY
112605: LIST
112606: LIST
112607: LIST
112608: LIST
112609: LIST
112610: PPUSH
112611: CALL_OW 72
112615: ST_TO_ADDR
// if not defenders and not solds then
112616: LD_VAR 0 2
112620: NOT
112621: PUSH
112622: LD_VAR 0 8
112626: NOT
112627: AND
112628: IFFALSE 112632
// exit ;
112630: GO 114402
// depot_under_attack := false ;
112632: LD_ADDR_VAR 0 16
112636: PUSH
112637: LD_INT 0
112639: ST_TO_ADDR
// sold_defenders := [ ] ;
112640: LD_ADDR_VAR 0 17
112644: PUSH
112645: EMPTY
112646: ST_TO_ADDR
// if mechs then
112647: LD_VAR 0 12
112651: IFFALSE 112804
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112653: LD_ADDR_VAR 0 4
112657: PUSH
112658: LD_VAR 0 2
112662: PPUSH
112663: LD_INT 21
112665: PUSH
112666: LD_INT 2
112668: PUSH
112669: EMPTY
112670: LIST
112671: LIST
112672: PPUSH
112673: CALL_OW 72
112677: PUSH
112678: FOR_IN
112679: IFFALSE 112802
// begin if GetTag ( i ) <> 20 then
112681: LD_VAR 0 4
112685: PPUSH
112686: CALL_OW 110
112690: PUSH
112691: LD_INT 20
112693: NONEQUAL
112694: IFFALSE 112708
// SetTag ( i , 20 ) ;
112696: LD_VAR 0 4
112700: PPUSH
112701: LD_INT 20
112703: PPUSH
112704: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112708: LD_VAR 0 4
112712: PPUSH
112713: CALL_OW 263
112717: PUSH
112718: LD_INT 1
112720: EQUAL
112721: PUSH
112722: LD_VAR 0 4
112726: PPUSH
112727: CALL_OW 311
112731: NOT
112732: AND
112733: IFFALSE 112800
// begin un := mechs [ 1 ] ;
112735: LD_ADDR_VAR 0 10
112739: PUSH
112740: LD_VAR 0 12
112744: PUSH
112745: LD_INT 1
112747: ARRAY
112748: ST_TO_ADDR
// ComExit ( un ) ;
112749: LD_VAR 0 10
112753: PPUSH
112754: CALL 52799 0 1
// AddComEnterUnit ( un , i ) ;
112758: LD_VAR 0 10
112762: PPUSH
112763: LD_VAR 0 4
112767: PPUSH
112768: CALL_OW 180
// SetTag ( un , 19 ) ;
112772: LD_VAR 0 10
112776: PPUSH
112777: LD_INT 19
112779: PPUSH
112780: CALL_OW 109
// mechs := mechs diff un ;
112784: LD_ADDR_VAR 0 12
112788: PUSH
112789: LD_VAR 0 12
112793: PUSH
112794: LD_VAR 0 10
112798: DIFF
112799: ST_TO_ADDR
// end ; end ;
112800: GO 112678
112802: POP
112803: POP
// if solds then
112804: LD_VAR 0 8
112808: IFFALSE 112867
// for i in solds do
112810: LD_ADDR_VAR 0 4
112814: PUSH
112815: LD_VAR 0 8
112819: PUSH
112820: FOR_IN
112821: IFFALSE 112865
// if not GetTag ( i ) then
112823: LD_VAR 0 4
112827: PPUSH
112828: CALL_OW 110
112832: NOT
112833: IFFALSE 112863
// begin defenders := defenders union i ;
112835: LD_ADDR_VAR 0 2
112839: PUSH
112840: LD_VAR 0 2
112844: PUSH
112845: LD_VAR 0 4
112849: UNION
112850: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112851: LD_VAR 0 4
112855: PPUSH
112856: LD_INT 18
112858: PPUSH
112859: CALL_OW 109
// end ;
112863: GO 112820
112865: POP
112866: POP
// repeat wait ( 0 0$2 ) ;
112867: LD_INT 70
112869: PPUSH
112870: CALL_OW 67
// enemy := mc_scan [ base ] ;
112874: LD_ADDR_VAR 0 21
112878: PUSH
112879: LD_EXP 84
112883: PUSH
112884: LD_VAR 0 1
112888: ARRAY
112889: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112890: LD_EXP 61
112894: PUSH
112895: LD_VAR 0 1
112899: ARRAY
112900: NOT
112901: PUSH
112902: LD_EXP 61
112906: PUSH
112907: LD_VAR 0 1
112911: ARRAY
112912: PUSH
112913: EMPTY
112914: EQUAL
112915: OR
112916: IFFALSE 112953
// begin for i in defenders do
112918: LD_ADDR_VAR 0 4
112922: PUSH
112923: LD_VAR 0 2
112927: PUSH
112928: FOR_IN
112929: IFFALSE 112942
// ComStop ( i ) ;
112931: LD_VAR 0 4
112935: PPUSH
112936: CALL_OW 141
112940: GO 112928
112942: POP
112943: POP
// defenders := [ ] ;
112944: LD_ADDR_VAR 0 2
112948: PUSH
112949: EMPTY
112950: ST_TO_ADDR
// exit ;
112951: GO 114402
// end ; for i in defenders do
112953: LD_ADDR_VAR 0 4
112957: PUSH
112958: LD_VAR 0 2
112962: PUSH
112963: FOR_IN
112964: IFFALSE 113862
// begin e := NearestUnitToUnit ( enemy , i ) ;
112966: LD_ADDR_VAR 0 13
112970: PUSH
112971: LD_VAR 0 21
112975: PPUSH
112976: LD_VAR 0 4
112980: PPUSH
112981: CALL_OW 74
112985: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112986: LD_ADDR_VAR 0 7
112990: PUSH
112991: LD_EXP 61
112995: PUSH
112996: LD_VAR 0 1
113000: ARRAY
113001: PPUSH
113002: LD_INT 2
113004: PUSH
113005: LD_INT 30
113007: PUSH
113008: LD_INT 0
113010: PUSH
113011: EMPTY
113012: LIST
113013: LIST
113014: PUSH
113015: LD_INT 30
113017: PUSH
113018: LD_INT 1
113020: PUSH
113021: EMPTY
113022: LIST
113023: LIST
113024: PUSH
113025: EMPTY
113026: LIST
113027: LIST
113028: LIST
113029: PPUSH
113030: CALL_OW 72
113034: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113035: LD_ADDR_VAR 0 16
113039: PUSH
113040: LD_VAR 0 7
113044: NOT
113045: PUSH
113046: LD_VAR 0 7
113050: PPUSH
113051: LD_INT 3
113053: PUSH
113054: LD_INT 24
113056: PUSH
113057: LD_INT 600
113059: PUSH
113060: EMPTY
113061: LIST
113062: LIST
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: PPUSH
113068: CALL_OW 72
113072: OR
113073: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113074: LD_VAR 0 4
113078: PPUSH
113079: CALL_OW 247
113083: PUSH
113084: LD_INT 2
113086: DOUBLE
113087: EQUAL
113088: IFTRUE 113092
113090: GO 113488
113092: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113093: LD_VAR 0 4
113097: PPUSH
113098: CALL_OW 256
113102: PUSH
113103: LD_INT 1000
113105: EQUAL
113106: PUSH
113107: LD_VAR 0 4
113111: PPUSH
113112: LD_VAR 0 13
113116: PPUSH
113117: CALL_OW 296
113121: PUSH
113122: LD_INT 40
113124: LESS
113125: PUSH
113126: LD_VAR 0 13
113130: PPUSH
113131: LD_EXP 86
113135: PUSH
113136: LD_VAR 0 1
113140: ARRAY
113141: PPUSH
113142: CALL_OW 308
113146: OR
113147: AND
113148: IFFALSE 113270
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113150: LD_VAR 0 4
113154: PPUSH
113155: CALL_OW 262
113159: PUSH
113160: LD_INT 1
113162: EQUAL
113163: PUSH
113164: LD_VAR 0 4
113168: PPUSH
113169: CALL_OW 261
113173: PUSH
113174: LD_INT 30
113176: LESS
113177: AND
113178: PUSH
113179: LD_VAR 0 7
113183: AND
113184: IFFALSE 113254
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113186: LD_VAR 0 4
113190: PPUSH
113191: LD_VAR 0 7
113195: PPUSH
113196: LD_VAR 0 4
113200: PPUSH
113201: CALL_OW 74
113205: PPUSH
113206: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113210: LD_VAR 0 4
113214: PPUSH
113215: LD_VAR 0 7
113219: PPUSH
113220: LD_VAR 0 4
113224: PPUSH
113225: CALL_OW 74
113229: PPUSH
113230: CALL_OW 296
113234: PUSH
113235: LD_INT 6
113237: LESS
113238: IFFALSE 113252
// SetFuel ( i , 100 ) ;
113240: LD_VAR 0 4
113244: PPUSH
113245: LD_INT 100
113247: PPUSH
113248: CALL_OW 240
// end else
113252: GO 113268
// ComAttackUnit ( i , e ) ;
113254: LD_VAR 0 4
113258: PPUSH
113259: LD_VAR 0 13
113263: PPUSH
113264: CALL_OW 115
// end else
113268: GO 113371
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113270: LD_VAR 0 13
113274: PPUSH
113275: LD_EXP 86
113279: PUSH
113280: LD_VAR 0 1
113284: ARRAY
113285: PPUSH
113286: CALL_OW 308
113290: NOT
113291: PUSH
113292: LD_VAR 0 4
113296: PPUSH
113297: LD_VAR 0 13
113301: PPUSH
113302: CALL_OW 296
113306: PUSH
113307: LD_INT 40
113309: GREATEREQUAL
113310: AND
113311: PUSH
113312: LD_VAR 0 4
113316: PPUSH
113317: CALL_OW 256
113321: PUSH
113322: LD_INT 650
113324: LESSEQUAL
113325: OR
113326: PUSH
113327: LD_VAR 0 4
113331: PPUSH
113332: LD_EXP 85
113336: PUSH
113337: LD_VAR 0 1
113341: ARRAY
113342: PPUSH
113343: CALL_OW 308
113347: NOT
113348: AND
113349: IFFALSE 113371
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113351: LD_VAR 0 4
113355: PPUSH
113356: LD_EXP 85
113360: PUSH
113361: LD_VAR 0 1
113365: ARRAY
113366: PPUSH
113367: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113371: LD_VAR 0 4
113375: PPUSH
113376: CALL_OW 256
113380: PUSH
113381: LD_INT 1000
113383: LESS
113384: PUSH
113385: LD_VAR 0 4
113389: PPUSH
113390: CALL_OW 263
113394: PUSH
113395: LD_INT 1
113397: EQUAL
113398: AND
113399: PUSH
113400: LD_VAR 0 4
113404: PPUSH
113405: CALL_OW 311
113409: AND
113410: PUSH
113411: LD_VAR 0 4
113415: PPUSH
113416: LD_EXP 85
113420: PUSH
113421: LD_VAR 0 1
113425: ARRAY
113426: PPUSH
113427: CALL_OW 308
113431: AND
113432: IFFALSE 113486
// begin mech := IsDrivenBy ( i ) ;
113434: LD_ADDR_VAR 0 9
113438: PUSH
113439: LD_VAR 0 4
113443: PPUSH
113444: CALL_OW 311
113448: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113449: LD_VAR 0 9
113453: PPUSH
113454: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113458: LD_VAR 0 9
113462: PPUSH
113463: LD_VAR 0 4
113467: PPUSH
113468: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113472: LD_VAR 0 9
113476: PPUSH
113477: LD_VAR 0 4
113481: PPUSH
113482: CALL_OW 180
// end ; end ; unit_human :
113486: GO 113833
113488: LD_INT 1
113490: DOUBLE
113491: EQUAL
113492: IFTRUE 113496
113494: GO 113832
113496: POP
// begin b := IsInUnit ( i ) ;
113497: LD_ADDR_VAR 0 18
113501: PUSH
113502: LD_VAR 0 4
113506: PPUSH
113507: CALL_OW 310
113511: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113512: LD_ADDR_VAR 0 19
113516: PUSH
113517: LD_VAR 0 18
113521: NOT
113522: PUSH
113523: LD_VAR 0 18
113527: PPUSH
113528: CALL_OW 266
113532: PUSH
113533: LD_INT 32
113535: PUSH
113536: LD_INT 31
113538: PUSH
113539: EMPTY
113540: LIST
113541: LIST
113542: IN
113543: OR
113544: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113545: LD_VAR 0 18
113549: PPUSH
113550: CALL_OW 266
113554: PUSH
113555: LD_INT 5
113557: EQUAL
113558: PUSH
113559: LD_VAR 0 4
113563: PPUSH
113564: CALL_OW 257
113568: PUSH
113569: LD_INT 1
113571: PUSH
113572: LD_INT 2
113574: PUSH
113575: LD_INT 3
113577: PUSH
113578: LD_INT 4
113580: PUSH
113581: EMPTY
113582: LIST
113583: LIST
113584: LIST
113585: LIST
113586: IN
113587: AND
113588: IFFALSE 113625
// begin class := AllowSpecClass ( i ) ;
113590: LD_ADDR_VAR 0 20
113594: PUSH
113595: LD_VAR 0 4
113599: PPUSH
113600: CALL 16719 0 1
113604: ST_TO_ADDR
// if class then
113605: LD_VAR 0 20
113609: IFFALSE 113625
// ComChangeProfession ( i , class ) ;
113611: LD_VAR 0 4
113615: PPUSH
113616: LD_VAR 0 20
113620: PPUSH
113621: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113625: LD_VAR 0 16
113629: PUSH
113630: LD_VAR 0 2
113634: PPUSH
113635: LD_INT 21
113637: PUSH
113638: LD_INT 2
113640: PUSH
113641: EMPTY
113642: LIST
113643: LIST
113644: PPUSH
113645: CALL_OW 72
113649: PUSH
113650: LD_INT 1
113652: LESSEQUAL
113653: OR
113654: PUSH
113655: LD_VAR 0 19
113659: AND
113660: PUSH
113661: LD_VAR 0 4
113665: PUSH
113666: LD_VAR 0 17
113670: IN
113671: NOT
113672: AND
113673: IFFALSE 113766
// begin if b then
113675: LD_VAR 0 18
113679: IFFALSE 113728
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113681: LD_VAR 0 18
113685: PPUSH
113686: LD_VAR 0 21
113690: PPUSH
113691: LD_VAR 0 18
113695: PPUSH
113696: CALL_OW 74
113700: PPUSH
113701: CALL_OW 296
113705: PUSH
113706: LD_INT 10
113708: LESS
113709: PUSH
113710: LD_VAR 0 18
113714: PPUSH
113715: CALL_OW 461
113719: PUSH
113720: LD_INT 7
113722: NONEQUAL
113723: AND
113724: IFFALSE 113728
// continue ;
113726: GO 112963
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113728: LD_ADDR_VAR 0 17
113732: PUSH
113733: LD_VAR 0 17
113737: PPUSH
113738: LD_VAR 0 17
113742: PUSH
113743: LD_INT 1
113745: PLUS
113746: PPUSH
113747: LD_VAR 0 4
113751: PPUSH
113752: CALL_OW 1
113756: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113757: LD_VAR 0 4
113761: PPUSH
113762: CALL_OW 122
// end ; if sold_defenders then
113766: LD_VAR 0 17
113770: IFFALSE 113830
// if i in sold_defenders then
113772: LD_VAR 0 4
113776: PUSH
113777: LD_VAR 0 17
113781: IN
113782: IFFALSE 113830
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113784: LD_VAR 0 4
113788: PPUSH
113789: CALL_OW 314
113793: NOT
113794: PUSH
113795: LD_VAR 0 4
113799: PPUSH
113800: LD_VAR 0 13
113804: PPUSH
113805: CALL_OW 296
113809: PUSH
113810: LD_INT 30
113812: LESS
113813: AND
113814: IFFALSE 113830
// ComAttackUnit ( i , e ) ;
113816: LD_VAR 0 4
113820: PPUSH
113821: LD_VAR 0 13
113825: PPUSH
113826: CALL_OW 115
// end ; end ; end ;
113830: GO 113833
113832: POP
// if IsDead ( i ) then
113833: LD_VAR 0 4
113837: PPUSH
113838: CALL_OW 301
113842: IFFALSE 113860
// defenders := defenders diff i ;
113844: LD_ADDR_VAR 0 2
113848: PUSH
113849: LD_VAR 0 2
113853: PUSH
113854: LD_VAR 0 4
113858: DIFF
113859: ST_TO_ADDR
// end ;
113860: GO 112963
113862: POP
113863: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113864: LD_VAR 0 21
113868: NOT
113869: PUSH
113870: LD_VAR 0 2
113874: NOT
113875: OR
113876: PUSH
113877: LD_EXP 61
113881: PUSH
113882: LD_VAR 0 1
113886: ARRAY
113887: NOT
113888: OR
113889: IFFALSE 112867
// MC_Reset ( base , 18 ) ;
113891: LD_VAR 0 1
113895: PPUSH
113896: LD_INT 18
113898: PPUSH
113899: CALL 60515 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113903: LD_ADDR_VAR 0 2
113907: PUSH
113908: LD_VAR 0 2
113912: PUSH
113913: LD_VAR 0 2
113917: PPUSH
113918: LD_INT 2
113920: PUSH
113921: LD_INT 25
113923: PUSH
113924: LD_INT 1
113926: PUSH
113927: EMPTY
113928: LIST
113929: LIST
113930: PUSH
113931: LD_INT 25
113933: PUSH
113934: LD_INT 5
113936: PUSH
113937: EMPTY
113938: LIST
113939: LIST
113940: PUSH
113941: LD_INT 25
113943: PUSH
113944: LD_INT 8
113946: PUSH
113947: EMPTY
113948: LIST
113949: LIST
113950: PUSH
113951: LD_INT 25
113953: PUSH
113954: LD_INT 9
113956: PUSH
113957: EMPTY
113958: LIST
113959: LIST
113960: PUSH
113961: EMPTY
113962: LIST
113963: LIST
113964: LIST
113965: LIST
113966: LIST
113967: PPUSH
113968: CALL_OW 72
113972: DIFF
113973: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113974: LD_VAR 0 21
113978: NOT
113979: PUSH
113980: LD_VAR 0 2
113984: PPUSH
113985: LD_INT 21
113987: PUSH
113988: LD_INT 2
113990: PUSH
113991: EMPTY
113992: LIST
113993: LIST
113994: PPUSH
113995: CALL_OW 72
113999: AND
114000: IFFALSE 114338
// begin tmp := FilterByTag ( defenders , 19 ) ;
114002: LD_ADDR_VAR 0 11
114006: PUSH
114007: LD_VAR 0 2
114011: PPUSH
114012: LD_INT 19
114014: PPUSH
114015: CALL 49982 0 2
114019: ST_TO_ADDR
// if tmp then
114020: LD_VAR 0 11
114024: IFFALSE 114094
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114026: LD_ADDR_VAR 0 11
114030: PUSH
114031: LD_VAR 0 11
114035: PPUSH
114036: LD_INT 25
114038: PUSH
114039: LD_INT 3
114041: PUSH
114042: EMPTY
114043: LIST
114044: LIST
114045: PPUSH
114046: CALL_OW 72
114050: ST_TO_ADDR
// if tmp then
114051: LD_VAR 0 11
114055: IFFALSE 114094
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114057: LD_ADDR_EXP 73
114061: PUSH
114062: LD_EXP 73
114066: PPUSH
114067: LD_VAR 0 1
114071: PPUSH
114072: LD_EXP 73
114076: PUSH
114077: LD_VAR 0 1
114081: ARRAY
114082: PUSH
114083: LD_VAR 0 11
114087: UNION
114088: PPUSH
114089: CALL_OW 1
114093: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114094: LD_VAR 0 1
114098: PPUSH
114099: LD_INT 19
114101: PPUSH
114102: CALL 60515 0 2
// repeat wait ( 0 0$1 ) ;
114106: LD_INT 35
114108: PPUSH
114109: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114113: LD_EXP 61
114117: PUSH
114118: LD_VAR 0 1
114122: ARRAY
114123: NOT
114124: PUSH
114125: LD_EXP 61
114129: PUSH
114130: LD_VAR 0 1
114134: ARRAY
114135: PUSH
114136: EMPTY
114137: EQUAL
114138: OR
114139: IFFALSE 114176
// begin for i in defenders do
114141: LD_ADDR_VAR 0 4
114145: PUSH
114146: LD_VAR 0 2
114150: PUSH
114151: FOR_IN
114152: IFFALSE 114165
// ComStop ( i ) ;
114154: LD_VAR 0 4
114158: PPUSH
114159: CALL_OW 141
114163: GO 114151
114165: POP
114166: POP
// defenders := [ ] ;
114167: LD_ADDR_VAR 0 2
114171: PUSH
114172: EMPTY
114173: ST_TO_ADDR
// exit ;
114174: GO 114402
// end ; for i in defenders do
114176: LD_ADDR_VAR 0 4
114180: PUSH
114181: LD_VAR 0 2
114185: PUSH
114186: FOR_IN
114187: IFFALSE 114276
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114189: LD_VAR 0 4
114193: PPUSH
114194: LD_EXP 85
114198: PUSH
114199: LD_VAR 0 1
114203: ARRAY
114204: PPUSH
114205: CALL_OW 308
114209: NOT
114210: IFFALSE 114234
// ComMoveToArea ( i , mc_parking [ base ] ) else
114212: LD_VAR 0 4
114216: PPUSH
114217: LD_EXP 85
114221: PUSH
114222: LD_VAR 0 1
114226: ARRAY
114227: PPUSH
114228: CALL_OW 113
114232: GO 114274
// if GetControl ( i ) = control_manual then
114234: LD_VAR 0 4
114238: PPUSH
114239: CALL_OW 263
114243: PUSH
114244: LD_INT 1
114246: EQUAL
114247: IFFALSE 114274
// if IsDrivenBy ( i ) then
114249: LD_VAR 0 4
114253: PPUSH
114254: CALL_OW 311
114258: IFFALSE 114274
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114260: LD_VAR 0 4
114264: PPUSH
114265: CALL_OW 311
114269: PPUSH
114270: CALL_OW 121
// end ;
114274: GO 114186
114276: POP
114277: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114278: LD_VAR 0 2
114282: PPUSH
114283: LD_INT 95
114285: PUSH
114286: LD_EXP 85
114290: PUSH
114291: LD_VAR 0 1
114295: ARRAY
114296: PUSH
114297: EMPTY
114298: LIST
114299: LIST
114300: PPUSH
114301: CALL_OW 72
114305: PUSH
114306: LD_VAR 0 2
114310: EQUAL
114311: PUSH
114312: LD_EXP 84
114316: PUSH
114317: LD_VAR 0 1
114321: ARRAY
114322: OR
114323: PUSH
114324: LD_EXP 61
114328: PUSH
114329: LD_VAR 0 1
114333: ARRAY
114334: NOT
114335: OR
114336: IFFALSE 114106
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114338: LD_ADDR_EXP 83
114342: PUSH
114343: LD_EXP 83
114347: PPUSH
114348: LD_VAR 0 1
114352: PPUSH
114353: LD_VAR 0 2
114357: PPUSH
114358: LD_INT 21
114360: PUSH
114361: LD_INT 2
114363: PUSH
114364: EMPTY
114365: LIST
114366: LIST
114367: PPUSH
114368: CALL_OW 72
114372: PPUSH
114373: CALL_OW 1
114377: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114378: LD_VAR 0 1
114382: PPUSH
114383: LD_INT 19
114385: PPUSH
114386: CALL 60515 0 2
// MC_Reset ( base , 20 ) ;
114390: LD_VAR 0 1
114394: PPUSH
114395: LD_INT 20
114397: PPUSH
114398: CALL 60515 0 2
// end ; end_of_file
114402: LD_VAR 0 3
114406: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114407: LD_VAR 0 1
114411: PUSH
114412: LD_INT 200
114414: DOUBLE
114415: GREATEREQUAL
114416: IFFALSE 114424
114418: LD_INT 299
114420: DOUBLE
114421: LESSEQUAL
114422: IFTRUE 114426
114424: GO 114458
114426: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114427: LD_VAR 0 1
114431: PPUSH
114432: LD_VAR 0 2
114436: PPUSH
114437: LD_VAR 0 3
114441: PPUSH
114442: LD_VAR 0 4
114446: PPUSH
114447: LD_VAR 0 5
114451: PPUSH
114452: CALL 103193 0 5
114456: GO 114535
114458: LD_INT 300
114460: DOUBLE
114461: GREATEREQUAL
114462: IFFALSE 114470
114464: LD_INT 399
114466: DOUBLE
114467: LESSEQUAL
114468: IFTRUE 114472
114470: GO 114534
114472: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114473: LD_VAR 0 1
114477: PPUSH
114478: LD_VAR 0 2
114482: PPUSH
114483: LD_VAR 0 3
114487: PPUSH
114488: LD_VAR 0 4
114492: PPUSH
114493: LD_VAR 0 5
114497: PPUSH
114498: LD_VAR 0 6
114502: PPUSH
114503: LD_VAR 0 7
114507: PPUSH
114508: LD_VAR 0 8
114512: PPUSH
114513: LD_VAR 0 9
114517: PPUSH
114518: LD_VAR 0 10
114522: PPUSH
114523: LD_VAR 0 11
114527: PPUSH
114528: CALL 99526 0 11
114532: GO 114535
114534: POP
// end ;
114535: PPOPN 11
114537: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114538: LD_VAR 0 1
114542: PPUSH
114543: LD_VAR 0 2
114547: PPUSH
114548: LD_VAR 0 3
114552: PPUSH
114553: LD_VAR 0 4
114557: PPUSH
114558: LD_VAR 0 5
114562: PPUSH
114563: CALL 102929 0 5
// end ; end_of_file
114567: PPOPN 5
114569: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114570: LD_VAR 0 1
114574: PPUSH
114575: LD_VAR 0 2
114579: PPUSH
114580: LD_VAR 0 3
114584: PPUSH
114585: LD_VAR 0 4
114589: PPUSH
114590: LD_VAR 0 5
114594: PPUSH
114595: LD_VAR 0 6
114599: PPUSH
114600: CALL 87146 0 6
// end ;
114604: PPOPN 6
114606: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114607: LD_INT 0
114609: PPUSH
// begin if not units then
114610: LD_VAR 0 1
114614: NOT
114615: IFFALSE 114619
// exit ;
114617: GO 114619
// end ;
114619: PPOPN 7
114621: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114622: CALL 87040 0 0
// end ;
114626: PPOPN 1
114628: END
