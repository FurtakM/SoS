// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 57136 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48903 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48903 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48903 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48903 0 9
// PrepareArabian ;
 147: CALL 3529 0 0
// PrepareRussian ;
 151: CALL 2664 0 0
// PrepareAlliance ;
 155: CALL 729 0 0
// MC_Start ( ) ;
 159: CALL 59248 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6692 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80569 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 80995 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81453 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81722 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 80935 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81629 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 80995 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81453 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81722 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80779 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 80935 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 51
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// end ; end_of_file
 724: LD_VAR 0 1
 728: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 729: LD_INT 0
 731: PPUSH
 732: PPUSH
 733: PPUSH
 734: PPUSH
// uc_side := 7 ;
 735: LD_ADDR_OWVAR 20
 739: PUSH
 740: LD_INT 7
 742: ST_TO_ADDR
// uc_nation := 1 ;
 743: LD_ADDR_OWVAR 21
 747: PUSH
 748: LD_INT 1
 750: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 751: LD_ADDR_EXP 14
 755: PUSH
 756: LD_STRING JMM
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_STRING 12a_
 767: PPUSH
 768: CALL 14063 0 3
 772: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 773: LD_EXP 14
 777: PPUSH
 778: LD_INT 71
 780: PPUSH
 781: LD_INT 23
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 791: LD_EXP 14
 795: PPUSH
 796: LD_INT 2
 798: PPUSH
 799: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_STRING Roth
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_STRING 12a_
 819: PPUSH
 820: CALL 14063 0 3
 824: ST_TO_ADDR
// if Roth then
 825: LD_EXP 15
 829: IFFALSE 849
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 831: LD_EXP 15
 835: PPUSH
 836: LD_INT 71
 838: PPUSH
 839: LD_INT 21
 841: PPUSH
 842: LD_INT 0
 844: PPUSH
 845: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 849: LD_ADDR_EXP 16
 853: PUSH
 854: LD_STRING Lisa
 856: PPUSH
 857: LD_EXP 1
 861: NOT
 862: PPUSH
 863: LD_STRING 12a_
 865: PPUSH
 866: CALL 14063 0 3
 870: ST_TO_ADDR
// if Lisa then
 871: LD_EXP 16
 875: IFFALSE 892
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 877: LD_EXP 16
 881: PPUSH
 882: LD_INT 13
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 892: LD_ADDR_EXP 17
 896: PUSH
 897: LD_STRING Donaldson
 899: PPUSH
 900: LD_EXP 1
 904: NOT
 905: PPUSH
 906: LD_STRING 12a_
 908: PPUSH
 909: CALL 14063 0 3
 913: ST_TO_ADDR
// if Donaldson then
 914: LD_EXP 17
 918: IFFALSE 935
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 920: LD_EXP 17
 924: PPUSH
 925: LD_INT 13
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 935: LD_ADDR_EXP 18
 939: PUSH
 940: LD_STRING Bobby
 942: PPUSH
 943: LD_EXP 1
 947: NOT
 948: PPUSH
 949: LD_STRING 12a_
 951: PPUSH
 952: CALL 14063 0 3
 956: ST_TO_ADDR
// if Bobby then
 957: LD_EXP 18
 961: IFFALSE 978
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 963: LD_EXP 18
 967: PPUSH
 968: LD_INT 13
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 978: LD_ADDR_EXP 19
 982: PUSH
 983: LD_STRING Cyrus
 985: PPUSH
 986: LD_EXP 1
 990: NOT
 991: PPUSH
 992: LD_STRING 12a_
 994: PPUSH
 995: CALL 14063 0 3
 999: ST_TO_ADDR
// if Cyrus then
1000: LD_EXP 19
1004: IFFALSE 1021
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1006: LD_EXP 19
1010: PPUSH
1011: LD_INT 13
1013: PPUSH
1014: LD_INT 0
1016: PPUSH
1017: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1021: LD_ADDR_EXP 20
1025: PUSH
1026: LD_STRING Denis
1028: PPUSH
1029: LD_EXP 1
1033: NOT
1034: PPUSH
1035: LD_STRING 12a_
1037: PPUSH
1038: CALL 14063 0 3
1042: ST_TO_ADDR
// if Denis then
1043: LD_EXP 20
1047: IFFALSE 1064
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1049: LD_EXP 20
1053: PPUSH
1054: LD_INT 13
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1064: LD_ADDR_EXP 21
1068: PUSH
1069: LD_STRING Brown
1071: PPUSH
1072: LD_EXP 1
1076: NOT
1077: PPUSH
1078: LD_STRING 12a_
1080: PPUSH
1081: CALL 14063 0 3
1085: ST_TO_ADDR
// if Brown then
1086: LD_EXP 21
1090: IFFALSE 1107
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1092: LD_EXP 21
1096: PPUSH
1097: LD_INT 13
1099: PPUSH
1100: LD_INT 0
1102: PPUSH
1103: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1107: LD_ADDR_EXP 22
1111: PUSH
1112: LD_STRING Gladstone
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_STRING 12a_
1123: PPUSH
1124: CALL 14063 0 3
1128: ST_TO_ADDR
// if Gladstone then
1129: LD_EXP 22
1133: IFFALSE 1150
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1135: LD_EXP 22
1139: PPUSH
1140: LD_INT 13
1142: PPUSH
1143: LD_INT 0
1145: PPUSH
1146: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1150: LD_ADDR_EXP 23
1154: PUSH
1155: LD_STRING Houten
1157: PPUSH
1158: LD_EXP 1
1162: NOT
1163: PPUSH
1164: LD_STRING 12a_
1166: PPUSH
1167: CALL 14063 0 3
1171: ST_TO_ADDR
// if Houten then
1172: LD_EXP 23
1176: IFFALSE 1193
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1178: LD_EXP 23
1182: PPUSH
1183: LD_INT 13
1185: PPUSH
1186: LD_INT 0
1188: PPUSH
1189: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1193: LD_ADDR_EXP 24
1197: PUSH
1198: LD_STRING Cornell
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 12a_
1209: PPUSH
1210: CALL 14063 0 3
1214: ST_TO_ADDR
// if Cornel then
1215: LD_EXP 24
1219: IFFALSE 1236
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1221: LD_EXP 24
1225: PPUSH
1226: LD_INT 13
1228: PPUSH
1229: LD_INT 0
1231: PPUSH
1232: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1236: LD_ADDR_EXP 25
1240: PUSH
1241: LD_STRING Gary
1243: PPUSH
1244: LD_EXP 1
1248: NOT
1249: PPUSH
1250: LD_STRING 12a_
1252: PPUSH
1253: CALL 14063 0 3
1257: ST_TO_ADDR
// if Gary then
1258: LD_EXP 25
1262: IFFALSE 1279
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1264: LD_EXP 25
1268: PPUSH
1269: LD_INT 13
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1279: LD_ADDR_EXP 26
1283: PUSH
1284: LD_STRING Frank
1286: PPUSH
1287: LD_EXP 1
1291: NOT
1292: PPUSH
1293: LD_STRING 12a_
1295: PPUSH
1296: CALL 14063 0 3
1300: ST_TO_ADDR
// if Frank then
1301: LD_EXP 26
1305: IFFALSE 1322
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1307: LD_EXP 26
1311: PPUSH
1312: LD_INT 13
1314: PPUSH
1315: LD_INT 0
1317: PPUSH
1318: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1322: LD_ADDR_EXP 27
1326: PUSH
1327: LD_STRING Kikuchi
1329: PPUSH
1330: LD_EXP 1
1334: NOT
1335: PPUSH
1336: LD_STRING 12a_
1338: PPUSH
1339: CALL 14063 0 3
1343: ST_TO_ADDR
// if Kikuchi then
1344: LD_EXP 27
1348: IFFALSE 1365
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1350: LD_EXP 27
1354: PPUSH
1355: LD_INT 13
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1365: LD_ADDR_EXP 28
1369: PUSH
1370: LD_STRING Simms
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_STRING 12a_
1381: PPUSH
1382: CALL 14063 0 3
1386: ST_TO_ADDR
// if Simms then
1387: LD_EXP 28
1391: IFFALSE 1408
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1393: LD_EXP 28
1397: PPUSH
1398: LD_INT 13
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1408: LD_ADDR_EXP 29
1412: PUSH
1413: LD_STRING Joan
1415: PPUSH
1416: LD_EXP 1
1420: NOT
1421: PPUSH
1422: LD_STRING 12a_
1424: PPUSH
1425: CALL 14063 0 3
1429: ST_TO_ADDR
// if Joan then
1430: LD_EXP 29
1434: IFFALSE 1451
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1436: LD_EXP 29
1440: PPUSH
1441: LD_INT 13
1443: PPUSH
1444: LD_INT 0
1446: PPUSH
1447: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1451: LD_ADDR_EXP 30
1455: PUSH
1456: LD_STRING DeltaDoctor
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 12a_
1467: PPUSH
1468: CALL 14063 0 3
1472: ST_TO_ADDR
// if DeltaDoctor then
1473: LD_EXP 30
1477: IFFALSE 1494
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1479: LD_EXP 30
1483: PPUSH
1484: LD_INT 13
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_STRING 12a_others
1501: PPUSH
1502: CALL_OW 31
1506: ST_TO_ADDR
// if tmp then
1507: LD_VAR 0 4
1511: IFFALSE 1545
// for i in tmp do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1543
// PlaceUnitArea ( i , alliance_start , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 13
1533: PPUSH
1534: LD_INT 0
1536: PPUSH
1537: CALL_OW 49
1541: GO 1523
1543: POP
1544: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1545: LD_INT 3
1547: PPUSH
1548: LD_INT 3
1550: PPUSH
1551: LD_INT 3
1553: PPUSH
1554: LD_INT 12
1556: PPUSH
1557: LD_INT 100
1559: PPUSH
1560: CALL 21089 0 5
// veh := CreateVehicle ;
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: CALL_OW 45
1573: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1574: LD_VAR 0 2
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1586: LD_VAR 0 2
1590: PPUSH
1591: LD_INT 60
1593: PPUSH
1594: LD_INT 6
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1604: LD_VAR 0 2
1608: PPUSH
1609: LD_INT 4
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1619: LD_STRING 11_artifact_captured
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 30
1629: IFFALSE 1705
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1631: LD_INT 3
1633: PPUSH
1634: LD_INT 3
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 12
1642: PPUSH
1643: LD_INT 100
1645: PPUSH
1646: CALL 21089 0 5
// veh := CreateVehicle ;
1650: LD_ADDR_VAR 0 2
1654: PUSH
1655: CALL_OW 45
1659: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1672: LD_VAR 0 2
1676: PPUSH
1677: LD_INT 75
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1690: LD_VAR 0 2
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: LD_INT 50
1700: PPUSH
1701: CALL_OW 290
// end ; end ;
1705: LD_VAR 0 1
1709: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// uc_side := 6 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 6
1723: ST_TO_ADDR
// uc_nation := 3 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1736: LD_ADDR_EXP 31
1740: PUSH
1741: LD_STRING Gossudarov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1749: LD_ADDR_EXP 32
1753: PUSH
1754: LD_STRING Kirilenkova
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1762: LD_ADDR_EXP 33
1766: PUSH
1767: LD_STRING Titov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1775: LD_ADDR_EXP 38
1779: PUSH
1780: LD_STRING Oblukov
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1788: LD_ADDR_EXP 35
1792: PUSH
1793: LD_STRING Dolgov
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1801: LD_ADDR_EXP 36
1805: PUSH
1806: LD_STRING Petrosyan
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1814: LD_ADDR_EXP 37
1818: PUSH
1819: LD_STRING Scholtze
1821: PPUSH
1822: CALL_OW 25
1826: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1827: LD_ADDR_EXP 39
1831: PUSH
1832: LD_STRING Kapitsova
1834: PPUSH
1835: CALL_OW 25
1839: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1840: LD_ADDR_VAR 0 2
1844: PUSH
1845: LD_EXP 31
1849: PUSH
1850: LD_EXP 32
1854: PUSH
1855: LD_EXP 33
1859: PUSH
1860: LD_EXP 38
1864: PUSH
1865: LD_EXP 35
1869: PUSH
1870: LD_EXP 36
1874: PUSH
1875: LD_EXP 37
1879: PUSH
1880: LD_EXP 39
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1895: LD_INT 1
1897: PPUSH
1898: LD_INT 4
1900: PPUSH
1901: LD_INT 8
1903: PPUSH
1904: CALL_OW 380
// un := CreateHuman ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: CALL_OW 44
1917: ST_TO_ADDR
// tmp := tmp ^ un ;
1918: LD_ADDR_VAR 0 2
1922: PUSH
1923: LD_VAR 0 2
1927: PUSH
1928: LD_VAR 0 4
1932: ADD
1933: ST_TO_ADDR
// for i in tmp do
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: LD_VAR 0 2
1943: PUSH
1944: FOR_IN
1945: IFFALSE 1964
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1947: LD_VAR 0 3
1951: PPUSH
1952: LD_INT 14
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 49
1962: GO 1944
1964: POP
1965: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1966: LD_VAR 0 2
1970: PPUSH
1971: LD_EXP 3
1975: PPUSH
1976: CALL_OW 250
1980: PPUSH
1981: LD_EXP 3
1985: PPUSH
1986: CALL_OW 251
1990: PPUSH
1991: CALL_OW 111
// end ;
1995: LD_VAR 0 1
1999: RET
// export function PrepareBelkov ; begin
2000: LD_INT 0
2002: PPUSH
// uc_side := 4 ;
2003: LD_ADDR_OWVAR 20
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// uc_nation := 3 ;
2011: LD_ADDR_OWVAR 21
2015: PUSH
2016: LD_INT 3
2018: ST_TO_ADDR
// InitHc ;
2019: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2023: LD_ADDR_EXP 46
2027: PUSH
2028: LD_STRING Belkov
2030: PPUSH
2031: CALL_OW 25
2035: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2036: LD_EXP 46
2040: PPUSH
2041: LD_INT 14
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// end ;
2051: LD_VAR 0 1
2055: RET
// export function PrepareGnyevko ; begin
2056: LD_INT 0
2058: PPUSH
// uc_side := 4 ;
2059: LD_ADDR_OWVAR 20
2063: PUSH
2064: LD_INT 4
2066: ST_TO_ADDR
// uc_nation := 3 ;
2067: LD_ADDR_OWVAR 21
2071: PUSH
2072: LD_INT 3
2074: ST_TO_ADDR
// InitHc ;
2075: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2079: LD_ADDR_EXP 47
2083: PUSH
2084: LD_STRING Gnyevko
2086: PPUSH
2087: CALL_OW 25
2091: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2092: LD_EXP 47
2096: PPUSH
2097: LD_INT 14
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// end ;
2107: LD_VAR 0 1
2111: RET
// export function PrepareBurlak ; var i , tmp ; begin
2112: LD_INT 0
2114: PPUSH
2115: PPUSH
2116: PPUSH
// uc_side := 4 ;
2117: LD_ADDR_OWVAR 20
2121: PUSH
2122: LD_INT 4
2124: ST_TO_ADDR
// uc_nation := 3 ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2133: LD_INT 35
2135: PPUSH
2136: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2140: LD_INT 92
2142: PUSH
2143: LD_INT 123
2145: PUSH
2146: LD_INT 3
2148: PUSH
2149: LD_INT 3
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: NOT
2163: IFFALSE 2133
// InitHc ;
2165: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2169: LD_ADDR_EXP 45
2173: PUSH
2174: LD_STRING Burlak
2176: PPUSH
2177: CALL_OW 25
2181: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2182: LD_INT 24
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 22
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 1
2207: PPUSH
2208: LD_INT 45
2210: PUSH
2211: LD_INT 44
2213: PUSH
2214: LD_INT 43
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 21089 0 5
// Masha := CreateVehicle ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: CALL_OW 45
2244: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2245: LD_EXP 48
2249: PUSH
2250: LD_EXP 45
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: LD_INT 499
2261: PPUSH
2262: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2266: LD_EXP 48
2270: PPUSH
2271: LD_INT 3
2273: PPUSH
2274: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 1
2285: PPUSH
2286: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2290: LD_EXP 48
2294: PPUSH
2295: LD_INT 18
2297: PPUSH
2298: LD_INT 0
2300: PPUSH
2301: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2305: LD_EXP 45
2309: PPUSH
2310: LD_INT 125
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 0
2318: PPUSH
2319: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2323: LD_EXP 45
2327: PPUSH
2328: LD_EXP 48
2332: PPUSH
2333: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2337: LD_INT 10
2339: PPUSH
2340: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2344: LD_EXP 48
2348: PPUSH
2349: LD_INT 110
2351: PPUSH
2352: LD_INT 10
2354: PPUSH
2355: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2359: LD_ADDR_EXP 41
2363: PUSH
2364: LD_STRING Petrovova
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2372: LD_ADDR_EXP 43
2376: PUSH
2377: LD_STRING Kuzmov
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2385: LD_ADDR_EXP 42
2389: PUSH
2390: LD_STRING Kovalyuk
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2398: LD_ADDR_EXP 40
2402: PUSH
2403: LD_STRING Lipshchin
2405: PPUSH
2406: CALL_OW 25
2410: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2411: LD_ADDR_EXP 44
2415: PUSH
2416: LD_STRING Karamazov
2418: PPUSH
2419: CALL_OW 25
2423: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2424: LD_ADDR_VAR 0 3
2428: PUSH
2429: LD_EXP 41
2433: PUSH
2434: LD_EXP 43
2438: PUSH
2439: LD_EXP 42
2443: PUSH
2444: LD_EXP 40
2448: PUSH
2449: LD_EXP 44
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: ST_TO_ADDR
// for i in tmp do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2511
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2474: LD_VAR 0 2
2478: PPUSH
2479: LD_INT 399
2481: PPUSH
2482: LD_INT 799
2484: PPUSH
2485: CALL_OW 12
2489: PPUSH
2490: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: LD_INT 19
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 49
// end ;
2509: GO 2471
2511: POP
2512: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_INT 116
2520: PPUSH
2521: LD_INT 8
2523: PPUSH
2524: CALL_OW 111
// AddComHold ( tmp ) ;
2528: LD_VAR 0 3
2532: PPUSH
2533: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2537: LD_ADDR_VAR 0 2
2541: PUSH
2542: LD_VAR 0 3
2546: PPUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2603
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 20
2572: PPUSH
2573: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2577: LD_VAR 0 2
2581: PPUSH
2582: LD_INT 147
2584: PPUSH
2585: LD_INT 45
2587: PPUSH
2588: CALL_OW 178
// AddComCrawl ( i ) ;
2592: LD_VAR 0 2
2596: PPUSH
2597: CALL_OW 197
// end ;
2601: GO 2562
2603: POP
2604: POP
// repeat wait ( 0 0$1 ) ;
2605: LD_INT 35
2607: PPUSH
2608: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2612: LD_EXP 48
2616: PPUSH
2617: LD_INT 110
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 307
2627: PUSH
2628: LD_EXP 48
2632: PPUSH
2633: CALL_OW 305
2637: NOT
2638: OR
2639: IFFALSE 2605
// ComStop ( Burlak ) ;
2641: LD_EXP 45
2645: PPUSH
2646: CALL_OW 141
// AddComHold ( Burlak ) ;
2650: LD_EXP 45
2654: PPUSH
2655: CALL_OW 200
// end ; end_of_file
2659: LD_VAR 0 1
2663: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2664: LD_INT 0
2666: PPUSH
2667: PPUSH
2668: PPUSH
2669: PPUSH
// uc_side := 3 ;
2670: LD_ADDR_OWVAR 20
2674: PUSH
2675: LD_INT 3
2677: ST_TO_ADDR
// uc_nation := 3 ;
2678: LD_ADDR_OWVAR 21
2682: PUSH
2683: LD_INT 3
2685: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2686: LD_ADDR_EXP 49
2690: PUSH
2691: LD_INT 47
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: LD_INT 7
2702: PUSH
2703: LD_INT 8
2705: PUSH
2706: LD_INT 9
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_OWVAR 67
2718: ARRAY
2719: PPUSH
2720: LD_INT 10000
2722: PUSH
2723: LD_INT 3000
2725: PUSH
2726: LD_INT 300
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PPUSH
2734: LD_INT 9
2736: PUSH
2737: LD_INT 5
2739: PUSH
2740: LD_INT 6
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL 24498 0 6
2756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2757: LD_ADDR_EXP 58
2761: PUSH
2762: LD_EXP 58
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_EXP 49
2774: PPUSH
2775: CALL_OW 1
2779: ST_TO_ADDR
// tmp := [ ] ;
2780: LD_ADDR_VAR 0 4
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// for i = 1 to 4 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 4
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2894
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2803: LD_INT 22
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_INT 3
2811: PPUSH
2812: LD_INT 43
2814: PUSH
2815: LD_INT 45
2817: PUSH
2818: LD_INT 45
2820: PUSH
2821: LD_INT 44
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: LD_VAR 0 2
2834: PUSH
2835: LD_INT 4
2837: MOD
2838: PUSH
2839: LD_INT 1
2841: PLUS
2842: ARRAY
2843: PPUSH
2844: LD_INT 100
2846: PPUSH
2847: CALL 21089 0 5
// veh := CreateVehicle ;
2851: LD_ADDR_VAR 0 3
2855: PUSH
2856: CALL_OW 45
2860: ST_TO_ADDR
// tmp := tmp ^ veh ;
2861: LD_ADDR_VAR 0 4
2865: PUSH
2866: LD_VAR 0 4
2870: PUSH
2871: LD_VAR 0 3
2875: ADD
2876: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2877: LD_VAR 0 3
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 49
// end ;
2892: GO 2800
2894: POP
2895: POP
// russian_guard := tmp ;
2896: LD_ADDR_EXP 50
2900: PUSH
2901: LD_VAR 0 4
2905: ST_TO_ADDR
// end ;
2906: LD_VAR 0 1
2910: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2911: LD_INT 47
2913: PPUSH
2914: CALL_OW 302
2918: PUSH
2919: LD_EXP 6
2923: AND
2924: IFFALSE 3526
2926: GO 2928
2928: DISABLE
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
// begin enable ;
2937: ENABLE
// base := 2 ;
2938: LD_ADDR_VAR 0 2
2942: PUSH
2943: LD_INT 2
2945: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: LD_INT 0
2956: PUSH
2957: LD_INT 0
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: LD_INT 0
2968: PUSH
2969: LD_INT 0
2971: PUSH
2972: LD_INT 0
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 1
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 45
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 21
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 3
3024: PUSH
3025: LD_INT 45
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 22
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 3
3042: PUSH
3043: LD_INT 45
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 23
3054: PUSH
3055: LD_INT 1
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 46
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3076: LD_ADDR_VAR 0 1
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_OWVAR 67
3090: PUSH
3091: LD_OWVAR 1
3095: PUSH
3096: LD_INT 21000
3098: DIV
3099: PLUS
3100: PUSH
3101: FOR_TO
3102: IFFALSE 3190
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3104: LD_ADDR_VAR 0 3
3108: PUSH
3109: LD_VAR 0 3
3113: PPUSH
3114: LD_VAR 0 3
3118: PUSH
3119: LD_INT 1
3121: PLUS
3122: PPUSH
3123: LD_INT 23
3125: PUSH
3126: LD_INT 24
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 1
3135: PPUSH
3136: LD_INT 2
3138: PPUSH
3139: CALL_OW 12
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: LD_INT 46
3153: PUSH
3154: LD_INT 47
3156: PUSH
3157: LD_INT 45
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_INT 3
3170: PPUSH
3171: CALL_OW 12
3175: ARRAY
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 2
3187: ST_TO_ADDR
3188: GO 3101
3190: POP
3191: POP
// MC_InsertProduceList ( base , tmp ) ;
3192: LD_VAR 0 2
3196: PPUSH
3197: LD_VAR 0 3
3201: PPUSH
3202: CALL 80935 0 2
// repeat wait ( 0 0$1 ) ;
3206: LD_INT 35
3208: PPUSH
3209: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3213: LD_EXP 77
3217: PUSH
3218: LD_VAR 0 2
3222: ARRAY
3223: PUSH
3224: LD_INT 6
3226: GREATER
3227: IFFALSE 3206
// wait ( 0 0$20 ) ;
3229: LD_INT 700
3231: PPUSH
3232: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: LD_INT 71
3243: PUSH
3244: LD_INT 19
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 91
3253: PUSH
3254: LD_INT 67
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 52
3263: PUSH
3264: LD_INT 44
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 68
3273: PUSH
3274: LD_INT 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3287: LD_ADDR_VAR 0 6
3291: PUSH
3292: LD_EXP 77
3296: PUSH
3297: LD_VAR 0 2
3301: ARRAY
3302: PUSH
3303: LD_EXP 77
3307: PUSH
3308: LD_VAR 0 2
3312: ARRAY
3313: PPUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 34
3319: PUSH
3320: LD_INT 51
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 34
3329: PUSH
3330: LD_INT 52
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: PPUSH
3342: CALL_OW 72
3346: DIFF
3347: ST_TO_ADDR
// if not attackers then
3348: LD_VAR 0 6
3352: NOT
3353: IFFALSE 3357
// exit ;
3355: GO 3526
// ru_attackers := attackers ;
3357: LD_ADDR_EXP 51
3361: PUSH
3362: LD_VAR 0 6
3366: ST_TO_ADDR
// for i = 1 to attackers do
3367: LD_ADDR_VAR 0 1
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 6
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3460
// begin case i mod 3 of 0 :
3385: LD_VAR 0 1
3389: PUSH
3390: LD_INT 3
3392: MOD
3393: PUSH
3394: LD_INT 0
3396: DOUBLE
3397: EQUAL
3398: IFTRUE 3402
3400: GO 3405
3402: POP
// ; 1 :
3403: GO 3458
3405: LD_INT 1
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 32
3421: PPUSH
3422: LD_INT 49
3424: PPUSH
3425: CALL_OW 114
3429: GO 3458
3431: LD_INT 2
3433: DOUBLE
3434: EQUAL
3435: IFTRUE 3439
3437: GO 3457
3439: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_INT 117
3447: PPUSH
3448: LD_INT 107
3450: PPUSH
3451: CALL_OW 114
3455: GO 3458
3457: POP
// end ;
3458: GO 3382
3460: POP
3461: POP
// repeat wait ( 0 0$1 ) ;
3462: LD_INT 35
3464: PPUSH
3465: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3469: LD_VAR 0 6
3473: PPUSH
3474: LD_INT 60
3476: PUSH
3477: EMPTY
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: NOT
3485: IFFALSE 3462
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3487: LD_VAR 0 2
3491: PPUSH
3492: LD_VAR 0 6
3496: PPUSH
3497: LD_VAR 0 5
3501: PPUSH
3502: LD_VAR 0 4
3506: PPUSH
3507: CALL 81120 0 4
// if not first_attack then
3511: LD_EXP 7
3515: NOT
3516: IFFALSE 3526
// first_attack := true ;
3518: LD_ADDR_EXP 7
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// end ; end_of_file
3526: PPOPN 6
3528: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3529: LD_INT 0
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// uc_side := 2 ;
3538: LD_ADDR_OWVAR 20
3542: PUSH
3543: LD_INT 2
3545: ST_TO_ADDR
// uc_nation := 2 ;
3546: LD_ADDR_OWVAR 21
3550: PUSH
3551: LD_INT 2
3553: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3554: LD_ADDR_EXP 54
3558: PUSH
3559: LD_STRING Abdul
3561: PPUSH
3562: CALL_OW 25
3566: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3567: LD_EXP 54
3571: PPUSH
3572: LD_INT 11
3574: PPUSH
3575: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3579: LD_EXP 54
3583: PPUSH
3584: LD_INT 1
3586: PPUSH
3587: CALL_OW 52
// vc_chassis := 31 ;
3591: LD_ADDR_OWVAR 37
3595: PUSH
3596: LD_INT 31
3598: ST_TO_ADDR
// vc_control := control_rider ;
3599: LD_ADDR_OWVAR 38
3603: PUSH
3604: LD_INT 4
3606: ST_TO_ADDR
// mastodont := CreateVehicle ;
3607: LD_ADDR_EXP 55
3611: PUSH
3612: CALL_OW 45
3616: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3617: LD_EXP 55
3621: PPUSH
3622: LD_INT 153
3624: PPUSH
3625: LD_INT 71
3627: PPUSH
3628: LD_INT 0
3630: PPUSH
3631: CALL_OW 48
// InitVc ;
3635: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3639: LD_ADDR_EXP 52
3643: PUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_STRING 
3652: PPUSH
3653: LD_INT 7
3655: PUSH
3656: LD_INT 8
3658: PUSH
3659: LD_INT 9
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_OWVAR 67
3671: ARRAY
3672: PPUSH
3673: LD_INT 5000
3675: PUSH
3676: LD_INT 1000
3678: PUSH
3679: LD_INT 300
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: LD_INT 22
3689: PUSH
3690: LD_INT 5
3692: PUSH
3693: LD_INT 6
3695: PUSH
3696: LD_INT 9
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: PPUSH
3705: CALL 24498 0 6
3709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3710: LD_ADDR_EXP 58
3714: PUSH
3715: LD_EXP 58
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_EXP 52
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// tmp := [ ] ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3740: LD_ADDR_OWVAR 37
3744: PUSH
3745: LD_INT 14
3747: ST_TO_ADDR
// vc_engine := engine_siberite ;
3748: LD_ADDR_OWVAR 39
3752: PUSH
3753: LD_INT 3
3755: ST_TO_ADDR
// vc_control := control_manual ;
3756: LD_ADDR_OWVAR 38
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3764: LD_ADDR_OWVAR 40
3768: PUSH
3769: LD_INT 31
3771: ST_TO_ADDR
// for i = 1 to 3 do
3772: LD_ADDR_VAR 0 2
3776: PUSH
3777: DOUBLE
3778: LD_INT 1
3780: DEC
3781: ST_TO_ADDR
3782: LD_INT 3
3784: PUSH
3785: FOR_TO
3786: IFFALSE 4030
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3788: LD_ADDR_VAR 0 5
3792: PUSH
3793: LD_INT 153
3795: PUSH
3796: LD_INT 71
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 155
3805: PUSH
3806: LD_INT 81
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: MOD
3825: PUSH
3826: LD_INT 1
3828: PLUS
3829: ARRAY
3830: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3831: LD_INT 0
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: LD_INT 7
3839: PUSH
3840: LD_INT 8
3842: PUSH
3843: LD_INT 9
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_OWVAR 67
3855: ARRAY
3856: PPUSH
3857: CALL_OW 380
// un := CreateVehicle ;
3861: LD_ADDR_VAR 0 6
3865: PUSH
3866: CALL_OW 45
3870: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3871: LD_VAR 0 6
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_INT 5
3881: PPUSH
3882: CALL_OW 12
3886: PPUSH
3887: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3891: LD_VAR 0 6
3895: PPUSH
3896: LD_VAR 0 5
3900: PUSH
3901: LD_INT 1
3903: ARRAY
3904: PPUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_INT 2
3912: ARRAY
3913: PPUSH
3914: LD_INT 6
3916: PPUSH
3917: LD_INT 0
3919: PPUSH
3920: CALL_OW 50
// un2 := CreateHuman ;
3924: LD_ADDR_VAR 0 7
3928: PUSH
3929: CALL_OW 44
3933: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3934: LD_VAR 0 7
3938: PPUSH
3939: LD_VAR 0 6
3943: PPUSH
3944: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3948: LD_ADDR_EXP 58
3952: PUSH
3953: LD_EXP 58
3957: PPUSH
3958: LD_INT 1
3960: PUSH
3961: LD_EXP 58
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: LD_VAR 0 6
3982: PPUSH
3983: CALL 21211 0 3
3987: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3988: LD_ADDR_EXP 58
3992: PUSH
3993: LD_EXP 58
3997: PPUSH
3998: LD_INT 1
4000: PUSH
4001: LD_EXP 58
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 1
4012: PLUS
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: LD_VAR 0 7
4022: PPUSH
4023: CALL 21211 0 3
4027: ST_TO_ADDR
// end ;
4028: GO 3785
4030: POP
4031: POP
// for i = 1 to 5 do
4032: LD_ADDR_VAR 0 2
4036: PUSH
4037: DOUBLE
4038: LD_INT 1
4040: DEC
4041: ST_TO_ADDR
4042: LD_INT 5
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4139
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4048: LD_INT 14
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_INT 25
4059: PUSH
4060: LD_INT 28
4062: PUSH
4063: LD_INT 28
4065: PUSH
4066: LD_INT 26
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: PUSH
4075: LD_VAR 0 2
4079: PUSH
4080: LD_INT 4
4082: MOD
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: ARRAY
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL 21089 0 5
// veh := CreateVehicle ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// tmp := tmp ^ veh ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_VAR 0 3
4120: ADD
4121: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// end ;
4137: GO 4045
4139: POP
4140: POP
// arabian_guard := tmp ;
4141: LD_ADDR_EXP 53
4145: PUSH
4146: LD_VAR 0 4
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4156: LD_INT 22
4158: PUSH
4159: LD_INT 7
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 91
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 12
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PPUSH
4184: CALL_OW 69
4188: PUSH
4189: LD_EXP 55
4193: PPUSH
4194: CALL_OW 256
4198: PUSH
4199: LD_INT 990
4201: LESS
4202: OR
4203: PUSH
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 256
4213: PUSH
4214: LD_INT 990
4216: LESS
4217: OR
4218: IFFALSE 4361
4220: GO 4222
4222: DISABLE
// begin if IsInUnit ( Abdul ) then
4223: LD_EXP 54
4227: PPUSH
4228: CALL_OW 310
4232: IFFALSE 4243
// ComExitBuilding ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 122
// if Mastodont then
4243: LD_EXP 55
4247: IFFALSE 4264
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4249: LD_EXP 55
4253: PPUSH
4254: LD_INT 205
4256: PPUSH
4257: LD_INT 132
4259: PPUSH
4260: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4264: LD_EXP 54
4268: PPUSH
4269: LD_INT 205
4271: PPUSH
4272: LD_INT 132
4274: PPUSH
4275: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4279: LD_INT 35
4281: PPUSH
4282: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4286: LD_EXP 54
4290: PPUSH
4291: LD_INT 21
4293: PPUSH
4294: CALL_OW 308
4298: IFFALSE 4279
// RemoveUnit ( Abdul ) ;
4300: LD_EXP 54
4304: PPUSH
4305: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4309: LD_INT 35
4311: PPUSH
4312: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4316: LD_EXP 55
4320: PPUSH
4321: LD_INT 21
4323: PPUSH
4324: CALL_OW 308
4328: PUSH
4329: LD_EXP 55
4333: PPUSH
4334: CALL_OW 301
4338: OR
4339: IFFALSE 4309
// if IsOk ( Mastodont ) then
4341: LD_EXP 55
4345: PPUSH
4346: CALL_OW 302
4350: IFFALSE 4361
// RemoveUnit ( Mastodont ) ;
4352: LD_EXP 55
4356: PPUSH
4357: CALL_OW 64
// end ;
4361: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4362: LD_EXP 54
4366: PPUSH
4367: CALL_OW 301
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 2
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 25
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 4
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 8
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 16
4454: PUSH
4455: LD_INT 19
4457: PUSH
4458: LD_INT 22
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: LESS
4472: OR
4473: IFFALSE 5146
4475: GO 4477
4477: DISABLE
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
4485: PPUSH
// begin MC_Kill ( 1 ) ;
4486: LD_INT 1
4488: PPUSH
4489: CALL 57371 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 2
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 25
4533: PUSH
4534: LD_INT 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 25
4543: PUSH
4544: LD_INT 4
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 25
4553: PUSH
4554: LD_INT 8
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PPUSH
4573: CALL_OW 69
4577: ST_TO_ADDR
// for i in tmp do
4578: LD_ADDR_VAR 0 5
4582: PUSH
4583: LD_VAR 0 2
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4605
// SetTag ( i , 10 ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: LD_INT 10
4598: PPUSH
4599: CALL_OW 109
4603: GO 4588
4605: POP
4606: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4607: LD_ADDR_VAR 0 3
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 2
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 21
4624: PUSH
4625: LD_INT 1
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: PUSH
4641: LD_VAR 0 2
4645: DIFF
4646: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 2
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 24
4674: PUSH
4675: LD_INT 300
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4692: LD_ADDR_VAR 0 4
4696: PUSH
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 33
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 58
4714: PUSH
4715: EMPTY
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 72
4726: ST_TO_ADDR
// for i in tmp do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: LD_VAR 0 2
4736: PUSH
4737: FOR_IN
4738: IFFALSE 4922
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4740: LD_VAR 0 5
4744: PUSH
4745: LD_INT 55
4747: PUSH
4748: EMPTY
4749: LIST
4750: PPUSH
4751: CALL_OW 69
4755: IN
4756: IFFALSE 4775
// begin AddComMoveXY ( i , 209 , 132 ) ;
4758: LD_VAR 0 5
4762: PPUSH
4763: LD_INT 209
4765: PPUSH
4766: LD_INT 132
4768: PPUSH
4769: CALL_OW 171
// continue ;
4773: GO 4737
// end ; if IsInUnit ( i ) then
4775: LD_VAR 0 5
4779: PPUSH
4780: CALL_OW 310
4784: IFFALSE 4802
// begin ComExitBuilding ( i ) ;
4786: LD_VAR 0 5
4790: PPUSH
4791: CALL_OW 122
// wait ( 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 67
// end ; if tmp_empty then
4802: LD_VAR 0 4
4806: IFFALSE 4905
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4808: LD_VAR 0 5
4812: PPUSH
4813: LD_VAR 0 4
4817: PPUSH
4818: LD_VAR 0 5
4822: PPUSH
4823: CALL_OW 74
4827: PPUSH
4828: CALL_OW 296
4832: PUSH
4833: LD_INT 25
4835: LESS
4836: IFFALSE 4905
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_VAR 0 4
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 74
4857: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_VAR 0 6
4867: PPUSH
4868: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4872: LD_VAR 0 5
4876: PPUSH
4877: LD_INT 209
4879: PPUSH
4880: LD_INT 132
4882: PPUSH
4883: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4887: LD_ADDR_VAR 0 4
4891: PUSH
4892: LD_VAR 0 4
4896: PUSH
4897: LD_VAR 0 6
4901: DIFF
4902: ST_TO_ADDR
// continue ;
4903: GO 4737
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4905: LD_VAR 0 5
4909: PPUSH
4910: LD_INT 201
4912: PPUSH
4913: LD_INT 132
4915: PPUSH
4916: CALL_OW 171
// end ;
4920: GO 4737
4922: POP
4923: POP
// for i in tmp_ape do
4924: LD_ADDR_VAR 0 5
4928: PUSH
4929: LD_VAR 0 3
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4974
// begin if IsInUnit ( i ) then
4937: LD_VAR 0 5
4941: PPUSH
4942: CALL_OW 310
4946: IFFALSE 4957
// ComExitBuilding ( i ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_INT 201
4964: PPUSH
4965: LD_INT 132
4967: PPUSH
4968: CALL_OW 171
// end ;
4972: GO 4934
4974: POP
4975: POP
// repeat wait ( 0 0$1 ) ;
4976: LD_INT 35
4978: PPUSH
4979: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4983: LD_ADDR_VAR 0 5
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_VAR 0 3
4997: UNION
4998: PUSH
4999: LD_VAR 0 1
5003: UNION
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5037
// if not HasTask ( i ) then
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 314
5017: NOT
5018: IFFALSE 5035
// ComMoveXY ( i , 201 , 132 ) ;
5020: LD_VAR 0 5
5024: PPUSH
5025: LD_INT 201
5027: PPUSH
5028: LD_INT 132
5030: PPUSH
5031: CALL_OW 111
5035: GO 5005
5037: POP
5038: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5039: LD_INT 21
5041: PPUSH
5042: LD_INT 22
5044: PUSH
5045: LD_INT 2
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 70
5056: IFFALSE 5097
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5058: LD_ADDR_VAR 0 5
5062: PUSH
5063: LD_INT 21
5065: PPUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: PUSH
5081: FOR_IN
5082: IFFALSE 5095
// RemoveUnit ( i ) ;
5084: LD_VAR 0 5
5088: PPUSH
5089: CALL_OW 64
5093: GO 5081
5095: POP
5096: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5097: LD_INT 22
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 2
5109: PUSH
5110: LD_INT 21
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: LD_INT 2
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: NOT
5144: IFFALSE 4976
// end ;
5146: PPOPN 6
5148: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5149: LD_EXP 9
5153: PUSH
5154: LD_INT 92
5156: PPUSH
5157: LD_INT 40
5159: PPUSH
5160: CALL_OW 428
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 30
5172: EQUAL
5173: AND
5174: IFFALSE 5370
5176: GO 5178
5178: DISABLE
5179: LD_INT 0
5181: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: LD_EXP 58
5191: PUSH
5192: LD_INT 1
5194: ARRAY
5195: PPUSH
5196: LD_INT 25
5198: PUSH
5199: LD_INT 4
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// if not sci then
5211: LD_VAR 0 1
5215: NOT
5216: IFFALSE 5220
// exit ;
5218: GO 5370
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5220: LD_ADDR_EXP 58
5224: PUSH
5225: LD_EXP 58
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_EXP 58
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: DIFF
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5257: LD_VAR 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: PPUSH
5266: CALL_OW 310
5270: IFFALSE 5285
// ComExitBuilding ( sci [ 1 ] ) ;
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 105
5290: PPUSH
5291: LD_INT 14
5293: PPUSH
5294: LD_INT 20
5296: PPUSH
5297: CALL 22107 0 4
5301: PUSH
5302: LD_INT 4
5304: ARRAY
5305: PUSH
5306: LD_INT 10
5308: LESS
5309: IFFALSE 5332
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 105
5322: PPUSH
5323: LD_INT 14
5325: PPUSH
5326: CALL_OW 171
5330: GO 5351
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 118
5343: PPUSH
5344: LD_INT 77
5346: PPUSH
5347: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 1
5358: ARRAY
5359: PPUSH
5360: LD_INT 92
5362: PPUSH
5363: LD_INT 40
5365: PPUSH
5366: CALL_OW 218
// end ;
5370: PPOPN 1
5372: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5373: LD_INT 1
5375: PPUSH
5376: CALL_OW 302
5380: PUSH
5381: LD_EXP 9
5385: AND
5386: IFFALSE 5845
5388: GO 5390
5390: DISABLE
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
5395: PPUSH
5396: PPUSH
5397: PPUSH
5398: PPUSH
// begin enable ;
5399: ENABLE
// base := 1 ;
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5408: LD_ADDR_VAR 0 4
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: LD_INT 0
5418: PUSH
5419: LD_INT 0
5421: PUSH
5422: LD_INT 0
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: LD_INT 0
5430: PUSH
5431: LD_INT 0
5433: PUSH
5434: LD_INT 0
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: LD_INT 14
5462: PUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 2
5468: PUSH
5469: LD_INT 26
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_INT 14
5480: PUSH
5481: LD_INT 1
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 28
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 13
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: LD_INT 2
5504: PUSH
5505: LD_INT 29
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: LIST
5518: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: DOUBLE
5525: LD_INT 1
5527: DEC
5528: ST_TO_ADDR
5529: LD_OWVAR 67
5533: PUSH
5534: LD_OWVAR 1
5538: PUSH
5539: LD_INT 21000
5541: DIV
5542: PLUS
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5637
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5547: LD_ADDR_VAR 0 3
5551: PUSH
5552: LD_VAR 0 3
5556: PPUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_INT 1
5564: PLUS
5565: PPUSH
5566: LD_INT 13
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 2
5581: PPUSH
5582: CALL_OW 12
5586: ARRAY
5587: PUSH
5588: LD_INT 1
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 28
5596: PUSH
5597: LD_INT 29
5599: PUSH
5600: LD_INT 25
5602: PUSH
5603: LD_INT 26
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 4
5617: PPUSH
5618: CALL_OW 12
5622: ARRAY
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 2
5634: ST_TO_ADDR
5635: GO 5544
5637: POP
5638: POP
// MC_InsertProduceList ( base , tmp ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL 80935 0 2
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5660: LD_EXP 77
5664: PUSH
5665: LD_VAR 0 2
5669: ARRAY
5670: PUSH
5671: LD_INT 6
5673: GREATER
5674: IFFALSE 5653
// wait ( 0 0$20 ) ;
5676: LD_INT 700
5678: PPUSH
5679: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5683: LD_ADDR_VAR 0 5
5687: PUSH
5688: LD_INT 124
5690: PUSH
5691: LD_INT 85
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 90
5700: PUSH
5701: LD_INT 61
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 69
5710: PUSH
5711: LD_INT 48
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 68
5720: PUSH
5721: LD_INT 48
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5734: LD_ADDR_VAR 0 6
5738: PUSH
5739: LD_EXP 77
5743: PUSH
5744: LD_VAR 0 2
5748: ARRAY
5749: PUSH
5750: LD_EXP 77
5754: PUSH
5755: LD_VAR 0 2
5759: ARRAY
5760: PPUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: DIFF
5776: ST_TO_ADDR
// if not attackers then
5777: LD_VAR 0 6
5781: NOT
5782: IFFALSE 5786
// exit ;
5784: GO 5845
// ar_attackers := attackers ;
5786: LD_ADDR_EXP 10
5790: PUSH
5791: LD_VAR 0 6
5795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5803: LD_VAR 0 6
5807: PPUSH
5808: LD_INT 60
5810: PUSH
5811: EMPTY
5812: LIST
5813: PPUSH
5814: CALL_OW 72
5818: NOT
5819: IFFALSE 5796
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_VAR 0 5
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: CALL 81120 0 4
// end ;
5845: PPOPN 6
5847: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5848: LD_INT 1
5850: PPUSH
5851: CALL_OW 302
5855: PUSH
5856: LD_EXP 9
5860: AND
5861: PUSH
5862: LD_EXP 48
5866: PPUSH
5867: LD_INT 22
5869: PPUSH
5870: CALL_OW 308
5874: AND
5875: PUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 81283 0 1
5883: PUSH
5884: LD_INT 0
5886: EQUAL
5887: AND
5888: PUSH
5889: LD_EXP 10
5893: NOT
5894: AND
5895: IFFALSE 6359
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
// begin base := 1 ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5917: LD_ADDR_VAR 0 4
5921: PUSH
5922: LD_INT 0
5924: PUSH
5925: LD_INT 0
5927: PUSH
5928: LD_INT 0
5930: PUSH
5931: LD_INT 0
5933: PUSH
5934: LD_INT 0
5936: PUSH
5937: LD_INT 0
5939: PUSH
5940: LD_INT 0
5942: PUSH
5943: LD_INT 0
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 28
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 13
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 27
5998: PUSH
5999: EMPTY
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 1
6010: PUSH
6011: LD_INT 2
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 11
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 2
6031: PUSH
6032: LD_INT 24
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: LD_INT 11
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 24
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_VAR 0 3
6075: PPUSH
6076: CALL 80935 0 2
// repeat wait ( 0 0$1 ) ;
6080: LD_INT 35
6082: PPUSH
6083: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6087: LD_EXP 77
6091: PUSH
6092: LD_VAR 0 2
6096: ARRAY
6097: PUSH
6098: LD_INT 6
6100: GREATEREQUAL
6101: IFFALSE 6080
// wait ( 0 0$20 ) ;
6103: LD_INT 700
6105: PPUSH
6106: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6110: LD_ADDR_VAR 0 5
6114: PUSH
6115: LD_INT 119
6117: PUSH
6118: LD_INT 9
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: EMPTY
6126: LIST
6127: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6128: LD_ADDR_VAR 0 6
6132: PUSH
6133: LD_EXP 77
6137: PUSH
6138: LD_VAR 0 2
6142: ARRAY
6143: PUSH
6144: LD_EXP 77
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 34
6157: PUSH
6158: LD_INT 32
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 72
6169: DIFF
6170: ST_TO_ADDR
// if not attackers then
6171: LD_VAR 0 6
6175: NOT
6176: IFFALSE 6180
// exit ;
6178: GO 6359
// uc_side := 2 ;
6180: LD_ADDR_OWVAR 20
6184: PUSH
6185: LD_INT 2
6187: ST_TO_ADDR
// uc_nation := 2 ;
6188: LD_ADDR_OWVAR 21
6192: PUSH
6193: LD_INT 2
6195: ST_TO_ADDR
// InitHc ;
6196: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: DOUBLE
6206: LD_INT 1
6208: DEC
6209: ST_TO_ADDR
6210: LD_INT 4
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 6
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: LD_OWVAR 67
6228: ARRAY
6229: PUSH
6230: FOR_TO
6231: IFFALSE 6308
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6233: LD_INT 0
6235: PPUSH
6236: LD_INT 15
6238: PUSH
6239: LD_INT 17
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 2
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: PPUSH
6258: LD_INT 8
6260: PPUSH
6261: CALL_OW 380
// un := CreateHuman ;
6265: LD_ADDR_VAR 0 7
6269: PUSH
6270: CALL_OW 44
6274: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6275: LD_VAR 0 7
6279: PPUSH
6280: LD_INT 23
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: CALL_OW 49
// attackers := attackers union un ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_VAR 0 6
6299: PUSH
6300: LD_VAR 0 7
6304: UNION
6305: ST_TO_ADDR
// end ;
6306: GO 6230
6308: POP
6309: POP
// repeat wait ( 0 0$1 ) ;
6310: LD_INT 35
6312: PPUSH
6313: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6317: LD_VAR 0 6
6321: PPUSH
6322: LD_INT 60
6324: PUSH
6325: EMPTY
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: NOT
6333: IFFALSE 6310
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_VAR 0 6
6344: PPUSH
6345: LD_VAR 0 5
6349: PPUSH
6350: LD_VAR 0 4
6354: PPUSH
6355: CALL 81120 0 4
// end ; end_of_file
6359: PPOPN 7
6361: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6362: LD_INT 0
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// uc_side := 1 ;
6368: LD_ADDR_OWVAR 20
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// uc_nation := 1 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// InitHc ;
6384: CALL_OW 19
// InitVc ;
6388: CALL_OW 20
// tmp := [ ] ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: DOUBLE
6405: LD_INT 1
6407: DEC
6408: ST_TO_ADDR
6409: LD_INT 5
6411: PUSH
6412: LD_INT 6
6414: PUSH
6415: LD_INT 6
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_OWVAR 67
6427: ARRAY
6428: PUSH
6429: FOR_TO
6430: IFFALSE 6567
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6432: LD_INT 2
6434: PUSH
6435: LD_INT 4
6437: PUSH
6438: LD_INT 5
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: CALL_OW 12
6456: ARRAY
6457: PPUSH
6458: LD_INT 1
6460: PUSH
6461: LD_INT 3
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_INT 2
6473: PPUSH
6474: CALL_OW 12
6478: ARRAY
6479: PPUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 9
6485: PUSH
6486: LD_INT 7
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 2
6498: PPUSH
6499: CALL_OW 12
6503: ARRAY
6504: PPUSH
6505: LD_INT 78
6507: PPUSH
6508: CALL 21089 0 5
// veh := CreateVehicle ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: CALL_OW 45
6521: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 2
6529: PPUSH
6530: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6534: LD_VAR 0 4
6538: PPUSH
6539: LD_INT 17
6541: PPUSH
6542: LD_INT 0
6544: PPUSH
6545: CALL_OW 49
// tmp := tmp ^ veh ;
6549: LD_ADDR_VAR 0 3
6553: PUSH
6554: LD_VAR 0 3
6558: PUSH
6559: LD_VAR 0 4
6563: ADD
6564: ST_TO_ADDR
// end ;
6565: GO 6429
6567: POP
6568: POP
// if not tmp then
6569: LD_VAR 0 3
6573: NOT
6574: IFFALSE 6578
// exit ;
6576: GO 6687
// if not first_powell_attack then
6578: LD_EXP 11
6582: NOT
6583: IFFALSE 6593
// first_powell_attack := true ;
6585: LD_ADDR_EXP 11
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6593: LD_INT 70
6595: PPUSH
6596: CALL_OW 67
// for i in tmp do
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 3
6609: PUSH
6610: FOR_IN
6611: IFFALSE 6678
// if IsOk ( i ) then
6613: LD_VAR 0 2
6617: PPUSH
6618: CALL_OW 302
6622: IFFALSE 6660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 81
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PPUSH
6644: LD_VAR 0 2
6648: PPUSH
6649: CALL_OW 74
6653: PPUSH
6654: CALL_OW 115
6658: GO 6676
// tmp := tmp diff i ;
6660: LD_ADDR_VAR 0 3
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 2
6674: DIFF
6675: ST_TO_ADDR
6676: GO 6610
6678: POP
6679: POP
// until not tmp ;
6680: LD_VAR 0 3
6684: NOT
6685: IFFALSE 6593
// end ; end_of_file
6687: LD_VAR 0 1
6691: RET
// export function Action ; var tmp , i , un ; begin
6692: LD_INT 0
6694: PPUSH
6695: PPUSH
6696: PPUSH
6697: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6698: LD_INT 68
6700: PPUSH
6701: LD_INT 39
6703: PPUSH
6704: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// InGameOn ;
6728: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 71
6739: PPUSH
6740: LD_INT 49
6742: PPUSH
6743: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6747: LD_INT 35
6749: PPUSH
6750: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6754: LD_INT 7
6756: PPUSH
6757: LD_INT 71
6759: PPUSH
6760: LD_INT 51
6762: PPUSH
6763: CALL_OW 293
6767: IFFALSE 6747
// DialogueOn ;
6769: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6773: LD_EXP 14
6777: PPUSH
6778: LD_STRING D1-JMM-1
6780: PPUSH
6781: CALL_OW 88
// if Joan then
6785: LD_EXP 29
6789: IFFALSE 6803
// Say ( Joan , D1-Joan-1 ) ;
6791: LD_EXP 29
6795: PPUSH
6796: LD_STRING D1-Joan-1
6798: PPUSH
6799: CALL_OW 88
// if Lisa then
6803: LD_EXP 16
6807: IFFALSE 6821
// Say ( Lisa , D1-Lisa-1 ) ;
6809: LD_EXP 16
6813: PPUSH
6814: LD_STRING D1-Lisa-1
6816: PPUSH
6817: CALL_OW 88
// if Joan or Lisa then
6821: LD_EXP 29
6825: PUSH
6826: LD_EXP 16
6830: OR
6831: IFFALSE 6845
// Say ( JMM , D1-JMM-2 ) ;
6833: LD_EXP 14
6837: PPUSH
6838: LD_STRING D1-JMM-2
6840: PPUSH
6841: CALL_OW 88
// DialogueOff ;
6845: CALL_OW 7
// InGameOff ;
6849: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6853: LD_INT 71
6855: PPUSH
6856: LD_INT 50
6858: PPUSH
6859: LD_INT 7
6861: PPUSH
6862: LD_INT 30
6864: NEG
6865: PPUSH
6866: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6870: LD_INT 71
6872: PPUSH
6873: LD_INT 50
6875: PPUSH
6876: LD_INT 7
6878: PPUSH
6879: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6883: LD_STRING M1
6885: PPUSH
6886: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6890: LD_INT 35
6892: PPUSH
6893: CALL_OW 67
// until freedom ;
6897: LD_EXP 3
6901: IFFALSE 6890
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6903: LD_INT 350
6905: PPUSH
6906: LD_INT 700
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// PrepareGossudarov ;
6918: CALL 1710 0 0
// repeat wait ( 0 0$1 ) ;
6922: LD_INT 35
6924: PPUSH
6925: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6929: LD_INT 22
6931: PUSH
6932: LD_INT 6
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 3
6941: PUSH
6942: LD_INT 24
6944: PUSH
6945: LD_INT 1000
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 69
6964: PUSH
6965: LD_INT 7
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 292
6977: OR
6978: IFFALSE 6922
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// for i in tmp do
7000: LD_ADDR_VAR 0 3
7004: PUSH
7005: LD_VAR 0 2
7009: PUSH
7010: FOR_IN
7011: IFFALSE 7027
// SetSide ( i , 7 ) ;
7013: LD_VAR 0 3
7017: PPUSH
7018: LD_INT 7
7020: PPUSH
7021: CALL_OW 235
7025: GO 7010
7027: POP
7028: POP
// DialogueOn ;
7029: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7033: LD_EXP 14
7037: PUSH
7038: LD_EXP 15
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_EXP 31
7051: PPUSH
7052: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7056: LD_EXP 31
7060: PPUSH
7061: CALL_OW 87
// if not Roth then
7065: LD_EXP 15
7069: NOT
7070: IFFALSE 7162
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7072: LD_VAR 0 2
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 24
7082: PUSH
7083: LD_INT 1000
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: IFFALSE 7112
// Say ( JMM , D2-JMM-1 ) ;
7100: LD_EXP 14
7104: PPUSH
7105: LD_STRING D2-JMM-1
7107: PPUSH
7108: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7112: LD_EXP 14
7116: PPUSH
7117: LD_STRING D2-JMM-1b
7119: PPUSH
7120: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7124: LD_EXP 31
7128: PPUSH
7129: LD_STRING D2-Gos-1
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-2
7143: PPUSH
7144: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7148: LD_EXP 31
7152: PPUSH
7153: LD_STRING D2-Gos-2
7155: PPUSH
7156: CALL_OW 88
// end else
7160: GO 7314
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7162: LD_VAR 0 2
7166: PPUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 24
7172: PUSH
7173: LD_INT 1000
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL_OW 72
7188: IFFALSE 7214
// begin Say ( Roth , D2-Roth-2 ) ;
7190: LD_EXP 15
7194: PPUSH
7195: LD_STRING D2-Roth-2
7197: PPUSH
7198: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7202: LD_EXP 14
7206: PPUSH
7207: LD_STRING D2-JMM-1a
7209: PPUSH
7210: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7214: LD_EXP 15
7218: PPUSH
7219: LD_STRING D2-Roth-2a
7221: PPUSH
7222: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7226: LD_EXP 15
7230: PPUSH
7231: LD_STRING D2-Roth-2b
7233: PPUSH
7234: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7238: LD_EXP 14
7242: PPUSH
7243: LD_STRING D2-JMM-3
7245: PPUSH
7246: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 3
7257: PUSH
7258: LD_INT 24
7260: PUSH
7261: LD_INT 1000
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 72
7276: IFFALSE 7314
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7278: LD_EXP 31
7282: PPUSH
7283: LD_STRING D2-Gos-3
7285: PPUSH
7286: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7290: LD_EXP 14
7294: PPUSH
7295: LD_STRING D2-JMM-4
7297: PPUSH
7298: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7302: LD_EXP 31
7306: PPUSH
7307: LD_STRING D2-Gos-4
7309: PPUSH
7310: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7314: LD_EXP 14
7318: PPUSH
7319: LD_STRING D2-JMM-5
7321: PPUSH
7322: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7326: LD_EXP 31
7330: PPUSH
7331: LD_STRING D2-Gos-5
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7338: LD_EXP 14
7342: PPUSH
7343: LD_STRING D2-JMM-6
7345: PPUSH
7346: CALL_OW 88
// DialogueOff ;
7350: CALL_OW 7
// wait ( 0 0$2 ) ;
7354: LD_INT 70
7356: PPUSH
7357: CALL_OW 67
// if Kirilenkova then
7361: LD_EXP 32
7365: IFFALSE 7379
// Say ( Kirilenkova , D3-Kir-1 ) ;
7367: LD_EXP 32
7371: PPUSH
7372: LD_STRING D3-Kir-1
7374: PPUSH
7375: CALL_OW 88
// gossudarov_arrive := true ;
7379: LD_ADDR_EXP 4
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7387: LD_STRING CombinedForces
7389: PPUSH
7390: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until ru_lab_builded ;
7401: LD_EXP 5
7405: IFFALSE 7394
// if Kirilenkova then
7407: LD_EXP 32
7411: IFFALSE 7427
// Say ( Kirilenkova , D3a-Kir-1 ) else
7413: LD_EXP 32
7417: PPUSH
7418: LD_STRING D3a-Kir-1
7420: PPUSH
7421: CALL_OW 88
7425: GO 7449
// begin un := SciRu ;
7427: LD_ADDR_VAR 0 4
7431: PUSH
7432: CALL 12534 0 0
7436: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7437: LD_VAR 0 4
7441: PPUSH
7442: LD_STRING D3a-Sci1-1
7444: PPUSH
7445: CALL_OW 88
// end ; if Kirilenkova or un then
7449: LD_EXP 32
7453: PUSH
7454: LD_VAR 0 4
7458: OR
7459: IFFALSE 7473
// Say ( JMM , D3a-JMM-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-JMM-1
7468: PPUSH
7469: CALL_OW 88
// end ;
7473: LD_VAR 0 1
7477: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7478: LD_EXP 4
7482: PUSH
7483: LD_INT 22
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: LD_INT 25
7498: PUSH
7499: LD_INT 1
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 25
7508: PUSH
7509: LD_INT 2
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 25
7518: PUSH
7519: LD_INT 3
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 25
7538: PUSH
7539: LD_INT 5
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 25
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 9
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 69
7584: PUSH
7585: LD_INT 7
7587: LESS
7588: AND
7589: IFFALSE 7601
7591: GO 7593
7593: DISABLE
// YouLost ( TooMany ) ;
7594: LD_STRING TooMany
7596: PPUSH
7597: CALL_OW 104
7601: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7602: LD_EXP 31
7606: PPUSH
7607: CALL_OW 255
7611: PUSH
7612: LD_INT 7
7614: EQUAL
7615: IFFALSE 7815
7617: GO 7619
7619: DISABLE
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
// begin uc_side := 3 ;
7625: LD_ADDR_OWVAR 20
7629: PUSH
7630: LD_INT 3
7632: ST_TO_ADDR
// uc_nation := 3 ;
7633: LD_ADDR_OWVAR 21
7637: PUSH
7638: LD_INT 3
7640: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7641: LD_INT 21
7643: PPUSH
7644: LD_INT 3
7646: PPUSH
7647: LD_INT 3
7649: PPUSH
7650: LD_INT 42
7652: PPUSH
7653: LD_INT 100
7655: PPUSH
7656: CALL 21089 0 5
// un := CreateVehicle ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: CALL_OW 45
7669: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 15
7677: PPUSH
7678: LD_INT 0
7680: PPUSH
7681: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_INT 67
7692: PPUSH
7693: LD_INT 45
7695: PPUSH
7696: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_INT 70
7707: PPUSH
7708: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7712: LD_VAR 0 3
7716: PPUSH
7717: LD_INT 69
7719: PPUSH
7720: LD_INT 18
7722: PPUSH
7723: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7727: LD_VAR 0 3
7731: PPUSH
7732: LD_INT 60
7734: PPUSH
7735: LD_INT 2
7737: PPUSH
7738: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7749: LD_VAR 0 3
7753: PPUSH
7754: CALL_OW 302
7758: NOT
7759: PUSH
7760: LD_VAR 0 3
7764: PPUSH
7765: LD_INT 17
7767: PPUSH
7768: CALL_OW 308
7772: OR
7773: IFFALSE 7742
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7775: LD_VAR 0 3
7779: PPUSH
7780: LD_INT 17
7782: PPUSH
7783: CALL_OW 308
7787: PUSH
7788: LD_VAR 0 3
7792: PPUSH
7793: LD_INT 60
7795: PPUSH
7796: LD_INT 2
7798: PPUSH
7799: CALL_OW 307
7803: OR
7804: IFFALSE 7815
// RemoveUnit ( un ) ;
7806: LD_VAR 0 3
7810: PPUSH
7811: CALL_OW 64
// end ;
7815: PPOPN 3
7817: END
// every 0 0$2 do var i , un , tmp ;
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7826: LD_INT 70
7828: PPUSH
7829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 22
7840: PUSH
7841: LD_INT 7
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 101
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 69
7866: ST_TO_ADDR
// until tmp ;
7867: LD_VAR 0 3
7871: IFFALSE 7826
// un := NearestUnitToUnit ( tmp , JMM ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_VAR 0 3
7882: PPUSH
7883: LD_EXP 14
7887: PPUSH
7888: CALL_OW 74
7892: ST_TO_ADDR
// player_spotted := true ;
7893: LD_ADDR_EXP 6
7897: PUSH
7898: LD_INT 1
7900: ST_TO_ADDR
// tmp := SciRu ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: CALL 12534 0 0
7910: ST_TO_ADDR
// if not tmp then
7911: LD_VAR 0 3
7915: NOT
7916: IFFALSE 7928
// tmp := SolRu ;
7918: LD_ADDR_VAR 0 3
7922: PUSH
7923: CALL 12681 0 0
7927: ST_TO_ADDR
// DialogueOn ;
7928: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 250
7941: PPUSH
7942: LD_VAR 0 2
7946: PPUSH
7947: CALL_OW 251
7951: PPUSH
7952: LD_INT 7
7954: PPUSH
7955: LD_INT 8
7957: NEG
7958: PPUSH
7959: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7963: LD_VAR 0 2
7967: PPUSH
7968: CALL_OW 87
// if tmp then
7972: LD_VAR 0 3
7976: IFFALSE 7990
// Say ( tmp , D4-RSci1-1 ) ;
7978: LD_VAR 0 3
7982: PPUSH
7983: LD_STRING D4-RSci1-1
7985: PPUSH
7986: CALL_OW 88
// if Gossudarov then
7990: LD_EXP 31
7994: IFFALSE 8020
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7996: LD_EXP 31
8000: PPUSH
8001: LD_STRING D4-Gos-1
8003: PPUSH
8004: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8008: LD_EXP 14
8012: PPUSH
8013: LD_STRING D4-JMM-1
8015: PPUSH
8016: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8020: LD_VAR 0 2
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_VAR 0 2
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 331
// DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8051: LD_STRING M5
8053: PPUSH
8054: CALL_OW 337
// end ;
8058: PPOPN 3
8060: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8061: LD_EXP 6
8065: IFFALSE 8654
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// begin PrepareBelkov ;
8075: CALL 2000 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8079: LD_EXP 46
8083: PPUSH
8084: LD_INT 118
8086: PPUSH
8087: LD_INT 106
8089: PPUSH
8090: CALL_OW 111
// AddComHold ( Belkov ) ;
8094: LD_EXP 46
8098: PPUSH
8099: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8103: LD_INT 35
8105: PPUSH
8106: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8110: LD_EXP 46
8114: PPUSH
8115: LD_INT 118
8117: PPUSH
8118: LD_INT 106
8120: PPUSH
8121: CALL_OW 307
8125: IFFALSE 8103
// ChangeSideFog ( 4 , 7 ) ;
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 7
8132: PPUSH
8133: CALL_OW 343
// if IsOk ( Belkov ) then
8137: LD_EXP 46
8141: PPUSH
8142: CALL_OW 302
8146: IFFALSE 8230
// begin InGameOn ;
8148: CALL_OW 8
// DialogueOn ;
8152: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8156: LD_EXP 46
8160: PPUSH
8161: LD_STRING D5-Bel-1
8163: PPUSH
8164: CALL_OW 94
// if Gossudarov then
8168: LD_EXP 31
8172: IFFALSE 8222
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8174: LD_EXP 31
8178: PPUSH
8179: LD_STRING D5-Gos-1
8181: PPUSH
8182: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8186: LD_EXP 14
8190: PPUSH
8191: LD_STRING D5-JMM-1
8193: PPUSH
8194: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8198: LD_EXP 31
8202: PPUSH
8203: LD_STRING D5-Gos-2
8205: PPUSH
8206: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8210: LD_EXP 14
8214: PPUSH
8215: LD_STRING D5-JMM-2
8217: PPUSH
8218: CALL_OW 88
// end ; DialogueOff ;
8222: CALL_OW 7
// InGameOff ;
8226: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8230: LD_STRING QSaveBelkov
8232: PPUSH
8233: CALL_OW 97
8237: PUSH
8238: LD_INT 1
8240: DOUBLE
8241: EQUAL
8242: IFTRUE 8246
8244: GO 8296
8246: POP
// begin DialogueOn ;
8247: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D5a-JMM-1
8258: PPUSH
8259: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8263: LD_EXP 46
8267: PPUSH
8268: LD_STRING D5a-Bel-1
8270: PPUSH
8271: CALL_OW 94
// DialogueOff ;
8275: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 83
8286: PPUSH
8287: LD_INT 49
8289: PPUSH
8290: CALL_OW 111
// end ; 2 :
8294: GO 8329
8296: LD_INT 2
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8328
8304: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8305: LD_EXP 14
8309: PPUSH
8310: LD_STRING D5a-JMM-2
8312: PPUSH
8313: CALL_OW 88
// ComHold ( Belkov ) ;
8317: LD_EXP 46
8321: PPUSH
8322: CALL_OW 140
// end ; end ;
8326: GO 8329
8328: POP
// time := 0 0$00 ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 0
8336: ST_TO_ADDR
// vehSpawned := false ;
8337: LD_ADDR_VAR 0 3
8341: PUSH
8342: LD_INT 0
8344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8345: LD_INT 35
8347: PPUSH
8348: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 350
8359: PUSH
8360: LD_INT 175
8362: PUSH
8363: LD_INT 70
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: LIST
8370: PUSH
8371: LD_OWVAR 67
8375: ARRAY
8376: GREATEREQUAL
8377: PUSH
8378: LD_VAR 0 3
8382: NOT
8383: AND
8384: IFFALSE 8474
// begin vehSpawned := true ;
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// uc_side := 3 ;
8394: LD_ADDR_OWVAR 20
8398: PUSH
8399: LD_INT 3
8401: ST_TO_ADDR
// uc_nation := 3 ;
8402: LD_ADDR_OWVAR 21
8406: PUSH
8407: LD_INT 3
8409: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8410: LD_INT 22
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 43
8421: PPUSH
8422: LD_INT 100
8424: PPUSH
8425: CALL 21089 0 5
// veh := CreateVehicle ;
8429: LD_ADDR_VAR 0 2
8433: PUSH
8434: CALL_OW 45
8438: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8439: LD_VAR 0 2
8443: PPUSH
8444: LD_INT 130
8446: PPUSH
8447: LD_INT 131
8449: PPUSH
8450: LD_INT 0
8452: PPUSH
8453: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8457: LD_VAR 0 2
8461: PPUSH
8462: LD_INT 100
8464: PPUSH
8465: LD_INT 82
8467: PPUSH
8468: CALL_OW 114
// end else
8472: GO 8488
// time := time + 0 0$1 ;
8474: LD_ADDR_VAR 0 1
8478: PUSH
8479: LD_VAR 0 1
8483: PUSH
8484: LD_INT 35
8486: PLUS
8487: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8488: LD_EXP 46
8492: PPUSH
8493: CALL_OW 301
8497: PUSH
8498: LD_EXP 46
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 4
8510: EQUAL
8511: AND
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_INT 7
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: PPUSH
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 74
8537: PPUSH
8538: LD_EXP 46
8542: PPUSH
8543: CALL_OW 296
8547: PUSH
8548: LD_INT 10
8550: LESS
8551: OR
8552: IFFALSE 8345
// if IsDead ( Belkov ) then
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: IFFALSE 8588
// begin CenterNowOnUnits ( Belkov ) ;
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8574: LD_EXP 14
8578: PPUSH
8579: LD_STRING D5a-JMM-2a
8581: PPUSH
8582: CALL_OW 88
// exit ;
8586: GO 8654
// end ; if See ( 7 , Belkov ) then
8588: LD_INT 7
8590: PPUSH
8591: LD_EXP 46
8595: PPUSH
8596: CALL_OW 292
8600: IFFALSE 8614
// SetSide ( Belkov , 7 ) ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 7
8609: PPUSH
8610: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8614: LD_INT 35
8616: PPUSH
8617: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8621: LD_EXP 46
8625: PPUSH
8626: LD_INT 66
8628: PPUSH
8629: LD_INT 45
8631: PPUSH
8632: CALL_OW 297
8636: PUSH
8637: LD_INT 30
8639: LESS
8640: IFFALSE 8614
// Say ( Belkov , D6-Bel-1 ) ;
8642: LD_EXP 46
8646: PPUSH
8647: LD_STRING D6-Bel-1
8649: PPUSH
8650: CALL_OW 88
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 302
8666: PUSH
8667: LD_EXP 46
8671: PPUSH
8672: CALL_OW 504
8676: PUSH
8677: LD_INT 2
8679: PUSH
8680: LD_INT 34
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 34
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: PPUSH
8705: CALL_OW 69
8709: IN
8710: AND
8711: IFFALSE 8728
8713: GO 8715
8715: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8716: LD_EXP 46
8720: PPUSH
8721: LD_STRING D7-Bel-1
8723: PPUSH
8724: CALL_OW 88
8728: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8729: LD_INT 22
8731: PUSH
8732: LD_INT 7
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: LD_INT 101
8741: PUSH
8742: LD_INT 2
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PPUSH
8753: CALL_OW 69
8757: PUSH
8758: LD_EXP 8
8762: NOT
8763: AND
8764: PUSH
8765: LD_EXP 45
8769: PPUSH
8770: CALL_OW 305
8774: NOT
8775: AND
8776: IFFALSE 9246
8778: GO 8780
8780: DISABLE
8781: LD_INT 0
8783: PPUSH
// begin ar_base_spotted := true ;
8784: LD_ADDR_EXP 8
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 2
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_EXP 14
8840: PPUSH
8841: CALL_OW 74
8845: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8846: LD_INT 7
8848: PPUSH
8849: LD_INT 3
8851: PPUSH
8852: CALL_OW 332
// DialogueOn ;
8856: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8860: LD_VAR 0 1
8864: PPUSH
8865: CALL_OW 250
8869: PPUSH
8870: LD_VAR 0 1
8874: PPUSH
8875: CALL_OW 251
8879: PPUSH
8880: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8884: LD_ADDR_VAR 0 1
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 23
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: LD_INT 26
8911: PUSH
8912: LD_INT 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: PUSH
8929: LD_EXP 14
8933: PUSH
8934: LD_EXP 18
8938: PUSH
8939: LD_EXP 19
8943: PUSH
8944: LD_EXP 26
8948: PUSH
8949: LD_EXP 15
8953: PUSH
8954: LD_EXP 24
8958: PUSH
8959: LD_EXP 20
8963: PUSH
8964: LD_EXP 22
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: DIFF
8979: ST_TO_ADDR
// if not tmp then
8980: LD_VAR 0 1
8984: NOT
8985: IFFALSE 9059
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 22
8994: PUSH
8995: LD_INT 7
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: LD_INT 23
9004: PUSH
9005: LD_INT 1
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 2
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: PUSH
9032: LD_EXP 29
9036: PUSH
9037: LD_EXP 16
9041: PUSH
9042: LD_EXP 27
9046: PUSH
9047: LD_EXP 28
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: DIFF
9058: ST_TO_ADDR
// if tmp then
9059: LD_VAR 0 1
9063: IFFALSE 9134
// case GetSex ( tmp [ 1 ] ) of sex_male :
9065: LD_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ARRAY
9073: PPUSH
9074: CALL_OW 258
9078: PUSH
9079: LD_INT 1
9081: DOUBLE
9082: EQUAL
9083: IFTRUE 9087
9085: GO 9106
9087: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9088: LD_VAR 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D9-Sol1-1
9099: PPUSH
9100: CALL_OW 88
9104: GO 9134
9106: LD_INT 2
9108: DOUBLE
9109: EQUAL
9110: IFTRUE 9114
9112: GO 9133
9114: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 1
9122: ARRAY
9123: PPUSH
9124: LD_STRING D9-FSol1-1
9126: PPUSH
9127: CALL_OW 88
9131: GO 9134
9133: POP
// if Frank then
9134: LD_EXP 26
9138: IFFALSE 9242
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9140: LD_EXP 55
9144: PPUSH
9145: CALL_OW 250
9149: PPUSH
9150: LD_EXP 55
9154: PPUSH
9155: CALL_OW 251
9159: PPUSH
9160: LD_INT 7
9162: PPUSH
9163: LD_INT 8
9165: PPUSH
9166: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9170: LD_EXP 55
9174: PPUSH
9175: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9179: LD_EXP 26
9183: PPUSH
9184: LD_STRING D9-Frank-1
9186: PPUSH
9187: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D9-JMM-1
9198: PPUSH
9199: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9203: LD_EXP 26
9207: PPUSH
9208: LD_STRING D9-Frank-2
9210: PPUSH
9211: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9215: LD_EXP 55
9219: PPUSH
9220: CALL_OW 250
9224: PPUSH
9225: LD_EXP 55
9229: PPUSH
9230: CALL_OW 251
9234: PPUSH
9235: LD_INT 7
9237: PPUSH
9238: CALL_OW 331
// end ; DialogueOff ;
9242: CALL_OW 7
// end ;
9246: PPOPN 1
9248: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9249: LD_EXP 7
9253: PUSH
9254: LD_OWVAR 1
9258: PUSH
9259: LD_INT 42000
9261: GREATEREQUAL
9262: OR
9263: IFFALSE 10290
9265: GO 9267
9267: DISABLE
9268: LD_INT 0
9270: PPUSH
9271: PPUSH
// begin selected_option := 1 ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9280: LD_INT 10500
9282: PPUSH
9283: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9287: LD_INT 35
9289: PPUSH
9290: CALL_OW 67
// until not ru_attackers ;
9294: LD_EXP 51
9298: NOT
9299: IFFALSE 9287
// PrepareBurlak ;
9301: CALL 2112 0 0
// repeat wait ( 0 0$2 ) ;
9305: LD_INT 70
9307: PPUSH
9308: CALL_OW 67
// until not HasTask ( Burlak ) ;
9312: LD_EXP 45
9316: PPUSH
9317: CALL_OW 314
9321: NOT
9322: IFFALSE 9305
// InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9332: LD_EXP 48
9336: PPUSH
9337: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D10-Bur-1
9348: PPUSH
9349: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9353: LD_EXP 46
9357: PUSH
9358: LD_EXP 46
9362: PPUSH
9363: CALL_OW 255
9367: PUSH
9368: LD_INT 7
9370: EQUAL
9371: AND
9372: IFFALSE 9386
// Say ( Belkov , D10-Bel-1 ) ;
9374: LD_EXP 46
9378: PPUSH
9379: LD_STRING D10-Bel-1
9381: PPUSH
9382: CALL_OW 88
// if Gossudarov then
9386: LD_EXP 31
9390: IFFALSE 9404
// Say ( Gossudarov , D10-Gos-1 ) ;
9392: LD_EXP 31
9396: PPUSH
9397: LD_STRING D10-Gos-1
9399: PPUSH
9400: CALL_OW 88
// if Kirilenkova then
9404: LD_EXP 32
9408: IFFALSE 9422
// Say ( Kirilenkova , D10-Kir-1 ) ;
9410: LD_EXP 32
9414: PPUSH
9415: LD_STRING D10-Kir-1
9417: PPUSH
9418: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9422: CALL 12681 0 0
9426: PPUSH
9427: LD_STRING D10-RSol1-1
9429: PPUSH
9430: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D10-Bur-2
9441: PPUSH
9442: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9446: LD_EXP 14
9450: PPUSH
9451: LD_STRING D10-JMM-2
9453: PPUSH
9454: CALL_OW 88
// if Kirilenkova then
9458: LD_EXP 32
9462: IFFALSE 9478
// Say ( Kirilenkova , D10-Kir-2 ) else
9464: LD_EXP 32
9468: PPUSH
9469: LD_STRING D10-Kir-2
9471: PPUSH
9472: CALL_OW 88
9476: GO 9490
// Say ( SolRu , D10-RSol1-2 ) ;
9478: CALL 12681 0 0
9482: PPUSH
9483: LD_STRING D10-RSol1-2
9485: PPUSH
9486: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9490: LD_EXP 14
9494: PPUSH
9495: LD_STRING D10-JMM-3
9497: PPUSH
9498: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9502: LD_EXP 45
9506: PPUSH
9507: LD_STRING D10-Bur-3
9509: PPUSH
9510: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9514: LD_EXP 14
9518: PPUSH
9519: LD_STRING D10-JMM-4
9521: PPUSH
9522: CALL_OW 88
// DialogueOff ;
9526: CALL_OW 7
// InGameOff ;
9530: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9534: LD_STRING M2
9536: PPUSH
9537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9548: LD_INT 22
9550: PUSH
9551: LD_INT 7
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 91
9560: PUSH
9561: LD_EXP 45
9565: PUSH
9566: LD_INT 8
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PPUSH
9578: CALL_OW 69
9582: IFFALSE 9541
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_INT 22
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PUSH
9604: FOR_IN
9605: IFFALSE 9621
// SetSide ( i , 7 ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 7
9614: PPUSH
9615: CALL_OW 235
9619: GO 9604
9621: POP
9622: POP
// ChangeMissionObjectives ( M3 ) ;
9623: LD_STRING M3
9625: PPUSH
9626: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9637: LD_EXP 14
9641: PPUSH
9642: LD_EXP 45
9646: PPUSH
9647: CALL_OW 296
9651: PUSH
9652: LD_INT 8
9654: LESS
9655: IFFALSE 9630
// ComTurnUnit ( JMM , Burlak ) ;
9657: LD_EXP 14
9661: PPUSH
9662: LD_EXP 45
9666: PPUSH
9667: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9671: LD_EXP 45
9675: PPUSH
9676: LD_EXP 14
9680: PPUSH
9681: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9685: LD_INT 10
9687: PPUSH
9688: CALL_OW 67
// DialogueOn ;
9692: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9696: LD_EXP 14
9700: PPUSH
9701: LD_STRING D11-JMM-1
9703: PPUSH
9704: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9708: LD_EXP 45
9712: PPUSH
9713: LD_STRING D11-Bur-1
9715: PPUSH
9716: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9720: LD_EXP 14
9724: PPUSH
9725: LD_STRING D11-JMM-2
9727: PPUSH
9728: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9732: LD_EXP 45
9736: PPUSH
9737: LD_STRING D11-Bur-2
9739: PPUSH
9740: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9744: LD_EXP 14
9748: PPUSH
9749: LD_STRING D11-JMM-3
9751: PPUSH
9752: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9756: LD_EXP 45
9760: PPUSH
9761: LD_STRING D11-Bur-3
9763: PPUSH
9764: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9768: LD_EXP 14
9772: PPUSH
9773: LD_STRING D11-JMM-4
9775: PPUSH
9776: CALL_OW 88
// if ar_base_spotted then
9780: LD_EXP 8
9784: IFFALSE 9800
// Say ( Burlak , D12-Bur-1 ) else
9786: LD_EXP 45
9790: PPUSH
9791: LD_STRING D12-Bur-1
9793: PPUSH
9794: CALL_OW 88
9798: GO 9839
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9800: LD_INT 7
9802: PPUSH
9803: LD_INT 3
9805: PPUSH
9806: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9810: LD_INT 127
9812: PPUSH
9813: LD_INT 45
9815: PPUSH
9816: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1a
9827: PPUSH
9828: CALL_OW 88
// dwait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9839: LD_EXP 45
9843: PPUSH
9844: LD_STRING D12-Bur-1b
9846: PPUSH
9847: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9851: LD_EXP 14
9855: PPUSH
9856: LD_STRING D12-JMM-1
9858: PPUSH
9859: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9863: LD_EXP 45
9867: PPUSH
9868: LD_STRING D12-Bur-2
9870: PPUSH
9871: CALL_OW 88
// if Roth then
9875: LD_EXP 15
9879: IFFALSE 9895
// Say ( Roth , D12-Roth-2 ) else
9881: LD_EXP 15
9885: PPUSH
9886: LD_STRING D12-Roth-2
9888: PPUSH
9889: CALL_OW 88
9893: GO 9907
// Say ( SciRu , D12-RSci1-2 ) ;
9895: CALL 12534 0 0
9899: PPUSH
9900: LD_STRING D12-RSci1-2
9902: PPUSH
9903: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9907: LD_EXP 14
9911: PPUSH
9912: LD_STRING D12-JMM-2
9914: PPUSH
9915: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9919: LD_EXP 45
9923: PPUSH
9924: LD_STRING D12-Bur-3
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9931: LD_EXP 14
9935: PPUSH
9936: LD_STRING D12-JMM-3
9938: PPUSH
9939: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D12-Bur-4
9950: PPUSH
9951: CALL_OW 88
// case Query ( QBase ) of 1 :
9955: LD_STRING QBase
9957: PPUSH
9958: CALL_OW 97
9962: PUSH
9963: LD_INT 1
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10089
9971: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9972: LD_EXP 14
9976: PPUSH
9977: LD_STRING D13a-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9984: LD_EXP 45
9988: PPUSH
9989: LD_STRING D13a-Bur-1
9991: PPUSH
9992: CALL_OW 88
// if Roth then
9996: LD_EXP 15
10000: IFFALSE 10016
// Say ( Roth , D13a-Roth-1 ) else
10002: LD_EXP 15
10006: PPUSH
10007: LD_STRING D13a-Roth-1
10009: PPUSH
10010: CALL_OW 88
10014: GO 10028
// Say ( SciRu , D13a-RSci1-1 ) ;
10016: CALL 12534 0 0
10020: PPUSH
10021: LD_STRING D13a-RSci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10028: LD_EXP 14
10032: PPUSH
10033: LD_STRING D13a-JMM-2
10035: PPUSH
10036: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10040: LD_STRING QBaseAgain
10042: PPUSH
10043: CALL_OW 97
10047: PUSH
10048: LD_INT 1
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 2 ; 2 :
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
10065: GO 10087
10067: LD_INT 2
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10086
10075: POP
// selected_option := 3 ; end ;
10076: LD_ADDR_VAR 0 2
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
10084: GO 10087
10086: POP
// end ; 2 :
10087: GO 10128
10089: LD_INT 2
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 2 ; 3 :
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 2
10105: ST_TO_ADDR
10106: GO 10128
10108: LD_INT 3
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10127
10116: POP
// selected_option := 3 ; end ;
10117: LD_ADDR_VAR 0 2
10121: PUSH
10122: LD_INT 3
10124: ST_TO_ADDR
10125: GO 10128
10127: POP
// if selected_option = 2 then
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10230
// begin Say ( JMM , D13b-JMM-1 ) ;
10138: LD_EXP 14
10142: PPUSH
10143: LD_STRING D13b-JMM-1
10145: PPUSH
10146: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10150: LD_EXP 45
10154: PPUSH
10155: LD_STRING D13b-Bur-1
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10162: LD_EXP 14
10166: PPUSH
10167: LD_STRING D13b-JMM-2
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10174: LD_EXP 54
10178: PPUSH
10179: LD_STRING D13b-Abd-2
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10186: LD_EXP 14
10190: PPUSH
10191: LD_STRING D13b-JMM-3
10193: PPUSH
10194: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10198: LD_EXP 54
10202: PPUSH
10203: LD_STRING D13b-Abd-3
10205: PPUSH
10206: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10210: LD_EXP 14
10214: PPUSH
10215: LD_STRING D13b-JMM-4
10217: PPUSH
10218: CALL_OW 88
// ar_active_attack := true ;
10222: LD_ADDR_EXP 9
10226: PUSH
10227: LD_INT 1
10229: ST_TO_ADDR
// end ; if selected_option = 3 then
10230: LD_VAR 0 2
10234: PUSH
10235: LD_INT 3
10237: EQUAL
10238: IFFALSE 10264
// begin Say ( JMM , D13c-JMM-1 ) ;
10240: LD_EXP 14
10244: PPUSH
10245: LD_STRING D13c-JMM-1
10247: PPUSH
10248: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10252: LD_EXP 45
10256: PPUSH
10257: LD_STRING D13c-Bur-1
10259: PPUSH
10260: CALL_OW 88
// end ; DialogueOff ;
10264: CALL_OW 7
// if not ar_active_attack then
10268: LD_EXP 9
10272: NOT
10273: IFFALSE 10290
// begin wait ( 6 6$00 ) ;
10275: LD_INT 12600
10277: PPUSH
10278: CALL_OW 67
// ar_active_attack := true ;
10282: LD_ADDR_EXP 9
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// end ; end ;
10290: PPOPN 2
10292: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10293: LD_EXP 45
10297: PPUSH
10298: CALL_OW 305
10302: PUSH
10303: LD_EXP 45
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: AND
10317: IFFALSE 10513
10319: GO 10321
10321: DISABLE
10322: LD_INT 0
10324: PPUSH
// begin wait ( 4 4$40 ) ;
10325: LD_INT 9800
10327: PPUSH
10328: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// until not ru_attackers ;
10339: LD_EXP 51
10343: NOT
10344: IFFALSE 10332
// PrepareGnyevko ;
10346: CALL 2056 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10350: LD_EXP 47
10354: PPUSH
10355: LD_INT 124
10357: PPUSH
10358: LD_INT 118
10360: PPUSH
10361: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10365: LD_EXP 47
10369: PPUSH
10370: CALL_OW 200
// time := 0 0$00 ;
10374: LD_ADDR_VAR 0 1
10378: PUSH
10379: LD_INT 0
10381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10382: LD_INT 35
10384: PPUSH
10385: CALL_OW 67
// time := time + 0 0$1 ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_VAR 0 1
10398: PUSH
10399: LD_INT 35
10401: PLUS
10402: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10403: LD_EXP 47
10407: PPUSH
10408: LD_INT 124
10410: PPUSH
10411: LD_INT 118
10413: PPUSH
10414: CALL_OW 307
10418: PUSH
10419: LD_VAR 0 1
10423: PUSH
10424: LD_INT 1050
10426: GREATEREQUAL
10427: OR
10428: IFFALSE 10382
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10430: LD_EXP 47
10434: PPUSH
10435: LD_STRING DBelkov-Gny-1
10437: PPUSH
10438: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10442: LD_EXP 45
10446: PPUSH
10447: LD_STRING DBelkov-Bur-1a
10449: PPUSH
10450: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10461: LD_EXP 47
10465: PPUSH
10466: LD_INT 22
10468: PUSH
10469: LD_INT 7
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PPUSH
10476: CALL_OW 69
10480: PPUSH
10481: LD_EXP 47
10485: PPUSH
10486: CALL_OW 74
10490: PPUSH
10491: CALL_OW 296
10495: PUSH
10496: LD_INT 8
10498: LESS
10499: IFFALSE 10454
// SetSide ( Gnyevko , 7 ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_INT 7
10508: PPUSH
10509: CALL_OW 235
// end ;
10513: PPOPN 1
10515: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10516: LD_EXP 45
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: IFFALSE 10539
10531: GO 10533
10533: DISABLE
// begin enable ;
10534: ENABLE
// PrepareAmericanAttack ;
10535: CALL 6362 0 0
// end ;
10539: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10540: LD_INT 22
10542: PUSH
10543: LD_INT 1
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: IFFALSE 10738
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
10562: PPUSH
// begin while true do
10563: LD_INT 1
10565: IFFALSE 10622
// begin wait ( 0 0$1 ) ;
10567: LD_INT 35
10569: PPUSH
10570: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10574: LD_ADDR_VAR 0 2
10578: PUSH
10579: LD_INT 22
10581: PUSH
10582: LD_INT 1
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: PPUSH
10589: CALL_OW 69
10593: PPUSH
10594: LD_EXP 14
10598: PPUSH
10599: CALL_OW 74
10603: ST_TO_ADDR
// if See ( 7 , tmp ) then
10604: LD_INT 7
10606: PPUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 292
10616: IFFALSE 10620
// break ;
10618: GO 10622
// end ;
10620: GO 10563
// DialogueOn ;
10622: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL_OW 250
10644: PPUSH
10645: LD_VAR 0 2
10649: PPUSH
10650: CALL_OW 251
10654: PPUSH
10655: LD_INT 7
10657: PPUSH
10658: LD_INT 8
10660: PPUSH
10661: CALL_OW 330
// if Denis then
10665: LD_EXP 20
10669: IFFALSE 10683
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10671: LD_EXP 20
10675: PPUSH
10676: LD_STRING DAmerAttack-Pet-1
10678: PPUSH
10679: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10683: LD_EXP 14
10687: PPUSH
10688: LD_STRING DAmerAttack-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10695: LD_EXP 45
10699: PPUSH
10700: LD_STRING DStop-Bur-1
10702: PPUSH
10703: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 250
10716: PPUSH
10717: LD_VAR 0 2
10721: PPUSH
10722: CALL_OW 251
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 331
// DialogueOff ;
10734: CALL_OW 7
// end ;
10738: PPOPN 2
10740: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10741: LD_INT 22
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 21
10753: PUSH
10754: LD_INT 1
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: IFFALSE 10815
10775: GO 10777
10777: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10778: LD_STRING M5a
10780: PPUSH
10781: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10785: LD_EXP 14
10789: PPUSH
10790: LD_STRING D8-JMM-1
10792: PPUSH
10793: CALL_OW 88
// if Gossudarov then
10797: LD_EXP 31
10801: IFFALSE 10815
// Say ( Gossudarov , D8-Gos-1 ) ;
10803: LD_EXP 31
10807: PPUSH
10808: LD_STRING D8-Gos-1
10810: PPUSH
10811: CALL_OW 88
// end ;
10815: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 21
10828: PUSH
10829: LD_INT 1
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: PUSH
10845: LD_INT 0
10847: EQUAL
10848: IFFALSE 10898
10850: GO 10852
10852: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10853: LD_STRING M4c
10855: PPUSH
10856: CALL_OW 337
// if Roth then
10860: LD_EXP 15
10864: IFFALSE 10880
// Say ( Roth , DStop-Roth-1 ) else
10866: LD_EXP 15
10870: PPUSH
10871: LD_STRING DStop-Roth-1
10873: PPUSH
10874: CALL_OW 88
10878: GO 10898
// if Gossudarov then
10880: LD_EXP 31
10884: IFFALSE 10898
// Say ( Gossudarov , D8-Gos-1a ) ;
10886: LD_EXP 31
10890: PPUSH
10891: LD_STRING D8-Gos-1a
10893: PPUSH
10894: CALL_OW 88
// end ;
10898: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10899: LD_INT 7
10901: PPUSH
10902: LD_INT 1
10904: PPUSH
10905: LD_INT 1
10907: PPUSH
10908: CALL 14126 0 3
10912: PUSH
10913: LD_INT 0
10915: EQUAL
10916: PUSH
10917: LD_INT 7
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_INT 1
10925: PPUSH
10926: CALL 14126 0 3
10930: PUSH
10931: LD_INT 0
10933: EQUAL
10934: AND
10935: IFFALSE 10947
10937: GO 10939
10939: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10940: LD_STRING M1a
10942: PPUSH
10943: CALL_OW 337
// end ;
10947: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
10948: LD_INT 22
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 21
10960: PUSH
10961: LD_INT 1
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: PUSH
10977: LD_INT 0
10979: EQUAL
10980: PUSH
10981: LD_INT 22
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_INT 0
11012: EQUAL
11013: AND
11014: PUSH
11015: LD_INT 22
11017: PUSH
11018: LD_INT 1
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 69
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 1
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 14126 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: PUSH
11054: LD_INT 7
11056: PPUSH
11057: LD_INT 3
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL 14126 0 3
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: AND
11072: IFFALSE 12531
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
11082: PPUSH
11083: PPUSH
11084: PPUSH
// begin m1 := false ;
11085: LD_ADDR_VAR 0 4
11089: PUSH
11090: LD_INT 0
11092: ST_TO_ADDR
// m2 := false ;
11093: LD_ADDR_VAR 0 5
11097: PUSH
11098: LD_INT 0
11100: ST_TO_ADDR
// m3 := false ;
11101: LD_ADDR_VAR 0 6
11105: PUSH
11106: LD_INT 0
11108: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11109: LD_INT 105
11111: PPUSH
11112: CALL_OW 67
// if not IsDead ( Masha ) then
11116: LD_EXP 48
11120: PPUSH
11121: CALL_OW 301
11125: NOT
11126: IFFALSE 11148
// begin m1 := true ;
11128: LD_ADDR_VAR 0 4
11132: PUSH
11133: LD_INT 1
11135: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11136: LD_STRING Masha
11138: PPUSH
11139: LD_INT 1
11141: PPUSH
11142: CALL_OW 101
// end else
11146: GO 11159
// AddMedal ( Masha , - 1 ) ;
11148: LD_STRING Masha
11150: PPUSH
11151: LD_INT 1
11153: NEG
11154: PPUSH
11155: CALL_OW 101
// if abdul_escaped then
11159: LD_EXP 12
11163: IFFALSE 11178
// AddMedal ( Abdul , - 1 ) else
11165: LD_STRING Abdul
11167: PPUSH
11168: LD_INT 1
11170: NEG
11171: PPUSH
11172: CALL_OW 101
11176: GO 11196
// begin m2 := true ;
11178: LD_ADDR_VAR 0 5
11182: PUSH
11183: LD_INT 1
11185: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11186: LD_STRING Abdul
11188: PPUSH
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 101
// end ; if loss_counter = 0 then
11196: LD_EXP 13
11200: PUSH
11201: LD_INT 0
11203: EQUAL
11204: IFFALSE 11226
// begin m3 := true ;
11206: LD_ADDR_VAR 0 6
11210: PUSH
11211: LD_INT 1
11213: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11214: LD_STRING People
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: CALL_OW 101
// end else
11224: GO 11284
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11226: LD_EXP 13
11230: PUSH
11231: LD_INT 3
11233: PUSH
11234: LD_INT 2
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: LIST
11244: PUSH
11245: LD_OWVAR 67
11249: ARRAY
11250: LESSEQUAL
11251: IFFALSE 11273
// begin AddMedal ( People , 1 ) ;
11253: LD_STRING People
11255: PPUSH
11256: LD_INT 1
11258: PPUSH
11259: CALL_OW 101
// m3 := true ;
11263: LD_ADDR_VAR 0 6
11267: PUSH
11268: LD_INT 1
11270: ST_TO_ADDR
// end else
11271: GO 11284
// AddMedal ( People , - 1 ) ;
11273: LD_STRING People
11275: PPUSH
11276: LD_INT 1
11278: NEG
11279: PPUSH
11280: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11284: LD_OWVAR 67
11288: PUSH
11289: LD_INT 3
11291: EQUAL
11292: PUSH
11293: LD_VAR 0 4
11297: AND
11298: PUSH
11299: LD_VAR 0 5
11303: AND
11304: PUSH
11305: LD_VAR 0 6
11309: AND
11310: IFFALSE 11322
// SetAchievementEX ( ACH_AMER , 17 ) ;
11312: LD_STRING ACH_AMER
11314: PPUSH
11315: LD_INT 17
11317: PPUSH
11318: CALL_OW 564
// GiveMedals ( MAIN ) ;
11322: LD_STRING MAIN
11324: PPUSH
11325: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11329: LD_ADDR_VAR 0 2
11333: PUSH
11334: LD_INT 22
11336: PUSH
11337: LD_INT 7
11339: PUSH
11340: EMPTY
11341: LIST
11342: LIST
11343: PUSH
11344: LD_INT 2
11346: PUSH
11347: LD_INT 25
11349: PUSH
11350: LD_INT 1
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: PUSH
11357: LD_INT 25
11359: PUSH
11360: LD_INT 2
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: PUSH
11367: LD_INT 25
11369: PUSH
11370: LD_INT 3
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: LD_INT 25
11379: PUSH
11380: LD_INT 4
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: PUSH
11387: LD_INT 25
11389: PUSH
11390: LD_INT 5
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: PUSH
11397: LD_INT 25
11399: PUSH
11400: LD_INT 8
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: PUSH
11407: LD_INT 25
11409: PUSH
11410: LD_INT 9
11412: PUSH
11413: EMPTY
11414: LIST
11415: LIST
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: PUSH
11427: EMPTY
11428: LIST
11429: LIST
11430: PPUSH
11431: CALL_OW 69
11435: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11436: LD_VAR 0 2
11440: PPUSH
11441: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11445: LD_ADDR_VAR 0 3
11449: PUSH
11450: LD_EXP 14
11454: PUSH
11455: LD_EXP 15
11459: PUSH
11460: LD_EXP 16
11464: PUSH
11465: LD_EXP 17
11469: PUSH
11470: LD_EXP 18
11474: PUSH
11475: LD_EXP 19
11479: PUSH
11480: LD_EXP 20
11484: PUSH
11485: LD_EXP 21
11489: PUSH
11490: LD_EXP 22
11494: PUSH
11495: LD_EXP 23
11499: PUSH
11500: LD_EXP 24
11504: PUSH
11505: LD_EXP 25
11509: PUSH
11510: LD_EXP 26
11514: PUSH
11515: LD_EXP 27
11519: PUSH
11520: LD_EXP 28
11524: PUSH
11525: LD_EXP 29
11529: PUSH
11530: LD_EXP 30
11534: PUSH
11535: LD_EXP 31
11539: PUSH
11540: LD_EXP 32
11544: PUSH
11545: LD_EXP 33
11549: PUSH
11550: LD_EXP 35
11554: PUSH
11555: LD_EXP 36
11559: PUSH
11560: LD_EXP 37
11564: PUSH
11565: LD_EXP 38
11569: PUSH
11570: LD_EXP 39
11574: PUSH
11575: LD_EXP 40
11579: PUSH
11580: LD_EXP 41
11584: PUSH
11585: LD_EXP 42
11589: PUSH
11590: LD_EXP 43
11594: PUSH
11595: LD_EXP 44
11599: PUSH
11600: LD_EXP 45
11604: PUSH
11605: LD_EXP 46
11609: PUSH
11610: LD_EXP 47
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: ST_TO_ADDR
// if tmp diff tmp2 then
11650: LD_VAR 0 2
11654: PUSH
11655: LD_VAR 0 3
11659: DIFF
11660: IFFALSE 11680
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11662: LD_VAR 0 2
11666: PUSH
11667: LD_VAR 0 3
11671: DIFF
11672: PPUSH
11673: LD_STRING 13a_others
11675: PPUSH
11676: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11680: LD_EXP 14
11684: PPUSH
11685: LD_STRING 13a_JMM
11687: PPUSH
11688: CALL_OW 38
// if Titov then
11692: LD_EXP 33
11696: IFFALSE 11710
// SaveCharacters ( Titov , 13a_Titov ) ;
11698: LD_EXP 33
11702: PPUSH
11703: LD_STRING 13a_Titov
11705: PPUSH
11706: CALL_OW 38
// if Dolgov then
11710: LD_EXP 35
11714: IFFALSE 11728
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11716: LD_EXP 35
11720: PPUSH
11721: LD_STRING 13a_Dolgov
11723: PPUSH
11724: CALL_OW 38
// if Petrosyan then
11728: LD_EXP 36
11732: IFFALSE 11746
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11734: LD_EXP 36
11738: PPUSH
11739: LD_STRING 13a_Petrosyan
11741: PPUSH
11742: CALL_OW 38
// if Scholtze then
11746: LD_EXP 37
11750: IFFALSE 11764
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11752: LD_EXP 37
11756: PPUSH
11757: LD_STRING 13a_Scholtze
11759: PPUSH
11760: CALL_OW 38
// if Oblukov then
11764: LD_EXP 38
11768: IFFALSE 11782
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11770: LD_EXP 38
11774: PPUSH
11775: LD_STRING 13a_Oblukov
11777: PPUSH
11778: CALL_OW 38
// if Kapitsova then
11782: LD_EXP 39
11786: IFFALSE 11800
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11788: LD_EXP 39
11792: PPUSH
11793: LD_STRING 13a_Kapitsova
11795: PPUSH
11796: CALL_OW 38
// if Lipshchin then
11800: LD_EXP 40
11804: IFFALSE 11818
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11806: LD_EXP 40
11810: PPUSH
11811: LD_STRING 13a_Lipshchin
11813: PPUSH
11814: CALL_OW 38
// if Petrovova then
11818: LD_EXP 41
11822: IFFALSE 11836
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11824: LD_EXP 41
11828: PPUSH
11829: LD_STRING 13a_Petrovova
11831: PPUSH
11832: CALL_OW 38
// if Kovalyuk then
11836: LD_EXP 42
11840: IFFALSE 11854
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11842: LD_EXP 42
11846: PPUSH
11847: LD_STRING 13a_Kovalyuk
11849: PPUSH
11850: CALL_OW 38
// if Kuzmov then
11854: LD_EXP 43
11858: IFFALSE 11872
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11860: LD_EXP 43
11864: PPUSH
11865: LD_STRING 13a_Kuzmov
11867: PPUSH
11868: CALL_OW 38
// if Karamazov then
11872: LD_EXP 44
11876: IFFALSE 11890
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11878: LD_EXP 44
11882: PPUSH
11883: LD_STRING 13a_Karamazov
11885: PPUSH
11886: CALL_OW 38
// if Burlak then
11890: LD_EXP 45
11894: IFFALSE 11908
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11896: LD_EXP 45
11900: PPUSH
11901: LD_STRING 13a_Burlak
11903: PPUSH
11904: CALL_OW 38
// if Belkov then
11908: LD_EXP 46
11912: IFFALSE 11926
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11914: LD_EXP 46
11918: PPUSH
11919: LD_STRING 13a_Belkov
11921: PPUSH
11922: CALL_OW 38
// if Gnyevko then
11926: LD_EXP 47
11930: IFFALSE 11944
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11932: LD_EXP 47
11936: PPUSH
11937: LD_STRING 13a_Gnyevko
11939: PPUSH
11940: CALL_OW 38
// if Lisa then
11944: LD_EXP 16
11948: IFFALSE 11962
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11950: LD_EXP 16
11954: PPUSH
11955: LD_STRING 13a_Lisa
11957: PPUSH
11958: CALL_OW 38
// if Donaldson then
11962: LD_EXP 17
11966: IFFALSE 11980
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11968: LD_EXP 17
11972: PPUSH
11973: LD_STRING 13a_Donaldson
11975: PPUSH
11976: CALL_OW 38
// if Bobby then
11980: LD_EXP 18
11984: IFFALSE 11998
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11986: LD_EXP 18
11990: PPUSH
11991: LD_STRING 13a_Bobby
11993: PPUSH
11994: CALL_OW 38
// if Cyrus then
11998: LD_EXP 19
12002: IFFALSE 12016
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12004: LD_EXP 19
12008: PPUSH
12009: LD_STRING 13a_Cyrus
12011: PPUSH
12012: CALL_OW 38
// if Denis then
12016: LD_EXP 20
12020: IFFALSE 12034
// SaveCharacters ( Denis , 13a_Denis ) ;
12022: LD_EXP 20
12026: PPUSH
12027: LD_STRING 13a_Denis
12029: PPUSH
12030: CALL_OW 38
// if Brown then
12034: LD_EXP 21
12038: IFFALSE 12052
// SaveCharacters ( Brown , 13a_Brown ) ;
12040: LD_EXP 21
12044: PPUSH
12045: LD_STRING 13a_Brown
12047: PPUSH
12048: CALL_OW 38
// if Gladstone then
12052: LD_EXP 22
12056: IFFALSE 12070
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12058: LD_EXP 22
12062: PPUSH
12063: LD_STRING 13a_Gladstone
12065: PPUSH
12066: CALL_OW 38
// if Houten then
12070: LD_EXP 23
12074: IFFALSE 12088
// SaveCharacters ( Houten , 13a_Houten ) ;
12076: LD_EXP 23
12080: PPUSH
12081: LD_STRING 13a_Houten
12083: PPUSH
12084: CALL_OW 38
// if Cornel then
12088: LD_EXP 24
12092: IFFALSE 12106
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12094: LD_EXP 24
12098: PPUSH
12099: LD_STRING 13a_Cornel
12101: PPUSH
12102: CALL_OW 38
// if Gary then
12106: LD_EXP 25
12110: IFFALSE 12124
// SaveCharacters ( Gary , 13a_Gary ) ;
12112: LD_EXP 25
12116: PPUSH
12117: LD_STRING 13a_Gary
12119: PPUSH
12120: CALL_OW 38
// if Frank then
12124: LD_EXP 26
12128: IFFALSE 12142
// SaveCharacters ( Frank , 13a_Frank ) ;
12130: LD_EXP 26
12134: PPUSH
12135: LD_STRING 13a_Frank
12137: PPUSH
12138: CALL_OW 38
// if Kikuchi then
12142: LD_EXP 27
12146: IFFALSE 12160
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12148: LD_EXP 27
12152: PPUSH
12153: LD_STRING 13a_Kikuchi
12155: PPUSH
12156: CALL_OW 38
// if Simms then
12160: LD_EXP 28
12164: IFFALSE 12178
// SaveCharacters ( Simms , 13a_Simms ) ;
12166: LD_EXP 28
12170: PPUSH
12171: LD_STRING 13a_Simms
12173: PPUSH
12174: CALL_OW 38
// if Joan then
12178: LD_EXP 29
12182: IFFALSE 12196
// SaveCharacters ( Joan , 13a_Joan ) ;
12184: LD_EXP 29
12188: PPUSH
12189: LD_STRING 13a_Joan
12191: PPUSH
12192: CALL_OW 38
// if DeltaDoctor then
12196: LD_EXP 30
12200: IFFALSE 12214
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12202: LD_EXP 30
12206: PPUSH
12207: LD_STRING 13a_DeltaDoctor
12209: PPUSH
12210: CALL_OW 38
// if Gossudarov then
12214: LD_EXP 31
12218: IFFALSE 12232
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12220: LD_EXP 31
12224: PPUSH
12225: LD_STRING 13a_Gossudarov
12227: PPUSH
12228: CALL_OW 38
// if Kirilenkova then
12232: LD_EXP 32
12236: IFFALSE 12250
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12238: LD_EXP 32
12242: PPUSH
12243: LD_STRING 13a_Kirilenkova
12245: PPUSH
12246: CALL_OW 38
// if Roth then
12250: LD_EXP 15
12254: IFFALSE 12268
// SaveCharacters ( Roth , 13a_Roth ) ;
12256: LD_EXP 15
12260: PPUSH
12261: LD_STRING 13a_Roth
12263: PPUSH
12264: CALL_OW 38
// if Masha then
12268: LD_EXP 48
12272: IFFALSE 12327
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12274: LD_EXP 48
12278: PPUSH
12279: CALL_OW 265
12283: PUSH
12284: LD_EXP 48
12288: PPUSH
12289: CALL_OW 262
12293: PUSH
12294: LD_EXP 48
12298: PPUSH
12299: CALL_OW 263
12303: PUSH
12304: LD_EXP 48
12308: PPUSH
12309: CALL_OW 264
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: PPUSH
12320: LD_STRING 13a_Masha
12322: PPUSH
12323: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12327: LD_ADDR_VAR 0 2
12331: PUSH
12332: LD_INT 21
12334: PUSH
12335: LD_INT 3
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PPUSH
12342: CALL_OW 69
12346: ST_TO_ADDR
// tmp2 := [ ] ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: EMPTY
12353: ST_TO_ADDR
// if tmp then
12354: LD_VAR 0 2
12358: IFFALSE 12509
// for i in tmp do
12360: LD_ADDR_VAR 0 1
12364: PUSH
12365: LD_VAR 0 2
12369: PUSH
12370: FOR_IN
12371: IFFALSE 12507
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12373: LD_ADDR_VAR 0 3
12377: PUSH
12378: LD_VAR 0 3
12382: PUSH
12383: LD_VAR 0 1
12387: PPUSH
12388: CALL_OW 255
12392: PUSH
12393: LD_VAR 0 1
12397: PPUSH
12398: CALL_OW 248
12402: PUSH
12403: LD_VAR 0 1
12407: PPUSH
12408: CALL_OW 266
12412: PUSH
12413: LD_VAR 0 1
12417: PPUSH
12418: CALL_OW 250
12422: PUSH
12423: LD_VAR 0 1
12427: PPUSH
12428: CALL_OW 251
12432: PUSH
12433: LD_VAR 0 1
12437: PPUSH
12438: CALL_OW 254
12442: PUSH
12443: LD_VAR 0 1
12447: PPUSH
12448: CALL_OW 267
12452: PUSH
12453: LD_VAR 0 1
12457: PPUSH
12458: LD_INT 1
12460: PPUSH
12461: CALL_OW 268
12465: PUSH
12466: LD_VAR 0 1
12470: PPUSH
12471: LD_INT 2
12473: PPUSH
12474: CALL_OW 268
12478: PUSH
12479: LD_VAR 0 1
12483: PPUSH
12484: CALL_OW 269
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: PUSH
12501: EMPTY
12502: LIST
12503: ADD
12504: ST_TO_ADDR
12505: GO 12370
12507: POP
12508: POP
// if tmp2 then
12509: LD_VAR 0 3
12513: IFFALSE 12527
// SaveVariable ( tmp2 , 13a_buildings ) ;
12515: LD_VAR 0 3
12519: PPUSH
12520: LD_STRING 13a_buildings
12522: PPUSH
12523: CALL_OW 39
// YouWin ;
12527: CALL_OW 103
// end ;
12531: PPOPN 6
12533: END
// export function SciRu ; var tmp , t ; begin
12534: LD_INT 0
12536: PPUSH
12537: PPUSH
12538: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_EXP 31
12548: PUSH
12549: LD_EXP 45
12553: PUSH
12554: LD_EXP 33
12558: PUSH
12559: LD_EXP 46
12563: PUSH
12564: LD_EXP 47
12568: PUSH
12569: LD_EXP 36
12573: PUSH
12574: LD_EXP 37
12578: PUSH
12579: LD_EXP 35
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: LIST
12593: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12594: LD_ADDR_VAR 0 2
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_INT 7
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 23
12611: PUSH
12612: LD_INT 3
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: LD_INT 25
12621: PUSH
12622: LD_INT 4
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 26
12631: PUSH
12632: LD_INT 1
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: PUSH
12650: LD_VAR 0 3
12654: DIFF
12655: ST_TO_ADDR
// if tmp then
12656: LD_VAR 0 2
12660: IFFALSE 12676
// result := tmp [ 1 ] ;
12662: LD_ADDR_VAR 0 1
12666: PUSH
12667: LD_VAR 0 2
12671: PUSH
12672: LD_INT 1
12674: ARRAY
12675: ST_TO_ADDR
// end ;
12676: LD_VAR 0 1
12680: RET
// export function SolRu ; var tmp , t ; begin
12681: LD_INT 0
12683: PPUSH
12684: PPUSH
12685: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12686: LD_ADDR_VAR 0 3
12690: PUSH
12691: LD_EXP 31
12695: PUSH
12696: LD_EXP 45
12700: PUSH
12701: LD_EXP 33
12705: PUSH
12706: LD_EXP 46
12710: PUSH
12711: LD_EXP 47
12715: PUSH
12716: LD_EXP 36
12720: PUSH
12721: LD_EXP 37
12725: PUSH
12726: LD_EXP 35
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: LIST
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: LIST
12740: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12741: LD_ADDR_VAR 0 2
12745: PUSH
12746: LD_INT 22
12748: PUSH
12749: LD_INT 7
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: PUSH
12756: LD_INT 23
12758: PUSH
12759: LD_INT 3
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PUSH
12766: LD_INT 25
12768: PUSH
12769: LD_INT 1
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 26
12778: PUSH
12779: LD_INT 1
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: PPUSH
12792: CALL_OW 69
12796: PUSH
12797: LD_VAR 0 3
12801: DIFF
12802: ST_TO_ADDR
// if tmp then
12803: LD_VAR 0 2
12807: IFFALSE 12823
// result := tmp [ 1 ] ;
12809: LD_ADDR_VAR 0 1
12813: PUSH
12814: LD_VAR 0 2
12818: PUSH
12819: LD_INT 1
12821: ARRAY
12822: ST_TO_ADDR
// end ; end_of_file
12823: LD_VAR 0 1
12827: RET
// export function CustomEvent ( event ) ; begin
12828: LD_INT 0
12830: PPUSH
// end ;
12831: LD_VAR 0 2
12835: RET
// on UnitDestroyed ( un ) do var i , side ;
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12840: LD_VAR 0 1
12844: PUSH
12845: LD_INT 22
12847: PUSH
12848: LD_INT 7
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 2
12857: PUSH
12858: LD_INT 25
12860: PUSH
12861: LD_INT 1
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 25
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 25
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: PUSH
12888: LD_INT 25
12890: PUSH
12891: LD_INT 4
12893: PUSH
12894: EMPTY
12895: LIST
12896: LIST
12897: PUSH
12898: LD_INT 25
12900: PUSH
12901: LD_INT 5
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: PUSH
12908: LD_INT 25
12910: PUSH
12911: LD_INT 8
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: LD_INT 25
12920: PUSH
12921: LD_INT 9
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: LIST
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PPUSH
12942: CALL_OW 69
12946: IN
12947: IFFALSE 12963
// loss_counter := loss_counter + 1 ;
12949: LD_ADDR_EXP 13
12953: PUSH
12954: LD_EXP 13
12958: PUSH
12959: LD_INT 1
12961: PLUS
12962: ST_TO_ADDR
// if un = Abdul then
12963: LD_VAR 0 1
12967: PUSH
12968: LD_EXP 54
12972: EQUAL
12973: IFFALSE 12983
// abdul_escaped := false ;
12975: LD_ADDR_EXP 12
12979: PUSH
12980: LD_INT 0
12982: ST_TO_ADDR
// if un in ru_attackers then
12983: LD_VAR 0 1
12987: PUSH
12988: LD_EXP 51
12992: IN
12993: IFFALSE 13011
// ru_attackers := ru_attackers diff un ;
12995: LD_ADDR_EXP 51
12999: PUSH
13000: LD_EXP 51
13004: PUSH
13005: LD_VAR 0 1
13009: DIFF
13010: ST_TO_ADDR
// if un in ar_attackers then
13011: LD_VAR 0 1
13015: PUSH
13016: LD_EXP 10
13020: IN
13021: IFFALSE 13039
// ar_attackers := ar_attackers diff un ;
13023: LD_ADDR_EXP 10
13027: PUSH
13028: LD_EXP 10
13032: PUSH
13033: LD_VAR 0 1
13037: DIFF
13038: ST_TO_ADDR
// if un = JMM then
13039: LD_VAR 0 1
13043: PUSH
13044: LD_EXP 14
13048: EQUAL
13049: IFFALSE 13060
// begin YouLost ( JMM ) ;
13051: LD_STRING JMM
13053: PPUSH
13054: CALL_OW 104
// exit ;
13058: GO 13149
// end ; if un = Burlak then
13060: LD_VAR 0 1
13064: PUSH
13065: LD_EXP 45
13069: EQUAL
13070: IFFALSE 13081
// begin YouLost ( Burlak ) ;
13072: LD_STRING Burlak
13074: PPUSH
13075: CALL_OW 104
// exit ;
13079: GO 13149
// end ; if un = freedom then
13081: LD_VAR 0 1
13085: PUSH
13086: LD_EXP 3
13090: EQUAL
13091: IFFALSE 13102
// begin YouLost ( Destroyed ) ;
13093: LD_STRING Destroyed
13095: PPUSH
13096: CALL_OW 104
// exit ;
13100: GO 13149
// end ; if un = Masha then
13102: LD_VAR 0 1
13106: PUSH
13107: LD_EXP 48
13111: EQUAL
13112: IFFALSE 13121
// ChangeMissionObjectives ( M4b ) ;
13114: LD_STRING M4b
13116: PPUSH
13117: CALL_OW 337
// if un = Mastodont then
13121: LD_VAR 0 1
13125: PUSH
13126: LD_EXP 55
13130: EQUAL
13131: IFFALSE 13140
// ChangeMissionObjectives ( M4a ) ;
13133: LD_STRING M4a
13135: PPUSH
13136: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13140: LD_VAR 0 1
13144: PPUSH
13145: CALL 84327 0 1
// end ;
13149: PPOPN 3
13151: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13152: LD_VAR 0 1
13156: PPUSH
13157: LD_VAR 0 2
13161: PPUSH
13162: CALL 86661 0 2
// end ;
13166: PPOPN 2
13168: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13169: LD_VAR 0 1
13173: PPUSH
13174: CALL 85729 0 1
// end ;
13178: PPOPN 1
13180: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13181: LD_VAR 0 1
13185: PUSH
13186: LD_INT 22
13188: PUSH
13189: LD_INT 7
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 30
13198: PUSH
13199: LD_INT 0
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PPUSH
13210: CALL_OW 69
13214: IN
13215: IFFALSE 13254
// begin SetBName ( building , freedom ) ;
13217: LD_VAR 0 1
13221: PPUSH
13222: LD_STRING freedom
13224: PPUSH
13225: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13229: LD_INT 0
13231: PPUSH
13232: LD_INT 7
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 324
// freedom := building ;
13242: LD_ADDR_EXP 3
13246: PUSH
13247: LD_VAR 0 1
13251: ST_TO_ADDR
// exit ;
13252: GO 13320
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13254: LD_VAR 0 1
13258: PUSH
13259: LD_INT 22
13261: PUSH
13262: LD_INT 7
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: PUSH
13269: LD_INT 23
13271: PUSH
13272: LD_INT 3
13274: PUSH
13275: EMPTY
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 30
13281: PUSH
13282: LD_INT 6
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: LIST
13293: PPUSH
13294: CALL_OW 69
13298: IN
13299: IFFALSE 13311
// begin ru_lab_builded := true ;
13301: LD_ADDR_EXP 5
13305: PUSH
13306: LD_INT 1
13308: ST_TO_ADDR
// exit ;
13309: GO 13320
// end ; MCE_BuildingComplete ( building ) ;
13311: LD_VAR 0 1
13315: PPUSH
13316: CALL 85970 0 1
// end ;
13320: PPOPN 1
13322: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13323: LD_VAR 0 1
13327: PPUSH
13328: LD_VAR 0 2
13332: PPUSH
13333: CALL 84023 0 2
// end ;
13337: PPOPN 2
13339: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13340: LD_VAR 0 1
13344: PPUSH
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_VAR 0 3
13354: PPUSH
13355: LD_VAR 0 4
13359: PPUSH
13360: LD_VAR 0 5
13364: PPUSH
13365: CALL 83643 0 5
// end ;
13369: PPOPN 5
13371: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13372: LD_VAR 0 1
13376: PPUSH
13377: LD_VAR 0 2
13381: PPUSH
13382: CALL 83239 0 2
// end ;
13386: PPOPN 2
13388: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13389: LD_VAR 0 1
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: LD_VAR 0 3
13403: PPUSH
13404: LD_VAR 0 4
13408: PPUSH
13409: CALL 83077 0 4
// end ;
13413: PPOPN 4
13415: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13416: LD_VAR 0 1
13420: PPUSH
13421: LD_VAR 0 2
13425: PPUSH
13426: LD_VAR 0 3
13430: PPUSH
13431: CALL 82852 0 3
// end ;
13435: PPOPN 3
13437: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: CALL 82737 0 2
// end ;
13452: PPOPN 2
13454: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_VAR 0 2
13464: PPUSH
13465: CALL 86922 0 2
// end ;
13469: PPOPN 2
13471: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13472: LD_VAR 0 1
13476: PPUSH
13477: LD_VAR 0 2
13481: PPUSH
13482: LD_VAR 0 3
13486: PPUSH
13487: LD_VAR 0 4
13491: PPUSH
13492: CALL 87138 0 4
// end ;
13496: PPOPN 4
13498: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13499: LD_VAR 0 1
13503: PPUSH
13504: LD_VAR 0 2
13508: PPUSH
13509: CALL 82546 0 2
// end ;
13513: PPOPN 2
13515: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13516: LD_VAR 0 1
13520: PPUSH
13521: CALL 87421 0 1
// end ; end_of_file
13525: PPOPN 1
13527: END
// every 0 0$30 do var cr , time ;
13528: GO 13530
13530: DISABLE
13531: LD_INT 0
13533: PPUSH
13534: PPUSH
// begin time := 0 0$30 ;
13535: LD_ADDR_VAR 0 2
13539: PUSH
13540: LD_INT 1050
13542: ST_TO_ADDR
// while game do
13543: LD_EXP 2
13547: IFFALSE 13646
// begin wait ( time ) ;
13549: LD_VAR 0 2
13553: PPUSH
13554: CALL_OW 67
// if tick > 2 2$00 then
13558: LD_OWVAR 1
13562: PUSH
13563: LD_INT 4200
13565: GREATER
13566: IFFALSE 13599
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13568: LD_ADDR_VAR 0 2
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: LD_INT 280
13580: PUSH
13581: LD_INT 420
13583: PUSH
13584: LD_INT 630
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: PUSH
13592: LD_OWVAR 67
13596: ARRAY
13597: PLUS
13598: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13599: LD_INT 1
13601: PPUSH
13602: LD_INT 5
13604: PPUSH
13605: CALL_OW 12
13609: PPUSH
13610: LD_INT 70
13612: PPUSH
13613: LD_INT 49
13615: PPUSH
13616: LD_INT 25
13618: PPUSH
13619: LD_INT 1
13621: PPUSH
13622: CALL_OW 56
// if time > 5 5$00 then
13626: LD_VAR 0 2
13630: PUSH
13631: LD_INT 10500
13633: GREATER
13634: IFFALSE 13644
// time := 0 0$30 ;
13636: LD_ADDR_VAR 0 2
13640: PUSH
13641: LD_INT 1050
13643: ST_TO_ADDR
// end ;
13644: GO 13543
// end ;
13646: PPOPN 2
13648: END
// every 0 0$30 do var cr , time ;
13649: GO 13651
13651: DISABLE
13652: LD_INT 0
13654: PPUSH
13655: PPUSH
// begin time := 0 0$20 ;
13656: LD_ADDR_VAR 0 2
13660: PUSH
13661: LD_INT 700
13663: ST_TO_ADDR
// while game do
13664: LD_EXP 2
13668: IFFALSE 13757
// begin wait ( time ) ;
13670: LD_VAR 0 2
13674: PPUSH
13675: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13679: LD_ADDR_VAR 0 2
13683: PUSH
13684: LD_VAR 0 2
13688: PUSH
13689: LD_INT 490
13691: PUSH
13692: LD_INT 525
13694: PUSH
13695: LD_INT 560
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: LD_OWVAR 67
13707: ARRAY
13708: PLUS
13709: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13710: LD_INT 3
13712: PPUSH
13713: LD_INT 5
13715: PPUSH
13716: CALL_OW 12
13720: PPUSH
13721: LD_INT 26
13723: PPUSH
13724: LD_INT 9
13726: PPUSH
13727: LD_INT 30
13729: PPUSH
13730: LD_INT 1
13732: PPUSH
13733: CALL_OW 56
// if time > 3 3$00 then
13737: LD_VAR 0 2
13741: PUSH
13742: LD_INT 6300
13744: GREATER
13745: IFFALSE 13755
// time := 0 0$20 ;
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: LD_INT 700
13754: ST_TO_ADDR
// end ;
13755: GO 13664
// end ;
13757: PPOPN 2
13759: END
// every 0 0$30 do var cr , time ;
13760: GO 13762
13762: DISABLE
13763: LD_INT 0
13765: PPUSH
13766: PPUSH
// begin time := 0 0$20 ;
13767: LD_ADDR_VAR 0 2
13771: PUSH
13772: LD_INT 700
13774: ST_TO_ADDR
// while game do
13775: LD_EXP 2
13779: IFFALSE 13904
// begin wait ( time ) ;
13781: LD_VAR 0 2
13785: PPUSH
13786: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13790: LD_ADDR_VAR 0 2
13794: PUSH
13795: LD_VAR 0 2
13799: PUSH
13800: LD_INT 175
13802: PUSH
13803: LD_INT 210
13805: PUSH
13806: LD_INT 280
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: PUSH
13814: LD_OWVAR 67
13818: ARRAY
13819: PLUS
13820: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13821: LD_INT 1
13823: PPUSH
13824: LD_INT 5
13826: PPUSH
13827: CALL_OW 12
13831: PPUSH
13832: LD_INT 179
13834: PPUSH
13835: LD_INT 101
13837: PPUSH
13838: LD_INT 20
13840: PPUSH
13841: LD_INT 1
13843: PPUSH
13844: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13848: LD_INT 350
13850: PPUSH
13851: LD_INT 525
13853: PPUSH
13854: CALL_OW 12
13858: PPUSH
13859: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13863: LD_INT 1
13865: PPUSH
13866: LD_INT 5
13868: PPUSH
13869: CALL_OW 12
13873: PPUSH
13874: LD_INT 9
13876: PPUSH
13877: LD_INT 1
13879: PPUSH
13880: CALL_OW 55
// if time > 4 4$00 then
13884: LD_VAR 0 2
13888: PUSH
13889: LD_INT 8400
13891: GREATER
13892: IFFALSE 13902
// time := 0 0$30 ;
13894: LD_ADDR_VAR 0 2
13898: PUSH
13899: LD_INT 1050
13901: ST_TO_ADDR
// end ;
13902: GO 13775
// end ;
13904: PPOPN 2
13906: END
// every 0 0$30 do var cr , time ;
13907: GO 13909
13909: DISABLE
13910: LD_INT 0
13912: PPUSH
13913: PPUSH
// begin time := 0 0$10 ;
13914: LD_ADDR_VAR 0 2
13918: PUSH
13919: LD_INT 350
13921: ST_TO_ADDR
// while game do
13922: LD_EXP 2
13926: IFFALSE 14060
// begin wait ( time ) ;
13928: LD_VAR 0 2
13932: PPUSH
13933: CALL_OW 67
// time := time + 0 0$10 ;
13937: LD_ADDR_VAR 0 2
13941: PUSH
13942: LD_VAR 0 2
13946: PUSH
13947: LD_INT 350
13949: PLUS
13950: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13951: LD_INT 1
13953: PPUSH
13954: LD_INT 5
13956: PPUSH
13957: CALL_OW 12
13961: PPUSH
13962: LD_INT 11
13964: PPUSH
13965: LD_INT 1
13967: PPUSH
13968: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13972: LD_ADDR_VAR 0 1
13976: PUSH
13977: LD_INT 1
13979: PPUSH
13980: LD_INT 3
13982: PPUSH
13983: CALL_OW 12
13987: ST_TO_ADDR
// if cr = 1 then
13988: LD_VAR 0 1
13992: PUSH
13993: LD_INT 1
13995: EQUAL
13996: IFFALSE 14040
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13998: LD_INT 700
14000: PPUSH
14001: LD_INT 1575
14003: PPUSH
14004: CALL_OW 12
14008: PPUSH
14009: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14013: LD_INT 1
14015: PPUSH
14016: LD_INT 5
14018: PPUSH
14019: CALL_OW 12
14023: PPUSH
14024: LD_INT 34
14026: PPUSH
14027: LD_INT 50
14029: PPUSH
14030: LD_INT 7
14032: PPUSH
14033: LD_INT 1
14035: PPUSH
14036: CALL_OW 56
// end ; if time > 8 8$00 then
14040: LD_VAR 0 2
14044: PUSH
14045: LD_INT 16800
14047: GREATER
14048: IFFALSE 14058
// time := 0 0$40 ;
14050: LD_ADDR_VAR 0 2
14054: PUSH
14055: LD_INT 1400
14057: ST_TO_ADDR
// end ;
14058: GO 13922
// end ; end_of_file
14060: PPOPN 2
14062: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14063: LD_INT 0
14065: PPUSH
14066: PPUSH
// if exist_mode then
14067: LD_VAR 0 2
14071: IFFALSE 14096
// unit := CreateCharacter ( prefix & ident ) else
14073: LD_ADDR_VAR 0 5
14077: PUSH
14078: LD_VAR 0 3
14082: PUSH
14083: LD_VAR 0 1
14087: STR
14088: PPUSH
14089: CALL_OW 34
14093: ST_TO_ADDR
14094: GO 14111
// unit := NewCharacter ( ident ) ;
14096: LD_ADDR_VAR 0 5
14100: PUSH
14101: LD_VAR 0 1
14105: PPUSH
14106: CALL_OW 25
14110: ST_TO_ADDR
// result := unit ;
14111: LD_ADDR_VAR 0 4
14115: PUSH
14116: LD_VAR 0 5
14120: ST_TO_ADDR
// end ;
14121: LD_VAR 0 4
14125: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14126: LD_INT 0
14128: PPUSH
14129: PPUSH
// if not side or not nation then
14130: LD_VAR 0 1
14134: NOT
14135: PUSH
14136: LD_VAR 0 2
14140: NOT
14141: OR
14142: IFFALSE 14146
// exit ;
14144: GO 14790
// case nation of nation_american :
14146: LD_VAR 0 2
14150: PUSH
14151: LD_INT 1
14153: DOUBLE
14154: EQUAL
14155: IFTRUE 14159
14157: GO 14333
14159: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14160: LD_ADDR_VAR 0 4
14164: PUSH
14165: LD_INT 35
14167: PUSH
14168: LD_INT 45
14170: PUSH
14171: LD_INT 46
14173: PUSH
14174: LD_INT 47
14176: PUSH
14177: LD_INT 1
14179: PUSH
14180: LD_INT 2
14182: PUSH
14183: LD_INT 6
14185: PUSH
14186: LD_INT 15
14188: PUSH
14189: LD_INT 16
14191: PUSH
14192: LD_INT 7
14194: PUSH
14195: LD_INT 12
14197: PUSH
14198: LD_INT 13
14200: PUSH
14201: LD_INT 10
14203: PUSH
14204: LD_INT 14
14206: PUSH
14207: LD_INT 20
14209: PUSH
14210: LD_INT 21
14212: PUSH
14213: LD_INT 22
14215: PUSH
14216: LD_INT 25
14218: PUSH
14219: LD_INT 32
14221: PUSH
14222: LD_INT 27
14224: PUSH
14225: LD_INT 36
14227: PUSH
14228: LD_INT 69
14230: PUSH
14231: LD_INT 39
14233: PUSH
14234: LD_INT 34
14236: PUSH
14237: LD_INT 40
14239: PUSH
14240: LD_INT 48
14242: PUSH
14243: LD_INT 49
14245: PUSH
14246: LD_INT 50
14248: PUSH
14249: LD_INT 51
14251: PUSH
14252: LD_INT 52
14254: PUSH
14255: LD_INT 53
14257: PUSH
14258: LD_INT 54
14260: PUSH
14261: LD_INT 55
14263: PUSH
14264: LD_INT 56
14266: PUSH
14267: LD_INT 57
14269: PUSH
14270: LD_INT 58
14272: PUSH
14273: LD_INT 59
14275: PUSH
14276: LD_INT 60
14278: PUSH
14279: LD_INT 61
14281: PUSH
14282: LD_INT 62
14284: PUSH
14285: LD_INT 80
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: ST_TO_ADDR
14331: GO 14714
14333: LD_INT 2
14335: DOUBLE
14336: EQUAL
14337: IFTRUE 14341
14339: GO 14523
14341: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14342: LD_ADDR_VAR 0 4
14346: PUSH
14347: LD_INT 35
14349: PUSH
14350: LD_INT 45
14352: PUSH
14353: LD_INT 46
14355: PUSH
14356: LD_INT 47
14358: PUSH
14359: LD_INT 70
14361: PUSH
14362: LD_INT 1
14364: PUSH
14365: LD_INT 11
14367: PUSH
14368: LD_INT 3
14370: PUSH
14371: LD_INT 4
14373: PUSH
14374: LD_INT 5
14376: PUSH
14377: LD_INT 6
14379: PUSH
14380: LD_INT 15
14382: PUSH
14383: LD_INT 18
14385: PUSH
14386: LD_INT 7
14388: PUSH
14389: LD_INT 17
14391: PUSH
14392: LD_INT 8
14394: PUSH
14395: LD_INT 20
14397: PUSH
14398: LD_INT 21
14400: PUSH
14401: LD_INT 22
14403: PUSH
14404: LD_INT 72
14406: PUSH
14407: LD_INT 26
14409: PUSH
14410: LD_INT 69
14412: PUSH
14413: LD_INT 39
14415: PUSH
14416: LD_INT 40
14418: PUSH
14419: LD_INT 41
14421: PUSH
14422: LD_INT 42
14424: PUSH
14425: LD_INT 43
14427: PUSH
14428: LD_INT 48
14430: PUSH
14431: LD_INT 49
14433: PUSH
14434: LD_INT 50
14436: PUSH
14437: LD_INT 51
14439: PUSH
14440: LD_INT 52
14442: PUSH
14443: LD_INT 53
14445: PUSH
14446: LD_INT 54
14448: PUSH
14449: LD_INT 55
14451: PUSH
14452: LD_INT 56
14454: PUSH
14455: LD_INT 60
14457: PUSH
14458: LD_INT 61
14460: PUSH
14461: LD_INT 62
14463: PUSH
14464: LD_INT 66
14466: PUSH
14467: LD_INT 67
14469: PUSH
14470: LD_INT 68
14472: PUSH
14473: LD_INT 81
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: ST_TO_ADDR
14521: GO 14714
14523: LD_INT 3
14525: DOUBLE
14526: EQUAL
14527: IFTRUE 14531
14529: GO 14713
14531: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14532: LD_ADDR_VAR 0 4
14536: PUSH
14537: LD_INT 46
14539: PUSH
14540: LD_INT 47
14542: PUSH
14543: LD_INT 1
14545: PUSH
14546: LD_INT 2
14548: PUSH
14549: LD_INT 11
14551: PUSH
14552: LD_INT 9
14554: PUSH
14555: LD_INT 20
14557: PUSH
14558: LD_INT 19
14560: PUSH
14561: LD_INT 21
14563: PUSH
14564: LD_INT 24
14566: PUSH
14567: LD_INT 22
14569: PUSH
14570: LD_INT 25
14572: PUSH
14573: LD_INT 28
14575: PUSH
14576: LD_INT 29
14578: PUSH
14579: LD_INT 30
14581: PUSH
14582: LD_INT 31
14584: PUSH
14585: LD_INT 37
14587: PUSH
14588: LD_INT 38
14590: PUSH
14591: LD_INT 32
14593: PUSH
14594: LD_INT 27
14596: PUSH
14597: LD_INT 33
14599: PUSH
14600: LD_INT 69
14602: PUSH
14603: LD_INT 39
14605: PUSH
14606: LD_INT 34
14608: PUSH
14609: LD_INT 40
14611: PUSH
14612: LD_INT 71
14614: PUSH
14615: LD_INT 23
14617: PUSH
14618: LD_INT 44
14620: PUSH
14621: LD_INT 48
14623: PUSH
14624: LD_INT 49
14626: PUSH
14627: LD_INT 50
14629: PUSH
14630: LD_INT 51
14632: PUSH
14633: LD_INT 52
14635: PUSH
14636: LD_INT 53
14638: PUSH
14639: LD_INT 54
14641: PUSH
14642: LD_INT 55
14644: PUSH
14645: LD_INT 56
14647: PUSH
14648: LD_INT 57
14650: PUSH
14651: LD_INT 58
14653: PUSH
14654: LD_INT 59
14656: PUSH
14657: LD_INT 63
14659: PUSH
14660: LD_INT 64
14662: PUSH
14663: LD_INT 65
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: ST_TO_ADDR
14711: GO 14714
14713: POP
// if state > - 1 and state < 3 then
14714: LD_VAR 0 3
14718: PUSH
14719: LD_INT 1
14721: NEG
14722: GREATER
14723: PUSH
14724: LD_VAR 0 3
14728: PUSH
14729: LD_INT 3
14731: LESS
14732: AND
14733: IFFALSE 14790
// for i in result do
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 4
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14788
// if GetTech ( i , side ) <> state then
14748: LD_VAR 0 5
14752: PPUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 321
14762: PUSH
14763: LD_VAR 0 3
14767: NONEQUAL
14768: IFFALSE 14786
// result := result diff i ;
14770: LD_ADDR_VAR 0 4
14774: PUSH
14775: LD_VAR 0 4
14779: PUSH
14780: LD_VAR 0 5
14784: DIFF
14785: ST_TO_ADDR
14786: GO 14745
14788: POP
14789: POP
// end ;
14790: LD_VAR 0 4
14794: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14795: LD_INT 0
14797: PPUSH
14798: PPUSH
14799: PPUSH
// result := true ;
14800: LD_ADDR_VAR 0 3
14804: PUSH
14805: LD_INT 1
14807: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14808: LD_ADDR_VAR 0 5
14812: PUSH
14813: LD_VAR 0 2
14817: PPUSH
14818: CALL_OW 480
14822: ST_TO_ADDR
// if not tmp then
14823: LD_VAR 0 5
14827: NOT
14828: IFFALSE 14832
// exit ;
14830: GO 14881
// for i in tmp do
14832: LD_ADDR_VAR 0 4
14836: PUSH
14837: LD_VAR 0 5
14841: PUSH
14842: FOR_IN
14843: IFFALSE 14879
// if GetTech ( i , side ) <> state_researched then
14845: LD_VAR 0 4
14849: PPUSH
14850: LD_VAR 0 1
14854: PPUSH
14855: CALL_OW 321
14859: PUSH
14860: LD_INT 2
14862: NONEQUAL
14863: IFFALSE 14877
// begin result := false ;
14865: LD_ADDR_VAR 0 3
14869: PUSH
14870: LD_INT 0
14872: ST_TO_ADDR
// exit ;
14873: POP
14874: POP
14875: GO 14881
// end ;
14877: GO 14842
14879: POP
14880: POP
// end ;
14881: LD_VAR 0 3
14885: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14886: LD_INT 0
14888: PPUSH
14889: PPUSH
14890: PPUSH
14891: PPUSH
14892: PPUSH
14893: PPUSH
14894: PPUSH
14895: PPUSH
14896: PPUSH
14897: PPUSH
14898: PPUSH
14899: PPUSH
14900: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14901: LD_VAR 0 1
14905: NOT
14906: PUSH
14907: LD_VAR 0 1
14911: PPUSH
14912: CALL_OW 257
14916: PUSH
14917: LD_INT 9
14919: NONEQUAL
14920: OR
14921: IFFALSE 14925
// exit ;
14923: GO 15498
// side := GetSide ( unit ) ;
14925: LD_ADDR_VAR 0 9
14929: PUSH
14930: LD_VAR 0 1
14934: PPUSH
14935: CALL_OW 255
14939: ST_TO_ADDR
// tech_space := tech_spacanom ;
14940: LD_ADDR_VAR 0 12
14944: PUSH
14945: LD_INT 29
14947: ST_TO_ADDR
// tech_time := tech_taurad ;
14948: LD_ADDR_VAR 0 13
14952: PUSH
14953: LD_INT 28
14955: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14956: LD_ADDR_VAR 0 11
14960: PUSH
14961: LD_VAR 0 1
14965: PPUSH
14966: CALL_OW 310
14970: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14971: LD_VAR 0 11
14975: PPUSH
14976: CALL_OW 247
14980: PUSH
14981: LD_INT 2
14983: EQUAL
14984: IFFALSE 14988
// exit ;
14986: GO 15498
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14988: LD_ADDR_VAR 0 8
14992: PUSH
14993: LD_INT 81
14995: PUSH
14996: LD_VAR 0 9
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: PUSH
15005: LD_INT 3
15007: PUSH
15008: LD_INT 21
15010: PUSH
15011: LD_INT 3
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PPUSH
15026: CALL_OW 69
15030: ST_TO_ADDR
// if not tmp then
15031: LD_VAR 0 8
15035: NOT
15036: IFFALSE 15040
// exit ;
15038: GO 15498
// if in_unit then
15040: LD_VAR 0 11
15044: IFFALSE 15068
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15046: LD_ADDR_VAR 0 10
15050: PUSH
15051: LD_VAR 0 8
15055: PPUSH
15056: LD_VAR 0 11
15060: PPUSH
15061: CALL_OW 74
15065: ST_TO_ADDR
15066: GO 15088
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15068: LD_ADDR_VAR 0 10
15072: PUSH
15073: LD_VAR 0 8
15077: PPUSH
15078: LD_VAR 0 1
15082: PPUSH
15083: CALL_OW 74
15087: ST_TO_ADDR
// if not enemy then
15088: LD_VAR 0 10
15092: NOT
15093: IFFALSE 15097
// exit ;
15095: GO 15498
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15097: LD_VAR 0 11
15101: PUSH
15102: LD_VAR 0 11
15106: PPUSH
15107: LD_VAR 0 10
15111: PPUSH
15112: CALL_OW 296
15116: PUSH
15117: LD_INT 13
15119: GREATER
15120: AND
15121: PUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: LD_VAR 0 10
15131: PPUSH
15132: CALL_OW 296
15136: PUSH
15137: LD_INT 12
15139: GREATER
15140: OR
15141: IFFALSE 15145
// exit ;
15143: GO 15498
// missile := [ 1 ] ;
15145: LD_ADDR_VAR 0 14
15149: PUSH
15150: LD_INT 1
15152: PUSH
15153: EMPTY
15154: LIST
15155: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15156: LD_VAR 0 9
15160: PPUSH
15161: LD_VAR 0 12
15165: PPUSH
15166: CALL_OW 325
15170: IFFALSE 15199
// missile := Insert ( missile , missile + 1 , 2 ) ;
15172: LD_ADDR_VAR 0 14
15176: PUSH
15177: LD_VAR 0 14
15181: PPUSH
15182: LD_VAR 0 14
15186: PUSH
15187: LD_INT 1
15189: PLUS
15190: PPUSH
15191: LD_INT 2
15193: PPUSH
15194: CALL_OW 2
15198: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15199: LD_VAR 0 9
15203: PPUSH
15204: LD_VAR 0 13
15208: PPUSH
15209: CALL_OW 325
15213: PUSH
15214: LD_VAR 0 10
15218: PPUSH
15219: CALL_OW 255
15223: PPUSH
15224: LD_VAR 0 13
15228: PPUSH
15229: CALL_OW 325
15233: NOT
15234: AND
15235: IFFALSE 15264
// missile := Insert ( missile , missile + 1 , 3 ) ;
15237: LD_ADDR_VAR 0 14
15241: PUSH
15242: LD_VAR 0 14
15246: PPUSH
15247: LD_VAR 0 14
15251: PUSH
15252: LD_INT 1
15254: PLUS
15255: PPUSH
15256: LD_INT 3
15258: PPUSH
15259: CALL_OW 2
15263: ST_TO_ADDR
// if missile < 2 then
15264: LD_VAR 0 14
15268: PUSH
15269: LD_INT 2
15271: LESS
15272: IFFALSE 15276
// exit ;
15274: GO 15498
// x := GetX ( enemy ) ;
15276: LD_ADDR_VAR 0 4
15280: PUSH
15281: LD_VAR 0 10
15285: PPUSH
15286: CALL_OW 250
15290: ST_TO_ADDR
// y := GetY ( enemy ) ;
15291: LD_ADDR_VAR 0 5
15295: PUSH
15296: LD_VAR 0 10
15300: PPUSH
15301: CALL_OW 251
15305: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15306: LD_ADDR_VAR 0 6
15310: PUSH
15311: LD_VAR 0 4
15315: PUSH
15316: LD_INT 1
15318: NEG
15319: PPUSH
15320: LD_INT 1
15322: PPUSH
15323: CALL_OW 12
15327: PLUS
15328: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15329: LD_ADDR_VAR 0 7
15333: PUSH
15334: LD_VAR 0 5
15338: PUSH
15339: LD_INT 1
15341: NEG
15342: PPUSH
15343: LD_INT 1
15345: PPUSH
15346: CALL_OW 12
15350: PLUS
15351: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15352: LD_VAR 0 6
15356: PPUSH
15357: LD_VAR 0 7
15361: PPUSH
15362: CALL_OW 488
15366: NOT
15367: IFFALSE 15389
// begin _x := x ;
15369: LD_ADDR_VAR 0 6
15373: PUSH
15374: LD_VAR 0 4
15378: ST_TO_ADDR
// _y := y ;
15379: LD_ADDR_VAR 0 7
15383: PUSH
15384: LD_VAR 0 5
15388: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15389: LD_ADDR_VAR 0 3
15393: PUSH
15394: LD_INT 1
15396: PPUSH
15397: LD_VAR 0 14
15401: PPUSH
15402: CALL_OW 12
15406: ST_TO_ADDR
// case i of 1 :
15407: LD_VAR 0 3
15411: PUSH
15412: LD_INT 1
15414: DOUBLE
15415: EQUAL
15416: IFTRUE 15420
15418: GO 15437
15420: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15421: LD_VAR 0 1
15425: PPUSH
15426: LD_VAR 0 10
15430: PPUSH
15431: CALL_OW 115
15435: GO 15498
15437: LD_INT 2
15439: DOUBLE
15440: EQUAL
15441: IFTRUE 15445
15443: GO 15467
15445: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15446: LD_VAR 0 1
15450: PPUSH
15451: LD_VAR 0 6
15455: PPUSH
15456: LD_VAR 0 7
15460: PPUSH
15461: CALL_OW 153
15465: GO 15498
15467: LD_INT 3
15469: DOUBLE
15470: EQUAL
15471: IFTRUE 15475
15473: GO 15497
15475: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15476: LD_VAR 0 1
15480: PPUSH
15481: LD_VAR 0 6
15485: PPUSH
15486: LD_VAR 0 7
15490: PPUSH
15491: CALL_OW 154
15495: GO 15498
15497: POP
// end ;
15498: LD_VAR 0 2
15502: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15503: LD_INT 0
15505: PPUSH
15506: PPUSH
15507: PPUSH
15508: PPUSH
15509: PPUSH
15510: PPUSH
// if not unit or not building then
15511: LD_VAR 0 1
15515: NOT
15516: PUSH
15517: LD_VAR 0 2
15521: NOT
15522: OR
15523: IFFALSE 15527
// exit ;
15525: GO 15685
// x := GetX ( building ) ;
15527: LD_ADDR_VAR 0 5
15531: PUSH
15532: LD_VAR 0 2
15536: PPUSH
15537: CALL_OW 250
15541: ST_TO_ADDR
// y := GetY ( building ) ;
15542: LD_ADDR_VAR 0 6
15546: PUSH
15547: LD_VAR 0 2
15551: PPUSH
15552: CALL_OW 251
15556: ST_TO_ADDR
// for i = 0 to 5 do
15557: LD_ADDR_VAR 0 4
15561: PUSH
15562: DOUBLE
15563: LD_INT 0
15565: DEC
15566: ST_TO_ADDR
15567: LD_INT 5
15569: PUSH
15570: FOR_TO
15571: IFFALSE 15683
// begin _x := ShiftX ( x , i , 3 ) ;
15573: LD_ADDR_VAR 0 7
15577: PUSH
15578: LD_VAR 0 5
15582: PPUSH
15583: LD_VAR 0 4
15587: PPUSH
15588: LD_INT 3
15590: PPUSH
15591: CALL_OW 272
15595: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15596: LD_ADDR_VAR 0 8
15600: PUSH
15601: LD_VAR 0 6
15605: PPUSH
15606: LD_VAR 0 4
15610: PPUSH
15611: LD_INT 3
15613: PPUSH
15614: CALL_OW 273
15618: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15619: LD_VAR 0 7
15623: PPUSH
15624: LD_VAR 0 8
15628: PPUSH
15629: CALL_OW 488
15633: NOT
15634: IFFALSE 15638
// continue ;
15636: GO 15570
// if HexInfo ( _x , _y ) = 0 then
15638: LD_VAR 0 7
15642: PPUSH
15643: LD_VAR 0 8
15647: PPUSH
15648: CALL_OW 428
15652: PUSH
15653: LD_INT 0
15655: EQUAL
15656: IFFALSE 15681
// begin ComMoveXY ( unit , _x , _y ) ;
15658: LD_VAR 0 1
15662: PPUSH
15663: LD_VAR 0 7
15667: PPUSH
15668: LD_VAR 0 8
15672: PPUSH
15673: CALL_OW 111
// exit ;
15677: POP
15678: POP
15679: GO 15685
// end ; end ;
15681: GO 15570
15683: POP
15684: POP
// end ;
15685: LD_VAR 0 3
15689: RET
// export function ScanBase ( side , base_area ) ; begin
15690: LD_INT 0
15692: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: LD_VAR 0 2
15702: PPUSH
15703: LD_INT 81
15705: PUSH
15706: LD_VAR 0 1
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PPUSH
15715: CALL_OW 70
15719: ST_TO_ADDR
// end ;
15720: LD_VAR 0 3
15724: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15725: LD_INT 0
15727: PPUSH
15728: PPUSH
15729: PPUSH
15730: PPUSH
15731: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15732: LD_VAR 0 1
15736: NOT
15737: PUSH
15738: LD_EXP 58
15742: PUSH
15743: LD_VAR 0 1
15747: ARRAY
15748: NOT
15749: OR
15750: PUSH
15751: LD_VAR 0 2
15755: NOT
15756: OR
15757: PUSH
15758: LD_VAR 0 3
15762: NOT
15763: OR
15764: IFFALSE 15768
// exit ;
15766: GO 16281
// side := mc_sides [ base ] ;
15768: LD_ADDR_VAR 0 6
15772: PUSH
15773: LD_EXP 84
15777: PUSH
15778: LD_VAR 0 1
15782: ARRAY
15783: ST_TO_ADDR
// if not side then
15784: LD_VAR 0 6
15788: NOT
15789: IFFALSE 15793
// exit ;
15791: GO 16281
// for i in solds do
15793: LD_ADDR_VAR 0 7
15797: PUSH
15798: LD_VAR 0 2
15802: PUSH
15803: FOR_IN
15804: IFFALSE 15865
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15806: LD_VAR 0 7
15810: PPUSH
15811: CALL_OW 310
15815: PPUSH
15816: CALL_OW 266
15820: PUSH
15821: LD_INT 32
15823: PUSH
15824: LD_INT 31
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: IN
15831: IFFALSE 15851
// solds := solds diff i else
15833: LD_ADDR_VAR 0 2
15837: PUSH
15838: LD_VAR 0 2
15842: PUSH
15843: LD_VAR 0 7
15847: DIFF
15848: ST_TO_ADDR
15849: GO 15863
// SetTag ( i , 18 ) ;
15851: LD_VAR 0 7
15855: PPUSH
15856: LD_INT 18
15858: PPUSH
15859: CALL_OW 109
15863: GO 15803
15865: POP
15866: POP
// if not solds then
15867: LD_VAR 0 2
15871: NOT
15872: IFFALSE 15876
// exit ;
15874: GO 16281
// repeat wait ( 0 0$1 ) ;
15876: LD_INT 35
15878: PPUSH
15879: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15883: LD_ADDR_VAR 0 5
15887: PUSH
15888: LD_VAR 0 6
15892: PPUSH
15893: LD_VAR 0 3
15897: PPUSH
15898: CALL 15690 0 2
15902: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15903: LD_EXP 58
15907: PUSH
15908: LD_VAR 0 1
15912: ARRAY
15913: NOT
15914: PUSH
15915: LD_EXP 58
15919: PUSH
15920: LD_VAR 0 1
15924: ARRAY
15925: PUSH
15926: EMPTY
15927: EQUAL
15928: OR
15929: IFFALSE 15966
// begin for i in solds do
15931: LD_ADDR_VAR 0 7
15935: PUSH
15936: LD_VAR 0 2
15940: PUSH
15941: FOR_IN
15942: IFFALSE 15955
// ComStop ( i ) ;
15944: LD_VAR 0 7
15948: PPUSH
15949: CALL_OW 141
15953: GO 15941
15955: POP
15956: POP
// solds := [ ] ;
15957: LD_ADDR_VAR 0 2
15961: PUSH
15962: EMPTY
15963: ST_TO_ADDR
// exit ;
15964: GO 16281
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
15966: LD_VAR 0 5
15970: NOT
15971: PUSH
15972: LD_VAR 0 5
15976: PUSH
15977: LD_INT 3
15979: GREATER
15980: OR
15981: PUSH
15982: LD_EXP 80
15986: PUSH
15987: LD_VAR 0 1
15991: ARRAY
15992: OR
15993: IFFALSE 16034
// begin for i in solds do
15995: LD_ADDR_VAR 0 7
15999: PUSH
16000: LD_VAR 0 2
16004: PUSH
16005: FOR_IN
16006: IFFALSE 16030
// if HasTask ( i ) then
16008: LD_VAR 0 7
16012: PPUSH
16013: CALL_OW 314
16017: IFFALSE 16028
// ComStop ( i ) ;
16019: LD_VAR 0 7
16023: PPUSH
16024: CALL_OW 141
16028: GO 16005
16030: POP
16031: POP
// break ;
16032: GO 16269
// end ; for i in solds do
16034: LD_ADDR_VAR 0 7
16038: PUSH
16039: LD_VAR 0 2
16043: PUSH
16044: FOR_IN
16045: IFFALSE 16261
// begin if IsInUnit ( i ) then
16047: LD_VAR 0 7
16051: PPUSH
16052: CALL_OW 310
16056: IFFALSE 16067
// ComExitBuilding ( i ) ;
16058: LD_VAR 0 7
16062: PPUSH
16063: CALL_OW 122
// if GetLives ( i ) > 333 then
16067: LD_VAR 0 7
16071: PPUSH
16072: CALL_OW 256
16076: PUSH
16077: LD_INT 333
16079: GREATER
16080: IFFALSE 16108
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16082: LD_VAR 0 7
16086: PPUSH
16087: LD_VAR 0 5
16091: PPUSH
16092: LD_VAR 0 7
16096: PPUSH
16097: CALL_OW 74
16101: PPUSH
16102: CALL_OW 115
16106: GO 16259
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_EXP 58
16117: PUSH
16118: LD_VAR 0 1
16122: ARRAY
16123: PPUSH
16124: LD_INT 2
16126: PUSH
16127: LD_INT 30
16129: PUSH
16130: LD_INT 0
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PUSH
16137: LD_INT 30
16139: PUSH
16140: LD_INT 1
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 30
16149: PUSH
16150: LD_INT 6
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: PPUSH
16163: CALL_OW 72
16167: PPUSH
16168: LD_VAR 0 7
16172: PPUSH
16173: CALL_OW 74
16177: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16178: LD_VAR 0 7
16182: PPUSH
16183: LD_VAR 0 8
16187: PPUSH
16188: CALL_OW 250
16192: PPUSH
16193: LD_INT 3
16195: PPUSH
16196: LD_INT 5
16198: PPUSH
16199: CALL_OW 272
16203: PPUSH
16204: LD_VAR 0 8
16208: PPUSH
16209: CALL_OW 251
16213: PPUSH
16214: LD_INT 3
16216: PPUSH
16217: LD_INT 5
16219: PPUSH
16220: CALL_OW 273
16224: PPUSH
16225: CALL_OW 111
// SetTag ( i , 0 ) ;
16229: LD_VAR 0 7
16233: PPUSH
16234: LD_INT 0
16236: PPUSH
16237: CALL_OW 109
// solds := solds diff i ;
16241: LD_ADDR_VAR 0 2
16245: PUSH
16246: LD_VAR 0 2
16250: PUSH
16251: LD_VAR 0 7
16255: DIFF
16256: ST_TO_ADDR
// continue ;
16257: GO 16044
// end ; end ;
16259: GO 16044
16261: POP
16262: POP
// until solds ;
16263: LD_VAR 0 2
16267: IFFALSE 15876
// MC_Reset ( base , 18 ) ;
16269: LD_VAR 0 1
16273: PPUSH
16274: LD_INT 18
16276: PPUSH
16277: CALL 61214 0 2
// end ;
16281: LD_VAR 0 4
16285: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16286: LD_INT 0
16288: PPUSH
16289: PPUSH
16290: PPUSH
16291: PPUSH
16292: PPUSH
16293: PPUSH
16294: PPUSH
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
16301: PPUSH
16302: PPUSH
16303: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16304: LD_ADDR_VAR 0 12
16308: PUSH
16309: LD_EXP 58
16313: PUSH
16314: LD_VAR 0 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 25
16322: PUSH
16323: LD_INT 3
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PPUSH
16330: CALL_OW 72
16334: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16335: LD_EXP 98
16339: PUSH
16340: LD_VAR 0 1
16344: ARRAY
16345: IFFALSE 16369
// mechs := mechs diff mc_remote_driver [ base ] ;
16347: LD_ADDR_VAR 0 12
16351: PUSH
16352: LD_VAR 0 12
16356: PUSH
16357: LD_EXP 98
16361: PUSH
16362: LD_VAR 0 1
16366: ARRAY
16367: DIFF
16368: ST_TO_ADDR
// for i in mechs do
16369: LD_ADDR_VAR 0 5
16373: PUSH
16374: LD_VAR 0 12
16378: PUSH
16379: FOR_IN
16380: IFFALSE 16415
// if GetTag ( i ) > 0 then
16382: LD_VAR 0 5
16386: PPUSH
16387: CALL_OW 110
16391: PUSH
16392: LD_INT 0
16394: GREATER
16395: IFFALSE 16413
// mechs := mechs diff i ;
16397: LD_ADDR_VAR 0 12
16401: PUSH
16402: LD_VAR 0 12
16406: PUSH
16407: LD_VAR 0 5
16411: DIFF
16412: ST_TO_ADDR
16413: GO 16379
16415: POP
16416: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16417: LD_ADDR_VAR 0 8
16421: PUSH
16422: LD_EXP 58
16426: PUSH
16427: LD_VAR 0 1
16431: ARRAY
16432: PPUSH
16433: LD_INT 2
16435: PUSH
16436: LD_INT 25
16438: PUSH
16439: LD_INT 1
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PUSH
16446: LD_INT 25
16448: PUSH
16449: LD_INT 5
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: PUSH
16456: LD_INT 25
16458: PUSH
16459: LD_INT 8
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 25
16468: PUSH
16469: LD_INT 9
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: LIST
16480: LIST
16481: LIST
16482: PPUSH
16483: CALL_OW 72
16487: ST_TO_ADDR
// if not defenders and not solds then
16488: LD_VAR 0 2
16492: NOT
16493: PUSH
16494: LD_VAR 0 8
16498: NOT
16499: AND
16500: IFFALSE 16504
// exit ;
16502: GO 18042
// depot_under_attack := false ;
16504: LD_ADDR_VAR 0 16
16508: PUSH
16509: LD_INT 0
16511: ST_TO_ADDR
// sold_defenders := [ ] ;
16512: LD_ADDR_VAR 0 17
16516: PUSH
16517: EMPTY
16518: ST_TO_ADDR
// if mechs then
16519: LD_VAR 0 12
16523: IFFALSE 16652
// for i in defenders do
16525: LD_ADDR_VAR 0 5
16529: PUSH
16530: LD_VAR 0 2
16534: PUSH
16535: FOR_IN
16536: IFFALSE 16650
// begin SetTag ( i , 20 ) ;
16538: LD_VAR 0 5
16542: PPUSH
16543: LD_INT 20
16545: PPUSH
16546: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16550: LD_VAR 0 5
16554: PPUSH
16555: CALL_OW 263
16559: PUSH
16560: LD_INT 1
16562: EQUAL
16563: PUSH
16564: LD_VAR 0 5
16568: PPUSH
16569: CALL_OW 311
16573: NOT
16574: AND
16575: PUSH
16576: LD_VAR 0 12
16580: AND
16581: IFFALSE 16648
// begin un := mechs [ 1 ] ;
16583: LD_ADDR_VAR 0 10
16587: PUSH
16588: LD_VAR 0 12
16592: PUSH
16593: LD_INT 1
16595: ARRAY
16596: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16597: LD_VAR 0 10
16601: PPUSH
16602: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16606: LD_VAR 0 10
16610: PPUSH
16611: LD_VAR 0 5
16615: PPUSH
16616: CALL_OW 180
// SetTag ( un , 19 ) ;
16620: LD_VAR 0 10
16624: PPUSH
16625: LD_INT 19
16627: PPUSH
16628: CALL_OW 109
// mechs := mechs diff un ;
16632: LD_ADDR_VAR 0 12
16636: PUSH
16637: LD_VAR 0 12
16641: PUSH
16642: LD_VAR 0 10
16646: DIFF
16647: ST_TO_ADDR
// end ; end ;
16648: GO 16535
16650: POP
16651: POP
// if solds then
16652: LD_VAR 0 8
16656: IFFALSE 16715
// for i in solds do
16658: LD_ADDR_VAR 0 5
16662: PUSH
16663: LD_VAR 0 8
16667: PUSH
16668: FOR_IN
16669: IFFALSE 16713
// if not GetTag ( i ) then
16671: LD_VAR 0 5
16675: PPUSH
16676: CALL_OW 110
16680: NOT
16681: IFFALSE 16711
// begin defenders := defenders union i ;
16683: LD_ADDR_VAR 0 2
16687: PUSH
16688: LD_VAR 0 2
16692: PUSH
16693: LD_VAR 0 5
16697: UNION
16698: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16699: LD_VAR 0 5
16703: PPUSH
16704: LD_INT 18
16706: PPUSH
16707: CALL_OW 109
// end ;
16711: GO 16668
16713: POP
16714: POP
// repeat wait ( 0 0$1 ) ;
16715: LD_INT 35
16717: PPUSH
16718: CALL_OW 67
// enemy := mc_scan [ base ] ;
16722: LD_ADDR_VAR 0 3
16726: PUSH
16727: LD_EXP 81
16731: PUSH
16732: LD_VAR 0 1
16736: ARRAY
16737: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16738: LD_EXP 58
16742: PUSH
16743: LD_VAR 0 1
16747: ARRAY
16748: NOT
16749: PUSH
16750: LD_EXP 58
16754: PUSH
16755: LD_VAR 0 1
16759: ARRAY
16760: PUSH
16761: EMPTY
16762: EQUAL
16763: OR
16764: IFFALSE 16801
// begin for i in defenders do
16766: LD_ADDR_VAR 0 5
16770: PUSH
16771: LD_VAR 0 2
16775: PUSH
16776: FOR_IN
16777: IFFALSE 16790
// ComStop ( i ) ;
16779: LD_VAR 0 5
16783: PPUSH
16784: CALL_OW 141
16788: GO 16776
16790: POP
16791: POP
// defenders := [ ] ;
16792: LD_ADDR_VAR 0 2
16796: PUSH
16797: EMPTY
16798: ST_TO_ADDR
// exit ;
16799: GO 18042
// end ; for i in defenders do
16801: LD_ADDR_VAR 0 5
16805: PUSH
16806: LD_VAR 0 2
16810: PUSH
16811: FOR_IN
16812: IFFALSE 17542
// begin e := NearestUnitToUnit ( enemy , i ) ;
16814: LD_ADDR_VAR 0 13
16818: PUSH
16819: LD_VAR 0 3
16823: PPUSH
16824: LD_VAR 0 5
16828: PPUSH
16829: CALL_OW 74
16833: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16834: LD_ADDR_VAR 0 16
16838: PUSH
16839: LD_EXP 58
16843: PUSH
16844: LD_VAR 0 1
16848: ARRAY
16849: PPUSH
16850: LD_INT 2
16852: PUSH
16853: LD_INT 30
16855: PUSH
16856: LD_INT 0
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: PUSH
16863: LD_INT 30
16865: PUSH
16866: LD_INT 1
16868: PUSH
16869: EMPTY
16870: LIST
16871: LIST
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: LIST
16877: PPUSH
16878: CALL_OW 72
16882: NOT
16883: PUSH
16884: LD_EXP 58
16888: PUSH
16889: LD_VAR 0 1
16893: ARRAY
16894: PPUSH
16895: LD_INT 2
16897: PUSH
16898: LD_INT 30
16900: PUSH
16901: LD_INT 0
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 30
16910: PUSH
16911: LD_INT 1
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: LIST
16922: PPUSH
16923: CALL_OW 72
16927: PPUSH
16928: CALL_OW 256
16932: PUSH
16933: LD_INT 600
16935: LESS
16936: OR
16937: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16938: LD_VAR 0 5
16942: PPUSH
16943: CALL_OW 247
16947: PUSH
16948: LD_INT 2
16950: DOUBLE
16951: EQUAL
16952: IFTRUE 16956
16954: GO 17248
16956: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
16957: LD_VAR 0 5
16961: PPUSH
16962: CALL_OW 256
16966: PUSH
16967: LD_INT 650
16969: GREATER
16970: PUSH
16971: LD_VAR 0 5
16975: PPUSH
16976: LD_VAR 0 13
16980: PPUSH
16981: CALL_OW 296
16985: PUSH
16986: LD_INT 40
16988: LESS
16989: PUSH
16990: LD_VAR 0 13
16994: PPUSH
16995: LD_EXP 83
16999: PUSH
17000: LD_VAR 0 1
17004: ARRAY
17005: PPUSH
17006: CALL_OW 308
17010: OR
17011: AND
17012: IFFALSE 17030
// ComAttackUnit ( i , e ) else
17014: LD_VAR 0 5
17018: PPUSH
17019: LD_VAR 0 13
17023: PPUSH
17024: CALL_OW 115
17028: GO 17131
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17030: LD_VAR 0 13
17034: PPUSH
17035: LD_EXP 83
17039: PUSH
17040: LD_VAR 0 1
17044: ARRAY
17045: PPUSH
17046: CALL_OW 308
17050: NOT
17051: PUSH
17052: LD_VAR 0 5
17056: PPUSH
17057: LD_VAR 0 13
17061: PPUSH
17062: CALL_OW 296
17066: PUSH
17067: LD_INT 40
17069: GREATEREQUAL
17070: AND
17071: PUSH
17072: LD_VAR 0 5
17076: PPUSH
17077: CALL_OW 256
17081: PUSH
17082: LD_INT 650
17084: LESSEQUAL
17085: OR
17086: PUSH
17087: LD_VAR 0 5
17091: PPUSH
17092: LD_EXP 82
17096: PUSH
17097: LD_VAR 0 1
17101: ARRAY
17102: PPUSH
17103: CALL_OW 308
17107: NOT
17108: AND
17109: IFFALSE 17131
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17111: LD_VAR 0 5
17115: PPUSH
17116: LD_EXP 82
17120: PUSH
17121: LD_VAR 0 1
17125: ARRAY
17126: PPUSH
17127: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17131: LD_VAR 0 5
17135: PPUSH
17136: CALL_OW 256
17140: PUSH
17141: LD_INT 998
17143: LESS
17144: PUSH
17145: LD_VAR 0 5
17149: PPUSH
17150: CALL_OW 263
17154: PUSH
17155: LD_INT 1
17157: EQUAL
17158: AND
17159: PUSH
17160: LD_VAR 0 5
17164: PPUSH
17165: CALL_OW 311
17169: AND
17170: PUSH
17171: LD_VAR 0 5
17175: PPUSH
17176: LD_EXP 82
17180: PUSH
17181: LD_VAR 0 1
17185: ARRAY
17186: PPUSH
17187: CALL_OW 308
17191: AND
17192: IFFALSE 17246
// begin mech := IsDrivenBy ( i ) ;
17194: LD_ADDR_VAR 0 9
17198: PUSH
17199: LD_VAR 0 5
17203: PPUSH
17204: CALL_OW 311
17208: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17209: LD_VAR 0 9
17213: PPUSH
17214: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17218: LD_VAR 0 9
17222: PPUSH
17223: LD_VAR 0 5
17227: PPUSH
17228: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17232: LD_VAR 0 9
17236: PPUSH
17237: LD_VAR 0 5
17241: PPUSH
17242: CALL_OW 180
// end ; end ; unit_human :
17246: GO 17513
17248: LD_INT 1
17250: DOUBLE
17251: EQUAL
17252: IFTRUE 17256
17254: GO 17512
17256: POP
// begin b := IsInUnit ( i ) ;
17257: LD_ADDR_VAR 0 18
17261: PUSH
17262: LD_VAR 0 5
17266: PPUSH
17267: CALL_OW 310
17271: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17272: LD_ADDR_VAR 0 19
17276: PUSH
17277: LD_VAR 0 18
17281: NOT
17282: PUSH
17283: LD_VAR 0 18
17287: PPUSH
17288: CALL_OW 266
17292: PUSH
17293: LD_INT 32
17295: PUSH
17296: LD_INT 31
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: IN
17303: OR
17304: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17305: LD_VAR 0 16
17309: PUSH
17310: LD_VAR 0 2
17314: PPUSH
17315: LD_INT 21
17317: PUSH
17318: LD_INT 2
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: PPUSH
17325: CALL_OW 72
17329: PUSH
17330: LD_INT 1
17332: LESSEQUAL
17333: OR
17334: PUSH
17335: LD_VAR 0 19
17339: AND
17340: PUSH
17341: LD_VAR 0 5
17345: PUSH
17346: LD_VAR 0 17
17350: IN
17351: NOT
17352: AND
17353: IFFALSE 17446
// begin if b then
17355: LD_VAR 0 18
17359: IFFALSE 17408
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17361: LD_VAR 0 18
17365: PPUSH
17366: LD_VAR 0 3
17370: PPUSH
17371: LD_VAR 0 18
17375: PPUSH
17376: CALL_OW 74
17380: PPUSH
17381: CALL_OW 296
17385: PUSH
17386: LD_INT 10
17388: LESS
17389: PUSH
17390: LD_VAR 0 18
17394: PPUSH
17395: CALL_OW 461
17399: PUSH
17400: LD_INT 7
17402: NONEQUAL
17403: AND
17404: IFFALSE 17408
// continue ;
17406: GO 16811
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17408: LD_ADDR_VAR 0 17
17412: PUSH
17413: LD_VAR 0 17
17417: PPUSH
17418: LD_VAR 0 17
17422: PUSH
17423: LD_INT 1
17425: PLUS
17426: PPUSH
17427: LD_VAR 0 5
17431: PPUSH
17432: CALL_OW 1
17436: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17437: LD_VAR 0 5
17441: PPUSH
17442: CALL_OW 122
// end ; if sold_defenders then
17446: LD_VAR 0 17
17450: IFFALSE 17510
// if i in sold_defenders then
17452: LD_VAR 0 5
17456: PUSH
17457: LD_VAR 0 17
17461: IN
17462: IFFALSE 17510
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17464: LD_VAR 0 5
17468: PPUSH
17469: CALL_OW 314
17473: NOT
17474: PUSH
17475: LD_VAR 0 5
17479: PPUSH
17480: LD_VAR 0 13
17484: PPUSH
17485: CALL_OW 296
17489: PUSH
17490: LD_INT 30
17492: LESS
17493: AND
17494: IFFALSE 17510
// ComAttackUnit ( i , e ) ;
17496: LD_VAR 0 5
17500: PPUSH
17501: LD_VAR 0 13
17505: PPUSH
17506: CALL_OW 115
// end ; end ; end ;
17510: GO 17513
17512: POP
// if IsDead ( i ) then
17513: LD_VAR 0 5
17517: PPUSH
17518: CALL_OW 301
17522: IFFALSE 17540
// defenders := defenders diff i ;
17524: LD_ADDR_VAR 0 2
17528: PUSH
17529: LD_VAR 0 2
17533: PUSH
17534: LD_VAR 0 5
17538: DIFF
17539: ST_TO_ADDR
// end ;
17540: GO 16811
17542: POP
17543: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17544: LD_VAR 0 3
17548: NOT
17549: PUSH
17550: LD_VAR 0 2
17554: NOT
17555: OR
17556: PUSH
17557: LD_EXP 58
17561: PUSH
17562: LD_VAR 0 1
17566: ARRAY
17567: NOT
17568: OR
17569: IFFALSE 16715
// MC_Reset ( base , 18 ) ;
17571: LD_VAR 0 1
17575: PPUSH
17576: LD_INT 18
17578: PPUSH
17579: CALL 61214 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17583: LD_ADDR_VAR 0 2
17587: PUSH
17588: LD_VAR 0 2
17592: PUSH
17593: LD_VAR 0 2
17597: PPUSH
17598: LD_INT 2
17600: PUSH
17601: LD_INT 25
17603: PUSH
17604: LD_INT 1
17606: PUSH
17607: EMPTY
17608: LIST
17609: LIST
17610: PUSH
17611: LD_INT 25
17613: PUSH
17614: LD_INT 5
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: PUSH
17621: LD_INT 25
17623: PUSH
17624: LD_INT 8
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 25
17633: PUSH
17634: LD_INT 9
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: PPUSH
17648: CALL_OW 72
17652: DIFF
17653: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17654: LD_VAR 0 3
17658: NOT
17659: PUSH
17660: LD_VAR 0 2
17664: PPUSH
17665: LD_INT 21
17667: PUSH
17668: LD_INT 2
17670: PUSH
17671: EMPTY
17672: LIST
17673: LIST
17674: PPUSH
17675: CALL_OW 72
17679: AND
17680: IFFALSE 18018
// begin tmp := FilterByTag ( defenders , 19 ) ;
17682: LD_ADDR_VAR 0 11
17686: PUSH
17687: LD_VAR 0 2
17691: PPUSH
17692: LD_INT 19
17694: PPUSH
17695: CALL 54471 0 2
17699: ST_TO_ADDR
// if tmp then
17700: LD_VAR 0 11
17704: IFFALSE 17774
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17706: LD_ADDR_VAR 0 11
17710: PUSH
17711: LD_VAR 0 11
17715: PPUSH
17716: LD_INT 25
17718: PUSH
17719: LD_INT 3
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: PPUSH
17726: CALL_OW 72
17730: ST_TO_ADDR
// if tmp then
17731: LD_VAR 0 11
17735: IFFALSE 17774
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17737: LD_ADDR_EXP 70
17741: PUSH
17742: LD_EXP 70
17746: PPUSH
17747: LD_VAR 0 1
17751: PPUSH
17752: LD_EXP 70
17756: PUSH
17757: LD_VAR 0 1
17761: ARRAY
17762: PUSH
17763: LD_VAR 0 11
17767: UNION
17768: PPUSH
17769: CALL_OW 1
17773: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17774: LD_VAR 0 1
17778: PPUSH
17779: LD_INT 19
17781: PPUSH
17782: CALL 61214 0 2
// repeat wait ( 0 0$1 ) ;
17786: LD_INT 35
17788: PPUSH
17789: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17793: LD_EXP 58
17797: PUSH
17798: LD_VAR 0 1
17802: ARRAY
17803: NOT
17804: PUSH
17805: LD_EXP 58
17809: PUSH
17810: LD_VAR 0 1
17814: ARRAY
17815: PUSH
17816: EMPTY
17817: EQUAL
17818: OR
17819: IFFALSE 17856
// begin for i in defenders do
17821: LD_ADDR_VAR 0 5
17825: PUSH
17826: LD_VAR 0 2
17830: PUSH
17831: FOR_IN
17832: IFFALSE 17845
// ComStop ( i ) ;
17834: LD_VAR 0 5
17838: PPUSH
17839: CALL_OW 141
17843: GO 17831
17845: POP
17846: POP
// defenders := [ ] ;
17847: LD_ADDR_VAR 0 2
17851: PUSH
17852: EMPTY
17853: ST_TO_ADDR
// exit ;
17854: GO 18042
// end ; for i in defenders do
17856: LD_ADDR_VAR 0 5
17860: PUSH
17861: LD_VAR 0 2
17865: PUSH
17866: FOR_IN
17867: IFFALSE 17956
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17869: LD_VAR 0 5
17873: PPUSH
17874: LD_EXP 82
17878: PUSH
17879: LD_VAR 0 1
17883: ARRAY
17884: PPUSH
17885: CALL_OW 308
17889: NOT
17890: IFFALSE 17914
// ComMoveToArea ( i , mc_parking [ base ] ) else
17892: LD_VAR 0 5
17896: PPUSH
17897: LD_EXP 82
17901: PUSH
17902: LD_VAR 0 1
17906: ARRAY
17907: PPUSH
17908: CALL_OW 113
17912: GO 17954
// if GetControl ( i ) = control_manual then
17914: LD_VAR 0 5
17918: PPUSH
17919: CALL_OW 263
17923: PUSH
17924: LD_INT 1
17926: EQUAL
17927: IFFALSE 17954
// if IsDrivenBy ( i ) then
17929: LD_VAR 0 5
17933: PPUSH
17934: CALL_OW 311
17938: IFFALSE 17954
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17940: LD_VAR 0 5
17944: PPUSH
17945: CALL_OW 311
17949: PPUSH
17950: CALL_OW 121
// end ;
17954: GO 17866
17956: POP
17957: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
17958: LD_VAR 0 2
17962: PPUSH
17963: LD_INT 95
17965: PUSH
17966: LD_EXP 82
17970: PUSH
17971: LD_VAR 0 1
17975: ARRAY
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PPUSH
17981: CALL_OW 72
17985: PUSH
17986: LD_VAR 0 2
17990: EQUAL
17991: PUSH
17992: LD_EXP 81
17996: PUSH
17997: LD_VAR 0 1
18001: ARRAY
18002: OR
18003: PUSH
18004: LD_EXP 58
18008: PUSH
18009: LD_VAR 0 1
18013: ARRAY
18014: NOT
18015: OR
18016: IFFALSE 17786
// end ; MC_Reset ( base , 19 ) ;
18018: LD_VAR 0 1
18022: PPUSH
18023: LD_INT 19
18025: PPUSH
18026: CALL 61214 0 2
// MC_Reset ( base , 20 ) ;
18030: LD_VAR 0 1
18034: PPUSH
18035: LD_INT 20
18037: PPUSH
18038: CALL 61214 0 2
// end ;
18042: LD_VAR 0 4
18046: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18047: LD_INT 0
18049: PPUSH
18050: PPUSH
18051: PPUSH
18052: PPUSH
// result := false ;
18053: LD_ADDR_VAR 0 2
18057: PUSH
18058: LD_INT 0
18060: ST_TO_ADDR
// side := GetSide ( unit ) ;
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: LD_VAR 0 1
18070: PPUSH
18071: CALL_OW 255
18075: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18076: LD_ADDR_VAR 0 4
18080: PUSH
18081: LD_VAR 0 1
18085: PPUSH
18086: CALL_OW 248
18090: ST_TO_ADDR
// case nat of 1 :
18091: LD_VAR 0 4
18095: PUSH
18096: LD_INT 1
18098: DOUBLE
18099: EQUAL
18100: IFTRUE 18104
18102: GO 18115
18104: POP
// tech := tech_lassight ; 2 :
18105: LD_ADDR_VAR 0 5
18109: PUSH
18110: LD_INT 12
18112: ST_TO_ADDR
18113: GO 18154
18115: LD_INT 2
18117: DOUBLE
18118: EQUAL
18119: IFTRUE 18123
18121: GO 18134
18123: POP
// tech := tech_mortar ; 3 :
18124: LD_ADDR_VAR 0 5
18128: PUSH
18129: LD_INT 41
18131: ST_TO_ADDR
18132: GO 18154
18134: LD_INT 3
18136: DOUBLE
18137: EQUAL
18138: IFTRUE 18142
18140: GO 18153
18142: POP
// tech := tech_bazooka ; end ;
18143: LD_ADDR_VAR 0 5
18147: PUSH
18148: LD_INT 44
18150: ST_TO_ADDR
18151: GO 18154
18153: POP
// if Researched ( side , tech ) then
18154: LD_VAR 0 3
18158: PPUSH
18159: LD_VAR 0 5
18163: PPUSH
18164: CALL_OW 325
18168: IFFALSE 18195
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18170: LD_ADDR_VAR 0 2
18174: PUSH
18175: LD_INT 5
18177: PUSH
18178: LD_INT 8
18180: PUSH
18181: LD_INT 9
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: LIST
18188: PUSH
18189: LD_VAR 0 4
18193: ARRAY
18194: ST_TO_ADDR
// end ;
18195: LD_VAR 0 2
18199: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18200: LD_INT 0
18202: PPUSH
18203: PPUSH
18204: PPUSH
// if not mines then
18205: LD_VAR 0 2
18209: NOT
18210: IFFALSE 18214
// exit ;
18212: GO 18358
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18214: LD_ADDR_VAR 0 5
18218: PUSH
18219: LD_INT 81
18221: PUSH
18222: LD_VAR 0 1
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: PUSH
18231: LD_INT 3
18233: PUSH
18234: LD_INT 21
18236: PUSH
18237: LD_INT 3
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: PPUSH
18252: CALL_OW 69
18256: ST_TO_ADDR
// for i in mines do
18257: LD_ADDR_VAR 0 4
18261: PUSH
18262: LD_VAR 0 2
18266: PUSH
18267: FOR_IN
18268: IFFALSE 18356
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18270: LD_VAR 0 4
18274: PUSH
18275: LD_INT 1
18277: ARRAY
18278: PPUSH
18279: LD_VAR 0 4
18283: PUSH
18284: LD_INT 2
18286: ARRAY
18287: PPUSH
18288: CALL_OW 458
18292: NOT
18293: IFFALSE 18297
// continue ;
18295: GO 18267
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18297: LD_VAR 0 4
18301: PUSH
18302: LD_INT 1
18304: ARRAY
18305: PPUSH
18306: LD_VAR 0 4
18310: PUSH
18311: LD_INT 2
18313: ARRAY
18314: PPUSH
18315: CALL_OW 428
18319: PUSH
18320: LD_VAR 0 5
18324: IN
18325: IFFALSE 18354
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18327: LD_VAR 0 4
18331: PUSH
18332: LD_INT 1
18334: ARRAY
18335: PPUSH
18336: LD_VAR 0 4
18340: PUSH
18341: LD_INT 2
18343: ARRAY
18344: PPUSH
18345: LD_VAR 0 1
18349: PPUSH
18350: CALL_OW 456
// end ;
18354: GO 18267
18356: POP
18357: POP
// end ;
18358: LD_VAR 0 3
18362: RET
// export function Count ( array ) ; var i ; begin
18363: LD_INT 0
18365: PPUSH
18366: PPUSH
// result := 0 ;
18367: LD_ADDR_VAR 0 2
18371: PUSH
18372: LD_INT 0
18374: ST_TO_ADDR
// for i in array do
18375: LD_ADDR_VAR 0 3
18379: PUSH
18380: LD_VAR 0 1
18384: PUSH
18385: FOR_IN
18386: IFFALSE 18410
// if i then
18388: LD_VAR 0 3
18392: IFFALSE 18408
// result := result + 1 ;
18394: LD_ADDR_VAR 0 2
18398: PUSH
18399: LD_VAR 0 2
18403: PUSH
18404: LD_INT 1
18406: PLUS
18407: ST_TO_ADDR
18408: GO 18385
18410: POP
18411: POP
// end ;
18412: LD_VAR 0 2
18416: RET
// export function IsEmpty ( building ) ; begin
18417: LD_INT 0
18419: PPUSH
// if not building then
18420: LD_VAR 0 1
18424: NOT
18425: IFFALSE 18429
// exit ;
18427: GO 18472
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18429: LD_ADDR_VAR 0 2
18433: PUSH
18434: LD_VAR 0 1
18438: PUSH
18439: LD_INT 22
18441: PUSH
18442: LD_VAR 0 1
18446: PPUSH
18447: CALL_OW 255
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: PUSH
18456: LD_INT 58
18458: PUSH
18459: EMPTY
18460: LIST
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PPUSH
18466: CALL_OW 69
18470: IN
18471: ST_TO_ADDR
// end ;
18472: LD_VAR 0 2
18476: RET
// export function IsNotFull ( building ) ; begin
18477: LD_INT 0
18479: PPUSH
// if not building then
18480: LD_VAR 0 1
18484: NOT
18485: IFFALSE 18489
// exit ;
18487: GO 18508
// result := UnitsInside ( building ) < 6 ;
18489: LD_ADDR_VAR 0 2
18493: PUSH
18494: LD_VAR 0 1
18498: PPUSH
18499: CALL_OW 313
18503: PUSH
18504: LD_INT 6
18506: LESS
18507: ST_TO_ADDR
// end ;
18508: LD_VAR 0 2
18512: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18513: LD_INT 0
18515: PPUSH
18516: PPUSH
18517: PPUSH
18518: PPUSH
// tmp := [ ] ;
18519: LD_ADDR_VAR 0 3
18523: PUSH
18524: EMPTY
18525: ST_TO_ADDR
// list := [ ] ;
18526: LD_ADDR_VAR 0 5
18530: PUSH
18531: EMPTY
18532: ST_TO_ADDR
// for i = 16 to 25 do
18533: LD_ADDR_VAR 0 4
18537: PUSH
18538: DOUBLE
18539: LD_INT 16
18541: DEC
18542: ST_TO_ADDR
18543: LD_INT 25
18545: PUSH
18546: FOR_TO
18547: IFFALSE 18620
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18549: LD_ADDR_VAR 0 3
18553: PUSH
18554: LD_VAR 0 3
18558: PUSH
18559: LD_INT 22
18561: PUSH
18562: LD_VAR 0 1
18566: PPUSH
18567: CALL_OW 255
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: PUSH
18576: LD_INT 91
18578: PUSH
18579: LD_VAR 0 1
18583: PUSH
18584: LD_INT 6
18586: PUSH
18587: EMPTY
18588: LIST
18589: LIST
18590: LIST
18591: PUSH
18592: LD_INT 30
18594: PUSH
18595: LD_VAR 0 4
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: LIST
18608: PUSH
18609: EMPTY
18610: LIST
18611: PPUSH
18612: CALL_OW 69
18616: ADD
18617: ST_TO_ADDR
18618: GO 18546
18620: POP
18621: POP
// for i = 1 to tmp do
18622: LD_ADDR_VAR 0 4
18626: PUSH
18627: DOUBLE
18628: LD_INT 1
18630: DEC
18631: ST_TO_ADDR
18632: LD_VAR 0 3
18636: PUSH
18637: FOR_TO
18638: IFFALSE 18726
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18640: LD_ADDR_VAR 0 5
18644: PUSH
18645: LD_VAR 0 5
18649: PUSH
18650: LD_VAR 0 3
18654: PUSH
18655: LD_VAR 0 4
18659: ARRAY
18660: PPUSH
18661: CALL_OW 266
18665: PUSH
18666: LD_VAR 0 3
18670: PUSH
18671: LD_VAR 0 4
18675: ARRAY
18676: PPUSH
18677: CALL_OW 250
18681: PUSH
18682: LD_VAR 0 3
18686: PUSH
18687: LD_VAR 0 4
18691: ARRAY
18692: PPUSH
18693: CALL_OW 251
18697: PUSH
18698: LD_VAR 0 3
18702: PUSH
18703: LD_VAR 0 4
18707: ARRAY
18708: PPUSH
18709: CALL_OW 254
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: LIST
18718: LIST
18719: PUSH
18720: EMPTY
18721: LIST
18722: ADD
18723: ST_TO_ADDR
18724: GO 18637
18726: POP
18727: POP
// result := list ;
18728: LD_ADDR_VAR 0 2
18732: PUSH
18733: LD_VAR 0 5
18737: ST_TO_ADDR
// end ;
18738: LD_VAR 0 2
18742: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18743: LD_INT 0
18745: PPUSH
18746: PPUSH
18747: PPUSH
18748: PPUSH
18749: PPUSH
18750: PPUSH
18751: PPUSH
// if not factory then
18752: LD_VAR 0 1
18756: NOT
18757: IFFALSE 18761
// exit ;
18759: GO 19354
// if control = control_apeman then
18761: LD_VAR 0 4
18765: PUSH
18766: LD_INT 5
18768: EQUAL
18769: IFFALSE 18878
// begin tmp := UnitsInside ( factory ) ;
18771: LD_ADDR_VAR 0 8
18775: PUSH
18776: LD_VAR 0 1
18780: PPUSH
18781: CALL_OW 313
18785: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18786: LD_VAR 0 8
18790: PPUSH
18791: LD_INT 25
18793: PUSH
18794: LD_INT 12
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PPUSH
18801: CALL_OW 72
18805: NOT
18806: IFFALSE 18816
// control := control_manual ;
18808: LD_ADDR_VAR 0 4
18812: PUSH
18813: LD_INT 1
18815: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18816: LD_ADDR_VAR 0 8
18820: PUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: CALL 18513 0 1
18830: ST_TO_ADDR
// if tmp then
18831: LD_VAR 0 8
18835: IFFALSE 18878
// begin for i in tmp do
18837: LD_ADDR_VAR 0 7
18841: PUSH
18842: LD_VAR 0 8
18846: PUSH
18847: FOR_IN
18848: IFFALSE 18876
// if i [ 1 ] = b_ext_radio then
18850: LD_VAR 0 7
18854: PUSH
18855: LD_INT 1
18857: ARRAY
18858: PUSH
18859: LD_INT 22
18861: EQUAL
18862: IFFALSE 18874
// begin control := control_remote ;
18864: LD_ADDR_VAR 0 4
18868: PUSH
18869: LD_INT 2
18871: ST_TO_ADDR
// break ;
18872: GO 18876
// end ;
18874: GO 18847
18876: POP
18877: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18878: LD_VAR 0 1
18882: PPUSH
18883: LD_VAR 0 2
18887: PPUSH
18888: LD_VAR 0 3
18892: PPUSH
18893: LD_VAR 0 4
18897: PPUSH
18898: LD_VAR 0 5
18902: PPUSH
18903: CALL_OW 448
18907: IFFALSE 18942
// begin result := [ chassis , engine , control , weapon ] ;
18909: LD_ADDR_VAR 0 6
18913: PUSH
18914: LD_VAR 0 2
18918: PUSH
18919: LD_VAR 0 3
18923: PUSH
18924: LD_VAR 0 4
18928: PUSH
18929: LD_VAR 0 5
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: LIST
18938: LIST
18939: ST_TO_ADDR
// exit ;
18940: GO 19354
// end ; _chassis := AvailableChassisList ( factory ) ;
18942: LD_ADDR_VAR 0 9
18946: PUSH
18947: LD_VAR 0 1
18951: PPUSH
18952: CALL_OW 475
18956: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18957: LD_ADDR_VAR 0 11
18961: PUSH
18962: LD_VAR 0 1
18966: PPUSH
18967: CALL_OW 476
18971: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18972: LD_ADDR_VAR 0 12
18976: PUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: CALL_OW 477
18986: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18987: LD_ADDR_VAR 0 10
18991: PUSH
18992: LD_VAR 0 1
18996: PPUSH
18997: CALL_OW 478
19001: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19002: LD_VAR 0 9
19006: NOT
19007: PUSH
19008: LD_VAR 0 11
19012: NOT
19013: OR
19014: PUSH
19015: LD_VAR 0 12
19019: NOT
19020: OR
19021: PUSH
19022: LD_VAR 0 10
19026: NOT
19027: OR
19028: IFFALSE 19063
// begin result := [ chassis , engine , control , weapon ] ;
19030: LD_ADDR_VAR 0 6
19034: PUSH
19035: LD_VAR 0 2
19039: PUSH
19040: LD_VAR 0 3
19044: PUSH
19045: LD_VAR 0 4
19049: PUSH
19050: LD_VAR 0 5
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: ST_TO_ADDR
// exit ;
19061: GO 19354
// end ; if not chassis in _chassis then
19063: LD_VAR 0 2
19067: PUSH
19068: LD_VAR 0 9
19072: IN
19073: NOT
19074: IFFALSE 19100
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 9
19085: PUSH
19086: LD_INT 1
19088: PPUSH
19089: LD_VAR 0 9
19093: PPUSH
19094: CALL_OW 12
19098: ARRAY
19099: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19100: LD_VAR 0 2
19104: PPUSH
19105: LD_VAR 0 3
19109: PPUSH
19110: CALL 19359 0 2
19114: NOT
19115: IFFALSE 19174
// repeat engine := _engine [ 1 ] ;
19117: LD_ADDR_VAR 0 3
19121: PUSH
19122: LD_VAR 0 11
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19131: LD_ADDR_VAR 0 11
19135: PUSH
19136: LD_VAR 0 11
19140: PPUSH
19141: LD_INT 1
19143: PPUSH
19144: CALL_OW 3
19148: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19149: LD_VAR 0 2
19153: PPUSH
19154: LD_VAR 0 3
19158: PPUSH
19159: CALL 19359 0 2
19163: PUSH
19164: LD_VAR 0 11
19168: PUSH
19169: EMPTY
19170: EQUAL
19171: OR
19172: IFFALSE 19117
// if not control in _control then
19174: LD_VAR 0 4
19178: PUSH
19179: LD_VAR 0 12
19183: IN
19184: NOT
19185: IFFALSE 19211
// control := _control [ rand ( 1 , _control ) ] ;
19187: LD_ADDR_VAR 0 4
19191: PUSH
19192: LD_VAR 0 12
19196: PUSH
19197: LD_INT 1
19199: PPUSH
19200: LD_VAR 0 12
19204: PPUSH
19205: CALL_OW 12
19209: ARRAY
19210: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19211: LD_VAR 0 2
19215: PPUSH
19216: LD_VAR 0 5
19220: PPUSH
19221: CALL 19579 0 2
19225: NOT
19226: IFFALSE 19285
// repeat weapon := _weapon [ 1 ] ;
19228: LD_ADDR_VAR 0 5
19232: PUSH
19233: LD_VAR 0 10
19237: PUSH
19238: LD_INT 1
19240: ARRAY
19241: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19242: LD_ADDR_VAR 0 10
19246: PUSH
19247: LD_VAR 0 10
19251: PPUSH
19252: LD_INT 1
19254: PPUSH
19255: CALL_OW 3
19259: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19260: LD_VAR 0 2
19264: PPUSH
19265: LD_VAR 0 5
19269: PPUSH
19270: CALL 19579 0 2
19274: PUSH
19275: LD_VAR 0 10
19279: PUSH
19280: EMPTY
19281: EQUAL
19282: OR
19283: IFFALSE 19228
// result := [ ] ;
19285: LD_ADDR_VAR 0 6
19289: PUSH
19290: EMPTY
19291: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19292: LD_VAR 0 1
19296: PPUSH
19297: LD_VAR 0 2
19301: PPUSH
19302: LD_VAR 0 3
19306: PPUSH
19307: LD_VAR 0 4
19311: PPUSH
19312: LD_VAR 0 5
19316: PPUSH
19317: CALL_OW 448
19321: IFFALSE 19354
// result := [ chassis , engine , control , weapon ] ;
19323: LD_ADDR_VAR 0 6
19327: PUSH
19328: LD_VAR 0 2
19332: PUSH
19333: LD_VAR 0 3
19337: PUSH
19338: LD_VAR 0 4
19342: PUSH
19343: LD_VAR 0 5
19347: PUSH
19348: EMPTY
19349: LIST
19350: LIST
19351: LIST
19352: LIST
19353: ST_TO_ADDR
// end ;
19354: LD_VAR 0 6
19358: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19359: LD_INT 0
19361: PPUSH
// if not chassis or not engine then
19362: LD_VAR 0 1
19366: NOT
19367: PUSH
19368: LD_VAR 0 2
19372: NOT
19373: OR
19374: IFFALSE 19378
// exit ;
19376: GO 19574
// case engine of engine_solar :
19378: LD_VAR 0 2
19382: PUSH
19383: LD_INT 2
19385: DOUBLE
19386: EQUAL
19387: IFTRUE 19391
19389: GO 19429
19391: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19392: LD_ADDR_VAR 0 3
19396: PUSH
19397: LD_INT 11
19399: PUSH
19400: LD_INT 12
19402: PUSH
19403: LD_INT 13
19405: PUSH
19406: LD_INT 14
19408: PUSH
19409: LD_INT 1
19411: PUSH
19412: LD_INT 2
19414: PUSH
19415: LD_INT 3
19417: PUSH
19418: EMPTY
19419: LIST
19420: LIST
19421: LIST
19422: LIST
19423: LIST
19424: LIST
19425: LIST
19426: ST_TO_ADDR
19427: GO 19558
19429: LD_INT 1
19431: DOUBLE
19432: EQUAL
19433: IFTRUE 19437
19435: GO 19499
19437: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19438: LD_ADDR_VAR 0 3
19442: PUSH
19443: LD_INT 11
19445: PUSH
19446: LD_INT 12
19448: PUSH
19449: LD_INT 13
19451: PUSH
19452: LD_INT 14
19454: PUSH
19455: LD_INT 1
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: LD_INT 3
19463: PUSH
19464: LD_INT 4
19466: PUSH
19467: LD_INT 5
19469: PUSH
19470: LD_INT 21
19472: PUSH
19473: LD_INT 23
19475: PUSH
19476: LD_INT 22
19478: PUSH
19479: LD_INT 24
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: LIST
19493: LIST
19494: LIST
19495: LIST
19496: ST_TO_ADDR
19497: GO 19558
19499: LD_INT 3
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19557
19507: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19508: LD_ADDR_VAR 0 3
19512: PUSH
19513: LD_INT 13
19515: PUSH
19516: LD_INT 14
19518: PUSH
19519: LD_INT 2
19521: PUSH
19522: LD_INT 3
19524: PUSH
19525: LD_INT 4
19527: PUSH
19528: LD_INT 5
19530: PUSH
19531: LD_INT 21
19533: PUSH
19534: LD_INT 22
19536: PUSH
19537: LD_INT 23
19539: PUSH
19540: LD_INT 24
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: LIST
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: LIST
19553: LIST
19554: ST_TO_ADDR
19555: GO 19558
19557: POP
// result := ( chassis in result ) ;
19558: LD_ADDR_VAR 0 3
19562: PUSH
19563: LD_VAR 0 1
19567: PUSH
19568: LD_VAR 0 3
19572: IN
19573: ST_TO_ADDR
// end ;
19574: LD_VAR 0 3
19578: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19579: LD_INT 0
19581: PPUSH
// if not chassis or not weapon then
19582: LD_VAR 0 1
19586: NOT
19587: PUSH
19588: LD_VAR 0 2
19592: NOT
19593: OR
19594: IFFALSE 19598
// exit ;
19596: GO 20624
// case weapon of us_machine_gun :
19598: LD_VAR 0 2
19602: PUSH
19603: LD_INT 2
19605: DOUBLE
19606: EQUAL
19607: IFTRUE 19611
19609: GO 19641
19611: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19612: LD_ADDR_VAR 0 3
19616: PUSH
19617: LD_INT 1
19619: PUSH
19620: LD_INT 2
19622: PUSH
19623: LD_INT 3
19625: PUSH
19626: LD_INT 4
19628: PUSH
19629: LD_INT 5
19631: PUSH
19632: EMPTY
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: ST_TO_ADDR
19639: GO 20608
19641: LD_INT 3
19643: DOUBLE
19644: EQUAL
19645: IFTRUE 19649
19647: GO 19679
19649: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19650: LD_ADDR_VAR 0 3
19654: PUSH
19655: LD_INT 1
19657: PUSH
19658: LD_INT 2
19660: PUSH
19661: LD_INT 3
19663: PUSH
19664: LD_INT 4
19666: PUSH
19667: LD_INT 5
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: ST_TO_ADDR
19677: GO 20608
19679: LD_INT 11
19681: DOUBLE
19682: EQUAL
19683: IFTRUE 19687
19685: GO 19717
19687: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: LD_INT 1
19695: PUSH
19696: LD_INT 2
19698: PUSH
19699: LD_INT 3
19701: PUSH
19702: LD_INT 4
19704: PUSH
19705: LD_INT 5
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: ST_TO_ADDR
19715: GO 20608
19717: LD_INT 4
19719: DOUBLE
19720: EQUAL
19721: IFTRUE 19725
19723: GO 19751
19725: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19726: LD_ADDR_VAR 0 3
19730: PUSH
19731: LD_INT 2
19733: PUSH
19734: LD_INT 3
19736: PUSH
19737: LD_INT 4
19739: PUSH
19740: LD_INT 5
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: LIST
19747: LIST
19748: ST_TO_ADDR
19749: GO 20608
19751: LD_INT 5
19753: DOUBLE
19754: EQUAL
19755: IFTRUE 19759
19757: GO 19785
19759: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19760: LD_ADDR_VAR 0 3
19764: PUSH
19765: LD_INT 2
19767: PUSH
19768: LD_INT 3
19770: PUSH
19771: LD_INT 4
19773: PUSH
19774: LD_INT 5
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: ST_TO_ADDR
19783: GO 20608
19785: LD_INT 9
19787: DOUBLE
19788: EQUAL
19789: IFTRUE 19793
19791: GO 19819
19793: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19794: LD_ADDR_VAR 0 3
19798: PUSH
19799: LD_INT 2
19801: PUSH
19802: LD_INT 3
19804: PUSH
19805: LD_INT 4
19807: PUSH
19808: LD_INT 5
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: LIST
19815: LIST
19816: ST_TO_ADDR
19817: GO 20608
19819: LD_INT 7
19821: DOUBLE
19822: EQUAL
19823: IFTRUE 19827
19825: GO 19853
19827: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19828: LD_ADDR_VAR 0 3
19832: PUSH
19833: LD_INT 2
19835: PUSH
19836: LD_INT 3
19838: PUSH
19839: LD_INT 4
19841: PUSH
19842: LD_INT 5
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: LIST
19849: LIST
19850: ST_TO_ADDR
19851: GO 20608
19853: LD_INT 12
19855: DOUBLE
19856: EQUAL
19857: IFTRUE 19861
19859: GO 19887
19861: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19862: LD_ADDR_VAR 0 3
19866: PUSH
19867: LD_INT 2
19869: PUSH
19870: LD_INT 3
19872: PUSH
19873: LD_INT 4
19875: PUSH
19876: LD_INT 5
19878: PUSH
19879: EMPTY
19880: LIST
19881: LIST
19882: LIST
19883: LIST
19884: ST_TO_ADDR
19885: GO 20608
19887: LD_INT 13
19889: DOUBLE
19890: EQUAL
19891: IFTRUE 19895
19893: GO 19921
19895: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19896: LD_ADDR_VAR 0 3
19900: PUSH
19901: LD_INT 2
19903: PUSH
19904: LD_INT 3
19906: PUSH
19907: LD_INT 4
19909: PUSH
19910: LD_INT 5
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: ST_TO_ADDR
19919: GO 20608
19921: LD_INT 14
19923: DOUBLE
19924: EQUAL
19925: IFTRUE 19929
19927: GO 19947
19929: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19930: LD_ADDR_VAR 0 3
19934: PUSH
19935: LD_INT 4
19937: PUSH
19938: LD_INT 5
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: ST_TO_ADDR
19945: GO 20608
19947: LD_INT 6
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 19973
19955: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19956: LD_ADDR_VAR 0 3
19960: PUSH
19961: LD_INT 4
19963: PUSH
19964: LD_INT 5
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: ST_TO_ADDR
19971: GO 20608
19973: LD_INT 10
19975: DOUBLE
19976: EQUAL
19977: IFTRUE 19981
19979: GO 19999
19981: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19982: LD_ADDR_VAR 0 3
19986: PUSH
19987: LD_INT 4
19989: PUSH
19990: LD_INT 5
19992: PUSH
19993: EMPTY
19994: LIST
19995: LIST
19996: ST_TO_ADDR
19997: GO 20608
19999: LD_INT 22
20001: DOUBLE
20002: EQUAL
20003: IFTRUE 20007
20005: GO 20033
20007: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20008: LD_ADDR_VAR 0 3
20012: PUSH
20013: LD_INT 11
20015: PUSH
20016: LD_INT 12
20018: PUSH
20019: LD_INT 13
20021: PUSH
20022: LD_INT 14
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: LIST
20030: ST_TO_ADDR
20031: GO 20608
20033: LD_INT 23
20035: DOUBLE
20036: EQUAL
20037: IFTRUE 20041
20039: GO 20067
20041: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20042: LD_ADDR_VAR 0 3
20046: PUSH
20047: LD_INT 11
20049: PUSH
20050: LD_INT 12
20052: PUSH
20053: LD_INT 13
20055: PUSH
20056: LD_INT 14
20058: PUSH
20059: EMPTY
20060: LIST
20061: LIST
20062: LIST
20063: LIST
20064: ST_TO_ADDR
20065: GO 20608
20067: LD_INT 24
20069: DOUBLE
20070: EQUAL
20071: IFTRUE 20075
20073: GO 20101
20075: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20076: LD_ADDR_VAR 0 3
20080: PUSH
20081: LD_INT 11
20083: PUSH
20084: LD_INT 12
20086: PUSH
20087: LD_INT 13
20089: PUSH
20090: LD_INT 14
20092: PUSH
20093: EMPTY
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: ST_TO_ADDR
20099: GO 20608
20101: LD_INT 30
20103: DOUBLE
20104: EQUAL
20105: IFTRUE 20109
20107: GO 20135
20109: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20110: LD_ADDR_VAR 0 3
20114: PUSH
20115: LD_INT 11
20117: PUSH
20118: LD_INT 12
20120: PUSH
20121: LD_INT 13
20123: PUSH
20124: LD_INT 14
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: LIST
20131: LIST
20132: ST_TO_ADDR
20133: GO 20608
20135: LD_INT 25
20137: DOUBLE
20138: EQUAL
20139: IFTRUE 20143
20141: GO 20161
20143: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20144: LD_ADDR_VAR 0 3
20148: PUSH
20149: LD_INT 13
20151: PUSH
20152: LD_INT 14
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: ST_TO_ADDR
20159: GO 20608
20161: LD_INT 27
20163: DOUBLE
20164: EQUAL
20165: IFTRUE 20169
20167: GO 20187
20169: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20170: LD_ADDR_VAR 0 3
20174: PUSH
20175: LD_INT 13
20177: PUSH
20178: LD_INT 14
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: ST_TO_ADDR
20185: GO 20608
20187: LD_INT 28
20189: DOUBLE
20190: EQUAL
20191: IFTRUE 20195
20193: GO 20213
20195: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20196: LD_ADDR_VAR 0 3
20200: PUSH
20201: LD_INT 13
20203: PUSH
20204: LD_INT 14
20206: PUSH
20207: EMPTY
20208: LIST
20209: LIST
20210: ST_TO_ADDR
20211: GO 20608
20213: LD_INT 29
20215: DOUBLE
20216: EQUAL
20217: IFTRUE 20221
20219: GO 20239
20221: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20222: LD_ADDR_VAR 0 3
20226: PUSH
20227: LD_INT 13
20229: PUSH
20230: LD_INT 14
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: ST_TO_ADDR
20237: GO 20608
20239: LD_INT 31
20241: DOUBLE
20242: EQUAL
20243: IFTRUE 20247
20245: GO 20265
20247: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20248: LD_ADDR_VAR 0 3
20252: PUSH
20253: LD_INT 13
20255: PUSH
20256: LD_INT 14
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20608
20265: LD_INT 26
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20291
20273: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 13
20281: PUSH
20282: LD_INT 14
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: ST_TO_ADDR
20289: GO 20608
20291: LD_INT 42
20293: DOUBLE
20294: EQUAL
20295: IFTRUE 20299
20297: GO 20325
20299: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20300: LD_ADDR_VAR 0 3
20304: PUSH
20305: LD_INT 21
20307: PUSH
20308: LD_INT 22
20310: PUSH
20311: LD_INT 23
20313: PUSH
20314: LD_INT 24
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: ST_TO_ADDR
20323: GO 20608
20325: LD_INT 43
20327: DOUBLE
20328: EQUAL
20329: IFTRUE 20333
20331: GO 20359
20333: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_INT 21
20341: PUSH
20342: LD_INT 22
20344: PUSH
20345: LD_INT 23
20347: PUSH
20348: LD_INT 24
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: LIST
20355: LIST
20356: ST_TO_ADDR
20357: GO 20608
20359: LD_INT 44
20361: DOUBLE
20362: EQUAL
20363: IFTRUE 20367
20365: GO 20393
20367: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20368: LD_ADDR_VAR 0 3
20372: PUSH
20373: LD_INT 21
20375: PUSH
20376: LD_INT 22
20378: PUSH
20379: LD_INT 23
20381: PUSH
20382: LD_INT 24
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: LIST
20389: LIST
20390: ST_TO_ADDR
20391: GO 20608
20393: LD_INT 45
20395: DOUBLE
20396: EQUAL
20397: IFTRUE 20401
20399: GO 20427
20401: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20402: LD_ADDR_VAR 0 3
20406: PUSH
20407: LD_INT 21
20409: PUSH
20410: LD_INT 22
20412: PUSH
20413: LD_INT 23
20415: PUSH
20416: LD_INT 24
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: ST_TO_ADDR
20425: GO 20608
20427: LD_INT 49
20429: DOUBLE
20430: EQUAL
20431: IFTRUE 20435
20433: GO 20461
20435: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20436: LD_ADDR_VAR 0 3
20440: PUSH
20441: LD_INT 21
20443: PUSH
20444: LD_INT 22
20446: PUSH
20447: LD_INT 23
20449: PUSH
20450: LD_INT 24
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: LIST
20457: LIST
20458: ST_TO_ADDR
20459: GO 20608
20461: LD_INT 51
20463: DOUBLE
20464: EQUAL
20465: IFTRUE 20469
20467: GO 20495
20469: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20470: LD_ADDR_VAR 0 3
20474: PUSH
20475: LD_INT 21
20477: PUSH
20478: LD_INT 22
20480: PUSH
20481: LD_INT 23
20483: PUSH
20484: LD_INT 24
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: ST_TO_ADDR
20493: GO 20608
20495: LD_INT 52
20497: DOUBLE
20498: EQUAL
20499: IFTRUE 20503
20501: GO 20529
20503: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20504: LD_ADDR_VAR 0 3
20508: PUSH
20509: LD_INT 21
20511: PUSH
20512: LD_INT 22
20514: PUSH
20515: LD_INT 23
20517: PUSH
20518: LD_INT 24
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: LIST
20526: ST_TO_ADDR
20527: GO 20608
20529: LD_INT 53
20531: DOUBLE
20532: EQUAL
20533: IFTRUE 20537
20535: GO 20555
20537: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20538: LD_ADDR_VAR 0 3
20542: PUSH
20543: LD_INT 23
20545: PUSH
20546: LD_INT 24
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: ST_TO_ADDR
20553: GO 20608
20555: LD_INT 46
20557: DOUBLE
20558: EQUAL
20559: IFTRUE 20563
20561: GO 20581
20563: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20564: LD_ADDR_VAR 0 3
20568: PUSH
20569: LD_INT 23
20571: PUSH
20572: LD_INT 24
20574: PUSH
20575: EMPTY
20576: LIST
20577: LIST
20578: ST_TO_ADDR
20579: GO 20608
20581: LD_INT 47
20583: DOUBLE
20584: EQUAL
20585: IFTRUE 20589
20587: GO 20607
20589: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20590: LD_ADDR_VAR 0 3
20594: PUSH
20595: LD_INT 23
20597: PUSH
20598: LD_INT 24
20600: PUSH
20601: EMPTY
20602: LIST
20603: LIST
20604: ST_TO_ADDR
20605: GO 20608
20607: POP
// result := ( chassis in result ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 1
20617: PUSH
20618: LD_VAR 0 3
20622: IN
20623: ST_TO_ADDR
// end ;
20624: LD_VAR 0 3
20628: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20629: LD_INT 0
20631: PPUSH
20632: PPUSH
20633: PPUSH
20634: PPUSH
20635: PPUSH
20636: PPUSH
20637: PPUSH
// result := array ;
20638: LD_ADDR_VAR 0 5
20642: PUSH
20643: LD_VAR 0 1
20647: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20648: LD_VAR 0 1
20652: NOT
20653: PUSH
20654: LD_VAR 0 2
20658: NOT
20659: OR
20660: PUSH
20661: LD_VAR 0 3
20665: NOT
20666: OR
20667: PUSH
20668: LD_VAR 0 2
20672: PUSH
20673: LD_VAR 0 1
20677: GREATER
20678: OR
20679: PUSH
20680: LD_VAR 0 3
20684: PUSH
20685: LD_VAR 0 1
20689: GREATER
20690: OR
20691: IFFALSE 20695
// exit ;
20693: GO 20991
// if direction then
20695: LD_VAR 0 4
20699: IFFALSE 20763
// begin d := 1 ;
20701: LD_ADDR_VAR 0 9
20705: PUSH
20706: LD_INT 1
20708: ST_TO_ADDR
// if i_from > i_to then
20709: LD_VAR 0 2
20713: PUSH
20714: LD_VAR 0 3
20718: GREATER
20719: IFFALSE 20745
// length := ( array - i_from ) + i_to else
20721: LD_ADDR_VAR 0 11
20725: PUSH
20726: LD_VAR 0 1
20730: PUSH
20731: LD_VAR 0 2
20735: MINUS
20736: PUSH
20737: LD_VAR 0 3
20741: PLUS
20742: ST_TO_ADDR
20743: GO 20761
// length := i_to - i_from ;
20745: LD_ADDR_VAR 0 11
20749: PUSH
20750: LD_VAR 0 3
20754: PUSH
20755: LD_VAR 0 2
20759: MINUS
20760: ST_TO_ADDR
// end else
20761: GO 20824
// begin d := - 1 ;
20763: LD_ADDR_VAR 0 9
20767: PUSH
20768: LD_INT 1
20770: NEG
20771: ST_TO_ADDR
// if i_from > i_to then
20772: LD_VAR 0 2
20776: PUSH
20777: LD_VAR 0 3
20781: GREATER
20782: IFFALSE 20802
// length := i_from - i_to else
20784: LD_ADDR_VAR 0 11
20788: PUSH
20789: LD_VAR 0 2
20793: PUSH
20794: LD_VAR 0 3
20798: MINUS
20799: ST_TO_ADDR
20800: GO 20824
// length := ( array - i_to ) + i_from ;
20802: LD_ADDR_VAR 0 11
20806: PUSH
20807: LD_VAR 0 1
20811: PUSH
20812: LD_VAR 0 3
20816: MINUS
20817: PUSH
20818: LD_VAR 0 2
20822: PLUS
20823: ST_TO_ADDR
// end ; if not length then
20824: LD_VAR 0 11
20828: NOT
20829: IFFALSE 20833
// exit ;
20831: GO 20991
// tmp := array ;
20833: LD_ADDR_VAR 0 10
20837: PUSH
20838: LD_VAR 0 1
20842: ST_TO_ADDR
// for i = 1 to length do
20843: LD_ADDR_VAR 0 6
20847: PUSH
20848: DOUBLE
20849: LD_INT 1
20851: DEC
20852: ST_TO_ADDR
20853: LD_VAR 0 11
20857: PUSH
20858: FOR_TO
20859: IFFALSE 20979
// begin for j = 1 to array do
20861: LD_ADDR_VAR 0 7
20865: PUSH
20866: DOUBLE
20867: LD_INT 1
20869: DEC
20870: ST_TO_ADDR
20871: LD_VAR 0 1
20875: PUSH
20876: FOR_TO
20877: IFFALSE 20965
// begin k := j + d ;
20879: LD_ADDR_VAR 0 8
20883: PUSH
20884: LD_VAR 0 7
20888: PUSH
20889: LD_VAR 0 9
20893: PLUS
20894: ST_TO_ADDR
// if k > array then
20895: LD_VAR 0 8
20899: PUSH
20900: LD_VAR 0 1
20904: GREATER
20905: IFFALSE 20915
// k := 1 ;
20907: LD_ADDR_VAR 0 8
20911: PUSH
20912: LD_INT 1
20914: ST_TO_ADDR
// if not k then
20915: LD_VAR 0 8
20919: NOT
20920: IFFALSE 20932
// k := array ;
20922: LD_ADDR_VAR 0 8
20926: PUSH
20927: LD_VAR 0 1
20931: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20932: LD_ADDR_VAR 0 10
20936: PUSH
20937: LD_VAR 0 10
20941: PPUSH
20942: LD_VAR 0 8
20946: PPUSH
20947: LD_VAR 0 1
20951: PUSH
20952: LD_VAR 0 7
20956: ARRAY
20957: PPUSH
20958: CALL_OW 1
20962: ST_TO_ADDR
// end ;
20963: GO 20876
20965: POP
20966: POP
// array := tmp ;
20967: LD_ADDR_VAR 0 1
20971: PUSH
20972: LD_VAR 0 10
20976: ST_TO_ADDR
// end ;
20977: GO 20858
20979: POP
20980: POP
// result := array ;
20981: LD_ADDR_VAR 0 5
20985: PUSH
20986: LD_VAR 0 1
20990: ST_TO_ADDR
// end ;
20991: LD_VAR 0 5
20995: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20996: LD_INT 0
20998: PPUSH
20999: PPUSH
// result := 0 ;
21000: LD_ADDR_VAR 0 3
21004: PUSH
21005: LD_INT 0
21007: ST_TO_ADDR
// if not array or not value in array then
21008: LD_VAR 0 1
21012: NOT
21013: PUSH
21014: LD_VAR 0 2
21018: PUSH
21019: LD_VAR 0 1
21023: IN
21024: NOT
21025: OR
21026: IFFALSE 21030
// exit ;
21028: GO 21084
// for i = 1 to array do
21030: LD_ADDR_VAR 0 4
21034: PUSH
21035: DOUBLE
21036: LD_INT 1
21038: DEC
21039: ST_TO_ADDR
21040: LD_VAR 0 1
21044: PUSH
21045: FOR_TO
21046: IFFALSE 21082
// if value = array [ i ] then
21048: LD_VAR 0 2
21052: PUSH
21053: LD_VAR 0 1
21057: PUSH
21058: LD_VAR 0 4
21062: ARRAY
21063: EQUAL
21064: IFFALSE 21080
// begin result := i ;
21066: LD_ADDR_VAR 0 3
21070: PUSH
21071: LD_VAR 0 4
21075: ST_TO_ADDR
// exit ;
21076: POP
21077: POP
21078: GO 21084
// end ;
21080: GO 21045
21082: POP
21083: POP
// end ;
21084: LD_VAR 0 3
21088: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21089: LD_INT 0
21091: PPUSH
// vc_chassis := chassis ;
21092: LD_ADDR_OWVAR 37
21096: PUSH
21097: LD_VAR 0 1
21101: ST_TO_ADDR
// vc_engine := engine ;
21102: LD_ADDR_OWVAR 39
21106: PUSH
21107: LD_VAR 0 2
21111: ST_TO_ADDR
// vc_control := control ;
21112: LD_ADDR_OWVAR 38
21116: PUSH
21117: LD_VAR 0 3
21121: ST_TO_ADDR
// vc_weapon := weapon ;
21122: LD_ADDR_OWVAR 40
21126: PUSH
21127: LD_VAR 0 4
21131: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21132: LD_ADDR_OWVAR 41
21136: PUSH
21137: LD_VAR 0 5
21141: ST_TO_ADDR
// end ;
21142: LD_VAR 0 6
21146: RET
// export function WantPlant ( unit ) ; var task ; begin
21147: LD_INT 0
21149: PPUSH
21150: PPUSH
// result := false ;
21151: LD_ADDR_VAR 0 2
21155: PUSH
21156: LD_INT 0
21158: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21159: LD_ADDR_VAR 0 3
21163: PUSH
21164: LD_VAR 0 1
21168: PPUSH
21169: CALL_OW 437
21173: ST_TO_ADDR
// if task then
21174: LD_VAR 0 3
21178: IFFALSE 21206
// if task [ 1 ] [ 1 ] = p then
21180: LD_VAR 0 3
21184: PUSH
21185: LD_INT 1
21187: ARRAY
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PUSH
21193: LD_STRING p
21195: EQUAL
21196: IFFALSE 21206
// result := true ;
21198: LD_ADDR_VAR 0 2
21202: PUSH
21203: LD_INT 1
21205: ST_TO_ADDR
// end ;
21206: LD_VAR 0 2
21210: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21211: LD_INT 0
21213: PPUSH
21214: PPUSH
21215: PPUSH
21216: PPUSH
// if pos < 1 then
21217: LD_VAR 0 2
21221: PUSH
21222: LD_INT 1
21224: LESS
21225: IFFALSE 21229
// exit ;
21227: GO 21532
// if pos = 1 then
21229: LD_VAR 0 2
21233: PUSH
21234: LD_INT 1
21236: EQUAL
21237: IFFALSE 21270
// result := Replace ( arr , pos [ 1 ] , value ) else
21239: LD_ADDR_VAR 0 4
21243: PUSH
21244: LD_VAR 0 1
21248: PPUSH
21249: LD_VAR 0 2
21253: PUSH
21254: LD_INT 1
21256: ARRAY
21257: PPUSH
21258: LD_VAR 0 3
21262: PPUSH
21263: CALL_OW 1
21267: ST_TO_ADDR
21268: GO 21532
// begin tmp := arr ;
21270: LD_ADDR_VAR 0 6
21274: PUSH
21275: LD_VAR 0 1
21279: ST_TO_ADDR
// s_arr := [ tmp ] ;
21280: LD_ADDR_VAR 0 7
21284: PUSH
21285: LD_VAR 0 6
21289: PUSH
21290: EMPTY
21291: LIST
21292: ST_TO_ADDR
// for i = 1 to pos - 1 do
21293: LD_ADDR_VAR 0 5
21297: PUSH
21298: DOUBLE
21299: LD_INT 1
21301: DEC
21302: ST_TO_ADDR
21303: LD_VAR 0 2
21307: PUSH
21308: LD_INT 1
21310: MINUS
21311: PUSH
21312: FOR_TO
21313: IFFALSE 21358
// begin tmp := tmp [ pos [ i ] ] ;
21315: LD_ADDR_VAR 0 6
21319: PUSH
21320: LD_VAR 0 6
21324: PUSH
21325: LD_VAR 0 2
21329: PUSH
21330: LD_VAR 0 5
21334: ARRAY
21335: ARRAY
21336: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21337: LD_ADDR_VAR 0 7
21341: PUSH
21342: LD_VAR 0 7
21346: PUSH
21347: LD_VAR 0 6
21351: PUSH
21352: EMPTY
21353: LIST
21354: ADD
21355: ST_TO_ADDR
// end ;
21356: GO 21312
21358: POP
21359: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21360: LD_ADDR_VAR 0 6
21364: PUSH
21365: LD_VAR 0 6
21369: PPUSH
21370: LD_VAR 0 2
21374: PUSH
21375: LD_VAR 0 2
21379: ARRAY
21380: PPUSH
21381: LD_VAR 0 3
21385: PPUSH
21386: CALL_OW 1
21390: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21391: LD_ADDR_VAR 0 7
21395: PUSH
21396: LD_VAR 0 7
21400: PPUSH
21401: LD_VAR 0 7
21405: PPUSH
21406: LD_VAR 0 6
21410: PPUSH
21411: CALL_OW 1
21415: ST_TO_ADDR
// for i = s_arr downto 2 do
21416: LD_ADDR_VAR 0 5
21420: PUSH
21421: DOUBLE
21422: LD_VAR 0 7
21426: INC
21427: ST_TO_ADDR
21428: LD_INT 2
21430: PUSH
21431: FOR_DOWNTO
21432: IFFALSE 21516
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21434: LD_ADDR_VAR 0 6
21438: PUSH
21439: LD_VAR 0 7
21443: PUSH
21444: LD_VAR 0 5
21448: PUSH
21449: LD_INT 1
21451: MINUS
21452: ARRAY
21453: PPUSH
21454: LD_VAR 0 2
21458: PUSH
21459: LD_VAR 0 5
21463: PUSH
21464: LD_INT 1
21466: MINUS
21467: ARRAY
21468: PPUSH
21469: LD_VAR 0 7
21473: PUSH
21474: LD_VAR 0 5
21478: ARRAY
21479: PPUSH
21480: CALL_OW 1
21484: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21485: LD_ADDR_VAR 0 7
21489: PUSH
21490: LD_VAR 0 7
21494: PPUSH
21495: LD_VAR 0 5
21499: PUSH
21500: LD_INT 1
21502: MINUS
21503: PPUSH
21504: LD_VAR 0 6
21508: PPUSH
21509: CALL_OW 1
21513: ST_TO_ADDR
// end ;
21514: GO 21431
21516: POP
21517: POP
// result := s_arr [ 1 ] ;
21518: LD_ADDR_VAR 0 4
21522: PUSH
21523: LD_VAR 0 7
21527: PUSH
21528: LD_INT 1
21530: ARRAY
21531: ST_TO_ADDR
// end ; end ;
21532: LD_VAR 0 4
21536: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21537: LD_INT 0
21539: PPUSH
21540: PPUSH
// if not list then
21541: LD_VAR 0 1
21545: NOT
21546: IFFALSE 21550
// exit ;
21548: GO 21641
// i := list [ pos1 ] ;
21550: LD_ADDR_VAR 0 5
21554: PUSH
21555: LD_VAR 0 1
21559: PUSH
21560: LD_VAR 0 2
21564: ARRAY
21565: ST_TO_ADDR
// if not i then
21566: LD_VAR 0 5
21570: NOT
21571: IFFALSE 21575
// exit ;
21573: GO 21641
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21575: LD_ADDR_VAR 0 1
21579: PUSH
21580: LD_VAR 0 1
21584: PPUSH
21585: LD_VAR 0 2
21589: PPUSH
21590: LD_VAR 0 1
21594: PUSH
21595: LD_VAR 0 3
21599: ARRAY
21600: PPUSH
21601: CALL_OW 1
21605: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21606: LD_ADDR_VAR 0 1
21610: PUSH
21611: LD_VAR 0 1
21615: PPUSH
21616: LD_VAR 0 3
21620: PPUSH
21621: LD_VAR 0 5
21625: PPUSH
21626: CALL_OW 1
21630: ST_TO_ADDR
// result := list ;
21631: LD_ADDR_VAR 0 4
21635: PUSH
21636: LD_VAR 0 1
21640: ST_TO_ADDR
// end ;
21641: LD_VAR 0 4
21645: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21646: LD_INT 0
21648: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21649: LD_ADDR_VAR 0 5
21653: PUSH
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL_OW 250
21663: PPUSH
21664: LD_VAR 0 1
21668: PPUSH
21669: CALL_OW 251
21673: PPUSH
21674: LD_VAR 0 2
21678: PPUSH
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_VAR 0 4
21688: PPUSH
21689: CALL 21699 0 5
21693: ST_TO_ADDR
// end ;
21694: LD_VAR 0 5
21698: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21699: LD_INT 0
21701: PPUSH
21702: PPUSH
21703: PPUSH
21704: PPUSH
// if not list then
21705: LD_VAR 0 3
21709: NOT
21710: IFFALSE 21714
// exit ;
21712: GO 22102
// result := [ ] ;
21714: LD_ADDR_VAR 0 6
21718: PUSH
21719: EMPTY
21720: ST_TO_ADDR
// for i in list do
21721: LD_ADDR_VAR 0 7
21725: PUSH
21726: LD_VAR 0 3
21730: PUSH
21731: FOR_IN
21732: IFFALSE 21934
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21734: LD_ADDR_VAR 0 9
21738: PUSH
21739: LD_VAR 0 7
21743: PPUSH
21744: LD_VAR 0 1
21748: PPUSH
21749: LD_VAR 0 2
21753: PPUSH
21754: CALL_OW 297
21758: ST_TO_ADDR
// if not result then
21759: LD_VAR 0 6
21763: NOT
21764: IFFALSE 21790
// result := [ [ i , tmp ] ] else
21766: LD_ADDR_VAR 0 6
21770: PUSH
21771: LD_VAR 0 7
21775: PUSH
21776: LD_VAR 0 9
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: PUSH
21785: EMPTY
21786: LIST
21787: ST_TO_ADDR
21788: GO 21932
// begin if result [ result ] [ 2 ] < tmp then
21790: LD_VAR 0 6
21794: PUSH
21795: LD_VAR 0 6
21799: ARRAY
21800: PUSH
21801: LD_INT 2
21803: ARRAY
21804: PUSH
21805: LD_VAR 0 9
21809: LESS
21810: IFFALSE 21852
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21812: LD_ADDR_VAR 0 6
21816: PUSH
21817: LD_VAR 0 6
21821: PPUSH
21822: LD_VAR 0 6
21826: PUSH
21827: LD_INT 1
21829: PLUS
21830: PPUSH
21831: LD_VAR 0 7
21835: PUSH
21836: LD_VAR 0 9
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PPUSH
21845: CALL_OW 2
21849: ST_TO_ADDR
21850: GO 21932
// for j = 1 to result do
21852: LD_ADDR_VAR 0 8
21856: PUSH
21857: DOUBLE
21858: LD_INT 1
21860: DEC
21861: ST_TO_ADDR
21862: LD_VAR 0 6
21866: PUSH
21867: FOR_TO
21868: IFFALSE 21930
// begin if tmp < result [ j ] [ 2 ] then
21870: LD_VAR 0 9
21874: PUSH
21875: LD_VAR 0 6
21879: PUSH
21880: LD_VAR 0 8
21884: ARRAY
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: LESS
21890: IFFALSE 21928
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21892: LD_ADDR_VAR 0 6
21896: PUSH
21897: LD_VAR 0 6
21901: PPUSH
21902: LD_VAR 0 8
21906: PPUSH
21907: LD_VAR 0 7
21911: PUSH
21912: LD_VAR 0 9
21916: PUSH
21917: EMPTY
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 2
21925: ST_TO_ADDR
// break ;
21926: GO 21930
// end ; end ;
21928: GO 21867
21930: POP
21931: POP
// end ; end ;
21932: GO 21731
21934: POP
21935: POP
// if result and not asc then
21936: LD_VAR 0 6
21940: PUSH
21941: LD_VAR 0 4
21945: NOT
21946: AND
21947: IFFALSE 22022
// begin tmp := result ;
21949: LD_ADDR_VAR 0 9
21953: PUSH
21954: LD_VAR 0 6
21958: ST_TO_ADDR
// for i = tmp downto 1 do
21959: LD_ADDR_VAR 0 7
21963: PUSH
21964: DOUBLE
21965: LD_VAR 0 9
21969: INC
21970: ST_TO_ADDR
21971: LD_INT 1
21973: PUSH
21974: FOR_DOWNTO
21975: IFFALSE 22020
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21977: LD_ADDR_VAR 0 6
21981: PUSH
21982: LD_VAR 0 6
21986: PPUSH
21987: LD_VAR 0 9
21991: PUSH
21992: LD_VAR 0 7
21996: MINUS
21997: PUSH
21998: LD_INT 1
22000: PLUS
22001: PPUSH
22002: LD_VAR 0 9
22006: PUSH
22007: LD_VAR 0 7
22011: ARRAY
22012: PPUSH
22013: CALL_OW 1
22017: ST_TO_ADDR
22018: GO 21974
22020: POP
22021: POP
// end ; tmp := [ ] ;
22022: LD_ADDR_VAR 0 9
22026: PUSH
22027: EMPTY
22028: ST_TO_ADDR
// if mode then
22029: LD_VAR 0 5
22033: IFFALSE 22102
// begin for i = 1 to result do
22035: LD_ADDR_VAR 0 7
22039: PUSH
22040: DOUBLE
22041: LD_INT 1
22043: DEC
22044: ST_TO_ADDR
22045: LD_VAR 0 6
22049: PUSH
22050: FOR_TO
22051: IFFALSE 22090
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22053: LD_ADDR_VAR 0 9
22057: PUSH
22058: LD_VAR 0 9
22062: PPUSH
22063: LD_VAR 0 7
22067: PPUSH
22068: LD_VAR 0 6
22072: PUSH
22073: LD_VAR 0 7
22077: ARRAY
22078: PUSH
22079: LD_INT 1
22081: ARRAY
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
22088: GO 22050
22090: POP
22091: POP
// result := tmp ;
22092: LD_ADDR_VAR 0 6
22096: PUSH
22097: LD_VAR 0 9
22101: ST_TO_ADDR
// end ; end ;
22102: LD_VAR 0 6
22106: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22107: LD_INT 0
22109: PPUSH
22110: PPUSH
22111: PPUSH
22112: PPUSH
22113: PPUSH
22114: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22115: LD_ADDR_VAR 0 5
22119: PUSH
22120: LD_INT 0
22122: PUSH
22123: LD_INT 0
22125: PUSH
22126: LD_INT 0
22128: PUSH
22129: EMPTY
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: LIST
22136: ST_TO_ADDR
// if not x or not y then
22137: LD_VAR 0 2
22141: NOT
22142: PUSH
22143: LD_VAR 0 3
22147: NOT
22148: OR
22149: IFFALSE 22153
// exit ;
22151: GO 23799
// if not range then
22153: LD_VAR 0 4
22157: NOT
22158: IFFALSE 22168
// range := 10 ;
22160: LD_ADDR_VAR 0 4
22164: PUSH
22165: LD_INT 10
22167: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22168: LD_ADDR_VAR 0 8
22172: PUSH
22173: LD_INT 81
22175: PUSH
22176: LD_VAR 0 1
22180: PUSH
22181: EMPTY
22182: LIST
22183: LIST
22184: PUSH
22185: LD_INT 92
22187: PUSH
22188: LD_VAR 0 2
22192: PUSH
22193: LD_VAR 0 3
22197: PUSH
22198: LD_VAR 0 4
22202: PUSH
22203: EMPTY
22204: LIST
22205: LIST
22206: LIST
22207: LIST
22208: PUSH
22209: LD_INT 3
22211: PUSH
22212: LD_INT 21
22214: PUSH
22215: LD_INT 3
22217: PUSH
22218: EMPTY
22219: LIST
22220: LIST
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: EMPTY
22227: LIST
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: ST_TO_ADDR
// if not tmp then
22236: LD_VAR 0 8
22240: NOT
22241: IFFALSE 22245
// exit ;
22243: GO 23799
// for i in tmp do
22245: LD_ADDR_VAR 0 6
22249: PUSH
22250: LD_VAR 0 8
22254: PUSH
22255: FOR_IN
22256: IFFALSE 23774
// begin points := [ 0 , 0 , 0 ] ;
22258: LD_ADDR_VAR 0 9
22262: PUSH
22263: LD_INT 0
22265: PUSH
22266: LD_INT 0
22268: PUSH
22269: LD_INT 0
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: LIST
22276: ST_TO_ADDR
// bpoints := 1 ;
22277: LD_ADDR_VAR 0 10
22281: PUSH
22282: LD_INT 1
22284: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22285: LD_VAR 0 6
22289: PPUSH
22290: CALL_OW 247
22294: PUSH
22295: LD_INT 1
22297: DOUBLE
22298: EQUAL
22299: IFTRUE 22303
22301: GO 22881
22303: POP
// begin if GetClass ( i ) = 1 then
22304: LD_VAR 0 6
22308: PPUSH
22309: CALL_OW 257
22313: PUSH
22314: LD_INT 1
22316: EQUAL
22317: IFFALSE 22338
// points := [ 10 , 5 , 3 ] ;
22319: LD_ADDR_VAR 0 9
22323: PUSH
22324: LD_INT 10
22326: PUSH
22327: LD_INT 5
22329: PUSH
22330: LD_INT 3
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: LIST
22337: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22338: LD_VAR 0 6
22342: PPUSH
22343: CALL_OW 257
22347: PUSH
22348: LD_INT 2
22350: PUSH
22351: LD_INT 3
22353: PUSH
22354: LD_INT 4
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: LIST
22361: IN
22362: IFFALSE 22383
// points := [ 3 , 2 , 1 ] ;
22364: LD_ADDR_VAR 0 9
22368: PUSH
22369: LD_INT 3
22371: PUSH
22372: LD_INT 2
22374: PUSH
22375: LD_INT 1
22377: PUSH
22378: EMPTY
22379: LIST
22380: LIST
22381: LIST
22382: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22383: LD_VAR 0 6
22387: PPUSH
22388: CALL_OW 257
22392: PUSH
22393: LD_INT 5
22395: EQUAL
22396: IFFALSE 22417
// points := [ 130 , 5 , 2 ] ;
22398: LD_ADDR_VAR 0 9
22402: PUSH
22403: LD_INT 130
22405: PUSH
22406: LD_INT 5
22408: PUSH
22409: LD_INT 2
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: LIST
22416: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22417: LD_VAR 0 6
22421: PPUSH
22422: CALL_OW 257
22426: PUSH
22427: LD_INT 8
22429: EQUAL
22430: IFFALSE 22451
// points := [ 35 , 35 , 30 ] ;
22432: LD_ADDR_VAR 0 9
22436: PUSH
22437: LD_INT 35
22439: PUSH
22440: LD_INT 35
22442: PUSH
22443: LD_INT 30
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: LIST
22450: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22451: LD_VAR 0 6
22455: PPUSH
22456: CALL_OW 257
22460: PUSH
22461: LD_INT 9
22463: EQUAL
22464: IFFALSE 22485
// points := [ 20 , 55 , 40 ] ;
22466: LD_ADDR_VAR 0 9
22470: PUSH
22471: LD_INT 20
22473: PUSH
22474: LD_INT 55
22476: PUSH
22477: LD_INT 40
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: LIST
22484: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22485: LD_VAR 0 6
22489: PPUSH
22490: CALL_OW 257
22494: PUSH
22495: LD_INT 12
22497: PUSH
22498: LD_INT 16
22500: PUSH
22501: EMPTY
22502: LIST
22503: LIST
22504: IN
22505: IFFALSE 22526
// points := [ 5 , 3 , 2 ] ;
22507: LD_ADDR_VAR 0 9
22511: PUSH
22512: LD_INT 5
22514: PUSH
22515: LD_INT 3
22517: PUSH
22518: LD_INT 2
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: LIST
22525: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22526: LD_VAR 0 6
22530: PPUSH
22531: CALL_OW 257
22535: PUSH
22536: LD_INT 17
22538: EQUAL
22539: IFFALSE 22560
// points := [ 100 , 50 , 75 ] ;
22541: LD_ADDR_VAR 0 9
22545: PUSH
22546: LD_INT 100
22548: PUSH
22549: LD_INT 50
22551: PUSH
22552: LD_INT 75
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22560: LD_VAR 0 6
22564: PPUSH
22565: CALL_OW 257
22569: PUSH
22570: LD_INT 15
22572: EQUAL
22573: IFFALSE 22594
// points := [ 10 , 5 , 3 ] ;
22575: LD_ADDR_VAR 0 9
22579: PUSH
22580: LD_INT 10
22582: PUSH
22583: LD_INT 5
22585: PUSH
22586: LD_INT 3
22588: PUSH
22589: EMPTY
22590: LIST
22591: LIST
22592: LIST
22593: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22594: LD_VAR 0 6
22598: PPUSH
22599: CALL_OW 257
22603: PUSH
22604: LD_INT 14
22606: EQUAL
22607: IFFALSE 22628
// points := [ 10 , 0 , 0 ] ;
22609: LD_ADDR_VAR 0 9
22613: PUSH
22614: LD_INT 10
22616: PUSH
22617: LD_INT 0
22619: PUSH
22620: LD_INT 0
22622: PUSH
22623: EMPTY
22624: LIST
22625: LIST
22626: LIST
22627: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22628: LD_VAR 0 6
22632: PPUSH
22633: CALL_OW 257
22637: PUSH
22638: LD_INT 11
22640: EQUAL
22641: IFFALSE 22662
// points := [ 30 , 10 , 5 ] ;
22643: LD_ADDR_VAR 0 9
22647: PUSH
22648: LD_INT 30
22650: PUSH
22651: LD_INT 10
22653: PUSH
22654: LD_INT 5
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: LIST
22661: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22662: LD_VAR 0 1
22666: PPUSH
22667: LD_INT 5
22669: PPUSH
22670: CALL_OW 321
22674: PUSH
22675: LD_INT 2
22677: EQUAL
22678: IFFALSE 22695
// bpoints := bpoints * 1.8 ;
22680: LD_ADDR_VAR 0 10
22684: PUSH
22685: LD_VAR 0 10
22689: PUSH
22690: LD_REAL  1.80000000000000E+0000
22693: MUL
22694: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22695: LD_VAR 0 6
22699: PPUSH
22700: CALL_OW 257
22704: PUSH
22705: LD_INT 1
22707: PUSH
22708: LD_INT 2
22710: PUSH
22711: LD_INT 3
22713: PUSH
22714: LD_INT 4
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: LIST
22721: LIST
22722: IN
22723: PUSH
22724: LD_VAR 0 1
22728: PPUSH
22729: LD_INT 51
22731: PPUSH
22732: CALL_OW 321
22736: PUSH
22737: LD_INT 2
22739: EQUAL
22740: AND
22741: IFFALSE 22758
// bpoints := bpoints * 1.2 ;
22743: LD_ADDR_VAR 0 10
22747: PUSH
22748: LD_VAR 0 10
22752: PUSH
22753: LD_REAL  1.20000000000000E+0000
22756: MUL
22757: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22758: LD_VAR 0 6
22762: PPUSH
22763: CALL_OW 257
22767: PUSH
22768: LD_INT 5
22770: PUSH
22771: LD_INT 7
22773: PUSH
22774: LD_INT 9
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: IN
22782: PUSH
22783: LD_VAR 0 1
22787: PPUSH
22788: LD_INT 52
22790: PPUSH
22791: CALL_OW 321
22795: PUSH
22796: LD_INT 2
22798: EQUAL
22799: AND
22800: IFFALSE 22817
// bpoints := bpoints * 1.5 ;
22802: LD_ADDR_VAR 0 10
22806: PUSH
22807: LD_VAR 0 10
22811: PUSH
22812: LD_REAL  1.50000000000000E+0000
22815: MUL
22816: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22817: LD_VAR 0 1
22821: PPUSH
22822: LD_INT 66
22824: PPUSH
22825: CALL_OW 321
22829: PUSH
22830: LD_INT 2
22832: EQUAL
22833: IFFALSE 22850
// bpoints := bpoints * 1.1 ;
22835: LD_ADDR_VAR 0 10
22839: PUSH
22840: LD_VAR 0 10
22844: PUSH
22845: LD_REAL  1.10000000000000E+0000
22848: MUL
22849: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22850: LD_ADDR_VAR 0 10
22854: PUSH
22855: LD_VAR 0 10
22859: PUSH
22860: LD_VAR 0 6
22864: PPUSH
22865: LD_INT 1
22867: PPUSH
22868: CALL_OW 259
22872: PUSH
22873: LD_REAL  1.15000000000000E+0000
22876: MUL
22877: MUL
22878: ST_TO_ADDR
// end ; unit_vehicle :
22879: GO 23703
22881: LD_INT 2
22883: DOUBLE
22884: EQUAL
22885: IFTRUE 22889
22887: GO 23691
22889: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22890: LD_VAR 0 6
22894: PPUSH
22895: CALL_OW 264
22899: PUSH
22900: LD_INT 2
22902: PUSH
22903: LD_INT 42
22905: PUSH
22906: LD_INT 24
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: LIST
22913: IN
22914: IFFALSE 22935
// points := [ 25 , 5 , 3 ] ;
22916: LD_ADDR_VAR 0 9
22920: PUSH
22921: LD_INT 25
22923: PUSH
22924: LD_INT 5
22926: PUSH
22927: LD_INT 3
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: LIST
22934: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22935: LD_VAR 0 6
22939: PPUSH
22940: CALL_OW 264
22944: PUSH
22945: LD_INT 4
22947: PUSH
22948: LD_INT 43
22950: PUSH
22951: LD_INT 25
22953: PUSH
22954: EMPTY
22955: LIST
22956: LIST
22957: LIST
22958: IN
22959: IFFALSE 22980
// points := [ 40 , 15 , 5 ] ;
22961: LD_ADDR_VAR 0 9
22965: PUSH
22966: LD_INT 40
22968: PUSH
22969: LD_INT 15
22971: PUSH
22972: LD_INT 5
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: LIST
22979: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22980: LD_VAR 0 6
22984: PPUSH
22985: CALL_OW 264
22989: PUSH
22990: LD_INT 3
22992: PUSH
22993: LD_INT 23
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: IN
23000: IFFALSE 23021
// points := [ 7 , 25 , 8 ] ;
23002: LD_ADDR_VAR 0 9
23006: PUSH
23007: LD_INT 7
23009: PUSH
23010: LD_INT 25
23012: PUSH
23013: LD_INT 8
23015: PUSH
23016: EMPTY
23017: LIST
23018: LIST
23019: LIST
23020: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23021: LD_VAR 0 6
23025: PPUSH
23026: CALL_OW 264
23030: PUSH
23031: LD_INT 5
23033: PUSH
23034: LD_INT 27
23036: PUSH
23037: LD_INT 44
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: LIST
23044: IN
23045: IFFALSE 23066
// points := [ 14 , 50 , 16 ] ;
23047: LD_ADDR_VAR 0 9
23051: PUSH
23052: LD_INT 14
23054: PUSH
23055: LD_INT 50
23057: PUSH
23058: LD_INT 16
23060: PUSH
23061: EMPTY
23062: LIST
23063: LIST
23064: LIST
23065: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23066: LD_VAR 0 6
23070: PPUSH
23071: CALL_OW 264
23075: PUSH
23076: LD_INT 6
23078: PUSH
23079: LD_INT 46
23081: PUSH
23082: EMPTY
23083: LIST
23084: LIST
23085: IN
23086: IFFALSE 23107
// points := [ 32 , 120 , 70 ] ;
23088: LD_ADDR_VAR 0 9
23092: PUSH
23093: LD_INT 32
23095: PUSH
23096: LD_INT 120
23098: PUSH
23099: LD_INT 70
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: LIST
23106: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23107: LD_VAR 0 6
23111: PPUSH
23112: CALL_OW 264
23116: PUSH
23117: LD_INT 7
23119: PUSH
23120: LD_INT 28
23122: PUSH
23123: LD_INT 45
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: LIST
23130: IN
23131: IFFALSE 23152
// points := [ 35 , 20 , 45 ] ;
23133: LD_ADDR_VAR 0 9
23137: PUSH
23138: LD_INT 35
23140: PUSH
23141: LD_INT 20
23143: PUSH
23144: LD_INT 45
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: LIST
23151: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23152: LD_VAR 0 6
23156: PPUSH
23157: CALL_OW 264
23161: PUSH
23162: LD_INT 47
23164: PUSH
23165: EMPTY
23166: LIST
23167: IN
23168: IFFALSE 23189
// points := [ 67 , 45 , 75 ] ;
23170: LD_ADDR_VAR 0 9
23174: PUSH
23175: LD_INT 67
23177: PUSH
23178: LD_INT 45
23180: PUSH
23181: LD_INT 75
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23189: LD_VAR 0 6
23193: PPUSH
23194: CALL_OW 264
23198: PUSH
23199: LD_INT 26
23201: PUSH
23202: EMPTY
23203: LIST
23204: IN
23205: IFFALSE 23226
// points := [ 120 , 30 , 80 ] ;
23207: LD_ADDR_VAR 0 9
23211: PUSH
23212: LD_INT 120
23214: PUSH
23215: LD_INT 30
23217: PUSH
23218: LD_INT 80
23220: PUSH
23221: EMPTY
23222: LIST
23223: LIST
23224: LIST
23225: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23226: LD_VAR 0 6
23230: PPUSH
23231: CALL_OW 264
23235: PUSH
23236: LD_INT 22
23238: PUSH
23239: EMPTY
23240: LIST
23241: IN
23242: IFFALSE 23263
// points := [ 40 , 1 , 1 ] ;
23244: LD_ADDR_VAR 0 9
23248: PUSH
23249: LD_INT 40
23251: PUSH
23252: LD_INT 1
23254: PUSH
23255: LD_INT 1
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23263: LD_VAR 0 6
23267: PPUSH
23268: CALL_OW 264
23272: PUSH
23273: LD_INT 29
23275: PUSH
23276: EMPTY
23277: LIST
23278: IN
23279: IFFALSE 23300
// points := [ 70 , 200 , 400 ] ;
23281: LD_ADDR_VAR 0 9
23285: PUSH
23286: LD_INT 70
23288: PUSH
23289: LD_INT 200
23291: PUSH
23292: LD_INT 400
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: LIST
23299: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23300: LD_VAR 0 6
23304: PPUSH
23305: CALL_OW 264
23309: PUSH
23310: LD_INT 14
23312: PUSH
23313: LD_INT 53
23315: PUSH
23316: EMPTY
23317: LIST
23318: LIST
23319: IN
23320: IFFALSE 23341
// points := [ 40 , 10 , 20 ] ;
23322: LD_ADDR_VAR 0 9
23326: PUSH
23327: LD_INT 40
23329: PUSH
23330: LD_INT 10
23332: PUSH
23333: LD_INT 20
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: LIST
23340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 264
23350: PUSH
23351: LD_INT 9
23353: PUSH
23354: EMPTY
23355: LIST
23356: IN
23357: IFFALSE 23378
// points := [ 5 , 70 , 20 ] ;
23359: LD_ADDR_VAR 0 9
23363: PUSH
23364: LD_INT 5
23366: PUSH
23367: LD_INT 70
23369: PUSH
23370: LD_INT 20
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: LIST
23377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23378: LD_VAR 0 6
23382: PPUSH
23383: CALL_OW 264
23387: PUSH
23388: LD_INT 10
23390: PUSH
23391: EMPTY
23392: LIST
23393: IN
23394: IFFALSE 23415
// points := [ 35 , 110 , 70 ] ;
23396: LD_ADDR_VAR 0 9
23400: PUSH
23401: LD_INT 35
23403: PUSH
23404: LD_INT 110
23406: PUSH
23407: LD_INT 70
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: LIST
23414: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23415: LD_VAR 0 6
23419: PPUSH
23420: CALL_OW 265
23424: PUSH
23425: LD_INT 25
23427: EQUAL
23428: IFFALSE 23449
// points := [ 80 , 65 , 100 ] ;
23430: LD_ADDR_VAR 0 9
23434: PUSH
23435: LD_INT 80
23437: PUSH
23438: LD_INT 65
23440: PUSH
23441: LD_INT 100
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23449: LD_VAR 0 6
23453: PPUSH
23454: CALL_OW 263
23458: PUSH
23459: LD_INT 1
23461: EQUAL
23462: IFFALSE 23497
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23464: LD_ADDR_VAR 0 10
23468: PUSH
23469: LD_VAR 0 10
23473: PUSH
23474: LD_VAR 0 6
23478: PPUSH
23479: CALL_OW 311
23483: PPUSH
23484: LD_INT 3
23486: PPUSH
23487: CALL_OW 259
23491: PUSH
23492: LD_INT 4
23494: MUL
23495: MUL
23496: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23497: LD_VAR 0 6
23501: PPUSH
23502: CALL_OW 263
23506: PUSH
23507: LD_INT 2
23509: EQUAL
23510: IFFALSE 23561
// begin j := IsControledBy ( i ) ;
23512: LD_ADDR_VAR 0 7
23516: PUSH
23517: LD_VAR 0 6
23521: PPUSH
23522: CALL_OW 312
23526: ST_TO_ADDR
// if j then
23527: LD_VAR 0 7
23531: IFFALSE 23561
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23533: LD_ADDR_VAR 0 10
23537: PUSH
23538: LD_VAR 0 10
23542: PUSH
23543: LD_VAR 0 7
23547: PPUSH
23548: LD_INT 3
23550: PPUSH
23551: CALL_OW 259
23555: PUSH
23556: LD_INT 3
23558: MUL
23559: MUL
23560: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23561: LD_VAR 0 6
23565: PPUSH
23566: CALL_OW 264
23570: PUSH
23571: LD_INT 5
23573: PUSH
23574: LD_INT 6
23576: PUSH
23577: LD_INT 46
23579: PUSH
23580: LD_INT 44
23582: PUSH
23583: LD_INT 47
23585: PUSH
23586: LD_INT 45
23588: PUSH
23589: LD_INT 28
23591: PUSH
23592: LD_INT 7
23594: PUSH
23595: LD_INT 27
23597: PUSH
23598: LD_INT 29
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: LIST
23607: LIST
23608: LIST
23609: LIST
23610: LIST
23611: LIST
23612: IN
23613: PUSH
23614: LD_VAR 0 1
23618: PPUSH
23619: LD_INT 52
23621: PPUSH
23622: CALL_OW 321
23626: PUSH
23627: LD_INT 2
23629: EQUAL
23630: AND
23631: IFFALSE 23648
// bpoints := bpoints * 1.2 ;
23633: LD_ADDR_VAR 0 10
23637: PUSH
23638: LD_VAR 0 10
23642: PUSH
23643: LD_REAL  1.20000000000000E+0000
23646: MUL
23647: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23648: LD_VAR 0 6
23652: PPUSH
23653: CALL_OW 264
23657: PUSH
23658: LD_INT 6
23660: PUSH
23661: LD_INT 46
23663: PUSH
23664: LD_INT 47
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: IN
23672: IFFALSE 23689
// bpoints := bpoints * 1.2 ;
23674: LD_ADDR_VAR 0 10
23678: PUSH
23679: LD_VAR 0 10
23683: PUSH
23684: LD_REAL  1.20000000000000E+0000
23687: MUL
23688: ST_TO_ADDR
// end ; unit_building :
23689: GO 23703
23691: LD_INT 3
23693: DOUBLE
23694: EQUAL
23695: IFTRUE 23699
23697: GO 23702
23699: POP
// ; end ;
23700: GO 23703
23702: POP
// for j = 1 to 3 do
23703: LD_ADDR_VAR 0 7
23707: PUSH
23708: DOUBLE
23709: LD_INT 1
23711: DEC
23712: ST_TO_ADDR
23713: LD_INT 3
23715: PUSH
23716: FOR_TO
23717: IFFALSE 23770
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23719: LD_ADDR_VAR 0 5
23723: PUSH
23724: LD_VAR 0 5
23728: PPUSH
23729: LD_VAR 0 7
23733: PPUSH
23734: LD_VAR 0 5
23738: PUSH
23739: LD_VAR 0 7
23743: ARRAY
23744: PUSH
23745: LD_VAR 0 9
23749: PUSH
23750: LD_VAR 0 7
23754: ARRAY
23755: PUSH
23756: LD_VAR 0 10
23760: MUL
23761: PLUS
23762: PPUSH
23763: CALL_OW 1
23767: ST_TO_ADDR
23768: GO 23716
23770: POP
23771: POP
// end ;
23772: GO 22255
23774: POP
23775: POP
// result := Replace ( result , 4 , tmp ) ;
23776: LD_ADDR_VAR 0 5
23780: PUSH
23781: LD_VAR 0 5
23785: PPUSH
23786: LD_INT 4
23788: PPUSH
23789: LD_VAR 0 8
23793: PPUSH
23794: CALL_OW 1
23798: ST_TO_ADDR
// end ;
23799: LD_VAR 0 5
23803: RET
// export function DangerAtRange ( unit , range ) ; begin
23804: LD_INT 0
23806: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23807: LD_ADDR_VAR 0 3
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: CALL_OW 255
23821: PPUSH
23822: LD_VAR 0 1
23826: PPUSH
23827: CALL_OW 250
23831: PPUSH
23832: LD_VAR 0 1
23836: PPUSH
23837: CALL_OW 251
23841: PPUSH
23842: LD_VAR 0 2
23846: PPUSH
23847: CALL 22107 0 4
23851: ST_TO_ADDR
// end ;
23852: LD_VAR 0 3
23856: RET
// export function DangerInArea ( side , area ) ; begin
23857: LD_INT 0
23859: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23860: LD_ADDR_VAR 0 3
23864: PUSH
23865: LD_VAR 0 2
23869: PPUSH
23870: LD_INT 81
23872: PUSH
23873: LD_VAR 0 1
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PPUSH
23882: CALL_OW 70
23886: ST_TO_ADDR
// end ;
23887: LD_VAR 0 3
23891: RET
// export function IsExtension ( b ) ; begin
23892: LD_INT 0
23894: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23895: LD_ADDR_VAR 0 2
23899: PUSH
23900: LD_VAR 0 1
23904: PUSH
23905: LD_INT 23
23907: PUSH
23908: LD_INT 20
23910: PUSH
23911: LD_INT 22
23913: PUSH
23914: LD_INT 17
23916: PUSH
23917: LD_INT 24
23919: PUSH
23920: LD_INT 21
23922: PUSH
23923: LD_INT 19
23925: PUSH
23926: LD_INT 16
23928: PUSH
23929: LD_INT 25
23931: PUSH
23932: LD_INT 18
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: LIST
23944: LIST
23945: LIST
23946: IN
23947: ST_TO_ADDR
// end ;
23948: LD_VAR 0 2
23952: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23953: LD_INT 0
23955: PPUSH
23956: PPUSH
23957: PPUSH
// result := [ ] ;
23958: LD_ADDR_VAR 0 3
23962: PUSH
23963: EMPTY
23964: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23965: LD_ADDR_VAR 0 4
23969: PUSH
23970: LD_VAR 0 2
23974: PPUSH
23975: LD_INT 21
23977: PUSH
23978: LD_INT 3
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PPUSH
23985: CALL_OW 70
23989: ST_TO_ADDR
// if not tmp then
23990: LD_VAR 0 4
23994: NOT
23995: IFFALSE 23999
// exit ;
23997: GO 24057
// for i in tmp do
23999: LD_ADDR_VAR 0 5
24003: PUSH
24004: LD_VAR 0 4
24008: PUSH
24009: FOR_IN
24010: IFFALSE 24045
// if GetBase ( i ) <> base then
24012: LD_VAR 0 5
24016: PPUSH
24017: CALL_OW 274
24021: PUSH
24022: LD_VAR 0 1
24026: NONEQUAL
24027: IFFALSE 24043
// ComLinkToBase ( base , i ) ;
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_VAR 0 5
24038: PPUSH
24039: CALL_OW 169
24043: GO 24009
24045: POP
24046: POP
// result := tmp ;
24047: LD_ADDR_VAR 0 3
24051: PUSH
24052: LD_VAR 0 4
24056: ST_TO_ADDR
// end ;
24057: LD_VAR 0 3
24061: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24062: LD_INT 0
24064: PPUSH
24065: PPUSH
// if BuildingStatus ( b ) = bs_build then
24066: LD_VAR 0 2
24070: PPUSH
24071: CALL_OW 461
24075: PUSH
24076: LD_INT 1
24078: EQUAL
24079: IFFALSE 24139
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24081: LD_VAR 0 1
24085: PPUSH
24086: LD_STRING h
24088: PUSH
24089: LD_VAR 0 2
24093: PPUSH
24094: CALL_OW 250
24098: PUSH
24099: LD_VAR 0 2
24103: PPUSH
24104: CALL_OW 251
24108: PUSH
24109: LD_VAR 0 2
24113: PUSH
24114: LD_INT 0
24116: PUSH
24117: LD_INT 0
24119: PUSH
24120: LD_INT 0
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: PUSH
24132: EMPTY
24133: LIST
24134: PPUSH
24135: CALL_OW 446
// end ;
24139: LD_VAR 0 3
24143: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24144: LD_INT 0
24146: PPUSH
24147: PPUSH
24148: PPUSH
24149: PPUSH
24150: PPUSH
24151: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24152: LD_VAR 0 1
24156: NOT
24157: PUSH
24158: LD_VAR 0 1
24162: PPUSH
24163: CALL_OW 263
24167: PUSH
24168: LD_INT 2
24170: EQUAL
24171: NOT
24172: OR
24173: IFFALSE 24177
// exit ;
24175: GO 24493
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24177: LD_ADDR_VAR 0 6
24181: PUSH
24182: LD_INT 22
24184: PUSH
24185: LD_VAR 0 1
24189: PPUSH
24190: CALL_OW 255
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: LD_INT 2
24201: PUSH
24202: LD_INT 30
24204: PUSH
24205: LD_INT 36
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PUSH
24212: LD_INT 34
24214: PUSH
24215: LD_INT 31
24217: PUSH
24218: EMPTY
24219: LIST
24220: LIST
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: LIST
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PPUSH
24231: CALL_OW 69
24235: ST_TO_ADDR
// if not tmp then
24236: LD_VAR 0 6
24240: NOT
24241: IFFALSE 24245
// exit ;
24243: GO 24493
// result := [ ] ;
24245: LD_ADDR_VAR 0 2
24249: PUSH
24250: EMPTY
24251: ST_TO_ADDR
// for i in tmp do
24252: LD_ADDR_VAR 0 3
24256: PUSH
24257: LD_VAR 0 6
24261: PUSH
24262: FOR_IN
24263: IFFALSE 24334
// begin t := UnitsInside ( i ) ;
24265: LD_ADDR_VAR 0 4
24269: PUSH
24270: LD_VAR 0 3
24274: PPUSH
24275: CALL_OW 313
24279: ST_TO_ADDR
// if t then
24280: LD_VAR 0 4
24284: IFFALSE 24332
// for j in t do
24286: LD_ADDR_VAR 0 7
24290: PUSH
24291: LD_VAR 0 4
24295: PUSH
24296: FOR_IN
24297: IFFALSE 24330
// result := Insert ( result , result + 1 , j ) ;
24299: LD_ADDR_VAR 0 2
24303: PUSH
24304: LD_VAR 0 2
24308: PPUSH
24309: LD_VAR 0 2
24313: PUSH
24314: LD_INT 1
24316: PLUS
24317: PPUSH
24318: LD_VAR 0 7
24322: PPUSH
24323: CALL_OW 2
24327: ST_TO_ADDR
24328: GO 24296
24330: POP
24331: POP
// end ;
24332: GO 24262
24334: POP
24335: POP
// if not result then
24336: LD_VAR 0 2
24340: NOT
24341: IFFALSE 24345
// exit ;
24343: GO 24493
// mech := result [ 1 ] ;
24345: LD_ADDR_VAR 0 5
24349: PUSH
24350: LD_VAR 0 2
24354: PUSH
24355: LD_INT 1
24357: ARRAY
24358: ST_TO_ADDR
// if result > 1 then
24359: LD_VAR 0 2
24363: PUSH
24364: LD_INT 1
24366: GREATER
24367: IFFALSE 24479
// for i = 2 to result do
24369: LD_ADDR_VAR 0 3
24373: PUSH
24374: DOUBLE
24375: LD_INT 2
24377: DEC
24378: ST_TO_ADDR
24379: LD_VAR 0 2
24383: PUSH
24384: FOR_TO
24385: IFFALSE 24477
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24387: LD_ADDR_VAR 0 4
24391: PUSH
24392: LD_VAR 0 2
24396: PUSH
24397: LD_VAR 0 3
24401: ARRAY
24402: PPUSH
24403: LD_INT 3
24405: PPUSH
24406: CALL_OW 259
24410: PUSH
24411: LD_VAR 0 2
24415: PUSH
24416: LD_VAR 0 3
24420: ARRAY
24421: PPUSH
24422: CALL_OW 432
24426: MINUS
24427: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24428: LD_VAR 0 4
24432: PUSH
24433: LD_VAR 0 5
24437: PPUSH
24438: LD_INT 3
24440: PPUSH
24441: CALL_OW 259
24445: PUSH
24446: LD_VAR 0 5
24450: PPUSH
24451: CALL_OW 432
24455: MINUS
24456: GREATEREQUAL
24457: IFFALSE 24475
// mech := result [ i ] ;
24459: LD_ADDR_VAR 0 5
24463: PUSH
24464: LD_VAR 0 2
24468: PUSH
24469: LD_VAR 0 3
24473: ARRAY
24474: ST_TO_ADDR
// end ;
24475: GO 24384
24477: POP
24478: POP
// ComLinkTo ( vehicle , mech ) ;
24479: LD_VAR 0 1
24483: PPUSH
24484: LD_VAR 0 5
24488: PPUSH
24489: CALL_OW 135
// end ;
24493: LD_VAR 0 2
24497: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24498: LD_INT 0
24500: PPUSH
24501: PPUSH
24502: PPUSH
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
24509: PPUSH
24510: PPUSH
24511: PPUSH
24512: PPUSH
// result := [ ] ;
24513: LD_ADDR_VAR 0 7
24517: PUSH
24518: EMPTY
24519: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24520: LD_VAR 0 1
24524: PPUSH
24525: CALL_OW 266
24529: PUSH
24530: LD_INT 0
24532: PUSH
24533: LD_INT 1
24535: PUSH
24536: EMPTY
24537: LIST
24538: LIST
24539: IN
24540: NOT
24541: IFFALSE 24545
// exit ;
24543: GO 26176
// if name then
24545: LD_VAR 0 3
24549: IFFALSE 24565
// SetBName ( base_dep , name ) ;
24551: LD_VAR 0 1
24555: PPUSH
24556: LD_VAR 0 3
24560: PPUSH
24561: CALL_OW 500
// base := GetBase ( base_dep ) ;
24565: LD_ADDR_VAR 0 15
24569: PUSH
24570: LD_VAR 0 1
24574: PPUSH
24575: CALL_OW 274
24579: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24580: LD_ADDR_VAR 0 16
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: CALL_OW 255
24594: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24595: LD_ADDR_VAR 0 17
24599: PUSH
24600: LD_VAR 0 1
24604: PPUSH
24605: CALL_OW 248
24609: ST_TO_ADDR
// if sources then
24610: LD_VAR 0 5
24614: IFFALSE 24661
// for i = 1 to 3 do
24616: LD_ADDR_VAR 0 8
24620: PUSH
24621: DOUBLE
24622: LD_INT 1
24624: DEC
24625: ST_TO_ADDR
24626: LD_INT 3
24628: PUSH
24629: FOR_TO
24630: IFFALSE 24659
// AddResourceType ( base , i , sources [ i ] ) ;
24632: LD_VAR 0 15
24636: PPUSH
24637: LD_VAR 0 8
24641: PPUSH
24642: LD_VAR 0 5
24646: PUSH
24647: LD_VAR 0 8
24651: ARRAY
24652: PPUSH
24653: CALL_OW 276
24657: GO 24629
24659: POP
24660: POP
// buildings := GetBaseBuildings ( base , area ) ;
24661: LD_ADDR_VAR 0 18
24665: PUSH
24666: LD_VAR 0 15
24670: PPUSH
24671: LD_VAR 0 2
24675: PPUSH
24676: CALL 23953 0 2
24680: ST_TO_ADDR
// InitHc ;
24681: CALL_OW 19
// InitUc ;
24685: CALL_OW 18
// uc_side := side ;
24689: LD_ADDR_OWVAR 20
24693: PUSH
24694: LD_VAR 0 16
24698: ST_TO_ADDR
// uc_nation := nation ;
24699: LD_ADDR_OWVAR 21
24703: PUSH
24704: LD_VAR 0 17
24708: ST_TO_ADDR
// if buildings then
24709: LD_VAR 0 18
24713: IFFALSE 26035
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24715: LD_ADDR_VAR 0 19
24719: PUSH
24720: LD_VAR 0 18
24724: PPUSH
24725: LD_INT 2
24727: PUSH
24728: LD_INT 30
24730: PUSH
24731: LD_INT 29
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 30
24740: PUSH
24741: LD_INT 30
24743: PUSH
24744: EMPTY
24745: LIST
24746: LIST
24747: PUSH
24748: EMPTY
24749: LIST
24750: LIST
24751: LIST
24752: PPUSH
24753: CALL_OW 72
24757: ST_TO_ADDR
// if tmp then
24758: LD_VAR 0 19
24762: IFFALSE 24810
// for i in tmp do
24764: LD_ADDR_VAR 0 8
24768: PUSH
24769: LD_VAR 0 19
24773: PUSH
24774: FOR_IN
24775: IFFALSE 24808
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24777: LD_VAR 0 8
24781: PPUSH
24782: CALL_OW 250
24786: PPUSH
24787: LD_VAR 0 8
24791: PPUSH
24792: CALL_OW 251
24796: PPUSH
24797: LD_VAR 0 16
24801: PPUSH
24802: CALL_OW 441
24806: GO 24774
24808: POP
24809: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24810: LD_VAR 0 18
24814: PPUSH
24815: LD_INT 2
24817: PUSH
24818: LD_INT 30
24820: PUSH
24821: LD_INT 32
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 30
24830: PUSH
24831: LD_INT 33
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: PUSH
24838: EMPTY
24839: LIST
24840: LIST
24841: LIST
24842: PPUSH
24843: CALL_OW 72
24847: IFFALSE 24935
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24849: LD_ADDR_VAR 0 8
24853: PUSH
24854: LD_VAR 0 18
24858: PPUSH
24859: LD_INT 2
24861: PUSH
24862: LD_INT 30
24864: PUSH
24865: LD_INT 32
24867: PUSH
24868: EMPTY
24869: LIST
24870: LIST
24871: PUSH
24872: LD_INT 30
24874: PUSH
24875: LD_INT 33
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: LIST
24886: PPUSH
24887: CALL_OW 72
24891: PUSH
24892: FOR_IN
24893: IFFALSE 24933
// begin if not GetBWeapon ( i ) then
24895: LD_VAR 0 8
24899: PPUSH
24900: CALL_OW 269
24904: NOT
24905: IFFALSE 24931
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24907: LD_VAR 0 8
24911: PPUSH
24912: LD_VAR 0 8
24916: PPUSH
24917: LD_VAR 0 2
24921: PPUSH
24922: CALL 26181 0 2
24926: PPUSH
24927: CALL_OW 431
// end ;
24931: GO 24892
24933: POP
24934: POP
// end ; for i = 1 to personel do
24935: LD_ADDR_VAR 0 8
24939: PUSH
24940: DOUBLE
24941: LD_INT 1
24943: DEC
24944: ST_TO_ADDR
24945: LD_VAR 0 6
24949: PUSH
24950: FOR_TO
24951: IFFALSE 26015
// begin if i > 4 then
24953: LD_VAR 0 8
24957: PUSH
24958: LD_INT 4
24960: GREATER
24961: IFFALSE 24965
// break ;
24963: GO 26015
// case i of 1 :
24965: LD_VAR 0 8
24969: PUSH
24970: LD_INT 1
24972: DOUBLE
24973: EQUAL
24974: IFTRUE 24978
24976: GO 25058
24978: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24979: LD_ADDR_VAR 0 12
24983: PUSH
24984: LD_VAR 0 18
24988: PPUSH
24989: LD_INT 22
24991: PUSH
24992: LD_VAR 0 16
24996: PUSH
24997: EMPTY
24998: LIST
24999: LIST
25000: PUSH
25001: LD_INT 58
25003: PUSH
25004: EMPTY
25005: LIST
25006: PUSH
25007: LD_INT 2
25009: PUSH
25010: LD_INT 30
25012: PUSH
25013: LD_INT 32
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: PUSH
25020: LD_INT 30
25022: PUSH
25023: LD_INT 4
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: LD_INT 30
25032: PUSH
25033: LD_INT 5
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: LIST
25044: LIST
25045: PUSH
25046: EMPTY
25047: LIST
25048: LIST
25049: LIST
25050: PPUSH
25051: CALL_OW 72
25055: ST_TO_ADDR
25056: GO 25280
25058: LD_INT 2
25060: DOUBLE
25061: EQUAL
25062: IFTRUE 25066
25064: GO 25128
25066: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25067: LD_ADDR_VAR 0 12
25071: PUSH
25072: LD_VAR 0 18
25076: PPUSH
25077: LD_INT 22
25079: PUSH
25080: LD_VAR 0 16
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: PUSH
25089: LD_INT 2
25091: PUSH
25092: LD_INT 30
25094: PUSH
25095: LD_INT 0
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 30
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: LIST
25116: PUSH
25117: EMPTY
25118: LIST
25119: LIST
25120: PPUSH
25121: CALL_OW 72
25125: ST_TO_ADDR
25126: GO 25280
25128: LD_INT 3
25130: DOUBLE
25131: EQUAL
25132: IFTRUE 25136
25134: GO 25198
25136: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25137: LD_ADDR_VAR 0 12
25141: PUSH
25142: LD_VAR 0 18
25146: PPUSH
25147: LD_INT 22
25149: PUSH
25150: LD_VAR 0 16
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: LD_INT 2
25161: PUSH
25162: LD_INT 30
25164: PUSH
25165: LD_INT 2
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: PUSH
25172: LD_INT 30
25174: PUSH
25175: LD_INT 3
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: LIST
25186: PUSH
25187: EMPTY
25188: LIST
25189: LIST
25190: PPUSH
25191: CALL_OW 72
25195: ST_TO_ADDR
25196: GO 25280
25198: LD_INT 4
25200: DOUBLE
25201: EQUAL
25202: IFTRUE 25206
25204: GO 25279
25206: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25207: LD_ADDR_VAR 0 12
25211: PUSH
25212: LD_VAR 0 18
25216: PPUSH
25217: LD_INT 22
25219: PUSH
25220: LD_VAR 0 16
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PUSH
25229: LD_INT 2
25231: PUSH
25232: LD_INT 30
25234: PUSH
25235: LD_INT 6
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: LD_INT 30
25244: PUSH
25245: LD_INT 7
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 30
25254: PUSH
25255: LD_INT 8
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: EMPTY
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PPUSH
25272: CALL_OW 72
25276: ST_TO_ADDR
25277: GO 25280
25279: POP
// if i = 1 then
25280: LD_VAR 0 8
25284: PUSH
25285: LD_INT 1
25287: EQUAL
25288: IFFALSE 25399
// begin tmp := [ ] ;
25290: LD_ADDR_VAR 0 19
25294: PUSH
25295: EMPTY
25296: ST_TO_ADDR
// for j in f do
25297: LD_ADDR_VAR 0 9
25301: PUSH
25302: LD_VAR 0 12
25306: PUSH
25307: FOR_IN
25308: IFFALSE 25381
// if GetBType ( j ) = b_bunker then
25310: LD_VAR 0 9
25314: PPUSH
25315: CALL_OW 266
25319: PUSH
25320: LD_INT 32
25322: EQUAL
25323: IFFALSE 25350
// tmp := Insert ( tmp , 1 , j ) else
25325: LD_ADDR_VAR 0 19
25329: PUSH
25330: LD_VAR 0 19
25334: PPUSH
25335: LD_INT 1
25337: PPUSH
25338: LD_VAR 0 9
25342: PPUSH
25343: CALL_OW 2
25347: ST_TO_ADDR
25348: GO 25379
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25350: LD_ADDR_VAR 0 19
25354: PUSH
25355: LD_VAR 0 19
25359: PPUSH
25360: LD_VAR 0 19
25364: PUSH
25365: LD_INT 1
25367: PLUS
25368: PPUSH
25369: LD_VAR 0 9
25373: PPUSH
25374: CALL_OW 2
25378: ST_TO_ADDR
25379: GO 25307
25381: POP
25382: POP
// if tmp then
25383: LD_VAR 0 19
25387: IFFALSE 25399
// f := tmp ;
25389: LD_ADDR_VAR 0 12
25393: PUSH
25394: LD_VAR 0 19
25398: ST_TO_ADDR
// end ; x := personel [ i ] ;
25399: LD_ADDR_VAR 0 13
25403: PUSH
25404: LD_VAR 0 6
25408: PUSH
25409: LD_VAR 0 8
25413: ARRAY
25414: ST_TO_ADDR
// if x = - 1 then
25415: LD_VAR 0 13
25419: PUSH
25420: LD_INT 1
25422: NEG
25423: EQUAL
25424: IFFALSE 25633
// begin for j in f do
25426: LD_ADDR_VAR 0 9
25430: PUSH
25431: LD_VAR 0 12
25435: PUSH
25436: FOR_IN
25437: IFFALSE 25629
// repeat InitHc ;
25439: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25443: LD_VAR 0 9
25447: PPUSH
25448: CALL_OW 266
25452: PUSH
25453: LD_INT 5
25455: EQUAL
25456: IFFALSE 25526
// begin if UnitsInside ( j ) < 3 then
25458: LD_VAR 0 9
25462: PPUSH
25463: CALL_OW 313
25467: PUSH
25468: LD_INT 3
25470: LESS
25471: IFFALSE 25507
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25473: LD_INT 0
25475: PPUSH
25476: LD_INT 5
25478: PUSH
25479: LD_INT 8
25481: PUSH
25482: LD_INT 9
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: PUSH
25490: LD_VAR 0 17
25494: ARRAY
25495: PPUSH
25496: LD_VAR 0 4
25500: PPUSH
25501: CALL_OW 380
25505: GO 25524
// PrepareHuman ( false , i , skill ) ;
25507: LD_INT 0
25509: PPUSH
25510: LD_VAR 0 8
25514: PPUSH
25515: LD_VAR 0 4
25519: PPUSH
25520: CALL_OW 380
// end else
25524: GO 25543
// PrepareHuman ( false , i , skill ) ;
25526: LD_INT 0
25528: PPUSH
25529: LD_VAR 0 8
25533: PPUSH
25534: LD_VAR 0 4
25538: PPUSH
25539: CALL_OW 380
// un := CreateHuman ;
25543: LD_ADDR_VAR 0 14
25547: PUSH
25548: CALL_OW 44
25552: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25553: LD_ADDR_VAR 0 7
25557: PUSH
25558: LD_VAR 0 7
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: LD_VAR 0 14
25570: PPUSH
25571: CALL_OW 2
25575: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25576: LD_VAR 0 14
25580: PPUSH
25581: LD_VAR 0 9
25585: PPUSH
25586: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25590: LD_VAR 0 9
25594: PPUSH
25595: CALL_OW 313
25599: PUSH
25600: LD_INT 6
25602: EQUAL
25603: PUSH
25604: LD_VAR 0 9
25608: PPUSH
25609: CALL_OW 266
25613: PUSH
25614: LD_INT 32
25616: PUSH
25617: LD_INT 31
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: IN
25624: OR
25625: IFFALSE 25439
25627: GO 25436
25629: POP
25630: POP
// end else
25631: GO 26013
// for j = 1 to x do
25633: LD_ADDR_VAR 0 9
25637: PUSH
25638: DOUBLE
25639: LD_INT 1
25641: DEC
25642: ST_TO_ADDR
25643: LD_VAR 0 13
25647: PUSH
25648: FOR_TO
25649: IFFALSE 26011
// begin InitHc ;
25651: CALL_OW 19
// if not f then
25655: LD_VAR 0 12
25659: NOT
25660: IFFALSE 25749
// begin PrepareHuman ( false , i , skill ) ;
25662: LD_INT 0
25664: PPUSH
25665: LD_VAR 0 8
25669: PPUSH
25670: LD_VAR 0 4
25674: PPUSH
25675: CALL_OW 380
// un := CreateHuman ;
25679: LD_ADDR_VAR 0 14
25683: PUSH
25684: CALL_OW 44
25688: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25689: LD_ADDR_VAR 0 7
25693: PUSH
25694: LD_VAR 0 7
25698: PPUSH
25699: LD_INT 1
25701: PPUSH
25702: LD_VAR 0 14
25706: PPUSH
25707: CALL_OW 2
25711: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25712: LD_VAR 0 14
25716: PPUSH
25717: LD_VAR 0 1
25721: PPUSH
25722: CALL_OW 250
25726: PPUSH
25727: LD_VAR 0 1
25731: PPUSH
25732: CALL_OW 251
25736: PPUSH
25737: LD_INT 10
25739: PPUSH
25740: LD_INT 0
25742: PPUSH
25743: CALL_OW 50
// continue ;
25747: GO 25648
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25749: LD_VAR 0 12
25753: PUSH
25754: LD_INT 1
25756: ARRAY
25757: PPUSH
25758: CALL_OW 313
25762: PUSH
25763: LD_VAR 0 12
25767: PUSH
25768: LD_INT 1
25770: ARRAY
25771: PPUSH
25772: CALL_OW 266
25776: PUSH
25777: LD_INT 32
25779: PUSH
25780: LD_INT 31
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: IN
25787: AND
25788: PUSH
25789: LD_VAR 0 12
25793: PUSH
25794: LD_INT 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 313
25802: PUSH
25803: LD_INT 6
25805: EQUAL
25806: OR
25807: IFFALSE 25827
// f := Delete ( f , 1 ) ;
25809: LD_ADDR_VAR 0 12
25813: PUSH
25814: LD_VAR 0 12
25818: PPUSH
25819: LD_INT 1
25821: PPUSH
25822: CALL_OW 3
25826: ST_TO_ADDR
// if not f then
25827: LD_VAR 0 12
25831: NOT
25832: IFFALSE 25850
// begin x := x + 2 ;
25834: LD_ADDR_VAR 0 13
25838: PUSH
25839: LD_VAR 0 13
25843: PUSH
25844: LD_INT 2
25846: PLUS
25847: ST_TO_ADDR
// continue ;
25848: GO 25648
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25850: LD_VAR 0 12
25854: PUSH
25855: LD_INT 1
25857: ARRAY
25858: PPUSH
25859: CALL_OW 266
25863: PUSH
25864: LD_INT 5
25866: EQUAL
25867: IFFALSE 25941
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25869: LD_VAR 0 12
25873: PUSH
25874: LD_INT 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 313
25882: PUSH
25883: LD_INT 3
25885: LESS
25886: IFFALSE 25922
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25888: LD_INT 0
25890: PPUSH
25891: LD_INT 5
25893: PUSH
25894: LD_INT 8
25896: PUSH
25897: LD_INT 9
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: LIST
25904: PUSH
25905: LD_VAR 0 17
25909: ARRAY
25910: PPUSH
25911: LD_VAR 0 4
25915: PPUSH
25916: CALL_OW 380
25920: GO 25939
// PrepareHuman ( false , i , skill ) ;
25922: LD_INT 0
25924: PPUSH
25925: LD_VAR 0 8
25929: PPUSH
25930: LD_VAR 0 4
25934: PPUSH
25935: CALL_OW 380
// end else
25939: GO 25958
// PrepareHuman ( false , i , skill ) ;
25941: LD_INT 0
25943: PPUSH
25944: LD_VAR 0 8
25948: PPUSH
25949: LD_VAR 0 4
25953: PPUSH
25954: CALL_OW 380
// un := CreateHuman ;
25958: LD_ADDR_VAR 0 14
25962: PUSH
25963: CALL_OW 44
25967: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25968: LD_ADDR_VAR 0 7
25972: PUSH
25973: LD_VAR 0 7
25977: PPUSH
25978: LD_INT 1
25980: PPUSH
25981: LD_VAR 0 14
25985: PPUSH
25986: CALL_OW 2
25990: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25991: LD_VAR 0 14
25995: PPUSH
25996: LD_VAR 0 12
26000: PUSH
26001: LD_INT 1
26003: ARRAY
26004: PPUSH
26005: CALL_OW 52
// end ;
26009: GO 25648
26011: POP
26012: POP
// end ;
26013: GO 24950
26015: POP
26016: POP
// result := result ^ buildings ;
26017: LD_ADDR_VAR 0 7
26021: PUSH
26022: LD_VAR 0 7
26026: PUSH
26027: LD_VAR 0 18
26031: ADD
26032: ST_TO_ADDR
// end else
26033: GO 26176
// begin for i = 1 to personel do
26035: LD_ADDR_VAR 0 8
26039: PUSH
26040: DOUBLE
26041: LD_INT 1
26043: DEC
26044: ST_TO_ADDR
26045: LD_VAR 0 6
26049: PUSH
26050: FOR_TO
26051: IFFALSE 26174
// begin if i > 4 then
26053: LD_VAR 0 8
26057: PUSH
26058: LD_INT 4
26060: GREATER
26061: IFFALSE 26065
// break ;
26063: GO 26174
// x := personel [ i ] ;
26065: LD_ADDR_VAR 0 13
26069: PUSH
26070: LD_VAR 0 6
26074: PUSH
26075: LD_VAR 0 8
26079: ARRAY
26080: ST_TO_ADDR
// if x = - 1 then
26081: LD_VAR 0 13
26085: PUSH
26086: LD_INT 1
26088: NEG
26089: EQUAL
26090: IFFALSE 26094
// continue ;
26092: GO 26050
// PrepareHuman ( false , i , skill ) ;
26094: LD_INT 0
26096: PPUSH
26097: LD_VAR 0 8
26101: PPUSH
26102: LD_VAR 0 4
26106: PPUSH
26107: CALL_OW 380
// un := CreateHuman ;
26111: LD_ADDR_VAR 0 14
26115: PUSH
26116: CALL_OW 44
26120: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26121: LD_VAR 0 14
26125: PPUSH
26126: LD_VAR 0 1
26130: PPUSH
26131: CALL_OW 250
26135: PPUSH
26136: LD_VAR 0 1
26140: PPUSH
26141: CALL_OW 251
26145: PPUSH
26146: LD_INT 10
26148: PPUSH
26149: LD_INT 0
26151: PPUSH
26152: CALL_OW 50
// result := result ^ un ;
26156: LD_ADDR_VAR 0 7
26160: PUSH
26161: LD_VAR 0 7
26165: PUSH
26166: LD_VAR 0 14
26170: ADD
26171: ST_TO_ADDR
// end ;
26172: GO 26050
26174: POP
26175: POP
// end ; end ;
26176: LD_VAR 0 7
26180: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26181: LD_INT 0
26183: PPUSH
26184: PPUSH
26185: PPUSH
26186: PPUSH
26187: PPUSH
26188: PPUSH
26189: PPUSH
26190: PPUSH
26191: PPUSH
26192: PPUSH
26193: PPUSH
26194: PPUSH
26195: PPUSH
26196: PPUSH
26197: PPUSH
26198: PPUSH
// result := false ;
26199: LD_ADDR_VAR 0 3
26203: PUSH
26204: LD_INT 0
26206: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26207: LD_VAR 0 1
26211: NOT
26212: PUSH
26213: LD_VAR 0 1
26217: PPUSH
26218: CALL_OW 266
26222: PUSH
26223: LD_INT 32
26225: PUSH
26226: LD_INT 33
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: IN
26233: NOT
26234: OR
26235: IFFALSE 26239
// exit ;
26237: GO 27375
// nat := GetNation ( tower ) ;
26239: LD_ADDR_VAR 0 12
26243: PUSH
26244: LD_VAR 0 1
26248: PPUSH
26249: CALL_OW 248
26253: ST_TO_ADDR
// side := GetSide ( tower ) ;
26254: LD_ADDR_VAR 0 16
26258: PUSH
26259: LD_VAR 0 1
26263: PPUSH
26264: CALL_OW 255
26268: ST_TO_ADDR
// x := GetX ( tower ) ;
26269: LD_ADDR_VAR 0 10
26273: PUSH
26274: LD_VAR 0 1
26278: PPUSH
26279: CALL_OW 250
26283: ST_TO_ADDR
// y := GetY ( tower ) ;
26284: LD_ADDR_VAR 0 11
26288: PUSH
26289: LD_VAR 0 1
26293: PPUSH
26294: CALL_OW 251
26298: ST_TO_ADDR
// if not x or not y then
26299: LD_VAR 0 10
26303: NOT
26304: PUSH
26305: LD_VAR 0 11
26309: NOT
26310: OR
26311: IFFALSE 26315
// exit ;
26313: GO 27375
// weapon := 0 ;
26315: LD_ADDR_VAR 0 18
26319: PUSH
26320: LD_INT 0
26322: ST_TO_ADDR
// fac_list := [ ] ;
26323: LD_ADDR_VAR 0 17
26327: PUSH
26328: EMPTY
26329: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26330: LD_ADDR_VAR 0 6
26334: PUSH
26335: LD_VAR 0 1
26339: PPUSH
26340: CALL_OW 274
26344: PPUSH
26345: LD_VAR 0 2
26349: PPUSH
26350: CALL 23953 0 2
26354: PPUSH
26355: LD_INT 30
26357: PUSH
26358: LD_INT 3
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: PPUSH
26365: CALL_OW 72
26369: ST_TO_ADDR
// if not factories then
26370: LD_VAR 0 6
26374: NOT
26375: IFFALSE 26379
// exit ;
26377: GO 27375
// for i in factories do
26379: LD_ADDR_VAR 0 8
26383: PUSH
26384: LD_VAR 0 6
26388: PUSH
26389: FOR_IN
26390: IFFALSE 26415
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26392: LD_ADDR_VAR 0 17
26396: PUSH
26397: LD_VAR 0 17
26401: PUSH
26402: LD_VAR 0 8
26406: PPUSH
26407: CALL_OW 478
26411: UNION
26412: ST_TO_ADDR
26413: GO 26389
26415: POP
26416: POP
// if not fac_list then
26417: LD_VAR 0 17
26421: NOT
26422: IFFALSE 26426
// exit ;
26424: GO 27375
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26426: LD_ADDR_VAR 0 5
26430: PUSH
26431: LD_INT 4
26433: PUSH
26434: LD_INT 5
26436: PUSH
26437: LD_INT 9
26439: PUSH
26440: LD_INT 10
26442: PUSH
26443: LD_INT 6
26445: PUSH
26446: LD_INT 7
26448: PUSH
26449: LD_INT 11
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: LIST
26456: LIST
26457: LIST
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 27
26463: PUSH
26464: LD_INT 28
26466: PUSH
26467: LD_INT 26
26469: PUSH
26470: LD_INT 30
26472: PUSH
26473: EMPTY
26474: LIST
26475: LIST
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 43
26481: PUSH
26482: LD_INT 44
26484: PUSH
26485: LD_INT 46
26487: PUSH
26488: LD_INT 45
26490: PUSH
26491: LD_INT 47
26493: PUSH
26494: LD_INT 49
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: LIST
26501: LIST
26502: LIST
26503: LIST
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: LIST
26509: PUSH
26510: LD_VAR 0 12
26514: ARRAY
26515: ST_TO_ADDR
// for i in list do
26516: LD_ADDR_VAR 0 8
26520: PUSH
26521: LD_VAR 0 5
26525: PUSH
26526: FOR_IN
26527: IFFALSE 26560
// if not i in fac_list then
26529: LD_VAR 0 8
26533: PUSH
26534: LD_VAR 0 17
26538: IN
26539: NOT
26540: IFFALSE 26558
// list := list diff i ;
26542: LD_ADDR_VAR 0 5
26546: PUSH
26547: LD_VAR 0 5
26551: PUSH
26552: LD_VAR 0 8
26556: DIFF
26557: ST_TO_ADDR
26558: GO 26526
26560: POP
26561: POP
// if not list then
26562: LD_VAR 0 5
26566: NOT
26567: IFFALSE 26571
// exit ;
26569: GO 27375
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26571: LD_VAR 0 12
26575: PUSH
26576: LD_INT 3
26578: EQUAL
26579: PUSH
26580: LD_INT 49
26582: PUSH
26583: LD_VAR 0 5
26587: IN
26588: AND
26589: PUSH
26590: LD_INT 31
26592: PPUSH
26593: LD_VAR 0 16
26597: PPUSH
26598: CALL_OW 321
26602: PUSH
26603: LD_INT 2
26605: EQUAL
26606: AND
26607: IFFALSE 26667
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26609: LD_INT 22
26611: PUSH
26612: LD_VAR 0 16
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 35
26623: PUSH
26624: LD_INT 49
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: LD_INT 91
26633: PUSH
26634: LD_VAR 0 1
26638: PUSH
26639: LD_INT 10
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: LIST
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: LIST
26651: PPUSH
26652: CALL_OW 69
26656: NOT
26657: IFFALSE 26667
// weapon := ru_time_lapser ;
26659: LD_ADDR_VAR 0 18
26663: PUSH
26664: LD_INT 49
26666: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26667: LD_VAR 0 12
26671: PUSH
26672: LD_INT 1
26674: PUSH
26675: LD_INT 2
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: IN
26682: PUSH
26683: LD_INT 11
26685: PUSH
26686: LD_VAR 0 5
26690: IN
26691: PUSH
26692: LD_INT 30
26694: PUSH
26695: LD_VAR 0 5
26699: IN
26700: OR
26701: AND
26702: PUSH
26703: LD_INT 6
26705: PPUSH
26706: LD_VAR 0 16
26710: PPUSH
26711: CALL_OW 321
26715: PUSH
26716: LD_INT 2
26718: EQUAL
26719: AND
26720: IFFALSE 26885
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26722: LD_INT 22
26724: PUSH
26725: LD_VAR 0 16
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: LD_INT 2
26736: PUSH
26737: LD_INT 35
26739: PUSH
26740: LD_INT 11
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 35
26749: PUSH
26750: LD_INT 30
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 91
26764: PUSH
26765: LD_VAR 0 1
26769: PUSH
26770: LD_INT 18
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: LIST
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PPUSH
26783: CALL_OW 69
26787: NOT
26788: PUSH
26789: LD_INT 22
26791: PUSH
26792: LD_VAR 0 16
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 2
26803: PUSH
26804: LD_INT 30
26806: PUSH
26807: LD_INT 32
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: LD_INT 30
26816: PUSH
26817: LD_INT 33
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 91
26831: PUSH
26832: LD_VAR 0 1
26836: PUSH
26837: LD_INT 12
26839: PUSH
26840: EMPTY
26841: LIST
26842: LIST
26843: LIST
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: LIST
26849: PUSH
26850: EMPTY
26851: LIST
26852: PPUSH
26853: CALL_OW 69
26857: PUSH
26858: LD_INT 2
26860: GREATER
26861: AND
26862: IFFALSE 26885
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26864: LD_ADDR_VAR 0 18
26868: PUSH
26869: LD_INT 11
26871: PUSH
26872: LD_INT 30
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_VAR 0 12
26883: ARRAY
26884: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26885: LD_VAR 0 18
26889: NOT
26890: PUSH
26891: LD_INT 40
26893: PPUSH
26894: LD_VAR 0 16
26898: PPUSH
26899: CALL_OW 321
26903: PUSH
26904: LD_INT 2
26906: EQUAL
26907: AND
26908: PUSH
26909: LD_INT 7
26911: PUSH
26912: LD_VAR 0 5
26916: IN
26917: PUSH
26918: LD_INT 28
26920: PUSH
26921: LD_VAR 0 5
26925: IN
26926: OR
26927: PUSH
26928: LD_INT 45
26930: PUSH
26931: LD_VAR 0 5
26935: IN
26936: OR
26937: AND
26938: IFFALSE 27192
// begin hex := GetHexInfo ( x , y ) ;
26940: LD_ADDR_VAR 0 4
26944: PUSH
26945: LD_VAR 0 10
26949: PPUSH
26950: LD_VAR 0 11
26954: PPUSH
26955: CALL_OW 546
26959: ST_TO_ADDR
// if hex [ 1 ] then
26960: LD_VAR 0 4
26964: PUSH
26965: LD_INT 1
26967: ARRAY
26968: IFFALSE 26972
// exit ;
26970: GO 27375
// height := hex [ 2 ] ;
26972: LD_ADDR_VAR 0 15
26976: PUSH
26977: LD_VAR 0 4
26981: PUSH
26982: LD_INT 2
26984: ARRAY
26985: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26986: LD_ADDR_VAR 0 14
26990: PUSH
26991: LD_INT 0
26993: PUSH
26994: LD_INT 2
26996: PUSH
26997: LD_INT 3
26999: PUSH
27000: LD_INT 5
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: LIST
27007: LIST
27008: ST_TO_ADDR
// for i in tmp do
27009: LD_ADDR_VAR 0 8
27013: PUSH
27014: LD_VAR 0 14
27018: PUSH
27019: FOR_IN
27020: IFFALSE 27190
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27022: LD_ADDR_VAR 0 9
27026: PUSH
27027: LD_VAR 0 10
27031: PPUSH
27032: LD_VAR 0 8
27036: PPUSH
27037: LD_INT 5
27039: PPUSH
27040: CALL_OW 272
27044: PUSH
27045: LD_VAR 0 11
27049: PPUSH
27050: LD_VAR 0 8
27054: PPUSH
27055: LD_INT 5
27057: PPUSH
27058: CALL_OW 273
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27067: LD_VAR 0 9
27071: PUSH
27072: LD_INT 1
27074: ARRAY
27075: PPUSH
27076: LD_VAR 0 9
27080: PUSH
27081: LD_INT 2
27083: ARRAY
27084: PPUSH
27085: CALL_OW 488
27089: IFFALSE 27188
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27091: LD_ADDR_VAR 0 4
27095: PUSH
27096: LD_VAR 0 9
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: PPUSH
27105: LD_VAR 0 9
27109: PUSH
27110: LD_INT 2
27112: ARRAY
27113: PPUSH
27114: CALL_OW 546
27118: ST_TO_ADDR
// if hex [ 1 ] then
27119: LD_VAR 0 4
27123: PUSH
27124: LD_INT 1
27126: ARRAY
27127: IFFALSE 27131
// continue ;
27129: GO 27019
// h := hex [ 2 ] ;
27131: LD_ADDR_VAR 0 13
27135: PUSH
27136: LD_VAR 0 4
27140: PUSH
27141: LD_INT 2
27143: ARRAY
27144: ST_TO_ADDR
// if h + 7 < height then
27145: LD_VAR 0 13
27149: PUSH
27150: LD_INT 7
27152: PLUS
27153: PUSH
27154: LD_VAR 0 15
27158: LESS
27159: IFFALSE 27188
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27161: LD_ADDR_VAR 0 18
27165: PUSH
27166: LD_INT 7
27168: PUSH
27169: LD_INT 28
27171: PUSH
27172: LD_INT 45
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: PUSH
27180: LD_VAR 0 12
27184: ARRAY
27185: ST_TO_ADDR
// break ;
27186: GO 27190
// end ; end ; end ;
27188: GO 27019
27190: POP
27191: POP
// end ; if not weapon then
27192: LD_VAR 0 18
27196: NOT
27197: IFFALSE 27257
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27199: LD_ADDR_VAR 0 5
27203: PUSH
27204: LD_VAR 0 5
27208: PUSH
27209: LD_INT 11
27211: PUSH
27212: LD_INT 30
27214: PUSH
27215: LD_INT 49
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: LIST
27222: DIFF
27223: ST_TO_ADDR
// if not list then
27224: LD_VAR 0 5
27228: NOT
27229: IFFALSE 27233
// exit ;
27231: GO 27375
// weapon := list [ rand ( 1 , list ) ] ;
27233: LD_ADDR_VAR 0 18
27237: PUSH
27238: LD_VAR 0 5
27242: PUSH
27243: LD_INT 1
27245: PPUSH
27246: LD_VAR 0 5
27250: PPUSH
27251: CALL_OW 12
27255: ARRAY
27256: ST_TO_ADDR
// end ; if weapon then
27257: LD_VAR 0 18
27261: IFFALSE 27375
// begin tmp := CostOfWeapon ( weapon ) ;
27263: LD_ADDR_VAR 0 14
27267: PUSH
27268: LD_VAR 0 18
27272: PPUSH
27273: CALL_OW 451
27277: ST_TO_ADDR
// j := GetBase ( tower ) ;
27278: LD_ADDR_VAR 0 9
27282: PUSH
27283: LD_VAR 0 1
27287: PPUSH
27288: CALL_OW 274
27292: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27293: LD_VAR 0 9
27297: PPUSH
27298: LD_INT 1
27300: PPUSH
27301: CALL_OW 275
27305: PUSH
27306: LD_VAR 0 14
27310: PUSH
27311: LD_INT 1
27313: ARRAY
27314: GREATEREQUAL
27315: PUSH
27316: LD_VAR 0 9
27320: PPUSH
27321: LD_INT 2
27323: PPUSH
27324: CALL_OW 275
27328: PUSH
27329: LD_VAR 0 14
27333: PUSH
27334: LD_INT 2
27336: ARRAY
27337: GREATEREQUAL
27338: AND
27339: PUSH
27340: LD_VAR 0 9
27344: PPUSH
27345: LD_INT 3
27347: PPUSH
27348: CALL_OW 275
27352: PUSH
27353: LD_VAR 0 14
27357: PUSH
27358: LD_INT 3
27360: ARRAY
27361: GREATEREQUAL
27362: AND
27363: IFFALSE 27375
// result := weapon ;
27365: LD_ADDR_VAR 0 3
27369: PUSH
27370: LD_VAR 0 18
27374: ST_TO_ADDR
// end ; end ;
27375: LD_VAR 0 3
27379: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27380: LD_INT 0
27382: PPUSH
27383: PPUSH
// result := true ;
27384: LD_ADDR_VAR 0 3
27388: PUSH
27389: LD_INT 1
27391: ST_TO_ADDR
// if array1 = array2 then
27392: LD_VAR 0 1
27396: PUSH
27397: LD_VAR 0 2
27401: EQUAL
27402: IFFALSE 27462
// begin for i = 1 to array1 do
27404: LD_ADDR_VAR 0 4
27408: PUSH
27409: DOUBLE
27410: LD_INT 1
27412: DEC
27413: ST_TO_ADDR
27414: LD_VAR 0 1
27418: PUSH
27419: FOR_TO
27420: IFFALSE 27458
// if array1 [ i ] <> array2 [ i ] then
27422: LD_VAR 0 1
27426: PUSH
27427: LD_VAR 0 4
27431: ARRAY
27432: PUSH
27433: LD_VAR 0 2
27437: PUSH
27438: LD_VAR 0 4
27442: ARRAY
27443: NONEQUAL
27444: IFFALSE 27456
// begin result := false ;
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_INT 0
27453: ST_TO_ADDR
// break ;
27454: GO 27458
// end ;
27456: GO 27419
27458: POP
27459: POP
// end else
27460: GO 27470
// result := false ;
27462: LD_ADDR_VAR 0 3
27466: PUSH
27467: LD_INT 0
27469: ST_TO_ADDR
// end ;
27470: LD_VAR 0 3
27474: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27475: LD_INT 0
27477: PPUSH
27478: PPUSH
27479: PPUSH
// pom := GetBase ( fac ) ;
27480: LD_ADDR_VAR 0 5
27484: PUSH
27485: LD_VAR 0 1
27489: PPUSH
27490: CALL_OW 274
27494: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27495: LD_ADDR_VAR 0 4
27499: PUSH
27500: LD_VAR 0 2
27504: PUSH
27505: LD_INT 1
27507: ARRAY
27508: PPUSH
27509: LD_VAR 0 2
27513: PUSH
27514: LD_INT 2
27516: ARRAY
27517: PPUSH
27518: LD_VAR 0 2
27522: PUSH
27523: LD_INT 3
27525: ARRAY
27526: PPUSH
27527: LD_VAR 0 2
27531: PUSH
27532: LD_INT 4
27534: ARRAY
27535: PPUSH
27536: CALL_OW 449
27540: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27541: LD_ADDR_VAR 0 3
27545: PUSH
27546: LD_VAR 0 5
27550: PPUSH
27551: LD_INT 1
27553: PPUSH
27554: CALL_OW 275
27558: PUSH
27559: LD_VAR 0 4
27563: PUSH
27564: LD_INT 1
27566: ARRAY
27567: GREATEREQUAL
27568: PUSH
27569: LD_VAR 0 5
27573: PPUSH
27574: LD_INT 2
27576: PPUSH
27577: CALL_OW 275
27581: PUSH
27582: LD_VAR 0 4
27586: PUSH
27587: LD_INT 2
27589: ARRAY
27590: GREATEREQUAL
27591: AND
27592: PUSH
27593: LD_VAR 0 5
27597: PPUSH
27598: LD_INT 3
27600: PPUSH
27601: CALL_OW 275
27605: PUSH
27606: LD_VAR 0 4
27610: PUSH
27611: LD_INT 3
27613: ARRAY
27614: GREATEREQUAL
27615: AND
27616: ST_TO_ADDR
// end ;
27617: LD_VAR 0 3
27621: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27622: LD_INT 0
27624: PPUSH
27625: PPUSH
27626: PPUSH
27627: PPUSH
// pom := GetBase ( building ) ;
27628: LD_ADDR_VAR 0 3
27632: PUSH
27633: LD_VAR 0 1
27637: PPUSH
27638: CALL_OW 274
27642: ST_TO_ADDR
// if not pom then
27643: LD_VAR 0 3
27647: NOT
27648: IFFALSE 27652
// exit ;
27650: GO 27822
// btype := GetBType ( building ) ;
27652: LD_ADDR_VAR 0 5
27656: PUSH
27657: LD_VAR 0 1
27661: PPUSH
27662: CALL_OW 266
27666: ST_TO_ADDR
// if btype = b_armoury then
27667: LD_VAR 0 5
27671: PUSH
27672: LD_INT 4
27674: EQUAL
27675: IFFALSE 27685
// btype := b_barracks ;
27677: LD_ADDR_VAR 0 5
27681: PUSH
27682: LD_INT 5
27684: ST_TO_ADDR
// if btype = b_depot then
27685: LD_VAR 0 5
27689: PUSH
27690: LD_INT 0
27692: EQUAL
27693: IFFALSE 27703
// btype := b_warehouse ;
27695: LD_ADDR_VAR 0 5
27699: PUSH
27700: LD_INT 1
27702: ST_TO_ADDR
// if btype = b_workshop then
27703: LD_VAR 0 5
27707: PUSH
27708: LD_INT 2
27710: EQUAL
27711: IFFALSE 27721
// btype := b_factory ;
27713: LD_ADDR_VAR 0 5
27717: PUSH
27718: LD_INT 3
27720: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27721: LD_ADDR_VAR 0 4
27725: PUSH
27726: LD_VAR 0 5
27730: PPUSH
27731: LD_VAR 0 1
27735: PPUSH
27736: CALL_OW 248
27740: PPUSH
27741: CALL_OW 450
27745: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27746: LD_ADDR_VAR 0 2
27750: PUSH
27751: LD_VAR 0 3
27755: PPUSH
27756: LD_INT 1
27758: PPUSH
27759: CALL_OW 275
27763: PUSH
27764: LD_VAR 0 4
27768: PUSH
27769: LD_INT 1
27771: ARRAY
27772: GREATEREQUAL
27773: PUSH
27774: LD_VAR 0 3
27778: PPUSH
27779: LD_INT 2
27781: PPUSH
27782: CALL_OW 275
27786: PUSH
27787: LD_VAR 0 4
27791: PUSH
27792: LD_INT 2
27794: ARRAY
27795: GREATEREQUAL
27796: AND
27797: PUSH
27798: LD_VAR 0 3
27802: PPUSH
27803: LD_INT 3
27805: PPUSH
27806: CALL_OW 275
27810: PUSH
27811: LD_VAR 0 4
27815: PUSH
27816: LD_INT 3
27818: ARRAY
27819: GREATEREQUAL
27820: AND
27821: ST_TO_ADDR
// end ;
27822: LD_VAR 0 2
27826: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27827: LD_INT 0
27829: PPUSH
27830: PPUSH
27831: PPUSH
// pom := GetBase ( building ) ;
27832: LD_ADDR_VAR 0 4
27836: PUSH
27837: LD_VAR 0 1
27841: PPUSH
27842: CALL_OW 274
27846: ST_TO_ADDR
// if not pom then
27847: LD_VAR 0 4
27851: NOT
27852: IFFALSE 27856
// exit ;
27854: GO 27957
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27856: LD_ADDR_VAR 0 5
27860: PUSH
27861: LD_VAR 0 2
27865: PPUSH
27866: LD_VAR 0 1
27870: PPUSH
27871: CALL_OW 248
27875: PPUSH
27876: CALL_OW 450
27880: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27881: LD_ADDR_VAR 0 3
27885: PUSH
27886: LD_VAR 0 4
27890: PPUSH
27891: LD_INT 1
27893: PPUSH
27894: CALL_OW 275
27898: PUSH
27899: LD_VAR 0 5
27903: PUSH
27904: LD_INT 1
27906: ARRAY
27907: GREATEREQUAL
27908: PUSH
27909: LD_VAR 0 4
27913: PPUSH
27914: LD_INT 2
27916: PPUSH
27917: CALL_OW 275
27921: PUSH
27922: LD_VAR 0 5
27926: PUSH
27927: LD_INT 2
27929: ARRAY
27930: GREATEREQUAL
27931: AND
27932: PUSH
27933: LD_VAR 0 4
27937: PPUSH
27938: LD_INT 3
27940: PPUSH
27941: CALL_OW 275
27945: PUSH
27946: LD_VAR 0 5
27950: PUSH
27951: LD_INT 3
27953: ARRAY
27954: GREATEREQUAL
27955: AND
27956: ST_TO_ADDR
// end ;
27957: LD_VAR 0 3
27961: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27962: LD_INT 0
27964: PPUSH
27965: PPUSH
27966: PPUSH
27967: PPUSH
27968: PPUSH
27969: PPUSH
27970: PPUSH
27971: PPUSH
27972: PPUSH
27973: PPUSH
// result := false ;
27974: LD_ADDR_VAR 0 6
27978: PUSH
27979: LD_INT 0
27981: ST_TO_ADDR
// if not base or not btype or not x or not y then
27982: LD_VAR 0 1
27986: NOT
27987: PUSH
27988: LD_VAR 0 2
27992: NOT
27993: OR
27994: PUSH
27995: LD_VAR 0 3
27999: NOT
28000: OR
28001: PUSH
28002: LD_VAR 0 4
28006: NOT
28007: OR
28008: IFFALSE 28012
// exit ;
28010: GO 28621
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28012: LD_ADDR_VAR 0 12
28016: PUSH
28017: LD_VAR 0 2
28021: PPUSH
28022: LD_VAR 0 3
28026: PPUSH
28027: LD_VAR 0 4
28031: PPUSH
28032: LD_VAR 0 5
28036: PPUSH
28037: LD_VAR 0 1
28041: PUSH
28042: LD_INT 1
28044: ARRAY
28045: PPUSH
28046: CALL_OW 248
28050: PPUSH
28051: LD_INT 0
28053: PPUSH
28054: CALL 29458 0 6
28058: ST_TO_ADDR
// if not hexes then
28059: LD_VAR 0 12
28063: NOT
28064: IFFALSE 28068
// exit ;
28066: GO 28621
// for i = 1 to hexes do
28068: LD_ADDR_VAR 0 7
28072: PUSH
28073: DOUBLE
28074: LD_INT 1
28076: DEC
28077: ST_TO_ADDR
28078: LD_VAR 0 12
28082: PUSH
28083: FOR_TO
28084: IFFALSE 28619
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28086: LD_ADDR_VAR 0 11
28090: PUSH
28091: LD_VAR 0 12
28095: PUSH
28096: LD_VAR 0 7
28100: ARRAY
28101: PUSH
28102: LD_INT 1
28104: ARRAY
28105: PPUSH
28106: LD_VAR 0 12
28110: PUSH
28111: LD_VAR 0 7
28115: ARRAY
28116: PUSH
28117: LD_INT 2
28119: ARRAY
28120: PPUSH
28121: CALL_OW 428
28125: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28126: LD_VAR 0 12
28130: PUSH
28131: LD_VAR 0 7
28135: ARRAY
28136: PUSH
28137: LD_INT 1
28139: ARRAY
28140: PPUSH
28141: LD_VAR 0 12
28145: PUSH
28146: LD_VAR 0 7
28150: ARRAY
28151: PUSH
28152: LD_INT 2
28154: ARRAY
28155: PPUSH
28156: CALL_OW 351
28160: PUSH
28161: LD_VAR 0 12
28165: PUSH
28166: LD_VAR 0 7
28170: ARRAY
28171: PUSH
28172: LD_INT 1
28174: ARRAY
28175: PPUSH
28176: LD_VAR 0 12
28180: PUSH
28181: LD_VAR 0 7
28185: ARRAY
28186: PUSH
28187: LD_INT 2
28189: ARRAY
28190: PPUSH
28191: CALL_OW 488
28195: NOT
28196: OR
28197: PUSH
28198: LD_VAR 0 11
28202: PPUSH
28203: CALL_OW 247
28207: PUSH
28208: LD_INT 3
28210: EQUAL
28211: OR
28212: IFFALSE 28218
// exit ;
28214: POP
28215: POP
28216: GO 28621
// if not tmp or not tmp in base then
28218: LD_VAR 0 11
28222: NOT
28223: PUSH
28224: LD_VAR 0 11
28228: PUSH
28229: LD_VAR 0 1
28233: IN
28234: NOT
28235: OR
28236: IFFALSE 28240
// continue ;
28238: GO 28083
// result := true ;
28240: LD_ADDR_VAR 0 6
28244: PUSH
28245: LD_INT 1
28247: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28248: LD_ADDR_VAR 0 15
28252: PUSH
28253: LD_VAR 0 1
28257: PPUSH
28258: LD_INT 22
28260: PUSH
28261: LD_VAR 0 11
28265: PPUSH
28266: CALL_OW 255
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: PUSH
28278: LD_INT 30
28280: PUSH
28281: LD_INT 0
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 30
28290: PUSH
28291: LD_INT 1
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: LIST
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PPUSH
28307: CALL_OW 72
28311: ST_TO_ADDR
// if dep then
28312: LD_VAR 0 15
28316: IFFALSE 28452
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28318: LD_ADDR_VAR 0 14
28322: PUSH
28323: LD_VAR 0 15
28327: PUSH
28328: LD_INT 1
28330: ARRAY
28331: PPUSH
28332: CALL_OW 250
28336: PPUSH
28337: LD_VAR 0 15
28341: PUSH
28342: LD_INT 1
28344: ARRAY
28345: PPUSH
28346: CALL_OW 254
28350: PPUSH
28351: LD_INT 5
28353: PPUSH
28354: CALL_OW 272
28358: PUSH
28359: LD_VAR 0 15
28363: PUSH
28364: LD_INT 1
28366: ARRAY
28367: PPUSH
28368: CALL_OW 251
28372: PPUSH
28373: LD_VAR 0 15
28377: PUSH
28378: LD_INT 1
28380: ARRAY
28381: PPUSH
28382: CALL_OW 254
28386: PPUSH
28387: LD_INT 5
28389: PPUSH
28390: CALL_OW 273
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28399: LD_VAR 0 14
28403: PUSH
28404: LD_INT 1
28406: ARRAY
28407: PPUSH
28408: LD_VAR 0 14
28412: PUSH
28413: LD_INT 2
28415: ARRAY
28416: PPUSH
28417: CALL_OW 488
28421: IFFALSE 28452
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28423: LD_VAR 0 11
28427: PPUSH
28428: LD_VAR 0 14
28432: PUSH
28433: LD_INT 1
28435: ARRAY
28436: PPUSH
28437: LD_VAR 0 14
28441: PUSH
28442: LD_INT 2
28444: ARRAY
28445: PPUSH
28446: CALL_OW 111
// continue ;
28450: GO 28083
// end ; end ; r := GetDir ( tmp ) ;
28452: LD_ADDR_VAR 0 13
28456: PUSH
28457: LD_VAR 0 11
28461: PPUSH
28462: CALL_OW 254
28466: ST_TO_ADDR
// if r = 5 then
28467: LD_VAR 0 13
28471: PUSH
28472: LD_INT 5
28474: EQUAL
28475: IFFALSE 28485
// r := 0 ;
28477: LD_ADDR_VAR 0 13
28481: PUSH
28482: LD_INT 0
28484: ST_TO_ADDR
// for j = r to 5 do
28485: LD_ADDR_VAR 0 8
28489: PUSH
28490: DOUBLE
28491: LD_VAR 0 13
28495: DEC
28496: ST_TO_ADDR
28497: LD_INT 5
28499: PUSH
28500: FOR_TO
28501: IFFALSE 28615
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28503: LD_ADDR_VAR 0 9
28507: PUSH
28508: LD_VAR 0 11
28512: PPUSH
28513: CALL_OW 250
28517: PPUSH
28518: LD_VAR 0 8
28522: PPUSH
28523: LD_INT 2
28525: PPUSH
28526: CALL_OW 272
28530: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28531: LD_ADDR_VAR 0 10
28535: PUSH
28536: LD_VAR 0 11
28540: PPUSH
28541: CALL_OW 251
28545: PPUSH
28546: LD_VAR 0 8
28550: PPUSH
28551: LD_INT 2
28553: PPUSH
28554: CALL_OW 273
28558: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28559: LD_VAR 0 9
28563: PPUSH
28564: LD_VAR 0 10
28568: PPUSH
28569: CALL_OW 488
28573: PUSH
28574: LD_VAR 0 9
28578: PPUSH
28579: LD_VAR 0 10
28583: PPUSH
28584: CALL_OW 428
28588: NOT
28589: AND
28590: IFFALSE 28613
// begin ComMoveXY ( tmp , _x , _y ) ;
28592: LD_VAR 0 11
28596: PPUSH
28597: LD_VAR 0 9
28601: PPUSH
28602: LD_VAR 0 10
28606: PPUSH
28607: CALL_OW 111
// break ;
28611: GO 28615
// end ; end ;
28613: GO 28500
28615: POP
28616: POP
// end ;
28617: GO 28083
28619: POP
28620: POP
// end ;
28621: LD_VAR 0 6
28625: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28626: LD_INT 0
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
// result := false ;
28638: LD_ADDR_VAR 0 6
28642: PUSH
28643: LD_INT 0
28645: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28646: LD_VAR 0 1
28650: NOT
28651: PUSH
28652: LD_VAR 0 1
28656: PPUSH
28657: CALL_OW 266
28661: PUSH
28662: LD_INT 0
28664: PUSH
28665: LD_INT 1
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: IN
28672: NOT
28673: OR
28674: PUSH
28675: LD_VAR 0 2
28679: NOT
28680: OR
28681: PUSH
28682: LD_VAR 0 5
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: LD_INT 1
28692: PUSH
28693: LD_INT 2
28695: PUSH
28696: LD_INT 3
28698: PUSH
28699: LD_INT 4
28701: PUSH
28702: LD_INT 5
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: IN
28713: NOT
28714: OR
28715: PUSH
28716: LD_VAR 0 3
28720: PPUSH
28721: LD_VAR 0 4
28725: PPUSH
28726: CALL_OW 488
28730: NOT
28731: OR
28732: IFFALSE 28736
// exit ;
28734: GO 29453
// pom := GetBase ( depot ) ;
28736: LD_ADDR_VAR 0 10
28740: PUSH
28741: LD_VAR 0 1
28745: PPUSH
28746: CALL_OW 274
28750: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28751: LD_ADDR_VAR 0 11
28755: PUSH
28756: LD_VAR 0 2
28760: PPUSH
28761: LD_VAR 0 1
28765: PPUSH
28766: CALL_OW 248
28770: PPUSH
28771: CALL_OW 450
28775: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28776: LD_VAR 0 10
28780: PPUSH
28781: LD_INT 1
28783: PPUSH
28784: CALL_OW 275
28788: PUSH
28789: LD_VAR 0 11
28793: PUSH
28794: LD_INT 1
28796: ARRAY
28797: GREATEREQUAL
28798: PUSH
28799: LD_VAR 0 10
28803: PPUSH
28804: LD_INT 2
28806: PPUSH
28807: CALL_OW 275
28811: PUSH
28812: LD_VAR 0 11
28816: PUSH
28817: LD_INT 2
28819: ARRAY
28820: GREATEREQUAL
28821: AND
28822: PUSH
28823: LD_VAR 0 10
28827: PPUSH
28828: LD_INT 3
28830: PPUSH
28831: CALL_OW 275
28835: PUSH
28836: LD_VAR 0 11
28840: PUSH
28841: LD_INT 3
28843: ARRAY
28844: GREATEREQUAL
28845: AND
28846: NOT
28847: IFFALSE 28851
// exit ;
28849: GO 29453
// if GetBType ( depot ) = b_depot then
28851: LD_VAR 0 1
28855: PPUSH
28856: CALL_OW 266
28860: PUSH
28861: LD_INT 0
28863: EQUAL
28864: IFFALSE 28876
// dist := 28 else
28866: LD_ADDR_VAR 0 14
28870: PUSH
28871: LD_INT 28
28873: ST_TO_ADDR
28874: GO 28884
// dist := 36 ;
28876: LD_ADDR_VAR 0 14
28880: PUSH
28881: LD_INT 36
28883: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28884: LD_VAR 0 1
28888: PPUSH
28889: LD_VAR 0 3
28893: PPUSH
28894: LD_VAR 0 4
28898: PPUSH
28899: CALL_OW 297
28903: PUSH
28904: LD_VAR 0 14
28908: GREATER
28909: IFFALSE 28913
// exit ;
28911: GO 29453
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28913: LD_ADDR_VAR 0 12
28917: PUSH
28918: LD_VAR 0 2
28922: PPUSH
28923: LD_VAR 0 3
28927: PPUSH
28928: LD_VAR 0 4
28932: PPUSH
28933: LD_VAR 0 5
28937: PPUSH
28938: LD_VAR 0 1
28942: PPUSH
28943: CALL_OW 248
28947: PPUSH
28948: LD_INT 0
28950: PPUSH
28951: CALL 29458 0 6
28955: ST_TO_ADDR
// if not hexes then
28956: LD_VAR 0 12
28960: NOT
28961: IFFALSE 28965
// exit ;
28963: GO 29453
// hex := GetHexInfo ( x , y ) ;
28965: LD_ADDR_VAR 0 15
28969: PUSH
28970: LD_VAR 0 3
28974: PPUSH
28975: LD_VAR 0 4
28979: PPUSH
28980: CALL_OW 546
28984: ST_TO_ADDR
// if hex [ 1 ] then
28985: LD_VAR 0 15
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IFFALSE 28997
// exit ;
28995: GO 29453
// height := hex [ 2 ] ;
28997: LD_ADDR_VAR 0 13
29001: PUSH
29002: LD_VAR 0 15
29006: PUSH
29007: LD_INT 2
29009: ARRAY
29010: ST_TO_ADDR
// for i = 1 to hexes do
29011: LD_ADDR_VAR 0 7
29015: PUSH
29016: DOUBLE
29017: LD_INT 1
29019: DEC
29020: ST_TO_ADDR
29021: LD_VAR 0 12
29025: PUSH
29026: FOR_TO
29027: IFFALSE 29357
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29029: LD_VAR 0 12
29033: PUSH
29034: LD_VAR 0 7
29038: ARRAY
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PPUSH
29044: LD_VAR 0 12
29048: PUSH
29049: LD_VAR 0 7
29053: ARRAY
29054: PUSH
29055: LD_INT 2
29057: ARRAY
29058: PPUSH
29059: CALL_OW 488
29063: NOT
29064: PUSH
29065: LD_VAR 0 12
29069: PUSH
29070: LD_VAR 0 7
29074: ARRAY
29075: PUSH
29076: LD_INT 1
29078: ARRAY
29079: PPUSH
29080: LD_VAR 0 12
29084: PUSH
29085: LD_VAR 0 7
29089: ARRAY
29090: PUSH
29091: LD_INT 2
29093: ARRAY
29094: PPUSH
29095: CALL_OW 428
29099: PUSH
29100: LD_INT 0
29102: GREATER
29103: OR
29104: PUSH
29105: LD_VAR 0 12
29109: PUSH
29110: LD_VAR 0 7
29114: ARRAY
29115: PUSH
29116: LD_INT 1
29118: ARRAY
29119: PPUSH
29120: LD_VAR 0 12
29124: PUSH
29125: LD_VAR 0 7
29129: ARRAY
29130: PUSH
29131: LD_INT 2
29133: ARRAY
29134: PPUSH
29135: CALL_OW 351
29139: OR
29140: IFFALSE 29146
// exit ;
29142: POP
29143: POP
29144: GO 29453
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29146: LD_ADDR_VAR 0 8
29150: PUSH
29151: LD_VAR 0 12
29155: PUSH
29156: LD_VAR 0 7
29160: ARRAY
29161: PUSH
29162: LD_INT 1
29164: ARRAY
29165: PPUSH
29166: LD_VAR 0 12
29170: PUSH
29171: LD_VAR 0 7
29175: ARRAY
29176: PUSH
29177: LD_INT 2
29179: ARRAY
29180: PPUSH
29181: CALL_OW 546
29185: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29186: LD_VAR 0 8
29190: PUSH
29191: LD_INT 1
29193: ARRAY
29194: PUSH
29195: LD_VAR 0 8
29199: PUSH
29200: LD_INT 2
29202: ARRAY
29203: PUSH
29204: LD_VAR 0 13
29208: PUSH
29209: LD_INT 2
29211: PLUS
29212: GREATER
29213: OR
29214: PUSH
29215: LD_VAR 0 8
29219: PUSH
29220: LD_INT 2
29222: ARRAY
29223: PUSH
29224: LD_VAR 0 13
29228: PUSH
29229: LD_INT 2
29231: MINUS
29232: LESS
29233: OR
29234: PUSH
29235: LD_VAR 0 8
29239: PUSH
29240: LD_INT 3
29242: ARRAY
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: LD_INT 8
29249: PUSH
29250: LD_INT 9
29252: PUSH
29253: LD_INT 10
29255: PUSH
29256: LD_INT 11
29258: PUSH
29259: LD_INT 12
29261: PUSH
29262: LD_INT 13
29264: PUSH
29265: LD_INT 16
29267: PUSH
29268: LD_INT 17
29270: PUSH
29271: LD_INT 18
29273: PUSH
29274: LD_INT 19
29276: PUSH
29277: LD_INT 20
29279: PUSH
29280: LD_INT 21
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: LIST
29294: LIST
29295: LIST
29296: LIST
29297: IN
29298: NOT
29299: OR
29300: PUSH
29301: LD_VAR 0 8
29305: PUSH
29306: LD_INT 5
29308: ARRAY
29309: NOT
29310: OR
29311: PUSH
29312: LD_VAR 0 8
29316: PUSH
29317: LD_INT 6
29319: ARRAY
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: LD_INT 2
29326: PUSH
29327: LD_INT 7
29329: PUSH
29330: LD_INT 9
29332: PUSH
29333: LD_INT 10
29335: PUSH
29336: LD_INT 11
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: LIST
29346: IN
29347: NOT
29348: OR
29349: IFFALSE 29355
// exit ;
29351: POP
29352: POP
29353: GO 29453
// end ;
29355: GO 29026
29357: POP
29358: POP
// side := GetSide ( depot ) ;
29359: LD_ADDR_VAR 0 9
29363: PUSH
29364: LD_VAR 0 1
29368: PPUSH
29369: CALL_OW 255
29373: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29374: LD_VAR 0 9
29378: PPUSH
29379: LD_VAR 0 3
29383: PPUSH
29384: LD_VAR 0 4
29388: PPUSH
29389: LD_INT 20
29391: PPUSH
29392: CALL 22107 0 4
29396: PUSH
29397: LD_INT 4
29399: ARRAY
29400: IFFALSE 29404
// exit ;
29402: GO 29453
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29404: LD_VAR 0 2
29408: PUSH
29409: LD_INT 29
29411: PUSH
29412: LD_INT 30
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: IN
29419: PUSH
29420: LD_VAR 0 3
29424: PPUSH
29425: LD_VAR 0 4
29429: PPUSH
29430: LD_VAR 0 9
29434: PPUSH
29435: CALL_OW 440
29439: NOT
29440: AND
29441: IFFALSE 29445
// exit ;
29443: GO 29453
// result := true ;
29445: LD_ADDR_VAR 0 6
29449: PUSH
29450: LD_INT 1
29452: ST_TO_ADDR
// end ;
29453: LD_VAR 0 6
29457: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29458: LD_INT 0
29460: PPUSH
29461: PPUSH
29462: PPUSH
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
29468: PPUSH
29469: PPUSH
29470: PPUSH
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
29475: PPUSH
29476: PPUSH
29477: PPUSH
29478: PPUSH
29479: PPUSH
29480: PPUSH
29481: PPUSH
29482: PPUSH
29483: PPUSH
29484: PPUSH
29485: PPUSH
29486: PPUSH
29487: PPUSH
29488: PPUSH
29489: PPUSH
29490: PPUSH
29491: PPUSH
29492: PPUSH
29493: PPUSH
29494: PPUSH
29495: PPUSH
29496: PPUSH
29497: PPUSH
29498: PPUSH
29499: PPUSH
29500: PPUSH
29501: PPUSH
29502: PPUSH
29503: PPUSH
29504: PPUSH
29505: PPUSH
29506: PPUSH
29507: PPUSH
29508: PPUSH
29509: PPUSH
29510: PPUSH
29511: PPUSH
29512: PPUSH
29513: PPUSH
29514: PPUSH
29515: PPUSH
29516: PPUSH
29517: PPUSH
// result = [ ] ;
29518: LD_ADDR_VAR 0 7
29522: PUSH
29523: EMPTY
29524: ST_TO_ADDR
// temp_list = [ ] ;
29525: LD_ADDR_VAR 0 9
29529: PUSH
29530: EMPTY
29531: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29532: LD_VAR 0 4
29536: PUSH
29537: LD_INT 0
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: LD_INT 2
29545: PUSH
29546: LD_INT 3
29548: PUSH
29549: LD_INT 4
29551: PUSH
29552: LD_INT 5
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: IN
29563: NOT
29564: PUSH
29565: LD_VAR 0 1
29569: PUSH
29570: LD_INT 0
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: IN
29580: PUSH
29581: LD_VAR 0 5
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: LD_INT 3
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: LIST
29599: IN
29600: NOT
29601: AND
29602: OR
29603: IFFALSE 29607
// exit ;
29605: GO 47998
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29607: LD_VAR 0 1
29611: PUSH
29612: LD_INT 6
29614: PUSH
29615: LD_INT 7
29617: PUSH
29618: LD_INT 8
29620: PUSH
29621: LD_INT 13
29623: PUSH
29624: LD_INT 12
29626: PUSH
29627: LD_INT 15
29629: PUSH
29630: LD_INT 11
29632: PUSH
29633: LD_INT 14
29635: PUSH
29636: LD_INT 10
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: IN
29650: IFFALSE 29660
// btype = b_lab ;
29652: LD_ADDR_VAR 0 1
29656: PUSH
29657: LD_INT 6
29659: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29660: LD_VAR 0 6
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: LD_INT 1
29670: PUSH
29671: LD_INT 2
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: LIST
29678: IN
29679: NOT
29680: PUSH
29681: LD_VAR 0 1
29685: PUSH
29686: LD_INT 0
29688: PUSH
29689: LD_INT 1
29691: PUSH
29692: LD_INT 2
29694: PUSH
29695: LD_INT 3
29697: PUSH
29698: LD_INT 6
29700: PUSH
29701: LD_INT 36
29703: PUSH
29704: LD_INT 4
29706: PUSH
29707: LD_INT 5
29709: PUSH
29710: LD_INT 31
29712: PUSH
29713: LD_INT 32
29715: PUSH
29716: LD_INT 33
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: IN
29732: NOT
29733: PUSH
29734: LD_VAR 0 6
29738: PUSH
29739: LD_INT 1
29741: EQUAL
29742: AND
29743: OR
29744: PUSH
29745: LD_VAR 0 1
29749: PUSH
29750: LD_INT 2
29752: PUSH
29753: LD_INT 3
29755: PUSH
29756: EMPTY
29757: LIST
29758: LIST
29759: IN
29760: NOT
29761: PUSH
29762: LD_VAR 0 6
29766: PUSH
29767: LD_INT 2
29769: EQUAL
29770: AND
29771: OR
29772: IFFALSE 29782
// mode = 0 ;
29774: LD_ADDR_VAR 0 6
29778: PUSH
29779: LD_INT 0
29781: ST_TO_ADDR
// case mode of 0 :
29782: LD_VAR 0 6
29786: PUSH
29787: LD_INT 0
29789: DOUBLE
29790: EQUAL
29791: IFTRUE 29795
29793: GO 41248
29795: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29796: LD_ADDR_VAR 0 11
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: LD_INT 0
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 0
29813: PUSH
29814: LD_INT 1
29816: NEG
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 1
29824: PUSH
29825: LD_INT 0
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 1
29834: PUSH
29835: LD_INT 1
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: LD_INT 1
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PUSH
29852: LD_INT 1
29854: NEG
29855: PUSH
29856: LD_INT 0
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 1
29865: NEG
29866: PUSH
29867: LD_INT 1
29869: NEG
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 1
29877: NEG
29878: PUSH
29879: LD_INT 2
29881: NEG
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 0
29889: PUSH
29890: LD_INT 2
29892: NEG
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 1
29900: PUSH
29901: LD_INT 1
29903: NEG
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: LD_INT 1
29911: PUSH
29912: LD_INT 2
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: LD_INT 2
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: LD_INT 3
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 3
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 2
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: LIST
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29989: LD_ADDR_VAR 0 12
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 0
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 0
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 1
30027: PUSH
30028: LD_INT 1
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 0
30037: PUSH
30038: LD_INT 1
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 1
30047: NEG
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: NEG
30059: PUSH
30060: LD_INT 1
30062: NEG
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 1
30070: PUSH
30071: LD_INT 1
30073: NEG
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 2
30081: PUSH
30082: LD_INT 0
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 2
30091: PUSH
30092: LD_INT 1
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: LD_INT 1
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 2
30123: NEG
30124: PUSH
30125: LD_INT 1
30127: NEG
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 2
30135: NEG
30136: PUSH
30137: LD_INT 1
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 3
30146: NEG
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 3
30157: NEG
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30185: LD_ADDR_VAR 0 13
30189: PUSH
30190: LD_INT 0
30192: PUSH
30193: LD_INT 0
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: PUSH
30224: LD_INT 1
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 0
30233: PUSH
30234: LD_INT 1
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 1
30243: NEG
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: LD_INT 1
30258: NEG
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 1
30266: NEG
30267: PUSH
30268: LD_INT 2
30270: NEG
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: LD_INT 1
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 2
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 1
30298: PUSH
30299: LD_INT 2
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 2
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: NEG
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 2
30320: NEG
30321: PUSH
30322: LD_INT 2
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 3
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 3
30344: NEG
30345: PUSH
30346: LD_INT 2
30348: NEG
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 3
30356: NEG
30357: PUSH
30358: LD_INT 3
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30384: LD_ADDR_VAR 0 14
30388: PUSH
30389: LD_INT 0
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 0
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: PUSH
30410: LD_INT 1
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 1
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 0
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 1
30453: NEG
30454: PUSH
30455: LD_INT 1
30457: NEG
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 1
30465: NEG
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: LD_INT 2
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: LD_INT 1
30499: PUSH
30500: LD_INT 2
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 0
30509: PUSH
30510: LD_INT 2
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: LD_INT 1
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 1
30530: NEG
30531: PUSH
30532: LD_INT 3
30534: NEG
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 0
30542: PUSH
30543: LD_INT 3
30545: NEG
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 1
30553: PUSH
30554: LD_INT 2
30556: NEG
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30580: LD_ADDR_VAR 0 15
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 1
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: NEG
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 2
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: LD_INT 1
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 2
30703: NEG
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: NEG
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 2
30726: PUSH
30727: LD_INT 1
30729: NEG
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 3
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 3
30747: PUSH
30748: LD_INT 1
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30773: LD_ADDR_VAR 0 16
30777: PUSH
30778: LD_INT 0
30780: PUSH
30781: LD_INT 0
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 1
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: LD_INT 1
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: LD_INT 0
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: LD_INT 1
30846: NEG
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 1
30854: NEG
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 2
30876: PUSH
30877: LD_INT 2
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: LD_INT 2
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 2
30896: NEG
30897: PUSH
30898: LD_INT 1
30900: NEG
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 2
30908: NEG
30909: PUSH
30910: LD_INT 2
30912: NEG
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 3
30920: PUSH
30921: LD_INT 2
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 3
30930: PUSH
30931: LD_INT 3
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: PUSH
30938: LD_INT 2
30940: PUSH
30941: LD_INT 3
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30966: LD_ADDR_VAR 0 17
30970: PUSH
30971: LD_INT 0
30973: PUSH
30974: LD_INT 0
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 0
30983: PUSH
30984: LD_INT 1
30986: NEG
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 1
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 1
31004: PUSH
31005: LD_INT 1
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: LD_INT 1
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 1
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 1
31047: NEG
31048: PUSH
31049: LD_INT 2
31051: NEG
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 2
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 1
31073: NEG
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 2
31091: PUSH
31092: LD_INT 1
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PUSH
31099: LD_INT 2
31101: PUSH
31102: LD_INT 2
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 2
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: LD_INT 2
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: LD_INT 1
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 2
31142: NEG
31143: PUSH
31144: LD_INT 0
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 2
31165: NEG
31166: PUSH
31167: LD_INT 2
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31196: LD_ADDR_VAR 0 18
31200: PUSH
31201: LD_INT 0
31203: PUSH
31204: LD_INT 0
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: LD_INT 1
31216: NEG
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 1
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: LD_INT 1
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 1
31254: NEG
31255: PUSH
31256: LD_INT 0
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 1
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 1
31277: NEG
31278: PUSH
31279: LD_INT 2
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 0
31289: PUSH
31290: LD_INT 2
31292: NEG
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 1
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 2
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 2
31321: PUSH
31322: LD_INT 1
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: LD_INT 2
31331: PUSH
31332: LD_INT 2
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 1
31341: PUSH
31342: LD_INT 2
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 0
31351: PUSH
31352: LD_INT 2
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 1
31361: NEG
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: NEG
31373: PUSH
31374: LD_INT 0
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 2
31383: NEG
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: LD_INT 2
31395: NEG
31396: PUSH
31397: LD_INT 2
31399: NEG
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31426: LD_ADDR_VAR 0 19
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: LD_INT 0
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 0
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 1
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 0
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: LD_INT 0
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: NEG
31508: PUSH
31509: LD_INT 2
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: LD_INT 2
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: LD_INT 1
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 2
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 2
31551: PUSH
31552: LD_INT 1
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: LD_INT 2
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PUSH
31569: LD_INT 1
31571: PUSH
31572: LD_INT 2
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 0
31581: PUSH
31582: LD_INT 2
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 1
31591: NEG
31592: PUSH
31593: LD_INT 1
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 2
31602: NEG
31603: PUSH
31604: LD_INT 0
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 1
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 2
31625: NEG
31626: PUSH
31627: LD_INT 2
31629: NEG
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31656: LD_ADDR_VAR 0 20
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: LD_INT 0
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: LD_INT 0
31673: PUSH
31674: LD_INT 1
31676: NEG
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 1
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 1
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 0
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: NEG
31715: PUSH
31716: LD_INT 0
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 1
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: LD_INT 2
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 0
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 2
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 2
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 2
31791: PUSH
31792: LD_INT 2
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 1
31801: PUSH
31802: LD_INT 2
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: LD_INT 2
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 2
31832: NEG
31833: PUSH
31834: LD_INT 0
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 1
31847: NEG
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: LD_INT 2
31859: NEG
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31886: LD_ADDR_VAR 0 21
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 0
31903: PUSH
31904: LD_INT 1
31906: NEG
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: PUSH
31915: LD_INT 0
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 0
31934: PUSH
31935: LD_INT 1
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: LD_INT 0
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: LD_INT 1
31955: NEG
31956: PUSH
31957: LD_INT 1
31959: NEG
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: LD_INT 2
31971: NEG
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 0
31979: PUSH
31980: LD_INT 2
31982: NEG
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 2
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 2
32021: PUSH
32022: LD_INT 2
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 1
32031: PUSH
32032: LD_INT 2
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: LD_INT 0
32041: PUSH
32042: LD_INT 2
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: LD_INT 1
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 2
32062: NEG
32063: PUSH
32064: LD_INT 0
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 2
32073: NEG
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 2
32085: NEG
32086: PUSH
32087: LD_INT 2
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32116: LD_ADDR_VAR 0 22
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: LD_INT 0
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: LD_INT 1
32136: NEG
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 1
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 1
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 0
32164: PUSH
32165: LD_INT 1
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 1
32174: NEG
32175: PUSH
32176: LD_INT 0
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 1
32185: NEG
32186: PUSH
32187: LD_INT 1
32189: NEG
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: LD_INT 2
32201: NEG
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 0
32209: PUSH
32210: LD_INT 2
32212: NEG
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 1
32220: PUSH
32221: LD_INT 1
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: LD_INT 1
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: LD_INT 2
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 1
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: LD_INT 2
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 1
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 2
32292: NEG
32293: PUSH
32294: LD_INT 0
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 2
32303: NEG
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 2
32315: NEG
32316: PUSH
32317: LD_INT 2
32319: NEG
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32346: LD_ADDR_VAR 0 23
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: LD_INT 0
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 0
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 1
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 1
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 0
32394: PUSH
32395: LD_INT 1
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: LD_INT 0
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 1
32415: NEG
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: LD_INT 2
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 0
32439: PUSH
32440: LD_INT 2
32442: NEG
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: LD_INT 1
32453: NEG
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 2
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: LD_INT 1
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 2
32481: PUSH
32482: LD_INT 2
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: LD_INT 2
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 0
32501: PUSH
32502: LD_INT 2
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 2
32522: NEG
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 2
32533: NEG
32534: PUSH
32535: LD_INT 1
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 2
32545: NEG
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 2
32557: NEG
32558: PUSH
32559: LD_INT 3
32561: NEG
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 1
32569: NEG
32570: PUSH
32571: LD_INT 3
32573: NEG
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: LD_INT 2
32584: NEG
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: PUSH
32590: LD_INT 2
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32626: LD_ADDR_VAR 0 24
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 0
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: LD_INT 1
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: LD_INT 1
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 1
32699: NEG
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 1
32707: NEG
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 1
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: LD_INT 0
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 2
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 2
32761: PUSH
32762: LD_INT 2
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: LD_INT 2
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 0
32781: PUSH
32782: LD_INT 2
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 1
32791: NEG
32792: PUSH
32793: LD_INT 1
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 2
32802: NEG
32803: PUSH
32804: LD_INT 0
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 2
32813: NEG
32814: PUSH
32815: LD_INT 1
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 2
32825: NEG
32826: PUSH
32827: LD_INT 2
32829: NEG
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 1
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 2
32848: PUSH
32849: LD_INT 1
32851: NEG
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 3
32859: PUSH
32860: LD_INT 1
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 3
32869: PUSH
32870: LD_INT 2
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: LIST
32901: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32902: LD_ADDR_VAR 0 25
32906: PUSH
32907: LD_INT 0
32909: PUSH
32910: LD_INT 0
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: LD_INT 1
32922: NEG
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 1
32930: PUSH
32931: LD_INT 0
32933: PUSH
32934: EMPTY
32935: LIST
32936: LIST
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: LD_INT 1
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: LD_INT 1
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 1
32960: NEG
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: NEG
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: LD_INT 2
32998: NEG
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 1
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 2
33027: PUSH
33028: LD_INT 1
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 2
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: LD_INT 2
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: LD_INT 2
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 1
33067: NEG
33068: PUSH
33069: LD_INT 1
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 2
33078: NEG
33079: PUSH
33080: LD_INT 0
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 2
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: NEG
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 2
33101: NEG
33102: PUSH
33103: LD_INT 2
33105: NEG
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 3
33113: PUSH
33114: LD_INT 1
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 3
33123: PUSH
33124: LD_INT 2
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 2
33133: PUSH
33134: LD_INT 3
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 1
33143: PUSH
33144: LD_INT 3
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33176: LD_ADDR_VAR 0 26
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 0
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: LD_INT 1
33196: NEG
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 1
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: LD_INT 2
33261: NEG
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: LD_INT 2
33272: NEG
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: LD_INT 1
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: LD_INT 0
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 2
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 0
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 1
33341: NEG
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 2
33352: NEG
33353: PUSH
33354: LD_INT 0
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 2
33363: NEG
33364: PUSH
33365: LD_INT 1
33367: NEG
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 2
33375: NEG
33376: PUSH
33377: LD_INT 2
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 2
33387: PUSH
33388: LD_INT 3
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: LD_INT 2
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 2
33418: NEG
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33452: LD_ADDR_VAR 0 27
33456: PUSH
33457: LD_INT 0
33459: PUSH
33460: LD_INT 0
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 0
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 1
33480: PUSH
33481: LD_INT 0
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: LD_INT 1
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 0
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 1
33510: NEG
33511: PUSH
33512: LD_INT 0
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: NEG
33522: PUSH
33523: LD_INT 1
33525: NEG
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: LD_INT 1
33533: NEG
33534: PUSH
33535: LD_INT 2
33537: NEG
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 0
33545: PUSH
33546: LD_INT 2
33548: NEG
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 2
33567: PUSH
33568: LD_INT 0
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 2
33587: PUSH
33588: LD_INT 2
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: LD_INT 2
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 0
33607: PUSH
33608: LD_INT 2
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 1
33617: NEG
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 2
33628: NEG
33629: PUSH
33630: LD_INT 0
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: LD_INT 1
33643: NEG
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 2
33651: NEG
33652: PUSH
33653: LD_INT 2
33655: NEG
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 1
33663: NEG
33664: PUSH
33665: LD_INT 2
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: LD_INT 1
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 3
33685: NEG
33686: PUSH
33687: LD_INT 1
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 3
33697: NEG
33698: PUSH
33699: LD_INT 2
33701: NEG
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33732: LD_ADDR_VAR 0 28
33736: PUSH
33737: LD_INT 0
33739: PUSH
33740: LD_INT 0
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: LD_INT 1
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 1
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: LD_INT 1
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: LD_INT 1
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 1
33801: NEG
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 1
33813: NEG
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 0
33825: PUSH
33826: LD_INT 2
33828: NEG
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 1
33836: PUSH
33837: LD_INT 1
33839: NEG
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 2
33847: PUSH
33848: LD_INT 0
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 2
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 2
33867: PUSH
33868: LD_INT 2
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 2
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: LD_INT 2
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: NEG
33898: PUSH
33899: LD_INT 1
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 2
33908: NEG
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 2
33919: NEG
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 2
33931: NEG
33932: PUSH
33933: LD_INT 2
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 2
33943: NEG
33944: PUSH
33945: LD_INT 3
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 1
33955: NEG
33956: PUSH
33957: LD_INT 3
33959: NEG
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 3
33967: NEG
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 3
33979: NEG
33980: PUSH
33981: LD_INT 2
33983: NEG
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34014: LD_ADDR_VAR 0 29
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: LD_INT 1
34034: NEG
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: NEG
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 2
34099: NEG
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: LD_INT 2
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: PUSH
34119: LD_INT 1
34121: NEG
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 2
34129: PUSH
34130: LD_INT 0
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 2
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: PUSH
34150: LD_INT 2
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: LD_INT 2
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: NEG
34181: PUSH
34182: LD_INT 1
34184: NEG
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 2
34192: NEG
34193: PUSH
34194: LD_INT 2
34196: NEG
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 2
34204: NEG
34205: PUSH
34206: LD_INT 3
34208: NEG
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 2
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 3
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: LD_INT 3
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 1
34247: NEG
34248: PUSH
34249: LD_INT 2
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 3
34258: NEG
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34293: LD_ADDR_VAR 0 30
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 0
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: PUSH
34332: LD_INT 1
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 1
34351: NEG
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: NEG
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 1
34374: NEG
34375: PUSH
34376: LD_INT 2
34378: NEG
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: LD_INT 2
34389: NEG
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: PUSH
34398: LD_INT 1
34400: NEG
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 2
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 2
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 2
34428: PUSH
34429: LD_INT 2
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 2
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: NEG
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 2
34459: NEG
34460: PUSH
34461: LD_INT 0
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PUSH
34468: LD_INT 2
34470: NEG
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: LD_INT 1
34482: NEG
34483: PUSH
34484: LD_INT 3
34486: NEG
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: LD_INT 2
34497: NEG
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 3
34505: PUSH
34506: LD_INT 2
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: LD_INT 3
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 2
34525: NEG
34526: PUSH
34527: LD_INT 1
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 3
34536: NEG
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: LIST
34570: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34571: LD_ADDR_VAR 0 31
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: LD_INT 0
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 0
34588: PUSH
34589: LD_INT 1
34591: NEG
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 1
34609: PUSH
34610: LD_INT 1
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 0
34619: PUSH
34620: LD_INT 1
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 1
34629: NEG
34630: PUSH
34631: LD_INT 0
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 1
34640: NEG
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: LD_INT 2
34656: NEG
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: LD_INT 1
34667: NEG
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 2
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 2
34695: PUSH
34696: LD_INT 2
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 1
34705: PUSH
34706: LD_INT 2
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 0
34715: PUSH
34716: LD_INT 2
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 1
34725: NEG
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: NEG
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 2
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 3
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 2
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 3
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: LD_INT 3
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 3
34814: NEG
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: LIST
34848: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34849: LD_ADDR_VAR 0 32
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 0
34897: PUSH
34898: LD_INT 1
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 1
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 2
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: LD_INT 2
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 2
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: LD_INT 2
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 2
35015: NEG
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 2
35026: NEG
35027: PUSH
35028: LD_INT 1
35030: NEG
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: NEG
35039: PUSH
35040: LD_INT 3
35042: NEG
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: LD_INT 2
35053: NEG
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 3
35061: PUSH
35062: LD_INT 2
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 2
35071: PUSH
35072: LD_INT 3
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: LD_INT 2
35081: NEG
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 3
35092: NEG
35093: PUSH
35094: LD_INT 1
35096: NEG
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35127: LD_ADDR_VAR 0 33
35131: PUSH
35132: LD_INT 0
35134: PUSH
35135: LD_INT 0
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 1
35147: NEG
35148: PUSH
35149: EMPTY
35150: LIST
35151: LIST
35152: PUSH
35153: LD_INT 1
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 1
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: LD_INT 0
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: LD_INT 1
35196: NEG
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: LD_INT 2
35212: NEG
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: LD_INT 1
35223: NEG
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: PUSH
35232: LD_INT 0
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 2
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: LD_INT 2
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: LD_INT 2
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 1
35271: NEG
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 2
35282: NEG
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 2
35293: NEG
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 2
35305: NEG
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 2
35317: NEG
35318: PUSH
35319: LD_INT 3
35321: NEG
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: PUSH
35330: LD_INT 1
35332: NEG
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 3
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: LD_INT 3
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 3
35371: NEG
35372: PUSH
35373: LD_INT 2
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35406: LD_ADDR_VAR 0 34
35410: PUSH
35411: LD_INT 0
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 0
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: PUSH
35445: LD_INT 1
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 0
35454: PUSH
35455: LD_INT 1
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: NEG
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 1
35475: NEG
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 1
35487: NEG
35488: PUSH
35489: LD_INT 2
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: LD_INT 2
35502: NEG
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: LD_INT 1
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 2
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 1
35541: PUSH
35542: LD_INT 2
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: LD_INT 1
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 2
35573: NEG
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 2
35585: NEG
35586: PUSH
35587: LD_INT 2
35589: NEG
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: LD_INT 3
35601: NEG
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: LD_INT 2
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 3
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: PUSH
35631: LD_INT 3
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 3
35651: NEG
35652: PUSH
35653: LD_INT 1
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35686: LD_ADDR_VAR 0 35
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 0
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 1
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 0
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: LD_INT 1
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35798: LD_ADDR_VAR 0 36
35802: PUSH
35803: LD_INT 0
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: LD_INT 1
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 0
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 1
35867: NEG
35868: PUSH
35869: LD_INT 1
35871: NEG
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 1
35879: NEG
35880: PUSH
35881: LD_INT 2
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: LD_INT 2
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35910: LD_ADDR_VAR 0 37
35914: PUSH
35915: LD_INT 0
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 0
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 0
35958: PUSH
35959: LD_INT 1
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 1
35968: NEG
35969: PUSH
35970: LD_INT 0
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: NEG
35980: PUSH
35981: LD_INT 1
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 1
35991: PUSH
35992: LD_INT 1
35994: NEG
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: LIST
36021: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36022: LD_ADDR_VAR 0 38
36026: PUSH
36027: LD_INT 0
36029: PUSH
36030: LD_INT 0
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: LD_INT 1
36042: NEG
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: PUSH
36051: LD_INT 0
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 1
36060: PUSH
36061: LD_INT 1
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 1
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: NEG
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: PUSH
36104: LD_INT 1
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 2
36113: NEG
36114: PUSH
36115: LD_INT 1
36117: NEG
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36134: LD_ADDR_VAR 0 39
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 0
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: NEG
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: NEG
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: LD_INT 2
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36246: LD_ADDR_VAR 0 40
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 0
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 0
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: LD_INT 0
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: LD_INT 1
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 0
36294: PUSH
36295: LD_INT 1
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: LD_INT 0
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: LD_INT 1
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: LD_INT 1
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36358: LD_ADDR_VAR 0 41
36362: PUSH
36363: LD_INT 0
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: LD_INT 1
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 1
36396: PUSH
36397: LD_INT 1
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 0
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: LD_INT 1
36416: NEG
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 1
36427: NEG
36428: PUSH
36429: LD_INT 1
36431: NEG
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 2
36443: NEG
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 1
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 2
36462: PUSH
36463: LD_INT 0
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 2
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 2
36482: PUSH
36483: LD_INT 2
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 1
36492: PUSH
36493: LD_INT 2
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 1
36502: NEG
36503: PUSH
36504: LD_INT 1
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: LD_INT 2
36513: NEG
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 2
36524: NEG
36525: PUSH
36526: LD_INT 1
36528: NEG
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: LD_INT 2
36540: NEG
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 2
36548: NEG
36549: PUSH
36550: LD_INT 3
36552: NEG
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 2
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 3
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 3
36581: PUSH
36582: LD_INT 1
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 3
36591: PUSH
36592: LD_INT 2
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: LD_INT 3
36601: PUSH
36602: LD_INT 3
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: LD_INT 3
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 3
36632: NEG
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 3
36643: NEG
36644: PUSH
36645: LD_INT 1
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 3
36655: NEG
36656: PUSH
36657: LD_INT 2
36659: NEG
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 3
36667: NEG
36668: PUSH
36669: LD_INT 3
36671: NEG
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36708: LD_ADDR_VAR 0 42
36712: PUSH
36713: LD_INT 0
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 1
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 1
36746: PUSH
36747: LD_INT 1
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 0
36756: PUSH
36757: LD_INT 1
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: LD_INT 0
36770: PUSH
36771: EMPTY
36772: LIST
36773: LIST
36774: PUSH
36775: LD_INT 1
36777: NEG
36778: PUSH
36779: LD_INT 1
36781: NEG
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: PUSH
36787: LD_INT 1
36789: NEG
36790: PUSH
36791: LD_INT 2
36793: NEG
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: LD_INT 2
36804: NEG
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: LD_INT 1
36815: NEG
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 2
36833: PUSH
36834: LD_INT 2
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: PUSH
36844: LD_INT 2
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 0
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: LD_INT 1
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 2
36874: NEG
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: LD_INT 2
36890: NEG
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 2
36898: NEG
36899: PUSH
36900: LD_INT 3
36902: NEG
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: LD_INT 3
36914: NEG
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 0
36922: PUSH
36923: LD_INT 3
36925: NEG
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: LD_INT 2
36936: NEG
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 3
36954: PUSH
36955: LD_INT 3
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 2
36964: PUSH
36965: LD_INT 3
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: LD_INT 3
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: LD_INT 3
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 1
36994: NEG
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 3
37005: NEG
37006: PUSH
37007: LD_INT 2
37009: NEG
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 3
37017: NEG
37018: PUSH
37019: LD_INT 3
37021: NEG
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37058: LD_ADDR_VAR 0 43
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: LD_INT 0
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 0
37075: PUSH
37076: LD_INT 1
37078: NEG
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 1
37086: PUSH
37087: LD_INT 0
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 1
37096: PUSH
37097: LD_INT 1
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 0
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 1
37116: NEG
37117: PUSH
37118: LD_INT 0
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 1
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 1
37139: NEG
37140: PUSH
37141: LD_INT 2
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 0
37151: PUSH
37152: LD_INT 2
37154: NEG
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: LD_INT 1
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 2
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 2
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: PUSH
37194: LD_INT 2
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 0
37203: PUSH
37204: LD_INT 2
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PUSH
37211: LD_INT 1
37213: NEG
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 2
37224: NEG
37225: PUSH
37226: LD_INT 0
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 2
37235: NEG
37236: PUSH
37237: LD_INT 1
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: LD_INT 3
37251: NEG
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 0
37259: PUSH
37260: LD_INT 3
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 2
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 1
37284: NEG
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 3
37292: PUSH
37293: LD_INT 0
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 3
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: PUSH
37313: LD_INT 3
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: LD_INT 3
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: LD_INT 2
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 2
37343: NEG
37344: PUSH
37345: LD_INT 1
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 3
37354: NEG
37355: PUSH
37356: LD_INT 0
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 3
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37406: LD_ADDR_VAR 0 44
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 0
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 0
37423: PUSH
37424: LD_INT 1
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: NEG
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 1
37475: NEG
37476: PUSH
37477: LD_INT 1
37479: NEG
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: LD_INT 2
37491: NEG
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 1
37499: PUSH
37500: LD_INT 1
37502: NEG
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 2
37510: PUSH
37511: LD_INT 0
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 2
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 2
37530: PUSH
37531: LD_INT 2
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 1
37540: PUSH
37541: LD_INT 2
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 1
37550: NEG
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 2
37561: NEG
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 2
37572: NEG
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 2
37584: NEG
37585: PUSH
37586: LD_INT 2
37588: NEG
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 2
37596: NEG
37597: PUSH
37598: LD_INT 3
37600: NEG
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 2
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 3
37619: PUSH
37620: LD_INT 0
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: PUSH
37627: LD_INT 3
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 3
37639: PUSH
37640: LD_INT 2
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: LD_INT 3
37649: PUSH
37650: LD_INT 3
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 2
37659: PUSH
37660: LD_INT 3
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: LD_INT 2
37669: NEG
37670: PUSH
37671: LD_INT 1
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 3
37680: NEG
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 3
37691: NEG
37692: PUSH
37693: LD_INT 1
37695: NEG
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 3
37703: NEG
37704: PUSH
37705: LD_INT 2
37707: NEG
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 3
37715: NEG
37716: PUSH
37717: LD_INT 3
37719: NEG
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: LIST
37741: LIST
37742: LIST
37743: LIST
37744: LIST
37745: LIST
37746: LIST
37747: LIST
37748: LIST
37749: LIST
37750: LIST
37751: LIST
37752: LIST
37753: LIST
37754: LIST
37755: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37756: LD_ADDR_VAR 0 45
37760: PUSH
37761: LD_INT 0
37763: PUSH
37764: LD_INT 0
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: LD_INT 1
37776: NEG
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 1
37784: PUSH
37785: LD_INT 0
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 1
37794: PUSH
37795: LD_INT 1
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 0
37804: PUSH
37805: LD_INT 1
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 1
37814: NEG
37815: PUSH
37816: LD_INT 0
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: NEG
37826: PUSH
37827: LD_INT 1
37829: NEG
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 1
37837: NEG
37838: PUSH
37839: LD_INT 2
37841: NEG
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: LD_INT 1
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 2
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 2
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 1
37891: PUSH
37892: LD_INT 2
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 0
37901: PUSH
37902: LD_INT 2
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: NEG
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 2
37922: NEG
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 2
37934: NEG
37935: PUSH
37936: LD_INT 2
37938: NEG
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 2
37946: NEG
37947: PUSH
37948: LD_INT 3
37950: NEG
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: LD_INT 3
37962: NEG
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 0
37970: PUSH
37971: LD_INT 3
37973: NEG
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 1
37981: PUSH
37982: LD_INT 2
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 3
37992: PUSH
37993: LD_INT 2
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 3
38002: PUSH
38003: LD_INT 3
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: PUSH
38013: LD_INT 3
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 1
38022: PUSH
38023: LD_INT 3
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: LD_INT 3
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 1
38042: NEG
38043: PUSH
38044: LD_INT 2
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 3
38053: NEG
38054: PUSH
38055: LD_INT 2
38057: NEG
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 3
38065: NEG
38066: PUSH
38067: LD_INT 3
38069: NEG
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38106: LD_ADDR_VAR 0 46
38110: PUSH
38111: LD_INT 0
38113: PUSH
38114: LD_INT 0
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 0
38123: PUSH
38124: LD_INT 1
38126: NEG
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 1
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 1
38144: PUSH
38145: LD_INT 1
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 0
38154: PUSH
38155: LD_INT 1
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 1
38164: NEG
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: LD_INT 1
38179: NEG
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: PUSH
38185: LD_INT 1
38187: NEG
38188: PUSH
38189: LD_INT 2
38191: NEG
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 0
38199: PUSH
38200: LD_INT 2
38202: NEG
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: PUSH
38211: LD_INT 1
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 2
38221: PUSH
38222: LD_INT 0
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: PUSH
38232: LD_INT 1
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: LD_INT 2
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 2
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: LD_INT 1
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 2
38272: NEG
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 2
38283: NEG
38284: PUSH
38285: LD_INT 1
38287: NEG
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: LD_INT 3
38299: NEG
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 0
38307: PUSH
38308: LD_INT 3
38310: NEG
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 1
38318: PUSH
38319: LD_INT 2
38321: NEG
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 2
38329: PUSH
38330: LD_INT 1
38332: NEG
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 3
38340: PUSH
38341: LD_INT 0
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 3
38350: PUSH
38351: LD_INT 1
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: LD_INT 3
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: LD_INT 3
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 1
38380: NEG
38381: PUSH
38382: LD_INT 2
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 2
38391: NEG
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 3
38402: NEG
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 3
38413: NEG
38414: PUSH
38415: LD_INT 1
38417: NEG
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: EMPTY
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38454: LD_ADDR_VAR 0 47
38458: PUSH
38459: LD_INT 0
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 0
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 1
38482: PUSH
38483: LD_INT 0
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 1
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: NEG
38513: PUSH
38514: LD_INT 0
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 1
38523: NEG
38524: PUSH
38525: LD_INT 1
38527: NEG
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: LD_INT 2
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 1
38561: NEG
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 2
38569: NEG
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 2
38581: NEG
38582: PUSH
38583: LD_INT 2
38585: NEG
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38605: LD_ADDR_VAR 0 48
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 0
38622: PUSH
38623: LD_INT 1
38625: NEG
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: LD_INT 0
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: LD_INT 1
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: LD_INT 0
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 1
38674: NEG
38675: PUSH
38676: LD_INT 1
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 1
38686: NEG
38687: PUSH
38688: LD_INT 2
38690: NEG
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 2
38701: NEG
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: LD_INT 1
38712: NEG
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: LD_INT 0
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 2
38730: PUSH
38731: LD_INT 1
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38752: LD_ADDR_VAR 0 49
38756: PUSH
38757: LD_INT 0
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 0
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 1
38780: PUSH
38781: LD_INT 0
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: PUSH
38791: LD_INT 1
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 0
38800: PUSH
38801: LD_INT 1
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 1
38810: NEG
38811: PUSH
38812: LD_INT 0
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: LD_INT 1
38821: NEG
38822: PUSH
38823: LD_INT 1
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: LD_INT 1
38836: NEG
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 2
38844: PUSH
38845: LD_INT 0
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 2
38854: PUSH
38855: LD_INT 1
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 2
38864: PUSH
38865: LD_INT 2
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: LD_INT 2
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38896: LD_ADDR_VAR 0 50
38900: PUSH
38901: LD_INT 0
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 0
38913: PUSH
38914: LD_INT 1
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: PUSH
38925: LD_INT 0
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 0
38944: PUSH
38945: LD_INT 1
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 1
38954: NEG
38955: PUSH
38956: LD_INT 0
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: LD_INT 1
38969: NEG
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: LD_INT 1
38980: PUSH
38981: EMPTY
38982: LIST
38983: LIST
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: LD_INT 2
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 0
39007: PUSH
39008: LD_INT 2
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39040: LD_ADDR_VAR 0 51
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 1
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: PUSH
39079: LD_INT 1
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 0
39088: PUSH
39089: LD_INT 1
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 1
39098: NEG
39099: PUSH
39100: LD_INT 0
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: LD_INT 1
39113: NEG
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 2
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 1
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: LD_INT 0
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: LD_INT 2
39163: NEG
39164: PUSH
39165: LD_INT 1
39167: NEG
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39187: LD_ADDR_VAR 0 52
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: LD_INT 0
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 0
39204: PUSH
39205: LD_INT 1
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 1
39225: PUSH
39226: LD_INT 1
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 0
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 1
39245: NEG
39246: PUSH
39247: LD_INT 0
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 1
39256: NEG
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 1
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 2
39291: NEG
39292: PUSH
39293: LD_INT 0
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 2
39302: NEG
39303: PUSH
39304: LD_INT 1
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 2
39314: NEG
39315: PUSH
39316: LD_INT 2
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: LIST
39331: LIST
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39338: LD_ADDR_VAR 0 53
39342: PUSH
39343: LD_INT 0
39345: PUSH
39346: LD_INT 0
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 0
39355: PUSH
39356: LD_INT 1
39358: NEG
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 1
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 0
39386: PUSH
39387: LD_INT 1
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: LD_INT 1
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: NEG
39420: PUSH
39421: LD_INT 2
39423: NEG
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 0
39431: PUSH
39432: LD_INT 2
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 2
39453: PUSH
39454: LD_INT 0
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: PUSH
39464: LD_INT 1
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 2
39473: PUSH
39474: LD_INT 2
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 1
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: LD_INT 2
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 1
39503: NEG
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 2
39514: NEG
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 2
39537: NEG
39538: PUSH
39539: LD_INT 2
39541: NEG
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39568: LD_ADDR_VAR 0 54
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 0
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 0
39585: PUSH
39586: LD_INT 1
39588: NEG
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 1
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 1
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: LD_INT 1
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 0
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 1
39649: NEG
39650: PUSH
39651: LD_INT 2
39653: NEG
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 2
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 2
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 2
39703: PUSH
39704: LD_INT 2
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: LD_INT 2
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: LD_INT 2
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 1
39733: NEG
39734: PUSH
39735: LD_INT 1
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 2
39744: NEG
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 2
39755: NEG
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 2
39767: NEG
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: LIST
39784: LIST
39785: LIST
39786: LIST
39787: LIST
39788: LIST
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39798: LD_ADDR_VAR 0 55
39802: PUSH
39803: LD_INT 0
39805: PUSH
39806: LD_INT 0
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 0
39815: PUSH
39816: LD_INT 1
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 1
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 0
39846: PUSH
39847: LD_INT 1
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 1
39856: NEG
39857: PUSH
39858: LD_INT 0
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: LD_INT 1
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: LD_INT 2
39883: NEG
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: LD_INT 2
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 2
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 2
39923: PUSH
39924: LD_INT 1
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 2
39933: PUSH
39934: LD_INT 2
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 1
39943: PUSH
39944: LD_INT 2
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: LD_INT 2
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: NEG
39964: PUSH
39965: LD_INT 1
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 2
39974: NEG
39975: PUSH
39976: LD_INT 0
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: LD_INT 1
39989: NEG
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 2
39997: NEG
39998: PUSH
39999: LD_INT 2
40001: NEG
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40028: LD_ADDR_VAR 0 56
40032: PUSH
40033: LD_INT 0
40035: PUSH
40036: LD_INT 0
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 0
40045: PUSH
40046: LD_INT 1
40048: NEG
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 1
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 0
40076: PUSH
40077: LD_INT 1
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 1
40086: NEG
40087: PUSH
40088: LD_INT 0
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 1
40097: NEG
40098: PUSH
40099: LD_INT 1
40101: NEG
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 1
40109: NEG
40110: PUSH
40111: LD_INT 2
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: PUSH
40133: LD_INT 1
40135: NEG
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 2
40143: PUSH
40144: LD_INT 0
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 2
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 2
40163: PUSH
40164: LD_INT 2
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 1
40173: PUSH
40174: LD_INT 2
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 0
40183: PUSH
40184: LD_INT 2
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 1
40193: NEG
40194: PUSH
40195: LD_INT 1
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 2
40204: NEG
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 2
40215: NEG
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: NEG
40228: PUSH
40229: LD_INT 2
40231: NEG
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40258: LD_ADDR_VAR 0 57
40262: PUSH
40263: LD_INT 0
40265: PUSH
40266: LD_INT 0
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 0
40275: PUSH
40276: LD_INT 1
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: LD_INT 0
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 1
40296: PUSH
40297: LD_INT 1
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: LD_INT 1
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 1
40316: NEG
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 1
40327: NEG
40328: PUSH
40329: LD_INT 1
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 1
40339: NEG
40340: PUSH
40341: LD_INT 2
40343: NEG
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: LD_INT 2
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: PUSH
40363: LD_INT 1
40365: NEG
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 2
40373: PUSH
40374: LD_INT 0
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 2
40383: PUSH
40384: LD_INT 1
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: LD_INT 2
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 1
40403: PUSH
40404: LD_INT 2
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 0
40413: PUSH
40414: LD_INT 2
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 1
40423: NEG
40424: PUSH
40425: LD_INT 1
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 2
40434: NEG
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 2
40445: NEG
40446: PUSH
40447: LD_INT 1
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 2
40457: NEG
40458: PUSH
40459: LD_INT 2
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40488: LD_ADDR_VAR 0 58
40492: PUSH
40493: LD_INT 0
40495: PUSH
40496: LD_INT 0
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 0
40505: PUSH
40506: LD_INT 1
40508: NEG
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: LD_INT 1
40526: PUSH
40527: LD_INT 1
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 0
40536: PUSH
40537: LD_INT 1
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PUSH
40544: LD_INT 1
40546: NEG
40547: PUSH
40548: LD_INT 0
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 1
40557: NEG
40558: PUSH
40559: LD_INT 1
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 1
40569: NEG
40570: PUSH
40571: LD_INT 2
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 0
40581: PUSH
40582: LD_INT 2
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: PUSH
40593: LD_INT 1
40595: NEG
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 2
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 2
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 2
40623: PUSH
40624: LD_INT 2
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 1
40633: PUSH
40634: LD_INT 2
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: LD_INT 2
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: LD_INT 1
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 2
40675: NEG
40676: PUSH
40677: LD_INT 1
40679: NEG
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 2
40687: NEG
40688: PUSH
40689: LD_INT 2
40691: NEG
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40718: LD_ADDR_VAR 0 59
40722: PUSH
40723: LD_INT 0
40725: PUSH
40726: LD_INT 0
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: LD_INT 0
40735: PUSH
40736: LD_INT 1
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 1
40746: PUSH
40747: LD_INT 0
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 1
40756: PUSH
40757: LD_INT 1
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 0
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 1
40776: NEG
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40806: LD_ADDR_VAR 0 60
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: LD_INT 0
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: LD_INT 1
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 1
40844: PUSH
40845: LD_INT 1
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 0
40854: PUSH
40855: LD_INT 1
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 1
40864: NEG
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 1
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40894: LD_ADDR_VAR 0 61
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 0
40911: PUSH
40912: LD_INT 1
40914: NEG
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 1
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 1
40932: PUSH
40933: LD_INT 1
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 1
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: NEG
40953: PUSH
40954: LD_INT 0
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 1
40967: NEG
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40982: LD_ADDR_VAR 0 62
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: LD_INT 0
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 0
40999: PUSH
41000: LD_INT 1
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 1
41010: PUSH
41011: LD_INT 0
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 1
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: LD_INT 1
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 1
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 1
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41070: LD_ADDR_VAR 0 63
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 0
41087: PUSH
41088: LD_INT 1
41090: NEG
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 1
41098: PUSH
41099: LD_INT 0
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 1
41108: PUSH
41109: LD_INT 1
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 0
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 1
41128: NEG
41129: PUSH
41130: LD_INT 0
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 1
41139: NEG
41140: PUSH
41141: LD_INT 1
41143: NEG
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41158: LD_ADDR_VAR 0 64
41162: PUSH
41163: LD_INT 0
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: LD_INT 1
41178: NEG
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 1
41186: PUSH
41187: LD_INT 0
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 1
41196: PUSH
41197: LD_INT 1
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 0
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 1
41216: NEG
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 1
41227: NEG
41228: PUSH
41229: LD_INT 1
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: ST_TO_ADDR
// end ; 1 :
41246: GO 47143
41248: LD_INT 1
41250: DOUBLE
41251: EQUAL
41252: IFTRUE 41256
41254: GO 43879
41256: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41257: LD_ADDR_VAR 0 11
41261: PUSH
41262: LD_INT 1
41264: NEG
41265: PUSH
41266: LD_INT 3
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 1
41287: PUSH
41288: LD_INT 2
41290: NEG
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: LIST
41300: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41301: LD_ADDR_VAR 0 12
41305: PUSH
41306: LD_INT 2
41308: PUSH
41309: LD_INT 1
41311: NEG
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 3
41319: PUSH
41320: LD_INT 0
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: LD_INT 1
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: LIST
41341: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41342: LD_ADDR_VAR 0 13
41346: PUSH
41347: LD_INT 3
41349: PUSH
41350: LD_INT 2
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: LD_INT 3
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 2
41369: PUSH
41370: LD_INT 3
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41382: LD_ADDR_VAR 0 14
41386: PUSH
41387: LD_INT 1
41389: PUSH
41390: LD_INT 3
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 0
41399: PUSH
41400: LD_INT 3
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: NEG
41410: PUSH
41411: LD_INT 2
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: LIST
41422: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41423: LD_ADDR_VAR 0 15
41427: PUSH
41428: LD_INT 2
41430: NEG
41431: PUSH
41432: LD_INT 1
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 3
41441: NEG
41442: PUSH
41443: LD_INT 0
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 3
41452: NEG
41453: PUSH
41454: LD_INT 1
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: LIST
41466: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41467: LD_ADDR_VAR 0 16
41471: PUSH
41472: LD_INT 2
41474: NEG
41475: PUSH
41476: LD_INT 3
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 3
41486: NEG
41487: PUSH
41488: LD_INT 2
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 3
41498: NEG
41499: PUSH
41500: LD_INT 3
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: LIST
41512: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41513: LD_ADDR_VAR 0 17
41517: PUSH
41518: LD_INT 1
41520: NEG
41521: PUSH
41522: LD_INT 3
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 0
41532: PUSH
41533: LD_INT 3
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: PUSH
41544: LD_INT 2
41546: NEG
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41557: LD_ADDR_VAR 0 18
41561: PUSH
41562: LD_INT 2
41564: PUSH
41565: LD_INT 1
41567: NEG
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 3
41575: PUSH
41576: LD_INT 0
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: LD_INT 1
41588: PUSH
41589: EMPTY
41590: LIST
41591: LIST
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: LIST
41597: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41598: LD_ADDR_VAR 0 19
41602: PUSH
41603: LD_INT 3
41605: PUSH
41606: LD_INT 2
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 3
41615: PUSH
41616: LD_INT 3
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 2
41625: PUSH
41626: LD_INT 3
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: LIST
41637: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41638: LD_ADDR_VAR 0 20
41642: PUSH
41643: LD_INT 1
41645: PUSH
41646: LD_INT 3
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PUSH
41653: LD_INT 0
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 1
41665: NEG
41666: PUSH
41667: LD_INT 2
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: LIST
41678: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41679: LD_ADDR_VAR 0 21
41683: PUSH
41684: LD_INT 2
41686: NEG
41687: PUSH
41688: LD_INT 1
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 3
41708: NEG
41709: PUSH
41710: LD_INT 1
41712: NEG
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: LIST
41722: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41723: LD_ADDR_VAR 0 22
41727: PUSH
41728: LD_INT 2
41730: NEG
41731: PUSH
41732: LD_INT 3
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 3
41742: NEG
41743: PUSH
41744: LD_INT 2
41746: NEG
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 3
41754: NEG
41755: PUSH
41756: LD_INT 3
41758: NEG
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: LIST
41768: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41769: LD_ADDR_VAR 0 23
41773: PUSH
41774: LD_INT 0
41776: PUSH
41777: LD_INT 3
41779: NEG
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: LD_INT 4
41791: NEG
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 1
41799: PUSH
41800: LD_INT 3
41802: NEG
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41813: LD_ADDR_VAR 0 24
41817: PUSH
41818: LD_INT 3
41820: PUSH
41821: LD_INT 0
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: LD_INT 1
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 4
41841: PUSH
41842: LD_INT 1
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: LIST
41853: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41854: LD_ADDR_VAR 0 25
41858: PUSH
41859: LD_INT 3
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 4
41871: PUSH
41872: LD_INT 3
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 3
41881: PUSH
41882: LD_INT 4
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: LIST
41893: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41894: LD_ADDR_VAR 0 26
41898: PUSH
41899: LD_INT 0
41901: PUSH
41902: LD_INT 3
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 1
41911: PUSH
41912: LD_INT 4
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: NEG
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: LIST
41934: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41935: LD_ADDR_VAR 0 27
41939: PUSH
41940: LD_INT 3
41942: NEG
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 3
41953: NEG
41954: PUSH
41955: LD_INT 1
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 4
41964: NEG
41965: PUSH
41966: LD_INT 1
41968: NEG
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: LIST
41978: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41979: LD_ADDR_VAR 0 28
41983: PUSH
41984: LD_INT 3
41986: NEG
41987: PUSH
41988: LD_INT 3
41990: NEG
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 3
41998: NEG
41999: PUSH
42000: LD_INT 4
42002: NEG
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 4
42010: NEG
42011: PUSH
42012: LD_INT 3
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: LIST
42024: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42025: LD_ADDR_VAR 0 29
42029: PUSH
42030: LD_INT 1
42032: NEG
42033: PUSH
42034: LD_INT 3
42036: NEG
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: LD_INT 3
42047: NEG
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 1
42055: PUSH
42056: LD_INT 2
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: NEG
42067: PUSH
42068: LD_INT 4
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: LD_INT 4
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: LD_INT 3
42092: NEG
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 1
42100: NEG
42101: PUSH
42102: LD_INT 5
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 0
42112: PUSH
42113: LD_INT 5
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: LD_INT 4
42126: NEG
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 1
42134: NEG
42135: PUSH
42136: LD_INT 6
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 6
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 1
42157: PUSH
42158: LD_INT 5
42160: NEG
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42180: LD_ADDR_VAR 0 30
42184: PUSH
42185: LD_INT 2
42187: PUSH
42188: LD_INT 1
42190: NEG
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: LD_INT 0
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 3
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 3
42218: PUSH
42219: LD_INT 1
42221: NEG
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 4
42229: PUSH
42230: LD_INT 0
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 4
42239: PUSH
42240: LD_INT 1
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 4
42249: PUSH
42250: LD_INT 1
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 5
42260: PUSH
42261: LD_INT 0
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 5
42270: PUSH
42271: LD_INT 1
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 5
42280: PUSH
42281: LD_INT 1
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 6
42291: PUSH
42292: LD_INT 0
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 6
42301: PUSH
42302: LD_INT 1
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42323: LD_ADDR_VAR 0 31
42327: PUSH
42328: LD_INT 3
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 3
42340: PUSH
42341: LD_INT 3
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: LD_INT 2
42350: PUSH
42351: LD_INT 3
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 4
42360: PUSH
42361: LD_INT 3
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 4
42370: PUSH
42371: LD_INT 4
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 3
42380: PUSH
42381: LD_INT 4
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 5
42390: PUSH
42391: LD_INT 4
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 5
42400: PUSH
42401: LD_INT 5
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 4
42410: PUSH
42411: LD_INT 5
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 6
42420: PUSH
42421: LD_INT 5
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 6
42430: PUSH
42431: LD_INT 6
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: PUSH
42438: LD_INT 5
42440: PUSH
42441: LD_INT 6
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42462: LD_ADDR_VAR 0 32
42466: PUSH
42467: LD_INT 1
42469: PUSH
42470: LD_INT 3
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 0
42479: PUSH
42480: LD_INT 3
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 1
42489: NEG
42490: PUSH
42491: LD_INT 2
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 1
42500: PUSH
42501: LD_INT 4
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 0
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 1
42520: NEG
42521: PUSH
42522: LD_INT 3
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: LD_INT 5
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 0
42541: PUSH
42542: LD_INT 5
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 4
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 1
42562: PUSH
42563: LD_INT 6
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: LD_INT 6
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 1
42582: NEG
42583: PUSH
42584: LD_INT 5
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42605: LD_ADDR_VAR 0 33
42609: PUSH
42610: LD_INT 2
42612: NEG
42613: PUSH
42614: LD_INT 1
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 3
42623: NEG
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 3
42634: NEG
42635: PUSH
42636: LD_INT 1
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 3
42646: NEG
42647: PUSH
42648: LD_INT 1
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 4
42657: NEG
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 4
42668: NEG
42669: PUSH
42670: LD_INT 1
42672: NEG
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 4
42680: NEG
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 5
42691: NEG
42692: PUSH
42693: LD_INT 0
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 5
42702: NEG
42703: PUSH
42704: LD_INT 1
42706: NEG
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 5
42714: NEG
42715: PUSH
42716: LD_INT 1
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 6
42725: NEG
42726: PUSH
42727: LD_INT 0
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 6
42736: NEG
42737: PUSH
42738: LD_INT 1
42740: NEG
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42760: LD_ADDR_VAR 0 34
42764: PUSH
42765: LD_INT 2
42767: NEG
42768: PUSH
42769: LD_INT 3
42771: NEG
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 3
42779: NEG
42780: PUSH
42781: LD_INT 2
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 3
42791: NEG
42792: PUSH
42793: LD_INT 3
42795: NEG
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 3
42803: NEG
42804: PUSH
42805: LD_INT 4
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 4
42815: NEG
42816: PUSH
42817: LD_INT 3
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 4
42827: NEG
42828: PUSH
42829: LD_INT 4
42831: NEG
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 4
42839: NEG
42840: PUSH
42841: LD_INT 5
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 5
42851: NEG
42852: PUSH
42853: LD_INT 4
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 5
42863: NEG
42864: PUSH
42865: LD_INT 5
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 5
42875: NEG
42876: PUSH
42877: LD_INT 6
42879: NEG
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 6
42887: NEG
42888: PUSH
42889: LD_INT 5
42891: NEG
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 6
42899: NEG
42900: PUSH
42901: LD_INT 6
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: LIST
42916: LIST
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42923: LD_ADDR_VAR 0 41
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: LD_INT 2
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 1
42941: NEG
42942: PUSH
42943: LD_INT 3
42945: NEG
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 1
42953: PUSH
42954: LD_INT 2
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: LIST
42966: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42967: LD_ADDR_VAR 0 42
42971: PUSH
42972: LD_INT 2
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: PUSH
42982: LD_INT 2
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 3
42995: PUSH
42996: LD_INT 1
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43008: LD_ADDR_VAR 0 43
43012: PUSH
43013: LD_INT 2
43015: PUSH
43016: LD_INT 2
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 3
43025: PUSH
43026: LD_INT 2
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PUSH
43033: LD_INT 2
43035: PUSH
43036: LD_INT 3
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: LIST
43047: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43048: LD_ADDR_VAR 0 44
43052: PUSH
43053: LD_INT 0
43055: PUSH
43056: LD_INT 2
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 1
43065: PUSH
43066: LD_INT 3
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 1
43075: NEG
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: LIST
43088: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43089: LD_ADDR_VAR 0 45
43093: PUSH
43094: LD_INT 2
43096: NEG
43097: PUSH
43098: LD_INT 0
43100: PUSH
43101: EMPTY
43102: LIST
43103: LIST
43104: PUSH
43105: LD_INT 2
43107: NEG
43108: PUSH
43109: LD_INT 1
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 3
43118: NEG
43119: PUSH
43120: LD_INT 1
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: LIST
43132: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43133: LD_ADDR_VAR 0 46
43137: PUSH
43138: LD_INT 2
43140: NEG
43141: PUSH
43142: LD_INT 2
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 2
43152: NEG
43153: PUSH
43154: LD_INT 3
43156: NEG
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: PUSH
43162: LD_INT 3
43164: NEG
43165: PUSH
43166: LD_INT 2
43168: NEG
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43179: LD_ADDR_VAR 0 47
43183: PUSH
43184: LD_INT 2
43186: NEG
43187: PUSH
43188: LD_INT 3
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 3
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43212: LD_ADDR_VAR 0 48
43216: PUSH
43217: LD_INT 1
43219: PUSH
43220: LD_INT 2
43222: NEG
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 2
43230: PUSH
43231: LD_INT 1
43233: NEG
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43243: LD_ADDR_VAR 0 49
43247: PUSH
43248: LD_INT 3
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 3
43260: PUSH
43261: LD_INT 2
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43272: LD_ADDR_VAR 0 50
43276: PUSH
43277: LD_INT 2
43279: PUSH
43280: LD_INT 3
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: PUSH
43287: LD_INT 1
43289: PUSH
43290: LD_INT 3
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43301: LD_ADDR_VAR 0 51
43305: PUSH
43306: LD_INT 1
43308: NEG
43309: PUSH
43310: LD_INT 2
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: LD_INT 2
43319: NEG
43320: PUSH
43321: LD_INT 1
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43332: LD_ADDR_VAR 0 52
43336: PUSH
43337: LD_INT 3
43339: NEG
43340: PUSH
43341: LD_INT 1
43343: NEG
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 3
43351: NEG
43352: PUSH
43353: LD_INT 2
43355: NEG
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43365: LD_ADDR_VAR 0 53
43369: PUSH
43370: LD_INT 1
43372: NEG
43373: PUSH
43374: LD_INT 3
43376: NEG
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: LD_INT 0
43384: PUSH
43385: LD_INT 3
43387: NEG
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 1
43395: PUSH
43396: LD_INT 2
43398: NEG
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: LIST
43408: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43409: LD_ADDR_VAR 0 54
43413: PUSH
43414: LD_INT 2
43416: PUSH
43417: LD_INT 1
43419: NEG
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: LD_INT 3
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 3
43437: PUSH
43438: LD_INT 1
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: LIST
43449: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43450: LD_ADDR_VAR 0 55
43454: PUSH
43455: LD_INT 3
43457: PUSH
43458: LD_INT 2
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 3
43467: PUSH
43468: LD_INT 3
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 2
43477: PUSH
43478: LD_INT 3
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: LIST
43489: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43490: LD_ADDR_VAR 0 56
43494: PUSH
43495: LD_INT 1
43497: PUSH
43498: LD_INT 3
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 0
43507: PUSH
43508: LD_INT 3
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 1
43517: NEG
43518: PUSH
43519: LD_INT 2
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: LIST
43530: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43531: LD_ADDR_VAR 0 57
43535: PUSH
43536: LD_INT 2
43538: NEG
43539: PUSH
43540: LD_INT 1
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 3
43549: NEG
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 3
43560: NEG
43561: PUSH
43562: LD_INT 1
43564: NEG
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: LIST
43574: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43575: LD_ADDR_VAR 0 58
43579: PUSH
43580: LD_INT 2
43582: NEG
43583: PUSH
43584: LD_INT 3
43586: NEG
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 3
43594: NEG
43595: PUSH
43596: LD_INT 2
43598: NEG
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 3
43606: NEG
43607: PUSH
43608: LD_INT 3
43610: NEG
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: EMPTY
43617: LIST
43618: LIST
43619: LIST
43620: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43621: LD_ADDR_VAR 0 59
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: LD_INT 2
43632: NEG
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 0
43640: PUSH
43641: LD_INT 2
43643: NEG
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 1
43651: PUSH
43652: LD_INT 1
43654: NEG
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: LIST
43664: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43665: LD_ADDR_VAR 0 60
43669: PUSH
43670: LD_INT 1
43672: PUSH
43673: LD_INT 1
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 2
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: LIST
43705: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43706: LD_ADDR_VAR 0 61
43710: PUSH
43711: LD_INT 2
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 2
43723: PUSH
43724: LD_INT 2
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 1
43733: PUSH
43734: LD_INT 2
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: LIST
43745: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43746: LD_ADDR_VAR 0 62
43750: PUSH
43751: LD_INT 1
43753: PUSH
43754: LD_INT 2
43756: PUSH
43757: EMPTY
43758: LIST
43759: LIST
43760: PUSH
43761: LD_INT 0
43763: PUSH
43764: LD_INT 2
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 1
43773: NEG
43774: PUSH
43775: LD_INT 1
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: LIST
43786: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43787: LD_ADDR_VAR 0 63
43791: PUSH
43792: LD_INT 1
43794: NEG
43795: PUSH
43796: LD_INT 1
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 2
43805: NEG
43806: PUSH
43807: LD_INT 0
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: PUSH
43814: LD_INT 2
43816: NEG
43817: PUSH
43818: LD_INT 1
43820: NEG
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: EMPTY
43827: LIST
43828: LIST
43829: LIST
43830: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43831: LD_ADDR_VAR 0 64
43835: PUSH
43836: LD_INT 1
43838: NEG
43839: PUSH
43840: LD_INT 2
43842: NEG
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 2
43850: NEG
43851: PUSH
43852: LD_INT 1
43854: NEG
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: LD_INT 2
43862: NEG
43863: PUSH
43864: LD_INT 2
43866: NEG
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: LIST
43876: ST_TO_ADDR
// end ; 2 :
43877: GO 47143
43879: LD_INT 2
43881: DOUBLE
43882: EQUAL
43883: IFTRUE 43887
43885: GO 47142
43887: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43888: LD_ADDR_VAR 0 29
43892: PUSH
43893: LD_INT 4
43895: PUSH
43896: LD_INT 0
43898: PUSH
43899: EMPTY
43900: LIST
43901: LIST
43902: PUSH
43903: LD_INT 4
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 5
43916: PUSH
43917: LD_INT 0
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 5
43926: PUSH
43927: LD_INT 1
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 4
43936: PUSH
43937: LD_INT 1
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 3
43946: PUSH
43947: LD_INT 0
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 3
43956: PUSH
43957: LD_INT 1
43959: NEG
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 3
43967: PUSH
43968: LD_INT 2
43970: NEG
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 5
43978: PUSH
43979: LD_INT 2
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 3
43988: PUSH
43989: LD_INT 3
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 3
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 4
44008: PUSH
44009: LD_INT 3
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 4
44018: PUSH
44019: LD_INT 4
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 3
44028: PUSH
44029: LD_INT 4
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: PUSH
44049: LD_INT 2
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 4
44058: PUSH
44059: LD_INT 2
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 2
44068: PUSH
44069: LD_INT 4
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 0
44078: PUSH
44079: LD_INT 4
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 0
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 1
44098: PUSH
44099: LD_INT 4
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: LD_INT 5
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_INT 0
44118: PUSH
44119: LD_INT 5
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 1
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 1
44139: NEG
44140: PUSH
44141: LD_INT 3
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 2
44150: PUSH
44151: LD_INT 5
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: LD_INT 3
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 3
44171: NEG
44172: PUSH
44173: LD_INT 0
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 3
44182: NEG
44183: PUSH
44184: LD_INT 1
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: LD_INT 0
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: LD_INT 1
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 3
44216: NEG
44217: PUSH
44218: LD_INT 1
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 4
44227: NEG
44228: PUSH
44229: LD_INT 0
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 4
44238: NEG
44239: PUSH
44240: LD_INT 1
44242: NEG
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 4
44250: NEG
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 2
44262: NEG
44263: PUSH
44264: LD_INT 2
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 4
44273: NEG
44274: PUSH
44275: LD_INT 4
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 4
44285: NEG
44286: PUSH
44287: LD_INT 5
44289: NEG
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 3
44297: NEG
44298: PUSH
44299: LD_INT 4
44301: NEG
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 3
44309: NEG
44310: PUSH
44311: LD_INT 3
44313: NEG
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: LD_INT 4
44321: NEG
44322: PUSH
44323: LD_INT 3
44325: NEG
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PUSH
44331: LD_INT 5
44333: NEG
44334: PUSH
44335: LD_INT 4
44337: NEG
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 5
44345: NEG
44346: PUSH
44347: LD_INT 5
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 3
44357: NEG
44358: PUSH
44359: LD_INT 5
44361: NEG
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 5
44369: NEG
44370: PUSH
44371: LD_INT 3
44373: NEG
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44426: LD_ADDR_VAR 0 30
44430: PUSH
44431: LD_INT 4
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 4
44443: PUSH
44444: LD_INT 3
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 5
44453: PUSH
44454: LD_INT 4
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 5
44463: PUSH
44464: LD_INT 5
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 4
44473: PUSH
44474: LD_INT 5
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 3
44483: PUSH
44484: LD_INT 4
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 3
44493: PUSH
44494: LD_INT 3
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 5
44503: PUSH
44504: LD_INT 3
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: LD_INT 3
44513: PUSH
44514: LD_INT 5
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 0
44523: PUSH
44524: LD_INT 3
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 0
44533: PUSH
44534: LD_INT 2
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 1
44543: PUSH
44544: LD_INT 3
44546: PUSH
44547: EMPTY
44548: LIST
44549: LIST
44550: PUSH
44551: LD_INT 1
44553: PUSH
44554: LD_INT 4
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: PUSH
44561: LD_INT 0
44563: PUSH
44564: LD_INT 4
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 1
44573: NEG
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 1
44584: NEG
44585: PUSH
44586: LD_INT 2
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 2
44595: PUSH
44596: LD_INT 4
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 2
44605: NEG
44606: PUSH
44607: LD_INT 2
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 4
44616: NEG
44617: PUSH
44618: LD_INT 0
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 4
44627: NEG
44628: PUSH
44629: LD_INT 1
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 3
44639: NEG
44640: PUSH
44641: LD_INT 0
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 3
44650: NEG
44651: PUSH
44652: LD_INT 1
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 4
44661: NEG
44662: PUSH
44663: LD_INT 1
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 5
44672: NEG
44673: PUSH
44674: LD_INT 0
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: LD_INT 1
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 5
44695: NEG
44696: PUSH
44697: LD_INT 2
44699: NEG
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 3
44707: NEG
44708: PUSH
44709: LD_INT 2
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: PUSH
44716: LD_INT 3
44718: NEG
44719: PUSH
44720: LD_INT 3
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 3
44730: NEG
44731: PUSH
44732: LD_INT 4
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 2
44742: NEG
44743: PUSH
44744: LD_INT 3
44746: NEG
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 2
44754: NEG
44755: PUSH
44756: LD_INT 2
44758: NEG
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 3
44766: NEG
44767: PUSH
44768: LD_INT 2
44770: NEG
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 4
44778: NEG
44779: PUSH
44780: LD_INT 3
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 4
44790: NEG
44791: PUSH
44792: LD_INT 4
44794: NEG
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 2
44802: NEG
44803: PUSH
44804: LD_INT 4
44806: NEG
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 4
44814: NEG
44815: PUSH
44816: LD_INT 2
44818: NEG
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: PUSH
44824: LD_INT 0
44826: PUSH
44827: LD_INT 4
44829: NEG
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 0
44837: PUSH
44838: LD_INT 5
44840: NEG
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: PUSH
44846: LD_INT 1
44848: PUSH
44849: LD_INT 4
44851: NEG
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 1
44859: PUSH
44860: LD_INT 3
44862: NEG
44863: PUSH
44864: EMPTY
44865: LIST
44866: LIST
44867: PUSH
44868: LD_INT 0
44870: PUSH
44871: LD_INT 3
44873: NEG
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: PUSH
44879: LD_INT 1
44881: NEG
44882: PUSH
44883: LD_INT 4
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 1
44893: NEG
44894: PUSH
44895: LD_INT 5
44897: NEG
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: PUSH
44906: LD_INT 3
44908: NEG
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 2
44916: NEG
44917: PUSH
44918: LD_INT 5
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: LIST
44970: LIST
44971: LIST
44972: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44973: LD_ADDR_VAR 0 31
44977: PUSH
44978: LD_INT 0
44980: PUSH
44981: LD_INT 4
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 0
44990: PUSH
44991: LD_INT 3
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 1
45000: PUSH
45001: LD_INT 4
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: LD_INT 1
45010: PUSH
45011: LD_INT 5
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 0
45020: PUSH
45021: LD_INT 5
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 1
45030: NEG
45031: PUSH
45032: LD_INT 4
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 1
45041: NEG
45042: PUSH
45043: LD_INT 3
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 2
45052: PUSH
45053: LD_INT 5
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PUSH
45060: LD_INT 2
45062: NEG
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 3
45073: NEG
45074: PUSH
45075: LD_INT 0
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 3
45084: NEG
45085: PUSH
45086: LD_INT 1
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: LD_INT 0
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 2
45107: NEG
45108: PUSH
45109: LD_INT 1
45111: PUSH
45112: EMPTY
45113: LIST
45114: LIST
45115: PUSH
45116: LD_INT 3
45118: NEG
45119: PUSH
45120: LD_INT 1
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 4
45129: NEG
45130: PUSH
45131: LD_INT 0
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: LD_INT 1
45144: NEG
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 4
45152: NEG
45153: PUSH
45154: LD_INT 2
45156: NEG
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 2
45164: NEG
45165: PUSH
45166: LD_INT 2
45168: PUSH
45169: EMPTY
45170: LIST
45171: LIST
45172: PUSH
45173: LD_INT 4
45175: NEG
45176: PUSH
45177: LD_INT 4
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 4
45187: NEG
45188: PUSH
45189: LD_INT 5
45191: NEG
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 3
45199: NEG
45200: PUSH
45201: LD_INT 4
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 3
45211: NEG
45212: PUSH
45213: LD_INT 3
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 4
45223: NEG
45224: PUSH
45225: LD_INT 3
45227: NEG
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 5
45235: NEG
45236: PUSH
45237: LD_INT 4
45239: NEG
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: PUSH
45245: LD_INT 5
45247: NEG
45248: PUSH
45249: LD_INT 5
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 3
45259: NEG
45260: PUSH
45261: LD_INT 5
45263: NEG
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 5
45271: NEG
45272: PUSH
45273: LD_INT 3
45275: NEG
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 0
45283: PUSH
45284: LD_INT 3
45286: NEG
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 0
45294: PUSH
45295: LD_INT 4
45297: NEG
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 1
45305: PUSH
45306: LD_INT 3
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 1
45316: PUSH
45317: LD_INT 2
45319: NEG
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: PUSH
45325: LD_INT 0
45327: PUSH
45328: LD_INT 2
45330: NEG
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: PUSH
45340: LD_INT 3
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 1
45350: NEG
45351: PUSH
45352: LD_INT 4
45354: NEG
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 2
45362: PUSH
45363: LD_INT 2
45365: NEG
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 2
45373: NEG
45374: PUSH
45375: LD_INT 4
45377: NEG
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 4
45385: PUSH
45386: LD_INT 0
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PUSH
45393: LD_INT 4
45395: PUSH
45396: LD_INT 1
45398: NEG
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: LD_INT 0
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 5
45416: PUSH
45417: LD_INT 1
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 4
45426: PUSH
45427: LD_INT 1
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 3
45436: PUSH
45437: LD_INT 0
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 3
45446: PUSH
45447: LD_INT 1
45449: NEG
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: LD_INT 3
45457: PUSH
45458: LD_INT 2
45460: NEG
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 5
45468: PUSH
45469: LD_INT 2
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: LIST
45515: LIST
45516: LIST
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45523: LD_ADDR_VAR 0 32
45527: PUSH
45528: LD_INT 4
45530: NEG
45531: PUSH
45532: LD_INT 0
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: LD_INT 1
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 3
45553: NEG
45554: PUSH
45555: LD_INT 0
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 3
45564: NEG
45565: PUSH
45566: LD_INT 1
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: LD_INT 4
45575: NEG
45576: PUSH
45577: LD_INT 1
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: PUSH
45584: LD_INT 5
45586: NEG
45587: PUSH
45588: LD_INT 0
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 5
45597: NEG
45598: PUSH
45599: LD_INT 1
45601: NEG
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 5
45609: NEG
45610: PUSH
45611: LD_INT 2
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 3
45621: NEG
45622: PUSH
45623: LD_INT 2
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 3
45632: NEG
45633: PUSH
45634: LD_INT 3
45636: NEG
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: PUSH
45642: LD_INT 3
45644: NEG
45645: PUSH
45646: LD_INT 4
45648: NEG
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PUSH
45654: LD_INT 2
45656: NEG
45657: PUSH
45658: LD_INT 3
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: LD_INT 2
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: LD_INT 2
45684: NEG
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 4
45692: NEG
45693: PUSH
45694: LD_INT 3
45696: NEG
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: PUSH
45702: LD_INT 4
45704: NEG
45705: PUSH
45706: LD_INT 4
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 2
45716: NEG
45717: PUSH
45718: LD_INT 4
45720: NEG
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 4
45728: NEG
45729: PUSH
45730: LD_INT 2
45732: NEG
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 0
45740: PUSH
45741: LD_INT 4
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 0
45751: PUSH
45752: LD_INT 5
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 4
45765: NEG
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: PUSH
45771: LD_INT 1
45773: PUSH
45774: LD_INT 3
45776: NEG
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: LD_INT 3
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 1
45795: NEG
45796: PUSH
45797: LD_INT 4
45799: NEG
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 5
45811: NEG
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 3
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: NEG
45831: PUSH
45832: LD_INT 5
45834: NEG
45835: PUSH
45836: EMPTY
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 3
45842: PUSH
45843: LD_INT 0
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PUSH
45850: LD_INT 3
45852: PUSH
45853: LD_INT 1
45855: NEG
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 4
45863: PUSH
45864: LD_INT 0
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 4
45873: PUSH
45874: LD_INT 1
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 3
45883: PUSH
45884: LD_INT 1
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 2
45893: PUSH
45894: LD_INT 0
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: LD_INT 1
45906: NEG
45907: PUSH
45908: EMPTY
45909: LIST
45910: LIST
45911: PUSH
45912: LD_INT 2
45914: PUSH
45915: LD_INT 2
45917: NEG
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 4
45925: PUSH
45926: LD_INT 2
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 4
45935: PUSH
45936: LD_INT 4
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 4
45945: PUSH
45946: LD_INT 3
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 5
45955: PUSH
45956: LD_INT 4
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: PUSH
45963: LD_INT 5
45965: PUSH
45966: LD_INT 5
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: PUSH
45973: LD_INT 4
45975: PUSH
45976: LD_INT 5
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 3
45985: PUSH
45986: LD_INT 4
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: LD_INT 3
45998: PUSH
45999: EMPTY
46000: LIST
46001: LIST
46002: PUSH
46003: LD_INT 5
46005: PUSH
46006: LD_INT 3
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: PUSH
46016: LD_INT 5
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: LIST
46061: LIST
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46070: LD_ADDR_VAR 0 33
46074: PUSH
46075: LD_INT 4
46077: NEG
46078: PUSH
46079: LD_INT 4
46081: NEG
46082: PUSH
46083: EMPTY
46084: LIST
46085: LIST
46086: PUSH
46087: LD_INT 4
46089: NEG
46090: PUSH
46091: LD_INT 5
46093: NEG
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 3
46101: NEG
46102: PUSH
46103: LD_INT 4
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 3
46113: NEG
46114: PUSH
46115: LD_INT 3
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 4
46125: NEG
46126: PUSH
46127: LD_INT 3
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 5
46137: NEG
46138: PUSH
46139: LD_INT 4
46141: NEG
46142: PUSH
46143: EMPTY
46144: LIST
46145: LIST
46146: PUSH
46147: LD_INT 5
46149: NEG
46150: PUSH
46151: LD_INT 5
46153: NEG
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 3
46161: NEG
46162: PUSH
46163: LD_INT 5
46165: NEG
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: LD_INT 5
46173: NEG
46174: PUSH
46175: LD_INT 3
46177: NEG
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 0
46185: PUSH
46186: LD_INT 3
46188: NEG
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 0
46196: PUSH
46197: LD_INT 4
46199: NEG
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 3
46210: NEG
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 1
46218: PUSH
46219: LD_INT 2
46221: NEG
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: LD_INT 0
46229: PUSH
46230: LD_INT 2
46232: NEG
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 1
46240: NEG
46241: PUSH
46242: LD_INT 3
46244: NEG
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: PUSH
46250: LD_INT 1
46252: NEG
46253: PUSH
46254: LD_INT 4
46256: NEG
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 2
46264: PUSH
46265: LD_INT 2
46267: NEG
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 2
46275: NEG
46276: PUSH
46277: LD_INT 4
46279: NEG
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: LD_INT 4
46287: PUSH
46288: LD_INT 0
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PUSH
46295: LD_INT 4
46297: PUSH
46298: LD_INT 1
46300: NEG
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 5
46308: PUSH
46309: LD_INT 0
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 5
46318: PUSH
46319: LD_INT 1
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 4
46328: PUSH
46329: LD_INT 1
46331: PUSH
46332: EMPTY
46333: LIST
46334: LIST
46335: PUSH
46336: LD_INT 3
46338: PUSH
46339: LD_INT 0
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: LD_INT 3
46348: PUSH
46349: LD_INT 1
46351: NEG
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PUSH
46357: LD_INT 3
46359: PUSH
46360: LD_INT 2
46362: NEG
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 5
46370: PUSH
46371: LD_INT 2
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 3
46380: PUSH
46381: LD_INT 3
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: LD_INT 2
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 4
46400: PUSH
46401: LD_INT 3
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 4
46410: PUSH
46411: LD_INT 4
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 3
46420: PUSH
46421: LD_INT 4
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 2
46430: PUSH
46431: LD_INT 3
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 2
46440: PUSH
46441: LD_INT 2
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 4
46450: PUSH
46451: LD_INT 2
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 2
46460: PUSH
46461: LD_INT 4
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 0
46470: PUSH
46471: LD_INT 4
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 0
46480: PUSH
46481: LD_INT 3
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 1
46490: PUSH
46491: LD_INT 4
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 1
46500: PUSH
46501: LD_INT 5
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 0
46510: PUSH
46511: LD_INT 5
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 1
46520: NEG
46521: PUSH
46522: LD_INT 4
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: LD_INT 1
46531: NEG
46532: PUSH
46533: LD_INT 3
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 2
46542: PUSH
46543: LD_INT 5
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: PUSH
46550: LD_INT 2
46552: NEG
46553: PUSH
46554: LD_INT 3
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46608: LD_ADDR_VAR 0 34
46612: PUSH
46613: LD_INT 0
46615: PUSH
46616: LD_INT 4
46618: NEG
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: LD_INT 0
46626: PUSH
46627: LD_INT 5
46629: NEG
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: PUSH
46635: LD_INT 1
46637: PUSH
46638: LD_INT 4
46640: NEG
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: LD_INT 1
46648: PUSH
46649: LD_INT 3
46651: NEG
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: LD_INT 3
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 1
46670: NEG
46671: PUSH
46672: LD_INT 4
46674: NEG
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 1
46682: NEG
46683: PUSH
46684: LD_INT 5
46686: NEG
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_INT 2
46694: PUSH
46695: LD_INT 3
46697: NEG
46698: PUSH
46699: EMPTY
46700: LIST
46701: LIST
46702: PUSH
46703: LD_INT 2
46705: NEG
46706: PUSH
46707: LD_INT 5
46709: NEG
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: PUSH
46715: LD_INT 3
46717: PUSH
46718: LD_INT 0
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: PUSH
46725: LD_INT 3
46727: PUSH
46728: LD_INT 1
46730: NEG
46731: PUSH
46732: EMPTY
46733: LIST
46734: LIST
46735: PUSH
46736: LD_INT 4
46738: PUSH
46739: LD_INT 0
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 4
46748: PUSH
46749: LD_INT 1
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 3
46758: PUSH
46759: LD_INT 1
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: LD_INT 2
46768: PUSH
46769: LD_INT 0
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 2
46778: PUSH
46779: LD_INT 1
46781: NEG
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_INT 2
46789: PUSH
46790: LD_INT 2
46792: NEG
46793: PUSH
46794: EMPTY
46795: LIST
46796: LIST
46797: PUSH
46798: LD_INT 4
46800: PUSH
46801: LD_INT 2
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 4
46810: PUSH
46811: LD_INT 4
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: PUSH
46818: LD_INT 4
46820: PUSH
46821: LD_INT 3
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 5
46830: PUSH
46831: LD_INT 4
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: PUSH
46838: LD_INT 5
46840: PUSH
46841: LD_INT 5
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: PUSH
46848: LD_INT 4
46850: PUSH
46851: LD_INT 5
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 3
46860: PUSH
46861: LD_INT 4
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 3
46870: PUSH
46871: LD_INT 3
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_INT 5
46880: PUSH
46881: LD_INT 3
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: PUSH
46888: LD_INT 3
46890: PUSH
46891: LD_INT 5
46893: PUSH
46894: EMPTY
46895: LIST
46896: LIST
46897: PUSH
46898: LD_INT 0
46900: PUSH
46901: LD_INT 3
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: PUSH
46908: LD_INT 0
46910: PUSH
46911: LD_INT 2
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 1
46920: PUSH
46921: LD_INT 3
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: LD_INT 1
46930: PUSH
46931: LD_INT 4
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PUSH
46938: LD_INT 0
46940: PUSH
46941: LD_INT 4
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: LD_INT 1
46950: NEG
46951: PUSH
46952: LD_INT 3
46954: PUSH
46955: EMPTY
46956: LIST
46957: LIST
46958: PUSH
46959: LD_INT 1
46961: NEG
46962: PUSH
46963: LD_INT 2
46965: PUSH
46966: EMPTY
46967: LIST
46968: LIST
46969: PUSH
46970: LD_INT 2
46972: PUSH
46973: LD_INT 4
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: LD_INT 2
46982: NEG
46983: PUSH
46984: LD_INT 2
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: PUSH
46991: LD_INT 4
46993: NEG
46994: PUSH
46995: LD_INT 0
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: LD_INT 4
47004: NEG
47005: PUSH
47006: LD_INT 1
47008: NEG
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 3
47016: NEG
47017: PUSH
47018: LD_INT 0
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: LD_INT 3
47027: NEG
47028: PUSH
47029: LD_INT 1
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: LD_INT 4
47038: NEG
47039: PUSH
47040: LD_INT 1
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: PUSH
47047: LD_INT 5
47049: NEG
47050: PUSH
47051: LD_INT 0
47053: PUSH
47054: EMPTY
47055: LIST
47056: LIST
47057: PUSH
47058: LD_INT 5
47060: NEG
47061: PUSH
47062: LD_INT 1
47064: NEG
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: PUSH
47070: LD_INT 5
47072: NEG
47073: PUSH
47074: LD_INT 2
47076: NEG
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PUSH
47082: LD_INT 3
47084: NEG
47085: PUSH
47086: LD_INT 2
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: LIST
47133: LIST
47134: LIST
47135: LIST
47136: LIST
47137: LIST
47138: LIST
47139: ST_TO_ADDR
// end ; end ;
47140: GO 47143
47142: POP
// case btype of b_depot , b_warehouse :
47143: LD_VAR 0 1
47147: PUSH
47148: LD_INT 0
47150: DOUBLE
47151: EQUAL
47152: IFTRUE 47162
47154: LD_INT 1
47156: DOUBLE
47157: EQUAL
47158: IFTRUE 47162
47160: GO 47363
47162: POP
// case nation of nation_american :
47163: LD_VAR 0 5
47167: PUSH
47168: LD_INT 1
47170: DOUBLE
47171: EQUAL
47172: IFTRUE 47176
47174: GO 47232
47176: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47177: LD_ADDR_VAR 0 9
47181: PUSH
47182: LD_VAR 0 11
47186: PUSH
47187: LD_VAR 0 12
47191: PUSH
47192: LD_VAR 0 13
47196: PUSH
47197: LD_VAR 0 14
47201: PUSH
47202: LD_VAR 0 15
47206: PUSH
47207: LD_VAR 0 16
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: PUSH
47220: LD_VAR 0 4
47224: PUSH
47225: LD_INT 1
47227: PLUS
47228: ARRAY
47229: ST_TO_ADDR
47230: GO 47361
47232: LD_INT 2
47234: DOUBLE
47235: EQUAL
47236: IFTRUE 47240
47238: GO 47296
47240: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47241: LD_ADDR_VAR 0 9
47245: PUSH
47246: LD_VAR 0 17
47250: PUSH
47251: LD_VAR 0 18
47255: PUSH
47256: LD_VAR 0 19
47260: PUSH
47261: LD_VAR 0 20
47265: PUSH
47266: LD_VAR 0 21
47270: PUSH
47271: LD_VAR 0 22
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: PUSH
47284: LD_VAR 0 4
47288: PUSH
47289: LD_INT 1
47291: PLUS
47292: ARRAY
47293: ST_TO_ADDR
47294: GO 47361
47296: LD_INT 3
47298: DOUBLE
47299: EQUAL
47300: IFTRUE 47304
47302: GO 47360
47304: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47305: LD_ADDR_VAR 0 9
47309: PUSH
47310: LD_VAR 0 23
47314: PUSH
47315: LD_VAR 0 24
47319: PUSH
47320: LD_VAR 0 25
47324: PUSH
47325: LD_VAR 0 26
47329: PUSH
47330: LD_VAR 0 27
47334: PUSH
47335: LD_VAR 0 28
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: PUSH
47348: LD_VAR 0 4
47352: PUSH
47353: LD_INT 1
47355: PLUS
47356: ARRAY
47357: ST_TO_ADDR
47358: GO 47361
47360: POP
47361: GO 47916
47363: LD_INT 2
47365: DOUBLE
47366: EQUAL
47367: IFTRUE 47377
47369: LD_INT 3
47371: DOUBLE
47372: EQUAL
47373: IFTRUE 47377
47375: GO 47433
47377: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47378: LD_ADDR_VAR 0 9
47382: PUSH
47383: LD_VAR 0 29
47387: PUSH
47388: LD_VAR 0 30
47392: PUSH
47393: LD_VAR 0 31
47397: PUSH
47398: LD_VAR 0 32
47402: PUSH
47403: LD_VAR 0 33
47407: PUSH
47408: LD_VAR 0 34
47412: PUSH
47413: EMPTY
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: PUSH
47421: LD_VAR 0 4
47425: PUSH
47426: LD_INT 1
47428: PLUS
47429: ARRAY
47430: ST_TO_ADDR
47431: GO 47916
47433: LD_INT 16
47435: DOUBLE
47436: EQUAL
47437: IFTRUE 47495
47439: LD_INT 17
47441: DOUBLE
47442: EQUAL
47443: IFTRUE 47495
47445: LD_INT 18
47447: DOUBLE
47448: EQUAL
47449: IFTRUE 47495
47451: LD_INT 19
47453: DOUBLE
47454: EQUAL
47455: IFTRUE 47495
47457: LD_INT 22
47459: DOUBLE
47460: EQUAL
47461: IFTRUE 47495
47463: LD_INT 20
47465: DOUBLE
47466: EQUAL
47467: IFTRUE 47495
47469: LD_INT 21
47471: DOUBLE
47472: EQUAL
47473: IFTRUE 47495
47475: LD_INT 23
47477: DOUBLE
47478: EQUAL
47479: IFTRUE 47495
47481: LD_INT 24
47483: DOUBLE
47484: EQUAL
47485: IFTRUE 47495
47487: LD_INT 25
47489: DOUBLE
47490: EQUAL
47491: IFTRUE 47495
47493: GO 47551
47495: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47496: LD_ADDR_VAR 0 9
47500: PUSH
47501: LD_VAR 0 35
47505: PUSH
47506: LD_VAR 0 36
47510: PUSH
47511: LD_VAR 0 37
47515: PUSH
47516: LD_VAR 0 38
47520: PUSH
47521: LD_VAR 0 39
47525: PUSH
47526: LD_VAR 0 40
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: LIST
47538: PUSH
47539: LD_VAR 0 4
47543: PUSH
47544: LD_INT 1
47546: PLUS
47547: ARRAY
47548: ST_TO_ADDR
47549: GO 47916
47551: LD_INT 6
47553: DOUBLE
47554: EQUAL
47555: IFTRUE 47607
47557: LD_INT 7
47559: DOUBLE
47560: EQUAL
47561: IFTRUE 47607
47563: LD_INT 8
47565: DOUBLE
47566: EQUAL
47567: IFTRUE 47607
47569: LD_INT 13
47571: DOUBLE
47572: EQUAL
47573: IFTRUE 47607
47575: LD_INT 12
47577: DOUBLE
47578: EQUAL
47579: IFTRUE 47607
47581: LD_INT 15
47583: DOUBLE
47584: EQUAL
47585: IFTRUE 47607
47587: LD_INT 11
47589: DOUBLE
47590: EQUAL
47591: IFTRUE 47607
47593: LD_INT 14
47595: DOUBLE
47596: EQUAL
47597: IFTRUE 47607
47599: LD_INT 10
47601: DOUBLE
47602: EQUAL
47603: IFTRUE 47607
47605: GO 47663
47607: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47608: LD_ADDR_VAR 0 9
47612: PUSH
47613: LD_VAR 0 41
47617: PUSH
47618: LD_VAR 0 42
47622: PUSH
47623: LD_VAR 0 43
47627: PUSH
47628: LD_VAR 0 44
47632: PUSH
47633: LD_VAR 0 45
47637: PUSH
47638: LD_VAR 0 46
47642: PUSH
47643: EMPTY
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: PUSH
47651: LD_VAR 0 4
47655: PUSH
47656: LD_INT 1
47658: PLUS
47659: ARRAY
47660: ST_TO_ADDR
47661: GO 47916
47663: LD_INT 36
47665: DOUBLE
47666: EQUAL
47667: IFTRUE 47671
47669: GO 47727
47671: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47672: LD_ADDR_VAR 0 9
47676: PUSH
47677: LD_VAR 0 47
47681: PUSH
47682: LD_VAR 0 48
47686: PUSH
47687: LD_VAR 0 49
47691: PUSH
47692: LD_VAR 0 50
47696: PUSH
47697: LD_VAR 0 51
47701: PUSH
47702: LD_VAR 0 52
47706: PUSH
47707: EMPTY
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: PUSH
47715: LD_VAR 0 4
47719: PUSH
47720: LD_INT 1
47722: PLUS
47723: ARRAY
47724: ST_TO_ADDR
47725: GO 47916
47727: LD_INT 4
47729: DOUBLE
47730: EQUAL
47731: IFTRUE 47753
47733: LD_INT 5
47735: DOUBLE
47736: EQUAL
47737: IFTRUE 47753
47739: LD_INT 34
47741: DOUBLE
47742: EQUAL
47743: IFTRUE 47753
47745: LD_INT 37
47747: DOUBLE
47748: EQUAL
47749: IFTRUE 47753
47751: GO 47809
47753: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47754: LD_ADDR_VAR 0 9
47758: PUSH
47759: LD_VAR 0 53
47763: PUSH
47764: LD_VAR 0 54
47768: PUSH
47769: LD_VAR 0 55
47773: PUSH
47774: LD_VAR 0 56
47778: PUSH
47779: LD_VAR 0 57
47783: PUSH
47784: LD_VAR 0 58
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: PUSH
47797: LD_VAR 0 4
47801: PUSH
47802: LD_INT 1
47804: PLUS
47805: ARRAY
47806: ST_TO_ADDR
47807: GO 47916
47809: LD_INT 31
47811: DOUBLE
47812: EQUAL
47813: IFTRUE 47859
47815: LD_INT 32
47817: DOUBLE
47818: EQUAL
47819: IFTRUE 47859
47821: LD_INT 33
47823: DOUBLE
47824: EQUAL
47825: IFTRUE 47859
47827: LD_INT 27
47829: DOUBLE
47830: EQUAL
47831: IFTRUE 47859
47833: LD_INT 26
47835: DOUBLE
47836: EQUAL
47837: IFTRUE 47859
47839: LD_INT 28
47841: DOUBLE
47842: EQUAL
47843: IFTRUE 47859
47845: LD_INT 29
47847: DOUBLE
47848: EQUAL
47849: IFTRUE 47859
47851: LD_INT 30
47853: DOUBLE
47854: EQUAL
47855: IFTRUE 47859
47857: GO 47915
47859: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47860: LD_ADDR_VAR 0 9
47864: PUSH
47865: LD_VAR 0 59
47869: PUSH
47870: LD_VAR 0 60
47874: PUSH
47875: LD_VAR 0 61
47879: PUSH
47880: LD_VAR 0 62
47884: PUSH
47885: LD_VAR 0 63
47889: PUSH
47890: LD_VAR 0 64
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: PUSH
47903: LD_VAR 0 4
47907: PUSH
47908: LD_INT 1
47910: PLUS
47911: ARRAY
47912: ST_TO_ADDR
47913: GO 47916
47915: POP
// temp_list2 = [ ] ;
47916: LD_ADDR_VAR 0 10
47920: PUSH
47921: EMPTY
47922: ST_TO_ADDR
// for i in temp_list do
47923: LD_ADDR_VAR 0 8
47927: PUSH
47928: LD_VAR 0 9
47932: PUSH
47933: FOR_IN
47934: IFFALSE 47986
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47936: LD_ADDR_VAR 0 10
47940: PUSH
47941: LD_VAR 0 10
47945: PUSH
47946: LD_VAR 0 8
47950: PUSH
47951: LD_INT 1
47953: ARRAY
47954: PUSH
47955: LD_VAR 0 2
47959: PLUS
47960: PUSH
47961: LD_VAR 0 8
47965: PUSH
47966: LD_INT 2
47968: ARRAY
47969: PUSH
47970: LD_VAR 0 3
47974: PLUS
47975: PUSH
47976: EMPTY
47977: LIST
47978: LIST
47979: PUSH
47980: EMPTY
47981: LIST
47982: ADD
47983: ST_TO_ADDR
47984: GO 47933
47986: POP
47987: POP
// result = temp_list2 ;
47988: LD_ADDR_VAR 0 7
47992: PUSH
47993: LD_VAR 0 10
47997: ST_TO_ADDR
// end ;
47998: LD_VAR 0 7
48002: RET
// export function EnemyInRange ( unit , dist ) ; begin
48003: LD_INT 0
48005: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48006: LD_ADDR_VAR 0 3
48010: PUSH
48011: LD_VAR 0 1
48015: PPUSH
48016: CALL_OW 255
48020: PPUSH
48021: LD_VAR 0 1
48025: PPUSH
48026: CALL_OW 250
48030: PPUSH
48031: LD_VAR 0 1
48035: PPUSH
48036: CALL_OW 251
48040: PPUSH
48041: LD_VAR 0 2
48045: PPUSH
48046: CALL 22107 0 4
48050: PUSH
48051: LD_INT 4
48053: ARRAY
48054: ST_TO_ADDR
// end ;
48055: LD_VAR 0 3
48059: RET
// export function PlayerSeeMe ( unit ) ; begin
48060: LD_INT 0
48062: PPUSH
// result := See ( your_side , unit ) ;
48063: LD_ADDR_VAR 0 2
48067: PUSH
48068: LD_OWVAR 2
48072: PPUSH
48073: LD_VAR 0 1
48077: PPUSH
48078: CALL_OW 292
48082: ST_TO_ADDR
// end ;
48083: LD_VAR 0 2
48087: RET
// export function ReverseDir ( unit ) ; begin
48088: LD_INT 0
48090: PPUSH
// if not unit then
48091: LD_VAR 0 1
48095: NOT
48096: IFFALSE 48100
// exit ;
48098: GO 48146
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48100: LD_ADDR_VAR 0 2
48104: PUSH
48105: LD_INT 3
48107: PUSH
48108: LD_INT 4
48110: PUSH
48111: LD_INT 5
48113: PUSH
48114: LD_INT 0
48116: PUSH
48117: LD_INT 1
48119: PUSH
48120: LD_INT 2
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: PUSH
48131: LD_VAR 0 1
48135: PPUSH
48136: CALL_OW 254
48140: PUSH
48141: LD_INT 1
48143: PLUS
48144: ARRAY
48145: ST_TO_ADDR
// end ;
48146: LD_VAR 0 2
48150: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48151: LD_INT 0
48153: PPUSH
48154: PPUSH
48155: PPUSH
48156: PPUSH
48157: PPUSH
// if not hexes then
48158: LD_VAR 0 2
48162: NOT
48163: IFFALSE 48167
// exit ;
48165: GO 48315
// dist := 9999 ;
48167: LD_ADDR_VAR 0 5
48171: PUSH
48172: LD_INT 9999
48174: ST_TO_ADDR
// for i = 1 to hexes do
48175: LD_ADDR_VAR 0 4
48179: PUSH
48180: DOUBLE
48181: LD_INT 1
48183: DEC
48184: ST_TO_ADDR
48185: LD_VAR 0 2
48189: PUSH
48190: FOR_TO
48191: IFFALSE 48303
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48193: LD_VAR 0 1
48197: PPUSH
48198: LD_VAR 0 2
48202: PUSH
48203: LD_VAR 0 4
48207: ARRAY
48208: PUSH
48209: LD_INT 1
48211: ARRAY
48212: PPUSH
48213: LD_VAR 0 2
48217: PUSH
48218: LD_VAR 0 4
48222: ARRAY
48223: PUSH
48224: LD_INT 2
48226: ARRAY
48227: PPUSH
48228: CALL_OW 297
48232: PUSH
48233: LD_VAR 0 5
48237: LESS
48238: IFFALSE 48301
// begin hex := hexes [ i ] ;
48240: LD_ADDR_VAR 0 7
48244: PUSH
48245: LD_VAR 0 2
48249: PUSH
48250: LD_VAR 0 4
48254: ARRAY
48255: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48256: LD_ADDR_VAR 0 5
48260: PUSH
48261: LD_VAR 0 1
48265: PPUSH
48266: LD_VAR 0 2
48270: PUSH
48271: LD_VAR 0 4
48275: ARRAY
48276: PUSH
48277: LD_INT 1
48279: ARRAY
48280: PPUSH
48281: LD_VAR 0 2
48285: PUSH
48286: LD_VAR 0 4
48290: ARRAY
48291: PUSH
48292: LD_INT 2
48294: ARRAY
48295: PPUSH
48296: CALL_OW 297
48300: ST_TO_ADDR
// end ; end ;
48301: GO 48190
48303: POP
48304: POP
// result := hex ;
48305: LD_ADDR_VAR 0 3
48309: PUSH
48310: LD_VAR 0 7
48314: ST_TO_ADDR
// end ;
48315: LD_VAR 0 3
48319: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48320: LD_INT 0
48322: PPUSH
48323: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48324: LD_VAR 0 1
48328: NOT
48329: PUSH
48330: LD_VAR 0 1
48334: PUSH
48335: LD_INT 21
48337: PUSH
48338: LD_INT 2
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PUSH
48345: LD_INT 23
48347: PUSH
48348: LD_INT 2
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PUSH
48355: EMPTY
48356: LIST
48357: LIST
48358: PPUSH
48359: CALL_OW 69
48363: IN
48364: NOT
48365: OR
48366: IFFALSE 48370
// exit ;
48368: GO 48417
// for i = 1 to 3 do
48370: LD_ADDR_VAR 0 3
48374: PUSH
48375: DOUBLE
48376: LD_INT 1
48378: DEC
48379: ST_TO_ADDR
48380: LD_INT 3
48382: PUSH
48383: FOR_TO
48384: IFFALSE 48415
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48386: LD_VAR 0 1
48390: PPUSH
48391: CALL_OW 250
48395: PPUSH
48396: LD_VAR 0 1
48400: PPUSH
48401: CALL_OW 251
48405: PPUSH
48406: LD_INT 1
48408: PPUSH
48409: CALL_OW 453
48413: GO 48383
48415: POP
48416: POP
// end ;
48417: LD_VAR 0 2
48421: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48422: LD_INT 0
48424: PPUSH
48425: PPUSH
48426: PPUSH
48427: PPUSH
48428: PPUSH
48429: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48430: LD_VAR 0 1
48434: NOT
48435: PUSH
48436: LD_VAR 0 2
48440: NOT
48441: OR
48442: PUSH
48443: LD_VAR 0 1
48447: PPUSH
48448: CALL_OW 314
48452: OR
48453: IFFALSE 48457
// exit ;
48455: GO 48898
// x := GetX ( enemy_unit ) ;
48457: LD_ADDR_VAR 0 7
48461: PUSH
48462: LD_VAR 0 2
48466: PPUSH
48467: CALL_OW 250
48471: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48472: LD_ADDR_VAR 0 8
48476: PUSH
48477: LD_VAR 0 2
48481: PPUSH
48482: CALL_OW 251
48486: ST_TO_ADDR
// if not x or not y then
48487: LD_VAR 0 7
48491: NOT
48492: PUSH
48493: LD_VAR 0 8
48497: NOT
48498: OR
48499: IFFALSE 48503
// exit ;
48501: GO 48898
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48503: LD_ADDR_VAR 0 6
48507: PUSH
48508: LD_VAR 0 7
48512: PPUSH
48513: LD_INT 0
48515: PPUSH
48516: LD_INT 4
48518: PPUSH
48519: CALL_OW 272
48523: PUSH
48524: LD_VAR 0 8
48528: PPUSH
48529: LD_INT 0
48531: PPUSH
48532: LD_INT 4
48534: PPUSH
48535: CALL_OW 273
48539: PUSH
48540: EMPTY
48541: LIST
48542: LIST
48543: PUSH
48544: LD_VAR 0 7
48548: PPUSH
48549: LD_INT 1
48551: PPUSH
48552: LD_INT 4
48554: PPUSH
48555: CALL_OW 272
48559: PUSH
48560: LD_VAR 0 8
48564: PPUSH
48565: LD_INT 1
48567: PPUSH
48568: LD_INT 4
48570: PPUSH
48571: CALL_OW 273
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_VAR 0 7
48584: PPUSH
48585: LD_INT 2
48587: PPUSH
48588: LD_INT 4
48590: PPUSH
48591: CALL_OW 272
48595: PUSH
48596: LD_VAR 0 8
48600: PPUSH
48601: LD_INT 2
48603: PPUSH
48604: LD_INT 4
48606: PPUSH
48607: CALL_OW 273
48611: PUSH
48612: EMPTY
48613: LIST
48614: LIST
48615: PUSH
48616: LD_VAR 0 7
48620: PPUSH
48621: LD_INT 3
48623: PPUSH
48624: LD_INT 4
48626: PPUSH
48627: CALL_OW 272
48631: PUSH
48632: LD_VAR 0 8
48636: PPUSH
48637: LD_INT 3
48639: PPUSH
48640: LD_INT 4
48642: PPUSH
48643: CALL_OW 273
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_VAR 0 7
48656: PPUSH
48657: LD_INT 4
48659: PPUSH
48660: LD_INT 4
48662: PPUSH
48663: CALL_OW 272
48667: PUSH
48668: LD_VAR 0 8
48672: PPUSH
48673: LD_INT 4
48675: PPUSH
48676: LD_INT 4
48678: PPUSH
48679: CALL_OW 273
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PUSH
48688: LD_VAR 0 7
48692: PPUSH
48693: LD_INT 5
48695: PPUSH
48696: LD_INT 4
48698: PPUSH
48699: CALL_OW 272
48703: PUSH
48704: LD_VAR 0 8
48708: PPUSH
48709: LD_INT 5
48711: PPUSH
48712: LD_INT 4
48714: PPUSH
48715: CALL_OW 273
48719: PUSH
48720: EMPTY
48721: LIST
48722: LIST
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: LIST
48728: LIST
48729: LIST
48730: LIST
48731: ST_TO_ADDR
// for i = tmp downto 1 do
48732: LD_ADDR_VAR 0 4
48736: PUSH
48737: DOUBLE
48738: LD_VAR 0 6
48742: INC
48743: ST_TO_ADDR
48744: LD_INT 1
48746: PUSH
48747: FOR_DOWNTO
48748: IFFALSE 48849
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48750: LD_VAR 0 6
48754: PUSH
48755: LD_VAR 0 4
48759: ARRAY
48760: PUSH
48761: LD_INT 1
48763: ARRAY
48764: PPUSH
48765: LD_VAR 0 6
48769: PUSH
48770: LD_VAR 0 4
48774: ARRAY
48775: PUSH
48776: LD_INT 2
48778: ARRAY
48779: PPUSH
48780: CALL_OW 488
48784: NOT
48785: PUSH
48786: LD_VAR 0 6
48790: PUSH
48791: LD_VAR 0 4
48795: ARRAY
48796: PUSH
48797: LD_INT 1
48799: ARRAY
48800: PPUSH
48801: LD_VAR 0 6
48805: PUSH
48806: LD_VAR 0 4
48810: ARRAY
48811: PUSH
48812: LD_INT 2
48814: ARRAY
48815: PPUSH
48816: CALL_OW 428
48820: PUSH
48821: LD_INT 0
48823: NONEQUAL
48824: OR
48825: IFFALSE 48847
// tmp := Delete ( tmp , i ) ;
48827: LD_ADDR_VAR 0 6
48831: PUSH
48832: LD_VAR 0 6
48836: PPUSH
48837: LD_VAR 0 4
48841: PPUSH
48842: CALL_OW 3
48846: ST_TO_ADDR
48847: GO 48747
48849: POP
48850: POP
// j := GetClosestHex ( unit , tmp ) ;
48851: LD_ADDR_VAR 0 5
48855: PUSH
48856: LD_VAR 0 1
48860: PPUSH
48861: LD_VAR 0 6
48865: PPUSH
48866: CALL 48151 0 2
48870: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48871: LD_VAR 0 1
48875: PPUSH
48876: LD_VAR 0 5
48880: PUSH
48881: LD_INT 1
48883: ARRAY
48884: PPUSH
48885: LD_VAR 0 5
48889: PUSH
48890: LD_INT 2
48892: ARRAY
48893: PPUSH
48894: CALL_OW 111
// end ;
48898: LD_VAR 0 3
48902: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48903: LD_INT 0
48905: PPUSH
48906: PPUSH
48907: PPUSH
// uc_side = 0 ;
48908: LD_ADDR_OWVAR 20
48912: PUSH
48913: LD_INT 0
48915: ST_TO_ADDR
// uc_nation = 0 ;
48916: LD_ADDR_OWVAR 21
48920: PUSH
48921: LD_INT 0
48923: ST_TO_ADDR
// InitHc ;
48924: CALL_OW 19
// InitVc ;
48928: CALL_OW 20
// if mastodonts then
48932: LD_VAR 0 6
48936: IFFALSE 49003
// for i = 1 to mastodonts do
48938: LD_ADDR_VAR 0 11
48942: PUSH
48943: DOUBLE
48944: LD_INT 1
48946: DEC
48947: ST_TO_ADDR
48948: LD_VAR 0 6
48952: PUSH
48953: FOR_TO
48954: IFFALSE 49001
// begin vc_chassis := 31 ;
48956: LD_ADDR_OWVAR 37
48960: PUSH
48961: LD_INT 31
48963: ST_TO_ADDR
// vc_control := control_rider ;
48964: LD_ADDR_OWVAR 38
48968: PUSH
48969: LD_INT 4
48971: ST_TO_ADDR
// animal := CreateVehicle ;
48972: LD_ADDR_VAR 0 12
48976: PUSH
48977: CALL_OW 45
48981: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48982: LD_VAR 0 12
48986: PPUSH
48987: LD_VAR 0 8
48991: PPUSH
48992: LD_INT 0
48994: PPUSH
48995: CALL 55748 0 3
// end ;
48999: GO 48953
49001: POP
49002: POP
// if horses then
49003: LD_VAR 0 5
49007: IFFALSE 49074
// for i = 1 to horses do
49009: LD_ADDR_VAR 0 11
49013: PUSH
49014: DOUBLE
49015: LD_INT 1
49017: DEC
49018: ST_TO_ADDR
49019: LD_VAR 0 5
49023: PUSH
49024: FOR_TO
49025: IFFALSE 49072
// begin hc_class := 21 ;
49027: LD_ADDR_OWVAR 28
49031: PUSH
49032: LD_INT 21
49034: ST_TO_ADDR
// hc_gallery :=  ;
49035: LD_ADDR_OWVAR 33
49039: PUSH
49040: LD_STRING 
49042: ST_TO_ADDR
// animal := CreateHuman ;
49043: LD_ADDR_VAR 0 12
49047: PUSH
49048: CALL_OW 44
49052: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49053: LD_VAR 0 12
49057: PPUSH
49058: LD_VAR 0 8
49062: PPUSH
49063: LD_INT 0
49065: PPUSH
49066: CALL 55748 0 3
// end ;
49070: GO 49024
49072: POP
49073: POP
// if birds then
49074: LD_VAR 0 1
49078: IFFALSE 49145
// for i = 1 to birds do
49080: LD_ADDR_VAR 0 11
49084: PUSH
49085: DOUBLE
49086: LD_INT 1
49088: DEC
49089: ST_TO_ADDR
49090: LD_VAR 0 1
49094: PUSH
49095: FOR_TO
49096: IFFALSE 49143
// begin hc_class = 18 ;
49098: LD_ADDR_OWVAR 28
49102: PUSH
49103: LD_INT 18
49105: ST_TO_ADDR
// hc_gallery =  ;
49106: LD_ADDR_OWVAR 33
49110: PUSH
49111: LD_STRING 
49113: ST_TO_ADDR
// animal := CreateHuman ;
49114: LD_ADDR_VAR 0 12
49118: PUSH
49119: CALL_OW 44
49123: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49124: LD_VAR 0 12
49128: PPUSH
49129: LD_VAR 0 8
49133: PPUSH
49134: LD_INT 0
49136: PPUSH
49137: CALL 55748 0 3
// end ;
49141: GO 49095
49143: POP
49144: POP
// if tigers then
49145: LD_VAR 0 2
49149: IFFALSE 49233
// for i = 1 to tigers do
49151: LD_ADDR_VAR 0 11
49155: PUSH
49156: DOUBLE
49157: LD_INT 1
49159: DEC
49160: ST_TO_ADDR
49161: LD_VAR 0 2
49165: PUSH
49166: FOR_TO
49167: IFFALSE 49231
// begin hc_class = class_tiger ;
49169: LD_ADDR_OWVAR 28
49173: PUSH
49174: LD_INT 14
49176: ST_TO_ADDR
// hc_gallery =  ;
49177: LD_ADDR_OWVAR 33
49181: PUSH
49182: LD_STRING 
49184: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49185: LD_ADDR_OWVAR 35
49189: PUSH
49190: LD_INT 7
49192: NEG
49193: PPUSH
49194: LD_INT 7
49196: PPUSH
49197: CALL_OW 12
49201: ST_TO_ADDR
// animal := CreateHuman ;
49202: LD_ADDR_VAR 0 12
49206: PUSH
49207: CALL_OW 44
49211: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49212: LD_VAR 0 12
49216: PPUSH
49217: LD_VAR 0 8
49221: PPUSH
49222: LD_INT 0
49224: PPUSH
49225: CALL 55748 0 3
// end ;
49229: GO 49166
49231: POP
49232: POP
// if apemans then
49233: LD_VAR 0 3
49237: IFFALSE 49360
// for i = 1 to apemans do
49239: LD_ADDR_VAR 0 11
49243: PUSH
49244: DOUBLE
49245: LD_INT 1
49247: DEC
49248: ST_TO_ADDR
49249: LD_VAR 0 3
49253: PUSH
49254: FOR_TO
49255: IFFALSE 49358
// begin hc_class = class_apeman ;
49257: LD_ADDR_OWVAR 28
49261: PUSH
49262: LD_INT 12
49264: ST_TO_ADDR
// hc_gallery =  ;
49265: LD_ADDR_OWVAR 33
49269: PUSH
49270: LD_STRING 
49272: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49273: LD_ADDR_OWVAR 35
49277: PUSH
49278: LD_INT 5
49280: NEG
49281: PPUSH
49282: LD_INT 5
49284: PPUSH
49285: CALL_OW 12
49289: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49290: LD_ADDR_OWVAR 31
49294: PUSH
49295: LD_INT 1
49297: PPUSH
49298: LD_INT 3
49300: PPUSH
49301: CALL_OW 12
49305: PUSH
49306: LD_INT 1
49308: PPUSH
49309: LD_INT 3
49311: PPUSH
49312: CALL_OW 12
49316: PUSH
49317: LD_INT 0
49319: PUSH
49320: LD_INT 0
49322: PUSH
49323: EMPTY
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: ST_TO_ADDR
// animal := CreateHuman ;
49329: LD_ADDR_VAR 0 12
49333: PUSH
49334: CALL_OW 44
49338: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49339: LD_VAR 0 12
49343: PPUSH
49344: LD_VAR 0 8
49348: PPUSH
49349: LD_INT 0
49351: PPUSH
49352: CALL 55748 0 3
// end ;
49356: GO 49254
49358: POP
49359: POP
// if enchidnas then
49360: LD_VAR 0 4
49364: IFFALSE 49431
// for i = 1 to enchidnas do
49366: LD_ADDR_VAR 0 11
49370: PUSH
49371: DOUBLE
49372: LD_INT 1
49374: DEC
49375: ST_TO_ADDR
49376: LD_VAR 0 4
49380: PUSH
49381: FOR_TO
49382: IFFALSE 49429
// begin hc_class = 13 ;
49384: LD_ADDR_OWVAR 28
49388: PUSH
49389: LD_INT 13
49391: ST_TO_ADDR
// hc_gallery =  ;
49392: LD_ADDR_OWVAR 33
49396: PUSH
49397: LD_STRING 
49399: ST_TO_ADDR
// animal := CreateHuman ;
49400: LD_ADDR_VAR 0 12
49404: PUSH
49405: CALL_OW 44
49409: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49410: LD_VAR 0 12
49414: PPUSH
49415: LD_VAR 0 8
49419: PPUSH
49420: LD_INT 0
49422: PPUSH
49423: CALL 55748 0 3
// end ;
49427: GO 49381
49429: POP
49430: POP
// if fishes then
49431: LD_VAR 0 7
49435: IFFALSE 49502
// for i = 1 to fishes do
49437: LD_ADDR_VAR 0 11
49441: PUSH
49442: DOUBLE
49443: LD_INT 1
49445: DEC
49446: ST_TO_ADDR
49447: LD_VAR 0 7
49451: PUSH
49452: FOR_TO
49453: IFFALSE 49500
// begin hc_class = 20 ;
49455: LD_ADDR_OWVAR 28
49459: PUSH
49460: LD_INT 20
49462: ST_TO_ADDR
// hc_gallery =  ;
49463: LD_ADDR_OWVAR 33
49467: PUSH
49468: LD_STRING 
49470: ST_TO_ADDR
// animal := CreateHuman ;
49471: LD_ADDR_VAR 0 12
49475: PUSH
49476: CALL_OW 44
49480: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49481: LD_VAR 0 12
49485: PPUSH
49486: LD_VAR 0 9
49490: PPUSH
49491: LD_INT 0
49493: PPUSH
49494: CALL 55748 0 3
// end ;
49498: GO 49452
49500: POP
49501: POP
// end ;
49502: LD_VAR 0 10
49506: RET
// export function WantHeal ( sci , unit ) ; begin
49507: LD_INT 0
49509: PPUSH
// if GetTaskList ( sci ) > 0 then
49510: LD_VAR 0 1
49514: PPUSH
49515: CALL_OW 437
49519: PUSH
49520: LD_INT 0
49522: GREATER
49523: IFFALSE 49593
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49525: LD_VAR 0 1
49529: PPUSH
49530: CALL_OW 437
49534: PUSH
49535: LD_INT 1
49537: ARRAY
49538: PUSH
49539: LD_INT 1
49541: ARRAY
49542: PUSH
49543: LD_STRING l
49545: EQUAL
49546: PUSH
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 437
49556: PUSH
49557: LD_INT 1
49559: ARRAY
49560: PUSH
49561: LD_INT 4
49563: ARRAY
49564: PUSH
49565: LD_VAR 0 2
49569: EQUAL
49570: AND
49571: IFFALSE 49583
// result := true else
49573: LD_ADDR_VAR 0 3
49577: PUSH
49578: LD_INT 1
49580: ST_TO_ADDR
49581: GO 49591
// result := false ;
49583: LD_ADDR_VAR 0 3
49587: PUSH
49588: LD_INT 0
49590: ST_TO_ADDR
// end else
49591: GO 49601
// result := false ;
49593: LD_ADDR_VAR 0 3
49597: PUSH
49598: LD_INT 0
49600: ST_TO_ADDR
// end ;
49601: LD_VAR 0 3
49605: RET
// export function HealTarget ( sci ) ; begin
49606: LD_INT 0
49608: PPUSH
// if not sci then
49609: LD_VAR 0 1
49613: NOT
49614: IFFALSE 49618
// exit ;
49616: GO 49683
// result := 0 ;
49618: LD_ADDR_VAR 0 2
49622: PUSH
49623: LD_INT 0
49625: ST_TO_ADDR
// if GetTaskList ( sci ) then
49626: LD_VAR 0 1
49630: PPUSH
49631: CALL_OW 437
49635: IFFALSE 49683
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49637: LD_VAR 0 1
49641: PPUSH
49642: CALL_OW 437
49646: PUSH
49647: LD_INT 1
49649: ARRAY
49650: PUSH
49651: LD_INT 1
49653: ARRAY
49654: PUSH
49655: LD_STRING l
49657: EQUAL
49658: IFFALSE 49683
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49660: LD_ADDR_VAR 0 2
49664: PUSH
49665: LD_VAR 0 1
49669: PPUSH
49670: CALL_OW 437
49674: PUSH
49675: LD_INT 1
49677: ARRAY
49678: PUSH
49679: LD_INT 4
49681: ARRAY
49682: ST_TO_ADDR
// end ;
49683: LD_VAR 0 2
49687: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49688: LD_INT 0
49690: PPUSH
49691: PPUSH
49692: PPUSH
49693: PPUSH
49694: PPUSH
49695: PPUSH
49696: PPUSH
49697: PPUSH
49698: PPUSH
49699: PPUSH
49700: PPUSH
49701: PPUSH
49702: PPUSH
49703: PPUSH
49704: PPUSH
49705: PPUSH
49706: PPUSH
49707: PPUSH
49708: PPUSH
49709: PPUSH
49710: PPUSH
49711: PPUSH
49712: PPUSH
49713: PPUSH
49714: PPUSH
49715: PPUSH
49716: PPUSH
49717: PPUSH
49718: PPUSH
49719: PPUSH
49720: PPUSH
49721: PPUSH
49722: PPUSH
49723: PPUSH
// if not list then
49724: LD_VAR 0 1
49728: NOT
49729: IFFALSE 49733
// exit ;
49731: GO 54359
// base := list [ 1 ] ;
49733: LD_ADDR_VAR 0 3
49737: PUSH
49738: LD_VAR 0 1
49742: PUSH
49743: LD_INT 1
49745: ARRAY
49746: ST_TO_ADDR
// group := list [ 2 ] ;
49747: LD_ADDR_VAR 0 4
49751: PUSH
49752: LD_VAR 0 1
49756: PUSH
49757: LD_INT 2
49759: ARRAY
49760: ST_TO_ADDR
// path := list [ 3 ] ;
49761: LD_ADDR_VAR 0 5
49765: PUSH
49766: LD_VAR 0 1
49770: PUSH
49771: LD_INT 3
49773: ARRAY
49774: ST_TO_ADDR
// flags := list [ 4 ] ;
49775: LD_ADDR_VAR 0 6
49779: PUSH
49780: LD_VAR 0 1
49784: PUSH
49785: LD_INT 4
49787: ARRAY
49788: ST_TO_ADDR
// mined := [ ] ;
49789: LD_ADDR_VAR 0 27
49793: PUSH
49794: EMPTY
49795: ST_TO_ADDR
// bombed := [ ] ;
49796: LD_ADDR_VAR 0 28
49800: PUSH
49801: EMPTY
49802: ST_TO_ADDR
// healers := [ ] ;
49803: LD_ADDR_VAR 0 31
49807: PUSH
49808: EMPTY
49809: ST_TO_ADDR
// to_heal := [ ] ;
49810: LD_ADDR_VAR 0 30
49814: PUSH
49815: EMPTY
49816: ST_TO_ADDR
// repairs := [ ] ;
49817: LD_ADDR_VAR 0 33
49821: PUSH
49822: EMPTY
49823: ST_TO_ADDR
// to_repair := [ ] ;
49824: LD_ADDR_VAR 0 32
49828: PUSH
49829: EMPTY
49830: ST_TO_ADDR
// if not group or not path then
49831: LD_VAR 0 4
49835: NOT
49836: PUSH
49837: LD_VAR 0 5
49841: NOT
49842: OR
49843: IFFALSE 49847
// exit ;
49845: GO 54359
// side := GetSide ( group [ 1 ] ) ;
49847: LD_ADDR_VAR 0 35
49851: PUSH
49852: LD_VAR 0 4
49856: PUSH
49857: LD_INT 1
49859: ARRAY
49860: PPUSH
49861: CALL_OW 255
49865: ST_TO_ADDR
// if flags then
49866: LD_VAR 0 6
49870: IFFALSE 50014
// begin f_ignore_area := flags [ 1 ] ;
49872: LD_ADDR_VAR 0 17
49876: PUSH
49877: LD_VAR 0 6
49881: PUSH
49882: LD_INT 1
49884: ARRAY
49885: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49886: LD_ADDR_VAR 0 18
49890: PUSH
49891: LD_VAR 0 6
49895: PUSH
49896: LD_INT 2
49898: ARRAY
49899: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49900: LD_ADDR_VAR 0 19
49904: PUSH
49905: LD_VAR 0 6
49909: PUSH
49910: LD_INT 3
49912: ARRAY
49913: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49914: LD_ADDR_VAR 0 20
49918: PUSH
49919: LD_VAR 0 6
49923: PUSH
49924: LD_INT 4
49926: ARRAY
49927: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49928: LD_ADDR_VAR 0 21
49932: PUSH
49933: LD_VAR 0 6
49937: PUSH
49938: LD_INT 5
49940: ARRAY
49941: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49942: LD_ADDR_VAR 0 22
49946: PUSH
49947: LD_VAR 0 6
49951: PUSH
49952: LD_INT 6
49954: ARRAY
49955: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49956: LD_ADDR_VAR 0 23
49960: PUSH
49961: LD_VAR 0 6
49965: PUSH
49966: LD_INT 7
49968: ARRAY
49969: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49970: LD_ADDR_VAR 0 24
49974: PUSH
49975: LD_VAR 0 6
49979: PUSH
49980: LD_INT 8
49982: ARRAY
49983: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49984: LD_ADDR_VAR 0 25
49988: PUSH
49989: LD_VAR 0 6
49993: PUSH
49994: LD_INT 9
49996: ARRAY
49997: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49998: LD_ADDR_VAR 0 26
50002: PUSH
50003: LD_VAR 0 6
50007: PUSH
50008: LD_INT 10
50010: ARRAY
50011: ST_TO_ADDR
// end else
50012: GO 50094
// begin f_ignore_area := false ;
50014: LD_ADDR_VAR 0 17
50018: PUSH
50019: LD_INT 0
50021: ST_TO_ADDR
// f_capture := false ;
50022: LD_ADDR_VAR 0 18
50026: PUSH
50027: LD_INT 0
50029: ST_TO_ADDR
// f_ignore_civ := false ;
50030: LD_ADDR_VAR 0 19
50034: PUSH
50035: LD_INT 0
50037: ST_TO_ADDR
// f_murder := false ;
50038: LD_ADDR_VAR 0 20
50042: PUSH
50043: LD_INT 0
50045: ST_TO_ADDR
// f_mines := false ;
50046: LD_ADDR_VAR 0 21
50050: PUSH
50051: LD_INT 0
50053: ST_TO_ADDR
// f_repair := false ;
50054: LD_ADDR_VAR 0 22
50058: PUSH
50059: LD_INT 0
50061: ST_TO_ADDR
// f_heal := false ;
50062: LD_ADDR_VAR 0 23
50066: PUSH
50067: LD_INT 0
50069: ST_TO_ADDR
// f_spacetime := false ;
50070: LD_ADDR_VAR 0 24
50074: PUSH
50075: LD_INT 0
50077: ST_TO_ADDR
// f_attack_depot := false ;
50078: LD_ADDR_VAR 0 25
50082: PUSH
50083: LD_INT 0
50085: ST_TO_ADDR
// f_crawl := false ;
50086: LD_ADDR_VAR 0 26
50090: PUSH
50091: LD_INT 0
50093: ST_TO_ADDR
// end ; if f_heal then
50094: LD_VAR 0 23
50098: IFFALSE 50125
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50100: LD_ADDR_VAR 0 31
50104: PUSH
50105: LD_VAR 0 4
50109: PPUSH
50110: LD_INT 25
50112: PUSH
50113: LD_INT 4
50115: PUSH
50116: EMPTY
50117: LIST
50118: LIST
50119: PPUSH
50120: CALL_OW 72
50124: ST_TO_ADDR
// if f_repair then
50125: LD_VAR 0 22
50129: IFFALSE 50156
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50131: LD_ADDR_VAR 0 33
50135: PUSH
50136: LD_VAR 0 4
50140: PPUSH
50141: LD_INT 25
50143: PUSH
50144: LD_INT 3
50146: PUSH
50147: EMPTY
50148: LIST
50149: LIST
50150: PPUSH
50151: CALL_OW 72
50155: ST_TO_ADDR
// units_path := [ ] ;
50156: LD_ADDR_VAR 0 16
50160: PUSH
50161: EMPTY
50162: ST_TO_ADDR
// for i = 1 to group do
50163: LD_ADDR_VAR 0 7
50167: PUSH
50168: DOUBLE
50169: LD_INT 1
50171: DEC
50172: ST_TO_ADDR
50173: LD_VAR 0 4
50177: PUSH
50178: FOR_TO
50179: IFFALSE 50208
// units_path := Replace ( units_path , i , path ) ;
50181: LD_ADDR_VAR 0 16
50185: PUSH
50186: LD_VAR 0 16
50190: PPUSH
50191: LD_VAR 0 7
50195: PPUSH
50196: LD_VAR 0 5
50200: PPUSH
50201: CALL_OW 1
50205: ST_TO_ADDR
50206: GO 50178
50208: POP
50209: POP
// repeat for i = group downto 1 do
50210: LD_ADDR_VAR 0 7
50214: PUSH
50215: DOUBLE
50216: LD_VAR 0 4
50220: INC
50221: ST_TO_ADDR
50222: LD_INT 1
50224: PUSH
50225: FOR_DOWNTO
50226: IFFALSE 54322
// begin wait ( 5 ) ;
50228: LD_INT 5
50230: PPUSH
50231: CALL_OW 67
// tmp := [ ] ;
50235: LD_ADDR_VAR 0 14
50239: PUSH
50240: EMPTY
50241: ST_TO_ADDR
// attacking := false ;
50242: LD_ADDR_VAR 0 29
50246: PUSH
50247: LD_INT 0
50249: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50250: LD_VAR 0 4
50254: PUSH
50255: LD_VAR 0 7
50259: ARRAY
50260: PPUSH
50261: CALL_OW 301
50265: PUSH
50266: LD_VAR 0 4
50270: PUSH
50271: LD_VAR 0 7
50275: ARRAY
50276: NOT
50277: OR
50278: IFFALSE 50387
// begin if GetType ( group [ i ] ) = unit_human then
50280: LD_VAR 0 4
50284: PUSH
50285: LD_VAR 0 7
50289: ARRAY
50290: PPUSH
50291: CALL_OW 247
50295: PUSH
50296: LD_INT 1
50298: EQUAL
50299: IFFALSE 50345
// begin to_heal := to_heal diff group [ i ] ;
50301: LD_ADDR_VAR 0 30
50305: PUSH
50306: LD_VAR 0 30
50310: PUSH
50311: LD_VAR 0 4
50315: PUSH
50316: LD_VAR 0 7
50320: ARRAY
50321: DIFF
50322: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50323: LD_ADDR_VAR 0 31
50327: PUSH
50328: LD_VAR 0 31
50332: PUSH
50333: LD_VAR 0 4
50337: PUSH
50338: LD_VAR 0 7
50342: ARRAY
50343: DIFF
50344: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50345: LD_ADDR_VAR 0 4
50349: PUSH
50350: LD_VAR 0 4
50354: PPUSH
50355: LD_VAR 0 7
50359: PPUSH
50360: CALL_OW 3
50364: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50365: LD_ADDR_VAR 0 16
50369: PUSH
50370: LD_VAR 0 16
50374: PPUSH
50375: LD_VAR 0 7
50379: PPUSH
50380: CALL_OW 3
50384: ST_TO_ADDR
// continue ;
50385: GO 50225
// end ; if f_repair then
50387: LD_VAR 0 22
50391: IFFALSE 50880
// begin if GetType ( group [ i ] ) = unit_vehicle then
50393: LD_VAR 0 4
50397: PUSH
50398: LD_VAR 0 7
50402: ARRAY
50403: PPUSH
50404: CALL_OW 247
50408: PUSH
50409: LD_INT 2
50411: EQUAL
50412: IFFALSE 50602
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50414: LD_VAR 0 4
50418: PUSH
50419: LD_VAR 0 7
50423: ARRAY
50424: PPUSH
50425: CALL_OW 256
50429: PUSH
50430: LD_INT 700
50432: LESS
50433: PUSH
50434: LD_VAR 0 4
50438: PUSH
50439: LD_VAR 0 7
50443: ARRAY
50444: PUSH
50445: LD_VAR 0 32
50449: IN
50450: NOT
50451: AND
50452: IFFALSE 50476
// to_repair := to_repair union group [ i ] ;
50454: LD_ADDR_VAR 0 32
50458: PUSH
50459: LD_VAR 0 32
50463: PUSH
50464: LD_VAR 0 4
50468: PUSH
50469: LD_VAR 0 7
50473: ARRAY
50474: UNION
50475: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50476: LD_VAR 0 4
50480: PUSH
50481: LD_VAR 0 7
50485: ARRAY
50486: PPUSH
50487: CALL_OW 256
50491: PUSH
50492: LD_INT 1000
50494: EQUAL
50495: PUSH
50496: LD_VAR 0 4
50500: PUSH
50501: LD_VAR 0 7
50505: ARRAY
50506: PUSH
50507: LD_VAR 0 32
50511: IN
50512: AND
50513: IFFALSE 50537
// to_repair := to_repair diff group [ i ] ;
50515: LD_ADDR_VAR 0 32
50519: PUSH
50520: LD_VAR 0 32
50524: PUSH
50525: LD_VAR 0 4
50529: PUSH
50530: LD_VAR 0 7
50534: ARRAY
50535: DIFF
50536: ST_TO_ADDR
// if group [ i ] in to_repair then
50537: LD_VAR 0 4
50541: PUSH
50542: LD_VAR 0 7
50546: ARRAY
50547: PUSH
50548: LD_VAR 0 32
50552: IN
50553: IFFALSE 50600
// begin if not IsInArea ( group [ i ] , f_repair ) then
50555: LD_VAR 0 4
50559: PUSH
50560: LD_VAR 0 7
50564: ARRAY
50565: PPUSH
50566: LD_VAR 0 22
50570: PPUSH
50571: CALL_OW 308
50575: NOT
50576: IFFALSE 50598
// ComMoveToArea ( group [ i ] , f_repair ) ;
50578: LD_VAR 0 4
50582: PUSH
50583: LD_VAR 0 7
50587: ARRAY
50588: PPUSH
50589: LD_VAR 0 22
50593: PPUSH
50594: CALL_OW 113
// continue ;
50598: GO 50225
// end ; end else
50600: GO 50880
// if group [ i ] in repairs then
50602: LD_VAR 0 4
50606: PUSH
50607: LD_VAR 0 7
50611: ARRAY
50612: PUSH
50613: LD_VAR 0 33
50617: IN
50618: IFFALSE 50880
// begin if IsInUnit ( group [ i ] ) then
50620: LD_VAR 0 4
50624: PUSH
50625: LD_VAR 0 7
50629: ARRAY
50630: PPUSH
50631: CALL_OW 310
50635: IFFALSE 50703
// begin z := IsInUnit ( group [ i ] ) ;
50637: LD_ADDR_VAR 0 13
50641: PUSH
50642: LD_VAR 0 4
50646: PUSH
50647: LD_VAR 0 7
50651: ARRAY
50652: PPUSH
50653: CALL_OW 310
50657: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50658: LD_VAR 0 13
50662: PUSH
50663: LD_VAR 0 32
50667: IN
50668: PUSH
50669: LD_VAR 0 13
50673: PPUSH
50674: LD_VAR 0 22
50678: PPUSH
50679: CALL_OW 308
50683: AND
50684: IFFALSE 50701
// ComExitVehicle ( group [ i ] ) ;
50686: LD_VAR 0 4
50690: PUSH
50691: LD_VAR 0 7
50695: ARRAY
50696: PPUSH
50697: CALL_OW 121
// end else
50701: GO 50880
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50703: LD_ADDR_VAR 0 13
50707: PUSH
50708: LD_VAR 0 4
50712: PPUSH
50713: LD_INT 95
50715: PUSH
50716: LD_VAR 0 22
50720: PUSH
50721: EMPTY
50722: LIST
50723: LIST
50724: PUSH
50725: LD_INT 58
50727: PUSH
50728: EMPTY
50729: LIST
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: PPUSH
50735: CALL_OW 72
50739: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50740: LD_VAR 0 4
50744: PUSH
50745: LD_VAR 0 7
50749: ARRAY
50750: PPUSH
50751: CALL_OW 314
50755: NOT
50756: IFFALSE 50878
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50758: LD_ADDR_VAR 0 10
50762: PUSH
50763: LD_VAR 0 13
50767: PPUSH
50768: LD_VAR 0 4
50772: PUSH
50773: LD_VAR 0 7
50777: ARRAY
50778: PPUSH
50779: CALL_OW 74
50783: ST_TO_ADDR
// if not x then
50784: LD_VAR 0 10
50788: NOT
50789: IFFALSE 50793
// continue ;
50791: GO 50225
// if GetLives ( x ) < 1000 then
50793: LD_VAR 0 10
50797: PPUSH
50798: CALL_OW 256
50802: PUSH
50803: LD_INT 1000
50805: LESS
50806: IFFALSE 50830
// ComRepairVehicle ( group [ i ] , x ) else
50808: LD_VAR 0 4
50812: PUSH
50813: LD_VAR 0 7
50817: ARRAY
50818: PPUSH
50819: LD_VAR 0 10
50823: PPUSH
50824: CALL_OW 129
50828: GO 50878
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50830: LD_VAR 0 23
50834: PUSH
50835: LD_VAR 0 4
50839: PUSH
50840: LD_VAR 0 7
50844: ARRAY
50845: PPUSH
50846: CALL_OW 256
50850: PUSH
50851: LD_INT 1000
50853: LESS
50854: AND
50855: NOT
50856: IFFALSE 50878
// ComEnterUnit ( group [ i ] , x ) ;
50858: LD_VAR 0 4
50862: PUSH
50863: LD_VAR 0 7
50867: ARRAY
50868: PPUSH
50869: LD_VAR 0 10
50873: PPUSH
50874: CALL_OW 120
// end ; continue ;
50878: GO 50225
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50880: LD_VAR 0 23
50884: PUSH
50885: LD_VAR 0 4
50889: PUSH
50890: LD_VAR 0 7
50894: ARRAY
50895: PPUSH
50896: CALL_OW 247
50900: PUSH
50901: LD_INT 1
50903: EQUAL
50904: AND
50905: IFFALSE 51383
// begin if group [ i ] in healers then
50907: LD_VAR 0 4
50911: PUSH
50912: LD_VAR 0 7
50916: ARRAY
50917: PUSH
50918: LD_VAR 0 31
50922: IN
50923: IFFALSE 51196
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50925: LD_VAR 0 4
50929: PUSH
50930: LD_VAR 0 7
50934: ARRAY
50935: PPUSH
50936: LD_VAR 0 23
50940: PPUSH
50941: CALL_OW 308
50945: NOT
50946: PUSH
50947: LD_VAR 0 4
50951: PUSH
50952: LD_VAR 0 7
50956: ARRAY
50957: PPUSH
50958: CALL_OW 314
50962: NOT
50963: AND
50964: IFFALSE 50988
// ComMoveToArea ( group [ i ] , f_heal ) else
50966: LD_VAR 0 4
50970: PUSH
50971: LD_VAR 0 7
50975: ARRAY
50976: PPUSH
50977: LD_VAR 0 23
50981: PPUSH
50982: CALL_OW 113
50986: GO 51194
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50988: LD_VAR 0 4
50992: PUSH
50993: LD_VAR 0 7
50997: ARRAY
50998: PPUSH
50999: CALL 49606 0 1
51003: PPUSH
51004: CALL_OW 256
51008: PUSH
51009: LD_INT 1000
51011: EQUAL
51012: IFFALSE 51031
// ComStop ( group [ i ] ) else
51014: LD_VAR 0 4
51018: PUSH
51019: LD_VAR 0 7
51023: ARRAY
51024: PPUSH
51025: CALL_OW 141
51029: GO 51194
// if not HasTask ( group [ i ] ) and to_heal then
51031: LD_VAR 0 4
51035: PUSH
51036: LD_VAR 0 7
51040: ARRAY
51041: PPUSH
51042: CALL_OW 314
51046: NOT
51047: PUSH
51048: LD_VAR 0 30
51052: AND
51053: IFFALSE 51194
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51055: LD_ADDR_VAR 0 13
51059: PUSH
51060: LD_VAR 0 30
51064: PPUSH
51065: LD_INT 3
51067: PUSH
51068: LD_INT 54
51070: PUSH
51071: EMPTY
51072: LIST
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: PPUSH
51078: CALL_OW 72
51082: PPUSH
51083: LD_VAR 0 4
51087: PUSH
51088: LD_VAR 0 7
51092: ARRAY
51093: PPUSH
51094: CALL_OW 74
51098: ST_TO_ADDR
// if z then
51099: LD_VAR 0 13
51103: IFFALSE 51194
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51105: LD_INT 91
51107: PUSH
51108: LD_VAR 0 13
51112: PUSH
51113: LD_INT 10
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: LIST
51120: PUSH
51121: LD_INT 81
51123: PUSH
51124: LD_VAR 0 13
51128: PPUSH
51129: CALL_OW 255
51133: PUSH
51134: EMPTY
51135: LIST
51136: LIST
51137: PUSH
51138: EMPTY
51139: LIST
51140: LIST
51141: PPUSH
51142: CALL_OW 69
51146: PUSH
51147: LD_INT 0
51149: EQUAL
51150: IFFALSE 51174
// ComHeal ( group [ i ] , z ) else
51152: LD_VAR 0 4
51156: PUSH
51157: LD_VAR 0 7
51161: ARRAY
51162: PPUSH
51163: LD_VAR 0 13
51167: PPUSH
51168: CALL_OW 128
51172: GO 51194
// ComMoveToArea ( group [ i ] , f_heal ) ;
51174: LD_VAR 0 4
51178: PUSH
51179: LD_VAR 0 7
51183: ARRAY
51184: PPUSH
51185: LD_VAR 0 23
51189: PPUSH
51190: CALL_OW 113
// end ; continue ;
51194: GO 50225
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51196: LD_VAR 0 4
51200: PUSH
51201: LD_VAR 0 7
51205: ARRAY
51206: PPUSH
51207: CALL_OW 256
51211: PUSH
51212: LD_INT 700
51214: LESS
51215: PUSH
51216: LD_VAR 0 4
51220: PUSH
51221: LD_VAR 0 7
51225: ARRAY
51226: PUSH
51227: LD_VAR 0 30
51231: IN
51232: NOT
51233: AND
51234: IFFALSE 51258
// to_heal := to_heal union group [ i ] ;
51236: LD_ADDR_VAR 0 30
51240: PUSH
51241: LD_VAR 0 30
51245: PUSH
51246: LD_VAR 0 4
51250: PUSH
51251: LD_VAR 0 7
51255: ARRAY
51256: UNION
51257: ST_TO_ADDR
// if group [ i ] in to_heal then
51258: LD_VAR 0 4
51262: PUSH
51263: LD_VAR 0 7
51267: ARRAY
51268: PUSH
51269: LD_VAR 0 30
51273: IN
51274: IFFALSE 51383
// begin if GetLives ( group [ i ] ) = 1000 then
51276: LD_VAR 0 4
51280: PUSH
51281: LD_VAR 0 7
51285: ARRAY
51286: PPUSH
51287: CALL_OW 256
51291: PUSH
51292: LD_INT 1000
51294: EQUAL
51295: IFFALSE 51321
// to_heal := to_heal diff group [ i ] else
51297: LD_ADDR_VAR 0 30
51301: PUSH
51302: LD_VAR 0 30
51306: PUSH
51307: LD_VAR 0 4
51311: PUSH
51312: LD_VAR 0 7
51316: ARRAY
51317: DIFF
51318: ST_TO_ADDR
51319: GO 51383
// begin if not IsInArea ( group [ i ] , to_heal ) then
51321: LD_VAR 0 4
51325: PUSH
51326: LD_VAR 0 7
51330: ARRAY
51331: PPUSH
51332: LD_VAR 0 30
51336: PPUSH
51337: CALL_OW 308
51341: NOT
51342: IFFALSE 51366
// ComMoveToArea ( group [ i ] , f_heal ) else
51344: LD_VAR 0 4
51348: PUSH
51349: LD_VAR 0 7
51353: ARRAY
51354: PPUSH
51355: LD_VAR 0 23
51359: PPUSH
51360: CALL_OW 113
51364: GO 51381
// ComHold ( group [ i ] ) ;
51366: LD_VAR 0 4
51370: PUSH
51371: LD_VAR 0 7
51375: ARRAY
51376: PPUSH
51377: CALL_OW 140
// continue ;
51381: GO 50225
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51383: LD_VAR 0 4
51387: PUSH
51388: LD_VAR 0 7
51392: ARRAY
51393: PPUSH
51394: LD_INT 10
51396: PPUSH
51397: CALL 48003 0 2
51401: NOT
51402: PUSH
51403: LD_VAR 0 16
51407: PUSH
51408: LD_VAR 0 7
51412: ARRAY
51413: PUSH
51414: EMPTY
51415: EQUAL
51416: NOT
51417: AND
51418: IFFALSE 51684
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51420: LD_VAR 0 4
51424: PUSH
51425: LD_VAR 0 7
51429: ARRAY
51430: PPUSH
51431: CALL_OW 262
51435: PUSH
51436: LD_INT 1
51438: PUSH
51439: LD_INT 2
51441: PUSH
51442: EMPTY
51443: LIST
51444: LIST
51445: IN
51446: IFFALSE 51487
// if GetFuel ( group [ i ] ) < 10 then
51448: LD_VAR 0 4
51452: PUSH
51453: LD_VAR 0 7
51457: ARRAY
51458: PPUSH
51459: CALL_OW 261
51463: PUSH
51464: LD_INT 10
51466: LESS
51467: IFFALSE 51487
// SetFuel ( group [ i ] , 12 ) ;
51469: LD_VAR 0 4
51473: PUSH
51474: LD_VAR 0 7
51478: ARRAY
51479: PPUSH
51480: LD_INT 12
51482: PPUSH
51483: CALL_OW 240
// if units_path [ i ] then
51487: LD_VAR 0 16
51491: PUSH
51492: LD_VAR 0 7
51496: ARRAY
51497: IFFALSE 51682
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51499: LD_VAR 0 4
51503: PUSH
51504: LD_VAR 0 7
51508: ARRAY
51509: PPUSH
51510: LD_VAR 0 16
51514: PUSH
51515: LD_VAR 0 7
51519: ARRAY
51520: PUSH
51521: LD_INT 1
51523: ARRAY
51524: PUSH
51525: LD_INT 1
51527: ARRAY
51528: PPUSH
51529: LD_VAR 0 16
51533: PUSH
51534: LD_VAR 0 7
51538: ARRAY
51539: PUSH
51540: LD_INT 1
51542: ARRAY
51543: PUSH
51544: LD_INT 2
51546: ARRAY
51547: PPUSH
51548: CALL_OW 297
51552: PUSH
51553: LD_INT 6
51555: GREATER
51556: IFFALSE 51631
// begin if not HasTask ( group [ i ] ) then
51558: LD_VAR 0 4
51562: PUSH
51563: LD_VAR 0 7
51567: ARRAY
51568: PPUSH
51569: CALL_OW 314
51573: NOT
51574: IFFALSE 51629
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51576: LD_VAR 0 4
51580: PUSH
51581: LD_VAR 0 7
51585: ARRAY
51586: PPUSH
51587: LD_VAR 0 16
51591: PUSH
51592: LD_VAR 0 7
51596: ARRAY
51597: PUSH
51598: LD_INT 1
51600: ARRAY
51601: PUSH
51602: LD_INT 1
51604: ARRAY
51605: PPUSH
51606: LD_VAR 0 16
51610: PUSH
51611: LD_VAR 0 7
51615: ARRAY
51616: PUSH
51617: LD_INT 1
51619: ARRAY
51620: PUSH
51621: LD_INT 2
51623: ARRAY
51624: PPUSH
51625: CALL_OW 114
// end else
51629: GO 51682
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51631: LD_ADDR_VAR 0 15
51635: PUSH
51636: LD_VAR 0 16
51640: PUSH
51641: LD_VAR 0 7
51645: ARRAY
51646: PPUSH
51647: LD_INT 1
51649: PPUSH
51650: CALL_OW 3
51654: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51655: LD_ADDR_VAR 0 16
51659: PUSH
51660: LD_VAR 0 16
51664: PPUSH
51665: LD_VAR 0 7
51669: PPUSH
51670: LD_VAR 0 15
51674: PPUSH
51675: CALL_OW 1
51679: ST_TO_ADDR
// continue ;
51680: GO 50225
// end ; end ; end else
51682: GO 54320
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51684: LD_ADDR_VAR 0 14
51688: PUSH
51689: LD_INT 81
51691: PUSH
51692: LD_VAR 0 4
51696: PUSH
51697: LD_VAR 0 7
51701: ARRAY
51702: PPUSH
51703: CALL_OW 255
51707: PUSH
51708: EMPTY
51709: LIST
51710: LIST
51711: PPUSH
51712: CALL_OW 69
51716: ST_TO_ADDR
// if not tmp then
51717: LD_VAR 0 14
51721: NOT
51722: IFFALSE 51726
// continue ;
51724: GO 50225
// if f_ignore_area then
51726: LD_VAR 0 17
51730: IFFALSE 51818
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51732: LD_ADDR_VAR 0 15
51736: PUSH
51737: LD_VAR 0 14
51741: PPUSH
51742: LD_INT 3
51744: PUSH
51745: LD_INT 92
51747: PUSH
51748: LD_VAR 0 17
51752: PUSH
51753: LD_INT 1
51755: ARRAY
51756: PUSH
51757: LD_VAR 0 17
51761: PUSH
51762: LD_INT 2
51764: ARRAY
51765: PUSH
51766: LD_VAR 0 17
51770: PUSH
51771: LD_INT 3
51773: ARRAY
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: PPUSH
51785: CALL_OW 72
51789: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51790: LD_VAR 0 14
51794: PUSH
51795: LD_VAR 0 15
51799: DIFF
51800: IFFALSE 51818
// tmp := tmp diff tmp2 ;
51802: LD_ADDR_VAR 0 14
51806: PUSH
51807: LD_VAR 0 14
51811: PUSH
51812: LD_VAR 0 15
51816: DIFF
51817: ST_TO_ADDR
// end ; if not f_murder then
51818: LD_VAR 0 20
51822: NOT
51823: IFFALSE 51881
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51825: LD_ADDR_VAR 0 15
51829: PUSH
51830: LD_VAR 0 14
51834: PPUSH
51835: LD_INT 3
51837: PUSH
51838: LD_INT 50
51840: PUSH
51841: EMPTY
51842: LIST
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PPUSH
51848: CALL_OW 72
51852: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51853: LD_VAR 0 14
51857: PUSH
51858: LD_VAR 0 15
51862: DIFF
51863: IFFALSE 51881
// tmp := tmp diff tmp2 ;
51865: LD_ADDR_VAR 0 14
51869: PUSH
51870: LD_VAR 0 14
51874: PUSH
51875: LD_VAR 0 15
51879: DIFF
51880: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51881: LD_ADDR_VAR 0 14
51885: PUSH
51886: LD_VAR 0 4
51890: PUSH
51891: LD_VAR 0 7
51895: ARRAY
51896: PPUSH
51897: LD_VAR 0 14
51901: PPUSH
51902: LD_INT 1
51904: PPUSH
51905: LD_INT 1
51907: PPUSH
51908: CALL 21646 0 4
51912: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51913: LD_VAR 0 4
51917: PUSH
51918: LD_VAR 0 7
51922: ARRAY
51923: PPUSH
51924: CALL_OW 257
51928: PUSH
51929: LD_INT 1
51931: EQUAL
51932: IFFALSE 52380
// begin if WantPlant ( group [ i ] ) then
51934: LD_VAR 0 4
51938: PUSH
51939: LD_VAR 0 7
51943: ARRAY
51944: PPUSH
51945: CALL 21147 0 1
51949: IFFALSE 51953
// continue ;
51951: GO 50225
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51953: LD_VAR 0 18
51957: PUSH
51958: LD_VAR 0 4
51962: PUSH
51963: LD_VAR 0 7
51967: ARRAY
51968: PPUSH
51969: CALL_OW 310
51973: NOT
51974: AND
51975: PUSH
51976: LD_VAR 0 14
51980: PUSH
51981: LD_INT 1
51983: ARRAY
51984: PUSH
51985: LD_VAR 0 14
51989: PPUSH
51990: LD_INT 21
51992: PUSH
51993: LD_INT 2
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: PUSH
52000: LD_INT 58
52002: PUSH
52003: EMPTY
52004: LIST
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: PPUSH
52010: CALL_OW 72
52014: IN
52015: AND
52016: IFFALSE 52052
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52018: LD_VAR 0 4
52022: PUSH
52023: LD_VAR 0 7
52027: ARRAY
52028: PPUSH
52029: LD_VAR 0 14
52033: PUSH
52034: LD_INT 1
52036: ARRAY
52037: PPUSH
52038: CALL_OW 120
// attacking := true ;
52042: LD_ADDR_VAR 0 29
52046: PUSH
52047: LD_INT 1
52049: ST_TO_ADDR
// continue ;
52050: GO 50225
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52052: LD_VAR 0 26
52056: PUSH
52057: LD_VAR 0 4
52061: PUSH
52062: LD_VAR 0 7
52066: ARRAY
52067: PPUSH
52068: CALL_OW 257
52072: PUSH
52073: LD_INT 1
52075: EQUAL
52076: AND
52077: PUSH
52078: LD_VAR 0 4
52082: PUSH
52083: LD_VAR 0 7
52087: ARRAY
52088: PPUSH
52089: CALL_OW 256
52093: PUSH
52094: LD_INT 800
52096: LESS
52097: AND
52098: PUSH
52099: LD_VAR 0 4
52103: PUSH
52104: LD_VAR 0 7
52108: ARRAY
52109: PPUSH
52110: CALL_OW 318
52114: NOT
52115: AND
52116: IFFALSE 52133
// ComCrawl ( group [ i ] ) ;
52118: LD_VAR 0 4
52122: PUSH
52123: LD_VAR 0 7
52127: ARRAY
52128: PPUSH
52129: CALL_OW 137
// if f_mines then
52133: LD_VAR 0 21
52137: IFFALSE 52380
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52139: LD_VAR 0 14
52143: PUSH
52144: LD_INT 1
52146: ARRAY
52147: PPUSH
52148: CALL_OW 247
52152: PUSH
52153: LD_INT 3
52155: EQUAL
52156: PUSH
52157: LD_VAR 0 14
52161: PUSH
52162: LD_INT 1
52164: ARRAY
52165: PUSH
52166: LD_VAR 0 27
52170: IN
52171: NOT
52172: AND
52173: IFFALSE 52380
// begin x := GetX ( tmp [ 1 ] ) ;
52175: LD_ADDR_VAR 0 10
52179: PUSH
52180: LD_VAR 0 14
52184: PUSH
52185: LD_INT 1
52187: ARRAY
52188: PPUSH
52189: CALL_OW 250
52193: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52194: LD_ADDR_VAR 0 11
52198: PUSH
52199: LD_VAR 0 14
52203: PUSH
52204: LD_INT 1
52206: ARRAY
52207: PPUSH
52208: CALL_OW 251
52212: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52213: LD_ADDR_VAR 0 12
52217: PUSH
52218: LD_VAR 0 4
52222: PUSH
52223: LD_VAR 0 7
52227: ARRAY
52228: PPUSH
52229: CALL 48088 0 1
52233: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52234: LD_VAR 0 4
52238: PUSH
52239: LD_VAR 0 7
52243: ARRAY
52244: PPUSH
52245: LD_VAR 0 10
52249: PPUSH
52250: LD_VAR 0 11
52254: PPUSH
52255: LD_VAR 0 14
52259: PUSH
52260: LD_INT 1
52262: ARRAY
52263: PPUSH
52264: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52268: LD_VAR 0 4
52272: PUSH
52273: LD_VAR 0 7
52277: ARRAY
52278: PPUSH
52279: LD_VAR 0 10
52283: PPUSH
52284: LD_VAR 0 12
52288: PPUSH
52289: LD_INT 7
52291: PPUSH
52292: CALL_OW 272
52296: PPUSH
52297: LD_VAR 0 11
52301: PPUSH
52302: LD_VAR 0 12
52306: PPUSH
52307: LD_INT 7
52309: PPUSH
52310: CALL_OW 273
52314: PPUSH
52315: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52319: LD_VAR 0 4
52323: PUSH
52324: LD_VAR 0 7
52328: ARRAY
52329: PPUSH
52330: LD_INT 71
52332: PPUSH
52333: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52337: LD_ADDR_VAR 0 27
52341: PUSH
52342: LD_VAR 0 27
52346: PPUSH
52347: LD_VAR 0 27
52351: PUSH
52352: LD_INT 1
52354: PLUS
52355: PPUSH
52356: LD_VAR 0 14
52360: PUSH
52361: LD_INT 1
52363: ARRAY
52364: PPUSH
52365: CALL_OW 1
52369: ST_TO_ADDR
// attacking := true ;
52370: LD_ADDR_VAR 0 29
52374: PUSH
52375: LD_INT 1
52377: ST_TO_ADDR
// continue ;
52378: GO 50225
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52380: LD_VAR 0 4
52384: PUSH
52385: LD_VAR 0 7
52389: ARRAY
52390: PPUSH
52391: CALL_OW 257
52395: PUSH
52396: LD_INT 17
52398: EQUAL
52399: PUSH
52400: LD_VAR 0 4
52404: PUSH
52405: LD_VAR 0 7
52409: ARRAY
52410: PPUSH
52411: CALL_OW 110
52415: PUSH
52416: LD_INT 71
52418: EQUAL
52419: NOT
52420: AND
52421: IFFALSE 52567
// begin attacking := false ;
52423: LD_ADDR_VAR 0 29
52427: PUSH
52428: LD_INT 0
52430: ST_TO_ADDR
// k := 5 ;
52431: LD_ADDR_VAR 0 9
52435: PUSH
52436: LD_INT 5
52438: ST_TO_ADDR
// if tmp < k then
52439: LD_VAR 0 14
52443: PUSH
52444: LD_VAR 0 9
52448: LESS
52449: IFFALSE 52461
// k := tmp ;
52451: LD_ADDR_VAR 0 9
52455: PUSH
52456: LD_VAR 0 14
52460: ST_TO_ADDR
// for j = 1 to k do
52461: LD_ADDR_VAR 0 8
52465: PUSH
52466: DOUBLE
52467: LD_INT 1
52469: DEC
52470: ST_TO_ADDR
52471: LD_VAR 0 9
52475: PUSH
52476: FOR_TO
52477: IFFALSE 52565
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52479: LD_VAR 0 14
52483: PUSH
52484: LD_VAR 0 8
52488: ARRAY
52489: PUSH
52490: LD_VAR 0 14
52494: PPUSH
52495: LD_INT 58
52497: PUSH
52498: EMPTY
52499: LIST
52500: PPUSH
52501: CALL_OW 72
52505: IN
52506: NOT
52507: IFFALSE 52563
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52509: LD_VAR 0 4
52513: PUSH
52514: LD_VAR 0 7
52518: ARRAY
52519: PPUSH
52520: LD_VAR 0 14
52524: PUSH
52525: LD_VAR 0 8
52529: ARRAY
52530: PPUSH
52531: CALL_OW 115
// attacking := true ;
52535: LD_ADDR_VAR 0 29
52539: PUSH
52540: LD_INT 1
52542: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52543: LD_VAR 0 4
52547: PUSH
52548: LD_VAR 0 7
52552: ARRAY
52553: PPUSH
52554: LD_INT 71
52556: PPUSH
52557: CALL_OW 109
// continue ;
52561: GO 52476
// end ; end ;
52563: GO 52476
52565: POP
52566: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52567: LD_VAR 0 4
52571: PUSH
52572: LD_VAR 0 7
52576: ARRAY
52577: PPUSH
52578: CALL_OW 257
52582: PUSH
52583: LD_INT 8
52585: EQUAL
52586: PUSH
52587: LD_VAR 0 4
52591: PUSH
52592: LD_VAR 0 7
52596: ARRAY
52597: PPUSH
52598: CALL_OW 264
52602: PUSH
52603: LD_INT 28
52605: PUSH
52606: LD_INT 45
52608: PUSH
52609: LD_INT 7
52611: PUSH
52612: LD_INT 47
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: LIST
52619: LIST
52620: IN
52621: OR
52622: IFFALSE 52852
// begin attacking := false ;
52624: LD_ADDR_VAR 0 29
52628: PUSH
52629: LD_INT 0
52631: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52632: LD_VAR 0 14
52636: PUSH
52637: LD_INT 1
52639: ARRAY
52640: PPUSH
52641: CALL_OW 266
52645: PUSH
52646: LD_INT 32
52648: PUSH
52649: LD_INT 31
52651: PUSH
52652: LD_INT 33
52654: PUSH
52655: LD_INT 4
52657: PUSH
52658: LD_INT 5
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: LIST
52665: LIST
52666: LIST
52667: IN
52668: IFFALSE 52852
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52670: LD_ADDR_VAR 0 9
52674: PUSH
52675: LD_VAR 0 14
52679: PUSH
52680: LD_INT 1
52682: ARRAY
52683: PPUSH
52684: CALL_OW 266
52688: PPUSH
52689: LD_VAR 0 14
52693: PUSH
52694: LD_INT 1
52696: ARRAY
52697: PPUSH
52698: CALL_OW 250
52702: PPUSH
52703: LD_VAR 0 14
52707: PUSH
52708: LD_INT 1
52710: ARRAY
52711: PPUSH
52712: CALL_OW 251
52716: PPUSH
52717: LD_VAR 0 14
52721: PUSH
52722: LD_INT 1
52724: ARRAY
52725: PPUSH
52726: CALL_OW 254
52730: PPUSH
52731: LD_VAR 0 14
52735: PUSH
52736: LD_INT 1
52738: ARRAY
52739: PPUSH
52740: CALL_OW 248
52744: PPUSH
52745: LD_INT 0
52747: PPUSH
52748: CALL 29458 0 6
52752: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52753: LD_ADDR_VAR 0 8
52757: PUSH
52758: LD_VAR 0 4
52762: PUSH
52763: LD_VAR 0 7
52767: ARRAY
52768: PPUSH
52769: LD_VAR 0 9
52773: PPUSH
52774: CALL 48151 0 2
52778: ST_TO_ADDR
// if j then
52779: LD_VAR 0 8
52783: IFFALSE 52852
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52785: LD_VAR 0 8
52789: PUSH
52790: LD_INT 1
52792: ARRAY
52793: PPUSH
52794: LD_VAR 0 8
52798: PUSH
52799: LD_INT 2
52801: ARRAY
52802: PPUSH
52803: CALL_OW 488
52807: IFFALSE 52852
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52809: LD_VAR 0 4
52813: PUSH
52814: LD_VAR 0 7
52818: ARRAY
52819: PPUSH
52820: LD_VAR 0 8
52824: PUSH
52825: LD_INT 1
52827: ARRAY
52828: PPUSH
52829: LD_VAR 0 8
52833: PUSH
52834: LD_INT 2
52836: ARRAY
52837: PPUSH
52838: CALL_OW 116
// attacking := true ;
52842: LD_ADDR_VAR 0 29
52846: PUSH
52847: LD_INT 1
52849: ST_TO_ADDR
// continue ;
52850: GO 50225
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52852: LD_VAR 0 4
52856: PUSH
52857: LD_VAR 0 7
52861: ARRAY
52862: PPUSH
52863: CALL_OW 265
52867: PUSH
52868: LD_INT 11
52870: EQUAL
52871: IFFALSE 53149
// begin k := 10 ;
52873: LD_ADDR_VAR 0 9
52877: PUSH
52878: LD_INT 10
52880: ST_TO_ADDR
// x := 0 ;
52881: LD_ADDR_VAR 0 10
52885: PUSH
52886: LD_INT 0
52888: ST_TO_ADDR
// if tmp < k then
52889: LD_VAR 0 14
52893: PUSH
52894: LD_VAR 0 9
52898: LESS
52899: IFFALSE 52911
// k := tmp ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_VAR 0 14
52910: ST_TO_ADDR
// for j = k downto 1 do
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: DOUBLE
52917: LD_VAR 0 9
52921: INC
52922: ST_TO_ADDR
52923: LD_INT 1
52925: PUSH
52926: FOR_DOWNTO
52927: IFFALSE 53002
// begin if GetType ( tmp [ j ] ) = unit_human then
52929: LD_VAR 0 14
52933: PUSH
52934: LD_VAR 0 8
52938: ARRAY
52939: PPUSH
52940: CALL_OW 247
52944: PUSH
52945: LD_INT 1
52947: EQUAL
52948: IFFALSE 53000
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52950: LD_VAR 0 4
52954: PUSH
52955: LD_VAR 0 7
52959: ARRAY
52960: PPUSH
52961: LD_VAR 0 14
52965: PUSH
52966: LD_VAR 0 8
52970: ARRAY
52971: PPUSH
52972: CALL 48422 0 2
// x := tmp [ j ] ;
52976: LD_ADDR_VAR 0 10
52980: PUSH
52981: LD_VAR 0 14
52985: PUSH
52986: LD_VAR 0 8
52990: ARRAY
52991: ST_TO_ADDR
// attacking := true ;
52992: LD_ADDR_VAR 0 29
52996: PUSH
52997: LD_INT 1
52999: ST_TO_ADDR
// end ; end ;
53000: GO 52926
53002: POP
53003: POP
// if not x then
53004: LD_VAR 0 10
53008: NOT
53009: IFFALSE 53149
// begin attacking := true ;
53011: LD_ADDR_VAR 0 29
53015: PUSH
53016: LD_INT 1
53018: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53019: LD_VAR 0 4
53023: PUSH
53024: LD_VAR 0 7
53028: ARRAY
53029: PPUSH
53030: CALL_OW 250
53034: PPUSH
53035: LD_VAR 0 4
53039: PUSH
53040: LD_VAR 0 7
53044: ARRAY
53045: PPUSH
53046: CALL_OW 251
53050: PPUSH
53051: CALL_OW 546
53055: PUSH
53056: LD_INT 2
53058: ARRAY
53059: PUSH
53060: LD_VAR 0 14
53064: PUSH
53065: LD_INT 1
53067: ARRAY
53068: PPUSH
53069: CALL_OW 250
53073: PPUSH
53074: LD_VAR 0 14
53078: PUSH
53079: LD_INT 1
53081: ARRAY
53082: PPUSH
53083: CALL_OW 251
53087: PPUSH
53088: CALL_OW 546
53092: PUSH
53093: LD_INT 2
53095: ARRAY
53096: EQUAL
53097: IFFALSE 53125
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53099: LD_VAR 0 4
53103: PUSH
53104: LD_VAR 0 7
53108: ARRAY
53109: PPUSH
53110: LD_VAR 0 14
53114: PUSH
53115: LD_INT 1
53117: ARRAY
53118: PPUSH
53119: CALL 48422 0 2
53123: GO 53149
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53125: LD_VAR 0 4
53129: PUSH
53130: LD_VAR 0 7
53134: ARRAY
53135: PPUSH
53136: LD_VAR 0 14
53140: PUSH
53141: LD_INT 1
53143: ARRAY
53144: PPUSH
53145: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53149: LD_VAR 0 4
53153: PUSH
53154: LD_VAR 0 7
53158: ARRAY
53159: PPUSH
53160: CALL_OW 264
53164: PUSH
53165: LD_INT 29
53167: EQUAL
53168: IFFALSE 53534
// begin if WantsToAttack ( group [ i ] ) in bombed then
53170: LD_VAR 0 4
53174: PUSH
53175: LD_VAR 0 7
53179: ARRAY
53180: PPUSH
53181: CALL_OW 319
53185: PUSH
53186: LD_VAR 0 28
53190: IN
53191: IFFALSE 53195
// continue ;
53193: GO 50225
// k := 8 ;
53195: LD_ADDR_VAR 0 9
53199: PUSH
53200: LD_INT 8
53202: ST_TO_ADDR
// x := 0 ;
53203: LD_ADDR_VAR 0 10
53207: PUSH
53208: LD_INT 0
53210: ST_TO_ADDR
// if tmp < k then
53211: LD_VAR 0 14
53215: PUSH
53216: LD_VAR 0 9
53220: LESS
53221: IFFALSE 53233
// k := tmp ;
53223: LD_ADDR_VAR 0 9
53227: PUSH
53228: LD_VAR 0 14
53232: ST_TO_ADDR
// for j = 1 to k do
53233: LD_ADDR_VAR 0 8
53237: PUSH
53238: DOUBLE
53239: LD_INT 1
53241: DEC
53242: ST_TO_ADDR
53243: LD_VAR 0 9
53247: PUSH
53248: FOR_TO
53249: IFFALSE 53381
// begin if GetType ( tmp [ j ] ) = unit_building then
53251: LD_VAR 0 14
53255: PUSH
53256: LD_VAR 0 8
53260: ARRAY
53261: PPUSH
53262: CALL_OW 247
53266: PUSH
53267: LD_INT 3
53269: EQUAL
53270: IFFALSE 53379
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53272: LD_VAR 0 14
53276: PUSH
53277: LD_VAR 0 8
53281: ARRAY
53282: PUSH
53283: LD_VAR 0 28
53287: IN
53288: NOT
53289: PUSH
53290: LD_VAR 0 14
53294: PUSH
53295: LD_VAR 0 8
53299: ARRAY
53300: PPUSH
53301: CALL_OW 313
53305: AND
53306: IFFALSE 53379
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53308: LD_VAR 0 4
53312: PUSH
53313: LD_VAR 0 7
53317: ARRAY
53318: PPUSH
53319: LD_VAR 0 14
53323: PUSH
53324: LD_VAR 0 8
53328: ARRAY
53329: PPUSH
53330: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53334: LD_ADDR_VAR 0 28
53338: PUSH
53339: LD_VAR 0 28
53343: PPUSH
53344: LD_VAR 0 28
53348: PUSH
53349: LD_INT 1
53351: PLUS
53352: PPUSH
53353: LD_VAR 0 14
53357: PUSH
53358: LD_VAR 0 8
53362: ARRAY
53363: PPUSH
53364: CALL_OW 1
53368: ST_TO_ADDR
// attacking := true ;
53369: LD_ADDR_VAR 0 29
53373: PUSH
53374: LD_INT 1
53376: ST_TO_ADDR
// break ;
53377: GO 53381
// end ; end ;
53379: GO 53248
53381: POP
53382: POP
// if not attacking and f_attack_depot then
53383: LD_VAR 0 29
53387: NOT
53388: PUSH
53389: LD_VAR 0 25
53393: AND
53394: IFFALSE 53489
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53396: LD_ADDR_VAR 0 13
53400: PUSH
53401: LD_VAR 0 14
53405: PPUSH
53406: LD_INT 2
53408: PUSH
53409: LD_INT 30
53411: PUSH
53412: LD_INT 0
53414: PUSH
53415: EMPTY
53416: LIST
53417: LIST
53418: PUSH
53419: LD_INT 30
53421: PUSH
53422: LD_INT 1
53424: PUSH
53425: EMPTY
53426: LIST
53427: LIST
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: LIST
53433: PPUSH
53434: CALL_OW 72
53438: ST_TO_ADDR
// if z then
53439: LD_VAR 0 13
53443: IFFALSE 53489
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53445: LD_VAR 0 4
53449: PUSH
53450: LD_VAR 0 7
53454: ARRAY
53455: PPUSH
53456: LD_VAR 0 13
53460: PPUSH
53461: LD_VAR 0 4
53465: PUSH
53466: LD_VAR 0 7
53470: ARRAY
53471: PPUSH
53472: CALL_OW 74
53476: PPUSH
53477: CALL_OW 115
// attacking := true ;
53481: LD_ADDR_VAR 0 29
53485: PUSH
53486: LD_INT 1
53488: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53489: LD_VAR 0 4
53493: PUSH
53494: LD_VAR 0 7
53498: ARRAY
53499: PPUSH
53500: CALL_OW 256
53504: PUSH
53505: LD_INT 500
53507: LESS
53508: IFFALSE 53534
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53510: LD_VAR 0 4
53514: PUSH
53515: LD_VAR 0 7
53519: ARRAY
53520: PPUSH
53521: LD_VAR 0 14
53525: PUSH
53526: LD_INT 1
53528: ARRAY
53529: PPUSH
53530: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53534: LD_VAR 0 4
53538: PUSH
53539: LD_VAR 0 7
53543: ARRAY
53544: PPUSH
53545: CALL_OW 264
53549: PUSH
53550: LD_INT 49
53552: EQUAL
53553: IFFALSE 53674
// begin if not HasTask ( group [ i ] ) then
53555: LD_VAR 0 4
53559: PUSH
53560: LD_VAR 0 7
53564: ARRAY
53565: PPUSH
53566: CALL_OW 314
53570: NOT
53571: IFFALSE 53674
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53573: LD_ADDR_VAR 0 9
53577: PUSH
53578: LD_INT 81
53580: PUSH
53581: LD_VAR 0 4
53585: PUSH
53586: LD_VAR 0 7
53590: ARRAY
53591: PPUSH
53592: CALL_OW 255
53596: PUSH
53597: EMPTY
53598: LIST
53599: LIST
53600: PPUSH
53601: CALL_OW 69
53605: PPUSH
53606: LD_VAR 0 4
53610: PUSH
53611: LD_VAR 0 7
53615: ARRAY
53616: PPUSH
53617: CALL_OW 74
53621: ST_TO_ADDR
// if k then
53622: LD_VAR 0 9
53626: IFFALSE 53674
// if GetDistUnits ( group [ i ] , k ) > 10 then
53628: LD_VAR 0 4
53632: PUSH
53633: LD_VAR 0 7
53637: ARRAY
53638: PPUSH
53639: LD_VAR 0 9
53643: PPUSH
53644: CALL_OW 296
53648: PUSH
53649: LD_INT 10
53651: GREATER
53652: IFFALSE 53674
// ComMoveUnit ( group [ i ] , k ) ;
53654: LD_VAR 0 4
53658: PUSH
53659: LD_VAR 0 7
53663: ARRAY
53664: PPUSH
53665: LD_VAR 0 9
53669: PPUSH
53670: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53674: LD_VAR 0 4
53678: PUSH
53679: LD_VAR 0 7
53683: ARRAY
53684: PPUSH
53685: CALL_OW 256
53689: PUSH
53690: LD_INT 250
53692: LESS
53693: PUSH
53694: LD_VAR 0 4
53698: PUSH
53699: LD_VAR 0 7
53703: ARRAY
53704: PUSH
53705: LD_INT 21
53707: PUSH
53708: LD_INT 2
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: PUSH
53715: LD_INT 23
53717: PUSH
53718: LD_INT 2
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: EMPTY
53726: LIST
53727: LIST
53728: PPUSH
53729: CALL_OW 69
53733: IN
53734: AND
53735: IFFALSE 53860
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53737: LD_ADDR_VAR 0 9
53741: PUSH
53742: LD_OWVAR 3
53746: PUSH
53747: LD_VAR 0 4
53751: PUSH
53752: LD_VAR 0 7
53756: ARRAY
53757: DIFF
53758: PPUSH
53759: LD_VAR 0 4
53763: PUSH
53764: LD_VAR 0 7
53768: ARRAY
53769: PPUSH
53770: CALL_OW 74
53774: ST_TO_ADDR
// if not k then
53775: LD_VAR 0 9
53779: NOT
53780: IFFALSE 53784
// continue ;
53782: GO 50225
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53784: LD_VAR 0 9
53788: PUSH
53789: LD_INT 81
53791: PUSH
53792: LD_VAR 0 4
53796: PUSH
53797: LD_VAR 0 7
53801: ARRAY
53802: PPUSH
53803: CALL_OW 255
53807: PUSH
53808: EMPTY
53809: LIST
53810: LIST
53811: PPUSH
53812: CALL_OW 69
53816: IN
53817: PUSH
53818: LD_VAR 0 9
53822: PPUSH
53823: LD_VAR 0 4
53827: PUSH
53828: LD_VAR 0 7
53832: ARRAY
53833: PPUSH
53834: CALL_OW 296
53838: PUSH
53839: LD_INT 5
53841: LESS
53842: AND
53843: IFFALSE 53860
// ComAutodestruct ( group [ i ] ) ;
53845: LD_VAR 0 4
53849: PUSH
53850: LD_VAR 0 7
53854: ARRAY
53855: PPUSH
53856: CALL 48320 0 1
// end ; if f_attack_depot then
53860: LD_VAR 0 25
53864: IFFALSE 53976
// begin k := 6 ;
53866: LD_ADDR_VAR 0 9
53870: PUSH
53871: LD_INT 6
53873: ST_TO_ADDR
// if tmp < k then
53874: LD_VAR 0 14
53878: PUSH
53879: LD_VAR 0 9
53883: LESS
53884: IFFALSE 53896
// k := tmp ;
53886: LD_ADDR_VAR 0 9
53890: PUSH
53891: LD_VAR 0 14
53895: ST_TO_ADDR
// for j = 1 to k do
53896: LD_ADDR_VAR 0 8
53900: PUSH
53901: DOUBLE
53902: LD_INT 1
53904: DEC
53905: ST_TO_ADDR
53906: LD_VAR 0 9
53910: PUSH
53911: FOR_TO
53912: IFFALSE 53974
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53914: LD_VAR 0 8
53918: PPUSH
53919: CALL_OW 266
53923: PUSH
53924: LD_INT 0
53926: PUSH
53927: LD_INT 1
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: IN
53934: IFFALSE 53972
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53936: LD_VAR 0 4
53940: PUSH
53941: LD_VAR 0 7
53945: ARRAY
53946: PPUSH
53947: LD_VAR 0 14
53951: PUSH
53952: LD_VAR 0 8
53956: ARRAY
53957: PPUSH
53958: CALL_OW 115
// attacking := true ;
53962: LD_ADDR_VAR 0 29
53966: PUSH
53967: LD_INT 1
53969: ST_TO_ADDR
// break ;
53970: GO 53974
// end ;
53972: GO 53911
53974: POP
53975: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53976: LD_VAR 0 4
53980: PUSH
53981: LD_VAR 0 7
53985: ARRAY
53986: PPUSH
53987: CALL_OW 302
53991: PUSH
53992: LD_VAR 0 29
53996: NOT
53997: AND
53998: IFFALSE 54320
// begin if GetTag ( group [ i ] ) = 71 then
54000: LD_VAR 0 4
54004: PUSH
54005: LD_VAR 0 7
54009: ARRAY
54010: PPUSH
54011: CALL_OW 110
54015: PUSH
54016: LD_INT 71
54018: EQUAL
54019: IFFALSE 54060
// begin if HasTask ( group [ i ] ) then
54021: LD_VAR 0 4
54025: PUSH
54026: LD_VAR 0 7
54030: ARRAY
54031: PPUSH
54032: CALL_OW 314
54036: IFFALSE 54042
// continue else
54038: GO 50225
54040: GO 54060
// SetTag ( group [ i ] , 0 ) ;
54042: LD_VAR 0 4
54046: PUSH
54047: LD_VAR 0 7
54051: ARRAY
54052: PPUSH
54053: LD_INT 0
54055: PPUSH
54056: CALL_OW 109
// end ; k := 8 ;
54060: LD_ADDR_VAR 0 9
54064: PUSH
54065: LD_INT 8
54067: ST_TO_ADDR
// x := 0 ;
54068: LD_ADDR_VAR 0 10
54072: PUSH
54073: LD_INT 0
54075: ST_TO_ADDR
// if tmp < k then
54076: LD_VAR 0 14
54080: PUSH
54081: LD_VAR 0 9
54085: LESS
54086: IFFALSE 54098
// k := tmp ;
54088: LD_ADDR_VAR 0 9
54092: PUSH
54093: LD_VAR 0 14
54097: ST_TO_ADDR
// for j = 1 to k do
54098: LD_ADDR_VAR 0 8
54102: PUSH
54103: DOUBLE
54104: LD_INT 1
54106: DEC
54107: ST_TO_ADDR
54108: LD_VAR 0 9
54112: PUSH
54113: FOR_TO
54114: IFFALSE 54212
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54116: LD_VAR 0 14
54120: PUSH
54121: LD_VAR 0 8
54125: ARRAY
54126: PPUSH
54127: CALL_OW 247
54131: PUSH
54132: LD_INT 1
54134: EQUAL
54135: PUSH
54136: LD_VAR 0 14
54140: PUSH
54141: LD_VAR 0 8
54145: ARRAY
54146: PPUSH
54147: CALL_OW 256
54151: PUSH
54152: LD_INT 250
54154: LESS
54155: PUSH
54156: LD_VAR 0 20
54160: AND
54161: PUSH
54162: LD_VAR 0 20
54166: NOT
54167: PUSH
54168: LD_VAR 0 14
54172: PUSH
54173: LD_VAR 0 8
54177: ARRAY
54178: PPUSH
54179: CALL_OW 256
54183: PUSH
54184: LD_INT 250
54186: GREATEREQUAL
54187: AND
54188: OR
54189: AND
54190: IFFALSE 54210
// begin x := tmp [ j ] ;
54192: LD_ADDR_VAR 0 10
54196: PUSH
54197: LD_VAR 0 14
54201: PUSH
54202: LD_VAR 0 8
54206: ARRAY
54207: ST_TO_ADDR
// break ;
54208: GO 54212
// end ;
54210: GO 54113
54212: POP
54213: POP
// if x then
54214: LD_VAR 0 10
54218: IFFALSE 54242
// ComAttackUnit ( group [ i ] , x ) else
54220: LD_VAR 0 4
54224: PUSH
54225: LD_VAR 0 7
54229: ARRAY
54230: PPUSH
54231: LD_VAR 0 10
54235: PPUSH
54236: CALL_OW 115
54240: GO 54266
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54242: LD_VAR 0 4
54246: PUSH
54247: LD_VAR 0 7
54251: ARRAY
54252: PPUSH
54253: LD_VAR 0 14
54257: PUSH
54258: LD_INT 1
54260: ARRAY
54261: PPUSH
54262: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54266: LD_VAR 0 4
54270: PUSH
54271: LD_VAR 0 7
54275: ARRAY
54276: PPUSH
54277: CALL_OW 314
54281: NOT
54282: IFFALSE 54320
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54284: LD_VAR 0 4
54288: PUSH
54289: LD_VAR 0 7
54293: ARRAY
54294: PPUSH
54295: LD_VAR 0 14
54299: PPUSH
54300: LD_VAR 0 4
54304: PUSH
54305: LD_VAR 0 7
54309: ARRAY
54310: PPUSH
54311: CALL_OW 74
54315: PPUSH
54316: CALL_OW 115
// end ; end ; end ;
54320: GO 50225
54322: POP
54323: POP
// wait ( 0 0$1 ) ;
54324: LD_INT 35
54326: PPUSH
54327: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54331: LD_VAR 0 4
54335: PUSH
54336: EMPTY
54337: EQUAL
54338: PUSH
54339: LD_INT 81
54341: PUSH
54342: LD_VAR 0 35
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: PPUSH
54351: CALL_OW 69
54355: NOT
54356: OR
54357: IFFALSE 50210
// end ;
54359: LD_VAR 0 2
54363: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54364: LD_INT 0
54366: PPUSH
54367: PPUSH
54368: PPUSH
54369: PPUSH
// if not base_units then
54370: LD_VAR 0 1
54374: NOT
54375: IFFALSE 54379
// exit ;
54377: GO 54466
// result := false ;
54379: LD_ADDR_VAR 0 2
54383: PUSH
54384: LD_INT 0
54386: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54387: LD_ADDR_VAR 0 5
54391: PUSH
54392: LD_VAR 0 1
54396: PPUSH
54397: LD_INT 21
54399: PUSH
54400: LD_INT 3
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: PPUSH
54407: CALL_OW 72
54411: ST_TO_ADDR
// if not tmp then
54412: LD_VAR 0 5
54416: NOT
54417: IFFALSE 54421
// exit ;
54419: GO 54466
// for i in tmp do
54421: LD_ADDR_VAR 0 3
54425: PUSH
54426: LD_VAR 0 5
54430: PUSH
54431: FOR_IN
54432: IFFALSE 54464
// begin result := EnemyInRange ( i , 22 ) ;
54434: LD_ADDR_VAR 0 2
54438: PUSH
54439: LD_VAR 0 3
54443: PPUSH
54444: LD_INT 22
54446: PPUSH
54447: CALL 48003 0 2
54451: ST_TO_ADDR
// if result then
54452: LD_VAR 0 2
54456: IFFALSE 54462
// exit ;
54458: POP
54459: POP
54460: GO 54466
// end ;
54462: GO 54431
54464: POP
54465: POP
// end ;
54466: LD_VAR 0 2
54470: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54471: LD_INT 0
54473: PPUSH
54474: PPUSH
// if not units then
54475: LD_VAR 0 1
54479: NOT
54480: IFFALSE 54484
// exit ;
54482: GO 54554
// result := [ ] ;
54484: LD_ADDR_VAR 0 3
54488: PUSH
54489: EMPTY
54490: ST_TO_ADDR
// for i in units do
54491: LD_ADDR_VAR 0 4
54495: PUSH
54496: LD_VAR 0 1
54500: PUSH
54501: FOR_IN
54502: IFFALSE 54552
// if GetTag ( i ) = tag then
54504: LD_VAR 0 4
54508: PPUSH
54509: CALL_OW 110
54513: PUSH
54514: LD_VAR 0 2
54518: EQUAL
54519: IFFALSE 54550
// result := Insert ( result , result + 1 , i ) ;
54521: LD_ADDR_VAR 0 3
54525: PUSH
54526: LD_VAR 0 3
54530: PPUSH
54531: LD_VAR 0 3
54535: PUSH
54536: LD_INT 1
54538: PLUS
54539: PPUSH
54540: LD_VAR 0 4
54544: PPUSH
54545: CALL_OW 2
54549: ST_TO_ADDR
54550: GO 54501
54552: POP
54553: POP
// end ;
54554: LD_VAR 0 3
54558: RET
// export function IsDriver ( un ) ; begin
54559: LD_INT 0
54561: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54562: LD_ADDR_VAR 0 2
54566: PUSH
54567: LD_VAR 0 1
54571: PUSH
54572: LD_INT 55
54574: PUSH
54575: EMPTY
54576: LIST
54577: PPUSH
54578: CALL_OW 69
54582: IN
54583: ST_TO_ADDR
// end ;
54584: LD_VAR 0 2
54588: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54589: LD_INT 0
54591: PPUSH
54592: PPUSH
// list := [ ] ;
54593: LD_ADDR_VAR 0 5
54597: PUSH
54598: EMPTY
54599: ST_TO_ADDR
// case d of 0 :
54600: LD_VAR 0 3
54604: PUSH
54605: LD_INT 0
54607: DOUBLE
54608: EQUAL
54609: IFTRUE 54613
54611: GO 54746
54613: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54614: LD_ADDR_VAR 0 5
54618: PUSH
54619: LD_VAR 0 1
54623: PUSH
54624: LD_INT 4
54626: MINUS
54627: PUSH
54628: LD_VAR 0 2
54632: PUSH
54633: LD_INT 4
54635: MINUS
54636: PUSH
54637: LD_INT 2
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: PUSH
54645: LD_VAR 0 1
54649: PUSH
54650: LD_INT 3
54652: MINUS
54653: PUSH
54654: LD_VAR 0 2
54658: PUSH
54659: LD_INT 1
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: LIST
54666: PUSH
54667: LD_VAR 0 1
54671: PUSH
54672: LD_INT 4
54674: PLUS
54675: PUSH
54676: LD_VAR 0 2
54680: PUSH
54681: LD_INT 4
54683: PUSH
54684: EMPTY
54685: LIST
54686: LIST
54687: LIST
54688: PUSH
54689: LD_VAR 0 1
54693: PUSH
54694: LD_INT 3
54696: PLUS
54697: PUSH
54698: LD_VAR 0 2
54702: PUSH
54703: LD_INT 3
54705: PLUS
54706: PUSH
54707: LD_INT 5
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: LIST
54714: PUSH
54715: LD_VAR 0 1
54719: PUSH
54720: LD_VAR 0 2
54724: PUSH
54725: LD_INT 4
54727: PLUS
54728: PUSH
54729: LD_INT 0
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: LIST
54736: PUSH
54737: EMPTY
54738: LIST
54739: LIST
54740: LIST
54741: LIST
54742: LIST
54743: ST_TO_ADDR
// end ; 1 :
54744: GO 55444
54746: LD_INT 1
54748: DOUBLE
54749: EQUAL
54750: IFTRUE 54754
54752: GO 54887
54754: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54755: LD_ADDR_VAR 0 5
54759: PUSH
54760: LD_VAR 0 1
54764: PUSH
54765: LD_VAR 0 2
54769: PUSH
54770: LD_INT 4
54772: MINUS
54773: PUSH
54774: LD_INT 3
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: LIST
54781: PUSH
54782: LD_VAR 0 1
54786: PUSH
54787: LD_INT 3
54789: MINUS
54790: PUSH
54791: LD_VAR 0 2
54795: PUSH
54796: LD_INT 3
54798: MINUS
54799: PUSH
54800: LD_INT 2
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: LIST
54807: PUSH
54808: LD_VAR 0 1
54812: PUSH
54813: LD_INT 4
54815: MINUS
54816: PUSH
54817: LD_VAR 0 2
54821: PUSH
54822: LD_INT 1
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: PUSH
54830: LD_VAR 0 1
54834: PUSH
54835: LD_VAR 0 2
54839: PUSH
54840: LD_INT 3
54842: PLUS
54843: PUSH
54844: LD_INT 0
54846: PUSH
54847: EMPTY
54848: LIST
54849: LIST
54850: LIST
54851: PUSH
54852: LD_VAR 0 1
54856: PUSH
54857: LD_INT 4
54859: PLUS
54860: PUSH
54861: LD_VAR 0 2
54865: PUSH
54866: LD_INT 4
54868: PLUS
54869: PUSH
54870: LD_INT 5
54872: PUSH
54873: EMPTY
54874: LIST
54875: LIST
54876: LIST
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: LIST
54882: LIST
54883: LIST
54884: ST_TO_ADDR
// end ; 2 :
54885: GO 55444
54887: LD_INT 2
54889: DOUBLE
54890: EQUAL
54891: IFTRUE 54895
54893: GO 55024
54895: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54896: LD_ADDR_VAR 0 5
54900: PUSH
54901: LD_VAR 0 1
54905: PUSH
54906: LD_VAR 0 2
54910: PUSH
54911: LD_INT 3
54913: MINUS
54914: PUSH
54915: LD_INT 3
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: LIST
54922: PUSH
54923: LD_VAR 0 1
54927: PUSH
54928: LD_INT 4
54930: PLUS
54931: PUSH
54932: LD_VAR 0 2
54936: PUSH
54937: LD_INT 4
54939: PUSH
54940: EMPTY
54941: LIST
54942: LIST
54943: LIST
54944: PUSH
54945: LD_VAR 0 1
54949: PUSH
54950: LD_VAR 0 2
54954: PUSH
54955: LD_INT 4
54957: PLUS
54958: PUSH
54959: LD_INT 0
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: LIST
54966: PUSH
54967: LD_VAR 0 1
54971: PUSH
54972: LD_INT 3
54974: MINUS
54975: PUSH
54976: LD_VAR 0 2
54980: PUSH
54981: LD_INT 1
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: PUSH
54989: LD_VAR 0 1
54993: PUSH
54994: LD_INT 4
54996: MINUS
54997: PUSH
54998: LD_VAR 0 2
55002: PUSH
55003: LD_INT 4
55005: MINUS
55006: PUSH
55007: LD_INT 2
55009: PUSH
55010: EMPTY
55011: LIST
55012: LIST
55013: LIST
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: LIST
55019: LIST
55020: LIST
55021: ST_TO_ADDR
// end ; 3 :
55022: GO 55444
55024: LD_INT 3
55026: DOUBLE
55027: EQUAL
55028: IFTRUE 55032
55030: GO 55165
55032: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55033: LD_ADDR_VAR 0 5
55037: PUSH
55038: LD_VAR 0 1
55042: PUSH
55043: LD_INT 3
55045: PLUS
55046: PUSH
55047: LD_VAR 0 2
55051: PUSH
55052: LD_INT 4
55054: PUSH
55055: EMPTY
55056: LIST
55057: LIST
55058: LIST
55059: PUSH
55060: LD_VAR 0 1
55064: PUSH
55065: LD_INT 4
55067: PLUS
55068: PUSH
55069: LD_VAR 0 2
55073: PUSH
55074: LD_INT 4
55076: PLUS
55077: PUSH
55078: LD_INT 5
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: LIST
55085: PUSH
55086: LD_VAR 0 1
55090: PUSH
55091: LD_INT 4
55093: MINUS
55094: PUSH
55095: LD_VAR 0 2
55099: PUSH
55100: LD_INT 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: LIST
55107: PUSH
55108: LD_VAR 0 1
55112: PUSH
55113: LD_VAR 0 2
55117: PUSH
55118: LD_INT 4
55120: MINUS
55121: PUSH
55122: LD_INT 3
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: LIST
55129: PUSH
55130: LD_VAR 0 1
55134: PUSH
55135: LD_INT 3
55137: MINUS
55138: PUSH
55139: LD_VAR 0 2
55143: PUSH
55144: LD_INT 3
55146: MINUS
55147: PUSH
55148: LD_INT 2
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: LIST
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: LIST
55160: LIST
55161: LIST
55162: ST_TO_ADDR
// end ; 4 :
55163: GO 55444
55165: LD_INT 4
55167: DOUBLE
55168: EQUAL
55169: IFTRUE 55173
55171: GO 55306
55173: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55174: LD_ADDR_VAR 0 5
55178: PUSH
55179: LD_VAR 0 1
55183: PUSH
55184: LD_VAR 0 2
55188: PUSH
55189: LD_INT 4
55191: PLUS
55192: PUSH
55193: LD_INT 0
55195: PUSH
55196: EMPTY
55197: LIST
55198: LIST
55199: LIST
55200: PUSH
55201: LD_VAR 0 1
55205: PUSH
55206: LD_INT 3
55208: PLUS
55209: PUSH
55210: LD_VAR 0 2
55214: PUSH
55215: LD_INT 3
55217: PLUS
55218: PUSH
55219: LD_INT 5
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: LIST
55226: PUSH
55227: LD_VAR 0 1
55231: PUSH
55232: LD_INT 4
55234: PLUS
55235: PUSH
55236: LD_VAR 0 2
55240: PUSH
55241: LD_INT 4
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: PUSH
55249: LD_VAR 0 1
55253: PUSH
55254: LD_VAR 0 2
55258: PUSH
55259: LD_INT 3
55261: MINUS
55262: PUSH
55263: LD_INT 3
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: LIST
55270: PUSH
55271: LD_VAR 0 1
55275: PUSH
55276: LD_INT 4
55278: MINUS
55279: PUSH
55280: LD_VAR 0 2
55284: PUSH
55285: LD_INT 4
55287: MINUS
55288: PUSH
55289: LD_INT 2
55291: PUSH
55292: EMPTY
55293: LIST
55294: LIST
55295: LIST
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: ST_TO_ADDR
// end ; 5 :
55304: GO 55444
55306: LD_INT 5
55308: DOUBLE
55309: EQUAL
55310: IFTRUE 55314
55312: GO 55443
55314: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55315: LD_ADDR_VAR 0 5
55319: PUSH
55320: LD_VAR 0 1
55324: PUSH
55325: LD_INT 4
55327: MINUS
55328: PUSH
55329: LD_VAR 0 2
55333: PUSH
55334: LD_INT 1
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: LIST
55341: PUSH
55342: LD_VAR 0 1
55346: PUSH
55347: LD_VAR 0 2
55351: PUSH
55352: LD_INT 4
55354: MINUS
55355: PUSH
55356: LD_INT 3
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: LIST
55363: PUSH
55364: LD_VAR 0 1
55368: PUSH
55369: LD_INT 4
55371: PLUS
55372: PUSH
55373: LD_VAR 0 2
55377: PUSH
55378: LD_INT 4
55380: PLUS
55381: PUSH
55382: LD_INT 5
55384: PUSH
55385: EMPTY
55386: LIST
55387: LIST
55388: LIST
55389: PUSH
55390: LD_VAR 0 1
55394: PUSH
55395: LD_INT 3
55397: PLUS
55398: PUSH
55399: LD_VAR 0 2
55403: PUSH
55404: LD_INT 4
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: LIST
55411: PUSH
55412: LD_VAR 0 1
55416: PUSH
55417: LD_VAR 0 2
55421: PUSH
55422: LD_INT 3
55424: PLUS
55425: PUSH
55426: LD_INT 0
55428: PUSH
55429: EMPTY
55430: LIST
55431: LIST
55432: LIST
55433: PUSH
55434: EMPTY
55435: LIST
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: ST_TO_ADDR
// end ; end ;
55441: GO 55444
55443: POP
// result := list ;
55444: LD_ADDR_VAR 0 4
55448: PUSH
55449: LD_VAR 0 5
55453: ST_TO_ADDR
// end ;
55454: LD_VAR 0 4
55458: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55459: LD_INT 0
55461: PPUSH
55462: PPUSH
55463: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55464: LD_VAR 0 1
55468: NOT
55469: PUSH
55470: LD_VAR 0 2
55474: PUSH
55475: LD_INT 1
55477: PUSH
55478: LD_INT 2
55480: PUSH
55481: LD_INT 3
55483: PUSH
55484: LD_INT 4
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: LIST
55491: LIST
55492: IN
55493: NOT
55494: OR
55495: IFFALSE 55499
// exit ;
55497: GO 55591
// tmp := [ ] ;
55499: LD_ADDR_VAR 0 5
55503: PUSH
55504: EMPTY
55505: ST_TO_ADDR
// for i in units do
55506: LD_ADDR_VAR 0 4
55510: PUSH
55511: LD_VAR 0 1
55515: PUSH
55516: FOR_IN
55517: IFFALSE 55560
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55519: LD_ADDR_VAR 0 5
55523: PUSH
55524: LD_VAR 0 5
55528: PPUSH
55529: LD_VAR 0 5
55533: PUSH
55534: LD_INT 1
55536: PLUS
55537: PPUSH
55538: LD_VAR 0 4
55542: PPUSH
55543: LD_VAR 0 2
55547: PPUSH
55548: CALL_OW 259
55552: PPUSH
55553: CALL_OW 2
55557: ST_TO_ADDR
55558: GO 55516
55560: POP
55561: POP
// if not tmp then
55562: LD_VAR 0 5
55566: NOT
55567: IFFALSE 55571
// exit ;
55569: GO 55591
// result := SortListByListDesc ( units , tmp ) ;
55571: LD_ADDR_VAR 0 3
55575: PUSH
55576: LD_VAR 0 1
55580: PPUSH
55581: LD_VAR 0 5
55585: PPUSH
55586: CALL_OW 77
55590: ST_TO_ADDR
// end ;
55591: LD_VAR 0 3
55595: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55596: LD_INT 0
55598: PPUSH
55599: PPUSH
55600: PPUSH
// x := GetX ( building ) ;
55601: LD_ADDR_VAR 0 4
55605: PUSH
55606: LD_VAR 0 2
55610: PPUSH
55611: CALL_OW 250
55615: ST_TO_ADDR
// y := GetY ( building ) ;
55616: LD_ADDR_VAR 0 5
55620: PUSH
55621: LD_VAR 0 2
55625: PPUSH
55626: CALL_OW 251
55630: ST_TO_ADDR
// if GetTaskList ( unit ) then
55631: LD_VAR 0 1
55635: PPUSH
55636: CALL_OW 437
55640: IFFALSE 55735
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55642: LD_STRING e
55644: PUSH
55645: LD_VAR 0 1
55649: PPUSH
55650: CALL_OW 437
55654: PUSH
55655: LD_INT 1
55657: ARRAY
55658: PUSH
55659: LD_INT 1
55661: ARRAY
55662: EQUAL
55663: PUSH
55664: LD_VAR 0 4
55668: PUSH
55669: LD_VAR 0 1
55673: PPUSH
55674: CALL_OW 437
55678: PUSH
55679: LD_INT 1
55681: ARRAY
55682: PUSH
55683: LD_INT 2
55685: ARRAY
55686: EQUAL
55687: AND
55688: PUSH
55689: LD_VAR 0 5
55693: PUSH
55694: LD_VAR 0 1
55698: PPUSH
55699: CALL_OW 437
55703: PUSH
55704: LD_INT 1
55706: ARRAY
55707: PUSH
55708: LD_INT 3
55710: ARRAY
55711: EQUAL
55712: AND
55713: IFFALSE 55725
// result := true else
55715: LD_ADDR_VAR 0 3
55719: PUSH
55720: LD_INT 1
55722: ST_TO_ADDR
55723: GO 55733
// result := false ;
55725: LD_ADDR_VAR 0 3
55729: PUSH
55730: LD_INT 0
55732: ST_TO_ADDR
// end else
55733: GO 55743
// result := false ;
55735: LD_ADDR_VAR 0 3
55739: PUSH
55740: LD_INT 0
55742: ST_TO_ADDR
// end ;
55743: LD_VAR 0 3
55747: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55748: LD_INT 0
55750: PPUSH
55751: PPUSH
55752: PPUSH
55753: PPUSH
// if not unit or not area then
55754: LD_VAR 0 1
55758: NOT
55759: PUSH
55760: LD_VAR 0 2
55764: NOT
55765: OR
55766: IFFALSE 55770
// exit ;
55768: GO 55934
// tmp := AreaToList ( area , i ) ;
55770: LD_ADDR_VAR 0 6
55774: PUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_VAR 0 5
55784: PPUSH
55785: CALL_OW 517
55789: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55790: LD_ADDR_VAR 0 5
55794: PUSH
55795: DOUBLE
55796: LD_INT 1
55798: DEC
55799: ST_TO_ADDR
55800: LD_VAR 0 6
55804: PUSH
55805: LD_INT 1
55807: ARRAY
55808: PUSH
55809: FOR_TO
55810: IFFALSE 55932
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55812: LD_ADDR_VAR 0 7
55816: PUSH
55817: LD_VAR 0 6
55821: PUSH
55822: LD_INT 1
55824: ARRAY
55825: PUSH
55826: LD_VAR 0 5
55830: ARRAY
55831: PUSH
55832: LD_VAR 0 6
55836: PUSH
55837: LD_INT 2
55839: ARRAY
55840: PUSH
55841: LD_VAR 0 5
55845: ARRAY
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55851: LD_VAR 0 7
55855: PUSH
55856: LD_INT 1
55858: ARRAY
55859: PPUSH
55860: LD_VAR 0 7
55864: PUSH
55865: LD_INT 2
55867: ARRAY
55868: PPUSH
55869: CALL_OW 428
55873: PUSH
55874: LD_INT 0
55876: EQUAL
55877: IFFALSE 55930
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55879: LD_VAR 0 1
55883: PPUSH
55884: LD_VAR 0 7
55888: PUSH
55889: LD_INT 1
55891: ARRAY
55892: PPUSH
55893: LD_VAR 0 7
55897: PUSH
55898: LD_INT 2
55900: ARRAY
55901: PPUSH
55902: LD_VAR 0 3
55906: PPUSH
55907: CALL_OW 48
// result := IsPlaced ( unit ) ;
55911: LD_ADDR_VAR 0 4
55915: PUSH
55916: LD_VAR 0 1
55920: PPUSH
55921: CALL_OW 305
55925: ST_TO_ADDR
// exit ;
55926: POP
55927: POP
55928: GO 55934
// end ; end ;
55930: GO 55809
55932: POP
55933: POP
// end ;
55934: LD_VAR 0 4
55938: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55939: LD_INT 0
55941: PPUSH
55942: PPUSH
55943: PPUSH
// if not side or side > 8 then
55944: LD_VAR 0 1
55948: NOT
55949: PUSH
55950: LD_VAR 0 1
55954: PUSH
55955: LD_INT 8
55957: GREATER
55958: OR
55959: IFFALSE 55963
// exit ;
55961: GO 56150
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55963: LD_ADDR_VAR 0 4
55967: PUSH
55968: LD_INT 22
55970: PUSH
55971: LD_VAR 0 1
55975: PUSH
55976: EMPTY
55977: LIST
55978: LIST
55979: PUSH
55980: LD_INT 21
55982: PUSH
55983: LD_INT 3
55985: PUSH
55986: EMPTY
55987: LIST
55988: LIST
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: PPUSH
55994: CALL_OW 69
55998: ST_TO_ADDR
// if not tmp then
55999: LD_VAR 0 4
56003: NOT
56004: IFFALSE 56008
// exit ;
56006: GO 56150
// enable_addtolog := true ;
56008: LD_ADDR_OWVAR 81
56012: PUSH
56013: LD_INT 1
56015: ST_TO_ADDR
// AddToLog ( [ ) ;
56016: LD_STRING [
56018: PPUSH
56019: CALL_OW 561
// for i in tmp do
56023: LD_ADDR_VAR 0 3
56027: PUSH
56028: LD_VAR 0 4
56032: PUSH
56033: FOR_IN
56034: IFFALSE 56141
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56036: LD_STRING [
56038: PUSH
56039: LD_VAR 0 3
56043: PPUSH
56044: CALL_OW 266
56048: STR
56049: PUSH
56050: LD_STRING , 
56052: STR
56053: PUSH
56054: LD_VAR 0 3
56058: PPUSH
56059: CALL_OW 250
56063: STR
56064: PUSH
56065: LD_STRING , 
56067: STR
56068: PUSH
56069: LD_VAR 0 3
56073: PPUSH
56074: CALL_OW 251
56078: STR
56079: PUSH
56080: LD_STRING , 
56082: STR
56083: PUSH
56084: LD_VAR 0 3
56088: PPUSH
56089: CALL_OW 254
56093: STR
56094: PUSH
56095: LD_STRING , 
56097: STR
56098: PUSH
56099: LD_VAR 0 3
56103: PPUSH
56104: LD_INT 1
56106: PPUSH
56107: CALL_OW 268
56111: STR
56112: PUSH
56113: LD_STRING , 
56115: STR
56116: PUSH
56117: LD_VAR 0 3
56121: PPUSH
56122: LD_INT 2
56124: PPUSH
56125: CALL_OW 268
56129: STR
56130: PUSH
56131: LD_STRING ],
56133: STR
56134: PPUSH
56135: CALL_OW 561
// end ;
56139: GO 56033
56141: POP
56142: POP
// AddToLog ( ]; ) ;
56143: LD_STRING ];
56145: PPUSH
56146: CALL_OW 561
// end ;
56150: LD_VAR 0 2
56154: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56155: LD_INT 0
56157: PPUSH
56158: PPUSH
56159: PPUSH
56160: PPUSH
56161: PPUSH
// if not area or not rate or not max then
56162: LD_VAR 0 1
56166: NOT
56167: PUSH
56168: LD_VAR 0 2
56172: NOT
56173: OR
56174: PUSH
56175: LD_VAR 0 4
56179: NOT
56180: OR
56181: IFFALSE 56185
// exit ;
56183: GO 56377
// while 1 do
56185: LD_INT 1
56187: IFFALSE 56377
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56189: LD_ADDR_VAR 0 9
56193: PUSH
56194: LD_VAR 0 1
56198: PPUSH
56199: LD_INT 1
56201: PPUSH
56202: CALL_OW 287
56206: PUSH
56207: LD_INT 10
56209: MUL
56210: ST_TO_ADDR
// r := rate / 10 ;
56211: LD_ADDR_VAR 0 7
56215: PUSH
56216: LD_VAR 0 2
56220: PUSH
56221: LD_INT 10
56223: DIVREAL
56224: ST_TO_ADDR
// time := 1 1$00 ;
56225: LD_ADDR_VAR 0 8
56229: PUSH
56230: LD_INT 2100
56232: ST_TO_ADDR
// if amount < min then
56233: LD_VAR 0 9
56237: PUSH
56238: LD_VAR 0 3
56242: LESS
56243: IFFALSE 56261
// r := r * 2 else
56245: LD_ADDR_VAR 0 7
56249: PUSH
56250: LD_VAR 0 7
56254: PUSH
56255: LD_INT 2
56257: MUL
56258: ST_TO_ADDR
56259: GO 56287
// if amount > max then
56261: LD_VAR 0 9
56265: PUSH
56266: LD_VAR 0 4
56270: GREATER
56271: IFFALSE 56287
// r := r / 2 ;
56273: LD_ADDR_VAR 0 7
56277: PUSH
56278: LD_VAR 0 7
56282: PUSH
56283: LD_INT 2
56285: DIVREAL
56286: ST_TO_ADDR
// time := time / r ;
56287: LD_ADDR_VAR 0 8
56291: PUSH
56292: LD_VAR 0 8
56296: PUSH
56297: LD_VAR 0 7
56301: DIVREAL
56302: ST_TO_ADDR
// if time < 0 then
56303: LD_VAR 0 8
56307: PUSH
56308: LD_INT 0
56310: LESS
56311: IFFALSE 56328
// time := time * - 1 ;
56313: LD_ADDR_VAR 0 8
56317: PUSH
56318: LD_VAR 0 8
56322: PUSH
56323: LD_INT 1
56325: NEG
56326: MUL
56327: ST_TO_ADDR
// wait ( time ) ;
56328: LD_VAR 0 8
56332: PPUSH
56333: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56337: LD_INT 35
56339: PPUSH
56340: LD_INT 875
56342: PPUSH
56343: CALL_OW 12
56347: PPUSH
56348: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56352: LD_INT 1
56354: PPUSH
56355: LD_INT 5
56357: PPUSH
56358: CALL_OW 12
56362: PPUSH
56363: LD_VAR 0 1
56367: PPUSH
56368: LD_INT 1
56370: PPUSH
56371: CALL_OW 55
// end ;
56375: GO 56185
// end ;
56377: LD_VAR 0 5
56381: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56382: LD_INT 0
56384: PPUSH
56385: PPUSH
56386: PPUSH
56387: PPUSH
56388: PPUSH
56389: PPUSH
56390: PPUSH
56391: PPUSH
// if not turrets or not factories then
56392: LD_VAR 0 1
56396: NOT
56397: PUSH
56398: LD_VAR 0 2
56402: NOT
56403: OR
56404: IFFALSE 56408
// exit ;
56406: GO 56715
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56408: LD_ADDR_VAR 0 10
56412: PUSH
56413: LD_INT 5
56415: PUSH
56416: LD_INT 6
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: PUSH
56423: LD_INT 2
56425: PUSH
56426: LD_INT 4
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: LD_INT 3
56435: PUSH
56436: LD_INT 5
56438: PUSH
56439: EMPTY
56440: LIST
56441: LIST
56442: PUSH
56443: EMPTY
56444: LIST
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 24
56450: PUSH
56451: LD_INT 25
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PUSH
56458: LD_INT 23
56460: PUSH
56461: LD_INT 27
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: PUSH
56472: LD_INT 42
56474: PUSH
56475: LD_INT 43
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: LD_INT 44
56484: PUSH
56485: LD_INT 46
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: PUSH
56492: LD_INT 45
56494: PUSH
56495: LD_INT 47
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: PUSH
56502: EMPTY
56503: LIST
56504: LIST
56505: LIST
56506: PUSH
56507: EMPTY
56508: LIST
56509: LIST
56510: LIST
56511: ST_TO_ADDR
// result := [ ] ;
56512: LD_ADDR_VAR 0 3
56516: PUSH
56517: EMPTY
56518: ST_TO_ADDR
// for i in turrets do
56519: LD_ADDR_VAR 0 4
56523: PUSH
56524: LD_VAR 0 1
56528: PUSH
56529: FOR_IN
56530: IFFALSE 56713
// begin nat := GetNation ( i ) ;
56532: LD_ADDR_VAR 0 7
56536: PUSH
56537: LD_VAR 0 4
56541: PPUSH
56542: CALL_OW 248
56546: ST_TO_ADDR
// weapon := 0 ;
56547: LD_ADDR_VAR 0 8
56551: PUSH
56552: LD_INT 0
56554: ST_TO_ADDR
// if not nat then
56555: LD_VAR 0 7
56559: NOT
56560: IFFALSE 56564
// continue ;
56562: GO 56529
// for j in list [ nat ] do
56564: LD_ADDR_VAR 0 5
56568: PUSH
56569: LD_VAR 0 10
56573: PUSH
56574: LD_VAR 0 7
56578: ARRAY
56579: PUSH
56580: FOR_IN
56581: IFFALSE 56622
// if GetBWeapon ( i ) = j [ 1 ] then
56583: LD_VAR 0 4
56587: PPUSH
56588: CALL_OW 269
56592: PUSH
56593: LD_VAR 0 5
56597: PUSH
56598: LD_INT 1
56600: ARRAY
56601: EQUAL
56602: IFFALSE 56620
// begin weapon := j [ 2 ] ;
56604: LD_ADDR_VAR 0 8
56608: PUSH
56609: LD_VAR 0 5
56613: PUSH
56614: LD_INT 2
56616: ARRAY
56617: ST_TO_ADDR
// break ;
56618: GO 56622
// end ;
56620: GO 56580
56622: POP
56623: POP
// if not weapon then
56624: LD_VAR 0 8
56628: NOT
56629: IFFALSE 56633
// continue ;
56631: GO 56529
// for k in factories do
56633: LD_ADDR_VAR 0 6
56637: PUSH
56638: LD_VAR 0 2
56642: PUSH
56643: FOR_IN
56644: IFFALSE 56709
// begin weapons := AvailableWeaponList ( k ) ;
56646: LD_ADDR_VAR 0 9
56650: PUSH
56651: LD_VAR 0 6
56655: PPUSH
56656: CALL_OW 478
56660: ST_TO_ADDR
// if not weapons then
56661: LD_VAR 0 9
56665: NOT
56666: IFFALSE 56670
// continue ;
56668: GO 56643
// if weapon in weapons then
56670: LD_VAR 0 8
56674: PUSH
56675: LD_VAR 0 9
56679: IN
56680: IFFALSE 56707
// begin result := [ i , weapon ] ;
56682: LD_ADDR_VAR 0 3
56686: PUSH
56687: LD_VAR 0 4
56691: PUSH
56692: LD_VAR 0 8
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: ST_TO_ADDR
// exit ;
56701: POP
56702: POP
56703: POP
56704: POP
56705: GO 56715
// end ; end ;
56707: GO 56643
56709: POP
56710: POP
// end ;
56711: GO 56529
56713: POP
56714: POP
// end ;
56715: LD_VAR 0 3
56719: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56720: LD_INT 0
56722: PPUSH
// if not side or side > 8 then
56723: LD_VAR 0 3
56727: NOT
56728: PUSH
56729: LD_VAR 0 3
56733: PUSH
56734: LD_INT 8
56736: GREATER
56737: OR
56738: IFFALSE 56742
// exit ;
56740: GO 56801
// if not range then
56742: LD_VAR 0 4
56746: NOT
56747: IFFALSE 56758
// range := - 12 ;
56749: LD_ADDR_VAR 0 4
56753: PUSH
56754: LD_INT 12
56756: NEG
56757: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56758: LD_VAR 0 1
56762: PPUSH
56763: LD_VAR 0 2
56767: PPUSH
56768: LD_VAR 0 3
56772: PPUSH
56773: LD_VAR 0 4
56777: PPUSH
56778: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56782: LD_VAR 0 1
56786: PPUSH
56787: LD_VAR 0 2
56791: PPUSH
56792: LD_VAR 0 3
56796: PPUSH
56797: CALL_OW 331
// end ;
56801: LD_VAR 0 5
56805: RET
// export function Video ( mode ) ; begin
56806: LD_INT 0
56808: PPUSH
// ingame_video = mode ;
56809: LD_ADDR_OWVAR 52
56813: PUSH
56814: LD_VAR 0 1
56818: ST_TO_ADDR
// interface_hidden = mode ;
56819: LD_ADDR_OWVAR 54
56823: PUSH
56824: LD_VAR 0 1
56828: ST_TO_ADDR
// end ;
56829: LD_VAR 0 2
56833: RET
// export function Join ( array , element ) ; begin
56834: LD_INT 0
56836: PPUSH
// result := array ^ element ;
56837: LD_ADDR_VAR 0 3
56841: PUSH
56842: LD_VAR 0 1
56846: PUSH
56847: LD_VAR 0 2
56851: ADD
56852: ST_TO_ADDR
// end ;
56853: LD_VAR 0 3
56857: RET
// export function JoinUnion ( array , element ) ; begin
56858: LD_INT 0
56860: PPUSH
// result := array union element ;
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_VAR 0 1
56870: PUSH
56871: LD_VAR 0 2
56875: UNION
56876: ST_TO_ADDR
// end ;
56877: LD_VAR 0 3
56881: RET
// export function GetBehemoths ( side ) ; begin
56882: LD_INT 0
56884: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56885: LD_ADDR_VAR 0 2
56889: PUSH
56890: LD_INT 22
56892: PUSH
56893: LD_VAR 0 1
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PUSH
56902: LD_INT 31
56904: PUSH
56905: LD_INT 25
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PPUSH
56916: CALL_OW 69
56920: ST_TO_ADDR
// end ;
56921: LD_VAR 0 2
56925: RET
// export function Shuffle ( array ) ; var i , index ; begin
56926: LD_INT 0
56928: PPUSH
56929: PPUSH
56930: PPUSH
// result := [ ] ;
56931: LD_ADDR_VAR 0 2
56935: PUSH
56936: EMPTY
56937: ST_TO_ADDR
// if not array then
56938: LD_VAR 0 1
56942: NOT
56943: IFFALSE 56947
// exit ;
56945: GO 57046
// Randomize ;
56947: CALL_OW 10
// for i = array downto 1 do
56951: LD_ADDR_VAR 0 3
56955: PUSH
56956: DOUBLE
56957: LD_VAR 0 1
56961: INC
56962: ST_TO_ADDR
56963: LD_INT 1
56965: PUSH
56966: FOR_DOWNTO
56967: IFFALSE 57044
// begin index := rand ( 1 , array ) ;
56969: LD_ADDR_VAR 0 4
56973: PUSH
56974: LD_INT 1
56976: PPUSH
56977: LD_VAR 0 1
56981: PPUSH
56982: CALL_OW 12
56986: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56987: LD_ADDR_VAR 0 2
56991: PUSH
56992: LD_VAR 0 2
56996: PPUSH
56997: LD_VAR 0 2
57001: PUSH
57002: LD_INT 1
57004: PLUS
57005: PPUSH
57006: LD_VAR 0 1
57010: PUSH
57011: LD_VAR 0 4
57015: ARRAY
57016: PPUSH
57017: CALL_OW 2
57021: ST_TO_ADDR
// array := Delete ( array , index ) ;
57022: LD_ADDR_VAR 0 1
57026: PUSH
57027: LD_VAR 0 1
57031: PPUSH
57032: LD_VAR 0 4
57036: PPUSH
57037: CALL_OW 3
57041: ST_TO_ADDR
// end ;
57042: GO 56966
57044: POP
57045: POP
// end ;
57046: LD_VAR 0 2
57050: RET
// export function GetBaseMaterials ( base ) ; begin
57051: LD_INT 0
57053: PPUSH
// result := [ 0 , 0 , 0 ] ;
57054: LD_ADDR_VAR 0 2
57058: PUSH
57059: LD_INT 0
57061: PUSH
57062: LD_INT 0
57064: PUSH
57065: LD_INT 0
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: LIST
57072: ST_TO_ADDR
// if not base then
57073: LD_VAR 0 1
57077: NOT
57078: IFFALSE 57082
// exit ;
57080: GO 57131
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57082: LD_ADDR_VAR 0 2
57086: PUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: LD_INT 1
57094: PPUSH
57095: CALL_OW 275
57099: PUSH
57100: LD_VAR 0 1
57104: PPUSH
57105: LD_INT 2
57107: PPUSH
57108: CALL_OW 275
57112: PUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: LD_INT 3
57120: PPUSH
57121: CALL_OW 275
57125: PUSH
57126: EMPTY
57127: LIST
57128: LIST
57129: LIST
57130: ST_TO_ADDR
// end ; end_of_file
57131: LD_VAR 0 2
57135: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57136: LD_INT 0
57138: PPUSH
57139: PPUSH
// skirmish := false ;
57140: LD_ADDR_EXP 56
57144: PUSH
57145: LD_INT 0
57147: ST_TO_ADDR
// debug_mc := false ;
57148: LD_ADDR_EXP 57
57152: PUSH
57153: LD_INT 0
57155: ST_TO_ADDR
// mc_bases := [ ] ;
57156: LD_ADDR_EXP 58
57160: PUSH
57161: EMPTY
57162: ST_TO_ADDR
// mc_sides := [ ] ;
57163: LD_ADDR_EXP 84
57167: PUSH
57168: EMPTY
57169: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57170: LD_ADDR_EXP 59
57174: PUSH
57175: EMPTY
57176: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57177: LD_ADDR_EXP 60
57181: PUSH
57182: EMPTY
57183: ST_TO_ADDR
// mc_need_heal := [ ] ;
57184: LD_ADDR_EXP 61
57188: PUSH
57189: EMPTY
57190: ST_TO_ADDR
// mc_healers := [ ] ;
57191: LD_ADDR_EXP 62
57195: PUSH
57196: EMPTY
57197: ST_TO_ADDR
// mc_build_list := [ ] ;
57198: LD_ADDR_EXP 63
57202: PUSH
57203: EMPTY
57204: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57205: LD_ADDR_EXP 90
57209: PUSH
57210: EMPTY
57211: ST_TO_ADDR
// mc_builders := [ ] ;
57212: LD_ADDR_EXP 64
57216: PUSH
57217: EMPTY
57218: ST_TO_ADDR
// mc_construct_list := [ ] ;
57219: LD_ADDR_EXP 65
57223: PUSH
57224: EMPTY
57225: ST_TO_ADDR
// mc_turret_list := [ ] ;
57226: LD_ADDR_EXP 66
57230: PUSH
57231: EMPTY
57232: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57233: LD_ADDR_EXP 67
57237: PUSH
57238: EMPTY
57239: ST_TO_ADDR
// mc_miners := [ ] ;
57240: LD_ADDR_EXP 72
57244: PUSH
57245: EMPTY
57246: ST_TO_ADDR
// mc_mines := [ ] ;
57247: LD_ADDR_EXP 71
57251: PUSH
57252: EMPTY
57253: ST_TO_ADDR
// mc_minefields := [ ] ;
57254: LD_ADDR_EXP 73
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// mc_crates := [ ] ;
57261: LD_ADDR_EXP 74
57265: PUSH
57266: EMPTY
57267: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57268: LD_ADDR_EXP 75
57272: PUSH
57273: EMPTY
57274: ST_TO_ADDR
// mc_crates_area := [ ] ;
57275: LD_ADDR_EXP 76
57279: PUSH
57280: EMPTY
57281: ST_TO_ADDR
// mc_vehicles := [ ] ;
57282: LD_ADDR_EXP 77
57286: PUSH
57287: EMPTY
57288: ST_TO_ADDR
// mc_attack := [ ] ;
57289: LD_ADDR_EXP 78
57293: PUSH
57294: EMPTY
57295: ST_TO_ADDR
// mc_produce := [ ] ;
57296: LD_ADDR_EXP 79
57300: PUSH
57301: EMPTY
57302: ST_TO_ADDR
// mc_defender := [ ] ;
57303: LD_ADDR_EXP 80
57307: PUSH
57308: EMPTY
57309: ST_TO_ADDR
// mc_parking := [ ] ;
57310: LD_ADDR_EXP 82
57314: PUSH
57315: EMPTY
57316: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57317: LD_ADDR_EXP 68
57321: PUSH
57322: EMPTY
57323: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57324: LD_ADDR_EXP 70
57328: PUSH
57329: EMPTY
57330: ST_TO_ADDR
// mc_scan := [ ] ;
57331: LD_ADDR_EXP 81
57335: PUSH
57336: EMPTY
57337: ST_TO_ADDR
// mc_scan_area := [ ] ;
57338: LD_ADDR_EXP 83
57342: PUSH
57343: EMPTY
57344: ST_TO_ADDR
// mc_tech := [ ] ;
57345: LD_ADDR_EXP 85
57349: PUSH
57350: EMPTY
57351: ST_TO_ADDR
// mc_class := [ ] ;
57352: LD_ADDR_EXP 99
57356: PUSH
57357: EMPTY
57358: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57359: LD_ADDR_EXP 100
57363: PUSH
57364: EMPTY
57365: ST_TO_ADDR
// end ;
57366: LD_VAR 0 1
57370: RET
// export function MC_Kill ( base ) ; begin
57371: LD_INT 0
57373: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57374: LD_ADDR_EXP 58
57378: PUSH
57379: LD_EXP 58
57383: PPUSH
57384: LD_VAR 0 1
57388: PPUSH
57389: EMPTY
57390: PPUSH
57391: CALL_OW 1
57395: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57396: LD_ADDR_EXP 59
57400: PUSH
57401: LD_EXP 59
57405: PPUSH
57406: LD_VAR 0 1
57410: PPUSH
57411: EMPTY
57412: PPUSH
57413: CALL_OW 1
57417: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57418: LD_ADDR_EXP 60
57422: PUSH
57423: LD_EXP 60
57427: PPUSH
57428: LD_VAR 0 1
57432: PPUSH
57433: EMPTY
57434: PPUSH
57435: CALL_OW 1
57439: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57440: LD_ADDR_EXP 61
57444: PUSH
57445: LD_EXP 61
57449: PPUSH
57450: LD_VAR 0 1
57454: PPUSH
57455: EMPTY
57456: PPUSH
57457: CALL_OW 1
57461: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57462: LD_ADDR_EXP 62
57466: PUSH
57467: LD_EXP 62
57471: PPUSH
57472: LD_VAR 0 1
57476: PPUSH
57477: EMPTY
57478: PPUSH
57479: CALL_OW 1
57483: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57484: LD_ADDR_EXP 63
57488: PUSH
57489: LD_EXP 63
57493: PPUSH
57494: LD_VAR 0 1
57498: PPUSH
57499: EMPTY
57500: PPUSH
57501: CALL_OW 1
57505: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57506: LD_ADDR_EXP 64
57510: PUSH
57511: LD_EXP 64
57515: PPUSH
57516: LD_VAR 0 1
57520: PPUSH
57521: EMPTY
57522: PPUSH
57523: CALL_OW 1
57527: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57528: LD_ADDR_EXP 65
57532: PUSH
57533: LD_EXP 65
57537: PPUSH
57538: LD_VAR 0 1
57542: PPUSH
57543: EMPTY
57544: PPUSH
57545: CALL_OW 1
57549: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57550: LD_ADDR_EXP 66
57554: PUSH
57555: LD_EXP 66
57559: PPUSH
57560: LD_VAR 0 1
57564: PPUSH
57565: EMPTY
57566: PPUSH
57567: CALL_OW 1
57571: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57572: LD_ADDR_EXP 67
57576: PUSH
57577: LD_EXP 67
57581: PPUSH
57582: LD_VAR 0 1
57586: PPUSH
57587: EMPTY
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57594: LD_ADDR_EXP 68
57598: PUSH
57599: LD_EXP 68
57603: PPUSH
57604: LD_VAR 0 1
57608: PPUSH
57609: EMPTY
57610: PPUSH
57611: CALL_OW 1
57615: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57616: LD_ADDR_EXP 69
57620: PUSH
57621: LD_EXP 69
57625: PPUSH
57626: LD_VAR 0 1
57630: PPUSH
57631: LD_INT 0
57633: PPUSH
57634: CALL_OW 1
57638: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57639: LD_ADDR_EXP 70
57643: PUSH
57644: LD_EXP 70
57648: PPUSH
57649: LD_VAR 0 1
57653: PPUSH
57654: EMPTY
57655: PPUSH
57656: CALL_OW 1
57660: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57661: LD_ADDR_EXP 71
57665: PUSH
57666: LD_EXP 71
57670: PPUSH
57671: LD_VAR 0 1
57675: PPUSH
57676: EMPTY
57677: PPUSH
57678: CALL_OW 1
57682: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57683: LD_ADDR_EXP 72
57687: PUSH
57688: LD_EXP 72
57692: PPUSH
57693: LD_VAR 0 1
57697: PPUSH
57698: EMPTY
57699: PPUSH
57700: CALL_OW 1
57704: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57705: LD_ADDR_EXP 73
57709: PUSH
57710: LD_EXP 73
57714: PPUSH
57715: LD_VAR 0 1
57719: PPUSH
57720: EMPTY
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57727: LD_ADDR_EXP 74
57731: PUSH
57732: LD_EXP 74
57736: PPUSH
57737: LD_VAR 0 1
57741: PPUSH
57742: EMPTY
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57749: LD_ADDR_EXP 75
57753: PUSH
57754: LD_EXP 75
57758: PPUSH
57759: LD_VAR 0 1
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57771: LD_ADDR_EXP 76
57775: PUSH
57776: LD_EXP 76
57780: PPUSH
57781: LD_VAR 0 1
57785: PPUSH
57786: EMPTY
57787: PPUSH
57788: CALL_OW 1
57792: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57793: LD_ADDR_EXP 77
57797: PUSH
57798: LD_EXP 77
57802: PPUSH
57803: LD_VAR 0 1
57807: PPUSH
57808: EMPTY
57809: PPUSH
57810: CALL_OW 1
57814: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57815: LD_ADDR_EXP 78
57819: PUSH
57820: LD_EXP 78
57824: PPUSH
57825: LD_VAR 0 1
57829: PPUSH
57830: EMPTY
57831: PPUSH
57832: CALL_OW 1
57836: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57837: LD_ADDR_EXP 79
57841: PUSH
57842: LD_EXP 79
57846: PPUSH
57847: LD_VAR 0 1
57851: PPUSH
57852: EMPTY
57853: PPUSH
57854: CALL_OW 1
57858: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57859: LD_ADDR_EXP 80
57863: PUSH
57864: LD_EXP 80
57868: PPUSH
57869: LD_VAR 0 1
57873: PPUSH
57874: EMPTY
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57881: LD_ADDR_EXP 81
57885: PUSH
57886: LD_EXP 81
57890: PPUSH
57891: LD_VAR 0 1
57895: PPUSH
57896: EMPTY
57897: PPUSH
57898: CALL_OW 1
57902: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57903: LD_ADDR_EXP 82
57907: PUSH
57908: LD_EXP 82
57912: PPUSH
57913: LD_VAR 0 1
57917: PPUSH
57918: EMPTY
57919: PPUSH
57920: CALL_OW 1
57924: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57925: LD_ADDR_EXP 83
57929: PUSH
57930: LD_EXP 83
57934: PPUSH
57935: LD_VAR 0 1
57939: PPUSH
57940: EMPTY
57941: PPUSH
57942: CALL_OW 1
57946: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57947: LD_ADDR_EXP 85
57951: PUSH
57952: LD_EXP 85
57956: PPUSH
57957: LD_VAR 0 1
57961: PPUSH
57962: EMPTY
57963: PPUSH
57964: CALL_OW 1
57968: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57969: LD_ADDR_EXP 87
57973: PUSH
57974: LD_EXP 87
57978: PPUSH
57979: LD_VAR 0 1
57983: PPUSH
57984: EMPTY
57985: PPUSH
57986: CALL_OW 1
57990: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57991: LD_ADDR_EXP 88
57995: PUSH
57996: LD_EXP 88
58000: PPUSH
58001: LD_VAR 0 1
58005: PPUSH
58006: EMPTY
58007: PPUSH
58008: CALL_OW 1
58012: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58013: LD_ADDR_EXP 89
58017: PUSH
58018: LD_EXP 89
58022: PPUSH
58023: LD_VAR 0 1
58027: PPUSH
58028: EMPTY
58029: PPUSH
58030: CALL_OW 1
58034: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58035: LD_ADDR_EXP 90
58039: PUSH
58040: LD_EXP 90
58044: PPUSH
58045: LD_VAR 0 1
58049: PPUSH
58050: EMPTY
58051: PPUSH
58052: CALL_OW 1
58056: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58057: LD_ADDR_EXP 91
58061: PUSH
58062: LD_EXP 91
58066: PPUSH
58067: LD_VAR 0 1
58071: PPUSH
58072: EMPTY
58073: PPUSH
58074: CALL_OW 1
58078: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58079: LD_ADDR_EXP 92
58083: PUSH
58084: LD_EXP 92
58088: PPUSH
58089: LD_VAR 0 1
58093: PPUSH
58094: EMPTY
58095: PPUSH
58096: CALL_OW 1
58100: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58101: LD_ADDR_EXP 93
58105: PUSH
58106: LD_EXP 93
58110: PPUSH
58111: LD_VAR 0 1
58115: PPUSH
58116: EMPTY
58117: PPUSH
58118: CALL_OW 1
58122: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58123: LD_ADDR_EXP 94
58127: PUSH
58128: LD_EXP 94
58132: PPUSH
58133: LD_VAR 0 1
58137: PPUSH
58138: EMPTY
58139: PPUSH
58140: CALL_OW 1
58144: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58145: LD_ADDR_EXP 95
58149: PUSH
58150: LD_EXP 95
58154: PPUSH
58155: LD_VAR 0 1
58159: PPUSH
58160: EMPTY
58161: PPUSH
58162: CALL_OW 1
58166: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58167: LD_ADDR_EXP 96
58171: PUSH
58172: LD_EXP 96
58176: PPUSH
58177: LD_VAR 0 1
58181: PPUSH
58182: EMPTY
58183: PPUSH
58184: CALL_OW 1
58188: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58189: LD_ADDR_EXP 97
58193: PUSH
58194: LD_EXP 97
58198: PPUSH
58199: LD_VAR 0 1
58203: PPUSH
58204: EMPTY
58205: PPUSH
58206: CALL_OW 1
58210: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58211: LD_ADDR_EXP 98
58215: PUSH
58216: LD_EXP 98
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: EMPTY
58227: PPUSH
58228: CALL_OW 1
58232: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58233: LD_ADDR_EXP 99
58237: PUSH
58238: LD_EXP 99
58242: PPUSH
58243: LD_VAR 0 1
58247: PPUSH
58248: EMPTY
58249: PPUSH
58250: CALL_OW 1
58254: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58255: LD_ADDR_EXP 100
58259: PUSH
58260: LD_EXP 100
58264: PPUSH
58265: LD_VAR 0 1
58269: PPUSH
58270: LD_INT 0
58272: PPUSH
58273: CALL_OW 1
58277: ST_TO_ADDR
// end ;
58278: LD_VAR 0 2
58282: RET
// export function MC_Add ( side , units ) ; var base ; begin
58283: LD_INT 0
58285: PPUSH
58286: PPUSH
// base := mc_bases + 1 ;
58287: LD_ADDR_VAR 0 4
58291: PUSH
58292: LD_EXP 58
58296: PUSH
58297: LD_INT 1
58299: PLUS
58300: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58301: LD_ADDR_EXP 84
58305: PUSH
58306: LD_EXP 84
58310: PPUSH
58311: LD_VAR 0 4
58315: PPUSH
58316: LD_VAR 0 1
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58326: LD_ADDR_EXP 58
58330: PUSH
58331: LD_EXP 58
58335: PPUSH
58336: LD_VAR 0 4
58340: PPUSH
58341: LD_VAR 0 2
58345: PPUSH
58346: CALL_OW 1
58350: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58351: LD_ADDR_EXP 59
58355: PUSH
58356: LD_EXP 59
58360: PPUSH
58361: LD_VAR 0 4
58365: PPUSH
58366: EMPTY
58367: PPUSH
58368: CALL_OW 1
58372: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58373: LD_ADDR_EXP 60
58377: PUSH
58378: LD_EXP 60
58382: PPUSH
58383: LD_VAR 0 4
58387: PPUSH
58388: EMPTY
58389: PPUSH
58390: CALL_OW 1
58394: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58395: LD_ADDR_EXP 61
58399: PUSH
58400: LD_EXP 61
58404: PPUSH
58405: LD_VAR 0 4
58409: PPUSH
58410: EMPTY
58411: PPUSH
58412: CALL_OW 1
58416: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58417: LD_ADDR_EXP 62
58421: PUSH
58422: LD_EXP 62
58426: PPUSH
58427: LD_VAR 0 4
58431: PPUSH
58432: EMPTY
58433: PPUSH
58434: CALL_OW 1
58438: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58439: LD_ADDR_EXP 63
58443: PUSH
58444: LD_EXP 63
58448: PPUSH
58449: LD_VAR 0 4
58453: PPUSH
58454: EMPTY
58455: PPUSH
58456: CALL_OW 1
58460: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58461: LD_ADDR_EXP 64
58465: PUSH
58466: LD_EXP 64
58470: PPUSH
58471: LD_VAR 0 4
58475: PPUSH
58476: EMPTY
58477: PPUSH
58478: CALL_OW 1
58482: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58483: LD_ADDR_EXP 65
58487: PUSH
58488: LD_EXP 65
58492: PPUSH
58493: LD_VAR 0 4
58497: PPUSH
58498: EMPTY
58499: PPUSH
58500: CALL_OW 1
58504: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58505: LD_ADDR_EXP 66
58509: PUSH
58510: LD_EXP 66
58514: PPUSH
58515: LD_VAR 0 4
58519: PPUSH
58520: EMPTY
58521: PPUSH
58522: CALL_OW 1
58526: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58527: LD_ADDR_EXP 67
58531: PUSH
58532: LD_EXP 67
58536: PPUSH
58537: LD_VAR 0 4
58541: PPUSH
58542: EMPTY
58543: PPUSH
58544: CALL_OW 1
58548: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58549: LD_ADDR_EXP 68
58553: PUSH
58554: LD_EXP 68
58558: PPUSH
58559: LD_VAR 0 4
58563: PPUSH
58564: EMPTY
58565: PPUSH
58566: CALL_OW 1
58570: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58571: LD_ADDR_EXP 69
58575: PUSH
58576: LD_EXP 69
58580: PPUSH
58581: LD_VAR 0 4
58585: PPUSH
58586: LD_INT 0
58588: PPUSH
58589: CALL_OW 1
58593: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58594: LD_ADDR_EXP 70
58598: PUSH
58599: LD_EXP 70
58603: PPUSH
58604: LD_VAR 0 4
58608: PPUSH
58609: EMPTY
58610: PPUSH
58611: CALL_OW 1
58615: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58616: LD_ADDR_EXP 71
58620: PUSH
58621: LD_EXP 71
58625: PPUSH
58626: LD_VAR 0 4
58630: PPUSH
58631: EMPTY
58632: PPUSH
58633: CALL_OW 1
58637: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58638: LD_ADDR_EXP 72
58642: PUSH
58643: LD_EXP 72
58647: PPUSH
58648: LD_VAR 0 4
58652: PPUSH
58653: EMPTY
58654: PPUSH
58655: CALL_OW 1
58659: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58660: LD_ADDR_EXP 73
58664: PUSH
58665: LD_EXP 73
58669: PPUSH
58670: LD_VAR 0 4
58674: PPUSH
58675: EMPTY
58676: PPUSH
58677: CALL_OW 1
58681: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58682: LD_ADDR_EXP 74
58686: PUSH
58687: LD_EXP 74
58691: PPUSH
58692: LD_VAR 0 4
58696: PPUSH
58697: EMPTY
58698: PPUSH
58699: CALL_OW 1
58703: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58704: LD_ADDR_EXP 75
58708: PUSH
58709: LD_EXP 75
58713: PPUSH
58714: LD_VAR 0 4
58718: PPUSH
58719: EMPTY
58720: PPUSH
58721: CALL_OW 1
58725: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58726: LD_ADDR_EXP 76
58730: PUSH
58731: LD_EXP 76
58735: PPUSH
58736: LD_VAR 0 4
58740: PPUSH
58741: EMPTY
58742: PPUSH
58743: CALL_OW 1
58747: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58748: LD_ADDR_EXP 77
58752: PUSH
58753: LD_EXP 77
58757: PPUSH
58758: LD_VAR 0 4
58762: PPUSH
58763: EMPTY
58764: PPUSH
58765: CALL_OW 1
58769: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58770: LD_ADDR_EXP 78
58774: PUSH
58775: LD_EXP 78
58779: PPUSH
58780: LD_VAR 0 4
58784: PPUSH
58785: EMPTY
58786: PPUSH
58787: CALL_OW 1
58791: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58792: LD_ADDR_EXP 79
58796: PUSH
58797: LD_EXP 79
58801: PPUSH
58802: LD_VAR 0 4
58806: PPUSH
58807: EMPTY
58808: PPUSH
58809: CALL_OW 1
58813: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58814: LD_ADDR_EXP 80
58818: PUSH
58819: LD_EXP 80
58823: PPUSH
58824: LD_VAR 0 4
58828: PPUSH
58829: EMPTY
58830: PPUSH
58831: CALL_OW 1
58835: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58836: LD_ADDR_EXP 81
58840: PUSH
58841: LD_EXP 81
58845: PPUSH
58846: LD_VAR 0 4
58850: PPUSH
58851: EMPTY
58852: PPUSH
58853: CALL_OW 1
58857: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58858: LD_ADDR_EXP 82
58862: PUSH
58863: LD_EXP 82
58867: PPUSH
58868: LD_VAR 0 4
58872: PPUSH
58873: EMPTY
58874: PPUSH
58875: CALL_OW 1
58879: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58880: LD_ADDR_EXP 83
58884: PUSH
58885: LD_EXP 83
58889: PPUSH
58890: LD_VAR 0 4
58894: PPUSH
58895: EMPTY
58896: PPUSH
58897: CALL_OW 1
58901: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58902: LD_ADDR_EXP 85
58906: PUSH
58907: LD_EXP 85
58911: PPUSH
58912: LD_VAR 0 4
58916: PPUSH
58917: EMPTY
58918: PPUSH
58919: CALL_OW 1
58923: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58924: LD_ADDR_EXP 87
58928: PUSH
58929: LD_EXP 87
58933: PPUSH
58934: LD_VAR 0 4
58938: PPUSH
58939: EMPTY
58940: PPUSH
58941: CALL_OW 1
58945: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58946: LD_ADDR_EXP 88
58950: PUSH
58951: LD_EXP 88
58955: PPUSH
58956: LD_VAR 0 4
58960: PPUSH
58961: EMPTY
58962: PPUSH
58963: CALL_OW 1
58967: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58968: LD_ADDR_EXP 89
58972: PUSH
58973: LD_EXP 89
58977: PPUSH
58978: LD_VAR 0 4
58982: PPUSH
58983: EMPTY
58984: PPUSH
58985: CALL_OW 1
58989: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58990: LD_ADDR_EXP 90
58994: PUSH
58995: LD_EXP 90
58999: PPUSH
59000: LD_VAR 0 4
59004: PPUSH
59005: EMPTY
59006: PPUSH
59007: CALL_OW 1
59011: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59012: LD_ADDR_EXP 91
59016: PUSH
59017: LD_EXP 91
59021: PPUSH
59022: LD_VAR 0 4
59026: PPUSH
59027: EMPTY
59028: PPUSH
59029: CALL_OW 1
59033: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59034: LD_ADDR_EXP 92
59038: PUSH
59039: LD_EXP 92
59043: PPUSH
59044: LD_VAR 0 4
59048: PPUSH
59049: EMPTY
59050: PPUSH
59051: CALL_OW 1
59055: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59056: LD_ADDR_EXP 93
59060: PUSH
59061: LD_EXP 93
59065: PPUSH
59066: LD_VAR 0 4
59070: PPUSH
59071: EMPTY
59072: PPUSH
59073: CALL_OW 1
59077: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59078: LD_ADDR_EXP 94
59082: PUSH
59083: LD_EXP 94
59087: PPUSH
59088: LD_VAR 0 4
59092: PPUSH
59093: EMPTY
59094: PPUSH
59095: CALL_OW 1
59099: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59100: LD_ADDR_EXP 95
59104: PUSH
59105: LD_EXP 95
59109: PPUSH
59110: LD_VAR 0 4
59114: PPUSH
59115: EMPTY
59116: PPUSH
59117: CALL_OW 1
59121: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59122: LD_ADDR_EXP 96
59126: PUSH
59127: LD_EXP 96
59131: PPUSH
59132: LD_VAR 0 4
59136: PPUSH
59137: EMPTY
59138: PPUSH
59139: CALL_OW 1
59143: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59144: LD_ADDR_EXP 97
59148: PUSH
59149: LD_EXP 97
59153: PPUSH
59154: LD_VAR 0 4
59158: PPUSH
59159: EMPTY
59160: PPUSH
59161: CALL_OW 1
59165: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59166: LD_ADDR_EXP 98
59170: PUSH
59171: LD_EXP 98
59175: PPUSH
59176: LD_VAR 0 4
59180: PPUSH
59181: EMPTY
59182: PPUSH
59183: CALL_OW 1
59187: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59188: LD_ADDR_EXP 99
59192: PUSH
59193: LD_EXP 99
59197: PPUSH
59198: LD_VAR 0 4
59202: PPUSH
59203: EMPTY
59204: PPUSH
59205: CALL_OW 1
59209: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59210: LD_ADDR_EXP 100
59214: PUSH
59215: LD_EXP 100
59219: PPUSH
59220: LD_VAR 0 4
59224: PPUSH
59225: LD_INT 0
59227: PPUSH
59228: CALL_OW 1
59232: ST_TO_ADDR
// result := base ;
59233: LD_ADDR_VAR 0 3
59237: PUSH
59238: LD_VAR 0 4
59242: ST_TO_ADDR
// end ;
59243: LD_VAR 0 3
59247: RET
// export function MC_Start ( ) ; var i ; begin
59248: LD_INT 0
59250: PPUSH
59251: PPUSH
// for i = 1 to mc_bases do
59252: LD_ADDR_VAR 0 2
59256: PUSH
59257: DOUBLE
59258: LD_INT 1
59260: DEC
59261: ST_TO_ADDR
59262: LD_EXP 58
59266: PUSH
59267: FOR_TO
59268: IFFALSE 60345
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59270: LD_ADDR_EXP 58
59274: PUSH
59275: LD_EXP 58
59279: PPUSH
59280: LD_VAR 0 2
59284: PPUSH
59285: LD_EXP 58
59289: PUSH
59290: LD_VAR 0 2
59294: ARRAY
59295: PUSH
59296: LD_INT 0
59298: DIFF
59299: PPUSH
59300: CALL_OW 1
59304: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59305: LD_ADDR_EXP 59
59309: PUSH
59310: LD_EXP 59
59314: PPUSH
59315: LD_VAR 0 2
59319: PPUSH
59320: EMPTY
59321: PPUSH
59322: CALL_OW 1
59326: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59327: LD_ADDR_EXP 60
59331: PUSH
59332: LD_EXP 60
59336: PPUSH
59337: LD_VAR 0 2
59341: PPUSH
59342: EMPTY
59343: PPUSH
59344: CALL_OW 1
59348: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59349: LD_ADDR_EXP 61
59353: PUSH
59354: LD_EXP 61
59358: PPUSH
59359: LD_VAR 0 2
59363: PPUSH
59364: EMPTY
59365: PPUSH
59366: CALL_OW 1
59370: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59371: LD_ADDR_EXP 62
59375: PUSH
59376: LD_EXP 62
59380: PPUSH
59381: LD_VAR 0 2
59385: PPUSH
59386: EMPTY
59387: PUSH
59388: EMPTY
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: PPUSH
59394: CALL_OW 1
59398: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59399: LD_ADDR_EXP 63
59403: PUSH
59404: LD_EXP 63
59408: PPUSH
59409: LD_VAR 0 2
59413: PPUSH
59414: EMPTY
59415: PPUSH
59416: CALL_OW 1
59420: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59421: LD_ADDR_EXP 90
59425: PUSH
59426: LD_EXP 90
59430: PPUSH
59431: LD_VAR 0 2
59435: PPUSH
59436: EMPTY
59437: PPUSH
59438: CALL_OW 1
59442: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59443: LD_ADDR_EXP 64
59447: PUSH
59448: LD_EXP 64
59452: PPUSH
59453: LD_VAR 0 2
59457: PPUSH
59458: EMPTY
59459: PPUSH
59460: CALL_OW 1
59464: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59465: LD_ADDR_EXP 65
59469: PUSH
59470: LD_EXP 65
59474: PPUSH
59475: LD_VAR 0 2
59479: PPUSH
59480: EMPTY
59481: PPUSH
59482: CALL_OW 1
59486: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59487: LD_ADDR_EXP 66
59491: PUSH
59492: LD_EXP 66
59496: PPUSH
59497: LD_VAR 0 2
59501: PPUSH
59502: LD_EXP 58
59506: PUSH
59507: LD_VAR 0 2
59511: ARRAY
59512: PPUSH
59513: LD_INT 2
59515: PUSH
59516: LD_INT 30
59518: PUSH
59519: LD_INT 32
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PUSH
59526: LD_INT 30
59528: PUSH
59529: LD_INT 33
59531: PUSH
59532: EMPTY
59533: LIST
59534: LIST
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: PPUSH
59541: CALL_OW 72
59545: PPUSH
59546: CALL_OW 1
59550: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59551: LD_ADDR_EXP 67
59555: PUSH
59556: LD_EXP 67
59560: PPUSH
59561: LD_VAR 0 2
59565: PPUSH
59566: LD_EXP 58
59570: PUSH
59571: LD_VAR 0 2
59575: ARRAY
59576: PPUSH
59577: LD_INT 2
59579: PUSH
59580: LD_INT 30
59582: PUSH
59583: LD_INT 32
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: PUSH
59590: LD_INT 30
59592: PUSH
59593: LD_INT 31
59595: PUSH
59596: EMPTY
59597: LIST
59598: LIST
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: LIST
59604: PUSH
59605: LD_INT 58
59607: PUSH
59608: EMPTY
59609: LIST
59610: PUSH
59611: EMPTY
59612: LIST
59613: LIST
59614: PPUSH
59615: CALL_OW 72
59619: PPUSH
59620: CALL_OW 1
59624: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59625: LD_ADDR_EXP 68
59629: PUSH
59630: LD_EXP 68
59634: PPUSH
59635: LD_VAR 0 2
59639: PPUSH
59640: EMPTY
59641: PPUSH
59642: CALL_OW 1
59646: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59647: LD_ADDR_EXP 72
59651: PUSH
59652: LD_EXP 72
59656: PPUSH
59657: LD_VAR 0 2
59661: PPUSH
59662: EMPTY
59663: PPUSH
59664: CALL_OW 1
59668: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59669: LD_ADDR_EXP 71
59673: PUSH
59674: LD_EXP 71
59678: PPUSH
59679: LD_VAR 0 2
59683: PPUSH
59684: EMPTY
59685: PPUSH
59686: CALL_OW 1
59690: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59691: LD_ADDR_EXP 73
59695: PUSH
59696: LD_EXP 73
59700: PPUSH
59701: LD_VAR 0 2
59705: PPUSH
59706: EMPTY
59707: PPUSH
59708: CALL_OW 1
59712: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59713: LD_ADDR_EXP 74
59717: PUSH
59718: LD_EXP 74
59722: PPUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: EMPTY
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59735: LD_ADDR_EXP 75
59739: PUSH
59740: LD_EXP 75
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59757: LD_ADDR_EXP 76
59761: PUSH
59762: LD_EXP 76
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59779: LD_ADDR_EXP 77
59783: PUSH
59784: LD_EXP 77
59788: PPUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: EMPTY
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59801: LD_ADDR_EXP 78
59805: PUSH
59806: LD_EXP 78
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59823: LD_ADDR_EXP 79
59827: PUSH
59828: LD_EXP 79
59832: PPUSH
59833: LD_VAR 0 2
59837: PPUSH
59838: EMPTY
59839: PPUSH
59840: CALL_OW 1
59844: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59845: LD_ADDR_EXP 80
59849: PUSH
59850: LD_EXP 80
59854: PPUSH
59855: LD_VAR 0 2
59859: PPUSH
59860: EMPTY
59861: PPUSH
59862: CALL_OW 1
59866: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59867: LD_ADDR_EXP 69
59871: PUSH
59872: LD_EXP 69
59876: PPUSH
59877: LD_VAR 0 2
59881: PPUSH
59882: LD_INT 0
59884: PPUSH
59885: CALL_OW 1
59889: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59890: LD_ADDR_EXP 82
59894: PUSH
59895: LD_EXP 82
59899: PPUSH
59900: LD_VAR 0 2
59904: PPUSH
59905: LD_INT 0
59907: PPUSH
59908: CALL_OW 1
59912: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59913: LD_ADDR_EXP 70
59917: PUSH
59918: LD_EXP 70
59922: PPUSH
59923: LD_VAR 0 2
59927: PPUSH
59928: EMPTY
59929: PPUSH
59930: CALL_OW 1
59934: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59935: LD_ADDR_EXP 81
59939: PUSH
59940: LD_EXP 81
59944: PPUSH
59945: LD_VAR 0 2
59949: PPUSH
59950: LD_INT 0
59952: PPUSH
59953: CALL_OW 1
59957: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59958: LD_ADDR_EXP 83
59962: PUSH
59963: LD_EXP 83
59967: PPUSH
59968: LD_VAR 0 2
59972: PPUSH
59973: EMPTY
59974: PPUSH
59975: CALL_OW 1
59979: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59980: LD_ADDR_EXP 86
59984: PUSH
59985: LD_EXP 86
59989: PPUSH
59990: LD_VAR 0 2
59994: PPUSH
59995: LD_INT 0
59997: PPUSH
59998: CALL_OW 1
60002: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60003: LD_ADDR_EXP 87
60007: PUSH
60008: LD_EXP 87
60012: PPUSH
60013: LD_VAR 0 2
60017: PPUSH
60018: EMPTY
60019: PPUSH
60020: CALL_OW 1
60024: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60025: LD_ADDR_EXP 88
60029: PUSH
60030: LD_EXP 88
60034: PPUSH
60035: LD_VAR 0 2
60039: PPUSH
60040: EMPTY
60041: PPUSH
60042: CALL_OW 1
60046: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60047: LD_ADDR_EXP 89
60051: PUSH
60052: LD_EXP 89
60056: PPUSH
60057: LD_VAR 0 2
60061: PPUSH
60062: EMPTY
60063: PPUSH
60064: CALL_OW 1
60068: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60069: LD_ADDR_EXP 91
60073: PUSH
60074: LD_EXP 91
60078: PPUSH
60079: LD_VAR 0 2
60083: PPUSH
60084: LD_EXP 58
60088: PUSH
60089: LD_VAR 0 2
60093: ARRAY
60094: PPUSH
60095: LD_INT 2
60097: PUSH
60098: LD_INT 30
60100: PUSH
60101: LD_INT 6
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: PUSH
60108: LD_INT 30
60110: PUSH
60111: LD_INT 7
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PUSH
60118: LD_INT 30
60120: PUSH
60121: LD_INT 8
60123: PUSH
60124: EMPTY
60125: LIST
60126: LIST
60127: PUSH
60128: EMPTY
60129: LIST
60130: LIST
60131: LIST
60132: LIST
60133: PPUSH
60134: CALL_OW 72
60138: PPUSH
60139: CALL_OW 1
60143: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60144: LD_ADDR_EXP 92
60148: PUSH
60149: LD_EXP 92
60153: PPUSH
60154: LD_VAR 0 2
60158: PPUSH
60159: EMPTY
60160: PPUSH
60161: CALL_OW 1
60165: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60166: LD_ADDR_EXP 93
60170: PUSH
60171: LD_EXP 93
60175: PPUSH
60176: LD_VAR 0 2
60180: PPUSH
60181: EMPTY
60182: PPUSH
60183: CALL_OW 1
60187: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60188: LD_ADDR_EXP 94
60192: PUSH
60193: LD_EXP 94
60197: PPUSH
60198: LD_VAR 0 2
60202: PPUSH
60203: EMPTY
60204: PPUSH
60205: CALL_OW 1
60209: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60210: LD_ADDR_EXP 95
60214: PUSH
60215: LD_EXP 95
60219: PPUSH
60220: LD_VAR 0 2
60224: PPUSH
60225: EMPTY
60226: PPUSH
60227: CALL_OW 1
60231: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60232: LD_ADDR_EXP 96
60236: PUSH
60237: LD_EXP 96
60241: PPUSH
60242: LD_VAR 0 2
60246: PPUSH
60247: EMPTY
60248: PPUSH
60249: CALL_OW 1
60253: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60254: LD_ADDR_EXP 97
60258: PUSH
60259: LD_EXP 97
60263: PPUSH
60264: LD_VAR 0 2
60268: PPUSH
60269: EMPTY
60270: PPUSH
60271: CALL_OW 1
60275: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60276: LD_ADDR_EXP 98
60280: PUSH
60281: LD_EXP 98
60285: PPUSH
60286: LD_VAR 0 2
60290: PPUSH
60291: EMPTY
60292: PPUSH
60293: CALL_OW 1
60297: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60298: LD_ADDR_EXP 99
60302: PUSH
60303: LD_EXP 99
60307: PPUSH
60308: LD_VAR 0 2
60312: PPUSH
60313: EMPTY
60314: PPUSH
60315: CALL_OW 1
60319: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60320: LD_ADDR_EXP 100
60324: PUSH
60325: LD_EXP 100
60329: PPUSH
60330: LD_VAR 0 2
60334: PPUSH
60335: LD_INT 0
60337: PPUSH
60338: CALL_OW 1
60342: ST_TO_ADDR
// end ;
60343: GO 59267
60345: POP
60346: POP
// MC_InitSides ( ) ;
60347: CALL 60633 0 0
// MC_InitResearch ( ) ;
60351: CALL 60372 0 0
// CustomInitMacro ( ) ;
60355: CALL 181 0 0
// skirmish := true ;
60359: LD_ADDR_EXP 56
60363: PUSH
60364: LD_INT 1
60366: ST_TO_ADDR
// end ;
60367: LD_VAR 0 1
60371: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60372: LD_INT 0
60374: PPUSH
60375: PPUSH
60376: PPUSH
60377: PPUSH
60378: PPUSH
60379: PPUSH
// if not mc_bases then
60380: LD_EXP 58
60384: NOT
60385: IFFALSE 60389
// exit ;
60387: GO 60628
// for i = 1 to 8 do
60389: LD_ADDR_VAR 0 2
60393: PUSH
60394: DOUBLE
60395: LD_INT 1
60397: DEC
60398: ST_TO_ADDR
60399: LD_INT 8
60401: PUSH
60402: FOR_TO
60403: IFFALSE 60429
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60405: LD_ADDR_EXP 85
60409: PUSH
60410: LD_EXP 85
60414: PPUSH
60415: LD_VAR 0 2
60419: PPUSH
60420: EMPTY
60421: PPUSH
60422: CALL_OW 1
60426: ST_TO_ADDR
60427: GO 60402
60429: POP
60430: POP
// tmp := [ ] ;
60431: LD_ADDR_VAR 0 5
60435: PUSH
60436: EMPTY
60437: ST_TO_ADDR
// for i = 1 to mc_sides do
60438: LD_ADDR_VAR 0 2
60442: PUSH
60443: DOUBLE
60444: LD_INT 1
60446: DEC
60447: ST_TO_ADDR
60448: LD_EXP 84
60452: PUSH
60453: FOR_TO
60454: IFFALSE 60512
// if not mc_sides [ i ] in tmp then
60456: LD_EXP 84
60460: PUSH
60461: LD_VAR 0 2
60465: ARRAY
60466: PUSH
60467: LD_VAR 0 5
60471: IN
60472: NOT
60473: IFFALSE 60510
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60475: LD_ADDR_VAR 0 5
60479: PUSH
60480: LD_VAR 0 5
60484: PPUSH
60485: LD_VAR 0 5
60489: PUSH
60490: LD_INT 1
60492: PLUS
60493: PPUSH
60494: LD_EXP 84
60498: PUSH
60499: LD_VAR 0 2
60503: ARRAY
60504: PPUSH
60505: CALL_OW 2
60509: ST_TO_ADDR
60510: GO 60453
60512: POP
60513: POP
// if not tmp then
60514: LD_VAR 0 5
60518: NOT
60519: IFFALSE 60523
// exit ;
60521: GO 60628
// for j in tmp do
60523: LD_ADDR_VAR 0 3
60527: PUSH
60528: LD_VAR 0 5
60532: PUSH
60533: FOR_IN
60534: IFFALSE 60626
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60536: LD_ADDR_VAR 0 6
60540: PUSH
60541: LD_INT 22
60543: PUSH
60544: LD_VAR 0 3
60548: PUSH
60549: EMPTY
60550: LIST
60551: LIST
60552: PPUSH
60553: CALL_OW 69
60557: ST_TO_ADDR
// if not un then
60558: LD_VAR 0 6
60562: NOT
60563: IFFALSE 60567
// continue ;
60565: GO 60533
// nation := GetNation ( un [ 1 ] ) ;
60567: LD_ADDR_VAR 0 4
60571: PUSH
60572: LD_VAR 0 6
60576: PUSH
60577: LD_INT 1
60579: ARRAY
60580: PPUSH
60581: CALL_OW 248
60585: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60586: LD_ADDR_EXP 85
60590: PUSH
60591: LD_EXP 85
60595: PPUSH
60596: LD_VAR 0 3
60600: PPUSH
60601: LD_VAR 0 3
60605: PPUSH
60606: LD_VAR 0 4
60610: PPUSH
60611: LD_INT 1
60613: PPUSH
60614: CALL 14126 0 3
60618: PPUSH
60619: CALL_OW 1
60623: ST_TO_ADDR
// end ;
60624: GO 60533
60626: POP
60627: POP
// end ;
60628: LD_VAR 0 1
60632: RET
// export function MC_InitSides ( ) ; var i ; begin
60633: LD_INT 0
60635: PPUSH
60636: PPUSH
// if not mc_bases then
60637: LD_EXP 58
60641: NOT
60642: IFFALSE 60646
// exit ;
60644: GO 60720
// for i = 1 to mc_bases do
60646: LD_ADDR_VAR 0 2
60650: PUSH
60651: DOUBLE
60652: LD_INT 1
60654: DEC
60655: ST_TO_ADDR
60656: LD_EXP 58
60660: PUSH
60661: FOR_TO
60662: IFFALSE 60718
// if mc_bases [ i ] then
60664: LD_EXP 58
60668: PUSH
60669: LD_VAR 0 2
60673: ARRAY
60674: IFFALSE 60716
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60676: LD_ADDR_EXP 84
60680: PUSH
60681: LD_EXP 84
60685: PPUSH
60686: LD_VAR 0 2
60690: PPUSH
60691: LD_EXP 58
60695: PUSH
60696: LD_VAR 0 2
60700: ARRAY
60701: PUSH
60702: LD_INT 1
60704: ARRAY
60705: PPUSH
60706: CALL_OW 255
60710: PPUSH
60711: CALL_OW 1
60715: ST_TO_ADDR
60716: GO 60661
60718: POP
60719: POP
// end ;
60720: LD_VAR 0 1
60724: RET
// every 0 0$01 trigger skirmish do
60725: LD_EXP 56
60729: IFFALSE 60883
60731: GO 60733
60733: DISABLE
// begin enable ;
60734: ENABLE
// MC_CheckBuildings ( ) ;
60735: CALL 65381 0 0
// MC_CheckPeopleLife ( ) ;
60739: CALL 65506 0 0
// RaiseSailEvent ( 100 ) ;
60743: LD_INT 100
60745: PPUSH
60746: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60750: LD_INT 103
60752: PPUSH
60753: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60757: LD_INT 104
60759: PPUSH
60760: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60764: LD_INT 105
60766: PPUSH
60767: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60771: LD_INT 106
60773: PPUSH
60774: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60778: LD_INT 107
60780: PPUSH
60781: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60785: LD_INT 108
60787: PPUSH
60788: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60792: LD_INT 109
60794: PPUSH
60795: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60799: LD_INT 110
60801: PPUSH
60802: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60806: LD_INT 111
60808: PPUSH
60809: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60813: LD_INT 112
60815: PPUSH
60816: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60820: LD_INT 113
60822: PPUSH
60823: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60827: LD_INT 120
60829: PPUSH
60830: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60834: LD_INT 121
60836: PPUSH
60837: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60841: LD_INT 122
60843: PPUSH
60844: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60848: LD_INT 123
60850: PPUSH
60851: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60855: LD_INT 124
60857: PPUSH
60858: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60862: LD_INT 125
60864: PPUSH
60865: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60869: LD_INT 126
60871: PPUSH
60872: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60876: LD_INT 200
60878: PPUSH
60879: CALL_OW 427
// end ;
60883: END
// on SailEvent ( event ) do begin if event < 100 then
60884: LD_VAR 0 1
60888: PUSH
60889: LD_INT 100
60891: LESS
60892: IFFALSE 60903
// CustomEvent ( event ) ;
60894: LD_VAR 0 1
60898: PPUSH
60899: CALL 12828 0 1
// if event = 100 then
60903: LD_VAR 0 1
60907: PUSH
60908: LD_INT 100
60910: EQUAL
60911: IFFALSE 60917
// MC_ClassManager ( ) ;
60913: CALL 61309 0 0
// if event = 101 then
60917: LD_VAR 0 1
60921: PUSH
60922: LD_INT 101
60924: EQUAL
60925: IFFALSE 60931
// MC_RepairBuildings ( ) ;
60927: CALL 66102 0 0
// if event = 102 then
60931: LD_VAR 0 1
60935: PUSH
60936: LD_INT 102
60938: EQUAL
60939: IFFALSE 60945
// MC_Heal ( ) ;
60941: CALL 66834 0 0
// if event = 103 then
60945: LD_VAR 0 1
60949: PUSH
60950: LD_INT 103
60952: EQUAL
60953: IFFALSE 60959
// MC_Build ( ) ;
60955: CALL 67256 0 0
// if event = 104 then
60959: LD_VAR 0 1
60963: PUSH
60964: LD_INT 104
60966: EQUAL
60967: IFFALSE 60973
// MC_TurretWeapon ( ) ;
60969: CALL 68869 0 0
// if event = 105 then
60973: LD_VAR 0 1
60977: PUSH
60978: LD_INT 105
60980: EQUAL
60981: IFFALSE 60987
// MC_BuildUpgrade ( ) ;
60983: CALL 68420 0 0
// if event = 106 then
60987: LD_VAR 0 1
60991: PUSH
60992: LD_INT 106
60994: EQUAL
60995: IFFALSE 61001
// MC_PlantMines ( ) ;
60997: CALL 69299 0 0
// if event = 107 then
61001: LD_VAR 0 1
61005: PUSH
61006: LD_INT 107
61008: EQUAL
61009: IFFALSE 61015
// MC_CollectCrates ( ) ;
61011: CALL 70333 0 0
// if event = 108 then
61015: LD_VAR 0 1
61019: PUSH
61020: LD_INT 108
61022: EQUAL
61023: IFFALSE 61029
// MC_LinkRemoteControl ( ) ;
61025: CALL 72109 0 0
// if event = 109 then
61029: LD_VAR 0 1
61033: PUSH
61034: LD_INT 109
61036: EQUAL
61037: IFFALSE 61043
// MC_ProduceVehicle ( ) ;
61039: CALL 72290 0 0
// if event = 110 then
61043: LD_VAR 0 1
61047: PUSH
61048: LD_INT 110
61050: EQUAL
61051: IFFALSE 61057
// MC_SendAttack ( ) ;
61053: CALL 72756 0 0
// if event = 111 then
61057: LD_VAR 0 1
61061: PUSH
61062: LD_INT 111
61064: EQUAL
61065: IFFALSE 61071
// MC_Defend ( ) ;
61067: CALL 72864 0 0
// if event = 112 then
61071: LD_VAR 0 1
61075: PUSH
61076: LD_INT 112
61078: EQUAL
61079: IFFALSE 61085
// MC_Research ( ) ;
61081: CALL 73469 0 0
// if event = 113 then
61085: LD_VAR 0 1
61089: PUSH
61090: LD_INT 113
61092: EQUAL
61093: IFFALSE 61099
// MC_MinesTrigger ( ) ;
61095: CALL 74583 0 0
// if event = 120 then
61099: LD_VAR 0 1
61103: PUSH
61104: LD_INT 120
61106: EQUAL
61107: IFFALSE 61113
// MC_RepairVehicle ( ) ;
61109: CALL 74682 0 0
// if event = 121 then
61113: LD_VAR 0 1
61117: PUSH
61118: LD_INT 121
61120: EQUAL
61121: IFFALSE 61127
// MC_TameApe ( ) ;
61123: CALL 75412 0 0
// if event = 122 then
61127: LD_VAR 0 1
61131: PUSH
61132: LD_INT 122
61134: EQUAL
61135: IFFALSE 61141
// MC_ChangeApeClass ( ) ;
61137: CALL 76241 0 0
// if event = 123 then
61141: LD_VAR 0 1
61145: PUSH
61146: LD_INT 123
61148: EQUAL
61149: IFFALSE 61155
// MC_Bazooka ( ) ;
61151: CALL 76891 0 0
// if event = 124 then
61155: LD_VAR 0 1
61159: PUSH
61160: LD_INT 124
61162: EQUAL
61163: IFFALSE 61169
// MC_TeleportExit ( ) ;
61165: CALL 77089 0 0
// if event = 125 then
61169: LD_VAR 0 1
61173: PUSH
61174: LD_INT 125
61176: EQUAL
61177: IFFALSE 61183
// MC_Deposits ( ) ;
61179: CALL 77736 0 0
// if event = 126 then
61183: LD_VAR 0 1
61187: PUSH
61188: LD_INT 126
61190: EQUAL
61191: IFFALSE 61197
// MC_RemoteDriver ( ) ;
61193: CALL 78361 0 0
// if event = 200 then
61197: LD_VAR 0 1
61201: PUSH
61202: LD_INT 200
61204: EQUAL
61205: IFFALSE 61211
// MC_Idle ( ) ;
61207: CALL 80310 0 0
// end ;
61211: PPOPN 1
61213: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61214: LD_INT 0
61216: PPUSH
61217: PPUSH
// if not mc_bases [ base ] or not tag then
61218: LD_EXP 58
61222: PUSH
61223: LD_VAR 0 1
61227: ARRAY
61228: NOT
61229: PUSH
61230: LD_VAR 0 2
61234: NOT
61235: OR
61236: IFFALSE 61240
// exit ;
61238: GO 61304
// for i in mc_bases [ base ] union mc_ape [ base ] do
61240: LD_ADDR_VAR 0 4
61244: PUSH
61245: LD_EXP 58
61249: PUSH
61250: LD_VAR 0 1
61254: ARRAY
61255: PUSH
61256: LD_EXP 87
61260: PUSH
61261: LD_VAR 0 1
61265: ARRAY
61266: UNION
61267: PUSH
61268: FOR_IN
61269: IFFALSE 61302
// if GetTag ( i ) = tag then
61271: LD_VAR 0 4
61275: PPUSH
61276: CALL_OW 110
61280: PUSH
61281: LD_VAR 0 2
61285: EQUAL
61286: IFFALSE 61300
// SetTag ( i , 0 ) ;
61288: LD_VAR 0 4
61292: PPUSH
61293: LD_INT 0
61295: PPUSH
61296: CALL_OW 109
61300: GO 61268
61302: POP
61303: POP
// end ;
61304: LD_VAR 0 3
61308: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61309: LD_INT 0
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
61318: PPUSH
// if not mc_bases then
61319: LD_EXP 58
61323: NOT
61324: IFFALSE 61328
// exit ;
61326: GO 61786
// for i = 1 to mc_bases do
61328: LD_ADDR_VAR 0 2
61332: PUSH
61333: DOUBLE
61334: LD_INT 1
61336: DEC
61337: ST_TO_ADDR
61338: LD_EXP 58
61342: PUSH
61343: FOR_TO
61344: IFFALSE 61784
// begin tmp := MC_ClassCheckReq ( i ) ;
61346: LD_ADDR_VAR 0 4
61350: PUSH
61351: LD_VAR 0 2
61355: PPUSH
61356: CALL 61791 0 1
61360: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61361: LD_ADDR_EXP 99
61365: PUSH
61366: LD_EXP 99
61370: PPUSH
61371: LD_VAR 0 2
61375: PPUSH
61376: LD_VAR 0 4
61380: PPUSH
61381: CALL_OW 1
61385: ST_TO_ADDR
// if not tmp then
61386: LD_VAR 0 4
61390: NOT
61391: IFFALSE 61395
// continue ;
61393: GO 61343
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61395: LD_ADDR_VAR 0 6
61399: PUSH
61400: LD_EXP 58
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: PPUSH
61411: LD_INT 2
61413: PUSH
61414: LD_INT 30
61416: PUSH
61417: LD_INT 4
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 30
61426: PUSH
61427: LD_INT 5
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: LIST
61438: PPUSH
61439: CALL_OW 72
61443: PUSH
61444: LD_EXP 58
61448: PUSH
61449: LD_VAR 0 2
61453: ARRAY
61454: PPUSH
61455: LD_INT 2
61457: PUSH
61458: LD_INT 30
61460: PUSH
61461: LD_INT 0
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: PUSH
61468: LD_INT 30
61470: PUSH
61471: LD_INT 1
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: PUSH
61478: EMPTY
61479: LIST
61480: LIST
61481: LIST
61482: PPUSH
61483: CALL_OW 72
61487: PUSH
61488: LD_EXP 58
61492: PUSH
61493: LD_VAR 0 2
61497: ARRAY
61498: PPUSH
61499: LD_INT 30
61501: PUSH
61502: LD_INT 3
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PPUSH
61509: CALL_OW 72
61513: PUSH
61514: LD_EXP 58
61518: PUSH
61519: LD_VAR 0 2
61523: ARRAY
61524: PPUSH
61525: LD_INT 2
61527: PUSH
61528: LD_INT 30
61530: PUSH
61531: LD_INT 6
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: LD_INT 30
61540: PUSH
61541: LD_INT 7
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PUSH
61548: LD_INT 30
61550: PUSH
61551: LD_INT 8
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: PUSH
61558: EMPTY
61559: LIST
61560: LIST
61561: LIST
61562: LIST
61563: PPUSH
61564: CALL_OW 72
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: LIST
61573: LIST
61574: ST_TO_ADDR
// for j = 1 to 4 do
61575: LD_ADDR_VAR 0 3
61579: PUSH
61580: DOUBLE
61581: LD_INT 1
61583: DEC
61584: ST_TO_ADDR
61585: LD_INT 4
61587: PUSH
61588: FOR_TO
61589: IFFALSE 61780
// begin if not tmp [ j ] then
61591: LD_VAR 0 4
61595: PUSH
61596: LD_VAR 0 3
61600: ARRAY
61601: NOT
61602: IFFALSE 61606
// continue ;
61604: GO 61588
// for p in tmp [ j ] do
61606: LD_ADDR_VAR 0 5
61610: PUSH
61611: LD_VAR 0 4
61615: PUSH
61616: LD_VAR 0 3
61620: ARRAY
61621: PUSH
61622: FOR_IN
61623: IFFALSE 61776
// begin if not b [ j ] then
61625: LD_VAR 0 6
61629: PUSH
61630: LD_VAR 0 3
61634: ARRAY
61635: NOT
61636: IFFALSE 61640
// break ;
61638: GO 61776
// e := 0 ;
61640: LD_ADDR_VAR 0 7
61644: PUSH
61645: LD_INT 0
61647: ST_TO_ADDR
// for k in b [ j ] do
61648: LD_ADDR_VAR 0 8
61652: PUSH
61653: LD_VAR 0 6
61657: PUSH
61658: LD_VAR 0 3
61662: ARRAY
61663: PUSH
61664: FOR_IN
61665: IFFALSE 61692
// if IsNotFull ( k ) then
61667: LD_VAR 0 8
61671: PPUSH
61672: CALL 18477 0 1
61676: IFFALSE 61690
// begin e := k ;
61678: LD_ADDR_VAR 0 7
61682: PUSH
61683: LD_VAR 0 8
61687: ST_TO_ADDR
// break ;
61688: GO 61692
// end ;
61690: GO 61664
61692: POP
61693: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61694: LD_VAR 0 7
61698: PUSH
61699: LD_VAR 0 5
61703: PPUSH
61704: LD_VAR 0 7
61708: PPUSH
61709: CALL 55596 0 2
61713: NOT
61714: AND
61715: IFFALSE 61774
// begin if IsInUnit ( p ) then
61717: LD_VAR 0 5
61721: PPUSH
61722: CALL_OW 310
61726: IFFALSE 61737
// ComExitBuilding ( p ) ;
61728: LD_VAR 0 5
61732: PPUSH
61733: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61737: LD_VAR 0 5
61741: PPUSH
61742: LD_VAR 0 7
61746: PPUSH
61747: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61751: LD_VAR 0 5
61755: PPUSH
61756: LD_VAR 0 3
61760: PPUSH
61761: CALL_OW 183
// AddComExitBuilding ( p ) ;
61765: LD_VAR 0 5
61769: PPUSH
61770: CALL_OW 182
// end ; end ;
61774: GO 61622
61776: POP
61777: POP
// end ;
61778: GO 61588
61780: POP
61781: POP
// end ;
61782: GO 61343
61784: POP
61785: POP
// end ;
61786: LD_VAR 0 1
61790: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61791: LD_INT 0
61793: PPUSH
61794: PPUSH
61795: PPUSH
61796: PPUSH
61797: PPUSH
61798: PPUSH
61799: PPUSH
61800: PPUSH
61801: PPUSH
61802: PPUSH
61803: PPUSH
61804: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61805: LD_VAR 0 1
61809: NOT
61810: PUSH
61811: LD_EXP 58
61815: PUSH
61816: LD_VAR 0 1
61820: ARRAY
61821: NOT
61822: OR
61823: PUSH
61824: LD_EXP 58
61828: PUSH
61829: LD_VAR 0 1
61833: ARRAY
61834: PPUSH
61835: LD_INT 2
61837: PUSH
61838: LD_INT 30
61840: PUSH
61841: LD_INT 0
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: PUSH
61848: LD_INT 30
61850: PUSH
61851: LD_INT 1
61853: PUSH
61854: EMPTY
61855: LIST
61856: LIST
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: LIST
61862: PPUSH
61863: CALL_OW 72
61867: NOT
61868: OR
61869: IFFALSE 61873
// exit ;
61871: GO 65376
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61873: LD_ADDR_VAR 0 4
61877: PUSH
61878: LD_EXP 58
61882: PUSH
61883: LD_VAR 0 1
61887: ARRAY
61888: PPUSH
61889: LD_INT 2
61891: PUSH
61892: LD_INT 25
61894: PUSH
61895: LD_INT 1
61897: PUSH
61898: EMPTY
61899: LIST
61900: LIST
61901: PUSH
61902: LD_INT 25
61904: PUSH
61905: LD_INT 2
61907: PUSH
61908: EMPTY
61909: LIST
61910: LIST
61911: PUSH
61912: LD_INT 25
61914: PUSH
61915: LD_INT 3
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PUSH
61922: LD_INT 25
61924: PUSH
61925: LD_INT 4
61927: PUSH
61928: EMPTY
61929: LIST
61930: LIST
61931: PUSH
61932: LD_INT 25
61934: PUSH
61935: LD_INT 5
61937: PUSH
61938: EMPTY
61939: LIST
61940: LIST
61941: PUSH
61942: LD_INT 25
61944: PUSH
61945: LD_INT 8
61947: PUSH
61948: EMPTY
61949: LIST
61950: LIST
61951: PUSH
61952: LD_INT 25
61954: PUSH
61955: LD_INT 9
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PUSH
61962: EMPTY
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: PPUSH
61972: CALL_OW 72
61976: ST_TO_ADDR
// if not tmp then
61977: LD_VAR 0 4
61981: NOT
61982: IFFALSE 61986
// exit ;
61984: GO 65376
// for i in tmp do
61986: LD_ADDR_VAR 0 3
61990: PUSH
61991: LD_VAR 0 4
61995: PUSH
61996: FOR_IN
61997: IFFALSE 62028
// if GetTag ( i ) then
61999: LD_VAR 0 3
62003: PPUSH
62004: CALL_OW 110
62008: IFFALSE 62026
// tmp := tmp diff i ;
62010: LD_ADDR_VAR 0 4
62014: PUSH
62015: LD_VAR 0 4
62019: PUSH
62020: LD_VAR 0 3
62024: DIFF
62025: ST_TO_ADDR
62026: GO 61996
62028: POP
62029: POP
// if not tmp then
62030: LD_VAR 0 4
62034: NOT
62035: IFFALSE 62039
// exit ;
62037: GO 65376
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62039: LD_ADDR_VAR 0 5
62043: PUSH
62044: LD_EXP 58
62048: PUSH
62049: LD_VAR 0 1
62053: ARRAY
62054: PPUSH
62055: LD_INT 2
62057: PUSH
62058: LD_INT 25
62060: PUSH
62061: LD_INT 1
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: PUSH
62068: LD_INT 25
62070: PUSH
62071: LD_INT 5
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: PUSH
62078: LD_INT 25
62080: PUSH
62081: LD_INT 8
62083: PUSH
62084: EMPTY
62085: LIST
62086: LIST
62087: PUSH
62088: LD_INT 25
62090: PUSH
62091: LD_INT 9
62093: PUSH
62094: EMPTY
62095: LIST
62096: LIST
62097: PUSH
62098: EMPTY
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: LIST
62104: PPUSH
62105: CALL_OW 72
62109: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62110: LD_ADDR_VAR 0 6
62114: PUSH
62115: LD_EXP 58
62119: PUSH
62120: LD_VAR 0 1
62124: ARRAY
62125: PPUSH
62126: LD_INT 25
62128: PUSH
62129: LD_INT 2
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: PPUSH
62136: CALL_OW 72
62140: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62141: LD_ADDR_VAR 0 7
62145: PUSH
62146: LD_EXP 58
62150: PUSH
62151: LD_VAR 0 1
62155: ARRAY
62156: PPUSH
62157: LD_INT 25
62159: PUSH
62160: LD_INT 3
62162: PUSH
62163: EMPTY
62164: LIST
62165: LIST
62166: PPUSH
62167: CALL_OW 72
62171: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62172: LD_ADDR_VAR 0 8
62176: PUSH
62177: LD_EXP 58
62181: PUSH
62182: LD_VAR 0 1
62186: ARRAY
62187: PPUSH
62188: LD_INT 25
62190: PUSH
62191: LD_INT 4
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: PUSH
62198: LD_INT 24
62200: PUSH
62201: LD_INT 251
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: PUSH
62208: EMPTY
62209: LIST
62210: LIST
62211: PPUSH
62212: CALL_OW 72
62216: ST_TO_ADDR
// if mc_scan [ base ] then
62217: LD_EXP 81
62221: PUSH
62222: LD_VAR 0 1
62226: ARRAY
62227: IFFALSE 62688
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62229: LD_ADDR_EXP 100
62233: PUSH
62234: LD_EXP 100
62238: PPUSH
62239: LD_VAR 0 1
62243: PPUSH
62244: LD_INT 4
62246: PPUSH
62247: CALL_OW 1
62251: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62252: LD_ADDR_VAR 0 12
62256: PUSH
62257: LD_EXP 58
62261: PUSH
62262: LD_VAR 0 1
62266: ARRAY
62267: PPUSH
62268: LD_INT 2
62270: PUSH
62271: LD_INT 30
62273: PUSH
62274: LD_INT 4
62276: PUSH
62277: EMPTY
62278: LIST
62279: LIST
62280: PUSH
62281: LD_INT 30
62283: PUSH
62284: LD_INT 5
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: PUSH
62291: EMPTY
62292: LIST
62293: LIST
62294: LIST
62295: PPUSH
62296: CALL_OW 72
62300: ST_TO_ADDR
// if not b then
62301: LD_VAR 0 12
62305: NOT
62306: IFFALSE 62310
// exit ;
62308: GO 65376
// p := [ ] ;
62310: LD_ADDR_VAR 0 11
62314: PUSH
62315: EMPTY
62316: ST_TO_ADDR
// if sci >= 2 then
62317: LD_VAR 0 8
62321: PUSH
62322: LD_INT 2
62324: GREATEREQUAL
62325: IFFALSE 62356
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62327: LD_ADDR_VAR 0 8
62331: PUSH
62332: LD_VAR 0 8
62336: PUSH
62337: LD_INT 1
62339: ARRAY
62340: PUSH
62341: LD_VAR 0 8
62345: PUSH
62346: LD_INT 2
62348: ARRAY
62349: PUSH
62350: EMPTY
62351: LIST
62352: LIST
62353: ST_TO_ADDR
62354: GO 62417
// if sci = 1 then
62356: LD_VAR 0 8
62360: PUSH
62361: LD_INT 1
62363: EQUAL
62364: IFFALSE 62385
// sci := [ sci [ 1 ] ] else
62366: LD_ADDR_VAR 0 8
62370: PUSH
62371: LD_VAR 0 8
62375: PUSH
62376: LD_INT 1
62378: ARRAY
62379: PUSH
62380: EMPTY
62381: LIST
62382: ST_TO_ADDR
62383: GO 62417
// if sci = 0 then
62385: LD_VAR 0 8
62389: PUSH
62390: LD_INT 0
62392: EQUAL
62393: IFFALSE 62417
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62395: LD_ADDR_VAR 0 11
62399: PUSH
62400: LD_VAR 0 4
62404: PPUSH
62405: LD_INT 4
62407: PPUSH
62408: CALL 55459 0 2
62412: PUSH
62413: LD_INT 1
62415: ARRAY
62416: ST_TO_ADDR
// if eng > 4 then
62417: LD_VAR 0 6
62421: PUSH
62422: LD_INT 4
62424: GREATER
62425: IFFALSE 62471
// for i = eng downto 4 do
62427: LD_ADDR_VAR 0 3
62431: PUSH
62432: DOUBLE
62433: LD_VAR 0 6
62437: INC
62438: ST_TO_ADDR
62439: LD_INT 4
62441: PUSH
62442: FOR_DOWNTO
62443: IFFALSE 62469
// eng := eng diff eng [ i ] ;
62445: LD_ADDR_VAR 0 6
62449: PUSH
62450: LD_VAR 0 6
62454: PUSH
62455: LD_VAR 0 6
62459: PUSH
62460: LD_VAR 0 3
62464: ARRAY
62465: DIFF
62466: ST_TO_ADDR
62467: GO 62442
62469: POP
62470: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62471: LD_ADDR_VAR 0 4
62475: PUSH
62476: LD_VAR 0 4
62480: PUSH
62481: LD_VAR 0 5
62485: PUSH
62486: LD_VAR 0 6
62490: UNION
62491: PUSH
62492: LD_VAR 0 7
62496: UNION
62497: PUSH
62498: LD_VAR 0 8
62502: UNION
62503: DIFF
62504: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62505: LD_ADDR_VAR 0 13
62509: PUSH
62510: LD_EXP 58
62514: PUSH
62515: LD_VAR 0 1
62519: ARRAY
62520: PPUSH
62521: LD_INT 2
62523: PUSH
62524: LD_INT 30
62526: PUSH
62527: LD_INT 32
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PUSH
62534: LD_INT 30
62536: PUSH
62537: LD_INT 31
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: LIST
62548: PPUSH
62549: CALL_OW 72
62553: PUSH
62554: LD_EXP 58
62558: PUSH
62559: LD_VAR 0 1
62563: ARRAY
62564: PPUSH
62565: LD_INT 2
62567: PUSH
62568: LD_INT 30
62570: PUSH
62571: LD_INT 4
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: PUSH
62578: LD_INT 30
62580: PUSH
62581: LD_INT 5
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: LIST
62592: PPUSH
62593: CALL_OW 72
62597: PUSH
62598: LD_INT 6
62600: MUL
62601: PLUS
62602: ST_TO_ADDR
// if bcount < tmp then
62603: LD_VAR 0 13
62607: PUSH
62608: LD_VAR 0 4
62612: LESS
62613: IFFALSE 62659
// for i = tmp downto bcount do
62615: LD_ADDR_VAR 0 3
62619: PUSH
62620: DOUBLE
62621: LD_VAR 0 4
62625: INC
62626: ST_TO_ADDR
62627: LD_VAR 0 13
62631: PUSH
62632: FOR_DOWNTO
62633: IFFALSE 62657
// tmp := Delete ( tmp , tmp ) ;
62635: LD_ADDR_VAR 0 4
62639: PUSH
62640: LD_VAR 0 4
62644: PPUSH
62645: LD_VAR 0 4
62649: PPUSH
62650: CALL_OW 3
62654: ST_TO_ADDR
62655: GO 62632
62657: POP
62658: POP
// result := [ tmp , 0 , 0 , p ] ;
62659: LD_ADDR_VAR 0 2
62663: PUSH
62664: LD_VAR 0 4
62668: PUSH
62669: LD_INT 0
62671: PUSH
62672: LD_INT 0
62674: PUSH
62675: LD_VAR 0 11
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: ST_TO_ADDR
// exit ;
62686: GO 65376
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62688: LD_EXP 58
62692: PUSH
62693: LD_VAR 0 1
62697: ARRAY
62698: PPUSH
62699: LD_INT 2
62701: PUSH
62702: LD_INT 30
62704: PUSH
62705: LD_INT 6
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PUSH
62712: LD_INT 30
62714: PUSH
62715: LD_INT 7
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PUSH
62722: LD_INT 30
62724: PUSH
62725: LD_INT 8
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: PUSH
62732: EMPTY
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: PPUSH
62738: CALL_OW 72
62742: NOT
62743: PUSH
62744: LD_EXP 58
62748: PUSH
62749: LD_VAR 0 1
62753: ARRAY
62754: PPUSH
62755: LD_INT 30
62757: PUSH
62758: LD_INT 3
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PPUSH
62765: CALL_OW 72
62769: NOT
62770: AND
62771: IFFALSE 62843
// begin if eng = tmp then
62773: LD_VAR 0 6
62777: PUSH
62778: LD_VAR 0 4
62782: EQUAL
62783: IFFALSE 62787
// exit ;
62785: GO 65376
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62787: LD_ADDR_EXP 100
62791: PUSH
62792: LD_EXP 100
62796: PPUSH
62797: LD_VAR 0 1
62801: PPUSH
62802: LD_INT 1
62804: PPUSH
62805: CALL_OW 1
62809: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62810: LD_ADDR_VAR 0 2
62814: PUSH
62815: LD_INT 0
62817: PUSH
62818: LD_VAR 0 4
62822: PUSH
62823: LD_VAR 0 6
62827: DIFF
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: LD_INT 0
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: ST_TO_ADDR
// exit ;
62841: GO 65376
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62843: LD_EXP 85
62847: PUSH
62848: LD_EXP 84
62852: PUSH
62853: LD_VAR 0 1
62857: ARRAY
62858: ARRAY
62859: PUSH
62860: LD_EXP 58
62864: PUSH
62865: LD_VAR 0 1
62869: ARRAY
62870: PPUSH
62871: LD_INT 2
62873: PUSH
62874: LD_INT 30
62876: PUSH
62877: LD_INT 6
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PUSH
62884: LD_INT 30
62886: PUSH
62887: LD_INT 7
62889: PUSH
62890: EMPTY
62891: LIST
62892: LIST
62893: PUSH
62894: LD_INT 30
62896: PUSH
62897: LD_INT 8
62899: PUSH
62900: EMPTY
62901: LIST
62902: LIST
62903: PUSH
62904: EMPTY
62905: LIST
62906: LIST
62907: LIST
62908: LIST
62909: PPUSH
62910: CALL_OW 72
62914: AND
62915: PUSH
62916: LD_EXP 58
62920: PUSH
62921: LD_VAR 0 1
62925: ARRAY
62926: PPUSH
62927: LD_INT 30
62929: PUSH
62930: LD_INT 3
62932: PUSH
62933: EMPTY
62934: LIST
62935: LIST
62936: PPUSH
62937: CALL_OW 72
62941: NOT
62942: AND
62943: IFFALSE 63157
// begin if sci >= 6 then
62945: LD_VAR 0 8
62949: PUSH
62950: LD_INT 6
62952: GREATEREQUAL
62953: IFFALSE 62957
// exit ;
62955: GO 65376
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62957: LD_ADDR_EXP 100
62961: PUSH
62962: LD_EXP 100
62966: PPUSH
62967: LD_VAR 0 1
62971: PPUSH
62972: LD_INT 2
62974: PPUSH
62975: CALL_OW 1
62979: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62980: LD_ADDR_VAR 0 9
62984: PUSH
62985: LD_VAR 0 4
62989: PUSH
62990: LD_VAR 0 8
62994: DIFF
62995: PPUSH
62996: LD_INT 4
62998: PPUSH
62999: CALL 55459 0 2
63003: ST_TO_ADDR
// p := [ ] ;
63004: LD_ADDR_VAR 0 11
63008: PUSH
63009: EMPTY
63010: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63011: LD_VAR 0 8
63015: PUSH
63016: LD_INT 6
63018: LESS
63019: PUSH
63020: LD_VAR 0 9
63024: PUSH
63025: LD_INT 6
63027: GREATER
63028: AND
63029: IFFALSE 63110
// begin for i = 1 to 6 - sci do
63031: LD_ADDR_VAR 0 3
63035: PUSH
63036: DOUBLE
63037: LD_INT 1
63039: DEC
63040: ST_TO_ADDR
63041: LD_INT 6
63043: PUSH
63044: LD_VAR 0 8
63048: MINUS
63049: PUSH
63050: FOR_TO
63051: IFFALSE 63106
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63053: LD_ADDR_VAR 0 11
63057: PUSH
63058: LD_VAR 0 11
63062: PPUSH
63063: LD_VAR 0 11
63067: PUSH
63068: LD_INT 1
63070: PLUS
63071: PPUSH
63072: LD_VAR 0 9
63076: PUSH
63077: LD_INT 1
63079: ARRAY
63080: PPUSH
63081: CALL_OW 2
63085: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63086: LD_ADDR_VAR 0 9
63090: PUSH
63091: LD_VAR 0 9
63095: PPUSH
63096: LD_INT 1
63098: PPUSH
63099: CALL_OW 3
63103: ST_TO_ADDR
// end ;
63104: GO 63050
63106: POP
63107: POP
// end else
63108: GO 63130
// if sort then
63110: LD_VAR 0 9
63114: IFFALSE 63130
// p := sort [ 1 ] ;
63116: LD_ADDR_VAR 0 11
63120: PUSH
63121: LD_VAR 0 9
63125: PUSH
63126: LD_INT 1
63128: ARRAY
63129: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63130: LD_ADDR_VAR 0 2
63134: PUSH
63135: LD_INT 0
63137: PUSH
63138: LD_INT 0
63140: PUSH
63141: LD_INT 0
63143: PUSH
63144: LD_VAR 0 11
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: ST_TO_ADDR
// exit ;
63155: GO 65376
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63157: LD_EXP 85
63161: PUSH
63162: LD_EXP 84
63166: PUSH
63167: LD_VAR 0 1
63171: ARRAY
63172: ARRAY
63173: PUSH
63174: LD_EXP 58
63178: PUSH
63179: LD_VAR 0 1
63183: ARRAY
63184: PPUSH
63185: LD_INT 2
63187: PUSH
63188: LD_INT 30
63190: PUSH
63191: LD_INT 6
63193: PUSH
63194: EMPTY
63195: LIST
63196: LIST
63197: PUSH
63198: LD_INT 30
63200: PUSH
63201: LD_INT 7
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: PUSH
63208: LD_INT 30
63210: PUSH
63211: LD_INT 8
63213: PUSH
63214: EMPTY
63215: LIST
63216: LIST
63217: PUSH
63218: EMPTY
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: PPUSH
63224: CALL_OW 72
63228: AND
63229: PUSH
63230: LD_EXP 58
63234: PUSH
63235: LD_VAR 0 1
63239: ARRAY
63240: PPUSH
63241: LD_INT 30
63243: PUSH
63244: LD_INT 3
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PPUSH
63251: CALL_OW 72
63255: AND
63256: IFFALSE 63990
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63258: LD_ADDR_EXP 100
63262: PUSH
63263: LD_EXP 100
63267: PPUSH
63268: LD_VAR 0 1
63272: PPUSH
63273: LD_INT 3
63275: PPUSH
63276: CALL_OW 1
63280: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63281: LD_ADDR_VAR 0 2
63285: PUSH
63286: LD_INT 0
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: LD_INT 0
63294: PUSH
63295: LD_INT 0
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: ST_TO_ADDR
// if not eng then
63304: LD_VAR 0 6
63308: NOT
63309: IFFALSE 63372
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63311: LD_ADDR_VAR 0 11
63315: PUSH
63316: LD_VAR 0 4
63320: PPUSH
63321: LD_INT 2
63323: PPUSH
63324: CALL 55459 0 2
63328: PUSH
63329: LD_INT 1
63331: ARRAY
63332: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63333: LD_ADDR_VAR 0 2
63337: PUSH
63338: LD_VAR 0 2
63342: PPUSH
63343: LD_INT 2
63345: PPUSH
63346: LD_VAR 0 11
63350: PPUSH
63351: CALL_OW 1
63355: ST_TO_ADDR
// tmp := tmp diff p ;
63356: LD_ADDR_VAR 0 4
63360: PUSH
63361: LD_VAR 0 4
63365: PUSH
63366: LD_VAR 0 11
63370: DIFF
63371: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63372: LD_VAR 0 4
63376: PUSH
63377: LD_VAR 0 8
63381: PUSH
63382: LD_INT 6
63384: LESS
63385: AND
63386: IFFALSE 63574
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63388: LD_ADDR_VAR 0 9
63392: PUSH
63393: LD_VAR 0 4
63397: PUSH
63398: LD_VAR 0 8
63402: PUSH
63403: LD_VAR 0 7
63407: UNION
63408: DIFF
63409: PPUSH
63410: LD_INT 4
63412: PPUSH
63413: CALL 55459 0 2
63417: ST_TO_ADDR
// p := [ ] ;
63418: LD_ADDR_VAR 0 11
63422: PUSH
63423: EMPTY
63424: ST_TO_ADDR
// if sort then
63425: LD_VAR 0 9
63429: IFFALSE 63545
// for i = 1 to 6 - sci do
63431: LD_ADDR_VAR 0 3
63435: PUSH
63436: DOUBLE
63437: LD_INT 1
63439: DEC
63440: ST_TO_ADDR
63441: LD_INT 6
63443: PUSH
63444: LD_VAR 0 8
63448: MINUS
63449: PUSH
63450: FOR_TO
63451: IFFALSE 63543
// begin if i = sort then
63453: LD_VAR 0 3
63457: PUSH
63458: LD_VAR 0 9
63462: EQUAL
63463: IFFALSE 63467
// break ;
63465: GO 63543
// if GetClass ( i ) = 4 then
63467: LD_VAR 0 3
63471: PPUSH
63472: CALL_OW 257
63476: PUSH
63477: LD_INT 4
63479: EQUAL
63480: IFFALSE 63484
// continue ;
63482: GO 63450
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63484: LD_ADDR_VAR 0 11
63488: PUSH
63489: LD_VAR 0 11
63493: PPUSH
63494: LD_VAR 0 11
63498: PUSH
63499: LD_INT 1
63501: PLUS
63502: PPUSH
63503: LD_VAR 0 9
63507: PUSH
63508: LD_VAR 0 3
63512: ARRAY
63513: PPUSH
63514: CALL_OW 2
63518: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63519: LD_ADDR_VAR 0 4
63523: PUSH
63524: LD_VAR 0 4
63528: PUSH
63529: LD_VAR 0 9
63533: PUSH
63534: LD_VAR 0 3
63538: ARRAY
63539: DIFF
63540: ST_TO_ADDR
// end ;
63541: GO 63450
63543: POP
63544: POP
// if p then
63545: LD_VAR 0 11
63549: IFFALSE 63574
// result := Replace ( result , 4 , p ) ;
63551: LD_ADDR_VAR 0 2
63555: PUSH
63556: LD_VAR 0 2
63560: PPUSH
63561: LD_INT 4
63563: PPUSH
63564: LD_VAR 0 11
63568: PPUSH
63569: CALL_OW 1
63573: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63574: LD_VAR 0 4
63578: PUSH
63579: LD_VAR 0 7
63583: PUSH
63584: LD_INT 6
63586: LESS
63587: AND
63588: IFFALSE 63776
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63590: LD_ADDR_VAR 0 9
63594: PUSH
63595: LD_VAR 0 4
63599: PUSH
63600: LD_VAR 0 8
63604: PUSH
63605: LD_VAR 0 7
63609: UNION
63610: DIFF
63611: PPUSH
63612: LD_INT 3
63614: PPUSH
63615: CALL 55459 0 2
63619: ST_TO_ADDR
// p := [ ] ;
63620: LD_ADDR_VAR 0 11
63624: PUSH
63625: EMPTY
63626: ST_TO_ADDR
// if sort then
63627: LD_VAR 0 9
63631: IFFALSE 63747
// for i = 1 to 6 - mech do
63633: LD_ADDR_VAR 0 3
63637: PUSH
63638: DOUBLE
63639: LD_INT 1
63641: DEC
63642: ST_TO_ADDR
63643: LD_INT 6
63645: PUSH
63646: LD_VAR 0 7
63650: MINUS
63651: PUSH
63652: FOR_TO
63653: IFFALSE 63745
// begin if i = sort then
63655: LD_VAR 0 3
63659: PUSH
63660: LD_VAR 0 9
63664: EQUAL
63665: IFFALSE 63669
// break ;
63667: GO 63745
// if GetClass ( i ) = 3 then
63669: LD_VAR 0 3
63673: PPUSH
63674: CALL_OW 257
63678: PUSH
63679: LD_INT 3
63681: EQUAL
63682: IFFALSE 63686
// continue ;
63684: GO 63652
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63686: LD_ADDR_VAR 0 11
63690: PUSH
63691: LD_VAR 0 11
63695: PPUSH
63696: LD_VAR 0 11
63700: PUSH
63701: LD_INT 1
63703: PLUS
63704: PPUSH
63705: LD_VAR 0 9
63709: PUSH
63710: LD_VAR 0 3
63714: ARRAY
63715: PPUSH
63716: CALL_OW 2
63720: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63721: LD_ADDR_VAR 0 4
63725: PUSH
63726: LD_VAR 0 4
63730: PUSH
63731: LD_VAR 0 9
63735: PUSH
63736: LD_VAR 0 3
63740: ARRAY
63741: DIFF
63742: ST_TO_ADDR
// end ;
63743: GO 63652
63745: POP
63746: POP
// if p then
63747: LD_VAR 0 11
63751: IFFALSE 63776
// result := Replace ( result , 3 , p ) ;
63753: LD_ADDR_VAR 0 2
63757: PUSH
63758: LD_VAR 0 2
63762: PPUSH
63763: LD_INT 3
63765: PPUSH
63766: LD_VAR 0 11
63770: PPUSH
63771: CALL_OW 1
63775: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63776: LD_VAR 0 4
63780: PUSH
63781: LD_INT 6
63783: GREATER
63784: PUSH
63785: LD_VAR 0 6
63789: PUSH
63790: LD_INT 6
63792: LESS
63793: AND
63794: IFFALSE 63988
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63796: LD_ADDR_VAR 0 9
63800: PUSH
63801: LD_VAR 0 4
63805: PUSH
63806: LD_VAR 0 8
63810: PUSH
63811: LD_VAR 0 7
63815: UNION
63816: PUSH
63817: LD_VAR 0 6
63821: UNION
63822: DIFF
63823: PPUSH
63824: LD_INT 2
63826: PPUSH
63827: CALL 55459 0 2
63831: ST_TO_ADDR
// p := [ ] ;
63832: LD_ADDR_VAR 0 11
63836: PUSH
63837: EMPTY
63838: ST_TO_ADDR
// if sort then
63839: LD_VAR 0 9
63843: IFFALSE 63959
// for i = 1 to 6 - eng do
63845: LD_ADDR_VAR 0 3
63849: PUSH
63850: DOUBLE
63851: LD_INT 1
63853: DEC
63854: ST_TO_ADDR
63855: LD_INT 6
63857: PUSH
63858: LD_VAR 0 6
63862: MINUS
63863: PUSH
63864: FOR_TO
63865: IFFALSE 63957
// begin if i = sort then
63867: LD_VAR 0 3
63871: PUSH
63872: LD_VAR 0 9
63876: EQUAL
63877: IFFALSE 63881
// break ;
63879: GO 63957
// if GetClass ( i ) = 2 then
63881: LD_VAR 0 3
63885: PPUSH
63886: CALL_OW 257
63890: PUSH
63891: LD_INT 2
63893: EQUAL
63894: IFFALSE 63898
// continue ;
63896: GO 63864
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63898: LD_ADDR_VAR 0 11
63902: PUSH
63903: LD_VAR 0 11
63907: PPUSH
63908: LD_VAR 0 11
63912: PUSH
63913: LD_INT 1
63915: PLUS
63916: PPUSH
63917: LD_VAR 0 9
63921: PUSH
63922: LD_VAR 0 3
63926: ARRAY
63927: PPUSH
63928: CALL_OW 2
63932: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63933: LD_ADDR_VAR 0 4
63937: PUSH
63938: LD_VAR 0 4
63942: PUSH
63943: LD_VAR 0 9
63947: PUSH
63948: LD_VAR 0 3
63952: ARRAY
63953: DIFF
63954: ST_TO_ADDR
// end ;
63955: GO 63864
63957: POP
63958: POP
// if p then
63959: LD_VAR 0 11
63963: IFFALSE 63988
// result := Replace ( result , 2 , p ) ;
63965: LD_ADDR_VAR 0 2
63969: PUSH
63970: LD_VAR 0 2
63974: PPUSH
63975: LD_INT 2
63977: PPUSH
63978: LD_VAR 0 11
63982: PPUSH
63983: CALL_OW 1
63987: ST_TO_ADDR
// end ; exit ;
63988: GO 65376
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63990: LD_EXP 85
63994: PUSH
63995: LD_EXP 84
63999: PUSH
64000: LD_VAR 0 1
64004: ARRAY
64005: ARRAY
64006: NOT
64007: PUSH
64008: LD_EXP 58
64012: PUSH
64013: LD_VAR 0 1
64017: ARRAY
64018: PPUSH
64019: LD_INT 30
64021: PUSH
64022: LD_INT 3
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PPUSH
64029: CALL_OW 72
64033: AND
64034: PUSH
64035: LD_EXP 63
64039: PUSH
64040: LD_VAR 0 1
64044: ARRAY
64045: AND
64046: IFFALSE 64654
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64048: LD_ADDR_EXP 100
64052: PUSH
64053: LD_EXP 100
64057: PPUSH
64058: LD_VAR 0 1
64062: PPUSH
64063: LD_INT 5
64065: PPUSH
64066: CALL_OW 1
64070: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64071: LD_ADDR_VAR 0 2
64075: PUSH
64076: LD_INT 0
64078: PUSH
64079: LD_INT 0
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: LD_INT 0
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: ST_TO_ADDR
// if sci > 1 then
64094: LD_VAR 0 8
64098: PUSH
64099: LD_INT 1
64101: GREATER
64102: IFFALSE 64130
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64104: LD_ADDR_VAR 0 4
64108: PUSH
64109: LD_VAR 0 4
64113: PUSH
64114: LD_VAR 0 8
64118: PUSH
64119: LD_VAR 0 8
64123: PUSH
64124: LD_INT 1
64126: ARRAY
64127: DIFF
64128: DIFF
64129: ST_TO_ADDR
// if tmp and not sci then
64130: LD_VAR 0 4
64134: PUSH
64135: LD_VAR 0 8
64139: NOT
64140: AND
64141: IFFALSE 64210
// begin sort := SortBySkill ( tmp , 4 ) ;
64143: LD_ADDR_VAR 0 9
64147: PUSH
64148: LD_VAR 0 4
64152: PPUSH
64153: LD_INT 4
64155: PPUSH
64156: CALL 55459 0 2
64160: ST_TO_ADDR
// if sort then
64161: LD_VAR 0 9
64165: IFFALSE 64181
// p := sort [ 1 ] ;
64167: LD_ADDR_VAR 0 11
64171: PUSH
64172: LD_VAR 0 9
64176: PUSH
64177: LD_INT 1
64179: ARRAY
64180: ST_TO_ADDR
// if p then
64181: LD_VAR 0 11
64185: IFFALSE 64210
// result := Replace ( result , 4 , p ) ;
64187: LD_ADDR_VAR 0 2
64191: PUSH
64192: LD_VAR 0 2
64196: PPUSH
64197: LD_INT 4
64199: PPUSH
64200: LD_VAR 0 11
64204: PPUSH
64205: CALL_OW 1
64209: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64210: LD_ADDR_VAR 0 4
64214: PUSH
64215: LD_VAR 0 4
64219: PUSH
64220: LD_VAR 0 7
64224: DIFF
64225: ST_TO_ADDR
// if tmp and mech < 6 then
64226: LD_VAR 0 4
64230: PUSH
64231: LD_VAR 0 7
64235: PUSH
64236: LD_INT 6
64238: LESS
64239: AND
64240: IFFALSE 64428
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64242: LD_ADDR_VAR 0 9
64246: PUSH
64247: LD_VAR 0 4
64251: PUSH
64252: LD_VAR 0 8
64256: PUSH
64257: LD_VAR 0 7
64261: UNION
64262: DIFF
64263: PPUSH
64264: LD_INT 3
64266: PPUSH
64267: CALL 55459 0 2
64271: ST_TO_ADDR
// p := [ ] ;
64272: LD_ADDR_VAR 0 11
64276: PUSH
64277: EMPTY
64278: ST_TO_ADDR
// if sort then
64279: LD_VAR 0 9
64283: IFFALSE 64399
// for i = 1 to 6 - mech do
64285: LD_ADDR_VAR 0 3
64289: PUSH
64290: DOUBLE
64291: LD_INT 1
64293: DEC
64294: ST_TO_ADDR
64295: LD_INT 6
64297: PUSH
64298: LD_VAR 0 7
64302: MINUS
64303: PUSH
64304: FOR_TO
64305: IFFALSE 64397
// begin if i = sort then
64307: LD_VAR 0 3
64311: PUSH
64312: LD_VAR 0 9
64316: EQUAL
64317: IFFALSE 64321
// break ;
64319: GO 64397
// if GetClass ( i ) = 3 then
64321: LD_VAR 0 3
64325: PPUSH
64326: CALL_OW 257
64330: PUSH
64331: LD_INT 3
64333: EQUAL
64334: IFFALSE 64338
// continue ;
64336: GO 64304
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64338: LD_ADDR_VAR 0 11
64342: PUSH
64343: LD_VAR 0 11
64347: PPUSH
64348: LD_VAR 0 11
64352: PUSH
64353: LD_INT 1
64355: PLUS
64356: PPUSH
64357: LD_VAR 0 9
64361: PUSH
64362: LD_VAR 0 3
64366: ARRAY
64367: PPUSH
64368: CALL_OW 2
64372: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64373: LD_ADDR_VAR 0 4
64377: PUSH
64378: LD_VAR 0 4
64382: PUSH
64383: LD_VAR 0 9
64387: PUSH
64388: LD_VAR 0 3
64392: ARRAY
64393: DIFF
64394: ST_TO_ADDR
// end ;
64395: GO 64304
64397: POP
64398: POP
// if p then
64399: LD_VAR 0 11
64403: IFFALSE 64428
// result := Replace ( result , 3 , p ) ;
64405: LD_ADDR_VAR 0 2
64409: PUSH
64410: LD_VAR 0 2
64414: PPUSH
64415: LD_INT 3
64417: PPUSH
64418: LD_VAR 0 11
64422: PPUSH
64423: CALL_OW 1
64427: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64428: LD_ADDR_VAR 0 4
64432: PUSH
64433: LD_VAR 0 4
64437: PUSH
64438: LD_VAR 0 6
64442: DIFF
64443: ST_TO_ADDR
// if tmp and eng < 6 then
64444: LD_VAR 0 4
64448: PUSH
64449: LD_VAR 0 6
64453: PUSH
64454: LD_INT 6
64456: LESS
64457: AND
64458: IFFALSE 64652
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64460: LD_ADDR_VAR 0 9
64464: PUSH
64465: LD_VAR 0 4
64469: PUSH
64470: LD_VAR 0 8
64474: PUSH
64475: LD_VAR 0 7
64479: UNION
64480: PUSH
64481: LD_VAR 0 6
64485: UNION
64486: DIFF
64487: PPUSH
64488: LD_INT 2
64490: PPUSH
64491: CALL 55459 0 2
64495: ST_TO_ADDR
// p := [ ] ;
64496: LD_ADDR_VAR 0 11
64500: PUSH
64501: EMPTY
64502: ST_TO_ADDR
// if sort then
64503: LD_VAR 0 9
64507: IFFALSE 64623
// for i = 1 to 6 - eng do
64509: LD_ADDR_VAR 0 3
64513: PUSH
64514: DOUBLE
64515: LD_INT 1
64517: DEC
64518: ST_TO_ADDR
64519: LD_INT 6
64521: PUSH
64522: LD_VAR 0 6
64526: MINUS
64527: PUSH
64528: FOR_TO
64529: IFFALSE 64621
// begin if i = sort then
64531: LD_VAR 0 3
64535: PUSH
64536: LD_VAR 0 9
64540: EQUAL
64541: IFFALSE 64545
// break ;
64543: GO 64621
// if GetClass ( i ) = 2 then
64545: LD_VAR 0 3
64549: PPUSH
64550: CALL_OW 257
64554: PUSH
64555: LD_INT 2
64557: EQUAL
64558: IFFALSE 64562
// continue ;
64560: GO 64528
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64562: LD_ADDR_VAR 0 11
64566: PUSH
64567: LD_VAR 0 11
64571: PPUSH
64572: LD_VAR 0 11
64576: PUSH
64577: LD_INT 1
64579: PLUS
64580: PPUSH
64581: LD_VAR 0 9
64585: PUSH
64586: LD_VAR 0 3
64590: ARRAY
64591: PPUSH
64592: CALL_OW 2
64596: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64597: LD_ADDR_VAR 0 4
64601: PUSH
64602: LD_VAR 0 4
64606: PUSH
64607: LD_VAR 0 9
64611: PUSH
64612: LD_VAR 0 3
64616: ARRAY
64617: DIFF
64618: ST_TO_ADDR
// end ;
64619: GO 64528
64621: POP
64622: POP
// if p then
64623: LD_VAR 0 11
64627: IFFALSE 64652
// result := Replace ( result , 2 , p ) ;
64629: LD_ADDR_VAR 0 2
64633: PUSH
64634: LD_VAR 0 2
64638: PPUSH
64639: LD_INT 2
64641: PPUSH
64642: LD_VAR 0 11
64646: PPUSH
64647: CALL_OW 1
64651: ST_TO_ADDR
// end ; exit ;
64652: GO 65376
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64654: LD_EXP 85
64658: PUSH
64659: LD_EXP 84
64663: PUSH
64664: LD_VAR 0 1
64668: ARRAY
64669: ARRAY
64670: NOT
64671: PUSH
64672: LD_EXP 58
64676: PUSH
64677: LD_VAR 0 1
64681: ARRAY
64682: PPUSH
64683: LD_INT 30
64685: PUSH
64686: LD_INT 3
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PPUSH
64693: CALL_OW 72
64697: AND
64698: PUSH
64699: LD_EXP 63
64703: PUSH
64704: LD_VAR 0 1
64708: ARRAY
64709: NOT
64710: AND
64711: IFFALSE 65376
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64713: LD_ADDR_EXP 100
64717: PUSH
64718: LD_EXP 100
64722: PPUSH
64723: LD_VAR 0 1
64727: PPUSH
64728: LD_INT 6
64730: PPUSH
64731: CALL_OW 1
64735: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64736: LD_ADDR_VAR 0 2
64740: PUSH
64741: LD_INT 0
64743: PUSH
64744: LD_INT 0
64746: PUSH
64747: LD_INT 0
64749: PUSH
64750: LD_INT 0
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: ST_TO_ADDR
// if sci >= 1 then
64759: LD_VAR 0 8
64763: PUSH
64764: LD_INT 1
64766: GREATEREQUAL
64767: IFFALSE 64789
// tmp := tmp diff sci [ 1 ] ;
64769: LD_ADDR_VAR 0 4
64773: PUSH
64774: LD_VAR 0 4
64778: PUSH
64779: LD_VAR 0 8
64783: PUSH
64784: LD_INT 1
64786: ARRAY
64787: DIFF
64788: ST_TO_ADDR
// if tmp and not sci then
64789: LD_VAR 0 4
64793: PUSH
64794: LD_VAR 0 8
64798: NOT
64799: AND
64800: IFFALSE 64869
// begin sort := SortBySkill ( tmp , 4 ) ;
64802: LD_ADDR_VAR 0 9
64806: PUSH
64807: LD_VAR 0 4
64811: PPUSH
64812: LD_INT 4
64814: PPUSH
64815: CALL 55459 0 2
64819: ST_TO_ADDR
// if sort then
64820: LD_VAR 0 9
64824: IFFALSE 64840
// p := sort [ 1 ] ;
64826: LD_ADDR_VAR 0 11
64830: PUSH
64831: LD_VAR 0 9
64835: PUSH
64836: LD_INT 1
64838: ARRAY
64839: ST_TO_ADDR
// if p then
64840: LD_VAR 0 11
64844: IFFALSE 64869
// result := Replace ( result , 4 , p ) ;
64846: LD_ADDR_VAR 0 2
64850: PUSH
64851: LD_VAR 0 2
64855: PPUSH
64856: LD_INT 4
64858: PPUSH
64859: LD_VAR 0 11
64863: PPUSH
64864: CALL_OW 1
64868: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64869: LD_ADDR_VAR 0 4
64873: PUSH
64874: LD_VAR 0 4
64878: PUSH
64879: LD_VAR 0 7
64883: DIFF
64884: ST_TO_ADDR
// if tmp and mech < 6 then
64885: LD_VAR 0 4
64889: PUSH
64890: LD_VAR 0 7
64894: PUSH
64895: LD_INT 6
64897: LESS
64898: AND
64899: IFFALSE 65081
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64901: LD_ADDR_VAR 0 9
64905: PUSH
64906: LD_VAR 0 4
64910: PUSH
64911: LD_VAR 0 7
64915: DIFF
64916: PPUSH
64917: LD_INT 3
64919: PPUSH
64920: CALL 55459 0 2
64924: ST_TO_ADDR
// p := [ ] ;
64925: LD_ADDR_VAR 0 11
64929: PUSH
64930: EMPTY
64931: ST_TO_ADDR
// if sort then
64932: LD_VAR 0 9
64936: IFFALSE 65052
// for i = 1 to 6 - mech do
64938: LD_ADDR_VAR 0 3
64942: PUSH
64943: DOUBLE
64944: LD_INT 1
64946: DEC
64947: ST_TO_ADDR
64948: LD_INT 6
64950: PUSH
64951: LD_VAR 0 7
64955: MINUS
64956: PUSH
64957: FOR_TO
64958: IFFALSE 65050
// begin if i = sort then
64960: LD_VAR 0 3
64964: PUSH
64965: LD_VAR 0 9
64969: EQUAL
64970: IFFALSE 64974
// break ;
64972: GO 65050
// if GetClass ( i ) = 3 then
64974: LD_VAR 0 3
64978: PPUSH
64979: CALL_OW 257
64983: PUSH
64984: LD_INT 3
64986: EQUAL
64987: IFFALSE 64991
// continue ;
64989: GO 64957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64991: LD_ADDR_VAR 0 11
64995: PUSH
64996: LD_VAR 0 11
65000: PPUSH
65001: LD_VAR 0 11
65005: PUSH
65006: LD_INT 1
65008: PLUS
65009: PPUSH
65010: LD_VAR 0 9
65014: PUSH
65015: LD_VAR 0 3
65019: ARRAY
65020: PPUSH
65021: CALL_OW 2
65025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65026: LD_ADDR_VAR 0 4
65030: PUSH
65031: LD_VAR 0 4
65035: PUSH
65036: LD_VAR 0 9
65040: PUSH
65041: LD_VAR 0 3
65045: ARRAY
65046: DIFF
65047: ST_TO_ADDR
// end ;
65048: GO 64957
65050: POP
65051: POP
// if p then
65052: LD_VAR 0 11
65056: IFFALSE 65081
// result := Replace ( result , 3 , p ) ;
65058: LD_ADDR_VAR 0 2
65062: PUSH
65063: LD_VAR 0 2
65067: PPUSH
65068: LD_INT 3
65070: PPUSH
65071: LD_VAR 0 11
65075: PPUSH
65076: CALL_OW 1
65080: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65081: LD_ADDR_VAR 0 4
65085: PUSH
65086: LD_VAR 0 4
65090: PUSH
65091: LD_VAR 0 6
65095: DIFF
65096: ST_TO_ADDR
// if tmp and eng < 4 then
65097: LD_VAR 0 4
65101: PUSH
65102: LD_VAR 0 6
65106: PUSH
65107: LD_INT 4
65109: LESS
65110: AND
65111: IFFALSE 65301
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65113: LD_ADDR_VAR 0 9
65117: PUSH
65118: LD_VAR 0 4
65122: PUSH
65123: LD_VAR 0 7
65127: PUSH
65128: LD_VAR 0 6
65132: UNION
65133: DIFF
65134: PPUSH
65135: LD_INT 2
65137: PPUSH
65138: CALL 55459 0 2
65142: ST_TO_ADDR
// p := [ ] ;
65143: LD_ADDR_VAR 0 11
65147: PUSH
65148: EMPTY
65149: ST_TO_ADDR
// if sort then
65150: LD_VAR 0 9
65154: IFFALSE 65270
// for i = 1 to 4 - eng do
65156: LD_ADDR_VAR 0 3
65160: PUSH
65161: DOUBLE
65162: LD_INT 1
65164: DEC
65165: ST_TO_ADDR
65166: LD_INT 4
65168: PUSH
65169: LD_VAR 0 6
65173: MINUS
65174: PUSH
65175: FOR_TO
65176: IFFALSE 65268
// begin if i = sort then
65178: LD_VAR 0 3
65182: PUSH
65183: LD_VAR 0 9
65187: EQUAL
65188: IFFALSE 65192
// break ;
65190: GO 65268
// if GetClass ( i ) = 2 then
65192: LD_VAR 0 3
65196: PPUSH
65197: CALL_OW 257
65201: PUSH
65202: LD_INT 2
65204: EQUAL
65205: IFFALSE 65209
// continue ;
65207: GO 65175
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65209: LD_ADDR_VAR 0 11
65213: PUSH
65214: LD_VAR 0 11
65218: PPUSH
65219: LD_VAR 0 11
65223: PUSH
65224: LD_INT 1
65226: PLUS
65227: PPUSH
65228: LD_VAR 0 9
65232: PUSH
65233: LD_VAR 0 3
65237: ARRAY
65238: PPUSH
65239: CALL_OW 2
65243: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65244: LD_ADDR_VAR 0 4
65248: PUSH
65249: LD_VAR 0 4
65253: PUSH
65254: LD_VAR 0 9
65258: PUSH
65259: LD_VAR 0 3
65263: ARRAY
65264: DIFF
65265: ST_TO_ADDR
// end ;
65266: GO 65175
65268: POP
65269: POP
// if p then
65270: LD_VAR 0 11
65274: IFFALSE 65299
// result := Replace ( result , 2 , p ) ;
65276: LD_ADDR_VAR 0 2
65280: PUSH
65281: LD_VAR 0 2
65285: PPUSH
65286: LD_INT 2
65288: PPUSH
65289: LD_VAR 0 11
65293: PPUSH
65294: CALL_OW 1
65298: ST_TO_ADDR
// end else
65299: GO 65345
// for i = eng downto 5 do
65301: LD_ADDR_VAR 0 3
65305: PUSH
65306: DOUBLE
65307: LD_VAR 0 6
65311: INC
65312: ST_TO_ADDR
65313: LD_INT 5
65315: PUSH
65316: FOR_DOWNTO
65317: IFFALSE 65343
// tmp := tmp union eng [ i ] ;
65319: LD_ADDR_VAR 0 4
65323: PUSH
65324: LD_VAR 0 4
65328: PUSH
65329: LD_VAR 0 6
65333: PUSH
65334: LD_VAR 0 3
65338: ARRAY
65339: UNION
65340: ST_TO_ADDR
65341: GO 65316
65343: POP
65344: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65345: LD_ADDR_VAR 0 2
65349: PUSH
65350: LD_VAR 0 2
65354: PPUSH
65355: LD_INT 1
65357: PPUSH
65358: LD_VAR 0 4
65362: PUSH
65363: LD_VAR 0 5
65367: DIFF
65368: PPUSH
65369: CALL_OW 1
65373: ST_TO_ADDR
// exit ;
65374: GO 65376
// end ; end ;
65376: LD_VAR 0 2
65380: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65381: LD_INT 0
65383: PPUSH
65384: PPUSH
65385: PPUSH
// if not mc_bases then
65386: LD_EXP 58
65390: NOT
65391: IFFALSE 65395
// exit ;
65393: GO 65501
// for i = 1 to mc_bases do
65395: LD_ADDR_VAR 0 2
65399: PUSH
65400: DOUBLE
65401: LD_INT 1
65403: DEC
65404: ST_TO_ADDR
65405: LD_EXP 58
65409: PUSH
65410: FOR_TO
65411: IFFALSE 65492
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65413: LD_ADDR_VAR 0 3
65417: PUSH
65418: LD_EXP 58
65422: PUSH
65423: LD_VAR 0 2
65427: ARRAY
65428: PPUSH
65429: LD_INT 21
65431: PUSH
65432: LD_INT 3
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 3
65441: PUSH
65442: LD_INT 24
65444: PUSH
65445: LD_INT 1000
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PPUSH
65460: CALL_OW 72
65464: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65465: LD_ADDR_EXP 59
65469: PUSH
65470: LD_EXP 59
65474: PPUSH
65475: LD_VAR 0 2
65479: PPUSH
65480: LD_VAR 0 3
65484: PPUSH
65485: CALL_OW 1
65489: ST_TO_ADDR
// end ;
65490: GO 65410
65492: POP
65493: POP
// RaiseSailEvent ( 101 ) ;
65494: LD_INT 101
65496: PPUSH
65497: CALL_OW 427
// end ;
65501: LD_VAR 0 1
65505: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65506: LD_INT 0
65508: PPUSH
65509: PPUSH
65510: PPUSH
65511: PPUSH
65512: PPUSH
65513: PPUSH
65514: PPUSH
// if not mc_bases then
65515: LD_EXP 58
65519: NOT
65520: IFFALSE 65524
// exit ;
65522: GO 66097
// for i = 1 to mc_bases do
65524: LD_ADDR_VAR 0 2
65528: PUSH
65529: DOUBLE
65530: LD_INT 1
65532: DEC
65533: ST_TO_ADDR
65534: LD_EXP 58
65538: PUSH
65539: FOR_TO
65540: IFFALSE 66088
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65542: LD_ADDR_VAR 0 5
65546: PUSH
65547: LD_EXP 58
65551: PUSH
65552: LD_VAR 0 2
65556: ARRAY
65557: PUSH
65558: LD_EXP 87
65562: PUSH
65563: LD_VAR 0 2
65567: ARRAY
65568: UNION
65569: PPUSH
65570: LD_INT 21
65572: PUSH
65573: LD_INT 1
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 1
65582: PUSH
65583: LD_INT 3
65585: PUSH
65586: LD_INT 54
65588: PUSH
65589: EMPTY
65590: LIST
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 3
65598: PUSH
65599: LD_INT 24
65601: PUSH
65602: LD_INT 800
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PPUSH
65622: CALL_OW 72
65626: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65627: LD_ADDR_VAR 0 6
65631: PUSH
65632: LD_EXP 58
65636: PUSH
65637: LD_VAR 0 2
65641: ARRAY
65642: PPUSH
65643: LD_INT 21
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 1
65655: PUSH
65656: LD_INT 3
65658: PUSH
65659: LD_INT 54
65661: PUSH
65662: EMPTY
65663: LIST
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 3
65671: PUSH
65672: LD_INT 24
65674: PUSH
65675: LD_INT 250
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: LIST
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PPUSH
65695: CALL_OW 72
65699: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65700: LD_ADDR_VAR 0 7
65704: PUSH
65705: LD_VAR 0 5
65709: PUSH
65710: LD_VAR 0 6
65714: DIFF
65715: ST_TO_ADDR
// if not need_heal_1 then
65716: LD_VAR 0 6
65720: NOT
65721: IFFALSE 65754
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65723: LD_ADDR_EXP 61
65727: PUSH
65728: LD_EXP 61
65732: PPUSH
65733: LD_VAR 0 2
65737: PUSH
65738: LD_INT 1
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PPUSH
65745: EMPTY
65746: PPUSH
65747: CALL 21211 0 3
65751: ST_TO_ADDR
65752: GO 65824
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65754: LD_ADDR_EXP 61
65758: PUSH
65759: LD_EXP 61
65763: PPUSH
65764: LD_VAR 0 2
65768: PUSH
65769: LD_INT 1
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PPUSH
65776: LD_EXP 61
65780: PUSH
65781: LD_VAR 0 2
65785: ARRAY
65786: PUSH
65787: LD_INT 1
65789: ARRAY
65790: PPUSH
65791: LD_INT 3
65793: PUSH
65794: LD_INT 24
65796: PUSH
65797: LD_INT 1000
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PPUSH
65808: CALL_OW 72
65812: PUSH
65813: LD_VAR 0 6
65817: UNION
65818: PPUSH
65819: CALL 21211 0 3
65823: ST_TO_ADDR
// if not need_heal_2 then
65824: LD_VAR 0 7
65828: NOT
65829: IFFALSE 65862
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65831: LD_ADDR_EXP 61
65835: PUSH
65836: LD_EXP 61
65840: PPUSH
65841: LD_VAR 0 2
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PPUSH
65853: EMPTY
65854: PPUSH
65855: CALL 21211 0 3
65859: ST_TO_ADDR
65860: GO 65894
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65862: LD_ADDR_EXP 61
65866: PUSH
65867: LD_EXP 61
65871: PPUSH
65872: LD_VAR 0 2
65876: PUSH
65877: LD_INT 2
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PPUSH
65884: LD_VAR 0 7
65888: PPUSH
65889: CALL 21211 0 3
65893: ST_TO_ADDR
// if need_heal_2 then
65894: LD_VAR 0 7
65898: IFFALSE 66070
// for j in need_heal_2 do
65900: LD_ADDR_VAR 0 3
65904: PUSH
65905: LD_VAR 0 7
65909: PUSH
65910: FOR_IN
65911: IFFALSE 66068
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65913: LD_ADDR_VAR 0 5
65917: PUSH
65918: LD_EXP 58
65922: PUSH
65923: LD_VAR 0 2
65927: ARRAY
65928: PPUSH
65929: LD_INT 2
65931: PUSH
65932: LD_INT 30
65934: PUSH
65935: LD_INT 6
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 30
65944: PUSH
65945: LD_INT 7
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 30
65954: PUSH
65955: LD_INT 8
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 30
65964: PUSH
65965: LD_INT 0
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: PUSH
65972: LD_INT 30
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PUSH
65982: LD_INT 25
65984: PUSH
65985: LD_INT 4
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: PPUSH
66001: CALL_OW 72
66005: ST_TO_ADDR
// if tmp then
66006: LD_VAR 0 5
66010: IFFALSE 66066
// begin k := NearestUnitToUnit ( tmp , j ) ;
66012: LD_ADDR_VAR 0 4
66016: PUSH
66017: LD_VAR 0 5
66021: PPUSH
66022: LD_VAR 0 3
66026: PPUSH
66027: CALL_OW 74
66031: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66032: LD_VAR 0 3
66036: PPUSH
66037: LD_VAR 0 4
66041: PPUSH
66042: CALL_OW 296
66046: PUSH
66047: LD_INT 7
66049: GREATER
66050: IFFALSE 66066
// ComMoveUnit ( j , k ) ;
66052: LD_VAR 0 3
66056: PPUSH
66057: LD_VAR 0 4
66061: PPUSH
66062: CALL_OW 112
// end ; end ;
66066: GO 65910
66068: POP
66069: POP
// if not need_heal_1 and not need_heal_2 then
66070: LD_VAR 0 6
66074: NOT
66075: PUSH
66076: LD_VAR 0 7
66080: NOT
66081: AND
66082: IFFALSE 66086
// continue ;
66084: GO 65539
// end ;
66086: GO 65539
66088: POP
66089: POP
// RaiseSailEvent ( 102 ) ;
66090: LD_INT 102
66092: PPUSH
66093: CALL_OW 427
// end ;
66097: LD_VAR 0 1
66101: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
66102: LD_INT 0
66104: PPUSH
66105: PPUSH
66106: PPUSH
66107: PPUSH
66108: PPUSH
66109: PPUSH
// if not mc_bases then
66110: LD_EXP 58
66114: NOT
66115: IFFALSE 66119
// exit ;
66117: GO 66829
// for i = 1 to mc_bases do
66119: LD_ADDR_VAR 0 2
66123: PUSH
66124: DOUBLE
66125: LD_INT 1
66127: DEC
66128: ST_TO_ADDR
66129: LD_EXP 58
66133: PUSH
66134: FOR_TO
66135: IFFALSE 66827
// begin if not mc_building_need_repair [ i ] then
66137: LD_EXP 59
66141: PUSH
66142: LD_VAR 0 2
66146: ARRAY
66147: NOT
66148: IFFALSE 66322
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66150: LD_ADDR_VAR 0 6
66154: PUSH
66155: LD_EXP 77
66159: PUSH
66160: LD_VAR 0 2
66164: ARRAY
66165: PPUSH
66166: LD_INT 3
66168: PUSH
66169: LD_INT 24
66171: PUSH
66172: LD_INT 1000
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PUSH
66183: LD_INT 2
66185: PUSH
66186: LD_INT 34
66188: PUSH
66189: LD_INT 13
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 34
66198: PUSH
66199: LD_INT 52
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: LIST
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: PPUSH
66215: CALL_OW 72
66219: ST_TO_ADDR
// if cranes then
66220: LD_VAR 0 6
66224: IFFALSE 66286
// for j in cranes do
66226: LD_ADDR_VAR 0 3
66230: PUSH
66231: LD_VAR 0 6
66235: PUSH
66236: FOR_IN
66237: IFFALSE 66284
// if not IsInArea ( j , mc_parking [ i ] ) then
66239: LD_VAR 0 3
66243: PPUSH
66244: LD_EXP 82
66248: PUSH
66249: LD_VAR 0 2
66253: ARRAY
66254: PPUSH
66255: CALL_OW 308
66259: NOT
66260: IFFALSE 66282
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66262: LD_VAR 0 3
66266: PPUSH
66267: LD_EXP 82
66271: PUSH
66272: LD_VAR 0 2
66276: ARRAY
66277: PPUSH
66278: CALL_OW 113
66282: GO 66236
66284: POP
66285: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66286: LD_ADDR_EXP 60
66290: PUSH
66291: LD_EXP 60
66295: PPUSH
66296: LD_VAR 0 2
66300: PPUSH
66301: EMPTY
66302: PPUSH
66303: CALL_OW 1
66307: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66308: LD_VAR 0 2
66312: PPUSH
66313: LD_INT 101
66315: PPUSH
66316: CALL 61214 0 2
// continue ;
66320: GO 66134
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66322: LD_ADDR_EXP 64
66326: PUSH
66327: LD_EXP 64
66331: PPUSH
66332: LD_VAR 0 2
66336: PPUSH
66337: EMPTY
66338: PPUSH
66339: CALL_OW 1
66343: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66344: LD_VAR 0 2
66348: PPUSH
66349: LD_INT 103
66351: PPUSH
66352: CALL 61214 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66356: LD_ADDR_VAR 0 5
66360: PUSH
66361: LD_EXP 58
66365: PUSH
66366: LD_VAR 0 2
66370: ARRAY
66371: PUSH
66372: LD_EXP 87
66376: PUSH
66377: LD_VAR 0 2
66381: ARRAY
66382: UNION
66383: PPUSH
66384: LD_INT 2
66386: PUSH
66387: LD_INT 25
66389: PUSH
66390: LD_INT 2
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 25
66399: PUSH
66400: LD_INT 16
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: LIST
66411: PUSH
66412: EMPTY
66413: LIST
66414: PPUSH
66415: CALL_OW 72
66419: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66420: LD_ADDR_VAR 0 6
66424: PUSH
66425: LD_EXP 77
66429: PUSH
66430: LD_VAR 0 2
66434: ARRAY
66435: PPUSH
66436: LD_INT 2
66438: PUSH
66439: LD_INT 34
66441: PUSH
66442: LD_INT 13
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: LD_INT 34
66451: PUSH
66452: LD_INT 52
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: LIST
66463: PPUSH
66464: CALL_OW 72
66468: ST_TO_ADDR
// if cranes then
66469: LD_VAR 0 6
66473: IFFALSE 66609
// begin for j in cranes do
66475: LD_ADDR_VAR 0 3
66479: PUSH
66480: LD_VAR 0 6
66484: PUSH
66485: FOR_IN
66486: IFFALSE 66607
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66488: LD_VAR 0 3
66492: PPUSH
66493: CALL_OW 256
66497: PUSH
66498: LD_INT 500
66500: GREATEREQUAL
66501: PUSH
66502: LD_VAR 0 3
66506: PPUSH
66507: CALL_OW 314
66511: NOT
66512: AND
66513: IFFALSE 66547
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66515: LD_VAR 0 3
66519: PPUSH
66520: LD_EXP 59
66524: PUSH
66525: LD_VAR 0 2
66529: ARRAY
66530: PPUSH
66531: LD_VAR 0 3
66535: PPUSH
66536: CALL_OW 74
66540: PPUSH
66541: CALL_OW 130
66545: GO 66605
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66547: LD_VAR 0 3
66551: PPUSH
66552: CALL_OW 256
66556: PUSH
66557: LD_INT 500
66559: LESS
66560: PUSH
66561: LD_VAR 0 3
66565: PPUSH
66566: LD_EXP 82
66570: PUSH
66571: LD_VAR 0 2
66575: ARRAY
66576: PPUSH
66577: CALL_OW 308
66581: NOT
66582: AND
66583: IFFALSE 66605
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66585: LD_VAR 0 3
66589: PPUSH
66590: LD_EXP 82
66594: PUSH
66595: LD_VAR 0 2
66599: ARRAY
66600: PPUSH
66601: CALL_OW 113
66605: GO 66485
66607: POP
66608: POP
// end ; if not tmp then
66609: LD_VAR 0 5
66613: NOT
66614: IFFALSE 66618
// continue ;
66616: GO 66134
// for j in tmp do
66618: LD_ADDR_VAR 0 3
66622: PUSH
66623: LD_VAR 0 5
66627: PUSH
66628: FOR_IN
66629: IFFALSE 66823
// begin if mc_need_heal [ i ] then
66631: LD_EXP 61
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: IFFALSE 66689
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66643: LD_VAR 0 3
66647: PUSH
66648: LD_EXP 61
66652: PUSH
66653: LD_VAR 0 2
66657: ARRAY
66658: PUSH
66659: LD_INT 1
66661: ARRAY
66662: IN
66663: PUSH
66664: LD_VAR 0 3
66668: PUSH
66669: LD_EXP 61
66673: PUSH
66674: LD_VAR 0 2
66678: ARRAY
66679: PUSH
66680: LD_INT 2
66682: ARRAY
66683: IN
66684: OR
66685: IFFALSE 66689
// continue ;
66687: GO 66628
// if IsInUnit ( j ) then
66689: LD_VAR 0 3
66693: PPUSH
66694: CALL_OW 310
66698: IFFALSE 66709
// ComExitBuilding ( j ) ;
66700: LD_VAR 0 3
66704: PPUSH
66705: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66709: LD_VAR 0 3
66713: PUSH
66714: LD_EXP 60
66718: PUSH
66719: LD_VAR 0 2
66723: ARRAY
66724: IN
66725: NOT
66726: IFFALSE 66784
// begin SetTag ( j , 101 ) ;
66728: LD_VAR 0 3
66732: PPUSH
66733: LD_INT 101
66735: PPUSH
66736: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66740: LD_ADDR_EXP 60
66744: PUSH
66745: LD_EXP 60
66749: PPUSH
66750: LD_VAR 0 2
66754: PUSH
66755: LD_EXP 60
66759: PUSH
66760: LD_VAR 0 2
66764: ARRAY
66765: PUSH
66766: LD_INT 1
66768: PLUS
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PPUSH
66774: LD_VAR 0 3
66778: PPUSH
66779: CALL 21211 0 3
66783: ST_TO_ADDR
// end ; wait ( 1 ) ;
66784: LD_INT 1
66786: PPUSH
66787: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66791: LD_VAR 0 3
66795: PPUSH
66796: LD_EXP 59
66800: PUSH
66801: LD_VAR 0 2
66805: ARRAY
66806: PPUSH
66807: LD_VAR 0 3
66811: PPUSH
66812: CALL_OW 74
66816: PPUSH
66817: CALL_OW 130
// end ;
66821: GO 66628
66823: POP
66824: POP
// end ;
66825: GO 66134
66827: POP
66828: POP
// end ;
66829: LD_VAR 0 1
66833: RET
// export function MC_Heal ; var i , j , tmp ; begin
66834: LD_INT 0
66836: PPUSH
66837: PPUSH
66838: PPUSH
66839: PPUSH
// if not mc_bases then
66840: LD_EXP 58
66844: NOT
66845: IFFALSE 66849
// exit ;
66847: GO 67251
// for i = 1 to mc_bases do
66849: LD_ADDR_VAR 0 2
66853: PUSH
66854: DOUBLE
66855: LD_INT 1
66857: DEC
66858: ST_TO_ADDR
66859: LD_EXP 58
66863: PUSH
66864: FOR_TO
66865: IFFALSE 67249
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66867: LD_EXP 61
66871: PUSH
66872: LD_VAR 0 2
66876: ARRAY
66877: PUSH
66878: LD_INT 1
66880: ARRAY
66881: NOT
66882: PUSH
66883: LD_EXP 61
66887: PUSH
66888: LD_VAR 0 2
66892: ARRAY
66893: PUSH
66894: LD_INT 2
66896: ARRAY
66897: NOT
66898: AND
66899: IFFALSE 66937
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66901: LD_ADDR_EXP 62
66905: PUSH
66906: LD_EXP 62
66910: PPUSH
66911: LD_VAR 0 2
66915: PPUSH
66916: EMPTY
66917: PPUSH
66918: CALL_OW 1
66922: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66923: LD_VAR 0 2
66927: PPUSH
66928: LD_INT 102
66930: PPUSH
66931: CALL 61214 0 2
// continue ;
66935: GO 66864
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66937: LD_ADDR_VAR 0 4
66941: PUSH
66942: LD_EXP 58
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: PPUSH
66953: LD_INT 25
66955: PUSH
66956: LD_INT 4
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PPUSH
66963: CALL_OW 72
66967: ST_TO_ADDR
// if not tmp then
66968: LD_VAR 0 4
66972: NOT
66973: IFFALSE 66977
// continue ;
66975: GO 66864
// if mc_taming [ i ] then
66977: LD_EXP 89
66981: PUSH
66982: LD_VAR 0 2
66986: ARRAY
66987: IFFALSE 67011
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66989: LD_ADDR_EXP 89
66993: PUSH
66994: LD_EXP 89
66998: PPUSH
66999: LD_VAR 0 2
67003: PPUSH
67004: EMPTY
67005: PPUSH
67006: CALL_OW 1
67010: ST_TO_ADDR
// for j in tmp do
67011: LD_ADDR_VAR 0 3
67015: PUSH
67016: LD_VAR 0 4
67020: PUSH
67021: FOR_IN
67022: IFFALSE 67245
// begin if IsInUnit ( j ) then
67024: LD_VAR 0 3
67028: PPUSH
67029: CALL_OW 310
67033: IFFALSE 67044
// ComExitBuilding ( j ) ;
67035: LD_VAR 0 3
67039: PPUSH
67040: CALL_OW 122
// if not j in mc_healers [ i ] then
67044: LD_VAR 0 3
67048: PUSH
67049: LD_EXP 62
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: IN
67060: NOT
67061: IFFALSE 67107
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67063: LD_ADDR_EXP 62
67067: PUSH
67068: LD_EXP 62
67072: PPUSH
67073: LD_VAR 0 2
67077: PUSH
67078: LD_EXP 62
67082: PUSH
67083: LD_VAR 0 2
67087: ARRAY
67088: PUSH
67089: LD_INT 1
67091: PLUS
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PPUSH
67097: LD_VAR 0 3
67101: PPUSH
67102: CALL 21211 0 3
67106: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67107: LD_VAR 0 3
67111: PPUSH
67112: CALL_OW 110
67116: PUSH
67117: LD_INT 102
67119: NONEQUAL
67120: IFFALSE 67134
// SetTag ( j , 102 ) ;
67122: LD_VAR 0 3
67126: PPUSH
67127: LD_INT 102
67129: PPUSH
67130: CALL_OW 109
// Wait ( 3 ) ;
67134: LD_INT 3
67136: PPUSH
67137: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67141: LD_EXP 61
67145: PUSH
67146: LD_VAR 0 2
67150: ARRAY
67151: PUSH
67152: LD_INT 1
67154: ARRAY
67155: IFFALSE 67187
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67157: LD_VAR 0 3
67161: PPUSH
67162: LD_EXP 61
67166: PUSH
67167: LD_VAR 0 2
67171: ARRAY
67172: PUSH
67173: LD_INT 1
67175: ARRAY
67176: PUSH
67177: LD_INT 1
67179: ARRAY
67180: PPUSH
67181: CALL_OW 128
67185: GO 67243
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67187: LD_VAR 0 3
67191: PPUSH
67192: CALL_OW 314
67196: NOT
67197: PUSH
67198: LD_EXP 61
67202: PUSH
67203: LD_VAR 0 2
67207: ARRAY
67208: PUSH
67209: LD_INT 2
67211: ARRAY
67212: AND
67213: IFFALSE 67243
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67215: LD_VAR 0 3
67219: PPUSH
67220: LD_EXP 61
67224: PUSH
67225: LD_VAR 0 2
67229: ARRAY
67230: PUSH
67231: LD_INT 2
67233: ARRAY
67234: PUSH
67235: LD_INT 1
67237: ARRAY
67238: PPUSH
67239: CALL_OW 128
// end ;
67243: GO 67021
67245: POP
67246: POP
// end ;
67247: GO 66864
67249: POP
67250: POP
// end ;
67251: LD_VAR 0 1
67255: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67256: LD_INT 0
67258: PPUSH
67259: PPUSH
67260: PPUSH
67261: PPUSH
67262: PPUSH
// if not mc_bases then
67263: LD_EXP 58
67267: NOT
67268: IFFALSE 67272
// exit ;
67270: GO 68415
// for i = 1 to mc_bases do
67272: LD_ADDR_VAR 0 2
67276: PUSH
67277: DOUBLE
67278: LD_INT 1
67280: DEC
67281: ST_TO_ADDR
67282: LD_EXP 58
67286: PUSH
67287: FOR_TO
67288: IFFALSE 68413
// begin if mc_scan [ i ] then
67290: LD_EXP 81
67294: PUSH
67295: LD_VAR 0 2
67299: ARRAY
67300: IFFALSE 67304
// continue ;
67302: GO 67287
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67304: LD_EXP 63
67308: PUSH
67309: LD_VAR 0 2
67313: ARRAY
67314: NOT
67315: PUSH
67316: LD_EXP 65
67320: PUSH
67321: LD_VAR 0 2
67325: ARRAY
67326: NOT
67327: AND
67328: PUSH
67329: LD_EXP 64
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: AND
67340: IFFALSE 67378
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67342: LD_ADDR_EXP 64
67346: PUSH
67347: LD_EXP 64
67351: PPUSH
67352: LD_VAR 0 2
67356: PPUSH
67357: EMPTY
67358: PPUSH
67359: CALL_OW 1
67363: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67364: LD_VAR 0 2
67368: PPUSH
67369: LD_INT 103
67371: PPUSH
67372: CALL 61214 0 2
// continue ;
67376: GO 67287
// end ; if mc_construct_list [ i ] then
67378: LD_EXP 65
67382: PUSH
67383: LD_VAR 0 2
67387: ARRAY
67388: IFFALSE 67608
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67390: LD_ADDR_VAR 0 4
67394: PUSH
67395: LD_EXP 58
67399: PUSH
67400: LD_VAR 0 2
67404: ARRAY
67405: PPUSH
67406: LD_INT 25
67408: PUSH
67409: LD_INT 2
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PPUSH
67416: CALL_OW 72
67420: PUSH
67421: LD_EXP 60
67425: PUSH
67426: LD_VAR 0 2
67430: ARRAY
67431: DIFF
67432: ST_TO_ADDR
// if not tmp then
67433: LD_VAR 0 4
67437: NOT
67438: IFFALSE 67442
// continue ;
67440: GO 67287
// for j in tmp do
67442: LD_ADDR_VAR 0 3
67446: PUSH
67447: LD_VAR 0 4
67451: PUSH
67452: FOR_IN
67453: IFFALSE 67604
// begin if not mc_builders [ i ] then
67455: LD_EXP 64
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: NOT
67466: IFFALSE 67524
// begin SetTag ( j , 103 ) ;
67468: LD_VAR 0 3
67472: PPUSH
67473: LD_INT 103
67475: PPUSH
67476: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67480: LD_ADDR_EXP 64
67484: PUSH
67485: LD_EXP 64
67489: PPUSH
67490: LD_VAR 0 2
67494: PUSH
67495: LD_EXP 64
67499: PUSH
67500: LD_VAR 0 2
67504: ARRAY
67505: PUSH
67506: LD_INT 1
67508: PLUS
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PPUSH
67514: LD_VAR 0 3
67518: PPUSH
67519: CALL 21211 0 3
67523: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67524: LD_VAR 0 3
67528: PPUSH
67529: CALL_OW 310
67533: IFFALSE 67544
// ComExitBuilding ( j ) ;
67535: LD_VAR 0 3
67539: PPUSH
67540: CALL_OW 122
// wait ( 3 ) ;
67544: LD_INT 3
67546: PPUSH
67547: CALL_OW 67
// if not mc_construct_list [ i ] then
67551: LD_EXP 65
67555: PUSH
67556: LD_VAR 0 2
67560: ARRAY
67561: NOT
67562: IFFALSE 67566
// break ;
67564: GO 67604
// if not HasTask ( j ) then
67566: LD_VAR 0 3
67570: PPUSH
67571: CALL_OW 314
67575: NOT
67576: IFFALSE 67602
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67578: LD_VAR 0 3
67582: PPUSH
67583: LD_EXP 65
67587: PUSH
67588: LD_VAR 0 2
67592: ARRAY
67593: PUSH
67594: LD_INT 1
67596: ARRAY
67597: PPUSH
67598: CALL 24062 0 2
// end ;
67602: GO 67452
67604: POP
67605: POP
// end else
67606: GO 68411
// if mc_build_list [ i ] then
67608: LD_EXP 63
67612: PUSH
67613: LD_VAR 0 2
67617: ARRAY
67618: IFFALSE 68411
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67620: LD_ADDR_VAR 0 5
67624: PUSH
67625: LD_EXP 58
67629: PUSH
67630: LD_VAR 0 2
67634: ARRAY
67635: PPUSH
67636: LD_INT 2
67638: PUSH
67639: LD_INT 30
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 30
67651: PUSH
67652: LD_INT 1
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: LIST
67663: PPUSH
67664: CALL_OW 72
67668: ST_TO_ADDR
// if depot then
67669: LD_VAR 0 5
67673: IFFALSE 67691
// depot := depot [ 1 ] else
67675: LD_ADDR_VAR 0 5
67679: PUSH
67680: LD_VAR 0 5
67684: PUSH
67685: LD_INT 1
67687: ARRAY
67688: ST_TO_ADDR
67689: GO 67699
// depot := 0 ;
67691: LD_ADDR_VAR 0 5
67695: PUSH
67696: LD_INT 0
67698: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67699: LD_EXP 63
67703: PUSH
67704: LD_VAR 0 2
67708: ARRAY
67709: PUSH
67710: LD_INT 1
67712: ARRAY
67713: PUSH
67714: LD_INT 1
67716: ARRAY
67717: PPUSH
67718: CALL 23892 0 1
67722: PUSH
67723: LD_EXP 58
67727: PUSH
67728: LD_VAR 0 2
67732: ARRAY
67733: PPUSH
67734: LD_INT 2
67736: PUSH
67737: LD_INT 30
67739: PUSH
67740: LD_INT 2
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 30
67749: PUSH
67750: LD_INT 3
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: LIST
67761: PPUSH
67762: CALL_OW 72
67766: NOT
67767: AND
67768: IFFALSE 67873
// begin for j = 1 to mc_build_list [ i ] do
67770: LD_ADDR_VAR 0 3
67774: PUSH
67775: DOUBLE
67776: LD_INT 1
67778: DEC
67779: ST_TO_ADDR
67780: LD_EXP 63
67784: PUSH
67785: LD_VAR 0 2
67789: ARRAY
67790: PUSH
67791: FOR_TO
67792: IFFALSE 67871
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67794: LD_EXP 63
67798: PUSH
67799: LD_VAR 0 2
67803: ARRAY
67804: PUSH
67805: LD_VAR 0 3
67809: ARRAY
67810: PUSH
67811: LD_INT 1
67813: ARRAY
67814: PUSH
67815: LD_INT 2
67817: EQUAL
67818: IFFALSE 67869
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67820: LD_ADDR_EXP 63
67824: PUSH
67825: LD_EXP 63
67829: PPUSH
67830: LD_VAR 0 2
67834: PPUSH
67835: LD_EXP 63
67839: PUSH
67840: LD_VAR 0 2
67844: ARRAY
67845: PPUSH
67846: LD_VAR 0 3
67850: PPUSH
67851: LD_INT 1
67853: PPUSH
67854: LD_INT 0
67856: PPUSH
67857: CALL 20629 0 4
67861: PPUSH
67862: CALL_OW 1
67866: ST_TO_ADDR
// break ;
67867: GO 67871
// end ;
67869: GO 67791
67871: POP
67872: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67873: LD_EXP 63
67877: PUSH
67878: LD_VAR 0 2
67882: ARRAY
67883: PUSH
67884: LD_INT 1
67886: ARRAY
67887: PUSH
67888: LD_INT 1
67890: ARRAY
67891: PUSH
67892: LD_INT 0
67894: EQUAL
67895: PUSH
67896: LD_VAR 0 5
67900: PUSH
67901: LD_VAR 0 5
67905: PPUSH
67906: LD_EXP 63
67910: PUSH
67911: LD_VAR 0 2
67915: ARRAY
67916: PUSH
67917: LD_INT 1
67919: ARRAY
67920: PUSH
67921: LD_INT 1
67923: ARRAY
67924: PPUSH
67925: LD_EXP 63
67929: PUSH
67930: LD_VAR 0 2
67934: ARRAY
67935: PUSH
67936: LD_INT 1
67938: ARRAY
67939: PUSH
67940: LD_INT 2
67942: ARRAY
67943: PPUSH
67944: LD_EXP 63
67948: PUSH
67949: LD_VAR 0 2
67953: ARRAY
67954: PUSH
67955: LD_INT 1
67957: ARRAY
67958: PUSH
67959: LD_INT 3
67961: ARRAY
67962: PPUSH
67963: LD_EXP 63
67967: PUSH
67968: LD_VAR 0 2
67972: ARRAY
67973: PUSH
67974: LD_INT 1
67976: ARRAY
67977: PUSH
67978: LD_INT 4
67980: ARRAY
67981: PPUSH
67982: CALL 28626 0 5
67986: AND
67987: OR
67988: IFFALSE 68269
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67990: LD_ADDR_VAR 0 4
67994: PUSH
67995: LD_EXP 58
67999: PUSH
68000: LD_VAR 0 2
68004: ARRAY
68005: PPUSH
68006: LD_INT 25
68008: PUSH
68009: LD_INT 2
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PPUSH
68016: CALL_OW 72
68020: PUSH
68021: LD_EXP 60
68025: PUSH
68026: LD_VAR 0 2
68030: ARRAY
68031: DIFF
68032: ST_TO_ADDR
// if not tmp then
68033: LD_VAR 0 4
68037: NOT
68038: IFFALSE 68042
// continue ;
68040: GO 67287
// for j in tmp do
68042: LD_ADDR_VAR 0 3
68046: PUSH
68047: LD_VAR 0 4
68051: PUSH
68052: FOR_IN
68053: IFFALSE 68265
// begin if not mc_builders [ i ] then
68055: LD_EXP 64
68059: PUSH
68060: LD_VAR 0 2
68064: ARRAY
68065: NOT
68066: IFFALSE 68124
// begin SetTag ( j , 103 ) ;
68068: LD_VAR 0 3
68072: PPUSH
68073: LD_INT 103
68075: PPUSH
68076: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68080: LD_ADDR_EXP 64
68084: PUSH
68085: LD_EXP 64
68089: PPUSH
68090: LD_VAR 0 2
68094: PUSH
68095: LD_EXP 64
68099: PUSH
68100: LD_VAR 0 2
68104: ARRAY
68105: PUSH
68106: LD_INT 1
68108: PLUS
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PPUSH
68114: LD_VAR 0 3
68118: PPUSH
68119: CALL 21211 0 3
68123: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68124: LD_VAR 0 3
68128: PPUSH
68129: CALL_OW 310
68133: IFFALSE 68144
// ComExitBuilding ( j ) ;
68135: LD_VAR 0 3
68139: PPUSH
68140: CALL_OW 122
// wait ( 3 ) ;
68144: LD_INT 3
68146: PPUSH
68147: CALL_OW 67
// if not mc_build_list [ i ] then
68151: LD_EXP 63
68155: PUSH
68156: LD_VAR 0 2
68160: ARRAY
68161: NOT
68162: IFFALSE 68166
// break ;
68164: GO 68265
// if not HasTask ( j ) then
68166: LD_VAR 0 3
68170: PPUSH
68171: CALL_OW 314
68175: NOT
68176: IFFALSE 68263
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68178: LD_VAR 0 3
68182: PPUSH
68183: LD_EXP 63
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: PUSH
68194: LD_INT 1
68196: ARRAY
68197: PUSH
68198: LD_INT 1
68200: ARRAY
68201: PPUSH
68202: LD_EXP 63
68206: PUSH
68207: LD_VAR 0 2
68211: ARRAY
68212: PUSH
68213: LD_INT 1
68215: ARRAY
68216: PUSH
68217: LD_INT 2
68219: ARRAY
68220: PPUSH
68221: LD_EXP 63
68225: PUSH
68226: LD_VAR 0 2
68230: ARRAY
68231: PUSH
68232: LD_INT 1
68234: ARRAY
68235: PUSH
68236: LD_INT 3
68238: ARRAY
68239: PPUSH
68240: LD_EXP 63
68244: PUSH
68245: LD_VAR 0 2
68249: ARRAY
68250: PUSH
68251: LD_INT 1
68253: ARRAY
68254: PUSH
68255: LD_INT 4
68257: ARRAY
68258: PPUSH
68259: CALL_OW 145
// end ;
68263: GO 68052
68265: POP
68266: POP
// end else
68267: GO 68411
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68269: LD_EXP 58
68273: PUSH
68274: LD_VAR 0 2
68278: ARRAY
68279: PPUSH
68280: LD_EXP 63
68284: PUSH
68285: LD_VAR 0 2
68289: ARRAY
68290: PUSH
68291: LD_INT 1
68293: ARRAY
68294: PUSH
68295: LD_INT 1
68297: ARRAY
68298: PPUSH
68299: LD_EXP 63
68303: PUSH
68304: LD_VAR 0 2
68308: ARRAY
68309: PUSH
68310: LD_INT 1
68312: ARRAY
68313: PUSH
68314: LD_INT 2
68316: ARRAY
68317: PPUSH
68318: LD_EXP 63
68322: PUSH
68323: LD_VAR 0 2
68327: ARRAY
68328: PUSH
68329: LD_INT 1
68331: ARRAY
68332: PUSH
68333: LD_INT 3
68335: ARRAY
68336: PPUSH
68337: LD_EXP 63
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PUSH
68348: LD_INT 1
68350: ARRAY
68351: PUSH
68352: LD_INT 4
68354: ARRAY
68355: PPUSH
68356: CALL 27962 0 5
68360: NOT
68361: IFFALSE 68411
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68363: LD_ADDR_EXP 63
68367: PUSH
68368: LD_EXP 63
68372: PPUSH
68373: LD_VAR 0 2
68377: PPUSH
68378: LD_EXP 63
68382: PUSH
68383: LD_VAR 0 2
68387: ARRAY
68388: PPUSH
68389: LD_INT 1
68391: PPUSH
68392: LD_INT 1
68394: NEG
68395: PPUSH
68396: LD_INT 0
68398: PPUSH
68399: CALL 20629 0 4
68403: PPUSH
68404: CALL_OW 1
68408: ST_TO_ADDR
// continue ;
68409: GO 67287
// end ; end ; end ;
68411: GO 67287
68413: POP
68414: POP
// end ;
68415: LD_VAR 0 1
68419: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68420: LD_INT 0
68422: PPUSH
68423: PPUSH
68424: PPUSH
68425: PPUSH
68426: PPUSH
68427: PPUSH
// if not mc_bases then
68428: LD_EXP 58
68432: NOT
68433: IFFALSE 68437
// exit ;
68435: GO 68864
// for i = 1 to mc_bases do
68437: LD_ADDR_VAR 0 2
68441: PUSH
68442: DOUBLE
68443: LD_INT 1
68445: DEC
68446: ST_TO_ADDR
68447: LD_EXP 58
68451: PUSH
68452: FOR_TO
68453: IFFALSE 68862
// begin tmp := mc_build_upgrade [ i ] ;
68455: LD_ADDR_VAR 0 4
68459: PUSH
68460: LD_EXP 90
68464: PUSH
68465: LD_VAR 0 2
68469: ARRAY
68470: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68471: LD_ADDR_VAR 0 6
68475: PUSH
68476: LD_EXP 91
68480: PUSH
68481: LD_VAR 0 2
68485: ARRAY
68486: PPUSH
68487: LD_INT 2
68489: PUSH
68490: LD_INT 30
68492: PUSH
68493: LD_INT 6
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 30
68502: PUSH
68503: LD_INT 7
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: LIST
68514: PPUSH
68515: CALL_OW 72
68519: ST_TO_ADDR
// if not tmp and not lab then
68520: LD_VAR 0 4
68524: NOT
68525: PUSH
68526: LD_VAR 0 6
68530: NOT
68531: AND
68532: IFFALSE 68536
// continue ;
68534: GO 68452
// if tmp then
68536: LD_VAR 0 4
68540: IFFALSE 68660
// for j in tmp do
68542: LD_ADDR_VAR 0 3
68546: PUSH
68547: LD_VAR 0 4
68551: PUSH
68552: FOR_IN
68553: IFFALSE 68658
// begin if UpgradeCost ( j ) then
68555: LD_VAR 0 3
68559: PPUSH
68560: CALL 27622 0 1
68564: IFFALSE 68656
// begin ComUpgrade ( j ) ;
68566: LD_VAR 0 3
68570: PPUSH
68571: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68575: LD_ADDR_EXP 90
68579: PUSH
68580: LD_EXP 90
68584: PPUSH
68585: LD_VAR 0 2
68589: PPUSH
68590: LD_EXP 90
68594: PUSH
68595: LD_VAR 0 2
68599: ARRAY
68600: PUSH
68601: LD_VAR 0 3
68605: DIFF
68606: PPUSH
68607: CALL_OW 1
68611: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68612: LD_ADDR_EXP 65
68616: PUSH
68617: LD_EXP 65
68621: PPUSH
68622: LD_VAR 0 2
68626: PUSH
68627: LD_EXP 65
68631: PUSH
68632: LD_VAR 0 2
68636: ARRAY
68637: PUSH
68638: LD_INT 1
68640: PLUS
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PPUSH
68646: LD_VAR 0 3
68650: PPUSH
68651: CALL 21211 0 3
68655: ST_TO_ADDR
// end ; end ;
68656: GO 68552
68658: POP
68659: POP
// if not lab or not mc_lab_upgrade [ i ] then
68660: LD_VAR 0 6
68664: NOT
68665: PUSH
68666: LD_EXP 92
68670: PUSH
68671: LD_VAR 0 2
68675: ARRAY
68676: NOT
68677: OR
68678: IFFALSE 68682
// continue ;
68680: GO 68452
// for j in lab do
68682: LD_ADDR_VAR 0 3
68686: PUSH
68687: LD_VAR 0 6
68691: PUSH
68692: FOR_IN
68693: IFFALSE 68858
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68695: LD_VAR 0 3
68699: PPUSH
68700: CALL_OW 266
68704: PUSH
68705: LD_INT 6
68707: PUSH
68708: LD_INT 7
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: IN
68715: PUSH
68716: LD_VAR 0 3
68720: PPUSH
68721: CALL_OW 461
68725: PUSH
68726: LD_INT 1
68728: NONEQUAL
68729: AND
68730: IFFALSE 68856
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68732: LD_VAR 0 3
68736: PPUSH
68737: LD_EXP 92
68741: PUSH
68742: LD_VAR 0 2
68746: ARRAY
68747: PUSH
68748: LD_INT 1
68750: ARRAY
68751: PPUSH
68752: CALL 27827 0 2
68756: IFFALSE 68856
// begin ComCancel ( j ) ;
68758: LD_VAR 0 3
68762: PPUSH
68763: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68767: LD_VAR 0 3
68771: PPUSH
68772: LD_EXP 92
68776: PUSH
68777: LD_VAR 0 2
68781: ARRAY
68782: PUSH
68783: LD_INT 1
68785: ARRAY
68786: PPUSH
68787: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68791: LD_VAR 0 3
68795: PUSH
68796: LD_EXP 65
68800: PUSH
68801: LD_VAR 0 2
68805: ARRAY
68806: IN
68807: NOT
68808: IFFALSE 68854
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68810: LD_ADDR_EXP 65
68814: PUSH
68815: LD_EXP 65
68819: PPUSH
68820: LD_VAR 0 2
68824: PUSH
68825: LD_EXP 65
68829: PUSH
68830: LD_VAR 0 2
68834: ARRAY
68835: PUSH
68836: LD_INT 1
68838: PLUS
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PPUSH
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL 21211 0 3
68853: ST_TO_ADDR
// break ;
68854: GO 68858
// end ; end ; end ;
68856: GO 68692
68858: POP
68859: POP
// end ;
68860: GO 68452
68862: POP
68863: POP
// end ;
68864: LD_VAR 0 1
68868: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68869: LD_INT 0
68871: PPUSH
68872: PPUSH
68873: PPUSH
68874: PPUSH
68875: PPUSH
68876: PPUSH
68877: PPUSH
68878: PPUSH
68879: PPUSH
// if not mc_bases then
68880: LD_EXP 58
68884: NOT
68885: IFFALSE 68889
// exit ;
68887: GO 69294
// for i = 1 to mc_bases do
68889: LD_ADDR_VAR 0 2
68893: PUSH
68894: DOUBLE
68895: LD_INT 1
68897: DEC
68898: ST_TO_ADDR
68899: LD_EXP 58
68903: PUSH
68904: FOR_TO
68905: IFFALSE 69292
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68907: LD_EXP 66
68911: PUSH
68912: LD_VAR 0 2
68916: ARRAY
68917: NOT
68918: PUSH
68919: LD_EXP 58
68923: PUSH
68924: LD_VAR 0 2
68928: ARRAY
68929: PPUSH
68930: LD_INT 30
68932: PUSH
68933: LD_INT 3
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PPUSH
68940: CALL_OW 72
68944: NOT
68945: OR
68946: IFFALSE 68950
// continue ;
68948: GO 68904
// busy := false ;
68950: LD_ADDR_VAR 0 8
68954: PUSH
68955: LD_INT 0
68957: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68958: LD_ADDR_VAR 0 4
68962: PUSH
68963: LD_EXP 58
68967: PUSH
68968: LD_VAR 0 2
68972: ARRAY
68973: PPUSH
68974: LD_INT 30
68976: PUSH
68977: LD_INT 3
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PPUSH
68984: CALL_OW 72
68988: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68989: LD_ADDR_VAR 0 6
68993: PUSH
68994: LD_EXP 66
68998: PUSH
68999: LD_VAR 0 2
69003: ARRAY
69004: PPUSH
69005: LD_INT 2
69007: PUSH
69008: LD_INT 30
69010: PUSH
69011: LD_INT 32
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 30
69020: PUSH
69021: LD_INT 33
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: EMPTY
69029: LIST
69030: LIST
69031: LIST
69032: PPUSH
69033: CALL_OW 72
69037: ST_TO_ADDR
// if not t then
69038: LD_VAR 0 6
69042: NOT
69043: IFFALSE 69047
// continue ;
69045: GO 68904
// for j in tmp do
69047: LD_ADDR_VAR 0 3
69051: PUSH
69052: LD_VAR 0 4
69056: PUSH
69057: FOR_IN
69058: IFFALSE 69088
// if not BuildingStatus ( j ) = bs_idle then
69060: LD_VAR 0 3
69064: PPUSH
69065: CALL_OW 461
69069: PUSH
69070: LD_INT 2
69072: EQUAL
69073: NOT
69074: IFFALSE 69086
// begin busy := true ;
69076: LD_ADDR_VAR 0 8
69080: PUSH
69081: LD_INT 1
69083: ST_TO_ADDR
// break ;
69084: GO 69088
// end ;
69086: GO 69057
69088: POP
69089: POP
// if busy then
69090: LD_VAR 0 8
69094: IFFALSE 69098
// continue ;
69096: GO 68904
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69098: LD_ADDR_VAR 0 7
69102: PUSH
69103: LD_VAR 0 6
69107: PPUSH
69108: LD_INT 35
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PPUSH
69118: CALL_OW 72
69122: ST_TO_ADDR
// if tw then
69123: LD_VAR 0 7
69127: IFFALSE 69204
// begin tw := tw [ 1 ] ;
69129: LD_ADDR_VAR 0 7
69133: PUSH
69134: LD_VAR 0 7
69138: PUSH
69139: LD_INT 1
69141: ARRAY
69142: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69143: LD_ADDR_VAR 0 9
69147: PUSH
69148: LD_VAR 0 7
69152: PPUSH
69153: LD_EXP 83
69157: PUSH
69158: LD_VAR 0 2
69162: ARRAY
69163: PPUSH
69164: CALL 26181 0 2
69168: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69169: LD_EXP 97
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: IFFALSE 69202
// if not weapon in mc_allowed_tower_weapons [ i ] then
69181: LD_VAR 0 9
69185: PUSH
69186: LD_EXP 97
69190: PUSH
69191: LD_VAR 0 2
69195: ARRAY
69196: IN
69197: NOT
69198: IFFALSE 69202
// continue ;
69200: GO 68904
// end else
69202: GO 69267
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69204: LD_ADDR_VAR 0 5
69208: PUSH
69209: LD_EXP 66
69213: PUSH
69214: LD_VAR 0 2
69218: ARRAY
69219: PPUSH
69220: LD_VAR 0 4
69224: PPUSH
69225: CALL 56382 0 2
69229: ST_TO_ADDR
// if not tmp2 then
69230: LD_VAR 0 5
69234: NOT
69235: IFFALSE 69239
// continue ;
69237: GO 68904
// tw := tmp2 [ 1 ] ;
69239: LD_ADDR_VAR 0 7
69243: PUSH
69244: LD_VAR 0 5
69248: PUSH
69249: LD_INT 1
69251: ARRAY
69252: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69253: LD_ADDR_VAR 0 9
69257: PUSH
69258: LD_VAR 0 5
69262: PUSH
69263: LD_INT 2
69265: ARRAY
69266: ST_TO_ADDR
// end ; if not weapon then
69267: LD_VAR 0 9
69271: NOT
69272: IFFALSE 69276
// continue ;
69274: GO 68904
// ComPlaceWeapon ( tw , weapon ) ;
69276: LD_VAR 0 7
69280: PPUSH
69281: LD_VAR 0 9
69285: PPUSH
69286: CALL_OW 148
// end ;
69290: GO 68904
69292: POP
69293: POP
// end ;
69294: LD_VAR 0 1
69298: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69299: LD_INT 0
69301: PPUSH
69302: PPUSH
69303: PPUSH
69304: PPUSH
69305: PPUSH
69306: PPUSH
// if not mc_bases then
69307: LD_EXP 58
69311: NOT
69312: IFFALSE 69316
// exit ;
69314: GO 70328
// for i = 1 to mc_bases do
69316: LD_ADDR_VAR 0 2
69320: PUSH
69321: DOUBLE
69322: LD_INT 1
69324: DEC
69325: ST_TO_ADDR
69326: LD_EXP 58
69330: PUSH
69331: FOR_TO
69332: IFFALSE 70326
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69334: LD_EXP 71
69338: PUSH
69339: LD_VAR 0 2
69343: ARRAY
69344: NOT
69345: PUSH
69346: LD_EXP 71
69350: PUSH
69351: LD_VAR 0 2
69355: ARRAY
69356: PUSH
69357: LD_EXP 72
69361: PUSH
69362: LD_VAR 0 2
69366: ARRAY
69367: EQUAL
69368: OR
69369: IFFALSE 69373
// continue ;
69371: GO 69331
// if mc_miners [ i ] then
69373: LD_EXP 72
69377: PUSH
69378: LD_VAR 0 2
69382: ARRAY
69383: IFFALSE 70013
// begin k := 1 ;
69385: LD_ADDR_VAR 0 4
69389: PUSH
69390: LD_INT 1
69392: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69393: LD_ADDR_VAR 0 3
69397: PUSH
69398: DOUBLE
69399: LD_EXP 72
69403: PUSH
69404: LD_VAR 0 2
69408: ARRAY
69409: INC
69410: ST_TO_ADDR
69411: LD_INT 1
69413: PUSH
69414: FOR_DOWNTO
69415: IFFALSE 70011
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69417: LD_EXP 72
69421: PUSH
69422: LD_VAR 0 2
69426: ARRAY
69427: PUSH
69428: LD_VAR 0 3
69432: ARRAY
69433: PPUSH
69434: CALL_OW 301
69438: PUSH
69439: LD_EXP 72
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: PUSH
69450: LD_VAR 0 3
69454: ARRAY
69455: PPUSH
69456: CALL_OW 257
69460: PUSH
69461: LD_INT 1
69463: NONEQUAL
69464: OR
69465: IFFALSE 69528
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69467: LD_ADDR_VAR 0 5
69471: PUSH
69472: LD_EXP 72
69476: PUSH
69477: LD_VAR 0 2
69481: ARRAY
69482: PUSH
69483: LD_EXP 72
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: PUSH
69494: LD_VAR 0 3
69498: ARRAY
69499: DIFF
69500: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69501: LD_ADDR_EXP 72
69505: PUSH
69506: LD_EXP 72
69510: PPUSH
69511: LD_VAR 0 2
69515: PPUSH
69516: LD_VAR 0 5
69520: PPUSH
69521: CALL_OW 1
69525: ST_TO_ADDR
// continue ;
69526: GO 69414
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69528: LD_EXP 72
69532: PUSH
69533: LD_VAR 0 2
69537: ARRAY
69538: PUSH
69539: LD_VAR 0 3
69543: ARRAY
69544: PPUSH
69545: CALL 21147 0 1
69549: PUSH
69550: LD_EXP 72
69554: PUSH
69555: LD_VAR 0 2
69559: ARRAY
69560: PUSH
69561: LD_VAR 0 3
69565: ARRAY
69566: PPUSH
69567: CALL_OW 255
69571: PPUSH
69572: LD_EXP 71
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: PUSH
69583: LD_VAR 0 4
69587: ARRAY
69588: PUSH
69589: LD_INT 1
69591: ARRAY
69592: PPUSH
69593: LD_EXP 71
69597: PUSH
69598: LD_VAR 0 2
69602: ARRAY
69603: PUSH
69604: LD_VAR 0 4
69608: ARRAY
69609: PUSH
69610: LD_INT 2
69612: ARRAY
69613: PPUSH
69614: LD_INT 15
69616: PPUSH
69617: CALL 22107 0 4
69621: PUSH
69622: LD_INT 4
69624: ARRAY
69625: PUSH
69626: LD_EXP 72
69630: PUSH
69631: LD_VAR 0 2
69635: ARRAY
69636: PUSH
69637: LD_VAR 0 3
69641: ARRAY
69642: PPUSH
69643: LD_INT 10
69645: PPUSH
69646: CALL 23804 0 2
69650: PUSH
69651: LD_INT 4
69653: ARRAY
69654: OR
69655: AND
69656: IFFALSE 69679
// ComStop ( mc_miners [ i ] [ j ] ) ;
69658: LD_EXP 72
69662: PUSH
69663: LD_VAR 0 2
69667: ARRAY
69668: PUSH
69669: LD_VAR 0 3
69673: ARRAY
69674: PPUSH
69675: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69679: LD_EXP 72
69683: PUSH
69684: LD_VAR 0 2
69688: ARRAY
69689: PUSH
69690: LD_VAR 0 3
69694: ARRAY
69695: PPUSH
69696: CALL_OW 257
69700: PUSH
69701: LD_INT 1
69703: EQUAL
69704: PUSH
69705: LD_EXP 72
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_VAR 0 3
69720: ARRAY
69721: PPUSH
69722: CALL_OW 459
69726: NOT
69727: AND
69728: PUSH
69729: LD_EXP 72
69733: PUSH
69734: LD_VAR 0 2
69738: ARRAY
69739: PUSH
69740: LD_VAR 0 3
69744: ARRAY
69745: PPUSH
69746: CALL_OW 255
69750: PPUSH
69751: LD_EXP 71
69755: PUSH
69756: LD_VAR 0 2
69760: ARRAY
69761: PUSH
69762: LD_VAR 0 4
69766: ARRAY
69767: PUSH
69768: LD_INT 1
69770: ARRAY
69771: PPUSH
69772: LD_EXP 71
69776: PUSH
69777: LD_VAR 0 2
69781: ARRAY
69782: PUSH
69783: LD_VAR 0 4
69787: ARRAY
69788: PUSH
69789: LD_INT 2
69791: ARRAY
69792: PPUSH
69793: LD_INT 15
69795: PPUSH
69796: CALL 22107 0 4
69800: PUSH
69801: LD_INT 4
69803: ARRAY
69804: PUSH
69805: LD_INT 0
69807: EQUAL
69808: AND
69809: PUSH
69810: LD_EXP 72
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: PUSH
69821: LD_VAR 0 3
69825: ARRAY
69826: PPUSH
69827: CALL_OW 314
69831: NOT
69832: AND
69833: IFFALSE 70009
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69835: LD_EXP 72
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: PUSH
69846: LD_VAR 0 3
69850: ARRAY
69851: PPUSH
69852: CALL_OW 310
69856: IFFALSE 69879
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69858: LD_EXP 72
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: PUSH
69869: LD_VAR 0 3
69873: ARRAY
69874: PPUSH
69875: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69879: LD_EXP 72
69883: PUSH
69884: LD_VAR 0 2
69888: ARRAY
69889: PUSH
69890: LD_VAR 0 3
69894: ARRAY
69895: PPUSH
69896: CALL_OW 314
69900: NOT
69901: IFFALSE 69969
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69903: LD_EXP 72
69907: PUSH
69908: LD_VAR 0 2
69912: ARRAY
69913: PUSH
69914: LD_VAR 0 3
69918: ARRAY
69919: PPUSH
69920: LD_EXP 71
69924: PUSH
69925: LD_VAR 0 2
69929: ARRAY
69930: PUSH
69931: LD_VAR 0 4
69935: ARRAY
69936: PUSH
69937: LD_INT 1
69939: ARRAY
69940: PPUSH
69941: LD_EXP 71
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_VAR 0 4
69956: ARRAY
69957: PUSH
69958: LD_INT 2
69960: ARRAY
69961: PPUSH
69962: LD_INT 0
69964: PPUSH
69965: CALL_OW 193
// k := k + 1 ;
69969: LD_ADDR_VAR 0 4
69973: PUSH
69974: LD_VAR 0 4
69978: PUSH
69979: LD_INT 1
69981: PLUS
69982: ST_TO_ADDR
// if k > mc_mines [ i ] then
69983: LD_VAR 0 4
69987: PUSH
69988: LD_EXP 71
69992: PUSH
69993: LD_VAR 0 2
69997: ARRAY
69998: GREATER
69999: IFFALSE 70009
// k := 1 ;
70001: LD_ADDR_VAR 0 4
70005: PUSH
70006: LD_INT 1
70008: ST_TO_ADDR
// end ; end ;
70009: GO 69414
70011: POP
70012: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70013: LD_ADDR_VAR 0 5
70017: PUSH
70018: LD_EXP 58
70022: PUSH
70023: LD_VAR 0 2
70027: ARRAY
70028: PPUSH
70029: LD_INT 2
70031: PUSH
70032: LD_INT 30
70034: PUSH
70035: LD_INT 4
70037: PUSH
70038: EMPTY
70039: LIST
70040: LIST
70041: PUSH
70042: LD_INT 30
70044: PUSH
70045: LD_INT 5
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 30
70054: PUSH
70055: LD_INT 32
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: PPUSH
70068: CALL_OW 72
70072: ST_TO_ADDR
// if not tmp then
70073: LD_VAR 0 5
70077: NOT
70078: IFFALSE 70082
// continue ;
70080: GO 69331
// list := [ ] ;
70082: LD_ADDR_VAR 0 6
70086: PUSH
70087: EMPTY
70088: ST_TO_ADDR
// for j in tmp do
70089: LD_ADDR_VAR 0 3
70093: PUSH
70094: LD_VAR 0 5
70098: PUSH
70099: FOR_IN
70100: IFFALSE 70169
// begin for k in UnitsInside ( j ) do
70102: LD_ADDR_VAR 0 4
70106: PUSH
70107: LD_VAR 0 3
70111: PPUSH
70112: CALL_OW 313
70116: PUSH
70117: FOR_IN
70118: IFFALSE 70165
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70120: LD_VAR 0 4
70124: PPUSH
70125: CALL_OW 257
70129: PUSH
70130: LD_INT 1
70132: EQUAL
70133: PUSH
70134: LD_VAR 0 4
70138: PPUSH
70139: CALL_OW 459
70143: NOT
70144: AND
70145: IFFALSE 70163
// list := list ^ k ;
70147: LD_ADDR_VAR 0 6
70151: PUSH
70152: LD_VAR 0 6
70156: PUSH
70157: LD_VAR 0 4
70161: ADD
70162: ST_TO_ADDR
70163: GO 70117
70165: POP
70166: POP
// end ;
70167: GO 70099
70169: POP
70170: POP
// list := list diff mc_miners [ i ] ;
70171: LD_ADDR_VAR 0 6
70175: PUSH
70176: LD_VAR 0 6
70180: PUSH
70181: LD_EXP 72
70185: PUSH
70186: LD_VAR 0 2
70190: ARRAY
70191: DIFF
70192: ST_TO_ADDR
// if not list then
70193: LD_VAR 0 6
70197: NOT
70198: IFFALSE 70202
// continue ;
70200: GO 69331
// k := mc_mines [ i ] - mc_miners [ i ] ;
70202: LD_ADDR_VAR 0 4
70206: PUSH
70207: LD_EXP 71
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: PUSH
70218: LD_EXP 72
70222: PUSH
70223: LD_VAR 0 2
70227: ARRAY
70228: MINUS
70229: ST_TO_ADDR
// if k > list then
70230: LD_VAR 0 4
70234: PUSH
70235: LD_VAR 0 6
70239: GREATER
70240: IFFALSE 70252
// k := list ;
70242: LD_ADDR_VAR 0 4
70246: PUSH
70247: LD_VAR 0 6
70251: ST_TO_ADDR
// for j = 1 to k do
70252: LD_ADDR_VAR 0 3
70256: PUSH
70257: DOUBLE
70258: LD_INT 1
70260: DEC
70261: ST_TO_ADDR
70262: LD_VAR 0 4
70266: PUSH
70267: FOR_TO
70268: IFFALSE 70322
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70270: LD_ADDR_EXP 72
70274: PUSH
70275: LD_EXP 72
70279: PPUSH
70280: LD_VAR 0 2
70284: PUSH
70285: LD_EXP 72
70289: PUSH
70290: LD_VAR 0 2
70294: ARRAY
70295: PUSH
70296: LD_INT 1
70298: PLUS
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PPUSH
70304: LD_VAR 0 6
70308: PUSH
70309: LD_VAR 0 3
70313: ARRAY
70314: PPUSH
70315: CALL 21211 0 3
70319: ST_TO_ADDR
70320: GO 70267
70322: POP
70323: POP
// end ;
70324: GO 69331
70326: POP
70327: POP
// end ;
70328: LD_VAR 0 1
70332: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70333: LD_INT 0
70335: PPUSH
70336: PPUSH
70337: PPUSH
70338: PPUSH
70339: PPUSH
70340: PPUSH
70341: PPUSH
70342: PPUSH
70343: PPUSH
70344: PPUSH
// if not mc_bases then
70345: LD_EXP 58
70349: NOT
70350: IFFALSE 70354
// exit ;
70352: GO 72104
// for i = 1 to mc_bases do
70354: LD_ADDR_VAR 0 2
70358: PUSH
70359: DOUBLE
70360: LD_INT 1
70362: DEC
70363: ST_TO_ADDR
70364: LD_EXP 58
70368: PUSH
70369: FOR_TO
70370: IFFALSE 72102
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70372: LD_EXP 58
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: NOT
70383: PUSH
70384: LD_EXP 65
70388: PUSH
70389: LD_VAR 0 2
70393: ARRAY
70394: OR
70395: IFFALSE 70399
// continue ;
70397: GO 70369
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70399: LD_EXP 74
70403: PUSH
70404: LD_VAR 0 2
70408: ARRAY
70409: NOT
70410: PUSH
70411: LD_EXP 75
70415: PUSH
70416: LD_VAR 0 2
70420: ARRAY
70421: AND
70422: IFFALSE 70460
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70424: LD_ADDR_EXP 75
70428: PUSH
70429: LD_EXP 75
70433: PPUSH
70434: LD_VAR 0 2
70438: PPUSH
70439: EMPTY
70440: PPUSH
70441: CALL_OW 1
70445: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70446: LD_VAR 0 2
70450: PPUSH
70451: LD_INT 107
70453: PPUSH
70454: CALL 61214 0 2
// continue ;
70458: GO 70369
// end ; target := [ ] ;
70460: LD_ADDR_VAR 0 6
70464: PUSH
70465: EMPTY
70466: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70467: LD_ADDR_VAR 0 3
70471: PUSH
70472: DOUBLE
70473: LD_EXP 74
70477: PUSH
70478: LD_VAR 0 2
70482: ARRAY
70483: INC
70484: ST_TO_ADDR
70485: LD_INT 1
70487: PUSH
70488: FOR_DOWNTO
70489: IFFALSE 70749
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70491: LD_EXP 74
70495: PUSH
70496: LD_VAR 0 2
70500: ARRAY
70501: PUSH
70502: LD_VAR 0 3
70506: ARRAY
70507: PUSH
70508: LD_INT 2
70510: ARRAY
70511: PPUSH
70512: LD_EXP 74
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: PUSH
70523: LD_VAR 0 3
70527: ARRAY
70528: PUSH
70529: LD_INT 3
70531: ARRAY
70532: PPUSH
70533: CALL_OW 488
70537: PUSH
70538: LD_EXP 74
70542: PUSH
70543: LD_VAR 0 2
70547: ARRAY
70548: PUSH
70549: LD_VAR 0 3
70553: ARRAY
70554: PUSH
70555: LD_INT 2
70557: ARRAY
70558: PPUSH
70559: LD_EXP 74
70563: PUSH
70564: LD_VAR 0 2
70568: ARRAY
70569: PUSH
70570: LD_VAR 0 3
70574: ARRAY
70575: PUSH
70576: LD_INT 3
70578: ARRAY
70579: PPUSH
70580: CALL_OW 284
70584: PUSH
70585: LD_INT 0
70587: EQUAL
70588: AND
70589: IFFALSE 70644
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70591: LD_ADDR_VAR 0 5
70595: PUSH
70596: LD_EXP 74
70600: PUSH
70601: LD_VAR 0 2
70605: ARRAY
70606: PPUSH
70607: LD_VAR 0 3
70611: PPUSH
70612: CALL_OW 3
70616: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70617: LD_ADDR_EXP 74
70621: PUSH
70622: LD_EXP 74
70626: PPUSH
70627: LD_VAR 0 2
70631: PPUSH
70632: LD_VAR 0 5
70636: PPUSH
70637: CALL_OW 1
70641: ST_TO_ADDR
// continue ;
70642: GO 70488
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70644: LD_EXP 58
70648: PUSH
70649: LD_VAR 0 2
70653: ARRAY
70654: PUSH
70655: LD_INT 1
70657: ARRAY
70658: PPUSH
70659: CALL_OW 255
70663: PPUSH
70664: LD_EXP 74
70668: PUSH
70669: LD_VAR 0 2
70673: ARRAY
70674: PUSH
70675: LD_VAR 0 3
70679: ARRAY
70680: PUSH
70681: LD_INT 2
70683: ARRAY
70684: PPUSH
70685: LD_EXP 74
70689: PUSH
70690: LD_VAR 0 2
70694: ARRAY
70695: PUSH
70696: LD_VAR 0 3
70700: ARRAY
70701: PUSH
70702: LD_INT 3
70704: ARRAY
70705: PPUSH
70706: LD_INT 30
70708: PPUSH
70709: CALL 22107 0 4
70713: PUSH
70714: LD_INT 4
70716: ARRAY
70717: PUSH
70718: LD_INT 0
70720: EQUAL
70721: IFFALSE 70747
// begin target := mc_crates [ i ] [ j ] ;
70723: LD_ADDR_VAR 0 6
70727: PUSH
70728: LD_EXP 74
70732: PUSH
70733: LD_VAR 0 2
70737: ARRAY
70738: PUSH
70739: LD_VAR 0 3
70743: ARRAY
70744: ST_TO_ADDR
// break ;
70745: GO 70749
// end ; end ;
70747: GO 70488
70749: POP
70750: POP
// if not target then
70751: LD_VAR 0 6
70755: NOT
70756: IFFALSE 70760
// continue ;
70758: GO 70369
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70760: LD_ADDR_VAR 0 7
70764: PUSH
70765: LD_EXP 77
70769: PUSH
70770: LD_VAR 0 2
70774: ARRAY
70775: PPUSH
70776: LD_INT 2
70778: PUSH
70779: LD_INT 3
70781: PUSH
70782: LD_INT 58
70784: PUSH
70785: EMPTY
70786: LIST
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 61
70794: PUSH
70795: EMPTY
70796: LIST
70797: PUSH
70798: LD_INT 33
70800: PUSH
70801: LD_INT 5
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 33
70810: PUSH
70811: LD_INT 3
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 2
70827: PUSH
70828: LD_INT 34
70830: PUSH
70831: LD_INT 32
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 34
70840: PUSH
70841: LD_INT 51
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 34
70850: PUSH
70851: LD_INT 12
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PPUSH
70868: CALL_OW 72
70872: ST_TO_ADDR
// if not cargo then
70873: LD_VAR 0 7
70877: NOT
70878: IFFALSE 71521
// begin if mc_crates_collector [ i ] < 5 then
70880: LD_EXP 75
70884: PUSH
70885: LD_VAR 0 2
70889: ARRAY
70890: PUSH
70891: LD_INT 5
70893: LESS
70894: IFFALSE 71260
// begin if mc_ape [ i ] then
70896: LD_EXP 87
70900: PUSH
70901: LD_VAR 0 2
70905: ARRAY
70906: IFFALSE 70953
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70908: LD_ADDR_VAR 0 5
70912: PUSH
70913: LD_EXP 87
70917: PUSH
70918: LD_VAR 0 2
70922: ARRAY
70923: PPUSH
70924: LD_INT 25
70926: PUSH
70927: LD_INT 16
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 24
70936: PUSH
70937: LD_INT 750
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PPUSH
70948: CALL_OW 72
70952: ST_TO_ADDR
// if not tmp then
70953: LD_VAR 0 5
70957: NOT
70958: IFFALSE 71005
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70960: LD_ADDR_VAR 0 5
70964: PUSH
70965: LD_EXP 58
70969: PUSH
70970: LD_VAR 0 2
70974: ARRAY
70975: PPUSH
70976: LD_INT 25
70978: PUSH
70979: LD_INT 2
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: LD_INT 24
70988: PUSH
70989: LD_INT 750
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PPUSH
71000: CALL_OW 72
71004: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71005: LD_EXP 87
71009: PUSH
71010: LD_VAR 0 2
71014: ARRAY
71015: PUSH
71016: LD_EXP 58
71020: PUSH
71021: LD_VAR 0 2
71025: ARRAY
71026: PPUSH
71027: LD_INT 25
71029: PUSH
71030: LD_INT 2
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PUSH
71037: LD_INT 24
71039: PUSH
71040: LD_INT 750
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PPUSH
71051: CALL_OW 72
71055: AND
71056: PUSH
71057: LD_VAR 0 5
71061: PUSH
71062: LD_INT 5
71064: LESS
71065: AND
71066: IFFALSE 71148
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71068: LD_ADDR_VAR 0 3
71072: PUSH
71073: LD_EXP 58
71077: PUSH
71078: LD_VAR 0 2
71082: ARRAY
71083: PPUSH
71084: LD_INT 25
71086: PUSH
71087: LD_INT 2
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 24
71096: PUSH
71097: LD_INT 750
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PPUSH
71108: CALL_OW 72
71112: PUSH
71113: FOR_IN
71114: IFFALSE 71146
// begin tmp := tmp union j ;
71116: LD_ADDR_VAR 0 5
71120: PUSH
71121: LD_VAR 0 5
71125: PUSH
71126: LD_VAR 0 3
71130: UNION
71131: ST_TO_ADDR
// if tmp >= 5 then
71132: LD_VAR 0 5
71136: PUSH
71137: LD_INT 5
71139: GREATEREQUAL
71140: IFFALSE 71144
// break ;
71142: GO 71146
// end ;
71144: GO 71113
71146: POP
71147: POP
// end ; if not tmp then
71148: LD_VAR 0 5
71152: NOT
71153: IFFALSE 71157
// continue ;
71155: GO 70369
// for j in tmp do
71157: LD_ADDR_VAR 0 3
71161: PUSH
71162: LD_VAR 0 5
71166: PUSH
71167: FOR_IN
71168: IFFALSE 71258
// if not GetTag ( j ) then
71170: LD_VAR 0 3
71174: PPUSH
71175: CALL_OW 110
71179: NOT
71180: IFFALSE 71256
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71182: LD_ADDR_EXP 75
71186: PUSH
71187: LD_EXP 75
71191: PPUSH
71192: LD_VAR 0 2
71196: PUSH
71197: LD_EXP 75
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PUSH
71208: LD_INT 1
71210: PLUS
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PPUSH
71216: LD_VAR 0 3
71220: PPUSH
71221: CALL 21211 0 3
71225: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71226: LD_VAR 0 3
71230: PPUSH
71231: LD_INT 107
71233: PPUSH
71234: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71238: LD_EXP 75
71242: PUSH
71243: LD_VAR 0 2
71247: ARRAY
71248: PUSH
71249: LD_INT 5
71251: GREATEREQUAL
71252: IFFALSE 71256
// break ;
71254: GO 71258
// end ;
71256: GO 71167
71258: POP
71259: POP
// end ; if mc_crates_collector [ i ] and target then
71260: LD_EXP 75
71264: PUSH
71265: LD_VAR 0 2
71269: ARRAY
71270: PUSH
71271: LD_VAR 0 6
71275: AND
71276: IFFALSE 71519
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71278: LD_EXP 75
71282: PUSH
71283: LD_VAR 0 2
71287: ARRAY
71288: PUSH
71289: LD_VAR 0 6
71293: PUSH
71294: LD_INT 1
71296: ARRAY
71297: LESS
71298: IFFALSE 71318
// tmp := mc_crates_collector [ i ] else
71300: LD_ADDR_VAR 0 5
71304: PUSH
71305: LD_EXP 75
71309: PUSH
71310: LD_VAR 0 2
71314: ARRAY
71315: ST_TO_ADDR
71316: GO 71332
// tmp := target [ 1 ] ;
71318: LD_ADDR_VAR 0 5
71322: PUSH
71323: LD_VAR 0 6
71327: PUSH
71328: LD_INT 1
71330: ARRAY
71331: ST_TO_ADDR
// k := 0 ;
71332: LD_ADDR_VAR 0 4
71336: PUSH
71337: LD_INT 0
71339: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71340: LD_ADDR_VAR 0 3
71344: PUSH
71345: LD_EXP 75
71349: PUSH
71350: LD_VAR 0 2
71354: ARRAY
71355: PUSH
71356: FOR_IN
71357: IFFALSE 71517
// begin k := k + 1 ;
71359: LD_ADDR_VAR 0 4
71363: PUSH
71364: LD_VAR 0 4
71368: PUSH
71369: LD_INT 1
71371: PLUS
71372: ST_TO_ADDR
// if k > tmp then
71373: LD_VAR 0 4
71377: PUSH
71378: LD_VAR 0 5
71382: GREATER
71383: IFFALSE 71387
// break ;
71385: GO 71517
// if not GetClass ( j ) in [ 2 , 16 ] then
71387: LD_VAR 0 3
71391: PPUSH
71392: CALL_OW 257
71396: PUSH
71397: LD_INT 2
71399: PUSH
71400: LD_INT 16
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: IN
71407: NOT
71408: IFFALSE 71461
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71410: LD_ADDR_EXP 75
71414: PUSH
71415: LD_EXP 75
71419: PPUSH
71420: LD_VAR 0 2
71424: PPUSH
71425: LD_EXP 75
71429: PUSH
71430: LD_VAR 0 2
71434: ARRAY
71435: PUSH
71436: LD_VAR 0 3
71440: DIFF
71441: PPUSH
71442: CALL_OW 1
71446: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71447: LD_VAR 0 3
71451: PPUSH
71452: LD_INT 0
71454: PPUSH
71455: CALL_OW 109
// continue ;
71459: GO 71356
// end ; if IsInUnit ( j ) then
71461: LD_VAR 0 3
71465: PPUSH
71466: CALL_OW 310
71470: IFFALSE 71481
// ComExitBuilding ( j ) ;
71472: LD_VAR 0 3
71476: PPUSH
71477: CALL_OW 122
// wait ( 3 ) ;
71481: LD_INT 3
71483: PPUSH
71484: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71488: LD_VAR 0 3
71492: PPUSH
71493: LD_VAR 0 6
71497: PUSH
71498: LD_INT 2
71500: ARRAY
71501: PPUSH
71502: LD_VAR 0 6
71506: PUSH
71507: LD_INT 3
71509: ARRAY
71510: PPUSH
71511: CALL_OW 117
// end ;
71515: GO 71356
71517: POP
71518: POP
// end ; end else
71519: GO 72100
// begin for j in cargo do
71521: LD_ADDR_VAR 0 3
71525: PUSH
71526: LD_VAR 0 7
71530: PUSH
71531: FOR_IN
71532: IFFALSE 72098
// begin if GetTag ( j ) <> 0 then
71534: LD_VAR 0 3
71538: PPUSH
71539: CALL_OW 110
71543: PUSH
71544: LD_INT 0
71546: NONEQUAL
71547: IFFALSE 71551
// continue ;
71549: GO 71531
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71551: LD_VAR 0 3
71555: PPUSH
71556: CALL_OW 256
71560: PUSH
71561: LD_INT 1000
71563: LESS
71564: PUSH
71565: LD_VAR 0 3
71569: PPUSH
71570: LD_EXP 82
71574: PUSH
71575: LD_VAR 0 2
71579: ARRAY
71580: PPUSH
71581: CALL_OW 308
71585: NOT
71586: AND
71587: IFFALSE 71609
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71589: LD_VAR 0 3
71593: PPUSH
71594: LD_EXP 82
71598: PUSH
71599: LD_VAR 0 2
71603: ARRAY
71604: PPUSH
71605: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71609: LD_VAR 0 3
71613: PPUSH
71614: CALL_OW 256
71618: PUSH
71619: LD_INT 1000
71621: LESS
71622: PUSH
71623: LD_VAR 0 3
71627: PPUSH
71628: LD_EXP 82
71632: PUSH
71633: LD_VAR 0 2
71637: ARRAY
71638: PPUSH
71639: CALL_OW 308
71643: AND
71644: IFFALSE 71648
// continue ;
71646: GO 71531
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71648: LD_VAR 0 3
71652: PPUSH
71653: CALL_OW 262
71657: PUSH
71658: LD_INT 2
71660: EQUAL
71661: PUSH
71662: LD_VAR 0 3
71666: PPUSH
71667: CALL_OW 261
71671: PUSH
71672: LD_INT 15
71674: LESS
71675: AND
71676: IFFALSE 71680
// continue ;
71678: GO 71531
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71680: LD_VAR 0 3
71684: PPUSH
71685: CALL_OW 262
71689: PUSH
71690: LD_INT 1
71692: EQUAL
71693: PUSH
71694: LD_VAR 0 3
71698: PPUSH
71699: CALL_OW 261
71703: PUSH
71704: LD_INT 10
71706: LESS
71707: AND
71708: IFFALSE 72037
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71710: LD_ADDR_VAR 0 8
71714: PUSH
71715: LD_EXP 58
71719: PUSH
71720: LD_VAR 0 2
71724: ARRAY
71725: PPUSH
71726: LD_INT 2
71728: PUSH
71729: LD_INT 30
71731: PUSH
71732: LD_INT 0
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 30
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: LIST
71753: PPUSH
71754: CALL_OW 72
71758: ST_TO_ADDR
// if not depot then
71759: LD_VAR 0 8
71763: NOT
71764: IFFALSE 71768
// continue ;
71766: GO 71531
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71768: LD_VAR 0 3
71772: PPUSH
71773: LD_VAR 0 8
71777: PPUSH
71778: LD_VAR 0 3
71782: PPUSH
71783: CALL_OW 74
71787: PPUSH
71788: CALL_OW 296
71792: PUSH
71793: LD_INT 6
71795: LESS
71796: IFFALSE 71812
// SetFuel ( j , 100 ) else
71798: LD_VAR 0 3
71802: PPUSH
71803: LD_INT 100
71805: PPUSH
71806: CALL_OW 240
71810: GO 72037
// if GetFuel ( j ) = 0 then
71812: LD_VAR 0 3
71816: PPUSH
71817: CALL_OW 261
71821: PUSH
71822: LD_INT 0
71824: EQUAL
71825: IFFALSE 72037
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71827: LD_ADDR_EXP 77
71831: PUSH
71832: LD_EXP 77
71836: PPUSH
71837: LD_VAR 0 2
71841: PPUSH
71842: LD_EXP 77
71846: PUSH
71847: LD_VAR 0 2
71851: ARRAY
71852: PUSH
71853: LD_VAR 0 3
71857: DIFF
71858: PPUSH
71859: CALL_OW 1
71863: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71864: LD_VAR 0 3
71868: PPUSH
71869: CALL_OW 263
71873: PUSH
71874: LD_INT 1
71876: EQUAL
71877: IFFALSE 71893
// ComExitVehicle ( IsInUnit ( j ) ) ;
71879: LD_VAR 0 3
71883: PPUSH
71884: CALL_OW 310
71888: PPUSH
71889: CALL_OW 121
// if GetControl ( j ) = control_remote then
71893: LD_VAR 0 3
71897: PPUSH
71898: CALL_OW 263
71902: PUSH
71903: LD_INT 2
71905: EQUAL
71906: IFFALSE 71917
// ComUnlink ( j ) ;
71908: LD_VAR 0 3
71912: PPUSH
71913: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71917: LD_ADDR_VAR 0 9
71921: PUSH
71922: LD_VAR 0 2
71926: PPUSH
71927: LD_INT 3
71929: PPUSH
71930: CALL 81390 0 2
71934: ST_TO_ADDR
// if fac then
71935: LD_VAR 0 9
71939: IFFALSE 72035
// begin for k in fac do
71941: LD_ADDR_VAR 0 4
71945: PUSH
71946: LD_VAR 0 9
71950: PUSH
71951: FOR_IN
71952: IFFALSE 72033
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71954: LD_ADDR_VAR 0 10
71958: PUSH
71959: LD_VAR 0 9
71963: PPUSH
71964: LD_VAR 0 3
71968: PPUSH
71969: CALL_OW 265
71973: PPUSH
71974: LD_VAR 0 3
71978: PPUSH
71979: CALL_OW 262
71983: PPUSH
71984: LD_VAR 0 3
71988: PPUSH
71989: CALL_OW 263
71993: PPUSH
71994: LD_VAR 0 3
71998: PPUSH
71999: CALL_OW 264
72003: PPUSH
72004: CALL 18743 0 5
72008: ST_TO_ADDR
// if components then
72009: LD_VAR 0 10
72013: IFFALSE 72031
// begin MC_InsertProduceList ( i , components ) ;
72015: LD_VAR 0 2
72019: PPUSH
72020: LD_VAR 0 10
72024: PPUSH
72025: CALL 80935 0 2
// break ;
72029: GO 72033
// end ; end ;
72031: GO 71951
72033: POP
72034: POP
// end ; continue ;
72035: GO 71531
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72037: LD_VAR 0 3
72041: PPUSH
72042: LD_INT 1
72044: PPUSH
72045: CALL_OW 289
72049: PUSH
72050: LD_INT 100
72052: LESS
72053: PUSH
72054: LD_VAR 0 3
72058: PPUSH
72059: CALL_OW 314
72063: NOT
72064: AND
72065: IFFALSE 72094
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72067: LD_VAR 0 3
72071: PPUSH
72072: LD_VAR 0 6
72076: PUSH
72077: LD_INT 2
72079: ARRAY
72080: PPUSH
72081: LD_VAR 0 6
72085: PUSH
72086: LD_INT 3
72088: ARRAY
72089: PPUSH
72090: CALL_OW 117
// break ;
72094: GO 72098
// end ;
72096: GO 71531
72098: POP
72099: POP
// end ; end ;
72100: GO 70369
72102: POP
72103: POP
// end ;
72104: LD_VAR 0 1
72108: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72109: LD_INT 0
72111: PPUSH
72112: PPUSH
72113: PPUSH
72114: PPUSH
// if not mc_bases then
72115: LD_EXP 58
72119: NOT
72120: IFFALSE 72124
// exit ;
72122: GO 72285
// for i = 1 to mc_bases do
72124: LD_ADDR_VAR 0 2
72128: PUSH
72129: DOUBLE
72130: LD_INT 1
72132: DEC
72133: ST_TO_ADDR
72134: LD_EXP 58
72138: PUSH
72139: FOR_TO
72140: IFFALSE 72283
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72142: LD_ADDR_VAR 0 4
72146: PUSH
72147: LD_EXP 77
72151: PUSH
72152: LD_VAR 0 2
72156: ARRAY
72157: PUSH
72158: LD_EXP 80
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: UNION
72169: PPUSH
72170: LD_INT 33
72172: PUSH
72173: LD_INT 2
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PPUSH
72180: CALL_OW 72
72184: ST_TO_ADDR
// if tmp then
72185: LD_VAR 0 4
72189: IFFALSE 72281
// for j in tmp do
72191: LD_ADDR_VAR 0 3
72195: PUSH
72196: LD_VAR 0 4
72200: PUSH
72201: FOR_IN
72202: IFFALSE 72279
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72204: LD_VAR 0 3
72208: PPUSH
72209: CALL_OW 312
72213: NOT
72214: PUSH
72215: LD_VAR 0 3
72219: PPUSH
72220: CALL_OW 256
72224: PUSH
72225: LD_INT 250
72227: GREATEREQUAL
72228: AND
72229: IFFALSE 72242
// Connect ( j ) else
72231: LD_VAR 0 3
72235: PPUSH
72236: CALL 24144 0 1
72240: GO 72277
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72242: LD_VAR 0 3
72246: PPUSH
72247: CALL_OW 256
72251: PUSH
72252: LD_INT 250
72254: LESS
72255: PUSH
72256: LD_VAR 0 3
72260: PPUSH
72261: CALL_OW 312
72265: AND
72266: IFFALSE 72277
// ComUnlink ( j ) ;
72268: LD_VAR 0 3
72272: PPUSH
72273: CALL_OW 136
72277: GO 72201
72279: POP
72280: POP
// end ;
72281: GO 72139
72283: POP
72284: POP
// end ;
72285: LD_VAR 0 1
72289: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72290: LD_INT 0
72292: PPUSH
72293: PPUSH
72294: PPUSH
72295: PPUSH
72296: PPUSH
// if not mc_bases then
72297: LD_EXP 58
72301: NOT
72302: IFFALSE 72306
// exit ;
72304: GO 72751
// for i = 1 to mc_bases do
72306: LD_ADDR_VAR 0 2
72310: PUSH
72311: DOUBLE
72312: LD_INT 1
72314: DEC
72315: ST_TO_ADDR
72316: LD_EXP 58
72320: PUSH
72321: FOR_TO
72322: IFFALSE 72749
// begin if not mc_produce [ i ] then
72324: LD_EXP 79
72328: PUSH
72329: LD_VAR 0 2
72333: ARRAY
72334: NOT
72335: IFFALSE 72339
// continue ;
72337: GO 72321
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72339: LD_ADDR_VAR 0 5
72343: PUSH
72344: LD_EXP 58
72348: PUSH
72349: LD_VAR 0 2
72353: ARRAY
72354: PPUSH
72355: LD_INT 30
72357: PUSH
72358: LD_INT 3
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PPUSH
72365: CALL_OW 72
72369: ST_TO_ADDR
// if not fac then
72370: LD_VAR 0 5
72374: NOT
72375: IFFALSE 72379
// continue ;
72377: GO 72321
// for j in fac do
72379: LD_ADDR_VAR 0 3
72383: PUSH
72384: LD_VAR 0 5
72388: PUSH
72389: FOR_IN
72390: IFFALSE 72745
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72392: LD_VAR 0 3
72396: PPUSH
72397: CALL_OW 461
72401: PUSH
72402: LD_INT 2
72404: NONEQUAL
72405: PUSH
72406: LD_VAR 0 3
72410: PPUSH
72411: LD_INT 15
72413: PPUSH
72414: CALL 23804 0 2
72418: PUSH
72419: LD_INT 4
72421: ARRAY
72422: OR
72423: IFFALSE 72427
// continue ;
72425: GO 72389
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72427: LD_VAR 0 3
72431: PPUSH
72432: LD_EXP 79
72436: PUSH
72437: LD_VAR 0 2
72441: ARRAY
72442: PUSH
72443: LD_INT 1
72445: ARRAY
72446: PUSH
72447: LD_INT 1
72449: ARRAY
72450: PPUSH
72451: LD_EXP 79
72455: PUSH
72456: LD_VAR 0 2
72460: ARRAY
72461: PUSH
72462: LD_INT 1
72464: ARRAY
72465: PUSH
72466: LD_INT 2
72468: ARRAY
72469: PPUSH
72470: LD_EXP 79
72474: PUSH
72475: LD_VAR 0 2
72479: ARRAY
72480: PUSH
72481: LD_INT 1
72483: ARRAY
72484: PUSH
72485: LD_INT 3
72487: ARRAY
72488: PPUSH
72489: LD_EXP 79
72493: PUSH
72494: LD_VAR 0 2
72498: ARRAY
72499: PUSH
72500: LD_INT 1
72502: ARRAY
72503: PUSH
72504: LD_INT 4
72506: ARRAY
72507: PPUSH
72508: CALL_OW 448
72512: PUSH
72513: LD_VAR 0 3
72517: PPUSH
72518: LD_EXP 79
72522: PUSH
72523: LD_VAR 0 2
72527: ARRAY
72528: PUSH
72529: LD_INT 1
72531: ARRAY
72532: PUSH
72533: LD_INT 1
72535: ARRAY
72536: PUSH
72537: LD_EXP 79
72541: PUSH
72542: LD_VAR 0 2
72546: ARRAY
72547: PUSH
72548: LD_INT 1
72550: ARRAY
72551: PUSH
72552: LD_INT 2
72554: ARRAY
72555: PUSH
72556: LD_EXP 79
72560: PUSH
72561: LD_VAR 0 2
72565: ARRAY
72566: PUSH
72567: LD_INT 1
72569: ARRAY
72570: PUSH
72571: LD_INT 3
72573: ARRAY
72574: PUSH
72575: LD_EXP 79
72579: PUSH
72580: LD_VAR 0 2
72584: ARRAY
72585: PUSH
72586: LD_INT 1
72588: ARRAY
72589: PUSH
72590: LD_INT 4
72592: ARRAY
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: PPUSH
72600: CALL 27475 0 2
72604: AND
72605: IFFALSE 72743
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72607: LD_VAR 0 3
72611: PPUSH
72612: LD_EXP 79
72616: PUSH
72617: LD_VAR 0 2
72621: ARRAY
72622: PUSH
72623: LD_INT 1
72625: ARRAY
72626: PUSH
72627: LD_INT 1
72629: ARRAY
72630: PPUSH
72631: LD_EXP 79
72635: PUSH
72636: LD_VAR 0 2
72640: ARRAY
72641: PUSH
72642: LD_INT 1
72644: ARRAY
72645: PUSH
72646: LD_INT 2
72648: ARRAY
72649: PPUSH
72650: LD_EXP 79
72654: PUSH
72655: LD_VAR 0 2
72659: ARRAY
72660: PUSH
72661: LD_INT 1
72663: ARRAY
72664: PUSH
72665: LD_INT 3
72667: ARRAY
72668: PPUSH
72669: LD_EXP 79
72673: PUSH
72674: LD_VAR 0 2
72678: ARRAY
72679: PUSH
72680: LD_INT 1
72682: ARRAY
72683: PUSH
72684: LD_INT 4
72686: ARRAY
72687: PPUSH
72688: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72692: LD_ADDR_VAR 0 4
72696: PUSH
72697: LD_EXP 79
72701: PUSH
72702: LD_VAR 0 2
72706: ARRAY
72707: PPUSH
72708: LD_INT 1
72710: PPUSH
72711: CALL_OW 3
72715: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72716: LD_ADDR_EXP 79
72720: PUSH
72721: LD_EXP 79
72725: PPUSH
72726: LD_VAR 0 2
72730: PPUSH
72731: LD_VAR 0 4
72735: PPUSH
72736: CALL_OW 1
72740: ST_TO_ADDR
// break ;
72741: GO 72745
// end ; end ;
72743: GO 72389
72745: POP
72746: POP
// end ;
72747: GO 72321
72749: POP
72750: POP
// end ;
72751: LD_VAR 0 1
72755: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72756: LD_INT 0
72758: PPUSH
72759: PPUSH
72760: PPUSH
// if not mc_bases then
72761: LD_EXP 58
72765: NOT
72766: IFFALSE 72770
// exit ;
72768: GO 72859
// for i = 1 to mc_bases do
72770: LD_ADDR_VAR 0 2
72774: PUSH
72775: DOUBLE
72776: LD_INT 1
72778: DEC
72779: ST_TO_ADDR
72780: LD_EXP 58
72784: PUSH
72785: FOR_TO
72786: IFFALSE 72857
// begin if mc_attack [ i ] then
72788: LD_EXP 78
72792: PUSH
72793: LD_VAR 0 2
72797: ARRAY
72798: IFFALSE 72855
// begin tmp := mc_attack [ i ] [ 1 ] ;
72800: LD_ADDR_VAR 0 3
72804: PUSH
72805: LD_EXP 78
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: PUSH
72816: LD_INT 1
72818: ARRAY
72819: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72820: LD_ADDR_EXP 78
72824: PUSH
72825: LD_EXP 78
72829: PPUSH
72830: LD_VAR 0 2
72834: PPUSH
72835: EMPTY
72836: PPUSH
72837: CALL_OW 1
72841: ST_TO_ADDR
// Attack ( tmp ) ;
72842: LD_VAR 0 3
72846: PPUSH
72847: CALL 49688 0 1
// exit ;
72851: POP
72852: POP
72853: GO 72859
// end ; end ;
72855: GO 72785
72857: POP
72858: POP
// end ;
72859: LD_VAR 0 1
72863: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72864: LD_INT 0
72866: PPUSH
72867: PPUSH
72868: PPUSH
72869: PPUSH
72870: PPUSH
72871: PPUSH
72872: PPUSH
// if not mc_bases then
72873: LD_EXP 58
72877: NOT
72878: IFFALSE 72882
// exit ;
72880: GO 73464
// for i = 1 to mc_bases do
72882: LD_ADDR_VAR 0 2
72886: PUSH
72887: DOUBLE
72888: LD_INT 1
72890: DEC
72891: ST_TO_ADDR
72892: LD_EXP 58
72896: PUSH
72897: FOR_TO
72898: IFFALSE 73462
// begin if not mc_bases [ i ] then
72900: LD_EXP 58
72904: PUSH
72905: LD_VAR 0 2
72909: ARRAY
72910: NOT
72911: IFFALSE 72915
// continue ;
72913: GO 72897
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72915: LD_ADDR_VAR 0 7
72919: PUSH
72920: LD_EXP 58
72924: PUSH
72925: LD_VAR 0 2
72929: ARRAY
72930: PUSH
72931: LD_INT 1
72933: ARRAY
72934: PPUSH
72935: CALL 18047 0 1
72939: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72940: LD_ADDR_EXP 81
72944: PUSH
72945: LD_EXP 81
72949: PPUSH
72950: LD_VAR 0 2
72954: PPUSH
72955: LD_EXP 58
72959: PUSH
72960: LD_VAR 0 2
72964: ARRAY
72965: PUSH
72966: LD_INT 1
72968: ARRAY
72969: PPUSH
72970: CALL_OW 255
72974: PPUSH
72975: LD_EXP 83
72979: PUSH
72980: LD_VAR 0 2
72984: ARRAY
72985: PPUSH
72986: CALL 15690 0 2
72990: PPUSH
72991: CALL_OW 1
72995: ST_TO_ADDR
// if not mc_scan [ i ] then
72996: LD_EXP 81
73000: PUSH
73001: LD_VAR 0 2
73005: ARRAY
73006: NOT
73007: IFFALSE 73162
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73009: LD_ADDR_VAR 0 4
73013: PUSH
73014: LD_EXP 58
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: PPUSH
73025: LD_INT 2
73027: PUSH
73028: LD_INT 25
73030: PUSH
73031: LD_INT 5
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 25
73040: PUSH
73041: LD_INT 8
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 25
73050: PUSH
73051: LD_INT 9
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: PPUSH
73064: CALL_OW 72
73068: ST_TO_ADDR
// if not tmp then
73069: LD_VAR 0 4
73073: NOT
73074: IFFALSE 73078
// continue ;
73076: GO 72897
// for j in tmp do
73078: LD_ADDR_VAR 0 3
73082: PUSH
73083: LD_VAR 0 4
73087: PUSH
73088: FOR_IN
73089: IFFALSE 73160
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73091: LD_VAR 0 3
73095: PPUSH
73096: CALL_OW 310
73100: PPUSH
73101: CALL_OW 266
73105: PUSH
73106: LD_INT 5
73108: EQUAL
73109: PUSH
73110: LD_VAR 0 3
73114: PPUSH
73115: CALL_OW 257
73119: PUSH
73120: LD_INT 1
73122: EQUAL
73123: AND
73124: PUSH
73125: LD_VAR 0 3
73129: PPUSH
73130: CALL_OW 459
73134: NOT
73135: AND
73136: PUSH
73137: LD_VAR 0 7
73141: AND
73142: IFFALSE 73158
// ComChangeProfession ( j , class ) ;
73144: LD_VAR 0 3
73148: PPUSH
73149: LD_VAR 0 7
73153: PPUSH
73154: CALL_OW 123
73158: GO 73088
73160: POP
73161: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73162: LD_EXP 81
73166: PUSH
73167: LD_VAR 0 2
73171: ARRAY
73172: PUSH
73173: LD_EXP 80
73177: PUSH
73178: LD_VAR 0 2
73182: ARRAY
73183: NOT
73184: AND
73185: PUSH
73186: LD_EXP 58
73190: PUSH
73191: LD_VAR 0 2
73195: ARRAY
73196: PPUSH
73197: LD_INT 30
73199: PUSH
73200: LD_INT 32
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PPUSH
73207: CALL_OW 72
73211: NOT
73212: AND
73213: PUSH
73214: LD_EXP 58
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: PPUSH
73225: LD_INT 2
73227: PUSH
73228: LD_INT 30
73230: PUSH
73231: LD_INT 4
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: LD_INT 30
73240: PUSH
73241: LD_INT 5
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: LIST
73252: PPUSH
73253: CALL_OW 72
73257: NOT
73258: AND
73259: IFFALSE 73391
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73261: LD_ADDR_VAR 0 4
73265: PUSH
73266: LD_EXP 58
73270: PUSH
73271: LD_VAR 0 2
73275: ARRAY
73276: PPUSH
73277: LD_INT 2
73279: PUSH
73280: LD_INT 25
73282: PUSH
73283: LD_INT 1
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 25
73292: PUSH
73293: LD_INT 5
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 25
73302: PUSH
73303: LD_INT 8
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 25
73312: PUSH
73313: LD_INT 9
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: LIST
73324: LIST
73325: LIST
73326: PPUSH
73327: CALL_OW 72
73331: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73332: LD_ADDR_VAR 0 4
73336: PUSH
73337: LD_VAR 0 4
73341: PUSH
73342: LD_VAR 0 4
73346: PPUSH
73347: LD_INT 18
73349: PPUSH
73350: CALL 54471 0 2
73354: DIFF
73355: ST_TO_ADDR
// if tmp then
73356: LD_VAR 0 4
73360: IFFALSE 73391
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73362: LD_VAR 0 2
73366: PPUSH
73367: LD_VAR 0 4
73371: PPUSH
73372: LD_EXP 83
73376: PUSH
73377: LD_VAR 0 2
73381: ARRAY
73382: PPUSH
73383: CALL 15725 0 3
// exit ;
73387: POP
73388: POP
73389: GO 73464
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73391: LD_EXP 81
73395: PUSH
73396: LD_VAR 0 2
73400: ARRAY
73401: PUSH
73402: LD_EXP 80
73406: PUSH
73407: LD_VAR 0 2
73411: ARRAY
73412: AND
73413: IFFALSE 73460
// begin tmp := mc_defender [ i ] ;
73415: LD_ADDR_VAR 0 4
73419: PUSH
73420: LD_EXP 80
73424: PUSH
73425: LD_VAR 0 2
73429: ARRAY
73430: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73431: LD_VAR 0 2
73435: PPUSH
73436: LD_VAR 0 4
73440: PPUSH
73441: LD_EXP 81
73445: PUSH
73446: LD_VAR 0 2
73450: ARRAY
73451: PPUSH
73452: CALL 16286 0 3
// exit ;
73456: POP
73457: POP
73458: GO 73464
// end ; end ;
73460: GO 72897
73462: POP
73463: POP
// end ;
73464: LD_VAR 0 1
73468: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73469: LD_INT 0
73471: PPUSH
73472: PPUSH
73473: PPUSH
73474: PPUSH
73475: PPUSH
73476: PPUSH
73477: PPUSH
73478: PPUSH
73479: PPUSH
73480: PPUSH
73481: PPUSH
// if not mc_bases then
73482: LD_EXP 58
73486: NOT
73487: IFFALSE 73491
// exit ;
73489: GO 74578
// for i = 1 to mc_bases do
73491: LD_ADDR_VAR 0 2
73495: PUSH
73496: DOUBLE
73497: LD_INT 1
73499: DEC
73500: ST_TO_ADDR
73501: LD_EXP 58
73505: PUSH
73506: FOR_TO
73507: IFFALSE 74576
// begin tmp := mc_lab [ i ] ;
73509: LD_ADDR_VAR 0 6
73513: PUSH
73514: LD_EXP 91
73518: PUSH
73519: LD_VAR 0 2
73523: ARRAY
73524: ST_TO_ADDR
// if not tmp then
73525: LD_VAR 0 6
73529: NOT
73530: IFFALSE 73534
// continue ;
73532: GO 73506
// idle_lab := 0 ;
73534: LD_ADDR_VAR 0 11
73538: PUSH
73539: LD_INT 0
73541: ST_TO_ADDR
// for j in tmp do
73542: LD_ADDR_VAR 0 3
73546: PUSH
73547: LD_VAR 0 6
73551: PUSH
73552: FOR_IN
73553: IFFALSE 74572
// begin researching := false ;
73555: LD_ADDR_VAR 0 10
73559: PUSH
73560: LD_INT 0
73562: ST_TO_ADDR
// side := GetSide ( j ) ;
73563: LD_ADDR_VAR 0 4
73567: PUSH
73568: LD_VAR 0 3
73572: PPUSH
73573: CALL_OW 255
73577: ST_TO_ADDR
// if not mc_tech [ side ] then
73578: LD_EXP 85
73582: PUSH
73583: LD_VAR 0 4
73587: ARRAY
73588: NOT
73589: IFFALSE 73593
// continue ;
73591: GO 73552
// if BuildingStatus ( j ) = bs_idle then
73593: LD_VAR 0 3
73597: PPUSH
73598: CALL_OW 461
73602: PUSH
73603: LD_INT 2
73605: EQUAL
73606: IFFALSE 73794
// begin if idle_lab and UnitsInside ( j ) < 6 then
73608: LD_VAR 0 11
73612: PUSH
73613: LD_VAR 0 3
73617: PPUSH
73618: CALL_OW 313
73622: PUSH
73623: LD_INT 6
73625: LESS
73626: AND
73627: IFFALSE 73698
// begin tmp2 := UnitsInside ( idle_lab ) ;
73629: LD_ADDR_VAR 0 9
73633: PUSH
73634: LD_VAR 0 11
73638: PPUSH
73639: CALL_OW 313
73643: ST_TO_ADDR
// if tmp2 then
73644: LD_VAR 0 9
73648: IFFALSE 73690
// for x in tmp2 do
73650: LD_ADDR_VAR 0 7
73654: PUSH
73655: LD_VAR 0 9
73659: PUSH
73660: FOR_IN
73661: IFFALSE 73688
// begin ComExitBuilding ( x ) ;
73663: LD_VAR 0 7
73667: PPUSH
73668: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73672: LD_VAR 0 7
73676: PPUSH
73677: LD_VAR 0 3
73681: PPUSH
73682: CALL_OW 180
// end ;
73686: GO 73660
73688: POP
73689: POP
// idle_lab := 0 ;
73690: LD_ADDR_VAR 0 11
73694: PUSH
73695: LD_INT 0
73697: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73698: LD_ADDR_VAR 0 5
73702: PUSH
73703: LD_EXP 85
73707: PUSH
73708: LD_VAR 0 4
73712: ARRAY
73713: PUSH
73714: FOR_IN
73715: IFFALSE 73775
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73717: LD_VAR 0 3
73721: PPUSH
73722: LD_VAR 0 5
73726: PPUSH
73727: CALL_OW 430
73731: PUSH
73732: LD_VAR 0 4
73736: PPUSH
73737: LD_VAR 0 5
73741: PPUSH
73742: CALL 14795 0 2
73746: AND
73747: IFFALSE 73773
// begin researching := true ;
73749: LD_ADDR_VAR 0 10
73753: PUSH
73754: LD_INT 1
73756: ST_TO_ADDR
// ComResearch ( j , t ) ;
73757: LD_VAR 0 3
73761: PPUSH
73762: LD_VAR 0 5
73766: PPUSH
73767: CALL_OW 124
// break ;
73771: GO 73775
// end ;
73773: GO 73714
73775: POP
73776: POP
// if not researching then
73777: LD_VAR 0 10
73781: NOT
73782: IFFALSE 73794
// idle_lab := j ;
73784: LD_ADDR_VAR 0 11
73788: PUSH
73789: LD_VAR 0 3
73793: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73794: LD_VAR 0 3
73798: PPUSH
73799: CALL_OW 461
73803: PUSH
73804: LD_INT 10
73806: EQUAL
73807: IFFALSE 74395
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73809: LD_EXP 87
73813: PUSH
73814: LD_VAR 0 2
73818: ARRAY
73819: NOT
73820: PUSH
73821: LD_EXP 88
73825: PUSH
73826: LD_VAR 0 2
73830: ARRAY
73831: NOT
73832: AND
73833: PUSH
73834: LD_EXP 85
73838: PUSH
73839: LD_VAR 0 4
73843: ARRAY
73844: PUSH
73845: LD_INT 1
73847: GREATER
73848: AND
73849: IFFALSE 73980
// begin ComCancel ( j ) ;
73851: LD_VAR 0 3
73855: PPUSH
73856: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73860: LD_ADDR_EXP 85
73864: PUSH
73865: LD_EXP 85
73869: PPUSH
73870: LD_VAR 0 4
73874: PPUSH
73875: LD_EXP 85
73879: PUSH
73880: LD_VAR 0 4
73884: ARRAY
73885: PPUSH
73886: LD_EXP 85
73890: PUSH
73891: LD_VAR 0 4
73895: ARRAY
73896: PUSH
73897: LD_INT 1
73899: MINUS
73900: PPUSH
73901: LD_EXP 85
73905: PUSH
73906: LD_VAR 0 4
73910: ARRAY
73911: PPUSH
73912: LD_INT 0
73914: PPUSH
73915: CALL 20629 0 4
73919: PPUSH
73920: CALL_OW 1
73924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73925: LD_ADDR_EXP 85
73929: PUSH
73930: LD_EXP 85
73934: PPUSH
73935: LD_VAR 0 4
73939: PPUSH
73940: LD_EXP 85
73944: PUSH
73945: LD_VAR 0 4
73949: ARRAY
73950: PPUSH
73951: LD_EXP 85
73955: PUSH
73956: LD_VAR 0 4
73960: ARRAY
73961: PPUSH
73962: LD_INT 1
73964: PPUSH
73965: LD_INT 0
73967: PPUSH
73968: CALL 20629 0 4
73972: PPUSH
73973: CALL_OW 1
73977: ST_TO_ADDR
// continue ;
73978: GO 73552
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73980: LD_EXP 87
73984: PUSH
73985: LD_VAR 0 2
73989: ARRAY
73990: PUSH
73991: LD_EXP 88
73995: PUSH
73996: LD_VAR 0 2
74000: ARRAY
74001: NOT
74002: AND
74003: IFFALSE 74130
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74005: LD_ADDR_EXP 88
74009: PUSH
74010: LD_EXP 88
74014: PPUSH
74015: LD_VAR 0 2
74019: PUSH
74020: LD_EXP 88
74024: PUSH
74025: LD_VAR 0 2
74029: ARRAY
74030: PUSH
74031: LD_INT 1
74033: PLUS
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PPUSH
74039: LD_EXP 87
74043: PUSH
74044: LD_VAR 0 2
74048: ARRAY
74049: PUSH
74050: LD_INT 1
74052: ARRAY
74053: PPUSH
74054: CALL 21211 0 3
74058: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74059: LD_EXP 87
74063: PUSH
74064: LD_VAR 0 2
74068: ARRAY
74069: PUSH
74070: LD_INT 1
74072: ARRAY
74073: PPUSH
74074: LD_INT 112
74076: PPUSH
74077: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74081: LD_ADDR_VAR 0 9
74085: PUSH
74086: LD_EXP 87
74090: PUSH
74091: LD_VAR 0 2
74095: ARRAY
74096: PPUSH
74097: LD_INT 1
74099: PPUSH
74100: CALL_OW 3
74104: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74105: LD_ADDR_EXP 87
74109: PUSH
74110: LD_EXP 87
74114: PPUSH
74115: LD_VAR 0 2
74119: PPUSH
74120: LD_VAR 0 9
74124: PPUSH
74125: CALL_OW 1
74129: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74130: LD_EXP 87
74134: PUSH
74135: LD_VAR 0 2
74139: ARRAY
74140: PUSH
74141: LD_EXP 88
74145: PUSH
74146: LD_VAR 0 2
74150: ARRAY
74151: AND
74152: PUSH
74153: LD_EXP 88
74157: PUSH
74158: LD_VAR 0 2
74162: ARRAY
74163: PUSH
74164: LD_INT 1
74166: ARRAY
74167: PPUSH
74168: CALL_OW 310
74172: NOT
74173: AND
74174: PUSH
74175: LD_VAR 0 3
74179: PPUSH
74180: CALL_OW 313
74184: PUSH
74185: LD_INT 6
74187: EQUAL
74188: AND
74189: IFFALSE 74245
// begin tmp2 := UnitsInside ( j ) ;
74191: LD_ADDR_VAR 0 9
74195: PUSH
74196: LD_VAR 0 3
74200: PPUSH
74201: CALL_OW 313
74205: ST_TO_ADDR
// if tmp2 = 6 then
74206: LD_VAR 0 9
74210: PUSH
74211: LD_INT 6
74213: EQUAL
74214: IFFALSE 74245
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74216: LD_VAR 0 9
74220: PUSH
74221: LD_INT 1
74223: ARRAY
74224: PPUSH
74225: LD_INT 112
74227: PPUSH
74228: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74232: LD_VAR 0 9
74236: PUSH
74237: LD_INT 1
74239: ARRAY
74240: PPUSH
74241: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74245: LD_EXP 88
74249: PUSH
74250: LD_VAR 0 2
74254: ARRAY
74255: PUSH
74256: LD_EXP 88
74260: PUSH
74261: LD_VAR 0 2
74265: ARRAY
74266: PUSH
74267: LD_INT 1
74269: ARRAY
74270: PPUSH
74271: CALL_OW 314
74275: NOT
74276: AND
74277: PUSH
74278: LD_EXP 88
74282: PUSH
74283: LD_VAR 0 2
74287: ARRAY
74288: PUSH
74289: LD_INT 1
74291: ARRAY
74292: PPUSH
74293: CALL_OW 310
74297: NOT
74298: AND
74299: IFFALSE 74325
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74301: LD_EXP 88
74305: PUSH
74306: LD_VAR 0 2
74310: ARRAY
74311: PUSH
74312: LD_INT 1
74314: ARRAY
74315: PPUSH
74316: LD_VAR 0 3
74320: PPUSH
74321: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74325: LD_EXP 88
74329: PUSH
74330: LD_VAR 0 2
74334: ARRAY
74335: PUSH
74336: LD_INT 1
74338: ARRAY
74339: PPUSH
74340: CALL_OW 310
74344: PUSH
74345: LD_EXP 88
74349: PUSH
74350: LD_VAR 0 2
74354: ARRAY
74355: PUSH
74356: LD_INT 1
74358: ARRAY
74359: PPUSH
74360: CALL_OW 310
74364: PPUSH
74365: CALL_OW 461
74369: PUSH
74370: LD_INT 3
74372: NONEQUAL
74373: AND
74374: IFFALSE 74395
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74376: LD_EXP 88
74380: PUSH
74381: LD_VAR 0 2
74385: ARRAY
74386: PUSH
74387: LD_INT 1
74389: ARRAY
74390: PPUSH
74391: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74395: LD_VAR 0 3
74399: PPUSH
74400: CALL_OW 461
74404: PUSH
74405: LD_INT 6
74407: EQUAL
74408: PUSH
74409: LD_VAR 0 6
74413: PUSH
74414: LD_INT 1
74416: GREATER
74417: AND
74418: IFFALSE 74570
// begin sci := [ ] ;
74420: LD_ADDR_VAR 0 8
74424: PUSH
74425: EMPTY
74426: ST_TO_ADDR
// for x in ( tmp diff j ) do
74427: LD_ADDR_VAR 0 7
74431: PUSH
74432: LD_VAR 0 6
74436: PUSH
74437: LD_VAR 0 3
74441: DIFF
74442: PUSH
74443: FOR_IN
74444: IFFALSE 74496
// begin if sci = 6 then
74446: LD_VAR 0 8
74450: PUSH
74451: LD_INT 6
74453: EQUAL
74454: IFFALSE 74458
// break ;
74456: GO 74496
// if BuildingStatus ( x ) = bs_idle then
74458: LD_VAR 0 7
74462: PPUSH
74463: CALL_OW 461
74467: PUSH
74468: LD_INT 2
74470: EQUAL
74471: IFFALSE 74494
// sci := sci ^ UnitsInside ( x ) ;
74473: LD_ADDR_VAR 0 8
74477: PUSH
74478: LD_VAR 0 8
74482: PUSH
74483: LD_VAR 0 7
74487: PPUSH
74488: CALL_OW 313
74492: ADD
74493: ST_TO_ADDR
// end ;
74494: GO 74443
74496: POP
74497: POP
// if not sci then
74498: LD_VAR 0 8
74502: NOT
74503: IFFALSE 74507
// continue ;
74505: GO 73552
// for x in sci do
74507: LD_ADDR_VAR 0 7
74511: PUSH
74512: LD_VAR 0 8
74516: PUSH
74517: FOR_IN
74518: IFFALSE 74568
// if IsInUnit ( x ) and not HasTask ( x ) then
74520: LD_VAR 0 7
74524: PPUSH
74525: CALL_OW 310
74529: PUSH
74530: LD_VAR 0 7
74534: PPUSH
74535: CALL_OW 314
74539: NOT
74540: AND
74541: IFFALSE 74566
// begin ComExitBuilding ( x ) ;
74543: LD_VAR 0 7
74547: PPUSH
74548: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74552: LD_VAR 0 7
74556: PPUSH
74557: LD_VAR 0 3
74561: PPUSH
74562: CALL_OW 180
// end ;
74566: GO 74517
74568: POP
74569: POP
// end ; end ;
74570: GO 73552
74572: POP
74573: POP
// end ;
74574: GO 73506
74576: POP
74577: POP
// end ;
74578: LD_VAR 0 1
74582: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74583: LD_INT 0
74585: PPUSH
74586: PPUSH
// if not mc_bases then
74587: LD_EXP 58
74591: NOT
74592: IFFALSE 74596
// exit ;
74594: GO 74677
// for i = 1 to mc_bases do
74596: LD_ADDR_VAR 0 2
74600: PUSH
74601: DOUBLE
74602: LD_INT 1
74604: DEC
74605: ST_TO_ADDR
74606: LD_EXP 58
74610: PUSH
74611: FOR_TO
74612: IFFALSE 74675
// if mc_mines [ i ] and mc_miners [ i ] then
74614: LD_EXP 71
74618: PUSH
74619: LD_VAR 0 2
74623: ARRAY
74624: PUSH
74625: LD_EXP 72
74629: PUSH
74630: LD_VAR 0 2
74634: ARRAY
74635: AND
74636: IFFALSE 74673
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74638: LD_EXP 72
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: PUSH
74649: LD_INT 1
74651: ARRAY
74652: PPUSH
74653: CALL_OW 255
74657: PPUSH
74658: LD_EXP 71
74662: PUSH
74663: LD_VAR 0 2
74667: ARRAY
74668: PPUSH
74669: CALL 18200 0 2
74673: GO 74611
74675: POP
74676: POP
// end ;
74677: LD_VAR 0 1
74681: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74682: LD_INT 0
74684: PPUSH
74685: PPUSH
74686: PPUSH
74687: PPUSH
74688: PPUSH
74689: PPUSH
74690: PPUSH
74691: PPUSH
// if not mc_bases or not mc_parking then
74692: LD_EXP 58
74696: NOT
74697: PUSH
74698: LD_EXP 82
74702: NOT
74703: OR
74704: IFFALSE 74708
// exit ;
74706: GO 75407
// for i = 1 to mc_bases do
74708: LD_ADDR_VAR 0 2
74712: PUSH
74713: DOUBLE
74714: LD_INT 1
74716: DEC
74717: ST_TO_ADDR
74718: LD_EXP 58
74722: PUSH
74723: FOR_TO
74724: IFFALSE 75405
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74726: LD_EXP 58
74730: PUSH
74731: LD_VAR 0 2
74735: ARRAY
74736: NOT
74737: PUSH
74738: LD_EXP 82
74742: PUSH
74743: LD_VAR 0 2
74747: ARRAY
74748: NOT
74749: OR
74750: IFFALSE 74754
// continue ;
74752: GO 74723
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74754: LD_ADDR_VAR 0 5
74758: PUSH
74759: LD_EXP 58
74763: PUSH
74764: LD_VAR 0 2
74768: ARRAY
74769: PUSH
74770: LD_INT 1
74772: ARRAY
74773: PPUSH
74774: CALL_OW 255
74778: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74779: LD_ADDR_VAR 0 6
74783: PUSH
74784: LD_EXP 58
74788: PUSH
74789: LD_VAR 0 2
74793: ARRAY
74794: PPUSH
74795: LD_INT 30
74797: PUSH
74798: LD_INT 3
74800: PUSH
74801: EMPTY
74802: LIST
74803: LIST
74804: PPUSH
74805: CALL_OW 72
74809: ST_TO_ADDR
// if not fac then
74810: LD_VAR 0 6
74814: NOT
74815: IFFALSE 74866
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74817: LD_ADDR_VAR 0 6
74821: PUSH
74822: LD_EXP 58
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: PPUSH
74833: LD_INT 2
74835: PUSH
74836: LD_INT 30
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 30
74848: PUSH
74849: LD_INT 1
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: LIST
74860: PPUSH
74861: CALL_OW 72
74865: ST_TO_ADDR
// if not fac then
74866: LD_VAR 0 6
74870: NOT
74871: IFFALSE 74875
// continue ;
74873: GO 74723
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74875: LD_ADDR_VAR 0 7
74879: PUSH
74880: LD_EXP 82
74884: PUSH
74885: LD_VAR 0 2
74889: ARRAY
74890: PPUSH
74891: LD_INT 22
74893: PUSH
74894: LD_VAR 0 5
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 21
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 3
74915: PUSH
74916: LD_INT 24
74918: PUSH
74919: LD_INT 1000
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: LIST
74934: PPUSH
74935: CALL_OW 70
74939: ST_TO_ADDR
// for j in fac do
74940: LD_ADDR_VAR 0 3
74944: PUSH
74945: LD_VAR 0 6
74949: PUSH
74950: FOR_IN
74951: IFFALSE 75032
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74953: LD_ADDR_VAR 0 7
74957: PUSH
74958: LD_VAR 0 7
74962: PUSH
74963: LD_INT 22
74965: PUSH
74966: LD_VAR 0 5
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 91
74977: PUSH
74978: LD_VAR 0 3
74982: PUSH
74983: LD_INT 15
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: LIST
74990: PUSH
74991: LD_INT 21
74993: PUSH
74994: LD_INT 2
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 3
75003: PUSH
75004: LD_INT 24
75006: PUSH
75007: LD_INT 1000
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: PPUSH
75024: CALL_OW 69
75028: UNION
75029: ST_TO_ADDR
75030: GO 74950
75032: POP
75033: POP
// if not vehs then
75034: LD_VAR 0 7
75038: NOT
75039: IFFALSE 75065
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75041: LD_ADDR_EXP 70
75045: PUSH
75046: LD_EXP 70
75050: PPUSH
75051: LD_VAR 0 2
75055: PPUSH
75056: EMPTY
75057: PPUSH
75058: CALL_OW 1
75062: ST_TO_ADDR
// continue ;
75063: GO 74723
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75065: LD_ADDR_VAR 0 8
75069: PUSH
75070: LD_EXP 58
75074: PUSH
75075: LD_VAR 0 2
75079: ARRAY
75080: PPUSH
75081: LD_INT 30
75083: PUSH
75084: LD_INT 3
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PPUSH
75091: CALL_OW 72
75095: ST_TO_ADDR
// if tmp then
75096: LD_VAR 0 8
75100: IFFALSE 75203
// begin for j in tmp do
75102: LD_ADDR_VAR 0 3
75106: PUSH
75107: LD_VAR 0 8
75111: PUSH
75112: FOR_IN
75113: IFFALSE 75201
// for k in UnitsInside ( j ) do
75115: LD_ADDR_VAR 0 4
75119: PUSH
75120: LD_VAR 0 3
75124: PPUSH
75125: CALL_OW 313
75129: PUSH
75130: FOR_IN
75131: IFFALSE 75197
// if k then
75133: LD_VAR 0 4
75137: IFFALSE 75195
// if not k in mc_repair_vehicle [ i ] then
75139: LD_VAR 0 4
75143: PUSH
75144: LD_EXP 70
75148: PUSH
75149: LD_VAR 0 2
75153: ARRAY
75154: IN
75155: NOT
75156: IFFALSE 75195
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75158: LD_ADDR_EXP 70
75162: PUSH
75163: LD_EXP 70
75167: PPUSH
75168: LD_VAR 0 2
75172: PPUSH
75173: LD_EXP 70
75177: PUSH
75178: LD_VAR 0 2
75182: ARRAY
75183: PUSH
75184: LD_VAR 0 4
75188: UNION
75189: PPUSH
75190: CALL_OW 1
75194: ST_TO_ADDR
75195: GO 75130
75197: POP
75198: POP
75199: GO 75112
75201: POP
75202: POP
// end ; if not mc_repair_vehicle [ i ] then
75203: LD_EXP 70
75207: PUSH
75208: LD_VAR 0 2
75212: ARRAY
75213: NOT
75214: IFFALSE 75218
// continue ;
75216: GO 74723
// for j in mc_repair_vehicle [ i ] do
75218: LD_ADDR_VAR 0 3
75222: PUSH
75223: LD_EXP 70
75227: PUSH
75228: LD_VAR 0 2
75232: ARRAY
75233: PUSH
75234: FOR_IN
75235: IFFALSE 75401
// begin if GetClass ( j ) <> 3 then
75237: LD_VAR 0 3
75241: PPUSH
75242: CALL_OW 257
75246: PUSH
75247: LD_INT 3
75249: NONEQUAL
75250: IFFALSE 75291
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75252: LD_ADDR_EXP 70
75256: PUSH
75257: LD_EXP 70
75261: PPUSH
75262: LD_VAR 0 2
75266: PPUSH
75267: LD_EXP 70
75271: PUSH
75272: LD_VAR 0 2
75276: ARRAY
75277: PUSH
75278: LD_VAR 0 3
75282: DIFF
75283: PPUSH
75284: CALL_OW 1
75288: ST_TO_ADDR
// continue ;
75289: GO 75234
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75291: LD_VAR 0 3
75295: PPUSH
75296: CALL_OW 311
75300: NOT
75301: PUSH
75302: LD_VAR 0 3
75306: PUSH
75307: LD_EXP 61
75311: PUSH
75312: LD_VAR 0 2
75316: ARRAY
75317: PUSH
75318: LD_INT 1
75320: ARRAY
75321: IN
75322: NOT
75323: AND
75324: PUSH
75325: LD_VAR 0 3
75329: PUSH
75330: LD_EXP 61
75334: PUSH
75335: LD_VAR 0 2
75339: ARRAY
75340: PUSH
75341: LD_INT 2
75343: ARRAY
75344: IN
75345: NOT
75346: AND
75347: IFFALSE 75399
// begin if IsInUnit ( j ) then
75349: LD_VAR 0 3
75353: PPUSH
75354: CALL_OW 310
75358: IFFALSE 75369
// ComExitBuilding ( j ) ;
75360: LD_VAR 0 3
75364: PPUSH
75365: CALL_OW 122
// if not HasTask ( j ) then
75369: LD_VAR 0 3
75373: PPUSH
75374: CALL_OW 314
75378: NOT
75379: IFFALSE 75399
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75381: LD_VAR 0 3
75385: PPUSH
75386: LD_VAR 0 7
75390: PUSH
75391: LD_INT 1
75393: ARRAY
75394: PPUSH
75395: CALL_OW 189
// end ; end ;
75399: GO 75234
75401: POP
75402: POP
// end ;
75403: GO 74723
75405: POP
75406: POP
// end ;
75407: LD_VAR 0 1
75411: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75412: LD_INT 0
75414: PPUSH
75415: PPUSH
75416: PPUSH
75417: PPUSH
75418: PPUSH
75419: PPUSH
75420: PPUSH
75421: PPUSH
75422: PPUSH
75423: PPUSH
75424: PPUSH
// if not mc_bases then
75425: LD_EXP 58
75429: NOT
75430: IFFALSE 75434
// exit ;
75432: GO 76236
// for i = 1 to mc_bases do
75434: LD_ADDR_VAR 0 2
75438: PUSH
75439: DOUBLE
75440: LD_INT 1
75442: DEC
75443: ST_TO_ADDR
75444: LD_EXP 58
75448: PUSH
75449: FOR_TO
75450: IFFALSE 76234
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75452: LD_EXP 86
75456: PUSH
75457: LD_VAR 0 2
75461: ARRAY
75462: NOT
75463: PUSH
75464: LD_EXP 61
75468: PUSH
75469: LD_VAR 0 2
75473: ARRAY
75474: PUSH
75475: LD_INT 1
75477: ARRAY
75478: OR
75479: PUSH
75480: LD_EXP 61
75484: PUSH
75485: LD_VAR 0 2
75489: ARRAY
75490: PUSH
75491: LD_INT 2
75493: ARRAY
75494: OR
75495: PUSH
75496: LD_EXP 84
75500: PUSH
75501: LD_VAR 0 2
75505: ARRAY
75506: PPUSH
75507: LD_INT 1
75509: PPUSH
75510: CALL_OW 325
75514: NOT
75515: OR
75516: PUSH
75517: LD_EXP 81
75521: PUSH
75522: LD_VAR 0 2
75526: ARRAY
75527: OR
75528: IFFALSE 75532
// continue ;
75530: GO 75449
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75532: LD_ADDR_VAR 0 8
75536: PUSH
75537: LD_EXP 58
75541: PUSH
75542: LD_VAR 0 2
75546: ARRAY
75547: PPUSH
75548: LD_INT 25
75550: PUSH
75551: LD_INT 4
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 50
75560: PUSH
75561: EMPTY
75562: LIST
75563: PUSH
75564: LD_INT 3
75566: PUSH
75567: LD_INT 60
75569: PUSH
75570: EMPTY
75571: LIST
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: LIST
75581: PPUSH
75582: CALL_OW 72
75586: PUSH
75587: LD_EXP 62
75591: PUSH
75592: LD_VAR 0 2
75596: ARRAY
75597: DIFF
75598: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75599: LD_ADDR_VAR 0 9
75603: PUSH
75604: LD_EXP 58
75608: PUSH
75609: LD_VAR 0 2
75613: ARRAY
75614: PPUSH
75615: LD_INT 2
75617: PUSH
75618: LD_INT 30
75620: PUSH
75621: LD_INT 0
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 30
75630: PUSH
75631: LD_INT 1
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: LIST
75642: PPUSH
75643: CALL_OW 72
75647: ST_TO_ADDR
// if not tmp or not dep then
75648: LD_VAR 0 8
75652: NOT
75653: PUSH
75654: LD_VAR 0 9
75658: NOT
75659: OR
75660: IFFALSE 75664
// continue ;
75662: GO 75449
// side := GetSide ( tmp [ 1 ] ) ;
75664: LD_ADDR_VAR 0 11
75668: PUSH
75669: LD_VAR 0 8
75673: PUSH
75674: LD_INT 1
75676: ARRAY
75677: PPUSH
75678: CALL_OW 255
75682: ST_TO_ADDR
// dep := dep [ 1 ] ;
75683: LD_ADDR_VAR 0 9
75687: PUSH
75688: LD_VAR 0 9
75692: PUSH
75693: LD_INT 1
75695: ARRAY
75696: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75697: LD_ADDR_VAR 0 7
75701: PUSH
75702: LD_EXP 86
75706: PUSH
75707: LD_VAR 0 2
75711: ARRAY
75712: PPUSH
75713: LD_INT 22
75715: PUSH
75716: LD_INT 0
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 25
75725: PUSH
75726: LD_INT 12
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PPUSH
75737: CALL_OW 70
75741: PUSH
75742: LD_INT 22
75744: PUSH
75745: LD_INT 0
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 25
75754: PUSH
75755: LD_INT 12
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 91
75764: PUSH
75765: LD_VAR 0 9
75769: PUSH
75770: LD_INT 20
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: LIST
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: LIST
75782: PPUSH
75783: CALL_OW 69
75787: UNION
75788: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75789: LD_ADDR_VAR 0 10
75793: PUSH
75794: LD_EXP 86
75798: PUSH
75799: LD_VAR 0 2
75803: ARRAY
75804: PPUSH
75805: LD_INT 81
75807: PUSH
75808: LD_VAR 0 11
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PPUSH
75817: CALL_OW 70
75821: ST_TO_ADDR
// if not apes or danger_at_area then
75822: LD_VAR 0 7
75826: NOT
75827: PUSH
75828: LD_VAR 0 10
75832: OR
75833: IFFALSE 75883
// begin if mc_taming [ i ] then
75835: LD_EXP 89
75839: PUSH
75840: LD_VAR 0 2
75844: ARRAY
75845: IFFALSE 75881
// begin MC_Reset ( i , 121 ) ;
75847: LD_VAR 0 2
75851: PPUSH
75852: LD_INT 121
75854: PPUSH
75855: CALL 61214 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75859: LD_ADDR_EXP 89
75863: PUSH
75864: LD_EXP 89
75868: PPUSH
75869: LD_VAR 0 2
75873: PPUSH
75874: EMPTY
75875: PPUSH
75876: CALL_OW 1
75880: ST_TO_ADDR
// end ; continue ;
75881: GO 75449
// end ; for j in tmp do
75883: LD_ADDR_VAR 0 3
75887: PUSH
75888: LD_VAR 0 8
75892: PUSH
75893: FOR_IN
75894: IFFALSE 76230
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75896: LD_VAR 0 3
75900: PUSH
75901: LD_EXP 89
75905: PUSH
75906: LD_VAR 0 2
75910: ARRAY
75911: IN
75912: NOT
75913: PUSH
75914: LD_EXP 89
75918: PUSH
75919: LD_VAR 0 2
75923: ARRAY
75924: PUSH
75925: LD_INT 3
75927: LESS
75928: AND
75929: IFFALSE 75987
// begin SetTag ( j , 121 ) ;
75931: LD_VAR 0 3
75935: PPUSH
75936: LD_INT 121
75938: PPUSH
75939: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75943: LD_ADDR_EXP 89
75947: PUSH
75948: LD_EXP 89
75952: PPUSH
75953: LD_VAR 0 2
75957: PUSH
75958: LD_EXP 89
75962: PUSH
75963: LD_VAR 0 2
75967: ARRAY
75968: PUSH
75969: LD_INT 1
75971: PLUS
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PPUSH
75977: LD_VAR 0 3
75981: PPUSH
75982: CALL 21211 0 3
75986: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75987: LD_VAR 0 3
75991: PUSH
75992: LD_EXP 89
75996: PUSH
75997: LD_VAR 0 2
76001: ARRAY
76002: IN
76003: IFFALSE 76228
// begin if GetClass ( j ) <> 4 then
76005: LD_VAR 0 3
76009: PPUSH
76010: CALL_OW 257
76014: PUSH
76015: LD_INT 4
76017: NONEQUAL
76018: IFFALSE 76071
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76020: LD_ADDR_EXP 89
76024: PUSH
76025: LD_EXP 89
76029: PPUSH
76030: LD_VAR 0 2
76034: PPUSH
76035: LD_EXP 89
76039: PUSH
76040: LD_VAR 0 2
76044: ARRAY
76045: PUSH
76046: LD_VAR 0 3
76050: DIFF
76051: PPUSH
76052: CALL_OW 1
76056: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76057: LD_VAR 0 3
76061: PPUSH
76062: LD_INT 0
76064: PPUSH
76065: CALL_OW 109
// continue ;
76069: GO 75893
// end ; if IsInUnit ( j ) then
76071: LD_VAR 0 3
76075: PPUSH
76076: CALL_OW 310
76080: IFFALSE 76091
// ComExitBuilding ( j ) ;
76082: LD_VAR 0 3
76086: PPUSH
76087: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76091: LD_ADDR_VAR 0 6
76095: PUSH
76096: LD_VAR 0 7
76100: PPUSH
76101: LD_VAR 0 3
76105: PPUSH
76106: CALL_OW 74
76110: ST_TO_ADDR
// if not ape then
76111: LD_VAR 0 6
76115: NOT
76116: IFFALSE 76120
// break ;
76118: GO 76230
// x := GetX ( ape ) ;
76120: LD_ADDR_VAR 0 4
76124: PUSH
76125: LD_VAR 0 6
76129: PPUSH
76130: CALL_OW 250
76134: ST_TO_ADDR
// y := GetY ( ape ) ;
76135: LD_ADDR_VAR 0 5
76139: PUSH
76140: LD_VAR 0 6
76144: PPUSH
76145: CALL_OW 251
76149: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76150: LD_VAR 0 4
76154: PPUSH
76155: LD_VAR 0 5
76159: PPUSH
76160: CALL_OW 488
76164: NOT
76165: PUSH
76166: LD_VAR 0 11
76170: PPUSH
76171: LD_VAR 0 4
76175: PPUSH
76176: LD_VAR 0 5
76180: PPUSH
76181: LD_INT 20
76183: PPUSH
76184: CALL 22107 0 4
76188: PUSH
76189: LD_INT 4
76191: ARRAY
76192: OR
76193: IFFALSE 76197
// break ;
76195: GO 76230
// if not HasTask ( j ) then
76197: LD_VAR 0 3
76201: PPUSH
76202: CALL_OW 314
76206: NOT
76207: IFFALSE 76228
// ComTameXY ( j , x , y ) ;
76209: LD_VAR 0 3
76213: PPUSH
76214: LD_VAR 0 4
76218: PPUSH
76219: LD_VAR 0 5
76223: PPUSH
76224: CALL_OW 131
// end ; end ;
76228: GO 75893
76230: POP
76231: POP
// end ;
76232: GO 75449
76234: POP
76235: POP
// end ;
76236: LD_VAR 0 1
76240: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76241: LD_INT 0
76243: PPUSH
76244: PPUSH
76245: PPUSH
76246: PPUSH
76247: PPUSH
76248: PPUSH
76249: PPUSH
76250: PPUSH
// if not mc_bases then
76251: LD_EXP 58
76255: NOT
76256: IFFALSE 76260
// exit ;
76258: GO 76886
// for i = 1 to mc_bases do
76260: LD_ADDR_VAR 0 2
76264: PUSH
76265: DOUBLE
76266: LD_INT 1
76268: DEC
76269: ST_TO_ADDR
76270: LD_EXP 58
76274: PUSH
76275: FOR_TO
76276: IFFALSE 76884
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76278: LD_EXP 87
76282: PUSH
76283: LD_VAR 0 2
76287: ARRAY
76288: NOT
76289: PUSH
76290: LD_EXP 87
76294: PUSH
76295: LD_VAR 0 2
76299: ARRAY
76300: PPUSH
76301: LD_INT 25
76303: PUSH
76304: LD_INT 12
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PPUSH
76311: CALL_OW 72
76315: NOT
76316: OR
76317: IFFALSE 76321
// continue ;
76319: GO 76275
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76321: LD_ADDR_VAR 0 5
76325: PUSH
76326: LD_EXP 87
76330: PUSH
76331: LD_VAR 0 2
76335: ARRAY
76336: PUSH
76337: LD_INT 1
76339: ARRAY
76340: PPUSH
76341: CALL_OW 255
76345: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76346: LD_VAR 0 5
76350: PPUSH
76351: LD_INT 2
76353: PPUSH
76354: CALL_OW 325
76358: IFFALSE 76611
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76360: LD_ADDR_VAR 0 4
76364: PUSH
76365: LD_EXP 87
76369: PUSH
76370: LD_VAR 0 2
76374: ARRAY
76375: PPUSH
76376: LD_INT 25
76378: PUSH
76379: LD_INT 16
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PPUSH
76386: CALL_OW 72
76390: ST_TO_ADDR
// if tmp < 6 then
76391: LD_VAR 0 4
76395: PUSH
76396: LD_INT 6
76398: LESS
76399: IFFALSE 76611
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76401: LD_ADDR_VAR 0 6
76405: PUSH
76406: LD_EXP 58
76410: PUSH
76411: LD_VAR 0 2
76415: ARRAY
76416: PPUSH
76417: LD_INT 2
76419: PUSH
76420: LD_INT 30
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 30
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: LIST
76444: PPUSH
76445: CALL_OW 72
76449: ST_TO_ADDR
// if depot then
76450: LD_VAR 0 6
76454: IFFALSE 76611
// begin selected := 0 ;
76456: LD_ADDR_VAR 0 7
76460: PUSH
76461: LD_INT 0
76463: ST_TO_ADDR
// for j in depot do
76464: LD_ADDR_VAR 0 3
76468: PUSH
76469: LD_VAR 0 6
76473: PUSH
76474: FOR_IN
76475: IFFALSE 76506
// begin if UnitsInside ( j ) < 6 then
76477: LD_VAR 0 3
76481: PPUSH
76482: CALL_OW 313
76486: PUSH
76487: LD_INT 6
76489: LESS
76490: IFFALSE 76504
// begin selected := j ;
76492: LD_ADDR_VAR 0 7
76496: PUSH
76497: LD_VAR 0 3
76501: ST_TO_ADDR
// break ;
76502: GO 76506
// end ; end ;
76504: GO 76474
76506: POP
76507: POP
// if selected then
76508: LD_VAR 0 7
76512: IFFALSE 76611
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76514: LD_ADDR_VAR 0 3
76518: PUSH
76519: LD_EXP 87
76523: PUSH
76524: LD_VAR 0 2
76528: ARRAY
76529: PPUSH
76530: LD_INT 25
76532: PUSH
76533: LD_INT 12
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PPUSH
76540: CALL_OW 72
76544: PUSH
76545: FOR_IN
76546: IFFALSE 76609
// if not HasTask ( j ) then
76548: LD_VAR 0 3
76552: PPUSH
76553: CALL_OW 314
76557: NOT
76558: IFFALSE 76607
// begin if not IsInUnit ( j ) then
76560: LD_VAR 0 3
76564: PPUSH
76565: CALL_OW 310
76569: NOT
76570: IFFALSE 76586
// ComEnterUnit ( j , selected ) ;
76572: LD_VAR 0 3
76576: PPUSH
76577: LD_VAR 0 7
76581: PPUSH
76582: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76586: LD_VAR 0 3
76590: PPUSH
76591: LD_INT 16
76593: PPUSH
76594: CALL_OW 183
// AddComExitBuilding ( j ) ;
76598: LD_VAR 0 3
76602: PPUSH
76603: CALL_OW 182
// end ;
76607: GO 76545
76609: POP
76610: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76611: LD_VAR 0 5
76615: PPUSH
76616: LD_INT 11
76618: PPUSH
76619: CALL_OW 325
76623: IFFALSE 76882
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76625: LD_ADDR_VAR 0 4
76629: PUSH
76630: LD_EXP 87
76634: PUSH
76635: LD_VAR 0 2
76639: ARRAY
76640: PPUSH
76641: LD_INT 25
76643: PUSH
76644: LD_INT 16
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PPUSH
76651: CALL_OW 72
76655: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76656: LD_VAR 0 4
76660: PUSH
76661: LD_INT 6
76663: GREATEREQUAL
76664: PUSH
76665: LD_VAR 0 5
76669: PPUSH
76670: LD_INT 2
76672: PPUSH
76673: CALL_OW 325
76677: NOT
76678: OR
76679: IFFALSE 76882
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76681: LD_ADDR_VAR 0 8
76685: PUSH
76686: LD_EXP 58
76690: PUSH
76691: LD_VAR 0 2
76695: ARRAY
76696: PPUSH
76697: LD_INT 2
76699: PUSH
76700: LD_INT 30
76702: PUSH
76703: LD_INT 4
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 30
76712: PUSH
76713: LD_INT 5
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: LIST
76724: PPUSH
76725: CALL_OW 72
76729: ST_TO_ADDR
// if barracks then
76730: LD_VAR 0 8
76734: IFFALSE 76882
// begin selected := 0 ;
76736: LD_ADDR_VAR 0 7
76740: PUSH
76741: LD_INT 0
76743: ST_TO_ADDR
// for j in barracks do
76744: LD_ADDR_VAR 0 3
76748: PUSH
76749: LD_VAR 0 8
76753: PUSH
76754: FOR_IN
76755: IFFALSE 76786
// begin if UnitsInside ( j ) < 6 then
76757: LD_VAR 0 3
76761: PPUSH
76762: CALL_OW 313
76766: PUSH
76767: LD_INT 6
76769: LESS
76770: IFFALSE 76784
// begin selected := j ;
76772: LD_ADDR_VAR 0 7
76776: PUSH
76777: LD_VAR 0 3
76781: ST_TO_ADDR
// break ;
76782: GO 76786
// end ; end ;
76784: GO 76754
76786: POP
76787: POP
// if selected then
76788: LD_VAR 0 7
76792: IFFALSE 76882
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76794: LD_ADDR_VAR 0 3
76798: PUSH
76799: LD_EXP 87
76803: PUSH
76804: LD_VAR 0 2
76808: ARRAY
76809: PPUSH
76810: LD_INT 25
76812: PUSH
76813: LD_INT 12
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PPUSH
76820: CALL_OW 72
76824: PUSH
76825: FOR_IN
76826: IFFALSE 76880
// if not IsInUnit ( j ) and not HasTask ( j ) then
76828: LD_VAR 0 3
76832: PPUSH
76833: CALL_OW 310
76837: NOT
76838: PUSH
76839: LD_VAR 0 3
76843: PPUSH
76844: CALL_OW 314
76848: NOT
76849: AND
76850: IFFALSE 76878
// begin ComEnterUnit ( j , selected ) ;
76852: LD_VAR 0 3
76856: PPUSH
76857: LD_VAR 0 7
76861: PPUSH
76862: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76866: LD_VAR 0 3
76870: PPUSH
76871: LD_INT 15
76873: PPUSH
76874: CALL_OW 183
// end ;
76878: GO 76825
76880: POP
76881: POP
// end ; end ; end ; end ; end ;
76882: GO 76275
76884: POP
76885: POP
// end ;
76886: LD_VAR 0 1
76890: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76891: LD_INT 0
76893: PPUSH
76894: PPUSH
76895: PPUSH
76896: PPUSH
// if not mc_bases then
76897: LD_EXP 58
76901: NOT
76902: IFFALSE 76906
// exit ;
76904: GO 77084
// for i = 1 to mc_bases do
76906: LD_ADDR_VAR 0 2
76910: PUSH
76911: DOUBLE
76912: LD_INT 1
76914: DEC
76915: ST_TO_ADDR
76916: LD_EXP 58
76920: PUSH
76921: FOR_TO
76922: IFFALSE 77082
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76924: LD_ADDR_VAR 0 4
76928: PUSH
76929: LD_EXP 58
76933: PUSH
76934: LD_VAR 0 2
76938: ARRAY
76939: PPUSH
76940: LD_INT 25
76942: PUSH
76943: LD_INT 9
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PPUSH
76950: CALL_OW 72
76954: ST_TO_ADDR
// if not tmp then
76955: LD_VAR 0 4
76959: NOT
76960: IFFALSE 76964
// continue ;
76962: GO 76921
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76964: LD_EXP 84
76968: PUSH
76969: LD_VAR 0 2
76973: ARRAY
76974: PPUSH
76975: LD_INT 29
76977: PPUSH
76978: CALL_OW 325
76982: NOT
76983: PUSH
76984: LD_EXP 84
76988: PUSH
76989: LD_VAR 0 2
76993: ARRAY
76994: PPUSH
76995: LD_INT 28
76997: PPUSH
76998: CALL_OW 325
77002: NOT
77003: AND
77004: IFFALSE 77008
// continue ;
77006: GO 76921
// for j in tmp do
77008: LD_ADDR_VAR 0 3
77012: PUSH
77013: LD_VAR 0 4
77017: PUSH
77018: FOR_IN
77019: IFFALSE 77078
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77021: LD_VAR 0 3
77025: PUSH
77026: LD_EXP 61
77030: PUSH
77031: LD_VAR 0 2
77035: ARRAY
77036: PUSH
77037: LD_INT 1
77039: ARRAY
77040: IN
77041: NOT
77042: PUSH
77043: LD_VAR 0 3
77047: PUSH
77048: LD_EXP 61
77052: PUSH
77053: LD_VAR 0 2
77057: ARRAY
77058: PUSH
77059: LD_INT 2
77061: ARRAY
77062: IN
77063: NOT
77064: AND
77065: IFFALSE 77076
// ComSpaceTimeShoot ( j ) ;
77067: LD_VAR 0 3
77071: PPUSH
77072: CALL 14886 0 1
77076: GO 77018
77078: POP
77079: POP
// end ;
77080: GO 76921
77082: POP
77083: POP
// end ;
77084: LD_VAR 0 1
77088: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77089: LD_INT 0
77091: PPUSH
77092: PPUSH
77093: PPUSH
77094: PPUSH
77095: PPUSH
77096: PPUSH
77097: PPUSH
77098: PPUSH
77099: PPUSH
// if not mc_bases then
77100: LD_EXP 58
77104: NOT
77105: IFFALSE 77109
// exit ;
77107: GO 77731
// for i = 1 to mc_bases do
77109: LD_ADDR_VAR 0 2
77113: PUSH
77114: DOUBLE
77115: LD_INT 1
77117: DEC
77118: ST_TO_ADDR
77119: LD_EXP 58
77123: PUSH
77124: FOR_TO
77125: IFFALSE 77729
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77127: LD_EXP 93
77131: PUSH
77132: LD_VAR 0 2
77136: ARRAY
77137: NOT
77138: PUSH
77139: LD_INT 38
77141: PPUSH
77142: LD_EXP 84
77146: PUSH
77147: LD_VAR 0 2
77151: ARRAY
77152: PPUSH
77153: CALL_OW 321
77157: PUSH
77158: LD_INT 2
77160: NONEQUAL
77161: OR
77162: IFFALSE 77166
// continue ;
77164: GO 77124
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77166: LD_ADDR_VAR 0 8
77170: PUSH
77171: LD_EXP 58
77175: PUSH
77176: LD_VAR 0 2
77180: ARRAY
77181: PPUSH
77182: LD_INT 30
77184: PUSH
77185: LD_INT 34
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PPUSH
77192: CALL_OW 72
77196: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77197: LD_ADDR_VAR 0 9
77201: PUSH
77202: LD_EXP 58
77206: PUSH
77207: LD_VAR 0 2
77211: ARRAY
77212: PPUSH
77213: LD_INT 25
77215: PUSH
77216: LD_INT 4
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PPUSH
77223: CALL_OW 72
77227: PPUSH
77228: LD_INT 0
77230: PPUSH
77231: CALL 54471 0 2
77235: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77236: LD_VAR 0 9
77240: NOT
77241: PUSH
77242: LD_VAR 0 8
77246: NOT
77247: OR
77248: PUSH
77249: LD_EXP 58
77253: PUSH
77254: LD_VAR 0 2
77258: ARRAY
77259: PPUSH
77260: LD_INT 124
77262: PPUSH
77263: CALL 54471 0 2
77267: OR
77268: IFFALSE 77272
// continue ;
77270: GO 77124
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77272: LD_EXP 94
77276: PUSH
77277: LD_VAR 0 2
77281: ARRAY
77282: PUSH
77283: LD_EXP 93
77287: PUSH
77288: LD_VAR 0 2
77292: ARRAY
77293: LESS
77294: PUSH
77295: LD_EXP 94
77299: PUSH
77300: LD_VAR 0 2
77304: ARRAY
77305: PUSH
77306: LD_VAR 0 8
77310: LESS
77311: AND
77312: IFFALSE 77727
// begin tmp := sci [ 1 ] ;
77314: LD_ADDR_VAR 0 7
77318: PUSH
77319: LD_VAR 0 9
77323: PUSH
77324: LD_INT 1
77326: ARRAY
77327: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77328: LD_VAR 0 7
77332: PPUSH
77333: LD_INT 124
77335: PPUSH
77336: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77340: LD_ADDR_VAR 0 3
77344: PUSH
77345: DOUBLE
77346: LD_EXP 93
77350: PUSH
77351: LD_VAR 0 2
77355: ARRAY
77356: INC
77357: ST_TO_ADDR
77358: LD_EXP 93
77362: PUSH
77363: LD_VAR 0 2
77367: ARRAY
77368: PUSH
77369: FOR_DOWNTO
77370: IFFALSE 77713
// begin if IsInUnit ( tmp ) then
77372: LD_VAR 0 7
77376: PPUSH
77377: CALL_OW 310
77381: IFFALSE 77392
// ComExitBuilding ( tmp ) ;
77383: LD_VAR 0 7
77387: PPUSH
77388: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77392: LD_INT 35
77394: PPUSH
77395: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77399: LD_VAR 0 7
77403: PPUSH
77404: CALL_OW 310
77408: NOT
77409: PUSH
77410: LD_VAR 0 7
77414: PPUSH
77415: CALL_OW 314
77419: NOT
77420: AND
77421: IFFALSE 77392
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77423: LD_ADDR_VAR 0 6
77427: PUSH
77428: LD_VAR 0 7
77432: PPUSH
77433: CALL_OW 250
77437: PUSH
77438: LD_VAR 0 7
77442: PPUSH
77443: CALL_OW 251
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77452: LD_INT 35
77454: PPUSH
77455: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77459: LD_ADDR_VAR 0 4
77463: PUSH
77464: LD_EXP 93
77468: PUSH
77469: LD_VAR 0 2
77473: ARRAY
77474: PUSH
77475: LD_VAR 0 3
77479: ARRAY
77480: PUSH
77481: LD_INT 1
77483: ARRAY
77484: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77485: LD_ADDR_VAR 0 5
77489: PUSH
77490: LD_EXP 93
77494: PUSH
77495: LD_VAR 0 2
77499: ARRAY
77500: PUSH
77501: LD_VAR 0 3
77505: ARRAY
77506: PUSH
77507: LD_INT 2
77509: ARRAY
77510: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77511: LD_VAR 0 7
77515: PPUSH
77516: LD_INT 10
77518: PPUSH
77519: CALL 23804 0 2
77523: PUSH
77524: LD_INT 4
77526: ARRAY
77527: IFFALSE 77565
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77529: LD_VAR 0 7
77533: PPUSH
77534: LD_VAR 0 6
77538: PUSH
77539: LD_INT 1
77541: ARRAY
77542: PPUSH
77543: LD_VAR 0 6
77547: PUSH
77548: LD_INT 2
77550: ARRAY
77551: PPUSH
77552: CALL_OW 111
// wait ( 0 0$10 ) ;
77556: LD_INT 350
77558: PPUSH
77559: CALL_OW 67
// end else
77563: GO 77591
// begin ComMoveXY ( tmp , x , y ) ;
77565: LD_VAR 0 7
77569: PPUSH
77570: LD_VAR 0 4
77574: PPUSH
77575: LD_VAR 0 5
77579: PPUSH
77580: CALL_OW 111
// wait ( 0 0$3 ) ;
77584: LD_INT 105
77586: PPUSH
77587: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77591: LD_VAR 0 7
77595: PPUSH
77596: LD_VAR 0 4
77600: PPUSH
77601: LD_VAR 0 5
77605: PPUSH
77606: CALL_OW 307
77610: IFFALSE 77452
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77612: LD_VAR 0 7
77616: PPUSH
77617: LD_VAR 0 4
77621: PPUSH
77622: LD_VAR 0 5
77626: PPUSH
77627: LD_VAR 0 8
77631: PUSH
77632: LD_VAR 0 3
77636: ARRAY
77637: PPUSH
77638: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77642: LD_INT 35
77644: PPUSH
77645: CALL_OW 67
// until not HasTask ( tmp ) ;
77649: LD_VAR 0 7
77653: PPUSH
77654: CALL_OW 314
77658: NOT
77659: IFFALSE 77642
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77661: LD_ADDR_EXP 94
77665: PUSH
77666: LD_EXP 94
77670: PPUSH
77671: LD_VAR 0 2
77675: PUSH
77676: LD_EXP 94
77680: PUSH
77681: LD_VAR 0 2
77685: ARRAY
77686: PUSH
77687: LD_INT 1
77689: PLUS
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PPUSH
77695: LD_VAR 0 8
77699: PUSH
77700: LD_VAR 0 3
77704: ARRAY
77705: PPUSH
77706: CALL 21211 0 3
77710: ST_TO_ADDR
// end ;
77711: GO 77369
77713: POP
77714: POP
// MC_Reset ( i , 124 ) ;
77715: LD_VAR 0 2
77719: PPUSH
77720: LD_INT 124
77722: PPUSH
77723: CALL 61214 0 2
// end ; end ;
77727: GO 77124
77729: POP
77730: POP
// end ;
77731: LD_VAR 0 1
77735: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77736: LD_INT 0
77738: PPUSH
77739: PPUSH
77740: PPUSH
// if not mc_bases then
77741: LD_EXP 58
77745: NOT
77746: IFFALSE 77750
// exit ;
77748: GO 78356
// for i = 1 to mc_bases do
77750: LD_ADDR_VAR 0 2
77754: PUSH
77755: DOUBLE
77756: LD_INT 1
77758: DEC
77759: ST_TO_ADDR
77760: LD_EXP 58
77764: PUSH
77765: FOR_TO
77766: IFFALSE 78354
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77768: LD_ADDR_VAR 0 3
77772: PUSH
77773: LD_EXP 58
77777: PUSH
77778: LD_VAR 0 2
77782: ARRAY
77783: PPUSH
77784: LD_INT 25
77786: PUSH
77787: LD_INT 4
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PPUSH
77794: CALL_OW 72
77798: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77799: LD_VAR 0 3
77803: NOT
77804: PUSH
77805: LD_EXP 95
77809: PUSH
77810: LD_VAR 0 2
77814: ARRAY
77815: NOT
77816: OR
77817: PUSH
77818: LD_EXP 58
77822: PUSH
77823: LD_VAR 0 2
77827: ARRAY
77828: PPUSH
77829: LD_INT 2
77831: PUSH
77832: LD_INT 30
77834: PUSH
77835: LD_INT 0
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 30
77844: PUSH
77845: LD_INT 1
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: LIST
77856: PPUSH
77857: CALL_OW 72
77861: NOT
77862: OR
77863: IFFALSE 77913
// begin if mc_deposits_finder [ i ] then
77865: LD_EXP 96
77869: PUSH
77870: LD_VAR 0 2
77874: ARRAY
77875: IFFALSE 77911
// begin MC_Reset ( i , 125 ) ;
77877: LD_VAR 0 2
77881: PPUSH
77882: LD_INT 125
77884: PPUSH
77885: CALL 61214 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77889: LD_ADDR_EXP 96
77893: PUSH
77894: LD_EXP 96
77898: PPUSH
77899: LD_VAR 0 2
77903: PPUSH
77904: EMPTY
77905: PPUSH
77906: CALL_OW 1
77910: ST_TO_ADDR
// end ; continue ;
77911: GO 77765
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77913: LD_EXP 95
77917: PUSH
77918: LD_VAR 0 2
77922: ARRAY
77923: PUSH
77924: LD_INT 1
77926: ARRAY
77927: PUSH
77928: LD_INT 3
77930: ARRAY
77931: PUSH
77932: LD_INT 1
77934: EQUAL
77935: PUSH
77936: LD_INT 20
77938: PPUSH
77939: LD_EXP 84
77943: PUSH
77944: LD_VAR 0 2
77948: ARRAY
77949: PPUSH
77950: CALL_OW 321
77954: PUSH
77955: LD_INT 2
77957: NONEQUAL
77958: AND
77959: IFFALSE 78009
// begin if mc_deposits_finder [ i ] then
77961: LD_EXP 96
77965: PUSH
77966: LD_VAR 0 2
77970: ARRAY
77971: IFFALSE 78007
// begin MC_Reset ( i , 125 ) ;
77973: LD_VAR 0 2
77977: PPUSH
77978: LD_INT 125
77980: PPUSH
77981: CALL 61214 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77985: LD_ADDR_EXP 96
77989: PUSH
77990: LD_EXP 96
77994: PPUSH
77995: LD_VAR 0 2
77999: PPUSH
78000: EMPTY
78001: PPUSH
78002: CALL_OW 1
78006: ST_TO_ADDR
// end ; continue ;
78007: GO 77765
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78009: LD_EXP 95
78013: PUSH
78014: LD_VAR 0 2
78018: ARRAY
78019: PUSH
78020: LD_INT 1
78022: ARRAY
78023: PUSH
78024: LD_INT 1
78026: ARRAY
78027: PPUSH
78028: LD_EXP 95
78032: PUSH
78033: LD_VAR 0 2
78037: ARRAY
78038: PUSH
78039: LD_INT 1
78041: ARRAY
78042: PUSH
78043: LD_INT 2
78045: ARRAY
78046: PPUSH
78047: LD_EXP 84
78051: PUSH
78052: LD_VAR 0 2
78056: ARRAY
78057: PPUSH
78058: CALL_OW 440
78062: IFFALSE 78105
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78064: LD_ADDR_EXP 95
78068: PUSH
78069: LD_EXP 95
78073: PPUSH
78074: LD_VAR 0 2
78078: PPUSH
78079: LD_EXP 95
78083: PUSH
78084: LD_VAR 0 2
78088: ARRAY
78089: PPUSH
78090: LD_INT 1
78092: PPUSH
78093: CALL_OW 3
78097: PPUSH
78098: CALL_OW 1
78102: ST_TO_ADDR
78103: GO 78352
// begin if not mc_deposits_finder [ i ] then
78105: LD_EXP 96
78109: PUSH
78110: LD_VAR 0 2
78114: ARRAY
78115: NOT
78116: IFFALSE 78168
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78118: LD_ADDR_EXP 96
78122: PUSH
78123: LD_EXP 96
78127: PPUSH
78128: LD_VAR 0 2
78132: PPUSH
78133: LD_VAR 0 3
78137: PUSH
78138: LD_INT 1
78140: ARRAY
78141: PUSH
78142: EMPTY
78143: LIST
78144: PPUSH
78145: CALL_OW 1
78149: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78150: LD_VAR 0 3
78154: PUSH
78155: LD_INT 1
78157: ARRAY
78158: PPUSH
78159: LD_INT 125
78161: PPUSH
78162: CALL_OW 109
// end else
78166: GO 78352
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78168: LD_EXP 96
78172: PUSH
78173: LD_VAR 0 2
78177: ARRAY
78178: PUSH
78179: LD_INT 1
78181: ARRAY
78182: PPUSH
78183: CALL_OW 310
78187: IFFALSE 78210
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78189: LD_EXP 96
78193: PUSH
78194: LD_VAR 0 2
78198: ARRAY
78199: PUSH
78200: LD_INT 1
78202: ARRAY
78203: PPUSH
78204: CALL_OW 122
78208: GO 78352
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78210: LD_EXP 96
78214: PUSH
78215: LD_VAR 0 2
78219: ARRAY
78220: PUSH
78221: LD_INT 1
78223: ARRAY
78224: PPUSH
78225: CALL_OW 314
78229: NOT
78230: PUSH
78231: LD_EXP 96
78235: PUSH
78236: LD_VAR 0 2
78240: ARRAY
78241: PUSH
78242: LD_INT 1
78244: ARRAY
78245: PPUSH
78246: LD_EXP 95
78250: PUSH
78251: LD_VAR 0 2
78255: ARRAY
78256: PUSH
78257: LD_INT 1
78259: ARRAY
78260: PUSH
78261: LD_INT 1
78263: ARRAY
78264: PPUSH
78265: LD_EXP 95
78269: PUSH
78270: LD_VAR 0 2
78274: ARRAY
78275: PUSH
78276: LD_INT 1
78278: ARRAY
78279: PUSH
78280: LD_INT 2
78282: ARRAY
78283: PPUSH
78284: CALL_OW 297
78288: PUSH
78289: LD_INT 6
78291: GREATER
78292: AND
78293: IFFALSE 78352
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78295: LD_EXP 96
78299: PUSH
78300: LD_VAR 0 2
78304: ARRAY
78305: PUSH
78306: LD_INT 1
78308: ARRAY
78309: PPUSH
78310: LD_EXP 95
78314: PUSH
78315: LD_VAR 0 2
78319: ARRAY
78320: PUSH
78321: LD_INT 1
78323: ARRAY
78324: PUSH
78325: LD_INT 1
78327: ARRAY
78328: PPUSH
78329: LD_EXP 95
78333: PUSH
78334: LD_VAR 0 2
78338: ARRAY
78339: PUSH
78340: LD_INT 1
78342: ARRAY
78343: PUSH
78344: LD_INT 2
78346: ARRAY
78347: PPUSH
78348: CALL_OW 111
// end ; end ; end ;
78352: GO 77765
78354: POP
78355: POP
// end ;
78356: LD_VAR 0 1
78360: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78361: LD_INT 0
78363: PPUSH
78364: PPUSH
78365: PPUSH
78366: PPUSH
78367: PPUSH
78368: PPUSH
78369: PPUSH
78370: PPUSH
78371: PPUSH
78372: PPUSH
78373: PPUSH
// if not mc_bases then
78374: LD_EXP 58
78378: NOT
78379: IFFALSE 78383
// exit ;
78381: GO 79323
// for i = 1 to mc_bases do
78383: LD_ADDR_VAR 0 2
78387: PUSH
78388: DOUBLE
78389: LD_INT 1
78391: DEC
78392: ST_TO_ADDR
78393: LD_EXP 58
78397: PUSH
78398: FOR_TO
78399: IFFALSE 79321
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78401: LD_EXP 58
78405: PUSH
78406: LD_VAR 0 2
78410: ARRAY
78411: NOT
78412: PUSH
78413: LD_EXP 81
78417: PUSH
78418: LD_VAR 0 2
78422: ARRAY
78423: OR
78424: IFFALSE 78428
// continue ;
78426: GO 78398
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78428: LD_ADDR_VAR 0 7
78432: PUSH
78433: LD_EXP 58
78437: PUSH
78438: LD_VAR 0 2
78442: ARRAY
78443: PUSH
78444: LD_INT 1
78446: ARRAY
78447: PPUSH
78448: CALL_OW 248
78452: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78453: LD_VAR 0 7
78457: PUSH
78458: LD_INT 3
78460: EQUAL
78461: PUSH
78462: LD_EXP 77
78466: PUSH
78467: LD_VAR 0 2
78471: ARRAY
78472: PUSH
78473: LD_EXP 80
78477: PUSH
78478: LD_VAR 0 2
78482: ARRAY
78483: UNION
78484: PPUSH
78485: LD_INT 33
78487: PUSH
78488: LD_INT 2
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PPUSH
78495: CALL_OW 72
78499: NOT
78500: OR
78501: IFFALSE 78505
// continue ;
78503: GO 78398
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78505: LD_ADDR_VAR 0 9
78509: PUSH
78510: LD_EXP 58
78514: PUSH
78515: LD_VAR 0 2
78519: ARRAY
78520: PPUSH
78521: LD_INT 30
78523: PUSH
78524: LD_INT 36
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PPUSH
78531: CALL_OW 72
78535: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78536: LD_ADDR_VAR 0 10
78540: PUSH
78541: LD_EXP 77
78545: PUSH
78546: LD_VAR 0 2
78550: ARRAY
78551: PPUSH
78552: LD_INT 34
78554: PUSH
78555: LD_INT 31
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PPUSH
78562: CALL_OW 72
78566: ST_TO_ADDR
// if not cts and not mcts then
78567: LD_VAR 0 9
78571: NOT
78572: PUSH
78573: LD_VAR 0 10
78577: NOT
78578: AND
78579: IFFALSE 78583
// continue ;
78581: GO 78398
// x := cts ;
78583: LD_ADDR_VAR 0 11
78587: PUSH
78588: LD_VAR 0 9
78592: ST_TO_ADDR
// if not x then
78593: LD_VAR 0 11
78597: NOT
78598: IFFALSE 78610
// x := mcts ;
78600: LD_ADDR_VAR 0 11
78604: PUSH
78605: LD_VAR 0 10
78609: ST_TO_ADDR
// if not x then
78610: LD_VAR 0 11
78614: NOT
78615: IFFALSE 78619
// continue ;
78617: GO 78398
// if mc_remote_driver [ i ] then
78619: LD_EXP 98
78623: PUSH
78624: LD_VAR 0 2
78628: ARRAY
78629: IFFALSE 79016
// for j in mc_remote_driver [ i ] do
78631: LD_ADDR_VAR 0 3
78635: PUSH
78636: LD_EXP 98
78640: PUSH
78641: LD_VAR 0 2
78645: ARRAY
78646: PUSH
78647: FOR_IN
78648: IFFALSE 79014
// begin if GetClass ( j ) <> 3 then
78650: LD_VAR 0 3
78654: PPUSH
78655: CALL_OW 257
78659: PUSH
78660: LD_INT 3
78662: NONEQUAL
78663: IFFALSE 78716
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78665: LD_ADDR_EXP 98
78669: PUSH
78670: LD_EXP 98
78674: PPUSH
78675: LD_VAR 0 2
78679: PPUSH
78680: LD_EXP 98
78684: PUSH
78685: LD_VAR 0 2
78689: ARRAY
78690: PUSH
78691: LD_VAR 0 3
78695: DIFF
78696: PPUSH
78697: CALL_OW 1
78701: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78702: LD_VAR 0 3
78706: PPUSH
78707: LD_INT 0
78709: PPUSH
78710: CALL_OW 109
// continue ;
78714: GO 78647
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78716: LD_EXP 77
78720: PUSH
78721: LD_VAR 0 2
78725: ARRAY
78726: PPUSH
78727: LD_INT 34
78729: PUSH
78730: LD_INT 31
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 58
78739: PUSH
78740: EMPTY
78741: LIST
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PPUSH
78747: CALL_OW 72
78751: PUSH
78752: LD_VAR 0 3
78756: PPUSH
78757: CALL 54559 0 1
78761: NOT
78762: AND
78763: IFFALSE 78834
// begin if IsInUnit ( j ) then
78765: LD_VAR 0 3
78769: PPUSH
78770: CALL_OW 310
78774: IFFALSE 78785
// ComExitBuilding ( j ) ;
78776: LD_VAR 0 3
78780: PPUSH
78781: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78785: LD_VAR 0 3
78789: PPUSH
78790: LD_EXP 77
78794: PUSH
78795: LD_VAR 0 2
78799: ARRAY
78800: PPUSH
78801: LD_INT 34
78803: PUSH
78804: LD_INT 31
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 58
78813: PUSH
78814: EMPTY
78815: LIST
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PPUSH
78821: CALL_OW 72
78825: PUSH
78826: LD_INT 1
78828: ARRAY
78829: PPUSH
78830: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78834: LD_VAR 0 3
78838: PPUSH
78839: CALL_OW 310
78843: NOT
78844: PUSH
78845: LD_VAR 0 3
78849: PPUSH
78850: CALL_OW 310
78854: PPUSH
78855: CALL_OW 266
78859: PUSH
78860: LD_INT 36
78862: NONEQUAL
78863: PUSH
78864: LD_VAR 0 3
78868: PPUSH
78869: CALL 54559 0 1
78873: NOT
78874: AND
78875: OR
78876: IFFALSE 79012
// begin if IsInUnit ( j ) then
78878: LD_VAR 0 3
78882: PPUSH
78883: CALL_OW 310
78887: IFFALSE 78898
// ComExitBuilding ( j ) ;
78889: LD_VAR 0 3
78893: PPUSH
78894: CALL_OW 122
// ct := 0 ;
78898: LD_ADDR_VAR 0 8
78902: PUSH
78903: LD_INT 0
78905: ST_TO_ADDR
// for k in x do
78906: LD_ADDR_VAR 0 4
78910: PUSH
78911: LD_VAR 0 11
78915: PUSH
78916: FOR_IN
78917: IFFALSE 78990
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78919: LD_VAR 0 4
78923: PPUSH
78924: CALL_OW 264
78928: PUSH
78929: LD_INT 31
78931: EQUAL
78932: PUSH
78933: LD_VAR 0 4
78937: PPUSH
78938: CALL_OW 311
78942: NOT
78943: AND
78944: PUSH
78945: LD_VAR 0 4
78949: PPUSH
78950: CALL_OW 266
78954: PUSH
78955: LD_INT 36
78957: EQUAL
78958: PUSH
78959: LD_VAR 0 4
78963: PPUSH
78964: CALL_OW 313
78968: PUSH
78969: LD_INT 3
78971: LESS
78972: AND
78973: OR
78974: IFFALSE 78988
// begin ct := k ;
78976: LD_ADDR_VAR 0 8
78980: PUSH
78981: LD_VAR 0 4
78985: ST_TO_ADDR
// break ;
78986: GO 78990
// end ;
78988: GO 78916
78990: POP
78991: POP
// if ct then
78992: LD_VAR 0 8
78996: IFFALSE 79012
// ComEnterUnit ( j , ct ) ;
78998: LD_VAR 0 3
79002: PPUSH
79003: LD_VAR 0 8
79007: PPUSH
79008: CALL_OW 120
// end ; end ;
79012: GO 78647
79014: POP
79015: POP
// places := 0 ;
79016: LD_ADDR_VAR 0 5
79020: PUSH
79021: LD_INT 0
79023: ST_TO_ADDR
// for j = 1 to x do
79024: LD_ADDR_VAR 0 3
79028: PUSH
79029: DOUBLE
79030: LD_INT 1
79032: DEC
79033: ST_TO_ADDR
79034: LD_VAR 0 11
79038: PUSH
79039: FOR_TO
79040: IFFALSE 79116
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79042: LD_VAR 0 11
79046: PUSH
79047: LD_VAR 0 3
79051: ARRAY
79052: PPUSH
79053: CALL_OW 264
79057: PUSH
79058: LD_INT 31
79060: EQUAL
79061: IFFALSE 79079
// places := places + 1 else
79063: LD_ADDR_VAR 0 5
79067: PUSH
79068: LD_VAR 0 5
79072: PUSH
79073: LD_INT 1
79075: PLUS
79076: ST_TO_ADDR
79077: GO 79114
// if GetBType ( x [ j ] ) = b_control_tower then
79079: LD_VAR 0 11
79083: PUSH
79084: LD_VAR 0 3
79088: ARRAY
79089: PPUSH
79090: CALL_OW 266
79094: PUSH
79095: LD_INT 36
79097: EQUAL
79098: IFFALSE 79114
// places := places + 3 ;
79100: LD_ADDR_VAR 0 5
79104: PUSH
79105: LD_VAR 0 5
79109: PUSH
79110: LD_INT 3
79112: PLUS
79113: ST_TO_ADDR
79114: GO 79039
79116: POP
79117: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79118: LD_VAR 0 5
79122: PUSH
79123: LD_INT 0
79125: EQUAL
79126: PUSH
79127: LD_VAR 0 5
79131: PUSH
79132: LD_EXP 98
79136: PUSH
79137: LD_VAR 0 2
79141: ARRAY
79142: LESSEQUAL
79143: OR
79144: IFFALSE 79148
// continue ;
79146: GO 78398
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79148: LD_ADDR_VAR 0 6
79152: PUSH
79153: LD_EXP 58
79157: PUSH
79158: LD_VAR 0 2
79162: ARRAY
79163: PPUSH
79164: LD_INT 25
79166: PUSH
79167: LD_INT 3
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PPUSH
79174: CALL_OW 72
79178: PUSH
79179: LD_EXP 98
79183: PUSH
79184: LD_VAR 0 2
79188: ARRAY
79189: DIFF
79190: PPUSH
79191: LD_INT 3
79193: PPUSH
79194: CALL 55459 0 2
79198: ST_TO_ADDR
// for j in tmp do
79199: LD_ADDR_VAR 0 3
79203: PUSH
79204: LD_VAR 0 6
79208: PUSH
79209: FOR_IN
79210: IFFALSE 79245
// if GetTag ( j ) > 0 then
79212: LD_VAR 0 3
79216: PPUSH
79217: CALL_OW 110
79221: PUSH
79222: LD_INT 0
79224: GREATER
79225: IFFALSE 79243
// tmp := tmp diff j ;
79227: LD_ADDR_VAR 0 6
79231: PUSH
79232: LD_VAR 0 6
79236: PUSH
79237: LD_VAR 0 3
79241: DIFF
79242: ST_TO_ADDR
79243: GO 79209
79245: POP
79246: POP
// if not tmp then
79247: LD_VAR 0 6
79251: NOT
79252: IFFALSE 79256
// continue ;
79254: GO 78398
// if places then
79256: LD_VAR 0 5
79260: IFFALSE 79319
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79262: LD_ADDR_EXP 98
79266: PUSH
79267: LD_EXP 98
79271: PPUSH
79272: LD_VAR 0 2
79276: PPUSH
79277: LD_EXP 98
79281: PUSH
79282: LD_VAR 0 2
79286: ARRAY
79287: PUSH
79288: LD_VAR 0 6
79292: PUSH
79293: LD_INT 1
79295: ARRAY
79296: UNION
79297: PPUSH
79298: CALL_OW 1
79302: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79303: LD_VAR 0 6
79307: PUSH
79308: LD_INT 1
79310: ARRAY
79311: PPUSH
79312: LD_INT 126
79314: PPUSH
79315: CALL_OW 109
// end ; end ;
79319: GO 78398
79321: POP
79322: POP
// end ;
79323: LD_VAR 0 1
79327: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79328: LD_INT 0
79330: PPUSH
79331: PPUSH
79332: PPUSH
79333: PPUSH
79334: PPUSH
79335: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79336: LD_VAR 0 1
79340: NOT
79341: PUSH
79342: LD_VAR 0 2
79346: NOT
79347: OR
79348: PUSH
79349: LD_VAR 0 3
79353: NOT
79354: OR
79355: PUSH
79356: LD_VAR 0 4
79360: PUSH
79361: LD_INT 1
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 3
79369: PUSH
79370: LD_INT 4
79372: PUSH
79373: LD_INT 5
79375: PUSH
79376: LD_INT 8
79378: PUSH
79379: LD_INT 9
79381: PUSH
79382: LD_INT 15
79384: PUSH
79385: LD_INT 16
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: IN
79399: NOT
79400: OR
79401: IFFALSE 79405
// exit ;
79403: GO 80305
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79405: LD_ADDR_VAR 0 2
79409: PUSH
79410: LD_VAR 0 2
79414: PPUSH
79415: LD_INT 21
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 24
79427: PUSH
79428: LD_INT 250
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PPUSH
79439: CALL_OW 72
79443: ST_TO_ADDR
// case class of 1 , 15 :
79444: LD_VAR 0 4
79448: PUSH
79449: LD_INT 1
79451: DOUBLE
79452: EQUAL
79453: IFTRUE 79463
79455: LD_INT 15
79457: DOUBLE
79458: EQUAL
79459: IFTRUE 79463
79461: GO 79548
79463: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79464: LD_ADDR_VAR 0 8
79468: PUSH
79469: LD_VAR 0 2
79473: PPUSH
79474: LD_INT 2
79476: PUSH
79477: LD_INT 30
79479: PUSH
79480: LD_INT 32
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 30
79489: PUSH
79490: LD_INT 31
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: LIST
79501: PPUSH
79502: CALL_OW 72
79506: PUSH
79507: LD_VAR 0 2
79511: PPUSH
79512: LD_INT 2
79514: PUSH
79515: LD_INT 30
79517: PUSH
79518: LD_INT 4
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 30
79527: PUSH
79528: LD_INT 5
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: LIST
79539: PPUSH
79540: CALL_OW 72
79544: ADD
79545: ST_TO_ADDR
79546: GO 79794
79548: LD_INT 2
79550: DOUBLE
79551: EQUAL
79552: IFTRUE 79562
79554: LD_INT 16
79556: DOUBLE
79557: EQUAL
79558: IFTRUE 79562
79560: GO 79608
79562: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79563: LD_ADDR_VAR 0 8
79567: PUSH
79568: LD_VAR 0 2
79572: PPUSH
79573: LD_INT 2
79575: PUSH
79576: LD_INT 30
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 30
79588: PUSH
79589: LD_INT 1
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: LIST
79600: PPUSH
79601: CALL_OW 72
79605: ST_TO_ADDR
79606: GO 79794
79608: LD_INT 3
79610: DOUBLE
79611: EQUAL
79612: IFTRUE 79616
79614: GO 79662
79616: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79617: LD_ADDR_VAR 0 8
79621: PUSH
79622: LD_VAR 0 2
79626: PPUSH
79627: LD_INT 2
79629: PUSH
79630: LD_INT 30
79632: PUSH
79633: LD_INT 2
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 30
79642: PUSH
79643: LD_INT 3
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: LIST
79654: PPUSH
79655: CALL_OW 72
79659: ST_TO_ADDR
79660: GO 79794
79662: LD_INT 4
79664: DOUBLE
79665: EQUAL
79666: IFTRUE 79670
79668: GO 79727
79670: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79671: LD_ADDR_VAR 0 8
79675: PUSH
79676: LD_VAR 0 2
79680: PPUSH
79681: LD_INT 2
79683: PUSH
79684: LD_INT 30
79686: PUSH
79687: LD_INT 6
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 30
79696: PUSH
79697: LD_INT 7
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 30
79706: PUSH
79707: LD_INT 8
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: PPUSH
79720: CALL_OW 72
79724: ST_TO_ADDR
79725: GO 79794
79727: LD_INT 5
79729: DOUBLE
79730: EQUAL
79731: IFTRUE 79747
79733: LD_INT 8
79735: DOUBLE
79736: EQUAL
79737: IFTRUE 79747
79739: LD_INT 9
79741: DOUBLE
79742: EQUAL
79743: IFTRUE 79747
79745: GO 79793
79747: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79748: LD_ADDR_VAR 0 8
79752: PUSH
79753: LD_VAR 0 2
79757: PPUSH
79758: LD_INT 2
79760: PUSH
79761: LD_INT 30
79763: PUSH
79764: LD_INT 4
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 30
79773: PUSH
79774: LD_INT 5
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: LIST
79785: PPUSH
79786: CALL_OW 72
79790: ST_TO_ADDR
79791: GO 79794
79793: POP
// if not tmp then
79794: LD_VAR 0 8
79798: NOT
79799: IFFALSE 79803
// exit ;
79801: GO 80305
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79803: LD_VAR 0 4
79807: PUSH
79808: LD_INT 1
79810: PUSH
79811: LD_INT 15
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: IN
79818: PUSH
79819: LD_EXP 67
79823: PUSH
79824: LD_VAR 0 1
79828: ARRAY
79829: AND
79830: IFFALSE 79986
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79832: LD_ADDR_VAR 0 9
79836: PUSH
79837: LD_EXP 67
79841: PUSH
79842: LD_VAR 0 1
79846: ARRAY
79847: PUSH
79848: LD_INT 1
79850: ARRAY
79851: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79852: LD_VAR 0 9
79856: PUSH
79857: LD_EXP 68
79861: PUSH
79862: LD_VAR 0 1
79866: ARRAY
79867: IN
79868: NOT
79869: IFFALSE 79984
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79871: LD_ADDR_EXP 68
79875: PUSH
79876: LD_EXP 68
79880: PPUSH
79881: LD_VAR 0 1
79885: PUSH
79886: LD_EXP 68
79890: PUSH
79891: LD_VAR 0 1
79895: ARRAY
79896: PUSH
79897: LD_INT 1
79899: PLUS
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PPUSH
79905: LD_VAR 0 9
79909: PPUSH
79910: CALL 21211 0 3
79914: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79915: LD_ADDR_EXP 67
79919: PUSH
79920: LD_EXP 67
79924: PPUSH
79925: LD_VAR 0 1
79929: PPUSH
79930: LD_EXP 67
79934: PUSH
79935: LD_VAR 0 1
79939: ARRAY
79940: PUSH
79941: LD_VAR 0 9
79945: DIFF
79946: PPUSH
79947: CALL_OW 1
79951: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79952: LD_VAR 0 3
79956: PPUSH
79957: LD_EXP 68
79961: PUSH
79962: LD_VAR 0 1
79966: ARRAY
79967: PUSH
79968: LD_EXP 68
79972: PUSH
79973: LD_VAR 0 1
79977: ARRAY
79978: ARRAY
79979: PPUSH
79980: CALL_OW 120
// end ; exit ;
79984: GO 80305
// end ; if tmp > 1 then
79986: LD_VAR 0 8
79990: PUSH
79991: LD_INT 1
79993: GREATER
79994: IFFALSE 80098
// for i = 2 to tmp do
79996: LD_ADDR_VAR 0 6
80000: PUSH
80001: DOUBLE
80002: LD_INT 2
80004: DEC
80005: ST_TO_ADDR
80006: LD_VAR 0 8
80010: PUSH
80011: FOR_TO
80012: IFFALSE 80096
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80014: LD_VAR 0 8
80018: PUSH
80019: LD_VAR 0 6
80023: ARRAY
80024: PPUSH
80025: CALL_OW 461
80029: PUSH
80030: LD_INT 6
80032: EQUAL
80033: IFFALSE 80094
// begin x := tmp [ i ] ;
80035: LD_ADDR_VAR 0 9
80039: PUSH
80040: LD_VAR 0 8
80044: PUSH
80045: LD_VAR 0 6
80049: ARRAY
80050: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80051: LD_ADDR_VAR 0 8
80055: PUSH
80056: LD_VAR 0 8
80060: PPUSH
80061: LD_VAR 0 6
80065: PPUSH
80066: CALL_OW 3
80070: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80071: LD_ADDR_VAR 0 8
80075: PUSH
80076: LD_VAR 0 8
80080: PPUSH
80081: LD_INT 1
80083: PPUSH
80084: LD_VAR 0 9
80088: PPUSH
80089: CALL_OW 2
80093: ST_TO_ADDR
// end ;
80094: GO 80011
80096: POP
80097: POP
// for i in tmp do
80098: LD_ADDR_VAR 0 6
80102: PUSH
80103: LD_VAR 0 8
80107: PUSH
80108: FOR_IN
80109: IFFALSE 80178
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80111: LD_VAR 0 6
80115: PPUSH
80116: CALL_OW 313
80120: PUSH
80121: LD_INT 6
80123: LESS
80124: PUSH
80125: LD_VAR 0 6
80129: PPUSH
80130: CALL_OW 266
80134: PUSH
80135: LD_INT 31
80137: PUSH
80138: LD_INT 32
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: IN
80145: NOT
80146: AND
80147: PUSH
80148: LD_VAR 0 6
80152: PPUSH
80153: CALL_OW 313
80157: PUSH
80158: LD_INT 0
80160: EQUAL
80161: OR
80162: IFFALSE 80176
// begin j := i ;
80164: LD_ADDR_VAR 0 7
80168: PUSH
80169: LD_VAR 0 6
80173: ST_TO_ADDR
// break ;
80174: GO 80178
// end ; end ;
80176: GO 80108
80178: POP
80179: POP
// if j then
80180: LD_VAR 0 7
80184: IFFALSE 80202
// ComEnterUnit ( unit , j ) else
80186: LD_VAR 0 3
80190: PPUSH
80191: LD_VAR 0 7
80195: PPUSH
80196: CALL_OW 120
80200: GO 80305
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80202: LD_ADDR_VAR 0 10
80206: PUSH
80207: LD_VAR 0 2
80211: PPUSH
80212: LD_INT 2
80214: PUSH
80215: LD_INT 30
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 30
80227: PUSH
80228: LD_INT 1
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: LIST
80239: PPUSH
80240: CALL_OW 72
80244: ST_TO_ADDR
// if depot then
80245: LD_VAR 0 10
80249: IFFALSE 80305
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80251: LD_ADDR_VAR 0 10
80255: PUSH
80256: LD_VAR 0 10
80260: PPUSH
80261: LD_VAR 0 3
80265: PPUSH
80266: CALL_OW 74
80270: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80271: LD_VAR 0 3
80275: PPUSH
80276: LD_VAR 0 10
80280: PPUSH
80281: CALL_OW 296
80285: PUSH
80286: LD_INT 10
80288: GREATER
80289: IFFALSE 80305
// ComStandNearbyBuilding ( unit , depot ) ;
80291: LD_VAR 0 3
80295: PPUSH
80296: LD_VAR 0 10
80300: PPUSH
80301: CALL 15503 0 2
// end ; end ; end ;
80305: LD_VAR 0 5
80309: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80310: LD_INT 0
80312: PPUSH
80313: PPUSH
80314: PPUSH
80315: PPUSH
// if not mc_bases then
80316: LD_EXP 58
80320: NOT
80321: IFFALSE 80325
// exit ;
80323: GO 80564
// for i = 1 to mc_bases do
80325: LD_ADDR_VAR 0 2
80329: PUSH
80330: DOUBLE
80331: LD_INT 1
80333: DEC
80334: ST_TO_ADDR
80335: LD_EXP 58
80339: PUSH
80340: FOR_TO
80341: IFFALSE 80562
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80343: LD_ADDR_VAR 0 4
80347: PUSH
80348: LD_EXP 58
80352: PUSH
80353: LD_VAR 0 2
80357: ARRAY
80358: PPUSH
80359: LD_INT 21
80361: PUSH
80362: LD_INT 1
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PPUSH
80369: CALL_OW 72
80373: PUSH
80374: LD_EXP 87
80378: PUSH
80379: LD_VAR 0 2
80383: ARRAY
80384: UNION
80385: ST_TO_ADDR
// if not tmp then
80386: LD_VAR 0 4
80390: NOT
80391: IFFALSE 80395
// continue ;
80393: GO 80340
// for j in tmp do
80395: LD_ADDR_VAR 0 3
80399: PUSH
80400: LD_VAR 0 4
80404: PUSH
80405: FOR_IN
80406: IFFALSE 80558
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80408: LD_VAR 0 3
80412: PPUSH
80413: CALL_OW 110
80417: NOT
80418: PUSH
80419: LD_VAR 0 3
80423: PPUSH
80424: CALL_OW 314
80428: NOT
80429: AND
80430: PUSH
80431: LD_VAR 0 3
80435: PPUSH
80436: CALL_OW 311
80440: NOT
80441: AND
80442: PUSH
80443: LD_VAR 0 3
80447: PPUSH
80448: CALL_OW 310
80452: NOT
80453: AND
80454: PUSH
80455: LD_VAR 0 3
80459: PUSH
80460: LD_EXP 61
80464: PUSH
80465: LD_VAR 0 2
80469: ARRAY
80470: PUSH
80471: LD_INT 1
80473: ARRAY
80474: IN
80475: NOT
80476: AND
80477: PUSH
80478: LD_VAR 0 3
80482: PUSH
80483: LD_EXP 61
80487: PUSH
80488: LD_VAR 0 2
80492: ARRAY
80493: PUSH
80494: LD_INT 2
80496: ARRAY
80497: IN
80498: NOT
80499: AND
80500: PUSH
80501: LD_VAR 0 3
80505: PUSH
80506: LD_EXP 70
80510: PUSH
80511: LD_VAR 0 2
80515: ARRAY
80516: IN
80517: NOT
80518: AND
80519: IFFALSE 80556
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80521: LD_VAR 0 2
80525: PPUSH
80526: LD_EXP 58
80530: PUSH
80531: LD_VAR 0 2
80535: ARRAY
80536: PPUSH
80537: LD_VAR 0 3
80541: PPUSH
80542: LD_VAR 0 3
80546: PPUSH
80547: CALL_OW 257
80551: PPUSH
80552: CALL 79328 0 4
// end ;
80556: GO 80405
80558: POP
80559: POP
// end ;
80560: GO 80340
80562: POP
80563: POP
// end ;
80564: LD_VAR 0 1
80568: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80569: LD_INT 0
80571: PPUSH
80572: PPUSH
80573: PPUSH
80574: PPUSH
80575: PPUSH
80576: PPUSH
// if not mc_bases [ base ] then
80577: LD_EXP 58
80581: PUSH
80582: LD_VAR 0 1
80586: ARRAY
80587: NOT
80588: IFFALSE 80592
// exit ;
80590: GO 80774
// tmp := [ ] ;
80592: LD_ADDR_VAR 0 6
80596: PUSH
80597: EMPTY
80598: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80599: LD_ADDR_VAR 0 7
80603: PUSH
80604: LD_VAR 0 3
80608: PPUSH
80609: LD_INT 0
80611: PPUSH
80612: CALL_OW 517
80616: ST_TO_ADDR
// if not list then
80617: LD_VAR 0 7
80621: NOT
80622: IFFALSE 80626
// exit ;
80624: GO 80774
// for i = 1 to amount do
80626: LD_ADDR_VAR 0 5
80630: PUSH
80631: DOUBLE
80632: LD_INT 1
80634: DEC
80635: ST_TO_ADDR
80636: LD_VAR 0 2
80640: PUSH
80641: FOR_TO
80642: IFFALSE 80722
// begin x := rand ( 1 , list [ 1 ] ) ;
80644: LD_ADDR_VAR 0 8
80648: PUSH
80649: LD_INT 1
80651: PPUSH
80652: LD_VAR 0 7
80656: PUSH
80657: LD_INT 1
80659: ARRAY
80660: PPUSH
80661: CALL_OW 12
80665: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80666: LD_ADDR_VAR 0 6
80670: PUSH
80671: LD_VAR 0 6
80675: PPUSH
80676: LD_VAR 0 5
80680: PPUSH
80681: LD_VAR 0 7
80685: PUSH
80686: LD_INT 1
80688: ARRAY
80689: PUSH
80690: LD_VAR 0 8
80694: ARRAY
80695: PUSH
80696: LD_VAR 0 7
80700: PUSH
80701: LD_INT 2
80703: ARRAY
80704: PUSH
80705: LD_VAR 0 8
80709: ARRAY
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PPUSH
80715: CALL_OW 1
80719: ST_TO_ADDR
// end ;
80720: GO 80641
80722: POP
80723: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80724: LD_ADDR_EXP 71
80728: PUSH
80729: LD_EXP 71
80733: PPUSH
80734: LD_VAR 0 1
80738: PPUSH
80739: LD_VAR 0 6
80743: PPUSH
80744: CALL_OW 1
80748: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80749: LD_ADDR_EXP 73
80753: PUSH
80754: LD_EXP 73
80758: PPUSH
80759: LD_VAR 0 1
80763: PPUSH
80764: LD_VAR 0 3
80768: PPUSH
80769: CALL_OW 1
80773: ST_TO_ADDR
// end ;
80774: LD_VAR 0 4
80778: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80779: LD_INT 0
80781: PPUSH
// if not mc_bases [ base ] then
80782: LD_EXP 58
80786: PUSH
80787: LD_VAR 0 1
80791: ARRAY
80792: NOT
80793: IFFALSE 80797
// exit ;
80795: GO 80822
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80797: LD_ADDR_EXP 63
80801: PUSH
80802: LD_EXP 63
80806: PPUSH
80807: LD_VAR 0 1
80811: PPUSH
80812: LD_VAR 0 2
80816: PPUSH
80817: CALL_OW 1
80821: ST_TO_ADDR
// end ;
80822: LD_VAR 0 3
80826: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80827: LD_INT 0
80829: PPUSH
// if not mc_bases [ base ] then
80830: LD_EXP 58
80834: PUSH
80835: LD_VAR 0 1
80839: ARRAY
80840: NOT
80841: IFFALSE 80845
// exit ;
80843: GO 80882
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80845: LD_ADDR_EXP 63
80849: PUSH
80850: LD_EXP 63
80854: PPUSH
80855: LD_VAR 0 1
80859: PPUSH
80860: LD_EXP 63
80864: PUSH
80865: LD_VAR 0 1
80869: ARRAY
80870: PUSH
80871: LD_VAR 0 2
80875: UNION
80876: PPUSH
80877: CALL_OW 1
80881: ST_TO_ADDR
// end ;
80882: LD_VAR 0 3
80886: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80887: LD_INT 0
80889: PPUSH
// if not mc_bases [ base ] then
80890: LD_EXP 58
80894: PUSH
80895: LD_VAR 0 1
80899: ARRAY
80900: NOT
80901: IFFALSE 80905
// exit ;
80903: GO 80930
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80905: LD_ADDR_EXP 79
80909: PUSH
80910: LD_EXP 79
80914: PPUSH
80915: LD_VAR 0 1
80919: PPUSH
80920: LD_VAR 0 2
80924: PPUSH
80925: CALL_OW 1
80929: ST_TO_ADDR
// end ;
80930: LD_VAR 0 3
80934: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80935: LD_INT 0
80937: PPUSH
// if not mc_bases [ base ] then
80938: LD_EXP 58
80942: PUSH
80943: LD_VAR 0 1
80947: ARRAY
80948: NOT
80949: IFFALSE 80953
// exit ;
80951: GO 80990
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80953: LD_ADDR_EXP 79
80957: PUSH
80958: LD_EXP 79
80962: PPUSH
80963: LD_VAR 0 1
80967: PPUSH
80968: LD_EXP 79
80972: PUSH
80973: LD_VAR 0 1
80977: ARRAY
80978: PUSH
80979: LD_VAR 0 2
80983: ADD
80984: PPUSH
80985: CALL_OW 1
80989: ST_TO_ADDR
// end ;
80990: LD_VAR 0 3
80994: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80995: LD_INT 0
80997: PPUSH
// if not mc_bases [ base ] then
80998: LD_EXP 58
81002: PUSH
81003: LD_VAR 0 1
81007: ARRAY
81008: NOT
81009: IFFALSE 81013
// exit ;
81011: GO 81067
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81013: LD_ADDR_EXP 80
81017: PUSH
81018: LD_EXP 80
81022: PPUSH
81023: LD_VAR 0 1
81027: PPUSH
81028: LD_VAR 0 2
81032: PPUSH
81033: CALL_OW 1
81037: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81038: LD_ADDR_EXP 69
81042: PUSH
81043: LD_EXP 69
81047: PPUSH
81048: LD_VAR 0 1
81052: PPUSH
81053: LD_VAR 0 2
81057: PUSH
81058: LD_INT 0
81060: PLUS
81061: PPUSH
81062: CALL_OW 1
81066: ST_TO_ADDR
// end ;
81067: LD_VAR 0 3
81071: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81072: LD_INT 0
81074: PPUSH
// if not mc_bases [ base ] then
81075: LD_EXP 58
81079: PUSH
81080: LD_VAR 0 1
81084: ARRAY
81085: NOT
81086: IFFALSE 81090
// exit ;
81088: GO 81115
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81090: LD_ADDR_EXP 69
81094: PUSH
81095: LD_EXP 69
81099: PPUSH
81100: LD_VAR 0 1
81104: PPUSH
81105: LD_VAR 0 2
81109: PPUSH
81110: CALL_OW 1
81114: ST_TO_ADDR
// end ;
81115: LD_VAR 0 3
81119: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81120: LD_INT 0
81122: PPUSH
81123: PPUSH
81124: PPUSH
81125: PPUSH
// if not mc_bases [ base ] then
81126: LD_EXP 58
81130: PUSH
81131: LD_VAR 0 1
81135: ARRAY
81136: NOT
81137: IFFALSE 81141
// exit ;
81139: GO 81206
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81141: LD_ADDR_EXP 78
81145: PUSH
81146: LD_EXP 78
81150: PPUSH
81151: LD_VAR 0 1
81155: PUSH
81156: LD_EXP 78
81160: PUSH
81161: LD_VAR 0 1
81165: ARRAY
81166: PUSH
81167: LD_INT 1
81169: PLUS
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PPUSH
81175: LD_VAR 0 1
81179: PUSH
81180: LD_VAR 0 2
81184: PUSH
81185: LD_VAR 0 3
81189: PUSH
81190: LD_VAR 0 4
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: PPUSH
81201: CALL 21211 0 3
81205: ST_TO_ADDR
// end ;
81206: LD_VAR 0 5
81210: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81211: LD_INT 0
81213: PPUSH
// if not mc_bases [ base ] then
81214: LD_EXP 58
81218: PUSH
81219: LD_VAR 0 1
81223: ARRAY
81224: NOT
81225: IFFALSE 81229
// exit ;
81227: GO 81254
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81229: LD_ADDR_EXP 95
81233: PUSH
81234: LD_EXP 95
81238: PPUSH
81239: LD_VAR 0 1
81243: PPUSH
81244: LD_VAR 0 2
81248: PPUSH
81249: CALL_OW 1
81253: ST_TO_ADDR
// end ;
81254: LD_VAR 0 3
81258: RET
// export function MC_GetMinesField ( base ) ; begin
81259: LD_INT 0
81261: PPUSH
// result := mc_mines [ base ] ;
81262: LD_ADDR_VAR 0 2
81266: PUSH
81267: LD_EXP 71
81271: PUSH
81272: LD_VAR 0 1
81276: ARRAY
81277: ST_TO_ADDR
// end ;
81278: LD_VAR 0 2
81282: RET
// export function MC_GetProduceList ( base ) ; begin
81283: LD_INT 0
81285: PPUSH
// result := mc_produce [ base ] ;
81286: LD_ADDR_VAR 0 2
81290: PUSH
81291: LD_EXP 79
81295: PUSH
81296: LD_VAR 0 1
81300: ARRAY
81301: ST_TO_ADDR
// end ;
81302: LD_VAR 0 2
81306: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81307: LD_INT 0
81309: PPUSH
81310: PPUSH
// if not mc_bases then
81311: LD_EXP 58
81315: NOT
81316: IFFALSE 81320
// exit ;
81318: GO 81385
// if mc_bases [ base ] then
81320: LD_EXP 58
81324: PUSH
81325: LD_VAR 0 1
81329: ARRAY
81330: IFFALSE 81385
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81332: LD_ADDR_VAR 0 3
81336: PUSH
81337: LD_EXP 58
81341: PUSH
81342: LD_VAR 0 1
81346: ARRAY
81347: PPUSH
81348: LD_INT 30
81350: PUSH
81351: LD_VAR 0 2
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PPUSH
81360: CALL_OW 72
81364: ST_TO_ADDR
// if result then
81365: LD_VAR 0 3
81369: IFFALSE 81385
// result := result [ 1 ] ;
81371: LD_ADDR_VAR 0 3
81375: PUSH
81376: LD_VAR 0 3
81380: PUSH
81381: LD_INT 1
81383: ARRAY
81384: ST_TO_ADDR
// end ; end ;
81385: LD_VAR 0 3
81389: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81390: LD_INT 0
81392: PPUSH
81393: PPUSH
// if not mc_bases then
81394: LD_EXP 58
81398: NOT
81399: IFFALSE 81403
// exit ;
81401: GO 81448
// if mc_bases [ base ] then
81403: LD_EXP 58
81407: PUSH
81408: LD_VAR 0 1
81412: ARRAY
81413: IFFALSE 81448
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81415: LD_ADDR_VAR 0 3
81419: PUSH
81420: LD_EXP 58
81424: PUSH
81425: LD_VAR 0 1
81429: ARRAY
81430: PPUSH
81431: LD_INT 30
81433: PUSH
81434: LD_VAR 0 2
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PPUSH
81443: CALL_OW 72
81447: ST_TO_ADDR
// end ;
81448: LD_VAR 0 3
81452: RET
// export function MC_SetTame ( base , area ) ; begin
81453: LD_INT 0
81455: PPUSH
// if not mc_bases or not base then
81456: LD_EXP 58
81460: NOT
81461: PUSH
81462: LD_VAR 0 1
81466: NOT
81467: OR
81468: IFFALSE 81472
// exit ;
81470: GO 81497
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81472: LD_ADDR_EXP 86
81476: PUSH
81477: LD_EXP 86
81481: PPUSH
81482: LD_VAR 0 1
81486: PPUSH
81487: LD_VAR 0 2
81491: PPUSH
81492: CALL_OW 1
81496: ST_TO_ADDR
// end ;
81497: LD_VAR 0 3
81501: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81502: LD_INT 0
81504: PPUSH
81505: PPUSH
// if not mc_bases or not base then
81506: LD_EXP 58
81510: NOT
81511: PUSH
81512: LD_VAR 0 1
81516: NOT
81517: OR
81518: IFFALSE 81522
// exit ;
81520: GO 81624
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81522: LD_ADDR_VAR 0 4
81526: PUSH
81527: LD_EXP 58
81531: PUSH
81532: LD_VAR 0 1
81536: ARRAY
81537: PPUSH
81538: LD_INT 30
81540: PUSH
81541: LD_VAR 0 2
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PPUSH
81550: CALL_OW 72
81554: ST_TO_ADDR
// if not tmp then
81555: LD_VAR 0 4
81559: NOT
81560: IFFALSE 81564
// exit ;
81562: GO 81624
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81564: LD_ADDR_EXP 90
81568: PUSH
81569: LD_EXP 90
81573: PPUSH
81574: LD_VAR 0 1
81578: PPUSH
81579: LD_EXP 90
81583: PUSH
81584: LD_VAR 0 1
81588: ARRAY
81589: PPUSH
81590: LD_EXP 90
81594: PUSH
81595: LD_VAR 0 1
81599: ARRAY
81600: PUSH
81601: LD_INT 1
81603: PLUS
81604: PPUSH
81605: LD_VAR 0 4
81609: PUSH
81610: LD_INT 1
81612: ARRAY
81613: PPUSH
81614: CALL_OW 2
81618: PPUSH
81619: CALL_OW 1
81623: ST_TO_ADDR
// end ;
81624: LD_VAR 0 3
81628: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81629: LD_INT 0
81631: PPUSH
81632: PPUSH
// if not mc_bases or not base or not kinds then
81633: LD_EXP 58
81637: NOT
81638: PUSH
81639: LD_VAR 0 1
81643: NOT
81644: OR
81645: PUSH
81646: LD_VAR 0 2
81650: NOT
81651: OR
81652: IFFALSE 81656
// exit ;
81654: GO 81717
// for i in kinds do
81656: LD_ADDR_VAR 0 4
81660: PUSH
81661: LD_VAR 0 2
81665: PUSH
81666: FOR_IN
81667: IFFALSE 81715
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81669: LD_ADDR_EXP 92
81673: PUSH
81674: LD_EXP 92
81678: PPUSH
81679: LD_VAR 0 1
81683: PUSH
81684: LD_EXP 92
81688: PUSH
81689: LD_VAR 0 1
81693: ARRAY
81694: PUSH
81695: LD_INT 1
81697: PLUS
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PPUSH
81703: LD_VAR 0 4
81707: PPUSH
81708: CALL 21211 0 3
81712: ST_TO_ADDR
81713: GO 81666
81715: POP
81716: POP
// end ;
81717: LD_VAR 0 3
81721: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81722: LD_INT 0
81724: PPUSH
// if not mc_bases or not base or not areas then
81725: LD_EXP 58
81729: NOT
81730: PUSH
81731: LD_VAR 0 1
81735: NOT
81736: OR
81737: PUSH
81738: LD_VAR 0 2
81742: NOT
81743: OR
81744: IFFALSE 81748
// exit ;
81746: GO 81773
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81748: LD_ADDR_EXP 76
81752: PUSH
81753: LD_EXP 76
81757: PPUSH
81758: LD_VAR 0 1
81762: PPUSH
81763: LD_VAR 0 2
81767: PPUSH
81768: CALL_OW 1
81772: ST_TO_ADDR
// end ;
81773: LD_VAR 0 3
81777: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81778: LD_INT 0
81780: PPUSH
// if not mc_bases or not base or not teleports_exit then
81781: LD_EXP 58
81785: NOT
81786: PUSH
81787: LD_VAR 0 1
81791: NOT
81792: OR
81793: PUSH
81794: LD_VAR 0 2
81798: NOT
81799: OR
81800: IFFALSE 81804
// exit ;
81802: GO 81829
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81804: LD_ADDR_EXP 93
81808: PUSH
81809: LD_EXP 93
81813: PPUSH
81814: LD_VAR 0 1
81818: PPUSH
81819: LD_VAR 0 2
81823: PPUSH
81824: CALL_OW 1
81828: ST_TO_ADDR
// end ;
81829: LD_VAR 0 3
81833: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81834: LD_INT 0
81836: PPUSH
81837: PPUSH
81838: PPUSH
// if not mc_bases or not base or not ext_list then
81839: LD_EXP 58
81843: NOT
81844: PUSH
81845: LD_VAR 0 1
81849: NOT
81850: OR
81851: PUSH
81852: LD_VAR 0 5
81856: NOT
81857: OR
81858: IFFALSE 81862
// exit ;
81860: GO 82035
// tmp := GetFacExtXYD ( x , y , d ) ;
81862: LD_ADDR_VAR 0 8
81866: PUSH
81867: LD_VAR 0 2
81871: PPUSH
81872: LD_VAR 0 3
81876: PPUSH
81877: LD_VAR 0 4
81881: PPUSH
81882: CALL 54589 0 3
81886: ST_TO_ADDR
// if not tmp then
81887: LD_VAR 0 8
81891: NOT
81892: IFFALSE 81896
// exit ;
81894: GO 82035
// for i in tmp do
81896: LD_ADDR_VAR 0 7
81900: PUSH
81901: LD_VAR 0 8
81905: PUSH
81906: FOR_IN
81907: IFFALSE 82033
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81909: LD_ADDR_EXP 63
81913: PUSH
81914: LD_EXP 63
81918: PPUSH
81919: LD_VAR 0 1
81923: PPUSH
81924: LD_EXP 63
81928: PUSH
81929: LD_VAR 0 1
81933: ARRAY
81934: PPUSH
81935: LD_EXP 63
81939: PUSH
81940: LD_VAR 0 1
81944: ARRAY
81945: PUSH
81946: LD_INT 1
81948: PLUS
81949: PPUSH
81950: LD_VAR 0 5
81954: PUSH
81955: LD_INT 1
81957: ARRAY
81958: PUSH
81959: LD_VAR 0 7
81963: PUSH
81964: LD_INT 1
81966: ARRAY
81967: PUSH
81968: LD_VAR 0 7
81972: PUSH
81973: LD_INT 2
81975: ARRAY
81976: PUSH
81977: LD_VAR 0 7
81981: PUSH
81982: LD_INT 3
81984: ARRAY
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: PPUSH
81992: CALL_OW 2
81996: PPUSH
81997: CALL_OW 1
82001: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82002: LD_ADDR_VAR 0 5
82006: PUSH
82007: LD_VAR 0 5
82011: PPUSH
82012: LD_INT 1
82014: PPUSH
82015: CALL_OW 3
82019: ST_TO_ADDR
// if not ext_list then
82020: LD_VAR 0 5
82024: NOT
82025: IFFALSE 82031
// exit ;
82027: POP
82028: POP
82029: GO 82035
// end ;
82031: GO 81906
82033: POP
82034: POP
// end ;
82035: LD_VAR 0 6
82039: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82040: LD_INT 0
82042: PPUSH
// if not mc_bases or not base or not weapon_list then
82043: LD_EXP 58
82047: NOT
82048: PUSH
82049: LD_VAR 0 1
82053: NOT
82054: OR
82055: PUSH
82056: LD_VAR 0 2
82060: NOT
82061: OR
82062: IFFALSE 82066
// exit ;
82064: GO 82091
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82066: LD_ADDR_EXP 97
82070: PUSH
82071: LD_EXP 97
82075: PPUSH
82076: LD_VAR 0 1
82080: PPUSH
82081: LD_VAR 0 2
82085: PPUSH
82086: CALL_OW 1
82090: ST_TO_ADDR
// end ;
82091: LD_VAR 0 3
82095: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82096: LD_INT 0
82098: PPUSH
// if not mc_bases or not base or not tech_list then
82099: LD_EXP 58
82103: NOT
82104: PUSH
82105: LD_VAR 0 1
82109: NOT
82110: OR
82111: PUSH
82112: LD_VAR 0 2
82116: NOT
82117: OR
82118: IFFALSE 82122
// exit ;
82120: GO 82147
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82122: LD_ADDR_EXP 85
82126: PUSH
82127: LD_EXP 85
82131: PPUSH
82132: LD_VAR 0 1
82136: PPUSH
82137: LD_VAR 0 2
82141: PPUSH
82142: CALL_OW 1
82146: ST_TO_ADDR
// end ;
82147: LD_VAR 0 3
82151: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82152: LD_INT 0
82154: PPUSH
// if not mc_bases or not parking_area or not base then
82155: LD_EXP 58
82159: NOT
82160: PUSH
82161: LD_VAR 0 2
82165: NOT
82166: OR
82167: PUSH
82168: LD_VAR 0 1
82172: NOT
82173: OR
82174: IFFALSE 82178
// exit ;
82176: GO 82203
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82178: LD_ADDR_EXP 82
82182: PUSH
82183: LD_EXP 82
82187: PPUSH
82188: LD_VAR 0 1
82192: PPUSH
82193: LD_VAR 0 2
82197: PPUSH
82198: CALL_OW 1
82202: ST_TO_ADDR
// end ;
82203: LD_VAR 0 3
82207: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82208: LD_INT 0
82210: PPUSH
// if not mc_bases or not base or not scan_area then
82211: LD_EXP 58
82215: NOT
82216: PUSH
82217: LD_VAR 0 1
82221: NOT
82222: OR
82223: PUSH
82224: LD_VAR 0 2
82228: NOT
82229: OR
82230: IFFALSE 82234
// exit ;
82232: GO 82259
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82234: LD_ADDR_EXP 83
82238: PUSH
82239: LD_EXP 83
82243: PPUSH
82244: LD_VAR 0 1
82248: PPUSH
82249: LD_VAR 0 2
82253: PPUSH
82254: CALL_OW 1
82258: ST_TO_ADDR
// end ;
82259: LD_VAR 0 3
82263: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82264: LD_INT 0
82266: PPUSH
82267: PPUSH
// if not mc_bases or not base then
82268: LD_EXP 58
82272: NOT
82273: PUSH
82274: LD_VAR 0 1
82278: NOT
82279: OR
82280: IFFALSE 82284
// exit ;
82282: GO 82348
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82284: LD_ADDR_VAR 0 3
82288: PUSH
82289: LD_INT 1
82291: PUSH
82292: LD_INT 2
82294: PUSH
82295: LD_INT 3
82297: PUSH
82298: LD_INT 4
82300: PUSH
82301: LD_INT 11
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82311: LD_ADDR_EXP 85
82315: PUSH
82316: LD_EXP 85
82320: PPUSH
82321: LD_VAR 0 1
82325: PPUSH
82326: LD_EXP 85
82330: PUSH
82331: LD_VAR 0 1
82335: ARRAY
82336: PUSH
82337: LD_VAR 0 3
82341: DIFF
82342: PPUSH
82343: CALL_OW 1
82347: ST_TO_ADDR
// end ;
82348: LD_VAR 0 2
82352: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82353: LD_INT 0
82355: PPUSH
// result := mc_vehicles [ base ] ;
82356: LD_ADDR_VAR 0 3
82360: PUSH
82361: LD_EXP 77
82365: PUSH
82366: LD_VAR 0 1
82370: ARRAY
82371: ST_TO_ADDR
// if onlyCombat then
82372: LD_VAR 0 2
82376: IFFALSE 82541
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82378: LD_ADDR_VAR 0 3
82382: PUSH
82383: LD_VAR 0 3
82387: PUSH
82388: LD_VAR 0 3
82392: PPUSH
82393: LD_INT 2
82395: PUSH
82396: LD_INT 34
82398: PUSH
82399: LD_INT 12
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 34
82408: PUSH
82409: LD_INT 51
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 34
82418: PUSH
82419: LD_EXP 102
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 34
82430: PUSH
82431: LD_INT 32
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 34
82440: PUSH
82441: LD_INT 13
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 34
82450: PUSH
82451: LD_INT 52
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PUSH
82458: LD_INT 34
82460: PUSH
82461: LD_INT 14
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 34
82470: PUSH
82471: LD_INT 53
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 34
82480: PUSH
82481: LD_EXP 101
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 34
82492: PUSH
82493: LD_INT 31
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 34
82502: PUSH
82503: LD_INT 48
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 34
82512: PUSH
82513: LD_INT 8
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: PPUSH
82535: CALL_OW 72
82539: DIFF
82540: ST_TO_ADDR
// end ; end_of_file
82541: LD_VAR 0 3
82545: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82546: LD_INT 0
82548: PPUSH
82549: PPUSH
82550: PPUSH
// if not mc_bases or not skirmish then
82551: LD_EXP 58
82555: NOT
82556: PUSH
82557: LD_EXP 56
82561: NOT
82562: OR
82563: IFFALSE 82567
// exit ;
82565: GO 82732
// for i = 1 to mc_bases do
82567: LD_ADDR_VAR 0 4
82571: PUSH
82572: DOUBLE
82573: LD_INT 1
82575: DEC
82576: ST_TO_ADDR
82577: LD_EXP 58
82581: PUSH
82582: FOR_TO
82583: IFFALSE 82730
// begin if sci in mc_bases [ i ] then
82585: LD_VAR 0 2
82589: PUSH
82590: LD_EXP 58
82594: PUSH
82595: LD_VAR 0 4
82599: ARRAY
82600: IN
82601: IFFALSE 82728
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82603: LD_ADDR_EXP 87
82607: PUSH
82608: LD_EXP 87
82612: PPUSH
82613: LD_VAR 0 4
82617: PUSH
82618: LD_EXP 87
82622: PUSH
82623: LD_VAR 0 4
82627: ARRAY
82628: PUSH
82629: LD_INT 1
82631: PLUS
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PPUSH
82637: LD_VAR 0 1
82641: PPUSH
82642: CALL 21211 0 3
82646: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82647: LD_ADDR_VAR 0 5
82651: PUSH
82652: LD_EXP 58
82656: PUSH
82657: LD_VAR 0 4
82661: ARRAY
82662: PPUSH
82663: LD_INT 2
82665: PUSH
82666: LD_INT 30
82668: PUSH
82669: LD_INT 0
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 30
82678: PUSH
82679: LD_INT 1
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: LIST
82690: PPUSH
82691: CALL_OW 72
82695: PPUSH
82696: LD_VAR 0 1
82700: PPUSH
82701: CALL_OW 74
82705: ST_TO_ADDR
// if tmp then
82706: LD_VAR 0 5
82710: IFFALSE 82726
// ComStandNearbyBuilding ( ape , tmp ) ;
82712: LD_VAR 0 1
82716: PPUSH
82717: LD_VAR 0 5
82721: PPUSH
82722: CALL 15503 0 2
// break ;
82726: GO 82730
// end ; end ;
82728: GO 82582
82730: POP
82731: POP
// end ;
82732: LD_VAR 0 3
82736: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82737: LD_INT 0
82739: PPUSH
82740: PPUSH
82741: PPUSH
// if not mc_bases or not skirmish then
82742: LD_EXP 58
82746: NOT
82747: PUSH
82748: LD_EXP 56
82752: NOT
82753: OR
82754: IFFALSE 82758
// exit ;
82756: GO 82847
// for i = 1 to mc_bases do
82758: LD_ADDR_VAR 0 4
82762: PUSH
82763: DOUBLE
82764: LD_INT 1
82766: DEC
82767: ST_TO_ADDR
82768: LD_EXP 58
82772: PUSH
82773: FOR_TO
82774: IFFALSE 82845
// begin if building in mc_busy_turret_list [ i ] then
82776: LD_VAR 0 1
82780: PUSH
82781: LD_EXP 68
82785: PUSH
82786: LD_VAR 0 4
82790: ARRAY
82791: IN
82792: IFFALSE 82843
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82794: LD_ADDR_VAR 0 5
82798: PUSH
82799: LD_EXP 68
82803: PUSH
82804: LD_VAR 0 4
82808: ARRAY
82809: PUSH
82810: LD_VAR 0 1
82814: DIFF
82815: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82816: LD_ADDR_EXP 68
82820: PUSH
82821: LD_EXP 68
82825: PPUSH
82826: LD_VAR 0 4
82830: PPUSH
82831: LD_VAR 0 5
82835: PPUSH
82836: CALL_OW 1
82840: ST_TO_ADDR
// break ;
82841: GO 82845
// end ; end ;
82843: GO 82773
82845: POP
82846: POP
// end ;
82847: LD_VAR 0 3
82851: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82852: LD_INT 0
82854: PPUSH
82855: PPUSH
82856: PPUSH
// if not mc_bases or not skirmish then
82857: LD_EXP 58
82861: NOT
82862: PUSH
82863: LD_EXP 56
82867: NOT
82868: OR
82869: IFFALSE 82873
// exit ;
82871: GO 83072
// for i = 1 to mc_bases do
82873: LD_ADDR_VAR 0 5
82877: PUSH
82878: DOUBLE
82879: LD_INT 1
82881: DEC
82882: ST_TO_ADDR
82883: LD_EXP 58
82887: PUSH
82888: FOR_TO
82889: IFFALSE 83070
// if building in mc_bases [ i ] then
82891: LD_VAR 0 1
82895: PUSH
82896: LD_EXP 58
82900: PUSH
82901: LD_VAR 0 5
82905: ARRAY
82906: IN
82907: IFFALSE 83068
// begin tmp := mc_bases [ i ] diff building ;
82909: LD_ADDR_VAR 0 6
82913: PUSH
82914: LD_EXP 58
82918: PUSH
82919: LD_VAR 0 5
82923: ARRAY
82924: PUSH
82925: LD_VAR 0 1
82929: DIFF
82930: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82931: LD_ADDR_EXP 58
82935: PUSH
82936: LD_EXP 58
82940: PPUSH
82941: LD_VAR 0 5
82945: PPUSH
82946: LD_VAR 0 6
82950: PPUSH
82951: CALL_OW 1
82955: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82956: LD_VAR 0 1
82960: PUSH
82961: LD_EXP 66
82965: PUSH
82966: LD_VAR 0 5
82970: ARRAY
82971: IN
82972: IFFALSE 83011
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82974: LD_ADDR_EXP 66
82978: PUSH
82979: LD_EXP 66
82983: PPUSH
82984: LD_VAR 0 5
82988: PPUSH
82989: LD_EXP 66
82993: PUSH
82994: LD_VAR 0 5
82998: ARRAY
82999: PUSH
83000: LD_VAR 0 1
83004: DIFF
83005: PPUSH
83006: CALL_OW 1
83010: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83011: LD_VAR 0 1
83015: PUSH
83016: LD_EXP 67
83020: PUSH
83021: LD_VAR 0 5
83025: ARRAY
83026: IN
83027: IFFALSE 83066
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83029: LD_ADDR_EXP 67
83033: PUSH
83034: LD_EXP 67
83038: PPUSH
83039: LD_VAR 0 5
83043: PPUSH
83044: LD_EXP 67
83048: PUSH
83049: LD_VAR 0 5
83053: ARRAY
83054: PUSH
83055: LD_VAR 0 1
83059: DIFF
83060: PPUSH
83061: CALL_OW 1
83065: ST_TO_ADDR
// break ;
83066: GO 83070
// end ;
83068: GO 82888
83070: POP
83071: POP
// end ;
83072: LD_VAR 0 4
83076: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83077: LD_INT 0
83079: PPUSH
83080: PPUSH
83081: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83082: LD_EXP 58
83086: NOT
83087: PUSH
83088: LD_EXP 56
83092: NOT
83093: OR
83094: PUSH
83095: LD_VAR 0 3
83099: PUSH
83100: LD_EXP 84
83104: IN
83105: NOT
83106: OR
83107: IFFALSE 83111
// exit ;
83109: GO 83234
// for i = 1 to mc_vehicles do
83111: LD_ADDR_VAR 0 6
83115: PUSH
83116: DOUBLE
83117: LD_INT 1
83119: DEC
83120: ST_TO_ADDR
83121: LD_EXP 77
83125: PUSH
83126: FOR_TO
83127: IFFALSE 83232
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83129: LD_VAR 0 2
83133: PUSH
83134: LD_EXP 77
83138: PUSH
83139: LD_VAR 0 6
83143: ARRAY
83144: IN
83145: PUSH
83146: LD_VAR 0 1
83150: PUSH
83151: LD_EXP 77
83155: PUSH
83156: LD_VAR 0 6
83160: ARRAY
83161: IN
83162: OR
83163: IFFALSE 83230
// begin tmp := mc_vehicles [ i ] diff old ;
83165: LD_ADDR_VAR 0 7
83169: PUSH
83170: LD_EXP 77
83174: PUSH
83175: LD_VAR 0 6
83179: ARRAY
83180: PUSH
83181: LD_VAR 0 2
83185: DIFF
83186: ST_TO_ADDR
// tmp := tmp diff new ;
83187: LD_ADDR_VAR 0 7
83191: PUSH
83192: LD_VAR 0 7
83196: PUSH
83197: LD_VAR 0 1
83201: DIFF
83202: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83203: LD_ADDR_EXP 77
83207: PUSH
83208: LD_EXP 77
83212: PPUSH
83213: LD_VAR 0 6
83217: PPUSH
83218: LD_VAR 0 7
83222: PPUSH
83223: CALL_OW 1
83227: ST_TO_ADDR
// break ;
83228: GO 83232
// end ;
83230: GO 83126
83232: POP
83233: POP
// end ;
83234: LD_VAR 0 5
83238: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83239: LD_INT 0
83241: PPUSH
83242: PPUSH
83243: PPUSH
83244: PPUSH
// if not mc_bases or not skirmish then
83245: LD_EXP 58
83249: NOT
83250: PUSH
83251: LD_EXP 56
83255: NOT
83256: OR
83257: IFFALSE 83261
// exit ;
83259: GO 83638
// side := GetSide ( vehicle ) ;
83261: LD_ADDR_VAR 0 5
83265: PUSH
83266: LD_VAR 0 1
83270: PPUSH
83271: CALL_OW 255
83275: ST_TO_ADDR
// for i = 1 to mc_bases do
83276: LD_ADDR_VAR 0 4
83280: PUSH
83281: DOUBLE
83282: LD_INT 1
83284: DEC
83285: ST_TO_ADDR
83286: LD_EXP 58
83290: PUSH
83291: FOR_TO
83292: IFFALSE 83636
// begin if factory in mc_bases [ i ] then
83294: LD_VAR 0 2
83298: PUSH
83299: LD_EXP 58
83303: PUSH
83304: LD_VAR 0 4
83308: ARRAY
83309: IN
83310: IFFALSE 83634
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83312: LD_EXP 80
83316: PUSH
83317: LD_VAR 0 4
83321: ARRAY
83322: PUSH
83323: LD_EXP 69
83327: PUSH
83328: LD_VAR 0 4
83332: ARRAY
83333: LESS
83334: PUSH
83335: LD_VAR 0 1
83339: PPUSH
83340: CALL_OW 264
83344: PUSH
83345: LD_INT 31
83347: PUSH
83348: LD_INT 32
83350: PUSH
83351: LD_INT 51
83353: PUSH
83354: LD_EXP 102
83358: PUSH
83359: LD_INT 12
83361: PUSH
83362: LD_INT 30
83364: PUSH
83365: LD_EXP 101
83369: PUSH
83370: LD_INT 11
83372: PUSH
83373: LD_INT 53
83375: PUSH
83376: LD_INT 14
83378: PUSH
83379: LD_EXP 105
83383: PUSH
83384: LD_INT 29
83386: PUSH
83387: LD_EXP 103
83391: PUSH
83392: LD_INT 13
83394: PUSH
83395: LD_INT 52
83397: PUSH
83398: LD_INT 48
83400: PUSH
83401: LD_INT 8
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: IN
83423: NOT
83424: AND
83425: IFFALSE 83473
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83427: LD_ADDR_EXP 80
83431: PUSH
83432: LD_EXP 80
83436: PPUSH
83437: LD_VAR 0 4
83441: PUSH
83442: LD_EXP 80
83446: PUSH
83447: LD_VAR 0 4
83451: ARRAY
83452: PUSH
83453: LD_INT 1
83455: PLUS
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PPUSH
83461: LD_VAR 0 1
83465: PPUSH
83466: CALL 21211 0 3
83470: ST_TO_ADDR
83471: GO 83517
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83473: LD_ADDR_EXP 77
83477: PUSH
83478: LD_EXP 77
83482: PPUSH
83483: LD_VAR 0 4
83487: PUSH
83488: LD_EXP 77
83492: PUSH
83493: LD_VAR 0 4
83497: ARRAY
83498: PUSH
83499: LD_INT 1
83501: PLUS
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PPUSH
83507: LD_VAR 0 1
83511: PPUSH
83512: CALL 21211 0 3
83516: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83517: LD_VAR 0 1
83521: PPUSH
83522: CALL_OW 263
83526: PUSH
83527: LD_INT 2
83529: EQUAL
83530: IFFALSE 83550
// begin repeat wait ( 0 0$1 ) ;
83532: LD_INT 35
83534: PPUSH
83535: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83539: LD_VAR 0 1
83543: PPUSH
83544: CALL_OW 312
83548: IFFALSE 83532
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83550: LD_VAR 0 1
83554: PPUSH
83555: LD_EXP 82
83559: PUSH
83560: LD_VAR 0 4
83564: ARRAY
83565: PPUSH
83566: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83570: LD_VAR 0 1
83574: PPUSH
83575: CALL_OW 263
83579: PUSH
83580: LD_INT 1
83582: NONEQUAL
83583: IFFALSE 83587
// break ;
83585: GO 83636
// repeat wait ( 0 0$1 ) ;
83587: LD_INT 35
83589: PPUSH
83590: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83594: LD_VAR 0 1
83598: PPUSH
83599: LD_EXP 82
83603: PUSH
83604: LD_VAR 0 4
83608: ARRAY
83609: PPUSH
83610: CALL_OW 308
83614: IFFALSE 83587
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83616: LD_VAR 0 1
83620: PPUSH
83621: CALL_OW 311
83625: PPUSH
83626: CALL_OW 121
// exit ;
83630: POP
83631: POP
83632: GO 83638
// end ; end ;
83634: GO 83291
83636: POP
83637: POP
// end ;
83638: LD_VAR 0 3
83642: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83643: LD_INT 0
83645: PPUSH
83646: PPUSH
83647: PPUSH
83648: PPUSH
// if not mc_bases or not skirmish then
83649: LD_EXP 58
83653: NOT
83654: PUSH
83655: LD_EXP 56
83659: NOT
83660: OR
83661: IFFALSE 83665
// exit ;
83663: GO 84018
// repeat wait ( 0 0$1 ) ;
83665: LD_INT 35
83667: PPUSH
83668: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83672: LD_VAR 0 2
83676: PPUSH
83677: LD_VAR 0 3
83681: PPUSH
83682: CALL_OW 284
83686: IFFALSE 83665
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83688: LD_VAR 0 2
83692: PPUSH
83693: LD_VAR 0 3
83697: PPUSH
83698: CALL_OW 283
83702: PUSH
83703: LD_INT 4
83705: EQUAL
83706: IFFALSE 83710
// exit ;
83708: GO 84018
// for i = 1 to mc_bases do
83710: LD_ADDR_VAR 0 7
83714: PUSH
83715: DOUBLE
83716: LD_INT 1
83718: DEC
83719: ST_TO_ADDR
83720: LD_EXP 58
83724: PUSH
83725: FOR_TO
83726: IFFALSE 84016
// begin if mc_crates_area [ i ] then
83728: LD_EXP 76
83732: PUSH
83733: LD_VAR 0 7
83737: ARRAY
83738: IFFALSE 83849
// for j in mc_crates_area [ i ] do
83740: LD_ADDR_VAR 0 8
83744: PUSH
83745: LD_EXP 76
83749: PUSH
83750: LD_VAR 0 7
83754: ARRAY
83755: PUSH
83756: FOR_IN
83757: IFFALSE 83847
// if InArea ( x , y , j ) then
83759: LD_VAR 0 2
83763: PPUSH
83764: LD_VAR 0 3
83768: PPUSH
83769: LD_VAR 0 8
83773: PPUSH
83774: CALL_OW 309
83778: IFFALSE 83845
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83780: LD_ADDR_EXP 74
83784: PUSH
83785: LD_EXP 74
83789: PPUSH
83790: LD_VAR 0 7
83794: PUSH
83795: LD_EXP 74
83799: PUSH
83800: LD_VAR 0 7
83804: ARRAY
83805: PUSH
83806: LD_INT 1
83808: PLUS
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PPUSH
83814: LD_VAR 0 4
83818: PUSH
83819: LD_VAR 0 2
83823: PUSH
83824: LD_VAR 0 3
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: LIST
83833: PPUSH
83834: CALL 21211 0 3
83838: ST_TO_ADDR
// exit ;
83839: POP
83840: POP
83841: POP
83842: POP
83843: GO 84018
// end ;
83845: GO 83756
83847: POP
83848: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83849: LD_ADDR_VAR 0 9
83853: PUSH
83854: LD_EXP 58
83858: PUSH
83859: LD_VAR 0 7
83863: ARRAY
83864: PPUSH
83865: LD_INT 2
83867: PUSH
83868: LD_INT 30
83870: PUSH
83871: LD_INT 0
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 30
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: LIST
83892: PPUSH
83893: CALL_OW 72
83897: ST_TO_ADDR
// if not depot then
83898: LD_VAR 0 9
83902: NOT
83903: IFFALSE 83907
// continue ;
83905: GO 83725
// for j in depot do
83907: LD_ADDR_VAR 0 8
83911: PUSH
83912: LD_VAR 0 9
83916: PUSH
83917: FOR_IN
83918: IFFALSE 84012
// if GetDistUnitXY ( j , x , y ) < 30 then
83920: LD_VAR 0 8
83924: PPUSH
83925: LD_VAR 0 2
83929: PPUSH
83930: LD_VAR 0 3
83934: PPUSH
83935: CALL_OW 297
83939: PUSH
83940: LD_INT 30
83942: LESS
83943: IFFALSE 84010
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83945: LD_ADDR_EXP 74
83949: PUSH
83950: LD_EXP 74
83954: PPUSH
83955: LD_VAR 0 7
83959: PUSH
83960: LD_EXP 74
83964: PUSH
83965: LD_VAR 0 7
83969: ARRAY
83970: PUSH
83971: LD_INT 1
83973: PLUS
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PPUSH
83979: LD_VAR 0 4
83983: PUSH
83984: LD_VAR 0 2
83988: PUSH
83989: LD_VAR 0 3
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: LIST
83998: PPUSH
83999: CALL 21211 0 3
84003: ST_TO_ADDR
// exit ;
84004: POP
84005: POP
84006: POP
84007: POP
84008: GO 84018
// end ;
84010: GO 83917
84012: POP
84013: POP
// end ;
84014: GO 83725
84016: POP
84017: POP
// end ;
84018: LD_VAR 0 6
84022: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84023: LD_INT 0
84025: PPUSH
84026: PPUSH
84027: PPUSH
84028: PPUSH
// if not mc_bases or not skirmish then
84029: LD_EXP 58
84033: NOT
84034: PUSH
84035: LD_EXP 56
84039: NOT
84040: OR
84041: IFFALSE 84045
// exit ;
84043: GO 84322
// side := GetSide ( lab ) ;
84045: LD_ADDR_VAR 0 4
84049: PUSH
84050: LD_VAR 0 2
84054: PPUSH
84055: CALL_OW 255
84059: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84060: LD_VAR 0 4
84064: PUSH
84065: LD_EXP 84
84069: IN
84070: NOT
84071: PUSH
84072: LD_EXP 85
84076: NOT
84077: OR
84078: PUSH
84079: LD_EXP 58
84083: NOT
84084: OR
84085: IFFALSE 84089
// exit ;
84087: GO 84322
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84089: LD_ADDR_EXP 85
84093: PUSH
84094: LD_EXP 85
84098: PPUSH
84099: LD_VAR 0 4
84103: PPUSH
84104: LD_EXP 85
84108: PUSH
84109: LD_VAR 0 4
84113: ARRAY
84114: PUSH
84115: LD_VAR 0 1
84119: DIFF
84120: PPUSH
84121: CALL_OW 1
84125: ST_TO_ADDR
// for i = 1 to mc_bases do
84126: LD_ADDR_VAR 0 5
84130: PUSH
84131: DOUBLE
84132: LD_INT 1
84134: DEC
84135: ST_TO_ADDR
84136: LD_EXP 58
84140: PUSH
84141: FOR_TO
84142: IFFALSE 84320
// begin if lab in mc_bases [ i ] then
84144: LD_VAR 0 2
84148: PUSH
84149: LD_EXP 58
84153: PUSH
84154: LD_VAR 0 5
84158: ARRAY
84159: IN
84160: IFFALSE 84318
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84162: LD_VAR 0 1
84166: PUSH
84167: LD_INT 11
84169: PUSH
84170: LD_INT 4
84172: PUSH
84173: LD_INT 3
84175: PUSH
84176: LD_INT 2
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: IN
84185: PUSH
84186: LD_EXP 88
84190: PUSH
84191: LD_VAR 0 5
84195: ARRAY
84196: AND
84197: IFFALSE 84318
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84199: LD_ADDR_VAR 0 6
84203: PUSH
84204: LD_EXP 88
84208: PUSH
84209: LD_VAR 0 5
84213: ARRAY
84214: PUSH
84215: LD_INT 1
84217: ARRAY
84218: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84219: LD_ADDR_EXP 88
84223: PUSH
84224: LD_EXP 88
84228: PPUSH
84229: LD_VAR 0 5
84233: PPUSH
84234: EMPTY
84235: PPUSH
84236: CALL_OW 1
84240: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84241: LD_VAR 0 6
84245: PPUSH
84246: LD_INT 0
84248: PPUSH
84249: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84253: LD_VAR 0 6
84257: PPUSH
84258: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84262: LD_ADDR_EXP 87
84266: PUSH
84267: LD_EXP 87
84271: PPUSH
84272: LD_VAR 0 5
84276: PPUSH
84277: LD_EXP 87
84281: PUSH
84282: LD_VAR 0 5
84286: ARRAY
84287: PPUSH
84288: LD_INT 1
84290: PPUSH
84291: LD_VAR 0 6
84295: PPUSH
84296: CALL_OW 2
84300: PPUSH
84301: CALL_OW 1
84305: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84306: LD_VAR 0 5
84310: PPUSH
84311: LD_INT 112
84313: PPUSH
84314: CALL 61214 0 2
// end ; end ; end ;
84318: GO 84141
84320: POP
84321: POP
// end ;
84322: LD_VAR 0 3
84326: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84327: LD_INT 0
84329: PPUSH
84330: PPUSH
84331: PPUSH
84332: PPUSH
84333: PPUSH
84334: PPUSH
84335: PPUSH
84336: PPUSH
// if not mc_bases or not skirmish then
84337: LD_EXP 58
84341: NOT
84342: PUSH
84343: LD_EXP 56
84347: NOT
84348: OR
84349: IFFALSE 84353
// exit ;
84351: GO 85724
// for i = 1 to mc_bases do
84353: LD_ADDR_VAR 0 3
84357: PUSH
84358: DOUBLE
84359: LD_INT 1
84361: DEC
84362: ST_TO_ADDR
84363: LD_EXP 58
84367: PUSH
84368: FOR_TO
84369: IFFALSE 85722
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84371: LD_VAR 0 1
84375: PUSH
84376: LD_EXP 58
84380: PUSH
84381: LD_VAR 0 3
84385: ARRAY
84386: IN
84387: PUSH
84388: LD_VAR 0 1
84392: PUSH
84393: LD_EXP 65
84397: PUSH
84398: LD_VAR 0 3
84402: ARRAY
84403: IN
84404: OR
84405: PUSH
84406: LD_VAR 0 1
84410: PUSH
84411: LD_EXP 80
84415: PUSH
84416: LD_VAR 0 3
84420: ARRAY
84421: IN
84422: OR
84423: PUSH
84424: LD_VAR 0 1
84428: PUSH
84429: LD_EXP 77
84433: PUSH
84434: LD_VAR 0 3
84438: ARRAY
84439: IN
84440: OR
84441: PUSH
84442: LD_VAR 0 1
84446: PUSH
84447: LD_EXP 87
84451: PUSH
84452: LD_VAR 0 3
84456: ARRAY
84457: IN
84458: OR
84459: PUSH
84460: LD_VAR 0 1
84464: PUSH
84465: LD_EXP 88
84469: PUSH
84470: LD_VAR 0 3
84474: ARRAY
84475: IN
84476: OR
84477: IFFALSE 85720
// begin if un in mc_ape [ i ] then
84479: LD_VAR 0 1
84483: PUSH
84484: LD_EXP 87
84488: PUSH
84489: LD_VAR 0 3
84493: ARRAY
84494: IN
84495: IFFALSE 84534
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84497: LD_ADDR_EXP 87
84501: PUSH
84502: LD_EXP 87
84506: PPUSH
84507: LD_VAR 0 3
84511: PPUSH
84512: LD_EXP 87
84516: PUSH
84517: LD_VAR 0 3
84521: ARRAY
84522: PUSH
84523: LD_VAR 0 1
84527: DIFF
84528: PPUSH
84529: CALL_OW 1
84533: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84534: LD_VAR 0 1
84538: PUSH
84539: LD_EXP 88
84543: PUSH
84544: LD_VAR 0 3
84548: ARRAY
84549: IN
84550: IFFALSE 84574
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84552: LD_ADDR_EXP 88
84556: PUSH
84557: LD_EXP 88
84561: PPUSH
84562: LD_VAR 0 3
84566: PPUSH
84567: EMPTY
84568: PPUSH
84569: CALL_OW 1
84573: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84574: LD_VAR 0 1
84578: PPUSH
84579: CALL_OW 247
84583: PUSH
84584: LD_INT 2
84586: EQUAL
84587: PUSH
84588: LD_VAR 0 1
84592: PPUSH
84593: CALL_OW 110
84597: PUSH
84598: LD_INT 20
84600: EQUAL
84601: PUSH
84602: LD_VAR 0 1
84606: PUSH
84607: LD_EXP 80
84611: PUSH
84612: LD_VAR 0 3
84616: ARRAY
84617: IN
84618: OR
84619: PUSH
84620: LD_VAR 0 1
84624: PPUSH
84625: CALL_OW 264
84629: PUSH
84630: LD_INT 12
84632: PUSH
84633: LD_INT 51
84635: PUSH
84636: LD_EXP 102
84640: PUSH
84641: LD_INT 32
84643: PUSH
84644: LD_INT 13
84646: PUSH
84647: LD_INT 52
84649: PUSH
84650: LD_INT 31
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: IN
84662: OR
84663: AND
84664: IFFALSE 84972
// begin if un in mc_defender [ i ] then
84666: LD_VAR 0 1
84670: PUSH
84671: LD_EXP 80
84675: PUSH
84676: LD_VAR 0 3
84680: ARRAY
84681: IN
84682: IFFALSE 84721
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84684: LD_ADDR_EXP 80
84688: PUSH
84689: LD_EXP 80
84693: PPUSH
84694: LD_VAR 0 3
84698: PPUSH
84699: LD_EXP 80
84703: PUSH
84704: LD_VAR 0 3
84708: ARRAY
84709: PUSH
84710: LD_VAR 0 1
84714: DIFF
84715: PPUSH
84716: CALL_OW 1
84720: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84721: LD_ADDR_VAR 0 8
84725: PUSH
84726: LD_VAR 0 3
84730: PPUSH
84731: LD_INT 3
84733: PPUSH
84734: CALL 81390 0 2
84738: ST_TO_ADDR
// if fac then
84739: LD_VAR 0 8
84743: IFFALSE 84972
// begin for j in fac do
84745: LD_ADDR_VAR 0 4
84749: PUSH
84750: LD_VAR 0 8
84754: PUSH
84755: FOR_IN
84756: IFFALSE 84970
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84758: LD_ADDR_VAR 0 9
84762: PUSH
84763: LD_VAR 0 8
84767: PPUSH
84768: LD_VAR 0 1
84772: PPUSH
84773: CALL_OW 265
84777: PPUSH
84778: LD_VAR 0 1
84782: PPUSH
84783: CALL_OW 262
84787: PPUSH
84788: LD_VAR 0 1
84792: PPUSH
84793: CALL_OW 263
84797: PPUSH
84798: LD_VAR 0 1
84802: PPUSH
84803: CALL_OW 264
84807: PPUSH
84808: CALL 18743 0 5
84812: ST_TO_ADDR
// if components then
84813: LD_VAR 0 9
84817: IFFALSE 84968
// begin if GetWeapon ( un ) = ar_control_tower then
84819: LD_VAR 0 1
84823: PPUSH
84824: CALL_OW 264
84828: PUSH
84829: LD_INT 31
84831: EQUAL
84832: IFFALSE 84949
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84834: LD_VAR 0 1
84838: PPUSH
84839: CALL_OW 311
84843: PPUSH
84844: LD_INT 0
84846: PPUSH
84847: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84851: LD_ADDR_EXP 98
84855: PUSH
84856: LD_EXP 98
84860: PPUSH
84861: LD_VAR 0 3
84865: PPUSH
84866: LD_EXP 98
84870: PUSH
84871: LD_VAR 0 3
84875: ARRAY
84876: PUSH
84877: LD_VAR 0 1
84881: PPUSH
84882: CALL_OW 311
84886: DIFF
84887: PPUSH
84888: CALL_OW 1
84892: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84893: LD_ADDR_VAR 0 7
84897: PUSH
84898: LD_EXP 79
84902: PUSH
84903: LD_VAR 0 3
84907: ARRAY
84908: PPUSH
84909: LD_INT 1
84911: PPUSH
84912: LD_VAR 0 9
84916: PPUSH
84917: CALL_OW 2
84921: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84922: LD_ADDR_EXP 79
84926: PUSH
84927: LD_EXP 79
84931: PPUSH
84932: LD_VAR 0 3
84936: PPUSH
84937: LD_VAR 0 7
84941: PPUSH
84942: CALL_OW 1
84946: ST_TO_ADDR
// end else
84947: GO 84966
// MC_InsertProduceList ( i , [ components ] ) ;
84949: LD_VAR 0 3
84953: PPUSH
84954: LD_VAR 0 9
84958: PUSH
84959: EMPTY
84960: LIST
84961: PPUSH
84962: CALL 80935 0 2
// break ;
84966: GO 84970
// end ; end ;
84968: GO 84755
84970: POP
84971: POP
// end ; end ; if GetType ( un ) = unit_building then
84972: LD_VAR 0 1
84976: PPUSH
84977: CALL_OW 247
84981: PUSH
84982: LD_INT 3
84984: EQUAL
84985: IFFALSE 85388
// begin btype := GetBType ( un ) ;
84987: LD_ADDR_VAR 0 5
84991: PUSH
84992: LD_VAR 0 1
84996: PPUSH
84997: CALL_OW 266
85001: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85002: LD_VAR 0 5
85006: PUSH
85007: LD_INT 29
85009: PUSH
85010: LD_INT 30
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: IN
85017: IFFALSE 85090
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85019: LD_VAR 0 1
85023: PPUSH
85024: CALL_OW 250
85028: PPUSH
85029: LD_VAR 0 1
85033: PPUSH
85034: CALL_OW 251
85038: PPUSH
85039: LD_VAR 0 1
85043: PPUSH
85044: CALL_OW 255
85048: PPUSH
85049: CALL_OW 440
85053: NOT
85054: IFFALSE 85090
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85056: LD_VAR 0 1
85060: PPUSH
85061: CALL_OW 250
85065: PPUSH
85066: LD_VAR 0 1
85070: PPUSH
85071: CALL_OW 251
85075: PPUSH
85076: LD_VAR 0 1
85080: PPUSH
85081: CALL_OW 255
85085: PPUSH
85086: CALL_OW 441
// end ; if btype = b_warehouse then
85090: LD_VAR 0 5
85094: PUSH
85095: LD_INT 1
85097: EQUAL
85098: IFFALSE 85116
// begin btype := b_depot ;
85100: LD_ADDR_VAR 0 5
85104: PUSH
85105: LD_INT 0
85107: ST_TO_ADDR
// pos := 1 ;
85108: LD_ADDR_VAR 0 6
85112: PUSH
85113: LD_INT 1
85115: ST_TO_ADDR
// end ; if btype = b_factory then
85116: LD_VAR 0 5
85120: PUSH
85121: LD_INT 3
85123: EQUAL
85124: IFFALSE 85142
// begin btype := b_workshop ;
85126: LD_ADDR_VAR 0 5
85130: PUSH
85131: LD_INT 2
85133: ST_TO_ADDR
// pos := 1 ;
85134: LD_ADDR_VAR 0 6
85138: PUSH
85139: LD_INT 1
85141: ST_TO_ADDR
// end ; if btype = b_barracks then
85142: LD_VAR 0 5
85146: PUSH
85147: LD_INT 5
85149: EQUAL
85150: IFFALSE 85160
// btype := b_armoury ;
85152: LD_ADDR_VAR 0 5
85156: PUSH
85157: LD_INT 4
85159: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85160: LD_VAR 0 5
85164: PUSH
85165: LD_INT 7
85167: PUSH
85168: LD_INT 8
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: IN
85175: IFFALSE 85185
// btype := b_lab ;
85177: LD_ADDR_VAR 0 5
85181: PUSH
85182: LD_INT 6
85184: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85185: LD_ADDR_EXP 63
85189: PUSH
85190: LD_EXP 63
85194: PPUSH
85195: LD_VAR 0 3
85199: PUSH
85200: LD_EXP 63
85204: PUSH
85205: LD_VAR 0 3
85209: ARRAY
85210: PUSH
85211: LD_INT 1
85213: PLUS
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PPUSH
85219: LD_VAR 0 5
85223: PUSH
85224: LD_VAR 0 1
85228: PPUSH
85229: CALL_OW 250
85233: PUSH
85234: LD_VAR 0 1
85238: PPUSH
85239: CALL_OW 251
85243: PUSH
85244: LD_VAR 0 1
85248: PPUSH
85249: CALL_OW 254
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: PPUSH
85260: CALL 21211 0 3
85264: ST_TO_ADDR
// if pos = 1 then
85265: LD_VAR 0 6
85269: PUSH
85270: LD_INT 1
85272: EQUAL
85273: IFFALSE 85388
// begin tmp := mc_build_list [ i ] ;
85275: LD_ADDR_VAR 0 7
85279: PUSH
85280: LD_EXP 63
85284: PUSH
85285: LD_VAR 0 3
85289: ARRAY
85290: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85291: LD_VAR 0 7
85295: PPUSH
85296: LD_INT 2
85298: PUSH
85299: LD_INT 30
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 30
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: LIST
85323: PPUSH
85324: CALL_OW 72
85328: IFFALSE 85338
// pos := 2 ;
85330: LD_ADDR_VAR 0 6
85334: PUSH
85335: LD_INT 2
85337: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85338: LD_ADDR_VAR 0 7
85342: PUSH
85343: LD_VAR 0 7
85347: PPUSH
85348: LD_VAR 0 6
85352: PPUSH
85353: LD_VAR 0 7
85357: PPUSH
85358: CALL 21537 0 3
85362: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85363: LD_ADDR_EXP 63
85367: PUSH
85368: LD_EXP 63
85372: PPUSH
85373: LD_VAR 0 3
85377: PPUSH
85378: LD_VAR 0 7
85382: PPUSH
85383: CALL_OW 1
85387: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85388: LD_VAR 0 1
85392: PUSH
85393: LD_EXP 58
85397: PUSH
85398: LD_VAR 0 3
85402: ARRAY
85403: IN
85404: IFFALSE 85443
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85406: LD_ADDR_EXP 58
85410: PUSH
85411: LD_EXP 58
85415: PPUSH
85416: LD_VAR 0 3
85420: PPUSH
85421: LD_EXP 58
85425: PUSH
85426: LD_VAR 0 3
85430: ARRAY
85431: PUSH
85432: LD_VAR 0 1
85436: DIFF
85437: PPUSH
85438: CALL_OW 1
85442: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85443: LD_VAR 0 1
85447: PUSH
85448: LD_EXP 65
85452: PUSH
85453: LD_VAR 0 3
85457: ARRAY
85458: IN
85459: IFFALSE 85498
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85461: LD_ADDR_EXP 65
85465: PUSH
85466: LD_EXP 65
85470: PPUSH
85471: LD_VAR 0 3
85475: PPUSH
85476: LD_EXP 65
85480: PUSH
85481: LD_VAR 0 3
85485: ARRAY
85486: PUSH
85487: LD_VAR 0 1
85491: DIFF
85492: PPUSH
85493: CALL_OW 1
85497: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85498: LD_VAR 0 1
85502: PUSH
85503: LD_EXP 77
85507: PUSH
85508: LD_VAR 0 3
85512: ARRAY
85513: IN
85514: IFFALSE 85553
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85516: LD_ADDR_EXP 77
85520: PUSH
85521: LD_EXP 77
85525: PPUSH
85526: LD_VAR 0 3
85530: PPUSH
85531: LD_EXP 77
85535: PUSH
85536: LD_VAR 0 3
85540: ARRAY
85541: PUSH
85542: LD_VAR 0 1
85546: DIFF
85547: PPUSH
85548: CALL_OW 1
85552: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85553: LD_VAR 0 1
85557: PUSH
85558: LD_EXP 80
85562: PUSH
85563: LD_VAR 0 3
85567: ARRAY
85568: IN
85569: IFFALSE 85608
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85571: LD_ADDR_EXP 80
85575: PUSH
85576: LD_EXP 80
85580: PPUSH
85581: LD_VAR 0 3
85585: PPUSH
85586: LD_EXP 80
85590: PUSH
85591: LD_VAR 0 3
85595: ARRAY
85596: PUSH
85597: LD_VAR 0 1
85601: DIFF
85602: PPUSH
85603: CALL_OW 1
85607: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85608: LD_VAR 0 1
85612: PUSH
85613: LD_EXP 67
85617: PUSH
85618: LD_VAR 0 3
85622: ARRAY
85623: IN
85624: IFFALSE 85663
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85626: LD_ADDR_EXP 67
85630: PUSH
85631: LD_EXP 67
85635: PPUSH
85636: LD_VAR 0 3
85640: PPUSH
85641: LD_EXP 67
85645: PUSH
85646: LD_VAR 0 3
85650: ARRAY
85651: PUSH
85652: LD_VAR 0 1
85656: DIFF
85657: PPUSH
85658: CALL_OW 1
85662: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85663: LD_VAR 0 1
85667: PUSH
85668: LD_EXP 66
85672: PUSH
85673: LD_VAR 0 3
85677: ARRAY
85678: IN
85679: IFFALSE 85718
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85681: LD_ADDR_EXP 66
85685: PUSH
85686: LD_EXP 66
85690: PPUSH
85691: LD_VAR 0 3
85695: PPUSH
85696: LD_EXP 66
85700: PUSH
85701: LD_VAR 0 3
85705: ARRAY
85706: PUSH
85707: LD_VAR 0 1
85711: DIFF
85712: PPUSH
85713: CALL_OW 1
85717: ST_TO_ADDR
// end ; break ;
85718: GO 85722
// end ;
85720: GO 84368
85722: POP
85723: POP
// end ;
85724: LD_VAR 0 2
85728: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85729: LD_INT 0
85731: PPUSH
85732: PPUSH
85733: PPUSH
// if not mc_bases or not skirmish then
85734: LD_EXP 58
85738: NOT
85739: PUSH
85740: LD_EXP 56
85744: NOT
85745: OR
85746: IFFALSE 85750
// exit ;
85748: GO 85965
// for i = 1 to mc_bases do
85750: LD_ADDR_VAR 0 3
85754: PUSH
85755: DOUBLE
85756: LD_INT 1
85758: DEC
85759: ST_TO_ADDR
85760: LD_EXP 58
85764: PUSH
85765: FOR_TO
85766: IFFALSE 85963
// begin if building in mc_construct_list [ i ] then
85768: LD_VAR 0 1
85772: PUSH
85773: LD_EXP 65
85777: PUSH
85778: LD_VAR 0 3
85782: ARRAY
85783: IN
85784: IFFALSE 85961
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85786: LD_ADDR_EXP 65
85790: PUSH
85791: LD_EXP 65
85795: PPUSH
85796: LD_VAR 0 3
85800: PPUSH
85801: LD_EXP 65
85805: PUSH
85806: LD_VAR 0 3
85810: ARRAY
85811: PUSH
85812: LD_VAR 0 1
85816: DIFF
85817: PPUSH
85818: CALL_OW 1
85822: ST_TO_ADDR
// if building in mc_lab [ i ] then
85823: LD_VAR 0 1
85827: PUSH
85828: LD_EXP 91
85832: PUSH
85833: LD_VAR 0 3
85837: ARRAY
85838: IN
85839: IFFALSE 85894
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85841: LD_ADDR_EXP 92
85845: PUSH
85846: LD_EXP 92
85850: PPUSH
85851: LD_VAR 0 3
85855: PPUSH
85856: LD_EXP 92
85860: PUSH
85861: LD_VAR 0 3
85865: ARRAY
85866: PPUSH
85867: LD_INT 1
85869: PPUSH
85870: LD_EXP 92
85874: PUSH
85875: LD_VAR 0 3
85879: ARRAY
85880: PPUSH
85881: LD_INT 0
85883: PPUSH
85884: CALL 20629 0 4
85888: PPUSH
85889: CALL_OW 1
85893: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85894: LD_VAR 0 1
85898: PUSH
85899: LD_EXP 58
85903: PUSH
85904: LD_VAR 0 3
85908: ARRAY
85909: IN
85910: NOT
85911: IFFALSE 85957
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85913: LD_ADDR_EXP 58
85917: PUSH
85918: LD_EXP 58
85922: PPUSH
85923: LD_VAR 0 3
85927: PUSH
85928: LD_EXP 58
85932: PUSH
85933: LD_VAR 0 3
85937: ARRAY
85938: PUSH
85939: LD_INT 1
85941: PLUS
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PPUSH
85947: LD_VAR 0 1
85951: PPUSH
85952: CALL 21211 0 3
85956: ST_TO_ADDR
// exit ;
85957: POP
85958: POP
85959: GO 85965
// end ; end ;
85961: GO 85765
85963: POP
85964: POP
// end ;
85965: LD_VAR 0 2
85969: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85970: LD_INT 0
85972: PPUSH
85973: PPUSH
85974: PPUSH
85975: PPUSH
85976: PPUSH
85977: PPUSH
85978: PPUSH
// if not mc_bases or not skirmish then
85979: LD_EXP 58
85983: NOT
85984: PUSH
85985: LD_EXP 56
85989: NOT
85990: OR
85991: IFFALSE 85995
// exit ;
85993: GO 86656
// for i = 1 to mc_bases do
85995: LD_ADDR_VAR 0 3
85999: PUSH
86000: DOUBLE
86001: LD_INT 1
86003: DEC
86004: ST_TO_ADDR
86005: LD_EXP 58
86009: PUSH
86010: FOR_TO
86011: IFFALSE 86654
// begin if building in mc_construct_list [ i ] then
86013: LD_VAR 0 1
86017: PUSH
86018: LD_EXP 65
86022: PUSH
86023: LD_VAR 0 3
86027: ARRAY
86028: IN
86029: IFFALSE 86652
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86031: LD_ADDR_EXP 65
86035: PUSH
86036: LD_EXP 65
86040: PPUSH
86041: LD_VAR 0 3
86045: PPUSH
86046: LD_EXP 65
86050: PUSH
86051: LD_VAR 0 3
86055: ARRAY
86056: PUSH
86057: LD_VAR 0 1
86061: DIFF
86062: PPUSH
86063: CALL_OW 1
86067: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86068: LD_ADDR_EXP 58
86072: PUSH
86073: LD_EXP 58
86077: PPUSH
86078: LD_VAR 0 3
86082: PUSH
86083: LD_EXP 58
86087: PUSH
86088: LD_VAR 0 3
86092: ARRAY
86093: PUSH
86094: LD_INT 1
86096: PLUS
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PPUSH
86102: LD_VAR 0 1
86106: PPUSH
86107: CALL 21211 0 3
86111: ST_TO_ADDR
// btype := GetBType ( building ) ;
86112: LD_ADDR_VAR 0 5
86116: PUSH
86117: LD_VAR 0 1
86121: PPUSH
86122: CALL_OW 266
86126: ST_TO_ADDR
// side := GetSide ( building ) ;
86127: LD_ADDR_VAR 0 8
86131: PUSH
86132: LD_VAR 0 1
86136: PPUSH
86137: CALL_OW 255
86141: ST_TO_ADDR
// if btype = b_lab then
86142: LD_VAR 0 5
86146: PUSH
86147: LD_INT 6
86149: EQUAL
86150: IFFALSE 86200
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86152: LD_ADDR_EXP 91
86156: PUSH
86157: LD_EXP 91
86161: PPUSH
86162: LD_VAR 0 3
86166: PUSH
86167: LD_EXP 91
86171: PUSH
86172: LD_VAR 0 3
86176: ARRAY
86177: PUSH
86178: LD_INT 1
86180: PLUS
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PPUSH
86186: LD_VAR 0 1
86190: PPUSH
86191: CALL 21211 0 3
86195: ST_TO_ADDR
// exit ;
86196: POP
86197: POP
86198: GO 86656
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86200: LD_VAR 0 5
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: LD_INT 2
86210: PUSH
86211: LD_INT 4
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: LIST
86218: IN
86219: IFFALSE 86343
// begin if btype = b_armoury then
86221: LD_VAR 0 5
86225: PUSH
86226: LD_INT 4
86228: EQUAL
86229: IFFALSE 86239
// btype := b_barracks ;
86231: LD_ADDR_VAR 0 5
86235: PUSH
86236: LD_INT 5
86238: ST_TO_ADDR
// if btype = b_depot then
86239: LD_VAR 0 5
86243: PUSH
86244: LD_INT 0
86246: EQUAL
86247: IFFALSE 86257
// btype := b_warehouse ;
86249: LD_ADDR_VAR 0 5
86253: PUSH
86254: LD_INT 1
86256: ST_TO_ADDR
// if btype = b_workshop then
86257: LD_VAR 0 5
86261: PUSH
86262: LD_INT 2
86264: EQUAL
86265: IFFALSE 86275
// btype := b_factory ;
86267: LD_ADDR_VAR 0 5
86271: PUSH
86272: LD_INT 3
86274: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86275: LD_VAR 0 5
86279: PPUSH
86280: LD_VAR 0 8
86284: PPUSH
86285: CALL_OW 323
86289: PUSH
86290: LD_INT 1
86292: EQUAL
86293: IFFALSE 86339
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86295: LD_ADDR_EXP 90
86299: PUSH
86300: LD_EXP 90
86304: PPUSH
86305: LD_VAR 0 3
86309: PUSH
86310: LD_EXP 90
86314: PUSH
86315: LD_VAR 0 3
86319: ARRAY
86320: PUSH
86321: LD_INT 1
86323: PLUS
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PPUSH
86329: LD_VAR 0 1
86333: PPUSH
86334: CALL 21211 0 3
86338: ST_TO_ADDR
// exit ;
86339: POP
86340: POP
86341: GO 86656
// end ; if btype in [ b_bunker , b_turret ] then
86343: LD_VAR 0 5
86347: PUSH
86348: LD_INT 32
86350: PUSH
86351: LD_INT 33
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: IN
86358: IFFALSE 86648
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86360: LD_ADDR_EXP 66
86364: PUSH
86365: LD_EXP 66
86369: PPUSH
86370: LD_VAR 0 3
86374: PUSH
86375: LD_EXP 66
86379: PUSH
86380: LD_VAR 0 3
86384: ARRAY
86385: PUSH
86386: LD_INT 1
86388: PLUS
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PPUSH
86394: LD_VAR 0 1
86398: PPUSH
86399: CALL 21211 0 3
86403: ST_TO_ADDR
// if btype = b_bunker then
86404: LD_VAR 0 5
86408: PUSH
86409: LD_INT 32
86411: EQUAL
86412: IFFALSE 86648
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86414: LD_ADDR_EXP 67
86418: PUSH
86419: LD_EXP 67
86423: PPUSH
86424: LD_VAR 0 3
86428: PUSH
86429: LD_EXP 67
86433: PUSH
86434: LD_VAR 0 3
86438: ARRAY
86439: PUSH
86440: LD_INT 1
86442: PLUS
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PPUSH
86448: LD_VAR 0 1
86452: PPUSH
86453: CALL 21211 0 3
86457: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86458: LD_ADDR_VAR 0 6
86462: PUSH
86463: LD_EXP 58
86467: PUSH
86468: LD_VAR 0 3
86472: ARRAY
86473: PPUSH
86474: LD_INT 25
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 3
86486: PUSH
86487: LD_INT 54
86489: PUSH
86490: EMPTY
86491: LIST
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PPUSH
86501: CALL_OW 72
86505: ST_TO_ADDR
// if tmp then
86506: LD_VAR 0 6
86510: IFFALSE 86516
// exit ;
86512: POP
86513: POP
86514: GO 86656
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86516: LD_ADDR_VAR 0 6
86520: PUSH
86521: LD_EXP 58
86525: PUSH
86526: LD_VAR 0 3
86530: ARRAY
86531: PPUSH
86532: LD_INT 2
86534: PUSH
86535: LD_INT 30
86537: PUSH
86538: LD_INT 4
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 30
86547: PUSH
86548: LD_INT 5
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: LIST
86559: PPUSH
86560: CALL_OW 72
86564: ST_TO_ADDR
// if not tmp then
86565: LD_VAR 0 6
86569: NOT
86570: IFFALSE 86576
// exit ;
86572: POP
86573: POP
86574: GO 86656
// for j in tmp do
86576: LD_ADDR_VAR 0 4
86580: PUSH
86581: LD_VAR 0 6
86585: PUSH
86586: FOR_IN
86587: IFFALSE 86646
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86589: LD_ADDR_VAR 0 7
86593: PUSH
86594: LD_VAR 0 4
86598: PPUSH
86599: CALL_OW 313
86603: PPUSH
86604: LD_INT 25
86606: PUSH
86607: LD_INT 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PPUSH
86614: CALL_OW 72
86618: ST_TO_ADDR
// if units then
86619: LD_VAR 0 7
86623: IFFALSE 86644
// begin ComExitBuilding ( units [ 1 ] ) ;
86625: LD_VAR 0 7
86629: PUSH
86630: LD_INT 1
86632: ARRAY
86633: PPUSH
86634: CALL_OW 122
// exit ;
86638: POP
86639: POP
86640: POP
86641: POP
86642: GO 86656
// end ; end ;
86644: GO 86586
86646: POP
86647: POP
// end ; end ; exit ;
86648: POP
86649: POP
86650: GO 86656
// end ; end ;
86652: GO 86010
86654: POP
86655: POP
// end ;
86656: LD_VAR 0 2
86660: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86661: LD_INT 0
86663: PPUSH
86664: PPUSH
86665: PPUSH
86666: PPUSH
86667: PPUSH
86668: PPUSH
86669: PPUSH
// if not mc_bases or not skirmish then
86670: LD_EXP 58
86674: NOT
86675: PUSH
86676: LD_EXP 56
86680: NOT
86681: OR
86682: IFFALSE 86686
// exit ;
86684: GO 86917
// btype := GetBType ( building ) ;
86686: LD_ADDR_VAR 0 6
86690: PUSH
86691: LD_VAR 0 1
86695: PPUSH
86696: CALL_OW 266
86700: ST_TO_ADDR
// x := GetX ( building ) ;
86701: LD_ADDR_VAR 0 7
86705: PUSH
86706: LD_VAR 0 1
86710: PPUSH
86711: CALL_OW 250
86715: ST_TO_ADDR
// y := GetY ( building ) ;
86716: LD_ADDR_VAR 0 8
86720: PUSH
86721: LD_VAR 0 1
86725: PPUSH
86726: CALL_OW 251
86730: ST_TO_ADDR
// d := GetDir ( building ) ;
86731: LD_ADDR_VAR 0 9
86735: PUSH
86736: LD_VAR 0 1
86740: PPUSH
86741: CALL_OW 254
86745: ST_TO_ADDR
// for i = 1 to mc_bases do
86746: LD_ADDR_VAR 0 4
86750: PUSH
86751: DOUBLE
86752: LD_INT 1
86754: DEC
86755: ST_TO_ADDR
86756: LD_EXP 58
86760: PUSH
86761: FOR_TO
86762: IFFALSE 86915
// begin if not mc_build_list [ i ] then
86764: LD_EXP 63
86768: PUSH
86769: LD_VAR 0 4
86773: ARRAY
86774: NOT
86775: IFFALSE 86779
// continue ;
86777: GO 86761
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86779: LD_VAR 0 6
86783: PUSH
86784: LD_VAR 0 7
86788: PUSH
86789: LD_VAR 0 8
86793: PUSH
86794: LD_VAR 0 9
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: PPUSH
86805: LD_EXP 63
86809: PUSH
86810: LD_VAR 0 4
86814: ARRAY
86815: PUSH
86816: LD_INT 1
86818: ARRAY
86819: PPUSH
86820: CALL 27380 0 2
86824: IFFALSE 86913
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86826: LD_ADDR_EXP 63
86830: PUSH
86831: LD_EXP 63
86835: PPUSH
86836: LD_VAR 0 4
86840: PPUSH
86841: LD_EXP 63
86845: PUSH
86846: LD_VAR 0 4
86850: ARRAY
86851: PPUSH
86852: LD_INT 1
86854: PPUSH
86855: CALL_OW 3
86859: PPUSH
86860: CALL_OW 1
86864: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86865: LD_ADDR_EXP 65
86869: PUSH
86870: LD_EXP 65
86874: PPUSH
86875: LD_VAR 0 4
86879: PUSH
86880: LD_EXP 65
86884: PUSH
86885: LD_VAR 0 4
86889: ARRAY
86890: PUSH
86891: LD_INT 1
86893: PLUS
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: PPUSH
86899: LD_VAR 0 1
86903: PPUSH
86904: CALL 21211 0 3
86908: ST_TO_ADDR
// exit ;
86909: POP
86910: POP
86911: GO 86917
// end ; end ;
86913: GO 86761
86915: POP
86916: POP
// end ;
86917: LD_VAR 0 3
86921: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86922: LD_INT 0
86924: PPUSH
86925: PPUSH
86926: PPUSH
// if not mc_bases or not skirmish then
86927: LD_EXP 58
86931: NOT
86932: PUSH
86933: LD_EXP 56
86937: NOT
86938: OR
86939: IFFALSE 86943
// exit ;
86941: GO 87133
// for i = 1 to mc_bases do
86943: LD_ADDR_VAR 0 4
86947: PUSH
86948: DOUBLE
86949: LD_INT 1
86951: DEC
86952: ST_TO_ADDR
86953: LD_EXP 58
86957: PUSH
86958: FOR_TO
86959: IFFALSE 87046
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86961: LD_VAR 0 1
86965: PUSH
86966: LD_EXP 66
86970: PUSH
86971: LD_VAR 0 4
86975: ARRAY
86976: IN
86977: PUSH
86978: LD_VAR 0 1
86982: PUSH
86983: LD_EXP 67
86987: PUSH
86988: LD_VAR 0 4
86992: ARRAY
86993: IN
86994: NOT
86995: AND
86996: IFFALSE 87044
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86998: LD_ADDR_EXP 67
87002: PUSH
87003: LD_EXP 67
87007: PPUSH
87008: LD_VAR 0 4
87012: PUSH
87013: LD_EXP 67
87017: PUSH
87018: LD_VAR 0 4
87022: ARRAY
87023: PUSH
87024: LD_INT 1
87026: PLUS
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PPUSH
87032: LD_VAR 0 1
87036: PPUSH
87037: CALL 21211 0 3
87041: ST_TO_ADDR
// break ;
87042: GO 87046
// end ; end ;
87044: GO 86958
87046: POP
87047: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87048: LD_VAR 0 1
87052: PPUSH
87053: CALL_OW 257
87057: PUSH
87058: LD_EXP 84
87062: IN
87063: PUSH
87064: LD_VAR 0 1
87068: PPUSH
87069: CALL_OW 266
87073: PUSH
87074: LD_INT 5
87076: EQUAL
87077: AND
87078: PUSH
87079: LD_VAR 0 2
87083: PPUSH
87084: CALL_OW 110
87088: PUSH
87089: LD_INT 18
87091: NONEQUAL
87092: AND
87093: IFFALSE 87133
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87095: LD_VAR 0 2
87099: PPUSH
87100: CALL_OW 257
87104: PUSH
87105: LD_INT 5
87107: PUSH
87108: LD_INT 8
87110: PUSH
87111: LD_INT 9
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: LIST
87118: IN
87119: IFFALSE 87133
// SetClass ( unit , 1 ) ;
87121: LD_VAR 0 2
87125: PPUSH
87126: LD_INT 1
87128: PPUSH
87129: CALL_OW 336
// end ;
87133: LD_VAR 0 3
87137: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87138: LD_INT 0
87140: PPUSH
87141: PPUSH
// if not mc_bases or not skirmish then
87142: LD_EXP 58
87146: NOT
87147: PUSH
87148: LD_EXP 56
87152: NOT
87153: OR
87154: IFFALSE 87158
// exit ;
87156: GO 87274
// if GetLives ( abandoned_vehicle ) > 250 then
87158: LD_VAR 0 2
87162: PPUSH
87163: CALL_OW 256
87167: PUSH
87168: LD_INT 250
87170: GREATER
87171: IFFALSE 87175
// exit ;
87173: GO 87274
// for i = 1 to mc_bases do
87175: LD_ADDR_VAR 0 6
87179: PUSH
87180: DOUBLE
87181: LD_INT 1
87183: DEC
87184: ST_TO_ADDR
87185: LD_EXP 58
87189: PUSH
87190: FOR_TO
87191: IFFALSE 87272
// begin if driver in mc_bases [ i ] then
87193: LD_VAR 0 1
87197: PUSH
87198: LD_EXP 58
87202: PUSH
87203: LD_VAR 0 6
87207: ARRAY
87208: IN
87209: IFFALSE 87270
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87211: LD_VAR 0 1
87215: PPUSH
87216: LD_EXP 58
87220: PUSH
87221: LD_VAR 0 6
87225: ARRAY
87226: PPUSH
87227: LD_INT 2
87229: PUSH
87230: LD_INT 30
87232: PUSH
87233: LD_INT 0
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 30
87242: PUSH
87243: LD_INT 1
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: LIST
87254: PPUSH
87255: CALL_OW 72
87259: PUSH
87260: LD_INT 1
87262: ARRAY
87263: PPUSH
87264: CALL_OW 112
// break ;
87268: GO 87272
// end ; end ;
87270: GO 87190
87272: POP
87273: POP
// end ; end_of_file
87274: LD_VAR 0 5
87278: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87279: GO 87281
87281: DISABLE
// begin ru_radar := 98 ;
87282: LD_ADDR_EXP 101
87286: PUSH
87287: LD_INT 98
87289: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87290: LD_ADDR_EXP 102
87294: PUSH
87295: LD_INT 89
87297: ST_TO_ADDR
// us_hack := 99 ;
87298: LD_ADDR_EXP 103
87302: PUSH
87303: LD_INT 99
87305: ST_TO_ADDR
// us_artillery := 97 ;
87306: LD_ADDR_EXP 104
87310: PUSH
87311: LD_INT 97
87313: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87314: LD_ADDR_EXP 105
87318: PUSH
87319: LD_INT 91
87321: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87322: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87323: LD_INT 0
87325: PPUSH
87326: PPUSH
87327: PPUSH
87328: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87329: LD_VAR 0 1
87333: PPUSH
87334: CALL_OW 264
87338: PUSH
87339: LD_EXP 105
87343: EQUAL
87344: IFFALSE 87416
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87346: LD_INT 68
87348: PPUSH
87349: LD_VAR 0 1
87353: PPUSH
87354: CALL_OW 255
87358: PPUSH
87359: CALL_OW 321
87363: PUSH
87364: LD_INT 2
87366: EQUAL
87367: IFFALSE 87379
// eff := 70 else
87369: LD_ADDR_VAR 0 6
87373: PUSH
87374: LD_INT 70
87376: ST_TO_ADDR
87377: GO 87387
// eff := 30 ;
87379: LD_ADDR_VAR 0 6
87383: PUSH
87384: LD_INT 30
87386: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87387: LD_VAR 0 1
87391: PPUSH
87392: CALL_OW 250
87396: PPUSH
87397: LD_VAR 0 1
87401: PPUSH
87402: CALL_OW 251
87406: PPUSH
87407: LD_VAR 0 6
87411: PPUSH
87412: CALL_OW 495
// end ; end ;
87416: LD_VAR 0 4
87420: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87421: LD_INT 0
87423: PPUSH
87424: PPUSH
87425: PPUSH
87426: PPUSH
87427: PPUSH
87428: PPUSH
// if cmd = 124 then
87429: LD_VAR 0 1
87433: PUSH
87434: LD_INT 124
87436: EQUAL
87437: IFFALSE 87643
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87439: LD_ADDR_VAR 0 5
87443: PUSH
87444: LD_INT 2
87446: PUSH
87447: LD_INT 34
87449: PUSH
87450: LD_INT 53
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 34
87459: PUSH
87460: LD_INT 14
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: LIST
87471: PPUSH
87472: CALL_OW 69
87476: ST_TO_ADDR
// if not tmp then
87477: LD_VAR 0 5
87481: NOT
87482: IFFALSE 87486
// exit ;
87484: GO 87643
// for i in tmp do
87486: LD_ADDR_VAR 0 3
87490: PUSH
87491: LD_VAR 0 5
87495: PUSH
87496: FOR_IN
87497: IFFALSE 87641
// begin taskList := GetTaskList ( i ) ;
87499: LD_ADDR_VAR 0 6
87503: PUSH
87504: LD_VAR 0 3
87508: PPUSH
87509: CALL_OW 437
87513: ST_TO_ADDR
// if not taskList then
87514: LD_VAR 0 6
87518: NOT
87519: IFFALSE 87523
// continue ;
87521: GO 87496
// for j = 1 to taskList do
87523: LD_ADDR_VAR 0 4
87527: PUSH
87528: DOUBLE
87529: LD_INT 1
87531: DEC
87532: ST_TO_ADDR
87533: LD_VAR 0 6
87537: PUSH
87538: FOR_TO
87539: IFFALSE 87637
// if taskList [ j ] [ 1 ] = | then
87541: LD_VAR 0 6
87545: PUSH
87546: LD_VAR 0 4
87550: ARRAY
87551: PUSH
87552: LD_INT 1
87554: ARRAY
87555: PUSH
87556: LD_STRING |
87558: EQUAL
87559: IFFALSE 87635
// begin _taskList := Delete ( taskList , 1 ) ;
87561: LD_ADDR_VAR 0 7
87565: PUSH
87566: LD_VAR 0 6
87570: PPUSH
87571: LD_INT 1
87573: PPUSH
87574: CALL_OW 3
87578: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87579: LD_VAR 0 3
87583: PPUSH
87584: LD_VAR 0 7
87588: PPUSH
87589: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87593: LD_VAR 0 3
87597: PPUSH
87598: LD_VAR 0 6
87602: PUSH
87603: LD_VAR 0 4
87607: ARRAY
87608: PUSH
87609: LD_INT 2
87611: ARRAY
87612: PPUSH
87613: LD_VAR 0 6
87617: PUSH
87618: LD_VAR 0 4
87622: ARRAY
87623: PUSH
87624: LD_INT 3
87626: ARRAY
87627: PPUSH
87628: LD_INT 8
87630: PPUSH
87631: CALL 87648 0 4
// end ;
87635: GO 87538
87637: POP
87638: POP
// end ;
87639: GO 87496
87641: POP
87642: POP
// end ; end ;
87643: LD_VAR 0 2
87647: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87648: LD_INT 0
87650: PPUSH
87651: PPUSH
87652: PPUSH
87653: PPUSH
87654: PPUSH
87655: PPUSH
87656: PPUSH
87657: PPUSH
87658: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87659: LD_VAR 0 1
87663: NOT
87664: PUSH
87665: LD_VAR 0 2
87669: PPUSH
87670: LD_VAR 0 3
87674: PPUSH
87675: CALL_OW 488
87679: NOT
87680: OR
87681: PUSH
87682: LD_VAR 0 4
87686: NOT
87687: OR
87688: IFFALSE 87692
// exit ;
87690: GO 88032
// list := [ ] ;
87692: LD_ADDR_VAR 0 13
87696: PUSH
87697: EMPTY
87698: ST_TO_ADDR
// if x - r < 0 then
87699: LD_VAR 0 2
87703: PUSH
87704: LD_VAR 0 4
87708: MINUS
87709: PUSH
87710: LD_INT 0
87712: LESS
87713: IFFALSE 87725
// min_x := 0 else
87715: LD_ADDR_VAR 0 7
87719: PUSH
87720: LD_INT 0
87722: ST_TO_ADDR
87723: GO 87741
// min_x := x - r ;
87725: LD_ADDR_VAR 0 7
87729: PUSH
87730: LD_VAR 0 2
87734: PUSH
87735: LD_VAR 0 4
87739: MINUS
87740: ST_TO_ADDR
// if y - r < 0 then
87741: LD_VAR 0 3
87745: PUSH
87746: LD_VAR 0 4
87750: MINUS
87751: PUSH
87752: LD_INT 0
87754: LESS
87755: IFFALSE 87767
// min_y := 0 else
87757: LD_ADDR_VAR 0 8
87761: PUSH
87762: LD_INT 0
87764: ST_TO_ADDR
87765: GO 87783
// min_y := y - r ;
87767: LD_ADDR_VAR 0 8
87771: PUSH
87772: LD_VAR 0 3
87776: PUSH
87777: LD_VAR 0 4
87781: MINUS
87782: ST_TO_ADDR
// max_x := x + r ;
87783: LD_ADDR_VAR 0 9
87787: PUSH
87788: LD_VAR 0 2
87792: PUSH
87793: LD_VAR 0 4
87797: PLUS
87798: ST_TO_ADDR
// max_y := y + r ;
87799: LD_ADDR_VAR 0 10
87803: PUSH
87804: LD_VAR 0 3
87808: PUSH
87809: LD_VAR 0 4
87813: PLUS
87814: ST_TO_ADDR
// for _x = min_x to max_x do
87815: LD_ADDR_VAR 0 11
87819: PUSH
87820: DOUBLE
87821: LD_VAR 0 7
87825: DEC
87826: ST_TO_ADDR
87827: LD_VAR 0 9
87831: PUSH
87832: FOR_TO
87833: IFFALSE 87950
// for _y = min_y to max_y do
87835: LD_ADDR_VAR 0 12
87839: PUSH
87840: DOUBLE
87841: LD_VAR 0 8
87845: DEC
87846: ST_TO_ADDR
87847: LD_VAR 0 10
87851: PUSH
87852: FOR_TO
87853: IFFALSE 87946
// begin if not ValidHex ( _x , _y ) then
87855: LD_VAR 0 11
87859: PPUSH
87860: LD_VAR 0 12
87864: PPUSH
87865: CALL_OW 488
87869: NOT
87870: IFFALSE 87874
// continue ;
87872: GO 87852
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87874: LD_VAR 0 11
87878: PPUSH
87879: LD_VAR 0 12
87883: PPUSH
87884: CALL_OW 351
87888: PUSH
87889: LD_VAR 0 11
87893: PPUSH
87894: LD_VAR 0 12
87898: PPUSH
87899: CALL_OW 554
87903: AND
87904: IFFALSE 87944
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87906: LD_ADDR_VAR 0 13
87910: PUSH
87911: LD_VAR 0 13
87915: PPUSH
87916: LD_VAR 0 13
87920: PUSH
87921: LD_INT 1
87923: PLUS
87924: PPUSH
87925: LD_VAR 0 11
87929: PUSH
87930: LD_VAR 0 12
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PPUSH
87939: CALL_OW 2
87943: ST_TO_ADDR
// end ;
87944: GO 87852
87946: POP
87947: POP
87948: GO 87832
87950: POP
87951: POP
// if not list then
87952: LD_VAR 0 13
87956: NOT
87957: IFFALSE 87961
// exit ;
87959: GO 88032
// for i in list do
87961: LD_ADDR_VAR 0 6
87965: PUSH
87966: LD_VAR 0 13
87970: PUSH
87971: FOR_IN
87972: IFFALSE 88030
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87974: LD_VAR 0 1
87978: PPUSH
87979: LD_STRING M
87981: PUSH
87982: LD_VAR 0 6
87986: PUSH
87987: LD_INT 1
87989: ARRAY
87990: PUSH
87991: LD_VAR 0 6
87995: PUSH
87996: LD_INT 2
87998: ARRAY
87999: PUSH
88000: LD_INT 0
88002: PUSH
88003: LD_INT 0
88005: PUSH
88006: LD_INT 0
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: PUSH
88021: EMPTY
88022: LIST
88023: PPUSH
88024: CALL_OW 447
88028: GO 87971
88030: POP
88031: POP
// end ;
88032: LD_VAR 0 5
88036: RET
