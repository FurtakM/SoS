// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 682 0 0
// InitGlobalVariables ;
  19: CALL 83530 0 0
// InitMacro ;
  23: CALL 53214 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48104 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48104 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48104 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 48104 0 9
// PrepareArabian ;
 168: CALL 3932 0 0
// PrepareRussian ;
 172: CALL 2911 0 0
// PrepareAlliance ;
 176: CALL 884 0 0
// MC_Start ( ) ;
 180: CALL 55379 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7274 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 83
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 84
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: PUSH
 253: LD_OWVAR 67
 257: ARRAY
 258: PPUSH
 259: LD_INT 7
 261: PPUSH
 262: CALL 76767 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_EXP 54
 273: PPUSH
 274: CALL 77193 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 278: LD_INT 1
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL 77651 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 288: LD_INT 1
 290: PPUSH
 291: LD_INT 9
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77920 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 13
 306: PUSH
 307: LD_INT 1
 309: PUSH
 310: LD_INT 2
 312: PUSH
 313: LD_INT 32
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_INT 13
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_EXP 109
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: PUSH
 342: EMPTY
 343: LIST
 344: LIST
 345: PPUSH
 346: CALL 77133 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 350: LD_INT 2
 352: PPUSH
 353: LD_INT 12
 355: PUSH
 356: LD_INT 14
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: LD_INT 11
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL 77827 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 375: LD_INT 2
 377: PPUSH
 378: LD_EXP 51
 382: PPUSH
 383: CALL 77193 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 387: LD_INT 2
 389: PPUSH
 390: LD_INT 8
 392: PPUSH
 393: CALL 77651 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 397: LD_INT 2
 399: PPUSH
 400: LD_INT 10
 402: PUSH
 403: EMPTY
 404: LIST
 405: PPUSH
 406: CALL 77920 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 6
 415: PUSH
 416: LD_INT 71
 418: PUSH
 419: LD_INT 116
 421: PUSH
 422: LD_INT 4
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_INT 4
 433: PUSH
 434: LD_INT 85
 436: PUSH
 437: LD_INT 116
 439: PUSH
 440: LD_INT 4
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: PUSH
 449: LD_INT 32
 451: PUSH
 452: LD_INT 83
 454: PUSH
 455: LD_INT 111
 457: PUSH
 458: LD_INT 4
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: PUSH
 467: LD_INT 32
 469: PUSH
 470: LD_INT 87
 472: PUSH
 473: LD_INT 121
 475: PUSH
 476: LD_INT 4
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: LIST
 483: LIST
 484: PUSH
 485: LD_INT 33
 487: PUSH
 488: LD_INT 88
 490: PUSH
 491: LD_INT 128
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 32
 505: PUSH
 506: LD_INT 59
 508: PUSH
 509: LD_INT 89
 511: PUSH
 512: LD_INT 3
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: LD_INT 33
 523: PUSH
 524: LD_INT 69
 526: PUSH
 527: LD_INT 98
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: PUSH
 539: LD_INT 33
 541: PUSH
 542: LD_INT 77
 544: PUSH
 545: LD_INT 103
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: PUSH
 557: LD_INT 33
 559: PUSH
 560: LD_INT 83
 562: PUSH
 563: LD_INT 105
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 33
 577: PUSH
 578: LD_INT 71
 580: PUSH
 581: LD_INT 125
 583: PUSH
 584: LD_INT 5
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PPUSH
 605: CALL 76977 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 609: LD_INT 2
 611: PPUSH
 612: LD_INT 43
 614: PUSH
 615: LD_INT 47
 617: PUSH
 618: LD_INT 46
 620: PUSH
 621: EMPTY
 622: LIST
 623: LIST
 624: LIST
 625: PPUSH
 626: CALL 78238 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 630: LD_INT 2
 632: PPUSH
 633: LD_INT 21
 635: PUSH
 636: LD_INT 1
 638: PUSH
 639: LD_INT 3
 641: PUSH
 642: LD_INT 51
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 22
 653: PUSH
 654: LD_INT 1
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 52
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: PPUSH
 673: CALL 77133 0 2
// end ;
 677: LD_VAR 0 1
 681: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 682: LD_INT 0
 684: PPUSH
// debug := false ;
 685: LD_ADDR_EXP 1
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// game := true ;
 693: LD_ADDR_EXP 2
 697: PUSH
 698: LD_INT 1
 700: ST_TO_ADDR
// gossudarov_arrive := false ;
 701: LD_ADDR_EXP 4
 705: PUSH
 706: LD_INT 0
 708: ST_TO_ADDR
// ru_lab_builded := false ;
 709: LD_ADDR_EXP 5
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// player_spotted := false ;
 717: LD_ADDR_EXP 6
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// first_attack := false ;
 725: LD_ADDR_EXP 7
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// ru_attackers := [ ] ;
 733: LD_ADDR_EXP 52
 737: PUSH
 738: EMPTY
 739: ST_TO_ADDR
// ar_base_spotted := false ;
 740: LD_ADDR_EXP 8
 744: PUSH
 745: LD_INT 0
 747: ST_TO_ADDR
// ar_active_attack := false ;
 748: LD_ADDR_EXP 9
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_attackers := [ ] ;
 756: LD_ADDR_EXP 10
 760: PUSH
 761: EMPTY
 762: ST_TO_ADDR
// first_powell_attack := false ;
 763: LD_ADDR_EXP 11
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// abdul_escaped := true ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 1
 778: ST_TO_ADDR
// loss_counter := 0 ;
 779: LD_ADDR_EXP 13
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// hack_counter := 0 ;
 787: LD_ADDR_EXP 14
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// end ;
 795: LD_VAR 0 1
 799: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 800: LD_EXP 48
 804: PPUSH
 805: CALL_OW 255
 809: PUSH
 810: LD_INT 7
 812: EQUAL
 813: PUSH
 814: LD_EXP 47
 818: PPUSH
 819: CALL_OW 255
 823: PUSH
 824: LD_INT 7
 826: EQUAL
 827: AND
 828: PUSH
 829: LD_EXP 48
 833: PPUSH
 834: CALL_OW 302
 838: AND
 839: PUSH
 840: LD_EXP 47
 844: PPUSH
 845: CALL_OW 302
 849: AND
 850: IFFALSE 862
 852: GO 854
 854: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 855: LD_STRING ACH_COMRADE
 857: PPUSH
 858: CALL_OW 543
 862: END
// every 0 0$1 trigger hack_counter >= 10 do
 863: LD_EXP 14
 867: PUSH
 868: LD_INT 10
 870: GREATEREQUAL
 871: IFFALSE 883
 873: GO 875
 875: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 876: LD_STRING ACH_HACK
 878: PPUSH
 879: CALL_OW 543
 883: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 884: LD_INT 0
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// uc_side := 7 ;
 890: LD_ADDR_OWVAR 20
 894: PUSH
 895: LD_INT 7
 897: ST_TO_ADDR
// uc_nation := 1 ;
 898: LD_ADDR_OWVAR 21
 902: PUSH
 903: LD_INT 1
 905: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 906: LD_ADDR_EXP 15
 910: PUSH
 911: LD_STRING JMM
 913: PPUSH
 914: LD_EXP 1
 918: NOT
 919: PPUSH
 920: LD_STRING 12a_
 922: PPUSH
 923: CALL 14740 0 3
 927: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 928: LD_EXP 15
 932: PPUSH
 933: LD_INT 71
 935: PPUSH
 936: LD_INT 23
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 946: LD_EXP 15
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 958: LD_ADDR_EXP 16
 962: PUSH
 963: LD_STRING Roth
 965: PPUSH
 966: LD_EXP 1
 970: NOT
 971: PPUSH
 972: LD_STRING 12a_
 974: PPUSH
 975: CALL 14740 0 3
 979: ST_TO_ADDR
// if Roth then
 980: LD_EXP 16
 984: IFFALSE 1004
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 986: LD_EXP 16
 990: PPUSH
 991: LD_INT 71
 993: PPUSH
 994: LD_INT 21
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1004: LD_ADDR_EXP 17
1008: PUSH
1009: LD_STRING Lisa
1011: PPUSH
1012: LD_EXP 1
1016: NOT
1017: PPUSH
1018: LD_STRING 12a_
1020: PPUSH
1021: CALL 14740 0 3
1025: ST_TO_ADDR
// if Lisa then
1026: LD_EXP 17
1030: IFFALSE 1047
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1032: LD_EXP 17
1036: PPUSH
1037: LD_INT 13
1039: PPUSH
1040: LD_INT 0
1042: PPUSH
1043: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1047: LD_ADDR_EXP 18
1051: PUSH
1052: LD_STRING Donaldson
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_STRING 12a_
1063: PPUSH
1064: CALL 14740 0 3
1068: ST_TO_ADDR
// if Donaldson then
1069: LD_EXP 18
1073: IFFALSE 1090
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1075: LD_EXP 18
1079: PPUSH
1080: LD_INT 13
1082: PPUSH
1083: LD_INT 0
1085: PPUSH
1086: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1090: LD_ADDR_EXP 19
1094: PUSH
1095: LD_STRING Bobby
1097: PPUSH
1098: LD_EXP 1
1102: NOT
1103: PPUSH
1104: LD_STRING 12a_
1106: PPUSH
1107: CALL 14740 0 3
1111: ST_TO_ADDR
// if Bobby then
1112: LD_EXP 19
1116: IFFALSE 1133
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1118: LD_EXP 19
1122: PPUSH
1123: LD_INT 13
1125: PPUSH
1126: LD_INT 0
1128: PPUSH
1129: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1133: LD_ADDR_EXP 20
1137: PUSH
1138: LD_STRING Cyrus
1140: PPUSH
1141: LD_EXP 1
1145: NOT
1146: PPUSH
1147: LD_STRING 12a_
1149: PPUSH
1150: CALL 14740 0 3
1154: ST_TO_ADDR
// if Cyrus then
1155: LD_EXP 20
1159: IFFALSE 1176
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1161: LD_EXP 20
1165: PPUSH
1166: LD_INT 13
1168: PPUSH
1169: LD_INT 0
1171: PPUSH
1172: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1176: LD_ADDR_EXP 21
1180: PUSH
1181: LD_STRING Denis
1183: PPUSH
1184: LD_EXP 1
1188: NOT
1189: PPUSH
1190: LD_STRING 12a_
1192: PPUSH
1193: CALL 14740 0 3
1197: ST_TO_ADDR
// if Denis then
1198: LD_EXP 21
1202: IFFALSE 1219
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1204: LD_EXP 21
1208: PPUSH
1209: LD_INT 13
1211: PPUSH
1212: LD_INT 0
1214: PPUSH
1215: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1219: LD_ADDR_EXP 22
1223: PUSH
1224: LD_STRING Brown
1226: PPUSH
1227: LD_EXP 1
1231: NOT
1232: PPUSH
1233: LD_STRING 12a_
1235: PPUSH
1236: CALL 14740 0 3
1240: ST_TO_ADDR
// if Brown then
1241: LD_EXP 22
1245: IFFALSE 1262
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1247: LD_EXP 22
1251: PPUSH
1252: LD_INT 13
1254: PPUSH
1255: LD_INT 0
1257: PPUSH
1258: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1262: LD_ADDR_EXP 23
1266: PUSH
1267: LD_STRING Gladstone
1269: PPUSH
1270: LD_EXP 1
1274: NOT
1275: PPUSH
1276: LD_STRING 12a_
1278: PPUSH
1279: CALL 14740 0 3
1283: ST_TO_ADDR
// if Gladstone then
1284: LD_EXP 23
1288: IFFALSE 1305
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1290: LD_EXP 23
1294: PPUSH
1295: LD_INT 13
1297: PPUSH
1298: LD_INT 0
1300: PPUSH
1301: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1305: LD_ADDR_EXP 24
1309: PUSH
1310: LD_STRING Houten
1312: PPUSH
1313: LD_EXP 1
1317: NOT
1318: PPUSH
1319: LD_STRING 12a_
1321: PPUSH
1322: CALL 14740 0 3
1326: ST_TO_ADDR
// if Houten then
1327: LD_EXP 24
1331: IFFALSE 1348
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1333: LD_EXP 24
1337: PPUSH
1338: LD_INT 13
1340: PPUSH
1341: LD_INT 0
1343: PPUSH
1344: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1348: LD_ADDR_EXP 25
1352: PUSH
1353: LD_STRING Cornell
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: LD_STRING 12a_
1364: PPUSH
1365: CALL 14740 0 3
1369: ST_TO_ADDR
// if Cornel then
1370: LD_EXP 25
1374: IFFALSE 1391
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1376: LD_EXP 25
1380: PPUSH
1381: LD_INT 13
1383: PPUSH
1384: LD_INT 0
1386: PPUSH
1387: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1391: LD_ADDR_EXP 26
1395: PUSH
1396: LD_STRING Gary
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: LD_STRING 12a_
1407: PPUSH
1408: CALL 14740 0 3
1412: ST_TO_ADDR
// if Gary then
1413: LD_EXP 26
1417: IFFALSE 1434
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1419: LD_EXP 26
1423: PPUSH
1424: LD_INT 13
1426: PPUSH
1427: LD_INT 0
1429: PPUSH
1430: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1434: LD_ADDR_EXP 27
1438: PUSH
1439: LD_STRING Frank
1441: PPUSH
1442: LD_EXP 1
1446: NOT
1447: PPUSH
1448: LD_STRING 12a_
1450: PPUSH
1451: CALL 14740 0 3
1455: ST_TO_ADDR
// if Frank then
1456: LD_EXP 27
1460: IFFALSE 1477
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1462: LD_EXP 27
1466: PPUSH
1467: LD_INT 13
1469: PPUSH
1470: LD_INT 0
1472: PPUSH
1473: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1477: LD_ADDR_EXP 28
1481: PUSH
1482: LD_STRING Kikuchi
1484: PPUSH
1485: LD_EXP 1
1489: NOT
1490: PPUSH
1491: LD_STRING 12a_
1493: PPUSH
1494: CALL 14740 0 3
1498: ST_TO_ADDR
// if Kikuchi then
1499: LD_EXP 28
1503: IFFALSE 1520
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1505: LD_EXP 28
1509: PPUSH
1510: LD_INT 13
1512: PPUSH
1513: LD_INT 0
1515: PPUSH
1516: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1520: LD_ADDR_EXP 29
1524: PUSH
1525: LD_STRING Simms
1527: PPUSH
1528: LD_EXP 1
1532: NOT
1533: PPUSH
1534: LD_STRING 12a_
1536: PPUSH
1537: CALL 14740 0 3
1541: ST_TO_ADDR
// if Simms then
1542: LD_EXP 29
1546: IFFALSE 1563
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1548: LD_EXP 29
1552: PPUSH
1553: LD_INT 13
1555: PPUSH
1556: LD_INT 0
1558: PPUSH
1559: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1563: LD_ADDR_EXP 30
1567: PUSH
1568: LD_STRING Joan
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: LD_STRING 12a_
1579: PPUSH
1580: CALL 14740 0 3
1584: ST_TO_ADDR
// if Joan then
1585: LD_EXP 30
1589: IFFALSE 1606
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1591: LD_EXP 30
1595: PPUSH
1596: LD_INT 13
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1606: LD_ADDR_EXP 31
1610: PUSH
1611: LD_STRING DeltaDoctor
1613: PPUSH
1614: LD_EXP 1
1618: NOT
1619: PPUSH
1620: LD_STRING 12a_
1622: PPUSH
1623: CALL 14740 0 3
1627: ST_TO_ADDR
// if DeltaDoctor then
1628: LD_EXP 31
1632: IFFALSE 1649
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1634: LD_EXP 31
1638: PPUSH
1639: LD_INT 13
1641: PPUSH
1642: LD_INT 0
1644: PPUSH
1645: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: LD_STRING 12a_others
1656: PPUSH
1657: CALL_OW 31
1661: ST_TO_ADDR
// if tmp then
1662: LD_VAR 0 4
1666: IFFALSE 1700
// for i in tmp do
1668: LD_ADDR_VAR 0 3
1672: PUSH
1673: LD_VAR 0 4
1677: PUSH
1678: FOR_IN
1679: IFFALSE 1698
// PlaceUnitArea ( i , alliance_start , false ) ;
1681: LD_VAR 0 3
1685: PPUSH
1686: LD_INT 13
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 49
1696: GO 1678
1698: POP
1699: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1700: LD_INT 3
1702: PPUSH
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 100
1714: PPUSH
1715: CALL 19604 0 5
// veh := CreateVehicle ;
1719: LD_ADDR_VAR 0 2
1723: PUSH
1724: CALL_OW 45
1728: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1729: LD_VAR 0 2
1733: PPUSH
1734: LD_INT 2
1736: PPUSH
1737: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1741: LD_VAR 0 2
1745: PPUSH
1746: LD_INT 60
1748: PPUSH
1749: LD_INT 6
1751: PPUSH
1752: LD_INT 0
1754: PPUSH
1755: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1759: LD_VAR 0 2
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: LD_INT 30
1769: PPUSH
1770: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1774: LD_STRING 11_artifact_captured
1776: PPUSH
1777: LD_INT 0
1779: PPUSH
1780: CALL_OW 30
1784: IFFALSE 1860
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1786: LD_INT 3
1788: PPUSH
1789: LD_INT 3
1791: PPUSH
1792: LD_INT 3
1794: PPUSH
1795: LD_INT 12
1797: PPUSH
1798: LD_INT 100
1800: PPUSH
1801: CALL 19604 0 5
// veh := CreateVehicle ;
1805: LD_ADDR_VAR 0 2
1809: PUSH
1810: CALL_OW 45
1814: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1815: LD_VAR 0 2
1819: PPUSH
1820: LD_INT 3
1822: PPUSH
1823: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1827: LD_VAR 0 2
1831: PPUSH
1832: LD_INT 75
1834: PPUSH
1835: LD_INT 6
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: LD_INT 4
1852: PPUSH
1853: LD_INT 50
1855: PPUSH
1856: CALL_OW 290
// end ; end ;
1860: LD_VAR 0 1
1864: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1865: LD_INT 0
1867: PPUSH
1868: PPUSH
1869: PPUSH
1870: PPUSH
// uc_side := 6 ;
1871: LD_ADDR_OWVAR 20
1875: PUSH
1876: LD_INT 6
1878: ST_TO_ADDR
// uc_nation := 3 ;
1879: LD_ADDR_OWVAR 21
1883: PUSH
1884: LD_INT 3
1886: ST_TO_ADDR
// InitHc ;
1887: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1891: LD_ADDR_EXP 32
1895: PUSH
1896: LD_STRING Gossudarov
1898: PPUSH
1899: CALL_OW 25
1903: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1904: LD_ADDR_EXP 33
1908: PUSH
1909: LD_STRING Kirilenkova
1911: PPUSH
1912: CALL_OW 25
1916: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1917: LD_ADDR_EXP 34
1921: PUSH
1922: LD_STRING Titov
1924: PPUSH
1925: CALL_OW 25
1929: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Oblukov
1937: PPUSH
1938: CALL_OW 25
1942: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1943: LD_ADDR_EXP 36
1947: PUSH
1948: LD_STRING Dolgov
1950: PPUSH
1951: CALL_OW 25
1955: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1956: LD_ADDR_EXP 37
1960: PUSH
1961: LD_STRING Petrosyan
1963: PPUSH
1964: CALL_OW 25
1968: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1969: LD_ADDR_EXP 38
1973: PUSH
1974: LD_STRING Scholtze
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1982: LD_ADDR_EXP 40
1986: PUSH
1987: LD_STRING Kapitsova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_EXP 32
2004: PUSH
2005: LD_EXP 33
2009: PUSH
2010: LD_EXP 34
2014: PUSH
2015: LD_EXP 39
2019: PUSH
2020: LD_EXP 36
2024: PUSH
2025: LD_EXP 37
2029: PUSH
2030: LD_EXP 38
2034: PUSH
2035: LD_EXP 40
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 4
2055: PPUSH
2056: LD_INT 8
2058: PPUSH
2059: CALL_OW 380
// un := CreateHuman ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: CALL_OW 44
2072: ST_TO_ADDR
// tmp := tmp ^ un ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_VAR 0 2
2082: PUSH
2083: LD_VAR 0 4
2087: ADD
2088: ST_TO_ADDR
// for i in tmp do
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: FOR_IN
2100: IFFALSE 2119
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 14
2109: PPUSH
2110: LD_INT 0
2112: PPUSH
2113: CALL_OW 49
2117: GO 2099
2119: POP
2120: POP
// if freedom then
2121: LD_EXP 3
2125: IFFALSE 2158
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2127: LD_VAR 0 2
2131: PPUSH
2132: LD_EXP 3
2136: PPUSH
2137: CALL_OW 250
2141: PPUSH
2142: LD_EXP 3
2146: PPUSH
2147: CALL_OW 251
2151: PPUSH
2152: CALL_OW 111
2156: GO 2173
// ComMoveXY ( tmp , 70 , 48 ) ;
2158: LD_VAR 0 2
2162: PPUSH
2163: LD_INT 70
2165: PPUSH
2166: LD_INT 48
2168: PPUSH
2169: CALL_OW 111
// end ;
2173: LD_VAR 0 1
2177: RET
// export function PrepareBelkov ; begin
2178: LD_INT 0
2180: PPUSH
// uc_side := 4 ;
2181: LD_ADDR_OWVAR 20
2185: PUSH
2186: LD_INT 4
2188: ST_TO_ADDR
// uc_nation := 3 ;
2189: LD_ADDR_OWVAR 21
2193: PUSH
2194: LD_INT 3
2196: ST_TO_ADDR
// InitHc ;
2197: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2201: LD_ADDR_EXP 47
2205: PUSH
2206: LD_STRING Belkov
2208: PPUSH
2209: CALL_OW 25
2213: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2214: LD_EXP 47
2218: PPUSH
2219: LD_INT 14
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 49
// end ;
2229: LD_VAR 0 1
2233: RET
// export function PrepareGnyevko ; begin
2234: LD_INT 0
2236: PPUSH
// uc_side := 4 ;
2237: LD_ADDR_OWVAR 20
2241: PUSH
2242: LD_INT 4
2244: ST_TO_ADDR
// uc_nation := 3 ;
2245: LD_ADDR_OWVAR 21
2249: PUSH
2250: LD_INT 3
2252: ST_TO_ADDR
// InitHc ;
2253: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2257: LD_ADDR_EXP 48
2261: PUSH
2262: LD_STRING Gnyevko
2264: PPUSH
2265: CALL_OW 25
2269: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2270: LD_EXP 48
2274: PPUSH
2275: LD_INT 14
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// end ;
2285: LD_VAR 0 1
2289: RET
// export function PrepareBurlak ; var i , tmp ; begin
2290: LD_INT 0
2292: PPUSH
2293: PPUSH
2294: PPUSH
// uc_side := 4 ;
2295: LD_ADDR_OWVAR 20
2299: PUSH
2300: LD_INT 4
2302: ST_TO_ADDR
// uc_nation := 3 ;
2303: LD_ADDR_OWVAR 21
2307: PUSH
2308: LD_INT 3
2310: ST_TO_ADDR
// InitHc ;
2311: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2315: LD_ADDR_EXP 46
2319: PUSH
2320: LD_STRING Burlak
2322: PPUSH
2323: CALL_OW 25
2327: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2328: LD_INT 24
2330: PUSH
2331: LD_INT 23
2333: PUSH
2334: LD_INT 22
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: LIST
2341: PUSH
2342: LD_OWVAR 67
2346: ARRAY
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_INT 1
2353: PPUSH
2354: LD_INT 45
2356: PUSH
2357: LD_INT 44
2359: PUSH
2360: LD_INT 43
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: LIST
2367: PUSH
2368: LD_OWVAR 67
2372: ARRAY
2373: PPUSH
2374: LD_INT 0
2376: PPUSH
2377: CALL 19604 0 5
// Masha := CreateVehicle ;
2381: LD_ADDR_EXP 49
2385: PUSH
2386: CALL_OW 45
2390: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2391: LD_EXP 49
2395: PUSH
2396: LD_EXP 46
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PPUSH
2405: LD_INT 499
2407: PPUSH
2408: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2412: LD_EXP 49
2416: PPUSH
2417: LD_INT 3
2419: PPUSH
2420: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2424: LD_EXP 49
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 18
2441: PPUSH
2442: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2446: LD_INT 35
2448: PPUSH
2449: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_INT 18
2460: PPUSH
2461: EMPTY
2462: PPUSH
2463: CALL_OW 70
2467: ST_TO_ADDR
// if tmp then
2468: LD_VAR 0 3
2472: IFFALSE 2506
// for i in tmp do
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 3
2483: PUSH
2484: FOR_IN
2485: IFFALSE 2504
// ComMoveXY ( i , 114 , 9 ) ;
2487: LD_VAR 0 2
2491: PPUSH
2492: LD_INT 114
2494: PPUSH
2495: LD_INT 9
2497: PPUSH
2498: CALL_OW 111
2502: GO 2484
2504: POP
2505: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2506: LD_INT 18
2508: PPUSH
2509: EMPTY
2510: PPUSH
2511: CALL_OW 70
2515: NOT
2516: PUSH
2517: LD_INT 123
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: CALL_OW 428
2527: PUSH
2528: LD_INT 0
2530: EQUAL
2531: AND
2532: IFFALSE 2446
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2534: LD_EXP 49
2538: PPUSH
2539: LD_INT 123
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2552: LD_EXP 46
2556: PPUSH
2557: LD_INT 125
2559: PPUSH
2560: LD_INT 1
2562: PPUSH
2563: LD_INT 0
2565: PPUSH
2566: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2570: LD_EXP 46
2574: PPUSH
2575: LD_EXP 49
2579: PPUSH
2580: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2584: LD_INT 10
2586: PPUSH
2587: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2591: LD_EXP 49
2595: PPUSH
2596: LD_INT 110
2598: PPUSH
2599: LD_INT 10
2601: PPUSH
2602: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2606: LD_ADDR_EXP 42
2610: PUSH
2611: LD_STRING Petrovova
2613: PPUSH
2614: CALL_OW 25
2618: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2619: LD_ADDR_EXP 44
2623: PUSH
2624: LD_STRING Kuzmov
2626: PPUSH
2627: CALL_OW 25
2631: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2632: LD_ADDR_EXP 43
2636: PUSH
2637: LD_STRING Kovalyuk
2639: PPUSH
2640: CALL_OW 25
2644: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2645: LD_ADDR_EXP 41
2649: PUSH
2650: LD_STRING Lipshchin
2652: PPUSH
2653: CALL_OW 25
2657: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2658: LD_ADDR_EXP 45
2662: PUSH
2663: LD_STRING Karamazov
2665: PPUSH
2666: CALL_OW 25
2670: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 42
2680: PUSH
2681: LD_EXP 44
2685: PUSH
2686: LD_EXP 43
2690: PUSH
2691: LD_EXP 41
2695: PUSH
2696: LD_EXP 45
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: ST_TO_ADDR
// for i in tmp do
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 3
2717: PUSH
2718: FOR_IN
2719: IFFALSE 2758
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2721: LD_VAR 0 2
2725: PPUSH
2726: LD_INT 399
2728: PPUSH
2729: LD_INT 799
2731: PPUSH
2732: CALL_OW 12
2736: PPUSH
2737: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: LD_INT 0
2751: PPUSH
2752: CALL_OW 49
// end ;
2756: GO 2718
2758: POP
2759: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 116
2767: PPUSH
2768: LD_INT 8
2770: PPUSH
2771: CALL_OW 111
// AddComHold ( tmp ) ;
2775: LD_VAR 0 3
2779: PPUSH
2780: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2784: LD_ADDR_VAR 0 2
2788: PUSH
2789: LD_VAR 0 3
2793: PPUSH
2794: LD_INT 25
2796: PUSH
2797: LD_INT 1
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PPUSH
2804: CALL_OW 72
2808: PUSH
2809: FOR_IN
2810: IFFALSE 2850
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2812: LD_VAR 0 2
2816: PPUSH
2817: LD_INT 20
2819: PPUSH
2820: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2824: LD_VAR 0 2
2828: PPUSH
2829: LD_INT 147
2831: PPUSH
2832: LD_INT 45
2834: PPUSH
2835: CALL_OW 178
// AddComCrawl ( i ) ;
2839: LD_VAR 0 2
2843: PPUSH
2844: CALL_OW 197
// end ;
2848: GO 2809
2850: POP
2851: POP
// repeat wait ( 0 0$1 ) ;
2852: LD_INT 35
2854: PPUSH
2855: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2859: LD_EXP 49
2863: PPUSH
2864: LD_INT 110
2866: PPUSH
2867: LD_INT 10
2869: PPUSH
2870: CALL_OW 307
2874: PUSH
2875: LD_EXP 49
2879: PPUSH
2880: CALL_OW 305
2884: NOT
2885: OR
2886: IFFALSE 2852
// ComStop ( Burlak ) ;
2888: LD_EXP 46
2892: PPUSH
2893: CALL_OW 141
// AddComHold ( Burlak ) ;
2897: LD_EXP 46
2901: PPUSH
2902: CALL_OW 200
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// uc_side := 3 ;
2918: LD_ADDR_OWVAR 20
2922: PUSH
2923: LD_INT 3
2925: ST_TO_ADDR
// uc_nation := 3 ;
2926: LD_ADDR_OWVAR 21
2930: PUSH
2931: LD_INT 3
2933: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2934: LD_ADDR_EXP 50
2938: PUSH
2939: LD_INT 47
2941: PPUSH
2942: LD_INT 4
2944: PPUSH
2945: LD_STRING 
2947: PPUSH
2948: LD_INT 7
2950: PUSH
2951: LD_INT 8
2953: PUSH
2954: LD_INT 10
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: PUSH
2962: LD_OWVAR 67
2966: ARRAY
2967: PPUSH
2968: LD_INT 10000
2970: PUSH
2971: LD_INT 3000
2973: PUSH
2974: LD_INT 300
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PPUSH
2982: LD_INT 9
2984: PUSH
2985: LD_INT 5
2987: PUSH
2988: LD_INT 6
2990: PUSH
2991: LD_INT 6
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL 23051 0 6
3004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3005: LD_ADDR_EXP 59
3009: PUSH
3010: LD_EXP 59
3014: PPUSH
3015: LD_INT 2
3017: PPUSH
3018: LD_EXP 50
3022: PPUSH
3023: CALL_OW 1
3027: ST_TO_ADDR
// tmp := [ ] ;
3028: LD_ADDR_VAR 0 4
3032: PUSH
3033: EMPTY
3034: ST_TO_ADDR
// for i = 1 to 4 do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: DOUBLE
3041: LD_INT 1
3043: DEC
3044: ST_TO_ADDR
3045: LD_INT 4
3047: PUSH
3048: FOR_TO
3049: IFFALSE 3142
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3051: LD_INT 22
3053: PPUSH
3054: LD_INT 3
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: LD_INT 43
3062: PUSH
3063: LD_INT 45
3065: PUSH
3066: LD_INT 45
3068: PUSH
3069: LD_INT 44
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_INT 4
3085: MOD
3086: PUSH
3087: LD_INT 1
3089: PLUS
3090: ARRAY
3091: PPUSH
3092: LD_INT 100
3094: PPUSH
3095: CALL 19604 0 5
// veh := CreateVehicle ;
3099: LD_ADDR_VAR 0 3
3103: PUSH
3104: CALL_OW 45
3108: ST_TO_ADDR
// tmp := tmp ^ veh ;
3109: LD_ADDR_VAR 0 4
3113: PUSH
3114: LD_VAR 0 4
3118: PUSH
3119: LD_VAR 0 3
3123: ADD
3124: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3125: LD_VAR 0 3
3129: PPUSH
3130: LD_INT 2
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 49
// end ;
3140: GO 3048
3142: POP
3143: POP
// russian_guard := tmp ;
3144: LD_ADDR_EXP 51
3148: PUSH
3149: LD_VAR 0 4
3153: ST_TO_ADDR
// if Difficulty = 3 then
3154: LD_OWVAR 67
3158: PUSH
3159: LD_INT 3
3161: EQUAL
3162: IFFALSE 3226
// begin bc_type := b_breastwork ;
3164: LD_ADDR_OWVAR 42
3168: PUSH
3169: LD_INT 31
3171: ST_TO_ADDR
// bc_level := 10 ;
3172: LD_ADDR_OWVAR 43
3176: PUSH
3177: LD_INT 10
3179: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3180: LD_ADDR_VAR 0 5
3184: PUSH
3185: LD_INT 96
3187: PPUSH
3188: LD_INT 105
3190: PPUSH
3191: LD_INT 3
3193: PPUSH
3194: CALL_OW 47
3198: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3199: LD_INT 0
3201: PPUSH
3202: LD_INT 9
3204: PPUSH
3205: LD_INT 10
3207: PPUSH
3208: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3212: CALL_OW 44
3216: PPUSH
3217: LD_VAR 0 5
3221: PPUSH
3222: CALL_OW 52
// end ; end ;
3226: LD_VAR 0 1
3230: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3231: LD_INT 47
3233: PPUSH
3234: CALL_OW 302
3238: PUSH
3239: LD_EXP 6
3243: AND
3244: IFFALSE 3929
3246: GO 3248
3248: DISABLE
3249: LD_INT 0
3251: PPUSH
3252: PPUSH
3253: PPUSH
3254: PPUSH
3255: PPUSH
3256: PPUSH
3257: PPUSH
// begin enable ;
3258: ENABLE
// base := 2 ;
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: LD_INT 2
3266: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3267: LD_ADDR_VAR 0 4
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: LD_INT 0
3277: PUSH
3278: LD_INT 0
3280: PUSH
3281: LD_INT 0
3283: PUSH
3284: LD_INT 0
3286: PUSH
3287: LD_INT 0
3289: PUSH
3290: LD_INT 0
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 1
3298: PUSH
3299: LD_INT 0
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: LIST
3311: LIST
3312: LIST
3313: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3314: LD_ADDR_VAR 0 3
3318: PUSH
3319: LD_INT 22
3321: PUSH
3322: LD_INT 1
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 45
3330: PUSH
3331: EMPTY
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_INT 21
3339: PUSH
3340: LD_INT 1
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 45
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: PUSH
3355: LD_INT 22
3357: PUSH
3358: LD_INT 1
3360: PUSH
3361: LD_INT 3
3363: PUSH
3364: LD_INT 45
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 23
3375: PUSH
3376: LD_INT 1
3378: PUSH
3379: LD_INT 3
3381: PUSH
3382: LD_INT 46
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// amount := Difficulty ;
3397: LD_ADDR_VAR 0 7
3401: PUSH
3402: LD_OWVAR 67
3406: ST_TO_ADDR
// if tick > 30 30$00 then
3407: LD_OWVAR 1
3411: PUSH
3412: LD_INT 63000
3414: GREATER
3415: IFFALSE 3448
// amount := amount + [ 2 , 3 , 4 ] [ Difficulty ] ;
3417: LD_ADDR_VAR 0 7
3421: PUSH
3422: LD_VAR 0 7
3426: PUSH
3427: LD_INT 2
3429: PUSH
3430: LD_INT 3
3432: PUSH
3433: LD_INT 4
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: LD_OWVAR 67
3445: ARRAY
3446: PLUS
3447: ST_TO_ADDR
// for i = 1 to amount do
3448: LD_ADDR_VAR 0 1
3452: PUSH
3453: DOUBLE
3454: LD_INT 1
3456: DEC
3457: ST_TO_ADDR
3458: LD_VAR 0 7
3462: PUSH
3463: FOR_TO
3464: IFFALSE 3552
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3466: LD_ADDR_VAR 0 3
3470: PUSH
3471: LD_VAR 0 3
3475: PPUSH
3476: LD_VAR 0 3
3480: PUSH
3481: LD_INT 1
3483: PLUS
3484: PPUSH
3485: LD_INT 23
3487: PUSH
3488: LD_INT 24
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 2
3500: PPUSH
3501: CALL_OW 12
3505: ARRAY
3506: PUSH
3507: LD_INT 1
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: LD_INT 46
3515: PUSH
3516: LD_INT 47
3518: PUSH
3519: LD_INT 45
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 3
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 2
3549: ST_TO_ADDR
3550: GO 3463
3552: POP
3553: POP
// MC_InsertProduceList ( base , tmp ) ;
3554: LD_VAR 0 2
3558: PPUSH
3559: LD_VAR 0 3
3563: PPUSH
3564: CALL 77133 0 2
// repeat wait ( 0 0$1 ) ;
3568: LD_INT 35
3570: PPUSH
3571: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3575: LD_VAR 0 2
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL 78551 0 2
3587: PUSH
3588: LD_VAR 0 7
3592: GREATEREQUAL
3593: IFFALSE 3568
// wait ( 0 0$30 ) ;
3595: LD_INT 1050
3597: PPUSH
3598: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_INT 71
3609: PUSH
3610: LD_INT 19
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 91
3619: PUSH
3620: LD_INT 67
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 52
3629: PUSH
3630: LD_INT 44
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 68
3639: PUSH
3640: LD_INT 48
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_EXP 78
3662: PUSH
3663: LD_VAR 0 2
3667: ARRAY
3668: PUSH
3669: LD_EXP 78
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: PPUSH
3680: LD_INT 2
3682: PUSH
3683: LD_INT 34
3685: PUSH
3686: LD_INT 51
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: LD_INT 34
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PPUSH
3708: CALL_OW 72
3712: DIFF
3713: ST_TO_ADDR
// if not attackers then
3714: LD_VAR 0 6
3718: NOT
3719: IFFALSE 3723
// exit ;
3721: GO 3929
// ru_attackers := attackers ;
3723: LD_ADDR_EXP 52
3727: PUSH
3728: LD_VAR 0 6
3732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3733: LD_ADDR_EXP 78
3737: PUSH
3738: LD_EXP 78
3742: PPUSH
3743: LD_VAR 0 2
3747: PPUSH
3748: LD_EXP 78
3752: PUSH
3753: LD_VAR 0 2
3757: ARRAY
3758: PUSH
3759: LD_VAR 0 6
3763: DIFF
3764: PPUSH
3765: CALL_OW 1
3769: ST_TO_ADDR
// for i = 1 to attackers do
3770: LD_ADDR_VAR 0 1
3774: PUSH
3775: DOUBLE
3776: LD_INT 1
3778: DEC
3779: ST_TO_ADDR
3780: LD_VAR 0 6
3784: PUSH
3785: FOR_TO
3786: IFFALSE 3863
// begin case i mod 3 of 0 :
3788: LD_VAR 0 1
3792: PUSH
3793: LD_INT 3
3795: MOD
3796: PUSH
3797: LD_INT 0
3799: DOUBLE
3800: EQUAL
3801: IFTRUE 3805
3803: GO 3808
3805: POP
// ; 1 :
3806: GO 3861
3808: LD_INT 1
3810: DOUBLE
3811: EQUAL
3812: IFTRUE 3816
3814: GO 3834
3816: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3817: LD_VAR 0 1
3821: PPUSH
3822: LD_INT 32
3824: PPUSH
3825: LD_INT 49
3827: PPUSH
3828: CALL_OW 114
3832: GO 3861
3834: LD_INT 2
3836: DOUBLE
3837: EQUAL
3838: IFTRUE 3842
3840: GO 3860
3842: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3843: LD_VAR 0 1
3847: PPUSH
3848: LD_INT 117
3850: PPUSH
3851: LD_INT 107
3853: PPUSH
3854: CALL_OW 114
3858: GO 3861
3860: POP
// end ;
3861: GO 3785
3863: POP
3864: POP
// repeat wait ( 0 0$1 ) ;
3865: LD_INT 35
3867: PPUSH
3868: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_INT 60
3879: PUSH
3880: EMPTY
3881: LIST
3882: PPUSH
3883: CALL_OW 72
3887: NOT
3888: IFFALSE 3865
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3890: LD_VAR 0 2
3894: PPUSH
3895: LD_VAR 0 6
3899: PPUSH
3900: LD_VAR 0 5
3904: PPUSH
3905: LD_VAR 0 4
3909: PPUSH
3910: CALL 77318 0 4
// if not first_attack then
3914: LD_EXP 7
3918: NOT
3919: IFFALSE 3929
// first_attack := true ;
3921: LD_ADDR_EXP 7
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// end ; end_of_file
3929: PPOPN 7
3931: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3932: LD_INT 0
3934: PPUSH
3935: PPUSH
3936: PPUSH
3937: PPUSH
3938: PPUSH
3939: PPUSH
3940: PPUSH
// uc_side := 2 ;
3941: LD_ADDR_OWVAR 20
3945: PUSH
3946: LD_INT 2
3948: ST_TO_ADDR
// uc_nation := 2 ;
3949: LD_ADDR_OWVAR 21
3953: PUSH
3954: LD_INT 2
3956: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3957: LD_ADDR_EXP 55
3961: PUSH
3962: LD_STRING Abdul
3964: PPUSH
3965: CALL_OW 25
3969: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3970: LD_EXP 55
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3982: LD_EXP 55
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: CALL_OW 52
// vc_chassis := 31 ;
3994: LD_ADDR_OWVAR 37
3998: PUSH
3999: LD_INT 31
4001: ST_TO_ADDR
// vc_control := control_rider ;
4002: LD_ADDR_OWVAR 38
4006: PUSH
4007: LD_INT 4
4009: ST_TO_ADDR
// mastodont := CreateVehicle ;
4010: LD_ADDR_EXP 56
4014: PUSH
4015: CALL_OW 45
4019: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4020: LD_EXP 56
4024: PPUSH
4025: LD_INT 153
4027: PPUSH
4028: LD_INT 71
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 48
// InitVc ;
4038: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 3
4052: PPUSH
4053: LD_STRING 
4055: PPUSH
4056: LD_INT 7
4058: PUSH
4059: LD_INT 8
4061: PUSH
4062: LD_INT 10
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: LIST
4069: PUSH
4070: LD_OWVAR 67
4074: ARRAY
4075: PPUSH
4076: LD_INT 5000
4078: PUSH
4079: LD_INT 1000
4081: PUSH
4082: LD_INT 300
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PPUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 5
4095: PUSH
4096: LD_INT 6
4098: PUSH
4099: LD_INT 9
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PPUSH
4108: CALL 23051 0 6
4112: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4113: LD_ADDR_EXP 59
4117: PUSH
4118: LD_EXP 59
4122: PPUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_EXP 53
4130: PPUSH
4131: CALL_OW 1
4135: ST_TO_ADDR
// tmp := [ ] ;
4136: LD_ADDR_VAR 0 4
4140: PUSH
4141: EMPTY
4142: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4143: LD_ADDR_OWVAR 37
4147: PUSH
4148: LD_INT 14
4150: ST_TO_ADDR
// vc_engine := engine_siberite ;
4151: LD_ADDR_OWVAR 39
4155: PUSH
4156: LD_INT 3
4158: ST_TO_ADDR
// vc_control := control_manual ;
4159: LD_ADDR_OWVAR 38
4163: PUSH
4164: LD_INT 1
4166: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4167: LD_ADDR_OWVAR 40
4171: PUSH
4172: LD_INT 31
4174: ST_TO_ADDR
// for i = 1 to 3 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 3
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4433
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 153
4198: PUSH
4199: LD_INT 71
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 155
4208: PUSH
4209: LD_INT 81
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_VAR 0 2
4224: PUSH
4225: LD_INT 2
4227: MOD
4228: PUSH
4229: LD_INT 1
4231: PLUS
4232: ARRAY
4233: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 ] [ Difficulty ] ) ;
4234: LD_INT 0
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 7
4242: PUSH
4243: LD_INT 8
4245: PUSH
4246: LD_INT 10
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: PUSH
4254: LD_OWVAR 67
4258: ARRAY
4259: PPUSH
4260: CALL_OW 380
// un := CreateVehicle ;
4264: LD_ADDR_VAR 0 6
4268: PUSH
4269: CALL_OW 45
4273: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4274: LD_VAR 0 6
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: LD_INT 5
4284: PPUSH
4285: CALL_OW 12
4289: PPUSH
4290: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4294: LD_VAR 0 6
4298: PPUSH
4299: LD_VAR 0 5
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PPUSH
4308: LD_VAR 0 5
4312: PUSH
4313: LD_INT 2
4315: ARRAY
4316: PPUSH
4317: LD_INT 6
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 50
// un2 := CreateHuman ;
4327: LD_ADDR_VAR 0 7
4331: PUSH
4332: CALL_OW 44
4336: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4337: LD_VAR 0 7
4341: PPUSH
4342: LD_VAR 0 6
4346: PPUSH
4347: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4351: LD_ADDR_EXP 59
4355: PUSH
4356: LD_EXP 59
4360: PPUSH
4361: LD_INT 1
4363: PUSH
4364: LD_EXP 59
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: PUSH
4373: LD_INT 1
4375: PLUS
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: LD_VAR 0 6
4385: PPUSH
4386: CALL 19726 0 3
4390: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4391: LD_ADDR_EXP 59
4395: PUSH
4396: LD_EXP 59
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 59
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 7
4425: PPUSH
4426: CALL 19726 0 3
4430: ST_TO_ADDR
// end ;
4431: GO 4188
4433: POP
4434: POP
// for i = 1 to 5 do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: DOUBLE
4441: LD_INT 1
4443: DEC
4444: ST_TO_ADDR
4445: LD_INT 5
4447: PUSH
4448: FOR_TO
4449: IFFALSE 4542
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4451: LD_INT 14
4453: PPUSH
4454: LD_INT 3
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 25
4462: PUSH
4463: LD_INT 28
4465: PUSH
4466: LD_INT 28
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_VAR 0 2
4482: PUSH
4483: LD_INT 4
4485: MOD
4486: PUSH
4487: LD_INT 1
4489: PLUS
4490: ARRAY
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 19604 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// tmp := tmp ^ veh ;
4509: LD_ADDR_VAR 0 4
4513: PUSH
4514: LD_VAR 0 4
4518: PUSH
4519: LD_VAR 0 3
4523: ADD
4524: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4525: LD_VAR 0 3
4529: PPUSH
4530: LD_INT 1
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 49
// end ;
4540: GO 4448
4542: POP
4543: POP
// arabian_guard := tmp ;
4544: LD_ADDR_EXP 54
4548: PUSH
4549: LD_VAR 0 4
4553: ST_TO_ADDR
// end ;
4554: LD_VAR 0 1
4558: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4559: LD_INT 22
4561: PUSH
4562: LD_INT 7
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 91
4571: PUSH
4572: LD_INT 1
4574: PUSH
4575: LD_INT 12
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 69
4591: PUSH
4592: LD_EXP 56
4596: PPUSH
4597: CALL_OW 256
4601: PUSH
4602: LD_INT 990
4604: LESS
4605: OR
4606: PUSH
4607: LD_EXP 55
4611: PPUSH
4612: CALL_OW 256
4616: PUSH
4617: LD_INT 990
4619: LESS
4620: OR
4621: IFFALSE 4764
4623: GO 4625
4625: DISABLE
// begin if IsInUnit ( Abdul ) then
4626: LD_EXP 55
4630: PPUSH
4631: CALL_OW 310
4635: IFFALSE 4646
// ComExitBuilding ( Abdul ) ;
4637: LD_EXP 55
4641: PPUSH
4642: CALL_OW 122
// if Mastodont then
4646: LD_EXP 56
4650: IFFALSE 4667
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4652: LD_EXP 56
4656: PPUSH
4657: LD_INT 205
4659: PPUSH
4660: LD_INT 132
4662: PPUSH
4663: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4667: LD_EXP 55
4671: PPUSH
4672: LD_INT 205
4674: PPUSH
4675: LD_INT 132
4677: PPUSH
4678: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4682: LD_INT 35
4684: PPUSH
4685: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4689: LD_EXP 55
4693: PPUSH
4694: LD_INT 21
4696: PPUSH
4697: CALL_OW 308
4701: IFFALSE 4682
// RemoveUnit ( Abdul ) ;
4703: LD_EXP 55
4707: PPUSH
4708: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4712: LD_INT 35
4714: PPUSH
4715: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4719: LD_EXP 56
4723: PPUSH
4724: LD_INT 21
4726: PPUSH
4727: CALL_OW 308
4731: PUSH
4732: LD_EXP 56
4736: PPUSH
4737: CALL_OW 301
4741: OR
4742: IFFALSE 4712
// if IsOk ( Mastodont ) then
4744: LD_EXP 56
4748: PPUSH
4749: CALL_OW 302
4753: IFFALSE 4764
// RemoveUnit ( Mastodont ) ;
4755: LD_EXP 56
4759: PPUSH
4760: CALL_OW 64
// end ;
4764: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4765: LD_EXP 55
4769: PPUSH
4770: CALL_OW 301
4774: PUSH
4775: LD_INT 22
4777: PUSH
4778: LD_INT 2
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 2
4787: PUSH
4788: LD_INT 25
4790: PUSH
4791: LD_INT 1
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 25
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 25
4810: PUSH
4811: LD_INT 3
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 25
4820: PUSH
4821: LD_INT 4
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 8
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PPUSH
4850: CALL_OW 69
4854: PUSH
4855: LD_INT 16
4857: PUSH
4858: LD_INT 19
4860: PUSH
4861: LD_INT 22
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: PUSH
4869: LD_OWVAR 67
4873: ARRAY
4874: LESS
4875: OR
4876: IFFALSE 5549
4878: GO 4880
4880: DISABLE
4881: LD_INT 0
4883: PPUSH
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// begin MC_Kill ( 1 ) ;
4889: LD_INT 1
4891: PPUSH
4892: CALL 53456 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4896: LD_ADDR_VAR 0 2
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 2
4913: PUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 1
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PUSH
4924: LD_INT 25
4926: PUSH
4927: LD_INT 2
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 25
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 25
4946: PUSH
4947: LD_INT 4
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 25
4956: PUSH
4957: LD_INT 8
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PPUSH
4976: CALL_OW 69
4980: ST_TO_ADDR
// for i in tmp do
4981: LD_ADDR_VAR 0 5
4985: PUSH
4986: LD_VAR 0 2
4990: PUSH
4991: FOR_IN
4992: IFFALSE 5008
// SetTag ( i , 10 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 10
5001: PPUSH
5002: CALL_OW 109
5006: GO 4991
5008: POP
5009: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5010: LD_ADDR_VAR 0 3
5014: PUSH
5015: LD_INT 22
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 21
5027: PUSH
5028: LD_INT 1
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PPUSH
5039: CALL_OW 69
5043: PUSH
5044: LD_VAR 0 2
5048: DIFF
5049: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_INT 2
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 2
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 24
5077: PUSH
5078: LD_INT 300
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5095: LD_ADDR_VAR 0 4
5099: PUSH
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_INT 33
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: LD_INT 58
5117: PUSH
5118: EMPTY
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 72
5129: ST_TO_ADDR
// for i in tmp do
5130: LD_ADDR_VAR 0 5
5134: PUSH
5135: LD_VAR 0 2
5139: PUSH
5140: FOR_IN
5141: IFFALSE 5325
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5143: LD_VAR 0 5
5147: PUSH
5148: LD_INT 55
5150: PUSH
5151: EMPTY
5152: LIST
5153: PPUSH
5154: CALL_OW 69
5158: IN
5159: IFFALSE 5178
// begin AddComMoveXY ( i , 209 , 132 ) ;
5161: LD_VAR 0 5
5165: PPUSH
5166: LD_INT 209
5168: PPUSH
5169: LD_INT 132
5171: PPUSH
5172: CALL_OW 171
// continue ;
5176: GO 5140
// end ; if IsInUnit ( i ) then
5178: LD_VAR 0 5
5182: PPUSH
5183: CALL_OW 310
5187: IFFALSE 5205
// begin ComExitBuilding ( i ) ;
5189: LD_VAR 0 5
5193: PPUSH
5194: CALL_OW 122
// wait ( 3 ) ;
5198: LD_INT 3
5200: PPUSH
5201: CALL_OW 67
// end ; if tmp_empty then
5205: LD_VAR 0 4
5209: IFFALSE 5308
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5211: LD_VAR 0 5
5215: PPUSH
5216: LD_VAR 0 4
5220: PPUSH
5221: LD_VAR 0 5
5225: PPUSH
5226: CALL_OW 74
5230: PPUSH
5231: CALL_OW 296
5235: PUSH
5236: LD_INT 25
5238: LESS
5239: IFFALSE 5308
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5241: LD_ADDR_VAR 0 6
5245: PUSH
5246: LD_VAR 0 4
5250: PPUSH
5251: LD_VAR 0 5
5255: PPUSH
5256: CALL_OW 74
5260: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5261: LD_VAR 0 5
5265: PPUSH
5266: LD_VAR 0 6
5270: PPUSH
5271: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5275: LD_VAR 0 5
5279: PPUSH
5280: LD_INT 209
5282: PPUSH
5283: LD_INT 132
5285: PPUSH
5286: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: LD_VAR 0 4
5299: PUSH
5300: LD_VAR 0 6
5304: DIFF
5305: ST_TO_ADDR
// continue ;
5306: GO 5140
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5308: LD_VAR 0 5
5312: PPUSH
5313: LD_INT 201
5315: PPUSH
5316: LD_INT 132
5318: PPUSH
5319: CALL_OW 171
// end ;
5323: GO 5140
5325: POP
5326: POP
// for i in tmp_ape do
5327: LD_ADDR_VAR 0 5
5331: PUSH
5332: LD_VAR 0 3
5336: PUSH
5337: FOR_IN
5338: IFFALSE 5377
// begin if IsInUnit ( i ) then
5340: LD_VAR 0 5
5344: PPUSH
5345: CALL_OW 310
5349: IFFALSE 5360
// ComExitBuilding ( i ) ;
5351: LD_VAR 0 5
5355: PPUSH
5356: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5360: LD_VAR 0 5
5364: PPUSH
5365: LD_INT 201
5367: PPUSH
5368: LD_INT 132
5370: PPUSH
5371: CALL_OW 171
// end ;
5375: GO 5337
5377: POP
5378: POP
// repeat wait ( 0 0$1 ) ;
5379: LD_INT 35
5381: PPUSH
5382: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5386: LD_ADDR_VAR 0 5
5390: PUSH
5391: LD_VAR 0 2
5395: PUSH
5396: LD_VAR 0 3
5400: UNION
5401: PUSH
5402: LD_VAR 0 1
5406: UNION
5407: PUSH
5408: FOR_IN
5409: IFFALSE 5440
// if not HasTask ( i ) then
5411: LD_VAR 0 5
5415: PPUSH
5416: CALL_OW 314
5420: NOT
5421: IFFALSE 5438
// ComMoveXY ( i , 201 , 132 ) ;
5423: LD_VAR 0 5
5427: PPUSH
5428: LD_INT 201
5430: PPUSH
5431: LD_INT 132
5433: PPUSH
5434: CALL_OW 111
5438: GO 5408
5440: POP
5441: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5442: LD_INT 21
5444: PPUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 2
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PPUSH
5455: CALL_OW 70
5459: IFFALSE 5500
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5461: LD_ADDR_VAR 0 5
5465: PUSH
5466: LD_INT 21
5468: PPUSH
5469: LD_INT 22
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: CALL_OW 70
5483: PUSH
5484: FOR_IN
5485: IFFALSE 5498
// RemoveUnit ( i ) ;
5487: LD_VAR 0 5
5491: PPUSH
5492: CALL_OW 64
5496: GO 5484
5498: POP
5499: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5500: LD_INT 22
5502: PUSH
5503: LD_INT 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: LD_INT 21
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 21
5525: PUSH
5526: LD_INT 2
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL_OW 69
5546: NOT
5547: IFFALSE 5379
// end ;
5549: PPOPN 6
5551: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5552: LD_EXP 9
5556: PUSH
5557: LD_INT 92
5559: PPUSH
5560: LD_INT 40
5562: PPUSH
5563: CALL_OW 428
5567: PPUSH
5568: CALL_OW 266
5572: PUSH
5573: LD_INT 30
5575: EQUAL
5576: AND
5577: IFFALSE 5773
5579: GO 5581
5581: DISABLE
5582: LD_INT 0
5584: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: LD_EXP 59
5594: PUSH
5595: LD_INT 1
5597: ARRAY
5598: PPUSH
5599: LD_INT 25
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 72
5613: ST_TO_ADDR
// if not sci then
5614: LD_VAR 0 1
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 5773
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5623: LD_ADDR_EXP 59
5627: PUSH
5628: LD_EXP 59
5632: PPUSH
5633: LD_INT 1
5635: PPUSH
5636: LD_EXP 59
5640: PUSH
5641: LD_INT 1
5643: ARRAY
5644: PUSH
5645: LD_VAR 0 1
5649: PUSH
5650: LD_INT 1
5652: ARRAY
5653: DIFF
5654: PPUSH
5655: CALL_OW 1
5659: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5660: LD_VAR 0 1
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 310
5673: IFFALSE 5688
// ComExitBuilding ( sci [ 1 ] ) ;
5675: LD_VAR 0 1
5679: PUSH
5680: LD_INT 1
5682: ARRAY
5683: PPUSH
5684: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5688: LD_INT 2
5690: PPUSH
5691: LD_INT 105
5693: PPUSH
5694: LD_INT 14
5696: PPUSH
5697: LD_INT 20
5699: PPUSH
5700: CALL 20622 0 4
5704: PUSH
5705: LD_INT 4
5707: ARRAY
5708: PUSH
5709: LD_INT 10
5711: LESS
5712: IFFALSE 5735
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5714: LD_VAR 0 1
5718: PUSH
5719: LD_INT 1
5721: ARRAY
5722: PPUSH
5723: LD_INT 105
5725: PPUSH
5726: LD_INT 14
5728: PPUSH
5729: CALL_OW 171
5733: GO 5754
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5735: LD_VAR 0 1
5739: PUSH
5740: LD_INT 1
5742: ARRAY
5743: PPUSH
5744: LD_INT 118
5746: PPUSH
5747: LD_INT 77
5749: PPUSH
5750: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 1
5761: ARRAY
5762: PPUSH
5763: LD_INT 92
5765: PPUSH
5766: LD_INT 40
5768: PPUSH
5769: CALL_OW 218
// end ;
5773: PPOPN 1
5775: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5776: LD_INT 1
5778: PPUSH
5779: CALL_OW 302
5783: PUSH
5784: LD_EXP 9
5788: AND
5789: IFFALSE 6268
5791: GO 5793
5793: DISABLE
5794: LD_INT 0
5796: PPUSH
5797: PPUSH
5798: PPUSH
5799: PPUSH
5800: PPUSH
5801: PPUSH
// begin enable ;
5802: ENABLE
// base := 1 ;
5803: LD_ADDR_VAR 0 2
5807: PUSH
5808: LD_INT 1
5810: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5811: LD_ADDR_VAR 0 4
5815: PUSH
5816: LD_INT 0
5818: PUSH
5819: LD_INT 0
5821: PUSH
5822: LD_INT 0
5824: PUSH
5825: LD_INT 0
5827: PUSH
5828: LD_INT 0
5830: PUSH
5831: LD_INT 0
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 1
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5858: LD_ADDR_VAR 0 3
5862: PUSH
5863: LD_INT 14
5865: PUSH
5866: LD_INT 1
5868: PUSH
5869: LD_INT 2
5871: PUSH
5872: LD_INT 26
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 14
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 29
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5922: LD_ADDR_VAR 0 1
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_OWVAR 67
5936: PUSH
5937: LD_OWVAR 1
5941: PUSH
5942: LD_INT 21000
5944: DIV
5945: PLUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 6040
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5950: LD_ADDR_VAR 0 3
5954: PUSH
5955: LD_VAR 0 3
5959: PPUSH
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 1
5967: PLUS
5968: PPUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 14
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 1
5981: PPUSH
5982: LD_INT 2
5984: PPUSH
5985: CALL_OW 12
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: LD_INT 2
5996: PUSH
5997: LD_INT 28
5999: PUSH
6000: LD_INT 29
6002: PUSH
6003: LD_INT 25
6005: PUSH
6006: LD_INT 26
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 4
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 2
6037: ST_TO_ADDR
6038: GO 5947
6040: POP
6041: POP
// MC_InsertProduceList ( base , tmp ) ;
6042: LD_VAR 0 2
6046: PPUSH
6047: LD_VAR 0 3
6051: PPUSH
6052: CALL 77133 0 2
// repeat wait ( 0 0$1 ) ;
6056: LD_INT 35
6058: PPUSH
6059: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6063: LD_EXP 78
6067: PUSH
6068: LD_VAR 0 2
6072: ARRAY
6073: PUSH
6074: LD_INT 6
6076: GREATER
6077: IFFALSE 6056
// wait ( 0 0$20 ) ;
6079: LD_INT 700
6081: PPUSH
6082: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6086: LD_ADDR_VAR 0 5
6090: PUSH
6091: LD_INT 124
6093: PUSH
6094: LD_INT 85
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 90
6103: PUSH
6104: LD_INT 61
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 69
6113: PUSH
6114: LD_INT 48
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 68
6123: PUSH
6124: LD_INT 48
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6137: LD_ADDR_VAR 0 6
6141: PUSH
6142: LD_EXP 78
6146: PUSH
6147: LD_VAR 0 2
6151: ARRAY
6152: PUSH
6153: LD_EXP 78
6157: PUSH
6158: LD_VAR 0 2
6162: ARRAY
6163: PPUSH
6164: LD_INT 2
6166: PUSH
6167: LD_INT 34
6169: PUSH
6170: LD_INT 32
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 34
6179: PUSH
6180: LD_EXP 109
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: DIFF
6199: ST_TO_ADDR
// if not attackers then
6200: LD_VAR 0 6
6204: NOT
6205: IFFALSE 6209
// exit ;
6207: GO 6268
// ar_attackers := attackers ;
6209: LD_ADDR_EXP 10
6213: PUSH
6214: LD_VAR 0 6
6218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6219: LD_INT 35
6221: PPUSH
6222: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6226: LD_VAR 0 6
6230: PPUSH
6231: LD_INT 60
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: NOT
6242: IFFALSE 6219
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6244: LD_VAR 0 2
6248: PPUSH
6249: LD_VAR 0 6
6253: PPUSH
6254: LD_VAR 0 5
6258: PPUSH
6259: LD_VAR 0 4
6263: PPUSH
6264: CALL 77318 0 4
// end ;
6268: PPOPN 6
6270: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 302
6278: PUSH
6279: LD_EXP 9
6283: AND
6284: PUSH
6285: LD_EXP 49
6289: PPUSH
6290: LD_INT 22
6292: PPUSH
6293: CALL_OW 308
6297: AND
6298: PUSH
6299: LD_INT 1
6301: PPUSH
6302: CALL 77481 0 1
6306: PUSH
6307: LD_INT 0
6309: EQUAL
6310: AND
6311: PUSH
6312: LD_EXP 10
6316: NOT
6317: AND
6318: IFFALSE 6802
6320: GO 6322
6322: DISABLE
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
6331: PPUSH
// begin base := 1 ;
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: LD_INT 1
6339: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: LD_INT 0
6362: PUSH
6363: LD_INT 0
6365: PUSH
6366: LD_INT 0
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: LD_INT 0
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: LIST
6385: LIST
6386: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_INT 13
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 28
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 13
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 27
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 11
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 24
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6489: LD_VAR 0 2
6493: PPUSH
6494: LD_VAR 0 3
6498: PPUSH
6499: CALL 77133 0 2
// repeat wait ( 0 0$1 ) ;
6503: LD_INT 35
6505: PPUSH
6506: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6510: LD_EXP 78
6514: PUSH
6515: LD_VAR 0 2
6519: ARRAY
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: IFFALSE 6503
// wait ( 0 0$20 ) ;
6526: LD_INT 700
6528: PPUSH
6529: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6533: LD_ADDR_VAR 0 5
6537: PUSH
6538: LD_INT 119
6540: PUSH
6541: LD_INT 9
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6551: LD_ADDR_VAR 0 6
6555: PUSH
6556: LD_EXP 78
6560: PUSH
6561: LD_VAR 0 2
6565: ARRAY
6566: PUSH
6567: LD_EXP 78
6571: PUSH
6572: LD_VAR 0 2
6576: ARRAY
6577: PPUSH
6578: LD_INT 2
6580: PUSH
6581: LD_INT 34
6583: PUSH
6584: LD_INT 32
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 34
6593: PUSH
6594: LD_EXP 109
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: DIFF
6613: ST_TO_ADDR
// if not attackers then
6614: LD_VAR 0 6
6618: NOT
6619: IFFALSE 6623
// exit ;
6621: GO 6802
// uc_side := 2 ;
6623: LD_ADDR_OWVAR 20
6627: PUSH
6628: LD_INT 2
6630: ST_TO_ADDR
// uc_nation := 2 ;
6631: LD_ADDR_OWVAR 21
6635: PUSH
6636: LD_INT 2
6638: ST_TO_ADDR
// InitHc ;
6639: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6643: LD_ADDR_VAR 0 1
6647: PUSH
6648: DOUBLE
6649: LD_INT 1
6651: DEC
6652: ST_TO_ADDR
6653: LD_INT 4
6655: PUSH
6656: LD_INT 5
6658: PUSH
6659: LD_INT 6
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: PUSH
6667: LD_OWVAR 67
6671: ARRAY
6672: PUSH
6673: FOR_TO
6674: IFFALSE 6751
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6676: LD_INT 0
6678: PPUSH
6679: LD_INT 15
6681: PUSH
6682: LD_INT 17
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 2
6694: PPUSH
6695: CALL_OW 12
6699: ARRAY
6700: PPUSH
6701: LD_INT 8
6703: PPUSH
6704: CALL_OW 380
// un := CreateHuman ;
6708: LD_ADDR_VAR 0 7
6712: PUSH
6713: CALL_OW 44
6717: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6718: LD_VAR 0 7
6722: PPUSH
6723: LD_INT 23
6725: PPUSH
6726: LD_INT 0
6728: PPUSH
6729: CALL_OW 49
// attackers := attackers union un ;
6733: LD_ADDR_VAR 0 6
6737: PUSH
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 7
6747: UNION
6748: ST_TO_ADDR
// end ;
6749: GO 6673
6751: POP
6752: POP
// repeat wait ( 0 0$1 ) ;
6753: LD_INT 35
6755: PPUSH
6756: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_INT 60
6767: PUSH
6768: EMPTY
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: NOT
6776: IFFALSE 6753
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6778: LD_VAR 0 2
6782: PPUSH
6783: LD_VAR 0 6
6787: PPUSH
6788: LD_VAR 0 5
6792: PPUSH
6793: LD_VAR 0 4
6797: PPUSH
6798: CALL 77318 0 4
// end ; end_of_file
6802: PPOPN 7
6804: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6805: LD_INT 0
6807: PPUSH
6808: PPUSH
6809: PPUSH
6810: PPUSH
6811: PPUSH
6812: PPUSH
// uc_side := 1 ;
6813: LD_ADDR_OWVAR 20
6817: PUSH
6818: LD_INT 1
6820: ST_TO_ADDR
// uc_nation := 1 ;
6821: LD_ADDR_OWVAR 21
6825: PUSH
6826: LD_INT 1
6828: ST_TO_ADDR
// InitHc ;
6829: CALL_OW 19
// InitVc ;
6833: CALL_OW 20
// tmp := [ ] ;
6837: LD_ADDR_VAR 0 3
6841: PUSH
6842: EMPTY
6843: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 ] [ Difficulty ] do
6844: LD_ADDR_VAR 0 2
6848: PUSH
6849: DOUBLE
6850: LD_INT 1
6852: DEC
6853: ST_TO_ADDR
6854: LD_INT 6
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: LD_INT 10
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_OWVAR 67
6872: ARRAY
6873: PUSH
6874: FOR_TO
6875: IFFALSE 7149
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6877: LD_ADDR_VAR 0 5
6881: PUSH
6882: LD_INT 2
6884: PUSH
6885: LD_INT 4
6887: PUSH
6888: LD_INT 5
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 1
6898: PPUSH
6899: LD_INT 3
6901: PPUSH
6902: CALL_OW 12
6906: ARRAY
6907: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6908: LD_VAR 0 5
6912: PUSH
6913: LD_INT 2
6915: DOUBLE
6916: EQUAL
6917: IFTRUE 6921
6919: GO 6955
6921: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6922: LD_ADDR_VAR 0 6
6926: PUSH
6927: LD_INT 9
6929: PUSH
6930: LD_INT 5
6932: PUSH
6933: LD_INT 7
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 3
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: ST_TO_ADDR
6953: GO 7044
6955: LD_INT 4
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 7001
6963: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: LD_INT 9
6971: PUSH
6972: LD_INT 6
6974: PUSH
6975: LD_INT 6
6977: PUSH
6978: LD_INT 7
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: LD_INT 1
6989: PPUSH
6990: LD_INT 4
6992: PPUSH
6993: CALL_OW 12
6997: ARRAY
6998: ST_TO_ADDR
6999: GO 7044
7001: LD_INT 5
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7043
7009: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7010: LD_ADDR_VAR 0 6
7014: PUSH
7015: LD_INT 9
7017: PUSH
7018: LD_INT 6
7020: PUSH
7021: LD_INT 7
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 1
7031: PPUSH
7032: LD_INT 3
7034: PPUSH
7035: CALL_OW 12
7039: ARRAY
7040: ST_TO_ADDR
7041: GO 7044
7043: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7044: LD_VAR 0 5
7048: PPUSH
7049: LD_INT 1
7051: PUSH
7052: LD_INT 3
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 1
7061: PPUSH
7062: LD_INT 2
7064: PPUSH
7065: CALL_OW 12
7069: ARRAY
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_VAR 0 6
7078: PPUSH
7079: LD_INT 70
7081: PPUSH
7082: LD_INT 90
7084: PPUSH
7085: CALL_OW 12
7089: PPUSH
7090: CALL 19604 0 5
// veh := CreateVehicle ;
7094: LD_ADDR_VAR 0 4
7098: PUSH
7099: CALL_OW 45
7103: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7104: LD_VAR 0 4
7108: PPUSH
7109: LD_INT 2
7111: PPUSH
7112: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7116: LD_VAR 0 4
7120: PPUSH
7121: LD_INT 17
7123: PPUSH
7124: LD_INT 0
7126: PPUSH
7127: CALL_OW 49
// tmp := tmp ^ veh ;
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: LD_VAR 0 3
7140: PUSH
7141: LD_VAR 0 4
7145: ADD
7146: ST_TO_ADDR
// end ;
7147: GO 6874
7149: POP
7150: POP
// if not tmp then
7151: LD_VAR 0 3
7155: NOT
7156: IFFALSE 7160
// exit ;
7158: GO 7269
// if not first_powell_attack then
7160: LD_EXP 11
7164: NOT
7165: IFFALSE 7175
// first_powell_attack := true ;
7167: LD_ADDR_EXP 11
7171: PUSH
7172: LD_INT 1
7174: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7175: LD_INT 70
7177: PPUSH
7178: CALL_OW 67
// for i in tmp do
7182: LD_ADDR_VAR 0 2
7186: PUSH
7187: LD_VAR 0 3
7191: PUSH
7192: FOR_IN
7193: IFFALSE 7260
// if IsOk ( i ) then
7195: LD_VAR 0 2
7199: PPUSH
7200: CALL_OW 302
7204: IFFALSE 7242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7206: LD_VAR 0 2
7210: PPUSH
7211: LD_INT 81
7213: PUSH
7214: LD_INT 1
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: LD_VAR 0 2
7230: PPUSH
7231: CALL_OW 74
7235: PPUSH
7236: CALL_OW 115
7240: GO 7258
// tmp := tmp diff i ;
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: LD_VAR 0 3
7251: PUSH
7252: LD_VAR 0 2
7256: DIFF
7257: ST_TO_ADDR
7258: GO 7192
7260: POP
7261: POP
// until not tmp ;
7262: LD_VAR 0 3
7266: NOT
7267: IFFALSE 7175
// end ; end_of_file
7269: LD_VAR 0 1
7273: RET
// export function Action ; var tmp , i , un ; begin
7274: LD_INT 0
7276: PPUSH
7277: PPUSH
7278: PPUSH
7279: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7280: LD_INT 68
7282: PPUSH
7283: LD_INT 39
7285: PPUSH
7286: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: ST_TO_ADDR
// InGameOn ;
7310: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7314: LD_VAR 0 2
7318: PPUSH
7319: LD_INT 71
7321: PPUSH
7322: LD_INT 49
7324: PPUSH
7325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7329: LD_INT 35
7331: PPUSH
7332: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7336: LD_INT 7
7338: PPUSH
7339: LD_INT 71
7341: PPUSH
7342: LD_INT 51
7344: PPUSH
7345: CALL_OW 293
7349: IFFALSE 7329
// DialogueOn ;
7351: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7355: LD_EXP 15
7359: PPUSH
7360: LD_STRING D1-JMM-1
7362: PPUSH
7363: CALL_OW 88
// if Joan then
7367: LD_EXP 30
7371: IFFALSE 7385
// Say ( Joan , D1-Joan-1 ) ;
7373: LD_EXP 30
7377: PPUSH
7378: LD_STRING D1-Joan-1
7380: PPUSH
7381: CALL_OW 88
// if Lisa then
7385: LD_EXP 17
7389: IFFALSE 7403
// Say ( Lisa , D1-Lisa-1 ) ;
7391: LD_EXP 17
7395: PPUSH
7396: LD_STRING D1-Lisa-1
7398: PPUSH
7399: CALL_OW 88
// if Joan or Lisa then
7403: LD_EXP 30
7407: PUSH
7408: LD_EXP 17
7412: OR
7413: IFFALSE 7427
// Say ( JMM , D1-JMM-2 ) ;
7415: LD_EXP 15
7419: PPUSH
7420: LD_STRING D1-JMM-2
7422: PPUSH
7423: CALL_OW 88
// DialogueOff ;
7427: CALL_OW 7
// InGameOff ;
7431: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7435: LD_INT 71
7437: PPUSH
7438: LD_INT 50
7440: PPUSH
7441: LD_INT 7
7443: PPUSH
7444: LD_INT 30
7446: NEG
7447: PPUSH
7448: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7452: LD_INT 71
7454: PPUSH
7455: LD_INT 50
7457: PPUSH
7458: LD_INT 7
7460: PPUSH
7461: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7465: LD_STRING M1
7467: PPUSH
7468: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7472: LD_INT 35
7474: PPUSH
7475: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7479: LD_EXP 3
7483: PUSH
7484: LD_OWVAR 1
7488: PUSH
7489: LD_INT 2100
7491: GREATER
7492: OR
7493: IFFALSE 7472
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7495: LD_INT 350
7497: PPUSH
7498: LD_INT 700
7500: PPUSH
7501: CALL_OW 12
7505: PPUSH
7506: CALL_OW 67
// PrepareGossudarov ;
7510: CALL 1865 0 0
// repeat wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7521: LD_INT 22
7523: PUSH
7524: LD_INT 6
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PUSH
7531: LD_INT 3
7533: PUSH
7534: LD_INT 24
7536: PUSH
7537: LD_INT 1000
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: PUSH
7557: LD_INT 7
7559: PPUSH
7560: LD_EXP 32
7564: PPUSH
7565: CALL_OW 292
7569: OR
7570: IFFALSE 7514
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_INT 22
7579: PUSH
7580: LD_INT 6
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 69
7591: ST_TO_ADDR
// for i in tmp do
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_VAR 0 2
7601: PUSH
7602: FOR_IN
7603: IFFALSE 7619
// SetSide ( i , 7 ) ;
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 7
7612: PPUSH
7613: CALL_OW 235
7617: GO 7602
7619: POP
7620: POP
// DialogueOn ;
7621: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7625: LD_EXP 15
7629: PUSH
7630: LD_EXP 16
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: LD_EXP 32
7643: PPUSH
7644: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7648: LD_EXP 32
7652: PPUSH
7653: CALL_OW 87
// if not Roth then
7657: LD_EXP 16
7661: NOT
7662: IFFALSE 7754
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7664: LD_VAR 0 2
7668: PPUSH
7669: LD_INT 3
7671: PUSH
7672: LD_INT 24
7674: PUSH
7675: LD_INT 1000
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PPUSH
7686: CALL_OW 72
7690: IFFALSE 7704
// Say ( JMM , D2-JMM-1 ) ;
7692: LD_EXP 15
7696: PPUSH
7697: LD_STRING D2-JMM-1
7699: PPUSH
7700: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7704: LD_EXP 15
7708: PPUSH
7709: LD_STRING D2-JMM-1b
7711: PPUSH
7712: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7716: LD_EXP 32
7720: PPUSH
7721: LD_STRING D2-Gos-1
7723: PPUSH
7724: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7728: LD_EXP 15
7732: PPUSH
7733: LD_STRING D2-JMM-2
7735: PPUSH
7736: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7740: LD_EXP 32
7744: PPUSH
7745: LD_STRING D2-Gos-2
7747: PPUSH
7748: CALL_OW 88
// end else
7752: GO 7906
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7754: LD_VAR 0 2
7758: PPUSH
7759: LD_INT 3
7761: PUSH
7762: LD_INT 24
7764: PUSH
7765: LD_INT 1000
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PPUSH
7776: CALL_OW 72
7780: IFFALSE 7806
// begin Say ( Roth , D2-Roth-2 ) ;
7782: LD_EXP 16
7786: PPUSH
7787: LD_STRING D2-Roth-2
7789: PPUSH
7790: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7794: LD_EXP 15
7798: PPUSH
7799: LD_STRING D2-JMM-1a
7801: PPUSH
7802: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-Roth-2a
7813: PPUSH
7814: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7818: LD_EXP 16
7822: PPUSH
7823: LD_STRING D2-Roth-2b
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7830: LD_EXP 15
7834: PPUSH
7835: LD_STRING D2-JMM-3
7837: PPUSH
7838: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7842: LD_VAR 0 2
7846: PPUSH
7847: LD_INT 3
7849: PUSH
7850: LD_INT 24
7852: PUSH
7853: LD_INT 1000
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PPUSH
7864: CALL_OW 72
7868: IFFALSE 7906
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7870: LD_EXP 32
7874: PPUSH
7875: LD_STRING D2-Gos-3
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7882: LD_EXP 15
7886: PPUSH
7887: LD_STRING D2-JMM-4
7889: PPUSH
7890: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7894: LD_EXP 32
7898: PPUSH
7899: LD_STRING D2-Gos-4
7901: PPUSH
7902: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7906: LD_EXP 15
7910: PPUSH
7911: LD_STRING D2-JMM-5
7913: PPUSH
7914: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7918: LD_EXP 32
7922: PPUSH
7923: LD_STRING D2-Gos-5
7925: PPUSH
7926: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7930: LD_EXP 15
7934: PPUSH
7935: LD_STRING D2-JMM-6
7937: PPUSH
7938: CALL_OW 88
// DialogueOff ;
7942: CALL_OW 7
// wait ( 0 0$2 ) ;
7946: LD_INT 70
7948: PPUSH
7949: CALL_OW 67
// if Kirilenkova then
7953: LD_EXP 33
7957: IFFALSE 7971
// Say ( Kirilenkova , D3-Kir-1 ) ;
7959: LD_EXP 33
7963: PPUSH
7964: LD_STRING D3-Kir-1
7966: PPUSH
7967: CALL_OW 88
// gossudarov_arrive := true ;
7971: LD_ADDR_EXP 4
7975: PUSH
7976: LD_INT 1
7978: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7979: LD_INT 35
7981: PPUSH
7982: CALL_OW 67
// until ru_lab_builded ;
7986: LD_EXP 5
7990: IFFALSE 7979
// DialogueOn ;
7992: CALL_OW 6
// if Kirilenkova then
7996: LD_EXP 33
8000: IFFALSE 8016
// Say ( Kirilenkova , D3a-Kir-1 ) else
8002: LD_EXP 33
8006: PPUSH
8007: LD_STRING D3a-Kir-1
8009: PPUSH
8010: CALL_OW 88
8014: GO 8038
// begin un := SciRu ;
8016: LD_ADDR_VAR 0 4
8020: PUSH
8021: CALL 13167 0 0
8025: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8026: LD_VAR 0 4
8030: PPUSH
8031: LD_STRING D3a-Sci1-1
8033: PPUSH
8034: CALL_OW 88
// end ; if Kirilenkova or un then
8038: LD_EXP 33
8042: PUSH
8043: LD_VAR 0 4
8047: OR
8048: IFFALSE 8062
// Say ( JMM , D3a-JMM-1 ) ;
8050: LD_EXP 15
8054: PPUSH
8055: LD_STRING D3a-JMM-1
8057: PPUSH
8058: CALL_OW 88
// DialogueOff ;
8062: CALL_OW 7
// end ;
8066: LD_VAR 0 1
8070: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8071: LD_EXP 4
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 7
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 2
8088: PUSH
8089: LD_INT 25
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 25
8101: PUSH
8102: LD_INT 2
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 25
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: LD_INT 25
8121: PUSH
8122: LD_INT 4
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: LD_INT 25
8131: PUSH
8132: LD_INT 5
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_INT 25
8141: PUSH
8142: LD_INT 8
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 25
8151: PUSH
8152: LD_INT 9
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 7
8180: LESS
8181: AND
8182: IFFALSE 8194
8184: GO 8186
8186: DISABLE
// YouLost ( TooMany ) ;
8187: LD_STRING TooMany
8189: PPUSH
8190: CALL_OW 104
8194: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8195: LD_EXP 32
8199: PPUSH
8200: CALL_OW 255
8204: PUSH
8205: LD_INT 7
8207: EQUAL
8208: IFFALSE 8425
8210: GO 8212
8212: DISABLE
8213: LD_INT 0
8215: PPUSH
8216: PPUSH
8217: PPUSH
// begin uc_side := 3 ;
8218: LD_ADDR_OWVAR 20
8222: PUSH
8223: LD_INT 3
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8234: LD_INT 21
8236: PPUSH
8237: LD_INT 3
8239: PPUSH
8240: LD_INT 3
8242: PPUSH
8243: LD_INT 42
8245: PPUSH
8246: LD_INT 100
8248: PPUSH
8249: CALL 19604 0 5
// un := CreateVehicle ;
8253: LD_ADDR_VAR 0 3
8257: PUSH
8258: CALL_OW 45
8262: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8263: LD_VAR 0 3
8267: PPUSH
8268: LD_INT 15
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8278: LD_VAR 0 3
8282: PPUSH
8283: LD_INT 67
8285: PPUSH
8286: LD_INT 45
8288: PPUSH
8289: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8293: LD_VAR 0 3
8297: PPUSH
8298: LD_INT 70
8300: PPUSH
8301: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 69
8312: PPUSH
8313: LD_INT 18
8315: PPUSH
8316: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_INT 60
8327: PPUSH
8328: LD_INT 3
8330: PPUSH
8331: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8335: LD_INT 35
8337: PPUSH
8338: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8342: LD_VAR 0 3
8346: PPUSH
8347: CALL_OW 302
8351: NOT
8352: PUSH
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 17
8360: PPUSH
8361: CALL_OW 308
8365: OR
8366: PUSH
8367: LD_VAR 0 3
8371: PPUSH
8372: LD_INT 60
8374: PPUSH
8375: LD_INT 3
8377: PPUSH
8378: CALL_OW 307
8382: OR
8383: IFFALSE 8335
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_INT 17
8392: PPUSH
8393: CALL_OW 308
8397: PUSH
8398: LD_VAR 0 3
8402: PPUSH
8403: LD_INT 60
8405: PPUSH
8406: LD_INT 3
8408: PPUSH
8409: CALL_OW 307
8413: OR
8414: IFFALSE 8425
// RemoveUnit ( un ) ;
8416: LD_VAR 0 3
8420: PPUSH
8421: CALL_OW 64
// end ;
8425: PPOPN 3
8427: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8428: LD_EXP 4
8432: IFFALSE 8674
8434: GO 8436
8436: DISABLE
8437: LD_INT 0
8439: PPUSH
8440: PPUSH
8441: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8442: LD_INT 70
8444: PPUSH
8445: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8449: LD_ADDR_VAR 0 3
8453: PUSH
8454: LD_INT 22
8456: PUSH
8457: LD_INT 7
8459: PUSH
8460: EMPTY
8461: LIST
8462: LIST
8463: PUSH
8464: LD_INT 101
8466: PUSH
8467: LD_INT 3
8469: PUSH
8470: EMPTY
8471: LIST
8472: LIST
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: PPUSH
8478: CALL_OW 69
8482: ST_TO_ADDR
// until tmp ;
8483: LD_VAR 0 3
8487: IFFALSE 8442
// un := NearestUnitToUnit ( tmp , JMM ) ;
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_VAR 0 3
8498: PPUSH
8499: LD_EXP 15
8503: PPUSH
8504: CALL_OW 74
8508: ST_TO_ADDR
// player_spotted := true ;
8509: LD_ADDR_EXP 6
8513: PUSH
8514: LD_INT 1
8516: ST_TO_ADDR
// tmp := SciRu ;
8517: LD_ADDR_VAR 0 3
8521: PUSH
8522: CALL 13167 0 0
8526: ST_TO_ADDR
// if not tmp then
8527: LD_VAR 0 3
8531: NOT
8532: IFFALSE 8544
// tmp := SolRu ;
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: CALL 13314 0 0
8543: ST_TO_ADDR
// DialogueOn ;
8544: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8548: LD_VAR 0 2
8552: PPUSH
8553: CALL_OW 250
8557: PPUSH
8558: LD_VAR 0 2
8562: PPUSH
8563: CALL_OW 251
8567: PPUSH
8568: LD_INT 7
8570: PPUSH
8571: LD_INT 8
8573: NEG
8574: PPUSH
8575: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8579: LD_VAR 0 2
8583: PPUSH
8584: CALL_OW 87
// if tmp then
8588: LD_VAR 0 3
8592: IFFALSE 8606
// Say ( tmp , D4-RSci1-1 ) ;
8594: LD_VAR 0 3
8598: PPUSH
8599: LD_STRING D4-RSci1-1
8601: PPUSH
8602: CALL_OW 88
// if Gossudarov then
8606: LD_EXP 32
8610: IFFALSE 8636
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8612: LD_EXP 32
8616: PPUSH
8617: LD_STRING D4-Gos-1
8619: PPUSH
8620: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8624: LD_EXP 15
8628: PPUSH
8629: LD_STRING D4-JMM-1
8631: PPUSH
8632: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8636: LD_VAR 0 2
8640: PPUSH
8641: CALL_OW 250
8645: PPUSH
8646: LD_VAR 0 2
8650: PPUSH
8651: CALL_OW 251
8655: PPUSH
8656: LD_INT 7
8658: PPUSH
8659: CALL_OW 331
// DialogueOff ;
8663: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8667: LD_STRING M5
8669: PPUSH
8670: CALL_OW 337
// end ;
8674: PPOPN 3
8676: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8677: LD_EXP 6
8681: IFFALSE 9270
8683: GO 8685
8685: DISABLE
8686: LD_INT 0
8688: PPUSH
8689: PPUSH
8690: PPUSH
// begin PrepareBelkov ;
8691: CALL 2178 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8695: LD_EXP 47
8699: PPUSH
8700: LD_INT 118
8702: PPUSH
8703: LD_INT 106
8705: PPUSH
8706: CALL_OW 111
// AddComHold ( Belkov ) ;
8710: LD_EXP 47
8714: PPUSH
8715: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8719: LD_INT 35
8721: PPUSH
8722: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8726: LD_EXP 47
8730: PPUSH
8731: LD_INT 118
8733: PPUSH
8734: LD_INT 106
8736: PPUSH
8737: CALL_OW 307
8741: IFFALSE 8719
// ChangeSideFog ( 4 , 7 ) ;
8743: LD_INT 4
8745: PPUSH
8746: LD_INT 7
8748: PPUSH
8749: CALL_OW 343
// if IsOk ( Belkov ) then
8753: LD_EXP 47
8757: PPUSH
8758: CALL_OW 302
8762: IFFALSE 8846
// begin InGameOn ;
8764: CALL_OW 8
// DialogueOn ;
8768: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8772: LD_EXP 47
8776: PPUSH
8777: LD_STRING D5-Bel-1
8779: PPUSH
8780: CALL_OW 94
// if Gossudarov then
8784: LD_EXP 32
8788: IFFALSE 8838
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8790: LD_EXP 32
8794: PPUSH
8795: LD_STRING D5-Gos-1
8797: PPUSH
8798: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8802: LD_EXP 15
8806: PPUSH
8807: LD_STRING D5-JMM-1
8809: PPUSH
8810: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8814: LD_EXP 32
8818: PPUSH
8819: LD_STRING D5-Gos-2
8821: PPUSH
8822: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8826: LD_EXP 15
8830: PPUSH
8831: LD_STRING D5-JMM-2
8833: PPUSH
8834: CALL_OW 88
// end ; DialogueOff ;
8838: CALL_OW 7
// InGameOff ;
8842: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8846: LD_STRING QSaveBelkov
8848: PPUSH
8849: CALL_OW 97
8853: PUSH
8854: LD_INT 1
8856: DOUBLE
8857: EQUAL
8858: IFTRUE 8862
8860: GO 8912
8862: POP
// begin DialogueOn ;
8863: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8867: LD_EXP 15
8871: PPUSH
8872: LD_STRING D5a-JMM-1
8874: PPUSH
8875: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8879: LD_EXP 47
8883: PPUSH
8884: LD_STRING D5a-Bel-1
8886: PPUSH
8887: CALL_OW 94
// DialogueOff ;
8891: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8895: LD_EXP 47
8899: PPUSH
8900: LD_INT 83
8902: PPUSH
8903: LD_INT 49
8905: PPUSH
8906: CALL_OW 111
// end ; 2 :
8910: GO 8945
8912: LD_INT 2
8914: DOUBLE
8915: EQUAL
8916: IFTRUE 8920
8918: GO 8944
8920: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8921: LD_EXP 15
8925: PPUSH
8926: LD_STRING D5a-JMM-2
8928: PPUSH
8929: CALL_OW 88
// ComHold ( Belkov ) ;
8933: LD_EXP 47
8937: PPUSH
8938: CALL_OW 140
// end ; end ;
8942: GO 8945
8944: POP
// time := 0 0$00 ;
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: LD_INT 0
8952: ST_TO_ADDR
// vehSpawned := false ;
8953: LD_ADDR_VAR 0 3
8957: PUSH
8958: LD_INT 0
8960: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8961: LD_INT 35
8963: PPUSH
8964: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8968: LD_VAR 0 1
8972: PUSH
8973: LD_INT 350
8975: PUSH
8976: LD_INT 175
8978: PUSH
8979: LD_INT 70
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: LIST
8986: PUSH
8987: LD_OWVAR 67
8991: ARRAY
8992: GREATEREQUAL
8993: PUSH
8994: LD_VAR 0 3
8998: NOT
8999: AND
9000: IFFALSE 9090
// begin vehSpawned := true ;
9002: LD_ADDR_VAR 0 3
9006: PUSH
9007: LD_INT 1
9009: ST_TO_ADDR
// uc_side := 3 ;
9010: LD_ADDR_OWVAR 20
9014: PUSH
9015: LD_INT 3
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9026: LD_INT 22
9028: PPUSH
9029: LD_INT 3
9031: PPUSH
9032: LD_INT 3
9034: PPUSH
9035: LD_INT 43
9037: PPUSH
9038: LD_INT 100
9040: PPUSH
9041: CALL 19604 0 5
// veh := CreateVehicle ;
9045: LD_ADDR_VAR 0 2
9049: PUSH
9050: CALL_OW 45
9054: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: LD_INT 130
9062: PPUSH
9063: LD_INT 131
9065: PPUSH
9066: LD_INT 0
9068: PPUSH
9069: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9073: LD_VAR 0 2
9077: PPUSH
9078: LD_INT 100
9080: PPUSH
9081: LD_INT 82
9083: PPUSH
9084: CALL_OW 114
// end else
9088: GO 9104
// time := time + 0 0$1 ;
9090: LD_ADDR_VAR 0 1
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: LD_INT 35
9102: PLUS
9103: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9104: LD_EXP 47
9108: PPUSH
9109: CALL_OW 301
9113: PUSH
9114: LD_EXP 47
9118: PPUSH
9119: CALL_OW 255
9123: PUSH
9124: LD_INT 4
9126: EQUAL
9127: AND
9128: PUSH
9129: LD_INT 22
9131: PUSH
9132: LD_INT 7
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: PPUSH
9144: LD_EXP 47
9148: PPUSH
9149: CALL_OW 74
9153: PPUSH
9154: LD_EXP 47
9158: PPUSH
9159: CALL_OW 296
9163: PUSH
9164: LD_INT 10
9166: LESS
9167: OR
9168: IFFALSE 8961
// if IsDead ( Belkov ) then
9170: LD_EXP 47
9174: PPUSH
9175: CALL_OW 301
9179: IFFALSE 9204
// begin CenterNowOnUnits ( Belkov ) ;
9181: LD_EXP 47
9185: PPUSH
9186: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9190: LD_EXP 15
9194: PPUSH
9195: LD_STRING D5a-JMM-2a
9197: PPUSH
9198: CALL_OW 88
// exit ;
9202: GO 9270
// end ; if See ( 7 , Belkov ) then
9204: LD_INT 7
9206: PPUSH
9207: LD_EXP 47
9211: PPUSH
9212: CALL_OW 292
9216: IFFALSE 9230
// SetSide ( Belkov , 7 ) ;
9218: LD_EXP 47
9222: PPUSH
9223: LD_INT 7
9225: PPUSH
9226: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9230: LD_INT 35
9232: PPUSH
9233: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9237: LD_EXP 47
9241: PPUSH
9242: LD_INT 66
9244: PPUSH
9245: LD_INT 45
9247: PPUSH
9248: CALL_OW 297
9252: PUSH
9253: LD_INT 30
9255: LESS
9256: IFFALSE 9230
// Say ( Belkov , D6-Bel-1 ) ;
9258: LD_EXP 47
9262: PPUSH
9263: LD_STRING D6-Bel-1
9265: PPUSH
9266: CALL_OW 88
// end ;
9270: PPOPN 3
9272: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9273: LD_EXP 47
9277: PPUSH
9278: CALL_OW 302
9282: PUSH
9283: LD_EXP 47
9287: PPUSH
9288: CALL_OW 504
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: LD_INT 34
9298: PUSH
9299: LD_INT 47
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PUSH
9306: LD_INT 34
9308: PUSH
9309: LD_INT 45
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: LIST
9320: PPUSH
9321: CALL_OW 69
9325: IN
9326: AND
9327: IFFALSE 9344
9329: GO 9331
9331: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9332: LD_EXP 47
9336: PPUSH
9337: LD_STRING D7-Bel-1
9339: PPUSH
9340: CALL_OW 88
9344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9345: LD_INT 22
9347: PUSH
9348: LD_INT 7
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: LD_INT 101
9357: PUSH
9358: LD_INT 2
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PPUSH
9369: CALL_OW 69
9373: PUSH
9374: LD_EXP 8
9378: NOT
9379: AND
9380: PUSH
9381: LD_EXP 46
9385: PPUSH
9386: CALL_OW 305
9390: NOT
9391: AND
9392: IFFALSE 9862
9394: GO 9396
9396: DISABLE
9397: LD_INT 0
9399: PPUSH
// begin ar_base_spotted := true ;
9400: LD_ADDR_EXP 8
9404: PUSH
9405: LD_INT 1
9407: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9408: LD_ADDR_VAR 0 1
9412: PUSH
9413: LD_INT 22
9415: PUSH
9416: LD_INT 2
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: LD_INT 21
9425: PUSH
9426: LD_INT 3
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PPUSH
9437: CALL_OW 69
9441: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9442: LD_ADDR_VAR 0 1
9446: PUSH
9447: LD_VAR 0 1
9451: PPUSH
9452: LD_EXP 15
9456: PPUSH
9457: CALL_OW 74
9461: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9462: LD_INT 7
9464: PPUSH
9465: LD_INT 3
9467: PPUSH
9468: CALL_OW 332
// DialogueOn ;
9472: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9476: LD_VAR 0 1
9480: PPUSH
9481: CALL_OW 250
9485: PPUSH
9486: LD_VAR 0 1
9490: PPUSH
9491: CALL_OW 251
9495: PPUSH
9496: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9500: LD_ADDR_VAR 0 1
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_INT 7
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 23
9517: PUSH
9518: LD_INT 1
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 26
9527: PUSH
9528: LD_INT 1
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: PUSH
9545: LD_EXP 15
9549: PUSH
9550: LD_EXP 19
9554: PUSH
9555: LD_EXP 20
9559: PUSH
9560: LD_EXP 27
9564: PUSH
9565: LD_EXP 16
9569: PUSH
9570: LD_EXP 25
9574: PUSH
9575: LD_EXP 21
9579: PUSH
9580: LD_EXP 23
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: DIFF
9595: ST_TO_ADDR
// if not tmp then
9596: LD_VAR 0 1
9600: NOT
9601: IFFALSE 9675
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9603: LD_ADDR_VAR 0 1
9607: PUSH
9608: LD_INT 22
9610: PUSH
9611: LD_INT 7
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PUSH
9618: LD_INT 23
9620: PUSH
9621: LD_INT 1
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: PUSH
9628: LD_INT 26
9630: PUSH
9631: LD_INT 2
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: EMPTY
9639: LIST
9640: LIST
9641: LIST
9642: PPUSH
9643: CALL_OW 69
9647: PUSH
9648: LD_EXP 30
9652: PUSH
9653: LD_EXP 17
9657: PUSH
9658: LD_EXP 28
9662: PUSH
9663: LD_EXP 29
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: DIFF
9674: ST_TO_ADDR
// if tmp then
9675: LD_VAR 0 1
9679: IFFALSE 9750
// case GetSex ( tmp [ 1 ] ) of sex_male :
9681: LD_VAR 0 1
9685: PUSH
9686: LD_INT 1
9688: ARRAY
9689: PPUSH
9690: CALL_OW 258
9694: PUSH
9695: LD_INT 1
9697: DOUBLE
9698: EQUAL
9699: IFTRUE 9703
9701: GO 9722
9703: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9704: LD_VAR 0 1
9708: PUSH
9709: LD_INT 1
9711: ARRAY
9712: PPUSH
9713: LD_STRING D9-Sol1-1
9715: PPUSH
9716: CALL_OW 88
9720: GO 9750
9722: LD_INT 2
9724: DOUBLE
9725: EQUAL
9726: IFTRUE 9730
9728: GO 9749
9730: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9731: LD_VAR 0 1
9735: PUSH
9736: LD_INT 1
9738: ARRAY
9739: PPUSH
9740: LD_STRING D9-FSol1-1
9742: PPUSH
9743: CALL_OW 88
9747: GO 9750
9749: POP
// if Frank then
9750: LD_EXP 27
9754: IFFALSE 9858
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9756: LD_EXP 56
9760: PPUSH
9761: CALL_OW 250
9765: PPUSH
9766: LD_EXP 56
9770: PPUSH
9771: CALL_OW 251
9775: PPUSH
9776: LD_INT 7
9778: PPUSH
9779: LD_INT 8
9781: PPUSH
9782: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9786: LD_EXP 56
9790: PPUSH
9791: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9795: LD_EXP 27
9799: PPUSH
9800: LD_STRING D9-Frank-1
9802: PPUSH
9803: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9807: LD_EXP 15
9811: PPUSH
9812: LD_STRING D9-JMM-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9819: LD_EXP 27
9823: PPUSH
9824: LD_STRING D9-Frank-2
9826: PPUSH
9827: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9831: LD_EXP 56
9835: PPUSH
9836: CALL_OW 250
9840: PPUSH
9841: LD_EXP 56
9845: PPUSH
9846: CALL_OW 251
9850: PPUSH
9851: LD_INT 7
9853: PPUSH
9854: CALL_OW 331
// end ; DialogueOff ;
9858: CALL_OW 7
// end ;
9862: PPOPN 1
9864: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9865: LD_EXP 7
9869: PUSH
9870: LD_OWVAR 1
9874: PUSH
9875: LD_INT 42000
9877: GREATEREQUAL
9878: OR
9879: IFFALSE 10906
9881: GO 9883
9883: DISABLE
9884: LD_INT 0
9886: PPUSH
9887: PPUSH
// begin selected_option := 1 ;
9888: LD_ADDR_VAR 0 2
9892: PUSH
9893: LD_INT 1
9895: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9896: LD_INT 10500
9898: PPUSH
9899: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9903: LD_INT 35
9905: PPUSH
9906: CALL_OW 67
// until not ru_attackers ;
9910: LD_EXP 52
9914: NOT
9915: IFFALSE 9903
// PrepareBurlak ;
9917: CALL 2290 0 0
// repeat wait ( 0 0$2 ) ;
9921: LD_INT 70
9923: PPUSH
9924: CALL_OW 67
// until not HasTask ( Burlak ) ;
9928: LD_EXP 46
9932: PPUSH
9933: CALL_OW 314
9937: NOT
9938: IFFALSE 9921
// InGameOn ;
9940: CALL_OW 8
// DialogueOn ;
9944: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9948: LD_EXP 49
9952: PPUSH
9953: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9957: LD_EXP 46
9961: PPUSH
9962: LD_STRING D10-Bur-1
9964: PPUSH
9965: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9969: LD_EXP 47
9973: PUSH
9974: LD_EXP 47
9978: PPUSH
9979: CALL_OW 255
9983: PUSH
9984: LD_INT 7
9986: EQUAL
9987: AND
9988: IFFALSE 10002
// Say ( Belkov , D10-Bel-1 ) ;
9990: LD_EXP 47
9994: PPUSH
9995: LD_STRING D10-Bel-1
9997: PPUSH
9998: CALL_OW 88
// if Gossudarov then
10002: LD_EXP 32
10006: IFFALSE 10020
// Say ( Gossudarov , D10-Gos-1 ) ;
10008: LD_EXP 32
10012: PPUSH
10013: LD_STRING D10-Gos-1
10015: PPUSH
10016: CALL_OW 88
// if Kirilenkova then
10020: LD_EXP 33
10024: IFFALSE 10038
// Say ( Kirilenkova , D10-Kir-1 ) ;
10026: LD_EXP 33
10030: PPUSH
10031: LD_STRING D10-Kir-1
10033: PPUSH
10034: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10038: CALL 13314 0 0
10042: PPUSH
10043: LD_STRING D10-RSol1-1
10045: PPUSH
10046: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10050: LD_EXP 46
10054: PPUSH
10055: LD_STRING D10-Bur-2
10057: PPUSH
10058: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10062: LD_EXP 15
10066: PPUSH
10067: LD_STRING D10-JMM-2
10069: PPUSH
10070: CALL_OW 88
// if Kirilenkova then
10074: LD_EXP 33
10078: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-2 ) else
10080: LD_EXP 33
10084: PPUSH
10085: LD_STRING D10-Kir-2
10087: PPUSH
10088: CALL_OW 88
10092: GO 10106
// Say ( SolRu , D10-RSol1-2 ) ;
10094: CALL 13314 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-2
10101: PPUSH
10102: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10106: LD_EXP 15
10110: PPUSH
10111: LD_STRING D10-JMM-3
10113: PPUSH
10114: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10118: LD_EXP 46
10122: PPUSH
10123: LD_STRING D10-Bur-3
10125: PPUSH
10126: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10130: LD_EXP 15
10134: PPUSH
10135: LD_STRING D10-JMM-4
10137: PPUSH
10138: CALL_OW 88
// DialogueOff ;
10142: CALL_OW 7
// InGameOff ;
10146: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10150: LD_STRING M2
10152: PPUSH
10153: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10157: LD_INT 35
10159: PPUSH
10160: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10164: LD_INT 22
10166: PUSH
10167: LD_INT 7
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 91
10176: PUSH
10177: LD_EXP 46
10181: PUSH
10182: LD_INT 8
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10157
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10200: LD_ADDR_VAR 0 1
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 4
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PPUSH
10215: CALL_OW 69
10219: PUSH
10220: FOR_IN
10221: IFFALSE 10237
// SetSide ( i , 7 ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 7
10230: PPUSH
10231: CALL_OW 235
10235: GO 10220
10237: POP
10238: POP
// ChangeMissionObjectives ( M3 ) ;
10239: LD_STRING M3
10241: PPUSH
10242: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10253: LD_EXP 15
10257: PPUSH
10258: LD_EXP 46
10262: PPUSH
10263: CALL_OW 296
10267: PUSH
10268: LD_INT 8
10270: LESS
10271: IFFALSE 10246
// ComTurnUnit ( JMM , Burlak ) ;
10273: LD_EXP 15
10277: PPUSH
10278: LD_EXP 46
10282: PPUSH
10283: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10287: LD_EXP 46
10291: PPUSH
10292: LD_EXP 15
10296: PPUSH
10297: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10301: LD_INT 10
10303: PPUSH
10304: CALL_OW 67
// DialogueOn ;
10308: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10312: LD_EXP 15
10316: PPUSH
10317: LD_STRING D11-JMM-1
10319: PPUSH
10320: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10324: LD_EXP 46
10328: PPUSH
10329: LD_STRING D11-Bur-1
10331: PPUSH
10332: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10336: LD_EXP 15
10340: PPUSH
10341: LD_STRING D11-JMM-2
10343: PPUSH
10344: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10348: LD_EXP 46
10352: PPUSH
10353: LD_STRING D11-Bur-2
10355: PPUSH
10356: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10360: LD_EXP 15
10364: PPUSH
10365: LD_STRING D11-JMM-3
10367: PPUSH
10368: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10372: LD_EXP 46
10376: PPUSH
10377: LD_STRING D11-Bur-3
10379: PPUSH
10380: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10384: LD_EXP 15
10388: PPUSH
10389: LD_STRING D11-JMM-4
10391: PPUSH
10392: CALL_OW 88
// if ar_base_spotted then
10396: LD_EXP 8
10400: IFFALSE 10416
// Say ( Burlak , D12-Bur-1 ) else
10402: LD_EXP 46
10406: PPUSH
10407: LD_STRING D12-Bur-1
10409: PPUSH
10410: CALL_OW 88
10414: GO 10455
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10416: LD_INT 7
10418: PPUSH
10419: LD_INT 3
10421: PPUSH
10422: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10426: LD_INT 127
10428: PPUSH
10429: LD_INT 45
10431: PPUSH
10432: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10436: LD_EXP 46
10440: PPUSH
10441: LD_STRING D12-Bur-1a
10443: PPUSH
10444: CALL_OW 88
// dwait ( 0 0$2 ) ;
10448: LD_INT 70
10450: PPUSH
10451: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10455: LD_EXP 46
10459: PPUSH
10460: LD_STRING D12-Bur-1b
10462: PPUSH
10463: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10467: LD_EXP 15
10471: PPUSH
10472: LD_STRING D12-JMM-1
10474: PPUSH
10475: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10479: LD_EXP 46
10483: PPUSH
10484: LD_STRING D12-Bur-2
10486: PPUSH
10487: CALL_OW 88
// if Roth then
10491: LD_EXP 16
10495: IFFALSE 10511
// Say ( Roth , D12-Roth-2 ) else
10497: LD_EXP 16
10501: PPUSH
10502: LD_STRING D12-Roth-2
10504: PPUSH
10505: CALL_OW 88
10509: GO 10523
// Say ( SciRu , D12-RSci1-2 ) ;
10511: CALL 13167 0 0
10515: PPUSH
10516: LD_STRING D12-RSci1-2
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10523: LD_EXP 15
10527: PPUSH
10528: LD_STRING D12-JMM-2
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10535: LD_EXP 46
10539: PPUSH
10540: LD_STRING D12-Bur-3
10542: PPUSH
10543: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10547: LD_EXP 15
10551: PPUSH
10552: LD_STRING D12-JMM-3
10554: PPUSH
10555: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10559: LD_EXP 46
10563: PPUSH
10564: LD_STRING D12-Bur-4
10566: PPUSH
10567: CALL_OW 88
// case Query ( QBase ) of 1 :
10571: LD_STRING QBase
10573: PPUSH
10574: CALL_OW 97
10578: PUSH
10579: LD_INT 1
10581: DOUBLE
10582: EQUAL
10583: IFTRUE 10587
10585: GO 10705
10587: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10588: LD_EXP 15
10592: PPUSH
10593: LD_STRING D13a-JMM-1
10595: PPUSH
10596: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10600: LD_EXP 46
10604: PPUSH
10605: LD_STRING D13a-Bur-1
10607: PPUSH
10608: CALL_OW 88
// if Roth then
10612: LD_EXP 16
10616: IFFALSE 10632
// Say ( Roth , D13a-Roth-1 ) else
10618: LD_EXP 16
10622: PPUSH
10623: LD_STRING D13a-Roth-1
10625: PPUSH
10626: CALL_OW 88
10630: GO 10644
// Say ( SciRu , D13a-RSci1-1 ) ;
10632: CALL 13167 0 0
10636: PPUSH
10637: LD_STRING D13a-RSci1-1
10639: PPUSH
10640: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10644: LD_EXP 15
10648: PPUSH
10649: LD_STRING D13a-JMM-2
10651: PPUSH
10652: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10656: LD_STRING QBaseAgain
10658: PPUSH
10659: CALL_OW 97
10663: PUSH
10664: LD_INT 1
10666: DOUBLE
10667: EQUAL
10668: IFTRUE 10672
10670: GO 10683
10672: POP
// selected_option := 2 ; 2 :
10673: LD_ADDR_VAR 0 2
10677: PUSH
10678: LD_INT 2
10680: ST_TO_ADDR
10681: GO 10703
10683: LD_INT 2
10685: DOUBLE
10686: EQUAL
10687: IFTRUE 10691
10689: GO 10702
10691: POP
// selected_option := 3 ; end ;
10692: LD_ADDR_VAR 0 2
10696: PUSH
10697: LD_INT 3
10699: ST_TO_ADDR
10700: GO 10703
10702: POP
// end ; 2 :
10703: GO 10744
10705: LD_INT 2
10707: DOUBLE
10708: EQUAL
10709: IFTRUE 10713
10711: GO 10724
10713: POP
// selected_option := 2 ; 3 :
10714: LD_ADDR_VAR 0 2
10718: PUSH
10719: LD_INT 2
10721: ST_TO_ADDR
10722: GO 10744
10724: LD_INT 3
10726: DOUBLE
10727: EQUAL
10728: IFTRUE 10732
10730: GO 10743
10732: POP
// selected_option := 3 ; end ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 3
10740: ST_TO_ADDR
10741: GO 10744
10743: POP
// if selected_option = 2 then
10744: LD_VAR 0 2
10748: PUSH
10749: LD_INT 2
10751: EQUAL
10752: IFFALSE 10846
// begin Say ( JMM , D13b-JMM-1 ) ;
10754: LD_EXP 15
10758: PPUSH
10759: LD_STRING D13b-JMM-1
10761: PPUSH
10762: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10766: LD_EXP 46
10770: PPUSH
10771: LD_STRING D13b-Bur-1
10773: PPUSH
10774: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10778: LD_EXP 15
10782: PPUSH
10783: LD_STRING D13b-JMM-2
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10790: LD_EXP 55
10794: PPUSH
10795: LD_STRING D13b-Abd-2
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10802: LD_EXP 15
10806: PPUSH
10807: LD_STRING D13b-JMM-3
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10814: LD_EXP 55
10818: PPUSH
10819: LD_STRING D13b-Abd-3
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10826: LD_EXP 15
10830: PPUSH
10831: LD_STRING D13b-JMM-4
10833: PPUSH
10834: CALL_OW 88
// ar_active_attack := true ;
10838: LD_ADDR_EXP 9
10842: PUSH
10843: LD_INT 1
10845: ST_TO_ADDR
// end ; if selected_option = 3 then
10846: LD_VAR 0 2
10850: PUSH
10851: LD_INT 3
10853: EQUAL
10854: IFFALSE 10880
// begin Say ( JMM , D13c-JMM-1 ) ;
10856: LD_EXP 15
10860: PPUSH
10861: LD_STRING D13c-JMM-1
10863: PPUSH
10864: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10868: LD_EXP 46
10872: PPUSH
10873: LD_STRING D13c-Bur-1
10875: PPUSH
10876: CALL_OW 88
// end ; DialogueOff ;
10880: CALL_OW 7
// if not ar_active_attack then
10884: LD_EXP 9
10888: NOT
10889: IFFALSE 10906
// begin wait ( 6 6$00 ) ;
10891: LD_INT 12600
10893: PPUSH
10894: CALL_OW 67
// ar_active_attack := true ;
10898: LD_ADDR_EXP 9
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// end ; end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10909: LD_EXP 46
10913: PPUSH
10914: CALL_OW 305
10918: PUSH
10919: LD_EXP 46
10923: PPUSH
10924: CALL_OW 255
10928: PUSH
10929: LD_INT 7
10931: EQUAL
10932: AND
10933: IFFALSE 11129
10935: GO 10937
10937: DISABLE
10938: LD_INT 0
10940: PPUSH
// begin wait ( 4 4$40 ) ;
10941: LD_INT 9800
10943: PPUSH
10944: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// until not ru_attackers ;
10955: LD_EXP 52
10959: NOT
10960: IFFALSE 10948
// PrepareGnyevko ;
10962: CALL 2234 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10966: LD_EXP 48
10970: PPUSH
10971: LD_INT 124
10973: PPUSH
10974: LD_INT 118
10976: PPUSH
10977: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10981: LD_EXP 48
10985: PPUSH
10986: CALL_OW 200
// time := 0 0$00 ;
10990: LD_ADDR_VAR 0 1
10994: PUSH
10995: LD_INT 0
10997: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10998: LD_INT 35
11000: PPUSH
11001: CALL_OW 67
// time := time + 0 0$1 ;
11005: LD_ADDR_VAR 0 1
11009: PUSH
11010: LD_VAR 0 1
11014: PUSH
11015: LD_INT 35
11017: PLUS
11018: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11019: LD_EXP 48
11023: PPUSH
11024: LD_INT 124
11026: PPUSH
11027: LD_INT 118
11029: PPUSH
11030: CALL_OW 307
11034: PUSH
11035: LD_VAR 0 1
11039: PUSH
11040: LD_INT 1050
11042: GREATEREQUAL
11043: OR
11044: IFFALSE 10998
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11046: LD_EXP 48
11050: PPUSH
11051: LD_STRING DBelkov-Gny-1
11053: PPUSH
11054: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11058: LD_EXP 46
11062: PPUSH
11063: LD_STRING DBelkov-Bur-1a
11065: PPUSH
11066: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11070: LD_INT 35
11072: PPUSH
11073: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11077: LD_EXP 48
11081: PPUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 7
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: PPUSH
11097: LD_EXP 48
11101: PPUSH
11102: CALL_OW 74
11106: PPUSH
11107: CALL_OW 296
11111: PUSH
11112: LD_INT 8
11114: LESS
11115: IFFALSE 11070
// SetSide ( Gnyevko , 7 ) ;
11117: LD_EXP 48
11121: PPUSH
11122: LD_INT 7
11124: PPUSH
11125: CALL_OW 235
// end ;
11129: PPOPN 1
11131: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11132: LD_EXP 46
11136: PPUSH
11137: CALL_OW 255
11141: PUSH
11142: LD_INT 7
11144: EQUAL
11145: IFFALSE 11155
11147: GO 11149
11149: DISABLE
// begin enable ;
11150: ENABLE
// PrepareAmericanAttack ;
11151: CALL 6805 0 0
// end ;
11155: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11156: LD_INT 22
11158: PUSH
11159: LD_INT 1
11161: PUSH
11162: EMPTY
11163: LIST
11164: LIST
11165: PPUSH
11166: CALL_OW 69
11170: IFFALSE 11354
11172: GO 11174
11174: DISABLE
11175: LD_INT 0
11177: PPUSH
11178: PPUSH
// begin while true do
11179: LD_INT 1
11181: IFFALSE 11238
// begin wait ( 0 0$1 ) ;
11183: LD_INT 35
11185: PPUSH
11186: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11190: LD_ADDR_VAR 0 2
11194: PUSH
11195: LD_INT 22
11197: PUSH
11198: LD_INT 1
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: PPUSH
11210: LD_EXP 15
11214: PPUSH
11215: CALL_OW 74
11219: ST_TO_ADDR
// if See ( 7 , tmp ) then
11220: LD_INT 7
11222: PPUSH
11223: LD_VAR 0 2
11227: PPUSH
11228: CALL_OW 292
11232: IFFALSE 11236
// break ;
11234: GO 11238
// end ;
11236: GO 11179
// DialogueOn ;
11238: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11251: LD_VAR 0 2
11255: PPUSH
11256: CALL_OW 250
11260: PPUSH
11261: LD_VAR 0 2
11265: PPUSH
11266: CALL_OW 251
11270: PPUSH
11271: LD_INT 7
11273: PPUSH
11274: LD_INT 8
11276: PPUSH
11277: CALL_OW 330
// if Denis then
11281: LD_EXP 21
11285: IFFALSE 11299
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11287: LD_EXP 21
11291: PPUSH
11292: LD_STRING DAmerAttack-Pet-1
11294: PPUSH
11295: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11299: LD_EXP 15
11303: PPUSH
11304: LD_STRING DAmerAttack-JMM-1
11306: PPUSH
11307: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11311: LD_EXP 46
11315: PPUSH
11316: LD_STRING DStop-Bur-1
11318: PPUSH
11319: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11323: LD_VAR 0 2
11327: PPUSH
11328: CALL_OW 250
11332: PPUSH
11333: LD_VAR 0 2
11337: PPUSH
11338: CALL_OW 251
11342: PPUSH
11343: LD_INT 7
11345: PPUSH
11346: CALL_OW 331
// DialogueOff ;
11350: CALL_OW 7
// end ;
11354: PPOPN 2
11356: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11357: LD_INT 22
11359: PUSH
11360: LD_INT 3
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: PUSH
11367: LD_INT 21
11369: PUSH
11370: LD_INT 1
11372: PUSH
11373: EMPTY
11374: LIST
11375: LIST
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PPUSH
11381: CALL_OW 69
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11431
11391: GO 11393
11393: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11394: LD_STRING M5a
11396: PPUSH
11397: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11401: LD_EXP 15
11405: PPUSH
11406: LD_STRING D8-JMM-1
11408: PPUSH
11409: CALL_OW 88
// if Gossudarov then
11413: LD_EXP 32
11417: IFFALSE 11431
// Say ( Gossudarov , D8-Gos-1 ) ;
11419: LD_EXP 32
11423: PPUSH
11424: LD_STRING D8-Gos-1
11426: PPUSH
11427: CALL_OW 88
// end ;
11431: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11432: LD_INT 22
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PUSH
11442: LD_INT 21
11444: PUSH
11445: LD_INT 1
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PPUSH
11456: CALL_OW 69
11460: PUSH
11461: LD_INT 0
11463: EQUAL
11464: IFFALSE 11514
11466: GO 11468
11468: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11469: LD_STRING M4c
11471: PPUSH
11472: CALL_OW 337
// if Roth then
11476: LD_EXP 16
11480: IFFALSE 11496
// Say ( Roth , DStop-Roth-1 ) else
11482: LD_EXP 16
11486: PPUSH
11487: LD_STRING DStop-Roth-1
11489: PPUSH
11490: CALL_OW 88
11494: GO 11514
// if Gossudarov then
11496: LD_EXP 32
11500: IFFALSE 11514
// Say ( Gossudarov , D8-Gos-1a ) ;
11502: LD_EXP 32
11506: PPUSH
11507: LD_STRING D8-Gos-1a
11509: PPUSH
11510: CALL_OW 88
// end ;
11514: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11515: LD_INT 7
11517: PPUSH
11518: LD_INT 1
11520: PPUSH
11521: LD_INT 1
11523: PPUSH
11524: CALL 14803 0 3
11528: PUSH
11529: LD_INT 0
11531: EQUAL
11532: PUSH
11533: LD_INT 7
11535: PPUSH
11536: LD_INT 3
11538: PPUSH
11539: LD_INT 1
11541: PPUSH
11542: CALL 14803 0 3
11546: PUSH
11547: LD_INT 0
11549: EQUAL
11550: AND
11551: IFFALSE 11563
11553: GO 11555
11555: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11556: LD_STRING M1a
11558: PPUSH
11559: CALL_OW 337
// end ;
11563: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11564: LD_INT 22
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 21
11576: PUSH
11577: LD_INT 1
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 69
11592: PUSH
11593: LD_INT 0
11595: EQUAL
11596: PUSH
11597: LD_INT 22
11599: PUSH
11600: LD_INT 3
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 21
11609: PUSH
11610: LD_INT 1
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PPUSH
11621: CALL_OW 69
11625: PUSH
11626: LD_INT 0
11628: EQUAL
11629: AND
11630: PUSH
11631: LD_INT 22
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 69
11645: PUSH
11646: LD_INT 0
11648: EQUAL
11649: AND
11650: PUSH
11651: LD_INT 7
11653: PPUSH
11654: LD_INT 1
11656: PPUSH
11657: LD_INT 1
11659: PPUSH
11660: CALL 14803 0 3
11664: PUSH
11665: LD_INT 0
11667: EQUAL
11668: AND
11669: PUSH
11670: LD_INT 7
11672: PPUSH
11673: LD_INT 3
11675: PPUSH
11676: LD_INT 1
11678: PPUSH
11679: CALL 14803 0 3
11683: PUSH
11684: LD_INT 0
11686: EQUAL
11687: AND
11688: IFFALSE 13164
11690: GO 11692
11692: DISABLE
11693: LD_INT 0
11695: PPUSH
11696: PPUSH
11697: PPUSH
11698: PPUSH
11699: PPUSH
11700: PPUSH
// begin m1 := false ;
11701: LD_ADDR_VAR 0 4
11705: PUSH
11706: LD_INT 0
11708: ST_TO_ADDR
// m2 := false ;
11709: LD_ADDR_VAR 0 5
11713: PUSH
11714: LD_INT 0
11716: ST_TO_ADDR
// m3 := false ;
11717: LD_ADDR_VAR 0 6
11721: PUSH
11722: LD_INT 0
11724: ST_TO_ADDR
// if tick < 40 40$00 then
11725: LD_OWVAR 1
11729: PUSH
11730: LD_INT 84000
11732: LESS
11733: IFFALSE 11742
// SetAchievement ( ACH_ASPEED_17 ) ;
11735: LD_STRING ACH_ASPEED_17
11737: PPUSH
11738: CALL_OW 543
// wait ( 0 0$5 ) ;
11742: LD_INT 175
11744: PPUSH
11745: CALL_OW 67
// if not IsDead ( Masha ) then
11749: LD_EXP 49
11753: PPUSH
11754: CALL_OW 301
11758: NOT
11759: IFFALSE 11781
// begin m1 := true ;
11761: LD_ADDR_VAR 0 4
11765: PUSH
11766: LD_INT 1
11768: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11769: LD_STRING Masha
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: CALL_OW 101
// end else
11779: GO 11792
// AddMedal ( Masha , - 1 ) ;
11781: LD_STRING Masha
11783: PPUSH
11784: LD_INT 1
11786: NEG
11787: PPUSH
11788: CALL_OW 101
// if abdul_escaped then
11792: LD_EXP 12
11796: IFFALSE 11811
// AddMedal ( Abdul , - 1 ) else
11798: LD_STRING Abdul
11800: PPUSH
11801: LD_INT 1
11803: NEG
11804: PPUSH
11805: CALL_OW 101
11809: GO 11829
// begin m2 := true ;
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_INT 1
11818: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11819: LD_STRING Abdul
11821: PPUSH
11822: LD_INT 1
11824: PPUSH
11825: CALL_OW 101
// end ; if loss_counter = 0 then
11829: LD_EXP 13
11833: PUSH
11834: LD_INT 0
11836: EQUAL
11837: IFFALSE 11859
// begin m3 := true ;
11839: LD_ADDR_VAR 0 6
11843: PUSH
11844: LD_INT 1
11846: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11847: LD_STRING People
11849: PPUSH
11850: LD_INT 2
11852: PPUSH
11853: CALL_OW 101
// end else
11857: GO 11917
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11859: LD_EXP 13
11863: PUSH
11864: LD_INT 3
11866: PUSH
11867: LD_INT 2
11869: PUSH
11870: LD_INT 2
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PUSH
11878: LD_OWVAR 67
11882: ARRAY
11883: LESSEQUAL
11884: IFFALSE 11906
// begin AddMedal ( People , 1 ) ;
11886: LD_STRING People
11888: PPUSH
11889: LD_INT 1
11891: PPUSH
11892: CALL_OW 101
// m3 := true ;
11896: LD_ADDR_VAR 0 6
11900: PUSH
11901: LD_INT 1
11903: ST_TO_ADDR
// end else
11904: GO 11917
// AddMedal ( People , - 1 ) ;
11906: LD_STRING People
11908: PPUSH
11909: LD_INT 1
11911: NEG
11912: PPUSH
11913: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11917: LD_OWVAR 67
11921: PUSH
11922: LD_INT 3
11924: EQUAL
11925: PUSH
11926: LD_VAR 0 4
11930: AND
11931: PUSH
11932: LD_VAR 0 5
11936: AND
11937: PUSH
11938: LD_VAR 0 6
11942: AND
11943: IFFALSE 11955
// SetAchievementEX ( ACH_AMER , 17 ) ;
11945: LD_STRING ACH_AMER
11947: PPUSH
11948: LD_INT 17
11950: PPUSH
11951: CALL_OW 564
// GiveMedals ( MAIN ) ;
11955: LD_STRING MAIN
11957: PPUSH
11958: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11962: LD_ADDR_VAR 0 2
11966: PUSH
11967: LD_INT 22
11969: PUSH
11970: LD_INT 7
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: LD_INT 25
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: PUSH
11990: LD_INT 25
11992: PUSH
11993: LD_INT 2
11995: PUSH
11996: EMPTY
11997: LIST
11998: LIST
11999: PUSH
12000: LD_INT 25
12002: PUSH
12003: LD_INT 3
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 25
12012: PUSH
12013: LD_INT 4
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 25
12022: PUSH
12023: LD_INT 5
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 25
12032: PUSH
12033: LD_INT 8
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 25
12042: PUSH
12043: LD_INT 9
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: LIST
12056: LIST
12057: LIST
12058: LIST
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12069: LD_VAR 0 2
12073: PPUSH
12074: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12078: LD_ADDR_VAR 0 3
12082: PUSH
12083: LD_EXP 15
12087: PUSH
12088: LD_EXP 16
12092: PUSH
12093: LD_EXP 17
12097: PUSH
12098: LD_EXP 18
12102: PUSH
12103: LD_EXP 19
12107: PUSH
12108: LD_EXP 20
12112: PUSH
12113: LD_EXP 21
12117: PUSH
12118: LD_EXP 22
12122: PUSH
12123: LD_EXP 23
12127: PUSH
12128: LD_EXP 24
12132: PUSH
12133: LD_EXP 25
12137: PUSH
12138: LD_EXP 26
12142: PUSH
12143: LD_EXP 27
12147: PUSH
12148: LD_EXP 28
12152: PUSH
12153: LD_EXP 29
12157: PUSH
12158: LD_EXP 30
12162: PUSH
12163: LD_EXP 31
12167: PUSH
12168: LD_EXP 32
12172: PUSH
12173: LD_EXP 33
12177: PUSH
12178: LD_EXP 34
12182: PUSH
12183: LD_EXP 36
12187: PUSH
12188: LD_EXP 37
12192: PUSH
12193: LD_EXP 38
12197: PUSH
12198: LD_EXP 39
12202: PUSH
12203: LD_EXP 40
12207: PUSH
12208: LD_EXP 41
12212: PUSH
12213: LD_EXP 42
12217: PUSH
12218: LD_EXP 43
12222: PUSH
12223: LD_EXP 44
12227: PUSH
12228: LD_EXP 45
12232: PUSH
12233: LD_EXP 46
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 48
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: LIST
12267: LIST
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: LIST
12280: LIST
12281: LIST
12282: ST_TO_ADDR
// if tmp diff tmp2 then
12283: LD_VAR 0 2
12287: PUSH
12288: LD_VAR 0 3
12292: DIFF
12293: IFFALSE 12313
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12295: LD_VAR 0 2
12299: PUSH
12300: LD_VAR 0 3
12304: DIFF
12305: PPUSH
12306: LD_STRING 13a_others
12308: PPUSH
12309: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12313: LD_EXP 15
12317: PPUSH
12318: LD_STRING 13a_JMM
12320: PPUSH
12321: CALL_OW 38
// if Titov then
12325: LD_EXP 34
12329: IFFALSE 12343
// SaveCharacters ( Titov , 13a_Titov ) ;
12331: LD_EXP 34
12335: PPUSH
12336: LD_STRING 13a_Titov
12338: PPUSH
12339: CALL_OW 38
// if Dolgov then
12343: LD_EXP 36
12347: IFFALSE 12361
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12349: LD_EXP 36
12353: PPUSH
12354: LD_STRING 13a_Dolgov
12356: PPUSH
12357: CALL_OW 38
// if Petrosyan then
12361: LD_EXP 37
12365: IFFALSE 12379
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12367: LD_EXP 37
12371: PPUSH
12372: LD_STRING 13a_Petrosyan
12374: PPUSH
12375: CALL_OW 38
// if Scholtze then
12379: LD_EXP 38
12383: IFFALSE 12397
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12385: LD_EXP 38
12389: PPUSH
12390: LD_STRING 13a_Scholtze
12392: PPUSH
12393: CALL_OW 38
// if Oblukov then
12397: LD_EXP 39
12401: IFFALSE 12415
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12403: LD_EXP 39
12407: PPUSH
12408: LD_STRING 13a_Oblukov
12410: PPUSH
12411: CALL_OW 38
// if Kapitsova then
12415: LD_EXP 40
12419: IFFALSE 12433
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12421: LD_EXP 40
12425: PPUSH
12426: LD_STRING 13a_Kapitsova
12428: PPUSH
12429: CALL_OW 38
// if Lipshchin then
12433: LD_EXP 41
12437: IFFALSE 12451
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12439: LD_EXP 41
12443: PPUSH
12444: LD_STRING 13a_Lipshchin
12446: PPUSH
12447: CALL_OW 38
// if Petrovova then
12451: LD_EXP 42
12455: IFFALSE 12469
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12457: LD_EXP 42
12461: PPUSH
12462: LD_STRING 13a_Petrovova
12464: PPUSH
12465: CALL_OW 38
// if Kovalyuk then
12469: LD_EXP 43
12473: IFFALSE 12487
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12475: LD_EXP 43
12479: PPUSH
12480: LD_STRING 13a_Kovalyuk
12482: PPUSH
12483: CALL_OW 38
// if Kuzmov then
12487: LD_EXP 44
12491: IFFALSE 12505
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12493: LD_EXP 44
12497: PPUSH
12498: LD_STRING 13a_Kuzmov
12500: PPUSH
12501: CALL_OW 38
// if Karamazov then
12505: LD_EXP 45
12509: IFFALSE 12523
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12511: LD_EXP 45
12515: PPUSH
12516: LD_STRING 13a_Karamazov
12518: PPUSH
12519: CALL_OW 38
// if Burlak then
12523: LD_EXP 46
12527: IFFALSE 12541
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12529: LD_EXP 46
12533: PPUSH
12534: LD_STRING 13a_Burlak
12536: PPUSH
12537: CALL_OW 38
// if Belkov then
12541: LD_EXP 47
12545: IFFALSE 12559
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12547: LD_EXP 47
12551: PPUSH
12552: LD_STRING 13a_Belkov
12554: PPUSH
12555: CALL_OW 38
// if Gnyevko then
12559: LD_EXP 48
12563: IFFALSE 12577
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12565: LD_EXP 48
12569: PPUSH
12570: LD_STRING 13a_Gnyevko
12572: PPUSH
12573: CALL_OW 38
// if Lisa then
12577: LD_EXP 17
12581: IFFALSE 12595
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12583: LD_EXP 17
12587: PPUSH
12588: LD_STRING 13a_Lisa
12590: PPUSH
12591: CALL_OW 38
// if Donaldson then
12595: LD_EXP 18
12599: IFFALSE 12613
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12601: LD_EXP 18
12605: PPUSH
12606: LD_STRING 13a_Donaldson
12608: PPUSH
12609: CALL_OW 38
// if Bobby then
12613: LD_EXP 19
12617: IFFALSE 12631
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12619: LD_EXP 19
12623: PPUSH
12624: LD_STRING 13a_Bobby
12626: PPUSH
12627: CALL_OW 38
// if Cyrus then
12631: LD_EXP 20
12635: IFFALSE 12649
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12637: LD_EXP 20
12641: PPUSH
12642: LD_STRING 13a_Cyrus
12644: PPUSH
12645: CALL_OW 38
// if Denis then
12649: LD_EXP 21
12653: IFFALSE 12667
// SaveCharacters ( Denis , 13a_Denis ) ;
12655: LD_EXP 21
12659: PPUSH
12660: LD_STRING 13a_Denis
12662: PPUSH
12663: CALL_OW 38
// if Brown then
12667: LD_EXP 22
12671: IFFALSE 12685
// SaveCharacters ( Brown , 13a_Brown ) ;
12673: LD_EXP 22
12677: PPUSH
12678: LD_STRING 13a_Brown
12680: PPUSH
12681: CALL_OW 38
// if Gladstone then
12685: LD_EXP 23
12689: IFFALSE 12703
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12691: LD_EXP 23
12695: PPUSH
12696: LD_STRING 13a_Gladstone
12698: PPUSH
12699: CALL_OW 38
// if Houten then
12703: LD_EXP 24
12707: IFFALSE 12721
// SaveCharacters ( Houten , 13a_Houten ) ;
12709: LD_EXP 24
12713: PPUSH
12714: LD_STRING 13a_Houten
12716: PPUSH
12717: CALL_OW 38
// if Cornel then
12721: LD_EXP 25
12725: IFFALSE 12739
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12727: LD_EXP 25
12731: PPUSH
12732: LD_STRING 13a_Cornel
12734: PPUSH
12735: CALL_OW 38
// if Gary then
12739: LD_EXP 26
12743: IFFALSE 12757
// SaveCharacters ( Gary , 13a_Gary ) ;
12745: LD_EXP 26
12749: PPUSH
12750: LD_STRING 13a_Gary
12752: PPUSH
12753: CALL_OW 38
// if Frank then
12757: LD_EXP 27
12761: IFFALSE 12775
// SaveCharacters ( Frank , 13a_Frank ) ;
12763: LD_EXP 27
12767: PPUSH
12768: LD_STRING 13a_Frank
12770: PPUSH
12771: CALL_OW 38
// if Kikuchi then
12775: LD_EXP 28
12779: IFFALSE 12793
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12781: LD_EXP 28
12785: PPUSH
12786: LD_STRING 13a_Kikuchi
12788: PPUSH
12789: CALL_OW 38
// if Simms then
12793: LD_EXP 29
12797: IFFALSE 12811
// SaveCharacters ( Simms , 13a_Simms ) ;
12799: LD_EXP 29
12803: PPUSH
12804: LD_STRING 13a_Simms
12806: PPUSH
12807: CALL_OW 38
// if Joan then
12811: LD_EXP 30
12815: IFFALSE 12829
// SaveCharacters ( Joan , 13a_Joan ) ;
12817: LD_EXP 30
12821: PPUSH
12822: LD_STRING 13a_Joan
12824: PPUSH
12825: CALL_OW 38
// if DeltaDoctor then
12829: LD_EXP 31
12833: IFFALSE 12847
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12835: LD_EXP 31
12839: PPUSH
12840: LD_STRING 13a_DeltaDoctor
12842: PPUSH
12843: CALL_OW 38
// if Gossudarov then
12847: LD_EXP 32
12851: IFFALSE 12865
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12853: LD_EXP 32
12857: PPUSH
12858: LD_STRING 13a_Gossudarov
12860: PPUSH
12861: CALL_OW 38
// if Kirilenkova then
12865: LD_EXP 33
12869: IFFALSE 12883
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12871: LD_EXP 33
12875: PPUSH
12876: LD_STRING 13a_Kirilenkova
12878: PPUSH
12879: CALL_OW 38
// if Roth then
12883: LD_EXP 16
12887: IFFALSE 12901
// SaveCharacters ( Roth , 13a_Roth ) ;
12889: LD_EXP 16
12893: PPUSH
12894: LD_STRING 13a_Roth
12896: PPUSH
12897: CALL_OW 38
// if Masha then
12901: LD_EXP 49
12905: IFFALSE 12960
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12907: LD_EXP 49
12911: PPUSH
12912: CALL_OW 265
12916: PUSH
12917: LD_EXP 49
12921: PPUSH
12922: CALL_OW 262
12926: PUSH
12927: LD_EXP 49
12931: PPUSH
12932: CALL_OW 263
12936: PUSH
12937: LD_EXP 49
12941: PPUSH
12942: CALL_OW 264
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: PPUSH
12953: LD_STRING 13a_Masha
12955: PPUSH
12956: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12960: LD_ADDR_VAR 0 2
12964: PUSH
12965: LD_INT 21
12967: PUSH
12968: LD_INT 3
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: PPUSH
12975: CALL_OW 69
12979: ST_TO_ADDR
// tmp2 := [ ] ;
12980: LD_ADDR_VAR 0 3
12984: PUSH
12985: EMPTY
12986: ST_TO_ADDR
// if tmp then
12987: LD_VAR 0 2
12991: IFFALSE 13142
// for i in tmp do
12993: LD_ADDR_VAR 0 1
12997: PUSH
12998: LD_VAR 0 2
13002: PUSH
13003: FOR_IN
13004: IFFALSE 13140
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13006: LD_ADDR_VAR 0 3
13010: PUSH
13011: LD_VAR 0 3
13015: PUSH
13016: LD_VAR 0 1
13020: PPUSH
13021: CALL_OW 255
13025: PUSH
13026: LD_VAR 0 1
13030: PPUSH
13031: CALL_OW 248
13035: PUSH
13036: LD_VAR 0 1
13040: PPUSH
13041: CALL_OW 266
13045: PUSH
13046: LD_VAR 0 1
13050: PPUSH
13051: CALL_OW 250
13055: PUSH
13056: LD_VAR 0 1
13060: PPUSH
13061: CALL_OW 251
13065: PUSH
13066: LD_VAR 0 1
13070: PPUSH
13071: CALL_OW 254
13075: PUSH
13076: LD_VAR 0 1
13080: PPUSH
13081: CALL_OW 267
13085: PUSH
13086: LD_VAR 0 1
13090: PPUSH
13091: LD_INT 1
13093: PPUSH
13094: CALL_OW 268
13098: PUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: LD_INT 2
13106: PPUSH
13107: CALL_OW 268
13111: PUSH
13112: LD_VAR 0 1
13116: PPUSH
13117: CALL_OW 269
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: PUSH
13134: EMPTY
13135: LIST
13136: ADD
13137: ST_TO_ADDR
13138: GO 13003
13140: POP
13141: POP
// if tmp2 then
13142: LD_VAR 0 3
13146: IFFALSE 13160
// SaveVariable ( tmp2 , 13a_buildings ) ;
13148: LD_VAR 0 3
13152: PPUSH
13153: LD_STRING 13a_buildings
13155: PPUSH
13156: CALL_OW 39
// YouWin ;
13160: CALL_OW 103
// end ;
13164: PPOPN 6
13166: END
// export function SciRu ; var tmp , t ; begin
13167: LD_INT 0
13169: PPUSH
13170: PPUSH
13171: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13172: LD_ADDR_VAR 0 3
13176: PUSH
13177: LD_EXP 32
13181: PUSH
13182: LD_EXP 46
13186: PUSH
13187: LD_EXP 34
13191: PUSH
13192: LD_EXP 47
13196: PUSH
13197: LD_EXP 48
13201: PUSH
13202: LD_EXP 37
13206: PUSH
13207: LD_EXP 38
13211: PUSH
13212: LD_EXP 36
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: LIST
13225: LIST
13226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13227: LD_ADDR_VAR 0 2
13231: PUSH
13232: LD_INT 22
13234: PUSH
13235: LD_INT 7
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 23
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 25
13254: PUSH
13255: LD_INT 4
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 26
13264: PUSH
13265: LD_INT 1
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: PPUSH
13278: CALL_OW 69
13282: PUSH
13283: LD_VAR 0 3
13287: DIFF
13288: ST_TO_ADDR
// if tmp then
13289: LD_VAR 0 2
13293: IFFALSE 13309
// result := tmp [ 1 ] ;
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: LD_INT 1
13307: ARRAY
13308: ST_TO_ADDR
// end ;
13309: LD_VAR 0 1
13313: RET
// export function SolRu ; var tmp , t ; begin
13314: LD_INT 0
13316: PPUSH
13317: PPUSH
13318: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_EXP 32
13328: PUSH
13329: LD_EXP 46
13333: PUSH
13334: LD_EXP 34
13338: PUSH
13339: LD_EXP 47
13343: PUSH
13344: LD_EXP 48
13348: PUSH
13349: LD_EXP 37
13353: PUSH
13354: LD_EXP 38
13358: PUSH
13359: LD_EXP 36
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13374: LD_ADDR_VAR 0 2
13378: PUSH
13379: LD_INT 22
13381: PUSH
13382: LD_INT 7
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 23
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: EMPTY
13396: LIST
13397: LIST
13398: PUSH
13399: LD_INT 25
13401: PUSH
13402: LD_INT 1
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PUSH
13409: LD_INT 26
13411: PUSH
13412: LD_INT 1
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 69
13429: PUSH
13430: LD_VAR 0 3
13434: DIFF
13435: ST_TO_ADDR
// if tmp then
13436: LD_VAR 0 2
13440: IFFALSE 13456
// result := tmp [ 1 ] ;
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_VAR 0 2
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: ST_TO_ADDR
// end ; end_of_file
13456: LD_VAR 0 1
13460: RET
// export function CustomEvent ( event ) ; begin
13461: LD_INT 0
13463: PPUSH
// end ;
13464: LD_VAR 0 2
13468: RET
// on UnitDestroyed ( un ) do var i , side ;
13469: LD_INT 0
13471: PPUSH
13472: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13473: LD_VAR 0 1
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_INT 7
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 2
13490: PUSH
13491: LD_INT 25
13493: PUSH
13494: LD_INT 1
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PUSH
13501: LD_INT 25
13503: PUSH
13504: LD_INT 2
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 25
13513: PUSH
13514: LD_INT 3
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PUSH
13521: LD_INT 25
13523: PUSH
13524: LD_INT 4
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: LD_INT 25
13533: PUSH
13534: LD_INT 5
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 25
13543: PUSH
13544: LD_INT 8
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: LD_INT 25
13553: PUSH
13554: LD_INT 9
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: IN
13580: IFFALSE 13596
// loss_counter := loss_counter + 1 ;
13582: LD_ADDR_EXP 13
13586: PUSH
13587: LD_EXP 13
13591: PUSH
13592: LD_INT 1
13594: PLUS
13595: ST_TO_ADDR
// if un = Abdul then
13596: LD_VAR 0 1
13600: PUSH
13601: LD_EXP 55
13605: EQUAL
13606: IFFALSE 13616
// abdul_escaped := false ;
13608: LD_ADDR_EXP 12
13612: PUSH
13613: LD_INT 0
13615: ST_TO_ADDR
// if un in ru_attackers then
13616: LD_VAR 0 1
13620: PUSH
13621: LD_EXP 52
13625: IN
13626: IFFALSE 13644
// ru_attackers := ru_attackers diff un ;
13628: LD_ADDR_EXP 52
13632: PUSH
13633: LD_EXP 52
13637: PUSH
13638: LD_VAR 0 1
13642: DIFF
13643: ST_TO_ADDR
// if un in ar_attackers then
13644: LD_VAR 0 1
13648: PUSH
13649: LD_EXP 10
13653: IN
13654: IFFALSE 13672
// ar_attackers := ar_attackers diff un ;
13656: LD_ADDR_EXP 10
13660: PUSH
13661: LD_EXP 10
13665: PUSH
13666: LD_VAR 0 1
13670: DIFF
13671: ST_TO_ADDR
// if un = JMM then
13672: LD_VAR 0 1
13676: PUSH
13677: LD_EXP 15
13681: EQUAL
13682: IFFALSE 13693
// begin YouLost ( JMM ) ;
13684: LD_STRING JMM
13686: PPUSH
13687: CALL_OW 104
// exit ;
13691: GO 13782
// end ; if un = Burlak then
13693: LD_VAR 0 1
13697: PUSH
13698: LD_EXP 46
13702: EQUAL
13703: IFFALSE 13714
// begin YouLost ( Burlak ) ;
13705: LD_STRING Burlak
13707: PPUSH
13708: CALL_OW 104
// exit ;
13712: GO 13782
// end ; if un = freedom then
13714: LD_VAR 0 1
13718: PUSH
13719: LD_EXP 3
13723: EQUAL
13724: IFFALSE 13735
// begin YouLost ( Destroyed ) ;
13726: LD_STRING Destroyed
13728: PPUSH
13729: CALL_OW 104
// exit ;
13733: GO 13782
// end ; if un = Masha then
13735: LD_VAR 0 1
13739: PUSH
13740: LD_EXP 49
13744: EQUAL
13745: IFFALSE 13754
// ChangeMissionObjectives ( M4b ) ;
13747: LD_STRING M4b
13749: PPUSH
13750: CALL_OW 337
// if un = Mastodont then
13754: LD_VAR 0 1
13758: PUSH
13759: LD_EXP 56
13763: EQUAL
13764: IFFALSE 13773
// ChangeMissionObjectives ( M4a ) ;
13766: LD_STRING M4a
13768: PPUSH
13769: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL 80544 0 1
// end ;
13782: PPOPN 3
13784: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 2
13794: PPUSH
13795: CALL 82878 0 2
// end ;
13799: PPOPN 2
13801: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13802: LD_VAR 0 1
13806: PPUSH
13807: CALL 81946 0 1
// end ;
13811: PPOPN 1
13813: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13814: LD_VAR 0 1
13818: PUSH
13819: LD_INT 22
13821: PUSH
13822: LD_INT 7
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: LD_INT 0
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PPUSH
13843: CALL_OW 69
13847: IN
13848: IFFALSE 13887
// begin SetBName ( building , freedom ) ;
13850: LD_VAR 0 1
13854: PPUSH
13855: LD_STRING freedom
13857: PPUSH
13858: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13862: LD_INT 0
13864: PPUSH
13865: LD_INT 7
13867: PPUSH
13868: LD_INT 0
13870: PPUSH
13871: CALL_OW 324
// freedom := building ;
13875: LD_ADDR_EXP 3
13879: PUSH
13880: LD_VAR 0 1
13884: ST_TO_ADDR
// exit ;
13885: GO 13953
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13887: LD_VAR 0 1
13891: PUSH
13892: LD_INT 22
13894: PUSH
13895: LD_INT 7
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 23
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: PUSH
13912: LD_INT 30
13914: PUSH
13915: LD_INT 6
13917: PUSH
13918: EMPTY
13919: LIST
13920: LIST
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: PPUSH
13927: CALL_OW 69
13931: IN
13932: IFFALSE 13944
// begin ru_lab_builded := true ;
13934: LD_ADDR_EXP 5
13938: PUSH
13939: LD_INT 1
13941: ST_TO_ADDR
// exit ;
13942: GO 13953
// end ; MCE_BuildingComplete ( building ) ;
13944: LD_VAR 0 1
13948: PPUSH
13949: CALL 82187 0 1
// end ;
13953: PPOPN 1
13955: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13956: LD_VAR 0 1
13960: PPUSH
13961: LD_VAR 0 2
13965: PPUSH
13966: CALL 80240 0 2
// end ;
13970: PPOPN 2
13972: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13973: LD_VAR 0 1
13977: PPUSH
13978: LD_VAR 0 2
13982: PPUSH
13983: LD_VAR 0 3
13987: PPUSH
13988: LD_VAR 0 4
13992: PPUSH
13993: LD_VAR 0 5
13997: PPUSH
13998: CALL 79860 0 5
// end ;
14002: PPOPN 5
14004: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14005: LD_VAR 0 1
14009: PPUSH
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL 79450 0 2
// end ;
14019: PPOPN 2
14021: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14022: LD_VAR 0 1
14026: PPUSH
14027: CALL_OW 263
14031: PUSH
14032: LD_INT 3
14034: EQUAL
14035: PUSH
14036: LD_VAR 0 2
14040: PPUSH
14041: CALL_OW 263
14045: PUSH
14046: LD_INT 3
14048: EQUAL
14049: OR
14050: IFFALSE 14066
// hack_counter := hack_counter + 1 ;
14052: LD_ADDR_EXP 14
14056: PUSH
14057: LD_EXP 14
14061: PUSH
14062: LD_INT 1
14064: PLUS
14065: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14066: LD_VAR 0 1
14070: PPUSH
14071: LD_VAR 0 2
14075: PPUSH
14076: LD_VAR 0 3
14080: PPUSH
14081: LD_VAR 0 4
14085: PPUSH
14086: CALL 79288 0 4
// end ;
14090: PPOPN 4
14092: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_VAR 0 3
14107: PPUSH
14108: CALL 79063 0 3
// end ;
14112: PPOPN 3
14114: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14115: LD_VAR 0 1
14119: PPUSH
14120: LD_VAR 0 2
14124: PPUSH
14125: CALL 78948 0 2
// end ;
14129: PPOPN 2
14131: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14132: LD_VAR 0 1
14136: PPUSH
14137: LD_VAR 0 2
14141: PPUSH
14142: CALL 83173 0 2
// end ;
14146: PPOPN 2
14148: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14149: LD_VAR 0 1
14153: PPUSH
14154: LD_VAR 0 2
14158: PPUSH
14159: LD_VAR 0 3
14163: PPUSH
14164: LD_VAR 0 4
14168: PPUSH
14169: CALL 83389 0 4
// end ;
14173: PPOPN 4
14175: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_VAR 0 2
14185: PPUSH
14186: CALL 78757 0 2
// end ;
14190: PPOPN 2
14192: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14193: LD_VAR 0 1
14197: PPUSH
14198: CALL 96976 0 1
// end ; end_of_file
14202: PPOPN 1
14204: END
// every 0 0$30 do var cr , time ;
14205: GO 14207
14207: DISABLE
14208: LD_INT 0
14210: PPUSH
14211: PPUSH
// begin time := 0 0$20 ;
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: LD_INT 700
14219: ST_TO_ADDR
// while game do
14220: LD_EXP 2
14224: IFFALSE 14323
// begin wait ( time ) ;
14226: LD_VAR 0 2
14230: PPUSH
14231: CALL_OW 67
// if tick > 2 2$00 then
14235: LD_OWVAR 1
14239: PUSH
14240: LD_INT 4200
14242: GREATER
14243: IFFALSE 14276
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 ] [ Difficulty ] ;
14245: LD_ADDR_VAR 0 2
14249: PUSH
14250: LD_VAR 0 2
14254: PUSH
14255: LD_INT 140
14257: PUSH
14258: LD_INT 140
14260: PUSH
14261: LD_INT 210
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: PUSH
14269: LD_OWVAR 67
14273: ARRAY
14274: PLUS
14275: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 70
14289: PPUSH
14290: LD_INT 49
14292: PPUSH
14293: LD_INT 25
14295: PPUSH
14296: LD_INT 1
14298: PPUSH
14299: CALL_OW 56
// if time > 3 3$00 then
14303: LD_VAR 0 2
14307: PUSH
14308: LD_INT 6300
14310: GREATER
14311: IFFALSE 14321
// time := 0 0$30 ;
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: LD_INT 1050
14320: ST_TO_ADDR
// end ;
14321: GO 14220
// end ;
14323: PPOPN 2
14325: END
// every 0 0$30 do var cr , time ;
14326: GO 14328
14328: DISABLE
14329: LD_INT 0
14331: PPUSH
14332: PPUSH
// begin time := 0 0$20 ;
14333: LD_ADDR_VAR 0 2
14337: PUSH
14338: LD_INT 700
14340: ST_TO_ADDR
// while game do
14341: LD_EXP 2
14345: IFFALSE 14434
// begin wait ( time ) ;
14347: LD_VAR 0 2
14351: PPUSH
14352: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 ] [ Difficulty ] ;
14356: LD_ADDR_VAR 0 2
14360: PUSH
14361: LD_VAR 0 2
14365: PUSH
14366: LD_INT 140
14368: PUSH
14369: LD_INT 175
14371: PUSH
14372: LD_INT 210
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: PUSH
14380: LD_OWVAR 67
14384: ARRAY
14385: PLUS
14386: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14387: LD_INT 3
14389: PPUSH
14390: LD_INT 5
14392: PPUSH
14393: CALL_OW 12
14397: PPUSH
14398: LD_INT 26
14400: PPUSH
14401: LD_INT 9
14403: PPUSH
14404: LD_INT 30
14406: PPUSH
14407: LD_INT 1
14409: PPUSH
14410: CALL_OW 56
// if time > 3 3$00 then
14414: LD_VAR 0 2
14418: PUSH
14419: LD_INT 6300
14421: GREATER
14422: IFFALSE 14432
// time := 0 0$20 ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_INT 700
14431: ST_TO_ADDR
// end ;
14432: GO 14341
// end ;
14434: PPOPN 2
14436: END
// every 0 0$30 do var cr , time ;
14437: GO 14439
14439: DISABLE
14440: LD_INT 0
14442: PPUSH
14443: PPUSH
// begin time := 0 0$20 ;
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: LD_INT 700
14451: ST_TO_ADDR
// while game do
14452: LD_EXP 2
14456: IFFALSE 14581
// begin wait ( time ) ;
14458: LD_VAR 0 2
14462: PPUSH
14463: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14467: LD_ADDR_VAR 0 2
14471: PUSH
14472: LD_VAR 0 2
14476: PUSH
14477: LD_INT 175
14479: PUSH
14480: LD_INT 210
14482: PUSH
14483: LD_INT 280
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: PUSH
14491: LD_OWVAR 67
14495: ARRAY
14496: PLUS
14497: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14498: LD_INT 1
14500: PPUSH
14501: LD_INT 5
14503: PPUSH
14504: CALL_OW 12
14508: PPUSH
14509: LD_INT 179
14511: PPUSH
14512: LD_INT 101
14514: PPUSH
14515: LD_INT 20
14517: PPUSH
14518: LD_INT 1
14520: PPUSH
14521: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14525: LD_INT 350
14527: PPUSH
14528: LD_INT 525
14530: PPUSH
14531: CALL_OW 12
14535: PPUSH
14536: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14540: LD_INT 1
14542: PPUSH
14543: LD_INT 5
14545: PPUSH
14546: CALL_OW 12
14550: PPUSH
14551: LD_INT 9
14553: PPUSH
14554: LD_INT 1
14556: PPUSH
14557: CALL_OW 55
// if time > 4 4$00 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_INT 8400
14568: GREATER
14569: IFFALSE 14579
// time := 0 0$30 ;
14571: LD_ADDR_VAR 0 2
14575: PUSH
14576: LD_INT 1050
14578: ST_TO_ADDR
// end ;
14579: GO 14452
// end ;
14581: PPOPN 2
14583: END
// every 0 0$30 do var cr , time ;
14584: GO 14586
14586: DISABLE
14587: LD_INT 0
14589: PPUSH
14590: PPUSH
// begin time := 0 0$10 ;
14591: LD_ADDR_VAR 0 2
14595: PUSH
14596: LD_INT 350
14598: ST_TO_ADDR
// while game do
14599: LD_EXP 2
14603: IFFALSE 14737
// begin wait ( time ) ;
14605: LD_VAR 0 2
14609: PPUSH
14610: CALL_OW 67
// time := time + 0 0$10 ;
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 2
14623: PUSH
14624: LD_INT 350
14626: PLUS
14627: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14628: LD_INT 1
14630: PPUSH
14631: LD_INT 5
14633: PPUSH
14634: CALL_OW 12
14638: PPUSH
14639: LD_INT 11
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14649: LD_ADDR_VAR 0 1
14653: PUSH
14654: LD_INT 1
14656: PPUSH
14657: LD_INT 3
14659: PPUSH
14660: CALL_OW 12
14664: ST_TO_ADDR
// if cr = 1 then
14665: LD_VAR 0 1
14669: PUSH
14670: LD_INT 1
14672: EQUAL
14673: IFFALSE 14717
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14675: LD_INT 700
14677: PPUSH
14678: LD_INT 1575
14680: PPUSH
14681: CALL_OW 12
14685: PPUSH
14686: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14690: LD_INT 1
14692: PPUSH
14693: LD_INT 5
14695: PPUSH
14696: CALL_OW 12
14700: PPUSH
14701: LD_INT 34
14703: PPUSH
14704: LD_INT 50
14706: PPUSH
14707: LD_INT 7
14709: PPUSH
14710: LD_INT 1
14712: PPUSH
14713: CALL_OW 56
// end ; if time > 4 4$00 then
14717: LD_VAR 0 2
14721: PUSH
14722: LD_INT 8400
14724: GREATER
14725: IFFALSE 14735
// time := 0 0$40 ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 1400
14734: ST_TO_ADDR
// end ;
14735: GO 14599
// end ; end_of_file
14737: PPOPN 2
14739: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14740: LD_INT 0
14742: PPUSH
14743: PPUSH
// if exist_mode then
14744: LD_VAR 0 2
14748: IFFALSE 14773
// unit := CreateCharacter ( prefix & ident ) else
14750: LD_ADDR_VAR 0 5
14754: PUSH
14755: LD_VAR 0 3
14759: PUSH
14760: LD_VAR 0 1
14764: STR
14765: PPUSH
14766: CALL_OW 34
14770: ST_TO_ADDR
14771: GO 14788
// unit := NewCharacter ( ident ) ;
14773: LD_ADDR_VAR 0 5
14777: PUSH
14778: LD_VAR 0 1
14782: PPUSH
14783: CALL_OW 25
14787: ST_TO_ADDR
// result := unit ;
14788: LD_ADDR_VAR 0 4
14792: PUSH
14793: LD_VAR 0 5
14797: ST_TO_ADDR
// end ;
14798: LD_VAR 0 4
14802: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14803: LD_INT 0
14805: PPUSH
14806: PPUSH
// if not side or not nation then
14807: LD_VAR 0 1
14811: NOT
14812: PUSH
14813: LD_VAR 0 2
14817: NOT
14818: OR
14819: IFFALSE 14823
// exit ;
14821: GO 15591
// case nation of nation_american :
14823: LD_VAR 0 2
14827: PUSH
14828: LD_INT 1
14830: DOUBLE
14831: EQUAL
14832: IFTRUE 14836
14834: GO 15050
14836: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14837: LD_ADDR_VAR 0 4
14841: PUSH
14842: LD_INT 35
14844: PUSH
14845: LD_INT 45
14847: PUSH
14848: LD_INT 46
14850: PUSH
14851: LD_INT 47
14853: PUSH
14854: LD_INT 82
14856: PUSH
14857: LD_INT 83
14859: PUSH
14860: LD_INT 84
14862: PUSH
14863: LD_INT 85
14865: PUSH
14866: LD_INT 86
14868: PUSH
14869: LD_INT 1
14871: PUSH
14872: LD_INT 2
14874: PUSH
14875: LD_INT 6
14877: PUSH
14878: LD_INT 15
14880: PUSH
14881: LD_INT 16
14883: PUSH
14884: LD_INT 7
14886: PUSH
14887: LD_INT 12
14889: PUSH
14890: LD_INT 13
14892: PUSH
14893: LD_INT 10
14895: PUSH
14896: LD_INT 14
14898: PUSH
14899: LD_INT 20
14901: PUSH
14902: LD_INT 21
14904: PUSH
14905: LD_INT 22
14907: PUSH
14908: LD_INT 25
14910: PUSH
14911: LD_INT 32
14913: PUSH
14914: LD_INT 27
14916: PUSH
14917: LD_INT 36
14919: PUSH
14920: LD_INT 69
14922: PUSH
14923: LD_INT 39
14925: PUSH
14926: LD_INT 34
14928: PUSH
14929: LD_INT 40
14931: PUSH
14932: LD_INT 48
14934: PUSH
14935: LD_INT 49
14937: PUSH
14938: LD_INT 50
14940: PUSH
14941: LD_INT 51
14943: PUSH
14944: LD_INT 52
14946: PUSH
14947: LD_INT 53
14949: PUSH
14950: LD_INT 54
14952: PUSH
14953: LD_INT 55
14955: PUSH
14956: LD_INT 56
14958: PUSH
14959: LD_INT 57
14961: PUSH
14962: LD_INT 58
14964: PUSH
14965: LD_INT 59
14967: PUSH
14968: LD_INT 60
14970: PUSH
14971: LD_INT 61
14973: PUSH
14974: LD_INT 62
14976: PUSH
14977: LD_INT 80
14979: PUSH
14980: LD_INT 82
14982: PUSH
14983: LD_INT 83
14985: PUSH
14986: LD_INT 84
14988: PUSH
14989: LD_INT 85
14991: PUSH
14992: LD_INT 86
14994: PUSH
14995: EMPTY
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: ST_TO_ADDR
15048: GO 15515
15050: LD_INT 2
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15284
15058: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15059: LD_ADDR_VAR 0 4
15063: PUSH
15064: LD_INT 35
15066: PUSH
15067: LD_INT 45
15069: PUSH
15070: LD_INT 46
15072: PUSH
15073: LD_INT 47
15075: PUSH
15076: LD_INT 82
15078: PUSH
15079: LD_INT 83
15081: PUSH
15082: LD_INT 84
15084: PUSH
15085: LD_INT 85
15087: PUSH
15088: LD_INT 87
15090: PUSH
15091: LD_INT 70
15093: PUSH
15094: LD_INT 1
15096: PUSH
15097: LD_INT 11
15099: PUSH
15100: LD_INT 3
15102: PUSH
15103: LD_INT 4
15105: PUSH
15106: LD_INT 5
15108: PUSH
15109: LD_INT 6
15111: PUSH
15112: LD_INT 15
15114: PUSH
15115: LD_INT 18
15117: PUSH
15118: LD_INT 7
15120: PUSH
15121: LD_INT 17
15123: PUSH
15124: LD_INT 8
15126: PUSH
15127: LD_INT 20
15129: PUSH
15130: LD_INT 21
15132: PUSH
15133: LD_INT 22
15135: PUSH
15136: LD_INT 72
15138: PUSH
15139: LD_INT 26
15141: PUSH
15142: LD_INT 69
15144: PUSH
15145: LD_INT 39
15147: PUSH
15148: LD_INT 40
15150: PUSH
15151: LD_INT 41
15153: PUSH
15154: LD_INT 42
15156: PUSH
15157: LD_INT 43
15159: PUSH
15160: LD_INT 48
15162: PUSH
15163: LD_INT 49
15165: PUSH
15166: LD_INT 50
15168: PUSH
15169: LD_INT 51
15171: PUSH
15172: LD_INT 52
15174: PUSH
15175: LD_INT 53
15177: PUSH
15178: LD_INT 54
15180: PUSH
15181: LD_INT 55
15183: PUSH
15184: LD_INT 56
15186: PUSH
15187: LD_INT 60
15189: PUSH
15190: LD_INT 61
15192: PUSH
15193: LD_INT 62
15195: PUSH
15196: LD_INT 66
15198: PUSH
15199: LD_INT 67
15201: PUSH
15202: LD_INT 68
15204: PUSH
15205: LD_INT 81
15207: PUSH
15208: LD_INT 82
15210: PUSH
15211: LD_INT 83
15213: PUSH
15214: LD_INT 84
15216: PUSH
15217: LD_INT 85
15219: PUSH
15220: LD_INT 87
15222: PUSH
15223: LD_INT 88
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: LIST
15278: LIST
15279: LIST
15280: LIST
15281: ST_TO_ADDR
15282: GO 15515
15284: LD_INT 3
15286: DOUBLE
15287: EQUAL
15288: IFTRUE 15292
15290: GO 15514
15292: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15293: LD_ADDR_VAR 0 4
15297: PUSH
15298: LD_INT 46
15300: PUSH
15301: LD_INT 47
15303: PUSH
15304: LD_INT 1
15306: PUSH
15307: LD_INT 2
15309: PUSH
15310: LD_INT 82
15312: PUSH
15313: LD_INT 83
15315: PUSH
15316: LD_INT 84
15318: PUSH
15319: LD_INT 85
15321: PUSH
15322: LD_INT 86
15324: PUSH
15325: LD_INT 11
15327: PUSH
15328: LD_INT 9
15330: PUSH
15331: LD_INT 20
15333: PUSH
15334: LD_INT 19
15336: PUSH
15337: LD_INT 21
15339: PUSH
15340: LD_INT 24
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 25
15348: PUSH
15349: LD_INT 28
15351: PUSH
15352: LD_INT 29
15354: PUSH
15355: LD_INT 30
15357: PUSH
15358: LD_INT 31
15360: PUSH
15361: LD_INT 37
15363: PUSH
15364: LD_INT 38
15366: PUSH
15367: LD_INT 32
15369: PUSH
15370: LD_INT 27
15372: PUSH
15373: LD_INT 33
15375: PUSH
15376: LD_INT 69
15378: PUSH
15379: LD_INT 39
15381: PUSH
15382: LD_INT 34
15384: PUSH
15385: LD_INT 40
15387: PUSH
15388: LD_INT 71
15390: PUSH
15391: LD_INT 23
15393: PUSH
15394: LD_INT 44
15396: PUSH
15397: LD_INT 48
15399: PUSH
15400: LD_INT 49
15402: PUSH
15403: LD_INT 50
15405: PUSH
15406: LD_INT 51
15408: PUSH
15409: LD_INT 52
15411: PUSH
15412: LD_INT 53
15414: PUSH
15415: LD_INT 54
15417: PUSH
15418: LD_INT 55
15420: PUSH
15421: LD_INT 56
15423: PUSH
15424: LD_INT 57
15426: PUSH
15427: LD_INT 58
15429: PUSH
15430: LD_INT 59
15432: PUSH
15433: LD_INT 63
15435: PUSH
15436: LD_INT 64
15438: PUSH
15439: LD_INT 65
15441: PUSH
15442: LD_INT 82
15444: PUSH
15445: LD_INT 83
15447: PUSH
15448: LD_INT 84
15450: PUSH
15451: LD_INT 85
15453: PUSH
15454: LD_INT 86
15456: PUSH
15457: EMPTY
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: LIST
15493: LIST
15494: LIST
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: LIST
15500: LIST
15501: LIST
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: LIST
15509: LIST
15510: LIST
15511: ST_TO_ADDR
15512: GO 15515
15514: POP
// if state > - 1 and state < 3 then
15515: LD_VAR 0 3
15519: PUSH
15520: LD_INT 1
15522: NEG
15523: GREATER
15524: PUSH
15525: LD_VAR 0 3
15529: PUSH
15530: LD_INT 3
15532: LESS
15533: AND
15534: IFFALSE 15591
// for i in result do
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 4
15545: PUSH
15546: FOR_IN
15547: IFFALSE 15589
// if GetTech ( i , side ) <> state then
15549: LD_VAR 0 5
15553: PPUSH
15554: LD_VAR 0 1
15558: PPUSH
15559: CALL_OW 321
15563: PUSH
15564: LD_VAR 0 3
15568: NONEQUAL
15569: IFFALSE 15587
// result := result diff i ;
15571: LD_ADDR_VAR 0 4
15575: PUSH
15576: LD_VAR 0 4
15580: PUSH
15581: LD_VAR 0 5
15585: DIFF
15586: ST_TO_ADDR
15587: GO 15546
15589: POP
15590: POP
// end ;
15591: LD_VAR 0 4
15595: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15596: LD_INT 0
15598: PPUSH
15599: PPUSH
15600: PPUSH
// result := true ;
15601: LD_ADDR_VAR 0 3
15605: PUSH
15606: LD_INT 1
15608: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15609: LD_ADDR_VAR 0 5
15613: PUSH
15614: LD_VAR 0 2
15618: PPUSH
15619: CALL_OW 480
15623: ST_TO_ADDR
// if not tmp then
15624: LD_VAR 0 5
15628: NOT
15629: IFFALSE 15633
// exit ;
15631: GO 15682
// for i in tmp do
15633: LD_ADDR_VAR 0 4
15637: PUSH
15638: LD_VAR 0 5
15642: PUSH
15643: FOR_IN
15644: IFFALSE 15680
// if GetTech ( i , side ) <> state_researched then
15646: LD_VAR 0 4
15650: PPUSH
15651: LD_VAR 0 1
15655: PPUSH
15656: CALL_OW 321
15660: PUSH
15661: LD_INT 2
15663: NONEQUAL
15664: IFFALSE 15678
// begin result := false ;
15666: LD_ADDR_VAR 0 3
15670: PUSH
15671: LD_INT 0
15673: ST_TO_ADDR
// exit ;
15674: POP
15675: POP
15676: GO 15682
// end ;
15678: GO 15643
15680: POP
15681: POP
// end ;
15682: LD_VAR 0 3
15686: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15687: LD_INT 0
15689: PPUSH
15690: PPUSH
15691: PPUSH
15692: PPUSH
15693: PPUSH
15694: PPUSH
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
15701: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15702: LD_VAR 0 1
15706: NOT
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 257
15717: PUSH
15718: LD_INT 9
15720: NONEQUAL
15721: OR
15722: IFFALSE 15726
// exit ;
15724: GO 16299
// side := GetSide ( unit ) ;
15726: LD_ADDR_VAR 0 9
15730: PUSH
15731: LD_VAR 0 1
15735: PPUSH
15736: CALL_OW 255
15740: ST_TO_ADDR
// tech_space := tech_spacanom ;
15741: LD_ADDR_VAR 0 12
15745: PUSH
15746: LD_INT 29
15748: ST_TO_ADDR
// tech_time := tech_taurad ;
15749: LD_ADDR_VAR 0 13
15753: PUSH
15754: LD_INT 28
15756: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15757: LD_ADDR_VAR 0 11
15761: PUSH
15762: LD_VAR 0 1
15766: PPUSH
15767: CALL_OW 310
15771: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15772: LD_VAR 0 11
15776: PPUSH
15777: CALL_OW 247
15781: PUSH
15782: LD_INT 2
15784: EQUAL
15785: IFFALSE 15789
// exit ;
15787: GO 16299
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15789: LD_ADDR_VAR 0 8
15793: PUSH
15794: LD_INT 81
15796: PUSH
15797: LD_VAR 0 9
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 3
15808: PUSH
15809: LD_INT 21
15811: PUSH
15812: LD_INT 3
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PPUSH
15827: CALL_OW 69
15831: ST_TO_ADDR
// if not tmp then
15832: LD_VAR 0 8
15836: NOT
15837: IFFALSE 15841
// exit ;
15839: GO 16299
// if in_unit then
15841: LD_VAR 0 11
15845: IFFALSE 15869
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15847: LD_ADDR_VAR 0 10
15851: PUSH
15852: LD_VAR 0 8
15856: PPUSH
15857: LD_VAR 0 11
15861: PPUSH
15862: CALL_OW 74
15866: ST_TO_ADDR
15867: GO 15889
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15869: LD_ADDR_VAR 0 10
15873: PUSH
15874: LD_VAR 0 8
15878: PPUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: CALL_OW 74
15888: ST_TO_ADDR
// if not enemy then
15889: LD_VAR 0 10
15893: NOT
15894: IFFALSE 15898
// exit ;
15896: GO 16299
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15898: LD_VAR 0 11
15902: PUSH
15903: LD_VAR 0 11
15907: PPUSH
15908: LD_VAR 0 10
15912: PPUSH
15913: CALL_OW 296
15917: PUSH
15918: LD_INT 13
15920: GREATER
15921: AND
15922: PUSH
15923: LD_VAR 0 1
15927: PPUSH
15928: LD_VAR 0 10
15932: PPUSH
15933: CALL_OW 296
15937: PUSH
15938: LD_INT 12
15940: GREATER
15941: OR
15942: IFFALSE 15946
// exit ;
15944: GO 16299
// missile := [ 1 ] ;
15946: LD_ADDR_VAR 0 14
15950: PUSH
15951: LD_INT 1
15953: PUSH
15954: EMPTY
15955: LIST
15956: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15957: LD_VAR 0 9
15961: PPUSH
15962: LD_VAR 0 12
15966: PPUSH
15967: CALL_OW 325
15971: IFFALSE 16000
// missile := Insert ( missile , missile + 1 , 2 ) ;
15973: LD_ADDR_VAR 0 14
15977: PUSH
15978: LD_VAR 0 14
15982: PPUSH
15983: LD_VAR 0 14
15987: PUSH
15988: LD_INT 1
15990: PLUS
15991: PPUSH
15992: LD_INT 2
15994: PPUSH
15995: CALL_OW 2
15999: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16000: LD_VAR 0 9
16004: PPUSH
16005: LD_VAR 0 13
16009: PPUSH
16010: CALL_OW 325
16014: PUSH
16015: LD_VAR 0 10
16019: PPUSH
16020: CALL_OW 255
16024: PPUSH
16025: LD_VAR 0 13
16029: PPUSH
16030: CALL_OW 325
16034: NOT
16035: AND
16036: IFFALSE 16065
// missile := Insert ( missile , missile + 1 , 3 ) ;
16038: LD_ADDR_VAR 0 14
16042: PUSH
16043: LD_VAR 0 14
16047: PPUSH
16048: LD_VAR 0 14
16052: PUSH
16053: LD_INT 1
16055: PLUS
16056: PPUSH
16057: LD_INT 3
16059: PPUSH
16060: CALL_OW 2
16064: ST_TO_ADDR
// if missile < 2 then
16065: LD_VAR 0 14
16069: PUSH
16070: LD_INT 2
16072: LESS
16073: IFFALSE 16077
// exit ;
16075: GO 16299
// x := GetX ( enemy ) ;
16077: LD_ADDR_VAR 0 4
16081: PUSH
16082: LD_VAR 0 10
16086: PPUSH
16087: CALL_OW 250
16091: ST_TO_ADDR
// y := GetY ( enemy ) ;
16092: LD_ADDR_VAR 0 5
16096: PUSH
16097: LD_VAR 0 10
16101: PPUSH
16102: CALL_OW 251
16106: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16107: LD_ADDR_VAR 0 6
16111: PUSH
16112: LD_VAR 0 4
16116: PUSH
16117: LD_INT 1
16119: NEG
16120: PPUSH
16121: LD_INT 1
16123: PPUSH
16124: CALL_OW 12
16128: PLUS
16129: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16130: LD_ADDR_VAR 0 7
16134: PUSH
16135: LD_VAR 0 5
16139: PUSH
16140: LD_INT 1
16142: NEG
16143: PPUSH
16144: LD_INT 1
16146: PPUSH
16147: CALL_OW 12
16151: PLUS
16152: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16153: LD_VAR 0 6
16157: PPUSH
16158: LD_VAR 0 7
16162: PPUSH
16163: CALL_OW 488
16167: NOT
16168: IFFALSE 16190
// begin _x := x ;
16170: LD_ADDR_VAR 0 6
16174: PUSH
16175: LD_VAR 0 4
16179: ST_TO_ADDR
// _y := y ;
16180: LD_ADDR_VAR 0 7
16184: PUSH
16185: LD_VAR 0 5
16189: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16190: LD_ADDR_VAR 0 3
16194: PUSH
16195: LD_INT 1
16197: PPUSH
16198: LD_VAR 0 14
16202: PPUSH
16203: CALL_OW 12
16207: ST_TO_ADDR
// case i of 1 :
16208: LD_VAR 0 3
16212: PUSH
16213: LD_INT 1
16215: DOUBLE
16216: EQUAL
16217: IFTRUE 16221
16219: GO 16238
16221: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16222: LD_VAR 0 1
16226: PPUSH
16227: LD_VAR 0 10
16231: PPUSH
16232: CALL_OW 115
16236: GO 16299
16238: LD_INT 2
16240: DOUBLE
16241: EQUAL
16242: IFTRUE 16246
16244: GO 16268
16246: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16247: LD_VAR 0 1
16251: PPUSH
16252: LD_VAR 0 6
16256: PPUSH
16257: LD_VAR 0 7
16261: PPUSH
16262: CALL_OW 153
16266: GO 16299
16268: LD_INT 3
16270: DOUBLE
16271: EQUAL
16272: IFTRUE 16276
16274: GO 16298
16276: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16277: LD_VAR 0 1
16281: PPUSH
16282: LD_VAR 0 6
16286: PPUSH
16287: LD_VAR 0 7
16291: PPUSH
16292: CALL_OW 154
16296: GO 16299
16298: POP
// end ;
16299: LD_VAR 0 2
16303: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16304: LD_INT 0
16306: PPUSH
16307: PPUSH
16308: PPUSH
16309: PPUSH
16310: PPUSH
16311: PPUSH
// if not unit or not building then
16312: LD_VAR 0 1
16316: NOT
16317: PUSH
16318: LD_VAR 0 2
16322: NOT
16323: OR
16324: IFFALSE 16328
// exit ;
16326: GO 16486
// x := GetX ( building ) ;
16328: LD_ADDR_VAR 0 5
16332: PUSH
16333: LD_VAR 0 2
16337: PPUSH
16338: CALL_OW 250
16342: ST_TO_ADDR
// y := GetY ( building ) ;
16343: LD_ADDR_VAR 0 6
16347: PUSH
16348: LD_VAR 0 2
16352: PPUSH
16353: CALL_OW 251
16357: ST_TO_ADDR
// for i = 0 to 5 do
16358: LD_ADDR_VAR 0 4
16362: PUSH
16363: DOUBLE
16364: LD_INT 0
16366: DEC
16367: ST_TO_ADDR
16368: LD_INT 5
16370: PUSH
16371: FOR_TO
16372: IFFALSE 16484
// begin _x := ShiftX ( x , i , 3 ) ;
16374: LD_ADDR_VAR 0 7
16378: PUSH
16379: LD_VAR 0 5
16383: PPUSH
16384: LD_VAR 0 4
16388: PPUSH
16389: LD_INT 3
16391: PPUSH
16392: CALL_OW 272
16396: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16397: LD_ADDR_VAR 0 8
16401: PUSH
16402: LD_VAR 0 6
16406: PPUSH
16407: LD_VAR 0 4
16411: PPUSH
16412: LD_INT 3
16414: PPUSH
16415: CALL_OW 273
16419: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16420: LD_VAR 0 7
16424: PPUSH
16425: LD_VAR 0 8
16429: PPUSH
16430: CALL_OW 488
16434: NOT
16435: IFFALSE 16439
// continue ;
16437: GO 16371
// if HexInfo ( _x , _y ) = 0 then
16439: LD_VAR 0 7
16443: PPUSH
16444: LD_VAR 0 8
16448: PPUSH
16449: CALL_OW 428
16453: PUSH
16454: LD_INT 0
16456: EQUAL
16457: IFFALSE 16482
// begin ComMoveXY ( unit , _x , _y ) ;
16459: LD_VAR 0 1
16463: PPUSH
16464: LD_VAR 0 7
16468: PPUSH
16469: LD_VAR 0 8
16473: PPUSH
16474: CALL_OW 111
// exit ;
16478: POP
16479: POP
16480: GO 16486
// end ; end ;
16482: GO 16371
16484: POP
16485: POP
// end ;
16486: LD_VAR 0 3
16490: RET
// export function ScanBase ( side , base_area ) ; begin
16491: LD_INT 0
16493: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16494: LD_ADDR_VAR 0 3
16498: PUSH
16499: LD_VAR 0 2
16503: PPUSH
16504: LD_INT 81
16506: PUSH
16507: LD_VAR 0 1
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 70
16520: ST_TO_ADDR
// end ;
16521: LD_VAR 0 3
16525: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16526: LD_INT 0
16528: PPUSH
16529: PPUSH
16530: PPUSH
16531: PPUSH
// result := false ;
16532: LD_ADDR_VAR 0 2
16536: PUSH
16537: LD_INT 0
16539: ST_TO_ADDR
// side := GetSide ( unit ) ;
16540: LD_ADDR_VAR 0 3
16544: PUSH
16545: LD_VAR 0 1
16549: PPUSH
16550: CALL_OW 255
16554: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16555: LD_ADDR_VAR 0 4
16559: PUSH
16560: LD_VAR 0 1
16564: PPUSH
16565: CALL_OW 248
16569: ST_TO_ADDR
// case nat of 1 :
16570: LD_VAR 0 4
16574: PUSH
16575: LD_INT 1
16577: DOUBLE
16578: EQUAL
16579: IFTRUE 16583
16581: GO 16594
16583: POP
// tech := tech_lassight ; 2 :
16584: LD_ADDR_VAR 0 5
16588: PUSH
16589: LD_INT 12
16591: ST_TO_ADDR
16592: GO 16633
16594: LD_INT 2
16596: DOUBLE
16597: EQUAL
16598: IFTRUE 16602
16600: GO 16613
16602: POP
// tech := tech_mortar ; 3 :
16603: LD_ADDR_VAR 0 5
16607: PUSH
16608: LD_INT 41
16610: ST_TO_ADDR
16611: GO 16633
16613: LD_INT 3
16615: DOUBLE
16616: EQUAL
16617: IFTRUE 16621
16619: GO 16632
16621: POP
// tech := tech_bazooka ; end ;
16622: LD_ADDR_VAR 0 5
16626: PUSH
16627: LD_INT 44
16629: ST_TO_ADDR
16630: GO 16633
16632: POP
// if Researched ( side , tech ) then
16633: LD_VAR 0 3
16637: PPUSH
16638: LD_VAR 0 5
16642: PPUSH
16643: CALL_OW 325
16647: IFFALSE 16674
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16649: LD_ADDR_VAR 0 2
16653: PUSH
16654: LD_INT 5
16656: PUSH
16657: LD_INT 8
16659: PUSH
16660: LD_INT 9
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: LIST
16667: PUSH
16668: LD_VAR 0 4
16672: ARRAY
16673: ST_TO_ADDR
// end ;
16674: LD_VAR 0 2
16678: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16679: LD_INT 0
16681: PPUSH
16682: PPUSH
16683: PPUSH
// if not mines then
16684: LD_VAR 0 2
16688: NOT
16689: IFFALSE 16693
// exit ;
16691: GO 16837
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16693: LD_ADDR_VAR 0 5
16697: PUSH
16698: LD_INT 81
16700: PUSH
16701: LD_VAR 0 1
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 3
16712: PUSH
16713: LD_INT 21
16715: PUSH
16716: LD_INT 3
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: PPUSH
16731: CALL_OW 69
16735: ST_TO_ADDR
// for i in mines do
16736: LD_ADDR_VAR 0 4
16740: PUSH
16741: LD_VAR 0 2
16745: PUSH
16746: FOR_IN
16747: IFFALSE 16835
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16749: LD_VAR 0 4
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: PPUSH
16758: LD_VAR 0 4
16762: PUSH
16763: LD_INT 2
16765: ARRAY
16766: PPUSH
16767: CALL_OW 458
16771: NOT
16772: IFFALSE 16776
// continue ;
16774: GO 16746
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16776: LD_VAR 0 4
16780: PUSH
16781: LD_INT 1
16783: ARRAY
16784: PPUSH
16785: LD_VAR 0 4
16789: PUSH
16790: LD_INT 2
16792: ARRAY
16793: PPUSH
16794: CALL_OW 428
16798: PUSH
16799: LD_VAR 0 5
16803: IN
16804: IFFALSE 16833
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16806: LD_VAR 0 4
16810: PUSH
16811: LD_INT 1
16813: ARRAY
16814: PPUSH
16815: LD_VAR 0 4
16819: PUSH
16820: LD_INT 2
16822: ARRAY
16823: PPUSH
16824: LD_VAR 0 1
16828: PPUSH
16829: CALL_OW 456
// end ;
16833: GO 16746
16835: POP
16836: POP
// end ;
16837: LD_VAR 0 3
16841: RET
// export function Count ( array ) ; var i ; begin
16842: LD_INT 0
16844: PPUSH
16845: PPUSH
// result := 0 ;
16846: LD_ADDR_VAR 0 2
16850: PUSH
16851: LD_INT 0
16853: ST_TO_ADDR
// for i in array do
16854: LD_ADDR_VAR 0 3
16858: PUSH
16859: LD_VAR 0 1
16863: PUSH
16864: FOR_IN
16865: IFFALSE 16889
// if i then
16867: LD_VAR 0 3
16871: IFFALSE 16887
// result := result + 1 ;
16873: LD_ADDR_VAR 0 2
16877: PUSH
16878: LD_VAR 0 2
16882: PUSH
16883: LD_INT 1
16885: PLUS
16886: ST_TO_ADDR
16887: GO 16864
16889: POP
16890: POP
// end ;
16891: LD_VAR 0 2
16895: RET
// export function IsEmpty ( building ) ; begin
16896: LD_INT 0
16898: PPUSH
// if not building then
16899: LD_VAR 0 1
16903: NOT
16904: IFFALSE 16908
// exit ;
16906: GO 16951
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16908: LD_ADDR_VAR 0 2
16912: PUSH
16913: LD_VAR 0 1
16917: PUSH
16918: LD_INT 22
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: CALL_OW 255
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: LD_INT 58
16937: PUSH
16938: EMPTY
16939: LIST
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PPUSH
16945: CALL_OW 69
16949: IN
16950: ST_TO_ADDR
// end ;
16951: LD_VAR 0 2
16955: RET
// export function IsNotFull ( building ) ; begin
16956: LD_INT 0
16958: PPUSH
// if not building then
16959: LD_VAR 0 1
16963: NOT
16964: IFFALSE 16968
// exit ;
16966: GO 16987
// result := UnitsInside ( building ) < 6 ;
16968: LD_ADDR_VAR 0 2
16972: PUSH
16973: LD_VAR 0 1
16977: PPUSH
16978: CALL_OW 313
16982: PUSH
16983: LD_INT 6
16985: LESS
16986: ST_TO_ADDR
// end ;
16987: LD_VAR 0 2
16991: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16992: LD_INT 0
16994: PPUSH
16995: PPUSH
16996: PPUSH
16997: PPUSH
// tmp := [ ] ;
16998: LD_ADDR_VAR 0 3
17002: PUSH
17003: EMPTY
17004: ST_TO_ADDR
// list := [ ] ;
17005: LD_ADDR_VAR 0 5
17009: PUSH
17010: EMPTY
17011: ST_TO_ADDR
// for i = 16 to 25 do
17012: LD_ADDR_VAR 0 4
17016: PUSH
17017: DOUBLE
17018: LD_INT 16
17020: DEC
17021: ST_TO_ADDR
17022: LD_INT 25
17024: PUSH
17025: FOR_TO
17026: IFFALSE 17099
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17028: LD_ADDR_VAR 0 3
17032: PUSH
17033: LD_VAR 0 3
17037: PUSH
17038: LD_INT 22
17040: PUSH
17041: LD_VAR 0 1
17045: PPUSH
17046: CALL_OW 255
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: PUSH
17055: LD_INT 91
17057: PUSH
17058: LD_VAR 0 1
17062: PUSH
17063: LD_INT 6
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: LIST
17070: PUSH
17071: LD_INT 30
17073: PUSH
17074: LD_VAR 0 4
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: LIST
17087: PUSH
17088: EMPTY
17089: LIST
17090: PPUSH
17091: CALL_OW 69
17095: ADD
17096: ST_TO_ADDR
17097: GO 17025
17099: POP
17100: POP
// for i = 1 to tmp do
17101: LD_ADDR_VAR 0 4
17105: PUSH
17106: DOUBLE
17107: LD_INT 1
17109: DEC
17110: ST_TO_ADDR
17111: LD_VAR 0 3
17115: PUSH
17116: FOR_TO
17117: IFFALSE 17205
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17119: LD_ADDR_VAR 0 5
17123: PUSH
17124: LD_VAR 0 5
17128: PUSH
17129: LD_VAR 0 3
17133: PUSH
17134: LD_VAR 0 4
17138: ARRAY
17139: PPUSH
17140: CALL_OW 266
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_VAR 0 4
17154: ARRAY
17155: PPUSH
17156: CALL_OW 250
17160: PUSH
17161: LD_VAR 0 3
17165: PUSH
17166: LD_VAR 0 4
17170: ARRAY
17171: PPUSH
17172: CALL_OW 251
17176: PUSH
17177: LD_VAR 0 3
17181: PUSH
17182: LD_VAR 0 4
17186: ARRAY
17187: PPUSH
17188: CALL_OW 254
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: PUSH
17199: EMPTY
17200: LIST
17201: ADD
17202: ST_TO_ADDR
17203: GO 17116
17205: POP
17206: POP
// result := list ;
17207: LD_ADDR_VAR 0 2
17211: PUSH
17212: LD_VAR 0 5
17216: ST_TO_ADDR
// end ;
17217: LD_VAR 0 2
17221: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17222: LD_INT 0
17224: PPUSH
17225: PPUSH
17226: PPUSH
17227: PPUSH
17228: PPUSH
17229: PPUSH
17230: PPUSH
// if not factory then
17231: LD_VAR 0 1
17235: NOT
17236: IFFALSE 17240
// exit ;
17238: GO 17833
// if control = control_apeman then
17240: LD_VAR 0 4
17244: PUSH
17245: LD_INT 5
17247: EQUAL
17248: IFFALSE 17357
// begin tmp := UnitsInside ( factory ) ;
17250: LD_ADDR_VAR 0 8
17254: PUSH
17255: LD_VAR 0 1
17259: PPUSH
17260: CALL_OW 313
17264: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17265: LD_VAR 0 8
17269: PPUSH
17270: LD_INT 25
17272: PUSH
17273: LD_INT 12
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PPUSH
17280: CALL_OW 72
17284: NOT
17285: IFFALSE 17295
// control := control_manual ;
17287: LD_ADDR_VAR 0 4
17291: PUSH
17292: LD_INT 1
17294: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17295: LD_ADDR_VAR 0 8
17299: PUSH
17300: LD_VAR 0 1
17304: PPUSH
17305: CALL 16992 0 1
17309: ST_TO_ADDR
// if tmp then
17310: LD_VAR 0 8
17314: IFFALSE 17357
// begin for i in tmp do
17316: LD_ADDR_VAR 0 7
17320: PUSH
17321: LD_VAR 0 8
17325: PUSH
17326: FOR_IN
17327: IFFALSE 17355
// if i [ 1 ] = b_ext_radio then
17329: LD_VAR 0 7
17333: PUSH
17334: LD_INT 1
17336: ARRAY
17337: PUSH
17338: LD_INT 22
17340: EQUAL
17341: IFFALSE 17353
// begin control := control_remote ;
17343: LD_ADDR_VAR 0 4
17347: PUSH
17348: LD_INT 2
17350: ST_TO_ADDR
// break ;
17351: GO 17355
// end ;
17353: GO 17326
17355: POP
17356: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17357: LD_VAR 0 1
17361: PPUSH
17362: LD_VAR 0 2
17366: PPUSH
17367: LD_VAR 0 3
17371: PPUSH
17372: LD_VAR 0 4
17376: PPUSH
17377: LD_VAR 0 5
17381: PPUSH
17382: CALL_OW 448
17386: IFFALSE 17421
// begin result := [ chassis , engine , control , weapon ] ;
17388: LD_ADDR_VAR 0 6
17392: PUSH
17393: LD_VAR 0 2
17397: PUSH
17398: LD_VAR 0 3
17402: PUSH
17403: LD_VAR 0 4
17407: PUSH
17408: LD_VAR 0 5
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: ST_TO_ADDR
// exit ;
17419: GO 17833
// end ; _chassis := AvailableChassisList ( factory ) ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_VAR 0 1
17430: PPUSH
17431: CALL_OW 475
17435: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17436: LD_ADDR_VAR 0 11
17440: PUSH
17441: LD_VAR 0 1
17445: PPUSH
17446: CALL_OW 476
17450: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17451: LD_ADDR_VAR 0 12
17455: PUSH
17456: LD_VAR 0 1
17460: PPUSH
17461: CALL_OW 477
17465: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17466: LD_ADDR_VAR 0 10
17470: PUSH
17471: LD_VAR 0 1
17475: PPUSH
17476: CALL_OW 478
17480: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17481: LD_VAR 0 9
17485: NOT
17486: PUSH
17487: LD_VAR 0 11
17491: NOT
17492: OR
17493: PUSH
17494: LD_VAR 0 12
17498: NOT
17499: OR
17500: PUSH
17501: LD_VAR 0 10
17505: NOT
17506: OR
17507: IFFALSE 17542
// begin result := [ chassis , engine , control , weapon ] ;
17509: LD_ADDR_VAR 0 6
17513: PUSH
17514: LD_VAR 0 2
17518: PUSH
17519: LD_VAR 0 3
17523: PUSH
17524: LD_VAR 0 4
17528: PUSH
17529: LD_VAR 0 5
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: ST_TO_ADDR
// exit ;
17540: GO 17833
// end ; if not chassis in _chassis then
17542: LD_VAR 0 2
17546: PUSH
17547: LD_VAR 0 9
17551: IN
17552: NOT
17553: IFFALSE 17579
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17555: LD_ADDR_VAR 0 2
17559: PUSH
17560: LD_VAR 0 9
17564: PUSH
17565: LD_INT 1
17567: PPUSH
17568: LD_VAR 0 9
17572: PPUSH
17573: CALL_OW 12
17577: ARRAY
17578: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17579: LD_VAR 0 2
17583: PPUSH
17584: LD_VAR 0 3
17588: PPUSH
17589: CALL 17838 0 2
17593: NOT
17594: IFFALSE 17653
// repeat engine := _engine [ 1 ] ;
17596: LD_ADDR_VAR 0 3
17600: PUSH
17601: LD_VAR 0 11
17605: PUSH
17606: LD_INT 1
17608: ARRAY
17609: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17610: LD_ADDR_VAR 0 11
17614: PUSH
17615: LD_VAR 0 11
17619: PPUSH
17620: LD_INT 1
17622: PPUSH
17623: CALL_OW 3
17627: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17628: LD_VAR 0 2
17632: PPUSH
17633: LD_VAR 0 3
17637: PPUSH
17638: CALL 17838 0 2
17642: PUSH
17643: LD_VAR 0 11
17647: PUSH
17648: EMPTY
17649: EQUAL
17650: OR
17651: IFFALSE 17596
// if not control in _control then
17653: LD_VAR 0 4
17657: PUSH
17658: LD_VAR 0 12
17662: IN
17663: NOT
17664: IFFALSE 17690
// control := _control [ rand ( 1 , _control ) ] ;
17666: LD_ADDR_VAR 0 4
17670: PUSH
17671: LD_VAR 0 12
17675: PUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_VAR 0 12
17683: PPUSH
17684: CALL_OW 12
17688: ARRAY
17689: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17690: LD_VAR 0 2
17694: PPUSH
17695: LD_VAR 0 5
17699: PPUSH
17700: CALL 18058 0 2
17704: NOT
17705: IFFALSE 17764
// repeat weapon := _weapon [ 1 ] ;
17707: LD_ADDR_VAR 0 5
17711: PUSH
17712: LD_VAR 0 10
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17721: LD_ADDR_VAR 0 10
17725: PUSH
17726: LD_VAR 0 10
17730: PPUSH
17731: LD_INT 1
17733: PPUSH
17734: CALL_OW 3
17738: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17739: LD_VAR 0 2
17743: PPUSH
17744: LD_VAR 0 5
17748: PPUSH
17749: CALL 18058 0 2
17753: PUSH
17754: LD_VAR 0 10
17758: PUSH
17759: EMPTY
17760: EQUAL
17761: OR
17762: IFFALSE 17707
// result := [ ] ;
17764: LD_ADDR_VAR 0 6
17768: PUSH
17769: EMPTY
17770: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_VAR 0 2
17780: PPUSH
17781: LD_VAR 0 3
17785: PPUSH
17786: LD_VAR 0 4
17790: PPUSH
17791: LD_VAR 0 5
17795: PPUSH
17796: CALL_OW 448
17800: IFFALSE 17833
// result := [ chassis , engine , control , weapon ] ;
17802: LD_ADDR_VAR 0 6
17806: PUSH
17807: LD_VAR 0 2
17811: PUSH
17812: LD_VAR 0 3
17816: PUSH
17817: LD_VAR 0 4
17821: PUSH
17822: LD_VAR 0 5
17826: PUSH
17827: EMPTY
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: ST_TO_ADDR
// end ;
17833: LD_VAR 0 6
17837: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17838: LD_INT 0
17840: PPUSH
// if not chassis or not engine then
17841: LD_VAR 0 1
17845: NOT
17846: PUSH
17847: LD_VAR 0 2
17851: NOT
17852: OR
17853: IFFALSE 17857
// exit ;
17855: GO 18053
// case engine of engine_solar :
17857: LD_VAR 0 2
17861: PUSH
17862: LD_INT 2
17864: DOUBLE
17865: EQUAL
17866: IFTRUE 17870
17868: GO 17908
17870: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17871: LD_ADDR_VAR 0 3
17875: PUSH
17876: LD_INT 11
17878: PUSH
17879: LD_INT 12
17881: PUSH
17882: LD_INT 13
17884: PUSH
17885: LD_INT 14
17887: PUSH
17888: LD_INT 1
17890: PUSH
17891: LD_INT 2
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: LIST
17904: LIST
17905: ST_TO_ADDR
17906: GO 18037
17908: LD_INT 1
17910: DOUBLE
17911: EQUAL
17912: IFTRUE 17916
17914: GO 17978
17916: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17917: LD_ADDR_VAR 0 3
17921: PUSH
17922: LD_INT 11
17924: PUSH
17925: LD_INT 12
17927: PUSH
17928: LD_INT 13
17930: PUSH
17931: LD_INT 14
17933: PUSH
17934: LD_INT 1
17936: PUSH
17937: LD_INT 2
17939: PUSH
17940: LD_INT 3
17942: PUSH
17943: LD_INT 4
17945: PUSH
17946: LD_INT 5
17948: PUSH
17949: LD_INT 21
17951: PUSH
17952: LD_INT 23
17954: PUSH
17955: LD_INT 22
17957: PUSH
17958: LD_INT 24
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: LIST
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: LIST
17971: LIST
17972: LIST
17973: LIST
17974: LIST
17975: ST_TO_ADDR
17976: GO 18037
17978: LD_INT 3
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18036
17986: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17987: LD_ADDR_VAR 0 3
17991: PUSH
17992: LD_INT 13
17994: PUSH
17995: LD_INT 14
17997: PUSH
17998: LD_INT 2
18000: PUSH
18001: LD_INT 3
18003: PUSH
18004: LD_INT 4
18006: PUSH
18007: LD_INT 5
18009: PUSH
18010: LD_INT 21
18012: PUSH
18013: LD_INT 22
18015: PUSH
18016: LD_INT 23
18018: PUSH
18019: LD_INT 24
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: ST_TO_ADDR
18034: GO 18037
18036: POP
// result := ( chassis in result ) ;
18037: LD_ADDR_VAR 0 3
18041: PUSH
18042: LD_VAR 0 1
18046: PUSH
18047: LD_VAR 0 3
18051: IN
18052: ST_TO_ADDR
// end ;
18053: LD_VAR 0 3
18057: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18058: LD_INT 0
18060: PPUSH
// if not chassis or not weapon then
18061: LD_VAR 0 1
18065: NOT
18066: PUSH
18067: LD_VAR 0 2
18071: NOT
18072: OR
18073: IFFALSE 18077
// exit ;
18075: GO 19139
// case weapon of us_machine_gun :
18077: LD_VAR 0 2
18081: PUSH
18082: LD_INT 2
18084: DOUBLE
18085: EQUAL
18086: IFTRUE 18090
18088: GO 18120
18090: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18091: LD_ADDR_VAR 0 3
18095: PUSH
18096: LD_INT 1
18098: PUSH
18099: LD_INT 2
18101: PUSH
18102: LD_INT 3
18104: PUSH
18105: LD_INT 4
18107: PUSH
18108: LD_INT 5
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: LIST
18117: ST_TO_ADDR
18118: GO 19123
18120: LD_INT 3
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18158
18128: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18129: LD_ADDR_VAR 0 3
18133: PUSH
18134: LD_INT 1
18136: PUSH
18137: LD_INT 2
18139: PUSH
18140: LD_INT 3
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: LD_INT 5
18148: PUSH
18149: EMPTY
18150: LIST
18151: LIST
18152: LIST
18153: LIST
18154: LIST
18155: ST_TO_ADDR
18156: GO 19123
18158: LD_INT 11
18160: DOUBLE
18161: EQUAL
18162: IFTRUE 18166
18164: GO 18196
18166: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18167: LD_ADDR_VAR 0 3
18171: PUSH
18172: LD_INT 1
18174: PUSH
18175: LD_INT 2
18177: PUSH
18178: LD_INT 3
18180: PUSH
18181: LD_INT 4
18183: PUSH
18184: LD_INT 5
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: ST_TO_ADDR
18194: GO 19123
18196: LD_INT 4
18198: DOUBLE
18199: EQUAL
18200: IFTRUE 18204
18202: GO 18230
18204: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18205: LD_ADDR_VAR 0 3
18209: PUSH
18210: LD_INT 2
18212: PUSH
18213: LD_INT 3
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: LD_INT 5
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: ST_TO_ADDR
18228: GO 19123
18230: LD_INT 5
18232: DOUBLE
18233: EQUAL
18234: IFTRUE 18238
18236: GO 18264
18238: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18239: LD_ADDR_VAR 0 3
18243: PUSH
18244: LD_INT 2
18246: PUSH
18247: LD_INT 3
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: LD_INT 5
18255: PUSH
18256: EMPTY
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: ST_TO_ADDR
18262: GO 19123
18264: LD_INT 9
18266: DOUBLE
18267: EQUAL
18268: IFTRUE 18272
18270: GO 18298
18272: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18273: LD_ADDR_VAR 0 3
18277: PUSH
18278: LD_INT 2
18280: PUSH
18281: LD_INT 3
18283: PUSH
18284: LD_INT 4
18286: PUSH
18287: LD_INT 5
18289: PUSH
18290: EMPTY
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: ST_TO_ADDR
18296: GO 19123
18298: LD_INT 7
18300: DOUBLE
18301: EQUAL
18302: IFTRUE 18306
18304: GO 18332
18306: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18307: LD_ADDR_VAR 0 3
18311: PUSH
18312: LD_INT 2
18314: PUSH
18315: LD_INT 3
18317: PUSH
18318: LD_INT 4
18320: PUSH
18321: LD_INT 5
18323: PUSH
18324: EMPTY
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: ST_TO_ADDR
18330: GO 19123
18332: LD_INT 12
18334: DOUBLE
18335: EQUAL
18336: IFTRUE 18340
18338: GO 18366
18340: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18341: LD_ADDR_VAR 0 3
18345: PUSH
18346: LD_INT 2
18348: PUSH
18349: LD_INT 3
18351: PUSH
18352: LD_INT 4
18354: PUSH
18355: LD_INT 5
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: ST_TO_ADDR
18364: GO 19123
18366: LD_INT 13
18368: DOUBLE
18369: EQUAL
18370: IFTRUE 18374
18372: GO 18400
18374: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18375: LD_ADDR_VAR 0 3
18379: PUSH
18380: LD_INT 2
18382: PUSH
18383: LD_INT 3
18385: PUSH
18386: LD_INT 4
18388: PUSH
18389: LD_INT 5
18391: PUSH
18392: EMPTY
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: ST_TO_ADDR
18398: GO 19123
18400: LD_INT 14
18402: DOUBLE
18403: EQUAL
18404: IFTRUE 18408
18406: GO 18426
18408: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18409: LD_ADDR_VAR 0 3
18413: PUSH
18414: LD_INT 4
18416: PUSH
18417: LD_INT 5
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: ST_TO_ADDR
18424: GO 19123
18426: LD_INT 6
18428: DOUBLE
18429: EQUAL
18430: IFTRUE 18434
18432: GO 18452
18434: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18435: LD_ADDR_VAR 0 3
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: LD_INT 5
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: ST_TO_ADDR
18450: GO 19123
18452: LD_INT 10
18454: DOUBLE
18455: EQUAL
18456: IFTRUE 18460
18458: GO 18478
18460: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18461: LD_ADDR_VAR 0 3
18465: PUSH
18466: LD_INT 4
18468: PUSH
18469: LD_INT 5
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: ST_TO_ADDR
18476: GO 19123
18478: LD_INT 22
18480: DOUBLE
18481: EQUAL
18482: IFTRUE 18486
18484: GO 18512
18486: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18487: LD_ADDR_VAR 0 3
18491: PUSH
18492: LD_INT 11
18494: PUSH
18495: LD_INT 12
18497: PUSH
18498: LD_INT 13
18500: PUSH
18501: LD_INT 14
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: ST_TO_ADDR
18510: GO 19123
18512: LD_INT 23
18514: DOUBLE
18515: EQUAL
18516: IFTRUE 18520
18518: GO 18546
18520: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18521: LD_ADDR_VAR 0 3
18525: PUSH
18526: LD_INT 11
18528: PUSH
18529: LD_INT 12
18531: PUSH
18532: LD_INT 13
18534: PUSH
18535: LD_INT 14
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: LIST
18542: LIST
18543: ST_TO_ADDR
18544: GO 19123
18546: LD_INT 24
18548: DOUBLE
18549: EQUAL
18550: IFTRUE 18554
18552: GO 18580
18554: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18555: LD_ADDR_VAR 0 3
18559: PUSH
18560: LD_INT 11
18562: PUSH
18563: LD_INT 12
18565: PUSH
18566: LD_INT 13
18568: PUSH
18569: LD_INT 14
18571: PUSH
18572: EMPTY
18573: LIST
18574: LIST
18575: LIST
18576: LIST
18577: ST_TO_ADDR
18578: GO 19123
18580: LD_INT 30
18582: DOUBLE
18583: EQUAL
18584: IFTRUE 18588
18586: GO 18614
18588: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18589: LD_ADDR_VAR 0 3
18593: PUSH
18594: LD_INT 11
18596: PUSH
18597: LD_INT 12
18599: PUSH
18600: LD_INT 13
18602: PUSH
18603: LD_INT 14
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: ST_TO_ADDR
18612: GO 19123
18614: LD_INT 25
18616: DOUBLE
18617: EQUAL
18618: IFTRUE 18622
18620: GO 18640
18622: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18623: LD_ADDR_VAR 0 3
18627: PUSH
18628: LD_INT 13
18630: PUSH
18631: LD_INT 14
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: ST_TO_ADDR
18638: GO 19123
18640: LD_INT 27
18642: DOUBLE
18643: EQUAL
18644: IFTRUE 18648
18646: GO 18666
18648: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18649: LD_ADDR_VAR 0 3
18653: PUSH
18654: LD_INT 13
18656: PUSH
18657: LD_INT 14
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: ST_TO_ADDR
18664: GO 19123
18666: LD_EXP 108
18670: DOUBLE
18671: EQUAL
18672: IFTRUE 18676
18674: GO 18702
18676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18677: LD_ADDR_VAR 0 3
18681: PUSH
18682: LD_INT 11
18684: PUSH
18685: LD_INT 12
18687: PUSH
18688: LD_INT 13
18690: PUSH
18691: LD_INT 14
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: LIST
18698: LIST
18699: ST_TO_ADDR
18700: GO 19123
18702: LD_INT 28
18704: DOUBLE
18705: EQUAL
18706: IFTRUE 18710
18708: GO 18728
18710: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18711: LD_ADDR_VAR 0 3
18715: PUSH
18716: LD_INT 13
18718: PUSH
18719: LD_INT 14
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: ST_TO_ADDR
18726: GO 19123
18728: LD_INT 29
18730: DOUBLE
18731: EQUAL
18732: IFTRUE 18736
18734: GO 18754
18736: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18737: LD_ADDR_VAR 0 3
18741: PUSH
18742: LD_INT 13
18744: PUSH
18745: LD_INT 14
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: ST_TO_ADDR
18752: GO 19123
18754: LD_INT 31
18756: DOUBLE
18757: EQUAL
18758: IFTRUE 18762
18760: GO 18780
18762: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18763: LD_ADDR_VAR 0 3
18767: PUSH
18768: LD_INT 13
18770: PUSH
18771: LD_INT 14
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: ST_TO_ADDR
18778: GO 19123
18780: LD_INT 26
18782: DOUBLE
18783: EQUAL
18784: IFTRUE 18788
18786: GO 18806
18788: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18789: LD_ADDR_VAR 0 3
18793: PUSH
18794: LD_INT 13
18796: PUSH
18797: LD_INT 14
18799: PUSH
18800: EMPTY
18801: LIST
18802: LIST
18803: ST_TO_ADDR
18804: GO 19123
18806: LD_INT 42
18808: DOUBLE
18809: EQUAL
18810: IFTRUE 18814
18812: GO 18840
18814: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18815: LD_ADDR_VAR 0 3
18819: PUSH
18820: LD_INT 21
18822: PUSH
18823: LD_INT 22
18825: PUSH
18826: LD_INT 23
18828: PUSH
18829: LD_INT 24
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: ST_TO_ADDR
18838: GO 19123
18840: LD_INT 43
18842: DOUBLE
18843: EQUAL
18844: IFTRUE 18848
18846: GO 18874
18848: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18849: LD_ADDR_VAR 0 3
18853: PUSH
18854: LD_INT 21
18856: PUSH
18857: LD_INT 22
18859: PUSH
18860: LD_INT 23
18862: PUSH
18863: LD_INT 24
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: ST_TO_ADDR
18872: GO 19123
18874: LD_INT 44
18876: DOUBLE
18877: EQUAL
18878: IFTRUE 18882
18880: GO 18908
18882: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18883: LD_ADDR_VAR 0 3
18887: PUSH
18888: LD_INT 21
18890: PUSH
18891: LD_INT 22
18893: PUSH
18894: LD_INT 23
18896: PUSH
18897: LD_INT 24
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: LIST
18904: LIST
18905: ST_TO_ADDR
18906: GO 19123
18908: LD_INT 45
18910: DOUBLE
18911: EQUAL
18912: IFTRUE 18916
18914: GO 18942
18916: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18917: LD_ADDR_VAR 0 3
18921: PUSH
18922: LD_INT 21
18924: PUSH
18925: LD_INT 22
18927: PUSH
18928: LD_INT 23
18930: PUSH
18931: LD_INT 24
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: LIST
18938: LIST
18939: ST_TO_ADDR
18940: GO 19123
18942: LD_INT 49
18944: DOUBLE
18945: EQUAL
18946: IFTRUE 18950
18948: GO 18976
18950: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18951: LD_ADDR_VAR 0 3
18955: PUSH
18956: LD_INT 21
18958: PUSH
18959: LD_INT 22
18961: PUSH
18962: LD_INT 23
18964: PUSH
18965: LD_INT 24
18967: PUSH
18968: EMPTY
18969: LIST
18970: LIST
18971: LIST
18972: LIST
18973: ST_TO_ADDR
18974: GO 19123
18976: LD_INT 51
18978: DOUBLE
18979: EQUAL
18980: IFTRUE 18984
18982: GO 19010
18984: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18985: LD_ADDR_VAR 0 3
18989: PUSH
18990: LD_INT 21
18992: PUSH
18993: LD_INT 22
18995: PUSH
18996: LD_INT 23
18998: PUSH
18999: LD_INT 24
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: ST_TO_ADDR
19008: GO 19123
19010: LD_INT 52
19012: DOUBLE
19013: EQUAL
19014: IFTRUE 19018
19016: GO 19044
19018: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19019: LD_ADDR_VAR 0 3
19023: PUSH
19024: LD_INT 21
19026: PUSH
19027: LD_INT 22
19029: PUSH
19030: LD_INT 23
19032: PUSH
19033: LD_INT 24
19035: PUSH
19036: EMPTY
19037: LIST
19038: LIST
19039: LIST
19040: LIST
19041: ST_TO_ADDR
19042: GO 19123
19044: LD_INT 53
19046: DOUBLE
19047: EQUAL
19048: IFTRUE 19052
19050: GO 19070
19052: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19053: LD_ADDR_VAR 0 3
19057: PUSH
19058: LD_INT 23
19060: PUSH
19061: LD_INT 24
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: ST_TO_ADDR
19068: GO 19123
19070: LD_INT 46
19072: DOUBLE
19073: EQUAL
19074: IFTRUE 19078
19076: GO 19096
19078: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19079: LD_ADDR_VAR 0 3
19083: PUSH
19084: LD_INT 23
19086: PUSH
19087: LD_INT 24
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: ST_TO_ADDR
19094: GO 19123
19096: LD_INT 47
19098: DOUBLE
19099: EQUAL
19100: IFTRUE 19104
19102: GO 19122
19104: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19105: LD_ADDR_VAR 0 3
19109: PUSH
19110: LD_INT 23
19112: PUSH
19113: LD_INT 24
19115: PUSH
19116: EMPTY
19117: LIST
19118: LIST
19119: ST_TO_ADDR
19120: GO 19123
19122: POP
// result := ( chassis in result ) ;
19123: LD_ADDR_VAR 0 3
19127: PUSH
19128: LD_VAR 0 1
19132: PUSH
19133: LD_VAR 0 3
19137: IN
19138: ST_TO_ADDR
// end ;
19139: LD_VAR 0 3
19143: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19144: LD_INT 0
19146: PPUSH
19147: PPUSH
19148: PPUSH
19149: PPUSH
19150: PPUSH
19151: PPUSH
19152: PPUSH
// result := array ;
19153: LD_ADDR_VAR 0 5
19157: PUSH
19158: LD_VAR 0 1
19162: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19163: LD_VAR 0 1
19167: NOT
19168: PUSH
19169: LD_VAR 0 2
19173: NOT
19174: OR
19175: PUSH
19176: LD_VAR 0 3
19180: NOT
19181: OR
19182: PUSH
19183: LD_VAR 0 2
19187: PUSH
19188: LD_VAR 0 1
19192: GREATER
19193: OR
19194: PUSH
19195: LD_VAR 0 3
19199: PUSH
19200: LD_VAR 0 1
19204: GREATER
19205: OR
19206: IFFALSE 19210
// exit ;
19208: GO 19506
// if direction then
19210: LD_VAR 0 4
19214: IFFALSE 19278
// begin d := 1 ;
19216: LD_ADDR_VAR 0 9
19220: PUSH
19221: LD_INT 1
19223: ST_TO_ADDR
// if i_from > i_to then
19224: LD_VAR 0 2
19228: PUSH
19229: LD_VAR 0 3
19233: GREATER
19234: IFFALSE 19260
// length := ( array - i_from ) + i_to else
19236: LD_ADDR_VAR 0 11
19240: PUSH
19241: LD_VAR 0 1
19245: PUSH
19246: LD_VAR 0 2
19250: MINUS
19251: PUSH
19252: LD_VAR 0 3
19256: PLUS
19257: ST_TO_ADDR
19258: GO 19276
// length := i_to - i_from ;
19260: LD_ADDR_VAR 0 11
19264: PUSH
19265: LD_VAR 0 3
19269: PUSH
19270: LD_VAR 0 2
19274: MINUS
19275: ST_TO_ADDR
// end else
19276: GO 19339
// begin d := - 1 ;
19278: LD_ADDR_VAR 0 9
19282: PUSH
19283: LD_INT 1
19285: NEG
19286: ST_TO_ADDR
// if i_from > i_to then
19287: LD_VAR 0 2
19291: PUSH
19292: LD_VAR 0 3
19296: GREATER
19297: IFFALSE 19317
// length := i_from - i_to else
19299: LD_ADDR_VAR 0 11
19303: PUSH
19304: LD_VAR 0 2
19308: PUSH
19309: LD_VAR 0 3
19313: MINUS
19314: ST_TO_ADDR
19315: GO 19339
// length := ( array - i_to ) + i_from ;
19317: LD_ADDR_VAR 0 11
19321: PUSH
19322: LD_VAR 0 1
19326: PUSH
19327: LD_VAR 0 3
19331: MINUS
19332: PUSH
19333: LD_VAR 0 2
19337: PLUS
19338: ST_TO_ADDR
// end ; if not length then
19339: LD_VAR 0 11
19343: NOT
19344: IFFALSE 19348
// exit ;
19346: GO 19506
// tmp := array ;
19348: LD_ADDR_VAR 0 10
19352: PUSH
19353: LD_VAR 0 1
19357: ST_TO_ADDR
// for i = 1 to length do
19358: LD_ADDR_VAR 0 6
19362: PUSH
19363: DOUBLE
19364: LD_INT 1
19366: DEC
19367: ST_TO_ADDR
19368: LD_VAR 0 11
19372: PUSH
19373: FOR_TO
19374: IFFALSE 19494
// begin for j = 1 to array do
19376: LD_ADDR_VAR 0 7
19380: PUSH
19381: DOUBLE
19382: LD_INT 1
19384: DEC
19385: ST_TO_ADDR
19386: LD_VAR 0 1
19390: PUSH
19391: FOR_TO
19392: IFFALSE 19480
// begin k := j + d ;
19394: LD_ADDR_VAR 0 8
19398: PUSH
19399: LD_VAR 0 7
19403: PUSH
19404: LD_VAR 0 9
19408: PLUS
19409: ST_TO_ADDR
// if k > array then
19410: LD_VAR 0 8
19414: PUSH
19415: LD_VAR 0 1
19419: GREATER
19420: IFFALSE 19430
// k := 1 ;
19422: LD_ADDR_VAR 0 8
19426: PUSH
19427: LD_INT 1
19429: ST_TO_ADDR
// if not k then
19430: LD_VAR 0 8
19434: NOT
19435: IFFALSE 19447
// k := array ;
19437: LD_ADDR_VAR 0 8
19441: PUSH
19442: LD_VAR 0 1
19446: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19447: LD_ADDR_VAR 0 10
19451: PUSH
19452: LD_VAR 0 10
19456: PPUSH
19457: LD_VAR 0 8
19461: PPUSH
19462: LD_VAR 0 1
19466: PUSH
19467: LD_VAR 0 7
19471: ARRAY
19472: PPUSH
19473: CALL_OW 1
19477: ST_TO_ADDR
// end ;
19478: GO 19391
19480: POP
19481: POP
// array := tmp ;
19482: LD_ADDR_VAR 0 1
19486: PUSH
19487: LD_VAR 0 10
19491: ST_TO_ADDR
// end ;
19492: GO 19373
19494: POP
19495: POP
// result := array ;
19496: LD_ADDR_VAR 0 5
19500: PUSH
19501: LD_VAR 0 1
19505: ST_TO_ADDR
// end ;
19506: LD_VAR 0 5
19510: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19511: LD_INT 0
19513: PPUSH
19514: PPUSH
// result := 0 ;
19515: LD_ADDR_VAR 0 3
19519: PUSH
19520: LD_INT 0
19522: ST_TO_ADDR
// if not array or not value in array then
19523: LD_VAR 0 1
19527: NOT
19528: PUSH
19529: LD_VAR 0 2
19533: PUSH
19534: LD_VAR 0 1
19538: IN
19539: NOT
19540: OR
19541: IFFALSE 19545
// exit ;
19543: GO 19599
// for i = 1 to array do
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: DOUBLE
19551: LD_INT 1
19553: DEC
19554: ST_TO_ADDR
19555: LD_VAR 0 1
19559: PUSH
19560: FOR_TO
19561: IFFALSE 19597
// if value = array [ i ] then
19563: LD_VAR 0 2
19567: PUSH
19568: LD_VAR 0 1
19572: PUSH
19573: LD_VAR 0 4
19577: ARRAY
19578: EQUAL
19579: IFFALSE 19595
// begin result := i ;
19581: LD_ADDR_VAR 0 3
19585: PUSH
19586: LD_VAR 0 4
19590: ST_TO_ADDR
// exit ;
19591: POP
19592: POP
19593: GO 19599
// end ;
19595: GO 19560
19597: POP
19598: POP
// end ;
19599: LD_VAR 0 3
19603: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19604: LD_INT 0
19606: PPUSH
// vc_chassis := chassis ;
19607: LD_ADDR_OWVAR 37
19611: PUSH
19612: LD_VAR 0 1
19616: ST_TO_ADDR
// vc_engine := engine ;
19617: LD_ADDR_OWVAR 39
19621: PUSH
19622: LD_VAR 0 2
19626: ST_TO_ADDR
// vc_control := control ;
19627: LD_ADDR_OWVAR 38
19631: PUSH
19632: LD_VAR 0 3
19636: ST_TO_ADDR
// vc_weapon := weapon ;
19637: LD_ADDR_OWVAR 40
19641: PUSH
19642: LD_VAR 0 4
19646: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19647: LD_ADDR_OWVAR 41
19651: PUSH
19652: LD_VAR 0 5
19656: ST_TO_ADDR
// end ;
19657: LD_VAR 0 6
19661: RET
// export function WantPlant ( unit ) ; var task ; begin
19662: LD_INT 0
19664: PPUSH
19665: PPUSH
// result := false ;
19666: LD_ADDR_VAR 0 2
19670: PUSH
19671: LD_INT 0
19673: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19674: LD_ADDR_VAR 0 3
19678: PUSH
19679: LD_VAR 0 1
19683: PPUSH
19684: CALL_OW 437
19688: ST_TO_ADDR
// if task then
19689: LD_VAR 0 3
19693: IFFALSE 19721
// if task [ 1 ] [ 1 ] = p then
19695: LD_VAR 0 3
19699: PUSH
19700: LD_INT 1
19702: ARRAY
19703: PUSH
19704: LD_INT 1
19706: ARRAY
19707: PUSH
19708: LD_STRING p
19710: EQUAL
19711: IFFALSE 19721
// result := true ;
19713: LD_ADDR_VAR 0 2
19717: PUSH
19718: LD_INT 1
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 2
19725: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if pos < 1 then
19732: LD_VAR 0 2
19736: PUSH
19737: LD_INT 1
19739: LESS
19740: IFFALSE 19744
// exit ;
19742: GO 20047
// if pos = 1 then
19744: LD_VAR 0 2
19748: PUSH
19749: LD_INT 1
19751: EQUAL
19752: IFFALSE 19785
// result := Replace ( arr , pos [ 1 ] , value ) else
19754: LD_ADDR_VAR 0 4
19758: PUSH
19759: LD_VAR 0 1
19763: PPUSH
19764: LD_VAR 0 2
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_VAR 0 3
19777: PPUSH
19778: CALL_OW 1
19782: ST_TO_ADDR
19783: GO 20047
// begin tmp := arr ;
19785: LD_ADDR_VAR 0 6
19789: PUSH
19790: LD_VAR 0 1
19794: ST_TO_ADDR
// s_arr := [ tmp ] ;
19795: LD_ADDR_VAR 0 7
19799: PUSH
19800: LD_VAR 0 6
19804: PUSH
19805: EMPTY
19806: LIST
19807: ST_TO_ADDR
// for i = 1 to pos - 1 do
19808: LD_ADDR_VAR 0 5
19812: PUSH
19813: DOUBLE
19814: LD_INT 1
19816: DEC
19817: ST_TO_ADDR
19818: LD_VAR 0 2
19822: PUSH
19823: LD_INT 1
19825: MINUS
19826: PUSH
19827: FOR_TO
19828: IFFALSE 19873
// begin tmp := tmp [ pos [ i ] ] ;
19830: LD_ADDR_VAR 0 6
19834: PUSH
19835: LD_VAR 0 6
19839: PUSH
19840: LD_VAR 0 2
19844: PUSH
19845: LD_VAR 0 5
19849: ARRAY
19850: ARRAY
19851: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19852: LD_ADDR_VAR 0 7
19856: PUSH
19857: LD_VAR 0 7
19861: PUSH
19862: LD_VAR 0 6
19866: PUSH
19867: EMPTY
19868: LIST
19869: ADD
19870: ST_TO_ADDR
// end ;
19871: GO 19827
19873: POP
19874: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19875: LD_ADDR_VAR 0 6
19879: PUSH
19880: LD_VAR 0 6
19884: PPUSH
19885: LD_VAR 0 2
19889: PUSH
19890: LD_VAR 0 2
19894: ARRAY
19895: PPUSH
19896: LD_VAR 0 3
19900: PPUSH
19901: CALL_OW 1
19905: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19906: LD_ADDR_VAR 0 7
19910: PUSH
19911: LD_VAR 0 7
19915: PPUSH
19916: LD_VAR 0 7
19920: PPUSH
19921: LD_VAR 0 6
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// for i = s_arr downto 2 do
19931: LD_ADDR_VAR 0 5
19935: PUSH
19936: DOUBLE
19937: LD_VAR 0 7
19941: INC
19942: ST_TO_ADDR
19943: LD_INT 2
19945: PUSH
19946: FOR_DOWNTO
19947: IFFALSE 20031
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19949: LD_ADDR_VAR 0 6
19953: PUSH
19954: LD_VAR 0 7
19958: PUSH
19959: LD_VAR 0 5
19963: PUSH
19964: LD_INT 1
19966: MINUS
19967: ARRAY
19968: PPUSH
19969: LD_VAR 0 2
19973: PUSH
19974: LD_VAR 0 5
19978: PUSH
19979: LD_INT 1
19981: MINUS
19982: ARRAY
19983: PPUSH
19984: LD_VAR 0 7
19988: PUSH
19989: LD_VAR 0 5
19993: ARRAY
19994: PPUSH
19995: CALL_OW 1
19999: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20000: LD_ADDR_VAR 0 7
20004: PUSH
20005: LD_VAR 0 7
20009: PPUSH
20010: LD_VAR 0 5
20014: PUSH
20015: LD_INT 1
20017: MINUS
20018: PPUSH
20019: LD_VAR 0 6
20023: PPUSH
20024: CALL_OW 1
20028: ST_TO_ADDR
// end ;
20029: GO 19946
20031: POP
20032: POP
// result := s_arr [ 1 ] ;
20033: LD_ADDR_VAR 0 4
20037: PUSH
20038: LD_VAR 0 7
20042: PUSH
20043: LD_INT 1
20045: ARRAY
20046: ST_TO_ADDR
// end ; end ;
20047: LD_VAR 0 4
20051: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20052: LD_INT 0
20054: PPUSH
20055: PPUSH
// if not list then
20056: LD_VAR 0 1
20060: NOT
20061: IFFALSE 20065
// exit ;
20063: GO 20156
// i := list [ pos1 ] ;
20065: LD_ADDR_VAR 0 5
20069: PUSH
20070: LD_VAR 0 1
20074: PUSH
20075: LD_VAR 0 2
20079: ARRAY
20080: ST_TO_ADDR
// if not i then
20081: LD_VAR 0 5
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20156
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20090: LD_ADDR_VAR 0 1
20094: PUSH
20095: LD_VAR 0 1
20099: PPUSH
20100: LD_VAR 0 2
20104: PPUSH
20105: LD_VAR 0 1
20109: PUSH
20110: LD_VAR 0 3
20114: ARRAY
20115: PPUSH
20116: CALL_OW 1
20120: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20121: LD_ADDR_VAR 0 1
20125: PUSH
20126: LD_VAR 0 1
20130: PPUSH
20131: LD_VAR 0 3
20135: PPUSH
20136: LD_VAR 0 5
20140: PPUSH
20141: CALL_OW 1
20145: ST_TO_ADDR
// result := list ;
20146: LD_ADDR_VAR 0 4
20150: PUSH
20151: LD_VAR 0 1
20155: ST_TO_ADDR
// end ;
20156: LD_VAR 0 4
20160: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20161: LD_INT 0
20163: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20164: LD_ADDR_VAR 0 5
20168: PUSH
20169: LD_VAR 0 1
20173: PPUSH
20174: CALL_OW 250
20178: PPUSH
20179: LD_VAR 0 1
20183: PPUSH
20184: CALL_OW 251
20188: PPUSH
20189: LD_VAR 0 2
20193: PPUSH
20194: LD_VAR 0 3
20198: PPUSH
20199: LD_VAR 0 4
20203: PPUSH
20204: CALL 20214 0 5
20208: ST_TO_ADDR
// end ;
20209: LD_VAR 0 5
20213: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20214: LD_INT 0
20216: PPUSH
20217: PPUSH
20218: PPUSH
20219: PPUSH
// if not list then
20220: LD_VAR 0 3
20224: NOT
20225: IFFALSE 20229
// exit ;
20227: GO 20617
// result := [ ] ;
20229: LD_ADDR_VAR 0 6
20233: PUSH
20234: EMPTY
20235: ST_TO_ADDR
// for i in list do
20236: LD_ADDR_VAR 0 7
20240: PUSH
20241: LD_VAR 0 3
20245: PUSH
20246: FOR_IN
20247: IFFALSE 20449
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20249: LD_ADDR_VAR 0 9
20253: PUSH
20254: LD_VAR 0 7
20258: PPUSH
20259: LD_VAR 0 1
20263: PPUSH
20264: LD_VAR 0 2
20268: PPUSH
20269: CALL_OW 297
20273: ST_TO_ADDR
// if not result then
20274: LD_VAR 0 6
20278: NOT
20279: IFFALSE 20305
// result := [ [ i , tmp ] ] else
20281: LD_ADDR_VAR 0 6
20285: PUSH
20286: LD_VAR 0 7
20290: PUSH
20291: LD_VAR 0 9
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: PUSH
20300: EMPTY
20301: LIST
20302: ST_TO_ADDR
20303: GO 20447
// begin if result [ result ] [ 2 ] < tmp then
20305: LD_VAR 0 6
20309: PUSH
20310: LD_VAR 0 6
20314: ARRAY
20315: PUSH
20316: LD_INT 2
20318: ARRAY
20319: PUSH
20320: LD_VAR 0 9
20324: LESS
20325: IFFALSE 20367
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20327: LD_ADDR_VAR 0 6
20331: PUSH
20332: LD_VAR 0 6
20336: PPUSH
20337: LD_VAR 0 6
20341: PUSH
20342: LD_INT 1
20344: PLUS
20345: PPUSH
20346: LD_VAR 0 7
20350: PUSH
20351: LD_VAR 0 9
20355: PUSH
20356: EMPTY
20357: LIST
20358: LIST
20359: PPUSH
20360: CALL_OW 2
20364: ST_TO_ADDR
20365: GO 20447
// for j = 1 to result do
20367: LD_ADDR_VAR 0 8
20371: PUSH
20372: DOUBLE
20373: LD_INT 1
20375: DEC
20376: ST_TO_ADDR
20377: LD_VAR 0 6
20381: PUSH
20382: FOR_TO
20383: IFFALSE 20445
// begin if tmp < result [ j ] [ 2 ] then
20385: LD_VAR 0 9
20389: PUSH
20390: LD_VAR 0 6
20394: PUSH
20395: LD_VAR 0 8
20399: ARRAY
20400: PUSH
20401: LD_INT 2
20403: ARRAY
20404: LESS
20405: IFFALSE 20443
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20407: LD_ADDR_VAR 0 6
20411: PUSH
20412: LD_VAR 0 6
20416: PPUSH
20417: LD_VAR 0 8
20421: PPUSH
20422: LD_VAR 0 7
20426: PUSH
20427: LD_VAR 0 9
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PPUSH
20436: CALL_OW 2
20440: ST_TO_ADDR
// break ;
20441: GO 20445
// end ; end ;
20443: GO 20382
20445: POP
20446: POP
// end ; end ;
20447: GO 20246
20449: POP
20450: POP
// if result and not asc then
20451: LD_VAR 0 6
20455: PUSH
20456: LD_VAR 0 4
20460: NOT
20461: AND
20462: IFFALSE 20537
// begin tmp := result ;
20464: LD_ADDR_VAR 0 9
20468: PUSH
20469: LD_VAR 0 6
20473: ST_TO_ADDR
// for i = tmp downto 1 do
20474: LD_ADDR_VAR 0 7
20478: PUSH
20479: DOUBLE
20480: LD_VAR 0 9
20484: INC
20485: ST_TO_ADDR
20486: LD_INT 1
20488: PUSH
20489: FOR_DOWNTO
20490: IFFALSE 20535
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20492: LD_ADDR_VAR 0 6
20496: PUSH
20497: LD_VAR 0 6
20501: PPUSH
20502: LD_VAR 0 9
20506: PUSH
20507: LD_VAR 0 7
20511: MINUS
20512: PUSH
20513: LD_INT 1
20515: PLUS
20516: PPUSH
20517: LD_VAR 0 9
20521: PUSH
20522: LD_VAR 0 7
20526: ARRAY
20527: PPUSH
20528: CALL_OW 1
20532: ST_TO_ADDR
20533: GO 20489
20535: POP
20536: POP
// end ; tmp := [ ] ;
20537: LD_ADDR_VAR 0 9
20541: PUSH
20542: EMPTY
20543: ST_TO_ADDR
// if mode then
20544: LD_VAR 0 5
20548: IFFALSE 20617
// begin for i = 1 to result do
20550: LD_ADDR_VAR 0 7
20554: PUSH
20555: DOUBLE
20556: LD_INT 1
20558: DEC
20559: ST_TO_ADDR
20560: LD_VAR 0 6
20564: PUSH
20565: FOR_TO
20566: IFFALSE 20605
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_VAR 0 9
20577: PPUSH
20578: LD_VAR 0 7
20582: PPUSH
20583: LD_VAR 0 6
20587: PUSH
20588: LD_VAR 0 7
20592: ARRAY
20593: PUSH
20594: LD_INT 1
20596: ARRAY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
20603: GO 20565
20605: POP
20606: POP
// result := tmp ;
20607: LD_ADDR_VAR 0 6
20611: PUSH
20612: LD_VAR 0 9
20616: ST_TO_ADDR
// end ; end ;
20617: LD_VAR 0 6
20621: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20622: LD_INT 0
20624: PPUSH
20625: PPUSH
20626: PPUSH
20627: PPUSH
20628: PPUSH
20629: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20630: LD_ADDR_VAR 0 5
20634: PUSH
20635: LD_INT 0
20637: PUSH
20638: LD_INT 0
20640: PUSH
20641: LD_INT 0
20643: PUSH
20644: EMPTY
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: ST_TO_ADDR
// if not x or not y then
20652: LD_VAR 0 2
20656: NOT
20657: PUSH
20658: LD_VAR 0 3
20662: NOT
20663: OR
20664: IFFALSE 20668
// exit ;
20666: GO 22320
// if not range then
20668: LD_VAR 0 4
20672: NOT
20673: IFFALSE 20683
// range := 10 ;
20675: LD_ADDR_VAR 0 4
20679: PUSH
20680: LD_INT 10
20682: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20683: LD_ADDR_VAR 0 8
20687: PUSH
20688: LD_INT 81
20690: PUSH
20691: LD_VAR 0 1
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: PUSH
20700: LD_INT 92
20702: PUSH
20703: LD_VAR 0 2
20707: PUSH
20708: LD_VAR 0 3
20712: PUSH
20713: LD_VAR 0 4
20717: PUSH
20718: EMPTY
20719: LIST
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_INT 3
20726: PUSH
20727: LD_INT 21
20729: PUSH
20730: LD_INT 3
20732: PUSH
20733: EMPTY
20734: LIST
20735: LIST
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: PUSH
20741: EMPTY
20742: LIST
20743: LIST
20744: LIST
20745: PPUSH
20746: CALL_OW 69
20750: ST_TO_ADDR
// if not tmp then
20751: LD_VAR 0 8
20755: NOT
20756: IFFALSE 20760
// exit ;
20758: GO 22320
// for i in tmp do
20760: LD_ADDR_VAR 0 6
20764: PUSH
20765: LD_VAR 0 8
20769: PUSH
20770: FOR_IN
20771: IFFALSE 22295
// begin points := [ 0 , 0 , 0 ] ;
20773: LD_ADDR_VAR 0 9
20777: PUSH
20778: LD_INT 0
20780: PUSH
20781: LD_INT 0
20783: PUSH
20784: LD_INT 0
20786: PUSH
20787: EMPTY
20788: LIST
20789: LIST
20790: LIST
20791: ST_TO_ADDR
// bpoints := 1 ;
20792: LD_ADDR_VAR 0 10
20796: PUSH
20797: LD_INT 1
20799: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20800: LD_VAR 0 6
20804: PPUSH
20805: CALL_OW 247
20809: PUSH
20810: LD_INT 1
20812: DOUBLE
20813: EQUAL
20814: IFTRUE 20818
20816: GO 21396
20818: POP
// begin if GetClass ( i ) = 1 then
20819: LD_VAR 0 6
20823: PPUSH
20824: CALL_OW 257
20828: PUSH
20829: LD_INT 1
20831: EQUAL
20832: IFFALSE 20853
// points := [ 10 , 5 , 3 ] ;
20834: LD_ADDR_VAR 0 9
20838: PUSH
20839: LD_INT 10
20841: PUSH
20842: LD_INT 5
20844: PUSH
20845: LD_INT 3
20847: PUSH
20848: EMPTY
20849: LIST
20850: LIST
20851: LIST
20852: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20853: LD_VAR 0 6
20857: PPUSH
20858: CALL_OW 257
20862: PUSH
20863: LD_INT 2
20865: PUSH
20866: LD_INT 3
20868: PUSH
20869: LD_INT 4
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: IN
20877: IFFALSE 20898
// points := [ 3 , 2 , 1 ] ;
20879: LD_ADDR_VAR 0 9
20883: PUSH
20884: LD_INT 3
20886: PUSH
20887: LD_INT 2
20889: PUSH
20890: LD_INT 1
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 257
20907: PUSH
20908: LD_INT 5
20910: EQUAL
20911: IFFALSE 20932
// points := [ 130 , 5 , 2 ] ;
20913: LD_ADDR_VAR 0 9
20917: PUSH
20918: LD_INT 130
20920: PUSH
20921: LD_INT 5
20923: PUSH
20924: LD_INT 2
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: LIST
20931: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20932: LD_VAR 0 6
20936: PPUSH
20937: CALL_OW 257
20941: PUSH
20942: LD_INT 8
20944: EQUAL
20945: IFFALSE 20966
// points := [ 35 , 35 , 30 ] ;
20947: LD_ADDR_VAR 0 9
20951: PUSH
20952: LD_INT 35
20954: PUSH
20955: LD_INT 35
20957: PUSH
20958: LD_INT 30
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20966: LD_VAR 0 6
20970: PPUSH
20971: CALL_OW 257
20975: PUSH
20976: LD_INT 9
20978: EQUAL
20979: IFFALSE 21000
// points := [ 20 , 55 , 40 ] ;
20981: LD_ADDR_VAR 0 9
20985: PUSH
20986: LD_INT 20
20988: PUSH
20989: LD_INT 55
20991: PUSH
20992: LD_INT 40
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21000: LD_VAR 0 6
21004: PPUSH
21005: CALL_OW 257
21009: PUSH
21010: LD_INT 12
21012: PUSH
21013: LD_INT 16
21015: PUSH
21016: EMPTY
21017: LIST
21018: LIST
21019: IN
21020: IFFALSE 21041
// points := [ 5 , 3 , 2 ] ;
21022: LD_ADDR_VAR 0 9
21026: PUSH
21027: LD_INT 5
21029: PUSH
21030: LD_INT 3
21032: PUSH
21033: LD_INT 2
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: LIST
21040: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21041: LD_VAR 0 6
21045: PPUSH
21046: CALL_OW 257
21050: PUSH
21051: LD_INT 17
21053: EQUAL
21054: IFFALSE 21075
// points := [ 100 , 50 , 75 ] ;
21056: LD_ADDR_VAR 0 9
21060: PUSH
21061: LD_INT 100
21063: PUSH
21064: LD_INT 50
21066: PUSH
21067: LD_INT 75
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: LIST
21074: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21075: LD_VAR 0 6
21079: PPUSH
21080: CALL_OW 257
21084: PUSH
21085: LD_INT 15
21087: EQUAL
21088: IFFALSE 21109
// points := [ 10 , 5 , 3 ] ;
21090: LD_ADDR_VAR 0 9
21094: PUSH
21095: LD_INT 10
21097: PUSH
21098: LD_INT 5
21100: PUSH
21101: LD_INT 3
21103: PUSH
21104: EMPTY
21105: LIST
21106: LIST
21107: LIST
21108: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21109: LD_VAR 0 6
21113: PPUSH
21114: CALL_OW 257
21118: PUSH
21119: LD_INT 14
21121: EQUAL
21122: IFFALSE 21143
// points := [ 10 , 0 , 0 ] ;
21124: LD_ADDR_VAR 0 9
21128: PUSH
21129: LD_INT 10
21131: PUSH
21132: LD_INT 0
21134: PUSH
21135: LD_INT 0
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: LIST
21142: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21143: LD_VAR 0 6
21147: PPUSH
21148: CALL_OW 257
21152: PUSH
21153: LD_INT 11
21155: EQUAL
21156: IFFALSE 21177
// points := [ 30 , 10 , 5 ] ;
21158: LD_ADDR_VAR 0 9
21162: PUSH
21163: LD_INT 30
21165: PUSH
21166: LD_INT 10
21168: PUSH
21169: LD_INT 5
21171: PUSH
21172: EMPTY
21173: LIST
21174: LIST
21175: LIST
21176: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21177: LD_VAR 0 1
21181: PPUSH
21182: LD_INT 5
21184: PPUSH
21185: CALL_OW 321
21189: PUSH
21190: LD_INT 2
21192: EQUAL
21193: IFFALSE 21210
// bpoints := bpoints * 1.8 ;
21195: LD_ADDR_VAR 0 10
21199: PUSH
21200: LD_VAR 0 10
21204: PUSH
21205: LD_REAL  1.80000000000000E+0000
21208: MUL
21209: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21210: LD_VAR 0 6
21214: PPUSH
21215: CALL_OW 257
21219: PUSH
21220: LD_INT 1
21222: PUSH
21223: LD_INT 2
21225: PUSH
21226: LD_INT 3
21228: PUSH
21229: LD_INT 4
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: LIST
21236: LIST
21237: IN
21238: PUSH
21239: LD_VAR 0 1
21243: PPUSH
21244: LD_INT 51
21246: PPUSH
21247: CALL_OW 321
21251: PUSH
21252: LD_INT 2
21254: EQUAL
21255: AND
21256: IFFALSE 21273
// bpoints := bpoints * 1.2 ;
21258: LD_ADDR_VAR 0 10
21262: PUSH
21263: LD_VAR 0 10
21267: PUSH
21268: LD_REAL  1.20000000000000E+0000
21271: MUL
21272: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21273: LD_VAR 0 6
21277: PPUSH
21278: CALL_OW 257
21282: PUSH
21283: LD_INT 5
21285: PUSH
21286: LD_INT 7
21288: PUSH
21289: LD_INT 9
21291: PUSH
21292: EMPTY
21293: LIST
21294: LIST
21295: LIST
21296: IN
21297: PUSH
21298: LD_VAR 0 1
21302: PPUSH
21303: LD_INT 52
21305: PPUSH
21306: CALL_OW 321
21310: PUSH
21311: LD_INT 2
21313: EQUAL
21314: AND
21315: IFFALSE 21332
// bpoints := bpoints * 1.5 ;
21317: LD_ADDR_VAR 0 10
21321: PUSH
21322: LD_VAR 0 10
21326: PUSH
21327: LD_REAL  1.50000000000000E+0000
21330: MUL
21331: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21332: LD_VAR 0 1
21336: PPUSH
21337: LD_INT 66
21339: PPUSH
21340: CALL_OW 321
21344: PUSH
21345: LD_INT 2
21347: EQUAL
21348: IFFALSE 21365
// bpoints := bpoints * 1.1 ;
21350: LD_ADDR_VAR 0 10
21354: PUSH
21355: LD_VAR 0 10
21359: PUSH
21360: LD_REAL  1.10000000000000E+0000
21363: MUL
21364: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21365: LD_ADDR_VAR 0 10
21369: PUSH
21370: LD_VAR 0 10
21374: PUSH
21375: LD_VAR 0 6
21379: PPUSH
21380: LD_INT 1
21382: PPUSH
21383: CALL_OW 259
21387: PUSH
21388: LD_REAL  1.15000000000000E+0000
21391: MUL
21392: MUL
21393: ST_TO_ADDR
// end ; unit_vehicle :
21394: GO 22224
21396: LD_INT 2
21398: DOUBLE
21399: EQUAL
21400: IFTRUE 21404
21402: GO 22212
21404: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 2
21417: PUSH
21418: LD_INT 42
21420: PUSH
21421: LD_INT 24
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: LIST
21428: IN
21429: IFFALSE 21450
// points := [ 25 , 5 , 3 ] ;
21431: LD_ADDR_VAR 0 9
21435: PUSH
21436: LD_INT 25
21438: PUSH
21439: LD_INT 5
21441: PUSH
21442: LD_INT 3
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: LIST
21449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21450: LD_VAR 0 6
21454: PPUSH
21455: CALL_OW 264
21459: PUSH
21460: LD_INT 4
21462: PUSH
21463: LD_INT 43
21465: PUSH
21466: LD_INT 25
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: LIST
21473: IN
21474: IFFALSE 21495
// points := [ 40 , 15 , 5 ] ;
21476: LD_ADDR_VAR 0 9
21480: PUSH
21481: LD_INT 40
21483: PUSH
21484: LD_INT 15
21486: PUSH
21487: LD_INT 5
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: LIST
21494: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21495: LD_VAR 0 6
21499: PPUSH
21500: CALL_OW 264
21504: PUSH
21505: LD_INT 3
21507: PUSH
21508: LD_INT 23
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: IN
21515: IFFALSE 21536
// points := [ 7 , 25 , 8 ] ;
21517: LD_ADDR_VAR 0 9
21521: PUSH
21522: LD_INT 7
21524: PUSH
21525: LD_INT 25
21527: PUSH
21528: LD_INT 8
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: LIST
21535: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21536: LD_VAR 0 6
21540: PPUSH
21541: CALL_OW 264
21545: PUSH
21546: LD_INT 5
21548: PUSH
21549: LD_INT 27
21551: PUSH
21552: LD_INT 44
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: LIST
21559: IN
21560: IFFALSE 21581
// points := [ 14 , 50 , 16 ] ;
21562: LD_ADDR_VAR 0 9
21566: PUSH
21567: LD_INT 14
21569: PUSH
21570: LD_INT 50
21572: PUSH
21573: LD_INT 16
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21581: LD_VAR 0 6
21585: PPUSH
21586: CALL_OW 264
21590: PUSH
21591: LD_INT 6
21593: PUSH
21594: LD_INT 46
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: IN
21601: IFFALSE 21622
// points := [ 32 , 120 , 70 ] ;
21603: LD_ADDR_VAR 0 9
21607: PUSH
21608: LD_INT 32
21610: PUSH
21611: LD_INT 120
21613: PUSH
21614: LD_INT 70
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21622: LD_VAR 0 6
21626: PPUSH
21627: CALL_OW 264
21631: PUSH
21632: LD_INT 7
21634: PUSH
21635: LD_INT 28
21637: PUSH
21638: LD_INT 45
21640: PUSH
21641: LD_EXP 108
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: IN
21652: IFFALSE 21673
// points := [ 35 , 20 , 45 ] ;
21654: LD_ADDR_VAR 0 9
21658: PUSH
21659: LD_INT 35
21661: PUSH
21662: LD_INT 20
21664: PUSH
21665: LD_INT 45
21667: PUSH
21668: EMPTY
21669: LIST
21670: LIST
21671: LIST
21672: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21673: LD_VAR 0 6
21677: PPUSH
21678: CALL_OW 264
21682: PUSH
21683: LD_INT 47
21685: PUSH
21686: EMPTY
21687: LIST
21688: IN
21689: IFFALSE 21710
// points := [ 67 , 45 , 75 ] ;
21691: LD_ADDR_VAR 0 9
21695: PUSH
21696: LD_INT 67
21698: PUSH
21699: LD_INT 45
21701: PUSH
21702: LD_INT 75
21704: PUSH
21705: EMPTY
21706: LIST
21707: LIST
21708: LIST
21709: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21710: LD_VAR 0 6
21714: PPUSH
21715: CALL_OW 264
21719: PUSH
21720: LD_INT 26
21722: PUSH
21723: EMPTY
21724: LIST
21725: IN
21726: IFFALSE 21747
// points := [ 120 , 30 , 80 ] ;
21728: LD_ADDR_VAR 0 9
21732: PUSH
21733: LD_INT 120
21735: PUSH
21736: LD_INT 30
21738: PUSH
21739: LD_INT 80
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: LIST
21746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21747: LD_VAR 0 6
21751: PPUSH
21752: CALL_OW 264
21756: PUSH
21757: LD_INT 22
21759: PUSH
21760: EMPTY
21761: LIST
21762: IN
21763: IFFALSE 21784
// points := [ 40 , 1 , 1 ] ;
21765: LD_ADDR_VAR 0 9
21769: PUSH
21770: LD_INT 40
21772: PUSH
21773: LD_INT 1
21775: PUSH
21776: LD_INT 1
21778: PUSH
21779: EMPTY
21780: LIST
21781: LIST
21782: LIST
21783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21784: LD_VAR 0 6
21788: PPUSH
21789: CALL_OW 264
21793: PUSH
21794: LD_INT 29
21796: PUSH
21797: EMPTY
21798: LIST
21799: IN
21800: IFFALSE 21821
// points := [ 70 , 200 , 400 ] ;
21802: LD_ADDR_VAR 0 9
21806: PUSH
21807: LD_INT 70
21809: PUSH
21810: LD_INT 200
21812: PUSH
21813: LD_INT 400
21815: PUSH
21816: EMPTY
21817: LIST
21818: LIST
21819: LIST
21820: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21821: LD_VAR 0 6
21825: PPUSH
21826: CALL_OW 264
21830: PUSH
21831: LD_INT 14
21833: PUSH
21834: LD_INT 53
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: IN
21841: IFFALSE 21862
// points := [ 40 , 10 , 20 ] ;
21843: LD_ADDR_VAR 0 9
21847: PUSH
21848: LD_INT 40
21850: PUSH
21851: LD_INT 10
21853: PUSH
21854: LD_INT 20
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21862: LD_VAR 0 6
21866: PPUSH
21867: CALL_OW 264
21871: PUSH
21872: LD_INT 9
21874: PUSH
21875: EMPTY
21876: LIST
21877: IN
21878: IFFALSE 21899
// points := [ 5 , 70 , 20 ] ;
21880: LD_ADDR_VAR 0 9
21884: PUSH
21885: LD_INT 5
21887: PUSH
21888: LD_INT 70
21890: PUSH
21891: LD_INT 20
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: LIST
21898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21899: LD_VAR 0 6
21903: PPUSH
21904: CALL_OW 264
21908: PUSH
21909: LD_INT 10
21911: PUSH
21912: EMPTY
21913: LIST
21914: IN
21915: IFFALSE 21936
// points := [ 35 , 110 , 70 ] ;
21917: LD_ADDR_VAR 0 9
21921: PUSH
21922: LD_INT 35
21924: PUSH
21925: LD_INT 110
21927: PUSH
21928: LD_INT 70
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: LIST
21935: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21936: LD_VAR 0 6
21940: PPUSH
21941: CALL_OW 265
21945: PUSH
21946: LD_INT 25
21948: EQUAL
21949: IFFALSE 21970
// points := [ 80 , 65 , 100 ] ;
21951: LD_ADDR_VAR 0 9
21955: PUSH
21956: LD_INT 80
21958: PUSH
21959: LD_INT 65
21961: PUSH
21962: LD_INT 100
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: LIST
21969: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21970: LD_VAR 0 6
21974: PPUSH
21975: CALL_OW 263
21979: PUSH
21980: LD_INT 1
21982: EQUAL
21983: IFFALSE 22018
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21985: LD_ADDR_VAR 0 10
21989: PUSH
21990: LD_VAR 0 10
21994: PUSH
21995: LD_VAR 0 6
21999: PPUSH
22000: CALL_OW 311
22004: PPUSH
22005: LD_INT 3
22007: PPUSH
22008: CALL_OW 259
22012: PUSH
22013: LD_INT 4
22015: MUL
22016: MUL
22017: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22018: LD_VAR 0 6
22022: PPUSH
22023: CALL_OW 263
22027: PUSH
22028: LD_INT 2
22030: EQUAL
22031: IFFALSE 22082
// begin j := IsControledBy ( i ) ;
22033: LD_ADDR_VAR 0 7
22037: PUSH
22038: LD_VAR 0 6
22042: PPUSH
22043: CALL_OW 312
22047: ST_TO_ADDR
// if j then
22048: LD_VAR 0 7
22052: IFFALSE 22082
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22054: LD_ADDR_VAR 0 10
22058: PUSH
22059: LD_VAR 0 10
22063: PUSH
22064: LD_VAR 0 7
22068: PPUSH
22069: LD_INT 3
22071: PPUSH
22072: CALL_OW 259
22076: PUSH
22077: LD_INT 3
22079: MUL
22080: MUL
22081: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 264
22091: PUSH
22092: LD_INT 5
22094: PUSH
22095: LD_INT 6
22097: PUSH
22098: LD_INT 46
22100: PUSH
22101: LD_INT 44
22103: PUSH
22104: LD_INT 47
22106: PUSH
22107: LD_INT 45
22109: PUSH
22110: LD_INT 28
22112: PUSH
22113: LD_INT 7
22115: PUSH
22116: LD_INT 27
22118: PUSH
22119: LD_INT 29
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: LIST
22126: LIST
22127: LIST
22128: LIST
22129: LIST
22130: LIST
22131: LIST
22132: LIST
22133: IN
22134: PUSH
22135: LD_VAR 0 1
22139: PPUSH
22140: LD_INT 52
22142: PPUSH
22143: CALL_OW 321
22147: PUSH
22148: LD_INT 2
22150: EQUAL
22151: AND
22152: IFFALSE 22169
// bpoints := bpoints * 1.2 ;
22154: LD_ADDR_VAR 0 10
22158: PUSH
22159: LD_VAR 0 10
22163: PUSH
22164: LD_REAL  1.20000000000000E+0000
22167: MUL
22168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22169: LD_VAR 0 6
22173: PPUSH
22174: CALL_OW 264
22178: PUSH
22179: LD_INT 6
22181: PUSH
22182: LD_INT 46
22184: PUSH
22185: LD_INT 47
22187: PUSH
22188: EMPTY
22189: LIST
22190: LIST
22191: LIST
22192: IN
22193: IFFALSE 22210
// bpoints := bpoints * 1.2 ;
22195: LD_ADDR_VAR 0 10
22199: PUSH
22200: LD_VAR 0 10
22204: PUSH
22205: LD_REAL  1.20000000000000E+0000
22208: MUL
22209: ST_TO_ADDR
// end ; unit_building :
22210: GO 22224
22212: LD_INT 3
22214: DOUBLE
22215: EQUAL
22216: IFTRUE 22220
22218: GO 22223
22220: POP
// ; end ;
22221: GO 22224
22223: POP
// for j = 1 to 3 do
22224: LD_ADDR_VAR 0 7
22228: PUSH
22229: DOUBLE
22230: LD_INT 1
22232: DEC
22233: ST_TO_ADDR
22234: LD_INT 3
22236: PUSH
22237: FOR_TO
22238: IFFALSE 22291
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22240: LD_ADDR_VAR 0 5
22244: PUSH
22245: LD_VAR 0 5
22249: PPUSH
22250: LD_VAR 0 7
22254: PPUSH
22255: LD_VAR 0 5
22259: PUSH
22260: LD_VAR 0 7
22264: ARRAY
22265: PUSH
22266: LD_VAR 0 9
22270: PUSH
22271: LD_VAR 0 7
22275: ARRAY
22276: PUSH
22277: LD_VAR 0 10
22281: MUL
22282: PLUS
22283: PPUSH
22284: CALL_OW 1
22288: ST_TO_ADDR
22289: GO 22237
22291: POP
22292: POP
// end ;
22293: GO 20770
22295: POP
22296: POP
// result := Replace ( result , 4 , tmp ) ;
22297: LD_ADDR_VAR 0 5
22301: PUSH
22302: LD_VAR 0 5
22306: PPUSH
22307: LD_INT 4
22309: PPUSH
22310: LD_VAR 0 8
22314: PPUSH
22315: CALL_OW 1
22319: ST_TO_ADDR
// end ;
22320: LD_VAR 0 5
22324: RET
// export function DangerAtRange ( unit , range ) ; begin
22325: LD_INT 0
22327: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22328: LD_ADDR_VAR 0 3
22332: PUSH
22333: LD_VAR 0 1
22337: PPUSH
22338: CALL_OW 255
22342: PPUSH
22343: LD_VAR 0 1
22347: PPUSH
22348: CALL_OW 250
22352: PPUSH
22353: LD_VAR 0 1
22357: PPUSH
22358: CALL_OW 251
22362: PPUSH
22363: LD_VAR 0 2
22367: PPUSH
22368: CALL 20622 0 4
22372: ST_TO_ADDR
// end ;
22373: LD_VAR 0 3
22377: RET
// export function DangerInArea ( side , area ) ; begin
22378: LD_INT 0
22380: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22381: LD_ADDR_VAR 0 3
22385: PUSH
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_INT 81
22393: PUSH
22394: LD_VAR 0 1
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PPUSH
22403: CALL_OW 70
22407: ST_TO_ADDR
// end ;
22408: LD_VAR 0 3
22412: RET
// export function IsExtension ( b ) ; begin
22413: LD_INT 0
22415: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22416: LD_ADDR_VAR 0 2
22420: PUSH
22421: LD_VAR 0 1
22425: PUSH
22426: LD_INT 23
22428: PUSH
22429: LD_INT 20
22431: PUSH
22432: LD_INT 22
22434: PUSH
22435: LD_INT 17
22437: PUSH
22438: LD_INT 24
22440: PUSH
22441: LD_INT 21
22443: PUSH
22444: LD_INT 19
22446: PUSH
22447: LD_INT 16
22449: PUSH
22450: LD_INT 25
22452: PUSH
22453: LD_INT 18
22455: PUSH
22456: EMPTY
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: IN
22468: ST_TO_ADDR
// end ;
22469: LD_VAR 0 2
22473: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22474: LD_INT 0
22476: PPUSH
22477: PPUSH
22478: PPUSH
// result := [ ] ;
22479: LD_ADDR_VAR 0 4
22483: PUSH
22484: EMPTY
22485: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PPUSH
22496: LD_INT 21
22498: PUSH
22499: LD_INT 3
22501: PUSH
22502: EMPTY
22503: LIST
22504: LIST
22505: PPUSH
22506: CALL_OW 70
22510: ST_TO_ADDR
// if not tmp then
22511: LD_VAR 0 5
22515: NOT
22516: IFFALSE 22520
// exit ;
22518: GO 22584
// if checkLink then
22520: LD_VAR 0 3
22524: IFFALSE 22574
// begin for i in tmp do
22526: LD_ADDR_VAR 0 6
22530: PUSH
22531: LD_VAR 0 5
22535: PUSH
22536: FOR_IN
22537: IFFALSE 22572
// if GetBase ( i ) <> base then
22539: LD_VAR 0 6
22543: PPUSH
22544: CALL_OW 274
22548: PUSH
22549: LD_VAR 0 1
22553: NONEQUAL
22554: IFFALSE 22570
// ComLinkToBase ( base , i ) ;
22556: LD_VAR 0 1
22560: PPUSH
22561: LD_VAR 0 6
22565: PPUSH
22566: CALL_OW 169
22570: GO 22536
22572: POP
22573: POP
// end ; result := tmp ;
22574: LD_ADDR_VAR 0 4
22578: PUSH
22579: LD_VAR 0 5
22583: ST_TO_ADDR
// end ;
22584: LD_VAR 0 4
22588: RET
// export function ComComplete ( units , b ) ; var i ; begin
22589: LD_INT 0
22591: PPUSH
22592: PPUSH
// if not units then
22593: LD_VAR 0 1
22597: NOT
22598: IFFALSE 22602
// exit ;
22600: GO 22692
// for i in units do
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 1
22611: PUSH
22612: FOR_IN
22613: IFFALSE 22690
// if BuildingStatus ( b ) = bs_build then
22615: LD_VAR 0 2
22619: PPUSH
22620: CALL_OW 461
22624: PUSH
22625: LD_INT 1
22627: EQUAL
22628: IFFALSE 22688
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22630: LD_VAR 0 4
22634: PPUSH
22635: LD_STRING h
22637: PUSH
22638: LD_VAR 0 2
22642: PPUSH
22643: CALL_OW 250
22647: PUSH
22648: LD_VAR 0 2
22652: PPUSH
22653: CALL_OW 251
22657: PUSH
22658: LD_VAR 0 2
22662: PUSH
22663: LD_INT 0
22665: PUSH
22666: LD_INT 0
22668: PUSH
22669: LD_INT 0
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: PPUSH
22684: CALL_OW 446
22688: GO 22612
22690: POP
22691: POP
// end ;
22692: LD_VAR 0 3
22696: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22697: LD_INT 0
22699: PPUSH
22700: PPUSH
22701: PPUSH
22702: PPUSH
22703: PPUSH
22704: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22705: LD_VAR 0 1
22709: NOT
22710: PUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: CALL_OW 263
22720: PUSH
22721: LD_INT 2
22723: EQUAL
22724: NOT
22725: OR
22726: IFFALSE 22730
// exit ;
22728: GO 23046
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22730: LD_ADDR_VAR 0 6
22734: PUSH
22735: LD_INT 22
22737: PUSH
22738: LD_VAR 0 1
22742: PPUSH
22743: CALL_OW 255
22747: PUSH
22748: EMPTY
22749: LIST
22750: LIST
22751: PUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 30
22757: PUSH
22758: LD_INT 36
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 34
22767: PUSH
22768: LD_INT 31
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: PPUSH
22784: CALL_OW 69
22788: ST_TO_ADDR
// if not tmp then
22789: LD_VAR 0 6
22793: NOT
22794: IFFALSE 22798
// exit ;
22796: GO 23046
// result := [ ] ;
22798: LD_ADDR_VAR 0 2
22802: PUSH
22803: EMPTY
22804: ST_TO_ADDR
// for i in tmp do
22805: LD_ADDR_VAR 0 3
22809: PUSH
22810: LD_VAR 0 6
22814: PUSH
22815: FOR_IN
22816: IFFALSE 22887
// begin t := UnitsInside ( i ) ;
22818: LD_ADDR_VAR 0 4
22822: PUSH
22823: LD_VAR 0 3
22827: PPUSH
22828: CALL_OW 313
22832: ST_TO_ADDR
// if t then
22833: LD_VAR 0 4
22837: IFFALSE 22885
// for j in t do
22839: LD_ADDR_VAR 0 7
22843: PUSH
22844: LD_VAR 0 4
22848: PUSH
22849: FOR_IN
22850: IFFALSE 22883
// result := Insert ( result , result + 1 , j ) ;
22852: LD_ADDR_VAR 0 2
22856: PUSH
22857: LD_VAR 0 2
22861: PPUSH
22862: LD_VAR 0 2
22866: PUSH
22867: LD_INT 1
22869: PLUS
22870: PPUSH
22871: LD_VAR 0 7
22875: PPUSH
22876: CALL_OW 2
22880: ST_TO_ADDR
22881: GO 22849
22883: POP
22884: POP
// end ;
22885: GO 22815
22887: POP
22888: POP
// if not result then
22889: LD_VAR 0 2
22893: NOT
22894: IFFALSE 22898
// exit ;
22896: GO 23046
// mech := result [ 1 ] ;
22898: LD_ADDR_VAR 0 5
22902: PUSH
22903: LD_VAR 0 2
22907: PUSH
22908: LD_INT 1
22910: ARRAY
22911: ST_TO_ADDR
// if result > 1 then
22912: LD_VAR 0 2
22916: PUSH
22917: LD_INT 1
22919: GREATER
22920: IFFALSE 23032
// for i = 2 to result do
22922: LD_ADDR_VAR 0 3
22926: PUSH
22927: DOUBLE
22928: LD_INT 2
22930: DEC
22931: ST_TO_ADDR
22932: LD_VAR 0 2
22936: PUSH
22937: FOR_TO
22938: IFFALSE 23030
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22940: LD_ADDR_VAR 0 4
22944: PUSH
22945: LD_VAR 0 2
22949: PUSH
22950: LD_VAR 0 3
22954: ARRAY
22955: PPUSH
22956: LD_INT 3
22958: PPUSH
22959: CALL_OW 259
22963: PUSH
22964: LD_VAR 0 2
22968: PUSH
22969: LD_VAR 0 3
22973: ARRAY
22974: PPUSH
22975: CALL_OW 432
22979: MINUS
22980: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22981: LD_VAR 0 4
22985: PUSH
22986: LD_VAR 0 5
22990: PPUSH
22991: LD_INT 3
22993: PPUSH
22994: CALL_OW 259
22998: PUSH
22999: LD_VAR 0 5
23003: PPUSH
23004: CALL_OW 432
23008: MINUS
23009: GREATEREQUAL
23010: IFFALSE 23028
// mech := result [ i ] ;
23012: LD_ADDR_VAR 0 5
23016: PUSH
23017: LD_VAR 0 2
23021: PUSH
23022: LD_VAR 0 3
23026: ARRAY
23027: ST_TO_ADDR
// end ;
23028: GO 22937
23030: POP
23031: POP
// ComLinkTo ( vehicle , mech ) ;
23032: LD_VAR 0 1
23036: PPUSH
23037: LD_VAR 0 5
23041: PPUSH
23042: CALL_OW 135
// end ;
23046: LD_VAR 0 2
23050: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23051: LD_INT 0
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
23065: PPUSH
// result := [ ] ;
23066: LD_ADDR_VAR 0 7
23070: PUSH
23071: EMPTY
23072: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23073: LD_VAR 0 1
23077: PPUSH
23078: CALL_OW 266
23082: PUSH
23083: LD_INT 0
23085: PUSH
23086: LD_INT 1
23088: PUSH
23089: EMPTY
23090: LIST
23091: LIST
23092: IN
23093: NOT
23094: IFFALSE 23098
// exit ;
23096: GO 24732
// if name then
23098: LD_VAR 0 3
23102: IFFALSE 23118
// SetBName ( base_dep , name ) ;
23104: LD_VAR 0 1
23108: PPUSH
23109: LD_VAR 0 3
23113: PPUSH
23114: CALL_OW 500
// base := GetBase ( base_dep ) ;
23118: LD_ADDR_VAR 0 15
23122: PUSH
23123: LD_VAR 0 1
23127: PPUSH
23128: CALL_OW 274
23132: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23133: LD_ADDR_VAR 0 16
23137: PUSH
23138: LD_VAR 0 1
23142: PPUSH
23143: CALL_OW 255
23147: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23148: LD_ADDR_VAR 0 17
23152: PUSH
23153: LD_VAR 0 1
23157: PPUSH
23158: CALL_OW 248
23162: ST_TO_ADDR
// if sources then
23163: LD_VAR 0 5
23167: IFFALSE 23214
// for i = 1 to 3 do
23169: LD_ADDR_VAR 0 8
23173: PUSH
23174: DOUBLE
23175: LD_INT 1
23177: DEC
23178: ST_TO_ADDR
23179: LD_INT 3
23181: PUSH
23182: FOR_TO
23183: IFFALSE 23212
// AddResourceType ( base , i , sources [ i ] ) ;
23185: LD_VAR 0 15
23189: PPUSH
23190: LD_VAR 0 8
23194: PPUSH
23195: LD_VAR 0 5
23199: PUSH
23200: LD_VAR 0 8
23204: ARRAY
23205: PPUSH
23206: CALL_OW 276
23210: GO 23182
23212: POP
23213: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23214: LD_ADDR_VAR 0 18
23218: PUSH
23219: LD_VAR 0 15
23223: PPUSH
23224: LD_VAR 0 2
23228: PPUSH
23229: LD_INT 1
23231: PPUSH
23232: CALL 22474 0 3
23236: ST_TO_ADDR
// InitHc ;
23237: CALL_OW 19
// InitUc ;
23241: CALL_OW 18
// uc_side := side ;
23245: LD_ADDR_OWVAR 20
23249: PUSH
23250: LD_VAR 0 16
23254: ST_TO_ADDR
// uc_nation := nation ;
23255: LD_ADDR_OWVAR 21
23259: PUSH
23260: LD_VAR 0 17
23264: ST_TO_ADDR
// if buildings then
23265: LD_VAR 0 18
23269: IFFALSE 24591
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23271: LD_ADDR_VAR 0 19
23275: PUSH
23276: LD_VAR 0 18
23280: PPUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 30
23286: PUSH
23287: LD_INT 29
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 30
23296: PUSH
23297: LD_INT 30
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: LIST
23308: PPUSH
23309: CALL_OW 72
23313: ST_TO_ADDR
// if tmp then
23314: LD_VAR 0 19
23318: IFFALSE 23366
// for i in tmp do
23320: LD_ADDR_VAR 0 8
23324: PUSH
23325: LD_VAR 0 19
23329: PUSH
23330: FOR_IN
23331: IFFALSE 23364
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23333: LD_VAR 0 8
23337: PPUSH
23338: CALL_OW 250
23342: PPUSH
23343: LD_VAR 0 8
23347: PPUSH
23348: CALL_OW 251
23352: PPUSH
23353: LD_VAR 0 16
23357: PPUSH
23358: CALL_OW 441
23362: GO 23330
23364: POP
23365: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23366: LD_VAR 0 18
23370: PPUSH
23371: LD_INT 2
23373: PUSH
23374: LD_INT 30
23376: PUSH
23377: LD_INT 32
23379: PUSH
23380: EMPTY
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 30
23386: PUSH
23387: LD_INT 33
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: LIST
23398: PPUSH
23399: CALL_OW 72
23403: IFFALSE 23491
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23405: LD_ADDR_VAR 0 8
23409: PUSH
23410: LD_VAR 0 18
23414: PPUSH
23415: LD_INT 2
23417: PUSH
23418: LD_INT 30
23420: PUSH
23421: LD_INT 32
23423: PUSH
23424: EMPTY
23425: LIST
23426: LIST
23427: PUSH
23428: LD_INT 30
23430: PUSH
23431: LD_INT 33
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: PUSH
23438: EMPTY
23439: LIST
23440: LIST
23441: LIST
23442: PPUSH
23443: CALL_OW 72
23447: PUSH
23448: FOR_IN
23449: IFFALSE 23489
// begin if not GetBWeapon ( i ) then
23451: LD_VAR 0 8
23455: PPUSH
23456: CALL_OW 269
23460: NOT
23461: IFFALSE 23487
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23463: LD_VAR 0 8
23467: PPUSH
23468: LD_VAR 0 8
23472: PPUSH
23473: LD_VAR 0 2
23477: PPUSH
23478: CALL 24737 0 2
23482: PPUSH
23483: CALL_OW 431
// end ;
23487: GO 23448
23489: POP
23490: POP
// end ; for i = 1 to personel do
23491: LD_ADDR_VAR 0 8
23495: PUSH
23496: DOUBLE
23497: LD_INT 1
23499: DEC
23500: ST_TO_ADDR
23501: LD_VAR 0 6
23505: PUSH
23506: FOR_TO
23507: IFFALSE 24571
// begin if i > 4 then
23509: LD_VAR 0 8
23513: PUSH
23514: LD_INT 4
23516: GREATER
23517: IFFALSE 23521
// break ;
23519: GO 24571
// case i of 1 :
23521: LD_VAR 0 8
23525: PUSH
23526: LD_INT 1
23528: DOUBLE
23529: EQUAL
23530: IFTRUE 23534
23532: GO 23614
23534: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23535: LD_ADDR_VAR 0 12
23539: PUSH
23540: LD_VAR 0 18
23544: PPUSH
23545: LD_INT 22
23547: PUSH
23548: LD_VAR 0 16
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: LD_INT 58
23559: PUSH
23560: EMPTY
23561: LIST
23562: PUSH
23563: LD_INT 2
23565: PUSH
23566: LD_INT 30
23568: PUSH
23569: LD_INT 32
23571: PUSH
23572: EMPTY
23573: LIST
23574: LIST
23575: PUSH
23576: LD_INT 30
23578: PUSH
23579: LD_INT 4
23581: PUSH
23582: EMPTY
23583: LIST
23584: LIST
23585: PUSH
23586: LD_INT 30
23588: PUSH
23589: LD_INT 5
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PUSH
23596: EMPTY
23597: LIST
23598: LIST
23599: LIST
23600: LIST
23601: PUSH
23602: EMPTY
23603: LIST
23604: LIST
23605: LIST
23606: PPUSH
23607: CALL_OW 72
23611: ST_TO_ADDR
23612: GO 23836
23614: LD_INT 2
23616: DOUBLE
23617: EQUAL
23618: IFTRUE 23622
23620: GO 23684
23622: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23623: LD_ADDR_VAR 0 12
23627: PUSH
23628: LD_VAR 0 18
23632: PPUSH
23633: LD_INT 22
23635: PUSH
23636: LD_VAR 0 16
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: LD_INT 2
23647: PUSH
23648: LD_INT 30
23650: PUSH
23651: LD_INT 0
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PUSH
23658: LD_INT 30
23660: PUSH
23661: LD_INT 1
23663: PUSH
23664: EMPTY
23665: LIST
23666: LIST
23667: PUSH
23668: EMPTY
23669: LIST
23670: LIST
23671: LIST
23672: PUSH
23673: EMPTY
23674: LIST
23675: LIST
23676: PPUSH
23677: CALL_OW 72
23681: ST_TO_ADDR
23682: GO 23836
23684: LD_INT 3
23686: DOUBLE
23687: EQUAL
23688: IFTRUE 23692
23690: GO 23754
23692: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23693: LD_ADDR_VAR 0 12
23697: PUSH
23698: LD_VAR 0 18
23702: PPUSH
23703: LD_INT 22
23705: PUSH
23706: LD_VAR 0 16
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: PUSH
23715: LD_INT 2
23717: PUSH
23718: LD_INT 30
23720: PUSH
23721: LD_INT 2
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: PUSH
23728: LD_INT 30
23730: PUSH
23731: LD_INT 3
23733: PUSH
23734: EMPTY
23735: LIST
23736: LIST
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: LIST
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: PPUSH
23747: CALL_OW 72
23751: ST_TO_ADDR
23752: GO 23836
23754: LD_INT 4
23756: DOUBLE
23757: EQUAL
23758: IFTRUE 23762
23760: GO 23835
23762: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23763: LD_ADDR_VAR 0 12
23767: PUSH
23768: LD_VAR 0 18
23772: PPUSH
23773: LD_INT 22
23775: PUSH
23776: LD_VAR 0 16
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PUSH
23785: LD_INT 2
23787: PUSH
23788: LD_INT 30
23790: PUSH
23791: LD_INT 6
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 30
23800: PUSH
23801: LD_INT 7
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: PUSH
23808: LD_INT 30
23810: PUSH
23811: LD_INT 8
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 72
23832: ST_TO_ADDR
23833: GO 23836
23835: POP
// if i = 1 then
23836: LD_VAR 0 8
23840: PUSH
23841: LD_INT 1
23843: EQUAL
23844: IFFALSE 23955
// begin tmp := [ ] ;
23846: LD_ADDR_VAR 0 19
23850: PUSH
23851: EMPTY
23852: ST_TO_ADDR
// for j in f do
23853: LD_ADDR_VAR 0 9
23857: PUSH
23858: LD_VAR 0 12
23862: PUSH
23863: FOR_IN
23864: IFFALSE 23937
// if GetBType ( j ) = b_bunker then
23866: LD_VAR 0 9
23870: PPUSH
23871: CALL_OW 266
23875: PUSH
23876: LD_INT 32
23878: EQUAL
23879: IFFALSE 23906
// tmp := Insert ( tmp , 1 , j ) else
23881: LD_ADDR_VAR 0 19
23885: PUSH
23886: LD_VAR 0 19
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: LD_VAR 0 9
23898: PPUSH
23899: CALL_OW 2
23903: ST_TO_ADDR
23904: GO 23935
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23906: LD_ADDR_VAR 0 19
23910: PUSH
23911: LD_VAR 0 19
23915: PPUSH
23916: LD_VAR 0 19
23920: PUSH
23921: LD_INT 1
23923: PLUS
23924: PPUSH
23925: LD_VAR 0 9
23929: PPUSH
23930: CALL_OW 2
23934: ST_TO_ADDR
23935: GO 23863
23937: POP
23938: POP
// if tmp then
23939: LD_VAR 0 19
23943: IFFALSE 23955
// f := tmp ;
23945: LD_ADDR_VAR 0 12
23949: PUSH
23950: LD_VAR 0 19
23954: ST_TO_ADDR
// end ; x := personel [ i ] ;
23955: LD_ADDR_VAR 0 13
23959: PUSH
23960: LD_VAR 0 6
23964: PUSH
23965: LD_VAR 0 8
23969: ARRAY
23970: ST_TO_ADDR
// if x = - 1 then
23971: LD_VAR 0 13
23975: PUSH
23976: LD_INT 1
23978: NEG
23979: EQUAL
23980: IFFALSE 24189
// begin for j in f do
23982: LD_ADDR_VAR 0 9
23986: PUSH
23987: LD_VAR 0 12
23991: PUSH
23992: FOR_IN
23993: IFFALSE 24185
// repeat InitHc ;
23995: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23999: LD_VAR 0 9
24003: PPUSH
24004: CALL_OW 266
24008: PUSH
24009: LD_INT 5
24011: EQUAL
24012: IFFALSE 24082
// begin if UnitsInside ( j ) < 3 then
24014: LD_VAR 0 9
24018: PPUSH
24019: CALL_OW 313
24023: PUSH
24024: LD_INT 3
24026: LESS
24027: IFFALSE 24063
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24029: LD_INT 0
24031: PPUSH
24032: LD_INT 5
24034: PUSH
24035: LD_INT 8
24037: PUSH
24038: LD_INT 9
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: LIST
24045: PUSH
24046: LD_VAR 0 17
24050: ARRAY
24051: PPUSH
24052: LD_VAR 0 4
24056: PPUSH
24057: CALL_OW 380
24061: GO 24080
// PrepareHuman ( false , i , skill ) ;
24063: LD_INT 0
24065: PPUSH
24066: LD_VAR 0 8
24070: PPUSH
24071: LD_VAR 0 4
24075: PPUSH
24076: CALL_OW 380
// end else
24080: GO 24099
// PrepareHuman ( false , i , skill ) ;
24082: LD_INT 0
24084: PPUSH
24085: LD_VAR 0 8
24089: PPUSH
24090: LD_VAR 0 4
24094: PPUSH
24095: CALL_OW 380
// un := CreateHuman ;
24099: LD_ADDR_VAR 0 14
24103: PUSH
24104: CALL_OW 44
24108: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 7
24118: PPUSH
24119: LD_INT 1
24121: PPUSH
24122: LD_VAR 0 14
24126: PPUSH
24127: CALL_OW 2
24131: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24132: LD_VAR 0 14
24136: PPUSH
24137: LD_VAR 0 9
24141: PPUSH
24142: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24146: LD_VAR 0 9
24150: PPUSH
24151: CALL_OW 313
24155: PUSH
24156: LD_INT 6
24158: EQUAL
24159: PUSH
24160: LD_VAR 0 9
24164: PPUSH
24165: CALL_OW 266
24169: PUSH
24170: LD_INT 32
24172: PUSH
24173: LD_INT 31
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: IN
24180: OR
24181: IFFALSE 23995
24183: GO 23992
24185: POP
24186: POP
// end else
24187: GO 24569
// for j = 1 to x do
24189: LD_ADDR_VAR 0 9
24193: PUSH
24194: DOUBLE
24195: LD_INT 1
24197: DEC
24198: ST_TO_ADDR
24199: LD_VAR 0 13
24203: PUSH
24204: FOR_TO
24205: IFFALSE 24567
// begin InitHc ;
24207: CALL_OW 19
// if not f then
24211: LD_VAR 0 12
24215: NOT
24216: IFFALSE 24305
// begin PrepareHuman ( false , i , skill ) ;
24218: LD_INT 0
24220: PPUSH
24221: LD_VAR 0 8
24225: PPUSH
24226: LD_VAR 0 4
24230: PPUSH
24231: CALL_OW 380
// un := CreateHuman ;
24235: LD_ADDR_VAR 0 14
24239: PUSH
24240: CALL_OW 44
24244: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24245: LD_ADDR_VAR 0 7
24249: PUSH
24250: LD_VAR 0 7
24254: PPUSH
24255: LD_INT 1
24257: PPUSH
24258: LD_VAR 0 14
24262: PPUSH
24263: CALL_OW 2
24267: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24268: LD_VAR 0 14
24272: PPUSH
24273: LD_VAR 0 1
24277: PPUSH
24278: CALL_OW 250
24282: PPUSH
24283: LD_VAR 0 1
24287: PPUSH
24288: CALL_OW 251
24292: PPUSH
24293: LD_INT 10
24295: PPUSH
24296: LD_INT 0
24298: PPUSH
24299: CALL_OW 50
// continue ;
24303: GO 24204
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24305: LD_VAR 0 12
24309: PUSH
24310: LD_INT 1
24312: ARRAY
24313: PPUSH
24314: CALL_OW 313
24318: PUSH
24319: LD_VAR 0 12
24323: PUSH
24324: LD_INT 1
24326: ARRAY
24327: PPUSH
24328: CALL_OW 266
24332: PUSH
24333: LD_INT 32
24335: PUSH
24336: LD_INT 31
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: IN
24343: AND
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 313
24358: PUSH
24359: LD_INT 6
24361: EQUAL
24362: OR
24363: IFFALSE 24383
// f := Delete ( f , 1 ) ;
24365: LD_ADDR_VAR 0 12
24369: PUSH
24370: LD_VAR 0 12
24374: PPUSH
24375: LD_INT 1
24377: PPUSH
24378: CALL_OW 3
24382: ST_TO_ADDR
// if not f then
24383: LD_VAR 0 12
24387: NOT
24388: IFFALSE 24406
// begin x := x + 2 ;
24390: LD_ADDR_VAR 0 13
24394: PUSH
24395: LD_VAR 0 13
24399: PUSH
24400: LD_INT 2
24402: PLUS
24403: ST_TO_ADDR
// continue ;
24404: GO 24204
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24406: LD_VAR 0 12
24410: PUSH
24411: LD_INT 1
24413: ARRAY
24414: PPUSH
24415: CALL_OW 266
24419: PUSH
24420: LD_INT 5
24422: EQUAL
24423: IFFALSE 24497
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24425: LD_VAR 0 12
24429: PUSH
24430: LD_INT 1
24432: ARRAY
24433: PPUSH
24434: CALL_OW 313
24438: PUSH
24439: LD_INT 3
24441: LESS
24442: IFFALSE 24478
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24444: LD_INT 0
24446: PPUSH
24447: LD_INT 5
24449: PUSH
24450: LD_INT 8
24452: PUSH
24453: LD_INT 9
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: LIST
24460: PUSH
24461: LD_VAR 0 17
24465: ARRAY
24466: PPUSH
24467: LD_VAR 0 4
24471: PPUSH
24472: CALL_OW 380
24476: GO 24495
// PrepareHuman ( false , i , skill ) ;
24478: LD_INT 0
24480: PPUSH
24481: LD_VAR 0 8
24485: PPUSH
24486: LD_VAR 0 4
24490: PPUSH
24491: CALL_OW 380
// end else
24495: GO 24514
// PrepareHuman ( false , i , skill ) ;
24497: LD_INT 0
24499: PPUSH
24500: LD_VAR 0 8
24504: PPUSH
24505: LD_VAR 0 4
24509: PPUSH
24510: CALL_OW 380
// un := CreateHuman ;
24514: LD_ADDR_VAR 0 14
24518: PUSH
24519: CALL_OW 44
24523: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24524: LD_ADDR_VAR 0 7
24528: PUSH
24529: LD_VAR 0 7
24533: PPUSH
24534: LD_INT 1
24536: PPUSH
24537: LD_VAR 0 14
24541: PPUSH
24542: CALL_OW 2
24546: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24547: LD_VAR 0 14
24551: PPUSH
24552: LD_VAR 0 12
24556: PUSH
24557: LD_INT 1
24559: ARRAY
24560: PPUSH
24561: CALL_OW 52
// end ;
24565: GO 24204
24567: POP
24568: POP
// end ;
24569: GO 23506
24571: POP
24572: POP
// result := result ^ buildings ;
24573: LD_ADDR_VAR 0 7
24577: PUSH
24578: LD_VAR 0 7
24582: PUSH
24583: LD_VAR 0 18
24587: ADD
24588: ST_TO_ADDR
// end else
24589: GO 24732
// begin for i = 1 to personel do
24591: LD_ADDR_VAR 0 8
24595: PUSH
24596: DOUBLE
24597: LD_INT 1
24599: DEC
24600: ST_TO_ADDR
24601: LD_VAR 0 6
24605: PUSH
24606: FOR_TO
24607: IFFALSE 24730
// begin if i > 4 then
24609: LD_VAR 0 8
24613: PUSH
24614: LD_INT 4
24616: GREATER
24617: IFFALSE 24621
// break ;
24619: GO 24730
// x := personel [ i ] ;
24621: LD_ADDR_VAR 0 13
24625: PUSH
24626: LD_VAR 0 6
24630: PUSH
24631: LD_VAR 0 8
24635: ARRAY
24636: ST_TO_ADDR
// if x = - 1 then
24637: LD_VAR 0 13
24641: PUSH
24642: LD_INT 1
24644: NEG
24645: EQUAL
24646: IFFALSE 24650
// continue ;
24648: GO 24606
// PrepareHuman ( false , i , skill ) ;
24650: LD_INT 0
24652: PPUSH
24653: LD_VAR 0 8
24657: PPUSH
24658: LD_VAR 0 4
24662: PPUSH
24663: CALL_OW 380
// un := CreateHuman ;
24667: LD_ADDR_VAR 0 14
24671: PUSH
24672: CALL_OW 44
24676: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24677: LD_VAR 0 14
24681: PPUSH
24682: LD_VAR 0 1
24686: PPUSH
24687: CALL_OW 250
24691: PPUSH
24692: LD_VAR 0 1
24696: PPUSH
24697: CALL_OW 251
24701: PPUSH
24702: LD_INT 10
24704: PPUSH
24705: LD_INT 0
24707: PPUSH
24708: CALL_OW 50
// result := result ^ un ;
24712: LD_ADDR_VAR 0 7
24716: PUSH
24717: LD_VAR 0 7
24721: PUSH
24722: LD_VAR 0 14
24726: ADD
24727: ST_TO_ADDR
// end ;
24728: GO 24606
24730: POP
24731: POP
// end ; end ;
24732: LD_VAR 0 7
24736: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24737: LD_INT 0
24739: PPUSH
24740: PPUSH
24741: PPUSH
24742: PPUSH
24743: PPUSH
24744: PPUSH
24745: PPUSH
24746: PPUSH
24747: PPUSH
24748: PPUSH
24749: PPUSH
24750: PPUSH
24751: PPUSH
24752: PPUSH
24753: PPUSH
24754: PPUSH
// result := false ;
24755: LD_ADDR_VAR 0 3
24759: PUSH
24760: LD_INT 0
24762: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24763: LD_VAR 0 1
24767: NOT
24768: PUSH
24769: LD_VAR 0 1
24773: PPUSH
24774: CALL_OW 266
24778: PUSH
24779: LD_INT 32
24781: PUSH
24782: LD_INT 33
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: IN
24789: NOT
24790: OR
24791: IFFALSE 24795
// exit ;
24793: GO 25904
// nat := GetNation ( tower ) ;
24795: LD_ADDR_VAR 0 12
24799: PUSH
24800: LD_VAR 0 1
24804: PPUSH
24805: CALL_OW 248
24809: ST_TO_ADDR
// side := GetSide ( tower ) ;
24810: LD_ADDR_VAR 0 16
24814: PUSH
24815: LD_VAR 0 1
24819: PPUSH
24820: CALL_OW 255
24824: ST_TO_ADDR
// x := GetX ( tower ) ;
24825: LD_ADDR_VAR 0 10
24829: PUSH
24830: LD_VAR 0 1
24834: PPUSH
24835: CALL_OW 250
24839: ST_TO_ADDR
// y := GetY ( tower ) ;
24840: LD_ADDR_VAR 0 11
24844: PUSH
24845: LD_VAR 0 1
24849: PPUSH
24850: CALL_OW 251
24854: ST_TO_ADDR
// if not x or not y then
24855: LD_VAR 0 10
24859: NOT
24860: PUSH
24861: LD_VAR 0 11
24865: NOT
24866: OR
24867: IFFALSE 24871
// exit ;
24869: GO 25904
// weapon := 0 ;
24871: LD_ADDR_VAR 0 18
24875: PUSH
24876: LD_INT 0
24878: ST_TO_ADDR
// fac_list := [ ] ;
24879: LD_ADDR_VAR 0 17
24883: PUSH
24884: EMPTY
24885: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24886: LD_ADDR_VAR 0 6
24890: PUSH
24891: LD_VAR 0 1
24895: PPUSH
24896: CALL_OW 274
24900: PPUSH
24901: LD_VAR 0 2
24905: PPUSH
24906: LD_INT 0
24908: PPUSH
24909: CALL 22474 0 3
24913: PPUSH
24914: LD_INT 30
24916: PUSH
24917: LD_INT 3
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: PPUSH
24924: CALL_OW 72
24928: ST_TO_ADDR
// if not factories then
24929: LD_VAR 0 6
24933: NOT
24934: IFFALSE 24938
// exit ;
24936: GO 25904
// for i in factories do
24938: LD_ADDR_VAR 0 8
24942: PUSH
24943: LD_VAR 0 6
24947: PUSH
24948: FOR_IN
24949: IFFALSE 24974
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24951: LD_ADDR_VAR 0 17
24955: PUSH
24956: LD_VAR 0 17
24960: PUSH
24961: LD_VAR 0 8
24965: PPUSH
24966: CALL_OW 478
24970: UNION
24971: ST_TO_ADDR
24972: GO 24948
24974: POP
24975: POP
// if not fac_list then
24976: LD_VAR 0 17
24980: NOT
24981: IFFALSE 24985
// exit ;
24983: GO 25904
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24985: LD_ADDR_VAR 0 5
24989: PUSH
24990: LD_INT 4
24992: PUSH
24993: LD_INT 5
24995: PUSH
24996: LD_INT 9
24998: PUSH
24999: LD_INT 10
25001: PUSH
25002: LD_INT 6
25004: PUSH
25005: LD_INT 7
25007: PUSH
25008: LD_INT 11
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: LIST
25019: PUSH
25020: LD_INT 27
25022: PUSH
25023: LD_INT 28
25025: PUSH
25026: LD_INT 26
25028: PUSH
25029: LD_INT 30
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 43
25040: PUSH
25041: LD_INT 44
25043: PUSH
25044: LD_INT 46
25046: PUSH
25047: LD_INT 45
25049: PUSH
25050: LD_INT 47
25052: PUSH
25053: LD_INT 49
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: LIST
25068: PUSH
25069: LD_VAR 0 12
25073: ARRAY
25074: ST_TO_ADDR
// list := list isect fac_list ;
25075: LD_ADDR_VAR 0 5
25079: PUSH
25080: LD_VAR 0 5
25084: PUSH
25085: LD_VAR 0 17
25089: ISECT
25090: ST_TO_ADDR
// if not list then
25091: LD_VAR 0 5
25095: NOT
25096: IFFALSE 25100
// exit ;
25098: GO 25904
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25100: LD_VAR 0 12
25104: PUSH
25105: LD_INT 3
25107: EQUAL
25108: PUSH
25109: LD_INT 49
25111: PUSH
25112: LD_VAR 0 5
25116: IN
25117: AND
25118: PUSH
25119: LD_INT 31
25121: PPUSH
25122: LD_VAR 0 16
25126: PPUSH
25127: CALL_OW 321
25131: PUSH
25132: LD_INT 2
25134: EQUAL
25135: AND
25136: IFFALSE 25196
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25138: LD_INT 22
25140: PUSH
25141: LD_VAR 0 16
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: LD_INT 35
25152: PUSH
25153: LD_INT 49
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: PUSH
25160: LD_INT 91
25162: PUSH
25163: LD_VAR 0 1
25167: PUSH
25168: LD_INT 10
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: LIST
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PPUSH
25181: CALL_OW 69
25185: NOT
25186: IFFALSE 25196
// weapon := ru_time_lapser ;
25188: LD_ADDR_VAR 0 18
25192: PUSH
25193: LD_INT 49
25195: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25196: LD_VAR 0 12
25200: PUSH
25201: LD_INT 1
25203: PUSH
25204: LD_INT 2
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: IN
25211: PUSH
25212: LD_INT 11
25214: PUSH
25215: LD_VAR 0 5
25219: IN
25220: PUSH
25221: LD_INT 30
25223: PUSH
25224: LD_VAR 0 5
25228: IN
25229: OR
25230: AND
25231: PUSH
25232: LD_INT 6
25234: PPUSH
25235: LD_VAR 0 16
25239: PPUSH
25240: CALL_OW 321
25244: PUSH
25245: LD_INT 2
25247: EQUAL
25248: AND
25249: IFFALSE 25414
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25251: LD_INT 22
25253: PUSH
25254: LD_VAR 0 16
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 2
25265: PUSH
25266: LD_INT 35
25268: PUSH
25269: LD_INT 11
25271: PUSH
25272: EMPTY
25273: LIST
25274: LIST
25275: PUSH
25276: LD_INT 35
25278: PUSH
25279: LD_INT 30
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: LIST
25290: PUSH
25291: LD_INT 91
25293: PUSH
25294: LD_VAR 0 1
25298: PUSH
25299: LD_INT 18
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: LIST
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: LIST
25311: PPUSH
25312: CALL_OW 69
25316: NOT
25317: PUSH
25318: LD_INT 22
25320: PUSH
25321: LD_VAR 0 16
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 2
25332: PUSH
25333: LD_INT 30
25335: PUSH
25336: LD_INT 32
25338: PUSH
25339: EMPTY
25340: LIST
25341: LIST
25342: PUSH
25343: LD_INT 30
25345: PUSH
25346: LD_INT 33
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 91
25360: PUSH
25361: LD_VAR 0 1
25365: PUSH
25366: LD_INT 12
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: LIST
25373: PUSH
25374: EMPTY
25375: LIST
25376: LIST
25377: LIST
25378: PUSH
25379: EMPTY
25380: LIST
25381: PPUSH
25382: CALL_OW 69
25386: PUSH
25387: LD_INT 2
25389: GREATER
25390: AND
25391: IFFALSE 25414
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25393: LD_ADDR_VAR 0 18
25397: PUSH
25398: LD_INT 11
25400: PUSH
25401: LD_INT 30
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: PUSH
25408: LD_VAR 0 12
25412: ARRAY
25413: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25414: LD_VAR 0 18
25418: NOT
25419: PUSH
25420: LD_INT 40
25422: PPUSH
25423: LD_VAR 0 16
25427: PPUSH
25428: CALL_OW 321
25432: PUSH
25433: LD_INT 2
25435: EQUAL
25436: AND
25437: PUSH
25438: LD_INT 7
25440: PUSH
25441: LD_VAR 0 5
25445: IN
25446: PUSH
25447: LD_INT 28
25449: PUSH
25450: LD_VAR 0 5
25454: IN
25455: OR
25456: PUSH
25457: LD_INT 45
25459: PUSH
25460: LD_VAR 0 5
25464: IN
25465: OR
25466: AND
25467: IFFALSE 25721
// begin hex := GetHexInfo ( x , y ) ;
25469: LD_ADDR_VAR 0 4
25473: PUSH
25474: LD_VAR 0 10
25478: PPUSH
25479: LD_VAR 0 11
25483: PPUSH
25484: CALL_OW 546
25488: ST_TO_ADDR
// if hex [ 1 ] then
25489: LD_VAR 0 4
25493: PUSH
25494: LD_INT 1
25496: ARRAY
25497: IFFALSE 25501
// exit ;
25499: GO 25904
// height := hex [ 2 ] ;
25501: LD_ADDR_VAR 0 15
25505: PUSH
25506: LD_VAR 0 4
25510: PUSH
25511: LD_INT 2
25513: ARRAY
25514: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25515: LD_ADDR_VAR 0 14
25519: PUSH
25520: LD_INT 0
25522: PUSH
25523: LD_INT 2
25525: PUSH
25526: LD_INT 3
25528: PUSH
25529: LD_INT 5
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: ST_TO_ADDR
// for i in tmp do
25538: LD_ADDR_VAR 0 8
25542: PUSH
25543: LD_VAR 0 14
25547: PUSH
25548: FOR_IN
25549: IFFALSE 25719
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25551: LD_ADDR_VAR 0 9
25555: PUSH
25556: LD_VAR 0 10
25560: PPUSH
25561: LD_VAR 0 8
25565: PPUSH
25566: LD_INT 5
25568: PPUSH
25569: CALL_OW 272
25573: PUSH
25574: LD_VAR 0 11
25578: PPUSH
25579: LD_VAR 0 8
25583: PPUSH
25584: LD_INT 5
25586: PPUSH
25587: CALL_OW 273
25591: PUSH
25592: EMPTY
25593: LIST
25594: LIST
25595: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25596: LD_VAR 0 9
25600: PUSH
25601: LD_INT 1
25603: ARRAY
25604: PPUSH
25605: LD_VAR 0 9
25609: PUSH
25610: LD_INT 2
25612: ARRAY
25613: PPUSH
25614: CALL_OW 488
25618: IFFALSE 25717
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25620: LD_ADDR_VAR 0 4
25624: PUSH
25625: LD_VAR 0 9
25629: PUSH
25630: LD_INT 1
25632: ARRAY
25633: PPUSH
25634: LD_VAR 0 9
25638: PUSH
25639: LD_INT 2
25641: ARRAY
25642: PPUSH
25643: CALL_OW 546
25647: ST_TO_ADDR
// if hex [ 1 ] then
25648: LD_VAR 0 4
25652: PUSH
25653: LD_INT 1
25655: ARRAY
25656: IFFALSE 25660
// continue ;
25658: GO 25548
// h := hex [ 2 ] ;
25660: LD_ADDR_VAR 0 13
25664: PUSH
25665: LD_VAR 0 4
25669: PUSH
25670: LD_INT 2
25672: ARRAY
25673: ST_TO_ADDR
// if h + 7 < height then
25674: LD_VAR 0 13
25678: PUSH
25679: LD_INT 7
25681: PLUS
25682: PUSH
25683: LD_VAR 0 15
25687: LESS
25688: IFFALSE 25717
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25690: LD_ADDR_VAR 0 18
25694: PUSH
25695: LD_INT 7
25697: PUSH
25698: LD_INT 28
25700: PUSH
25701: LD_INT 45
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: LIST
25708: PUSH
25709: LD_VAR 0 12
25713: ARRAY
25714: ST_TO_ADDR
// break ;
25715: GO 25719
// end ; end ; end ;
25717: GO 25548
25719: POP
25720: POP
// end ; if not weapon then
25721: LD_VAR 0 18
25725: NOT
25726: IFFALSE 25786
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25728: LD_ADDR_VAR 0 5
25732: PUSH
25733: LD_VAR 0 5
25737: PUSH
25738: LD_INT 11
25740: PUSH
25741: LD_INT 30
25743: PUSH
25744: LD_INT 49
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: LIST
25751: DIFF
25752: ST_TO_ADDR
// if not list then
25753: LD_VAR 0 5
25757: NOT
25758: IFFALSE 25762
// exit ;
25760: GO 25904
// weapon := list [ rand ( 1 , list ) ] ;
25762: LD_ADDR_VAR 0 18
25766: PUSH
25767: LD_VAR 0 5
25771: PUSH
25772: LD_INT 1
25774: PPUSH
25775: LD_VAR 0 5
25779: PPUSH
25780: CALL_OW 12
25784: ARRAY
25785: ST_TO_ADDR
// end ; if weapon then
25786: LD_VAR 0 18
25790: IFFALSE 25904
// begin tmp := CostOfWeapon ( weapon ) ;
25792: LD_ADDR_VAR 0 14
25796: PUSH
25797: LD_VAR 0 18
25801: PPUSH
25802: CALL_OW 451
25806: ST_TO_ADDR
// j := GetBase ( tower ) ;
25807: LD_ADDR_VAR 0 9
25811: PUSH
25812: LD_VAR 0 1
25816: PPUSH
25817: CALL_OW 274
25821: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25822: LD_VAR 0 9
25826: PPUSH
25827: LD_INT 1
25829: PPUSH
25830: CALL_OW 275
25834: PUSH
25835: LD_VAR 0 14
25839: PUSH
25840: LD_INT 1
25842: ARRAY
25843: GREATEREQUAL
25844: PUSH
25845: LD_VAR 0 9
25849: PPUSH
25850: LD_INT 2
25852: PPUSH
25853: CALL_OW 275
25857: PUSH
25858: LD_VAR 0 14
25862: PUSH
25863: LD_INT 2
25865: ARRAY
25866: GREATEREQUAL
25867: AND
25868: PUSH
25869: LD_VAR 0 9
25873: PPUSH
25874: LD_INT 3
25876: PPUSH
25877: CALL_OW 275
25881: PUSH
25882: LD_VAR 0 14
25886: PUSH
25887: LD_INT 3
25889: ARRAY
25890: GREATEREQUAL
25891: AND
25892: IFFALSE 25904
// result := weapon ;
25894: LD_ADDR_VAR 0 3
25898: PUSH
25899: LD_VAR 0 18
25903: ST_TO_ADDR
// end ; end ;
25904: LD_VAR 0 3
25908: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25909: LD_INT 0
25911: PPUSH
25912: PPUSH
// result := true ;
25913: LD_ADDR_VAR 0 3
25917: PUSH
25918: LD_INT 1
25920: ST_TO_ADDR
// if array1 = array2 then
25921: LD_VAR 0 1
25925: PUSH
25926: LD_VAR 0 2
25930: EQUAL
25931: IFFALSE 25991
// begin for i = 1 to array1 do
25933: LD_ADDR_VAR 0 4
25937: PUSH
25938: DOUBLE
25939: LD_INT 1
25941: DEC
25942: ST_TO_ADDR
25943: LD_VAR 0 1
25947: PUSH
25948: FOR_TO
25949: IFFALSE 25987
// if array1 [ i ] <> array2 [ i ] then
25951: LD_VAR 0 1
25955: PUSH
25956: LD_VAR 0 4
25960: ARRAY
25961: PUSH
25962: LD_VAR 0 2
25966: PUSH
25967: LD_VAR 0 4
25971: ARRAY
25972: NONEQUAL
25973: IFFALSE 25985
// begin result := false ;
25975: LD_ADDR_VAR 0 3
25979: PUSH
25980: LD_INT 0
25982: ST_TO_ADDR
// break ;
25983: GO 25987
// end ;
25985: GO 25948
25987: POP
25988: POP
// end else
25989: GO 25999
// result := false ;
25991: LD_ADDR_VAR 0 3
25995: PUSH
25996: LD_INT 0
25998: ST_TO_ADDR
// end ;
25999: LD_VAR 0 3
26003: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26004: LD_INT 0
26006: PPUSH
26007: PPUSH
// if not array1 or not array2 then
26008: LD_VAR 0 1
26012: NOT
26013: PUSH
26014: LD_VAR 0 2
26018: NOT
26019: OR
26020: IFFALSE 26024
// exit ;
26022: GO 26088
// result := true ;
26024: LD_ADDR_VAR 0 3
26028: PUSH
26029: LD_INT 1
26031: ST_TO_ADDR
// for i = 1 to array1 do
26032: LD_ADDR_VAR 0 4
26036: PUSH
26037: DOUBLE
26038: LD_INT 1
26040: DEC
26041: ST_TO_ADDR
26042: LD_VAR 0 1
26046: PUSH
26047: FOR_TO
26048: IFFALSE 26086
// if array1 [ i ] <> array2 [ i ] then
26050: LD_VAR 0 1
26054: PUSH
26055: LD_VAR 0 4
26059: ARRAY
26060: PUSH
26061: LD_VAR 0 2
26065: PUSH
26066: LD_VAR 0 4
26070: ARRAY
26071: NONEQUAL
26072: IFFALSE 26084
// begin result := false ;
26074: LD_ADDR_VAR 0 3
26078: PUSH
26079: LD_INT 0
26081: ST_TO_ADDR
// break ;
26082: GO 26086
// end ;
26084: GO 26047
26086: POP
26087: POP
// end ;
26088: LD_VAR 0 3
26092: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26093: LD_INT 0
26095: PPUSH
26096: PPUSH
26097: PPUSH
// pom := GetBase ( fac ) ;
26098: LD_ADDR_VAR 0 5
26102: PUSH
26103: LD_VAR 0 1
26107: PPUSH
26108: CALL_OW 274
26112: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 2
26122: PUSH
26123: LD_INT 1
26125: ARRAY
26126: PPUSH
26127: LD_VAR 0 2
26131: PUSH
26132: LD_INT 2
26134: ARRAY
26135: PPUSH
26136: LD_VAR 0 2
26140: PUSH
26141: LD_INT 3
26143: ARRAY
26144: PPUSH
26145: LD_VAR 0 2
26149: PUSH
26150: LD_INT 4
26152: ARRAY
26153: PPUSH
26154: CALL_OW 449
26158: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26159: LD_ADDR_VAR 0 3
26163: PUSH
26164: LD_VAR 0 5
26168: PPUSH
26169: LD_INT 1
26171: PPUSH
26172: CALL_OW 275
26176: PUSH
26177: LD_VAR 0 4
26181: PUSH
26182: LD_INT 1
26184: ARRAY
26185: GREATEREQUAL
26186: PUSH
26187: LD_VAR 0 5
26191: PPUSH
26192: LD_INT 2
26194: PPUSH
26195: CALL_OW 275
26199: PUSH
26200: LD_VAR 0 4
26204: PUSH
26205: LD_INT 2
26207: ARRAY
26208: GREATEREQUAL
26209: AND
26210: PUSH
26211: LD_VAR 0 5
26215: PPUSH
26216: LD_INT 3
26218: PPUSH
26219: CALL_OW 275
26223: PUSH
26224: LD_VAR 0 4
26228: PUSH
26229: LD_INT 3
26231: ARRAY
26232: GREATEREQUAL
26233: AND
26234: ST_TO_ADDR
// end ;
26235: LD_VAR 0 3
26239: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26240: LD_INT 0
26242: PPUSH
26243: PPUSH
26244: PPUSH
26245: PPUSH
// pom := GetBase ( building ) ;
26246: LD_ADDR_VAR 0 3
26250: PUSH
26251: LD_VAR 0 1
26255: PPUSH
26256: CALL_OW 274
26260: ST_TO_ADDR
// if not pom then
26261: LD_VAR 0 3
26265: NOT
26266: IFFALSE 26270
// exit ;
26268: GO 26440
// btype := GetBType ( building ) ;
26270: LD_ADDR_VAR 0 5
26274: PUSH
26275: LD_VAR 0 1
26279: PPUSH
26280: CALL_OW 266
26284: ST_TO_ADDR
// if btype = b_armoury then
26285: LD_VAR 0 5
26289: PUSH
26290: LD_INT 4
26292: EQUAL
26293: IFFALSE 26303
// btype := b_barracks ;
26295: LD_ADDR_VAR 0 5
26299: PUSH
26300: LD_INT 5
26302: ST_TO_ADDR
// if btype = b_depot then
26303: LD_VAR 0 5
26307: PUSH
26308: LD_INT 0
26310: EQUAL
26311: IFFALSE 26321
// btype := b_warehouse ;
26313: LD_ADDR_VAR 0 5
26317: PUSH
26318: LD_INT 1
26320: ST_TO_ADDR
// if btype = b_workshop then
26321: LD_VAR 0 5
26325: PUSH
26326: LD_INT 2
26328: EQUAL
26329: IFFALSE 26339
// btype := b_factory ;
26331: LD_ADDR_VAR 0 5
26335: PUSH
26336: LD_INT 3
26338: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26339: LD_ADDR_VAR 0 4
26343: PUSH
26344: LD_VAR 0 5
26348: PPUSH
26349: LD_VAR 0 1
26353: PPUSH
26354: CALL_OW 248
26358: PPUSH
26359: CALL_OW 450
26363: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26364: LD_ADDR_VAR 0 2
26368: PUSH
26369: LD_VAR 0 3
26373: PPUSH
26374: LD_INT 1
26376: PPUSH
26377: CALL_OW 275
26381: PUSH
26382: LD_VAR 0 4
26386: PUSH
26387: LD_INT 1
26389: ARRAY
26390: GREATEREQUAL
26391: PUSH
26392: LD_VAR 0 3
26396: PPUSH
26397: LD_INT 2
26399: PPUSH
26400: CALL_OW 275
26404: PUSH
26405: LD_VAR 0 4
26409: PUSH
26410: LD_INT 2
26412: ARRAY
26413: GREATEREQUAL
26414: AND
26415: PUSH
26416: LD_VAR 0 3
26420: PPUSH
26421: LD_INT 3
26423: PPUSH
26424: CALL_OW 275
26428: PUSH
26429: LD_VAR 0 4
26433: PUSH
26434: LD_INT 3
26436: ARRAY
26437: GREATEREQUAL
26438: AND
26439: ST_TO_ADDR
// end ;
26440: LD_VAR 0 2
26444: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26445: LD_INT 0
26447: PPUSH
26448: PPUSH
26449: PPUSH
// pom := GetBase ( building ) ;
26450: LD_ADDR_VAR 0 4
26454: PUSH
26455: LD_VAR 0 1
26459: PPUSH
26460: CALL_OW 274
26464: ST_TO_ADDR
// if not pom then
26465: LD_VAR 0 4
26469: NOT
26470: IFFALSE 26474
// exit ;
26472: GO 26575
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26474: LD_ADDR_VAR 0 5
26478: PUSH
26479: LD_VAR 0 2
26483: PPUSH
26484: LD_VAR 0 1
26488: PPUSH
26489: CALL_OW 248
26493: PPUSH
26494: CALL_OW 450
26498: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26499: LD_ADDR_VAR 0 3
26503: PUSH
26504: LD_VAR 0 4
26508: PPUSH
26509: LD_INT 1
26511: PPUSH
26512: CALL_OW 275
26516: PUSH
26517: LD_VAR 0 5
26521: PUSH
26522: LD_INT 1
26524: ARRAY
26525: GREATEREQUAL
26526: PUSH
26527: LD_VAR 0 4
26531: PPUSH
26532: LD_INT 2
26534: PPUSH
26535: CALL_OW 275
26539: PUSH
26540: LD_VAR 0 5
26544: PUSH
26545: LD_INT 2
26547: ARRAY
26548: GREATEREQUAL
26549: AND
26550: PUSH
26551: LD_VAR 0 4
26555: PPUSH
26556: LD_INT 3
26558: PPUSH
26559: CALL_OW 275
26563: PUSH
26564: LD_VAR 0 5
26568: PUSH
26569: LD_INT 3
26571: ARRAY
26572: GREATEREQUAL
26573: AND
26574: ST_TO_ADDR
// end ;
26575: LD_VAR 0 3
26579: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26580: LD_INT 0
26582: PPUSH
26583: PPUSH
26584: PPUSH
26585: PPUSH
26586: PPUSH
26587: PPUSH
26588: PPUSH
26589: PPUSH
26590: PPUSH
26591: PPUSH
26592: PPUSH
// result := false ;
26593: LD_ADDR_VAR 0 8
26597: PUSH
26598: LD_INT 0
26600: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26601: LD_VAR 0 5
26605: NOT
26606: PUSH
26607: LD_VAR 0 1
26611: NOT
26612: OR
26613: PUSH
26614: LD_VAR 0 2
26618: NOT
26619: OR
26620: PUSH
26621: LD_VAR 0 3
26625: NOT
26626: OR
26627: IFFALSE 26631
// exit ;
26629: GO 27445
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26631: LD_ADDR_VAR 0 14
26635: PUSH
26636: LD_VAR 0 1
26640: PPUSH
26641: LD_VAR 0 2
26645: PPUSH
26646: LD_VAR 0 3
26650: PPUSH
26651: LD_VAR 0 4
26655: PPUSH
26656: LD_VAR 0 5
26660: PUSH
26661: LD_INT 1
26663: ARRAY
26664: PPUSH
26665: CALL_OW 248
26669: PPUSH
26670: LD_INT 0
26672: PPUSH
26673: CALL 28682 0 6
26677: ST_TO_ADDR
// if not hexes then
26678: LD_VAR 0 14
26682: NOT
26683: IFFALSE 26687
// exit ;
26685: GO 27445
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26687: LD_ADDR_VAR 0 17
26691: PUSH
26692: LD_VAR 0 5
26696: PPUSH
26697: LD_INT 22
26699: PUSH
26700: LD_VAR 0 13
26704: PPUSH
26705: CALL_OW 255
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PUSH
26714: LD_INT 2
26716: PUSH
26717: LD_INT 30
26719: PUSH
26720: LD_INT 0
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PUSH
26727: LD_INT 30
26729: PUSH
26730: LD_INT 1
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: LIST
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PPUSH
26746: CALL_OW 72
26750: ST_TO_ADDR
// for i = 1 to hexes do
26751: LD_ADDR_VAR 0 9
26755: PUSH
26756: DOUBLE
26757: LD_INT 1
26759: DEC
26760: ST_TO_ADDR
26761: LD_VAR 0 14
26765: PUSH
26766: FOR_TO
26767: IFFALSE 27443
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26769: LD_ADDR_VAR 0 13
26773: PUSH
26774: LD_VAR 0 14
26778: PUSH
26779: LD_VAR 0 9
26783: ARRAY
26784: PUSH
26785: LD_INT 1
26787: ARRAY
26788: PPUSH
26789: LD_VAR 0 14
26793: PUSH
26794: LD_VAR 0 9
26798: ARRAY
26799: PUSH
26800: LD_INT 2
26802: ARRAY
26803: PPUSH
26804: CALL_OW 428
26808: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26809: LD_VAR 0 14
26813: PUSH
26814: LD_VAR 0 9
26818: ARRAY
26819: PUSH
26820: LD_INT 1
26822: ARRAY
26823: PPUSH
26824: LD_VAR 0 14
26828: PUSH
26829: LD_VAR 0 9
26833: ARRAY
26834: PUSH
26835: LD_INT 2
26837: ARRAY
26838: PPUSH
26839: CALL_OW 351
26843: PUSH
26844: LD_VAR 0 14
26848: PUSH
26849: LD_VAR 0 9
26853: ARRAY
26854: PUSH
26855: LD_INT 1
26857: ARRAY
26858: PPUSH
26859: LD_VAR 0 14
26863: PUSH
26864: LD_VAR 0 9
26868: ARRAY
26869: PUSH
26870: LD_INT 2
26872: ARRAY
26873: PPUSH
26874: CALL_OW 488
26878: NOT
26879: OR
26880: PUSH
26881: LD_VAR 0 13
26885: PPUSH
26886: CALL_OW 247
26890: PUSH
26891: LD_INT 3
26893: EQUAL
26894: OR
26895: IFFALSE 26901
// exit ;
26897: POP
26898: POP
26899: GO 27445
// if not tmp then
26901: LD_VAR 0 13
26905: NOT
26906: IFFALSE 26910
// continue ;
26908: GO 26766
// result := true ;
26910: LD_ADDR_VAR 0 8
26914: PUSH
26915: LD_INT 1
26917: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26918: LD_VAR 0 6
26922: PUSH
26923: LD_VAR 0 13
26927: PPUSH
26928: CALL_OW 247
26932: PUSH
26933: LD_INT 2
26935: EQUAL
26936: AND
26937: PUSH
26938: LD_VAR 0 13
26942: PPUSH
26943: CALL_OW 263
26947: PUSH
26948: LD_INT 1
26950: EQUAL
26951: AND
26952: IFFALSE 27116
// begin if IsDrivenBy ( tmp ) then
26954: LD_VAR 0 13
26958: PPUSH
26959: CALL_OW 311
26963: IFFALSE 26967
// continue ;
26965: GO 26766
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26967: LD_VAR 0 6
26971: PPUSH
26972: LD_INT 3
26974: PUSH
26975: LD_INT 60
26977: PUSH
26978: EMPTY
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 55
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PPUSH
27002: CALL_OW 72
27006: IFFALSE 27114
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27008: LD_ADDR_VAR 0 18
27012: PUSH
27013: LD_VAR 0 6
27017: PPUSH
27018: LD_INT 3
27020: PUSH
27021: LD_INT 60
27023: PUSH
27024: EMPTY
27025: LIST
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: LD_INT 3
27033: PUSH
27034: LD_INT 55
27036: PUSH
27037: EMPTY
27038: LIST
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PPUSH
27048: CALL_OW 72
27052: PUSH
27053: LD_INT 1
27055: ARRAY
27056: ST_TO_ADDR
// if IsInUnit ( driver ) then
27057: LD_VAR 0 18
27061: PPUSH
27062: CALL_OW 310
27066: IFFALSE 27077
// ComExit ( driver ) ;
27068: LD_VAR 0 18
27072: PPUSH
27073: CALL 51866 0 1
// AddComEnterUnit ( driver , tmp ) ;
27077: LD_VAR 0 18
27081: PPUSH
27082: LD_VAR 0 13
27086: PPUSH
27087: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27091: LD_VAR 0 18
27095: PPUSH
27096: LD_VAR 0 7
27100: PPUSH
27101: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27105: LD_VAR 0 18
27109: PPUSH
27110: CALL_OW 181
// end ; continue ;
27114: GO 26766
// end ; if not cleaners or not tmp in cleaners then
27116: LD_VAR 0 6
27120: NOT
27121: PUSH
27122: LD_VAR 0 13
27126: PUSH
27127: LD_VAR 0 6
27131: IN
27132: NOT
27133: OR
27134: IFFALSE 27441
// begin if dep then
27136: LD_VAR 0 17
27140: IFFALSE 27276
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27142: LD_ADDR_VAR 0 16
27146: PUSH
27147: LD_VAR 0 17
27151: PUSH
27152: LD_INT 1
27154: ARRAY
27155: PPUSH
27156: CALL_OW 250
27160: PPUSH
27161: LD_VAR 0 17
27165: PUSH
27166: LD_INT 1
27168: ARRAY
27169: PPUSH
27170: CALL_OW 254
27174: PPUSH
27175: LD_INT 5
27177: PPUSH
27178: CALL_OW 272
27182: PUSH
27183: LD_VAR 0 17
27187: PUSH
27188: LD_INT 1
27190: ARRAY
27191: PPUSH
27192: CALL_OW 251
27196: PPUSH
27197: LD_VAR 0 17
27201: PUSH
27202: LD_INT 1
27204: ARRAY
27205: PPUSH
27206: CALL_OW 254
27210: PPUSH
27211: LD_INT 5
27213: PPUSH
27214: CALL_OW 273
27218: PUSH
27219: EMPTY
27220: LIST
27221: LIST
27222: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27223: LD_VAR 0 16
27227: PUSH
27228: LD_INT 1
27230: ARRAY
27231: PPUSH
27232: LD_VAR 0 16
27236: PUSH
27237: LD_INT 2
27239: ARRAY
27240: PPUSH
27241: CALL_OW 488
27245: IFFALSE 27276
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27247: LD_VAR 0 13
27251: PPUSH
27252: LD_VAR 0 16
27256: PUSH
27257: LD_INT 1
27259: ARRAY
27260: PPUSH
27261: LD_VAR 0 16
27265: PUSH
27266: LD_INT 2
27268: ARRAY
27269: PPUSH
27270: CALL_OW 111
// continue ;
27274: GO 26766
// end ; end ; r := GetDir ( tmp ) ;
27276: LD_ADDR_VAR 0 15
27280: PUSH
27281: LD_VAR 0 13
27285: PPUSH
27286: CALL_OW 254
27290: ST_TO_ADDR
// if r = 5 then
27291: LD_VAR 0 15
27295: PUSH
27296: LD_INT 5
27298: EQUAL
27299: IFFALSE 27309
// r := 0 ;
27301: LD_ADDR_VAR 0 15
27305: PUSH
27306: LD_INT 0
27308: ST_TO_ADDR
// for j = r to 5 do
27309: LD_ADDR_VAR 0 10
27313: PUSH
27314: DOUBLE
27315: LD_VAR 0 15
27319: DEC
27320: ST_TO_ADDR
27321: LD_INT 5
27323: PUSH
27324: FOR_TO
27325: IFFALSE 27439
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27327: LD_ADDR_VAR 0 11
27331: PUSH
27332: LD_VAR 0 13
27336: PPUSH
27337: CALL_OW 250
27341: PPUSH
27342: LD_VAR 0 10
27346: PPUSH
27347: LD_INT 2
27349: PPUSH
27350: CALL_OW 272
27354: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27355: LD_ADDR_VAR 0 12
27359: PUSH
27360: LD_VAR 0 13
27364: PPUSH
27365: CALL_OW 251
27369: PPUSH
27370: LD_VAR 0 10
27374: PPUSH
27375: LD_INT 2
27377: PPUSH
27378: CALL_OW 273
27382: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27383: LD_VAR 0 11
27387: PPUSH
27388: LD_VAR 0 12
27392: PPUSH
27393: CALL_OW 488
27397: PUSH
27398: LD_VAR 0 11
27402: PPUSH
27403: LD_VAR 0 12
27407: PPUSH
27408: CALL_OW 428
27412: NOT
27413: AND
27414: IFFALSE 27437
// begin ComMoveXY ( tmp , _x , _y ) ;
27416: LD_VAR 0 13
27420: PPUSH
27421: LD_VAR 0 11
27425: PPUSH
27426: LD_VAR 0 12
27430: PPUSH
27431: CALL_OW 111
// break ;
27435: GO 27439
// end ; end ;
27437: GO 27324
27439: POP
27440: POP
// end ; end ;
27441: GO 26766
27443: POP
27444: POP
// end ;
27445: LD_VAR 0 8
27449: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27450: LD_INT 0
27452: PPUSH
// result := true ;
27453: LD_ADDR_VAR 0 3
27457: PUSH
27458: LD_INT 1
27460: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27461: LD_VAR 0 2
27465: PUSH
27466: LD_INT 24
27468: DOUBLE
27469: EQUAL
27470: IFTRUE 27480
27472: LD_INT 33
27474: DOUBLE
27475: EQUAL
27476: IFTRUE 27480
27478: GO 27505
27480: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27481: LD_ADDR_VAR 0 3
27485: PUSH
27486: LD_INT 32
27488: PPUSH
27489: LD_VAR 0 1
27493: PPUSH
27494: CALL_OW 321
27498: PUSH
27499: LD_INT 2
27501: EQUAL
27502: ST_TO_ADDR
27503: GO 27825
27505: LD_INT 20
27507: DOUBLE
27508: EQUAL
27509: IFTRUE 27513
27511: GO 27538
27513: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27514: LD_ADDR_VAR 0 3
27518: PUSH
27519: LD_INT 6
27521: PPUSH
27522: LD_VAR 0 1
27526: PPUSH
27527: CALL_OW 321
27531: PUSH
27532: LD_INT 2
27534: EQUAL
27535: ST_TO_ADDR
27536: GO 27825
27538: LD_INT 22
27540: DOUBLE
27541: EQUAL
27542: IFTRUE 27552
27544: LD_INT 36
27546: DOUBLE
27547: EQUAL
27548: IFTRUE 27552
27550: GO 27577
27552: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27553: LD_ADDR_VAR 0 3
27557: PUSH
27558: LD_INT 15
27560: PPUSH
27561: LD_VAR 0 1
27565: PPUSH
27566: CALL_OW 321
27570: PUSH
27571: LD_INT 2
27573: EQUAL
27574: ST_TO_ADDR
27575: GO 27825
27577: LD_INT 30
27579: DOUBLE
27580: EQUAL
27581: IFTRUE 27585
27583: GO 27610
27585: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27586: LD_ADDR_VAR 0 3
27590: PUSH
27591: LD_INT 20
27593: PPUSH
27594: LD_VAR 0 1
27598: PPUSH
27599: CALL_OW 321
27603: PUSH
27604: LD_INT 2
27606: EQUAL
27607: ST_TO_ADDR
27608: GO 27825
27610: LD_INT 28
27612: DOUBLE
27613: EQUAL
27614: IFTRUE 27624
27616: LD_INT 21
27618: DOUBLE
27619: EQUAL
27620: IFTRUE 27624
27622: GO 27649
27624: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27625: LD_ADDR_VAR 0 3
27629: PUSH
27630: LD_INT 21
27632: PPUSH
27633: LD_VAR 0 1
27637: PPUSH
27638: CALL_OW 321
27642: PUSH
27643: LD_INT 2
27645: EQUAL
27646: ST_TO_ADDR
27647: GO 27825
27649: LD_INT 16
27651: DOUBLE
27652: EQUAL
27653: IFTRUE 27657
27655: GO 27684
27657: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27658: LD_ADDR_VAR 0 3
27662: PUSH
27663: LD_EXP 115
27667: PPUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 321
27677: PUSH
27678: LD_INT 2
27680: EQUAL
27681: ST_TO_ADDR
27682: GO 27825
27684: LD_INT 19
27686: DOUBLE
27687: EQUAL
27688: IFTRUE 27698
27690: LD_INT 23
27692: DOUBLE
27693: EQUAL
27694: IFTRUE 27698
27696: GO 27725
27698: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27699: LD_ADDR_VAR 0 3
27703: PUSH
27704: LD_EXP 114
27708: PPUSH
27709: LD_VAR 0 1
27713: PPUSH
27714: CALL_OW 321
27718: PUSH
27719: LD_INT 2
27721: EQUAL
27722: ST_TO_ADDR
27723: GO 27825
27725: LD_INT 17
27727: DOUBLE
27728: EQUAL
27729: IFTRUE 27733
27731: GO 27758
27733: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27734: LD_ADDR_VAR 0 3
27738: PUSH
27739: LD_INT 39
27741: PPUSH
27742: LD_VAR 0 1
27746: PPUSH
27747: CALL_OW 321
27751: PUSH
27752: LD_INT 2
27754: EQUAL
27755: ST_TO_ADDR
27756: GO 27825
27758: LD_INT 18
27760: DOUBLE
27761: EQUAL
27762: IFTRUE 27766
27764: GO 27791
27766: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27767: LD_ADDR_VAR 0 3
27771: PUSH
27772: LD_INT 40
27774: PPUSH
27775: LD_VAR 0 1
27779: PPUSH
27780: CALL_OW 321
27784: PUSH
27785: LD_INT 2
27787: EQUAL
27788: ST_TO_ADDR
27789: GO 27825
27791: LD_INT 27
27793: DOUBLE
27794: EQUAL
27795: IFTRUE 27799
27797: GO 27824
27799: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27800: LD_ADDR_VAR 0 3
27804: PUSH
27805: LD_INT 35
27807: PPUSH
27808: LD_VAR 0 1
27812: PPUSH
27813: CALL_OW 321
27817: PUSH
27818: LD_INT 2
27820: EQUAL
27821: ST_TO_ADDR
27822: GO 27825
27824: POP
// end ;
27825: LD_VAR 0 3
27829: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27830: LD_INT 0
27832: PPUSH
27833: PPUSH
27834: PPUSH
27835: PPUSH
27836: PPUSH
27837: PPUSH
27838: PPUSH
27839: PPUSH
27840: PPUSH
27841: PPUSH
27842: PPUSH
// result := false ;
27843: LD_ADDR_VAR 0 6
27847: PUSH
27848: LD_INT 0
27850: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27851: LD_VAR 0 1
27855: NOT
27856: PUSH
27857: LD_VAR 0 1
27861: PPUSH
27862: CALL_OW 266
27866: PUSH
27867: LD_INT 0
27869: PUSH
27870: LD_INT 1
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: IN
27877: NOT
27878: OR
27879: PUSH
27880: LD_VAR 0 2
27884: NOT
27885: OR
27886: PUSH
27887: LD_VAR 0 5
27891: PUSH
27892: LD_INT 0
27894: PUSH
27895: LD_INT 1
27897: PUSH
27898: LD_INT 2
27900: PUSH
27901: LD_INT 3
27903: PUSH
27904: LD_INT 4
27906: PUSH
27907: LD_INT 5
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: IN
27918: NOT
27919: OR
27920: PUSH
27921: LD_VAR 0 3
27925: PPUSH
27926: LD_VAR 0 4
27930: PPUSH
27931: CALL_OW 488
27935: NOT
27936: OR
27937: IFFALSE 27941
// exit ;
27939: GO 28677
// side := GetSide ( depot ) ;
27941: LD_ADDR_VAR 0 9
27945: PUSH
27946: LD_VAR 0 1
27950: PPUSH
27951: CALL_OW 255
27955: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
27956: LD_VAR 0 9
27960: PPUSH
27961: LD_VAR 0 2
27965: PPUSH
27966: CALL 27450 0 2
27970: NOT
27971: IFFALSE 27975
// exit ;
27973: GO 28677
// pom := GetBase ( depot ) ;
27975: LD_ADDR_VAR 0 10
27979: PUSH
27980: LD_VAR 0 1
27984: PPUSH
27985: CALL_OW 274
27989: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27990: LD_ADDR_VAR 0 11
27994: PUSH
27995: LD_VAR 0 2
27999: PPUSH
28000: LD_VAR 0 1
28004: PPUSH
28005: CALL_OW 248
28009: PPUSH
28010: CALL_OW 450
28014: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28015: LD_VAR 0 10
28019: PPUSH
28020: LD_INT 1
28022: PPUSH
28023: CALL_OW 275
28027: PUSH
28028: LD_VAR 0 11
28032: PUSH
28033: LD_INT 1
28035: ARRAY
28036: GREATEREQUAL
28037: PUSH
28038: LD_VAR 0 10
28042: PPUSH
28043: LD_INT 2
28045: PPUSH
28046: CALL_OW 275
28050: PUSH
28051: LD_VAR 0 11
28055: PUSH
28056: LD_INT 2
28058: ARRAY
28059: GREATEREQUAL
28060: AND
28061: PUSH
28062: LD_VAR 0 10
28066: PPUSH
28067: LD_INT 3
28069: PPUSH
28070: CALL_OW 275
28074: PUSH
28075: LD_VAR 0 11
28079: PUSH
28080: LD_INT 3
28082: ARRAY
28083: GREATEREQUAL
28084: AND
28085: NOT
28086: IFFALSE 28090
// exit ;
28088: GO 28677
// if GetBType ( depot ) = b_depot then
28090: LD_VAR 0 1
28094: PPUSH
28095: CALL_OW 266
28099: PUSH
28100: LD_INT 0
28102: EQUAL
28103: IFFALSE 28115
// dist := 28 else
28105: LD_ADDR_VAR 0 14
28109: PUSH
28110: LD_INT 28
28112: ST_TO_ADDR
28113: GO 28123
// dist := 36 ;
28115: LD_ADDR_VAR 0 14
28119: PUSH
28120: LD_INT 36
28122: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28123: LD_VAR 0 1
28127: PPUSH
28128: LD_VAR 0 3
28132: PPUSH
28133: LD_VAR 0 4
28137: PPUSH
28138: CALL_OW 297
28142: PUSH
28143: LD_VAR 0 14
28147: GREATER
28148: IFFALSE 28152
// exit ;
28150: GO 28677
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28152: LD_ADDR_VAR 0 12
28156: PUSH
28157: LD_VAR 0 2
28161: PPUSH
28162: LD_VAR 0 3
28166: PPUSH
28167: LD_VAR 0 4
28171: PPUSH
28172: LD_VAR 0 5
28176: PPUSH
28177: LD_VAR 0 1
28181: PPUSH
28182: CALL_OW 248
28186: PPUSH
28187: LD_INT 0
28189: PPUSH
28190: CALL 28682 0 6
28194: ST_TO_ADDR
// if not hexes then
28195: LD_VAR 0 12
28199: NOT
28200: IFFALSE 28204
// exit ;
28202: GO 28677
// hex := GetHexInfo ( x , y ) ;
28204: LD_ADDR_VAR 0 15
28208: PUSH
28209: LD_VAR 0 3
28213: PPUSH
28214: LD_VAR 0 4
28218: PPUSH
28219: CALL_OW 546
28223: ST_TO_ADDR
// if hex [ 1 ] then
28224: LD_VAR 0 15
28228: PUSH
28229: LD_INT 1
28231: ARRAY
28232: IFFALSE 28236
// exit ;
28234: GO 28677
// height := hex [ 2 ] ;
28236: LD_ADDR_VAR 0 13
28240: PUSH
28241: LD_VAR 0 15
28245: PUSH
28246: LD_INT 2
28248: ARRAY
28249: ST_TO_ADDR
// for i = 1 to hexes do
28250: LD_ADDR_VAR 0 7
28254: PUSH
28255: DOUBLE
28256: LD_INT 1
28258: DEC
28259: ST_TO_ADDR
28260: LD_VAR 0 12
28264: PUSH
28265: FOR_TO
28266: IFFALSE 28596
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28268: LD_VAR 0 12
28272: PUSH
28273: LD_VAR 0 7
28277: ARRAY
28278: PUSH
28279: LD_INT 1
28281: ARRAY
28282: PPUSH
28283: LD_VAR 0 12
28287: PUSH
28288: LD_VAR 0 7
28292: ARRAY
28293: PUSH
28294: LD_INT 2
28296: ARRAY
28297: PPUSH
28298: CALL_OW 488
28302: NOT
28303: PUSH
28304: LD_VAR 0 12
28308: PUSH
28309: LD_VAR 0 7
28313: ARRAY
28314: PUSH
28315: LD_INT 1
28317: ARRAY
28318: PPUSH
28319: LD_VAR 0 12
28323: PUSH
28324: LD_VAR 0 7
28328: ARRAY
28329: PUSH
28330: LD_INT 2
28332: ARRAY
28333: PPUSH
28334: CALL_OW 428
28338: PUSH
28339: LD_INT 0
28341: GREATER
28342: OR
28343: PUSH
28344: LD_VAR 0 12
28348: PUSH
28349: LD_VAR 0 7
28353: ARRAY
28354: PUSH
28355: LD_INT 1
28357: ARRAY
28358: PPUSH
28359: LD_VAR 0 12
28363: PUSH
28364: LD_VAR 0 7
28368: ARRAY
28369: PUSH
28370: LD_INT 2
28372: ARRAY
28373: PPUSH
28374: CALL_OW 351
28378: OR
28379: IFFALSE 28385
// exit ;
28381: POP
28382: POP
28383: GO 28677
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28385: LD_ADDR_VAR 0 8
28389: PUSH
28390: LD_VAR 0 12
28394: PUSH
28395: LD_VAR 0 7
28399: ARRAY
28400: PUSH
28401: LD_INT 1
28403: ARRAY
28404: PPUSH
28405: LD_VAR 0 12
28409: PUSH
28410: LD_VAR 0 7
28414: ARRAY
28415: PUSH
28416: LD_INT 2
28418: ARRAY
28419: PPUSH
28420: CALL_OW 546
28424: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28425: LD_VAR 0 8
28429: PUSH
28430: LD_INT 1
28432: ARRAY
28433: PUSH
28434: LD_VAR 0 8
28438: PUSH
28439: LD_INT 2
28441: ARRAY
28442: PUSH
28443: LD_VAR 0 13
28447: PUSH
28448: LD_INT 2
28450: PLUS
28451: GREATER
28452: OR
28453: PUSH
28454: LD_VAR 0 8
28458: PUSH
28459: LD_INT 2
28461: ARRAY
28462: PUSH
28463: LD_VAR 0 13
28467: PUSH
28468: LD_INT 2
28470: MINUS
28471: LESS
28472: OR
28473: PUSH
28474: LD_VAR 0 8
28478: PUSH
28479: LD_INT 3
28481: ARRAY
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: LD_INT 8
28488: PUSH
28489: LD_INT 9
28491: PUSH
28492: LD_INT 10
28494: PUSH
28495: LD_INT 11
28497: PUSH
28498: LD_INT 12
28500: PUSH
28501: LD_INT 13
28503: PUSH
28504: LD_INT 16
28506: PUSH
28507: LD_INT 17
28509: PUSH
28510: LD_INT 18
28512: PUSH
28513: LD_INT 19
28515: PUSH
28516: LD_INT 20
28518: PUSH
28519: LD_INT 21
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: LIST
28534: LIST
28535: LIST
28536: IN
28537: NOT
28538: OR
28539: PUSH
28540: LD_VAR 0 8
28544: PUSH
28545: LD_INT 5
28547: ARRAY
28548: NOT
28549: OR
28550: PUSH
28551: LD_VAR 0 8
28555: PUSH
28556: LD_INT 6
28558: ARRAY
28559: PUSH
28560: LD_INT 1
28562: PUSH
28563: LD_INT 2
28565: PUSH
28566: LD_INT 7
28568: PUSH
28569: LD_INT 9
28571: PUSH
28572: LD_INT 10
28574: PUSH
28575: LD_INT 11
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: LIST
28585: IN
28586: NOT
28587: OR
28588: IFFALSE 28594
// exit ;
28590: POP
28591: POP
28592: GO 28677
// end ;
28594: GO 28265
28596: POP
28597: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28598: LD_VAR 0 9
28602: PPUSH
28603: LD_VAR 0 3
28607: PPUSH
28608: LD_VAR 0 4
28612: PPUSH
28613: LD_INT 20
28615: PPUSH
28616: CALL 20622 0 4
28620: PUSH
28621: LD_INT 4
28623: ARRAY
28624: IFFALSE 28628
// exit ;
28626: GO 28677
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28628: LD_VAR 0 2
28632: PUSH
28633: LD_INT 29
28635: PUSH
28636: LD_INT 30
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: IN
28643: PUSH
28644: LD_VAR 0 3
28648: PPUSH
28649: LD_VAR 0 4
28653: PPUSH
28654: LD_VAR 0 9
28658: PPUSH
28659: CALL_OW 440
28663: NOT
28664: AND
28665: IFFALSE 28669
// exit ;
28667: GO 28677
// result := true ;
28669: LD_ADDR_VAR 0 6
28673: PUSH
28674: LD_INT 1
28676: ST_TO_ADDR
// end ;
28677: LD_VAR 0 6
28681: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28682: LD_INT 0
28684: PPUSH
28685: PPUSH
28686: PPUSH
28687: PPUSH
28688: PPUSH
28689: PPUSH
28690: PPUSH
28691: PPUSH
28692: PPUSH
28693: PPUSH
28694: PPUSH
28695: PPUSH
28696: PPUSH
28697: PPUSH
28698: PPUSH
28699: PPUSH
28700: PPUSH
28701: PPUSH
28702: PPUSH
28703: PPUSH
28704: PPUSH
28705: PPUSH
28706: PPUSH
28707: PPUSH
28708: PPUSH
28709: PPUSH
28710: PPUSH
28711: PPUSH
28712: PPUSH
28713: PPUSH
28714: PPUSH
28715: PPUSH
28716: PPUSH
28717: PPUSH
28718: PPUSH
28719: PPUSH
28720: PPUSH
28721: PPUSH
28722: PPUSH
28723: PPUSH
28724: PPUSH
28725: PPUSH
28726: PPUSH
28727: PPUSH
28728: PPUSH
28729: PPUSH
28730: PPUSH
28731: PPUSH
28732: PPUSH
28733: PPUSH
28734: PPUSH
28735: PPUSH
28736: PPUSH
28737: PPUSH
28738: PPUSH
28739: PPUSH
28740: PPUSH
28741: PPUSH
// result = [ ] ;
28742: LD_ADDR_VAR 0 7
28746: PUSH
28747: EMPTY
28748: ST_TO_ADDR
// temp_list = [ ] ;
28749: LD_ADDR_VAR 0 9
28753: PUSH
28754: EMPTY
28755: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28756: LD_VAR 0 4
28760: PUSH
28761: LD_INT 0
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: LD_INT 3
28772: PUSH
28773: LD_INT 4
28775: PUSH
28776: LD_INT 5
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: IN
28787: NOT
28788: PUSH
28789: LD_VAR 0 1
28793: PUSH
28794: LD_INT 0
28796: PUSH
28797: LD_INT 1
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: IN
28804: PUSH
28805: LD_VAR 0 5
28809: PUSH
28810: LD_INT 1
28812: PUSH
28813: LD_INT 2
28815: PUSH
28816: LD_INT 3
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: IN
28824: NOT
28825: AND
28826: OR
28827: IFFALSE 28831
// exit ;
28829: GO 47222
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28831: LD_VAR 0 1
28835: PUSH
28836: LD_INT 6
28838: PUSH
28839: LD_INT 7
28841: PUSH
28842: LD_INT 8
28844: PUSH
28845: LD_INT 13
28847: PUSH
28848: LD_INT 12
28850: PUSH
28851: LD_INT 15
28853: PUSH
28854: LD_INT 11
28856: PUSH
28857: LD_INT 14
28859: PUSH
28860: LD_INT 10
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: LIST
28873: IN
28874: IFFALSE 28884
// btype = b_lab ;
28876: LD_ADDR_VAR 0 1
28880: PUSH
28881: LD_INT 6
28883: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28884: LD_VAR 0 6
28888: PUSH
28889: LD_INT 0
28891: PUSH
28892: LD_INT 1
28894: PUSH
28895: LD_INT 2
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: LIST
28902: IN
28903: NOT
28904: PUSH
28905: LD_VAR 0 1
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 1
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: LD_INT 3
28921: PUSH
28922: LD_INT 6
28924: PUSH
28925: LD_INT 36
28927: PUSH
28928: LD_INT 4
28930: PUSH
28931: LD_INT 5
28933: PUSH
28934: LD_INT 31
28936: PUSH
28937: LD_INT 32
28939: PUSH
28940: LD_INT 33
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: LIST
28955: IN
28956: NOT
28957: PUSH
28958: LD_VAR 0 6
28962: PUSH
28963: LD_INT 1
28965: EQUAL
28966: AND
28967: OR
28968: PUSH
28969: LD_VAR 0 1
28973: PUSH
28974: LD_INT 2
28976: PUSH
28977: LD_INT 3
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: IN
28984: NOT
28985: PUSH
28986: LD_VAR 0 6
28990: PUSH
28991: LD_INT 2
28993: EQUAL
28994: AND
28995: OR
28996: IFFALSE 29006
// mode = 0 ;
28998: LD_ADDR_VAR 0 6
29002: PUSH
29003: LD_INT 0
29005: ST_TO_ADDR
// case mode of 0 :
29006: LD_VAR 0 6
29010: PUSH
29011: LD_INT 0
29013: DOUBLE
29014: EQUAL
29015: IFTRUE 29019
29017: GO 40472
29019: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29020: LD_ADDR_VAR 0 11
29024: PUSH
29025: LD_INT 0
29027: PUSH
29028: LD_INT 0
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 1
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 1
29048: PUSH
29049: LD_INT 0
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: NEG
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 1
29101: NEG
29102: PUSH
29103: LD_INT 2
29105: NEG
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: LD_INT 2
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 1
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: EMPTY
29130: LIST
29131: LIST
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: LD_INT 2
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 0
29145: PUSH
29146: LD_INT 2
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: NEG
29156: PUSH
29157: LD_INT 1
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 1
29166: PUSH
29167: LD_INT 3
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 0
29176: PUSH
29177: LD_INT 3
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 1
29186: NEG
29187: PUSH
29188: LD_INT 2
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29213: LD_ADDR_VAR 0 12
29217: PUSH
29218: LD_INT 0
29220: PUSH
29221: LD_INT 0
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 1
29233: NEG
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PUSH
29242: LD_INT 0
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 1
29294: PUSH
29295: LD_INT 1
29297: NEG
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 2
29305: PUSH
29306: LD_INT 0
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 2
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 1
29325: NEG
29326: PUSH
29327: LD_INT 1
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 2
29336: NEG
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 2
29347: NEG
29348: PUSH
29349: LD_INT 1
29351: NEG
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 2
29359: NEG
29360: PUSH
29361: LD_INT 1
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 3
29370: NEG
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 3
29381: NEG
29382: PUSH
29383: LD_INT 1
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: LIST
29395: LIST
29396: LIST
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29409: LD_ADDR_VAR 0 13
29413: PUSH
29414: LD_INT 0
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: LD_INT 1
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: LD_INT 0
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 1
29447: PUSH
29448: LD_INT 1
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 0
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 1
29467: NEG
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: NEG
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: LD_INT 2
29494: NEG
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: PUSH
29503: LD_INT 1
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 2
29512: PUSH
29513: LD_INT 2
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: PUSH
29523: LD_INT 2
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: LD_INT 1
29536: NEG
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 2
29544: NEG
29545: PUSH
29546: LD_INT 2
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 2
29556: NEG
29557: PUSH
29558: LD_INT 3
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 3
29568: NEG
29569: PUSH
29570: LD_INT 2
29572: NEG
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 3
29580: NEG
29581: PUSH
29582: LD_INT 3
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29608: LD_ADDR_VAR 0 14
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: LD_INT 1
29628: NEG
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 0
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: LD_INT 0
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: LD_INT 1
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: LD_INT 1
29689: NEG
29690: PUSH
29691: LD_INT 2
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 0
29701: PUSH
29702: LD_INT 2
29704: NEG
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: LD_INT 1
29715: NEG
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: LD_INT 2
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: NEG
29744: PUSH
29745: LD_INT 1
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 3
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 3
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: LD_INT 2
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29804: LD_ADDR_VAR 0 15
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: LD_INT 0
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 1
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: PUSH
29833: LD_INT 0
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: LD_INT 1
29877: NEG
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: PUSH
29897: LD_INT 0
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 2
29906: PUSH
29907: LD_INT 1
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 1
29916: NEG
29917: PUSH
29918: LD_INT 1
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 2
29927: NEG
29928: PUSH
29929: LD_INT 0
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 2
29938: NEG
29939: PUSH
29940: LD_INT 1
29942: NEG
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 2
29950: PUSH
29951: LD_INT 1
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 0
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 3
29971: PUSH
29972: LD_INT 1
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29997: LD_ADDR_VAR 0 16
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: LD_INT 0
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 1
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 1
30055: NEG
30056: PUSH
30057: LD_INT 0
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 1
30066: NEG
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 2
30082: NEG
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 2
30090: PUSH
30091: LD_INT 1
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 2
30100: PUSH
30101: LD_INT 2
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: LD_INT 1
30110: PUSH
30111: LD_INT 2
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 2
30120: NEG
30121: PUSH
30122: LD_INT 1
30124: NEG
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 2
30132: NEG
30133: PUSH
30134: LD_INT 2
30136: NEG
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 3
30144: PUSH
30145: LD_INT 2
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 3
30154: PUSH
30155: LD_INT 3
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30190: LD_ADDR_VAR 0 17
30194: PUSH
30195: LD_INT 0
30197: PUSH
30198: LD_INT 0
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: LD_INT 1
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 1
30228: PUSH
30229: LD_INT 1
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 0
30238: PUSH
30239: LD_INT 1
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: LD_INT 0
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 1
30263: NEG
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 1
30271: NEG
30272: PUSH
30273: LD_INT 2
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 0
30283: PUSH
30284: LD_INT 2
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 2
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 2
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: LD_INT 2
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: LD_INT 2
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: LD_INT 2
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 1
30355: NEG
30356: PUSH
30357: LD_INT 1
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 2
30366: NEG
30367: PUSH
30368: LD_INT 0
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 2
30377: NEG
30378: PUSH
30379: LD_INT 1
30381: NEG
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 2
30389: NEG
30390: PUSH
30391: LD_INT 2
30393: NEG
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30420: LD_ADDR_VAR 0 18
30424: PUSH
30425: LD_INT 0
30427: PUSH
30428: LD_INT 0
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: LD_INT 1
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 1
30458: PUSH
30459: LD_INT 1
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 0
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: LD_INT 0
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 1
30493: NEG
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 1
30501: NEG
30502: PUSH
30503: LD_INT 2
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 0
30513: PUSH
30514: LD_INT 2
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 1
30524: PUSH
30525: LD_INT 1
30527: NEG
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 2
30535: PUSH
30536: LD_INT 0
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 2
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 2
30555: PUSH
30556: LD_INT 2
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: PUSH
30566: LD_INT 2
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 2
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: LD_INT 1
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: NEG
30597: PUSH
30598: LD_INT 0
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: LD_INT 1
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: NEG
30620: PUSH
30621: LD_INT 2
30623: NEG
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30650: LD_ADDR_VAR 0 19
30654: PUSH
30655: LD_INT 0
30657: PUSH
30658: LD_INT 0
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 0
30667: PUSH
30668: LD_INT 1
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: LD_INT 0
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 1
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: PUSH
30696: LD_INT 0
30698: PUSH
30699: LD_INT 1
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 1
30719: NEG
30720: PUSH
30721: LD_INT 1
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 1
30731: NEG
30732: PUSH
30733: LD_INT 2
30735: NEG
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 0
30743: PUSH
30744: LD_INT 2
30746: NEG
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: LD_INT 1
30757: NEG
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 2
30765: PUSH
30766: LD_INT 0
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 2
30785: PUSH
30786: LD_INT 2
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 1
30795: PUSH
30796: LD_INT 2
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: LD_INT 2
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: NEG
30816: PUSH
30817: LD_INT 1
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: NEG
30827: PUSH
30828: LD_INT 0
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 2
30837: NEG
30838: PUSH
30839: LD_INT 1
30841: NEG
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 2
30849: NEG
30850: PUSH
30851: LD_INT 2
30853: NEG
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30880: LD_ADDR_VAR 0 20
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 0
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: LD_INT 1
30900: NEG
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: PUSH
30909: LD_INT 0
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 0
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: LD_INT 0
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: LD_INT 1
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 1
30961: NEG
30962: PUSH
30963: LD_INT 2
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 0
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 1
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 2
30995: PUSH
30996: LD_INT 0
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 2
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 2
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 2
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 2
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 1
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 2
31056: NEG
31057: PUSH
31058: LD_INT 0
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 2
31067: NEG
31068: PUSH
31069: LD_INT 1
31071: NEG
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 2
31079: NEG
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31110: LD_ADDR_VAR 0 21
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: LD_INT 0
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 0
31127: PUSH
31128: LD_INT 1
31130: NEG
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: LD_INT 0
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 1
31148: PUSH
31149: LD_INT 1
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: LD_INT 1
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 1
31179: NEG
31180: PUSH
31181: LD_INT 1
31183: NEG
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 1
31191: NEG
31192: PUSH
31193: LD_INT 2
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 0
31203: PUSH
31204: LD_INT 2
31206: NEG
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: LD_INT 1
31217: NEG
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 2
31225: PUSH
31226: LD_INT 0
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 2
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 2
31245: PUSH
31246: LD_INT 2
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 1
31255: PUSH
31256: LD_INT 2
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: LD_INT 2
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 1
31275: NEG
31276: PUSH
31277: LD_INT 1
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 2
31286: NEG
31287: PUSH
31288: LD_INT 0
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 2
31297: NEG
31298: PUSH
31299: LD_INT 1
31301: NEG
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 2
31309: NEG
31310: PUSH
31311: LD_INT 2
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31340: LD_ADDR_VAR 0 22
31344: PUSH
31345: LD_INT 0
31347: PUSH
31348: LD_INT 0
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 0
31357: PUSH
31358: LD_INT 1
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: LD_INT 0
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: PUSH
31379: LD_INT 1
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 0
31388: PUSH
31389: LD_INT 1
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: NEG
31410: PUSH
31411: LD_INT 1
31413: NEG
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: NEG
31422: PUSH
31423: LD_INT 2
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: LD_INT 2
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 1
31444: PUSH
31445: LD_INT 1
31447: NEG
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 2
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 2
31465: PUSH
31466: LD_INT 1
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 2
31475: PUSH
31476: LD_INT 2
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 2
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 2
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: NEG
31506: PUSH
31507: LD_INT 1
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: LD_INT 0
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: NEG
31528: PUSH
31529: LD_INT 1
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: NEG
31540: PUSH
31541: LD_INT 2
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: EMPTY
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31570: LD_ADDR_VAR 0 23
31574: PUSH
31575: LD_INT 0
31577: PUSH
31578: LD_INT 0
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 0
31587: PUSH
31588: LD_INT 1
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: LD_INT 0
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: LD_INT 1
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 0
31618: PUSH
31619: LD_INT 1
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 1
31639: NEG
31640: PUSH
31641: LD_INT 1
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: NEG
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: LD_INT 1
31677: NEG
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: LD_INT 0
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: LD_INT 1
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 2
31705: PUSH
31706: LD_INT 2
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: PUSH
31716: LD_INT 2
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: LD_INT 2
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 1
31735: NEG
31736: PUSH
31737: LD_INT 1
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 2
31757: NEG
31758: PUSH
31759: LD_INT 1
31761: NEG
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 2
31769: NEG
31770: PUSH
31771: LD_INT 2
31773: NEG
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 2
31781: NEG
31782: PUSH
31783: LD_INT 3
31785: NEG
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: NEG
31794: PUSH
31795: LD_INT 3
31797: NEG
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: LD_INT 2
31808: NEG
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 2
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: LIST
31849: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31850: LD_ADDR_VAR 0 24
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: LD_INT 0
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 0
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 1
31878: PUSH
31879: LD_INT 0
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 1
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 0
31898: PUSH
31899: LD_INT 1
31901: PUSH
31902: EMPTY
31903: LIST
31904: LIST
31905: PUSH
31906: LD_INT 1
31908: NEG
31909: PUSH
31910: LD_INT 0
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: LD_INT 1
31923: NEG
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 1
31931: NEG
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 0
31943: PUSH
31944: LD_INT 2
31946: NEG
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: PUSH
31955: LD_INT 1
31957: NEG
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: LD_INT 2
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 2
31985: PUSH
31986: LD_INT 2
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: LD_INT 2
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: LD_INT 2
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: LD_INT 1
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 2
32026: NEG
32027: PUSH
32028: LD_INT 0
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 2
32037: NEG
32038: PUSH
32039: LD_INT 1
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 2
32049: NEG
32050: PUSH
32051: LD_INT 2
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: LD_INT 1
32061: PUSH
32062: LD_INT 2
32064: NEG
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: LD_INT 1
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 3
32083: PUSH
32084: LD_INT 1
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 3
32093: PUSH
32094: LD_INT 2
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32126: LD_ADDR_VAR 0 25
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: LD_INT 1
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 0
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 1
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: LD_INT 1
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: NEG
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: LD_INT 1
32199: NEG
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: NEG
32208: PUSH
32209: LD_INT 2
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: LD_INT 2
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: LD_INT 1
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: LD_INT 0
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: LD_INT 1
32317: NEG
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: NEG
32326: PUSH
32327: LD_INT 2
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 3
32337: PUSH
32338: LD_INT 1
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 3
32347: PUSH
32348: LD_INT 2
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 2
32357: PUSH
32358: LD_INT 3
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: PUSH
32368: LD_INT 3
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32400: LD_ADDR_VAR 0 26
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: LD_INT 0
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 0
32448: PUSH
32449: LD_INT 1
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: LD_INT 0
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 1
32469: NEG
32470: PUSH
32471: LD_INT 1
32473: NEG
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 2
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: LD_INT 1
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: LD_INT 2
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 1
32545: PUSH
32546: LD_INT 2
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: LD_INT 2
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: LD_INT 1
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: NEG
32577: PUSH
32578: LD_INT 0
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 2
32587: NEG
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 2
32599: NEG
32600: PUSH
32601: LD_INT 2
32603: NEG
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 2
32611: PUSH
32612: LD_INT 3
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: LD_INT 3
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: PUSH
32633: LD_INT 2
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: LD_INT 1
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32676: LD_ADDR_VAR 0 27
32680: PUSH
32681: LD_INT 0
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 0
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: LD_INT 1
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 0
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: NEG
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: NEG
32853: PUSH
32854: LD_INT 0
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 2
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 3
32909: NEG
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 3
32921: NEG
32922: PUSH
32923: LD_INT 2
32925: NEG
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32956: LD_ADDR_VAR 0 28
32960: PUSH
32961: LD_INT 0
32963: PUSH
32964: LD_INT 0
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 0
32973: PUSH
32974: LD_INT 1
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 1
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: LD_INT 1
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: PUSH
33002: LD_INT 0
33004: PUSH
33005: LD_INT 1
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: LD_INT 0
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: LD_INT 1
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 2
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 0
33049: PUSH
33050: LD_INT 2
33052: NEG
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: PUSH
33072: LD_INT 0
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 2
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: LD_INT 2
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 1
33101: PUSH
33102: LD_INT 2
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: LD_INT 2
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 1
33121: NEG
33122: PUSH
33123: LD_INT 1
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 2
33132: NEG
33133: PUSH
33134: LD_INT 0
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 2
33143: NEG
33144: PUSH
33145: LD_INT 1
33147: NEG
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: LD_INT 2
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 2
33167: NEG
33168: PUSH
33169: LD_INT 3
33171: NEG
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 1
33179: NEG
33180: PUSH
33181: LD_INT 3
33183: NEG
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 3
33191: NEG
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 3
33203: NEG
33204: PUSH
33205: LD_INT 2
33207: NEG
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33238: LD_ADDR_VAR 0 29
33242: PUSH
33243: LD_INT 0
33245: PUSH
33246: LD_INT 0
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 0
33255: PUSH
33256: LD_INT 1
33258: NEG
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 1
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 1
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: LD_INT 1
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 1
33296: NEG
33297: PUSH
33298: LD_INT 0
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 1
33307: NEG
33308: PUSH
33309: LD_INT 1
33311: NEG
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: LD_INT 2
33323: NEG
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 0
33331: PUSH
33332: LD_INT 2
33334: NEG
33335: PUSH
33336: EMPTY
33337: LIST
33338: LIST
33339: PUSH
33340: LD_INT 1
33342: PUSH
33343: LD_INT 1
33345: NEG
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 2
33353: PUSH
33354: LD_INT 0
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 2
33363: PUSH
33364: LD_INT 1
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: LD_INT 2
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: PUSH
33381: LD_INT 0
33383: PUSH
33384: LD_INT 2
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 1
33393: NEG
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 2
33404: NEG
33405: PUSH
33406: LD_INT 1
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 2
33416: NEG
33417: PUSH
33418: LD_INT 2
33420: NEG
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 2
33428: NEG
33429: PUSH
33430: LD_INT 3
33432: NEG
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 3
33451: PUSH
33452: LD_INT 1
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 3
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 1
33471: NEG
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 3
33482: NEG
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33517: LD_ADDR_VAR 0 30
33521: PUSH
33522: LD_INT 0
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 1
33537: NEG
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 1
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: LD_INT 0
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 1
33586: NEG
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: LD_INT 1
33598: NEG
33599: PUSH
33600: LD_INT 2
33602: NEG
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 2
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 2
33632: PUSH
33633: LD_INT 0
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: PUSH
33643: LD_INT 1
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 2
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: PUSH
33663: LD_INT 2
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 2
33683: NEG
33684: PUSH
33685: LD_INT 0
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 2
33694: NEG
33695: PUSH
33696: LD_INT 1
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: NEG
33707: PUSH
33708: LD_INT 3
33710: NEG
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 1
33718: PUSH
33719: LD_INT 2
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 3
33729: PUSH
33730: LD_INT 2
33732: PUSH
33733: EMPTY
33734: LIST
33735: LIST
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: LD_INT 3
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: NEG
33750: PUSH
33751: LD_INT 1
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 3
33760: NEG
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33795: LD_ADDR_VAR 0 31
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: LD_INT 0
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 0
33812: PUSH
33813: LD_INT 1
33815: NEG
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 1
33823: PUSH
33824: LD_INT 0
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: LD_INT 1
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 0
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: NEG
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: LD_INT 1
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: LD_INT 2
33880: NEG
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 2
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 2
33909: PUSH
33910: LD_INT 1
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 2
33919: PUSH
33920: LD_INT 2
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 2
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 0
33939: PUSH
33940: LD_INT 2
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: NEG
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 2
33960: NEG
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: NEG
33973: PUSH
33974: LD_INT 2
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 2
33984: NEG
33985: PUSH
33986: LD_INT 3
33988: NEG
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 2
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 3
34007: PUSH
34008: LD_INT 1
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: LD_INT 3
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: LD_INT 2
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 3
34038: NEG
34039: PUSH
34040: LD_INT 2
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34073: LD_ADDR_VAR 0 32
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: PUSH
34112: LD_INT 1
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 0
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 1
34131: NEG
34132: PUSH
34133: LD_INT 0
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 1
34142: NEG
34143: PUSH
34144: LD_INT 1
34146: NEG
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: LD_INT 2
34158: NEG
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 0
34166: PUSH
34167: LD_INT 2
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: LD_INT 1
34180: NEG
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: LD_INT 2
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: LD_INT 2
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: LD_INT 2
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: LD_INT 1
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 2
34239: NEG
34240: PUSH
34241: LD_INT 0
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 2
34250: NEG
34251: PUSH
34252: LD_INT 1
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 1
34262: NEG
34263: PUSH
34264: LD_INT 3
34266: NEG
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 1
34274: PUSH
34275: LD_INT 2
34277: NEG
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 3
34285: PUSH
34286: LD_INT 2
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: LD_INT 3
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 2
34305: NEG
34306: PUSH
34307: LD_INT 1
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PUSH
34314: LD_INT 3
34316: NEG
34317: PUSH
34318: LD_INT 1
34320: NEG
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34351: LD_ADDR_VAR 0 33
34355: PUSH
34356: LD_INT 0
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 0
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: PUSH
34380: LD_INT 0
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 0
34399: PUSH
34400: LD_INT 1
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: NEG
34410: PUSH
34411: LD_INT 0
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 1
34432: NEG
34433: PUSH
34434: LD_INT 2
34436: NEG
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 1
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 2
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 2
34465: PUSH
34466: LD_INT 1
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: LD_INT 2
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 2
34529: NEG
34530: PUSH
34531: LD_INT 2
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 2
34541: NEG
34542: PUSH
34543: LD_INT 3
34545: NEG
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 2
34553: PUSH
34554: LD_INT 1
34556: NEG
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 3
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 1
34574: PUSH
34575: LD_INT 3
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 3
34595: NEG
34596: PUSH
34597: LD_INT 2
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34630: LD_ADDR_VAR 0 34
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: LD_INT 1
34650: NEG
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 1
34658: PUSH
34659: LD_INT 0
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: LD_INT 1
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 1
34688: NEG
34689: PUSH
34690: LD_INT 0
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: LD_INT 1
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: NEG
34712: PUSH
34713: LD_INT 2
34715: NEG
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 0
34723: PUSH
34724: LD_INT 2
34726: NEG
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 1
34734: PUSH
34735: LD_INT 1
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 2
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 2
34755: PUSH
34756: LD_INT 2
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 2
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 2
34786: NEG
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 2
34797: NEG
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 2
34809: NEG
34810: PUSH
34811: LD_INT 2
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: NEG
34822: PUSH
34823: LD_INT 3
34825: NEG
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 1
34833: PUSH
34834: LD_INT 2
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 3
34844: PUSH
34845: LD_INT 2
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: PUSH
34855: LD_INT 3
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 2
34864: NEG
34865: PUSH
34866: LD_INT 1
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 3
34875: NEG
34876: PUSH
34877: LD_INT 1
34879: NEG
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34910: LD_ADDR_VAR 0 35
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 1
34938: PUSH
34939: LD_INT 0
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: LD_INT 1
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: LD_INT 1
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 1
34968: NEG
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: LD_INT 1
34983: NEG
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: LD_INT 1
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 1
35005: NEG
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35022: LD_ADDR_VAR 0 36
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 0
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: LD_INT 0
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 1
35060: PUSH
35061: LD_INT 1
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 0
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: LD_INT 0
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: LD_INT 1
35095: NEG
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: NEG
35104: PUSH
35105: LD_INT 2
35107: NEG
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 1
35115: PUSH
35116: LD_INT 2
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35134: LD_ADDR_VAR 0 37
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 0
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: PUSH
35163: LD_INT 0
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 1
35172: PUSH
35173: LD_INT 1
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 1
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: LD_INT 0
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: NEG
35204: PUSH
35205: LD_INT 1
35207: NEG
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 1
35215: PUSH
35216: LD_INT 1
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 1
35226: NEG
35227: PUSH
35228: LD_INT 1
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35246: LD_ADDR_VAR 0 38
35250: PUSH
35251: LD_INT 0
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 1
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 1
35304: NEG
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 1
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 2
35337: NEG
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35358: LD_ADDR_VAR 0 39
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: LD_INT 0
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 0
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 1
35386: PUSH
35387: LD_INT 0
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 1
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 1
35416: NEG
35417: PUSH
35418: LD_INT 0
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: NEG
35428: PUSH
35429: LD_INT 1
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: LD_INT 2
35443: NEG
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 1
35451: PUSH
35452: LD_INT 2
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35470: LD_ADDR_VAR 0 40
35474: PUSH
35475: LD_INT 0
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 0
35487: PUSH
35488: LD_INT 1
35490: NEG
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 1
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: EMPTY
35503: LIST
35504: LIST
35505: PUSH
35506: LD_INT 1
35508: PUSH
35509: LD_INT 1
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: LD_INT 1
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: NEG
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 1
35562: NEG
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35582: LD_ADDR_VAR 0 41
35586: PUSH
35587: LD_INT 0
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 0
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: PUSH
35621: LD_INT 1
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 0
35630: PUSH
35631: LD_INT 1
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 1
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: LD_INT 2
35667: NEG
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 1
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: PUSH
35697: LD_INT 1
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 2
35706: PUSH
35707: LD_INT 2
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 1
35716: PUSH
35717: LD_INT 2
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 2
35737: NEG
35738: PUSH
35739: LD_INT 0
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 2
35748: NEG
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 2
35760: NEG
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 2
35772: NEG
35773: PUSH
35774: LD_INT 3
35776: NEG
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 2
35784: PUSH
35785: LD_INT 1
35787: NEG
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 3
35795: PUSH
35796: LD_INT 0
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 3
35805: PUSH
35806: LD_INT 1
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 3
35815: PUSH
35816: LD_INT 2
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 3
35825: PUSH
35826: LD_INT 3
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 2
35835: PUSH
35836: LD_INT 3
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 2
35845: NEG
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 3
35856: NEG
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 3
35867: NEG
35868: PUSH
35869: LD_INT 1
35871: NEG
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 3
35879: NEG
35880: PUSH
35881: LD_INT 2
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 3
35891: NEG
35892: PUSH
35893: LD_INT 3
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35932: LD_ADDR_VAR 0 42
35936: PUSH
35937: LD_INT 0
35939: PUSH
35940: LD_INT 0
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 1
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: LD_INT 1
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 0
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: NEG
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 1
36001: NEG
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: LD_INT 2
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: LD_INT 2
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: LD_INT 1
36039: NEG
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: LD_INT 1
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 2
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: LD_INT 2
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 0
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 2
36098: NEG
36099: PUSH
36100: LD_INT 1
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: NEG
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: LD_INT 2
36122: NEG
36123: PUSH
36124: LD_INT 3
36126: NEG
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 1
36134: NEG
36135: PUSH
36136: LD_INT 3
36138: NEG
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 0
36146: PUSH
36147: LD_INT 3
36149: NEG
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: LD_INT 2
36160: NEG
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 3
36168: PUSH
36169: LD_INT 2
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 3
36178: PUSH
36179: LD_INT 3
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 3
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: PUSH
36199: LD_INT 3
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 3
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 1
36218: NEG
36219: PUSH
36220: LD_INT 2
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 3
36229: NEG
36230: PUSH
36231: LD_INT 2
36233: NEG
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 3
36241: NEG
36242: PUSH
36243: LD_INT 3
36245: NEG
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: LIST
36281: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36282: LD_ADDR_VAR 0 43
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: LD_INT 0
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: LD_INT 1
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 0
36330: PUSH
36331: LD_INT 1
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: LD_INT 1
36340: NEG
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 1
36355: NEG
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: LD_INT 2
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 2
36397: PUSH
36398: LD_INT 0
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: LD_INT 2
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: LD_INT 2
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 2
36448: NEG
36449: PUSH
36450: LD_INT 0
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 2
36459: NEG
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 3
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: LD_INT 3
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 2
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 3
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 3
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: LD_INT 3
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 3
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 1
36556: NEG
36557: PUSH
36558: LD_INT 2
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 2
36567: NEG
36568: PUSH
36569: LD_INT 1
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 3
36578: NEG
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 3
36589: NEG
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: EMPTY
36596: LIST
36597: LIST
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36630: LD_ADDR_VAR 0 44
36634: PUSH
36635: LD_INT 0
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 0
36647: PUSH
36648: LD_INT 1
36650: NEG
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: LD_INT 0
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: LD_INT 1
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: LD_INT 1
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: LD_INT 0
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 1
36699: NEG
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: LD_INT 2
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 2
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 1
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 2
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: LD_INT 3
36824: NEG
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 2
36832: PUSH
36833: LD_INT 1
36835: NEG
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: LD_INT 0
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: LD_INT 1
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 3
36863: PUSH
36864: LD_INT 2
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 3
36873: PUSH
36874: LD_INT 3
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 2
36883: PUSH
36884: LD_INT 3
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 3
36904: NEG
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 3
36927: NEG
36928: PUSH
36929: LD_INT 2
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: LD_INT 3
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36980: LD_ADDR_VAR 0 45
36984: PUSH
36985: LD_INT 0
36987: PUSH
36988: LD_INT 0
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 0
36997: PUSH
36998: LD_INT 1
37000: NEG
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 1
37008: PUSH
37009: LD_INT 0
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: LD_INT 1
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: LD_INT 1
37053: NEG
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: LD_INT 2
37065: NEG
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: LD_INT 2
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 1
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: LD_INT 1
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 2
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 0
37125: PUSH
37126: LD_INT 2
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: LD_INT 1
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 2
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: NEG
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 2
37170: NEG
37171: PUSH
37172: LD_INT 3
37174: NEG
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 1
37182: NEG
37183: PUSH
37184: LD_INT 3
37186: NEG
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 0
37194: PUSH
37195: LD_INT 3
37197: NEG
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 1
37205: PUSH
37206: LD_INT 2
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 3
37216: PUSH
37217: LD_INT 2
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 3
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 2
37236: PUSH
37237: LD_INT 3
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: LD_INT 3
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 3
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 3
37277: NEG
37278: PUSH
37279: LD_INT 2
37281: NEG
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: LD_INT 3
37293: NEG
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37330: LD_ADDR_VAR 0 46
37334: PUSH
37335: LD_INT 0
37337: PUSH
37338: LD_INT 0
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 0
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: LD_INT 0
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: LD_INT 1
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: LD_INT 1
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 0
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: NEG
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: LD_INT 2
37415: NEG
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 0
37423: PUSH
37424: LD_INT 2
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: LD_INT 1
37437: NEG
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 2
37445: PUSH
37446: LD_INT 0
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 1
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: LD_INT 2
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 2
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 1
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 2
37496: NEG
37497: PUSH
37498: LD_INT 0
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 2
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 3
37564: PUSH
37565: LD_INT 0
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 3
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: PUSH
37585: LD_INT 3
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 3
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 1
37604: NEG
37605: PUSH
37606: LD_INT 2
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: NEG
37616: PUSH
37617: LD_INT 1
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 3
37626: NEG
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 3
37637: NEG
37638: PUSH
37639: LD_INT 1
37641: NEG
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37678: LD_ADDR_VAR 0 47
37682: PUSH
37683: LD_INT 0
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: LD_INT 1
37698: NEG
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 1
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 1
37716: PUSH
37717: LD_INT 1
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: LD_INT 0
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 1
37747: NEG
37748: PUSH
37749: LD_INT 1
37751: NEG
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 1
37759: NEG
37760: PUSH
37761: LD_INT 2
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 0
37771: PUSH
37772: LD_INT 2
37774: NEG
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 1
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 2
37793: NEG
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 2
37805: NEG
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: LIST
37827: LIST
37828: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37829: LD_ADDR_VAR 0 48
37833: PUSH
37834: LD_INT 0
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 0
37846: PUSH
37847: LD_INT 1
37849: NEG
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 1
37867: PUSH
37868: LD_INT 1
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 0
37877: PUSH
37878: LD_INT 1
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 1
37887: NEG
37888: PUSH
37889: LD_INT 0
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: LD_INT 1
37902: NEG
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: PUSH
37908: LD_INT 1
37910: NEG
37911: PUSH
37912: LD_INT 2
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 0
37922: PUSH
37923: LD_INT 2
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 1
37933: PUSH
37934: LD_INT 1
37936: NEG
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 2
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 2
37954: PUSH
37955: LD_INT 1
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37976: LD_ADDR_VAR 0 49
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: LD_INT 0
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 0
37993: PUSH
37994: LD_INT 1
37996: NEG
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 1
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 1
38014: PUSH
38015: LD_INT 1
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 0
38024: PUSH
38025: LD_INT 1
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 1
38034: NEG
38035: PUSH
38036: LD_INT 0
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: LD_INT 1
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 1
38057: PUSH
38058: LD_INT 1
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 2
38068: PUSH
38069: LD_INT 0
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 2
38078: PUSH
38079: LD_INT 1
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 2
38088: PUSH
38089: LD_INT 2
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 1
38098: PUSH
38099: LD_INT 2
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38120: LD_ADDR_VAR 0 50
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: LD_INT 1
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 1
38158: PUSH
38159: LD_INT 1
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 2
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 2
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: PUSH
38222: LD_INT 2
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: LD_INT 2
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38264: LD_ADDR_VAR 0 51
38268: PUSH
38269: LD_INT 0
38271: PUSH
38272: LD_INT 0
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 0
38281: PUSH
38282: LD_INT 1
38284: NEG
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 1
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 0
38312: PUSH
38313: LD_INT 1
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 1
38322: NEG
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: LD_INT 1
38337: NEG
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 1
38345: PUSH
38346: LD_INT 2
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 0
38355: PUSH
38356: LD_INT 2
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: NEG
38366: PUSH
38367: LD_INT 1
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 2
38376: NEG
38377: PUSH
38378: LD_INT 0
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 2
38387: NEG
38388: PUSH
38389: LD_INT 1
38391: NEG
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38411: LD_ADDR_VAR 0 52
38415: PUSH
38416: LD_INT 0
38418: PUSH
38419: LD_INT 0
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: LD_INT 1
38431: NEG
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 1
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 1
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 0
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 1
38469: NEG
38470: PUSH
38471: LD_INT 0
38473: PUSH
38474: EMPTY
38475: LIST
38476: LIST
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: LD_INT 1
38484: NEG
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: NEG
38493: PUSH
38494: LD_INT 2
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: NEG
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 2
38515: NEG
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 2
38526: NEG
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 2
38538: NEG
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38562: LD_ADDR_VAR 0 53
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: LD_INT 0
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 0
38579: PUSH
38580: LD_INT 1
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 1
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: LD_INT 1
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: PUSH
38608: LD_INT 0
38610: PUSH
38611: LD_INT 1
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 1
38620: NEG
38621: PUSH
38622: LD_INT 0
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 1
38631: NEG
38632: PUSH
38633: LD_INT 1
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 1
38643: NEG
38644: PUSH
38645: LD_INT 2
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: LD_INT 2
38658: NEG
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: LD_INT 1
38669: NEG
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 2
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 2
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 2
38697: PUSH
38698: LD_INT 2
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 1
38707: PUSH
38708: LD_INT 2
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 1
38727: NEG
38728: PUSH
38729: LD_INT 1
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 2
38738: NEG
38739: PUSH
38740: LD_INT 0
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 1
38753: NEG
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 2
38761: NEG
38762: PUSH
38763: LD_INT 2
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: LIST
38789: LIST
38790: LIST
38791: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38792: LD_ADDR_VAR 0 54
38796: PUSH
38797: LD_INT 0
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 0
38809: PUSH
38810: LD_INT 1
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: LD_INT 0
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 1
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: LD_INT 0
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: LD_INT 1
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: LD_INT 2
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 0
38885: PUSH
38886: LD_INT 2
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: LD_INT 1
38899: NEG
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 2
38907: PUSH
38908: LD_INT 0
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 2
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: LD_INT 2
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 2
38968: NEG
38969: PUSH
38970: LD_INT 0
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 2
38979: NEG
38980: PUSH
38981: LD_INT 1
38983: NEG
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 2
38991: NEG
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39022: LD_ADDR_VAR 0 55
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: LD_INT 0
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 0
39039: PUSH
39040: LD_INT 1
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: LD_INT 0
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: LD_INT 1
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: LD_INT 1
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 1
39091: NEG
39092: PUSH
39093: LD_INT 1
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: LD_INT 2
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 1
39126: PUSH
39127: LD_INT 1
39129: NEG
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 2
39137: PUSH
39138: LD_INT 0
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 2
39147: PUSH
39148: LD_INT 1
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 2
39157: PUSH
39158: LD_INT 2
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: LD_INT 2
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 1
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 2
39209: NEG
39210: PUSH
39211: LD_INT 1
39213: NEG
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: NEG
39222: PUSH
39223: LD_INT 2
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39252: LD_ADDR_VAR 0 56
39256: PUSH
39257: LD_INT 0
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 0
39269: PUSH
39270: LD_INT 1
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: LD_INT 1
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 0
39300: PUSH
39301: LD_INT 1
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 1
39321: NEG
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 1
39333: NEG
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 0
39345: PUSH
39346: LD_INT 2
39348: NEG
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 1
39356: PUSH
39357: LD_INT 1
39359: NEG
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 2
39367: PUSH
39368: LD_INT 0
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 2
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 2
39387: PUSH
39388: LD_INT 2
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 1
39397: PUSH
39398: LD_INT 2
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: LD_INT 2
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: LD_INT 0
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 2
39439: NEG
39440: PUSH
39441: LD_INT 1
39443: NEG
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: LD_INT 2
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: LIST
39478: LIST
39479: LIST
39480: LIST
39481: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39482: LD_ADDR_VAR 0 57
39486: PUSH
39487: LD_INT 0
39489: PUSH
39490: LD_INT 0
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: LD_INT 1
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 1
39510: PUSH
39511: LD_INT 0
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: LD_INT 1
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: LD_INT 1
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: LD_INT 0
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 2
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 2
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 2
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 2
39617: PUSH
39618: LD_INT 2
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: LD_INT 2
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 0
39637: PUSH
39638: LD_INT 2
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 1
39647: NEG
39648: PUSH
39649: LD_INT 1
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: NEG
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: NEG
39682: PUSH
39683: LD_INT 2
39685: NEG
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39712: LD_ADDR_VAR 0 58
39716: PUSH
39717: LD_INT 0
39719: PUSH
39720: LD_INT 0
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 0
39729: PUSH
39730: LD_INT 1
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 1
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 1
39750: PUSH
39751: LD_INT 1
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: NEG
39794: PUSH
39795: LD_INT 2
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 0
39805: PUSH
39806: LD_INT 2
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 1
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 2
39827: PUSH
39828: LD_INT 0
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 1
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: LD_INT 2
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: PUSH
39858: LD_INT 2
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: LD_INT 2
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: LD_INT 1
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 2
39888: NEG
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 2
39899: NEG
39900: PUSH
39901: LD_INT 1
39903: NEG
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 2
39911: NEG
39912: PUSH
39913: LD_INT 2
39915: NEG
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39942: LD_ADDR_VAR 0 59
39946: PUSH
39947: LD_INT 0
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 0
39959: PUSH
39960: LD_INT 1
39962: NEG
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 1
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 1
39980: PUSH
39981: LD_INT 1
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 0
39990: PUSH
39991: LD_INT 1
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: LD_INT 1
40015: NEG
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40030: LD_ADDR_VAR 0 60
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: LD_INT 1
40050: NEG
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 1
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 1
40068: PUSH
40069: LD_INT 1
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: LD_INT 1
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 1
40088: NEG
40089: PUSH
40090: LD_INT 0
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 1
40099: NEG
40100: PUSH
40101: LD_INT 1
40103: NEG
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: LIST
40116: LIST
40117: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40118: LD_ADDR_VAR 0 61
40122: PUSH
40123: LD_INT 0
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 0
40135: PUSH
40136: LD_INT 1
40138: NEG
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 1
40146: PUSH
40147: LD_INT 0
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 1
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 1
40176: NEG
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 1
40187: NEG
40188: PUSH
40189: LD_INT 1
40191: NEG
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40206: LD_ADDR_VAR 0 62
40210: PUSH
40211: LD_INT 0
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: LD_INT 1
40226: NEG
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PUSH
40232: LD_INT 1
40234: PUSH
40235: LD_INT 0
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: LD_INT 1
40247: PUSH
40248: EMPTY
40249: LIST
40250: LIST
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: LD_INT 1
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: LD_INT 1
40264: NEG
40265: PUSH
40266: LD_INT 0
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 1
40275: NEG
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: LIST
40293: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40294: LD_ADDR_VAR 0 63
40298: PUSH
40299: LD_INT 0
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 0
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 1
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 1
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: NEG
40364: PUSH
40365: LD_INT 1
40367: NEG
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40382: LD_ADDR_VAR 0 64
40386: PUSH
40387: LD_INT 0
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: LD_INT 1
40402: NEG
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 1
40410: PUSH
40411: LD_INT 0
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: LD_INT 1
40420: PUSH
40421: LD_INT 1
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: LD_INT 1
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 1
40440: NEG
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 1
40451: NEG
40452: PUSH
40453: LD_INT 1
40455: NEG
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: ST_TO_ADDR
// end ; 1 :
40470: GO 46367
40472: LD_INT 1
40474: DOUBLE
40475: EQUAL
40476: IFTRUE 40480
40478: GO 43103
40480: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40481: LD_ADDR_VAR 0 11
40485: PUSH
40486: LD_INT 1
40488: NEG
40489: PUSH
40490: LD_INT 3
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 0
40500: PUSH
40501: LD_INT 3
40503: NEG
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: PUSH
40512: LD_INT 2
40514: NEG
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: LIST
40524: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40525: LD_ADDR_VAR 0 12
40529: PUSH
40530: LD_INT 2
40532: PUSH
40533: LD_INT 1
40535: NEG
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: LD_INT 3
40543: PUSH
40544: LD_INT 0
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: LIST
40565: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40566: LD_ADDR_VAR 0 13
40570: PUSH
40571: LD_INT 3
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 3
40583: PUSH
40584: LD_INT 3
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 2
40593: PUSH
40594: LD_INT 3
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: LIST
40605: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40606: LD_ADDR_VAR 0 14
40610: PUSH
40611: LD_INT 1
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: LD_INT 3
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 1
40633: NEG
40634: PUSH
40635: LD_INT 2
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: LIST
40646: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40647: LD_ADDR_VAR 0 15
40651: PUSH
40652: LD_INT 2
40654: NEG
40655: PUSH
40656: LD_INT 1
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 3
40665: NEG
40666: PUSH
40667: LD_INT 0
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: LD_INT 3
40676: NEG
40677: PUSH
40678: LD_INT 1
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: LIST
40690: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40691: LD_ADDR_VAR 0 16
40695: PUSH
40696: LD_INT 2
40698: NEG
40699: PUSH
40700: LD_INT 3
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 3
40710: NEG
40711: PUSH
40712: LD_INT 2
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 3
40722: NEG
40723: PUSH
40724: LD_INT 3
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: LIST
40736: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40737: LD_ADDR_VAR 0 17
40741: PUSH
40742: LD_INT 1
40744: NEG
40745: PUSH
40746: LD_INT 3
40748: NEG
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: LD_INT 3
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 1
40767: PUSH
40768: LD_INT 2
40770: NEG
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: LIST
40780: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40781: LD_ADDR_VAR 0 18
40785: PUSH
40786: LD_INT 2
40788: PUSH
40789: LD_INT 1
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 3
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: LIST
40821: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40822: LD_ADDR_VAR 0 19
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: LD_INT 2
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 3
40839: PUSH
40840: LD_INT 3
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: LD_INT 3
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40862: LD_ADDR_VAR 0 20
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 3
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 0
40879: PUSH
40880: LD_INT 3
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 1
40889: NEG
40890: PUSH
40891: LD_INT 2
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40903: LD_ADDR_VAR 0 21
40907: PUSH
40908: LD_INT 2
40910: NEG
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 3
40921: NEG
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 3
40932: NEG
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: LIST
40946: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40947: LD_ADDR_VAR 0 22
40951: PUSH
40952: LD_INT 2
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 3
40966: NEG
40967: PUSH
40968: LD_INT 2
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: LD_INT 3
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: LIST
40992: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40993: LD_ADDR_VAR 0 23
40997: PUSH
40998: LD_INT 0
41000: PUSH
41001: LD_INT 3
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 1
41011: NEG
41012: PUSH
41013: LD_INT 4
41015: NEG
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: LD_INT 3
41026: NEG
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: LIST
41036: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41037: LD_ADDR_VAR 0 24
41041: PUSH
41042: LD_INT 3
41044: PUSH
41045: LD_INT 0
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 3
41054: PUSH
41055: LD_INT 1
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 4
41065: PUSH
41066: LD_INT 1
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: LIST
41077: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41078: LD_ADDR_VAR 0 25
41082: PUSH
41083: LD_INT 3
41085: PUSH
41086: LD_INT 3
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 4
41095: PUSH
41096: LD_INT 3
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 3
41105: PUSH
41106: LD_INT 4
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: LIST
41117: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41118: LD_ADDR_VAR 0 26
41122: PUSH
41123: LD_INT 0
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: LD_INT 4
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 1
41145: NEG
41146: PUSH
41147: LD_INT 3
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41159: LD_ADDR_VAR 0 27
41163: PUSH
41164: LD_INT 3
41166: NEG
41167: PUSH
41168: LD_INT 0
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 3
41177: NEG
41178: PUSH
41179: LD_INT 1
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: NEG
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: LIST
41202: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41203: LD_ADDR_VAR 0 28
41207: PUSH
41208: LD_INT 3
41210: NEG
41211: PUSH
41212: LD_INT 3
41214: NEG
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 3
41222: NEG
41223: PUSH
41224: LD_INT 4
41226: NEG
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 4
41234: NEG
41235: PUSH
41236: LD_INT 3
41238: NEG
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: LIST
41248: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41249: LD_ADDR_VAR 0 29
41253: PUSH
41254: LD_INT 1
41256: NEG
41257: PUSH
41258: LD_INT 3
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 0
41268: PUSH
41269: LD_INT 3
41271: NEG
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 1
41279: PUSH
41280: LD_INT 2
41282: NEG
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 1
41290: NEG
41291: PUSH
41292: LD_INT 4
41294: NEG
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: LD_INT 4
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 1
41313: PUSH
41314: LD_INT 3
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: LD_INT 5
41328: NEG
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 0
41336: PUSH
41337: LD_INT 5
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: LD_INT 4
41350: NEG
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 1
41358: NEG
41359: PUSH
41360: LD_INT 6
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: LD_INT 6
41373: NEG
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 1
41381: PUSH
41382: LD_INT 5
41384: NEG
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41404: LD_ADDR_VAR 0 30
41408: PUSH
41409: LD_INT 2
41411: PUSH
41412: LD_INT 1
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: LD_INT 0
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 3
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 3
41442: PUSH
41443: LD_INT 1
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 4
41453: PUSH
41454: LD_INT 0
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 4
41463: PUSH
41464: LD_INT 1
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 4
41473: PUSH
41474: LD_INT 1
41476: NEG
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PUSH
41482: LD_INT 5
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 5
41494: PUSH
41495: LD_INT 1
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 5
41504: PUSH
41505: LD_INT 1
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 6
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 6
41525: PUSH
41526: LD_INT 1
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41547: LD_ADDR_VAR 0 31
41551: PUSH
41552: LD_INT 3
41554: PUSH
41555: LD_INT 2
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 3
41564: PUSH
41565: LD_INT 3
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: LD_INT 2
41574: PUSH
41575: LD_INT 3
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 4
41584: PUSH
41585: LD_INT 3
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 4
41594: PUSH
41595: LD_INT 4
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 3
41604: PUSH
41605: LD_INT 4
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: PUSH
41612: LD_INT 5
41614: PUSH
41615: LD_INT 4
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: PUSH
41625: LD_INT 5
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 4
41634: PUSH
41635: LD_INT 5
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 6
41644: PUSH
41645: LD_INT 5
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 6
41654: PUSH
41655: LD_INT 6
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 5
41664: PUSH
41665: LD_INT 6
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41686: LD_ADDR_VAR 0 32
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: LD_INT 3
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 0
41703: PUSH
41704: LD_INT 3
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 2
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 1
41724: PUSH
41725: LD_INT 4
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 0
41734: PUSH
41735: LD_INT 4
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 1
41744: NEG
41745: PUSH
41746: LD_INT 3
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 1
41755: PUSH
41756: LD_INT 5
41758: PUSH
41759: EMPTY
41760: LIST
41761: LIST
41762: PUSH
41763: LD_INT 0
41765: PUSH
41766: LD_INT 5
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 1
41775: NEG
41776: PUSH
41777: LD_INT 4
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 1
41786: PUSH
41787: LD_INT 6
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 0
41796: PUSH
41797: LD_INT 6
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 1
41806: NEG
41807: PUSH
41808: LD_INT 5
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41829: LD_ADDR_VAR 0 33
41833: PUSH
41834: LD_INT 2
41836: NEG
41837: PUSH
41838: LD_INT 1
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 3
41847: NEG
41848: PUSH
41849: LD_INT 0
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 3
41858: NEG
41859: PUSH
41860: LD_INT 1
41862: NEG
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 3
41870: NEG
41871: PUSH
41872: LD_INT 1
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 4
41881: NEG
41882: PUSH
41883: LD_INT 0
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 4
41892: NEG
41893: PUSH
41894: LD_INT 1
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 4
41904: NEG
41905: PUSH
41906: LD_INT 1
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 5
41915: NEG
41916: PUSH
41917: LD_INT 0
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: LD_INT 5
41926: NEG
41927: PUSH
41928: LD_INT 1
41930: NEG
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 5
41938: NEG
41939: PUSH
41940: LD_INT 1
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 6
41949: NEG
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 6
41960: NEG
41961: PUSH
41962: LD_INT 1
41964: NEG
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: LIST
41974: LIST
41975: LIST
41976: LIST
41977: LIST
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: LIST
41983: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41984: LD_ADDR_VAR 0 34
41988: PUSH
41989: LD_INT 2
41991: NEG
41992: PUSH
41993: LD_INT 3
41995: NEG
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 3
42003: NEG
42004: PUSH
42005: LD_INT 2
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: LD_INT 3
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: NEG
42028: PUSH
42029: LD_INT 4
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 4
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 4
42051: NEG
42052: PUSH
42053: LD_INT 4
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 4
42063: NEG
42064: PUSH
42065: LD_INT 5
42067: NEG
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 5
42075: NEG
42076: PUSH
42077: LD_INT 4
42079: NEG
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 5
42087: NEG
42088: PUSH
42089: LD_INT 5
42091: NEG
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 5
42099: NEG
42100: PUSH
42101: LD_INT 6
42103: NEG
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 6
42111: NEG
42112: PUSH
42113: LD_INT 5
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 6
42123: NEG
42124: PUSH
42125: LD_INT 6
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: LIST
42143: LIST
42144: LIST
42145: LIST
42146: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42147: LD_ADDR_VAR 0 41
42151: PUSH
42152: LD_INT 0
42154: PUSH
42155: LD_INT 2
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 1
42165: NEG
42166: PUSH
42167: LD_INT 3
42169: NEG
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 1
42177: PUSH
42178: LD_INT 2
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: LIST
42190: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42191: LD_ADDR_VAR 0 42
42195: PUSH
42196: LD_INT 2
42198: PUSH
42199: LD_INT 0
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: LD_INT 2
42208: PUSH
42209: LD_INT 1
42211: NEG
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 3
42219: PUSH
42220: LD_INT 1
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: LIST
42231: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42232: LD_ADDR_VAR 0 43
42236: PUSH
42237: LD_INT 2
42239: PUSH
42240: LD_INT 2
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 3
42249: PUSH
42250: LD_INT 2
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 2
42259: PUSH
42260: LD_INT 3
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42272: LD_ADDR_VAR 0 44
42276: PUSH
42277: LD_INT 0
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 1
42289: PUSH
42290: LD_INT 3
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 1
42299: NEG
42300: PUSH
42301: LD_INT 2
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: LIST
42312: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42313: LD_ADDR_VAR 0 45
42317: PUSH
42318: LD_INT 2
42320: NEG
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 2
42331: NEG
42332: PUSH
42333: LD_INT 1
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 3
42342: NEG
42343: PUSH
42344: LD_INT 1
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42357: LD_ADDR_VAR 0 46
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: LD_INT 2
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: LD_INT 2
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: LIST
42402: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42403: LD_ADDR_VAR 0 47
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: LD_INT 3
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 1
42422: NEG
42423: PUSH
42424: LD_INT 3
42426: NEG
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42436: LD_ADDR_VAR 0 48
42440: PUSH
42441: LD_INT 1
42443: PUSH
42444: LD_INT 2
42446: NEG
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 2
42454: PUSH
42455: LD_INT 1
42457: NEG
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42467: LD_ADDR_VAR 0 49
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: LD_INT 1
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 3
42484: PUSH
42485: LD_INT 2
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42496: LD_ADDR_VAR 0 50
42500: PUSH
42501: LD_INT 2
42503: PUSH
42504: LD_INT 3
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 1
42513: PUSH
42514: LD_INT 3
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42525: LD_ADDR_VAR 0 51
42529: PUSH
42530: LD_INT 1
42532: NEG
42533: PUSH
42534: LD_INT 2
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42556: LD_ADDR_VAR 0 52
42560: PUSH
42561: LD_INT 3
42563: NEG
42564: PUSH
42565: LD_INT 1
42567: NEG
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 3
42575: NEG
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42589: LD_ADDR_VAR 0 53
42593: PUSH
42594: LD_INT 1
42596: NEG
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 0
42608: PUSH
42609: LD_INT 3
42611: NEG
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 1
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42633: LD_ADDR_VAR 0 54
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: LD_INT 1
42643: NEG
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 3
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 3
42661: PUSH
42662: LD_INT 1
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: LIST
42673: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42674: LD_ADDR_VAR 0 55
42678: PUSH
42679: LD_INT 3
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 3
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 2
42701: PUSH
42702: LD_INT 3
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: LIST
42713: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42714: LD_ADDR_VAR 0 56
42718: PUSH
42719: LD_INT 1
42721: PUSH
42722: LD_INT 3
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 0
42731: PUSH
42732: LD_INT 3
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 1
42741: NEG
42742: PUSH
42743: LD_INT 2
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: LIST
42754: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42755: LD_ADDR_VAR 0 57
42759: PUSH
42760: LD_INT 2
42762: NEG
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: LD_INT 0
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 3
42784: NEG
42785: PUSH
42786: LD_INT 1
42788: NEG
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: LIST
42798: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42799: LD_ADDR_VAR 0 58
42803: PUSH
42804: LD_INT 2
42806: NEG
42807: PUSH
42808: LD_INT 3
42810: NEG
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 3
42818: NEG
42819: PUSH
42820: LD_INT 2
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 3
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: LIST
42844: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42845: LD_ADDR_VAR 0 59
42849: PUSH
42850: LD_INT 1
42852: NEG
42853: PUSH
42854: LD_INT 2
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: LD_INT 2
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: LD_INT 1
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: LIST
42888: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42889: LD_ADDR_VAR 0 60
42893: PUSH
42894: LD_INT 1
42896: PUSH
42897: LD_INT 1
42899: NEG
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: LD_INT 2
42907: PUSH
42908: LD_INT 0
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 2
42917: PUSH
42918: LD_INT 1
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: LIST
42929: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42930: LD_ADDR_VAR 0 61
42934: PUSH
42935: LD_INT 2
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 2
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 1
42957: PUSH
42958: LD_INT 2
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: LIST
42969: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42970: LD_ADDR_VAR 0 62
42974: PUSH
42975: LD_INT 1
42977: PUSH
42978: LD_INT 2
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 0
42987: PUSH
42988: LD_INT 2
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43011: LD_ADDR_VAR 0 63
43015: PUSH
43016: LD_INT 1
43018: NEG
43019: PUSH
43020: LD_INT 1
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 2
43029: NEG
43030: PUSH
43031: LD_INT 0
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 2
43040: NEG
43041: PUSH
43042: LD_INT 1
43044: NEG
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: LIST
43054: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43055: LD_ADDR_VAR 0 64
43059: PUSH
43060: LD_INT 1
43062: NEG
43063: PUSH
43064: LD_INT 2
43066: NEG
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: LD_INT 2
43074: NEG
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: LD_INT 2
43086: NEG
43087: PUSH
43088: LD_INT 2
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: LIST
43100: ST_TO_ADDR
// end ; 2 :
43101: GO 46367
43103: LD_INT 2
43105: DOUBLE
43106: EQUAL
43107: IFTRUE 43111
43109: GO 46366
43111: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43112: LD_ADDR_VAR 0 29
43116: PUSH
43117: LD_INT 4
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 4
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 5
43140: PUSH
43141: LD_INT 0
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: LD_INT 5
43150: PUSH
43151: LD_INT 1
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 4
43160: PUSH
43161: LD_INT 1
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 3
43170: PUSH
43171: LD_INT 0
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 3
43180: PUSH
43181: LD_INT 1
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 3
43191: PUSH
43192: LD_INT 2
43194: NEG
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 5
43202: PUSH
43203: LD_INT 2
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 3
43212: PUSH
43213: LD_INT 3
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: LD_INT 3
43222: PUSH
43223: LD_INT 2
43225: PUSH
43226: EMPTY
43227: LIST
43228: LIST
43229: PUSH
43230: LD_INT 4
43232: PUSH
43233: LD_INT 3
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 4
43242: PUSH
43243: LD_INT 4
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 3
43252: PUSH
43253: LD_INT 4
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 2
43262: PUSH
43263: LD_INT 3
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 2
43272: PUSH
43273: LD_INT 2
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 4
43282: PUSH
43283: LD_INT 2
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 2
43292: PUSH
43293: LD_INT 4
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 0
43302: PUSH
43303: LD_INT 4
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 3
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: PUSH
43323: LD_INT 4
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 5
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: LD_INT 5
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 1
43352: NEG
43353: PUSH
43354: LD_INT 4
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: LD_INT 3
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 2
43374: PUSH
43375: LD_INT 5
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: LD_INT 2
43384: NEG
43385: PUSH
43386: LD_INT 3
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 3
43395: NEG
43396: PUSH
43397: LD_INT 0
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: LD_INT 3
43406: NEG
43407: PUSH
43408: LD_INT 1
43410: NEG
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 2
43418: NEG
43419: PUSH
43420: LD_INT 0
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 2
43429: NEG
43430: PUSH
43431: LD_INT 1
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 3
43440: NEG
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 4
43451: NEG
43452: PUSH
43453: LD_INT 0
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 4
43474: NEG
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 2
43486: NEG
43487: PUSH
43488: LD_INT 2
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 4
43497: NEG
43498: PUSH
43499: LD_INT 4
43501: NEG
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 4
43509: NEG
43510: PUSH
43511: LD_INT 5
43513: NEG
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 3
43521: NEG
43522: PUSH
43523: LD_INT 4
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 3
43533: NEG
43534: PUSH
43535: LD_INT 3
43537: NEG
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 4
43545: NEG
43546: PUSH
43547: LD_INT 3
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 5
43557: NEG
43558: PUSH
43559: LD_INT 4
43561: NEG
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 5
43569: NEG
43570: PUSH
43571: LD_INT 5
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 3
43581: NEG
43582: PUSH
43583: LD_INT 5
43585: NEG
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 5
43593: NEG
43594: PUSH
43595: LD_INT 3
43597: NEG
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: LIST
43616: LIST
43617: LIST
43618: LIST
43619: LIST
43620: LIST
43621: LIST
43622: LIST
43623: LIST
43624: LIST
43625: LIST
43626: LIST
43627: LIST
43628: LIST
43629: LIST
43630: LIST
43631: LIST
43632: LIST
43633: LIST
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: LIST
43647: LIST
43648: LIST
43649: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43650: LD_ADDR_VAR 0 30
43654: PUSH
43655: LD_INT 4
43657: PUSH
43658: LD_INT 4
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 4
43667: PUSH
43668: LD_INT 3
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: LD_INT 5
43677: PUSH
43678: LD_INT 4
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 5
43687: PUSH
43688: LD_INT 5
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PUSH
43695: LD_INT 4
43697: PUSH
43698: LD_INT 5
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 3
43707: PUSH
43708: LD_INT 4
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 3
43717: PUSH
43718: LD_INT 3
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 5
43727: PUSH
43728: LD_INT 3
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 3
43737: PUSH
43738: LD_INT 5
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 0
43747: PUSH
43748: LD_INT 3
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 0
43757: PUSH
43758: LD_INT 2
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 1
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 1
43777: PUSH
43778: LD_INT 4
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 0
43787: PUSH
43788: LD_INT 4
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 1
43797: NEG
43798: PUSH
43799: LD_INT 3
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 1
43808: NEG
43809: PUSH
43810: LD_INT 2
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 2
43819: PUSH
43820: LD_INT 4
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 2
43829: NEG
43830: PUSH
43831: LD_INT 2
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 4
43840: NEG
43841: PUSH
43842: LD_INT 0
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 4
43851: NEG
43852: PUSH
43853: LD_INT 1
43855: NEG
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 3
43863: NEG
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: LD_INT 4
43885: NEG
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 5
43896: NEG
43897: PUSH
43898: LD_INT 0
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 5
43907: NEG
43908: PUSH
43909: LD_INT 1
43911: NEG
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 5
43919: NEG
43920: PUSH
43921: LD_INT 2
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 3
43931: NEG
43932: PUSH
43933: LD_INT 2
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 3
43942: NEG
43943: PUSH
43944: LD_INT 3
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: LD_INT 3
43954: NEG
43955: PUSH
43956: LD_INT 4
43958: NEG
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 2
43966: NEG
43967: PUSH
43968: LD_INT 3
43970: NEG
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 2
43978: NEG
43979: PUSH
43980: LD_INT 2
43982: NEG
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 3
43990: NEG
43991: PUSH
43992: LD_INT 2
43994: NEG
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: NEG
44003: PUSH
44004: LD_INT 3
44006: NEG
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 4
44014: NEG
44015: PUSH
44016: LD_INT 4
44018: NEG
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: LD_INT 4
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 4
44038: NEG
44039: PUSH
44040: LD_INT 2
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 0
44050: PUSH
44051: LD_INT 4
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 5
44064: NEG
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 1
44072: PUSH
44073: LD_INT 4
44075: NEG
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 1
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: LD_INT 3
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 1
44105: NEG
44106: PUSH
44107: LD_INT 4
44109: NEG
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: LD_INT 1
44117: NEG
44118: PUSH
44119: LD_INT 5
44121: NEG
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 2
44129: PUSH
44130: LD_INT 3
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 2
44140: NEG
44141: PUSH
44142: LD_INT 5
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: LIST
44163: LIST
44164: LIST
44165: LIST
44166: LIST
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: LIST
44172: LIST
44173: LIST
44174: LIST
44175: LIST
44176: LIST
44177: LIST
44178: LIST
44179: LIST
44180: LIST
44181: LIST
44182: LIST
44183: LIST
44184: LIST
44185: LIST
44186: LIST
44187: LIST
44188: LIST
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: LIST
44196: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44197: LD_ADDR_VAR 0 31
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: LD_INT 4
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 0
44214: PUSH
44215: LD_INT 3
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 1
44224: PUSH
44225: LD_INT 4
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 5
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 0
44244: PUSH
44245: LD_INT 5
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 1
44254: NEG
44255: PUSH
44256: LD_INT 4
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 1
44265: NEG
44266: PUSH
44267: LD_INT 3
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 2
44276: PUSH
44277: LD_INT 5
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 2
44286: NEG
44287: PUSH
44288: LD_INT 3
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 3
44297: NEG
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 3
44308: NEG
44309: PUSH
44310: LD_INT 1
44312: NEG
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: NEG
44321: PUSH
44322: LD_INT 0
44324: PUSH
44325: EMPTY
44326: LIST
44327: LIST
44328: PUSH
44329: LD_INT 2
44331: NEG
44332: PUSH
44333: LD_INT 1
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 3
44342: NEG
44343: PUSH
44344: LD_INT 1
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 4
44353: NEG
44354: PUSH
44355: LD_INT 0
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 4
44364: NEG
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 4
44376: NEG
44377: PUSH
44378: LD_INT 2
44380: NEG
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 2
44388: NEG
44389: PUSH
44390: LD_INT 2
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 4
44399: NEG
44400: PUSH
44401: LD_INT 4
44403: NEG
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 4
44411: NEG
44412: PUSH
44413: LD_INT 5
44415: NEG
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: NEG
44424: PUSH
44425: LD_INT 4
44427: NEG
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 3
44435: NEG
44436: PUSH
44437: LD_INT 3
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 4
44447: NEG
44448: PUSH
44449: LD_INT 3
44451: NEG
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 5
44459: NEG
44460: PUSH
44461: LD_INT 4
44463: NEG
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: LD_INT 5
44471: NEG
44472: PUSH
44473: LD_INT 5
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 3
44483: NEG
44484: PUSH
44485: LD_INT 5
44487: NEG
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 5
44495: NEG
44496: PUSH
44497: LD_INT 3
44499: NEG
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: LD_INT 3
44510: NEG
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PUSH
44516: LD_INT 0
44518: PUSH
44519: LD_INT 4
44521: NEG
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 1
44529: PUSH
44530: LD_INT 3
44532: NEG
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 1
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 0
44551: PUSH
44552: LD_INT 2
44554: NEG
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 1
44562: NEG
44563: PUSH
44564: LD_INT 3
44566: NEG
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 1
44574: NEG
44575: PUSH
44576: LD_INT 4
44578: NEG
44579: PUSH
44580: EMPTY
44581: LIST
44582: LIST
44583: PUSH
44584: LD_INT 2
44586: PUSH
44587: LD_INT 2
44589: NEG
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: LD_INT 2
44597: NEG
44598: PUSH
44599: LD_INT 4
44601: NEG
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 4
44609: PUSH
44610: LD_INT 0
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 4
44619: PUSH
44620: LD_INT 1
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 5
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 5
44640: PUSH
44641: LD_INT 1
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 4
44650: PUSH
44651: LD_INT 1
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 3
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 3
44670: PUSH
44671: LD_INT 1
44673: NEG
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 3
44681: PUSH
44682: LD_INT 2
44684: NEG
44685: PUSH
44686: EMPTY
44687: LIST
44688: LIST
44689: PUSH
44690: LD_INT 5
44692: PUSH
44693: LD_INT 2
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: LIST
44704: LIST
44705: LIST
44706: LIST
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44747: LD_ADDR_VAR 0 32
44751: PUSH
44752: LD_INT 4
44754: NEG
44755: PUSH
44756: LD_INT 0
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: NEG
44766: PUSH
44767: LD_INT 1
44769: NEG
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 3
44777: NEG
44778: PUSH
44779: LD_INT 0
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 3
44788: NEG
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 4
44799: NEG
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 5
44810: NEG
44811: PUSH
44812: LD_INT 0
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 5
44821: NEG
44822: PUSH
44823: LD_INT 1
44825: NEG
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 5
44833: NEG
44834: PUSH
44835: LD_INT 2
44837: NEG
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 3
44845: NEG
44846: PUSH
44847: LD_INT 2
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 3
44856: NEG
44857: PUSH
44858: LD_INT 3
44860: NEG
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: PUSH
44866: LD_INT 3
44868: NEG
44869: PUSH
44870: LD_INT 4
44872: NEG
44873: PUSH
44874: EMPTY
44875: LIST
44876: LIST
44877: PUSH
44878: LD_INT 2
44880: NEG
44881: PUSH
44882: LD_INT 3
44884: NEG
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 2
44892: NEG
44893: PUSH
44894: LD_INT 2
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 3
44904: NEG
44905: PUSH
44906: LD_INT 2
44908: NEG
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 4
44916: NEG
44917: PUSH
44918: LD_INT 3
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: LD_INT 4
44928: NEG
44929: PUSH
44930: LD_INT 4
44932: NEG
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 2
44940: NEG
44941: PUSH
44942: LD_INT 4
44944: NEG
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 4
44952: NEG
44953: PUSH
44954: LD_INT 2
44956: NEG
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 0
44964: PUSH
44965: LD_INT 4
44967: NEG
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 0
44975: PUSH
44976: LD_INT 5
44978: NEG
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 1
44986: PUSH
44987: LD_INT 4
44989: NEG
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 1
44997: PUSH
44998: LD_INT 3
45000: NEG
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 0
45008: PUSH
45009: LD_INT 3
45011: NEG
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 1
45019: NEG
45020: PUSH
45021: LD_INT 4
45023: NEG
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 1
45031: NEG
45032: PUSH
45033: LD_INT 5
45035: NEG
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 2
45043: PUSH
45044: LD_INT 3
45046: NEG
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 2
45054: NEG
45055: PUSH
45056: LD_INT 5
45058: NEG
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 3
45066: PUSH
45067: LD_INT 0
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 3
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 4
45087: PUSH
45088: LD_INT 0
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 4
45097: PUSH
45098: LD_INT 1
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 3
45107: PUSH
45108: LD_INT 1
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 2
45117: PUSH
45118: LD_INT 0
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 2
45127: PUSH
45128: LD_INT 1
45130: NEG
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: LD_INT 2
45138: PUSH
45139: LD_INT 2
45141: NEG
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 4
45149: PUSH
45150: LD_INT 2
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 4
45159: PUSH
45160: LD_INT 4
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 4
45169: PUSH
45170: LD_INT 3
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 5
45179: PUSH
45180: LD_INT 4
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 5
45189: PUSH
45190: LD_INT 5
45192: PUSH
45193: EMPTY
45194: LIST
45195: LIST
45196: PUSH
45197: LD_INT 4
45199: PUSH
45200: LD_INT 5
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 3
45209: PUSH
45210: LD_INT 4
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 3
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 5
45229: PUSH
45230: LD_INT 3
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 3
45239: PUSH
45240: LD_INT 5
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45294: LD_ADDR_VAR 0 33
45298: PUSH
45299: LD_INT 4
45301: NEG
45302: PUSH
45303: LD_INT 4
45305: NEG
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 4
45313: NEG
45314: PUSH
45315: LD_INT 5
45317: NEG
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 3
45325: NEG
45326: PUSH
45327: LD_INT 4
45329: NEG
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: PUSH
45335: LD_INT 3
45337: NEG
45338: PUSH
45339: LD_INT 3
45341: NEG
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 4
45349: NEG
45350: PUSH
45351: LD_INT 3
45353: NEG
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 5
45361: NEG
45362: PUSH
45363: LD_INT 4
45365: NEG
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 5
45373: NEG
45374: PUSH
45375: LD_INT 5
45377: NEG
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 3
45385: NEG
45386: PUSH
45387: LD_INT 5
45389: NEG
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: PUSH
45395: LD_INT 5
45397: NEG
45398: PUSH
45399: LD_INT 3
45401: NEG
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 0
45409: PUSH
45410: LD_INT 3
45412: NEG
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PUSH
45418: LD_INT 0
45420: PUSH
45421: LD_INT 4
45423: NEG
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 1
45431: PUSH
45432: LD_INT 3
45434: NEG
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: PUSH
45440: LD_INT 1
45442: PUSH
45443: LD_INT 2
45445: NEG
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 0
45453: PUSH
45454: LD_INT 2
45456: NEG
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: LD_INT 3
45468: NEG
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 1
45476: NEG
45477: PUSH
45478: LD_INT 4
45480: NEG
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 2
45488: PUSH
45489: LD_INT 2
45491: NEG
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: PUSH
45497: LD_INT 2
45499: NEG
45500: PUSH
45501: LD_INT 4
45503: NEG
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 4
45511: PUSH
45512: LD_INT 0
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 4
45521: PUSH
45522: LD_INT 1
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 5
45532: PUSH
45533: LD_INT 0
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 5
45542: PUSH
45543: LD_INT 1
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 4
45552: PUSH
45553: LD_INT 1
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 3
45562: PUSH
45563: LD_INT 0
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 3
45572: PUSH
45573: LD_INT 1
45575: NEG
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 3
45583: PUSH
45584: LD_INT 2
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 5
45594: PUSH
45595: LD_INT 2
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 3
45604: PUSH
45605: LD_INT 3
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: PUSH
45612: LD_INT 3
45614: PUSH
45615: LD_INT 2
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: PUSH
45622: LD_INT 4
45624: PUSH
45625: LD_INT 3
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: LD_INT 4
45634: PUSH
45635: LD_INT 4
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: PUSH
45642: LD_INT 3
45644: PUSH
45645: LD_INT 4
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 2
45654: PUSH
45655: LD_INT 3
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 2
45664: PUSH
45665: LD_INT 2
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 4
45674: PUSH
45675: LD_INT 2
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: LD_INT 2
45684: PUSH
45685: LD_INT 4
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: LD_INT 0
45694: PUSH
45695: LD_INT 4
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: PUSH
45702: LD_INT 0
45704: PUSH
45705: LD_INT 3
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PUSH
45712: LD_INT 1
45714: PUSH
45715: LD_INT 4
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 1
45724: PUSH
45725: LD_INT 5
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 0
45734: PUSH
45735: LD_INT 5
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 1
45744: NEG
45745: PUSH
45746: LD_INT 4
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: PUSH
45753: LD_INT 1
45755: NEG
45756: PUSH
45757: LD_INT 3
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: PUSH
45764: LD_INT 2
45766: PUSH
45767: LD_INT 5
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: LD_INT 2
45776: NEG
45777: PUSH
45778: LD_INT 3
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45832: LD_ADDR_VAR 0 34
45836: PUSH
45837: LD_INT 0
45839: PUSH
45840: LD_INT 4
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 0
45850: PUSH
45851: LD_INT 5
45853: NEG
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 1
45861: PUSH
45862: LD_INT 4
45864: NEG
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: LD_INT 1
45872: PUSH
45873: LD_INT 3
45875: NEG
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 0
45883: PUSH
45884: LD_INT 3
45886: NEG
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 1
45894: NEG
45895: PUSH
45896: LD_INT 4
45898: NEG
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 1
45906: NEG
45907: PUSH
45908: LD_INT 5
45910: NEG
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 2
45918: PUSH
45919: LD_INT 3
45921: NEG
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: LD_INT 2
45929: NEG
45930: PUSH
45931: LD_INT 5
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 3
45941: PUSH
45942: LD_INT 0
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 3
45951: PUSH
45952: LD_INT 1
45954: NEG
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 4
45962: PUSH
45963: LD_INT 0
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 4
45972: PUSH
45973: LD_INT 1
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: PUSH
45980: LD_INT 3
45982: PUSH
45983: LD_INT 1
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 2
45992: PUSH
45993: LD_INT 0
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 2
46002: PUSH
46003: LD_INT 1
46005: NEG
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 2
46013: PUSH
46014: LD_INT 2
46016: NEG
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: LD_INT 2
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 4
46034: PUSH
46035: LD_INT 4
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 4
46044: PUSH
46045: LD_INT 3
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 5
46054: PUSH
46055: LD_INT 4
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 5
46064: PUSH
46065: LD_INT 5
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 4
46074: PUSH
46075: LD_INT 5
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 3
46084: PUSH
46085: LD_INT 4
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 3
46094: PUSH
46095: LD_INT 3
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: PUSH
46102: LD_INT 5
46104: PUSH
46105: LD_INT 3
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: PUSH
46112: LD_INT 3
46114: PUSH
46115: LD_INT 5
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 0
46124: PUSH
46125: LD_INT 3
46127: PUSH
46128: EMPTY
46129: LIST
46130: LIST
46131: PUSH
46132: LD_INT 0
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 1
46144: PUSH
46145: LD_INT 3
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 1
46154: PUSH
46155: LD_INT 4
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: LD_INT 0
46164: PUSH
46165: LD_INT 4
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 1
46174: NEG
46175: PUSH
46176: LD_INT 3
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 1
46185: NEG
46186: PUSH
46187: LD_INT 2
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 2
46196: PUSH
46197: LD_INT 4
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: PUSH
46204: LD_INT 2
46206: NEG
46207: PUSH
46208: LD_INT 2
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 4
46217: NEG
46218: PUSH
46219: LD_INT 0
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 4
46228: NEG
46229: PUSH
46230: LD_INT 1
46232: NEG
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 3
46240: NEG
46241: PUSH
46242: LD_INT 0
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: LD_INT 3
46251: NEG
46252: PUSH
46253: LD_INT 1
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 4
46262: NEG
46263: PUSH
46264: LD_INT 1
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 5
46273: NEG
46274: PUSH
46275: LD_INT 0
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: LD_INT 5
46284: NEG
46285: PUSH
46286: LD_INT 1
46288: NEG
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 5
46296: NEG
46297: PUSH
46298: LD_INT 2
46300: NEG
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 3
46308: NEG
46309: PUSH
46310: LD_INT 2
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: ST_TO_ADDR
// end ; end ;
46364: GO 46367
46366: POP
// case btype of b_depot , b_warehouse :
46367: LD_VAR 0 1
46371: PUSH
46372: LD_INT 0
46374: DOUBLE
46375: EQUAL
46376: IFTRUE 46386
46378: LD_INT 1
46380: DOUBLE
46381: EQUAL
46382: IFTRUE 46386
46384: GO 46587
46386: POP
// case nation of nation_american :
46387: LD_VAR 0 5
46391: PUSH
46392: LD_INT 1
46394: DOUBLE
46395: EQUAL
46396: IFTRUE 46400
46398: GO 46456
46400: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46401: LD_ADDR_VAR 0 9
46405: PUSH
46406: LD_VAR 0 11
46410: PUSH
46411: LD_VAR 0 12
46415: PUSH
46416: LD_VAR 0 13
46420: PUSH
46421: LD_VAR 0 14
46425: PUSH
46426: LD_VAR 0 15
46430: PUSH
46431: LD_VAR 0 16
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: PUSH
46444: LD_VAR 0 4
46448: PUSH
46449: LD_INT 1
46451: PLUS
46452: ARRAY
46453: ST_TO_ADDR
46454: GO 46585
46456: LD_INT 2
46458: DOUBLE
46459: EQUAL
46460: IFTRUE 46464
46462: GO 46520
46464: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46465: LD_ADDR_VAR 0 9
46469: PUSH
46470: LD_VAR 0 17
46474: PUSH
46475: LD_VAR 0 18
46479: PUSH
46480: LD_VAR 0 19
46484: PUSH
46485: LD_VAR 0 20
46489: PUSH
46490: LD_VAR 0 21
46494: PUSH
46495: LD_VAR 0 22
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: PUSH
46508: LD_VAR 0 4
46512: PUSH
46513: LD_INT 1
46515: PLUS
46516: ARRAY
46517: ST_TO_ADDR
46518: GO 46585
46520: LD_INT 3
46522: DOUBLE
46523: EQUAL
46524: IFTRUE 46528
46526: GO 46584
46528: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46529: LD_ADDR_VAR 0 9
46533: PUSH
46534: LD_VAR 0 23
46538: PUSH
46539: LD_VAR 0 24
46543: PUSH
46544: LD_VAR 0 25
46548: PUSH
46549: LD_VAR 0 26
46553: PUSH
46554: LD_VAR 0 27
46558: PUSH
46559: LD_VAR 0 28
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: PUSH
46572: LD_VAR 0 4
46576: PUSH
46577: LD_INT 1
46579: PLUS
46580: ARRAY
46581: ST_TO_ADDR
46582: GO 46585
46584: POP
46585: GO 47140
46587: LD_INT 2
46589: DOUBLE
46590: EQUAL
46591: IFTRUE 46601
46593: LD_INT 3
46595: DOUBLE
46596: EQUAL
46597: IFTRUE 46601
46599: GO 46657
46601: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46602: LD_ADDR_VAR 0 9
46606: PUSH
46607: LD_VAR 0 29
46611: PUSH
46612: LD_VAR 0 30
46616: PUSH
46617: LD_VAR 0 31
46621: PUSH
46622: LD_VAR 0 32
46626: PUSH
46627: LD_VAR 0 33
46631: PUSH
46632: LD_VAR 0 34
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: PUSH
46645: LD_VAR 0 4
46649: PUSH
46650: LD_INT 1
46652: PLUS
46653: ARRAY
46654: ST_TO_ADDR
46655: GO 47140
46657: LD_INT 16
46659: DOUBLE
46660: EQUAL
46661: IFTRUE 46719
46663: LD_INT 17
46665: DOUBLE
46666: EQUAL
46667: IFTRUE 46719
46669: LD_INT 18
46671: DOUBLE
46672: EQUAL
46673: IFTRUE 46719
46675: LD_INT 19
46677: DOUBLE
46678: EQUAL
46679: IFTRUE 46719
46681: LD_INT 22
46683: DOUBLE
46684: EQUAL
46685: IFTRUE 46719
46687: LD_INT 20
46689: DOUBLE
46690: EQUAL
46691: IFTRUE 46719
46693: LD_INT 21
46695: DOUBLE
46696: EQUAL
46697: IFTRUE 46719
46699: LD_INT 23
46701: DOUBLE
46702: EQUAL
46703: IFTRUE 46719
46705: LD_INT 24
46707: DOUBLE
46708: EQUAL
46709: IFTRUE 46719
46711: LD_INT 25
46713: DOUBLE
46714: EQUAL
46715: IFTRUE 46719
46717: GO 46775
46719: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46720: LD_ADDR_VAR 0 9
46724: PUSH
46725: LD_VAR 0 35
46729: PUSH
46730: LD_VAR 0 36
46734: PUSH
46735: LD_VAR 0 37
46739: PUSH
46740: LD_VAR 0 38
46744: PUSH
46745: LD_VAR 0 39
46749: PUSH
46750: LD_VAR 0 40
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: PUSH
46763: LD_VAR 0 4
46767: PUSH
46768: LD_INT 1
46770: PLUS
46771: ARRAY
46772: ST_TO_ADDR
46773: GO 47140
46775: LD_INT 6
46777: DOUBLE
46778: EQUAL
46779: IFTRUE 46831
46781: LD_INT 7
46783: DOUBLE
46784: EQUAL
46785: IFTRUE 46831
46787: LD_INT 8
46789: DOUBLE
46790: EQUAL
46791: IFTRUE 46831
46793: LD_INT 13
46795: DOUBLE
46796: EQUAL
46797: IFTRUE 46831
46799: LD_INT 12
46801: DOUBLE
46802: EQUAL
46803: IFTRUE 46831
46805: LD_INT 15
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46831
46811: LD_INT 11
46813: DOUBLE
46814: EQUAL
46815: IFTRUE 46831
46817: LD_INT 14
46819: DOUBLE
46820: EQUAL
46821: IFTRUE 46831
46823: LD_INT 10
46825: DOUBLE
46826: EQUAL
46827: IFTRUE 46831
46829: GO 46887
46831: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46832: LD_ADDR_VAR 0 9
46836: PUSH
46837: LD_VAR 0 41
46841: PUSH
46842: LD_VAR 0 42
46846: PUSH
46847: LD_VAR 0 43
46851: PUSH
46852: LD_VAR 0 44
46856: PUSH
46857: LD_VAR 0 45
46861: PUSH
46862: LD_VAR 0 46
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: LIST
46874: PUSH
46875: LD_VAR 0 4
46879: PUSH
46880: LD_INT 1
46882: PLUS
46883: ARRAY
46884: ST_TO_ADDR
46885: GO 47140
46887: LD_INT 36
46889: DOUBLE
46890: EQUAL
46891: IFTRUE 46895
46893: GO 46951
46895: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46896: LD_ADDR_VAR 0 9
46900: PUSH
46901: LD_VAR 0 47
46905: PUSH
46906: LD_VAR 0 48
46910: PUSH
46911: LD_VAR 0 49
46915: PUSH
46916: LD_VAR 0 50
46920: PUSH
46921: LD_VAR 0 51
46925: PUSH
46926: LD_VAR 0 52
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: PUSH
46939: LD_VAR 0 4
46943: PUSH
46944: LD_INT 1
46946: PLUS
46947: ARRAY
46948: ST_TO_ADDR
46949: GO 47140
46951: LD_INT 4
46953: DOUBLE
46954: EQUAL
46955: IFTRUE 46977
46957: LD_INT 5
46959: DOUBLE
46960: EQUAL
46961: IFTRUE 46977
46963: LD_INT 34
46965: DOUBLE
46966: EQUAL
46967: IFTRUE 46977
46969: LD_INT 37
46971: DOUBLE
46972: EQUAL
46973: IFTRUE 46977
46975: GO 47033
46977: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46978: LD_ADDR_VAR 0 9
46982: PUSH
46983: LD_VAR 0 53
46987: PUSH
46988: LD_VAR 0 54
46992: PUSH
46993: LD_VAR 0 55
46997: PUSH
46998: LD_VAR 0 56
47002: PUSH
47003: LD_VAR 0 57
47007: PUSH
47008: LD_VAR 0 58
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: PUSH
47021: LD_VAR 0 4
47025: PUSH
47026: LD_INT 1
47028: PLUS
47029: ARRAY
47030: ST_TO_ADDR
47031: GO 47140
47033: LD_INT 31
47035: DOUBLE
47036: EQUAL
47037: IFTRUE 47083
47039: LD_INT 32
47041: DOUBLE
47042: EQUAL
47043: IFTRUE 47083
47045: LD_INT 33
47047: DOUBLE
47048: EQUAL
47049: IFTRUE 47083
47051: LD_INT 27
47053: DOUBLE
47054: EQUAL
47055: IFTRUE 47083
47057: LD_INT 26
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47083
47063: LD_INT 28
47065: DOUBLE
47066: EQUAL
47067: IFTRUE 47083
47069: LD_INT 29
47071: DOUBLE
47072: EQUAL
47073: IFTRUE 47083
47075: LD_INT 30
47077: DOUBLE
47078: EQUAL
47079: IFTRUE 47083
47081: GO 47139
47083: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47084: LD_ADDR_VAR 0 9
47088: PUSH
47089: LD_VAR 0 59
47093: PUSH
47094: LD_VAR 0 60
47098: PUSH
47099: LD_VAR 0 61
47103: PUSH
47104: LD_VAR 0 62
47108: PUSH
47109: LD_VAR 0 63
47113: PUSH
47114: LD_VAR 0 64
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: PUSH
47127: LD_VAR 0 4
47131: PUSH
47132: LD_INT 1
47134: PLUS
47135: ARRAY
47136: ST_TO_ADDR
47137: GO 47140
47139: POP
// temp_list2 = [ ] ;
47140: LD_ADDR_VAR 0 10
47144: PUSH
47145: EMPTY
47146: ST_TO_ADDR
// for i in temp_list do
47147: LD_ADDR_VAR 0 8
47151: PUSH
47152: LD_VAR 0 9
47156: PUSH
47157: FOR_IN
47158: IFFALSE 47210
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47160: LD_ADDR_VAR 0 10
47164: PUSH
47165: LD_VAR 0 10
47169: PUSH
47170: LD_VAR 0 8
47174: PUSH
47175: LD_INT 1
47177: ARRAY
47178: PUSH
47179: LD_VAR 0 2
47183: PLUS
47184: PUSH
47185: LD_VAR 0 8
47189: PUSH
47190: LD_INT 2
47192: ARRAY
47193: PUSH
47194: LD_VAR 0 3
47198: PLUS
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: EMPTY
47205: LIST
47206: ADD
47207: ST_TO_ADDR
47208: GO 47157
47210: POP
47211: POP
// result = temp_list2 ;
47212: LD_ADDR_VAR 0 7
47216: PUSH
47217: LD_VAR 0 10
47221: ST_TO_ADDR
// end ;
47222: LD_VAR 0 7
47226: RET
// export function EnemyInRange ( unit , dist ) ; begin
47227: LD_INT 0
47229: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47230: LD_ADDR_VAR 0 3
47234: PUSH
47235: LD_VAR 0 1
47239: PPUSH
47240: CALL_OW 255
47244: PPUSH
47245: LD_VAR 0 1
47249: PPUSH
47250: CALL_OW 250
47254: PPUSH
47255: LD_VAR 0 1
47259: PPUSH
47260: CALL_OW 251
47264: PPUSH
47265: LD_VAR 0 2
47269: PPUSH
47270: CALL 20622 0 4
47274: PUSH
47275: LD_INT 4
47277: ARRAY
47278: ST_TO_ADDR
// end ;
47279: LD_VAR 0 3
47283: RET
// export function PlayerSeeMe ( unit ) ; begin
47284: LD_INT 0
47286: PPUSH
// result := See ( your_side , unit ) ;
47287: LD_ADDR_VAR 0 2
47291: PUSH
47292: LD_OWVAR 2
47296: PPUSH
47297: LD_VAR 0 1
47301: PPUSH
47302: CALL_OW 292
47306: ST_TO_ADDR
// end ;
47307: LD_VAR 0 2
47311: RET
// export function ReverseDir ( unit ) ; begin
47312: LD_INT 0
47314: PPUSH
// if not unit then
47315: LD_VAR 0 1
47319: NOT
47320: IFFALSE 47324
// exit ;
47322: GO 47347
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47324: LD_ADDR_VAR 0 2
47328: PUSH
47329: LD_VAR 0 1
47333: PPUSH
47334: CALL_OW 254
47338: PUSH
47339: LD_INT 3
47341: PLUS
47342: PUSH
47343: LD_INT 6
47345: MOD
47346: ST_TO_ADDR
// end ;
47347: LD_VAR 0 2
47351: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47352: LD_INT 0
47354: PPUSH
47355: PPUSH
47356: PPUSH
47357: PPUSH
47358: PPUSH
// if not hexes then
47359: LD_VAR 0 2
47363: NOT
47364: IFFALSE 47368
// exit ;
47366: GO 47516
// dist := 9999 ;
47368: LD_ADDR_VAR 0 5
47372: PUSH
47373: LD_INT 9999
47375: ST_TO_ADDR
// for i = 1 to hexes do
47376: LD_ADDR_VAR 0 4
47380: PUSH
47381: DOUBLE
47382: LD_INT 1
47384: DEC
47385: ST_TO_ADDR
47386: LD_VAR 0 2
47390: PUSH
47391: FOR_TO
47392: IFFALSE 47504
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47394: LD_VAR 0 1
47398: PPUSH
47399: LD_VAR 0 2
47403: PUSH
47404: LD_VAR 0 4
47408: ARRAY
47409: PUSH
47410: LD_INT 1
47412: ARRAY
47413: PPUSH
47414: LD_VAR 0 2
47418: PUSH
47419: LD_VAR 0 4
47423: ARRAY
47424: PUSH
47425: LD_INT 2
47427: ARRAY
47428: PPUSH
47429: CALL_OW 297
47433: PUSH
47434: LD_VAR 0 5
47438: LESS
47439: IFFALSE 47502
// begin hex := hexes [ i ] ;
47441: LD_ADDR_VAR 0 7
47445: PUSH
47446: LD_VAR 0 2
47450: PUSH
47451: LD_VAR 0 4
47455: ARRAY
47456: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47457: LD_ADDR_VAR 0 5
47461: PUSH
47462: LD_VAR 0 1
47466: PPUSH
47467: LD_VAR 0 2
47471: PUSH
47472: LD_VAR 0 4
47476: ARRAY
47477: PUSH
47478: LD_INT 1
47480: ARRAY
47481: PPUSH
47482: LD_VAR 0 2
47486: PUSH
47487: LD_VAR 0 4
47491: ARRAY
47492: PUSH
47493: LD_INT 2
47495: ARRAY
47496: PPUSH
47497: CALL_OW 297
47501: ST_TO_ADDR
// end ; end ;
47502: GO 47391
47504: POP
47505: POP
// result := hex ;
47506: LD_ADDR_VAR 0 3
47510: PUSH
47511: LD_VAR 0 7
47515: ST_TO_ADDR
// end ;
47516: LD_VAR 0 3
47520: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47525: LD_VAR 0 1
47529: NOT
47530: PUSH
47531: LD_VAR 0 1
47535: PUSH
47536: LD_INT 21
47538: PUSH
47539: LD_INT 2
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PUSH
47546: LD_INT 23
47548: PUSH
47549: LD_INT 2
47551: PUSH
47552: EMPTY
47553: LIST
47554: LIST
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PPUSH
47560: CALL_OW 69
47564: IN
47565: NOT
47566: OR
47567: IFFALSE 47571
// exit ;
47569: GO 47618
// for i = 1 to 3 do
47571: LD_ADDR_VAR 0 3
47575: PUSH
47576: DOUBLE
47577: LD_INT 1
47579: DEC
47580: ST_TO_ADDR
47581: LD_INT 3
47583: PUSH
47584: FOR_TO
47585: IFFALSE 47616
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47587: LD_VAR 0 1
47591: PPUSH
47592: CALL_OW 250
47596: PPUSH
47597: LD_VAR 0 1
47601: PPUSH
47602: CALL_OW 251
47606: PPUSH
47607: LD_INT 1
47609: PPUSH
47610: CALL_OW 453
47614: GO 47584
47616: POP
47617: POP
// end ;
47618: LD_VAR 0 2
47622: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47623: LD_INT 0
47625: PPUSH
47626: PPUSH
47627: PPUSH
47628: PPUSH
47629: PPUSH
47630: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47631: LD_VAR 0 1
47635: NOT
47636: PUSH
47637: LD_VAR 0 2
47641: NOT
47642: OR
47643: PUSH
47644: LD_VAR 0 1
47648: PPUSH
47649: CALL_OW 314
47653: OR
47654: IFFALSE 47658
// exit ;
47656: GO 48099
// x := GetX ( enemy_unit ) ;
47658: LD_ADDR_VAR 0 7
47662: PUSH
47663: LD_VAR 0 2
47667: PPUSH
47668: CALL_OW 250
47672: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47673: LD_ADDR_VAR 0 8
47677: PUSH
47678: LD_VAR 0 2
47682: PPUSH
47683: CALL_OW 251
47687: ST_TO_ADDR
// if not x or not y then
47688: LD_VAR 0 7
47692: NOT
47693: PUSH
47694: LD_VAR 0 8
47698: NOT
47699: OR
47700: IFFALSE 47704
// exit ;
47702: GO 48099
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47704: LD_ADDR_VAR 0 6
47708: PUSH
47709: LD_VAR 0 7
47713: PPUSH
47714: LD_INT 0
47716: PPUSH
47717: LD_INT 4
47719: PPUSH
47720: CALL_OW 272
47724: PUSH
47725: LD_VAR 0 8
47729: PPUSH
47730: LD_INT 0
47732: PPUSH
47733: LD_INT 4
47735: PPUSH
47736: CALL_OW 273
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: PUSH
47745: LD_VAR 0 7
47749: PPUSH
47750: LD_INT 1
47752: PPUSH
47753: LD_INT 4
47755: PPUSH
47756: CALL_OW 272
47760: PUSH
47761: LD_VAR 0 8
47765: PPUSH
47766: LD_INT 1
47768: PPUSH
47769: LD_INT 4
47771: PPUSH
47772: CALL_OW 273
47776: PUSH
47777: EMPTY
47778: LIST
47779: LIST
47780: PUSH
47781: LD_VAR 0 7
47785: PPUSH
47786: LD_INT 2
47788: PPUSH
47789: LD_INT 4
47791: PPUSH
47792: CALL_OW 272
47796: PUSH
47797: LD_VAR 0 8
47801: PPUSH
47802: LD_INT 2
47804: PPUSH
47805: LD_INT 4
47807: PPUSH
47808: CALL_OW 273
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_VAR 0 7
47821: PPUSH
47822: LD_INT 3
47824: PPUSH
47825: LD_INT 4
47827: PPUSH
47828: CALL_OW 272
47832: PUSH
47833: LD_VAR 0 8
47837: PPUSH
47838: LD_INT 3
47840: PPUSH
47841: LD_INT 4
47843: PPUSH
47844: CALL_OW 273
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: PUSH
47853: LD_VAR 0 7
47857: PPUSH
47858: LD_INT 4
47860: PPUSH
47861: LD_INT 4
47863: PPUSH
47864: CALL_OW 272
47868: PUSH
47869: LD_VAR 0 8
47873: PPUSH
47874: LD_INT 4
47876: PPUSH
47877: LD_INT 4
47879: PPUSH
47880: CALL_OW 273
47884: PUSH
47885: EMPTY
47886: LIST
47887: LIST
47888: PUSH
47889: LD_VAR 0 7
47893: PPUSH
47894: LD_INT 5
47896: PPUSH
47897: LD_INT 4
47899: PPUSH
47900: CALL_OW 272
47904: PUSH
47905: LD_VAR 0 8
47909: PPUSH
47910: LD_INT 5
47912: PPUSH
47913: LD_INT 4
47915: PPUSH
47916: CALL_OW 273
47920: PUSH
47921: EMPTY
47922: LIST
47923: LIST
47924: PUSH
47925: EMPTY
47926: LIST
47927: LIST
47928: LIST
47929: LIST
47930: LIST
47931: LIST
47932: ST_TO_ADDR
// for i = tmp downto 1 do
47933: LD_ADDR_VAR 0 4
47937: PUSH
47938: DOUBLE
47939: LD_VAR 0 6
47943: INC
47944: ST_TO_ADDR
47945: LD_INT 1
47947: PUSH
47948: FOR_DOWNTO
47949: IFFALSE 48050
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47951: LD_VAR 0 6
47955: PUSH
47956: LD_VAR 0 4
47960: ARRAY
47961: PUSH
47962: LD_INT 1
47964: ARRAY
47965: PPUSH
47966: LD_VAR 0 6
47970: PUSH
47971: LD_VAR 0 4
47975: ARRAY
47976: PUSH
47977: LD_INT 2
47979: ARRAY
47980: PPUSH
47981: CALL_OW 488
47985: NOT
47986: PUSH
47987: LD_VAR 0 6
47991: PUSH
47992: LD_VAR 0 4
47996: ARRAY
47997: PUSH
47998: LD_INT 1
48000: ARRAY
48001: PPUSH
48002: LD_VAR 0 6
48006: PUSH
48007: LD_VAR 0 4
48011: ARRAY
48012: PUSH
48013: LD_INT 2
48015: ARRAY
48016: PPUSH
48017: CALL_OW 428
48021: PUSH
48022: LD_INT 0
48024: NONEQUAL
48025: OR
48026: IFFALSE 48048
// tmp := Delete ( tmp , i ) ;
48028: LD_ADDR_VAR 0 6
48032: PUSH
48033: LD_VAR 0 6
48037: PPUSH
48038: LD_VAR 0 4
48042: PPUSH
48043: CALL_OW 3
48047: ST_TO_ADDR
48048: GO 47948
48050: POP
48051: POP
// j := GetClosestHex ( unit , tmp ) ;
48052: LD_ADDR_VAR 0 5
48056: PUSH
48057: LD_VAR 0 1
48061: PPUSH
48062: LD_VAR 0 6
48066: PPUSH
48067: CALL 47352 0 2
48071: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48072: LD_VAR 0 1
48076: PPUSH
48077: LD_VAR 0 5
48081: PUSH
48082: LD_INT 1
48084: ARRAY
48085: PPUSH
48086: LD_VAR 0 5
48090: PUSH
48091: LD_INT 2
48093: ARRAY
48094: PPUSH
48095: CALL_OW 111
// end ;
48099: LD_VAR 0 3
48103: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48104: LD_INT 0
48106: PPUSH
48107: PPUSH
48108: PPUSH
// uc_side = 0 ;
48109: LD_ADDR_OWVAR 20
48113: PUSH
48114: LD_INT 0
48116: ST_TO_ADDR
// uc_nation = 0 ;
48117: LD_ADDR_OWVAR 21
48121: PUSH
48122: LD_INT 0
48124: ST_TO_ADDR
// InitHc_All ( ) ;
48125: CALL_OW 584
// InitVc ;
48129: CALL_OW 20
// if mastodonts then
48133: LD_VAR 0 6
48137: IFFALSE 48204
// for i = 1 to mastodonts do
48139: LD_ADDR_VAR 0 11
48143: PUSH
48144: DOUBLE
48145: LD_INT 1
48147: DEC
48148: ST_TO_ADDR
48149: LD_VAR 0 6
48153: PUSH
48154: FOR_TO
48155: IFFALSE 48202
// begin vc_chassis := 31 ;
48157: LD_ADDR_OWVAR 37
48161: PUSH
48162: LD_INT 31
48164: ST_TO_ADDR
// vc_control := control_rider ;
48165: LD_ADDR_OWVAR 38
48169: PUSH
48170: LD_INT 4
48172: ST_TO_ADDR
// animal := CreateVehicle ;
48173: LD_ADDR_VAR 0 12
48177: PUSH
48178: CALL_OW 45
48182: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48183: LD_VAR 0 12
48187: PPUSH
48188: LD_VAR 0 8
48192: PPUSH
48193: LD_INT 0
48195: PPUSH
48196: CALL 50392 0 3
// end ;
48200: GO 48154
48202: POP
48203: POP
// if horses then
48204: LD_VAR 0 5
48208: IFFALSE 48275
// for i = 1 to horses do
48210: LD_ADDR_VAR 0 11
48214: PUSH
48215: DOUBLE
48216: LD_INT 1
48218: DEC
48219: ST_TO_ADDR
48220: LD_VAR 0 5
48224: PUSH
48225: FOR_TO
48226: IFFALSE 48273
// begin hc_class := 21 ;
48228: LD_ADDR_OWVAR 28
48232: PUSH
48233: LD_INT 21
48235: ST_TO_ADDR
// hc_gallery :=  ;
48236: LD_ADDR_OWVAR 33
48240: PUSH
48241: LD_STRING 
48243: ST_TO_ADDR
// animal := CreateHuman ;
48244: LD_ADDR_VAR 0 12
48248: PUSH
48249: CALL_OW 44
48253: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48254: LD_VAR 0 12
48258: PPUSH
48259: LD_VAR 0 8
48263: PPUSH
48264: LD_INT 0
48266: PPUSH
48267: CALL 50392 0 3
// end ;
48271: GO 48225
48273: POP
48274: POP
// if birds then
48275: LD_VAR 0 1
48279: IFFALSE 48346
// for i = 1 to birds do
48281: LD_ADDR_VAR 0 11
48285: PUSH
48286: DOUBLE
48287: LD_INT 1
48289: DEC
48290: ST_TO_ADDR
48291: LD_VAR 0 1
48295: PUSH
48296: FOR_TO
48297: IFFALSE 48344
// begin hc_class = 18 ;
48299: LD_ADDR_OWVAR 28
48303: PUSH
48304: LD_INT 18
48306: ST_TO_ADDR
// hc_gallery =  ;
48307: LD_ADDR_OWVAR 33
48311: PUSH
48312: LD_STRING 
48314: ST_TO_ADDR
// animal := CreateHuman ;
48315: LD_ADDR_VAR 0 12
48319: PUSH
48320: CALL_OW 44
48324: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48325: LD_VAR 0 12
48329: PPUSH
48330: LD_VAR 0 8
48334: PPUSH
48335: LD_INT 0
48337: PPUSH
48338: CALL 50392 0 3
// end ;
48342: GO 48296
48344: POP
48345: POP
// if tigers then
48346: LD_VAR 0 2
48350: IFFALSE 48434
// for i = 1 to tigers do
48352: LD_ADDR_VAR 0 11
48356: PUSH
48357: DOUBLE
48358: LD_INT 1
48360: DEC
48361: ST_TO_ADDR
48362: LD_VAR 0 2
48366: PUSH
48367: FOR_TO
48368: IFFALSE 48432
// begin hc_class = class_tiger ;
48370: LD_ADDR_OWVAR 28
48374: PUSH
48375: LD_INT 14
48377: ST_TO_ADDR
// hc_gallery =  ;
48378: LD_ADDR_OWVAR 33
48382: PUSH
48383: LD_STRING 
48385: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48386: LD_ADDR_OWVAR 35
48390: PUSH
48391: LD_INT 7
48393: NEG
48394: PPUSH
48395: LD_INT 7
48397: PPUSH
48398: CALL_OW 12
48402: ST_TO_ADDR
// animal := CreateHuman ;
48403: LD_ADDR_VAR 0 12
48407: PUSH
48408: CALL_OW 44
48412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48413: LD_VAR 0 12
48417: PPUSH
48418: LD_VAR 0 8
48422: PPUSH
48423: LD_INT 0
48425: PPUSH
48426: CALL 50392 0 3
// end ;
48430: GO 48367
48432: POP
48433: POP
// if apemans then
48434: LD_VAR 0 3
48438: IFFALSE 48561
// for i = 1 to apemans do
48440: LD_ADDR_VAR 0 11
48444: PUSH
48445: DOUBLE
48446: LD_INT 1
48448: DEC
48449: ST_TO_ADDR
48450: LD_VAR 0 3
48454: PUSH
48455: FOR_TO
48456: IFFALSE 48559
// begin hc_class = class_apeman ;
48458: LD_ADDR_OWVAR 28
48462: PUSH
48463: LD_INT 12
48465: ST_TO_ADDR
// hc_gallery =  ;
48466: LD_ADDR_OWVAR 33
48470: PUSH
48471: LD_STRING 
48473: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48474: LD_ADDR_OWVAR 35
48478: PUSH
48479: LD_INT 5
48481: NEG
48482: PPUSH
48483: LD_INT 5
48485: PPUSH
48486: CALL_OW 12
48490: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48491: LD_ADDR_OWVAR 31
48495: PUSH
48496: LD_INT 1
48498: PPUSH
48499: LD_INT 3
48501: PPUSH
48502: CALL_OW 12
48506: PUSH
48507: LD_INT 1
48509: PPUSH
48510: LD_INT 3
48512: PPUSH
48513: CALL_OW 12
48517: PUSH
48518: LD_INT 0
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: ST_TO_ADDR
// animal := CreateHuman ;
48530: LD_ADDR_VAR 0 12
48534: PUSH
48535: CALL_OW 44
48539: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48540: LD_VAR 0 12
48544: PPUSH
48545: LD_VAR 0 8
48549: PPUSH
48550: LD_INT 0
48552: PPUSH
48553: CALL 50392 0 3
// end ;
48557: GO 48455
48559: POP
48560: POP
// if enchidnas then
48561: LD_VAR 0 4
48565: IFFALSE 48632
// for i = 1 to enchidnas do
48567: LD_ADDR_VAR 0 11
48571: PUSH
48572: DOUBLE
48573: LD_INT 1
48575: DEC
48576: ST_TO_ADDR
48577: LD_VAR 0 4
48581: PUSH
48582: FOR_TO
48583: IFFALSE 48630
// begin hc_class = 13 ;
48585: LD_ADDR_OWVAR 28
48589: PUSH
48590: LD_INT 13
48592: ST_TO_ADDR
// hc_gallery =  ;
48593: LD_ADDR_OWVAR 33
48597: PUSH
48598: LD_STRING 
48600: ST_TO_ADDR
// animal := CreateHuman ;
48601: LD_ADDR_VAR 0 12
48605: PUSH
48606: CALL_OW 44
48610: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48611: LD_VAR 0 12
48615: PPUSH
48616: LD_VAR 0 8
48620: PPUSH
48621: LD_INT 0
48623: PPUSH
48624: CALL 50392 0 3
// end ;
48628: GO 48582
48630: POP
48631: POP
// if fishes then
48632: LD_VAR 0 7
48636: IFFALSE 48703
// for i = 1 to fishes do
48638: LD_ADDR_VAR 0 11
48642: PUSH
48643: DOUBLE
48644: LD_INT 1
48646: DEC
48647: ST_TO_ADDR
48648: LD_VAR 0 7
48652: PUSH
48653: FOR_TO
48654: IFFALSE 48701
// begin hc_class = 20 ;
48656: LD_ADDR_OWVAR 28
48660: PUSH
48661: LD_INT 20
48663: ST_TO_ADDR
// hc_gallery =  ;
48664: LD_ADDR_OWVAR 33
48668: PUSH
48669: LD_STRING 
48671: ST_TO_ADDR
// animal := CreateHuman ;
48672: LD_ADDR_VAR 0 12
48676: PUSH
48677: CALL_OW 44
48681: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48682: LD_VAR 0 12
48686: PPUSH
48687: LD_VAR 0 9
48691: PPUSH
48692: LD_INT 0
48694: PPUSH
48695: CALL 50392 0 3
// end ;
48699: GO 48653
48701: POP
48702: POP
// end ;
48703: LD_VAR 0 10
48707: RET
// export function WantHeal ( sci , unit ) ; begin
48708: LD_INT 0
48710: PPUSH
// if GetTaskList ( sci ) > 0 then
48711: LD_VAR 0 1
48715: PPUSH
48716: CALL_OW 437
48720: PUSH
48721: LD_INT 0
48723: GREATER
48724: IFFALSE 48794
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48726: LD_VAR 0 1
48730: PPUSH
48731: CALL_OW 437
48735: PUSH
48736: LD_INT 1
48738: ARRAY
48739: PUSH
48740: LD_INT 1
48742: ARRAY
48743: PUSH
48744: LD_STRING l
48746: EQUAL
48747: PUSH
48748: LD_VAR 0 1
48752: PPUSH
48753: CALL_OW 437
48757: PUSH
48758: LD_INT 1
48760: ARRAY
48761: PUSH
48762: LD_INT 4
48764: ARRAY
48765: PUSH
48766: LD_VAR 0 2
48770: EQUAL
48771: AND
48772: IFFALSE 48784
// result := true else
48774: LD_ADDR_VAR 0 3
48778: PUSH
48779: LD_INT 1
48781: ST_TO_ADDR
48782: GO 48792
// result := false ;
48784: LD_ADDR_VAR 0 3
48788: PUSH
48789: LD_INT 0
48791: ST_TO_ADDR
// end else
48792: GO 48802
// result := false ;
48794: LD_ADDR_VAR 0 3
48798: PUSH
48799: LD_INT 0
48801: ST_TO_ADDR
// end ;
48802: LD_VAR 0 3
48806: RET
// export function HealTarget ( sci ) ; begin
48807: LD_INT 0
48809: PPUSH
// if not sci then
48810: LD_VAR 0 1
48814: NOT
48815: IFFALSE 48819
// exit ;
48817: GO 48884
// result := 0 ;
48819: LD_ADDR_VAR 0 2
48823: PUSH
48824: LD_INT 0
48826: ST_TO_ADDR
// if GetTaskList ( sci ) then
48827: LD_VAR 0 1
48831: PPUSH
48832: CALL_OW 437
48836: IFFALSE 48884
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48838: LD_VAR 0 1
48842: PPUSH
48843: CALL_OW 437
48847: PUSH
48848: LD_INT 1
48850: ARRAY
48851: PUSH
48852: LD_INT 1
48854: ARRAY
48855: PUSH
48856: LD_STRING l
48858: EQUAL
48859: IFFALSE 48884
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48861: LD_ADDR_VAR 0 2
48865: PUSH
48866: LD_VAR 0 1
48870: PPUSH
48871: CALL_OW 437
48875: PUSH
48876: LD_INT 1
48878: ARRAY
48879: PUSH
48880: LD_INT 4
48882: ARRAY
48883: ST_TO_ADDR
// end ;
48884: LD_VAR 0 2
48888: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48889: LD_INT 0
48891: PPUSH
48892: PPUSH
48893: PPUSH
48894: PPUSH
// if not base_units then
48895: LD_VAR 0 1
48899: NOT
48900: IFFALSE 48904
// exit ;
48902: GO 48991
// result := false ;
48904: LD_ADDR_VAR 0 2
48908: PUSH
48909: LD_INT 0
48911: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48912: LD_ADDR_VAR 0 5
48916: PUSH
48917: LD_VAR 0 1
48921: PPUSH
48922: LD_INT 21
48924: PUSH
48925: LD_INT 3
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PPUSH
48932: CALL_OW 72
48936: ST_TO_ADDR
// if not tmp then
48937: LD_VAR 0 5
48941: NOT
48942: IFFALSE 48946
// exit ;
48944: GO 48991
// for i in tmp do
48946: LD_ADDR_VAR 0 3
48950: PUSH
48951: LD_VAR 0 5
48955: PUSH
48956: FOR_IN
48957: IFFALSE 48989
// begin result := EnemyInRange ( i , 22 ) ;
48959: LD_ADDR_VAR 0 2
48963: PUSH
48964: LD_VAR 0 3
48968: PPUSH
48969: LD_INT 22
48971: PPUSH
48972: CALL 47227 0 2
48976: ST_TO_ADDR
// if result then
48977: LD_VAR 0 2
48981: IFFALSE 48987
// exit ;
48983: POP
48984: POP
48985: GO 48991
// end ;
48987: GO 48956
48989: POP
48990: POP
// end ;
48991: LD_VAR 0 2
48995: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48996: LD_INT 0
48998: PPUSH
48999: PPUSH
// if not units then
49000: LD_VAR 0 1
49004: NOT
49005: IFFALSE 49009
// exit ;
49007: GO 49079
// result := [ ] ;
49009: LD_ADDR_VAR 0 3
49013: PUSH
49014: EMPTY
49015: ST_TO_ADDR
// for i in units do
49016: LD_ADDR_VAR 0 4
49020: PUSH
49021: LD_VAR 0 1
49025: PUSH
49026: FOR_IN
49027: IFFALSE 49077
// if GetTag ( i ) = tag then
49029: LD_VAR 0 4
49033: PPUSH
49034: CALL_OW 110
49038: PUSH
49039: LD_VAR 0 2
49043: EQUAL
49044: IFFALSE 49075
// result := Insert ( result , result + 1 , i ) ;
49046: LD_ADDR_VAR 0 3
49050: PUSH
49051: LD_VAR 0 3
49055: PPUSH
49056: LD_VAR 0 3
49060: PUSH
49061: LD_INT 1
49063: PLUS
49064: PPUSH
49065: LD_VAR 0 4
49069: PPUSH
49070: CALL_OW 2
49074: ST_TO_ADDR
49075: GO 49026
49077: POP
49078: POP
// end ;
49079: LD_VAR 0 3
49083: RET
// export function IsDriver ( un ) ; begin
49084: LD_INT 0
49086: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49087: LD_ADDR_VAR 0 2
49091: PUSH
49092: LD_VAR 0 1
49096: PUSH
49097: LD_INT 55
49099: PUSH
49100: EMPTY
49101: LIST
49102: PPUSH
49103: CALL_OW 69
49107: IN
49108: ST_TO_ADDR
// end ;
49109: LD_VAR 0 2
49113: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49114: LD_INT 0
49116: PPUSH
49117: PPUSH
// list := [ ] ;
49118: LD_ADDR_VAR 0 5
49122: PUSH
49123: EMPTY
49124: ST_TO_ADDR
// case d of 0 :
49125: LD_VAR 0 3
49129: PUSH
49130: LD_INT 0
49132: DOUBLE
49133: EQUAL
49134: IFTRUE 49138
49136: GO 49271
49138: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49139: LD_ADDR_VAR 0 5
49143: PUSH
49144: LD_VAR 0 1
49148: PUSH
49149: LD_INT 4
49151: MINUS
49152: PUSH
49153: LD_VAR 0 2
49157: PUSH
49158: LD_INT 4
49160: MINUS
49161: PUSH
49162: LD_INT 2
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: LIST
49169: PUSH
49170: LD_VAR 0 1
49174: PUSH
49175: LD_INT 3
49177: MINUS
49178: PUSH
49179: LD_VAR 0 2
49183: PUSH
49184: LD_INT 1
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: LIST
49191: PUSH
49192: LD_VAR 0 1
49196: PUSH
49197: LD_INT 4
49199: PLUS
49200: PUSH
49201: LD_VAR 0 2
49205: PUSH
49206: LD_INT 4
49208: PUSH
49209: EMPTY
49210: LIST
49211: LIST
49212: LIST
49213: PUSH
49214: LD_VAR 0 1
49218: PUSH
49219: LD_INT 3
49221: PLUS
49222: PUSH
49223: LD_VAR 0 2
49227: PUSH
49228: LD_INT 3
49230: PLUS
49231: PUSH
49232: LD_INT 5
49234: PUSH
49235: EMPTY
49236: LIST
49237: LIST
49238: LIST
49239: PUSH
49240: LD_VAR 0 1
49244: PUSH
49245: LD_VAR 0 2
49249: PUSH
49250: LD_INT 4
49252: PLUS
49253: PUSH
49254: LD_INT 0
49256: PUSH
49257: EMPTY
49258: LIST
49259: LIST
49260: LIST
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: ST_TO_ADDR
// end ; 1 :
49269: GO 49969
49271: LD_INT 1
49273: DOUBLE
49274: EQUAL
49275: IFTRUE 49279
49277: GO 49412
49279: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49280: LD_ADDR_VAR 0 5
49284: PUSH
49285: LD_VAR 0 1
49289: PUSH
49290: LD_VAR 0 2
49294: PUSH
49295: LD_INT 4
49297: MINUS
49298: PUSH
49299: LD_INT 3
49301: PUSH
49302: EMPTY
49303: LIST
49304: LIST
49305: LIST
49306: PUSH
49307: LD_VAR 0 1
49311: PUSH
49312: LD_INT 3
49314: MINUS
49315: PUSH
49316: LD_VAR 0 2
49320: PUSH
49321: LD_INT 3
49323: MINUS
49324: PUSH
49325: LD_INT 2
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: PUSH
49333: LD_VAR 0 1
49337: PUSH
49338: LD_INT 4
49340: MINUS
49341: PUSH
49342: LD_VAR 0 2
49346: PUSH
49347: LD_INT 1
49349: PUSH
49350: EMPTY
49351: LIST
49352: LIST
49353: LIST
49354: PUSH
49355: LD_VAR 0 1
49359: PUSH
49360: LD_VAR 0 2
49364: PUSH
49365: LD_INT 3
49367: PLUS
49368: PUSH
49369: LD_INT 0
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: LIST
49376: PUSH
49377: LD_VAR 0 1
49381: PUSH
49382: LD_INT 4
49384: PLUS
49385: PUSH
49386: LD_VAR 0 2
49390: PUSH
49391: LD_INT 4
49393: PLUS
49394: PUSH
49395: LD_INT 5
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: LIST
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: ST_TO_ADDR
// end ; 2 :
49410: GO 49969
49412: LD_INT 2
49414: DOUBLE
49415: EQUAL
49416: IFTRUE 49420
49418: GO 49549
49420: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49421: LD_ADDR_VAR 0 5
49425: PUSH
49426: LD_VAR 0 1
49430: PUSH
49431: LD_VAR 0 2
49435: PUSH
49436: LD_INT 3
49438: MINUS
49439: PUSH
49440: LD_INT 3
49442: PUSH
49443: EMPTY
49444: LIST
49445: LIST
49446: LIST
49447: PUSH
49448: LD_VAR 0 1
49452: PUSH
49453: LD_INT 4
49455: PLUS
49456: PUSH
49457: LD_VAR 0 2
49461: PUSH
49462: LD_INT 4
49464: PUSH
49465: EMPTY
49466: LIST
49467: LIST
49468: LIST
49469: PUSH
49470: LD_VAR 0 1
49474: PUSH
49475: LD_VAR 0 2
49479: PUSH
49480: LD_INT 4
49482: PLUS
49483: PUSH
49484: LD_INT 0
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: LIST
49491: PUSH
49492: LD_VAR 0 1
49496: PUSH
49497: LD_INT 3
49499: MINUS
49500: PUSH
49501: LD_VAR 0 2
49505: PUSH
49506: LD_INT 1
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: LIST
49513: PUSH
49514: LD_VAR 0 1
49518: PUSH
49519: LD_INT 4
49521: MINUS
49522: PUSH
49523: LD_VAR 0 2
49527: PUSH
49528: LD_INT 4
49530: MINUS
49531: PUSH
49532: LD_INT 2
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: LIST
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: ST_TO_ADDR
// end ; 3 :
49547: GO 49969
49549: LD_INT 3
49551: DOUBLE
49552: EQUAL
49553: IFTRUE 49557
49555: GO 49690
49557: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49558: LD_ADDR_VAR 0 5
49562: PUSH
49563: LD_VAR 0 1
49567: PUSH
49568: LD_INT 3
49570: PLUS
49571: PUSH
49572: LD_VAR 0 2
49576: PUSH
49577: LD_INT 4
49579: PUSH
49580: EMPTY
49581: LIST
49582: LIST
49583: LIST
49584: PUSH
49585: LD_VAR 0 1
49589: PUSH
49590: LD_INT 4
49592: PLUS
49593: PUSH
49594: LD_VAR 0 2
49598: PUSH
49599: LD_INT 4
49601: PLUS
49602: PUSH
49603: LD_INT 5
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: LIST
49610: PUSH
49611: LD_VAR 0 1
49615: PUSH
49616: LD_INT 4
49618: MINUS
49619: PUSH
49620: LD_VAR 0 2
49624: PUSH
49625: LD_INT 1
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: LIST
49632: PUSH
49633: LD_VAR 0 1
49637: PUSH
49638: LD_VAR 0 2
49642: PUSH
49643: LD_INT 4
49645: MINUS
49646: PUSH
49647: LD_INT 3
49649: PUSH
49650: EMPTY
49651: LIST
49652: LIST
49653: LIST
49654: PUSH
49655: LD_VAR 0 1
49659: PUSH
49660: LD_INT 3
49662: MINUS
49663: PUSH
49664: LD_VAR 0 2
49668: PUSH
49669: LD_INT 3
49671: MINUS
49672: PUSH
49673: LD_INT 2
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: LIST
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: LIST
49687: ST_TO_ADDR
// end ; 4 :
49688: GO 49969
49690: LD_INT 4
49692: DOUBLE
49693: EQUAL
49694: IFTRUE 49698
49696: GO 49831
49698: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49699: LD_ADDR_VAR 0 5
49703: PUSH
49704: LD_VAR 0 1
49708: PUSH
49709: LD_VAR 0 2
49713: PUSH
49714: LD_INT 4
49716: PLUS
49717: PUSH
49718: LD_INT 0
49720: PUSH
49721: EMPTY
49722: LIST
49723: LIST
49724: LIST
49725: PUSH
49726: LD_VAR 0 1
49730: PUSH
49731: LD_INT 3
49733: PLUS
49734: PUSH
49735: LD_VAR 0 2
49739: PUSH
49740: LD_INT 3
49742: PLUS
49743: PUSH
49744: LD_INT 5
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: LIST
49751: PUSH
49752: LD_VAR 0 1
49756: PUSH
49757: LD_INT 4
49759: PLUS
49760: PUSH
49761: LD_VAR 0 2
49765: PUSH
49766: LD_INT 4
49768: PUSH
49769: EMPTY
49770: LIST
49771: LIST
49772: LIST
49773: PUSH
49774: LD_VAR 0 1
49778: PUSH
49779: LD_VAR 0 2
49783: PUSH
49784: LD_INT 3
49786: MINUS
49787: PUSH
49788: LD_INT 3
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: LIST
49795: PUSH
49796: LD_VAR 0 1
49800: PUSH
49801: LD_INT 4
49803: MINUS
49804: PUSH
49805: LD_VAR 0 2
49809: PUSH
49810: LD_INT 4
49812: MINUS
49813: PUSH
49814: LD_INT 2
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: LIST
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: ST_TO_ADDR
// end ; 5 :
49829: GO 49969
49831: LD_INT 5
49833: DOUBLE
49834: EQUAL
49835: IFTRUE 49839
49837: GO 49968
49839: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49840: LD_ADDR_VAR 0 5
49844: PUSH
49845: LD_VAR 0 1
49849: PUSH
49850: LD_INT 4
49852: MINUS
49853: PUSH
49854: LD_VAR 0 2
49858: PUSH
49859: LD_INT 1
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: LIST
49866: PUSH
49867: LD_VAR 0 1
49871: PUSH
49872: LD_VAR 0 2
49876: PUSH
49877: LD_INT 4
49879: MINUS
49880: PUSH
49881: LD_INT 3
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: LIST
49888: PUSH
49889: LD_VAR 0 1
49893: PUSH
49894: LD_INT 4
49896: PLUS
49897: PUSH
49898: LD_VAR 0 2
49902: PUSH
49903: LD_INT 4
49905: PLUS
49906: PUSH
49907: LD_INT 5
49909: PUSH
49910: EMPTY
49911: LIST
49912: LIST
49913: LIST
49914: PUSH
49915: LD_VAR 0 1
49919: PUSH
49920: LD_INT 3
49922: PLUS
49923: PUSH
49924: LD_VAR 0 2
49928: PUSH
49929: LD_INT 4
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: LIST
49936: PUSH
49937: LD_VAR 0 1
49941: PUSH
49942: LD_VAR 0 2
49946: PUSH
49947: LD_INT 3
49949: PLUS
49950: PUSH
49951: LD_INT 0
49953: PUSH
49954: EMPTY
49955: LIST
49956: LIST
49957: LIST
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: LIST
49963: LIST
49964: LIST
49965: ST_TO_ADDR
// end ; end ;
49966: GO 49969
49968: POP
// result := list ;
49969: LD_ADDR_VAR 0 4
49973: PUSH
49974: LD_VAR 0 5
49978: ST_TO_ADDR
// end ;
49979: LD_VAR 0 4
49983: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49984: LD_INT 0
49986: PPUSH
49987: PPUSH
49988: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49989: LD_VAR 0 1
49993: NOT
49994: PUSH
49995: LD_VAR 0 2
49999: PUSH
50000: LD_INT 1
50002: PUSH
50003: LD_INT 2
50005: PUSH
50006: LD_INT 3
50008: PUSH
50009: LD_INT 4
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: LIST
50016: LIST
50017: IN
50018: NOT
50019: OR
50020: IFFALSE 50024
// exit ;
50022: GO 50116
// tmp := [ ] ;
50024: LD_ADDR_VAR 0 5
50028: PUSH
50029: EMPTY
50030: ST_TO_ADDR
// for i in units do
50031: LD_ADDR_VAR 0 4
50035: PUSH
50036: LD_VAR 0 1
50040: PUSH
50041: FOR_IN
50042: IFFALSE 50085
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50044: LD_ADDR_VAR 0 5
50048: PUSH
50049: LD_VAR 0 5
50053: PPUSH
50054: LD_VAR 0 5
50058: PUSH
50059: LD_INT 1
50061: PLUS
50062: PPUSH
50063: LD_VAR 0 4
50067: PPUSH
50068: LD_VAR 0 2
50072: PPUSH
50073: CALL_OW 259
50077: PPUSH
50078: CALL_OW 2
50082: ST_TO_ADDR
50083: GO 50041
50085: POP
50086: POP
// if not tmp then
50087: LD_VAR 0 5
50091: NOT
50092: IFFALSE 50096
// exit ;
50094: GO 50116
// result := SortListByListDesc ( units , tmp ) ;
50096: LD_ADDR_VAR 0 3
50100: PUSH
50101: LD_VAR 0 1
50105: PPUSH
50106: LD_VAR 0 5
50110: PPUSH
50111: CALL_OW 77
50115: ST_TO_ADDR
// end ;
50116: LD_VAR 0 3
50120: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50121: LD_INT 0
50123: PPUSH
50124: PPUSH
50125: PPUSH
// result := false ;
50126: LD_ADDR_VAR 0 3
50130: PUSH
50131: LD_INT 0
50133: ST_TO_ADDR
// x := GetX ( building ) ;
50134: LD_ADDR_VAR 0 4
50138: PUSH
50139: LD_VAR 0 2
50143: PPUSH
50144: CALL_OW 250
50148: ST_TO_ADDR
// y := GetY ( building ) ;
50149: LD_ADDR_VAR 0 5
50153: PUSH
50154: LD_VAR 0 2
50158: PPUSH
50159: CALL_OW 251
50163: ST_TO_ADDR
// if not building or not x or not y then
50164: LD_VAR 0 2
50168: NOT
50169: PUSH
50170: LD_VAR 0 4
50174: NOT
50175: OR
50176: PUSH
50177: LD_VAR 0 5
50181: NOT
50182: OR
50183: IFFALSE 50187
// exit ;
50185: GO 50279
// if GetTaskList ( unit ) then
50187: LD_VAR 0 1
50191: PPUSH
50192: CALL_OW 437
50196: IFFALSE 50279
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50198: LD_STRING e
50200: PUSH
50201: LD_VAR 0 1
50205: PPUSH
50206: CALL_OW 437
50210: PUSH
50211: LD_INT 1
50213: ARRAY
50214: PUSH
50215: LD_INT 1
50217: ARRAY
50218: EQUAL
50219: PUSH
50220: LD_VAR 0 4
50224: PUSH
50225: LD_VAR 0 1
50229: PPUSH
50230: CALL_OW 437
50234: PUSH
50235: LD_INT 1
50237: ARRAY
50238: PUSH
50239: LD_INT 2
50241: ARRAY
50242: EQUAL
50243: AND
50244: PUSH
50245: LD_VAR 0 5
50249: PUSH
50250: LD_VAR 0 1
50254: PPUSH
50255: CALL_OW 437
50259: PUSH
50260: LD_INT 1
50262: ARRAY
50263: PUSH
50264: LD_INT 3
50266: ARRAY
50267: EQUAL
50268: AND
50269: IFFALSE 50279
// result := true end ;
50271: LD_ADDR_VAR 0 3
50275: PUSH
50276: LD_INT 1
50278: ST_TO_ADDR
// end ;
50279: LD_VAR 0 3
50283: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50284: LD_INT 0
50286: PPUSH
// result := false ;
50287: LD_ADDR_VAR 0 4
50291: PUSH
50292: LD_INT 0
50294: ST_TO_ADDR
// if GetTaskList ( unit ) then
50295: LD_VAR 0 1
50299: PPUSH
50300: CALL_OW 437
50304: IFFALSE 50387
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50306: LD_STRING M
50308: PUSH
50309: LD_VAR 0 1
50313: PPUSH
50314: CALL_OW 437
50318: PUSH
50319: LD_INT 1
50321: ARRAY
50322: PUSH
50323: LD_INT 1
50325: ARRAY
50326: EQUAL
50327: PUSH
50328: LD_VAR 0 2
50332: PUSH
50333: LD_VAR 0 1
50337: PPUSH
50338: CALL_OW 437
50342: PUSH
50343: LD_INT 1
50345: ARRAY
50346: PUSH
50347: LD_INT 2
50349: ARRAY
50350: EQUAL
50351: AND
50352: PUSH
50353: LD_VAR 0 3
50357: PUSH
50358: LD_VAR 0 1
50362: PPUSH
50363: CALL_OW 437
50367: PUSH
50368: LD_INT 1
50370: ARRAY
50371: PUSH
50372: LD_INT 3
50374: ARRAY
50375: EQUAL
50376: AND
50377: IFFALSE 50387
// result := true ;
50379: LD_ADDR_VAR 0 4
50383: PUSH
50384: LD_INT 1
50386: ST_TO_ADDR
// end ; end ;
50387: LD_VAR 0 4
50391: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50392: LD_INT 0
50394: PPUSH
50395: PPUSH
50396: PPUSH
50397: PPUSH
// if not unit or not area then
50398: LD_VAR 0 1
50402: NOT
50403: PUSH
50404: LD_VAR 0 2
50408: NOT
50409: OR
50410: IFFALSE 50414
// exit ;
50412: GO 50578
// tmp := AreaToList ( area , i ) ;
50414: LD_ADDR_VAR 0 6
50418: PUSH
50419: LD_VAR 0 2
50423: PPUSH
50424: LD_VAR 0 5
50428: PPUSH
50429: CALL_OW 517
50433: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50434: LD_ADDR_VAR 0 5
50438: PUSH
50439: DOUBLE
50440: LD_INT 1
50442: DEC
50443: ST_TO_ADDR
50444: LD_VAR 0 6
50448: PUSH
50449: LD_INT 1
50451: ARRAY
50452: PUSH
50453: FOR_TO
50454: IFFALSE 50576
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50456: LD_ADDR_VAR 0 7
50460: PUSH
50461: LD_VAR 0 6
50465: PUSH
50466: LD_INT 1
50468: ARRAY
50469: PUSH
50470: LD_VAR 0 5
50474: ARRAY
50475: PUSH
50476: LD_VAR 0 6
50480: PUSH
50481: LD_INT 2
50483: ARRAY
50484: PUSH
50485: LD_VAR 0 5
50489: ARRAY
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50495: LD_VAR 0 7
50499: PUSH
50500: LD_INT 1
50502: ARRAY
50503: PPUSH
50504: LD_VAR 0 7
50508: PUSH
50509: LD_INT 2
50511: ARRAY
50512: PPUSH
50513: CALL_OW 428
50517: PUSH
50518: LD_INT 0
50520: EQUAL
50521: IFFALSE 50574
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50523: LD_VAR 0 1
50527: PPUSH
50528: LD_VAR 0 7
50532: PUSH
50533: LD_INT 1
50535: ARRAY
50536: PPUSH
50537: LD_VAR 0 7
50541: PUSH
50542: LD_INT 2
50544: ARRAY
50545: PPUSH
50546: LD_VAR 0 3
50550: PPUSH
50551: CALL_OW 48
// result := IsPlaced ( unit ) ;
50555: LD_ADDR_VAR 0 4
50559: PUSH
50560: LD_VAR 0 1
50564: PPUSH
50565: CALL_OW 305
50569: ST_TO_ADDR
// exit ;
50570: POP
50571: POP
50572: GO 50578
// end ; end ;
50574: GO 50453
50576: POP
50577: POP
// end ;
50578: LD_VAR 0 4
50582: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50583: LD_INT 0
50585: PPUSH
50586: PPUSH
50587: PPUSH
// if not side or side > 8 then
50588: LD_VAR 0 1
50592: NOT
50593: PUSH
50594: LD_VAR 0 1
50598: PUSH
50599: LD_INT 8
50601: GREATER
50602: OR
50603: IFFALSE 50607
// exit ;
50605: GO 50794
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50607: LD_ADDR_VAR 0 4
50611: PUSH
50612: LD_INT 22
50614: PUSH
50615: LD_VAR 0 1
50619: PUSH
50620: EMPTY
50621: LIST
50622: LIST
50623: PUSH
50624: LD_INT 21
50626: PUSH
50627: LD_INT 3
50629: PUSH
50630: EMPTY
50631: LIST
50632: LIST
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: PPUSH
50638: CALL_OW 69
50642: ST_TO_ADDR
// if not tmp then
50643: LD_VAR 0 4
50647: NOT
50648: IFFALSE 50652
// exit ;
50650: GO 50794
// enable_addtolog := true ;
50652: LD_ADDR_OWVAR 81
50656: PUSH
50657: LD_INT 1
50659: ST_TO_ADDR
// AddToLog ( [ ) ;
50660: LD_STRING [
50662: PPUSH
50663: CALL_OW 561
// for i in tmp do
50667: LD_ADDR_VAR 0 3
50671: PUSH
50672: LD_VAR 0 4
50676: PUSH
50677: FOR_IN
50678: IFFALSE 50785
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50680: LD_STRING [
50682: PUSH
50683: LD_VAR 0 3
50687: PPUSH
50688: CALL_OW 266
50692: STR
50693: PUSH
50694: LD_STRING , 
50696: STR
50697: PUSH
50698: LD_VAR 0 3
50702: PPUSH
50703: CALL_OW 250
50707: STR
50708: PUSH
50709: LD_STRING , 
50711: STR
50712: PUSH
50713: LD_VAR 0 3
50717: PPUSH
50718: CALL_OW 251
50722: STR
50723: PUSH
50724: LD_STRING , 
50726: STR
50727: PUSH
50728: LD_VAR 0 3
50732: PPUSH
50733: CALL_OW 254
50737: STR
50738: PUSH
50739: LD_STRING , 
50741: STR
50742: PUSH
50743: LD_VAR 0 3
50747: PPUSH
50748: LD_INT 1
50750: PPUSH
50751: CALL_OW 268
50755: STR
50756: PUSH
50757: LD_STRING , 
50759: STR
50760: PUSH
50761: LD_VAR 0 3
50765: PPUSH
50766: LD_INT 2
50768: PPUSH
50769: CALL_OW 268
50773: STR
50774: PUSH
50775: LD_STRING ],
50777: STR
50778: PPUSH
50779: CALL_OW 561
// end ;
50783: GO 50677
50785: POP
50786: POP
// AddToLog ( ]; ) ;
50787: LD_STRING ];
50789: PPUSH
50790: CALL_OW 561
// end ;
50794: LD_VAR 0 2
50798: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50799: LD_INT 0
50801: PPUSH
50802: PPUSH
50803: PPUSH
50804: PPUSH
50805: PPUSH
// if not area or not rate or not max then
50806: LD_VAR 0 1
50810: NOT
50811: PUSH
50812: LD_VAR 0 2
50816: NOT
50817: OR
50818: PUSH
50819: LD_VAR 0 4
50823: NOT
50824: OR
50825: IFFALSE 50829
// exit ;
50827: GO 51021
// while 1 do
50829: LD_INT 1
50831: IFFALSE 51021
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50833: LD_ADDR_VAR 0 9
50837: PUSH
50838: LD_VAR 0 1
50842: PPUSH
50843: LD_INT 1
50845: PPUSH
50846: CALL_OW 287
50850: PUSH
50851: LD_INT 10
50853: MUL
50854: ST_TO_ADDR
// r := rate / 10 ;
50855: LD_ADDR_VAR 0 7
50859: PUSH
50860: LD_VAR 0 2
50864: PUSH
50865: LD_INT 10
50867: DIVREAL
50868: ST_TO_ADDR
// time := 1 1$00 ;
50869: LD_ADDR_VAR 0 8
50873: PUSH
50874: LD_INT 2100
50876: ST_TO_ADDR
// if amount < min then
50877: LD_VAR 0 9
50881: PUSH
50882: LD_VAR 0 3
50886: LESS
50887: IFFALSE 50905
// r := r * 2 else
50889: LD_ADDR_VAR 0 7
50893: PUSH
50894: LD_VAR 0 7
50898: PUSH
50899: LD_INT 2
50901: MUL
50902: ST_TO_ADDR
50903: GO 50931
// if amount > max then
50905: LD_VAR 0 9
50909: PUSH
50910: LD_VAR 0 4
50914: GREATER
50915: IFFALSE 50931
// r := r / 2 ;
50917: LD_ADDR_VAR 0 7
50921: PUSH
50922: LD_VAR 0 7
50926: PUSH
50927: LD_INT 2
50929: DIVREAL
50930: ST_TO_ADDR
// time := time / r ;
50931: LD_ADDR_VAR 0 8
50935: PUSH
50936: LD_VAR 0 8
50940: PUSH
50941: LD_VAR 0 7
50945: DIVREAL
50946: ST_TO_ADDR
// if time < 0 then
50947: LD_VAR 0 8
50951: PUSH
50952: LD_INT 0
50954: LESS
50955: IFFALSE 50972
// time := time * - 1 ;
50957: LD_ADDR_VAR 0 8
50961: PUSH
50962: LD_VAR 0 8
50966: PUSH
50967: LD_INT 1
50969: NEG
50970: MUL
50971: ST_TO_ADDR
// wait ( time ) ;
50972: LD_VAR 0 8
50976: PPUSH
50977: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50981: LD_INT 35
50983: PPUSH
50984: LD_INT 875
50986: PPUSH
50987: CALL_OW 12
50991: PPUSH
50992: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50996: LD_INT 1
50998: PPUSH
50999: LD_INT 5
51001: PPUSH
51002: CALL_OW 12
51006: PPUSH
51007: LD_VAR 0 1
51011: PPUSH
51012: LD_INT 1
51014: PPUSH
51015: CALL_OW 55
// end ;
51019: GO 50829
// end ;
51021: LD_VAR 0 5
51025: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51026: LD_INT 0
51028: PPUSH
51029: PPUSH
51030: PPUSH
51031: PPUSH
51032: PPUSH
51033: PPUSH
51034: PPUSH
51035: PPUSH
// if not turrets or not factories then
51036: LD_VAR 0 1
51040: NOT
51041: PUSH
51042: LD_VAR 0 2
51046: NOT
51047: OR
51048: IFFALSE 51052
// exit ;
51050: GO 51359
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51052: LD_ADDR_VAR 0 10
51056: PUSH
51057: LD_INT 5
51059: PUSH
51060: LD_INT 6
51062: PUSH
51063: EMPTY
51064: LIST
51065: LIST
51066: PUSH
51067: LD_INT 2
51069: PUSH
51070: LD_INT 4
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: PUSH
51077: LD_INT 3
51079: PUSH
51080: LD_INT 5
51082: PUSH
51083: EMPTY
51084: LIST
51085: LIST
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: LIST
51091: PUSH
51092: LD_INT 24
51094: PUSH
51095: LD_INT 25
51097: PUSH
51098: EMPTY
51099: LIST
51100: LIST
51101: PUSH
51102: LD_INT 23
51104: PUSH
51105: LD_INT 27
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: LD_INT 42
51118: PUSH
51119: LD_INT 43
51121: PUSH
51122: EMPTY
51123: LIST
51124: LIST
51125: PUSH
51126: LD_INT 44
51128: PUSH
51129: LD_INT 46
51131: PUSH
51132: EMPTY
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 45
51138: PUSH
51139: LD_INT 47
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: LIST
51150: PUSH
51151: EMPTY
51152: LIST
51153: LIST
51154: LIST
51155: ST_TO_ADDR
// result := [ ] ;
51156: LD_ADDR_VAR 0 3
51160: PUSH
51161: EMPTY
51162: ST_TO_ADDR
// for i in turrets do
51163: LD_ADDR_VAR 0 4
51167: PUSH
51168: LD_VAR 0 1
51172: PUSH
51173: FOR_IN
51174: IFFALSE 51357
// begin nat := GetNation ( i ) ;
51176: LD_ADDR_VAR 0 7
51180: PUSH
51181: LD_VAR 0 4
51185: PPUSH
51186: CALL_OW 248
51190: ST_TO_ADDR
// weapon := 0 ;
51191: LD_ADDR_VAR 0 8
51195: PUSH
51196: LD_INT 0
51198: ST_TO_ADDR
// if not nat then
51199: LD_VAR 0 7
51203: NOT
51204: IFFALSE 51208
// continue ;
51206: GO 51173
// for j in list [ nat ] do
51208: LD_ADDR_VAR 0 5
51212: PUSH
51213: LD_VAR 0 10
51217: PUSH
51218: LD_VAR 0 7
51222: ARRAY
51223: PUSH
51224: FOR_IN
51225: IFFALSE 51266
// if GetBWeapon ( i ) = j [ 1 ] then
51227: LD_VAR 0 4
51231: PPUSH
51232: CALL_OW 269
51236: PUSH
51237: LD_VAR 0 5
51241: PUSH
51242: LD_INT 1
51244: ARRAY
51245: EQUAL
51246: IFFALSE 51264
// begin weapon := j [ 2 ] ;
51248: LD_ADDR_VAR 0 8
51252: PUSH
51253: LD_VAR 0 5
51257: PUSH
51258: LD_INT 2
51260: ARRAY
51261: ST_TO_ADDR
// break ;
51262: GO 51266
// end ;
51264: GO 51224
51266: POP
51267: POP
// if not weapon then
51268: LD_VAR 0 8
51272: NOT
51273: IFFALSE 51277
// continue ;
51275: GO 51173
// for k in factories do
51277: LD_ADDR_VAR 0 6
51281: PUSH
51282: LD_VAR 0 2
51286: PUSH
51287: FOR_IN
51288: IFFALSE 51353
// begin weapons := AvailableWeaponList ( k ) ;
51290: LD_ADDR_VAR 0 9
51294: PUSH
51295: LD_VAR 0 6
51299: PPUSH
51300: CALL_OW 478
51304: ST_TO_ADDR
// if not weapons then
51305: LD_VAR 0 9
51309: NOT
51310: IFFALSE 51314
// continue ;
51312: GO 51287
// if weapon in weapons then
51314: LD_VAR 0 8
51318: PUSH
51319: LD_VAR 0 9
51323: IN
51324: IFFALSE 51351
// begin result := [ i , weapon ] ;
51326: LD_ADDR_VAR 0 3
51330: PUSH
51331: LD_VAR 0 4
51335: PUSH
51336: LD_VAR 0 8
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: ST_TO_ADDR
// exit ;
51345: POP
51346: POP
51347: POP
51348: POP
51349: GO 51359
// end ; end ;
51351: GO 51287
51353: POP
51354: POP
// end ;
51355: GO 51173
51357: POP
51358: POP
// end ;
51359: LD_VAR 0 3
51363: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51364: LD_INT 0
51366: PPUSH
// if not side or side > 8 then
51367: LD_VAR 0 3
51371: NOT
51372: PUSH
51373: LD_VAR 0 3
51377: PUSH
51378: LD_INT 8
51380: GREATER
51381: OR
51382: IFFALSE 51386
// exit ;
51384: GO 51445
// if not range then
51386: LD_VAR 0 4
51390: NOT
51391: IFFALSE 51402
// range := - 12 ;
51393: LD_ADDR_VAR 0 4
51397: PUSH
51398: LD_INT 12
51400: NEG
51401: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51402: LD_VAR 0 1
51406: PPUSH
51407: LD_VAR 0 2
51411: PPUSH
51412: LD_VAR 0 3
51416: PPUSH
51417: LD_VAR 0 4
51421: PPUSH
51422: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51426: LD_VAR 0 1
51430: PPUSH
51431: LD_VAR 0 2
51435: PPUSH
51436: LD_VAR 0 3
51440: PPUSH
51441: CALL_OW 331
// end ;
51445: LD_VAR 0 5
51449: RET
// export function Video ( mode ) ; begin
51450: LD_INT 0
51452: PPUSH
// ingame_video = mode ;
51453: LD_ADDR_OWVAR 52
51457: PUSH
51458: LD_VAR 0 1
51462: ST_TO_ADDR
// interface_hidden = mode ;
51463: LD_ADDR_OWVAR 54
51467: PUSH
51468: LD_VAR 0 1
51472: ST_TO_ADDR
// end ;
51473: LD_VAR 0 2
51477: RET
// export function Join ( array , element ) ; begin
51478: LD_INT 0
51480: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51481: LD_ADDR_VAR 0 3
51485: PUSH
51486: LD_VAR 0 1
51490: PPUSH
51491: LD_VAR 0 1
51495: PUSH
51496: LD_INT 1
51498: PLUS
51499: PPUSH
51500: LD_VAR 0 2
51504: PPUSH
51505: CALL_OW 1
51509: ST_TO_ADDR
// end ;
51510: LD_VAR 0 3
51514: RET
// export function JoinUnion ( array , element ) ; begin
51515: LD_INT 0
51517: PPUSH
// result := array union element ;
51518: LD_ADDR_VAR 0 3
51522: PUSH
51523: LD_VAR 0 1
51527: PUSH
51528: LD_VAR 0 2
51532: UNION
51533: ST_TO_ADDR
// end ;
51534: LD_VAR 0 3
51538: RET
// export function GetBehemoths ( side ) ; begin
51539: LD_INT 0
51541: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51542: LD_ADDR_VAR 0 2
51546: PUSH
51547: LD_INT 22
51549: PUSH
51550: LD_VAR 0 1
51554: PUSH
51555: EMPTY
51556: LIST
51557: LIST
51558: PUSH
51559: LD_INT 31
51561: PUSH
51562: LD_INT 25
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: PPUSH
51573: CALL_OW 69
51577: ST_TO_ADDR
// end ;
51578: LD_VAR 0 2
51582: RET
// export function Shuffle ( array ) ; var i , index ; begin
51583: LD_INT 0
51585: PPUSH
51586: PPUSH
51587: PPUSH
// result := [ ] ;
51588: LD_ADDR_VAR 0 2
51592: PUSH
51593: EMPTY
51594: ST_TO_ADDR
// if not array then
51595: LD_VAR 0 1
51599: NOT
51600: IFFALSE 51604
// exit ;
51602: GO 51703
// Randomize ;
51604: CALL_OW 10
// for i = array downto 1 do
51608: LD_ADDR_VAR 0 3
51612: PUSH
51613: DOUBLE
51614: LD_VAR 0 1
51618: INC
51619: ST_TO_ADDR
51620: LD_INT 1
51622: PUSH
51623: FOR_DOWNTO
51624: IFFALSE 51701
// begin index := rand ( 1 , array ) ;
51626: LD_ADDR_VAR 0 4
51630: PUSH
51631: LD_INT 1
51633: PPUSH
51634: LD_VAR 0 1
51638: PPUSH
51639: CALL_OW 12
51643: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51644: LD_ADDR_VAR 0 2
51648: PUSH
51649: LD_VAR 0 2
51653: PPUSH
51654: LD_VAR 0 2
51658: PUSH
51659: LD_INT 1
51661: PLUS
51662: PPUSH
51663: LD_VAR 0 1
51667: PUSH
51668: LD_VAR 0 4
51672: ARRAY
51673: PPUSH
51674: CALL_OW 2
51678: ST_TO_ADDR
// array := Delete ( array , index ) ;
51679: LD_ADDR_VAR 0 1
51683: PUSH
51684: LD_VAR 0 1
51688: PPUSH
51689: LD_VAR 0 4
51693: PPUSH
51694: CALL_OW 3
51698: ST_TO_ADDR
// end ;
51699: GO 51623
51701: POP
51702: POP
// end ;
51703: LD_VAR 0 2
51707: RET
// export function GetBaseMaterials ( base ) ; begin
51708: LD_INT 0
51710: PPUSH
// result := [ 0 , 0 , 0 ] ;
51711: LD_ADDR_VAR 0 2
51715: PUSH
51716: LD_INT 0
51718: PUSH
51719: LD_INT 0
51721: PUSH
51722: LD_INT 0
51724: PUSH
51725: EMPTY
51726: LIST
51727: LIST
51728: LIST
51729: ST_TO_ADDR
// if not base then
51730: LD_VAR 0 1
51734: NOT
51735: IFFALSE 51739
// exit ;
51737: GO 51788
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51739: LD_ADDR_VAR 0 2
51743: PUSH
51744: LD_VAR 0 1
51748: PPUSH
51749: LD_INT 1
51751: PPUSH
51752: CALL_OW 275
51756: PUSH
51757: LD_VAR 0 1
51761: PPUSH
51762: LD_INT 2
51764: PPUSH
51765: CALL_OW 275
51769: PUSH
51770: LD_VAR 0 1
51774: PPUSH
51775: LD_INT 3
51777: PPUSH
51778: CALL_OW 275
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: LIST
51787: ST_TO_ADDR
// end ;
51788: LD_VAR 0 2
51792: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51793: LD_INT 0
51795: PPUSH
51796: PPUSH
// result := array ;
51797: LD_ADDR_VAR 0 3
51801: PUSH
51802: LD_VAR 0 1
51806: ST_TO_ADDR
// if size > 0 then
51807: LD_VAR 0 2
51811: PUSH
51812: LD_INT 0
51814: GREATER
51815: IFFALSE 51861
// for i := array downto size do
51817: LD_ADDR_VAR 0 4
51821: PUSH
51822: DOUBLE
51823: LD_VAR 0 1
51827: INC
51828: ST_TO_ADDR
51829: LD_VAR 0 2
51833: PUSH
51834: FOR_DOWNTO
51835: IFFALSE 51859
// result := Delete ( result , result ) ;
51837: LD_ADDR_VAR 0 3
51841: PUSH
51842: LD_VAR 0 3
51846: PPUSH
51847: LD_VAR 0 3
51851: PPUSH
51852: CALL_OW 3
51856: ST_TO_ADDR
51857: GO 51834
51859: POP
51860: POP
// end ;
51861: LD_VAR 0 3
51865: RET
// export function ComExit ( unit ) ; var tmp ; begin
51866: LD_INT 0
51868: PPUSH
51869: PPUSH
// if not IsInUnit ( unit ) then
51870: LD_VAR 0 1
51874: PPUSH
51875: CALL_OW 310
51879: NOT
51880: IFFALSE 51884
// exit ;
51882: GO 51944
// tmp := IsInUnit ( unit ) ;
51884: LD_ADDR_VAR 0 3
51888: PUSH
51889: LD_VAR 0 1
51893: PPUSH
51894: CALL_OW 310
51898: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51899: LD_VAR 0 3
51903: PPUSH
51904: CALL_OW 247
51908: PUSH
51909: LD_INT 2
51911: EQUAL
51912: IFFALSE 51925
// ComExitVehicle ( unit ) else
51914: LD_VAR 0 1
51918: PPUSH
51919: CALL_OW 121
51923: GO 51934
// ComExitBuilding ( unit ) ;
51925: LD_VAR 0 1
51929: PPUSH
51930: CALL_OW 122
// result := tmp ;
51934: LD_ADDR_VAR 0 2
51938: PUSH
51939: LD_VAR 0 3
51943: ST_TO_ADDR
// end ;
51944: LD_VAR 0 2
51948: RET
// export function ComExitAll ( units ) ; var i ; begin
51949: LD_INT 0
51951: PPUSH
51952: PPUSH
// if not units then
51953: LD_VAR 0 1
51957: NOT
51958: IFFALSE 51962
// exit ;
51960: GO 51988
// for i in units do
51962: LD_ADDR_VAR 0 3
51966: PUSH
51967: LD_VAR 0 1
51971: PUSH
51972: FOR_IN
51973: IFFALSE 51986
// ComExit ( i ) ;
51975: LD_VAR 0 3
51979: PPUSH
51980: CALL 51866 0 1
51984: GO 51972
51986: POP
51987: POP
// end ;
51988: LD_VAR 0 2
51992: RET
// export function ResetHc ; begin
51993: LD_INT 0
51995: PPUSH
// InitHc ;
51996: CALL_OW 19
// hc_importance := 0 ;
52000: LD_ADDR_OWVAR 32
52004: PUSH
52005: LD_INT 0
52007: ST_TO_ADDR
// end ;
52008: LD_VAR 0 1
52012: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52013: LD_INT 0
52015: PPUSH
52016: PPUSH
52017: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52018: LD_ADDR_VAR 0 6
52022: PUSH
52023: LD_VAR 0 1
52027: PUSH
52028: LD_VAR 0 3
52032: PLUS
52033: PUSH
52034: LD_INT 2
52036: DIV
52037: ST_TO_ADDR
// if _x < 0 then
52038: LD_VAR 0 6
52042: PUSH
52043: LD_INT 0
52045: LESS
52046: IFFALSE 52063
// _x := _x * - 1 ;
52048: LD_ADDR_VAR 0 6
52052: PUSH
52053: LD_VAR 0 6
52057: PUSH
52058: LD_INT 1
52060: NEG
52061: MUL
52062: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52063: LD_ADDR_VAR 0 7
52067: PUSH
52068: LD_VAR 0 2
52072: PUSH
52073: LD_VAR 0 4
52077: PLUS
52078: PUSH
52079: LD_INT 2
52081: DIV
52082: ST_TO_ADDR
// if _y < 0 then
52083: LD_VAR 0 7
52087: PUSH
52088: LD_INT 0
52090: LESS
52091: IFFALSE 52108
// _y := _y * - 1 ;
52093: LD_ADDR_VAR 0 7
52097: PUSH
52098: LD_VAR 0 7
52102: PUSH
52103: LD_INT 1
52105: NEG
52106: MUL
52107: ST_TO_ADDR
// result := [ _x , _y ] ;
52108: LD_ADDR_VAR 0 5
52112: PUSH
52113: LD_VAR 0 6
52117: PUSH
52118: LD_VAR 0 7
52122: PUSH
52123: EMPTY
52124: LIST
52125: LIST
52126: ST_TO_ADDR
// end ;
52127: LD_VAR 0 5
52131: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52132: LD_INT 0
52134: PPUSH
52135: PPUSH
52136: PPUSH
52137: PPUSH
// task := GetTaskList ( unit ) ;
52138: LD_ADDR_VAR 0 7
52142: PUSH
52143: LD_VAR 0 1
52147: PPUSH
52148: CALL_OW 437
52152: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52153: LD_VAR 0 7
52157: NOT
52158: PUSH
52159: LD_VAR 0 1
52163: PPUSH
52164: LD_VAR 0 2
52168: PPUSH
52169: CALL_OW 308
52173: NOT
52174: AND
52175: IFFALSE 52179
// exit ;
52177: GO 52297
// if IsInArea ( unit , area ) then
52179: LD_VAR 0 1
52183: PPUSH
52184: LD_VAR 0 2
52188: PPUSH
52189: CALL_OW 308
52193: IFFALSE 52211
// begin ComMoveToArea ( unit , goAway ) ;
52195: LD_VAR 0 1
52199: PPUSH
52200: LD_VAR 0 3
52204: PPUSH
52205: CALL_OW 113
// exit ;
52209: GO 52297
// end ; if task [ 1 ] [ 1 ] <> M then
52211: LD_VAR 0 7
52215: PUSH
52216: LD_INT 1
52218: ARRAY
52219: PUSH
52220: LD_INT 1
52222: ARRAY
52223: PUSH
52224: LD_STRING M
52226: NONEQUAL
52227: IFFALSE 52231
// exit ;
52229: GO 52297
// x := task [ 1 ] [ 2 ] ;
52231: LD_ADDR_VAR 0 5
52235: PUSH
52236: LD_VAR 0 7
52240: PUSH
52241: LD_INT 1
52243: ARRAY
52244: PUSH
52245: LD_INT 2
52247: ARRAY
52248: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52249: LD_ADDR_VAR 0 6
52253: PUSH
52254: LD_VAR 0 7
52258: PUSH
52259: LD_INT 1
52261: ARRAY
52262: PUSH
52263: LD_INT 3
52265: ARRAY
52266: ST_TO_ADDR
// if InArea ( x , y , area ) then
52267: LD_VAR 0 5
52271: PPUSH
52272: LD_VAR 0 6
52276: PPUSH
52277: LD_VAR 0 2
52281: PPUSH
52282: CALL_OW 309
52286: IFFALSE 52297
// ComStop ( unit ) ;
52288: LD_VAR 0 1
52292: PPUSH
52293: CALL_OW 141
// end ;
52297: LD_VAR 0 4
52301: RET
// export function Abs ( value ) ; begin
52302: LD_INT 0
52304: PPUSH
// result := value ;
52305: LD_ADDR_VAR 0 2
52309: PUSH
52310: LD_VAR 0 1
52314: ST_TO_ADDR
// if value < 0 then
52315: LD_VAR 0 1
52319: PUSH
52320: LD_INT 0
52322: LESS
52323: IFFALSE 52340
// result := value * - 1 ;
52325: LD_ADDR_VAR 0 2
52329: PUSH
52330: LD_VAR 0 1
52334: PUSH
52335: LD_INT 1
52337: NEG
52338: MUL
52339: ST_TO_ADDR
// end ;
52340: LD_VAR 0 2
52344: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52345: LD_INT 0
52347: PPUSH
52348: PPUSH
52349: PPUSH
52350: PPUSH
52351: PPUSH
52352: PPUSH
52353: PPUSH
52354: PPUSH
// if not unit or not building then
52355: LD_VAR 0 1
52359: NOT
52360: PUSH
52361: LD_VAR 0 2
52365: NOT
52366: OR
52367: IFFALSE 52371
// exit ;
52369: GO 52597
// x := GetX ( building ) ;
52371: LD_ADDR_VAR 0 4
52375: PUSH
52376: LD_VAR 0 2
52380: PPUSH
52381: CALL_OW 250
52385: ST_TO_ADDR
// y := GetY ( building ) ;
52386: LD_ADDR_VAR 0 6
52390: PUSH
52391: LD_VAR 0 2
52395: PPUSH
52396: CALL_OW 251
52400: ST_TO_ADDR
// d := GetDir ( building ) ;
52401: LD_ADDR_VAR 0 8
52405: PUSH
52406: LD_VAR 0 2
52410: PPUSH
52411: CALL_OW 254
52415: ST_TO_ADDR
// r := 4 ;
52416: LD_ADDR_VAR 0 9
52420: PUSH
52421: LD_INT 4
52423: ST_TO_ADDR
// for i := 1 to 5 do
52424: LD_ADDR_VAR 0 10
52428: PUSH
52429: DOUBLE
52430: LD_INT 1
52432: DEC
52433: ST_TO_ADDR
52434: LD_INT 5
52436: PUSH
52437: FOR_TO
52438: IFFALSE 52595
// begin _x := ShiftX ( x , d , r + i ) ;
52440: LD_ADDR_VAR 0 5
52444: PUSH
52445: LD_VAR 0 4
52449: PPUSH
52450: LD_VAR 0 8
52454: PPUSH
52455: LD_VAR 0 9
52459: PUSH
52460: LD_VAR 0 10
52464: PLUS
52465: PPUSH
52466: CALL_OW 272
52470: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52471: LD_ADDR_VAR 0 7
52475: PUSH
52476: LD_VAR 0 6
52480: PPUSH
52481: LD_VAR 0 8
52485: PPUSH
52486: LD_VAR 0 9
52490: PUSH
52491: LD_VAR 0 10
52495: PLUS
52496: PPUSH
52497: CALL_OW 273
52501: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52502: LD_VAR 0 5
52506: PPUSH
52507: LD_VAR 0 7
52511: PPUSH
52512: CALL_OW 488
52516: PUSH
52517: LD_VAR 0 5
52521: PPUSH
52522: LD_VAR 0 7
52526: PPUSH
52527: CALL_OW 428
52531: PPUSH
52532: CALL_OW 247
52536: PUSH
52537: LD_INT 3
52539: PUSH
52540: LD_INT 2
52542: PUSH
52543: EMPTY
52544: LIST
52545: LIST
52546: IN
52547: NOT
52548: AND
52549: IFFALSE 52593
// begin ComMoveXY ( unit , _x , _y ) ;
52551: LD_VAR 0 1
52555: PPUSH
52556: LD_VAR 0 5
52560: PPUSH
52561: LD_VAR 0 7
52565: PPUSH
52566: CALL_OW 111
// result := [ _x , _y ] ;
52570: LD_ADDR_VAR 0 3
52574: PUSH
52575: LD_VAR 0 5
52579: PUSH
52580: LD_VAR 0 7
52584: PUSH
52585: EMPTY
52586: LIST
52587: LIST
52588: ST_TO_ADDR
// exit ;
52589: POP
52590: POP
52591: GO 52597
// end ; end ;
52593: GO 52437
52595: POP
52596: POP
// end ;
52597: LD_VAR 0 3
52601: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52602: LD_INT 0
52604: PPUSH
52605: PPUSH
52606: PPUSH
// result := 0 ;
52607: LD_ADDR_VAR 0 3
52611: PUSH
52612: LD_INT 0
52614: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52615: LD_VAR 0 1
52619: PUSH
52620: LD_INT 0
52622: LESS
52623: PUSH
52624: LD_VAR 0 1
52628: PUSH
52629: LD_INT 8
52631: GREATER
52632: OR
52633: PUSH
52634: LD_VAR 0 2
52638: PUSH
52639: LD_INT 0
52641: LESS
52642: OR
52643: PUSH
52644: LD_VAR 0 2
52648: PUSH
52649: LD_INT 8
52651: GREATER
52652: OR
52653: IFFALSE 52657
// exit ;
52655: GO 52732
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52657: LD_ADDR_VAR 0 4
52661: PUSH
52662: LD_INT 22
52664: PUSH
52665: LD_VAR 0 2
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: PPUSH
52674: CALL_OW 69
52678: PUSH
52679: FOR_IN
52680: IFFALSE 52730
// begin un := UnitShoot ( i ) ;
52682: LD_ADDR_VAR 0 5
52686: PUSH
52687: LD_VAR 0 4
52691: PPUSH
52692: CALL_OW 504
52696: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52697: LD_VAR 0 5
52701: PPUSH
52702: CALL_OW 255
52706: PUSH
52707: LD_VAR 0 1
52711: EQUAL
52712: IFFALSE 52728
// begin result := un ;
52714: LD_ADDR_VAR 0 3
52718: PUSH
52719: LD_VAR 0 5
52723: ST_TO_ADDR
// exit ;
52724: POP
52725: POP
52726: GO 52732
// end ; end ;
52728: GO 52679
52730: POP
52731: POP
// end ;
52732: LD_VAR 0 3
52736: RET
// export function GetCargoBay ( units ) ; begin
52737: LD_INT 0
52739: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52740: LD_ADDR_VAR 0 2
52744: PUSH
52745: LD_VAR 0 1
52749: PPUSH
52750: LD_INT 2
52752: PUSH
52753: LD_INT 34
52755: PUSH
52756: LD_INT 12
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: PUSH
52763: LD_INT 34
52765: PUSH
52766: LD_INT 51
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: PUSH
52773: LD_INT 34
52775: PUSH
52776: LD_INT 32
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: PUSH
52783: LD_INT 34
52785: PUSH
52786: LD_EXP 104
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: PUSH
52795: EMPTY
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: PPUSH
52802: CALL_OW 72
52806: ST_TO_ADDR
// end ;
52807: LD_VAR 0 2
52811: RET
// export function Negate ( value ) ; begin
52812: LD_INT 0
52814: PPUSH
// result := not value ;
52815: LD_ADDR_VAR 0 2
52819: PUSH
52820: LD_VAR 0 1
52824: NOT
52825: ST_TO_ADDR
// end ;
52826: LD_VAR 0 2
52830: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
52831: LD_INT 0
52833: PPUSH
// if x1 = x2 then
52834: LD_VAR 0 1
52838: PUSH
52839: LD_VAR 0 3
52843: EQUAL
52844: IFFALSE 52878
// begin if y1 > y2 then
52846: LD_VAR 0 2
52850: PUSH
52851: LD_VAR 0 4
52855: GREATER
52856: IFFALSE 52868
// result := 0 else
52858: LD_ADDR_VAR 0 5
52862: PUSH
52863: LD_INT 0
52865: ST_TO_ADDR
52866: GO 52876
// result := 3 ;
52868: LD_ADDR_VAR 0 5
52872: PUSH
52873: LD_INT 3
52875: ST_TO_ADDR
// exit ;
52876: GO 52964
// end ; if y1 = y2 then
52878: LD_VAR 0 2
52882: PUSH
52883: LD_VAR 0 4
52887: EQUAL
52888: IFFALSE 52922
// begin if x1 > x2 then
52890: LD_VAR 0 1
52894: PUSH
52895: LD_VAR 0 3
52899: GREATER
52900: IFFALSE 52912
// result := 1 else
52902: LD_ADDR_VAR 0 5
52906: PUSH
52907: LD_INT 1
52909: ST_TO_ADDR
52910: GO 52920
// result := 4 ;
52912: LD_ADDR_VAR 0 5
52916: PUSH
52917: LD_INT 4
52919: ST_TO_ADDR
// exit ;
52920: GO 52964
// end ; if x1 > x2 and y1 > y2 then
52922: LD_VAR 0 1
52926: PUSH
52927: LD_VAR 0 3
52931: GREATER
52932: PUSH
52933: LD_VAR 0 2
52937: PUSH
52938: LD_VAR 0 4
52942: GREATER
52943: AND
52944: IFFALSE 52956
// result := 2 else
52946: LD_ADDR_VAR 0 5
52950: PUSH
52951: LD_INT 2
52953: ST_TO_ADDR
52954: GO 52964
// result := 5 ;
52956: LD_ADDR_VAR 0 5
52960: PUSH
52961: LD_INT 5
52963: ST_TO_ADDR
// end ;
52964: LD_VAR 0 5
52968: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52969: LD_INT 0
52971: PPUSH
52972: PPUSH
// if not driver or not IsInUnit ( driver ) then
52973: LD_VAR 0 1
52977: NOT
52978: PUSH
52979: LD_VAR 0 1
52983: PPUSH
52984: CALL_OW 310
52988: NOT
52989: OR
52990: IFFALSE 52994
// exit ;
52992: GO 53084
// vehicle := IsInUnit ( driver ) ;
52994: LD_ADDR_VAR 0 3
52998: PUSH
52999: LD_VAR 0 1
53003: PPUSH
53004: CALL_OW 310
53008: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53009: LD_VAR 0 1
53013: PPUSH
53014: LD_STRING \
53016: PUSH
53017: LD_INT 0
53019: PUSH
53020: LD_INT 0
53022: PUSH
53023: LD_INT 0
53025: PUSH
53026: LD_INT 0
53028: PUSH
53029: LD_INT 0
53031: PUSH
53032: LD_INT 0
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: LIST
53041: LIST
53042: LIST
53043: PUSH
53044: LD_STRING E
53046: PUSH
53047: LD_INT 0
53049: PUSH
53050: LD_INT 0
53052: PUSH
53053: LD_VAR 0 3
53057: PUSH
53058: LD_INT 0
53060: PUSH
53061: LD_INT 0
53063: PUSH
53064: LD_INT 0
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: PPUSH
53080: CALL_OW 446
// end ;
53084: LD_VAR 0 2
53088: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53089: LD_INT 0
53091: PPUSH
53092: PPUSH
53093: PPUSH
// tmp := [ ] ;
53094: LD_ADDR_VAR 0 5
53098: PUSH
53099: EMPTY
53100: ST_TO_ADDR
// for i in units do
53101: LD_ADDR_VAR 0 4
53105: PUSH
53106: LD_VAR 0 1
53110: PUSH
53111: FOR_IN
53112: IFFALSE 53150
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53114: LD_ADDR_VAR 0 5
53118: PUSH
53119: LD_VAR 0 5
53123: PPUSH
53124: LD_VAR 0 5
53128: PUSH
53129: LD_INT 1
53131: PLUS
53132: PPUSH
53133: LD_VAR 0 4
53137: PPUSH
53138: CALL_OW 256
53142: PPUSH
53143: CALL_OW 2
53147: ST_TO_ADDR
53148: GO 53111
53150: POP
53151: POP
// if not tmp then
53152: LD_VAR 0 5
53156: NOT
53157: IFFALSE 53161
// exit ;
53159: GO 53209
// if asc then
53161: LD_VAR 0 2
53165: IFFALSE 53189
// result := SortListByListAsc ( units , tmp ) else
53167: LD_ADDR_VAR 0 3
53171: PUSH
53172: LD_VAR 0 1
53176: PPUSH
53177: LD_VAR 0 5
53181: PPUSH
53182: CALL_OW 76
53186: ST_TO_ADDR
53187: GO 53209
// result := SortListByListDesc ( units , tmp ) ;
53189: LD_ADDR_VAR 0 3
53193: PUSH
53194: LD_VAR 0 1
53198: PPUSH
53199: LD_VAR 0 5
53203: PPUSH
53204: CALL_OW 77
53208: ST_TO_ADDR
// end ; end_of_file
53209: LD_VAR 0 3
53213: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53214: LD_INT 0
53216: PPUSH
53217: PPUSH
// skirmish := false ;
53218: LD_ADDR_EXP 57
53222: PUSH
53223: LD_INT 0
53225: ST_TO_ADDR
// debug_mc := false ;
53226: LD_ADDR_EXP 58
53230: PUSH
53231: LD_INT 0
53233: ST_TO_ADDR
// mc_bases := [ ] ;
53234: LD_ADDR_EXP 59
53238: PUSH
53239: EMPTY
53240: ST_TO_ADDR
// mc_sides := [ ] ;
53241: LD_ADDR_EXP 85
53245: PUSH
53246: EMPTY
53247: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53248: LD_ADDR_EXP 60
53252: PUSH
53253: EMPTY
53254: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53255: LD_ADDR_EXP 61
53259: PUSH
53260: EMPTY
53261: ST_TO_ADDR
// mc_need_heal := [ ] ;
53262: LD_ADDR_EXP 62
53266: PUSH
53267: EMPTY
53268: ST_TO_ADDR
// mc_healers := [ ] ;
53269: LD_ADDR_EXP 63
53273: PUSH
53274: EMPTY
53275: ST_TO_ADDR
// mc_build_list := [ ] ;
53276: LD_ADDR_EXP 64
53280: PUSH
53281: EMPTY
53282: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53283: LD_ADDR_EXP 91
53287: PUSH
53288: EMPTY
53289: ST_TO_ADDR
// mc_builders := [ ] ;
53290: LD_ADDR_EXP 65
53294: PUSH
53295: EMPTY
53296: ST_TO_ADDR
// mc_construct_list := [ ] ;
53297: LD_ADDR_EXP 66
53301: PUSH
53302: EMPTY
53303: ST_TO_ADDR
// mc_turret_list := [ ] ;
53304: LD_ADDR_EXP 67
53308: PUSH
53309: EMPTY
53310: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53311: LD_ADDR_EXP 68
53315: PUSH
53316: EMPTY
53317: ST_TO_ADDR
// mc_miners := [ ] ;
53318: LD_ADDR_EXP 73
53322: PUSH
53323: EMPTY
53324: ST_TO_ADDR
// mc_mines := [ ] ;
53325: LD_ADDR_EXP 72
53329: PUSH
53330: EMPTY
53331: ST_TO_ADDR
// mc_minefields := [ ] ;
53332: LD_ADDR_EXP 74
53336: PUSH
53337: EMPTY
53338: ST_TO_ADDR
// mc_crates := [ ] ;
53339: LD_ADDR_EXP 75
53343: PUSH
53344: EMPTY
53345: ST_TO_ADDR
// mc_crates_collector := [ ] ;
53346: LD_ADDR_EXP 76
53350: PUSH
53351: EMPTY
53352: ST_TO_ADDR
// mc_crates_area := [ ] ;
53353: LD_ADDR_EXP 77
53357: PUSH
53358: EMPTY
53359: ST_TO_ADDR
// mc_vehicles := [ ] ;
53360: LD_ADDR_EXP 78
53364: PUSH
53365: EMPTY
53366: ST_TO_ADDR
// mc_attack := [ ] ;
53367: LD_ADDR_EXP 79
53371: PUSH
53372: EMPTY
53373: ST_TO_ADDR
// mc_produce := [ ] ;
53374: LD_ADDR_EXP 80
53378: PUSH
53379: EMPTY
53380: ST_TO_ADDR
// mc_defender := [ ] ;
53381: LD_ADDR_EXP 81
53385: PUSH
53386: EMPTY
53387: ST_TO_ADDR
// mc_parking := [ ] ;
53388: LD_ADDR_EXP 83
53392: PUSH
53393: EMPTY
53394: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
53395: LD_ADDR_EXP 69
53399: PUSH
53400: EMPTY
53401: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
53402: LD_ADDR_EXP 71
53406: PUSH
53407: EMPTY
53408: ST_TO_ADDR
// mc_scan := [ ] ;
53409: LD_ADDR_EXP 82
53413: PUSH
53414: EMPTY
53415: ST_TO_ADDR
// mc_scan_area := [ ] ;
53416: LD_ADDR_EXP 84
53420: PUSH
53421: EMPTY
53422: ST_TO_ADDR
// mc_tech := [ ] ;
53423: LD_ADDR_EXP 86
53427: PUSH
53428: EMPTY
53429: ST_TO_ADDR
// mc_class := [ ] ;
53430: LD_ADDR_EXP 100
53434: PUSH
53435: EMPTY
53436: ST_TO_ADDR
// mc_class_case_use := [ ] ;
53437: LD_ADDR_EXP 101
53441: PUSH
53442: EMPTY
53443: ST_TO_ADDR
// mc_is_defending := [ ] ;
53444: LD_ADDR_EXP 102
53448: PUSH
53449: EMPTY
53450: ST_TO_ADDR
// end ;
53451: LD_VAR 0 1
53455: RET
// export function MC_Kill ( base ) ; begin
53456: LD_INT 0
53458: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
53459: LD_ADDR_EXP 59
53463: PUSH
53464: LD_EXP 59
53468: PPUSH
53469: LD_VAR 0 1
53473: PPUSH
53474: EMPTY
53475: PPUSH
53476: CALL_OW 1
53480: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53481: LD_ADDR_EXP 60
53485: PUSH
53486: LD_EXP 60
53490: PPUSH
53491: LD_VAR 0 1
53495: PPUSH
53496: EMPTY
53497: PPUSH
53498: CALL_OW 1
53502: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53503: LD_ADDR_EXP 61
53507: PUSH
53508: LD_EXP 61
53512: PPUSH
53513: LD_VAR 0 1
53517: PPUSH
53518: EMPTY
53519: PPUSH
53520: CALL_OW 1
53524: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53525: LD_ADDR_EXP 62
53529: PUSH
53530: LD_EXP 62
53534: PPUSH
53535: LD_VAR 0 1
53539: PPUSH
53540: EMPTY
53541: PPUSH
53542: CALL_OW 1
53546: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53547: LD_ADDR_EXP 63
53551: PUSH
53552: LD_EXP 63
53556: PPUSH
53557: LD_VAR 0 1
53561: PPUSH
53562: EMPTY
53563: PPUSH
53564: CALL_OW 1
53568: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53569: LD_ADDR_EXP 64
53573: PUSH
53574: LD_EXP 64
53578: PPUSH
53579: LD_VAR 0 1
53583: PPUSH
53584: EMPTY
53585: PPUSH
53586: CALL_OW 1
53590: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53591: LD_ADDR_EXP 65
53595: PUSH
53596: LD_EXP 65
53600: PPUSH
53601: LD_VAR 0 1
53605: PPUSH
53606: EMPTY
53607: PPUSH
53608: CALL_OW 1
53612: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53613: LD_ADDR_EXP 66
53617: PUSH
53618: LD_EXP 66
53622: PPUSH
53623: LD_VAR 0 1
53627: PPUSH
53628: EMPTY
53629: PPUSH
53630: CALL_OW 1
53634: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53635: LD_ADDR_EXP 67
53639: PUSH
53640: LD_EXP 67
53644: PPUSH
53645: LD_VAR 0 1
53649: PPUSH
53650: EMPTY
53651: PPUSH
53652: CALL_OW 1
53656: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53657: LD_ADDR_EXP 68
53661: PUSH
53662: LD_EXP 68
53666: PPUSH
53667: LD_VAR 0 1
53671: PPUSH
53672: EMPTY
53673: PPUSH
53674: CALL_OW 1
53678: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53679: LD_ADDR_EXP 69
53683: PUSH
53684: LD_EXP 69
53688: PPUSH
53689: LD_VAR 0 1
53693: PPUSH
53694: EMPTY
53695: PPUSH
53696: CALL_OW 1
53700: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53701: LD_ADDR_EXP 70
53705: PUSH
53706: LD_EXP 70
53710: PPUSH
53711: LD_VAR 0 1
53715: PPUSH
53716: LD_INT 0
53718: PPUSH
53719: CALL_OW 1
53723: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53724: LD_ADDR_EXP 71
53728: PUSH
53729: LD_EXP 71
53733: PPUSH
53734: LD_VAR 0 1
53738: PPUSH
53739: EMPTY
53740: PPUSH
53741: CALL_OW 1
53745: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53746: LD_ADDR_EXP 72
53750: PUSH
53751: LD_EXP 72
53755: PPUSH
53756: LD_VAR 0 1
53760: PPUSH
53761: EMPTY
53762: PPUSH
53763: CALL_OW 1
53767: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53768: LD_ADDR_EXP 73
53772: PUSH
53773: LD_EXP 73
53777: PPUSH
53778: LD_VAR 0 1
53782: PPUSH
53783: EMPTY
53784: PPUSH
53785: CALL_OW 1
53789: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53790: LD_ADDR_EXP 74
53794: PUSH
53795: LD_EXP 74
53799: PPUSH
53800: LD_VAR 0 1
53804: PPUSH
53805: EMPTY
53806: PPUSH
53807: CALL_OW 1
53811: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53812: LD_ADDR_EXP 75
53816: PUSH
53817: LD_EXP 75
53821: PPUSH
53822: LD_VAR 0 1
53826: PPUSH
53827: EMPTY
53828: PPUSH
53829: CALL_OW 1
53833: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53834: LD_ADDR_EXP 76
53838: PUSH
53839: LD_EXP 76
53843: PPUSH
53844: LD_VAR 0 1
53848: PPUSH
53849: EMPTY
53850: PPUSH
53851: CALL_OW 1
53855: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53856: LD_ADDR_EXP 77
53860: PUSH
53861: LD_EXP 77
53865: PPUSH
53866: LD_VAR 0 1
53870: PPUSH
53871: EMPTY
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53878: LD_ADDR_EXP 78
53882: PUSH
53883: LD_EXP 78
53887: PPUSH
53888: LD_VAR 0 1
53892: PPUSH
53893: EMPTY
53894: PPUSH
53895: CALL_OW 1
53899: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53900: LD_ADDR_EXP 79
53904: PUSH
53905: LD_EXP 79
53909: PPUSH
53910: LD_VAR 0 1
53914: PPUSH
53915: EMPTY
53916: PPUSH
53917: CALL_OW 1
53921: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53922: LD_ADDR_EXP 80
53926: PUSH
53927: LD_EXP 80
53931: PPUSH
53932: LD_VAR 0 1
53936: PPUSH
53937: EMPTY
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53944: LD_ADDR_EXP 81
53948: PUSH
53949: LD_EXP 81
53953: PPUSH
53954: LD_VAR 0 1
53958: PPUSH
53959: EMPTY
53960: PPUSH
53961: CALL_OW 1
53965: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53966: LD_ADDR_EXP 82
53970: PUSH
53971: LD_EXP 82
53975: PPUSH
53976: LD_VAR 0 1
53980: PPUSH
53981: EMPTY
53982: PPUSH
53983: CALL_OW 1
53987: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53988: LD_ADDR_EXP 83
53992: PUSH
53993: LD_EXP 83
53997: PPUSH
53998: LD_VAR 0 1
54002: PPUSH
54003: EMPTY
54004: PPUSH
54005: CALL_OW 1
54009: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54010: LD_ADDR_EXP 84
54014: PUSH
54015: LD_EXP 84
54019: PPUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: EMPTY
54026: PPUSH
54027: CALL_OW 1
54031: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54032: LD_ADDR_EXP 86
54036: PUSH
54037: LD_EXP 86
54041: PPUSH
54042: LD_VAR 0 1
54046: PPUSH
54047: EMPTY
54048: PPUSH
54049: CALL_OW 1
54053: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54054: LD_ADDR_EXP 88
54058: PUSH
54059: LD_EXP 88
54063: PPUSH
54064: LD_VAR 0 1
54068: PPUSH
54069: EMPTY
54070: PPUSH
54071: CALL_OW 1
54075: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54076: LD_ADDR_EXP 89
54080: PUSH
54081: LD_EXP 89
54085: PPUSH
54086: LD_VAR 0 1
54090: PPUSH
54091: EMPTY
54092: PPUSH
54093: CALL_OW 1
54097: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54098: LD_ADDR_EXP 90
54102: PUSH
54103: LD_EXP 90
54107: PPUSH
54108: LD_VAR 0 1
54112: PPUSH
54113: EMPTY
54114: PPUSH
54115: CALL_OW 1
54119: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54120: LD_ADDR_EXP 91
54124: PUSH
54125: LD_EXP 91
54129: PPUSH
54130: LD_VAR 0 1
54134: PPUSH
54135: EMPTY
54136: PPUSH
54137: CALL_OW 1
54141: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54142: LD_ADDR_EXP 92
54146: PUSH
54147: LD_EXP 92
54151: PPUSH
54152: LD_VAR 0 1
54156: PPUSH
54157: EMPTY
54158: PPUSH
54159: CALL_OW 1
54163: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54164: LD_ADDR_EXP 93
54168: PUSH
54169: LD_EXP 93
54173: PPUSH
54174: LD_VAR 0 1
54178: PPUSH
54179: EMPTY
54180: PPUSH
54181: CALL_OW 1
54185: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54186: LD_ADDR_EXP 94
54190: PUSH
54191: LD_EXP 94
54195: PPUSH
54196: LD_VAR 0 1
54200: PPUSH
54201: EMPTY
54202: PPUSH
54203: CALL_OW 1
54207: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54208: LD_ADDR_EXP 95
54212: PUSH
54213: LD_EXP 95
54217: PPUSH
54218: LD_VAR 0 1
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54230: LD_ADDR_EXP 96
54234: PUSH
54235: LD_EXP 96
54239: PPUSH
54240: LD_VAR 0 1
54244: PPUSH
54245: EMPTY
54246: PPUSH
54247: CALL_OW 1
54251: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54252: LD_ADDR_EXP 97
54256: PUSH
54257: LD_EXP 97
54261: PPUSH
54262: LD_VAR 0 1
54266: PPUSH
54267: EMPTY
54268: PPUSH
54269: CALL_OW 1
54273: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54274: LD_ADDR_EXP 98
54278: PUSH
54279: LD_EXP 98
54283: PPUSH
54284: LD_VAR 0 1
54288: PPUSH
54289: EMPTY
54290: PPUSH
54291: CALL_OW 1
54295: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54296: LD_ADDR_EXP 99
54300: PUSH
54301: LD_EXP 99
54305: PPUSH
54306: LD_VAR 0 1
54310: PPUSH
54311: EMPTY
54312: PPUSH
54313: CALL_OW 1
54317: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54318: LD_ADDR_EXP 100
54322: PUSH
54323: LD_EXP 100
54327: PPUSH
54328: LD_VAR 0 1
54332: PPUSH
54333: EMPTY
54334: PPUSH
54335: CALL_OW 1
54339: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54340: LD_ADDR_EXP 101
54344: PUSH
54345: LD_EXP 101
54349: PPUSH
54350: LD_VAR 0 1
54354: PPUSH
54355: LD_INT 0
54357: PPUSH
54358: CALL_OW 1
54362: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54363: LD_ADDR_EXP 102
54367: PUSH
54368: LD_EXP 102
54372: PPUSH
54373: LD_VAR 0 1
54377: PPUSH
54378: LD_INT 0
54380: PPUSH
54381: CALL_OW 1
54385: ST_TO_ADDR
// end ;
54386: LD_VAR 0 2
54390: RET
// export function MC_Add ( side , units ) ; var base ; begin
54391: LD_INT 0
54393: PPUSH
54394: PPUSH
// base := mc_bases + 1 ;
54395: LD_ADDR_VAR 0 4
54399: PUSH
54400: LD_EXP 59
54404: PUSH
54405: LD_INT 1
54407: PLUS
54408: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
54409: LD_ADDR_EXP 85
54413: PUSH
54414: LD_EXP 85
54418: PPUSH
54419: LD_VAR 0 4
54423: PPUSH
54424: LD_VAR 0 1
54428: PPUSH
54429: CALL_OW 1
54433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
54434: LD_ADDR_EXP 59
54438: PUSH
54439: LD_EXP 59
54443: PPUSH
54444: LD_VAR 0 4
54448: PPUSH
54449: LD_VAR 0 2
54453: PPUSH
54454: CALL_OW 1
54458: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54459: LD_ADDR_EXP 60
54463: PUSH
54464: LD_EXP 60
54468: PPUSH
54469: LD_VAR 0 4
54473: PPUSH
54474: EMPTY
54475: PPUSH
54476: CALL_OW 1
54480: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54481: LD_ADDR_EXP 61
54485: PUSH
54486: LD_EXP 61
54490: PPUSH
54491: LD_VAR 0 4
54495: PPUSH
54496: EMPTY
54497: PPUSH
54498: CALL_OW 1
54502: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54503: LD_ADDR_EXP 62
54507: PUSH
54508: LD_EXP 62
54512: PPUSH
54513: LD_VAR 0 4
54517: PPUSH
54518: EMPTY
54519: PPUSH
54520: CALL_OW 1
54524: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54525: LD_ADDR_EXP 63
54529: PUSH
54530: LD_EXP 63
54534: PPUSH
54535: LD_VAR 0 4
54539: PPUSH
54540: EMPTY
54541: PPUSH
54542: CALL_OW 1
54546: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54547: LD_ADDR_EXP 64
54551: PUSH
54552: LD_EXP 64
54556: PPUSH
54557: LD_VAR 0 4
54561: PPUSH
54562: EMPTY
54563: PPUSH
54564: CALL_OW 1
54568: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54569: LD_ADDR_EXP 65
54573: PUSH
54574: LD_EXP 65
54578: PPUSH
54579: LD_VAR 0 4
54583: PPUSH
54584: EMPTY
54585: PPUSH
54586: CALL_OW 1
54590: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54591: LD_ADDR_EXP 66
54595: PUSH
54596: LD_EXP 66
54600: PPUSH
54601: LD_VAR 0 4
54605: PPUSH
54606: EMPTY
54607: PPUSH
54608: CALL_OW 1
54612: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54613: LD_ADDR_EXP 67
54617: PUSH
54618: LD_EXP 67
54622: PPUSH
54623: LD_VAR 0 4
54627: PPUSH
54628: EMPTY
54629: PPUSH
54630: CALL_OW 1
54634: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54635: LD_ADDR_EXP 68
54639: PUSH
54640: LD_EXP 68
54644: PPUSH
54645: LD_VAR 0 4
54649: PPUSH
54650: EMPTY
54651: PPUSH
54652: CALL_OW 1
54656: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54657: LD_ADDR_EXP 69
54661: PUSH
54662: LD_EXP 69
54666: PPUSH
54667: LD_VAR 0 4
54671: PPUSH
54672: EMPTY
54673: PPUSH
54674: CALL_OW 1
54678: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54679: LD_ADDR_EXP 70
54683: PUSH
54684: LD_EXP 70
54688: PPUSH
54689: LD_VAR 0 4
54693: PPUSH
54694: LD_INT 0
54696: PPUSH
54697: CALL_OW 1
54701: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54702: LD_ADDR_EXP 71
54706: PUSH
54707: LD_EXP 71
54711: PPUSH
54712: LD_VAR 0 4
54716: PPUSH
54717: EMPTY
54718: PPUSH
54719: CALL_OW 1
54723: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54724: LD_ADDR_EXP 72
54728: PUSH
54729: LD_EXP 72
54733: PPUSH
54734: LD_VAR 0 4
54738: PPUSH
54739: EMPTY
54740: PPUSH
54741: CALL_OW 1
54745: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54746: LD_ADDR_EXP 73
54750: PUSH
54751: LD_EXP 73
54755: PPUSH
54756: LD_VAR 0 4
54760: PPUSH
54761: EMPTY
54762: PPUSH
54763: CALL_OW 1
54767: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54768: LD_ADDR_EXP 74
54772: PUSH
54773: LD_EXP 74
54777: PPUSH
54778: LD_VAR 0 4
54782: PPUSH
54783: EMPTY
54784: PPUSH
54785: CALL_OW 1
54789: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54790: LD_ADDR_EXP 75
54794: PUSH
54795: LD_EXP 75
54799: PPUSH
54800: LD_VAR 0 4
54804: PPUSH
54805: EMPTY
54806: PPUSH
54807: CALL_OW 1
54811: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54812: LD_ADDR_EXP 76
54816: PUSH
54817: LD_EXP 76
54821: PPUSH
54822: LD_VAR 0 4
54826: PPUSH
54827: EMPTY
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54834: LD_ADDR_EXP 77
54838: PUSH
54839: LD_EXP 77
54843: PPUSH
54844: LD_VAR 0 4
54848: PPUSH
54849: EMPTY
54850: PPUSH
54851: CALL_OW 1
54855: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54856: LD_ADDR_EXP 78
54860: PUSH
54861: LD_EXP 78
54865: PPUSH
54866: LD_VAR 0 4
54870: PPUSH
54871: EMPTY
54872: PPUSH
54873: CALL_OW 1
54877: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54878: LD_ADDR_EXP 79
54882: PUSH
54883: LD_EXP 79
54887: PPUSH
54888: LD_VAR 0 4
54892: PPUSH
54893: EMPTY
54894: PPUSH
54895: CALL_OW 1
54899: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54900: LD_ADDR_EXP 80
54904: PUSH
54905: LD_EXP 80
54909: PPUSH
54910: LD_VAR 0 4
54914: PPUSH
54915: EMPTY
54916: PPUSH
54917: CALL_OW 1
54921: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54922: LD_ADDR_EXP 81
54926: PUSH
54927: LD_EXP 81
54931: PPUSH
54932: LD_VAR 0 4
54936: PPUSH
54937: EMPTY
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54944: LD_ADDR_EXP 82
54948: PUSH
54949: LD_EXP 82
54953: PPUSH
54954: LD_VAR 0 4
54958: PPUSH
54959: EMPTY
54960: PPUSH
54961: CALL_OW 1
54965: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54966: LD_ADDR_EXP 83
54970: PUSH
54971: LD_EXP 83
54975: PPUSH
54976: LD_VAR 0 4
54980: PPUSH
54981: EMPTY
54982: PPUSH
54983: CALL_OW 1
54987: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54988: LD_ADDR_EXP 84
54992: PUSH
54993: LD_EXP 84
54997: PPUSH
54998: LD_VAR 0 4
55002: PPUSH
55003: EMPTY
55004: PPUSH
55005: CALL_OW 1
55009: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55010: LD_ADDR_EXP 86
55014: PUSH
55015: LD_EXP 86
55019: PPUSH
55020: LD_VAR 0 4
55024: PPUSH
55025: EMPTY
55026: PPUSH
55027: CALL_OW 1
55031: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55032: LD_ADDR_EXP 88
55036: PUSH
55037: LD_EXP 88
55041: PPUSH
55042: LD_VAR 0 4
55046: PPUSH
55047: EMPTY
55048: PPUSH
55049: CALL_OW 1
55053: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55054: LD_ADDR_EXP 89
55058: PUSH
55059: LD_EXP 89
55063: PPUSH
55064: LD_VAR 0 4
55068: PPUSH
55069: EMPTY
55070: PPUSH
55071: CALL_OW 1
55075: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55076: LD_ADDR_EXP 90
55080: PUSH
55081: LD_EXP 90
55085: PPUSH
55086: LD_VAR 0 4
55090: PPUSH
55091: EMPTY
55092: PPUSH
55093: CALL_OW 1
55097: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55098: LD_ADDR_EXP 91
55102: PUSH
55103: LD_EXP 91
55107: PPUSH
55108: LD_VAR 0 4
55112: PPUSH
55113: EMPTY
55114: PPUSH
55115: CALL_OW 1
55119: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55120: LD_ADDR_EXP 92
55124: PUSH
55125: LD_EXP 92
55129: PPUSH
55130: LD_VAR 0 4
55134: PPUSH
55135: EMPTY
55136: PPUSH
55137: CALL_OW 1
55141: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55142: LD_ADDR_EXP 93
55146: PUSH
55147: LD_EXP 93
55151: PPUSH
55152: LD_VAR 0 4
55156: PPUSH
55157: EMPTY
55158: PPUSH
55159: CALL_OW 1
55163: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55164: LD_ADDR_EXP 94
55168: PUSH
55169: LD_EXP 94
55173: PPUSH
55174: LD_VAR 0 4
55178: PPUSH
55179: EMPTY
55180: PPUSH
55181: CALL_OW 1
55185: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55186: LD_ADDR_EXP 95
55190: PUSH
55191: LD_EXP 95
55195: PPUSH
55196: LD_VAR 0 4
55200: PPUSH
55201: EMPTY
55202: PPUSH
55203: CALL_OW 1
55207: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55208: LD_ADDR_EXP 96
55212: PUSH
55213: LD_EXP 96
55217: PPUSH
55218: LD_VAR 0 4
55222: PPUSH
55223: EMPTY
55224: PPUSH
55225: CALL_OW 1
55229: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55230: LD_ADDR_EXP 97
55234: PUSH
55235: LD_EXP 97
55239: PPUSH
55240: LD_VAR 0 4
55244: PPUSH
55245: EMPTY
55246: PPUSH
55247: CALL_OW 1
55251: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55252: LD_ADDR_EXP 98
55256: PUSH
55257: LD_EXP 98
55261: PPUSH
55262: LD_VAR 0 4
55266: PPUSH
55267: EMPTY
55268: PPUSH
55269: CALL_OW 1
55273: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55274: LD_ADDR_EXP 99
55278: PUSH
55279: LD_EXP 99
55283: PPUSH
55284: LD_VAR 0 4
55288: PPUSH
55289: EMPTY
55290: PPUSH
55291: CALL_OW 1
55295: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55296: LD_ADDR_EXP 100
55300: PUSH
55301: LD_EXP 100
55305: PPUSH
55306: LD_VAR 0 4
55310: PPUSH
55311: EMPTY
55312: PPUSH
55313: CALL_OW 1
55317: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55318: LD_ADDR_EXP 101
55322: PUSH
55323: LD_EXP 101
55327: PPUSH
55328: LD_VAR 0 4
55332: PPUSH
55333: LD_INT 0
55335: PPUSH
55336: CALL_OW 1
55340: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55341: LD_ADDR_EXP 102
55345: PUSH
55346: LD_EXP 102
55350: PPUSH
55351: LD_VAR 0 4
55355: PPUSH
55356: LD_INT 0
55358: PPUSH
55359: CALL_OW 1
55363: ST_TO_ADDR
// result := base ;
55364: LD_ADDR_VAR 0 3
55368: PUSH
55369: LD_VAR 0 4
55373: ST_TO_ADDR
// end ;
55374: LD_VAR 0 3
55378: RET
// export function MC_Start ( ) ; var i ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
// for i = 1 to mc_bases do
55383: LD_ADDR_VAR 0 2
55387: PUSH
55388: DOUBLE
55389: LD_INT 1
55391: DEC
55392: ST_TO_ADDR
55393: LD_EXP 59
55397: PUSH
55398: FOR_TO
55399: IFFALSE 56499
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
55401: LD_ADDR_EXP 59
55405: PUSH
55406: LD_EXP 59
55410: PPUSH
55411: LD_VAR 0 2
55415: PPUSH
55416: LD_EXP 59
55420: PUSH
55421: LD_VAR 0 2
55425: ARRAY
55426: PUSH
55427: LD_INT 0
55429: DIFF
55430: PPUSH
55431: CALL_OW 1
55435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
55436: LD_ADDR_EXP 60
55440: PUSH
55441: LD_EXP 60
55445: PPUSH
55446: LD_VAR 0 2
55450: PPUSH
55451: EMPTY
55452: PPUSH
55453: CALL_OW 1
55457: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55458: LD_ADDR_EXP 61
55462: PUSH
55463: LD_EXP 61
55467: PPUSH
55468: LD_VAR 0 2
55472: PPUSH
55473: EMPTY
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
55480: LD_ADDR_EXP 62
55484: PUSH
55485: LD_EXP 62
55489: PPUSH
55490: LD_VAR 0 2
55494: PPUSH
55495: EMPTY
55496: PPUSH
55497: CALL_OW 1
55501: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
55502: LD_ADDR_EXP 63
55506: PUSH
55507: LD_EXP 63
55511: PPUSH
55512: LD_VAR 0 2
55516: PPUSH
55517: EMPTY
55518: PUSH
55519: EMPTY
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PPUSH
55525: CALL_OW 1
55529: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
55530: LD_ADDR_EXP 64
55534: PUSH
55535: LD_EXP 64
55539: PPUSH
55540: LD_VAR 0 2
55544: PPUSH
55545: EMPTY
55546: PPUSH
55547: CALL_OW 1
55551: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55552: LD_ADDR_EXP 91
55556: PUSH
55557: LD_EXP 91
55561: PPUSH
55562: LD_VAR 0 2
55566: PPUSH
55567: EMPTY
55568: PPUSH
55569: CALL_OW 1
55573: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
55574: LD_ADDR_EXP 65
55578: PUSH
55579: LD_EXP 65
55583: PPUSH
55584: LD_VAR 0 2
55588: PPUSH
55589: EMPTY
55590: PPUSH
55591: CALL_OW 1
55595: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
55596: LD_ADDR_EXP 66
55600: PUSH
55601: LD_EXP 66
55605: PPUSH
55606: LD_VAR 0 2
55610: PPUSH
55611: EMPTY
55612: PPUSH
55613: CALL_OW 1
55617: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
55618: LD_ADDR_EXP 67
55622: PUSH
55623: LD_EXP 67
55627: PPUSH
55628: LD_VAR 0 2
55632: PPUSH
55633: LD_EXP 59
55637: PUSH
55638: LD_VAR 0 2
55642: ARRAY
55643: PPUSH
55644: LD_INT 2
55646: PUSH
55647: LD_INT 30
55649: PUSH
55650: LD_INT 32
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: PUSH
55657: LD_INT 30
55659: PUSH
55660: LD_INT 33
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: LIST
55671: PPUSH
55672: CALL_OW 72
55676: PPUSH
55677: CALL_OW 1
55681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
55682: LD_ADDR_EXP 68
55686: PUSH
55687: LD_EXP 68
55691: PPUSH
55692: LD_VAR 0 2
55696: PPUSH
55697: LD_EXP 59
55701: PUSH
55702: LD_VAR 0 2
55706: ARRAY
55707: PPUSH
55708: LD_INT 2
55710: PUSH
55711: LD_INT 30
55713: PUSH
55714: LD_INT 32
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: PUSH
55721: LD_INT 30
55723: PUSH
55724: LD_INT 31
55726: PUSH
55727: EMPTY
55728: LIST
55729: LIST
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: LIST
55735: PUSH
55736: LD_INT 58
55738: PUSH
55739: EMPTY
55740: LIST
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: PPUSH
55746: CALL_OW 72
55750: PPUSH
55751: CALL_OW 1
55755: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
55756: LD_ADDR_EXP 69
55760: PUSH
55761: LD_EXP 69
55765: PPUSH
55766: LD_VAR 0 2
55770: PPUSH
55771: EMPTY
55772: PPUSH
55773: CALL_OW 1
55777: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
55778: LD_ADDR_EXP 73
55782: PUSH
55783: LD_EXP 73
55787: PPUSH
55788: LD_VAR 0 2
55792: PPUSH
55793: EMPTY
55794: PPUSH
55795: CALL_OW 1
55799: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
55800: LD_ADDR_EXP 72
55804: PUSH
55805: LD_EXP 72
55809: PPUSH
55810: LD_VAR 0 2
55814: PPUSH
55815: EMPTY
55816: PPUSH
55817: CALL_OW 1
55821: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55822: LD_ADDR_EXP 74
55826: PUSH
55827: LD_EXP 74
55831: PPUSH
55832: LD_VAR 0 2
55836: PPUSH
55837: EMPTY
55838: PPUSH
55839: CALL_OW 1
55843: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55844: LD_ADDR_EXP 75
55848: PUSH
55849: LD_EXP 75
55853: PPUSH
55854: LD_VAR 0 2
55858: PPUSH
55859: EMPTY
55860: PPUSH
55861: CALL_OW 1
55865: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55866: LD_ADDR_EXP 76
55870: PUSH
55871: LD_EXP 76
55875: PPUSH
55876: LD_VAR 0 2
55880: PPUSH
55881: EMPTY
55882: PPUSH
55883: CALL_OW 1
55887: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55888: LD_ADDR_EXP 77
55892: PUSH
55893: LD_EXP 77
55897: PPUSH
55898: LD_VAR 0 2
55902: PPUSH
55903: EMPTY
55904: PPUSH
55905: CALL_OW 1
55909: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55910: LD_ADDR_EXP 78
55914: PUSH
55915: LD_EXP 78
55919: PPUSH
55920: LD_VAR 0 2
55924: PPUSH
55925: EMPTY
55926: PPUSH
55927: CALL_OW 1
55931: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55932: LD_ADDR_EXP 79
55936: PUSH
55937: LD_EXP 79
55941: PPUSH
55942: LD_VAR 0 2
55946: PPUSH
55947: EMPTY
55948: PPUSH
55949: CALL_OW 1
55953: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55954: LD_ADDR_EXP 80
55958: PUSH
55959: LD_EXP 80
55963: PPUSH
55964: LD_VAR 0 2
55968: PPUSH
55969: EMPTY
55970: PPUSH
55971: CALL_OW 1
55975: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55976: LD_ADDR_EXP 81
55980: PUSH
55981: LD_EXP 81
55985: PPUSH
55986: LD_VAR 0 2
55990: PPUSH
55991: EMPTY
55992: PPUSH
55993: CALL_OW 1
55997: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55998: LD_ADDR_EXP 70
56002: PUSH
56003: LD_EXP 70
56007: PPUSH
56008: LD_VAR 0 2
56012: PPUSH
56013: LD_INT 0
56015: PPUSH
56016: CALL_OW 1
56020: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56021: LD_ADDR_EXP 83
56025: PUSH
56026: LD_EXP 83
56030: PPUSH
56031: LD_VAR 0 2
56035: PPUSH
56036: LD_INT 0
56038: PPUSH
56039: CALL_OW 1
56043: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56044: LD_ADDR_EXP 71
56048: PUSH
56049: LD_EXP 71
56053: PPUSH
56054: LD_VAR 0 2
56058: PPUSH
56059: EMPTY
56060: PPUSH
56061: CALL_OW 1
56065: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56066: LD_ADDR_EXP 82
56070: PUSH
56071: LD_EXP 82
56075: PPUSH
56076: LD_VAR 0 2
56080: PPUSH
56081: LD_INT 0
56083: PPUSH
56084: CALL_OW 1
56088: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56089: LD_ADDR_EXP 84
56093: PUSH
56094: LD_EXP 84
56098: PPUSH
56099: LD_VAR 0 2
56103: PPUSH
56104: EMPTY
56105: PPUSH
56106: CALL_OW 1
56110: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56111: LD_ADDR_EXP 87
56115: PUSH
56116: LD_EXP 87
56120: PPUSH
56121: LD_VAR 0 2
56125: PPUSH
56126: LD_INT 0
56128: PPUSH
56129: CALL_OW 1
56133: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56134: LD_ADDR_EXP 88
56138: PUSH
56139: LD_EXP 88
56143: PPUSH
56144: LD_VAR 0 2
56148: PPUSH
56149: EMPTY
56150: PPUSH
56151: CALL_OW 1
56155: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56156: LD_ADDR_EXP 89
56160: PUSH
56161: LD_EXP 89
56165: PPUSH
56166: LD_VAR 0 2
56170: PPUSH
56171: EMPTY
56172: PPUSH
56173: CALL_OW 1
56177: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56178: LD_ADDR_EXP 90
56182: PUSH
56183: LD_EXP 90
56187: PPUSH
56188: LD_VAR 0 2
56192: PPUSH
56193: EMPTY
56194: PPUSH
56195: CALL_OW 1
56199: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56200: LD_ADDR_EXP 92
56204: PUSH
56205: LD_EXP 92
56209: PPUSH
56210: LD_VAR 0 2
56214: PPUSH
56215: LD_EXP 59
56219: PUSH
56220: LD_VAR 0 2
56224: ARRAY
56225: PPUSH
56226: LD_INT 2
56228: PUSH
56229: LD_INT 30
56231: PUSH
56232: LD_INT 6
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PUSH
56239: LD_INT 30
56241: PUSH
56242: LD_INT 7
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: PUSH
56249: LD_INT 30
56251: PUSH
56252: LD_INT 8
56254: PUSH
56255: EMPTY
56256: LIST
56257: LIST
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: LIST
56263: LIST
56264: PPUSH
56265: CALL_OW 72
56269: PPUSH
56270: CALL_OW 1
56274: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56275: LD_ADDR_EXP 93
56279: PUSH
56280: LD_EXP 93
56284: PPUSH
56285: LD_VAR 0 2
56289: PPUSH
56290: EMPTY
56291: PPUSH
56292: CALL_OW 1
56296: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56297: LD_ADDR_EXP 94
56301: PUSH
56302: LD_EXP 94
56306: PPUSH
56307: LD_VAR 0 2
56311: PPUSH
56312: EMPTY
56313: PPUSH
56314: CALL_OW 1
56318: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
56319: LD_ADDR_EXP 95
56323: PUSH
56324: LD_EXP 95
56328: PPUSH
56329: LD_VAR 0 2
56333: PPUSH
56334: EMPTY
56335: PPUSH
56336: CALL_OW 1
56340: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
56341: LD_ADDR_EXP 96
56345: PUSH
56346: LD_EXP 96
56350: PPUSH
56351: LD_VAR 0 2
56355: PPUSH
56356: EMPTY
56357: PPUSH
56358: CALL_OW 1
56362: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56363: LD_ADDR_EXP 97
56367: PUSH
56368: LD_EXP 97
56372: PPUSH
56373: LD_VAR 0 2
56377: PPUSH
56378: EMPTY
56379: PPUSH
56380: CALL_OW 1
56384: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
56385: LD_ADDR_EXP 98
56389: PUSH
56390: LD_EXP 98
56394: PPUSH
56395: LD_VAR 0 2
56399: PPUSH
56400: EMPTY
56401: PPUSH
56402: CALL_OW 1
56406: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
56407: LD_ADDR_EXP 99
56411: PUSH
56412: LD_EXP 99
56416: PPUSH
56417: LD_VAR 0 2
56421: PPUSH
56422: EMPTY
56423: PPUSH
56424: CALL_OW 1
56428: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
56429: LD_ADDR_EXP 100
56433: PUSH
56434: LD_EXP 100
56438: PPUSH
56439: LD_VAR 0 2
56443: PPUSH
56444: EMPTY
56445: PPUSH
56446: CALL_OW 1
56450: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
56451: LD_ADDR_EXP 101
56455: PUSH
56456: LD_EXP 101
56460: PPUSH
56461: LD_VAR 0 2
56465: PPUSH
56466: LD_INT 0
56468: PPUSH
56469: CALL_OW 1
56473: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56474: LD_ADDR_EXP 102
56478: PUSH
56479: LD_EXP 102
56483: PPUSH
56484: LD_VAR 0 2
56488: PPUSH
56489: LD_INT 0
56491: PPUSH
56492: CALL_OW 1
56496: ST_TO_ADDR
// end ;
56497: GO 55398
56499: POP
56500: POP
// MC_InitSides ( ) ;
56501: CALL 56787 0 0
// MC_InitResearch ( ) ;
56505: CALL 56526 0 0
// CustomInitMacro ( ) ;
56509: CALL 202 0 0
// skirmish := true ;
56513: LD_ADDR_EXP 57
56517: PUSH
56518: LD_INT 1
56520: ST_TO_ADDR
// end ;
56521: LD_VAR 0 1
56525: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
56526: LD_INT 0
56528: PPUSH
56529: PPUSH
56530: PPUSH
56531: PPUSH
56532: PPUSH
56533: PPUSH
// if not mc_bases then
56534: LD_EXP 59
56538: NOT
56539: IFFALSE 56543
// exit ;
56541: GO 56782
// for i = 1 to 8 do
56543: LD_ADDR_VAR 0 2
56547: PUSH
56548: DOUBLE
56549: LD_INT 1
56551: DEC
56552: ST_TO_ADDR
56553: LD_INT 8
56555: PUSH
56556: FOR_TO
56557: IFFALSE 56583
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56559: LD_ADDR_EXP 86
56563: PUSH
56564: LD_EXP 86
56568: PPUSH
56569: LD_VAR 0 2
56573: PPUSH
56574: EMPTY
56575: PPUSH
56576: CALL_OW 1
56580: ST_TO_ADDR
56581: GO 56556
56583: POP
56584: POP
// tmp := [ ] ;
56585: LD_ADDR_VAR 0 5
56589: PUSH
56590: EMPTY
56591: ST_TO_ADDR
// for i = 1 to mc_sides do
56592: LD_ADDR_VAR 0 2
56596: PUSH
56597: DOUBLE
56598: LD_INT 1
56600: DEC
56601: ST_TO_ADDR
56602: LD_EXP 85
56606: PUSH
56607: FOR_TO
56608: IFFALSE 56666
// if not mc_sides [ i ] in tmp then
56610: LD_EXP 85
56614: PUSH
56615: LD_VAR 0 2
56619: ARRAY
56620: PUSH
56621: LD_VAR 0 5
56625: IN
56626: NOT
56627: IFFALSE 56664
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
56629: LD_ADDR_VAR 0 5
56633: PUSH
56634: LD_VAR 0 5
56638: PPUSH
56639: LD_VAR 0 5
56643: PUSH
56644: LD_INT 1
56646: PLUS
56647: PPUSH
56648: LD_EXP 85
56652: PUSH
56653: LD_VAR 0 2
56657: ARRAY
56658: PPUSH
56659: CALL_OW 2
56663: ST_TO_ADDR
56664: GO 56607
56666: POP
56667: POP
// if not tmp then
56668: LD_VAR 0 5
56672: NOT
56673: IFFALSE 56677
// exit ;
56675: GO 56782
// for j in tmp do
56677: LD_ADDR_VAR 0 3
56681: PUSH
56682: LD_VAR 0 5
56686: PUSH
56687: FOR_IN
56688: IFFALSE 56780
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
56690: LD_ADDR_VAR 0 6
56694: PUSH
56695: LD_INT 22
56697: PUSH
56698: LD_VAR 0 3
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PPUSH
56707: CALL_OW 69
56711: ST_TO_ADDR
// if not un then
56712: LD_VAR 0 6
56716: NOT
56717: IFFALSE 56721
// continue ;
56719: GO 56687
// nation := GetNation ( un [ 1 ] ) ;
56721: LD_ADDR_VAR 0 4
56725: PUSH
56726: LD_VAR 0 6
56730: PUSH
56731: LD_INT 1
56733: ARRAY
56734: PPUSH
56735: CALL_OW 248
56739: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
56740: LD_ADDR_EXP 86
56744: PUSH
56745: LD_EXP 86
56749: PPUSH
56750: LD_VAR 0 3
56754: PPUSH
56755: LD_VAR 0 3
56759: PPUSH
56760: LD_VAR 0 4
56764: PPUSH
56765: LD_INT 1
56767: PPUSH
56768: CALL 14803 0 3
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// end ;
56778: GO 56687
56780: POP
56781: POP
// end ;
56782: LD_VAR 0 1
56786: RET
// export function MC_InitSides ( ) ; var i ; begin
56787: LD_INT 0
56789: PPUSH
56790: PPUSH
// if not mc_bases then
56791: LD_EXP 59
56795: NOT
56796: IFFALSE 56800
// exit ;
56798: GO 56874
// for i = 1 to mc_bases do
56800: LD_ADDR_VAR 0 2
56804: PUSH
56805: DOUBLE
56806: LD_INT 1
56808: DEC
56809: ST_TO_ADDR
56810: LD_EXP 59
56814: PUSH
56815: FOR_TO
56816: IFFALSE 56872
// if mc_bases [ i ] then
56818: LD_EXP 59
56822: PUSH
56823: LD_VAR 0 2
56827: ARRAY
56828: IFFALSE 56870
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56830: LD_ADDR_EXP 85
56834: PUSH
56835: LD_EXP 85
56839: PPUSH
56840: LD_VAR 0 2
56844: PPUSH
56845: LD_EXP 59
56849: PUSH
56850: LD_VAR 0 2
56854: ARRAY
56855: PUSH
56856: LD_INT 1
56858: ARRAY
56859: PPUSH
56860: CALL_OW 255
56864: PPUSH
56865: CALL_OW 1
56869: ST_TO_ADDR
56870: GO 56815
56872: POP
56873: POP
// end ;
56874: LD_VAR 0 1
56878: RET
// every 0 0$03 trigger skirmish do
56879: LD_EXP 57
56883: IFFALSE 57037
56885: GO 56887
56887: DISABLE
// begin enable ;
56888: ENABLE
// MC_CheckBuildings ( ) ;
56889: CALL 61535 0 0
// MC_CheckPeopleLife ( ) ;
56893: CALL 61660 0 0
// RaiseSailEvent ( 100 ) ;
56897: LD_INT 100
56899: PPUSH
56900: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56904: LD_INT 103
56906: PPUSH
56907: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56911: LD_INT 104
56913: PPUSH
56914: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56918: LD_INT 105
56920: PPUSH
56921: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56925: LD_INT 106
56927: PPUSH
56928: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56932: LD_INT 107
56934: PPUSH
56935: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56939: LD_INT 108
56941: PPUSH
56942: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56946: LD_INT 109
56948: PPUSH
56949: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56953: LD_INT 110
56955: PPUSH
56956: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56960: LD_INT 111
56962: PPUSH
56963: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56967: LD_INT 112
56969: PPUSH
56970: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56974: LD_INT 113
56976: PPUSH
56977: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56981: LD_INT 120
56983: PPUSH
56984: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56988: LD_INT 121
56990: PPUSH
56991: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56995: LD_INT 122
56997: PPUSH
56998: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57002: LD_INT 123
57004: PPUSH
57005: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57009: LD_INT 124
57011: PPUSH
57012: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57016: LD_INT 125
57018: PPUSH
57019: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57023: LD_INT 126
57025: PPUSH
57026: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57030: LD_INT 200
57032: PPUSH
57033: CALL_OW 427
// end ;
57037: END
// on SailEvent ( event ) do begin if event < 100 then
57038: LD_VAR 0 1
57042: PUSH
57043: LD_INT 100
57045: LESS
57046: IFFALSE 57057
// CustomEvent ( event ) ;
57048: LD_VAR 0 1
57052: PPUSH
57053: CALL 13461 0 1
// if event = 100 then
57057: LD_VAR 0 1
57061: PUSH
57062: LD_INT 100
57064: EQUAL
57065: IFFALSE 57071
// MC_ClassManager ( ) ;
57067: CALL 57463 0 0
// if event = 101 then
57071: LD_VAR 0 1
57075: PUSH
57076: LD_INT 101
57078: EQUAL
57079: IFFALSE 57085
// MC_RepairBuildings ( ) ;
57081: CALL 62245 0 0
// if event = 102 then
57085: LD_VAR 0 1
57089: PUSH
57090: LD_INT 102
57092: EQUAL
57093: IFFALSE 57099
// MC_Heal ( ) ;
57095: CALL 63130 0 0
// if event = 103 then
57099: LD_VAR 0 1
57103: PUSH
57104: LD_INT 103
57106: EQUAL
57107: IFFALSE 57113
// MC_Build ( ) ;
57109: CALL 63552 0 0
// if event = 104 then
57113: LD_VAR 0 1
57117: PUSH
57118: LD_INT 104
57120: EQUAL
57121: IFFALSE 57127
// MC_TurretWeapon ( ) ;
57123: CALL 65193 0 0
// if event = 105 then
57127: LD_VAR 0 1
57131: PUSH
57132: LD_INT 105
57134: EQUAL
57135: IFFALSE 57141
// MC_BuildUpgrade ( ) ;
57137: CALL 64744 0 0
// if event = 106 then
57141: LD_VAR 0 1
57145: PUSH
57146: LD_INT 106
57148: EQUAL
57149: IFFALSE 57155
// MC_PlantMines ( ) ;
57151: CALL 65623 0 0
// if event = 107 then
57155: LD_VAR 0 1
57159: PUSH
57160: LD_INT 107
57162: EQUAL
57163: IFFALSE 57169
// MC_CollectCrates ( ) ;
57165: CALL 66414 0 0
// if event = 108 then
57169: LD_VAR 0 1
57173: PUSH
57174: LD_INT 108
57176: EQUAL
57177: IFFALSE 57183
// MC_LinkRemoteControl ( ) ;
57179: CALL 68190 0 0
// if event = 109 then
57183: LD_VAR 0 1
57187: PUSH
57188: LD_INT 109
57190: EQUAL
57191: IFFALSE 57197
// MC_ProduceVehicle ( ) ;
57193: CALL 68371 0 0
// if event = 110 then
57197: LD_VAR 0 1
57201: PUSH
57202: LD_INT 110
57204: EQUAL
57205: IFFALSE 57211
// MC_SendAttack ( ) ;
57207: CALL 68837 0 0
// if event = 111 then
57211: LD_VAR 0 1
57215: PUSH
57216: LD_INT 111
57218: EQUAL
57219: IFFALSE 57225
// MC_Defend ( ) ;
57221: CALL 68945 0 0
// if event = 112 then
57225: LD_VAR 0 1
57229: PUSH
57230: LD_INT 112
57232: EQUAL
57233: IFFALSE 57239
// MC_Research ( ) ;
57235: CALL 69667 0 0
// if event = 113 then
57239: LD_VAR 0 1
57243: PUSH
57244: LD_INT 113
57246: EQUAL
57247: IFFALSE 57253
// MC_MinesTrigger ( ) ;
57249: CALL 70781 0 0
// if event = 120 then
57253: LD_VAR 0 1
57257: PUSH
57258: LD_INT 120
57260: EQUAL
57261: IFFALSE 57267
// MC_RepairVehicle ( ) ;
57263: CALL 70880 0 0
// if event = 121 then
57267: LD_VAR 0 1
57271: PUSH
57272: LD_INT 121
57274: EQUAL
57275: IFFALSE 57281
// MC_TameApe ( ) ;
57277: CALL 71610 0 0
// if event = 122 then
57281: LD_VAR 0 1
57285: PUSH
57286: LD_INT 122
57288: EQUAL
57289: IFFALSE 57295
// MC_ChangeApeClass ( ) ;
57291: CALL 72439 0 0
// if event = 123 then
57295: LD_VAR 0 1
57299: PUSH
57300: LD_INT 123
57302: EQUAL
57303: IFFALSE 57309
// MC_Bazooka ( ) ;
57305: CALL 73089 0 0
// if event = 124 then
57309: LD_VAR 0 1
57313: PUSH
57314: LD_INT 124
57316: EQUAL
57317: IFFALSE 57323
// MC_TeleportExit ( ) ;
57319: CALL 73287 0 0
// if event = 125 then
57323: LD_VAR 0 1
57327: PUSH
57328: LD_INT 125
57330: EQUAL
57331: IFFALSE 57337
// MC_Deposits ( ) ;
57333: CALL 73934 0 0
// if event = 126 then
57337: LD_VAR 0 1
57341: PUSH
57342: LD_INT 126
57344: EQUAL
57345: IFFALSE 57351
// MC_RemoteDriver ( ) ;
57347: CALL 74559 0 0
// if event = 200 then
57351: LD_VAR 0 1
57355: PUSH
57356: LD_INT 200
57358: EQUAL
57359: IFFALSE 57365
// MC_Idle ( ) ;
57361: CALL 76508 0 0
// end ;
57365: PPOPN 1
57367: END
// export function MC_Reset ( base , tag ) ; var i ; begin
57368: LD_INT 0
57370: PPUSH
57371: PPUSH
// if not mc_bases [ base ] or not tag then
57372: LD_EXP 59
57376: PUSH
57377: LD_VAR 0 1
57381: ARRAY
57382: NOT
57383: PUSH
57384: LD_VAR 0 2
57388: NOT
57389: OR
57390: IFFALSE 57394
// exit ;
57392: GO 57458
// for i in mc_bases [ base ] union mc_ape [ base ] do
57394: LD_ADDR_VAR 0 4
57398: PUSH
57399: LD_EXP 59
57403: PUSH
57404: LD_VAR 0 1
57408: ARRAY
57409: PUSH
57410: LD_EXP 88
57414: PUSH
57415: LD_VAR 0 1
57419: ARRAY
57420: UNION
57421: PUSH
57422: FOR_IN
57423: IFFALSE 57456
// if GetTag ( i ) = tag then
57425: LD_VAR 0 4
57429: PPUSH
57430: CALL_OW 110
57434: PUSH
57435: LD_VAR 0 2
57439: EQUAL
57440: IFFALSE 57454
// SetTag ( i , 0 ) ;
57442: LD_VAR 0 4
57446: PPUSH
57447: LD_INT 0
57449: PPUSH
57450: CALL_OW 109
57454: GO 57422
57456: POP
57457: POP
// end ;
57458: LD_VAR 0 3
57462: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
57463: LD_INT 0
57465: PPUSH
57466: PPUSH
57467: PPUSH
57468: PPUSH
57469: PPUSH
57470: PPUSH
57471: PPUSH
57472: PPUSH
// if not mc_bases then
57473: LD_EXP 59
57477: NOT
57478: IFFALSE 57482
// exit ;
57480: GO 57940
// for i = 1 to mc_bases do
57482: LD_ADDR_VAR 0 2
57486: PUSH
57487: DOUBLE
57488: LD_INT 1
57490: DEC
57491: ST_TO_ADDR
57492: LD_EXP 59
57496: PUSH
57497: FOR_TO
57498: IFFALSE 57938
// begin tmp := MC_ClassCheckReq ( i ) ;
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_VAR 0 2
57509: PPUSH
57510: CALL 57945 0 1
57514: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
57515: LD_ADDR_EXP 100
57519: PUSH
57520: LD_EXP 100
57524: PPUSH
57525: LD_VAR 0 2
57529: PPUSH
57530: LD_VAR 0 4
57534: PPUSH
57535: CALL_OW 1
57539: ST_TO_ADDR
// if not tmp then
57540: LD_VAR 0 4
57544: NOT
57545: IFFALSE 57549
// continue ;
57547: GO 57497
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
57549: LD_ADDR_VAR 0 6
57553: PUSH
57554: LD_EXP 59
57558: PUSH
57559: LD_VAR 0 2
57563: ARRAY
57564: PPUSH
57565: LD_INT 2
57567: PUSH
57568: LD_INT 30
57570: PUSH
57571: LD_INT 4
57573: PUSH
57574: EMPTY
57575: LIST
57576: LIST
57577: PUSH
57578: LD_INT 30
57580: PUSH
57581: LD_INT 5
57583: PUSH
57584: EMPTY
57585: LIST
57586: LIST
57587: PUSH
57588: EMPTY
57589: LIST
57590: LIST
57591: LIST
57592: PPUSH
57593: CALL_OW 72
57597: PUSH
57598: LD_EXP 59
57602: PUSH
57603: LD_VAR 0 2
57607: ARRAY
57608: PPUSH
57609: LD_INT 2
57611: PUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 0
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: LD_INT 30
57624: PUSH
57625: LD_INT 1
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: LIST
57636: PPUSH
57637: CALL_OW 72
57641: PUSH
57642: LD_EXP 59
57646: PUSH
57647: LD_VAR 0 2
57651: ARRAY
57652: PPUSH
57653: LD_INT 30
57655: PUSH
57656: LD_INT 3
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: PPUSH
57663: CALL_OW 72
57667: PUSH
57668: LD_EXP 59
57672: PUSH
57673: LD_VAR 0 2
57677: ARRAY
57678: PPUSH
57679: LD_INT 2
57681: PUSH
57682: LD_INT 30
57684: PUSH
57685: LD_INT 6
57687: PUSH
57688: EMPTY
57689: LIST
57690: LIST
57691: PUSH
57692: LD_INT 30
57694: PUSH
57695: LD_INT 7
57697: PUSH
57698: EMPTY
57699: LIST
57700: LIST
57701: PUSH
57702: LD_INT 30
57704: PUSH
57705: LD_INT 8
57707: PUSH
57708: EMPTY
57709: LIST
57710: LIST
57711: PUSH
57712: EMPTY
57713: LIST
57714: LIST
57715: LIST
57716: LIST
57717: PPUSH
57718: CALL_OW 72
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: LIST
57727: LIST
57728: ST_TO_ADDR
// for j = 1 to 4 do
57729: LD_ADDR_VAR 0 3
57733: PUSH
57734: DOUBLE
57735: LD_INT 1
57737: DEC
57738: ST_TO_ADDR
57739: LD_INT 4
57741: PUSH
57742: FOR_TO
57743: IFFALSE 57934
// begin if not tmp [ j ] then
57745: LD_VAR 0 4
57749: PUSH
57750: LD_VAR 0 3
57754: ARRAY
57755: NOT
57756: IFFALSE 57760
// continue ;
57758: GO 57742
// for p in tmp [ j ] do
57760: LD_ADDR_VAR 0 5
57764: PUSH
57765: LD_VAR 0 4
57769: PUSH
57770: LD_VAR 0 3
57774: ARRAY
57775: PUSH
57776: FOR_IN
57777: IFFALSE 57930
// begin if not b [ j ] then
57779: LD_VAR 0 6
57783: PUSH
57784: LD_VAR 0 3
57788: ARRAY
57789: NOT
57790: IFFALSE 57794
// break ;
57792: GO 57930
// e := 0 ;
57794: LD_ADDR_VAR 0 7
57798: PUSH
57799: LD_INT 0
57801: ST_TO_ADDR
// for k in b [ j ] do
57802: LD_ADDR_VAR 0 8
57806: PUSH
57807: LD_VAR 0 6
57811: PUSH
57812: LD_VAR 0 3
57816: ARRAY
57817: PUSH
57818: FOR_IN
57819: IFFALSE 57846
// if IsNotFull ( k ) then
57821: LD_VAR 0 8
57825: PPUSH
57826: CALL 16956 0 1
57830: IFFALSE 57844
// begin e := k ;
57832: LD_ADDR_VAR 0 7
57836: PUSH
57837: LD_VAR 0 8
57841: ST_TO_ADDR
// break ;
57842: GO 57846
// end ;
57844: GO 57818
57846: POP
57847: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57848: LD_VAR 0 7
57852: PUSH
57853: LD_VAR 0 5
57857: PPUSH
57858: LD_VAR 0 7
57862: PPUSH
57863: CALL 50121 0 2
57867: NOT
57868: AND
57869: IFFALSE 57928
// begin if IsInUnit ( p ) then
57871: LD_VAR 0 5
57875: PPUSH
57876: CALL_OW 310
57880: IFFALSE 57891
// ComExitBuilding ( p ) ;
57882: LD_VAR 0 5
57886: PPUSH
57887: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57891: LD_VAR 0 5
57895: PPUSH
57896: LD_VAR 0 7
57900: PPUSH
57901: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57905: LD_VAR 0 5
57909: PPUSH
57910: LD_VAR 0 3
57914: PPUSH
57915: CALL_OW 183
// AddComExitBuilding ( p ) ;
57919: LD_VAR 0 5
57923: PPUSH
57924: CALL_OW 182
// end ; end ;
57928: GO 57776
57930: POP
57931: POP
// end ;
57932: GO 57742
57934: POP
57935: POP
// end ;
57936: GO 57497
57938: POP
57939: POP
// end ;
57940: LD_VAR 0 1
57944: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57945: LD_INT 0
57947: PPUSH
57948: PPUSH
57949: PPUSH
57950: PPUSH
57951: PPUSH
57952: PPUSH
57953: PPUSH
57954: PPUSH
57955: PPUSH
57956: PPUSH
57957: PPUSH
57958: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57959: LD_VAR 0 1
57963: NOT
57964: PUSH
57965: LD_EXP 59
57969: PUSH
57970: LD_VAR 0 1
57974: ARRAY
57975: NOT
57976: OR
57977: PUSH
57978: LD_EXP 59
57982: PUSH
57983: LD_VAR 0 1
57987: ARRAY
57988: PPUSH
57989: LD_INT 2
57991: PUSH
57992: LD_INT 30
57994: PUSH
57995: LD_INT 0
57997: PUSH
57998: EMPTY
57999: LIST
58000: LIST
58001: PUSH
58002: LD_INT 30
58004: PUSH
58005: LD_INT 1
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: PUSH
58012: EMPTY
58013: LIST
58014: LIST
58015: LIST
58016: PPUSH
58017: CALL_OW 72
58021: NOT
58022: OR
58023: IFFALSE 58027
// exit ;
58025: GO 61530
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58027: LD_ADDR_VAR 0 4
58031: PUSH
58032: LD_EXP 59
58036: PUSH
58037: LD_VAR 0 1
58041: ARRAY
58042: PPUSH
58043: LD_INT 2
58045: PUSH
58046: LD_INT 25
58048: PUSH
58049: LD_INT 1
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: PUSH
58056: LD_INT 25
58058: PUSH
58059: LD_INT 2
58061: PUSH
58062: EMPTY
58063: LIST
58064: LIST
58065: PUSH
58066: LD_INT 25
58068: PUSH
58069: LD_INT 3
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: PUSH
58076: LD_INT 25
58078: PUSH
58079: LD_INT 4
58081: PUSH
58082: EMPTY
58083: LIST
58084: LIST
58085: PUSH
58086: LD_INT 25
58088: PUSH
58089: LD_INT 5
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: PUSH
58096: LD_INT 25
58098: PUSH
58099: LD_INT 8
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PUSH
58106: LD_INT 25
58108: PUSH
58109: LD_INT 9
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: LIST
58120: LIST
58121: LIST
58122: LIST
58123: LIST
58124: LIST
58125: PPUSH
58126: CALL_OW 72
58130: ST_TO_ADDR
// if not tmp then
58131: LD_VAR 0 4
58135: NOT
58136: IFFALSE 58140
// exit ;
58138: GO 61530
// for i in tmp do
58140: LD_ADDR_VAR 0 3
58144: PUSH
58145: LD_VAR 0 4
58149: PUSH
58150: FOR_IN
58151: IFFALSE 58182
// if GetTag ( i ) then
58153: LD_VAR 0 3
58157: PPUSH
58158: CALL_OW 110
58162: IFFALSE 58180
// tmp := tmp diff i ;
58164: LD_ADDR_VAR 0 4
58168: PUSH
58169: LD_VAR 0 4
58173: PUSH
58174: LD_VAR 0 3
58178: DIFF
58179: ST_TO_ADDR
58180: GO 58150
58182: POP
58183: POP
// if not tmp then
58184: LD_VAR 0 4
58188: NOT
58189: IFFALSE 58193
// exit ;
58191: GO 61530
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58193: LD_ADDR_VAR 0 5
58197: PUSH
58198: LD_EXP 59
58202: PUSH
58203: LD_VAR 0 1
58207: ARRAY
58208: PPUSH
58209: LD_INT 2
58211: PUSH
58212: LD_INT 25
58214: PUSH
58215: LD_INT 1
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 25
58224: PUSH
58225: LD_INT 5
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: PUSH
58232: LD_INT 25
58234: PUSH
58235: LD_INT 8
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: PUSH
58242: LD_INT 25
58244: PUSH
58245: LD_INT 9
58247: PUSH
58248: EMPTY
58249: LIST
58250: LIST
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: LIST
58256: LIST
58257: LIST
58258: PPUSH
58259: CALL_OW 72
58263: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58264: LD_ADDR_VAR 0 6
58268: PUSH
58269: LD_EXP 59
58273: PUSH
58274: LD_VAR 0 1
58278: ARRAY
58279: PPUSH
58280: LD_INT 25
58282: PUSH
58283: LD_INT 2
58285: PUSH
58286: EMPTY
58287: LIST
58288: LIST
58289: PPUSH
58290: CALL_OW 72
58294: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58295: LD_ADDR_VAR 0 7
58299: PUSH
58300: LD_EXP 59
58304: PUSH
58305: LD_VAR 0 1
58309: ARRAY
58310: PPUSH
58311: LD_INT 25
58313: PUSH
58314: LD_INT 3
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: PPUSH
58321: CALL_OW 72
58325: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
58326: LD_ADDR_VAR 0 8
58330: PUSH
58331: LD_EXP 59
58335: PUSH
58336: LD_VAR 0 1
58340: ARRAY
58341: PPUSH
58342: LD_INT 25
58344: PUSH
58345: LD_INT 4
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PUSH
58352: LD_INT 24
58354: PUSH
58355: LD_INT 251
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: PUSH
58362: EMPTY
58363: LIST
58364: LIST
58365: PPUSH
58366: CALL_OW 72
58370: ST_TO_ADDR
// if mc_scan [ base ] then
58371: LD_EXP 82
58375: PUSH
58376: LD_VAR 0 1
58380: ARRAY
58381: IFFALSE 58842
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
58383: LD_ADDR_EXP 101
58387: PUSH
58388: LD_EXP 101
58392: PPUSH
58393: LD_VAR 0 1
58397: PPUSH
58398: LD_INT 4
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58406: LD_ADDR_VAR 0 12
58410: PUSH
58411: LD_EXP 59
58415: PUSH
58416: LD_VAR 0 1
58420: ARRAY
58421: PPUSH
58422: LD_INT 2
58424: PUSH
58425: LD_INT 30
58427: PUSH
58428: LD_INT 4
58430: PUSH
58431: EMPTY
58432: LIST
58433: LIST
58434: PUSH
58435: LD_INT 30
58437: PUSH
58438: LD_INT 5
58440: PUSH
58441: EMPTY
58442: LIST
58443: LIST
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: LIST
58449: PPUSH
58450: CALL_OW 72
58454: ST_TO_ADDR
// if not b then
58455: LD_VAR 0 12
58459: NOT
58460: IFFALSE 58464
// exit ;
58462: GO 61530
// p := [ ] ;
58464: LD_ADDR_VAR 0 11
58468: PUSH
58469: EMPTY
58470: ST_TO_ADDR
// if sci >= 2 then
58471: LD_VAR 0 8
58475: PUSH
58476: LD_INT 2
58478: GREATEREQUAL
58479: IFFALSE 58510
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
58481: LD_ADDR_VAR 0 8
58485: PUSH
58486: LD_VAR 0 8
58490: PUSH
58491: LD_INT 1
58493: ARRAY
58494: PUSH
58495: LD_VAR 0 8
58499: PUSH
58500: LD_INT 2
58502: ARRAY
58503: PUSH
58504: EMPTY
58505: LIST
58506: LIST
58507: ST_TO_ADDR
58508: GO 58571
// if sci = 1 then
58510: LD_VAR 0 8
58514: PUSH
58515: LD_INT 1
58517: EQUAL
58518: IFFALSE 58539
// sci := [ sci [ 1 ] ] else
58520: LD_ADDR_VAR 0 8
58524: PUSH
58525: LD_VAR 0 8
58529: PUSH
58530: LD_INT 1
58532: ARRAY
58533: PUSH
58534: EMPTY
58535: LIST
58536: ST_TO_ADDR
58537: GO 58571
// if sci = 0 then
58539: LD_VAR 0 8
58543: PUSH
58544: LD_INT 0
58546: EQUAL
58547: IFFALSE 58571
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58549: LD_ADDR_VAR 0 11
58553: PUSH
58554: LD_VAR 0 4
58558: PPUSH
58559: LD_INT 4
58561: PPUSH
58562: CALL 49984 0 2
58566: PUSH
58567: LD_INT 1
58569: ARRAY
58570: ST_TO_ADDR
// if eng > 4 then
58571: LD_VAR 0 6
58575: PUSH
58576: LD_INT 4
58578: GREATER
58579: IFFALSE 58625
// for i = eng downto 4 do
58581: LD_ADDR_VAR 0 3
58585: PUSH
58586: DOUBLE
58587: LD_VAR 0 6
58591: INC
58592: ST_TO_ADDR
58593: LD_INT 4
58595: PUSH
58596: FOR_DOWNTO
58597: IFFALSE 58623
// eng := eng diff eng [ i ] ;
58599: LD_ADDR_VAR 0 6
58603: PUSH
58604: LD_VAR 0 6
58608: PUSH
58609: LD_VAR 0 6
58613: PUSH
58614: LD_VAR 0 3
58618: ARRAY
58619: DIFF
58620: ST_TO_ADDR
58621: GO 58596
58623: POP
58624: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
58625: LD_ADDR_VAR 0 4
58629: PUSH
58630: LD_VAR 0 4
58634: PUSH
58635: LD_VAR 0 5
58639: PUSH
58640: LD_VAR 0 6
58644: UNION
58645: PUSH
58646: LD_VAR 0 7
58650: UNION
58651: PUSH
58652: LD_VAR 0 8
58656: UNION
58657: DIFF
58658: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
58659: LD_ADDR_VAR 0 13
58663: PUSH
58664: LD_EXP 59
58668: PUSH
58669: LD_VAR 0 1
58673: ARRAY
58674: PPUSH
58675: LD_INT 2
58677: PUSH
58678: LD_INT 30
58680: PUSH
58681: LD_INT 32
58683: PUSH
58684: EMPTY
58685: LIST
58686: LIST
58687: PUSH
58688: LD_INT 30
58690: PUSH
58691: LD_INT 31
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: PUSH
58698: EMPTY
58699: LIST
58700: LIST
58701: LIST
58702: PPUSH
58703: CALL_OW 72
58707: PUSH
58708: LD_EXP 59
58712: PUSH
58713: LD_VAR 0 1
58717: ARRAY
58718: PPUSH
58719: LD_INT 2
58721: PUSH
58722: LD_INT 30
58724: PUSH
58725: LD_INT 4
58727: PUSH
58728: EMPTY
58729: LIST
58730: LIST
58731: PUSH
58732: LD_INT 30
58734: PUSH
58735: LD_INT 5
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: LIST
58746: PPUSH
58747: CALL_OW 72
58751: PUSH
58752: LD_INT 6
58754: MUL
58755: PLUS
58756: ST_TO_ADDR
// if bcount < tmp then
58757: LD_VAR 0 13
58761: PUSH
58762: LD_VAR 0 4
58766: LESS
58767: IFFALSE 58813
// for i = tmp downto bcount do
58769: LD_ADDR_VAR 0 3
58773: PUSH
58774: DOUBLE
58775: LD_VAR 0 4
58779: INC
58780: ST_TO_ADDR
58781: LD_VAR 0 13
58785: PUSH
58786: FOR_DOWNTO
58787: IFFALSE 58811
// tmp := Delete ( tmp , tmp ) ;
58789: LD_ADDR_VAR 0 4
58793: PUSH
58794: LD_VAR 0 4
58798: PPUSH
58799: LD_VAR 0 4
58803: PPUSH
58804: CALL_OW 3
58808: ST_TO_ADDR
58809: GO 58786
58811: POP
58812: POP
// result := [ tmp , 0 , 0 , p ] ;
58813: LD_ADDR_VAR 0 2
58817: PUSH
58818: LD_VAR 0 4
58822: PUSH
58823: LD_INT 0
58825: PUSH
58826: LD_INT 0
58828: PUSH
58829: LD_VAR 0 11
58833: PUSH
58834: EMPTY
58835: LIST
58836: LIST
58837: LIST
58838: LIST
58839: ST_TO_ADDR
// exit ;
58840: GO 61530
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58842: LD_EXP 59
58846: PUSH
58847: LD_VAR 0 1
58851: ARRAY
58852: PPUSH
58853: LD_INT 2
58855: PUSH
58856: LD_INT 30
58858: PUSH
58859: LD_INT 6
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: PUSH
58866: LD_INT 30
58868: PUSH
58869: LD_INT 7
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: PUSH
58876: LD_INT 30
58878: PUSH
58879: LD_INT 8
58881: PUSH
58882: EMPTY
58883: LIST
58884: LIST
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: LIST
58890: LIST
58891: PPUSH
58892: CALL_OW 72
58896: NOT
58897: PUSH
58898: LD_EXP 59
58902: PUSH
58903: LD_VAR 0 1
58907: ARRAY
58908: PPUSH
58909: LD_INT 30
58911: PUSH
58912: LD_INT 3
58914: PUSH
58915: EMPTY
58916: LIST
58917: LIST
58918: PPUSH
58919: CALL_OW 72
58923: NOT
58924: AND
58925: IFFALSE 58997
// begin if eng = tmp then
58927: LD_VAR 0 6
58931: PUSH
58932: LD_VAR 0 4
58936: EQUAL
58937: IFFALSE 58941
// exit ;
58939: GO 61530
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58941: LD_ADDR_EXP 101
58945: PUSH
58946: LD_EXP 101
58950: PPUSH
58951: LD_VAR 0 1
58955: PPUSH
58956: LD_INT 1
58958: PPUSH
58959: CALL_OW 1
58963: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58964: LD_ADDR_VAR 0 2
58968: PUSH
58969: LD_INT 0
58971: PUSH
58972: LD_VAR 0 4
58976: PUSH
58977: LD_VAR 0 6
58981: DIFF
58982: PUSH
58983: LD_INT 0
58985: PUSH
58986: LD_INT 0
58988: PUSH
58989: EMPTY
58990: LIST
58991: LIST
58992: LIST
58993: LIST
58994: ST_TO_ADDR
// exit ;
58995: GO 61530
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58997: LD_EXP 86
59001: PUSH
59002: LD_EXP 85
59006: PUSH
59007: LD_VAR 0 1
59011: ARRAY
59012: ARRAY
59013: PUSH
59014: LD_EXP 59
59018: PUSH
59019: LD_VAR 0 1
59023: ARRAY
59024: PPUSH
59025: LD_INT 2
59027: PUSH
59028: LD_INT 30
59030: PUSH
59031: LD_INT 6
59033: PUSH
59034: EMPTY
59035: LIST
59036: LIST
59037: PUSH
59038: LD_INT 30
59040: PUSH
59041: LD_INT 7
59043: PUSH
59044: EMPTY
59045: LIST
59046: LIST
59047: PUSH
59048: LD_INT 30
59050: PUSH
59051: LD_INT 8
59053: PUSH
59054: EMPTY
59055: LIST
59056: LIST
59057: PUSH
59058: EMPTY
59059: LIST
59060: LIST
59061: LIST
59062: LIST
59063: PPUSH
59064: CALL_OW 72
59068: AND
59069: PUSH
59070: LD_EXP 59
59074: PUSH
59075: LD_VAR 0 1
59079: ARRAY
59080: PPUSH
59081: LD_INT 30
59083: PUSH
59084: LD_INT 3
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: PPUSH
59091: CALL_OW 72
59095: NOT
59096: AND
59097: IFFALSE 59311
// begin if sci >= 6 then
59099: LD_VAR 0 8
59103: PUSH
59104: LD_INT 6
59106: GREATEREQUAL
59107: IFFALSE 59111
// exit ;
59109: GO 61530
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59111: LD_ADDR_EXP 101
59115: PUSH
59116: LD_EXP 101
59120: PPUSH
59121: LD_VAR 0 1
59125: PPUSH
59126: LD_INT 2
59128: PPUSH
59129: CALL_OW 1
59133: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59134: LD_ADDR_VAR 0 9
59138: PUSH
59139: LD_VAR 0 4
59143: PUSH
59144: LD_VAR 0 8
59148: DIFF
59149: PPUSH
59150: LD_INT 4
59152: PPUSH
59153: CALL 49984 0 2
59157: ST_TO_ADDR
// p := [ ] ;
59158: LD_ADDR_VAR 0 11
59162: PUSH
59163: EMPTY
59164: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59165: LD_VAR 0 8
59169: PUSH
59170: LD_INT 6
59172: LESS
59173: PUSH
59174: LD_VAR 0 9
59178: PUSH
59179: LD_INT 6
59181: GREATER
59182: AND
59183: IFFALSE 59264
// begin for i = 1 to 6 - sci do
59185: LD_ADDR_VAR 0 3
59189: PUSH
59190: DOUBLE
59191: LD_INT 1
59193: DEC
59194: ST_TO_ADDR
59195: LD_INT 6
59197: PUSH
59198: LD_VAR 0 8
59202: MINUS
59203: PUSH
59204: FOR_TO
59205: IFFALSE 59260
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59207: LD_ADDR_VAR 0 11
59211: PUSH
59212: LD_VAR 0 11
59216: PPUSH
59217: LD_VAR 0 11
59221: PUSH
59222: LD_INT 1
59224: PLUS
59225: PPUSH
59226: LD_VAR 0 9
59230: PUSH
59231: LD_INT 1
59233: ARRAY
59234: PPUSH
59235: CALL_OW 2
59239: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59240: LD_ADDR_VAR 0 9
59244: PUSH
59245: LD_VAR 0 9
59249: PPUSH
59250: LD_INT 1
59252: PPUSH
59253: CALL_OW 3
59257: ST_TO_ADDR
// end ;
59258: GO 59204
59260: POP
59261: POP
// end else
59262: GO 59284
// if sort then
59264: LD_VAR 0 9
59268: IFFALSE 59284
// p := sort [ 1 ] ;
59270: LD_ADDR_VAR 0 11
59274: PUSH
59275: LD_VAR 0 9
59279: PUSH
59280: LD_INT 1
59282: ARRAY
59283: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59284: LD_ADDR_VAR 0 2
59288: PUSH
59289: LD_INT 0
59291: PUSH
59292: LD_INT 0
59294: PUSH
59295: LD_INT 0
59297: PUSH
59298: LD_VAR 0 11
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: LIST
59307: LIST
59308: ST_TO_ADDR
// exit ;
59309: GO 61530
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59311: LD_EXP 86
59315: PUSH
59316: LD_EXP 85
59320: PUSH
59321: LD_VAR 0 1
59325: ARRAY
59326: ARRAY
59327: PUSH
59328: LD_EXP 59
59332: PUSH
59333: LD_VAR 0 1
59337: ARRAY
59338: PPUSH
59339: LD_INT 2
59341: PUSH
59342: LD_INT 30
59344: PUSH
59345: LD_INT 6
59347: PUSH
59348: EMPTY
59349: LIST
59350: LIST
59351: PUSH
59352: LD_INT 30
59354: PUSH
59355: LD_INT 7
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: PUSH
59362: LD_INT 30
59364: PUSH
59365: LD_INT 8
59367: PUSH
59368: EMPTY
59369: LIST
59370: LIST
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: LIST
59376: LIST
59377: PPUSH
59378: CALL_OW 72
59382: AND
59383: PUSH
59384: LD_EXP 59
59388: PUSH
59389: LD_VAR 0 1
59393: ARRAY
59394: PPUSH
59395: LD_INT 30
59397: PUSH
59398: LD_INT 3
59400: PUSH
59401: EMPTY
59402: LIST
59403: LIST
59404: PPUSH
59405: CALL_OW 72
59409: AND
59410: IFFALSE 60144
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
59412: LD_ADDR_EXP 101
59416: PUSH
59417: LD_EXP 101
59421: PPUSH
59422: LD_VAR 0 1
59426: PPUSH
59427: LD_INT 3
59429: PPUSH
59430: CALL_OW 1
59434: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59435: LD_ADDR_VAR 0 2
59439: PUSH
59440: LD_INT 0
59442: PUSH
59443: LD_INT 0
59445: PUSH
59446: LD_INT 0
59448: PUSH
59449: LD_INT 0
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: LIST
59456: LIST
59457: ST_TO_ADDR
// if not eng then
59458: LD_VAR 0 6
59462: NOT
59463: IFFALSE 59526
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
59465: LD_ADDR_VAR 0 11
59469: PUSH
59470: LD_VAR 0 4
59474: PPUSH
59475: LD_INT 2
59477: PPUSH
59478: CALL 49984 0 2
59482: PUSH
59483: LD_INT 1
59485: ARRAY
59486: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
59487: LD_ADDR_VAR 0 2
59491: PUSH
59492: LD_VAR 0 2
59496: PPUSH
59497: LD_INT 2
59499: PPUSH
59500: LD_VAR 0 11
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// tmp := tmp diff p ;
59510: LD_ADDR_VAR 0 4
59514: PUSH
59515: LD_VAR 0 4
59519: PUSH
59520: LD_VAR 0 11
59524: DIFF
59525: ST_TO_ADDR
// end ; if tmp and sci < 6 then
59526: LD_VAR 0 4
59530: PUSH
59531: LD_VAR 0 8
59535: PUSH
59536: LD_INT 6
59538: LESS
59539: AND
59540: IFFALSE 59728
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59542: LD_ADDR_VAR 0 9
59546: PUSH
59547: LD_VAR 0 4
59551: PUSH
59552: LD_VAR 0 8
59556: PUSH
59557: LD_VAR 0 7
59561: UNION
59562: DIFF
59563: PPUSH
59564: LD_INT 4
59566: PPUSH
59567: CALL 49984 0 2
59571: ST_TO_ADDR
// p := [ ] ;
59572: LD_ADDR_VAR 0 11
59576: PUSH
59577: EMPTY
59578: ST_TO_ADDR
// if sort then
59579: LD_VAR 0 9
59583: IFFALSE 59699
// for i = 1 to 6 - sci do
59585: LD_ADDR_VAR 0 3
59589: PUSH
59590: DOUBLE
59591: LD_INT 1
59593: DEC
59594: ST_TO_ADDR
59595: LD_INT 6
59597: PUSH
59598: LD_VAR 0 8
59602: MINUS
59603: PUSH
59604: FOR_TO
59605: IFFALSE 59697
// begin if i = sort then
59607: LD_VAR 0 3
59611: PUSH
59612: LD_VAR 0 9
59616: EQUAL
59617: IFFALSE 59621
// break ;
59619: GO 59697
// if GetClass ( i ) = 4 then
59621: LD_VAR 0 3
59625: PPUSH
59626: CALL_OW 257
59630: PUSH
59631: LD_INT 4
59633: EQUAL
59634: IFFALSE 59638
// continue ;
59636: GO 59604
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59638: LD_ADDR_VAR 0 11
59642: PUSH
59643: LD_VAR 0 11
59647: PPUSH
59648: LD_VAR 0 11
59652: PUSH
59653: LD_INT 1
59655: PLUS
59656: PPUSH
59657: LD_VAR 0 9
59661: PUSH
59662: LD_VAR 0 3
59666: ARRAY
59667: PPUSH
59668: CALL_OW 2
59672: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59673: LD_ADDR_VAR 0 4
59677: PUSH
59678: LD_VAR 0 4
59682: PUSH
59683: LD_VAR 0 9
59687: PUSH
59688: LD_VAR 0 3
59692: ARRAY
59693: DIFF
59694: ST_TO_ADDR
// end ;
59695: GO 59604
59697: POP
59698: POP
// if p then
59699: LD_VAR 0 11
59703: IFFALSE 59728
// result := Replace ( result , 4 , p ) ;
59705: LD_ADDR_VAR 0 2
59709: PUSH
59710: LD_VAR 0 2
59714: PPUSH
59715: LD_INT 4
59717: PPUSH
59718: LD_VAR 0 11
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// end ; if tmp and mech < 6 then
59728: LD_VAR 0 4
59732: PUSH
59733: LD_VAR 0 7
59737: PUSH
59738: LD_INT 6
59740: LESS
59741: AND
59742: IFFALSE 59930
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59744: LD_ADDR_VAR 0 9
59748: PUSH
59749: LD_VAR 0 4
59753: PUSH
59754: LD_VAR 0 8
59758: PUSH
59759: LD_VAR 0 7
59763: UNION
59764: DIFF
59765: PPUSH
59766: LD_INT 3
59768: PPUSH
59769: CALL 49984 0 2
59773: ST_TO_ADDR
// p := [ ] ;
59774: LD_ADDR_VAR 0 11
59778: PUSH
59779: EMPTY
59780: ST_TO_ADDR
// if sort then
59781: LD_VAR 0 9
59785: IFFALSE 59901
// for i = 1 to 6 - mech do
59787: LD_ADDR_VAR 0 3
59791: PUSH
59792: DOUBLE
59793: LD_INT 1
59795: DEC
59796: ST_TO_ADDR
59797: LD_INT 6
59799: PUSH
59800: LD_VAR 0 7
59804: MINUS
59805: PUSH
59806: FOR_TO
59807: IFFALSE 59899
// begin if i = sort then
59809: LD_VAR 0 3
59813: PUSH
59814: LD_VAR 0 9
59818: EQUAL
59819: IFFALSE 59823
// break ;
59821: GO 59899
// if GetClass ( i ) = 3 then
59823: LD_VAR 0 3
59827: PPUSH
59828: CALL_OW 257
59832: PUSH
59833: LD_INT 3
59835: EQUAL
59836: IFFALSE 59840
// continue ;
59838: GO 59806
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59840: LD_ADDR_VAR 0 11
59844: PUSH
59845: LD_VAR 0 11
59849: PPUSH
59850: LD_VAR 0 11
59854: PUSH
59855: LD_INT 1
59857: PLUS
59858: PPUSH
59859: LD_VAR 0 9
59863: PUSH
59864: LD_VAR 0 3
59868: ARRAY
59869: PPUSH
59870: CALL_OW 2
59874: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59875: LD_ADDR_VAR 0 4
59879: PUSH
59880: LD_VAR 0 4
59884: PUSH
59885: LD_VAR 0 9
59889: PUSH
59890: LD_VAR 0 3
59894: ARRAY
59895: DIFF
59896: ST_TO_ADDR
// end ;
59897: GO 59806
59899: POP
59900: POP
// if p then
59901: LD_VAR 0 11
59905: IFFALSE 59930
// result := Replace ( result , 3 , p ) ;
59907: LD_ADDR_VAR 0 2
59911: PUSH
59912: LD_VAR 0 2
59916: PPUSH
59917: LD_INT 3
59919: PPUSH
59920: LD_VAR 0 11
59924: PPUSH
59925: CALL_OW 1
59929: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59930: LD_VAR 0 4
59934: PUSH
59935: LD_INT 6
59937: GREATER
59938: PUSH
59939: LD_VAR 0 6
59943: PUSH
59944: LD_INT 6
59946: LESS
59947: AND
59948: IFFALSE 60142
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59950: LD_ADDR_VAR 0 9
59954: PUSH
59955: LD_VAR 0 4
59959: PUSH
59960: LD_VAR 0 8
59964: PUSH
59965: LD_VAR 0 7
59969: UNION
59970: PUSH
59971: LD_VAR 0 6
59975: UNION
59976: DIFF
59977: PPUSH
59978: LD_INT 2
59980: PPUSH
59981: CALL 49984 0 2
59985: ST_TO_ADDR
// p := [ ] ;
59986: LD_ADDR_VAR 0 11
59990: PUSH
59991: EMPTY
59992: ST_TO_ADDR
// if sort then
59993: LD_VAR 0 9
59997: IFFALSE 60113
// for i = 1 to 6 - eng do
59999: LD_ADDR_VAR 0 3
60003: PUSH
60004: DOUBLE
60005: LD_INT 1
60007: DEC
60008: ST_TO_ADDR
60009: LD_INT 6
60011: PUSH
60012: LD_VAR 0 6
60016: MINUS
60017: PUSH
60018: FOR_TO
60019: IFFALSE 60111
// begin if i = sort then
60021: LD_VAR 0 3
60025: PUSH
60026: LD_VAR 0 9
60030: EQUAL
60031: IFFALSE 60035
// break ;
60033: GO 60111
// if GetClass ( i ) = 2 then
60035: LD_VAR 0 3
60039: PPUSH
60040: CALL_OW 257
60044: PUSH
60045: LD_INT 2
60047: EQUAL
60048: IFFALSE 60052
// continue ;
60050: GO 60018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60052: LD_ADDR_VAR 0 11
60056: PUSH
60057: LD_VAR 0 11
60061: PPUSH
60062: LD_VAR 0 11
60066: PUSH
60067: LD_INT 1
60069: PLUS
60070: PPUSH
60071: LD_VAR 0 9
60075: PUSH
60076: LD_VAR 0 3
60080: ARRAY
60081: PPUSH
60082: CALL_OW 2
60086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60087: LD_ADDR_VAR 0 4
60091: PUSH
60092: LD_VAR 0 4
60096: PUSH
60097: LD_VAR 0 9
60101: PUSH
60102: LD_VAR 0 3
60106: ARRAY
60107: DIFF
60108: ST_TO_ADDR
// end ;
60109: GO 60018
60111: POP
60112: POP
// if p then
60113: LD_VAR 0 11
60117: IFFALSE 60142
// result := Replace ( result , 2 , p ) ;
60119: LD_ADDR_VAR 0 2
60123: PUSH
60124: LD_VAR 0 2
60128: PPUSH
60129: LD_INT 2
60131: PPUSH
60132: LD_VAR 0 11
60136: PPUSH
60137: CALL_OW 1
60141: ST_TO_ADDR
// end ; exit ;
60142: GO 61530
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60144: LD_EXP 86
60148: PUSH
60149: LD_EXP 85
60153: PUSH
60154: LD_VAR 0 1
60158: ARRAY
60159: ARRAY
60160: NOT
60161: PUSH
60162: LD_EXP 59
60166: PUSH
60167: LD_VAR 0 1
60171: ARRAY
60172: PPUSH
60173: LD_INT 30
60175: PUSH
60176: LD_INT 3
60178: PUSH
60179: EMPTY
60180: LIST
60181: LIST
60182: PPUSH
60183: CALL_OW 72
60187: AND
60188: PUSH
60189: LD_EXP 64
60193: PUSH
60194: LD_VAR 0 1
60198: ARRAY
60199: AND
60200: IFFALSE 60808
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60202: LD_ADDR_EXP 101
60206: PUSH
60207: LD_EXP 101
60211: PPUSH
60212: LD_VAR 0 1
60216: PPUSH
60217: LD_INT 5
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60225: LD_ADDR_VAR 0 2
60229: PUSH
60230: LD_INT 0
60232: PUSH
60233: LD_INT 0
60235: PUSH
60236: LD_INT 0
60238: PUSH
60239: LD_INT 0
60241: PUSH
60242: EMPTY
60243: LIST
60244: LIST
60245: LIST
60246: LIST
60247: ST_TO_ADDR
// if sci > 1 then
60248: LD_VAR 0 8
60252: PUSH
60253: LD_INT 1
60255: GREATER
60256: IFFALSE 60284
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60258: LD_ADDR_VAR 0 4
60262: PUSH
60263: LD_VAR 0 4
60267: PUSH
60268: LD_VAR 0 8
60272: PUSH
60273: LD_VAR 0 8
60277: PUSH
60278: LD_INT 1
60280: ARRAY
60281: DIFF
60282: DIFF
60283: ST_TO_ADDR
// if tmp and not sci then
60284: LD_VAR 0 4
60288: PUSH
60289: LD_VAR 0 8
60293: NOT
60294: AND
60295: IFFALSE 60364
// begin sort := SortBySkill ( tmp , 4 ) ;
60297: LD_ADDR_VAR 0 9
60301: PUSH
60302: LD_VAR 0 4
60306: PPUSH
60307: LD_INT 4
60309: PPUSH
60310: CALL 49984 0 2
60314: ST_TO_ADDR
// if sort then
60315: LD_VAR 0 9
60319: IFFALSE 60335
// p := sort [ 1 ] ;
60321: LD_ADDR_VAR 0 11
60325: PUSH
60326: LD_VAR 0 9
60330: PUSH
60331: LD_INT 1
60333: ARRAY
60334: ST_TO_ADDR
// if p then
60335: LD_VAR 0 11
60339: IFFALSE 60364
// result := Replace ( result , 4 , p ) ;
60341: LD_ADDR_VAR 0 2
60345: PUSH
60346: LD_VAR 0 2
60350: PPUSH
60351: LD_INT 4
60353: PPUSH
60354: LD_VAR 0 11
60358: PPUSH
60359: CALL_OW 1
60363: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60364: LD_ADDR_VAR 0 4
60368: PUSH
60369: LD_VAR 0 4
60373: PUSH
60374: LD_VAR 0 7
60378: DIFF
60379: ST_TO_ADDR
// if tmp and mech < 6 then
60380: LD_VAR 0 4
60384: PUSH
60385: LD_VAR 0 7
60389: PUSH
60390: LD_INT 6
60392: LESS
60393: AND
60394: IFFALSE 60582
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60396: LD_ADDR_VAR 0 9
60400: PUSH
60401: LD_VAR 0 4
60405: PUSH
60406: LD_VAR 0 8
60410: PUSH
60411: LD_VAR 0 7
60415: UNION
60416: DIFF
60417: PPUSH
60418: LD_INT 3
60420: PPUSH
60421: CALL 49984 0 2
60425: ST_TO_ADDR
// p := [ ] ;
60426: LD_ADDR_VAR 0 11
60430: PUSH
60431: EMPTY
60432: ST_TO_ADDR
// if sort then
60433: LD_VAR 0 9
60437: IFFALSE 60553
// for i = 1 to 6 - mech do
60439: LD_ADDR_VAR 0 3
60443: PUSH
60444: DOUBLE
60445: LD_INT 1
60447: DEC
60448: ST_TO_ADDR
60449: LD_INT 6
60451: PUSH
60452: LD_VAR 0 7
60456: MINUS
60457: PUSH
60458: FOR_TO
60459: IFFALSE 60551
// begin if i = sort then
60461: LD_VAR 0 3
60465: PUSH
60466: LD_VAR 0 9
60470: EQUAL
60471: IFFALSE 60475
// break ;
60473: GO 60551
// if GetClass ( i ) = 3 then
60475: LD_VAR 0 3
60479: PPUSH
60480: CALL_OW 257
60484: PUSH
60485: LD_INT 3
60487: EQUAL
60488: IFFALSE 60492
// continue ;
60490: GO 60458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60492: LD_ADDR_VAR 0 11
60496: PUSH
60497: LD_VAR 0 11
60501: PPUSH
60502: LD_VAR 0 11
60506: PUSH
60507: LD_INT 1
60509: PLUS
60510: PPUSH
60511: LD_VAR 0 9
60515: PUSH
60516: LD_VAR 0 3
60520: ARRAY
60521: PPUSH
60522: CALL_OW 2
60526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60527: LD_ADDR_VAR 0 4
60531: PUSH
60532: LD_VAR 0 4
60536: PUSH
60537: LD_VAR 0 9
60541: PUSH
60542: LD_VAR 0 3
60546: ARRAY
60547: DIFF
60548: ST_TO_ADDR
// end ;
60549: GO 60458
60551: POP
60552: POP
// if p then
60553: LD_VAR 0 11
60557: IFFALSE 60582
// result := Replace ( result , 3 , p ) ;
60559: LD_ADDR_VAR 0 2
60563: PUSH
60564: LD_VAR 0 2
60568: PPUSH
60569: LD_INT 3
60571: PPUSH
60572: LD_VAR 0 11
60576: PPUSH
60577: CALL_OW 1
60581: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60582: LD_ADDR_VAR 0 4
60586: PUSH
60587: LD_VAR 0 4
60591: PUSH
60592: LD_VAR 0 6
60596: DIFF
60597: ST_TO_ADDR
// if tmp and eng < 6 then
60598: LD_VAR 0 4
60602: PUSH
60603: LD_VAR 0 6
60607: PUSH
60608: LD_INT 6
60610: LESS
60611: AND
60612: IFFALSE 60806
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60614: LD_ADDR_VAR 0 9
60618: PUSH
60619: LD_VAR 0 4
60623: PUSH
60624: LD_VAR 0 8
60628: PUSH
60629: LD_VAR 0 7
60633: UNION
60634: PUSH
60635: LD_VAR 0 6
60639: UNION
60640: DIFF
60641: PPUSH
60642: LD_INT 2
60644: PPUSH
60645: CALL 49984 0 2
60649: ST_TO_ADDR
// p := [ ] ;
60650: LD_ADDR_VAR 0 11
60654: PUSH
60655: EMPTY
60656: ST_TO_ADDR
// if sort then
60657: LD_VAR 0 9
60661: IFFALSE 60777
// for i = 1 to 6 - eng do
60663: LD_ADDR_VAR 0 3
60667: PUSH
60668: DOUBLE
60669: LD_INT 1
60671: DEC
60672: ST_TO_ADDR
60673: LD_INT 6
60675: PUSH
60676: LD_VAR 0 6
60680: MINUS
60681: PUSH
60682: FOR_TO
60683: IFFALSE 60775
// begin if i = sort then
60685: LD_VAR 0 3
60689: PUSH
60690: LD_VAR 0 9
60694: EQUAL
60695: IFFALSE 60699
// break ;
60697: GO 60775
// if GetClass ( i ) = 2 then
60699: LD_VAR 0 3
60703: PPUSH
60704: CALL_OW 257
60708: PUSH
60709: LD_INT 2
60711: EQUAL
60712: IFFALSE 60716
// continue ;
60714: GO 60682
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60716: LD_ADDR_VAR 0 11
60720: PUSH
60721: LD_VAR 0 11
60725: PPUSH
60726: LD_VAR 0 11
60730: PUSH
60731: LD_INT 1
60733: PLUS
60734: PPUSH
60735: LD_VAR 0 9
60739: PUSH
60740: LD_VAR 0 3
60744: ARRAY
60745: PPUSH
60746: CALL_OW 2
60750: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60751: LD_ADDR_VAR 0 4
60755: PUSH
60756: LD_VAR 0 4
60760: PUSH
60761: LD_VAR 0 9
60765: PUSH
60766: LD_VAR 0 3
60770: ARRAY
60771: DIFF
60772: ST_TO_ADDR
// end ;
60773: GO 60682
60775: POP
60776: POP
// if p then
60777: LD_VAR 0 11
60781: IFFALSE 60806
// result := Replace ( result , 2 , p ) ;
60783: LD_ADDR_VAR 0 2
60787: PUSH
60788: LD_VAR 0 2
60792: PPUSH
60793: LD_INT 2
60795: PPUSH
60796: LD_VAR 0 11
60800: PPUSH
60801: CALL_OW 1
60805: ST_TO_ADDR
// end ; exit ;
60806: GO 61530
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
60808: LD_EXP 86
60812: PUSH
60813: LD_EXP 85
60817: PUSH
60818: LD_VAR 0 1
60822: ARRAY
60823: ARRAY
60824: NOT
60825: PUSH
60826: LD_EXP 59
60830: PUSH
60831: LD_VAR 0 1
60835: ARRAY
60836: PPUSH
60837: LD_INT 30
60839: PUSH
60840: LD_INT 3
60842: PUSH
60843: EMPTY
60844: LIST
60845: LIST
60846: PPUSH
60847: CALL_OW 72
60851: AND
60852: PUSH
60853: LD_EXP 64
60857: PUSH
60858: LD_VAR 0 1
60862: ARRAY
60863: NOT
60864: AND
60865: IFFALSE 61530
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60867: LD_ADDR_EXP 101
60871: PUSH
60872: LD_EXP 101
60876: PPUSH
60877: LD_VAR 0 1
60881: PPUSH
60882: LD_INT 6
60884: PPUSH
60885: CALL_OW 1
60889: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60890: LD_ADDR_VAR 0 2
60894: PUSH
60895: LD_INT 0
60897: PUSH
60898: LD_INT 0
60900: PUSH
60901: LD_INT 0
60903: PUSH
60904: LD_INT 0
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: ST_TO_ADDR
// if sci >= 1 then
60913: LD_VAR 0 8
60917: PUSH
60918: LD_INT 1
60920: GREATEREQUAL
60921: IFFALSE 60943
// tmp := tmp diff sci [ 1 ] ;
60923: LD_ADDR_VAR 0 4
60927: PUSH
60928: LD_VAR 0 4
60932: PUSH
60933: LD_VAR 0 8
60937: PUSH
60938: LD_INT 1
60940: ARRAY
60941: DIFF
60942: ST_TO_ADDR
// if tmp and not sci then
60943: LD_VAR 0 4
60947: PUSH
60948: LD_VAR 0 8
60952: NOT
60953: AND
60954: IFFALSE 61023
// begin sort := SortBySkill ( tmp , 4 ) ;
60956: LD_ADDR_VAR 0 9
60960: PUSH
60961: LD_VAR 0 4
60965: PPUSH
60966: LD_INT 4
60968: PPUSH
60969: CALL 49984 0 2
60973: ST_TO_ADDR
// if sort then
60974: LD_VAR 0 9
60978: IFFALSE 60994
// p := sort [ 1 ] ;
60980: LD_ADDR_VAR 0 11
60984: PUSH
60985: LD_VAR 0 9
60989: PUSH
60990: LD_INT 1
60992: ARRAY
60993: ST_TO_ADDR
// if p then
60994: LD_VAR 0 11
60998: IFFALSE 61023
// result := Replace ( result , 4 , p ) ;
61000: LD_ADDR_VAR 0 2
61004: PUSH
61005: LD_VAR 0 2
61009: PPUSH
61010: LD_INT 4
61012: PPUSH
61013: LD_VAR 0 11
61017: PPUSH
61018: CALL_OW 1
61022: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61023: LD_ADDR_VAR 0 4
61027: PUSH
61028: LD_VAR 0 4
61032: PUSH
61033: LD_VAR 0 7
61037: DIFF
61038: ST_TO_ADDR
// if tmp and mech < 6 then
61039: LD_VAR 0 4
61043: PUSH
61044: LD_VAR 0 7
61048: PUSH
61049: LD_INT 6
61051: LESS
61052: AND
61053: IFFALSE 61235
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61055: LD_ADDR_VAR 0 9
61059: PUSH
61060: LD_VAR 0 4
61064: PUSH
61065: LD_VAR 0 7
61069: DIFF
61070: PPUSH
61071: LD_INT 3
61073: PPUSH
61074: CALL 49984 0 2
61078: ST_TO_ADDR
// p := [ ] ;
61079: LD_ADDR_VAR 0 11
61083: PUSH
61084: EMPTY
61085: ST_TO_ADDR
// if sort then
61086: LD_VAR 0 9
61090: IFFALSE 61206
// for i = 1 to 6 - mech do
61092: LD_ADDR_VAR 0 3
61096: PUSH
61097: DOUBLE
61098: LD_INT 1
61100: DEC
61101: ST_TO_ADDR
61102: LD_INT 6
61104: PUSH
61105: LD_VAR 0 7
61109: MINUS
61110: PUSH
61111: FOR_TO
61112: IFFALSE 61204
// begin if i = sort then
61114: LD_VAR 0 3
61118: PUSH
61119: LD_VAR 0 9
61123: EQUAL
61124: IFFALSE 61128
// break ;
61126: GO 61204
// if GetClass ( i ) = 3 then
61128: LD_VAR 0 3
61132: PPUSH
61133: CALL_OW 257
61137: PUSH
61138: LD_INT 3
61140: EQUAL
61141: IFFALSE 61145
// continue ;
61143: GO 61111
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61145: LD_ADDR_VAR 0 11
61149: PUSH
61150: LD_VAR 0 11
61154: PPUSH
61155: LD_VAR 0 11
61159: PUSH
61160: LD_INT 1
61162: PLUS
61163: PPUSH
61164: LD_VAR 0 9
61168: PUSH
61169: LD_VAR 0 3
61173: ARRAY
61174: PPUSH
61175: CALL_OW 2
61179: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61180: LD_ADDR_VAR 0 4
61184: PUSH
61185: LD_VAR 0 4
61189: PUSH
61190: LD_VAR 0 9
61194: PUSH
61195: LD_VAR 0 3
61199: ARRAY
61200: DIFF
61201: ST_TO_ADDR
// end ;
61202: GO 61111
61204: POP
61205: POP
// if p then
61206: LD_VAR 0 11
61210: IFFALSE 61235
// result := Replace ( result , 3 , p ) ;
61212: LD_ADDR_VAR 0 2
61216: PUSH
61217: LD_VAR 0 2
61221: PPUSH
61222: LD_INT 3
61224: PPUSH
61225: LD_VAR 0 11
61229: PPUSH
61230: CALL_OW 1
61234: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61235: LD_ADDR_VAR 0 4
61239: PUSH
61240: LD_VAR 0 4
61244: PUSH
61245: LD_VAR 0 6
61249: DIFF
61250: ST_TO_ADDR
// if tmp and eng < 4 then
61251: LD_VAR 0 4
61255: PUSH
61256: LD_VAR 0 6
61260: PUSH
61261: LD_INT 4
61263: LESS
61264: AND
61265: IFFALSE 61455
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61267: LD_ADDR_VAR 0 9
61271: PUSH
61272: LD_VAR 0 4
61276: PUSH
61277: LD_VAR 0 7
61281: PUSH
61282: LD_VAR 0 6
61286: UNION
61287: DIFF
61288: PPUSH
61289: LD_INT 2
61291: PPUSH
61292: CALL 49984 0 2
61296: ST_TO_ADDR
// p := [ ] ;
61297: LD_ADDR_VAR 0 11
61301: PUSH
61302: EMPTY
61303: ST_TO_ADDR
// if sort then
61304: LD_VAR 0 9
61308: IFFALSE 61424
// for i = 1 to 4 - eng do
61310: LD_ADDR_VAR 0 3
61314: PUSH
61315: DOUBLE
61316: LD_INT 1
61318: DEC
61319: ST_TO_ADDR
61320: LD_INT 4
61322: PUSH
61323: LD_VAR 0 6
61327: MINUS
61328: PUSH
61329: FOR_TO
61330: IFFALSE 61422
// begin if i = sort then
61332: LD_VAR 0 3
61336: PUSH
61337: LD_VAR 0 9
61341: EQUAL
61342: IFFALSE 61346
// break ;
61344: GO 61422
// if GetClass ( i ) = 2 then
61346: LD_VAR 0 3
61350: PPUSH
61351: CALL_OW 257
61355: PUSH
61356: LD_INT 2
61358: EQUAL
61359: IFFALSE 61363
// continue ;
61361: GO 61329
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61363: LD_ADDR_VAR 0 11
61367: PUSH
61368: LD_VAR 0 11
61372: PPUSH
61373: LD_VAR 0 11
61377: PUSH
61378: LD_INT 1
61380: PLUS
61381: PPUSH
61382: LD_VAR 0 9
61386: PUSH
61387: LD_VAR 0 3
61391: ARRAY
61392: PPUSH
61393: CALL_OW 2
61397: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61398: LD_ADDR_VAR 0 4
61402: PUSH
61403: LD_VAR 0 4
61407: PUSH
61408: LD_VAR 0 9
61412: PUSH
61413: LD_VAR 0 3
61417: ARRAY
61418: DIFF
61419: ST_TO_ADDR
// end ;
61420: GO 61329
61422: POP
61423: POP
// if p then
61424: LD_VAR 0 11
61428: IFFALSE 61453
// result := Replace ( result , 2 , p ) ;
61430: LD_ADDR_VAR 0 2
61434: PUSH
61435: LD_VAR 0 2
61439: PPUSH
61440: LD_INT 2
61442: PPUSH
61443: LD_VAR 0 11
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// end else
61453: GO 61499
// for i = eng downto 5 do
61455: LD_ADDR_VAR 0 3
61459: PUSH
61460: DOUBLE
61461: LD_VAR 0 6
61465: INC
61466: ST_TO_ADDR
61467: LD_INT 5
61469: PUSH
61470: FOR_DOWNTO
61471: IFFALSE 61497
// tmp := tmp union eng [ i ] ;
61473: LD_ADDR_VAR 0 4
61477: PUSH
61478: LD_VAR 0 4
61482: PUSH
61483: LD_VAR 0 6
61487: PUSH
61488: LD_VAR 0 3
61492: ARRAY
61493: UNION
61494: ST_TO_ADDR
61495: GO 61470
61497: POP
61498: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
61499: LD_ADDR_VAR 0 2
61503: PUSH
61504: LD_VAR 0 2
61508: PPUSH
61509: LD_INT 1
61511: PPUSH
61512: LD_VAR 0 4
61516: PUSH
61517: LD_VAR 0 5
61521: DIFF
61522: PPUSH
61523: CALL_OW 1
61527: ST_TO_ADDR
// exit ;
61528: GO 61530
// end ; end ;
61530: LD_VAR 0 2
61534: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61535: LD_INT 0
61537: PPUSH
61538: PPUSH
61539: PPUSH
// if not mc_bases then
61540: LD_EXP 59
61544: NOT
61545: IFFALSE 61549
// exit ;
61547: GO 61655
// for i = 1 to mc_bases do
61549: LD_ADDR_VAR 0 2
61553: PUSH
61554: DOUBLE
61555: LD_INT 1
61557: DEC
61558: ST_TO_ADDR
61559: LD_EXP 59
61563: PUSH
61564: FOR_TO
61565: IFFALSE 61646
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61567: LD_ADDR_VAR 0 3
61571: PUSH
61572: LD_EXP 59
61576: PUSH
61577: LD_VAR 0 2
61581: ARRAY
61582: PPUSH
61583: LD_INT 21
61585: PUSH
61586: LD_INT 3
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: PUSH
61593: LD_INT 3
61595: PUSH
61596: LD_INT 24
61598: PUSH
61599: LD_INT 1000
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: PUSH
61606: EMPTY
61607: LIST
61608: LIST
61609: PUSH
61610: EMPTY
61611: LIST
61612: LIST
61613: PPUSH
61614: CALL_OW 72
61618: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
61619: LD_ADDR_EXP 60
61623: PUSH
61624: LD_EXP 60
61628: PPUSH
61629: LD_VAR 0 2
61633: PPUSH
61634: LD_VAR 0 3
61638: PPUSH
61639: CALL_OW 1
61643: ST_TO_ADDR
// end ;
61644: GO 61564
61646: POP
61647: POP
// RaiseSailEvent ( 101 ) ;
61648: LD_INT 101
61650: PPUSH
61651: CALL_OW 427
// end ;
61655: LD_VAR 0 1
61659: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
61660: LD_INT 0
61662: PPUSH
61663: PPUSH
61664: PPUSH
61665: PPUSH
61666: PPUSH
61667: PPUSH
61668: PPUSH
// if not mc_bases then
61669: LD_EXP 59
61673: NOT
61674: IFFALSE 61678
// exit ;
61676: GO 62240
// for i = 1 to mc_bases do
61678: LD_ADDR_VAR 0 2
61682: PUSH
61683: DOUBLE
61684: LD_INT 1
61686: DEC
61687: ST_TO_ADDR
61688: LD_EXP 59
61692: PUSH
61693: FOR_TO
61694: IFFALSE 62231
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
61696: LD_ADDR_VAR 0 5
61700: PUSH
61701: LD_EXP 59
61705: PUSH
61706: LD_VAR 0 2
61710: ARRAY
61711: PUSH
61712: LD_EXP 88
61716: PUSH
61717: LD_VAR 0 2
61721: ARRAY
61722: UNION
61723: PPUSH
61724: LD_INT 21
61726: PUSH
61727: LD_INT 1
61729: PUSH
61730: EMPTY
61731: LIST
61732: LIST
61733: PUSH
61734: LD_INT 1
61736: PUSH
61737: LD_INT 3
61739: PUSH
61740: LD_INT 54
61742: PUSH
61743: EMPTY
61744: LIST
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: LD_INT 3
61752: PUSH
61753: LD_INT 24
61755: PUSH
61756: LD_INT 1000
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PUSH
61763: EMPTY
61764: LIST
61765: LIST
61766: PUSH
61767: EMPTY
61768: LIST
61769: LIST
61770: LIST
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PPUSH
61776: CALL_OW 72
61780: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61781: LD_ADDR_VAR 0 6
61785: PUSH
61786: LD_EXP 59
61790: PUSH
61791: LD_VAR 0 2
61795: ARRAY
61796: PPUSH
61797: LD_INT 21
61799: PUSH
61800: LD_INT 1
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: PUSH
61807: LD_INT 1
61809: PUSH
61810: LD_INT 3
61812: PUSH
61813: LD_INT 54
61815: PUSH
61816: EMPTY
61817: LIST
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: PUSH
61823: LD_INT 3
61825: PUSH
61826: LD_INT 24
61828: PUSH
61829: LD_INT 250
61831: PUSH
61832: EMPTY
61833: LIST
61834: LIST
61835: PUSH
61836: EMPTY
61837: LIST
61838: LIST
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: LIST
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PPUSH
61849: CALL_OW 72
61853: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61854: LD_ADDR_VAR 0 7
61858: PUSH
61859: LD_VAR 0 5
61863: PUSH
61864: LD_VAR 0 6
61868: DIFF
61869: ST_TO_ADDR
// if not need_heal_1 then
61870: LD_VAR 0 6
61874: NOT
61875: IFFALSE 61908
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61877: LD_ADDR_EXP 62
61881: PUSH
61882: LD_EXP 62
61886: PPUSH
61887: LD_VAR 0 2
61891: PUSH
61892: LD_INT 1
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PPUSH
61899: EMPTY
61900: PPUSH
61901: CALL 19726 0 3
61905: ST_TO_ADDR
61906: GO 61978
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61908: LD_ADDR_EXP 62
61912: PUSH
61913: LD_EXP 62
61917: PPUSH
61918: LD_VAR 0 2
61922: PUSH
61923: LD_INT 1
61925: PUSH
61926: EMPTY
61927: LIST
61928: LIST
61929: PPUSH
61930: LD_EXP 62
61934: PUSH
61935: LD_VAR 0 2
61939: ARRAY
61940: PUSH
61941: LD_INT 1
61943: ARRAY
61944: PPUSH
61945: LD_INT 3
61947: PUSH
61948: LD_INT 24
61950: PUSH
61951: LD_INT 1000
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL_OW 72
61966: PUSH
61967: LD_VAR 0 6
61971: UNION
61972: PPUSH
61973: CALL 19726 0 3
61977: ST_TO_ADDR
// if not need_heal_2 then
61978: LD_VAR 0 7
61982: NOT
61983: IFFALSE 62016
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61985: LD_ADDR_EXP 62
61989: PUSH
61990: LD_EXP 62
61994: PPUSH
61995: LD_VAR 0 2
61999: PUSH
62000: LD_INT 2
62002: PUSH
62003: EMPTY
62004: LIST
62005: LIST
62006: PPUSH
62007: EMPTY
62008: PPUSH
62009: CALL 19726 0 3
62013: ST_TO_ADDR
62014: GO 62048
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62016: LD_ADDR_EXP 62
62020: PUSH
62021: LD_EXP 62
62025: PPUSH
62026: LD_VAR 0 2
62030: PUSH
62031: LD_INT 2
62033: PUSH
62034: EMPTY
62035: LIST
62036: LIST
62037: PPUSH
62038: LD_VAR 0 7
62042: PPUSH
62043: CALL 19726 0 3
62047: ST_TO_ADDR
// if need_heal_2 then
62048: LD_VAR 0 7
62052: IFFALSE 62213
// for j in need_heal_2 do
62054: LD_ADDR_VAR 0 3
62058: PUSH
62059: LD_VAR 0 7
62063: PUSH
62064: FOR_IN
62065: IFFALSE 62211
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62067: LD_ADDR_VAR 0 5
62071: PUSH
62072: LD_EXP 59
62076: PUSH
62077: LD_VAR 0 2
62081: ARRAY
62082: PPUSH
62083: LD_INT 2
62085: PUSH
62086: LD_INT 30
62088: PUSH
62089: LD_INT 6
62091: PUSH
62092: EMPTY
62093: LIST
62094: LIST
62095: PUSH
62096: LD_INT 30
62098: PUSH
62099: LD_INT 7
62101: PUSH
62102: EMPTY
62103: LIST
62104: LIST
62105: PUSH
62106: LD_INT 30
62108: PUSH
62109: LD_INT 8
62111: PUSH
62112: EMPTY
62113: LIST
62114: LIST
62115: PUSH
62116: LD_INT 30
62118: PUSH
62119: LD_INT 0
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: PUSH
62126: LD_INT 30
62128: PUSH
62129: LD_INT 1
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: PUSH
62136: EMPTY
62137: LIST
62138: LIST
62139: LIST
62140: LIST
62141: LIST
62142: LIST
62143: PPUSH
62144: CALL_OW 72
62148: ST_TO_ADDR
// if tmp then
62149: LD_VAR 0 5
62153: IFFALSE 62209
// begin k := NearestUnitToUnit ( tmp , j ) ;
62155: LD_ADDR_VAR 0 4
62159: PUSH
62160: LD_VAR 0 5
62164: PPUSH
62165: LD_VAR 0 3
62169: PPUSH
62170: CALL_OW 74
62174: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62175: LD_VAR 0 3
62179: PPUSH
62180: LD_VAR 0 4
62184: PPUSH
62185: CALL_OW 296
62189: PUSH
62190: LD_INT 5
62192: GREATER
62193: IFFALSE 62209
// ComMoveToNearbyEntrance ( j , k ) ;
62195: LD_VAR 0 3
62199: PPUSH
62200: LD_VAR 0 4
62204: PPUSH
62205: CALL 52345 0 2
// end ; end ;
62209: GO 62064
62211: POP
62212: POP
// if not need_heal_1 and not need_heal_2 then
62213: LD_VAR 0 6
62217: NOT
62218: PUSH
62219: LD_VAR 0 7
62223: NOT
62224: AND
62225: IFFALSE 62229
// continue ;
62227: GO 61693
// end ;
62229: GO 61693
62231: POP
62232: POP
// RaiseSailEvent ( 102 ) ;
62233: LD_INT 102
62235: PPUSH
62236: CALL_OW 427
// end ;
62240: LD_VAR 0 1
62244: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62245: LD_INT 0
62247: PPUSH
62248: PPUSH
62249: PPUSH
62250: PPUSH
62251: PPUSH
62252: PPUSH
62253: PPUSH
62254: PPUSH
// if not mc_bases then
62255: LD_EXP 59
62259: NOT
62260: IFFALSE 62264
// exit ;
62262: GO 63125
// for i = 1 to mc_bases do
62264: LD_ADDR_VAR 0 2
62268: PUSH
62269: DOUBLE
62270: LD_INT 1
62272: DEC
62273: ST_TO_ADDR
62274: LD_EXP 59
62278: PUSH
62279: FOR_TO
62280: IFFALSE 63123
// begin if not mc_building_need_repair [ i ] then
62282: LD_EXP 60
62286: PUSH
62287: LD_VAR 0 2
62291: ARRAY
62292: NOT
62293: IFFALSE 62480
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
62295: LD_ADDR_VAR 0 6
62299: PUSH
62300: LD_EXP 78
62304: PUSH
62305: LD_VAR 0 2
62309: ARRAY
62310: PPUSH
62311: LD_INT 3
62313: PUSH
62314: LD_INT 24
62316: PUSH
62317: LD_INT 1000
62319: PUSH
62320: EMPTY
62321: LIST
62322: LIST
62323: PUSH
62324: EMPTY
62325: LIST
62326: LIST
62327: PUSH
62328: LD_INT 2
62330: PUSH
62331: LD_INT 34
62333: PUSH
62334: LD_INT 13
62336: PUSH
62337: EMPTY
62338: LIST
62339: LIST
62340: PUSH
62341: LD_INT 34
62343: PUSH
62344: LD_INT 52
62346: PUSH
62347: EMPTY
62348: LIST
62349: LIST
62350: PUSH
62351: LD_INT 34
62353: PUSH
62354: LD_EXP 109
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: LIST
62367: LIST
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PPUSH
62373: CALL_OW 72
62377: ST_TO_ADDR
// if cranes then
62378: LD_VAR 0 6
62382: IFFALSE 62444
// for j in cranes do
62384: LD_ADDR_VAR 0 3
62388: PUSH
62389: LD_VAR 0 6
62393: PUSH
62394: FOR_IN
62395: IFFALSE 62442
// if not IsInArea ( j , mc_parking [ i ] ) then
62397: LD_VAR 0 3
62401: PPUSH
62402: LD_EXP 83
62406: PUSH
62407: LD_VAR 0 2
62411: ARRAY
62412: PPUSH
62413: CALL_OW 308
62417: NOT
62418: IFFALSE 62440
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62420: LD_VAR 0 3
62424: PPUSH
62425: LD_EXP 83
62429: PUSH
62430: LD_VAR 0 2
62434: ARRAY
62435: PPUSH
62436: CALL_OW 113
62440: GO 62394
62442: POP
62443: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62444: LD_ADDR_EXP 61
62448: PUSH
62449: LD_EXP 61
62453: PPUSH
62454: LD_VAR 0 2
62458: PPUSH
62459: EMPTY
62460: PPUSH
62461: CALL_OW 1
62465: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
62466: LD_VAR 0 2
62470: PPUSH
62471: LD_INT 101
62473: PPUSH
62474: CALL 57368 0 2
// continue ;
62478: GO 62279
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
62480: LD_ADDR_EXP 65
62484: PUSH
62485: LD_EXP 65
62489: PPUSH
62490: LD_VAR 0 2
62494: PPUSH
62495: EMPTY
62496: PPUSH
62497: CALL_OW 1
62501: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62502: LD_VAR 0 2
62506: PPUSH
62507: LD_INT 103
62509: PPUSH
62510: CALL 57368 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
62514: LD_ADDR_VAR 0 5
62518: PUSH
62519: LD_EXP 59
62523: PUSH
62524: LD_VAR 0 2
62528: ARRAY
62529: PUSH
62530: LD_EXP 88
62534: PUSH
62535: LD_VAR 0 2
62539: ARRAY
62540: UNION
62541: PPUSH
62542: LD_INT 2
62544: PUSH
62545: LD_INT 25
62547: PUSH
62548: LD_INT 2
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 25
62557: PUSH
62558: LD_INT 16
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: LIST
62569: PUSH
62570: EMPTY
62571: LIST
62572: PPUSH
62573: CALL_OW 72
62577: PUSH
62578: LD_EXP 62
62582: PUSH
62583: LD_VAR 0 2
62587: ARRAY
62588: PUSH
62589: LD_INT 1
62591: ARRAY
62592: PUSH
62593: LD_EXP 62
62597: PUSH
62598: LD_VAR 0 2
62602: ARRAY
62603: PUSH
62604: LD_INT 2
62606: ARRAY
62607: UNION
62608: DIFF
62609: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
62610: LD_ADDR_VAR 0 6
62614: PUSH
62615: LD_EXP 78
62619: PUSH
62620: LD_VAR 0 2
62624: ARRAY
62625: PPUSH
62626: LD_INT 2
62628: PUSH
62629: LD_INT 34
62631: PUSH
62632: LD_INT 13
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PUSH
62639: LD_INT 34
62641: PUSH
62642: LD_INT 52
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 34
62651: PUSH
62652: LD_EXP 109
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: LIST
62665: LIST
62666: PPUSH
62667: CALL_OW 72
62671: ST_TO_ADDR
// if cranes then
62672: LD_VAR 0 6
62676: IFFALSE 62812
// begin for j in cranes do
62678: LD_ADDR_VAR 0 3
62682: PUSH
62683: LD_VAR 0 6
62687: PUSH
62688: FOR_IN
62689: IFFALSE 62810
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
62691: LD_VAR 0 3
62695: PPUSH
62696: CALL_OW 256
62700: PUSH
62701: LD_INT 1000
62703: EQUAL
62704: PUSH
62705: LD_VAR 0 3
62709: PPUSH
62710: CALL_OW 314
62714: NOT
62715: AND
62716: IFFALSE 62750
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
62718: LD_VAR 0 3
62722: PPUSH
62723: LD_EXP 60
62727: PUSH
62728: LD_VAR 0 2
62732: ARRAY
62733: PPUSH
62734: LD_VAR 0 3
62738: PPUSH
62739: CALL_OW 74
62743: PPUSH
62744: CALL_OW 130
62748: GO 62808
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62750: LD_VAR 0 3
62754: PPUSH
62755: CALL_OW 256
62759: PUSH
62760: LD_INT 500
62762: LESS
62763: PUSH
62764: LD_VAR 0 3
62768: PPUSH
62769: LD_EXP 83
62773: PUSH
62774: LD_VAR 0 2
62778: ARRAY
62779: PPUSH
62780: CALL_OW 308
62784: NOT
62785: AND
62786: IFFALSE 62808
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62788: LD_VAR 0 3
62792: PPUSH
62793: LD_EXP 83
62797: PUSH
62798: LD_VAR 0 2
62802: ARRAY
62803: PPUSH
62804: CALL_OW 113
// end ;
62808: GO 62688
62810: POP
62811: POP
// end ; if tmp > 3 then
62812: LD_VAR 0 5
62816: PUSH
62817: LD_INT 3
62819: GREATER
62820: IFFALSE 62840
// tmp := ShrinkArray ( tmp , 4 ) ;
62822: LD_ADDR_VAR 0 5
62826: PUSH
62827: LD_VAR 0 5
62831: PPUSH
62832: LD_INT 4
62834: PPUSH
62835: CALL 51793 0 2
62839: ST_TO_ADDR
// if not tmp then
62840: LD_VAR 0 5
62844: NOT
62845: IFFALSE 62849
// continue ;
62847: GO 62279
// for j in tmp do
62849: LD_ADDR_VAR 0 3
62853: PUSH
62854: LD_VAR 0 5
62858: PUSH
62859: FOR_IN
62860: IFFALSE 63119
// begin if IsInUnit ( j ) then
62862: LD_VAR 0 3
62866: PPUSH
62867: CALL_OW 310
62871: IFFALSE 62882
// ComExitBuilding ( j ) ;
62873: LD_VAR 0 3
62877: PPUSH
62878: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62882: LD_VAR 0 3
62886: PUSH
62887: LD_EXP 61
62891: PUSH
62892: LD_VAR 0 2
62896: ARRAY
62897: IN
62898: NOT
62899: IFFALSE 62957
// begin SetTag ( j , 101 ) ;
62901: LD_VAR 0 3
62905: PPUSH
62906: LD_INT 101
62908: PPUSH
62909: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62913: LD_ADDR_EXP 61
62917: PUSH
62918: LD_EXP 61
62922: PPUSH
62923: LD_VAR 0 2
62927: PUSH
62928: LD_EXP 61
62932: PUSH
62933: LD_VAR 0 2
62937: ARRAY
62938: PUSH
62939: LD_INT 1
62941: PLUS
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PPUSH
62947: LD_VAR 0 3
62951: PPUSH
62952: CALL 19726 0 3
62956: ST_TO_ADDR
// end ; wait ( 1 ) ;
62957: LD_INT 1
62959: PPUSH
62960: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62964: LD_ADDR_VAR 0 7
62968: PUSH
62969: LD_EXP 60
62973: PUSH
62974: LD_VAR 0 2
62978: ARRAY
62979: ST_TO_ADDR
// if mc_scan [ i ] then
62980: LD_EXP 82
62984: PUSH
62985: LD_VAR 0 2
62989: ARRAY
62990: IFFALSE 63052
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62992: LD_ADDR_VAR 0 7
62996: PUSH
62997: LD_EXP 60
63001: PUSH
63002: LD_VAR 0 2
63006: ARRAY
63007: PPUSH
63008: LD_INT 3
63010: PUSH
63011: LD_INT 30
63013: PUSH
63014: LD_INT 32
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 30
63023: PUSH
63024: LD_INT 33
63026: PUSH
63027: EMPTY
63028: LIST
63029: LIST
63030: PUSH
63031: LD_INT 30
63033: PUSH
63034: LD_INT 31
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: EMPTY
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: PPUSH
63047: CALL_OW 72
63051: ST_TO_ADDR
// if not to_repair_tmp then
63052: LD_VAR 0 7
63056: NOT
63057: IFFALSE 63061
// continue ;
63059: GO 62859
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63061: LD_ADDR_VAR 0 8
63065: PUSH
63066: LD_VAR 0 7
63070: PPUSH
63071: LD_VAR 0 3
63075: PPUSH
63076: CALL_OW 74
63080: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63081: LD_VAR 0 8
63085: PPUSH
63086: LD_INT 16
63088: PPUSH
63089: CALL 22325 0 2
63093: PUSH
63094: LD_INT 4
63096: ARRAY
63097: PUSH
63098: LD_INT 10
63100: LESS
63101: IFFALSE 63117
// ComRepairBuilding ( j , to_repair ) ;
63103: LD_VAR 0 3
63107: PPUSH
63108: LD_VAR 0 8
63112: PPUSH
63113: CALL_OW 130
// end ;
63117: GO 62859
63119: POP
63120: POP
// end ;
63121: GO 62279
63123: POP
63124: POP
// end ;
63125: LD_VAR 0 1
63129: RET
// export function MC_Heal ; var i , j , tmp ; begin
63130: LD_INT 0
63132: PPUSH
63133: PPUSH
63134: PPUSH
63135: PPUSH
// if not mc_bases then
63136: LD_EXP 59
63140: NOT
63141: IFFALSE 63145
// exit ;
63143: GO 63547
// for i = 1 to mc_bases do
63145: LD_ADDR_VAR 0 2
63149: PUSH
63150: DOUBLE
63151: LD_INT 1
63153: DEC
63154: ST_TO_ADDR
63155: LD_EXP 59
63159: PUSH
63160: FOR_TO
63161: IFFALSE 63545
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63163: LD_EXP 62
63167: PUSH
63168: LD_VAR 0 2
63172: ARRAY
63173: PUSH
63174: LD_INT 1
63176: ARRAY
63177: NOT
63178: PUSH
63179: LD_EXP 62
63183: PUSH
63184: LD_VAR 0 2
63188: ARRAY
63189: PUSH
63190: LD_INT 2
63192: ARRAY
63193: NOT
63194: AND
63195: IFFALSE 63233
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63197: LD_ADDR_EXP 63
63201: PUSH
63202: LD_EXP 63
63206: PPUSH
63207: LD_VAR 0 2
63211: PPUSH
63212: EMPTY
63213: PPUSH
63214: CALL_OW 1
63218: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63219: LD_VAR 0 2
63223: PPUSH
63224: LD_INT 102
63226: PPUSH
63227: CALL 57368 0 2
// continue ;
63231: GO 63160
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63233: LD_ADDR_VAR 0 4
63237: PUSH
63238: LD_EXP 59
63242: PUSH
63243: LD_VAR 0 2
63247: ARRAY
63248: PPUSH
63249: LD_INT 25
63251: PUSH
63252: LD_INT 4
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: PPUSH
63259: CALL_OW 72
63263: ST_TO_ADDR
// if not tmp then
63264: LD_VAR 0 4
63268: NOT
63269: IFFALSE 63273
// continue ;
63271: GO 63160
// if mc_taming [ i ] then
63273: LD_EXP 90
63277: PUSH
63278: LD_VAR 0 2
63282: ARRAY
63283: IFFALSE 63307
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63285: LD_ADDR_EXP 90
63289: PUSH
63290: LD_EXP 90
63294: PPUSH
63295: LD_VAR 0 2
63299: PPUSH
63300: EMPTY
63301: PPUSH
63302: CALL_OW 1
63306: ST_TO_ADDR
// for j in tmp do
63307: LD_ADDR_VAR 0 3
63311: PUSH
63312: LD_VAR 0 4
63316: PUSH
63317: FOR_IN
63318: IFFALSE 63541
// begin if IsInUnit ( j ) then
63320: LD_VAR 0 3
63324: PPUSH
63325: CALL_OW 310
63329: IFFALSE 63340
// ComExitBuilding ( j ) ;
63331: LD_VAR 0 3
63335: PPUSH
63336: CALL_OW 122
// if not j in mc_healers [ i ] then
63340: LD_VAR 0 3
63344: PUSH
63345: LD_EXP 63
63349: PUSH
63350: LD_VAR 0 2
63354: ARRAY
63355: IN
63356: NOT
63357: IFFALSE 63403
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63359: LD_ADDR_EXP 63
63363: PUSH
63364: LD_EXP 63
63368: PPUSH
63369: LD_VAR 0 2
63373: PUSH
63374: LD_EXP 63
63378: PUSH
63379: LD_VAR 0 2
63383: ARRAY
63384: PUSH
63385: LD_INT 1
63387: PLUS
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PPUSH
63393: LD_VAR 0 3
63397: PPUSH
63398: CALL 19726 0 3
63402: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63403: LD_VAR 0 3
63407: PPUSH
63408: CALL_OW 110
63412: PUSH
63413: LD_INT 102
63415: NONEQUAL
63416: IFFALSE 63430
// SetTag ( j , 102 ) ;
63418: LD_VAR 0 3
63422: PPUSH
63423: LD_INT 102
63425: PPUSH
63426: CALL_OW 109
// Wait ( 3 ) ;
63430: LD_INT 3
63432: PPUSH
63433: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63437: LD_EXP 62
63441: PUSH
63442: LD_VAR 0 2
63446: ARRAY
63447: PUSH
63448: LD_INT 1
63450: ARRAY
63451: IFFALSE 63483
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63453: LD_VAR 0 3
63457: PPUSH
63458: LD_EXP 62
63462: PUSH
63463: LD_VAR 0 2
63467: ARRAY
63468: PUSH
63469: LD_INT 1
63471: ARRAY
63472: PUSH
63473: LD_INT 1
63475: ARRAY
63476: PPUSH
63477: CALL_OW 128
63481: GO 63539
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63483: LD_VAR 0 3
63487: PPUSH
63488: CALL_OW 314
63492: NOT
63493: PUSH
63494: LD_EXP 62
63498: PUSH
63499: LD_VAR 0 2
63503: ARRAY
63504: PUSH
63505: LD_INT 2
63507: ARRAY
63508: AND
63509: IFFALSE 63539
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63511: LD_VAR 0 3
63515: PPUSH
63516: LD_EXP 62
63520: PUSH
63521: LD_VAR 0 2
63525: ARRAY
63526: PUSH
63527: LD_INT 2
63529: ARRAY
63530: PUSH
63531: LD_INT 1
63533: ARRAY
63534: PPUSH
63535: CALL_OW 128
// end ;
63539: GO 63317
63541: POP
63542: POP
// end ;
63543: GO 63160
63545: POP
63546: POP
// end ;
63547: LD_VAR 0 1
63551: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
63552: LD_INT 0
63554: PPUSH
63555: PPUSH
63556: PPUSH
63557: PPUSH
63558: PPUSH
// if not mc_bases then
63559: LD_EXP 59
63563: NOT
63564: IFFALSE 63568
// exit ;
63566: GO 64739
// for i = 1 to mc_bases do
63568: LD_ADDR_VAR 0 2
63572: PUSH
63573: DOUBLE
63574: LD_INT 1
63576: DEC
63577: ST_TO_ADDR
63578: LD_EXP 59
63582: PUSH
63583: FOR_TO
63584: IFFALSE 64737
// begin if mc_scan [ i ] then
63586: LD_EXP 82
63590: PUSH
63591: LD_VAR 0 2
63595: ARRAY
63596: IFFALSE 63600
// continue ;
63598: GO 63583
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63600: LD_EXP 64
63604: PUSH
63605: LD_VAR 0 2
63609: ARRAY
63610: NOT
63611: PUSH
63612: LD_EXP 66
63616: PUSH
63617: LD_VAR 0 2
63621: ARRAY
63622: NOT
63623: AND
63624: PUSH
63625: LD_EXP 65
63629: PUSH
63630: LD_VAR 0 2
63634: ARRAY
63635: AND
63636: IFFALSE 63674
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63638: LD_ADDR_EXP 65
63642: PUSH
63643: LD_EXP 65
63647: PPUSH
63648: LD_VAR 0 2
63652: PPUSH
63653: EMPTY
63654: PPUSH
63655: CALL_OW 1
63659: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63660: LD_VAR 0 2
63664: PPUSH
63665: LD_INT 103
63667: PPUSH
63668: CALL 57368 0 2
// continue ;
63672: GO 63583
// end ; if mc_construct_list [ i ] then
63674: LD_EXP 66
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: IFFALSE 63904
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63686: LD_ADDR_VAR 0 4
63690: PUSH
63691: LD_EXP 59
63695: PUSH
63696: LD_VAR 0 2
63700: ARRAY
63701: PPUSH
63702: LD_INT 25
63704: PUSH
63705: LD_INT 2
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: PPUSH
63712: CALL_OW 72
63716: PUSH
63717: LD_EXP 61
63721: PUSH
63722: LD_VAR 0 2
63726: ARRAY
63727: DIFF
63728: ST_TO_ADDR
// if not tmp then
63729: LD_VAR 0 4
63733: NOT
63734: IFFALSE 63738
// continue ;
63736: GO 63583
// for j in tmp do
63738: LD_ADDR_VAR 0 3
63742: PUSH
63743: LD_VAR 0 4
63747: PUSH
63748: FOR_IN
63749: IFFALSE 63900
// begin if not mc_builders [ i ] then
63751: LD_EXP 65
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: NOT
63762: IFFALSE 63820
// begin SetTag ( j , 103 ) ;
63764: LD_VAR 0 3
63768: PPUSH
63769: LD_INT 103
63771: PPUSH
63772: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63776: LD_ADDR_EXP 65
63780: PUSH
63781: LD_EXP 65
63785: PPUSH
63786: LD_VAR 0 2
63790: PUSH
63791: LD_EXP 65
63795: PUSH
63796: LD_VAR 0 2
63800: ARRAY
63801: PUSH
63802: LD_INT 1
63804: PLUS
63805: PUSH
63806: EMPTY
63807: LIST
63808: LIST
63809: PPUSH
63810: LD_VAR 0 3
63814: PPUSH
63815: CALL 19726 0 3
63819: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63820: LD_VAR 0 3
63824: PPUSH
63825: CALL_OW 310
63829: IFFALSE 63840
// ComExitBuilding ( j ) ;
63831: LD_VAR 0 3
63835: PPUSH
63836: CALL_OW 122
// wait ( 3 ) ;
63840: LD_INT 3
63842: PPUSH
63843: CALL_OW 67
// if not mc_construct_list [ i ] then
63847: LD_EXP 66
63851: PUSH
63852: LD_VAR 0 2
63856: ARRAY
63857: NOT
63858: IFFALSE 63862
// break ;
63860: GO 63900
// if not HasTask ( j ) then
63862: LD_VAR 0 3
63866: PPUSH
63867: CALL_OW 314
63871: NOT
63872: IFFALSE 63898
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63874: LD_VAR 0 3
63878: PPUSH
63879: LD_EXP 66
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PUSH
63890: LD_INT 1
63892: ARRAY
63893: PPUSH
63894: CALL 22589 0 2
// end ;
63898: GO 63748
63900: POP
63901: POP
// end else
63902: GO 64735
// if mc_build_list [ i ] then
63904: LD_EXP 64
63908: PUSH
63909: LD_VAR 0 2
63913: ARRAY
63914: IFFALSE 64735
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63916: LD_ADDR_VAR 0 5
63920: PUSH
63921: LD_EXP 59
63925: PUSH
63926: LD_VAR 0 2
63930: ARRAY
63931: PPUSH
63932: LD_INT 2
63934: PUSH
63935: LD_INT 30
63937: PUSH
63938: LD_INT 0
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 30
63947: PUSH
63948: LD_INT 1
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: LIST
63959: PPUSH
63960: CALL_OW 72
63964: ST_TO_ADDR
// if depot then
63965: LD_VAR 0 5
63969: IFFALSE 63987
// depot := depot [ 1 ] else
63971: LD_ADDR_VAR 0 5
63975: PUSH
63976: LD_VAR 0 5
63980: PUSH
63981: LD_INT 1
63983: ARRAY
63984: ST_TO_ADDR
63985: GO 63995
// depot := 0 ;
63987: LD_ADDR_VAR 0 5
63991: PUSH
63992: LD_INT 0
63994: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63995: LD_EXP 64
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PUSH
64006: LD_INT 1
64008: ARRAY
64009: PUSH
64010: LD_INT 1
64012: ARRAY
64013: PPUSH
64014: CALL 22413 0 1
64018: PUSH
64019: LD_EXP 59
64023: PUSH
64024: LD_VAR 0 2
64028: ARRAY
64029: PPUSH
64030: LD_INT 2
64032: PUSH
64033: LD_INT 30
64035: PUSH
64036: LD_INT 2
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 30
64045: PUSH
64046: LD_INT 3
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: LIST
64057: PPUSH
64058: CALL_OW 72
64062: NOT
64063: AND
64064: IFFALSE 64169
// begin for j = 1 to mc_build_list [ i ] do
64066: LD_ADDR_VAR 0 3
64070: PUSH
64071: DOUBLE
64072: LD_INT 1
64074: DEC
64075: ST_TO_ADDR
64076: LD_EXP 64
64080: PUSH
64081: LD_VAR 0 2
64085: ARRAY
64086: PUSH
64087: FOR_TO
64088: IFFALSE 64167
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64090: LD_EXP 64
64094: PUSH
64095: LD_VAR 0 2
64099: ARRAY
64100: PUSH
64101: LD_VAR 0 3
64105: ARRAY
64106: PUSH
64107: LD_INT 1
64109: ARRAY
64110: PUSH
64111: LD_INT 2
64113: EQUAL
64114: IFFALSE 64165
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64116: LD_ADDR_EXP 64
64120: PUSH
64121: LD_EXP 64
64125: PPUSH
64126: LD_VAR 0 2
64130: PPUSH
64131: LD_EXP 64
64135: PUSH
64136: LD_VAR 0 2
64140: ARRAY
64141: PPUSH
64142: LD_VAR 0 3
64146: PPUSH
64147: LD_INT 1
64149: PPUSH
64150: LD_INT 0
64152: PPUSH
64153: CALL 19144 0 4
64157: PPUSH
64158: CALL_OW 1
64162: ST_TO_ADDR
// break ;
64163: GO 64167
// end ;
64165: GO 64087
64167: POP
64168: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64169: LD_EXP 64
64173: PUSH
64174: LD_VAR 0 2
64178: ARRAY
64179: PUSH
64180: LD_INT 1
64182: ARRAY
64183: PUSH
64184: LD_INT 1
64186: ARRAY
64187: PUSH
64188: LD_INT 0
64190: EQUAL
64191: PUSH
64192: LD_VAR 0 5
64196: PUSH
64197: LD_VAR 0 5
64201: PPUSH
64202: LD_EXP 64
64206: PUSH
64207: LD_VAR 0 2
64211: ARRAY
64212: PUSH
64213: LD_INT 1
64215: ARRAY
64216: PUSH
64217: LD_INT 1
64219: ARRAY
64220: PPUSH
64221: LD_EXP 64
64225: PUSH
64226: LD_VAR 0 2
64230: ARRAY
64231: PUSH
64232: LD_INT 1
64234: ARRAY
64235: PUSH
64236: LD_INT 2
64238: ARRAY
64239: PPUSH
64240: LD_EXP 64
64244: PUSH
64245: LD_VAR 0 2
64249: ARRAY
64250: PUSH
64251: LD_INT 1
64253: ARRAY
64254: PUSH
64255: LD_INT 3
64257: ARRAY
64258: PPUSH
64259: LD_EXP 64
64263: PUSH
64264: LD_VAR 0 2
64268: ARRAY
64269: PUSH
64270: LD_INT 1
64272: ARRAY
64273: PUSH
64274: LD_INT 4
64276: ARRAY
64277: PPUSH
64278: CALL 27830 0 5
64282: AND
64283: OR
64284: IFFALSE 64565
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64286: LD_ADDR_VAR 0 4
64290: PUSH
64291: LD_EXP 59
64295: PUSH
64296: LD_VAR 0 2
64300: ARRAY
64301: PPUSH
64302: LD_INT 25
64304: PUSH
64305: LD_INT 2
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PPUSH
64312: CALL_OW 72
64316: PUSH
64317: LD_EXP 61
64321: PUSH
64322: LD_VAR 0 2
64326: ARRAY
64327: DIFF
64328: ST_TO_ADDR
// if not tmp then
64329: LD_VAR 0 4
64333: NOT
64334: IFFALSE 64338
// continue ;
64336: GO 63583
// for j in tmp do
64338: LD_ADDR_VAR 0 3
64342: PUSH
64343: LD_VAR 0 4
64347: PUSH
64348: FOR_IN
64349: IFFALSE 64561
// begin if not mc_builders [ i ] then
64351: LD_EXP 65
64355: PUSH
64356: LD_VAR 0 2
64360: ARRAY
64361: NOT
64362: IFFALSE 64420
// begin SetTag ( j , 103 ) ;
64364: LD_VAR 0 3
64368: PPUSH
64369: LD_INT 103
64371: PPUSH
64372: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64376: LD_ADDR_EXP 65
64380: PUSH
64381: LD_EXP 65
64385: PPUSH
64386: LD_VAR 0 2
64390: PUSH
64391: LD_EXP 65
64395: PUSH
64396: LD_VAR 0 2
64400: ARRAY
64401: PUSH
64402: LD_INT 1
64404: PLUS
64405: PUSH
64406: EMPTY
64407: LIST
64408: LIST
64409: PPUSH
64410: LD_VAR 0 3
64414: PPUSH
64415: CALL 19726 0 3
64419: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64420: LD_VAR 0 3
64424: PPUSH
64425: CALL_OW 310
64429: IFFALSE 64440
// ComExitBuilding ( j ) ;
64431: LD_VAR 0 3
64435: PPUSH
64436: CALL_OW 122
// wait ( 3 ) ;
64440: LD_INT 3
64442: PPUSH
64443: CALL_OW 67
// if not mc_build_list [ i ] then
64447: LD_EXP 64
64451: PUSH
64452: LD_VAR 0 2
64456: ARRAY
64457: NOT
64458: IFFALSE 64462
// break ;
64460: GO 64561
// if not HasTask ( j ) then
64462: LD_VAR 0 3
64466: PPUSH
64467: CALL_OW 314
64471: NOT
64472: IFFALSE 64559
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64474: LD_VAR 0 3
64478: PPUSH
64479: LD_EXP 64
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: PUSH
64490: LD_INT 1
64492: ARRAY
64493: PUSH
64494: LD_INT 1
64496: ARRAY
64497: PPUSH
64498: LD_EXP 64
64502: PUSH
64503: LD_VAR 0 2
64507: ARRAY
64508: PUSH
64509: LD_INT 1
64511: ARRAY
64512: PUSH
64513: LD_INT 2
64515: ARRAY
64516: PPUSH
64517: LD_EXP 64
64521: PUSH
64522: LD_VAR 0 2
64526: ARRAY
64527: PUSH
64528: LD_INT 1
64530: ARRAY
64531: PUSH
64532: LD_INT 3
64534: ARRAY
64535: PPUSH
64536: LD_EXP 64
64540: PUSH
64541: LD_VAR 0 2
64545: ARRAY
64546: PUSH
64547: LD_INT 1
64549: ARRAY
64550: PUSH
64551: LD_INT 4
64553: ARRAY
64554: PPUSH
64555: CALL_OW 145
// end ;
64559: GO 64348
64561: POP
64562: POP
// end else
64563: GO 64735
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
64565: LD_EXP 59
64569: PUSH
64570: LD_VAR 0 2
64574: ARRAY
64575: PPUSH
64576: LD_EXP 64
64580: PUSH
64581: LD_VAR 0 2
64585: ARRAY
64586: PUSH
64587: LD_INT 1
64589: ARRAY
64590: PUSH
64591: LD_INT 1
64593: ARRAY
64594: PPUSH
64595: LD_EXP 64
64599: PUSH
64600: LD_VAR 0 2
64604: ARRAY
64605: PUSH
64606: LD_INT 1
64608: ARRAY
64609: PUSH
64610: LD_INT 2
64612: ARRAY
64613: PPUSH
64614: LD_EXP 64
64618: PUSH
64619: LD_VAR 0 2
64623: ARRAY
64624: PUSH
64625: LD_INT 1
64627: ARRAY
64628: PUSH
64629: LD_INT 3
64631: ARRAY
64632: PPUSH
64633: LD_EXP 64
64637: PUSH
64638: LD_VAR 0 2
64642: ARRAY
64643: PUSH
64644: LD_INT 1
64646: ARRAY
64647: PUSH
64648: LD_INT 4
64650: ARRAY
64651: PPUSH
64652: LD_EXP 59
64656: PUSH
64657: LD_VAR 0 2
64661: ARRAY
64662: PPUSH
64663: LD_INT 21
64665: PUSH
64666: LD_INT 3
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PPUSH
64673: CALL_OW 72
64677: PPUSH
64678: EMPTY
64679: PPUSH
64680: CALL 26580 0 7
64684: NOT
64685: IFFALSE 64735
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64687: LD_ADDR_EXP 64
64691: PUSH
64692: LD_EXP 64
64696: PPUSH
64697: LD_VAR 0 2
64701: PPUSH
64702: LD_EXP 64
64706: PUSH
64707: LD_VAR 0 2
64711: ARRAY
64712: PPUSH
64713: LD_INT 1
64715: PPUSH
64716: LD_INT 1
64718: NEG
64719: PPUSH
64720: LD_INT 0
64722: PPUSH
64723: CALL 19144 0 4
64727: PPUSH
64728: CALL_OW 1
64732: ST_TO_ADDR
// continue ;
64733: GO 63583
// end ; end ; end ;
64735: GO 63583
64737: POP
64738: POP
// end ;
64739: LD_VAR 0 1
64743: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64744: LD_INT 0
64746: PPUSH
64747: PPUSH
64748: PPUSH
64749: PPUSH
64750: PPUSH
64751: PPUSH
// if not mc_bases then
64752: LD_EXP 59
64756: NOT
64757: IFFALSE 64761
// exit ;
64759: GO 65188
// for i = 1 to mc_bases do
64761: LD_ADDR_VAR 0 2
64765: PUSH
64766: DOUBLE
64767: LD_INT 1
64769: DEC
64770: ST_TO_ADDR
64771: LD_EXP 59
64775: PUSH
64776: FOR_TO
64777: IFFALSE 65186
// begin tmp := mc_build_upgrade [ i ] ;
64779: LD_ADDR_VAR 0 4
64783: PUSH
64784: LD_EXP 91
64788: PUSH
64789: LD_VAR 0 2
64793: ARRAY
64794: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64795: LD_ADDR_VAR 0 6
64799: PUSH
64800: LD_EXP 92
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: PPUSH
64811: LD_INT 2
64813: PUSH
64814: LD_INT 30
64816: PUSH
64817: LD_INT 6
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 30
64826: PUSH
64827: LD_INT 7
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: LIST
64838: PPUSH
64839: CALL_OW 72
64843: ST_TO_ADDR
// if not tmp and not lab then
64844: LD_VAR 0 4
64848: NOT
64849: PUSH
64850: LD_VAR 0 6
64854: NOT
64855: AND
64856: IFFALSE 64860
// continue ;
64858: GO 64776
// if tmp then
64860: LD_VAR 0 4
64864: IFFALSE 64984
// for j in tmp do
64866: LD_ADDR_VAR 0 3
64870: PUSH
64871: LD_VAR 0 4
64875: PUSH
64876: FOR_IN
64877: IFFALSE 64982
// begin if UpgradeCost ( j ) then
64879: LD_VAR 0 3
64883: PPUSH
64884: CALL 26240 0 1
64888: IFFALSE 64980
// begin ComUpgrade ( j ) ;
64890: LD_VAR 0 3
64894: PPUSH
64895: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64899: LD_ADDR_EXP 91
64903: PUSH
64904: LD_EXP 91
64908: PPUSH
64909: LD_VAR 0 2
64913: PPUSH
64914: LD_EXP 91
64918: PUSH
64919: LD_VAR 0 2
64923: ARRAY
64924: PUSH
64925: LD_VAR 0 3
64929: DIFF
64930: PPUSH
64931: CALL_OW 1
64935: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64936: LD_ADDR_EXP 66
64940: PUSH
64941: LD_EXP 66
64945: PPUSH
64946: LD_VAR 0 2
64950: PUSH
64951: LD_EXP 66
64955: PUSH
64956: LD_VAR 0 2
64960: ARRAY
64961: PUSH
64962: LD_INT 1
64964: PLUS
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: PPUSH
64970: LD_VAR 0 3
64974: PPUSH
64975: CALL 19726 0 3
64979: ST_TO_ADDR
// end ; end ;
64980: GO 64876
64982: POP
64983: POP
// if not lab or not mc_lab_upgrade [ i ] then
64984: LD_VAR 0 6
64988: NOT
64989: PUSH
64990: LD_EXP 93
64994: PUSH
64995: LD_VAR 0 2
64999: ARRAY
65000: NOT
65001: OR
65002: IFFALSE 65006
// continue ;
65004: GO 64776
// for j in lab do
65006: LD_ADDR_VAR 0 3
65010: PUSH
65011: LD_VAR 0 6
65015: PUSH
65016: FOR_IN
65017: IFFALSE 65182
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65019: LD_VAR 0 3
65023: PPUSH
65024: CALL_OW 266
65028: PUSH
65029: LD_INT 6
65031: PUSH
65032: LD_INT 7
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: IN
65039: PUSH
65040: LD_VAR 0 3
65044: PPUSH
65045: CALL_OW 461
65049: PUSH
65050: LD_INT 1
65052: NONEQUAL
65053: AND
65054: IFFALSE 65180
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65056: LD_VAR 0 3
65060: PPUSH
65061: LD_EXP 93
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: PUSH
65072: LD_INT 1
65074: ARRAY
65075: PPUSH
65076: CALL 26445 0 2
65080: IFFALSE 65180
// begin ComCancel ( j ) ;
65082: LD_VAR 0 3
65086: PPUSH
65087: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65091: LD_VAR 0 3
65095: PPUSH
65096: LD_EXP 93
65100: PUSH
65101: LD_VAR 0 2
65105: ARRAY
65106: PUSH
65107: LD_INT 1
65109: ARRAY
65110: PPUSH
65111: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65115: LD_VAR 0 3
65119: PUSH
65120: LD_EXP 66
65124: PUSH
65125: LD_VAR 0 2
65129: ARRAY
65130: IN
65131: NOT
65132: IFFALSE 65178
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65134: LD_ADDR_EXP 66
65138: PUSH
65139: LD_EXP 66
65143: PPUSH
65144: LD_VAR 0 2
65148: PUSH
65149: LD_EXP 66
65153: PUSH
65154: LD_VAR 0 2
65158: ARRAY
65159: PUSH
65160: LD_INT 1
65162: PLUS
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: PPUSH
65168: LD_VAR 0 3
65172: PPUSH
65173: CALL 19726 0 3
65177: ST_TO_ADDR
// break ;
65178: GO 65182
// end ; end ; end ;
65180: GO 65016
65182: POP
65183: POP
// end ;
65184: GO 64776
65186: POP
65187: POP
// end ;
65188: LD_VAR 0 1
65192: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65193: LD_INT 0
65195: PPUSH
65196: PPUSH
65197: PPUSH
65198: PPUSH
65199: PPUSH
65200: PPUSH
65201: PPUSH
65202: PPUSH
65203: PPUSH
// if not mc_bases then
65204: LD_EXP 59
65208: NOT
65209: IFFALSE 65213
// exit ;
65211: GO 65618
// for i = 1 to mc_bases do
65213: LD_ADDR_VAR 0 2
65217: PUSH
65218: DOUBLE
65219: LD_INT 1
65221: DEC
65222: ST_TO_ADDR
65223: LD_EXP 59
65227: PUSH
65228: FOR_TO
65229: IFFALSE 65616
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65231: LD_EXP 67
65235: PUSH
65236: LD_VAR 0 2
65240: ARRAY
65241: NOT
65242: PUSH
65243: LD_EXP 59
65247: PUSH
65248: LD_VAR 0 2
65252: ARRAY
65253: PPUSH
65254: LD_INT 30
65256: PUSH
65257: LD_INT 3
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PPUSH
65264: CALL_OW 72
65268: NOT
65269: OR
65270: IFFALSE 65274
// continue ;
65272: GO 65228
// busy := false ;
65274: LD_ADDR_VAR 0 8
65278: PUSH
65279: LD_INT 0
65281: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65282: LD_ADDR_VAR 0 4
65286: PUSH
65287: LD_EXP 59
65291: PUSH
65292: LD_VAR 0 2
65296: ARRAY
65297: PPUSH
65298: LD_INT 30
65300: PUSH
65301: LD_INT 3
65303: PUSH
65304: EMPTY
65305: LIST
65306: LIST
65307: PPUSH
65308: CALL_OW 72
65312: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65313: LD_ADDR_VAR 0 6
65317: PUSH
65318: LD_EXP 67
65322: PUSH
65323: LD_VAR 0 2
65327: ARRAY
65328: PPUSH
65329: LD_INT 2
65331: PUSH
65332: LD_INT 30
65334: PUSH
65335: LD_INT 32
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 30
65344: PUSH
65345: LD_INT 33
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: LIST
65356: PPUSH
65357: CALL_OW 72
65361: ST_TO_ADDR
// if not t then
65362: LD_VAR 0 6
65366: NOT
65367: IFFALSE 65371
// continue ;
65369: GO 65228
// for j in tmp do
65371: LD_ADDR_VAR 0 3
65375: PUSH
65376: LD_VAR 0 4
65380: PUSH
65381: FOR_IN
65382: IFFALSE 65412
// if not BuildingStatus ( j ) = bs_idle then
65384: LD_VAR 0 3
65388: PPUSH
65389: CALL_OW 461
65393: PUSH
65394: LD_INT 2
65396: EQUAL
65397: NOT
65398: IFFALSE 65410
// begin busy := true ;
65400: LD_ADDR_VAR 0 8
65404: PUSH
65405: LD_INT 1
65407: ST_TO_ADDR
// break ;
65408: GO 65412
// end ;
65410: GO 65381
65412: POP
65413: POP
// if busy then
65414: LD_VAR 0 8
65418: IFFALSE 65422
// continue ;
65420: GO 65228
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65422: LD_ADDR_VAR 0 7
65426: PUSH
65427: LD_VAR 0 6
65431: PPUSH
65432: LD_INT 35
65434: PUSH
65435: LD_INT 0
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PPUSH
65442: CALL_OW 72
65446: ST_TO_ADDR
// if tw then
65447: LD_VAR 0 7
65451: IFFALSE 65528
// begin tw := tw [ 1 ] ;
65453: LD_ADDR_VAR 0 7
65457: PUSH
65458: LD_VAR 0 7
65462: PUSH
65463: LD_INT 1
65465: ARRAY
65466: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65467: LD_ADDR_VAR 0 9
65471: PUSH
65472: LD_VAR 0 7
65476: PPUSH
65477: LD_EXP 84
65481: PUSH
65482: LD_VAR 0 2
65486: ARRAY
65487: PPUSH
65488: CALL 24737 0 2
65492: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65493: LD_EXP 98
65497: PUSH
65498: LD_VAR 0 2
65502: ARRAY
65503: IFFALSE 65526
// if not weapon in mc_allowed_tower_weapons [ i ] then
65505: LD_VAR 0 9
65509: PUSH
65510: LD_EXP 98
65514: PUSH
65515: LD_VAR 0 2
65519: ARRAY
65520: IN
65521: NOT
65522: IFFALSE 65526
// continue ;
65524: GO 65228
// end else
65526: GO 65591
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65528: LD_ADDR_VAR 0 5
65532: PUSH
65533: LD_EXP 67
65537: PUSH
65538: LD_VAR 0 2
65542: ARRAY
65543: PPUSH
65544: LD_VAR 0 4
65548: PPUSH
65549: CALL 51026 0 2
65553: ST_TO_ADDR
// if not tmp2 then
65554: LD_VAR 0 5
65558: NOT
65559: IFFALSE 65563
// continue ;
65561: GO 65228
// tw := tmp2 [ 1 ] ;
65563: LD_ADDR_VAR 0 7
65567: PUSH
65568: LD_VAR 0 5
65572: PUSH
65573: LD_INT 1
65575: ARRAY
65576: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65577: LD_ADDR_VAR 0 9
65581: PUSH
65582: LD_VAR 0 5
65586: PUSH
65587: LD_INT 2
65589: ARRAY
65590: ST_TO_ADDR
// end ; if not weapon then
65591: LD_VAR 0 9
65595: NOT
65596: IFFALSE 65600
// continue ;
65598: GO 65228
// ComPlaceWeapon ( tw , weapon ) ;
65600: LD_VAR 0 7
65604: PPUSH
65605: LD_VAR 0 9
65609: PPUSH
65610: CALL_OW 148
// end ;
65614: GO 65228
65616: POP
65617: POP
// end ;
65618: LD_VAR 0 1
65622: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
65623: LD_INT 0
65625: PPUSH
65626: PPUSH
65627: PPUSH
65628: PPUSH
65629: PPUSH
65630: PPUSH
65631: PPUSH
// if not mc_bases then
65632: LD_EXP 59
65636: NOT
65637: IFFALSE 65641
// exit ;
65639: GO 66409
// for i = 1 to mc_bases do
65641: LD_ADDR_VAR 0 2
65645: PUSH
65646: DOUBLE
65647: LD_INT 1
65649: DEC
65650: ST_TO_ADDR
65651: LD_EXP 59
65655: PUSH
65656: FOR_TO
65657: IFFALSE 66407
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
65659: LD_EXP 72
65663: PUSH
65664: LD_VAR 0 2
65668: ARRAY
65669: NOT
65670: PUSH
65671: LD_EXP 72
65675: PUSH
65676: LD_VAR 0 2
65680: ARRAY
65681: PUSH
65682: LD_EXP 73
65686: PUSH
65687: LD_VAR 0 2
65691: ARRAY
65692: EQUAL
65693: OR
65694: PUSH
65695: LD_EXP 82
65699: PUSH
65700: LD_VAR 0 2
65704: ARRAY
65705: OR
65706: IFFALSE 65710
// continue ;
65708: GO 65656
// if mc_miners [ i ] then
65710: LD_EXP 73
65714: PUSH
65715: LD_VAR 0 2
65719: ARRAY
65720: IFFALSE 66094
// begin for j = mc_miners [ i ] downto 1 do
65722: LD_ADDR_VAR 0 3
65726: PUSH
65727: DOUBLE
65728: LD_EXP 73
65732: PUSH
65733: LD_VAR 0 2
65737: ARRAY
65738: INC
65739: ST_TO_ADDR
65740: LD_INT 1
65742: PUSH
65743: FOR_DOWNTO
65744: IFFALSE 66092
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65746: LD_EXP 73
65750: PUSH
65751: LD_VAR 0 2
65755: ARRAY
65756: PUSH
65757: LD_VAR 0 3
65761: ARRAY
65762: PPUSH
65763: CALL_OW 301
65767: PUSH
65768: LD_EXP 73
65772: PUSH
65773: LD_VAR 0 2
65777: ARRAY
65778: PUSH
65779: LD_VAR 0 3
65783: ARRAY
65784: PPUSH
65785: CALL_OW 257
65789: PUSH
65790: LD_INT 1
65792: NONEQUAL
65793: OR
65794: IFFALSE 65857
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65796: LD_ADDR_VAR 0 5
65800: PUSH
65801: LD_EXP 73
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_EXP 73
65816: PUSH
65817: LD_VAR 0 2
65821: ARRAY
65822: PUSH
65823: LD_VAR 0 3
65827: ARRAY
65828: DIFF
65829: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65830: LD_ADDR_EXP 73
65834: PUSH
65835: LD_EXP 73
65839: PPUSH
65840: LD_VAR 0 2
65844: PPUSH
65845: LD_VAR 0 5
65849: PPUSH
65850: CALL_OW 1
65854: ST_TO_ADDR
// continue ;
65855: GO 65743
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65857: LD_EXP 73
65861: PUSH
65862: LD_VAR 0 2
65866: ARRAY
65867: PUSH
65868: LD_VAR 0 3
65872: ARRAY
65873: PPUSH
65874: CALL_OW 257
65878: PUSH
65879: LD_INT 1
65881: EQUAL
65882: PUSH
65883: LD_EXP 73
65887: PUSH
65888: LD_VAR 0 2
65892: ARRAY
65893: PUSH
65894: LD_VAR 0 3
65898: ARRAY
65899: PPUSH
65900: CALL_OW 459
65904: NOT
65905: AND
65906: PUSH
65907: LD_EXP 73
65911: PUSH
65912: LD_VAR 0 2
65916: ARRAY
65917: PUSH
65918: LD_VAR 0 3
65922: ARRAY
65923: PPUSH
65924: CALL_OW 314
65928: NOT
65929: AND
65930: IFFALSE 66090
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65932: LD_EXP 73
65936: PUSH
65937: LD_VAR 0 2
65941: ARRAY
65942: PUSH
65943: LD_VAR 0 3
65947: ARRAY
65948: PPUSH
65949: CALL_OW 310
65953: IFFALSE 65976
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65955: LD_EXP 73
65959: PUSH
65960: LD_VAR 0 2
65964: ARRAY
65965: PUSH
65966: LD_VAR 0 3
65970: ARRAY
65971: PPUSH
65972: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65976: LD_EXP 73
65980: PUSH
65981: LD_VAR 0 2
65985: ARRAY
65986: PUSH
65987: LD_VAR 0 3
65991: ARRAY
65992: PPUSH
65993: CALL_OW 314
65997: NOT
65998: IFFALSE 66090
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66000: LD_ADDR_VAR 0 7
66004: PUSH
66005: LD_INT 1
66007: PPUSH
66008: LD_EXP 72
66012: PUSH
66013: LD_VAR 0 2
66017: ARRAY
66018: PPUSH
66019: CALL_OW 12
66023: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66024: LD_EXP 73
66028: PUSH
66029: LD_VAR 0 2
66033: ARRAY
66034: PUSH
66035: LD_VAR 0 3
66039: ARRAY
66040: PPUSH
66041: LD_EXP 72
66045: PUSH
66046: LD_VAR 0 2
66050: ARRAY
66051: PUSH
66052: LD_VAR 0 7
66056: ARRAY
66057: PUSH
66058: LD_INT 1
66060: ARRAY
66061: PPUSH
66062: LD_EXP 72
66066: PUSH
66067: LD_VAR 0 2
66071: ARRAY
66072: PUSH
66073: LD_VAR 0 7
66077: ARRAY
66078: PUSH
66079: LD_INT 2
66081: ARRAY
66082: PPUSH
66083: LD_INT 0
66085: PPUSH
66086: CALL_OW 193
// end ; end ; end ;
66090: GO 65743
66092: POP
66093: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66094: LD_ADDR_VAR 0 5
66098: PUSH
66099: LD_EXP 59
66103: PUSH
66104: LD_VAR 0 2
66108: ARRAY
66109: PPUSH
66110: LD_INT 2
66112: PUSH
66113: LD_INT 30
66115: PUSH
66116: LD_INT 4
66118: PUSH
66119: EMPTY
66120: LIST
66121: LIST
66122: PUSH
66123: LD_INT 30
66125: PUSH
66126: LD_INT 5
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 30
66135: PUSH
66136: LD_INT 32
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: PPUSH
66149: CALL_OW 72
66153: ST_TO_ADDR
// if not tmp then
66154: LD_VAR 0 5
66158: NOT
66159: IFFALSE 66163
// continue ;
66161: GO 65656
// list := [ ] ;
66163: LD_ADDR_VAR 0 6
66167: PUSH
66168: EMPTY
66169: ST_TO_ADDR
// for j in tmp do
66170: LD_ADDR_VAR 0 3
66174: PUSH
66175: LD_VAR 0 5
66179: PUSH
66180: FOR_IN
66181: IFFALSE 66250
// begin for k in UnitsInside ( j ) do
66183: LD_ADDR_VAR 0 4
66187: PUSH
66188: LD_VAR 0 3
66192: PPUSH
66193: CALL_OW 313
66197: PUSH
66198: FOR_IN
66199: IFFALSE 66246
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66201: LD_VAR 0 4
66205: PPUSH
66206: CALL_OW 257
66210: PUSH
66211: LD_INT 1
66213: EQUAL
66214: PUSH
66215: LD_VAR 0 4
66219: PPUSH
66220: CALL_OW 459
66224: NOT
66225: AND
66226: IFFALSE 66244
// list := list ^ k ;
66228: LD_ADDR_VAR 0 6
66232: PUSH
66233: LD_VAR 0 6
66237: PUSH
66238: LD_VAR 0 4
66242: ADD
66243: ST_TO_ADDR
66244: GO 66198
66246: POP
66247: POP
// end ;
66248: GO 66180
66250: POP
66251: POP
// list := list diff mc_miners [ i ] ;
66252: LD_ADDR_VAR 0 6
66256: PUSH
66257: LD_VAR 0 6
66261: PUSH
66262: LD_EXP 73
66266: PUSH
66267: LD_VAR 0 2
66271: ARRAY
66272: DIFF
66273: ST_TO_ADDR
// if not list then
66274: LD_VAR 0 6
66278: NOT
66279: IFFALSE 66283
// continue ;
66281: GO 65656
// k := mc_mines [ i ] - mc_miners [ i ] ;
66283: LD_ADDR_VAR 0 4
66287: PUSH
66288: LD_EXP 72
66292: PUSH
66293: LD_VAR 0 2
66297: ARRAY
66298: PUSH
66299: LD_EXP 73
66303: PUSH
66304: LD_VAR 0 2
66308: ARRAY
66309: MINUS
66310: ST_TO_ADDR
// if k > list then
66311: LD_VAR 0 4
66315: PUSH
66316: LD_VAR 0 6
66320: GREATER
66321: IFFALSE 66333
// k := list ;
66323: LD_ADDR_VAR 0 4
66327: PUSH
66328: LD_VAR 0 6
66332: ST_TO_ADDR
// for j = 1 to k do
66333: LD_ADDR_VAR 0 3
66337: PUSH
66338: DOUBLE
66339: LD_INT 1
66341: DEC
66342: ST_TO_ADDR
66343: LD_VAR 0 4
66347: PUSH
66348: FOR_TO
66349: IFFALSE 66403
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66351: LD_ADDR_EXP 73
66355: PUSH
66356: LD_EXP 73
66360: PPUSH
66361: LD_VAR 0 2
66365: PUSH
66366: LD_EXP 73
66370: PUSH
66371: LD_VAR 0 2
66375: ARRAY
66376: PUSH
66377: LD_INT 1
66379: PLUS
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PPUSH
66385: LD_VAR 0 6
66389: PUSH
66390: LD_VAR 0 3
66394: ARRAY
66395: PPUSH
66396: CALL 19726 0 3
66400: ST_TO_ADDR
66401: GO 66348
66403: POP
66404: POP
// end ;
66405: GO 65656
66407: POP
66408: POP
// end ;
66409: LD_VAR 0 1
66413: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
66414: LD_INT 0
66416: PPUSH
66417: PPUSH
66418: PPUSH
66419: PPUSH
66420: PPUSH
66421: PPUSH
66422: PPUSH
66423: PPUSH
66424: PPUSH
66425: PPUSH
// if not mc_bases then
66426: LD_EXP 59
66430: NOT
66431: IFFALSE 66435
// exit ;
66433: GO 68185
// for i = 1 to mc_bases do
66435: LD_ADDR_VAR 0 2
66439: PUSH
66440: DOUBLE
66441: LD_INT 1
66443: DEC
66444: ST_TO_ADDR
66445: LD_EXP 59
66449: PUSH
66450: FOR_TO
66451: IFFALSE 68183
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66453: LD_EXP 59
66457: PUSH
66458: LD_VAR 0 2
66462: ARRAY
66463: NOT
66464: PUSH
66465: LD_EXP 66
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: OR
66476: IFFALSE 66480
// continue ;
66478: GO 66450
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66480: LD_EXP 75
66484: PUSH
66485: LD_VAR 0 2
66489: ARRAY
66490: NOT
66491: PUSH
66492: LD_EXP 76
66496: PUSH
66497: LD_VAR 0 2
66501: ARRAY
66502: AND
66503: IFFALSE 66541
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66505: LD_ADDR_EXP 76
66509: PUSH
66510: LD_EXP 76
66514: PPUSH
66515: LD_VAR 0 2
66519: PPUSH
66520: EMPTY
66521: PPUSH
66522: CALL_OW 1
66526: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66527: LD_VAR 0 2
66531: PPUSH
66532: LD_INT 107
66534: PPUSH
66535: CALL 57368 0 2
// continue ;
66539: GO 66450
// end ; target := [ ] ;
66541: LD_ADDR_VAR 0 6
66545: PUSH
66546: EMPTY
66547: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66548: LD_ADDR_VAR 0 3
66552: PUSH
66553: DOUBLE
66554: LD_EXP 75
66558: PUSH
66559: LD_VAR 0 2
66563: ARRAY
66564: INC
66565: ST_TO_ADDR
66566: LD_INT 1
66568: PUSH
66569: FOR_DOWNTO
66570: IFFALSE 66830
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66572: LD_EXP 75
66576: PUSH
66577: LD_VAR 0 2
66581: ARRAY
66582: PUSH
66583: LD_VAR 0 3
66587: ARRAY
66588: PUSH
66589: LD_INT 2
66591: ARRAY
66592: PPUSH
66593: LD_EXP 75
66597: PUSH
66598: LD_VAR 0 2
66602: ARRAY
66603: PUSH
66604: LD_VAR 0 3
66608: ARRAY
66609: PUSH
66610: LD_INT 3
66612: ARRAY
66613: PPUSH
66614: CALL_OW 488
66618: PUSH
66619: LD_EXP 75
66623: PUSH
66624: LD_VAR 0 2
66628: ARRAY
66629: PUSH
66630: LD_VAR 0 3
66634: ARRAY
66635: PUSH
66636: LD_INT 2
66638: ARRAY
66639: PPUSH
66640: LD_EXP 75
66644: PUSH
66645: LD_VAR 0 2
66649: ARRAY
66650: PUSH
66651: LD_VAR 0 3
66655: ARRAY
66656: PUSH
66657: LD_INT 3
66659: ARRAY
66660: PPUSH
66661: CALL_OW 284
66665: PUSH
66666: LD_INT 0
66668: EQUAL
66669: AND
66670: IFFALSE 66725
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66672: LD_ADDR_VAR 0 5
66676: PUSH
66677: LD_EXP 75
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: PPUSH
66688: LD_VAR 0 3
66692: PPUSH
66693: CALL_OW 3
66697: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66698: LD_ADDR_EXP 75
66702: PUSH
66703: LD_EXP 75
66707: PPUSH
66708: LD_VAR 0 2
66712: PPUSH
66713: LD_VAR 0 5
66717: PPUSH
66718: CALL_OW 1
66722: ST_TO_ADDR
// continue ;
66723: GO 66569
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66725: LD_EXP 59
66729: PUSH
66730: LD_VAR 0 2
66734: ARRAY
66735: PUSH
66736: LD_INT 1
66738: ARRAY
66739: PPUSH
66740: CALL_OW 255
66744: PPUSH
66745: LD_EXP 75
66749: PUSH
66750: LD_VAR 0 2
66754: ARRAY
66755: PUSH
66756: LD_VAR 0 3
66760: ARRAY
66761: PUSH
66762: LD_INT 2
66764: ARRAY
66765: PPUSH
66766: LD_EXP 75
66770: PUSH
66771: LD_VAR 0 2
66775: ARRAY
66776: PUSH
66777: LD_VAR 0 3
66781: ARRAY
66782: PUSH
66783: LD_INT 3
66785: ARRAY
66786: PPUSH
66787: LD_INT 30
66789: PPUSH
66790: CALL 20622 0 4
66794: PUSH
66795: LD_INT 4
66797: ARRAY
66798: PUSH
66799: LD_INT 0
66801: EQUAL
66802: IFFALSE 66828
// begin target := mc_crates [ i ] [ j ] ;
66804: LD_ADDR_VAR 0 6
66808: PUSH
66809: LD_EXP 75
66813: PUSH
66814: LD_VAR 0 2
66818: ARRAY
66819: PUSH
66820: LD_VAR 0 3
66824: ARRAY
66825: ST_TO_ADDR
// break ;
66826: GO 66830
// end ; end ;
66828: GO 66569
66830: POP
66831: POP
// if not target then
66832: LD_VAR 0 6
66836: NOT
66837: IFFALSE 66841
// continue ;
66839: GO 66450
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66841: LD_ADDR_VAR 0 7
66845: PUSH
66846: LD_EXP 78
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PPUSH
66857: LD_INT 2
66859: PUSH
66860: LD_INT 3
66862: PUSH
66863: LD_INT 58
66865: PUSH
66866: EMPTY
66867: LIST
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 61
66875: PUSH
66876: EMPTY
66877: LIST
66878: PUSH
66879: LD_INT 33
66881: PUSH
66882: LD_INT 5
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 33
66891: PUSH
66892: LD_INT 3
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: LD_INT 34
66911: PUSH
66912: LD_INT 32
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 34
66921: PUSH
66922: LD_INT 51
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 34
66931: PUSH
66932: LD_INT 12
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PPUSH
66949: CALL_OW 72
66953: ST_TO_ADDR
// if not cargo then
66954: LD_VAR 0 7
66958: NOT
66959: IFFALSE 67602
// begin if mc_crates_collector [ i ] < 5 then
66961: LD_EXP 76
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: PUSH
66972: LD_INT 5
66974: LESS
66975: IFFALSE 67341
// begin if mc_ape [ i ] then
66977: LD_EXP 88
66981: PUSH
66982: LD_VAR 0 2
66986: ARRAY
66987: IFFALSE 67034
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66989: LD_ADDR_VAR 0 5
66993: PUSH
66994: LD_EXP 88
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: PPUSH
67005: LD_INT 25
67007: PUSH
67008: LD_INT 16
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 24
67017: PUSH
67018: LD_INT 750
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PPUSH
67029: CALL_OW 72
67033: ST_TO_ADDR
// if not tmp then
67034: LD_VAR 0 5
67038: NOT
67039: IFFALSE 67086
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67041: LD_ADDR_VAR 0 5
67045: PUSH
67046: LD_EXP 59
67050: PUSH
67051: LD_VAR 0 2
67055: ARRAY
67056: PPUSH
67057: LD_INT 25
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 24
67069: PUSH
67070: LD_INT 750
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PPUSH
67081: CALL_OW 72
67085: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67086: LD_EXP 88
67090: PUSH
67091: LD_VAR 0 2
67095: ARRAY
67096: PUSH
67097: LD_EXP 59
67101: PUSH
67102: LD_VAR 0 2
67106: ARRAY
67107: PPUSH
67108: LD_INT 25
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 24
67120: PUSH
67121: LD_INT 750
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PPUSH
67132: CALL_OW 72
67136: AND
67137: PUSH
67138: LD_VAR 0 5
67142: PUSH
67143: LD_INT 5
67145: LESS
67146: AND
67147: IFFALSE 67229
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67149: LD_ADDR_VAR 0 3
67153: PUSH
67154: LD_EXP 59
67158: PUSH
67159: LD_VAR 0 2
67163: ARRAY
67164: PPUSH
67165: LD_INT 25
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 24
67177: PUSH
67178: LD_INT 750
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PPUSH
67189: CALL_OW 72
67193: PUSH
67194: FOR_IN
67195: IFFALSE 67227
// begin tmp := tmp union j ;
67197: LD_ADDR_VAR 0 5
67201: PUSH
67202: LD_VAR 0 5
67206: PUSH
67207: LD_VAR 0 3
67211: UNION
67212: ST_TO_ADDR
// if tmp >= 5 then
67213: LD_VAR 0 5
67217: PUSH
67218: LD_INT 5
67220: GREATEREQUAL
67221: IFFALSE 67225
// break ;
67223: GO 67227
// end ;
67225: GO 67194
67227: POP
67228: POP
// end ; if not tmp then
67229: LD_VAR 0 5
67233: NOT
67234: IFFALSE 67238
// continue ;
67236: GO 66450
// for j in tmp do
67238: LD_ADDR_VAR 0 3
67242: PUSH
67243: LD_VAR 0 5
67247: PUSH
67248: FOR_IN
67249: IFFALSE 67339
// if not GetTag ( j ) then
67251: LD_VAR 0 3
67255: PPUSH
67256: CALL_OW 110
67260: NOT
67261: IFFALSE 67337
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67263: LD_ADDR_EXP 76
67267: PUSH
67268: LD_EXP 76
67272: PPUSH
67273: LD_VAR 0 2
67277: PUSH
67278: LD_EXP 76
67282: PUSH
67283: LD_VAR 0 2
67287: ARRAY
67288: PUSH
67289: LD_INT 1
67291: PLUS
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PPUSH
67297: LD_VAR 0 3
67301: PPUSH
67302: CALL 19726 0 3
67306: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67307: LD_VAR 0 3
67311: PPUSH
67312: LD_INT 107
67314: PPUSH
67315: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67319: LD_EXP 76
67323: PUSH
67324: LD_VAR 0 2
67328: ARRAY
67329: PUSH
67330: LD_INT 5
67332: GREATEREQUAL
67333: IFFALSE 67337
// break ;
67335: GO 67339
// end ;
67337: GO 67248
67339: POP
67340: POP
// end ; if mc_crates_collector [ i ] and target then
67341: LD_EXP 76
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: PUSH
67352: LD_VAR 0 6
67356: AND
67357: IFFALSE 67600
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67359: LD_EXP 76
67363: PUSH
67364: LD_VAR 0 2
67368: ARRAY
67369: PUSH
67370: LD_VAR 0 6
67374: PUSH
67375: LD_INT 1
67377: ARRAY
67378: LESS
67379: IFFALSE 67399
// tmp := mc_crates_collector [ i ] else
67381: LD_ADDR_VAR 0 5
67385: PUSH
67386: LD_EXP 76
67390: PUSH
67391: LD_VAR 0 2
67395: ARRAY
67396: ST_TO_ADDR
67397: GO 67413
// tmp := target [ 1 ] ;
67399: LD_ADDR_VAR 0 5
67403: PUSH
67404: LD_VAR 0 6
67408: PUSH
67409: LD_INT 1
67411: ARRAY
67412: ST_TO_ADDR
// k := 0 ;
67413: LD_ADDR_VAR 0 4
67417: PUSH
67418: LD_INT 0
67420: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67421: LD_ADDR_VAR 0 3
67425: PUSH
67426: LD_EXP 76
67430: PUSH
67431: LD_VAR 0 2
67435: ARRAY
67436: PUSH
67437: FOR_IN
67438: IFFALSE 67598
// begin k := k + 1 ;
67440: LD_ADDR_VAR 0 4
67444: PUSH
67445: LD_VAR 0 4
67449: PUSH
67450: LD_INT 1
67452: PLUS
67453: ST_TO_ADDR
// if k > tmp then
67454: LD_VAR 0 4
67458: PUSH
67459: LD_VAR 0 5
67463: GREATER
67464: IFFALSE 67468
// break ;
67466: GO 67598
// if not GetClass ( j ) in [ 2 , 16 ] then
67468: LD_VAR 0 3
67472: PPUSH
67473: CALL_OW 257
67477: PUSH
67478: LD_INT 2
67480: PUSH
67481: LD_INT 16
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: IN
67488: NOT
67489: IFFALSE 67542
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
67491: LD_ADDR_EXP 76
67495: PUSH
67496: LD_EXP 76
67500: PPUSH
67501: LD_VAR 0 2
67505: PPUSH
67506: LD_EXP 76
67510: PUSH
67511: LD_VAR 0 2
67515: ARRAY
67516: PUSH
67517: LD_VAR 0 3
67521: DIFF
67522: PPUSH
67523: CALL_OW 1
67527: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67528: LD_VAR 0 3
67532: PPUSH
67533: LD_INT 0
67535: PPUSH
67536: CALL_OW 109
// continue ;
67540: GO 67437
// end ; if IsInUnit ( j ) then
67542: LD_VAR 0 3
67546: PPUSH
67547: CALL_OW 310
67551: IFFALSE 67562
// ComExitBuilding ( j ) ;
67553: LD_VAR 0 3
67557: PPUSH
67558: CALL_OW 122
// wait ( 3 ) ;
67562: LD_INT 3
67564: PPUSH
67565: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67569: LD_VAR 0 3
67573: PPUSH
67574: LD_VAR 0 6
67578: PUSH
67579: LD_INT 2
67581: ARRAY
67582: PPUSH
67583: LD_VAR 0 6
67587: PUSH
67588: LD_INT 3
67590: ARRAY
67591: PPUSH
67592: CALL_OW 117
// end ;
67596: GO 67437
67598: POP
67599: POP
// end ; end else
67600: GO 68181
// begin for j in cargo do
67602: LD_ADDR_VAR 0 3
67606: PUSH
67607: LD_VAR 0 7
67611: PUSH
67612: FOR_IN
67613: IFFALSE 68179
// begin if GetTag ( j ) <> 0 then
67615: LD_VAR 0 3
67619: PPUSH
67620: CALL_OW 110
67624: PUSH
67625: LD_INT 0
67627: NONEQUAL
67628: IFFALSE 67632
// continue ;
67630: GO 67612
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67632: LD_VAR 0 3
67636: PPUSH
67637: CALL_OW 256
67641: PUSH
67642: LD_INT 1000
67644: LESS
67645: PUSH
67646: LD_VAR 0 3
67650: PPUSH
67651: LD_EXP 83
67655: PUSH
67656: LD_VAR 0 2
67660: ARRAY
67661: PPUSH
67662: CALL_OW 308
67666: NOT
67667: AND
67668: IFFALSE 67690
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67670: LD_VAR 0 3
67674: PPUSH
67675: LD_EXP 83
67679: PUSH
67680: LD_VAR 0 2
67684: ARRAY
67685: PPUSH
67686: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67690: LD_VAR 0 3
67694: PPUSH
67695: CALL_OW 256
67699: PUSH
67700: LD_INT 1000
67702: LESS
67703: PUSH
67704: LD_VAR 0 3
67708: PPUSH
67709: LD_EXP 83
67713: PUSH
67714: LD_VAR 0 2
67718: ARRAY
67719: PPUSH
67720: CALL_OW 308
67724: AND
67725: IFFALSE 67729
// continue ;
67727: GO 67612
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67729: LD_VAR 0 3
67733: PPUSH
67734: CALL_OW 262
67738: PUSH
67739: LD_INT 2
67741: EQUAL
67742: PUSH
67743: LD_VAR 0 3
67747: PPUSH
67748: CALL_OW 261
67752: PUSH
67753: LD_INT 15
67755: LESS
67756: AND
67757: IFFALSE 67761
// continue ;
67759: GO 67612
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67761: LD_VAR 0 3
67765: PPUSH
67766: CALL_OW 262
67770: PUSH
67771: LD_INT 1
67773: EQUAL
67774: PUSH
67775: LD_VAR 0 3
67779: PPUSH
67780: CALL_OW 261
67784: PUSH
67785: LD_INT 10
67787: LESS
67788: AND
67789: IFFALSE 68118
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67791: LD_ADDR_VAR 0 8
67795: PUSH
67796: LD_EXP 59
67800: PUSH
67801: LD_VAR 0 2
67805: ARRAY
67806: PPUSH
67807: LD_INT 2
67809: PUSH
67810: LD_INT 30
67812: PUSH
67813: LD_INT 0
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 30
67822: PUSH
67823: LD_INT 1
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: LIST
67834: PPUSH
67835: CALL_OW 72
67839: ST_TO_ADDR
// if not depot then
67840: LD_VAR 0 8
67844: NOT
67845: IFFALSE 67849
// continue ;
67847: GO 67612
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67849: LD_VAR 0 3
67853: PPUSH
67854: LD_VAR 0 8
67858: PPUSH
67859: LD_VAR 0 3
67863: PPUSH
67864: CALL_OW 74
67868: PPUSH
67869: CALL_OW 296
67873: PUSH
67874: LD_INT 6
67876: LESS
67877: IFFALSE 67893
// SetFuel ( j , 100 ) else
67879: LD_VAR 0 3
67883: PPUSH
67884: LD_INT 100
67886: PPUSH
67887: CALL_OW 240
67891: GO 68118
// if GetFuel ( j ) = 0 then
67893: LD_VAR 0 3
67897: PPUSH
67898: CALL_OW 261
67902: PUSH
67903: LD_INT 0
67905: EQUAL
67906: IFFALSE 68118
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67908: LD_ADDR_EXP 78
67912: PUSH
67913: LD_EXP 78
67917: PPUSH
67918: LD_VAR 0 2
67922: PPUSH
67923: LD_EXP 78
67927: PUSH
67928: LD_VAR 0 2
67932: ARRAY
67933: PUSH
67934: LD_VAR 0 3
67938: DIFF
67939: PPUSH
67940: CALL_OW 1
67944: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67945: LD_VAR 0 3
67949: PPUSH
67950: CALL_OW 263
67954: PUSH
67955: LD_INT 1
67957: EQUAL
67958: IFFALSE 67974
// ComExitVehicle ( IsInUnit ( j ) ) ;
67960: LD_VAR 0 3
67964: PPUSH
67965: CALL_OW 310
67969: PPUSH
67970: CALL_OW 121
// if GetControl ( j ) = control_remote then
67974: LD_VAR 0 3
67978: PPUSH
67979: CALL_OW 263
67983: PUSH
67984: LD_INT 2
67986: EQUAL
67987: IFFALSE 67998
// ComUnlink ( j ) ;
67989: LD_VAR 0 3
67993: PPUSH
67994: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67998: LD_ADDR_VAR 0 9
68002: PUSH
68003: LD_VAR 0 2
68007: PPUSH
68008: LD_INT 3
68010: PPUSH
68011: CALL 77588 0 2
68015: ST_TO_ADDR
// if fac then
68016: LD_VAR 0 9
68020: IFFALSE 68116
// begin for k in fac do
68022: LD_ADDR_VAR 0 4
68026: PUSH
68027: LD_VAR 0 9
68031: PUSH
68032: FOR_IN
68033: IFFALSE 68114
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68035: LD_ADDR_VAR 0 10
68039: PUSH
68040: LD_VAR 0 9
68044: PPUSH
68045: LD_VAR 0 3
68049: PPUSH
68050: CALL_OW 265
68054: PPUSH
68055: LD_VAR 0 3
68059: PPUSH
68060: CALL_OW 262
68064: PPUSH
68065: LD_VAR 0 3
68069: PPUSH
68070: CALL_OW 263
68074: PPUSH
68075: LD_VAR 0 3
68079: PPUSH
68080: CALL_OW 264
68084: PPUSH
68085: CALL 17222 0 5
68089: ST_TO_ADDR
// if components then
68090: LD_VAR 0 10
68094: IFFALSE 68112
// begin MC_InsertProduceList ( i , components ) ;
68096: LD_VAR 0 2
68100: PPUSH
68101: LD_VAR 0 10
68105: PPUSH
68106: CALL 77133 0 2
// break ;
68110: GO 68114
// end ; end ;
68112: GO 68032
68114: POP
68115: POP
// end ; continue ;
68116: GO 67612
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68118: LD_VAR 0 3
68122: PPUSH
68123: LD_INT 1
68125: PPUSH
68126: CALL_OW 289
68130: PUSH
68131: LD_INT 100
68133: LESS
68134: PUSH
68135: LD_VAR 0 3
68139: PPUSH
68140: CALL_OW 314
68144: NOT
68145: AND
68146: IFFALSE 68175
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68148: LD_VAR 0 3
68152: PPUSH
68153: LD_VAR 0 6
68157: PUSH
68158: LD_INT 2
68160: ARRAY
68161: PPUSH
68162: LD_VAR 0 6
68166: PUSH
68167: LD_INT 3
68169: ARRAY
68170: PPUSH
68171: CALL_OW 117
// break ;
68175: GO 68179
// end ;
68177: GO 67612
68179: POP
68180: POP
// end ; end ;
68181: GO 66450
68183: POP
68184: POP
// end ;
68185: LD_VAR 0 1
68189: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68190: LD_INT 0
68192: PPUSH
68193: PPUSH
68194: PPUSH
68195: PPUSH
// if not mc_bases then
68196: LD_EXP 59
68200: NOT
68201: IFFALSE 68205
// exit ;
68203: GO 68366
// for i = 1 to mc_bases do
68205: LD_ADDR_VAR 0 2
68209: PUSH
68210: DOUBLE
68211: LD_INT 1
68213: DEC
68214: ST_TO_ADDR
68215: LD_EXP 59
68219: PUSH
68220: FOR_TO
68221: IFFALSE 68364
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68223: LD_ADDR_VAR 0 4
68227: PUSH
68228: LD_EXP 78
68232: PUSH
68233: LD_VAR 0 2
68237: ARRAY
68238: PUSH
68239: LD_EXP 81
68243: PUSH
68244: LD_VAR 0 2
68248: ARRAY
68249: UNION
68250: PPUSH
68251: LD_INT 33
68253: PUSH
68254: LD_INT 2
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PPUSH
68261: CALL_OW 72
68265: ST_TO_ADDR
// if tmp then
68266: LD_VAR 0 4
68270: IFFALSE 68362
// for j in tmp do
68272: LD_ADDR_VAR 0 3
68276: PUSH
68277: LD_VAR 0 4
68281: PUSH
68282: FOR_IN
68283: IFFALSE 68360
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68285: LD_VAR 0 3
68289: PPUSH
68290: CALL_OW 312
68294: NOT
68295: PUSH
68296: LD_VAR 0 3
68300: PPUSH
68301: CALL_OW 256
68305: PUSH
68306: LD_INT 250
68308: GREATEREQUAL
68309: AND
68310: IFFALSE 68323
// Connect ( j ) else
68312: LD_VAR 0 3
68316: PPUSH
68317: CALL 22697 0 1
68321: GO 68358
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68323: LD_VAR 0 3
68327: PPUSH
68328: CALL_OW 256
68332: PUSH
68333: LD_INT 250
68335: LESS
68336: PUSH
68337: LD_VAR 0 3
68341: PPUSH
68342: CALL_OW 312
68346: AND
68347: IFFALSE 68358
// ComUnlink ( j ) ;
68349: LD_VAR 0 3
68353: PPUSH
68354: CALL_OW 136
68358: GO 68282
68360: POP
68361: POP
// end ;
68362: GO 68220
68364: POP
68365: POP
// end ;
68366: LD_VAR 0 1
68370: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68371: LD_INT 0
68373: PPUSH
68374: PPUSH
68375: PPUSH
68376: PPUSH
68377: PPUSH
// if not mc_bases then
68378: LD_EXP 59
68382: NOT
68383: IFFALSE 68387
// exit ;
68385: GO 68832
// for i = 1 to mc_bases do
68387: LD_ADDR_VAR 0 2
68391: PUSH
68392: DOUBLE
68393: LD_INT 1
68395: DEC
68396: ST_TO_ADDR
68397: LD_EXP 59
68401: PUSH
68402: FOR_TO
68403: IFFALSE 68830
// begin if not mc_produce [ i ] then
68405: LD_EXP 80
68409: PUSH
68410: LD_VAR 0 2
68414: ARRAY
68415: NOT
68416: IFFALSE 68420
// continue ;
68418: GO 68402
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68420: LD_ADDR_VAR 0 5
68424: PUSH
68425: LD_EXP 59
68429: PUSH
68430: LD_VAR 0 2
68434: ARRAY
68435: PPUSH
68436: LD_INT 30
68438: PUSH
68439: LD_INT 3
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PPUSH
68446: CALL_OW 72
68450: ST_TO_ADDR
// if not fac then
68451: LD_VAR 0 5
68455: NOT
68456: IFFALSE 68460
// continue ;
68458: GO 68402
// for j in fac do
68460: LD_ADDR_VAR 0 3
68464: PUSH
68465: LD_VAR 0 5
68469: PUSH
68470: FOR_IN
68471: IFFALSE 68826
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
68473: LD_VAR 0 3
68477: PPUSH
68478: CALL_OW 461
68482: PUSH
68483: LD_INT 2
68485: NONEQUAL
68486: PUSH
68487: LD_VAR 0 3
68491: PPUSH
68492: LD_INT 15
68494: PPUSH
68495: CALL 22325 0 2
68499: PUSH
68500: LD_INT 4
68502: ARRAY
68503: OR
68504: IFFALSE 68508
// continue ;
68506: GO 68470
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
68508: LD_VAR 0 3
68512: PPUSH
68513: LD_EXP 80
68517: PUSH
68518: LD_VAR 0 2
68522: ARRAY
68523: PUSH
68524: LD_INT 1
68526: ARRAY
68527: PUSH
68528: LD_INT 1
68530: ARRAY
68531: PPUSH
68532: LD_EXP 80
68536: PUSH
68537: LD_VAR 0 2
68541: ARRAY
68542: PUSH
68543: LD_INT 1
68545: ARRAY
68546: PUSH
68547: LD_INT 2
68549: ARRAY
68550: PPUSH
68551: LD_EXP 80
68555: PUSH
68556: LD_VAR 0 2
68560: ARRAY
68561: PUSH
68562: LD_INT 1
68564: ARRAY
68565: PUSH
68566: LD_INT 3
68568: ARRAY
68569: PPUSH
68570: LD_EXP 80
68574: PUSH
68575: LD_VAR 0 2
68579: ARRAY
68580: PUSH
68581: LD_INT 1
68583: ARRAY
68584: PUSH
68585: LD_INT 4
68587: ARRAY
68588: PPUSH
68589: CALL_OW 448
68593: PUSH
68594: LD_VAR 0 3
68598: PPUSH
68599: LD_EXP 80
68603: PUSH
68604: LD_VAR 0 2
68608: ARRAY
68609: PUSH
68610: LD_INT 1
68612: ARRAY
68613: PUSH
68614: LD_INT 1
68616: ARRAY
68617: PUSH
68618: LD_EXP 80
68622: PUSH
68623: LD_VAR 0 2
68627: ARRAY
68628: PUSH
68629: LD_INT 1
68631: ARRAY
68632: PUSH
68633: LD_INT 2
68635: ARRAY
68636: PUSH
68637: LD_EXP 80
68641: PUSH
68642: LD_VAR 0 2
68646: ARRAY
68647: PUSH
68648: LD_INT 1
68650: ARRAY
68651: PUSH
68652: LD_INT 3
68654: ARRAY
68655: PUSH
68656: LD_EXP 80
68660: PUSH
68661: LD_VAR 0 2
68665: ARRAY
68666: PUSH
68667: LD_INT 1
68669: ARRAY
68670: PUSH
68671: LD_INT 4
68673: ARRAY
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: PPUSH
68681: CALL 26093 0 2
68685: AND
68686: IFFALSE 68824
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68688: LD_VAR 0 3
68692: PPUSH
68693: LD_EXP 80
68697: PUSH
68698: LD_VAR 0 2
68702: ARRAY
68703: PUSH
68704: LD_INT 1
68706: ARRAY
68707: PUSH
68708: LD_INT 1
68710: ARRAY
68711: PPUSH
68712: LD_EXP 80
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PUSH
68723: LD_INT 1
68725: ARRAY
68726: PUSH
68727: LD_INT 2
68729: ARRAY
68730: PPUSH
68731: LD_EXP 80
68735: PUSH
68736: LD_VAR 0 2
68740: ARRAY
68741: PUSH
68742: LD_INT 1
68744: ARRAY
68745: PUSH
68746: LD_INT 3
68748: ARRAY
68749: PPUSH
68750: LD_EXP 80
68754: PUSH
68755: LD_VAR 0 2
68759: ARRAY
68760: PUSH
68761: LD_INT 1
68763: ARRAY
68764: PUSH
68765: LD_INT 4
68767: ARRAY
68768: PPUSH
68769: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68773: LD_ADDR_VAR 0 4
68777: PUSH
68778: LD_EXP 80
68782: PUSH
68783: LD_VAR 0 2
68787: ARRAY
68788: PPUSH
68789: LD_INT 1
68791: PPUSH
68792: CALL_OW 3
68796: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68797: LD_ADDR_EXP 80
68801: PUSH
68802: LD_EXP 80
68806: PPUSH
68807: LD_VAR 0 2
68811: PPUSH
68812: LD_VAR 0 4
68816: PPUSH
68817: CALL_OW 1
68821: ST_TO_ADDR
// break ;
68822: GO 68826
// end ; end ;
68824: GO 68470
68826: POP
68827: POP
// end ;
68828: GO 68402
68830: POP
68831: POP
// end ;
68832: LD_VAR 0 1
68836: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68837: LD_INT 0
68839: PPUSH
68840: PPUSH
68841: PPUSH
// if not mc_bases then
68842: LD_EXP 59
68846: NOT
68847: IFFALSE 68851
// exit ;
68849: GO 68940
// for i = 1 to mc_bases do
68851: LD_ADDR_VAR 0 2
68855: PUSH
68856: DOUBLE
68857: LD_INT 1
68859: DEC
68860: ST_TO_ADDR
68861: LD_EXP 59
68865: PUSH
68866: FOR_TO
68867: IFFALSE 68938
// begin if mc_attack [ i ] then
68869: LD_EXP 79
68873: PUSH
68874: LD_VAR 0 2
68878: ARRAY
68879: IFFALSE 68936
// begin tmp := mc_attack [ i ] [ 1 ] ;
68881: LD_ADDR_VAR 0 3
68885: PUSH
68886: LD_EXP 79
68890: PUSH
68891: LD_VAR 0 2
68895: ARRAY
68896: PUSH
68897: LD_INT 1
68899: ARRAY
68900: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68901: LD_ADDR_EXP 79
68905: PUSH
68906: LD_EXP 79
68910: PPUSH
68911: LD_VAR 0 2
68915: PPUSH
68916: EMPTY
68917: PPUSH
68918: CALL_OW 1
68922: ST_TO_ADDR
// Attack ( tmp ) ;
68923: LD_VAR 0 3
68927: PPUSH
68928: CALL 100885 0 1
// exit ;
68932: POP
68933: POP
68934: GO 68940
// end ; end ;
68936: GO 68866
68938: POP
68939: POP
// end ;
68940: LD_VAR 0 1
68944: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68945: LD_INT 0
68947: PPUSH
68948: PPUSH
68949: PPUSH
68950: PPUSH
68951: PPUSH
68952: PPUSH
68953: PPUSH
// if not mc_bases then
68954: LD_EXP 59
68958: NOT
68959: IFFALSE 68963
// exit ;
68961: GO 69662
// for i = 1 to mc_bases do
68963: LD_ADDR_VAR 0 2
68967: PUSH
68968: DOUBLE
68969: LD_INT 1
68971: DEC
68972: ST_TO_ADDR
68973: LD_EXP 59
68977: PUSH
68978: FOR_TO
68979: IFFALSE 69660
// begin if not mc_bases [ i ] then
68981: LD_EXP 59
68985: PUSH
68986: LD_VAR 0 2
68990: ARRAY
68991: NOT
68992: IFFALSE 68996
// continue ;
68994: GO 68978
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68996: LD_ADDR_VAR 0 7
69000: PUSH
69001: LD_EXP 59
69005: PUSH
69006: LD_VAR 0 2
69010: ARRAY
69011: PUSH
69012: LD_INT 1
69014: ARRAY
69015: PPUSH
69016: CALL 16526 0 1
69020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69021: LD_ADDR_EXP 82
69025: PUSH
69026: LD_EXP 82
69030: PPUSH
69031: LD_VAR 0 2
69035: PPUSH
69036: LD_EXP 59
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: PUSH
69047: LD_INT 1
69049: ARRAY
69050: PPUSH
69051: CALL_OW 255
69055: PPUSH
69056: LD_EXP 84
69060: PUSH
69061: LD_VAR 0 2
69065: ARRAY
69066: PPUSH
69067: CALL 16491 0 2
69071: PPUSH
69072: CALL_OW 1
69076: ST_TO_ADDR
// if not mc_scan [ i ] then
69077: LD_EXP 82
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: NOT
69088: IFFALSE 69266
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69090: LD_ADDR_VAR 0 4
69094: PUSH
69095: LD_EXP 59
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: PPUSH
69106: LD_INT 2
69108: PUSH
69109: LD_INT 25
69111: PUSH
69112: LD_INT 5
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 25
69121: PUSH
69122: LD_INT 8
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: PUSH
69129: LD_INT 25
69131: PUSH
69132: LD_INT 9
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: PPUSH
69145: CALL_OW 72
69149: ST_TO_ADDR
// if not tmp then
69150: LD_VAR 0 4
69154: NOT
69155: IFFALSE 69159
// continue ;
69157: GO 68978
// for j in tmp do
69159: LD_ADDR_VAR 0 3
69163: PUSH
69164: LD_VAR 0 4
69168: PUSH
69169: FOR_IN
69170: IFFALSE 69241
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69172: LD_VAR 0 3
69176: PPUSH
69177: CALL_OW 310
69181: PPUSH
69182: CALL_OW 266
69186: PUSH
69187: LD_INT 5
69189: EQUAL
69190: PUSH
69191: LD_VAR 0 3
69195: PPUSH
69196: CALL_OW 257
69200: PUSH
69201: LD_INT 1
69203: EQUAL
69204: AND
69205: PUSH
69206: LD_VAR 0 3
69210: PPUSH
69211: CALL_OW 459
69215: NOT
69216: AND
69217: PUSH
69218: LD_VAR 0 7
69222: AND
69223: IFFALSE 69239
// ComChangeProfession ( j , class ) ;
69225: LD_VAR 0 3
69229: PPUSH
69230: LD_VAR 0 7
69234: PPUSH
69235: CALL_OW 123
69239: GO 69169
69241: POP
69242: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69243: LD_ADDR_EXP 102
69247: PUSH
69248: LD_EXP 102
69252: PPUSH
69253: LD_VAR 0 2
69257: PPUSH
69258: LD_INT 0
69260: PPUSH
69261: CALL_OW 1
69265: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69266: LD_EXP 82
69270: PUSH
69271: LD_VAR 0 2
69275: ARRAY
69276: PUSH
69277: LD_EXP 102
69281: PUSH
69282: LD_VAR 0 2
69286: ARRAY
69287: NOT
69288: AND
69289: PUSH
69290: LD_EXP 81
69294: PUSH
69295: LD_VAR 0 2
69299: ARRAY
69300: NOT
69301: AND
69302: PUSH
69303: LD_EXP 59
69307: PUSH
69308: LD_VAR 0 2
69312: ARRAY
69313: PPUSH
69314: LD_INT 30
69316: PUSH
69317: LD_INT 32
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PPUSH
69324: CALL_OW 72
69328: NOT
69329: AND
69330: PUSH
69331: LD_EXP 59
69335: PUSH
69336: LD_VAR 0 2
69340: ARRAY
69341: PPUSH
69342: LD_INT 2
69344: PUSH
69345: LD_INT 30
69347: PUSH
69348: LD_INT 4
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 30
69357: PUSH
69358: LD_INT 5
69360: PUSH
69361: EMPTY
69362: LIST
69363: LIST
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: LIST
69369: PPUSH
69370: CALL_OW 72
69374: NOT
69375: AND
69376: IFFALSE 69531
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69378: LD_ADDR_VAR 0 4
69382: PUSH
69383: LD_EXP 59
69387: PUSH
69388: LD_VAR 0 2
69392: ARRAY
69393: PPUSH
69394: LD_INT 2
69396: PUSH
69397: LD_INT 25
69399: PUSH
69400: LD_INT 1
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 25
69409: PUSH
69410: LD_INT 5
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 25
69419: PUSH
69420: LD_INT 8
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 25
69429: PUSH
69430: LD_INT 9
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: PPUSH
69444: CALL_OW 72
69448: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69449: LD_ADDR_VAR 0 4
69453: PUSH
69454: LD_VAR 0 4
69458: PUSH
69459: LD_VAR 0 4
69463: PPUSH
69464: LD_INT 18
69466: PPUSH
69467: CALL 48996 0 2
69471: DIFF
69472: ST_TO_ADDR
// if tmp then
69473: LD_VAR 0 4
69477: IFFALSE 69531
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69479: LD_ADDR_EXP 102
69483: PUSH
69484: LD_EXP 102
69488: PPUSH
69489: LD_VAR 0 2
69493: PPUSH
69494: LD_INT 1
69496: PPUSH
69497: CALL_OW 1
69501: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
69502: LD_VAR 0 2
69506: PPUSH
69507: LD_VAR 0 4
69511: PPUSH
69512: LD_EXP 84
69516: PUSH
69517: LD_VAR 0 2
69521: ARRAY
69522: PPUSH
69523: CALL 105594 0 3
// exit ;
69527: POP
69528: POP
69529: GO 69662
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69531: LD_EXP 82
69535: PUSH
69536: LD_VAR 0 2
69540: ARRAY
69541: PUSH
69542: LD_EXP 102
69546: PUSH
69547: LD_VAR 0 2
69551: ARRAY
69552: NOT
69553: AND
69554: PUSH
69555: LD_EXP 81
69559: PUSH
69560: LD_VAR 0 2
69564: ARRAY
69565: AND
69566: IFFALSE 69658
// begin tmp := mc_defender [ i ] ;
69568: LD_ADDR_VAR 0 4
69572: PUSH
69573: LD_EXP 81
69577: PUSH
69578: LD_VAR 0 2
69582: ARRAY
69583: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69584: LD_ADDR_EXP 81
69588: PUSH
69589: LD_EXP 81
69593: PPUSH
69594: LD_VAR 0 2
69598: PPUSH
69599: EMPTY
69600: PPUSH
69601: CALL_OW 1
69605: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69606: LD_ADDR_EXP 102
69610: PUSH
69611: LD_EXP 102
69615: PPUSH
69616: LD_VAR 0 2
69620: PPUSH
69621: LD_INT 1
69623: PPUSH
69624: CALL_OW 1
69628: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
69629: LD_VAR 0 2
69633: PPUSH
69634: LD_VAR 0 4
69638: PPUSH
69639: LD_EXP 82
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: PPUSH
69650: CALL 106155 0 3
// exit ;
69654: POP
69655: POP
69656: GO 69662
// end ; end ;
69658: GO 68978
69660: POP
69661: POP
// end ;
69662: LD_VAR 0 1
69666: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69667: LD_INT 0
69669: PPUSH
69670: PPUSH
69671: PPUSH
69672: PPUSH
69673: PPUSH
69674: PPUSH
69675: PPUSH
69676: PPUSH
69677: PPUSH
69678: PPUSH
69679: PPUSH
// if not mc_bases then
69680: LD_EXP 59
69684: NOT
69685: IFFALSE 69689
// exit ;
69687: GO 70776
// for i = 1 to mc_bases do
69689: LD_ADDR_VAR 0 2
69693: PUSH
69694: DOUBLE
69695: LD_INT 1
69697: DEC
69698: ST_TO_ADDR
69699: LD_EXP 59
69703: PUSH
69704: FOR_TO
69705: IFFALSE 70774
// begin tmp := mc_lab [ i ] ;
69707: LD_ADDR_VAR 0 6
69711: PUSH
69712: LD_EXP 92
69716: PUSH
69717: LD_VAR 0 2
69721: ARRAY
69722: ST_TO_ADDR
// if not tmp then
69723: LD_VAR 0 6
69727: NOT
69728: IFFALSE 69732
// continue ;
69730: GO 69704
// idle_lab := 0 ;
69732: LD_ADDR_VAR 0 11
69736: PUSH
69737: LD_INT 0
69739: ST_TO_ADDR
// for j in tmp do
69740: LD_ADDR_VAR 0 3
69744: PUSH
69745: LD_VAR 0 6
69749: PUSH
69750: FOR_IN
69751: IFFALSE 70770
// begin researching := false ;
69753: LD_ADDR_VAR 0 10
69757: PUSH
69758: LD_INT 0
69760: ST_TO_ADDR
// side := GetSide ( j ) ;
69761: LD_ADDR_VAR 0 4
69765: PUSH
69766: LD_VAR 0 3
69770: PPUSH
69771: CALL_OW 255
69775: ST_TO_ADDR
// if not mc_tech [ side ] then
69776: LD_EXP 86
69780: PUSH
69781: LD_VAR 0 4
69785: ARRAY
69786: NOT
69787: IFFALSE 69791
// continue ;
69789: GO 69750
// if BuildingStatus ( j ) = bs_idle then
69791: LD_VAR 0 3
69795: PPUSH
69796: CALL_OW 461
69800: PUSH
69801: LD_INT 2
69803: EQUAL
69804: IFFALSE 69992
// begin if idle_lab and UnitsInside ( j ) < 6 then
69806: LD_VAR 0 11
69810: PUSH
69811: LD_VAR 0 3
69815: PPUSH
69816: CALL_OW 313
69820: PUSH
69821: LD_INT 6
69823: LESS
69824: AND
69825: IFFALSE 69896
// begin tmp2 := UnitsInside ( idle_lab ) ;
69827: LD_ADDR_VAR 0 9
69831: PUSH
69832: LD_VAR 0 11
69836: PPUSH
69837: CALL_OW 313
69841: ST_TO_ADDR
// if tmp2 then
69842: LD_VAR 0 9
69846: IFFALSE 69888
// for x in tmp2 do
69848: LD_ADDR_VAR 0 7
69852: PUSH
69853: LD_VAR 0 9
69857: PUSH
69858: FOR_IN
69859: IFFALSE 69886
// begin ComExitBuilding ( x ) ;
69861: LD_VAR 0 7
69865: PPUSH
69866: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69870: LD_VAR 0 7
69874: PPUSH
69875: LD_VAR 0 3
69879: PPUSH
69880: CALL_OW 180
// end ;
69884: GO 69858
69886: POP
69887: POP
// idle_lab := 0 ;
69888: LD_ADDR_VAR 0 11
69892: PUSH
69893: LD_INT 0
69895: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69896: LD_ADDR_VAR 0 5
69900: PUSH
69901: LD_EXP 86
69905: PUSH
69906: LD_VAR 0 4
69910: ARRAY
69911: PUSH
69912: FOR_IN
69913: IFFALSE 69973
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69915: LD_VAR 0 3
69919: PPUSH
69920: LD_VAR 0 5
69924: PPUSH
69925: CALL_OW 430
69929: PUSH
69930: LD_VAR 0 4
69934: PPUSH
69935: LD_VAR 0 5
69939: PPUSH
69940: CALL 15596 0 2
69944: AND
69945: IFFALSE 69971
// begin researching := true ;
69947: LD_ADDR_VAR 0 10
69951: PUSH
69952: LD_INT 1
69954: ST_TO_ADDR
// ComResearch ( j , t ) ;
69955: LD_VAR 0 3
69959: PPUSH
69960: LD_VAR 0 5
69964: PPUSH
69965: CALL_OW 124
// break ;
69969: GO 69973
// end ;
69971: GO 69912
69973: POP
69974: POP
// if not researching then
69975: LD_VAR 0 10
69979: NOT
69980: IFFALSE 69992
// idle_lab := j ;
69982: LD_ADDR_VAR 0 11
69986: PUSH
69987: LD_VAR 0 3
69991: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69992: LD_VAR 0 3
69996: PPUSH
69997: CALL_OW 461
70001: PUSH
70002: LD_INT 10
70004: EQUAL
70005: IFFALSE 70593
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70007: LD_EXP 88
70011: PUSH
70012: LD_VAR 0 2
70016: ARRAY
70017: NOT
70018: PUSH
70019: LD_EXP 89
70023: PUSH
70024: LD_VAR 0 2
70028: ARRAY
70029: NOT
70030: AND
70031: PUSH
70032: LD_EXP 86
70036: PUSH
70037: LD_VAR 0 4
70041: ARRAY
70042: PUSH
70043: LD_INT 1
70045: GREATER
70046: AND
70047: IFFALSE 70178
// begin ComCancel ( j ) ;
70049: LD_VAR 0 3
70053: PPUSH
70054: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70058: LD_ADDR_EXP 86
70062: PUSH
70063: LD_EXP 86
70067: PPUSH
70068: LD_VAR 0 4
70072: PPUSH
70073: LD_EXP 86
70077: PUSH
70078: LD_VAR 0 4
70082: ARRAY
70083: PPUSH
70084: LD_EXP 86
70088: PUSH
70089: LD_VAR 0 4
70093: ARRAY
70094: PUSH
70095: LD_INT 1
70097: MINUS
70098: PPUSH
70099: LD_EXP 86
70103: PUSH
70104: LD_VAR 0 4
70108: ARRAY
70109: PPUSH
70110: LD_INT 0
70112: PPUSH
70113: CALL 19144 0 4
70117: PPUSH
70118: CALL_OW 1
70122: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70123: LD_ADDR_EXP 86
70127: PUSH
70128: LD_EXP 86
70132: PPUSH
70133: LD_VAR 0 4
70137: PPUSH
70138: LD_EXP 86
70142: PUSH
70143: LD_VAR 0 4
70147: ARRAY
70148: PPUSH
70149: LD_EXP 86
70153: PUSH
70154: LD_VAR 0 4
70158: ARRAY
70159: PPUSH
70160: LD_INT 1
70162: PPUSH
70163: LD_INT 0
70165: PPUSH
70166: CALL 19144 0 4
70170: PPUSH
70171: CALL_OW 1
70175: ST_TO_ADDR
// continue ;
70176: GO 69750
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70178: LD_EXP 88
70182: PUSH
70183: LD_VAR 0 2
70187: ARRAY
70188: PUSH
70189: LD_EXP 89
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: NOT
70200: AND
70201: IFFALSE 70328
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70203: LD_ADDR_EXP 89
70207: PUSH
70208: LD_EXP 89
70212: PPUSH
70213: LD_VAR 0 2
70217: PUSH
70218: LD_EXP 89
70222: PUSH
70223: LD_VAR 0 2
70227: ARRAY
70228: PUSH
70229: LD_INT 1
70231: PLUS
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PPUSH
70237: LD_EXP 88
70241: PUSH
70242: LD_VAR 0 2
70246: ARRAY
70247: PUSH
70248: LD_INT 1
70250: ARRAY
70251: PPUSH
70252: CALL 19726 0 3
70256: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70257: LD_EXP 88
70261: PUSH
70262: LD_VAR 0 2
70266: ARRAY
70267: PUSH
70268: LD_INT 1
70270: ARRAY
70271: PPUSH
70272: LD_INT 112
70274: PPUSH
70275: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70279: LD_ADDR_VAR 0 9
70283: PUSH
70284: LD_EXP 88
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: PPUSH
70295: LD_INT 1
70297: PPUSH
70298: CALL_OW 3
70302: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70303: LD_ADDR_EXP 88
70307: PUSH
70308: LD_EXP 88
70312: PPUSH
70313: LD_VAR 0 2
70317: PPUSH
70318: LD_VAR 0 9
70322: PPUSH
70323: CALL_OW 1
70327: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70328: LD_EXP 88
70332: PUSH
70333: LD_VAR 0 2
70337: ARRAY
70338: PUSH
70339: LD_EXP 89
70343: PUSH
70344: LD_VAR 0 2
70348: ARRAY
70349: AND
70350: PUSH
70351: LD_EXP 89
70355: PUSH
70356: LD_VAR 0 2
70360: ARRAY
70361: PUSH
70362: LD_INT 1
70364: ARRAY
70365: PPUSH
70366: CALL_OW 310
70370: NOT
70371: AND
70372: PUSH
70373: LD_VAR 0 3
70377: PPUSH
70378: CALL_OW 313
70382: PUSH
70383: LD_INT 6
70385: EQUAL
70386: AND
70387: IFFALSE 70443
// begin tmp2 := UnitsInside ( j ) ;
70389: LD_ADDR_VAR 0 9
70393: PUSH
70394: LD_VAR 0 3
70398: PPUSH
70399: CALL_OW 313
70403: ST_TO_ADDR
// if tmp2 = 6 then
70404: LD_VAR 0 9
70408: PUSH
70409: LD_INT 6
70411: EQUAL
70412: IFFALSE 70443
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70414: LD_VAR 0 9
70418: PUSH
70419: LD_INT 1
70421: ARRAY
70422: PPUSH
70423: LD_INT 112
70425: PPUSH
70426: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70430: LD_VAR 0 9
70434: PUSH
70435: LD_INT 1
70437: ARRAY
70438: PPUSH
70439: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70443: LD_EXP 89
70447: PUSH
70448: LD_VAR 0 2
70452: ARRAY
70453: PUSH
70454: LD_EXP 89
70458: PUSH
70459: LD_VAR 0 2
70463: ARRAY
70464: PUSH
70465: LD_INT 1
70467: ARRAY
70468: PPUSH
70469: CALL_OW 314
70473: NOT
70474: AND
70475: PUSH
70476: LD_EXP 89
70480: PUSH
70481: LD_VAR 0 2
70485: ARRAY
70486: PUSH
70487: LD_INT 1
70489: ARRAY
70490: PPUSH
70491: CALL_OW 310
70495: NOT
70496: AND
70497: IFFALSE 70523
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70499: LD_EXP 89
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: PUSH
70510: LD_INT 1
70512: ARRAY
70513: PPUSH
70514: LD_VAR 0 3
70518: PPUSH
70519: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70523: LD_EXP 89
70527: PUSH
70528: LD_VAR 0 2
70532: ARRAY
70533: PUSH
70534: LD_INT 1
70536: ARRAY
70537: PPUSH
70538: CALL_OW 310
70542: PUSH
70543: LD_EXP 89
70547: PUSH
70548: LD_VAR 0 2
70552: ARRAY
70553: PUSH
70554: LD_INT 1
70556: ARRAY
70557: PPUSH
70558: CALL_OW 310
70562: PPUSH
70563: CALL_OW 461
70567: PUSH
70568: LD_INT 3
70570: NONEQUAL
70571: AND
70572: IFFALSE 70593
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70574: LD_EXP 89
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: PUSH
70585: LD_INT 1
70587: ARRAY
70588: PPUSH
70589: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70593: LD_VAR 0 3
70597: PPUSH
70598: CALL_OW 461
70602: PUSH
70603: LD_INT 6
70605: EQUAL
70606: PUSH
70607: LD_VAR 0 6
70611: PUSH
70612: LD_INT 1
70614: GREATER
70615: AND
70616: IFFALSE 70768
// begin sci := [ ] ;
70618: LD_ADDR_VAR 0 8
70622: PUSH
70623: EMPTY
70624: ST_TO_ADDR
// for x in ( tmp diff j ) do
70625: LD_ADDR_VAR 0 7
70629: PUSH
70630: LD_VAR 0 6
70634: PUSH
70635: LD_VAR 0 3
70639: DIFF
70640: PUSH
70641: FOR_IN
70642: IFFALSE 70694
// begin if sci = 6 then
70644: LD_VAR 0 8
70648: PUSH
70649: LD_INT 6
70651: EQUAL
70652: IFFALSE 70656
// break ;
70654: GO 70694
// if BuildingStatus ( x ) = bs_idle then
70656: LD_VAR 0 7
70660: PPUSH
70661: CALL_OW 461
70665: PUSH
70666: LD_INT 2
70668: EQUAL
70669: IFFALSE 70692
// sci := sci ^ UnitsInside ( x ) ;
70671: LD_ADDR_VAR 0 8
70675: PUSH
70676: LD_VAR 0 8
70680: PUSH
70681: LD_VAR 0 7
70685: PPUSH
70686: CALL_OW 313
70690: ADD
70691: ST_TO_ADDR
// end ;
70692: GO 70641
70694: POP
70695: POP
// if not sci then
70696: LD_VAR 0 8
70700: NOT
70701: IFFALSE 70705
// continue ;
70703: GO 69750
// for x in sci do
70705: LD_ADDR_VAR 0 7
70709: PUSH
70710: LD_VAR 0 8
70714: PUSH
70715: FOR_IN
70716: IFFALSE 70766
// if IsInUnit ( x ) and not HasTask ( x ) then
70718: LD_VAR 0 7
70722: PPUSH
70723: CALL_OW 310
70727: PUSH
70728: LD_VAR 0 7
70732: PPUSH
70733: CALL_OW 314
70737: NOT
70738: AND
70739: IFFALSE 70764
// begin ComExitBuilding ( x ) ;
70741: LD_VAR 0 7
70745: PPUSH
70746: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70750: LD_VAR 0 7
70754: PPUSH
70755: LD_VAR 0 3
70759: PPUSH
70760: CALL_OW 180
// end ;
70764: GO 70715
70766: POP
70767: POP
// end ; end ;
70768: GO 69750
70770: POP
70771: POP
// end ;
70772: GO 69704
70774: POP
70775: POP
// end ;
70776: LD_VAR 0 1
70780: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70781: LD_INT 0
70783: PPUSH
70784: PPUSH
// if not mc_bases then
70785: LD_EXP 59
70789: NOT
70790: IFFALSE 70794
// exit ;
70792: GO 70875
// for i = 1 to mc_bases do
70794: LD_ADDR_VAR 0 2
70798: PUSH
70799: DOUBLE
70800: LD_INT 1
70802: DEC
70803: ST_TO_ADDR
70804: LD_EXP 59
70808: PUSH
70809: FOR_TO
70810: IFFALSE 70873
// if mc_mines [ i ] and mc_miners [ i ] then
70812: LD_EXP 72
70816: PUSH
70817: LD_VAR 0 2
70821: ARRAY
70822: PUSH
70823: LD_EXP 73
70827: PUSH
70828: LD_VAR 0 2
70832: ARRAY
70833: AND
70834: IFFALSE 70871
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70836: LD_EXP 73
70840: PUSH
70841: LD_VAR 0 2
70845: ARRAY
70846: PUSH
70847: LD_INT 1
70849: ARRAY
70850: PPUSH
70851: CALL_OW 255
70855: PPUSH
70856: LD_EXP 72
70860: PUSH
70861: LD_VAR 0 2
70865: ARRAY
70866: PPUSH
70867: CALL 16679 0 2
70871: GO 70809
70873: POP
70874: POP
// end ;
70875: LD_VAR 0 1
70879: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70880: LD_INT 0
70882: PPUSH
70883: PPUSH
70884: PPUSH
70885: PPUSH
70886: PPUSH
70887: PPUSH
70888: PPUSH
70889: PPUSH
// if not mc_bases or not mc_parking then
70890: LD_EXP 59
70894: NOT
70895: PUSH
70896: LD_EXP 83
70900: NOT
70901: OR
70902: IFFALSE 70906
// exit ;
70904: GO 71605
// for i = 1 to mc_bases do
70906: LD_ADDR_VAR 0 2
70910: PUSH
70911: DOUBLE
70912: LD_INT 1
70914: DEC
70915: ST_TO_ADDR
70916: LD_EXP 59
70920: PUSH
70921: FOR_TO
70922: IFFALSE 71603
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70924: LD_EXP 59
70928: PUSH
70929: LD_VAR 0 2
70933: ARRAY
70934: NOT
70935: PUSH
70936: LD_EXP 83
70940: PUSH
70941: LD_VAR 0 2
70945: ARRAY
70946: NOT
70947: OR
70948: IFFALSE 70952
// continue ;
70950: GO 70921
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70952: LD_ADDR_VAR 0 5
70956: PUSH
70957: LD_EXP 59
70961: PUSH
70962: LD_VAR 0 2
70966: ARRAY
70967: PUSH
70968: LD_INT 1
70970: ARRAY
70971: PPUSH
70972: CALL_OW 255
70976: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70977: LD_ADDR_VAR 0 6
70981: PUSH
70982: LD_EXP 59
70986: PUSH
70987: LD_VAR 0 2
70991: ARRAY
70992: PPUSH
70993: LD_INT 30
70995: PUSH
70996: LD_INT 3
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PPUSH
71003: CALL_OW 72
71007: ST_TO_ADDR
// if not fac then
71008: LD_VAR 0 6
71012: NOT
71013: IFFALSE 71064
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71015: LD_ADDR_VAR 0 6
71019: PUSH
71020: LD_EXP 59
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: PPUSH
71031: LD_INT 2
71033: PUSH
71034: LD_INT 30
71036: PUSH
71037: LD_INT 0
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 30
71046: PUSH
71047: LD_INT 1
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: LIST
71058: PPUSH
71059: CALL_OW 72
71063: ST_TO_ADDR
// if not fac then
71064: LD_VAR 0 6
71068: NOT
71069: IFFALSE 71073
// continue ;
71071: GO 70921
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71073: LD_ADDR_VAR 0 7
71077: PUSH
71078: LD_EXP 83
71082: PUSH
71083: LD_VAR 0 2
71087: ARRAY
71088: PPUSH
71089: LD_INT 22
71091: PUSH
71092: LD_VAR 0 5
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PUSH
71101: LD_INT 21
71103: PUSH
71104: LD_INT 2
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 3
71113: PUSH
71114: LD_INT 24
71116: PUSH
71117: LD_INT 1000
71119: PUSH
71120: EMPTY
71121: LIST
71122: LIST
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: LIST
71132: PPUSH
71133: CALL_OW 70
71137: ST_TO_ADDR
// for j in fac do
71138: LD_ADDR_VAR 0 3
71142: PUSH
71143: LD_VAR 0 6
71147: PUSH
71148: FOR_IN
71149: IFFALSE 71230
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71151: LD_ADDR_VAR 0 7
71155: PUSH
71156: LD_VAR 0 7
71160: PUSH
71161: LD_INT 22
71163: PUSH
71164: LD_VAR 0 5
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: LD_INT 91
71175: PUSH
71176: LD_VAR 0 3
71180: PUSH
71181: LD_INT 15
71183: PUSH
71184: EMPTY
71185: LIST
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 21
71191: PUSH
71192: LD_INT 2
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 3
71201: PUSH
71202: LD_INT 24
71204: PUSH
71205: LD_INT 1000
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: LIST
71220: LIST
71221: PPUSH
71222: CALL_OW 69
71226: UNION
71227: ST_TO_ADDR
71228: GO 71148
71230: POP
71231: POP
// if not vehs then
71232: LD_VAR 0 7
71236: NOT
71237: IFFALSE 71263
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71239: LD_ADDR_EXP 71
71243: PUSH
71244: LD_EXP 71
71248: PPUSH
71249: LD_VAR 0 2
71253: PPUSH
71254: EMPTY
71255: PPUSH
71256: CALL_OW 1
71260: ST_TO_ADDR
// continue ;
71261: GO 70921
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71263: LD_ADDR_VAR 0 8
71267: PUSH
71268: LD_EXP 59
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PPUSH
71279: LD_INT 30
71281: PUSH
71282: LD_INT 3
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PPUSH
71289: CALL_OW 72
71293: ST_TO_ADDR
// if tmp then
71294: LD_VAR 0 8
71298: IFFALSE 71401
// begin for j in tmp do
71300: LD_ADDR_VAR 0 3
71304: PUSH
71305: LD_VAR 0 8
71309: PUSH
71310: FOR_IN
71311: IFFALSE 71399
// for k in UnitsInside ( j ) do
71313: LD_ADDR_VAR 0 4
71317: PUSH
71318: LD_VAR 0 3
71322: PPUSH
71323: CALL_OW 313
71327: PUSH
71328: FOR_IN
71329: IFFALSE 71395
// if k then
71331: LD_VAR 0 4
71335: IFFALSE 71393
// if not k in mc_repair_vehicle [ i ] then
71337: LD_VAR 0 4
71341: PUSH
71342: LD_EXP 71
71346: PUSH
71347: LD_VAR 0 2
71351: ARRAY
71352: IN
71353: NOT
71354: IFFALSE 71393
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71356: LD_ADDR_EXP 71
71360: PUSH
71361: LD_EXP 71
71365: PPUSH
71366: LD_VAR 0 2
71370: PPUSH
71371: LD_EXP 71
71375: PUSH
71376: LD_VAR 0 2
71380: ARRAY
71381: PUSH
71382: LD_VAR 0 4
71386: UNION
71387: PPUSH
71388: CALL_OW 1
71392: ST_TO_ADDR
71393: GO 71328
71395: POP
71396: POP
71397: GO 71310
71399: POP
71400: POP
// end ; if not mc_repair_vehicle [ i ] then
71401: LD_EXP 71
71405: PUSH
71406: LD_VAR 0 2
71410: ARRAY
71411: NOT
71412: IFFALSE 71416
// continue ;
71414: GO 70921
// for j in mc_repair_vehicle [ i ] do
71416: LD_ADDR_VAR 0 3
71420: PUSH
71421: LD_EXP 71
71425: PUSH
71426: LD_VAR 0 2
71430: ARRAY
71431: PUSH
71432: FOR_IN
71433: IFFALSE 71599
// begin if GetClass ( j ) <> 3 then
71435: LD_VAR 0 3
71439: PPUSH
71440: CALL_OW 257
71444: PUSH
71445: LD_INT 3
71447: NONEQUAL
71448: IFFALSE 71489
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71450: LD_ADDR_EXP 71
71454: PUSH
71455: LD_EXP 71
71459: PPUSH
71460: LD_VAR 0 2
71464: PPUSH
71465: LD_EXP 71
71469: PUSH
71470: LD_VAR 0 2
71474: ARRAY
71475: PUSH
71476: LD_VAR 0 3
71480: DIFF
71481: PPUSH
71482: CALL_OW 1
71486: ST_TO_ADDR
// continue ;
71487: GO 71432
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71489: LD_VAR 0 3
71493: PPUSH
71494: CALL_OW 311
71498: NOT
71499: PUSH
71500: LD_VAR 0 3
71504: PUSH
71505: LD_EXP 62
71509: PUSH
71510: LD_VAR 0 2
71514: ARRAY
71515: PUSH
71516: LD_INT 1
71518: ARRAY
71519: IN
71520: NOT
71521: AND
71522: PUSH
71523: LD_VAR 0 3
71527: PUSH
71528: LD_EXP 62
71532: PUSH
71533: LD_VAR 0 2
71537: ARRAY
71538: PUSH
71539: LD_INT 2
71541: ARRAY
71542: IN
71543: NOT
71544: AND
71545: IFFALSE 71597
// begin if IsInUnit ( j ) then
71547: LD_VAR 0 3
71551: PPUSH
71552: CALL_OW 310
71556: IFFALSE 71567
// ComExitBuilding ( j ) ;
71558: LD_VAR 0 3
71562: PPUSH
71563: CALL_OW 122
// if not HasTask ( j ) then
71567: LD_VAR 0 3
71571: PPUSH
71572: CALL_OW 314
71576: NOT
71577: IFFALSE 71597
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
71579: LD_VAR 0 3
71583: PPUSH
71584: LD_VAR 0 7
71588: PUSH
71589: LD_INT 1
71591: ARRAY
71592: PPUSH
71593: CALL_OW 189
// end ; end ;
71597: GO 71432
71599: POP
71600: POP
// end ;
71601: GO 70921
71603: POP
71604: POP
// end ;
71605: LD_VAR 0 1
71609: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71610: LD_INT 0
71612: PPUSH
71613: PPUSH
71614: PPUSH
71615: PPUSH
71616: PPUSH
71617: PPUSH
71618: PPUSH
71619: PPUSH
71620: PPUSH
71621: PPUSH
71622: PPUSH
// if not mc_bases then
71623: LD_EXP 59
71627: NOT
71628: IFFALSE 71632
// exit ;
71630: GO 72434
// for i = 1 to mc_bases do
71632: LD_ADDR_VAR 0 2
71636: PUSH
71637: DOUBLE
71638: LD_INT 1
71640: DEC
71641: ST_TO_ADDR
71642: LD_EXP 59
71646: PUSH
71647: FOR_TO
71648: IFFALSE 72432
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71650: LD_EXP 87
71654: PUSH
71655: LD_VAR 0 2
71659: ARRAY
71660: NOT
71661: PUSH
71662: LD_EXP 62
71666: PUSH
71667: LD_VAR 0 2
71671: ARRAY
71672: PUSH
71673: LD_INT 1
71675: ARRAY
71676: OR
71677: PUSH
71678: LD_EXP 62
71682: PUSH
71683: LD_VAR 0 2
71687: ARRAY
71688: PUSH
71689: LD_INT 2
71691: ARRAY
71692: OR
71693: PUSH
71694: LD_EXP 85
71698: PUSH
71699: LD_VAR 0 2
71703: ARRAY
71704: PPUSH
71705: LD_INT 1
71707: PPUSH
71708: CALL_OW 325
71712: NOT
71713: OR
71714: PUSH
71715: LD_EXP 82
71719: PUSH
71720: LD_VAR 0 2
71724: ARRAY
71725: OR
71726: IFFALSE 71730
// continue ;
71728: GO 71647
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71730: LD_ADDR_VAR 0 8
71734: PUSH
71735: LD_EXP 59
71739: PUSH
71740: LD_VAR 0 2
71744: ARRAY
71745: PPUSH
71746: LD_INT 25
71748: PUSH
71749: LD_INT 4
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 50
71758: PUSH
71759: EMPTY
71760: LIST
71761: PUSH
71762: LD_INT 3
71764: PUSH
71765: LD_INT 60
71767: PUSH
71768: EMPTY
71769: LIST
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: LIST
71779: PPUSH
71780: CALL_OW 72
71784: PUSH
71785: LD_EXP 63
71789: PUSH
71790: LD_VAR 0 2
71794: ARRAY
71795: DIFF
71796: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71797: LD_ADDR_VAR 0 9
71801: PUSH
71802: LD_EXP 59
71806: PUSH
71807: LD_VAR 0 2
71811: ARRAY
71812: PPUSH
71813: LD_INT 2
71815: PUSH
71816: LD_INT 30
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 30
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: LIST
71840: PPUSH
71841: CALL_OW 72
71845: ST_TO_ADDR
// if not tmp or not dep then
71846: LD_VAR 0 8
71850: NOT
71851: PUSH
71852: LD_VAR 0 9
71856: NOT
71857: OR
71858: IFFALSE 71862
// continue ;
71860: GO 71647
// side := GetSide ( tmp [ 1 ] ) ;
71862: LD_ADDR_VAR 0 11
71866: PUSH
71867: LD_VAR 0 8
71871: PUSH
71872: LD_INT 1
71874: ARRAY
71875: PPUSH
71876: CALL_OW 255
71880: ST_TO_ADDR
// dep := dep [ 1 ] ;
71881: LD_ADDR_VAR 0 9
71885: PUSH
71886: LD_VAR 0 9
71890: PUSH
71891: LD_INT 1
71893: ARRAY
71894: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71895: LD_ADDR_VAR 0 7
71899: PUSH
71900: LD_EXP 87
71904: PUSH
71905: LD_VAR 0 2
71909: ARRAY
71910: PPUSH
71911: LD_INT 22
71913: PUSH
71914: LD_INT 0
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: PUSH
71921: LD_INT 25
71923: PUSH
71924: LD_INT 12
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PPUSH
71935: CALL_OW 70
71939: PUSH
71940: LD_INT 22
71942: PUSH
71943: LD_INT 0
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: LD_INT 25
71952: PUSH
71953: LD_INT 12
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 91
71962: PUSH
71963: LD_VAR 0 9
71967: PUSH
71968: LD_INT 20
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: LIST
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: LIST
71980: PPUSH
71981: CALL_OW 69
71985: UNION
71986: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71987: LD_ADDR_VAR 0 10
71991: PUSH
71992: LD_EXP 87
71996: PUSH
71997: LD_VAR 0 2
72001: ARRAY
72002: PPUSH
72003: LD_INT 81
72005: PUSH
72006: LD_VAR 0 11
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PPUSH
72015: CALL_OW 70
72019: ST_TO_ADDR
// if not apes or danger_at_area then
72020: LD_VAR 0 7
72024: NOT
72025: PUSH
72026: LD_VAR 0 10
72030: OR
72031: IFFALSE 72081
// begin if mc_taming [ i ] then
72033: LD_EXP 90
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: IFFALSE 72079
// begin MC_Reset ( i , 121 ) ;
72045: LD_VAR 0 2
72049: PPUSH
72050: LD_INT 121
72052: PPUSH
72053: CALL 57368 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72057: LD_ADDR_EXP 90
72061: PUSH
72062: LD_EXP 90
72066: PPUSH
72067: LD_VAR 0 2
72071: PPUSH
72072: EMPTY
72073: PPUSH
72074: CALL_OW 1
72078: ST_TO_ADDR
// end ; continue ;
72079: GO 71647
// end ; for j in tmp do
72081: LD_ADDR_VAR 0 3
72085: PUSH
72086: LD_VAR 0 8
72090: PUSH
72091: FOR_IN
72092: IFFALSE 72428
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72094: LD_VAR 0 3
72098: PUSH
72099: LD_EXP 90
72103: PUSH
72104: LD_VAR 0 2
72108: ARRAY
72109: IN
72110: NOT
72111: PUSH
72112: LD_EXP 90
72116: PUSH
72117: LD_VAR 0 2
72121: ARRAY
72122: PUSH
72123: LD_INT 3
72125: LESS
72126: AND
72127: IFFALSE 72185
// begin SetTag ( j , 121 ) ;
72129: LD_VAR 0 3
72133: PPUSH
72134: LD_INT 121
72136: PPUSH
72137: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72141: LD_ADDR_EXP 90
72145: PUSH
72146: LD_EXP 90
72150: PPUSH
72151: LD_VAR 0 2
72155: PUSH
72156: LD_EXP 90
72160: PUSH
72161: LD_VAR 0 2
72165: ARRAY
72166: PUSH
72167: LD_INT 1
72169: PLUS
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PPUSH
72175: LD_VAR 0 3
72179: PPUSH
72180: CALL 19726 0 3
72184: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72185: LD_VAR 0 3
72189: PUSH
72190: LD_EXP 90
72194: PUSH
72195: LD_VAR 0 2
72199: ARRAY
72200: IN
72201: IFFALSE 72426
// begin if GetClass ( j ) <> 4 then
72203: LD_VAR 0 3
72207: PPUSH
72208: CALL_OW 257
72212: PUSH
72213: LD_INT 4
72215: NONEQUAL
72216: IFFALSE 72269
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72218: LD_ADDR_EXP 90
72222: PUSH
72223: LD_EXP 90
72227: PPUSH
72228: LD_VAR 0 2
72232: PPUSH
72233: LD_EXP 90
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: PUSH
72244: LD_VAR 0 3
72248: DIFF
72249: PPUSH
72250: CALL_OW 1
72254: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72255: LD_VAR 0 3
72259: PPUSH
72260: LD_INT 0
72262: PPUSH
72263: CALL_OW 109
// continue ;
72267: GO 72091
// end ; if IsInUnit ( j ) then
72269: LD_VAR 0 3
72273: PPUSH
72274: CALL_OW 310
72278: IFFALSE 72289
// ComExitBuilding ( j ) ;
72280: LD_VAR 0 3
72284: PPUSH
72285: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72289: LD_ADDR_VAR 0 6
72293: PUSH
72294: LD_VAR 0 7
72298: PPUSH
72299: LD_VAR 0 3
72303: PPUSH
72304: CALL_OW 74
72308: ST_TO_ADDR
// if not ape then
72309: LD_VAR 0 6
72313: NOT
72314: IFFALSE 72318
// break ;
72316: GO 72428
// x := GetX ( ape ) ;
72318: LD_ADDR_VAR 0 4
72322: PUSH
72323: LD_VAR 0 6
72327: PPUSH
72328: CALL_OW 250
72332: ST_TO_ADDR
// y := GetY ( ape ) ;
72333: LD_ADDR_VAR 0 5
72337: PUSH
72338: LD_VAR 0 6
72342: PPUSH
72343: CALL_OW 251
72347: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72348: LD_VAR 0 4
72352: PPUSH
72353: LD_VAR 0 5
72357: PPUSH
72358: CALL_OW 488
72362: NOT
72363: PUSH
72364: LD_VAR 0 11
72368: PPUSH
72369: LD_VAR 0 4
72373: PPUSH
72374: LD_VAR 0 5
72378: PPUSH
72379: LD_INT 20
72381: PPUSH
72382: CALL 20622 0 4
72386: PUSH
72387: LD_INT 4
72389: ARRAY
72390: OR
72391: IFFALSE 72395
// break ;
72393: GO 72428
// if not HasTask ( j ) then
72395: LD_VAR 0 3
72399: PPUSH
72400: CALL_OW 314
72404: NOT
72405: IFFALSE 72426
// ComTameXY ( j , x , y ) ;
72407: LD_VAR 0 3
72411: PPUSH
72412: LD_VAR 0 4
72416: PPUSH
72417: LD_VAR 0 5
72421: PPUSH
72422: CALL_OW 131
// end ; end ;
72426: GO 72091
72428: POP
72429: POP
// end ;
72430: GO 71647
72432: POP
72433: POP
// end ;
72434: LD_VAR 0 1
72438: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72439: LD_INT 0
72441: PPUSH
72442: PPUSH
72443: PPUSH
72444: PPUSH
72445: PPUSH
72446: PPUSH
72447: PPUSH
72448: PPUSH
// if not mc_bases then
72449: LD_EXP 59
72453: NOT
72454: IFFALSE 72458
// exit ;
72456: GO 73084
// for i = 1 to mc_bases do
72458: LD_ADDR_VAR 0 2
72462: PUSH
72463: DOUBLE
72464: LD_INT 1
72466: DEC
72467: ST_TO_ADDR
72468: LD_EXP 59
72472: PUSH
72473: FOR_TO
72474: IFFALSE 73082
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72476: LD_EXP 88
72480: PUSH
72481: LD_VAR 0 2
72485: ARRAY
72486: NOT
72487: PUSH
72488: LD_EXP 88
72492: PUSH
72493: LD_VAR 0 2
72497: ARRAY
72498: PPUSH
72499: LD_INT 25
72501: PUSH
72502: LD_INT 12
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PPUSH
72509: CALL_OW 72
72513: NOT
72514: OR
72515: IFFALSE 72519
// continue ;
72517: GO 72473
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72519: LD_ADDR_VAR 0 5
72523: PUSH
72524: LD_EXP 88
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: CALL_OW 255
72543: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72544: LD_VAR 0 5
72548: PPUSH
72549: LD_INT 2
72551: PPUSH
72552: CALL_OW 325
72556: IFFALSE 72809
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72558: LD_ADDR_VAR 0 4
72562: PUSH
72563: LD_EXP 88
72567: PUSH
72568: LD_VAR 0 2
72572: ARRAY
72573: PPUSH
72574: LD_INT 25
72576: PUSH
72577: LD_INT 16
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PPUSH
72584: CALL_OW 72
72588: ST_TO_ADDR
// if tmp < 6 then
72589: LD_VAR 0 4
72593: PUSH
72594: LD_INT 6
72596: LESS
72597: IFFALSE 72809
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72599: LD_ADDR_VAR 0 6
72603: PUSH
72604: LD_EXP 59
72608: PUSH
72609: LD_VAR 0 2
72613: ARRAY
72614: PPUSH
72615: LD_INT 2
72617: PUSH
72618: LD_INT 30
72620: PUSH
72621: LD_INT 0
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 30
72630: PUSH
72631: LD_INT 1
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: LIST
72642: PPUSH
72643: CALL_OW 72
72647: ST_TO_ADDR
// if depot then
72648: LD_VAR 0 6
72652: IFFALSE 72809
// begin selected := 0 ;
72654: LD_ADDR_VAR 0 7
72658: PUSH
72659: LD_INT 0
72661: ST_TO_ADDR
// for j in depot do
72662: LD_ADDR_VAR 0 3
72666: PUSH
72667: LD_VAR 0 6
72671: PUSH
72672: FOR_IN
72673: IFFALSE 72704
// begin if UnitsInside ( j ) < 6 then
72675: LD_VAR 0 3
72679: PPUSH
72680: CALL_OW 313
72684: PUSH
72685: LD_INT 6
72687: LESS
72688: IFFALSE 72702
// begin selected := j ;
72690: LD_ADDR_VAR 0 7
72694: PUSH
72695: LD_VAR 0 3
72699: ST_TO_ADDR
// break ;
72700: GO 72704
// end ; end ;
72702: GO 72672
72704: POP
72705: POP
// if selected then
72706: LD_VAR 0 7
72710: IFFALSE 72809
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72712: LD_ADDR_VAR 0 3
72716: PUSH
72717: LD_EXP 88
72721: PUSH
72722: LD_VAR 0 2
72726: ARRAY
72727: PPUSH
72728: LD_INT 25
72730: PUSH
72731: LD_INT 12
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PPUSH
72738: CALL_OW 72
72742: PUSH
72743: FOR_IN
72744: IFFALSE 72807
// if not HasTask ( j ) then
72746: LD_VAR 0 3
72750: PPUSH
72751: CALL_OW 314
72755: NOT
72756: IFFALSE 72805
// begin if not IsInUnit ( j ) then
72758: LD_VAR 0 3
72762: PPUSH
72763: CALL_OW 310
72767: NOT
72768: IFFALSE 72784
// ComEnterUnit ( j , selected ) ;
72770: LD_VAR 0 3
72774: PPUSH
72775: LD_VAR 0 7
72779: PPUSH
72780: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72784: LD_VAR 0 3
72788: PPUSH
72789: LD_INT 16
72791: PPUSH
72792: CALL_OW 183
// AddComExitBuilding ( j ) ;
72796: LD_VAR 0 3
72800: PPUSH
72801: CALL_OW 182
// end ;
72805: GO 72743
72807: POP
72808: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72809: LD_VAR 0 5
72813: PPUSH
72814: LD_INT 11
72816: PPUSH
72817: CALL_OW 325
72821: IFFALSE 73080
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72823: LD_ADDR_VAR 0 4
72827: PUSH
72828: LD_EXP 88
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: PPUSH
72839: LD_INT 25
72841: PUSH
72842: LD_INT 16
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PPUSH
72849: CALL_OW 72
72853: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72854: LD_VAR 0 4
72858: PUSH
72859: LD_INT 6
72861: GREATEREQUAL
72862: PUSH
72863: LD_VAR 0 5
72867: PPUSH
72868: LD_INT 2
72870: PPUSH
72871: CALL_OW 325
72875: NOT
72876: OR
72877: IFFALSE 73080
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72879: LD_ADDR_VAR 0 8
72883: PUSH
72884: LD_EXP 59
72888: PUSH
72889: LD_VAR 0 2
72893: ARRAY
72894: PPUSH
72895: LD_INT 2
72897: PUSH
72898: LD_INT 30
72900: PUSH
72901: LD_INT 4
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 30
72910: PUSH
72911: LD_INT 5
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: LIST
72922: PPUSH
72923: CALL_OW 72
72927: ST_TO_ADDR
// if barracks then
72928: LD_VAR 0 8
72932: IFFALSE 73080
// begin selected := 0 ;
72934: LD_ADDR_VAR 0 7
72938: PUSH
72939: LD_INT 0
72941: ST_TO_ADDR
// for j in barracks do
72942: LD_ADDR_VAR 0 3
72946: PUSH
72947: LD_VAR 0 8
72951: PUSH
72952: FOR_IN
72953: IFFALSE 72984
// begin if UnitsInside ( j ) < 6 then
72955: LD_VAR 0 3
72959: PPUSH
72960: CALL_OW 313
72964: PUSH
72965: LD_INT 6
72967: LESS
72968: IFFALSE 72982
// begin selected := j ;
72970: LD_ADDR_VAR 0 7
72974: PUSH
72975: LD_VAR 0 3
72979: ST_TO_ADDR
// break ;
72980: GO 72984
// end ; end ;
72982: GO 72952
72984: POP
72985: POP
// if selected then
72986: LD_VAR 0 7
72990: IFFALSE 73080
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72992: LD_ADDR_VAR 0 3
72996: PUSH
72997: LD_EXP 88
73001: PUSH
73002: LD_VAR 0 2
73006: ARRAY
73007: PPUSH
73008: LD_INT 25
73010: PUSH
73011: LD_INT 12
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PPUSH
73018: CALL_OW 72
73022: PUSH
73023: FOR_IN
73024: IFFALSE 73078
// if not IsInUnit ( j ) and not HasTask ( j ) then
73026: LD_VAR 0 3
73030: PPUSH
73031: CALL_OW 310
73035: NOT
73036: PUSH
73037: LD_VAR 0 3
73041: PPUSH
73042: CALL_OW 314
73046: NOT
73047: AND
73048: IFFALSE 73076
// begin ComEnterUnit ( j , selected ) ;
73050: LD_VAR 0 3
73054: PPUSH
73055: LD_VAR 0 7
73059: PPUSH
73060: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73064: LD_VAR 0 3
73068: PPUSH
73069: LD_INT 15
73071: PPUSH
73072: CALL_OW 183
// end ;
73076: GO 73023
73078: POP
73079: POP
// end ; end ; end ; end ; end ;
73080: GO 72473
73082: POP
73083: POP
// end ;
73084: LD_VAR 0 1
73088: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73089: LD_INT 0
73091: PPUSH
73092: PPUSH
73093: PPUSH
73094: PPUSH
// if not mc_bases then
73095: LD_EXP 59
73099: NOT
73100: IFFALSE 73104
// exit ;
73102: GO 73282
// for i = 1 to mc_bases do
73104: LD_ADDR_VAR 0 2
73108: PUSH
73109: DOUBLE
73110: LD_INT 1
73112: DEC
73113: ST_TO_ADDR
73114: LD_EXP 59
73118: PUSH
73119: FOR_TO
73120: IFFALSE 73280
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73122: LD_ADDR_VAR 0 4
73126: PUSH
73127: LD_EXP 59
73131: PUSH
73132: LD_VAR 0 2
73136: ARRAY
73137: PPUSH
73138: LD_INT 25
73140: PUSH
73141: LD_INT 9
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PPUSH
73148: CALL_OW 72
73152: ST_TO_ADDR
// if not tmp then
73153: LD_VAR 0 4
73157: NOT
73158: IFFALSE 73162
// continue ;
73160: GO 73119
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73162: LD_EXP 85
73166: PUSH
73167: LD_VAR 0 2
73171: ARRAY
73172: PPUSH
73173: LD_INT 29
73175: PPUSH
73176: CALL_OW 325
73180: NOT
73181: PUSH
73182: LD_EXP 85
73186: PUSH
73187: LD_VAR 0 2
73191: ARRAY
73192: PPUSH
73193: LD_INT 28
73195: PPUSH
73196: CALL_OW 325
73200: NOT
73201: AND
73202: IFFALSE 73206
// continue ;
73204: GO 73119
// for j in tmp do
73206: LD_ADDR_VAR 0 3
73210: PUSH
73211: LD_VAR 0 4
73215: PUSH
73216: FOR_IN
73217: IFFALSE 73276
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73219: LD_VAR 0 3
73223: PUSH
73224: LD_EXP 62
73228: PUSH
73229: LD_VAR 0 2
73233: ARRAY
73234: PUSH
73235: LD_INT 1
73237: ARRAY
73238: IN
73239: NOT
73240: PUSH
73241: LD_VAR 0 3
73245: PUSH
73246: LD_EXP 62
73250: PUSH
73251: LD_VAR 0 2
73255: ARRAY
73256: PUSH
73257: LD_INT 2
73259: ARRAY
73260: IN
73261: NOT
73262: AND
73263: IFFALSE 73274
// ComSpaceTimeShoot ( j ) ;
73265: LD_VAR 0 3
73269: PPUSH
73270: CALL 15687 0 1
73274: GO 73216
73276: POP
73277: POP
// end ;
73278: GO 73119
73280: POP
73281: POP
// end ;
73282: LD_VAR 0 1
73286: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73287: LD_INT 0
73289: PPUSH
73290: PPUSH
73291: PPUSH
73292: PPUSH
73293: PPUSH
73294: PPUSH
73295: PPUSH
73296: PPUSH
73297: PPUSH
// if not mc_bases then
73298: LD_EXP 59
73302: NOT
73303: IFFALSE 73307
// exit ;
73305: GO 73929
// for i = 1 to mc_bases do
73307: LD_ADDR_VAR 0 2
73311: PUSH
73312: DOUBLE
73313: LD_INT 1
73315: DEC
73316: ST_TO_ADDR
73317: LD_EXP 59
73321: PUSH
73322: FOR_TO
73323: IFFALSE 73927
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73325: LD_EXP 94
73329: PUSH
73330: LD_VAR 0 2
73334: ARRAY
73335: NOT
73336: PUSH
73337: LD_INT 38
73339: PPUSH
73340: LD_EXP 85
73344: PUSH
73345: LD_VAR 0 2
73349: ARRAY
73350: PPUSH
73351: CALL_OW 321
73355: PUSH
73356: LD_INT 2
73358: NONEQUAL
73359: OR
73360: IFFALSE 73364
// continue ;
73362: GO 73322
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73364: LD_ADDR_VAR 0 8
73368: PUSH
73369: LD_EXP 59
73373: PUSH
73374: LD_VAR 0 2
73378: ARRAY
73379: PPUSH
73380: LD_INT 30
73382: PUSH
73383: LD_INT 34
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PPUSH
73390: CALL_OW 72
73394: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73395: LD_ADDR_VAR 0 9
73399: PUSH
73400: LD_EXP 59
73404: PUSH
73405: LD_VAR 0 2
73409: ARRAY
73410: PPUSH
73411: LD_INT 25
73413: PUSH
73414: LD_INT 4
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PPUSH
73421: CALL_OW 72
73425: PPUSH
73426: LD_INT 0
73428: PPUSH
73429: CALL 48996 0 2
73433: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73434: LD_VAR 0 9
73438: NOT
73439: PUSH
73440: LD_VAR 0 8
73444: NOT
73445: OR
73446: PUSH
73447: LD_EXP 59
73451: PUSH
73452: LD_VAR 0 2
73456: ARRAY
73457: PPUSH
73458: LD_INT 124
73460: PPUSH
73461: CALL 48996 0 2
73465: OR
73466: IFFALSE 73470
// continue ;
73468: GO 73322
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73470: LD_EXP 95
73474: PUSH
73475: LD_VAR 0 2
73479: ARRAY
73480: PUSH
73481: LD_EXP 94
73485: PUSH
73486: LD_VAR 0 2
73490: ARRAY
73491: LESS
73492: PUSH
73493: LD_EXP 95
73497: PUSH
73498: LD_VAR 0 2
73502: ARRAY
73503: PUSH
73504: LD_VAR 0 8
73508: LESS
73509: AND
73510: IFFALSE 73925
// begin tmp := sci [ 1 ] ;
73512: LD_ADDR_VAR 0 7
73516: PUSH
73517: LD_VAR 0 9
73521: PUSH
73522: LD_INT 1
73524: ARRAY
73525: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73526: LD_VAR 0 7
73530: PPUSH
73531: LD_INT 124
73533: PPUSH
73534: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73538: LD_ADDR_VAR 0 3
73542: PUSH
73543: DOUBLE
73544: LD_EXP 94
73548: PUSH
73549: LD_VAR 0 2
73553: ARRAY
73554: INC
73555: ST_TO_ADDR
73556: LD_EXP 94
73560: PUSH
73561: LD_VAR 0 2
73565: ARRAY
73566: PUSH
73567: FOR_DOWNTO
73568: IFFALSE 73911
// begin if IsInUnit ( tmp ) then
73570: LD_VAR 0 7
73574: PPUSH
73575: CALL_OW 310
73579: IFFALSE 73590
// ComExitBuilding ( tmp ) ;
73581: LD_VAR 0 7
73585: PPUSH
73586: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73590: LD_INT 35
73592: PPUSH
73593: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73597: LD_VAR 0 7
73601: PPUSH
73602: CALL_OW 310
73606: NOT
73607: PUSH
73608: LD_VAR 0 7
73612: PPUSH
73613: CALL_OW 314
73617: NOT
73618: AND
73619: IFFALSE 73590
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73621: LD_ADDR_VAR 0 6
73625: PUSH
73626: LD_VAR 0 7
73630: PPUSH
73631: CALL_OW 250
73635: PUSH
73636: LD_VAR 0 7
73640: PPUSH
73641: CALL_OW 251
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73650: LD_INT 35
73652: PPUSH
73653: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73657: LD_ADDR_VAR 0 4
73661: PUSH
73662: LD_EXP 94
73666: PUSH
73667: LD_VAR 0 2
73671: ARRAY
73672: PUSH
73673: LD_VAR 0 3
73677: ARRAY
73678: PUSH
73679: LD_INT 1
73681: ARRAY
73682: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73683: LD_ADDR_VAR 0 5
73687: PUSH
73688: LD_EXP 94
73692: PUSH
73693: LD_VAR 0 2
73697: ARRAY
73698: PUSH
73699: LD_VAR 0 3
73703: ARRAY
73704: PUSH
73705: LD_INT 2
73707: ARRAY
73708: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73709: LD_VAR 0 7
73713: PPUSH
73714: LD_INT 10
73716: PPUSH
73717: CALL 22325 0 2
73721: PUSH
73722: LD_INT 4
73724: ARRAY
73725: IFFALSE 73763
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73727: LD_VAR 0 7
73731: PPUSH
73732: LD_VAR 0 6
73736: PUSH
73737: LD_INT 1
73739: ARRAY
73740: PPUSH
73741: LD_VAR 0 6
73745: PUSH
73746: LD_INT 2
73748: ARRAY
73749: PPUSH
73750: CALL_OW 111
// wait ( 0 0$10 ) ;
73754: LD_INT 350
73756: PPUSH
73757: CALL_OW 67
// end else
73761: GO 73789
// begin ComMoveXY ( tmp , x , y ) ;
73763: LD_VAR 0 7
73767: PPUSH
73768: LD_VAR 0 4
73772: PPUSH
73773: LD_VAR 0 5
73777: PPUSH
73778: CALL_OW 111
// wait ( 0 0$3 ) ;
73782: LD_INT 105
73784: PPUSH
73785: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73789: LD_VAR 0 7
73793: PPUSH
73794: LD_VAR 0 4
73798: PPUSH
73799: LD_VAR 0 5
73803: PPUSH
73804: CALL_OW 307
73808: IFFALSE 73650
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73810: LD_VAR 0 7
73814: PPUSH
73815: LD_VAR 0 4
73819: PPUSH
73820: LD_VAR 0 5
73824: PPUSH
73825: LD_VAR 0 8
73829: PUSH
73830: LD_VAR 0 3
73834: ARRAY
73835: PPUSH
73836: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73840: LD_INT 35
73842: PPUSH
73843: CALL_OW 67
// until not HasTask ( tmp ) ;
73847: LD_VAR 0 7
73851: PPUSH
73852: CALL_OW 314
73856: NOT
73857: IFFALSE 73840
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73859: LD_ADDR_EXP 95
73863: PUSH
73864: LD_EXP 95
73868: PPUSH
73869: LD_VAR 0 2
73873: PUSH
73874: LD_EXP 95
73878: PUSH
73879: LD_VAR 0 2
73883: ARRAY
73884: PUSH
73885: LD_INT 1
73887: PLUS
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PPUSH
73893: LD_VAR 0 8
73897: PUSH
73898: LD_VAR 0 3
73902: ARRAY
73903: PPUSH
73904: CALL 19726 0 3
73908: ST_TO_ADDR
// end ;
73909: GO 73567
73911: POP
73912: POP
// MC_Reset ( i , 124 ) ;
73913: LD_VAR 0 2
73917: PPUSH
73918: LD_INT 124
73920: PPUSH
73921: CALL 57368 0 2
// end ; end ;
73925: GO 73322
73927: POP
73928: POP
// end ;
73929: LD_VAR 0 1
73933: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73934: LD_INT 0
73936: PPUSH
73937: PPUSH
73938: PPUSH
// if not mc_bases then
73939: LD_EXP 59
73943: NOT
73944: IFFALSE 73948
// exit ;
73946: GO 74554
// for i = 1 to mc_bases do
73948: LD_ADDR_VAR 0 2
73952: PUSH
73953: DOUBLE
73954: LD_INT 1
73956: DEC
73957: ST_TO_ADDR
73958: LD_EXP 59
73962: PUSH
73963: FOR_TO
73964: IFFALSE 74552
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73966: LD_ADDR_VAR 0 3
73970: PUSH
73971: LD_EXP 59
73975: PUSH
73976: LD_VAR 0 2
73980: ARRAY
73981: PPUSH
73982: LD_INT 25
73984: PUSH
73985: LD_INT 4
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PPUSH
73992: CALL_OW 72
73996: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73997: LD_VAR 0 3
74001: NOT
74002: PUSH
74003: LD_EXP 96
74007: PUSH
74008: LD_VAR 0 2
74012: ARRAY
74013: NOT
74014: OR
74015: PUSH
74016: LD_EXP 59
74020: PUSH
74021: LD_VAR 0 2
74025: ARRAY
74026: PPUSH
74027: LD_INT 2
74029: PUSH
74030: LD_INT 30
74032: PUSH
74033: LD_INT 0
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 30
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: LIST
74054: PPUSH
74055: CALL_OW 72
74059: NOT
74060: OR
74061: IFFALSE 74111
// begin if mc_deposits_finder [ i ] then
74063: LD_EXP 97
74067: PUSH
74068: LD_VAR 0 2
74072: ARRAY
74073: IFFALSE 74109
// begin MC_Reset ( i , 125 ) ;
74075: LD_VAR 0 2
74079: PPUSH
74080: LD_INT 125
74082: PPUSH
74083: CALL 57368 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74087: LD_ADDR_EXP 97
74091: PUSH
74092: LD_EXP 97
74096: PPUSH
74097: LD_VAR 0 2
74101: PPUSH
74102: EMPTY
74103: PPUSH
74104: CALL_OW 1
74108: ST_TO_ADDR
// end ; continue ;
74109: GO 73963
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74111: LD_EXP 96
74115: PUSH
74116: LD_VAR 0 2
74120: ARRAY
74121: PUSH
74122: LD_INT 1
74124: ARRAY
74125: PUSH
74126: LD_INT 3
74128: ARRAY
74129: PUSH
74130: LD_INT 1
74132: EQUAL
74133: PUSH
74134: LD_INT 20
74136: PPUSH
74137: LD_EXP 85
74141: PUSH
74142: LD_VAR 0 2
74146: ARRAY
74147: PPUSH
74148: CALL_OW 321
74152: PUSH
74153: LD_INT 2
74155: NONEQUAL
74156: AND
74157: IFFALSE 74207
// begin if mc_deposits_finder [ i ] then
74159: LD_EXP 97
74163: PUSH
74164: LD_VAR 0 2
74168: ARRAY
74169: IFFALSE 74205
// begin MC_Reset ( i , 125 ) ;
74171: LD_VAR 0 2
74175: PPUSH
74176: LD_INT 125
74178: PPUSH
74179: CALL 57368 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74183: LD_ADDR_EXP 97
74187: PUSH
74188: LD_EXP 97
74192: PPUSH
74193: LD_VAR 0 2
74197: PPUSH
74198: EMPTY
74199: PPUSH
74200: CALL_OW 1
74204: ST_TO_ADDR
// end ; continue ;
74205: GO 73963
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74207: LD_EXP 96
74211: PUSH
74212: LD_VAR 0 2
74216: ARRAY
74217: PUSH
74218: LD_INT 1
74220: ARRAY
74221: PUSH
74222: LD_INT 1
74224: ARRAY
74225: PPUSH
74226: LD_EXP 96
74230: PUSH
74231: LD_VAR 0 2
74235: ARRAY
74236: PUSH
74237: LD_INT 1
74239: ARRAY
74240: PUSH
74241: LD_INT 2
74243: ARRAY
74244: PPUSH
74245: LD_EXP 85
74249: PUSH
74250: LD_VAR 0 2
74254: ARRAY
74255: PPUSH
74256: CALL_OW 440
74260: IFFALSE 74303
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74262: LD_ADDR_EXP 96
74266: PUSH
74267: LD_EXP 96
74271: PPUSH
74272: LD_VAR 0 2
74276: PPUSH
74277: LD_EXP 96
74281: PUSH
74282: LD_VAR 0 2
74286: ARRAY
74287: PPUSH
74288: LD_INT 1
74290: PPUSH
74291: CALL_OW 3
74295: PPUSH
74296: CALL_OW 1
74300: ST_TO_ADDR
74301: GO 74550
// begin if not mc_deposits_finder [ i ] then
74303: LD_EXP 97
74307: PUSH
74308: LD_VAR 0 2
74312: ARRAY
74313: NOT
74314: IFFALSE 74366
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74316: LD_ADDR_EXP 97
74320: PUSH
74321: LD_EXP 97
74325: PPUSH
74326: LD_VAR 0 2
74330: PPUSH
74331: LD_VAR 0 3
74335: PUSH
74336: LD_INT 1
74338: ARRAY
74339: PUSH
74340: EMPTY
74341: LIST
74342: PPUSH
74343: CALL_OW 1
74347: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74348: LD_VAR 0 3
74352: PUSH
74353: LD_INT 1
74355: ARRAY
74356: PPUSH
74357: LD_INT 125
74359: PPUSH
74360: CALL_OW 109
// end else
74364: GO 74550
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74366: LD_EXP 97
74370: PUSH
74371: LD_VAR 0 2
74375: ARRAY
74376: PUSH
74377: LD_INT 1
74379: ARRAY
74380: PPUSH
74381: CALL_OW 310
74385: IFFALSE 74408
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74387: LD_EXP 97
74391: PUSH
74392: LD_VAR 0 2
74396: ARRAY
74397: PUSH
74398: LD_INT 1
74400: ARRAY
74401: PPUSH
74402: CALL_OW 122
74406: GO 74550
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74408: LD_EXP 97
74412: PUSH
74413: LD_VAR 0 2
74417: ARRAY
74418: PUSH
74419: LD_INT 1
74421: ARRAY
74422: PPUSH
74423: CALL_OW 314
74427: NOT
74428: PUSH
74429: LD_EXP 97
74433: PUSH
74434: LD_VAR 0 2
74438: ARRAY
74439: PUSH
74440: LD_INT 1
74442: ARRAY
74443: PPUSH
74444: LD_EXP 96
74448: PUSH
74449: LD_VAR 0 2
74453: ARRAY
74454: PUSH
74455: LD_INT 1
74457: ARRAY
74458: PUSH
74459: LD_INT 1
74461: ARRAY
74462: PPUSH
74463: LD_EXP 96
74467: PUSH
74468: LD_VAR 0 2
74472: ARRAY
74473: PUSH
74474: LD_INT 1
74476: ARRAY
74477: PUSH
74478: LD_INT 2
74480: ARRAY
74481: PPUSH
74482: CALL_OW 297
74486: PUSH
74487: LD_INT 6
74489: GREATER
74490: AND
74491: IFFALSE 74550
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74493: LD_EXP 97
74497: PUSH
74498: LD_VAR 0 2
74502: ARRAY
74503: PUSH
74504: LD_INT 1
74506: ARRAY
74507: PPUSH
74508: LD_EXP 96
74512: PUSH
74513: LD_VAR 0 2
74517: ARRAY
74518: PUSH
74519: LD_INT 1
74521: ARRAY
74522: PUSH
74523: LD_INT 1
74525: ARRAY
74526: PPUSH
74527: LD_EXP 96
74531: PUSH
74532: LD_VAR 0 2
74536: ARRAY
74537: PUSH
74538: LD_INT 1
74540: ARRAY
74541: PUSH
74542: LD_INT 2
74544: ARRAY
74545: PPUSH
74546: CALL_OW 111
// end ; end ; end ;
74550: GO 73963
74552: POP
74553: POP
// end ;
74554: LD_VAR 0 1
74558: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74559: LD_INT 0
74561: PPUSH
74562: PPUSH
74563: PPUSH
74564: PPUSH
74565: PPUSH
74566: PPUSH
74567: PPUSH
74568: PPUSH
74569: PPUSH
74570: PPUSH
74571: PPUSH
// if not mc_bases then
74572: LD_EXP 59
74576: NOT
74577: IFFALSE 74581
// exit ;
74579: GO 75521
// for i = 1 to mc_bases do
74581: LD_ADDR_VAR 0 2
74585: PUSH
74586: DOUBLE
74587: LD_INT 1
74589: DEC
74590: ST_TO_ADDR
74591: LD_EXP 59
74595: PUSH
74596: FOR_TO
74597: IFFALSE 75519
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74599: LD_EXP 59
74603: PUSH
74604: LD_VAR 0 2
74608: ARRAY
74609: NOT
74610: PUSH
74611: LD_EXP 82
74615: PUSH
74616: LD_VAR 0 2
74620: ARRAY
74621: OR
74622: IFFALSE 74626
// continue ;
74624: GO 74596
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74626: LD_ADDR_VAR 0 7
74630: PUSH
74631: LD_EXP 59
74635: PUSH
74636: LD_VAR 0 2
74640: ARRAY
74641: PUSH
74642: LD_INT 1
74644: ARRAY
74645: PPUSH
74646: CALL_OW 248
74650: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74651: LD_VAR 0 7
74655: PUSH
74656: LD_INT 3
74658: EQUAL
74659: PUSH
74660: LD_EXP 78
74664: PUSH
74665: LD_VAR 0 2
74669: ARRAY
74670: PUSH
74671: LD_EXP 81
74675: PUSH
74676: LD_VAR 0 2
74680: ARRAY
74681: UNION
74682: PPUSH
74683: LD_INT 33
74685: PUSH
74686: LD_INT 2
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PPUSH
74693: CALL_OW 72
74697: NOT
74698: OR
74699: IFFALSE 74703
// continue ;
74701: GO 74596
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74703: LD_ADDR_VAR 0 9
74707: PUSH
74708: LD_EXP 59
74712: PUSH
74713: LD_VAR 0 2
74717: ARRAY
74718: PPUSH
74719: LD_INT 30
74721: PUSH
74722: LD_INT 36
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PPUSH
74729: CALL_OW 72
74733: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74734: LD_ADDR_VAR 0 10
74738: PUSH
74739: LD_EXP 78
74743: PUSH
74744: LD_VAR 0 2
74748: ARRAY
74749: PPUSH
74750: LD_INT 34
74752: PUSH
74753: LD_INT 31
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PPUSH
74760: CALL_OW 72
74764: ST_TO_ADDR
// if not cts and not mcts then
74765: LD_VAR 0 9
74769: NOT
74770: PUSH
74771: LD_VAR 0 10
74775: NOT
74776: AND
74777: IFFALSE 74781
// continue ;
74779: GO 74596
// x := cts ;
74781: LD_ADDR_VAR 0 11
74785: PUSH
74786: LD_VAR 0 9
74790: ST_TO_ADDR
// if not x then
74791: LD_VAR 0 11
74795: NOT
74796: IFFALSE 74808
// x := mcts ;
74798: LD_ADDR_VAR 0 11
74802: PUSH
74803: LD_VAR 0 10
74807: ST_TO_ADDR
// if not x then
74808: LD_VAR 0 11
74812: NOT
74813: IFFALSE 74817
// continue ;
74815: GO 74596
// if mc_remote_driver [ i ] then
74817: LD_EXP 99
74821: PUSH
74822: LD_VAR 0 2
74826: ARRAY
74827: IFFALSE 75214
// for j in mc_remote_driver [ i ] do
74829: LD_ADDR_VAR 0 3
74833: PUSH
74834: LD_EXP 99
74838: PUSH
74839: LD_VAR 0 2
74843: ARRAY
74844: PUSH
74845: FOR_IN
74846: IFFALSE 75212
// begin if GetClass ( j ) <> 3 then
74848: LD_VAR 0 3
74852: PPUSH
74853: CALL_OW 257
74857: PUSH
74858: LD_INT 3
74860: NONEQUAL
74861: IFFALSE 74914
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74863: LD_ADDR_EXP 99
74867: PUSH
74868: LD_EXP 99
74872: PPUSH
74873: LD_VAR 0 2
74877: PPUSH
74878: LD_EXP 99
74882: PUSH
74883: LD_VAR 0 2
74887: ARRAY
74888: PUSH
74889: LD_VAR 0 3
74893: DIFF
74894: PPUSH
74895: CALL_OW 1
74899: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74900: LD_VAR 0 3
74904: PPUSH
74905: LD_INT 0
74907: PPUSH
74908: CALL_OW 109
// continue ;
74912: GO 74845
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74914: LD_EXP 78
74918: PUSH
74919: LD_VAR 0 2
74923: ARRAY
74924: PPUSH
74925: LD_INT 34
74927: PUSH
74928: LD_INT 31
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: LD_INT 58
74937: PUSH
74938: EMPTY
74939: LIST
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PPUSH
74945: CALL_OW 72
74949: PUSH
74950: LD_VAR 0 3
74954: PPUSH
74955: CALL 49084 0 1
74959: NOT
74960: AND
74961: IFFALSE 75032
// begin if IsInUnit ( j ) then
74963: LD_VAR 0 3
74967: PPUSH
74968: CALL_OW 310
74972: IFFALSE 74983
// ComExitBuilding ( j ) ;
74974: LD_VAR 0 3
74978: PPUSH
74979: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74983: LD_VAR 0 3
74987: PPUSH
74988: LD_EXP 78
74992: PUSH
74993: LD_VAR 0 2
74997: ARRAY
74998: PPUSH
74999: LD_INT 34
75001: PUSH
75002: LD_INT 31
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 58
75011: PUSH
75012: EMPTY
75013: LIST
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PPUSH
75019: CALL_OW 72
75023: PUSH
75024: LD_INT 1
75026: ARRAY
75027: PPUSH
75028: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75032: LD_VAR 0 3
75036: PPUSH
75037: CALL_OW 310
75041: NOT
75042: PUSH
75043: LD_VAR 0 3
75047: PPUSH
75048: CALL_OW 310
75052: PPUSH
75053: CALL_OW 266
75057: PUSH
75058: LD_INT 36
75060: NONEQUAL
75061: PUSH
75062: LD_VAR 0 3
75066: PPUSH
75067: CALL 49084 0 1
75071: NOT
75072: AND
75073: OR
75074: IFFALSE 75210
// begin if IsInUnit ( j ) then
75076: LD_VAR 0 3
75080: PPUSH
75081: CALL_OW 310
75085: IFFALSE 75096
// ComExitBuilding ( j ) ;
75087: LD_VAR 0 3
75091: PPUSH
75092: CALL_OW 122
// ct := 0 ;
75096: LD_ADDR_VAR 0 8
75100: PUSH
75101: LD_INT 0
75103: ST_TO_ADDR
// for k in x do
75104: LD_ADDR_VAR 0 4
75108: PUSH
75109: LD_VAR 0 11
75113: PUSH
75114: FOR_IN
75115: IFFALSE 75188
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75117: LD_VAR 0 4
75121: PPUSH
75122: CALL_OW 264
75126: PUSH
75127: LD_INT 31
75129: EQUAL
75130: PUSH
75131: LD_VAR 0 4
75135: PPUSH
75136: CALL_OW 311
75140: NOT
75141: AND
75142: PUSH
75143: LD_VAR 0 4
75147: PPUSH
75148: CALL_OW 266
75152: PUSH
75153: LD_INT 36
75155: EQUAL
75156: PUSH
75157: LD_VAR 0 4
75161: PPUSH
75162: CALL_OW 313
75166: PUSH
75167: LD_INT 3
75169: LESS
75170: AND
75171: OR
75172: IFFALSE 75186
// begin ct := k ;
75174: LD_ADDR_VAR 0 8
75178: PUSH
75179: LD_VAR 0 4
75183: ST_TO_ADDR
// break ;
75184: GO 75188
// end ;
75186: GO 75114
75188: POP
75189: POP
// if ct then
75190: LD_VAR 0 8
75194: IFFALSE 75210
// ComEnterUnit ( j , ct ) ;
75196: LD_VAR 0 3
75200: PPUSH
75201: LD_VAR 0 8
75205: PPUSH
75206: CALL_OW 120
// end ; end ;
75210: GO 74845
75212: POP
75213: POP
// places := 0 ;
75214: LD_ADDR_VAR 0 5
75218: PUSH
75219: LD_INT 0
75221: ST_TO_ADDR
// for j = 1 to x do
75222: LD_ADDR_VAR 0 3
75226: PUSH
75227: DOUBLE
75228: LD_INT 1
75230: DEC
75231: ST_TO_ADDR
75232: LD_VAR 0 11
75236: PUSH
75237: FOR_TO
75238: IFFALSE 75314
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75240: LD_VAR 0 11
75244: PUSH
75245: LD_VAR 0 3
75249: ARRAY
75250: PPUSH
75251: CALL_OW 264
75255: PUSH
75256: LD_INT 31
75258: EQUAL
75259: IFFALSE 75277
// places := places + 1 else
75261: LD_ADDR_VAR 0 5
75265: PUSH
75266: LD_VAR 0 5
75270: PUSH
75271: LD_INT 1
75273: PLUS
75274: ST_TO_ADDR
75275: GO 75312
// if GetBType ( x [ j ] ) = b_control_tower then
75277: LD_VAR 0 11
75281: PUSH
75282: LD_VAR 0 3
75286: ARRAY
75287: PPUSH
75288: CALL_OW 266
75292: PUSH
75293: LD_INT 36
75295: EQUAL
75296: IFFALSE 75312
// places := places + 3 ;
75298: LD_ADDR_VAR 0 5
75302: PUSH
75303: LD_VAR 0 5
75307: PUSH
75308: LD_INT 3
75310: PLUS
75311: ST_TO_ADDR
75312: GO 75237
75314: POP
75315: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75316: LD_VAR 0 5
75320: PUSH
75321: LD_INT 0
75323: EQUAL
75324: PUSH
75325: LD_VAR 0 5
75329: PUSH
75330: LD_EXP 99
75334: PUSH
75335: LD_VAR 0 2
75339: ARRAY
75340: LESSEQUAL
75341: OR
75342: IFFALSE 75346
// continue ;
75344: GO 74596
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75346: LD_ADDR_VAR 0 6
75350: PUSH
75351: LD_EXP 59
75355: PUSH
75356: LD_VAR 0 2
75360: ARRAY
75361: PPUSH
75362: LD_INT 25
75364: PUSH
75365: LD_INT 3
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PPUSH
75372: CALL_OW 72
75376: PUSH
75377: LD_EXP 99
75381: PUSH
75382: LD_VAR 0 2
75386: ARRAY
75387: DIFF
75388: PPUSH
75389: LD_INT 3
75391: PPUSH
75392: CALL 49984 0 2
75396: ST_TO_ADDR
// for j in tmp do
75397: LD_ADDR_VAR 0 3
75401: PUSH
75402: LD_VAR 0 6
75406: PUSH
75407: FOR_IN
75408: IFFALSE 75443
// if GetTag ( j ) > 0 then
75410: LD_VAR 0 3
75414: PPUSH
75415: CALL_OW 110
75419: PUSH
75420: LD_INT 0
75422: GREATER
75423: IFFALSE 75441
// tmp := tmp diff j ;
75425: LD_ADDR_VAR 0 6
75429: PUSH
75430: LD_VAR 0 6
75434: PUSH
75435: LD_VAR 0 3
75439: DIFF
75440: ST_TO_ADDR
75441: GO 75407
75443: POP
75444: POP
// if not tmp then
75445: LD_VAR 0 6
75449: NOT
75450: IFFALSE 75454
// continue ;
75452: GO 74596
// if places then
75454: LD_VAR 0 5
75458: IFFALSE 75517
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75460: LD_ADDR_EXP 99
75464: PUSH
75465: LD_EXP 99
75469: PPUSH
75470: LD_VAR 0 2
75474: PPUSH
75475: LD_EXP 99
75479: PUSH
75480: LD_VAR 0 2
75484: ARRAY
75485: PUSH
75486: LD_VAR 0 6
75490: PUSH
75491: LD_INT 1
75493: ARRAY
75494: UNION
75495: PPUSH
75496: CALL_OW 1
75500: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75501: LD_VAR 0 6
75505: PUSH
75506: LD_INT 1
75508: ARRAY
75509: PPUSH
75510: LD_INT 126
75512: PPUSH
75513: CALL_OW 109
// end ; end ;
75517: GO 74596
75519: POP
75520: POP
// end ;
75521: LD_VAR 0 1
75525: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75526: LD_INT 0
75528: PPUSH
75529: PPUSH
75530: PPUSH
75531: PPUSH
75532: PPUSH
75533: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75534: LD_VAR 0 1
75538: NOT
75539: PUSH
75540: LD_VAR 0 2
75544: NOT
75545: OR
75546: PUSH
75547: LD_VAR 0 3
75551: NOT
75552: OR
75553: PUSH
75554: LD_VAR 0 4
75558: PUSH
75559: LD_INT 1
75561: PUSH
75562: LD_INT 2
75564: PUSH
75565: LD_INT 3
75567: PUSH
75568: LD_INT 4
75570: PUSH
75571: LD_INT 5
75573: PUSH
75574: LD_INT 8
75576: PUSH
75577: LD_INT 9
75579: PUSH
75580: LD_INT 15
75582: PUSH
75583: LD_INT 16
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: LIST
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: IN
75597: NOT
75598: OR
75599: IFFALSE 75603
// exit ;
75601: GO 76503
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75603: LD_ADDR_VAR 0 2
75607: PUSH
75608: LD_VAR 0 2
75612: PPUSH
75613: LD_INT 21
75615: PUSH
75616: LD_INT 3
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 24
75625: PUSH
75626: LD_INT 250
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PPUSH
75637: CALL_OW 72
75641: ST_TO_ADDR
// case class of 1 , 15 :
75642: LD_VAR 0 4
75646: PUSH
75647: LD_INT 1
75649: DOUBLE
75650: EQUAL
75651: IFTRUE 75661
75653: LD_INT 15
75655: DOUBLE
75656: EQUAL
75657: IFTRUE 75661
75659: GO 75746
75661: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75662: LD_ADDR_VAR 0 8
75666: PUSH
75667: LD_VAR 0 2
75671: PPUSH
75672: LD_INT 2
75674: PUSH
75675: LD_INT 30
75677: PUSH
75678: LD_INT 32
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 30
75687: PUSH
75688: LD_INT 31
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: LIST
75699: PPUSH
75700: CALL_OW 72
75704: PUSH
75705: LD_VAR 0 2
75709: PPUSH
75710: LD_INT 2
75712: PUSH
75713: LD_INT 30
75715: PUSH
75716: LD_INT 4
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 30
75725: PUSH
75726: LD_INT 5
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: LIST
75737: PPUSH
75738: CALL_OW 72
75742: ADD
75743: ST_TO_ADDR
75744: GO 75992
75746: LD_INT 2
75748: DOUBLE
75749: EQUAL
75750: IFTRUE 75760
75752: LD_INT 16
75754: DOUBLE
75755: EQUAL
75756: IFTRUE 75760
75758: GO 75806
75760: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75761: LD_ADDR_VAR 0 8
75765: PUSH
75766: LD_VAR 0 2
75770: PPUSH
75771: LD_INT 2
75773: PUSH
75774: LD_INT 30
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 30
75786: PUSH
75787: LD_INT 1
75789: PUSH
75790: EMPTY
75791: LIST
75792: LIST
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: LIST
75798: PPUSH
75799: CALL_OW 72
75803: ST_TO_ADDR
75804: GO 75992
75806: LD_INT 3
75808: DOUBLE
75809: EQUAL
75810: IFTRUE 75814
75812: GO 75860
75814: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75815: LD_ADDR_VAR 0 8
75819: PUSH
75820: LD_VAR 0 2
75824: PPUSH
75825: LD_INT 2
75827: PUSH
75828: LD_INT 30
75830: PUSH
75831: LD_INT 2
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 30
75840: PUSH
75841: LD_INT 3
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: LIST
75852: PPUSH
75853: CALL_OW 72
75857: ST_TO_ADDR
75858: GO 75992
75860: LD_INT 4
75862: DOUBLE
75863: EQUAL
75864: IFTRUE 75868
75866: GO 75925
75868: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75869: LD_ADDR_VAR 0 8
75873: PUSH
75874: LD_VAR 0 2
75878: PPUSH
75879: LD_INT 2
75881: PUSH
75882: LD_INT 30
75884: PUSH
75885: LD_INT 6
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 30
75894: PUSH
75895: LD_INT 7
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 30
75904: PUSH
75905: LD_INT 8
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: PPUSH
75918: CALL_OW 72
75922: ST_TO_ADDR
75923: GO 75992
75925: LD_INT 5
75927: DOUBLE
75928: EQUAL
75929: IFTRUE 75945
75931: LD_INT 8
75933: DOUBLE
75934: EQUAL
75935: IFTRUE 75945
75937: LD_INT 9
75939: DOUBLE
75940: EQUAL
75941: IFTRUE 75945
75943: GO 75991
75945: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75946: LD_ADDR_VAR 0 8
75950: PUSH
75951: LD_VAR 0 2
75955: PPUSH
75956: LD_INT 2
75958: PUSH
75959: LD_INT 30
75961: PUSH
75962: LD_INT 4
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 30
75971: PUSH
75972: LD_INT 5
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: LIST
75983: PPUSH
75984: CALL_OW 72
75988: ST_TO_ADDR
75989: GO 75992
75991: POP
// if not tmp then
75992: LD_VAR 0 8
75996: NOT
75997: IFFALSE 76001
// exit ;
75999: GO 76503
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76001: LD_VAR 0 4
76005: PUSH
76006: LD_INT 1
76008: PUSH
76009: LD_INT 15
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: IN
76016: PUSH
76017: LD_EXP 68
76021: PUSH
76022: LD_VAR 0 1
76026: ARRAY
76027: AND
76028: IFFALSE 76184
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76030: LD_ADDR_VAR 0 9
76034: PUSH
76035: LD_EXP 68
76039: PUSH
76040: LD_VAR 0 1
76044: ARRAY
76045: PUSH
76046: LD_INT 1
76048: ARRAY
76049: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76050: LD_VAR 0 9
76054: PUSH
76055: LD_EXP 69
76059: PUSH
76060: LD_VAR 0 1
76064: ARRAY
76065: IN
76066: NOT
76067: IFFALSE 76182
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76069: LD_ADDR_EXP 69
76073: PUSH
76074: LD_EXP 69
76078: PPUSH
76079: LD_VAR 0 1
76083: PUSH
76084: LD_EXP 69
76088: PUSH
76089: LD_VAR 0 1
76093: ARRAY
76094: PUSH
76095: LD_INT 1
76097: PLUS
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PPUSH
76103: LD_VAR 0 9
76107: PPUSH
76108: CALL 19726 0 3
76112: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76113: LD_ADDR_EXP 68
76117: PUSH
76118: LD_EXP 68
76122: PPUSH
76123: LD_VAR 0 1
76127: PPUSH
76128: LD_EXP 68
76132: PUSH
76133: LD_VAR 0 1
76137: ARRAY
76138: PUSH
76139: LD_VAR 0 9
76143: DIFF
76144: PPUSH
76145: CALL_OW 1
76149: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76150: LD_VAR 0 3
76154: PPUSH
76155: LD_EXP 69
76159: PUSH
76160: LD_VAR 0 1
76164: ARRAY
76165: PUSH
76166: LD_EXP 69
76170: PUSH
76171: LD_VAR 0 1
76175: ARRAY
76176: ARRAY
76177: PPUSH
76178: CALL_OW 120
// end ; exit ;
76182: GO 76503
// end ; if tmp > 1 then
76184: LD_VAR 0 8
76188: PUSH
76189: LD_INT 1
76191: GREATER
76192: IFFALSE 76296
// for i = 2 to tmp do
76194: LD_ADDR_VAR 0 6
76198: PUSH
76199: DOUBLE
76200: LD_INT 2
76202: DEC
76203: ST_TO_ADDR
76204: LD_VAR 0 8
76208: PUSH
76209: FOR_TO
76210: IFFALSE 76294
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76212: LD_VAR 0 8
76216: PUSH
76217: LD_VAR 0 6
76221: ARRAY
76222: PPUSH
76223: CALL_OW 461
76227: PUSH
76228: LD_INT 6
76230: EQUAL
76231: IFFALSE 76292
// begin x := tmp [ i ] ;
76233: LD_ADDR_VAR 0 9
76237: PUSH
76238: LD_VAR 0 8
76242: PUSH
76243: LD_VAR 0 6
76247: ARRAY
76248: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76249: LD_ADDR_VAR 0 8
76253: PUSH
76254: LD_VAR 0 8
76258: PPUSH
76259: LD_VAR 0 6
76263: PPUSH
76264: CALL_OW 3
76268: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76269: LD_ADDR_VAR 0 8
76273: PUSH
76274: LD_VAR 0 8
76278: PPUSH
76279: LD_INT 1
76281: PPUSH
76282: LD_VAR 0 9
76286: PPUSH
76287: CALL_OW 2
76291: ST_TO_ADDR
// end ;
76292: GO 76209
76294: POP
76295: POP
// for i in tmp do
76296: LD_ADDR_VAR 0 6
76300: PUSH
76301: LD_VAR 0 8
76305: PUSH
76306: FOR_IN
76307: IFFALSE 76376
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76309: LD_VAR 0 6
76313: PPUSH
76314: CALL_OW 313
76318: PUSH
76319: LD_INT 6
76321: LESS
76322: PUSH
76323: LD_VAR 0 6
76327: PPUSH
76328: CALL_OW 266
76332: PUSH
76333: LD_INT 31
76335: PUSH
76336: LD_INT 32
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: IN
76343: NOT
76344: AND
76345: PUSH
76346: LD_VAR 0 6
76350: PPUSH
76351: CALL_OW 313
76355: PUSH
76356: LD_INT 0
76358: EQUAL
76359: OR
76360: IFFALSE 76374
// begin j := i ;
76362: LD_ADDR_VAR 0 7
76366: PUSH
76367: LD_VAR 0 6
76371: ST_TO_ADDR
// break ;
76372: GO 76376
// end ; end ;
76374: GO 76306
76376: POP
76377: POP
// if j then
76378: LD_VAR 0 7
76382: IFFALSE 76400
// ComEnterUnit ( unit , j ) else
76384: LD_VAR 0 3
76388: PPUSH
76389: LD_VAR 0 7
76393: PPUSH
76394: CALL_OW 120
76398: GO 76503
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76400: LD_ADDR_VAR 0 10
76404: PUSH
76405: LD_VAR 0 2
76409: PPUSH
76410: LD_INT 2
76412: PUSH
76413: LD_INT 30
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 30
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: LIST
76437: PPUSH
76438: CALL_OW 72
76442: ST_TO_ADDR
// if depot then
76443: LD_VAR 0 10
76447: IFFALSE 76503
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76449: LD_ADDR_VAR 0 10
76453: PUSH
76454: LD_VAR 0 10
76458: PPUSH
76459: LD_VAR 0 3
76463: PPUSH
76464: CALL_OW 74
76468: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76469: LD_VAR 0 3
76473: PPUSH
76474: LD_VAR 0 10
76478: PPUSH
76479: CALL_OW 296
76483: PUSH
76484: LD_INT 10
76486: GREATER
76487: IFFALSE 76503
// ComStandNearbyBuilding ( unit , depot ) ;
76489: LD_VAR 0 3
76493: PPUSH
76494: LD_VAR 0 10
76498: PPUSH
76499: CALL 16304 0 2
// end ; end ; end ;
76503: LD_VAR 0 5
76507: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76508: LD_INT 0
76510: PPUSH
76511: PPUSH
76512: PPUSH
76513: PPUSH
// if not mc_bases then
76514: LD_EXP 59
76518: NOT
76519: IFFALSE 76523
// exit ;
76521: GO 76762
// for i = 1 to mc_bases do
76523: LD_ADDR_VAR 0 2
76527: PUSH
76528: DOUBLE
76529: LD_INT 1
76531: DEC
76532: ST_TO_ADDR
76533: LD_EXP 59
76537: PUSH
76538: FOR_TO
76539: IFFALSE 76760
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76541: LD_ADDR_VAR 0 4
76545: PUSH
76546: LD_EXP 59
76550: PUSH
76551: LD_VAR 0 2
76555: ARRAY
76556: PPUSH
76557: LD_INT 21
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PPUSH
76567: CALL_OW 72
76571: PUSH
76572: LD_EXP 88
76576: PUSH
76577: LD_VAR 0 2
76581: ARRAY
76582: UNION
76583: ST_TO_ADDR
// if not tmp then
76584: LD_VAR 0 4
76588: NOT
76589: IFFALSE 76593
// continue ;
76591: GO 76538
// for j in tmp do
76593: LD_ADDR_VAR 0 3
76597: PUSH
76598: LD_VAR 0 4
76602: PUSH
76603: FOR_IN
76604: IFFALSE 76756
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76606: LD_VAR 0 3
76610: PPUSH
76611: CALL_OW 110
76615: NOT
76616: PUSH
76617: LD_VAR 0 3
76621: PPUSH
76622: CALL_OW 314
76626: NOT
76627: AND
76628: PUSH
76629: LD_VAR 0 3
76633: PPUSH
76634: CALL_OW 311
76638: NOT
76639: AND
76640: PUSH
76641: LD_VAR 0 3
76645: PPUSH
76646: CALL_OW 310
76650: NOT
76651: AND
76652: PUSH
76653: LD_VAR 0 3
76657: PUSH
76658: LD_EXP 62
76662: PUSH
76663: LD_VAR 0 2
76667: ARRAY
76668: PUSH
76669: LD_INT 1
76671: ARRAY
76672: IN
76673: NOT
76674: AND
76675: PUSH
76676: LD_VAR 0 3
76680: PUSH
76681: LD_EXP 62
76685: PUSH
76686: LD_VAR 0 2
76690: ARRAY
76691: PUSH
76692: LD_INT 2
76694: ARRAY
76695: IN
76696: NOT
76697: AND
76698: PUSH
76699: LD_VAR 0 3
76703: PUSH
76704: LD_EXP 71
76708: PUSH
76709: LD_VAR 0 2
76713: ARRAY
76714: IN
76715: NOT
76716: AND
76717: IFFALSE 76754
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76719: LD_VAR 0 2
76723: PPUSH
76724: LD_EXP 59
76728: PUSH
76729: LD_VAR 0 2
76733: ARRAY
76734: PPUSH
76735: LD_VAR 0 3
76739: PPUSH
76740: LD_VAR 0 3
76744: PPUSH
76745: CALL_OW 257
76749: PPUSH
76750: CALL 75526 0 4
// end ;
76754: GO 76603
76756: POP
76757: POP
// end ;
76758: GO 76538
76760: POP
76761: POP
// end ;
76762: LD_VAR 0 1
76766: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76767: LD_INT 0
76769: PPUSH
76770: PPUSH
76771: PPUSH
76772: PPUSH
76773: PPUSH
76774: PPUSH
// if not mc_bases [ base ] then
76775: LD_EXP 59
76779: PUSH
76780: LD_VAR 0 1
76784: ARRAY
76785: NOT
76786: IFFALSE 76790
// exit ;
76788: GO 76972
// tmp := [ ] ;
76790: LD_ADDR_VAR 0 6
76794: PUSH
76795: EMPTY
76796: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76797: LD_ADDR_VAR 0 7
76801: PUSH
76802: LD_VAR 0 3
76806: PPUSH
76807: LD_INT 0
76809: PPUSH
76810: CALL_OW 517
76814: ST_TO_ADDR
// if not list then
76815: LD_VAR 0 7
76819: NOT
76820: IFFALSE 76824
// exit ;
76822: GO 76972
// for i = 1 to amount do
76824: LD_ADDR_VAR 0 5
76828: PUSH
76829: DOUBLE
76830: LD_INT 1
76832: DEC
76833: ST_TO_ADDR
76834: LD_VAR 0 2
76838: PUSH
76839: FOR_TO
76840: IFFALSE 76920
// begin x := rand ( 1 , list [ 1 ] ) ;
76842: LD_ADDR_VAR 0 8
76846: PUSH
76847: LD_INT 1
76849: PPUSH
76850: LD_VAR 0 7
76854: PUSH
76855: LD_INT 1
76857: ARRAY
76858: PPUSH
76859: CALL_OW 12
76863: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76864: LD_ADDR_VAR 0 6
76868: PUSH
76869: LD_VAR 0 6
76873: PPUSH
76874: LD_VAR 0 5
76878: PPUSH
76879: LD_VAR 0 7
76883: PUSH
76884: LD_INT 1
76886: ARRAY
76887: PUSH
76888: LD_VAR 0 8
76892: ARRAY
76893: PUSH
76894: LD_VAR 0 7
76898: PUSH
76899: LD_INT 2
76901: ARRAY
76902: PUSH
76903: LD_VAR 0 8
76907: ARRAY
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: PPUSH
76913: CALL_OW 1
76917: ST_TO_ADDR
// end ;
76918: GO 76839
76920: POP
76921: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76922: LD_ADDR_EXP 72
76926: PUSH
76927: LD_EXP 72
76931: PPUSH
76932: LD_VAR 0 1
76936: PPUSH
76937: LD_VAR 0 6
76941: PPUSH
76942: CALL_OW 1
76946: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76947: LD_ADDR_EXP 74
76951: PUSH
76952: LD_EXP 74
76956: PPUSH
76957: LD_VAR 0 1
76961: PPUSH
76962: LD_VAR 0 3
76966: PPUSH
76967: CALL_OW 1
76971: ST_TO_ADDR
// end ;
76972: LD_VAR 0 4
76976: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76977: LD_INT 0
76979: PPUSH
// if not mc_bases [ base ] then
76980: LD_EXP 59
76984: PUSH
76985: LD_VAR 0 1
76989: ARRAY
76990: NOT
76991: IFFALSE 76995
// exit ;
76993: GO 77020
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76995: LD_ADDR_EXP 64
76999: PUSH
77000: LD_EXP 64
77004: PPUSH
77005: LD_VAR 0 1
77009: PPUSH
77010: LD_VAR 0 2
77014: PPUSH
77015: CALL_OW 1
77019: ST_TO_ADDR
// end ;
77020: LD_VAR 0 3
77024: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77025: LD_INT 0
77027: PPUSH
// if not mc_bases [ base ] then
77028: LD_EXP 59
77032: PUSH
77033: LD_VAR 0 1
77037: ARRAY
77038: NOT
77039: IFFALSE 77043
// exit ;
77041: GO 77080
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77043: LD_ADDR_EXP 64
77047: PUSH
77048: LD_EXP 64
77052: PPUSH
77053: LD_VAR 0 1
77057: PPUSH
77058: LD_EXP 64
77062: PUSH
77063: LD_VAR 0 1
77067: ARRAY
77068: PUSH
77069: LD_VAR 0 2
77073: UNION
77074: PPUSH
77075: CALL_OW 1
77079: ST_TO_ADDR
// end ;
77080: LD_VAR 0 3
77084: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77085: LD_INT 0
77087: PPUSH
// if not mc_bases [ base ] then
77088: LD_EXP 59
77092: PUSH
77093: LD_VAR 0 1
77097: ARRAY
77098: NOT
77099: IFFALSE 77103
// exit ;
77101: GO 77128
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77103: LD_ADDR_EXP 80
77107: PUSH
77108: LD_EXP 80
77112: PPUSH
77113: LD_VAR 0 1
77117: PPUSH
77118: LD_VAR 0 2
77122: PPUSH
77123: CALL_OW 1
77127: ST_TO_ADDR
// end ;
77128: LD_VAR 0 3
77132: RET
// export function MC_InsertProduceList ( base , components ) ; begin
77133: LD_INT 0
77135: PPUSH
// if not mc_bases [ base ] then
77136: LD_EXP 59
77140: PUSH
77141: LD_VAR 0 1
77145: ARRAY
77146: NOT
77147: IFFALSE 77151
// exit ;
77149: GO 77188
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
77151: LD_ADDR_EXP 80
77155: PUSH
77156: LD_EXP 80
77160: PPUSH
77161: LD_VAR 0 1
77165: PPUSH
77166: LD_EXP 80
77170: PUSH
77171: LD_VAR 0 1
77175: ARRAY
77176: PUSH
77177: LD_VAR 0 2
77181: ADD
77182: PPUSH
77183: CALL_OW 1
77187: ST_TO_ADDR
// end ;
77188: LD_VAR 0 3
77192: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77193: LD_INT 0
77195: PPUSH
// if not mc_bases [ base ] then
77196: LD_EXP 59
77200: PUSH
77201: LD_VAR 0 1
77205: ARRAY
77206: NOT
77207: IFFALSE 77211
// exit ;
77209: GO 77265
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77211: LD_ADDR_EXP 81
77215: PUSH
77216: LD_EXP 81
77220: PPUSH
77221: LD_VAR 0 1
77225: PPUSH
77226: LD_VAR 0 2
77230: PPUSH
77231: CALL_OW 1
77235: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77236: LD_ADDR_EXP 70
77240: PUSH
77241: LD_EXP 70
77245: PPUSH
77246: LD_VAR 0 1
77250: PPUSH
77251: LD_VAR 0 2
77255: PUSH
77256: LD_INT 0
77258: PLUS
77259: PPUSH
77260: CALL_OW 1
77264: ST_TO_ADDR
// end ;
77265: LD_VAR 0 3
77269: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77270: LD_INT 0
77272: PPUSH
// if not mc_bases [ base ] then
77273: LD_EXP 59
77277: PUSH
77278: LD_VAR 0 1
77282: ARRAY
77283: NOT
77284: IFFALSE 77288
// exit ;
77286: GO 77313
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77288: LD_ADDR_EXP 70
77292: PUSH
77293: LD_EXP 70
77297: PPUSH
77298: LD_VAR 0 1
77302: PPUSH
77303: LD_VAR 0 2
77307: PPUSH
77308: CALL_OW 1
77312: ST_TO_ADDR
// end ;
77313: LD_VAR 0 3
77317: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77318: LD_INT 0
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
// if not mc_bases [ base ] then
77324: LD_EXP 59
77328: PUSH
77329: LD_VAR 0 1
77333: ARRAY
77334: NOT
77335: IFFALSE 77339
// exit ;
77337: GO 77404
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77339: LD_ADDR_EXP 79
77343: PUSH
77344: LD_EXP 79
77348: PPUSH
77349: LD_VAR 0 1
77353: PUSH
77354: LD_EXP 79
77358: PUSH
77359: LD_VAR 0 1
77363: ARRAY
77364: PUSH
77365: LD_INT 1
77367: PLUS
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PPUSH
77373: LD_VAR 0 1
77377: PUSH
77378: LD_VAR 0 2
77382: PUSH
77383: LD_VAR 0 3
77387: PUSH
77388: LD_VAR 0 4
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: PPUSH
77399: CALL 19726 0 3
77403: ST_TO_ADDR
// end ;
77404: LD_VAR 0 5
77408: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77409: LD_INT 0
77411: PPUSH
// if not mc_bases [ base ] then
77412: LD_EXP 59
77416: PUSH
77417: LD_VAR 0 1
77421: ARRAY
77422: NOT
77423: IFFALSE 77427
// exit ;
77425: GO 77452
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77427: LD_ADDR_EXP 96
77431: PUSH
77432: LD_EXP 96
77436: PPUSH
77437: LD_VAR 0 1
77441: PPUSH
77442: LD_VAR 0 2
77446: PPUSH
77447: CALL_OW 1
77451: ST_TO_ADDR
// end ;
77452: LD_VAR 0 3
77456: RET
// export function MC_GetMinesField ( base ) ; begin
77457: LD_INT 0
77459: PPUSH
// result := mc_mines [ base ] ;
77460: LD_ADDR_VAR 0 2
77464: PUSH
77465: LD_EXP 72
77469: PUSH
77470: LD_VAR 0 1
77474: ARRAY
77475: ST_TO_ADDR
// end ;
77476: LD_VAR 0 2
77480: RET
// export function MC_GetProduceList ( base ) ; begin
77481: LD_INT 0
77483: PPUSH
// result := mc_produce [ base ] ;
77484: LD_ADDR_VAR 0 2
77488: PUSH
77489: LD_EXP 80
77493: PUSH
77494: LD_VAR 0 1
77498: ARRAY
77499: ST_TO_ADDR
// end ;
77500: LD_VAR 0 2
77504: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77505: LD_INT 0
77507: PPUSH
77508: PPUSH
// if not mc_bases then
77509: LD_EXP 59
77513: NOT
77514: IFFALSE 77518
// exit ;
77516: GO 77583
// if mc_bases [ base ] then
77518: LD_EXP 59
77522: PUSH
77523: LD_VAR 0 1
77527: ARRAY
77528: IFFALSE 77583
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77530: LD_ADDR_VAR 0 3
77534: PUSH
77535: LD_EXP 59
77539: PUSH
77540: LD_VAR 0 1
77544: ARRAY
77545: PPUSH
77546: LD_INT 30
77548: PUSH
77549: LD_VAR 0 2
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PPUSH
77558: CALL_OW 72
77562: ST_TO_ADDR
// if result then
77563: LD_VAR 0 3
77567: IFFALSE 77583
// result := result [ 1 ] ;
77569: LD_ADDR_VAR 0 3
77573: PUSH
77574: LD_VAR 0 3
77578: PUSH
77579: LD_INT 1
77581: ARRAY
77582: ST_TO_ADDR
// end ; end ;
77583: LD_VAR 0 3
77587: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77588: LD_INT 0
77590: PPUSH
77591: PPUSH
// if not mc_bases then
77592: LD_EXP 59
77596: NOT
77597: IFFALSE 77601
// exit ;
77599: GO 77646
// if mc_bases [ base ] then
77601: LD_EXP 59
77605: PUSH
77606: LD_VAR 0 1
77610: ARRAY
77611: IFFALSE 77646
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77613: LD_ADDR_VAR 0 3
77617: PUSH
77618: LD_EXP 59
77622: PUSH
77623: LD_VAR 0 1
77627: ARRAY
77628: PPUSH
77629: LD_INT 30
77631: PUSH
77632: LD_VAR 0 2
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PPUSH
77641: CALL_OW 72
77645: ST_TO_ADDR
// end ;
77646: LD_VAR 0 3
77650: RET
// export function MC_SetTame ( base , area ) ; begin
77651: LD_INT 0
77653: PPUSH
// if not mc_bases or not base then
77654: LD_EXP 59
77658: NOT
77659: PUSH
77660: LD_VAR 0 1
77664: NOT
77665: OR
77666: IFFALSE 77670
// exit ;
77668: GO 77695
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77670: LD_ADDR_EXP 87
77674: PUSH
77675: LD_EXP 87
77679: PPUSH
77680: LD_VAR 0 1
77684: PPUSH
77685: LD_VAR 0 2
77689: PPUSH
77690: CALL_OW 1
77694: ST_TO_ADDR
// end ;
77695: LD_VAR 0 3
77699: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77700: LD_INT 0
77702: PPUSH
77703: PPUSH
// if not mc_bases or not base then
77704: LD_EXP 59
77708: NOT
77709: PUSH
77710: LD_VAR 0 1
77714: NOT
77715: OR
77716: IFFALSE 77720
// exit ;
77718: GO 77822
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77720: LD_ADDR_VAR 0 4
77724: PUSH
77725: LD_EXP 59
77729: PUSH
77730: LD_VAR 0 1
77734: ARRAY
77735: PPUSH
77736: LD_INT 30
77738: PUSH
77739: LD_VAR 0 2
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PPUSH
77748: CALL_OW 72
77752: ST_TO_ADDR
// if not tmp then
77753: LD_VAR 0 4
77757: NOT
77758: IFFALSE 77762
// exit ;
77760: GO 77822
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77762: LD_ADDR_EXP 91
77766: PUSH
77767: LD_EXP 91
77771: PPUSH
77772: LD_VAR 0 1
77776: PPUSH
77777: LD_EXP 91
77781: PUSH
77782: LD_VAR 0 1
77786: ARRAY
77787: PPUSH
77788: LD_EXP 91
77792: PUSH
77793: LD_VAR 0 1
77797: ARRAY
77798: PUSH
77799: LD_INT 1
77801: PLUS
77802: PPUSH
77803: LD_VAR 0 4
77807: PUSH
77808: LD_INT 1
77810: ARRAY
77811: PPUSH
77812: CALL_OW 2
77816: PPUSH
77817: CALL_OW 1
77821: ST_TO_ADDR
// end ;
77822: LD_VAR 0 3
77826: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77827: LD_INT 0
77829: PPUSH
77830: PPUSH
// if not mc_bases or not base or not kinds then
77831: LD_EXP 59
77835: NOT
77836: PUSH
77837: LD_VAR 0 1
77841: NOT
77842: OR
77843: PUSH
77844: LD_VAR 0 2
77848: NOT
77849: OR
77850: IFFALSE 77854
// exit ;
77852: GO 77915
// for i in kinds do
77854: LD_ADDR_VAR 0 4
77858: PUSH
77859: LD_VAR 0 2
77863: PUSH
77864: FOR_IN
77865: IFFALSE 77913
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77867: LD_ADDR_EXP 93
77871: PUSH
77872: LD_EXP 93
77876: PPUSH
77877: LD_VAR 0 1
77881: PUSH
77882: LD_EXP 93
77886: PUSH
77887: LD_VAR 0 1
77891: ARRAY
77892: PUSH
77893: LD_INT 1
77895: PLUS
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PPUSH
77901: LD_VAR 0 4
77905: PPUSH
77906: CALL 19726 0 3
77910: ST_TO_ADDR
77911: GO 77864
77913: POP
77914: POP
// end ;
77915: LD_VAR 0 3
77919: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77920: LD_INT 0
77922: PPUSH
// if not mc_bases or not base or not areas then
77923: LD_EXP 59
77927: NOT
77928: PUSH
77929: LD_VAR 0 1
77933: NOT
77934: OR
77935: PUSH
77936: LD_VAR 0 2
77940: NOT
77941: OR
77942: IFFALSE 77946
// exit ;
77944: GO 77971
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77946: LD_ADDR_EXP 77
77950: PUSH
77951: LD_EXP 77
77955: PPUSH
77956: LD_VAR 0 1
77960: PPUSH
77961: LD_VAR 0 2
77965: PPUSH
77966: CALL_OW 1
77970: ST_TO_ADDR
// end ;
77971: LD_VAR 0 3
77975: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77976: LD_INT 0
77978: PPUSH
// if not mc_bases or not base or not teleports_exit then
77979: LD_EXP 59
77983: NOT
77984: PUSH
77985: LD_VAR 0 1
77989: NOT
77990: OR
77991: PUSH
77992: LD_VAR 0 2
77996: NOT
77997: OR
77998: IFFALSE 78002
// exit ;
78000: GO 78027
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78002: LD_ADDR_EXP 94
78006: PUSH
78007: LD_EXP 94
78011: PPUSH
78012: LD_VAR 0 1
78016: PPUSH
78017: LD_VAR 0 2
78021: PPUSH
78022: CALL_OW 1
78026: ST_TO_ADDR
// end ;
78027: LD_VAR 0 3
78031: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78032: LD_INT 0
78034: PPUSH
78035: PPUSH
78036: PPUSH
// if not mc_bases or not base or not ext_list then
78037: LD_EXP 59
78041: NOT
78042: PUSH
78043: LD_VAR 0 1
78047: NOT
78048: OR
78049: PUSH
78050: LD_VAR 0 5
78054: NOT
78055: OR
78056: IFFALSE 78060
// exit ;
78058: GO 78233
// tmp := GetFacExtXYD ( x , y , d ) ;
78060: LD_ADDR_VAR 0 8
78064: PUSH
78065: LD_VAR 0 2
78069: PPUSH
78070: LD_VAR 0 3
78074: PPUSH
78075: LD_VAR 0 4
78079: PPUSH
78080: CALL 49114 0 3
78084: ST_TO_ADDR
// if not tmp then
78085: LD_VAR 0 8
78089: NOT
78090: IFFALSE 78094
// exit ;
78092: GO 78233
// for i in tmp do
78094: LD_ADDR_VAR 0 7
78098: PUSH
78099: LD_VAR 0 8
78103: PUSH
78104: FOR_IN
78105: IFFALSE 78231
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78107: LD_ADDR_EXP 64
78111: PUSH
78112: LD_EXP 64
78116: PPUSH
78117: LD_VAR 0 1
78121: PPUSH
78122: LD_EXP 64
78126: PUSH
78127: LD_VAR 0 1
78131: ARRAY
78132: PPUSH
78133: LD_EXP 64
78137: PUSH
78138: LD_VAR 0 1
78142: ARRAY
78143: PUSH
78144: LD_INT 1
78146: PLUS
78147: PPUSH
78148: LD_VAR 0 5
78152: PUSH
78153: LD_INT 1
78155: ARRAY
78156: PUSH
78157: LD_VAR 0 7
78161: PUSH
78162: LD_INT 1
78164: ARRAY
78165: PUSH
78166: LD_VAR 0 7
78170: PUSH
78171: LD_INT 2
78173: ARRAY
78174: PUSH
78175: LD_VAR 0 7
78179: PUSH
78180: LD_INT 3
78182: ARRAY
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: LIST
78188: LIST
78189: PPUSH
78190: CALL_OW 2
78194: PPUSH
78195: CALL_OW 1
78199: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78200: LD_ADDR_VAR 0 5
78204: PUSH
78205: LD_VAR 0 5
78209: PPUSH
78210: LD_INT 1
78212: PPUSH
78213: CALL_OW 3
78217: ST_TO_ADDR
// if not ext_list then
78218: LD_VAR 0 5
78222: NOT
78223: IFFALSE 78229
// exit ;
78225: POP
78226: POP
78227: GO 78233
// end ;
78229: GO 78104
78231: POP
78232: POP
// end ;
78233: LD_VAR 0 6
78237: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78238: LD_INT 0
78240: PPUSH
// if not mc_bases or not base or not weapon_list then
78241: LD_EXP 59
78245: NOT
78246: PUSH
78247: LD_VAR 0 1
78251: NOT
78252: OR
78253: PUSH
78254: LD_VAR 0 2
78258: NOT
78259: OR
78260: IFFALSE 78264
// exit ;
78262: GO 78289
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78264: LD_ADDR_EXP 98
78268: PUSH
78269: LD_EXP 98
78273: PPUSH
78274: LD_VAR 0 1
78278: PPUSH
78279: LD_VAR 0 2
78283: PPUSH
78284: CALL_OW 1
78288: ST_TO_ADDR
// end ;
78289: LD_VAR 0 3
78293: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78294: LD_INT 0
78296: PPUSH
// if not mc_bases or not base or not tech_list then
78297: LD_EXP 59
78301: NOT
78302: PUSH
78303: LD_VAR 0 1
78307: NOT
78308: OR
78309: PUSH
78310: LD_VAR 0 2
78314: NOT
78315: OR
78316: IFFALSE 78320
// exit ;
78318: GO 78345
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78320: LD_ADDR_EXP 86
78324: PUSH
78325: LD_EXP 86
78329: PPUSH
78330: LD_VAR 0 1
78334: PPUSH
78335: LD_VAR 0 2
78339: PPUSH
78340: CALL_OW 1
78344: ST_TO_ADDR
// end ;
78345: LD_VAR 0 3
78349: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78350: LD_INT 0
78352: PPUSH
// if not mc_bases or not parking_area or not base then
78353: LD_EXP 59
78357: NOT
78358: PUSH
78359: LD_VAR 0 2
78363: NOT
78364: OR
78365: PUSH
78366: LD_VAR 0 1
78370: NOT
78371: OR
78372: IFFALSE 78376
// exit ;
78374: GO 78401
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78376: LD_ADDR_EXP 83
78380: PUSH
78381: LD_EXP 83
78385: PPUSH
78386: LD_VAR 0 1
78390: PPUSH
78391: LD_VAR 0 2
78395: PPUSH
78396: CALL_OW 1
78400: ST_TO_ADDR
// end ;
78401: LD_VAR 0 3
78405: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78406: LD_INT 0
78408: PPUSH
// if not mc_bases or not base or not scan_area then
78409: LD_EXP 59
78413: NOT
78414: PUSH
78415: LD_VAR 0 1
78419: NOT
78420: OR
78421: PUSH
78422: LD_VAR 0 2
78426: NOT
78427: OR
78428: IFFALSE 78432
// exit ;
78430: GO 78457
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78432: LD_ADDR_EXP 84
78436: PUSH
78437: LD_EXP 84
78441: PPUSH
78442: LD_VAR 0 1
78446: PPUSH
78447: LD_VAR 0 2
78451: PPUSH
78452: CALL_OW 1
78456: ST_TO_ADDR
// end ;
78457: LD_VAR 0 3
78461: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78462: LD_INT 0
78464: PPUSH
78465: PPUSH
// if not mc_bases or not base then
78466: LD_EXP 59
78470: NOT
78471: PUSH
78472: LD_VAR 0 1
78476: NOT
78477: OR
78478: IFFALSE 78482
// exit ;
78480: GO 78546
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78482: LD_ADDR_VAR 0 3
78486: PUSH
78487: LD_INT 1
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: LD_INT 4
78498: PUSH
78499: LD_INT 11
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78509: LD_ADDR_EXP 86
78513: PUSH
78514: LD_EXP 86
78518: PPUSH
78519: LD_VAR 0 1
78523: PPUSH
78524: LD_EXP 86
78528: PUSH
78529: LD_VAR 0 1
78533: ARRAY
78534: PUSH
78535: LD_VAR 0 3
78539: DIFF
78540: PPUSH
78541: CALL_OW 1
78545: ST_TO_ADDR
// end ;
78546: LD_VAR 0 2
78550: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78551: LD_INT 0
78553: PPUSH
// result := mc_vehicles [ base ] ;
78554: LD_ADDR_VAR 0 3
78558: PUSH
78559: LD_EXP 78
78563: PUSH
78564: LD_VAR 0 1
78568: ARRAY
78569: ST_TO_ADDR
// if onlyCombat then
78570: LD_VAR 0 2
78574: IFFALSE 78752
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78576: LD_ADDR_VAR 0 3
78580: PUSH
78581: LD_VAR 0 3
78585: PUSH
78586: LD_VAR 0 3
78590: PPUSH
78591: LD_INT 2
78593: PUSH
78594: LD_INT 34
78596: PUSH
78597: LD_INT 12
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 34
78606: PUSH
78607: LD_INT 51
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 34
78616: PUSH
78617: LD_EXP 104
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 34
78628: PUSH
78629: LD_INT 32
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 34
78638: PUSH
78639: LD_INT 13
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 34
78648: PUSH
78649: LD_INT 52
78651: PUSH
78652: EMPTY
78653: LIST
78654: LIST
78655: PUSH
78656: LD_INT 34
78658: PUSH
78659: LD_EXP 109
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 34
78670: PUSH
78671: LD_INT 14
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 34
78680: PUSH
78681: LD_INT 53
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 34
78690: PUSH
78691: LD_EXP 103
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 34
78702: PUSH
78703: LD_INT 31
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 34
78712: PUSH
78713: LD_INT 48
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 34
78722: PUSH
78723: LD_INT 8
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: PPUSH
78746: CALL_OW 72
78750: DIFF
78751: ST_TO_ADDR
// end ; end_of_file
78752: LD_VAR 0 3
78756: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78757: LD_INT 0
78759: PPUSH
78760: PPUSH
78761: PPUSH
// if not mc_bases or not skirmish then
78762: LD_EXP 59
78766: NOT
78767: PUSH
78768: LD_EXP 57
78772: NOT
78773: OR
78774: IFFALSE 78778
// exit ;
78776: GO 78943
// for i = 1 to mc_bases do
78778: LD_ADDR_VAR 0 4
78782: PUSH
78783: DOUBLE
78784: LD_INT 1
78786: DEC
78787: ST_TO_ADDR
78788: LD_EXP 59
78792: PUSH
78793: FOR_TO
78794: IFFALSE 78941
// begin if sci in mc_bases [ i ] then
78796: LD_VAR 0 2
78800: PUSH
78801: LD_EXP 59
78805: PUSH
78806: LD_VAR 0 4
78810: ARRAY
78811: IN
78812: IFFALSE 78939
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78814: LD_ADDR_EXP 88
78818: PUSH
78819: LD_EXP 88
78823: PPUSH
78824: LD_VAR 0 4
78828: PUSH
78829: LD_EXP 88
78833: PUSH
78834: LD_VAR 0 4
78838: ARRAY
78839: PUSH
78840: LD_INT 1
78842: PLUS
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PPUSH
78848: LD_VAR 0 1
78852: PPUSH
78853: CALL 19726 0 3
78857: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78858: LD_ADDR_VAR 0 5
78862: PUSH
78863: LD_EXP 59
78867: PUSH
78868: LD_VAR 0 4
78872: ARRAY
78873: PPUSH
78874: LD_INT 2
78876: PUSH
78877: LD_INT 30
78879: PUSH
78880: LD_INT 0
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 30
78889: PUSH
78890: LD_INT 1
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: LIST
78901: PPUSH
78902: CALL_OW 72
78906: PPUSH
78907: LD_VAR 0 1
78911: PPUSH
78912: CALL_OW 74
78916: ST_TO_ADDR
// if tmp then
78917: LD_VAR 0 5
78921: IFFALSE 78937
// ComStandNearbyBuilding ( ape , tmp ) ;
78923: LD_VAR 0 1
78927: PPUSH
78928: LD_VAR 0 5
78932: PPUSH
78933: CALL 16304 0 2
// break ;
78937: GO 78941
// end ; end ;
78939: GO 78793
78941: POP
78942: POP
// end ;
78943: LD_VAR 0 3
78947: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78948: LD_INT 0
78950: PPUSH
78951: PPUSH
78952: PPUSH
// if not mc_bases or not skirmish then
78953: LD_EXP 59
78957: NOT
78958: PUSH
78959: LD_EXP 57
78963: NOT
78964: OR
78965: IFFALSE 78969
// exit ;
78967: GO 79058
// for i = 1 to mc_bases do
78969: LD_ADDR_VAR 0 4
78973: PUSH
78974: DOUBLE
78975: LD_INT 1
78977: DEC
78978: ST_TO_ADDR
78979: LD_EXP 59
78983: PUSH
78984: FOR_TO
78985: IFFALSE 79056
// begin if building in mc_busy_turret_list [ i ] then
78987: LD_VAR 0 1
78991: PUSH
78992: LD_EXP 69
78996: PUSH
78997: LD_VAR 0 4
79001: ARRAY
79002: IN
79003: IFFALSE 79054
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79005: LD_ADDR_VAR 0 5
79009: PUSH
79010: LD_EXP 69
79014: PUSH
79015: LD_VAR 0 4
79019: ARRAY
79020: PUSH
79021: LD_VAR 0 1
79025: DIFF
79026: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79027: LD_ADDR_EXP 69
79031: PUSH
79032: LD_EXP 69
79036: PPUSH
79037: LD_VAR 0 4
79041: PPUSH
79042: LD_VAR 0 5
79046: PPUSH
79047: CALL_OW 1
79051: ST_TO_ADDR
// break ;
79052: GO 79056
// end ; end ;
79054: GO 78984
79056: POP
79057: POP
// end ;
79058: LD_VAR 0 3
79062: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79063: LD_INT 0
79065: PPUSH
79066: PPUSH
79067: PPUSH
// if not mc_bases or not skirmish then
79068: LD_EXP 59
79072: NOT
79073: PUSH
79074: LD_EXP 57
79078: NOT
79079: OR
79080: IFFALSE 79084
// exit ;
79082: GO 79283
// for i = 1 to mc_bases do
79084: LD_ADDR_VAR 0 5
79088: PUSH
79089: DOUBLE
79090: LD_INT 1
79092: DEC
79093: ST_TO_ADDR
79094: LD_EXP 59
79098: PUSH
79099: FOR_TO
79100: IFFALSE 79281
// if building in mc_bases [ i ] then
79102: LD_VAR 0 1
79106: PUSH
79107: LD_EXP 59
79111: PUSH
79112: LD_VAR 0 5
79116: ARRAY
79117: IN
79118: IFFALSE 79279
// begin tmp := mc_bases [ i ] diff building ;
79120: LD_ADDR_VAR 0 6
79124: PUSH
79125: LD_EXP 59
79129: PUSH
79130: LD_VAR 0 5
79134: ARRAY
79135: PUSH
79136: LD_VAR 0 1
79140: DIFF
79141: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79142: LD_ADDR_EXP 59
79146: PUSH
79147: LD_EXP 59
79151: PPUSH
79152: LD_VAR 0 5
79156: PPUSH
79157: LD_VAR 0 6
79161: PPUSH
79162: CALL_OW 1
79166: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79167: LD_VAR 0 1
79171: PUSH
79172: LD_EXP 67
79176: PUSH
79177: LD_VAR 0 5
79181: ARRAY
79182: IN
79183: IFFALSE 79222
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79185: LD_ADDR_EXP 67
79189: PUSH
79190: LD_EXP 67
79194: PPUSH
79195: LD_VAR 0 5
79199: PPUSH
79200: LD_EXP 67
79204: PUSH
79205: LD_VAR 0 5
79209: ARRAY
79210: PUSH
79211: LD_VAR 0 1
79215: DIFF
79216: PPUSH
79217: CALL_OW 1
79221: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79222: LD_VAR 0 1
79226: PUSH
79227: LD_EXP 68
79231: PUSH
79232: LD_VAR 0 5
79236: ARRAY
79237: IN
79238: IFFALSE 79277
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79240: LD_ADDR_EXP 68
79244: PUSH
79245: LD_EXP 68
79249: PPUSH
79250: LD_VAR 0 5
79254: PPUSH
79255: LD_EXP 68
79259: PUSH
79260: LD_VAR 0 5
79264: ARRAY
79265: PUSH
79266: LD_VAR 0 1
79270: DIFF
79271: PPUSH
79272: CALL_OW 1
79276: ST_TO_ADDR
// break ;
79277: GO 79281
// end ;
79279: GO 79099
79281: POP
79282: POP
// end ;
79283: LD_VAR 0 4
79287: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79288: LD_INT 0
79290: PPUSH
79291: PPUSH
79292: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79293: LD_EXP 59
79297: NOT
79298: PUSH
79299: LD_EXP 57
79303: NOT
79304: OR
79305: PUSH
79306: LD_VAR 0 3
79310: PUSH
79311: LD_EXP 85
79315: IN
79316: NOT
79317: OR
79318: IFFALSE 79322
// exit ;
79320: GO 79445
// for i = 1 to mc_vehicles do
79322: LD_ADDR_VAR 0 6
79326: PUSH
79327: DOUBLE
79328: LD_INT 1
79330: DEC
79331: ST_TO_ADDR
79332: LD_EXP 78
79336: PUSH
79337: FOR_TO
79338: IFFALSE 79443
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79340: LD_VAR 0 2
79344: PUSH
79345: LD_EXP 78
79349: PUSH
79350: LD_VAR 0 6
79354: ARRAY
79355: IN
79356: PUSH
79357: LD_VAR 0 1
79361: PUSH
79362: LD_EXP 78
79366: PUSH
79367: LD_VAR 0 6
79371: ARRAY
79372: IN
79373: OR
79374: IFFALSE 79441
// begin tmp := mc_vehicles [ i ] diff old ;
79376: LD_ADDR_VAR 0 7
79380: PUSH
79381: LD_EXP 78
79385: PUSH
79386: LD_VAR 0 6
79390: ARRAY
79391: PUSH
79392: LD_VAR 0 2
79396: DIFF
79397: ST_TO_ADDR
// tmp := tmp diff new ;
79398: LD_ADDR_VAR 0 7
79402: PUSH
79403: LD_VAR 0 7
79407: PUSH
79408: LD_VAR 0 1
79412: DIFF
79413: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79414: LD_ADDR_EXP 78
79418: PUSH
79419: LD_EXP 78
79423: PPUSH
79424: LD_VAR 0 6
79428: PPUSH
79429: LD_VAR 0 7
79433: PPUSH
79434: CALL_OW 1
79438: ST_TO_ADDR
// break ;
79439: GO 79443
// end ;
79441: GO 79337
79443: POP
79444: POP
// end ;
79445: LD_VAR 0 5
79449: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79450: LD_INT 0
79452: PPUSH
79453: PPUSH
79454: PPUSH
79455: PPUSH
// if not mc_bases or not skirmish then
79456: LD_EXP 59
79460: NOT
79461: PUSH
79462: LD_EXP 57
79466: NOT
79467: OR
79468: IFFALSE 79472
// exit ;
79470: GO 79855
// side := GetSide ( vehicle ) ;
79472: LD_ADDR_VAR 0 5
79476: PUSH
79477: LD_VAR 0 1
79481: PPUSH
79482: CALL_OW 255
79486: ST_TO_ADDR
// for i = 1 to mc_bases do
79487: LD_ADDR_VAR 0 4
79491: PUSH
79492: DOUBLE
79493: LD_INT 1
79495: DEC
79496: ST_TO_ADDR
79497: LD_EXP 59
79501: PUSH
79502: FOR_TO
79503: IFFALSE 79853
// begin if factory in mc_bases [ i ] then
79505: LD_VAR 0 2
79509: PUSH
79510: LD_EXP 59
79514: PUSH
79515: LD_VAR 0 4
79519: ARRAY
79520: IN
79521: IFFALSE 79851
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79523: LD_EXP 81
79527: PUSH
79528: LD_VAR 0 4
79532: ARRAY
79533: PUSH
79534: LD_EXP 70
79538: PUSH
79539: LD_VAR 0 4
79543: ARRAY
79544: LESS
79545: PUSH
79546: LD_VAR 0 1
79550: PPUSH
79551: CALL_OW 264
79555: PUSH
79556: LD_INT 31
79558: PUSH
79559: LD_INT 32
79561: PUSH
79562: LD_INT 51
79564: PUSH
79565: LD_EXP 104
79569: PUSH
79570: LD_INT 12
79572: PUSH
79573: LD_INT 30
79575: PUSH
79576: LD_EXP 103
79580: PUSH
79581: LD_INT 11
79583: PUSH
79584: LD_INT 53
79586: PUSH
79587: LD_INT 14
79589: PUSH
79590: LD_EXP 107
79594: PUSH
79595: LD_INT 29
79597: PUSH
79598: LD_EXP 105
79602: PUSH
79603: LD_INT 13
79605: PUSH
79606: LD_INT 52
79608: PUSH
79609: LD_EXP 109
79613: PUSH
79614: LD_INT 48
79616: PUSH
79617: LD_INT 8
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: IN
79640: NOT
79641: AND
79642: IFFALSE 79690
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79644: LD_ADDR_EXP 81
79648: PUSH
79649: LD_EXP 81
79653: PPUSH
79654: LD_VAR 0 4
79658: PUSH
79659: LD_EXP 81
79663: PUSH
79664: LD_VAR 0 4
79668: ARRAY
79669: PUSH
79670: LD_INT 1
79672: PLUS
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PPUSH
79678: LD_VAR 0 1
79682: PPUSH
79683: CALL 19726 0 3
79687: ST_TO_ADDR
79688: GO 79734
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79690: LD_ADDR_EXP 78
79694: PUSH
79695: LD_EXP 78
79699: PPUSH
79700: LD_VAR 0 4
79704: PUSH
79705: LD_EXP 78
79709: PUSH
79710: LD_VAR 0 4
79714: ARRAY
79715: PUSH
79716: LD_INT 1
79718: PLUS
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PPUSH
79724: LD_VAR 0 1
79728: PPUSH
79729: CALL 19726 0 3
79733: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79734: LD_VAR 0 1
79738: PPUSH
79739: CALL_OW 263
79743: PUSH
79744: LD_INT 2
79746: EQUAL
79747: IFFALSE 79767
// begin repeat wait ( 0 0$1 ) ;
79749: LD_INT 35
79751: PPUSH
79752: CALL_OW 67
// until IsControledBy ( vehicle ) ;
79756: LD_VAR 0 1
79760: PPUSH
79761: CALL_OW 312
79765: IFFALSE 79749
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79767: LD_VAR 0 1
79771: PPUSH
79772: LD_EXP 83
79776: PUSH
79777: LD_VAR 0 4
79781: ARRAY
79782: PPUSH
79783: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79787: LD_VAR 0 1
79791: PPUSH
79792: CALL_OW 263
79796: PUSH
79797: LD_INT 1
79799: NONEQUAL
79800: IFFALSE 79804
// break ;
79802: GO 79853
// repeat wait ( 0 0$1 ) ;
79804: LD_INT 35
79806: PPUSH
79807: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79811: LD_VAR 0 1
79815: PPUSH
79816: LD_EXP 83
79820: PUSH
79821: LD_VAR 0 4
79825: ARRAY
79826: PPUSH
79827: CALL_OW 308
79831: IFFALSE 79804
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79833: LD_VAR 0 1
79837: PPUSH
79838: CALL_OW 311
79842: PPUSH
79843: CALL_OW 121
// exit ;
79847: POP
79848: POP
79849: GO 79855
// end ; end ;
79851: GO 79502
79853: POP
79854: POP
// end ;
79855: LD_VAR 0 3
79859: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79860: LD_INT 0
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
// if not mc_bases or not skirmish then
79866: LD_EXP 59
79870: NOT
79871: PUSH
79872: LD_EXP 57
79876: NOT
79877: OR
79878: IFFALSE 79882
// exit ;
79880: GO 80235
// repeat wait ( 0 0$1 ) ;
79882: LD_INT 35
79884: PPUSH
79885: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79889: LD_VAR 0 2
79893: PPUSH
79894: LD_VAR 0 3
79898: PPUSH
79899: CALL_OW 284
79903: IFFALSE 79882
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79905: LD_VAR 0 2
79909: PPUSH
79910: LD_VAR 0 3
79914: PPUSH
79915: CALL_OW 283
79919: PUSH
79920: LD_INT 4
79922: EQUAL
79923: IFFALSE 79927
// exit ;
79925: GO 80235
// for i = 1 to mc_bases do
79927: LD_ADDR_VAR 0 7
79931: PUSH
79932: DOUBLE
79933: LD_INT 1
79935: DEC
79936: ST_TO_ADDR
79937: LD_EXP 59
79941: PUSH
79942: FOR_TO
79943: IFFALSE 80233
// begin if mc_crates_area [ i ] then
79945: LD_EXP 77
79949: PUSH
79950: LD_VAR 0 7
79954: ARRAY
79955: IFFALSE 80066
// for j in mc_crates_area [ i ] do
79957: LD_ADDR_VAR 0 8
79961: PUSH
79962: LD_EXP 77
79966: PUSH
79967: LD_VAR 0 7
79971: ARRAY
79972: PUSH
79973: FOR_IN
79974: IFFALSE 80064
// if InArea ( x , y , j ) then
79976: LD_VAR 0 2
79980: PPUSH
79981: LD_VAR 0 3
79985: PPUSH
79986: LD_VAR 0 8
79990: PPUSH
79991: CALL_OW 309
79995: IFFALSE 80062
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79997: LD_ADDR_EXP 75
80001: PUSH
80002: LD_EXP 75
80006: PPUSH
80007: LD_VAR 0 7
80011: PUSH
80012: LD_EXP 75
80016: PUSH
80017: LD_VAR 0 7
80021: ARRAY
80022: PUSH
80023: LD_INT 1
80025: PLUS
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PPUSH
80031: LD_VAR 0 4
80035: PUSH
80036: LD_VAR 0 2
80040: PUSH
80041: LD_VAR 0 3
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: LIST
80050: PPUSH
80051: CALL 19726 0 3
80055: ST_TO_ADDR
// exit ;
80056: POP
80057: POP
80058: POP
80059: POP
80060: GO 80235
// end ;
80062: GO 79973
80064: POP
80065: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80066: LD_ADDR_VAR 0 9
80070: PUSH
80071: LD_EXP 59
80075: PUSH
80076: LD_VAR 0 7
80080: ARRAY
80081: PPUSH
80082: LD_INT 2
80084: PUSH
80085: LD_INT 30
80087: PUSH
80088: LD_INT 0
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 30
80097: PUSH
80098: LD_INT 1
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: LIST
80109: PPUSH
80110: CALL_OW 72
80114: ST_TO_ADDR
// if not depot then
80115: LD_VAR 0 9
80119: NOT
80120: IFFALSE 80124
// continue ;
80122: GO 79942
// for j in depot do
80124: LD_ADDR_VAR 0 8
80128: PUSH
80129: LD_VAR 0 9
80133: PUSH
80134: FOR_IN
80135: IFFALSE 80229
// if GetDistUnitXY ( j , x , y ) < 30 then
80137: LD_VAR 0 8
80141: PPUSH
80142: LD_VAR 0 2
80146: PPUSH
80147: LD_VAR 0 3
80151: PPUSH
80152: CALL_OW 297
80156: PUSH
80157: LD_INT 30
80159: LESS
80160: IFFALSE 80227
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80162: LD_ADDR_EXP 75
80166: PUSH
80167: LD_EXP 75
80171: PPUSH
80172: LD_VAR 0 7
80176: PUSH
80177: LD_EXP 75
80181: PUSH
80182: LD_VAR 0 7
80186: ARRAY
80187: PUSH
80188: LD_INT 1
80190: PLUS
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PPUSH
80196: LD_VAR 0 4
80200: PUSH
80201: LD_VAR 0 2
80205: PUSH
80206: LD_VAR 0 3
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: LIST
80215: PPUSH
80216: CALL 19726 0 3
80220: ST_TO_ADDR
// exit ;
80221: POP
80222: POP
80223: POP
80224: POP
80225: GO 80235
// end ;
80227: GO 80134
80229: POP
80230: POP
// end ;
80231: GO 79942
80233: POP
80234: POP
// end ;
80235: LD_VAR 0 6
80239: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80240: LD_INT 0
80242: PPUSH
80243: PPUSH
80244: PPUSH
80245: PPUSH
// if not mc_bases or not skirmish then
80246: LD_EXP 59
80250: NOT
80251: PUSH
80252: LD_EXP 57
80256: NOT
80257: OR
80258: IFFALSE 80262
// exit ;
80260: GO 80539
// side := GetSide ( lab ) ;
80262: LD_ADDR_VAR 0 4
80266: PUSH
80267: LD_VAR 0 2
80271: PPUSH
80272: CALL_OW 255
80276: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80277: LD_VAR 0 4
80281: PUSH
80282: LD_EXP 85
80286: IN
80287: NOT
80288: PUSH
80289: LD_EXP 86
80293: NOT
80294: OR
80295: PUSH
80296: LD_EXP 59
80300: NOT
80301: OR
80302: IFFALSE 80306
// exit ;
80304: GO 80539
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80306: LD_ADDR_EXP 86
80310: PUSH
80311: LD_EXP 86
80315: PPUSH
80316: LD_VAR 0 4
80320: PPUSH
80321: LD_EXP 86
80325: PUSH
80326: LD_VAR 0 4
80330: ARRAY
80331: PUSH
80332: LD_VAR 0 1
80336: DIFF
80337: PPUSH
80338: CALL_OW 1
80342: ST_TO_ADDR
// for i = 1 to mc_bases do
80343: LD_ADDR_VAR 0 5
80347: PUSH
80348: DOUBLE
80349: LD_INT 1
80351: DEC
80352: ST_TO_ADDR
80353: LD_EXP 59
80357: PUSH
80358: FOR_TO
80359: IFFALSE 80537
// begin if lab in mc_bases [ i ] then
80361: LD_VAR 0 2
80365: PUSH
80366: LD_EXP 59
80370: PUSH
80371: LD_VAR 0 5
80375: ARRAY
80376: IN
80377: IFFALSE 80535
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80379: LD_VAR 0 1
80383: PUSH
80384: LD_INT 11
80386: PUSH
80387: LD_INT 4
80389: PUSH
80390: LD_INT 3
80392: PUSH
80393: LD_INT 2
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: IN
80402: PUSH
80403: LD_EXP 89
80407: PUSH
80408: LD_VAR 0 5
80412: ARRAY
80413: AND
80414: IFFALSE 80535
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80416: LD_ADDR_VAR 0 6
80420: PUSH
80421: LD_EXP 89
80425: PUSH
80426: LD_VAR 0 5
80430: ARRAY
80431: PUSH
80432: LD_INT 1
80434: ARRAY
80435: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80436: LD_ADDR_EXP 89
80440: PUSH
80441: LD_EXP 89
80445: PPUSH
80446: LD_VAR 0 5
80450: PPUSH
80451: EMPTY
80452: PPUSH
80453: CALL_OW 1
80457: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80458: LD_VAR 0 6
80462: PPUSH
80463: LD_INT 0
80465: PPUSH
80466: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80470: LD_VAR 0 6
80474: PPUSH
80475: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80479: LD_ADDR_EXP 88
80483: PUSH
80484: LD_EXP 88
80488: PPUSH
80489: LD_VAR 0 5
80493: PPUSH
80494: LD_EXP 88
80498: PUSH
80499: LD_VAR 0 5
80503: ARRAY
80504: PPUSH
80505: LD_INT 1
80507: PPUSH
80508: LD_VAR 0 6
80512: PPUSH
80513: CALL_OW 2
80517: PPUSH
80518: CALL_OW 1
80522: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80523: LD_VAR 0 5
80527: PPUSH
80528: LD_INT 112
80530: PPUSH
80531: CALL 57368 0 2
// end ; end ; end ;
80535: GO 80358
80537: POP
80538: POP
// end ;
80539: LD_VAR 0 3
80543: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80544: LD_INT 0
80546: PPUSH
80547: PPUSH
80548: PPUSH
80549: PPUSH
80550: PPUSH
80551: PPUSH
80552: PPUSH
80553: PPUSH
// if not mc_bases or not skirmish then
80554: LD_EXP 59
80558: NOT
80559: PUSH
80560: LD_EXP 57
80564: NOT
80565: OR
80566: IFFALSE 80570
// exit ;
80568: GO 81941
// for i = 1 to mc_bases do
80570: LD_ADDR_VAR 0 3
80574: PUSH
80575: DOUBLE
80576: LD_INT 1
80578: DEC
80579: ST_TO_ADDR
80580: LD_EXP 59
80584: PUSH
80585: FOR_TO
80586: IFFALSE 81939
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80588: LD_VAR 0 1
80592: PUSH
80593: LD_EXP 59
80597: PUSH
80598: LD_VAR 0 3
80602: ARRAY
80603: IN
80604: PUSH
80605: LD_VAR 0 1
80609: PUSH
80610: LD_EXP 66
80614: PUSH
80615: LD_VAR 0 3
80619: ARRAY
80620: IN
80621: OR
80622: PUSH
80623: LD_VAR 0 1
80627: PUSH
80628: LD_EXP 81
80632: PUSH
80633: LD_VAR 0 3
80637: ARRAY
80638: IN
80639: OR
80640: PUSH
80641: LD_VAR 0 1
80645: PUSH
80646: LD_EXP 78
80650: PUSH
80651: LD_VAR 0 3
80655: ARRAY
80656: IN
80657: OR
80658: PUSH
80659: LD_VAR 0 1
80663: PUSH
80664: LD_EXP 88
80668: PUSH
80669: LD_VAR 0 3
80673: ARRAY
80674: IN
80675: OR
80676: PUSH
80677: LD_VAR 0 1
80681: PUSH
80682: LD_EXP 89
80686: PUSH
80687: LD_VAR 0 3
80691: ARRAY
80692: IN
80693: OR
80694: IFFALSE 81937
// begin if un in mc_ape [ i ] then
80696: LD_VAR 0 1
80700: PUSH
80701: LD_EXP 88
80705: PUSH
80706: LD_VAR 0 3
80710: ARRAY
80711: IN
80712: IFFALSE 80751
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80714: LD_ADDR_EXP 88
80718: PUSH
80719: LD_EXP 88
80723: PPUSH
80724: LD_VAR 0 3
80728: PPUSH
80729: LD_EXP 88
80733: PUSH
80734: LD_VAR 0 3
80738: ARRAY
80739: PUSH
80740: LD_VAR 0 1
80744: DIFF
80745: PPUSH
80746: CALL_OW 1
80750: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80751: LD_VAR 0 1
80755: PUSH
80756: LD_EXP 89
80760: PUSH
80761: LD_VAR 0 3
80765: ARRAY
80766: IN
80767: IFFALSE 80791
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80769: LD_ADDR_EXP 89
80773: PUSH
80774: LD_EXP 89
80778: PPUSH
80779: LD_VAR 0 3
80783: PPUSH
80784: EMPTY
80785: PPUSH
80786: CALL_OW 1
80790: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80791: LD_VAR 0 1
80795: PPUSH
80796: CALL_OW 247
80800: PUSH
80801: LD_INT 2
80803: EQUAL
80804: PUSH
80805: LD_VAR 0 1
80809: PPUSH
80810: CALL_OW 110
80814: PUSH
80815: LD_INT 20
80817: EQUAL
80818: PUSH
80819: LD_VAR 0 1
80823: PUSH
80824: LD_EXP 81
80828: PUSH
80829: LD_VAR 0 3
80833: ARRAY
80834: IN
80835: OR
80836: PUSH
80837: LD_VAR 0 1
80841: PPUSH
80842: CALL_OW 264
80846: PUSH
80847: LD_INT 12
80849: PUSH
80850: LD_INT 51
80852: PUSH
80853: LD_EXP 104
80857: PUSH
80858: LD_INT 32
80860: PUSH
80861: LD_INT 13
80863: PUSH
80864: LD_INT 52
80866: PUSH
80867: LD_INT 31
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: IN
80879: OR
80880: AND
80881: IFFALSE 81189
// begin if un in mc_defender [ i ] then
80883: LD_VAR 0 1
80887: PUSH
80888: LD_EXP 81
80892: PUSH
80893: LD_VAR 0 3
80897: ARRAY
80898: IN
80899: IFFALSE 80938
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80901: LD_ADDR_EXP 81
80905: PUSH
80906: LD_EXP 81
80910: PPUSH
80911: LD_VAR 0 3
80915: PPUSH
80916: LD_EXP 81
80920: PUSH
80921: LD_VAR 0 3
80925: ARRAY
80926: PUSH
80927: LD_VAR 0 1
80931: DIFF
80932: PPUSH
80933: CALL_OW 1
80937: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80938: LD_ADDR_VAR 0 8
80942: PUSH
80943: LD_VAR 0 3
80947: PPUSH
80948: LD_INT 3
80950: PPUSH
80951: CALL 77588 0 2
80955: ST_TO_ADDR
// if fac then
80956: LD_VAR 0 8
80960: IFFALSE 81189
// begin for j in fac do
80962: LD_ADDR_VAR 0 4
80966: PUSH
80967: LD_VAR 0 8
80971: PUSH
80972: FOR_IN
80973: IFFALSE 81187
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80975: LD_ADDR_VAR 0 9
80979: PUSH
80980: LD_VAR 0 8
80984: PPUSH
80985: LD_VAR 0 1
80989: PPUSH
80990: CALL_OW 265
80994: PPUSH
80995: LD_VAR 0 1
80999: PPUSH
81000: CALL_OW 262
81004: PPUSH
81005: LD_VAR 0 1
81009: PPUSH
81010: CALL_OW 263
81014: PPUSH
81015: LD_VAR 0 1
81019: PPUSH
81020: CALL_OW 264
81024: PPUSH
81025: CALL 17222 0 5
81029: ST_TO_ADDR
// if components then
81030: LD_VAR 0 9
81034: IFFALSE 81185
// begin if GetWeapon ( un ) = ar_control_tower then
81036: LD_VAR 0 1
81040: PPUSH
81041: CALL_OW 264
81045: PUSH
81046: LD_INT 31
81048: EQUAL
81049: IFFALSE 81166
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
81051: LD_VAR 0 1
81055: PPUSH
81056: CALL_OW 311
81060: PPUSH
81061: LD_INT 0
81063: PPUSH
81064: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
81068: LD_ADDR_EXP 99
81072: PUSH
81073: LD_EXP 99
81077: PPUSH
81078: LD_VAR 0 3
81082: PPUSH
81083: LD_EXP 99
81087: PUSH
81088: LD_VAR 0 3
81092: ARRAY
81093: PUSH
81094: LD_VAR 0 1
81098: PPUSH
81099: CALL_OW 311
81103: DIFF
81104: PPUSH
81105: CALL_OW 1
81109: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
81110: LD_ADDR_VAR 0 7
81114: PUSH
81115: LD_EXP 80
81119: PUSH
81120: LD_VAR 0 3
81124: ARRAY
81125: PPUSH
81126: LD_INT 1
81128: PPUSH
81129: LD_VAR 0 9
81133: PPUSH
81134: CALL_OW 2
81138: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
81139: LD_ADDR_EXP 80
81143: PUSH
81144: LD_EXP 80
81148: PPUSH
81149: LD_VAR 0 3
81153: PPUSH
81154: LD_VAR 0 7
81158: PPUSH
81159: CALL_OW 1
81163: ST_TO_ADDR
// end else
81164: GO 81183
// MC_InsertProduceList ( i , [ components ] ) ;
81166: LD_VAR 0 3
81170: PPUSH
81171: LD_VAR 0 9
81175: PUSH
81176: EMPTY
81177: LIST
81178: PPUSH
81179: CALL 77133 0 2
// break ;
81183: GO 81187
// end ; end ;
81185: GO 80972
81187: POP
81188: POP
// end ; end ; if GetType ( un ) = unit_building then
81189: LD_VAR 0 1
81193: PPUSH
81194: CALL_OW 247
81198: PUSH
81199: LD_INT 3
81201: EQUAL
81202: IFFALSE 81605
// begin btype := GetBType ( un ) ;
81204: LD_ADDR_VAR 0 5
81208: PUSH
81209: LD_VAR 0 1
81213: PPUSH
81214: CALL_OW 266
81218: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81219: LD_VAR 0 5
81223: PUSH
81224: LD_INT 29
81226: PUSH
81227: LD_INT 30
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: IN
81234: IFFALSE 81307
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81236: LD_VAR 0 1
81240: PPUSH
81241: CALL_OW 250
81245: PPUSH
81246: LD_VAR 0 1
81250: PPUSH
81251: CALL_OW 251
81255: PPUSH
81256: LD_VAR 0 1
81260: PPUSH
81261: CALL_OW 255
81265: PPUSH
81266: CALL_OW 440
81270: NOT
81271: IFFALSE 81307
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81273: LD_VAR 0 1
81277: PPUSH
81278: CALL_OW 250
81282: PPUSH
81283: LD_VAR 0 1
81287: PPUSH
81288: CALL_OW 251
81292: PPUSH
81293: LD_VAR 0 1
81297: PPUSH
81298: CALL_OW 255
81302: PPUSH
81303: CALL_OW 441
// end ; if btype = b_warehouse then
81307: LD_VAR 0 5
81311: PUSH
81312: LD_INT 1
81314: EQUAL
81315: IFFALSE 81333
// begin btype := b_depot ;
81317: LD_ADDR_VAR 0 5
81321: PUSH
81322: LD_INT 0
81324: ST_TO_ADDR
// pos := 1 ;
81325: LD_ADDR_VAR 0 6
81329: PUSH
81330: LD_INT 1
81332: ST_TO_ADDR
// end ; if btype = b_factory then
81333: LD_VAR 0 5
81337: PUSH
81338: LD_INT 3
81340: EQUAL
81341: IFFALSE 81359
// begin btype := b_workshop ;
81343: LD_ADDR_VAR 0 5
81347: PUSH
81348: LD_INT 2
81350: ST_TO_ADDR
// pos := 1 ;
81351: LD_ADDR_VAR 0 6
81355: PUSH
81356: LD_INT 1
81358: ST_TO_ADDR
// end ; if btype = b_barracks then
81359: LD_VAR 0 5
81363: PUSH
81364: LD_INT 5
81366: EQUAL
81367: IFFALSE 81377
// btype := b_armoury ;
81369: LD_ADDR_VAR 0 5
81373: PUSH
81374: LD_INT 4
81376: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81377: LD_VAR 0 5
81381: PUSH
81382: LD_INT 7
81384: PUSH
81385: LD_INT 8
81387: PUSH
81388: EMPTY
81389: LIST
81390: LIST
81391: IN
81392: IFFALSE 81402
// btype := b_lab ;
81394: LD_ADDR_VAR 0 5
81398: PUSH
81399: LD_INT 6
81401: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81402: LD_ADDR_EXP 64
81406: PUSH
81407: LD_EXP 64
81411: PPUSH
81412: LD_VAR 0 3
81416: PUSH
81417: LD_EXP 64
81421: PUSH
81422: LD_VAR 0 3
81426: ARRAY
81427: PUSH
81428: LD_INT 1
81430: PLUS
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PPUSH
81436: LD_VAR 0 5
81440: PUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: CALL_OW 250
81450: PUSH
81451: LD_VAR 0 1
81455: PPUSH
81456: CALL_OW 251
81460: PUSH
81461: LD_VAR 0 1
81465: PPUSH
81466: CALL_OW 254
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: PPUSH
81477: CALL 19726 0 3
81481: ST_TO_ADDR
// if pos = 1 then
81482: LD_VAR 0 6
81486: PUSH
81487: LD_INT 1
81489: EQUAL
81490: IFFALSE 81605
// begin tmp := mc_build_list [ i ] ;
81492: LD_ADDR_VAR 0 7
81496: PUSH
81497: LD_EXP 64
81501: PUSH
81502: LD_VAR 0 3
81506: ARRAY
81507: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81508: LD_VAR 0 7
81512: PPUSH
81513: LD_INT 2
81515: PUSH
81516: LD_INT 30
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 30
81528: PUSH
81529: LD_INT 1
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: LIST
81540: PPUSH
81541: CALL_OW 72
81545: IFFALSE 81555
// pos := 2 ;
81547: LD_ADDR_VAR 0 6
81551: PUSH
81552: LD_INT 2
81554: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81555: LD_ADDR_VAR 0 7
81559: PUSH
81560: LD_VAR 0 7
81564: PPUSH
81565: LD_VAR 0 6
81569: PPUSH
81570: LD_VAR 0 7
81574: PPUSH
81575: CALL 20052 0 3
81579: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81580: LD_ADDR_EXP 64
81584: PUSH
81585: LD_EXP 64
81589: PPUSH
81590: LD_VAR 0 3
81594: PPUSH
81595: LD_VAR 0 7
81599: PPUSH
81600: CALL_OW 1
81604: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81605: LD_VAR 0 1
81609: PUSH
81610: LD_EXP 59
81614: PUSH
81615: LD_VAR 0 3
81619: ARRAY
81620: IN
81621: IFFALSE 81660
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81623: LD_ADDR_EXP 59
81627: PUSH
81628: LD_EXP 59
81632: PPUSH
81633: LD_VAR 0 3
81637: PPUSH
81638: LD_EXP 59
81642: PUSH
81643: LD_VAR 0 3
81647: ARRAY
81648: PUSH
81649: LD_VAR 0 1
81653: DIFF
81654: PPUSH
81655: CALL_OW 1
81659: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81660: LD_VAR 0 1
81664: PUSH
81665: LD_EXP 66
81669: PUSH
81670: LD_VAR 0 3
81674: ARRAY
81675: IN
81676: IFFALSE 81715
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81678: LD_ADDR_EXP 66
81682: PUSH
81683: LD_EXP 66
81687: PPUSH
81688: LD_VAR 0 3
81692: PPUSH
81693: LD_EXP 66
81697: PUSH
81698: LD_VAR 0 3
81702: ARRAY
81703: PUSH
81704: LD_VAR 0 1
81708: DIFF
81709: PPUSH
81710: CALL_OW 1
81714: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81715: LD_VAR 0 1
81719: PUSH
81720: LD_EXP 78
81724: PUSH
81725: LD_VAR 0 3
81729: ARRAY
81730: IN
81731: IFFALSE 81770
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81733: LD_ADDR_EXP 78
81737: PUSH
81738: LD_EXP 78
81742: PPUSH
81743: LD_VAR 0 3
81747: PPUSH
81748: LD_EXP 78
81752: PUSH
81753: LD_VAR 0 3
81757: ARRAY
81758: PUSH
81759: LD_VAR 0 1
81763: DIFF
81764: PPUSH
81765: CALL_OW 1
81769: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81770: LD_VAR 0 1
81774: PUSH
81775: LD_EXP 81
81779: PUSH
81780: LD_VAR 0 3
81784: ARRAY
81785: IN
81786: IFFALSE 81825
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81788: LD_ADDR_EXP 81
81792: PUSH
81793: LD_EXP 81
81797: PPUSH
81798: LD_VAR 0 3
81802: PPUSH
81803: LD_EXP 81
81807: PUSH
81808: LD_VAR 0 3
81812: ARRAY
81813: PUSH
81814: LD_VAR 0 1
81818: DIFF
81819: PPUSH
81820: CALL_OW 1
81824: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81825: LD_VAR 0 1
81829: PUSH
81830: LD_EXP 68
81834: PUSH
81835: LD_VAR 0 3
81839: ARRAY
81840: IN
81841: IFFALSE 81880
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81843: LD_ADDR_EXP 68
81847: PUSH
81848: LD_EXP 68
81852: PPUSH
81853: LD_VAR 0 3
81857: PPUSH
81858: LD_EXP 68
81862: PUSH
81863: LD_VAR 0 3
81867: ARRAY
81868: PUSH
81869: LD_VAR 0 1
81873: DIFF
81874: PPUSH
81875: CALL_OW 1
81879: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81880: LD_VAR 0 1
81884: PUSH
81885: LD_EXP 67
81889: PUSH
81890: LD_VAR 0 3
81894: ARRAY
81895: IN
81896: IFFALSE 81935
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81898: LD_ADDR_EXP 67
81902: PUSH
81903: LD_EXP 67
81907: PPUSH
81908: LD_VAR 0 3
81912: PPUSH
81913: LD_EXP 67
81917: PUSH
81918: LD_VAR 0 3
81922: ARRAY
81923: PUSH
81924: LD_VAR 0 1
81928: DIFF
81929: PPUSH
81930: CALL_OW 1
81934: ST_TO_ADDR
// end ; break ;
81935: GO 81939
// end ;
81937: GO 80585
81939: POP
81940: POP
// end ;
81941: LD_VAR 0 2
81945: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81946: LD_INT 0
81948: PPUSH
81949: PPUSH
81950: PPUSH
// if not mc_bases or not skirmish then
81951: LD_EXP 59
81955: NOT
81956: PUSH
81957: LD_EXP 57
81961: NOT
81962: OR
81963: IFFALSE 81967
// exit ;
81965: GO 82182
// for i = 1 to mc_bases do
81967: LD_ADDR_VAR 0 3
81971: PUSH
81972: DOUBLE
81973: LD_INT 1
81975: DEC
81976: ST_TO_ADDR
81977: LD_EXP 59
81981: PUSH
81982: FOR_TO
81983: IFFALSE 82180
// begin if building in mc_construct_list [ i ] then
81985: LD_VAR 0 1
81989: PUSH
81990: LD_EXP 66
81994: PUSH
81995: LD_VAR 0 3
81999: ARRAY
82000: IN
82001: IFFALSE 82178
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82003: LD_ADDR_EXP 66
82007: PUSH
82008: LD_EXP 66
82012: PPUSH
82013: LD_VAR 0 3
82017: PPUSH
82018: LD_EXP 66
82022: PUSH
82023: LD_VAR 0 3
82027: ARRAY
82028: PUSH
82029: LD_VAR 0 1
82033: DIFF
82034: PPUSH
82035: CALL_OW 1
82039: ST_TO_ADDR
// if building in mc_lab [ i ] then
82040: LD_VAR 0 1
82044: PUSH
82045: LD_EXP 92
82049: PUSH
82050: LD_VAR 0 3
82054: ARRAY
82055: IN
82056: IFFALSE 82111
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82058: LD_ADDR_EXP 93
82062: PUSH
82063: LD_EXP 93
82067: PPUSH
82068: LD_VAR 0 3
82072: PPUSH
82073: LD_EXP 93
82077: PUSH
82078: LD_VAR 0 3
82082: ARRAY
82083: PPUSH
82084: LD_INT 1
82086: PPUSH
82087: LD_EXP 93
82091: PUSH
82092: LD_VAR 0 3
82096: ARRAY
82097: PPUSH
82098: LD_INT 0
82100: PPUSH
82101: CALL 19144 0 4
82105: PPUSH
82106: CALL_OW 1
82110: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82111: LD_VAR 0 1
82115: PUSH
82116: LD_EXP 59
82120: PUSH
82121: LD_VAR 0 3
82125: ARRAY
82126: IN
82127: NOT
82128: IFFALSE 82174
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82130: LD_ADDR_EXP 59
82134: PUSH
82135: LD_EXP 59
82139: PPUSH
82140: LD_VAR 0 3
82144: PUSH
82145: LD_EXP 59
82149: PUSH
82150: LD_VAR 0 3
82154: ARRAY
82155: PUSH
82156: LD_INT 1
82158: PLUS
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PPUSH
82164: LD_VAR 0 1
82168: PPUSH
82169: CALL 19726 0 3
82173: ST_TO_ADDR
// exit ;
82174: POP
82175: POP
82176: GO 82182
// end ; end ;
82178: GO 81982
82180: POP
82181: POP
// end ;
82182: LD_VAR 0 2
82186: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82187: LD_INT 0
82189: PPUSH
82190: PPUSH
82191: PPUSH
82192: PPUSH
82193: PPUSH
82194: PPUSH
82195: PPUSH
// if not mc_bases or not skirmish then
82196: LD_EXP 59
82200: NOT
82201: PUSH
82202: LD_EXP 57
82206: NOT
82207: OR
82208: IFFALSE 82212
// exit ;
82210: GO 82873
// for i = 1 to mc_bases do
82212: LD_ADDR_VAR 0 3
82216: PUSH
82217: DOUBLE
82218: LD_INT 1
82220: DEC
82221: ST_TO_ADDR
82222: LD_EXP 59
82226: PUSH
82227: FOR_TO
82228: IFFALSE 82871
// begin if building in mc_construct_list [ i ] then
82230: LD_VAR 0 1
82234: PUSH
82235: LD_EXP 66
82239: PUSH
82240: LD_VAR 0 3
82244: ARRAY
82245: IN
82246: IFFALSE 82869
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82248: LD_ADDR_EXP 66
82252: PUSH
82253: LD_EXP 66
82257: PPUSH
82258: LD_VAR 0 3
82262: PPUSH
82263: LD_EXP 66
82267: PUSH
82268: LD_VAR 0 3
82272: ARRAY
82273: PUSH
82274: LD_VAR 0 1
82278: DIFF
82279: PPUSH
82280: CALL_OW 1
82284: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82285: LD_ADDR_EXP 59
82289: PUSH
82290: LD_EXP 59
82294: PPUSH
82295: LD_VAR 0 3
82299: PUSH
82300: LD_EXP 59
82304: PUSH
82305: LD_VAR 0 3
82309: ARRAY
82310: PUSH
82311: LD_INT 1
82313: PLUS
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PPUSH
82319: LD_VAR 0 1
82323: PPUSH
82324: CALL 19726 0 3
82328: ST_TO_ADDR
// btype := GetBType ( building ) ;
82329: LD_ADDR_VAR 0 5
82333: PUSH
82334: LD_VAR 0 1
82338: PPUSH
82339: CALL_OW 266
82343: ST_TO_ADDR
// side := GetSide ( building ) ;
82344: LD_ADDR_VAR 0 8
82348: PUSH
82349: LD_VAR 0 1
82353: PPUSH
82354: CALL_OW 255
82358: ST_TO_ADDR
// if btype = b_lab then
82359: LD_VAR 0 5
82363: PUSH
82364: LD_INT 6
82366: EQUAL
82367: IFFALSE 82417
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82369: LD_ADDR_EXP 92
82373: PUSH
82374: LD_EXP 92
82378: PPUSH
82379: LD_VAR 0 3
82383: PUSH
82384: LD_EXP 92
82388: PUSH
82389: LD_VAR 0 3
82393: ARRAY
82394: PUSH
82395: LD_INT 1
82397: PLUS
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PPUSH
82403: LD_VAR 0 1
82407: PPUSH
82408: CALL 19726 0 3
82412: ST_TO_ADDR
// exit ;
82413: POP
82414: POP
82415: GO 82873
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82417: LD_VAR 0 5
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 2
82427: PUSH
82428: LD_INT 4
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: LIST
82435: IN
82436: IFFALSE 82560
// begin if btype = b_armoury then
82438: LD_VAR 0 5
82442: PUSH
82443: LD_INT 4
82445: EQUAL
82446: IFFALSE 82456
// btype := b_barracks ;
82448: LD_ADDR_VAR 0 5
82452: PUSH
82453: LD_INT 5
82455: ST_TO_ADDR
// if btype = b_depot then
82456: LD_VAR 0 5
82460: PUSH
82461: LD_INT 0
82463: EQUAL
82464: IFFALSE 82474
// btype := b_warehouse ;
82466: LD_ADDR_VAR 0 5
82470: PUSH
82471: LD_INT 1
82473: ST_TO_ADDR
// if btype = b_workshop then
82474: LD_VAR 0 5
82478: PUSH
82479: LD_INT 2
82481: EQUAL
82482: IFFALSE 82492
// btype := b_factory ;
82484: LD_ADDR_VAR 0 5
82488: PUSH
82489: LD_INT 3
82491: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82492: LD_VAR 0 5
82496: PPUSH
82497: LD_VAR 0 8
82501: PPUSH
82502: CALL_OW 323
82506: PUSH
82507: LD_INT 1
82509: EQUAL
82510: IFFALSE 82556
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82512: LD_ADDR_EXP 91
82516: PUSH
82517: LD_EXP 91
82521: PPUSH
82522: LD_VAR 0 3
82526: PUSH
82527: LD_EXP 91
82531: PUSH
82532: LD_VAR 0 3
82536: ARRAY
82537: PUSH
82538: LD_INT 1
82540: PLUS
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PPUSH
82546: LD_VAR 0 1
82550: PPUSH
82551: CALL 19726 0 3
82555: ST_TO_ADDR
// exit ;
82556: POP
82557: POP
82558: GO 82873
// end ; if btype in [ b_bunker , b_turret ] then
82560: LD_VAR 0 5
82564: PUSH
82565: LD_INT 32
82567: PUSH
82568: LD_INT 33
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: IN
82575: IFFALSE 82865
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82577: LD_ADDR_EXP 67
82581: PUSH
82582: LD_EXP 67
82586: PPUSH
82587: LD_VAR 0 3
82591: PUSH
82592: LD_EXP 67
82596: PUSH
82597: LD_VAR 0 3
82601: ARRAY
82602: PUSH
82603: LD_INT 1
82605: PLUS
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PPUSH
82611: LD_VAR 0 1
82615: PPUSH
82616: CALL 19726 0 3
82620: ST_TO_ADDR
// if btype = b_bunker then
82621: LD_VAR 0 5
82625: PUSH
82626: LD_INT 32
82628: EQUAL
82629: IFFALSE 82865
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82631: LD_ADDR_EXP 68
82635: PUSH
82636: LD_EXP 68
82640: PPUSH
82641: LD_VAR 0 3
82645: PUSH
82646: LD_EXP 68
82650: PUSH
82651: LD_VAR 0 3
82655: ARRAY
82656: PUSH
82657: LD_INT 1
82659: PLUS
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PPUSH
82665: LD_VAR 0 1
82669: PPUSH
82670: CALL 19726 0 3
82674: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82675: LD_ADDR_VAR 0 6
82679: PUSH
82680: LD_EXP 59
82684: PUSH
82685: LD_VAR 0 3
82689: ARRAY
82690: PPUSH
82691: LD_INT 25
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 3
82703: PUSH
82704: LD_INT 54
82706: PUSH
82707: EMPTY
82708: LIST
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PPUSH
82718: CALL_OW 72
82722: ST_TO_ADDR
// if tmp then
82723: LD_VAR 0 6
82727: IFFALSE 82733
// exit ;
82729: POP
82730: POP
82731: GO 82873
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82733: LD_ADDR_VAR 0 6
82737: PUSH
82738: LD_EXP 59
82742: PUSH
82743: LD_VAR 0 3
82747: ARRAY
82748: PPUSH
82749: LD_INT 2
82751: PUSH
82752: LD_INT 30
82754: PUSH
82755: LD_INT 4
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 30
82764: PUSH
82765: LD_INT 5
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: LIST
82776: PPUSH
82777: CALL_OW 72
82781: ST_TO_ADDR
// if not tmp then
82782: LD_VAR 0 6
82786: NOT
82787: IFFALSE 82793
// exit ;
82789: POP
82790: POP
82791: GO 82873
// for j in tmp do
82793: LD_ADDR_VAR 0 4
82797: PUSH
82798: LD_VAR 0 6
82802: PUSH
82803: FOR_IN
82804: IFFALSE 82863
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82806: LD_ADDR_VAR 0 7
82810: PUSH
82811: LD_VAR 0 4
82815: PPUSH
82816: CALL_OW 313
82820: PPUSH
82821: LD_INT 25
82823: PUSH
82824: LD_INT 1
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PPUSH
82831: CALL_OW 72
82835: ST_TO_ADDR
// if units then
82836: LD_VAR 0 7
82840: IFFALSE 82861
// begin ComExitBuilding ( units [ 1 ] ) ;
82842: LD_VAR 0 7
82846: PUSH
82847: LD_INT 1
82849: ARRAY
82850: PPUSH
82851: CALL_OW 122
// exit ;
82855: POP
82856: POP
82857: POP
82858: POP
82859: GO 82873
// end ; end ;
82861: GO 82803
82863: POP
82864: POP
// end ; end ; exit ;
82865: POP
82866: POP
82867: GO 82873
// end ; end ;
82869: GO 82227
82871: POP
82872: POP
// end ;
82873: LD_VAR 0 2
82877: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82878: LD_INT 0
82880: PPUSH
82881: PPUSH
82882: PPUSH
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
// if not mc_bases or not skirmish then
82887: LD_EXP 59
82891: NOT
82892: PUSH
82893: LD_EXP 57
82897: NOT
82898: OR
82899: IFFALSE 82903
// exit ;
82901: GO 83168
// btype := GetBType ( building ) ;
82903: LD_ADDR_VAR 0 6
82907: PUSH
82908: LD_VAR 0 1
82912: PPUSH
82913: CALL_OW 266
82917: ST_TO_ADDR
// x := GetX ( building ) ;
82918: LD_ADDR_VAR 0 7
82922: PUSH
82923: LD_VAR 0 1
82927: PPUSH
82928: CALL_OW 250
82932: ST_TO_ADDR
// y := GetY ( building ) ;
82933: LD_ADDR_VAR 0 8
82937: PUSH
82938: LD_VAR 0 1
82942: PPUSH
82943: CALL_OW 251
82947: ST_TO_ADDR
// d := GetDir ( building ) ;
82948: LD_ADDR_VAR 0 9
82952: PUSH
82953: LD_VAR 0 1
82957: PPUSH
82958: CALL_OW 254
82962: ST_TO_ADDR
// for i = 1 to mc_bases do
82963: LD_ADDR_VAR 0 4
82967: PUSH
82968: DOUBLE
82969: LD_INT 1
82971: DEC
82972: ST_TO_ADDR
82973: LD_EXP 59
82977: PUSH
82978: FOR_TO
82979: IFFALSE 83166
// begin if not mc_build_list [ i ] then
82981: LD_EXP 64
82985: PUSH
82986: LD_VAR 0 4
82990: ARRAY
82991: NOT
82992: IFFALSE 82996
// continue ;
82994: GO 82978
// for j := 1 to mc_build_list [ i ] do
82996: LD_ADDR_VAR 0 5
83000: PUSH
83001: DOUBLE
83002: LD_INT 1
83004: DEC
83005: ST_TO_ADDR
83006: LD_EXP 64
83010: PUSH
83011: LD_VAR 0 4
83015: ARRAY
83016: PUSH
83017: FOR_TO
83018: IFFALSE 83162
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
83020: LD_VAR 0 6
83024: PUSH
83025: LD_VAR 0 7
83029: PUSH
83030: LD_VAR 0 8
83034: PUSH
83035: LD_VAR 0 9
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: PPUSH
83046: LD_EXP 64
83050: PUSH
83051: LD_VAR 0 4
83055: ARRAY
83056: PUSH
83057: LD_VAR 0 5
83061: ARRAY
83062: PPUSH
83063: CALL 25909 0 2
83067: IFFALSE 83160
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
83069: LD_ADDR_EXP 64
83073: PUSH
83074: LD_EXP 64
83078: PPUSH
83079: LD_VAR 0 4
83083: PPUSH
83084: LD_EXP 64
83088: PUSH
83089: LD_VAR 0 4
83093: ARRAY
83094: PPUSH
83095: LD_VAR 0 5
83099: PPUSH
83100: CALL_OW 3
83104: PPUSH
83105: CALL_OW 1
83109: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83110: LD_ADDR_EXP 66
83114: PUSH
83115: LD_EXP 66
83119: PPUSH
83120: LD_VAR 0 4
83124: PUSH
83125: LD_EXP 66
83129: PUSH
83130: LD_VAR 0 4
83134: ARRAY
83135: PUSH
83136: LD_INT 1
83138: PLUS
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PPUSH
83144: LD_VAR 0 1
83148: PPUSH
83149: CALL 19726 0 3
83153: ST_TO_ADDR
// exit ;
83154: POP
83155: POP
83156: POP
83157: POP
83158: GO 83168
// end ;
83160: GO 83017
83162: POP
83163: POP
// end ;
83164: GO 82978
83166: POP
83167: POP
// end ;
83168: LD_VAR 0 3
83172: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83173: LD_INT 0
83175: PPUSH
83176: PPUSH
83177: PPUSH
// if not mc_bases or not skirmish then
83178: LD_EXP 59
83182: NOT
83183: PUSH
83184: LD_EXP 57
83188: NOT
83189: OR
83190: IFFALSE 83194
// exit ;
83192: GO 83384
// for i = 1 to mc_bases do
83194: LD_ADDR_VAR 0 4
83198: PUSH
83199: DOUBLE
83200: LD_INT 1
83202: DEC
83203: ST_TO_ADDR
83204: LD_EXP 59
83208: PUSH
83209: FOR_TO
83210: IFFALSE 83297
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83212: LD_VAR 0 1
83216: PUSH
83217: LD_EXP 67
83221: PUSH
83222: LD_VAR 0 4
83226: ARRAY
83227: IN
83228: PUSH
83229: LD_VAR 0 1
83233: PUSH
83234: LD_EXP 68
83238: PUSH
83239: LD_VAR 0 4
83243: ARRAY
83244: IN
83245: NOT
83246: AND
83247: IFFALSE 83295
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83249: LD_ADDR_EXP 68
83253: PUSH
83254: LD_EXP 68
83258: PPUSH
83259: LD_VAR 0 4
83263: PUSH
83264: LD_EXP 68
83268: PUSH
83269: LD_VAR 0 4
83273: ARRAY
83274: PUSH
83275: LD_INT 1
83277: PLUS
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PPUSH
83283: LD_VAR 0 1
83287: PPUSH
83288: CALL 19726 0 3
83292: ST_TO_ADDR
// break ;
83293: GO 83297
// end ; end ;
83295: GO 83209
83297: POP
83298: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83299: LD_VAR 0 1
83303: PPUSH
83304: CALL_OW 257
83308: PUSH
83309: LD_EXP 85
83313: IN
83314: PUSH
83315: LD_VAR 0 1
83319: PPUSH
83320: CALL_OW 266
83324: PUSH
83325: LD_INT 5
83327: EQUAL
83328: AND
83329: PUSH
83330: LD_VAR 0 2
83334: PPUSH
83335: CALL_OW 110
83339: PUSH
83340: LD_INT 18
83342: NONEQUAL
83343: AND
83344: IFFALSE 83384
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83346: LD_VAR 0 2
83350: PPUSH
83351: CALL_OW 257
83355: PUSH
83356: LD_INT 5
83358: PUSH
83359: LD_INT 8
83361: PUSH
83362: LD_INT 9
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: LIST
83369: IN
83370: IFFALSE 83384
// SetClass ( unit , 1 ) ;
83372: LD_VAR 0 2
83376: PPUSH
83377: LD_INT 1
83379: PPUSH
83380: CALL_OW 336
// end ;
83384: LD_VAR 0 3
83388: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83389: LD_INT 0
83391: PPUSH
83392: PPUSH
// if not mc_bases or not skirmish then
83393: LD_EXP 59
83397: NOT
83398: PUSH
83399: LD_EXP 57
83403: NOT
83404: OR
83405: IFFALSE 83409
// exit ;
83407: GO 83525
// if GetLives ( abandoned_vehicle ) > 250 then
83409: LD_VAR 0 2
83413: PPUSH
83414: CALL_OW 256
83418: PUSH
83419: LD_INT 250
83421: GREATER
83422: IFFALSE 83426
// exit ;
83424: GO 83525
// for i = 1 to mc_bases do
83426: LD_ADDR_VAR 0 6
83430: PUSH
83431: DOUBLE
83432: LD_INT 1
83434: DEC
83435: ST_TO_ADDR
83436: LD_EXP 59
83440: PUSH
83441: FOR_TO
83442: IFFALSE 83523
// begin if driver in mc_bases [ i ] then
83444: LD_VAR 0 1
83448: PUSH
83449: LD_EXP 59
83453: PUSH
83454: LD_VAR 0 6
83458: ARRAY
83459: IN
83460: IFFALSE 83521
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83462: LD_VAR 0 1
83466: PPUSH
83467: LD_EXP 59
83471: PUSH
83472: LD_VAR 0 6
83476: ARRAY
83477: PPUSH
83478: LD_INT 2
83480: PUSH
83481: LD_INT 30
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 30
83493: PUSH
83494: LD_INT 1
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: LIST
83505: PPUSH
83506: CALL_OW 72
83510: PUSH
83511: LD_INT 1
83513: ARRAY
83514: PPUSH
83515: CALL 52345 0 2
// break ;
83519: GO 83523
// end ; end ;
83521: GO 83441
83523: POP
83524: POP
// end ; end_of_file
83525: LD_VAR 0 5
83529: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
83530: LD_INT 0
83532: PPUSH
// ar_miner := 81 ;
83533: LD_ADDR_EXP 110
83537: PUSH
83538: LD_INT 81
83540: ST_TO_ADDR
// ar_crane := 88 ;
83541: LD_ADDR_EXP 109
83545: PUSH
83546: LD_INT 88
83548: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83549: LD_ADDR_EXP 104
83553: PUSH
83554: LD_INT 89
83556: ST_TO_ADDR
// us_hack := 99 ;
83557: LD_ADDR_EXP 105
83561: PUSH
83562: LD_INT 99
83564: ST_TO_ADDR
// us_artillery := 97 ;
83565: LD_ADDR_EXP 106
83569: PUSH
83570: LD_INT 97
83572: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83573: LD_ADDR_EXP 107
83577: PUSH
83578: LD_INT 91
83580: ST_TO_ADDR
// ar_mortar := 92 ;
83581: LD_ADDR_EXP 108
83585: PUSH
83586: LD_INT 92
83588: ST_TO_ADDR
// ru_radar := 98 ;
83589: LD_ADDR_EXP 103
83593: PUSH
83594: LD_INT 98
83596: ST_TO_ADDR
// tech_Artillery := 80 ;
83597: LD_ADDR_EXP 111
83601: PUSH
83602: LD_INT 80
83604: ST_TO_ADDR
// tech_RadMat := 81 ;
83605: LD_ADDR_EXP 112
83609: PUSH
83610: LD_INT 81
83612: ST_TO_ADDR
// tech_BasicTools := 82 ;
83613: LD_ADDR_EXP 113
83617: PUSH
83618: LD_INT 82
83620: ST_TO_ADDR
// tech_Cargo := 83 ;
83621: LD_ADDR_EXP 114
83625: PUSH
83626: LD_INT 83
83628: ST_TO_ADDR
// tech_Track := 84 ;
83629: LD_ADDR_EXP 115
83633: PUSH
83634: LD_INT 84
83636: ST_TO_ADDR
// tech_Crane := 85 ;
83637: LD_ADDR_EXP 116
83641: PUSH
83642: LD_INT 85
83644: ST_TO_ADDR
// tech_Bulldozer := 86 ;
83645: LD_ADDR_EXP 117
83649: PUSH
83650: LD_INT 86
83652: ST_TO_ADDR
// tech_Hovercraft := 87 ;
83653: LD_ADDR_EXP 118
83657: PUSH
83658: LD_INT 87
83660: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
83661: LD_ADDR_EXP 119
83665: PUSH
83666: LD_INT 88
83668: ST_TO_ADDR
// class_mastodont := 31 ;
83669: LD_ADDR_EXP 120
83673: PUSH
83674: LD_INT 31
83676: ST_TO_ADDR
// class_horse := 21 ;
83677: LD_ADDR_EXP 121
83681: PUSH
83682: LD_INT 21
83684: ST_TO_ADDR
// end ;
83685: LD_VAR 0 1
83689: RET
// every 1 do
83690: GO 83692
83692: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
83693: CALL 83530 0 0
83697: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
83698: LD_INT 0
83700: PPUSH
// if p2 = 100 then
83701: LD_VAR 0 2
83705: PUSH
83706: LD_INT 100
83708: EQUAL
83709: IFFALSE 84658
// begin if not StreamModeActive then
83711: LD_EXP 122
83715: NOT
83716: IFFALSE 83726
// StreamModeActive := true ;
83718: LD_ADDR_EXP 122
83722: PUSH
83723: LD_INT 1
83725: ST_TO_ADDR
// if p3 = 0 then
83726: LD_VAR 0 3
83730: PUSH
83731: LD_INT 0
83733: EQUAL
83734: IFFALSE 83740
// InitStreamMode ;
83736: CALL 84818 0 0
// if p3 = 1 then
83740: LD_VAR 0 3
83744: PUSH
83745: LD_INT 1
83747: EQUAL
83748: IFFALSE 83758
// sRocket := true ;
83750: LD_ADDR_EXP 127
83754: PUSH
83755: LD_INT 1
83757: ST_TO_ADDR
// if p3 = 2 then
83758: LD_VAR 0 3
83762: PUSH
83763: LD_INT 2
83765: EQUAL
83766: IFFALSE 83776
// sSpeed := true ;
83768: LD_ADDR_EXP 126
83772: PUSH
83773: LD_INT 1
83775: ST_TO_ADDR
// if p3 = 3 then
83776: LD_VAR 0 3
83780: PUSH
83781: LD_INT 3
83783: EQUAL
83784: IFFALSE 83794
// sEngine := true ;
83786: LD_ADDR_EXP 128
83790: PUSH
83791: LD_INT 1
83793: ST_TO_ADDR
// if p3 = 4 then
83794: LD_VAR 0 3
83798: PUSH
83799: LD_INT 4
83801: EQUAL
83802: IFFALSE 83812
// sSpec := true ;
83804: LD_ADDR_EXP 125
83808: PUSH
83809: LD_INT 1
83811: ST_TO_ADDR
// if p3 = 5 then
83812: LD_VAR 0 3
83816: PUSH
83817: LD_INT 5
83819: EQUAL
83820: IFFALSE 83830
// sLevel := true ;
83822: LD_ADDR_EXP 129
83826: PUSH
83827: LD_INT 1
83829: ST_TO_ADDR
// if p3 = 6 then
83830: LD_VAR 0 3
83834: PUSH
83835: LD_INT 6
83837: EQUAL
83838: IFFALSE 83848
// sArmoury := true ;
83840: LD_ADDR_EXP 130
83844: PUSH
83845: LD_INT 1
83847: ST_TO_ADDR
// if p3 = 7 then
83848: LD_VAR 0 3
83852: PUSH
83853: LD_INT 7
83855: EQUAL
83856: IFFALSE 83866
// sRadar := true ;
83858: LD_ADDR_EXP 131
83862: PUSH
83863: LD_INT 1
83865: ST_TO_ADDR
// if p3 = 8 then
83866: LD_VAR 0 3
83870: PUSH
83871: LD_INT 8
83873: EQUAL
83874: IFFALSE 83884
// sBunker := true ;
83876: LD_ADDR_EXP 132
83880: PUSH
83881: LD_INT 1
83883: ST_TO_ADDR
// if p3 = 9 then
83884: LD_VAR 0 3
83888: PUSH
83889: LD_INT 9
83891: EQUAL
83892: IFFALSE 83902
// sHack := true ;
83894: LD_ADDR_EXP 133
83898: PUSH
83899: LD_INT 1
83901: ST_TO_ADDR
// if p3 = 10 then
83902: LD_VAR 0 3
83906: PUSH
83907: LD_INT 10
83909: EQUAL
83910: IFFALSE 83920
// sFire := true ;
83912: LD_ADDR_EXP 134
83916: PUSH
83917: LD_INT 1
83919: ST_TO_ADDR
// if p3 = 11 then
83920: LD_VAR 0 3
83924: PUSH
83925: LD_INT 11
83927: EQUAL
83928: IFFALSE 83938
// sRefresh := true ;
83930: LD_ADDR_EXP 135
83934: PUSH
83935: LD_INT 1
83937: ST_TO_ADDR
// if p3 = 12 then
83938: LD_VAR 0 3
83942: PUSH
83943: LD_INT 12
83945: EQUAL
83946: IFFALSE 83956
// sExp := true ;
83948: LD_ADDR_EXP 136
83952: PUSH
83953: LD_INT 1
83955: ST_TO_ADDR
// if p3 = 13 then
83956: LD_VAR 0 3
83960: PUSH
83961: LD_INT 13
83963: EQUAL
83964: IFFALSE 83974
// sDepot := true ;
83966: LD_ADDR_EXP 137
83970: PUSH
83971: LD_INT 1
83973: ST_TO_ADDR
// if p3 = 14 then
83974: LD_VAR 0 3
83978: PUSH
83979: LD_INT 14
83981: EQUAL
83982: IFFALSE 83992
// sFlag := true ;
83984: LD_ADDR_EXP 138
83988: PUSH
83989: LD_INT 1
83991: ST_TO_ADDR
// if p3 = 15 then
83992: LD_VAR 0 3
83996: PUSH
83997: LD_INT 15
83999: EQUAL
84000: IFFALSE 84010
// sKamikadze := true ;
84002: LD_ADDR_EXP 146
84006: PUSH
84007: LD_INT 1
84009: ST_TO_ADDR
// if p3 = 16 then
84010: LD_VAR 0 3
84014: PUSH
84015: LD_INT 16
84017: EQUAL
84018: IFFALSE 84028
// sTroll := true ;
84020: LD_ADDR_EXP 147
84024: PUSH
84025: LD_INT 1
84027: ST_TO_ADDR
// if p3 = 17 then
84028: LD_VAR 0 3
84032: PUSH
84033: LD_INT 17
84035: EQUAL
84036: IFFALSE 84046
// sSlow := true ;
84038: LD_ADDR_EXP 148
84042: PUSH
84043: LD_INT 1
84045: ST_TO_ADDR
// if p3 = 18 then
84046: LD_VAR 0 3
84050: PUSH
84051: LD_INT 18
84053: EQUAL
84054: IFFALSE 84064
// sLack := true ;
84056: LD_ADDR_EXP 149
84060: PUSH
84061: LD_INT 1
84063: ST_TO_ADDR
// if p3 = 19 then
84064: LD_VAR 0 3
84068: PUSH
84069: LD_INT 19
84071: EQUAL
84072: IFFALSE 84082
// sTank := true ;
84074: LD_ADDR_EXP 151
84078: PUSH
84079: LD_INT 1
84081: ST_TO_ADDR
// if p3 = 20 then
84082: LD_VAR 0 3
84086: PUSH
84087: LD_INT 20
84089: EQUAL
84090: IFFALSE 84100
// sRemote := true ;
84092: LD_ADDR_EXP 152
84096: PUSH
84097: LD_INT 1
84099: ST_TO_ADDR
// if p3 = 21 then
84100: LD_VAR 0 3
84104: PUSH
84105: LD_INT 21
84107: EQUAL
84108: IFFALSE 84118
// sPowell := true ;
84110: LD_ADDR_EXP 153
84114: PUSH
84115: LD_INT 1
84117: ST_TO_ADDR
// if p3 = 22 then
84118: LD_VAR 0 3
84122: PUSH
84123: LD_INT 22
84125: EQUAL
84126: IFFALSE 84136
// sTeleport := true ;
84128: LD_ADDR_EXP 156
84132: PUSH
84133: LD_INT 1
84135: ST_TO_ADDR
// if p3 = 23 then
84136: LD_VAR 0 3
84140: PUSH
84141: LD_INT 23
84143: EQUAL
84144: IFFALSE 84154
// sOilTower := true ;
84146: LD_ADDR_EXP 158
84150: PUSH
84151: LD_INT 1
84153: ST_TO_ADDR
// if p3 = 24 then
84154: LD_VAR 0 3
84158: PUSH
84159: LD_INT 24
84161: EQUAL
84162: IFFALSE 84172
// sShovel := true ;
84164: LD_ADDR_EXP 159
84168: PUSH
84169: LD_INT 1
84171: ST_TO_ADDR
// if p3 = 25 then
84172: LD_VAR 0 3
84176: PUSH
84177: LD_INT 25
84179: EQUAL
84180: IFFALSE 84190
// sSheik := true ;
84182: LD_ADDR_EXP 160
84186: PUSH
84187: LD_INT 1
84189: ST_TO_ADDR
// if p3 = 26 then
84190: LD_VAR 0 3
84194: PUSH
84195: LD_INT 26
84197: EQUAL
84198: IFFALSE 84208
// sEarthquake := true ;
84200: LD_ADDR_EXP 162
84204: PUSH
84205: LD_INT 1
84207: ST_TO_ADDR
// if p3 = 27 then
84208: LD_VAR 0 3
84212: PUSH
84213: LD_INT 27
84215: EQUAL
84216: IFFALSE 84226
// sAI := true ;
84218: LD_ADDR_EXP 163
84222: PUSH
84223: LD_INT 1
84225: ST_TO_ADDR
// if p3 = 28 then
84226: LD_VAR 0 3
84230: PUSH
84231: LD_INT 28
84233: EQUAL
84234: IFFALSE 84244
// sCargo := true ;
84236: LD_ADDR_EXP 166
84240: PUSH
84241: LD_INT 1
84243: ST_TO_ADDR
// if p3 = 29 then
84244: LD_VAR 0 3
84248: PUSH
84249: LD_INT 29
84251: EQUAL
84252: IFFALSE 84262
// sDLaser := true ;
84254: LD_ADDR_EXP 167
84258: PUSH
84259: LD_INT 1
84261: ST_TO_ADDR
// if p3 = 30 then
84262: LD_VAR 0 3
84266: PUSH
84267: LD_INT 30
84269: EQUAL
84270: IFFALSE 84280
// sExchange := true ;
84272: LD_ADDR_EXP 168
84276: PUSH
84277: LD_INT 1
84279: ST_TO_ADDR
// if p3 = 31 then
84280: LD_VAR 0 3
84284: PUSH
84285: LD_INT 31
84287: EQUAL
84288: IFFALSE 84298
// sFac := true ;
84290: LD_ADDR_EXP 169
84294: PUSH
84295: LD_INT 1
84297: ST_TO_ADDR
// if p3 = 32 then
84298: LD_VAR 0 3
84302: PUSH
84303: LD_INT 32
84305: EQUAL
84306: IFFALSE 84316
// sPower := true ;
84308: LD_ADDR_EXP 170
84312: PUSH
84313: LD_INT 1
84315: ST_TO_ADDR
// if p3 = 33 then
84316: LD_VAR 0 3
84320: PUSH
84321: LD_INT 33
84323: EQUAL
84324: IFFALSE 84334
// sRandom := true ;
84326: LD_ADDR_EXP 171
84330: PUSH
84331: LD_INT 1
84333: ST_TO_ADDR
// if p3 = 34 then
84334: LD_VAR 0 3
84338: PUSH
84339: LD_INT 34
84341: EQUAL
84342: IFFALSE 84352
// sShield := true ;
84344: LD_ADDR_EXP 172
84348: PUSH
84349: LD_INT 1
84351: ST_TO_ADDR
// if p3 = 35 then
84352: LD_VAR 0 3
84356: PUSH
84357: LD_INT 35
84359: EQUAL
84360: IFFALSE 84370
// sTime := true ;
84362: LD_ADDR_EXP 173
84366: PUSH
84367: LD_INT 1
84369: ST_TO_ADDR
// if p3 = 36 then
84370: LD_VAR 0 3
84374: PUSH
84375: LD_INT 36
84377: EQUAL
84378: IFFALSE 84388
// sTools := true ;
84380: LD_ADDR_EXP 174
84384: PUSH
84385: LD_INT 1
84387: ST_TO_ADDR
// if p3 = 101 then
84388: LD_VAR 0 3
84392: PUSH
84393: LD_INT 101
84395: EQUAL
84396: IFFALSE 84406
// sSold := true ;
84398: LD_ADDR_EXP 139
84402: PUSH
84403: LD_INT 1
84405: ST_TO_ADDR
// if p3 = 102 then
84406: LD_VAR 0 3
84410: PUSH
84411: LD_INT 102
84413: EQUAL
84414: IFFALSE 84424
// sDiff := true ;
84416: LD_ADDR_EXP 140
84420: PUSH
84421: LD_INT 1
84423: ST_TO_ADDR
// if p3 = 103 then
84424: LD_VAR 0 3
84428: PUSH
84429: LD_INT 103
84431: EQUAL
84432: IFFALSE 84442
// sFog := true ;
84434: LD_ADDR_EXP 143
84438: PUSH
84439: LD_INT 1
84441: ST_TO_ADDR
// if p3 = 104 then
84442: LD_VAR 0 3
84446: PUSH
84447: LD_INT 104
84449: EQUAL
84450: IFFALSE 84460
// sReset := true ;
84452: LD_ADDR_EXP 144
84456: PUSH
84457: LD_INT 1
84459: ST_TO_ADDR
// if p3 = 105 then
84460: LD_VAR 0 3
84464: PUSH
84465: LD_INT 105
84467: EQUAL
84468: IFFALSE 84478
// sSun := true ;
84470: LD_ADDR_EXP 145
84474: PUSH
84475: LD_INT 1
84477: ST_TO_ADDR
// if p3 = 106 then
84478: LD_VAR 0 3
84482: PUSH
84483: LD_INT 106
84485: EQUAL
84486: IFFALSE 84496
// sTiger := true ;
84488: LD_ADDR_EXP 141
84492: PUSH
84493: LD_INT 1
84495: ST_TO_ADDR
// if p3 = 107 then
84496: LD_VAR 0 3
84500: PUSH
84501: LD_INT 107
84503: EQUAL
84504: IFFALSE 84514
// sBomb := true ;
84506: LD_ADDR_EXP 142
84510: PUSH
84511: LD_INT 1
84513: ST_TO_ADDR
// if p3 = 108 then
84514: LD_VAR 0 3
84518: PUSH
84519: LD_INT 108
84521: EQUAL
84522: IFFALSE 84532
// sWound := true ;
84524: LD_ADDR_EXP 150
84528: PUSH
84529: LD_INT 1
84531: ST_TO_ADDR
// if p3 = 109 then
84532: LD_VAR 0 3
84536: PUSH
84537: LD_INT 109
84539: EQUAL
84540: IFFALSE 84550
// sBetray := true ;
84542: LD_ADDR_EXP 154
84546: PUSH
84547: LD_INT 1
84549: ST_TO_ADDR
// if p3 = 110 then
84550: LD_VAR 0 3
84554: PUSH
84555: LD_INT 110
84557: EQUAL
84558: IFFALSE 84568
// sContamin := true ;
84560: LD_ADDR_EXP 155
84564: PUSH
84565: LD_INT 1
84567: ST_TO_ADDR
// if p3 = 111 then
84568: LD_VAR 0 3
84572: PUSH
84573: LD_INT 111
84575: EQUAL
84576: IFFALSE 84586
// sOil := true ;
84578: LD_ADDR_EXP 157
84582: PUSH
84583: LD_INT 1
84585: ST_TO_ADDR
// if p3 = 112 then
84586: LD_VAR 0 3
84590: PUSH
84591: LD_INT 112
84593: EQUAL
84594: IFFALSE 84604
// sStu := true ;
84596: LD_ADDR_EXP 161
84600: PUSH
84601: LD_INT 1
84603: ST_TO_ADDR
// if p3 = 113 then
84604: LD_VAR 0 3
84608: PUSH
84609: LD_INT 113
84611: EQUAL
84612: IFFALSE 84622
// sBazooka := true ;
84614: LD_ADDR_EXP 164
84618: PUSH
84619: LD_INT 1
84621: ST_TO_ADDR
// if p3 = 114 then
84622: LD_VAR 0 3
84626: PUSH
84627: LD_INT 114
84629: EQUAL
84630: IFFALSE 84640
// sMortar := true ;
84632: LD_ADDR_EXP 165
84636: PUSH
84637: LD_INT 1
84639: ST_TO_ADDR
// if p3 = 115 then
84640: LD_VAR 0 3
84644: PUSH
84645: LD_INT 115
84647: EQUAL
84648: IFFALSE 84658
// sRanger := true ;
84650: LD_ADDR_EXP 175
84654: PUSH
84655: LD_INT 1
84657: ST_TO_ADDR
// end ; if p2 = 101 then
84658: LD_VAR 0 2
84662: PUSH
84663: LD_INT 101
84665: EQUAL
84666: IFFALSE 84794
// begin case p3 of 1 :
84668: LD_VAR 0 3
84672: PUSH
84673: LD_INT 1
84675: DOUBLE
84676: EQUAL
84677: IFTRUE 84681
84679: GO 84688
84681: POP
// hHackUnlimitedResources ; 2 :
84682: CALL 95831 0 0
84686: GO 84794
84688: LD_INT 2
84690: DOUBLE
84691: EQUAL
84692: IFTRUE 84696
84694: GO 84703
84696: POP
// hHackSetLevel10 ; 3 :
84697: CALL 95964 0 0
84701: GO 84794
84703: LD_INT 3
84705: DOUBLE
84706: EQUAL
84707: IFTRUE 84711
84709: GO 84718
84711: POP
// hHackSetLevel10YourUnits ; 4 :
84712: CALL 96049 0 0
84716: GO 84794
84718: LD_INT 4
84720: DOUBLE
84721: EQUAL
84722: IFTRUE 84726
84724: GO 84733
84726: POP
// hHackInvincible ; 5 :
84727: CALL 96497 0 0
84731: GO 84794
84733: LD_INT 5
84735: DOUBLE
84736: EQUAL
84737: IFTRUE 84741
84739: GO 84748
84741: POP
// hHackInvisible ; 6 :
84742: CALL 96608 0 0
84746: GO 84794
84748: LD_INT 6
84750: DOUBLE
84751: EQUAL
84752: IFTRUE 84756
84754: GO 84763
84756: POP
// hHackChangeYourSide ; 7 :
84757: CALL 96665 0 0
84761: GO 84794
84763: LD_INT 7
84765: DOUBLE
84766: EQUAL
84767: IFTRUE 84771
84769: GO 84778
84771: POP
// hHackChangeUnitSide ; 8 :
84772: CALL 96707 0 0
84776: GO 84794
84778: LD_INT 8
84780: DOUBLE
84781: EQUAL
84782: IFTRUE 84786
84784: GO 84793
84786: POP
// hHackFog ; end ;
84787: CALL 96808 0 0
84791: GO 84794
84793: POP
// end ; end ;
84794: LD_VAR 0 7
84798: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
84799: GO 84801
84801: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
84802: LD_STRING initStreamRollete();
84804: PPUSH
84805: CALL_OW 559
// InitStreamMode ;
84809: CALL 84818 0 0
// DefineStreamItems ( ) ;
84813: CALL 85258 0 0
// end ;
84817: END
// function InitStreamMode ; begin
84818: LD_INT 0
84820: PPUSH
// streamModeActive := false ;
84821: LD_ADDR_EXP 122
84825: PUSH
84826: LD_INT 0
84828: ST_TO_ADDR
// normalCounter := 36 ;
84829: LD_ADDR_EXP 123
84833: PUSH
84834: LD_INT 36
84836: ST_TO_ADDR
// hardcoreCounter := 16 ;
84837: LD_ADDR_EXP 124
84841: PUSH
84842: LD_INT 16
84844: ST_TO_ADDR
// sRocket := false ;
84845: LD_ADDR_EXP 127
84849: PUSH
84850: LD_INT 0
84852: ST_TO_ADDR
// sSpeed := false ;
84853: LD_ADDR_EXP 126
84857: PUSH
84858: LD_INT 0
84860: ST_TO_ADDR
// sEngine := false ;
84861: LD_ADDR_EXP 128
84865: PUSH
84866: LD_INT 0
84868: ST_TO_ADDR
// sSpec := false ;
84869: LD_ADDR_EXP 125
84873: PUSH
84874: LD_INT 0
84876: ST_TO_ADDR
// sLevel := false ;
84877: LD_ADDR_EXP 129
84881: PUSH
84882: LD_INT 0
84884: ST_TO_ADDR
// sArmoury := false ;
84885: LD_ADDR_EXP 130
84889: PUSH
84890: LD_INT 0
84892: ST_TO_ADDR
// sRadar := false ;
84893: LD_ADDR_EXP 131
84897: PUSH
84898: LD_INT 0
84900: ST_TO_ADDR
// sBunker := false ;
84901: LD_ADDR_EXP 132
84905: PUSH
84906: LD_INT 0
84908: ST_TO_ADDR
// sHack := false ;
84909: LD_ADDR_EXP 133
84913: PUSH
84914: LD_INT 0
84916: ST_TO_ADDR
// sFire := false ;
84917: LD_ADDR_EXP 134
84921: PUSH
84922: LD_INT 0
84924: ST_TO_ADDR
// sRefresh := false ;
84925: LD_ADDR_EXP 135
84929: PUSH
84930: LD_INT 0
84932: ST_TO_ADDR
// sExp := false ;
84933: LD_ADDR_EXP 136
84937: PUSH
84938: LD_INT 0
84940: ST_TO_ADDR
// sDepot := false ;
84941: LD_ADDR_EXP 137
84945: PUSH
84946: LD_INT 0
84948: ST_TO_ADDR
// sFlag := false ;
84949: LD_ADDR_EXP 138
84953: PUSH
84954: LD_INT 0
84956: ST_TO_ADDR
// sKamikadze := false ;
84957: LD_ADDR_EXP 146
84961: PUSH
84962: LD_INT 0
84964: ST_TO_ADDR
// sTroll := false ;
84965: LD_ADDR_EXP 147
84969: PUSH
84970: LD_INT 0
84972: ST_TO_ADDR
// sSlow := false ;
84973: LD_ADDR_EXP 148
84977: PUSH
84978: LD_INT 0
84980: ST_TO_ADDR
// sLack := false ;
84981: LD_ADDR_EXP 149
84985: PUSH
84986: LD_INT 0
84988: ST_TO_ADDR
// sTank := false ;
84989: LD_ADDR_EXP 151
84993: PUSH
84994: LD_INT 0
84996: ST_TO_ADDR
// sRemote := false ;
84997: LD_ADDR_EXP 152
85001: PUSH
85002: LD_INT 0
85004: ST_TO_ADDR
// sPowell := false ;
85005: LD_ADDR_EXP 153
85009: PUSH
85010: LD_INT 0
85012: ST_TO_ADDR
// sTeleport := false ;
85013: LD_ADDR_EXP 156
85017: PUSH
85018: LD_INT 0
85020: ST_TO_ADDR
// sOilTower := false ;
85021: LD_ADDR_EXP 158
85025: PUSH
85026: LD_INT 0
85028: ST_TO_ADDR
// sShovel := false ;
85029: LD_ADDR_EXP 159
85033: PUSH
85034: LD_INT 0
85036: ST_TO_ADDR
// sSheik := false ;
85037: LD_ADDR_EXP 160
85041: PUSH
85042: LD_INT 0
85044: ST_TO_ADDR
// sEarthquake := false ;
85045: LD_ADDR_EXP 162
85049: PUSH
85050: LD_INT 0
85052: ST_TO_ADDR
// sAI := false ;
85053: LD_ADDR_EXP 163
85057: PUSH
85058: LD_INT 0
85060: ST_TO_ADDR
// sCargo := false ;
85061: LD_ADDR_EXP 166
85065: PUSH
85066: LD_INT 0
85068: ST_TO_ADDR
// sDLaser := false ;
85069: LD_ADDR_EXP 167
85073: PUSH
85074: LD_INT 0
85076: ST_TO_ADDR
// sExchange := false ;
85077: LD_ADDR_EXP 168
85081: PUSH
85082: LD_INT 0
85084: ST_TO_ADDR
// sFac := false ;
85085: LD_ADDR_EXP 169
85089: PUSH
85090: LD_INT 0
85092: ST_TO_ADDR
// sPower := false ;
85093: LD_ADDR_EXP 170
85097: PUSH
85098: LD_INT 0
85100: ST_TO_ADDR
// sRandom := false ;
85101: LD_ADDR_EXP 171
85105: PUSH
85106: LD_INT 0
85108: ST_TO_ADDR
// sShield := false ;
85109: LD_ADDR_EXP 172
85113: PUSH
85114: LD_INT 0
85116: ST_TO_ADDR
// sTime := false ;
85117: LD_ADDR_EXP 173
85121: PUSH
85122: LD_INT 0
85124: ST_TO_ADDR
// sTools := false ;
85125: LD_ADDR_EXP 174
85129: PUSH
85130: LD_INT 0
85132: ST_TO_ADDR
// sSold := false ;
85133: LD_ADDR_EXP 139
85137: PUSH
85138: LD_INT 0
85140: ST_TO_ADDR
// sDiff := false ;
85141: LD_ADDR_EXP 140
85145: PUSH
85146: LD_INT 0
85148: ST_TO_ADDR
// sFog := false ;
85149: LD_ADDR_EXP 143
85153: PUSH
85154: LD_INT 0
85156: ST_TO_ADDR
// sReset := false ;
85157: LD_ADDR_EXP 144
85161: PUSH
85162: LD_INT 0
85164: ST_TO_ADDR
// sSun := false ;
85165: LD_ADDR_EXP 145
85169: PUSH
85170: LD_INT 0
85172: ST_TO_ADDR
// sTiger := false ;
85173: LD_ADDR_EXP 141
85177: PUSH
85178: LD_INT 0
85180: ST_TO_ADDR
// sBomb := false ;
85181: LD_ADDR_EXP 142
85185: PUSH
85186: LD_INT 0
85188: ST_TO_ADDR
// sWound := false ;
85189: LD_ADDR_EXP 150
85193: PUSH
85194: LD_INT 0
85196: ST_TO_ADDR
// sBetray := false ;
85197: LD_ADDR_EXP 154
85201: PUSH
85202: LD_INT 0
85204: ST_TO_ADDR
// sContamin := false ;
85205: LD_ADDR_EXP 155
85209: PUSH
85210: LD_INT 0
85212: ST_TO_ADDR
// sOil := false ;
85213: LD_ADDR_EXP 157
85217: PUSH
85218: LD_INT 0
85220: ST_TO_ADDR
// sStu := false ;
85221: LD_ADDR_EXP 161
85225: PUSH
85226: LD_INT 0
85228: ST_TO_ADDR
// sBazooka := false ;
85229: LD_ADDR_EXP 164
85233: PUSH
85234: LD_INT 0
85236: ST_TO_ADDR
// sMortar := false ;
85237: LD_ADDR_EXP 165
85241: PUSH
85242: LD_INT 0
85244: ST_TO_ADDR
// sRanger := false ;
85245: LD_ADDR_EXP 175
85249: PUSH
85250: LD_INT 0
85252: ST_TO_ADDR
// end ;
85253: LD_VAR 0 1
85257: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85258: LD_INT 0
85260: PPUSH
85261: PPUSH
85262: PPUSH
85263: PPUSH
85264: PPUSH
// result := [ ] ;
85265: LD_ADDR_VAR 0 1
85269: PUSH
85270: EMPTY
85271: ST_TO_ADDR
// if campaign_id = 1 then
85272: LD_OWVAR 69
85276: PUSH
85277: LD_INT 1
85279: EQUAL
85280: IFFALSE 88218
// begin case mission_number of 1 :
85282: LD_OWVAR 70
85286: PUSH
85287: LD_INT 1
85289: DOUBLE
85290: EQUAL
85291: IFTRUE 85295
85293: GO 85359
85295: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85296: LD_ADDR_VAR 0 1
85300: PUSH
85301: LD_INT 2
85303: PUSH
85304: LD_INT 4
85306: PUSH
85307: LD_INT 11
85309: PUSH
85310: LD_INT 12
85312: PUSH
85313: LD_INT 15
85315: PUSH
85316: LD_INT 16
85318: PUSH
85319: LD_INT 22
85321: PUSH
85322: LD_INT 23
85324: PUSH
85325: LD_INT 26
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 101
85341: PUSH
85342: LD_INT 102
85344: PUSH
85345: LD_INT 106
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: LIST
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: ST_TO_ADDR
85357: GO 88216
85359: LD_INT 2
85361: DOUBLE
85362: EQUAL
85363: IFTRUE 85367
85365: GO 85439
85367: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
85368: LD_ADDR_VAR 0 1
85372: PUSH
85373: LD_INT 2
85375: PUSH
85376: LD_INT 4
85378: PUSH
85379: LD_INT 11
85381: PUSH
85382: LD_INT 12
85384: PUSH
85385: LD_INT 15
85387: PUSH
85388: LD_INT 16
85390: PUSH
85391: LD_INT 22
85393: PUSH
85394: LD_INT 23
85396: PUSH
85397: LD_INT 26
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 101
85413: PUSH
85414: LD_INT 102
85416: PUSH
85417: LD_INT 105
85419: PUSH
85420: LD_INT 106
85422: PUSH
85423: LD_INT 108
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: ST_TO_ADDR
85437: GO 88216
85439: LD_INT 3
85441: DOUBLE
85442: EQUAL
85443: IFTRUE 85447
85445: GO 85523
85447: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
85448: LD_ADDR_VAR 0 1
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: LD_INT 4
85458: PUSH
85459: LD_INT 5
85461: PUSH
85462: LD_INT 11
85464: PUSH
85465: LD_INT 12
85467: PUSH
85468: LD_INT 15
85470: PUSH
85471: LD_INT 16
85473: PUSH
85474: LD_INT 22
85476: PUSH
85477: LD_INT 26
85479: PUSH
85480: LD_INT 36
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 101
85497: PUSH
85498: LD_INT 102
85500: PUSH
85501: LD_INT 105
85503: PUSH
85504: LD_INT 106
85506: PUSH
85507: LD_INT 108
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: ST_TO_ADDR
85521: GO 88216
85523: LD_INT 4
85525: DOUBLE
85526: EQUAL
85527: IFTRUE 85531
85529: GO 85615
85531: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
85532: LD_ADDR_VAR 0 1
85536: PUSH
85537: LD_INT 2
85539: PUSH
85540: LD_INT 4
85542: PUSH
85543: LD_INT 5
85545: PUSH
85546: LD_INT 8
85548: PUSH
85549: LD_INT 11
85551: PUSH
85552: LD_INT 12
85554: PUSH
85555: LD_INT 15
85557: PUSH
85558: LD_INT 16
85560: PUSH
85561: LD_INT 22
85563: PUSH
85564: LD_INT 23
85566: PUSH
85567: LD_INT 26
85569: PUSH
85570: LD_INT 36
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 101
85589: PUSH
85590: LD_INT 102
85592: PUSH
85593: LD_INT 105
85595: PUSH
85596: LD_INT 106
85598: PUSH
85599: LD_INT 108
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: ST_TO_ADDR
85613: GO 88216
85615: LD_INT 5
85617: DOUBLE
85618: EQUAL
85619: IFTRUE 85623
85621: GO 85723
85623: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
85624: LD_ADDR_VAR 0 1
85628: PUSH
85629: LD_INT 2
85631: PUSH
85632: LD_INT 4
85634: PUSH
85635: LD_INT 5
85637: PUSH
85638: LD_INT 6
85640: PUSH
85641: LD_INT 8
85643: PUSH
85644: LD_INT 11
85646: PUSH
85647: LD_INT 12
85649: PUSH
85650: LD_INT 15
85652: PUSH
85653: LD_INT 16
85655: PUSH
85656: LD_INT 22
85658: PUSH
85659: LD_INT 23
85661: PUSH
85662: LD_INT 25
85664: PUSH
85665: LD_INT 26
85667: PUSH
85668: LD_INT 36
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 101
85689: PUSH
85690: LD_INT 102
85692: PUSH
85693: LD_INT 105
85695: PUSH
85696: LD_INT 106
85698: PUSH
85699: LD_INT 108
85701: PUSH
85702: LD_INT 109
85704: PUSH
85705: LD_INT 112
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: ST_TO_ADDR
85721: GO 88216
85723: LD_INT 6
85725: DOUBLE
85726: EQUAL
85727: IFTRUE 85731
85729: GO 85851
85731: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
85732: LD_ADDR_VAR 0 1
85736: PUSH
85737: LD_INT 2
85739: PUSH
85740: LD_INT 4
85742: PUSH
85743: LD_INT 5
85745: PUSH
85746: LD_INT 6
85748: PUSH
85749: LD_INT 8
85751: PUSH
85752: LD_INT 11
85754: PUSH
85755: LD_INT 12
85757: PUSH
85758: LD_INT 15
85760: PUSH
85761: LD_INT 16
85763: PUSH
85764: LD_INT 20
85766: PUSH
85767: LD_INT 21
85769: PUSH
85770: LD_INT 22
85772: PUSH
85773: LD_INT 23
85775: PUSH
85776: LD_INT 25
85778: PUSH
85779: LD_INT 26
85781: PUSH
85782: LD_INT 30
85784: PUSH
85785: LD_INT 31
85787: PUSH
85788: LD_INT 32
85790: PUSH
85791: LD_INT 36
85793: PUSH
85794: EMPTY
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 101
85817: PUSH
85818: LD_INT 102
85820: PUSH
85821: LD_INT 105
85823: PUSH
85824: LD_INT 106
85826: PUSH
85827: LD_INT 108
85829: PUSH
85830: LD_INT 109
85832: PUSH
85833: LD_INT 112
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: ST_TO_ADDR
85849: GO 88216
85851: LD_INT 7
85853: DOUBLE
85854: EQUAL
85855: IFTRUE 85859
85857: GO 85959
85859: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
85860: LD_ADDR_VAR 0 1
85864: PUSH
85865: LD_INT 2
85867: PUSH
85868: LD_INT 4
85870: PUSH
85871: LD_INT 5
85873: PUSH
85874: LD_INT 7
85876: PUSH
85877: LD_INT 11
85879: PUSH
85880: LD_INT 12
85882: PUSH
85883: LD_INT 15
85885: PUSH
85886: LD_INT 16
85888: PUSH
85889: LD_INT 20
85891: PUSH
85892: LD_INT 21
85894: PUSH
85895: LD_INT 22
85897: PUSH
85898: LD_INT 23
85900: PUSH
85901: LD_INT 25
85903: PUSH
85904: LD_INT 26
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 101
85925: PUSH
85926: LD_INT 102
85928: PUSH
85929: LD_INT 103
85931: PUSH
85932: LD_INT 105
85934: PUSH
85935: LD_INT 106
85937: PUSH
85938: LD_INT 108
85940: PUSH
85941: LD_INT 112
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: ST_TO_ADDR
85957: GO 88216
85959: LD_INT 8
85961: DOUBLE
85962: EQUAL
85963: IFTRUE 85967
85965: GO 86095
85967: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
85968: LD_ADDR_VAR 0 1
85972: PUSH
85973: LD_INT 2
85975: PUSH
85976: LD_INT 4
85978: PUSH
85979: LD_INT 5
85981: PUSH
85982: LD_INT 6
85984: PUSH
85985: LD_INT 7
85987: PUSH
85988: LD_INT 8
85990: PUSH
85991: LD_INT 11
85993: PUSH
85994: LD_INT 12
85996: PUSH
85997: LD_INT 15
85999: PUSH
86000: LD_INT 16
86002: PUSH
86003: LD_INT 20
86005: PUSH
86006: LD_INT 21
86008: PUSH
86009: LD_INT 22
86011: PUSH
86012: LD_INT 23
86014: PUSH
86015: LD_INT 25
86017: PUSH
86018: LD_INT 26
86020: PUSH
86021: LD_INT 30
86023: PUSH
86024: LD_INT 31
86026: PUSH
86027: LD_INT 32
86029: PUSH
86030: LD_INT 36
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 101
86057: PUSH
86058: LD_INT 102
86060: PUSH
86061: LD_INT 103
86063: PUSH
86064: LD_INT 105
86066: PUSH
86067: LD_INT 106
86069: PUSH
86070: LD_INT 108
86072: PUSH
86073: LD_INT 109
86075: PUSH
86076: LD_INT 112
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: ST_TO_ADDR
86093: GO 88216
86095: LD_INT 9
86097: DOUBLE
86098: EQUAL
86099: IFTRUE 86103
86101: GO 86239
86103: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86104: LD_ADDR_VAR 0 1
86108: PUSH
86109: LD_INT 2
86111: PUSH
86112: LD_INT 4
86114: PUSH
86115: LD_INT 5
86117: PUSH
86118: LD_INT 6
86120: PUSH
86121: LD_INT 7
86123: PUSH
86124: LD_INT 8
86126: PUSH
86127: LD_INT 11
86129: PUSH
86130: LD_INT 12
86132: PUSH
86133: LD_INT 15
86135: PUSH
86136: LD_INT 16
86138: PUSH
86139: LD_INT 20
86141: PUSH
86142: LD_INT 21
86144: PUSH
86145: LD_INT 22
86147: PUSH
86148: LD_INT 23
86150: PUSH
86151: LD_INT 25
86153: PUSH
86154: LD_INT 26
86156: PUSH
86157: LD_INT 28
86159: PUSH
86160: LD_INT 30
86162: PUSH
86163: LD_INT 31
86165: PUSH
86166: LD_INT 32
86168: PUSH
86169: LD_INT 36
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 101
86197: PUSH
86198: LD_INT 102
86200: PUSH
86201: LD_INT 103
86203: PUSH
86204: LD_INT 105
86206: PUSH
86207: LD_INT 106
86209: PUSH
86210: LD_INT 108
86212: PUSH
86213: LD_INT 109
86215: PUSH
86216: LD_INT 112
86218: PUSH
86219: LD_INT 114
86221: PUSH
86222: EMPTY
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: ST_TO_ADDR
86237: GO 88216
86239: LD_INT 10
86241: DOUBLE
86242: EQUAL
86243: IFTRUE 86247
86245: GO 86431
86247: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86248: LD_ADDR_VAR 0 1
86252: PUSH
86253: LD_INT 2
86255: PUSH
86256: LD_INT 4
86258: PUSH
86259: LD_INT 5
86261: PUSH
86262: LD_INT 6
86264: PUSH
86265: LD_INT 7
86267: PUSH
86268: LD_INT 8
86270: PUSH
86271: LD_INT 9
86273: PUSH
86274: LD_INT 10
86276: PUSH
86277: LD_INT 11
86279: PUSH
86280: LD_INT 12
86282: PUSH
86283: LD_INT 13
86285: PUSH
86286: LD_INT 14
86288: PUSH
86289: LD_INT 15
86291: PUSH
86292: LD_INT 16
86294: PUSH
86295: LD_INT 17
86297: PUSH
86298: LD_INT 18
86300: PUSH
86301: LD_INT 19
86303: PUSH
86304: LD_INT 20
86306: PUSH
86307: LD_INT 21
86309: PUSH
86310: LD_INT 22
86312: PUSH
86313: LD_INT 23
86315: PUSH
86316: LD_INT 24
86318: PUSH
86319: LD_INT 25
86321: PUSH
86322: LD_INT 26
86324: PUSH
86325: LD_INT 28
86327: PUSH
86328: LD_INT 30
86330: PUSH
86331: LD_INT 31
86333: PUSH
86334: LD_INT 32
86336: PUSH
86337: LD_INT 36
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: LIST
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 101
86373: PUSH
86374: LD_INT 102
86376: PUSH
86377: LD_INT 103
86379: PUSH
86380: LD_INT 104
86382: PUSH
86383: LD_INT 105
86385: PUSH
86386: LD_INT 106
86388: PUSH
86389: LD_INT 107
86391: PUSH
86392: LD_INT 108
86394: PUSH
86395: LD_INT 109
86397: PUSH
86398: LD_INT 110
86400: PUSH
86401: LD_INT 111
86403: PUSH
86404: LD_INT 112
86406: PUSH
86407: LD_INT 114
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: ST_TO_ADDR
86429: GO 88216
86431: LD_INT 11
86433: DOUBLE
86434: EQUAL
86435: IFTRUE 86439
86437: GO 86631
86439: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
86440: LD_ADDR_VAR 0 1
86444: PUSH
86445: LD_INT 2
86447: PUSH
86448: LD_INT 3
86450: PUSH
86451: LD_INT 4
86453: PUSH
86454: LD_INT 5
86456: PUSH
86457: LD_INT 6
86459: PUSH
86460: LD_INT 7
86462: PUSH
86463: LD_INT 8
86465: PUSH
86466: LD_INT 9
86468: PUSH
86469: LD_INT 10
86471: PUSH
86472: LD_INT 11
86474: PUSH
86475: LD_INT 12
86477: PUSH
86478: LD_INT 13
86480: PUSH
86481: LD_INT 14
86483: PUSH
86484: LD_INT 15
86486: PUSH
86487: LD_INT 16
86489: PUSH
86490: LD_INT 17
86492: PUSH
86493: LD_INT 18
86495: PUSH
86496: LD_INT 19
86498: PUSH
86499: LD_INT 20
86501: PUSH
86502: LD_INT 21
86504: PUSH
86505: LD_INT 22
86507: PUSH
86508: LD_INT 23
86510: PUSH
86511: LD_INT 24
86513: PUSH
86514: LD_INT 25
86516: PUSH
86517: LD_INT 26
86519: PUSH
86520: LD_INT 28
86522: PUSH
86523: LD_INT 30
86525: PUSH
86526: LD_INT 31
86528: PUSH
86529: LD_INT 32
86531: PUSH
86532: LD_INT 34
86534: PUSH
86535: LD_INT 36
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 101
86573: PUSH
86574: LD_INT 102
86576: PUSH
86577: LD_INT 103
86579: PUSH
86580: LD_INT 104
86582: PUSH
86583: LD_INT 105
86585: PUSH
86586: LD_INT 106
86588: PUSH
86589: LD_INT 107
86591: PUSH
86592: LD_INT 108
86594: PUSH
86595: LD_INT 109
86597: PUSH
86598: LD_INT 110
86600: PUSH
86601: LD_INT 111
86603: PUSH
86604: LD_INT 112
86606: PUSH
86607: LD_INT 114
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: ST_TO_ADDR
86629: GO 88216
86631: LD_INT 12
86633: DOUBLE
86634: EQUAL
86635: IFTRUE 86639
86637: GO 86847
86639: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
86640: LD_ADDR_VAR 0 1
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: LD_INT 2
86650: PUSH
86651: LD_INT 3
86653: PUSH
86654: LD_INT 4
86656: PUSH
86657: LD_INT 5
86659: PUSH
86660: LD_INT 6
86662: PUSH
86663: LD_INT 7
86665: PUSH
86666: LD_INT 8
86668: PUSH
86669: LD_INT 9
86671: PUSH
86672: LD_INT 10
86674: PUSH
86675: LD_INT 11
86677: PUSH
86678: LD_INT 12
86680: PUSH
86681: LD_INT 13
86683: PUSH
86684: LD_INT 14
86686: PUSH
86687: LD_INT 15
86689: PUSH
86690: LD_INT 16
86692: PUSH
86693: LD_INT 17
86695: PUSH
86696: LD_INT 18
86698: PUSH
86699: LD_INT 19
86701: PUSH
86702: LD_INT 20
86704: PUSH
86705: LD_INT 21
86707: PUSH
86708: LD_INT 22
86710: PUSH
86711: LD_INT 23
86713: PUSH
86714: LD_INT 24
86716: PUSH
86717: LD_INT 25
86719: PUSH
86720: LD_INT 26
86722: PUSH
86723: LD_INT 27
86725: PUSH
86726: LD_INT 28
86728: PUSH
86729: LD_INT 30
86731: PUSH
86732: LD_INT 31
86734: PUSH
86735: LD_INT 32
86737: PUSH
86738: LD_INT 33
86740: PUSH
86741: LD_INT 34
86743: PUSH
86744: LD_INT 36
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 101
86785: PUSH
86786: LD_INT 102
86788: PUSH
86789: LD_INT 103
86791: PUSH
86792: LD_INT 104
86794: PUSH
86795: LD_INT 105
86797: PUSH
86798: LD_INT 106
86800: PUSH
86801: LD_INT 107
86803: PUSH
86804: LD_INT 108
86806: PUSH
86807: LD_INT 109
86809: PUSH
86810: LD_INT 110
86812: PUSH
86813: LD_INT 111
86815: PUSH
86816: LD_INT 112
86818: PUSH
86819: LD_INT 113
86821: PUSH
86822: LD_INT 114
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: ST_TO_ADDR
86845: GO 88216
86847: LD_INT 13
86849: DOUBLE
86850: EQUAL
86851: IFTRUE 86855
86853: GO 87051
86855: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
86856: LD_ADDR_VAR 0 1
86860: PUSH
86861: LD_INT 1
86863: PUSH
86864: LD_INT 2
86866: PUSH
86867: LD_INT 3
86869: PUSH
86870: LD_INT 4
86872: PUSH
86873: LD_INT 5
86875: PUSH
86876: LD_INT 8
86878: PUSH
86879: LD_INT 9
86881: PUSH
86882: LD_INT 10
86884: PUSH
86885: LD_INT 11
86887: PUSH
86888: LD_INT 12
86890: PUSH
86891: LD_INT 14
86893: PUSH
86894: LD_INT 15
86896: PUSH
86897: LD_INT 16
86899: PUSH
86900: LD_INT 17
86902: PUSH
86903: LD_INT 18
86905: PUSH
86906: LD_INT 19
86908: PUSH
86909: LD_INT 20
86911: PUSH
86912: LD_INT 21
86914: PUSH
86915: LD_INT 22
86917: PUSH
86918: LD_INT 23
86920: PUSH
86921: LD_INT 24
86923: PUSH
86924: LD_INT 25
86926: PUSH
86927: LD_INT 26
86929: PUSH
86930: LD_INT 27
86932: PUSH
86933: LD_INT 28
86935: PUSH
86936: LD_INT 30
86938: PUSH
86939: LD_INT 31
86941: PUSH
86942: LD_INT 32
86944: PUSH
86945: LD_INT 33
86947: PUSH
86948: LD_INT 34
86950: PUSH
86951: LD_INT 36
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 101
86989: PUSH
86990: LD_INT 102
86992: PUSH
86993: LD_INT 103
86995: PUSH
86996: LD_INT 104
86998: PUSH
86999: LD_INT 105
87001: PUSH
87002: LD_INT 106
87004: PUSH
87005: LD_INT 107
87007: PUSH
87008: LD_INT 108
87010: PUSH
87011: LD_INT 109
87013: PUSH
87014: LD_INT 110
87016: PUSH
87017: LD_INT 111
87019: PUSH
87020: LD_INT 112
87022: PUSH
87023: LD_INT 113
87025: PUSH
87026: LD_INT 114
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: ST_TO_ADDR
87049: GO 88216
87051: LD_INT 14
87053: DOUBLE
87054: EQUAL
87055: IFTRUE 87059
87057: GO 87271
87059: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87060: LD_ADDR_VAR 0 1
87064: PUSH
87065: LD_INT 1
87067: PUSH
87068: LD_INT 2
87070: PUSH
87071: LD_INT 3
87073: PUSH
87074: LD_INT 4
87076: PUSH
87077: LD_INT 5
87079: PUSH
87080: LD_INT 6
87082: PUSH
87083: LD_INT 7
87085: PUSH
87086: LD_INT 8
87088: PUSH
87089: LD_INT 9
87091: PUSH
87092: LD_INT 10
87094: PUSH
87095: LD_INT 11
87097: PUSH
87098: LD_INT 12
87100: PUSH
87101: LD_INT 13
87103: PUSH
87104: LD_INT 14
87106: PUSH
87107: LD_INT 15
87109: PUSH
87110: LD_INT 16
87112: PUSH
87113: LD_INT 17
87115: PUSH
87116: LD_INT 18
87118: PUSH
87119: LD_INT 19
87121: PUSH
87122: LD_INT 20
87124: PUSH
87125: LD_INT 21
87127: PUSH
87128: LD_INT 22
87130: PUSH
87131: LD_INT 23
87133: PUSH
87134: LD_INT 24
87136: PUSH
87137: LD_INT 25
87139: PUSH
87140: LD_INT 26
87142: PUSH
87143: LD_INT 27
87145: PUSH
87146: LD_INT 28
87148: PUSH
87149: LD_INT 29
87151: PUSH
87152: LD_INT 30
87154: PUSH
87155: LD_INT 31
87157: PUSH
87158: LD_INT 32
87160: PUSH
87161: LD_INT 33
87163: PUSH
87164: LD_INT 34
87166: PUSH
87167: LD_INT 36
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 101
87209: PUSH
87210: LD_INT 102
87212: PUSH
87213: LD_INT 103
87215: PUSH
87216: LD_INT 104
87218: PUSH
87219: LD_INT 105
87221: PUSH
87222: LD_INT 106
87224: PUSH
87225: LD_INT 107
87227: PUSH
87228: LD_INT 108
87230: PUSH
87231: LD_INT 109
87233: PUSH
87234: LD_INT 110
87236: PUSH
87237: LD_INT 111
87239: PUSH
87240: LD_INT 112
87242: PUSH
87243: LD_INT 113
87245: PUSH
87246: LD_INT 114
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: ST_TO_ADDR
87269: GO 88216
87271: LD_INT 15
87273: DOUBLE
87274: EQUAL
87275: IFTRUE 87279
87277: GO 87491
87279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87280: LD_ADDR_VAR 0 1
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 3
87293: PUSH
87294: LD_INT 4
87296: PUSH
87297: LD_INT 5
87299: PUSH
87300: LD_INT 6
87302: PUSH
87303: LD_INT 7
87305: PUSH
87306: LD_INT 8
87308: PUSH
87309: LD_INT 9
87311: PUSH
87312: LD_INT 10
87314: PUSH
87315: LD_INT 11
87317: PUSH
87318: LD_INT 12
87320: PUSH
87321: LD_INT 13
87323: PUSH
87324: LD_INT 14
87326: PUSH
87327: LD_INT 15
87329: PUSH
87330: LD_INT 16
87332: PUSH
87333: LD_INT 17
87335: PUSH
87336: LD_INT 18
87338: PUSH
87339: LD_INT 19
87341: PUSH
87342: LD_INT 20
87344: PUSH
87345: LD_INT 21
87347: PUSH
87348: LD_INT 22
87350: PUSH
87351: LD_INT 23
87353: PUSH
87354: LD_INT 24
87356: PUSH
87357: LD_INT 25
87359: PUSH
87360: LD_INT 26
87362: PUSH
87363: LD_INT 27
87365: PUSH
87366: LD_INT 28
87368: PUSH
87369: LD_INT 29
87371: PUSH
87372: LD_INT 30
87374: PUSH
87375: LD_INT 31
87377: PUSH
87378: LD_INT 32
87380: PUSH
87381: LD_INT 33
87383: PUSH
87384: LD_INT 34
87386: PUSH
87387: LD_INT 36
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 101
87429: PUSH
87430: LD_INT 102
87432: PUSH
87433: LD_INT 103
87435: PUSH
87436: LD_INT 104
87438: PUSH
87439: LD_INT 105
87441: PUSH
87442: LD_INT 106
87444: PUSH
87445: LD_INT 107
87447: PUSH
87448: LD_INT 108
87450: PUSH
87451: LD_INT 109
87453: PUSH
87454: LD_INT 110
87456: PUSH
87457: LD_INT 111
87459: PUSH
87460: LD_INT 112
87462: PUSH
87463: LD_INT 113
87465: PUSH
87466: LD_INT 114
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: ST_TO_ADDR
87489: GO 88216
87491: LD_INT 16
87493: DOUBLE
87494: EQUAL
87495: IFTRUE 87499
87497: GO 87623
87499: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
87500: LD_ADDR_VAR 0 1
87504: PUSH
87505: LD_INT 2
87507: PUSH
87508: LD_INT 4
87510: PUSH
87511: LD_INT 5
87513: PUSH
87514: LD_INT 7
87516: PUSH
87517: LD_INT 11
87519: PUSH
87520: LD_INT 12
87522: PUSH
87523: LD_INT 15
87525: PUSH
87526: LD_INT 16
87528: PUSH
87529: LD_INT 20
87531: PUSH
87532: LD_INT 21
87534: PUSH
87535: LD_INT 22
87537: PUSH
87538: LD_INT 23
87540: PUSH
87541: LD_INT 25
87543: PUSH
87544: LD_INT 26
87546: PUSH
87547: LD_INT 30
87549: PUSH
87550: LD_INT 31
87552: PUSH
87553: LD_INT 32
87555: PUSH
87556: LD_INT 33
87558: PUSH
87559: LD_INT 34
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 101
87585: PUSH
87586: LD_INT 102
87588: PUSH
87589: LD_INT 103
87591: PUSH
87592: LD_INT 106
87594: PUSH
87595: LD_INT 108
87597: PUSH
87598: LD_INT 112
87600: PUSH
87601: LD_INT 113
87603: PUSH
87604: LD_INT 114
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: ST_TO_ADDR
87621: GO 88216
87623: LD_INT 17
87625: DOUBLE
87626: EQUAL
87627: IFTRUE 87631
87629: GO 87843
87631: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
87632: LD_ADDR_VAR 0 1
87636: PUSH
87637: LD_INT 1
87639: PUSH
87640: LD_INT 2
87642: PUSH
87643: LD_INT 3
87645: PUSH
87646: LD_INT 4
87648: PUSH
87649: LD_INT 5
87651: PUSH
87652: LD_INT 6
87654: PUSH
87655: LD_INT 7
87657: PUSH
87658: LD_INT 8
87660: PUSH
87661: LD_INT 9
87663: PUSH
87664: LD_INT 10
87666: PUSH
87667: LD_INT 11
87669: PUSH
87670: LD_INT 12
87672: PUSH
87673: LD_INT 13
87675: PUSH
87676: LD_INT 14
87678: PUSH
87679: LD_INT 15
87681: PUSH
87682: LD_INT 16
87684: PUSH
87685: LD_INT 17
87687: PUSH
87688: LD_INT 18
87690: PUSH
87691: LD_INT 19
87693: PUSH
87694: LD_INT 20
87696: PUSH
87697: LD_INT 21
87699: PUSH
87700: LD_INT 22
87702: PUSH
87703: LD_INT 23
87705: PUSH
87706: LD_INT 24
87708: PUSH
87709: LD_INT 25
87711: PUSH
87712: LD_INT 26
87714: PUSH
87715: LD_INT 27
87717: PUSH
87718: LD_INT 28
87720: PUSH
87721: LD_INT 29
87723: PUSH
87724: LD_INT 30
87726: PUSH
87727: LD_INT 31
87729: PUSH
87730: LD_INT 32
87732: PUSH
87733: LD_INT 33
87735: PUSH
87736: LD_INT 34
87738: PUSH
87739: LD_INT 36
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 101
87781: PUSH
87782: LD_INT 102
87784: PUSH
87785: LD_INT 103
87787: PUSH
87788: LD_INT 104
87790: PUSH
87791: LD_INT 105
87793: PUSH
87794: LD_INT 106
87796: PUSH
87797: LD_INT 107
87799: PUSH
87800: LD_INT 108
87802: PUSH
87803: LD_INT 109
87805: PUSH
87806: LD_INT 110
87808: PUSH
87809: LD_INT 111
87811: PUSH
87812: LD_INT 112
87814: PUSH
87815: LD_INT 113
87817: PUSH
87818: LD_INT 114
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: ST_TO_ADDR
87841: GO 88216
87843: LD_INT 18
87845: DOUBLE
87846: EQUAL
87847: IFTRUE 87851
87849: GO 87987
87851: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
87852: LD_ADDR_VAR 0 1
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: LD_INT 4
87862: PUSH
87863: LD_INT 5
87865: PUSH
87866: LD_INT 7
87868: PUSH
87869: LD_INT 11
87871: PUSH
87872: LD_INT 12
87874: PUSH
87875: LD_INT 15
87877: PUSH
87878: LD_INT 16
87880: PUSH
87881: LD_INT 20
87883: PUSH
87884: LD_INT 21
87886: PUSH
87887: LD_INT 22
87889: PUSH
87890: LD_INT 23
87892: PUSH
87893: LD_INT 25
87895: PUSH
87896: LD_INT 26
87898: PUSH
87899: LD_INT 30
87901: PUSH
87902: LD_INT 31
87904: PUSH
87905: LD_INT 32
87907: PUSH
87908: LD_INT 33
87910: PUSH
87911: LD_INT 34
87913: PUSH
87914: LD_INT 35
87916: PUSH
87917: LD_INT 36
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: PUSH
87943: LD_INT 101
87945: PUSH
87946: LD_INT 102
87948: PUSH
87949: LD_INT 103
87951: PUSH
87952: LD_INT 106
87954: PUSH
87955: LD_INT 108
87957: PUSH
87958: LD_INT 112
87960: PUSH
87961: LD_INT 113
87963: PUSH
87964: LD_INT 114
87966: PUSH
87967: LD_INT 115
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: ST_TO_ADDR
87985: GO 88216
87987: LD_INT 19
87989: DOUBLE
87990: EQUAL
87991: IFTRUE 87995
87993: GO 88215
87995: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87996: LD_ADDR_VAR 0 1
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: LD_INT 2
88006: PUSH
88007: LD_INT 3
88009: PUSH
88010: LD_INT 4
88012: PUSH
88013: LD_INT 5
88015: PUSH
88016: LD_INT 6
88018: PUSH
88019: LD_INT 7
88021: PUSH
88022: LD_INT 8
88024: PUSH
88025: LD_INT 9
88027: PUSH
88028: LD_INT 10
88030: PUSH
88031: LD_INT 11
88033: PUSH
88034: LD_INT 12
88036: PUSH
88037: LD_INT 13
88039: PUSH
88040: LD_INT 14
88042: PUSH
88043: LD_INT 15
88045: PUSH
88046: LD_INT 16
88048: PUSH
88049: LD_INT 17
88051: PUSH
88052: LD_INT 18
88054: PUSH
88055: LD_INT 19
88057: PUSH
88058: LD_INT 20
88060: PUSH
88061: LD_INT 21
88063: PUSH
88064: LD_INT 22
88066: PUSH
88067: LD_INT 23
88069: PUSH
88070: LD_INT 24
88072: PUSH
88073: LD_INT 25
88075: PUSH
88076: LD_INT 26
88078: PUSH
88079: LD_INT 27
88081: PUSH
88082: LD_INT 28
88084: PUSH
88085: LD_INT 29
88087: PUSH
88088: LD_INT 30
88090: PUSH
88091: LD_INT 31
88093: PUSH
88094: LD_INT 32
88096: PUSH
88097: LD_INT 33
88099: PUSH
88100: LD_INT 34
88102: PUSH
88103: LD_INT 35
88105: PUSH
88106: LD_INT 36
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 101
88149: PUSH
88150: LD_INT 102
88152: PUSH
88153: LD_INT 103
88155: PUSH
88156: LD_INT 104
88158: PUSH
88159: LD_INT 105
88161: PUSH
88162: LD_INT 106
88164: PUSH
88165: LD_INT 107
88167: PUSH
88168: LD_INT 108
88170: PUSH
88171: LD_INT 109
88173: PUSH
88174: LD_INT 110
88176: PUSH
88177: LD_INT 111
88179: PUSH
88180: LD_INT 112
88182: PUSH
88183: LD_INT 113
88185: PUSH
88186: LD_INT 114
88188: PUSH
88189: LD_INT 115
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: ST_TO_ADDR
88213: GO 88216
88215: POP
// end else
88216: GO 88435
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88218: LD_ADDR_VAR 0 1
88222: PUSH
88223: LD_INT 1
88225: PUSH
88226: LD_INT 2
88228: PUSH
88229: LD_INT 3
88231: PUSH
88232: LD_INT 4
88234: PUSH
88235: LD_INT 5
88237: PUSH
88238: LD_INT 6
88240: PUSH
88241: LD_INT 7
88243: PUSH
88244: LD_INT 8
88246: PUSH
88247: LD_INT 9
88249: PUSH
88250: LD_INT 10
88252: PUSH
88253: LD_INT 11
88255: PUSH
88256: LD_INT 12
88258: PUSH
88259: LD_INT 13
88261: PUSH
88262: LD_INT 14
88264: PUSH
88265: LD_INT 15
88267: PUSH
88268: LD_INT 16
88270: PUSH
88271: LD_INT 17
88273: PUSH
88274: LD_INT 18
88276: PUSH
88277: LD_INT 19
88279: PUSH
88280: LD_INT 20
88282: PUSH
88283: LD_INT 21
88285: PUSH
88286: LD_INT 22
88288: PUSH
88289: LD_INT 23
88291: PUSH
88292: LD_INT 24
88294: PUSH
88295: LD_INT 25
88297: PUSH
88298: LD_INT 26
88300: PUSH
88301: LD_INT 27
88303: PUSH
88304: LD_INT 28
88306: PUSH
88307: LD_INT 29
88309: PUSH
88310: LD_INT 30
88312: PUSH
88313: LD_INT 31
88315: PUSH
88316: LD_INT 32
88318: PUSH
88319: LD_INT 33
88321: PUSH
88322: LD_INT 34
88324: PUSH
88325: LD_INT 35
88327: PUSH
88328: LD_INT 36
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: PUSH
88369: LD_INT 101
88371: PUSH
88372: LD_INT 102
88374: PUSH
88375: LD_INT 103
88377: PUSH
88378: LD_INT 104
88380: PUSH
88381: LD_INT 105
88383: PUSH
88384: LD_INT 106
88386: PUSH
88387: LD_INT 107
88389: PUSH
88390: LD_INT 108
88392: PUSH
88393: LD_INT 109
88395: PUSH
88396: LD_INT 110
88398: PUSH
88399: LD_INT 111
88401: PUSH
88402: LD_INT 112
88404: PUSH
88405: LD_INT 113
88407: PUSH
88408: LD_INT 114
88410: PUSH
88411: LD_INT 115
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: ST_TO_ADDR
// if result then
88435: LD_VAR 0 1
88439: IFFALSE 88728
// begin normal :=  ;
88441: LD_ADDR_VAR 0 3
88445: PUSH
88446: LD_STRING 
88448: ST_TO_ADDR
// hardcore :=  ;
88449: LD_ADDR_VAR 0 4
88453: PUSH
88454: LD_STRING 
88456: ST_TO_ADDR
// for i = 1 to normalCounter do
88457: LD_ADDR_VAR 0 5
88461: PUSH
88462: DOUBLE
88463: LD_INT 1
88465: DEC
88466: ST_TO_ADDR
88467: LD_EXP 123
88471: PUSH
88472: FOR_TO
88473: IFFALSE 88574
// begin tmp := 0 ;
88475: LD_ADDR_VAR 0 2
88479: PUSH
88480: LD_STRING 0
88482: ST_TO_ADDR
// if result [ 1 ] then
88483: LD_VAR 0 1
88487: PUSH
88488: LD_INT 1
88490: ARRAY
88491: IFFALSE 88556
// if result [ 1 ] [ 1 ] = i then
88493: LD_VAR 0 1
88497: PUSH
88498: LD_INT 1
88500: ARRAY
88501: PUSH
88502: LD_INT 1
88504: ARRAY
88505: PUSH
88506: LD_VAR 0 5
88510: EQUAL
88511: IFFALSE 88556
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
88513: LD_ADDR_VAR 0 1
88517: PUSH
88518: LD_VAR 0 1
88522: PPUSH
88523: LD_INT 1
88525: PPUSH
88526: LD_VAR 0 1
88530: PUSH
88531: LD_INT 1
88533: ARRAY
88534: PPUSH
88535: LD_INT 1
88537: PPUSH
88538: CALL_OW 3
88542: PPUSH
88543: CALL_OW 1
88547: ST_TO_ADDR
// tmp := 1 ;
88548: LD_ADDR_VAR 0 2
88552: PUSH
88553: LD_STRING 1
88555: ST_TO_ADDR
// end ; normal := normal & tmp ;
88556: LD_ADDR_VAR 0 3
88560: PUSH
88561: LD_VAR 0 3
88565: PUSH
88566: LD_VAR 0 2
88570: STR
88571: ST_TO_ADDR
// end ;
88572: GO 88472
88574: POP
88575: POP
// for i = 1 to hardcoreCounter do
88576: LD_ADDR_VAR 0 5
88580: PUSH
88581: DOUBLE
88582: LD_INT 1
88584: DEC
88585: ST_TO_ADDR
88586: LD_EXP 124
88590: PUSH
88591: FOR_TO
88592: IFFALSE 88697
// begin tmp := 0 ;
88594: LD_ADDR_VAR 0 2
88598: PUSH
88599: LD_STRING 0
88601: ST_TO_ADDR
// if result [ 2 ] then
88602: LD_VAR 0 1
88606: PUSH
88607: LD_INT 2
88609: ARRAY
88610: IFFALSE 88679
// if result [ 2 ] [ 1 ] = 100 + i then
88612: LD_VAR 0 1
88616: PUSH
88617: LD_INT 2
88619: ARRAY
88620: PUSH
88621: LD_INT 1
88623: ARRAY
88624: PUSH
88625: LD_INT 100
88627: PUSH
88628: LD_VAR 0 5
88632: PLUS
88633: EQUAL
88634: IFFALSE 88679
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
88636: LD_ADDR_VAR 0 1
88640: PUSH
88641: LD_VAR 0 1
88645: PPUSH
88646: LD_INT 2
88648: PPUSH
88649: LD_VAR 0 1
88653: PUSH
88654: LD_INT 2
88656: ARRAY
88657: PPUSH
88658: LD_INT 1
88660: PPUSH
88661: CALL_OW 3
88665: PPUSH
88666: CALL_OW 1
88670: ST_TO_ADDR
// tmp := 1 ;
88671: LD_ADDR_VAR 0 2
88675: PUSH
88676: LD_STRING 1
88678: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
88679: LD_ADDR_VAR 0 4
88683: PUSH
88684: LD_VAR 0 4
88688: PUSH
88689: LD_VAR 0 2
88693: STR
88694: ST_TO_ADDR
// end ;
88695: GO 88591
88697: POP
88698: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
88699: LD_STRING getStreamItemsFromMission("
88701: PUSH
88702: LD_VAR 0 3
88706: STR
88707: PUSH
88708: LD_STRING ","
88710: STR
88711: PUSH
88712: LD_VAR 0 4
88716: STR
88717: PUSH
88718: LD_STRING ")
88720: STR
88721: PPUSH
88722: CALL_OW 559
// end else
88726: GO 88735
// ToLua ( getStreamItemsFromMission("","") ) ;
88728: LD_STRING getStreamItemsFromMission("","")
88730: PPUSH
88731: CALL_OW 559
// end ;
88735: LD_VAR 0 1
88739: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
88740: LD_EXP 122
88744: PUSH
88745: LD_EXP 127
88749: AND
88750: IFFALSE 88874
88752: GO 88754
88754: DISABLE
88755: LD_INT 0
88757: PPUSH
88758: PPUSH
// begin enable ;
88759: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
88760: LD_ADDR_VAR 0 2
88764: PUSH
88765: LD_INT 22
88767: PUSH
88768: LD_OWVAR 2
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 2
88779: PUSH
88780: LD_INT 34
88782: PUSH
88783: LD_INT 7
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 34
88792: PUSH
88793: LD_INT 45
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: LD_INT 34
88802: PUSH
88803: LD_INT 28
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: LD_INT 34
88812: PUSH
88813: LD_INT 47
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PPUSH
88831: CALL_OW 69
88835: ST_TO_ADDR
// if not tmp then
88836: LD_VAR 0 2
88840: NOT
88841: IFFALSE 88845
// exit ;
88843: GO 88874
// for i in tmp do
88845: LD_ADDR_VAR 0 1
88849: PUSH
88850: LD_VAR 0 2
88854: PUSH
88855: FOR_IN
88856: IFFALSE 88872
// begin SetLives ( i , 0 ) ;
88858: LD_VAR 0 1
88862: PPUSH
88863: LD_INT 0
88865: PPUSH
88866: CALL_OW 234
// end ;
88870: GO 88855
88872: POP
88873: POP
// end ;
88874: PPOPN 2
88876: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
88877: LD_EXP 122
88881: PUSH
88882: LD_EXP 128
88886: AND
88887: IFFALSE 88971
88889: GO 88891
88891: DISABLE
88892: LD_INT 0
88894: PPUSH
88895: PPUSH
// begin enable ;
88896: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88897: LD_ADDR_VAR 0 2
88901: PUSH
88902: LD_INT 22
88904: PUSH
88905: LD_OWVAR 2
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 32
88916: PUSH
88917: LD_INT 3
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PPUSH
88928: CALL_OW 69
88932: ST_TO_ADDR
// if not tmp then
88933: LD_VAR 0 2
88937: NOT
88938: IFFALSE 88942
// exit ;
88940: GO 88971
// for i in tmp do
88942: LD_ADDR_VAR 0 1
88946: PUSH
88947: LD_VAR 0 2
88951: PUSH
88952: FOR_IN
88953: IFFALSE 88969
// begin SetLives ( i , 0 ) ;
88955: LD_VAR 0 1
88959: PPUSH
88960: LD_INT 0
88962: PPUSH
88963: CALL_OW 234
// end ;
88967: GO 88952
88969: POP
88970: POP
// end ;
88971: PPOPN 2
88973: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88974: LD_EXP 122
88978: PUSH
88979: LD_EXP 125
88983: AND
88984: IFFALSE 89077
88986: GO 88988
88988: DISABLE
88989: LD_INT 0
88991: PPUSH
// begin enable ;
88992: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88993: LD_ADDR_VAR 0 1
88997: PUSH
88998: LD_INT 22
89000: PUSH
89001: LD_OWVAR 2
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 2
89012: PUSH
89013: LD_INT 25
89015: PUSH
89016: LD_INT 5
89018: PUSH
89019: EMPTY
89020: LIST
89021: LIST
89022: PUSH
89023: LD_INT 25
89025: PUSH
89026: LD_INT 9
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 25
89035: PUSH
89036: LD_INT 8
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PPUSH
89053: CALL_OW 69
89057: PUSH
89058: FOR_IN
89059: IFFALSE 89075
// begin SetClass ( i , 1 ) ;
89061: LD_VAR 0 1
89065: PPUSH
89066: LD_INT 1
89068: PPUSH
89069: CALL_OW 336
// end ;
89073: GO 89058
89075: POP
89076: POP
// end ;
89077: PPOPN 1
89079: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89080: LD_EXP 122
89084: PUSH
89085: LD_EXP 126
89089: AND
89090: PUSH
89091: LD_OWVAR 65
89095: PUSH
89096: LD_INT 7
89098: LESS
89099: AND
89100: IFFALSE 89114
89102: GO 89104
89104: DISABLE
// begin enable ;
89105: ENABLE
// game_speed := 7 ;
89106: LD_ADDR_OWVAR 65
89110: PUSH
89111: LD_INT 7
89113: ST_TO_ADDR
// end ;
89114: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89115: LD_EXP 122
89119: PUSH
89120: LD_EXP 129
89124: AND
89125: IFFALSE 89327
89127: GO 89129
89129: DISABLE
89130: LD_INT 0
89132: PPUSH
89133: PPUSH
89134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89135: LD_ADDR_VAR 0 3
89139: PUSH
89140: LD_INT 81
89142: PUSH
89143: LD_OWVAR 2
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 21
89154: PUSH
89155: LD_INT 1
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PPUSH
89166: CALL_OW 69
89170: ST_TO_ADDR
// if not tmp then
89171: LD_VAR 0 3
89175: NOT
89176: IFFALSE 89180
// exit ;
89178: GO 89327
// if tmp > 5 then
89180: LD_VAR 0 3
89184: PUSH
89185: LD_INT 5
89187: GREATER
89188: IFFALSE 89200
// k := 5 else
89190: LD_ADDR_VAR 0 2
89194: PUSH
89195: LD_INT 5
89197: ST_TO_ADDR
89198: GO 89210
// k := tmp ;
89200: LD_ADDR_VAR 0 2
89204: PUSH
89205: LD_VAR 0 3
89209: ST_TO_ADDR
// for i := 1 to k do
89210: LD_ADDR_VAR 0 1
89214: PUSH
89215: DOUBLE
89216: LD_INT 1
89218: DEC
89219: ST_TO_ADDR
89220: LD_VAR 0 2
89224: PUSH
89225: FOR_TO
89226: IFFALSE 89325
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89228: LD_VAR 0 3
89232: PUSH
89233: LD_VAR 0 1
89237: ARRAY
89238: PPUSH
89239: LD_VAR 0 1
89243: PUSH
89244: LD_INT 4
89246: MOD
89247: PUSH
89248: LD_INT 1
89250: PLUS
89251: PPUSH
89252: CALL_OW 259
89256: PUSH
89257: LD_INT 10
89259: LESS
89260: IFFALSE 89323
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89262: LD_VAR 0 3
89266: PUSH
89267: LD_VAR 0 1
89271: ARRAY
89272: PPUSH
89273: LD_VAR 0 1
89277: PUSH
89278: LD_INT 4
89280: MOD
89281: PUSH
89282: LD_INT 1
89284: PLUS
89285: PPUSH
89286: LD_VAR 0 3
89290: PUSH
89291: LD_VAR 0 1
89295: ARRAY
89296: PPUSH
89297: LD_VAR 0 1
89301: PUSH
89302: LD_INT 4
89304: MOD
89305: PUSH
89306: LD_INT 1
89308: PLUS
89309: PPUSH
89310: CALL_OW 259
89314: PUSH
89315: LD_INT 1
89317: PLUS
89318: PPUSH
89319: CALL_OW 237
89323: GO 89225
89325: POP
89326: POP
// end ;
89327: PPOPN 3
89329: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89330: LD_EXP 122
89334: PUSH
89335: LD_EXP 130
89339: AND
89340: IFFALSE 89360
89342: GO 89344
89344: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89345: LD_INT 4
89347: PPUSH
89348: LD_OWVAR 2
89352: PPUSH
89353: LD_INT 0
89355: PPUSH
89356: CALL_OW 324
89360: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89361: LD_EXP 122
89365: PUSH
89366: LD_EXP 159
89370: AND
89371: IFFALSE 89391
89373: GO 89375
89375: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89376: LD_INT 19
89378: PPUSH
89379: LD_OWVAR 2
89383: PPUSH
89384: LD_INT 0
89386: PPUSH
89387: CALL_OW 324
89391: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89392: LD_EXP 122
89396: PUSH
89397: LD_EXP 131
89401: AND
89402: IFFALSE 89504
89404: GO 89406
89406: DISABLE
89407: LD_INT 0
89409: PPUSH
89410: PPUSH
// begin enable ;
89411: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89412: LD_ADDR_VAR 0 2
89416: PUSH
89417: LD_INT 22
89419: PUSH
89420: LD_OWVAR 2
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 2
89431: PUSH
89432: LD_INT 34
89434: PUSH
89435: LD_INT 11
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 34
89444: PUSH
89445: LD_INT 30
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: LIST
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: PPUSH
89461: CALL_OW 69
89465: ST_TO_ADDR
// if not tmp then
89466: LD_VAR 0 2
89470: NOT
89471: IFFALSE 89475
// exit ;
89473: GO 89504
// for i in tmp do
89475: LD_ADDR_VAR 0 1
89479: PUSH
89480: LD_VAR 0 2
89484: PUSH
89485: FOR_IN
89486: IFFALSE 89502
// begin SetLives ( i , 0 ) ;
89488: LD_VAR 0 1
89492: PPUSH
89493: LD_INT 0
89495: PPUSH
89496: CALL_OW 234
// end ;
89500: GO 89485
89502: POP
89503: POP
// end ;
89504: PPOPN 2
89506: END
// every 0 0$1 trigger StreamModeActive and sBunker do
89507: LD_EXP 122
89511: PUSH
89512: LD_EXP 132
89516: AND
89517: IFFALSE 89537
89519: GO 89521
89521: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
89522: LD_INT 32
89524: PPUSH
89525: LD_OWVAR 2
89529: PPUSH
89530: LD_INT 0
89532: PPUSH
89533: CALL_OW 324
89537: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
89538: LD_EXP 122
89542: PUSH
89543: LD_EXP 133
89547: AND
89548: IFFALSE 89729
89550: GO 89552
89552: DISABLE
89553: LD_INT 0
89555: PPUSH
89556: PPUSH
89557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
89558: LD_ADDR_VAR 0 2
89562: PUSH
89563: LD_INT 22
89565: PUSH
89566: LD_OWVAR 2
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 33
89577: PUSH
89578: LD_INT 3
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PPUSH
89589: CALL_OW 69
89593: ST_TO_ADDR
// if not tmp then
89594: LD_VAR 0 2
89598: NOT
89599: IFFALSE 89603
// exit ;
89601: GO 89729
// side := 0 ;
89603: LD_ADDR_VAR 0 3
89607: PUSH
89608: LD_INT 0
89610: ST_TO_ADDR
// for i := 1 to 8 do
89611: LD_ADDR_VAR 0 1
89615: PUSH
89616: DOUBLE
89617: LD_INT 1
89619: DEC
89620: ST_TO_ADDR
89621: LD_INT 8
89623: PUSH
89624: FOR_TO
89625: IFFALSE 89673
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89627: LD_OWVAR 2
89631: PUSH
89632: LD_VAR 0 1
89636: NONEQUAL
89637: PUSH
89638: LD_OWVAR 2
89642: PPUSH
89643: LD_VAR 0 1
89647: PPUSH
89648: CALL_OW 81
89652: PUSH
89653: LD_INT 2
89655: EQUAL
89656: AND
89657: IFFALSE 89671
// begin side := i ;
89659: LD_ADDR_VAR 0 3
89663: PUSH
89664: LD_VAR 0 1
89668: ST_TO_ADDR
// break ;
89669: GO 89673
// end ;
89671: GO 89624
89673: POP
89674: POP
// if not side then
89675: LD_VAR 0 3
89679: NOT
89680: IFFALSE 89684
// exit ;
89682: GO 89729
// for i := 1 to tmp do
89684: LD_ADDR_VAR 0 1
89688: PUSH
89689: DOUBLE
89690: LD_INT 1
89692: DEC
89693: ST_TO_ADDR
89694: LD_VAR 0 2
89698: PUSH
89699: FOR_TO
89700: IFFALSE 89727
// if Prob ( 60 ) then
89702: LD_INT 60
89704: PPUSH
89705: CALL_OW 13
89709: IFFALSE 89725
// SetSide ( i , side ) ;
89711: LD_VAR 0 1
89715: PPUSH
89716: LD_VAR 0 3
89720: PPUSH
89721: CALL_OW 235
89725: GO 89699
89727: POP
89728: POP
// end ;
89729: PPOPN 3
89731: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
89732: LD_EXP 122
89736: PUSH
89737: LD_EXP 135
89741: AND
89742: IFFALSE 89861
89744: GO 89746
89746: DISABLE
89747: LD_INT 0
89749: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
89750: LD_ADDR_VAR 0 1
89754: PUSH
89755: LD_INT 22
89757: PUSH
89758: LD_OWVAR 2
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 21
89769: PUSH
89770: LD_INT 1
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 3
89779: PUSH
89780: LD_INT 23
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: LIST
89798: PPUSH
89799: CALL_OW 69
89803: PUSH
89804: FOR_IN
89805: IFFALSE 89859
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
89807: LD_VAR 0 1
89811: PPUSH
89812: CALL_OW 257
89816: PUSH
89817: LD_INT 1
89819: PUSH
89820: LD_INT 2
89822: PUSH
89823: LD_INT 3
89825: PUSH
89826: LD_INT 4
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: IN
89835: IFFALSE 89857
// SetClass ( un , rand ( 1 , 4 ) ) ;
89837: LD_VAR 0 1
89841: PPUSH
89842: LD_INT 1
89844: PPUSH
89845: LD_INT 4
89847: PPUSH
89848: CALL_OW 12
89852: PPUSH
89853: CALL_OW 336
89857: GO 89804
89859: POP
89860: POP
// end ;
89861: PPOPN 1
89863: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
89864: LD_EXP 122
89868: PUSH
89869: LD_EXP 134
89873: AND
89874: IFFALSE 89953
89876: GO 89878
89878: DISABLE
89879: LD_INT 0
89881: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89882: LD_ADDR_VAR 0 1
89886: PUSH
89887: LD_INT 22
89889: PUSH
89890: LD_OWVAR 2
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 21
89901: PUSH
89902: LD_INT 3
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PPUSH
89913: CALL_OW 69
89917: ST_TO_ADDR
// if not tmp then
89918: LD_VAR 0 1
89922: NOT
89923: IFFALSE 89927
// exit ;
89925: GO 89953
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89927: LD_VAR 0 1
89931: PUSH
89932: LD_INT 1
89934: PPUSH
89935: LD_VAR 0 1
89939: PPUSH
89940: CALL_OW 12
89944: ARRAY
89945: PPUSH
89946: LD_INT 100
89948: PPUSH
89949: CALL_OW 234
// end ;
89953: PPOPN 1
89955: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89956: LD_EXP 122
89960: PUSH
89961: LD_EXP 136
89965: AND
89966: IFFALSE 90064
89968: GO 89970
89970: DISABLE
89971: LD_INT 0
89973: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89974: LD_ADDR_VAR 0 1
89978: PUSH
89979: LD_INT 22
89981: PUSH
89982: LD_OWVAR 2
89986: PUSH
89987: EMPTY
89988: LIST
89989: LIST
89990: PUSH
89991: LD_INT 21
89993: PUSH
89994: LD_INT 1
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PPUSH
90005: CALL_OW 69
90009: ST_TO_ADDR
// if not tmp then
90010: LD_VAR 0 1
90014: NOT
90015: IFFALSE 90019
// exit ;
90017: GO 90064
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90019: LD_VAR 0 1
90023: PUSH
90024: LD_INT 1
90026: PPUSH
90027: LD_VAR 0 1
90031: PPUSH
90032: CALL_OW 12
90036: ARRAY
90037: PPUSH
90038: LD_INT 1
90040: PPUSH
90041: LD_INT 4
90043: PPUSH
90044: CALL_OW 12
90048: PPUSH
90049: LD_INT 3000
90051: PPUSH
90052: LD_INT 9000
90054: PPUSH
90055: CALL_OW 12
90059: PPUSH
90060: CALL_OW 492
// end ;
90064: PPOPN 1
90066: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90067: LD_EXP 122
90071: PUSH
90072: LD_EXP 137
90076: AND
90077: IFFALSE 90097
90079: GO 90081
90081: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90082: LD_INT 1
90084: PPUSH
90085: LD_OWVAR 2
90089: PPUSH
90090: LD_INT 0
90092: PPUSH
90093: CALL_OW 324
90097: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90098: LD_EXP 122
90102: PUSH
90103: LD_EXP 138
90107: AND
90108: IFFALSE 90191
90110: GO 90112
90112: DISABLE
90113: LD_INT 0
90115: PPUSH
90116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90117: LD_ADDR_VAR 0 2
90121: PUSH
90122: LD_INT 22
90124: PUSH
90125: LD_OWVAR 2
90129: PUSH
90130: EMPTY
90131: LIST
90132: LIST
90133: PUSH
90134: LD_INT 21
90136: PUSH
90137: LD_INT 3
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PPUSH
90148: CALL_OW 69
90152: ST_TO_ADDR
// if not tmp then
90153: LD_VAR 0 2
90157: NOT
90158: IFFALSE 90162
// exit ;
90160: GO 90191
// for i in tmp do
90162: LD_ADDR_VAR 0 1
90166: PUSH
90167: LD_VAR 0 2
90171: PUSH
90172: FOR_IN
90173: IFFALSE 90189
// SetBLevel ( i , 10 ) ;
90175: LD_VAR 0 1
90179: PPUSH
90180: LD_INT 10
90182: PPUSH
90183: CALL_OW 241
90187: GO 90172
90189: POP
90190: POP
// end ;
90191: PPOPN 2
90193: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90194: LD_EXP 122
90198: PUSH
90199: LD_EXP 139
90203: AND
90204: IFFALSE 90315
90206: GO 90208
90208: DISABLE
90209: LD_INT 0
90211: PPUSH
90212: PPUSH
90213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90214: LD_ADDR_VAR 0 3
90218: PUSH
90219: LD_INT 22
90221: PUSH
90222: LD_OWVAR 2
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: LD_INT 25
90233: PUSH
90234: LD_INT 1
90236: PUSH
90237: EMPTY
90238: LIST
90239: LIST
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PPUSH
90245: CALL_OW 69
90249: ST_TO_ADDR
// if not tmp then
90250: LD_VAR 0 3
90254: NOT
90255: IFFALSE 90259
// exit ;
90257: GO 90315
// un := tmp [ rand ( 1 , tmp ) ] ;
90259: LD_ADDR_VAR 0 2
90263: PUSH
90264: LD_VAR 0 3
90268: PUSH
90269: LD_INT 1
90271: PPUSH
90272: LD_VAR 0 3
90276: PPUSH
90277: CALL_OW 12
90281: ARRAY
90282: ST_TO_ADDR
// if Crawls ( un ) then
90283: LD_VAR 0 2
90287: PPUSH
90288: CALL_OW 318
90292: IFFALSE 90303
// ComWalk ( un ) ;
90294: LD_VAR 0 2
90298: PPUSH
90299: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90303: LD_VAR 0 2
90307: PPUSH
90308: LD_INT 5
90310: PPUSH
90311: CALL_OW 336
// end ;
90315: PPOPN 3
90317: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90318: LD_EXP 122
90322: PUSH
90323: LD_EXP 140
90327: AND
90328: PUSH
90329: LD_OWVAR 67
90333: PUSH
90334: LD_INT 3
90336: LESS
90337: AND
90338: IFFALSE 90357
90340: GO 90342
90342: DISABLE
// Difficulty := Difficulty + 1 ;
90343: LD_ADDR_OWVAR 67
90347: PUSH
90348: LD_OWVAR 67
90352: PUSH
90353: LD_INT 1
90355: PLUS
90356: ST_TO_ADDR
90357: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90358: LD_EXP 122
90362: PUSH
90363: LD_EXP 141
90367: AND
90368: IFFALSE 90471
90370: GO 90372
90372: DISABLE
90373: LD_INT 0
90375: PPUSH
// begin for i := 1 to 5 do
90376: LD_ADDR_VAR 0 1
90380: PUSH
90381: DOUBLE
90382: LD_INT 1
90384: DEC
90385: ST_TO_ADDR
90386: LD_INT 5
90388: PUSH
90389: FOR_TO
90390: IFFALSE 90469
// begin uc_nation := nation_nature ;
90392: LD_ADDR_OWVAR 21
90396: PUSH
90397: LD_INT 0
90399: ST_TO_ADDR
// uc_side := 0 ;
90400: LD_ADDR_OWVAR 20
90404: PUSH
90405: LD_INT 0
90407: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90408: LD_ADDR_OWVAR 29
90412: PUSH
90413: LD_INT 12
90415: PUSH
90416: LD_INT 12
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: ST_TO_ADDR
// hc_agressivity := 20 ;
90423: LD_ADDR_OWVAR 35
90427: PUSH
90428: LD_INT 20
90430: ST_TO_ADDR
// hc_class := class_tiger ;
90431: LD_ADDR_OWVAR 28
90435: PUSH
90436: LD_INT 14
90438: ST_TO_ADDR
// hc_gallery :=  ;
90439: LD_ADDR_OWVAR 33
90443: PUSH
90444: LD_STRING 
90446: ST_TO_ADDR
// hc_name :=  ;
90447: LD_ADDR_OWVAR 26
90451: PUSH
90452: LD_STRING 
90454: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
90455: CALL_OW 44
90459: PPUSH
90460: LD_INT 0
90462: PPUSH
90463: CALL_OW 51
// end ;
90467: GO 90389
90469: POP
90470: POP
// end ;
90471: PPOPN 1
90473: END
// every 0 0$1 trigger StreamModeActive and sBomb do
90474: LD_EXP 122
90478: PUSH
90479: LD_EXP 142
90483: AND
90484: IFFALSE 90493
90486: GO 90488
90488: DISABLE
// StreamSibBomb ;
90489: CALL 90494 0 0
90493: END
// export function StreamSibBomb ; var i , x , y ; begin
90494: LD_INT 0
90496: PPUSH
90497: PPUSH
90498: PPUSH
90499: PPUSH
// result := false ;
90500: LD_ADDR_VAR 0 1
90504: PUSH
90505: LD_INT 0
90507: ST_TO_ADDR
// for i := 1 to 16 do
90508: LD_ADDR_VAR 0 2
90512: PUSH
90513: DOUBLE
90514: LD_INT 1
90516: DEC
90517: ST_TO_ADDR
90518: LD_INT 16
90520: PUSH
90521: FOR_TO
90522: IFFALSE 90721
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90524: LD_ADDR_VAR 0 3
90528: PUSH
90529: LD_INT 10
90531: PUSH
90532: LD_INT 20
90534: PUSH
90535: LD_INT 30
90537: PUSH
90538: LD_INT 40
90540: PUSH
90541: LD_INT 50
90543: PUSH
90544: LD_INT 60
90546: PUSH
90547: LD_INT 70
90549: PUSH
90550: LD_INT 80
90552: PUSH
90553: LD_INT 90
90555: PUSH
90556: LD_INT 100
90558: PUSH
90559: LD_INT 110
90561: PUSH
90562: LD_INT 120
90564: PUSH
90565: LD_INT 130
90567: PUSH
90568: LD_INT 140
90570: PUSH
90571: LD_INT 150
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 1
90593: PPUSH
90594: LD_INT 15
90596: PPUSH
90597: CALL_OW 12
90601: ARRAY
90602: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90603: LD_ADDR_VAR 0 4
90607: PUSH
90608: LD_INT 10
90610: PUSH
90611: LD_INT 20
90613: PUSH
90614: LD_INT 30
90616: PUSH
90617: LD_INT 40
90619: PUSH
90620: LD_INT 50
90622: PUSH
90623: LD_INT 60
90625: PUSH
90626: LD_INT 70
90628: PUSH
90629: LD_INT 80
90631: PUSH
90632: LD_INT 90
90634: PUSH
90635: LD_INT 100
90637: PUSH
90638: LD_INT 110
90640: PUSH
90641: LD_INT 120
90643: PUSH
90644: LD_INT 130
90646: PUSH
90647: LD_INT 140
90649: PUSH
90650: LD_INT 150
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 1
90672: PPUSH
90673: LD_INT 15
90675: PPUSH
90676: CALL_OW 12
90680: ARRAY
90681: ST_TO_ADDR
// if ValidHex ( x , y ) then
90682: LD_VAR 0 3
90686: PPUSH
90687: LD_VAR 0 4
90691: PPUSH
90692: CALL_OW 488
90696: IFFALSE 90719
// begin result := [ x , y ] ;
90698: LD_ADDR_VAR 0 1
90702: PUSH
90703: LD_VAR 0 3
90707: PUSH
90708: LD_VAR 0 4
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: ST_TO_ADDR
// break ;
90717: GO 90721
// end ; end ;
90719: GO 90521
90721: POP
90722: POP
// if result then
90723: LD_VAR 0 1
90727: IFFALSE 90787
// begin ToLua ( playSibBomb() ) ;
90729: LD_STRING playSibBomb()
90731: PPUSH
90732: CALL_OW 559
// wait ( 0 0$14 ) ;
90736: LD_INT 490
90738: PPUSH
90739: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
90743: LD_VAR 0 1
90747: PUSH
90748: LD_INT 1
90750: ARRAY
90751: PPUSH
90752: LD_VAR 0 1
90756: PUSH
90757: LD_INT 2
90759: ARRAY
90760: PPUSH
90761: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
90765: LD_VAR 0 1
90769: PUSH
90770: LD_INT 1
90772: ARRAY
90773: PPUSH
90774: LD_VAR 0 1
90778: PUSH
90779: LD_INT 2
90781: ARRAY
90782: PPUSH
90783: CALL_OW 429
// end ; end ;
90787: LD_VAR 0 1
90791: RET
// every 0 0$1 trigger StreamModeActive and sReset do
90792: LD_EXP 122
90796: PUSH
90797: LD_EXP 144
90801: AND
90802: IFFALSE 90814
90804: GO 90806
90806: DISABLE
// YouLost (  ) ;
90807: LD_STRING 
90809: PPUSH
90810: CALL_OW 104
90814: END
// every 0 0$1 trigger StreamModeActive and sFog do
90815: LD_EXP 122
90819: PUSH
90820: LD_EXP 143
90824: AND
90825: IFFALSE 90839
90827: GO 90829
90829: DISABLE
// FogOff ( your_side ) ;
90830: LD_OWVAR 2
90834: PPUSH
90835: CALL_OW 344
90839: END
// every 0 0$1 trigger StreamModeActive and sSun do
90840: LD_EXP 122
90844: PUSH
90845: LD_EXP 145
90849: AND
90850: IFFALSE 90878
90852: GO 90854
90854: DISABLE
// begin solar_recharge_percent := 0 ;
90855: LD_ADDR_OWVAR 79
90859: PUSH
90860: LD_INT 0
90862: ST_TO_ADDR
// wait ( 5 5$00 ) ;
90863: LD_INT 10500
90865: PPUSH
90866: CALL_OW 67
// solar_recharge_percent := 100 ;
90870: LD_ADDR_OWVAR 79
90874: PUSH
90875: LD_INT 100
90877: ST_TO_ADDR
// end ;
90878: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
90879: LD_EXP 122
90883: PUSH
90884: LD_EXP 146
90888: AND
90889: IFFALSE 91128
90891: GO 90893
90893: DISABLE
90894: LD_INT 0
90896: PPUSH
90897: PPUSH
90898: PPUSH
// begin tmp := [ ] ;
90899: LD_ADDR_VAR 0 3
90903: PUSH
90904: EMPTY
90905: ST_TO_ADDR
// for i := 1 to 6 do
90906: LD_ADDR_VAR 0 1
90910: PUSH
90911: DOUBLE
90912: LD_INT 1
90914: DEC
90915: ST_TO_ADDR
90916: LD_INT 6
90918: PUSH
90919: FOR_TO
90920: IFFALSE 91025
// begin uc_nation := nation_nature ;
90922: LD_ADDR_OWVAR 21
90926: PUSH
90927: LD_INT 0
90929: ST_TO_ADDR
// uc_side := 0 ;
90930: LD_ADDR_OWVAR 20
90934: PUSH
90935: LD_INT 0
90937: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90938: LD_ADDR_OWVAR 29
90942: PUSH
90943: LD_INT 12
90945: PUSH
90946: LD_INT 12
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: ST_TO_ADDR
// hc_agressivity := 20 ;
90953: LD_ADDR_OWVAR 35
90957: PUSH
90958: LD_INT 20
90960: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90961: LD_ADDR_OWVAR 28
90965: PUSH
90966: LD_INT 17
90968: ST_TO_ADDR
// hc_gallery :=  ;
90969: LD_ADDR_OWVAR 33
90973: PUSH
90974: LD_STRING 
90976: ST_TO_ADDR
// hc_name :=  ;
90977: LD_ADDR_OWVAR 26
90981: PUSH
90982: LD_STRING 
90984: ST_TO_ADDR
// un := CreateHuman ;
90985: LD_ADDR_VAR 0 2
90989: PUSH
90990: CALL_OW 44
90994: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90995: LD_VAR 0 2
90999: PPUSH
91000: LD_INT 1
91002: PPUSH
91003: CALL_OW 51
// tmp := tmp ^ un ;
91007: LD_ADDR_VAR 0 3
91011: PUSH
91012: LD_VAR 0 3
91016: PUSH
91017: LD_VAR 0 2
91021: ADD
91022: ST_TO_ADDR
// end ;
91023: GO 90919
91025: POP
91026: POP
// repeat wait ( 0 0$1 ) ;
91027: LD_INT 35
91029: PPUSH
91030: CALL_OW 67
// for un in tmp do
91034: LD_ADDR_VAR 0 2
91038: PUSH
91039: LD_VAR 0 3
91043: PUSH
91044: FOR_IN
91045: IFFALSE 91119
// begin if IsDead ( un ) then
91047: LD_VAR 0 2
91051: PPUSH
91052: CALL_OW 301
91056: IFFALSE 91076
// begin tmp := tmp diff un ;
91058: LD_ADDR_VAR 0 3
91062: PUSH
91063: LD_VAR 0 3
91067: PUSH
91068: LD_VAR 0 2
91072: DIFF
91073: ST_TO_ADDR
// continue ;
91074: GO 91044
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91076: LD_VAR 0 2
91080: PPUSH
91081: LD_INT 3
91083: PUSH
91084: LD_INT 22
91086: PUSH
91087: LD_INT 0
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PPUSH
91098: CALL_OW 69
91102: PPUSH
91103: LD_VAR 0 2
91107: PPUSH
91108: CALL_OW 74
91112: PPUSH
91113: CALL_OW 115
// end ;
91117: GO 91044
91119: POP
91120: POP
// until not tmp ;
91121: LD_VAR 0 3
91125: NOT
91126: IFFALSE 91027
// end ;
91128: PPOPN 3
91130: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91131: LD_EXP 122
91135: PUSH
91136: LD_EXP 147
91140: AND
91141: IFFALSE 91195
91143: GO 91145
91145: DISABLE
// begin ToLua ( displayTroll(); ) ;
91146: LD_STRING displayTroll();
91148: PPUSH
91149: CALL_OW 559
// wait ( 3 3$00 ) ;
91153: LD_INT 6300
91155: PPUSH
91156: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91160: LD_STRING hideTroll();
91162: PPUSH
91163: CALL_OW 559
// wait ( 1 1$00 ) ;
91167: LD_INT 2100
91169: PPUSH
91170: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91174: LD_STRING displayTroll();
91176: PPUSH
91177: CALL_OW 559
// wait ( 1 1$00 ) ;
91181: LD_INT 2100
91183: PPUSH
91184: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91188: LD_STRING hideTroll();
91190: PPUSH
91191: CALL_OW 559
// end ;
91195: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91196: LD_EXP 122
91200: PUSH
91201: LD_EXP 148
91205: AND
91206: IFFALSE 91269
91208: GO 91210
91210: DISABLE
91211: LD_INT 0
91213: PPUSH
// begin p := 0 ;
91214: LD_ADDR_VAR 0 1
91218: PUSH
91219: LD_INT 0
91221: ST_TO_ADDR
// repeat game_speed := 1 ;
91222: LD_ADDR_OWVAR 65
91226: PUSH
91227: LD_INT 1
91229: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91230: LD_INT 35
91232: PPUSH
91233: CALL_OW 67
// p := p + 1 ;
91237: LD_ADDR_VAR 0 1
91241: PUSH
91242: LD_VAR 0 1
91246: PUSH
91247: LD_INT 1
91249: PLUS
91250: ST_TO_ADDR
// until p >= 60 ;
91251: LD_VAR 0 1
91255: PUSH
91256: LD_INT 60
91258: GREATEREQUAL
91259: IFFALSE 91222
// game_speed := 4 ;
91261: LD_ADDR_OWVAR 65
91265: PUSH
91266: LD_INT 4
91268: ST_TO_ADDR
// end ;
91269: PPOPN 1
91271: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91272: LD_EXP 122
91276: PUSH
91277: LD_EXP 149
91281: AND
91282: IFFALSE 91428
91284: GO 91286
91286: DISABLE
91287: LD_INT 0
91289: PPUSH
91290: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91291: LD_ADDR_VAR 0 1
91295: PUSH
91296: LD_INT 22
91298: PUSH
91299: LD_OWVAR 2
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 2
91310: PUSH
91311: LD_INT 30
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 30
91323: PUSH
91324: LD_INT 1
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: LIST
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PPUSH
91340: CALL_OW 69
91344: ST_TO_ADDR
// if not depot then
91345: LD_VAR 0 1
91349: NOT
91350: IFFALSE 91354
// exit ;
91352: GO 91428
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91354: LD_ADDR_VAR 0 2
91358: PUSH
91359: LD_VAR 0 1
91363: PUSH
91364: LD_INT 1
91366: PPUSH
91367: LD_VAR 0 1
91371: PPUSH
91372: CALL_OW 12
91376: ARRAY
91377: PPUSH
91378: CALL_OW 274
91382: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91383: LD_VAR 0 2
91387: PPUSH
91388: LD_INT 1
91390: PPUSH
91391: LD_INT 0
91393: PPUSH
91394: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91398: LD_VAR 0 2
91402: PPUSH
91403: LD_INT 2
91405: PPUSH
91406: LD_INT 0
91408: PPUSH
91409: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91413: LD_VAR 0 2
91417: PPUSH
91418: LD_INT 3
91420: PPUSH
91421: LD_INT 0
91423: PPUSH
91424: CALL_OW 277
// end ;
91428: PPOPN 2
91430: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91431: LD_EXP 122
91435: PUSH
91436: LD_EXP 150
91440: AND
91441: IFFALSE 91538
91443: GO 91445
91445: DISABLE
91446: LD_INT 0
91448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91449: LD_ADDR_VAR 0 1
91453: PUSH
91454: LD_INT 22
91456: PUSH
91457: LD_OWVAR 2
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 21
91468: PUSH
91469: LD_INT 1
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 3
91478: PUSH
91479: LD_INT 23
91481: PUSH
91482: LD_INT 0
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: LIST
91497: PPUSH
91498: CALL_OW 69
91502: ST_TO_ADDR
// if not tmp then
91503: LD_VAR 0 1
91507: NOT
91508: IFFALSE 91512
// exit ;
91510: GO 91538
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
91512: LD_VAR 0 1
91516: PUSH
91517: LD_INT 1
91519: PPUSH
91520: LD_VAR 0 1
91524: PPUSH
91525: CALL_OW 12
91529: ARRAY
91530: PPUSH
91531: LD_INT 200
91533: PPUSH
91534: CALL_OW 234
// end ;
91538: PPOPN 1
91540: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
91541: LD_EXP 122
91545: PUSH
91546: LD_EXP 151
91550: AND
91551: IFFALSE 91630
91553: GO 91555
91555: DISABLE
91556: LD_INT 0
91558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
91559: LD_ADDR_VAR 0 1
91563: PUSH
91564: LD_INT 22
91566: PUSH
91567: LD_OWVAR 2
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 21
91578: PUSH
91579: LD_INT 2
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PPUSH
91590: CALL_OW 69
91594: ST_TO_ADDR
// if not tmp then
91595: LD_VAR 0 1
91599: NOT
91600: IFFALSE 91604
// exit ;
91602: GO 91630
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
91604: LD_VAR 0 1
91608: PUSH
91609: LD_INT 1
91611: PPUSH
91612: LD_VAR 0 1
91616: PPUSH
91617: CALL_OW 12
91621: ARRAY
91622: PPUSH
91623: LD_INT 60
91625: PPUSH
91626: CALL_OW 234
// end ;
91630: PPOPN 1
91632: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91633: LD_EXP 122
91637: PUSH
91638: LD_EXP 152
91642: AND
91643: IFFALSE 91742
91645: GO 91647
91647: DISABLE
91648: LD_INT 0
91650: PPUSH
91651: PPUSH
// begin enable ;
91652: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91653: LD_ADDR_VAR 0 1
91657: PUSH
91658: LD_INT 22
91660: PUSH
91661: LD_OWVAR 2
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 61
91672: PUSH
91673: EMPTY
91674: LIST
91675: PUSH
91676: LD_INT 33
91678: PUSH
91679: LD_INT 2
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: LIST
91690: PPUSH
91691: CALL_OW 69
91695: ST_TO_ADDR
// if not tmp then
91696: LD_VAR 0 1
91700: NOT
91701: IFFALSE 91705
// exit ;
91703: GO 91742
// for i in tmp do
91705: LD_ADDR_VAR 0 2
91709: PUSH
91710: LD_VAR 0 1
91714: PUSH
91715: FOR_IN
91716: IFFALSE 91740
// if IsControledBy ( i ) then
91718: LD_VAR 0 2
91722: PPUSH
91723: CALL_OW 312
91727: IFFALSE 91738
// ComUnlink ( i ) ;
91729: LD_VAR 0 2
91733: PPUSH
91734: CALL_OW 136
91738: GO 91715
91740: POP
91741: POP
// end ;
91742: PPOPN 2
91744: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
91745: LD_EXP 122
91749: PUSH
91750: LD_EXP 153
91754: AND
91755: IFFALSE 91895
91757: GO 91759
91759: DISABLE
91760: LD_INT 0
91762: PPUSH
91763: PPUSH
// begin ToLua ( displayPowell(); ) ;
91764: LD_STRING displayPowell();
91766: PPUSH
91767: CALL_OW 559
// uc_side := 0 ;
91771: LD_ADDR_OWVAR 20
91775: PUSH
91776: LD_INT 0
91778: ST_TO_ADDR
// uc_nation := 2 ;
91779: LD_ADDR_OWVAR 21
91783: PUSH
91784: LD_INT 2
91786: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
91787: LD_ADDR_OWVAR 37
91791: PUSH
91792: LD_INT 14
91794: ST_TO_ADDR
// vc_engine := engine_siberite ;
91795: LD_ADDR_OWVAR 39
91799: PUSH
91800: LD_INT 3
91802: ST_TO_ADDR
// vc_control := control_apeman ;
91803: LD_ADDR_OWVAR 38
91807: PUSH
91808: LD_INT 5
91810: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
91811: LD_ADDR_OWVAR 40
91815: PUSH
91816: LD_INT 29
91818: ST_TO_ADDR
// un := CreateVehicle ;
91819: LD_ADDR_VAR 0 2
91823: PUSH
91824: CALL_OW 45
91828: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91829: LD_VAR 0 2
91833: PPUSH
91834: LD_INT 1
91836: PPUSH
91837: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91841: LD_INT 35
91843: PPUSH
91844: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91848: LD_VAR 0 2
91852: PPUSH
91853: LD_INT 22
91855: PUSH
91856: LD_OWVAR 2
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PPUSH
91865: CALL_OW 69
91869: PPUSH
91870: LD_VAR 0 2
91874: PPUSH
91875: CALL_OW 74
91879: PPUSH
91880: CALL_OW 115
// until IsDead ( un ) ;
91884: LD_VAR 0 2
91888: PPUSH
91889: CALL_OW 301
91893: IFFALSE 91841
// end ;
91895: PPOPN 2
91897: END
// every 0 0$1 trigger StreamModeActive and sStu do
91898: LD_EXP 122
91902: PUSH
91903: LD_EXP 161
91907: AND
91908: IFFALSE 91924
91910: GO 91912
91912: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91913: LD_STRING displayStucuk();
91915: PPUSH
91916: CALL_OW 559
// ResetFog ;
91920: CALL_OW 335
// end ;
91924: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91925: LD_EXP 122
91929: PUSH
91930: LD_EXP 154
91934: AND
91935: IFFALSE 92076
91937: GO 91939
91939: DISABLE
91940: LD_INT 0
91942: PPUSH
91943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91944: LD_ADDR_VAR 0 2
91948: PUSH
91949: LD_INT 22
91951: PUSH
91952: LD_OWVAR 2
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 21
91963: PUSH
91964: LD_INT 1
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PPUSH
91975: CALL_OW 69
91979: ST_TO_ADDR
// if not tmp then
91980: LD_VAR 0 2
91984: NOT
91985: IFFALSE 91989
// exit ;
91987: GO 92076
// un := tmp [ rand ( 1 , tmp ) ] ;
91989: LD_ADDR_VAR 0 1
91993: PUSH
91994: LD_VAR 0 2
91998: PUSH
91999: LD_INT 1
92001: PPUSH
92002: LD_VAR 0 2
92006: PPUSH
92007: CALL_OW 12
92011: ARRAY
92012: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92013: LD_VAR 0 1
92017: PPUSH
92018: LD_INT 0
92020: PPUSH
92021: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92025: LD_VAR 0 1
92029: PPUSH
92030: LD_OWVAR 3
92034: PUSH
92035: LD_VAR 0 1
92039: DIFF
92040: PPUSH
92041: LD_VAR 0 1
92045: PPUSH
92046: CALL_OW 74
92050: PPUSH
92051: CALL_OW 115
// wait ( 0 0$20 ) ;
92055: LD_INT 700
92057: PPUSH
92058: CALL_OW 67
// SetSide ( un , your_side ) ;
92062: LD_VAR 0 1
92066: PPUSH
92067: LD_OWVAR 2
92071: PPUSH
92072: CALL_OW 235
// end ;
92076: PPOPN 2
92078: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92079: LD_EXP 122
92083: PUSH
92084: LD_EXP 155
92088: AND
92089: IFFALSE 92195
92091: GO 92093
92093: DISABLE
92094: LD_INT 0
92096: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92097: LD_ADDR_VAR 0 1
92101: PUSH
92102: LD_INT 22
92104: PUSH
92105: LD_OWVAR 2
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 2
92116: PUSH
92117: LD_INT 30
92119: PUSH
92120: LD_INT 0
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 30
92129: PUSH
92130: LD_INT 1
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: LIST
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PPUSH
92146: CALL_OW 69
92150: ST_TO_ADDR
// if not depot then
92151: LD_VAR 0 1
92155: NOT
92156: IFFALSE 92160
// exit ;
92158: GO 92195
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92160: LD_VAR 0 1
92164: PUSH
92165: LD_INT 1
92167: ARRAY
92168: PPUSH
92169: CALL_OW 250
92173: PPUSH
92174: LD_VAR 0 1
92178: PUSH
92179: LD_INT 1
92181: ARRAY
92182: PPUSH
92183: CALL_OW 251
92187: PPUSH
92188: LD_INT 70
92190: PPUSH
92191: CALL_OW 495
// end ;
92195: PPOPN 1
92197: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92198: LD_EXP 122
92202: PUSH
92203: LD_EXP 156
92207: AND
92208: IFFALSE 92419
92210: GO 92212
92212: DISABLE
92213: LD_INT 0
92215: PPUSH
92216: PPUSH
92217: PPUSH
92218: PPUSH
92219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92220: LD_ADDR_VAR 0 5
92224: PUSH
92225: LD_INT 22
92227: PUSH
92228: LD_OWVAR 2
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 21
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PPUSH
92251: CALL_OW 69
92255: ST_TO_ADDR
// if not tmp then
92256: LD_VAR 0 5
92260: NOT
92261: IFFALSE 92265
// exit ;
92263: GO 92419
// for i in tmp do
92265: LD_ADDR_VAR 0 1
92269: PUSH
92270: LD_VAR 0 5
92274: PUSH
92275: FOR_IN
92276: IFFALSE 92417
// begin d := rand ( 0 , 5 ) ;
92278: LD_ADDR_VAR 0 4
92282: PUSH
92283: LD_INT 0
92285: PPUSH
92286: LD_INT 5
92288: PPUSH
92289: CALL_OW 12
92293: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92294: LD_ADDR_VAR 0 2
92298: PUSH
92299: LD_VAR 0 1
92303: PPUSH
92304: CALL_OW 250
92308: PPUSH
92309: LD_VAR 0 4
92313: PPUSH
92314: LD_INT 3
92316: PPUSH
92317: LD_INT 12
92319: PPUSH
92320: CALL_OW 12
92324: PPUSH
92325: CALL_OW 272
92329: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92330: LD_ADDR_VAR 0 3
92334: PUSH
92335: LD_VAR 0 1
92339: PPUSH
92340: CALL_OW 251
92344: PPUSH
92345: LD_VAR 0 4
92349: PPUSH
92350: LD_INT 3
92352: PPUSH
92353: LD_INT 12
92355: PPUSH
92356: CALL_OW 12
92360: PPUSH
92361: CALL_OW 273
92365: ST_TO_ADDR
// if ValidHex ( x , y ) then
92366: LD_VAR 0 2
92370: PPUSH
92371: LD_VAR 0 3
92375: PPUSH
92376: CALL_OW 488
92380: IFFALSE 92415
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92382: LD_VAR 0 1
92386: PPUSH
92387: LD_VAR 0 2
92391: PPUSH
92392: LD_VAR 0 3
92396: PPUSH
92397: LD_INT 3
92399: PPUSH
92400: LD_INT 6
92402: PPUSH
92403: CALL_OW 12
92407: PPUSH
92408: LD_INT 1
92410: PPUSH
92411: CALL_OW 483
// end ;
92415: GO 92275
92417: POP
92418: POP
// end ;
92419: PPOPN 5
92421: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92422: LD_EXP 122
92426: PUSH
92427: LD_EXP 157
92431: AND
92432: IFFALSE 92526
92434: GO 92436
92436: DISABLE
92437: LD_INT 0
92439: PPUSH
92440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
92441: LD_ADDR_VAR 0 2
92445: PUSH
92446: LD_INT 22
92448: PUSH
92449: LD_OWVAR 2
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 32
92460: PUSH
92461: LD_INT 1
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PUSH
92468: LD_INT 21
92470: PUSH
92471: LD_INT 2
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: LIST
92482: PPUSH
92483: CALL_OW 69
92487: ST_TO_ADDR
// if not tmp then
92488: LD_VAR 0 2
92492: NOT
92493: IFFALSE 92497
// exit ;
92495: GO 92526
// for i in tmp do
92497: LD_ADDR_VAR 0 1
92501: PUSH
92502: LD_VAR 0 2
92506: PUSH
92507: FOR_IN
92508: IFFALSE 92524
// SetFuel ( i , 0 ) ;
92510: LD_VAR 0 1
92514: PPUSH
92515: LD_INT 0
92517: PPUSH
92518: CALL_OW 240
92522: GO 92507
92524: POP
92525: POP
// end ;
92526: PPOPN 2
92528: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
92529: LD_EXP 122
92533: PUSH
92534: LD_EXP 158
92538: AND
92539: IFFALSE 92605
92541: GO 92543
92543: DISABLE
92544: LD_INT 0
92546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92547: LD_ADDR_VAR 0 1
92551: PUSH
92552: LD_INT 22
92554: PUSH
92555: LD_OWVAR 2
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 30
92566: PUSH
92567: LD_INT 29
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PPUSH
92578: CALL_OW 69
92582: ST_TO_ADDR
// if not tmp then
92583: LD_VAR 0 1
92587: NOT
92588: IFFALSE 92592
// exit ;
92590: GO 92605
// DestroyUnit ( tmp [ 1 ] ) ;
92592: LD_VAR 0 1
92596: PUSH
92597: LD_INT 1
92599: ARRAY
92600: PPUSH
92601: CALL_OW 65
// end ;
92605: PPOPN 1
92607: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
92608: LD_EXP 122
92612: PUSH
92613: LD_EXP 160
92617: AND
92618: IFFALSE 92747
92620: GO 92622
92622: DISABLE
92623: LD_INT 0
92625: PPUSH
// begin uc_side := 0 ;
92626: LD_ADDR_OWVAR 20
92630: PUSH
92631: LD_INT 0
92633: ST_TO_ADDR
// uc_nation := nation_arabian ;
92634: LD_ADDR_OWVAR 21
92638: PUSH
92639: LD_INT 2
92641: ST_TO_ADDR
// hc_gallery :=  ;
92642: LD_ADDR_OWVAR 33
92646: PUSH
92647: LD_STRING 
92649: ST_TO_ADDR
// hc_name :=  ;
92650: LD_ADDR_OWVAR 26
92654: PUSH
92655: LD_STRING 
92657: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92658: LD_INT 1
92660: PPUSH
92661: LD_INT 11
92663: PPUSH
92664: LD_INT 10
92666: PPUSH
92667: CALL_OW 380
// un := CreateHuman ;
92671: LD_ADDR_VAR 0 1
92675: PUSH
92676: CALL_OW 44
92680: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92681: LD_VAR 0 1
92685: PPUSH
92686: LD_INT 1
92688: PPUSH
92689: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92693: LD_INT 35
92695: PPUSH
92696: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92700: LD_VAR 0 1
92704: PPUSH
92705: LD_INT 22
92707: PUSH
92708: LD_OWVAR 2
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PPUSH
92717: CALL_OW 69
92721: PPUSH
92722: LD_VAR 0 1
92726: PPUSH
92727: CALL_OW 74
92731: PPUSH
92732: CALL_OW 115
// until IsDead ( un ) ;
92736: LD_VAR 0 1
92740: PPUSH
92741: CALL_OW 301
92745: IFFALSE 92693
// end ;
92747: PPOPN 1
92749: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
92750: LD_EXP 122
92754: PUSH
92755: LD_EXP 162
92759: AND
92760: IFFALSE 92772
92762: GO 92764
92764: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
92765: LD_STRING earthquake(getX(game), 0, 32)
92767: PPUSH
92768: CALL_OW 559
92772: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
92773: LD_EXP 122
92777: PUSH
92778: LD_EXP 163
92782: AND
92783: IFFALSE 92874
92785: GO 92787
92787: DISABLE
92788: LD_INT 0
92790: PPUSH
// begin enable ;
92791: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
92792: LD_ADDR_VAR 0 1
92796: PUSH
92797: LD_INT 22
92799: PUSH
92800: LD_OWVAR 2
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 21
92811: PUSH
92812: LD_INT 2
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 33
92821: PUSH
92822: LD_INT 3
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: LIST
92833: PPUSH
92834: CALL_OW 69
92838: ST_TO_ADDR
// if not tmp then
92839: LD_VAR 0 1
92843: NOT
92844: IFFALSE 92848
// exit ;
92846: GO 92874
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92848: LD_VAR 0 1
92852: PUSH
92853: LD_INT 1
92855: PPUSH
92856: LD_VAR 0 1
92860: PPUSH
92861: CALL_OW 12
92865: ARRAY
92866: PPUSH
92867: LD_INT 1
92869: PPUSH
92870: CALL_OW 234
// end ;
92874: PPOPN 1
92876: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
92877: LD_EXP 122
92881: PUSH
92882: LD_EXP 164
92886: AND
92887: IFFALSE 93028
92889: GO 92891
92891: DISABLE
92892: LD_INT 0
92894: PPUSH
92895: PPUSH
92896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92897: LD_ADDR_VAR 0 3
92901: PUSH
92902: LD_INT 22
92904: PUSH
92905: LD_OWVAR 2
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 25
92916: PUSH
92917: LD_INT 1
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PPUSH
92928: CALL_OW 69
92932: ST_TO_ADDR
// if not tmp then
92933: LD_VAR 0 3
92937: NOT
92938: IFFALSE 92942
// exit ;
92940: GO 93028
// un := tmp [ rand ( 1 , tmp ) ] ;
92942: LD_ADDR_VAR 0 2
92946: PUSH
92947: LD_VAR 0 3
92951: PUSH
92952: LD_INT 1
92954: PPUSH
92955: LD_VAR 0 3
92959: PPUSH
92960: CALL_OW 12
92964: ARRAY
92965: ST_TO_ADDR
// if Crawls ( un ) then
92966: LD_VAR 0 2
92970: PPUSH
92971: CALL_OW 318
92975: IFFALSE 92986
// ComWalk ( un ) ;
92977: LD_VAR 0 2
92981: PPUSH
92982: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92986: LD_VAR 0 2
92990: PPUSH
92991: LD_INT 9
92993: PPUSH
92994: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92998: LD_INT 28
93000: PPUSH
93001: LD_OWVAR 2
93005: PPUSH
93006: LD_INT 2
93008: PPUSH
93009: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93013: LD_INT 29
93015: PPUSH
93016: LD_OWVAR 2
93020: PPUSH
93021: LD_INT 2
93023: PPUSH
93024: CALL_OW 322
// end ;
93028: PPOPN 3
93030: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93031: LD_EXP 122
93035: PUSH
93036: LD_EXP 165
93040: AND
93041: IFFALSE 93152
93043: GO 93045
93045: DISABLE
93046: LD_INT 0
93048: PPUSH
93049: PPUSH
93050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93051: LD_ADDR_VAR 0 3
93055: PUSH
93056: LD_INT 22
93058: PUSH
93059: LD_OWVAR 2
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 25
93070: PUSH
93071: LD_INT 1
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PPUSH
93082: CALL_OW 69
93086: ST_TO_ADDR
// if not tmp then
93087: LD_VAR 0 3
93091: NOT
93092: IFFALSE 93096
// exit ;
93094: GO 93152
// un := tmp [ rand ( 1 , tmp ) ] ;
93096: LD_ADDR_VAR 0 2
93100: PUSH
93101: LD_VAR 0 3
93105: PUSH
93106: LD_INT 1
93108: PPUSH
93109: LD_VAR 0 3
93113: PPUSH
93114: CALL_OW 12
93118: ARRAY
93119: ST_TO_ADDR
// if Crawls ( un ) then
93120: LD_VAR 0 2
93124: PPUSH
93125: CALL_OW 318
93129: IFFALSE 93140
// ComWalk ( un ) ;
93131: LD_VAR 0 2
93135: PPUSH
93136: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93140: LD_VAR 0 2
93144: PPUSH
93145: LD_INT 8
93147: PPUSH
93148: CALL_OW 336
// end ;
93152: PPOPN 3
93154: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93155: LD_EXP 122
93159: PUSH
93160: LD_EXP 166
93164: AND
93165: IFFALSE 93309
93167: GO 93169
93169: DISABLE
93170: LD_INT 0
93172: PPUSH
93173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93174: LD_ADDR_VAR 0 2
93178: PUSH
93179: LD_INT 22
93181: PUSH
93182: LD_OWVAR 2
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PUSH
93191: LD_INT 21
93193: PUSH
93194: LD_INT 2
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 2
93203: PUSH
93204: LD_INT 34
93206: PUSH
93207: LD_INT 12
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 34
93216: PUSH
93217: LD_INT 51
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 34
93226: PUSH
93227: LD_INT 32
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: LIST
93244: PPUSH
93245: CALL_OW 69
93249: ST_TO_ADDR
// if not tmp then
93250: LD_VAR 0 2
93254: NOT
93255: IFFALSE 93259
// exit ;
93257: GO 93309
// for i in tmp do
93259: LD_ADDR_VAR 0 1
93263: PUSH
93264: LD_VAR 0 2
93268: PUSH
93269: FOR_IN
93270: IFFALSE 93307
// if GetCargo ( i , mat_artifact ) = 0 then
93272: LD_VAR 0 1
93276: PPUSH
93277: LD_INT 4
93279: PPUSH
93280: CALL_OW 289
93284: PUSH
93285: LD_INT 0
93287: EQUAL
93288: IFFALSE 93305
// SetCargo ( i , mat_siberit , 100 ) ;
93290: LD_VAR 0 1
93294: PPUSH
93295: LD_INT 3
93297: PPUSH
93298: LD_INT 100
93300: PPUSH
93301: CALL_OW 290
93305: GO 93269
93307: POP
93308: POP
// end ;
93309: PPOPN 2
93311: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93312: LD_EXP 122
93316: PUSH
93317: LD_EXP 167
93321: AND
93322: IFFALSE 93505
93324: GO 93326
93326: DISABLE
93327: LD_INT 0
93329: PPUSH
93330: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93331: LD_ADDR_VAR 0 2
93335: PUSH
93336: LD_INT 22
93338: PUSH
93339: LD_OWVAR 2
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PPUSH
93348: CALL_OW 69
93352: ST_TO_ADDR
// if not tmp then
93353: LD_VAR 0 2
93357: NOT
93358: IFFALSE 93362
// exit ;
93360: GO 93505
// for i := 1 to 2 do
93362: LD_ADDR_VAR 0 1
93366: PUSH
93367: DOUBLE
93368: LD_INT 1
93370: DEC
93371: ST_TO_ADDR
93372: LD_INT 2
93374: PUSH
93375: FOR_TO
93376: IFFALSE 93503
// begin uc_side := your_side ;
93378: LD_ADDR_OWVAR 20
93382: PUSH
93383: LD_OWVAR 2
93387: ST_TO_ADDR
// uc_nation := nation_american ;
93388: LD_ADDR_OWVAR 21
93392: PUSH
93393: LD_INT 1
93395: ST_TO_ADDR
// vc_chassis := us_morphling ;
93396: LD_ADDR_OWVAR 37
93400: PUSH
93401: LD_INT 5
93403: ST_TO_ADDR
// vc_engine := engine_siberite ;
93404: LD_ADDR_OWVAR 39
93408: PUSH
93409: LD_INT 3
93411: ST_TO_ADDR
// vc_control := control_computer ;
93412: LD_ADDR_OWVAR 38
93416: PUSH
93417: LD_INT 3
93419: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93420: LD_ADDR_OWVAR 40
93424: PUSH
93425: LD_INT 10
93427: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93428: LD_VAR 0 2
93432: PUSH
93433: LD_INT 1
93435: ARRAY
93436: PPUSH
93437: CALL_OW 310
93441: NOT
93442: IFFALSE 93489
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
93444: CALL_OW 45
93448: PPUSH
93449: LD_VAR 0 2
93453: PUSH
93454: LD_INT 1
93456: ARRAY
93457: PPUSH
93458: CALL_OW 250
93462: PPUSH
93463: LD_VAR 0 2
93467: PUSH
93468: LD_INT 1
93470: ARRAY
93471: PPUSH
93472: CALL_OW 251
93476: PPUSH
93477: LD_INT 12
93479: PPUSH
93480: LD_INT 1
93482: PPUSH
93483: CALL_OW 50
93487: GO 93501
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
93489: CALL_OW 45
93493: PPUSH
93494: LD_INT 1
93496: PPUSH
93497: CALL_OW 51
// end ;
93501: GO 93375
93503: POP
93504: POP
// end ;
93505: PPOPN 2
93507: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
93508: LD_EXP 122
93512: PUSH
93513: LD_EXP 168
93517: AND
93518: IFFALSE 93740
93520: GO 93522
93522: DISABLE
93523: LD_INT 0
93525: PPUSH
93526: PPUSH
93527: PPUSH
93528: PPUSH
93529: PPUSH
93530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93531: LD_ADDR_VAR 0 6
93535: PUSH
93536: LD_INT 22
93538: PUSH
93539: LD_OWVAR 2
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 21
93550: PUSH
93551: LD_INT 1
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: LD_INT 3
93560: PUSH
93561: LD_INT 23
93563: PUSH
93564: LD_INT 0
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: LIST
93579: PPUSH
93580: CALL_OW 69
93584: ST_TO_ADDR
// if not tmp then
93585: LD_VAR 0 6
93589: NOT
93590: IFFALSE 93594
// exit ;
93592: GO 93740
// s1 := rand ( 1 , 4 ) ;
93594: LD_ADDR_VAR 0 2
93598: PUSH
93599: LD_INT 1
93601: PPUSH
93602: LD_INT 4
93604: PPUSH
93605: CALL_OW 12
93609: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
93610: LD_ADDR_VAR 0 4
93614: PUSH
93615: LD_VAR 0 6
93619: PUSH
93620: LD_INT 1
93622: ARRAY
93623: PPUSH
93624: LD_VAR 0 2
93628: PPUSH
93629: CALL_OW 259
93633: ST_TO_ADDR
// if s1 = 1 then
93634: LD_VAR 0 2
93638: PUSH
93639: LD_INT 1
93641: EQUAL
93642: IFFALSE 93662
// s2 := rand ( 2 , 4 ) else
93644: LD_ADDR_VAR 0 3
93648: PUSH
93649: LD_INT 2
93651: PPUSH
93652: LD_INT 4
93654: PPUSH
93655: CALL_OW 12
93659: ST_TO_ADDR
93660: GO 93670
// s2 := 1 ;
93662: LD_ADDR_VAR 0 3
93666: PUSH
93667: LD_INT 1
93669: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93670: LD_ADDR_VAR 0 5
93674: PUSH
93675: LD_VAR 0 6
93679: PUSH
93680: LD_INT 1
93682: ARRAY
93683: PPUSH
93684: LD_VAR 0 3
93688: PPUSH
93689: CALL_OW 259
93693: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93694: LD_VAR 0 6
93698: PUSH
93699: LD_INT 1
93701: ARRAY
93702: PPUSH
93703: LD_VAR 0 2
93707: PPUSH
93708: LD_VAR 0 5
93712: PPUSH
93713: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93717: LD_VAR 0 6
93721: PUSH
93722: LD_INT 1
93724: ARRAY
93725: PPUSH
93726: LD_VAR 0 3
93730: PPUSH
93731: LD_VAR 0 4
93735: PPUSH
93736: CALL_OW 237
// end ;
93740: PPOPN 6
93742: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
93743: LD_EXP 122
93747: PUSH
93748: LD_EXP 169
93752: AND
93753: IFFALSE 93832
93755: GO 93757
93757: DISABLE
93758: LD_INT 0
93760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
93761: LD_ADDR_VAR 0 1
93765: PUSH
93766: LD_INT 22
93768: PUSH
93769: LD_OWVAR 2
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: LD_INT 30
93780: PUSH
93781: LD_INT 3
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PPUSH
93792: CALL_OW 69
93796: ST_TO_ADDR
// if not tmp then
93797: LD_VAR 0 1
93801: NOT
93802: IFFALSE 93806
// exit ;
93804: GO 93832
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93806: LD_VAR 0 1
93810: PUSH
93811: LD_INT 1
93813: PPUSH
93814: LD_VAR 0 1
93818: PPUSH
93819: CALL_OW 12
93823: ARRAY
93824: PPUSH
93825: LD_INT 1
93827: PPUSH
93828: CALL_OW 234
// end ;
93832: PPOPN 1
93834: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
93835: LD_EXP 122
93839: PUSH
93840: LD_EXP 170
93844: AND
93845: IFFALSE 93957
93847: GO 93849
93849: DISABLE
93850: LD_INT 0
93852: PPUSH
93853: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
93854: LD_ADDR_VAR 0 2
93858: PUSH
93859: LD_INT 22
93861: PUSH
93862: LD_OWVAR 2
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 2
93873: PUSH
93874: LD_INT 30
93876: PUSH
93877: LD_INT 27
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: LD_INT 30
93886: PUSH
93887: LD_INT 26
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 30
93896: PUSH
93897: LD_INT 28
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PPUSH
93914: CALL_OW 69
93918: ST_TO_ADDR
// if not tmp then
93919: LD_VAR 0 2
93923: NOT
93924: IFFALSE 93928
// exit ;
93926: GO 93957
// for i in tmp do
93928: LD_ADDR_VAR 0 1
93932: PUSH
93933: LD_VAR 0 2
93937: PUSH
93938: FOR_IN
93939: IFFALSE 93955
// SetLives ( i , 1 ) ;
93941: LD_VAR 0 1
93945: PPUSH
93946: LD_INT 1
93948: PPUSH
93949: CALL_OW 234
93953: GO 93938
93955: POP
93956: POP
// end ;
93957: PPOPN 2
93959: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93960: LD_EXP 122
93964: PUSH
93965: LD_EXP 171
93969: AND
93970: IFFALSE 94244
93972: GO 93974
93974: DISABLE
93975: LD_INT 0
93977: PPUSH
93978: PPUSH
93979: PPUSH
// begin i := rand ( 1 , 7 ) ;
93980: LD_ADDR_VAR 0 1
93984: PUSH
93985: LD_INT 1
93987: PPUSH
93988: LD_INT 7
93990: PPUSH
93991: CALL_OW 12
93995: ST_TO_ADDR
// case i of 1 :
93996: LD_VAR 0 1
94000: PUSH
94001: LD_INT 1
94003: DOUBLE
94004: EQUAL
94005: IFTRUE 94009
94007: GO 94019
94009: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94010: LD_STRING earthquake(getX(game), 0, 32)
94012: PPUSH
94013: CALL_OW 559
94017: GO 94244
94019: LD_INT 2
94021: DOUBLE
94022: EQUAL
94023: IFTRUE 94027
94025: GO 94041
94027: POP
// begin ToLua ( displayStucuk(); ) ;
94028: LD_STRING displayStucuk();
94030: PPUSH
94031: CALL_OW 559
// ResetFog ;
94035: CALL_OW 335
// end ; 3 :
94039: GO 94244
94041: LD_INT 3
94043: DOUBLE
94044: EQUAL
94045: IFTRUE 94049
94047: GO 94153
94049: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94050: LD_ADDR_VAR 0 2
94054: PUSH
94055: LD_INT 22
94057: PUSH
94058: LD_OWVAR 2
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: LD_INT 25
94069: PUSH
94070: LD_INT 1
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PPUSH
94081: CALL_OW 69
94085: ST_TO_ADDR
// if not tmp then
94086: LD_VAR 0 2
94090: NOT
94091: IFFALSE 94095
// exit ;
94093: GO 94244
// un := tmp [ rand ( 1 , tmp ) ] ;
94095: LD_ADDR_VAR 0 3
94099: PUSH
94100: LD_VAR 0 2
94104: PUSH
94105: LD_INT 1
94107: PPUSH
94108: LD_VAR 0 2
94112: PPUSH
94113: CALL_OW 12
94117: ARRAY
94118: ST_TO_ADDR
// if Crawls ( un ) then
94119: LD_VAR 0 3
94123: PPUSH
94124: CALL_OW 318
94128: IFFALSE 94139
// ComWalk ( un ) ;
94130: LD_VAR 0 3
94134: PPUSH
94135: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94139: LD_VAR 0 3
94143: PPUSH
94144: LD_INT 8
94146: PPUSH
94147: CALL_OW 336
// end ; 4 :
94151: GO 94244
94153: LD_INT 4
94155: DOUBLE
94156: EQUAL
94157: IFTRUE 94161
94159: GO 94222
94161: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94162: LD_ADDR_VAR 0 2
94166: PUSH
94167: LD_INT 22
94169: PUSH
94170: LD_OWVAR 2
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 30
94181: PUSH
94182: LD_INT 29
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PPUSH
94193: CALL_OW 69
94197: ST_TO_ADDR
// if not tmp then
94198: LD_VAR 0 2
94202: NOT
94203: IFFALSE 94207
// exit ;
94205: GO 94244
// DestroyUnit ( tmp [ 1 ] ) ;
94207: LD_VAR 0 2
94211: PUSH
94212: LD_INT 1
94214: ARRAY
94215: PPUSH
94216: CALL_OW 65
// end ; 5 .. 7 :
94220: GO 94244
94222: LD_INT 5
94224: DOUBLE
94225: GREATEREQUAL
94226: IFFALSE 94234
94228: LD_INT 7
94230: DOUBLE
94231: LESSEQUAL
94232: IFTRUE 94236
94234: GO 94243
94236: POP
// StreamSibBomb ; end ;
94237: CALL 90494 0 0
94241: GO 94244
94243: POP
// end ;
94244: PPOPN 3
94246: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94247: LD_EXP 122
94251: PUSH
94252: LD_EXP 172
94256: AND
94257: IFFALSE 94413
94259: GO 94261
94261: DISABLE
94262: LD_INT 0
94264: PPUSH
94265: PPUSH
94266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94267: LD_ADDR_VAR 0 2
94271: PUSH
94272: LD_INT 81
94274: PUSH
94275: LD_OWVAR 2
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 2
94286: PUSH
94287: LD_INT 21
94289: PUSH
94290: LD_INT 1
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 21
94299: PUSH
94300: LD_INT 2
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: LIST
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PPUSH
94316: CALL_OW 69
94320: ST_TO_ADDR
// if not tmp then
94321: LD_VAR 0 2
94325: NOT
94326: IFFALSE 94330
// exit ;
94328: GO 94413
// p := 0 ;
94330: LD_ADDR_VAR 0 3
94334: PUSH
94335: LD_INT 0
94337: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94338: LD_INT 35
94340: PPUSH
94341: CALL_OW 67
// p := p + 1 ;
94345: LD_ADDR_VAR 0 3
94349: PUSH
94350: LD_VAR 0 3
94354: PUSH
94355: LD_INT 1
94357: PLUS
94358: ST_TO_ADDR
// for i in tmp do
94359: LD_ADDR_VAR 0 1
94363: PUSH
94364: LD_VAR 0 2
94368: PUSH
94369: FOR_IN
94370: IFFALSE 94401
// if GetLives ( i ) < 1000 then
94372: LD_VAR 0 1
94376: PPUSH
94377: CALL_OW 256
94381: PUSH
94382: LD_INT 1000
94384: LESS
94385: IFFALSE 94399
// SetLives ( i , 1000 ) ;
94387: LD_VAR 0 1
94391: PPUSH
94392: LD_INT 1000
94394: PPUSH
94395: CALL_OW 234
94399: GO 94369
94401: POP
94402: POP
// until p > 20 ;
94403: LD_VAR 0 3
94407: PUSH
94408: LD_INT 20
94410: GREATER
94411: IFFALSE 94338
// end ;
94413: PPOPN 3
94415: END
// every 0 0$1 trigger StreamModeActive and sTime do
94416: LD_EXP 122
94420: PUSH
94421: LD_EXP 173
94425: AND
94426: IFFALSE 94461
94428: GO 94430
94430: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94431: LD_INT 28
94433: PPUSH
94434: LD_OWVAR 2
94438: PPUSH
94439: LD_INT 2
94441: PPUSH
94442: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
94446: LD_INT 30
94448: PPUSH
94449: LD_OWVAR 2
94453: PPUSH
94454: LD_INT 2
94456: PPUSH
94457: CALL_OW 322
// end ;
94461: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
94462: LD_EXP 122
94466: PUSH
94467: LD_EXP 174
94471: AND
94472: IFFALSE 94593
94474: GO 94476
94476: DISABLE
94477: LD_INT 0
94479: PPUSH
94480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94481: LD_ADDR_VAR 0 2
94485: PUSH
94486: LD_INT 22
94488: PUSH
94489: LD_OWVAR 2
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 21
94500: PUSH
94501: LD_INT 1
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 3
94510: PUSH
94511: LD_INT 23
94513: PUSH
94514: LD_INT 0
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: LIST
94529: PPUSH
94530: CALL_OW 69
94534: ST_TO_ADDR
// if not tmp then
94535: LD_VAR 0 2
94539: NOT
94540: IFFALSE 94544
// exit ;
94542: GO 94593
// for i in tmp do
94544: LD_ADDR_VAR 0 1
94548: PUSH
94549: LD_VAR 0 2
94553: PUSH
94554: FOR_IN
94555: IFFALSE 94591
// begin if Crawls ( i ) then
94557: LD_VAR 0 1
94561: PPUSH
94562: CALL_OW 318
94566: IFFALSE 94577
// ComWalk ( i ) ;
94568: LD_VAR 0 1
94572: PPUSH
94573: CALL_OW 138
// SetClass ( i , 2 ) ;
94577: LD_VAR 0 1
94581: PPUSH
94582: LD_INT 2
94584: PPUSH
94585: CALL_OW 336
// end ;
94589: GO 94554
94591: POP
94592: POP
// end ;
94593: PPOPN 2
94595: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
94596: LD_EXP 122
94600: PUSH
94601: LD_EXP 175
94605: AND
94606: IFFALSE 94887
94608: GO 94610
94610: DISABLE
94611: LD_INT 0
94613: PPUSH
94614: PPUSH
94615: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94616: LD_OWVAR 2
94620: PPUSH
94621: LD_INT 9
94623: PPUSH
94624: LD_INT 1
94626: PPUSH
94627: LD_INT 1
94629: PPUSH
94630: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94634: LD_INT 9
94636: PPUSH
94637: LD_OWVAR 2
94641: PPUSH
94642: CALL_OW 343
// uc_side := 9 ;
94646: LD_ADDR_OWVAR 20
94650: PUSH
94651: LD_INT 9
94653: ST_TO_ADDR
// uc_nation := 2 ;
94654: LD_ADDR_OWVAR 21
94658: PUSH
94659: LD_INT 2
94661: ST_TO_ADDR
// hc_name := Dark Warrior ;
94662: LD_ADDR_OWVAR 26
94666: PUSH
94667: LD_STRING Dark Warrior
94669: ST_TO_ADDR
// hc_gallery :=  ;
94670: LD_ADDR_OWVAR 33
94674: PUSH
94675: LD_STRING 
94677: ST_TO_ADDR
// hc_noskilllimit := true ;
94678: LD_ADDR_OWVAR 76
94682: PUSH
94683: LD_INT 1
94685: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94686: LD_ADDR_OWVAR 31
94690: PUSH
94691: LD_INT 30
94693: PUSH
94694: LD_INT 30
94696: PUSH
94697: LD_INT 30
94699: PUSH
94700: LD_INT 30
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: ST_TO_ADDR
// un := CreateHuman ;
94709: LD_ADDR_VAR 0 3
94713: PUSH
94714: CALL_OW 44
94718: ST_TO_ADDR
// hc_noskilllimit := false ;
94719: LD_ADDR_OWVAR 76
94723: PUSH
94724: LD_INT 0
94726: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94727: LD_VAR 0 3
94731: PPUSH
94732: LD_INT 1
94734: PPUSH
94735: CALL_OW 51
// p := 0 ;
94739: LD_ADDR_VAR 0 2
94743: PUSH
94744: LD_INT 0
94746: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94747: LD_INT 35
94749: PPUSH
94750: CALL_OW 67
// p := p + 1 ;
94754: LD_ADDR_VAR 0 2
94758: PUSH
94759: LD_VAR 0 2
94763: PUSH
94764: LD_INT 1
94766: PLUS
94767: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
94768: LD_VAR 0 3
94772: PPUSH
94773: CALL_OW 256
94777: PUSH
94778: LD_INT 1000
94780: LESS
94781: IFFALSE 94795
// SetLives ( un , 1000 ) ;
94783: LD_VAR 0 3
94787: PPUSH
94788: LD_INT 1000
94790: PPUSH
94791: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
94795: LD_VAR 0 3
94799: PPUSH
94800: LD_INT 81
94802: PUSH
94803: LD_OWVAR 2
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 91
94814: PUSH
94815: LD_VAR 0 3
94819: PUSH
94820: LD_INT 30
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: LIST
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PPUSH
94832: CALL_OW 69
94836: PPUSH
94837: LD_VAR 0 3
94841: PPUSH
94842: CALL_OW 74
94846: PPUSH
94847: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
94851: LD_VAR 0 2
94855: PUSH
94856: LD_INT 60
94858: GREATER
94859: PUSH
94860: LD_VAR 0 3
94864: PPUSH
94865: CALL_OW 301
94869: OR
94870: IFFALSE 94747
// if un then
94872: LD_VAR 0 3
94876: IFFALSE 94887
// RemoveUnit ( un ) ;
94878: LD_VAR 0 3
94882: PPUSH
94883: CALL_OW 64
// end ;
94887: PPOPN 3
94889: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94890: LD_INT 0
94892: PPUSH
// case cmd of 301 :
94893: LD_VAR 0 1
94897: PUSH
94898: LD_INT 301
94900: DOUBLE
94901: EQUAL
94902: IFTRUE 94906
94904: GO 94938
94906: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
94907: LD_VAR 0 6
94911: PPUSH
94912: LD_VAR 0 7
94916: PPUSH
94917: LD_VAR 0 8
94921: PPUSH
94922: LD_VAR 0 4
94926: PPUSH
94927: LD_VAR 0 5
94931: PPUSH
94932: CALL 96139 0 5
94936: GO 95059
94938: LD_INT 302
94940: DOUBLE
94941: EQUAL
94942: IFTRUE 94946
94944: GO 94983
94946: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
94947: LD_VAR 0 6
94951: PPUSH
94952: LD_VAR 0 7
94956: PPUSH
94957: LD_VAR 0 8
94961: PPUSH
94962: LD_VAR 0 9
94966: PPUSH
94967: LD_VAR 0 4
94971: PPUSH
94972: LD_VAR 0 5
94976: PPUSH
94977: CALL 96230 0 6
94981: GO 95059
94983: LD_INT 303
94985: DOUBLE
94986: EQUAL
94987: IFTRUE 94991
94989: GO 95028
94991: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
94992: LD_VAR 0 6
94996: PPUSH
94997: LD_VAR 0 7
95001: PPUSH
95002: LD_VAR 0 8
95006: PPUSH
95007: LD_VAR 0 9
95011: PPUSH
95012: LD_VAR 0 4
95016: PPUSH
95017: LD_VAR 0 5
95021: PPUSH
95022: CALL 95064 0 6
95026: GO 95059
95028: LD_INT 304
95030: DOUBLE
95031: EQUAL
95032: IFTRUE 95036
95034: GO 95058
95036: POP
// hHackTeleport ( unit , x , y ) ; end ;
95037: LD_VAR 0 2
95041: PPUSH
95042: LD_VAR 0 4
95046: PPUSH
95047: LD_VAR 0 5
95051: PPUSH
95052: CALL 96823 0 3
95056: GO 95059
95058: POP
// end ;
95059: LD_VAR 0 12
95063: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95064: LD_INT 0
95066: PPUSH
95067: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95068: LD_VAR 0 1
95072: PUSH
95073: LD_INT 1
95075: LESS
95076: PUSH
95077: LD_VAR 0 1
95081: PUSH
95082: LD_INT 3
95084: GREATER
95085: OR
95086: PUSH
95087: LD_VAR 0 5
95091: PPUSH
95092: LD_VAR 0 6
95096: PPUSH
95097: CALL_OW 428
95101: OR
95102: IFFALSE 95106
// exit ;
95104: GO 95826
// uc_side := your_side ;
95106: LD_ADDR_OWVAR 20
95110: PUSH
95111: LD_OWVAR 2
95115: ST_TO_ADDR
// uc_nation := nation ;
95116: LD_ADDR_OWVAR 21
95120: PUSH
95121: LD_VAR 0 1
95125: ST_TO_ADDR
// bc_level = 1 ;
95126: LD_ADDR_OWVAR 43
95130: PUSH
95131: LD_INT 1
95133: ST_TO_ADDR
// case btype of 1 :
95134: LD_VAR 0 2
95138: PUSH
95139: LD_INT 1
95141: DOUBLE
95142: EQUAL
95143: IFTRUE 95147
95145: GO 95158
95147: POP
// bc_type := b_depot ; 2 :
95148: LD_ADDR_OWVAR 42
95152: PUSH
95153: LD_INT 0
95155: ST_TO_ADDR
95156: GO 95770
95158: LD_INT 2
95160: DOUBLE
95161: EQUAL
95162: IFTRUE 95166
95164: GO 95177
95166: POP
// bc_type := b_warehouse ; 3 :
95167: LD_ADDR_OWVAR 42
95171: PUSH
95172: LD_INT 1
95174: ST_TO_ADDR
95175: GO 95770
95177: LD_INT 3
95179: DOUBLE
95180: EQUAL
95181: IFTRUE 95185
95183: GO 95196
95185: POP
// bc_type := b_lab ; 4 .. 9 :
95186: LD_ADDR_OWVAR 42
95190: PUSH
95191: LD_INT 6
95193: ST_TO_ADDR
95194: GO 95770
95196: LD_INT 4
95198: DOUBLE
95199: GREATEREQUAL
95200: IFFALSE 95208
95202: LD_INT 9
95204: DOUBLE
95205: LESSEQUAL
95206: IFTRUE 95210
95208: GO 95262
95210: POP
// begin bc_type := b_lab_half ;
95211: LD_ADDR_OWVAR 42
95215: PUSH
95216: LD_INT 7
95218: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
95219: LD_ADDR_OWVAR 44
95223: PUSH
95224: LD_INT 10
95226: PUSH
95227: LD_INT 11
95229: PUSH
95230: LD_INT 12
95232: PUSH
95233: LD_INT 15
95235: PUSH
95236: LD_INT 14
95238: PUSH
95239: LD_INT 13
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: PUSH
95250: LD_VAR 0 2
95254: PUSH
95255: LD_INT 3
95257: MINUS
95258: ARRAY
95259: ST_TO_ADDR
// end ; 10 .. 13 :
95260: GO 95770
95262: LD_INT 10
95264: DOUBLE
95265: GREATEREQUAL
95266: IFFALSE 95274
95268: LD_INT 13
95270: DOUBLE
95271: LESSEQUAL
95272: IFTRUE 95276
95274: GO 95353
95276: POP
// begin bc_type := b_lab_full ;
95277: LD_ADDR_OWVAR 42
95281: PUSH
95282: LD_INT 8
95284: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
95285: LD_ADDR_OWVAR 44
95289: PUSH
95290: LD_INT 10
95292: PUSH
95293: LD_INT 12
95295: PUSH
95296: LD_INT 14
95298: PUSH
95299: LD_INT 13
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: PUSH
95308: LD_VAR 0 2
95312: PUSH
95313: LD_INT 9
95315: MINUS
95316: ARRAY
95317: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
95318: LD_ADDR_OWVAR 45
95322: PUSH
95323: LD_INT 11
95325: PUSH
95326: LD_INT 15
95328: PUSH
95329: LD_INT 12
95331: PUSH
95332: LD_INT 15
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: PUSH
95341: LD_VAR 0 2
95345: PUSH
95346: LD_INT 9
95348: MINUS
95349: ARRAY
95350: ST_TO_ADDR
// end ; 14 :
95351: GO 95770
95353: LD_INT 14
95355: DOUBLE
95356: EQUAL
95357: IFTRUE 95361
95359: GO 95372
95361: POP
// bc_type := b_workshop ; 15 :
95362: LD_ADDR_OWVAR 42
95366: PUSH
95367: LD_INT 2
95369: ST_TO_ADDR
95370: GO 95770
95372: LD_INT 15
95374: DOUBLE
95375: EQUAL
95376: IFTRUE 95380
95378: GO 95391
95380: POP
// bc_type := b_factory ; 16 :
95381: LD_ADDR_OWVAR 42
95385: PUSH
95386: LD_INT 3
95388: ST_TO_ADDR
95389: GO 95770
95391: LD_INT 16
95393: DOUBLE
95394: EQUAL
95395: IFTRUE 95399
95397: GO 95410
95399: POP
// bc_type := b_ext_gun ; 17 :
95400: LD_ADDR_OWVAR 42
95404: PUSH
95405: LD_INT 17
95407: ST_TO_ADDR
95408: GO 95770
95410: LD_INT 17
95412: DOUBLE
95413: EQUAL
95414: IFTRUE 95418
95416: GO 95446
95418: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
95419: LD_ADDR_OWVAR 42
95423: PUSH
95424: LD_INT 19
95426: PUSH
95427: LD_INT 23
95429: PUSH
95430: LD_INT 19
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: LIST
95437: PUSH
95438: LD_VAR 0 1
95442: ARRAY
95443: ST_TO_ADDR
95444: GO 95770
95446: LD_INT 18
95448: DOUBLE
95449: EQUAL
95450: IFTRUE 95454
95452: GO 95465
95454: POP
// bc_type := b_ext_radar ; 19 :
95455: LD_ADDR_OWVAR 42
95459: PUSH
95460: LD_INT 20
95462: ST_TO_ADDR
95463: GO 95770
95465: LD_INT 19
95467: DOUBLE
95468: EQUAL
95469: IFTRUE 95473
95471: GO 95484
95473: POP
// bc_type := b_ext_radio ; 20 :
95474: LD_ADDR_OWVAR 42
95478: PUSH
95479: LD_INT 22
95481: ST_TO_ADDR
95482: GO 95770
95484: LD_INT 20
95486: DOUBLE
95487: EQUAL
95488: IFTRUE 95492
95490: GO 95503
95492: POP
// bc_type := b_ext_siberium ; 21 :
95493: LD_ADDR_OWVAR 42
95497: PUSH
95498: LD_INT 21
95500: ST_TO_ADDR
95501: GO 95770
95503: LD_INT 21
95505: DOUBLE
95506: EQUAL
95507: IFTRUE 95511
95509: GO 95522
95511: POP
// bc_type := b_ext_computer ; 22 :
95512: LD_ADDR_OWVAR 42
95516: PUSH
95517: LD_INT 24
95519: ST_TO_ADDR
95520: GO 95770
95522: LD_INT 22
95524: DOUBLE
95525: EQUAL
95526: IFTRUE 95530
95528: GO 95541
95530: POP
// bc_type := b_ext_track ; 23 :
95531: LD_ADDR_OWVAR 42
95535: PUSH
95536: LD_INT 16
95538: ST_TO_ADDR
95539: GO 95770
95541: LD_INT 23
95543: DOUBLE
95544: EQUAL
95545: IFTRUE 95549
95547: GO 95560
95549: POP
// bc_type := b_ext_laser ; 24 :
95550: LD_ADDR_OWVAR 42
95554: PUSH
95555: LD_INT 25
95557: ST_TO_ADDR
95558: GO 95770
95560: LD_INT 24
95562: DOUBLE
95563: EQUAL
95564: IFTRUE 95568
95566: GO 95579
95568: POP
// bc_type := b_control_tower ; 25 :
95569: LD_ADDR_OWVAR 42
95573: PUSH
95574: LD_INT 36
95576: ST_TO_ADDR
95577: GO 95770
95579: LD_INT 25
95581: DOUBLE
95582: EQUAL
95583: IFTRUE 95587
95585: GO 95598
95587: POP
// bc_type := b_breastwork ; 26 :
95588: LD_ADDR_OWVAR 42
95592: PUSH
95593: LD_INT 31
95595: ST_TO_ADDR
95596: GO 95770
95598: LD_INT 26
95600: DOUBLE
95601: EQUAL
95602: IFTRUE 95606
95604: GO 95617
95606: POP
// bc_type := b_bunker ; 27 :
95607: LD_ADDR_OWVAR 42
95611: PUSH
95612: LD_INT 32
95614: ST_TO_ADDR
95615: GO 95770
95617: LD_INT 27
95619: DOUBLE
95620: EQUAL
95621: IFTRUE 95625
95623: GO 95636
95625: POP
// bc_type := b_turret ; 28 :
95626: LD_ADDR_OWVAR 42
95630: PUSH
95631: LD_INT 33
95633: ST_TO_ADDR
95634: GO 95770
95636: LD_INT 28
95638: DOUBLE
95639: EQUAL
95640: IFTRUE 95644
95642: GO 95655
95644: POP
// bc_type := b_armoury ; 29 :
95645: LD_ADDR_OWVAR 42
95649: PUSH
95650: LD_INT 4
95652: ST_TO_ADDR
95653: GO 95770
95655: LD_INT 29
95657: DOUBLE
95658: EQUAL
95659: IFTRUE 95663
95661: GO 95674
95663: POP
// bc_type := b_barracks ; 30 :
95664: LD_ADDR_OWVAR 42
95668: PUSH
95669: LD_INT 5
95671: ST_TO_ADDR
95672: GO 95770
95674: LD_INT 30
95676: DOUBLE
95677: EQUAL
95678: IFTRUE 95682
95680: GO 95693
95682: POP
// bc_type := b_solar_power ; 31 :
95683: LD_ADDR_OWVAR 42
95687: PUSH
95688: LD_INT 27
95690: ST_TO_ADDR
95691: GO 95770
95693: LD_INT 31
95695: DOUBLE
95696: EQUAL
95697: IFTRUE 95701
95699: GO 95712
95701: POP
// bc_type := b_oil_power ; 32 :
95702: LD_ADDR_OWVAR 42
95706: PUSH
95707: LD_INT 26
95709: ST_TO_ADDR
95710: GO 95770
95712: LD_INT 32
95714: DOUBLE
95715: EQUAL
95716: IFTRUE 95720
95718: GO 95731
95720: POP
// bc_type := b_siberite_power ; 33 :
95721: LD_ADDR_OWVAR 42
95725: PUSH
95726: LD_INT 28
95728: ST_TO_ADDR
95729: GO 95770
95731: LD_INT 33
95733: DOUBLE
95734: EQUAL
95735: IFTRUE 95739
95737: GO 95750
95739: POP
// bc_type := b_oil_mine ; 34 :
95740: LD_ADDR_OWVAR 42
95744: PUSH
95745: LD_INT 29
95747: ST_TO_ADDR
95748: GO 95770
95750: LD_INT 34
95752: DOUBLE
95753: EQUAL
95754: IFTRUE 95758
95756: GO 95769
95758: POP
// bc_type := b_siberite_mine ; end ;
95759: LD_ADDR_OWVAR 42
95763: PUSH
95764: LD_INT 30
95766: ST_TO_ADDR
95767: GO 95770
95769: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
95770: LD_ADDR_VAR 0 8
95774: PUSH
95775: LD_VAR 0 5
95779: PPUSH
95780: LD_VAR 0 6
95784: PPUSH
95785: LD_VAR 0 3
95789: PPUSH
95790: CALL_OW 47
95794: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
95795: LD_OWVAR 42
95799: PUSH
95800: LD_INT 32
95802: PUSH
95803: LD_INT 33
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: IN
95810: IFFALSE 95826
// PlaceWeaponTurret ( b , weapon ) ;
95812: LD_VAR 0 8
95816: PPUSH
95817: LD_VAR 0 4
95821: PPUSH
95822: CALL_OW 431
// end ;
95826: LD_VAR 0 7
95830: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
95831: LD_INT 0
95833: PPUSH
95834: PPUSH
95835: PPUSH
95836: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95837: LD_ADDR_VAR 0 4
95841: PUSH
95842: LD_INT 22
95844: PUSH
95845: LD_OWVAR 2
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 30
95859: PUSH
95860: LD_INT 0
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 30
95869: PUSH
95870: LD_INT 1
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: LIST
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PPUSH
95886: CALL_OW 69
95890: ST_TO_ADDR
// if not tmp then
95891: LD_VAR 0 4
95895: NOT
95896: IFFALSE 95900
// exit ;
95898: GO 95959
// for i in tmp do
95900: LD_ADDR_VAR 0 2
95904: PUSH
95905: LD_VAR 0 4
95909: PUSH
95910: FOR_IN
95911: IFFALSE 95957
// for j = 1 to 3 do
95913: LD_ADDR_VAR 0 3
95917: PUSH
95918: DOUBLE
95919: LD_INT 1
95921: DEC
95922: ST_TO_ADDR
95923: LD_INT 3
95925: PUSH
95926: FOR_TO
95927: IFFALSE 95953
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95929: LD_VAR 0 2
95933: PPUSH
95934: CALL_OW 274
95938: PPUSH
95939: LD_VAR 0 3
95943: PPUSH
95944: LD_INT 99999
95946: PPUSH
95947: CALL_OW 277
95951: GO 95926
95953: POP
95954: POP
95955: GO 95910
95957: POP
95958: POP
// end ;
95959: LD_VAR 0 1
95963: RET
// export function hHackSetLevel10 ; var i , j ; begin
95964: LD_INT 0
95966: PPUSH
95967: PPUSH
95968: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95969: LD_ADDR_VAR 0 2
95973: PUSH
95974: LD_INT 21
95976: PUSH
95977: LD_INT 1
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PPUSH
95984: CALL_OW 69
95988: PUSH
95989: FOR_IN
95990: IFFALSE 96042
// if IsSelected ( i ) then
95992: LD_VAR 0 2
95996: PPUSH
95997: CALL_OW 306
96001: IFFALSE 96040
// begin for j := 1 to 4 do
96003: LD_ADDR_VAR 0 3
96007: PUSH
96008: DOUBLE
96009: LD_INT 1
96011: DEC
96012: ST_TO_ADDR
96013: LD_INT 4
96015: PUSH
96016: FOR_TO
96017: IFFALSE 96038
// SetSkill ( i , j , 10 ) ;
96019: LD_VAR 0 2
96023: PPUSH
96024: LD_VAR 0 3
96028: PPUSH
96029: LD_INT 10
96031: PPUSH
96032: CALL_OW 237
96036: GO 96016
96038: POP
96039: POP
// end ;
96040: GO 95989
96042: POP
96043: POP
// end ;
96044: LD_VAR 0 1
96048: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
96049: LD_INT 0
96051: PPUSH
96052: PPUSH
96053: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
96054: LD_ADDR_VAR 0 2
96058: PUSH
96059: LD_INT 22
96061: PUSH
96062: LD_OWVAR 2
96066: PUSH
96067: EMPTY
96068: LIST
96069: LIST
96070: PUSH
96071: LD_INT 21
96073: PUSH
96074: LD_INT 1
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PPUSH
96085: CALL_OW 69
96089: PUSH
96090: FOR_IN
96091: IFFALSE 96132
// begin for j := 1 to 4 do
96093: LD_ADDR_VAR 0 3
96097: PUSH
96098: DOUBLE
96099: LD_INT 1
96101: DEC
96102: ST_TO_ADDR
96103: LD_INT 4
96105: PUSH
96106: FOR_TO
96107: IFFALSE 96128
// SetSkill ( i , j , 10 ) ;
96109: LD_VAR 0 2
96113: PPUSH
96114: LD_VAR 0 3
96118: PPUSH
96119: LD_INT 10
96121: PPUSH
96122: CALL_OW 237
96126: GO 96106
96128: POP
96129: POP
// end ;
96130: GO 96090
96132: POP
96133: POP
// end ;
96134: LD_VAR 0 1
96138: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
96139: LD_INT 0
96141: PPUSH
// uc_side := your_side ;
96142: LD_ADDR_OWVAR 20
96146: PUSH
96147: LD_OWVAR 2
96151: ST_TO_ADDR
// uc_nation := nation ;
96152: LD_ADDR_OWVAR 21
96156: PUSH
96157: LD_VAR 0 1
96161: ST_TO_ADDR
// InitHc ;
96162: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
96166: LD_INT 0
96168: PPUSH
96169: LD_VAR 0 2
96173: PPUSH
96174: LD_VAR 0 3
96178: PPUSH
96179: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
96183: LD_VAR 0 4
96187: PPUSH
96188: LD_VAR 0 5
96192: PPUSH
96193: CALL_OW 428
96197: PUSH
96198: LD_INT 0
96200: EQUAL
96201: IFFALSE 96225
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
96203: CALL_OW 44
96207: PPUSH
96208: LD_VAR 0 4
96212: PPUSH
96213: LD_VAR 0 5
96217: PPUSH
96218: LD_INT 1
96220: PPUSH
96221: CALL_OW 48
// end ;
96225: LD_VAR 0 6
96229: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
96230: LD_INT 0
96232: PPUSH
96233: PPUSH
// uc_side := your_side ;
96234: LD_ADDR_OWVAR 20
96238: PUSH
96239: LD_OWVAR 2
96243: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
96244: LD_VAR 0 1
96248: PUSH
96249: LD_INT 1
96251: PUSH
96252: LD_INT 2
96254: PUSH
96255: LD_INT 3
96257: PUSH
96258: LD_INT 4
96260: PUSH
96261: LD_INT 5
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: IN
96271: IFFALSE 96283
// uc_nation := nation_american else
96273: LD_ADDR_OWVAR 21
96277: PUSH
96278: LD_INT 1
96280: ST_TO_ADDR
96281: GO 96326
// if chassis in [ 11 , 12 , 13 , 14 ] then
96283: LD_VAR 0 1
96287: PUSH
96288: LD_INT 11
96290: PUSH
96291: LD_INT 12
96293: PUSH
96294: LD_INT 13
96296: PUSH
96297: LD_INT 14
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: IN
96306: IFFALSE 96318
// uc_nation := nation_arabian else
96308: LD_ADDR_OWVAR 21
96312: PUSH
96313: LD_INT 2
96315: ST_TO_ADDR
96316: GO 96326
// uc_nation := nation_russian ;
96318: LD_ADDR_OWVAR 21
96322: PUSH
96323: LD_INT 3
96325: ST_TO_ADDR
// vc_chassis := chassis ;
96326: LD_ADDR_OWVAR 37
96330: PUSH
96331: LD_VAR 0 1
96335: ST_TO_ADDR
// vc_engine := engine ;
96336: LD_ADDR_OWVAR 39
96340: PUSH
96341: LD_VAR 0 2
96345: ST_TO_ADDR
// vc_control := control ;
96346: LD_ADDR_OWVAR 38
96350: PUSH
96351: LD_VAR 0 3
96355: ST_TO_ADDR
// vc_weapon := weapon ;
96356: LD_ADDR_OWVAR 40
96360: PUSH
96361: LD_VAR 0 4
96365: ST_TO_ADDR
// un := CreateVehicle ;
96366: LD_ADDR_VAR 0 8
96370: PUSH
96371: CALL_OW 45
96375: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
96376: LD_VAR 0 8
96380: PPUSH
96381: LD_INT 0
96383: PPUSH
96384: LD_INT 5
96386: PPUSH
96387: CALL_OW 12
96391: PPUSH
96392: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
96396: LD_VAR 0 8
96400: PPUSH
96401: LD_VAR 0 5
96405: PPUSH
96406: LD_VAR 0 6
96410: PPUSH
96411: LD_INT 1
96413: PPUSH
96414: CALL_OW 48
// end ;
96418: LD_VAR 0 7
96422: RET
// export hInvincible ; every 1 do
96423: GO 96425
96425: DISABLE
// hInvincible := [ ] ;
96426: LD_ADDR_EXP 176
96430: PUSH
96431: EMPTY
96432: ST_TO_ADDR
96433: END
// every 10 do var i ;
96434: GO 96436
96436: DISABLE
96437: LD_INT 0
96439: PPUSH
// begin enable ;
96440: ENABLE
// if not hInvincible then
96441: LD_EXP 176
96445: NOT
96446: IFFALSE 96450
// exit ;
96448: GO 96494
// for i in hInvincible do
96450: LD_ADDR_VAR 0 1
96454: PUSH
96455: LD_EXP 176
96459: PUSH
96460: FOR_IN
96461: IFFALSE 96492
// if GetLives ( i ) < 1000 then
96463: LD_VAR 0 1
96467: PPUSH
96468: CALL_OW 256
96472: PUSH
96473: LD_INT 1000
96475: LESS
96476: IFFALSE 96490
// SetLives ( i , 1000 ) ;
96478: LD_VAR 0 1
96482: PPUSH
96483: LD_INT 1000
96485: PPUSH
96486: CALL_OW 234
96490: GO 96460
96492: POP
96493: POP
// end ;
96494: PPOPN 1
96496: END
// export function hHackInvincible ; var i ; begin
96497: LD_INT 0
96499: PPUSH
96500: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
96501: LD_ADDR_VAR 0 2
96505: PUSH
96506: LD_INT 2
96508: PUSH
96509: LD_INT 21
96511: PUSH
96512: LD_INT 1
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 21
96521: PUSH
96522: LD_INT 2
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: LIST
96533: PPUSH
96534: CALL_OW 69
96538: PUSH
96539: FOR_IN
96540: IFFALSE 96601
// if IsSelected ( i ) then
96542: LD_VAR 0 2
96546: PPUSH
96547: CALL_OW 306
96551: IFFALSE 96599
// begin if i in hInvincible then
96553: LD_VAR 0 2
96557: PUSH
96558: LD_EXP 176
96562: IN
96563: IFFALSE 96583
// hInvincible := hInvincible diff i else
96565: LD_ADDR_EXP 176
96569: PUSH
96570: LD_EXP 176
96574: PUSH
96575: LD_VAR 0 2
96579: DIFF
96580: ST_TO_ADDR
96581: GO 96599
// hInvincible := hInvincible union i ;
96583: LD_ADDR_EXP 176
96587: PUSH
96588: LD_EXP 176
96592: PUSH
96593: LD_VAR 0 2
96597: UNION
96598: ST_TO_ADDR
// end ;
96599: GO 96539
96601: POP
96602: POP
// end ;
96603: LD_VAR 0 1
96607: RET
// export function hHackInvisible ; var i , j ; begin
96608: LD_INT 0
96610: PPUSH
96611: PPUSH
96612: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96613: LD_ADDR_VAR 0 2
96617: PUSH
96618: LD_INT 21
96620: PUSH
96621: LD_INT 1
96623: PUSH
96624: EMPTY
96625: LIST
96626: LIST
96627: PPUSH
96628: CALL_OW 69
96632: PUSH
96633: FOR_IN
96634: IFFALSE 96658
// if IsSelected ( i ) then
96636: LD_VAR 0 2
96640: PPUSH
96641: CALL_OW 306
96645: IFFALSE 96656
// ComForceInvisible ( i ) ;
96647: LD_VAR 0 2
96651: PPUSH
96652: CALL_OW 496
96656: GO 96633
96658: POP
96659: POP
// end ;
96660: LD_VAR 0 1
96664: RET
// export function hHackChangeYourSide ; begin
96665: LD_INT 0
96667: PPUSH
// if your_side = 8 then
96668: LD_OWVAR 2
96672: PUSH
96673: LD_INT 8
96675: EQUAL
96676: IFFALSE 96688
// your_side := 0 else
96678: LD_ADDR_OWVAR 2
96682: PUSH
96683: LD_INT 0
96685: ST_TO_ADDR
96686: GO 96702
// your_side := your_side + 1 ;
96688: LD_ADDR_OWVAR 2
96692: PUSH
96693: LD_OWVAR 2
96697: PUSH
96698: LD_INT 1
96700: PLUS
96701: ST_TO_ADDR
// end ;
96702: LD_VAR 0 1
96706: RET
// export function hHackChangeUnitSide ; var i , j ; begin
96707: LD_INT 0
96709: PPUSH
96710: PPUSH
96711: PPUSH
// for i in all_units do
96712: LD_ADDR_VAR 0 2
96716: PUSH
96717: LD_OWVAR 3
96721: PUSH
96722: FOR_IN
96723: IFFALSE 96801
// if IsSelected ( i ) then
96725: LD_VAR 0 2
96729: PPUSH
96730: CALL_OW 306
96734: IFFALSE 96799
// begin j := GetSide ( i ) ;
96736: LD_ADDR_VAR 0 3
96740: PUSH
96741: LD_VAR 0 2
96745: PPUSH
96746: CALL_OW 255
96750: ST_TO_ADDR
// if j = 8 then
96751: LD_VAR 0 3
96755: PUSH
96756: LD_INT 8
96758: EQUAL
96759: IFFALSE 96771
// j := 0 else
96761: LD_ADDR_VAR 0 3
96765: PUSH
96766: LD_INT 0
96768: ST_TO_ADDR
96769: GO 96785
// j := j + 1 ;
96771: LD_ADDR_VAR 0 3
96775: PUSH
96776: LD_VAR 0 3
96780: PUSH
96781: LD_INT 1
96783: PLUS
96784: ST_TO_ADDR
// SetSide ( i , j ) ;
96785: LD_VAR 0 2
96789: PPUSH
96790: LD_VAR 0 3
96794: PPUSH
96795: CALL_OW 235
// end ;
96799: GO 96722
96801: POP
96802: POP
// end ;
96803: LD_VAR 0 1
96807: RET
// export function hHackFog ; begin
96808: LD_INT 0
96810: PPUSH
// FogOff ( true ) ;
96811: LD_INT 1
96813: PPUSH
96814: CALL_OW 344
// end ;
96818: LD_VAR 0 1
96822: RET
// export function hHackTeleport ( unit , x , y ) ; begin
96823: LD_INT 0
96825: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
96826: LD_VAR 0 1
96830: PPUSH
96831: LD_VAR 0 2
96835: PPUSH
96836: LD_VAR 0 3
96840: PPUSH
96841: LD_INT 1
96843: PPUSH
96844: LD_INT 1
96846: PPUSH
96847: CALL_OW 483
// CenterOnXY ( x , y ) ;
96851: LD_VAR 0 2
96855: PPUSH
96856: LD_VAR 0 3
96860: PPUSH
96861: CALL_OW 84
// end ; end_of_file
96865: LD_VAR 0 4
96869: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
96870: LD_INT 0
96872: PPUSH
96873: PPUSH
96874: PPUSH
96875: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
96876: LD_VAR 0 1
96880: PPUSH
96881: CALL_OW 264
96885: PUSH
96886: LD_EXP 107
96890: EQUAL
96891: IFFALSE 96963
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
96893: LD_INT 68
96895: PPUSH
96896: LD_VAR 0 1
96900: PPUSH
96901: CALL_OW 255
96905: PPUSH
96906: CALL_OW 321
96910: PUSH
96911: LD_INT 2
96913: EQUAL
96914: IFFALSE 96926
// eff := 70 else
96916: LD_ADDR_VAR 0 4
96920: PUSH
96921: LD_INT 70
96923: ST_TO_ADDR
96924: GO 96934
// eff := 30 ;
96926: LD_ADDR_VAR 0 4
96930: PUSH
96931: LD_INT 30
96933: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
96934: LD_VAR 0 1
96938: PPUSH
96939: CALL_OW 250
96943: PPUSH
96944: LD_VAR 0 1
96948: PPUSH
96949: CALL_OW 251
96953: PPUSH
96954: LD_VAR 0 4
96958: PPUSH
96959: CALL_OW 495
// end ; end ;
96963: LD_VAR 0 2
96967: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
96968: LD_INT 0
96970: PPUSH
// end ;
96971: LD_VAR 0 4
96975: RET
// export function SOS_Command ( cmd ) ; begin
96976: LD_INT 0
96978: PPUSH
// end ;
96979: LD_VAR 0 2
96983: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
96984: LD_INT 0
96986: PPUSH
// if cmd = 121 then
96987: LD_VAR 0 1
96991: PUSH
96992: LD_INT 121
96994: EQUAL
96995: IFFALSE 96997
// end ;
96997: LD_VAR 0 6
97001: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
97002: LD_INT 0
97004: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
97005: LD_VAR 0 1
97009: PUSH
97010: LD_INT 250
97012: EQUAL
97013: PUSH
97014: LD_VAR 0 2
97018: PPUSH
97019: CALL_OW 264
97023: PUSH
97024: LD_EXP 110
97028: EQUAL
97029: AND
97030: IFFALSE 97051
// MinerPlaceMine ( unit , x , y ) ;
97032: LD_VAR 0 2
97036: PPUSH
97037: LD_VAR 0 4
97041: PPUSH
97042: LD_VAR 0 5
97046: PPUSH
97047: CALL 99400 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
97051: LD_VAR 0 1
97055: PUSH
97056: LD_INT 251
97058: EQUAL
97059: PUSH
97060: LD_VAR 0 2
97064: PPUSH
97065: CALL_OW 264
97069: PUSH
97070: LD_EXP 110
97074: EQUAL
97075: AND
97076: IFFALSE 97097
// MinerDetonateMine ( unit , x , y ) ;
97078: LD_VAR 0 2
97082: PPUSH
97083: LD_VAR 0 4
97087: PPUSH
97088: LD_VAR 0 5
97092: PPUSH
97093: CALL 99677 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
97097: LD_VAR 0 1
97101: PUSH
97102: LD_INT 252
97104: EQUAL
97105: PUSH
97106: LD_VAR 0 2
97110: PPUSH
97111: CALL_OW 264
97115: PUSH
97116: LD_EXP 110
97120: EQUAL
97121: AND
97122: IFFALSE 97143
// MinerCreateMinefield ( unit , x , y ) ;
97124: LD_VAR 0 2
97128: PPUSH
97129: LD_VAR 0 4
97133: PPUSH
97134: LD_VAR 0 5
97138: PPUSH
97139: CALL 100094 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
97143: LD_VAR 0 1
97147: PUSH
97148: LD_INT 253
97150: EQUAL
97151: PUSH
97152: LD_VAR 0 2
97156: PPUSH
97157: CALL_OW 257
97161: PUSH
97162: LD_INT 5
97164: EQUAL
97165: AND
97166: IFFALSE 97187
// ComBinocular ( unit , x , y ) ;
97168: LD_VAR 0 2
97172: PPUSH
97173: LD_VAR 0 4
97177: PPUSH
97178: LD_VAR 0 5
97182: PPUSH
97183: CALL 100465 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
97187: LD_VAR 0 1
97191: PUSH
97192: LD_INT 254
97194: EQUAL
97195: PUSH
97196: LD_VAR 0 2
97200: PPUSH
97201: CALL_OW 264
97205: PUSH
97206: LD_EXP 105
97210: EQUAL
97211: AND
97212: PUSH
97213: LD_VAR 0 3
97217: PPUSH
97218: CALL_OW 263
97222: PUSH
97223: LD_INT 3
97225: EQUAL
97226: AND
97227: IFFALSE 97243
// HackDestroyVehicle ( unit , selectedUnit ) ;
97229: LD_VAR 0 2
97233: PPUSH
97234: LD_VAR 0 3
97238: PPUSH
97239: CALL 98760 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
97243: LD_VAR 0 1
97247: PUSH
97248: LD_INT 255
97250: EQUAL
97251: PUSH
97252: LD_VAR 0 2
97256: PPUSH
97257: CALL_OW 264
97261: PUSH
97262: LD_INT 14
97264: PUSH
97265: LD_INT 53
97267: PUSH
97268: EMPTY
97269: LIST
97270: LIST
97271: IN
97272: AND
97273: PUSH
97274: LD_VAR 0 4
97278: PPUSH
97279: LD_VAR 0 5
97283: PPUSH
97284: CALL_OW 488
97288: AND
97289: IFFALSE 97313
// CutTreeXYR ( unit , x , y , 12 ) ;
97291: LD_VAR 0 2
97295: PPUSH
97296: LD_VAR 0 4
97300: PPUSH
97301: LD_VAR 0 5
97305: PPUSH
97306: LD_INT 12
97308: PPUSH
97309: CALL 97326 0 4
// end ;
97313: LD_VAR 0 6
97317: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
97318: LD_INT 0
97320: PPUSH
// end ;
97321: LD_VAR 0 4
97325: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
97326: LD_INT 0
97328: PPUSH
97329: PPUSH
97330: PPUSH
97331: PPUSH
97332: PPUSH
97333: PPUSH
97334: PPUSH
97335: PPUSH
97336: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
97337: LD_VAR 0 1
97341: NOT
97342: PUSH
97343: LD_VAR 0 2
97347: PPUSH
97348: LD_VAR 0 3
97352: PPUSH
97353: CALL_OW 488
97357: NOT
97358: OR
97359: PUSH
97360: LD_VAR 0 4
97364: NOT
97365: OR
97366: IFFALSE 97370
// exit ;
97368: GO 97710
// list := [ ] ;
97370: LD_ADDR_VAR 0 13
97374: PUSH
97375: EMPTY
97376: ST_TO_ADDR
// if x - r < 0 then
97377: LD_VAR 0 2
97381: PUSH
97382: LD_VAR 0 4
97386: MINUS
97387: PUSH
97388: LD_INT 0
97390: LESS
97391: IFFALSE 97403
// min_x := 0 else
97393: LD_ADDR_VAR 0 7
97397: PUSH
97398: LD_INT 0
97400: ST_TO_ADDR
97401: GO 97419
// min_x := x - r ;
97403: LD_ADDR_VAR 0 7
97407: PUSH
97408: LD_VAR 0 2
97412: PUSH
97413: LD_VAR 0 4
97417: MINUS
97418: ST_TO_ADDR
// if y - r < 0 then
97419: LD_VAR 0 3
97423: PUSH
97424: LD_VAR 0 4
97428: MINUS
97429: PUSH
97430: LD_INT 0
97432: LESS
97433: IFFALSE 97445
// min_y := 0 else
97435: LD_ADDR_VAR 0 8
97439: PUSH
97440: LD_INT 0
97442: ST_TO_ADDR
97443: GO 97461
// min_y := y - r ;
97445: LD_ADDR_VAR 0 8
97449: PUSH
97450: LD_VAR 0 3
97454: PUSH
97455: LD_VAR 0 4
97459: MINUS
97460: ST_TO_ADDR
// max_x := x + r ;
97461: LD_ADDR_VAR 0 9
97465: PUSH
97466: LD_VAR 0 2
97470: PUSH
97471: LD_VAR 0 4
97475: PLUS
97476: ST_TO_ADDR
// max_y := y + r ;
97477: LD_ADDR_VAR 0 10
97481: PUSH
97482: LD_VAR 0 3
97486: PUSH
97487: LD_VAR 0 4
97491: PLUS
97492: ST_TO_ADDR
// for _x = min_x to max_x do
97493: LD_ADDR_VAR 0 11
97497: PUSH
97498: DOUBLE
97499: LD_VAR 0 7
97503: DEC
97504: ST_TO_ADDR
97505: LD_VAR 0 9
97509: PUSH
97510: FOR_TO
97511: IFFALSE 97628
// for _y = min_y to max_y do
97513: LD_ADDR_VAR 0 12
97517: PUSH
97518: DOUBLE
97519: LD_VAR 0 8
97523: DEC
97524: ST_TO_ADDR
97525: LD_VAR 0 10
97529: PUSH
97530: FOR_TO
97531: IFFALSE 97624
// begin if not ValidHex ( _x , _y ) then
97533: LD_VAR 0 11
97537: PPUSH
97538: LD_VAR 0 12
97542: PPUSH
97543: CALL_OW 488
97547: NOT
97548: IFFALSE 97552
// continue ;
97550: GO 97530
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
97552: LD_VAR 0 11
97556: PPUSH
97557: LD_VAR 0 12
97561: PPUSH
97562: CALL_OW 351
97566: PUSH
97567: LD_VAR 0 11
97571: PPUSH
97572: LD_VAR 0 12
97576: PPUSH
97577: CALL_OW 554
97581: AND
97582: IFFALSE 97622
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
97584: LD_ADDR_VAR 0 13
97588: PUSH
97589: LD_VAR 0 13
97593: PPUSH
97594: LD_VAR 0 13
97598: PUSH
97599: LD_INT 1
97601: PLUS
97602: PPUSH
97603: LD_VAR 0 11
97607: PUSH
97608: LD_VAR 0 12
97612: PUSH
97613: EMPTY
97614: LIST
97615: LIST
97616: PPUSH
97617: CALL_OW 2
97621: ST_TO_ADDR
// end ;
97622: GO 97530
97624: POP
97625: POP
97626: GO 97510
97628: POP
97629: POP
// if not list then
97630: LD_VAR 0 13
97634: NOT
97635: IFFALSE 97639
// exit ;
97637: GO 97710
// for i in list do
97639: LD_ADDR_VAR 0 6
97643: PUSH
97644: LD_VAR 0 13
97648: PUSH
97649: FOR_IN
97650: IFFALSE 97708
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
97652: LD_VAR 0 1
97656: PPUSH
97657: LD_STRING M
97659: PUSH
97660: LD_VAR 0 6
97664: PUSH
97665: LD_INT 1
97667: ARRAY
97668: PUSH
97669: LD_VAR 0 6
97673: PUSH
97674: LD_INT 2
97676: ARRAY
97677: PUSH
97678: LD_INT 0
97680: PUSH
97681: LD_INT 0
97683: PUSH
97684: LD_INT 0
97686: PUSH
97687: LD_INT 0
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: PUSH
97699: EMPTY
97700: LIST
97701: PPUSH
97702: CALL_OW 447
97706: GO 97649
97708: POP
97709: POP
// end ;
97710: LD_VAR 0 5
97714: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
97715: LD_EXP 179
97719: NOT
97720: IFFALSE 97770
97722: GO 97724
97724: DISABLE
// begin initHack := true ;
97725: LD_ADDR_EXP 179
97729: PUSH
97730: LD_INT 1
97732: ST_TO_ADDR
// hackTanks := [ ] ;
97733: LD_ADDR_EXP 180
97737: PUSH
97738: EMPTY
97739: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
97740: LD_ADDR_EXP 181
97744: PUSH
97745: EMPTY
97746: ST_TO_ADDR
// hackLimit := 3 ;
97747: LD_ADDR_EXP 182
97751: PUSH
97752: LD_INT 3
97754: ST_TO_ADDR
// hackDist := 12 ;
97755: LD_ADDR_EXP 183
97759: PUSH
97760: LD_INT 12
97762: ST_TO_ADDR
// hackCounter := [ ] ;
97763: LD_ADDR_EXP 184
97767: PUSH
97768: EMPTY
97769: ST_TO_ADDR
// end ;
97770: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
97771: LD_EXP 179
97775: PUSH
97776: LD_INT 34
97778: PUSH
97779: LD_EXP 105
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PPUSH
97788: CALL_OW 69
97792: AND
97793: IFFALSE 98048
97795: GO 97797
97797: DISABLE
97798: LD_INT 0
97800: PPUSH
97801: PPUSH
// begin enable ;
97802: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
97803: LD_ADDR_VAR 0 1
97807: PUSH
97808: LD_INT 34
97810: PUSH
97811: LD_EXP 105
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PPUSH
97820: CALL_OW 69
97824: PUSH
97825: FOR_IN
97826: IFFALSE 98046
// begin if not i in hackTanks then
97828: LD_VAR 0 1
97832: PUSH
97833: LD_EXP 180
97837: IN
97838: NOT
97839: IFFALSE 97922
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
97841: LD_ADDR_EXP 180
97845: PUSH
97846: LD_EXP 180
97850: PPUSH
97851: LD_EXP 180
97855: PUSH
97856: LD_INT 1
97858: PLUS
97859: PPUSH
97860: LD_VAR 0 1
97864: PPUSH
97865: CALL_OW 1
97869: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
97870: LD_ADDR_EXP 181
97874: PUSH
97875: LD_EXP 181
97879: PPUSH
97880: LD_EXP 181
97884: PUSH
97885: LD_INT 1
97887: PLUS
97888: PPUSH
97889: EMPTY
97890: PPUSH
97891: CALL_OW 1
97895: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
97896: LD_ADDR_EXP 184
97900: PUSH
97901: LD_EXP 184
97905: PPUSH
97906: LD_EXP 184
97910: PUSH
97911: LD_INT 1
97913: PLUS
97914: PPUSH
97915: EMPTY
97916: PPUSH
97917: CALL_OW 1
97921: ST_TO_ADDR
// end ; if not IsOk ( i ) then
97922: LD_VAR 0 1
97926: PPUSH
97927: CALL_OW 302
97931: NOT
97932: IFFALSE 97945
// begin HackUnlinkAll ( i ) ;
97934: LD_VAR 0 1
97938: PPUSH
97939: CALL 98051 0 1
// continue ;
97943: GO 97825
// end ; HackCheckCapturedStatus ( i ) ;
97945: LD_VAR 0 1
97949: PPUSH
97950: CALL 98494 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
97954: LD_ADDR_VAR 0 2
97958: PUSH
97959: LD_INT 81
97961: PUSH
97962: LD_VAR 0 1
97966: PPUSH
97967: CALL_OW 255
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: LD_INT 33
97978: PUSH
97979: LD_INT 3
97981: PUSH
97982: EMPTY
97983: LIST
97984: LIST
97985: PUSH
97986: LD_INT 91
97988: PUSH
97989: LD_VAR 0 1
97993: PUSH
97994: LD_EXP 183
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 50
98006: PUSH
98007: EMPTY
98008: LIST
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: PPUSH
98016: CALL_OW 69
98020: ST_TO_ADDR
// if not tmp then
98021: LD_VAR 0 2
98025: NOT
98026: IFFALSE 98030
// continue ;
98028: GO 97825
// HackLink ( i , tmp ) ;
98030: LD_VAR 0 1
98034: PPUSH
98035: LD_VAR 0 2
98039: PPUSH
98040: CALL 98187 0 2
// end ;
98044: GO 97825
98046: POP
98047: POP
// end ;
98048: PPOPN 2
98050: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
98051: LD_INT 0
98053: PPUSH
98054: PPUSH
98055: PPUSH
// if not hack in hackTanks then
98056: LD_VAR 0 1
98060: PUSH
98061: LD_EXP 180
98065: IN
98066: NOT
98067: IFFALSE 98071
// exit ;
98069: GO 98182
// index := GetElementIndex ( hackTanks , hack ) ;
98071: LD_ADDR_VAR 0 4
98075: PUSH
98076: LD_EXP 180
98080: PPUSH
98081: LD_VAR 0 1
98085: PPUSH
98086: CALL 19511 0 2
98090: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
98091: LD_EXP 181
98095: PUSH
98096: LD_VAR 0 4
98100: ARRAY
98101: IFFALSE 98182
// begin for i in hackTanksCaptured [ index ] do
98103: LD_ADDR_VAR 0 3
98107: PUSH
98108: LD_EXP 181
98112: PUSH
98113: LD_VAR 0 4
98117: ARRAY
98118: PUSH
98119: FOR_IN
98120: IFFALSE 98146
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
98122: LD_VAR 0 3
98126: PUSH
98127: LD_INT 1
98129: ARRAY
98130: PPUSH
98131: LD_VAR 0 3
98135: PUSH
98136: LD_INT 2
98138: ARRAY
98139: PPUSH
98140: CALL_OW 235
98144: GO 98119
98146: POP
98147: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
98148: LD_ADDR_EXP 181
98152: PUSH
98153: LD_EXP 181
98157: PPUSH
98158: LD_VAR 0 4
98162: PPUSH
98163: EMPTY
98164: PPUSH
98165: CALL_OW 1
98169: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
98170: LD_VAR 0 1
98174: PPUSH
98175: LD_INT 0
98177: PPUSH
98178: CALL_OW 505
// end ; end ;
98182: LD_VAR 0 2
98186: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
98187: LD_INT 0
98189: PPUSH
98190: PPUSH
98191: PPUSH
// if not hack in hackTanks or not vehicles then
98192: LD_VAR 0 1
98196: PUSH
98197: LD_EXP 180
98201: IN
98202: NOT
98203: PUSH
98204: LD_VAR 0 2
98208: NOT
98209: OR
98210: IFFALSE 98214
// exit ;
98212: GO 98489
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
98214: LD_ADDR_VAR 0 2
98218: PUSH
98219: LD_VAR 0 1
98223: PPUSH
98224: LD_VAR 0 2
98228: PPUSH
98229: LD_INT 1
98231: PPUSH
98232: LD_INT 1
98234: PPUSH
98235: CALL 20161 0 4
98239: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
98240: LD_ADDR_VAR 0 5
98244: PUSH
98245: LD_EXP 180
98249: PPUSH
98250: LD_VAR 0 1
98254: PPUSH
98255: CALL 19511 0 2
98259: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
98260: LD_EXP 181
98264: PUSH
98265: LD_VAR 0 5
98269: ARRAY
98270: PUSH
98271: LD_EXP 182
98275: LESS
98276: IFFALSE 98465
// begin for i := 1 to vehicles do
98278: LD_ADDR_VAR 0 4
98282: PUSH
98283: DOUBLE
98284: LD_INT 1
98286: DEC
98287: ST_TO_ADDR
98288: LD_VAR 0 2
98292: PUSH
98293: FOR_TO
98294: IFFALSE 98463
// begin if hackTanksCaptured [ index ] = hackLimit then
98296: LD_EXP 181
98300: PUSH
98301: LD_VAR 0 5
98305: ARRAY
98306: PUSH
98307: LD_EXP 182
98311: EQUAL
98312: IFFALSE 98316
// break ;
98314: GO 98463
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
98316: LD_ADDR_EXP 184
98320: PUSH
98321: LD_EXP 184
98325: PPUSH
98326: LD_VAR 0 5
98330: PPUSH
98331: LD_EXP 184
98335: PUSH
98336: LD_VAR 0 5
98340: ARRAY
98341: PUSH
98342: LD_INT 1
98344: PLUS
98345: PPUSH
98346: CALL_OW 1
98350: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
98351: LD_ADDR_EXP 181
98355: PUSH
98356: LD_EXP 181
98360: PPUSH
98361: LD_VAR 0 5
98365: PUSH
98366: LD_EXP 181
98370: PUSH
98371: LD_VAR 0 5
98375: ARRAY
98376: PUSH
98377: LD_INT 1
98379: PLUS
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: PPUSH
98385: LD_VAR 0 2
98389: PUSH
98390: LD_VAR 0 4
98394: ARRAY
98395: PUSH
98396: LD_VAR 0 2
98400: PUSH
98401: LD_VAR 0 4
98405: ARRAY
98406: PPUSH
98407: CALL_OW 255
98411: PUSH
98412: EMPTY
98413: LIST
98414: LIST
98415: PPUSH
98416: CALL 19726 0 3
98420: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
98421: LD_VAR 0 2
98425: PUSH
98426: LD_VAR 0 4
98430: ARRAY
98431: PPUSH
98432: LD_VAR 0 1
98436: PPUSH
98437: CALL_OW 255
98441: PPUSH
98442: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
98446: LD_VAR 0 2
98450: PUSH
98451: LD_VAR 0 4
98455: ARRAY
98456: PPUSH
98457: CALL_OW 141
// end ;
98461: GO 98293
98463: POP
98464: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
98465: LD_VAR 0 1
98469: PPUSH
98470: LD_EXP 181
98474: PUSH
98475: LD_VAR 0 5
98479: ARRAY
98480: PUSH
98481: LD_INT 0
98483: PLUS
98484: PPUSH
98485: CALL_OW 505
// end ;
98489: LD_VAR 0 3
98493: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
98494: LD_INT 0
98496: PPUSH
98497: PPUSH
98498: PPUSH
98499: PPUSH
// if not hack in hackTanks then
98500: LD_VAR 0 1
98504: PUSH
98505: LD_EXP 180
98509: IN
98510: NOT
98511: IFFALSE 98515
// exit ;
98513: GO 98755
// index := GetElementIndex ( hackTanks , hack ) ;
98515: LD_ADDR_VAR 0 4
98519: PUSH
98520: LD_EXP 180
98524: PPUSH
98525: LD_VAR 0 1
98529: PPUSH
98530: CALL 19511 0 2
98534: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
98535: LD_ADDR_VAR 0 3
98539: PUSH
98540: DOUBLE
98541: LD_EXP 181
98545: PUSH
98546: LD_VAR 0 4
98550: ARRAY
98551: INC
98552: ST_TO_ADDR
98553: LD_INT 1
98555: PUSH
98556: FOR_DOWNTO
98557: IFFALSE 98729
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
98559: LD_ADDR_VAR 0 5
98563: PUSH
98564: LD_EXP 181
98568: PUSH
98569: LD_VAR 0 4
98573: ARRAY
98574: PUSH
98575: LD_VAR 0 3
98579: ARRAY
98580: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
98581: LD_VAR 0 5
98585: PUSH
98586: LD_INT 1
98588: ARRAY
98589: PPUSH
98590: CALL_OW 302
98594: NOT
98595: PUSH
98596: LD_VAR 0 5
98600: PUSH
98601: LD_INT 1
98603: ARRAY
98604: PPUSH
98605: CALL_OW 255
98609: PUSH
98610: LD_VAR 0 1
98614: PPUSH
98615: CALL_OW 255
98619: NONEQUAL
98620: OR
98621: IFFALSE 98727
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
98623: LD_VAR 0 5
98627: PUSH
98628: LD_INT 1
98630: ARRAY
98631: PPUSH
98632: CALL_OW 305
98636: PUSH
98637: LD_VAR 0 5
98641: PUSH
98642: LD_INT 1
98644: ARRAY
98645: PPUSH
98646: CALL_OW 255
98650: PUSH
98651: LD_VAR 0 1
98655: PPUSH
98656: CALL_OW 255
98660: EQUAL
98661: AND
98662: IFFALSE 98686
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
98664: LD_VAR 0 5
98668: PUSH
98669: LD_INT 1
98671: ARRAY
98672: PPUSH
98673: LD_VAR 0 5
98677: PUSH
98678: LD_INT 2
98680: ARRAY
98681: PPUSH
98682: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
98686: LD_ADDR_EXP 181
98690: PUSH
98691: LD_EXP 181
98695: PPUSH
98696: LD_VAR 0 4
98700: PPUSH
98701: LD_EXP 181
98705: PUSH
98706: LD_VAR 0 4
98710: ARRAY
98711: PPUSH
98712: LD_VAR 0 3
98716: PPUSH
98717: CALL_OW 3
98721: PPUSH
98722: CALL_OW 1
98726: ST_TO_ADDR
// end ; end ;
98727: GO 98556
98729: POP
98730: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
98731: LD_VAR 0 1
98735: PPUSH
98736: LD_EXP 181
98740: PUSH
98741: LD_VAR 0 4
98745: ARRAY
98746: PUSH
98747: LD_INT 0
98749: PLUS
98750: PPUSH
98751: CALL_OW 505
// end ;
98755: LD_VAR 0 2
98759: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
98760: LD_INT 0
98762: PPUSH
98763: PPUSH
98764: PPUSH
98765: PPUSH
// if not hack in hackTanks then
98766: LD_VAR 0 1
98770: PUSH
98771: LD_EXP 180
98775: IN
98776: NOT
98777: IFFALSE 98781
// exit ;
98779: GO 98866
// index := GetElementIndex ( hackTanks , hack ) ;
98781: LD_ADDR_VAR 0 5
98785: PUSH
98786: LD_EXP 180
98790: PPUSH
98791: LD_VAR 0 1
98795: PPUSH
98796: CALL 19511 0 2
98800: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
98801: LD_ADDR_VAR 0 4
98805: PUSH
98806: DOUBLE
98807: LD_INT 1
98809: DEC
98810: ST_TO_ADDR
98811: LD_EXP 181
98815: PUSH
98816: LD_VAR 0 5
98820: ARRAY
98821: PUSH
98822: FOR_TO
98823: IFFALSE 98864
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
98825: LD_EXP 181
98829: PUSH
98830: LD_VAR 0 5
98834: ARRAY
98835: PUSH
98836: LD_VAR 0 4
98840: ARRAY
98841: PUSH
98842: LD_INT 1
98844: ARRAY
98845: PUSH
98846: LD_VAR 0 2
98850: EQUAL
98851: IFFALSE 98862
// KillUnit ( vehicle ) ;
98853: LD_VAR 0 2
98857: PPUSH
98858: CALL_OW 66
98862: GO 98822
98864: POP
98865: POP
// end ;
98866: LD_VAR 0 3
98870: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
98871: LD_EXP 185
98875: NOT
98876: IFFALSE 98911
98878: GO 98880
98880: DISABLE
// begin initMiner := true ;
98881: LD_ADDR_EXP 185
98885: PUSH
98886: LD_INT 1
98888: ST_TO_ADDR
// minersList := [ ] ;
98889: LD_ADDR_EXP 186
98893: PUSH
98894: EMPTY
98895: ST_TO_ADDR
// minerMinesList := [ ] ;
98896: LD_ADDR_EXP 187
98900: PUSH
98901: EMPTY
98902: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
98903: LD_ADDR_EXP 188
98907: PUSH
98908: LD_INT 5
98910: ST_TO_ADDR
// end ;
98911: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
98912: LD_EXP 185
98916: PUSH
98917: LD_INT 34
98919: PUSH
98920: LD_EXP 110
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: PPUSH
98929: CALL_OW 69
98933: AND
98934: IFFALSE 99397
98936: GO 98938
98938: DISABLE
98939: LD_INT 0
98941: PPUSH
98942: PPUSH
98943: PPUSH
98944: PPUSH
// begin enable ;
98945: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
98946: LD_ADDR_VAR 0 1
98950: PUSH
98951: LD_INT 34
98953: PUSH
98954: LD_EXP 110
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: PPUSH
98963: CALL_OW 69
98967: PUSH
98968: FOR_IN
98969: IFFALSE 99041
// begin if not i in minersList then
98971: LD_VAR 0 1
98975: PUSH
98976: LD_EXP 186
98980: IN
98981: NOT
98982: IFFALSE 99039
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
98984: LD_ADDR_EXP 186
98988: PUSH
98989: LD_EXP 186
98993: PPUSH
98994: LD_EXP 186
98998: PUSH
98999: LD_INT 1
99001: PLUS
99002: PPUSH
99003: LD_VAR 0 1
99007: PPUSH
99008: CALL_OW 1
99012: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
99013: LD_ADDR_EXP 187
99017: PUSH
99018: LD_EXP 187
99022: PPUSH
99023: LD_EXP 187
99027: PUSH
99028: LD_INT 1
99030: PLUS
99031: PPUSH
99032: EMPTY
99033: PPUSH
99034: CALL_OW 1
99038: ST_TO_ADDR
// end end ;
99039: GO 98968
99041: POP
99042: POP
// for i := minerMinesList downto 1 do
99043: LD_ADDR_VAR 0 1
99047: PUSH
99048: DOUBLE
99049: LD_EXP 187
99053: INC
99054: ST_TO_ADDR
99055: LD_INT 1
99057: PUSH
99058: FOR_DOWNTO
99059: IFFALSE 99395
// begin if IsLive ( minersList [ i ] ) then
99061: LD_EXP 186
99065: PUSH
99066: LD_VAR 0 1
99070: ARRAY
99071: PPUSH
99072: CALL_OW 300
99076: IFFALSE 99104
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
99078: LD_EXP 186
99082: PUSH
99083: LD_VAR 0 1
99087: ARRAY
99088: PPUSH
99089: LD_EXP 187
99093: PUSH
99094: LD_VAR 0 1
99098: ARRAY
99099: PPUSH
99100: CALL_OW 505
// if not minerMinesList [ i ] then
99104: LD_EXP 187
99108: PUSH
99109: LD_VAR 0 1
99113: ARRAY
99114: NOT
99115: IFFALSE 99119
// continue ;
99117: GO 99058
// for j := minerMinesList [ i ] downto 1 do
99119: LD_ADDR_VAR 0 2
99123: PUSH
99124: DOUBLE
99125: LD_EXP 187
99129: PUSH
99130: LD_VAR 0 1
99134: ARRAY
99135: INC
99136: ST_TO_ADDR
99137: LD_INT 1
99139: PUSH
99140: FOR_DOWNTO
99141: IFFALSE 99391
// begin side := GetSide ( minersList [ i ] ) ;
99143: LD_ADDR_VAR 0 3
99147: PUSH
99148: LD_EXP 186
99152: PUSH
99153: LD_VAR 0 1
99157: ARRAY
99158: PPUSH
99159: CALL_OW 255
99163: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
99164: LD_ADDR_VAR 0 4
99168: PUSH
99169: LD_EXP 187
99173: PUSH
99174: LD_VAR 0 1
99178: ARRAY
99179: PUSH
99180: LD_VAR 0 2
99184: ARRAY
99185: PUSH
99186: LD_INT 1
99188: ARRAY
99189: PPUSH
99190: LD_EXP 187
99194: PUSH
99195: LD_VAR 0 1
99199: ARRAY
99200: PUSH
99201: LD_VAR 0 2
99205: ARRAY
99206: PUSH
99207: LD_INT 2
99209: ARRAY
99210: PPUSH
99211: CALL_OW 428
99215: ST_TO_ADDR
// if not tmp then
99216: LD_VAR 0 4
99220: NOT
99221: IFFALSE 99225
// continue ;
99223: GO 99140
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
99225: LD_VAR 0 4
99229: PUSH
99230: LD_INT 81
99232: PUSH
99233: LD_VAR 0 3
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PPUSH
99242: CALL_OW 69
99246: IN
99247: PUSH
99248: LD_EXP 187
99252: PUSH
99253: LD_VAR 0 1
99257: ARRAY
99258: PUSH
99259: LD_VAR 0 2
99263: ARRAY
99264: PUSH
99265: LD_INT 1
99267: ARRAY
99268: PPUSH
99269: LD_EXP 187
99273: PUSH
99274: LD_VAR 0 1
99278: ARRAY
99279: PUSH
99280: LD_VAR 0 2
99284: ARRAY
99285: PUSH
99286: LD_INT 2
99288: ARRAY
99289: PPUSH
99290: CALL_OW 458
99294: AND
99295: IFFALSE 99389
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
99297: LD_EXP 187
99301: PUSH
99302: LD_VAR 0 1
99306: ARRAY
99307: PUSH
99308: LD_VAR 0 2
99312: ARRAY
99313: PUSH
99314: LD_INT 1
99316: ARRAY
99317: PPUSH
99318: LD_EXP 187
99322: PUSH
99323: LD_VAR 0 1
99327: ARRAY
99328: PUSH
99329: LD_VAR 0 2
99333: ARRAY
99334: PUSH
99335: LD_INT 2
99337: ARRAY
99338: PPUSH
99339: LD_VAR 0 3
99343: PPUSH
99344: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
99348: LD_ADDR_EXP 187
99352: PUSH
99353: LD_EXP 187
99357: PPUSH
99358: LD_VAR 0 1
99362: PPUSH
99363: LD_EXP 187
99367: PUSH
99368: LD_VAR 0 1
99372: ARRAY
99373: PPUSH
99374: LD_VAR 0 2
99378: PPUSH
99379: CALL_OW 3
99383: PPUSH
99384: CALL_OW 1
99388: ST_TO_ADDR
// end ; end ;
99389: GO 99140
99391: POP
99392: POP
// end ;
99393: GO 99058
99395: POP
99396: POP
// end ;
99397: PPOPN 4
99399: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
99400: LD_INT 0
99402: PPUSH
99403: PPUSH
// result := false ;
99404: LD_ADDR_VAR 0 4
99408: PUSH
99409: LD_INT 0
99411: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
99412: LD_VAR 0 1
99416: PPUSH
99417: CALL_OW 264
99421: PUSH
99422: LD_EXP 110
99426: EQUAL
99427: NOT
99428: IFFALSE 99432
// exit ;
99430: GO 99672
// index := GetElementIndex ( minersList , unit ) ;
99432: LD_ADDR_VAR 0 5
99436: PUSH
99437: LD_EXP 186
99441: PPUSH
99442: LD_VAR 0 1
99446: PPUSH
99447: CALL 19511 0 2
99451: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
99452: LD_EXP 187
99456: PUSH
99457: LD_VAR 0 5
99461: ARRAY
99462: PUSH
99463: LD_EXP 188
99467: GREATEREQUAL
99468: IFFALSE 99472
// exit ;
99470: GO 99672
// ComMoveXY ( unit , x , y ) ;
99472: LD_VAR 0 1
99476: PPUSH
99477: LD_VAR 0 2
99481: PPUSH
99482: LD_VAR 0 3
99486: PPUSH
99487: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
99491: LD_INT 35
99493: PPUSH
99494: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
99498: LD_VAR 0 1
99502: PPUSH
99503: LD_VAR 0 2
99507: PPUSH
99508: LD_VAR 0 3
99512: PPUSH
99513: CALL 50284 0 3
99517: NOT
99518: PUSH
99519: LD_VAR 0 1
99523: PPUSH
99524: CALL_OW 314
99528: AND
99529: IFFALSE 99533
// exit ;
99531: GO 99672
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
99533: LD_VAR 0 2
99537: PPUSH
99538: LD_VAR 0 3
99542: PPUSH
99543: CALL_OW 428
99547: PUSH
99548: LD_VAR 0 1
99552: EQUAL
99553: PUSH
99554: LD_VAR 0 1
99558: PPUSH
99559: CALL_OW 314
99563: NOT
99564: AND
99565: IFFALSE 99491
// PlaySoundXY ( x , y , PlantMine ) ;
99567: LD_VAR 0 2
99571: PPUSH
99572: LD_VAR 0 3
99576: PPUSH
99577: LD_STRING PlantMine
99579: PPUSH
99580: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
99584: LD_VAR 0 2
99588: PPUSH
99589: LD_VAR 0 3
99593: PPUSH
99594: LD_VAR 0 1
99598: PPUSH
99599: CALL_OW 255
99603: PPUSH
99604: LD_INT 0
99606: PPUSH
99607: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
99611: LD_ADDR_EXP 187
99615: PUSH
99616: LD_EXP 187
99620: PPUSH
99621: LD_VAR 0 5
99625: PUSH
99626: LD_EXP 187
99630: PUSH
99631: LD_VAR 0 5
99635: ARRAY
99636: PUSH
99637: LD_INT 1
99639: PLUS
99640: PUSH
99641: EMPTY
99642: LIST
99643: LIST
99644: PPUSH
99645: LD_VAR 0 2
99649: PUSH
99650: LD_VAR 0 3
99654: PUSH
99655: EMPTY
99656: LIST
99657: LIST
99658: PPUSH
99659: CALL 19726 0 3
99663: ST_TO_ADDR
// result := true ;
99664: LD_ADDR_VAR 0 4
99668: PUSH
99669: LD_INT 1
99671: ST_TO_ADDR
// end ;
99672: LD_VAR 0 4
99676: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
99677: LD_INT 0
99679: PPUSH
99680: PPUSH
99681: PPUSH
// if not unit in minersList then
99682: LD_VAR 0 1
99686: PUSH
99687: LD_EXP 186
99691: IN
99692: NOT
99693: IFFALSE 99697
// exit ;
99695: GO 100089
// index := GetElementIndex ( minersList , unit ) ;
99697: LD_ADDR_VAR 0 6
99701: PUSH
99702: LD_EXP 186
99706: PPUSH
99707: LD_VAR 0 1
99711: PPUSH
99712: CALL 19511 0 2
99716: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
99717: LD_ADDR_VAR 0 5
99721: PUSH
99722: DOUBLE
99723: LD_EXP 187
99727: PUSH
99728: LD_VAR 0 6
99732: ARRAY
99733: INC
99734: ST_TO_ADDR
99735: LD_INT 1
99737: PUSH
99738: FOR_DOWNTO
99739: IFFALSE 99900
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
99741: LD_EXP 187
99745: PUSH
99746: LD_VAR 0 6
99750: ARRAY
99751: PUSH
99752: LD_VAR 0 5
99756: ARRAY
99757: PUSH
99758: LD_INT 1
99760: ARRAY
99761: PUSH
99762: LD_VAR 0 2
99766: EQUAL
99767: PUSH
99768: LD_EXP 187
99772: PUSH
99773: LD_VAR 0 6
99777: ARRAY
99778: PUSH
99779: LD_VAR 0 5
99783: ARRAY
99784: PUSH
99785: LD_INT 2
99787: ARRAY
99788: PUSH
99789: LD_VAR 0 3
99793: EQUAL
99794: AND
99795: IFFALSE 99898
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
99797: LD_EXP 187
99801: PUSH
99802: LD_VAR 0 6
99806: ARRAY
99807: PUSH
99808: LD_VAR 0 5
99812: ARRAY
99813: PUSH
99814: LD_INT 1
99816: ARRAY
99817: PPUSH
99818: LD_EXP 187
99822: PUSH
99823: LD_VAR 0 6
99827: ARRAY
99828: PUSH
99829: LD_VAR 0 5
99833: ARRAY
99834: PUSH
99835: LD_INT 2
99837: ARRAY
99838: PPUSH
99839: LD_VAR 0 1
99843: PPUSH
99844: CALL_OW 255
99848: PPUSH
99849: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
99853: LD_ADDR_EXP 187
99857: PUSH
99858: LD_EXP 187
99862: PPUSH
99863: LD_VAR 0 6
99867: PPUSH
99868: LD_EXP 187
99872: PUSH
99873: LD_VAR 0 6
99877: ARRAY
99878: PPUSH
99879: LD_VAR 0 5
99883: PPUSH
99884: CALL_OW 3
99888: PPUSH
99889: CALL_OW 1
99893: ST_TO_ADDR
// exit ;
99894: POP
99895: POP
99896: GO 100089
// end ; end ;
99898: GO 99738
99900: POP
99901: POP
// for i := minerMinesList [ index ] downto 1 do
99902: LD_ADDR_VAR 0 5
99906: PUSH
99907: DOUBLE
99908: LD_EXP 187
99912: PUSH
99913: LD_VAR 0 6
99917: ARRAY
99918: INC
99919: ST_TO_ADDR
99920: LD_INT 1
99922: PUSH
99923: FOR_DOWNTO
99924: IFFALSE 100087
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
99926: LD_EXP 187
99930: PUSH
99931: LD_VAR 0 6
99935: ARRAY
99936: PUSH
99937: LD_VAR 0 5
99941: ARRAY
99942: PUSH
99943: LD_INT 1
99945: ARRAY
99946: PPUSH
99947: LD_EXP 187
99951: PUSH
99952: LD_VAR 0 6
99956: ARRAY
99957: PUSH
99958: LD_VAR 0 5
99962: ARRAY
99963: PUSH
99964: LD_INT 2
99966: ARRAY
99967: PPUSH
99968: LD_VAR 0 2
99972: PPUSH
99973: LD_VAR 0 3
99977: PPUSH
99978: CALL_OW 298
99982: PUSH
99983: LD_INT 6
99985: LESS
99986: IFFALSE 100085
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
99988: LD_EXP 187
99992: PUSH
99993: LD_VAR 0 6
99997: ARRAY
99998: PUSH
99999: LD_VAR 0 5
100003: ARRAY
100004: PUSH
100005: LD_INT 1
100007: ARRAY
100008: PPUSH
100009: LD_EXP 187
100013: PUSH
100014: LD_VAR 0 6
100018: ARRAY
100019: PUSH
100020: LD_VAR 0 5
100024: ARRAY
100025: PUSH
100026: LD_INT 2
100028: ARRAY
100029: PPUSH
100030: LD_VAR 0 1
100034: PPUSH
100035: CALL_OW 255
100039: PPUSH
100040: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
100044: LD_ADDR_EXP 187
100048: PUSH
100049: LD_EXP 187
100053: PPUSH
100054: LD_VAR 0 6
100058: PPUSH
100059: LD_EXP 187
100063: PUSH
100064: LD_VAR 0 6
100068: ARRAY
100069: PPUSH
100070: LD_VAR 0 5
100074: PPUSH
100075: CALL_OW 3
100079: PPUSH
100080: CALL_OW 1
100084: ST_TO_ADDR
// end ; end ;
100085: GO 99923
100087: POP
100088: POP
// end ;
100089: LD_VAR 0 4
100093: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
100094: LD_INT 0
100096: PPUSH
100097: PPUSH
100098: PPUSH
100099: PPUSH
100100: PPUSH
100101: PPUSH
100102: PPUSH
100103: PPUSH
100104: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
100105: LD_VAR 0 1
100109: PPUSH
100110: CALL_OW 264
100114: PUSH
100115: LD_EXP 110
100119: EQUAL
100120: NOT
100121: PUSH
100122: LD_VAR 0 1
100126: PUSH
100127: LD_EXP 186
100131: IN
100132: NOT
100133: OR
100134: IFFALSE 100138
// exit ;
100136: GO 100460
// index := GetElementIndex ( minersList , unit ) ;
100138: LD_ADDR_VAR 0 6
100142: PUSH
100143: LD_EXP 186
100147: PPUSH
100148: LD_VAR 0 1
100152: PPUSH
100153: CALL 19511 0 2
100157: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
100158: LD_ADDR_VAR 0 8
100162: PUSH
100163: LD_EXP 188
100167: PUSH
100168: LD_EXP 187
100172: PUSH
100173: LD_VAR 0 6
100177: ARRAY
100178: MINUS
100179: ST_TO_ADDR
// if not minesFreeAmount then
100180: LD_VAR 0 8
100184: NOT
100185: IFFALSE 100189
// exit ;
100187: GO 100460
// tmp := [ ] ;
100189: LD_ADDR_VAR 0 7
100193: PUSH
100194: EMPTY
100195: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
100196: LD_ADDR_VAR 0 5
100200: PUSH
100201: DOUBLE
100202: LD_INT 1
100204: DEC
100205: ST_TO_ADDR
100206: LD_VAR 0 8
100210: PUSH
100211: FOR_TO
100212: IFFALSE 100407
// begin _d := rand ( 0 , 5 ) ;
100214: LD_ADDR_VAR 0 11
100218: PUSH
100219: LD_INT 0
100221: PPUSH
100222: LD_INT 5
100224: PPUSH
100225: CALL_OW 12
100229: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
100230: LD_ADDR_VAR 0 12
100234: PUSH
100235: LD_INT 2
100237: PPUSH
100238: LD_INT 6
100240: PPUSH
100241: CALL_OW 12
100245: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
100246: LD_ADDR_VAR 0 9
100250: PUSH
100251: LD_VAR 0 2
100255: PPUSH
100256: LD_VAR 0 11
100260: PPUSH
100261: LD_VAR 0 12
100265: PPUSH
100266: CALL_OW 272
100270: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
100271: LD_ADDR_VAR 0 10
100275: PUSH
100276: LD_VAR 0 3
100280: PPUSH
100281: LD_VAR 0 11
100285: PPUSH
100286: LD_VAR 0 12
100290: PPUSH
100291: CALL_OW 273
100295: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
100296: LD_VAR 0 9
100300: PPUSH
100301: LD_VAR 0 10
100305: PPUSH
100306: CALL_OW 488
100310: PUSH
100311: LD_VAR 0 9
100315: PUSH
100316: LD_VAR 0 10
100320: PUSH
100321: EMPTY
100322: LIST
100323: LIST
100324: PUSH
100325: LD_VAR 0 7
100329: IN
100330: NOT
100331: AND
100332: PUSH
100333: LD_VAR 0 9
100337: PPUSH
100338: LD_VAR 0 10
100342: PPUSH
100343: CALL_OW 458
100347: NOT
100348: AND
100349: IFFALSE 100391
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
100351: LD_ADDR_VAR 0 7
100355: PUSH
100356: LD_VAR 0 7
100360: PPUSH
100361: LD_VAR 0 7
100365: PUSH
100366: LD_INT 1
100368: PLUS
100369: PPUSH
100370: LD_VAR 0 9
100374: PUSH
100375: LD_VAR 0 10
100379: PUSH
100380: EMPTY
100381: LIST
100382: LIST
100383: PPUSH
100384: CALL_OW 1
100388: ST_TO_ADDR
100389: GO 100405
// i := i - 1 ;
100391: LD_ADDR_VAR 0 5
100395: PUSH
100396: LD_VAR 0 5
100400: PUSH
100401: LD_INT 1
100403: MINUS
100404: ST_TO_ADDR
// end ;
100405: GO 100211
100407: POP
100408: POP
// for i in tmp do
100409: LD_ADDR_VAR 0 5
100413: PUSH
100414: LD_VAR 0 7
100418: PUSH
100419: FOR_IN
100420: IFFALSE 100458
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
100422: LD_VAR 0 1
100426: PPUSH
100427: LD_VAR 0 5
100431: PUSH
100432: LD_INT 1
100434: ARRAY
100435: PPUSH
100436: LD_VAR 0 5
100440: PUSH
100441: LD_INT 2
100443: ARRAY
100444: PPUSH
100445: CALL 99400 0 3
100449: NOT
100450: IFFALSE 100456
// exit ;
100452: POP
100453: POP
100454: GO 100460
100456: GO 100419
100458: POP
100459: POP
// end ;
100460: LD_VAR 0 4
100464: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
100465: LD_INT 0
100467: PPUSH
100468: PPUSH
100469: PPUSH
100470: PPUSH
100471: PPUSH
100472: PPUSH
100473: PPUSH
// if not GetClass ( unit ) = class_sniper then
100474: LD_VAR 0 1
100478: PPUSH
100479: CALL_OW 257
100483: PUSH
100484: LD_INT 5
100486: EQUAL
100487: NOT
100488: IFFALSE 100492
// exit ;
100490: GO 100880
// dist := 8 ;
100492: LD_ADDR_VAR 0 5
100496: PUSH
100497: LD_INT 8
100499: ST_TO_ADDR
// viewRange := 12 ;
100500: LD_ADDR_VAR 0 7
100504: PUSH
100505: LD_INT 12
100507: ST_TO_ADDR
// side := GetSide ( unit ) ;
100508: LD_ADDR_VAR 0 6
100512: PUSH
100513: LD_VAR 0 1
100517: PPUSH
100518: CALL_OW 255
100522: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
100523: LD_INT 61
100525: PPUSH
100526: LD_VAR 0 6
100530: PPUSH
100531: CALL_OW 321
100535: PUSH
100536: LD_INT 2
100538: EQUAL
100539: IFFALSE 100549
// viewRange := 16 ;
100541: LD_ADDR_VAR 0 7
100545: PUSH
100546: LD_INT 16
100548: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
100549: LD_VAR 0 1
100553: PPUSH
100554: LD_VAR 0 2
100558: PPUSH
100559: LD_VAR 0 3
100563: PPUSH
100564: CALL_OW 297
100568: PUSH
100569: LD_VAR 0 5
100573: GREATER
100574: IFFALSE 100653
// begin ComMoveXY ( unit , x , y ) ;
100576: LD_VAR 0 1
100580: PPUSH
100581: LD_VAR 0 2
100585: PPUSH
100586: LD_VAR 0 3
100590: PPUSH
100591: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100595: LD_INT 35
100597: PPUSH
100598: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
100602: LD_VAR 0 1
100606: PPUSH
100607: LD_VAR 0 2
100611: PPUSH
100612: LD_VAR 0 3
100616: PPUSH
100617: CALL 50284 0 3
100621: NOT
100622: IFFALSE 100626
// exit ;
100624: GO 100880
// until GetDistUnitXY ( unit , x , y ) < dist ;
100626: LD_VAR 0 1
100630: PPUSH
100631: LD_VAR 0 2
100635: PPUSH
100636: LD_VAR 0 3
100640: PPUSH
100641: CALL_OW 297
100645: PUSH
100646: LD_VAR 0 5
100650: LESS
100651: IFFALSE 100595
// end ; ComTurnXY ( unit , x , y ) ;
100653: LD_VAR 0 1
100657: PPUSH
100658: LD_VAR 0 2
100662: PPUSH
100663: LD_VAR 0 3
100667: PPUSH
100668: CALL_OW 118
// wait ( 5 ) ;
100672: LD_INT 5
100674: PPUSH
100675: CALL_OW 67
// _d := GetDir ( unit ) ;
100679: LD_ADDR_VAR 0 10
100683: PUSH
100684: LD_VAR 0 1
100688: PPUSH
100689: CALL_OW 254
100693: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
100694: LD_ADDR_VAR 0 8
100698: PUSH
100699: LD_VAR 0 1
100703: PPUSH
100704: CALL_OW 250
100708: PPUSH
100709: LD_VAR 0 10
100713: PPUSH
100714: LD_VAR 0 5
100718: PPUSH
100719: CALL_OW 272
100723: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
100724: LD_ADDR_VAR 0 9
100728: PUSH
100729: LD_VAR 0 1
100733: PPUSH
100734: CALL_OW 251
100738: PPUSH
100739: LD_VAR 0 10
100743: PPUSH
100744: LD_VAR 0 5
100748: PPUSH
100749: CALL_OW 273
100753: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
100754: LD_VAR 0 8
100758: PPUSH
100759: LD_VAR 0 9
100763: PPUSH
100764: CALL_OW 488
100768: NOT
100769: IFFALSE 100773
// exit ;
100771: GO 100880
// ComAnimCustom ( unit , 1 ) ;
100773: LD_VAR 0 1
100777: PPUSH
100778: LD_INT 1
100780: PPUSH
100781: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
100785: LD_VAR 0 8
100789: PPUSH
100790: LD_VAR 0 9
100794: PPUSH
100795: LD_VAR 0 6
100799: PPUSH
100800: LD_VAR 0 7
100804: PPUSH
100805: CALL_OW 330
// repeat wait ( 1 ) ;
100809: LD_INT 1
100811: PPUSH
100812: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
100816: LD_VAR 0 1
100820: PPUSH
100821: CALL_OW 316
100825: PUSH
100826: LD_VAR 0 1
100830: PPUSH
100831: CALL_OW 314
100835: OR
100836: PUSH
100837: LD_VAR 0 1
100841: PPUSH
100842: CALL_OW 302
100846: NOT
100847: OR
100848: PUSH
100849: LD_VAR 0 1
100853: PPUSH
100854: CALL_OW 301
100858: OR
100859: IFFALSE 100809
// RemoveSeeing ( _x , _y , side ) ;
100861: LD_VAR 0 8
100865: PPUSH
100866: LD_VAR 0 9
100870: PPUSH
100871: LD_VAR 0 6
100875: PPUSH
100876: CALL_OW 331
// end ; end_of_file
100880: LD_VAR 0 4
100884: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100885: LD_INT 0
100887: PPUSH
100888: PPUSH
100889: PPUSH
100890: PPUSH
100891: PPUSH
100892: PPUSH
100893: PPUSH
100894: PPUSH
100895: PPUSH
100896: PPUSH
100897: PPUSH
100898: PPUSH
100899: PPUSH
100900: PPUSH
100901: PPUSH
100902: PPUSH
100903: PPUSH
100904: PPUSH
100905: PPUSH
100906: PPUSH
100907: PPUSH
100908: PPUSH
100909: PPUSH
100910: PPUSH
100911: PPUSH
100912: PPUSH
100913: PPUSH
100914: PPUSH
100915: PPUSH
100916: PPUSH
100917: PPUSH
100918: PPUSH
100919: PPUSH
100920: PPUSH
// if not list then
100921: LD_VAR 0 1
100925: NOT
100926: IFFALSE 100930
// exit ;
100928: GO 105589
// base := list [ 1 ] ;
100930: LD_ADDR_VAR 0 3
100934: PUSH
100935: LD_VAR 0 1
100939: PUSH
100940: LD_INT 1
100942: ARRAY
100943: ST_TO_ADDR
// group := list [ 2 ] ;
100944: LD_ADDR_VAR 0 4
100948: PUSH
100949: LD_VAR 0 1
100953: PUSH
100954: LD_INT 2
100956: ARRAY
100957: ST_TO_ADDR
// path := list [ 3 ] ;
100958: LD_ADDR_VAR 0 5
100962: PUSH
100963: LD_VAR 0 1
100967: PUSH
100968: LD_INT 3
100970: ARRAY
100971: ST_TO_ADDR
// flags := list [ 4 ] ;
100972: LD_ADDR_VAR 0 6
100976: PUSH
100977: LD_VAR 0 1
100981: PUSH
100982: LD_INT 4
100984: ARRAY
100985: ST_TO_ADDR
// mined := [ ] ;
100986: LD_ADDR_VAR 0 27
100990: PUSH
100991: EMPTY
100992: ST_TO_ADDR
// bombed := [ ] ;
100993: LD_ADDR_VAR 0 28
100997: PUSH
100998: EMPTY
100999: ST_TO_ADDR
// healers := [ ] ;
101000: LD_ADDR_VAR 0 31
101004: PUSH
101005: EMPTY
101006: ST_TO_ADDR
// to_heal := [ ] ;
101007: LD_ADDR_VAR 0 30
101011: PUSH
101012: EMPTY
101013: ST_TO_ADDR
// repairs := [ ] ;
101014: LD_ADDR_VAR 0 33
101018: PUSH
101019: EMPTY
101020: ST_TO_ADDR
// to_repair := [ ] ;
101021: LD_ADDR_VAR 0 32
101025: PUSH
101026: EMPTY
101027: ST_TO_ADDR
// if not group or not path then
101028: LD_VAR 0 4
101032: NOT
101033: PUSH
101034: LD_VAR 0 5
101038: NOT
101039: OR
101040: IFFALSE 101044
// exit ;
101042: GO 105589
// side := GetSide ( group [ 1 ] ) ;
101044: LD_ADDR_VAR 0 35
101048: PUSH
101049: LD_VAR 0 4
101053: PUSH
101054: LD_INT 1
101056: ARRAY
101057: PPUSH
101058: CALL_OW 255
101062: ST_TO_ADDR
// if flags then
101063: LD_VAR 0 6
101067: IFFALSE 101211
// begin f_ignore_area := flags [ 1 ] ;
101069: LD_ADDR_VAR 0 17
101073: PUSH
101074: LD_VAR 0 6
101078: PUSH
101079: LD_INT 1
101081: ARRAY
101082: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
101083: LD_ADDR_VAR 0 18
101087: PUSH
101088: LD_VAR 0 6
101092: PUSH
101093: LD_INT 2
101095: ARRAY
101096: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101097: LD_ADDR_VAR 0 19
101101: PUSH
101102: LD_VAR 0 6
101106: PUSH
101107: LD_INT 3
101109: ARRAY
101110: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101111: LD_ADDR_VAR 0 20
101115: PUSH
101116: LD_VAR 0 6
101120: PUSH
101121: LD_INT 4
101123: ARRAY
101124: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101125: LD_ADDR_VAR 0 21
101129: PUSH
101130: LD_VAR 0 6
101134: PUSH
101135: LD_INT 5
101137: ARRAY
101138: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101139: LD_ADDR_VAR 0 22
101143: PUSH
101144: LD_VAR 0 6
101148: PUSH
101149: LD_INT 6
101151: ARRAY
101152: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101153: LD_ADDR_VAR 0 23
101157: PUSH
101158: LD_VAR 0 6
101162: PUSH
101163: LD_INT 7
101165: ARRAY
101166: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101167: LD_ADDR_VAR 0 24
101171: PUSH
101172: LD_VAR 0 6
101176: PUSH
101177: LD_INT 8
101179: ARRAY
101180: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101181: LD_ADDR_VAR 0 25
101185: PUSH
101186: LD_VAR 0 6
101190: PUSH
101191: LD_INT 9
101193: ARRAY
101194: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101195: LD_ADDR_VAR 0 26
101199: PUSH
101200: LD_VAR 0 6
101204: PUSH
101205: LD_INT 10
101207: ARRAY
101208: ST_TO_ADDR
// end else
101209: GO 101291
// begin f_ignore_area := false ;
101211: LD_ADDR_VAR 0 17
101215: PUSH
101216: LD_INT 0
101218: ST_TO_ADDR
// f_capture := false ;
101219: LD_ADDR_VAR 0 18
101223: PUSH
101224: LD_INT 0
101226: ST_TO_ADDR
// f_ignore_civ := false ;
101227: LD_ADDR_VAR 0 19
101231: PUSH
101232: LD_INT 0
101234: ST_TO_ADDR
// f_murder := false ;
101235: LD_ADDR_VAR 0 20
101239: PUSH
101240: LD_INT 0
101242: ST_TO_ADDR
// f_mines := false ;
101243: LD_ADDR_VAR 0 21
101247: PUSH
101248: LD_INT 0
101250: ST_TO_ADDR
// f_repair := false ;
101251: LD_ADDR_VAR 0 22
101255: PUSH
101256: LD_INT 0
101258: ST_TO_ADDR
// f_heal := false ;
101259: LD_ADDR_VAR 0 23
101263: PUSH
101264: LD_INT 0
101266: ST_TO_ADDR
// f_spacetime := false ;
101267: LD_ADDR_VAR 0 24
101271: PUSH
101272: LD_INT 0
101274: ST_TO_ADDR
// f_attack_depot := false ;
101275: LD_ADDR_VAR 0 25
101279: PUSH
101280: LD_INT 0
101282: ST_TO_ADDR
// f_crawl := false ;
101283: LD_ADDR_VAR 0 26
101287: PUSH
101288: LD_INT 0
101290: ST_TO_ADDR
// end ; if f_heal then
101291: LD_VAR 0 23
101295: IFFALSE 101322
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101297: LD_ADDR_VAR 0 31
101301: PUSH
101302: LD_VAR 0 4
101306: PPUSH
101307: LD_INT 25
101309: PUSH
101310: LD_INT 4
101312: PUSH
101313: EMPTY
101314: LIST
101315: LIST
101316: PPUSH
101317: CALL_OW 72
101321: ST_TO_ADDR
// if f_repair then
101322: LD_VAR 0 22
101326: IFFALSE 101353
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101328: LD_ADDR_VAR 0 33
101332: PUSH
101333: LD_VAR 0 4
101337: PPUSH
101338: LD_INT 25
101340: PUSH
101341: LD_INT 3
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PPUSH
101348: CALL_OW 72
101352: ST_TO_ADDR
// units_path := [ ] ;
101353: LD_ADDR_VAR 0 16
101357: PUSH
101358: EMPTY
101359: ST_TO_ADDR
// for i = 1 to group do
101360: LD_ADDR_VAR 0 7
101364: PUSH
101365: DOUBLE
101366: LD_INT 1
101368: DEC
101369: ST_TO_ADDR
101370: LD_VAR 0 4
101374: PUSH
101375: FOR_TO
101376: IFFALSE 101405
// units_path := Replace ( units_path , i , path ) ;
101378: LD_ADDR_VAR 0 16
101382: PUSH
101383: LD_VAR 0 16
101387: PPUSH
101388: LD_VAR 0 7
101392: PPUSH
101393: LD_VAR 0 5
101397: PPUSH
101398: CALL_OW 1
101402: ST_TO_ADDR
101403: GO 101375
101405: POP
101406: POP
// repeat for i = group downto 1 do
101407: LD_ADDR_VAR 0 7
101411: PUSH
101412: DOUBLE
101413: LD_VAR 0 4
101417: INC
101418: ST_TO_ADDR
101419: LD_INT 1
101421: PUSH
101422: FOR_DOWNTO
101423: IFFALSE 105545
// begin wait ( 5 ) ;
101425: LD_INT 5
101427: PPUSH
101428: CALL_OW 67
// tmp := [ ] ;
101432: LD_ADDR_VAR 0 14
101436: PUSH
101437: EMPTY
101438: ST_TO_ADDR
// attacking := false ;
101439: LD_ADDR_VAR 0 29
101443: PUSH
101444: LD_INT 0
101446: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101447: LD_VAR 0 4
101451: PUSH
101452: LD_VAR 0 7
101456: ARRAY
101457: PPUSH
101458: CALL_OW 301
101462: PUSH
101463: LD_VAR 0 4
101467: PUSH
101468: LD_VAR 0 7
101472: ARRAY
101473: NOT
101474: OR
101475: IFFALSE 101584
// begin if GetType ( group [ i ] ) = unit_human then
101477: LD_VAR 0 4
101481: PUSH
101482: LD_VAR 0 7
101486: ARRAY
101487: PPUSH
101488: CALL_OW 247
101492: PUSH
101493: LD_INT 1
101495: EQUAL
101496: IFFALSE 101542
// begin to_heal := to_heal diff group [ i ] ;
101498: LD_ADDR_VAR 0 30
101502: PUSH
101503: LD_VAR 0 30
101507: PUSH
101508: LD_VAR 0 4
101512: PUSH
101513: LD_VAR 0 7
101517: ARRAY
101518: DIFF
101519: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101520: LD_ADDR_VAR 0 31
101524: PUSH
101525: LD_VAR 0 31
101529: PUSH
101530: LD_VAR 0 4
101534: PUSH
101535: LD_VAR 0 7
101539: ARRAY
101540: DIFF
101541: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101542: LD_ADDR_VAR 0 4
101546: PUSH
101547: LD_VAR 0 4
101551: PPUSH
101552: LD_VAR 0 7
101556: PPUSH
101557: CALL_OW 3
101561: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101562: LD_ADDR_VAR 0 16
101566: PUSH
101567: LD_VAR 0 16
101571: PPUSH
101572: LD_VAR 0 7
101576: PPUSH
101577: CALL_OW 3
101581: ST_TO_ADDR
// continue ;
101582: GO 101422
// end ; if f_repair then
101584: LD_VAR 0 22
101588: IFFALSE 102077
// begin if GetType ( group [ i ] ) = unit_vehicle then
101590: LD_VAR 0 4
101594: PUSH
101595: LD_VAR 0 7
101599: ARRAY
101600: PPUSH
101601: CALL_OW 247
101605: PUSH
101606: LD_INT 2
101608: EQUAL
101609: IFFALSE 101799
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101611: LD_VAR 0 4
101615: PUSH
101616: LD_VAR 0 7
101620: ARRAY
101621: PPUSH
101622: CALL_OW 256
101626: PUSH
101627: LD_INT 700
101629: LESS
101630: PUSH
101631: LD_VAR 0 4
101635: PUSH
101636: LD_VAR 0 7
101640: ARRAY
101641: PUSH
101642: LD_VAR 0 32
101646: IN
101647: NOT
101648: AND
101649: IFFALSE 101673
// to_repair := to_repair union group [ i ] ;
101651: LD_ADDR_VAR 0 32
101655: PUSH
101656: LD_VAR 0 32
101660: PUSH
101661: LD_VAR 0 4
101665: PUSH
101666: LD_VAR 0 7
101670: ARRAY
101671: UNION
101672: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101673: LD_VAR 0 4
101677: PUSH
101678: LD_VAR 0 7
101682: ARRAY
101683: PPUSH
101684: CALL_OW 256
101688: PUSH
101689: LD_INT 1000
101691: EQUAL
101692: PUSH
101693: LD_VAR 0 4
101697: PUSH
101698: LD_VAR 0 7
101702: ARRAY
101703: PUSH
101704: LD_VAR 0 32
101708: IN
101709: AND
101710: IFFALSE 101734
// to_repair := to_repair diff group [ i ] ;
101712: LD_ADDR_VAR 0 32
101716: PUSH
101717: LD_VAR 0 32
101721: PUSH
101722: LD_VAR 0 4
101726: PUSH
101727: LD_VAR 0 7
101731: ARRAY
101732: DIFF
101733: ST_TO_ADDR
// if group [ i ] in to_repair then
101734: LD_VAR 0 4
101738: PUSH
101739: LD_VAR 0 7
101743: ARRAY
101744: PUSH
101745: LD_VAR 0 32
101749: IN
101750: IFFALSE 101797
// begin if not IsInArea ( group [ i ] , f_repair ) then
101752: LD_VAR 0 4
101756: PUSH
101757: LD_VAR 0 7
101761: ARRAY
101762: PPUSH
101763: LD_VAR 0 22
101767: PPUSH
101768: CALL_OW 308
101772: NOT
101773: IFFALSE 101795
// ComMoveToArea ( group [ i ] , f_repair ) ;
101775: LD_VAR 0 4
101779: PUSH
101780: LD_VAR 0 7
101784: ARRAY
101785: PPUSH
101786: LD_VAR 0 22
101790: PPUSH
101791: CALL_OW 113
// continue ;
101795: GO 101422
// end ; end else
101797: GO 102077
// if group [ i ] in repairs then
101799: LD_VAR 0 4
101803: PUSH
101804: LD_VAR 0 7
101808: ARRAY
101809: PUSH
101810: LD_VAR 0 33
101814: IN
101815: IFFALSE 102077
// begin if IsInUnit ( group [ i ] ) then
101817: LD_VAR 0 4
101821: PUSH
101822: LD_VAR 0 7
101826: ARRAY
101827: PPUSH
101828: CALL_OW 310
101832: IFFALSE 101900
// begin z := IsInUnit ( group [ i ] ) ;
101834: LD_ADDR_VAR 0 13
101838: PUSH
101839: LD_VAR 0 4
101843: PUSH
101844: LD_VAR 0 7
101848: ARRAY
101849: PPUSH
101850: CALL_OW 310
101854: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101855: LD_VAR 0 13
101859: PUSH
101860: LD_VAR 0 32
101864: IN
101865: PUSH
101866: LD_VAR 0 13
101870: PPUSH
101871: LD_VAR 0 22
101875: PPUSH
101876: CALL_OW 308
101880: AND
101881: IFFALSE 101898
// ComExitVehicle ( group [ i ] ) ;
101883: LD_VAR 0 4
101887: PUSH
101888: LD_VAR 0 7
101892: ARRAY
101893: PPUSH
101894: CALL_OW 121
// end else
101898: GO 102077
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101900: LD_ADDR_VAR 0 13
101904: PUSH
101905: LD_VAR 0 4
101909: PPUSH
101910: LD_INT 95
101912: PUSH
101913: LD_VAR 0 22
101917: PUSH
101918: EMPTY
101919: LIST
101920: LIST
101921: PUSH
101922: LD_INT 58
101924: PUSH
101925: EMPTY
101926: LIST
101927: PUSH
101928: EMPTY
101929: LIST
101930: LIST
101931: PPUSH
101932: CALL_OW 72
101936: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101937: LD_VAR 0 4
101941: PUSH
101942: LD_VAR 0 7
101946: ARRAY
101947: PPUSH
101948: CALL_OW 314
101952: NOT
101953: IFFALSE 102075
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101955: LD_ADDR_VAR 0 10
101959: PUSH
101960: LD_VAR 0 13
101964: PPUSH
101965: LD_VAR 0 4
101969: PUSH
101970: LD_VAR 0 7
101974: ARRAY
101975: PPUSH
101976: CALL_OW 74
101980: ST_TO_ADDR
// if not x then
101981: LD_VAR 0 10
101985: NOT
101986: IFFALSE 101990
// continue ;
101988: GO 101422
// if GetLives ( x ) < 1000 then
101990: LD_VAR 0 10
101994: PPUSH
101995: CALL_OW 256
101999: PUSH
102000: LD_INT 1000
102002: LESS
102003: IFFALSE 102027
// ComRepairVehicle ( group [ i ] , x ) else
102005: LD_VAR 0 4
102009: PUSH
102010: LD_VAR 0 7
102014: ARRAY
102015: PPUSH
102016: LD_VAR 0 10
102020: PPUSH
102021: CALL_OW 129
102025: GO 102075
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
102027: LD_VAR 0 23
102031: PUSH
102032: LD_VAR 0 4
102036: PUSH
102037: LD_VAR 0 7
102041: ARRAY
102042: PPUSH
102043: CALL_OW 256
102047: PUSH
102048: LD_INT 1000
102050: LESS
102051: AND
102052: NOT
102053: IFFALSE 102075
// ComEnterUnit ( group [ i ] , x ) ;
102055: LD_VAR 0 4
102059: PUSH
102060: LD_VAR 0 7
102064: ARRAY
102065: PPUSH
102066: LD_VAR 0 10
102070: PPUSH
102071: CALL_OW 120
// end ; continue ;
102075: GO 101422
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
102077: LD_VAR 0 23
102081: PUSH
102082: LD_VAR 0 4
102086: PUSH
102087: LD_VAR 0 7
102091: ARRAY
102092: PPUSH
102093: CALL_OW 247
102097: PUSH
102098: LD_INT 1
102100: EQUAL
102101: AND
102102: IFFALSE 102580
// begin if group [ i ] in healers then
102104: LD_VAR 0 4
102108: PUSH
102109: LD_VAR 0 7
102113: ARRAY
102114: PUSH
102115: LD_VAR 0 31
102119: IN
102120: IFFALSE 102393
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102122: LD_VAR 0 4
102126: PUSH
102127: LD_VAR 0 7
102131: ARRAY
102132: PPUSH
102133: LD_VAR 0 23
102137: PPUSH
102138: CALL_OW 308
102142: NOT
102143: PUSH
102144: LD_VAR 0 4
102148: PUSH
102149: LD_VAR 0 7
102153: ARRAY
102154: PPUSH
102155: CALL_OW 314
102159: NOT
102160: AND
102161: IFFALSE 102185
// ComMoveToArea ( group [ i ] , f_heal ) else
102163: LD_VAR 0 4
102167: PUSH
102168: LD_VAR 0 7
102172: ARRAY
102173: PPUSH
102174: LD_VAR 0 23
102178: PPUSH
102179: CALL_OW 113
102183: GO 102391
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102185: LD_VAR 0 4
102189: PUSH
102190: LD_VAR 0 7
102194: ARRAY
102195: PPUSH
102196: CALL 48807 0 1
102200: PPUSH
102201: CALL_OW 256
102205: PUSH
102206: LD_INT 1000
102208: EQUAL
102209: IFFALSE 102228
// ComStop ( group [ i ] ) else
102211: LD_VAR 0 4
102215: PUSH
102216: LD_VAR 0 7
102220: ARRAY
102221: PPUSH
102222: CALL_OW 141
102226: GO 102391
// if not HasTask ( group [ i ] ) and to_heal then
102228: LD_VAR 0 4
102232: PUSH
102233: LD_VAR 0 7
102237: ARRAY
102238: PPUSH
102239: CALL_OW 314
102243: NOT
102244: PUSH
102245: LD_VAR 0 30
102249: AND
102250: IFFALSE 102391
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102252: LD_ADDR_VAR 0 13
102256: PUSH
102257: LD_VAR 0 30
102261: PPUSH
102262: LD_INT 3
102264: PUSH
102265: LD_INT 54
102267: PUSH
102268: EMPTY
102269: LIST
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PPUSH
102275: CALL_OW 72
102279: PPUSH
102280: LD_VAR 0 4
102284: PUSH
102285: LD_VAR 0 7
102289: ARRAY
102290: PPUSH
102291: CALL_OW 74
102295: ST_TO_ADDR
// if z then
102296: LD_VAR 0 13
102300: IFFALSE 102391
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102302: LD_INT 91
102304: PUSH
102305: LD_VAR 0 13
102309: PUSH
102310: LD_INT 10
102312: PUSH
102313: EMPTY
102314: LIST
102315: LIST
102316: LIST
102317: PUSH
102318: LD_INT 81
102320: PUSH
102321: LD_VAR 0 13
102325: PPUSH
102326: CALL_OW 255
102330: PUSH
102331: EMPTY
102332: LIST
102333: LIST
102334: PUSH
102335: EMPTY
102336: LIST
102337: LIST
102338: PPUSH
102339: CALL_OW 69
102343: PUSH
102344: LD_INT 0
102346: EQUAL
102347: IFFALSE 102371
// ComHeal ( group [ i ] , z ) else
102349: LD_VAR 0 4
102353: PUSH
102354: LD_VAR 0 7
102358: ARRAY
102359: PPUSH
102360: LD_VAR 0 13
102364: PPUSH
102365: CALL_OW 128
102369: GO 102391
// ComMoveToArea ( group [ i ] , f_heal ) ;
102371: LD_VAR 0 4
102375: PUSH
102376: LD_VAR 0 7
102380: ARRAY
102381: PPUSH
102382: LD_VAR 0 23
102386: PPUSH
102387: CALL_OW 113
// end ; continue ;
102391: GO 101422
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102393: LD_VAR 0 4
102397: PUSH
102398: LD_VAR 0 7
102402: ARRAY
102403: PPUSH
102404: CALL_OW 256
102408: PUSH
102409: LD_INT 700
102411: LESS
102412: PUSH
102413: LD_VAR 0 4
102417: PUSH
102418: LD_VAR 0 7
102422: ARRAY
102423: PUSH
102424: LD_VAR 0 30
102428: IN
102429: NOT
102430: AND
102431: IFFALSE 102455
// to_heal := to_heal union group [ i ] ;
102433: LD_ADDR_VAR 0 30
102437: PUSH
102438: LD_VAR 0 30
102442: PUSH
102443: LD_VAR 0 4
102447: PUSH
102448: LD_VAR 0 7
102452: ARRAY
102453: UNION
102454: ST_TO_ADDR
// if group [ i ] in to_heal then
102455: LD_VAR 0 4
102459: PUSH
102460: LD_VAR 0 7
102464: ARRAY
102465: PUSH
102466: LD_VAR 0 30
102470: IN
102471: IFFALSE 102580
// begin if GetLives ( group [ i ] ) = 1000 then
102473: LD_VAR 0 4
102477: PUSH
102478: LD_VAR 0 7
102482: ARRAY
102483: PPUSH
102484: CALL_OW 256
102488: PUSH
102489: LD_INT 1000
102491: EQUAL
102492: IFFALSE 102518
// to_heal := to_heal diff group [ i ] else
102494: LD_ADDR_VAR 0 30
102498: PUSH
102499: LD_VAR 0 30
102503: PUSH
102504: LD_VAR 0 4
102508: PUSH
102509: LD_VAR 0 7
102513: ARRAY
102514: DIFF
102515: ST_TO_ADDR
102516: GO 102580
// begin if not IsInArea ( group [ i ] , to_heal ) then
102518: LD_VAR 0 4
102522: PUSH
102523: LD_VAR 0 7
102527: ARRAY
102528: PPUSH
102529: LD_VAR 0 30
102533: PPUSH
102534: CALL_OW 308
102538: NOT
102539: IFFALSE 102563
// ComMoveToArea ( group [ i ] , f_heal ) else
102541: LD_VAR 0 4
102545: PUSH
102546: LD_VAR 0 7
102550: ARRAY
102551: PPUSH
102552: LD_VAR 0 23
102556: PPUSH
102557: CALL_OW 113
102561: GO 102578
// ComHold ( group [ i ] ) ;
102563: LD_VAR 0 4
102567: PUSH
102568: LD_VAR 0 7
102572: ARRAY
102573: PPUSH
102574: CALL_OW 140
// continue ;
102578: GO 101422
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102580: LD_VAR 0 4
102584: PUSH
102585: LD_VAR 0 7
102589: ARRAY
102590: PPUSH
102591: LD_INT 10
102593: PPUSH
102594: CALL 47227 0 2
102598: NOT
102599: PUSH
102600: LD_VAR 0 16
102604: PUSH
102605: LD_VAR 0 7
102609: ARRAY
102610: PUSH
102611: EMPTY
102612: EQUAL
102613: NOT
102614: AND
102615: IFFALSE 102881
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102617: LD_VAR 0 4
102621: PUSH
102622: LD_VAR 0 7
102626: ARRAY
102627: PPUSH
102628: CALL_OW 262
102632: PUSH
102633: LD_INT 1
102635: PUSH
102636: LD_INT 2
102638: PUSH
102639: EMPTY
102640: LIST
102641: LIST
102642: IN
102643: IFFALSE 102684
// if GetFuel ( group [ i ] ) < 10 then
102645: LD_VAR 0 4
102649: PUSH
102650: LD_VAR 0 7
102654: ARRAY
102655: PPUSH
102656: CALL_OW 261
102660: PUSH
102661: LD_INT 10
102663: LESS
102664: IFFALSE 102684
// SetFuel ( group [ i ] , 12 ) ;
102666: LD_VAR 0 4
102670: PUSH
102671: LD_VAR 0 7
102675: ARRAY
102676: PPUSH
102677: LD_INT 12
102679: PPUSH
102680: CALL_OW 240
// if units_path [ i ] then
102684: LD_VAR 0 16
102688: PUSH
102689: LD_VAR 0 7
102693: ARRAY
102694: IFFALSE 102879
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102696: LD_VAR 0 4
102700: PUSH
102701: LD_VAR 0 7
102705: ARRAY
102706: PPUSH
102707: LD_VAR 0 16
102711: PUSH
102712: LD_VAR 0 7
102716: ARRAY
102717: PUSH
102718: LD_INT 1
102720: ARRAY
102721: PUSH
102722: LD_INT 1
102724: ARRAY
102725: PPUSH
102726: LD_VAR 0 16
102730: PUSH
102731: LD_VAR 0 7
102735: ARRAY
102736: PUSH
102737: LD_INT 1
102739: ARRAY
102740: PUSH
102741: LD_INT 2
102743: ARRAY
102744: PPUSH
102745: CALL_OW 297
102749: PUSH
102750: LD_INT 6
102752: GREATER
102753: IFFALSE 102828
// begin if not HasTask ( group [ i ] ) then
102755: LD_VAR 0 4
102759: PUSH
102760: LD_VAR 0 7
102764: ARRAY
102765: PPUSH
102766: CALL_OW 314
102770: NOT
102771: IFFALSE 102826
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102773: LD_VAR 0 4
102777: PUSH
102778: LD_VAR 0 7
102782: ARRAY
102783: PPUSH
102784: LD_VAR 0 16
102788: PUSH
102789: LD_VAR 0 7
102793: ARRAY
102794: PUSH
102795: LD_INT 1
102797: ARRAY
102798: PUSH
102799: LD_INT 1
102801: ARRAY
102802: PPUSH
102803: LD_VAR 0 16
102807: PUSH
102808: LD_VAR 0 7
102812: ARRAY
102813: PUSH
102814: LD_INT 1
102816: ARRAY
102817: PUSH
102818: LD_INT 2
102820: ARRAY
102821: PPUSH
102822: CALL_OW 114
// end else
102826: GO 102879
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102828: LD_ADDR_VAR 0 15
102832: PUSH
102833: LD_VAR 0 16
102837: PUSH
102838: LD_VAR 0 7
102842: ARRAY
102843: PPUSH
102844: LD_INT 1
102846: PPUSH
102847: CALL_OW 3
102851: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102852: LD_ADDR_VAR 0 16
102856: PUSH
102857: LD_VAR 0 16
102861: PPUSH
102862: LD_VAR 0 7
102866: PPUSH
102867: LD_VAR 0 15
102871: PPUSH
102872: CALL_OW 1
102876: ST_TO_ADDR
// continue ;
102877: GO 101422
// end ; end ; end else
102879: GO 105543
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102881: LD_ADDR_VAR 0 14
102885: PUSH
102886: LD_INT 81
102888: PUSH
102889: LD_VAR 0 4
102893: PUSH
102894: LD_VAR 0 7
102898: ARRAY
102899: PPUSH
102900: CALL_OW 255
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: PPUSH
102909: CALL_OW 69
102913: ST_TO_ADDR
// if not tmp then
102914: LD_VAR 0 14
102918: NOT
102919: IFFALSE 102923
// continue ;
102921: GO 101422
// if f_ignore_area then
102923: LD_VAR 0 17
102927: IFFALSE 103015
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102929: LD_ADDR_VAR 0 15
102933: PUSH
102934: LD_VAR 0 14
102938: PPUSH
102939: LD_INT 3
102941: PUSH
102942: LD_INT 92
102944: PUSH
102945: LD_VAR 0 17
102949: PUSH
102950: LD_INT 1
102952: ARRAY
102953: PUSH
102954: LD_VAR 0 17
102958: PUSH
102959: LD_INT 2
102961: ARRAY
102962: PUSH
102963: LD_VAR 0 17
102967: PUSH
102968: LD_INT 3
102970: ARRAY
102971: PUSH
102972: EMPTY
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: PUSH
102978: EMPTY
102979: LIST
102980: LIST
102981: PPUSH
102982: CALL_OW 72
102986: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102987: LD_VAR 0 14
102991: PUSH
102992: LD_VAR 0 15
102996: DIFF
102997: IFFALSE 103015
// tmp := tmp diff tmp2 ;
102999: LD_ADDR_VAR 0 14
103003: PUSH
103004: LD_VAR 0 14
103008: PUSH
103009: LD_VAR 0 15
103013: DIFF
103014: ST_TO_ADDR
// end ; if not f_murder then
103015: LD_VAR 0 20
103019: NOT
103020: IFFALSE 103078
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
103022: LD_ADDR_VAR 0 15
103026: PUSH
103027: LD_VAR 0 14
103031: PPUSH
103032: LD_INT 3
103034: PUSH
103035: LD_INT 50
103037: PUSH
103038: EMPTY
103039: LIST
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PPUSH
103045: CALL_OW 72
103049: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
103050: LD_VAR 0 14
103054: PUSH
103055: LD_VAR 0 15
103059: DIFF
103060: IFFALSE 103078
// tmp := tmp diff tmp2 ;
103062: LD_ADDR_VAR 0 14
103066: PUSH
103067: LD_VAR 0 14
103071: PUSH
103072: LD_VAR 0 15
103076: DIFF
103077: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
103078: LD_ADDR_VAR 0 14
103082: PUSH
103083: LD_VAR 0 4
103087: PUSH
103088: LD_VAR 0 7
103092: ARRAY
103093: PPUSH
103094: LD_VAR 0 14
103098: PPUSH
103099: LD_INT 1
103101: PPUSH
103102: LD_INT 1
103104: PPUSH
103105: CALL 20161 0 4
103109: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103110: LD_VAR 0 4
103114: PUSH
103115: LD_VAR 0 7
103119: ARRAY
103120: PPUSH
103121: CALL_OW 257
103125: PUSH
103126: LD_INT 1
103128: EQUAL
103129: IFFALSE 103577
// begin if WantPlant ( group [ i ] ) then
103131: LD_VAR 0 4
103135: PUSH
103136: LD_VAR 0 7
103140: ARRAY
103141: PPUSH
103142: CALL 19662 0 1
103146: IFFALSE 103150
// continue ;
103148: GO 101422
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103150: LD_VAR 0 18
103154: PUSH
103155: LD_VAR 0 4
103159: PUSH
103160: LD_VAR 0 7
103164: ARRAY
103165: PPUSH
103166: CALL_OW 310
103170: NOT
103171: AND
103172: PUSH
103173: LD_VAR 0 14
103177: PUSH
103178: LD_INT 1
103180: ARRAY
103181: PUSH
103182: LD_VAR 0 14
103186: PPUSH
103187: LD_INT 21
103189: PUSH
103190: LD_INT 2
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: PUSH
103197: LD_INT 58
103199: PUSH
103200: EMPTY
103201: LIST
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: PPUSH
103207: CALL_OW 72
103211: IN
103212: AND
103213: IFFALSE 103249
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103215: LD_VAR 0 4
103219: PUSH
103220: LD_VAR 0 7
103224: ARRAY
103225: PPUSH
103226: LD_VAR 0 14
103230: PUSH
103231: LD_INT 1
103233: ARRAY
103234: PPUSH
103235: CALL_OW 120
// attacking := true ;
103239: LD_ADDR_VAR 0 29
103243: PUSH
103244: LD_INT 1
103246: ST_TO_ADDR
// continue ;
103247: GO 101422
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103249: LD_VAR 0 26
103253: PUSH
103254: LD_VAR 0 4
103258: PUSH
103259: LD_VAR 0 7
103263: ARRAY
103264: PPUSH
103265: CALL_OW 257
103269: PUSH
103270: LD_INT 1
103272: EQUAL
103273: AND
103274: PUSH
103275: LD_VAR 0 4
103279: PUSH
103280: LD_VAR 0 7
103284: ARRAY
103285: PPUSH
103286: CALL_OW 256
103290: PUSH
103291: LD_INT 800
103293: LESS
103294: AND
103295: PUSH
103296: LD_VAR 0 4
103300: PUSH
103301: LD_VAR 0 7
103305: ARRAY
103306: PPUSH
103307: CALL_OW 318
103311: NOT
103312: AND
103313: IFFALSE 103330
// ComCrawl ( group [ i ] ) ;
103315: LD_VAR 0 4
103319: PUSH
103320: LD_VAR 0 7
103324: ARRAY
103325: PPUSH
103326: CALL_OW 137
// if f_mines then
103330: LD_VAR 0 21
103334: IFFALSE 103577
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103336: LD_VAR 0 14
103340: PUSH
103341: LD_INT 1
103343: ARRAY
103344: PPUSH
103345: CALL_OW 247
103349: PUSH
103350: LD_INT 3
103352: EQUAL
103353: PUSH
103354: LD_VAR 0 14
103358: PUSH
103359: LD_INT 1
103361: ARRAY
103362: PUSH
103363: LD_VAR 0 27
103367: IN
103368: NOT
103369: AND
103370: IFFALSE 103577
// begin x := GetX ( tmp [ 1 ] ) ;
103372: LD_ADDR_VAR 0 10
103376: PUSH
103377: LD_VAR 0 14
103381: PUSH
103382: LD_INT 1
103384: ARRAY
103385: PPUSH
103386: CALL_OW 250
103390: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103391: LD_ADDR_VAR 0 11
103395: PUSH
103396: LD_VAR 0 14
103400: PUSH
103401: LD_INT 1
103403: ARRAY
103404: PPUSH
103405: CALL_OW 251
103409: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103410: LD_ADDR_VAR 0 12
103414: PUSH
103415: LD_VAR 0 4
103419: PUSH
103420: LD_VAR 0 7
103424: ARRAY
103425: PPUSH
103426: CALL 47312 0 1
103430: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103431: LD_VAR 0 4
103435: PUSH
103436: LD_VAR 0 7
103440: ARRAY
103441: PPUSH
103442: LD_VAR 0 10
103446: PPUSH
103447: LD_VAR 0 11
103451: PPUSH
103452: LD_VAR 0 14
103456: PUSH
103457: LD_INT 1
103459: ARRAY
103460: PPUSH
103461: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103465: LD_VAR 0 4
103469: PUSH
103470: LD_VAR 0 7
103474: ARRAY
103475: PPUSH
103476: LD_VAR 0 10
103480: PPUSH
103481: LD_VAR 0 12
103485: PPUSH
103486: LD_INT 7
103488: PPUSH
103489: CALL_OW 272
103493: PPUSH
103494: LD_VAR 0 11
103498: PPUSH
103499: LD_VAR 0 12
103503: PPUSH
103504: LD_INT 7
103506: PPUSH
103507: CALL_OW 273
103511: PPUSH
103512: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: LD_INT 71
103529: PPUSH
103530: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103534: LD_ADDR_VAR 0 27
103538: PUSH
103539: LD_VAR 0 27
103543: PPUSH
103544: LD_VAR 0 27
103548: PUSH
103549: LD_INT 1
103551: PLUS
103552: PPUSH
103553: LD_VAR 0 14
103557: PUSH
103558: LD_INT 1
103560: ARRAY
103561: PPUSH
103562: CALL_OW 1
103566: ST_TO_ADDR
// attacking := true ;
103567: LD_ADDR_VAR 0 29
103571: PUSH
103572: LD_INT 1
103574: ST_TO_ADDR
// continue ;
103575: GO 101422
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103577: LD_VAR 0 4
103581: PUSH
103582: LD_VAR 0 7
103586: ARRAY
103587: PPUSH
103588: CALL_OW 257
103592: PUSH
103593: LD_INT 17
103595: EQUAL
103596: PUSH
103597: LD_VAR 0 4
103601: PUSH
103602: LD_VAR 0 7
103606: ARRAY
103607: PPUSH
103608: CALL_OW 110
103612: PUSH
103613: LD_INT 71
103615: EQUAL
103616: NOT
103617: AND
103618: IFFALSE 103764
// begin attacking := false ;
103620: LD_ADDR_VAR 0 29
103624: PUSH
103625: LD_INT 0
103627: ST_TO_ADDR
// k := 5 ;
103628: LD_ADDR_VAR 0 9
103632: PUSH
103633: LD_INT 5
103635: ST_TO_ADDR
// if tmp < k then
103636: LD_VAR 0 14
103640: PUSH
103641: LD_VAR 0 9
103645: LESS
103646: IFFALSE 103658
// k := tmp ;
103648: LD_ADDR_VAR 0 9
103652: PUSH
103653: LD_VAR 0 14
103657: ST_TO_ADDR
// for j = 1 to k do
103658: LD_ADDR_VAR 0 8
103662: PUSH
103663: DOUBLE
103664: LD_INT 1
103666: DEC
103667: ST_TO_ADDR
103668: LD_VAR 0 9
103672: PUSH
103673: FOR_TO
103674: IFFALSE 103762
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103676: LD_VAR 0 14
103680: PUSH
103681: LD_VAR 0 8
103685: ARRAY
103686: PUSH
103687: LD_VAR 0 14
103691: PPUSH
103692: LD_INT 58
103694: PUSH
103695: EMPTY
103696: LIST
103697: PPUSH
103698: CALL_OW 72
103702: IN
103703: NOT
103704: IFFALSE 103760
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103706: LD_VAR 0 4
103710: PUSH
103711: LD_VAR 0 7
103715: ARRAY
103716: PPUSH
103717: LD_VAR 0 14
103721: PUSH
103722: LD_VAR 0 8
103726: ARRAY
103727: PPUSH
103728: CALL_OW 115
// attacking := true ;
103732: LD_ADDR_VAR 0 29
103736: PUSH
103737: LD_INT 1
103739: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103740: LD_VAR 0 4
103744: PUSH
103745: LD_VAR 0 7
103749: ARRAY
103750: PPUSH
103751: LD_INT 71
103753: PPUSH
103754: CALL_OW 109
// continue ;
103758: GO 103673
// end ; end ;
103760: GO 103673
103762: POP
103763: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103764: LD_VAR 0 4
103768: PUSH
103769: LD_VAR 0 7
103773: ARRAY
103774: PPUSH
103775: CALL_OW 257
103779: PUSH
103780: LD_INT 8
103782: EQUAL
103783: PUSH
103784: LD_VAR 0 4
103788: PUSH
103789: LD_VAR 0 7
103793: ARRAY
103794: PPUSH
103795: CALL_OW 264
103799: PUSH
103800: LD_INT 28
103802: PUSH
103803: LD_INT 45
103805: PUSH
103806: LD_INT 7
103808: PUSH
103809: LD_INT 47
103811: PUSH
103812: EMPTY
103813: LIST
103814: LIST
103815: LIST
103816: LIST
103817: IN
103818: OR
103819: IFFALSE 104075
// begin attacking := false ;
103821: LD_ADDR_VAR 0 29
103825: PUSH
103826: LD_INT 0
103828: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103829: LD_VAR 0 14
103833: PUSH
103834: LD_INT 1
103836: ARRAY
103837: PPUSH
103838: CALL_OW 266
103842: PUSH
103843: LD_INT 32
103845: PUSH
103846: LD_INT 31
103848: PUSH
103849: LD_INT 33
103851: PUSH
103852: LD_INT 4
103854: PUSH
103855: LD_INT 5
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: LIST
103862: LIST
103863: LIST
103864: IN
103865: IFFALSE 104051
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103867: LD_ADDR_VAR 0 9
103871: PUSH
103872: LD_VAR 0 14
103876: PUSH
103877: LD_INT 1
103879: ARRAY
103880: PPUSH
103881: CALL_OW 266
103885: PPUSH
103886: LD_VAR 0 14
103890: PUSH
103891: LD_INT 1
103893: ARRAY
103894: PPUSH
103895: CALL_OW 250
103899: PPUSH
103900: LD_VAR 0 14
103904: PUSH
103905: LD_INT 1
103907: ARRAY
103908: PPUSH
103909: CALL_OW 251
103913: PPUSH
103914: LD_VAR 0 14
103918: PUSH
103919: LD_INT 1
103921: ARRAY
103922: PPUSH
103923: CALL_OW 254
103927: PPUSH
103928: LD_VAR 0 14
103932: PUSH
103933: LD_INT 1
103935: ARRAY
103936: PPUSH
103937: CALL_OW 248
103941: PPUSH
103942: LD_INT 0
103944: PPUSH
103945: CALL 28682 0 6
103949: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103950: LD_ADDR_VAR 0 8
103954: PUSH
103955: LD_VAR 0 4
103959: PUSH
103960: LD_VAR 0 7
103964: ARRAY
103965: PPUSH
103966: LD_VAR 0 9
103970: PPUSH
103971: CALL 47352 0 2
103975: ST_TO_ADDR
// if j then
103976: LD_VAR 0 8
103980: IFFALSE 104049
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103982: LD_VAR 0 8
103986: PUSH
103987: LD_INT 1
103989: ARRAY
103990: PPUSH
103991: LD_VAR 0 8
103995: PUSH
103996: LD_INT 2
103998: ARRAY
103999: PPUSH
104000: CALL_OW 488
104004: IFFALSE 104049
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
104006: LD_VAR 0 4
104010: PUSH
104011: LD_VAR 0 7
104015: ARRAY
104016: PPUSH
104017: LD_VAR 0 8
104021: PUSH
104022: LD_INT 1
104024: ARRAY
104025: PPUSH
104026: LD_VAR 0 8
104030: PUSH
104031: LD_INT 2
104033: ARRAY
104034: PPUSH
104035: CALL_OW 116
// attacking := true ;
104039: LD_ADDR_VAR 0 29
104043: PUSH
104044: LD_INT 1
104046: ST_TO_ADDR
// continue ;
104047: GO 101422
// end ; end else
104049: GO 104075
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104051: LD_VAR 0 4
104055: PUSH
104056: LD_VAR 0 7
104060: ARRAY
104061: PPUSH
104062: LD_VAR 0 14
104066: PUSH
104067: LD_INT 1
104069: ARRAY
104070: PPUSH
104071: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
104075: LD_VAR 0 4
104079: PUSH
104080: LD_VAR 0 7
104084: ARRAY
104085: PPUSH
104086: CALL_OW 265
104090: PUSH
104091: LD_INT 11
104093: EQUAL
104094: IFFALSE 104372
// begin k := 10 ;
104096: LD_ADDR_VAR 0 9
104100: PUSH
104101: LD_INT 10
104103: ST_TO_ADDR
// x := 0 ;
104104: LD_ADDR_VAR 0 10
104108: PUSH
104109: LD_INT 0
104111: ST_TO_ADDR
// if tmp < k then
104112: LD_VAR 0 14
104116: PUSH
104117: LD_VAR 0 9
104121: LESS
104122: IFFALSE 104134
// k := tmp ;
104124: LD_ADDR_VAR 0 9
104128: PUSH
104129: LD_VAR 0 14
104133: ST_TO_ADDR
// for j = k downto 1 do
104134: LD_ADDR_VAR 0 8
104138: PUSH
104139: DOUBLE
104140: LD_VAR 0 9
104144: INC
104145: ST_TO_ADDR
104146: LD_INT 1
104148: PUSH
104149: FOR_DOWNTO
104150: IFFALSE 104225
// begin if GetType ( tmp [ j ] ) = unit_human then
104152: LD_VAR 0 14
104156: PUSH
104157: LD_VAR 0 8
104161: ARRAY
104162: PPUSH
104163: CALL_OW 247
104167: PUSH
104168: LD_INT 1
104170: EQUAL
104171: IFFALSE 104223
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104173: LD_VAR 0 4
104177: PUSH
104178: LD_VAR 0 7
104182: ARRAY
104183: PPUSH
104184: LD_VAR 0 14
104188: PUSH
104189: LD_VAR 0 8
104193: ARRAY
104194: PPUSH
104195: CALL 47623 0 2
// x := tmp [ j ] ;
104199: LD_ADDR_VAR 0 10
104203: PUSH
104204: LD_VAR 0 14
104208: PUSH
104209: LD_VAR 0 8
104213: ARRAY
104214: ST_TO_ADDR
// attacking := true ;
104215: LD_ADDR_VAR 0 29
104219: PUSH
104220: LD_INT 1
104222: ST_TO_ADDR
// end ; end ;
104223: GO 104149
104225: POP
104226: POP
// if not x then
104227: LD_VAR 0 10
104231: NOT
104232: IFFALSE 104372
// begin attacking := true ;
104234: LD_ADDR_VAR 0 29
104238: PUSH
104239: LD_INT 1
104241: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104242: LD_VAR 0 4
104246: PUSH
104247: LD_VAR 0 7
104251: ARRAY
104252: PPUSH
104253: CALL_OW 250
104257: PPUSH
104258: LD_VAR 0 4
104262: PUSH
104263: LD_VAR 0 7
104267: ARRAY
104268: PPUSH
104269: CALL_OW 251
104273: PPUSH
104274: CALL_OW 546
104278: PUSH
104279: LD_INT 2
104281: ARRAY
104282: PUSH
104283: LD_VAR 0 14
104287: PUSH
104288: LD_INT 1
104290: ARRAY
104291: PPUSH
104292: CALL_OW 250
104296: PPUSH
104297: LD_VAR 0 14
104301: PUSH
104302: LD_INT 1
104304: ARRAY
104305: PPUSH
104306: CALL_OW 251
104310: PPUSH
104311: CALL_OW 546
104315: PUSH
104316: LD_INT 2
104318: ARRAY
104319: EQUAL
104320: IFFALSE 104348
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104322: LD_VAR 0 4
104326: PUSH
104327: LD_VAR 0 7
104331: ARRAY
104332: PPUSH
104333: LD_VAR 0 14
104337: PUSH
104338: LD_INT 1
104340: ARRAY
104341: PPUSH
104342: CALL 47623 0 2
104346: GO 104372
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104348: LD_VAR 0 4
104352: PUSH
104353: LD_VAR 0 7
104357: ARRAY
104358: PPUSH
104359: LD_VAR 0 14
104363: PUSH
104364: LD_INT 1
104366: ARRAY
104367: PPUSH
104368: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104372: LD_VAR 0 4
104376: PUSH
104377: LD_VAR 0 7
104381: ARRAY
104382: PPUSH
104383: CALL_OW 264
104387: PUSH
104388: LD_INT 29
104390: EQUAL
104391: IFFALSE 104757
// begin if WantsToAttack ( group [ i ] ) in bombed then
104393: LD_VAR 0 4
104397: PUSH
104398: LD_VAR 0 7
104402: ARRAY
104403: PPUSH
104404: CALL_OW 319
104408: PUSH
104409: LD_VAR 0 28
104413: IN
104414: IFFALSE 104418
// continue ;
104416: GO 101422
// k := 8 ;
104418: LD_ADDR_VAR 0 9
104422: PUSH
104423: LD_INT 8
104425: ST_TO_ADDR
// x := 0 ;
104426: LD_ADDR_VAR 0 10
104430: PUSH
104431: LD_INT 0
104433: ST_TO_ADDR
// if tmp < k then
104434: LD_VAR 0 14
104438: PUSH
104439: LD_VAR 0 9
104443: LESS
104444: IFFALSE 104456
// k := tmp ;
104446: LD_ADDR_VAR 0 9
104450: PUSH
104451: LD_VAR 0 14
104455: ST_TO_ADDR
// for j = 1 to k do
104456: LD_ADDR_VAR 0 8
104460: PUSH
104461: DOUBLE
104462: LD_INT 1
104464: DEC
104465: ST_TO_ADDR
104466: LD_VAR 0 9
104470: PUSH
104471: FOR_TO
104472: IFFALSE 104604
// begin if GetType ( tmp [ j ] ) = unit_building then
104474: LD_VAR 0 14
104478: PUSH
104479: LD_VAR 0 8
104483: ARRAY
104484: PPUSH
104485: CALL_OW 247
104489: PUSH
104490: LD_INT 3
104492: EQUAL
104493: IFFALSE 104602
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104495: LD_VAR 0 14
104499: PUSH
104500: LD_VAR 0 8
104504: ARRAY
104505: PUSH
104506: LD_VAR 0 28
104510: IN
104511: NOT
104512: PUSH
104513: LD_VAR 0 14
104517: PUSH
104518: LD_VAR 0 8
104522: ARRAY
104523: PPUSH
104524: CALL_OW 313
104528: AND
104529: IFFALSE 104602
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104531: LD_VAR 0 4
104535: PUSH
104536: LD_VAR 0 7
104540: ARRAY
104541: PPUSH
104542: LD_VAR 0 14
104546: PUSH
104547: LD_VAR 0 8
104551: ARRAY
104552: PPUSH
104553: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104557: LD_ADDR_VAR 0 28
104561: PUSH
104562: LD_VAR 0 28
104566: PPUSH
104567: LD_VAR 0 28
104571: PUSH
104572: LD_INT 1
104574: PLUS
104575: PPUSH
104576: LD_VAR 0 14
104580: PUSH
104581: LD_VAR 0 8
104585: ARRAY
104586: PPUSH
104587: CALL_OW 1
104591: ST_TO_ADDR
// attacking := true ;
104592: LD_ADDR_VAR 0 29
104596: PUSH
104597: LD_INT 1
104599: ST_TO_ADDR
// break ;
104600: GO 104604
// end ; end ;
104602: GO 104471
104604: POP
104605: POP
// if not attacking and f_attack_depot then
104606: LD_VAR 0 29
104610: NOT
104611: PUSH
104612: LD_VAR 0 25
104616: AND
104617: IFFALSE 104712
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104619: LD_ADDR_VAR 0 13
104623: PUSH
104624: LD_VAR 0 14
104628: PPUSH
104629: LD_INT 2
104631: PUSH
104632: LD_INT 30
104634: PUSH
104635: LD_INT 0
104637: PUSH
104638: EMPTY
104639: LIST
104640: LIST
104641: PUSH
104642: LD_INT 30
104644: PUSH
104645: LD_INT 1
104647: PUSH
104648: EMPTY
104649: LIST
104650: LIST
104651: PUSH
104652: EMPTY
104653: LIST
104654: LIST
104655: LIST
104656: PPUSH
104657: CALL_OW 72
104661: ST_TO_ADDR
// if z then
104662: LD_VAR 0 13
104666: IFFALSE 104712
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104668: LD_VAR 0 4
104672: PUSH
104673: LD_VAR 0 7
104677: ARRAY
104678: PPUSH
104679: LD_VAR 0 13
104683: PPUSH
104684: LD_VAR 0 4
104688: PUSH
104689: LD_VAR 0 7
104693: ARRAY
104694: PPUSH
104695: CALL_OW 74
104699: PPUSH
104700: CALL_OW 115
// attacking := true ;
104704: LD_ADDR_VAR 0 29
104708: PUSH
104709: LD_INT 1
104711: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104712: LD_VAR 0 4
104716: PUSH
104717: LD_VAR 0 7
104721: ARRAY
104722: PPUSH
104723: CALL_OW 256
104727: PUSH
104728: LD_INT 500
104730: LESS
104731: IFFALSE 104757
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104733: LD_VAR 0 4
104737: PUSH
104738: LD_VAR 0 7
104742: ARRAY
104743: PPUSH
104744: LD_VAR 0 14
104748: PUSH
104749: LD_INT 1
104751: ARRAY
104752: PPUSH
104753: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104757: LD_VAR 0 4
104761: PUSH
104762: LD_VAR 0 7
104766: ARRAY
104767: PPUSH
104768: CALL_OW 264
104772: PUSH
104773: LD_INT 49
104775: EQUAL
104776: IFFALSE 104897
// begin if not HasTask ( group [ i ] ) then
104778: LD_VAR 0 4
104782: PUSH
104783: LD_VAR 0 7
104787: ARRAY
104788: PPUSH
104789: CALL_OW 314
104793: NOT
104794: IFFALSE 104897
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104796: LD_ADDR_VAR 0 9
104800: PUSH
104801: LD_INT 81
104803: PUSH
104804: LD_VAR 0 4
104808: PUSH
104809: LD_VAR 0 7
104813: ARRAY
104814: PPUSH
104815: CALL_OW 255
104819: PUSH
104820: EMPTY
104821: LIST
104822: LIST
104823: PPUSH
104824: CALL_OW 69
104828: PPUSH
104829: LD_VAR 0 4
104833: PUSH
104834: LD_VAR 0 7
104838: ARRAY
104839: PPUSH
104840: CALL_OW 74
104844: ST_TO_ADDR
// if k then
104845: LD_VAR 0 9
104849: IFFALSE 104897
// if GetDistUnits ( group [ i ] , k ) > 10 then
104851: LD_VAR 0 4
104855: PUSH
104856: LD_VAR 0 7
104860: ARRAY
104861: PPUSH
104862: LD_VAR 0 9
104866: PPUSH
104867: CALL_OW 296
104871: PUSH
104872: LD_INT 10
104874: GREATER
104875: IFFALSE 104897
// ComMoveUnit ( group [ i ] , k ) ;
104877: LD_VAR 0 4
104881: PUSH
104882: LD_VAR 0 7
104886: ARRAY
104887: PPUSH
104888: LD_VAR 0 9
104892: PPUSH
104893: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104897: LD_VAR 0 4
104901: PUSH
104902: LD_VAR 0 7
104906: ARRAY
104907: PPUSH
104908: CALL_OW 256
104912: PUSH
104913: LD_INT 250
104915: LESS
104916: PUSH
104917: LD_VAR 0 4
104921: PUSH
104922: LD_VAR 0 7
104926: ARRAY
104927: PUSH
104928: LD_INT 21
104930: PUSH
104931: LD_INT 2
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: PUSH
104938: LD_INT 23
104940: PUSH
104941: LD_INT 2
104943: PUSH
104944: EMPTY
104945: LIST
104946: LIST
104947: PUSH
104948: EMPTY
104949: LIST
104950: LIST
104951: PPUSH
104952: CALL_OW 69
104956: IN
104957: AND
104958: IFFALSE 105083
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104960: LD_ADDR_VAR 0 9
104964: PUSH
104965: LD_OWVAR 3
104969: PUSH
104970: LD_VAR 0 4
104974: PUSH
104975: LD_VAR 0 7
104979: ARRAY
104980: DIFF
104981: PPUSH
104982: LD_VAR 0 4
104986: PUSH
104987: LD_VAR 0 7
104991: ARRAY
104992: PPUSH
104993: CALL_OW 74
104997: ST_TO_ADDR
// if not k then
104998: LD_VAR 0 9
105002: NOT
105003: IFFALSE 105007
// continue ;
105005: GO 101422
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
105007: LD_VAR 0 9
105011: PUSH
105012: LD_INT 81
105014: PUSH
105015: LD_VAR 0 4
105019: PUSH
105020: LD_VAR 0 7
105024: ARRAY
105025: PPUSH
105026: CALL_OW 255
105030: PUSH
105031: EMPTY
105032: LIST
105033: LIST
105034: PPUSH
105035: CALL_OW 69
105039: IN
105040: PUSH
105041: LD_VAR 0 9
105045: PPUSH
105046: LD_VAR 0 4
105050: PUSH
105051: LD_VAR 0 7
105055: ARRAY
105056: PPUSH
105057: CALL_OW 296
105061: PUSH
105062: LD_INT 5
105064: LESS
105065: AND
105066: IFFALSE 105083
// ComAutodestruct ( group [ i ] ) ;
105068: LD_VAR 0 4
105072: PUSH
105073: LD_VAR 0 7
105077: ARRAY
105078: PPUSH
105079: CALL 47521 0 1
// end ; if f_attack_depot then
105083: LD_VAR 0 25
105087: IFFALSE 105199
// begin k := 6 ;
105089: LD_ADDR_VAR 0 9
105093: PUSH
105094: LD_INT 6
105096: ST_TO_ADDR
// if tmp < k then
105097: LD_VAR 0 14
105101: PUSH
105102: LD_VAR 0 9
105106: LESS
105107: IFFALSE 105119
// k := tmp ;
105109: LD_ADDR_VAR 0 9
105113: PUSH
105114: LD_VAR 0 14
105118: ST_TO_ADDR
// for j = 1 to k do
105119: LD_ADDR_VAR 0 8
105123: PUSH
105124: DOUBLE
105125: LD_INT 1
105127: DEC
105128: ST_TO_ADDR
105129: LD_VAR 0 9
105133: PUSH
105134: FOR_TO
105135: IFFALSE 105197
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105137: LD_VAR 0 8
105141: PPUSH
105142: CALL_OW 266
105146: PUSH
105147: LD_INT 0
105149: PUSH
105150: LD_INT 1
105152: PUSH
105153: EMPTY
105154: LIST
105155: LIST
105156: IN
105157: IFFALSE 105195
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105159: LD_VAR 0 4
105163: PUSH
105164: LD_VAR 0 7
105168: ARRAY
105169: PPUSH
105170: LD_VAR 0 14
105174: PUSH
105175: LD_VAR 0 8
105179: ARRAY
105180: PPUSH
105181: CALL_OW 115
// attacking := true ;
105185: LD_ADDR_VAR 0 29
105189: PUSH
105190: LD_INT 1
105192: ST_TO_ADDR
// break ;
105193: GO 105197
// end ;
105195: GO 105134
105197: POP
105198: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105199: LD_VAR 0 4
105203: PUSH
105204: LD_VAR 0 7
105208: ARRAY
105209: PPUSH
105210: CALL_OW 302
105214: PUSH
105215: LD_VAR 0 29
105219: NOT
105220: AND
105221: IFFALSE 105543
// begin if GetTag ( group [ i ] ) = 71 then
105223: LD_VAR 0 4
105227: PUSH
105228: LD_VAR 0 7
105232: ARRAY
105233: PPUSH
105234: CALL_OW 110
105238: PUSH
105239: LD_INT 71
105241: EQUAL
105242: IFFALSE 105283
// begin if HasTask ( group [ i ] ) then
105244: LD_VAR 0 4
105248: PUSH
105249: LD_VAR 0 7
105253: ARRAY
105254: PPUSH
105255: CALL_OW 314
105259: IFFALSE 105265
// continue else
105261: GO 101422
105263: GO 105283
// SetTag ( group [ i ] , 0 ) ;
105265: LD_VAR 0 4
105269: PUSH
105270: LD_VAR 0 7
105274: ARRAY
105275: PPUSH
105276: LD_INT 0
105278: PPUSH
105279: CALL_OW 109
// end ; k := 8 ;
105283: LD_ADDR_VAR 0 9
105287: PUSH
105288: LD_INT 8
105290: ST_TO_ADDR
// x := 0 ;
105291: LD_ADDR_VAR 0 10
105295: PUSH
105296: LD_INT 0
105298: ST_TO_ADDR
// if tmp < k then
105299: LD_VAR 0 14
105303: PUSH
105304: LD_VAR 0 9
105308: LESS
105309: IFFALSE 105321
// k := tmp ;
105311: LD_ADDR_VAR 0 9
105315: PUSH
105316: LD_VAR 0 14
105320: ST_TO_ADDR
// for j = 1 to k do
105321: LD_ADDR_VAR 0 8
105325: PUSH
105326: DOUBLE
105327: LD_INT 1
105329: DEC
105330: ST_TO_ADDR
105331: LD_VAR 0 9
105335: PUSH
105336: FOR_TO
105337: IFFALSE 105435
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105339: LD_VAR 0 14
105343: PUSH
105344: LD_VAR 0 8
105348: ARRAY
105349: PPUSH
105350: CALL_OW 247
105354: PUSH
105355: LD_INT 1
105357: EQUAL
105358: PUSH
105359: LD_VAR 0 14
105363: PUSH
105364: LD_VAR 0 8
105368: ARRAY
105369: PPUSH
105370: CALL_OW 256
105374: PUSH
105375: LD_INT 250
105377: LESS
105378: PUSH
105379: LD_VAR 0 20
105383: AND
105384: PUSH
105385: LD_VAR 0 20
105389: NOT
105390: PUSH
105391: LD_VAR 0 14
105395: PUSH
105396: LD_VAR 0 8
105400: ARRAY
105401: PPUSH
105402: CALL_OW 256
105406: PUSH
105407: LD_INT 250
105409: GREATEREQUAL
105410: AND
105411: OR
105412: AND
105413: IFFALSE 105433
// begin x := tmp [ j ] ;
105415: LD_ADDR_VAR 0 10
105419: PUSH
105420: LD_VAR 0 14
105424: PUSH
105425: LD_VAR 0 8
105429: ARRAY
105430: ST_TO_ADDR
// break ;
105431: GO 105435
// end ;
105433: GO 105336
105435: POP
105436: POP
// if x then
105437: LD_VAR 0 10
105441: IFFALSE 105465
// ComAttackUnit ( group [ i ] , x ) else
105443: LD_VAR 0 4
105447: PUSH
105448: LD_VAR 0 7
105452: ARRAY
105453: PPUSH
105454: LD_VAR 0 10
105458: PPUSH
105459: CALL_OW 115
105463: GO 105489
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105465: LD_VAR 0 4
105469: PUSH
105470: LD_VAR 0 7
105474: ARRAY
105475: PPUSH
105476: LD_VAR 0 14
105480: PUSH
105481: LD_INT 1
105483: ARRAY
105484: PPUSH
105485: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105489: LD_VAR 0 4
105493: PUSH
105494: LD_VAR 0 7
105498: ARRAY
105499: PPUSH
105500: CALL_OW 314
105504: NOT
105505: IFFALSE 105543
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105507: LD_VAR 0 4
105511: PUSH
105512: LD_VAR 0 7
105516: ARRAY
105517: PPUSH
105518: LD_VAR 0 14
105522: PPUSH
105523: LD_VAR 0 4
105527: PUSH
105528: LD_VAR 0 7
105532: ARRAY
105533: PPUSH
105534: CALL_OW 74
105538: PPUSH
105539: CALL_OW 115
// end ; end ; end ;
105543: GO 101422
105545: POP
105546: POP
// wait ( 0 0$2 ) ;
105547: LD_INT 70
105549: PPUSH
105550: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105554: LD_VAR 0 4
105558: NOT
105559: PUSH
105560: LD_VAR 0 4
105564: PUSH
105565: EMPTY
105566: EQUAL
105567: OR
105568: PUSH
105569: LD_INT 81
105571: PUSH
105572: LD_VAR 0 35
105576: PUSH
105577: EMPTY
105578: LIST
105579: LIST
105580: PPUSH
105581: CALL_OW 69
105585: NOT
105586: OR
105587: IFFALSE 101407
// end ;
105589: LD_VAR 0 2
105593: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
105594: LD_INT 0
105596: PPUSH
105597: PPUSH
105598: PPUSH
105599: PPUSH
105600: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
105601: LD_VAR 0 1
105605: NOT
105606: PUSH
105607: LD_EXP 59
105611: PUSH
105612: LD_VAR 0 1
105616: ARRAY
105617: NOT
105618: OR
105619: PUSH
105620: LD_VAR 0 2
105624: NOT
105625: OR
105626: PUSH
105627: LD_VAR 0 3
105631: NOT
105632: OR
105633: IFFALSE 105637
// exit ;
105635: GO 106150
// side := mc_sides [ base ] ;
105637: LD_ADDR_VAR 0 6
105641: PUSH
105642: LD_EXP 85
105646: PUSH
105647: LD_VAR 0 1
105651: ARRAY
105652: ST_TO_ADDR
// if not side then
105653: LD_VAR 0 6
105657: NOT
105658: IFFALSE 105662
// exit ;
105660: GO 106150
// for i in solds do
105662: LD_ADDR_VAR 0 7
105666: PUSH
105667: LD_VAR 0 2
105671: PUSH
105672: FOR_IN
105673: IFFALSE 105734
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
105675: LD_VAR 0 7
105679: PPUSH
105680: CALL_OW 310
105684: PPUSH
105685: CALL_OW 266
105689: PUSH
105690: LD_INT 32
105692: PUSH
105693: LD_INT 31
105695: PUSH
105696: EMPTY
105697: LIST
105698: LIST
105699: IN
105700: IFFALSE 105720
// solds := solds diff i else
105702: LD_ADDR_VAR 0 2
105706: PUSH
105707: LD_VAR 0 2
105711: PUSH
105712: LD_VAR 0 7
105716: DIFF
105717: ST_TO_ADDR
105718: GO 105732
// SetTag ( i , 18 ) ;
105720: LD_VAR 0 7
105724: PPUSH
105725: LD_INT 18
105727: PPUSH
105728: CALL_OW 109
105732: GO 105672
105734: POP
105735: POP
// if not solds then
105736: LD_VAR 0 2
105740: NOT
105741: IFFALSE 105745
// exit ;
105743: GO 106150
// repeat wait ( 0 0$2 ) ;
105745: LD_INT 70
105747: PPUSH
105748: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
105752: LD_ADDR_VAR 0 5
105756: PUSH
105757: LD_VAR 0 6
105761: PPUSH
105762: LD_VAR 0 3
105766: PPUSH
105767: CALL 16491 0 2
105771: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105772: LD_EXP 59
105776: PUSH
105777: LD_VAR 0 1
105781: ARRAY
105782: NOT
105783: PUSH
105784: LD_EXP 59
105788: PUSH
105789: LD_VAR 0 1
105793: ARRAY
105794: PUSH
105795: EMPTY
105796: EQUAL
105797: OR
105798: IFFALSE 105835
// begin for i in solds do
105800: LD_ADDR_VAR 0 7
105804: PUSH
105805: LD_VAR 0 2
105809: PUSH
105810: FOR_IN
105811: IFFALSE 105824
// ComStop ( i ) ;
105813: LD_VAR 0 7
105817: PPUSH
105818: CALL_OW 141
105822: GO 105810
105824: POP
105825: POP
// solds := [ ] ;
105826: LD_ADDR_VAR 0 2
105830: PUSH
105831: EMPTY
105832: ST_TO_ADDR
// exit ;
105833: GO 106150
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
105835: LD_VAR 0 5
105839: NOT
105840: PUSH
105841: LD_VAR 0 5
105845: PUSH
105846: LD_INT 3
105848: GREATER
105849: OR
105850: PUSH
105851: LD_EXP 81
105855: PUSH
105856: LD_VAR 0 1
105860: ARRAY
105861: OR
105862: IFFALSE 105903
// begin for i in solds do
105864: LD_ADDR_VAR 0 7
105868: PUSH
105869: LD_VAR 0 2
105873: PUSH
105874: FOR_IN
105875: IFFALSE 105899
// if HasTask ( i ) then
105877: LD_VAR 0 7
105881: PPUSH
105882: CALL_OW 314
105886: IFFALSE 105897
// ComStop ( i ) ;
105888: LD_VAR 0 7
105892: PPUSH
105893: CALL_OW 141
105897: GO 105874
105899: POP
105900: POP
// break ;
105901: GO 106138
// end ; for i in solds do
105903: LD_ADDR_VAR 0 7
105907: PUSH
105908: LD_VAR 0 2
105912: PUSH
105913: FOR_IN
105914: IFFALSE 106130
// begin if IsInUnit ( i ) then
105916: LD_VAR 0 7
105920: PPUSH
105921: CALL_OW 310
105925: IFFALSE 105936
// ComExitBuilding ( i ) ;
105927: LD_VAR 0 7
105931: PPUSH
105932: CALL_OW 122
// if GetLives ( i ) > 333 then
105936: LD_VAR 0 7
105940: PPUSH
105941: CALL_OW 256
105945: PUSH
105946: LD_INT 333
105948: GREATER
105949: IFFALSE 105977
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105951: LD_VAR 0 7
105955: PPUSH
105956: LD_VAR 0 5
105960: PPUSH
105961: LD_VAR 0 7
105965: PPUSH
105966: CALL_OW 74
105970: PPUSH
105971: CALL_OW 115
105975: GO 106128
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
105977: LD_ADDR_VAR 0 8
105981: PUSH
105982: LD_EXP 59
105986: PUSH
105987: LD_VAR 0 1
105991: ARRAY
105992: PPUSH
105993: LD_INT 2
105995: PUSH
105996: LD_INT 30
105998: PUSH
105999: LD_INT 0
106001: PUSH
106002: EMPTY
106003: LIST
106004: LIST
106005: PUSH
106006: LD_INT 30
106008: PUSH
106009: LD_INT 1
106011: PUSH
106012: EMPTY
106013: LIST
106014: LIST
106015: PUSH
106016: LD_INT 30
106018: PUSH
106019: LD_INT 6
106021: PUSH
106022: EMPTY
106023: LIST
106024: LIST
106025: PUSH
106026: EMPTY
106027: LIST
106028: LIST
106029: LIST
106030: LIST
106031: PPUSH
106032: CALL_OW 72
106036: PPUSH
106037: LD_VAR 0 7
106041: PPUSH
106042: CALL_OW 74
106046: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
106047: LD_VAR 0 7
106051: PPUSH
106052: LD_VAR 0 8
106056: PPUSH
106057: CALL_OW 250
106061: PPUSH
106062: LD_INT 3
106064: PPUSH
106065: LD_INT 5
106067: PPUSH
106068: CALL_OW 272
106072: PPUSH
106073: LD_VAR 0 8
106077: PPUSH
106078: CALL_OW 251
106082: PPUSH
106083: LD_INT 3
106085: PPUSH
106086: LD_INT 5
106088: PPUSH
106089: CALL_OW 273
106093: PPUSH
106094: CALL_OW 111
// SetTag ( i , 0 ) ;
106098: LD_VAR 0 7
106102: PPUSH
106103: LD_INT 0
106105: PPUSH
106106: CALL_OW 109
// solds := solds diff i ;
106110: LD_ADDR_VAR 0 2
106114: PUSH
106115: LD_VAR 0 2
106119: PUSH
106120: LD_VAR 0 7
106124: DIFF
106125: ST_TO_ADDR
// continue ;
106126: GO 105913
// end ; end ;
106128: GO 105913
106130: POP
106131: POP
// until solds ;
106132: LD_VAR 0 2
106136: IFFALSE 105745
// MC_Reset ( base , 18 ) ;
106138: LD_VAR 0 1
106142: PPUSH
106143: LD_INT 18
106145: PPUSH
106146: CALL 57368 0 2
// end ;
106150: LD_VAR 0 4
106154: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
106155: LD_INT 0
106157: PPUSH
106158: PPUSH
106159: PPUSH
106160: PPUSH
106161: PPUSH
106162: PPUSH
106163: PPUSH
106164: PPUSH
106165: PPUSH
106166: PPUSH
106167: PPUSH
106168: PPUSH
106169: PPUSH
106170: PPUSH
106171: PPUSH
106172: PPUSH
106173: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
106174: LD_ADDR_VAR 0 13
106178: PUSH
106179: LD_EXP 59
106183: PUSH
106184: LD_VAR 0 1
106188: ARRAY
106189: PPUSH
106190: LD_INT 25
106192: PUSH
106193: LD_INT 3
106195: PUSH
106196: EMPTY
106197: LIST
106198: LIST
106199: PPUSH
106200: CALL_OW 72
106204: ST_TO_ADDR
// if mc_remote_driver [ base ] then
106205: LD_EXP 99
106209: PUSH
106210: LD_VAR 0 1
106214: ARRAY
106215: IFFALSE 106239
// mechs := mechs diff mc_remote_driver [ base ] ;
106217: LD_ADDR_VAR 0 13
106221: PUSH
106222: LD_VAR 0 13
106226: PUSH
106227: LD_EXP 99
106231: PUSH
106232: LD_VAR 0 1
106236: ARRAY
106237: DIFF
106238: ST_TO_ADDR
// for i in mechs do
106239: LD_ADDR_VAR 0 5
106243: PUSH
106244: LD_VAR 0 13
106248: PUSH
106249: FOR_IN
106250: IFFALSE 106285
// if GetTag ( i ) > 0 then
106252: LD_VAR 0 5
106256: PPUSH
106257: CALL_OW 110
106261: PUSH
106262: LD_INT 0
106264: GREATER
106265: IFFALSE 106283
// mechs := mechs diff i ;
106267: LD_ADDR_VAR 0 13
106271: PUSH
106272: LD_VAR 0 13
106276: PUSH
106277: LD_VAR 0 5
106281: DIFF
106282: ST_TO_ADDR
106283: GO 106249
106285: POP
106286: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106287: LD_ADDR_VAR 0 9
106291: PUSH
106292: LD_EXP 59
106296: PUSH
106297: LD_VAR 0 1
106301: ARRAY
106302: PPUSH
106303: LD_INT 2
106305: PUSH
106306: LD_INT 25
106308: PUSH
106309: LD_INT 1
106311: PUSH
106312: EMPTY
106313: LIST
106314: LIST
106315: PUSH
106316: LD_INT 25
106318: PUSH
106319: LD_INT 5
106321: PUSH
106322: EMPTY
106323: LIST
106324: LIST
106325: PUSH
106326: LD_INT 25
106328: PUSH
106329: LD_INT 8
106331: PUSH
106332: EMPTY
106333: LIST
106334: LIST
106335: PUSH
106336: LD_INT 25
106338: PUSH
106339: LD_INT 9
106341: PUSH
106342: EMPTY
106343: LIST
106344: LIST
106345: PUSH
106346: EMPTY
106347: LIST
106348: LIST
106349: LIST
106350: LIST
106351: LIST
106352: PPUSH
106353: CALL_OW 72
106357: ST_TO_ADDR
// if not defenders and not solds then
106358: LD_VAR 0 2
106362: NOT
106363: PUSH
106364: LD_VAR 0 9
106368: NOT
106369: AND
106370: IFFALSE 106374
// exit ;
106372: GO 108064
// depot_under_attack := false ;
106374: LD_ADDR_VAR 0 17
106378: PUSH
106379: LD_INT 0
106381: ST_TO_ADDR
// sold_defenders := [ ] ;
106382: LD_ADDR_VAR 0 18
106386: PUSH
106387: EMPTY
106388: ST_TO_ADDR
// if mechs then
106389: LD_VAR 0 13
106393: IFFALSE 106546
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
106395: LD_ADDR_VAR 0 5
106399: PUSH
106400: LD_VAR 0 2
106404: PPUSH
106405: LD_INT 21
106407: PUSH
106408: LD_INT 2
106410: PUSH
106411: EMPTY
106412: LIST
106413: LIST
106414: PPUSH
106415: CALL_OW 72
106419: PUSH
106420: FOR_IN
106421: IFFALSE 106544
// begin if GetTag ( i ) <> 20 then
106423: LD_VAR 0 5
106427: PPUSH
106428: CALL_OW 110
106432: PUSH
106433: LD_INT 20
106435: NONEQUAL
106436: IFFALSE 106450
// SetTag ( i , 20 ) ;
106438: LD_VAR 0 5
106442: PPUSH
106443: LD_INT 20
106445: PPUSH
106446: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
106450: LD_VAR 0 5
106454: PPUSH
106455: CALL_OW 263
106459: PUSH
106460: LD_INT 1
106462: EQUAL
106463: PUSH
106464: LD_VAR 0 5
106468: PPUSH
106469: CALL_OW 311
106473: NOT
106474: AND
106475: IFFALSE 106542
// begin un := mechs [ 1 ] ;
106477: LD_ADDR_VAR 0 11
106481: PUSH
106482: LD_VAR 0 13
106486: PUSH
106487: LD_INT 1
106489: ARRAY
106490: ST_TO_ADDR
// ComExit ( un ) ;
106491: LD_VAR 0 11
106495: PPUSH
106496: CALL 51866 0 1
// AddComEnterUnit ( un , i ) ;
106500: LD_VAR 0 11
106504: PPUSH
106505: LD_VAR 0 5
106509: PPUSH
106510: CALL_OW 180
// SetTag ( un , 19 ) ;
106514: LD_VAR 0 11
106518: PPUSH
106519: LD_INT 19
106521: PPUSH
106522: CALL_OW 109
// mechs := mechs diff un ;
106526: LD_ADDR_VAR 0 13
106530: PUSH
106531: LD_VAR 0 13
106535: PUSH
106536: LD_VAR 0 11
106540: DIFF
106541: ST_TO_ADDR
// end ; end ;
106542: GO 106420
106544: POP
106545: POP
// if solds then
106546: LD_VAR 0 9
106550: IFFALSE 106609
// for i in solds do
106552: LD_ADDR_VAR 0 5
106556: PUSH
106557: LD_VAR 0 9
106561: PUSH
106562: FOR_IN
106563: IFFALSE 106607
// if not GetTag ( i ) then
106565: LD_VAR 0 5
106569: PPUSH
106570: CALL_OW 110
106574: NOT
106575: IFFALSE 106605
// begin defenders := defenders union i ;
106577: LD_ADDR_VAR 0 2
106581: PUSH
106582: LD_VAR 0 2
106586: PUSH
106587: LD_VAR 0 5
106591: UNION
106592: ST_TO_ADDR
// SetTag ( i , 18 ) ;
106593: LD_VAR 0 5
106597: PPUSH
106598: LD_INT 18
106600: PPUSH
106601: CALL_OW 109
// end ;
106605: GO 106562
106607: POP
106608: POP
// repeat wait ( 0 0$2 ) ;
106609: LD_INT 70
106611: PPUSH
106612: CALL_OW 67
// enemy := mc_scan [ base ] ;
106616: LD_ADDR_VAR 0 3
106620: PUSH
106621: LD_EXP 82
106625: PUSH
106626: LD_VAR 0 1
106630: ARRAY
106631: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106632: LD_EXP 59
106636: PUSH
106637: LD_VAR 0 1
106641: ARRAY
106642: NOT
106643: PUSH
106644: LD_EXP 59
106648: PUSH
106649: LD_VAR 0 1
106653: ARRAY
106654: PUSH
106655: EMPTY
106656: EQUAL
106657: OR
106658: IFFALSE 106695
// begin for i in defenders do
106660: LD_ADDR_VAR 0 5
106664: PUSH
106665: LD_VAR 0 2
106669: PUSH
106670: FOR_IN
106671: IFFALSE 106684
// ComStop ( i ) ;
106673: LD_VAR 0 5
106677: PPUSH
106678: CALL_OW 141
106682: GO 106670
106684: POP
106685: POP
// defenders := [ ] ;
106686: LD_ADDR_VAR 0 2
106690: PUSH
106691: EMPTY
106692: ST_TO_ADDR
// exit ;
106693: GO 108064
// end ; for i in defenders do
106695: LD_ADDR_VAR 0 5
106699: PUSH
106700: LD_VAR 0 2
106704: PUSH
106705: FOR_IN
106706: IFFALSE 107524
// begin e := NearestUnitToUnit ( enemy , i ) ;
106708: LD_ADDR_VAR 0 14
106712: PUSH
106713: LD_VAR 0 3
106717: PPUSH
106718: LD_VAR 0 5
106722: PPUSH
106723: CALL_OW 74
106727: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106728: LD_ADDR_VAR 0 8
106732: PUSH
106733: LD_EXP 59
106737: PUSH
106738: LD_VAR 0 1
106742: ARRAY
106743: PPUSH
106744: LD_INT 2
106746: PUSH
106747: LD_INT 30
106749: PUSH
106750: LD_INT 0
106752: PUSH
106753: EMPTY
106754: LIST
106755: LIST
106756: PUSH
106757: LD_INT 30
106759: PUSH
106760: LD_INT 1
106762: PUSH
106763: EMPTY
106764: LIST
106765: LIST
106766: PUSH
106767: EMPTY
106768: LIST
106769: LIST
106770: LIST
106771: PPUSH
106772: CALL_OW 72
106776: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
106777: LD_ADDR_VAR 0 17
106781: PUSH
106782: LD_VAR 0 8
106786: NOT
106787: PUSH
106788: LD_VAR 0 8
106792: PPUSH
106793: LD_INT 3
106795: PUSH
106796: LD_INT 24
106798: PUSH
106799: LD_INT 600
106801: PUSH
106802: EMPTY
106803: LIST
106804: LIST
106805: PUSH
106806: EMPTY
106807: LIST
106808: LIST
106809: PPUSH
106810: CALL_OW 72
106814: OR
106815: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
106816: LD_VAR 0 5
106820: PPUSH
106821: CALL_OW 247
106825: PUSH
106826: LD_INT 2
106828: DOUBLE
106829: EQUAL
106830: IFTRUE 106834
106832: GO 107230
106834: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
106835: LD_VAR 0 5
106839: PPUSH
106840: CALL_OW 256
106844: PUSH
106845: LD_INT 1000
106847: EQUAL
106848: PUSH
106849: LD_VAR 0 5
106853: PPUSH
106854: LD_VAR 0 14
106858: PPUSH
106859: CALL_OW 296
106863: PUSH
106864: LD_INT 40
106866: LESS
106867: PUSH
106868: LD_VAR 0 14
106872: PPUSH
106873: LD_EXP 84
106877: PUSH
106878: LD_VAR 0 1
106882: ARRAY
106883: PPUSH
106884: CALL_OW 308
106888: OR
106889: AND
106890: IFFALSE 107012
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
106892: LD_VAR 0 5
106896: PPUSH
106897: CALL_OW 262
106901: PUSH
106902: LD_INT 1
106904: EQUAL
106905: PUSH
106906: LD_VAR 0 5
106910: PPUSH
106911: CALL_OW 261
106915: PUSH
106916: LD_INT 30
106918: LESS
106919: AND
106920: PUSH
106921: LD_VAR 0 8
106925: AND
106926: IFFALSE 106996
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
106928: LD_VAR 0 5
106932: PPUSH
106933: LD_VAR 0 8
106937: PPUSH
106938: LD_VAR 0 5
106942: PPUSH
106943: CALL_OW 74
106947: PPUSH
106948: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
106952: LD_VAR 0 5
106956: PPUSH
106957: LD_VAR 0 8
106961: PPUSH
106962: LD_VAR 0 5
106966: PPUSH
106967: CALL_OW 74
106971: PPUSH
106972: CALL_OW 296
106976: PUSH
106977: LD_INT 6
106979: LESS
106980: IFFALSE 106994
// SetFuel ( i , 100 ) ;
106982: LD_VAR 0 5
106986: PPUSH
106987: LD_INT 100
106989: PPUSH
106990: CALL_OW 240
// end else
106994: GO 107010
// ComAttackUnit ( i , e ) ;
106996: LD_VAR 0 5
107000: PPUSH
107001: LD_VAR 0 14
107005: PPUSH
107006: CALL_OW 115
// end else
107010: GO 107113
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
107012: LD_VAR 0 14
107016: PPUSH
107017: LD_EXP 84
107021: PUSH
107022: LD_VAR 0 1
107026: ARRAY
107027: PPUSH
107028: CALL_OW 308
107032: NOT
107033: PUSH
107034: LD_VAR 0 5
107038: PPUSH
107039: LD_VAR 0 14
107043: PPUSH
107044: CALL_OW 296
107048: PUSH
107049: LD_INT 40
107051: GREATEREQUAL
107052: AND
107053: PUSH
107054: LD_VAR 0 5
107058: PPUSH
107059: CALL_OW 256
107063: PUSH
107064: LD_INT 650
107066: LESSEQUAL
107067: OR
107068: PUSH
107069: LD_VAR 0 5
107073: PPUSH
107074: LD_EXP 83
107078: PUSH
107079: LD_VAR 0 1
107083: ARRAY
107084: PPUSH
107085: CALL_OW 308
107089: NOT
107090: AND
107091: IFFALSE 107113
// ComMoveToArea ( i , mc_parking [ base ] ) ;
107093: LD_VAR 0 5
107097: PPUSH
107098: LD_EXP 83
107102: PUSH
107103: LD_VAR 0 1
107107: ARRAY
107108: PPUSH
107109: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
107113: LD_VAR 0 5
107117: PPUSH
107118: CALL_OW 256
107122: PUSH
107123: LD_INT 1000
107125: LESS
107126: PUSH
107127: LD_VAR 0 5
107131: PPUSH
107132: CALL_OW 263
107136: PUSH
107137: LD_INT 1
107139: EQUAL
107140: AND
107141: PUSH
107142: LD_VAR 0 5
107146: PPUSH
107147: CALL_OW 311
107151: AND
107152: PUSH
107153: LD_VAR 0 5
107157: PPUSH
107158: LD_EXP 83
107162: PUSH
107163: LD_VAR 0 1
107167: ARRAY
107168: PPUSH
107169: CALL_OW 308
107173: AND
107174: IFFALSE 107228
// begin mech := IsDrivenBy ( i ) ;
107176: LD_ADDR_VAR 0 10
107180: PUSH
107181: LD_VAR 0 5
107185: PPUSH
107186: CALL_OW 311
107190: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
107191: LD_VAR 0 10
107195: PPUSH
107196: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
107200: LD_VAR 0 10
107204: PPUSH
107205: LD_VAR 0 5
107209: PPUSH
107210: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
107214: LD_VAR 0 10
107218: PPUSH
107219: LD_VAR 0 5
107223: PPUSH
107224: CALL_OW 180
// end ; end ; unit_human :
107228: GO 107495
107230: LD_INT 1
107232: DOUBLE
107233: EQUAL
107234: IFTRUE 107238
107236: GO 107494
107238: POP
// begin b := IsInUnit ( i ) ;
107239: LD_ADDR_VAR 0 19
107243: PUSH
107244: LD_VAR 0 5
107248: PPUSH
107249: CALL_OW 310
107253: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
107254: LD_ADDR_VAR 0 20
107258: PUSH
107259: LD_VAR 0 19
107263: NOT
107264: PUSH
107265: LD_VAR 0 19
107269: PPUSH
107270: CALL_OW 266
107274: PUSH
107275: LD_INT 32
107277: PUSH
107278: LD_INT 31
107280: PUSH
107281: EMPTY
107282: LIST
107283: LIST
107284: IN
107285: OR
107286: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
107287: LD_VAR 0 17
107291: PUSH
107292: LD_VAR 0 2
107296: PPUSH
107297: LD_INT 21
107299: PUSH
107300: LD_INT 2
107302: PUSH
107303: EMPTY
107304: LIST
107305: LIST
107306: PPUSH
107307: CALL_OW 72
107311: PUSH
107312: LD_INT 1
107314: LESSEQUAL
107315: OR
107316: PUSH
107317: LD_VAR 0 20
107321: AND
107322: PUSH
107323: LD_VAR 0 5
107327: PUSH
107328: LD_VAR 0 18
107332: IN
107333: NOT
107334: AND
107335: IFFALSE 107428
// begin if b then
107337: LD_VAR 0 19
107341: IFFALSE 107390
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
107343: LD_VAR 0 19
107347: PPUSH
107348: LD_VAR 0 3
107352: PPUSH
107353: LD_VAR 0 19
107357: PPUSH
107358: CALL_OW 74
107362: PPUSH
107363: CALL_OW 296
107367: PUSH
107368: LD_INT 10
107370: LESS
107371: PUSH
107372: LD_VAR 0 19
107376: PPUSH
107377: CALL_OW 461
107381: PUSH
107382: LD_INT 7
107384: NONEQUAL
107385: AND
107386: IFFALSE 107390
// continue ;
107388: GO 106705
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
107390: LD_ADDR_VAR 0 18
107394: PUSH
107395: LD_VAR 0 18
107399: PPUSH
107400: LD_VAR 0 18
107404: PUSH
107405: LD_INT 1
107407: PLUS
107408: PPUSH
107409: LD_VAR 0 5
107413: PPUSH
107414: CALL_OW 1
107418: ST_TO_ADDR
// ComExitBuilding ( i ) ;
107419: LD_VAR 0 5
107423: PPUSH
107424: CALL_OW 122
// end ; if sold_defenders then
107428: LD_VAR 0 18
107432: IFFALSE 107492
// if i in sold_defenders then
107434: LD_VAR 0 5
107438: PUSH
107439: LD_VAR 0 18
107443: IN
107444: IFFALSE 107492
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
107446: LD_VAR 0 5
107450: PPUSH
107451: CALL_OW 314
107455: NOT
107456: PUSH
107457: LD_VAR 0 5
107461: PPUSH
107462: LD_VAR 0 14
107466: PPUSH
107467: CALL_OW 296
107471: PUSH
107472: LD_INT 30
107474: LESS
107475: AND
107476: IFFALSE 107492
// ComAttackUnit ( i , e ) ;
107478: LD_VAR 0 5
107482: PPUSH
107483: LD_VAR 0 14
107487: PPUSH
107488: CALL_OW 115
// end ; end ; end ;
107492: GO 107495
107494: POP
// if IsDead ( i ) then
107495: LD_VAR 0 5
107499: PPUSH
107500: CALL_OW 301
107504: IFFALSE 107522
// defenders := defenders diff i ;
107506: LD_ADDR_VAR 0 2
107510: PUSH
107511: LD_VAR 0 2
107515: PUSH
107516: LD_VAR 0 5
107520: DIFF
107521: ST_TO_ADDR
// end ;
107522: GO 106705
107524: POP
107525: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
107526: LD_VAR 0 3
107530: NOT
107531: PUSH
107532: LD_VAR 0 2
107536: NOT
107537: OR
107538: PUSH
107539: LD_EXP 59
107543: PUSH
107544: LD_VAR 0 1
107548: ARRAY
107549: NOT
107550: OR
107551: IFFALSE 106609
// MC_Reset ( base , 18 ) ;
107553: LD_VAR 0 1
107557: PPUSH
107558: LD_INT 18
107560: PPUSH
107561: CALL 57368 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107565: LD_ADDR_VAR 0 2
107569: PUSH
107570: LD_VAR 0 2
107574: PUSH
107575: LD_VAR 0 2
107579: PPUSH
107580: LD_INT 2
107582: PUSH
107583: LD_INT 25
107585: PUSH
107586: LD_INT 1
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PUSH
107593: LD_INT 25
107595: PUSH
107596: LD_INT 5
107598: PUSH
107599: EMPTY
107600: LIST
107601: LIST
107602: PUSH
107603: LD_INT 25
107605: PUSH
107606: LD_INT 8
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: PUSH
107613: LD_INT 25
107615: PUSH
107616: LD_INT 9
107618: PUSH
107619: EMPTY
107620: LIST
107621: LIST
107622: PUSH
107623: EMPTY
107624: LIST
107625: LIST
107626: LIST
107627: LIST
107628: LIST
107629: PPUSH
107630: CALL_OW 72
107634: DIFF
107635: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
107636: LD_VAR 0 3
107640: NOT
107641: PUSH
107642: LD_VAR 0 2
107646: PPUSH
107647: LD_INT 21
107649: PUSH
107650: LD_INT 2
107652: PUSH
107653: EMPTY
107654: LIST
107655: LIST
107656: PPUSH
107657: CALL_OW 72
107661: AND
107662: IFFALSE 108000
// begin tmp := FilterByTag ( defenders , 19 ) ;
107664: LD_ADDR_VAR 0 12
107668: PUSH
107669: LD_VAR 0 2
107673: PPUSH
107674: LD_INT 19
107676: PPUSH
107677: CALL 48996 0 2
107681: ST_TO_ADDR
// if tmp then
107682: LD_VAR 0 12
107686: IFFALSE 107756
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
107688: LD_ADDR_VAR 0 12
107692: PUSH
107693: LD_VAR 0 12
107697: PPUSH
107698: LD_INT 25
107700: PUSH
107701: LD_INT 3
107703: PUSH
107704: EMPTY
107705: LIST
107706: LIST
107707: PPUSH
107708: CALL_OW 72
107712: ST_TO_ADDR
// if tmp then
107713: LD_VAR 0 12
107717: IFFALSE 107756
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
107719: LD_ADDR_EXP 71
107723: PUSH
107724: LD_EXP 71
107728: PPUSH
107729: LD_VAR 0 1
107733: PPUSH
107734: LD_EXP 71
107738: PUSH
107739: LD_VAR 0 1
107743: ARRAY
107744: PUSH
107745: LD_VAR 0 12
107749: UNION
107750: PPUSH
107751: CALL_OW 1
107755: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
107756: LD_VAR 0 1
107760: PPUSH
107761: LD_INT 19
107763: PPUSH
107764: CALL 57368 0 2
// repeat wait ( 0 0$1 ) ;
107768: LD_INT 35
107770: PPUSH
107771: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107775: LD_EXP 59
107779: PUSH
107780: LD_VAR 0 1
107784: ARRAY
107785: NOT
107786: PUSH
107787: LD_EXP 59
107791: PUSH
107792: LD_VAR 0 1
107796: ARRAY
107797: PUSH
107798: EMPTY
107799: EQUAL
107800: OR
107801: IFFALSE 107838
// begin for i in defenders do
107803: LD_ADDR_VAR 0 5
107807: PUSH
107808: LD_VAR 0 2
107812: PUSH
107813: FOR_IN
107814: IFFALSE 107827
// ComStop ( i ) ;
107816: LD_VAR 0 5
107820: PPUSH
107821: CALL_OW 141
107825: GO 107813
107827: POP
107828: POP
// defenders := [ ] ;
107829: LD_ADDR_VAR 0 2
107833: PUSH
107834: EMPTY
107835: ST_TO_ADDR
// exit ;
107836: GO 108064
// end ; for i in defenders do
107838: LD_ADDR_VAR 0 5
107842: PUSH
107843: LD_VAR 0 2
107847: PUSH
107848: FOR_IN
107849: IFFALSE 107938
// begin if not IsInArea ( i , mc_parking [ base ] ) then
107851: LD_VAR 0 5
107855: PPUSH
107856: LD_EXP 83
107860: PUSH
107861: LD_VAR 0 1
107865: ARRAY
107866: PPUSH
107867: CALL_OW 308
107871: NOT
107872: IFFALSE 107896
// ComMoveToArea ( i , mc_parking [ base ] ) else
107874: LD_VAR 0 5
107878: PPUSH
107879: LD_EXP 83
107883: PUSH
107884: LD_VAR 0 1
107888: ARRAY
107889: PPUSH
107890: CALL_OW 113
107894: GO 107936
// if GetControl ( i ) = control_manual then
107896: LD_VAR 0 5
107900: PPUSH
107901: CALL_OW 263
107905: PUSH
107906: LD_INT 1
107908: EQUAL
107909: IFFALSE 107936
// if IsDrivenBy ( i ) then
107911: LD_VAR 0 5
107915: PPUSH
107916: CALL_OW 311
107920: IFFALSE 107936
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
107922: LD_VAR 0 5
107926: PPUSH
107927: CALL_OW 311
107931: PPUSH
107932: CALL_OW 121
// end ;
107936: GO 107848
107938: POP
107939: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
107940: LD_VAR 0 2
107944: PPUSH
107945: LD_INT 95
107947: PUSH
107948: LD_EXP 83
107952: PUSH
107953: LD_VAR 0 1
107957: ARRAY
107958: PUSH
107959: EMPTY
107960: LIST
107961: LIST
107962: PPUSH
107963: CALL_OW 72
107967: PUSH
107968: LD_VAR 0 2
107972: EQUAL
107973: PUSH
107974: LD_EXP 82
107978: PUSH
107979: LD_VAR 0 1
107983: ARRAY
107984: OR
107985: PUSH
107986: LD_EXP 59
107990: PUSH
107991: LD_VAR 0 1
107995: ARRAY
107996: NOT
107997: OR
107998: IFFALSE 107768
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
108000: LD_ADDR_EXP 81
108004: PUSH
108005: LD_EXP 81
108009: PPUSH
108010: LD_VAR 0 1
108014: PPUSH
108015: LD_VAR 0 2
108019: PPUSH
108020: LD_INT 21
108022: PUSH
108023: LD_INT 2
108025: PUSH
108026: EMPTY
108027: LIST
108028: LIST
108029: PPUSH
108030: CALL_OW 72
108034: PPUSH
108035: CALL_OW 1
108039: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
108040: LD_VAR 0 1
108044: PPUSH
108045: LD_INT 19
108047: PPUSH
108048: CALL 57368 0 2
// MC_Reset ( base , 20 ) ;
108052: LD_VAR 0 1
108056: PPUSH
108057: LD_INT 20
108059: PPUSH
108060: CALL 57368 0 2
// end ; end_of_file
108064: LD_VAR 0 4
108068: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
108069: LD_VAR 0 1
108073: PUSH
108074: LD_INT 200
108076: DOUBLE
108077: GREATEREQUAL
108078: IFFALSE 108086
108080: LD_INT 299
108082: DOUBLE
108083: LESSEQUAL
108084: IFTRUE 108088
108086: GO 108120
108088: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
108089: LD_VAR 0 1
108093: PPUSH
108094: LD_VAR 0 2
108098: PPUSH
108099: LD_VAR 0 3
108103: PPUSH
108104: LD_VAR 0 4
108108: PPUSH
108109: LD_VAR 0 5
108113: PPUSH
108114: CALL 97002 0 5
108118: GO 108197
108120: LD_INT 300
108122: DOUBLE
108123: GREATEREQUAL
108124: IFFALSE 108132
108126: LD_INT 399
108128: DOUBLE
108129: LESSEQUAL
108130: IFTRUE 108134
108132: GO 108196
108134: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
108135: LD_VAR 0 1
108139: PPUSH
108140: LD_VAR 0 2
108144: PPUSH
108145: LD_VAR 0 3
108149: PPUSH
108150: LD_VAR 0 4
108154: PPUSH
108155: LD_VAR 0 5
108159: PPUSH
108160: LD_VAR 0 6
108164: PPUSH
108165: LD_VAR 0 7
108169: PPUSH
108170: LD_VAR 0 8
108174: PPUSH
108175: LD_VAR 0 9
108179: PPUSH
108180: LD_VAR 0 10
108184: PPUSH
108185: LD_VAR 0 11
108189: PPUSH
108190: CALL 94890 0 11
108194: GO 108197
108196: POP
// end ;
108197: PPOPN 11
108199: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
108200: LD_VAR 0 1
108204: PPUSH
108205: LD_VAR 0 2
108209: PPUSH
108210: LD_VAR 0 3
108214: PPUSH
108215: LD_VAR 0 4
108219: PPUSH
108220: LD_VAR 0 5
108224: PPUSH
108225: CALL 96984 0 5
// end ; end_of_file
108229: PPOPN 5
108231: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
108232: LD_VAR 0 1
108236: PPUSH
108237: LD_VAR 0 2
108241: PPUSH
108242: LD_VAR 0 3
108246: PPUSH
108247: LD_VAR 0 4
108251: PPUSH
108252: LD_VAR 0 5
108256: PPUSH
108257: LD_VAR 0 6
108261: PPUSH
108262: CALL 83698 0 6
// end ;
108266: PPOPN 6
108268: END
