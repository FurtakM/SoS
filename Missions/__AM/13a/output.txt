// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 644 0 0
// InitGlobalVariables ;
  19: CALL 82104 0 0
// InitMacro ;
  23: CALL 51993 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 47285 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 47285 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 47285 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 5
 128: PPUSH
 129: LD_INT 0
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 12
 143: PPUSH
 144: LD_INT 0
 146: PPUSH
 147: CALL 47285 0 9
// PrepareArabian ;
 151: CALL 3715 0 0
// PrepareRussian ;
 155: CALL 2850 0 0
// PrepareAlliance ;
 159: CALL 846 0 0
// MC_Start ( ) ;
 163: CALL 54105 0 0
// if debug then
 167: LD_EXP 1
 171: IFFALSE 180
// FogOff ( 1 ) ;
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 344
// Action ;
 180: CALL 6898 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 83
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 84
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 75375 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 54
 256: PPUSH
 257: CALL 75801 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 76259 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 76528 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 1
 310: PUSH
 311: LD_INT 2
 313: PUSH
 314: LD_EXP 108
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: LIST
 323: LIST
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75741 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_INT 12
 338: PUSH
 339: LD_INT 14
 341: PUSH
 342: LD_INT 10
 344: PUSH
 345: LD_INT 11
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 76435 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_EXP 51
 365: PPUSH
 366: CALL 75801 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 370: LD_INT 2
 372: PPUSH
 373: LD_INT 8
 375: PPUSH
 376: CALL 76259 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 10
 385: PUSH
 386: EMPTY
 387: LIST
 388: PPUSH
 389: CALL 76528 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 393: LD_INT 2
 395: PPUSH
 396: LD_INT 6
 398: PUSH
 399: LD_INT 71
 401: PUSH
 402: LD_INT 116
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: LIST
 412: LIST
 413: PUSH
 414: LD_INT 4
 416: PUSH
 417: LD_INT 85
 419: PUSH
 420: LD_INT 116
 422: PUSH
 423: LD_INT 4
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: PUSH
 432: LD_INT 32
 434: PUSH
 435: LD_INT 83
 437: PUSH
 438: LD_INT 111
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 32
 452: PUSH
 453: LD_INT 87
 455: PUSH
 456: LD_INT 121
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 33
 470: PUSH
 471: LD_INT 88
 473: PUSH
 474: LD_INT 128
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 59
 491: PUSH
 492: LD_INT 89
 494: PUSH
 495: LD_INT 3
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 69
 509: PUSH
 510: LD_INT 98
 512: PUSH
 513: LD_INT 3
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 33
 524: PUSH
 525: LD_INT 77
 527: PUSH
 528: LD_INT 103
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 83
 545: PUSH
 546: LD_INT 105
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 71
 563: PUSH
 564: LD_INT 125
 566: PUSH
 567: LD_INT 5
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PPUSH
 588: CALL 75585 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 1
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: PPUSH
 635: CALL 75741 0 2
// end ;
 639: LD_VAR 0 1
 643: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 644: LD_INT 0
 646: PPUSH
// debug := false ;
 647: LD_ADDR_EXP 1
 651: PUSH
 652: LD_INT 0
 654: ST_TO_ADDR
// game := true ;
 655: LD_ADDR_EXP 2
 659: PUSH
 660: LD_INT 1
 662: ST_TO_ADDR
// gossudarov_arrive := false ;
 663: LD_ADDR_EXP 4
 667: PUSH
 668: LD_INT 0
 670: ST_TO_ADDR
// ru_lab_builded := false ;
 671: LD_ADDR_EXP 5
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// player_spotted := false ;
 679: LD_ADDR_EXP 6
 683: PUSH
 684: LD_INT 0
 686: ST_TO_ADDR
// first_attack := false ;
 687: LD_ADDR_EXP 7
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// ru_attackers := [ ] ;
 695: LD_ADDR_EXP 52
 699: PUSH
 700: EMPTY
 701: ST_TO_ADDR
// ar_base_spotted := false ;
 702: LD_ADDR_EXP 8
 706: PUSH
 707: LD_INT 0
 709: ST_TO_ADDR
// ar_active_attack := false ;
 710: LD_ADDR_EXP 9
 714: PUSH
 715: LD_INT 0
 717: ST_TO_ADDR
// ar_attackers := [ ] ;
 718: LD_ADDR_EXP 10
 722: PUSH
 723: EMPTY
 724: ST_TO_ADDR
// first_powell_attack := false ;
 725: LD_ADDR_EXP 11
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// abdul_escaped := true ;
 733: LD_ADDR_EXP 12
 737: PUSH
 738: LD_INT 1
 740: ST_TO_ADDR
// loss_counter := 0 ;
 741: LD_ADDR_EXP 13
 745: PUSH
 746: LD_INT 0
 748: ST_TO_ADDR
// hack_counter := 0 ;
 749: LD_ADDR_EXP 14
 753: PUSH
 754: LD_INT 0
 756: ST_TO_ADDR
// end ;
 757: LD_VAR 0 1
 761: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 762: LD_EXP 48
 766: PPUSH
 767: CALL_OW 255
 771: PUSH
 772: LD_INT 7
 774: EQUAL
 775: PUSH
 776: LD_EXP 47
 780: PPUSH
 781: CALL_OW 255
 785: PUSH
 786: LD_INT 7
 788: EQUAL
 789: AND
 790: PUSH
 791: LD_EXP 48
 795: PPUSH
 796: CALL_OW 302
 800: AND
 801: PUSH
 802: LD_EXP 47
 806: PPUSH
 807: CALL_OW 302
 811: AND
 812: IFFALSE 824
 814: GO 816
 816: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 817: LD_STRING ACH_COMRADE
 819: PPUSH
 820: CALL_OW 543
 824: END
// every 0 0$1 trigger hack_counter >= 10 do
 825: LD_EXP 14
 829: PUSH
 830: LD_INT 10
 832: GREATEREQUAL
 833: IFFALSE 845
 835: GO 837
 837: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 838: LD_STRING ACH_HACK
 840: PPUSH
 841: CALL_OW 543
 845: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 846: LD_INT 0
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
// uc_side := 7 ;
 852: LD_ADDR_OWVAR 20
 856: PUSH
 857: LD_INT 7
 859: ST_TO_ADDR
// uc_nation := 1 ;
 860: LD_ADDR_OWVAR 21
 864: PUSH
 865: LD_INT 1
 867: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 868: LD_ADDR_EXP 15
 872: PUSH
 873: LD_STRING JMM
 875: PPUSH
 876: LD_EXP 1
 880: NOT
 881: PPUSH
 882: LD_STRING 12a_
 884: PPUSH
 885: CALL 14337 0 3
 889: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 890: LD_EXP 15
 894: PPUSH
 895: LD_INT 71
 897: PPUSH
 898: LD_INT 23
 900: PPUSH
 901: LD_INT 0
 903: PPUSH
 904: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 908: LD_EXP 15
 912: PPUSH
 913: LD_INT 2
 915: PPUSH
 916: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 920: LD_ADDR_EXP 16
 924: PUSH
 925: LD_STRING Roth
 927: PPUSH
 928: LD_EXP 1
 932: NOT
 933: PPUSH
 934: LD_STRING 12a_
 936: PPUSH
 937: CALL 14337 0 3
 941: ST_TO_ADDR
// if Roth then
 942: LD_EXP 16
 946: IFFALSE 966
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 948: LD_EXP 16
 952: PPUSH
 953: LD_INT 71
 955: PPUSH
 956: LD_INT 21
 958: PPUSH
 959: LD_INT 0
 961: PPUSH
 962: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 966: LD_ADDR_EXP 17
 970: PUSH
 971: LD_STRING Lisa
 973: PPUSH
 974: LD_EXP 1
 978: NOT
 979: PPUSH
 980: LD_STRING 12a_
 982: PPUSH
 983: CALL 14337 0 3
 987: ST_TO_ADDR
// if Lisa then
 988: LD_EXP 17
 992: IFFALSE 1009
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 994: LD_EXP 17
 998: PPUSH
 999: LD_INT 13
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1009: LD_ADDR_EXP 18
1013: PUSH
1014: LD_STRING Donaldson
1016: PPUSH
1017: LD_EXP 1
1021: NOT
1022: PPUSH
1023: LD_STRING 12a_
1025: PPUSH
1026: CALL 14337 0 3
1030: ST_TO_ADDR
// if Donaldson then
1031: LD_EXP 18
1035: IFFALSE 1052
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1037: LD_EXP 18
1041: PPUSH
1042: LD_INT 13
1044: PPUSH
1045: LD_INT 0
1047: PPUSH
1048: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1052: LD_ADDR_EXP 19
1056: PUSH
1057: LD_STRING Bobby
1059: PPUSH
1060: LD_EXP 1
1064: NOT
1065: PPUSH
1066: LD_STRING 12a_
1068: PPUSH
1069: CALL 14337 0 3
1073: ST_TO_ADDR
// if Bobby then
1074: LD_EXP 19
1078: IFFALSE 1095
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1080: LD_EXP 19
1084: PPUSH
1085: LD_INT 13
1087: PPUSH
1088: LD_INT 0
1090: PPUSH
1091: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1095: LD_ADDR_EXP 20
1099: PUSH
1100: LD_STRING Cyrus
1102: PPUSH
1103: LD_EXP 1
1107: NOT
1108: PPUSH
1109: LD_STRING 12a_
1111: PPUSH
1112: CALL 14337 0 3
1116: ST_TO_ADDR
// if Cyrus then
1117: LD_EXP 20
1121: IFFALSE 1138
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1123: LD_EXP 20
1127: PPUSH
1128: LD_INT 13
1130: PPUSH
1131: LD_INT 0
1133: PPUSH
1134: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1138: LD_ADDR_EXP 21
1142: PUSH
1143: LD_STRING Denis
1145: PPUSH
1146: LD_EXP 1
1150: NOT
1151: PPUSH
1152: LD_STRING 12a_
1154: PPUSH
1155: CALL 14337 0 3
1159: ST_TO_ADDR
// if Denis then
1160: LD_EXP 21
1164: IFFALSE 1181
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1166: LD_EXP 21
1170: PPUSH
1171: LD_INT 13
1173: PPUSH
1174: LD_INT 0
1176: PPUSH
1177: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1181: LD_ADDR_EXP 22
1185: PUSH
1186: LD_STRING Brown
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: LD_STRING 12a_
1197: PPUSH
1198: CALL 14337 0 3
1202: ST_TO_ADDR
// if Brown then
1203: LD_EXP 22
1207: IFFALSE 1224
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1209: LD_EXP 22
1213: PPUSH
1214: LD_INT 13
1216: PPUSH
1217: LD_INT 0
1219: PPUSH
1220: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1224: LD_ADDR_EXP 23
1228: PUSH
1229: LD_STRING Gladstone
1231: PPUSH
1232: LD_EXP 1
1236: NOT
1237: PPUSH
1238: LD_STRING 12a_
1240: PPUSH
1241: CALL 14337 0 3
1245: ST_TO_ADDR
// if Gladstone then
1246: LD_EXP 23
1250: IFFALSE 1267
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1252: LD_EXP 23
1256: PPUSH
1257: LD_INT 13
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1267: LD_ADDR_EXP 24
1271: PUSH
1272: LD_STRING Houten
1274: PPUSH
1275: LD_EXP 1
1279: NOT
1280: PPUSH
1281: LD_STRING 12a_
1283: PPUSH
1284: CALL 14337 0 3
1288: ST_TO_ADDR
// if Houten then
1289: LD_EXP 24
1293: IFFALSE 1310
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1295: LD_EXP 24
1299: PPUSH
1300: LD_INT 13
1302: PPUSH
1303: LD_INT 0
1305: PPUSH
1306: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1310: LD_ADDR_EXP 25
1314: PUSH
1315: LD_STRING Cornell
1317: PPUSH
1318: LD_EXP 1
1322: NOT
1323: PPUSH
1324: LD_STRING 12a_
1326: PPUSH
1327: CALL 14337 0 3
1331: ST_TO_ADDR
// if Cornel then
1332: LD_EXP 25
1336: IFFALSE 1353
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1338: LD_EXP 25
1342: PPUSH
1343: LD_INT 13
1345: PPUSH
1346: LD_INT 0
1348: PPUSH
1349: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1353: LD_ADDR_EXP 26
1357: PUSH
1358: LD_STRING Gary
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: LD_STRING 12a_
1369: PPUSH
1370: CALL 14337 0 3
1374: ST_TO_ADDR
// if Gary then
1375: LD_EXP 26
1379: IFFALSE 1396
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1381: LD_EXP 26
1385: PPUSH
1386: LD_INT 13
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1396: LD_ADDR_EXP 27
1400: PUSH
1401: LD_STRING Frank
1403: PPUSH
1404: LD_EXP 1
1408: NOT
1409: PPUSH
1410: LD_STRING 12a_
1412: PPUSH
1413: CALL 14337 0 3
1417: ST_TO_ADDR
// if Frank then
1418: LD_EXP 27
1422: IFFALSE 1439
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1424: LD_EXP 27
1428: PPUSH
1429: LD_INT 13
1431: PPUSH
1432: LD_INT 0
1434: PPUSH
1435: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1439: LD_ADDR_EXP 28
1443: PUSH
1444: LD_STRING Kikuchi
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 12a_
1455: PPUSH
1456: CALL 14337 0 3
1460: ST_TO_ADDR
// if Kikuchi then
1461: LD_EXP 28
1465: IFFALSE 1482
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1467: LD_EXP 28
1471: PPUSH
1472: LD_INT 13
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1482: LD_ADDR_EXP 29
1486: PUSH
1487: LD_STRING Simms
1489: PPUSH
1490: LD_EXP 1
1494: NOT
1495: PPUSH
1496: LD_STRING 12a_
1498: PPUSH
1499: CALL 14337 0 3
1503: ST_TO_ADDR
// if Simms then
1504: LD_EXP 29
1508: IFFALSE 1525
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1510: LD_EXP 29
1514: PPUSH
1515: LD_INT 13
1517: PPUSH
1518: LD_INT 0
1520: PPUSH
1521: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1525: LD_ADDR_EXP 30
1529: PUSH
1530: LD_STRING Joan
1532: PPUSH
1533: LD_EXP 1
1537: NOT
1538: PPUSH
1539: LD_STRING 12a_
1541: PPUSH
1542: CALL 14337 0 3
1546: ST_TO_ADDR
// if Joan then
1547: LD_EXP 30
1551: IFFALSE 1568
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1553: LD_EXP 30
1557: PPUSH
1558: LD_INT 13
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1568: LD_ADDR_EXP 31
1572: PUSH
1573: LD_STRING DeltaDoctor
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 12a_
1584: PPUSH
1585: CALL 14337 0 3
1589: ST_TO_ADDR
// if DeltaDoctor then
1590: LD_EXP 31
1594: IFFALSE 1611
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1596: LD_EXP 31
1600: PPUSH
1601: LD_INT 13
1603: PPUSH
1604: LD_INT 0
1606: PPUSH
1607: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_STRING 12a_others
1618: PPUSH
1619: CALL_OW 31
1623: ST_TO_ADDR
// if tmp then
1624: LD_VAR 0 4
1628: IFFALSE 1662
// for i in tmp do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: LD_VAR 0 4
1639: PUSH
1640: FOR_IN
1641: IFFALSE 1660
// PlaceUnitArea ( i , alliance_start , false ) ;
1643: LD_VAR 0 3
1647: PPUSH
1648: LD_INT 13
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 49
1658: GO 1640
1660: POP
1661: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1662: LD_INT 3
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 12
1673: PPUSH
1674: LD_INT 100
1676: PPUSH
1677: CALL 19161 0 5
// veh := CreateVehicle ;
1681: LD_ADDR_VAR 0 2
1685: PUSH
1686: CALL_OW 45
1690: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1691: LD_VAR 0 2
1695: PPUSH
1696: LD_INT 2
1698: PPUSH
1699: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1703: LD_VAR 0 2
1707: PPUSH
1708: LD_INT 60
1710: PPUSH
1711: LD_INT 6
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1721: LD_VAR 0 2
1725: PPUSH
1726: LD_INT 4
1728: PPUSH
1729: LD_INT 30
1731: PPUSH
1732: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1736: LD_STRING 11_artifact_captured
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: CALL_OW 30
1746: IFFALSE 1822
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1748: LD_INT 3
1750: PPUSH
1751: LD_INT 3
1753: PPUSH
1754: LD_INT 3
1756: PPUSH
1757: LD_INT 12
1759: PPUSH
1760: LD_INT 100
1762: PPUSH
1763: CALL 19161 0 5
// veh := CreateVehicle ;
1767: LD_ADDR_VAR 0 2
1771: PUSH
1772: CALL_OW 45
1776: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1777: LD_VAR 0 2
1781: PPUSH
1782: LD_INT 3
1784: PPUSH
1785: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1789: LD_VAR 0 2
1793: PPUSH
1794: LD_INT 75
1796: PPUSH
1797: LD_INT 6
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 4
1814: PPUSH
1815: LD_INT 50
1817: PPUSH
1818: CALL_OW 290
// end ; end ;
1822: LD_VAR 0 1
1826: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1827: LD_INT 0
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// uc_side := 6 ;
1833: LD_ADDR_OWVAR 20
1837: PUSH
1838: LD_INT 6
1840: ST_TO_ADDR
// uc_nation := 3 ;
1841: LD_ADDR_OWVAR 21
1845: PUSH
1846: LD_INT 3
1848: ST_TO_ADDR
// InitHc ;
1849: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1853: LD_ADDR_EXP 32
1857: PUSH
1858: LD_STRING Gossudarov
1860: PPUSH
1861: CALL_OW 25
1865: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1866: LD_ADDR_EXP 33
1870: PUSH
1871: LD_STRING Kirilenkova
1873: PPUSH
1874: CALL_OW 25
1878: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1879: LD_ADDR_EXP 34
1883: PUSH
1884: LD_STRING Titov
1886: PPUSH
1887: CALL_OW 25
1891: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1892: LD_ADDR_EXP 39
1896: PUSH
1897: LD_STRING Oblukov
1899: PPUSH
1900: CALL_OW 25
1904: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1905: LD_ADDR_EXP 36
1909: PUSH
1910: LD_STRING Dolgov
1912: PPUSH
1913: CALL_OW 25
1917: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1918: LD_ADDR_EXP 37
1922: PUSH
1923: LD_STRING Petrosyan
1925: PPUSH
1926: CALL_OW 25
1930: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1931: LD_ADDR_EXP 38
1935: PUSH
1936: LD_STRING Scholtze
1938: PPUSH
1939: CALL_OW 25
1943: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1944: LD_ADDR_EXP 40
1948: PUSH
1949: LD_STRING Kapitsova
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1957: LD_ADDR_VAR 0 2
1961: PUSH
1962: LD_EXP 32
1966: PUSH
1967: LD_EXP 33
1971: PUSH
1972: LD_EXP 34
1976: PUSH
1977: LD_EXP 39
1981: PUSH
1982: LD_EXP 36
1986: PUSH
1987: LD_EXP 37
1991: PUSH
1992: LD_EXP 38
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 4
2017: PPUSH
2018: LD_INT 8
2020: PPUSH
2021: CALL_OW 380
// un := CreateHuman ;
2025: LD_ADDR_VAR 0 4
2029: PUSH
2030: CALL_OW 44
2034: ST_TO_ADDR
// tmp := tmp ^ un ;
2035: LD_ADDR_VAR 0 2
2039: PUSH
2040: LD_VAR 0 2
2044: PUSH
2045: LD_VAR 0 4
2049: ADD
2050: ST_TO_ADDR
// for i in tmp do
2051: LD_ADDR_VAR 0 3
2055: PUSH
2056: LD_VAR 0 2
2060: PUSH
2061: FOR_IN
2062: IFFALSE 2081
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2064: LD_VAR 0 3
2068: PPUSH
2069: LD_INT 14
2071: PPUSH
2072: LD_INT 0
2074: PPUSH
2075: CALL_OW 49
2079: GO 2061
2081: POP
2082: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2083: LD_VAR 0 2
2087: PPUSH
2088: LD_EXP 3
2092: PPUSH
2093: CALL_OW 250
2097: PPUSH
2098: LD_EXP 3
2102: PPUSH
2103: CALL_OW 251
2107: PPUSH
2108: CALL_OW 111
// end ;
2112: LD_VAR 0 1
2116: RET
// export function PrepareBelkov ; begin
2117: LD_INT 0
2119: PPUSH
// uc_side := 4 ;
2120: LD_ADDR_OWVAR 20
2124: PUSH
2125: LD_INT 4
2127: ST_TO_ADDR
// uc_nation := 3 ;
2128: LD_ADDR_OWVAR 21
2132: PUSH
2133: LD_INT 3
2135: ST_TO_ADDR
// InitHc ;
2136: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2140: LD_ADDR_EXP 47
2144: PUSH
2145: LD_STRING Belkov
2147: PPUSH
2148: CALL_OW 25
2152: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2153: LD_EXP 47
2157: PPUSH
2158: LD_INT 14
2160: PPUSH
2161: LD_INT 0
2163: PPUSH
2164: CALL_OW 49
// end ;
2168: LD_VAR 0 1
2172: RET
// export function PrepareGnyevko ; begin
2173: LD_INT 0
2175: PPUSH
// uc_side := 4 ;
2176: LD_ADDR_OWVAR 20
2180: PUSH
2181: LD_INT 4
2183: ST_TO_ADDR
// uc_nation := 3 ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_INT 3
2191: ST_TO_ADDR
// InitHc ;
2192: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2196: LD_ADDR_EXP 48
2200: PUSH
2201: LD_STRING Gnyevko
2203: PPUSH
2204: CALL_OW 25
2208: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2209: LD_EXP 48
2213: PPUSH
2214: LD_INT 14
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// end ;
2224: LD_VAR 0 1
2228: RET
// export function PrepareBurlak ; var i , tmp ; begin
2229: LD_INT 0
2231: PPUSH
2232: PPUSH
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2254: LD_ADDR_EXP 46
2258: PUSH
2259: LD_STRING Burlak
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2267: LD_INT 24
2269: PUSH
2270: LD_INT 23
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: PUSH
2281: LD_OWVAR 67
2285: ARRAY
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 1
2292: PPUSH
2293: LD_INT 45
2295: PUSH
2296: LD_INT 44
2298: PUSH
2299: LD_INT 43
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PUSH
2307: LD_OWVAR 67
2311: ARRAY
2312: PPUSH
2313: LD_INT 0
2315: PPUSH
2316: CALL 19161 0 5
// Masha := CreateVehicle ;
2320: LD_ADDR_EXP 49
2324: PUSH
2325: CALL_OW 45
2329: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2330: LD_EXP 49
2334: PUSH
2335: LD_EXP 46
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: LD_INT 499
2346: PPUSH
2347: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2351: LD_EXP 49
2355: PPUSH
2356: LD_INT 3
2358: PPUSH
2359: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2363: LD_EXP 49
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2375: LD_INT 1
2377: PPUSH
2378: LD_INT 18
2380: PPUSH
2381: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2392: LD_ADDR_VAR 0 3
2396: PUSH
2397: LD_INT 18
2399: PPUSH
2400: EMPTY
2401: PPUSH
2402: CALL_OW 70
2406: ST_TO_ADDR
// if tmp then
2407: LD_VAR 0 3
2411: IFFALSE 2445
// for i in tmp do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_VAR 0 3
2422: PUSH
2423: FOR_IN
2424: IFFALSE 2443
// ComMoveXY ( i , 114 , 9 ) ;
2426: LD_VAR 0 2
2430: PPUSH
2431: LD_INT 114
2433: PPUSH
2434: LD_INT 9
2436: PPUSH
2437: CALL_OW 111
2441: GO 2423
2443: POP
2444: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2445: LD_INT 18
2447: PPUSH
2448: EMPTY
2449: PPUSH
2450: CALL_OW 70
2454: NOT
2455: PUSH
2456: LD_INT 123
2458: PPUSH
2459: LD_INT 3
2461: PPUSH
2462: CALL_OW 428
2466: PUSH
2467: LD_INT 0
2469: EQUAL
2470: AND
2471: IFFALSE 2385
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2473: LD_EXP 49
2477: PPUSH
2478: LD_INT 123
2480: PPUSH
2481: LD_INT 3
2483: PPUSH
2484: LD_INT 0
2486: PPUSH
2487: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2491: LD_EXP 46
2495: PPUSH
2496: LD_INT 125
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2509: LD_EXP 46
2513: PPUSH
2514: LD_EXP 49
2518: PPUSH
2519: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2523: LD_INT 10
2525: PPUSH
2526: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2530: LD_EXP 49
2534: PPUSH
2535: LD_INT 110
2537: PPUSH
2538: LD_INT 10
2540: PPUSH
2541: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2545: LD_ADDR_EXP 42
2549: PUSH
2550: LD_STRING Petrovova
2552: PPUSH
2553: CALL_OW 25
2557: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2558: LD_ADDR_EXP 44
2562: PUSH
2563: LD_STRING Kuzmov
2565: PPUSH
2566: CALL_OW 25
2570: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2571: LD_ADDR_EXP 43
2575: PUSH
2576: LD_STRING Kovalyuk
2578: PPUSH
2579: CALL_OW 25
2583: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2584: LD_ADDR_EXP 41
2588: PUSH
2589: LD_STRING Lipshchin
2591: PPUSH
2592: CALL_OW 25
2596: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2597: LD_ADDR_EXP 45
2601: PUSH
2602: LD_STRING Karamazov
2604: PPUSH
2605: CALL_OW 25
2609: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2610: LD_ADDR_VAR 0 3
2614: PUSH
2615: LD_EXP 42
2619: PUSH
2620: LD_EXP 44
2624: PUSH
2625: LD_EXP 43
2629: PUSH
2630: LD_EXP 41
2634: PUSH
2635: LD_EXP 45
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: ST_TO_ADDR
// for i in tmp do
2647: LD_ADDR_VAR 0 2
2651: PUSH
2652: LD_VAR 0 3
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2697
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 399
2667: PPUSH
2668: LD_INT 799
2670: PPUSH
2671: CALL_OW 12
2675: PPUSH
2676: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2680: LD_VAR 0 2
2684: PPUSH
2685: LD_INT 19
2687: PPUSH
2688: LD_INT 0
2690: PPUSH
2691: CALL_OW 49
// end ;
2695: GO 2657
2697: POP
2698: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2699: LD_VAR 0 3
2703: PPUSH
2704: LD_INT 116
2706: PPUSH
2707: LD_INT 8
2709: PPUSH
2710: CALL_OW 111
// AddComHold ( tmp ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2723: LD_ADDR_VAR 0 2
2727: PUSH
2728: LD_VAR 0 3
2732: PPUSH
2733: LD_INT 25
2735: PUSH
2736: LD_INT 1
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 72
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2789
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 20
2758: PPUSH
2759: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2763: LD_VAR 0 2
2767: PPUSH
2768: LD_INT 147
2770: PPUSH
2771: LD_INT 45
2773: PPUSH
2774: CALL_OW 178
// AddComCrawl ( i ) ;
2778: LD_VAR 0 2
2782: PPUSH
2783: CALL_OW 197
// end ;
2787: GO 2748
2789: POP
2790: POP
// repeat wait ( 0 0$1 ) ;
2791: LD_INT 35
2793: PPUSH
2794: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2798: LD_EXP 49
2802: PPUSH
2803: LD_INT 110
2805: PPUSH
2806: LD_INT 10
2808: PPUSH
2809: CALL_OW 307
2813: PUSH
2814: LD_EXP 49
2818: PPUSH
2819: CALL_OW 305
2823: NOT
2824: OR
2825: IFFALSE 2791
// ComStop ( Burlak ) ;
2827: LD_EXP 46
2831: PPUSH
2832: CALL_OW 141
// AddComHold ( Burlak ) ;
2836: LD_EXP 46
2840: PPUSH
2841: CALL_OW 200
// end ; end_of_file
2845: LD_VAR 0 1
2849: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2850: LD_INT 0
2852: PPUSH
2853: PPUSH
2854: PPUSH
2855: PPUSH
// uc_side := 3 ;
2856: LD_ADDR_OWVAR 20
2860: PUSH
2861: LD_INT 3
2863: ST_TO_ADDR
// uc_nation := 3 ;
2864: LD_ADDR_OWVAR 21
2868: PUSH
2869: LD_INT 3
2871: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2872: LD_ADDR_EXP 50
2876: PUSH
2877: LD_INT 47
2879: PPUSH
2880: LD_INT 4
2882: PPUSH
2883: LD_STRING 
2885: PPUSH
2886: LD_INT 7
2888: PUSH
2889: LD_INT 8
2891: PUSH
2892: LD_INT 9
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: LIST
2899: PUSH
2900: LD_OWVAR 67
2904: ARRAY
2905: PPUSH
2906: LD_INT 10000
2908: PUSH
2909: LD_INT 3000
2911: PUSH
2912: LD_INT 300
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: PPUSH
2920: LD_INT 9
2922: PUSH
2923: LD_INT 5
2925: PUSH
2926: LD_INT 6
2928: PUSH
2929: LD_INT 6
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PPUSH
2938: CALL 22602 0 6
2942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2943: LD_ADDR_EXP 59
2947: PUSH
2948: LD_EXP 59
2952: PPUSH
2953: LD_INT 2
2955: PPUSH
2956: LD_EXP 50
2960: PPUSH
2961: CALL_OW 1
2965: ST_TO_ADDR
// tmp := [ ] ;
2966: LD_ADDR_VAR 0 4
2970: PUSH
2971: EMPTY
2972: ST_TO_ADDR
// for i = 1 to 4 do
2973: LD_ADDR_VAR 0 2
2977: PUSH
2978: DOUBLE
2979: LD_INT 1
2981: DEC
2982: ST_TO_ADDR
2983: LD_INT 4
2985: PUSH
2986: FOR_TO
2987: IFFALSE 3080
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 3
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 43
3000: PUSH
3001: LD_INT 45
3003: PUSH
3004: LD_INT 45
3006: PUSH
3007: LD_INT 44
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_INT 4
3023: MOD
3024: PUSH
3025: LD_INT 1
3027: PLUS
3028: ARRAY
3029: PPUSH
3030: LD_INT 100
3032: PPUSH
3033: CALL 19161 0 5
// veh := CreateVehicle ;
3037: LD_ADDR_VAR 0 3
3041: PUSH
3042: CALL_OW 45
3046: ST_TO_ADDR
// tmp := tmp ^ veh ;
3047: LD_ADDR_VAR 0 4
3051: PUSH
3052: LD_VAR 0 4
3056: PUSH
3057: LD_VAR 0 3
3061: ADD
3062: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3063: LD_VAR 0 3
3067: PPUSH
3068: LD_INT 2
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 49
// end ;
3078: GO 2986
3080: POP
3081: POP
// russian_guard := tmp ;
3082: LD_ADDR_EXP 51
3086: PUSH
3087: LD_VAR 0 4
3091: ST_TO_ADDR
// end ;
3092: LD_VAR 0 1
3096: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3097: LD_INT 47
3099: PPUSH
3100: CALL_OW 302
3104: PUSH
3105: LD_EXP 6
3109: AND
3110: IFFALSE 3712
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
// begin enable ;
3123: ENABLE
// base := 2 ;
3124: LD_ADDR_VAR 0 2
3128: PUSH
3129: LD_INT 2
3131: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3132: LD_ADDR_VAR 0 4
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: LD_INT 0
3145: PUSH
3146: LD_INT 0
3148: PUSH
3149: LD_INT 0
3151: PUSH
3152: LD_INT 0
3154: PUSH
3155: LD_INT 0
3157: PUSH
3158: LD_INT 0
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3179: LD_ADDR_VAR 0 3
3183: PUSH
3184: LD_INT 22
3186: PUSH
3187: LD_INT 1
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: LD_INT 45
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 21
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: LD_INT 45
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: LD_INT 45
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 23
3240: PUSH
3241: LD_INT 1
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 46
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3262: LD_ADDR_VAR 0 1
3266: PUSH
3267: DOUBLE
3268: LD_INT 1
3270: DEC
3271: ST_TO_ADDR
3272: LD_OWVAR 67
3276: PUSH
3277: LD_OWVAR 1
3281: PUSH
3282: LD_INT 21000
3284: DIV
3285: PLUS
3286: PUSH
3287: FOR_TO
3288: IFFALSE 3376
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3290: LD_ADDR_VAR 0 3
3294: PUSH
3295: LD_VAR 0 3
3299: PPUSH
3300: LD_VAR 0 3
3304: PUSH
3305: LD_INT 1
3307: PLUS
3308: PPUSH
3309: LD_INT 23
3311: PUSH
3312: LD_INT 24
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: LD_INT 1
3321: PPUSH
3322: LD_INT 2
3324: PPUSH
3325: CALL_OW 12
3329: ARRAY
3330: PUSH
3331: LD_INT 1
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: LD_INT 46
3339: PUSH
3340: LD_INT 47
3342: PUSH
3343: LD_INT 45
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 12
3361: ARRAY
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PPUSH
3369: CALL_OW 2
3373: ST_TO_ADDR
3374: GO 3287
3376: POP
3377: POP
// MC_InsertProduceList ( base , tmp ) ;
3378: LD_VAR 0 2
3382: PPUSH
3383: LD_VAR 0 3
3387: PPUSH
3388: CALL 75741 0 2
// repeat wait ( 0 0$1 ) ;
3392: LD_INT 35
3394: PPUSH
3395: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3399: LD_EXP 78
3403: PUSH
3404: LD_VAR 0 2
3408: ARRAY
3409: PUSH
3410: LD_INT 6
3412: GREATER
3413: IFFALSE 3392
// wait ( 0 0$20 ) ;
3415: LD_INT 700
3417: PPUSH
3418: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3422: LD_ADDR_VAR 0 5
3426: PUSH
3427: LD_INT 71
3429: PUSH
3430: LD_INT 19
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 91
3439: PUSH
3440: LD_INT 67
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PUSH
3447: LD_INT 52
3449: PUSH
3450: LD_INT 44
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PUSH
3457: LD_INT 68
3459: PUSH
3460: LD_INT 48
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_EXP 78
3482: PUSH
3483: LD_VAR 0 2
3487: ARRAY
3488: PUSH
3489: LD_EXP 78
3493: PUSH
3494: LD_VAR 0 2
3498: ARRAY
3499: PPUSH
3500: LD_INT 2
3502: PUSH
3503: LD_INT 34
3505: PUSH
3506: LD_INT 51
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 34
3515: PUSH
3516: LD_INT 52
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: LIST
3527: PPUSH
3528: CALL_OW 72
3532: DIFF
3533: ST_TO_ADDR
// if not attackers then
3534: LD_VAR 0 6
3538: NOT
3539: IFFALSE 3543
// exit ;
3541: GO 3712
// ru_attackers := attackers ;
3543: LD_ADDR_EXP 52
3547: PUSH
3548: LD_VAR 0 6
3552: ST_TO_ADDR
// for i = 1 to attackers do
3553: LD_ADDR_VAR 0 1
3557: PUSH
3558: DOUBLE
3559: LD_INT 1
3561: DEC
3562: ST_TO_ADDR
3563: LD_VAR 0 6
3567: PUSH
3568: FOR_TO
3569: IFFALSE 3646
// begin case i mod 3 of 0 :
3571: LD_VAR 0 1
3575: PUSH
3576: LD_INT 3
3578: MOD
3579: PUSH
3580: LD_INT 0
3582: DOUBLE
3583: EQUAL
3584: IFTRUE 3588
3586: GO 3591
3588: POP
// ; 1 :
3589: GO 3644
3591: LD_INT 1
3593: DOUBLE
3594: EQUAL
3595: IFTRUE 3599
3597: GO 3617
3599: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3600: LD_VAR 0 1
3604: PPUSH
3605: LD_INT 32
3607: PPUSH
3608: LD_INT 49
3610: PPUSH
3611: CALL_OW 114
3615: GO 3644
3617: LD_INT 2
3619: DOUBLE
3620: EQUAL
3621: IFTRUE 3625
3623: GO 3643
3625: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3626: LD_VAR 0 1
3630: PPUSH
3631: LD_INT 117
3633: PPUSH
3634: LD_INT 107
3636: PPUSH
3637: CALL_OW 114
3641: GO 3644
3643: POP
// end ;
3644: GO 3568
3646: POP
3647: POP
// repeat wait ( 0 0$1 ) ;
3648: LD_INT 35
3650: PPUSH
3651: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3655: LD_VAR 0 6
3659: PPUSH
3660: LD_INT 60
3662: PUSH
3663: EMPTY
3664: LIST
3665: PPUSH
3666: CALL_OW 72
3670: NOT
3671: IFFALSE 3648
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3673: LD_VAR 0 2
3677: PPUSH
3678: LD_VAR 0 6
3682: PPUSH
3683: LD_VAR 0 5
3687: PPUSH
3688: LD_VAR 0 4
3692: PPUSH
3693: CALL 75926 0 4
// if not first_attack then
3697: LD_EXP 7
3701: NOT
3702: IFFALSE 3712
// first_attack := true ;
3704: LD_ADDR_EXP 7
3708: PUSH
3709: LD_INT 1
3711: ST_TO_ADDR
// end ; end_of_file
3712: PPOPN 6
3714: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3715: LD_INT 0
3717: PPUSH
3718: PPUSH
3719: PPUSH
3720: PPUSH
3721: PPUSH
3722: PPUSH
3723: PPUSH
// uc_side := 2 ;
3724: LD_ADDR_OWVAR 20
3728: PUSH
3729: LD_INT 2
3731: ST_TO_ADDR
// uc_nation := 2 ;
3732: LD_ADDR_OWVAR 21
3736: PUSH
3737: LD_INT 2
3739: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3740: LD_ADDR_EXP 55
3744: PUSH
3745: LD_STRING Abdul
3747: PPUSH
3748: CALL_OW 25
3752: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3753: LD_EXP 55
3757: PPUSH
3758: LD_INT 11
3760: PPUSH
3761: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3765: LD_EXP 55
3769: PPUSH
3770: LD_INT 1
3772: PPUSH
3773: CALL_OW 52
// vc_chassis := 31 ;
3777: LD_ADDR_OWVAR 37
3781: PUSH
3782: LD_INT 31
3784: ST_TO_ADDR
// vc_control := control_rider ;
3785: LD_ADDR_OWVAR 38
3789: PUSH
3790: LD_INT 4
3792: ST_TO_ADDR
// mastodont := CreateVehicle ;
3793: LD_ADDR_EXP 56
3797: PUSH
3798: CALL_OW 45
3802: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3803: LD_EXP 56
3807: PPUSH
3808: LD_INT 153
3810: PPUSH
3811: LD_INT 71
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL_OW 48
// InitVc ;
3821: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3825: LD_ADDR_EXP 53
3829: PUSH
3830: LD_INT 1
3832: PPUSH
3833: LD_INT 3
3835: PPUSH
3836: LD_STRING 
3838: PPUSH
3839: LD_INT 7
3841: PUSH
3842: LD_INT 8
3844: PUSH
3845: LD_INT 9
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PPUSH
3859: LD_INT 5000
3861: PUSH
3862: LD_INT 1000
3864: PUSH
3865: LD_INT 300
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: LIST
3872: PPUSH
3873: LD_INT 22
3875: PUSH
3876: LD_INT 5
3878: PUSH
3879: LD_INT 6
3881: PUSH
3882: LD_INT 9
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL 22602 0 6
3895: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3896: LD_ADDR_EXP 59
3900: PUSH
3901: LD_EXP 59
3905: PPUSH
3906: LD_INT 1
3908: PPUSH
3909: LD_EXP 53
3913: PPUSH
3914: CALL_OW 1
3918: ST_TO_ADDR
// tmp := [ ] ;
3919: LD_ADDR_VAR 0 4
3923: PUSH
3924: EMPTY
3925: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3926: LD_ADDR_OWVAR 37
3930: PUSH
3931: LD_INT 14
3933: ST_TO_ADDR
// vc_engine := engine_siberite ;
3934: LD_ADDR_OWVAR 39
3938: PUSH
3939: LD_INT 3
3941: ST_TO_ADDR
// vc_control := control_manual ;
3942: LD_ADDR_OWVAR 38
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3950: LD_ADDR_OWVAR 40
3954: PUSH
3955: LD_INT 31
3957: ST_TO_ADDR
// for i = 1 to 3 do
3958: LD_ADDR_VAR 0 2
3962: PUSH
3963: DOUBLE
3964: LD_INT 1
3966: DEC
3967: ST_TO_ADDR
3968: LD_INT 3
3970: PUSH
3971: FOR_TO
3972: IFFALSE 4216
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3974: LD_ADDR_VAR 0 5
3978: PUSH
3979: LD_INT 153
3981: PUSH
3982: LD_INT 71
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 155
3991: PUSH
3992: LD_INT 81
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: LD_VAR 0 2
4007: PUSH
4008: LD_INT 2
4010: MOD
4011: PUSH
4012: LD_INT 1
4014: PLUS
4015: ARRAY
4016: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
4017: LD_INT 0
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 7
4025: PUSH
4026: LD_INT 8
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_OWVAR 67
4041: ARRAY
4042: PPUSH
4043: CALL_OW 380
// un := CreateVehicle ;
4047: LD_ADDR_VAR 0 6
4051: PUSH
4052: CALL_OW 45
4056: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4057: LD_VAR 0 6
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: LD_INT 5
4067: PPUSH
4068: CALL_OW 12
4072: PPUSH
4073: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4077: LD_VAR 0 6
4081: PPUSH
4082: LD_VAR 0 5
4086: PUSH
4087: LD_INT 1
4089: ARRAY
4090: PPUSH
4091: LD_VAR 0 5
4095: PUSH
4096: LD_INT 2
4098: ARRAY
4099: PPUSH
4100: LD_INT 6
4102: PPUSH
4103: LD_INT 0
4105: PPUSH
4106: CALL_OW 50
// un2 := CreateHuman ;
4110: LD_ADDR_VAR 0 7
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4120: LD_VAR 0 7
4124: PPUSH
4125: LD_VAR 0 6
4129: PPUSH
4130: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4134: LD_ADDR_EXP 59
4138: PUSH
4139: LD_EXP 59
4143: PPUSH
4144: LD_INT 1
4146: PUSH
4147: LD_EXP 59
4151: PUSH
4152: LD_INT 1
4154: ARRAY
4155: PUSH
4156: LD_INT 1
4158: PLUS
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PPUSH
4164: LD_VAR 0 6
4168: PPUSH
4169: CALL 19283 0 3
4173: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4174: LD_ADDR_EXP 59
4178: PUSH
4179: LD_EXP 59
4183: PPUSH
4184: LD_INT 1
4186: PUSH
4187: LD_EXP 59
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PPUSH
4204: LD_VAR 0 7
4208: PPUSH
4209: CALL 19283 0 3
4213: ST_TO_ADDR
// end ;
4214: GO 3971
4216: POP
4217: POP
// for i = 1 to 5 do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_INT 5
4230: PUSH
4231: FOR_TO
4232: IFFALSE 4325
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4234: LD_INT 14
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 1
4242: PPUSH
4243: LD_INT 25
4245: PUSH
4246: LD_INT 28
4248: PUSH
4249: LD_INT 28
4251: PUSH
4252: LD_INT 26
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_VAR 0 2
4265: PUSH
4266: LD_INT 4
4268: MOD
4269: PUSH
4270: LD_INT 1
4272: PLUS
4273: ARRAY
4274: PPUSH
4275: LD_INT 100
4277: PPUSH
4278: CALL 19161 0 5
// veh := CreateVehicle ;
4282: LD_ADDR_VAR 0 3
4286: PUSH
4287: CALL_OW 45
4291: ST_TO_ADDR
// tmp := tmp ^ veh ;
4292: LD_ADDR_VAR 0 4
4296: PUSH
4297: LD_VAR 0 4
4301: PUSH
4302: LD_VAR 0 3
4306: ADD
4307: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4308: LD_VAR 0 3
4312: PPUSH
4313: LD_INT 1
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: CALL_OW 49
// end ;
4323: GO 4231
4325: POP
4326: POP
// arabian_guard := tmp ;
4327: LD_ADDR_EXP 54
4331: PUSH
4332: LD_VAR 0 4
4336: ST_TO_ADDR
// end ;
4337: LD_VAR 0 1
4341: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4342: LD_INT 22
4344: PUSH
4345: LD_INT 7
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 91
4354: PUSH
4355: LD_INT 1
4357: PUSH
4358: LD_INT 12
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PPUSH
4370: CALL_OW 69
4374: PUSH
4375: LD_EXP 56
4379: PPUSH
4380: CALL_OW 256
4384: PUSH
4385: LD_INT 990
4387: LESS
4388: OR
4389: PUSH
4390: LD_EXP 55
4394: PPUSH
4395: CALL_OW 256
4399: PUSH
4400: LD_INT 990
4402: LESS
4403: OR
4404: IFFALSE 4547
4406: GO 4408
4408: DISABLE
// begin if IsInUnit ( Abdul ) then
4409: LD_EXP 55
4413: PPUSH
4414: CALL_OW 310
4418: IFFALSE 4429
// ComExitBuilding ( Abdul ) ;
4420: LD_EXP 55
4424: PPUSH
4425: CALL_OW 122
// if Mastodont then
4429: LD_EXP 56
4433: IFFALSE 4450
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4435: LD_EXP 56
4439: PPUSH
4440: LD_INT 205
4442: PPUSH
4443: LD_INT 132
4445: PPUSH
4446: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4450: LD_EXP 55
4454: PPUSH
4455: LD_INT 205
4457: PPUSH
4458: LD_INT 132
4460: PPUSH
4461: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4465: LD_INT 35
4467: PPUSH
4468: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4472: LD_EXP 55
4476: PPUSH
4477: LD_INT 21
4479: PPUSH
4480: CALL_OW 308
4484: IFFALSE 4465
// RemoveUnit ( Abdul ) ;
4486: LD_EXP 55
4490: PPUSH
4491: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4495: LD_INT 35
4497: PPUSH
4498: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4502: LD_EXP 56
4506: PPUSH
4507: LD_INT 21
4509: PPUSH
4510: CALL_OW 308
4514: PUSH
4515: LD_EXP 56
4519: PPUSH
4520: CALL_OW 301
4524: OR
4525: IFFALSE 4495
// if IsOk ( Mastodont ) then
4527: LD_EXP 56
4531: PPUSH
4532: CALL_OW 302
4536: IFFALSE 4547
// RemoveUnit ( Mastodont ) ;
4538: LD_EXP 56
4542: PPUSH
4543: CALL_OW 64
// end ;
4547: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4548: LD_EXP 55
4552: PPUSH
4553: CALL_OW 301
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 2
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 2
4570: PUSH
4571: LD_INT 25
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 25
4583: PUSH
4584: LD_INT 2
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: LD_INT 25
4593: PUSH
4594: LD_INT 3
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 25
4603: PUSH
4604: LD_INT 4
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 25
4613: PUSH
4614: LD_INT 8
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PPUSH
4633: CALL_OW 69
4637: PUSH
4638: LD_INT 16
4640: PUSH
4641: LD_INT 19
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: LESS
4658: OR
4659: IFFALSE 5332
4661: GO 4663
4663: DISABLE
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
4668: PPUSH
4669: PPUSH
4670: PPUSH
4671: PPUSH
// begin MC_Kill ( 1 ) ;
4672: LD_INT 1
4674: PPUSH
4675: CALL 52228 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4679: LD_ADDR_VAR 0 2
4683: PUSH
4684: LD_INT 22
4686: PUSH
4687: LD_INT 2
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: LD_INT 2
4696: PUSH
4697: LD_INT 25
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: LD_INT 25
4709: PUSH
4710: LD_INT 2
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PUSH
4717: LD_INT 25
4719: PUSH
4720: LD_INT 3
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: PUSH
4727: LD_INT 25
4729: PUSH
4730: LD_INT 4
4732: PUSH
4733: EMPTY
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 25
4739: PUSH
4740: LD_INT 8
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: PPUSH
4759: CALL_OW 69
4763: ST_TO_ADDR
// for i in tmp do
4764: LD_ADDR_VAR 0 5
4768: PUSH
4769: LD_VAR 0 2
4773: PUSH
4774: FOR_IN
4775: IFFALSE 4791
// SetTag ( i , 10 ) ;
4777: LD_VAR 0 5
4781: PPUSH
4782: LD_INT 10
4784: PPUSH
4785: CALL_OW 109
4789: GO 4774
4791: POP
4792: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4793: LD_ADDR_VAR 0 3
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 21
4810: PUSH
4811: LD_INT 1
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: PUSH
4827: LD_VAR 0 2
4831: DIFF
4832: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4833: LD_ADDR_VAR 0 1
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 21
4850: PUSH
4851: LD_INT 2
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 24
4860: PUSH
4861: LD_INT 300
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_VAR 0 1
4887: PPUSH
4888: LD_INT 33
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 58
4900: PUSH
4901: EMPTY
4902: LIST
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PPUSH
4908: CALL_OW 72
4912: ST_TO_ADDR
// for i in tmp do
4913: LD_ADDR_VAR 0 5
4917: PUSH
4918: LD_VAR 0 2
4922: PUSH
4923: FOR_IN
4924: IFFALSE 5108
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 55
4933: PUSH
4934: EMPTY
4935: LIST
4936: PPUSH
4937: CALL_OW 69
4941: IN
4942: IFFALSE 4961
// begin AddComMoveXY ( i , 209 , 132 ) ;
4944: LD_VAR 0 5
4948: PPUSH
4949: LD_INT 209
4951: PPUSH
4952: LD_INT 132
4954: PPUSH
4955: CALL_OW 171
// continue ;
4959: GO 4923
// end ; if IsInUnit ( i ) then
4961: LD_VAR 0 5
4965: PPUSH
4966: CALL_OW 310
4970: IFFALSE 4988
// begin ComExitBuilding ( i ) ;
4972: LD_VAR 0 5
4976: PPUSH
4977: CALL_OW 122
// wait ( 3 ) ;
4981: LD_INT 3
4983: PPUSH
4984: CALL_OW 67
// end ; if tmp_empty then
4988: LD_VAR 0 4
4992: IFFALSE 5091
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_VAR 0 4
5003: PPUSH
5004: LD_VAR 0 5
5008: PPUSH
5009: CALL_OW 74
5013: PPUSH
5014: CALL_OW 296
5018: PUSH
5019: LD_INT 25
5021: LESS
5022: IFFALSE 5091
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5024: LD_ADDR_VAR 0 6
5028: PUSH
5029: LD_VAR 0 4
5033: PPUSH
5034: LD_VAR 0 5
5038: PPUSH
5039: CALL_OW 74
5043: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5044: LD_VAR 0 5
5048: PPUSH
5049: LD_VAR 0 6
5053: PPUSH
5054: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: LD_INT 209
5065: PPUSH
5066: LD_INT 132
5068: PPUSH
5069: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_VAR 0 6
5087: DIFF
5088: ST_TO_ADDR
// continue ;
5089: GO 4923
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5091: LD_VAR 0 5
5095: PPUSH
5096: LD_INT 201
5098: PPUSH
5099: LD_INT 132
5101: PPUSH
5102: CALL_OW 171
// end ;
5106: GO 4923
5108: POP
5109: POP
// for i in tmp_ape do
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: LD_VAR 0 3
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5160
// begin if IsInUnit ( i ) then
5123: LD_VAR 0 5
5127: PPUSH
5128: CALL_OW 310
5132: IFFALSE 5143
// ComExitBuilding ( i ) ;
5134: LD_VAR 0 5
5138: PPUSH
5139: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5143: LD_VAR 0 5
5147: PPUSH
5148: LD_INT 201
5150: PPUSH
5151: LD_INT 132
5153: PPUSH
5154: CALL_OW 171
// end ;
5158: GO 5120
5160: POP
5161: POP
// repeat wait ( 0 0$1 ) ;
5162: LD_INT 35
5164: PPUSH
5165: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5169: LD_ADDR_VAR 0 5
5173: PUSH
5174: LD_VAR 0 2
5178: PUSH
5179: LD_VAR 0 3
5183: UNION
5184: PUSH
5185: LD_VAR 0 1
5189: UNION
5190: PUSH
5191: FOR_IN
5192: IFFALSE 5223
// if not HasTask ( i ) then
5194: LD_VAR 0 5
5198: PPUSH
5199: CALL_OW 314
5203: NOT
5204: IFFALSE 5221
// ComMoveXY ( i , 201 , 132 ) ;
5206: LD_VAR 0 5
5210: PPUSH
5211: LD_INT 201
5213: PPUSH
5214: LD_INT 132
5216: PPUSH
5217: CALL_OW 111
5221: GO 5191
5223: POP
5224: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5225: LD_INT 21
5227: PPUSH
5228: LD_INT 22
5230: PUSH
5231: LD_INT 2
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 70
5242: IFFALSE 5283
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5244: LD_ADDR_VAR 0 5
5248: PUSH
5249: LD_INT 21
5251: PPUSH
5252: LD_INT 22
5254: PUSH
5255: LD_INT 2
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: PPUSH
5262: CALL_OW 70
5266: PUSH
5267: FOR_IN
5268: IFFALSE 5281
// RemoveUnit ( i ) ;
5270: LD_VAR 0 5
5274: PPUSH
5275: CALL_OW 64
5279: GO 5267
5281: POP
5282: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5283: LD_INT 22
5285: PUSH
5286: LD_INT 2
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 2
5295: PUSH
5296: LD_INT 21
5298: PUSH
5299: LD_INT 1
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PUSH
5306: LD_INT 21
5308: PUSH
5309: LD_INT 2
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: PPUSH
5325: CALL_OW 69
5329: NOT
5330: IFFALSE 5162
// end ;
5332: PPOPN 6
5334: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5335: LD_EXP 9
5339: PUSH
5340: LD_INT 92
5342: PPUSH
5343: LD_INT 40
5345: PPUSH
5346: CALL_OW 428
5350: PPUSH
5351: CALL_OW 266
5355: PUSH
5356: LD_INT 30
5358: EQUAL
5359: AND
5360: IFFALSE 5556
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5368: LD_ADDR_VAR 0 1
5372: PUSH
5373: LD_EXP 59
5377: PUSH
5378: LD_INT 1
5380: ARRAY
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 4
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: CALL_OW 72
5396: ST_TO_ADDR
// if not sci then
5397: LD_VAR 0 1
5401: NOT
5402: IFFALSE 5406
// exit ;
5404: GO 5556
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5406: LD_ADDR_EXP 59
5410: PUSH
5411: LD_EXP 59
5415: PPUSH
5416: LD_INT 1
5418: PPUSH
5419: LD_EXP 59
5423: PUSH
5424: LD_INT 1
5426: ARRAY
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 1
5435: ARRAY
5436: DIFF
5437: PPUSH
5438: CALL_OW 1
5442: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5443: LD_VAR 0 1
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 310
5456: IFFALSE 5471
// ComExitBuilding ( sci [ 1 ] ) ;
5458: LD_VAR 0 1
5462: PUSH
5463: LD_INT 1
5465: ARRAY
5466: PPUSH
5467: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5471: LD_INT 2
5473: PPUSH
5474: LD_INT 105
5476: PPUSH
5477: LD_INT 14
5479: PPUSH
5480: LD_INT 20
5482: PPUSH
5483: CALL 20179 0 4
5487: PUSH
5488: LD_INT 4
5490: ARRAY
5491: PUSH
5492: LD_INT 10
5494: LESS
5495: IFFALSE 5518
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: LD_INT 105
5508: PPUSH
5509: LD_INT 14
5511: PPUSH
5512: CALL_OW 171
5516: GO 5537
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5518: LD_VAR 0 1
5522: PUSH
5523: LD_INT 1
5525: ARRAY
5526: PPUSH
5527: LD_INT 118
5529: PPUSH
5530: LD_INT 77
5532: PPUSH
5533: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5537: LD_VAR 0 1
5541: PUSH
5542: LD_INT 1
5544: ARRAY
5545: PPUSH
5546: LD_INT 92
5548: PPUSH
5549: LD_INT 40
5551: PPUSH
5552: CALL_OW 218
// end ;
5556: PPOPN 1
5558: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5559: LD_INT 1
5561: PPUSH
5562: CALL_OW 302
5566: PUSH
5567: LD_EXP 9
5571: AND
5572: IFFALSE 6051
5574: GO 5576
5576: DISABLE
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// begin enable ;
5585: ENABLE
// base := 1 ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: LD_INT 1
5593: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_INT 0
5601: PUSH
5602: LD_INT 0
5604: PUSH
5605: LD_INT 0
5607: PUSH
5608: LD_INT 0
5610: PUSH
5611: LD_INT 0
5613: PUSH
5614: LD_INT 0
5616: PUSH
5617: LD_INT 0
5619: PUSH
5620: LD_INT 0
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 0
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 14
5648: PUSH
5649: LD_INT 1
5651: PUSH
5652: LD_INT 2
5654: PUSH
5655: LD_INT 26
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 14
5666: PUSH
5667: LD_INT 1
5669: PUSH
5670: LD_INT 2
5672: PUSH
5673: LD_INT 28
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 13
5684: PUSH
5685: LD_INT 1
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 29
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5705: LD_ADDR_VAR 0 1
5709: PUSH
5710: DOUBLE
5711: LD_INT 1
5713: DEC
5714: ST_TO_ADDR
5715: LD_OWVAR 67
5719: PUSH
5720: LD_OWVAR 1
5724: PUSH
5725: LD_INT 21000
5727: DIV
5728: PLUS
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5823
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_VAR 0 3
5742: PPUSH
5743: LD_VAR 0 3
5747: PUSH
5748: LD_INT 1
5750: PLUS
5751: PPUSH
5752: LD_INT 13
5754: PUSH
5755: LD_INT 14
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 1
5764: PPUSH
5765: LD_INT 2
5767: PPUSH
5768: CALL_OW 12
5772: ARRAY
5773: PUSH
5774: LD_INT 1
5776: PUSH
5777: LD_INT 2
5779: PUSH
5780: LD_INT 28
5782: PUSH
5783: LD_INT 29
5785: PUSH
5786: LD_INT 25
5788: PUSH
5789: LD_INT 26
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_INT 4
5803: PPUSH
5804: CALL_OW 12
5808: ARRAY
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 2
5820: ST_TO_ADDR
5821: GO 5730
5823: POP
5824: POP
// MC_InsertProduceList ( base , tmp ) ;
5825: LD_VAR 0 2
5829: PPUSH
5830: LD_VAR 0 3
5834: PPUSH
5835: CALL 75741 0 2
// repeat wait ( 0 0$1 ) ;
5839: LD_INT 35
5841: PPUSH
5842: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5846: LD_EXP 78
5850: PUSH
5851: LD_VAR 0 2
5855: ARRAY
5856: PUSH
5857: LD_INT 6
5859: GREATER
5860: IFFALSE 5839
// wait ( 0 0$20 ) ;
5862: LD_INT 700
5864: PPUSH
5865: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5869: LD_ADDR_VAR 0 5
5873: PUSH
5874: LD_INT 124
5876: PUSH
5877: LD_INT 85
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: LD_INT 90
5886: PUSH
5887: LD_INT 61
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: PUSH
5894: LD_INT 69
5896: PUSH
5897: LD_INT 48
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: LD_INT 68
5906: PUSH
5907: LD_INT 48
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5920: LD_ADDR_VAR 0 6
5924: PUSH
5925: LD_EXP 78
5929: PUSH
5930: LD_VAR 0 2
5934: ARRAY
5935: PUSH
5936: LD_EXP 78
5940: PUSH
5941: LD_VAR 0 2
5945: ARRAY
5946: PPUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 34
5952: PUSH
5953: LD_INT 32
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PUSH
5960: LD_INT 34
5962: PUSH
5963: LD_EXP 108
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 72
5981: DIFF
5982: ST_TO_ADDR
// if not attackers then
5983: LD_VAR 0 6
5987: NOT
5988: IFFALSE 5992
// exit ;
5990: GO 6051
// ar_attackers := attackers ;
5992: LD_ADDR_EXP 10
5996: PUSH
5997: LD_VAR 0 6
6001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6002: LD_INT 35
6004: PPUSH
6005: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6009: LD_VAR 0 6
6013: PPUSH
6014: LD_INT 60
6016: PUSH
6017: EMPTY
6018: LIST
6019: PPUSH
6020: CALL_OW 72
6024: NOT
6025: IFFALSE 6002
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6027: LD_VAR 0 2
6031: PPUSH
6032: LD_VAR 0 6
6036: PPUSH
6037: LD_VAR 0 5
6041: PPUSH
6042: LD_VAR 0 4
6046: PPUSH
6047: CALL 75926 0 4
// end ;
6051: PPOPN 6
6053: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6054: LD_INT 1
6056: PPUSH
6057: CALL_OW 302
6061: PUSH
6062: LD_EXP 9
6066: AND
6067: PUSH
6068: LD_EXP 49
6072: PPUSH
6073: LD_INT 22
6075: PPUSH
6076: CALL_OW 308
6080: AND
6081: PUSH
6082: LD_INT 1
6084: PPUSH
6085: CALL 76089 0 1
6089: PUSH
6090: LD_INT 0
6092: EQUAL
6093: AND
6094: PUSH
6095: LD_EXP 10
6099: NOT
6100: AND
6101: IFFALSE 6565
6103: GO 6105
6105: DISABLE
6106: LD_INT 0
6108: PPUSH
6109: PPUSH
6110: PPUSH
6111: PPUSH
6112: PPUSH
6113: PPUSH
6114: PPUSH
// begin base := 1 ;
6115: LD_ADDR_VAR 0 2
6119: PUSH
6120: LD_INT 1
6122: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6123: LD_ADDR_VAR 0 4
6127: PUSH
6128: LD_INT 0
6130: PUSH
6131: LD_INT 0
6133: PUSH
6134: LD_INT 0
6136: PUSH
6137: LD_INT 0
6139: PUSH
6140: LD_INT 0
6142: PUSH
6143: LD_INT 0
6145: PUSH
6146: LD_INT 0
6148: PUSH
6149: LD_INT 0
6151: PUSH
6152: LD_INT 1
6154: PUSH
6155: LD_INT 0
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6170: LD_ADDR_VAR 0 3
6174: PUSH
6175: LD_INT 13
6177: PUSH
6178: LD_INT 1
6180: PUSH
6181: LD_INT 2
6183: PUSH
6184: LD_INT 28
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: LIST
6191: LIST
6192: PUSH
6193: LD_INT 13
6195: PUSH
6196: LD_INT 1
6198: PUSH
6199: LD_INT 2
6201: PUSH
6202: LD_INT 27
6204: PUSH
6205: EMPTY
6206: LIST
6207: LIST
6208: LIST
6209: LIST
6210: PUSH
6211: LD_INT 13
6213: PUSH
6214: LD_INT 1
6216: PUSH
6217: LD_INT 2
6219: PUSH
6220: LD_INT 25
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: LIST
6227: LIST
6228: PUSH
6229: LD_INT 11
6231: PUSH
6232: LD_INT 2
6234: PUSH
6235: LD_INT 2
6237: PUSH
6238: LD_INT 24
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PUSH
6247: LD_INT 11
6249: PUSH
6250: LD_INT 2
6252: PUSH
6253: LD_INT 2
6255: PUSH
6256: LD_INT 24
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: LIST
6263: LIST
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6272: LD_VAR 0 2
6276: PPUSH
6277: LD_VAR 0 3
6281: PPUSH
6282: CALL 75741 0 2
// repeat wait ( 0 0$1 ) ;
6286: LD_INT 35
6288: PPUSH
6289: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6293: LD_EXP 78
6297: PUSH
6298: LD_VAR 0 2
6302: ARRAY
6303: PUSH
6304: LD_INT 6
6306: GREATEREQUAL
6307: IFFALSE 6286
// wait ( 0 0$20 ) ;
6309: LD_INT 700
6311: PPUSH
6312: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6316: LD_ADDR_VAR 0 5
6320: PUSH
6321: LD_INT 119
6323: PUSH
6324: LD_INT 9
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6334: LD_ADDR_VAR 0 6
6338: PUSH
6339: LD_EXP 78
6343: PUSH
6344: LD_VAR 0 2
6348: ARRAY
6349: PUSH
6350: LD_EXP 78
6354: PUSH
6355: LD_VAR 0 2
6359: ARRAY
6360: PPUSH
6361: LD_INT 34
6363: PUSH
6364: LD_INT 32
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PPUSH
6371: CALL_OW 72
6375: DIFF
6376: ST_TO_ADDR
// if not attackers then
6377: LD_VAR 0 6
6381: NOT
6382: IFFALSE 6386
// exit ;
6384: GO 6565
// uc_side := 2 ;
6386: LD_ADDR_OWVAR 20
6390: PUSH
6391: LD_INT 2
6393: ST_TO_ADDR
// uc_nation := 2 ;
6394: LD_ADDR_OWVAR 21
6398: PUSH
6399: LD_INT 2
6401: ST_TO_ADDR
// InitHc ;
6402: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6406: LD_ADDR_VAR 0 1
6410: PUSH
6411: DOUBLE
6412: LD_INT 1
6414: DEC
6415: ST_TO_ADDR
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: LD_INT 6
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: FOR_TO
6437: IFFALSE 6514
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6439: LD_INT 0
6441: PPUSH
6442: LD_INT 15
6444: PUSH
6445: LD_INT 17
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: PUSH
6452: LD_INT 1
6454: PPUSH
6455: LD_INT 2
6457: PPUSH
6458: CALL_OW 12
6462: ARRAY
6463: PPUSH
6464: LD_INT 8
6466: PPUSH
6467: CALL_OW 380
// un := CreateHuman ;
6471: LD_ADDR_VAR 0 7
6475: PUSH
6476: CALL_OW 44
6480: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6481: LD_VAR 0 7
6485: PPUSH
6486: LD_INT 23
6488: PPUSH
6489: LD_INT 0
6491: PPUSH
6492: CALL_OW 49
// attackers := attackers union un ;
6496: LD_ADDR_VAR 0 6
6500: PUSH
6501: LD_VAR 0 6
6505: PUSH
6506: LD_VAR 0 7
6510: UNION
6511: ST_TO_ADDR
// end ;
6512: GO 6436
6514: POP
6515: POP
// repeat wait ( 0 0$1 ) ;
6516: LD_INT 35
6518: PPUSH
6519: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6523: LD_VAR 0 6
6527: PPUSH
6528: LD_INT 60
6530: PUSH
6531: EMPTY
6532: LIST
6533: PPUSH
6534: CALL_OW 72
6538: NOT
6539: IFFALSE 6516
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6541: LD_VAR 0 2
6545: PPUSH
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PPUSH
6556: LD_VAR 0 4
6560: PPUSH
6561: CALL 75926 0 4
// end ; end_of_file
6565: PPOPN 7
6567: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6568: LD_INT 0
6570: PPUSH
6571: PPUSH
6572: PPUSH
6573: PPUSH
// uc_side := 1 ;
6574: LD_ADDR_OWVAR 20
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// uc_nation := 1 ;
6582: LD_ADDR_OWVAR 21
6586: PUSH
6587: LD_INT 1
6589: ST_TO_ADDR
// InitHc ;
6590: CALL_OW 19
// InitVc ;
6594: CALL_OW 20
// tmp := [ ] ;
6598: LD_ADDR_VAR 0 3
6602: PUSH
6603: EMPTY
6604: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6605: LD_ADDR_VAR 0 2
6609: PUSH
6610: DOUBLE
6611: LD_INT 1
6613: DEC
6614: ST_TO_ADDR
6615: LD_INT 5
6617: PUSH
6618: LD_INT 6
6620: PUSH
6621: LD_INT 6
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: LIST
6628: PUSH
6629: LD_OWVAR 67
6633: ARRAY
6634: PUSH
6635: FOR_TO
6636: IFFALSE 6773
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6638: LD_INT 2
6640: PUSH
6641: LD_INT 4
6643: PUSH
6644: LD_INT 5
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 3
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: LD_INT 1
6666: PUSH
6667: LD_INT 3
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 1
6676: PPUSH
6677: LD_INT 2
6679: PPUSH
6680: CALL_OW 12
6684: ARRAY
6685: PPUSH
6686: LD_INT 3
6688: PPUSH
6689: LD_INT 9
6691: PUSH
6692: LD_INT 7
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: LD_INT 1
6701: PPUSH
6702: LD_INT 2
6704: PPUSH
6705: CALL_OW 12
6709: ARRAY
6710: PPUSH
6711: LD_INT 78
6713: PPUSH
6714: CALL 19161 0 5
// veh := CreateVehicle ;
6718: LD_ADDR_VAR 0 4
6722: PUSH
6723: CALL_OW 45
6727: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6728: LD_VAR 0 4
6732: PPUSH
6733: LD_INT 2
6735: PPUSH
6736: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6740: LD_VAR 0 4
6744: PPUSH
6745: LD_INT 17
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 49
// tmp := tmp ^ veh ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_VAR 0 3
6764: PUSH
6765: LD_VAR 0 4
6769: ADD
6770: ST_TO_ADDR
// end ;
6771: GO 6635
6773: POP
6774: POP
// if not tmp then
6775: LD_VAR 0 3
6779: NOT
6780: IFFALSE 6784
// exit ;
6782: GO 6893
// if not first_powell_attack then
6784: LD_EXP 11
6788: NOT
6789: IFFALSE 6799
// first_powell_attack := true ;
6791: LD_ADDR_EXP 11
6795: PUSH
6796: LD_INT 1
6798: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6799: LD_INT 70
6801: PPUSH
6802: CALL_OW 67
// for i in tmp do
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 3
6815: PUSH
6816: FOR_IN
6817: IFFALSE 6884
// if IsOk ( i ) then
6819: LD_VAR 0 2
6823: PPUSH
6824: CALL_OW 302
6828: IFFALSE 6866
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6830: LD_VAR 0 2
6834: PPUSH
6835: LD_INT 81
6837: PUSH
6838: LD_INT 1
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PPUSH
6845: CALL_OW 69
6849: PPUSH
6850: LD_VAR 0 2
6854: PPUSH
6855: CALL_OW 74
6859: PPUSH
6860: CALL_OW 115
6864: GO 6882
// tmp := tmp diff i ;
6866: LD_ADDR_VAR 0 3
6870: PUSH
6871: LD_VAR 0 3
6875: PUSH
6876: LD_VAR 0 2
6880: DIFF
6881: ST_TO_ADDR
6882: GO 6816
6884: POP
6885: POP
// until not tmp ;
6886: LD_VAR 0 3
6890: NOT
6891: IFFALSE 6799
// end ; end_of_file
6893: LD_VAR 0 1
6897: RET
// export function Action ; var tmp , i , un ; begin
6898: LD_INT 0
6900: PPUSH
6901: PPUSH
6902: PPUSH
6903: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6904: LD_INT 68
6906: PPUSH
6907: LD_INT 39
6909: PPUSH
6910: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6914: LD_ADDR_VAR 0 2
6918: PUSH
6919: LD_INT 22
6921: PUSH
6922: LD_INT 7
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PPUSH
6929: CALL_OW 69
6933: ST_TO_ADDR
// InGameOn ;
6934: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6938: LD_VAR 0 2
6942: PPUSH
6943: LD_INT 71
6945: PPUSH
6946: LD_INT 49
6948: PPUSH
6949: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6953: LD_INT 35
6955: PPUSH
6956: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6960: LD_INT 7
6962: PPUSH
6963: LD_INT 71
6965: PPUSH
6966: LD_INT 51
6968: PPUSH
6969: CALL_OW 293
6973: IFFALSE 6953
// DialogueOn ;
6975: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6979: LD_EXP 15
6983: PPUSH
6984: LD_STRING D1-JMM-1
6986: PPUSH
6987: CALL_OW 88
// if Joan then
6991: LD_EXP 30
6995: IFFALSE 7009
// Say ( Joan , D1-Joan-1 ) ;
6997: LD_EXP 30
7001: PPUSH
7002: LD_STRING D1-Joan-1
7004: PPUSH
7005: CALL_OW 88
// if Lisa then
7009: LD_EXP 17
7013: IFFALSE 7027
// Say ( Lisa , D1-Lisa-1 ) ;
7015: LD_EXP 17
7019: PPUSH
7020: LD_STRING D1-Lisa-1
7022: PPUSH
7023: CALL_OW 88
// if Joan or Lisa then
7027: LD_EXP 30
7031: PUSH
7032: LD_EXP 17
7036: OR
7037: IFFALSE 7051
// Say ( JMM , D1-JMM-2 ) ;
7039: LD_EXP 15
7043: PPUSH
7044: LD_STRING D1-JMM-2
7046: PPUSH
7047: CALL_OW 88
// DialogueOff ;
7051: CALL_OW 7
// InGameOff ;
7055: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7059: LD_INT 71
7061: PPUSH
7062: LD_INT 50
7064: PPUSH
7065: LD_INT 7
7067: PPUSH
7068: LD_INT 30
7070: NEG
7071: PPUSH
7072: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7076: LD_INT 71
7078: PPUSH
7079: LD_INT 50
7081: PPUSH
7082: LD_INT 7
7084: PPUSH
7085: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7089: LD_STRING M1
7091: PPUSH
7092: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7096: LD_INT 35
7098: PPUSH
7099: CALL_OW 67
// until freedom ;
7103: LD_EXP 3
7107: IFFALSE 7096
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7109: LD_INT 350
7111: PPUSH
7112: LD_INT 700
7114: PPUSH
7115: CALL_OW 12
7119: PPUSH
7120: CALL_OW 67
// PrepareGossudarov ;
7124: CALL 1827 0 0
// repeat wait ( 0 0$1 ) ;
7128: LD_INT 35
7130: PPUSH
7131: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7135: LD_INT 22
7137: PUSH
7138: LD_INT 6
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: PUSH
7145: LD_INT 3
7147: PUSH
7148: LD_INT 24
7150: PUSH
7151: LD_INT 1000
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PPUSH
7166: CALL_OW 69
7170: PUSH
7171: LD_INT 7
7173: PPUSH
7174: LD_EXP 32
7178: PPUSH
7179: CALL_OW 292
7183: OR
7184: IFFALSE 7128
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7186: LD_ADDR_VAR 0 2
7190: PUSH
7191: LD_INT 22
7193: PUSH
7194: LD_INT 6
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: PPUSH
7201: CALL_OW 69
7205: ST_TO_ADDR
// for i in tmp do
7206: LD_ADDR_VAR 0 3
7210: PUSH
7211: LD_VAR 0 2
7215: PUSH
7216: FOR_IN
7217: IFFALSE 7233
// SetSide ( i , 7 ) ;
7219: LD_VAR 0 3
7223: PPUSH
7224: LD_INT 7
7226: PPUSH
7227: CALL_OW 235
7231: GO 7216
7233: POP
7234: POP
// DialogueOn ;
7235: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7239: LD_EXP 15
7243: PUSH
7244: LD_EXP 16
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PPUSH
7253: LD_EXP 32
7257: PPUSH
7258: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7262: LD_EXP 32
7266: PPUSH
7267: CALL_OW 87
// if not Roth then
7271: LD_EXP 16
7275: NOT
7276: IFFALSE 7368
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7278: LD_VAR 0 2
7282: PPUSH
7283: LD_INT 3
7285: PUSH
7286: LD_INT 24
7288: PUSH
7289: LD_INT 1000
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL_OW 72
7304: IFFALSE 7318
// Say ( JMM , D2-JMM-1 ) ;
7306: LD_EXP 15
7310: PPUSH
7311: LD_STRING D2-JMM-1
7313: PPUSH
7314: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7318: LD_EXP 15
7322: PPUSH
7323: LD_STRING D2-JMM-1b
7325: PPUSH
7326: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7330: LD_EXP 32
7334: PPUSH
7335: LD_STRING D2-Gos-1
7337: PPUSH
7338: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7342: LD_EXP 15
7346: PPUSH
7347: LD_STRING D2-JMM-2
7349: PPUSH
7350: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7354: LD_EXP 32
7358: PPUSH
7359: LD_STRING D2-Gos-2
7361: PPUSH
7362: CALL_OW 88
// end else
7366: GO 7520
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7368: LD_VAR 0 2
7372: PPUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 24
7378: PUSH
7379: LD_INT 1000
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PPUSH
7390: CALL_OW 72
7394: IFFALSE 7420
// begin Say ( Roth , D2-Roth-2 ) ;
7396: LD_EXP 16
7400: PPUSH
7401: LD_STRING D2-Roth-2
7403: PPUSH
7404: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7408: LD_EXP 15
7412: PPUSH
7413: LD_STRING D2-JMM-1a
7415: PPUSH
7416: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7420: LD_EXP 16
7424: PPUSH
7425: LD_STRING D2-Roth-2a
7427: PPUSH
7428: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7432: LD_EXP 16
7436: PPUSH
7437: LD_STRING D2-Roth-2b
7439: PPUSH
7440: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7444: LD_EXP 15
7448: PPUSH
7449: LD_STRING D2-JMM-3
7451: PPUSH
7452: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7456: LD_VAR 0 2
7460: PPUSH
7461: LD_INT 3
7463: PUSH
7464: LD_INT 24
7466: PUSH
7467: LD_INT 1000
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 72
7482: IFFALSE 7520
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7484: LD_EXP 32
7488: PPUSH
7489: LD_STRING D2-Gos-3
7491: PPUSH
7492: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7496: LD_EXP 15
7500: PPUSH
7501: LD_STRING D2-JMM-4
7503: PPUSH
7504: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7508: LD_EXP 32
7512: PPUSH
7513: LD_STRING D2-Gos-4
7515: PPUSH
7516: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7520: LD_EXP 15
7524: PPUSH
7525: LD_STRING D2-JMM-5
7527: PPUSH
7528: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7532: LD_EXP 32
7536: PPUSH
7537: LD_STRING D2-Gos-5
7539: PPUSH
7540: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7544: LD_EXP 15
7548: PPUSH
7549: LD_STRING D2-JMM-6
7551: PPUSH
7552: CALL_OW 88
// DialogueOff ;
7556: CALL_OW 7
// wait ( 0 0$2 ) ;
7560: LD_INT 70
7562: PPUSH
7563: CALL_OW 67
// if Kirilenkova then
7567: LD_EXP 33
7571: IFFALSE 7585
// Say ( Kirilenkova , D3-Kir-1 ) ;
7573: LD_EXP 33
7577: PPUSH
7578: LD_STRING D3-Kir-1
7580: PPUSH
7581: CALL_OW 88
// gossudarov_arrive := true ;
7585: LD_ADDR_EXP 4
7589: PUSH
7590: LD_INT 1
7592: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7593: LD_INT 35
7595: PPUSH
7596: CALL_OW 67
// until ru_lab_builded ;
7600: LD_EXP 5
7604: IFFALSE 7593
// DialogueOn ;
7606: CALL_OW 6
// if Kirilenkova then
7610: LD_EXP 33
7614: IFFALSE 7630
// Say ( Kirilenkova , D3a-Kir-1 ) else
7616: LD_EXP 33
7620: PPUSH
7621: LD_STRING D3a-Kir-1
7623: PPUSH
7624: CALL_OW 88
7628: GO 7652
// begin un := SciRu ;
7630: LD_ADDR_VAR 0 4
7634: PUSH
7635: CALL 12764 0 0
7639: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7640: LD_VAR 0 4
7644: PPUSH
7645: LD_STRING D3a-Sci1-1
7647: PPUSH
7648: CALL_OW 88
// end ; if Kirilenkova or un then
7652: LD_EXP 33
7656: PUSH
7657: LD_VAR 0 4
7661: OR
7662: IFFALSE 7676
// Say ( JMM , D3a-JMM-1 ) ;
7664: LD_EXP 15
7668: PPUSH
7669: LD_STRING D3a-JMM-1
7671: PPUSH
7672: CALL_OW 88
// DialogueOff ;
7676: CALL_OW 7
// end ;
7680: LD_VAR 0 1
7684: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7685: LD_EXP 4
7689: PUSH
7690: LD_INT 22
7692: PUSH
7693: LD_INT 7
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 25
7705: PUSH
7706: LD_INT 1
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 25
7715: PUSH
7716: LD_INT 2
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 25
7725: PUSH
7726: LD_INT 3
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 25
7735: PUSH
7736: LD_INT 4
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 25
7745: PUSH
7746: LD_INT 5
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PUSH
7753: LD_INT 25
7755: PUSH
7756: LD_INT 8
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 25
7765: PUSH
7766: LD_INT 9
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PPUSH
7787: CALL_OW 69
7791: PUSH
7792: LD_INT 7
7794: LESS
7795: AND
7796: IFFALSE 7808
7798: GO 7800
7800: DISABLE
// YouLost ( TooMany ) ;
7801: LD_STRING TooMany
7803: PPUSH
7804: CALL_OW 104
7808: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7809: LD_EXP 32
7813: PPUSH
7814: CALL_OW 255
7818: PUSH
7819: LD_INT 7
7821: EQUAL
7822: IFFALSE 8022
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
7831: PPUSH
// begin uc_side := 3 ;
7832: LD_ADDR_OWVAR 20
7836: PUSH
7837: LD_INT 3
7839: ST_TO_ADDR
// uc_nation := 3 ;
7840: LD_ADDR_OWVAR 21
7844: PUSH
7845: LD_INT 3
7847: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7848: LD_INT 21
7850: PPUSH
7851: LD_INT 3
7853: PPUSH
7854: LD_INT 3
7856: PPUSH
7857: LD_INT 42
7859: PPUSH
7860: LD_INT 100
7862: PPUSH
7863: CALL 19161 0 5
// un := CreateVehicle ;
7867: LD_ADDR_VAR 0 3
7871: PUSH
7872: CALL_OW 45
7876: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7877: LD_VAR 0 3
7881: PPUSH
7882: LD_INT 15
7884: PPUSH
7885: LD_INT 0
7887: PPUSH
7888: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7892: LD_VAR 0 3
7896: PPUSH
7897: LD_INT 67
7899: PPUSH
7900: LD_INT 45
7902: PPUSH
7903: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7907: LD_VAR 0 3
7911: PPUSH
7912: LD_INT 70
7914: PPUSH
7915: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7919: LD_VAR 0 3
7923: PPUSH
7924: LD_INT 69
7926: PPUSH
7927: LD_INT 18
7929: PPUSH
7930: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7934: LD_VAR 0 3
7938: PPUSH
7939: LD_INT 60
7941: PPUSH
7942: LD_INT 2
7944: PPUSH
7945: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7949: LD_INT 35
7951: PPUSH
7952: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7956: LD_VAR 0 3
7960: PPUSH
7961: CALL_OW 302
7965: NOT
7966: PUSH
7967: LD_VAR 0 3
7971: PPUSH
7972: LD_INT 17
7974: PPUSH
7975: CALL_OW 308
7979: OR
7980: IFFALSE 7949
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7982: LD_VAR 0 3
7986: PPUSH
7987: LD_INT 17
7989: PPUSH
7990: CALL_OW 308
7994: PUSH
7995: LD_VAR 0 3
7999: PPUSH
8000: LD_INT 60
8002: PPUSH
8003: LD_INT 2
8005: PPUSH
8006: CALL_OW 307
8010: OR
8011: IFFALSE 8022
// RemoveUnit ( un ) ;
8013: LD_VAR 0 3
8017: PPUSH
8018: CALL_OW 64
// end ;
8022: PPOPN 3
8024: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8025: LD_EXP 4
8029: IFFALSE 8271
8031: GO 8033
8033: DISABLE
8034: LD_INT 0
8036: PPUSH
8037: PPUSH
8038: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8039: LD_INT 70
8041: PPUSH
8042: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8046: LD_ADDR_VAR 0 3
8050: PUSH
8051: LD_INT 22
8053: PUSH
8054: LD_INT 7
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: LD_INT 101
8063: PUSH
8064: LD_INT 3
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PPUSH
8075: CALL_OW 69
8079: ST_TO_ADDR
// until tmp ;
8080: LD_VAR 0 3
8084: IFFALSE 8039
// un := NearestUnitToUnit ( tmp , JMM ) ;
8086: LD_ADDR_VAR 0 2
8090: PUSH
8091: LD_VAR 0 3
8095: PPUSH
8096: LD_EXP 15
8100: PPUSH
8101: CALL_OW 74
8105: ST_TO_ADDR
// player_spotted := true ;
8106: LD_ADDR_EXP 6
8110: PUSH
8111: LD_INT 1
8113: ST_TO_ADDR
// tmp := SciRu ;
8114: LD_ADDR_VAR 0 3
8118: PUSH
8119: CALL 12764 0 0
8123: ST_TO_ADDR
// if not tmp then
8124: LD_VAR 0 3
8128: NOT
8129: IFFALSE 8141
// tmp := SolRu ;
8131: LD_ADDR_VAR 0 3
8135: PUSH
8136: CALL 12911 0 0
8140: ST_TO_ADDR
// DialogueOn ;
8141: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8145: LD_VAR 0 2
8149: PPUSH
8150: CALL_OW 250
8154: PPUSH
8155: LD_VAR 0 2
8159: PPUSH
8160: CALL_OW 251
8164: PPUSH
8165: LD_INT 7
8167: PPUSH
8168: LD_INT 8
8170: NEG
8171: PPUSH
8172: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8176: LD_VAR 0 2
8180: PPUSH
8181: CALL_OW 87
// if tmp then
8185: LD_VAR 0 3
8189: IFFALSE 8203
// Say ( tmp , D4-RSci1-1 ) ;
8191: LD_VAR 0 3
8195: PPUSH
8196: LD_STRING D4-RSci1-1
8198: PPUSH
8199: CALL_OW 88
// if Gossudarov then
8203: LD_EXP 32
8207: IFFALSE 8233
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8209: LD_EXP 32
8213: PPUSH
8214: LD_STRING D4-Gos-1
8216: PPUSH
8217: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8221: LD_EXP 15
8225: PPUSH
8226: LD_STRING D4-JMM-1
8228: PPUSH
8229: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8233: LD_VAR 0 2
8237: PPUSH
8238: CALL_OW 250
8242: PPUSH
8243: LD_VAR 0 2
8247: PPUSH
8248: CALL_OW 251
8252: PPUSH
8253: LD_INT 7
8255: PPUSH
8256: CALL_OW 331
// DialogueOff ;
8260: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8264: LD_STRING M5
8266: PPUSH
8267: CALL_OW 337
// end ;
8271: PPOPN 3
8273: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8274: LD_EXP 6
8278: IFFALSE 8867
8280: GO 8282
8282: DISABLE
8283: LD_INT 0
8285: PPUSH
8286: PPUSH
8287: PPUSH
// begin PrepareBelkov ;
8288: CALL 2117 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8292: LD_EXP 47
8296: PPUSH
8297: LD_INT 118
8299: PPUSH
8300: LD_INT 106
8302: PPUSH
8303: CALL_OW 111
// AddComHold ( Belkov ) ;
8307: LD_EXP 47
8311: PPUSH
8312: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8316: LD_INT 35
8318: PPUSH
8319: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8323: LD_EXP 47
8327: PPUSH
8328: LD_INT 118
8330: PPUSH
8331: LD_INT 106
8333: PPUSH
8334: CALL_OW 307
8338: IFFALSE 8316
// ChangeSideFog ( 4 , 7 ) ;
8340: LD_INT 4
8342: PPUSH
8343: LD_INT 7
8345: PPUSH
8346: CALL_OW 343
// if IsOk ( Belkov ) then
8350: LD_EXP 47
8354: PPUSH
8355: CALL_OW 302
8359: IFFALSE 8443
// begin InGameOn ;
8361: CALL_OW 8
// DialogueOn ;
8365: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8369: LD_EXP 47
8373: PPUSH
8374: LD_STRING D5-Bel-1
8376: PPUSH
8377: CALL_OW 94
// if Gossudarov then
8381: LD_EXP 32
8385: IFFALSE 8435
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8387: LD_EXP 32
8391: PPUSH
8392: LD_STRING D5-Gos-1
8394: PPUSH
8395: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8399: LD_EXP 15
8403: PPUSH
8404: LD_STRING D5-JMM-1
8406: PPUSH
8407: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8411: LD_EXP 32
8415: PPUSH
8416: LD_STRING D5-Gos-2
8418: PPUSH
8419: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8423: LD_EXP 15
8427: PPUSH
8428: LD_STRING D5-JMM-2
8430: PPUSH
8431: CALL_OW 88
// end ; DialogueOff ;
8435: CALL_OW 7
// InGameOff ;
8439: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8443: LD_STRING QSaveBelkov
8445: PPUSH
8446: CALL_OW 97
8450: PUSH
8451: LD_INT 1
8453: DOUBLE
8454: EQUAL
8455: IFTRUE 8459
8457: GO 8509
8459: POP
// begin DialogueOn ;
8460: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8464: LD_EXP 15
8468: PPUSH
8469: LD_STRING D5a-JMM-1
8471: PPUSH
8472: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8476: LD_EXP 47
8480: PPUSH
8481: LD_STRING D5a-Bel-1
8483: PPUSH
8484: CALL_OW 94
// DialogueOff ;
8488: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8492: LD_EXP 47
8496: PPUSH
8497: LD_INT 83
8499: PPUSH
8500: LD_INT 49
8502: PPUSH
8503: CALL_OW 111
// end ; 2 :
8507: GO 8542
8509: LD_INT 2
8511: DOUBLE
8512: EQUAL
8513: IFTRUE 8517
8515: GO 8541
8517: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8518: LD_EXP 15
8522: PPUSH
8523: LD_STRING D5a-JMM-2
8525: PPUSH
8526: CALL_OW 88
// ComHold ( Belkov ) ;
8530: LD_EXP 47
8534: PPUSH
8535: CALL_OW 140
// end ; end ;
8539: GO 8542
8541: POP
// time := 0 0$00 ;
8542: LD_ADDR_VAR 0 1
8546: PUSH
8547: LD_INT 0
8549: ST_TO_ADDR
// vehSpawned := false ;
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 0
8557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8558: LD_INT 35
8560: PPUSH
8561: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8565: LD_VAR 0 1
8569: PUSH
8570: LD_INT 350
8572: PUSH
8573: LD_INT 175
8575: PUSH
8576: LD_INT 70
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_OWVAR 67
8588: ARRAY
8589: GREATEREQUAL
8590: PUSH
8591: LD_VAR 0 3
8595: NOT
8596: AND
8597: IFFALSE 8687
// begin vehSpawned := true ;
8599: LD_ADDR_VAR 0 3
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// uc_side := 3 ;
8607: LD_ADDR_OWVAR 20
8611: PUSH
8612: LD_INT 3
8614: ST_TO_ADDR
// uc_nation := 3 ;
8615: LD_ADDR_OWVAR 21
8619: PUSH
8620: LD_INT 3
8622: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8623: LD_INT 22
8625: PPUSH
8626: LD_INT 3
8628: PPUSH
8629: LD_INT 3
8631: PPUSH
8632: LD_INT 43
8634: PPUSH
8635: LD_INT 100
8637: PPUSH
8638: CALL 19161 0 5
// veh := CreateVehicle ;
8642: LD_ADDR_VAR 0 2
8646: PUSH
8647: CALL_OW 45
8651: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8652: LD_VAR 0 2
8656: PPUSH
8657: LD_INT 130
8659: PPUSH
8660: LD_INT 131
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8670: LD_VAR 0 2
8674: PPUSH
8675: LD_INT 100
8677: PPUSH
8678: LD_INT 82
8680: PPUSH
8681: CALL_OW 114
// end else
8685: GO 8701
// time := time + 0 0$1 ;
8687: LD_ADDR_VAR 0 1
8691: PUSH
8692: LD_VAR 0 1
8696: PUSH
8697: LD_INT 35
8699: PLUS
8700: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8701: LD_EXP 47
8705: PPUSH
8706: CALL_OW 301
8710: PUSH
8711: LD_EXP 47
8715: PPUSH
8716: CALL_OW 255
8720: PUSH
8721: LD_INT 4
8723: EQUAL
8724: AND
8725: PUSH
8726: LD_INT 22
8728: PUSH
8729: LD_INT 7
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PPUSH
8736: CALL_OW 69
8740: PPUSH
8741: LD_EXP 47
8745: PPUSH
8746: CALL_OW 74
8750: PPUSH
8751: LD_EXP 47
8755: PPUSH
8756: CALL_OW 296
8760: PUSH
8761: LD_INT 10
8763: LESS
8764: OR
8765: IFFALSE 8558
// if IsDead ( Belkov ) then
8767: LD_EXP 47
8771: PPUSH
8772: CALL_OW 301
8776: IFFALSE 8801
// begin CenterNowOnUnits ( Belkov ) ;
8778: LD_EXP 47
8782: PPUSH
8783: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8787: LD_EXP 15
8791: PPUSH
8792: LD_STRING D5a-JMM-2a
8794: PPUSH
8795: CALL_OW 88
// exit ;
8799: GO 8867
// end ; if See ( 7 , Belkov ) then
8801: LD_INT 7
8803: PPUSH
8804: LD_EXP 47
8808: PPUSH
8809: CALL_OW 292
8813: IFFALSE 8827
// SetSide ( Belkov , 7 ) ;
8815: LD_EXP 47
8819: PPUSH
8820: LD_INT 7
8822: PPUSH
8823: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8827: LD_INT 35
8829: PPUSH
8830: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8834: LD_EXP 47
8838: PPUSH
8839: LD_INT 66
8841: PPUSH
8842: LD_INT 45
8844: PPUSH
8845: CALL_OW 297
8849: PUSH
8850: LD_INT 30
8852: LESS
8853: IFFALSE 8827
// Say ( Belkov , D6-Bel-1 ) ;
8855: LD_EXP 47
8859: PPUSH
8860: LD_STRING D6-Bel-1
8862: PPUSH
8863: CALL_OW 88
// end ;
8867: PPOPN 3
8869: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8870: LD_EXP 47
8874: PPUSH
8875: CALL_OW 302
8879: PUSH
8880: LD_EXP 47
8884: PPUSH
8885: CALL_OW 504
8889: PUSH
8890: LD_INT 2
8892: PUSH
8893: LD_INT 34
8895: PUSH
8896: LD_INT 47
8898: PUSH
8899: EMPTY
8900: LIST
8901: LIST
8902: PUSH
8903: LD_INT 34
8905: PUSH
8906: LD_INT 45
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: LIST
8917: PPUSH
8918: CALL_OW 69
8922: IN
8923: AND
8924: IFFALSE 8941
8926: GO 8928
8928: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8929: LD_EXP 47
8933: PPUSH
8934: LD_STRING D7-Bel-1
8936: PPUSH
8937: CALL_OW 88
8941: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8942: LD_INT 22
8944: PUSH
8945: LD_INT 7
8947: PUSH
8948: EMPTY
8949: LIST
8950: LIST
8951: PUSH
8952: LD_INT 101
8954: PUSH
8955: LD_INT 2
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PPUSH
8966: CALL_OW 69
8970: PUSH
8971: LD_EXP 8
8975: NOT
8976: AND
8977: PUSH
8978: LD_EXP 46
8982: PPUSH
8983: CALL_OW 305
8987: NOT
8988: AND
8989: IFFALSE 9459
8991: GO 8993
8993: DISABLE
8994: LD_INT 0
8996: PPUSH
// begin ar_base_spotted := true ;
8997: LD_ADDR_EXP 8
9001: PUSH
9002: LD_INT 1
9004: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9005: LD_ADDR_VAR 0 1
9009: PUSH
9010: LD_INT 22
9012: PUSH
9013: LD_INT 2
9015: PUSH
9016: EMPTY
9017: LIST
9018: LIST
9019: PUSH
9020: LD_INT 21
9022: PUSH
9023: LD_INT 3
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PPUSH
9034: CALL_OW 69
9038: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9039: LD_ADDR_VAR 0 1
9043: PUSH
9044: LD_VAR 0 1
9048: PPUSH
9049: LD_EXP 15
9053: PPUSH
9054: CALL_OW 74
9058: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9059: LD_INT 7
9061: PPUSH
9062: LD_INT 3
9064: PPUSH
9065: CALL_OW 332
// DialogueOn ;
9069: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9073: LD_VAR 0 1
9077: PPUSH
9078: CALL_OW 250
9082: PPUSH
9083: LD_VAR 0 1
9087: PPUSH
9088: CALL_OW 251
9092: PPUSH
9093: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9097: LD_ADDR_VAR 0 1
9101: PUSH
9102: LD_INT 22
9104: PUSH
9105: LD_INT 7
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: LD_INT 23
9114: PUSH
9115: LD_INT 1
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 26
9124: PUSH
9125: LD_INT 1
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: LIST
9136: PPUSH
9137: CALL_OW 69
9141: PUSH
9142: LD_EXP 15
9146: PUSH
9147: LD_EXP 19
9151: PUSH
9152: LD_EXP 20
9156: PUSH
9157: LD_EXP 27
9161: PUSH
9162: LD_EXP 16
9166: PUSH
9167: LD_EXP 25
9171: PUSH
9172: LD_EXP 21
9176: PUSH
9177: LD_EXP 23
9181: PUSH
9182: EMPTY
9183: LIST
9184: LIST
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: LIST
9190: LIST
9191: DIFF
9192: ST_TO_ADDR
// if not tmp then
9193: LD_VAR 0 1
9197: NOT
9198: IFFALSE 9272
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9200: LD_ADDR_VAR 0 1
9204: PUSH
9205: LD_INT 22
9207: PUSH
9208: LD_INT 7
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PUSH
9215: LD_INT 23
9217: PUSH
9218: LD_INT 1
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: PUSH
9225: LD_INT 26
9227: PUSH
9228: LD_INT 2
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: LIST
9239: PPUSH
9240: CALL_OW 69
9244: PUSH
9245: LD_EXP 30
9249: PUSH
9250: LD_EXP 17
9254: PUSH
9255: LD_EXP 28
9259: PUSH
9260: LD_EXP 29
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: LIST
9269: LIST
9270: DIFF
9271: ST_TO_ADDR
// if tmp then
9272: LD_VAR 0 1
9276: IFFALSE 9347
// case GetSex ( tmp [ 1 ] ) of sex_male :
9278: LD_VAR 0 1
9282: PUSH
9283: LD_INT 1
9285: ARRAY
9286: PPUSH
9287: CALL_OW 258
9291: PUSH
9292: LD_INT 1
9294: DOUBLE
9295: EQUAL
9296: IFTRUE 9300
9298: GO 9319
9300: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9301: LD_VAR 0 1
9305: PUSH
9306: LD_INT 1
9308: ARRAY
9309: PPUSH
9310: LD_STRING D9-Sol1-1
9312: PPUSH
9313: CALL_OW 88
9317: GO 9347
9319: LD_INT 2
9321: DOUBLE
9322: EQUAL
9323: IFTRUE 9327
9325: GO 9346
9327: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9328: LD_VAR 0 1
9332: PUSH
9333: LD_INT 1
9335: ARRAY
9336: PPUSH
9337: LD_STRING D9-FSol1-1
9339: PPUSH
9340: CALL_OW 88
9344: GO 9347
9346: POP
// if Frank then
9347: LD_EXP 27
9351: IFFALSE 9455
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9353: LD_EXP 56
9357: PPUSH
9358: CALL_OW 250
9362: PPUSH
9363: LD_EXP 56
9367: PPUSH
9368: CALL_OW 251
9372: PPUSH
9373: LD_INT 7
9375: PPUSH
9376: LD_INT 8
9378: PPUSH
9379: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9392: LD_EXP 27
9396: PPUSH
9397: LD_STRING D9-Frank-1
9399: PPUSH
9400: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9404: LD_EXP 15
9408: PPUSH
9409: LD_STRING D9-JMM-1
9411: PPUSH
9412: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9416: LD_EXP 27
9420: PPUSH
9421: LD_STRING D9-Frank-2
9423: PPUSH
9424: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9428: LD_EXP 56
9432: PPUSH
9433: CALL_OW 250
9437: PPUSH
9438: LD_EXP 56
9442: PPUSH
9443: CALL_OW 251
9447: PPUSH
9448: LD_INT 7
9450: PPUSH
9451: CALL_OW 331
// end ; DialogueOff ;
9455: CALL_OW 7
// end ;
9459: PPOPN 1
9461: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9462: LD_EXP 7
9466: PUSH
9467: LD_OWVAR 1
9471: PUSH
9472: LD_INT 42000
9474: GREATEREQUAL
9475: OR
9476: IFFALSE 10503
9478: GO 9480
9480: DISABLE
9481: LD_INT 0
9483: PPUSH
9484: PPUSH
// begin selected_option := 1 ;
9485: LD_ADDR_VAR 0 2
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9493: LD_INT 10500
9495: PPUSH
9496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9500: LD_INT 35
9502: PPUSH
9503: CALL_OW 67
// until not ru_attackers ;
9507: LD_EXP 52
9511: NOT
9512: IFFALSE 9500
// PrepareBurlak ;
9514: CALL 2229 0 0
// repeat wait ( 0 0$2 ) ;
9518: LD_INT 70
9520: PPUSH
9521: CALL_OW 67
// until not HasTask ( Burlak ) ;
9525: LD_EXP 46
9529: PPUSH
9530: CALL_OW 314
9534: NOT
9535: IFFALSE 9518
// InGameOn ;
9537: CALL_OW 8
// DialogueOn ;
9541: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9545: LD_EXP 49
9549: PPUSH
9550: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9554: LD_EXP 46
9558: PPUSH
9559: LD_STRING D10-Bur-1
9561: PPUSH
9562: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9566: LD_EXP 47
9570: PUSH
9571: LD_EXP 47
9575: PPUSH
9576: CALL_OW 255
9580: PUSH
9581: LD_INT 7
9583: EQUAL
9584: AND
9585: IFFALSE 9599
// Say ( Belkov , D10-Bel-1 ) ;
9587: LD_EXP 47
9591: PPUSH
9592: LD_STRING D10-Bel-1
9594: PPUSH
9595: CALL_OW 88
// if Gossudarov then
9599: LD_EXP 32
9603: IFFALSE 9617
// Say ( Gossudarov , D10-Gos-1 ) ;
9605: LD_EXP 32
9609: PPUSH
9610: LD_STRING D10-Gos-1
9612: PPUSH
9613: CALL_OW 88
// if Kirilenkova then
9617: LD_EXP 33
9621: IFFALSE 9635
// Say ( Kirilenkova , D10-Kir-1 ) ;
9623: LD_EXP 33
9627: PPUSH
9628: LD_STRING D10-Kir-1
9630: PPUSH
9631: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9635: CALL 12911 0 0
9639: PPUSH
9640: LD_STRING D10-RSol1-1
9642: PPUSH
9643: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9647: LD_EXP 46
9651: PPUSH
9652: LD_STRING D10-Bur-2
9654: PPUSH
9655: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9659: LD_EXP 15
9663: PPUSH
9664: LD_STRING D10-JMM-2
9666: PPUSH
9667: CALL_OW 88
// if Kirilenkova then
9671: LD_EXP 33
9675: IFFALSE 9691
// Say ( Kirilenkova , D10-Kir-2 ) else
9677: LD_EXP 33
9681: PPUSH
9682: LD_STRING D10-Kir-2
9684: PPUSH
9685: CALL_OW 88
9689: GO 9703
// Say ( SolRu , D10-RSol1-2 ) ;
9691: CALL 12911 0 0
9695: PPUSH
9696: LD_STRING D10-RSol1-2
9698: PPUSH
9699: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9703: LD_EXP 15
9707: PPUSH
9708: LD_STRING D10-JMM-3
9710: PPUSH
9711: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9715: LD_EXP 46
9719: PPUSH
9720: LD_STRING D10-Bur-3
9722: PPUSH
9723: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9727: LD_EXP 15
9731: PPUSH
9732: LD_STRING D10-JMM-4
9734: PPUSH
9735: CALL_OW 88
// DialogueOff ;
9739: CALL_OW 7
// InGameOff ;
9743: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9747: LD_STRING M2
9749: PPUSH
9750: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9754: LD_INT 35
9756: PPUSH
9757: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9761: LD_INT 22
9763: PUSH
9764: LD_INT 7
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: LD_INT 91
9773: PUSH
9774: LD_EXP 46
9778: PUSH
9779: LD_INT 8
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: LIST
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: PPUSH
9791: CALL_OW 69
9795: IFFALSE 9754
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9797: LD_ADDR_VAR 0 1
9801: PUSH
9802: LD_INT 22
9804: PUSH
9805: LD_INT 4
9807: PUSH
9808: EMPTY
9809: LIST
9810: LIST
9811: PPUSH
9812: CALL_OW 69
9816: PUSH
9817: FOR_IN
9818: IFFALSE 9834
// SetSide ( i , 7 ) ;
9820: LD_VAR 0 1
9824: PPUSH
9825: LD_INT 7
9827: PPUSH
9828: CALL_OW 235
9832: GO 9817
9834: POP
9835: POP
// ChangeMissionObjectives ( M3 ) ;
9836: LD_STRING M3
9838: PPUSH
9839: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9843: LD_INT 35
9845: PPUSH
9846: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9850: LD_EXP 15
9854: PPUSH
9855: LD_EXP 46
9859: PPUSH
9860: CALL_OW 296
9864: PUSH
9865: LD_INT 8
9867: LESS
9868: IFFALSE 9843
// ComTurnUnit ( JMM , Burlak ) ;
9870: LD_EXP 15
9874: PPUSH
9875: LD_EXP 46
9879: PPUSH
9880: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9884: LD_EXP 46
9888: PPUSH
9889: LD_EXP 15
9893: PPUSH
9894: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9898: LD_INT 10
9900: PPUSH
9901: CALL_OW 67
// DialogueOn ;
9905: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9909: LD_EXP 15
9913: PPUSH
9914: LD_STRING D11-JMM-1
9916: PPUSH
9917: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9921: LD_EXP 46
9925: PPUSH
9926: LD_STRING D11-Bur-1
9928: PPUSH
9929: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9933: LD_EXP 15
9937: PPUSH
9938: LD_STRING D11-JMM-2
9940: PPUSH
9941: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9945: LD_EXP 46
9949: PPUSH
9950: LD_STRING D11-Bur-2
9952: PPUSH
9953: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9957: LD_EXP 15
9961: PPUSH
9962: LD_STRING D11-JMM-3
9964: PPUSH
9965: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9969: LD_EXP 46
9973: PPUSH
9974: LD_STRING D11-Bur-3
9976: PPUSH
9977: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9981: LD_EXP 15
9985: PPUSH
9986: LD_STRING D11-JMM-4
9988: PPUSH
9989: CALL_OW 88
// if ar_base_spotted then
9993: LD_EXP 8
9997: IFFALSE 10013
// Say ( Burlak , D12-Bur-1 ) else
9999: LD_EXP 46
10003: PPUSH
10004: LD_STRING D12-Bur-1
10006: PPUSH
10007: CALL_OW 88
10011: GO 10052
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10013: LD_INT 7
10015: PPUSH
10016: LD_INT 3
10018: PPUSH
10019: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10023: LD_INT 127
10025: PPUSH
10026: LD_INT 45
10028: PPUSH
10029: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10033: LD_EXP 46
10037: PPUSH
10038: LD_STRING D12-Bur-1a
10040: PPUSH
10041: CALL_OW 88
// dwait ( 0 0$2 ) ;
10045: LD_INT 70
10047: PPUSH
10048: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10052: LD_EXP 46
10056: PPUSH
10057: LD_STRING D12-Bur-1b
10059: PPUSH
10060: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10064: LD_EXP 15
10068: PPUSH
10069: LD_STRING D12-JMM-1
10071: PPUSH
10072: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10076: LD_EXP 46
10080: PPUSH
10081: LD_STRING D12-Bur-2
10083: PPUSH
10084: CALL_OW 88
// if Roth then
10088: LD_EXP 16
10092: IFFALSE 10108
// Say ( Roth , D12-Roth-2 ) else
10094: LD_EXP 16
10098: PPUSH
10099: LD_STRING D12-Roth-2
10101: PPUSH
10102: CALL_OW 88
10106: GO 10120
// Say ( SciRu , D12-RSci1-2 ) ;
10108: CALL 12764 0 0
10112: PPUSH
10113: LD_STRING D12-RSci1-2
10115: PPUSH
10116: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10120: LD_EXP 15
10124: PPUSH
10125: LD_STRING D12-JMM-2
10127: PPUSH
10128: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10132: LD_EXP 46
10136: PPUSH
10137: LD_STRING D12-Bur-3
10139: PPUSH
10140: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10144: LD_EXP 15
10148: PPUSH
10149: LD_STRING D12-JMM-3
10151: PPUSH
10152: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10156: LD_EXP 46
10160: PPUSH
10161: LD_STRING D12-Bur-4
10163: PPUSH
10164: CALL_OW 88
// case Query ( QBase ) of 1 :
10168: LD_STRING QBase
10170: PPUSH
10171: CALL_OW 97
10175: PUSH
10176: LD_INT 1
10178: DOUBLE
10179: EQUAL
10180: IFTRUE 10184
10182: GO 10302
10184: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10185: LD_EXP 15
10189: PPUSH
10190: LD_STRING D13a-JMM-1
10192: PPUSH
10193: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10197: LD_EXP 46
10201: PPUSH
10202: LD_STRING D13a-Bur-1
10204: PPUSH
10205: CALL_OW 88
// if Roth then
10209: LD_EXP 16
10213: IFFALSE 10229
// Say ( Roth , D13a-Roth-1 ) else
10215: LD_EXP 16
10219: PPUSH
10220: LD_STRING D13a-Roth-1
10222: PPUSH
10223: CALL_OW 88
10227: GO 10241
// Say ( SciRu , D13a-RSci1-1 ) ;
10229: CALL 12764 0 0
10233: PPUSH
10234: LD_STRING D13a-RSci1-1
10236: PPUSH
10237: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10241: LD_EXP 15
10245: PPUSH
10246: LD_STRING D13a-JMM-2
10248: PPUSH
10249: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10253: LD_STRING QBaseAgain
10255: PPUSH
10256: CALL_OW 97
10260: PUSH
10261: LD_INT 1
10263: DOUBLE
10264: EQUAL
10265: IFTRUE 10269
10267: GO 10280
10269: POP
// selected_option := 2 ; 2 :
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
10278: GO 10300
10280: LD_INT 2
10282: DOUBLE
10283: EQUAL
10284: IFTRUE 10288
10286: GO 10299
10288: POP
// selected_option := 3 ; end ;
10289: LD_ADDR_VAR 0 2
10293: PUSH
10294: LD_INT 3
10296: ST_TO_ADDR
10297: GO 10300
10299: POP
// end ; 2 :
10300: GO 10341
10302: LD_INT 2
10304: DOUBLE
10305: EQUAL
10306: IFTRUE 10310
10308: GO 10321
10310: POP
// selected_option := 2 ; 3 :
10311: LD_ADDR_VAR 0 2
10315: PUSH
10316: LD_INT 2
10318: ST_TO_ADDR
10319: GO 10341
10321: LD_INT 3
10323: DOUBLE
10324: EQUAL
10325: IFTRUE 10329
10327: GO 10340
10329: POP
// selected_option := 3 ; end ;
10330: LD_ADDR_VAR 0 2
10334: PUSH
10335: LD_INT 3
10337: ST_TO_ADDR
10338: GO 10341
10340: POP
// if selected_option = 2 then
10341: LD_VAR 0 2
10345: PUSH
10346: LD_INT 2
10348: EQUAL
10349: IFFALSE 10443
// begin Say ( JMM , D13b-JMM-1 ) ;
10351: LD_EXP 15
10355: PPUSH
10356: LD_STRING D13b-JMM-1
10358: PPUSH
10359: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10363: LD_EXP 46
10367: PPUSH
10368: LD_STRING D13b-Bur-1
10370: PPUSH
10371: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10375: LD_EXP 15
10379: PPUSH
10380: LD_STRING D13b-JMM-2
10382: PPUSH
10383: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10387: LD_EXP 55
10391: PPUSH
10392: LD_STRING D13b-Abd-2
10394: PPUSH
10395: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10399: LD_EXP 15
10403: PPUSH
10404: LD_STRING D13b-JMM-3
10406: PPUSH
10407: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10411: LD_EXP 55
10415: PPUSH
10416: LD_STRING D13b-Abd-3
10418: PPUSH
10419: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10423: LD_EXP 15
10427: PPUSH
10428: LD_STRING D13b-JMM-4
10430: PPUSH
10431: CALL_OW 88
// ar_active_attack := true ;
10435: LD_ADDR_EXP 9
10439: PUSH
10440: LD_INT 1
10442: ST_TO_ADDR
// end ; if selected_option = 3 then
10443: LD_VAR 0 2
10447: PUSH
10448: LD_INT 3
10450: EQUAL
10451: IFFALSE 10477
// begin Say ( JMM , D13c-JMM-1 ) ;
10453: LD_EXP 15
10457: PPUSH
10458: LD_STRING D13c-JMM-1
10460: PPUSH
10461: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10465: LD_EXP 46
10469: PPUSH
10470: LD_STRING D13c-Bur-1
10472: PPUSH
10473: CALL_OW 88
// end ; DialogueOff ;
10477: CALL_OW 7
// if not ar_active_attack then
10481: LD_EXP 9
10485: NOT
10486: IFFALSE 10503
// begin wait ( 6 6$00 ) ;
10488: LD_INT 12600
10490: PPUSH
10491: CALL_OW 67
// ar_active_attack := true ;
10495: LD_ADDR_EXP 9
10499: PUSH
10500: LD_INT 1
10502: ST_TO_ADDR
// end ; end ;
10503: PPOPN 2
10505: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10506: LD_EXP 46
10510: PPUSH
10511: CALL_OW 305
10515: PUSH
10516: LD_EXP 46
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: AND
10530: IFFALSE 10726
10532: GO 10534
10534: DISABLE
10535: LD_INT 0
10537: PPUSH
// begin wait ( 4 4$40 ) ;
10538: LD_INT 9800
10540: PPUSH
10541: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until not ru_attackers ;
10552: LD_EXP 52
10556: NOT
10557: IFFALSE 10545
// PrepareGnyevko ;
10559: CALL 2173 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10563: LD_EXP 48
10567: PPUSH
10568: LD_INT 124
10570: PPUSH
10571: LD_INT 118
10573: PPUSH
10574: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10578: LD_EXP 48
10582: PPUSH
10583: CALL_OW 200
// time := 0 0$00 ;
10587: LD_ADDR_VAR 0 1
10591: PUSH
10592: LD_INT 0
10594: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10595: LD_INT 35
10597: PPUSH
10598: CALL_OW 67
// time := time + 0 0$1 ;
10602: LD_ADDR_VAR 0 1
10606: PUSH
10607: LD_VAR 0 1
10611: PUSH
10612: LD_INT 35
10614: PLUS
10615: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10616: LD_EXP 48
10620: PPUSH
10621: LD_INT 124
10623: PPUSH
10624: LD_INT 118
10626: PPUSH
10627: CALL_OW 307
10631: PUSH
10632: LD_VAR 0 1
10636: PUSH
10637: LD_INT 1050
10639: GREATEREQUAL
10640: OR
10641: IFFALSE 10595
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10643: LD_EXP 48
10647: PPUSH
10648: LD_STRING DBelkov-Gny-1
10650: PPUSH
10651: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10655: LD_EXP 46
10659: PPUSH
10660: LD_STRING DBelkov-Bur-1a
10662: PPUSH
10663: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10667: LD_INT 35
10669: PPUSH
10670: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10674: LD_EXP 48
10678: PPUSH
10679: LD_INT 22
10681: PUSH
10682: LD_INT 7
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PPUSH
10689: CALL_OW 69
10693: PPUSH
10694: LD_EXP 48
10698: PPUSH
10699: CALL_OW 74
10703: PPUSH
10704: CALL_OW 296
10708: PUSH
10709: LD_INT 8
10711: LESS
10712: IFFALSE 10667
// SetSide ( Gnyevko , 7 ) ;
10714: LD_EXP 48
10718: PPUSH
10719: LD_INT 7
10721: PPUSH
10722: CALL_OW 235
// end ;
10726: PPOPN 1
10728: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10729: LD_EXP 46
10733: PPUSH
10734: CALL_OW 255
10738: PUSH
10739: LD_INT 7
10741: EQUAL
10742: IFFALSE 10752
10744: GO 10746
10746: DISABLE
// begin enable ;
10747: ENABLE
// PrepareAmericanAttack ;
10748: CALL 6568 0 0
// end ;
10752: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10753: LD_INT 22
10755: PUSH
10756: LD_INT 1
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: IFFALSE 10951
10769: GO 10771
10771: DISABLE
10772: LD_INT 0
10774: PPUSH
10775: PPUSH
// begin while true do
10776: LD_INT 1
10778: IFFALSE 10835
// begin wait ( 0 0$1 ) ;
10780: LD_INT 35
10782: PPUSH
10783: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10787: LD_ADDR_VAR 0 2
10791: PUSH
10792: LD_INT 22
10794: PUSH
10795: LD_INT 1
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: PPUSH
10802: CALL_OW 69
10806: PPUSH
10807: LD_EXP 15
10811: PPUSH
10812: CALL_OW 74
10816: ST_TO_ADDR
// if See ( 7 , tmp ) then
10817: LD_INT 7
10819: PPUSH
10820: LD_VAR 0 2
10824: PPUSH
10825: CALL_OW 292
10829: IFFALSE 10833
// break ;
10831: GO 10835
// end ;
10833: GO 10776
// DialogueOn ;
10835: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10839: LD_VAR 0 2
10843: PPUSH
10844: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10848: LD_VAR 0 2
10852: PPUSH
10853: CALL_OW 250
10857: PPUSH
10858: LD_VAR 0 2
10862: PPUSH
10863: CALL_OW 251
10867: PPUSH
10868: LD_INT 7
10870: PPUSH
10871: LD_INT 8
10873: PPUSH
10874: CALL_OW 330
// if Denis then
10878: LD_EXP 21
10882: IFFALSE 10896
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10884: LD_EXP 21
10888: PPUSH
10889: LD_STRING DAmerAttack-Pet-1
10891: PPUSH
10892: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10896: LD_EXP 15
10900: PPUSH
10901: LD_STRING DAmerAttack-JMM-1
10903: PPUSH
10904: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10908: LD_EXP 46
10912: PPUSH
10913: LD_STRING DStop-Bur-1
10915: PPUSH
10916: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10920: LD_VAR 0 2
10924: PPUSH
10925: CALL_OW 250
10929: PPUSH
10930: LD_VAR 0 2
10934: PPUSH
10935: CALL_OW 251
10939: PPUSH
10940: LD_INT 7
10942: PPUSH
10943: CALL_OW 331
// DialogueOff ;
10947: CALL_OW 7
// end ;
10951: PPOPN 2
10953: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10954: LD_INT 22
10956: PUSH
10957: LD_INT 3
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PUSH
10964: LD_INT 21
10966: PUSH
10967: LD_INT 1
10969: PUSH
10970: EMPTY
10971: LIST
10972: LIST
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PPUSH
10978: CALL_OW 69
10982: PUSH
10983: LD_INT 0
10985: EQUAL
10986: IFFALSE 11028
10988: GO 10990
10990: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10991: LD_STRING M5a
10993: PPUSH
10994: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10998: LD_EXP 15
11002: PPUSH
11003: LD_STRING D8-JMM-1
11005: PPUSH
11006: CALL_OW 88
// if Gossudarov then
11010: LD_EXP 32
11014: IFFALSE 11028
// Say ( Gossudarov , D8-Gos-1 ) ;
11016: LD_EXP 32
11020: PPUSH
11021: LD_STRING D8-Gos-1
11023: PPUSH
11024: CALL_OW 88
// end ;
11028: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11029: LD_INT 22
11031: PUSH
11032: LD_INT 2
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: PUSH
11039: LD_INT 21
11041: PUSH
11042: LD_INT 1
11044: PUSH
11045: EMPTY
11046: LIST
11047: LIST
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: PUSH
11058: LD_INT 0
11060: EQUAL
11061: IFFALSE 11111
11063: GO 11065
11065: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11066: LD_STRING M4c
11068: PPUSH
11069: CALL_OW 337
// if Roth then
11073: LD_EXP 16
11077: IFFALSE 11093
// Say ( Roth , DStop-Roth-1 ) else
11079: LD_EXP 16
11083: PPUSH
11084: LD_STRING DStop-Roth-1
11086: PPUSH
11087: CALL_OW 88
11091: GO 11111
// if Gossudarov then
11093: LD_EXP 32
11097: IFFALSE 11111
// Say ( Gossudarov , D8-Gos-1a ) ;
11099: LD_EXP 32
11103: PPUSH
11104: LD_STRING D8-Gos-1a
11106: PPUSH
11107: CALL_OW 88
// end ;
11111: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11112: LD_INT 7
11114: PPUSH
11115: LD_INT 1
11117: PPUSH
11118: LD_INT 1
11120: PPUSH
11121: CALL 14400 0 3
11125: PUSH
11126: LD_INT 0
11128: EQUAL
11129: PUSH
11130: LD_INT 7
11132: PPUSH
11133: LD_INT 3
11135: PPUSH
11136: LD_INT 1
11138: PPUSH
11139: CALL 14400 0 3
11143: PUSH
11144: LD_INT 0
11146: EQUAL
11147: AND
11148: IFFALSE 11160
11150: GO 11152
11152: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11153: LD_STRING M1a
11155: PPUSH
11156: CALL_OW 337
// end ;
11160: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11161: LD_INT 22
11163: PUSH
11164: LD_INT 2
11166: PUSH
11167: EMPTY
11168: LIST
11169: LIST
11170: PUSH
11171: LD_INT 21
11173: PUSH
11174: LD_INT 1
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PPUSH
11185: CALL_OW 69
11189: PUSH
11190: LD_INT 0
11192: EQUAL
11193: PUSH
11194: LD_INT 22
11196: PUSH
11197: LD_INT 3
11199: PUSH
11200: EMPTY
11201: LIST
11202: LIST
11203: PUSH
11204: LD_INT 21
11206: PUSH
11207: LD_INT 1
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PUSH
11214: EMPTY
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: PUSH
11223: LD_INT 0
11225: EQUAL
11226: AND
11227: PUSH
11228: LD_INT 22
11230: PUSH
11231: LD_INT 1
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PPUSH
11238: CALL_OW 69
11242: PUSH
11243: LD_INT 0
11245: EQUAL
11246: AND
11247: PUSH
11248: LD_INT 7
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: LD_INT 1
11256: PPUSH
11257: CALL 14400 0 3
11261: PUSH
11262: LD_INT 0
11264: EQUAL
11265: AND
11266: PUSH
11267: LD_INT 7
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 1
11275: PPUSH
11276: CALL 14400 0 3
11280: PUSH
11281: LD_INT 0
11283: EQUAL
11284: AND
11285: IFFALSE 12761
11287: GO 11289
11289: DISABLE
11290: LD_INT 0
11292: PPUSH
11293: PPUSH
11294: PPUSH
11295: PPUSH
11296: PPUSH
11297: PPUSH
// begin m1 := false ;
11298: LD_ADDR_VAR 0 4
11302: PUSH
11303: LD_INT 0
11305: ST_TO_ADDR
// m2 := false ;
11306: LD_ADDR_VAR 0 5
11310: PUSH
11311: LD_INT 0
11313: ST_TO_ADDR
// m3 := false ;
11314: LD_ADDR_VAR 0 6
11318: PUSH
11319: LD_INT 0
11321: ST_TO_ADDR
// if tick < 40 40$00 then
11322: LD_OWVAR 1
11326: PUSH
11327: LD_INT 84000
11329: LESS
11330: IFFALSE 11339
// SetAchievement ( ACH_ASPEED_17 ) ;
11332: LD_STRING ACH_ASPEED_17
11334: PPUSH
11335: CALL_OW 543
// wait ( 0 0$1 ) ;
11339: LD_INT 35
11341: PPUSH
11342: CALL_OW 67
// if not IsDead ( Masha ) then
11346: LD_EXP 49
11350: PPUSH
11351: CALL_OW 301
11355: NOT
11356: IFFALSE 11378
// begin m1 := true ;
11358: LD_ADDR_VAR 0 4
11362: PUSH
11363: LD_INT 1
11365: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11366: LD_STRING Masha
11368: PPUSH
11369: LD_INT 1
11371: PPUSH
11372: CALL_OW 101
// end else
11376: GO 11389
// AddMedal ( Masha , - 1 ) ;
11378: LD_STRING Masha
11380: PPUSH
11381: LD_INT 1
11383: NEG
11384: PPUSH
11385: CALL_OW 101
// if abdul_escaped then
11389: LD_EXP 12
11393: IFFALSE 11408
// AddMedal ( Abdul , - 1 ) else
11395: LD_STRING Abdul
11397: PPUSH
11398: LD_INT 1
11400: NEG
11401: PPUSH
11402: CALL_OW 101
11406: GO 11426
// begin m2 := true ;
11408: LD_ADDR_VAR 0 5
11412: PUSH
11413: LD_INT 1
11415: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11416: LD_STRING Abdul
11418: PPUSH
11419: LD_INT 1
11421: PPUSH
11422: CALL_OW 101
// end ; if loss_counter = 0 then
11426: LD_EXP 13
11430: PUSH
11431: LD_INT 0
11433: EQUAL
11434: IFFALSE 11456
// begin m3 := true ;
11436: LD_ADDR_VAR 0 6
11440: PUSH
11441: LD_INT 1
11443: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11444: LD_STRING People
11446: PPUSH
11447: LD_INT 2
11449: PPUSH
11450: CALL_OW 101
// end else
11454: GO 11514
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11456: LD_EXP 13
11460: PUSH
11461: LD_INT 3
11463: PUSH
11464: LD_INT 2
11466: PUSH
11467: LD_INT 2
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: LIST
11474: PUSH
11475: LD_OWVAR 67
11479: ARRAY
11480: LESSEQUAL
11481: IFFALSE 11503
// begin AddMedal ( People , 1 ) ;
11483: LD_STRING People
11485: PPUSH
11486: LD_INT 1
11488: PPUSH
11489: CALL_OW 101
// m3 := true ;
11493: LD_ADDR_VAR 0 6
11497: PUSH
11498: LD_INT 1
11500: ST_TO_ADDR
// end else
11501: GO 11514
// AddMedal ( People , - 1 ) ;
11503: LD_STRING People
11505: PPUSH
11506: LD_INT 1
11508: NEG
11509: PPUSH
11510: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11514: LD_OWVAR 67
11518: PUSH
11519: LD_INT 3
11521: EQUAL
11522: PUSH
11523: LD_VAR 0 4
11527: AND
11528: PUSH
11529: LD_VAR 0 5
11533: AND
11534: PUSH
11535: LD_VAR 0 6
11539: AND
11540: IFFALSE 11552
// SetAchievementEX ( ACH_AMER , 17 ) ;
11542: LD_STRING ACH_AMER
11544: PPUSH
11545: LD_INT 17
11547: PPUSH
11548: CALL_OW 564
// GiveMedals ( MAIN ) ;
11552: LD_STRING MAIN
11554: PPUSH
11555: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11559: LD_ADDR_VAR 0 2
11563: PUSH
11564: LD_INT 22
11566: PUSH
11567: LD_INT 7
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 2
11576: PUSH
11577: LD_INT 25
11579: PUSH
11580: LD_INT 1
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 25
11589: PUSH
11590: LD_INT 2
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 25
11599: PUSH
11600: LD_INT 3
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 25
11609: PUSH
11610: LD_INT 4
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: LD_INT 25
11619: PUSH
11620: LD_INT 5
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PUSH
11627: LD_INT 25
11629: PUSH
11630: LD_INT 8
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: PUSH
11637: LD_INT 25
11639: PUSH
11640: LD_INT 9
11642: PUSH
11643: EMPTY
11644: LIST
11645: LIST
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 69
11665: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11666: LD_VAR 0 2
11670: PPUSH
11671: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11675: LD_ADDR_VAR 0 3
11679: PUSH
11680: LD_EXP 15
11684: PUSH
11685: LD_EXP 16
11689: PUSH
11690: LD_EXP 17
11694: PUSH
11695: LD_EXP 18
11699: PUSH
11700: LD_EXP 19
11704: PUSH
11705: LD_EXP 20
11709: PUSH
11710: LD_EXP 21
11714: PUSH
11715: LD_EXP 22
11719: PUSH
11720: LD_EXP 23
11724: PUSH
11725: LD_EXP 24
11729: PUSH
11730: LD_EXP 25
11734: PUSH
11735: LD_EXP 26
11739: PUSH
11740: LD_EXP 27
11744: PUSH
11745: LD_EXP 28
11749: PUSH
11750: LD_EXP 29
11754: PUSH
11755: LD_EXP 30
11759: PUSH
11760: LD_EXP 31
11764: PUSH
11765: LD_EXP 32
11769: PUSH
11770: LD_EXP 33
11774: PUSH
11775: LD_EXP 34
11779: PUSH
11780: LD_EXP 36
11784: PUSH
11785: LD_EXP 37
11789: PUSH
11790: LD_EXP 38
11794: PUSH
11795: LD_EXP 39
11799: PUSH
11800: LD_EXP 40
11804: PUSH
11805: LD_EXP 41
11809: PUSH
11810: LD_EXP 42
11814: PUSH
11815: LD_EXP 43
11819: PUSH
11820: LD_EXP 44
11824: PUSH
11825: LD_EXP 45
11829: PUSH
11830: LD_EXP 46
11834: PUSH
11835: LD_EXP 47
11839: PUSH
11840: LD_EXP 48
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: ST_TO_ADDR
// if tmp diff tmp2 then
11880: LD_VAR 0 2
11884: PUSH
11885: LD_VAR 0 3
11889: DIFF
11890: IFFALSE 11910
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11892: LD_VAR 0 2
11896: PUSH
11897: LD_VAR 0 3
11901: DIFF
11902: PPUSH
11903: LD_STRING 13a_others
11905: PPUSH
11906: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11910: LD_EXP 15
11914: PPUSH
11915: LD_STRING 13a_JMM
11917: PPUSH
11918: CALL_OW 38
// if Titov then
11922: LD_EXP 34
11926: IFFALSE 11940
// SaveCharacters ( Titov , 13a_Titov ) ;
11928: LD_EXP 34
11932: PPUSH
11933: LD_STRING 13a_Titov
11935: PPUSH
11936: CALL_OW 38
// if Dolgov then
11940: LD_EXP 36
11944: IFFALSE 11958
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11946: LD_EXP 36
11950: PPUSH
11951: LD_STRING 13a_Dolgov
11953: PPUSH
11954: CALL_OW 38
// if Petrosyan then
11958: LD_EXP 37
11962: IFFALSE 11976
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11964: LD_EXP 37
11968: PPUSH
11969: LD_STRING 13a_Petrosyan
11971: PPUSH
11972: CALL_OW 38
// if Scholtze then
11976: LD_EXP 38
11980: IFFALSE 11994
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11982: LD_EXP 38
11986: PPUSH
11987: LD_STRING 13a_Scholtze
11989: PPUSH
11990: CALL_OW 38
// if Oblukov then
11994: LD_EXP 39
11998: IFFALSE 12012
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12000: LD_EXP 39
12004: PPUSH
12005: LD_STRING 13a_Oblukov
12007: PPUSH
12008: CALL_OW 38
// if Kapitsova then
12012: LD_EXP 40
12016: IFFALSE 12030
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12018: LD_EXP 40
12022: PPUSH
12023: LD_STRING 13a_Kapitsova
12025: PPUSH
12026: CALL_OW 38
// if Lipshchin then
12030: LD_EXP 41
12034: IFFALSE 12048
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12036: LD_EXP 41
12040: PPUSH
12041: LD_STRING 13a_Lipshchin
12043: PPUSH
12044: CALL_OW 38
// if Petrovova then
12048: LD_EXP 42
12052: IFFALSE 12066
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12054: LD_EXP 42
12058: PPUSH
12059: LD_STRING 13a_Petrovova
12061: PPUSH
12062: CALL_OW 38
// if Kovalyuk then
12066: LD_EXP 43
12070: IFFALSE 12084
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12072: LD_EXP 43
12076: PPUSH
12077: LD_STRING 13a_Kovalyuk
12079: PPUSH
12080: CALL_OW 38
// if Kuzmov then
12084: LD_EXP 44
12088: IFFALSE 12102
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12090: LD_EXP 44
12094: PPUSH
12095: LD_STRING 13a_Kuzmov
12097: PPUSH
12098: CALL_OW 38
// if Karamazov then
12102: LD_EXP 45
12106: IFFALSE 12120
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12108: LD_EXP 45
12112: PPUSH
12113: LD_STRING 13a_Karamazov
12115: PPUSH
12116: CALL_OW 38
// if Burlak then
12120: LD_EXP 46
12124: IFFALSE 12138
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12126: LD_EXP 46
12130: PPUSH
12131: LD_STRING 13a_Burlak
12133: PPUSH
12134: CALL_OW 38
// if Belkov then
12138: LD_EXP 47
12142: IFFALSE 12156
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12144: LD_EXP 47
12148: PPUSH
12149: LD_STRING 13a_Belkov
12151: PPUSH
12152: CALL_OW 38
// if Gnyevko then
12156: LD_EXP 48
12160: IFFALSE 12174
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12162: LD_EXP 48
12166: PPUSH
12167: LD_STRING 13a_Gnyevko
12169: PPUSH
12170: CALL_OW 38
// if Lisa then
12174: LD_EXP 17
12178: IFFALSE 12192
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12180: LD_EXP 17
12184: PPUSH
12185: LD_STRING 13a_Lisa
12187: PPUSH
12188: CALL_OW 38
// if Donaldson then
12192: LD_EXP 18
12196: IFFALSE 12210
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12198: LD_EXP 18
12202: PPUSH
12203: LD_STRING 13a_Donaldson
12205: PPUSH
12206: CALL_OW 38
// if Bobby then
12210: LD_EXP 19
12214: IFFALSE 12228
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12216: LD_EXP 19
12220: PPUSH
12221: LD_STRING 13a_Bobby
12223: PPUSH
12224: CALL_OW 38
// if Cyrus then
12228: LD_EXP 20
12232: IFFALSE 12246
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12234: LD_EXP 20
12238: PPUSH
12239: LD_STRING 13a_Cyrus
12241: PPUSH
12242: CALL_OW 38
// if Denis then
12246: LD_EXP 21
12250: IFFALSE 12264
// SaveCharacters ( Denis , 13a_Denis ) ;
12252: LD_EXP 21
12256: PPUSH
12257: LD_STRING 13a_Denis
12259: PPUSH
12260: CALL_OW 38
// if Brown then
12264: LD_EXP 22
12268: IFFALSE 12282
// SaveCharacters ( Brown , 13a_Brown ) ;
12270: LD_EXP 22
12274: PPUSH
12275: LD_STRING 13a_Brown
12277: PPUSH
12278: CALL_OW 38
// if Gladstone then
12282: LD_EXP 23
12286: IFFALSE 12300
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12288: LD_EXP 23
12292: PPUSH
12293: LD_STRING 13a_Gladstone
12295: PPUSH
12296: CALL_OW 38
// if Houten then
12300: LD_EXP 24
12304: IFFALSE 12318
// SaveCharacters ( Houten , 13a_Houten ) ;
12306: LD_EXP 24
12310: PPUSH
12311: LD_STRING 13a_Houten
12313: PPUSH
12314: CALL_OW 38
// if Cornel then
12318: LD_EXP 25
12322: IFFALSE 12336
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12324: LD_EXP 25
12328: PPUSH
12329: LD_STRING 13a_Cornel
12331: PPUSH
12332: CALL_OW 38
// if Gary then
12336: LD_EXP 26
12340: IFFALSE 12354
// SaveCharacters ( Gary , 13a_Gary ) ;
12342: LD_EXP 26
12346: PPUSH
12347: LD_STRING 13a_Gary
12349: PPUSH
12350: CALL_OW 38
// if Frank then
12354: LD_EXP 27
12358: IFFALSE 12372
// SaveCharacters ( Frank , 13a_Frank ) ;
12360: LD_EXP 27
12364: PPUSH
12365: LD_STRING 13a_Frank
12367: PPUSH
12368: CALL_OW 38
// if Kikuchi then
12372: LD_EXP 28
12376: IFFALSE 12390
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12378: LD_EXP 28
12382: PPUSH
12383: LD_STRING 13a_Kikuchi
12385: PPUSH
12386: CALL_OW 38
// if Simms then
12390: LD_EXP 29
12394: IFFALSE 12408
// SaveCharacters ( Simms , 13a_Simms ) ;
12396: LD_EXP 29
12400: PPUSH
12401: LD_STRING 13a_Simms
12403: PPUSH
12404: CALL_OW 38
// if Joan then
12408: LD_EXP 30
12412: IFFALSE 12426
// SaveCharacters ( Joan , 13a_Joan ) ;
12414: LD_EXP 30
12418: PPUSH
12419: LD_STRING 13a_Joan
12421: PPUSH
12422: CALL_OW 38
// if DeltaDoctor then
12426: LD_EXP 31
12430: IFFALSE 12444
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12432: LD_EXP 31
12436: PPUSH
12437: LD_STRING 13a_DeltaDoctor
12439: PPUSH
12440: CALL_OW 38
// if Gossudarov then
12444: LD_EXP 32
12448: IFFALSE 12462
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12450: LD_EXP 32
12454: PPUSH
12455: LD_STRING 13a_Gossudarov
12457: PPUSH
12458: CALL_OW 38
// if Kirilenkova then
12462: LD_EXP 33
12466: IFFALSE 12480
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12468: LD_EXP 33
12472: PPUSH
12473: LD_STRING 13a_Kirilenkova
12475: PPUSH
12476: CALL_OW 38
// if Roth then
12480: LD_EXP 16
12484: IFFALSE 12498
// SaveCharacters ( Roth , 13a_Roth ) ;
12486: LD_EXP 16
12490: PPUSH
12491: LD_STRING 13a_Roth
12493: PPUSH
12494: CALL_OW 38
// if Masha then
12498: LD_EXP 49
12502: IFFALSE 12557
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12504: LD_EXP 49
12508: PPUSH
12509: CALL_OW 265
12513: PUSH
12514: LD_EXP 49
12518: PPUSH
12519: CALL_OW 262
12523: PUSH
12524: LD_EXP 49
12528: PPUSH
12529: CALL_OW 263
12533: PUSH
12534: LD_EXP 49
12538: PPUSH
12539: CALL_OW 264
12543: PUSH
12544: EMPTY
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: PPUSH
12550: LD_STRING 13a_Masha
12552: PPUSH
12553: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12557: LD_ADDR_VAR 0 2
12561: PUSH
12562: LD_INT 21
12564: PUSH
12565: LD_INT 3
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: PPUSH
12572: CALL_OW 69
12576: ST_TO_ADDR
// tmp2 := [ ] ;
12577: LD_ADDR_VAR 0 3
12581: PUSH
12582: EMPTY
12583: ST_TO_ADDR
// if tmp then
12584: LD_VAR 0 2
12588: IFFALSE 12739
// for i in tmp do
12590: LD_ADDR_VAR 0 1
12594: PUSH
12595: LD_VAR 0 2
12599: PUSH
12600: FOR_IN
12601: IFFALSE 12737
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12603: LD_ADDR_VAR 0 3
12607: PUSH
12608: LD_VAR 0 3
12612: PUSH
12613: LD_VAR 0 1
12617: PPUSH
12618: CALL_OW 255
12622: PUSH
12623: LD_VAR 0 1
12627: PPUSH
12628: CALL_OW 248
12632: PUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 266
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: CALL_OW 250
12652: PUSH
12653: LD_VAR 0 1
12657: PPUSH
12658: CALL_OW 251
12662: PUSH
12663: LD_VAR 0 1
12667: PPUSH
12668: CALL_OW 254
12672: PUSH
12673: LD_VAR 0 1
12677: PPUSH
12678: CALL_OW 267
12682: PUSH
12683: LD_VAR 0 1
12687: PPUSH
12688: LD_INT 1
12690: PPUSH
12691: CALL_OW 268
12695: PUSH
12696: LD_VAR 0 1
12700: PPUSH
12701: LD_INT 2
12703: PPUSH
12704: CALL_OW 268
12708: PUSH
12709: LD_VAR 0 1
12713: PPUSH
12714: CALL_OW 269
12718: PUSH
12719: EMPTY
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: EMPTY
12732: LIST
12733: ADD
12734: ST_TO_ADDR
12735: GO 12600
12737: POP
12738: POP
// if tmp2 then
12739: LD_VAR 0 3
12743: IFFALSE 12757
// SaveVariable ( tmp2 , 13a_buildings ) ;
12745: LD_VAR 0 3
12749: PPUSH
12750: LD_STRING 13a_buildings
12752: PPUSH
12753: CALL_OW 39
// YouWin ;
12757: CALL_OW 103
// end ;
12761: PPOPN 6
12763: END
// export function SciRu ; var tmp , t ; begin
12764: LD_INT 0
12766: PPUSH
12767: PPUSH
12768: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12769: LD_ADDR_VAR 0 3
12773: PUSH
12774: LD_EXP 32
12778: PUSH
12779: LD_EXP 46
12783: PUSH
12784: LD_EXP 34
12788: PUSH
12789: LD_EXP 47
12793: PUSH
12794: LD_EXP 48
12798: PUSH
12799: LD_EXP 37
12803: PUSH
12804: LD_EXP 38
12808: PUSH
12809: LD_EXP 36
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12824: LD_ADDR_VAR 0 2
12828: PUSH
12829: LD_INT 22
12831: PUSH
12832: LD_INT 7
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 23
12841: PUSH
12842: LD_INT 3
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: PUSH
12849: LD_INT 25
12851: PUSH
12852: LD_INT 4
12854: PUSH
12855: EMPTY
12856: LIST
12857: LIST
12858: PUSH
12859: LD_INT 26
12861: PUSH
12862: LD_INT 1
12864: PUSH
12865: EMPTY
12866: LIST
12867: LIST
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PPUSH
12875: CALL_OW 69
12879: PUSH
12880: LD_VAR 0 3
12884: DIFF
12885: ST_TO_ADDR
// if tmp then
12886: LD_VAR 0 2
12890: IFFALSE 12906
// result := tmp [ 1 ] ;
12892: LD_ADDR_VAR 0 1
12896: PUSH
12897: LD_VAR 0 2
12901: PUSH
12902: LD_INT 1
12904: ARRAY
12905: ST_TO_ADDR
// end ;
12906: LD_VAR 0 1
12910: RET
// export function SolRu ; var tmp , t ; begin
12911: LD_INT 0
12913: PPUSH
12914: PPUSH
12915: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12916: LD_ADDR_VAR 0 3
12920: PUSH
12921: LD_EXP 32
12925: PUSH
12926: LD_EXP 46
12930: PUSH
12931: LD_EXP 34
12935: PUSH
12936: LD_EXP 47
12940: PUSH
12941: LD_EXP 48
12945: PUSH
12946: LD_EXP 37
12950: PUSH
12951: LD_EXP 38
12955: PUSH
12956: LD_EXP 36
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12971: LD_ADDR_VAR 0 2
12975: PUSH
12976: LD_INT 22
12978: PUSH
12979: LD_INT 7
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: LD_INT 23
12988: PUSH
12989: LD_INT 3
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: LD_INT 25
12998: PUSH
12999: LD_INT 1
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: LD_INT 26
13008: PUSH
13009: LD_INT 1
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: PPUSH
13022: CALL_OW 69
13026: PUSH
13027: LD_VAR 0 3
13031: DIFF
13032: ST_TO_ADDR
// if tmp then
13033: LD_VAR 0 2
13037: IFFALSE 13053
// result := tmp [ 1 ] ;
13039: LD_ADDR_VAR 0 1
13043: PUSH
13044: LD_VAR 0 2
13048: PUSH
13049: LD_INT 1
13051: ARRAY
13052: ST_TO_ADDR
// end ; end_of_file
13053: LD_VAR 0 1
13057: RET
// export function CustomEvent ( event ) ; begin
13058: LD_INT 0
13060: PPUSH
// end ;
13061: LD_VAR 0 2
13065: RET
// on UnitDestroyed ( un ) do var i , side ;
13066: LD_INT 0
13068: PPUSH
13069: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13070: LD_VAR 0 1
13074: PUSH
13075: LD_INT 22
13077: PUSH
13078: LD_INT 7
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 2
13087: PUSH
13088: LD_INT 25
13090: PUSH
13091: LD_INT 1
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: LD_INT 25
13100: PUSH
13101: LD_INT 2
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 25
13110: PUSH
13111: LD_INT 3
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 25
13120: PUSH
13121: LD_INT 4
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 25
13130: PUSH
13131: LD_INT 5
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 25
13140: PUSH
13141: LD_INT 8
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: LD_INT 25
13150: PUSH
13151: LD_INT 9
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: PUSH
13158: EMPTY
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PPUSH
13172: CALL_OW 69
13176: IN
13177: IFFALSE 13193
// loss_counter := loss_counter + 1 ;
13179: LD_ADDR_EXP 13
13183: PUSH
13184: LD_EXP 13
13188: PUSH
13189: LD_INT 1
13191: PLUS
13192: ST_TO_ADDR
// if un = Abdul then
13193: LD_VAR 0 1
13197: PUSH
13198: LD_EXP 55
13202: EQUAL
13203: IFFALSE 13213
// abdul_escaped := false ;
13205: LD_ADDR_EXP 12
13209: PUSH
13210: LD_INT 0
13212: ST_TO_ADDR
// if un in ru_attackers then
13213: LD_VAR 0 1
13217: PUSH
13218: LD_EXP 52
13222: IN
13223: IFFALSE 13241
// ru_attackers := ru_attackers diff un ;
13225: LD_ADDR_EXP 52
13229: PUSH
13230: LD_EXP 52
13234: PUSH
13235: LD_VAR 0 1
13239: DIFF
13240: ST_TO_ADDR
// if un in ar_attackers then
13241: LD_VAR 0 1
13245: PUSH
13246: LD_EXP 10
13250: IN
13251: IFFALSE 13269
// ar_attackers := ar_attackers diff un ;
13253: LD_ADDR_EXP 10
13257: PUSH
13258: LD_EXP 10
13262: PUSH
13263: LD_VAR 0 1
13267: DIFF
13268: ST_TO_ADDR
// if un = JMM then
13269: LD_VAR 0 1
13273: PUSH
13274: LD_EXP 15
13278: EQUAL
13279: IFFALSE 13290
// begin YouLost ( JMM ) ;
13281: LD_STRING JMM
13283: PPUSH
13284: CALL_OW 104
// exit ;
13288: GO 13379
// end ; if un = Burlak then
13290: LD_VAR 0 1
13294: PUSH
13295: LD_EXP 46
13299: EQUAL
13300: IFFALSE 13311
// begin YouLost ( Burlak ) ;
13302: LD_STRING Burlak
13304: PPUSH
13305: CALL_OW 104
// exit ;
13309: GO 13379
// end ; if un = freedom then
13311: LD_VAR 0 1
13315: PUSH
13316: LD_EXP 3
13320: EQUAL
13321: IFFALSE 13332
// begin YouLost ( Destroyed ) ;
13323: LD_STRING Destroyed
13325: PPUSH
13326: CALL_OW 104
// exit ;
13330: GO 13379
// end ; if un = Masha then
13332: LD_VAR 0 1
13336: PUSH
13337: LD_EXP 49
13341: EQUAL
13342: IFFALSE 13351
// ChangeMissionObjectives ( M4b ) ;
13344: LD_STRING M4b
13346: PPUSH
13347: CALL_OW 337
// if un = Mastodont then
13351: LD_VAR 0 1
13355: PUSH
13356: LD_EXP 56
13360: EQUAL
13361: IFFALSE 13370
// ChangeMissionObjectives ( M4a ) ;
13363: LD_STRING M4a
13365: PPUSH
13366: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13370: LD_VAR 0 1
13374: PPUSH
13375: CALL 79152 0 1
// end ;
13379: PPOPN 3
13381: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13382: LD_VAR 0 1
13386: PPUSH
13387: LD_VAR 0 2
13391: PPUSH
13392: CALL 81486 0 2
// end ;
13396: PPOPN 2
13398: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13399: LD_VAR 0 1
13403: PPUSH
13404: CALL 80554 0 1
// end ;
13408: PPOPN 1
13410: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13411: LD_VAR 0 1
13415: PUSH
13416: LD_INT 22
13418: PUSH
13419: LD_INT 7
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: LD_INT 30
13428: PUSH
13429: LD_INT 0
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PPUSH
13440: CALL_OW 69
13444: IN
13445: IFFALSE 13484
// begin SetBName ( building , freedom ) ;
13447: LD_VAR 0 1
13451: PPUSH
13452: LD_STRING freedom
13454: PPUSH
13455: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13459: LD_INT 0
13461: PPUSH
13462: LD_INT 7
13464: PPUSH
13465: LD_INT 0
13467: PPUSH
13468: CALL_OW 324
// freedom := building ;
13472: LD_ADDR_EXP 3
13476: PUSH
13477: LD_VAR 0 1
13481: ST_TO_ADDR
// exit ;
13482: GO 13550
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13484: LD_VAR 0 1
13488: PUSH
13489: LD_INT 22
13491: PUSH
13492: LD_INT 7
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: LD_INT 23
13501: PUSH
13502: LD_INT 3
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PUSH
13509: LD_INT 30
13511: PUSH
13512: LD_INT 6
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 69
13528: IN
13529: IFFALSE 13541
// begin ru_lab_builded := true ;
13531: LD_ADDR_EXP 5
13535: PUSH
13536: LD_INT 1
13538: ST_TO_ADDR
// exit ;
13539: GO 13550
// end ; MCE_BuildingComplete ( building ) ;
13541: LD_VAR 0 1
13545: PPUSH
13546: CALL 80795 0 1
// end ;
13550: PPOPN 1
13552: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13553: LD_VAR 0 1
13557: PPUSH
13558: LD_VAR 0 2
13562: PPUSH
13563: CALL 78848 0 2
// end ;
13567: PPOPN 2
13569: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13570: LD_VAR 0 1
13574: PPUSH
13575: LD_VAR 0 2
13579: PPUSH
13580: LD_VAR 0 3
13584: PPUSH
13585: LD_VAR 0 4
13589: PPUSH
13590: LD_VAR 0 5
13594: PPUSH
13595: CALL 78468 0 5
// end ;
13599: PPOPN 5
13601: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: CALL 78058 0 2
// end ;
13616: PPOPN 2
13618: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13619: LD_VAR 0 1
13623: PPUSH
13624: CALL_OW 263
13628: PUSH
13629: LD_INT 3
13631: EQUAL
13632: PUSH
13633: LD_VAR 0 2
13637: PPUSH
13638: CALL_OW 263
13642: PUSH
13643: LD_INT 3
13645: EQUAL
13646: OR
13647: IFFALSE 13663
// hack_counter := hack_counter + 1 ;
13649: LD_ADDR_EXP 14
13653: PUSH
13654: LD_EXP 14
13658: PUSH
13659: LD_INT 1
13661: PLUS
13662: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13663: LD_VAR 0 1
13667: PPUSH
13668: LD_VAR 0 2
13672: PPUSH
13673: LD_VAR 0 3
13677: PPUSH
13678: LD_VAR 0 4
13682: PPUSH
13683: CALL 77896 0 4
// end ;
13687: PPOPN 4
13689: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13690: LD_VAR 0 1
13694: PPUSH
13695: LD_VAR 0 2
13699: PPUSH
13700: LD_VAR 0 3
13704: PPUSH
13705: CALL 77671 0 3
// end ;
13709: PPOPN 3
13711: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13712: LD_VAR 0 1
13716: PPUSH
13717: LD_VAR 0 2
13721: PPUSH
13722: CALL 77556 0 2
// end ;
13726: PPOPN 2
13728: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13729: LD_VAR 0 1
13733: PPUSH
13734: LD_VAR 0 2
13738: PPUSH
13739: CALL 81747 0 2
// end ;
13743: PPOPN 2
13745: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13746: LD_VAR 0 1
13750: PPUSH
13751: LD_VAR 0 2
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: LD_VAR 0 4
13765: PPUSH
13766: CALL 81963 0 4
// end ;
13770: PPOPN 4
13772: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13773: LD_VAR 0 1
13777: PPUSH
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL 77365 0 2
// end ;
13787: PPOPN 2
13789: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13790: LD_VAR 0 1
13794: PPUSH
13795: CALL 95521 0 1
// end ; end_of_file
13799: PPOPN 1
13801: END
// every 0 0$30 do var cr , time ;
13802: GO 13804
13804: DISABLE
13805: LD_INT 0
13807: PPUSH
13808: PPUSH
// begin time := 0 0$30 ;
13809: LD_ADDR_VAR 0 2
13813: PUSH
13814: LD_INT 1050
13816: ST_TO_ADDR
// while game do
13817: LD_EXP 2
13821: IFFALSE 13920
// begin wait ( time ) ;
13823: LD_VAR 0 2
13827: PPUSH
13828: CALL_OW 67
// if tick > 2 2$00 then
13832: LD_OWVAR 1
13836: PUSH
13837: LD_INT 4200
13839: GREATER
13840: IFFALSE 13873
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13842: LD_ADDR_VAR 0 2
13846: PUSH
13847: LD_VAR 0 2
13851: PUSH
13852: LD_INT 280
13854: PUSH
13855: LD_INT 420
13857: PUSH
13858: LD_INT 630
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: LIST
13865: PUSH
13866: LD_OWVAR 67
13870: ARRAY
13871: PLUS
13872: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13873: LD_INT 1
13875: PPUSH
13876: LD_INT 5
13878: PPUSH
13879: CALL_OW 12
13883: PPUSH
13884: LD_INT 70
13886: PPUSH
13887: LD_INT 49
13889: PPUSH
13890: LD_INT 25
13892: PPUSH
13893: LD_INT 1
13895: PPUSH
13896: CALL_OW 56
// if time > 5 5$00 then
13900: LD_VAR 0 2
13904: PUSH
13905: LD_INT 10500
13907: GREATER
13908: IFFALSE 13918
// time := 0 0$30 ;
13910: LD_ADDR_VAR 0 2
13914: PUSH
13915: LD_INT 1050
13917: ST_TO_ADDR
// end ;
13918: GO 13817
// end ;
13920: PPOPN 2
13922: END
// every 0 0$30 do var cr , time ;
13923: GO 13925
13925: DISABLE
13926: LD_INT 0
13928: PPUSH
13929: PPUSH
// begin time := 0 0$20 ;
13930: LD_ADDR_VAR 0 2
13934: PUSH
13935: LD_INT 700
13937: ST_TO_ADDR
// while game do
13938: LD_EXP 2
13942: IFFALSE 14031
// begin wait ( time ) ;
13944: LD_VAR 0 2
13948: PPUSH
13949: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_VAR 0 2
13962: PUSH
13963: LD_INT 490
13965: PUSH
13966: LD_INT 525
13968: PUSH
13969: LD_INT 560
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: LIST
13976: PUSH
13977: LD_OWVAR 67
13981: ARRAY
13982: PLUS
13983: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13984: LD_INT 3
13986: PPUSH
13987: LD_INT 5
13989: PPUSH
13990: CALL_OW 12
13994: PPUSH
13995: LD_INT 26
13997: PPUSH
13998: LD_INT 9
14000: PPUSH
14001: LD_INT 30
14003: PPUSH
14004: LD_INT 1
14006: PPUSH
14007: CALL_OW 56
// if time > 3 3$00 then
14011: LD_VAR 0 2
14015: PUSH
14016: LD_INT 6300
14018: GREATER
14019: IFFALSE 14029
// time := 0 0$20 ;
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 700
14028: ST_TO_ADDR
// end ;
14029: GO 13938
// end ;
14031: PPOPN 2
14033: END
// every 0 0$30 do var cr , time ;
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
14040: PPUSH
// begin time := 0 0$20 ;
14041: LD_ADDR_VAR 0 2
14045: PUSH
14046: LD_INT 700
14048: ST_TO_ADDR
// while game do
14049: LD_EXP 2
14053: IFFALSE 14178
// begin wait ( time ) ;
14055: LD_VAR 0 2
14059: PPUSH
14060: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14064: LD_ADDR_VAR 0 2
14068: PUSH
14069: LD_VAR 0 2
14073: PUSH
14074: LD_INT 175
14076: PUSH
14077: LD_INT 210
14079: PUSH
14080: LD_INT 280
14082: PUSH
14083: EMPTY
14084: LIST
14085: LIST
14086: LIST
14087: PUSH
14088: LD_OWVAR 67
14092: ARRAY
14093: PLUS
14094: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14095: LD_INT 1
14097: PPUSH
14098: LD_INT 5
14100: PPUSH
14101: CALL_OW 12
14105: PPUSH
14106: LD_INT 179
14108: PPUSH
14109: LD_INT 101
14111: PPUSH
14112: LD_INT 20
14114: PPUSH
14115: LD_INT 1
14117: PPUSH
14118: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14122: LD_INT 350
14124: PPUSH
14125: LD_INT 525
14127: PPUSH
14128: CALL_OW 12
14132: PPUSH
14133: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14137: LD_INT 1
14139: PPUSH
14140: LD_INT 5
14142: PPUSH
14143: CALL_OW 12
14147: PPUSH
14148: LD_INT 9
14150: PPUSH
14151: LD_INT 1
14153: PPUSH
14154: CALL_OW 55
// if time > 4 4$00 then
14158: LD_VAR 0 2
14162: PUSH
14163: LD_INT 8400
14165: GREATER
14166: IFFALSE 14176
// time := 0 0$30 ;
14168: LD_ADDR_VAR 0 2
14172: PUSH
14173: LD_INT 1050
14175: ST_TO_ADDR
// end ;
14176: GO 14049
// end ;
14178: PPOPN 2
14180: END
// every 0 0$30 do var cr , time ;
14181: GO 14183
14183: DISABLE
14184: LD_INT 0
14186: PPUSH
14187: PPUSH
// begin time := 0 0$10 ;
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: LD_INT 350
14195: ST_TO_ADDR
// while game do
14196: LD_EXP 2
14200: IFFALSE 14334
// begin wait ( time ) ;
14202: LD_VAR 0 2
14206: PPUSH
14207: CALL_OW 67
// time := time + 0 0$10 ;
14211: LD_ADDR_VAR 0 2
14215: PUSH
14216: LD_VAR 0 2
14220: PUSH
14221: LD_INT 350
14223: PLUS
14224: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14225: LD_INT 1
14227: PPUSH
14228: LD_INT 5
14230: PPUSH
14231: CALL_OW 12
14235: PPUSH
14236: LD_INT 11
14238: PPUSH
14239: LD_INT 1
14241: PPUSH
14242: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14246: LD_ADDR_VAR 0 1
14250: PUSH
14251: LD_INT 1
14253: PPUSH
14254: LD_INT 3
14256: PPUSH
14257: CALL_OW 12
14261: ST_TO_ADDR
// if cr = 1 then
14262: LD_VAR 0 1
14266: PUSH
14267: LD_INT 1
14269: EQUAL
14270: IFFALSE 14314
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14272: LD_INT 700
14274: PPUSH
14275: LD_INT 1575
14277: PPUSH
14278: CALL_OW 12
14282: PPUSH
14283: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14287: LD_INT 1
14289: PPUSH
14290: LD_INT 5
14292: PPUSH
14293: CALL_OW 12
14297: PPUSH
14298: LD_INT 34
14300: PPUSH
14301: LD_INT 50
14303: PPUSH
14304: LD_INT 7
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 56
// end ; if time > 8 8$00 then
14314: LD_VAR 0 2
14318: PUSH
14319: LD_INT 16800
14321: GREATER
14322: IFFALSE 14332
// time := 0 0$40 ;
14324: LD_ADDR_VAR 0 2
14328: PUSH
14329: LD_INT 1400
14331: ST_TO_ADDR
// end ;
14332: GO 14196
// end ; end_of_file
14334: PPOPN 2
14336: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14337: LD_INT 0
14339: PPUSH
14340: PPUSH
// if exist_mode then
14341: LD_VAR 0 2
14345: IFFALSE 14370
// unit := CreateCharacter ( prefix & ident ) else
14347: LD_ADDR_VAR 0 5
14351: PUSH
14352: LD_VAR 0 3
14356: PUSH
14357: LD_VAR 0 1
14361: STR
14362: PPUSH
14363: CALL_OW 34
14367: ST_TO_ADDR
14368: GO 14385
// unit := NewCharacter ( ident ) ;
14370: LD_ADDR_VAR 0 5
14374: PUSH
14375: LD_VAR 0 1
14379: PPUSH
14380: CALL_OW 25
14384: ST_TO_ADDR
// result := unit ;
14385: LD_ADDR_VAR 0 4
14389: PUSH
14390: LD_VAR 0 5
14394: ST_TO_ADDR
// end ;
14395: LD_VAR 0 4
14399: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14400: LD_INT 0
14402: PPUSH
14403: PPUSH
// if not side or not nation then
14404: LD_VAR 0 1
14408: NOT
14409: PUSH
14410: LD_VAR 0 2
14414: NOT
14415: OR
14416: IFFALSE 14420
// exit ;
14418: GO 15184
// case nation of nation_american :
14420: LD_VAR 0 2
14424: PUSH
14425: LD_INT 1
14427: DOUBLE
14428: EQUAL
14429: IFTRUE 14433
14431: GO 14647
14433: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14434: LD_ADDR_VAR 0 4
14438: PUSH
14439: LD_INT 35
14441: PUSH
14442: LD_INT 45
14444: PUSH
14445: LD_INT 46
14447: PUSH
14448: LD_INT 47
14450: PUSH
14451: LD_INT 82
14453: PUSH
14454: LD_INT 83
14456: PUSH
14457: LD_INT 84
14459: PUSH
14460: LD_INT 85
14462: PUSH
14463: LD_INT 86
14465: PUSH
14466: LD_INT 1
14468: PUSH
14469: LD_INT 2
14471: PUSH
14472: LD_INT 6
14474: PUSH
14475: LD_INT 15
14477: PUSH
14478: LD_INT 16
14480: PUSH
14481: LD_INT 7
14483: PUSH
14484: LD_INT 12
14486: PUSH
14487: LD_INT 13
14489: PUSH
14490: LD_INT 10
14492: PUSH
14493: LD_INT 14
14495: PUSH
14496: LD_INT 20
14498: PUSH
14499: LD_INT 21
14501: PUSH
14502: LD_INT 22
14504: PUSH
14505: LD_INT 25
14507: PUSH
14508: LD_INT 32
14510: PUSH
14511: LD_INT 27
14513: PUSH
14514: LD_INT 36
14516: PUSH
14517: LD_INT 69
14519: PUSH
14520: LD_INT 39
14522: PUSH
14523: LD_INT 34
14525: PUSH
14526: LD_INT 40
14528: PUSH
14529: LD_INT 48
14531: PUSH
14532: LD_INT 49
14534: PUSH
14535: LD_INT 50
14537: PUSH
14538: LD_INT 51
14540: PUSH
14541: LD_INT 52
14543: PUSH
14544: LD_INT 53
14546: PUSH
14547: LD_INT 54
14549: PUSH
14550: LD_INT 55
14552: PUSH
14553: LD_INT 56
14555: PUSH
14556: LD_INT 57
14558: PUSH
14559: LD_INT 58
14561: PUSH
14562: LD_INT 59
14564: PUSH
14565: LD_INT 60
14567: PUSH
14568: LD_INT 61
14570: PUSH
14571: LD_INT 62
14573: PUSH
14574: LD_INT 80
14576: PUSH
14577: LD_INT 82
14579: PUSH
14580: LD_INT 83
14582: PUSH
14583: LD_INT 84
14585: PUSH
14586: LD_INT 85
14588: PUSH
14589: LD_INT 86
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: ST_TO_ADDR
14645: GO 15108
14647: LD_INT 2
14649: DOUBLE
14650: EQUAL
14651: IFTRUE 14655
14653: GO 14877
14655: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14656: LD_ADDR_VAR 0 4
14660: PUSH
14661: LD_INT 35
14663: PUSH
14664: LD_INT 45
14666: PUSH
14667: LD_INT 46
14669: PUSH
14670: LD_INT 47
14672: PUSH
14673: LD_INT 82
14675: PUSH
14676: LD_INT 83
14678: PUSH
14679: LD_INT 84
14681: PUSH
14682: LD_INT 85
14684: PUSH
14685: LD_INT 87
14687: PUSH
14688: LD_INT 70
14690: PUSH
14691: LD_INT 1
14693: PUSH
14694: LD_INT 11
14696: PUSH
14697: LD_INT 3
14699: PUSH
14700: LD_INT 4
14702: PUSH
14703: LD_INT 5
14705: PUSH
14706: LD_INT 6
14708: PUSH
14709: LD_INT 15
14711: PUSH
14712: LD_INT 18
14714: PUSH
14715: LD_INT 7
14717: PUSH
14718: LD_INT 17
14720: PUSH
14721: LD_INT 8
14723: PUSH
14724: LD_INT 20
14726: PUSH
14727: LD_INT 21
14729: PUSH
14730: LD_INT 22
14732: PUSH
14733: LD_INT 72
14735: PUSH
14736: LD_INT 26
14738: PUSH
14739: LD_INT 69
14741: PUSH
14742: LD_INT 39
14744: PUSH
14745: LD_INT 40
14747: PUSH
14748: LD_INT 41
14750: PUSH
14751: LD_INT 42
14753: PUSH
14754: LD_INT 43
14756: PUSH
14757: LD_INT 48
14759: PUSH
14760: LD_INT 49
14762: PUSH
14763: LD_INT 50
14765: PUSH
14766: LD_INT 51
14768: PUSH
14769: LD_INT 52
14771: PUSH
14772: LD_INT 53
14774: PUSH
14775: LD_INT 54
14777: PUSH
14778: LD_INT 55
14780: PUSH
14781: LD_INT 56
14783: PUSH
14784: LD_INT 60
14786: PUSH
14787: LD_INT 61
14789: PUSH
14790: LD_INT 62
14792: PUSH
14793: LD_INT 66
14795: PUSH
14796: LD_INT 67
14798: PUSH
14799: LD_INT 68
14801: PUSH
14802: LD_INT 81
14804: PUSH
14805: LD_INT 82
14807: PUSH
14808: LD_INT 83
14810: PUSH
14811: LD_INT 84
14813: PUSH
14814: LD_INT 85
14816: PUSH
14817: LD_INT 87
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: ST_TO_ADDR
14875: GO 15108
14877: LD_INT 3
14879: DOUBLE
14880: EQUAL
14881: IFTRUE 14885
14883: GO 15107
14885: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14886: LD_ADDR_VAR 0 4
14890: PUSH
14891: LD_INT 46
14893: PUSH
14894: LD_INT 47
14896: PUSH
14897: LD_INT 1
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: LD_INT 82
14905: PUSH
14906: LD_INT 83
14908: PUSH
14909: LD_INT 84
14911: PUSH
14912: LD_INT 85
14914: PUSH
14915: LD_INT 86
14917: PUSH
14918: LD_INT 11
14920: PUSH
14921: LD_INT 9
14923: PUSH
14924: LD_INT 20
14926: PUSH
14927: LD_INT 19
14929: PUSH
14930: LD_INT 21
14932: PUSH
14933: LD_INT 24
14935: PUSH
14936: LD_INT 22
14938: PUSH
14939: LD_INT 25
14941: PUSH
14942: LD_INT 28
14944: PUSH
14945: LD_INT 29
14947: PUSH
14948: LD_INT 30
14950: PUSH
14951: LD_INT 31
14953: PUSH
14954: LD_INT 37
14956: PUSH
14957: LD_INT 38
14959: PUSH
14960: LD_INT 32
14962: PUSH
14963: LD_INT 27
14965: PUSH
14966: LD_INT 33
14968: PUSH
14969: LD_INT 69
14971: PUSH
14972: LD_INT 39
14974: PUSH
14975: LD_INT 34
14977: PUSH
14978: LD_INT 40
14980: PUSH
14981: LD_INT 71
14983: PUSH
14984: LD_INT 23
14986: PUSH
14987: LD_INT 44
14989: PUSH
14990: LD_INT 48
14992: PUSH
14993: LD_INT 49
14995: PUSH
14996: LD_INT 50
14998: PUSH
14999: LD_INT 51
15001: PUSH
15002: LD_INT 52
15004: PUSH
15005: LD_INT 53
15007: PUSH
15008: LD_INT 54
15010: PUSH
15011: LD_INT 55
15013: PUSH
15014: LD_INT 56
15016: PUSH
15017: LD_INT 57
15019: PUSH
15020: LD_INT 58
15022: PUSH
15023: LD_INT 59
15025: PUSH
15026: LD_INT 63
15028: PUSH
15029: LD_INT 64
15031: PUSH
15032: LD_INT 65
15034: PUSH
15035: LD_INT 82
15037: PUSH
15038: LD_INT 83
15040: PUSH
15041: LD_INT 84
15043: PUSH
15044: LD_INT 85
15046: PUSH
15047: LD_INT 86
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: LIST
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: LIST
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: ST_TO_ADDR
15105: GO 15108
15107: POP
// if state > - 1 and state < 3 then
15108: LD_VAR 0 3
15112: PUSH
15113: LD_INT 1
15115: NEG
15116: GREATER
15117: PUSH
15118: LD_VAR 0 3
15122: PUSH
15123: LD_INT 3
15125: LESS
15126: AND
15127: IFFALSE 15184
// for i in result do
15129: LD_ADDR_VAR 0 5
15133: PUSH
15134: LD_VAR 0 4
15138: PUSH
15139: FOR_IN
15140: IFFALSE 15182
// if GetTech ( i , side ) <> state then
15142: LD_VAR 0 5
15146: PPUSH
15147: LD_VAR 0 1
15151: PPUSH
15152: CALL_OW 321
15156: PUSH
15157: LD_VAR 0 3
15161: NONEQUAL
15162: IFFALSE 15180
// result := result diff i ;
15164: LD_ADDR_VAR 0 4
15168: PUSH
15169: LD_VAR 0 4
15173: PUSH
15174: LD_VAR 0 5
15178: DIFF
15179: ST_TO_ADDR
15180: GO 15139
15182: POP
15183: POP
// end ;
15184: LD_VAR 0 4
15188: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15189: LD_INT 0
15191: PPUSH
15192: PPUSH
15193: PPUSH
// result := true ;
15194: LD_ADDR_VAR 0 3
15198: PUSH
15199: LD_INT 1
15201: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15202: LD_ADDR_VAR 0 5
15206: PUSH
15207: LD_VAR 0 2
15211: PPUSH
15212: CALL_OW 480
15216: ST_TO_ADDR
// if not tmp then
15217: LD_VAR 0 5
15221: NOT
15222: IFFALSE 15226
// exit ;
15224: GO 15275
// for i in tmp do
15226: LD_ADDR_VAR 0 4
15230: PUSH
15231: LD_VAR 0 5
15235: PUSH
15236: FOR_IN
15237: IFFALSE 15273
// if GetTech ( i , side ) <> state_researched then
15239: LD_VAR 0 4
15243: PPUSH
15244: LD_VAR 0 1
15248: PPUSH
15249: CALL_OW 321
15253: PUSH
15254: LD_INT 2
15256: NONEQUAL
15257: IFFALSE 15271
// begin result := false ;
15259: LD_ADDR_VAR 0 3
15263: PUSH
15264: LD_INT 0
15266: ST_TO_ADDR
// exit ;
15267: POP
15268: POP
15269: GO 15275
// end ;
15271: GO 15236
15273: POP
15274: POP
// end ;
15275: LD_VAR 0 3
15279: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15280: LD_INT 0
15282: PPUSH
15283: PPUSH
15284: PPUSH
15285: PPUSH
15286: PPUSH
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
15291: PPUSH
15292: PPUSH
15293: PPUSH
15294: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15295: LD_VAR 0 1
15299: NOT
15300: PUSH
15301: LD_VAR 0 1
15305: PPUSH
15306: CALL_OW 257
15310: PUSH
15311: LD_INT 9
15313: NONEQUAL
15314: OR
15315: IFFALSE 15319
// exit ;
15317: GO 15892
// side := GetSide ( unit ) ;
15319: LD_ADDR_VAR 0 9
15323: PUSH
15324: LD_VAR 0 1
15328: PPUSH
15329: CALL_OW 255
15333: ST_TO_ADDR
// tech_space := tech_spacanom ;
15334: LD_ADDR_VAR 0 12
15338: PUSH
15339: LD_INT 29
15341: ST_TO_ADDR
// tech_time := tech_taurad ;
15342: LD_ADDR_VAR 0 13
15346: PUSH
15347: LD_INT 28
15349: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15350: LD_ADDR_VAR 0 11
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: CALL_OW 310
15364: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15365: LD_VAR 0 11
15369: PPUSH
15370: CALL_OW 247
15374: PUSH
15375: LD_INT 2
15377: EQUAL
15378: IFFALSE 15382
// exit ;
15380: GO 15892
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15382: LD_ADDR_VAR 0 8
15386: PUSH
15387: LD_INT 81
15389: PUSH
15390: LD_VAR 0 9
15394: PUSH
15395: EMPTY
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 3
15401: PUSH
15402: LD_INT 21
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: PUSH
15412: EMPTY
15413: LIST
15414: LIST
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PPUSH
15420: CALL_OW 69
15424: ST_TO_ADDR
// if not tmp then
15425: LD_VAR 0 8
15429: NOT
15430: IFFALSE 15434
// exit ;
15432: GO 15892
// if in_unit then
15434: LD_VAR 0 11
15438: IFFALSE 15462
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15440: LD_ADDR_VAR 0 10
15444: PUSH
15445: LD_VAR 0 8
15449: PPUSH
15450: LD_VAR 0 11
15454: PPUSH
15455: CALL_OW 74
15459: ST_TO_ADDR
15460: GO 15482
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15462: LD_ADDR_VAR 0 10
15466: PUSH
15467: LD_VAR 0 8
15471: PPUSH
15472: LD_VAR 0 1
15476: PPUSH
15477: CALL_OW 74
15481: ST_TO_ADDR
// if not enemy then
15482: LD_VAR 0 10
15486: NOT
15487: IFFALSE 15491
// exit ;
15489: GO 15892
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15491: LD_VAR 0 11
15495: PUSH
15496: LD_VAR 0 11
15500: PPUSH
15501: LD_VAR 0 10
15505: PPUSH
15506: CALL_OW 296
15510: PUSH
15511: LD_INT 13
15513: GREATER
15514: AND
15515: PUSH
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_VAR 0 10
15525: PPUSH
15526: CALL_OW 296
15530: PUSH
15531: LD_INT 12
15533: GREATER
15534: OR
15535: IFFALSE 15539
// exit ;
15537: GO 15892
// missile := [ 1 ] ;
15539: LD_ADDR_VAR 0 14
15543: PUSH
15544: LD_INT 1
15546: PUSH
15547: EMPTY
15548: LIST
15549: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15550: LD_VAR 0 9
15554: PPUSH
15555: LD_VAR 0 12
15559: PPUSH
15560: CALL_OW 325
15564: IFFALSE 15593
// missile := Insert ( missile , missile + 1 , 2 ) ;
15566: LD_ADDR_VAR 0 14
15570: PUSH
15571: LD_VAR 0 14
15575: PPUSH
15576: LD_VAR 0 14
15580: PUSH
15581: LD_INT 1
15583: PLUS
15584: PPUSH
15585: LD_INT 2
15587: PPUSH
15588: CALL_OW 2
15592: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15593: LD_VAR 0 9
15597: PPUSH
15598: LD_VAR 0 13
15602: PPUSH
15603: CALL_OW 325
15607: PUSH
15608: LD_VAR 0 10
15612: PPUSH
15613: CALL_OW 255
15617: PPUSH
15618: LD_VAR 0 13
15622: PPUSH
15623: CALL_OW 325
15627: NOT
15628: AND
15629: IFFALSE 15658
// missile := Insert ( missile , missile + 1 , 3 ) ;
15631: LD_ADDR_VAR 0 14
15635: PUSH
15636: LD_VAR 0 14
15640: PPUSH
15641: LD_VAR 0 14
15645: PUSH
15646: LD_INT 1
15648: PLUS
15649: PPUSH
15650: LD_INT 3
15652: PPUSH
15653: CALL_OW 2
15657: ST_TO_ADDR
// if missile < 2 then
15658: LD_VAR 0 14
15662: PUSH
15663: LD_INT 2
15665: LESS
15666: IFFALSE 15670
// exit ;
15668: GO 15892
// x := GetX ( enemy ) ;
15670: LD_ADDR_VAR 0 4
15674: PUSH
15675: LD_VAR 0 10
15679: PPUSH
15680: CALL_OW 250
15684: ST_TO_ADDR
// y := GetY ( enemy ) ;
15685: LD_ADDR_VAR 0 5
15689: PUSH
15690: LD_VAR 0 10
15694: PPUSH
15695: CALL_OW 251
15699: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15700: LD_ADDR_VAR 0 6
15704: PUSH
15705: LD_VAR 0 4
15709: PUSH
15710: LD_INT 1
15712: NEG
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: CALL_OW 12
15721: PLUS
15722: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15723: LD_ADDR_VAR 0 7
15727: PUSH
15728: LD_VAR 0 5
15732: PUSH
15733: LD_INT 1
15735: NEG
15736: PPUSH
15737: LD_INT 1
15739: PPUSH
15740: CALL_OW 12
15744: PLUS
15745: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15746: LD_VAR 0 6
15750: PPUSH
15751: LD_VAR 0 7
15755: PPUSH
15756: CALL_OW 488
15760: NOT
15761: IFFALSE 15783
// begin _x := x ;
15763: LD_ADDR_VAR 0 6
15767: PUSH
15768: LD_VAR 0 4
15772: ST_TO_ADDR
// _y := y ;
15773: LD_ADDR_VAR 0 7
15777: PUSH
15778: LD_VAR 0 5
15782: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15783: LD_ADDR_VAR 0 3
15787: PUSH
15788: LD_INT 1
15790: PPUSH
15791: LD_VAR 0 14
15795: PPUSH
15796: CALL_OW 12
15800: ST_TO_ADDR
// case i of 1 :
15801: LD_VAR 0 3
15805: PUSH
15806: LD_INT 1
15808: DOUBLE
15809: EQUAL
15810: IFTRUE 15814
15812: GO 15831
15814: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_VAR 0 10
15824: PPUSH
15825: CALL_OW 115
15829: GO 15892
15831: LD_INT 2
15833: DOUBLE
15834: EQUAL
15835: IFTRUE 15839
15837: GO 15861
15839: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15840: LD_VAR 0 1
15844: PPUSH
15845: LD_VAR 0 6
15849: PPUSH
15850: LD_VAR 0 7
15854: PPUSH
15855: CALL_OW 153
15859: GO 15892
15861: LD_INT 3
15863: DOUBLE
15864: EQUAL
15865: IFTRUE 15869
15867: GO 15891
15869: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15870: LD_VAR 0 1
15874: PPUSH
15875: LD_VAR 0 6
15879: PPUSH
15880: LD_VAR 0 7
15884: PPUSH
15885: CALL_OW 154
15889: GO 15892
15891: POP
// end ;
15892: LD_VAR 0 2
15896: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15897: LD_INT 0
15899: PPUSH
15900: PPUSH
15901: PPUSH
15902: PPUSH
15903: PPUSH
15904: PPUSH
// if not unit or not building then
15905: LD_VAR 0 1
15909: NOT
15910: PUSH
15911: LD_VAR 0 2
15915: NOT
15916: OR
15917: IFFALSE 15921
// exit ;
15919: GO 16079
// x := GetX ( building ) ;
15921: LD_ADDR_VAR 0 5
15925: PUSH
15926: LD_VAR 0 2
15930: PPUSH
15931: CALL_OW 250
15935: ST_TO_ADDR
// y := GetY ( building ) ;
15936: LD_ADDR_VAR 0 6
15940: PUSH
15941: LD_VAR 0 2
15945: PPUSH
15946: CALL_OW 251
15950: ST_TO_ADDR
// for i = 0 to 5 do
15951: LD_ADDR_VAR 0 4
15955: PUSH
15956: DOUBLE
15957: LD_INT 0
15959: DEC
15960: ST_TO_ADDR
15961: LD_INT 5
15963: PUSH
15964: FOR_TO
15965: IFFALSE 16077
// begin _x := ShiftX ( x , i , 3 ) ;
15967: LD_ADDR_VAR 0 7
15971: PUSH
15972: LD_VAR 0 5
15976: PPUSH
15977: LD_VAR 0 4
15981: PPUSH
15982: LD_INT 3
15984: PPUSH
15985: CALL_OW 272
15989: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15990: LD_ADDR_VAR 0 8
15994: PUSH
15995: LD_VAR 0 6
15999: PPUSH
16000: LD_VAR 0 4
16004: PPUSH
16005: LD_INT 3
16007: PPUSH
16008: CALL_OW 273
16012: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16013: LD_VAR 0 7
16017: PPUSH
16018: LD_VAR 0 8
16022: PPUSH
16023: CALL_OW 488
16027: NOT
16028: IFFALSE 16032
// continue ;
16030: GO 15964
// if HexInfo ( _x , _y ) = 0 then
16032: LD_VAR 0 7
16036: PPUSH
16037: LD_VAR 0 8
16041: PPUSH
16042: CALL_OW 428
16046: PUSH
16047: LD_INT 0
16049: EQUAL
16050: IFFALSE 16075
// begin ComMoveXY ( unit , _x , _y ) ;
16052: LD_VAR 0 1
16056: PPUSH
16057: LD_VAR 0 7
16061: PPUSH
16062: LD_VAR 0 8
16066: PPUSH
16067: CALL_OW 111
// exit ;
16071: POP
16072: POP
16073: GO 16079
// end ; end ;
16075: GO 15964
16077: POP
16078: POP
// end ;
16079: LD_VAR 0 3
16083: RET
// export function ScanBase ( side , base_area ) ; begin
16084: LD_INT 0
16086: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16087: LD_ADDR_VAR 0 3
16091: PUSH
16092: LD_VAR 0 2
16096: PPUSH
16097: LD_INT 81
16099: PUSH
16100: LD_VAR 0 1
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PPUSH
16109: CALL_OW 70
16113: ST_TO_ADDR
// end ;
16114: LD_VAR 0 3
16118: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16119: LD_INT 0
16121: PPUSH
16122: PPUSH
16123: PPUSH
16124: PPUSH
// result := false ;
16125: LD_ADDR_VAR 0 2
16129: PUSH
16130: LD_INT 0
16132: ST_TO_ADDR
// side := GetSide ( unit ) ;
16133: LD_ADDR_VAR 0 3
16137: PUSH
16138: LD_VAR 0 1
16142: PPUSH
16143: CALL_OW 255
16147: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16148: LD_ADDR_VAR 0 4
16152: PUSH
16153: LD_VAR 0 1
16157: PPUSH
16158: CALL_OW 248
16162: ST_TO_ADDR
// case nat of 1 :
16163: LD_VAR 0 4
16167: PUSH
16168: LD_INT 1
16170: DOUBLE
16171: EQUAL
16172: IFTRUE 16176
16174: GO 16187
16176: POP
// tech := tech_lassight ; 2 :
16177: LD_ADDR_VAR 0 5
16181: PUSH
16182: LD_INT 12
16184: ST_TO_ADDR
16185: GO 16226
16187: LD_INT 2
16189: DOUBLE
16190: EQUAL
16191: IFTRUE 16195
16193: GO 16206
16195: POP
// tech := tech_mortar ; 3 :
16196: LD_ADDR_VAR 0 5
16200: PUSH
16201: LD_INT 41
16203: ST_TO_ADDR
16204: GO 16226
16206: LD_INT 3
16208: DOUBLE
16209: EQUAL
16210: IFTRUE 16214
16212: GO 16225
16214: POP
// tech := tech_bazooka ; end ;
16215: LD_ADDR_VAR 0 5
16219: PUSH
16220: LD_INT 44
16222: ST_TO_ADDR
16223: GO 16226
16225: POP
// if Researched ( side , tech ) then
16226: LD_VAR 0 3
16230: PPUSH
16231: LD_VAR 0 5
16235: PPUSH
16236: CALL_OW 325
16240: IFFALSE 16267
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16242: LD_ADDR_VAR 0 2
16246: PUSH
16247: LD_INT 5
16249: PUSH
16250: LD_INT 8
16252: PUSH
16253: LD_INT 9
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: LIST
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: ST_TO_ADDR
// end ;
16267: LD_VAR 0 2
16271: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16272: LD_INT 0
16274: PPUSH
16275: PPUSH
16276: PPUSH
// if not mines then
16277: LD_VAR 0 2
16281: NOT
16282: IFFALSE 16286
// exit ;
16284: GO 16430
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16286: LD_ADDR_VAR 0 5
16290: PUSH
16291: LD_INT 81
16293: PUSH
16294: LD_VAR 0 1
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 3
16305: PUSH
16306: LD_INT 21
16308: PUSH
16309: LD_INT 3
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: PUSH
16316: EMPTY
16317: LIST
16318: LIST
16319: PUSH
16320: EMPTY
16321: LIST
16322: LIST
16323: PPUSH
16324: CALL_OW 69
16328: ST_TO_ADDR
// for i in mines do
16329: LD_ADDR_VAR 0 4
16333: PUSH
16334: LD_VAR 0 2
16338: PUSH
16339: FOR_IN
16340: IFFALSE 16428
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16342: LD_VAR 0 4
16346: PUSH
16347: LD_INT 1
16349: ARRAY
16350: PPUSH
16351: LD_VAR 0 4
16355: PUSH
16356: LD_INT 2
16358: ARRAY
16359: PPUSH
16360: CALL_OW 458
16364: NOT
16365: IFFALSE 16369
// continue ;
16367: GO 16339
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16369: LD_VAR 0 4
16373: PUSH
16374: LD_INT 1
16376: ARRAY
16377: PPUSH
16378: LD_VAR 0 4
16382: PUSH
16383: LD_INT 2
16385: ARRAY
16386: PPUSH
16387: CALL_OW 428
16391: PUSH
16392: LD_VAR 0 5
16396: IN
16397: IFFALSE 16426
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16399: LD_VAR 0 4
16403: PUSH
16404: LD_INT 1
16406: ARRAY
16407: PPUSH
16408: LD_VAR 0 4
16412: PUSH
16413: LD_INT 2
16415: ARRAY
16416: PPUSH
16417: LD_VAR 0 1
16421: PPUSH
16422: CALL_OW 456
// end ;
16426: GO 16339
16428: POP
16429: POP
// end ;
16430: LD_VAR 0 3
16434: RET
// export function Count ( array ) ; var i ; begin
16435: LD_INT 0
16437: PPUSH
16438: PPUSH
// result := 0 ;
16439: LD_ADDR_VAR 0 2
16443: PUSH
16444: LD_INT 0
16446: ST_TO_ADDR
// for i in array do
16447: LD_ADDR_VAR 0 3
16451: PUSH
16452: LD_VAR 0 1
16456: PUSH
16457: FOR_IN
16458: IFFALSE 16482
// if i then
16460: LD_VAR 0 3
16464: IFFALSE 16480
// result := result + 1 ;
16466: LD_ADDR_VAR 0 2
16470: PUSH
16471: LD_VAR 0 2
16475: PUSH
16476: LD_INT 1
16478: PLUS
16479: ST_TO_ADDR
16480: GO 16457
16482: POP
16483: POP
// end ;
16484: LD_VAR 0 2
16488: RET
// export function IsEmpty ( building ) ; begin
16489: LD_INT 0
16491: PPUSH
// if not building then
16492: LD_VAR 0 1
16496: NOT
16497: IFFALSE 16501
// exit ;
16499: GO 16544
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16501: LD_ADDR_VAR 0 2
16505: PUSH
16506: LD_VAR 0 1
16510: PUSH
16511: LD_INT 22
16513: PUSH
16514: LD_VAR 0 1
16518: PPUSH
16519: CALL_OW 255
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: LD_INT 58
16530: PUSH
16531: EMPTY
16532: LIST
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: PPUSH
16538: CALL_OW 69
16542: IN
16543: ST_TO_ADDR
// end ;
16544: LD_VAR 0 2
16548: RET
// export function IsNotFull ( building ) ; begin
16549: LD_INT 0
16551: PPUSH
// if not building then
16552: LD_VAR 0 1
16556: NOT
16557: IFFALSE 16561
// exit ;
16559: GO 16580
// result := UnitsInside ( building ) < 6 ;
16561: LD_ADDR_VAR 0 2
16565: PUSH
16566: LD_VAR 0 1
16570: PPUSH
16571: CALL_OW 313
16575: PUSH
16576: LD_INT 6
16578: LESS
16579: ST_TO_ADDR
// end ;
16580: LD_VAR 0 2
16584: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16585: LD_INT 0
16587: PPUSH
16588: PPUSH
16589: PPUSH
16590: PPUSH
// tmp := [ ] ;
16591: LD_ADDR_VAR 0 3
16595: PUSH
16596: EMPTY
16597: ST_TO_ADDR
// list := [ ] ;
16598: LD_ADDR_VAR 0 5
16602: PUSH
16603: EMPTY
16604: ST_TO_ADDR
// for i = 16 to 25 do
16605: LD_ADDR_VAR 0 4
16609: PUSH
16610: DOUBLE
16611: LD_INT 16
16613: DEC
16614: ST_TO_ADDR
16615: LD_INT 25
16617: PUSH
16618: FOR_TO
16619: IFFALSE 16692
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16621: LD_ADDR_VAR 0 3
16625: PUSH
16626: LD_VAR 0 3
16630: PUSH
16631: LD_INT 22
16633: PUSH
16634: LD_VAR 0 1
16638: PPUSH
16639: CALL_OW 255
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: PUSH
16648: LD_INT 91
16650: PUSH
16651: LD_VAR 0 1
16655: PUSH
16656: LD_INT 6
16658: PUSH
16659: EMPTY
16660: LIST
16661: LIST
16662: LIST
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_VAR 0 4
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: LIST
16680: PUSH
16681: EMPTY
16682: LIST
16683: PPUSH
16684: CALL_OW 69
16688: ADD
16689: ST_TO_ADDR
16690: GO 16618
16692: POP
16693: POP
// for i = 1 to tmp do
16694: LD_ADDR_VAR 0 4
16698: PUSH
16699: DOUBLE
16700: LD_INT 1
16702: DEC
16703: ST_TO_ADDR
16704: LD_VAR 0 3
16708: PUSH
16709: FOR_TO
16710: IFFALSE 16798
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16712: LD_ADDR_VAR 0 5
16716: PUSH
16717: LD_VAR 0 5
16721: PUSH
16722: LD_VAR 0 3
16726: PUSH
16727: LD_VAR 0 4
16731: ARRAY
16732: PPUSH
16733: CALL_OW 266
16737: PUSH
16738: LD_VAR 0 3
16742: PUSH
16743: LD_VAR 0 4
16747: ARRAY
16748: PPUSH
16749: CALL_OW 250
16753: PUSH
16754: LD_VAR 0 3
16758: PUSH
16759: LD_VAR 0 4
16763: ARRAY
16764: PPUSH
16765: CALL_OW 251
16769: PUSH
16770: LD_VAR 0 3
16774: PUSH
16775: LD_VAR 0 4
16779: ARRAY
16780: PPUSH
16781: CALL_OW 254
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: PUSH
16792: EMPTY
16793: LIST
16794: ADD
16795: ST_TO_ADDR
16796: GO 16709
16798: POP
16799: POP
// result := list ;
16800: LD_ADDR_VAR 0 2
16804: PUSH
16805: LD_VAR 0 5
16809: ST_TO_ADDR
// end ;
16810: LD_VAR 0 2
16814: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16815: LD_INT 0
16817: PPUSH
16818: PPUSH
16819: PPUSH
16820: PPUSH
16821: PPUSH
16822: PPUSH
16823: PPUSH
// if not factory then
16824: LD_VAR 0 1
16828: NOT
16829: IFFALSE 16833
// exit ;
16831: GO 17426
// if control = control_apeman then
16833: LD_VAR 0 4
16837: PUSH
16838: LD_INT 5
16840: EQUAL
16841: IFFALSE 16950
// begin tmp := UnitsInside ( factory ) ;
16843: LD_ADDR_VAR 0 8
16847: PUSH
16848: LD_VAR 0 1
16852: PPUSH
16853: CALL_OW 313
16857: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16858: LD_VAR 0 8
16862: PPUSH
16863: LD_INT 25
16865: PUSH
16866: LD_INT 12
16868: PUSH
16869: EMPTY
16870: LIST
16871: LIST
16872: PPUSH
16873: CALL_OW 72
16877: NOT
16878: IFFALSE 16888
// control := control_manual ;
16880: LD_ADDR_VAR 0 4
16884: PUSH
16885: LD_INT 1
16887: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16888: LD_ADDR_VAR 0 8
16892: PUSH
16893: LD_VAR 0 1
16897: PPUSH
16898: CALL 16585 0 1
16902: ST_TO_ADDR
// if tmp then
16903: LD_VAR 0 8
16907: IFFALSE 16950
// begin for i in tmp do
16909: LD_ADDR_VAR 0 7
16913: PUSH
16914: LD_VAR 0 8
16918: PUSH
16919: FOR_IN
16920: IFFALSE 16948
// if i [ 1 ] = b_ext_radio then
16922: LD_VAR 0 7
16926: PUSH
16927: LD_INT 1
16929: ARRAY
16930: PUSH
16931: LD_INT 22
16933: EQUAL
16934: IFFALSE 16946
// begin control := control_remote ;
16936: LD_ADDR_VAR 0 4
16940: PUSH
16941: LD_INT 2
16943: ST_TO_ADDR
// break ;
16944: GO 16948
// end ;
16946: GO 16919
16948: POP
16949: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16950: LD_VAR 0 1
16954: PPUSH
16955: LD_VAR 0 2
16959: PPUSH
16960: LD_VAR 0 3
16964: PPUSH
16965: LD_VAR 0 4
16969: PPUSH
16970: LD_VAR 0 5
16974: PPUSH
16975: CALL_OW 448
16979: IFFALSE 17014
// begin result := [ chassis , engine , control , weapon ] ;
16981: LD_ADDR_VAR 0 6
16985: PUSH
16986: LD_VAR 0 2
16990: PUSH
16991: LD_VAR 0 3
16995: PUSH
16996: LD_VAR 0 4
17000: PUSH
17001: LD_VAR 0 5
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: ST_TO_ADDR
// exit ;
17012: GO 17426
// end ; _chassis := AvailableChassisList ( factory ) ;
17014: LD_ADDR_VAR 0 9
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 475
17028: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17029: LD_ADDR_VAR 0 11
17033: PUSH
17034: LD_VAR 0 1
17038: PPUSH
17039: CALL_OW 476
17043: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17044: LD_ADDR_VAR 0 12
17048: PUSH
17049: LD_VAR 0 1
17053: PPUSH
17054: CALL_OW 477
17058: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17059: LD_ADDR_VAR 0 10
17063: PUSH
17064: LD_VAR 0 1
17068: PPUSH
17069: CALL_OW 478
17073: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17074: LD_VAR 0 9
17078: NOT
17079: PUSH
17080: LD_VAR 0 11
17084: NOT
17085: OR
17086: PUSH
17087: LD_VAR 0 12
17091: NOT
17092: OR
17093: PUSH
17094: LD_VAR 0 10
17098: NOT
17099: OR
17100: IFFALSE 17135
// begin result := [ chassis , engine , control , weapon ] ;
17102: LD_ADDR_VAR 0 6
17106: PUSH
17107: LD_VAR 0 2
17111: PUSH
17112: LD_VAR 0 3
17116: PUSH
17117: LD_VAR 0 4
17121: PUSH
17122: LD_VAR 0 5
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: LIST
17131: LIST
17132: ST_TO_ADDR
// exit ;
17133: GO 17426
// end ; if not chassis in _chassis then
17135: LD_VAR 0 2
17139: PUSH
17140: LD_VAR 0 9
17144: IN
17145: NOT
17146: IFFALSE 17172
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17148: LD_ADDR_VAR 0 2
17152: PUSH
17153: LD_VAR 0 9
17157: PUSH
17158: LD_INT 1
17160: PPUSH
17161: LD_VAR 0 9
17165: PPUSH
17166: CALL_OW 12
17170: ARRAY
17171: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17172: LD_VAR 0 2
17176: PPUSH
17177: LD_VAR 0 3
17181: PPUSH
17182: CALL 17431 0 2
17186: NOT
17187: IFFALSE 17246
// repeat engine := _engine [ 1 ] ;
17189: LD_ADDR_VAR 0 3
17193: PUSH
17194: LD_VAR 0 11
17198: PUSH
17199: LD_INT 1
17201: ARRAY
17202: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17203: LD_ADDR_VAR 0 11
17207: PUSH
17208: LD_VAR 0 11
17212: PPUSH
17213: LD_INT 1
17215: PPUSH
17216: CALL_OW 3
17220: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17221: LD_VAR 0 2
17225: PPUSH
17226: LD_VAR 0 3
17230: PPUSH
17231: CALL 17431 0 2
17235: PUSH
17236: LD_VAR 0 11
17240: PUSH
17241: EMPTY
17242: EQUAL
17243: OR
17244: IFFALSE 17189
// if not control in _control then
17246: LD_VAR 0 4
17250: PUSH
17251: LD_VAR 0 12
17255: IN
17256: NOT
17257: IFFALSE 17283
// control := _control [ rand ( 1 , _control ) ] ;
17259: LD_ADDR_VAR 0 4
17263: PUSH
17264: LD_VAR 0 12
17268: PUSH
17269: LD_INT 1
17271: PPUSH
17272: LD_VAR 0 12
17276: PPUSH
17277: CALL_OW 12
17281: ARRAY
17282: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17283: LD_VAR 0 2
17287: PPUSH
17288: LD_VAR 0 5
17292: PPUSH
17293: CALL 17651 0 2
17297: NOT
17298: IFFALSE 17357
// repeat weapon := _weapon [ 1 ] ;
17300: LD_ADDR_VAR 0 5
17304: PUSH
17305: LD_VAR 0 10
17309: PUSH
17310: LD_INT 1
17312: ARRAY
17313: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17314: LD_ADDR_VAR 0 10
17318: PUSH
17319: LD_VAR 0 10
17323: PPUSH
17324: LD_INT 1
17326: PPUSH
17327: CALL_OW 3
17331: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17332: LD_VAR 0 2
17336: PPUSH
17337: LD_VAR 0 5
17341: PPUSH
17342: CALL 17651 0 2
17346: PUSH
17347: LD_VAR 0 10
17351: PUSH
17352: EMPTY
17353: EQUAL
17354: OR
17355: IFFALSE 17300
// result := [ ] ;
17357: LD_ADDR_VAR 0 6
17361: PUSH
17362: EMPTY
17363: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17364: LD_VAR 0 1
17368: PPUSH
17369: LD_VAR 0 2
17373: PPUSH
17374: LD_VAR 0 3
17378: PPUSH
17379: LD_VAR 0 4
17383: PPUSH
17384: LD_VAR 0 5
17388: PPUSH
17389: CALL_OW 448
17393: IFFALSE 17426
// result := [ chassis , engine , control , weapon ] ;
17395: LD_ADDR_VAR 0 6
17399: PUSH
17400: LD_VAR 0 2
17404: PUSH
17405: LD_VAR 0 3
17409: PUSH
17410: LD_VAR 0 4
17414: PUSH
17415: LD_VAR 0 5
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// end ;
17426: LD_VAR 0 6
17430: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17431: LD_INT 0
17433: PPUSH
// if not chassis or not engine then
17434: LD_VAR 0 1
17438: NOT
17439: PUSH
17440: LD_VAR 0 2
17444: NOT
17445: OR
17446: IFFALSE 17450
// exit ;
17448: GO 17646
// case engine of engine_solar :
17450: LD_VAR 0 2
17454: PUSH
17455: LD_INT 2
17457: DOUBLE
17458: EQUAL
17459: IFTRUE 17463
17461: GO 17501
17463: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17464: LD_ADDR_VAR 0 3
17468: PUSH
17469: LD_INT 11
17471: PUSH
17472: LD_INT 12
17474: PUSH
17475: LD_INT 13
17477: PUSH
17478: LD_INT 14
17480: PUSH
17481: LD_INT 1
17483: PUSH
17484: LD_INT 2
17486: PUSH
17487: LD_INT 3
17489: PUSH
17490: EMPTY
17491: LIST
17492: LIST
17493: LIST
17494: LIST
17495: LIST
17496: LIST
17497: LIST
17498: ST_TO_ADDR
17499: GO 17630
17501: LD_INT 1
17503: DOUBLE
17504: EQUAL
17505: IFTRUE 17509
17507: GO 17571
17509: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17510: LD_ADDR_VAR 0 3
17514: PUSH
17515: LD_INT 11
17517: PUSH
17518: LD_INT 12
17520: PUSH
17521: LD_INT 13
17523: PUSH
17524: LD_INT 14
17526: PUSH
17527: LD_INT 1
17529: PUSH
17530: LD_INT 2
17532: PUSH
17533: LD_INT 3
17535: PUSH
17536: LD_INT 4
17538: PUSH
17539: LD_INT 5
17541: PUSH
17542: LD_INT 21
17544: PUSH
17545: LD_INT 23
17547: PUSH
17548: LD_INT 22
17550: PUSH
17551: LD_INT 24
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: ST_TO_ADDR
17569: GO 17630
17571: LD_INT 3
17573: DOUBLE
17574: EQUAL
17575: IFTRUE 17579
17577: GO 17629
17579: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17580: LD_ADDR_VAR 0 3
17584: PUSH
17585: LD_INT 13
17587: PUSH
17588: LD_INT 14
17590: PUSH
17591: LD_INT 2
17593: PUSH
17594: LD_INT 3
17596: PUSH
17597: LD_INT 4
17599: PUSH
17600: LD_INT 5
17602: PUSH
17603: LD_INT 21
17605: PUSH
17606: LD_INT 22
17608: PUSH
17609: LD_INT 23
17611: PUSH
17612: LD_INT 24
17614: PUSH
17615: EMPTY
17616: LIST
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: LIST
17623: LIST
17624: LIST
17625: LIST
17626: ST_TO_ADDR
17627: GO 17630
17629: POP
// result := ( chassis in result ) ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_VAR 0 1
17639: PUSH
17640: LD_VAR 0 3
17644: IN
17645: ST_TO_ADDR
// end ;
17646: LD_VAR 0 3
17650: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17651: LD_INT 0
17653: PPUSH
// if not chassis or not weapon then
17654: LD_VAR 0 1
17658: NOT
17659: PUSH
17660: LD_VAR 0 2
17664: NOT
17665: OR
17666: IFFALSE 17670
// exit ;
17668: GO 18696
// case weapon of us_machine_gun :
17670: LD_VAR 0 2
17674: PUSH
17675: LD_INT 2
17677: DOUBLE
17678: EQUAL
17679: IFTRUE 17683
17681: GO 17713
17683: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17684: LD_ADDR_VAR 0 3
17688: PUSH
17689: LD_INT 1
17691: PUSH
17692: LD_INT 2
17694: PUSH
17695: LD_INT 3
17697: PUSH
17698: LD_INT 4
17700: PUSH
17701: LD_INT 5
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: LIST
17708: LIST
17709: LIST
17710: ST_TO_ADDR
17711: GO 18680
17713: LD_INT 3
17715: DOUBLE
17716: EQUAL
17717: IFTRUE 17721
17719: GO 17751
17721: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_INT 1
17729: PUSH
17730: LD_INT 2
17732: PUSH
17733: LD_INT 3
17735: PUSH
17736: LD_INT 4
17738: PUSH
17739: LD_INT 5
17741: PUSH
17742: EMPTY
17743: LIST
17744: LIST
17745: LIST
17746: LIST
17747: LIST
17748: ST_TO_ADDR
17749: GO 18680
17751: LD_INT 11
17753: DOUBLE
17754: EQUAL
17755: IFTRUE 17759
17757: GO 17789
17759: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17760: LD_ADDR_VAR 0 3
17764: PUSH
17765: LD_INT 1
17767: PUSH
17768: LD_INT 2
17770: PUSH
17771: LD_INT 3
17773: PUSH
17774: LD_INT 4
17776: PUSH
17777: LD_INT 5
17779: PUSH
17780: EMPTY
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: ST_TO_ADDR
17787: GO 18680
17789: LD_INT 4
17791: DOUBLE
17792: EQUAL
17793: IFTRUE 17797
17795: GO 17823
17797: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17798: LD_ADDR_VAR 0 3
17802: PUSH
17803: LD_INT 2
17805: PUSH
17806: LD_INT 3
17808: PUSH
17809: LD_INT 4
17811: PUSH
17812: LD_INT 5
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: ST_TO_ADDR
17821: GO 18680
17823: LD_INT 5
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17857
17831: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17832: LD_ADDR_VAR 0 3
17836: PUSH
17837: LD_INT 2
17839: PUSH
17840: LD_INT 3
17842: PUSH
17843: LD_INT 4
17845: PUSH
17846: LD_INT 5
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: ST_TO_ADDR
17855: GO 18680
17857: LD_INT 9
17859: DOUBLE
17860: EQUAL
17861: IFTRUE 17865
17863: GO 17891
17865: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17866: LD_ADDR_VAR 0 3
17870: PUSH
17871: LD_INT 2
17873: PUSH
17874: LD_INT 3
17876: PUSH
17877: LD_INT 4
17879: PUSH
17880: LD_INT 5
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: LIST
17887: LIST
17888: ST_TO_ADDR
17889: GO 18680
17891: LD_INT 7
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17925
17899: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17900: LD_ADDR_VAR 0 3
17904: PUSH
17905: LD_INT 2
17907: PUSH
17908: LD_INT 3
17910: PUSH
17911: LD_INT 4
17913: PUSH
17914: LD_INT 5
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: LIST
17921: LIST
17922: ST_TO_ADDR
17923: GO 18680
17925: LD_INT 12
17927: DOUBLE
17928: EQUAL
17929: IFTRUE 17933
17931: GO 17959
17933: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17934: LD_ADDR_VAR 0 3
17938: PUSH
17939: LD_INT 2
17941: PUSH
17942: LD_INT 3
17944: PUSH
17945: LD_INT 4
17947: PUSH
17948: LD_INT 5
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: ST_TO_ADDR
17957: GO 18680
17959: LD_INT 13
17961: DOUBLE
17962: EQUAL
17963: IFTRUE 17967
17965: GO 17993
17967: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17968: LD_ADDR_VAR 0 3
17972: PUSH
17973: LD_INT 2
17975: PUSH
17976: LD_INT 3
17978: PUSH
17979: LD_INT 4
17981: PUSH
17982: LD_INT 5
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: ST_TO_ADDR
17991: GO 18680
17993: LD_INT 14
17995: DOUBLE
17996: EQUAL
17997: IFTRUE 18001
17999: GO 18019
18001: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18002: LD_ADDR_VAR 0 3
18006: PUSH
18007: LD_INT 4
18009: PUSH
18010: LD_INT 5
18012: PUSH
18013: EMPTY
18014: LIST
18015: LIST
18016: ST_TO_ADDR
18017: GO 18680
18019: LD_INT 6
18021: DOUBLE
18022: EQUAL
18023: IFTRUE 18027
18025: GO 18045
18027: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18028: LD_ADDR_VAR 0 3
18032: PUSH
18033: LD_INT 4
18035: PUSH
18036: LD_INT 5
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: ST_TO_ADDR
18043: GO 18680
18045: LD_INT 10
18047: DOUBLE
18048: EQUAL
18049: IFTRUE 18053
18051: GO 18071
18053: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18054: LD_ADDR_VAR 0 3
18058: PUSH
18059: LD_INT 4
18061: PUSH
18062: LD_INT 5
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: ST_TO_ADDR
18069: GO 18680
18071: LD_INT 22
18073: DOUBLE
18074: EQUAL
18075: IFTRUE 18079
18077: GO 18105
18079: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18080: LD_ADDR_VAR 0 3
18084: PUSH
18085: LD_INT 11
18087: PUSH
18088: LD_INT 12
18090: PUSH
18091: LD_INT 13
18093: PUSH
18094: LD_INT 14
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: ST_TO_ADDR
18103: GO 18680
18105: LD_INT 23
18107: DOUBLE
18108: EQUAL
18109: IFTRUE 18113
18111: GO 18139
18113: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18114: LD_ADDR_VAR 0 3
18118: PUSH
18119: LD_INT 11
18121: PUSH
18122: LD_INT 12
18124: PUSH
18125: LD_INT 13
18127: PUSH
18128: LD_INT 14
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: LIST
18135: LIST
18136: ST_TO_ADDR
18137: GO 18680
18139: LD_INT 24
18141: DOUBLE
18142: EQUAL
18143: IFTRUE 18147
18145: GO 18173
18147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18148: LD_ADDR_VAR 0 3
18152: PUSH
18153: LD_INT 11
18155: PUSH
18156: LD_INT 12
18158: PUSH
18159: LD_INT 13
18161: PUSH
18162: LD_INT 14
18164: PUSH
18165: EMPTY
18166: LIST
18167: LIST
18168: LIST
18169: LIST
18170: ST_TO_ADDR
18171: GO 18680
18173: LD_INT 30
18175: DOUBLE
18176: EQUAL
18177: IFTRUE 18181
18179: GO 18207
18181: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18182: LD_ADDR_VAR 0 3
18186: PUSH
18187: LD_INT 11
18189: PUSH
18190: LD_INT 12
18192: PUSH
18193: LD_INT 13
18195: PUSH
18196: LD_INT 14
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: LIST
18204: ST_TO_ADDR
18205: GO 18680
18207: LD_INT 25
18209: DOUBLE
18210: EQUAL
18211: IFTRUE 18215
18213: GO 18233
18215: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18216: LD_ADDR_VAR 0 3
18220: PUSH
18221: LD_INT 13
18223: PUSH
18224: LD_INT 14
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: ST_TO_ADDR
18231: GO 18680
18233: LD_INT 27
18235: DOUBLE
18236: EQUAL
18237: IFTRUE 18241
18239: GO 18259
18241: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18242: LD_ADDR_VAR 0 3
18246: PUSH
18247: LD_INT 13
18249: PUSH
18250: LD_INT 14
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: ST_TO_ADDR
18257: GO 18680
18259: LD_INT 28
18261: DOUBLE
18262: EQUAL
18263: IFTRUE 18267
18265: GO 18285
18267: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18268: LD_ADDR_VAR 0 3
18272: PUSH
18273: LD_INT 13
18275: PUSH
18276: LD_INT 14
18278: PUSH
18279: EMPTY
18280: LIST
18281: LIST
18282: ST_TO_ADDR
18283: GO 18680
18285: LD_INT 29
18287: DOUBLE
18288: EQUAL
18289: IFTRUE 18293
18291: GO 18311
18293: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18294: LD_ADDR_VAR 0 3
18298: PUSH
18299: LD_INT 13
18301: PUSH
18302: LD_INT 14
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: ST_TO_ADDR
18309: GO 18680
18311: LD_INT 31
18313: DOUBLE
18314: EQUAL
18315: IFTRUE 18319
18317: GO 18337
18319: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18320: LD_ADDR_VAR 0 3
18324: PUSH
18325: LD_INT 13
18327: PUSH
18328: LD_INT 14
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: ST_TO_ADDR
18335: GO 18680
18337: LD_INT 26
18339: DOUBLE
18340: EQUAL
18341: IFTRUE 18345
18343: GO 18363
18345: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18346: LD_ADDR_VAR 0 3
18350: PUSH
18351: LD_INT 13
18353: PUSH
18354: LD_INT 14
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: ST_TO_ADDR
18361: GO 18680
18363: LD_INT 42
18365: DOUBLE
18366: EQUAL
18367: IFTRUE 18371
18369: GO 18397
18371: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18372: LD_ADDR_VAR 0 3
18376: PUSH
18377: LD_INT 21
18379: PUSH
18380: LD_INT 22
18382: PUSH
18383: LD_INT 23
18385: PUSH
18386: LD_INT 24
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: ST_TO_ADDR
18395: GO 18680
18397: LD_INT 43
18399: DOUBLE
18400: EQUAL
18401: IFTRUE 18405
18403: GO 18431
18405: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18406: LD_ADDR_VAR 0 3
18410: PUSH
18411: LD_INT 21
18413: PUSH
18414: LD_INT 22
18416: PUSH
18417: LD_INT 23
18419: PUSH
18420: LD_INT 24
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: LIST
18427: LIST
18428: ST_TO_ADDR
18429: GO 18680
18431: LD_INT 44
18433: DOUBLE
18434: EQUAL
18435: IFTRUE 18439
18437: GO 18465
18439: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18440: LD_ADDR_VAR 0 3
18444: PUSH
18445: LD_INT 21
18447: PUSH
18448: LD_INT 22
18450: PUSH
18451: LD_INT 23
18453: PUSH
18454: LD_INT 24
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: ST_TO_ADDR
18463: GO 18680
18465: LD_INT 45
18467: DOUBLE
18468: EQUAL
18469: IFTRUE 18473
18471: GO 18499
18473: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18474: LD_ADDR_VAR 0 3
18478: PUSH
18479: LD_INT 21
18481: PUSH
18482: LD_INT 22
18484: PUSH
18485: LD_INT 23
18487: PUSH
18488: LD_INT 24
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: LIST
18495: LIST
18496: ST_TO_ADDR
18497: GO 18680
18499: LD_INT 49
18501: DOUBLE
18502: EQUAL
18503: IFTRUE 18507
18505: GO 18533
18507: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18508: LD_ADDR_VAR 0 3
18512: PUSH
18513: LD_INT 21
18515: PUSH
18516: LD_INT 22
18518: PUSH
18519: LD_INT 23
18521: PUSH
18522: LD_INT 24
18524: PUSH
18525: EMPTY
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: ST_TO_ADDR
18531: GO 18680
18533: LD_INT 51
18535: DOUBLE
18536: EQUAL
18537: IFTRUE 18541
18539: GO 18567
18541: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18542: LD_ADDR_VAR 0 3
18546: PUSH
18547: LD_INT 21
18549: PUSH
18550: LD_INT 22
18552: PUSH
18553: LD_INT 23
18555: PUSH
18556: LD_INT 24
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: LIST
18563: LIST
18564: ST_TO_ADDR
18565: GO 18680
18567: LD_INT 52
18569: DOUBLE
18570: EQUAL
18571: IFTRUE 18575
18573: GO 18601
18575: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18576: LD_ADDR_VAR 0 3
18580: PUSH
18581: LD_INT 21
18583: PUSH
18584: LD_INT 22
18586: PUSH
18587: LD_INT 23
18589: PUSH
18590: LD_INT 24
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: ST_TO_ADDR
18599: GO 18680
18601: LD_INT 53
18603: DOUBLE
18604: EQUAL
18605: IFTRUE 18609
18607: GO 18627
18609: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_INT 23
18617: PUSH
18618: LD_INT 24
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: ST_TO_ADDR
18625: GO 18680
18627: LD_INT 46
18629: DOUBLE
18630: EQUAL
18631: IFTRUE 18635
18633: GO 18653
18635: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18636: LD_ADDR_VAR 0 3
18640: PUSH
18641: LD_INT 23
18643: PUSH
18644: LD_INT 24
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: ST_TO_ADDR
18651: GO 18680
18653: LD_INT 47
18655: DOUBLE
18656: EQUAL
18657: IFTRUE 18661
18659: GO 18679
18661: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18662: LD_ADDR_VAR 0 3
18666: PUSH
18667: LD_INT 23
18669: PUSH
18670: LD_INT 24
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: ST_TO_ADDR
18677: GO 18680
18679: POP
// result := ( chassis in result ) ;
18680: LD_ADDR_VAR 0 3
18684: PUSH
18685: LD_VAR 0 1
18689: PUSH
18690: LD_VAR 0 3
18694: IN
18695: ST_TO_ADDR
// end ;
18696: LD_VAR 0 3
18700: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18701: LD_INT 0
18703: PPUSH
18704: PPUSH
18705: PPUSH
18706: PPUSH
18707: PPUSH
18708: PPUSH
18709: PPUSH
// result := array ;
18710: LD_ADDR_VAR 0 5
18714: PUSH
18715: LD_VAR 0 1
18719: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18720: LD_VAR 0 1
18724: NOT
18725: PUSH
18726: LD_VAR 0 2
18730: NOT
18731: OR
18732: PUSH
18733: LD_VAR 0 3
18737: NOT
18738: OR
18739: PUSH
18740: LD_VAR 0 2
18744: PUSH
18745: LD_VAR 0 1
18749: GREATER
18750: OR
18751: PUSH
18752: LD_VAR 0 3
18756: PUSH
18757: LD_VAR 0 1
18761: GREATER
18762: OR
18763: IFFALSE 18767
// exit ;
18765: GO 19063
// if direction then
18767: LD_VAR 0 4
18771: IFFALSE 18835
// begin d := 1 ;
18773: LD_ADDR_VAR 0 9
18777: PUSH
18778: LD_INT 1
18780: ST_TO_ADDR
// if i_from > i_to then
18781: LD_VAR 0 2
18785: PUSH
18786: LD_VAR 0 3
18790: GREATER
18791: IFFALSE 18817
// length := ( array - i_from ) + i_to else
18793: LD_ADDR_VAR 0 11
18797: PUSH
18798: LD_VAR 0 1
18802: PUSH
18803: LD_VAR 0 2
18807: MINUS
18808: PUSH
18809: LD_VAR 0 3
18813: PLUS
18814: ST_TO_ADDR
18815: GO 18833
// length := i_to - i_from ;
18817: LD_ADDR_VAR 0 11
18821: PUSH
18822: LD_VAR 0 3
18826: PUSH
18827: LD_VAR 0 2
18831: MINUS
18832: ST_TO_ADDR
// end else
18833: GO 18896
// begin d := - 1 ;
18835: LD_ADDR_VAR 0 9
18839: PUSH
18840: LD_INT 1
18842: NEG
18843: ST_TO_ADDR
// if i_from > i_to then
18844: LD_VAR 0 2
18848: PUSH
18849: LD_VAR 0 3
18853: GREATER
18854: IFFALSE 18874
// length := i_from - i_to else
18856: LD_ADDR_VAR 0 11
18860: PUSH
18861: LD_VAR 0 2
18865: PUSH
18866: LD_VAR 0 3
18870: MINUS
18871: ST_TO_ADDR
18872: GO 18896
// length := ( array - i_to ) + i_from ;
18874: LD_ADDR_VAR 0 11
18878: PUSH
18879: LD_VAR 0 1
18883: PUSH
18884: LD_VAR 0 3
18888: MINUS
18889: PUSH
18890: LD_VAR 0 2
18894: PLUS
18895: ST_TO_ADDR
// end ; if not length then
18896: LD_VAR 0 11
18900: NOT
18901: IFFALSE 18905
// exit ;
18903: GO 19063
// tmp := array ;
18905: LD_ADDR_VAR 0 10
18909: PUSH
18910: LD_VAR 0 1
18914: ST_TO_ADDR
// for i = 1 to length do
18915: LD_ADDR_VAR 0 6
18919: PUSH
18920: DOUBLE
18921: LD_INT 1
18923: DEC
18924: ST_TO_ADDR
18925: LD_VAR 0 11
18929: PUSH
18930: FOR_TO
18931: IFFALSE 19051
// begin for j = 1 to array do
18933: LD_ADDR_VAR 0 7
18937: PUSH
18938: DOUBLE
18939: LD_INT 1
18941: DEC
18942: ST_TO_ADDR
18943: LD_VAR 0 1
18947: PUSH
18948: FOR_TO
18949: IFFALSE 19037
// begin k := j + d ;
18951: LD_ADDR_VAR 0 8
18955: PUSH
18956: LD_VAR 0 7
18960: PUSH
18961: LD_VAR 0 9
18965: PLUS
18966: ST_TO_ADDR
// if k > array then
18967: LD_VAR 0 8
18971: PUSH
18972: LD_VAR 0 1
18976: GREATER
18977: IFFALSE 18987
// k := 1 ;
18979: LD_ADDR_VAR 0 8
18983: PUSH
18984: LD_INT 1
18986: ST_TO_ADDR
// if not k then
18987: LD_VAR 0 8
18991: NOT
18992: IFFALSE 19004
// k := array ;
18994: LD_ADDR_VAR 0 8
18998: PUSH
18999: LD_VAR 0 1
19003: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19004: LD_ADDR_VAR 0 10
19008: PUSH
19009: LD_VAR 0 10
19013: PPUSH
19014: LD_VAR 0 8
19018: PPUSH
19019: LD_VAR 0 1
19023: PUSH
19024: LD_VAR 0 7
19028: ARRAY
19029: PPUSH
19030: CALL_OW 1
19034: ST_TO_ADDR
// end ;
19035: GO 18948
19037: POP
19038: POP
// array := tmp ;
19039: LD_ADDR_VAR 0 1
19043: PUSH
19044: LD_VAR 0 10
19048: ST_TO_ADDR
// end ;
19049: GO 18930
19051: POP
19052: POP
// result := array ;
19053: LD_ADDR_VAR 0 5
19057: PUSH
19058: LD_VAR 0 1
19062: ST_TO_ADDR
// end ;
19063: LD_VAR 0 5
19067: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19068: LD_INT 0
19070: PPUSH
19071: PPUSH
// result := 0 ;
19072: LD_ADDR_VAR 0 3
19076: PUSH
19077: LD_INT 0
19079: ST_TO_ADDR
// if not array or not value in array then
19080: LD_VAR 0 1
19084: NOT
19085: PUSH
19086: LD_VAR 0 2
19090: PUSH
19091: LD_VAR 0 1
19095: IN
19096: NOT
19097: OR
19098: IFFALSE 19102
// exit ;
19100: GO 19156
// for i = 1 to array do
19102: LD_ADDR_VAR 0 4
19106: PUSH
19107: DOUBLE
19108: LD_INT 1
19110: DEC
19111: ST_TO_ADDR
19112: LD_VAR 0 1
19116: PUSH
19117: FOR_TO
19118: IFFALSE 19154
// if value = array [ i ] then
19120: LD_VAR 0 2
19124: PUSH
19125: LD_VAR 0 1
19129: PUSH
19130: LD_VAR 0 4
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19152
// begin result := i ;
19138: LD_ADDR_VAR 0 3
19142: PUSH
19143: LD_VAR 0 4
19147: ST_TO_ADDR
// exit ;
19148: POP
19149: POP
19150: GO 19156
// end ;
19152: GO 19117
19154: POP
19155: POP
// end ;
19156: LD_VAR 0 3
19160: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19161: LD_INT 0
19163: PPUSH
// vc_chassis := chassis ;
19164: LD_ADDR_OWVAR 37
19168: PUSH
19169: LD_VAR 0 1
19173: ST_TO_ADDR
// vc_engine := engine ;
19174: LD_ADDR_OWVAR 39
19178: PUSH
19179: LD_VAR 0 2
19183: ST_TO_ADDR
// vc_control := control ;
19184: LD_ADDR_OWVAR 38
19188: PUSH
19189: LD_VAR 0 3
19193: ST_TO_ADDR
// vc_weapon := weapon ;
19194: LD_ADDR_OWVAR 40
19198: PUSH
19199: LD_VAR 0 4
19203: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19204: LD_ADDR_OWVAR 41
19208: PUSH
19209: LD_VAR 0 5
19213: ST_TO_ADDR
// end ;
19214: LD_VAR 0 6
19218: RET
// export function WantPlant ( unit ) ; var task ; begin
19219: LD_INT 0
19221: PPUSH
19222: PPUSH
// result := false ;
19223: LD_ADDR_VAR 0 2
19227: PUSH
19228: LD_INT 0
19230: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19231: LD_ADDR_VAR 0 3
19235: PUSH
19236: LD_VAR 0 1
19240: PPUSH
19241: CALL_OW 437
19245: ST_TO_ADDR
// if task then
19246: LD_VAR 0 3
19250: IFFALSE 19278
// if task [ 1 ] [ 1 ] = p then
19252: LD_VAR 0 3
19256: PUSH
19257: LD_INT 1
19259: ARRAY
19260: PUSH
19261: LD_INT 1
19263: ARRAY
19264: PUSH
19265: LD_STRING p
19267: EQUAL
19268: IFFALSE 19278
// result := true ;
19270: LD_ADDR_VAR 0 2
19274: PUSH
19275: LD_INT 1
19277: ST_TO_ADDR
// end ;
19278: LD_VAR 0 2
19282: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19283: LD_INT 0
19285: PPUSH
19286: PPUSH
19287: PPUSH
19288: PPUSH
// if pos < 1 then
19289: LD_VAR 0 2
19293: PUSH
19294: LD_INT 1
19296: LESS
19297: IFFALSE 19301
// exit ;
19299: GO 19604
// if pos = 1 then
19301: LD_VAR 0 2
19305: PUSH
19306: LD_INT 1
19308: EQUAL
19309: IFFALSE 19342
// result := Replace ( arr , pos [ 1 ] , value ) else
19311: LD_ADDR_VAR 0 4
19315: PUSH
19316: LD_VAR 0 1
19320: PPUSH
19321: LD_VAR 0 2
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: PPUSH
19330: LD_VAR 0 3
19334: PPUSH
19335: CALL_OW 1
19339: ST_TO_ADDR
19340: GO 19604
// begin tmp := arr ;
19342: LD_ADDR_VAR 0 6
19346: PUSH
19347: LD_VAR 0 1
19351: ST_TO_ADDR
// s_arr := [ tmp ] ;
19352: LD_ADDR_VAR 0 7
19356: PUSH
19357: LD_VAR 0 6
19361: PUSH
19362: EMPTY
19363: LIST
19364: ST_TO_ADDR
// for i = 1 to pos - 1 do
19365: LD_ADDR_VAR 0 5
19369: PUSH
19370: DOUBLE
19371: LD_INT 1
19373: DEC
19374: ST_TO_ADDR
19375: LD_VAR 0 2
19379: PUSH
19380: LD_INT 1
19382: MINUS
19383: PUSH
19384: FOR_TO
19385: IFFALSE 19430
// begin tmp := tmp [ pos [ i ] ] ;
19387: LD_ADDR_VAR 0 6
19391: PUSH
19392: LD_VAR 0 6
19396: PUSH
19397: LD_VAR 0 2
19401: PUSH
19402: LD_VAR 0 5
19406: ARRAY
19407: ARRAY
19408: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19409: LD_ADDR_VAR 0 7
19413: PUSH
19414: LD_VAR 0 7
19418: PUSH
19419: LD_VAR 0 6
19423: PUSH
19424: EMPTY
19425: LIST
19426: ADD
19427: ST_TO_ADDR
// end ;
19428: GO 19384
19430: POP
19431: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19432: LD_ADDR_VAR 0 6
19436: PUSH
19437: LD_VAR 0 6
19441: PPUSH
19442: LD_VAR 0 2
19446: PUSH
19447: LD_VAR 0 2
19451: ARRAY
19452: PPUSH
19453: LD_VAR 0 3
19457: PPUSH
19458: CALL_OW 1
19462: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19463: LD_ADDR_VAR 0 7
19467: PUSH
19468: LD_VAR 0 7
19472: PPUSH
19473: LD_VAR 0 7
19477: PPUSH
19478: LD_VAR 0 6
19482: PPUSH
19483: CALL_OW 1
19487: ST_TO_ADDR
// for i = s_arr downto 2 do
19488: LD_ADDR_VAR 0 5
19492: PUSH
19493: DOUBLE
19494: LD_VAR 0 7
19498: INC
19499: ST_TO_ADDR
19500: LD_INT 2
19502: PUSH
19503: FOR_DOWNTO
19504: IFFALSE 19588
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 7
19515: PUSH
19516: LD_VAR 0 5
19520: PUSH
19521: LD_INT 1
19523: MINUS
19524: ARRAY
19525: PPUSH
19526: LD_VAR 0 2
19530: PUSH
19531: LD_VAR 0 5
19535: PUSH
19536: LD_INT 1
19538: MINUS
19539: ARRAY
19540: PPUSH
19541: LD_VAR 0 7
19545: PUSH
19546: LD_VAR 0 5
19550: ARRAY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19557: LD_ADDR_VAR 0 7
19561: PUSH
19562: LD_VAR 0 7
19566: PPUSH
19567: LD_VAR 0 5
19571: PUSH
19572: LD_INT 1
19574: MINUS
19575: PPUSH
19576: LD_VAR 0 6
19580: PPUSH
19581: CALL_OW 1
19585: ST_TO_ADDR
// end ;
19586: GO 19503
19588: POP
19589: POP
// result := s_arr [ 1 ] ;
19590: LD_ADDR_VAR 0 4
19594: PUSH
19595: LD_VAR 0 7
19599: PUSH
19600: LD_INT 1
19602: ARRAY
19603: ST_TO_ADDR
// end ; end ;
19604: LD_VAR 0 4
19608: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19609: LD_INT 0
19611: PPUSH
19612: PPUSH
// if not list then
19613: LD_VAR 0 1
19617: NOT
19618: IFFALSE 19622
// exit ;
19620: GO 19713
// i := list [ pos1 ] ;
19622: LD_ADDR_VAR 0 5
19626: PUSH
19627: LD_VAR 0 1
19631: PUSH
19632: LD_VAR 0 2
19636: ARRAY
19637: ST_TO_ADDR
// if not i then
19638: LD_VAR 0 5
19642: NOT
19643: IFFALSE 19647
// exit ;
19645: GO 19713
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19647: LD_ADDR_VAR 0 1
19651: PUSH
19652: LD_VAR 0 1
19656: PPUSH
19657: LD_VAR 0 2
19661: PPUSH
19662: LD_VAR 0 1
19666: PUSH
19667: LD_VAR 0 3
19671: ARRAY
19672: PPUSH
19673: CALL_OW 1
19677: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19678: LD_ADDR_VAR 0 1
19682: PUSH
19683: LD_VAR 0 1
19687: PPUSH
19688: LD_VAR 0 3
19692: PPUSH
19693: LD_VAR 0 5
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// result := list ;
19703: LD_ADDR_VAR 0 4
19707: PUSH
19708: LD_VAR 0 1
19712: ST_TO_ADDR
// end ;
19713: LD_VAR 0 4
19717: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19718: LD_INT 0
19720: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19721: LD_ADDR_VAR 0 5
19725: PUSH
19726: LD_VAR 0 1
19730: PPUSH
19731: CALL_OW 250
19735: PPUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: CALL_OW 251
19745: PPUSH
19746: LD_VAR 0 2
19750: PPUSH
19751: LD_VAR 0 3
19755: PPUSH
19756: LD_VAR 0 4
19760: PPUSH
19761: CALL 19771 0 5
19765: ST_TO_ADDR
// end ;
19766: LD_VAR 0 5
19770: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19771: LD_INT 0
19773: PPUSH
19774: PPUSH
19775: PPUSH
19776: PPUSH
// if not list then
19777: LD_VAR 0 3
19781: NOT
19782: IFFALSE 19786
// exit ;
19784: GO 20174
// result := [ ] ;
19786: LD_ADDR_VAR 0 6
19790: PUSH
19791: EMPTY
19792: ST_TO_ADDR
// for i in list do
19793: LD_ADDR_VAR 0 7
19797: PUSH
19798: LD_VAR 0 3
19802: PUSH
19803: FOR_IN
19804: IFFALSE 20006
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19806: LD_ADDR_VAR 0 9
19810: PUSH
19811: LD_VAR 0 7
19815: PPUSH
19816: LD_VAR 0 1
19820: PPUSH
19821: LD_VAR 0 2
19825: PPUSH
19826: CALL_OW 297
19830: ST_TO_ADDR
// if not result then
19831: LD_VAR 0 6
19835: NOT
19836: IFFALSE 19862
// result := [ [ i , tmp ] ] else
19838: LD_ADDR_VAR 0 6
19842: PUSH
19843: LD_VAR 0 7
19847: PUSH
19848: LD_VAR 0 9
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: PUSH
19857: EMPTY
19858: LIST
19859: ST_TO_ADDR
19860: GO 20004
// begin if result [ result ] [ 2 ] < tmp then
19862: LD_VAR 0 6
19866: PUSH
19867: LD_VAR 0 6
19871: ARRAY
19872: PUSH
19873: LD_INT 2
19875: ARRAY
19876: PUSH
19877: LD_VAR 0 9
19881: LESS
19882: IFFALSE 19924
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19884: LD_ADDR_VAR 0 6
19888: PUSH
19889: LD_VAR 0 6
19893: PPUSH
19894: LD_VAR 0 6
19898: PUSH
19899: LD_INT 1
19901: PLUS
19902: PPUSH
19903: LD_VAR 0 7
19907: PUSH
19908: LD_VAR 0 9
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: PPUSH
19917: CALL_OW 2
19921: ST_TO_ADDR
19922: GO 20004
// for j = 1 to result do
19924: LD_ADDR_VAR 0 8
19928: PUSH
19929: DOUBLE
19930: LD_INT 1
19932: DEC
19933: ST_TO_ADDR
19934: LD_VAR 0 6
19938: PUSH
19939: FOR_TO
19940: IFFALSE 20002
// begin if tmp < result [ j ] [ 2 ] then
19942: LD_VAR 0 9
19946: PUSH
19947: LD_VAR 0 6
19951: PUSH
19952: LD_VAR 0 8
19956: ARRAY
19957: PUSH
19958: LD_INT 2
19960: ARRAY
19961: LESS
19962: IFFALSE 20000
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19964: LD_ADDR_VAR 0 6
19968: PUSH
19969: LD_VAR 0 6
19973: PPUSH
19974: LD_VAR 0 8
19978: PPUSH
19979: LD_VAR 0 7
19983: PUSH
19984: LD_VAR 0 9
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PPUSH
19993: CALL_OW 2
19997: ST_TO_ADDR
// break ;
19998: GO 20002
// end ; end ;
20000: GO 19939
20002: POP
20003: POP
// end ; end ;
20004: GO 19803
20006: POP
20007: POP
// if result and not asc then
20008: LD_VAR 0 6
20012: PUSH
20013: LD_VAR 0 4
20017: NOT
20018: AND
20019: IFFALSE 20094
// begin tmp := result ;
20021: LD_ADDR_VAR 0 9
20025: PUSH
20026: LD_VAR 0 6
20030: ST_TO_ADDR
// for i = tmp downto 1 do
20031: LD_ADDR_VAR 0 7
20035: PUSH
20036: DOUBLE
20037: LD_VAR 0 9
20041: INC
20042: ST_TO_ADDR
20043: LD_INT 1
20045: PUSH
20046: FOR_DOWNTO
20047: IFFALSE 20092
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20049: LD_ADDR_VAR 0 6
20053: PUSH
20054: LD_VAR 0 6
20058: PPUSH
20059: LD_VAR 0 9
20063: PUSH
20064: LD_VAR 0 7
20068: MINUS
20069: PUSH
20070: LD_INT 1
20072: PLUS
20073: PPUSH
20074: LD_VAR 0 9
20078: PUSH
20079: LD_VAR 0 7
20083: ARRAY
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
20090: GO 20046
20092: POP
20093: POP
// end ; tmp := [ ] ;
20094: LD_ADDR_VAR 0 9
20098: PUSH
20099: EMPTY
20100: ST_TO_ADDR
// if mode then
20101: LD_VAR 0 5
20105: IFFALSE 20174
// begin for i = 1 to result do
20107: LD_ADDR_VAR 0 7
20111: PUSH
20112: DOUBLE
20113: LD_INT 1
20115: DEC
20116: ST_TO_ADDR
20117: LD_VAR 0 6
20121: PUSH
20122: FOR_TO
20123: IFFALSE 20162
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20125: LD_ADDR_VAR 0 9
20129: PUSH
20130: LD_VAR 0 9
20134: PPUSH
20135: LD_VAR 0 7
20139: PPUSH
20140: LD_VAR 0 6
20144: PUSH
20145: LD_VAR 0 7
20149: ARRAY
20150: PUSH
20151: LD_INT 1
20153: ARRAY
20154: PPUSH
20155: CALL_OW 1
20159: ST_TO_ADDR
20160: GO 20122
20162: POP
20163: POP
// result := tmp ;
20164: LD_ADDR_VAR 0 6
20168: PUSH
20169: LD_VAR 0 9
20173: ST_TO_ADDR
// end ; end ;
20174: LD_VAR 0 6
20178: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20179: LD_INT 0
20181: PPUSH
20182: PPUSH
20183: PPUSH
20184: PPUSH
20185: PPUSH
20186: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20187: LD_ADDR_VAR 0 5
20191: PUSH
20192: LD_INT 0
20194: PUSH
20195: LD_INT 0
20197: PUSH
20198: LD_INT 0
20200: PUSH
20201: EMPTY
20202: PUSH
20203: EMPTY
20204: LIST
20205: LIST
20206: LIST
20207: LIST
20208: ST_TO_ADDR
// if not x or not y then
20209: LD_VAR 0 2
20213: NOT
20214: PUSH
20215: LD_VAR 0 3
20219: NOT
20220: OR
20221: IFFALSE 20225
// exit ;
20223: GO 21871
// if not range then
20225: LD_VAR 0 4
20229: NOT
20230: IFFALSE 20240
// range := 10 ;
20232: LD_ADDR_VAR 0 4
20236: PUSH
20237: LD_INT 10
20239: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20240: LD_ADDR_VAR 0 8
20244: PUSH
20245: LD_INT 81
20247: PUSH
20248: LD_VAR 0 1
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: PUSH
20257: LD_INT 92
20259: PUSH
20260: LD_VAR 0 2
20264: PUSH
20265: LD_VAR 0 3
20269: PUSH
20270: LD_VAR 0 4
20274: PUSH
20275: EMPTY
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: PUSH
20281: LD_INT 3
20283: PUSH
20284: LD_INT 21
20286: PUSH
20287: LD_INT 3
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: LIST
20302: PPUSH
20303: CALL_OW 69
20307: ST_TO_ADDR
// if not tmp then
20308: LD_VAR 0 8
20312: NOT
20313: IFFALSE 20317
// exit ;
20315: GO 21871
// for i in tmp do
20317: LD_ADDR_VAR 0 6
20321: PUSH
20322: LD_VAR 0 8
20326: PUSH
20327: FOR_IN
20328: IFFALSE 21846
// begin points := [ 0 , 0 , 0 ] ;
20330: LD_ADDR_VAR 0 9
20334: PUSH
20335: LD_INT 0
20337: PUSH
20338: LD_INT 0
20340: PUSH
20341: LD_INT 0
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: LIST
20348: ST_TO_ADDR
// bpoints := 1 ;
20349: LD_ADDR_VAR 0 10
20353: PUSH
20354: LD_INT 1
20356: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20357: LD_VAR 0 6
20361: PPUSH
20362: CALL_OW 247
20366: PUSH
20367: LD_INT 1
20369: DOUBLE
20370: EQUAL
20371: IFTRUE 20375
20373: GO 20953
20375: POP
// begin if GetClass ( i ) = 1 then
20376: LD_VAR 0 6
20380: PPUSH
20381: CALL_OW 257
20385: PUSH
20386: LD_INT 1
20388: EQUAL
20389: IFFALSE 20410
// points := [ 10 , 5 , 3 ] ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 10
20398: PUSH
20399: LD_INT 5
20401: PUSH
20402: LD_INT 3
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20410: LD_VAR 0 6
20414: PPUSH
20415: CALL_OW 257
20419: PUSH
20420: LD_INT 2
20422: PUSH
20423: LD_INT 3
20425: PUSH
20426: LD_INT 4
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: LIST
20433: IN
20434: IFFALSE 20455
// points := [ 3 , 2 , 1 ] ;
20436: LD_ADDR_VAR 0 9
20440: PUSH
20441: LD_INT 3
20443: PUSH
20444: LD_INT 2
20446: PUSH
20447: LD_INT 1
20449: PUSH
20450: EMPTY
20451: LIST
20452: LIST
20453: LIST
20454: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20455: LD_VAR 0 6
20459: PPUSH
20460: CALL_OW 257
20464: PUSH
20465: LD_INT 5
20467: EQUAL
20468: IFFALSE 20489
// points := [ 130 , 5 , 2 ] ;
20470: LD_ADDR_VAR 0 9
20474: PUSH
20475: LD_INT 130
20477: PUSH
20478: LD_INT 5
20480: PUSH
20481: LD_INT 2
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20489: LD_VAR 0 6
20493: PPUSH
20494: CALL_OW 257
20498: PUSH
20499: LD_INT 8
20501: EQUAL
20502: IFFALSE 20523
// points := [ 35 , 35 , 30 ] ;
20504: LD_ADDR_VAR 0 9
20508: PUSH
20509: LD_INT 35
20511: PUSH
20512: LD_INT 35
20514: PUSH
20515: LD_INT 30
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: LIST
20522: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20523: LD_VAR 0 6
20527: PPUSH
20528: CALL_OW 257
20532: PUSH
20533: LD_INT 9
20535: EQUAL
20536: IFFALSE 20557
// points := [ 20 , 55 , 40 ] ;
20538: LD_ADDR_VAR 0 9
20542: PUSH
20543: LD_INT 20
20545: PUSH
20546: LD_INT 55
20548: PUSH
20549: LD_INT 40
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: LIST
20556: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20557: LD_VAR 0 6
20561: PPUSH
20562: CALL_OW 257
20566: PUSH
20567: LD_INT 12
20569: PUSH
20570: LD_INT 16
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: IN
20577: IFFALSE 20598
// points := [ 5 , 3 , 2 ] ;
20579: LD_ADDR_VAR 0 9
20583: PUSH
20584: LD_INT 5
20586: PUSH
20587: LD_INT 3
20589: PUSH
20590: LD_INT 2
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: LIST
20597: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20598: LD_VAR 0 6
20602: PPUSH
20603: CALL_OW 257
20607: PUSH
20608: LD_INT 17
20610: EQUAL
20611: IFFALSE 20632
// points := [ 100 , 50 , 75 ] ;
20613: LD_ADDR_VAR 0 9
20617: PUSH
20618: LD_INT 100
20620: PUSH
20621: LD_INT 50
20623: PUSH
20624: LD_INT 75
20626: PUSH
20627: EMPTY
20628: LIST
20629: LIST
20630: LIST
20631: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20632: LD_VAR 0 6
20636: PPUSH
20637: CALL_OW 257
20641: PUSH
20642: LD_INT 15
20644: EQUAL
20645: IFFALSE 20666
// points := [ 10 , 5 , 3 ] ;
20647: LD_ADDR_VAR 0 9
20651: PUSH
20652: LD_INT 10
20654: PUSH
20655: LD_INT 5
20657: PUSH
20658: LD_INT 3
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: LIST
20665: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20666: LD_VAR 0 6
20670: PPUSH
20671: CALL_OW 257
20675: PUSH
20676: LD_INT 14
20678: EQUAL
20679: IFFALSE 20700
// points := [ 10 , 0 , 0 ] ;
20681: LD_ADDR_VAR 0 9
20685: PUSH
20686: LD_INT 10
20688: PUSH
20689: LD_INT 0
20691: PUSH
20692: LD_INT 0
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: LIST
20699: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20700: LD_VAR 0 6
20704: PPUSH
20705: CALL_OW 257
20709: PUSH
20710: LD_INT 11
20712: EQUAL
20713: IFFALSE 20734
// points := [ 30 , 10 , 5 ] ;
20715: LD_ADDR_VAR 0 9
20719: PUSH
20720: LD_INT 30
20722: PUSH
20723: LD_INT 10
20725: PUSH
20726: LD_INT 5
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20734: LD_VAR 0 1
20738: PPUSH
20739: LD_INT 5
20741: PPUSH
20742: CALL_OW 321
20746: PUSH
20747: LD_INT 2
20749: EQUAL
20750: IFFALSE 20767
// bpoints := bpoints * 1.8 ;
20752: LD_ADDR_VAR 0 10
20756: PUSH
20757: LD_VAR 0 10
20761: PUSH
20762: LD_REAL  1.80000000000000E+0000
20765: MUL
20766: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20767: LD_VAR 0 6
20771: PPUSH
20772: CALL_OW 257
20776: PUSH
20777: LD_INT 1
20779: PUSH
20780: LD_INT 2
20782: PUSH
20783: LD_INT 3
20785: PUSH
20786: LD_INT 4
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: IN
20795: PUSH
20796: LD_VAR 0 1
20800: PPUSH
20801: LD_INT 51
20803: PPUSH
20804: CALL_OW 321
20808: PUSH
20809: LD_INT 2
20811: EQUAL
20812: AND
20813: IFFALSE 20830
// bpoints := bpoints * 1.2 ;
20815: LD_ADDR_VAR 0 10
20819: PUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_REAL  1.20000000000000E+0000
20828: MUL
20829: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20830: LD_VAR 0 6
20834: PPUSH
20835: CALL_OW 257
20839: PUSH
20840: LD_INT 5
20842: PUSH
20843: LD_INT 7
20845: PUSH
20846: LD_INT 9
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: LIST
20853: IN
20854: PUSH
20855: LD_VAR 0 1
20859: PPUSH
20860: LD_INT 52
20862: PPUSH
20863: CALL_OW 321
20867: PUSH
20868: LD_INT 2
20870: EQUAL
20871: AND
20872: IFFALSE 20889
// bpoints := bpoints * 1.5 ;
20874: LD_ADDR_VAR 0 10
20878: PUSH
20879: LD_VAR 0 10
20883: PUSH
20884: LD_REAL  1.50000000000000E+0000
20887: MUL
20888: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20889: LD_VAR 0 1
20893: PPUSH
20894: LD_INT 66
20896: PPUSH
20897: CALL_OW 321
20901: PUSH
20902: LD_INT 2
20904: EQUAL
20905: IFFALSE 20922
// bpoints := bpoints * 1.1 ;
20907: LD_ADDR_VAR 0 10
20911: PUSH
20912: LD_VAR 0 10
20916: PUSH
20917: LD_REAL  1.10000000000000E+0000
20920: MUL
20921: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20922: LD_ADDR_VAR 0 10
20926: PUSH
20927: LD_VAR 0 10
20931: PUSH
20932: LD_VAR 0 6
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 259
20944: PUSH
20945: LD_REAL  1.15000000000000E+0000
20948: MUL
20949: MUL
20950: ST_TO_ADDR
// end ; unit_vehicle :
20951: GO 21775
20953: LD_INT 2
20955: DOUBLE
20956: EQUAL
20957: IFTRUE 20961
20959: GO 21763
20961: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 264
20971: PUSH
20972: LD_INT 2
20974: PUSH
20975: LD_INT 42
20977: PUSH
20978: LD_INT 24
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: LIST
20985: IN
20986: IFFALSE 21007
// points := [ 25 , 5 , 3 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 25
20995: PUSH
20996: LD_INT 5
20998: PUSH
20999: LD_INT 3
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 264
21016: PUSH
21017: LD_INT 4
21019: PUSH
21020: LD_INT 43
21022: PUSH
21023: LD_INT 25
21025: PUSH
21026: EMPTY
21027: LIST
21028: LIST
21029: LIST
21030: IN
21031: IFFALSE 21052
// points := [ 40 , 15 , 5 ] ;
21033: LD_ADDR_VAR 0 9
21037: PUSH
21038: LD_INT 40
21040: PUSH
21041: LD_INT 15
21043: PUSH
21044: LD_INT 5
21046: PUSH
21047: EMPTY
21048: LIST
21049: LIST
21050: LIST
21051: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21052: LD_VAR 0 6
21056: PPUSH
21057: CALL_OW 264
21061: PUSH
21062: LD_INT 3
21064: PUSH
21065: LD_INT 23
21067: PUSH
21068: EMPTY
21069: LIST
21070: LIST
21071: IN
21072: IFFALSE 21093
// points := [ 7 , 25 , 8 ] ;
21074: LD_ADDR_VAR 0 9
21078: PUSH
21079: LD_INT 7
21081: PUSH
21082: LD_INT 25
21084: PUSH
21085: LD_INT 8
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 264
21102: PUSH
21103: LD_INT 5
21105: PUSH
21106: LD_INT 27
21108: PUSH
21109: LD_INT 44
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: LIST
21116: IN
21117: IFFALSE 21138
// points := [ 14 , 50 , 16 ] ;
21119: LD_ADDR_VAR 0 9
21123: PUSH
21124: LD_INT 14
21126: PUSH
21127: LD_INT 50
21129: PUSH
21130: LD_INT 16
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: LIST
21137: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21138: LD_VAR 0 6
21142: PPUSH
21143: CALL_OW 264
21147: PUSH
21148: LD_INT 6
21150: PUSH
21151: LD_INT 46
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: IN
21158: IFFALSE 21179
// points := [ 32 , 120 , 70 ] ;
21160: LD_ADDR_VAR 0 9
21164: PUSH
21165: LD_INT 32
21167: PUSH
21168: LD_INT 120
21170: PUSH
21171: LD_INT 70
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21179: LD_VAR 0 6
21183: PPUSH
21184: CALL_OW 264
21188: PUSH
21189: LD_INT 7
21191: PUSH
21192: LD_INT 28
21194: PUSH
21195: LD_INT 45
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: LIST
21202: IN
21203: IFFALSE 21224
// points := [ 35 , 20 , 45 ] ;
21205: LD_ADDR_VAR 0 9
21209: PUSH
21210: LD_INT 35
21212: PUSH
21213: LD_INT 20
21215: PUSH
21216: LD_INT 45
21218: PUSH
21219: EMPTY
21220: LIST
21221: LIST
21222: LIST
21223: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21224: LD_VAR 0 6
21228: PPUSH
21229: CALL_OW 264
21233: PUSH
21234: LD_INT 47
21236: PUSH
21237: EMPTY
21238: LIST
21239: IN
21240: IFFALSE 21261
// points := [ 67 , 45 , 75 ] ;
21242: LD_ADDR_VAR 0 9
21246: PUSH
21247: LD_INT 67
21249: PUSH
21250: LD_INT 45
21252: PUSH
21253: LD_INT 75
21255: PUSH
21256: EMPTY
21257: LIST
21258: LIST
21259: LIST
21260: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21261: LD_VAR 0 6
21265: PPUSH
21266: CALL_OW 264
21270: PUSH
21271: LD_INT 26
21273: PUSH
21274: EMPTY
21275: LIST
21276: IN
21277: IFFALSE 21298
// points := [ 120 , 30 , 80 ] ;
21279: LD_ADDR_VAR 0 9
21283: PUSH
21284: LD_INT 120
21286: PUSH
21287: LD_INT 30
21289: PUSH
21290: LD_INT 80
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: LIST
21297: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21298: LD_VAR 0 6
21302: PPUSH
21303: CALL_OW 264
21307: PUSH
21308: LD_INT 22
21310: PUSH
21311: EMPTY
21312: LIST
21313: IN
21314: IFFALSE 21335
// points := [ 40 , 1 , 1 ] ;
21316: LD_ADDR_VAR 0 9
21320: PUSH
21321: LD_INT 40
21323: PUSH
21324: LD_INT 1
21326: PUSH
21327: LD_INT 1
21329: PUSH
21330: EMPTY
21331: LIST
21332: LIST
21333: LIST
21334: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21335: LD_VAR 0 6
21339: PPUSH
21340: CALL_OW 264
21344: PUSH
21345: LD_INT 29
21347: PUSH
21348: EMPTY
21349: LIST
21350: IN
21351: IFFALSE 21372
// points := [ 70 , 200 , 400 ] ;
21353: LD_ADDR_VAR 0 9
21357: PUSH
21358: LD_INT 70
21360: PUSH
21361: LD_INT 200
21363: PUSH
21364: LD_INT 400
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21372: LD_VAR 0 6
21376: PPUSH
21377: CALL_OW 264
21381: PUSH
21382: LD_INT 14
21384: PUSH
21385: LD_INT 53
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: IN
21392: IFFALSE 21413
// points := [ 40 , 10 , 20 ] ;
21394: LD_ADDR_VAR 0 9
21398: PUSH
21399: LD_INT 40
21401: PUSH
21402: LD_INT 10
21404: PUSH
21405: LD_INT 20
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: LIST
21412: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21413: LD_VAR 0 6
21417: PPUSH
21418: CALL_OW 264
21422: PUSH
21423: LD_INT 9
21425: PUSH
21426: EMPTY
21427: LIST
21428: IN
21429: IFFALSE 21450
// points := [ 5 , 70 , 20 ] ;
21431: LD_ADDR_VAR 0 9
21435: PUSH
21436: LD_INT 5
21438: PUSH
21439: LD_INT 70
21441: PUSH
21442: LD_INT 20
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: LIST
21449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21450: LD_VAR 0 6
21454: PPUSH
21455: CALL_OW 264
21459: PUSH
21460: LD_INT 10
21462: PUSH
21463: EMPTY
21464: LIST
21465: IN
21466: IFFALSE 21487
// points := [ 35 , 110 , 70 ] ;
21468: LD_ADDR_VAR 0 9
21472: PUSH
21473: LD_INT 35
21475: PUSH
21476: LD_INT 110
21478: PUSH
21479: LD_INT 70
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: LIST
21486: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21487: LD_VAR 0 6
21491: PPUSH
21492: CALL_OW 265
21496: PUSH
21497: LD_INT 25
21499: EQUAL
21500: IFFALSE 21521
// points := [ 80 , 65 , 100 ] ;
21502: LD_ADDR_VAR 0 9
21506: PUSH
21507: LD_INT 80
21509: PUSH
21510: LD_INT 65
21512: PUSH
21513: LD_INT 100
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21521: LD_VAR 0 6
21525: PPUSH
21526: CALL_OW 263
21530: PUSH
21531: LD_INT 1
21533: EQUAL
21534: IFFALSE 21569
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21536: LD_ADDR_VAR 0 10
21540: PUSH
21541: LD_VAR 0 10
21545: PUSH
21546: LD_VAR 0 6
21550: PPUSH
21551: CALL_OW 311
21555: PPUSH
21556: LD_INT 3
21558: PPUSH
21559: CALL_OW 259
21563: PUSH
21564: LD_INT 4
21566: MUL
21567: MUL
21568: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21569: LD_VAR 0 6
21573: PPUSH
21574: CALL_OW 263
21578: PUSH
21579: LD_INT 2
21581: EQUAL
21582: IFFALSE 21633
// begin j := IsControledBy ( i ) ;
21584: LD_ADDR_VAR 0 7
21588: PUSH
21589: LD_VAR 0 6
21593: PPUSH
21594: CALL_OW 312
21598: ST_TO_ADDR
// if j then
21599: LD_VAR 0 7
21603: IFFALSE 21633
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21605: LD_ADDR_VAR 0 10
21609: PUSH
21610: LD_VAR 0 10
21614: PUSH
21615: LD_VAR 0 7
21619: PPUSH
21620: LD_INT 3
21622: PPUSH
21623: CALL_OW 259
21627: PUSH
21628: LD_INT 3
21630: MUL
21631: MUL
21632: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21633: LD_VAR 0 6
21637: PPUSH
21638: CALL_OW 264
21642: PUSH
21643: LD_INT 5
21645: PUSH
21646: LD_INT 6
21648: PUSH
21649: LD_INT 46
21651: PUSH
21652: LD_INT 44
21654: PUSH
21655: LD_INT 47
21657: PUSH
21658: LD_INT 45
21660: PUSH
21661: LD_INT 28
21663: PUSH
21664: LD_INT 7
21666: PUSH
21667: LD_INT 27
21669: PUSH
21670: LD_INT 29
21672: PUSH
21673: EMPTY
21674: LIST
21675: LIST
21676: LIST
21677: LIST
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: IN
21685: PUSH
21686: LD_VAR 0 1
21690: PPUSH
21691: LD_INT 52
21693: PPUSH
21694: CALL_OW 321
21698: PUSH
21699: LD_INT 2
21701: EQUAL
21702: AND
21703: IFFALSE 21720
// bpoints := bpoints * 1.2 ;
21705: LD_ADDR_VAR 0 10
21709: PUSH
21710: LD_VAR 0 10
21714: PUSH
21715: LD_REAL  1.20000000000000E+0000
21718: MUL
21719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21720: LD_VAR 0 6
21724: PPUSH
21725: CALL_OW 264
21729: PUSH
21730: LD_INT 6
21732: PUSH
21733: LD_INT 46
21735: PUSH
21736: LD_INT 47
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: LIST
21743: IN
21744: IFFALSE 21761
// bpoints := bpoints * 1.2 ;
21746: LD_ADDR_VAR 0 10
21750: PUSH
21751: LD_VAR 0 10
21755: PUSH
21756: LD_REAL  1.20000000000000E+0000
21759: MUL
21760: ST_TO_ADDR
// end ; unit_building :
21761: GO 21775
21763: LD_INT 3
21765: DOUBLE
21766: EQUAL
21767: IFTRUE 21771
21769: GO 21774
21771: POP
// ; end ;
21772: GO 21775
21774: POP
// for j = 1 to 3 do
21775: LD_ADDR_VAR 0 7
21779: PUSH
21780: DOUBLE
21781: LD_INT 1
21783: DEC
21784: ST_TO_ADDR
21785: LD_INT 3
21787: PUSH
21788: FOR_TO
21789: IFFALSE 21842
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21791: LD_ADDR_VAR 0 5
21795: PUSH
21796: LD_VAR 0 5
21800: PPUSH
21801: LD_VAR 0 7
21805: PPUSH
21806: LD_VAR 0 5
21810: PUSH
21811: LD_VAR 0 7
21815: ARRAY
21816: PUSH
21817: LD_VAR 0 9
21821: PUSH
21822: LD_VAR 0 7
21826: ARRAY
21827: PUSH
21828: LD_VAR 0 10
21832: MUL
21833: PLUS
21834: PPUSH
21835: CALL_OW 1
21839: ST_TO_ADDR
21840: GO 21788
21842: POP
21843: POP
// end ;
21844: GO 20327
21846: POP
21847: POP
// result := Replace ( result , 4 , tmp ) ;
21848: LD_ADDR_VAR 0 5
21852: PUSH
21853: LD_VAR 0 5
21857: PPUSH
21858: LD_INT 4
21860: PPUSH
21861: LD_VAR 0 8
21865: PPUSH
21866: CALL_OW 1
21870: ST_TO_ADDR
// end ;
21871: LD_VAR 0 5
21875: RET
// export function DangerAtRange ( unit , range ) ; begin
21876: LD_INT 0
21878: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21879: LD_ADDR_VAR 0 3
21883: PUSH
21884: LD_VAR 0 1
21888: PPUSH
21889: CALL_OW 255
21893: PPUSH
21894: LD_VAR 0 1
21898: PPUSH
21899: CALL_OW 250
21903: PPUSH
21904: LD_VAR 0 1
21908: PPUSH
21909: CALL_OW 251
21913: PPUSH
21914: LD_VAR 0 2
21918: PPUSH
21919: CALL 20179 0 4
21923: ST_TO_ADDR
// end ;
21924: LD_VAR 0 3
21928: RET
// export function DangerInArea ( side , area ) ; begin
21929: LD_INT 0
21931: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21932: LD_ADDR_VAR 0 3
21936: PUSH
21937: LD_VAR 0 2
21941: PPUSH
21942: LD_INT 81
21944: PUSH
21945: LD_VAR 0 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PPUSH
21954: CALL_OW 70
21958: ST_TO_ADDR
// end ;
21959: LD_VAR 0 3
21963: RET
// export function IsExtension ( b ) ; begin
21964: LD_INT 0
21966: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21967: LD_ADDR_VAR 0 2
21971: PUSH
21972: LD_VAR 0 1
21976: PUSH
21977: LD_INT 23
21979: PUSH
21980: LD_INT 20
21982: PUSH
21983: LD_INT 22
21985: PUSH
21986: LD_INT 17
21988: PUSH
21989: LD_INT 24
21991: PUSH
21992: LD_INT 21
21994: PUSH
21995: LD_INT 19
21997: PUSH
21998: LD_INT 16
22000: PUSH
22001: LD_INT 25
22003: PUSH
22004: LD_INT 18
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: LIST
22011: LIST
22012: LIST
22013: LIST
22014: LIST
22015: LIST
22016: LIST
22017: LIST
22018: IN
22019: ST_TO_ADDR
// end ;
22020: LD_VAR 0 2
22024: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22025: LD_INT 0
22027: PPUSH
22028: PPUSH
22029: PPUSH
// result := [ ] ;
22030: LD_ADDR_VAR 0 4
22034: PUSH
22035: EMPTY
22036: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22037: LD_ADDR_VAR 0 5
22041: PUSH
22042: LD_VAR 0 2
22046: PPUSH
22047: LD_INT 21
22049: PUSH
22050: LD_INT 3
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PPUSH
22057: CALL_OW 70
22061: ST_TO_ADDR
// if not tmp then
22062: LD_VAR 0 5
22066: NOT
22067: IFFALSE 22071
// exit ;
22069: GO 22135
// if checkLink then
22071: LD_VAR 0 3
22075: IFFALSE 22125
// begin for i in tmp do
22077: LD_ADDR_VAR 0 6
22081: PUSH
22082: LD_VAR 0 5
22086: PUSH
22087: FOR_IN
22088: IFFALSE 22123
// if GetBase ( i ) <> base then
22090: LD_VAR 0 6
22094: PPUSH
22095: CALL_OW 274
22099: PUSH
22100: LD_VAR 0 1
22104: NONEQUAL
22105: IFFALSE 22121
// ComLinkToBase ( base , i ) ;
22107: LD_VAR 0 1
22111: PPUSH
22112: LD_VAR 0 6
22116: PPUSH
22117: CALL_OW 169
22121: GO 22087
22123: POP
22124: POP
// end ; result := tmp ;
22125: LD_ADDR_VAR 0 4
22129: PUSH
22130: LD_VAR 0 5
22134: ST_TO_ADDR
// end ;
22135: LD_VAR 0 4
22139: RET
// export function ComComplete ( units , b ) ; var i ; begin
22140: LD_INT 0
22142: PPUSH
22143: PPUSH
// if not units then
22144: LD_VAR 0 1
22148: NOT
22149: IFFALSE 22153
// exit ;
22151: GO 22243
// for i in units do
22153: LD_ADDR_VAR 0 4
22157: PUSH
22158: LD_VAR 0 1
22162: PUSH
22163: FOR_IN
22164: IFFALSE 22241
// if BuildingStatus ( b ) = bs_build then
22166: LD_VAR 0 2
22170: PPUSH
22171: CALL_OW 461
22175: PUSH
22176: LD_INT 1
22178: EQUAL
22179: IFFALSE 22239
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22181: LD_VAR 0 4
22185: PPUSH
22186: LD_STRING h
22188: PUSH
22189: LD_VAR 0 2
22193: PPUSH
22194: CALL_OW 250
22198: PUSH
22199: LD_VAR 0 2
22203: PPUSH
22204: CALL_OW 251
22208: PUSH
22209: LD_VAR 0 2
22213: PUSH
22214: LD_INT 0
22216: PUSH
22217: LD_INT 0
22219: PUSH
22220: LD_INT 0
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: LIST
22230: LIST
22231: PUSH
22232: EMPTY
22233: LIST
22234: PPUSH
22235: CALL_OW 446
22239: GO 22163
22241: POP
22242: POP
// end ;
22243: LD_VAR 0 3
22247: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22248: LD_INT 0
22250: PPUSH
22251: PPUSH
22252: PPUSH
22253: PPUSH
22254: PPUSH
22255: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22256: LD_VAR 0 1
22260: NOT
22261: PUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: CALL_OW 263
22271: PUSH
22272: LD_INT 2
22274: EQUAL
22275: NOT
22276: OR
22277: IFFALSE 22281
// exit ;
22279: GO 22597
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22281: LD_ADDR_VAR 0 6
22285: PUSH
22286: LD_INT 22
22288: PUSH
22289: LD_VAR 0 1
22293: PPUSH
22294: CALL_OW 255
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: LD_INT 2
22305: PUSH
22306: LD_INT 30
22308: PUSH
22309: LD_INT 36
22311: PUSH
22312: EMPTY
22313: LIST
22314: LIST
22315: PUSH
22316: LD_INT 34
22318: PUSH
22319: LD_INT 31
22321: PUSH
22322: EMPTY
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: LIST
22330: PUSH
22331: EMPTY
22332: LIST
22333: LIST
22334: PPUSH
22335: CALL_OW 69
22339: ST_TO_ADDR
// if not tmp then
22340: LD_VAR 0 6
22344: NOT
22345: IFFALSE 22349
// exit ;
22347: GO 22597
// result := [ ] ;
22349: LD_ADDR_VAR 0 2
22353: PUSH
22354: EMPTY
22355: ST_TO_ADDR
// for i in tmp do
22356: LD_ADDR_VAR 0 3
22360: PUSH
22361: LD_VAR 0 6
22365: PUSH
22366: FOR_IN
22367: IFFALSE 22438
// begin t := UnitsInside ( i ) ;
22369: LD_ADDR_VAR 0 4
22373: PUSH
22374: LD_VAR 0 3
22378: PPUSH
22379: CALL_OW 313
22383: ST_TO_ADDR
// if t then
22384: LD_VAR 0 4
22388: IFFALSE 22436
// for j in t do
22390: LD_ADDR_VAR 0 7
22394: PUSH
22395: LD_VAR 0 4
22399: PUSH
22400: FOR_IN
22401: IFFALSE 22434
// result := Insert ( result , result + 1 , j ) ;
22403: LD_ADDR_VAR 0 2
22407: PUSH
22408: LD_VAR 0 2
22412: PPUSH
22413: LD_VAR 0 2
22417: PUSH
22418: LD_INT 1
22420: PLUS
22421: PPUSH
22422: LD_VAR 0 7
22426: PPUSH
22427: CALL_OW 2
22431: ST_TO_ADDR
22432: GO 22400
22434: POP
22435: POP
// end ;
22436: GO 22366
22438: POP
22439: POP
// if not result then
22440: LD_VAR 0 2
22444: NOT
22445: IFFALSE 22449
// exit ;
22447: GO 22597
// mech := result [ 1 ] ;
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_VAR 0 2
22458: PUSH
22459: LD_INT 1
22461: ARRAY
22462: ST_TO_ADDR
// if result > 1 then
22463: LD_VAR 0 2
22467: PUSH
22468: LD_INT 1
22470: GREATER
22471: IFFALSE 22583
// for i = 2 to result do
22473: LD_ADDR_VAR 0 3
22477: PUSH
22478: DOUBLE
22479: LD_INT 2
22481: DEC
22482: ST_TO_ADDR
22483: LD_VAR 0 2
22487: PUSH
22488: FOR_TO
22489: IFFALSE 22581
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22491: LD_ADDR_VAR 0 4
22495: PUSH
22496: LD_VAR 0 2
22500: PUSH
22501: LD_VAR 0 3
22505: ARRAY
22506: PPUSH
22507: LD_INT 3
22509: PPUSH
22510: CALL_OW 259
22514: PUSH
22515: LD_VAR 0 2
22519: PUSH
22520: LD_VAR 0 3
22524: ARRAY
22525: PPUSH
22526: CALL_OW 432
22530: MINUS
22531: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22532: LD_VAR 0 4
22536: PUSH
22537: LD_VAR 0 5
22541: PPUSH
22542: LD_INT 3
22544: PPUSH
22545: CALL_OW 259
22549: PUSH
22550: LD_VAR 0 5
22554: PPUSH
22555: CALL_OW 432
22559: MINUS
22560: GREATEREQUAL
22561: IFFALSE 22579
// mech := result [ i ] ;
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_VAR 0 2
22572: PUSH
22573: LD_VAR 0 3
22577: ARRAY
22578: ST_TO_ADDR
// end ;
22579: GO 22488
22581: POP
22582: POP
// ComLinkTo ( vehicle , mech ) ;
22583: LD_VAR 0 1
22587: PPUSH
22588: LD_VAR 0 5
22592: PPUSH
22593: CALL_OW 135
// end ;
22597: LD_VAR 0 2
22601: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22602: LD_INT 0
22604: PPUSH
22605: PPUSH
22606: PPUSH
22607: PPUSH
22608: PPUSH
22609: PPUSH
22610: PPUSH
22611: PPUSH
22612: PPUSH
22613: PPUSH
22614: PPUSH
22615: PPUSH
22616: PPUSH
// result := [ ] ;
22617: LD_ADDR_VAR 0 7
22621: PUSH
22622: EMPTY
22623: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22624: LD_VAR 0 1
22628: PPUSH
22629: CALL_OW 266
22633: PUSH
22634: LD_INT 0
22636: PUSH
22637: LD_INT 1
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: IN
22644: NOT
22645: IFFALSE 22649
// exit ;
22647: GO 24283
// if name then
22649: LD_VAR 0 3
22653: IFFALSE 22669
// SetBName ( base_dep , name ) ;
22655: LD_VAR 0 1
22659: PPUSH
22660: LD_VAR 0 3
22664: PPUSH
22665: CALL_OW 500
// base := GetBase ( base_dep ) ;
22669: LD_ADDR_VAR 0 15
22673: PUSH
22674: LD_VAR 0 1
22678: PPUSH
22679: CALL_OW 274
22683: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22684: LD_ADDR_VAR 0 16
22688: PUSH
22689: LD_VAR 0 1
22693: PPUSH
22694: CALL_OW 255
22698: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22699: LD_ADDR_VAR 0 17
22703: PUSH
22704: LD_VAR 0 1
22708: PPUSH
22709: CALL_OW 248
22713: ST_TO_ADDR
// if sources then
22714: LD_VAR 0 5
22718: IFFALSE 22765
// for i = 1 to 3 do
22720: LD_ADDR_VAR 0 8
22724: PUSH
22725: DOUBLE
22726: LD_INT 1
22728: DEC
22729: ST_TO_ADDR
22730: LD_INT 3
22732: PUSH
22733: FOR_TO
22734: IFFALSE 22763
// AddResourceType ( base , i , sources [ i ] ) ;
22736: LD_VAR 0 15
22740: PPUSH
22741: LD_VAR 0 8
22745: PPUSH
22746: LD_VAR 0 5
22750: PUSH
22751: LD_VAR 0 8
22755: ARRAY
22756: PPUSH
22757: CALL_OW 276
22761: GO 22733
22763: POP
22764: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22765: LD_ADDR_VAR 0 18
22769: PUSH
22770: LD_VAR 0 15
22774: PPUSH
22775: LD_VAR 0 2
22779: PPUSH
22780: LD_INT 1
22782: PPUSH
22783: CALL 22025 0 3
22787: ST_TO_ADDR
// InitHc ;
22788: CALL_OW 19
// InitUc ;
22792: CALL_OW 18
// uc_side := side ;
22796: LD_ADDR_OWVAR 20
22800: PUSH
22801: LD_VAR 0 16
22805: ST_TO_ADDR
// uc_nation := nation ;
22806: LD_ADDR_OWVAR 21
22810: PUSH
22811: LD_VAR 0 17
22815: ST_TO_ADDR
// if buildings then
22816: LD_VAR 0 18
22820: IFFALSE 24142
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22822: LD_ADDR_VAR 0 19
22826: PUSH
22827: LD_VAR 0 18
22831: PPUSH
22832: LD_INT 2
22834: PUSH
22835: LD_INT 30
22837: PUSH
22838: LD_INT 29
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 30
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 72
22864: ST_TO_ADDR
// if tmp then
22865: LD_VAR 0 19
22869: IFFALSE 22917
// for i in tmp do
22871: LD_ADDR_VAR 0 8
22875: PUSH
22876: LD_VAR 0 19
22880: PUSH
22881: FOR_IN
22882: IFFALSE 22915
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22884: LD_VAR 0 8
22888: PPUSH
22889: CALL_OW 250
22893: PPUSH
22894: LD_VAR 0 8
22898: PPUSH
22899: CALL_OW 251
22903: PPUSH
22904: LD_VAR 0 16
22908: PPUSH
22909: CALL_OW 441
22913: GO 22881
22915: POP
22916: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22917: LD_VAR 0 18
22921: PPUSH
22922: LD_INT 2
22924: PUSH
22925: LD_INT 30
22927: PUSH
22928: LD_INT 32
22930: PUSH
22931: EMPTY
22932: LIST
22933: LIST
22934: PUSH
22935: LD_INT 30
22937: PUSH
22938: LD_INT 33
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: PUSH
22945: EMPTY
22946: LIST
22947: LIST
22948: LIST
22949: PPUSH
22950: CALL_OW 72
22954: IFFALSE 23042
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22956: LD_ADDR_VAR 0 8
22960: PUSH
22961: LD_VAR 0 18
22965: PPUSH
22966: LD_INT 2
22968: PUSH
22969: LD_INT 30
22971: PUSH
22972: LD_INT 32
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: PUSH
22979: LD_INT 30
22981: PUSH
22982: LD_INT 33
22984: PUSH
22985: EMPTY
22986: LIST
22987: LIST
22988: PUSH
22989: EMPTY
22990: LIST
22991: LIST
22992: LIST
22993: PPUSH
22994: CALL_OW 72
22998: PUSH
22999: FOR_IN
23000: IFFALSE 23040
// begin if not GetBWeapon ( i ) then
23002: LD_VAR 0 8
23006: PPUSH
23007: CALL_OW 269
23011: NOT
23012: IFFALSE 23038
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23014: LD_VAR 0 8
23018: PPUSH
23019: LD_VAR 0 8
23023: PPUSH
23024: LD_VAR 0 2
23028: PPUSH
23029: CALL 24288 0 2
23033: PPUSH
23034: CALL_OW 431
// end ;
23038: GO 22999
23040: POP
23041: POP
// end ; for i = 1 to personel do
23042: LD_ADDR_VAR 0 8
23046: PUSH
23047: DOUBLE
23048: LD_INT 1
23050: DEC
23051: ST_TO_ADDR
23052: LD_VAR 0 6
23056: PUSH
23057: FOR_TO
23058: IFFALSE 24122
// begin if i > 4 then
23060: LD_VAR 0 8
23064: PUSH
23065: LD_INT 4
23067: GREATER
23068: IFFALSE 23072
// break ;
23070: GO 24122
// case i of 1 :
23072: LD_VAR 0 8
23076: PUSH
23077: LD_INT 1
23079: DOUBLE
23080: EQUAL
23081: IFTRUE 23085
23083: GO 23165
23085: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23086: LD_ADDR_VAR 0 12
23090: PUSH
23091: LD_VAR 0 18
23095: PPUSH
23096: LD_INT 22
23098: PUSH
23099: LD_VAR 0 16
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: LD_INT 58
23110: PUSH
23111: EMPTY
23112: LIST
23113: PUSH
23114: LD_INT 2
23116: PUSH
23117: LD_INT 30
23119: PUSH
23120: LD_INT 32
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PUSH
23127: LD_INT 30
23129: PUSH
23130: LD_INT 4
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: PUSH
23137: LD_INT 30
23139: PUSH
23140: LD_INT 5
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: LIST
23151: LIST
23152: PUSH
23153: EMPTY
23154: LIST
23155: LIST
23156: LIST
23157: PPUSH
23158: CALL_OW 72
23162: ST_TO_ADDR
23163: GO 23387
23165: LD_INT 2
23167: DOUBLE
23168: EQUAL
23169: IFTRUE 23173
23171: GO 23235
23173: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23174: LD_ADDR_VAR 0 12
23178: PUSH
23179: LD_VAR 0 18
23183: PPUSH
23184: LD_INT 22
23186: PUSH
23187: LD_VAR 0 16
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 2
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: LD_INT 0
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PUSH
23209: LD_INT 30
23211: PUSH
23212: LD_INT 1
23214: PUSH
23215: EMPTY
23216: LIST
23217: LIST
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PPUSH
23228: CALL_OW 72
23232: ST_TO_ADDR
23233: GO 23387
23235: LD_INT 3
23237: DOUBLE
23238: EQUAL
23239: IFTRUE 23243
23241: GO 23305
23243: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23244: LD_ADDR_VAR 0 12
23248: PUSH
23249: LD_VAR 0 18
23253: PPUSH
23254: LD_INT 22
23256: PUSH
23257: LD_VAR 0 16
23261: PUSH
23262: EMPTY
23263: LIST
23264: LIST
23265: PUSH
23266: LD_INT 2
23268: PUSH
23269: LD_INT 30
23271: PUSH
23272: LD_INT 2
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 3
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PPUSH
23298: CALL_OW 72
23302: ST_TO_ADDR
23303: GO 23387
23305: LD_INT 4
23307: DOUBLE
23308: EQUAL
23309: IFTRUE 23313
23311: GO 23386
23313: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23314: LD_ADDR_VAR 0 12
23318: PUSH
23319: LD_VAR 0 18
23323: PPUSH
23324: LD_INT 22
23326: PUSH
23327: LD_VAR 0 16
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PUSH
23336: LD_INT 2
23338: PUSH
23339: LD_INT 30
23341: PUSH
23342: LD_INT 6
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: PUSH
23349: LD_INT 30
23351: PUSH
23352: LD_INT 7
23354: PUSH
23355: EMPTY
23356: LIST
23357: LIST
23358: PUSH
23359: LD_INT 30
23361: PUSH
23362: LD_INT 8
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PPUSH
23379: CALL_OW 72
23383: ST_TO_ADDR
23384: GO 23387
23386: POP
// if i = 1 then
23387: LD_VAR 0 8
23391: PUSH
23392: LD_INT 1
23394: EQUAL
23395: IFFALSE 23506
// begin tmp := [ ] ;
23397: LD_ADDR_VAR 0 19
23401: PUSH
23402: EMPTY
23403: ST_TO_ADDR
// for j in f do
23404: LD_ADDR_VAR 0 9
23408: PUSH
23409: LD_VAR 0 12
23413: PUSH
23414: FOR_IN
23415: IFFALSE 23488
// if GetBType ( j ) = b_bunker then
23417: LD_VAR 0 9
23421: PPUSH
23422: CALL_OW 266
23426: PUSH
23427: LD_INT 32
23429: EQUAL
23430: IFFALSE 23457
// tmp := Insert ( tmp , 1 , j ) else
23432: LD_ADDR_VAR 0 19
23436: PUSH
23437: LD_VAR 0 19
23441: PPUSH
23442: LD_INT 1
23444: PPUSH
23445: LD_VAR 0 9
23449: PPUSH
23450: CALL_OW 2
23454: ST_TO_ADDR
23455: GO 23486
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23457: LD_ADDR_VAR 0 19
23461: PUSH
23462: LD_VAR 0 19
23466: PPUSH
23467: LD_VAR 0 19
23471: PUSH
23472: LD_INT 1
23474: PLUS
23475: PPUSH
23476: LD_VAR 0 9
23480: PPUSH
23481: CALL_OW 2
23485: ST_TO_ADDR
23486: GO 23414
23488: POP
23489: POP
// if tmp then
23490: LD_VAR 0 19
23494: IFFALSE 23506
// f := tmp ;
23496: LD_ADDR_VAR 0 12
23500: PUSH
23501: LD_VAR 0 19
23505: ST_TO_ADDR
// end ; x := personel [ i ] ;
23506: LD_ADDR_VAR 0 13
23510: PUSH
23511: LD_VAR 0 6
23515: PUSH
23516: LD_VAR 0 8
23520: ARRAY
23521: ST_TO_ADDR
// if x = - 1 then
23522: LD_VAR 0 13
23526: PUSH
23527: LD_INT 1
23529: NEG
23530: EQUAL
23531: IFFALSE 23740
// begin for j in f do
23533: LD_ADDR_VAR 0 9
23537: PUSH
23538: LD_VAR 0 12
23542: PUSH
23543: FOR_IN
23544: IFFALSE 23736
// repeat InitHc ;
23546: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23550: LD_VAR 0 9
23554: PPUSH
23555: CALL_OW 266
23559: PUSH
23560: LD_INT 5
23562: EQUAL
23563: IFFALSE 23633
// begin if UnitsInside ( j ) < 3 then
23565: LD_VAR 0 9
23569: PPUSH
23570: CALL_OW 313
23574: PUSH
23575: LD_INT 3
23577: LESS
23578: IFFALSE 23614
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23580: LD_INT 0
23582: PPUSH
23583: LD_INT 5
23585: PUSH
23586: LD_INT 8
23588: PUSH
23589: LD_INT 9
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: LIST
23596: PUSH
23597: LD_VAR 0 17
23601: ARRAY
23602: PPUSH
23603: LD_VAR 0 4
23607: PPUSH
23608: CALL_OW 380
23612: GO 23631
// PrepareHuman ( false , i , skill ) ;
23614: LD_INT 0
23616: PPUSH
23617: LD_VAR 0 8
23621: PPUSH
23622: LD_VAR 0 4
23626: PPUSH
23627: CALL_OW 380
// end else
23631: GO 23650
// PrepareHuman ( false , i , skill ) ;
23633: LD_INT 0
23635: PPUSH
23636: LD_VAR 0 8
23640: PPUSH
23641: LD_VAR 0 4
23645: PPUSH
23646: CALL_OW 380
// un := CreateHuman ;
23650: LD_ADDR_VAR 0 14
23654: PUSH
23655: CALL_OW 44
23659: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23660: LD_ADDR_VAR 0 7
23664: PUSH
23665: LD_VAR 0 7
23669: PPUSH
23670: LD_INT 1
23672: PPUSH
23673: LD_VAR 0 14
23677: PPUSH
23678: CALL_OW 2
23682: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23683: LD_VAR 0 14
23687: PPUSH
23688: LD_VAR 0 9
23692: PPUSH
23693: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23697: LD_VAR 0 9
23701: PPUSH
23702: CALL_OW 313
23706: PUSH
23707: LD_INT 6
23709: EQUAL
23710: PUSH
23711: LD_VAR 0 9
23715: PPUSH
23716: CALL_OW 266
23720: PUSH
23721: LD_INT 32
23723: PUSH
23724: LD_INT 31
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: IN
23731: OR
23732: IFFALSE 23546
23734: GO 23543
23736: POP
23737: POP
// end else
23738: GO 24120
// for j = 1 to x do
23740: LD_ADDR_VAR 0 9
23744: PUSH
23745: DOUBLE
23746: LD_INT 1
23748: DEC
23749: ST_TO_ADDR
23750: LD_VAR 0 13
23754: PUSH
23755: FOR_TO
23756: IFFALSE 24118
// begin InitHc ;
23758: CALL_OW 19
// if not f then
23762: LD_VAR 0 12
23766: NOT
23767: IFFALSE 23856
// begin PrepareHuman ( false , i , skill ) ;
23769: LD_INT 0
23771: PPUSH
23772: LD_VAR 0 8
23776: PPUSH
23777: LD_VAR 0 4
23781: PPUSH
23782: CALL_OW 380
// un := CreateHuman ;
23786: LD_ADDR_VAR 0 14
23790: PUSH
23791: CALL_OW 44
23795: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23796: LD_ADDR_VAR 0 7
23800: PUSH
23801: LD_VAR 0 7
23805: PPUSH
23806: LD_INT 1
23808: PPUSH
23809: LD_VAR 0 14
23813: PPUSH
23814: CALL_OW 2
23818: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23819: LD_VAR 0 14
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 250
23833: PPUSH
23834: LD_VAR 0 1
23838: PPUSH
23839: CALL_OW 251
23843: PPUSH
23844: LD_INT 10
23846: PPUSH
23847: LD_INT 0
23849: PPUSH
23850: CALL_OW 50
// continue ;
23854: GO 23755
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23856: LD_VAR 0 12
23860: PUSH
23861: LD_INT 1
23863: ARRAY
23864: PPUSH
23865: CALL_OW 313
23869: PUSH
23870: LD_VAR 0 12
23874: PUSH
23875: LD_INT 1
23877: ARRAY
23878: PPUSH
23879: CALL_OW 266
23883: PUSH
23884: LD_INT 32
23886: PUSH
23887: LD_INT 31
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: IN
23894: AND
23895: PUSH
23896: LD_VAR 0 12
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 313
23909: PUSH
23910: LD_INT 6
23912: EQUAL
23913: OR
23914: IFFALSE 23934
// f := Delete ( f , 1 ) ;
23916: LD_ADDR_VAR 0 12
23920: PUSH
23921: LD_VAR 0 12
23925: PPUSH
23926: LD_INT 1
23928: PPUSH
23929: CALL_OW 3
23933: ST_TO_ADDR
// if not f then
23934: LD_VAR 0 12
23938: NOT
23939: IFFALSE 23957
// begin x := x + 2 ;
23941: LD_ADDR_VAR 0 13
23945: PUSH
23946: LD_VAR 0 13
23950: PUSH
23951: LD_INT 2
23953: PLUS
23954: ST_TO_ADDR
// continue ;
23955: GO 23755
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23957: LD_VAR 0 12
23961: PUSH
23962: LD_INT 1
23964: ARRAY
23965: PPUSH
23966: CALL_OW 266
23970: PUSH
23971: LD_INT 5
23973: EQUAL
23974: IFFALSE 24048
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23976: LD_VAR 0 12
23980: PUSH
23981: LD_INT 1
23983: ARRAY
23984: PPUSH
23985: CALL_OW 313
23989: PUSH
23990: LD_INT 3
23992: LESS
23993: IFFALSE 24029
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23995: LD_INT 0
23997: PPUSH
23998: LD_INT 5
24000: PUSH
24001: LD_INT 8
24003: PUSH
24004: LD_INT 9
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: LIST
24011: PUSH
24012: LD_VAR 0 17
24016: ARRAY
24017: PPUSH
24018: LD_VAR 0 4
24022: PPUSH
24023: CALL_OW 380
24027: GO 24046
// PrepareHuman ( false , i , skill ) ;
24029: LD_INT 0
24031: PPUSH
24032: LD_VAR 0 8
24036: PPUSH
24037: LD_VAR 0 4
24041: PPUSH
24042: CALL_OW 380
// end else
24046: GO 24065
// PrepareHuman ( false , i , skill ) ;
24048: LD_INT 0
24050: PPUSH
24051: LD_VAR 0 8
24055: PPUSH
24056: LD_VAR 0 4
24060: PPUSH
24061: CALL_OW 380
// un := CreateHuman ;
24065: LD_ADDR_VAR 0 14
24069: PUSH
24070: CALL_OW 44
24074: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24075: LD_ADDR_VAR 0 7
24079: PUSH
24080: LD_VAR 0 7
24084: PPUSH
24085: LD_INT 1
24087: PPUSH
24088: LD_VAR 0 14
24092: PPUSH
24093: CALL_OW 2
24097: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24098: LD_VAR 0 14
24102: PPUSH
24103: LD_VAR 0 12
24107: PUSH
24108: LD_INT 1
24110: ARRAY
24111: PPUSH
24112: CALL_OW 52
// end ;
24116: GO 23755
24118: POP
24119: POP
// end ;
24120: GO 23057
24122: POP
24123: POP
// result := result ^ buildings ;
24124: LD_ADDR_VAR 0 7
24128: PUSH
24129: LD_VAR 0 7
24133: PUSH
24134: LD_VAR 0 18
24138: ADD
24139: ST_TO_ADDR
// end else
24140: GO 24283
// begin for i = 1 to personel do
24142: LD_ADDR_VAR 0 8
24146: PUSH
24147: DOUBLE
24148: LD_INT 1
24150: DEC
24151: ST_TO_ADDR
24152: LD_VAR 0 6
24156: PUSH
24157: FOR_TO
24158: IFFALSE 24281
// begin if i > 4 then
24160: LD_VAR 0 8
24164: PUSH
24165: LD_INT 4
24167: GREATER
24168: IFFALSE 24172
// break ;
24170: GO 24281
// x := personel [ i ] ;
24172: LD_ADDR_VAR 0 13
24176: PUSH
24177: LD_VAR 0 6
24181: PUSH
24182: LD_VAR 0 8
24186: ARRAY
24187: ST_TO_ADDR
// if x = - 1 then
24188: LD_VAR 0 13
24192: PUSH
24193: LD_INT 1
24195: NEG
24196: EQUAL
24197: IFFALSE 24201
// continue ;
24199: GO 24157
// PrepareHuman ( false , i , skill ) ;
24201: LD_INT 0
24203: PPUSH
24204: LD_VAR 0 8
24208: PPUSH
24209: LD_VAR 0 4
24213: PPUSH
24214: CALL_OW 380
// un := CreateHuman ;
24218: LD_ADDR_VAR 0 14
24222: PUSH
24223: CALL_OW 44
24227: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24228: LD_VAR 0 14
24232: PPUSH
24233: LD_VAR 0 1
24237: PPUSH
24238: CALL_OW 250
24242: PPUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: CALL_OW 251
24252: PPUSH
24253: LD_INT 10
24255: PPUSH
24256: LD_INT 0
24258: PPUSH
24259: CALL_OW 50
// result := result ^ un ;
24263: LD_ADDR_VAR 0 7
24267: PUSH
24268: LD_VAR 0 7
24272: PUSH
24273: LD_VAR 0 14
24277: ADD
24278: ST_TO_ADDR
// end ;
24279: GO 24157
24281: POP
24282: POP
// end ; end ;
24283: LD_VAR 0 7
24287: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24288: LD_INT 0
24290: PPUSH
24291: PPUSH
24292: PPUSH
24293: PPUSH
24294: PPUSH
24295: PPUSH
24296: PPUSH
24297: PPUSH
24298: PPUSH
24299: PPUSH
24300: PPUSH
24301: PPUSH
24302: PPUSH
24303: PPUSH
24304: PPUSH
24305: PPUSH
// result := false ;
24306: LD_ADDR_VAR 0 3
24310: PUSH
24311: LD_INT 0
24313: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24314: LD_VAR 0 1
24318: NOT
24319: PUSH
24320: LD_VAR 0 1
24324: PPUSH
24325: CALL_OW 266
24329: PUSH
24330: LD_INT 32
24332: PUSH
24333: LD_INT 33
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: IN
24340: NOT
24341: OR
24342: IFFALSE 24346
// exit ;
24344: GO 25485
// nat := GetNation ( tower ) ;
24346: LD_ADDR_VAR 0 12
24350: PUSH
24351: LD_VAR 0 1
24355: PPUSH
24356: CALL_OW 248
24360: ST_TO_ADDR
// side := GetSide ( tower ) ;
24361: LD_ADDR_VAR 0 16
24365: PUSH
24366: LD_VAR 0 1
24370: PPUSH
24371: CALL_OW 255
24375: ST_TO_ADDR
// x := GetX ( tower ) ;
24376: LD_ADDR_VAR 0 10
24380: PUSH
24381: LD_VAR 0 1
24385: PPUSH
24386: CALL_OW 250
24390: ST_TO_ADDR
// y := GetY ( tower ) ;
24391: LD_ADDR_VAR 0 11
24395: PUSH
24396: LD_VAR 0 1
24400: PPUSH
24401: CALL_OW 251
24405: ST_TO_ADDR
// if not x or not y then
24406: LD_VAR 0 10
24410: NOT
24411: PUSH
24412: LD_VAR 0 11
24416: NOT
24417: OR
24418: IFFALSE 24422
// exit ;
24420: GO 25485
// weapon := 0 ;
24422: LD_ADDR_VAR 0 18
24426: PUSH
24427: LD_INT 0
24429: ST_TO_ADDR
// fac_list := [ ] ;
24430: LD_ADDR_VAR 0 17
24434: PUSH
24435: EMPTY
24436: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24437: LD_ADDR_VAR 0 6
24441: PUSH
24442: LD_VAR 0 1
24446: PPUSH
24447: CALL_OW 274
24451: PPUSH
24452: LD_VAR 0 2
24456: PPUSH
24457: LD_INT 0
24459: PPUSH
24460: CALL 22025 0 3
24464: PPUSH
24465: LD_INT 30
24467: PUSH
24468: LD_INT 3
24470: PUSH
24471: EMPTY
24472: LIST
24473: LIST
24474: PPUSH
24475: CALL_OW 72
24479: ST_TO_ADDR
// if not factories then
24480: LD_VAR 0 6
24484: NOT
24485: IFFALSE 24489
// exit ;
24487: GO 25485
// for i in factories do
24489: LD_ADDR_VAR 0 8
24493: PUSH
24494: LD_VAR 0 6
24498: PUSH
24499: FOR_IN
24500: IFFALSE 24525
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24502: LD_ADDR_VAR 0 17
24506: PUSH
24507: LD_VAR 0 17
24511: PUSH
24512: LD_VAR 0 8
24516: PPUSH
24517: CALL_OW 478
24521: UNION
24522: ST_TO_ADDR
24523: GO 24499
24525: POP
24526: POP
// if not fac_list then
24527: LD_VAR 0 17
24531: NOT
24532: IFFALSE 24536
// exit ;
24534: GO 25485
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24536: LD_ADDR_VAR 0 5
24540: PUSH
24541: LD_INT 4
24543: PUSH
24544: LD_INT 5
24546: PUSH
24547: LD_INT 9
24549: PUSH
24550: LD_INT 10
24552: PUSH
24553: LD_INT 6
24555: PUSH
24556: LD_INT 7
24558: PUSH
24559: LD_INT 11
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: PUSH
24571: LD_INT 27
24573: PUSH
24574: LD_INT 28
24576: PUSH
24577: LD_INT 26
24579: PUSH
24580: LD_INT 30
24582: PUSH
24583: EMPTY
24584: LIST
24585: LIST
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 43
24591: PUSH
24592: LD_INT 44
24594: PUSH
24595: LD_INT 46
24597: PUSH
24598: LD_INT 45
24600: PUSH
24601: LD_INT 47
24603: PUSH
24604: LD_INT 49
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: LIST
24613: LIST
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: LIST
24619: PUSH
24620: LD_VAR 0 12
24624: ARRAY
24625: ST_TO_ADDR
// for i in list do
24626: LD_ADDR_VAR 0 8
24630: PUSH
24631: LD_VAR 0 5
24635: PUSH
24636: FOR_IN
24637: IFFALSE 24670
// if not i in fac_list then
24639: LD_VAR 0 8
24643: PUSH
24644: LD_VAR 0 17
24648: IN
24649: NOT
24650: IFFALSE 24668
// list := list diff i ;
24652: LD_ADDR_VAR 0 5
24656: PUSH
24657: LD_VAR 0 5
24661: PUSH
24662: LD_VAR 0 8
24666: DIFF
24667: ST_TO_ADDR
24668: GO 24636
24670: POP
24671: POP
// if not list then
24672: LD_VAR 0 5
24676: NOT
24677: IFFALSE 24681
// exit ;
24679: GO 25485
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24681: LD_VAR 0 12
24685: PUSH
24686: LD_INT 3
24688: EQUAL
24689: PUSH
24690: LD_INT 49
24692: PUSH
24693: LD_VAR 0 5
24697: IN
24698: AND
24699: PUSH
24700: LD_INT 31
24702: PPUSH
24703: LD_VAR 0 16
24707: PPUSH
24708: CALL_OW 321
24712: PUSH
24713: LD_INT 2
24715: EQUAL
24716: AND
24717: IFFALSE 24777
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24719: LD_INT 22
24721: PUSH
24722: LD_VAR 0 16
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PUSH
24731: LD_INT 35
24733: PUSH
24734: LD_INT 49
24736: PUSH
24737: EMPTY
24738: LIST
24739: LIST
24740: PUSH
24741: LD_INT 91
24743: PUSH
24744: LD_VAR 0 1
24748: PUSH
24749: LD_INT 10
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: LIST
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: LIST
24761: PPUSH
24762: CALL_OW 69
24766: NOT
24767: IFFALSE 24777
// weapon := ru_time_lapser ;
24769: LD_ADDR_VAR 0 18
24773: PUSH
24774: LD_INT 49
24776: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24777: LD_VAR 0 12
24781: PUSH
24782: LD_INT 1
24784: PUSH
24785: LD_INT 2
24787: PUSH
24788: EMPTY
24789: LIST
24790: LIST
24791: IN
24792: PUSH
24793: LD_INT 11
24795: PUSH
24796: LD_VAR 0 5
24800: IN
24801: PUSH
24802: LD_INT 30
24804: PUSH
24805: LD_VAR 0 5
24809: IN
24810: OR
24811: AND
24812: PUSH
24813: LD_INT 6
24815: PPUSH
24816: LD_VAR 0 16
24820: PPUSH
24821: CALL_OW 321
24825: PUSH
24826: LD_INT 2
24828: EQUAL
24829: AND
24830: IFFALSE 24995
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24832: LD_INT 22
24834: PUSH
24835: LD_VAR 0 16
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: LD_INT 2
24846: PUSH
24847: LD_INT 35
24849: PUSH
24850: LD_INT 11
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 35
24859: PUSH
24860: LD_INT 30
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: PUSH
24872: LD_INT 91
24874: PUSH
24875: LD_VAR 0 1
24879: PUSH
24880: LD_INT 18
24882: PUSH
24883: EMPTY
24884: LIST
24885: LIST
24886: LIST
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: LIST
24892: PPUSH
24893: CALL_OW 69
24897: NOT
24898: PUSH
24899: LD_INT 22
24901: PUSH
24902: LD_VAR 0 16
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: PUSH
24911: LD_INT 2
24913: PUSH
24914: LD_INT 30
24916: PUSH
24917: LD_INT 32
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: PUSH
24924: LD_INT 30
24926: PUSH
24927: LD_INT 33
24929: PUSH
24930: EMPTY
24931: LIST
24932: LIST
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_INT 91
24941: PUSH
24942: LD_VAR 0 1
24946: PUSH
24947: LD_INT 12
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: LIST
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: LIST
24959: PUSH
24960: EMPTY
24961: LIST
24962: PPUSH
24963: CALL_OW 69
24967: PUSH
24968: LD_INT 2
24970: GREATER
24971: AND
24972: IFFALSE 24995
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24974: LD_ADDR_VAR 0 18
24978: PUSH
24979: LD_INT 11
24981: PUSH
24982: LD_INT 30
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: PUSH
24989: LD_VAR 0 12
24993: ARRAY
24994: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24995: LD_VAR 0 18
24999: NOT
25000: PUSH
25001: LD_INT 40
25003: PPUSH
25004: LD_VAR 0 16
25008: PPUSH
25009: CALL_OW 321
25013: PUSH
25014: LD_INT 2
25016: EQUAL
25017: AND
25018: PUSH
25019: LD_INT 7
25021: PUSH
25022: LD_VAR 0 5
25026: IN
25027: PUSH
25028: LD_INT 28
25030: PUSH
25031: LD_VAR 0 5
25035: IN
25036: OR
25037: PUSH
25038: LD_INT 45
25040: PUSH
25041: LD_VAR 0 5
25045: IN
25046: OR
25047: AND
25048: IFFALSE 25302
// begin hex := GetHexInfo ( x , y ) ;
25050: LD_ADDR_VAR 0 4
25054: PUSH
25055: LD_VAR 0 10
25059: PPUSH
25060: LD_VAR 0 11
25064: PPUSH
25065: CALL_OW 546
25069: ST_TO_ADDR
// if hex [ 1 ] then
25070: LD_VAR 0 4
25074: PUSH
25075: LD_INT 1
25077: ARRAY
25078: IFFALSE 25082
// exit ;
25080: GO 25485
// height := hex [ 2 ] ;
25082: LD_ADDR_VAR 0 15
25086: PUSH
25087: LD_VAR 0 4
25091: PUSH
25092: LD_INT 2
25094: ARRAY
25095: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25096: LD_ADDR_VAR 0 14
25100: PUSH
25101: LD_INT 0
25103: PUSH
25104: LD_INT 2
25106: PUSH
25107: LD_INT 3
25109: PUSH
25110: LD_INT 5
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: LIST
25117: LIST
25118: ST_TO_ADDR
// for i in tmp do
25119: LD_ADDR_VAR 0 8
25123: PUSH
25124: LD_VAR 0 14
25128: PUSH
25129: FOR_IN
25130: IFFALSE 25300
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25132: LD_ADDR_VAR 0 9
25136: PUSH
25137: LD_VAR 0 10
25141: PPUSH
25142: LD_VAR 0 8
25146: PPUSH
25147: LD_INT 5
25149: PPUSH
25150: CALL_OW 272
25154: PUSH
25155: LD_VAR 0 11
25159: PPUSH
25160: LD_VAR 0 8
25164: PPUSH
25165: LD_INT 5
25167: PPUSH
25168: CALL_OW 273
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25177: LD_VAR 0 9
25181: PUSH
25182: LD_INT 1
25184: ARRAY
25185: PPUSH
25186: LD_VAR 0 9
25190: PUSH
25191: LD_INT 2
25193: ARRAY
25194: PPUSH
25195: CALL_OW 488
25199: IFFALSE 25298
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25201: LD_ADDR_VAR 0 4
25205: PUSH
25206: LD_VAR 0 9
25210: PUSH
25211: LD_INT 1
25213: ARRAY
25214: PPUSH
25215: LD_VAR 0 9
25219: PUSH
25220: LD_INT 2
25222: ARRAY
25223: PPUSH
25224: CALL_OW 546
25228: ST_TO_ADDR
// if hex [ 1 ] then
25229: LD_VAR 0 4
25233: PUSH
25234: LD_INT 1
25236: ARRAY
25237: IFFALSE 25241
// continue ;
25239: GO 25129
// h := hex [ 2 ] ;
25241: LD_ADDR_VAR 0 13
25245: PUSH
25246: LD_VAR 0 4
25250: PUSH
25251: LD_INT 2
25253: ARRAY
25254: ST_TO_ADDR
// if h + 7 < height then
25255: LD_VAR 0 13
25259: PUSH
25260: LD_INT 7
25262: PLUS
25263: PUSH
25264: LD_VAR 0 15
25268: LESS
25269: IFFALSE 25298
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25271: LD_ADDR_VAR 0 18
25275: PUSH
25276: LD_INT 7
25278: PUSH
25279: LD_INT 28
25281: PUSH
25282: LD_INT 45
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: LIST
25289: PUSH
25290: LD_VAR 0 12
25294: ARRAY
25295: ST_TO_ADDR
// break ;
25296: GO 25300
// end ; end ; end ;
25298: GO 25129
25300: POP
25301: POP
// end ; if not weapon then
25302: LD_VAR 0 18
25306: NOT
25307: IFFALSE 25367
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25309: LD_ADDR_VAR 0 5
25313: PUSH
25314: LD_VAR 0 5
25318: PUSH
25319: LD_INT 11
25321: PUSH
25322: LD_INT 30
25324: PUSH
25325: LD_INT 49
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: DIFF
25333: ST_TO_ADDR
// if not list then
25334: LD_VAR 0 5
25338: NOT
25339: IFFALSE 25343
// exit ;
25341: GO 25485
// weapon := list [ rand ( 1 , list ) ] ;
25343: LD_ADDR_VAR 0 18
25347: PUSH
25348: LD_VAR 0 5
25352: PUSH
25353: LD_INT 1
25355: PPUSH
25356: LD_VAR 0 5
25360: PPUSH
25361: CALL_OW 12
25365: ARRAY
25366: ST_TO_ADDR
// end ; if weapon then
25367: LD_VAR 0 18
25371: IFFALSE 25485
// begin tmp := CostOfWeapon ( weapon ) ;
25373: LD_ADDR_VAR 0 14
25377: PUSH
25378: LD_VAR 0 18
25382: PPUSH
25383: CALL_OW 451
25387: ST_TO_ADDR
// j := GetBase ( tower ) ;
25388: LD_ADDR_VAR 0 9
25392: PUSH
25393: LD_VAR 0 1
25397: PPUSH
25398: CALL_OW 274
25402: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25403: LD_VAR 0 9
25407: PPUSH
25408: LD_INT 1
25410: PPUSH
25411: CALL_OW 275
25415: PUSH
25416: LD_VAR 0 14
25420: PUSH
25421: LD_INT 1
25423: ARRAY
25424: GREATEREQUAL
25425: PUSH
25426: LD_VAR 0 9
25430: PPUSH
25431: LD_INT 2
25433: PPUSH
25434: CALL_OW 275
25438: PUSH
25439: LD_VAR 0 14
25443: PUSH
25444: LD_INT 2
25446: ARRAY
25447: GREATEREQUAL
25448: AND
25449: PUSH
25450: LD_VAR 0 9
25454: PPUSH
25455: LD_INT 3
25457: PPUSH
25458: CALL_OW 275
25462: PUSH
25463: LD_VAR 0 14
25467: PUSH
25468: LD_INT 3
25470: ARRAY
25471: GREATEREQUAL
25472: AND
25473: IFFALSE 25485
// result := weapon ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_VAR 0 18
25484: ST_TO_ADDR
// end ; end ;
25485: LD_VAR 0 3
25489: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25490: LD_INT 0
25492: PPUSH
25493: PPUSH
// result := true ;
25494: LD_ADDR_VAR 0 3
25498: PUSH
25499: LD_INT 1
25501: ST_TO_ADDR
// if array1 = array2 then
25502: LD_VAR 0 1
25506: PUSH
25507: LD_VAR 0 2
25511: EQUAL
25512: IFFALSE 25572
// begin for i = 1 to array1 do
25514: LD_ADDR_VAR 0 4
25518: PUSH
25519: DOUBLE
25520: LD_INT 1
25522: DEC
25523: ST_TO_ADDR
25524: LD_VAR 0 1
25528: PUSH
25529: FOR_TO
25530: IFFALSE 25568
// if array1 [ i ] <> array2 [ i ] then
25532: LD_VAR 0 1
25536: PUSH
25537: LD_VAR 0 4
25541: ARRAY
25542: PUSH
25543: LD_VAR 0 2
25547: PUSH
25548: LD_VAR 0 4
25552: ARRAY
25553: NONEQUAL
25554: IFFALSE 25566
// begin result := false ;
25556: LD_ADDR_VAR 0 3
25560: PUSH
25561: LD_INT 0
25563: ST_TO_ADDR
// break ;
25564: GO 25568
// end ;
25566: GO 25529
25568: POP
25569: POP
// end else
25570: GO 25580
// result := false ;
25572: LD_ADDR_VAR 0 3
25576: PUSH
25577: LD_INT 0
25579: ST_TO_ADDR
// end ;
25580: LD_VAR 0 3
25584: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25585: LD_INT 0
25587: PPUSH
25588: PPUSH
// if not array1 or not array2 then
25589: LD_VAR 0 1
25593: NOT
25594: PUSH
25595: LD_VAR 0 2
25599: NOT
25600: OR
25601: IFFALSE 25605
// exit ;
25603: GO 25669
// result := true ;
25605: LD_ADDR_VAR 0 3
25609: PUSH
25610: LD_INT 1
25612: ST_TO_ADDR
// for i = 1 to array1 do
25613: LD_ADDR_VAR 0 4
25617: PUSH
25618: DOUBLE
25619: LD_INT 1
25621: DEC
25622: ST_TO_ADDR
25623: LD_VAR 0 1
25627: PUSH
25628: FOR_TO
25629: IFFALSE 25667
// if array1 [ i ] <> array2 [ i ] then
25631: LD_VAR 0 1
25635: PUSH
25636: LD_VAR 0 4
25640: ARRAY
25641: PUSH
25642: LD_VAR 0 2
25646: PUSH
25647: LD_VAR 0 4
25651: ARRAY
25652: NONEQUAL
25653: IFFALSE 25665
// begin result := false ;
25655: LD_ADDR_VAR 0 3
25659: PUSH
25660: LD_INT 0
25662: ST_TO_ADDR
// break ;
25663: GO 25667
// end ;
25665: GO 25628
25667: POP
25668: POP
// end ;
25669: LD_VAR 0 3
25673: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25674: LD_INT 0
25676: PPUSH
25677: PPUSH
25678: PPUSH
// pom := GetBase ( fac ) ;
25679: LD_ADDR_VAR 0 5
25683: PUSH
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 274
25693: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25694: LD_ADDR_VAR 0 4
25698: PUSH
25699: LD_VAR 0 2
25703: PUSH
25704: LD_INT 1
25706: ARRAY
25707: PPUSH
25708: LD_VAR 0 2
25712: PUSH
25713: LD_INT 2
25715: ARRAY
25716: PPUSH
25717: LD_VAR 0 2
25721: PUSH
25722: LD_INT 3
25724: ARRAY
25725: PPUSH
25726: LD_VAR 0 2
25730: PUSH
25731: LD_INT 4
25733: ARRAY
25734: PPUSH
25735: CALL_OW 449
25739: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25740: LD_ADDR_VAR 0 3
25744: PUSH
25745: LD_VAR 0 5
25749: PPUSH
25750: LD_INT 1
25752: PPUSH
25753: CALL_OW 275
25757: PUSH
25758: LD_VAR 0 4
25762: PUSH
25763: LD_INT 1
25765: ARRAY
25766: GREATEREQUAL
25767: PUSH
25768: LD_VAR 0 5
25772: PPUSH
25773: LD_INT 2
25775: PPUSH
25776: CALL_OW 275
25780: PUSH
25781: LD_VAR 0 4
25785: PUSH
25786: LD_INT 2
25788: ARRAY
25789: GREATEREQUAL
25790: AND
25791: PUSH
25792: LD_VAR 0 5
25796: PPUSH
25797: LD_INT 3
25799: PPUSH
25800: CALL_OW 275
25804: PUSH
25805: LD_VAR 0 4
25809: PUSH
25810: LD_INT 3
25812: ARRAY
25813: GREATEREQUAL
25814: AND
25815: ST_TO_ADDR
// end ;
25816: LD_VAR 0 3
25820: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25821: LD_INT 0
25823: PPUSH
25824: PPUSH
25825: PPUSH
25826: PPUSH
// pom := GetBase ( building ) ;
25827: LD_ADDR_VAR 0 3
25831: PUSH
25832: LD_VAR 0 1
25836: PPUSH
25837: CALL_OW 274
25841: ST_TO_ADDR
// if not pom then
25842: LD_VAR 0 3
25846: NOT
25847: IFFALSE 25851
// exit ;
25849: GO 26021
// btype := GetBType ( building ) ;
25851: LD_ADDR_VAR 0 5
25855: PUSH
25856: LD_VAR 0 1
25860: PPUSH
25861: CALL_OW 266
25865: ST_TO_ADDR
// if btype = b_armoury then
25866: LD_VAR 0 5
25870: PUSH
25871: LD_INT 4
25873: EQUAL
25874: IFFALSE 25884
// btype := b_barracks ;
25876: LD_ADDR_VAR 0 5
25880: PUSH
25881: LD_INT 5
25883: ST_TO_ADDR
// if btype = b_depot then
25884: LD_VAR 0 5
25888: PUSH
25889: LD_INT 0
25891: EQUAL
25892: IFFALSE 25902
// btype := b_warehouse ;
25894: LD_ADDR_VAR 0 5
25898: PUSH
25899: LD_INT 1
25901: ST_TO_ADDR
// if btype = b_workshop then
25902: LD_VAR 0 5
25906: PUSH
25907: LD_INT 2
25909: EQUAL
25910: IFFALSE 25920
// btype := b_factory ;
25912: LD_ADDR_VAR 0 5
25916: PUSH
25917: LD_INT 3
25919: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25920: LD_ADDR_VAR 0 4
25924: PUSH
25925: LD_VAR 0 5
25929: PPUSH
25930: LD_VAR 0 1
25934: PPUSH
25935: CALL_OW 248
25939: PPUSH
25940: CALL_OW 450
25944: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25945: LD_ADDR_VAR 0 2
25949: PUSH
25950: LD_VAR 0 3
25954: PPUSH
25955: LD_INT 1
25957: PPUSH
25958: CALL_OW 275
25962: PUSH
25963: LD_VAR 0 4
25967: PUSH
25968: LD_INT 1
25970: ARRAY
25971: GREATEREQUAL
25972: PUSH
25973: LD_VAR 0 3
25977: PPUSH
25978: LD_INT 2
25980: PPUSH
25981: CALL_OW 275
25985: PUSH
25986: LD_VAR 0 4
25990: PUSH
25991: LD_INT 2
25993: ARRAY
25994: GREATEREQUAL
25995: AND
25996: PUSH
25997: LD_VAR 0 3
26001: PPUSH
26002: LD_INT 3
26004: PPUSH
26005: CALL_OW 275
26009: PUSH
26010: LD_VAR 0 4
26014: PUSH
26015: LD_INT 3
26017: ARRAY
26018: GREATEREQUAL
26019: AND
26020: ST_TO_ADDR
// end ;
26021: LD_VAR 0 2
26025: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26026: LD_INT 0
26028: PPUSH
26029: PPUSH
26030: PPUSH
// pom := GetBase ( building ) ;
26031: LD_ADDR_VAR 0 4
26035: PUSH
26036: LD_VAR 0 1
26040: PPUSH
26041: CALL_OW 274
26045: ST_TO_ADDR
// if not pom then
26046: LD_VAR 0 4
26050: NOT
26051: IFFALSE 26055
// exit ;
26053: GO 26156
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26055: LD_ADDR_VAR 0 5
26059: PUSH
26060: LD_VAR 0 2
26064: PPUSH
26065: LD_VAR 0 1
26069: PPUSH
26070: CALL_OW 248
26074: PPUSH
26075: CALL_OW 450
26079: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26080: LD_ADDR_VAR 0 3
26084: PUSH
26085: LD_VAR 0 4
26089: PPUSH
26090: LD_INT 1
26092: PPUSH
26093: CALL_OW 275
26097: PUSH
26098: LD_VAR 0 5
26102: PUSH
26103: LD_INT 1
26105: ARRAY
26106: GREATEREQUAL
26107: PUSH
26108: LD_VAR 0 4
26112: PPUSH
26113: LD_INT 2
26115: PPUSH
26116: CALL_OW 275
26120: PUSH
26121: LD_VAR 0 5
26125: PUSH
26126: LD_INT 2
26128: ARRAY
26129: GREATEREQUAL
26130: AND
26131: PUSH
26132: LD_VAR 0 4
26136: PPUSH
26137: LD_INT 3
26139: PPUSH
26140: CALL_OW 275
26144: PUSH
26145: LD_VAR 0 5
26149: PUSH
26150: LD_INT 3
26152: ARRAY
26153: GREATEREQUAL
26154: AND
26155: ST_TO_ADDR
// end ;
26156: LD_VAR 0 3
26160: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26161: LD_INT 0
26163: PPUSH
26164: PPUSH
26165: PPUSH
26166: PPUSH
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
26171: PPUSH
26172: PPUSH
26173: PPUSH
// result := false ;
26174: LD_ADDR_VAR 0 8
26178: PUSH
26179: LD_INT 0
26181: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26182: LD_VAR 0 5
26186: NOT
26187: PUSH
26188: LD_VAR 0 1
26192: NOT
26193: OR
26194: PUSH
26195: LD_VAR 0 2
26199: NOT
26200: OR
26201: PUSH
26202: LD_VAR 0 3
26206: NOT
26207: OR
26208: IFFALSE 26212
// exit ;
26210: GO 27026
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26212: LD_ADDR_VAR 0 14
26216: PUSH
26217: LD_VAR 0 1
26221: PPUSH
26222: LD_VAR 0 2
26226: PPUSH
26227: LD_VAR 0 3
26231: PPUSH
26232: LD_VAR 0 4
26236: PPUSH
26237: LD_VAR 0 5
26241: PUSH
26242: LD_INT 1
26244: ARRAY
26245: PPUSH
26246: CALL_OW 248
26250: PPUSH
26251: LD_INT 0
26253: PPUSH
26254: CALL 27863 0 6
26258: ST_TO_ADDR
// if not hexes then
26259: LD_VAR 0 14
26263: NOT
26264: IFFALSE 26268
// exit ;
26266: GO 27026
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26268: LD_ADDR_VAR 0 17
26272: PUSH
26273: LD_VAR 0 5
26277: PPUSH
26278: LD_INT 22
26280: PUSH
26281: LD_VAR 0 13
26285: PPUSH
26286: CALL_OW 255
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: LD_INT 2
26297: PUSH
26298: LD_INT 30
26300: PUSH
26301: LD_INT 0
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 30
26310: PUSH
26311: LD_INT 1
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: LIST
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PPUSH
26327: CALL_OW 72
26331: ST_TO_ADDR
// for i = 1 to hexes do
26332: LD_ADDR_VAR 0 9
26336: PUSH
26337: DOUBLE
26338: LD_INT 1
26340: DEC
26341: ST_TO_ADDR
26342: LD_VAR 0 14
26346: PUSH
26347: FOR_TO
26348: IFFALSE 27024
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26350: LD_ADDR_VAR 0 13
26354: PUSH
26355: LD_VAR 0 14
26359: PUSH
26360: LD_VAR 0 9
26364: ARRAY
26365: PUSH
26366: LD_INT 1
26368: ARRAY
26369: PPUSH
26370: LD_VAR 0 14
26374: PUSH
26375: LD_VAR 0 9
26379: ARRAY
26380: PUSH
26381: LD_INT 2
26383: ARRAY
26384: PPUSH
26385: CALL_OW 428
26389: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26390: LD_VAR 0 14
26394: PUSH
26395: LD_VAR 0 9
26399: ARRAY
26400: PUSH
26401: LD_INT 1
26403: ARRAY
26404: PPUSH
26405: LD_VAR 0 14
26409: PUSH
26410: LD_VAR 0 9
26414: ARRAY
26415: PUSH
26416: LD_INT 2
26418: ARRAY
26419: PPUSH
26420: CALL_OW 351
26424: PUSH
26425: LD_VAR 0 14
26429: PUSH
26430: LD_VAR 0 9
26434: ARRAY
26435: PUSH
26436: LD_INT 1
26438: ARRAY
26439: PPUSH
26440: LD_VAR 0 14
26444: PUSH
26445: LD_VAR 0 9
26449: ARRAY
26450: PUSH
26451: LD_INT 2
26453: ARRAY
26454: PPUSH
26455: CALL_OW 488
26459: NOT
26460: OR
26461: PUSH
26462: LD_VAR 0 13
26466: PPUSH
26467: CALL_OW 247
26471: PUSH
26472: LD_INT 3
26474: EQUAL
26475: OR
26476: IFFALSE 26482
// exit ;
26478: POP
26479: POP
26480: GO 27026
// if not tmp then
26482: LD_VAR 0 13
26486: NOT
26487: IFFALSE 26491
// continue ;
26489: GO 26347
// result := true ;
26491: LD_ADDR_VAR 0 8
26495: PUSH
26496: LD_INT 1
26498: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26499: LD_VAR 0 6
26503: PUSH
26504: LD_VAR 0 13
26508: PPUSH
26509: CALL_OW 247
26513: PUSH
26514: LD_INT 2
26516: EQUAL
26517: AND
26518: PUSH
26519: LD_VAR 0 13
26523: PPUSH
26524: CALL_OW 263
26528: PUSH
26529: LD_INT 1
26531: EQUAL
26532: AND
26533: IFFALSE 26697
// begin if IsDrivenBy ( tmp ) then
26535: LD_VAR 0 13
26539: PPUSH
26540: CALL_OW 311
26544: IFFALSE 26548
// continue ;
26546: GO 26347
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26548: LD_VAR 0 6
26552: PPUSH
26553: LD_INT 3
26555: PUSH
26556: LD_INT 60
26558: PUSH
26559: EMPTY
26560: LIST
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 3
26568: PUSH
26569: LD_INT 55
26571: PUSH
26572: EMPTY
26573: LIST
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PPUSH
26583: CALL_OW 72
26587: IFFALSE 26695
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26589: LD_ADDR_VAR 0 18
26593: PUSH
26594: LD_VAR 0 6
26598: PPUSH
26599: LD_INT 3
26601: PUSH
26602: LD_INT 60
26604: PUSH
26605: EMPTY
26606: LIST
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 3
26614: PUSH
26615: LD_INT 55
26617: PUSH
26618: EMPTY
26619: LIST
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PPUSH
26629: CALL_OW 72
26633: PUSH
26634: LD_INT 1
26636: ARRAY
26637: ST_TO_ADDR
// if IsInUnit ( driver ) then
26638: LD_VAR 0 18
26642: PPUSH
26643: CALL_OW 310
26647: IFFALSE 26658
// ComExit ( driver ) ;
26649: LD_VAR 0 18
26653: PPUSH
26654: CALL 51047 0 1
// AddComEnterUnit ( driver , tmp ) ;
26658: LD_VAR 0 18
26662: PPUSH
26663: LD_VAR 0 13
26667: PPUSH
26668: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
26672: LD_VAR 0 18
26676: PPUSH
26677: LD_VAR 0 7
26681: PPUSH
26682: CALL_OW 173
// AddComExitVehicle ( driver ) ;
26686: LD_VAR 0 18
26690: PPUSH
26691: CALL_OW 181
// end ; continue ;
26695: GO 26347
// end ; if not cleaners or not tmp in cleaners then
26697: LD_VAR 0 6
26701: NOT
26702: PUSH
26703: LD_VAR 0 13
26707: PUSH
26708: LD_VAR 0 6
26712: IN
26713: NOT
26714: OR
26715: IFFALSE 27022
// begin if dep then
26717: LD_VAR 0 17
26721: IFFALSE 26857
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26723: LD_ADDR_VAR 0 16
26727: PUSH
26728: LD_VAR 0 17
26732: PUSH
26733: LD_INT 1
26735: ARRAY
26736: PPUSH
26737: CALL_OW 250
26741: PPUSH
26742: LD_VAR 0 17
26746: PUSH
26747: LD_INT 1
26749: ARRAY
26750: PPUSH
26751: CALL_OW 254
26755: PPUSH
26756: LD_INT 5
26758: PPUSH
26759: CALL_OW 272
26763: PUSH
26764: LD_VAR 0 17
26768: PUSH
26769: LD_INT 1
26771: ARRAY
26772: PPUSH
26773: CALL_OW 251
26777: PPUSH
26778: LD_VAR 0 17
26782: PUSH
26783: LD_INT 1
26785: ARRAY
26786: PPUSH
26787: CALL_OW 254
26791: PPUSH
26792: LD_INT 5
26794: PPUSH
26795: CALL_OW 273
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26804: LD_VAR 0 16
26808: PUSH
26809: LD_INT 1
26811: ARRAY
26812: PPUSH
26813: LD_VAR 0 16
26817: PUSH
26818: LD_INT 2
26820: ARRAY
26821: PPUSH
26822: CALL_OW 488
26826: IFFALSE 26857
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26828: LD_VAR 0 13
26832: PPUSH
26833: LD_VAR 0 16
26837: PUSH
26838: LD_INT 1
26840: ARRAY
26841: PPUSH
26842: LD_VAR 0 16
26846: PUSH
26847: LD_INT 2
26849: ARRAY
26850: PPUSH
26851: CALL_OW 111
// continue ;
26855: GO 26347
// end ; end ; r := GetDir ( tmp ) ;
26857: LD_ADDR_VAR 0 15
26861: PUSH
26862: LD_VAR 0 13
26866: PPUSH
26867: CALL_OW 254
26871: ST_TO_ADDR
// if r = 5 then
26872: LD_VAR 0 15
26876: PUSH
26877: LD_INT 5
26879: EQUAL
26880: IFFALSE 26890
// r := 0 ;
26882: LD_ADDR_VAR 0 15
26886: PUSH
26887: LD_INT 0
26889: ST_TO_ADDR
// for j = r to 5 do
26890: LD_ADDR_VAR 0 10
26894: PUSH
26895: DOUBLE
26896: LD_VAR 0 15
26900: DEC
26901: ST_TO_ADDR
26902: LD_INT 5
26904: PUSH
26905: FOR_TO
26906: IFFALSE 27020
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26908: LD_ADDR_VAR 0 11
26912: PUSH
26913: LD_VAR 0 13
26917: PPUSH
26918: CALL_OW 250
26922: PPUSH
26923: LD_VAR 0 10
26927: PPUSH
26928: LD_INT 2
26930: PPUSH
26931: CALL_OW 272
26935: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26936: LD_ADDR_VAR 0 12
26940: PUSH
26941: LD_VAR 0 13
26945: PPUSH
26946: CALL_OW 251
26950: PPUSH
26951: LD_VAR 0 10
26955: PPUSH
26956: LD_INT 2
26958: PPUSH
26959: CALL_OW 273
26963: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26964: LD_VAR 0 11
26968: PPUSH
26969: LD_VAR 0 12
26973: PPUSH
26974: CALL_OW 488
26978: PUSH
26979: LD_VAR 0 11
26983: PPUSH
26984: LD_VAR 0 12
26988: PPUSH
26989: CALL_OW 428
26993: NOT
26994: AND
26995: IFFALSE 27018
// begin ComMoveXY ( tmp , _x , _y ) ;
26997: LD_VAR 0 13
27001: PPUSH
27002: LD_VAR 0 11
27006: PPUSH
27007: LD_VAR 0 12
27011: PPUSH
27012: CALL_OW 111
// break ;
27016: GO 27020
// end ; end ;
27018: GO 26905
27020: POP
27021: POP
// end ; end ;
27022: GO 26347
27024: POP
27025: POP
// end ;
27026: LD_VAR 0 8
27030: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27031: LD_INT 0
27033: PPUSH
27034: PPUSH
27035: PPUSH
27036: PPUSH
27037: PPUSH
27038: PPUSH
27039: PPUSH
27040: PPUSH
27041: PPUSH
27042: PPUSH
// result := false ;
27043: LD_ADDR_VAR 0 6
27047: PUSH
27048: LD_INT 0
27050: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27051: LD_VAR 0 1
27055: NOT
27056: PUSH
27057: LD_VAR 0 1
27061: PPUSH
27062: CALL_OW 266
27066: PUSH
27067: LD_INT 0
27069: PUSH
27070: LD_INT 1
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: IN
27077: NOT
27078: OR
27079: PUSH
27080: LD_VAR 0 2
27084: NOT
27085: OR
27086: PUSH
27087: LD_VAR 0 5
27091: PUSH
27092: LD_INT 0
27094: PUSH
27095: LD_INT 1
27097: PUSH
27098: LD_INT 2
27100: PUSH
27101: LD_INT 3
27103: PUSH
27104: LD_INT 4
27106: PUSH
27107: LD_INT 5
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: LIST
27114: LIST
27115: LIST
27116: LIST
27117: IN
27118: NOT
27119: OR
27120: PUSH
27121: LD_VAR 0 3
27125: PPUSH
27126: LD_VAR 0 4
27130: PPUSH
27131: CALL_OW 488
27135: NOT
27136: OR
27137: IFFALSE 27141
// exit ;
27139: GO 27858
// pom := GetBase ( depot ) ;
27141: LD_ADDR_VAR 0 10
27145: PUSH
27146: LD_VAR 0 1
27150: PPUSH
27151: CALL_OW 274
27155: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27156: LD_ADDR_VAR 0 11
27160: PUSH
27161: LD_VAR 0 2
27165: PPUSH
27166: LD_VAR 0 1
27170: PPUSH
27171: CALL_OW 248
27175: PPUSH
27176: CALL_OW 450
27180: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27181: LD_VAR 0 10
27185: PPUSH
27186: LD_INT 1
27188: PPUSH
27189: CALL_OW 275
27193: PUSH
27194: LD_VAR 0 11
27198: PUSH
27199: LD_INT 1
27201: ARRAY
27202: GREATEREQUAL
27203: PUSH
27204: LD_VAR 0 10
27208: PPUSH
27209: LD_INT 2
27211: PPUSH
27212: CALL_OW 275
27216: PUSH
27217: LD_VAR 0 11
27221: PUSH
27222: LD_INT 2
27224: ARRAY
27225: GREATEREQUAL
27226: AND
27227: PUSH
27228: LD_VAR 0 10
27232: PPUSH
27233: LD_INT 3
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 11
27245: PUSH
27246: LD_INT 3
27248: ARRAY
27249: GREATEREQUAL
27250: AND
27251: NOT
27252: IFFALSE 27256
// exit ;
27254: GO 27858
// if GetBType ( depot ) = b_depot then
27256: LD_VAR 0 1
27260: PPUSH
27261: CALL_OW 266
27265: PUSH
27266: LD_INT 0
27268: EQUAL
27269: IFFALSE 27281
// dist := 28 else
27271: LD_ADDR_VAR 0 14
27275: PUSH
27276: LD_INT 28
27278: ST_TO_ADDR
27279: GO 27289
// dist := 36 ;
27281: LD_ADDR_VAR 0 14
27285: PUSH
27286: LD_INT 36
27288: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27289: LD_VAR 0 1
27293: PPUSH
27294: LD_VAR 0 3
27298: PPUSH
27299: LD_VAR 0 4
27303: PPUSH
27304: CALL_OW 297
27308: PUSH
27309: LD_VAR 0 14
27313: GREATER
27314: IFFALSE 27318
// exit ;
27316: GO 27858
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27318: LD_ADDR_VAR 0 12
27322: PUSH
27323: LD_VAR 0 2
27327: PPUSH
27328: LD_VAR 0 3
27332: PPUSH
27333: LD_VAR 0 4
27337: PPUSH
27338: LD_VAR 0 5
27342: PPUSH
27343: LD_VAR 0 1
27347: PPUSH
27348: CALL_OW 248
27352: PPUSH
27353: LD_INT 0
27355: PPUSH
27356: CALL 27863 0 6
27360: ST_TO_ADDR
// if not hexes then
27361: LD_VAR 0 12
27365: NOT
27366: IFFALSE 27370
// exit ;
27368: GO 27858
// hex := GetHexInfo ( x , y ) ;
27370: LD_ADDR_VAR 0 15
27374: PUSH
27375: LD_VAR 0 3
27379: PPUSH
27380: LD_VAR 0 4
27384: PPUSH
27385: CALL_OW 546
27389: ST_TO_ADDR
// if hex [ 1 ] then
27390: LD_VAR 0 15
27394: PUSH
27395: LD_INT 1
27397: ARRAY
27398: IFFALSE 27402
// exit ;
27400: GO 27858
// height := hex [ 2 ] ;
27402: LD_ADDR_VAR 0 13
27406: PUSH
27407: LD_VAR 0 15
27411: PUSH
27412: LD_INT 2
27414: ARRAY
27415: ST_TO_ADDR
// for i = 1 to hexes do
27416: LD_ADDR_VAR 0 7
27420: PUSH
27421: DOUBLE
27422: LD_INT 1
27424: DEC
27425: ST_TO_ADDR
27426: LD_VAR 0 12
27430: PUSH
27431: FOR_TO
27432: IFFALSE 27762
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27434: LD_VAR 0 12
27438: PUSH
27439: LD_VAR 0 7
27443: ARRAY
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: LD_VAR 0 12
27453: PUSH
27454: LD_VAR 0 7
27458: ARRAY
27459: PUSH
27460: LD_INT 2
27462: ARRAY
27463: PPUSH
27464: CALL_OW 488
27468: NOT
27469: PUSH
27470: LD_VAR 0 12
27474: PUSH
27475: LD_VAR 0 7
27479: ARRAY
27480: PUSH
27481: LD_INT 1
27483: ARRAY
27484: PPUSH
27485: LD_VAR 0 12
27489: PUSH
27490: LD_VAR 0 7
27494: ARRAY
27495: PUSH
27496: LD_INT 2
27498: ARRAY
27499: PPUSH
27500: CALL_OW 428
27504: PUSH
27505: LD_INT 0
27507: GREATER
27508: OR
27509: PUSH
27510: LD_VAR 0 12
27514: PUSH
27515: LD_VAR 0 7
27519: ARRAY
27520: PUSH
27521: LD_INT 1
27523: ARRAY
27524: PPUSH
27525: LD_VAR 0 12
27529: PUSH
27530: LD_VAR 0 7
27534: ARRAY
27535: PUSH
27536: LD_INT 2
27538: ARRAY
27539: PPUSH
27540: CALL_OW 351
27544: OR
27545: IFFALSE 27551
// exit ;
27547: POP
27548: POP
27549: GO 27858
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27551: LD_ADDR_VAR 0 8
27555: PUSH
27556: LD_VAR 0 12
27560: PUSH
27561: LD_VAR 0 7
27565: ARRAY
27566: PUSH
27567: LD_INT 1
27569: ARRAY
27570: PPUSH
27571: LD_VAR 0 12
27575: PUSH
27576: LD_VAR 0 7
27580: ARRAY
27581: PUSH
27582: LD_INT 2
27584: ARRAY
27585: PPUSH
27586: CALL_OW 546
27590: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27591: LD_VAR 0 8
27595: PUSH
27596: LD_INT 1
27598: ARRAY
27599: PUSH
27600: LD_VAR 0 8
27604: PUSH
27605: LD_INT 2
27607: ARRAY
27608: PUSH
27609: LD_VAR 0 13
27613: PUSH
27614: LD_INT 2
27616: PLUS
27617: GREATER
27618: OR
27619: PUSH
27620: LD_VAR 0 8
27624: PUSH
27625: LD_INT 2
27627: ARRAY
27628: PUSH
27629: LD_VAR 0 13
27633: PUSH
27634: LD_INT 2
27636: MINUS
27637: LESS
27638: OR
27639: PUSH
27640: LD_VAR 0 8
27644: PUSH
27645: LD_INT 3
27647: ARRAY
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: LD_INT 8
27654: PUSH
27655: LD_INT 9
27657: PUSH
27658: LD_INT 10
27660: PUSH
27661: LD_INT 11
27663: PUSH
27664: LD_INT 12
27666: PUSH
27667: LD_INT 13
27669: PUSH
27670: LD_INT 16
27672: PUSH
27673: LD_INT 17
27675: PUSH
27676: LD_INT 18
27678: PUSH
27679: LD_INT 19
27681: PUSH
27682: LD_INT 20
27684: PUSH
27685: LD_INT 21
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: IN
27703: NOT
27704: OR
27705: PUSH
27706: LD_VAR 0 8
27710: PUSH
27711: LD_INT 5
27713: ARRAY
27714: NOT
27715: OR
27716: PUSH
27717: LD_VAR 0 8
27721: PUSH
27722: LD_INT 6
27724: ARRAY
27725: PUSH
27726: LD_INT 1
27728: PUSH
27729: LD_INT 2
27731: PUSH
27732: LD_INT 7
27734: PUSH
27735: LD_INT 9
27737: PUSH
27738: LD_INT 10
27740: PUSH
27741: LD_INT 11
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: IN
27752: NOT
27753: OR
27754: IFFALSE 27760
// exit ;
27756: POP
27757: POP
27758: GO 27858
// end ;
27760: GO 27431
27762: POP
27763: POP
// side := GetSide ( depot ) ;
27764: LD_ADDR_VAR 0 9
27768: PUSH
27769: LD_VAR 0 1
27773: PPUSH
27774: CALL_OW 255
27778: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27779: LD_VAR 0 9
27783: PPUSH
27784: LD_VAR 0 3
27788: PPUSH
27789: LD_VAR 0 4
27793: PPUSH
27794: LD_INT 20
27796: PPUSH
27797: CALL 20179 0 4
27801: PUSH
27802: LD_INT 4
27804: ARRAY
27805: IFFALSE 27809
// exit ;
27807: GO 27858
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27809: LD_VAR 0 2
27813: PUSH
27814: LD_INT 29
27816: PUSH
27817: LD_INT 30
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: IN
27824: PUSH
27825: LD_VAR 0 3
27829: PPUSH
27830: LD_VAR 0 4
27834: PPUSH
27835: LD_VAR 0 9
27839: PPUSH
27840: CALL_OW 440
27844: NOT
27845: AND
27846: IFFALSE 27850
// exit ;
27848: GO 27858
// result := true ;
27850: LD_ADDR_VAR 0 6
27854: PUSH
27855: LD_INT 1
27857: ST_TO_ADDR
// end ;
27858: LD_VAR 0 6
27862: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27863: LD_INT 0
27865: PPUSH
27866: PPUSH
27867: PPUSH
27868: PPUSH
27869: PPUSH
27870: PPUSH
27871: PPUSH
27872: PPUSH
27873: PPUSH
27874: PPUSH
27875: PPUSH
27876: PPUSH
27877: PPUSH
27878: PPUSH
27879: PPUSH
27880: PPUSH
27881: PPUSH
27882: PPUSH
27883: PPUSH
27884: PPUSH
27885: PPUSH
27886: PPUSH
27887: PPUSH
27888: PPUSH
27889: PPUSH
27890: PPUSH
27891: PPUSH
27892: PPUSH
27893: PPUSH
27894: PPUSH
27895: PPUSH
27896: PPUSH
27897: PPUSH
27898: PPUSH
27899: PPUSH
27900: PPUSH
27901: PPUSH
27902: PPUSH
27903: PPUSH
27904: PPUSH
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
27914: PPUSH
27915: PPUSH
27916: PPUSH
27917: PPUSH
27918: PPUSH
27919: PPUSH
27920: PPUSH
27921: PPUSH
27922: PPUSH
// result = [ ] ;
27923: LD_ADDR_VAR 0 7
27927: PUSH
27928: EMPTY
27929: ST_TO_ADDR
// temp_list = [ ] ;
27930: LD_ADDR_VAR 0 9
27934: PUSH
27935: EMPTY
27936: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27937: LD_VAR 0 4
27941: PUSH
27942: LD_INT 0
27944: PUSH
27945: LD_INT 1
27947: PUSH
27948: LD_INT 2
27950: PUSH
27951: LD_INT 3
27953: PUSH
27954: LD_INT 4
27956: PUSH
27957: LD_INT 5
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: LIST
27964: LIST
27965: LIST
27966: LIST
27967: IN
27968: NOT
27969: PUSH
27970: LD_VAR 0 1
27974: PUSH
27975: LD_INT 0
27977: PUSH
27978: LD_INT 1
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: IN
27985: PUSH
27986: LD_VAR 0 5
27990: PUSH
27991: LD_INT 1
27993: PUSH
27994: LD_INT 2
27996: PUSH
27997: LD_INT 3
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: LIST
28004: IN
28005: NOT
28006: AND
28007: OR
28008: IFFALSE 28012
// exit ;
28010: GO 46403
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28012: LD_VAR 0 1
28016: PUSH
28017: LD_INT 6
28019: PUSH
28020: LD_INT 7
28022: PUSH
28023: LD_INT 8
28025: PUSH
28026: LD_INT 13
28028: PUSH
28029: LD_INT 12
28031: PUSH
28032: LD_INT 15
28034: PUSH
28035: LD_INT 11
28037: PUSH
28038: LD_INT 14
28040: PUSH
28041: LD_INT 10
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: IN
28055: IFFALSE 28065
// btype = b_lab ;
28057: LD_ADDR_VAR 0 1
28061: PUSH
28062: LD_INT 6
28064: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28065: LD_VAR 0 6
28069: PUSH
28070: LD_INT 0
28072: PUSH
28073: LD_INT 1
28075: PUSH
28076: LD_INT 2
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: LIST
28083: IN
28084: NOT
28085: PUSH
28086: LD_VAR 0 1
28090: PUSH
28091: LD_INT 0
28093: PUSH
28094: LD_INT 1
28096: PUSH
28097: LD_INT 2
28099: PUSH
28100: LD_INT 3
28102: PUSH
28103: LD_INT 6
28105: PUSH
28106: LD_INT 36
28108: PUSH
28109: LD_INT 4
28111: PUSH
28112: LD_INT 5
28114: PUSH
28115: LD_INT 31
28117: PUSH
28118: LD_INT 32
28120: PUSH
28121: LD_INT 33
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: IN
28137: NOT
28138: PUSH
28139: LD_VAR 0 6
28143: PUSH
28144: LD_INT 1
28146: EQUAL
28147: AND
28148: OR
28149: PUSH
28150: LD_VAR 0 1
28154: PUSH
28155: LD_INT 2
28157: PUSH
28158: LD_INT 3
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: IN
28165: NOT
28166: PUSH
28167: LD_VAR 0 6
28171: PUSH
28172: LD_INT 2
28174: EQUAL
28175: AND
28176: OR
28177: IFFALSE 28187
// mode = 0 ;
28179: LD_ADDR_VAR 0 6
28183: PUSH
28184: LD_INT 0
28186: ST_TO_ADDR
// case mode of 0 :
28187: LD_VAR 0 6
28191: PUSH
28192: LD_INT 0
28194: DOUBLE
28195: EQUAL
28196: IFTRUE 28200
28198: GO 39653
28200: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28201: LD_ADDR_VAR 0 11
28205: PUSH
28206: LD_INT 0
28208: PUSH
28209: LD_INT 0
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 0
28218: PUSH
28219: LD_INT 1
28221: NEG
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 1
28229: PUSH
28230: LD_INT 0
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 1
28239: PUSH
28240: LD_INT 1
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 0
28249: PUSH
28250: LD_INT 1
28252: PUSH
28253: EMPTY
28254: LIST
28255: LIST
28256: PUSH
28257: LD_INT 1
28259: NEG
28260: PUSH
28261: LD_INT 0
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 1
28274: NEG
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: NEG
28283: PUSH
28284: LD_INT 2
28286: NEG
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 0
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 1
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 1
28316: PUSH
28317: LD_INT 2
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PUSH
28324: LD_INT 0
28326: PUSH
28327: LD_INT 2
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 1
28336: NEG
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 1
28347: PUSH
28348: LD_INT 3
28350: PUSH
28351: EMPTY
28352: LIST
28353: LIST
28354: PUSH
28355: LD_INT 0
28357: PUSH
28358: LD_INT 3
28360: PUSH
28361: EMPTY
28362: LIST
28363: LIST
28364: PUSH
28365: LD_INT 1
28367: NEG
28368: PUSH
28369: LD_INT 2
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: LIST
28389: LIST
28390: LIST
28391: LIST
28392: LIST
28393: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28394: LD_ADDR_VAR 0 12
28398: PUSH
28399: LD_INT 0
28401: PUSH
28402: LD_INT 0
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 1
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 1
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 1
28432: PUSH
28433: LD_INT 1
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: LD_INT 1
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: LD_INT 0
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 1
28463: NEG
28464: PUSH
28465: LD_INT 1
28467: NEG
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 1
28475: PUSH
28476: LD_INT 1
28478: NEG
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: PUSH
28484: LD_INT 2
28486: PUSH
28487: LD_INT 0
28489: PUSH
28490: EMPTY
28491: LIST
28492: LIST
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: LD_INT 1
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 1
28506: NEG
28507: PUSH
28508: LD_INT 1
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 2
28517: NEG
28518: PUSH
28519: LD_INT 0
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 2
28528: NEG
28529: PUSH
28530: LD_INT 1
28532: NEG
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 2
28540: NEG
28541: PUSH
28542: LD_INT 1
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 3
28551: NEG
28552: PUSH
28553: LD_INT 0
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 3
28562: NEG
28563: PUSH
28564: LD_INT 1
28566: NEG
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: LIST
28585: LIST
28586: LIST
28587: LIST
28588: LIST
28589: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28590: LD_ADDR_VAR 0 13
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: LD_INT 0
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 0
28607: PUSH
28608: LD_INT 1
28610: NEG
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 1
28618: PUSH
28619: LD_INT 0
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 1
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: NEG
28649: PUSH
28650: LD_INT 0
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 1
28659: NEG
28660: PUSH
28661: LD_INT 1
28663: NEG
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 1
28671: NEG
28672: PUSH
28673: LD_INT 2
28675: NEG
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 2
28683: PUSH
28684: LD_INT 1
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 2
28693: PUSH
28694: LD_INT 2
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 2
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 2
28713: NEG
28714: PUSH
28715: LD_INT 1
28717: NEG
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: PUSH
28723: LD_INT 2
28725: NEG
28726: PUSH
28727: LD_INT 2
28729: NEG
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 2
28737: NEG
28738: PUSH
28739: LD_INT 3
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 3
28749: NEG
28750: PUSH
28751: LD_INT 2
28753: NEG
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 3
28761: NEG
28762: PUSH
28763: LD_INT 3
28765: NEG
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28789: LD_ADDR_VAR 0 14
28793: PUSH
28794: LD_INT 0
28796: PUSH
28797: LD_INT 0
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 0
28806: PUSH
28807: LD_INT 1
28809: NEG
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 1
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: EMPTY
28822: LIST
28823: LIST
28824: PUSH
28825: LD_INT 1
28827: PUSH
28828: LD_INT 1
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: LD_INT 1
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 1
28847: NEG
28848: PUSH
28849: LD_INT 0
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 1
28862: NEG
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 1
28870: NEG
28871: PUSH
28872: LD_INT 2
28874: NEG
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 0
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 1
28893: PUSH
28894: LD_INT 1
28896: NEG
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 1
28904: PUSH
28905: LD_INT 2
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: PUSH
28912: LD_INT 0
28914: PUSH
28915: LD_INT 2
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 1
28924: NEG
28925: PUSH
28926: LD_INT 1
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 3
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 0
28947: PUSH
28948: LD_INT 3
28950: NEG
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 1
28958: PUSH
28959: LD_INT 2
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28985: LD_ADDR_VAR 0 15
28989: PUSH
28990: LD_INT 0
28992: PUSH
28993: LD_INT 0
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 0
29002: PUSH
29003: LD_INT 1
29005: NEG
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PUSH
29011: LD_INT 1
29013: PUSH
29014: LD_INT 0
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: LD_INT 1
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: LD_INT 0
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: NEG
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 1
29054: NEG
29055: PUSH
29056: LD_INT 1
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 1
29066: PUSH
29067: LD_INT 1
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: NEG
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: NEG
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: LD_INT 2
29119: NEG
29120: PUSH
29121: LD_INT 1
29123: NEG
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: LD_INT 1
29134: NEG
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 3
29142: PUSH
29143: LD_INT 0
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 3
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29178: LD_ADDR_VAR 0 16
29182: PUSH
29183: LD_INT 0
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 0
29195: PUSH
29196: LD_INT 1
29198: NEG
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 1
29206: PUSH
29207: LD_INT 0
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 1
29216: PUSH
29217: LD_INT 1
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: LD_INT 1
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 1
29236: NEG
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: NEG
29248: PUSH
29249: LD_INT 1
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 1
29259: NEG
29260: PUSH
29261: LD_INT 2
29263: NEG
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 2
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 2
29281: PUSH
29282: LD_INT 2
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: LD_INT 1
29291: PUSH
29292: LD_INT 2
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 2
29301: NEG
29302: PUSH
29303: LD_INT 1
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 2
29313: NEG
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 3
29325: PUSH
29326: LD_INT 2
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 3
29335: PUSH
29336: LD_INT 3
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 2
29345: PUSH
29346: LD_INT 3
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: LIST
29364: LIST
29365: LIST
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29371: LD_ADDR_VAR 0 17
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: LD_INT 1
29391: NEG
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 1
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: LD_INT 1
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 1
29429: NEG
29430: PUSH
29431: LD_INT 0
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 1
29440: NEG
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 1
29452: NEG
29453: PUSH
29454: LD_INT 2
29456: NEG
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 0
29464: PUSH
29465: LD_INT 2
29467: NEG
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 1
29475: PUSH
29476: LD_INT 1
29478: NEG
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: PUSH
29484: LD_INT 2
29486: PUSH
29487: LD_INT 0
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: PUSH
29494: LD_INT 2
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 2
29506: PUSH
29507: LD_INT 2
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: LD_INT 2
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 0
29526: PUSH
29527: LD_INT 2
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 1
29536: NEG
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 2
29547: NEG
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: NEG
29559: PUSH
29560: LD_INT 1
29562: NEG
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 2
29570: NEG
29571: PUSH
29572: LD_INT 2
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29601: LD_ADDR_VAR 0 18
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 0
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: LD_INT 1
29621: NEG
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: LD_INT 1
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 0
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: NEG
29660: PUSH
29661: LD_INT 0
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: PUSH
29668: LD_INT 1
29670: NEG
29671: PUSH
29672: LD_INT 1
29674: NEG
29675: PUSH
29676: EMPTY
29677: LIST
29678: LIST
29679: PUSH
29680: LD_INT 1
29682: NEG
29683: PUSH
29684: LD_INT 2
29686: NEG
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: LD_INT 2
29697: NEG
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 1
29705: PUSH
29706: LD_INT 1
29708: NEG
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PUSH
29714: LD_INT 2
29716: PUSH
29717: LD_INT 0
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: LD_INT 1
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 2
29736: PUSH
29737: LD_INT 2
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: LD_INT 2
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 2
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 1
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 2
29777: NEG
29778: PUSH
29779: LD_INT 0
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 2
29788: NEG
29789: PUSH
29790: LD_INT 1
29792: NEG
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 2
29800: NEG
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: LIST
29829: LIST
29830: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29831: LD_ADDR_VAR 0 19
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 0
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 0
29848: PUSH
29849: LD_INT 1
29851: NEG
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 1
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: LD_INT 1
29869: PUSH
29870: LD_INT 1
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: LD_INT 1
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 1
29889: NEG
29890: PUSH
29891: LD_INT 0
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 1
29900: NEG
29901: PUSH
29902: LD_INT 1
29904: NEG
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 1
29912: NEG
29913: PUSH
29914: LD_INT 2
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 0
29924: PUSH
29925: LD_INT 2
29927: NEG
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: LD_INT 1
29938: NEG
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 2
29946: PUSH
29947: LD_INT 0
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: LD_INT 2
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 2
29966: PUSH
29967: LD_INT 2
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PUSH
29974: LD_INT 1
29976: PUSH
29977: LD_INT 2
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 2
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 1
29996: NEG
29997: PUSH
29998: LD_INT 1
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 2
30007: NEG
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: NEG
30019: PUSH
30020: LD_INT 1
30022: NEG
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 2
30030: NEG
30031: PUSH
30032: LD_INT 2
30034: NEG
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30061: LD_ADDR_VAR 0 20
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 0
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: LD_INT 1
30081: NEG
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 1
30089: PUSH
30090: LD_INT 0
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: LD_INT 1
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 0
30109: PUSH
30110: LD_INT 1
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 1
30119: NEG
30120: PUSH
30121: LD_INT 0
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 1
30130: NEG
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 1
30142: NEG
30143: PUSH
30144: LD_INT 2
30146: NEG
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: LD_INT 2
30157: NEG
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 2
30176: PUSH
30177: LD_INT 0
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 2
30186: PUSH
30187: LD_INT 1
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 2
30196: PUSH
30197: LD_INT 2
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: LD_INT 2
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 2
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 2
30237: NEG
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 2
30248: NEG
30249: PUSH
30250: LD_INT 1
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 2
30260: NEG
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30291: LD_ADDR_VAR 0 21
30295: PUSH
30296: LD_INT 0
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: LD_INT 1
30311: NEG
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 1
30319: PUSH
30320: LD_INT 0
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: LD_INT 1
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 0
30339: PUSH
30340: LD_INT 1
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 1
30349: NEG
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: LD_INT 1
30364: NEG
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: LD_INT 2
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 2
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 1
30395: PUSH
30396: LD_INT 1
30398: NEG
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 2
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 2
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: PUSH
30427: LD_INT 2
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 2
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: LD_INT 2
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 2
30478: NEG
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30521: LD_ADDR_VAR 0 22
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: LD_INT 0
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 0
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 1
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 1
30559: PUSH
30560: LD_INT 1
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 0
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 1
30579: NEG
30580: PUSH
30581: LD_INT 0
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 1
30590: NEG
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 1
30602: NEG
30603: PUSH
30604: LD_INT 2
30606: NEG
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 0
30614: PUSH
30615: LD_INT 2
30617: NEG
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PUSH
30623: LD_INT 1
30625: PUSH
30626: LD_INT 1
30628: NEG
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: PUSH
30634: LD_INT 2
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 2
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 2
30656: PUSH
30657: LD_INT 2
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: PUSH
30667: LD_INT 2
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: LD_INT 2
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 1
30686: NEG
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 2
30697: NEG
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 2
30708: NEG
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 2
30720: NEG
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: LIST
30736: LIST
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30751: LD_ADDR_VAR 0 23
30755: PUSH
30756: LD_INT 0
30758: PUSH
30759: LD_INT 0
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 0
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 1
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 1
30789: PUSH
30790: LD_INT 1
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: LD_INT 1
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: LD_INT 0
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 1
30820: NEG
30821: PUSH
30822: LD_INT 1
30824: NEG
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: LD_INT 2
30836: NEG
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 0
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 1
30855: PUSH
30856: LD_INT 1
30858: NEG
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: LD_INT 0
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 2
30876: PUSH
30877: LD_INT 1
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 2
30886: PUSH
30887: LD_INT 2
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 1
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 0
30906: PUSH
30907: LD_INT 2
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: LD_INT 1
30916: NEG
30917: PUSH
30918: LD_INT 1
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 2
30927: NEG
30928: PUSH
30929: LD_INT 0
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 2
30938: NEG
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 2
30950: NEG
30951: PUSH
30952: LD_INT 2
30954: NEG
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 2
30962: NEG
30963: PUSH
30964: LD_INT 3
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 3
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: LD_INT 2
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: LIST
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31031: LD_ADDR_VAR 0 24
31035: PUSH
31036: LD_INT 0
31038: PUSH
31039: LD_INT 0
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: PUSH
31046: LD_INT 0
31048: PUSH
31049: LD_INT 1
31051: NEG
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 1
31059: PUSH
31060: LD_INT 0
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 1
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: LD_INT 0
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 1
31104: NEG
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 0
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 1
31135: PUSH
31136: LD_INT 1
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 2
31146: PUSH
31147: LD_INT 0
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 2
31156: PUSH
31157: LD_INT 1
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 2
31166: PUSH
31167: LD_INT 2
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 1
31176: PUSH
31177: LD_INT 2
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: LD_INT 2
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: NEG
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 2
31207: NEG
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 2
31218: NEG
31219: PUSH
31220: LD_INT 1
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 2
31230: NEG
31231: PUSH
31232: LD_INT 2
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 2
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 3
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 3
31274: PUSH
31275: LD_INT 2
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: LIST
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31307: LD_ADDR_VAR 0 25
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: LD_INT 0
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: LD_INT 1
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: LD_INT 0
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 0
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: NEG
31389: PUSH
31390: LD_INT 2
31392: NEG
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 0
31400: PUSH
31401: LD_INT 2
31403: NEG
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 1
31411: PUSH
31412: LD_INT 1
31414: NEG
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 2
31422: PUSH
31423: LD_INT 0
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: LD_INT 2
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 1
31452: PUSH
31453: LD_INT 2
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: LD_INT 2
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: LD_INT 1
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 2
31494: NEG
31495: PUSH
31496: LD_INT 1
31498: NEG
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 2
31506: NEG
31507: PUSH
31508: LD_INT 2
31510: NEG
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 3
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 3
31528: PUSH
31529: LD_INT 2
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: PUSH
31539: LD_INT 3
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: PUSH
31549: LD_INT 3
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: LIST
31575: LIST
31576: LIST
31577: LIST
31578: LIST
31579: LIST
31580: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31581: LD_ADDR_VAR 0 26
31585: PUSH
31586: LD_INT 0
31588: PUSH
31589: LD_INT 0
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 0
31598: PUSH
31599: LD_INT 1
31601: NEG
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: LD_INT 0
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 1
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: LD_INT 1
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 1
31639: NEG
31640: PUSH
31641: LD_INT 0
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 1
31662: NEG
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 2
31677: NEG
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: EMPTY
31691: LIST
31692: LIST
31693: PUSH
31694: LD_INT 2
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: EMPTY
31701: LIST
31702: LIST
31703: PUSH
31704: LD_INT 2
31706: PUSH
31707: LD_INT 1
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 2
31716: PUSH
31717: LD_INT 2
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: LD_INT 2
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: LD_INT 2
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 2
31757: NEG
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 2
31780: NEG
31781: PUSH
31782: LD_INT 2
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 3
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: PUSH
31803: LD_INT 3
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: NEG
31813: PUSH
31814: LD_INT 2
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: PUSH
31821: LD_INT 2
31823: NEG
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31857: LD_ADDR_VAR 0 27
31861: PUSH
31862: LD_INT 0
31864: PUSH
31865: LD_INT 0
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 1
31895: PUSH
31896: LD_INT 1
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 0
31905: PUSH
31906: LD_INT 1
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: LD_INT 0
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 1
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: LD_INT 2
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: LD_INT 2
31953: NEG
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 1
31961: PUSH
31962: LD_INT 1
31964: NEG
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: LD_INT 0
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 2
31992: PUSH
31993: LD_INT 2
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: LD_INT 2
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 0
32012: PUSH
32013: LD_INT 2
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 1
32022: NEG
32023: PUSH
32024: LD_INT 1
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 2
32033: NEG
32034: PUSH
32035: LD_INT 0
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 2
32044: NEG
32045: PUSH
32046: LD_INT 1
32048: NEG
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 2
32056: NEG
32057: PUSH
32058: LD_INT 2
32060: NEG
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 1
32068: NEG
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 2
32079: NEG
32080: PUSH
32081: LD_INT 1
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 3
32090: NEG
32091: PUSH
32092: LD_INT 1
32094: NEG
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PUSH
32100: LD_INT 3
32102: NEG
32103: PUSH
32104: LD_INT 2
32106: NEG
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: LIST
32126: LIST
32127: LIST
32128: LIST
32129: LIST
32130: LIST
32131: LIST
32132: LIST
32133: LIST
32134: LIST
32135: LIST
32136: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32137: LD_ADDR_VAR 0 28
32141: PUSH
32142: LD_INT 0
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 1
32165: PUSH
32166: LD_INT 0
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 1
32175: PUSH
32176: LD_INT 1
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 0
32185: PUSH
32186: LD_INT 1
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: LD_INT 1
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 1
32218: NEG
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 0
32230: PUSH
32231: LD_INT 2
32233: NEG
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 2
32252: PUSH
32253: LD_INT 0
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 2
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 2
32272: PUSH
32273: LD_INT 2
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: LD_INT 2
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 0
32292: PUSH
32293: LD_INT 2
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: LD_INT 1
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: LD_INT 0
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 2
32324: NEG
32325: PUSH
32326: LD_INT 1
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 2
32336: NEG
32337: PUSH
32338: LD_INT 2
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: NEG
32349: PUSH
32350: LD_INT 3
32352: NEG
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: LD_INT 3
32364: NEG
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 3
32372: NEG
32373: PUSH
32374: LD_INT 1
32376: NEG
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 3
32384: NEG
32385: PUSH
32386: LD_INT 2
32388: NEG
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: LIST
32405: LIST
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32419: LD_ADDR_VAR 0 29
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: LD_INT 0
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 0
32436: PUSH
32437: LD_INT 1
32439: NEG
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 1
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 0
32467: PUSH
32468: LD_INT 1
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: LD_INT 1
32477: NEG
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 1
32488: NEG
32489: PUSH
32490: LD_INT 1
32492: NEG
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: LD_INT 2
32504: NEG
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: LD_INT 2
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: LD_INT 1
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 2
32534: PUSH
32535: LD_INT 0
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 1
32554: PUSH
32555: LD_INT 2
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 0
32564: PUSH
32565: LD_INT 2
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 2
32585: NEG
32586: PUSH
32587: LD_INT 1
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 2
32597: NEG
32598: PUSH
32599: LD_INT 2
32601: NEG
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: NEG
32610: PUSH
32611: LD_INT 3
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 2
32621: PUSH
32622: LD_INT 1
32624: NEG
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 3
32632: PUSH
32633: LD_INT 1
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 1
32642: PUSH
32643: LD_INT 3
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: LD_INT 2
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 3
32663: NEG
32664: PUSH
32665: LD_INT 2
32667: NEG
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32698: LD_ADDR_VAR 0 30
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: LD_INT 1
32718: NEG
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 1
32726: PUSH
32727: LD_INT 0
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 1
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 1
32756: NEG
32757: PUSH
32758: LD_INT 0
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: LD_INT 2
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: LD_INT 2
32794: NEG
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 1
32802: PUSH
32803: LD_INT 1
32805: NEG
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 2
32813: PUSH
32814: LD_INT 0
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 2
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: PUSH
32855: LD_INT 1
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 2
32864: NEG
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 1
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 3
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: LD_INT 2
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 3
32910: PUSH
32911: LD_INT 2
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 2
32920: PUSH
32921: LD_INT 3
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 2
32930: NEG
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 3
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32976: LD_ADDR_VAR 0 31
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 0
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: PUSH
33002: LD_INT 1
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 1
33014: PUSH
33015: LD_INT 1
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 1
33034: NEG
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: NEG
33046: PUSH
33047: LD_INT 1
33049: NEG
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: LD_INT 2
33061: NEG
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 1
33072: NEG
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 2
33080: PUSH
33081: LD_INT 0
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: LD_INT 2
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 0
33120: PUSH
33121: LD_INT 2
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 2
33141: NEG
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 2
33153: NEG
33154: PUSH
33155: LD_INT 2
33157: NEG
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: NEG
33166: PUSH
33167: LD_INT 3
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 2
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 3
33188: PUSH
33189: LD_INT 1
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 3
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: LD_INT 2
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 3
33219: NEG
33220: PUSH
33221: LD_INT 2
33223: NEG
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: LIST
33243: LIST
33244: LIST
33245: LIST
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: LIST
33253: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33254: LD_ADDR_VAR 0 32
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 0
33271: PUSH
33272: LD_INT 1
33274: NEG
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 1
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 0
33302: PUSH
33303: LD_INT 1
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: LD_INT 0
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 1
33335: NEG
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 1
33358: PUSH
33359: LD_INT 1
33361: NEG
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 2
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 2
33379: PUSH
33380: LD_INT 2
33382: PUSH
33383: EMPTY
33384: LIST
33385: LIST
33386: PUSH
33387: LD_INT 1
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: LD_INT 2
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 1
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 2
33420: NEG
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 2
33431: NEG
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 3
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 2
33458: NEG
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 3
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 2
33476: PUSH
33477: LD_INT 3
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 3
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: LIST
33525: LIST
33526: LIST
33527: LIST
33528: LIST
33529: LIST
33530: LIST
33531: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33532: LD_ADDR_VAR 0 33
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 0
33549: PUSH
33550: LD_INT 1
33552: NEG
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: PUSH
33561: LD_INT 0
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: LD_INT 1
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 0
33580: PUSH
33581: LD_INT 1
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 0
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: LD_INT 1
33605: NEG
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 1
33613: NEG
33614: PUSH
33615: LD_INT 2
33617: NEG
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 1
33625: PUSH
33626: LD_INT 1
33628: NEG
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 2
33636: PUSH
33637: LD_INT 0
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: PUSH
33644: LD_INT 2
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 1
33656: PUSH
33657: LD_INT 2
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: LD_INT 2
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 1
33676: NEG
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PUSH
33685: LD_INT 2
33687: NEG
33688: PUSH
33689: LD_INT 0
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: LD_INT 1
33702: NEG
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 2
33710: NEG
33711: PUSH
33712: LD_INT 2
33714: NEG
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 2
33722: NEG
33723: PUSH
33724: LD_INT 3
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 2
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 3
33745: PUSH
33746: LD_INT 1
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 1
33755: PUSH
33756: LD_INT 3
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 2
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 3
33776: NEG
33777: PUSH
33778: LD_INT 2
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: LIST
33803: LIST
33804: LIST
33805: LIST
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33811: LD_ADDR_VAR 0 34
33815: PUSH
33816: LD_INT 0
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 0
33828: PUSH
33829: LD_INT 1
33831: NEG
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 1
33849: PUSH
33850: LD_INT 1
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: LD_INT 1
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 1
33892: NEG
33893: PUSH
33894: LD_INT 2
33896: NEG
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 0
33904: PUSH
33905: LD_INT 2
33907: NEG
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 2
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 2
33936: PUSH
33937: LD_INT 2
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: LD_INT 2
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: LD_INT 1
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 2
33967: NEG
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PUSH
33976: LD_INT 2
33978: NEG
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 2
33990: NEG
33991: PUSH
33992: LD_INT 2
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: NEG
34003: PUSH
34004: LD_INT 3
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 1
34014: PUSH
34015: LD_INT 2
34017: NEG
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 3
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 2
34035: PUSH
34036: LD_INT 3
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 2
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 3
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34091: LD_ADDR_VAR 0 35
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: LD_INT 1
34111: NEG
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 1
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: LD_INT 1
34164: NEG
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: LD_INT 1
34186: NEG
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: LIST
34202: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34203: LD_ADDR_VAR 0 36
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 0
34220: PUSH
34221: LD_INT 1
34223: NEG
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 1
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 1
34241: PUSH
34242: LD_INT 1
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: NEG
34262: PUSH
34263: LD_INT 0
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: LD_INT 1
34276: NEG
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 1
34284: NEG
34285: PUSH
34286: LD_INT 2
34288: NEG
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 1
34296: PUSH
34297: LD_INT 2
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34315: LD_ADDR_VAR 0 37
34319: PUSH
34320: LD_INT 0
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 0
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: PUSH
34344: LD_INT 0
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: LD_INT 1
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 0
34363: PUSH
34364: LD_INT 1
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: LD_INT 0
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: LD_INT 1
34388: NEG
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: LIST
34426: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34427: LD_ADDR_VAR 0 38
34431: PUSH
34432: LD_INT 0
34434: PUSH
34435: LD_INT 0
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 0
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: LD_INT 1
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 0
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: NEG
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: NEG
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 2
34508: PUSH
34509: LD_INT 1
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 2
34518: NEG
34519: PUSH
34520: LD_INT 1
34522: NEG
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34539: LD_ADDR_VAR 0 39
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 0
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: NEG
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: PUSH
34633: LD_INT 2
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: LIST
34644: LIST
34645: LIST
34646: LIST
34647: LIST
34648: LIST
34649: LIST
34650: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34651: LD_ADDR_VAR 0 40
34655: PUSH
34656: LD_INT 0
34658: PUSH
34659: LD_INT 0
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: LD_INT 1
34671: NEG
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: LD_INT 1
34679: PUSH
34680: LD_INT 0
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 1
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 1
34709: NEG
34710: PUSH
34711: LD_INT 0
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 1
34720: NEG
34721: PUSH
34722: LD_INT 1
34724: NEG
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: PUSH
34733: LD_INT 1
34735: NEG
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34763: LD_ADDR_VAR 0 41
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: LD_INT 0
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: PUSH
34792: LD_INT 0
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: LD_INT 1
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 0
34811: PUSH
34812: LD_INT 1
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: NEG
34822: PUSH
34823: LD_INT 0
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: LD_INT 1
34836: NEG
34837: PUSH
34838: EMPTY
34839: LIST
34840: LIST
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 2
34887: PUSH
34888: LD_INT 2
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: LD_INT 2
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: NEG
34919: PUSH
34920: LD_INT 0
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 2
34929: NEG
34930: PUSH
34931: LD_INT 1
34933: NEG
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 2
34941: NEG
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: NEG
34954: PUSH
34955: LD_INT 3
34957: NEG
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 2
34965: PUSH
34966: LD_INT 1
34968: NEG
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 3
34976: PUSH
34977: LD_INT 0
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 3
34986: PUSH
34987: LD_INT 1
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 3
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: LD_INT 3
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: LD_INT 3
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 2
35026: NEG
35027: PUSH
35028: LD_INT 1
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 3
35037: NEG
35038: PUSH
35039: LD_INT 0
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: LD_INT 1
35052: NEG
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 3
35060: NEG
35061: PUSH
35062: LD_INT 2
35064: NEG
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 3
35072: NEG
35073: PUSH
35074: LD_INT 3
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35113: LD_ADDR_VAR 0 42
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: LD_INT 0
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 0
35130: PUSH
35131: LD_INT 1
35133: NEG
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 1
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: LD_INT 1
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: NEG
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: LD_INT 1
35186: NEG
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 1
35194: NEG
35195: PUSH
35196: LD_INT 2
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: LD_INT 2
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 2
35228: PUSH
35229: LD_INT 1
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: LD_INT 2
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: LD_INT 2
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: LD_INT 2
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: NEG
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 2
35279: NEG
35280: PUSH
35281: LD_INT 1
35283: NEG
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: LD_INT 2
35291: NEG
35292: PUSH
35293: LD_INT 2
35295: NEG
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 2
35303: NEG
35304: PUSH
35305: LD_INT 3
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 3
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 0
35327: PUSH
35328: LD_INT 3
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: LD_INT 2
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 3
35349: PUSH
35350: LD_INT 2
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 3
35359: PUSH
35360: LD_INT 3
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 2
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: PUSH
35380: LD_INT 3
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 0
35389: PUSH
35390: LD_INT 3
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 1
35399: NEG
35400: PUSH
35401: LD_INT 2
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 3
35410: NEG
35411: PUSH
35412: LD_INT 2
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 3
35422: NEG
35423: PUSH
35424: LD_INT 3
35426: NEG
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35463: LD_ADDR_VAR 0 43
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: LD_INT 0
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 0
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: LD_INT 2
35548: NEG
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 2
35559: NEG
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 1
35570: NEG
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 2
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 2
35588: PUSH
35589: LD_INT 1
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: LD_INT 2
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: LD_INT 1
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: LD_INT 3
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 0
35664: PUSH
35665: LD_INT 3
35667: NEG
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 1
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 3
35697: PUSH
35698: LD_INT 0
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 3
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: LD_INT 3
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 0
35727: PUSH
35728: LD_INT 3
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 2
35748: NEG
35749: PUSH
35750: LD_INT 1
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 3
35759: NEG
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 3
35770: NEG
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35811: LD_ADDR_VAR 0 44
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: LD_INT 0
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 0
35828: PUSH
35829: LD_INT 1
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 1
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: LD_INT 1
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 0
35859: PUSH
35860: LD_INT 1
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: LD_INT 1
35884: NEG
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: LD_INT 2
35896: NEG
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: PUSH
35905: LD_INT 1
35907: NEG
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 2
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 2
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 1
35955: NEG
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 2
35966: NEG
35967: PUSH
35968: LD_INT 0
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: LD_INT 1
35981: NEG
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 2
35989: NEG
35990: PUSH
35991: LD_INT 2
35993: NEG
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 2
36001: NEG
36002: PUSH
36003: LD_INT 3
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: PUSH
36014: LD_INT 1
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 3
36024: PUSH
36025: LD_INT 0
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 3
36034: PUSH
36035: LD_INT 1
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 3
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: LD_INT 3
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: PUSH
36065: LD_INT 3
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 2
36074: NEG
36075: PUSH
36076: LD_INT 1
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 3
36085: NEG
36086: PUSH
36087: LD_INT 0
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: LD_INT 1
36100: NEG
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 3
36108: NEG
36109: PUSH
36110: LD_INT 2
36112: NEG
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 3
36120: NEG
36121: PUSH
36122: LD_INT 3
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36161: LD_ADDR_VAR 0 45
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 1
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: NEG
36220: PUSH
36221: LD_INT 0
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 1
36230: NEG
36231: PUSH
36232: LD_INT 1
36234: NEG
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: NEG
36243: PUSH
36244: LD_INT 2
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: LD_INT 2
36257: NEG
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 2
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: LD_INT 2
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: NEG
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 2
36327: NEG
36328: PUSH
36329: LD_INT 1
36331: NEG
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 2
36339: NEG
36340: PUSH
36341: LD_INT 2
36343: NEG
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 2
36351: NEG
36352: PUSH
36353: LD_INT 3
36355: NEG
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 3
36367: NEG
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: LD_INT 3
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: LD_INT 2
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 3
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 3
36407: PUSH
36408: LD_INT 3
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: LD_INT 3
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 1
36427: PUSH
36428: LD_INT 3
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 0
36437: PUSH
36438: LD_INT 3
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: LD_INT 2
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 3
36458: NEG
36459: PUSH
36460: LD_INT 2
36462: NEG
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 3
36470: NEG
36471: PUSH
36472: LD_INT 3
36474: NEG
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36511: LD_ADDR_VAR 0 46
36515: PUSH
36516: LD_INT 0
36518: PUSH
36519: LD_INT 0
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 0
36528: PUSH
36529: LD_INT 1
36531: NEG
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 1
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 0
36559: PUSH
36560: LD_INT 1
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PUSH
36567: LD_INT 1
36569: NEG
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 1
36580: NEG
36581: PUSH
36582: LD_INT 1
36584: NEG
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 0
36604: PUSH
36605: LD_INT 2
36607: NEG
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: LD_INT 0
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: LD_INT 1
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 1
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: LD_INT 2
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 1
36666: NEG
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 2
36677: NEG
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 2
36688: NEG
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: LD_INT 3
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 0
36712: PUSH
36713: LD_INT 3
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: LD_INT 2
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 1
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 0
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 3
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 1
36765: PUSH
36766: LD_INT 3
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: LD_INT 3
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: LD_INT 2
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 3
36807: NEG
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 3
36818: NEG
36819: PUSH
36820: LD_INT 1
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36859: LD_ADDR_VAR 0 47
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 0
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 1
36917: NEG
36918: PUSH
36919: LD_INT 0
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 1
36928: NEG
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: LD_INT 2
36944: NEG
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: LD_INT 2
36955: NEG
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 1
36963: PUSH
36964: LD_INT 1
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 2
36974: NEG
36975: PUSH
36976: LD_INT 1
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 2
36986: NEG
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37010: LD_ADDR_VAR 0 48
37014: PUSH
37015: LD_INT 0
37017: PUSH
37018: LD_INT 0
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: LD_INT 1
37030: NEG
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 1
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: LD_INT 1
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: LD_INT 1
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: LD_INT 1
37068: NEG
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: LD_INT 2
37095: NEG
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: LD_INT 2
37106: NEG
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 2
37125: PUSH
37126: LD_INT 0
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 2
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37157: LD_ADDR_VAR 0 49
37161: PUSH
37162: LD_INT 0
37164: PUSH
37165: LD_INT 0
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 0
37174: PUSH
37175: LD_INT 1
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 1
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: LD_INT 1
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: NEG
37216: PUSH
37217: LD_INT 0
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 1
37230: NEG
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 1
37238: PUSH
37239: LD_INT 1
37241: NEG
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 2
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 2
37259: PUSH
37260: LD_INT 1
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 2
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: LD_INT 2
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37301: LD_ADDR_VAR 0 50
37305: PUSH
37306: LD_INT 0
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: LD_INT 1
37321: NEG
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 1
37329: PUSH
37330: LD_INT 0
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: LD_INT 1
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: LD_INT 1
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: LD_INT 0
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: LD_INT 1
37374: NEG
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: PUSH
37383: LD_INT 1
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: LD_INT 2
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: PUSH
37403: LD_INT 2
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 0
37412: PUSH
37413: LD_INT 2
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: LIST
37439: LIST
37440: LIST
37441: LIST
37442: LIST
37443: LIST
37444: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37445: LD_ADDR_VAR 0 51
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: LD_INT 0
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 1
37465: NEG
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 1
37483: PUSH
37484: LD_INT 1
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 0
37493: PUSH
37494: LD_INT 1
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 1
37514: NEG
37515: PUSH
37516: LD_INT 1
37518: NEG
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 1
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 0
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: LD_INT 1
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: LD_INT 1
37572: NEG
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37592: LD_ADDR_VAR 0 52
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: LD_INT 1
37612: NEG
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 1
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 1
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 1
37661: NEG
37662: PUSH
37663: LD_INT 1
37665: NEG
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: LD_INT 2
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 1
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 2
37696: NEG
37697: PUSH
37698: LD_INT 0
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 2
37707: NEG
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: NEG
37720: PUSH
37721: LD_INT 2
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: LIST
37741: LIST
37742: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37743: LD_ADDR_VAR 0 53
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 0
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: LD_INT 1
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: LD_INT 0
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 1
37781: PUSH
37782: LD_INT 1
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 1
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: LD_INT 0
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 1
37812: NEG
37813: PUSH
37814: LD_INT 1
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 1
37824: NEG
37825: PUSH
37826: LD_INT 2
37828: NEG
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 0
37836: PUSH
37837: LD_INT 2
37839: NEG
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 1
37847: PUSH
37848: LD_INT 1
37850: NEG
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 2
37858: PUSH
37859: LD_INT 0
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 2
37868: PUSH
37869: LD_INT 1
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 2
37878: PUSH
37879: LD_INT 2
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: PUSH
37889: LD_INT 2
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 0
37898: PUSH
37899: LD_INT 2
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 1
37908: NEG
37909: PUSH
37910: LD_INT 1
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 2
37919: NEG
37920: PUSH
37921: LD_INT 0
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: NEG
37931: PUSH
37932: LD_INT 1
37934: NEG
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 2
37942: NEG
37943: PUSH
37944: LD_INT 2
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37973: LD_ADDR_VAR 0 54
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 0
37990: PUSH
37991: LD_INT 1
37993: NEG
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 0
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: LD_INT 1
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: LD_INT 1
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: NEG
38032: PUSH
38033: LD_INT 0
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 1
38042: NEG
38043: PUSH
38044: LD_INT 1
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 1
38054: NEG
38055: PUSH
38056: LD_INT 2
38058: NEG
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 0
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: LD_INT 1
38080: NEG
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 2
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 2
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 2
38108: PUSH
38109: LD_INT 2
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 1
38118: PUSH
38119: LD_INT 2
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 1
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 2
38149: NEG
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 2
38160: NEG
38161: PUSH
38162: LD_INT 1
38164: NEG
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 2
38172: NEG
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: LIST
38202: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38203: LD_ADDR_VAR 0 55
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: LD_INT 0
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 0
38220: PUSH
38221: LD_INT 1
38223: NEG
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 1
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 1
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: LD_INT 0
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: LD_INT 1
38276: NEG
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 1
38284: NEG
38285: PUSH
38286: LD_INT 2
38288: NEG
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: LD_INT 2
38299: NEG
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 1
38307: PUSH
38308: LD_INT 1
38310: NEG
38311: PUSH
38312: EMPTY
38313: LIST
38314: LIST
38315: PUSH
38316: LD_INT 2
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 2
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 2
38338: PUSH
38339: LD_INT 2
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 2
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: LD_INT 2
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: NEG
38380: PUSH
38381: LD_INT 0
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 2
38390: NEG
38391: PUSH
38392: LD_INT 1
38394: NEG
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: NEG
38403: PUSH
38404: LD_INT 2
38406: NEG
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38433: LD_ADDR_VAR 0 56
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 1
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 0
38481: PUSH
38482: LD_INT 1
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 1
38491: NEG
38492: PUSH
38493: LD_INT 0
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: NEG
38503: PUSH
38504: LD_INT 1
38506: NEG
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: NEG
38515: PUSH
38516: LD_INT 2
38518: NEG
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: LD_INT 2
38529: NEG
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 1
38537: PUSH
38538: LD_INT 1
38540: NEG
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 2
38548: PUSH
38549: LD_INT 0
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 2
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 2
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 2
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 2
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 1
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 2
38609: NEG
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: NEG
38621: PUSH
38622: LD_INT 1
38624: NEG
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: NEG
38633: PUSH
38634: LD_INT 2
38636: NEG
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38663: LD_ADDR_VAR 0 57
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: LD_INT 0
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 0
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 0
38711: PUSH
38712: LD_INT 1
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: LD_INT 0
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 1
38732: NEG
38733: PUSH
38734: LD_INT 1
38736: NEG
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 1
38744: NEG
38745: PUSH
38746: LD_INT 2
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 0
38756: PUSH
38757: LD_INT 2
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 2
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 2
38798: PUSH
38799: LD_INT 2
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: LD_INT 2
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: LD_INT 2
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 1
38828: NEG
38829: PUSH
38830: LD_INT 1
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 2
38839: NEG
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 2
38850: NEG
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 2
38862: NEG
38863: PUSH
38864: LD_INT 2
38866: NEG
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38893: LD_ADDR_VAR 0 58
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: LD_INT 0
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 0
38910: PUSH
38911: LD_INT 1
38913: NEG
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 1
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 1
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: LD_INT 1
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 1
38951: NEG
38952: PUSH
38953: LD_INT 0
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 1
38962: NEG
38963: PUSH
38964: LD_INT 1
38966: NEG
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 1
38974: NEG
38975: PUSH
38976: LD_INT 2
38978: NEG
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 2
38989: NEG
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: LD_INT 1
39000: NEG
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: LD_INT 2
39018: PUSH
39019: LD_INT 1
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 2
39028: PUSH
39029: LD_INT 2
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: LD_INT 2
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 0
39048: PUSH
39049: LD_INT 2
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 1
39058: NEG
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 2
39080: NEG
39081: PUSH
39082: LD_INT 1
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 2
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39123: LD_ADDR_VAR 0 59
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: LD_INT 0
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 0
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 1
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: LD_INT 1
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 1
39181: NEG
39182: PUSH
39183: LD_INT 0
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: LD_INT 1
39196: NEG
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: LIST
39210: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39211: LD_ADDR_VAR 0 60
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 0
39228: PUSH
39229: LD_INT 1
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 1
39239: PUSH
39240: LD_INT 0
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 1
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 0
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: LD_INT 0
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 1
39280: NEG
39281: PUSH
39282: LD_INT 1
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39299: LD_ADDR_VAR 0 61
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 1
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 0
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39387: LD_ADDR_VAR 0 62
39391: PUSH
39392: LD_INT 0
39394: PUSH
39395: LD_INT 0
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: LD_INT 1
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 0
39435: PUSH
39436: LD_INT 1
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 1
39445: NEG
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 1
39456: NEG
39457: PUSH
39458: LD_INT 1
39460: NEG
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39475: LD_ADDR_VAR 0 63
39479: PUSH
39480: LD_INT 0
39482: PUSH
39483: LD_INT 0
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 0
39492: PUSH
39493: LD_INT 1
39495: NEG
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 1
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 1
39513: PUSH
39514: LD_INT 1
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 0
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 0
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PUSH
39542: LD_INT 1
39544: NEG
39545: PUSH
39546: LD_INT 1
39548: NEG
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: LIST
39560: LIST
39561: LIST
39562: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39563: LD_ADDR_VAR 0 64
39567: PUSH
39568: LD_INT 0
39570: PUSH
39571: LD_INT 0
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 0
39580: PUSH
39581: LD_INT 1
39583: NEG
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 1
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 0
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 1
39621: NEG
39622: PUSH
39623: LD_INT 0
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: NEG
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: ST_TO_ADDR
// end ; 1 :
39651: GO 45548
39653: LD_INT 1
39655: DOUBLE
39656: EQUAL
39657: IFTRUE 39661
39659: GO 42284
39661: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39662: LD_ADDR_VAR 0 11
39666: PUSH
39667: LD_INT 1
39669: NEG
39670: PUSH
39671: LD_INT 3
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: LD_INT 3
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: PUSH
39693: LD_INT 2
39695: NEG
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39706: LD_ADDR_VAR 0 12
39710: PUSH
39711: LD_INT 2
39713: PUSH
39714: LD_INT 1
39716: NEG
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 3
39724: PUSH
39725: LD_INT 0
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: LD_INT 1
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: LIST
39746: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39747: LD_ADDR_VAR 0 13
39751: PUSH
39752: LD_INT 3
39754: PUSH
39755: LD_INT 2
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 3
39764: PUSH
39765: LD_INT 3
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: PUSH
39772: LD_INT 2
39774: PUSH
39775: LD_INT 3
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: LIST
39786: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39787: LD_ADDR_VAR 0 14
39791: PUSH
39792: LD_INT 1
39794: PUSH
39795: LD_INT 3
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 0
39804: PUSH
39805: LD_INT 3
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 2
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: LIST
39827: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39828: LD_ADDR_VAR 0 15
39832: PUSH
39833: LD_INT 2
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 3
39846: NEG
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: NEG
39858: PUSH
39859: LD_INT 1
39861: NEG
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: LIST
39871: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39872: LD_ADDR_VAR 0 16
39876: PUSH
39877: LD_INT 2
39879: NEG
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 3
39891: NEG
39892: PUSH
39893: LD_INT 2
39895: NEG
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 3
39903: NEG
39904: PUSH
39905: LD_INT 3
39907: NEG
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39918: LD_ADDR_VAR 0 17
39922: PUSH
39923: LD_INT 1
39925: NEG
39926: PUSH
39927: LD_INT 3
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 0
39937: PUSH
39938: LD_INT 3
39940: NEG
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: PUSH
39949: LD_INT 2
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39962: LD_ADDR_VAR 0 18
39966: PUSH
39967: LD_INT 2
39969: PUSH
39970: LD_INT 1
39972: NEG
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 3
39990: PUSH
39991: LD_INT 1
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: LIST
40002: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40003: LD_ADDR_VAR 0 19
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: LD_INT 2
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 3
40020: PUSH
40021: LD_INT 3
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 2
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: LIST
40042: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40043: LD_ADDR_VAR 0 20
40047: PUSH
40048: LD_INT 1
40050: PUSH
40051: LD_INT 3
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 0
40060: PUSH
40061: LD_INT 3
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 1
40070: NEG
40071: PUSH
40072: LD_INT 2
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: LIST
40083: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40084: LD_ADDR_VAR 0 21
40088: PUSH
40089: LD_INT 2
40091: NEG
40092: PUSH
40093: LD_INT 1
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: LD_INT 3
40102: NEG
40103: PUSH
40104: LD_INT 0
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 3
40113: NEG
40114: PUSH
40115: LD_INT 1
40117: NEG
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: LIST
40127: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40128: LD_ADDR_VAR 0 22
40132: PUSH
40133: LD_INT 2
40135: NEG
40136: PUSH
40137: LD_INT 3
40139: NEG
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 3
40159: NEG
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: LIST
40173: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40174: LD_ADDR_VAR 0 23
40178: PUSH
40179: LD_INT 0
40181: PUSH
40182: LD_INT 3
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: NEG
40193: PUSH
40194: LD_INT 4
40196: NEG
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: LD_INT 3
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40218: LD_ADDR_VAR 0 24
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 4
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: LIST
40258: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40259: LD_ADDR_VAR 0 25
40263: PUSH
40264: LD_INT 3
40266: PUSH
40267: LD_INT 3
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 3
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 3
40286: PUSH
40287: LD_INT 4
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: LIST
40298: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40299: LD_ADDR_VAR 0 26
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: LD_INT 3
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 1
40316: PUSH
40317: LD_INT 4
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: LD_INT 3
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: LIST
40339: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40340: LD_ADDR_VAR 0 27
40344: PUSH
40345: LD_INT 3
40347: NEG
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 3
40358: NEG
40359: PUSH
40360: LD_INT 1
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 4
40369: NEG
40370: PUSH
40371: LD_INT 1
40373: NEG
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: LIST
40383: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40384: LD_ADDR_VAR 0 28
40388: PUSH
40389: LD_INT 3
40391: NEG
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 3
40403: NEG
40404: PUSH
40405: LD_INT 4
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: LD_INT 3
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: LIST
40429: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40430: LD_ADDR_VAR 0 29
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: LD_INT 3
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: LD_INT 3
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 2
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: LD_INT 4
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 0
40483: PUSH
40484: LD_INT 4
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: PUSH
40495: LD_INT 3
40497: NEG
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 1
40505: NEG
40506: PUSH
40507: LD_INT 5
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 5
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: LD_INT 4
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 1
40539: NEG
40540: PUSH
40541: LD_INT 6
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 0
40551: PUSH
40552: LD_INT 6
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 5
40565: NEG
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: EMPTY
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40585: LD_ADDR_VAR 0 30
40589: PUSH
40590: LD_INT 2
40592: PUSH
40593: LD_INT 1
40595: NEG
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 3
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 3
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 3
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 4
40634: PUSH
40635: LD_INT 0
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: LD_INT 4
40644: PUSH
40645: LD_INT 1
40647: PUSH
40648: EMPTY
40649: LIST
40650: LIST
40651: PUSH
40652: LD_INT 4
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 5
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 5
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 5
40685: PUSH
40686: LD_INT 1
40688: NEG
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 6
40696: PUSH
40697: LD_INT 0
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 6
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40728: LD_ADDR_VAR 0 31
40732: PUSH
40733: LD_INT 3
40735: PUSH
40736: LD_INT 2
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 3
40745: PUSH
40746: LD_INT 3
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 2
40755: PUSH
40756: LD_INT 3
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 4
40765: PUSH
40766: LD_INT 3
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 4
40775: PUSH
40776: LD_INT 4
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 3
40785: PUSH
40786: LD_INT 4
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 5
40795: PUSH
40796: LD_INT 4
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 5
40805: PUSH
40806: LD_INT 5
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 4
40815: PUSH
40816: LD_INT 5
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 6
40825: PUSH
40826: LD_INT 5
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 6
40835: PUSH
40836: LD_INT 6
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 5
40845: PUSH
40846: LD_INT 6
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40867: LD_ADDR_VAR 0 32
40871: PUSH
40872: LD_INT 1
40874: PUSH
40875: LD_INT 3
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: LD_INT 3
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 1
40894: NEG
40895: PUSH
40896: LD_INT 2
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 1
40905: PUSH
40906: LD_INT 4
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 0
40915: PUSH
40916: LD_INT 4
40918: PUSH
40919: EMPTY
40920: LIST
40921: LIST
40922: PUSH
40923: LD_INT 1
40925: NEG
40926: PUSH
40927: LD_INT 3
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: PUSH
40934: LD_INT 1
40936: PUSH
40937: LD_INT 5
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 0
40946: PUSH
40947: LD_INT 5
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: LD_INT 4
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: LD_INT 6
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 6
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: LD_INT 5
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41010: LD_ADDR_VAR 0 33
41014: PUSH
41015: LD_INT 2
41017: NEG
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 3
41028: NEG
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: LD_INT 1
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 0
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 4
41073: NEG
41074: PUSH
41075: LD_INT 1
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 4
41085: NEG
41086: PUSH
41087: LD_INT 1
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 5
41107: NEG
41108: PUSH
41109: LD_INT 1
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 5
41119: NEG
41120: PUSH
41121: LD_INT 1
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 6
41130: NEG
41131: PUSH
41132: LD_INT 0
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 6
41141: NEG
41142: PUSH
41143: LD_INT 1
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41165: LD_ADDR_VAR 0 34
41169: PUSH
41170: LD_INT 2
41172: NEG
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 3
41184: NEG
41185: PUSH
41186: LD_INT 2
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: NEG
41197: PUSH
41198: LD_INT 3
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: LD_INT 4
41212: NEG
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 4
41220: NEG
41221: PUSH
41222: LD_INT 3
41224: NEG
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 4
41232: NEG
41233: PUSH
41234: LD_INT 4
41236: NEG
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 4
41244: NEG
41245: PUSH
41246: LD_INT 5
41248: NEG
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 5
41256: NEG
41257: PUSH
41258: LD_INT 4
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 5
41268: NEG
41269: PUSH
41270: LD_INT 5
41272: NEG
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 5
41280: NEG
41281: PUSH
41282: LD_INT 6
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 6
41292: NEG
41293: PUSH
41294: LD_INT 5
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 6
41304: NEG
41305: PUSH
41306: LD_INT 6
41308: NEG
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: LIST
41318: LIST
41319: LIST
41320: LIST
41321: LIST
41322: LIST
41323: LIST
41324: LIST
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41328: LD_ADDR_VAR 0 41
41332: PUSH
41333: LD_INT 0
41335: PUSH
41336: LD_INT 2
41338: NEG
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 1
41346: NEG
41347: PUSH
41348: LD_INT 3
41350: NEG
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: LD_INT 2
41361: NEG
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: LIST
41371: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41372: LD_ADDR_VAR 0 42
41376: PUSH
41377: LD_INT 2
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 2
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 3
41400: PUSH
41401: LD_INT 1
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: LIST
41412: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41413: LD_ADDR_VAR 0 43
41417: PUSH
41418: LD_INT 2
41420: PUSH
41421: LD_INT 2
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 3
41430: PUSH
41431: LD_INT 2
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 2
41440: PUSH
41441: LD_INT 3
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: LIST
41452: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41453: LD_ADDR_VAR 0 44
41457: PUSH
41458: LD_INT 0
41460: PUSH
41461: LD_INT 2
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 1
41470: PUSH
41471: LD_INT 3
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 1
41480: NEG
41481: PUSH
41482: LD_INT 2
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41494: LD_ADDR_VAR 0 45
41498: PUSH
41499: LD_INT 2
41501: NEG
41502: PUSH
41503: LD_INT 0
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: LD_INT 1
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 3
41523: NEG
41524: PUSH
41525: LD_INT 1
41527: NEG
41528: PUSH
41529: EMPTY
41530: LIST
41531: LIST
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: LIST
41537: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41538: LD_ADDR_VAR 0 46
41542: PUSH
41543: LD_INT 2
41545: NEG
41546: PUSH
41547: LD_INT 2
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 2
41557: NEG
41558: PUSH
41559: LD_INT 3
41561: NEG
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 3
41569: NEG
41570: PUSH
41571: LD_INT 2
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: LIST
41583: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41584: LD_ADDR_VAR 0 47
41588: PUSH
41589: LD_INT 2
41591: NEG
41592: PUSH
41593: LD_INT 3
41595: NEG
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 1
41603: NEG
41604: PUSH
41605: LD_INT 3
41607: NEG
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: EMPTY
41614: LIST
41615: LIST
41616: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41617: LD_ADDR_VAR 0 48
41621: PUSH
41622: LD_INT 1
41624: PUSH
41625: LD_INT 2
41627: NEG
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: LD_INT 2
41635: PUSH
41636: LD_INT 1
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41648: LD_ADDR_VAR 0 49
41652: PUSH
41653: LD_INT 3
41655: PUSH
41656: LD_INT 1
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 3
41665: PUSH
41666: LD_INT 2
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41677: LD_ADDR_VAR 0 50
41681: PUSH
41682: LD_INT 2
41684: PUSH
41685: LD_INT 3
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: LD_INT 3
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41706: LD_ADDR_VAR 0 51
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 2
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 2
41724: NEG
41725: PUSH
41726: LD_INT 1
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41737: LD_ADDR_VAR 0 52
41741: PUSH
41742: LD_INT 3
41744: NEG
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 3
41756: NEG
41757: PUSH
41758: LD_INT 2
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41770: LD_ADDR_VAR 0 53
41774: PUSH
41775: LD_INT 1
41777: NEG
41778: PUSH
41779: LD_INT 3
41781: NEG
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 0
41789: PUSH
41790: LD_INT 3
41792: NEG
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: PUSH
41801: LD_INT 2
41803: NEG
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41814: LD_ADDR_VAR 0 54
41818: PUSH
41819: LD_INT 2
41821: PUSH
41822: LD_INT 1
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 3
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: LD_INT 3
41842: PUSH
41843: LD_INT 1
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: LIST
41854: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41855: LD_ADDR_VAR 0 55
41859: PUSH
41860: LD_INT 3
41862: PUSH
41863: LD_INT 2
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 3
41872: PUSH
41873: LD_INT 3
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 2
41882: PUSH
41883: LD_INT 3
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: LIST
41894: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41895: LD_ADDR_VAR 0 56
41899: PUSH
41900: LD_INT 1
41902: PUSH
41903: LD_INT 3
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PUSH
41910: LD_INT 0
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 1
41922: NEG
41923: PUSH
41924: LD_INT 2
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: LIST
41935: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41936: LD_ADDR_VAR 0 57
41940: PUSH
41941: LD_INT 2
41943: NEG
41944: PUSH
41945: LD_INT 1
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 3
41954: NEG
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 3
41965: NEG
41966: PUSH
41967: LD_INT 1
41969: NEG
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: LIST
41979: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41980: LD_ADDR_VAR 0 58
41984: PUSH
41985: LD_INT 2
41987: NEG
41988: PUSH
41989: LD_INT 3
41991: NEG
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 3
41999: NEG
42000: PUSH
42001: LD_INT 2
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 3
42011: NEG
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: LIST
42025: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42026: LD_ADDR_VAR 0 59
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: LD_INT 2
42037: NEG
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 0
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 1
42056: PUSH
42057: LD_INT 1
42059: NEG
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: LIST
42069: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42070: LD_ADDR_VAR 0 60
42074: PUSH
42075: LD_INT 1
42077: PUSH
42078: LD_INT 1
42080: NEG
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 2
42088: PUSH
42089: LD_INT 0
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 2
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42111: LD_ADDR_VAR 0 61
42115: PUSH
42116: LD_INT 2
42118: PUSH
42119: LD_INT 1
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 2
42128: PUSH
42129: LD_INT 2
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 1
42138: PUSH
42139: LD_INT 2
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: LIST
42150: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42151: LD_ADDR_VAR 0 62
42155: PUSH
42156: LD_INT 1
42158: PUSH
42159: LD_INT 2
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 0
42168: PUSH
42169: LD_INT 2
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: NEG
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: LIST
42191: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42192: LD_ADDR_VAR 0 63
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: LD_INT 1
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 2
42210: NEG
42211: PUSH
42212: LD_INT 0
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 2
42221: NEG
42222: PUSH
42223: LD_INT 1
42225: NEG
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42236: LD_ADDR_VAR 0 64
42240: PUSH
42241: LD_INT 1
42243: NEG
42244: PUSH
42245: LD_INT 2
42247: NEG
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: NEG
42256: PUSH
42257: LD_INT 1
42259: NEG
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 2
42267: NEG
42268: PUSH
42269: LD_INT 2
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: LIST
42281: ST_TO_ADDR
// end ; 2 :
42282: GO 45548
42284: LD_INT 2
42286: DOUBLE
42287: EQUAL
42288: IFTRUE 42292
42290: GO 45547
42292: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42293: LD_ADDR_VAR 0 29
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: LD_INT 0
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 4
42310: PUSH
42311: LD_INT 1
42313: NEG
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 5
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 5
42331: PUSH
42332: LD_INT 1
42334: PUSH
42335: EMPTY
42336: LIST
42337: LIST
42338: PUSH
42339: LD_INT 4
42341: PUSH
42342: LD_INT 1
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: PUSH
42349: LD_INT 3
42351: PUSH
42352: LD_INT 0
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 3
42361: PUSH
42362: LD_INT 1
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 3
42372: PUSH
42373: LD_INT 2
42375: NEG
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 5
42383: PUSH
42384: LD_INT 2
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 3
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 3
42403: PUSH
42404: LD_INT 2
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 4
42413: PUSH
42414: LD_INT 3
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 4
42423: PUSH
42424: LD_INT 4
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 3
42433: PUSH
42434: LD_INT 4
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 2
42443: PUSH
42444: LD_INT 3
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 2
42453: PUSH
42454: LD_INT 2
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: LD_INT 2
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 2
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 0
42483: PUSH
42484: LD_INT 4
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: LD_INT 3
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: PUSH
42504: LD_INT 4
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 1
42513: PUSH
42514: LD_INT 5
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 0
42523: PUSH
42524: LD_INT 5
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 1
42533: NEG
42534: PUSH
42535: LD_INT 4
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 1
42544: NEG
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 2
42555: PUSH
42556: LD_INT 5
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 2
42565: NEG
42566: PUSH
42567: LD_INT 3
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 3
42576: NEG
42577: PUSH
42578: LD_INT 0
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 3
42587: NEG
42588: PUSH
42589: LD_INT 1
42591: NEG
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: PUSH
42597: LD_INT 2
42599: NEG
42600: PUSH
42601: LD_INT 0
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 2
42610: NEG
42611: PUSH
42612: LD_INT 1
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: LD_INT 3
42621: NEG
42622: PUSH
42623: LD_INT 1
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 4
42632: NEG
42633: PUSH
42634: LD_INT 0
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 1
42647: NEG
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 4
42655: NEG
42656: PUSH
42657: LD_INT 2
42659: NEG
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 2
42667: NEG
42668: PUSH
42669: LD_INT 2
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 4
42678: NEG
42679: PUSH
42680: LD_INT 4
42682: NEG
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 4
42690: NEG
42691: PUSH
42692: LD_INT 5
42694: NEG
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 3
42702: NEG
42703: PUSH
42704: LD_INT 4
42706: NEG
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 3
42714: NEG
42715: PUSH
42716: LD_INT 3
42718: NEG
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 4
42726: NEG
42727: PUSH
42728: LD_INT 3
42730: NEG
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 5
42738: NEG
42739: PUSH
42740: LD_INT 4
42742: NEG
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 5
42750: NEG
42751: PUSH
42752: LD_INT 5
42754: NEG
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 3
42762: NEG
42763: PUSH
42764: LD_INT 5
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 5
42774: NEG
42775: PUSH
42776: LD_INT 3
42778: NEG
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: LIST
42795: LIST
42796: LIST
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: LIST
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42831: LD_ADDR_VAR 0 30
42835: PUSH
42836: LD_INT 4
42838: PUSH
42839: LD_INT 4
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 4
42848: PUSH
42849: LD_INT 3
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 5
42858: PUSH
42859: LD_INT 4
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 5
42868: PUSH
42869: LD_INT 5
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 4
42878: PUSH
42879: LD_INT 5
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: LD_INT 4
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 3
42898: PUSH
42899: LD_INT 3
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 5
42908: PUSH
42909: LD_INT 3
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: LD_INT 3
42918: PUSH
42919: LD_INT 5
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: LD_INT 3
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 0
42938: PUSH
42939: LD_INT 2
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: PUSH
42946: LD_INT 1
42948: PUSH
42949: LD_INT 3
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 1
42958: PUSH
42959: LD_INT 4
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: PUSH
42966: LD_INT 0
42968: PUSH
42969: LD_INT 4
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: LD_INT 3
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 1
42989: NEG
42990: PUSH
42991: LD_INT 2
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 2
43000: PUSH
43001: LD_INT 4
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 2
43010: NEG
43011: PUSH
43012: LD_INT 2
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 4
43021: NEG
43022: PUSH
43023: LD_INT 0
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 4
43032: NEG
43033: PUSH
43034: LD_INT 1
43036: NEG
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 3
43044: NEG
43045: PUSH
43046: LD_INT 0
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 3
43055: NEG
43056: PUSH
43057: LD_INT 1
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: LD_INT 4
43066: NEG
43067: PUSH
43068: LD_INT 1
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 5
43077: NEG
43078: PUSH
43079: LD_INT 0
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 5
43088: NEG
43089: PUSH
43090: LD_INT 1
43092: NEG
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 5
43100: NEG
43101: PUSH
43102: LD_INT 2
43104: NEG
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 3
43112: NEG
43113: PUSH
43114: LD_INT 2
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 3
43123: NEG
43124: PUSH
43125: LD_INT 3
43127: NEG
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 3
43135: NEG
43136: PUSH
43137: LD_INT 4
43139: NEG
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 2
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: NEG
43160: PUSH
43161: LD_INT 2
43163: NEG
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 3
43171: NEG
43172: PUSH
43173: LD_INT 2
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 4
43183: NEG
43184: PUSH
43185: LD_INT 3
43187: NEG
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PUSH
43193: LD_INT 4
43195: NEG
43196: PUSH
43197: LD_INT 4
43199: NEG
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 2
43207: NEG
43208: PUSH
43209: LD_INT 4
43211: NEG
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 4
43219: NEG
43220: PUSH
43221: LD_INT 2
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 0
43231: PUSH
43232: LD_INT 4
43234: NEG
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: LD_INT 0
43242: PUSH
43243: LD_INT 5
43245: NEG
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: LD_INT 4
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 1
43264: PUSH
43265: LD_INT 3
43267: NEG
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 0
43275: PUSH
43276: LD_INT 3
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 1
43286: NEG
43287: PUSH
43288: LD_INT 4
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 1
43298: NEG
43299: PUSH
43300: LD_INT 5
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 2
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 2
43321: NEG
43322: PUSH
43323: LD_INT 5
43325: NEG
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: LIST
43335: LIST
43336: LIST
43337: LIST
43338: LIST
43339: LIST
43340: LIST
43341: LIST
43342: LIST
43343: LIST
43344: LIST
43345: LIST
43346: LIST
43347: LIST
43348: LIST
43349: LIST
43350: LIST
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: LIST
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43378: LD_ADDR_VAR 0 31
43382: PUSH
43383: LD_INT 0
43385: PUSH
43386: LD_INT 4
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 0
43395: PUSH
43396: LD_INT 3
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 1
43405: PUSH
43406: LD_INT 4
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 1
43415: PUSH
43416: LD_INT 5
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 0
43425: PUSH
43426: LD_INT 5
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: LD_INT 1
43435: NEG
43436: PUSH
43437: LD_INT 4
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 1
43446: NEG
43447: PUSH
43448: LD_INT 3
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PUSH
43455: LD_INT 2
43457: PUSH
43458: LD_INT 5
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 2
43467: NEG
43468: PUSH
43469: LD_INT 3
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 3
43478: NEG
43479: PUSH
43480: LD_INT 0
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 3
43489: NEG
43490: PUSH
43491: LD_INT 1
43493: NEG
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 2
43501: NEG
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 2
43512: NEG
43513: PUSH
43514: LD_INT 1
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: PUSH
43521: LD_INT 3
43523: NEG
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 4
43534: NEG
43535: PUSH
43536: LD_INT 0
43538: PUSH
43539: EMPTY
43540: LIST
43541: LIST
43542: PUSH
43543: LD_INT 4
43545: NEG
43546: PUSH
43547: LD_INT 1
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 4
43557: NEG
43558: PUSH
43559: LD_INT 2
43561: NEG
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 2
43569: NEG
43570: PUSH
43571: LD_INT 2
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 4
43580: NEG
43581: PUSH
43582: LD_INT 4
43584: NEG
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 4
43592: NEG
43593: PUSH
43594: LD_INT 5
43596: NEG
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 3
43604: NEG
43605: PUSH
43606: LD_INT 4
43608: NEG
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: NEG
43617: PUSH
43618: LD_INT 3
43620: NEG
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 4
43628: NEG
43629: PUSH
43630: LD_INT 3
43632: NEG
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 5
43640: NEG
43641: PUSH
43642: LD_INT 4
43644: NEG
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 5
43652: NEG
43653: PUSH
43654: LD_INT 5
43656: NEG
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 3
43664: NEG
43665: PUSH
43666: LD_INT 5
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 5
43676: NEG
43677: PUSH
43678: LD_INT 3
43680: NEG
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: LD_INT 3
43691: NEG
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: PUSH
43697: LD_INT 0
43699: PUSH
43700: LD_INT 4
43702: NEG
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 1
43710: PUSH
43711: LD_INT 3
43713: NEG
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 1
43721: PUSH
43722: LD_INT 2
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 0
43732: PUSH
43733: LD_INT 2
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 1
43743: NEG
43744: PUSH
43745: LD_INT 3
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 1
43755: NEG
43756: PUSH
43757: LD_INT 4
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 2
43767: PUSH
43768: LD_INT 2
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 2
43778: NEG
43779: PUSH
43780: LD_INT 4
43782: NEG
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 4
43790: PUSH
43791: LD_INT 0
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 4
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 5
43811: PUSH
43812: LD_INT 0
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 5
43821: PUSH
43822: LD_INT 1
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 4
43831: PUSH
43832: LD_INT 1
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 3
43841: PUSH
43842: LD_INT 0
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: LD_INT 1
43854: NEG
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: LD_INT 3
43862: PUSH
43863: LD_INT 2
43865: NEG
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: LD_INT 5
43873: PUSH
43874: LD_INT 2
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43928: LD_ADDR_VAR 0 32
43932: PUSH
43933: LD_INT 4
43935: NEG
43936: PUSH
43937: LD_INT 0
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 4
43946: NEG
43947: PUSH
43948: LD_INT 1
43950: NEG
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 3
43958: NEG
43959: PUSH
43960: LD_INT 0
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 3
43969: NEG
43970: PUSH
43971: LD_INT 1
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: LD_INT 4
43980: NEG
43981: PUSH
43982: LD_INT 1
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 5
43991: NEG
43992: PUSH
43993: LD_INT 0
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 5
44002: NEG
44003: PUSH
44004: LD_INT 1
44006: NEG
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 5
44014: NEG
44015: PUSH
44016: LD_INT 2
44018: NEG
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 3
44026: NEG
44027: PUSH
44028: LD_INT 2
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 3
44037: NEG
44038: PUSH
44039: LD_INT 3
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 3
44049: NEG
44050: PUSH
44051: LD_INT 4
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 2
44061: NEG
44062: PUSH
44063: LD_INT 3
44065: NEG
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 2
44073: NEG
44074: PUSH
44075: LD_INT 2
44077: NEG
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 3
44085: NEG
44086: PUSH
44087: LD_INT 2
44089: NEG
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: LD_INT 3
44101: NEG
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 4
44109: NEG
44110: PUSH
44111: LD_INT 4
44113: NEG
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 2
44121: NEG
44122: PUSH
44123: LD_INT 4
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 4
44133: NEG
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: LD_INT 4
44148: NEG
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 0
44156: PUSH
44157: LD_INT 5
44159: NEG
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 1
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 1
44178: PUSH
44179: LD_INT 3
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 0
44189: PUSH
44190: LD_INT 3
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 1
44200: NEG
44201: PUSH
44202: LD_INT 4
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 1
44212: NEG
44213: PUSH
44214: LD_INT 5
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 2
44224: PUSH
44225: LD_INT 3
44227: NEG
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 2
44235: NEG
44236: PUSH
44237: LD_INT 5
44239: NEG
44240: PUSH
44241: EMPTY
44242: LIST
44243: LIST
44244: PUSH
44245: LD_INT 3
44247: PUSH
44248: LD_INT 0
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 3
44257: PUSH
44258: LD_INT 1
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 4
44268: PUSH
44269: LD_INT 0
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 4
44278: PUSH
44279: LD_INT 1
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 3
44288: PUSH
44289: LD_INT 1
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 2
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 2
44308: PUSH
44309: LD_INT 1
44311: NEG
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: PUSH
44317: LD_INT 2
44319: PUSH
44320: LD_INT 2
44322: NEG
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 4
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 4
44340: PUSH
44341: LD_INT 4
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 4
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 5
44360: PUSH
44361: LD_INT 4
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 5
44370: PUSH
44371: LD_INT 5
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 4
44380: PUSH
44381: LD_INT 5
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: LD_INT 3
44390: PUSH
44391: LD_INT 4
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 3
44400: PUSH
44401: LD_INT 3
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: LD_INT 5
44410: PUSH
44411: LD_INT 3
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 3
44420: PUSH
44421: LD_INT 5
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44475: LD_ADDR_VAR 0 33
44479: PUSH
44480: LD_INT 4
44482: NEG
44483: PUSH
44484: LD_INT 4
44486: NEG
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 4
44494: NEG
44495: PUSH
44496: LD_INT 5
44498: NEG
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 3
44506: NEG
44507: PUSH
44508: LD_INT 4
44510: NEG
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PUSH
44516: LD_INT 3
44518: NEG
44519: PUSH
44520: LD_INT 3
44522: NEG
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 4
44530: NEG
44531: PUSH
44532: LD_INT 3
44534: NEG
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: PUSH
44540: LD_INT 5
44542: NEG
44543: PUSH
44544: LD_INT 4
44546: NEG
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 5
44554: NEG
44555: PUSH
44556: LD_INT 5
44558: NEG
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 3
44566: NEG
44567: PUSH
44568: LD_INT 5
44570: NEG
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 5
44578: NEG
44579: PUSH
44580: LD_INT 3
44582: NEG
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 0
44590: PUSH
44591: LD_INT 3
44593: NEG
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 0
44601: PUSH
44602: LD_INT 4
44604: NEG
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: LD_INT 1
44612: PUSH
44613: LD_INT 3
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 1
44623: PUSH
44624: LD_INT 2
44626: NEG
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 0
44634: PUSH
44635: LD_INT 2
44637: NEG
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 1
44645: NEG
44646: PUSH
44647: LD_INT 3
44649: NEG
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 1
44657: NEG
44658: PUSH
44659: LD_INT 4
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 2
44669: PUSH
44670: LD_INT 2
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 2
44680: NEG
44681: PUSH
44682: LD_INT 4
44684: NEG
44685: PUSH
44686: EMPTY
44687: LIST
44688: LIST
44689: PUSH
44690: LD_INT 4
44692: PUSH
44693: LD_INT 0
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 4
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 5
44713: PUSH
44714: LD_INT 0
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 5
44723: PUSH
44724: LD_INT 1
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 4
44733: PUSH
44734: LD_INT 1
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: LD_INT 3
44743: PUSH
44744: LD_INT 0
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 3
44753: PUSH
44754: LD_INT 1
44756: NEG
44757: PUSH
44758: EMPTY
44759: LIST
44760: LIST
44761: PUSH
44762: LD_INT 3
44764: PUSH
44765: LD_INT 2
44767: NEG
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 5
44775: PUSH
44776: LD_INT 2
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: LD_INT 3
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: LD_INT 2
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 4
44805: PUSH
44806: LD_INT 3
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 4
44815: PUSH
44816: LD_INT 4
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 3
44825: PUSH
44826: LD_INT 4
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 2
44835: PUSH
44836: LD_INT 3
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: LD_INT 2
44845: PUSH
44846: LD_INT 2
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 4
44855: PUSH
44856: LD_INT 2
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 2
44865: PUSH
44866: LD_INT 4
44868: PUSH
44869: EMPTY
44870: LIST
44871: LIST
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: LD_INT 4
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 0
44885: PUSH
44886: LD_INT 3
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 1
44895: PUSH
44896: LD_INT 4
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 1
44905: PUSH
44906: LD_INT 5
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: PUSH
44913: LD_INT 0
44915: PUSH
44916: LD_INT 5
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 1
44925: NEG
44926: PUSH
44927: LD_INT 4
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 1
44936: NEG
44937: PUSH
44938: LD_INT 3
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 2
44947: PUSH
44948: LD_INT 5
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 2
44957: NEG
44958: PUSH
44959: LD_INT 3
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: LIST
44970: LIST
44971: LIST
44972: LIST
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: LIST
45010: LIST
45011: LIST
45012: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45013: LD_ADDR_VAR 0 34
45017: PUSH
45018: LD_INT 0
45020: PUSH
45021: LD_INT 4
45023: NEG
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 0
45031: PUSH
45032: LD_INT 5
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 1
45042: PUSH
45043: LD_INT 4
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 1
45053: PUSH
45054: LD_INT 3
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 0
45064: PUSH
45065: LD_INT 3
45067: NEG
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 1
45075: NEG
45076: PUSH
45077: LD_INT 4
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 1
45087: NEG
45088: PUSH
45089: LD_INT 5
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 2
45099: PUSH
45100: LD_INT 3
45102: NEG
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 2
45110: NEG
45111: PUSH
45112: LD_INT 5
45114: NEG
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: LD_INT 3
45122: PUSH
45123: LD_INT 0
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 3
45132: PUSH
45133: LD_INT 1
45135: NEG
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 4
45143: PUSH
45144: LD_INT 0
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 4
45153: PUSH
45154: LD_INT 1
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 3
45163: PUSH
45164: LD_INT 1
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 2
45173: PUSH
45174: LD_INT 0
45176: PUSH
45177: EMPTY
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 2
45183: PUSH
45184: LD_INT 1
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 2
45194: PUSH
45195: LD_INT 2
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 4
45205: PUSH
45206: LD_INT 2
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: LD_INT 4
45215: PUSH
45216: LD_INT 4
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: PUSH
45223: LD_INT 4
45225: PUSH
45226: LD_INT 3
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 5
45235: PUSH
45236: LD_INT 4
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 5
45245: PUSH
45246: LD_INT 5
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 4
45255: PUSH
45256: LD_INT 5
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 3
45265: PUSH
45266: LD_INT 4
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PUSH
45273: LD_INT 3
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 5
45285: PUSH
45286: LD_INT 3
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: LD_INT 5
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 0
45305: PUSH
45306: LD_INT 3
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: PUSH
45313: LD_INT 0
45315: PUSH
45316: LD_INT 2
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 1
45325: PUSH
45326: LD_INT 3
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 1
45335: PUSH
45336: LD_INT 4
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: LD_INT 4
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 1
45355: NEG
45356: PUSH
45357: LD_INT 3
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 1
45366: NEG
45367: PUSH
45368: LD_INT 2
45370: PUSH
45371: EMPTY
45372: LIST
45373: LIST
45374: PUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 4
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 2
45387: NEG
45388: PUSH
45389: LD_INT 2
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 4
45398: NEG
45399: PUSH
45400: LD_INT 0
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 4
45409: NEG
45410: PUSH
45411: LD_INT 1
45413: NEG
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: NEG
45422: PUSH
45423: LD_INT 0
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: PUSH
45430: LD_INT 3
45432: NEG
45433: PUSH
45434: LD_INT 1
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 4
45443: NEG
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 5
45454: NEG
45455: PUSH
45456: LD_INT 0
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 5
45465: NEG
45466: PUSH
45467: LD_INT 1
45469: NEG
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 5
45477: NEG
45478: PUSH
45479: LD_INT 2
45481: NEG
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 3
45489: NEG
45490: PUSH
45491: LD_INT 2
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: LIST
45515: LIST
45516: LIST
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: LIST
45523: LIST
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: ST_TO_ADDR
// end ; end ;
45545: GO 45548
45547: POP
// case btype of b_depot , b_warehouse :
45548: LD_VAR 0 1
45552: PUSH
45553: LD_INT 0
45555: DOUBLE
45556: EQUAL
45557: IFTRUE 45567
45559: LD_INT 1
45561: DOUBLE
45562: EQUAL
45563: IFTRUE 45567
45565: GO 45768
45567: POP
// case nation of nation_american :
45568: LD_VAR 0 5
45572: PUSH
45573: LD_INT 1
45575: DOUBLE
45576: EQUAL
45577: IFTRUE 45581
45579: GO 45637
45581: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45582: LD_ADDR_VAR 0 9
45586: PUSH
45587: LD_VAR 0 11
45591: PUSH
45592: LD_VAR 0 12
45596: PUSH
45597: LD_VAR 0 13
45601: PUSH
45602: LD_VAR 0 14
45606: PUSH
45607: LD_VAR 0 15
45611: PUSH
45612: LD_VAR 0 16
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: PUSH
45625: LD_VAR 0 4
45629: PUSH
45630: LD_INT 1
45632: PLUS
45633: ARRAY
45634: ST_TO_ADDR
45635: GO 45766
45637: LD_INT 2
45639: DOUBLE
45640: EQUAL
45641: IFTRUE 45645
45643: GO 45701
45645: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45646: LD_ADDR_VAR 0 9
45650: PUSH
45651: LD_VAR 0 17
45655: PUSH
45656: LD_VAR 0 18
45660: PUSH
45661: LD_VAR 0 19
45665: PUSH
45666: LD_VAR 0 20
45670: PUSH
45671: LD_VAR 0 21
45675: PUSH
45676: LD_VAR 0 22
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: PUSH
45689: LD_VAR 0 4
45693: PUSH
45694: LD_INT 1
45696: PLUS
45697: ARRAY
45698: ST_TO_ADDR
45699: GO 45766
45701: LD_INT 3
45703: DOUBLE
45704: EQUAL
45705: IFTRUE 45709
45707: GO 45765
45709: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45710: LD_ADDR_VAR 0 9
45714: PUSH
45715: LD_VAR 0 23
45719: PUSH
45720: LD_VAR 0 24
45724: PUSH
45725: LD_VAR 0 25
45729: PUSH
45730: LD_VAR 0 26
45734: PUSH
45735: LD_VAR 0 27
45739: PUSH
45740: LD_VAR 0 28
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: PUSH
45753: LD_VAR 0 4
45757: PUSH
45758: LD_INT 1
45760: PLUS
45761: ARRAY
45762: ST_TO_ADDR
45763: GO 45766
45765: POP
45766: GO 46321
45768: LD_INT 2
45770: DOUBLE
45771: EQUAL
45772: IFTRUE 45782
45774: LD_INT 3
45776: DOUBLE
45777: EQUAL
45778: IFTRUE 45782
45780: GO 45838
45782: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45783: LD_ADDR_VAR 0 9
45787: PUSH
45788: LD_VAR 0 29
45792: PUSH
45793: LD_VAR 0 30
45797: PUSH
45798: LD_VAR 0 31
45802: PUSH
45803: LD_VAR 0 32
45807: PUSH
45808: LD_VAR 0 33
45812: PUSH
45813: LD_VAR 0 34
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: PUSH
45826: LD_VAR 0 4
45830: PUSH
45831: LD_INT 1
45833: PLUS
45834: ARRAY
45835: ST_TO_ADDR
45836: GO 46321
45838: LD_INT 16
45840: DOUBLE
45841: EQUAL
45842: IFTRUE 45900
45844: LD_INT 17
45846: DOUBLE
45847: EQUAL
45848: IFTRUE 45900
45850: LD_INT 18
45852: DOUBLE
45853: EQUAL
45854: IFTRUE 45900
45856: LD_INT 19
45858: DOUBLE
45859: EQUAL
45860: IFTRUE 45900
45862: LD_INT 22
45864: DOUBLE
45865: EQUAL
45866: IFTRUE 45900
45868: LD_INT 20
45870: DOUBLE
45871: EQUAL
45872: IFTRUE 45900
45874: LD_INT 21
45876: DOUBLE
45877: EQUAL
45878: IFTRUE 45900
45880: LD_INT 23
45882: DOUBLE
45883: EQUAL
45884: IFTRUE 45900
45886: LD_INT 24
45888: DOUBLE
45889: EQUAL
45890: IFTRUE 45900
45892: LD_INT 25
45894: DOUBLE
45895: EQUAL
45896: IFTRUE 45900
45898: GO 45956
45900: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45901: LD_ADDR_VAR 0 9
45905: PUSH
45906: LD_VAR 0 35
45910: PUSH
45911: LD_VAR 0 36
45915: PUSH
45916: LD_VAR 0 37
45920: PUSH
45921: LD_VAR 0 38
45925: PUSH
45926: LD_VAR 0 39
45930: PUSH
45931: LD_VAR 0 40
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: LIST
45943: PUSH
45944: LD_VAR 0 4
45948: PUSH
45949: LD_INT 1
45951: PLUS
45952: ARRAY
45953: ST_TO_ADDR
45954: GO 46321
45956: LD_INT 6
45958: DOUBLE
45959: EQUAL
45960: IFTRUE 46012
45962: LD_INT 7
45964: DOUBLE
45965: EQUAL
45966: IFTRUE 46012
45968: LD_INT 8
45970: DOUBLE
45971: EQUAL
45972: IFTRUE 46012
45974: LD_INT 13
45976: DOUBLE
45977: EQUAL
45978: IFTRUE 46012
45980: LD_INT 12
45982: DOUBLE
45983: EQUAL
45984: IFTRUE 46012
45986: LD_INT 15
45988: DOUBLE
45989: EQUAL
45990: IFTRUE 46012
45992: LD_INT 11
45994: DOUBLE
45995: EQUAL
45996: IFTRUE 46012
45998: LD_INT 14
46000: DOUBLE
46001: EQUAL
46002: IFTRUE 46012
46004: LD_INT 10
46006: DOUBLE
46007: EQUAL
46008: IFTRUE 46012
46010: GO 46068
46012: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46013: LD_ADDR_VAR 0 9
46017: PUSH
46018: LD_VAR 0 41
46022: PUSH
46023: LD_VAR 0 42
46027: PUSH
46028: LD_VAR 0 43
46032: PUSH
46033: LD_VAR 0 44
46037: PUSH
46038: LD_VAR 0 45
46042: PUSH
46043: LD_VAR 0 46
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: PUSH
46056: LD_VAR 0 4
46060: PUSH
46061: LD_INT 1
46063: PLUS
46064: ARRAY
46065: ST_TO_ADDR
46066: GO 46321
46068: LD_INT 36
46070: DOUBLE
46071: EQUAL
46072: IFTRUE 46076
46074: GO 46132
46076: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46077: LD_ADDR_VAR 0 9
46081: PUSH
46082: LD_VAR 0 47
46086: PUSH
46087: LD_VAR 0 48
46091: PUSH
46092: LD_VAR 0 49
46096: PUSH
46097: LD_VAR 0 50
46101: PUSH
46102: LD_VAR 0 51
46106: PUSH
46107: LD_VAR 0 52
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: PUSH
46120: LD_VAR 0 4
46124: PUSH
46125: LD_INT 1
46127: PLUS
46128: ARRAY
46129: ST_TO_ADDR
46130: GO 46321
46132: LD_INT 4
46134: DOUBLE
46135: EQUAL
46136: IFTRUE 46158
46138: LD_INT 5
46140: DOUBLE
46141: EQUAL
46142: IFTRUE 46158
46144: LD_INT 34
46146: DOUBLE
46147: EQUAL
46148: IFTRUE 46158
46150: LD_INT 37
46152: DOUBLE
46153: EQUAL
46154: IFTRUE 46158
46156: GO 46214
46158: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46159: LD_ADDR_VAR 0 9
46163: PUSH
46164: LD_VAR 0 53
46168: PUSH
46169: LD_VAR 0 54
46173: PUSH
46174: LD_VAR 0 55
46178: PUSH
46179: LD_VAR 0 56
46183: PUSH
46184: LD_VAR 0 57
46188: PUSH
46189: LD_VAR 0 58
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: PUSH
46202: LD_VAR 0 4
46206: PUSH
46207: LD_INT 1
46209: PLUS
46210: ARRAY
46211: ST_TO_ADDR
46212: GO 46321
46214: LD_INT 31
46216: DOUBLE
46217: EQUAL
46218: IFTRUE 46264
46220: LD_INT 32
46222: DOUBLE
46223: EQUAL
46224: IFTRUE 46264
46226: LD_INT 33
46228: DOUBLE
46229: EQUAL
46230: IFTRUE 46264
46232: LD_INT 27
46234: DOUBLE
46235: EQUAL
46236: IFTRUE 46264
46238: LD_INT 26
46240: DOUBLE
46241: EQUAL
46242: IFTRUE 46264
46244: LD_INT 28
46246: DOUBLE
46247: EQUAL
46248: IFTRUE 46264
46250: LD_INT 29
46252: DOUBLE
46253: EQUAL
46254: IFTRUE 46264
46256: LD_INT 30
46258: DOUBLE
46259: EQUAL
46260: IFTRUE 46264
46262: GO 46320
46264: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46265: LD_ADDR_VAR 0 9
46269: PUSH
46270: LD_VAR 0 59
46274: PUSH
46275: LD_VAR 0 60
46279: PUSH
46280: LD_VAR 0 61
46284: PUSH
46285: LD_VAR 0 62
46289: PUSH
46290: LD_VAR 0 63
46294: PUSH
46295: LD_VAR 0 64
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: PUSH
46308: LD_VAR 0 4
46312: PUSH
46313: LD_INT 1
46315: PLUS
46316: ARRAY
46317: ST_TO_ADDR
46318: GO 46321
46320: POP
// temp_list2 = [ ] ;
46321: LD_ADDR_VAR 0 10
46325: PUSH
46326: EMPTY
46327: ST_TO_ADDR
// for i in temp_list do
46328: LD_ADDR_VAR 0 8
46332: PUSH
46333: LD_VAR 0 9
46337: PUSH
46338: FOR_IN
46339: IFFALSE 46391
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46341: LD_ADDR_VAR 0 10
46345: PUSH
46346: LD_VAR 0 10
46350: PUSH
46351: LD_VAR 0 8
46355: PUSH
46356: LD_INT 1
46358: ARRAY
46359: PUSH
46360: LD_VAR 0 2
46364: PLUS
46365: PUSH
46366: LD_VAR 0 8
46370: PUSH
46371: LD_INT 2
46373: ARRAY
46374: PUSH
46375: LD_VAR 0 3
46379: PLUS
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: EMPTY
46386: LIST
46387: ADD
46388: ST_TO_ADDR
46389: GO 46338
46391: POP
46392: POP
// result = temp_list2 ;
46393: LD_ADDR_VAR 0 7
46397: PUSH
46398: LD_VAR 0 10
46402: ST_TO_ADDR
// end ;
46403: LD_VAR 0 7
46407: RET
// export function EnemyInRange ( unit , dist ) ; begin
46408: LD_INT 0
46410: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46411: LD_ADDR_VAR 0 3
46415: PUSH
46416: LD_VAR 0 1
46420: PPUSH
46421: CALL_OW 255
46425: PPUSH
46426: LD_VAR 0 1
46430: PPUSH
46431: CALL_OW 250
46435: PPUSH
46436: LD_VAR 0 1
46440: PPUSH
46441: CALL_OW 251
46445: PPUSH
46446: LD_VAR 0 2
46450: PPUSH
46451: CALL 20179 0 4
46455: PUSH
46456: LD_INT 4
46458: ARRAY
46459: ST_TO_ADDR
// end ;
46460: LD_VAR 0 3
46464: RET
// export function PlayerSeeMe ( unit ) ; begin
46465: LD_INT 0
46467: PPUSH
// result := See ( your_side , unit ) ;
46468: LD_ADDR_VAR 0 2
46472: PUSH
46473: LD_OWVAR 2
46477: PPUSH
46478: LD_VAR 0 1
46482: PPUSH
46483: CALL_OW 292
46487: ST_TO_ADDR
// end ;
46488: LD_VAR 0 2
46492: RET
// export function ReverseDir ( unit ) ; begin
46493: LD_INT 0
46495: PPUSH
// if not unit then
46496: LD_VAR 0 1
46500: NOT
46501: IFFALSE 46505
// exit ;
46503: GO 46528
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46505: LD_ADDR_VAR 0 2
46509: PUSH
46510: LD_VAR 0 1
46514: PPUSH
46515: CALL_OW 254
46519: PUSH
46520: LD_INT 3
46522: PLUS
46523: PUSH
46524: LD_INT 6
46526: MOD
46527: ST_TO_ADDR
// end ;
46528: LD_VAR 0 2
46532: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46533: LD_INT 0
46535: PPUSH
46536: PPUSH
46537: PPUSH
46538: PPUSH
46539: PPUSH
// if not hexes then
46540: LD_VAR 0 2
46544: NOT
46545: IFFALSE 46549
// exit ;
46547: GO 46697
// dist := 9999 ;
46549: LD_ADDR_VAR 0 5
46553: PUSH
46554: LD_INT 9999
46556: ST_TO_ADDR
// for i = 1 to hexes do
46557: LD_ADDR_VAR 0 4
46561: PUSH
46562: DOUBLE
46563: LD_INT 1
46565: DEC
46566: ST_TO_ADDR
46567: LD_VAR 0 2
46571: PUSH
46572: FOR_TO
46573: IFFALSE 46685
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46575: LD_VAR 0 1
46579: PPUSH
46580: LD_VAR 0 2
46584: PUSH
46585: LD_VAR 0 4
46589: ARRAY
46590: PUSH
46591: LD_INT 1
46593: ARRAY
46594: PPUSH
46595: LD_VAR 0 2
46599: PUSH
46600: LD_VAR 0 4
46604: ARRAY
46605: PUSH
46606: LD_INT 2
46608: ARRAY
46609: PPUSH
46610: CALL_OW 297
46614: PUSH
46615: LD_VAR 0 5
46619: LESS
46620: IFFALSE 46683
// begin hex := hexes [ i ] ;
46622: LD_ADDR_VAR 0 7
46626: PUSH
46627: LD_VAR 0 2
46631: PUSH
46632: LD_VAR 0 4
46636: ARRAY
46637: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46638: LD_ADDR_VAR 0 5
46642: PUSH
46643: LD_VAR 0 1
46647: PPUSH
46648: LD_VAR 0 2
46652: PUSH
46653: LD_VAR 0 4
46657: ARRAY
46658: PUSH
46659: LD_INT 1
46661: ARRAY
46662: PPUSH
46663: LD_VAR 0 2
46667: PUSH
46668: LD_VAR 0 4
46672: ARRAY
46673: PUSH
46674: LD_INT 2
46676: ARRAY
46677: PPUSH
46678: CALL_OW 297
46682: ST_TO_ADDR
// end ; end ;
46683: GO 46572
46685: POP
46686: POP
// result := hex ;
46687: LD_ADDR_VAR 0 3
46691: PUSH
46692: LD_VAR 0 7
46696: ST_TO_ADDR
// end ;
46697: LD_VAR 0 3
46701: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46702: LD_INT 0
46704: PPUSH
46705: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46706: LD_VAR 0 1
46710: NOT
46711: PUSH
46712: LD_VAR 0 1
46716: PUSH
46717: LD_INT 21
46719: PUSH
46720: LD_INT 2
46722: PUSH
46723: EMPTY
46724: LIST
46725: LIST
46726: PUSH
46727: LD_INT 23
46729: PUSH
46730: LD_INT 2
46732: PUSH
46733: EMPTY
46734: LIST
46735: LIST
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PPUSH
46741: CALL_OW 69
46745: IN
46746: NOT
46747: OR
46748: IFFALSE 46752
// exit ;
46750: GO 46799
// for i = 1 to 3 do
46752: LD_ADDR_VAR 0 3
46756: PUSH
46757: DOUBLE
46758: LD_INT 1
46760: DEC
46761: ST_TO_ADDR
46762: LD_INT 3
46764: PUSH
46765: FOR_TO
46766: IFFALSE 46797
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46768: LD_VAR 0 1
46772: PPUSH
46773: CALL_OW 250
46777: PPUSH
46778: LD_VAR 0 1
46782: PPUSH
46783: CALL_OW 251
46787: PPUSH
46788: LD_INT 1
46790: PPUSH
46791: CALL_OW 453
46795: GO 46765
46797: POP
46798: POP
// end ;
46799: LD_VAR 0 2
46803: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46804: LD_INT 0
46806: PPUSH
46807: PPUSH
46808: PPUSH
46809: PPUSH
46810: PPUSH
46811: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46812: LD_VAR 0 1
46816: NOT
46817: PUSH
46818: LD_VAR 0 2
46822: NOT
46823: OR
46824: PUSH
46825: LD_VAR 0 1
46829: PPUSH
46830: CALL_OW 314
46834: OR
46835: IFFALSE 46839
// exit ;
46837: GO 47280
// x := GetX ( enemy_unit ) ;
46839: LD_ADDR_VAR 0 7
46843: PUSH
46844: LD_VAR 0 2
46848: PPUSH
46849: CALL_OW 250
46853: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46854: LD_ADDR_VAR 0 8
46858: PUSH
46859: LD_VAR 0 2
46863: PPUSH
46864: CALL_OW 251
46868: ST_TO_ADDR
// if not x or not y then
46869: LD_VAR 0 7
46873: NOT
46874: PUSH
46875: LD_VAR 0 8
46879: NOT
46880: OR
46881: IFFALSE 46885
// exit ;
46883: GO 47280
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46885: LD_ADDR_VAR 0 6
46889: PUSH
46890: LD_VAR 0 7
46894: PPUSH
46895: LD_INT 0
46897: PPUSH
46898: LD_INT 4
46900: PPUSH
46901: CALL_OW 272
46905: PUSH
46906: LD_VAR 0 8
46910: PPUSH
46911: LD_INT 0
46913: PPUSH
46914: LD_INT 4
46916: PPUSH
46917: CALL_OW 273
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_VAR 0 7
46930: PPUSH
46931: LD_INT 1
46933: PPUSH
46934: LD_INT 4
46936: PPUSH
46937: CALL_OW 272
46941: PUSH
46942: LD_VAR 0 8
46946: PPUSH
46947: LD_INT 1
46949: PPUSH
46950: LD_INT 4
46952: PPUSH
46953: CALL_OW 273
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PUSH
46962: LD_VAR 0 7
46966: PPUSH
46967: LD_INT 2
46969: PPUSH
46970: LD_INT 4
46972: PPUSH
46973: CALL_OW 272
46977: PUSH
46978: LD_VAR 0 8
46982: PPUSH
46983: LD_INT 2
46985: PPUSH
46986: LD_INT 4
46988: PPUSH
46989: CALL_OW 273
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_VAR 0 7
47002: PPUSH
47003: LD_INT 3
47005: PPUSH
47006: LD_INT 4
47008: PPUSH
47009: CALL_OW 272
47013: PUSH
47014: LD_VAR 0 8
47018: PPUSH
47019: LD_INT 3
47021: PPUSH
47022: LD_INT 4
47024: PPUSH
47025: CALL_OW 273
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_VAR 0 7
47038: PPUSH
47039: LD_INT 4
47041: PPUSH
47042: LD_INT 4
47044: PPUSH
47045: CALL_OW 272
47049: PUSH
47050: LD_VAR 0 8
47054: PPUSH
47055: LD_INT 4
47057: PPUSH
47058: LD_INT 4
47060: PPUSH
47061: CALL_OW 273
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: PUSH
47070: LD_VAR 0 7
47074: PPUSH
47075: LD_INT 5
47077: PPUSH
47078: LD_INT 4
47080: PPUSH
47081: CALL_OW 272
47085: PUSH
47086: LD_VAR 0 8
47090: PPUSH
47091: LD_INT 5
47093: PPUSH
47094: LD_INT 4
47096: PPUSH
47097: CALL_OW 273
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: ST_TO_ADDR
// for i = tmp downto 1 do
47114: LD_ADDR_VAR 0 4
47118: PUSH
47119: DOUBLE
47120: LD_VAR 0 6
47124: INC
47125: ST_TO_ADDR
47126: LD_INT 1
47128: PUSH
47129: FOR_DOWNTO
47130: IFFALSE 47231
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47132: LD_VAR 0 6
47136: PUSH
47137: LD_VAR 0 4
47141: ARRAY
47142: PUSH
47143: LD_INT 1
47145: ARRAY
47146: PPUSH
47147: LD_VAR 0 6
47151: PUSH
47152: LD_VAR 0 4
47156: ARRAY
47157: PUSH
47158: LD_INT 2
47160: ARRAY
47161: PPUSH
47162: CALL_OW 488
47166: NOT
47167: PUSH
47168: LD_VAR 0 6
47172: PUSH
47173: LD_VAR 0 4
47177: ARRAY
47178: PUSH
47179: LD_INT 1
47181: ARRAY
47182: PPUSH
47183: LD_VAR 0 6
47187: PUSH
47188: LD_VAR 0 4
47192: ARRAY
47193: PUSH
47194: LD_INT 2
47196: ARRAY
47197: PPUSH
47198: CALL_OW 428
47202: PUSH
47203: LD_INT 0
47205: NONEQUAL
47206: OR
47207: IFFALSE 47229
// tmp := Delete ( tmp , i ) ;
47209: LD_ADDR_VAR 0 6
47213: PUSH
47214: LD_VAR 0 6
47218: PPUSH
47219: LD_VAR 0 4
47223: PPUSH
47224: CALL_OW 3
47228: ST_TO_ADDR
47229: GO 47129
47231: POP
47232: POP
// j := GetClosestHex ( unit , tmp ) ;
47233: LD_ADDR_VAR 0 5
47237: PUSH
47238: LD_VAR 0 1
47242: PPUSH
47243: LD_VAR 0 6
47247: PPUSH
47248: CALL 46533 0 2
47252: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47253: LD_VAR 0 1
47257: PPUSH
47258: LD_VAR 0 5
47262: PUSH
47263: LD_INT 1
47265: ARRAY
47266: PPUSH
47267: LD_VAR 0 5
47271: PUSH
47272: LD_INT 2
47274: ARRAY
47275: PPUSH
47276: CALL_OW 111
// end ;
47280: LD_VAR 0 3
47284: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47285: LD_INT 0
47287: PPUSH
47288: PPUSH
47289: PPUSH
// uc_side = 0 ;
47290: LD_ADDR_OWVAR 20
47294: PUSH
47295: LD_INT 0
47297: ST_TO_ADDR
// uc_nation = 0 ;
47298: LD_ADDR_OWVAR 21
47302: PUSH
47303: LD_INT 0
47305: ST_TO_ADDR
// InitHc_All ( ) ;
47306: CALL_OW 584
// InitVc ;
47310: CALL_OW 20
// if mastodonts then
47314: LD_VAR 0 6
47318: IFFALSE 47385
// for i = 1 to mastodonts do
47320: LD_ADDR_VAR 0 11
47324: PUSH
47325: DOUBLE
47326: LD_INT 1
47328: DEC
47329: ST_TO_ADDR
47330: LD_VAR 0 6
47334: PUSH
47335: FOR_TO
47336: IFFALSE 47383
// begin vc_chassis := 31 ;
47338: LD_ADDR_OWVAR 37
47342: PUSH
47343: LD_INT 31
47345: ST_TO_ADDR
// vc_control := control_rider ;
47346: LD_ADDR_OWVAR 38
47350: PUSH
47351: LD_INT 4
47353: ST_TO_ADDR
// animal := CreateVehicle ;
47354: LD_ADDR_VAR 0 12
47358: PUSH
47359: CALL_OW 45
47363: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47364: LD_VAR 0 12
47368: PPUSH
47369: LD_VAR 0 8
47373: PPUSH
47374: LD_INT 0
47376: PPUSH
47377: CALL 49573 0 3
// end ;
47381: GO 47335
47383: POP
47384: POP
// if horses then
47385: LD_VAR 0 5
47389: IFFALSE 47456
// for i = 1 to horses do
47391: LD_ADDR_VAR 0 11
47395: PUSH
47396: DOUBLE
47397: LD_INT 1
47399: DEC
47400: ST_TO_ADDR
47401: LD_VAR 0 5
47405: PUSH
47406: FOR_TO
47407: IFFALSE 47454
// begin hc_class := 21 ;
47409: LD_ADDR_OWVAR 28
47413: PUSH
47414: LD_INT 21
47416: ST_TO_ADDR
// hc_gallery :=  ;
47417: LD_ADDR_OWVAR 33
47421: PUSH
47422: LD_STRING 
47424: ST_TO_ADDR
// animal := CreateHuman ;
47425: LD_ADDR_VAR 0 12
47429: PUSH
47430: CALL_OW 44
47434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47435: LD_VAR 0 12
47439: PPUSH
47440: LD_VAR 0 8
47444: PPUSH
47445: LD_INT 0
47447: PPUSH
47448: CALL 49573 0 3
// end ;
47452: GO 47406
47454: POP
47455: POP
// if birds then
47456: LD_VAR 0 1
47460: IFFALSE 47527
// for i = 1 to birds do
47462: LD_ADDR_VAR 0 11
47466: PUSH
47467: DOUBLE
47468: LD_INT 1
47470: DEC
47471: ST_TO_ADDR
47472: LD_VAR 0 1
47476: PUSH
47477: FOR_TO
47478: IFFALSE 47525
// begin hc_class = 18 ;
47480: LD_ADDR_OWVAR 28
47484: PUSH
47485: LD_INT 18
47487: ST_TO_ADDR
// hc_gallery =  ;
47488: LD_ADDR_OWVAR 33
47492: PUSH
47493: LD_STRING 
47495: ST_TO_ADDR
// animal := CreateHuman ;
47496: LD_ADDR_VAR 0 12
47500: PUSH
47501: CALL_OW 44
47505: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47506: LD_VAR 0 12
47510: PPUSH
47511: LD_VAR 0 8
47515: PPUSH
47516: LD_INT 0
47518: PPUSH
47519: CALL 49573 0 3
// end ;
47523: GO 47477
47525: POP
47526: POP
// if tigers then
47527: LD_VAR 0 2
47531: IFFALSE 47615
// for i = 1 to tigers do
47533: LD_ADDR_VAR 0 11
47537: PUSH
47538: DOUBLE
47539: LD_INT 1
47541: DEC
47542: ST_TO_ADDR
47543: LD_VAR 0 2
47547: PUSH
47548: FOR_TO
47549: IFFALSE 47613
// begin hc_class = class_tiger ;
47551: LD_ADDR_OWVAR 28
47555: PUSH
47556: LD_INT 14
47558: ST_TO_ADDR
// hc_gallery =  ;
47559: LD_ADDR_OWVAR 33
47563: PUSH
47564: LD_STRING 
47566: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47567: LD_ADDR_OWVAR 35
47571: PUSH
47572: LD_INT 7
47574: NEG
47575: PPUSH
47576: LD_INT 7
47578: PPUSH
47579: CALL_OW 12
47583: ST_TO_ADDR
// animal := CreateHuman ;
47584: LD_ADDR_VAR 0 12
47588: PUSH
47589: CALL_OW 44
47593: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47594: LD_VAR 0 12
47598: PPUSH
47599: LD_VAR 0 8
47603: PPUSH
47604: LD_INT 0
47606: PPUSH
47607: CALL 49573 0 3
// end ;
47611: GO 47548
47613: POP
47614: POP
// if apemans then
47615: LD_VAR 0 3
47619: IFFALSE 47742
// for i = 1 to apemans do
47621: LD_ADDR_VAR 0 11
47625: PUSH
47626: DOUBLE
47627: LD_INT 1
47629: DEC
47630: ST_TO_ADDR
47631: LD_VAR 0 3
47635: PUSH
47636: FOR_TO
47637: IFFALSE 47740
// begin hc_class = class_apeman ;
47639: LD_ADDR_OWVAR 28
47643: PUSH
47644: LD_INT 12
47646: ST_TO_ADDR
// hc_gallery =  ;
47647: LD_ADDR_OWVAR 33
47651: PUSH
47652: LD_STRING 
47654: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47655: LD_ADDR_OWVAR 35
47659: PUSH
47660: LD_INT 5
47662: NEG
47663: PPUSH
47664: LD_INT 5
47666: PPUSH
47667: CALL_OW 12
47671: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47672: LD_ADDR_OWVAR 31
47676: PUSH
47677: LD_INT 1
47679: PPUSH
47680: LD_INT 3
47682: PPUSH
47683: CALL_OW 12
47687: PUSH
47688: LD_INT 1
47690: PPUSH
47691: LD_INT 3
47693: PPUSH
47694: CALL_OW 12
47698: PUSH
47699: LD_INT 0
47701: PUSH
47702: LD_INT 0
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: ST_TO_ADDR
// animal := CreateHuman ;
47711: LD_ADDR_VAR 0 12
47715: PUSH
47716: CALL_OW 44
47720: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47721: LD_VAR 0 12
47725: PPUSH
47726: LD_VAR 0 8
47730: PPUSH
47731: LD_INT 0
47733: PPUSH
47734: CALL 49573 0 3
// end ;
47738: GO 47636
47740: POP
47741: POP
// if enchidnas then
47742: LD_VAR 0 4
47746: IFFALSE 47813
// for i = 1 to enchidnas do
47748: LD_ADDR_VAR 0 11
47752: PUSH
47753: DOUBLE
47754: LD_INT 1
47756: DEC
47757: ST_TO_ADDR
47758: LD_VAR 0 4
47762: PUSH
47763: FOR_TO
47764: IFFALSE 47811
// begin hc_class = 13 ;
47766: LD_ADDR_OWVAR 28
47770: PUSH
47771: LD_INT 13
47773: ST_TO_ADDR
// hc_gallery =  ;
47774: LD_ADDR_OWVAR 33
47778: PUSH
47779: LD_STRING 
47781: ST_TO_ADDR
// animal := CreateHuman ;
47782: LD_ADDR_VAR 0 12
47786: PUSH
47787: CALL_OW 44
47791: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47792: LD_VAR 0 12
47796: PPUSH
47797: LD_VAR 0 8
47801: PPUSH
47802: LD_INT 0
47804: PPUSH
47805: CALL 49573 0 3
// end ;
47809: GO 47763
47811: POP
47812: POP
// if fishes then
47813: LD_VAR 0 7
47817: IFFALSE 47884
// for i = 1 to fishes do
47819: LD_ADDR_VAR 0 11
47823: PUSH
47824: DOUBLE
47825: LD_INT 1
47827: DEC
47828: ST_TO_ADDR
47829: LD_VAR 0 7
47833: PUSH
47834: FOR_TO
47835: IFFALSE 47882
// begin hc_class = 20 ;
47837: LD_ADDR_OWVAR 28
47841: PUSH
47842: LD_INT 20
47844: ST_TO_ADDR
// hc_gallery =  ;
47845: LD_ADDR_OWVAR 33
47849: PUSH
47850: LD_STRING 
47852: ST_TO_ADDR
// animal := CreateHuman ;
47853: LD_ADDR_VAR 0 12
47857: PUSH
47858: CALL_OW 44
47862: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47863: LD_VAR 0 12
47867: PPUSH
47868: LD_VAR 0 9
47872: PPUSH
47873: LD_INT 0
47875: PPUSH
47876: CALL 49573 0 3
// end ;
47880: GO 47834
47882: POP
47883: POP
// end ;
47884: LD_VAR 0 10
47888: RET
// export function WantHeal ( sci , unit ) ; begin
47889: LD_INT 0
47891: PPUSH
// if GetTaskList ( sci ) > 0 then
47892: LD_VAR 0 1
47896: PPUSH
47897: CALL_OW 437
47901: PUSH
47902: LD_INT 0
47904: GREATER
47905: IFFALSE 47975
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47907: LD_VAR 0 1
47911: PPUSH
47912: CALL_OW 437
47916: PUSH
47917: LD_INT 1
47919: ARRAY
47920: PUSH
47921: LD_INT 1
47923: ARRAY
47924: PUSH
47925: LD_STRING l
47927: EQUAL
47928: PUSH
47929: LD_VAR 0 1
47933: PPUSH
47934: CALL_OW 437
47938: PUSH
47939: LD_INT 1
47941: ARRAY
47942: PUSH
47943: LD_INT 4
47945: ARRAY
47946: PUSH
47947: LD_VAR 0 2
47951: EQUAL
47952: AND
47953: IFFALSE 47965
// result := true else
47955: LD_ADDR_VAR 0 3
47959: PUSH
47960: LD_INT 1
47962: ST_TO_ADDR
47963: GO 47973
// result := false ;
47965: LD_ADDR_VAR 0 3
47969: PUSH
47970: LD_INT 0
47972: ST_TO_ADDR
// end else
47973: GO 47983
// result := false ;
47975: LD_ADDR_VAR 0 3
47979: PUSH
47980: LD_INT 0
47982: ST_TO_ADDR
// end ;
47983: LD_VAR 0 3
47987: RET
// export function HealTarget ( sci ) ; begin
47988: LD_INT 0
47990: PPUSH
// if not sci then
47991: LD_VAR 0 1
47995: NOT
47996: IFFALSE 48000
// exit ;
47998: GO 48065
// result := 0 ;
48000: LD_ADDR_VAR 0 2
48004: PUSH
48005: LD_INT 0
48007: ST_TO_ADDR
// if GetTaskList ( sci ) then
48008: LD_VAR 0 1
48012: PPUSH
48013: CALL_OW 437
48017: IFFALSE 48065
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48019: LD_VAR 0 1
48023: PPUSH
48024: CALL_OW 437
48028: PUSH
48029: LD_INT 1
48031: ARRAY
48032: PUSH
48033: LD_INT 1
48035: ARRAY
48036: PUSH
48037: LD_STRING l
48039: EQUAL
48040: IFFALSE 48065
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48042: LD_ADDR_VAR 0 2
48046: PUSH
48047: LD_VAR 0 1
48051: PPUSH
48052: CALL_OW 437
48056: PUSH
48057: LD_INT 1
48059: ARRAY
48060: PUSH
48061: LD_INT 4
48063: ARRAY
48064: ST_TO_ADDR
// end ;
48065: LD_VAR 0 2
48069: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48070: LD_INT 0
48072: PPUSH
48073: PPUSH
48074: PPUSH
48075: PPUSH
// if not base_units then
48076: LD_VAR 0 1
48080: NOT
48081: IFFALSE 48085
// exit ;
48083: GO 48172
// result := false ;
48085: LD_ADDR_VAR 0 2
48089: PUSH
48090: LD_INT 0
48092: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48093: LD_ADDR_VAR 0 5
48097: PUSH
48098: LD_VAR 0 1
48102: PPUSH
48103: LD_INT 21
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PPUSH
48113: CALL_OW 72
48117: ST_TO_ADDR
// if not tmp then
48118: LD_VAR 0 5
48122: NOT
48123: IFFALSE 48127
// exit ;
48125: GO 48172
// for i in tmp do
48127: LD_ADDR_VAR 0 3
48131: PUSH
48132: LD_VAR 0 5
48136: PUSH
48137: FOR_IN
48138: IFFALSE 48170
// begin result := EnemyInRange ( i , 22 ) ;
48140: LD_ADDR_VAR 0 2
48144: PUSH
48145: LD_VAR 0 3
48149: PPUSH
48150: LD_INT 22
48152: PPUSH
48153: CALL 46408 0 2
48157: ST_TO_ADDR
// if result then
48158: LD_VAR 0 2
48162: IFFALSE 48168
// exit ;
48164: POP
48165: POP
48166: GO 48172
// end ;
48168: GO 48137
48170: POP
48171: POP
// end ;
48172: LD_VAR 0 2
48176: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48177: LD_INT 0
48179: PPUSH
48180: PPUSH
// if not units then
48181: LD_VAR 0 1
48185: NOT
48186: IFFALSE 48190
// exit ;
48188: GO 48260
// result := [ ] ;
48190: LD_ADDR_VAR 0 3
48194: PUSH
48195: EMPTY
48196: ST_TO_ADDR
// for i in units do
48197: LD_ADDR_VAR 0 4
48201: PUSH
48202: LD_VAR 0 1
48206: PUSH
48207: FOR_IN
48208: IFFALSE 48258
// if GetTag ( i ) = tag then
48210: LD_VAR 0 4
48214: PPUSH
48215: CALL_OW 110
48219: PUSH
48220: LD_VAR 0 2
48224: EQUAL
48225: IFFALSE 48256
// result := Insert ( result , result + 1 , i ) ;
48227: LD_ADDR_VAR 0 3
48231: PUSH
48232: LD_VAR 0 3
48236: PPUSH
48237: LD_VAR 0 3
48241: PUSH
48242: LD_INT 1
48244: PLUS
48245: PPUSH
48246: LD_VAR 0 4
48250: PPUSH
48251: CALL_OW 2
48255: ST_TO_ADDR
48256: GO 48207
48258: POP
48259: POP
// end ;
48260: LD_VAR 0 3
48264: RET
// export function IsDriver ( un ) ; begin
48265: LD_INT 0
48267: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48268: LD_ADDR_VAR 0 2
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: LD_INT 55
48280: PUSH
48281: EMPTY
48282: LIST
48283: PPUSH
48284: CALL_OW 69
48288: IN
48289: ST_TO_ADDR
// end ;
48290: LD_VAR 0 2
48294: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48295: LD_INT 0
48297: PPUSH
48298: PPUSH
// list := [ ] ;
48299: LD_ADDR_VAR 0 5
48303: PUSH
48304: EMPTY
48305: ST_TO_ADDR
// case d of 0 :
48306: LD_VAR 0 3
48310: PUSH
48311: LD_INT 0
48313: DOUBLE
48314: EQUAL
48315: IFTRUE 48319
48317: GO 48452
48319: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48320: LD_ADDR_VAR 0 5
48324: PUSH
48325: LD_VAR 0 1
48329: PUSH
48330: LD_INT 4
48332: MINUS
48333: PUSH
48334: LD_VAR 0 2
48338: PUSH
48339: LD_INT 4
48341: MINUS
48342: PUSH
48343: LD_INT 2
48345: PUSH
48346: EMPTY
48347: LIST
48348: LIST
48349: LIST
48350: PUSH
48351: LD_VAR 0 1
48355: PUSH
48356: LD_INT 3
48358: MINUS
48359: PUSH
48360: LD_VAR 0 2
48364: PUSH
48365: LD_INT 1
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: LIST
48372: PUSH
48373: LD_VAR 0 1
48377: PUSH
48378: LD_INT 4
48380: PLUS
48381: PUSH
48382: LD_VAR 0 2
48386: PUSH
48387: LD_INT 4
48389: PUSH
48390: EMPTY
48391: LIST
48392: LIST
48393: LIST
48394: PUSH
48395: LD_VAR 0 1
48399: PUSH
48400: LD_INT 3
48402: PLUS
48403: PUSH
48404: LD_VAR 0 2
48408: PUSH
48409: LD_INT 3
48411: PLUS
48412: PUSH
48413: LD_INT 5
48415: PUSH
48416: EMPTY
48417: LIST
48418: LIST
48419: LIST
48420: PUSH
48421: LD_VAR 0 1
48425: PUSH
48426: LD_VAR 0 2
48430: PUSH
48431: LD_INT 4
48433: PLUS
48434: PUSH
48435: LD_INT 0
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: LIST
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: ST_TO_ADDR
// end ; 1 :
48450: GO 49150
48452: LD_INT 1
48454: DOUBLE
48455: EQUAL
48456: IFTRUE 48460
48458: GO 48593
48460: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48461: LD_ADDR_VAR 0 5
48465: PUSH
48466: LD_VAR 0 1
48470: PUSH
48471: LD_VAR 0 2
48475: PUSH
48476: LD_INT 4
48478: MINUS
48479: PUSH
48480: LD_INT 3
48482: PUSH
48483: EMPTY
48484: LIST
48485: LIST
48486: LIST
48487: PUSH
48488: LD_VAR 0 1
48492: PUSH
48493: LD_INT 3
48495: MINUS
48496: PUSH
48497: LD_VAR 0 2
48501: PUSH
48502: LD_INT 3
48504: MINUS
48505: PUSH
48506: LD_INT 2
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: LIST
48513: PUSH
48514: LD_VAR 0 1
48518: PUSH
48519: LD_INT 4
48521: MINUS
48522: PUSH
48523: LD_VAR 0 2
48527: PUSH
48528: LD_INT 1
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: LIST
48535: PUSH
48536: LD_VAR 0 1
48540: PUSH
48541: LD_VAR 0 2
48545: PUSH
48546: LD_INT 3
48548: PLUS
48549: PUSH
48550: LD_INT 0
48552: PUSH
48553: EMPTY
48554: LIST
48555: LIST
48556: LIST
48557: PUSH
48558: LD_VAR 0 1
48562: PUSH
48563: LD_INT 4
48565: PLUS
48566: PUSH
48567: LD_VAR 0 2
48571: PUSH
48572: LD_INT 4
48574: PLUS
48575: PUSH
48576: LD_INT 5
48578: PUSH
48579: EMPTY
48580: LIST
48581: LIST
48582: LIST
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: LIST
48588: LIST
48589: LIST
48590: ST_TO_ADDR
// end ; 2 :
48591: GO 49150
48593: LD_INT 2
48595: DOUBLE
48596: EQUAL
48597: IFTRUE 48601
48599: GO 48730
48601: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48602: LD_ADDR_VAR 0 5
48606: PUSH
48607: LD_VAR 0 1
48611: PUSH
48612: LD_VAR 0 2
48616: PUSH
48617: LD_INT 3
48619: MINUS
48620: PUSH
48621: LD_INT 3
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: LIST
48628: PUSH
48629: LD_VAR 0 1
48633: PUSH
48634: LD_INT 4
48636: PLUS
48637: PUSH
48638: LD_VAR 0 2
48642: PUSH
48643: LD_INT 4
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: LIST
48650: PUSH
48651: LD_VAR 0 1
48655: PUSH
48656: LD_VAR 0 2
48660: PUSH
48661: LD_INT 4
48663: PLUS
48664: PUSH
48665: LD_INT 0
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: LIST
48672: PUSH
48673: LD_VAR 0 1
48677: PUSH
48678: LD_INT 3
48680: MINUS
48681: PUSH
48682: LD_VAR 0 2
48686: PUSH
48687: LD_INT 1
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: LIST
48694: PUSH
48695: LD_VAR 0 1
48699: PUSH
48700: LD_INT 4
48702: MINUS
48703: PUSH
48704: LD_VAR 0 2
48708: PUSH
48709: LD_INT 4
48711: MINUS
48712: PUSH
48713: LD_INT 2
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: LIST
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: ST_TO_ADDR
// end ; 3 :
48728: GO 49150
48730: LD_INT 3
48732: DOUBLE
48733: EQUAL
48734: IFTRUE 48738
48736: GO 48871
48738: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48739: LD_ADDR_VAR 0 5
48743: PUSH
48744: LD_VAR 0 1
48748: PUSH
48749: LD_INT 3
48751: PLUS
48752: PUSH
48753: LD_VAR 0 2
48757: PUSH
48758: LD_INT 4
48760: PUSH
48761: EMPTY
48762: LIST
48763: LIST
48764: LIST
48765: PUSH
48766: LD_VAR 0 1
48770: PUSH
48771: LD_INT 4
48773: PLUS
48774: PUSH
48775: LD_VAR 0 2
48779: PUSH
48780: LD_INT 4
48782: PLUS
48783: PUSH
48784: LD_INT 5
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: LIST
48791: PUSH
48792: LD_VAR 0 1
48796: PUSH
48797: LD_INT 4
48799: MINUS
48800: PUSH
48801: LD_VAR 0 2
48805: PUSH
48806: LD_INT 1
48808: PUSH
48809: EMPTY
48810: LIST
48811: LIST
48812: LIST
48813: PUSH
48814: LD_VAR 0 1
48818: PUSH
48819: LD_VAR 0 2
48823: PUSH
48824: LD_INT 4
48826: MINUS
48827: PUSH
48828: LD_INT 3
48830: PUSH
48831: EMPTY
48832: LIST
48833: LIST
48834: LIST
48835: PUSH
48836: LD_VAR 0 1
48840: PUSH
48841: LD_INT 3
48843: MINUS
48844: PUSH
48845: LD_VAR 0 2
48849: PUSH
48850: LD_INT 3
48852: MINUS
48853: PUSH
48854: LD_INT 2
48856: PUSH
48857: EMPTY
48858: LIST
48859: LIST
48860: LIST
48861: PUSH
48862: EMPTY
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: ST_TO_ADDR
// end ; 4 :
48869: GO 49150
48871: LD_INT 4
48873: DOUBLE
48874: EQUAL
48875: IFTRUE 48879
48877: GO 49012
48879: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48880: LD_ADDR_VAR 0 5
48884: PUSH
48885: LD_VAR 0 1
48889: PUSH
48890: LD_VAR 0 2
48894: PUSH
48895: LD_INT 4
48897: PLUS
48898: PUSH
48899: LD_INT 0
48901: PUSH
48902: EMPTY
48903: LIST
48904: LIST
48905: LIST
48906: PUSH
48907: LD_VAR 0 1
48911: PUSH
48912: LD_INT 3
48914: PLUS
48915: PUSH
48916: LD_VAR 0 2
48920: PUSH
48921: LD_INT 3
48923: PLUS
48924: PUSH
48925: LD_INT 5
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: PUSH
48933: LD_VAR 0 1
48937: PUSH
48938: LD_INT 4
48940: PLUS
48941: PUSH
48942: LD_VAR 0 2
48946: PUSH
48947: LD_INT 4
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: LIST
48954: PUSH
48955: LD_VAR 0 1
48959: PUSH
48960: LD_VAR 0 2
48964: PUSH
48965: LD_INT 3
48967: MINUS
48968: PUSH
48969: LD_INT 3
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: LIST
48976: PUSH
48977: LD_VAR 0 1
48981: PUSH
48982: LD_INT 4
48984: MINUS
48985: PUSH
48986: LD_VAR 0 2
48990: PUSH
48991: LD_INT 4
48993: MINUS
48994: PUSH
48995: LD_INT 2
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: LIST
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: LIST
49007: LIST
49008: LIST
49009: ST_TO_ADDR
// end ; 5 :
49010: GO 49150
49012: LD_INT 5
49014: DOUBLE
49015: EQUAL
49016: IFTRUE 49020
49018: GO 49149
49020: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49021: LD_ADDR_VAR 0 5
49025: PUSH
49026: LD_VAR 0 1
49030: PUSH
49031: LD_INT 4
49033: MINUS
49034: PUSH
49035: LD_VAR 0 2
49039: PUSH
49040: LD_INT 1
49042: PUSH
49043: EMPTY
49044: LIST
49045: LIST
49046: LIST
49047: PUSH
49048: LD_VAR 0 1
49052: PUSH
49053: LD_VAR 0 2
49057: PUSH
49058: LD_INT 4
49060: MINUS
49061: PUSH
49062: LD_INT 3
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: LIST
49069: PUSH
49070: LD_VAR 0 1
49074: PUSH
49075: LD_INT 4
49077: PLUS
49078: PUSH
49079: LD_VAR 0 2
49083: PUSH
49084: LD_INT 4
49086: PLUS
49087: PUSH
49088: LD_INT 5
49090: PUSH
49091: EMPTY
49092: LIST
49093: LIST
49094: LIST
49095: PUSH
49096: LD_VAR 0 1
49100: PUSH
49101: LD_INT 3
49103: PLUS
49104: PUSH
49105: LD_VAR 0 2
49109: PUSH
49110: LD_INT 4
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: LIST
49117: PUSH
49118: LD_VAR 0 1
49122: PUSH
49123: LD_VAR 0 2
49127: PUSH
49128: LD_INT 3
49130: PLUS
49131: PUSH
49132: LD_INT 0
49134: PUSH
49135: EMPTY
49136: LIST
49137: LIST
49138: LIST
49139: PUSH
49140: EMPTY
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: ST_TO_ADDR
// end ; end ;
49147: GO 49150
49149: POP
// result := list ;
49150: LD_ADDR_VAR 0 4
49154: PUSH
49155: LD_VAR 0 5
49159: ST_TO_ADDR
// end ;
49160: LD_VAR 0 4
49164: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49165: LD_INT 0
49167: PPUSH
49168: PPUSH
49169: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49170: LD_VAR 0 1
49174: NOT
49175: PUSH
49176: LD_VAR 0 2
49180: PUSH
49181: LD_INT 1
49183: PUSH
49184: LD_INT 2
49186: PUSH
49187: LD_INT 3
49189: PUSH
49190: LD_INT 4
49192: PUSH
49193: EMPTY
49194: LIST
49195: LIST
49196: LIST
49197: LIST
49198: IN
49199: NOT
49200: OR
49201: IFFALSE 49205
// exit ;
49203: GO 49297
// tmp := [ ] ;
49205: LD_ADDR_VAR 0 5
49209: PUSH
49210: EMPTY
49211: ST_TO_ADDR
// for i in units do
49212: LD_ADDR_VAR 0 4
49216: PUSH
49217: LD_VAR 0 1
49221: PUSH
49222: FOR_IN
49223: IFFALSE 49266
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49225: LD_ADDR_VAR 0 5
49229: PUSH
49230: LD_VAR 0 5
49234: PPUSH
49235: LD_VAR 0 5
49239: PUSH
49240: LD_INT 1
49242: PLUS
49243: PPUSH
49244: LD_VAR 0 4
49248: PPUSH
49249: LD_VAR 0 2
49253: PPUSH
49254: CALL_OW 259
49258: PPUSH
49259: CALL_OW 2
49263: ST_TO_ADDR
49264: GO 49222
49266: POP
49267: POP
// if not tmp then
49268: LD_VAR 0 5
49272: NOT
49273: IFFALSE 49277
// exit ;
49275: GO 49297
// result := SortListByListDesc ( units , tmp ) ;
49277: LD_ADDR_VAR 0 3
49281: PUSH
49282: LD_VAR 0 1
49286: PPUSH
49287: LD_VAR 0 5
49291: PPUSH
49292: CALL_OW 77
49296: ST_TO_ADDR
// end ;
49297: LD_VAR 0 3
49301: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49302: LD_INT 0
49304: PPUSH
49305: PPUSH
49306: PPUSH
// result := false ;
49307: LD_ADDR_VAR 0 3
49311: PUSH
49312: LD_INT 0
49314: ST_TO_ADDR
// x := GetX ( building ) ;
49315: LD_ADDR_VAR 0 4
49319: PUSH
49320: LD_VAR 0 2
49324: PPUSH
49325: CALL_OW 250
49329: ST_TO_ADDR
// y := GetY ( building ) ;
49330: LD_ADDR_VAR 0 5
49334: PUSH
49335: LD_VAR 0 2
49339: PPUSH
49340: CALL_OW 251
49344: ST_TO_ADDR
// if not building or not x or not y then
49345: LD_VAR 0 2
49349: NOT
49350: PUSH
49351: LD_VAR 0 4
49355: NOT
49356: OR
49357: PUSH
49358: LD_VAR 0 5
49362: NOT
49363: OR
49364: IFFALSE 49368
// exit ;
49366: GO 49460
// if GetTaskList ( unit ) then
49368: LD_VAR 0 1
49372: PPUSH
49373: CALL_OW 437
49377: IFFALSE 49460
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49379: LD_STRING e
49381: PUSH
49382: LD_VAR 0 1
49386: PPUSH
49387: CALL_OW 437
49391: PUSH
49392: LD_INT 1
49394: ARRAY
49395: PUSH
49396: LD_INT 1
49398: ARRAY
49399: EQUAL
49400: PUSH
49401: LD_VAR 0 4
49405: PUSH
49406: LD_VAR 0 1
49410: PPUSH
49411: CALL_OW 437
49415: PUSH
49416: LD_INT 1
49418: ARRAY
49419: PUSH
49420: LD_INT 2
49422: ARRAY
49423: EQUAL
49424: AND
49425: PUSH
49426: LD_VAR 0 5
49430: PUSH
49431: LD_VAR 0 1
49435: PPUSH
49436: CALL_OW 437
49440: PUSH
49441: LD_INT 1
49443: ARRAY
49444: PUSH
49445: LD_INT 3
49447: ARRAY
49448: EQUAL
49449: AND
49450: IFFALSE 49460
// result := true end ;
49452: LD_ADDR_VAR 0 3
49456: PUSH
49457: LD_INT 1
49459: ST_TO_ADDR
// end ;
49460: LD_VAR 0 3
49464: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49465: LD_INT 0
49467: PPUSH
// result := false ;
49468: LD_ADDR_VAR 0 4
49472: PUSH
49473: LD_INT 0
49475: ST_TO_ADDR
// if GetTaskList ( unit ) then
49476: LD_VAR 0 1
49480: PPUSH
49481: CALL_OW 437
49485: IFFALSE 49568
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49487: LD_STRING M
49489: PUSH
49490: LD_VAR 0 1
49494: PPUSH
49495: CALL_OW 437
49499: PUSH
49500: LD_INT 1
49502: ARRAY
49503: PUSH
49504: LD_INT 1
49506: ARRAY
49507: EQUAL
49508: PUSH
49509: LD_VAR 0 2
49513: PUSH
49514: LD_VAR 0 1
49518: PPUSH
49519: CALL_OW 437
49523: PUSH
49524: LD_INT 1
49526: ARRAY
49527: PUSH
49528: LD_INT 2
49530: ARRAY
49531: EQUAL
49532: AND
49533: PUSH
49534: LD_VAR 0 3
49538: PUSH
49539: LD_VAR 0 1
49543: PPUSH
49544: CALL_OW 437
49548: PUSH
49549: LD_INT 1
49551: ARRAY
49552: PUSH
49553: LD_INT 3
49555: ARRAY
49556: EQUAL
49557: AND
49558: IFFALSE 49568
// result := true ;
49560: LD_ADDR_VAR 0 4
49564: PUSH
49565: LD_INT 1
49567: ST_TO_ADDR
// end ; end ;
49568: LD_VAR 0 4
49572: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49573: LD_INT 0
49575: PPUSH
49576: PPUSH
49577: PPUSH
49578: PPUSH
// if not unit or not area then
49579: LD_VAR 0 1
49583: NOT
49584: PUSH
49585: LD_VAR 0 2
49589: NOT
49590: OR
49591: IFFALSE 49595
// exit ;
49593: GO 49759
// tmp := AreaToList ( area , i ) ;
49595: LD_ADDR_VAR 0 6
49599: PUSH
49600: LD_VAR 0 2
49604: PPUSH
49605: LD_VAR 0 5
49609: PPUSH
49610: CALL_OW 517
49614: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49615: LD_ADDR_VAR 0 5
49619: PUSH
49620: DOUBLE
49621: LD_INT 1
49623: DEC
49624: ST_TO_ADDR
49625: LD_VAR 0 6
49629: PUSH
49630: LD_INT 1
49632: ARRAY
49633: PUSH
49634: FOR_TO
49635: IFFALSE 49757
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49637: LD_ADDR_VAR 0 7
49641: PUSH
49642: LD_VAR 0 6
49646: PUSH
49647: LD_INT 1
49649: ARRAY
49650: PUSH
49651: LD_VAR 0 5
49655: ARRAY
49656: PUSH
49657: LD_VAR 0 6
49661: PUSH
49662: LD_INT 2
49664: ARRAY
49665: PUSH
49666: LD_VAR 0 5
49670: ARRAY
49671: PUSH
49672: EMPTY
49673: LIST
49674: LIST
49675: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49676: LD_VAR 0 7
49680: PUSH
49681: LD_INT 1
49683: ARRAY
49684: PPUSH
49685: LD_VAR 0 7
49689: PUSH
49690: LD_INT 2
49692: ARRAY
49693: PPUSH
49694: CALL_OW 428
49698: PUSH
49699: LD_INT 0
49701: EQUAL
49702: IFFALSE 49755
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49704: LD_VAR 0 1
49708: PPUSH
49709: LD_VAR 0 7
49713: PUSH
49714: LD_INT 1
49716: ARRAY
49717: PPUSH
49718: LD_VAR 0 7
49722: PUSH
49723: LD_INT 2
49725: ARRAY
49726: PPUSH
49727: LD_VAR 0 3
49731: PPUSH
49732: CALL_OW 48
// result := IsPlaced ( unit ) ;
49736: LD_ADDR_VAR 0 4
49740: PUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: CALL_OW 305
49750: ST_TO_ADDR
// exit ;
49751: POP
49752: POP
49753: GO 49759
// end ; end ;
49755: GO 49634
49757: POP
49758: POP
// end ;
49759: LD_VAR 0 4
49763: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49764: LD_INT 0
49766: PPUSH
49767: PPUSH
49768: PPUSH
// if not side or side > 8 then
49769: LD_VAR 0 1
49773: NOT
49774: PUSH
49775: LD_VAR 0 1
49779: PUSH
49780: LD_INT 8
49782: GREATER
49783: OR
49784: IFFALSE 49788
// exit ;
49786: GO 49975
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49788: LD_ADDR_VAR 0 4
49792: PUSH
49793: LD_INT 22
49795: PUSH
49796: LD_VAR 0 1
49800: PUSH
49801: EMPTY
49802: LIST
49803: LIST
49804: PUSH
49805: LD_INT 21
49807: PUSH
49808: LD_INT 3
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: PPUSH
49819: CALL_OW 69
49823: ST_TO_ADDR
// if not tmp then
49824: LD_VAR 0 4
49828: NOT
49829: IFFALSE 49833
// exit ;
49831: GO 49975
// enable_addtolog := true ;
49833: LD_ADDR_OWVAR 81
49837: PUSH
49838: LD_INT 1
49840: ST_TO_ADDR
// AddToLog ( [ ) ;
49841: LD_STRING [
49843: PPUSH
49844: CALL_OW 561
// for i in tmp do
49848: LD_ADDR_VAR 0 3
49852: PUSH
49853: LD_VAR 0 4
49857: PUSH
49858: FOR_IN
49859: IFFALSE 49966
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49861: LD_STRING [
49863: PUSH
49864: LD_VAR 0 3
49868: PPUSH
49869: CALL_OW 266
49873: STR
49874: PUSH
49875: LD_STRING , 
49877: STR
49878: PUSH
49879: LD_VAR 0 3
49883: PPUSH
49884: CALL_OW 250
49888: STR
49889: PUSH
49890: LD_STRING , 
49892: STR
49893: PUSH
49894: LD_VAR 0 3
49898: PPUSH
49899: CALL_OW 251
49903: STR
49904: PUSH
49905: LD_STRING , 
49907: STR
49908: PUSH
49909: LD_VAR 0 3
49913: PPUSH
49914: CALL_OW 254
49918: STR
49919: PUSH
49920: LD_STRING , 
49922: STR
49923: PUSH
49924: LD_VAR 0 3
49928: PPUSH
49929: LD_INT 1
49931: PPUSH
49932: CALL_OW 268
49936: STR
49937: PUSH
49938: LD_STRING , 
49940: STR
49941: PUSH
49942: LD_VAR 0 3
49946: PPUSH
49947: LD_INT 2
49949: PPUSH
49950: CALL_OW 268
49954: STR
49955: PUSH
49956: LD_STRING ],
49958: STR
49959: PPUSH
49960: CALL_OW 561
// end ;
49964: GO 49858
49966: POP
49967: POP
// AddToLog ( ]; ) ;
49968: LD_STRING ];
49970: PPUSH
49971: CALL_OW 561
// end ;
49975: LD_VAR 0 2
49979: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49980: LD_INT 0
49982: PPUSH
49983: PPUSH
49984: PPUSH
49985: PPUSH
49986: PPUSH
// if not area or not rate or not max then
49987: LD_VAR 0 1
49991: NOT
49992: PUSH
49993: LD_VAR 0 2
49997: NOT
49998: OR
49999: PUSH
50000: LD_VAR 0 4
50004: NOT
50005: OR
50006: IFFALSE 50010
// exit ;
50008: GO 50202
// while 1 do
50010: LD_INT 1
50012: IFFALSE 50202
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50014: LD_ADDR_VAR 0 9
50018: PUSH
50019: LD_VAR 0 1
50023: PPUSH
50024: LD_INT 1
50026: PPUSH
50027: CALL_OW 287
50031: PUSH
50032: LD_INT 10
50034: MUL
50035: ST_TO_ADDR
// r := rate / 10 ;
50036: LD_ADDR_VAR 0 7
50040: PUSH
50041: LD_VAR 0 2
50045: PUSH
50046: LD_INT 10
50048: DIVREAL
50049: ST_TO_ADDR
// time := 1 1$00 ;
50050: LD_ADDR_VAR 0 8
50054: PUSH
50055: LD_INT 2100
50057: ST_TO_ADDR
// if amount < min then
50058: LD_VAR 0 9
50062: PUSH
50063: LD_VAR 0 3
50067: LESS
50068: IFFALSE 50086
// r := r * 2 else
50070: LD_ADDR_VAR 0 7
50074: PUSH
50075: LD_VAR 0 7
50079: PUSH
50080: LD_INT 2
50082: MUL
50083: ST_TO_ADDR
50084: GO 50112
// if amount > max then
50086: LD_VAR 0 9
50090: PUSH
50091: LD_VAR 0 4
50095: GREATER
50096: IFFALSE 50112
// r := r / 2 ;
50098: LD_ADDR_VAR 0 7
50102: PUSH
50103: LD_VAR 0 7
50107: PUSH
50108: LD_INT 2
50110: DIVREAL
50111: ST_TO_ADDR
// time := time / r ;
50112: LD_ADDR_VAR 0 8
50116: PUSH
50117: LD_VAR 0 8
50121: PUSH
50122: LD_VAR 0 7
50126: DIVREAL
50127: ST_TO_ADDR
// if time < 0 then
50128: LD_VAR 0 8
50132: PUSH
50133: LD_INT 0
50135: LESS
50136: IFFALSE 50153
// time := time * - 1 ;
50138: LD_ADDR_VAR 0 8
50142: PUSH
50143: LD_VAR 0 8
50147: PUSH
50148: LD_INT 1
50150: NEG
50151: MUL
50152: ST_TO_ADDR
// wait ( time ) ;
50153: LD_VAR 0 8
50157: PPUSH
50158: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50162: LD_INT 35
50164: PPUSH
50165: LD_INT 875
50167: PPUSH
50168: CALL_OW 12
50172: PPUSH
50173: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50177: LD_INT 1
50179: PPUSH
50180: LD_INT 5
50182: PPUSH
50183: CALL_OW 12
50187: PPUSH
50188: LD_VAR 0 1
50192: PPUSH
50193: LD_INT 1
50195: PPUSH
50196: CALL_OW 55
// end ;
50200: GO 50010
// end ;
50202: LD_VAR 0 5
50206: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50207: LD_INT 0
50209: PPUSH
50210: PPUSH
50211: PPUSH
50212: PPUSH
50213: PPUSH
50214: PPUSH
50215: PPUSH
50216: PPUSH
// if not turrets or not factories then
50217: LD_VAR 0 1
50221: NOT
50222: PUSH
50223: LD_VAR 0 2
50227: NOT
50228: OR
50229: IFFALSE 50233
// exit ;
50231: GO 50540
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50233: LD_ADDR_VAR 0 10
50237: PUSH
50238: LD_INT 5
50240: PUSH
50241: LD_INT 6
50243: PUSH
50244: EMPTY
50245: LIST
50246: LIST
50247: PUSH
50248: LD_INT 2
50250: PUSH
50251: LD_INT 4
50253: PUSH
50254: EMPTY
50255: LIST
50256: LIST
50257: PUSH
50258: LD_INT 3
50260: PUSH
50261: LD_INT 5
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: LIST
50272: PUSH
50273: LD_INT 24
50275: PUSH
50276: LD_INT 25
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PUSH
50283: LD_INT 23
50285: PUSH
50286: LD_INT 27
50288: PUSH
50289: EMPTY
50290: LIST
50291: LIST
50292: PUSH
50293: EMPTY
50294: LIST
50295: LIST
50296: PUSH
50297: LD_INT 42
50299: PUSH
50300: LD_INT 43
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 44
50309: PUSH
50310: LD_INT 46
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: LD_INT 45
50319: PUSH
50320: LD_INT 47
50322: PUSH
50323: EMPTY
50324: LIST
50325: LIST
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: LIST
50331: PUSH
50332: EMPTY
50333: LIST
50334: LIST
50335: LIST
50336: ST_TO_ADDR
// result := [ ] ;
50337: LD_ADDR_VAR 0 3
50341: PUSH
50342: EMPTY
50343: ST_TO_ADDR
// for i in turrets do
50344: LD_ADDR_VAR 0 4
50348: PUSH
50349: LD_VAR 0 1
50353: PUSH
50354: FOR_IN
50355: IFFALSE 50538
// begin nat := GetNation ( i ) ;
50357: LD_ADDR_VAR 0 7
50361: PUSH
50362: LD_VAR 0 4
50366: PPUSH
50367: CALL_OW 248
50371: ST_TO_ADDR
// weapon := 0 ;
50372: LD_ADDR_VAR 0 8
50376: PUSH
50377: LD_INT 0
50379: ST_TO_ADDR
// if not nat then
50380: LD_VAR 0 7
50384: NOT
50385: IFFALSE 50389
// continue ;
50387: GO 50354
// for j in list [ nat ] do
50389: LD_ADDR_VAR 0 5
50393: PUSH
50394: LD_VAR 0 10
50398: PUSH
50399: LD_VAR 0 7
50403: ARRAY
50404: PUSH
50405: FOR_IN
50406: IFFALSE 50447
// if GetBWeapon ( i ) = j [ 1 ] then
50408: LD_VAR 0 4
50412: PPUSH
50413: CALL_OW 269
50417: PUSH
50418: LD_VAR 0 5
50422: PUSH
50423: LD_INT 1
50425: ARRAY
50426: EQUAL
50427: IFFALSE 50445
// begin weapon := j [ 2 ] ;
50429: LD_ADDR_VAR 0 8
50433: PUSH
50434: LD_VAR 0 5
50438: PUSH
50439: LD_INT 2
50441: ARRAY
50442: ST_TO_ADDR
// break ;
50443: GO 50447
// end ;
50445: GO 50405
50447: POP
50448: POP
// if not weapon then
50449: LD_VAR 0 8
50453: NOT
50454: IFFALSE 50458
// continue ;
50456: GO 50354
// for k in factories do
50458: LD_ADDR_VAR 0 6
50462: PUSH
50463: LD_VAR 0 2
50467: PUSH
50468: FOR_IN
50469: IFFALSE 50534
// begin weapons := AvailableWeaponList ( k ) ;
50471: LD_ADDR_VAR 0 9
50475: PUSH
50476: LD_VAR 0 6
50480: PPUSH
50481: CALL_OW 478
50485: ST_TO_ADDR
// if not weapons then
50486: LD_VAR 0 9
50490: NOT
50491: IFFALSE 50495
// continue ;
50493: GO 50468
// if weapon in weapons then
50495: LD_VAR 0 8
50499: PUSH
50500: LD_VAR 0 9
50504: IN
50505: IFFALSE 50532
// begin result := [ i , weapon ] ;
50507: LD_ADDR_VAR 0 3
50511: PUSH
50512: LD_VAR 0 4
50516: PUSH
50517: LD_VAR 0 8
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: ST_TO_ADDR
// exit ;
50526: POP
50527: POP
50528: POP
50529: POP
50530: GO 50540
// end ; end ;
50532: GO 50468
50534: POP
50535: POP
// end ;
50536: GO 50354
50538: POP
50539: POP
// end ;
50540: LD_VAR 0 3
50544: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50545: LD_INT 0
50547: PPUSH
// if not side or side > 8 then
50548: LD_VAR 0 3
50552: NOT
50553: PUSH
50554: LD_VAR 0 3
50558: PUSH
50559: LD_INT 8
50561: GREATER
50562: OR
50563: IFFALSE 50567
// exit ;
50565: GO 50626
// if not range then
50567: LD_VAR 0 4
50571: NOT
50572: IFFALSE 50583
// range := - 12 ;
50574: LD_ADDR_VAR 0 4
50578: PUSH
50579: LD_INT 12
50581: NEG
50582: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50583: LD_VAR 0 1
50587: PPUSH
50588: LD_VAR 0 2
50592: PPUSH
50593: LD_VAR 0 3
50597: PPUSH
50598: LD_VAR 0 4
50602: PPUSH
50603: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50607: LD_VAR 0 1
50611: PPUSH
50612: LD_VAR 0 2
50616: PPUSH
50617: LD_VAR 0 3
50621: PPUSH
50622: CALL_OW 331
// end ;
50626: LD_VAR 0 5
50630: RET
// export function Video ( mode ) ; begin
50631: LD_INT 0
50633: PPUSH
// ingame_video = mode ;
50634: LD_ADDR_OWVAR 52
50638: PUSH
50639: LD_VAR 0 1
50643: ST_TO_ADDR
// interface_hidden = mode ;
50644: LD_ADDR_OWVAR 54
50648: PUSH
50649: LD_VAR 0 1
50653: ST_TO_ADDR
// end ;
50654: LD_VAR 0 2
50658: RET
// export function Join ( array , element ) ; begin
50659: LD_INT 0
50661: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50662: LD_ADDR_VAR 0 3
50666: PUSH
50667: LD_VAR 0 1
50671: PPUSH
50672: LD_VAR 0 1
50676: PUSH
50677: LD_INT 1
50679: PLUS
50680: PPUSH
50681: LD_VAR 0 2
50685: PPUSH
50686: CALL_OW 1
50690: ST_TO_ADDR
// end ;
50691: LD_VAR 0 3
50695: RET
// export function JoinUnion ( array , element ) ; begin
50696: LD_INT 0
50698: PPUSH
// result := array union element ;
50699: LD_ADDR_VAR 0 3
50703: PUSH
50704: LD_VAR 0 1
50708: PUSH
50709: LD_VAR 0 2
50713: UNION
50714: ST_TO_ADDR
// end ;
50715: LD_VAR 0 3
50719: RET
// export function GetBehemoths ( side ) ; begin
50720: LD_INT 0
50722: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50723: LD_ADDR_VAR 0 2
50727: PUSH
50728: LD_INT 22
50730: PUSH
50731: LD_VAR 0 1
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: PUSH
50740: LD_INT 31
50742: PUSH
50743: LD_INT 25
50745: PUSH
50746: EMPTY
50747: LIST
50748: LIST
50749: PUSH
50750: EMPTY
50751: LIST
50752: LIST
50753: PPUSH
50754: CALL_OW 69
50758: ST_TO_ADDR
// end ;
50759: LD_VAR 0 2
50763: RET
// export function Shuffle ( array ) ; var i , index ; begin
50764: LD_INT 0
50766: PPUSH
50767: PPUSH
50768: PPUSH
// result := [ ] ;
50769: LD_ADDR_VAR 0 2
50773: PUSH
50774: EMPTY
50775: ST_TO_ADDR
// if not array then
50776: LD_VAR 0 1
50780: NOT
50781: IFFALSE 50785
// exit ;
50783: GO 50884
// Randomize ;
50785: CALL_OW 10
// for i = array downto 1 do
50789: LD_ADDR_VAR 0 3
50793: PUSH
50794: DOUBLE
50795: LD_VAR 0 1
50799: INC
50800: ST_TO_ADDR
50801: LD_INT 1
50803: PUSH
50804: FOR_DOWNTO
50805: IFFALSE 50882
// begin index := rand ( 1 , array ) ;
50807: LD_ADDR_VAR 0 4
50811: PUSH
50812: LD_INT 1
50814: PPUSH
50815: LD_VAR 0 1
50819: PPUSH
50820: CALL_OW 12
50824: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50825: LD_ADDR_VAR 0 2
50829: PUSH
50830: LD_VAR 0 2
50834: PPUSH
50835: LD_VAR 0 2
50839: PUSH
50840: LD_INT 1
50842: PLUS
50843: PPUSH
50844: LD_VAR 0 1
50848: PUSH
50849: LD_VAR 0 4
50853: ARRAY
50854: PPUSH
50855: CALL_OW 2
50859: ST_TO_ADDR
// array := Delete ( array , index ) ;
50860: LD_ADDR_VAR 0 1
50864: PUSH
50865: LD_VAR 0 1
50869: PPUSH
50870: LD_VAR 0 4
50874: PPUSH
50875: CALL_OW 3
50879: ST_TO_ADDR
// end ;
50880: GO 50804
50882: POP
50883: POP
// end ;
50884: LD_VAR 0 2
50888: RET
// export function GetBaseMaterials ( base ) ; begin
50889: LD_INT 0
50891: PPUSH
// result := [ 0 , 0 , 0 ] ;
50892: LD_ADDR_VAR 0 2
50896: PUSH
50897: LD_INT 0
50899: PUSH
50900: LD_INT 0
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: LIST
50910: ST_TO_ADDR
// if not base then
50911: LD_VAR 0 1
50915: NOT
50916: IFFALSE 50920
// exit ;
50918: GO 50969
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50920: LD_ADDR_VAR 0 2
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: LD_INT 1
50932: PPUSH
50933: CALL_OW 275
50937: PUSH
50938: LD_VAR 0 1
50942: PPUSH
50943: LD_INT 2
50945: PPUSH
50946: CALL_OW 275
50950: PUSH
50951: LD_VAR 0 1
50955: PPUSH
50956: LD_INT 3
50958: PPUSH
50959: CALL_OW 275
50963: PUSH
50964: EMPTY
50965: LIST
50966: LIST
50967: LIST
50968: ST_TO_ADDR
// end ;
50969: LD_VAR 0 2
50973: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50974: LD_INT 0
50976: PPUSH
50977: PPUSH
// result := array ;
50978: LD_ADDR_VAR 0 3
50982: PUSH
50983: LD_VAR 0 1
50987: ST_TO_ADDR
// if size > 0 then
50988: LD_VAR 0 2
50992: PUSH
50993: LD_INT 0
50995: GREATER
50996: IFFALSE 51042
// for i := array downto size do
50998: LD_ADDR_VAR 0 4
51002: PUSH
51003: DOUBLE
51004: LD_VAR 0 1
51008: INC
51009: ST_TO_ADDR
51010: LD_VAR 0 2
51014: PUSH
51015: FOR_DOWNTO
51016: IFFALSE 51040
// result := Delete ( result , result ) ;
51018: LD_ADDR_VAR 0 3
51022: PUSH
51023: LD_VAR 0 3
51027: PPUSH
51028: LD_VAR 0 3
51032: PPUSH
51033: CALL_OW 3
51037: ST_TO_ADDR
51038: GO 51015
51040: POP
51041: POP
// end ;
51042: LD_VAR 0 3
51046: RET
// export function ComExit ( unit ) ; var tmp ; begin
51047: LD_INT 0
51049: PPUSH
51050: PPUSH
// if not IsInUnit ( unit ) then
51051: LD_VAR 0 1
51055: PPUSH
51056: CALL_OW 310
51060: NOT
51061: IFFALSE 51065
// exit ;
51063: GO 51125
// tmp := IsInUnit ( unit ) ;
51065: LD_ADDR_VAR 0 3
51069: PUSH
51070: LD_VAR 0 1
51074: PPUSH
51075: CALL_OW 310
51079: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51080: LD_VAR 0 3
51084: PPUSH
51085: CALL_OW 247
51089: PUSH
51090: LD_INT 2
51092: EQUAL
51093: IFFALSE 51106
// ComExitVehicle ( unit ) else
51095: LD_VAR 0 1
51099: PPUSH
51100: CALL_OW 121
51104: GO 51115
// ComExitBuilding ( unit ) ;
51106: LD_VAR 0 1
51110: PPUSH
51111: CALL_OW 122
// result := tmp ;
51115: LD_ADDR_VAR 0 2
51119: PUSH
51120: LD_VAR 0 3
51124: ST_TO_ADDR
// end ;
51125: LD_VAR 0 2
51129: RET
// export function ComExitAll ( units ) ; var i ; begin
51130: LD_INT 0
51132: PPUSH
51133: PPUSH
// if not units then
51134: LD_VAR 0 1
51138: NOT
51139: IFFALSE 51143
// exit ;
51141: GO 51169
// for i in units do
51143: LD_ADDR_VAR 0 3
51147: PUSH
51148: LD_VAR 0 1
51152: PUSH
51153: FOR_IN
51154: IFFALSE 51167
// ComExit ( i ) ;
51156: LD_VAR 0 3
51160: PPUSH
51161: CALL 51047 0 1
51165: GO 51153
51167: POP
51168: POP
// end ;
51169: LD_VAR 0 2
51173: RET
// export function ResetHc ; begin
51174: LD_INT 0
51176: PPUSH
// InitHc ;
51177: CALL_OW 19
// hc_importance := 0 ;
51181: LD_ADDR_OWVAR 32
51185: PUSH
51186: LD_INT 0
51188: ST_TO_ADDR
// end ;
51189: LD_VAR 0 1
51193: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51194: LD_INT 0
51196: PPUSH
51197: PPUSH
51198: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51199: LD_ADDR_VAR 0 6
51203: PUSH
51204: LD_VAR 0 1
51208: PUSH
51209: LD_VAR 0 3
51213: PLUS
51214: PUSH
51215: LD_INT 2
51217: DIV
51218: ST_TO_ADDR
// if _x < 0 then
51219: LD_VAR 0 6
51223: PUSH
51224: LD_INT 0
51226: LESS
51227: IFFALSE 51244
// _x := _x * - 1 ;
51229: LD_ADDR_VAR 0 6
51233: PUSH
51234: LD_VAR 0 6
51238: PUSH
51239: LD_INT 1
51241: NEG
51242: MUL
51243: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51244: LD_ADDR_VAR 0 7
51248: PUSH
51249: LD_VAR 0 2
51253: PUSH
51254: LD_VAR 0 4
51258: PLUS
51259: PUSH
51260: LD_INT 2
51262: DIV
51263: ST_TO_ADDR
// if _y < 0 then
51264: LD_VAR 0 7
51268: PUSH
51269: LD_INT 0
51271: LESS
51272: IFFALSE 51289
// _y := _y * - 1 ;
51274: LD_ADDR_VAR 0 7
51278: PUSH
51279: LD_VAR 0 7
51283: PUSH
51284: LD_INT 1
51286: NEG
51287: MUL
51288: ST_TO_ADDR
// result := [ _x , _y ] ;
51289: LD_ADDR_VAR 0 5
51293: PUSH
51294: LD_VAR 0 6
51298: PUSH
51299: LD_VAR 0 7
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: ST_TO_ADDR
// end ;
51308: LD_VAR 0 5
51312: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51313: LD_INT 0
51315: PPUSH
51316: PPUSH
51317: PPUSH
51318: PPUSH
// task := GetTaskList ( unit ) ;
51319: LD_ADDR_VAR 0 7
51323: PUSH
51324: LD_VAR 0 1
51328: PPUSH
51329: CALL_OW 437
51333: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51334: LD_VAR 0 7
51338: NOT
51339: PUSH
51340: LD_VAR 0 1
51344: PPUSH
51345: LD_VAR 0 2
51349: PPUSH
51350: CALL_OW 308
51354: NOT
51355: AND
51356: IFFALSE 51360
// exit ;
51358: GO 51478
// if IsInArea ( unit , area ) then
51360: LD_VAR 0 1
51364: PPUSH
51365: LD_VAR 0 2
51369: PPUSH
51370: CALL_OW 308
51374: IFFALSE 51392
// begin ComMoveToArea ( unit , goAway ) ;
51376: LD_VAR 0 1
51380: PPUSH
51381: LD_VAR 0 3
51385: PPUSH
51386: CALL_OW 113
// exit ;
51390: GO 51478
// end ; if task [ 1 ] [ 1 ] <> M then
51392: LD_VAR 0 7
51396: PUSH
51397: LD_INT 1
51399: ARRAY
51400: PUSH
51401: LD_INT 1
51403: ARRAY
51404: PUSH
51405: LD_STRING M
51407: NONEQUAL
51408: IFFALSE 51412
// exit ;
51410: GO 51478
// x := task [ 1 ] [ 2 ] ;
51412: LD_ADDR_VAR 0 5
51416: PUSH
51417: LD_VAR 0 7
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PUSH
51426: LD_INT 2
51428: ARRAY
51429: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51430: LD_ADDR_VAR 0 6
51434: PUSH
51435: LD_VAR 0 7
51439: PUSH
51440: LD_INT 1
51442: ARRAY
51443: PUSH
51444: LD_INT 3
51446: ARRAY
51447: ST_TO_ADDR
// if InArea ( x , y , area ) then
51448: LD_VAR 0 5
51452: PPUSH
51453: LD_VAR 0 6
51457: PPUSH
51458: LD_VAR 0 2
51462: PPUSH
51463: CALL_OW 309
51467: IFFALSE 51478
// ComStop ( unit ) ;
51469: LD_VAR 0 1
51473: PPUSH
51474: CALL_OW 141
// end ;
51478: LD_VAR 0 4
51482: RET
// export function Abs ( value ) ; begin
51483: LD_INT 0
51485: PPUSH
// result := value ;
51486: LD_ADDR_VAR 0 2
51490: PUSH
51491: LD_VAR 0 1
51495: ST_TO_ADDR
// if value < 0 then
51496: LD_VAR 0 1
51500: PUSH
51501: LD_INT 0
51503: LESS
51504: IFFALSE 51521
// result := value * - 1 ;
51506: LD_ADDR_VAR 0 2
51510: PUSH
51511: LD_VAR 0 1
51515: PUSH
51516: LD_INT 1
51518: NEG
51519: MUL
51520: ST_TO_ADDR
// end ;
51521: LD_VAR 0 2
51525: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51526: LD_INT 0
51528: PPUSH
51529: PPUSH
51530: PPUSH
51531: PPUSH
51532: PPUSH
51533: PPUSH
51534: PPUSH
51535: PPUSH
// if not unit or not building then
51536: LD_VAR 0 1
51540: NOT
51541: PUSH
51542: LD_VAR 0 2
51546: NOT
51547: OR
51548: IFFALSE 51552
// exit ;
51550: GO 51778
// x := GetX ( building ) ;
51552: LD_ADDR_VAR 0 4
51556: PUSH
51557: LD_VAR 0 2
51561: PPUSH
51562: CALL_OW 250
51566: ST_TO_ADDR
// y := GetY ( building ) ;
51567: LD_ADDR_VAR 0 6
51571: PUSH
51572: LD_VAR 0 2
51576: PPUSH
51577: CALL_OW 251
51581: ST_TO_ADDR
// d := GetDir ( building ) ;
51582: LD_ADDR_VAR 0 8
51586: PUSH
51587: LD_VAR 0 2
51591: PPUSH
51592: CALL_OW 254
51596: ST_TO_ADDR
// r := 4 ;
51597: LD_ADDR_VAR 0 9
51601: PUSH
51602: LD_INT 4
51604: ST_TO_ADDR
// for i := 1 to 5 do
51605: LD_ADDR_VAR 0 10
51609: PUSH
51610: DOUBLE
51611: LD_INT 1
51613: DEC
51614: ST_TO_ADDR
51615: LD_INT 5
51617: PUSH
51618: FOR_TO
51619: IFFALSE 51776
// begin _x := ShiftX ( x , d , r + i ) ;
51621: LD_ADDR_VAR 0 5
51625: PUSH
51626: LD_VAR 0 4
51630: PPUSH
51631: LD_VAR 0 8
51635: PPUSH
51636: LD_VAR 0 9
51640: PUSH
51641: LD_VAR 0 10
51645: PLUS
51646: PPUSH
51647: CALL_OW 272
51651: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51652: LD_ADDR_VAR 0 7
51656: PUSH
51657: LD_VAR 0 6
51661: PPUSH
51662: LD_VAR 0 8
51666: PPUSH
51667: LD_VAR 0 9
51671: PUSH
51672: LD_VAR 0 10
51676: PLUS
51677: PPUSH
51678: CALL_OW 273
51682: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51683: LD_VAR 0 5
51687: PPUSH
51688: LD_VAR 0 7
51692: PPUSH
51693: CALL_OW 488
51697: PUSH
51698: LD_VAR 0 5
51702: PPUSH
51703: LD_VAR 0 7
51707: PPUSH
51708: CALL_OW 428
51712: PPUSH
51713: CALL_OW 247
51717: PUSH
51718: LD_INT 3
51720: PUSH
51721: LD_INT 2
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: IN
51728: NOT
51729: AND
51730: IFFALSE 51774
// begin ComMoveXY ( unit , _x , _y ) ;
51732: LD_VAR 0 1
51736: PPUSH
51737: LD_VAR 0 5
51741: PPUSH
51742: LD_VAR 0 7
51746: PPUSH
51747: CALL_OW 111
// result := [ _x , _y ] ;
51751: LD_ADDR_VAR 0 3
51755: PUSH
51756: LD_VAR 0 5
51760: PUSH
51761: LD_VAR 0 7
51765: PUSH
51766: EMPTY
51767: LIST
51768: LIST
51769: ST_TO_ADDR
// exit ;
51770: POP
51771: POP
51772: GO 51778
// end ; end ;
51774: GO 51618
51776: POP
51777: POP
// end ;
51778: LD_VAR 0 3
51782: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51783: LD_INT 0
51785: PPUSH
51786: PPUSH
51787: PPUSH
// result := 0 ;
51788: LD_ADDR_VAR 0 3
51792: PUSH
51793: LD_INT 0
51795: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51796: LD_VAR 0 1
51800: PUSH
51801: LD_INT 0
51803: LESS
51804: PUSH
51805: LD_VAR 0 1
51809: PUSH
51810: LD_INT 8
51812: GREATER
51813: OR
51814: PUSH
51815: LD_VAR 0 2
51819: PUSH
51820: LD_INT 0
51822: LESS
51823: OR
51824: PUSH
51825: LD_VAR 0 2
51829: PUSH
51830: LD_INT 8
51832: GREATER
51833: OR
51834: IFFALSE 51838
// exit ;
51836: GO 51913
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51838: LD_ADDR_VAR 0 4
51842: PUSH
51843: LD_INT 22
51845: PUSH
51846: LD_VAR 0 2
51850: PUSH
51851: EMPTY
51852: LIST
51853: LIST
51854: PPUSH
51855: CALL_OW 69
51859: PUSH
51860: FOR_IN
51861: IFFALSE 51911
// begin un := UnitShoot ( i ) ;
51863: LD_ADDR_VAR 0 5
51867: PUSH
51868: LD_VAR 0 4
51872: PPUSH
51873: CALL_OW 504
51877: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51878: LD_VAR 0 5
51882: PPUSH
51883: CALL_OW 255
51887: PUSH
51888: LD_VAR 0 1
51892: EQUAL
51893: IFFALSE 51909
// begin result := un ;
51895: LD_ADDR_VAR 0 3
51899: PUSH
51900: LD_VAR 0 5
51904: ST_TO_ADDR
// exit ;
51905: POP
51906: POP
51907: GO 51913
// end ; end ;
51909: GO 51860
51911: POP
51912: POP
// end ;
51913: LD_VAR 0 3
51917: RET
// export function GetCargoBay ( units ) ; begin
51918: LD_INT 0
51920: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51921: LD_ADDR_VAR 0 2
51925: PUSH
51926: LD_VAR 0 1
51930: PPUSH
51931: LD_INT 2
51933: PUSH
51934: LD_INT 34
51936: PUSH
51937: LD_INT 12
51939: PUSH
51940: EMPTY
51941: LIST
51942: LIST
51943: PUSH
51944: LD_INT 34
51946: PUSH
51947: LD_INT 51
51949: PUSH
51950: EMPTY
51951: LIST
51952: LIST
51953: PUSH
51954: LD_INT 34
51956: PUSH
51957: LD_INT 32
51959: PUSH
51960: EMPTY
51961: LIST
51962: LIST
51963: PUSH
51964: LD_INT 34
51966: PUSH
51967: LD_EXP 103
51971: PUSH
51972: EMPTY
51973: LIST
51974: LIST
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: PPUSH
51983: CALL_OW 72
51987: ST_TO_ADDR
// end ; end_of_file
51988: LD_VAR 0 2
51992: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
51993: LD_INT 0
51995: PPUSH
51996: PPUSH
// skirmish := false ;
51997: LD_ADDR_EXP 57
52001: PUSH
52002: LD_INT 0
52004: ST_TO_ADDR
// debug_mc := false ;
52005: LD_ADDR_EXP 58
52009: PUSH
52010: LD_INT 0
52012: ST_TO_ADDR
// mc_bases := [ ] ;
52013: LD_ADDR_EXP 59
52017: PUSH
52018: EMPTY
52019: ST_TO_ADDR
// mc_sides := [ ] ;
52020: LD_ADDR_EXP 85
52024: PUSH
52025: EMPTY
52026: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52027: LD_ADDR_EXP 60
52031: PUSH
52032: EMPTY
52033: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52034: LD_ADDR_EXP 61
52038: PUSH
52039: EMPTY
52040: ST_TO_ADDR
// mc_need_heal := [ ] ;
52041: LD_ADDR_EXP 62
52045: PUSH
52046: EMPTY
52047: ST_TO_ADDR
// mc_healers := [ ] ;
52048: LD_ADDR_EXP 63
52052: PUSH
52053: EMPTY
52054: ST_TO_ADDR
// mc_build_list := [ ] ;
52055: LD_ADDR_EXP 64
52059: PUSH
52060: EMPTY
52061: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52062: LD_ADDR_EXP 91
52066: PUSH
52067: EMPTY
52068: ST_TO_ADDR
// mc_builders := [ ] ;
52069: LD_ADDR_EXP 65
52073: PUSH
52074: EMPTY
52075: ST_TO_ADDR
// mc_construct_list := [ ] ;
52076: LD_ADDR_EXP 66
52080: PUSH
52081: EMPTY
52082: ST_TO_ADDR
// mc_turret_list := [ ] ;
52083: LD_ADDR_EXP 67
52087: PUSH
52088: EMPTY
52089: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52090: LD_ADDR_EXP 68
52094: PUSH
52095: EMPTY
52096: ST_TO_ADDR
// mc_miners := [ ] ;
52097: LD_ADDR_EXP 73
52101: PUSH
52102: EMPTY
52103: ST_TO_ADDR
// mc_mines := [ ] ;
52104: LD_ADDR_EXP 72
52108: PUSH
52109: EMPTY
52110: ST_TO_ADDR
// mc_minefields := [ ] ;
52111: LD_ADDR_EXP 74
52115: PUSH
52116: EMPTY
52117: ST_TO_ADDR
// mc_crates := [ ] ;
52118: LD_ADDR_EXP 75
52122: PUSH
52123: EMPTY
52124: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52125: LD_ADDR_EXP 76
52129: PUSH
52130: EMPTY
52131: ST_TO_ADDR
// mc_crates_area := [ ] ;
52132: LD_ADDR_EXP 77
52136: PUSH
52137: EMPTY
52138: ST_TO_ADDR
// mc_vehicles := [ ] ;
52139: LD_ADDR_EXP 78
52143: PUSH
52144: EMPTY
52145: ST_TO_ADDR
// mc_attack := [ ] ;
52146: LD_ADDR_EXP 79
52150: PUSH
52151: EMPTY
52152: ST_TO_ADDR
// mc_produce := [ ] ;
52153: LD_ADDR_EXP 80
52157: PUSH
52158: EMPTY
52159: ST_TO_ADDR
// mc_defender := [ ] ;
52160: LD_ADDR_EXP 81
52164: PUSH
52165: EMPTY
52166: ST_TO_ADDR
// mc_parking := [ ] ;
52167: LD_ADDR_EXP 83
52171: PUSH
52172: EMPTY
52173: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52174: LD_ADDR_EXP 69
52178: PUSH
52179: EMPTY
52180: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52181: LD_ADDR_EXP 71
52185: PUSH
52186: EMPTY
52187: ST_TO_ADDR
// mc_scan := [ ] ;
52188: LD_ADDR_EXP 82
52192: PUSH
52193: EMPTY
52194: ST_TO_ADDR
// mc_scan_area := [ ] ;
52195: LD_ADDR_EXP 84
52199: PUSH
52200: EMPTY
52201: ST_TO_ADDR
// mc_tech := [ ] ;
52202: LD_ADDR_EXP 86
52206: PUSH
52207: EMPTY
52208: ST_TO_ADDR
// mc_class := [ ] ;
52209: LD_ADDR_EXP 100
52213: PUSH
52214: EMPTY
52215: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52216: LD_ADDR_EXP 101
52220: PUSH
52221: EMPTY
52222: ST_TO_ADDR
// end ;
52223: LD_VAR 0 1
52227: RET
// export function MC_Kill ( base ) ; begin
52228: LD_INT 0
52230: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52231: LD_ADDR_EXP 59
52235: PUSH
52236: LD_EXP 59
52240: PPUSH
52241: LD_VAR 0 1
52245: PPUSH
52246: EMPTY
52247: PPUSH
52248: CALL_OW 1
52252: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52253: LD_ADDR_EXP 60
52257: PUSH
52258: LD_EXP 60
52262: PPUSH
52263: LD_VAR 0 1
52267: PPUSH
52268: EMPTY
52269: PPUSH
52270: CALL_OW 1
52274: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52275: LD_ADDR_EXP 61
52279: PUSH
52280: LD_EXP 61
52284: PPUSH
52285: LD_VAR 0 1
52289: PPUSH
52290: EMPTY
52291: PPUSH
52292: CALL_OW 1
52296: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52297: LD_ADDR_EXP 62
52301: PUSH
52302: LD_EXP 62
52306: PPUSH
52307: LD_VAR 0 1
52311: PPUSH
52312: EMPTY
52313: PPUSH
52314: CALL_OW 1
52318: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52319: LD_ADDR_EXP 63
52323: PUSH
52324: LD_EXP 63
52328: PPUSH
52329: LD_VAR 0 1
52333: PPUSH
52334: EMPTY
52335: PPUSH
52336: CALL_OW 1
52340: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52341: LD_ADDR_EXP 64
52345: PUSH
52346: LD_EXP 64
52350: PPUSH
52351: LD_VAR 0 1
52355: PPUSH
52356: EMPTY
52357: PPUSH
52358: CALL_OW 1
52362: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52363: LD_ADDR_EXP 65
52367: PUSH
52368: LD_EXP 65
52372: PPUSH
52373: LD_VAR 0 1
52377: PPUSH
52378: EMPTY
52379: PPUSH
52380: CALL_OW 1
52384: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52385: LD_ADDR_EXP 66
52389: PUSH
52390: LD_EXP 66
52394: PPUSH
52395: LD_VAR 0 1
52399: PPUSH
52400: EMPTY
52401: PPUSH
52402: CALL_OW 1
52406: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52407: LD_ADDR_EXP 67
52411: PUSH
52412: LD_EXP 67
52416: PPUSH
52417: LD_VAR 0 1
52421: PPUSH
52422: EMPTY
52423: PPUSH
52424: CALL_OW 1
52428: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52429: LD_ADDR_EXP 68
52433: PUSH
52434: LD_EXP 68
52438: PPUSH
52439: LD_VAR 0 1
52443: PPUSH
52444: EMPTY
52445: PPUSH
52446: CALL_OW 1
52450: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52451: LD_ADDR_EXP 69
52455: PUSH
52456: LD_EXP 69
52460: PPUSH
52461: LD_VAR 0 1
52465: PPUSH
52466: EMPTY
52467: PPUSH
52468: CALL_OW 1
52472: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52473: LD_ADDR_EXP 70
52477: PUSH
52478: LD_EXP 70
52482: PPUSH
52483: LD_VAR 0 1
52487: PPUSH
52488: LD_INT 0
52490: PPUSH
52491: CALL_OW 1
52495: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52496: LD_ADDR_EXP 71
52500: PUSH
52501: LD_EXP 71
52505: PPUSH
52506: LD_VAR 0 1
52510: PPUSH
52511: EMPTY
52512: PPUSH
52513: CALL_OW 1
52517: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52518: LD_ADDR_EXP 72
52522: PUSH
52523: LD_EXP 72
52527: PPUSH
52528: LD_VAR 0 1
52532: PPUSH
52533: EMPTY
52534: PPUSH
52535: CALL_OW 1
52539: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52540: LD_ADDR_EXP 73
52544: PUSH
52545: LD_EXP 73
52549: PPUSH
52550: LD_VAR 0 1
52554: PPUSH
52555: EMPTY
52556: PPUSH
52557: CALL_OW 1
52561: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52562: LD_ADDR_EXP 74
52566: PUSH
52567: LD_EXP 74
52571: PPUSH
52572: LD_VAR 0 1
52576: PPUSH
52577: EMPTY
52578: PPUSH
52579: CALL_OW 1
52583: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52584: LD_ADDR_EXP 75
52588: PUSH
52589: LD_EXP 75
52593: PPUSH
52594: LD_VAR 0 1
52598: PPUSH
52599: EMPTY
52600: PPUSH
52601: CALL_OW 1
52605: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52606: LD_ADDR_EXP 76
52610: PUSH
52611: LD_EXP 76
52615: PPUSH
52616: LD_VAR 0 1
52620: PPUSH
52621: EMPTY
52622: PPUSH
52623: CALL_OW 1
52627: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52628: LD_ADDR_EXP 77
52632: PUSH
52633: LD_EXP 77
52637: PPUSH
52638: LD_VAR 0 1
52642: PPUSH
52643: EMPTY
52644: PPUSH
52645: CALL_OW 1
52649: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52650: LD_ADDR_EXP 78
52654: PUSH
52655: LD_EXP 78
52659: PPUSH
52660: LD_VAR 0 1
52664: PPUSH
52665: EMPTY
52666: PPUSH
52667: CALL_OW 1
52671: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52672: LD_ADDR_EXP 79
52676: PUSH
52677: LD_EXP 79
52681: PPUSH
52682: LD_VAR 0 1
52686: PPUSH
52687: EMPTY
52688: PPUSH
52689: CALL_OW 1
52693: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52694: LD_ADDR_EXP 80
52698: PUSH
52699: LD_EXP 80
52703: PPUSH
52704: LD_VAR 0 1
52708: PPUSH
52709: EMPTY
52710: PPUSH
52711: CALL_OW 1
52715: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52716: LD_ADDR_EXP 81
52720: PUSH
52721: LD_EXP 81
52725: PPUSH
52726: LD_VAR 0 1
52730: PPUSH
52731: EMPTY
52732: PPUSH
52733: CALL_OW 1
52737: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52738: LD_ADDR_EXP 82
52742: PUSH
52743: LD_EXP 82
52747: PPUSH
52748: LD_VAR 0 1
52752: PPUSH
52753: EMPTY
52754: PPUSH
52755: CALL_OW 1
52759: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52760: LD_ADDR_EXP 83
52764: PUSH
52765: LD_EXP 83
52769: PPUSH
52770: LD_VAR 0 1
52774: PPUSH
52775: EMPTY
52776: PPUSH
52777: CALL_OW 1
52781: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52782: LD_ADDR_EXP 84
52786: PUSH
52787: LD_EXP 84
52791: PPUSH
52792: LD_VAR 0 1
52796: PPUSH
52797: EMPTY
52798: PPUSH
52799: CALL_OW 1
52803: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52804: LD_ADDR_EXP 86
52808: PUSH
52809: LD_EXP 86
52813: PPUSH
52814: LD_VAR 0 1
52818: PPUSH
52819: EMPTY
52820: PPUSH
52821: CALL_OW 1
52825: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52826: LD_ADDR_EXP 88
52830: PUSH
52831: LD_EXP 88
52835: PPUSH
52836: LD_VAR 0 1
52840: PPUSH
52841: EMPTY
52842: PPUSH
52843: CALL_OW 1
52847: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52848: LD_ADDR_EXP 89
52852: PUSH
52853: LD_EXP 89
52857: PPUSH
52858: LD_VAR 0 1
52862: PPUSH
52863: EMPTY
52864: PPUSH
52865: CALL_OW 1
52869: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52870: LD_ADDR_EXP 90
52874: PUSH
52875: LD_EXP 90
52879: PPUSH
52880: LD_VAR 0 1
52884: PPUSH
52885: EMPTY
52886: PPUSH
52887: CALL_OW 1
52891: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52892: LD_ADDR_EXP 91
52896: PUSH
52897: LD_EXP 91
52901: PPUSH
52902: LD_VAR 0 1
52906: PPUSH
52907: EMPTY
52908: PPUSH
52909: CALL_OW 1
52913: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52914: LD_ADDR_EXP 92
52918: PUSH
52919: LD_EXP 92
52923: PPUSH
52924: LD_VAR 0 1
52928: PPUSH
52929: EMPTY
52930: PPUSH
52931: CALL_OW 1
52935: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52936: LD_ADDR_EXP 93
52940: PUSH
52941: LD_EXP 93
52945: PPUSH
52946: LD_VAR 0 1
52950: PPUSH
52951: EMPTY
52952: PPUSH
52953: CALL_OW 1
52957: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52958: LD_ADDR_EXP 94
52962: PUSH
52963: LD_EXP 94
52967: PPUSH
52968: LD_VAR 0 1
52972: PPUSH
52973: EMPTY
52974: PPUSH
52975: CALL_OW 1
52979: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52980: LD_ADDR_EXP 95
52984: PUSH
52985: LD_EXP 95
52989: PPUSH
52990: LD_VAR 0 1
52994: PPUSH
52995: EMPTY
52996: PPUSH
52997: CALL_OW 1
53001: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53002: LD_ADDR_EXP 96
53006: PUSH
53007: LD_EXP 96
53011: PPUSH
53012: LD_VAR 0 1
53016: PPUSH
53017: EMPTY
53018: PPUSH
53019: CALL_OW 1
53023: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53024: LD_ADDR_EXP 97
53028: PUSH
53029: LD_EXP 97
53033: PPUSH
53034: LD_VAR 0 1
53038: PPUSH
53039: EMPTY
53040: PPUSH
53041: CALL_OW 1
53045: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53046: LD_ADDR_EXP 98
53050: PUSH
53051: LD_EXP 98
53055: PPUSH
53056: LD_VAR 0 1
53060: PPUSH
53061: EMPTY
53062: PPUSH
53063: CALL_OW 1
53067: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53068: LD_ADDR_EXP 99
53072: PUSH
53073: LD_EXP 99
53077: PPUSH
53078: LD_VAR 0 1
53082: PPUSH
53083: EMPTY
53084: PPUSH
53085: CALL_OW 1
53089: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53090: LD_ADDR_EXP 100
53094: PUSH
53095: LD_EXP 100
53099: PPUSH
53100: LD_VAR 0 1
53104: PPUSH
53105: EMPTY
53106: PPUSH
53107: CALL_OW 1
53111: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53112: LD_ADDR_EXP 101
53116: PUSH
53117: LD_EXP 101
53121: PPUSH
53122: LD_VAR 0 1
53126: PPUSH
53127: LD_INT 0
53129: PPUSH
53130: CALL_OW 1
53134: ST_TO_ADDR
// end ;
53135: LD_VAR 0 2
53139: RET
// export function MC_Add ( side , units ) ; var base ; begin
53140: LD_INT 0
53142: PPUSH
53143: PPUSH
// base := mc_bases + 1 ;
53144: LD_ADDR_VAR 0 4
53148: PUSH
53149: LD_EXP 59
53153: PUSH
53154: LD_INT 1
53156: PLUS
53157: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53158: LD_ADDR_EXP 85
53162: PUSH
53163: LD_EXP 85
53167: PPUSH
53168: LD_VAR 0 4
53172: PPUSH
53173: LD_VAR 0 1
53177: PPUSH
53178: CALL_OW 1
53182: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53183: LD_ADDR_EXP 59
53187: PUSH
53188: LD_EXP 59
53192: PPUSH
53193: LD_VAR 0 4
53197: PPUSH
53198: LD_VAR 0 2
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53208: LD_ADDR_EXP 60
53212: PUSH
53213: LD_EXP 60
53217: PPUSH
53218: LD_VAR 0 4
53222: PPUSH
53223: EMPTY
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53230: LD_ADDR_EXP 61
53234: PUSH
53235: LD_EXP 61
53239: PPUSH
53240: LD_VAR 0 4
53244: PPUSH
53245: EMPTY
53246: PPUSH
53247: CALL_OW 1
53251: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53252: LD_ADDR_EXP 62
53256: PUSH
53257: LD_EXP 62
53261: PPUSH
53262: LD_VAR 0 4
53266: PPUSH
53267: EMPTY
53268: PPUSH
53269: CALL_OW 1
53273: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53274: LD_ADDR_EXP 63
53278: PUSH
53279: LD_EXP 63
53283: PPUSH
53284: LD_VAR 0 4
53288: PPUSH
53289: EMPTY
53290: PPUSH
53291: CALL_OW 1
53295: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53296: LD_ADDR_EXP 64
53300: PUSH
53301: LD_EXP 64
53305: PPUSH
53306: LD_VAR 0 4
53310: PPUSH
53311: EMPTY
53312: PPUSH
53313: CALL_OW 1
53317: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53318: LD_ADDR_EXP 65
53322: PUSH
53323: LD_EXP 65
53327: PPUSH
53328: LD_VAR 0 4
53332: PPUSH
53333: EMPTY
53334: PPUSH
53335: CALL_OW 1
53339: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53340: LD_ADDR_EXP 66
53344: PUSH
53345: LD_EXP 66
53349: PPUSH
53350: LD_VAR 0 4
53354: PPUSH
53355: EMPTY
53356: PPUSH
53357: CALL_OW 1
53361: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53362: LD_ADDR_EXP 67
53366: PUSH
53367: LD_EXP 67
53371: PPUSH
53372: LD_VAR 0 4
53376: PPUSH
53377: EMPTY
53378: PPUSH
53379: CALL_OW 1
53383: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53384: LD_ADDR_EXP 68
53388: PUSH
53389: LD_EXP 68
53393: PPUSH
53394: LD_VAR 0 4
53398: PPUSH
53399: EMPTY
53400: PPUSH
53401: CALL_OW 1
53405: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53406: LD_ADDR_EXP 69
53410: PUSH
53411: LD_EXP 69
53415: PPUSH
53416: LD_VAR 0 4
53420: PPUSH
53421: EMPTY
53422: PPUSH
53423: CALL_OW 1
53427: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53428: LD_ADDR_EXP 70
53432: PUSH
53433: LD_EXP 70
53437: PPUSH
53438: LD_VAR 0 4
53442: PPUSH
53443: LD_INT 0
53445: PPUSH
53446: CALL_OW 1
53450: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53451: LD_ADDR_EXP 71
53455: PUSH
53456: LD_EXP 71
53460: PPUSH
53461: LD_VAR 0 4
53465: PPUSH
53466: EMPTY
53467: PPUSH
53468: CALL_OW 1
53472: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53473: LD_ADDR_EXP 72
53477: PUSH
53478: LD_EXP 72
53482: PPUSH
53483: LD_VAR 0 4
53487: PPUSH
53488: EMPTY
53489: PPUSH
53490: CALL_OW 1
53494: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53495: LD_ADDR_EXP 73
53499: PUSH
53500: LD_EXP 73
53504: PPUSH
53505: LD_VAR 0 4
53509: PPUSH
53510: EMPTY
53511: PPUSH
53512: CALL_OW 1
53516: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53517: LD_ADDR_EXP 74
53521: PUSH
53522: LD_EXP 74
53526: PPUSH
53527: LD_VAR 0 4
53531: PPUSH
53532: EMPTY
53533: PPUSH
53534: CALL_OW 1
53538: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53539: LD_ADDR_EXP 75
53543: PUSH
53544: LD_EXP 75
53548: PPUSH
53549: LD_VAR 0 4
53553: PPUSH
53554: EMPTY
53555: PPUSH
53556: CALL_OW 1
53560: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53561: LD_ADDR_EXP 76
53565: PUSH
53566: LD_EXP 76
53570: PPUSH
53571: LD_VAR 0 4
53575: PPUSH
53576: EMPTY
53577: PPUSH
53578: CALL_OW 1
53582: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53583: LD_ADDR_EXP 77
53587: PUSH
53588: LD_EXP 77
53592: PPUSH
53593: LD_VAR 0 4
53597: PPUSH
53598: EMPTY
53599: PPUSH
53600: CALL_OW 1
53604: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53605: LD_ADDR_EXP 78
53609: PUSH
53610: LD_EXP 78
53614: PPUSH
53615: LD_VAR 0 4
53619: PPUSH
53620: EMPTY
53621: PPUSH
53622: CALL_OW 1
53626: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53627: LD_ADDR_EXP 79
53631: PUSH
53632: LD_EXP 79
53636: PPUSH
53637: LD_VAR 0 4
53641: PPUSH
53642: EMPTY
53643: PPUSH
53644: CALL_OW 1
53648: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53649: LD_ADDR_EXP 80
53653: PUSH
53654: LD_EXP 80
53658: PPUSH
53659: LD_VAR 0 4
53663: PPUSH
53664: EMPTY
53665: PPUSH
53666: CALL_OW 1
53670: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53671: LD_ADDR_EXP 81
53675: PUSH
53676: LD_EXP 81
53680: PPUSH
53681: LD_VAR 0 4
53685: PPUSH
53686: EMPTY
53687: PPUSH
53688: CALL_OW 1
53692: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53693: LD_ADDR_EXP 82
53697: PUSH
53698: LD_EXP 82
53702: PPUSH
53703: LD_VAR 0 4
53707: PPUSH
53708: EMPTY
53709: PPUSH
53710: CALL_OW 1
53714: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53715: LD_ADDR_EXP 83
53719: PUSH
53720: LD_EXP 83
53724: PPUSH
53725: LD_VAR 0 4
53729: PPUSH
53730: EMPTY
53731: PPUSH
53732: CALL_OW 1
53736: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53737: LD_ADDR_EXP 84
53741: PUSH
53742: LD_EXP 84
53746: PPUSH
53747: LD_VAR 0 4
53751: PPUSH
53752: EMPTY
53753: PPUSH
53754: CALL_OW 1
53758: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53759: LD_ADDR_EXP 86
53763: PUSH
53764: LD_EXP 86
53768: PPUSH
53769: LD_VAR 0 4
53773: PPUSH
53774: EMPTY
53775: PPUSH
53776: CALL_OW 1
53780: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53781: LD_ADDR_EXP 88
53785: PUSH
53786: LD_EXP 88
53790: PPUSH
53791: LD_VAR 0 4
53795: PPUSH
53796: EMPTY
53797: PPUSH
53798: CALL_OW 1
53802: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53803: LD_ADDR_EXP 89
53807: PUSH
53808: LD_EXP 89
53812: PPUSH
53813: LD_VAR 0 4
53817: PPUSH
53818: EMPTY
53819: PPUSH
53820: CALL_OW 1
53824: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53825: LD_ADDR_EXP 90
53829: PUSH
53830: LD_EXP 90
53834: PPUSH
53835: LD_VAR 0 4
53839: PPUSH
53840: EMPTY
53841: PPUSH
53842: CALL_OW 1
53846: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53847: LD_ADDR_EXP 91
53851: PUSH
53852: LD_EXP 91
53856: PPUSH
53857: LD_VAR 0 4
53861: PPUSH
53862: EMPTY
53863: PPUSH
53864: CALL_OW 1
53868: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53869: LD_ADDR_EXP 92
53873: PUSH
53874: LD_EXP 92
53878: PPUSH
53879: LD_VAR 0 4
53883: PPUSH
53884: EMPTY
53885: PPUSH
53886: CALL_OW 1
53890: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53891: LD_ADDR_EXP 93
53895: PUSH
53896: LD_EXP 93
53900: PPUSH
53901: LD_VAR 0 4
53905: PPUSH
53906: EMPTY
53907: PPUSH
53908: CALL_OW 1
53912: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53913: LD_ADDR_EXP 94
53917: PUSH
53918: LD_EXP 94
53922: PPUSH
53923: LD_VAR 0 4
53927: PPUSH
53928: EMPTY
53929: PPUSH
53930: CALL_OW 1
53934: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53935: LD_ADDR_EXP 95
53939: PUSH
53940: LD_EXP 95
53944: PPUSH
53945: LD_VAR 0 4
53949: PPUSH
53950: EMPTY
53951: PPUSH
53952: CALL_OW 1
53956: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53957: LD_ADDR_EXP 96
53961: PUSH
53962: LD_EXP 96
53966: PPUSH
53967: LD_VAR 0 4
53971: PPUSH
53972: EMPTY
53973: PPUSH
53974: CALL_OW 1
53978: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53979: LD_ADDR_EXP 97
53983: PUSH
53984: LD_EXP 97
53988: PPUSH
53989: LD_VAR 0 4
53993: PPUSH
53994: EMPTY
53995: PPUSH
53996: CALL_OW 1
54000: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54001: LD_ADDR_EXP 98
54005: PUSH
54006: LD_EXP 98
54010: PPUSH
54011: LD_VAR 0 4
54015: PPUSH
54016: EMPTY
54017: PPUSH
54018: CALL_OW 1
54022: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54023: LD_ADDR_EXP 99
54027: PUSH
54028: LD_EXP 99
54032: PPUSH
54033: LD_VAR 0 4
54037: PPUSH
54038: EMPTY
54039: PPUSH
54040: CALL_OW 1
54044: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54045: LD_ADDR_EXP 100
54049: PUSH
54050: LD_EXP 100
54054: PPUSH
54055: LD_VAR 0 4
54059: PPUSH
54060: EMPTY
54061: PPUSH
54062: CALL_OW 1
54066: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54067: LD_ADDR_EXP 101
54071: PUSH
54072: LD_EXP 101
54076: PPUSH
54077: LD_VAR 0 4
54081: PPUSH
54082: LD_INT 0
54084: PPUSH
54085: CALL_OW 1
54089: ST_TO_ADDR
// result := base ;
54090: LD_ADDR_VAR 0 3
54094: PUSH
54095: LD_VAR 0 4
54099: ST_TO_ADDR
// end ;
54100: LD_VAR 0 3
54104: RET
// export function MC_Start ( ) ; var i ; begin
54105: LD_INT 0
54107: PPUSH
54108: PPUSH
// for i = 1 to mc_bases do
54109: LD_ADDR_VAR 0 2
54113: PUSH
54114: DOUBLE
54115: LD_INT 1
54117: DEC
54118: ST_TO_ADDR
54119: LD_EXP 59
54123: PUSH
54124: FOR_TO
54125: IFFALSE 55202
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54127: LD_ADDR_EXP 59
54131: PUSH
54132: LD_EXP 59
54136: PPUSH
54137: LD_VAR 0 2
54141: PPUSH
54142: LD_EXP 59
54146: PUSH
54147: LD_VAR 0 2
54151: ARRAY
54152: PUSH
54153: LD_INT 0
54155: DIFF
54156: PPUSH
54157: CALL_OW 1
54161: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54162: LD_ADDR_EXP 60
54166: PUSH
54167: LD_EXP 60
54171: PPUSH
54172: LD_VAR 0 2
54176: PPUSH
54177: EMPTY
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54184: LD_ADDR_EXP 61
54188: PUSH
54189: LD_EXP 61
54193: PPUSH
54194: LD_VAR 0 2
54198: PPUSH
54199: EMPTY
54200: PPUSH
54201: CALL_OW 1
54205: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54206: LD_ADDR_EXP 62
54210: PUSH
54211: LD_EXP 62
54215: PPUSH
54216: LD_VAR 0 2
54220: PPUSH
54221: EMPTY
54222: PPUSH
54223: CALL_OW 1
54227: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54228: LD_ADDR_EXP 63
54232: PUSH
54233: LD_EXP 63
54237: PPUSH
54238: LD_VAR 0 2
54242: PPUSH
54243: EMPTY
54244: PUSH
54245: EMPTY
54246: PUSH
54247: EMPTY
54248: LIST
54249: LIST
54250: PPUSH
54251: CALL_OW 1
54255: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54256: LD_ADDR_EXP 64
54260: PUSH
54261: LD_EXP 64
54265: PPUSH
54266: LD_VAR 0 2
54270: PPUSH
54271: EMPTY
54272: PPUSH
54273: CALL_OW 1
54277: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54278: LD_ADDR_EXP 91
54282: PUSH
54283: LD_EXP 91
54287: PPUSH
54288: LD_VAR 0 2
54292: PPUSH
54293: EMPTY
54294: PPUSH
54295: CALL_OW 1
54299: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54300: LD_ADDR_EXP 65
54304: PUSH
54305: LD_EXP 65
54309: PPUSH
54310: LD_VAR 0 2
54314: PPUSH
54315: EMPTY
54316: PPUSH
54317: CALL_OW 1
54321: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54322: LD_ADDR_EXP 66
54326: PUSH
54327: LD_EXP 66
54331: PPUSH
54332: LD_VAR 0 2
54336: PPUSH
54337: EMPTY
54338: PPUSH
54339: CALL_OW 1
54343: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54344: LD_ADDR_EXP 67
54348: PUSH
54349: LD_EXP 67
54353: PPUSH
54354: LD_VAR 0 2
54358: PPUSH
54359: LD_EXP 59
54363: PUSH
54364: LD_VAR 0 2
54368: ARRAY
54369: PPUSH
54370: LD_INT 2
54372: PUSH
54373: LD_INT 30
54375: PUSH
54376: LD_INT 32
54378: PUSH
54379: EMPTY
54380: LIST
54381: LIST
54382: PUSH
54383: LD_INT 30
54385: PUSH
54386: LD_INT 33
54388: PUSH
54389: EMPTY
54390: LIST
54391: LIST
54392: PUSH
54393: EMPTY
54394: LIST
54395: LIST
54396: LIST
54397: PPUSH
54398: CALL_OW 72
54402: PPUSH
54403: CALL_OW 1
54407: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54408: LD_ADDR_EXP 68
54412: PUSH
54413: LD_EXP 68
54417: PPUSH
54418: LD_VAR 0 2
54422: PPUSH
54423: LD_EXP 59
54427: PUSH
54428: LD_VAR 0 2
54432: ARRAY
54433: PPUSH
54434: LD_INT 2
54436: PUSH
54437: LD_INT 30
54439: PUSH
54440: LD_INT 32
54442: PUSH
54443: EMPTY
54444: LIST
54445: LIST
54446: PUSH
54447: LD_INT 30
54449: PUSH
54450: LD_INT 31
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: PUSH
54457: EMPTY
54458: LIST
54459: LIST
54460: LIST
54461: PUSH
54462: LD_INT 58
54464: PUSH
54465: EMPTY
54466: LIST
54467: PUSH
54468: EMPTY
54469: LIST
54470: LIST
54471: PPUSH
54472: CALL_OW 72
54476: PPUSH
54477: CALL_OW 1
54481: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54482: LD_ADDR_EXP 69
54486: PUSH
54487: LD_EXP 69
54491: PPUSH
54492: LD_VAR 0 2
54496: PPUSH
54497: EMPTY
54498: PPUSH
54499: CALL_OW 1
54503: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54504: LD_ADDR_EXP 73
54508: PUSH
54509: LD_EXP 73
54513: PPUSH
54514: LD_VAR 0 2
54518: PPUSH
54519: EMPTY
54520: PPUSH
54521: CALL_OW 1
54525: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54526: LD_ADDR_EXP 72
54530: PUSH
54531: LD_EXP 72
54535: PPUSH
54536: LD_VAR 0 2
54540: PPUSH
54541: EMPTY
54542: PPUSH
54543: CALL_OW 1
54547: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54548: LD_ADDR_EXP 74
54552: PUSH
54553: LD_EXP 74
54557: PPUSH
54558: LD_VAR 0 2
54562: PPUSH
54563: EMPTY
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54570: LD_ADDR_EXP 75
54574: PUSH
54575: LD_EXP 75
54579: PPUSH
54580: LD_VAR 0 2
54584: PPUSH
54585: EMPTY
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54592: LD_ADDR_EXP 76
54596: PUSH
54597: LD_EXP 76
54601: PPUSH
54602: LD_VAR 0 2
54606: PPUSH
54607: EMPTY
54608: PPUSH
54609: CALL_OW 1
54613: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54614: LD_ADDR_EXP 77
54618: PUSH
54619: LD_EXP 77
54623: PPUSH
54624: LD_VAR 0 2
54628: PPUSH
54629: EMPTY
54630: PPUSH
54631: CALL_OW 1
54635: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54636: LD_ADDR_EXP 78
54640: PUSH
54641: LD_EXP 78
54645: PPUSH
54646: LD_VAR 0 2
54650: PPUSH
54651: EMPTY
54652: PPUSH
54653: CALL_OW 1
54657: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54658: LD_ADDR_EXP 79
54662: PUSH
54663: LD_EXP 79
54667: PPUSH
54668: LD_VAR 0 2
54672: PPUSH
54673: EMPTY
54674: PPUSH
54675: CALL_OW 1
54679: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54680: LD_ADDR_EXP 80
54684: PUSH
54685: LD_EXP 80
54689: PPUSH
54690: LD_VAR 0 2
54694: PPUSH
54695: EMPTY
54696: PPUSH
54697: CALL_OW 1
54701: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54702: LD_ADDR_EXP 81
54706: PUSH
54707: LD_EXP 81
54711: PPUSH
54712: LD_VAR 0 2
54716: PPUSH
54717: EMPTY
54718: PPUSH
54719: CALL_OW 1
54723: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54724: LD_ADDR_EXP 70
54728: PUSH
54729: LD_EXP 70
54733: PPUSH
54734: LD_VAR 0 2
54738: PPUSH
54739: LD_INT 0
54741: PPUSH
54742: CALL_OW 1
54746: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54747: LD_ADDR_EXP 83
54751: PUSH
54752: LD_EXP 83
54756: PPUSH
54757: LD_VAR 0 2
54761: PPUSH
54762: LD_INT 0
54764: PPUSH
54765: CALL_OW 1
54769: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54770: LD_ADDR_EXP 71
54774: PUSH
54775: LD_EXP 71
54779: PPUSH
54780: LD_VAR 0 2
54784: PPUSH
54785: EMPTY
54786: PPUSH
54787: CALL_OW 1
54791: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54792: LD_ADDR_EXP 82
54796: PUSH
54797: LD_EXP 82
54801: PPUSH
54802: LD_VAR 0 2
54806: PPUSH
54807: LD_INT 0
54809: PPUSH
54810: CALL_OW 1
54814: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54815: LD_ADDR_EXP 84
54819: PUSH
54820: LD_EXP 84
54824: PPUSH
54825: LD_VAR 0 2
54829: PPUSH
54830: EMPTY
54831: PPUSH
54832: CALL_OW 1
54836: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54837: LD_ADDR_EXP 87
54841: PUSH
54842: LD_EXP 87
54846: PPUSH
54847: LD_VAR 0 2
54851: PPUSH
54852: LD_INT 0
54854: PPUSH
54855: CALL_OW 1
54859: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54860: LD_ADDR_EXP 88
54864: PUSH
54865: LD_EXP 88
54869: PPUSH
54870: LD_VAR 0 2
54874: PPUSH
54875: EMPTY
54876: PPUSH
54877: CALL_OW 1
54881: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54882: LD_ADDR_EXP 89
54886: PUSH
54887: LD_EXP 89
54891: PPUSH
54892: LD_VAR 0 2
54896: PPUSH
54897: EMPTY
54898: PPUSH
54899: CALL_OW 1
54903: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54904: LD_ADDR_EXP 90
54908: PUSH
54909: LD_EXP 90
54913: PPUSH
54914: LD_VAR 0 2
54918: PPUSH
54919: EMPTY
54920: PPUSH
54921: CALL_OW 1
54925: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54926: LD_ADDR_EXP 92
54930: PUSH
54931: LD_EXP 92
54935: PPUSH
54936: LD_VAR 0 2
54940: PPUSH
54941: LD_EXP 59
54945: PUSH
54946: LD_VAR 0 2
54950: ARRAY
54951: PPUSH
54952: LD_INT 2
54954: PUSH
54955: LD_INT 30
54957: PUSH
54958: LD_INT 6
54960: PUSH
54961: EMPTY
54962: LIST
54963: LIST
54964: PUSH
54965: LD_INT 30
54967: PUSH
54968: LD_INT 7
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: PUSH
54975: LD_INT 30
54977: PUSH
54978: LD_INT 8
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PUSH
54985: EMPTY
54986: LIST
54987: LIST
54988: LIST
54989: LIST
54990: PPUSH
54991: CALL_OW 72
54995: PPUSH
54996: CALL_OW 1
55000: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55001: LD_ADDR_EXP 93
55005: PUSH
55006: LD_EXP 93
55010: PPUSH
55011: LD_VAR 0 2
55015: PPUSH
55016: EMPTY
55017: PPUSH
55018: CALL_OW 1
55022: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55023: LD_ADDR_EXP 94
55027: PUSH
55028: LD_EXP 94
55032: PPUSH
55033: LD_VAR 0 2
55037: PPUSH
55038: EMPTY
55039: PPUSH
55040: CALL_OW 1
55044: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55045: LD_ADDR_EXP 95
55049: PUSH
55050: LD_EXP 95
55054: PPUSH
55055: LD_VAR 0 2
55059: PPUSH
55060: EMPTY
55061: PPUSH
55062: CALL_OW 1
55066: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55067: LD_ADDR_EXP 96
55071: PUSH
55072: LD_EXP 96
55076: PPUSH
55077: LD_VAR 0 2
55081: PPUSH
55082: EMPTY
55083: PPUSH
55084: CALL_OW 1
55088: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55089: LD_ADDR_EXP 97
55093: PUSH
55094: LD_EXP 97
55098: PPUSH
55099: LD_VAR 0 2
55103: PPUSH
55104: EMPTY
55105: PPUSH
55106: CALL_OW 1
55110: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55111: LD_ADDR_EXP 98
55115: PUSH
55116: LD_EXP 98
55120: PPUSH
55121: LD_VAR 0 2
55125: PPUSH
55126: EMPTY
55127: PPUSH
55128: CALL_OW 1
55132: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55133: LD_ADDR_EXP 99
55137: PUSH
55138: LD_EXP 99
55142: PPUSH
55143: LD_VAR 0 2
55147: PPUSH
55148: EMPTY
55149: PPUSH
55150: CALL_OW 1
55154: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55155: LD_ADDR_EXP 100
55159: PUSH
55160: LD_EXP 100
55164: PPUSH
55165: LD_VAR 0 2
55169: PPUSH
55170: EMPTY
55171: PPUSH
55172: CALL_OW 1
55176: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55177: LD_ADDR_EXP 101
55181: PUSH
55182: LD_EXP 101
55186: PPUSH
55187: LD_VAR 0 2
55191: PPUSH
55192: LD_INT 0
55194: PPUSH
55195: CALL_OW 1
55199: ST_TO_ADDR
// end ;
55200: GO 54124
55202: POP
55203: POP
// MC_InitSides ( ) ;
55204: CALL 55490 0 0
// MC_InitResearch ( ) ;
55208: CALL 55229 0 0
// CustomInitMacro ( ) ;
55212: CALL 185 0 0
// skirmish := true ;
55216: LD_ADDR_EXP 57
55220: PUSH
55221: LD_INT 1
55223: ST_TO_ADDR
// end ;
55224: LD_VAR 0 1
55228: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55229: LD_INT 0
55231: PPUSH
55232: PPUSH
55233: PPUSH
55234: PPUSH
55235: PPUSH
55236: PPUSH
// if not mc_bases then
55237: LD_EXP 59
55241: NOT
55242: IFFALSE 55246
// exit ;
55244: GO 55485
// for i = 1 to 8 do
55246: LD_ADDR_VAR 0 2
55250: PUSH
55251: DOUBLE
55252: LD_INT 1
55254: DEC
55255: ST_TO_ADDR
55256: LD_INT 8
55258: PUSH
55259: FOR_TO
55260: IFFALSE 55286
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55262: LD_ADDR_EXP 86
55266: PUSH
55267: LD_EXP 86
55271: PPUSH
55272: LD_VAR 0 2
55276: PPUSH
55277: EMPTY
55278: PPUSH
55279: CALL_OW 1
55283: ST_TO_ADDR
55284: GO 55259
55286: POP
55287: POP
// tmp := [ ] ;
55288: LD_ADDR_VAR 0 5
55292: PUSH
55293: EMPTY
55294: ST_TO_ADDR
// for i = 1 to mc_sides do
55295: LD_ADDR_VAR 0 2
55299: PUSH
55300: DOUBLE
55301: LD_INT 1
55303: DEC
55304: ST_TO_ADDR
55305: LD_EXP 85
55309: PUSH
55310: FOR_TO
55311: IFFALSE 55369
// if not mc_sides [ i ] in tmp then
55313: LD_EXP 85
55317: PUSH
55318: LD_VAR 0 2
55322: ARRAY
55323: PUSH
55324: LD_VAR 0 5
55328: IN
55329: NOT
55330: IFFALSE 55367
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55332: LD_ADDR_VAR 0 5
55336: PUSH
55337: LD_VAR 0 5
55341: PPUSH
55342: LD_VAR 0 5
55346: PUSH
55347: LD_INT 1
55349: PLUS
55350: PPUSH
55351: LD_EXP 85
55355: PUSH
55356: LD_VAR 0 2
55360: ARRAY
55361: PPUSH
55362: CALL_OW 2
55366: ST_TO_ADDR
55367: GO 55310
55369: POP
55370: POP
// if not tmp then
55371: LD_VAR 0 5
55375: NOT
55376: IFFALSE 55380
// exit ;
55378: GO 55485
// for j in tmp do
55380: LD_ADDR_VAR 0 3
55384: PUSH
55385: LD_VAR 0 5
55389: PUSH
55390: FOR_IN
55391: IFFALSE 55483
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55393: LD_ADDR_VAR 0 6
55397: PUSH
55398: LD_INT 22
55400: PUSH
55401: LD_VAR 0 3
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PPUSH
55410: CALL_OW 69
55414: ST_TO_ADDR
// if not un then
55415: LD_VAR 0 6
55419: NOT
55420: IFFALSE 55424
// continue ;
55422: GO 55390
// nation := GetNation ( un [ 1 ] ) ;
55424: LD_ADDR_VAR 0 4
55428: PUSH
55429: LD_VAR 0 6
55433: PUSH
55434: LD_INT 1
55436: ARRAY
55437: PPUSH
55438: CALL_OW 248
55442: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55443: LD_ADDR_EXP 86
55447: PUSH
55448: LD_EXP 86
55452: PPUSH
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_VAR 0 3
55462: PPUSH
55463: LD_VAR 0 4
55467: PPUSH
55468: LD_INT 1
55470: PPUSH
55471: CALL 14400 0 3
55475: PPUSH
55476: CALL_OW 1
55480: ST_TO_ADDR
// end ;
55481: GO 55390
55483: POP
55484: POP
// end ;
55485: LD_VAR 0 1
55489: RET
// export function MC_InitSides ( ) ; var i ; begin
55490: LD_INT 0
55492: PPUSH
55493: PPUSH
// if not mc_bases then
55494: LD_EXP 59
55498: NOT
55499: IFFALSE 55503
// exit ;
55501: GO 55577
// for i = 1 to mc_bases do
55503: LD_ADDR_VAR 0 2
55507: PUSH
55508: DOUBLE
55509: LD_INT 1
55511: DEC
55512: ST_TO_ADDR
55513: LD_EXP 59
55517: PUSH
55518: FOR_TO
55519: IFFALSE 55575
// if mc_bases [ i ] then
55521: LD_EXP 59
55525: PUSH
55526: LD_VAR 0 2
55530: ARRAY
55531: IFFALSE 55573
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55533: LD_ADDR_EXP 85
55537: PUSH
55538: LD_EXP 85
55542: PPUSH
55543: LD_VAR 0 2
55547: PPUSH
55548: LD_EXP 59
55552: PUSH
55553: LD_VAR 0 2
55557: ARRAY
55558: PUSH
55559: LD_INT 1
55561: ARRAY
55562: PPUSH
55563: CALL_OW 255
55567: PPUSH
55568: CALL_OW 1
55572: ST_TO_ADDR
55573: GO 55518
55575: POP
55576: POP
// end ;
55577: LD_VAR 0 1
55581: RET
// every 0 0$03 trigger skirmish do
55582: LD_EXP 57
55586: IFFALSE 55740
55588: GO 55590
55590: DISABLE
// begin enable ;
55591: ENABLE
// MC_CheckBuildings ( ) ;
55592: CALL 60238 0 0
// MC_CheckPeopleLife ( ) ;
55596: CALL 60363 0 0
// RaiseSailEvent ( 100 ) ;
55600: LD_INT 100
55602: PPUSH
55603: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55607: LD_INT 103
55609: PPUSH
55610: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55614: LD_INT 104
55616: PPUSH
55617: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55621: LD_INT 105
55623: PPUSH
55624: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55628: LD_INT 106
55630: PPUSH
55631: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55635: LD_INT 107
55637: PPUSH
55638: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55642: LD_INT 108
55644: PPUSH
55645: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55649: LD_INT 109
55651: PPUSH
55652: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55656: LD_INT 110
55658: PPUSH
55659: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55663: LD_INT 111
55665: PPUSH
55666: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55670: LD_INT 112
55672: PPUSH
55673: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55677: LD_INT 113
55679: PPUSH
55680: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55684: LD_INT 120
55686: PPUSH
55687: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55691: LD_INT 121
55693: PPUSH
55694: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55698: LD_INT 122
55700: PPUSH
55701: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55705: LD_INT 123
55707: PPUSH
55708: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55712: LD_INT 124
55714: PPUSH
55715: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55719: LD_INT 125
55721: PPUSH
55722: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55726: LD_INT 126
55728: PPUSH
55729: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55733: LD_INT 200
55735: PPUSH
55736: CALL_OW 427
// end ;
55740: END
// on SailEvent ( event ) do begin if event < 100 then
55741: LD_VAR 0 1
55745: PUSH
55746: LD_INT 100
55748: LESS
55749: IFFALSE 55760
// CustomEvent ( event ) ;
55751: LD_VAR 0 1
55755: PPUSH
55756: CALL 13058 0 1
// if event = 100 then
55760: LD_VAR 0 1
55764: PUSH
55765: LD_INT 100
55767: EQUAL
55768: IFFALSE 55774
// MC_ClassManager ( ) ;
55770: CALL 56166 0 0
// if event = 101 then
55774: LD_VAR 0 1
55778: PUSH
55779: LD_INT 101
55781: EQUAL
55782: IFFALSE 55788
// MC_RepairBuildings ( ) ;
55784: CALL 60948 0 0
// if event = 102 then
55788: LD_VAR 0 1
55792: PUSH
55793: LD_INT 102
55795: EQUAL
55796: IFFALSE 55802
// MC_Heal ( ) ;
55798: CALL 61833 0 0
// if event = 103 then
55802: LD_VAR 0 1
55806: PUSH
55807: LD_INT 103
55809: EQUAL
55810: IFFALSE 55816
// MC_Build ( ) ;
55812: CALL 62255 0 0
// if event = 104 then
55816: LD_VAR 0 1
55820: PUSH
55821: LD_INT 104
55823: EQUAL
55824: IFFALSE 55830
// MC_TurretWeapon ( ) ;
55826: CALL 63896 0 0
// if event = 105 then
55830: LD_VAR 0 1
55834: PUSH
55835: LD_INT 105
55837: EQUAL
55838: IFFALSE 55844
// MC_BuildUpgrade ( ) ;
55840: CALL 63447 0 0
// if event = 106 then
55844: LD_VAR 0 1
55848: PUSH
55849: LD_INT 106
55851: EQUAL
55852: IFFALSE 55858
// MC_PlantMines ( ) ;
55854: CALL 64326 0 0
// if event = 107 then
55858: LD_VAR 0 1
55862: PUSH
55863: LD_INT 107
55865: EQUAL
55866: IFFALSE 55872
// MC_CollectCrates ( ) ;
55868: CALL 65117 0 0
// if event = 108 then
55872: LD_VAR 0 1
55876: PUSH
55877: LD_INT 108
55879: EQUAL
55880: IFFALSE 55886
// MC_LinkRemoteControl ( ) ;
55882: CALL 66893 0 0
// if event = 109 then
55886: LD_VAR 0 1
55890: PUSH
55891: LD_INT 109
55893: EQUAL
55894: IFFALSE 55900
// MC_ProduceVehicle ( ) ;
55896: CALL 67074 0 0
// if event = 110 then
55900: LD_VAR 0 1
55904: PUSH
55905: LD_INT 110
55907: EQUAL
55908: IFFALSE 55914
// MC_SendAttack ( ) ;
55910: CALL 67540 0 0
// if event = 111 then
55914: LD_VAR 0 1
55918: PUSH
55919: LD_INT 111
55921: EQUAL
55922: IFFALSE 55928
// MC_Defend ( ) ;
55924: CALL 67648 0 0
// if event = 112 then
55928: LD_VAR 0 1
55932: PUSH
55933: LD_INT 112
55935: EQUAL
55936: IFFALSE 55942
// MC_Research ( ) ;
55938: CALL 68275 0 0
// if event = 113 then
55942: LD_VAR 0 1
55946: PUSH
55947: LD_INT 113
55949: EQUAL
55950: IFFALSE 55956
// MC_MinesTrigger ( ) ;
55952: CALL 69389 0 0
// if event = 120 then
55956: LD_VAR 0 1
55960: PUSH
55961: LD_INT 120
55963: EQUAL
55964: IFFALSE 55970
// MC_RepairVehicle ( ) ;
55966: CALL 69488 0 0
// if event = 121 then
55970: LD_VAR 0 1
55974: PUSH
55975: LD_INT 121
55977: EQUAL
55978: IFFALSE 55984
// MC_TameApe ( ) ;
55980: CALL 70218 0 0
// if event = 122 then
55984: LD_VAR 0 1
55988: PUSH
55989: LD_INT 122
55991: EQUAL
55992: IFFALSE 55998
// MC_ChangeApeClass ( ) ;
55994: CALL 71047 0 0
// if event = 123 then
55998: LD_VAR 0 1
56002: PUSH
56003: LD_INT 123
56005: EQUAL
56006: IFFALSE 56012
// MC_Bazooka ( ) ;
56008: CALL 71697 0 0
// if event = 124 then
56012: LD_VAR 0 1
56016: PUSH
56017: LD_INT 124
56019: EQUAL
56020: IFFALSE 56026
// MC_TeleportExit ( ) ;
56022: CALL 71895 0 0
// if event = 125 then
56026: LD_VAR 0 1
56030: PUSH
56031: LD_INT 125
56033: EQUAL
56034: IFFALSE 56040
// MC_Deposits ( ) ;
56036: CALL 72542 0 0
// if event = 126 then
56040: LD_VAR 0 1
56044: PUSH
56045: LD_INT 126
56047: EQUAL
56048: IFFALSE 56054
// MC_RemoteDriver ( ) ;
56050: CALL 73167 0 0
// if event = 200 then
56054: LD_VAR 0 1
56058: PUSH
56059: LD_INT 200
56061: EQUAL
56062: IFFALSE 56068
// MC_Idle ( ) ;
56064: CALL 75116 0 0
// end ;
56068: PPOPN 1
56070: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56071: LD_INT 0
56073: PPUSH
56074: PPUSH
// if not mc_bases [ base ] or not tag then
56075: LD_EXP 59
56079: PUSH
56080: LD_VAR 0 1
56084: ARRAY
56085: NOT
56086: PUSH
56087: LD_VAR 0 2
56091: NOT
56092: OR
56093: IFFALSE 56097
// exit ;
56095: GO 56161
// for i in mc_bases [ base ] union mc_ape [ base ] do
56097: LD_ADDR_VAR 0 4
56101: PUSH
56102: LD_EXP 59
56106: PUSH
56107: LD_VAR 0 1
56111: ARRAY
56112: PUSH
56113: LD_EXP 88
56117: PUSH
56118: LD_VAR 0 1
56122: ARRAY
56123: UNION
56124: PUSH
56125: FOR_IN
56126: IFFALSE 56159
// if GetTag ( i ) = tag then
56128: LD_VAR 0 4
56132: PPUSH
56133: CALL_OW 110
56137: PUSH
56138: LD_VAR 0 2
56142: EQUAL
56143: IFFALSE 56157
// SetTag ( i , 0 ) ;
56145: LD_VAR 0 4
56149: PPUSH
56150: LD_INT 0
56152: PPUSH
56153: CALL_OW 109
56157: GO 56125
56159: POP
56160: POP
// end ;
56161: LD_VAR 0 3
56165: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56166: LD_INT 0
56168: PPUSH
56169: PPUSH
56170: PPUSH
56171: PPUSH
56172: PPUSH
56173: PPUSH
56174: PPUSH
56175: PPUSH
// if not mc_bases then
56176: LD_EXP 59
56180: NOT
56181: IFFALSE 56185
// exit ;
56183: GO 56643
// for i = 1 to mc_bases do
56185: LD_ADDR_VAR 0 2
56189: PUSH
56190: DOUBLE
56191: LD_INT 1
56193: DEC
56194: ST_TO_ADDR
56195: LD_EXP 59
56199: PUSH
56200: FOR_TO
56201: IFFALSE 56641
// begin tmp := MC_ClassCheckReq ( i ) ;
56203: LD_ADDR_VAR 0 4
56207: PUSH
56208: LD_VAR 0 2
56212: PPUSH
56213: CALL 56648 0 1
56217: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56218: LD_ADDR_EXP 100
56222: PUSH
56223: LD_EXP 100
56227: PPUSH
56228: LD_VAR 0 2
56232: PPUSH
56233: LD_VAR 0 4
56237: PPUSH
56238: CALL_OW 1
56242: ST_TO_ADDR
// if not tmp then
56243: LD_VAR 0 4
56247: NOT
56248: IFFALSE 56252
// continue ;
56250: GO 56200
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56252: LD_ADDR_VAR 0 6
56256: PUSH
56257: LD_EXP 59
56261: PUSH
56262: LD_VAR 0 2
56266: ARRAY
56267: PPUSH
56268: LD_INT 2
56270: PUSH
56271: LD_INT 30
56273: PUSH
56274: LD_INT 4
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PUSH
56281: LD_INT 30
56283: PUSH
56284: LD_INT 5
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: LIST
56295: PPUSH
56296: CALL_OW 72
56300: PUSH
56301: LD_EXP 59
56305: PUSH
56306: LD_VAR 0 2
56310: ARRAY
56311: PPUSH
56312: LD_INT 2
56314: PUSH
56315: LD_INT 30
56317: PUSH
56318: LD_INT 0
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: LD_INT 30
56327: PUSH
56328: LD_INT 1
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: LIST
56339: PPUSH
56340: CALL_OW 72
56344: PUSH
56345: LD_EXP 59
56349: PUSH
56350: LD_VAR 0 2
56354: ARRAY
56355: PPUSH
56356: LD_INT 30
56358: PUSH
56359: LD_INT 3
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: PPUSH
56366: CALL_OW 72
56370: PUSH
56371: LD_EXP 59
56375: PUSH
56376: LD_VAR 0 2
56380: ARRAY
56381: PPUSH
56382: LD_INT 2
56384: PUSH
56385: LD_INT 30
56387: PUSH
56388: LD_INT 6
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PUSH
56395: LD_INT 30
56397: PUSH
56398: LD_INT 7
56400: PUSH
56401: EMPTY
56402: LIST
56403: LIST
56404: PUSH
56405: LD_INT 30
56407: PUSH
56408: LD_INT 8
56410: PUSH
56411: EMPTY
56412: LIST
56413: LIST
56414: PUSH
56415: EMPTY
56416: LIST
56417: LIST
56418: LIST
56419: LIST
56420: PPUSH
56421: CALL_OW 72
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: LIST
56430: LIST
56431: ST_TO_ADDR
// for j = 1 to 4 do
56432: LD_ADDR_VAR 0 3
56436: PUSH
56437: DOUBLE
56438: LD_INT 1
56440: DEC
56441: ST_TO_ADDR
56442: LD_INT 4
56444: PUSH
56445: FOR_TO
56446: IFFALSE 56637
// begin if not tmp [ j ] then
56448: LD_VAR 0 4
56452: PUSH
56453: LD_VAR 0 3
56457: ARRAY
56458: NOT
56459: IFFALSE 56463
// continue ;
56461: GO 56445
// for p in tmp [ j ] do
56463: LD_ADDR_VAR 0 5
56467: PUSH
56468: LD_VAR 0 4
56472: PUSH
56473: LD_VAR 0 3
56477: ARRAY
56478: PUSH
56479: FOR_IN
56480: IFFALSE 56633
// begin if not b [ j ] then
56482: LD_VAR 0 6
56486: PUSH
56487: LD_VAR 0 3
56491: ARRAY
56492: NOT
56493: IFFALSE 56497
// break ;
56495: GO 56633
// e := 0 ;
56497: LD_ADDR_VAR 0 7
56501: PUSH
56502: LD_INT 0
56504: ST_TO_ADDR
// for k in b [ j ] do
56505: LD_ADDR_VAR 0 8
56509: PUSH
56510: LD_VAR 0 6
56514: PUSH
56515: LD_VAR 0 3
56519: ARRAY
56520: PUSH
56521: FOR_IN
56522: IFFALSE 56549
// if IsNotFull ( k ) then
56524: LD_VAR 0 8
56528: PPUSH
56529: CALL 16549 0 1
56533: IFFALSE 56547
// begin e := k ;
56535: LD_ADDR_VAR 0 7
56539: PUSH
56540: LD_VAR 0 8
56544: ST_TO_ADDR
// break ;
56545: GO 56549
// end ;
56547: GO 56521
56549: POP
56550: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56551: LD_VAR 0 7
56555: PUSH
56556: LD_VAR 0 5
56560: PPUSH
56561: LD_VAR 0 7
56565: PPUSH
56566: CALL 49302 0 2
56570: NOT
56571: AND
56572: IFFALSE 56631
// begin if IsInUnit ( p ) then
56574: LD_VAR 0 5
56578: PPUSH
56579: CALL_OW 310
56583: IFFALSE 56594
// ComExitBuilding ( p ) ;
56585: LD_VAR 0 5
56589: PPUSH
56590: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56594: LD_VAR 0 5
56598: PPUSH
56599: LD_VAR 0 7
56603: PPUSH
56604: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56608: LD_VAR 0 5
56612: PPUSH
56613: LD_VAR 0 3
56617: PPUSH
56618: CALL_OW 183
// AddComExitBuilding ( p ) ;
56622: LD_VAR 0 5
56626: PPUSH
56627: CALL_OW 182
// end ; end ;
56631: GO 56479
56633: POP
56634: POP
// end ;
56635: GO 56445
56637: POP
56638: POP
// end ;
56639: GO 56200
56641: POP
56642: POP
// end ;
56643: LD_VAR 0 1
56647: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56648: LD_INT 0
56650: PPUSH
56651: PPUSH
56652: PPUSH
56653: PPUSH
56654: PPUSH
56655: PPUSH
56656: PPUSH
56657: PPUSH
56658: PPUSH
56659: PPUSH
56660: PPUSH
56661: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56662: LD_VAR 0 1
56666: NOT
56667: PUSH
56668: LD_EXP 59
56672: PUSH
56673: LD_VAR 0 1
56677: ARRAY
56678: NOT
56679: OR
56680: PUSH
56681: LD_EXP 59
56685: PUSH
56686: LD_VAR 0 1
56690: ARRAY
56691: PPUSH
56692: LD_INT 2
56694: PUSH
56695: LD_INT 30
56697: PUSH
56698: LD_INT 0
56700: PUSH
56701: EMPTY
56702: LIST
56703: LIST
56704: PUSH
56705: LD_INT 30
56707: PUSH
56708: LD_INT 1
56710: PUSH
56711: EMPTY
56712: LIST
56713: LIST
56714: PUSH
56715: EMPTY
56716: LIST
56717: LIST
56718: LIST
56719: PPUSH
56720: CALL_OW 72
56724: NOT
56725: OR
56726: IFFALSE 56730
// exit ;
56728: GO 60233
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56730: LD_ADDR_VAR 0 4
56734: PUSH
56735: LD_EXP 59
56739: PUSH
56740: LD_VAR 0 1
56744: ARRAY
56745: PPUSH
56746: LD_INT 2
56748: PUSH
56749: LD_INT 25
56751: PUSH
56752: LD_INT 1
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: PUSH
56759: LD_INT 25
56761: PUSH
56762: LD_INT 2
56764: PUSH
56765: EMPTY
56766: LIST
56767: LIST
56768: PUSH
56769: LD_INT 25
56771: PUSH
56772: LD_INT 3
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PUSH
56779: LD_INT 25
56781: PUSH
56782: LD_INT 4
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PUSH
56789: LD_INT 25
56791: PUSH
56792: LD_INT 5
56794: PUSH
56795: EMPTY
56796: LIST
56797: LIST
56798: PUSH
56799: LD_INT 25
56801: PUSH
56802: LD_INT 8
56804: PUSH
56805: EMPTY
56806: LIST
56807: LIST
56808: PUSH
56809: LD_INT 25
56811: PUSH
56812: LD_INT 9
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PUSH
56819: EMPTY
56820: LIST
56821: LIST
56822: LIST
56823: LIST
56824: LIST
56825: LIST
56826: LIST
56827: LIST
56828: PPUSH
56829: CALL_OW 72
56833: ST_TO_ADDR
// if not tmp then
56834: LD_VAR 0 4
56838: NOT
56839: IFFALSE 56843
// exit ;
56841: GO 60233
// for i in tmp do
56843: LD_ADDR_VAR 0 3
56847: PUSH
56848: LD_VAR 0 4
56852: PUSH
56853: FOR_IN
56854: IFFALSE 56885
// if GetTag ( i ) then
56856: LD_VAR 0 3
56860: PPUSH
56861: CALL_OW 110
56865: IFFALSE 56883
// tmp := tmp diff i ;
56867: LD_ADDR_VAR 0 4
56871: PUSH
56872: LD_VAR 0 4
56876: PUSH
56877: LD_VAR 0 3
56881: DIFF
56882: ST_TO_ADDR
56883: GO 56853
56885: POP
56886: POP
// if not tmp then
56887: LD_VAR 0 4
56891: NOT
56892: IFFALSE 56896
// exit ;
56894: GO 60233
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56896: LD_ADDR_VAR 0 5
56900: PUSH
56901: LD_EXP 59
56905: PUSH
56906: LD_VAR 0 1
56910: ARRAY
56911: PPUSH
56912: LD_INT 2
56914: PUSH
56915: LD_INT 25
56917: PUSH
56918: LD_INT 1
56920: PUSH
56921: EMPTY
56922: LIST
56923: LIST
56924: PUSH
56925: LD_INT 25
56927: PUSH
56928: LD_INT 5
56930: PUSH
56931: EMPTY
56932: LIST
56933: LIST
56934: PUSH
56935: LD_INT 25
56937: PUSH
56938: LD_INT 8
56940: PUSH
56941: EMPTY
56942: LIST
56943: LIST
56944: PUSH
56945: LD_INT 25
56947: PUSH
56948: LD_INT 9
56950: PUSH
56951: EMPTY
56952: LIST
56953: LIST
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: LIST
56959: LIST
56960: LIST
56961: PPUSH
56962: CALL_OW 72
56966: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56967: LD_ADDR_VAR 0 6
56971: PUSH
56972: LD_EXP 59
56976: PUSH
56977: LD_VAR 0 1
56981: ARRAY
56982: PPUSH
56983: LD_INT 25
56985: PUSH
56986: LD_INT 2
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: PPUSH
56993: CALL_OW 72
56997: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56998: LD_ADDR_VAR 0 7
57002: PUSH
57003: LD_EXP 59
57007: PUSH
57008: LD_VAR 0 1
57012: ARRAY
57013: PPUSH
57014: LD_INT 25
57016: PUSH
57017: LD_INT 3
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: PPUSH
57024: CALL_OW 72
57028: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57029: LD_ADDR_VAR 0 8
57033: PUSH
57034: LD_EXP 59
57038: PUSH
57039: LD_VAR 0 1
57043: ARRAY
57044: PPUSH
57045: LD_INT 25
57047: PUSH
57048: LD_INT 4
57050: PUSH
57051: EMPTY
57052: LIST
57053: LIST
57054: PUSH
57055: LD_INT 24
57057: PUSH
57058: LD_INT 251
57060: PUSH
57061: EMPTY
57062: LIST
57063: LIST
57064: PUSH
57065: EMPTY
57066: LIST
57067: LIST
57068: PPUSH
57069: CALL_OW 72
57073: ST_TO_ADDR
// if mc_scan [ base ] then
57074: LD_EXP 82
57078: PUSH
57079: LD_VAR 0 1
57083: ARRAY
57084: IFFALSE 57545
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57086: LD_ADDR_EXP 101
57090: PUSH
57091: LD_EXP 101
57095: PPUSH
57096: LD_VAR 0 1
57100: PPUSH
57101: LD_INT 4
57103: PPUSH
57104: CALL_OW 1
57108: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57109: LD_ADDR_VAR 0 12
57113: PUSH
57114: LD_EXP 59
57118: PUSH
57119: LD_VAR 0 1
57123: ARRAY
57124: PPUSH
57125: LD_INT 2
57127: PUSH
57128: LD_INT 30
57130: PUSH
57131: LD_INT 4
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: PUSH
57138: LD_INT 30
57140: PUSH
57141: LD_INT 5
57143: PUSH
57144: EMPTY
57145: LIST
57146: LIST
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: LIST
57152: PPUSH
57153: CALL_OW 72
57157: ST_TO_ADDR
// if not b then
57158: LD_VAR 0 12
57162: NOT
57163: IFFALSE 57167
// exit ;
57165: GO 60233
// p := [ ] ;
57167: LD_ADDR_VAR 0 11
57171: PUSH
57172: EMPTY
57173: ST_TO_ADDR
// if sci >= 2 then
57174: LD_VAR 0 8
57178: PUSH
57179: LD_INT 2
57181: GREATEREQUAL
57182: IFFALSE 57213
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57184: LD_ADDR_VAR 0 8
57188: PUSH
57189: LD_VAR 0 8
57193: PUSH
57194: LD_INT 1
57196: ARRAY
57197: PUSH
57198: LD_VAR 0 8
57202: PUSH
57203: LD_INT 2
57205: ARRAY
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: ST_TO_ADDR
57211: GO 57274
// if sci = 1 then
57213: LD_VAR 0 8
57217: PUSH
57218: LD_INT 1
57220: EQUAL
57221: IFFALSE 57242
// sci := [ sci [ 1 ] ] else
57223: LD_ADDR_VAR 0 8
57227: PUSH
57228: LD_VAR 0 8
57232: PUSH
57233: LD_INT 1
57235: ARRAY
57236: PUSH
57237: EMPTY
57238: LIST
57239: ST_TO_ADDR
57240: GO 57274
// if sci = 0 then
57242: LD_VAR 0 8
57246: PUSH
57247: LD_INT 0
57249: EQUAL
57250: IFFALSE 57274
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57252: LD_ADDR_VAR 0 11
57256: PUSH
57257: LD_VAR 0 4
57261: PPUSH
57262: LD_INT 4
57264: PPUSH
57265: CALL 49165 0 2
57269: PUSH
57270: LD_INT 1
57272: ARRAY
57273: ST_TO_ADDR
// if eng > 4 then
57274: LD_VAR 0 6
57278: PUSH
57279: LD_INT 4
57281: GREATER
57282: IFFALSE 57328
// for i = eng downto 4 do
57284: LD_ADDR_VAR 0 3
57288: PUSH
57289: DOUBLE
57290: LD_VAR 0 6
57294: INC
57295: ST_TO_ADDR
57296: LD_INT 4
57298: PUSH
57299: FOR_DOWNTO
57300: IFFALSE 57326
// eng := eng diff eng [ i ] ;
57302: LD_ADDR_VAR 0 6
57306: PUSH
57307: LD_VAR 0 6
57311: PUSH
57312: LD_VAR 0 6
57316: PUSH
57317: LD_VAR 0 3
57321: ARRAY
57322: DIFF
57323: ST_TO_ADDR
57324: GO 57299
57326: POP
57327: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57328: LD_ADDR_VAR 0 4
57332: PUSH
57333: LD_VAR 0 4
57337: PUSH
57338: LD_VAR 0 5
57342: PUSH
57343: LD_VAR 0 6
57347: UNION
57348: PUSH
57349: LD_VAR 0 7
57353: UNION
57354: PUSH
57355: LD_VAR 0 8
57359: UNION
57360: DIFF
57361: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57362: LD_ADDR_VAR 0 13
57366: PUSH
57367: LD_EXP 59
57371: PUSH
57372: LD_VAR 0 1
57376: ARRAY
57377: PPUSH
57378: LD_INT 2
57380: PUSH
57381: LD_INT 30
57383: PUSH
57384: LD_INT 32
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PUSH
57391: LD_INT 30
57393: PUSH
57394: LD_INT 31
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: LIST
57405: PPUSH
57406: CALL_OW 72
57410: PUSH
57411: LD_EXP 59
57415: PUSH
57416: LD_VAR 0 1
57420: ARRAY
57421: PPUSH
57422: LD_INT 2
57424: PUSH
57425: LD_INT 30
57427: PUSH
57428: LD_INT 4
57430: PUSH
57431: EMPTY
57432: LIST
57433: LIST
57434: PUSH
57435: LD_INT 30
57437: PUSH
57438: LD_INT 5
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: PUSH
57445: EMPTY
57446: LIST
57447: LIST
57448: LIST
57449: PPUSH
57450: CALL_OW 72
57454: PUSH
57455: LD_INT 6
57457: MUL
57458: PLUS
57459: ST_TO_ADDR
// if bcount < tmp then
57460: LD_VAR 0 13
57464: PUSH
57465: LD_VAR 0 4
57469: LESS
57470: IFFALSE 57516
// for i = tmp downto bcount do
57472: LD_ADDR_VAR 0 3
57476: PUSH
57477: DOUBLE
57478: LD_VAR 0 4
57482: INC
57483: ST_TO_ADDR
57484: LD_VAR 0 13
57488: PUSH
57489: FOR_DOWNTO
57490: IFFALSE 57514
// tmp := Delete ( tmp , tmp ) ;
57492: LD_ADDR_VAR 0 4
57496: PUSH
57497: LD_VAR 0 4
57501: PPUSH
57502: LD_VAR 0 4
57506: PPUSH
57507: CALL_OW 3
57511: ST_TO_ADDR
57512: GO 57489
57514: POP
57515: POP
// result := [ tmp , 0 , 0 , p ] ;
57516: LD_ADDR_VAR 0 2
57520: PUSH
57521: LD_VAR 0 4
57525: PUSH
57526: LD_INT 0
57528: PUSH
57529: LD_INT 0
57531: PUSH
57532: LD_VAR 0 11
57536: PUSH
57537: EMPTY
57538: LIST
57539: LIST
57540: LIST
57541: LIST
57542: ST_TO_ADDR
// exit ;
57543: GO 60233
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57545: LD_EXP 59
57549: PUSH
57550: LD_VAR 0 1
57554: ARRAY
57555: PPUSH
57556: LD_INT 2
57558: PUSH
57559: LD_INT 30
57561: PUSH
57562: LD_INT 6
57564: PUSH
57565: EMPTY
57566: LIST
57567: LIST
57568: PUSH
57569: LD_INT 30
57571: PUSH
57572: LD_INT 7
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: PUSH
57579: LD_INT 30
57581: PUSH
57582: LD_INT 8
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: LIST
57593: LIST
57594: PPUSH
57595: CALL_OW 72
57599: NOT
57600: PUSH
57601: LD_EXP 59
57605: PUSH
57606: LD_VAR 0 1
57610: ARRAY
57611: PPUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 3
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PPUSH
57622: CALL_OW 72
57626: NOT
57627: AND
57628: IFFALSE 57700
// begin if eng = tmp then
57630: LD_VAR 0 6
57634: PUSH
57635: LD_VAR 0 4
57639: EQUAL
57640: IFFALSE 57644
// exit ;
57642: GO 60233
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57644: LD_ADDR_EXP 101
57648: PUSH
57649: LD_EXP 101
57653: PPUSH
57654: LD_VAR 0 1
57658: PPUSH
57659: LD_INT 1
57661: PPUSH
57662: CALL_OW 1
57666: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57667: LD_ADDR_VAR 0 2
57671: PUSH
57672: LD_INT 0
57674: PUSH
57675: LD_VAR 0 4
57679: PUSH
57680: LD_VAR 0 6
57684: DIFF
57685: PUSH
57686: LD_INT 0
57688: PUSH
57689: LD_INT 0
57691: PUSH
57692: EMPTY
57693: LIST
57694: LIST
57695: LIST
57696: LIST
57697: ST_TO_ADDR
// exit ;
57698: GO 60233
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57700: LD_EXP 86
57704: PUSH
57705: LD_EXP 85
57709: PUSH
57710: LD_VAR 0 1
57714: ARRAY
57715: ARRAY
57716: PUSH
57717: LD_EXP 59
57721: PUSH
57722: LD_VAR 0 1
57726: ARRAY
57727: PPUSH
57728: LD_INT 2
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 6
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 30
57743: PUSH
57744: LD_INT 7
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: LD_INT 30
57753: PUSH
57754: LD_INT 8
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: LIST
57765: LIST
57766: PPUSH
57767: CALL_OW 72
57771: AND
57772: PUSH
57773: LD_EXP 59
57777: PUSH
57778: LD_VAR 0 1
57782: ARRAY
57783: PPUSH
57784: LD_INT 30
57786: PUSH
57787: LD_INT 3
57789: PUSH
57790: EMPTY
57791: LIST
57792: LIST
57793: PPUSH
57794: CALL_OW 72
57798: NOT
57799: AND
57800: IFFALSE 58014
// begin if sci >= 6 then
57802: LD_VAR 0 8
57806: PUSH
57807: LD_INT 6
57809: GREATEREQUAL
57810: IFFALSE 57814
// exit ;
57812: GO 60233
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57814: LD_ADDR_EXP 101
57818: PUSH
57819: LD_EXP 101
57823: PPUSH
57824: LD_VAR 0 1
57828: PPUSH
57829: LD_INT 2
57831: PPUSH
57832: CALL_OW 1
57836: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57837: LD_ADDR_VAR 0 9
57841: PUSH
57842: LD_VAR 0 4
57846: PUSH
57847: LD_VAR 0 8
57851: DIFF
57852: PPUSH
57853: LD_INT 4
57855: PPUSH
57856: CALL 49165 0 2
57860: ST_TO_ADDR
// p := [ ] ;
57861: LD_ADDR_VAR 0 11
57865: PUSH
57866: EMPTY
57867: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57868: LD_VAR 0 8
57872: PUSH
57873: LD_INT 6
57875: LESS
57876: PUSH
57877: LD_VAR 0 9
57881: PUSH
57882: LD_INT 6
57884: GREATER
57885: AND
57886: IFFALSE 57967
// begin for i = 1 to 6 - sci do
57888: LD_ADDR_VAR 0 3
57892: PUSH
57893: DOUBLE
57894: LD_INT 1
57896: DEC
57897: ST_TO_ADDR
57898: LD_INT 6
57900: PUSH
57901: LD_VAR 0 8
57905: MINUS
57906: PUSH
57907: FOR_TO
57908: IFFALSE 57963
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57910: LD_ADDR_VAR 0 11
57914: PUSH
57915: LD_VAR 0 11
57919: PPUSH
57920: LD_VAR 0 11
57924: PUSH
57925: LD_INT 1
57927: PLUS
57928: PPUSH
57929: LD_VAR 0 9
57933: PUSH
57934: LD_INT 1
57936: ARRAY
57937: PPUSH
57938: CALL_OW 2
57942: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57943: LD_ADDR_VAR 0 9
57947: PUSH
57948: LD_VAR 0 9
57952: PPUSH
57953: LD_INT 1
57955: PPUSH
57956: CALL_OW 3
57960: ST_TO_ADDR
// end ;
57961: GO 57907
57963: POP
57964: POP
// end else
57965: GO 57987
// if sort then
57967: LD_VAR 0 9
57971: IFFALSE 57987
// p := sort [ 1 ] ;
57973: LD_ADDR_VAR 0 11
57977: PUSH
57978: LD_VAR 0 9
57982: PUSH
57983: LD_INT 1
57985: ARRAY
57986: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57987: LD_ADDR_VAR 0 2
57991: PUSH
57992: LD_INT 0
57994: PUSH
57995: LD_INT 0
57997: PUSH
57998: LD_INT 0
58000: PUSH
58001: LD_VAR 0 11
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: LIST
58010: LIST
58011: ST_TO_ADDR
// exit ;
58012: GO 60233
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58014: LD_EXP 86
58018: PUSH
58019: LD_EXP 85
58023: PUSH
58024: LD_VAR 0 1
58028: ARRAY
58029: ARRAY
58030: PUSH
58031: LD_EXP 59
58035: PUSH
58036: LD_VAR 0 1
58040: ARRAY
58041: PPUSH
58042: LD_INT 2
58044: PUSH
58045: LD_INT 30
58047: PUSH
58048: LD_INT 6
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: PUSH
58055: LD_INT 30
58057: PUSH
58058: LD_INT 7
58060: PUSH
58061: EMPTY
58062: LIST
58063: LIST
58064: PUSH
58065: LD_INT 30
58067: PUSH
58068: LD_INT 8
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: LIST
58079: LIST
58080: PPUSH
58081: CALL_OW 72
58085: AND
58086: PUSH
58087: LD_EXP 59
58091: PUSH
58092: LD_VAR 0 1
58096: ARRAY
58097: PPUSH
58098: LD_INT 30
58100: PUSH
58101: LD_INT 3
58103: PUSH
58104: EMPTY
58105: LIST
58106: LIST
58107: PPUSH
58108: CALL_OW 72
58112: AND
58113: IFFALSE 58847
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58115: LD_ADDR_EXP 101
58119: PUSH
58120: LD_EXP 101
58124: PPUSH
58125: LD_VAR 0 1
58129: PPUSH
58130: LD_INT 3
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58138: LD_ADDR_VAR 0 2
58142: PUSH
58143: LD_INT 0
58145: PUSH
58146: LD_INT 0
58148: PUSH
58149: LD_INT 0
58151: PUSH
58152: LD_INT 0
58154: PUSH
58155: EMPTY
58156: LIST
58157: LIST
58158: LIST
58159: LIST
58160: ST_TO_ADDR
// if not eng then
58161: LD_VAR 0 6
58165: NOT
58166: IFFALSE 58229
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58168: LD_ADDR_VAR 0 11
58172: PUSH
58173: LD_VAR 0 4
58177: PPUSH
58178: LD_INT 2
58180: PPUSH
58181: CALL 49165 0 2
58185: PUSH
58186: LD_INT 1
58188: ARRAY
58189: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58190: LD_ADDR_VAR 0 2
58194: PUSH
58195: LD_VAR 0 2
58199: PPUSH
58200: LD_INT 2
58202: PPUSH
58203: LD_VAR 0 11
58207: PPUSH
58208: CALL_OW 1
58212: ST_TO_ADDR
// tmp := tmp diff p ;
58213: LD_ADDR_VAR 0 4
58217: PUSH
58218: LD_VAR 0 4
58222: PUSH
58223: LD_VAR 0 11
58227: DIFF
58228: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58229: LD_VAR 0 4
58233: PUSH
58234: LD_VAR 0 8
58238: PUSH
58239: LD_INT 6
58241: LESS
58242: AND
58243: IFFALSE 58431
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58245: LD_ADDR_VAR 0 9
58249: PUSH
58250: LD_VAR 0 4
58254: PUSH
58255: LD_VAR 0 8
58259: PUSH
58260: LD_VAR 0 7
58264: UNION
58265: DIFF
58266: PPUSH
58267: LD_INT 4
58269: PPUSH
58270: CALL 49165 0 2
58274: ST_TO_ADDR
// p := [ ] ;
58275: LD_ADDR_VAR 0 11
58279: PUSH
58280: EMPTY
58281: ST_TO_ADDR
// if sort then
58282: LD_VAR 0 9
58286: IFFALSE 58402
// for i = 1 to 6 - sci do
58288: LD_ADDR_VAR 0 3
58292: PUSH
58293: DOUBLE
58294: LD_INT 1
58296: DEC
58297: ST_TO_ADDR
58298: LD_INT 6
58300: PUSH
58301: LD_VAR 0 8
58305: MINUS
58306: PUSH
58307: FOR_TO
58308: IFFALSE 58400
// begin if i = sort then
58310: LD_VAR 0 3
58314: PUSH
58315: LD_VAR 0 9
58319: EQUAL
58320: IFFALSE 58324
// break ;
58322: GO 58400
// if GetClass ( i ) = 4 then
58324: LD_VAR 0 3
58328: PPUSH
58329: CALL_OW 257
58333: PUSH
58334: LD_INT 4
58336: EQUAL
58337: IFFALSE 58341
// continue ;
58339: GO 58307
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58341: LD_ADDR_VAR 0 11
58345: PUSH
58346: LD_VAR 0 11
58350: PPUSH
58351: LD_VAR 0 11
58355: PUSH
58356: LD_INT 1
58358: PLUS
58359: PPUSH
58360: LD_VAR 0 9
58364: PUSH
58365: LD_VAR 0 3
58369: ARRAY
58370: PPUSH
58371: CALL_OW 2
58375: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58376: LD_ADDR_VAR 0 4
58380: PUSH
58381: LD_VAR 0 4
58385: PUSH
58386: LD_VAR 0 9
58390: PUSH
58391: LD_VAR 0 3
58395: ARRAY
58396: DIFF
58397: ST_TO_ADDR
// end ;
58398: GO 58307
58400: POP
58401: POP
// if p then
58402: LD_VAR 0 11
58406: IFFALSE 58431
// result := Replace ( result , 4 , p ) ;
58408: LD_ADDR_VAR 0 2
58412: PUSH
58413: LD_VAR 0 2
58417: PPUSH
58418: LD_INT 4
58420: PPUSH
58421: LD_VAR 0 11
58425: PPUSH
58426: CALL_OW 1
58430: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58431: LD_VAR 0 4
58435: PUSH
58436: LD_VAR 0 7
58440: PUSH
58441: LD_INT 6
58443: LESS
58444: AND
58445: IFFALSE 58633
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58447: LD_ADDR_VAR 0 9
58451: PUSH
58452: LD_VAR 0 4
58456: PUSH
58457: LD_VAR 0 8
58461: PUSH
58462: LD_VAR 0 7
58466: UNION
58467: DIFF
58468: PPUSH
58469: LD_INT 3
58471: PPUSH
58472: CALL 49165 0 2
58476: ST_TO_ADDR
// p := [ ] ;
58477: LD_ADDR_VAR 0 11
58481: PUSH
58482: EMPTY
58483: ST_TO_ADDR
// if sort then
58484: LD_VAR 0 9
58488: IFFALSE 58604
// for i = 1 to 6 - mech do
58490: LD_ADDR_VAR 0 3
58494: PUSH
58495: DOUBLE
58496: LD_INT 1
58498: DEC
58499: ST_TO_ADDR
58500: LD_INT 6
58502: PUSH
58503: LD_VAR 0 7
58507: MINUS
58508: PUSH
58509: FOR_TO
58510: IFFALSE 58602
// begin if i = sort then
58512: LD_VAR 0 3
58516: PUSH
58517: LD_VAR 0 9
58521: EQUAL
58522: IFFALSE 58526
// break ;
58524: GO 58602
// if GetClass ( i ) = 3 then
58526: LD_VAR 0 3
58530: PPUSH
58531: CALL_OW 257
58535: PUSH
58536: LD_INT 3
58538: EQUAL
58539: IFFALSE 58543
// continue ;
58541: GO 58509
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58543: LD_ADDR_VAR 0 11
58547: PUSH
58548: LD_VAR 0 11
58552: PPUSH
58553: LD_VAR 0 11
58557: PUSH
58558: LD_INT 1
58560: PLUS
58561: PPUSH
58562: LD_VAR 0 9
58566: PUSH
58567: LD_VAR 0 3
58571: ARRAY
58572: PPUSH
58573: CALL_OW 2
58577: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58578: LD_ADDR_VAR 0 4
58582: PUSH
58583: LD_VAR 0 4
58587: PUSH
58588: LD_VAR 0 9
58592: PUSH
58593: LD_VAR 0 3
58597: ARRAY
58598: DIFF
58599: ST_TO_ADDR
// end ;
58600: GO 58509
58602: POP
58603: POP
// if p then
58604: LD_VAR 0 11
58608: IFFALSE 58633
// result := Replace ( result , 3 , p ) ;
58610: LD_ADDR_VAR 0 2
58614: PUSH
58615: LD_VAR 0 2
58619: PPUSH
58620: LD_INT 3
58622: PPUSH
58623: LD_VAR 0 11
58627: PPUSH
58628: CALL_OW 1
58632: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58633: LD_VAR 0 4
58637: PUSH
58638: LD_INT 6
58640: GREATER
58641: PUSH
58642: LD_VAR 0 6
58646: PUSH
58647: LD_INT 6
58649: LESS
58650: AND
58651: IFFALSE 58845
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58653: LD_ADDR_VAR 0 9
58657: PUSH
58658: LD_VAR 0 4
58662: PUSH
58663: LD_VAR 0 8
58667: PUSH
58668: LD_VAR 0 7
58672: UNION
58673: PUSH
58674: LD_VAR 0 6
58678: UNION
58679: DIFF
58680: PPUSH
58681: LD_INT 2
58683: PPUSH
58684: CALL 49165 0 2
58688: ST_TO_ADDR
// p := [ ] ;
58689: LD_ADDR_VAR 0 11
58693: PUSH
58694: EMPTY
58695: ST_TO_ADDR
// if sort then
58696: LD_VAR 0 9
58700: IFFALSE 58816
// for i = 1 to 6 - eng do
58702: LD_ADDR_VAR 0 3
58706: PUSH
58707: DOUBLE
58708: LD_INT 1
58710: DEC
58711: ST_TO_ADDR
58712: LD_INT 6
58714: PUSH
58715: LD_VAR 0 6
58719: MINUS
58720: PUSH
58721: FOR_TO
58722: IFFALSE 58814
// begin if i = sort then
58724: LD_VAR 0 3
58728: PUSH
58729: LD_VAR 0 9
58733: EQUAL
58734: IFFALSE 58738
// break ;
58736: GO 58814
// if GetClass ( i ) = 2 then
58738: LD_VAR 0 3
58742: PPUSH
58743: CALL_OW 257
58747: PUSH
58748: LD_INT 2
58750: EQUAL
58751: IFFALSE 58755
// continue ;
58753: GO 58721
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58755: LD_ADDR_VAR 0 11
58759: PUSH
58760: LD_VAR 0 11
58764: PPUSH
58765: LD_VAR 0 11
58769: PUSH
58770: LD_INT 1
58772: PLUS
58773: PPUSH
58774: LD_VAR 0 9
58778: PUSH
58779: LD_VAR 0 3
58783: ARRAY
58784: PPUSH
58785: CALL_OW 2
58789: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58790: LD_ADDR_VAR 0 4
58794: PUSH
58795: LD_VAR 0 4
58799: PUSH
58800: LD_VAR 0 9
58804: PUSH
58805: LD_VAR 0 3
58809: ARRAY
58810: DIFF
58811: ST_TO_ADDR
// end ;
58812: GO 58721
58814: POP
58815: POP
// if p then
58816: LD_VAR 0 11
58820: IFFALSE 58845
// result := Replace ( result , 2 , p ) ;
58822: LD_ADDR_VAR 0 2
58826: PUSH
58827: LD_VAR 0 2
58831: PPUSH
58832: LD_INT 2
58834: PPUSH
58835: LD_VAR 0 11
58839: PPUSH
58840: CALL_OW 1
58844: ST_TO_ADDR
// end ; exit ;
58845: GO 60233
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58847: LD_EXP 86
58851: PUSH
58852: LD_EXP 85
58856: PUSH
58857: LD_VAR 0 1
58861: ARRAY
58862: ARRAY
58863: NOT
58864: PUSH
58865: LD_EXP 59
58869: PUSH
58870: LD_VAR 0 1
58874: ARRAY
58875: PPUSH
58876: LD_INT 30
58878: PUSH
58879: LD_INT 3
58881: PUSH
58882: EMPTY
58883: LIST
58884: LIST
58885: PPUSH
58886: CALL_OW 72
58890: AND
58891: PUSH
58892: LD_EXP 64
58896: PUSH
58897: LD_VAR 0 1
58901: ARRAY
58902: AND
58903: IFFALSE 59511
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58905: LD_ADDR_EXP 101
58909: PUSH
58910: LD_EXP 101
58914: PPUSH
58915: LD_VAR 0 1
58919: PPUSH
58920: LD_INT 5
58922: PPUSH
58923: CALL_OW 1
58927: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58928: LD_ADDR_VAR 0 2
58932: PUSH
58933: LD_INT 0
58935: PUSH
58936: LD_INT 0
58938: PUSH
58939: LD_INT 0
58941: PUSH
58942: LD_INT 0
58944: PUSH
58945: EMPTY
58946: LIST
58947: LIST
58948: LIST
58949: LIST
58950: ST_TO_ADDR
// if sci > 1 then
58951: LD_VAR 0 8
58955: PUSH
58956: LD_INT 1
58958: GREATER
58959: IFFALSE 58987
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58961: LD_ADDR_VAR 0 4
58965: PUSH
58966: LD_VAR 0 4
58970: PUSH
58971: LD_VAR 0 8
58975: PUSH
58976: LD_VAR 0 8
58980: PUSH
58981: LD_INT 1
58983: ARRAY
58984: DIFF
58985: DIFF
58986: ST_TO_ADDR
// if tmp and not sci then
58987: LD_VAR 0 4
58991: PUSH
58992: LD_VAR 0 8
58996: NOT
58997: AND
58998: IFFALSE 59067
// begin sort := SortBySkill ( tmp , 4 ) ;
59000: LD_ADDR_VAR 0 9
59004: PUSH
59005: LD_VAR 0 4
59009: PPUSH
59010: LD_INT 4
59012: PPUSH
59013: CALL 49165 0 2
59017: ST_TO_ADDR
// if sort then
59018: LD_VAR 0 9
59022: IFFALSE 59038
// p := sort [ 1 ] ;
59024: LD_ADDR_VAR 0 11
59028: PUSH
59029: LD_VAR 0 9
59033: PUSH
59034: LD_INT 1
59036: ARRAY
59037: ST_TO_ADDR
// if p then
59038: LD_VAR 0 11
59042: IFFALSE 59067
// result := Replace ( result , 4 , p ) ;
59044: LD_ADDR_VAR 0 2
59048: PUSH
59049: LD_VAR 0 2
59053: PPUSH
59054: LD_INT 4
59056: PPUSH
59057: LD_VAR 0 11
59061: PPUSH
59062: CALL_OW 1
59066: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59067: LD_ADDR_VAR 0 4
59071: PUSH
59072: LD_VAR 0 4
59076: PUSH
59077: LD_VAR 0 7
59081: DIFF
59082: ST_TO_ADDR
// if tmp and mech < 6 then
59083: LD_VAR 0 4
59087: PUSH
59088: LD_VAR 0 7
59092: PUSH
59093: LD_INT 6
59095: LESS
59096: AND
59097: IFFALSE 59285
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59099: LD_ADDR_VAR 0 9
59103: PUSH
59104: LD_VAR 0 4
59108: PUSH
59109: LD_VAR 0 8
59113: PUSH
59114: LD_VAR 0 7
59118: UNION
59119: DIFF
59120: PPUSH
59121: LD_INT 3
59123: PPUSH
59124: CALL 49165 0 2
59128: ST_TO_ADDR
// p := [ ] ;
59129: LD_ADDR_VAR 0 11
59133: PUSH
59134: EMPTY
59135: ST_TO_ADDR
// if sort then
59136: LD_VAR 0 9
59140: IFFALSE 59256
// for i = 1 to 6 - mech do
59142: LD_ADDR_VAR 0 3
59146: PUSH
59147: DOUBLE
59148: LD_INT 1
59150: DEC
59151: ST_TO_ADDR
59152: LD_INT 6
59154: PUSH
59155: LD_VAR 0 7
59159: MINUS
59160: PUSH
59161: FOR_TO
59162: IFFALSE 59254
// begin if i = sort then
59164: LD_VAR 0 3
59168: PUSH
59169: LD_VAR 0 9
59173: EQUAL
59174: IFFALSE 59178
// break ;
59176: GO 59254
// if GetClass ( i ) = 3 then
59178: LD_VAR 0 3
59182: PPUSH
59183: CALL_OW 257
59187: PUSH
59188: LD_INT 3
59190: EQUAL
59191: IFFALSE 59195
// continue ;
59193: GO 59161
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59195: LD_ADDR_VAR 0 11
59199: PUSH
59200: LD_VAR 0 11
59204: PPUSH
59205: LD_VAR 0 11
59209: PUSH
59210: LD_INT 1
59212: PLUS
59213: PPUSH
59214: LD_VAR 0 9
59218: PUSH
59219: LD_VAR 0 3
59223: ARRAY
59224: PPUSH
59225: CALL_OW 2
59229: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59230: LD_ADDR_VAR 0 4
59234: PUSH
59235: LD_VAR 0 4
59239: PUSH
59240: LD_VAR 0 9
59244: PUSH
59245: LD_VAR 0 3
59249: ARRAY
59250: DIFF
59251: ST_TO_ADDR
// end ;
59252: GO 59161
59254: POP
59255: POP
// if p then
59256: LD_VAR 0 11
59260: IFFALSE 59285
// result := Replace ( result , 3 , p ) ;
59262: LD_ADDR_VAR 0 2
59266: PUSH
59267: LD_VAR 0 2
59271: PPUSH
59272: LD_INT 3
59274: PPUSH
59275: LD_VAR 0 11
59279: PPUSH
59280: CALL_OW 1
59284: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59285: LD_ADDR_VAR 0 4
59289: PUSH
59290: LD_VAR 0 4
59294: PUSH
59295: LD_VAR 0 6
59299: DIFF
59300: ST_TO_ADDR
// if tmp and eng < 6 then
59301: LD_VAR 0 4
59305: PUSH
59306: LD_VAR 0 6
59310: PUSH
59311: LD_INT 6
59313: LESS
59314: AND
59315: IFFALSE 59509
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59317: LD_ADDR_VAR 0 9
59321: PUSH
59322: LD_VAR 0 4
59326: PUSH
59327: LD_VAR 0 8
59331: PUSH
59332: LD_VAR 0 7
59336: UNION
59337: PUSH
59338: LD_VAR 0 6
59342: UNION
59343: DIFF
59344: PPUSH
59345: LD_INT 2
59347: PPUSH
59348: CALL 49165 0 2
59352: ST_TO_ADDR
// p := [ ] ;
59353: LD_ADDR_VAR 0 11
59357: PUSH
59358: EMPTY
59359: ST_TO_ADDR
// if sort then
59360: LD_VAR 0 9
59364: IFFALSE 59480
// for i = 1 to 6 - eng do
59366: LD_ADDR_VAR 0 3
59370: PUSH
59371: DOUBLE
59372: LD_INT 1
59374: DEC
59375: ST_TO_ADDR
59376: LD_INT 6
59378: PUSH
59379: LD_VAR 0 6
59383: MINUS
59384: PUSH
59385: FOR_TO
59386: IFFALSE 59478
// begin if i = sort then
59388: LD_VAR 0 3
59392: PUSH
59393: LD_VAR 0 9
59397: EQUAL
59398: IFFALSE 59402
// break ;
59400: GO 59478
// if GetClass ( i ) = 2 then
59402: LD_VAR 0 3
59406: PPUSH
59407: CALL_OW 257
59411: PUSH
59412: LD_INT 2
59414: EQUAL
59415: IFFALSE 59419
// continue ;
59417: GO 59385
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59419: LD_ADDR_VAR 0 11
59423: PUSH
59424: LD_VAR 0 11
59428: PPUSH
59429: LD_VAR 0 11
59433: PUSH
59434: LD_INT 1
59436: PLUS
59437: PPUSH
59438: LD_VAR 0 9
59442: PUSH
59443: LD_VAR 0 3
59447: ARRAY
59448: PPUSH
59449: CALL_OW 2
59453: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59454: LD_ADDR_VAR 0 4
59458: PUSH
59459: LD_VAR 0 4
59463: PUSH
59464: LD_VAR 0 9
59468: PUSH
59469: LD_VAR 0 3
59473: ARRAY
59474: DIFF
59475: ST_TO_ADDR
// end ;
59476: GO 59385
59478: POP
59479: POP
// if p then
59480: LD_VAR 0 11
59484: IFFALSE 59509
// result := Replace ( result , 2 , p ) ;
59486: LD_ADDR_VAR 0 2
59490: PUSH
59491: LD_VAR 0 2
59495: PPUSH
59496: LD_INT 2
59498: PPUSH
59499: LD_VAR 0 11
59503: PPUSH
59504: CALL_OW 1
59508: ST_TO_ADDR
// end ; exit ;
59509: GO 60233
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59511: LD_EXP 86
59515: PUSH
59516: LD_EXP 85
59520: PUSH
59521: LD_VAR 0 1
59525: ARRAY
59526: ARRAY
59527: NOT
59528: PUSH
59529: LD_EXP 59
59533: PUSH
59534: LD_VAR 0 1
59538: ARRAY
59539: PPUSH
59540: LD_INT 30
59542: PUSH
59543: LD_INT 3
59545: PUSH
59546: EMPTY
59547: LIST
59548: LIST
59549: PPUSH
59550: CALL_OW 72
59554: AND
59555: PUSH
59556: LD_EXP 64
59560: PUSH
59561: LD_VAR 0 1
59565: ARRAY
59566: NOT
59567: AND
59568: IFFALSE 60233
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59570: LD_ADDR_EXP 101
59574: PUSH
59575: LD_EXP 101
59579: PPUSH
59580: LD_VAR 0 1
59584: PPUSH
59585: LD_INT 6
59587: PPUSH
59588: CALL_OW 1
59592: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59593: LD_ADDR_VAR 0 2
59597: PUSH
59598: LD_INT 0
59600: PUSH
59601: LD_INT 0
59603: PUSH
59604: LD_INT 0
59606: PUSH
59607: LD_INT 0
59609: PUSH
59610: EMPTY
59611: LIST
59612: LIST
59613: LIST
59614: LIST
59615: ST_TO_ADDR
// if sci >= 1 then
59616: LD_VAR 0 8
59620: PUSH
59621: LD_INT 1
59623: GREATEREQUAL
59624: IFFALSE 59646
// tmp := tmp diff sci [ 1 ] ;
59626: LD_ADDR_VAR 0 4
59630: PUSH
59631: LD_VAR 0 4
59635: PUSH
59636: LD_VAR 0 8
59640: PUSH
59641: LD_INT 1
59643: ARRAY
59644: DIFF
59645: ST_TO_ADDR
// if tmp and not sci then
59646: LD_VAR 0 4
59650: PUSH
59651: LD_VAR 0 8
59655: NOT
59656: AND
59657: IFFALSE 59726
// begin sort := SortBySkill ( tmp , 4 ) ;
59659: LD_ADDR_VAR 0 9
59663: PUSH
59664: LD_VAR 0 4
59668: PPUSH
59669: LD_INT 4
59671: PPUSH
59672: CALL 49165 0 2
59676: ST_TO_ADDR
// if sort then
59677: LD_VAR 0 9
59681: IFFALSE 59697
// p := sort [ 1 ] ;
59683: LD_ADDR_VAR 0 11
59687: PUSH
59688: LD_VAR 0 9
59692: PUSH
59693: LD_INT 1
59695: ARRAY
59696: ST_TO_ADDR
// if p then
59697: LD_VAR 0 11
59701: IFFALSE 59726
// result := Replace ( result , 4 , p ) ;
59703: LD_ADDR_VAR 0 2
59707: PUSH
59708: LD_VAR 0 2
59712: PPUSH
59713: LD_INT 4
59715: PPUSH
59716: LD_VAR 0 11
59720: PPUSH
59721: CALL_OW 1
59725: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59726: LD_ADDR_VAR 0 4
59730: PUSH
59731: LD_VAR 0 4
59735: PUSH
59736: LD_VAR 0 7
59740: DIFF
59741: ST_TO_ADDR
// if tmp and mech < 6 then
59742: LD_VAR 0 4
59746: PUSH
59747: LD_VAR 0 7
59751: PUSH
59752: LD_INT 6
59754: LESS
59755: AND
59756: IFFALSE 59938
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59758: LD_ADDR_VAR 0 9
59762: PUSH
59763: LD_VAR 0 4
59767: PUSH
59768: LD_VAR 0 7
59772: DIFF
59773: PPUSH
59774: LD_INT 3
59776: PPUSH
59777: CALL 49165 0 2
59781: ST_TO_ADDR
// p := [ ] ;
59782: LD_ADDR_VAR 0 11
59786: PUSH
59787: EMPTY
59788: ST_TO_ADDR
// if sort then
59789: LD_VAR 0 9
59793: IFFALSE 59909
// for i = 1 to 6 - mech do
59795: LD_ADDR_VAR 0 3
59799: PUSH
59800: DOUBLE
59801: LD_INT 1
59803: DEC
59804: ST_TO_ADDR
59805: LD_INT 6
59807: PUSH
59808: LD_VAR 0 7
59812: MINUS
59813: PUSH
59814: FOR_TO
59815: IFFALSE 59907
// begin if i = sort then
59817: LD_VAR 0 3
59821: PUSH
59822: LD_VAR 0 9
59826: EQUAL
59827: IFFALSE 59831
// break ;
59829: GO 59907
// if GetClass ( i ) = 3 then
59831: LD_VAR 0 3
59835: PPUSH
59836: CALL_OW 257
59840: PUSH
59841: LD_INT 3
59843: EQUAL
59844: IFFALSE 59848
// continue ;
59846: GO 59814
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59848: LD_ADDR_VAR 0 11
59852: PUSH
59853: LD_VAR 0 11
59857: PPUSH
59858: LD_VAR 0 11
59862: PUSH
59863: LD_INT 1
59865: PLUS
59866: PPUSH
59867: LD_VAR 0 9
59871: PUSH
59872: LD_VAR 0 3
59876: ARRAY
59877: PPUSH
59878: CALL_OW 2
59882: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59883: LD_ADDR_VAR 0 4
59887: PUSH
59888: LD_VAR 0 4
59892: PUSH
59893: LD_VAR 0 9
59897: PUSH
59898: LD_VAR 0 3
59902: ARRAY
59903: DIFF
59904: ST_TO_ADDR
// end ;
59905: GO 59814
59907: POP
59908: POP
// if p then
59909: LD_VAR 0 11
59913: IFFALSE 59938
// result := Replace ( result , 3 , p ) ;
59915: LD_ADDR_VAR 0 2
59919: PUSH
59920: LD_VAR 0 2
59924: PPUSH
59925: LD_INT 3
59927: PPUSH
59928: LD_VAR 0 11
59932: PPUSH
59933: CALL_OW 1
59937: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59938: LD_ADDR_VAR 0 4
59942: PUSH
59943: LD_VAR 0 4
59947: PUSH
59948: LD_VAR 0 6
59952: DIFF
59953: ST_TO_ADDR
// if tmp and eng < 4 then
59954: LD_VAR 0 4
59958: PUSH
59959: LD_VAR 0 6
59963: PUSH
59964: LD_INT 4
59966: LESS
59967: AND
59968: IFFALSE 60158
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59970: LD_ADDR_VAR 0 9
59974: PUSH
59975: LD_VAR 0 4
59979: PUSH
59980: LD_VAR 0 7
59984: PUSH
59985: LD_VAR 0 6
59989: UNION
59990: DIFF
59991: PPUSH
59992: LD_INT 2
59994: PPUSH
59995: CALL 49165 0 2
59999: ST_TO_ADDR
// p := [ ] ;
60000: LD_ADDR_VAR 0 11
60004: PUSH
60005: EMPTY
60006: ST_TO_ADDR
// if sort then
60007: LD_VAR 0 9
60011: IFFALSE 60127
// for i = 1 to 4 - eng do
60013: LD_ADDR_VAR 0 3
60017: PUSH
60018: DOUBLE
60019: LD_INT 1
60021: DEC
60022: ST_TO_ADDR
60023: LD_INT 4
60025: PUSH
60026: LD_VAR 0 6
60030: MINUS
60031: PUSH
60032: FOR_TO
60033: IFFALSE 60125
// begin if i = sort then
60035: LD_VAR 0 3
60039: PUSH
60040: LD_VAR 0 9
60044: EQUAL
60045: IFFALSE 60049
// break ;
60047: GO 60125
// if GetClass ( i ) = 2 then
60049: LD_VAR 0 3
60053: PPUSH
60054: CALL_OW 257
60058: PUSH
60059: LD_INT 2
60061: EQUAL
60062: IFFALSE 60066
// continue ;
60064: GO 60032
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60066: LD_ADDR_VAR 0 11
60070: PUSH
60071: LD_VAR 0 11
60075: PPUSH
60076: LD_VAR 0 11
60080: PUSH
60081: LD_INT 1
60083: PLUS
60084: PPUSH
60085: LD_VAR 0 9
60089: PUSH
60090: LD_VAR 0 3
60094: ARRAY
60095: PPUSH
60096: CALL_OW 2
60100: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60101: LD_ADDR_VAR 0 4
60105: PUSH
60106: LD_VAR 0 4
60110: PUSH
60111: LD_VAR 0 9
60115: PUSH
60116: LD_VAR 0 3
60120: ARRAY
60121: DIFF
60122: ST_TO_ADDR
// end ;
60123: GO 60032
60125: POP
60126: POP
// if p then
60127: LD_VAR 0 11
60131: IFFALSE 60156
// result := Replace ( result , 2 , p ) ;
60133: LD_ADDR_VAR 0 2
60137: PUSH
60138: LD_VAR 0 2
60142: PPUSH
60143: LD_INT 2
60145: PPUSH
60146: LD_VAR 0 11
60150: PPUSH
60151: CALL_OW 1
60155: ST_TO_ADDR
// end else
60156: GO 60202
// for i = eng downto 5 do
60158: LD_ADDR_VAR 0 3
60162: PUSH
60163: DOUBLE
60164: LD_VAR 0 6
60168: INC
60169: ST_TO_ADDR
60170: LD_INT 5
60172: PUSH
60173: FOR_DOWNTO
60174: IFFALSE 60200
// tmp := tmp union eng [ i ] ;
60176: LD_ADDR_VAR 0 4
60180: PUSH
60181: LD_VAR 0 4
60185: PUSH
60186: LD_VAR 0 6
60190: PUSH
60191: LD_VAR 0 3
60195: ARRAY
60196: UNION
60197: ST_TO_ADDR
60198: GO 60173
60200: POP
60201: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60202: LD_ADDR_VAR 0 2
60206: PUSH
60207: LD_VAR 0 2
60211: PPUSH
60212: LD_INT 1
60214: PPUSH
60215: LD_VAR 0 4
60219: PUSH
60220: LD_VAR 0 5
60224: DIFF
60225: PPUSH
60226: CALL_OW 1
60230: ST_TO_ADDR
// exit ;
60231: GO 60233
// end ; end ;
60233: LD_VAR 0 2
60237: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60238: LD_INT 0
60240: PPUSH
60241: PPUSH
60242: PPUSH
// if not mc_bases then
60243: LD_EXP 59
60247: NOT
60248: IFFALSE 60252
// exit ;
60250: GO 60358
// for i = 1 to mc_bases do
60252: LD_ADDR_VAR 0 2
60256: PUSH
60257: DOUBLE
60258: LD_INT 1
60260: DEC
60261: ST_TO_ADDR
60262: LD_EXP 59
60266: PUSH
60267: FOR_TO
60268: IFFALSE 60349
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60270: LD_ADDR_VAR 0 3
60274: PUSH
60275: LD_EXP 59
60279: PUSH
60280: LD_VAR 0 2
60284: ARRAY
60285: PPUSH
60286: LD_INT 21
60288: PUSH
60289: LD_INT 3
60291: PUSH
60292: EMPTY
60293: LIST
60294: LIST
60295: PUSH
60296: LD_INT 3
60298: PUSH
60299: LD_INT 24
60301: PUSH
60302: LD_INT 1000
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PUSH
60309: EMPTY
60310: LIST
60311: LIST
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: PPUSH
60317: CALL_OW 72
60321: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60322: LD_ADDR_EXP 60
60326: PUSH
60327: LD_EXP 60
60331: PPUSH
60332: LD_VAR 0 2
60336: PPUSH
60337: LD_VAR 0 3
60341: PPUSH
60342: CALL_OW 1
60346: ST_TO_ADDR
// end ;
60347: GO 60267
60349: POP
60350: POP
// RaiseSailEvent ( 101 ) ;
60351: LD_INT 101
60353: PPUSH
60354: CALL_OW 427
// end ;
60358: LD_VAR 0 1
60362: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60363: LD_INT 0
60365: PPUSH
60366: PPUSH
60367: PPUSH
60368: PPUSH
60369: PPUSH
60370: PPUSH
60371: PPUSH
// if not mc_bases then
60372: LD_EXP 59
60376: NOT
60377: IFFALSE 60381
// exit ;
60379: GO 60943
// for i = 1 to mc_bases do
60381: LD_ADDR_VAR 0 2
60385: PUSH
60386: DOUBLE
60387: LD_INT 1
60389: DEC
60390: ST_TO_ADDR
60391: LD_EXP 59
60395: PUSH
60396: FOR_TO
60397: IFFALSE 60934
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60399: LD_ADDR_VAR 0 5
60403: PUSH
60404: LD_EXP 59
60408: PUSH
60409: LD_VAR 0 2
60413: ARRAY
60414: PUSH
60415: LD_EXP 88
60419: PUSH
60420: LD_VAR 0 2
60424: ARRAY
60425: UNION
60426: PPUSH
60427: LD_INT 21
60429: PUSH
60430: LD_INT 1
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 1
60439: PUSH
60440: LD_INT 3
60442: PUSH
60443: LD_INT 54
60445: PUSH
60446: EMPTY
60447: LIST
60448: PUSH
60449: EMPTY
60450: LIST
60451: LIST
60452: PUSH
60453: LD_INT 3
60455: PUSH
60456: LD_INT 24
60458: PUSH
60459: LD_INT 1000
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: LIST
60474: PUSH
60475: EMPTY
60476: LIST
60477: LIST
60478: PPUSH
60479: CALL_OW 72
60483: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60484: LD_ADDR_VAR 0 6
60488: PUSH
60489: LD_EXP 59
60493: PUSH
60494: LD_VAR 0 2
60498: ARRAY
60499: PPUSH
60500: LD_INT 21
60502: PUSH
60503: LD_INT 1
60505: PUSH
60506: EMPTY
60507: LIST
60508: LIST
60509: PUSH
60510: LD_INT 1
60512: PUSH
60513: LD_INT 3
60515: PUSH
60516: LD_INT 54
60518: PUSH
60519: EMPTY
60520: LIST
60521: PUSH
60522: EMPTY
60523: LIST
60524: LIST
60525: PUSH
60526: LD_INT 3
60528: PUSH
60529: LD_INT 24
60531: PUSH
60532: LD_INT 250
60534: PUSH
60535: EMPTY
60536: LIST
60537: LIST
60538: PUSH
60539: EMPTY
60540: LIST
60541: LIST
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: LIST
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PPUSH
60552: CALL_OW 72
60556: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60557: LD_ADDR_VAR 0 7
60561: PUSH
60562: LD_VAR 0 5
60566: PUSH
60567: LD_VAR 0 6
60571: DIFF
60572: ST_TO_ADDR
// if not need_heal_1 then
60573: LD_VAR 0 6
60577: NOT
60578: IFFALSE 60611
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60580: LD_ADDR_EXP 62
60584: PUSH
60585: LD_EXP 62
60589: PPUSH
60590: LD_VAR 0 2
60594: PUSH
60595: LD_INT 1
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PPUSH
60602: EMPTY
60603: PPUSH
60604: CALL 19283 0 3
60608: ST_TO_ADDR
60609: GO 60681
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60611: LD_ADDR_EXP 62
60615: PUSH
60616: LD_EXP 62
60620: PPUSH
60621: LD_VAR 0 2
60625: PUSH
60626: LD_INT 1
60628: PUSH
60629: EMPTY
60630: LIST
60631: LIST
60632: PPUSH
60633: LD_EXP 62
60637: PUSH
60638: LD_VAR 0 2
60642: ARRAY
60643: PUSH
60644: LD_INT 1
60646: ARRAY
60647: PPUSH
60648: LD_INT 3
60650: PUSH
60651: LD_INT 24
60653: PUSH
60654: LD_INT 1000
60656: PUSH
60657: EMPTY
60658: LIST
60659: LIST
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: PPUSH
60665: CALL_OW 72
60669: PUSH
60670: LD_VAR 0 6
60674: UNION
60675: PPUSH
60676: CALL 19283 0 3
60680: ST_TO_ADDR
// if not need_heal_2 then
60681: LD_VAR 0 7
60685: NOT
60686: IFFALSE 60719
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60688: LD_ADDR_EXP 62
60692: PUSH
60693: LD_EXP 62
60697: PPUSH
60698: LD_VAR 0 2
60702: PUSH
60703: LD_INT 2
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PPUSH
60710: EMPTY
60711: PPUSH
60712: CALL 19283 0 3
60716: ST_TO_ADDR
60717: GO 60751
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60719: LD_ADDR_EXP 62
60723: PUSH
60724: LD_EXP 62
60728: PPUSH
60729: LD_VAR 0 2
60733: PUSH
60734: LD_INT 2
60736: PUSH
60737: EMPTY
60738: LIST
60739: LIST
60740: PPUSH
60741: LD_VAR 0 7
60745: PPUSH
60746: CALL 19283 0 3
60750: ST_TO_ADDR
// if need_heal_2 then
60751: LD_VAR 0 7
60755: IFFALSE 60916
// for j in need_heal_2 do
60757: LD_ADDR_VAR 0 3
60761: PUSH
60762: LD_VAR 0 7
60766: PUSH
60767: FOR_IN
60768: IFFALSE 60914
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60770: LD_ADDR_VAR 0 5
60774: PUSH
60775: LD_EXP 59
60779: PUSH
60780: LD_VAR 0 2
60784: ARRAY
60785: PPUSH
60786: LD_INT 2
60788: PUSH
60789: LD_INT 30
60791: PUSH
60792: LD_INT 6
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 30
60801: PUSH
60802: LD_INT 7
60804: PUSH
60805: EMPTY
60806: LIST
60807: LIST
60808: PUSH
60809: LD_INT 30
60811: PUSH
60812: LD_INT 8
60814: PUSH
60815: EMPTY
60816: LIST
60817: LIST
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 0
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 1
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: LIST
60844: LIST
60845: LIST
60846: PPUSH
60847: CALL_OW 72
60851: ST_TO_ADDR
// if tmp then
60852: LD_VAR 0 5
60856: IFFALSE 60912
// begin k := NearestUnitToUnit ( tmp , j ) ;
60858: LD_ADDR_VAR 0 4
60862: PUSH
60863: LD_VAR 0 5
60867: PPUSH
60868: LD_VAR 0 3
60872: PPUSH
60873: CALL_OW 74
60877: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60878: LD_VAR 0 3
60882: PPUSH
60883: LD_VAR 0 4
60887: PPUSH
60888: CALL_OW 296
60892: PUSH
60893: LD_INT 5
60895: GREATER
60896: IFFALSE 60912
// ComMoveToNearbyEntrance ( j , k ) ;
60898: LD_VAR 0 3
60902: PPUSH
60903: LD_VAR 0 4
60907: PPUSH
60908: CALL 51526 0 2
// end ; end ;
60912: GO 60767
60914: POP
60915: POP
// if not need_heal_1 and not need_heal_2 then
60916: LD_VAR 0 6
60920: NOT
60921: PUSH
60922: LD_VAR 0 7
60926: NOT
60927: AND
60928: IFFALSE 60932
// continue ;
60930: GO 60396
// end ;
60932: GO 60396
60934: POP
60935: POP
// RaiseSailEvent ( 102 ) ;
60936: LD_INT 102
60938: PPUSH
60939: CALL_OW 427
// end ;
60943: LD_VAR 0 1
60947: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60948: LD_INT 0
60950: PPUSH
60951: PPUSH
60952: PPUSH
60953: PPUSH
60954: PPUSH
60955: PPUSH
60956: PPUSH
60957: PPUSH
// if not mc_bases then
60958: LD_EXP 59
60962: NOT
60963: IFFALSE 60967
// exit ;
60965: GO 61828
// for i = 1 to mc_bases do
60967: LD_ADDR_VAR 0 2
60971: PUSH
60972: DOUBLE
60973: LD_INT 1
60975: DEC
60976: ST_TO_ADDR
60977: LD_EXP 59
60981: PUSH
60982: FOR_TO
60983: IFFALSE 61826
// begin if not mc_building_need_repair [ i ] then
60985: LD_EXP 60
60989: PUSH
60990: LD_VAR 0 2
60994: ARRAY
60995: NOT
60996: IFFALSE 61183
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60998: LD_ADDR_VAR 0 6
61002: PUSH
61003: LD_EXP 78
61007: PUSH
61008: LD_VAR 0 2
61012: ARRAY
61013: PPUSH
61014: LD_INT 3
61016: PUSH
61017: LD_INT 24
61019: PUSH
61020: LD_INT 1000
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: LD_INT 2
61033: PUSH
61034: LD_INT 34
61036: PUSH
61037: LD_INT 13
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PUSH
61044: LD_INT 34
61046: PUSH
61047: LD_INT 52
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: LD_INT 34
61056: PUSH
61057: LD_EXP 108
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: LIST
61070: LIST
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PPUSH
61076: CALL_OW 72
61080: ST_TO_ADDR
// if cranes then
61081: LD_VAR 0 6
61085: IFFALSE 61147
// for j in cranes do
61087: LD_ADDR_VAR 0 3
61091: PUSH
61092: LD_VAR 0 6
61096: PUSH
61097: FOR_IN
61098: IFFALSE 61145
// if not IsInArea ( j , mc_parking [ i ] ) then
61100: LD_VAR 0 3
61104: PPUSH
61105: LD_EXP 83
61109: PUSH
61110: LD_VAR 0 2
61114: ARRAY
61115: PPUSH
61116: CALL_OW 308
61120: NOT
61121: IFFALSE 61143
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61123: LD_VAR 0 3
61127: PPUSH
61128: LD_EXP 83
61132: PUSH
61133: LD_VAR 0 2
61137: ARRAY
61138: PPUSH
61139: CALL_OW 113
61143: GO 61097
61145: POP
61146: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61147: LD_ADDR_EXP 61
61151: PUSH
61152: LD_EXP 61
61156: PPUSH
61157: LD_VAR 0 2
61161: PPUSH
61162: EMPTY
61163: PPUSH
61164: CALL_OW 1
61168: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61169: LD_VAR 0 2
61173: PPUSH
61174: LD_INT 101
61176: PPUSH
61177: CALL 56071 0 2
// continue ;
61181: GO 60982
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61183: LD_ADDR_EXP 65
61187: PUSH
61188: LD_EXP 65
61192: PPUSH
61193: LD_VAR 0 2
61197: PPUSH
61198: EMPTY
61199: PPUSH
61200: CALL_OW 1
61204: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61205: LD_VAR 0 2
61209: PPUSH
61210: LD_INT 103
61212: PPUSH
61213: CALL 56071 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61217: LD_ADDR_VAR 0 5
61221: PUSH
61222: LD_EXP 59
61226: PUSH
61227: LD_VAR 0 2
61231: ARRAY
61232: PUSH
61233: LD_EXP 88
61237: PUSH
61238: LD_VAR 0 2
61242: ARRAY
61243: UNION
61244: PPUSH
61245: LD_INT 2
61247: PUSH
61248: LD_INT 25
61250: PUSH
61251: LD_INT 2
61253: PUSH
61254: EMPTY
61255: LIST
61256: LIST
61257: PUSH
61258: LD_INT 25
61260: PUSH
61261: LD_INT 16
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: LIST
61272: PUSH
61273: EMPTY
61274: LIST
61275: PPUSH
61276: CALL_OW 72
61280: PUSH
61281: LD_EXP 62
61285: PUSH
61286: LD_VAR 0 2
61290: ARRAY
61291: PUSH
61292: LD_INT 1
61294: ARRAY
61295: PUSH
61296: LD_EXP 62
61300: PUSH
61301: LD_VAR 0 2
61305: ARRAY
61306: PUSH
61307: LD_INT 2
61309: ARRAY
61310: UNION
61311: DIFF
61312: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61313: LD_ADDR_VAR 0 6
61317: PUSH
61318: LD_EXP 78
61322: PUSH
61323: LD_VAR 0 2
61327: ARRAY
61328: PPUSH
61329: LD_INT 2
61331: PUSH
61332: LD_INT 34
61334: PUSH
61335: LD_INT 13
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: PUSH
61342: LD_INT 34
61344: PUSH
61345: LD_INT 52
61347: PUSH
61348: EMPTY
61349: LIST
61350: LIST
61351: PUSH
61352: LD_INT 34
61354: PUSH
61355: LD_EXP 108
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PUSH
61364: EMPTY
61365: LIST
61366: LIST
61367: LIST
61368: LIST
61369: PPUSH
61370: CALL_OW 72
61374: ST_TO_ADDR
// if cranes then
61375: LD_VAR 0 6
61379: IFFALSE 61515
// begin for j in cranes do
61381: LD_ADDR_VAR 0 3
61385: PUSH
61386: LD_VAR 0 6
61390: PUSH
61391: FOR_IN
61392: IFFALSE 61513
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61394: LD_VAR 0 3
61398: PPUSH
61399: CALL_OW 256
61403: PUSH
61404: LD_INT 1000
61406: EQUAL
61407: PUSH
61408: LD_VAR 0 3
61412: PPUSH
61413: CALL_OW 314
61417: NOT
61418: AND
61419: IFFALSE 61453
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61421: LD_VAR 0 3
61425: PPUSH
61426: LD_EXP 60
61430: PUSH
61431: LD_VAR 0 2
61435: ARRAY
61436: PPUSH
61437: LD_VAR 0 3
61441: PPUSH
61442: CALL_OW 74
61446: PPUSH
61447: CALL_OW 130
61451: GO 61511
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61453: LD_VAR 0 3
61457: PPUSH
61458: CALL_OW 256
61462: PUSH
61463: LD_INT 500
61465: LESS
61466: PUSH
61467: LD_VAR 0 3
61471: PPUSH
61472: LD_EXP 83
61476: PUSH
61477: LD_VAR 0 2
61481: ARRAY
61482: PPUSH
61483: CALL_OW 308
61487: NOT
61488: AND
61489: IFFALSE 61511
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61491: LD_VAR 0 3
61495: PPUSH
61496: LD_EXP 83
61500: PUSH
61501: LD_VAR 0 2
61505: ARRAY
61506: PPUSH
61507: CALL_OW 113
// end ;
61511: GO 61391
61513: POP
61514: POP
// end ; if tmp > 3 then
61515: LD_VAR 0 5
61519: PUSH
61520: LD_INT 3
61522: GREATER
61523: IFFALSE 61543
// tmp := ShrinkArray ( tmp , 4 ) ;
61525: LD_ADDR_VAR 0 5
61529: PUSH
61530: LD_VAR 0 5
61534: PPUSH
61535: LD_INT 4
61537: PPUSH
61538: CALL 50974 0 2
61542: ST_TO_ADDR
// if not tmp then
61543: LD_VAR 0 5
61547: NOT
61548: IFFALSE 61552
// continue ;
61550: GO 60982
// for j in tmp do
61552: LD_ADDR_VAR 0 3
61556: PUSH
61557: LD_VAR 0 5
61561: PUSH
61562: FOR_IN
61563: IFFALSE 61822
// begin if IsInUnit ( j ) then
61565: LD_VAR 0 3
61569: PPUSH
61570: CALL_OW 310
61574: IFFALSE 61585
// ComExitBuilding ( j ) ;
61576: LD_VAR 0 3
61580: PPUSH
61581: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61585: LD_VAR 0 3
61589: PUSH
61590: LD_EXP 61
61594: PUSH
61595: LD_VAR 0 2
61599: ARRAY
61600: IN
61601: NOT
61602: IFFALSE 61660
// begin SetTag ( j , 101 ) ;
61604: LD_VAR 0 3
61608: PPUSH
61609: LD_INT 101
61611: PPUSH
61612: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61616: LD_ADDR_EXP 61
61620: PUSH
61621: LD_EXP 61
61625: PPUSH
61626: LD_VAR 0 2
61630: PUSH
61631: LD_EXP 61
61635: PUSH
61636: LD_VAR 0 2
61640: ARRAY
61641: PUSH
61642: LD_INT 1
61644: PLUS
61645: PUSH
61646: EMPTY
61647: LIST
61648: LIST
61649: PPUSH
61650: LD_VAR 0 3
61654: PPUSH
61655: CALL 19283 0 3
61659: ST_TO_ADDR
// end ; wait ( 1 ) ;
61660: LD_INT 1
61662: PPUSH
61663: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61667: LD_ADDR_VAR 0 7
61671: PUSH
61672: LD_EXP 60
61676: PUSH
61677: LD_VAR 0 2
61681: ARRAY
61682: ST_TO_ADDR
// if mc_scan [ i ] then
61683: LD_EXP 82
61687: PUSH
61688: LD_VAR 0 2
61692: ARRAY
61693: IFFALSE 61755
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61695: LD_ADDR_VAR 0 7
61699: PUSH
61700: LD_EXP 60
61704: PUSH
61705: LD_VAR 0 2
61709: ARRAY
61710: PPUSH
61711: LD_INT 3
61713: PUSH
61714: LD_INT 30
61716: PUSH
61717: LD_INT 32
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: PUSH
61724: LD_INT 30
61726: PUSH
61727: LD_INT 33
61729: PUSH
61730: EMPTY
61731: LIST
61732: LIST
61733: PUSH
61734: LD_INT 30
61736: PUSH
61737: LD_INT 31
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: LIST
61748: LIST
61749: PPUSH
61750: CALL_OW 72
61754: ST_TO_ADDR
// if not to_repair_tmp then
61755: LD_VAR 0 7
61759: NOT
61760: IFFALSE 61764
// continue ;
61762: GO 61562
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61764: LD_ADDR_VAR 0 8
61768: PUSH
61769: LD_VAR 0 7
61773: PPUSH
61774: LD_VAR 0 3
61778: PPUSH
61779: CALL_OW 74
61783: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61784: LD_VAR 0 8
61788: PPUSH
61789: LD_INT 16
61791: PPUSH
61792: CALL 21876 0 2
61796: PUSH
61797: LD_INT 4
61799: ARRAY
61800: PUSH
61801: LD_INT 10
61803: LESS
61804: IFFALSE 61820
// ComRepairBuilding ( j , to_repair ) ;
61806: LD_VAR 0 3
61810: PPUSH
61811: LD_VAR 0 8
61815: PPUSH
61816: CALL_OW 130
// end ;
61820: GO 61562
61822: POP
61823: POP
// end ;
61824: GO 60982
61826: POP
61827: POP
// end ;
61828: LD_VAR 0 1
61832: RET
// export function MC_Heal ; var i , j , tmp ; begin
61833: LD_INT 0
61835: PPUSH
61836: PPUSH
61837: PPUSH
61838: PPUSH
// if not mc_bases then
61839: LD_EXP 59
61843: NOT
61844: IFFALSE 61848
// exit ;
61846: GO 62250
// for i = 1 to mc_bases do
61848: LD_ADDR_VAR 0 2
61852: PUSH
61853: DOUBLE
61854: LD_INT 1
61856: DEC
61857: ST_TO_ADDR
61858: LD_EXP 59
61862: PUSH
61863: FOR_TO
61864: IFFALSE 62248
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61866: LD_EXP 62
61870: PUSH
61871: LD_VAR 0 2
61875: ARRAY
61876: PUSH
61877: LD_INT 1
61879: ARRAY
61880: NOT
61881: PUSH
61882: LD_EXP 62
61886: PUSH
61887: LD_VAR 0 2
61891: ARRAY
61892: PUSH
61893: LD_INT 2
61895: ARRAY
61896: NOT
61897: AND
61898: IFFALSE 61936
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61900: LD_ADDR_EXP 63
61904: PUSH
61905: LD_EXP 63
61909: PPUSH
61910: LD_VAR 0 2
61914: PPUSH
61915: EMPTY
61916: PPUSH
61917: CALL_OW 1
61921: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61922: LD_VAR 0 2
61926: PPUSH
61927: LD_INT 102
61929: PPUSH
61930: CALL 56071 0 2
// continue ;
61934: GO 61863
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61936: LD_ADDR_VAR 0 4
61940: PUSH
61941: LD_EXP 59
61945: PUSH
61946: LD_VAR 0 2
61950: ARRAY
61951: PPUSH
61952: LD_INT 25
61954: PUSH
61955: LD_INT 4
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL_OW 72
61966: ST_TO_ADDR
// if not tmp then
61967: LD_VAR 0 4
61971: NOT
61972: IFFALSE 61976
// continue ;
61974: GO 61863
// if mc_taming [ i ] then
61976: LD_EXP 90
61980: PUSH
61981: LD_VAR 0 2
61985: ARRAY
61986: IFFALSE 62010
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61988: LD_ADDR_EXP 90
61992: PUSH
61993: LD_EXP 90
61997: PPUSH
61998: LD_VAR 0 2
62002: PPUSH
62003: EMPTY
62004: PPUSH
62005: CALL_OW 1
62009: ST_TO_ADDR
// for j in tmp do
62010: LD_ADDR_VAR 0 3
62014: PUSH
62015: LD_VAR 0 4
62019: PUSH
62020: FOR_IN
62021: IFFALSE 62244
// begin if IsInUnit ( j ) then
62023: LD_VAR 0 3
62027: PPUSH
62028: CALL_OW 310
62032: IFFALSE 62043
// ComExitBuilding ( j ) ;
62034: LD_VAR 0 3
62038: PPUSH
62039: CALL_OW 122
// if not j in mc_healers [ i ] then
62043: LD_VAR 0 3
62047: PUSH
62048: LD_EXP 63
62052: PUSH
62053: LD_VAR 0 2
62057: ARRAY
62058: IN
62059: NOT
62060: IFFALSE 62106
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62062: LD_ADDR_EXP 63
62066: PUSH
62067: LD_EXP 63
62071: PPUSH
62072: LD_VAR 0 2
62076: PUSH
62077: LD_EXP 63
62081: PUSH
62082: LD_VAR 0 2
62086: ARRAY
62087: PUSH
62088: LD_INT 1
62090: PLUS
62091: PUSH
62092: EMPTY
62093: LIST
62094: LIST
62095: PPUSH
62096: LD_VAR 0 3
62100: PPUSH
62101: CALL 19283 0 3
62105: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62106: LD_VAR 0 3
62110: PPUSH
62111: CALL_OW 110
62115: PUSH
62116: LD_INT 102
62118: NONEQUAL
62119: IFFALSE 62133
// SetTag ( j , 102 ) ;
62121: LD_VAR 0 3
62125: PPUSH
62126: LD_INT 102
62128: PPUSH
62129: CALL_OW 109
// Wait ( 3 ) ;
62133: LD_INT 3
62135: PPUSH
62136: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62140: LD_EXP 62
62144: PUSH
62145: LD_VAR 0 2
62149: ARRAY
62150: PUSH
62151: LD_INT 1
62153: ARRAY
62154: IFFALSE 62186
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62156: LD_VAR 0 3
62160: PPUSH
62161: LD_EXP 62
62165: PUSH
62166: LD_VAR 0 2
62170: ARRAY
62171: PUSH
62172: LD_INT 1
62174: ARRAY
62175: PUSH
62176: LD_INT 1
62178: ARRAY
62179: PPUSH
62180: CALL_OW 128
62184: GO 62242
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62186: LD_VAR 0 3
62190: PPUSH
62191: CALL_OW 314
62195: NOT
62196: PUSH
62197: LD_EXP 62
62201: PUSH
62202: LD_VAR 0 2
62206: ARRAY
62207: PUSH
62208: LD_INT 2
62210: ARRAY
62211: AND
62212: IFFALSE 62242
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62214: LD_VAR 0 3
62218: PPUSH
62219: LD_EXP 62
62223: PUSH
62224: LD_VAR 0 2
62228: ARRAY
62229: PUSH
62230: LD_INT 2
62232: ARRAY
62233: PUSH
62234: LD_INT 1
62236: ARRAY
62237: PPUSH
62238: CALL_OW 128
// end ;
62242: GO 62020
62244: POP
62245: POP
// end ;
62246: GO 61863
62248: POP
62249: POP
// end ;
62250: LD_VAR 0 1
62254: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62255: LD_INT 0
62257: PPUSH
62258: PPUSH
62259: PPUSH
62260: PPUSH
62261: PPUSH
// if not mc_bases then
62262: LD_EXP 59
62266: NOT
62267: IFFALSE 62271
// exit ;
62269: GO 63442
// for i = 1 to mc_bases do
62271: LD_ADDR_VAR 0 2
62275: PUSH
62276: DOUBLE
62277: LD_INT 1
62279: DEC
62280: ST_TO_ADDR
62281: LD_EXP 59
62285: PUSH
62286: FOR_TO
62287: IFFALSE 63440
// begin if mc_scan [ i ] then
62289: LD_EXP 82
62293: PUSH
62294: LD_VAR 0 2
62298: ARRAY
62299: IFFALSE 62303
// continue ;
62301: GO 62286
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62303: LD_EXP 64
62307: PUSH
62308: LD_VAR 0 2
62312: ARRAY
62313: NOT
62314: PUSH
62315: LD_EXP 66
62319: PUSH
62320: LD_VAR 0 2
62324: ARRAY
62325: NOT
62326: AND
62327: PUSH
62328: LD_EXP 65
62332: PUSH
62333: LD_VAR 0 2
62337: ARRAY
62338: AND
62339: IFFALSE 62377
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62341: LD_ADDR_EXP 65
62345: PUSH
62346: LD_EXP 65
62350: PPUSH
62351: LD_VAR 0 2
62355: PPUSH
62356: EMPTY
62357: PPUSH
62358: CALL_OW 1
62362: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62363: LD_VAR 0 2
62367: PPUSH
62368: LD_INT 103
62370: PPUSH
62371: CALL 56071 0 2
// continue ;
62375: GO 62286
// end ; if mc_construct_list [ i ] then
62377: LD_EXP 66
62381: PUSH
62382: LD_VAR 0 2
62386: ARRAY
62387: IFFALSE 62607
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62389: LD_ADDR_VAR 0 4
62393: PUSH
62394: LD_EXP 59
62398: PUSH
62399: LD_VAR 0 2
62403: ARRAY
62404: PPUSH
62405: LD_INT 25
62407: PUSH
62408: LD_INT 2
62410: PUSH
62411: EMPTY
62412: LIST
62413: LIST
62414: PPUSH
62415: CALL_OW 72
62419: PUSH
62420: LD_EXP 61
62424: PUSH
62425: LD_VAR 0 2
62429: ARRAY
62430: DIFF
62431: ST_TO_ADDR
// if not tmp then
62432: LD_VAR 0 4
62436: NOT
62437: IFFALSE 62441
// continue ;
62439: GO 62286
// for j in tmp do
62441: LD_ADDR_VAR 0 3
62445: PUSH
62446: LD_VAR 0 4
62450: PUSH
62451: FOR_IN
62452: IFFALSE 62603
// begin if not mc_builders [ i ] then
62454: LD_EXP 65
62458: PUSH
62459: LD_VAR 0 2
62463: ARRAY
62464: NOT
62465: IFFALSE 62523
// begin SetTag ( j , 103 ) ;
62467: LD_VAR 0 3
62471: PPUSH
62472: LD_INT 103
62474: PPUSH
62475: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62479: LD_ADDR_EXP 65
62483: PUSH
62484: LD_EXP 65
62488: PPUSH
62489: LD_VAR 0 2
62493: PUSH
62494: LD_EXP 65
62498: PUSH
62499: LD_VAR 0 2
62503: ARRAY
62504: PUSH
62505: LD_INT 1
62507: PLUS
62508: PUSH
62509: EMPTY
62510: LIST
62511: LIST
62512: PPUSH
62513: LD_VAR 0 3
62517: PPUSH
62518: CALL 19283 0 3
62522: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62523: LD_VAR 0 3
62527: PPUSH
62528: CALL_OW 310
62532: IFFALSE 62543
// ComExitBuilding ( j ) ;
62534: LD_VAR 0 3
62538: PPUSH
62539: CALL_OW 122
// wait ( 3 ) ;
62543: LD_INT 3
62545: PPUSH
62546: CALL_OW 67
// if not mc_construct_list [ i ] then
62550: LD_EXP 66
62554: PUSH
62555: LD_VAR 0 2
62559: ARRAY
62560: NOT
62561: IFFALSE 62565
// break ;
62563: GO 62603
// if not HasTask ( j ) then
62565: LD_VAR 0 3
62569: PPUSH
62570: CALL_OW 314
62574: NOT
62575: IFFALSE 62601
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62577: LD_VAR 0 3
62581: PPUSH
62582: LD_EXP 66
62586: PUSH
62587: LD_VAR 0 2
62591: ARRAY
62592: PUSH
62593: LD_INT 1
62595: ARRAY
62596: PPUSH
62597: CALL 22140 0 2
// end ;
62601: GO 62451
62603: POP
62604: POP
// end else
62605: GO 63438
// if mc_build_list [ i ] then
62607: LD_EXP 64
62611: PUSH
62612: LD_VAR 0 2
62616: ARRAY
62617: IFFALSE 63438
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62619: LD_ADDR_VAR 0 5
62623: PUSH
62624: LD_EXP 59
62628: PUSH
62629: LD_VAR 0 2
62633: ARRAY
62634: PPUSH
62635: LD_INT 2
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: LD_INT 0
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 30
62650: PUSH
62651: LD_INT 1
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: LIST
62662: PPUSH
62663: CALL_OW 72
62667: ST_TO_ADDR
// if depot then
62668: LD_VAR 0 5
62672: IFFALSE 62690
// depot := depot [ 1 ] else
62674: LD_ADDR_VAR 0 5
62678: PUSH
62679: LD_VAR 0 5
62683: PUSH
62684: LD_INT 1
62686: ARRAY
62687: ST_TO_ADDR
62688: GO 62698
// depot := 0 ;
62690: LD_ADDR_VAR 0 5
62694: PUSH
62695: LD_INT 0
62697: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62698: LD_EXP 64
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: PUSH
62709: LD_INT 1
62711: ARRAY
62712: PUSH
62713: LD_INT 1
62715: ARRAY
62716: PPUSH
62717: CALL 21964 0 1
62721: PUSH
62722: LD_EXP 59
62726: PUSH
62727: LD_VAR 0 2
62731: ARRAY
62732: PPUSH
62733: LD_INT 2
62735: PUSH
62736: LD_INT 30
62738: PUSH
62739: LD_INT 2
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: PUSH
62746: LD_INT 30
62748: PUSH
62749: LD_INT 3
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: LIST
62760: PPUSH
62761: CALL_OW 72
62765: NOT
62766: AND
62767: IFFALSE 62872
// begin for j = 1 to mc_build_list [ i ] do
62769: LD_ADDR_VAR 0 3
62773: PUSH
62774: DOUBLE
62775: LD_INT 1
62777: DEC
62778: ST_TO_ADDR
62779: LD_EXP 64
62783: PUSH
62784: LD_VAR 0 2
62788: ARRAY
62789: PUSH
62790: FOR_TO
62791: IFFALSE 62870
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62793: LD_EXP 64
62797: PUSH
62798: LD_VAR 0 2
62802: ARRAY
62803: PUSH
62804: LD_VAR 0 3
62808: ARRAY
62809: PUSH
62810: LD_INT 1
62812: ARRAY
62813: PUSH
62814: LD_INT 2
62816: EQUAL
62817: IFFALSE 62868
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62819: LD_ADDR_EXP 64
62823: PUSH
62824: LD_EXP 64
62828: PPUSH
62829: LD_VAR 0 2
62833: PPUSH
62834: LD_EXP 64
62838: PUSH
62839: LD_VAR 0 2
62843: ARRAY
62844: PPUSH
62845: LD_VAR 0 3
62849: PPUSH
62850: LD_INT 1
62852: PPUSH
62853: LD_INT 0
62855: PPUSH
62856: CALL 18701 0 4
62860: PPUSH
62861: CALL_OW 1
62865: ST_TO_ADDR
// break ;
62866: GO 62870
// end ;
62868: GO 62790
62870: POP
62871: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62872: LD_EXP 64
62876: PUSH
62877: LD_VAR 0 2
62881: ARRAY
62882: PUSH
62883: LD_INT 1
62885: ARRAY
62886: PUSH
62887: LD_INT 1
62889: ARRAY
62890: PUSH
62891: LD_INT 0
62893: EQUAL
62894: PUSH
62895: LD_VAR 0 5
62899: PUSH
62900: LD_VAR 0 5
62904: PPUSH
62905: LD_EXP 64
62909: PUSH
62910: LD_VAR 0 2
62914: ARRAY
62915: PUSH
62916: LD_INT 1
62918: ARRAY
62919: PUSH
62920: LD_INT 1
62922: ARRAY
62923: PPUSH
62924: LD_EXP 64
62928: PUSH
62929: LD_VAR 0 2
62933: ARRAY
62934: PUSH
62935: LD_INT 1
62937: ARRAY
62938: PUSH
62939: LD_INT 2
62941: ARRAY
62942: PPUSH
62943: LD_EXP 64
62947: PUSH
62948: LD_VAR 0 2
62952: ARRAY
62953: PUSH
62954: LD_INT 1
62956: ARRAY
62957: PUSH
62958: LD_INT 3
62960: ARRAY
62961: PPUSH
62962: LD_EXP 64
62966: PUSH
62967: LD_VAR 0 2
62971: ARRAY
62972: PUSH
62973: LD_INT 1
62975: ARRAY
62976: PUSH
62977: LD_INT 4
62979: ARRAY
62980: PPUSH
62981: CALL 27031 0 5
62985: AND
62986: OR
62987: IFFALSE 63268
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62989: LD_ADDR_VAR 0 4
62993: PUSH
62994: LD_EXP 59
62998: PUSH
62999: LD_VAR 0 2
63003: ARRAY
63004: PPUSH
63005: LD_INT 25
63007: PUSH
63008: LD_INT 2
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PPUSH
63015: CALL_OW 72
63019: PUSH
63020: LD_EXP 61
63024: PUSH
63025: LD_VAR 0 2
63029: ARRAY
63030: DIFF
63031: ST_TO_ADDR
// if not tmp then
63032: LD_VAR 0 4
63036: NOT
63037: IFFALSE 63041
// continue ;
63039: GO 62286
// for j in tmp do
63041: LD_ADDR_VAR 0 3
63045: PUSH
63046: LD_VAR 0 4
63050: PUSH
63051: FOR_IN
63052: IFFALSE 63264
// begin if not mc_builders [ i ] then
63054: LD_EXP 65
63058: PUSH
63059: LD_VAR 0 2
63063: ARRAY
63064: NOT
63065: IFFALSE 63123
// begin SetTag ( j , 103 ) ;
63067: LD_VAR 0 3
63071: PPUSH
63072: LD_INT 103
63074: PPUSH
63075: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63079: LD_ADDR_EXP 65
63083: PUSH
63084: LD_EXP 65
63088: PPUSH
63089: LD_VAR 0 2
63093: PUSH
63094: LD_EXP 65
63098: PUSH
63099: LD_VAR 0 2
63103: ARRAY
63104: PUSH
63105: LD_INT 1
63107: PLUS
63108: PUSH
63109: EMPTY
63110: LIST
63111: LIST
63112: PPUSH
63113: LD_VAR 0 3
63117: PPUSH
63118: CALL 19283 0 3
63122: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63123: LD_VAR 0 3
63127: PPUSH
63128: CALL_OW 310
63132: IFFALSE 63143
// ComExitBuilding ( j ) ;
63134: LD_VAR 0 3
63138: PPUSH
63139: CALL_OW 122
// wait ( 3 ) ;
63143: LD_INT 3
63145: PPUSH
63146: CALL_OW 67
// if not mc_build_list [ i ] then
63150: LD_EXP 64
63154: PUSH
63155: LD_VAR 0 2
63159: ARRAY
63160: NOT
63161: IFFALSE 63165
// break ;
63163: GO 63264
// if not HasTask ( j ) then
63165: LD_VAR 0 3
63169: PPUSH
63170: CALL_OW 314
63174: NOT
63175: IFFALSE 63262
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63177: LD_VAR 0 3
63181: PPUSH
63182: LD_EXP 64
63186: PUSH
63187: LD_VAR 0 2
63191: ARRAY
63192: PUSH
63193: LD_INT 1
63195: ARRAY
63196: PUSH
63197: LD_INT 1
63199: ARRAY
63200: PPUSH
63201: LD_EXP 64
63205: PUSH
63206: LD_VAR 0 2
63210: ARRAY
63211: PUSH
63212: LD_INT 1
63214: ARRAY
63215: PUSH
63216: LD_INT 2
63218: ARRAY
63219: PPUSH
63220: LD_EXP 64
63224: PUSH
63225: LD_VAR 0 2
63229: ARRAY
63230: PUSH
63231: LD_INT 1
63233: ARRAY
63234: PUSH
63235: LD_INT 3
63237: ARRAY
63238: PPUSH
63239: LD_EXP 64
63243: PUSH
63244: LD_VAR 0 2
63248: ARRAY
63249: PUSH
63250: LD_INT 1
63252: ARRAY
63253: PUSH
63254: LD_INT 4
63256: ARRAY
63257: PPUSH
63258: CALL_OW 145
// end ;
63262: GO 63051
63264: POP
63265: POP
// end else
63266: GO 63438
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63268: LD_EXP 59
63272: PUSH
63273: LD_VAR 0 2
63277: ARRAY
63278: PPUSH
63279: LD_EXP 64
63283: PUSH
63284: LD_VAR 0 2
63288: ARRAY
63289: PUSH
63290: LD_INT 1
63292: ARRAY
63293: PUSH
63294: LD_INT 1
63296: ARRAY
63297: PPUSH
63298: LD_EXP 64
63302: PUSH
63303: LD_VAR 0 2
63307: ARRAY
63308: PUSH
63309: LD_INT 1
63311: ARRAY
63312: PUSH
63313: LD_INT 2
63315: ARRAY
63316: PPUSH
63317: LD_EXP 64
63321: PUSH
63322: LD_VAR 0 2
63326: ARRAY
63327: PUSH
63328: LD_INT 1
63330: ARRAY
63331: PUSH
63332: LD_INT 3
63334: ARRAY
63335: PPUSH
63336: LD_EXP 64
63340: PUSH
63341: LD_VAR 0 2
63345: ARRAY
63346: PUSH
63347: LD_INT 1
63349: ARRAY
63350: PUSH
63351: LD_INT 4
63353: ARRAY
63354: PPUSH
63355: LD_EXP 59
63359: PUSH
63360: LD_VAR 0 2
63364: ARRAY
63365: PPUSH
63366: LD_INT 21
63368: PUSH
63369: LD_INT 3
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PPUSH
63376: CALL_OW 72
63380: PPUSH
63381: EMPTY
63382: PPUSH
63383: CALL 26161 0 7
63387: NOT
63388: IFFALSE 63438
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63390: LD_ADDR_EXP 64
63394: PUSH
63395: LD_EXP 64
63399: PPUSH
63400: LD_VAR 0 2
63404: PPUSH
63405: LD_EXP 64
63409: PUSH
63410: LD_VAR 0 2
63414: ARRAY
63415: PPUSH
63416: LD_INT 1
63418: PPUSH
63419: LD_INT 1
63421: NEG
63422: PPUSH
63423: LD_INT 0
63425: PPUSH
63426: CALL 18701 0 4
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// continue ;
63436: GO 62286
// end ; end ; end ;
63438: GO 62286
63440: POP
63441: POP
// end ;
63442: LD_VAR 0 1
63446: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63447: LD_INT 0
63449: PPUSH
63450: PPUSH
63451: PPUSH
63452: PPUSH
63453: PPUSH
63454: PPUSH
// if not mc_bases then
63455: LD_EXP 59
63459: NOT
63460: IFFALSE 63464
// exit ;
63462: GO 63891
// for i = 1 to mc_bases do
63464: LD_ADDR_VAR 0 2
63468: PUSH
63469: DOUBLE
63470: LD_INT 1
63472: DEC
63473: ST_TO_ADDR
63474: LD_EXP 59
63478: PUSH
63479: FOR_TO
63480: IFFALSE 63889
// begin tmp := mc_build_upgrade [ i ] ;
63482: LD_ADDR_VAR 0 4
63486: PUSH
63487: LD_EXP 91
63491: PUSH
63492: LD_VAR 0 2
63496: ARRAY
63497: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63498: LD_ADDR_VAR 0 6
63502: PUSH
63503: LD_EXP 92
63507: PUSH
63508: LD_VAR 0 2
63512: ARRAY
63513: PPUSH
63514: LD_INT 2
63516: PUSH
63517: LD_INT 30
63519: PUSH
63520: LD_INT 6
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: PUSH
63527: LD_INT 30
63529: PUSH
63530: LD_INT 7
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: PUSH
63537: EMPTY
63538: LIST
63539: LIST
63540: LIST
63541: PPUSH
63542: CALL_OW 72
63546: ST_TO_ADDR
// if not tmp and not lab then
63547: LD_VAR 0 4
63551: NOT
63552: PUSH
63553: LD_VAR 0 6
63557: NOT
63558: AND
63559: IFFALSE 63563
// continue ;
63561: GO 63479
// if tmp then
63563: LD_VAR 0 4
63567: IFFALSE 63687
// for j in tmp do
63569: LD_ADDR_VAR 0 3
63573: PUSH
63574: LD_VAR 0 4
63578: PUSH
63579: FOR_IN
63580: IFFALSE 63685
// begin if UpgradeCost ( j ) then
63582: LD_VAR 0 3
63586: PPUSH
63587: CALL 25821 0 1
63591: IFFALSE 63683
// begin ComUpgrade ( j ) ;
63593: LD_VAR 0 3
63597: PPUSH
63598: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63602: LD_ADDR_EXP 91
63606: PUSH
63607: LD_EXP 91
63611: PPUSH
63612: LD_VAR 0 2
63616: PPUSH
63617: LD_EXP 91
63621: PUSH
63622: LD_VAR 0 2
63626: ARRAY
63627: PUSH
63628: LD_VAR 0 3
63632: DIFF
63633: PPUSH
63634: CALL_OW 1
63638: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63639: LD_ADDR_EXP 66
63643: PUSH
63644: LD_EXP 66
63648: PPUSH
63649: LD_VAR 0 2
63653: PUSH
63654: LD_EXP 66
63658: PUSH
63659: LD_VAR 0 2
63663: ARRAY
63664: PUSH
63665: LD_INT 1
63667: PLUS
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PPUSH
63673: LD_VAR 0 3
63677: PPUSH
63678: CALL 19283 0 3
63682: ST_TO_ADDR
// end ; end ;
63683: GO 63579
63685: POP
63686: POP
// if not lab or not mc_lab_upgrade [ i ] then
63687: LD_VAR 0 6
63691: NOT
63692: PUSH
63693: LD_EXP 93
63697: PUSH
63698: LD_VAR 0 2
63702: ARRAY
63703: NOT
63704: OR
63705: IFFALSE 63709
// continue ;
63707: GO 63479
// for j in lab do
63709: LD_ADDR_VAR 0 3
63713: PUSH
63714: LD_VAR 0 6
63718: PUSH
63719: FOR_IN
63720: IFFALSE 63885
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63722: LD_VAR 0 3
63726: PPUSH
63727: CALL_OW 266
63731: PUSH
63732: LD_INT 6
63734: PUSH
63735: LD_INT 7
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: IN
63742: PUSH
63743: LD_VAR 0 3
63747: PPUSH
63748: CALL_OW 461
63752: PUSH
63753: LD_INT 1
63755: NONEQUAL
63756: AND
63757: IFFALSE 63883
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63759: LD_VAR 0 3
63763: PPUSH
63764: LD_EXP 93
63768: PUSH
63769: LD_VAR 0 2
63773: ARRAY
63774: PUSH
63775: LD_INT 1
63777: ARRAY
63778: PPUSH
63779: CALL 26026 0 2
63783: IFFALSE 63883
// begin ComCancel ( j ) ;
63785: LD_VAR 0 3
63789: PPUSH
63790: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63794: LD_VAR 0 3
63798: PPUSH
63799: LD_EXP 93
63803: PUSH
63804: LD_VAR 0 2
63808: ARRAY
63809: PUSH
63810: LD_INT 1
63812: ARRAY
63813: PPUSH
63814: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63818: LD_VAR 0 3
63822: PUSH
63823: LD_EXP 66
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: IN
63834: NOT
63835: IFFALSE 63881
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63837: LD_ADDR_EXP 66
63841: PUSH
63842: LD_EXP 66
63846: PPUSH
63847: LD_VAR 0 2
63851: PUSH
63852: LD_EXP 66
63856: PUSH
63857: LD_VAR 0 2
63861: ARRAY
63862: PUSH
63863: LD_INT 1
63865: PLUS
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PPUSH
63871: LD_VAR 0 3
63875: PPUSH
63876: CALL 19283 0 3
63880: ST_TO_ADDR
// break ;
63881: GO 63885
// end ; end ; end ;
63883: GO 63719
63885: POP
63886: POP
// end ;
63887: GO 63479
63889: POP
63890: POP
// end ;
63891: LD_VAR 0 1
63895: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63896: LD_INT 0
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
63904: PPUSH
63905: PPUSH
63906: PPUSH
// if not mc_bases then
63907: LD_EXP 59
63911: NOT
63912: IFFALSE 63916
// exit ;
63914: GO 64321
// for i = 1 to mc_bases do
63916: LD_ADDR_VAR 0 2
63920: PUSH
63921: DOUBLE
63922: LD_INT 1
63924: DEC
63925: ST_TO_ADDR
63926: LD_EXP 59
63930: PUSH
63931: FOR_TO
63932: IFFALSE 64319
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63934: LD_EXP 67
63938: PUSH
63939: LD_VAR 0 2
63943: ARRAY
63944: NOT
63945: PUSH
63946: LD_EXP 59
63950: PUSH
63951: LD_VAR 0 2
63955: ARRAY
63956: PPUSH
63957: LD_INT 30
63959: PUSH
63960: LD_INT 3
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PPUSH
63967: CALL_OW 72
63971: NOT
63972: OR
63973: IFFALSE 63977
// continue ;
63975: GO 63931
// busy := false ;
63977: LD_ADDR_VAR 0 8
63981: PUSH
63982: LD_INT 0
63984: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63985: LD_ADDR_VAR 0 4
63989: PUSH
63990: LD_EXP 59
63994: PUSH
63995: LD_VAR 0 2
63999: ARRAY
64000: PPUSH
64001: LD_INT 30
64003: PUSH
64004: LD_INT 3
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PPUSH
64011: CALL_OW 72
64015: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64016: LD_ADDR_VAR 0 6
64020: PUSH
64021: LD_EXP 67
64025: PUSH
64026: LD_VAR 0 2
64030: ARRAY
64031: PPUSH
64032: LD_INT 2
64034: PUSH
64035: LD_INT 30
64037: PUSH
64038: LD_INT 32
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: PUSH
64045: LD_INT 30
64047: PUSH
64048: LD_INT 33
64050: PUSH
64051: EMPTY
64052: LIST
64053: LIST
64054: PUSH
64055: EMPTY
64056: LIST
64057: LIST
64058: LIST
64059: PPUSH
64060: CALL_OW 72
64064: ST_TO_ADDR
// if not t then
64065: LD_VAR 0 6
64069: NOT
64070: IFFALSE 64074
// continue ;
64072: GO 63931
// for j in tmp do
64074: LD_ADDR_VAR 0 3
64078: PUSH
64079: LD_VAR 0 4
64083: PUSH
64084: FOR_IN
64085: IFFALSE 64115
// if not BuildingStatus ( j ) = bs_idle then
64087: LD_VAR 0 3
64091: PPUSH
64092: CALL_OW 461
64096: PUSH
64097: LD_INT 2
64099: EQUAL
64100: NOT
64101: IFFALSE 64113
// begin busy := true ;
64103: LD_ADDR_VAR 0 8
64107: PUSH
64108: LD_INT 1
64110: ST_TO_ADDR
// break ;
64111: GO 64115
// end ;
64113: GO 64084
64115: POP
64116: POP
// if busy then
64117: LD_VAR 0 8
64121: IFFALSE 64125
// continue ;
64123: GO 63931
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64125: LD_ADDR_VAR 0 7
64129: PUSH
64130: LD_VAR 0 6
64134: PPUSH
64135: LD_INT 35
64137: PUSH
64138: LD_INT 0
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PPUSH
64145: CALL_OW 72
64149: ST_TO_ADDR
// if tw then
64150: LD_VAR 0 7
64154: IFFALSE 64231
// begin tw := tw [ 1 ] ;
64156: LD_ADDR_VAR 0 7
64160: PUSH
64161: LD_VAR 0 7
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64170: LD_ADDR_VAR 0 9
64174: PUSH
64175: LD_VAR 0 7
64179: PPUSH
64180: LD_EXP 84
64184: PUSH
64185: LD_VAR 0 2
64189: ARRAY
64190: PPUSH
64191: CALL 24288 0 2
64195: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64196: LD_EXP 98
64200: PUSH
64201: LD_VAR 0 2
64205: ARRAY
64206: IFFALSE 64229
// if not weapon in mc_allowed_tower_weapons [ i ] then
64208: LD_VAR 0 9
64212: PUSH
64213: LD_EXP 98
64217: PUSH
64218: LD_VAR 0 2
64222: ARRAY
64223: IN
64224: NOT
64225: IFFALSE 64229
// continue ;
64227: GO 63931
// end else
64229: GO 64294
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64231: LD_ADDR_VAR 0 5
64235: PUSH
64236: LD_EXP 67
64240: PUSH
64241: LD_VAR 0 2
64245: ARRAY
64246: PPUSH
64247: LD_VAR 0 4
64251: PPUSH
64252: CALL 50207 0 2
64256: ST_TO_ADDR
// if not tmp2 then
64257: LD_VAR 0 5
64261: NOT
64262: IFFALSE 64266
// continue ;
64264: GO 63931
// tw := tmp2 [ 1 ] ;
64266: LD_ADDR_VAR 0 7
64270: PUSH
64271: LD_VAR 0 5
64275: PUSH
64276: LD_INT 1
64278: ARRAY
64279: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64280: LD_ADDR_VAR 0 9
64284: PUSH
64285: LD_VAR 0 5
64289: PUSH
64290: LD_INT 2
64292: ARRAY
64293: ST_TO_ADDR
// end ; if not weapon then
64294: LD_VAR 0 9
64298: NOT
64299: IFFALSE 64303
// continue ;
64301: GO 63931
// ComPlaceWeapon ( tw , weapon ) ;
64303: LD_VAR 0 7
64307: PPUSH
64308: LD_VAR 0 9
64312: PPUSH
64313: CALL_OW 148
// end ;
64317: GO 63931
64319: POP
64320: POP
// end ;
64321: LD_VAR 0 1
64325: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64326: LD_INT 0
64328: PPUSH
64329: PPUSH
64330: PPUSH
64331: PPUSH
64332: PPUSH
64333: PPUSH
64334: PPUSH
// if not mc_bases then
64335: LD_EXP 59
64339: NOT
64340: IFFALSE 64344
// exit ;
64342: GO 65112
// for i = 1 to mc_bases do
64344: LD_ADDR_VAR 0 2
64348: PUSH
64349: DOUBLE
64350: LD_INT 1
64352: DEC
64353: ST_TO_ADDR
64354: LD_EXP 59
64358: PUSH
64359: FOR_TO
64360: IFFALSE 65110
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64362: LD_EXP 72
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: NOT
64373: PUSH
64374: LD_EXP 72
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: PUSH
64385: LD_EXP 73
64389: PUSH
64390: LD_VAR 0 2
64394: ARRAY
64395: EQUAL
64396: OR
64397: PUSH
64398: LD_EXP 82
64402: PUSH
64403: LD_VAR 0 2
64407: ARRAY
64408: OR
64409: IFFALSE 64413
// continue ;
64411: GO 64359
// if mc_miners [ i ] then
64413: LD_EXP 73
64417: PUSH
64418: LD_VAR 0 2
64422: ARRAY
64423: IFFALSE 64797
// begin for j = mc_miners [ i ] downto 1 do
64425: LD_ADDR_VAR 0 3
64429: PUSH
64430: DOUBLE
64431: LD_EXP 73
64435: PUSH
64436: LD_VAR 0 2
64440: ARRAY
64441: INC
64442: ST_TO_ADDR
64443: LD_INT 1
64445: PUSH
64446: FOR_DOWNTO
64447: IFFALSE 64795
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64449: LD_EXP 73
64453: PUSH
64454: LD_VAR 0 2
64458: ARRAY
64459: PUSH
64460: LD_VAR 0 3
64464: ARRAY
64465: PPUSH
64466: CALL_OW 301
64470: PUSH
64471: LD_EXP 73
64475: PUSH
64476: LD_VAR 0 2
64480: ARRAY
64481: PUSH
64482: LD_VAR 0 3
64486: ARRAY
64487: PPUSH
64488: CALL_OW 257
64492: PUSH
64493: LD_INT 1
64495: NONEQUAL
64496: OR
64497: IFFALSE 64560
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64499: LD_ADDR_VAR 0 5
64503: PUSH
64504: LD_EXP 73
64508: PUSH
64509: LD_VAR 0 2
64513: ARRAY
64514: PUSH
64515: LD_EXP 73
64519: PUSH
64520: LD_VAR 0 2
64524: ARRAY
64525: PUSH
64526: LD_VAR 0 3
64530: ARRAY
64531: DIFF
64532: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64533: LD_ADDR_EXP 73
64537: PUSH
64538: LD_EXP 73
64542: PPUSH
64543: LD_VAR 0 2
64547: PPUSH
64548: LD_VAR 0 5
64552: PPUSH
64553: CALL_OW 1
64557: ST_TO_ADDR
// continue ;
64558: GO 64446
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64560: LD_EXP 73
64564: PUSH
64565: LD_VAR 0 2
64569: ARRAY
64570: PUSH
64571: LD_VAR 0 3
64575: ARRAY
64576: PPUSH
64577: CALL_OW 257
64581: PUSH
64582: LD_INT 1
64584: EQUAL
64585: PUSH
64586: LD_EXP 73
64590: PUSH
64591: LD_VAR 0 2
64595: ARRAY
64596: PUSH
64597: LD_VAR 0 3
64601: ARRAY
64602: PPUSH
64603: CALL_OW 459
64607: NOT
64608: AND
64609: PUSH
64610: LD_EXP 73
64614: PUSH
64615: LD_VAR 0 2
64619: ARRAY
64620: PUSH
64621: LD_VAR 0 3
64625: ARRAY
64626: PPUSH
64627: CALL_OW 314
64631: NOT
64632: AND
64633: IFFALSE 64793
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64635: LD_EXP 73
64639: PUSH
64640: LD_VAR 0 2
64644: ARRAY
64645: PUSH
64646: LD_VAR 0 3
64650: ARRAY
64651: PPUSH
64652: CALL_OW 310
64656: IFFALSE 64679
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64658: LD_EXP 73
64662: PUSH
64663: LD_VAR 0 2
64667: ARRAY
64668: PUSH
64669: LD_VAR 0 3
64673: ARRAY
64674: PPUSH
64675: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64679: LD_EXP 73
64683: PUSH
64684: LD_VAR 0 2
64688: ARRAY
64689: PUSH
64690: LD_VAR 0 3
64694: ARRAY
64695: PPUSH
64696: CALL_OW 314
64700: NOT
64701: IFFALSE 64793
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64703: LD_ADDR_VAR 0 7
64707: PUSH
64708: LD_INT 1
64710: PPUSH
64711: LD_EXP 72
64715: PUSH
64716: LD_VAR 0 2
64720: ARRAY
64721: PPUSH
64722: CALL_OW 12
64726: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64727: LD_EXP 73
64731: PUSH
64732: LD_VAR 0 2
64736: ARRAY
64737: PUSH
64738: LD_VAR 0 3
64742: ARRAY
64743: PPUSH
64744: LD_EXP 72
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: PUSH
64755: LD_VAR 0 7
64759: ARRAY
64760: PUSH
64761: LD_INT 1
64763: ARRAY
64764: PPUSH
64765: LD_EXP 72
64769: PUSH
64770: LD_VAR 0 2
64774: ARRAY
64775: PUSH
64776: LD_VAR 0 7
64780: ARRAY
64781: PUSH
64782: LD_INT 2
64784: ARRAY
64785: PPUSH
64786: LD_INT 0
64788: PPUSH
64789: CALL_OW 193
// end ; end ; end ;
64793: GO 64446
64795: POP
64796: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64797: LD_ADDR_VAR 0 5
64801: PUSH
64802: LD_EXP 59
64806: PUSH
64807: LD_VAR 0 2
64811: ARRAY
64812: PPUSH
64813: LD_INT 2
64815: PUSH
64816: LD_INT 30
64818: PUSH
64819: LD_INT 4
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: PUSH
64826: LD_INT 30
64828: PUSH
64829: LD_INT 5
64831: PUSH
64832: EMPTY
64833: LIST
64834: LIST
64835: PUSH
64836: LD_INT 30
64838: PUSH
64839: LD_INT 32
64841: PUSH
64842: EMPTY
64843: LIST
64844: LIST
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: LIST
64850: LIST
64851: PPUSH
64852: CALL_OW 72
64856: ST_TO_ADDR
// if not tmp then
64857: LD_VAR 0 5
64861: NOT
64862: IFFALSE 64866
// continue ;
64864: GO 64359
// list := [ ] ;
64866: LD_ADDR_VAR 0 6
64870: PUSH
64871: EMPTY
64872: ST_TO_ADDR
// for j in tmp do
64873: LD_ADDR_VAR 0 3
64877: PUSH
64878: LD_VAR 0 5
64882: PUSH
64883: FOR_IN
64884: IFFALSE 64953
// begin for k in UnitsInside ( j ) do
64886: LD_ADDR_VAR 0 4
64890: PUSH
64891: LD_VAR 0 3
64895: PPUSH
64896: CALL_OW 313
64900: PUSH
64901: FOR_IN
64902: IFFALSE 64949
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64904: LD_VAR 0 4
64908: PPUSH
64909: CALL_OW 257
64913: PUSH
64914: LD_INT 1
64916: EQUAL
64917: PUSH
64918: LD_VAR 0 4
64922: PPUSH
64923: CALL_OW 459
64927: NOT
64928: AND
64929: IFFALSE 64947
// list := list ^ k ;
64931: LD_ADDR_VAR 0 6
64935: PUSH
64936: LD_VAR 0 6
64940: PUSH
64941: LD_VAR 0 4
64945: ADD
64946: ST_TO_ADDR
64947: GO 64901
64949: POP
64950: POP
// end ;
64951: GO 64883
64953: POP
64954: POP
// list := list diff mc_miners [ i ] ;
64955: LD_ADDR_VAR 0 6
64959: PUSH
64960: LD_VAR 0 6
64964: PUSH
64965: LD_EXP 73
64969: PUSH
64970: LD_VAR 0 2
64974: ARRAY
64975: DIFF
64976: ST_TO_ADDR
// if not list then
64977: LD_VAR 0 6
64981: NOT
64982: IFFALSE 64986
// continue ;
64984: GO 64359
// k := mc_mines [ i ] - mc_miners [ i ] ;
64986: LD_ADDR_VAR 0 4
64990: PUSH
64991: LD_EXP 72
64995: PUSH
64996: LD_VAR 0 2
65000: ARRAY
65001: PUSH
65002: LD_EXP 73
65006: PUSH
65007: LD_VAR 0 2
65011: ARRAY
65012: MINUS
65013: ST_TO_ADDR
// if k > list then
65014: LD_VAR 0 4
65018: PUSH
65019: LD_VAR 0 6
65023: GREATER
65024: IFFALSE 65036
// k := list ;
65026: LD_ADDR_VAR 0 4
65030: PUSH
65031: LD_VAR 0 6
65035: ST_TO_ADDR
// for j = 1 to k do
65036: LD_ADDR_VAR 0 3
65040: PUSH
65041: DOUBLE
65042: LD_INT 1
65044: DEC
65045: ST_TO_ADDR
65046: LD_VAR 0 4
65050: PUSH
65051: FOR_TO
65052: IFFALSE 65106
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65054: LD_ADDR_EXP 73
65058: PUSH
65059: LD_EXP 73
65063: PPUSH
65064: LD_VAR 0 2
65068: PUSH
65069: LD_EXP 73
65073: PUSH
65074: LD_VAR 0 2
65078: ARRAY
65079: PUSH
65080: LD_INT 1
65082: PLUS
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PPUSH
65088: LD_VAR 0 6
65092: PUSH
65093: LD_VAR 0 3
65097: ARRAY
65098: PPUSH
65099: CALL 19283 0 3
65103: ST_TO_ADDR
65104: GO 65051
65106: POP
65107: POP
// end ;
65108: GO 64359
65110: POP
65111: POP
// end ;
65112: LD_VAR 0 1
65116: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
65117: LD_INT 0
65119: PPUSH
65120: PPUSH
65121: PPUSH
65122: PPUSH
65123: PPUSH
65124: PPUSH
65125: PPUSH
65126: PPUSH
65127: PPUSH
65128: PPUSH
// if not mc_bases then
65129: LD_EXP 59
65133: NOT
65134: IFFALSE 65138
// exit ;
65136: GO 66888
// for i = 1 to mc_bases do
65138: LD_ADDR_VAR 0 2
65142: PUSH
65143: DOUBLE
65144: LD_INT 1
65146: DEC
65147: ST_TO_ADDR
65148: LD_EXP 59
65152: PUSH
65153: FOR_TO
65154: IFFALSE 66886
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65156: LD_EXP 59
65160: PUSH
65161: LD_VAR 0 2
65165: ARRAY
65166: NOT
65167: PUSH
65168: LD_EXP 66
65172: PUSH
65173: LD_VAR 0 2
65177: ARRAY
65178: OR
65179: IFFALSE 65183
// continue ;
65181: GO 65153
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65183: LD_EXP 75
65187: PUSH
65188: LD_VAR 0 2
65192: ARRAY
65193: NOT
65194: PUSH
65195: LD_EXP 76
65199: PUSH
65200: LD_VAR 0 2
65204: ARRAY
65205: AND
65206: IFFALSE 65244
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65208: LD_ADDR_EXP 76
65212: PUSH
65213: LD_EXP 76
65217: PPUSH
65218: LD_VAR 0 2
65222: PPUSH
65223: EMPTY
65224: PPUSH
65225: CALL_OW 1
65229: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65230: LD_VAR 0 2
65234: PPUSH
65235: LD_INT 107
65237: PPUSH
65238: CALL 56071 0 2
// continue ;
65242: GO 65153
// end ; target := [ ] ;
65244: LD_ADDR_VAR 0 6
65248: PUSH
65249: EMPTY
65250: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65251: LD_ADDR_VAR 0 3
65255: PUSH
65256: DOUBLE
65257: LD_EXP 75
65261: PUSH
65262: LD_VAR 0 2
65266: ARRAY
65267: INC
65268: ST_TO_ADDR
65269: LD_INT 1
65271: PUSH
65272: FOR_DOWNTO
65273: IFFALSE 65533
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65275: LD_EXP 75
65279: PUSH
65280: LD_VAR 0 2
65284: ARRAY
65285: PUSH
65286: LD_VAR 0 3
65290: ARRAY
65291: PUSH
65292: LD_INT 2
65294: ARRAY
65295: PPUSH
65296: LD_EXP 75
65300: PUSH
65301: LD_VAR 0 2
65305: ARRAY
65306: PUSH
65307: LD_VAR 0 3
65311: ARRAY
65312: PUSH
65313: LD_INT 3
65315: ARRAY
65316: PPUSH
65317: CALL_OW 488
65321: PUSH
65322: LD_EXP 75
65326: PUSH
65327: LD_VAR 0 2
65331: ARRAY
65332: PUSH
65333: LD_VAR 0 3
65337: ARRAY
65338: PUSH
65339: LD_INT 2
65341: ARRAY
65342: PPUSH
65343: LD_EXP 75
65347: PUSH
65348: LD_VAR 0 2
65352: ARRAY
65353: PUSH
65354: LD_VAR 0 3
65358: ARRAY
65359: PUSH
65360: LD_INT 3
65362: ARRAY
65363: PPUSH
65364: CALL_OW 284
65368: PUSH
65369: LD_INT 0
65371: EQUAL
65372: AND
65373: IFFALSE 65428
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65375: LD_ADDR_VAR 0 5
65379: PUSH
65380: LD_EXP 75
65384: PUSH
65385: LD_VAR 0 2
65389: ARRAY
65390: PPUSH
65391: LD_VAR 0 3
65395: PPUSH
65396: CALL_OW 3
65400: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65401: LD_ADDR_EXP 75
65405: PUSH
65406: LD_EXP 75
65410: PPUSH
65411: LD_VAR 0 2
65415: PPUSH
65416: LD_VAR 0 5
65420: PPUSH
65421: CALL_OW 1
65425: ST_TO_ADDR
// continue ;
65426: GO 65272
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65428: LD_EXP 59
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: PUSH
65439: LD_INT 1
65441: ARRAY
65442: PPUSH
65443: CALL_OW 255
65447: PPUSH
65448: LD_EXP 75
65452: PUSH
65453: LD_VAR 0 2
65457: ARRAY
65458: PUSH
65459: LD_VAR 0 3
65463: ARRAY
65464: PUSH
65465: LD_INT 2
65467: ARRAY
65468: PPUSH
65469: LD_EXP 75
65473: PUSH
65474: LD_VAR 0 2
65478: ARRAY
65479: PUSH
65480: LD_VAR 0 3
65484: ARRAY
65485: PUSH
65486: LD_INT 3
65488: ARRAY
65489: PPUSH
65490: LD_INT 30
65492: PPUSH
65493: CALL 20179 0 4
65497: PUSH
65498: LD_INT 4
65500: ARRAY
65501: PUSH
65502: LD_INT 0
65504: EQUAL
65505: IFFALSE 65531
// begin target := mc_crates [ i ] [ j ] ;
65507: LD_ADDR_VAR 0 6
65511: PUSH
65512: LD_EXP 75
65516: PUSH
65517: LD_VAR 0 2
65521: ARRAY
65522: PUSH
65523: LD_VAR 0 3
65527: ARRAY
65528: ST_TO_ADDR
// break ;
65529: GO 65533
// end ; end ;
65531: GO 65272
65533: POP
65534: POP
// if not target then
65535: LD_VAR 0 6
65539: NOT
65540: IFFALSE 65544
// continue ;
65542: GO 65153
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65544: LD_ADDR_VAR 0 7
65548: PUSH
65549: LD_EXP 78
65553: PUSH
65554: LD_VAR 0 2
65558: ARRAY
65559: PPUSH
65560: LD_INT 2
65562: PUSH
65563: LD_INT 3
65565: PUSH
65566: LD_INT 58
65568: PUSH
65569: EMPTY
65570: LIST
65571: PUSH
65572: EMPTY
65573: LIST
65574: LIST
65575: PUSH
65576: LD_INT 61
65578: PUSH
65579: EMPTY
65580: LIST
65581: PUSH
65582: LD_INT 33
65584: PUSH
65585: LD_INT 5
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: LD_INT 33
65594: PUSH
65595: LD_INT 3
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 2
65611: PUSH
65612: LD_INT 34
65614: PUSH
65615: LD_INT 32
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 34
65624: PUSH
65625: LD_INT 51
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 34
65634: PUSH
65635: LD_INT 12
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: LIST
65646: LIST
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PPUSH
65652: CALL_OW 72
65656: ST_TO_ADDR
// if not cargo then
65657: LD_VAR 0 7
65661: NOT
65662: IFFALSE 66305
// begin if mc_crates_collector [ i ] < 5 then
65664: LD_EXP 76
65668: PUSH
65669: LD_VAR 0 2
65673: ARRAY
65674: PUSH
65675: LD_INT 5
65677: LESS
65678: IFFALSE 66044
// begin if mc_ape [ i ] then
65680: LD_EXP 88
65684: PUSH
65685: LD_VAR 0 2
65689: ARRAY
65690: IFFALSE 65737
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65692: LD_ADDR_VAR 0 5
65696: PUSH
65697: LD_EXP 88
65701: PUSH
65702: LD_VAR 0 2
65706: ARRAY
65707: PPUSH
65708: LD_INT 25
65710: PUSH
65711: LD_INT 16
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: LD_INT 24
65720: PUSH
65721: LD_INT 750
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: EMPTY
65729: LIST
65730: LIST
65731: PPUSH
65732: CALL_OW 72
65736: ST_TO_ADDR
// if not tmp then
65737: LD_VAR 0 5
65741: NOT
65742: IFFALSE 65789
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65744: LD_ADDR_VAR 0 5
65748: PUSH
65749: LD_EXP 59
65753: PUSH
65754: LD_VAR 0 2
65758: ARRAY
65759: PPUSH
65760: LD_INT 25
65762: PUSH
65763: LD_INT 2
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 24
65772: PUSH
65773: LD_INT 750
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PPUSH
65784: CALL_OW 72
65788: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65789: LD_EXP 88
65793: PUSH
65794: LD_VAR 0 2
65798: ARRAY
65799: PUSH
65800: LD_EXP 59
65804: PUSH
65805: LD_VAR 0 2
65809: ARRAY
65810: PPUSH
65811: LD_INT 25
65813: PUSH
65814: LD_INT 2
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 24
65823: PUSH
65824: LD_INT 750
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PPUSH
65835: CALL_OW 72
65839: AND
65840: PUSH
65841: LD_VAR 0 5
65845: PUSH
65846: LD_INT 5
65848: LESS
65849: AND
65850: IFFALSE 65932
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65852: LD_ADDR_VAR 0 3
65856: PUSH
65857: LD_EXP 59
65861: PUSH
65862: LD_VAR 0 2
65866: ARRAY
65867: PPUSH
65868: LD_INT 25
65870: PUSH
65871: LD_INT 2
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 24
65880: PUSH
65881: LD_INT 750
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PPUSH
65892: CALL_OW 72
65896: PUSH
65897: FOR_IN
65898: IFFALSE 65930
// begin tmp := tmp union j ;
65900: LD_ADDR_VAR 0 5
65904: PUSH
65905: LD_VAR 0 5
65909: PUSH
65910: LD_VAR 0 3
65914: UNION
65915: ST_TO_ADDR
// if tmp >= 5 then
65916: LD_VAR 0 5
65920: PUSH
65921: LD_INT 5
65923: GREATEREQUAL
65924: IFFALSE 65928
// break ;
65926: GO 65930
// end ;
65928: GO 65897
65930: POP
65931: POP
// end ; if not tmp then
65932: LD_VAR 0 5
65936: NOT
65937: IFFALSE 65941
// continue ;
65939: GO 65153
// for j in tmp do
65941: LD_ADDR_VAR 0 3
65945: PUSH
65946: LD_VAR 0 5
65950: PUSH
65951: FOR_IN
65952: IFFALSE 66042
// if not GetTag ( j ) then
65954: LD_VAR 0 3
65958: PPUSH
65959: CALL_OW 110
65963: NOT
65964: IFFALSE 66040
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65966: LD_ADDR_EXP 76
65970: PUSH
65971: LD_EXP 76
65975: PPUSH
65976: LD_VAR 0 2
65980: PUSH
65981: LD_EXP 76
65985: PUSH
65986: LD_VAR 0 2
65990: ARRAY
65991: PUSH
65992: LD_INT 1
65994: PLUS
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PPUSH
66000: LD_VAR 0 3
66004: PPUSH
66005: CALL 19283 0 3
66009: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66010: LD_VAR 0 3
66014: PPUSH
66015: LD_INT 107
66017: PPUSH
66018: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66022: LD_EXP 76
66026: PUSH
66027: LD_VAR 0 2
66031: ARRAY
66032: PUSH
66033: LD_INT 5
66035: GREATEREQUAL
66036: IFFALSE 66040
// break ;
66038: GO 66042
// end ;
66040: GO 65951
66042: POP
66043: POP
// end ; if mc_crates_collector [ i ] and target then
66044: LD_EXP 76
66048: PUSH
66049: LD_VAR 0 2
66053: ARRAY
66054: PUSH
66055: LD_VAR 0 6
66059: AND
66060: IFFALSE 66303
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66062: LD_EXP 76
66066: PUSH
66067: LD_VAR 0 2
66071: ARRAY
66072: PUSH
66073: LD_VAR 0 6
66077: PUSH
66078: LD_INT 1
66080: ARRAY
66081: LESS
66082: IFFALSE 66102
// tmp := mc_crates_collector [ i ] else
66084: LD_ADDR_VAR 0 5
66088: PUSH
66089: LD_EXP 76
66093: PUSH
66094: LD_VAR 0 2
66098: ARRAY
66099: ST_TO_ADDR
66100: GO 66116
// tmp := target [ 1 ] ;
66102: LD_ADDR_VAR 0 5
66106: PUSH
66107: LD_VAR 0 6
66111: PUSH
66112: LD_INT 1
66114: ARRAY
66115: ST_TO_ADDR
// k := 0 ;
66116: LD_ADDR_VAR 0 4
66120: PUSH
66121: LD_INT 0
66123: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66124: LD_ADDR_VAR 0 3
66128: PUSH
66129: LD_EXP 76
66133: PUSH
66134: LD_VAR 0 2
66138: ARRAY
66139: PUSH
66140: FOR_IN
66141: IFFALSE 66301
// begin k := k + 1 ;
66143: LD_ADDR_VAR 0 4
66147: PUSH
66148: LD_VAR 0 4
66152: PUSH
66153: LD_INT 1
66155: PLUS
66156: ST_TO_ADDR
// if k > tmp then
66157: LD_VAR 0 4
66161: PUSH
66162: LD_VAR 0 5
66166: GREATER
66167: IFFALSE 66171
// break ;
66169: GO 66301
// if not GetClass ( j ) in [ 2 , 16 ] then
66171: LD_VAR 0 3
66175: PPUSH
66176: CALL_OW 257
66180: PUSH
66181: LD_INT 2
66183: PUSH
66184: LD_INT 16
66186: PUSH
66187: EMPTY
66188: LIST
66189: LIST
66190: IN
66191: NOT
66192: IFFALSE 66245
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66194: LD_ADDR_EXP 76
66198: PUSH
66199: LD_EXP 76
66203: PPUSH
66204: LD_VAR 0 2
66208: PPUSH
66209: LD_EXP 76
66213: PUSH
66214: LD_VAR 0 2
66218: ARRAY
66219: PUSH
66220: LD_VAR 0 3
66224: DIFF
66225: PPUSH
66226: CALL_OW 1
66230: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66231: LD_VAR 0 3
66235: PPUSH
66236: LD_INT 0
66238: PPUSH
66239: CALL_OW 109
// continue ;
66243: GO 66140
// end ; if IsInUnit ( j ) then
66245: LD_VAR 0 3
66249: PPUSH
66250: CALL_OW 310
66254: IFFALSE 66265
// ComExitBuilding ( j ) ;
66256: LD_VAR 0 3
66260: PPUSH
66261: CALL_OW 122
// wait ( 3 ) ;
66265: LD_INT 3
66267: PPUSH
66268: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66272: LD_VAR 0 3
66276: PPUSH
66277: LD_VAR 0 6
66281: PUSH
66282: LD_INT 2
66284: ARRAY
66285: PPUSH
66286: LD_VAR 0 6
66290: PUSH
66291: LD_INT 3
66293: ARRAY
66294: PPUSH
66295: CALL_OW 117
// end ;
66299: GO 66140
66301: POP
66302: POP
// end ; end else
66303: GO 66884
// begin for j in cargo do
66305: LD_ADDR_VAR 0 3
66309: PUSH
66310: LD_VAR 0 7
66314: PUSH
66315: FOR_IN
66316: IFFALSE 66882
// begin if GetTag ( j ) <> 0 then
66318: LD_VAR 0 3
66322: PPUSH
66323: CALL_OW 110
66327: PUSH
66328: LD_INT 0
66330: NONEQUAL
66331: IFFALSE 66335
// continue ;
66333: GO 66315
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66335: LD_VAR 0 3
66339: PPUSH
66340: CALL_OW 256
66344: PUSH
66345: LD_INT 1000
66347: LESS
66348: PUSH
66349: LD_VAR 0 3
66353: PPUSH
66354: LD_EXP 83
66358: PUSH
66359: LD_VAR 0 2
66363: ARRAY
66364: PPUSH
66365: CALL_OW 308
66369: NOT
66370: AND
66371: IFFALSE 66393
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66373: LD_VAR 0 3
66377: PPUSH
66378: LD_EXP 83
66382: PUSH
66383: LD_VAR 0 2
66387: ARRAY
66388: PPUSH
66389: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66393: LD_VAR 0 3
66397: PPUSH
66398: CALL_OW 256
66402: PUSH
66403: LD_INT 1000
66405: LESS
66406: PUSH
66407: LD_VAR 0 3
66411: PPUSH
66412: LD_EXP 83
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PPUSH
66423: CALL_OW 308
66427: AND
66428: IFFALSE 66432
// continue ;
66430: GO 66315
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66432: LD_VAR 0 3
66436: PPUSH
66437: CALL_OW 262
66441: PUSH
66442: LD_INT 2
66444: EQUAL
66445: PUSH
66446: LD_VAR 0 3
66450: PPUSH
66451: CALL_OW 261
66455: PUSH
66456: LD_INT 15
66458: LESS
66459: AND
66460: IFFALSE 66464
// continue ;
66462: GO 66315
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66464: LD_VAR 0 3
66468: PPUSH
66469: CALL_OW 262
66473: PUSH
66474: LD_INT 1
66476: EQUAL
66477: PUSH
66478: LD_VAR 0 3
66482: PPUSH
66483: CALL_OW 261
66487: PUSH
66488: LD_INT 10
66490: LESS
66491: AND
66492: IFFALSE 66821
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66494: LD_ADDR_VAR 0 8
66498: PUSH
66499: LD_EXP 59
66503: PUSH
66504: LD_VAR 0 2
66508: ARRAY
66509: PPUSH
66510: LD_INT 2
66512: PUSH
66513: LD_INT 30
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 30
66525: PUSH
66526: LD_INT 1
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: LIST
66537: PPUSH
66538: CALL_OW 72
66542: ST_TO_ADDR
// if not depot then
66543: LD_VAR 0 8
66547: NOT
66548: IFFALSE 66552
// continue ;
66550: GO 66315
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66552: LD_VAR 0 3
66556: PPUSH
66557: LD_VAR 0 8
66561: PPUSH
66562: LD_VAR 0 3
66566: PPUSH
66567: CALL_OW 74
66571: PPUSH
66572: CALL_OW 296
66576: PUSH
66577: LD_INT 6
66579: LESS
66580: IFFALSE 66596
// SetFuel ( j , 100 ) else
66582: LD_VAR 0 3
66586: PPUSH
66587: LD_INT 100
66589: PPUSH
66590: CALL_OW 240
66594: GO 66821
// if GetFuel ( j ) = 0 then
66596: LD_VAR 0 3
66600: PPUSH
66601: CALL_OW 261
66605: PUSH
66606: LD_INT 0
66608: EQUAL
66609: IFFALSE 66821
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66611: LD_ADDR_EXP 78
66615: PUSH
66616: LD_EXP 78
66620: PPUSH
66621: LD_VAR 0 2
66625: PPUSH
66626: LD_EXP 78
66630: PUSH
66631: LD_VAR 0 2
66635: ARRAY
66636: PUSH
66637: LD_VAR 0 3
66641: DIFF
66642: PPUSH
66643: CALL_OW 1
66647: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66648: LD_VAR 0 3
66652: PPUSH
66653: CALL_OW 263
66657: PUSH
66658: LD_INT 1
66660: EQUAL
66661: IFFALSE 66677
// ComExitVehicle ( IsInUnit ( j ) ) ;
66663: LD_VAR 0 3
66667: PPUSH
66668: CALL_OW 310
66672: PPUSH
66673: CALL_OW 121
// if GetControl ( j ) = control_remote then
66677: LD_VAR 0 3
66681: PPUSH
66682: CALL_OW 263
66686: PUSH
66687: LD_INT 2
66689: EQUAL
66690: IFFALSE 66701
// ComUnlink ( j ) ;
66692: LD_VAR 0 3
66696: PPUSH
66697: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66701: LD_ADDR_VAR 0 9
66705: PUSH
66706: LD_VAR 0 2
66710: PPUSH
66711: LD_INT 3
66713: PPUSH
66714: CALL 76196 0 2
66718: ST_TO_ADDR
// if fac then
66719: LD_VAR 0 9
66723: IFFALSE 66819
// begin for k in fac do
66725: LD_ADDR_VAR 0 4
66729: PUSH
66730: LD_VAR 0 9
66734: PUSH
66735: FOR_IN
66736: IFFALSE 66817
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66738: LD_ADDR_VAR 0 10
66742: PUSH
66743: LD_VAR 0 9
66747: PPUSH
66748: LD_VAR 0 3
66752: PPUSH
66753: CALL_OW 265
66757: PPUSH
66758: LD_VAR 0 3
66762: PPUSH
66763: CALL_OW 262
66767: PPUSH
66768: LD_VAR 0 3
66772: PPUSH
66773: CALL_OW 263
66777: PPUSH
66778: LD_VAR 0 3
66782: PPUSH
66783: CALL_OW 264
66787: PPUSH
66788: CALL 16815 0 5
66792: ST_TO_ADDR
// if components then
66793: LD_VAR 0 10
66797: IFFALSE 66815
// begin MC_InsertProduceList ( i , components ) ;
66799: LD_VAR 0 2
66803: PPUSH
66804: LD_VAR 0 10
66808: PPUSH
66809: CALL 75741 0 2
// break ;
66813: GO 66817
// end ; end ;
66815: GO 66735
66817: POP
66818: POP
// end ; continue ;
66819: GO 66315
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66821: LD_VAR 0 3
66825: PPUSH
66826: LD_INT 1
66828: PPUSH
66829: CALL_OW 289
66833: PUSH
66834: LD_INT 100
66836: LESS
66837: PUSH
66838: LD_VAR 0 3
66842: PPUSH
66843: CALL_OW 314
66847: NOT
66848: AND
66849: IFFALSE 66878
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66851: LD_VAR 0 3
66855: PPUSH
66856: LD_VAR 0 6
66860: PUSH
66861: LD_INT 2
66863: ARRAY
66864: PPUSH
66865: LD_VAR 0 6
66869: PUSH
66870: LD_INT 3
66872: ARRAY
66873: PPUSH
66874: CALL_OW 117
// break ;
66878: GO 66882
// end ;
66880: GO 66315
66882: POP
66883: POP
// end ; end ;
66884: GO 65153
66886: POP
66887: POP
// end ;
66888: LD_VAR 0 1
66892: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66893: LD_INT 0
66895: PPUSH
66896: PPUSH
66897: PPUSH
66898: PPUSH
// if not mc_bases then
66899: LD_EXP 59
66903: NOT
66904: IFFALSE 66908
// exit ;
66906: GO 67069
// for i = 1 to mc_bases do
66908: LD_ADDR_VAR 0 2
66912: PUSH
66913: DOUBLE
66914: LD_INT 1
66916: DEC
66917: ST_TO_ADDR
66918: LD_EXP 59
66922: PUSH
66923: FOR_TO
66924: IFFALSE 67067
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66926: LD_ADDR_VAR 0 4
66930: PUSH
66931: LD_EXP 78
66935: PUSH
66936: LD_VAR 0 2
66940: ARRAY
66941: PUSH
66942: LD_EXP 81
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: UNION
66953: PPUSH
66954: LD_INT 33
66956: PUSH
66957: LD_INT 2
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: CALL_OW 72
66968: ST_TO_ADDR
// if tmp then
66969: LD_VAR 0 4
66973: IFFALSE 67065
// for j in tmp do
66975: LD_ADDR_VAR 0 3
66979: PUSH
66980: LD_VAR 0 4
66984: PUSH
66985: FOR_IN
66986: IFFALSE 67063
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66988: LD_VAR 0 3
66992: PPUSH
66993: CALL_OW 312
66997: NOT
66998: PUSH
66999: LD_VAR 0 3
67003: PPUSH
67004: CALL_OW 256
67008: PUSH
67009: LD_INT 250
67011: GREATEREQUAL
67012: AND
67013: IFFALSE 67026
// Connect ( j ) else
67015: LD_VAR 0 3
67019: PPUSH
67020: CALL 22248 0 1
67024: GO 67061
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67026: LD_VAR 0 3
67030: PPUSH
67031: CALL_OW 256
67035: PUSH
67036: LD_INT 250
67038: LESS
67039: PUSH
67040: LD_VAR 0 3
67044: PPUSH
67045: CALL_OW 312
67049: AND
67050: IFFALSE 67061
// ComUnlink ( j ) ;
67052: LD_VAR 0 3
67056: PPUSH
67057: CALL_OW 136
67061: GO 66985
67063: POP
67064: POP
// end ;
67065: GO 66923
67067: POP
67068: POP
// end ;
67069: LD_VAR 0 1
67073: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67074: LD_INT 0
67076: PPUSH
67077: PPUSH
67078: PPUSH
67079: PPUSH
67080: PPUSH
// if not mc_bases then
67081: LD_EXP 59
67085: NOT
67086: IFFALSE 67090
// exit ;
67088: GO 67535
// for i = 1 to mc_bases do
67090: LD_ADDR_VAR 0 2
67094: PUSH
67095: DOUBLE
67096: LD_INT 1
67098: DEC
67099: ST_TO_ADDR
67100: LD_EXP 59
67104: PUSH
67105: FOR_TO
67106: IFFALSE 67533
// begin if not mc_produce [ i ] then
67108: LD_EXP 80
67112: PUSH
67113: LD_VAR 0 2
67117: ARRAY
67118: NOT
67119: IFFALSE 67123
// continue ;
67121: GO 67105
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67123: LD_ADDR_VAR 0 5
67127: PUSH
67128: LD_EXP 59
67132: PUSH
67133: LD_VAR 0 2
67137: ARRAY
67138: PPUSH
67139: LD_INT 30
67141: PUSH
67142: LD_INT 3
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: PPUSH
67149: CALL_OW 72
67153: ST_TO_ADDR
// if not fac then
67154: LD_VAR 0 5
67158: NOT
67159: IFFALSE 67163
// continue ;
67161: GO 67105
// for j in fac do
67163: LD_ADDR_VAR 0 3
67167: PUSH
67168: LD_VAR 0 5
67172: PUSH
67173: FOR_IN
67174: IFFALSE 67529
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67176: LD_VAR 0 3
67180: PPUSH
67181: CALL_OW 461
67185: PUSH
67186: LD_INT 2
67188: NONEQUAL
67189: PUSH
67190: LD_VAR 0 3
67194: PPUSH
67195: LD_INT 15
67197: PPUSH
67198: CALL 21876 0 2
67202: PUSH
67203: LD_INT 4
67205: ARRAY
67206: OR
67207: IFFALSE 67211
// continue ;
67209: GO 67173
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67211: LD_VAR 0 3
67215: PPUSH
67216: LD_EXP 80
67220: PUSH
67221: LD_VAR 0 2
67225: ARRAY
67226: PUSH
67227: LD_INT 1
67229: ARRAY
67230: PUSH
67231: LD_INT 1
67233: ARRAY
67234: PPUSH
67235: LD_EXP 80
67239: PUSH
67240: LD_VAR 0 2
67244: ARRAY
67245: PUSH
67246: LD_INT 1
67248: ARRAY
67249: PUSH
67250: LD_INT 2
67252: ARRAY
67253: PPUSH
67254: LD_EXP 80
67258: PUSH
67259: LD_VAR 0 2
67263: ARRAY
67264: PUSH
67265: LD_INT 1
67267: ARRAY
67268: PUSH
67269: LD_INT 3
67271: ARRAY
67272: PPUSH
67273: LD_EXP 80
67277: PUSH
67278: LD_VAR 0 2
67282: ARRAY
67283: PUSH
67284: LD_INT 1
67286: ARRAY
67287: PUSH
67288: LD_INT 4
67290: ARRAY
67291: PPUSH
67292: CALL_OW 448
67296: PUSH
67297: LD_VAR 0 3
67301: PPUSH
67302: LD_EXP 80
67306: PUSH
67307: LD_VAR 0 2
67311: ARRAY
67312: PUSH
67313: LD_INT 1
67315: ARRAY
67316: PUSH
67317: LD_INT 1
67319: ARRAY
67320: PUSH
67321: LD_EXP 80
67325: PUSH
67326: LD_VAR 0 2
67330: ARRAY
67331: PUSH
67332: LD_INT 1
67334: ARRAY
67335: PUSH
67336: LD_INT 2
67338: ARRAY
67339: PUSH
67340: LD_EXP 80
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: PUSH
67351: LD_INT 1
67353: ARRAY
67354: PUSH
67355: LD_INT 3
67357: ARRAY
67358: PUSH
67359: LD_EXP 80
67363: PUSH
67364: LD_VAR 0 2
67368: ARRAY
67369: PUSH
67370: LD_INT 1
67372: ARRAY
67373: PUSH
67374: LD_INT 4
67376: ARRAY
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: PPUSH
67384: CALL 25674 0 2
67388: AND
67389: IFFALSE 67527
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67391: LD_VAR 0 3
67395: PPUSH
67396: LD_EXP 80
67400: PUSH
67401: LD_VAR 0 2
67405: ARRAY
67406: PUSH
67407: LD_INT 1
67409: ARRAY
67410: PUSH
67411: LD_INT 1
67413: ARRAY
67414: PPUSH
67415: LD_EXP 80
67419: PUSH
67420: LD_VAR 0 2
67424: ARRAY
67425: PUSH
67426: LD_INT 1
67428: ARRAY
67429: PUSH
67430: LD_INT 2
67432: ARRAY
67433: PPUSH
67434: LD_EXP 80
67438: PUSH
67439: LD_VAR 0 2
67443: ARRAY
67444: PUSH
67445: LD_INT 1
67447: ARRAY
67448: PUSH
67449: LD_INT 3
67451: ARRAY
67452: PPUSH
67453: LD_EXP 80
67457: PUSH
67458: LD_VAR 0 2
67462: ARRAY
67463: PUSH
67464: LD_INT 1
67466: ARRAY
67467: PUSH
67468: LD_INT 4
67470: ARRAY
67471: PPUSH
67472: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67476: LD_ADDR_VAR 0 4
67480: PUSH
67481: LD_EXP 80
67485: PUSH
67486: LD_VAR 0 2
67490: ARRAY
67491: PPUSH
67492: LD_INT 1
67494: PPUSH
67495: CALL_OW 3
67499: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67500: LD_ADDR_EXP 80
67504: PUSH
67505: LD_EXP 80
67509: PPUSH
67510: LD_VAR 0 2
67514: PPUSH
67515: LD_VAR 0 4
67519: PPUSH
67520: CALL_OW 1
67524: ST_TO_ADDR
// break ;
67525: GO 67529
// end ; end ;
67527: GO 67173
67529: POP
67530: POP
// end ;
67531: GO 67105
67533: POP
67534: POP
// end ;
67535: LD_VAR 0 1
67539: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67540: LD_INT 0
67542: PPUSH
67543: PPUSH
67544: PPUSH
// if not mc_bases then
67545: LD_EXP 59
67549: NOT
67550: IFFALSE 67554
// exit ;
67552: GO 67643
// for i = 1 to mc_bases do
67554: LD_ADDR_VAR 0 2
67558: PUSH
67559: DOUBLE
67560: LD_INT 1
67562: DEC
67563: ST_TO_ADDR
67564: LD_EXP 59
67568: PUSH
67569: FOR_TO
67570: IFFALSE 67641
// begin if mc_attack [ i ] then
67572: LD_EXP 79
67576: PUSH
67577: LD_VAR 0 2
67581: ARRAY
67582: IFFALSE 67639
// begin tmp := mc_attack [ i ] [ 1 ] ;
67584: LD_ADDR_VAR 0 3
67588: PUSH
67589: LD_EXP 79
67593: PUSH
67594: LD_VAR 0 2
67598: ARRAY
67599: PUSH
67600: LD_INT 1
67602: ARRAY
67603: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67604: LD_ADDR_EXP 79
67608: PUSH
67609: LD_EXP 79
67613: PPUSH
67614: LD_VAR 0 2
67618: PPUSH
67619: EMPTY
67620: PPUSH
67621: CALL_OW 1
67625: ST_TO_ADDR
// Attack ( tmp ) ;
67626: LD_VAR 0 3
67630: PPUSH
67631: CALL 99430 0 1
// exit ;
67635: POP
67636: POP
67637: GO 67643
// end ; end ;
67639: GO 67569
67641: POP
67642: POP
// end ;
67643: LD_VAR 0 1
67647: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67648: LD_INT 0
67650: PPUSH
67651: PPUSH
67652: PPUSH
67653: PPUSH
67654: PPUSH
67655: PPUSH
67656: PPUSH
// if not mc_bases then
67657: LD_EXP 59
67661: NOT
67662: IFFALSE 67666
// exit ;
67664: GO 68270
// for i = 1 to mc_bases do
67666: LD_ADDR_VAR 0 2
67670: PUSH
67671: DOUBLE
67672: LD_INT 1
67674: DEC
67675: ST_TO_ADDR
67676: LD_EXP 59
67680: PUSH
67681: FOR_TO
67682: IFFALSE 68268
// begin if not mc_bases [ i ] then
67684: LD_EXP 59
67688: PUSH
67689: LD_VAR 0 2
67693: ARRAY
67694: NOT
67695: IFFALSE 67699
// continue ;
67697: GO 67681
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67699: LD_ADDR_VAR 0 7
67703: PUSH
67704: LD_EXP 59
67708: PUSH
67709: LD_VAR 0 2
67713: ARRAY
67714: PUSH
67715: LD_INT 1
67717: ARRAY
67718: PPUSH
67719: CALL 16119 0 1
67723: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67724: LD_ADDR_EXP 82
67728: PUSH
67729: LD_EXP 82
67733: PPUSH
67734: LD_VAR 0 2
67738: PPUSH
67739: LD_EXP 59
67743: PUSH
67744: LD_VAR 0 2
67748: ARRAY
67749: PUSH
67750: LD_INT 1
67752: ARRAY
67753: PPUSH
67754: CALL_OW 255
67758: PPUSH
67759: LD_EXP 84
67763: PUSH
67764: LD_VAR 0 2
67768: ARRAY
67769: PPUSH
67770: CALL 16084 0 2
67774: PPUSH
67775: CALL_OW 1
67779: ST_TO_ADDR
// if not mc_scan [ i ] then
67780: LD_EXP 82
67784: PUSH
67785: LD_VAR 0 2
67789: ARRAY
67790: NOT
67791: IFFALSE 67946
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67793: LD_ADDR_VAR 0 4
67797: PUSH
67798: LD_EXP 59
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PPUSH
67809: LD_INT 2
67811: PUSH
67812: LD_INT 25
67814: PUSH
67815: LD_INT 5
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 25
67824: PUSH
67825: LD_INT 8
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 25
67834: PUSH
67835: LD_INT 9
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: PPUSH
67848: CALL_OW 72
67852: ST_TO_ADDR
// if not tmp then
67853: LD_VAR 0 4
67857: NOT
67858: IFFALSE 67862
// continue ;
67860: GO 67681
// for j in tmp do
67862: LD_ADDR_VAR 0 3
67866: PUSH
67867: LD_VAR 0 4
67871: PUSH
67872: FOR_IN
67873: IFFALSE 67944
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67875: LD_VAR 0 3
67879: PPUSH
67880: CALL_OW 310
67884: PPUSH
67885: CALL_OW 266
67889: PUSH
67890: LD_INT 5
67892: EQUAL
67893: PUSH
67894: LD_VAR 0 3
67898: PPUSH
67899: CALL_OW 257
67903: PUSH
67904: LD_INT 1
67906: EQUAL
67907: AND
67908: PUSH
67909: LD_VAR 0 3
67913: PPUSH
67914: CALL_OW 459
67918: NOT
67919: AND
67920: PUSH
67921: LD_VAR 0 7
67925: AND
67926: IFFALSE 67942
// ComChangeProfession ( j , class ) ;
67928: LD_VAR 0 3
67932: PPUSH
67933: LD_VAR 0 7
67937: PPUSH
67938: CALL_OW 123
67942: GO 67872
67944: POP
67945: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67946: LD_EXP 82
67950: PUSH
67951: LD_VAR 0 2
67955: ARRAY
67956: PUSH
67957: LD_EXP 81
67961: PUSH
67962: LD_VAR 0 2
67966: ARRAY
67967: NOT
67968: AND
67969: PUSH
67970: LD_EXP 59
67974: PUSH
67975: LD_VAR 0 2
67979: ARRAY
67980: PPUSH
67981: LD_INT 30
67983: PUSH
67984: LD_INT 32
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PPUSH
67991: CALL_OW 72
67995: NOT
67996: AND
67997: PUSH
67998: LD_EXP 59
68002: PUSH
68003: LD_VAR 0 2
68007: ARRAY
68008: PPUSH
68009: LD_INT 2
68011: PUSH
68012: LD_INT 30
68014: PUSH
68015: LD_INT 4
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 30
68024: PUSH
68025: LD_INT 5
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: LIST
68036: PPUSH
68037: CALL_OW 72
68041: NOT
68042: AND
68043: IFFALSE 68175
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68045: LD_ADDR_VAR 0 4
68049: PUSH
68050: LD_EXP 59
68054: PUSH
68055: LD_VAR 0 2
68059: ARRAY
68060: PPUSH
68061: LD_INT 2
68063: PUSH
68064: LD_INT 25
68066: PUSH
68067: LD_INT 1
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: LD_INT 25
68076: PUSH
68077: LD_INT 5
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: LD_INT 25
68086: PUSH
68087: LD_INT 8
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 25
68096: PUSH
68097: LD_INT 9
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: PPUSH
68111: CALL_OW 72
68115: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68116: LD_ADDR_VAR 0 4
68120: PUSH
68121: LD_VAR 0 4
68125: PUSH
68126: LD_VAR 0 4
68130: PPUSH
68131: LD_INT 18
68133: PPUSH
68134: CALL 48177 0 2
68138: DIFF
68139: ST_TO_ADDR
// if tmp then
68140: LD_VAR 0 4
68144: IFFALSE 68175
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
68146: LD_VAR 0 2
68150: PPUSH
68151: LD_VAR 0 4
68155: PPUSH
68156: LD_EXP 84
68160: PUSH
68161: LD_VAR 0 2
68165: ARRAY
68166: PPUSH
68167: CALL 104139 0 3
// exit ;
68171: POP
68172: POP
68173: GO 68270
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
68175: LD_EXP 82
68179: PUSH
68180: LD_VAR 0 2
68184: ARRAY
68185: PUSH
68186: LD_EXP 81
68190: PUSH
68191: LD_VAR 0 2
68195: ARRAY
68196: AND
68197: IFFALSE 68266
// begin tmp := mc_defender [ i ] ;
68199: LD_ADDR_VAR 0 4
68203: PUSH
68204: LD_EXP 81
68208: PUSH
68209: LD_VAR 0 2
68213: ARRAY
68214: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68215: LD_ADDR_EXP 81
68219: PUSH
68220: LD_EXP 81
68224: PPUSH
68225: LD_VAR 0 2
68229: PPUSH
68230: EMPTY
68231: PPUSH
68232: CALL_OW 1
68236: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
68237: LD_VAR 0 2
68241: PPUSH
68242: LD_VAR 0 4
68246: PPUSH
68247: LD_EXP 82
68251: PUSH
68252: LD_VAR 0 2
68256: ARRAY
68257: PPUSH
68258: CALL 104700 0 3
// exit ;
68262: POP
68263: POP
68264: GO 68270
// end ; end ;
68266: GO 67681
68268: POP
68269: POP
// end ;
68270: LD_VAR 0 1
68274: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68275: LD_INT 0
68277: PPUSH
68278: PPUSH
68279: PPUSH
68280: PPUSH
68281: PPUSH
68282: PPUSH
68283: PPUSH
68284: PPUSH
68285: PPUSH
68286: PPUSH
68287: PPUSH
// if not mc_bases then
68288: LD_EXP 59
68292: NOT
68293: IFFALSE 68297
// exit ;
68295: GO 69384
// for i = 1 to mc_bases do
68297: LD_ADDR_VAR 0 2
68301: PUSH
68302: DOUBLE
68303: LD_INT 1
68305: DEC
68306: ST_TO_ADDR
68307: LD_EXP 59
68311: PUSH
68312: FOR_TO
68313: IFFALSE 69382
// begin tmp := mc_lab [ i ] ;
68315: LD_ADDR_VAR 0 6
68319: PUSH
68320: LD_EXP 92
68324: PUSH
68325: LD_VAR 0 2
68329: ARRAY
68330: ST_TO_ADDR
// if not tmp then
68331: LD_VAR 0 6
68335: NOT
68336: IFFALSE 68340
// continue ;
68338: GO 68312
// idle_lab := 0 ;
68340: LD_ADDR_VAR 0 11
68344: PUSH
68345: LD_INT 0
68347: ST_TO_ADDR
// for j in tmp do
68348: LD_ADDR_VAR 0 3
68352: PUSH
68353: LD_VAR 0 6
68357: PUSH
68358: FOR_IN
68359: IFFALSE 69378
// begin researching := false ;
68361: LD_ADDR_VAR 0 10
68365: PUSH
68366: LD_INT 0
68368: ST_TO_ADDR
// side := GetSide ( j ) ;
68369: LD_ADDR_VAR 0 4
68373: PUSH
68374: LD_VAR 0 3
68378: PPUSH
68379: CALL_OW 255
68383: ST_TO_ADDR
// if not mc_tech [ side ] then
68384: LD_EXP 86
68388: PUSH
68389: LD_VAR 0 4
68393: ARRAY
68394: NOT
68395: IFFALSE 68399
// continue ;
68397: GO 68358
// if BuildingStatus ( j ) = bs_idle then
68399: LD_VAR 0 3
68403: PPUSH
68404: CALL_OW 461
68408: PUSH
68409: LD_INT 2
68411: EQUAL
68412: IFFALSE 68600
// begin if idle_lab and UnitsInside ( j ) < 6 then
68414: LD_VAR 0 11
68418: PUSH
68419: LD_VAR 0 3
68423: PPUSH
68424: CALL_OW 313
68428: PUSH
68429: LD_INT 6
68431: LESS
68432: AND
68433: IFFALSE 68504
// begin tmp2 := UnitsInside ( idle_lab ) ;
68435: LD_ADDR_VAR 0 9
68439: PUSH
68440: LD_VAR 0 11
68444: PPUSH
68445: CALL_OW 313
68449: ST_TO_ADDR
// if tmp2 then
68450: LD_VAR 0 9
68454: IFFALSE 68496
// for x in tmp2 do
68456: LD_ADDR_VAR 0 7
68460: PUSH
68461: LD_VAR 0 9
68465: PUSH
68466: FOR_IN
68467: IFFALSE 68494
// begin ComExitBuilding ( x ) ;
68469: LD_VAR 0 7
68473: PPUSH
68474: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68478: LD_VAR 0 7
68482: PPUSH
68483: LD_VAR 0 3
68487: PPUSH
68488: CALL_OW 180
// end ;
68492: GO 68466
68494: POP
68495: POP
// idle_lab := 0 ;
68496: LD_ADDR_VAR 0 11
68500: PUSH
68501: LD_INT 0
68503: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68504: LD_ADDR_VAR 0 5
68508: PUSH
68509: LD_EXP 86
68513: PUSH
68514: LD_VAR 0 4
68518: ARRAY
68519: PUSH
68520: FOR_IN
68521: IFFALSE 68581
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68523: LD_VAR 0 3
68527: PPUSH
68528: LD_VAR 0 5
68532: PPUSH
68533: CALL_OW 430
68537: PUSH
68538: LD_VAR 0 4
68542: PPUSH
68543: LD_VAR 0 5
68547: PPUSH
68548: CALL 15189 0 2
68552: AND
68553: IFFALSE 68579
// begin researching := true ;
68555: LD_ADDR_VAR 0 10
68559: PUSH
68560: LD_INT 1
68562: ST_TO_ADDR
// ComResearch ( j , t ) ;
68563: LD_VAR 0 3
68567: PPUSH
68568: LD_VAR 0 5
68572: PPUSH
68573: CALL_OW 124
// break ;
68577: GO 68581
// end ;
68579: GO 68520
68581: POP
68582: POP
// if not researching then
68583: LD_VAR 0 10
68587: NOT
68588: IFFALSE 68600
// idle_lab := j ;
68590: LD_ADDR_VAR 0 11
68594: PUSH
68595: LD_VAR 0 3
68599: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68600: LD_VAR 0 3
68604: PPUSH
68605: CALL_OW 461
68609: PUSH
68610: LD_INT 10
68612: EQUAL
68613: IFFALSE 69201
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68615: LD_EXP 88
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: NOT
68626: PUSH
68627: LD_EXP 89
68631: PUSH
68632: LD_VAR 0 2
68636: ARRAY
68637: NOT
68638: AND
68639: PUSH
68640: LD_EXP 86
68644: PUSH
68645: LD_VAR 0 4
68649: ARRAY
68650: PUSH
68651: LD_INT 1
68653: GREATER
68654: AND
68655: IFFALSE 68786
// begin ComCancel ( j ) ;
68657: LD_VAR 0 3
68661: PPUSH
68662: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68666: LD_ADDR_EXP 86
68670: PUSH
68671: LD_EXP 86
68675: PPUSH
68676: LD_VAR 0 4
68680: PPUSH
68681: LD_EXP 86
68685: PUSH
68686: LD_VAR 0 4
68690: ARRAY
68691: PPUSH
68692: LD_EXP 86
68696: PUSH
68697: LD_VAR 0 4
68701: ARRAY
68702: PUSH
68703: LD_INT 1
68705: MINUS
68706: PPUSH
68707: LD_EXP 86
68711: PUSH
68712: LD_VAR 0 4
68716: ARRAY
68717: PPUSH
68718: LD_INT 0
68720: PPUSH
68721: CALL 18701 0 4
68725: PPUSH
68726: CALL_OW 1
68730: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68731: LD_ADDR_EXP 86
68735: PUSH
68736: LD_EXP 86
68740: PPUSH
68741: LD_VAR 0 4
68745: PPUSH
68746: LD_EXP 86
68750: PUSH
68751: LD_VAR 0 4
68755: ARRAY
68756: PPUSH
68757: LD_EXP 86
68761: PUSH
68762: LD_VAR 0 4
68766: ARRAY
68767: PPUSH
68768: LD_INT 1
68770: PPUSH
68771: LD_INT 0
68773: PPUSH
68774: CALL 18701 0 4
68778: PPUSH
68779: CALL_OW 1
68783: ST_TO_ADDR
// continue ;
68784: GO 68358
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68786: LD_EXP 88
68790: PUSH
68791: LD_VAR 0 2
68795: ARRAY
68796: PUSH
68797: LD_EXP 89
68801: PUSH
68802: LD_VAR 0 2
68806: ARRAY
68807: NOT
68808: AND
68809: IFFALSE 68936
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68811: LD_ADDR_EXP 89
68815: PUSH
68816: LD_EXP 89
68820: PPUSH
68821: LD_VAR 0 2
68825: PUSH
68826: LD_EXP 89
68830: PUSH
68831: LD_VAR 0 2
68835: ARRAY
68836: PUSH
68837: LD_INT 1
68839: PLUS
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PPUSH
68845: LD_EXP 88
68849: PUSH
68850: LD_VAR 0 2
68854: ARRAY
68855: PUSH
68856: LD_INT 1
68858: ARRAY
68859: PPUSH
68860: CALL 19283 0 3
68864: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68865: LD_EXP 88
68869: PUSH
68870: LD_VAR 0 2
68874: ARRAY
68875: PUSH
68876: LD_INT 1
68878: ARRAY
68879: PPUSH
68880: LD_INT 112
68882: PPUSH
68883: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68887: LD_ADDR_VAR 0 9
68891: PUSH
68892: LD_EXP 88
68896: PUSH
68897: LD_VAR 0 2
68901: ARRAY
68902: PPUSH
68903: LD_INT 1
68905: PPUSH
68906: CALL_OW 3
68910: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68911: LD_ADDR_EXP 88
68915: PUSH
68916: LD_EXP 88
68920: PPUSH
68921: LD_VAR 0 2
68925: PPUSH
68926: LD_VAR 0 9
68930: PPUSH
68931: CALL_OW 1
68935: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68936: LD_EXP 88
68940: PUSH
68941: LD_VAR 0 2
68945: ARRAY
68946: PUSH
68947: LD_EXP 89
68951: PUSH
68952: LD_VAR 0 2
68956: ARRAY
68957: AND
68958: PUSH
68959: LD_EXP 89
68963: PUSH
68964: LD_VAR 0 2
68968: ARRAY
68969: PUSH
68970: LD_INT 1
68972: ARRAY
68973: PPUSH
68974: CALL_OW 310
68978: NOT
68979: AND
68980: PUSH
68981: LD_VAR 0 3
68985: PPUSH
68986: CALL_OW 313
68990: PUSH
68991: LD_INT 6
68993: EQUAL
68994: AND
68995: IFFALSE 69051
// begin tmp2 := UnitsInside ( j ) ;
68997: LD_ADDR_VAR 0 9
69001: PUSH
69002: LD_VAR 0 3
69006: PPUSH
69007: CALL_OW 313
69011: ST_TO_ADDR
// if tmp2 = 6 then
69012: LD_VAR 0 9
69016: PUSH
69017: LD_INT 6
69019: EQUAL
69020: IFFALSE 69051
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69022: LD_VAR 0 9
69026: PUSH
69027: LD_INT 1
69029: ARRAY
69030: PPUSH
69031: LD_INT 112
69033: PPUSH
69034: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69038: LD_VAR 0 9
69042: PUSH
69043: LD_INT 1
69045: ARRAY
69046: PPUSH
69047: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69051: LD_EXP 89
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: PUSH
69062: LD_EXP 89
69066: PUSH
69067: LD_VAR 0 2
69071: ARRAY
69072: PUSH
69073: LD_INT 1
69075: ARRAY
69076: PPUSH
69077: CALL_OW 314
69081: NOT
69082: AND
69083: PUSH
69084: LD_EXP 89
69088: PUSH
69089: LD_VAR 0 2
69093: ARRAY
69094: PUSH
69095: LD_INT 1
69097: ARRAY
69098: PPUSH
69099: CALL_OW 310
69103: NOT
69104: AND
69105: IFFALSE 69131
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69107: LD_EXP 89
69111: PUSH
69112: LD_VAR 0 2
69116: ARRAY
69117: PUSH
69118: LD_INT 1
69120: ARRAY
69121: PPUSH
69122: LD_VAR 0 3
69126: PPUSH
69127: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69131: LD_EXP 89
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: PUSH
69142: LD_INT 1
69144: ARRAY
69145: PPUSH
69146: CALL_OW 310
69150: PUSH
69151: LD_EXP 89
69155: PUSH
69156: LD_VAR 0 2
69160: ARRAY
69161: PUSH
69162: LD_INT 1
69164: ARRAY
69165: PPUSH
69166: CALL_OW 310
69170: PPUSH
69171: CALL_OW 461
69175: PUSH
69176: LD_INT 3
69178: NONEQUAL
69179: AND
69180: IFFALSE 69201
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69182: LD_EXP 89
69186: PUSH
69187: LD_VAR 0 2
69191: ARRAY
69192: PUSH
69193: LD_INT 1
69195: ARRAY
69196: PPUSH
69197: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69201: LD_VAR 0 3
69205: PPUSH
69206: CALL_OW 461
69210: PUSH
69211: LD_INT 6
69213: EQUAL
69214: PUSH
69215: LD_VAR 0 6
69219: PUSH
69220: LD_INT 1
69222: GREATER
69223: AND
69224: IFFALSE 69376
// begin sci := [ ] ;
69226: LD_ADDR_VAR 0 8
69230: PUSH
69231: EMPTY
69232: ST_TO_ADDR
// for x in ( tmp diff j ) do
69233: LD_ADDR_VAR 0 7
69237: PUSH
69238: LD_VAR 0 6
69242: PUSH
69243: LD_VAR 0 3
69247: DIFF
69248: PUSH
69249: FOR_IN
69250: IFFALSE 69302
// begin if sci = 6 then
69252: LD_VAR 0 8
69256: PUSH
69257: LD_INT 6
69259: EQUAL
69260: IFFALSE 69264
// break ;
69262: GO 69302
// if BuildingStatus ( x ) = bs_idle then
69264: LD_VAR 0 7
69268: PPUSH
69269: CALL_OW 461
69273: PUSH
69274: LD_INT 2
69276: EQUAL
69277: IFFALSE 69300
// sci := sci ^ UnitsInside ( x ) ;
69279: LD_ADDR_VAR 0 8
69283: PUSH
69284: LD_VAR 0 8
69288: PUSH
69289: LD_VAR 0 7
69293: PPUSH
69294: CALL_OW 313
69298: ADD
69299: ST_TO_ADDR
// end ;
69300: GO 69249
69302: POP
69303: POP
// if not sci then
69304: LD_VAR 0 8
69308: NOT
69309: IFFALSE 69313
// continue ;
69311: GO 68358
// for x in sci do
69313: LD_ADDR_VAR 0 7
69317: PUSH
69318: LD_VAR 0 8
69322: PUSH
69323: FOR_IN
69324: IFFALSE 69374
// if IsInUnit ( x ) and not HasTask ( x ) then
69326: LD_VAR 0 7
69330: PPUSH
69331: CALL_OW 310
69335: PUSH
69336: LD_VAR 0 7
69340: PPUSH
69341: CALL_OW 314
69345: NOT
69346: AND
69347: IFFALSE 69372
// begin ComExitBuilding ( x ) ;
69349: LD_VAR 0 7
69353: PPUSH
69354: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69358: LD_VAR 0 7
69362: PPUSH
69363: LD_VAR 0 3
69367: PPUSH
69368: CALL_OW 180
// end ;
69372: GO 69323
69374: POP
69375: POP
// end ; end ;
69376: GO 68358
69378: POP
69379: POP
// end ;
69380: GO 68312
69382: POP
69383: POP
// end ;
69384: LD_VAR 0 1
69388: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69389: LD_INT 0
69391: PPUSH
69392: PPUSH
// if not mc_bases then
69393: LD_EXP 59
69397: NOT
69398: IFFALSE 69402
// exit ;
69400: GO 69483
// for i = 1 to mc_bases do
69402: LD_ADDR_VAR 0 2
69406: PUSH
69407: DOUBLE
69408: LD_INT 1
69410: DEC
69411: ST_TO_ADDR
69412: LD_EXP 59
69416: PUSH
69417: FOR_TO
69418: IFFALSE 69481
// if mc_mines [ i ] and mc_miners [ i ] then
69420: LD_EXP 72
69424: PUSH
69425: LD_VAR 0 2
69429: ARRAY
69430: PUSH
69431: LD_EXP 73
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: AND
69442: IFFALSE 69479
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69444: LD_EXP 73
69448: PUSH
69449: LD_VAR 0 2
69453: ARRAY
69454: PUSH
69455: LD_INT 1
69457: ARRAY
69458: PPUSH
69459: CALL_OW 255
69463: PPUSH
69464: LD_EXP 72
69468: PUSH
69469: LD_VAR 0 2
69473: ARRAY
69474: PPUSH
69475: CALL 16272 0 2
69479: GO 69417
69481: POP
69482: POP
// end ;
69483: LD_VAR 0 1
69487: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69488: LD_INT 0
69490: PPUSH
69491: PPUSH
69492: PPUSH
69493: PPUSH
69494: PPUSH
69495: PPUSH
69496: PPUSH
69497: PPUSH
// if not mc_bases or not mc_parking then
69498: LD_EXP 59
69502: NOT
69503: PUSH
69504: LD_EXP 83
69508: NOT
69509: OR
69510: IFFALSE 69514
// exit ;
69512: GO 70213
// for i = 1 to mc_bases do
69514: LD_ADDR_VAR 0 2
69518: PUSH
69519: DOUBLE
69520: LD_INT 1
69522: DEC
69523: ST_TO_ADDR
69524: LD_EXP 59
69528: PUSH
69529: FOR_TO
69530: IFFALSE 70211
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69532: LD_EXP 59
69536: PUSH
69537: LD_VAR 0 2
69541: ARRAY
69542: NOT
69543: PUSH
69544: LD_EXP 83
69548: PUSH
69549: LD_VAR 0 2
69553: ARRAY
69554: NOT
69555: OR
69556: IFFALSE 69560
// continue ;
69558: GO 69529
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69560: LD_ADDR_VAR 0 5
69564: PUSH
69565: LD_EXP 59
69569: PUSH
69570: LD_VAR 0 2
69574: ARRAY
69575: PUSH
69576: LD_INT 1
69578: ARRAY
69579: PPUSH
69580: CALL_OW 255
69584: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69585: LD_ADDR_VAR 0 6
69589: PUSH
69590: LD_EXP 59
69594: PUSH
69595: LD_VAR 0 2
69599: ARRAY
69600: PPUSH
69601: LD_INT 30
69603: PUSH
69604: LD_INT 3
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PPUSH
69611: CALL_OW 72
69615: ST_TO_ADDR
// if not fac then
69616: LD_VAR 0 6
69620: NOT
69621: IFFALSE 69672
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69623: LD_ADDR_VAR 0 6
69627: PUSH
69628: LD_EXP 59
69632: PUSH
69633: LD_VAR 0 2
69637: ARRAY
69638: PPUSH
69639: LD_INT 2
69641: PUSH
69642: LD_INT 30
69644: PUSH
69645: LD_INT 0
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 30
69654: PUSH
69655: LD_INT 1
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: LIST
69666: PPUSH
69667: CALL_OW 72
69671: ST_TO_ADDR
// if not fac then
69672: LD_VAR 0 6
69676: NOT
69677: IFFALSE 69681
// continue ;
69679: GO 69529
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69681: LD_ADDR_VAR 0 7
69685: PUSH
69686: LD_EXP 83
69690: PUSH
69691: LD_VAR 0 2
69695: ARRAY
69696: PPUSH
69697: LD_INT 22
69699: PUSH
69700: LD_VAR 0 5
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 21
69711: PUSH
69712: LD_INT 2
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 3
69721: PUSH
69722: LD_INT 24
69724: PUSH
69725: LD_INT 1000
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: LIST
69740: PPUSH
69741: CALL_OW 70
69745: ST_TO_ADDR
// for j in fac do
69746: LD_ADDR_VAR 0 3
69750: PUSH
69751: LD_VAR 0 6
69755: PUSH
69756: FOR_IN
69757: IFFALSE 69838
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69759: LD_ADDR_VAR 0 7
69763: PUSH
69764: LD_VAR 0 7
69768: PUSH
69769: LD_INT 22
69771: PUSH
69772: LD_VAR 0 5
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 91
69783: PUSH
69784: LD_VAR 0 3
69788: PUSH
69789: LD_INT 15
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 21
69799: PUSH
69800: LD_INT 2
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 3
69809: PUSH
69810: LD_INT 24
69812: PUSH
69813: LD_INT 1000
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: PPUSH
69830: CALL_OW 69
69834: UNION
69835: ST_TO_ADDR
69836: GO 69756
69838: POP
69839: POP
// if not vehs then
69840: LD_VAR 0 7
69844: NOT
69845: IFFALSE 69871
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69847: LD_ADDR_EXP 71
69851: PUSH
69852: LD_EXP 71
69856: PPUSH
69857: LD_VAR 0 2
69861: PPUSH
69862: EMPTY
69863: PPUSH
69864: CALL_OW 1
69868: ST_TO_ADDR
// continue ;
69869: GO 69529
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69871: LD_ADDR_VAR 0 8
69875: PUSH
69876: LD_EXP 59
69880: PUSH
69881: LD_VAR 0 2
69885: ARRAY
69886: PPUSH
69887: LD_INT 30
69889: PUSH
69890: LD_INT 3
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PPUSH
69897: CALL_OW 72
69901: ST_TO_ADDR
// if tmp then
69902: LD_VAR 0 8
69906: IFFALSE 70009
// begin for j in tmp do
69908: LD_ADDR_VAR 0 3
69912: PUSH
69913: LD_VAR 0 8
69917: PUSH
69918: FOR_IN
69919: IFFALSE 70007
// for k in UnitsInside ( j ) do
69921: LD_ADDR_VAR 0 4
69925: PUSH
69926: LD_VAR 0 3
69930: PPUSH
69931: CALL_OW 313
69935: PUSH
69936: FOR_IN
69937: IFFALSE 70003
// if k then
69939: LD_VAR 0 4
69943: IFFALSE 70001
// if not k in mc_repair_vehicle [ i ] then
69945: LD_VAR 0 4
69949: PUSH
69950: LD_EXP 71
69954: PUSH
69955: LD_VAR 0 2
69959: ARRAY
69960: IN
69961: NOT
69962: IFFALSE 70001
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69964: LD_ADDR_EXP 71
69968: PUSH
69969: LD_EXP 71
69973: PPUSH
69974: LD_VAR 0 2
69978: PPUSH
69979: LD_EXP 71
69983: PUSH
69984: LD_VAR 0 2
69988: ARRAY
69989: PUSH
69990: LD_VAR 0 4
69994: UNION
69995: PPUSH
69996: CALL_OW 1
70000: ST_TO_ADDR
70001: GO 69936
70003: POP
70004: POP
70005: GO 69918
70007: POP
70008: POP
// end ; if not mc_repair_vehicle [ i ] then
70009: LD_EXP 71
70013: PUSH
70014: LD_VAR 0 2
70018: ARRAY
70019: NOT
70020: IFFALSE 70024
// continue ;
70022: GO 69529
// for j in mc_repair_vehicle [ i ] do
70024: LD_ADDR_VAR 0 3
70028: PUSH
70029: LD_EXP 71
70033: PUSH
70034: LD_VAR 0 2
70038: ARRAY
70039: PUSH
70040: FOR_IN
70041: IFFALSE 70207
// begin if GetClass ( j ) <> 3 then
70043: LD_VAR 0 3
70047: PPUSH
70048: CALL_OW 257
70052: PUSH
70053: LD_INT 3
70055: NONEQUAL
70056: IFFALSE 70097
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70058: LD_ADDR_EXP 71
70062: PUSH
70063: LD_EXP 71
70067: PPUSH
70068: LD_VAR 0 2
70072: PPUSH
70073: LD_EXP 71
70077: PUSH
70078: LD_VAR 0 2
70082: ARRAY
70083: PUSH
70084: LD_VAR 0 3
70088: DIFF
70089: PPUSH
70090: CALL_OW 1
70094: ST_TO_ADDR
// continue ;
70095: GO 70040
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70097: LD_VAR 0 3
70101: PPUSH
70102: CALL_OW 311
70106: NOT
70107: PUSH
70108: LD_VAR 0 3
70112: PUSH
70113: LD_EXP 62
70117: PUSH
70118: LD_VAR 0 2
70122: ARRAY
70123: PUSH
70124: LD_INT 1
70126: ARRAY
70127: IN
70128: NOT
70129: AND
70130: PUSH
70131: LD_VAR 0 3
70135: PUSH
70136: LD_EXP 62
70140: PUSH
70141: LD_VAR 0 2
70145: ARRAY
70146: PUSH
70147: LD_INT 2
70149: ARRAY
70150: IN
70151: NOT
70152: AND
70153: IFFALSE 70205
// begin if IsInUnit ( j ) then
70155: LD_VAR 0 3
70159: PPUSH
70160: CALL_OW 310
70164: IFFALSE 70175
// ComExitBuilding ( j ) ;
70166: LD_VAR 0 3
70170: PPUSH
70171: CALL_OW 122
// if not HasTask ( j ) then
70175: LD_VAR 0 3
70179: PPUSH
70180: CALL_OW 314
70184: NOT
70185: IFFALSE 70205
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
70187: LD_VAR 0 3
70191: PPUSH
70192: LD_VAR 0 7
70196: PUSH
70197: LD_INT 1
70199: ARRAY
70200: PPUSH
70201: CALL_OW 189
// end ; end ;
70205: GO 70040
70207: POP
70208: POP
// end ;
70209: GO 69529
70211: POP
70212: POP
// end ;
70213: LD_VAR 0 1
70217: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70218: LD_INT 0
70220: PPUSH
70221: PPUSH
70222: PPUSH
70223: PPUSH
70224: PPUSH
70225: PPUSH
70226: PPUSH
70227: PPUSH
70228: PPUSH
70229: PPUSH
70230: PPUSH
// if not mc_bases then
70231: LD_EXP 59
70235: NOT
70236: IFFALSE 70240
// exit ;
70238: GO 71042
// for i = 1 to mc_bases do
70240: LD_ADDR_VAR 0 2
70244: PUSH
70245: DOUBLE
70246: LD_INT 1
70248: DEC
70249: ST_TO_ADDR
70250: LD_EXP 59
70254: PUSH
70255: FOR_TO
70256: IFFALSE 71040
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70258: LD_EXP 87
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: NOT
70269: PUSH
70270: LD_EXP 62
70274: PUSH
70275: LD_VAR 0 2
70279: ARRAY
70280: PUSH
70281: LD_INT 1
70283: ARRAY
70284: OR
70285: PUSH
70286: LD_EXP 62
70290: PUSH
70291: LD_VAR 0 2
70295: ARRAY
70296: PUSH
70297: LD_INT 2
70299: ARRAY
70300: OR
70301: PUSH
70302: LD_EXP 85
70306: PUSH
70307: LD_VAR 0 2
70311: ARRAY
70312: PPUSH
70313: LD_INT 1
70315: PPUSH
70316: CALL_OW 325
70320: NOT
70321: OR
70322: PUSH
70323: LD_EXP 82
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: OR
70334: IFFALSE 70338
// continue ;
70336: GO 70255
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70338: LD_ADDR_VAR 0 8
70342: PUSH
70343: LD_EXP 59
70347: PUSH
70348: LD_VAR 0 2
70352: ARRAY
70353: PPUSH
70354: LD_INT 25
70356: PUSH
70357: LD_INT 4
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 50
70366: PUSH
70367: EMPTY
70368: LIST
70369: PUSH
70370: LD_INT 3
70372: PUSH
70373: LD_INT 60
70375: PUSH
70376: EMPTY
70377: LIST
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: LIST
70387: PPUSH
70388: CALL_OW 72
70392: PUSH
70393: LD_EXP 63
70397: PUSH
70398: LD_VAR 0 2
70402: ARRAY
70403: DIFF
70404: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70405: LD_ADDR_VAR 0 9
70409: PUSH
70410: LD_EXP 59
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PPUSH
70421: LD_INT 2
70423: PUSH
70424: LD_INT 30
70426: PUSH
70427: LD_INT 0
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: PUSH
70434: LD_INT 30
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: LIST
70448: PPUSH
70449: CALL_OW 72
70453: ST_TO_ADDR
// if not tmp or not dep then
70454: LD_VAR 0 8
70458: NOT
70459: PUSH
70460: LD_VAR 0 9
70464: NOT
70465: OR
70466: IFFALSE 70470
// continue ;
70468: GO 70255
// side := GetSide ( tmp [ 1 ] ) ;
70470: LD_ADDR_VAR 0 11
70474: PUSH
70475: LD_VAR 0 8
70479: PUSH
70480: LD_INT 1
70482: ARRAY
70483: PPUSH
70484: CALL_OW 255
70488: ST_TO_ADDR
// dep := dep [ 1 ] ;
70489: LD_ADDR_VAR 0 9
70493: PUSH
70494: LD_VAR 0 9
70498: PUSH
70499: LD_INT 1
70501: ARRAY
70502: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70503: LD_ADDR_VAR 0 7
70507: PUSH
70508: LD_EXP 87
70512: PUSH
70513: LD_VAR 0 2
70517: ARRAY
70518: PPUSH
70519: LD_INT 22
70521: PUSH
70522: LD_INT 0
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: LD_INT 25
70531: PUSH
70532: LD_INT 12
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PPUSH
70543: CALL_OW 70
70547: PUSH
70548: LD_INT 22
70550: PUSH
70551: LD_INT 0
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 25
70560: PUSH
70561: LD_INT 12
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 91
70570: PUSH
70571: LD_VAR 0 9
70575: PUSH
70576: LD_INT 20
70578: PUSH
70579: EMPTY
70580: LIST
70581: LIST
70582: LIST
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: LIST
70588: PPUSH
70589: CALL_OW 69
70593: UNION
70594: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70595: LD_ADDR_VAR 0 10
70599: PUSH
70600: LD_EXP 87
70604: PUSH
70605: LD_VAR 0 2
70609: ARRAY
70610: PPUSH
70611: LD_INT 81
70613: PUSH
70614: LD_VAR 0 11
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PPUSH
70623: CALL_OW 70
70627: ST_TO_ADDR
// if not apes or danger_at_area then
70628: LD_VAR 0 7
70632: NOT
70633: PUSH
70634: LD_VAR 0 10
70638: OR
70639: IFFALSE 70689
// begin if mc_taming [ i ] then
70641: LD_EXP 90
70645: PUSH
70646: LD_VAR 0 2
70650: ARRAY
70651: IFFALSE 70687
// begin MC_Reset ( i , 121 ) ;
70653: LD_VAR 0 2
70657: PPUSH
70658: LD_INT 121
70660: PPUSH
70661: CALL 56071 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70665: LD_ADDR_EXP 90
70669: PUSH
70670: LD_EXP 90
70674: PPUSH
70675: LD_VAR 0 2
70679: PPUSH
70680: EMPTY
70681: PPUSH
70682: CALL_OW 1
70686: ST_TO_ADDR
// end ; continue ;
70687: GO 70255
// end ; for j in tmp do
70689: LD_ADDR_VAR 0 3
70693: PUSH
70694: LD_VAR 0 8
70698: PUSH
70699: FOR_IN
70700: IFFALSE 71036
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70702: LD_VAR 0 3
70706: PUSH
70707: LD_EXP 90
70711: PUSH
70712: LD_VAR 0 2
70716: ARRAY
70717: IN
70718: NOT
70719: PUSH
70720: LD_EXP 90
70724: PUSH
70725: LD_VAR 0 2
70729: ARRAY
70730: PUSH
70731: LD_INT 3
70733: LESS
70734: AND
70735: IFFALSE 70793
// begin SetTag ( j , 121 ) ;
70737: LD_VAR 0 3
70741: PPUSH
70742: LD_INT 121
70744: PPUSH
70745: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70749: LD_ADDR_EXP 90
70753: PUSH
70754: LD_EXP 90
70758: PPUSH
70759: LD_VAR 0 2
70763: PUSH
70764: LD_EXP 90
70768: PUSH
70769: LD_VAR 0 2
70773: ARRAY
70774: PUSH
70775: LD_INT 1
70777: PLUS
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: PPUSH
70783: LD_VAR 0 3
70787: PPUSH
70788: CALL 19283 0 3
70792: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70793: LD_VAR 0 3
70797: PUSH
70798: LD_EXP 90
70802: PUSH
70803: LD_VAR 0 2
70807: ARRAY
70808: IN
70809: IFFALSE 71034
// begin if GetClass ( j ) <> 4 then
70811: LD_VAR 0 3
70815: PPUSH
70816: CALL_OW 257
70820: PUSH
70821: LD_INT 4
70823: NONEQUAL
70824: IFFALSE 70877
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70826: LD_ADDR_EXP 90
70830: PUSH
70831: LD_EXP 90
70835: PPUSH
70836: LD_VAR 0 2
70840: PPUSH
70841: LD_EXP 90
70845: PUSH
70846: LD_VAR 0 2
70850: ARRAY
70851: PUSH
70852: LD_VAR 0 3
70856: DIFF
70857: PPUSH
70858: CALL_OW 1
70862: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70863: LD_VAR 0 3
70867: PPUSH
70868: LD_INT 0
70870: PPUSH
70871: CALL_OW 109
// continue ;
70875: GO 70699
// end ; if IsInUnit ( j ) then
70877: LD_VAR 0 3
70881: PPUSH
70882: CALL_OW 310
70886: IFFALSE 70897
// ComExitBuilding ( j ) ;
70888: LD_VAR 0 3
70892: PPUSH
70893: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70897: LD_ADDR_VAR 0 6
70901: PUSH
70902: LD_VAR 0 7
70906: PPUSH
70907: LD_VAR 0 3
70911: PPUSH
70912: CALL_OW 74
70916: ST_TO_ADDR
// if not ape then
70917: LD_VAR 0 6
70921: NOT
70922: IFFALSE 70926
// break ;
70924: GO 71036
// x := GetX ( ape ) ;
70926: LD_ADDR_VAR 0 4
70930: PUSH
70931: LD_VAR 0 6
70935: PPUSH
70936: CALL_OW 250
70940: ST_TO_ADDR
// y := GetY ( ape ) ;
70941: LD_ADDR_VAR 0 5
70945: PUSH
70946: LD_VAR 0 6
70950: PPUSH
70951: CALL_OW 251
70955: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70956: LD_VAR 0 4
70960: PPUSH
70961: LD_VAR 0 5
70965: PPUSH
70966: CALL_OW 488
70970: NOT
70971: PUSH
70972: LD_VAR 0 11
70976: PPUSH
70977: LD_VAR 0 4
70981: PPUSH
70982: LD_VAR 0 5
70986: PPUSH
70987: LD_INT 20
70989: PPUSH
70990: CALL 20179 0 4
70994: PUSH
70995: LD_INT 4
70997: ARRAY
70998: OR
70999: IFFALSE 71003
// break ;
71001: GO 71036
// if not HasTask ( j ) then
71003: LD_VAR 0 3
71007: PPUSH
71008: CALL_OW 314
71012: NOT
71013: IFFALSE 71034
// ComTameXY ( j , x , y ) ;
71015: LD_VAR 0 3
71019: PPUSH
71020: LD_VAR 0 4
71024: PPUSH
71025: LD_VAR 0 5
71029: PPUSH
71030: CALL_OW 131
// end ; end ;
71034: GO 70699
71036: POP
71037: POP
// end ;
71038: GO 70255
71040: POP
71041: POP
// end ;
71042: LD_VAR 0 1
71046: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71047: LD_INT 0
71049: PPUSH
71050: PPUSH
71051: PPUSH
71052: PPUSH
71053: PPUSH
71054: PPUSH
71055: PPUSH
71056: PPUSH
// if not mc_bases then
71057: LD_EXP 59
71061: NOT
71062: IFFALSE 71066
// exit ;
71064: GO 71692
// for i = 1 to mc_bases do
71066: LD_ADDR_VAR 0 2
71070: PUSH
71071: DOUBLE
71072: LD_INT 1
71074: DEC
71075: ST_TO_ADDR
71076: LD_EXP 59
71080: PUSH
71081: FOR_TO
71082: IFFALSE 71690
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71084: LD_EXP 88
71088: PUSH
71089: LD_VAR 0 2
71093: ARRAY
71094: NOT
71095: PUSH
71096: LD_EXP 88
71100: PUSH
71101: LD_VAR 0 2
71105: ARRAY
71106: PPUSH
71107: LD_INT 25
71109: PUSH
71110: LD_INT 12
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PPUSH
71117: CALL_OW 72
71121: NOT
71122: OR
71123: IFFALSE 71127
// continue ;
71125: GO 71081
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71127: LD_ADDR_VAR 0 5
71131: PUSH
71132: LD_EXP 88
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PUSH
71143: LD_INT 1
71145: ARRAY
71146: PPUSH
71147: CALL_OW 255
71151: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71152: LD_VAR 0 5
71156: PPUSH
71157: LD_INT 2
71159: PPUSH
71160: CALL_OW 325
71164: IFFALSE 71417
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71166: LD_ADDR_VAR 0 4
71170: PUSH
71171: LD_EXP 88
71175: PUSH
71176: LD_VAR 0 2
71180: ARRAY
71181: PPUSH
71182: LD_INT 25
71184: PUSH
71185: LD_INT 16
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PPUSH
71192: CALL_OW 72
71196: ST_TO_ADDR
// if tmp < 6 then
71197: LD_VAR 0 4
71201: PUSH
71202: LD_INT 6
71204: LESS
71205: IFFALSE 71417
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71207: LD_ADDR_VAR 0 6
71211: PUSH
71212: LD_EXP 59
71216: PUSH
71217: LD_VAR 0 2
71221: ARRAY
71222: PPUSH
71223: LD_INT 2
71225: PUSH
71226: LD_INT 30
71228: PUSH
71229: LD_INT 0
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 30
71238: PUSH
71239: LD_INT 1
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: LIST
71250: PPUSH
71251: CALL_OW 72
71255: ST_TO_ADDR
// if depot then
71256: LD_VAR 0 6
71260: IFFALSE 71417
// begin selected := 0 ;
71262: LD_ADDR_VAR 0 7
71266: PUSH
71267: LD_INT 0
71269: ST_TO_ADDR
// for j in depot do
71270: LD_ADDR_VAR 0 3
71274: PUSH
71275: LD_VAR 0 6
71279: PUSH
71280: FOR_IN
71281: IFFALSE 71312
// begin if UnitsInside ( j ) < 6 then
71283: LD_VAR 0 3
71287: PPUSH
71288: CALL_OW 313
71292: PUSH
71293: LD_INT 6
71295: LESS
71296: IFFALSE 71310
// begin selected := j ;
71298: LD_ADDR_VAR 0 7
71302: PUSH
71303: LD_VAR 0 3
71307: ST_TO_ADDR
// break ;
71308: GO 71312
// end ; end ;
71310: GO 71280
71312: POP
71313: POP
// if selected then
71314: LD_VAR 0 7
71318: IFFALSE 71417
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71320: LD_ADDR_VAR 0 3
71324: PUSH
71325: LD_EXP 88
71329: PUSH
71330: LD_VAR 0 2
71334: ARRAY
71335: PPUSH
71336: LD_INT 25
71338: PUSH
71339: LD_INT 12
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PPUSH
71346: CALL_OW 72
71350: PUSH
71351: FOR_IN
71352: IFFALSE 71415
// if not HasTask ( j ) then
71354: LD_VAR 0 3
71358: PPUSH
71359: CALL_OW 314
71363: NOT
71364: IFFALSE 71413
// begin if not IsInUnit ( j ) then
71366: LD_VAR 0 3
71370: PPUSH
71371: CALL_OW 310
71375: NOT
71376: IFFALSE 71392
// ComEnterUnit ( j , selected ) ;
71378: LD_VAR 0 3
71382: PPUSH
71383: LD_VAR 0 7
71387: PPUSH
71388: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71392: LD_VAR 0 3
71396: PPUSH
71397: LD_INT 16
71399: PPUSH
71400: CALL_OW 183
// AddComExitBuilding ( j ) ;
71404: LD_VAR 0 3
71408: PPUSH
71409: CALL_OW 182
// end ;
71413: GO 71351
71415: POP
71416: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71417: LD_VAR 0 5
71421: PPUSH
71422: LD_INT 11
71424: PPUSH
71425: CALL_OW 325
71429: IFFALSE 71688
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71431: LD_ADDR_VAR 0 4
71435: PUSH
71436: LD_EXP 88
71440: PUSH
71441: LD_VAR 0 2
71445: ARRAY
71446: PPUSH
71447: LD_INT 25
71449: PUSH
71450: LD_INT 16
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PPUSH
71457: CALL_OW 72
71461: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71462: LD_VAR 0 4
71466: PUSH
71467: LD_INT 6
71469: GREATEREQUAL
71470: PUSH
71471: LD_VAR 0 5
71475: PPUSH
71476: LD_INT 2
71478: PPUSH
71479: CALL_OW 325
71483: NOT
71484: OR
71485: IFFALSE 71688
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71487: LD_ADDR_VAR 0 8
71491: PUSH
71492: LD_EXP 59
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: PPUSH
71503: LD_INT 2
71505: PUSH
71506: LD_INT 30
71508: PUSH
71509: LD_INT 4
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 30
71518: PUSH
71519: LD_INT 5
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: LIST
71530: PPUSH
71531: CALL_OW 72
71535: ST_TO_ADDR
// if barracks then
71536: LD_VAR 0 8
71540: IFFALSE 71688
// begin selected := 0 ;
71542: LD_ADDR_VAR 0 7
71546: PUSH
71547: LD_INT 0
71549: ST_TO_ADDR
// for j in barracks do
71550: LD_ADDR_VAR 0 3
71554: PUSH
71555: LD_VAR 0 8
71559: PUSH
71560: FOR_IN
71561: IFFALSE 71592
// begin if UnitsInside ( j ) < 6 then
71563: LD_VAR 0 3
71567: PPUSH
71568: CALL_OW 313
71572: PUSH
71573: LD_INT 6
71575: LESS
71576: IFFALSE 71590
// begin selected := j ;
71578: LD_ADDR_VAR 0 7
71582: PUSH
71583: LD_VAR 0 3
71587: ST_TO_ADDR
// break ;
71588: GO 71592
// end ; end ;
71590: GO 71560
71592: POP
71593: POP
// if selected then
71594: LD_VAR 0 7
71598: IFFALSE 71688
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71600: LD_ADDR_VAR 0 3
71604: PUSH
71605: LD_EXP 88
71609: PUSH
71610: LD_VAR 0 2
71614: ARRAY
71615: PPUSH
71616: LD_INT 25
71618: PUSH
71619: LD_INT 12
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PPUSH
71626: CALL_OW 72
71630: PUSH
71631: FOR_IN
71632: IFFALSE 71686
// if not IsInUnit ( j ) and not HasTask ( j ) then
71634: LD_VAR 0 3
71638: PPUSH
71639: CALL_OW 310
71643: NOT
71644: PUSH
71645: LD_VAR 0 3
71649: PPUSH
71650: CALL_OW 314
71654: NOT
71655: AND
71656: IFFALSE 71684
// begin ComEnterUnit ( j , selected ) ;
71658: LD_VAR 0 3
71662: PPUSH
71663: LD_VAR 0 7
71667: PPUSH
71668: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71672: LD_VAR 0 3
71676: PPUSH
71677: LD_INT 15
71679: PPUSH
71680: CALL_OW 183
// end ;
71684: GO 71631
71686: POP
71687: POP
// end ; end ; end ; end ; end ;
71688: GO 71081
71690: POP
71691: POP
// end ;
71692: LD_VAR 0 1
71696: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71697: LD_INT 0
71699: PPUSH
71700: PPUSH
71701: PPUSH
71702: PPUSH
// if not mc_bases then
71703: LD_EXP 59
71707: NOT
71708: IFFALSE 71712
// exit ;
71710: GO 71890
// for i = 1 to mc_bases do
71712: LD_ADDR_VAR 0 2
71716: PUSH
71717: DOUBLE
71718: LD_INT 1
71720: DEC
71721: ST_TO_ADDR
71722: LD_EXP 59
71726: PUSH
71727: FOR_TO
71728: IFFALSE 71888
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71730: LD_ADDR_VAR 0 4
71734: PUSH
71735: LD_EXP 59
71739: PUSH
71740: LD_VAR 0 2
71744: ARRAY
71745: PPUSH
71746: LD_INT 25
71748: PUSH
71749: LD_INT 9
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PPUSH
71756: CALL_OW 72
71760: ST_TO_ADDR
// if not tmp then
71761: LD_VAR 0 4
71765: NOT
71766: IFFALSE 71770
// continue ;
71768: GO 71727
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71770: LD_EXP 85
71774: PUSH
71775: LD_VAR 0 2
71779: ARRAY
71780: PPUSH
71781: LD_INT 29
71783: PPUSH
71784: CALL_OW 325
71788: NOT
71789: PUSH
71790: LD_EXP 85
71794: PUSH
71795: LD_VAR 0 2
71799: ARRAY
71800: PPUSH
71801: LD_INT 28
71803: PPUSH
71804: CALL_OW 325
71808: NOT
71809: AND
71810: IFFALSE 71814
// continue ;
71812: GO 71727
// for j in tmp do
71814: LD_ADDR_VAR 0 3
71818: PUSH
71819: LD_VAR 0 4
71823: PUSH
71824: FOR_IN
71825: IFFALSE 71884
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71827: LD_VAR 0 3
71831: PUSH
71832: LD_EXP 62
71836: PUSH
71837: LD_VAR 0 2
71841: ARRAY
71842: PUSH
71843: LD_INT 1
71845: ARRAY
71846: IN
71847: NOT
71848: PUSH
71849: LD_VAR 0 3
71853: PUSH
71854: LD_EXP 62
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: PUSH
71865: LD_INT 2
71867: ARRAY
71868: IN
71869: NOT
71870: AND
71871: IFFALSE 71882
// ComSpaceTimeShoot ( j ) ;
71873: LD_VAR 0 3
71877: PPUSH
71878: CALL 15280 0 1
71882: GO 71824
71884: POP
71885: POP
// end ;
71886: GO 71727
71888: POP
71889: POP
// end ;
71890: LD_VAR 0 1
71894: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71895: LD_INT 0
71897: PPUSH
71898: PPUSH
71899: PPUSH
71900: PPUSH
71901: PPUSH
71902: PPUSH
71903: PPUSH
71904: PPUSH
71905: PPUSH
// if not mc_bases then
71906: LD_EXP 59
71910: NOT
71911: IFFALSE 71915
// exit ;
71913: GO 72537
// for i = 1 to mc_bases do
71915: LD_ADDR_VAR 0 2
71919: PUSH
71920: DOUBLE
71921: LD_INT 1
71923: DEC
71924: ST_TO_ADDR
71925: LD_EXP 59
71929: PUSH
71930: FOR_TO
71931: IFFALSE 72535
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71933: LD_EXP 94
71937: PUSH
71938: LD_VAR 0 2
71942: ARRAY
71943: NOT
71944: PUSH
71945: LD_INT 38
71947: PPUSH
71948: LD_EXP 85
71952: PUSH
71953: LD_VAR 0 2
71957: ARRAY
71958: PPUSH
71959: CALL_OW 321
71963: PUSH
71964: LD_INT 2
71966: NONEQUAL
71967: OR
71968: IFFALSE 71972
// continue ;
71970: GO 71930
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71972: LD_ADDR_VAR 0 8
71976: PUSH
71977: LD_EXP 59
71981: PUSH
71982: LD_VAR 0 2
71986: ARRAY
71987: PPUSH
71988: LD_INT 30
71990: PUSH
71991: LD_INT 34
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PPUSH
71998: CALL_OW 72
72002: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72003: LD_ADDR_VAR 0 9
72007: PUSH
72008: LD_EXP 59
72012: PUSH
72013: LD_VAR 0 2
72017: ARRAY
72018: PPUSH
72019: LD_INT 25
72021: PUSH
72022: LD_INT 4
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PPUSH
72029: CALL_OW 72
72033: PPUSH
72034: LD_INT 0
72036: PPUSH
72037: CALL 48177 0 2
72041: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72042: LD_VAR 0 9
72046: NOT
72047: PUSH
72048: LD_VAR 0 8
72052: NOT
72053: OR
72054: PUSH
72055: LD_EXP 59
72059: PUSH
72060: LD_VAR 0 2
72064: ARRAY
72065: PPUSH
72066: LD_INT 124
72068: PPUSH
72069: CALL 48177 0 2
72073: OR
72074: IFFALSE 72078
// continue ;
72076: GO 71930
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72078: LD_EXP 95
72082: PUSH
72083: LD_VAR 0 2
72087: ARRAY
72088: PUSH
72089: LD_EXP 94
72093: PUSH
72094: LD_VAR 0 2
72098: ARRAY
72099: LESS
72100: PUSH
72101: LD_EXP 95
72105: PUSH
72106: LD_VAR 0 2
72110: ARRAY
72111: PUSH
72112: LD_VAR 0 8
72116: LESS
72117: AND
72118: IFFALSE 72533
// begin tmp := sci [ 1 ] ;
72120: LD_ADDR_VAR 0 7
72124: PUSH
72125: LD_VAR 0 9
72129: PUSH
72130: LD_INT 1
72132: ARRAY
72133: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72134: LD_VAR 0 7
72138: PPUSH
72139: LD_INT 124
72141: PPUSH
72142: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72146: LD_ADDR_VAR 0 3
72150: PUSH
72151: DOUBLE
72152: LD_EXP 94
72156: PUSH
72157: LD_VAR 0 2
72161: ARRAY
72162: INC
72163: ST_TO_ADDR
72164: LD_EXP 94
72168: PUSH
72169: LD_VAR 0 2
72173: ARRAY
72174: PUSH
72175: FOR_DOWNTO
72176: IFFALSE 72519
// begin if IsInUnit ( tmp ) then
72178: LD_VAR 0 7
72182: PPUSH
72183: CALL_OW 310
72187: IFFALSE 72198
// ComExitBuilding ( tmp ) ;
72189: LD_VAR 0 7
72193: PPUSH
72194: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72198: LD_INT 35
72200: PPUSH
72201: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72205: LD_VAR 0 7
72209: PPUSH
72210: CALL_OW 310
72214: NOT
72215: PUSH
72216: LD_VAR 0 7
72220: PPUSH
72221: CALL_OW 314
72225: NOT
72226: AND
72227: IFFALSE 72198
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72229: LD_ADDR_VAR 0 6
72233: PUSH
72234: LD_VAR 0 7
72238: PPUSH
72239: CALL_OW 250
72243: PUSH
72244: LD_VAR 0 7
72248: PPUSH
72249: CALL_OW 251
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72258: LD_INT 35
72260: PPUSH
72261: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72265: LD_ADDR_VAR 0 4
72269: PUSH
72270: LD_EXP 94
72274: PUSH
72275: LD_VAR 0 2
72279: ARRAY
72280: PUSH
72281: LD_VAR 0 3
72285: ARRAY
72286: PUSH
72287: LD_INT 1
72289: ARRAY
72290: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72291: LD_ADDR_VAR 0 5
72295: PUSH
72296: LD_EXP 94
72300: PUSH
72301: LD_VAR 0 2
72305: ARRAY
72306: PUSH
72307: LD_VAR 0 3
72311: ARRAY
72312: PUSH
72313: LD_INT 2
72315: ARRAY
72316: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72317: LD_VAR 0 7
72321: PPUSH
72322: LD_INT 10
72324: PPUSH
72325: CALL 21876 0 2
72329: PUSH
72330: LD_INT 4
72332: ARRAY
72333: IFFALSE 72371
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72335: LD_VAR 0 7
72339: PPUSH
72340: LD_VAR 0 6
72344: PUSH
72345: LD_INT 1
72347: ARRAY
72348: PPUSH
72349: LD_VAR 0 6
72353: PUSH
72354: LD_INT 2
72356: ARRAY
72357: PPUSH
72358: CALL_OW 111
// wait ( 0 0$10 ) ;
72362: LD_INT 350
72364: PPUSH
72365: CALL_OW 67
// end else
72369: GO 72397
// begin ComMoveXY ( tmp , x , y ) ;
72371: LD_VAR 0 7
72375: PPUSH
72376: LD_VAR 0 4
72380: PPUSH
72381: LD_VAR 0 5
72385: PPUSH
72386: CALL_OW 111
// wait ( 0 0$3 ) ;
72390: LD_INT 105
72392: PPUSH
72393: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72397: LD_VAR 0 7
72401: PPUSH
72402: LD_VAR 0 4
72406: PPUSH
72407: LD_VAR 0 5
72411: PPUSH
72412: CALL_OW 307
72416: IFFALSE 72258
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72418: LD_VAR 0 7
72422: PPUSH
72423: LD_VAR 0 4
72427: PPUSH
72428: LD_VAR 0 5
72432: PPUSH
72433: LD_VAR 0 8
72437: PUSH
72438: LD_VAR 0 3
72442: ARRAY
72443: PPUSH
72444: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72448: LD_INT 35
72450: PPUSH
72451: CALL_OW 67
// until not HasTask ( tmp ) ;
72455: LD_VAR 0 7
72459: PPUSH
72460: CALL_OW 314
72464: NOT
72465: IFFALSE 72448
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72467: LD_ADDR_EXP 95
72471: PUSH
72472: LD_EXP 95
72476: PPUSH
72477: LD_VAR 0 2
72481: PUSH
72482: LD_EXP 95
72486: PUSH
72487: LD_VAR 0 2
72491: ARRAY
72492: PUSH
72493: LD_INT 1
72495: PLUS
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PPUSH
72501: LD_VAR 0 8
72505: PUSH
72506: LD_VAR 0 3
72510: ARRAY
72511: PPUSH
72512: CALL 19283 0 3
72516: ST_TO_ADDR
// end ;
72517: GO 72175
72519: POP
72520: POP
// MC_Reset ( i , 124 ) ;
72521: LD_VAR 0 2
72525: PPUSH
72526: LD_INT 124
72528: PPUSH
72529: CALL 56071 0 2
// end ; end ;
72533: GO 71930
72535: POP
72536: POP
// end ;
72537: LD_VAR 0 1
72541: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72542: LD_INT 0
72544: PPUSH
72545: PPUSH
72546: PPUSH
// if not mc_bases then
72547: LD_EXP 59
72551: NOT
72552: IFFALSE 72556
// exit ;
72554: GO 73162
// for i = 1 to mc_bases do
72556: LD_ADDR_VAR 0 2
72560: PUSH
72561: DOUBLE
72562: LD_INT 1
72564: DEC
72565: ST_TO_ADDR
72566: LD_EXP 59
72570: PUSH
72571: FOR_TO
72572: IFFALSE 73160
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72574: LD_ADDR_VAR 0 3
72578: PUSH
72579: LD_EXP 59
72583: PUSH
72584: LD_VAR 0 2
72588: ARRAY
72589: PPUSH
72590: LD_INT 25
72592: PUSH
72593: LD_INT 4
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PPUSH
72600: CALL_OW 72
72604: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72605: LD_VAR 0 3
72609: NOT
72610: PUSH
72611: LD_EXP 96
72615: PUSH
72616: LD_VAR 0 2
72620: ARRAY
72621: NOT
72622: OR
72623: PUSH
72624: LD_EXP 59
72628: PUSH
72629: LD_VAR 0 2
72633: ARRAY
72634: PPUSH
72635: LD_INT 2
72637: PUSH
72638: LD_INT 30
72640: PUSH
72641: LD_INT 0
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 30
72650: PUSH
72651: LD_INT 1
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: LIST
72662: PPUSH
72663: CALL_OW 72
72667: NOT
72668: OR
72669: IFFALSE 72719
// begin if mc_deposits_finder [ i ] then
72671: LD_EXP 97
72675: PUSH
72676: LD_VAR 0 2
72680: ARRAY
72681: IFFALSE 72717
// begin MC_Reset ( i , 125 ) ;
72683: LD_VAR 0 2
72687: PPUSH
72688: LD_INT 125
72690: PPUSH
72691: CALL 56071 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72695: LD_ADDR_EXP 97
72699: PUSH
72700: LD_EXP 97
72704: PPUSH
72705: LD_VAR 0 2
72709: PPUSH
72710: EMPTY
72711: PPUSH
72712: CALL_OW 1
72716: ST_TO_ADDR
// end ; continue ;
72717: GO 72571
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72719: LD_EXP 96
72723: PUSH
72724: LD_VAR 0 2
72728: ARRAY
72729: PUSH
72730: LD_INT 1
72732: ARRAY
72733: PUSH
72734: LD_INT 3
72736: ARRAY
72737: PUSH
72738: LD_INT 1
72740: EQUAL
72741: PUSH
72742: LD_INT 20
72744: PPUSH
72745: LD_EXP 85
72749: PUSH
72750: LD_VAR 0 2
72754: ARRAY
72755: PPUSH
72756: CALL_OW 321
72760: PUSH
72761: LD_INT 2
72763: NONEQUAL
72764: AND
72765: IFFALSE 72815
// begin if mc_deposits_finder [ i ] then
72767: LD_EXP 97
72771: PUSH
72772: LD_VAR 0 2
72776: ARRAY
72777: IFFALSE 72813
// begin MC_Reset ( i , 125 ) ;
72779: LD_VAR 0 2
72783: PPUSH
72784: LD_INT 125
72786: PPUSH
72787: CALL 56071 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72791: LD_ADDR_EXP 97
72795: PUSH
72796: LD_EXP 97
72800: PPUSH
72801: LD_VAR 0 2
72805: PPUSH
72806: EMPTY
72807: PPUSH
72808: CALL_OW 1
72812: ST_TO_ADDR
// end ; continue ;
72813: GO 72571
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72815: LD_EXP 96
72819: PUSH
72820: LD_VAR 0 2
72824: ARRAY
72825: PUSH
72826: LD_INT 1
72828: ARRAY
72829: PUSH
72830: LD_INT 1
72832: ARRAY
72833: PPUSH
72834: LD_EXP 96
72838: PUSH
72839: LD_VAR 0 2
72843: ARRAY
72844: PUSH
72845: LD_INT 1
72847: ARRAY
72848: PUSH
72849: LD_INT 2
72851: ARRAY
72852: PPUSH
72853: LD_EXP 85
72857: PUSH
72858: LD_VAR 0 2
72862: ARRAY
72863: PPUSH
72864: CALL_OW 440
72868: IFFALSE 72911
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72870: LD_ADDR_EXP 96
72874: PUSH
72875: LD_EXP 96
72879: PPUSH
72880: LD_VAR 0 2
72884: PPUSH
72885: LD_EXP 96
72889: PUSH
72890: LD_VAR 0 2
72894: ARRAY
72895: PPUSH
72896: LD_INT 1
72898: PPUSH
72899: CALL_OW 3
72903: PPUSH
72904: CALL_OW 1
72908: ST_TO_ADDR
72909: GO 73158
// begin if not mc_deposits_finder [ i ] then
72911: LD_EXP 97
72915: PUSH
72916: LD_VAR 0 2
72920: ARRAY
72921: NOT
72922: IFFALSE 72974
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72924: LD_ADDR_EXP 97
72928: PUSH
72929: LD_EXP 97
72933: PPUSH
72934: LD_VAR 0 2
72938: PPUSH
72939: LD_VAR 0 3
72943: PUSH
72944: LD_INT 1
72946: ARRAY
72947: PUSH
72948: EMPTY
72949: LIST
72950: PPUSH
72951: CALL_OW 1
72955: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72956: LD_VAR 0 3
72960: PUSH
72961: LD_INT 1
72963: ARRAY
72964: PPUSH
72965: LD_INT 125
72967: PPUSH
72968: CALL_OW 109
// end else
72972: GO 73158
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72974: LD_EXP 97
72978: PUSH
72979: LD_VAR 0 2
72983: ARRAY
72984: PUSH
72985: LD_INT 1
72987: ARRAY
72988: PPUSH
72989: CALL_OW 310
72993: IFFALSE 73016
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72995: LD_EXP 97
72999: PUSH
73000: LD_VAR 0 2
73004: ARRAY
73005: PUSH
73006: LD_INT 1
73008: ARRAY
73009: PPUSH
73010: CALL_OW 122
73014: GO 73158
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73016: LD_EXP 97
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: PUSH
73027: LD_INT 1
73029: ARRAY
73030: PPUSH
73031: CALL_OW 314
73035: NOT
73036: PUSH
73037: LD_EXP 97
73041: PUSH
73042: LD_VAR 0 2
73046: ARRAY
73047: PUSH
73048: LD_INT 1
73050: ARRAY
73051: PPUSH
73052: LD_EXP 96
73056: PUSH
73057: LD_VAR 0 2
73061: ARRAY
73062: PUSH
73063: LD_INT 1
73065: ARRAY
73066: PUSH
73067: LD_INT 1
73069: ARRAY
73070: PPUSH
73071: LD_EXP 96
73075: PUSH
73076: LD_VAR 0 2
73080: ARRAY
73081: PUSH
73082: LD_INT 1
73084: ARRAY
73085: PUSH
73086: LD_INT 2
73088: ARRAY
73089: PPUSH
73090: CALL_OW 297
73094: PUSH
73095: LD_INT 6
73097: GREATER
73098: AND
73099: IFFALSE 73158
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73101: LD_EXP 97
73105: PUSH
73106: LD_VAR 0 2
73110: ARRAY
73111: PUSH
73112: LD_INT 1
73114: ARRAY
73115: PPUSH
73116: LD_EXP 96
73120: PUSH
73121: LD_VAR 0 2
73125: ARRAY
73126: PUSH
73127: LD_INT 1
73129: ARRAY
73130: PUSH
73131: LD_INT 1
73133: ARRAY
73134: PPUSH
73135: LD_EXP 96
73139: PUSH
73140: LD_VAR 0 2
73144: ARRAY
73145: PUSH
73146: LD_INT 1
73148: ARRAY
73149: PUSH
73150: LD_INT 2
73152: ARRAY
73153: PPUSH
73154: CALL_OW 111
// end ; end ; end ;
73158: GO 72571
73160: POP
73161: POP
// end ;
73162: LD_VAR 0 1
73166: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73167: LD_INT 0
73169: PPUSH
73170: PPUSH
73171: PPUSH
73172: PPUSH
73173: PPUSH
73174: PPUSH
73175: PPUSH
73176: PPUSH
73177: PPUSH
73178: PPUSH
73179: PPUSH
// if not mc_bases then
73180: LD_EXP 59
73184: NOT
73185: IFFALSE 73189
// exit ;
73187: GO 74129
// for i = 1 to mc_bases do
73189: LD_ADDR_VAR 0 2
73193: PUSH
73194: DOUBLE
73195: LD_INT 1
73197: DEC
73198: ST_TO_ADDR
73199: LD_EXP 59
73203: PUSH
73204: FOR_TO
73205: IFFALSE 74127
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73207: LD_EXP 59
73211: PUSH
73212: LD_VAR 0 2
73216: ARRAY
73217: NOT
73218: PUSH
73219: LD_EXP 82
73223: PUSH
73224: LD_VAR 0 2
73228: ARRAY
73229: OR
73230: IFFALSE 73234
// continue ;
73232: GO 73204
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73234: LD_ADDR_VAR 0 7
73238: PUSH
73239: LD_EXP 59
73243: PUSH
73244: LD_VAR 0 2
73248: ARRAY
73249: PUSH
73250: LD_INT 1
73252: ARRAY
73253: PPUSH
73254: CALL_OW 248
73258: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73259: LD_VAR 0 7
73263: PUSH
73264: LD_INT 3
73266: EQUAL
73267: PUSH
73268: LD_EXP 78
73272: PUSH
73273: LD_VAR 0 2
73277: ARRAY
73278: PUSH
73279: LD_EXP 81
73283: PUSH
73284: LD_VAR 0 2
73288: ARRAY
73289: UNION
73290: PPUSH
73291: LD_INT 33
73293: PUSH
73294: LD_INT 2
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PPUSH
73301: CALL_OW 72
73305: NOT
73306: OR
73307: IFFALSE 73311
// continue ;
73309: GO 73204
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73311: LD_ADDR_VAR 0 9
73315: PUSH
73316: LD_EXP 59
73320: PUSH
73321: LD_VAR 0 2
73325: ARRAY
73326: PPUSH
73327: LD_INT 30
73329: PUSH
73330: LD_INT 36
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: PPUSH
73337: CALL_OW 72
73341: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73342: LD_ADDR_VAR 0 10
73346: PUSH
73347: LD_EXP 78
73351: PUSH
73352: LD_VAR 0 2
73356: ARRAY
73357: PPUSH
73358: LD_INT 34
73360: PUSH
73361: LD_INT 31
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PPUSH
73368: CALL_OW 72
73372: ST_TO_ADDR
// if not cts and not mcts then
73373: LD_VAR 0 9
73377: NOT
73378: PUSH
73379: LD_VAR 0 10
73383: NOT
73384: AND
73385: IFFALSE 73389
// continue ;
73387: GO 73204
// x := cts ;
73389: LD_ADDR_VAR 0 11
73393: PUSH
73394: LD_VAR 0 9
73398: ST_TO_ADDR
// if not x then
73399: LD_VAR 0 11
73403: NOT
73404: IFFALSE 73416
// x := mcts ;
73406: LD_ADDR_VAR 0 11
73410: PUSH
73411: LD_VAR 0 10
73415: ST_TO_ADDR
// if not x then
73416: LD_VAR 0 11
73420: NOT
73421: IFFALSE 73425
// continue ;
73423: GO 73204
// if mc_remote_driver [ i ] then
73425: LD_EXP 99
73429: PUSH
73430: LD_VAR 0 2
73434: ARRAY
73435: IFFALSE 73822
// for j in mc_remote_driver [ i ] do
73437: LD_ADDR_VAR 0 3
73441: PUSH
73442: LD_EXP 99
73446: PUSH
73447: LD_VAR 0 2
73451: ARRAY
73452: PUSH
73453: FOR_IN
73454: IFFALSE 73820
// begin if GetClass ( j ) <> 3 then
73456: LD_VAR 0 3
73460: PPUSH
73461: CALL_OW 257
73465: PUSH
73466: LD_INT 3
73468: NONEQUAL
73469: IFFALSE 73522
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73471: LD_ADDR_EXP 99
73475: PUSH
73476: LD_EXP 99
73480: PPUSH
73481: LD_VAR 0 2
73485: PPUSH
73486: LD_EXP 99
73490: PUSH
73491: LD_VAR 0 2
73495: ARRAY
73496: PUSH
73497: LD_VAR 0 3
73501: DIFF
73502: PPUSH
73503: CALL_OW 1
73507: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73508: LD_VAR 0 3
73512: PPUSH
73513: LD_INT 0
73515: PPUSH
73516: CALL_OW 109
// continue ;
73520: GO 73453
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73522: LD_EXP 78
73526: PUSH
73527: LD_VAR 0 2
73531: ARRAY
73532: PPUSH
73533: LD_INT 34
73535: PUSH
73536: LD_INT 31
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 58
73545: PUSH
73546: EMPTY
73547: LIST
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PPUSH
73553: CALL_OW 72
73557: PUSH
73558: LD_VAR 0 3
73562: PPUSH
73563: CALL 48265 0 1
73567: NOT
73568: AND
73569: IFFALSE 73640
// begin if IsInUnit ( j ) then
73571: LD_VAR 0 3
73575: PPUSH
73576: CALL_OW 310
73580: IFFALSE 73591
// ComExitBuilding ( j ) ;
73582: LD_VAR 0 3
73586: PPUSH
73587: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73591: LD_VAR 0 3
73595: PPUSH
73596: LD_EXP 78
73600: PUSH
73601: LD_VAR 0 2
73605: ARRAY
73606: PPUSH
73607: LD_INT 34
73609: PUSH
73610: LD_INT 31
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 58
73619: PUSH
73620: EMPTY
73621: LIST
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PPUSH
73627: CALL_OW 72
73631: PUSH
73632: LD_INT 1
73634: ARRAY
73635: PPUSH
73636: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73640: LD_VAR 0 3
73644: PPUSH
73645: CALL_OW 310
73649: NOT
73650: PUSH
73651: LD_VAR 0 3
73655: PPUSH
73656: CALL_OW 310
73660: PPUSH
73661: CALL_OW 266
73665: PUSH
73666: LD_INT 36
73668: NONEQUAL
73669: PUSH
73670: LD_VAR 0 3
73674: PPUSH
73675: CALL 48265 0 1
73679: NOT
73680: AND
73681: OR
73682: IFFALSE 73818
// begin if IsInUnit ( j ) then
73684: LD_VAR 0 3
73688: PPUSH
73689: CALL_OW 310
73693: IFFALSE 73704
// ComExitBuilding ( j ) ;
73695: LD_VAR 0 3
73699: PPUSH
73700: CALL_OW 122
// ct := 0 ;
73704: LD_ADDR_VAR 0 8
73708: PUSH
73709: LD_INT 0
73711: ST_TO_ADDR
// for k in x do
73712: LD_ADDR_VAR 0 4
73716: PUSH
73717: LD_VAR 0 11
73721: PUSH
73722: FOR_IN
73723: IFFALSE 73796
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73725: LD_VAR 0 4
73729: PPUSH
73730: CALL_OW 264
73734: PUSH
73735: LD_INT 31
73737: EQUAL
73738: PUSH
73739: LD_VAR 0 4
73743: PPUSH
73744: CALL_OW 311
73748: NOT
73749: AND
73750: PUSH
73751: LD_VAR 0 4
73755: PPUSH
73756: CALL_OW 266
73760: PUSH
73761: LD_INT 36
73763: EQUAL
73764: PUSH
73765: LD_VAR 0 4
73769: PPUSH
73770: CALL_OW 313
73774: PUSH
73775: LD_INT 3
73777: LESS
73778: AND
73779: OR
73780: IFFALSE 73794
// begin ct := k ;
73782: LD_ADDR_VAR 0 8
73786: PUSH
73787: LD_VAR 0 4
73791: ST_TO_ADDR
// break ;
73792: GO 73796
// end ;
73794: GO 73722
73796: POP
73797: POP
// if ct then
73798: LD_VAR 0 8
73802: IFFALSE 73818
// ComEnterUnit ( j , ct ) ;
73804: LD_VAR 0 3
73808: PPUSH
73809: LD_VAR 0 8
73813: PPUSH
73814: CALL_OW 120
// end ; end ;
73818: GO 73453
73820: POP
73821: POP
// places := 0 ;
73822: LD_ADDR_VAR 0 5
73826: PUSH
73827: LD_INT 0
73829: ST_TO_ADDR
// for j = 1 to x do
73830: LD_ADDR_VAR 0 3
73834: PUSH
73835: DOUBLE
73836: LD_INT 1
73838: DEC
73839: ST_TO_ADDR
73840: LD_VAR 0 11
73844: PUSH
73845: FOR_TO
73846: IFFALSE 73922
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73848: LD_VAR 0 11
73852: PUSH
73853: LD_VAR 0 3
73857: ARRAY
73858: PPUSH
73859: CALL_OW 264
73863: PUSH
73864: LD_INT 31
73866: EQUAL
73867: IFFALSE 73885
// places := places + 1 else
73869: LD_ADDR_VAR 0 5
73873: PUSH
73874: LD_VAR 0 5
73878: PUSH
73879: LD_INT 1
73881: PLUS
73882: ST_TO_ADDR
73883: GO 73920
// if GetBType ( x [ j ] ) = b_control_tower then
73885: LD_VAR 0 11
73889: PUSH
73890: LD_VAR 0 3
73894: ARRAY
73895: PPUSH
73896: CALL_OW 266
73900: PUSH
73901: LD_INT 36
73903: EQUAL
73904: IFFALSE 73920
// places := places + 3 ;
73906: LD_ADDR_VAR 0 5
73910: PUSH
73911: LD_VAR 0 5
73915: PUSH
73916: LD_INT 3
73918: PLUS
73919: ST_TO_ADDR
73920: GO 73845
73922: POP
73923: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73924: LD_VAR 0 5
73928: PUSH
73929: LD_INT 0
73931: EQUAL
73932: PUSH
73933: LD_VAR 0 5
73937: PUSH
73938: LD_EXP 99
73942: PUSH
73943: LD_VAR 0 2
73947: ARRAY
73948: LESSEQUAL
73949: OR
73950: IFFALSE 73954
// continue ;
73952: GO 73204
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73954: LD_ADDR_VAR 0 6
73958: PUSH
73959: LD_EXP 59
73963: PUSH
73964: LD_VAR 0 2
73968: ARRAY
73969: PPUSH
73970: LD_INT 25
73972: PUSH
73973: LD_INT 3
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PPUSH
73980: CALL_OW 72
73984: PUSH
73985: LD_EXP 99
73989: PUSH
73990: LD_VAR 0 2
73994: ARRAY
73995: DIFF
73996: PPUSH
73997: LD_INT 3
73999: PPUSH
74000: CALL 49165 0 2
74004: ST_TO_ADDR
// for j in tmp do
74005: LD_ADDR_VAR 0 3
74009: PUSH
74010: LD_VAR 0 6
74014: PUSH
74015: FOR_IN
74016: IFFALSE 74051
// if GetTag ( j ) > 0 then
74018: LD_VAR 0 3
74022: PPUSH
74023: CALL_OW 110
74027: PUSH
74028: LD_INT 0
74030: GREATER
74031: IFFALSE 74049
// tmp := tmp diff j ;
74033: LD_ADDR_VAR 0 6
74037: PUSH
74038: LD_VAR 0 6
74042: PUSH
74043: LD_VAR 0 3
74047: DIFF
74048: ST_TO_ADDR
74049: GO 74015
74051: POP
74052: POP
// if not tmp then
74053: LD_VAR 0 6
74057: NOT
74058: IFFALSE 74062
// continue ;
74060: GO 73204
// if places then
74062: LD_VAR 0 5
74066: IFFALSE 74125
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74068: LD_ADDR_EXP 99
74072: PUSH
74073: LD_EXP 99
74077: PPUSH
74078: LD_VAR 0 2
74082: PPUSH
74083: LD_EXP 99
74087: PUSH
74088: LD_VAR 0 2
74092: ARRAY
74093: PUSH
74094: LD_VAR 0 6
74098: PUSH
74099: LD_INT 1
74101: ARRAY
74102: UNION
74103: PPUSH
74104: CALL_OW 1
74108: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74109: LD_VAR 0 6
74113: PUSH
74114: LD_INT 1
74116: ARRAY
74117: PPUSH
74118: LD_INT 126
74120: PPUSH
74121: CALL_OW 109
// end ; end ;
74125: GO 73204
74127: POP
74128: POP
// end ;
74129: LD_VAR 0 1
74133: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74134: LD_INT 0
74136: PPUSH
74137: PPUSH
74138: PPUSH
74139: PPUSH
74140: PPUSH
74141: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74142: LD_VAR 0 1
74146: NOT
74147: PUSH
74148: LD_VAR 0 2
74152: NOT
74153: OR
74154: PUSH
74155: LD_VAR 0 3
74159: NOT
74160: OR
74161: PUSH
74162: LD_VAR 0 4
74166: PUSH
74167: LD_INT 1
74169: PUSH
74170: LD_INT 2
74172: PUSH
74173: LD_INT 3
74175: PUSH
74176: LD_INT 4
74178: PUSH
74179: LD_INT 5
74181: PUSH
74182: LD_INT 8
74184: PUSH
74185: LD_INT 9
74187: PUSH
74188: LD_INT 15
74190: PUSH
74191: LD_INT 16
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: IN
74205: NOT
74206: OR
74207: IFFALSE 74211
// exit ;
74209: GO 75111
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74211: LD_ADDR_VAR 0 2
74215: PUSH
74216: LD_VAR 0 2
74220: PPUSH
74221: LD_INT 21
74223: PUSH
74224: LD_INT 3
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: PUSH
74231: LD_INT 24
74233: PUSH
74234: LD_INT 250
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PPUSH
74245: CALL_OW 72
74249: ST_TO_ADDR
// case class of 1 , 15 :
74250: LD_VAR 0 4
74254: PUSH
74255: LD_INT 1
74257: DOUBLE
74258: EQUAL
74259: IFTRUE 74269
74261: LD_INT 15
74263: DOUBLE
74264: EQUAL
74265: IFTRUE 74269
74267: GO 74354
74269: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74270: LD_ADDR_VAR 0 8
74274: PUSH
74275: LD_VAR 0 2
74279: PPUSH
74280: LD_INT 2
74282: PUSH
74283: LD_INT 30
74285: PUSH
74286: LD_INT 32
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: PUSH
74293: LD_INT 30
74295: PUSH
74296: LD_INT 31
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: LIST
74307: PPUSH
74308: CALL_OW 72
74312: PUSH
74313: LD_VAR 0 2
74317: PPUSH
74318: LD_INT 2
74320: PUSH
74321: LD_INT 30
74323: PUSH
74324: LD_INT 4
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 30
74333: PUSH
74334: LD_INT 5
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: LIST
74345: PPUSH
74346: CALL_OW 72
74350: ADD
74351: ST_TO_ADDR
74352: GO 74600
74354: LD_INT 2
74356: DOUBLE
74357: EQUAL
74358: IFTRUE 74368
74360: LD_INT 16
74362: DOUBLE
74363: EQUAL
74364: IFTRUE 74368
74366: GO 74414
74368: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74369: LD_ADDR_VAR 0 8
74373: PUSH
74374: LD_VAR 0 2
74378: PPUSH
74379: LD_INT 2
74381: PUSH
74382: LD_INT 30
74384: PUSH
74385: LD_INT 0
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 30
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: LIST
74406: PPUSH
74407: CALL_OW 72
74411: ST_TO_ADDR
74412: GO 74600
74414: LD_INT 3
74416: DOUBLE
74417: EQUAL
74418: IFTRUE 74422
74420: GO 74468
74422: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74423: LD_ADDR_VAR 0 8
74427: PUSH
74428: LD_VAR 0 2
74432: PPUSH
74433: LD_INT 2
74435: PUSH
74436: LD_INT 30
74438: PUSH
74439: LD_INT 2
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 30
74448: PUSH
74449: LD_INT 3
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: LIST
74460: PPUSH
74461: CALL_OW 72
74465: ST_TO_ADDR
74466: GO 74600
74468: LD_INT 4
74470: DOUBLE
74471: EQUAL
74472: IFTRUE 74476
74474: GO 74533
74476: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74477: LD_ADDR_VAR 0 8
74481: PUSH
74482: LD_VAR 0 2
74486: PPUSH
74487: LD_INT 2
74489: PUSH
74490: LD_INT 30
74492: PUSH
74493: LD_INT 6
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 30
74502: PUSH
74503: LD_INT 7
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 30
74512: PUSH
74513: LD_INT 8
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: PPUSH
74526: CALL_OW 72
74530: ST_TO_ADDR
74531: GO 74600
74533: LD_INT 5
74535: DOUBLE
74536: EQUAL
74537: IFTRUE 74553
74539: LD_INT 8
74541: DOUBLE
74542: EQUAL
74543: IFTRUE 74553
74545: LD_INT 9
74547: DOUBLE
74548: EQUAL
74549: IFTRUE 74553
74551: GO 74599
74553: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74554: LD_ADDR_VAR 0 8
74558: PUSH
74559: LD_VAR 0 2
74563: PPUSH
74564: LD_INT 2
74566: PUSH
74567: LD_INT 30
74569: PUSH
74570: LD_INT 4
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 30
74579: PUSH
74580: LD_INT 5
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: EMPTY
74588: LIST
74589: LIST
74590: LIST
74591: PPUSH
74592: CALL_OW 72
74596: ST_TO_ADDR
74597: GO 74600
74599: POP
// if not tmp then
74600: LD_VAR 0 8
74604: NOT
74605: IFFALSE 74609
// exit ;
74607: GO 75111
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74609: LD_VAR 0 4
74613: PUSH
74614: LD_INT 1
74616: PUSH
74617: LD_INT 15
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: IN
74624: PUSH
74625: LD_EXP 68
74629: PUSH
74630: LD_VAR 0 1
74634: ARRAY
74635: AND
74636: IFFALSE 74792
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74638: LD_ADDR_VAR 0 9
74642: PUSH
74643: LD_EXP 68
74647: PUSH
74648: LD_VAR 0 1
74652: ARRAY
74653: PUSH
74654: LD_INT 1
74656: ARRAY
74657: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74658: LD_VAR 0 9
74662: PUSH
74663: LD_EXP 69
74667: PUSH
74668: LD_VAR 0 1
74672: ARRAY
74673: IN
74674: NOT
74675: IFFALSE 74790
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74677: LD_ADDR_EXP 69
74681: PUSH
74682: LD_EXP 69
74686: PPUSH
74687: LD_VAR 0 1
74691: PUSH
74692: LD_EXP 69
74696: PUSH
74697: LD_VAR 0 1
74701: ARRAY
74702: PUSH
74703: LD_INT 1
74705: PLUS
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PPUSH
74711: LD_VAR 0 9
74715: PPUSH
74716: CALL 19283 0 3
74720: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74721: LD_ADDR_EXP 68
74725: PUSH
74726: LD_EXP 68
74730: PPUSH
74731: LD_VAR 0 1
74735: PPUSH
74736: LD_EXP 68
74740: PUSH
74741: LD_VAR 0 1
74745: ARRAY
74746: PUSH
74747: LD_VAR 0 9
74751: DIFF
74752: PPUSH
74753: CALL_OW 1
74757: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74758: LD_VAR 0 3
74762: PPUSH
74763: LD_EXP 69
74767: PUSH
74768: LD_VAR 0 1
74772: ARRAY
74773: PUSH
74774: LD_EXP 69
74778: PUSH
74779: LD_VAR 0 1
74783: ARRAY
74784: ARRAY
74785: PPUSH
74786: CALL_OW 120
// end ; exit ;
74790: GO 75111
// end ; if tmp > 1 then
74792: LD_VAR 0 8
74796: PUSH
74797: LD_INT 1
74799: GREATER
74800: IFFALSE 74904
// for i = 2 to tmp do
74802: LD_ADDR_VAR 0 6
74806: PUSH
74807: DOUBLE
74808: LD_INT 2
74810: DEC
74811: ST_TO_ADDR
74812: LD_VAR 0 8
74816: PUSH
74817: FOR_TO
74818: IFFALSE 74902
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74820: LD_VAR 0 8
74824: PUSH
74825: LD_VAR 0 6
74829: ARRAY
74830: PPUSH
74831: CALL_OW 461
74835: PUSH
74836: LD_INT 6
74838: EQUAL
74839: IFFALSE 74900
// begin x := tmp [ i ] ;
74841: LD_ADDR_VAR 0 9
74845: PUSH
74846: LD_VAR 0 8
74850: PUSH
74851: LD_VAR 0 6
74855: ARRAY
74856: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74857: LD_ADDR_VAR 0 8
74861: PUSH
74862: LD_VAR 0 8
74866: PPUSH
74867: LD_VAR 0 6
74871: PPUSH
74872: CALL_OW 3
74876: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74877: LD_ADDR_VAR 0 8
74881: PUSH
74882: LD_VAR 0 8
74886: PPUSH
74887: LD_INT 1
74889: PPUSH
74890: LD_VAR 0 9
74894: PPUSH
74895: CALL_OW 2
74899: ST_TO_ADDR
// end ;
74900: GO 74817
74902: POP
74903: POP
// for i in tmp do
74904: LD_ADDR_VAR 0 6
74908: PUSH
74909: LD_VAR 0 8
74913: PUSH
74914: FOR_IN
74915: IFFALSE 74984
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74917: LD_VAR 0 6
74921: PPUSH
74922: CALL_OW 313
74926: PUSH
74927: LD_INT 6
74929: LESS
74930: PUSH
74931: LD_VAR 0 6
74935: PPUSH
74936: CALL_OW 266
74940: PUSH
74941: LD_INT 31
74943: PUSH
74944: LD_INT 32
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: IN
74951: NOT
74952: AND
74953: PUSH
74954: LD_VAR 0 6
74958: PPUSH
74959: CALL_OW 313
74963: PUSH
74964: LD_INT 0
74966: EQUAL
74967: OR
74968: IFFALSE 74982
// begin j := i ;
74970: LD_ADDR_VAR 0 7
74974: PUSH
74975: LD_VAR 0 6
74979: ST_TO_ADDR
// break ;
74980: GO 74984
// end ; end ;
74982: GO 74914
74984: POP
74985: POP
// if j then
74986: LD_VAR 0 7
74990: IFFALSE 75008
// ComEnterUnit ( unit , j ) else
74992: LD_VAR 0 3
74996: PPUSH
74997: LD_VAR 0 7
75001: PPUSH
75002: CALL_OW 120
75006: GO 75111
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75008: LD_ADDR_VAR 0 10
75012: PUSH
75013: LD_VAR 0 2
75017: PPUSH
75018: LD_INT 2
75020: PUSH
75021: LD_INT 30
75023: PUSH
75024: LD_INT 0
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 30
75033: PUSH
75034: LD_INT 1
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: LIST
75045: PPUSH
75046: CALL_OW 72
75050: ST_TO_ADDR
// if depot then
75051: LD_VAR 0 10
75055: IFFALSE 75111
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75057: LD_ADDR_VAR 0 10
75061: PUSH
75062: LD_VAR 0 10
75066: PPUSH
75067: LD_VAR 0 3
75071: PPUSH
75072: CALL_OW 74
75076: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75077: LD_VAR 0 3
75081: PPUSH
75082: LD_VAR 0 10
75086: PPUSH
75087: CALL_OW 296
75091: PUSH
75092: LD_INT 10
75094: GREATER
75095: IFFALSE 75111
// ComStandNearbyBuilding ( unit , depot ) ;
75097: LD_VAR 0 3
75101: PPUSH
75102: LD_VAR 0 10
75106: PPUSH
75107: CALL 15897 0 2
// end ; end ; end ;
75111: LD_VAR 0 5
75115: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75116: LD_INT 0
75118: PPUSH
75119: PPUSH
75120: PPUSH
75121: PPUSH
// if not mc_bases then
75122: LD_EXP 59
75126: NOT
75127: IFFALSE 75131
// exit ;
75129: GO 75370
// for i = 1 to mc_bases do
75131: LD_ADDR_VAR 0 2
75135: PUSH
75136: DOUBLE
75137: LD_INT 1
75139: DEC
75140: ST_TO_ADDR
75141: LD_EXP 59
75145: PUSH
75146: FOR_TO
75147: IFFALSE 75368
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75149: LD_ADDR_VAR 0 4
75153: PUSH
75154: LD_EXP 59
75158: PUSH
75159: LD_VAR 0 2
75163: ARRAY
75164: PPUSH
75165: LD_INT 21
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PPUSH
75175: CALL_OW 72
75179: PUSH
75180: LD_EXP 88
75184: PUSH
75185: LD_VAR 0 2
75189: ARRAY
75190: UNION
75191: ST_TO_ADDR
// if not tmp then
75192: LD_VAR 0 4
75196: NOT
75197: IFFALSE 75201
// continue ;
75199: GO 75146
// for j in tmp do
75201: LD_ADDR_VAR 0 3
75205: PUSH
75206: LD_VAR 0 4
75210: PUSH
75211: FOR_IN
75212: IFFALSE 75364
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75214: LD_VAR 0 3
75218: PPUSH
75219: CALL_OW 110
75223: NOT
75224: PUSH
75225: LD_VAR 0 3
75229: PPUSH
75230: CALL_OW 314
75234: NOT
75235: AND
75236: PUSH
75237: LD_VAR 0 3
75241: PPUSH
75242: CALL_OW 311
75246: NOT
75247: AND
75248: PUSH
75249: LD_VAR 0 3
75253: PPUSH
75254: CALL_OW 310
75258: NOT
75259: AND
75260: PUSH
75261: LD_VAR 0 3
75265: PUSH
75266: LD_EXP 62
75270: PUSH
75271: LD_VAR 0 2
75275: ARRAY
75276: PUSH
75277: LD_INT 1
75279: ARRAY
75280: IN
75281: NOT
75282: AND
75283: PUSH
75284: LD_VAR 0 3
75288: PUSH
75289: LD_EXP 62
75293: PUSH
75294: LD_VAR 0 2
75298: ARRAY
75299: PUSH
75300: LD_INT 2
75302: ARRAY
75303: IN
75304: NOT
75305: AND
75306: PUSH
75307: LD_VAR 0 3
75311: PUSH
75312: LD_EXP 71
75316: PUSH
75317: LD_VAR 0 2
75321: ARRAY
75322: IN
75323: NOT
75324: AND
75325: IFFALSE 75362
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75327: LD_VAR 0 2
75331: PPUSH
75332: LD_EXP 59
75336: PUSH
75337: LD_VAR 0 2
75341: ARRAY
75342: PPUSH
75343: LD_VAR 0 3
75347: PPUSH
75348: LD_VAR 0 3
75352: PPUSH
75353: CALL_OW 257
75357: PPUSH
75358: CALL 74134 0 4
// end ;
75362: GO 75211
75364: POP
75365: POP
// end ;
75366: GO 75146
75368: POP
75369: POP
// end ;
75370: LD_VAR 0 1
75374: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75375: LD_INT 0
75377: PPUSH
75378: PPUSH
75379: PPUSH
75380: PPUSH
75381: PPUSH
75382: PPUSH
// if not mc_bases [ base ] then
75383: LD_EXP 59
75387: PUSH
75388: LD_VAR 0 1
75392: ARRAY
75393: NOT
75394: IFFALSE 75398
// exit ;
75396: GO 75580
// tmp := [ ] ;
75398: LD_ADDR_VAR 0 6
75402: PUSH
75403: EMPTY
75404: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75405: LD_ADDR_VAR 0 7
75409: PUSH
75410: LD_VAR 0 3
75414: PPUSH
75415: LD_INT 0
75417: PPUSH
75418: CALL_OW 517
75422: ST_TO_ADDR
// if not list then
75423: LD_VAR 0 7
75427: NOT
75428: IFFALSE 75432
// exit ;
75430: GO 75580
// for i = 1 to amount do
75432: LD_ADDR_VAR 0 5
75436: PUSH
75437: DOUBLE
75438: LD_INT 1
75440: DEC
75441: ST_TO_ADDR
75442: LD_VAR 0 2
75446: PUSH
75447: FOR_TO
75448: IFFALSE 75528
// begin x := rand ( 1 , list [ 1 ] ) ;
75450: LD_ADDR_VAR 0 8
75454: PUSH
75455: LD_INT 1
75457: PPUSH
75458: LD_VAR 0 7
75462: PUSH
75463: LD_INT 1
75465: ARRAY
75466: PPUSH
75467: CALL_OW 12
75471: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75472: LD_ADDR_VAR 0 6
75476: PUSH
75477: LD_VAR 0 6
75481: PPUSH
75482: LD_VAR 0 5
75486: PPUSH
75487: LD_VAR 0 7
75491: PUSH
75492: LD_INT 1
75494: ARRAY
75495: PUSH
75496: LD_VAR 0 8
75500: ARRAY
75501: PUSH
75502: LD_VAR 0 7
75506: PUSH
75507: LD_INT 2
75509: ARRAY
75510: PUSH
75511: LD_VAR 0 8
75515: ARRAY
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PPUSH
75521: CALL_OW 1
75525: ST_TO_ADDR
// end ;
75526: GO 75447
75528: POP
75529: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75530: LD_ADDR_EXP 72
75534: PUSH
75535: LD_EXP 72
75539: PPUSH
75540: LD_VAR 0 1
75544: PPUSH
75545: LD_VAR 0 6
75549: PPUSH
75550: CALL_OW 1
75554: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75555: LD_ADDR_EXP 74
75559: PUSH
75560: LD_EXP 74
75564: PPUSH
75565: LD_VAR 0 1
75569: PPUSH
75570: LD_VAR 0 3
75574: PPUSH
75575: CALL_OW 1
75579: ST_TO_ADDR
// end ;
75580: LD_VAR 0 4
75584: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75585: LD_INT 0
75587: PPUSH
// if not mc_bases [ base ] then
75588: LD_EXP 59
75592: PUSH
75593: LD_VAR 0 1
75597: ARRAY
75598: NOT
75599: IFFALSE 75603
// exit ;
75601: GO 75628
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75603: LD_ADDR_EXP 64
75607: PUSH
75608: LD_EXP 64
75612: PPUSH
75613: LD_VAR 0 1
75617: PPUSH
75618: LD_VAR 0 2
75622: PPUSH
75623: CALL_OW 1
75627: ST_TO_ADDR
// end ;
75628: LD_VAR 0 3
75632: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75633: LD_INT 0
75635: PPUSH
// if not mc_bases [ base ] then
75636: LD_EXP 59
75640: PUSH
75641: LD_VAR 0 1
75645: ARRAY
75646: NOT
75647: IFFALSE 75651
// exit ;
75649: GO 75688
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75651: LD_ADDR_EXP 64
75655: PUSH
75656: LD_EXP 64
75660: PPUSH
75661: LD_VAR 0 1
75665: PPUSH
75666: LD_EXP 64
75670: PUSH
75671: LD_VAR 0 1
75675: ARRAY
75676: PUSH
75677: LD_VAR 0 2
75681: UNION
75682: PPUSH
75683: CALL_OW 1
75687: ST_TO_ADDR
// end ;
75688: LD_VAR 0 3
75692: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75693: LD_INT 0
75695: PPUSH
// if not mc_bases [ base ] then
75696: LD_EXP 59
75700: PUSH
75701: LD_VAR 0 1
75705: ARRAY
75706: NOT
75707: IFFALSE 75711
// exit ;
75709: GO 75736
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75711: LD_ADDR_EXP 80
75715: PUSH
75716: LD_EXP 80
75720: PPUSH
75721: LD_VAR 0 1
75725: PPUSH
75726: LD_VAR 0 2
75730: PPUSH
75731: CALL_OW 1
75735: ST_TO_ADDR
// end ;
75736: LD_VAR 0 3
75740: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75741: LD_INT 0
75743: PPUSH
// if not mc_bases [ base ] then
75744: LD_EXP 59
75748: PUSH
75749: LD_VAR 0 1
75753: ARRAY
75754: NOT
75755: IFFALSE 75759
// exit ;
75757: GO 75796
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75759: LD_ADDR_EXP 80
75763: PUSH
75764: LD_EXP 80
75768: PPUSH
75769: LD_VAR 0 1
75773: PPUSH
75774: LD_EXP 80
75778: PUSH
75779: LD_VAR 0 1
75783: ARRAY
75784: PUSH
75785: LD_VAR 0 2
75789: ADD
75790: PPUSH
75791: CALL_OW 1
75795: ST_TO_ADDR
// end ;
75796: LD_VAR 0 3
75800: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75801: LD_INT 0
75803: PPUSH
// if not mc_bases [ base ] then
75804: LD_EXP 59
75808: PUSH
75809: LD_VAR 0 1
75813: ARRAY
75814: NOT
75815: IFFALSE 75819
// exit ;
75817: GO 75873
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75819: LD_ADDR_EXP 81
75823: PUSH
75824: LD_EXP 81
75828: PPUSH
75829: LD_VAR 0 1
75833: PPUSH
75834: LD_VAR 0 2
75838: PPUSH
75839: CALL_OW 1
75843: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75844: LD_ADDR_EXP 70
75848: PUSH
75849: LD_EXP 70
75853: PPUSH
75854: LD_VAR 0 1
75858: PPUSH
75859: LD_VAR 0 2
75863: PUSH
75864: LD_INT 0
75866: PLUS
75867: PPUSH
75868: CALL_OW 1
75872: ST_TO_ADDR
// end ;
75873: LD_VAR 0 3
75877: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75878: LD_INT 0
75880: PPUSH
// if not mc_bases [ base ] then
75881: LD_EXP 59
75885: PUSH
75886: LD_VAR 0 1
75890: ARRAY
75891: NOT
75892: IFFALSE 75896
// exit ;
75894: GO 75921
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75896: LD_ADDR_EXP 70
75900: PUSH
75901: LD_EXP 70
75905: PPUSH
75906: LD_VAR 0 1
75910: PPUSH
75911: LD_VAR 0 2
75915: PPUSH
75916: CALL_OW 1
75920: ST_TO_ADDR
// end ;
75921: LD_VAR 0 3
75925: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75926: LD_INT 0
75928: PPUSH
75929: PPUSH
75930: PPUSH
75931: PPUSH
// if not mc_bases [ base ] then
75932: LD_EXP 59
75936: PUSH
75937: LD_VAR 0 1
75941: ARRAY
75942: NOT
75943: IFFALSE 75947
// exit ;
75945: GO 76012
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75947: LD_ADDR_EXP 79
75951: PUSH
75952: LD_EXP 79
75956: PPUSH
75957: LD_VAR 0 1
75961: PUSH
75962: LD_EXP 79
75966: PUSH
75967: LD_VAR 0 1
75971: ARRAY
75972: PUSH
75973: LD_INT 1
75975: PLUS
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PPUSH
75981: LD_VAR 0 1
75985: PUSH
75986: LD_VAR 0 2
75990: PUSH
75991: LD_VAR 0 3
75995: PUSH
75996: LD_VAR 0 4
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: PPUSH
76007: CALL 19283 0 3
76011: ST_TO_ADDR
// end ;
76012: LD_VAR 0 5
76016: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76017: LD_INT 0
76019: PPUSH
// if not mc_bases [ base ] then
76020: LD_EXP 59
76024: PUSH
76025: LD_VAR 0 1
76029: ARRAY
76030: NOT
76031: IFFALSE 76035
// exit ;
76033: GO 76060
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76035: LD_ADDR_EXP 96
76039: PUSH
76040: LD_EXP 96
76044: PPUSH
76045: LD_VAR 0 1
76049: PPUSH
76050: LD_VAR 0 2
76054: PPUSH
76055: CALL_OW 1
76059: ST_TO_ADDR
// end ;
76060: LD_VAR 0 3
76064: RET
// export function MC_GetMinesField ( base ) ; begin
76065: LD_INT 0
76067: PPUSH
// result := mc_mines [ base ] ;
76068: LD_ADDR_VAR 0 2
76072: PUSH
76073: LD_EXP 72
76077: PUSH
76078: LD_VAR 0 1
76082: ARRAY
76083: ST_TO_ADDR
// end ;
76084: LD_VAR 0 2
76088: RET
// export function MC_GetProduceList ( base ) ; begin
76089: LD_INT 0
76091: PPUSH
// result := mc_produce [ base ] ;
76092: LD_ADDR_VAR 0 2
76096: PUSH
76097: LD_EXP 80
76101: PUSH
76102: LD_VAR 0 1
76106: ARRAY
76107: ST_TO_ADDR
// end ;
76108: LD_VAR 0 2
76112: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76113: LD_INT 0
76115: PPUSH
76116: PPUSH
// if not mc_bases then
76117: LD_EXP 59
76121: NOT
76122: IFFALSE 76126
// exit ;
76124: GO 76191
// if mc_bases [ base ] then
76126: LD_EXP 59
76130: PUSH
76131: LD_VAR 0 1
76135: ARRAY
76136: IFFALSE 76191
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76138: LD_ADDR_VAR 0 3
76142: PUSH
76143: LD_EXP 59
76147: PUSH
76148: LD_VAR 0 1
76152: ARRAY
76153: PPUSH
76154: LD_INT 30
76156: PUSH
76157: LD_VAR 0 2
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PPUSH
76166: CALL_OW 72
76170: ST_TO_ADDR
// if result then
76171: LD_VAR 0 3
76175: IFFALSE 76191
// result := result [ 1 ] ;
76177: LD_ADDR_VAR 0 3
76181: PUSH
76182: LD_VAR 0 3
76186: PUSH
76187: LD_INT 1
76189: ARRAY
76190: ST_TO_ADDR
// end ; end ;
76191: LD_VAR 0 3
76195: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76196: LD_INT 0
76198: PPUSH
76199: PPUSH
// if not mc_bases then
76200: LD_EXP 59
76204: NOT
76205: IFFALSE 76209
// exit ;
76207: GO 76254
// if mc_bases [ base ] then
76209: LD_EXP 59
76213: PUSH
76214: LD_VAR 0 1
76218: ARRAY
76219: IFFALSE 76254
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76221: LD_ADDR_VAR 0 3
76225: PUSH
76226: LD_EXP 59
76230: PUSH
76231: LD_VAR 0 1
76235: ARRAY
76236: PPUSH
76237: LD_INT 30
76239: PUSH
76240: LD_VAR 0 2
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PPUSH
76249: CALL_OW 72
76253: ST_TO_ADDR
// end ;
76254: LD_VAR 0 3
76258: RET
// export function MC_SetTame ( base , area ) ; begin
76259: LD_INT 0
76261: PPUSH
// if not mc_bases or not base then
76262: LD_EXP 59
76266: NOT
76267: PUSH
76268: LD_VAR 0 1
76272: NOT
76273: OR
76274: IFFALSE 76278
// exit ;
76276: GO 76303
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76278: LD_ADDR_EXP 87
76282: PUSH
76283: LD_EXP 87
76287: PPUSH
76288: LD_VAR 0 1
76292: PPUSH
76293: LD_VAR 0 2
76297: PPUSH
76298: CALL_OW 1
76302: ST_TO_ADDR
// end ;
76303: LD_VAR 0 3
76307: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76308: LD_INT 0
76310: PPUSH
76311: PPUSH
// if not mc_bases or not base then
76312: LD_EXP 59
76316: NOT
76317: PUSH
76318: LD_VAR 0 1
76322: NOT
76323: OR
76324: IFFALSE 76328
// exit ;
76326: GO 76430
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76328: LD_ADDR_VAR 0 4
76332: PUSH
76333: LD_EXP 59
76337: PUSH
76338: LD_VAR 0 1
76342: ARRAY
76343: PPUSH
76344: LD_INT 30
76346: PUSH
76347: LD_VAR 0 2
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PPUSH
76356: CALL_OW 72
76360: ST_TO_ADDR
// if not tmp then
76361: LD_VAR 0 4
76365: NOT
76366: IFFALSE 76370
// exit ;
76368: GO 76430
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76370: LD_ADDR_EXP 91
76374: PUSH
76375: LD_EXP 91
76379: PPUSH
76380: LD_VAR 0 1
76384: PPUSH
76385: LD_EXP 91
76389: PUSH
76390: LD_VAR 0 1
76394: ARRAY
76395: PPUSH
76396: LD_EXP 91
76400: PUSH
76401: LD_VAR 0 1
76405: ARRAY
76406: PUSH
76407: LD_INT 1
76409: PLUS
76410: PPUSH
76411: LD_VAR 0 4
76415: PUSH
76416: LD_INT 1
76418: ARRAY
76419: PPUSH
76420: CALL_OW 2
76424: PPUSH
76425: CALL_OW 1
76429: ST_TO_ADDR
// end ;
76430: LD_VAR 0 3
76434: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76435: LD_INT 0
76437: PPUSH
76438: PPUSH
// if not mc_bases or not base or not kinds then
76439: LD_EXP 59
76443: NOT
76444: PUSH
76445: LD_VAR 0 1
76449: NOT
76450: OR
76451: PUSH
76452: LD_VAR 0 2
76456: NOT
76457: OR
76458: IFFALSE 76462
// exit ;
76460: GO 76523
// for i in kinds do
76462: LD_ADDR_VAR 0 4
76466: PUSH
76467: LD_VAR 0 2
76471: PUSH
76472: FOR_IN
76473: IFFALSE 76521
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76475: LD_ADDR_EXP 93
76479: PUSH
76480: LD_EXP 93
76484: PPUSH
76485: LD_VAR 0 1
76489: PUSH
76490: LD_EXP 93
76494: PUSH
76495: LD_VAR 0 1
76499: ARRAY
76500: PUSH
76501: LD_INT 1
76503: PLUS
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PPUSH
76509: LD_VAR 0 4
76513: PPUSH
76514: CALL 19283 0 3
76518: ST_TO_ADDR
76519: GO 76472
76521: POP
76522: POP
// end ;
76523: LD_VAR 0 3
76527: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76528: LD_INT 0
76530: PPUSH
// if not mc_bases or not base or not areas then
76531: LD_EXP 59
76535: NOT
76536: PUSH
76537: LD_VAR 0 1
76541: NOT
76542: OR
76543: PUSH
76544: LD_VAR 0 2
76548: NOT
76549: OR
76550: IFFALSE 76554
// exit ;
76552: GO 76579
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76554: LD_ADDR_EXP 77
76558: PUSH
76559: LD_EXP 77
76563: PPUSH
76564: LD_VAR 0 1
76568: PPUSH
76569: LD_VAR 0 2
76573: PPUSH
76574: CALL_OW 1
76578: ST_TO_ADDR
// end ;
76579: LD_VAR 0 3
76583: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76584: LD_INT 0
76586: PPUSH
// if not mc_bases or not base or not teleports_exit then
76587: LD_EXP 59
76591: NOT
76592: PUSH
76593: LD_VAR 0 1
76597: NOT
76598: OR
76599: PUSH
76600: LD_VAR 0 2
76604: NOT
76605: OR
76606: IFFALSE 76610
// exit ;
76608: GO 76635
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76610: LD_ADDR_EXP 94
76614: PUSH
76615: LD_EXP 94
76619: PPUSH
76620: LD_VAR 0 1
76624: PPUSH
76625: LD_VAR 0 2
76629: PPUSH
76630: CALL_OW 1
76634: ST_TO_ADDR
// end ;
76635: LD_VAR 0 3
76639: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76640: LD_INT 0
76642: PPUSH
76643: PPUSH
76644: PPUSH
// if not mc_bases or not base or not ext_list then
76645: LD_EXP 59
76649: NOT
76650: PUSH
76651: LD_VAR 0 1
76655: NOT
76656: OR
76657: PUSH
76658: LD_VAR 0 5
76662: NOT
76663: OR
76664: IFFALSE 76668
// exit ;
76666: GO 76841
// tmp := GetFacExtXYD ( x , y , d ) ;
76668: LD_ADDR_VAR 0 8
76672: PUSH
76673: LD_VAR 0 2
76677: PPUSH
76678: LD_VAR 0 3
76682: PPUSH
76683: LD_VAR 0 4
76687: PPUSH
76688: CALL 48295 0 3
76692: ST_TO_ADDR
// if not tmp then
76693: LD_VAR 0 8
76697: NOT
76698: IFFALSE 76702
// exit ;
76700: GO 76841
// for i in tmp do
76702: LD_ADDR_VAR 0 7
76706: PUSH
76707: LD_VAR 0 8
76711: PUSH
76712: FOR_IN
76713: IFFALSE 76839
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76715: LD_ADDR_EXP 64
76719: PUSH
76720: LD_EXP 64
76724: PPUSH
76725: LD_VAR 0 1
76729: PPUSH
76730: LD_EXP 64
76734: PUSH
76735: LD_VAR 0 1
76739: ARRAY
76740: PPUSH
76741: LD_EXP 64
76745: PUSH
76746: LD_VAR 0 1
76750: ARRAY
76751: PUSH
76752: LD_INT 1
76754: PLUS
76755: PPUSH
76756: LD_VAR 0 5
76760: PUSH
76761: LD_INT 1
76763: ARRAY
76764: PUSH
76765: LD_VAR 0 7
76769: PUSH
76770: LD_INT 1
76772: ARRAY
76773: PUSH
76774: LD_VAR 0 7
76778: PUSH
76779: LD_INT 2
76781: ARRAY
76782: PUSH
76783: LD_VAR 0 7
76787: PUSH
76788: LD_INT 3
76790: ARRAY
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: LIST
76796: LIST
76797: PPUSH
76798: CALL_OW 2
76802: PPUSH
76803: CALL_OW 1
76807: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76808: LD_ADDR_VAR 0 5
76812: PUSH
76813: LD_VAR 0 5
76817: PPUSH
76818: LD_INT 1
76820: PPUSH
76821: CALL_OW 3
76825: ST_TO_ADDR
// if not ext_list then
76826: LD_VAR 0 5
76830: NOT
76831: IFFALSE 76837
// exit ;
76833: POP
76834: POP
76835: GO 76841
// end ;
76837: GO 76712
76839: POP
76840: POP
// end ;
76841: LD_VAR 0 6
76845: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76846: LD_INT 0
76848: PPUSH
// if not mc_bases or not base or not weapon_list then
76849: LD_EXP 59
76853: NOT
76854: PUSH
76855: LD_VAR 0 1
76859: NOT
76860: OR
76861: PUSH
76862: LD_VAR 0 2
76866: NOT
76867: OR
76868: IFFALSE 76872
// exit ;
76870: GO 76897
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76872: LD_ADDR_EXP 98
76876: PUSH
76877: LD_EXP 98
76881: PPUSH
76882: LD_VAR 0 1
76886: PPUSH
76887: LD_VAR 0 2
76891: PPUSH
76892: CALL_OW 1
76896: ST_TO_ADDR
// end ;
76897: LD_VAR 0 3
76901: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76902: LD_INT 0
76904: PPUSH
// if not mc_bases or not base or not tech_list then
76905: LD_EXP 59
76909: NOT
76910: PUSH
76911: LD_VAR 0 1
76915: NOT
76916: OR
76917: PUSH
76918: LD_VAR 0 2
76922: NOT
76923: OR
76924: IFFALSE 76928
// exit ;
76926: GO 76953
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76928: LD_ADDR_EXP 86
76932: PUSH
76933: LD_EXP 86
76937: PPUSH
76938: LD_VAR 0 1
76942: PPUSH
76943: LD_VAR 0 2
76947: PPUSH
76948: CALL_OW 1
76952: ST_TO_ADDR
// end ;
76953: LD_VAR 0 3
76957: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76958: LD_INT 0
76960: PPUSH
// if not mc_bases or not parking_area or not base then
76961: LD_EXP 59
76965: NOT
76966: PUSH
76967: LD_VAR 0 2
76971: NOT
76972: OR
76973: PUSH
76974: LD_VAR 0 1
76978: NOT
76979: OR
76980: IFFALSE 76984
// exit ;
76982: GO 77009
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76984: LD_ADDR_EXP 83
76988: PUSH
76989: LD_EXP 83
76993: PPUSH
76994: LD_VAR 0 1
76998: PPUSH
76999: LD_VAR 0 2
77003: PPUSH
77004: CALL_OW 1
77008: ST_TO_ADDR
// end ;
77009: LD_VAR 0 3
77013: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77014: LD_INT 0
77016: PPUSH
// if not mc_bases or not base or not scan_area then
77017: LD_EXP 59
77021: NOT
77022: PUSH
77023: LD_VAR 0 1
77027: NOT
77028: OR
77029: PUSH
77030: LD_VAR 0 2
77034: NOT
77035: OR
77036: IFFALSE 77040
// exit ;
77038: GO 77065
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77040: LD_ADDR_EXP 84
77044: PUSH
77045: LD_EXP 84
77049: PPUSH
77050: LD_VAR 0 1
77054: PPUSH
77055: LD_VAR 0 2
77059: PPUSH
77060: CALL_OW 1
77064: ST_TO_ADDR
// end ;
77065: LD_VAR 0 3
77069: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77070: LD_INT 0
77072: PPUSH
77073: PPUSH
// if not mc_bases or not base then
77074: LD_EXP 59
77078: NOT
77079: PUSH
77080: LD_VAR 0 1
77084: NOT
77085: OR
77086: IFFALSE 77090
// exit ;
77088: GO 77154
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77090: LD_ADDR_VAR 0 3
77094: PUSH
77095: LD_INT 1
77097: PUSH
77098: LD_INT 2
77100: PUSH
77101: LD_INT 3
77103: PUSH
77104: LD_INT 4
77106: PUSH
77107: LD_INT 11
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: LIST
77116: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77117: LD_ADDR_EXP 86
77121: PUSH
77122: LD_EXP 86
77126: PPUSH
77127: LD_VAR 0 1
77131: PPUSH
77132: LD_EXP 86
77136: PUSH
77137: LD_VAR 0 1
77141: ARRAY
77142: PUSH
77143: LD_VAR 0 3
77147: DIFF
77148: PPUSH
77149: CALL_OW 1
77153: ST_TO_ADDR
// end ;
77154: LD_VAR 0 2
77158: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77159: LD_INT 0
77161: PPUSH
// result := mc_vehicles [ base ] ;
77162: LD_ADDR_VAR 0 3
77166: PUSH
77167: LD_EXP 78
77171: PUSH
77172: LD_VAR 0 1
77176: ARRAY
77177: ST_TO_ADDR
// if onlyCombat then
77178: LD_VAR 0 2
77182: IFFALSE 77360
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77184: LD_ADDR_VAR 0 3
77188: PUSH
77189: LD_VAR 0 3
77193: PUSH
77194: LD_VAR 0 3
77198: PPUSH
77199: LD_INT 2
77201: PUSH
77202: LD_INT 34
77204: PUSH
77205: LD_INT 12
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 34
77214: PUSH
77215: LD_INT 51
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 34
77224: PUSH
77225: LD_EXP 103
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 34
77236: PUSH
77237: LD_INT 32
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 34
77246: PUSH
77247: LD_INT 13
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 34
77256: PUSH
77257: LD_INT 52
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 34
77266: PUSH
77267: LD_EXP 108
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 34
77278: PUSH
77279: LD_INT 14
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 34
77288: PUSH
77289: LD_INT 53
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 34
77298: PUSH
77299: LD_EXP 102
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 34
77310: PUSH
77311: LD_INT 31
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 34
77320: PUSH
77321: LD_INT 48
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: LD_INT 34
77330: PUSH
77331: LD_INT 8
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: LIST
77350: LIST
77351: LIST
77352: LIST
77353: PPUSH
77354: CALL_OW 72
77358: DIFF
77359: ST_TO_ADDR
// end ; end_of_file
77360: LD_VAR 0 3
77364: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77365: LD_INT 0
77367: PPUSH
77368: PPUSH
77369: PPUSH
// if not mc_bases or not skirmish then
77370: LD_EXP 59
77374: NOT
77375: PUSH
77376: LD_EXP 57
77380: NOT
77381: OR
77382: IFFALSE 77386
// exit ;
77384: GO 77551
// for i = 1 to mc_bases do
77386: LD_ADDR_VAR 0 4
77390: PUSH
77391: DOUBLE
77392: LD_INT 1
77394: DEC
77395: ST_TO_ADDR
77396: LD_EXP 59
77400: PUSH
77401: FOR_TO
77402: IFFALSE 77549
// begin if sci in mc_bases [ i ] then
77404: LD_VAR 0 2
77408: PUSH
77409: LD_EXP 59
77413: PUSH
77414: LD_VAR 0 4
77418: ARRAY
77419: IN
77420: IFFALSE 77547
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77422: LD_ADDR_EXP 88
77426: PUSH
77427: LD_EXP 88
77431: PPUSH
77432: LD_VAR 0 4
77436: PUSH
77437: LD_EXP 88
77441: PUSH
77442: LD_VAR 0 4
77446: ARRAY
77447: PUSH
77448: LD_INT 1
77450: PLUS
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PPUSH
77456: LD_VAR 0 1
77460: PPUSH
77461: CALL 19283 0 3
77465: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77466: LD_ADDR_VAR 0 5
77470: PUSH
77471: LD_EXP 59
77475: PUSH
77476: LD_VAR 0 4
77480: ARRAY
77481: PPUSH
77482: LD_INT 2
77484: PUSH
77485: LD_INT 30
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 30
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: LIST
77509: PPUSH
77510: CALL_OW 72
77514: PPUSH
77515: LD_VAR 0 1
77519: PPUSH
77520: CALL_OW 74
77524: ST_TO_ADDR
// if tmp then
77525: LD_VAR 0 5
77529: IFFALSE 77545
// ComStandNearbyBuilding ( ape , tmp ) ;
77531: LD_VAR 0 1
77535: PPUSH
77536: LD_VAR 0 5
77540: PPUSH
77541: CALL 15897 0 2
// break ;
77545: GO 77549
// end ; end ;
77547: GO 77401
77549: POP
77550: POP
// end ;
77551: LD_VAR 0 3
77555: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77556: LD_INT 0
77558: PPUSH
77559: PPUSH
77560: PPUSH
// if not mc_bases or not skirmish then
77561: LD_EXP 59
77565: NOT
77566: PUSH
77567: LD_EXP 57
77571: NOT
77572: OR
77573: IFFALSE 77577
// exit ;
77575: GO 77666
// for i = 1 to mc_bases do
77577: LD_ADDR_VAR 0 4
77581: PUSH
77582: DOUBLE
77583: LD_INT 1
77585: DEC
77586: ST_TO_ADDR
77587: LD_EXP 59
77591: PUSH
77592: FOR_TO
77593: IFFALSE 77664
// begin if building in mc_busy_turret_list [ i ] then
77595: LD_VAR 0 1
77599: PUSH
77600: LD_EXP 69
77604: PUSH
77605: LD_VAR 0 4
77609: ARRAY
77610: IN
77611: IFFALSE 77662
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77613: LD_ADDR_VAR 0 5
77617: PUSH
77618: LD_EXP 69
77622: PUSH
77623: LD_VAR 0 4
77627: ARRAY
77628: PUSH
77629: LD_VAR 0 1
77633: DIFF
77634: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77635: LD_ADDR_EXP 69
77639: PUSH
77640: LD_EXP 69
77644: PPUSH
77645: LD_VAR 0 4
77649: PPUSH
77650: LD_VAR 0 5
77654: PPUSH
77655: CALL_OW 1
77659: ST_TO_ADDR
// break ;
77660: GO 77664
// end ; end ;
77662: GO 77592
77664: POP
77665: POP
// end ;
77666: LD_VAR 0 3
77670: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77671: LD_INT 0
77673: PPUSH
77674: PPUSH
77675: PPUSH
// if not mc_bases or not skirmish then
77676: LD_EXP 59
77680: NOT
77681: PUSH
77682: LD_EXP 57
77686: NOT
77687: OR
77688: IFFALSE 77692
// exit ;
77690: GO 77891
// for i = 1 to mc_bases do
77692: LD_ADDR_VAR 0 5
77696: PUSH
77697: DOUBLE
77698: LD_INT 1
77700: DEC
77701: ST_TO_ADDR
77702: LD_EXP 59
77706: PUSH
77707: FOR_TO
77708: IFFALSE 77889
// if building in mc_bases [ i ] then
77710: LD_VAR 0 1
77714: PUSH
77715: LD_EXP 59
77719: PUSH
77720: LD_VAR 0 5
77724: ARRAY
77725: IN
77726: IFFALSE 77887
// begin tmp := mc_bases [ i ] diff building ;
77728: LD_ADDR_VAR 0 6
77732: PUSH
77733: LD_EXP 59
77737: PUSH
77738: LD_VAR 0 5
77742: ARRAY
77743: PUSH
77744: LD_VAR 0 1
77748: DIFF
77749: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77750: LD_ADDR_EXP 59
77754: PUSH
77755: LD_EXP 59
77759: PPUSH
77760: LD_VAR 0 5
77764: PPUSH
77765: LD_VAR 0 6
77769: PPUSH
77770: CALL_OW 1
77774: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77775: LD_VAR 0 1
77779: PUSH
77780: LD_EXP 67
77784: PUSH
77785: LD_VAR 0 5
77789: ARRAY
77790: IN
77791: IFFALSE 77830
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77793: LD_ADDR_EXP 67
77797: PUSH
77798: LD_EXP 67
77802: PPUSH
77803: LD_VAR 0 5
77807: PPUSH
77808: LD_EXP 67
77812: PUSH
77813: LD_VAR 0 5
77817: ARRAY
77818: PUSH
77819: LD_VAR 0 1
77823: DIFF
77824: PPUSH
77825: CALL_OW 1
77829: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77830: LD_VAR 0 1
77834: PUSH
77835: LD_EXP 68
77839: PUSH
77840: LD_VAR 0 5
77844: ARRAY
77845: IN
77846: IFFALSE 77885
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77848: LD_ADDR_EXP 68
77852: PUSH
77853: LD_EXP 68
77857: PPUSH
77858: LD_VAR 0 5
77862: PPUSH
77863: LD_EXP 68
77867: PUSH
77868: LD_VAR 0 5
77872: ARRAY
77873: PUSH
77874: LD_VAR 0 1
77878: DIFF
77879: PPUSH
77880: CALL_OW 1
77884: ST_TO_ADDR
// break ;
77885: GO 77889
// end ;
77887: GO 77707
77889: POP
77890: POP
// end ;
77891: LD_VAR 0 4
77895: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77896: LD_INT 0
77898: PPUSH
77899: PPUSH
77900: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77901: LD_EXP 59
77905: NOT
77906: PUSH
77907: LD_EXP 57
77911: NOT
77912: OR
77913: PUSH
77914: LD_VAR 0 3
77918: PUSH
77919: LD_EXP 85
77923: IN
77924: NOT
77925: OR
77926: IFFALSE 77930
// exit ;
77928: GO 78053
// for i = 1 to mc_vehicles do
77930: LD_ADDR_VAR 0 6
77934: PUSH
77935: DOUBLE
77936: LD_INT 1
77938: DEC
77939: ST_TO_ADDR
77940: LD_EXP 78
77944: PUSH
77945: FOR_TO
77946: IFFALSE 78051
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77948: LD_VAR 0 2
77952: PUSH
77953: LD_EXP 78
77957: PUSH
77958: LD_VAR 0 6
77962: ARRAY
77963: IN
77964: PUSH
77965: LD_VAR 0 1
77969: PUSH
77970: LD_EXP 78
77974: PUSH
77975: LD_VAR 0 6
77979: ARRAY
77980: IN
77981: OR
77982: IFFALSE 78049
// begin tmp := mc_vehicles [ i ] diff old ;
77984: LD_ADDR_VAR 0 7
77988: PUSH
77989: LD_EXP 78
77993: PUSH
77994: LD_VAR 0 6
77998: ARRAY
77999: PUSH
78000: LD_VAR 0 2
78004: DIFF
78005: ST_TO_ADDR
// tmp := tmp diff new ;
78006: LD_ADDR_VAR 0 7
78010: PUSH
78011: LD_VAR 0 7
78015: PUSH
78016: LD_VAR 0 1
78020: DIFF
78021: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78022: LD_ADDR_EXP 78
78026: PUSH
78027: LD_EXP 78
78031: PPUSH
78032: LD_VAR 0 6
78036: PPUSH
78037: LD_VAR 0 7
78041: PPUSH
78042: CALL_OW 1
78046: ST_TO_ADDR
// break ;
78047: GO 78051
// end ;
78049: GO 77945
78051: POP
78052: POP
// end ;
78053: LD_VAR 0 5
78057: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78058: LD_INT 0
78060: PPUSH
78061: PPUSH
78062: PPUSH
78063: PPUSH
// if not mc_bases or not skirmish then
78064: LD_EXP 59
78068: NOT
78069: PUSH
78070: LD_EXP 57
78074: NOT
78075: OR
78076: IFFALSE 78080
// exit ;
78078: GO 78463
// side := GetSide ( vehicle ) ;
78080: LD_ADDR_VAR 0 5
78084: PUSH
78085: LD_VAR 0 1
78089: PPUSH
78090: CALL_OW 255
78094: ST_TO_ADDR
// for i = 1 to mc_bases do
78095: LD_ADDR_VAR 0 4
78099: PUSH
78100: DOUBLE
78101: LD_INT 1
78103: DEC
78104: ST_TO_ADDR
78105: LD_EXP 59
78109: PUSH
78110: FOR_TO
78111: IFFALSE 78461
// begin if factory in mc_bases [ i ] then
78113: LD_VAR 0 2
78117: PUSH
78118: LD_EXP 59
78122: PUSH
78123: LD_VAR 0 4
78127: ARRAY
78128: IN
78129: IFFALSE 78459
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78131: LD_EXP 81
78135: PUSH
78136: LD_VAR 0 4
78140: ARRAY
78141: PUSH
78142: LD_EXP 70
78146: PUSH
78147: LD_VAR 0 4
78151: ARRAY
78152: LESS
78153: PUSH
78154: LD_VAR 0 1
78158: PPUSH
78159: CALL_OW 264
78163: PUSH
78164: LD_INT 31
78166: PUSH
78167: LD_INT 32
78169: PUSH
78170: LD_INT 51
78172: PUSH
78173: LD_EXP 103
78177: PUSH
78178: LD_INT 12
78180: PUSH
78181: LD_INT 30
78183: PUSH
78184: LD_EXP 102
78188: PUSH
78189: LD_INT 11
78191: PUSH
78192: LD_INT 53
78194: PUSH
78195: LD_INT 14
78197: PUSH
78198: LD_EXP 106
78202: PUSH
78203: LD_INT 29
78205: PUSH
78206: LD_EXP 104
78210: PUSH
78211: LD_INT 13
78213: PUSH
78214: LD_INT 52
78216: PUSH
78217: LD_EXP 108
78221: PUSH
78222: LD_INT 48
78224: PUSH
78225: LD_INT 8
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: IN
78248: NOT
78249: AND
78250: IFFALSE 78298
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78252: LD_ADDR_EXP 81
78256: PUSH
78257: LD_EXP 81
78261: PPUSH
78262: LD_VAR 0 4
78266: PUSH
78267: LD_EXP 81
78271: PUSH
78272: LD_VAR 0 4
78276: ARRAY
78277: PUSH
78278: LD_INT 1
78280: PLUS
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PPUSH
78286: LD_VAR 0 1
78290: PPUSH
78291: CALL 19283 0 3
78295: ST_TO_ADDR
78296: GO 78342
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78298: LD_ADDR_EXP 78
78302: PUSH
78303: LD_EXP 78
78307: PPUSH
78308: LD_VAR 0 4
78312: PUSH
78313: LD_EXP 78
78317: PUSH
78318: LD_VAR 0 4
78322: ARRAY
78323: PUSH
78324: LD_INT 1
78326: PLUS
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PPUSH
78332: LD_VAR 0 1
78336: PPUSH
78337: CALL 19283 0 3
78341: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78342: LD_VAR 0 1
78346: PPUSH
78347: CALL_OW 263
78351: PUSH
78352: LD_INT 2
78354: EQUAL
78355: IFFALSE 78375
// begin repeat wait ( 0 0$1 ) ;
78357: LD_INT 35
78359: PPUSH
78360: CALL_OW 67
// until IsControledBy ( vehicle ) ;
78364: LD_VAR 0 1
78368: PPUSH
78369: CALL_OW 312
78373: IFFALSE 78357
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78375: LD_VAR 0 1
78379: PPUSH
78380: LD_EXP 83
78384: PUSH
78385: LD_VAR 0 4
78389: ARRAY
78390: PPUSH
78391: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78395: LD_VAR 0 1
78399: PPUSH
78400: CALL_OW 263
78404: PUSH
78405: LD_INT 1
78407: NONEQUAL
78408: IFFALSE 78412
// break ;
78410: GO 78461
// repeat wait ( 0 0$1 ) ;
78412: LD_INT 35
78414: PPUSH
78415: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78419: LD_VAR 0 1
78423: PPUSH
78424: LD_EXP 83
78428: PUSH
78429: LD_VAR 0 4
78433: ARRAY
78434: PPUSH
78435: CALL_OW 308
78439: IFFALSE 78412
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78441: LD_VAR 0 1
78445: PPUSH
78446: CALL_OW 311
78450: PPUSH
78451: CALL_OW 121
// exit ;
78455: POP
78456: POP
78457: GO 78463
// end ; end ;
78459: GO 78110
78461: POP
78462: POP
// end ;
78463: LD_VAR 0 3
78467: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78468: LD_INT 0
78470: PPUSH
78471: PPUSH
78472: PPUSH
78473: PPUSH
// if not mc_bases or not skirmish then
78474: LD_EXP 59
78478: NOT
78479: PUSH
78480: LD_EXP 57
78484: NOT
78485: OR
78486: IFFALSE 78490
// exit ;
78488: GO 78843
// repeat wait ( 0 0$1 ) ;
78490: LD_INT 35
78492: PPUSH
78493: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78497: LD_VAR 0 2
78501: PPUSH
78502: LD_VAR 0 3
78506: PPUSH
78507: CALL_OW 284
78511: IFFALSE 78490
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78513: LD_VAR 0 2
78517: PPUSH
78518: LD_VAR 0 3
78522: PPUSH
78523: CALL_OW 283
78527: PUSH
78528: LD_INT 4
78530: EQUAL
78531: IFFALSE 78535
// exit ;
78533: GO 78843
// for i = 1 to mc_bases do
78535: LD_ADDR_VAR 0 7
78539: PUSH
78540: DOUBLE
78541: LD_INT 1
78543: DEC
78544: ST_TO_ADDR
78545: LD_EXP 59
78549: PUSH
78550: FOR_TO
78551: IFFALSE 78841
// begin if mc_crates_area [ i ] then
78553: LD_EXP 77
78557: PUSH
78558: LD_VAR 0 7
78562: ARRAY
78563: IFFALSE 78674
// for j in mc_crates_area [ i ] do
78565: LD_ADDR_VAR 0 8
78569: PUSH
78570: LD_EXP 77
78574: PUSH
78575: LD_VAR 0 7
78579: ARRAY
78580: PUSH
78581: FOR_IN
78582: IFFALSE 78672
// if InArea ( x , y , j ) then
78584: LD_VAR 0 2
78588: PPUSH
78589: LD_VAR 0 3
78593: PPUSH
78594: LD_VAR 0 8
78598: PPUSH
78599: CALL_OW 309
78603: IFFALSE 78670
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78605: LD_ADDR_EXP 75
78609: PUSH
78610: LD_EXP 75
78614: PPUSH
78615: LD_VAR 0 7
78619: PUSH
78620: LD_EXP 75
78624: PUSH
78625: LD_VAR 0 7
78629: ARRAY
78630: PUSH
78631: LD_INT 1
78633: PLUS
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PPUSH
78639: LD_VAR 0 4
78643: PUSH
78644: LD_VAR 0 2
78648: PUSH
78649: LD_VAR 0 3
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: LIST
78658: PPUSH
78659: CALL 19283 0 3
78663: ST_TO_ADDR
// exit ;
78664: POP
78665: POP
78666: POP
78667: POP
78668: GO 78843
// end ;
78670: GO 78581
78672: POP
78673: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78674: LD_ADDR_VAR 0 9
78678: PUSH
78679: LD_EXP 59
78683: PUSH
78684: LD_VAR 0 7
78688: ARRAY
78689: PPUSH
78690: LD_INT 2
78692: PUSH
78693: LD_INT 30
78695: PUSH
78696: LD_INT 0
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 30
78705: PUSH
78706: LD_INT 1
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: LIST
78717: PPUSH
78718: CALL_OW 72
78722: ST_TO_ADDR
// if not depot then
78723: LD_VAR 0 9
78727: NOT
78728: IFFALSE 78732
// continue ;
78730: GO 78550
// for j in depot do
78732: LD_ADDR_VAR 0 8
78736: PUSH
78737: LD_VAR 0 9
78741: PUSH
78742: FOR_IN
78743: IFFALSE 78837
// if GetDistUnitXY ( j , x , y ) < 30 then
78745: LD_VAR 0 8
78749: PPUSH
78750: LD_VAR 0 2
78754: PPUSH
78755: LD_VAR 0 3
78759: PPUSH
78760: CALL_OW 297
78764: PUSH
78765: LD_INT 30
78767: LESS
78768: IFFALSE 78835
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78770: LD_ADDR_EXP 75
78774: PUSH
78775: LD_EXP 75
78779: PPUSH
78780: LD_VAR 0 7
78784: PUSH
78785: LD_EXP 75
78789: PUSH
78790: LD_VAR 0 7
78794: ARRAY
78795: PUSH
78796: LD_INT 1
78798: PLUS
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PPUSH
78804: LD_VAR 0 4
78808: PUSH
78809: LD_VAR 0 2
78813: PUSH
78814: LD_VAR 0 3
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: LIST
78823: PPUSH
78824: CALL 19283 0 3
78828: ST_TO_ADDR
// exit ;
78829: POP
78830: POP
78831: POP
78832: POP
78833: GO 78843
// end ;
78835: GO 78742
78837: POP
78838: POP
// end ;
78839: GO 78550
78841: POP
78842: POP
// end ;
78843: LD_VAR 0 6
78847: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78848: LD_INT 0
78850: PPUSH
78851: PPUSH
78852: PPUSH
78853: PPUSH
// if not mc_bases or not skirmish then
78854: LD_EXP 59
78858: NOT
78859: PUSH
78860: LD_EXP 57
78864: NOT
78865: OR
78866: IFFALSE 78870
// exit ;
78868: GO 79147
// side := GetSide ( lab ) ;
78870: LD_ADDR_VAR 0 4
78874: PUSH
78875: LD_VAR 0 2
78879: PPUSH
78880: CALL_OW 255
78884: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78885: LD_VAR 0 4
78889: PUSH
78890: LD_EXP 85
78894: IN
78895: NOT
78896: PUSH
78897: LD_EXP 86
78901: NOT
78902: OR
78903: PUSH
78904: LD_EXP 59
78908: NOT
78909: OR
78910: IFFALSE 78914
// exit ;
78912: GO 79147
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78914: LD_ADDR_EXP 86
78918: PUSH
78919: LD_EXP 86
78923: PPUSH
78924: LD_VAR 0 4
78928: PPUSH
78929: LD_EXP 86
78933: PUSH
78934: LD_VAR 0 4
78938: ARRAY
78939: PUSH
78940: LD_VAR 0 1
78944: DIFF
78945: PPUSH
78946: CALL_OW 1
78950: ST_TO_ADDR
// for i = 1 to mc_bases do
78951: LD_ADDR_VAR 0 5
78955: PUSH
78956: DOUBLE
78957: LD_INT 1
78959: DEC
78960: ST_TO_ADDR
78961: LD_EXP 59
78965: PUSH
78966: FOR_TO
78967: IFFALSE 79145
// begin if lab in mc_bases [ i ] then
78969: LD_VAR 0 2
78973: PUSH
78974: LD_EXP 59
78978: PUSH
78979: LD_VAR 0 5
78983: ARRAY
78984: IN
78985: IFFALSE 79143
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78987: LD_VAR 0 1
78991: PUSH
78992: LD_INT 11
78994: PUSH
78995: LD_INT 4
78997: PUSH
78998: LD_INT 3
79000: PUSH
79001: LD_INT 2
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: IN
79010: PUSH
79011: LD_EXP 89
79015: PUSH
79016: LD_VAR 0 5
79020: ARRAY
79021: AND
79022: IFFALSE 79143
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79024: LD_ADDR_VAR 0 6
79028: PUSH
79029: LD_EXP 89
79033: PUSH
79034: LD_VAR 0 5
79038: ARRAY
79039: PUSH
79040: LD_INT 1
79042: ARRAY
79043: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79044: LD_ADDR_EXP 89
79048: PUSH
79049: LD_EXP 89
79053: PPUSH
79054: LD_VAR 0 5
79058: PPUSH
79059: EMPTY
79060: PPUSH
79061: CALL_OW 1
79065: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79066: LD_VAR 0 6
79070: PPUSH
79071: LD_INT 0
79073: PPUSH
79074: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79078: LD_VAR 0 6
79082: PPUSH
79083: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79087: LD_ADDR_EXP 88
79091: PUSH
79092: LD_EXP 88
79096: PPUSH
79097: LD_VAR 0 5
79101: PPUSH
79102: LD_EXP 88
79106: PUSH
79107: LD_VAR 0 5
79111: ARRAY
79112: PPUSH
79113: LD_INT 1
79115: PPUSH
79116: LD_VAR 0 6
79120: PPUSH
79121: CALL_OW 2
79125: PPUSH
79126: CALL_OW 1
79130: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79131: LD_VAR 0 5
79135: PPUSH
79136: LD_INT 112
79138: PPUSH
79139: CALL 56071 0 2
// end ; end ; end ;
79143: GO 78966
79145: POP
79146: POP
// end ;
79147: LD_VAR 0 3
79151: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79152: LD_INT 0
79154: PPUSH
79155: PPUSH
79156: PPUSH
79157: PPUSH
79158: PPUSH
79159: PPUSH
79160: PPUSH
79161: PPUSH
// if not mc_bases or not skirmish then
79162: LD_EXP 59
79166: NOT
79167: PUSH
79168: LD_EXP 57
79172: NOT
79173: OR
79174: IFFALSE 79178
// exit ;
79176: GO 80549
// for i = 1 to mc_bases do
79178: LD_ADDR_VAR 0 3
79182: PUSH
79183: DOUBLE
79184: LD_INT 1
79186: DEC
79187: ST_TO_ADDR
79188: LD_EXP 59
79192: PUSH
79193: FOR_TO
79194: IFFALSE 80547
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79196: LD_VAR 0 1
79200: PUSH
79201: LD_EXP 59
79205: PUSH
79206: LD_VAR 0 3
79210: ARRAY
79211: IN
79212: PUSH
79213: LD_VAR 0 1
79217: PUSH
79218: LD_EXP 66
79222: PUSH
79223: LD_VAR 0 3
79227: ARRAY
79228: IN
79229: OR
79230: PUSH
79231: LD_VAR 0 1
79235: PUSH
79236: LD_EXP 81
79240: PUSH
79241: LD_VAR 0 3
79245: ARRAY
79246: IN
79247: OR
79248: PUSH
79249: LD_VAR 0 1
79253: PUSH
79254: LD_EXP 78
79258: PUSH
79259: LD_VAR 0 3
79263: ARRAY
79264: IN
79265: OR
79266: PUSH
79267: LD_VAR 0 1
79271: PUSH
79272: LD_EXP 88
79276: PUSH
79277: LD_VAR 0 3
79281: ARRAY
79282: IN
79283: OR
79284: PUSH
79285: LD_VAR 0 1
79289: PUSH
79290: LD_EXP 89
79294: PUSH
79295: LD_VAR 0 3
79299: ARRAY
79300: IN
79301: OR
79302: IFFALSE 80545
// begin if un in mc_ape [ i ] then
79304: LD_VAR 0 1
79308: PUSH
79309: LD_EXP 88
79313: PUSH
79314: LD_VAR 0 3
79318: ARRAY
79319: IN
79320: IFFALSE 79359
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79322: LD_ADDR_EXP 88
79326: PUSH
79327: LD_EXP 88
79331: PPUSH
79332: LD_VAR 0 3
79336: PPUSH
79337: LD_EXP 88
79341: PUSH
79342: LD_VAR 0 3
79346: ARRAY
79347: PUSH
79348: LD_VAR 0 1
79352: DIFF
79353: PPUSH
79354: CALL_OW 1
79358: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79359: LD_VAR 0 1
79363: PUSH
79364: LD_EXP 89
79368: PUSH
79369: LD_VAR 0 3
79373: ARRAY
79374: IN
79375: IFFALSE 79399
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79377: LD_ADDR_EXP 89
79381: PUSH
79382: LD_EXP 89
79386: PPUSH
79387: LD_VAR 0 3
79391: PPUSH
79392: EMPTY
79393: PPUSH
79394: CALL_OW 1
79398: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79399: LD_VAR 0 1
79403: PPUSH
79404: CALL_OW 247
79408: PUSH
79409: LD_INT 2
79411: EQUAL
79412: PUSH
79413: LD_VAR 0 1
79417: PPUSH
79418: CALL_OW 110
79422: PUSH
79423: LD_INT 20
79425: EQUAL
79426: PUSH
79427: LD_VAR 0 1
79431: PUSH
79432: LD_EXP 81
79436: PUSH
79437: LD_VAR 0 3
79441: ARRAY
79442: IN
79443: OR
79444: PUSH
79445: LD_VAR 0 1
79449: PPUSH
79450: CALL_OW 264
79454: PUSH
79455: LD_INT 12
79457: PUSH
79458: LD_INT 51
79460: PUSH
79461: LD_EXP 103
79465: PUSH
79466: LD_INT 32
79468: PUSH
79469: LD_INT 13
79471: PUSH
79472: LD_INT 52
79474: PUSH
79475: LD_INT 31
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: IN
79487: OR
79488: AND
79489: IFFALSE 79797
// begin if un in mc_defender [ i ] then
79491: LD_VAR 0 1
79495: PUSH
79496: LD_EXP 81
79500: PUSH
79501: LD_VAR 0 3
79505: ARRAY
79506: IN
79507: IFFALSE 79546
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79509: LD_ADDR_EXP 81
79513: PUSH
79514: LD_EXP 81
79518: PPUSH
79519: LD_VAR 0 3
79523: PPUSH
79524: LD_EXP 81
79528: PUSH
79529: LD_VAR 0 3
79533: ARRAY
79534: PUSH
79535: LD_VAR 0 1
79539: DIFF
79540: PPUSH
79541: CALL_OW 1
79545: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79546: LD_ADDR_VAR 0 8
79550: PUSH
79551: LD_VAR 0 3
79555: PPUSH
79556: LD_INT 3
79558: PPUSH
79559: CALL 76196 0 2
79563: ST_TO_ADDR
// if fac then
79564: LD_VAR 0 8
79568: IFFALSE 79797
// begin for j in fac do
79570: LD_ADDR_VAR 0 4
79574: PUSH
79575: LD_VAR 0 8
79579: PUSH
79580: FOR_IN
79581: IFFALSE 79795
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79583: LD_ADDR_VAR 0 9
79587: PUSH
79588: LD_VAR 0 8
79592: PPUSH
79593: LD_VAR 0 1
79597: PPUSH
79598: CALL_OW 265
79602: PPUSH
79603: LD_VAR 0 1
79607: PPUSH
79608: CALL_OW 262
79612: PPUSH
79613: LD_VAR 0 1
79617: PPUSH
79618: CALL_OW 263
79622: PPUSH
79623: LD_VAR 0 1
79627: PPUSH
79628: CALL_OW 264
79632: PPUSH
79633: CALL 16815 0 5
79637: ST_TO_ADDR
// if components then
79638: LD_VAR 0 9
79642: IFFALSE 79793
// begin if GetWeapon ( un ) = ar_control_tower then
79644: LD_VAR 0 1
79648: PPUSH
79649: CALL_OW 264
79653: PUSH
79654: LD_INT 31
79656: EQUAL
79657: IFFALSE 79774
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79659: LD_VAR 0 1
79663: PPUSH
79664: CALL_OW 311
79668: PPUSH
79669: LD_INT 0
79671: PPUSH
79672: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79676: LD_ADDR_EXP 99
79680: PUSH
79681: LD_EXP 99
79685: PPUSH
79686: LD_VAR 0 3
79690: PPUSH
79691: LD_EXP 99
79695: PUSH
79696: LD_VAR 0 3
79700: ARRAY
79701: PUSH
79702: LD_VAR 0 1
79706: PPUSH
79707: CALL_OW 311
79711: DIFF
79712: PPUSH
79713: CALL_OW 1
79717: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79718: LD_ADDR_VAR 0 7
79722: PUSH
79723: LD_EXP 80
79727: PUSH
79728: LD_VAR 0 3
79732: ARRAY
79733: PPUSH
79734: LD_INT 1
79736: PPUSH
79737: LD_VAR 0 9
79741: PPUSH
79742: CALL_OW 2
79746: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79747: LD_ADDR_EXP 80
79751: PUSH
79752: LD_EXP 80
79756: PPUSH
79757: LD_VAR 0 3
79761: PPUSH
79762: LD_VAR 0 7
79766: PPUSH
79767: CALL_OW 1
79771: ST_TO_ADDR
// end else
79772: GO 79791
// MC_InsertProduceList ( i , [ components ] ) ;
79774: LD_VAR 0 3
79778: PPUSH
79779: LD_VAR 0 9
79783: PUSH
79784: EMPTY
79785: LIST
79786: PPUSH
79787: CALL 75741 0 2
// break ;
79791: GO 79795
// end ; end ;
79793: GO 79580
79795: POP
79796: POP
// end ; end ; if GetType ( un ) = unit_building then
79797: LD_VAR 0 1
79801: PPUSH
79802: CALL_OW 247
79806: PUSH
79807: LD_INT 3
79809: EQUAL
79810: IFFALSE 80213
// begin btype := GetBType ( un ) ;
79812: LD_ADDR_VAR 0 5
79816: PUSH
79817: LD_VAR 0 1
79821: PPUSH
79822: CALL_OW 266
79826: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79827: LD_VAR 0 5
79831: PUSH
79832: LD_INT 29
79834: PUSH
79835: LD_INT 30
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: IN
79842: IFFALSE 79915
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79844: LD_VAR 0 1
79848: PPUSH
79849: CALL_OW 250
79853: PPUSH
79854: LD_VAR 0 1
79858: PPUSH
79859: CALL_OW 251
79863: PPUSH
79864: LD_VAR 0 1
79868: PPUSH
79869: CALL_OW 255
79873: PPUSH
79874: CALL_OW 440
79878: NOT
79879: IFFALSE 79915
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79881: LD_VAR 0 1
79885: PPUSH
79886: CALL_OW 250
79890: PPUSH
79891: LD_VAR 0 1
79895: PPUSH
79896: CALL_OW 251
79900: PPUSH
79901: LD_VAR 0 1
79905: PPUSH
79906: CALL_OW 255
79910: PPUSH
79911: CALL_OW 441
// end ; if btype = b_warehouse then
79915: LD_VAR 0 5
79919: PUSH
79920: LD_INT 1
79922: EQUAL
79923: IFFALSE 79941
// begin btype := b_depot ;
79925: LD_ADDR_VAR 0 5
79929: PUSH
79930: LD_INT 0
79932: ST_TO_ADDR
// pos := 1 ;
79933: LD_ADDR_VAR 0 6
79937: PUSH
79938: LD_INT 1
79940: ST_TO_ADDR
// end ; if btype = b_factory then
79941: LD_VAR 0 5
79945: PUSH
79946: LD_INT 3
79948: EQUAL
79949: IFFALSE 79967
// begin btype := b_workshop ;
79951: LD_ADDR_VAR 0 5
79955: PUSH
79956: LD_INT 2
79958: ST_TO_ADDR
// pos := 1 ;
79959: LD_ADDR_VAR 0 6
79963: PUSH
79964: LD_INT 1
79966: ST_TO_ADDR
// end ; if btype = b_barracks then
79967: LD_VAR 0 5
79971: PUSH
79972: LD_INT 5
79974: EQUAL
79975: IFFALSE 79985
// btype := b_armoury ;
79977: LD_ADDR_VAR 0 5
79981: PUSH
79982: LD_INT 4
79984: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79985: LD_VAR 0 5
79989: PUSH
79990: LD_INT 7
79992: PUSH
79993: LD_INT 8
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: IN
80000: IFFALSE 80010
// btype := b_lab ;
80002: LD_ADDR_VAR 0 5
80006: PUSH
80007: LD_INT 6
80009: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80010: LD_ADDR_EXP 64
80014: PUSH
80015: LD_EXP 64
80019: PPUSH
80020: LD_VAR 0 3
80024: PUSH
80025: LD_EXP 64
80029: PUSH
80030: LD_VAR 0 3
80034: ARRAY
80035: PUSH
80036: LD_INT 1
80038: PLUS
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PPUSH
80044: LD_VAR 0 5
80048: PUSH
80049: LD_VAR 0 1
80053: PPUSH
80054: CALL_OW 250
80058: PUSH
80059: LD_VAR 0 1
80063: PPUSH
80064: CALL_OW 251
80068: PUSH
80069: LD_VAR 0 1
80073: PPUSH
80074: CALL_OW 254
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: PPUSH
80085: CALL 19283 0 3
80089: ST_TO_ADDR
// if pos = 1 then
80090: LD_VAR 0 6
80094: PUSH
80095: LD_INT 1
80097: EQUAL
80098: IFFALSE 80213
// begin tmp := mc_build_list [ i ] ;
80100: LD_ADDR_VAR 0 7
80104: PUSH
80105: LD_EXP 64
80109: PUSH
80110: LD_VAR 0 3
80114: ARRAY
80115: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80116: LD_VAR 0 7
80120: PPUSH
80121: LD_INT 2
80123: PUSH
80124: LD_INT 30
80126: PUSH
80127: LD_INT 0
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 30
80136: PUSH
80137: LD_INT 1
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: LIST
80148: PPUSH
80149: CALL_OW 72
80153: IFFALSE 80163
// pos := 2 ;
80155: LD_ADDR_VAR 0 6
80159: PUSH
80160: LD_INT 2
80162: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80163: LD_ADDR_VAR 0 7
80167: PUSH
80168: LD_VAR 0 7
80172: PPUSH
80173: LD_VAR 0 6
80177: PPUSH
80178: LD_VAR 0 7
80182: PPUSH
80183: CALL 19609 0 3
80187: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80188: LD_ADDR_EXP 64
80192: PUSH
80193: LD_EXP 64
80197: PPUSH
80198: LD_VAR 0 3
80202: PPUSH
80203: LD_VAR 0 7
80207: PPUSH
80208: CALL_OW 1
80212: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80213: LD_VAR 0 1
80217: PUSH
80218: LD_EXP 59
80222: PUSH
80223: LD_VAR 0 3
80227: ARRAY
80228: IN
80229: IFFALSE 80268
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80231: LD_ADDR_EXP 59
80235: PUSH
80236: LD_EXP 59
80240: PPUSH
80241: LD_VAR 0 3
80245: PPUSH
80246: LD_EXP 59
80250: PUSH
80251: LD_VAR 0 3
80255: ARRAY
80256: PUSH
80257: LD_VAR 0 1
80261: DIFF
80262: PPUSH
80263: CALL_OW 1
80267: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80268: LD_VAR 0 1
80272: PUSH
80273: LD_EXP 66
80277: PUSH
80278: LD_VAR 0 3
80282: ARRAY
80283: IN
80284: IFFALSE 80323
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80286: LD_ADDR_EXP 66
80290: PUSH
80291: LD_EXP 66
80295: PPUSH
80296: LD_VAR 0 3
80300: PPUSH
80301: LD_EXP 66
80305: PUSH
80306: LD_VAR 0 3
80310: ARRAY
80311: PUSH
80312: LD_VAR 0 1
80316: DIFF
80317: PPUSH
80318: CALL_OW 1
80322: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80323: LD_VAR 0 1
80327: PUSH
80328: LD_EXP 78
80332: PUSH
80333: LD_VAR 0 3
80337: ARRAY
80338: IN
80339: IFFALSE 80378
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80341: LD_ADDR_EXP 78
80345: PUSH
80346: LD_EXP 78
80350: PPUSH
80351: LD_VAR 0 3
80355: PPUSH
80356: LD_EXP 78
80360: PUSH
80361: LD_VAR 0 3
80365: ARRAY
80366: PUSH
80367: LD_VAR 0 1
80371: DIFF
80372: PPUSH
80373: CALL_OW 1
80377: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80378: LD_VAR 0 1
80382: PUSH
80383: LD_EXP 81
80387: PUSH
80388: LD_VAR 0 3
80392: ARRAY
80393: IN
80394: IFFALSE 80433
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80396: LD_ADDR_EXP 81
80400: PUSH
80401: LD_EXP 81
80405: PPUSH
80406: LD_VAR 0 3
80410: PPUSH
80411: LD_EXP 81
80415: PUSH
80416: LD_VAR 0 3
80420: ARRAY
80421: PUSH
80422: LD_VAR 0 1
80426: DIFF
80427: PPUSH
80428: CALL_OW 1
80432: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80433: LD_VAR 0 1
80437: PUSH
80438: LD_EXP 68
80442: PUSH
80443: LD_VAR 0 3
80447: ARRAY
80448: IN
80449: IFFALSE 80488
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80451: LD_ADDR_EXP 68
80455: PUSH
80456: LD_EXP 68
80460: PPUSH
80461: LD_VAR 0 3
80465: PPUSH
80466: LD_EXP 68
80470: PUSH
80471: LD_VAR 0 3
80475: ARRAY
80476: PUSH
80477: LD_VAR 0 1
80481: DIFF
80482: PPUSH
80483: CALL_OW 1
80487: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80488: LD_VAR 0 1
80492: PUSH
80493: LD_EXP 67
80497: PUSH
80498: LD_VAR 0 3
80502: ARRAY
80503: IN
80504: IFFALSE 80543
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80506: LD_ADDR_EXP 67
80510: PUSH
80511: LD_EXP 67
80515: PPUSH
80516: LD_VAR 0 3
80520: PPUSH
80521: LD_EXP 67
80525: PUSH
80526: LD_VAR 0 3
80530: ARRAY
80531: PUSH
80532: LD_VAR 0 1
80536: DIFF
80537: PPUSH
80538: CALL_OW 1
80542: ST_TO_ADDR
// end ; break ;
80543: GO 80547
// end ;
80545: GO 79193
80547: POP
80548: POP
// end ;
80549: LD_VAR 0 2
80553: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80554: LD_INT 0
80556: PPUSH
80557: PPUSH
80558: PPUSH
// if not mc_bases or not skirmish then
80559: LD_EXP 59
80563: NOT
80564: PUSH
80565: LD_EXP 57
80569: NOT
80570: OR
80571: IFFALSE 80575
// exit ;
80573: GO 80790
// for i = 1 to mc_bases do
80575: LD_ADDR_VAR 0 3
80579: PUSH
80580: DOUBLE
80581: LD_INT 1
80583: DEC
80584: ST_TO_ADDR
80585: LD_EXP 59
80589: PUSH
80590: FOR_TO
80591: IFFALSE 80788
// begin if building in mc_construct_list [ i ] then
80593: LD_VAR 0 1
80597: PUSH
80598: LD_EXP 66
80602: PUSH
80603: LD_VAR 0 3
80607: ARRAY
80608: IN
80609: IFFALSE 80786
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80611: LD_ADDR_EXP 66
80615: PUSH
80616: LD_EXP 66
80620: PPUSH
80621: LD_VAR 0 3
80625: PPUSH
80626: LD_EXP 66
80630: PUSH
80631: LD_VAR 0 3
80635: ARRAY
80636: PUSH
80637: LD_VAR 0 1
80641: DIFF
80642: PPUSH
80643: CALL_OW 1
80647: ST_TO_ADDR
// if building in mc_lab [ i ] then
80648: LD_VAR 0 1
80652: PUSH
80653: LD_EXP 92
80657: PUSH
80658: LD_VAR 0 3
80662: ARRAY
80663: IN
80664: IFFALSE 80719
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80666: LD_ADDR_EXP 93
80670: PUSH
80671: LD_EXP 93
80675: PPUSH
80676: LD_VAR 0 3
80680: PPUSH
80681: LD_EXP 93
80685: PUSH
80686: LD_VAR 0 3
80690: ARRAY
80691: PPUSH
80692: LD_INT 1
80694: PPUSH
80695: LD_EXP 93
80699: PUSH
80700: LD_VAR 0 3
80704: ARRAY
80705: PPUSH
80706: LD_INT 0
80708: PPUSH
80709: CALL 18701 0 4
80713: PPUSH
80714: CALL_OW 1
80718: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80719: LD_VAR 0 1
80723: PUSH
80724: LD_EXP 59
80728: PUSH
80729: LD_VAR 0 3
80733: ARRAY
80734: IN
80735: NOT
80736: IFFALSE 80782
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80738: LD_ADDR_EXP 59
80742: PUSH
80743: LD_EXP 59
80747: PPUSH
80748: LD_VAR 0 3
80752: PUSH
80753: LD_EXP 59
80757: PUSH
80758: LD_VAR 0 3
80762: ARRAY
80763: PUSH
80764: LD_INT 1
80766: PLUS
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PPUSH
80772: LD_VAR 0 1
80776: PPUSH
80777: CALL 19283 0 3
80781: ST_TO_ADDR
// exit ;
80782: POP
80783: POP
80784: GO 80790
// end ; end ;
80786: GO 80590
80788: POP
80789: POP
// end ;
80790: LD_VAR 0 2
80794: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80795: LD_INT 0
80797: PPUSH
80798: PPUSH
80799: PPUSH
80800: PPUSH
80801: PPUSH
80802: PPUSH
80803: PPUSH
// if not mc_bases or not skirmish then
80804: LD_EXP 59
80808: NOT
80809: PUSH
80810: LD_EXP 57
80814: NOT
80815: OR
80816: IFFALSE 80820
// exit ;
80818: GO 81481
// for i = 1 to mc_bases do
80820: LD_ADDR_VAR 0 3
80824: PUSH
80825: DOUBLE
80826: LD_INT 1
80828: DEC
80829: ST_TO_ADDR
80830: LD_EXP 59
80834: PUSH
80835: FOR_TO
80836: IFFALSE 81479
// begin if building in mc_construct_list [ i ] then
80838: LD_VAR 0 1
80842: PUSH
80843: LD_EXP 66
80847: PUSH
80848: LD_VAR 0 3
80852: ARRAY
80853: IN
80854: IFFALSE 81477
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80856: LD_ADDR_EXP 66
80860: PUSH
80861: LD_EXP 66
80865: PPUSH
80866: LD_VAR 0 3
80870: PPUSH
80871: LD_EXP 66
80875: PUSH
80876: LD_VAR 0 3
80880: ARRAY
80881: PUSH
80882: LD_VAR 0 1
80886: DIFF
80887: PPUSH
80888: CALL_OW 1
80892: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80893: LD_ADDR_EXP 59
80897: PUSH
80898: LD_EXP 59
80902: PPUSH
80903: LD_VAR 0 3
80907: PUSH
80908: LD_EXP 59
80912: PUSH
80913: LD_VAR 0 3
80917: ARRAY
80918: PUSH
80919: LD_INT 1
80921: PLUS
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PPUSH
80927: LD_VAR 0 1
80931: PPUSH
80932: CALL 19283 0 3
80936: ST_TO_ADDR
// btype := GetBType ( building ) ;
80937: LD_ADDR_VAR 0 5
80941: PUSH
80942: LD_VAR 0 1
80946: PPUSH
80947: CALL_OW 266
80951: ST_TO_ADDR
// side := GetSide ( building ) ;
80952: LD_ADDR_VAR 0 8
80956: PUSH
80957: LD_VAR 0 1
80961: PPUSH
80962: CALL_OW 255
80966: ST_TO_ADDR
// if btype = b_lab then
80967: LD_VAR 0 5
80971: PUSH
80972: LD_INT 6
80974: EQUAL
80975: IFFALSE 81025
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80977: LD_ADDR_EXP 92
80981: PUSH
80982: LD_EXP 92
80986: PPUSH
80987: LD_VAR 0 3
80991: PUSH
80992: LD_EXP 92
80996: PUSH
80997: LD_VAR 0 3
81001: ARRAY
81002: PUSH
81003: LD_INT 1
81005: PLUS
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PPUSH
81011: LD_VAR 0 1
81015: PPUSH
81016: CALL 19283 0 3
81020: ST_TO_ADDR
// exit ;
81021: POP
81022: POP
81023: GO 81481
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81025: LD_VAR 0 5
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 2
81035: PUSH
81036: LD_INT 4
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: LIST
81043: IN
81044: IFFALSE 81168
// begin if btype = b_armoury then
81046: LD_VAR 0 5
81050: PUSH
81051: LD_INT 4
81053: EQUAL
81054: IFFALSE 81064
// btype := b_barracks ;
81056: LD_ADDR_VAR 0 5
81060: PUSH
81061: LD_INT 5
81063: ST_TO_ADDR
// if btype = b_depot then
81064: LD_VAR 0 5
81068: PUSH
81069: LD_INT 0
81071: EQUAL
81072: IFFALSE 81082
// btype := b_warehouse ;
81074: LD_ADDR_VAR 0 5
81078: PUSH
81079: LD_INT 1
81081: ST_TO_ADDR
// if btype = b_workshop then
81082: LD_VAR 0 5
81086: PUSH
81087: LD_INT 2
81089: EQUAL
81090: IFFALSE 81100
// btype := b_factory ;
81092: LD_ADDR_VAR 0 5
81096: PUSH
81097: LD_INT 3
81099: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81100: LD_VAR 0 5
81104: PPUSH
81105: LD_VAR 0 8
81109: PPUSH
81110: CALL_OW 323
81114: PUSH
81115: LD_INT 1
81117: EQUAL
81118: IFFALSE 81164
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81120: LD_ADDR_EXP 91
81124: PUSH
81125: LD_EXP 91
81129: PPUSH
81130: LD_VAR 0 3
81134: PUSH
81135: LD_EXP 91
81139: PUSH
81140: LD_VAR 0 3
81144: ARRAY
81145: PUSH
81146: LD_INT 1
81148: PLUS
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PPUSH
81154: LD_VAR 0 1
81158: PPUSH
81159: CALL 19283 0 3
81163: ST_TO_ADDR
// exit ;
81164: POP
81165: POP
81166: GO 81481
// end ; if btype in [ b_bunker , b_turret ] then
81168: LD_VAR 0 5
81172: PUSH
81173: LD_INT 32
81175: PUSH
81176: LD_INT 33
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: IN
81183: IFFALSE 81473
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81185: LD_ADDR_EXP 67
81189: PUSH
81190: LD_EXP 67
81194: PPUSH
81195: LD_VAR 0 3
81199: PUSH
81200: LD_EXP 67
81204: PUSH
81205: LD_VAR 0 3
81209: ARRAY
81210: PUSH
81211: LD_INT 1
81213: PLUS
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PPUSH
81219: LD_VAR 0 1
81223: PPUSH
81224: CALL 19283 0 3
81228: ST_TO_ADDR
// if btype = b_bunker then
81229: LD_VAR 0 5
81233: PUSH
81234: LD_INT 32
81236: EQUAL
81237: IFFALSE 81473
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81239: LD_ADDR_EXP 68
81243: PUSH
81244: LD_EXP 68
81248: PPUSH
81249: LD_VAR 0 3
81253: PUSH
81254: LD_EXP 68
81258: PUSH
81259: LD_VAR 0 3
81263: ARRAY
81264: PUSH
81265: LD_INT 1
81267: PLUS
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PPUSH
81273: LD_VAR 0 1
81277: PPUSH
81278: CALL 19283 0 3
81282: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81283: LD_ADDR_VAR 0 6
81287: PUSH
81288: LD_EXP 59
81292: PUSH
81293: LD_VAR 0 3
81297: ARRAY
81298: PPUSH
81299: LD_INT 25
81301: PUSH
81302: LD_INT 1
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 3
81311: PUSH
81312: LD_INT 54
81314: PUSH
81315: EMPTY
81316: LIST
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PPUSH
81326: CALL_OW 72
81330: ST_TO_ADDR
// if tmp then
81331: LD_VAR 0 6
81335: IFFALSE 81341
// exit ;
81337: POP
81338: POP
81339: GO 81481
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81341: LD_ADDR_VAR 0 6
81345: PUSH
81346: LD_EXP 59
81350: PUSH
81351: LD_VAR 0 3
81355: ARRAY
81356: PPUSH
81357: LD_INT 2
81359: PUSH
81360: LD_INT 30
81362: PUSH
81363: LD_INT 4
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 30
81372: PUSH
81373: LD_INT 5
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: LIST
81384: PPUSH
81385: CALL_OW 72
81389: ST_TO_ADDR
// if not tmp then
81390: LD_VAR 0 6
81394: NOT
81395: IFFALSE 81401
// exit ;
81397: POP
81398: POP
81399: GO 81481
// for j in tmp do
81401: LD_ADDR_VAR 0 4
81405: PUSH
81406: LD_VAR 0 6
81410: PUSH
81411: FOR_IN
81412: IFFALSE 81471
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81414: LD_ADDR_VAR 0 7
81418: PUSH
81419: LD_VAR 0 4
81423: PPUSH
81424: CALL_OW 313
81428: PPUSH
81429: LD_INT 25
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PPUSH
81439: CALL_OW 72
81443: ST_TO_ADDR
// if units then
81444: LD_VAR 0 7
81448: IFFALSE 81469
// begin ComExitBuilding ( units [ 1 ] ) ;
81450: LD_VAR 0 7
81454: PUSH
81455: LD_INT 1
81457: ARRAY
81458: PPUSH
81459: CALL_OW 122
// exit ;
81463: POP
81464: POP
81465: POP
81466: POP
81467: GO 81481
// end ; end ;
81469: GO 81411
81471: POP
81472: POP
// end ; end ; exit ;
81473: POP
81474: POP
81475: GO 81481
// end ; end ;
81477: GO 80835
81479: POP
81480: POP
// end ;
81481: LD_VAR 0 2
81485: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81486: LD_INT 0
81488: PPUSH
81489: PPUSH
81490: PPUSH
81491: PPUSH
81492: PPUSH
81493: PPUSH
81494: PPUSH
// if not mc_bases or not skirmish then
81495: LD_EXP 59
81499: NOT
81500: PUSH
81501: LD_EXP 57
81505: NOT
81506: OR
81507: IFFALSE 81511
// exit ;
81509: GO 81742
// btype := GetBType ( building ) ;
81511: LD_ADDR_VAR 0 6
81515: PUSH
81516: LD_VAR 0 1
81520: PPUSH
81521: CALL_OW 266
81525: ST_TO_ADDR
// x := GetX ( building ) ;
81526: LD_ADDR_VAR 0 7
81530: PUSH
81531: LD_VAR 0 1
81535: PPUSH
81536: CALL_OW 250
81540: ST_TO_ADDR
// y := GetY ( building ) ;
81541: LD_ADDR_VAR 0 8
81545: PUSH
81546: LD_VAR 0 1
81550: PPUSH
81551: CALL_OW 251
81555: ST_TO_ADDR
// d := GetDir ( building ) ;
81556: LD_ADDR_VAR 0 9
81560: PUSH
81561: LD_VAR 0 1
81565: PPUSH
81566: CALL_OW 254
81570: ST_TO_ADDR
// for i = 1 to mc_bases do
81571: LD_ADDR_VAR 0 4
81575: PUSH
81576: DOUBLE
81577: LD_INT 1
81579: DEC
81580: ST_TO_ADDR
81581: LD_EXP 59
81585: PUSH
81586: FOR_TO
81587: IFFALSE 81740
// begin if not mc_build_list [ i ] then
81589: LD_EXP 64
81593: PUSH
81594: LD_VAR 0 4
81598: ARRAY
81599: NOT
81600: IFFALSE 81604
// continue ;
81602: GO 81586
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
81604: LD_VAR 0 6
81608: PUSH
81609: LD_VAR 0 7
81613: PUSH
81614: LD_VAR 0 8
81618: PUSH
81619: LD_VAR 0 9
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: PPUSH
81630: LD_EXP 64
81634: PUSH
81635: LD_VAR 0 4
81639: ARRAY
81640: PUSH
81641: LD_INT 1
81643: ARRAY
81644: PPUSH
81645: CALL 25490 0 2
81649: IFFALSE 81738
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81651: LD_ADDR_EXP 64
81655: PUSH
81656: LD_EXP 64
81660: PPUSH
81661: LD_VAR 0 4
81665: PPUSH
81666: LD_EXP 64
81670: PUSH
81671: LD_VAR 0 4
81675: ARRAY
81676: PPUSH
81677: LD_INT 1
81679: PPUSH
81680: CALL_OW 3
81684: PPUSH
81685: CALL_OW 1
81689: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81690: LD_ADDR_EXP 66
81694: PUSH
81695: LD_EXP 66
81699: PPUSH
81700: LD_VAR 0 4
81704: PUSH
81705: LD_EXP 66
81709: PUSH
81710: LD_VAR 0 4
81714: ARRAY
81715: PUSH
81716: LD_INT 1
81718: PLUS
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PPUSH
81724: LD_VAR 0 1
81728: PPUSH
81729: CALL 19283 0 3
81733: ST_TO_ADDR
// exit ;
81734: POP
81735: POP
81736: GO 81742
// end ; end ;
81738: GO 81586
81740: POP
81741: POP
// end ;
81742: LD_VAR 0 3
81746: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81747: LD_INT 0
81749: PPUSH
81750: PPUSH
81751: PPUSH
// if not mc_bases or not skirmish then
81752: LD_EXP 59
81756: NOT
81757: PUSH
81758: LD_EXP 57
81762: NOT
81763: OR
81764: IFFALSE 81768
// exit ;
81766: GO 81958
// for i = 1 to mc_bases do
81768: LD_ADDR_VAR 0 4
81772: PUSH
81773: DOUBLE
81774: LD_INT 1
81776: DEC
81777: ST_TO_ADDR
81778: LD_EXP 59
81782: PUSH
81783: FOR_TO
81784: IFFALSE 81871
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81786: LD_VAR 0 1
81790: PUSH
81791: LD_EXP 67
81795: PUSH
81796: LD_VAR 0 4
81800: ARRAY
81801: IN
81802: PUSH
81803: LD_VAR 0 1
81807: PUSH
81808: LD_EXP 68
81812: PUSH
81813: LD_VAR 0 4
81817: ARRAY
81818: IN
81819: NOT
81820: AND
81821: IFFALSE 81869
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81823: LD_ADDR_EXP 68
81827: PUSH
81828: LD_EXP 68
81832: PPUSH
81833: LD_VAR 0 4
81837: PUSH
81838: LD_EXP 68
81842: PUSH
81843: LD_VAR 0 4
81847: ARRAY
81848: PUSH
81849: LD_INT 1
81851: PLUS
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PPUSH
81857: LD_VAR 0 1
81861: PPUSH
81862: CALL 19283 0 3
81866: ST_TO_ADDR
// break ;
81867: GO 81871
// end ; end ;
81869: GO 81783
81871: POP
81872: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81873: LD_VAR 0 1
81877: PPUSH
81878: CALL_OW 257
81882: PUSH
81883: LD_EXP 85
81887: IN
81888: PUSH
81889: LD_VAR 0 1
81893: PPUSH
81894: CALL_OW 266
81898: PUSH
81899: LD_INT 5
81901: EQUAL
81902: AND
81903: PUSH
81904: LD_VAR 0 2
81908: PPUSH
81909: CALL_OW 110
81913: PUSH
81914: LD_INT 18
81916: NONEQUAL
81917: AND
81918: IFFALSE 81958
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81920: LD_VAR 0 2
81924: PPUSH
81925: CALL_OW 257
81929: PUSH
81930: LD_INT 5
81932: PUSH
81933: LD_INT 8
81935: PUSH
81936: LD_INT 9
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: LIST
81943: IN
81944: IFFALSE 81958
// SetClass ( unit , 1 ) ;
81946: LD_VAR 0 2
81950: PPUSH
81951: LD_INT 1
81953: PPUSH
81954: CALL_OW 336
// end ;
81958: LD_VAR 0 3
81962: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81963: LD_INT 0
81965: PPUSH
81966: PPUSH
// if not mc_bases or not skirmish then
81967: LD_EXP 59
81971: NOT
81972: PUSH
81973: LD_EXP 57
81977: NOT
81978: OR
81979: IFFALSE 81983
// exit ;
81981: GO 82099
// if GetLives ( abandoned_vehicle ) > 250 then
81983: LD_VAR 0 2
81987: PPUSH
81988: CALL_OW 256
81992: PUSH
81993: LD_INT 250
81995: GREATER
81996: IFFALSE 82000
// exit ;
81998: GO 82099
// for i = 1 to mc_bases do
82000: LD_ADDR_VAR 0 6
82004: PUSH
82005: DOUBLE
82006: LD_INT 1
82008: DEC
82009: ST_TO_ADDR
82010: LD_EXP 59
82014: PUSH
82015: FOR_TO
82016: IFFALSE 82097
// begin if driver in mc_bases [ i ] then
82018: LD_VAR 0 1
82022: PUSH
82023: LD_EXP 59
82027: PUSH
82028: LD_VAR 0 6
82032: ARRAY
82033: IN
82034: IFFALSE 82095
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82036: LD_VAR 0 1
82040: PPUSH
82041: LD_EXP 59
82045: PUSH
82046: LD_VAR 0 6
82050: ARRAY
82051: PPUSH
82052: LD_INT 2
82054: PUSH
82055: LD_INT 30
82057: PUSH
82058: LD_INT 0
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 30
82067: PUSH
82068: LD_INT 1
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: LIST
82079: PPUSH
82080: CALL_OW 72
82084: PUSH
82085: LD_INT 1
82087: ARRAY
82088: PPUSH
82089: CALL 51526 0 2
// break ;
82093: GO 82097
// end ; end ;
82095: GO 82015
82097: POP
82098: POP
// end ; end_of_file
82099: LD_VAR 0 5
82103: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
82104: LD_INT 0
82106: PPUSH
// ar_miner := 81 ;
82107: LD_ADDR_EXP 109
82111: PUSH
82112: LD_INT 81
82114: ST_TO_ADDR
// ar_crane := 88 ;
82115: LD_ADDR_EXP 108
82119: PUSH
82120: LD_INT 88
82122: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
82123: LD_ADDR_EXP 103
82127: PUSH
82128: LD_INT 89
82130: ST_TO_ADDR
// us_hack := 99 ;
82131: LD_ADDR_EXP 104
82135: PUSH
82136: LD_INT 99
82138: ST_TO_ADDR
// us_artillery := 97 ;
82139: LD_ADDR_EXP 105
82143: PUSH
82144: LD_INT 97
82146: ST_TO_ADDR
// ar_bio_bomb := 91 ;
82147: LD_ADDR_EXP 106
82151: PUSH
82152: LD_INT 91
82154: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
82155: LD_ADDR_EXP 107
82159: PUSH
82160: LD_INT 92
82162: ST_TO_ADDR
// ru_radar := 98 ;
82163: LD_ADDR_EXP 102
82167: PUSH
82168: LD_INT 98
82170: ST_TO_ADDR
// tech_Artillery := 80 ;
82171: LD_ADDR_EXP 110
82175: PUSH
82176: LD_INT 80
82178: ST_TO_ADDR
// tech_RadMat := 81 ;
82179: LD_ADDR_EXP 111
82183: PUSH
82184: LD_INT 81
82186: ST_TO_ADDR
// tech_BasicTools := 82 ;
82187: LD_ADDR_EXP 112
82191: PUSH
82192: LD_INT 82
82194: ST_TO_ADDR
// tech_Cargo := 83 ;
82195: LD_ADDR_EXP 113
82199: PUSH
82200: LD_INT 83
82202: ST_TO_ADDR
// tech_Track := 84 ;
82203: LD_ADDR_EXP 114
82207: PUSH
82208: LD_INT 84
82210: ST_TO_ADDR
// tech_Crane := 85 ;
82211: LD_ADDR_EXP 115
82215: PUSH
82216: LD_INT 85
82218: ST_TO_ADDR
// tech_Bulldozer := 86 ;
82219: LD_ADDR_EXP 116
82223: PUSH
82224: LD_INT 86
82226: ST_TO_ADDR
// tech_Hovercraft := 87 ;
82227: LD_ADDR_EXP 117
82231: PUSH
82232: LD_INT 87
82234: ST_TO_ADDR
// end ;
82235: LD_VAR 0 1
82239: RET
// every 1 do
82240: GO 82242
82242: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
82243: CALL 82104 0 0
82247: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
82248: LD_VAR 0 2
82252: PUSH
82253: LD_INT 100
82255: EQUAL
82256: IFFALSE 83205
// begin if not StreamModeActive then
82258: LD_EXP 118
82262: NOT
82263: IFFALSE 82273
// StreamModeActive := true ;
82265: LD_ADDR_EXP 118
82269: PUSH
82270: LD_INT 1
82272: ST_TO_ADDR
// if p3 = 0 then
82273: LD_VAR 0 3
82277: PUSH
82278: LD_INT 0
82280: EQUAL
82281: IFFALSE 82287
// InitStreamMode ;
82283: CALL 83363 0 0
// if p3 = 1 then
82287: LD_VAR 0 3
82291: PUSH
82292: LD_INT 1
82294: EQUAL
82295: IFFALSE 82305
// sRocket := true ;
82297: LD_ADDR_EXP 123
82301: PUSH
82302: LD_INT 1
82304: ST_TO_ADDR
// if p3 = 2 then
82305: LD_VAR 0 3
82309: PUSH
82310: LD_INT 2
82312: EQUAL
82313: IFFALSE 82323
// sSpeed := true ;
82315: LD_ADDR_EXP 122
82319: PUSH
82320: LD_INT 1
82322: ST_TO_ADDR
// if p3 = 3 then
82323: LD_VAR 0 3
82327: PUSH
82328: LD_INT 3
82330: EQUAL
82331: IFFALSE 82341
// sEngine := true ;
82333: LD_ADDR_EXP 124
82337: PUSH
82338: LD_INT 1
82340: ST_TO_ADDR
// if p3 = 4 then
82341: LD_VAR 0 3
82345: PUSH
82346: LD_INT 4
82348: EQUAL
82349: IFFALSE 82359
// sSpec := true ;
82351: LD_ADDR_EXP 121
82355: PUSH
82356: LD_INT 1
82358: ST_TO_ADDR
// if p3 = 5 then
82359: LD_VAR 0 3
82363: PUSH
82364: LD_INT 5
82366: EQUAL
82367: IFFALSE 82377
// sLevel := true ;
82369: LD_ADDR_EXP 125
82373: PUSH
82374: LD_INT 1
82376: ST_TO_ADDR
// if p3 = 6 then
82377: LD_VAR 0 3
82381: PUSH
82382: LD_INT 6
82384: EQUAL
82385: IFFALSE 82395
// sArmoury := true ;
82387: LD_ADDR_EXP 126
82391: PUSH
82392: LD_INT 1
82394: ST_TO_ADDR
// if p3 = 7 then
82395: LD_VAR 0 3
82399: PUSH
82400: LD_INT 7
82402: EQUAL
82403: IFFALSE 82413
// sRadar := true ;
82405: LD_ADDR_EXP 127
82409: PUSH
82410: LD_INT 1
82412: ST_TO_ADDR
// if p3 = 8 then
82413: LD_VAR 0 3
82417: PUSH
82418: LD_INT 8
82420: EQUAL
82421: IFFALSE 82431
// sBunker := true ;
82423: LD_ADDR_EXP 128
82427: PUSH
82428: LD_INT 1
82430: ST_TO_ADDR
// if p3 = 9 then
82431: LD_VAR 0 3
82435: PUSH
82436: LD_INT 9
82438: EQUAL
82439: IFFALSE 82449
// sHack := true ;
82441: LD_ADDR_EXP 129
82445: PUSH
82446: LD_INT 1
82448: ST_TO_ADDR
// if p3 = 10 then
82449: LD_VAR 0 3
82453: PUSH
82454: LD_INT 10
82456: EQUAL
82457: IFFALSE 82467
// sFire := true ;
82459: LD_ADDR_EXP 130
82463: PUSH
82464: LD_INT 1
82466: ST_TO_ADDR
// if p3 = 11 then
82467: LD_VAR 0 3
82471: PUSH
82472: LD_INT 11
82474: EQUAL
82475: IFFALSE 82485
// sRefresh := true ;
82477: LD_ADDR_EXP 131
82481: PUSH
82482: LD_INT 1
82484: ST_TO_ADDR
// if p3 = 12 then
82485: LD_VAR 0 3
82489: PUSH
82490: LD_INT 12
82492: EQUAL
82493: IFFALSE 82503
// sExp := true ;
82495: LD_ADDR_EXP 132
82499: PUSH
82500: LD_INT 1
82502: ST_TO_ADDR
// if p3 = 13 then
82503: LD_VAR 0 3
82507: PUSH
82508: LD_INT 13
82510: EQUAL
82511: IFFALSE 82521
// sDepot := true ;
82513: LD_ADDR_EXP 133
82517: PUSH
82518: LD_INT 1
82520: ST_TO_ADDR
// if p3 = 14 then
82521: LD_VAR 0 3
82525: PUSH
82526: LD_INT 14
82528: EQUAL
82529: IFFALSE 82539
// sFlag := true ;
82531: LD_ADDR_EXP 134
82535: PUSH
82536: LD_INT 1
82538: ST_TO_ADDR
// if p3 = 15 then
82539: LD_VAR 0 3
82543: PUSH
82544: LD_INT 15
82546: EQUAL
82547: IFFALSE 82557
// sKamikadze := true ;
82549: LD_ADDR_EXP 142
82553: PUSH
82554: LD_INT 1
82556: ST_TO_ADDR
// if p3 = 16 then
82557: LD_VAR 0 3
82561: PUSH
82562: LD_INT 16
82564: EQUAL
82565: IFFALSE 82575
// sTroll := true ;
82567: LD_ADDR_EXP 143
82571: PUSH
82572: LD_INT 1
82574: ST_TO_ADDR
// if p3 = 17 then
82575: LD_VAR 0 3
82579: PUSH
82580: LD_INT 17
82582: EQUAL
82583: IFFALSE 82593
// sSlow := true ;
82585: LD_ADDR_EXP 144
82589: PUSH
82590: LD_INT 1
82592: ST_TO_ADDR
// if p3 = 18 then
82593: LD_VAR 0 3
82597: PUSH
82598: LD_INT 18
82600: EQUAL
82601: IFFALSE 82611
// sLack := true ;
82603: LD_ADDR_EXP 145
82607: PUSH
82608: LD_INT 1
82610: ST_TO_ADDR
// if p3 = 19 then
82611: LD_VAR 0 3
82615: PUSH
82616: LD_INT 19
82618: EQUAL
82619: IFFALSE 82629
// sTank := true ;
82621: LD_ADDR_EXP 147
82625: PUSH
82626: LD_INT 1
82628: ST_TO_ADDR
// if p3 = 20 then
82629: LD_VAR 0 3
82633: PUSH
82634: LD_INT 20
82636: EQUAL
82637: IFFALSE 82647
// sRemote := true ;
82639: LD_ADDR_EXP 148
82643: PUSH
82644: LD_INT 1
82646: ST_TO_ADDR
// if p3 = 21 then
82647: LD_VAR 0 3
82651: PUSH
82652: LD_INT 21
82654: EQUAL
82655: IFFALSE 82665
// sPowell := true ;
82657: LD_ADDR_EXP 149
82661: PUSH
82662: LD_INT 1
82664: ST_TO_ADDR
// if p3 = 22 then
82665: LD_VAR 0 3
82669: PUSH
82670: LD_INT 22
82672: EQUAL
82673: IFFALSE 82683
// sTeleport := true ;
82675: LD_ADDR_EXP 152
82679: PUSH
82680: LD_INT 1
82682: ST_TO_ADDR
// if p3 = 23 then
82683: LD_VAR 0 3
82687: PUSH
82688: LD_INT 23
82690: EQUAL
82691: IFFALSE 82701
// sOilTower := true ;
82693: LD_ADDR_EXP 154
82697: PUSH
82698: LD_INT 1
82700: ST_TO_ADDR
// if p3 = 24 then
82701: LD_VAR 0 3
82705: PUSH
82706: LD_INT 24
82708: EQUAL
82709: IFFALSE 82719
// sShovel := true ;
82711: LD_ADDR_EXP 155
82715: PUSH
82716: LD_INT 1
82718: ST_TO_ADDR
// if p3 = 25 then
82719: LD_VAR 0 3
82723: PUSH
82724: LD_INT 25
82726: EQUAL
82727: IFFALSE 82737
// sSheik := true ;
82729: LD_ADDR_EXP 156
82733: PUSH
82734: LD_INT 1
82736: ST_TO_ADDR
// if p3 = 26 then
82737: LD_VAR 0 3
82741: PUSH
82742: LD_INT 26
82744: EQUAL
82745: IFFALSE 82755
// sEarthquake := true ;
82747: LD_ADDR_EXP 158
82751: PUSH
82752: LD_INT 1
82754: ST_TO_ADDR
// if p3 = 27 then
82755: LD_VAR 0 3
82759: PUSH
82760: LD_INT 27
82762: EQUAL
82763: IFFALSE 82773
// sAI := true ;
82765: LD_ADDR_EXP 159
82769: PUSH
82770: LD_INT 1
82772: ST_TO_ADDR
// if p3 = 28 then
82773: LD_VAR 0 3
82777: PUSH
82778: LD_INT 28
82780: EQUAL
82781: IFFALSE 82791
// sCargo := true ;
82783: LD_ADDR_EXP 162
82787: PUSH
82788: LD_INT 1
82790: ST_TO_ADDR
// if p3 = 29 then
82791: LD_VAR 0 3
82795: PUSH
82796: LD_INT 29
82798: EQUAL
82799: IFFALSE 82809
// sDLaser := true ;
82801: LD_ADDR_EXP 163
82805: PUSH
82806: LD_INT 1
82808: ST_TO_ADDR
// if p3 = 30 then
82809: LD_VAR 0 3
82813: PUSH
82814: LD_INT 30
82816: EQUAL
82817: IFFALSE 82827
// sExchange := true ;
82819: LD_ADDR_EXP 164
82823: PUSH
82824: LD_INT 1
82826: ST_TO_ADDR
// if p3 = 31 then
82827: LD_VAR 0 3
82831: PUSH
82832: LD_INT 31
82834: EQUAL
82835: IFFALSE 82845
// sFac := true ;
82837: LD_ADDR_EXP 165
82841: PUSH
82842: LD_INT 1
82844: ST_TO_ADDR
// if p3 = 32 then
82845: LD_VAR 0 3
82849: PUSH
82850: LD_INT 32
82852: EQUAL
82853: IFFALSE 82863
// sPower := true ;
82855: LD_ADDR_EXP 166
82859: PUSH
82860: LD_INT 1
82862: ST_TO_ADDR
// if p3 = 33 then
82863: LD_VAR 0 3
82867: PUSH
82868: LD_INT 33
82870: EQUAL
82871: IFFALSE 82881
// sRandom := true ;
82873: LD_ADDR_EXP 167
82877: PUSH
82878: LD_INT 1
82880: ST_TO_ADDR
// if p3 = 34 then
82881: LD_VAR 0 3
82885: PUSH
82886: LD_INT 34
82888: EQUAL
82889: IFFALSE 82899
// sShield := true ;
82891: LD_ADDR_EXP 168
82895: PUSH
82896: LD_INT 1
82898: ST_TO_ADDR
// if p3 = 35 then
82899: LD_VAR 0 3
82903: PUSH
82904: LD_INT 35
82906: EQUAL
82907: IFFALSE 82917
// sTime := true ;
82909: LD_ADDR_EXP 169
82913: PUSH
82914: LD_INT 1
82916: ST_TO_ADDR
// if p3 = 36 then
82917: LD_VAR 0 3
82921: PUSH
82922: LD_INT 36
82924: EQUAL
82925: IFFALSE 82935
// sTools := true ;
82927: LD_ADDR_EXP 170
82931: PUSH
82932: LD_INT 1
82934: ST_TO_ADDR
// if p3 = 101 then
82935: LD_VAR 0 3
82939: PUSH
82940: LD_INT 101
82942: EQUAL
82943: IFFALSE 82953
// sSold := true ;
82945: LD_ADDR_EXP 135
82949: PUSH
82950: LD_INT 1
82952: ST_TO_ADDR
// if p3 = 102 then
82953: LD_VAR 0 3
82957: PUSH
82958: LD_INT 102
82960: EQUAL
82961: IFFALSE 82971
// sDiff := true ;
82963: LD_ADDR_EXP 136
82967: PUSH
82968: LD_INT 1
82970: ST_TO_ADDR
// if p3 = 103 then
82971: LD_VAR 0 3
82975: PUSH
82976: LD_INT 103
82978: EQUAL
82979: IFFALSE 82989
// sFog := true ;
82981: LD_ADDR_EXP 139
82985: PUSH
82986: LD_INT 1
82988: ST_TO_ADDR
// if p3 = 104 then
82989: LD_VAR 0 3
82993: PUSH
82994: LD_INT 104
82996: EQUAL
82997: IFFALSE 83007
// sReset := true ;
82999: LD_ADDR_EXP 140
83003: PUSH
83004: LD_INT 1
83006: ST_TO_ADDR
// if p3 = 105 then
83007: LD_VAR 0 3
83011: PUSH
83012: LD_INT 105
83014: EQUAL
83015: IFFALSE 83025
// sSun := true ;
83017: LD_ADDR_EXP 141
83021: PUSH
83022: LD_INT 1
83024: ST_TO_ADDR
// if p3 = 106 then
83025: LD_VAR 0 3
83029: PUSH
83030: LD_INT 106
83032: EQUAL
83033: IFFALSE 83043
// sTiger := true ;
83035: LD_ADDR_EXP 137
83039: PUSH
83040: LD_INT 1
83042: ST_TO_ADDR
// if p3 = 107 then
83043: LD_VAR 0 3
83047: PUSH
83048: LD_INT 107
83050: EQUAL
83051: IFFALSE 83061
// sBomb := true ;
83053: LD_ADDR_EXP 138
83057: PUSH
83058: LD_INT 1
83060: ST_TO_ADDR
// if p3 = 108 then
83061: LD_VAR 0 3
83065: PUSH
83066: LD_INT 108
83068: EQUAL
83069: IFFALSE 83079
// sWound := true ;
83071: LD_ADDR_EXP 146
83075: PUSH
83076: LD_INT 1
83078: ST_TO_ADDR
// if p3 = 109 then
83079: LD_VAR 0 3
83083: PUSH
83084: LD_INT 109
83086: EQUAL
83087: IFFALSE 83097
// sBetray := true ;
83089: LD_ADDR_EXP 150
83093: PUSH
83094: LD_INT 1
83096: ST_TO_ADDR
// if p3 = 110 then
83097: LD_VAR 0 3
83101: PUSH
83102: LD_INT 110
83104: EQUAL
83105: IFFALSE 83115
// sContamin := true ;
83107: LD_ADDR_EXP 151
83111: PUSH
83112: LD_INT 1
83114: ST_TO_ADDR
// if p3 = 111 then
83115: LD_VAR 0 3
83119: PUSH
83120: LD_INT 111
83122: EQUAL
83123: IFFALSE 83133
// sOil := true ;
83125: LD_ADDR_EXP 153
83129: PUSH
83130: LD_INT 1
83132: ST_TO_ADDR
// if p3 = 112 then
83133: LD_VAR 0 3
83137: PUSH
83138: LD_INT 112
83140: EQUAL
83141: IFFALSE 83151
// sStu := true ;
83143: LD_ADDR_EXP 157
83147: PUSH
83148: LD_INT 1
83150: ST_TO_ADDR
// if p3 = 113 then
83151: LD_VAR 0 3
83155: PUSH
83156: LD_INT 113
83158: EQUAL
83159: IFFALSE 83169
// sBazooka := true ;
83161: LD_ADDR_EXP 160
83165: PUSH
83166: LD_INT 1
83168: ST_TO_ADDR
// if p3 = 114 then
83169: LD_VAR 0 3
83173: PUSH
83174: LD_INT 114
83176: EQUAL
83177: IFFALSE 83187
// sMortar := true ;
83179: LD_ADDR_EXP 161
83183: PUSH
83184: LD_INT 1
83186: ST_TO_ADDR
// if p3 = 115 then
83187: LD_VAR 0 3
83191: PUSH
83192: LD_INT 115
83194: EQUAL
83195: IFFALSE 83205
// sRanger := true ;
83197: LD_ADDR_EXP 171
83201: PUSH
83202: LD_INT 1
83204: ST_TO_ADDR
// end ; if p2 = 101 then
83205: LD_VAR 0 2
83209: PUSH
83210: LD_INT 101
83212: EQUAL
83213: IFFALSE 83341
// begin case p3 of 1 :
83215: LD_VAR 0 3
83219: PUSH
83220: LD_INT 1
83222: DOUBLE
83223: EQUAL
83224: IFTRUE 83228
83226: GO 83235
83228: POP
// hHackUnlimitedResources ; 2 :
83229: CALL 94376 0 0
83233: GO 83341
83235: LD_INT 2
83237: DOUBLE
83238: EQUAL
83239: IFTRUE 83243
83241: GO 83250
83243: POP
// hHackSetLevel10 ; 3 :
83244: CALL 94509 0 0
83248: GO 83341
83250: LD_INT 3
83252: DOUBLE
83253: EQUAL
83254: IFTRUE 83258
83256: GO 83265
83258: POP
// hHackSetLevel10YourUnits ; 4 :
83259: CALL 94594 0 0
83263: GO 83341
83265: LD_INT 4
83267: DOUBLE
83268: EQUAL
83269: IFTRUE 83273
83271: GO 83280
83273: POP
// hHackInvincible ; 5 :
83274: CALL 95042 0 0
83278: GO 83341
83280: LD_INT 5
83282: DOUBLE
83283: EQUAL
83284: IFTRUE 83288
83286: GO 83295
83288: POP
// hHackInvisible ; 6 :
83289: CALL 95153 0 0
83293: GO 83341
83295: LD_INT 6
83297: DOUBLE
83298: EQUAL
83299: IFTRUE 83303
83301: GO 83310
83303: POP
// hHackChangeYourSide ; 7 :
83304: CALL 95210 0 0
83308: GO 83341
83310: LD_INT 7
83312: DOUBLE
83313: EQUAL
83314: IFTRUE 83318
83316: GO 83325
83318: POP
// hHackChangeUnitSide ; 8 :
83319: CALL 95252 0 0
83323: GO 83341
83325: LD_INT 8
83327: DOUBLE
83328: EQUAL
83329: IFTRUE 83333
83331: GO 83340
83333: POP
// hHackFog ; end ;
83334: CALL 95353 0 0
83338: GO 83341
83340: POP
// end ; end ;
83341: PPOPN 6
83343: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83344: GO 83346
83346: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83347: LD_STRING initStreamRollete();
83349: PPUSH
83350: CALL_OW 559
// InitStreamMode ;
83354: CALL 83363 0 0
// DefineStreamItems ( ) ;
83358: CALL 83803 0 0
// end ;
83362: END
// function InitStreamMode ; begin
83363: LD_INT 0
83365: PPUSH
// streamModeActive := false ;
83366: LD_ADDR_EXP 118
83370: PUSH
83371: LD_INT 0
83373: ST_TO_ADDR
// normalCounter := 36 ;
83374: LD_ADDR_EXP 119
83378: PUSH
83379: LD_INT 36
83381: ST_TO_ADDR
// hardcoreCounter := 16 ;
83382: LD_ADDR_EXP 120
83386: PUSH
83387: LD_INT 16
83389: ST_TO_ADDR
// sRocket := false ;
83390: LD_ADDR_EXP 123
83394: PUSH
83395: LD_INT 0
83397: ST_TO_ADDR
// sSpeed := false ;
83398: LD_ADDR_EXP 122
83402: PUSH
83403: LD_INT 0
83405: ST_TO_ADDR
// sEngine := false ;
83406: LD_ADDR_EXP 124
83410: PUSH
83411: LD_INT 0
83413: ST_TO_ADDR
// sSpec := false ;
83414: LD_ADDR_EXP 121
83418: PUSH
83419: LD_INT 0
83421: ST_TO_ADDR
// sLevel := false ;
83422: LD_ADDR_EXP 125
83426: PUSH
83427: LD_INT 0
83429: ST_TO_ADDR
// sArmoury := false ;
83430: LD_ADDR_EXP 126
83434: PUSH
83435: LD_INT 0
83437: ST_TO_ADDR
// sRadar := false ;
83438: LD_ADDR_EXP 127
83442: PUSH
83443: LD_INT 0
83445: ST_TO_ADDR
// sBunker := false ;
83446: LD_ADDR_EXP 128
83450: PUSH
83451: LD_INT 0
83453: ST_TO_ADDR
// sHack := false ;
83454: LD_ADDR_EXP 129
83458: PUSH
83459: LD_INT 0
83461: ST_TO_ADDR
// sFire := false ;
83462: LD_ADDR_EXP 130
83466: PUSH
83467: LD_INT 0
83469: ST_TO_ADDR
// sRefresh := false ;
83470: LD_ADDR_EXP 131
83474: PUSH
83475: LD_INT 0
83477: ST_TO_ADDR
// sExp := false ;
83478: LD_ADDR_EXP 132
83482: PUSH
83483: LD_INT 0
83485: ST_TO_ADDR
// sDepot := false ;
83486: LD_ADDR_EXP 133
83490: PUSH
83491: LD_INT 0
83493: ST_TO_ADDR
// sFlag := false ;
83494: LD_ADDR_EXP 134
83498: PUSH
83499: LD_INT 0
83501: ST_TO_ADDR
// sKamikadze := false ;
83502: LD_ADDR_EXP 142
83506: PUSH
83507: LD_INT 0
83509: ST_TO_ADDR
// sTroll := false ;
83510: LD_ADDR_EXP 143
83514: PUSH
83515: LD_INT 0
83517: ST_TO_ADDR
// sSlow := false ;
83518: LD_ADDR_EXP 144
83522: PUSH
83523: LD_INT 0
83525: ST_TO_ADDR
// sLack := false ;
83526: LD_ADDR_EXP 145
83530: PUSH
83531: LD_INT 0
83533: ST_TO_ADDR
// sTank := false ;
83534: LD_ADDR_EXP 147
83538: PUSH
83539: LD_INT 0
83541: ST_TO_ADDR
// sRemote := false ;
83542: LD_ADDR_EXP 148
83546: PUSH
83547: LD_INT 0
83549: ST_TO_ADDR
// sPowell := false ;
83550: LD_ADDR_EXP 149
83554: PUSH
83555: LD_INT 0
83557: ST_TO_ADDR
// sTeleport := false ;
83558: LD_ADDR_EXP 152
83562: PUSH
83563: LD_INT 0
83565: ST_TO_ADDR
// sOilTower := false ;
83566: LD_ADDR_EXP 154
83570: PUSH
83571: LD_INT 0
83573: ST_TO_ADDR
// sShovel := false ;
83574: LD_ADDR_EXP 155
83578: PUSH
83579: LD_INT 0
83581: ST_TO_ADDR
// sSheik := false ;
83582: LD_ADDR_EXP 156
83586: PUSH
83587: LD_INT 0
83589: ST_TO_ADDR
// sEarthquake := false ;
83590: LD_ADDR_EXP 158
83594: PUSH
83595: LD_INT 0
83597: ST_TO_ADDR
// sAI := false ;
83598: LD_ADDR_EXP 159
83602: PUSH
83603: LD_INT 0
83605: ST_TO_ADDR
// sCargo := false ;
83606: LD_ADDR_EXP 162
83610: PUSH
83611: LD_INT 0
83613: ST_TO_ADDR
// sDLaser := false ;
83614: LD_ADDR_EXP 163
83618: PUSH
83619: LD_INT 0
83621: ST_TO_ADDR
// sExchange := false ;
83622: LD_ADDR_EXP 164
83626: PUSH
83627: LD_INT 0
83629: ST_TO_ADDR
// sFac := false ;
83630: LD_ADDR_EXP 165
83634: PUSH
83635: LD_INT 0
83637: ST_TO_ADDR
// sPower := false ;
83638: LD_ADDR_EXP 166
83642: PUSH
83643: LD_INT 0
83645: ST_TO_ADDR
// sRandom := false ;
83646: LD_ADDR_EXP 167
83650: PUSH
83651: LD_INT 0
83653: ST_TO_ADDR
// sShield := false ;
83654: LD_ADDR_EXP 168
83658: PUSH
83659: LD_INT 0
83661: ST_TO_ADDR
// sTime := false ;
83662: LD_ADDR_EXP 169
83666: PUSH
83667: LD_INT 0
83669: ST_TO_ADDR
// sTools := false ;
83670: LD_ADDR_EXP 170
83674: PUSH
83675: LD_INT 0
83677: ST_TO_ADDR
// sSold := false ;
83678: LD_ADDR_EXP 135
83682: PUSH
83683: LD_INT 0
83685: ST_TO_ADDR
// sDiff := false ;
83686: LD_ADDR_EXP 136
83690: PUSH
83691: LD_INT 0
83693: ST_TO_ADDR
// sFog := false ;
83694: LD_ADDR_EXP 139
83698: PUSH
83699: LD_INT 0
83701: ST_TO_ADDR
// sReset := false ;
83702: LD_ADDR_EXP 140
83706: PUSH
83707: LD_INT 0
83709: ST_TO_ADDR
// sSun := false ;
83710: LD_ADDR_EXP 141
83714: PUSH
83715: LD_INT 0
83717: ST_TO_ADDR
// sTiger := false ;
83718: LD_ADDR_EXP 137
83722: PUSH
83723: LD_INT 0
83725: ST_TO_ADDR
// sBomb := false ;
83726: LD_ADDR_EXP 138
83730: PUSH
83731: LD_INT 0
83733: ST_TO_ADDR
// sWound := false ;
83734: LD_ADDR_EXP 146
83738: PUSH
83739: LD_INT 0
83741: ST_TO_ADDR
// sBetray := false ;
83742: LD_ADDR_EXP 150
83746: PUSH
83747: LD_INT 0
83749: ST_TO_ADDR
// sContamin := false ;
83750: LD_ADDR_EXP 151
83754: PUSH
83755: LD_INT 0
83757: ST_TO_ADDR
// sOil := false ;
83758: LD_ADDR_EXP 153
83762: PUSH
83763: LD_INT 0
83765: ST_TO_ADDR
// sStu := false ;
83766: LD_ADDR_EXP 157
83770: PUSH
83771: LD_INT 0
83773: ST_TO_ADDR
// sBazooka := false ;
83774: LD_ADDR_EXP 160
83778: PUSH
83779: LD_INT 0
83781: ST_TO_ADDR
// sMortar := false ;
83782: LD_ADDR_EXP 161
83786: PUSH
83787: LD_INT 0
83789: ST_TO_ADDR
// sRanger := false ;
83790: LD_ADDR_EXP 171
83794: PUSH
83795: LD_INT 0
83797: ST_TO_ADDR
// end ;
83798: LD_VAR 0 1
83802: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83803: LD_INT 0
83805: PPUSH
83806: PPUSH
83807: PPUSH
83808: PPUSH
83809: PPUSH
// result := [ ] ;
83810: LD_ADDR_VAR 0 1
83814: PUSH
83815: EMPTY
83816: ST_TO_ADDR
// if campaign_id = 1 then
83817: LD_OWVAR 69
83821: PUSH
83822: LD_INT 1
83824: EQUAL
83825: IFFALSE 86763
// begin case mission_number of 1 :
83827: LD_OWVAR 70
83831: PUSH
83832: LD_INT 1
83834: DOUBLE
83835: EQUAL
83836: IFTRUE 83840
83838: GO 83904
83840: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
83841: LD_ADDR_VAR 0 1
83845: PUSH
83846: LD_INT 2
83848: PUSH
83849: LD_INT 4
83851: PUSH
83852: LD_INT 11
83854: PUSH
83855: LD_INT 12
83857: PUSH
83858: LD_INT 15
83860: PUSH
83861: LD_INT 16
83863: PUSH
83864: LD_INT 22
83866: PUSH
83867: LD_INT 23
83869: PUSH
83870: LD_INT 26
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 101
83886: PUSH
83887: LD_INT 102
83889: PUSH
83890: LD_INT 106
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: LIST
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: ST_TO_ADDR
83902: GO 86761
83904: LD_INT 2
83906: DOUBLE
83907: EQUAL
83908: IFTRUE 83912
83910: GO 83984
83912: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
83913: LD_ADDR_VAR 0 1
83917: PUSH
83918: LD_INT 2
83920: PUSH
83921: LD_INT 4
83923: PUSH
83924: LD_INT 11
83926: PUSH
83927: LD_INT 12
83929: PUSH
83930: LD_INT 15
83932: PUSH
83933: LD_INT 16
83935: PUSH
83936: LD_INT 22
83938: PUSH
83939: LD_INT 23
83941: PUSH
83942: LD_INT 26
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 101
83958: PUSH
83959: LD_INT 102
83961: PUSH
83962: LD_INT 105
83964: PUSH
83965: LD_INT 106
83967: PUSH
83968: LD_INT 108
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: ST_TO_ADDR
83982: GO 86761
83984: LD_INT 3
83986: DOUBLE
83987: EQUAL
83988: IFTRUE 83992
83990: GO 84068
83992: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83993: LD_ADDR_VAR 0 1
83997: PUSH
83998: LD_INT 2
84000: PUSH
84001: LD_INT 4
84003: PUSH
84004: LD_INT 5
84006: PUSH
84007: LD_INT 11
84009: PUSH
84010: LD_INT 12
84012: PUSH
84013: LD_INT 15
84015: PUSH
84016: LD_INT 16
84018: PUSH
84019: LD_INT 22
84021: PUSH
84022: LD_INT 26
84024: PUSH
84025: LD_INT 36
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 101
84042: PUSH
84043: LD_INT 102
84045: PUSH
84046: LD_INT 105
84048: PUSH
84049: LD_INT 106
84051: PUSH
84052: LD_INT 108
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: ST_TO_ADDR
84066: GO 86761
84068: LD_INT 4
84070: DOUBLE
84071: EQUAL
84072: IFTRUE 84076
84074: GO 84160
84076: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84077: LD_ADDR_VAR 0 1
84081: PUSH
84082: LD_INT 2
84084: PUSH
84085: LD_INT 4
84087: PUSH
84088: LD_INT 5
84090: PUSH
84091: LD_INT 8
84093: PUSH
84094: LD_INT 11
84096: PUSH
84097: LD_INT 12
84099: PUSH
84100: LD_INT 15
84102: PUSH
84103: LD_INT 16
84105: PUSH
84106: LD_INT 22
84108: PUSH
84109: LD_INT 23
84111: PUSH
84112: LD_INT 26
84114: PUSH
84115: LD_INT 36
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 101
84134: PUSH
84135: LD_INT 102
84137: PUSH
84138: LD_INT 105
84140: PUSH
84141: LD_INT 106
84143: PUSH
84144: LD_INT 108
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: ST_TO_ADDR
84158: GO 86761
84160: LD_INT 5
84162: DOUBLE
84163: EQUAL
84164: IFTRUE 84168
84166: GO 84268
84168: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84169: LD_ADDR_VAR 0 1
84173: PUSH
84174: LD_INT 2
84176: PUSH
84177: LD_INT 4
84179: PUSH
84180: LD_INT 5
84182: PUSH
84183: LD_INT 6
84185: PUSH
84186: LD_INT 8
84188: PUSH
84189: LD_INT 11
84191: PUSH
84192: LD_INT 12
84194: PUSH
84195: LD_INT 15
84197: PUSH
84198: LD_INT 16
84200: PUSH
84201: LD_INT 22
84203: PUSH
84204: LD_INT 23
84206: PUSH
84207: LD_INT 25
84209: PUSH
84210: LD_INT 26
84212: PUSH
84213: LD_INT 36
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 101
84234: PUSH
84235: LD_INT 102
84237: PUSH
84238: LD_INT 105
84240: PUSH
84241: LD_INT 106
84243: PUSH
84244: LD_INT 108
84246: PUSH
84247: LD_INT 109
84249: PUSH
84250: LD_INT 112
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: LIST
84257: LIST
84258: LIST
84259: LIST
84260: LIST
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: ST_TO_ADDR
84266: GO 86761
84268: LD_INT 6
84270: DOUBLE
84271: EQUAL
84272: IFTRUE 84276
84274: GO 84396
84276: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84277: LD_ADDR_VAR 0 1
84281: PUSH
84282: LD_INT 2
84284: PUSH
84285: LD_INT 4
84287: PUSH
84288: LD_INT 5
84290: PUSH
84291: LD_INT 6
84293: PUSH
84294: LD_INT 8
84296: PUSH
84297: LD_INT 11
84299: PUSH
84300: LD_INT 12
84302: PUSH
84303: LD_INT 15
84305: PUSH
84306: LD_INT 16
84308: PUSH
84309: LD_INT 20
84311: PUSH
84312: LD_INT 21
84314: PUSH
84315: LD_INT 22
84317: PUSH
84318: LD_INT 23
84320: PUSH
84321: LD_INT 25
84323: PUSH
84324: LD_INT 26
84326: PUSH
84327: LD_INT 30
84329: PUSH
84330: LD_INT 31
84332: PUSH
84333: LD_INT 32
84335: PUSH
84336: LD_INT 36
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: LIST
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 101
84362: PUSH
84363: LD_INT 102
84365: PUSH
84366: LD_INT 105
84368: PUSH
84369: LD_INT 106
84371: PUSH
84372: LD_INT 108
84374: PUSH
84375: LD_INT 109
84377: PUSH
84378: LD_INT 112
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: ST_TO_ADDR
84394: GO 86761
84396: LD_INT 7
84398: DOUBLE
84399: EQUAL
84400: IFTRUE 84404
84402: GO 84504
84404: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84405: LD_ADDR_VAR 0 1
84409: PUSH
84410: LD_INT 2
84412: PUSH
84413: LD_INT 4
84415: PUSH
84416: LD_INT 5
84418: PUSH
84419: LD_INT 7
84421: PUSH
84422: LD_INT 11
84424: PUSH
84425: LD_INT 12
84427: PUSH
84428: LD_INT 15
84430: PUSH
84431: LD_INT 16
84433: PUSH
84434: LD_INT 20
84436: PUSH
84437: LD_INT 21
84439: PUSH
84440: LD_INT 22
84442: PUSH
84443: LD_INT 23
84445: PUSH
84446: LD_INT 25
84448: PUSH
84449: LD_INT 26
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 101
84470: PUSH
84471: LD_INT 102
84473: PUSH
84474: LD_INT 103
84476: PUSH
84477: LD_INT 105
84479: PUSH
84480: LD_INT 106
84482: PUSH
84483: LD_INT 108
84485: PUSH
84486: LD_INT 112
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: ST_TO_ADDR
84502: GO 86761
84504: LD_INT 8
84506: DOUBLE
84507: EQUAL
84508: IFTRUE 84512
84510: GO 84640
84512: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
84513: LD_ADDR_VAR 0 1
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: LD_INT 4
84523: PUSH
84524: LD_INT 5
84526: PUSH
84527: LD_INT 6
84529: PUSH
84530: LD_INT 7
84532: PUSH
84533: LD_INT 8
84535: PUSH
84536: LD_INT 11
84538: PUSH
84539: LD_INT 12
84541: PUSH
84542: LD_INT 15
84544: PUSH
84545: LD_INT 16
84547: PUSH
84548: LD_INT 20
84550: PUSH
84551: LD_INT 21
84553: PUSH
84554: LD_INT 22
84556: PUSH
84557: LD_INT 23
84559: PUSH
84560: LD_INT 25
84562: PUSH
84563: LD_INT 26
84565: PUSH
84566: LD_INT 30
84568: PUSH
84569: LD_INT 31
84571: PUSH
84572: LD_INT 32
84574: PUSH
84575: LD_INT 36
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 101
84602: PUSH
84603: LD_INT 102
84605: PUSH
84606: LD_INT 103
84608: PUSH
84609: LD_INT 105
84611: PUSH
84612: LD_INT 106
84614: PUSH
84615: LD_INT 108
84617: PUSH
84618: LD_INT 109
84620: PUSH
84621: LD_INT 112
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: LIST
84628: LIST
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: ST_TO_ADDR
84638: GO 86761
84640: LD_INT 9
84642: DOUBLE
84643: EQUAL
84644: IFTRUE 84648
84646: GO 84784
84648: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
84649: LD_ADDR_VAR 0 1
84653: PUSH
84654: LD_INT 2
84656: PUSH
84657: LD_INT 4
84659: PUSH
84660: LD_INT 5
84662: PUSH
84663: LD_INT 6
84665: PUSH
84666: LD_INT 7
84668: PUSH
84669: LD_INT 8
84671: PUSH
84672: LD_INT 11
84674: PUSH
84675: LD_INT 12
84677: PUSH
84678: LD_INT 15
84680: PUSH
84681: LD_INT 16
84683: PUSH
84684: LD_INT 20
84686: PUSH
84687: LD_INT 21
84689: PUSH
84690: LD_INT 22
84692: PUSH
84693: LD_INT 23
84695: PUSH
84696: LD_INT 25
84698: PUSH
84699: LD_INT 26
84701: PUSH
84702: LD_INT 28
84704: PUSH
84705: LD_INT 30
84707: PUSH
84708: LD_INT 31
84710: PUSH
84711: LD_INT 32
84713: PUSH
84714: LD_INT 36
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 101
84742: PUSH
84743: LD_INT 102
84745: PUSH
84746: LD_INT 103
84748: PUSH
84749: LD_INT 105
84751: PUSH
84752: LD_INT 106
84754: PUSH
84755: LD_INT 108
84757: PUSH
84758: LD_INT 109
84760: PUSH
84761: LD_INT 112
84763: PUSH
84764: LD_INT 114
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: ST_TO_ADDR
84782: GO 86761
84784: LD_INT 10
84786: DOUBLE
84787: EQUAL
84788: IFTRUE 84792
84790: GO 84976
84792: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84793: LD_ADDR_VAR 0 1
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: LD_INT 4
84803: PUSH
84804: LD_INT 5
84806: PUSH
84807: LD_INT 6
84809: PUSH
84810: LD_INT 7
84812: PUSH
84813: LD_INT 8
84815: PUSH
84816: LD_INT 9
84818: PUSH
84819: LD_INT 10
84821: PUSH
84822: LD_INT 11
84824: PUSH
84825: LD_INT 12
84827: PUSH
84828: LD_INT 13
84830: PUSH
84831: LD_INT 14
84833: PUSH
84834: LD_INT 15
84836: PUSH
84837: LD_INT 16
84839: PUSH
84840: LD_INT 17
84842: PUSH
84843: LD_INT 18
84845: PUSH
84846: LD_INT 19
84848: PUSH
84849: LD_INT 20
84851: PUSH
84852: LD_INT 21
84854: PUSH
84855: LD_INT 22
84857: PUSH
84858: LD_INT 23
84860: PUSH
84861: LD_INT 24
84863: PUSH
84864: LD_INT 25
84866: PUSH
84867: LD_INT 26
84869: PUSH
84870: LD_INT 28
84872: PUSH
84873: LD_INT 30
84875: PUSH
84876: LD_INT 31
84878: PUSH
84879: LD_INT 32
84881: PUSH
84882: LD_INT 36
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: LIST
84904: LIST
84905: LIST
84906: LIST
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 101
84918: PUSH
84919: LD_INT 102
84921: PUSH
84922: LD_INT 103
84924: PUSH
84925: LD_INT 104
84927: PUSH
84928: LD_INT 105
84930: PUSH
84931: LD_INT 106
84933: PUSH
84934: LD_INT 107
84936: PUSH
84937: LD_INT 108
84939: PUSH
84940: LD_INT 109
84942: PUSH
84943: LD_INT 110
84945: PUSH
84946: LD_INT 111
84948: PUSH
84949: LD_INT 112
84951: PUSH
84952: LD_INT 114
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: ST_TO_ADDR
84974: GO 86761
84976: LD_INT 11
84978: DOUBLE
84979: EQUAL
84980: IFTRUE 84984
84982: GO 85176
84984: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84985: LD_ADDR_VAR 0 1
84989: PUSH
84990: LD_INT 2
84992: PUSH
84993: LD_INT 3
84995: PUSH
84996: LD_INT 4
84998: PUSH
84999: LD_INT 5
85001: PUSH
85002: LD_INT 6
85004: PUSH
85005: LD_INT 7
85007: PUSH
85008: LD_INT 8
85010: PUSH
85011: LD_INT 9
85013: PUSH
85014: LD_INT 10
85016: PUSH
85017: LD_INT 11
85019: PUSH
85020: LD_INT 12
85022: PUSH
85023: LD_INT 13
85025: PUSH
85026: LD_INT 14
85028: PUSH
85029: LD_INT 15
85031: PUSH
85032: LD_INT 16
85034: PUSH
85035: LD_INT 17
85037: PUSH
85038: LD_INT 18
85040: PUSH
85041: LD_INT 19
85043: PUSH
85044: LD_INT 20
85046: PUSH
85047: LD_INT 21
85049: PUSH
85050: LD_INT 22
85052: PUSH
85053: LD_INT 23
85055: PUSH
85056: LD_INT 24
85058: PUSH
85059: LD_INT 25
85061: PUSH
85062: LD_INT 26
85064: PUSH
85065: LD_INT 28
85067: PUSH
85068: LD_INT 30
85070: PUSH
85071: LD_INT 31
85073: PUSH
85074: LD_INT 32
85076: PUSH
85077: LD_INT 34
85079: PUSH
85080: LD_INT 36
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 101
85118: PUSH
85119: LD_INT 102
85121: PUSH
85122: LD_INT 103
85124: PUSH
85125: LD_INT 104
85127: PUSH
85128: LD_INT 105
85130: PUSH
85131: LD_INT 106
85133: PUSH
85134: LD_INT 107
85136: PUSH
85137: LD_INT 108
85139: PUSH
85140: LD_INT 109
85142: PUSH
85143: LD_INT 110
85145: PUSH
85146: LD_INT 111
85148: PUSH
85149: LD_INT 112
85151: PUSH
85152: LD_INT 114
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: ST_TO_ADDR
85174: GO 86761
85176: LD_INT 12
85178: DOUBLE
85179: EQUAL
85180: IFTRUE 85184
85182: GO 85392
85184: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85185: LD_ADDR_VAR 0 1
85189: PUSH
85190: LD_INT 1
85192: PUSH
85193: LD_INT 2
85195: PUSH
85196: LD_INT 3
85198: PUSH
85199: LD_INT 4
85201: PUSH
85202: LD_INT 5
85204: PUSH
85205: LD_INT 6
85207: PUSH
85208: LD_INT 7
85210: PUSH
85211: LD_INT 8
85213: PUSH
85214: LD_INT 9
85216: PUSH
85217: LD_INT 10
85219: PUSH
85220: LD_INT 11
85222: PUSH
85223: LD_INT 12
85225: PUSH
85226: LD_INT 13
85228: PUSH
85229: LD_INT 14
85231: PUSH
85232: LD_INT 15
85234: PUSH
85235: LD_INT 16
85237: PUSH
85238: LD_INT 17
85240: PUSH
85241: LD_INT 18
85243: PUSH
85244: LD_INT 19
85246: PUSH
85247: LD_INT 20
85249: PUSH
85250: LD_INT 21
85252: PUSH
85253: LD_INT 22
85255: PUSH
85256: LD_INT 23
85258: PUSH
85259: LD_INT 24
85261: PUSH
85262: LD_INT 25
85264: PUSH
85265: LD_INT 26
85267: PUSH
85268: LD_INT 27
85270: PUSH
85271: LD_INT 28
85273: PUSH
85274: LD_INT 30
85276: PUSH
85277: LD_INT 31
85279: PUSH
85280: LD_INT 32
85282: PUSH
85283: LD_INT 33
85285: PUSH
85286: LD_INT 34
85288: PUSH
85289: LD_INT 36
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 101
85330: PUSH
85331: LD_INT 102
85333: PUSH
85334: LD_INT 103
85336: PUSH
85337: LD_INT 104
85339: PUSH
85340: LD_INT 105
85342: PUSH
85343: LD_INT 106
85345: PUSH
85346: LD_INT 107
85348: PUSH
85349: LD_INT 108
85351: PUSH
85352: LD_INT 109
85354: PUSH
85355: LD_INT 110
85357: PUSH
85358: LD_INT 111
85360: PUSH
85361: LD_INT 112
85363: PUSH
85364: LD_INT 113
85366: PUSH
85367: LD_INT 114
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: ST_TO_ADDR
85390: GO 86761
85392: LD_INT 13
85394: DOUBLE
85395: EQUAL
85396: IFTRUE 85400
85398: GO 85596
85400: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85401: LD_ADDR_VAR 0 1
85405: PUSH
85406: LD_INT 1
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: LD_INT 3
85414: PUSH
85415: LD_INT 4
85417: PUSH
85418: LD_INT 5
85420: PUSH
85421: LD_INT 8
85423: PUSH
85424: LD_INT 9
85426: PUSH
85427: LD_INT 10
85429: PUSH
85430: LD_INT 11
85432: PUSH
85433: LD_INT 12
85435: PUSH
85436: LD_INT 14
85438: PUSH
85439: LD_INT 15
85441: PUSH
85442: LD_INT 16
85444: PUSH
85445: LD_INT 17
85447: PUSH
85448: LD_INT 18
85450: PUSH
85451: LD_INT 19
85453: PUSH
85454: LD_INT 20
85456: PUSH
85457: LD_INT 21
85459: PUSH
85460: LD_INT 22
85462: PUSH
85463: LD_INT 23
85465: PUSH
85466: LD_INT 24
85468: PUSH
85469: LD_INT 25
85471: PUSH
85472: LD_INT 26
85474: PUSH
85475: LD_INT 27
85477: PUSH
85478: LD_INT 28
85480: PUSH
85481: LD_INT 30
85483: PUSH
85484: LD_INT 31
85486: PUSH
85487: LD_INT 32
85489: PUSH
85490: LD_INT 33
85492: PUSH
85493: LD_INT 34
85495: PUSH
85496: LD_INT 36
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 101
85534: PUSH
85535: LD_INT 102
85537: PUSH
85538: LD_INT 103
85540: PUSH
85541: LD_INT 104
85543: PUSH
85544: LD_INT 105
85546: PUSH
85547: LD_INT 106
85549: PUSH
85550: LD_INT 107
85552: PUSH
85553: LD_INT 108
85555: PUSH
85556: LD_INT 109
85558: PUSH
85559: LD_INT 110
85561: PUSH
85562: LD_INT 111
85564: PUSH
85565: LD_INT 112
85567: PUSH
85568: LD_INT 113
85570: PUSH
85571: LD_INT 114
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: ST_TO_ADDR
85594: GO 86761
85596: LD_INT 14
85598: DOUBLE
85599: EQUAL
85600: IFTRUE 85604
85602: GO 85816
85604: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
85605: LD_ADDR_VAR 0 1
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: LD_INT 3
85618: PUSH
85619: LD_INT 4
85621: PUSH
85622: LD_INT 5
85624: PUSH
85625: LD_INT 6
85627: PUSH
85628: LD_INT 7
85630: PUSH
85631: LD_INT 8
85633: PUSH
85634: LD_INT 9
85636: PUSH
85637: LD_INT 10
85639: PUSH
85640: LD_INT 11
85642: PUSH
85643: LD_INT 12
85645: PUSH
85646: LD_INT 13
85648: PUSH
85649: LD_INT 14
85651: PUSH
85652: LD_INT 15
85654: PUSH
85655: LD_INT 16
85657: PUSH
85658: LD_INT 17
85660: PUSH
85661: LD_INT 18
85663: PUSH
85664: LD_INT 19
85666: PUSH
85667: LD_INT 20
85669: PUSH
85670: LD_INT 21
85672: PUSH
85673: LD_INT 22
85675: PUSH
85676: LD_INT 23
85678: PUSH
85679: LD_INT 24
85681: PUSH
85682: LD_INT 25
85684: PUSH
85685: LD_INT 26
85687: PUSH
85688: LD_INT 27
85690: PUSH
85691: LD_INT 28
85693: PUSH
85694: LD_INT 29
85696: PUSH
85697: LD_INT 30
85699: PUSH
85700: LD_INT 31
85702: PUSH
85703: LD_INT 32
85705: PUSH
85706: LD_INT 33
85708: PUSH
85709: LD_INT 34
85711: PUSH
85712: LD_INT 36
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 101
85754: PUSH
85755: LD_INT 102
85757: PUSH
85758: LD_INT 103
85760: PUSH
85761: LD_INT 104
85763: PUSH
85764: LD_INT 105
85766: PUSH
85767: LD_INT 106
85769: PUSH
85770: LD_INT 107
85772: PUSH
85773: LD_INT 108
85775: PUSH
85776: LD_INT 109
85778: PUSH
85779: LD_INT 110
85781: PUSH
85782: LD_INT 111
85784: PUSH
85785: LD_INT 112
85787: PUSH
85788: LD_INT 113
85790: PUSH
85791: LD_INT 114
85793: PUSH
85794: EMPTY
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: ST_TO_ADDR
85814: GO 86761
85816: LD_INT 15
85818: DOUBLE
85819: EQUAL
85820: IFTRUE 85824
85822: GO 86036
85824: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
85825: LD_ADDR_VAR 0 1
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: LD_INT 2
85835: PUSH
85836: LD_INT 3
85838: PUSH
85839: LD_INT 4
85841: PUSH
85842: LD_INT 5
85844: PUSH
85845: LD_INT 6
85847: PUSH
85848: LD_INT 7
85850: PUSH
85851: LD_INT 8
85853: PUSH
85854: LD_INT 9
85856: PUSH
85857: LD_INT 10
85859: PUSH
85860: LD_INT 11
85862: PUSH
85863: LD_INT 12
85865: PUSH
85866: LD_INT 13
85868: PUSH
85869: LD_INT 14
85871: PUSH
85872: LD_INT 15
85874: PUSH
85875: LD_INT 16
85877: PUSH
85878: LD_INT 17
85880: PUSH
85881: LD_INT 18
85883: PUSH
85884: LD_INT 19
85886: PUSH
85887: LD_INT 20
85889: PUSH
85890: LD_INT 21
85892: PUSH
85893: LD_INT 22
85895: PUSH
85896: LD_INT 23
85898: PUSH
85899: LD_INT 24
85901: PUSH
85902: LD_INT 25
85904: PUSH
85905: LD_INT 26
85907: PUSH
85908: LD_INT 27
85910: PUSH
85911: LD_INT 28
85913: PUSH
85914: LD_INT 29
85916: PUSH
85917: LD_INT 30
85919: PUSH
85920: LD_INT 31
85922: PUSH
85923: LD_INT 32
85925: PUSH
85926: LD_INT 33
85928: PUSH
85929: LD_INT 34
85931: PUSH
85932: LD_INT 36
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 101
85974: PUSH
85975: LD_INT 102
85977: PUSH
85978: LD_INT 103
85980: PUSH
85981: LD_INT 104
85983: PUSH
85984: LD_INT 105
85986: PUSH
85987: LD_INT 106
85989: PUSH
85990: LD_INT 107
85992: PUSH
85993: LD_INT 108
85995: PUSH
85996: LD_INT 109
85998: PUSH
85999: LD_INT 110
86001: PUSH
86002: LD_INT 111
86004: PUSH
86005: LD_INT 112
86007: PUSH
86008: LD_INT 113
86010: PUSH
86011: LD_INT 114
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: ST_TO_ADDR
86034: GO 86761
86036: LD_INT 16
86038: DOUBLE
86039: EQUAL
86040: IFTRUE 86044
86042: GO 86168
86044: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86045: LD_ADDR_VAR 0 1
86049: PUSH
86050: LD_INT 2
86052: PUSH
86053: LD_INT 4
86055: PUSH
86056: LD_INT 5
86058: PUSH
86059: LD_INT 7
86061: PUSH
86062: LD_INT 11
86064: PUSH
86065: LD_INT 12
86067: PUSH
86068: LD_INT 15
86070: PUSH
86071: LD_INT 16
86073: PUSH
86074: LD_INT 20
86076: PUSH
86077: LD_INT 21
86079: PUSH
86080: LD_INT 22
86082: PUSH
86083: LD_INT 23
86085: PUSH
86086: LD_INT 25
86088: PUSH
86089: LD_INT 26
86091: PUSH
86092: LD_INT 30
86094: PUSH
86095: LD_INT 31
86097: PUSH
86098: LD_INT 32
86100: PUSH
86101: LD_INT 33
86103: PUSH
86104: LD_INT 34
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 101
86130: PUSH
86131: LD_INT 102
86133: PUSH
86134: LD_INT 103
86136: PUSH
86137: LD_INT 106
86139: PUSH
86140: LD_INT 108
86142: PUSH
86143: LD_INT 112
86145: PUSH
86146: LD_INT 113
86148: PUSH
86149: LD_INT 114
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: ST_TO_ADDR
86166: GO 86761
86168: LD_INT 17
86170: DOUBLE
86171: EQUAL
86172: IFTRUE 86176
86174: GO 86388
86176: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86177: LD_ADDR_VAR 0 1
86181: PUSH
86182: LD_INT 1
86184: PUSH
86185: LD_INT 2
86187: PUSH
86188: LD_INT 3
86190: PUSH
86191: LD_INT 4
86193: PUSH
86194: LD_INT 5
86196: PUSH
86197: LD_INT 6
86199: PUSH
86200: LD_INT 7
86202: PUSH
86203: LD_INT 8
86205: PUSH
86206: LD_INT 9
86208: PUSH
86209: LD_INT 10
86211: PUSH
86212: LD_INT 11
86214: PUSH
86215: LD_INT 12
86217: PUSH
86218: LD_INT 13
86220: PUSH
86221: LD_INT 14
86223: PUSH
86224: LD_INT 15
86226: PUSH
86227: LD_INT 16
86229: PUSH
86230: LD_INT 17
86232: PUSH
86233: LD_INT 18
86235: PUSH
86236: LD_INT 19
86238: PUSH
86239: LD_INT 20
86241: PUSH
86242: LD_INT 21
86244: PUSH
86245: LD_INT 22
86247: PUSH
86248: LD_INT 23
86250: PUSH
86251: LD_INT 24
86253: PUSH
86254: LD_INT 25
86256: PUSH
86257: LD_INT 26
86259: PUSH
86260: LD_INT 27
86262: PUSH
86263: LD_INT 28
86265: PUSH
86266: LD_INT 29
86268: PUSH
86269: LD_INT 30
86271: PUSH
86272: LD_INT 31
86274: PUSH
86275: LD_INT 32
86277: PUSH
86278: LD_INT 33
86280: PUSH
86281: LD_INT 34
86283: PUSH
86284: LD_INT 36
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 101
86326: PUSH
86327: LD_INT 102
86329: PUSH
86330: LD_INT 103
86332: PUSH
86333: LD_INT 104
86335: PUSH
86336: LD_INT 105
86338: PUSH
86339: LD_INT 106
86341: PUSH
86342: LD_INT 107
86344: PUSH
86345: LD_INT 108
86347: PUSH
86348: LD_INT 109
86350: PUSH
86351: LD_INT 110
86353: PUSH
86354: LD_INT 111
86356: PUSH
86357: LD_INT 112
86359: PUSH
86360: LD_INT 113
86362: PUSH
86363: LD_INT 114
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: ST_TO_ADDR
86386: GO 86761
86388: LD_INT 18
86390: DOUBLE
86391: EQUAL
86392: IFTRUE 86396
86394: GO 86532
86396: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86397: LD_ADDR_VAR 0 1
86401: PUSH
86402: LD_INT 2
86404: PUSH
86405: LD_INT 4
86407: PUSH
86408: LD_INT 5
86410: PUSH
86411: LD_INT 7
86413: PUSH
86414: LD_INT 11
86416: PUSH
86417: LD_INT 12
86419: PUSH
86420: LD_INT 15
86422: PUSH
86423: LD_INT 16
86425: PUSH
86426: LD_INT 20
86428: PUSH
86429: LD_INT 21
86431: PUSH
86432: LD_INT 22
86434: PUSH
86435: LD_INT 23
86437: PUSH
86438: LD_INT 25
86440: PUSH
86441: LD_INT 26
86443: PUSH
86444: LD_INT 30
86446: PUSH
86447: LD_INT 31
86449: PUSH
86450: LD_INT 32
86452: PUSH
86453: LD_INT 33
86455: PUSH
86456: LD_INT 34
86458: PUSH
86459: LD_INT 35
86461: PUSH
86462: LD_INT 36
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 101
86490: PUSH
86491: LD_INT 102
86493: PUSH
86494: LD_INT 103
86496: PUSH
86497: LD_INT 106
86499: PUSH
86500: LD_INT 108
86502: PUSH
86503: LD_INT 112
86505: PUSH
86506: LD_INT 113
86508: PUSH
86509: LD_INT 114
86511: PUSH
86512: LD_INT 115
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: ST_TO_ADDR
86530: GO 86761
86532: LD_INT 19
86534: DOUBLE
86535: EQUAL
86536: IFTRUE 86540
86538: GO 86760
86540: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
86541: LD_ADDR_VAR 0 1
86545: PUSH
86546: LD_INT 1
86548: PUSH
86549: LD_INT 2
86551: PUSH
86552: LD_INT 3
86554: PUSH
86555: LD_INT 4
86557: PUSH
86558: LD_INT 5
86560: PUSH
86561: LD_INT 6
86563: PUSH
86564: LD_INT 7
86566: PUSH
86567: LD_INT 8
86569: PUSH
86570: LD_INT 9
86572: PUSH
86573: LD_INT 10
86575: PUSH
86576: LD_INT 11
86578: PUSH
86579: LD_INT 12
86581: PUSH
86582: LD_INT 13
86584: PUSH
86585: LD_INT 14
86587: PUSH
86588: LD_INT 15
86590: PUSH
86591: LD_INT 16
86593: PUSH
86594: LD_INT 17
86596: PUSH
86597: LD_INT 18
86599: PUSH
86600: LD_INT 19
86602: PUSH
86603: LD_INT 20
86605: PUSH
86606: LD_INT 21
86608: PUSH
86609: LD_INT 22
86611: PUSH
86612: LD_INT 23
86614: PUSH
86615: LD_INT 24
86617: PUSH
86618: LD_INT 25
86620: PUSH
86621: LD_INT 26
86623: PUSH
86624: LD_INT 27
86626: PUSH
86627: LD_INT 28
86629: PUSH
86630: LD_INT 29
86632: PUSH
86633: LD_INT 30
86635: PUSH
86636: LD_INT 31
86638: PUSH
86639: LD_INT 32
86641: PUSH
86642: LD_INT 33
86644: PUSH
86645: LD_INT 34
86647: PUSH
86648: LD_INT 35
86650: PUSH
86651: LD_INT 36
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 101
86694: PUSH
86695: LD_INT 102
86697: PUSH
86698: LD_INT 103
86700: PUSH
86701: LD_INT 104
86703: PUSH
86704: LD_INT 105
86706: PUSH
86707: LD_INT 106
86709: PUSH
86710: LD_INT 107
86712: PUSH
86713: LD_INT 108
86715: PUSH
86716: LD_INT 109
86718: PUSH
86719: LD_INT 110
86721: PUSH
86722: LD_INT 111
86724: PUSH
86725: LD_INT 112
86727: PUSH
86728: LD_INT 113
86730: PUSH
86731: LD_INT 114
86733: PUSH
86734: LD_INT 115
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: ST_TO_ADDR
86758: GO 86761
86760: POP
// end else
86761: GO 86980
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86763: LD_ADDR_VAR 0 1
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: LD_INT 2
86773: PUSH
86774: LD_INT 3
86776: PUSH
86777: LD_INT 4
86779: PUSH
86780: LD_INT 5
86782: PUSH
86783: LD_INT 6
86785: PUSH
86786: LD_INT 7
86788: PUSH
86789: LD_INT 8
86791: PUSH
86792: LD_INT 9
86794: PUSH
86795: LD_INT 10
86797: PUSH
86798: LD_INT 11
86800: PUSH
86801: LD_INT 12
86803: PUSH
86804: LD_INT 13
86806: PUSH
86807: LD_INT 14
86809: PUSH
86810: LD_INT 15
86812: PUSH
86813: LD_INT 16
86815: PUSH
86816: LD_INT 17
86818: PUSH
86819: LD_INT 18
86821: PUSH
86822: LD_INT 19
86824: PUSH
86825: LD_INT 20
86827: PUSH
86828: LD_INT 21
86830: PUSH
86831: LD_INT 22
86833: PUSH
86834: LD_INT 23
86836: PUSH
86837: LD_INT 24
86839: PUSH
86840: LD_INT 25
86842: PUSH
86843: LD_INT 26
86845: PUSH
86846: LD_INT 27
86848: PUSH
86849: LD_INT 28
86851: PUSH
86852: LD_INT 29
86854: PUSH
86855: LD_INT 30
86857: PUSH
86858: LD_INT 31
86860: PUSH
86861: LD_INT 32
86863: PUSH
86864: LD_INT 33
86866: PUSH
86867: LD_INT 34
86869: PUSH
86870: LD_INT 35
86872: PUSH
86873: LD_INT 36
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 101
86916: PUSH
86917: LD_INT 102
86919: PUSH
86920: LD_INT 103
86922: PUSH
86923: LD_INT 104
86925: PUSH
86926: LD_INT 105
86928: PUSH
86929: LD_INT 106
86931: PUSH
86932: LD_INT 107
86934: PUSH
86935: LD_INT 108
86937: PUSH
86938: LD_INT 109
86940: PUSH
86941: LD_INT 110
86943: PUSH
86944: LD_INT 111
86946: PUSH
86947: LD_INT 112
86949: PUSH
86950: LD_INT 113
86952: PUSH
86953: LD_INT 114
86955: PUSH
86956: LD_INT 115
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: ST_TO_ADDR
// if result then
86980: LD_VAR 0 1
86984: IFFALSE 87273
// begin normal :=  ;
86986: LD_ADDR_VAR 0 3
86990: PUSH
86991: LD_STRING 
86993: ST_TO_ADDR
// hardcore :=  ;
86994: LD_ADDR_VAR 0 4
86998: PUSH
86999: LD_STRING 
87001: ST_TO_ADDR
// for i = 1 to normalCounter do
87002: LD_ADDR_VAR 0 5
87006: PUSH
87007: DOUBLE
87008: LD_INT 1
87010: DEC
87011: ST_TO_ADDR
87012: LD_EXP 119
87016: PUSH
87017: FOR_TO
87018: IFFALSE 87119
// begin tmp := 0 ;
87020: LD_ADDR_VAR 0 2
87024: PUSH
87025: LD_STRING 0
87027: ST_TO_ADDR
// if result [ 1 ] then
87028: LD_VAR 0 1
87032: PUSH
87033: LD_INT 1
87035: ARRAY
87036: IFFALSE 87101
// if result [ 1 ] [ 1 ] = i then
87038: LD_VAR 0 1
87042: PUSH
87043: LD_INT 1
87045: ARRAY
87046: PUSH
87047: LD_INT 1
87049: ARRAY
87050: PUSH
87051: LD_VAR 0 5
87055: EQUAL
87056: IFFALSE 87101
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87058: LD_ADDR_VAR 0 1
87062: PUSH
87063: LD_VAR 0 1
87067: PPUSH
87068: LD_INT 1
87070: PPUSH
87071: LD_VAR 0 1
87075: PUSH
87076: LD_INT 1
87078: ARRAY
87079: PPUSH
87080: LD_INT 1
87082: PPUSH
87083: CALL_OW 3
87087: PPUSH
87088: CALL_OW 1
87092: ST_TO_ADDR
// tmp := 1 ;
87093: LD_ADDR_VAR 0 2
87097: PUSH
87098: LD_STRING 1
87100: ST_TO_ADDR
// end ; normal := normal & tmp ;
87101: LD_ADDR_VAR 0 3
87105: PUSH
87106: LD_VAR 0 3
87110: PUSH
87111: LD_VAR 0 2
87115: STR
87116: ST_TO_ADDR
// end ;
87117: GO 87017
87119: POP
87120: POP
// for i = 1 to hardcoreCounter do
87121: LD_ADDR_VAR 0 5
87125: PUSH
87126: DOUBLE
87127: LD_INT 1
87129: DEC
87130: ST_TO_ADDR
87131: LD_EXP 120
87135: PUSH
87136: FOR_TO
87137: IFFALSE 87242
// begin tmp := 0 ;
87139: LD_ADDR_VAR 0 2
87143: PUSH
87144: LD_STRING 0
87146: ST_TO_ADDR
// if result [ 2 ] then
87147: LD_VAR 0 1
87151: PUSH
87152: LD_INT 2
87154: ARRAY
87155: IFFALSE 87224
// if result [ 2 ] [ 1 ] = 100 + i then
87157: LD_VAR 0 1
87161: PUSH
87162: LD_INT 2
87164: ARRAY
87165: PUSH
87166: LD_INT 1
87168: ARRAY
87169: PUSH
87170: LD_INT 100
87172: PUSH
87173: LD_VAR 0 5
87177: PLUS
87178: EQUAL
87179: IFFALSE 87224
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87181: LD_ADDR_VAR 0 1
87185: PUSH
87186: LD_VAR 0 1
87190: PPUSH
87191: LD_INT 2
87193: PPUSH
87194: LD_VAR 0 1
87198: PUSH
87199: LD_INT 2
87201: ARRAY
87202: PPUSH
87203: LD_INT 1
87205: PPUSH
87206: CALL_OW 3
87210: PPUSH
87211: CALL_OW 1
87215: ST_TO_ADDR
// tmp := 1 ;
87216: LD_ADDR_VAR 0 2
87220: PUSH
87221: LD_STRING 1
87223: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87224: LD_ADDR_VAR 0 4
87228: PUSH
87229: LD_VAR 0 4
87233: PUSH
87234: LD_VAR 0 2
87238: STR
87239: ST_TO_ADDR
// end ;
87240: GO 87136
87242: POP
87243: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87244: LD_STRING getStreamItemsFromMission("
87246: PUSH
87247: LD_VAR 0 3
87251: STR
87252: PUSH
87253: LD_STRING ","
87255: STR
87256: PUSH
87257: LD_VAR 0 4
87261: STR
87262: PUSH
87263: LD_STRING ")
87265: STR
87266: PPUSH
87267: CALL_OW 559
// end else
87271: GO 87280
// ToLua ( getStreamItemsFromMission("","") ) ;
87273: LD_STRING getStreamItemsFromMission("","")
87275: PPUSH
87276: CALL_OW 559
// end ;
87280: LD_VAR 0 1
87284: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87285: LD_EXP 118
87289: PUSH
87290: LD_EXP 123
87294: AND
87295: IFFALSE 87419
87297: GO 87299
87299: DISABLE
87300: LD_INT 0
87302: PPUSH
87303: PPUSH
// begin enable ;
87304: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87305: LD_ADDR_VAR 0 2
87309: PUSH
87310: LD_INT 22
87312: PUSH
87313: LD_OWVAR 2
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 2
87324: PUSH
87325: LD_INT 34
87327: PUSH
87328: LD_INT 7
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 34
87337: PUSH
87338: LD_INT 45
87340: PUSH
87341: EMPTY
87342: LIST
87343: LIST
87344: PUSH
87345: LD_INT 34
87347: PUSH
87348: LD_INT 28
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: PUSH
87355: LD_INT 34
87357: PUSH
87358: LD_INT 47
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PPUSH
87376: CALL_OW 69
87380: ST_TO_ADDR
// if not tmp then
87381: LD_VAR 0 2
87385: NOT
87386: IFFALSE 87390
// exit ;
87388: GO 87419
// for i in tmp do
87390: LD_ADDR_VAR 0 1
87394: PUSH
87395: LD_VAR 0 2
87399: PUSH
87400: FOR_IN
87401: IFFALSE 87417
// begin SetLives ( i , 0 ) ;
87403: LD_VAR 0 1
87407: PPUSH
87408: LD_INT 0
87410: PPUSH
87411: CALL_OW 234
// end ;
87415: GO 87400
87417: POP
87418: POP
// end ;
87419: PPOPN 2
87421: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
87422: LD_EXP 118
87426: PUSH
87427: LD_EXP 124
87431: AND
87432: IFFALSE 87516
87434: GO 87436
87436: DISABLE
87437: LD_INT 0
87439: PPUSH
87440: PPUSH
// begin enable ;
87441: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
87442: LD_ADDR_VAR 0 2
87446: PUSH
87447: LD_INT 22
87449: PUSH
87450: LD_OWVAR 2
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 32
87461: PUSH
87462: LD_INT 3
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PPUSH
87473: CALL_OW 69
87477: ST_TO_ADDR
// if not tmp then
87478: LD_VAR 0 2
87482: NOT
87483: IFFALSE 87487
// exit ;
87485: GO 87516
// for i in tmp do
87487: LD_ADDR_VAR 0 1
87491: PUSH
87492: LD_VAR 0 2
87496: PUSH
87497: FOR_IN
87498: IFFALSE 87514
// begin SetLives ( i , 0 ) ;
87500: LD_VAR 0 1
87504: PPUSH
87505: LD_INT 0
87507: PPUSH
87508: CALL_OW 234
// end ;
87512: GO 87497
87514: POP
87515: POP
// end ;
87516: PPOPN 2
87518: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
87519: LD_EXP 118
87523: PUSH
87524: LD_EXP 121
87528: AND
87529: IFFALSE 87622
87531: GO 87533
87533: DISABLE
87534: LD_INT 0
87536: PPUSH
// begin enable ;
87537: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
87538: LD_ADDR_VAR 0 1
87542: PUSH
87543: LD_INT 22
87545: PUSH
87546: LD_OWVAR 2
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: LD_INT 25
87560: PUSH
87561: LD_INT 5
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 25
87570: PUSH
87571: LD_INT 9
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 25
87580: PUSH
87581: LD_INT 8
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PPUSH
87598: CALL_OW 69
87602: PUSH
87603: FOR_IN
87604: IFFALSE 87620
// begin SetClass ( i , 1 ) ;
87606: LD_VAR 0 1
87610: PPUSH
87611: LD_INT 1
87613: PPUSH
87614: CALL_OW 336
// end ;
87618: GO 87603
87620: POP
87621: POP
// end ;
87622: PPOPN 1
87624: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
87625: LD_EXP 118
87629: PUSH
87630: LD_EXP 122
87634: AND
87635: PUSH
87636: LD_OWVAR 65
87640: PUSH
87641: LD_INT 7
87643: LESS
87644: AND
87645: IFFALSE 87659
87647: GO 87649
87649: DISABLE
// begin enable ;
87650: ENABLE
// game_speed := 7 ;
87651: LD_ADDR_OWVAR 65
87655: PUSH
87656: LD_INT 7
87658: ST_TO_ADDR
// end ;
87659: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
87660: LD_EXP 118
87664: PUSH
87665: LD_EXP 125
87669: AND
87670: IFFALSE 87872
87672: GO 87674
87674: DISABLE
87675: LD_INT 0
87677: PPUSH
87678: PPUSH
87679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
87680: LD_ADDR_VAR 0 3
87684: PUSH
87685: LD_INT 81
87687: PUSH
87688: LD_OWVAR 2
87692: PUSH
87693: EMPTY
87694: LIST
87695: LIST
87696: PUSH
87697: LD_INT 21
87699: PUSH
87700: LD_INT 1
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PPUSH
87711: CALL_OW 69
87715: ST_TO_ADDR
// if not tmp then
87716: LD_VAR 0 3
87720: NOT
87721: IFFALSE 87725
// exit ;
87723: GO 87872
// if tmp > 5 then
87725: LD_VAR 0 3
87729: PUSH
87730: LD_INT 5
87732: GREATER
87733: IFFALSE 87745
// k := 5 else
87735: LD_ADDR_VAR 0 2
87739: PUSH
87740: LD_INT 5
87742: ST_TO_ADDR
87743: GO 87755
// k := tmp ;
87745: LD_ADDR_VAR 0 2
87749: PUSH
87750: LD_VAR 0 3
87754: ST_TO_ADDR
// for i := 1 to k do
87755: LD_ADDR_VAR 0 1
87759: PUSH
87760: DOUBLE
87761: LD_INT 1
87763: DEC
87764: ST_TO_ADDR
87765: LD_VAR 0 2
87769: PUSH
87770: FOR_TO
87771: IFFALSE 87870
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87773: LD_VAR 0 3
87777: PUSH
87778: LD_VAR 0 1
87782: ARRAY
87783: PPUSH
87784: LD_VAR 0 1
87788: PUSH
87789: LD_INT 4
87791: MOD
87792: PUSH
87793: LD_INT 1
87795: PLUS
87796: PPUSH
87797: CALL_OW 259
87801: PUSH
87802: LD_INT 10
87804: LESS
87805: IFFALSE 87868
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
87807: LD_VAR 0 3
87811: PUSH
87812: LD_VAR 0 1
87816: ARRAY
87817: PPUSH
87818: LD_VAR 0 1
87822: PUSH
87823: LD_INT 4
87825: MOD
87826: PUSH
87827: LD_INT 1
87829: PLUS
87830: PPUSH
87831: LD_VAR 0 3
87835: PUSH
87836: LD_VAR 0 1
87840: ARRAY
87841: PPUSH
87842: LD_VAR 0 1
87846: PUSH
87847: LD_INT 4
87849: MOD
87850: PUSH
87851: LD_INT 1
87853: PLUS
87854: PPUSH
87855: CALL_OW 259
87859: PUSH
87860: LD_INT 1
87862: PLUS
87863: PPUSH
87864: CALL_OW 237
87868: GO 87770
87870: POP
87871: POP
// end ;
87872: PPOPN 3
87874: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
87875: LD_EXP 118
87879: PUSH
87880: LD_EXP 126
87884: AND
87885: IFFALSE 87905
87887: GO 87889
87889: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
87890: LD_INT 4
87892: PPUSH
87893: LD_OWVAR 2
87897: PPUSH
87898: LD_INT 0
87900: PPUSH
87901: CALL_OW 324
87905: END
// every 0 0$1 trigger StreamModeActive and sShovel do
87906: LD_EXP 118
87910: PUSH
87911: LD_EXP 155
87915: AND
87916: IFFALSE 87936
87918: GO 87920
87920: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
87921: LD_INT 19
87923: PPUSH
87924: LD_OWVAR 2
87928: PPUSH
87929: LD_INT 0
87931: PPUSH
87932: CALL_OW 324
87936: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
87937: LD_EXP 118
87941: PUSH
87942: LD_EXP 127
87946: AND
87947: IFFALSE 88049
87949: GO 87951
87951: DISABLE
87952: LD_INT 0
87954: PPUSH
87955: PPUSH
// begin enable ;
87956: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
87957: LD_ADDR_VAR 0 2
87961: PUSH
87962: LD_INT 22
87964: PUSH
87965: LD_OWVAR 2
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: LD_INT 34
87979: PUSH
87980: LD_INT 11
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 34
87989: PUSH
87990: LD_INT 30
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: LIST
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: PPUSH
88006: CALL_OW 69
88010: ST_TO_ADDR
// if not tmp then
88011: LD_VAR 0 2
88015: NOT
88016: IFFALSE 88020
// exit ;
88018: GO 88049
// for i in tmp do
88020: LD_ADDR_VAR 0 1
88024: PUSH
88025: LD_VAR 0 2
88029: PUSH
88030: FOR_IN
88031: IFFALSE 88047
// begin SetLives ( i , 0 ) ;
88033: LD_VAR 0 1
88037: PPUSH
88038: LD_INT 0
88040: PPUSH
88041: CALL_OW 234
// end ;
88045: GO 88030
88047: POP
88048: POP
// end ;
88049: PPOPN 2
88051: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88052: LD_EXP 118
88056: PUSH
88057: LD_EXP 128
88061: AND
88062: IFFALSE 88082
88064: GO 88066
88066: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88067: LD_INT 32
88069: PPUSH
88070: LD_OWVAR 2
88074: PPUSH
88075: LD_INT 0
88077: PPUSH
88078: CALL_OW 324
88082: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88083: LD_EXP 118
88087: PUSH
88088: LD_EXP 129
88092: AND
88093: IFFALSE 88274
88095: GO 88097
88097: DISABLE
88098: LD_INT 0
88100: PPUSH
88101: PPUSH
88102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88103: LD_ADDR_VAR 0 2
88107: PUSH
88108: LD_INT 22
88110: PUSH
88111: LD_OWVAR 2
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 33
88122: PUSH
88123: LD_INT 3
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PPUSH
88134: CALL_OW 69
88138: ST_TO_ADDR
// if not tmp then
88139: LD_VAR 0 2
88143: NOT
88144: IFFALSE 88148
// exit ;
88146: GO 88274
// side := 0 ;
88148: LD_ADDR_VAR 0 3
88152: PUSH
88153: LD_INT 0
88155: ST_TO_ADDR
// for i := 1 to 8 do
88156: LD_ADDR_VAR 0 1
88160: PUSH
88161: DOUBLE
88162: LD_INT 1
88164: DEC
88165: ST_TO_ADDR
88166: LD_INT 8
88168: PUSH
88169: FOR_TO
88170: IFFALSE 88218
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88172: LD_OWVAR 2
88176: PUSH
88177: LD_VAR 0 1
88181: NONEQUAL
88182: PUSH
88183: LD_OWVAR 2
88187: PPUSH
88188: LD_VAR 0 1
88192: PPUSH
88193: CALL_OW 81
88197: PUSH
88198: LD_INT 2
88200: EQUAL
88201: AND
88202: IFFALSE 88216
// begin side := i ;
88204: LD_ADDR_VAR 0 3
88208: PUSH
88209: LD_VAR 0 1
88213: ST_TO_ADDR
// break ;
88214: GO 88218
// end ;
88216: GO 88169
88218: POP
88219: POP
// if not side then
88220: LD_VAR 0 3
88224: NOT
88225: IFFALSE 88229
// exit ;
88227: GO 88274
// for i := 1 to tmp do
88229: LD_ADDR_VAR 0 1
88233: PUSH
88234: DOUBLE
88235: LD_INT 1
88237: DEC
88238: ST_TO_ADDR
88239: LD_VAR 0 2
88243: PUSH
88244: FOR_TO
88245: IFFALSE 88272
// if Prob ( 60 ) then
88247: LD_INT 60
88249: PPUSH
88250: CALL_OW 13
88254: IFFALSE 88270
// SetSide ( i , side ) ;
88256: LD_VAR 0 1
88260: PPUSH
88261: LD_VAR 0 3
88265: PPUSH
88266: CALL_OW 235
88270: GO 88244
88272: POP
88273: POP
// end ;
88274: PPOPN 3
88276: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88277: LD_EXP 118
88281: PUSH
88282: LD_EXP 131
88286: AND
88287: IFFALSE 88406
88289: GO 88291
88291: DISABLE
88292: LD_INT 0
88294: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88295: LD_ADDR_VAR 0 1
88299: PUSH
88300: LD_INT 22
88302: PUSH
88303: LD_OWVAR 2
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 21
88314: PUSH
88315: LD_INT 1
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 3
88324: PUSH
88325: LD_INT 23
88327: PUSH
88328: LD_INT 0
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: LIST
88343: PPUSH
88344: CALL_OW 69
88348: PUSH
88349: FOR_IN
88350: IFFALSE 88404
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88352: LD_VAR 0 1
88356: PPUSH
88357: CALL_OW 257
88361: PUSH
88362: LD_INT 1
88364: PUSH
88365: LD_INT 2
88367: PUSH
88368: LD_INT 3
88370: PUSH
88371: LD_INT 4
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: IN
88380: IFFALSE 88402
// SetClass ( un , rand ( 1 , 4 ) ) ;
88382: LD_VAR 0 1
88386: PPUSH
88387: LD_INT 1
88389: PPUSH
88390: LD_INT 4
88392: PPUSH
88393: CALL_OW 12
88397: PPUSH
88398: CALL_OW 336
88402: GO 88349
88404: POP
88405: POP
// end ;
88406: PPOPN 1
88408: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88409: LD_EXP 118
88413: PUSH
88414: LD_EXP 130
88418: AND
88419: IFFALSE 88498
88421: GO 88423
88423: DISABLE
88424: LD_INT 0
88426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88427: LD_ADDR_VAR 0 1
88431: PUSH
88432: LD_INT 22
88434: PUSH
88435: LD_OWVAR 2
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: PUSH
88444: LD_INT 21
88446: PUSH
88447: LD_INT 3
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PPUSH
88458: CALL_OW 69
88462: ST_TO_ADDR
// if not tmp then
88463: LD_VAR 0 1
88467: NOT
88468: IFFALSE 88472
// exit ;
88470: GO 88498
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
88472: LD_VAR 0 1
88476: PUSH
88477: LD_INT 1
88479: PPUSH
88480: LD_VAR 0 1
88484: PPUSH
88485: CALL_OW 12
88489: ARRAY
88490: PPUSH
88491: LD_INT 100
88493: PPUSH
88494: CALL_OW 234
// end ;
88498: PPOPN 1
88500: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
88501: LD_EXP 118
88505: PUSH
88506: LD_EXP 132
88510: AND
88511: IFFALSE 88609
88513: GO 88515
88515: DISABLE
88516: LD_INT 0
88518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88519: LD_ADDR_VAR 0 1
88523: PUSH
88524: LD_INT 22
88526: PUSH
88527: LD_OWVAR 2
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 21
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PPUSH
88550: CALL_OW 69
88554: ST_TO_ADDR
// if not tmp then
88555: LD_VAR 0 1
88559: NOT
88560: IFFALSE 88564
// exit ;
88562: GO 88609
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
88564: LD_VAR 0 1
88568: PUSH
88569: LD_INT 1
88571: PPUSH
88572: LD_VAR 0 1
88576: PPUSH
88577: CALL_OW 12
88581: ARRAY
88582: PPUSH
88583: LD_INT 1
88585: PPUSH
88586: LD_INT 4
88588: PPUSH
88589: CALL_OW 12
88593: PPUSH
88594: LD_INT 3000
88596: PPUSH
88597: LD_INT 9000
88599: PPUSH
88600: CALL_OW 12
88604: PPUSH
88605: CALL_OW 492
// end ;
88609: PPOPN 1
88611: END
// every 0 0$1 trigger StreamModeActive and sDepot do
88612: LD_EXP 118
88616: PUSH
88617: LD_EXP 133
88621: AND
88622: IFFALSE 88642
88624: GO 88626
88626: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
88627: LD_INT 1
88629: PPUSH
88630: LD_OWVAR 2
88634: PPUSH
88635: LD_INT 0
88637: PPUSH
88638: CALL_OW 324
88642: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
88643: LD_EXP 118
88647: PUSH
88648: LD_EXP 134
88652: AND
88653: IFFALSE 88736
88655: GO 88657
88657: DISABLE
88658: LD_INT 0
88660: PPUSH
88661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88662: LD_ADDR_VAR 0 2
88666: PUSH
88667: LD_INT 22
88669: PUSH
88670: LD_OWVAR 2
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 21
88681: PUSH
88682: LD_INT 3
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PPUSH
88693: CALL_OW 69
88697: ST_TO_ADDR
// if not tmp then
88698: LD_VAR 0 2
88702: NOT
88703: IFFALSE 88707
// exit ;
88705: GO 88736
// for i in tmp do
88707: LD_ADDR_VAR 0 1
88711: PUSH
88712: LD_VAR 0 2
88716: PUSH
88717: FOR_IN
88718: IFFALSE 88734
// SetBLevel ( i , 10 ) ;
88720: LD_VAR 0 1
88724: PPUSH
88725: LD_INT 10
88727: PPUSH
88728: CALL_OW 241
88732: GO 88717
88734: POP
88735: POP
// end ;
88736: PPOPN 2
88738: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88739: LD_EXP 118
88743: PUSH
88744: LD_EXP 135
88748: AND
88749: IFFALSE 88860
88751: GO 88753
88753: DISABLE
88754: LD_INT 0
88756: PPUSH
88757: PPUSH
88758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88759: LD_ADDR_VAR 0 3
88763: PUSH
88764: LD_INT 22
88766: PUSH
88767: LD_OWVAR 2
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 25
88778: PUSH
88779: LD_INT 1
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PPUSH
88790: CALL_OW 69
88794: ST_TO_ADDR
// if not tmp then
88795: LD_VAR 0 3
88799: NOT
88800: IFFALSE 88804
// exit ;
88802: GO 88860
// un := tmp [ rand ( 1 , tmp ) ] ;
88804: LD_ADDR_VAR 0 2
88808: PUSH
88809: LD_VAR 0 3
88813: PUSH
88814: LD_INT 1
88816: PPUSH
88817: LD_VAR 0 3
88821: PPUSH
88822: CALL_OW 12
88826: ARRAY
88827: ST_TO_ADDR
// if Crawls ( un ) then
88828: LD_VAR 0 2
88832: PPUSH
88833: CALL_OW 318
88837: IFFALSE 88848
// ComWalk ( un ) ;
88839: LD_VAR 0 2
88843: PPUSH
88844: CALL_OW 138
// SetClass ( un , class_sniper ) ;
88848: LD_VAR 0 2
88852: PPUSH
88853: LD_INT 5
88855: PPUSH
88856: CALL_OW 336
// end ;
88860: PPOPN 3
88862: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
88863: LD_EXP 118
88867: PUSH
88868: LD_EXP 136
88872: AND
88873: PUSH
88874: LD_OWVAR 67
88878: PUSH
88879: LD_INT 3
88881: LESS
88882: AND
88883: IFFALSE 88902
88885: GO 88887
88887: DISABLE
// Difficulty := Difficulty + 1 ;
88888: LD_ADDR_OWVAR 67
88892: PUSH
88893: LD_OWVAR 67
88897: PUSH
88898: LD_INT 1
88900: PLUS
88901: ST_TO_ADDR
88902: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
88903: LD_EXP 118
88907: PUSH
88908: LD_EXP 137
88912: AND
88913: IFFALSE 89016
88915: GO 88917
88917: DISABLE
88918: LD_INT 0
88920: PPUSH
// begin for i := 1 to 5 do
88921: LD_ADDR_VAR 0 1
88925: PUSH
88926: DOUBLE
88927: LD_INT 1
88929: DEC
88930: ST_TO_ADDR
88931: LD_INT 5
88933: PUSH
88934: FOR_TO
88935: IFFALSE 89014
// begin uc_nation := nation_nature ;
88937: LD_ADDR_OWVAR 21
88941: PUSH
88942: LD_INT 0
88944: ST_TO_ADDR
// uc_side := 0 ;
88945: LD_ADDR_OWVAR 20
88949: PUSH
88950: LD_INT 0
88952: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88953: LD_ADDR_OWVAR 29
88957: PUSH
88958: LD_INT 12
88960: PUSH
88961: LD_INT 12
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: ST_TO_ADDR
// hc_agressivity := 20 ;
88968: LD_ADDR_OWVAR 35
88972: PUSH
88973: LD_INT 20
88975: ST_TO_ADDR
// hc_class := class_tiger ;
88976: LD_ADDR_OWVAR 28
88980: PUSH
88981: LD_INT 14
88983: ST_TO_ADDR
// hc_gallery :=  ;
88984: LD_ADDR_OWVAR 33
88988: PUSH
88989: LD_STRING 
88991: ST_TO_ADDR
// hc_name :=  ;
88992: LD_ADDR_OWVAR 26
88996: PUSH
88997: LD_STRING 
88999: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89000: CALL_OW 44
89004: PPUSH
89005: LD_INT 0
89007: PPUSH
89008: CALL_OW 51
// end ;
89012: GO 88934
89014: POP
89015: POP
// end ;
89016: PPOPN 1
89018: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89019: LD_EXP 118
89023: PUSH
89024: LD_EXP 138
89028: AND
89029: IFFALSE 89038
89031: GO 89033
89033: DISABLE
// StreamSibBomb ;
89034: CALL 89039 0 0
89038: END
// export function StreamSibBomb ; var i , x , y ; begin
89039: LD_INT 0
89041: PPUSH
89042: PPUSH
89043: PPUSH
89044: PPUSH
// result := false ;
89045: LD_ADDR_VAR 0 1
89049: PUSH
89050: LD_INT 0
89052: ST_TO_ADDR
// for i := 1 to 16 do
89053: LD_ADDR_VAR 0 2
89057: PUSH
89058: DOUBLE
89059: LD_INT 1
89061: DEC
89062: ST_TO_ADDR
89063: LD_INT 16
89065: PUSH
89066: FOR_TO
89067: IFFALSE 89266
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89069: LD_ADDR_VAR 0 3
89073: PUSH
89074: LD_INT 10
89076: PUSH
89077: LD_INT 20
89079: PUSH
89080: LD_INT 30
89082: PUSH
89083: LD_INT 40
89085: PUSH
89086: LD_INT 50
89088: PUSH
89089: LD_INT 60
89091: PUSH
89092: LD_INT 70
89094: PUSH
89095: LD_INT 80
89097: PUSH
89098: LD_INT 90
89100: PUSH
89101: LD_INT 100
89103: PUSH
89104: LD_INT 110
89106: PUSH
89107: LD_INT 120
89109: PUSH
89110: LD_INT 130
89112: PUSH
89113: LD_INT 140
89115: PUSH
89116: LD_INT 150
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: PPUSH
89139: LD_INT 15
89141: PPUSH
89142: CALL_OW 12
89146: ARRAY
89147: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89148: LD_ADDR_VAR 0 4
89152: PUSH
89153: LD_INT 10
89155: PUSH
89156: LD_INT 20
89158: PUSH
89159: LD_INT 30
89161: PUSH
89162: LD_INT 40
89164: PUSH
89165: LD_INT 50
89167: PUSH
89168: LD_INT 60
89170: PUSH
89171: LD_INT 70
89173: PUSH
89174: LD_INT 80
89176: PUSH
89177: LD_INT 90
89179: PUSH
89180: LD_INT 100
89182: PUSH
89183: LD_INT 110
89185: PUSH
89186: LD_INT 120
89188: PUSH
89189: LD_INT 130
89191: PUSH
89192: LD_INT 140
89194: PUSH
89195: LD_INT 150
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: PUSH
89215: LD_INT 1
89217: PPUSH
89218: LD_INT 15
89220: PPUSH
89221: CALL_OW 12
89225: ARRAY
89226: ST_TO_ADDR
// if ValidHex ( x , y ) then
89227: LD_VAR 0 3
89231: PPUSH
89232: LD_VAR 0 4
89236: PPUSH
89237: CALL_OW 488
89241: IFFALSE 89264
// begin result := [ x , y ] ;
89243: LD_ADDR_VAR 0 1
89247: PUSH
89248: LD_VAR 0 3
89252: PUSH
89253: LD_VAR 0 4
89257: PUSH
89258: EMPTY
89259: LIST
89260: LIST
89261: ST_TO_ADDR
// break ;
89262: GO 89266
// end ; end ;
89264: GO 89066
89266: POP
89267: POP
// if result then
89268: LD_VAR 0 1
89272: IFFALSE 89332
// begin ToLua ( playSibBomb() ) ;
89274: LD_STRING playSibBomb()
89276: PPUSH
89277: CALL_OW 559
// wait ( 0 0$14 ) ;
89281: LD_INT 490
89283: PPUSH
89284: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89288: LD_VAR 0 1
89292: PUSH
89293: LD_INT 1
89295: ARRAY
89296: PPUSH
89297: LD_VAR 0 1
89301: PUSH
89302: LD_INT 2
89304: ARRAY
89305: PPUSH
89306: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89310: LD_VAR 0 1
89314: PUSH
89315: LD_INT 1
89317: ARRAY
89318: PPUSH
89319: LD_VAR 0 1
89323: PUSH
89324: LD_INT 2
89326: ARRAY
89327: PPUSH
89328: CALL_OW 429
// end ; end ;
89332: LD_VAR 0 1
89336: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89337: LD_EXP 118
89341: PUSH
89342: LD_EXP 140
89346: AND
89347: IFFALSE 89359
89349: GO 89351
89351: DISABLE
// YouLost (  ) ;
89352: LD_STRING 
89354: PPUSH
89355: CALL_OW 104
89359: END
// every 0 0$1 trigger StreamModeActive and sFog do
89360: LD_EXP 118
89364: PUSH
89365: LD_EXP 139
89369: AND
89370: IFFALSE 89384
89372: GO 89374
89374: DISABLE
// FogOff ( your_side ) ;
89375: LD_OWVAR 2
89379: PPUSH
89380: CALL_OW 344
89384: END
// every 0 0$1 trigger StreamModeActive and sSun do
89385: LD_EXP 118
89389: PUSH
89390: LD_EXP 141
89394: AND
89395: IFFALSE 89423
89397: GO 89399
89399: DISABLE
// begin solar_recharge_percent := 0 ;
89400: LD_ADDR_OWVAR 79
89404: PUSH
89405: LD_INT 0
89407: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89408: LD_INT 10500
89410: PPUSH
89411: CALL_OW 67
// solar_recharge_percent := 100 ;
89415: LD_ADDR_OWVAR 79
89419: PUSH
89420: LD_INT 100
89422: ST_TO_ADDR
// end ;
89423: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
89424: LD_EXP 118
89428: PUSH
89429: LD_EXP 142
89433: AND
89434: IFFALSE 89673
89436: GO 89438
89438: DISABLE
89439: LD_INT 0
89441: PPUSH
89442: PPUSH
89443: PPUSH
// begin tmp := [ ] ;
89444: LD_ADDR_VAR 0 3
89448: PUSH
89449: EMPTY
89450: ST_TO_ADDR
// for i := 1 to 6 do
89451: LD_ADDR_VAR 0 1
89455: PUSH
89456: DOUBLE
89457: LD_INT 1
89459: DEC
89460: ST_TO_ADDR
89461: LD_INT 6
89463: PUSH
89464: FOR_TO
89465: IFFALSE 89570
// begin uc_nation := nation_nature ;
89467: LD_ADDR_OWVAR 21
89471: PUSH
89472: LD_INT 0
89474: ST_TO_ADDR
// uc_side := 0 ;
89475: LD_ADDR_OWVAR 20
89479: PUSH
89480: LD_INT 0
89482: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89483: LD_ADDR_OWVAR 29
89487: PUSH
89488: LD_INT 12
89490: PUSH
89491: LD_INT 12
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: ST_TO_ADDR
// hc_agressivity := 20 ;
89498: LD_ADDR_OWVAR 35
89502: PUSH
89503: LD_INT 20
89505: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
89506: LD_ADDR_OWVAR 28
89510: PUSH
89511: LD_INT 17
89513: ST_TO_ADDR
// hc_gallery :=  ;
89514: LD_ADDR_OWVAR 33
89518: PUSH
89519: LD_STRING 
89521: ST_TO_ADDR
// hc_name :=  ;
89522: LD_ADDR_OWVAR 26
89526: PUSH
89527: LD_STRING 
89529: ST_TO_ADDR
// un := CreateHuman ;
89530: LD_ADDR_VAR 0 2
89534: PUSH
89535: CALL_OW 44
89539: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
89540: LD_VAR 0 2
89544: PPUSH
89545: LD_INT 1
89547: PPUSH
89548: CALL_OW 51
// tmp := tmp ^ un ;
89552: LD_ADDR_VAR 0 3
89556: PUSH
89557: LD_VAR 0 3
89561: PUSH
89562: LD_VAR 0 2
89566: ADD
89567: ST_TO_ADDR
// end ;
89568: GO 89464
89570: POP
89571: POP
// repeat wait ( 0 0$1 ) ;
89572: LD_INT 35
89574: PPUSH
89575: CALL_OW 67
// for un in tmp do
89579: LD_ADDR_VAR 0 2
89583: PUSH
89584: LD_VAR 0 3
89588: PUSH
89589: FOR_IN
89590: IFFALSE 89664
// begin if IsDead ( un ) then
89592: LD_VAR 0 2
89596: PPUSH
89597: CALL_OW 301
89601: IFFALSE 89621
// begin tmp := tmp diff un ;
89603: LD_ADDR_VAR 0 3
89607: PUSH
89608: LD_VAR 0 3
89612: PUSH
89613: LD_VAR 0 2
89617: DIFF
89618: ST_TO_ADDR
// continue ;
89619: GO 89589
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
89621: LD_VAR 0 2
89625: PPUSH
89626: LD_INT 3
89628: PUSH
89629: LD_INT 22
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PPUSH
89643: CALL_OW 69
89647: PPUSH
89648: LD_VAR 0 2
89652: PPUSH
89653: CALL_OW 74
89657: PPUSH
89658: CALL_OW 115
// end ;
89662: GO 89589
89664: POP
89665: POP
// until not tmp ;
89666: LD_VAR 0 3
89670: NOT
89671: IFFALSE 89572
// end ;
89673: PPOPN 3
89675: END
// every 0 0$1 trigger StreamModeActive and sTroll do
89676: LD_EXP 118
89680: PUSH
89681: LD_EXP 143
89685: AND
89686: IFFALSE 89740
89688: GO 89690
89690: DISABLE
// begin ToLua ( displayTroll(); ) ;
89691: LD_STRING displayTroll();
89693: PPUSH
89694: CALL_OW 559
// wait ( 3 3$00 ) ;
89698: LD_INT 6300
89700: PPUSH
89701: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89705: LD_STRING hideTroll();
89707: PPUSH
89708: CALL_OW 559
// wait ( 1 1$00 ) ;
89712: LD_INT 2100
89714: PPUSH
89715: CALL_OW 67
// ToLua ( displayTroll(); ) ;
89719: LD_STRING displayTroll();
89721: PPUSH
89722: CALL_OW 559
// wait ( 1 1$00 ) ;
89726: LD_INT 2100
89728: PPUSH
89729: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89733: LD_STRING hideTroll();
89735: PPUSH
89736: CALL_OW 559
// end ;
89740: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89741: LD_EXP 118
89745: PUSH
89746: LD_EXP 144
89750: AND
89751: IFFALSE 89814
89753: GO 89755
89755: DISABLE
89756: LD_INT 0
89758: PPUSH
// begin p := 0 ;
89759: LD_ADDR_VAR 0 1
89763: PUSH
89764: LD_INT 0
89766: ST_TO_ADDR
// repeat game_speed := 1 ;
89767: LD_ADDR_OWVAR 65
89771: PUSH
89772: LD_INT 1
89774: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89775: LD_INT 35
89777: PPUSH
89778: CALL_OW 67
// p := p + 1 ;
89782: LD_ADDR_VAR 0 1
89786: PUSH
89787: LD_VAR 0 1
89791: PUSH
89792: LD_INT 1
89794: PLUS
89795: ST_TO_ADDR
// until p >= 60 ;
89796: LD_VAR 0 1
89800: PUSH
89801: LD_INT 60
89803: GREATEREQUAL
89804: IFFALSE 89767
// game_speed := 4 ;
89806: LD_ADDR_OWVAR 65
89810: PUSH
89811: LD_INT 4
89813: ST_TO_ADDR
// end ;
89814: PPOPN 1
89816: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
89817: LD_EXP 118
89821: PUSH
89822: LD_EXP 145
89826: AND
89827: IFFALSE 89973
89829: GO 89831
89831: DISABLE
89832: LD_INT 0
89834: PPUSH
89835: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89836: LD_ADDR_VAR 0 1
89840: PUSH
89841: LD_INT 22
89843: PUSH
89844: LD_OWVAR 2
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 2
89855: PUSH
89856: LD_INT 30
89858: PUSH
89859: LD_INT 0
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 30
89868: PUSH
89869: LD_INT 1
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: LIST
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PPUSH
89885: CALL_OW 69
89889: ST_TO_ADDR
// if not depot then
89890: LD_VAR 0 1
89894: NOT
89895: IFFALSE 89899
// exit ;
89897: GO 89973
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
89899: LD_ADDR_VAR 0 2
89903: PUSH
89904: LD_VAR 0 1
89908: PUSH
89909: LD_INT 1
89911: PPUSH
89912: LD_VAR 0 1
89916: PPUSH
89917: CALL_OW 12
89921: ARRAY
89922: PPUSH
89923: CALL_OW 274
89927: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
89928: LD_VAR 0 2
89932: PPUSH
89933: LD_INT 1
89935: PPUSH
89936: LD_INT 0
89938: PPUSH
89939: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
89943: LD_VAR 0 2
89947: PPUSH
89948: LD_INT 2
89950: PPUSH
89951: LD_INT 0
89953: PPUSH
89954: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
89958: LD_VAR 0 2
89962: PPUSH
89963: LD_INT 3
89965: PPUSH
89966: LD_INT 0
89968: PPUSH
89969: CALL_OW 277
// end ;
89973: PPOPN 2
89975: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
89976: LD_EXP 118
89980: PUSH
89981: LD_EXP 146
89985: AND
89986: IFFALSE 90083
89988: GO 89990
89990: DISABLE
89991: LD_INT 0
89993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89994: LD_ADDR_VAR 0 1
89998: PUSH
89999: LD_INT 22
90001: PUSH
90002: LD_OWVAR 2
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 21
90013: PUSH
90014: LD_INT 1
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 3
90023: PUSH
90024: LD_INT 23
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: LIST
90042: PPUSH
90043: CALL_OW 69
90047: ST_TO_ADDR
// if not tmp then
90048: LD_VAR 0 1
90052: NOT
90053: IFFALSE 90057
// exit ;
90055: GO 90083
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90057: LD_VAR 0 1
90061: PUSH
90062: LD_INT 1
90064: PPUSH
90065: LD_VAR 0 1
90069: PPUSH
90070: CALL_OW 12
90074: ARRAY
90075: PPUSH
90076: LD_INT 200
90078: PPUSH
90079: CALL_OW 234
// end ;
90083: PPOPN 1
90085: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90086: LD_EXP 118
90090: PUSH
90091: LD_EXP 147
90095: AND
90096: IFFALSE 90175
90098: GO 90100
90100: DISABLE
90101: LD_INT 0
90103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90104: LD_ADDR_VAR 0 1
90108: PUSH
90109: LD_INT 22
90111: PUSH
90112: LD_OWVAR 2
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 21
90123: PUSH
90124: LD_INT 2
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PPUSH
90135: CALL_OW 69
90139: ST_TO_ADDR
// if not tmp then
90140: LD_VAR 0 1
90144: NOT
90145: IFFALSE 90149
// exit ;
90147: GO 90175
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90149: LD_VAR 0 1
90153: PUSH
90154: LD_INT 1
90156: PPUSH
90157: LD_VAR 0 1
90161: PPUSH
90162: CALL_OW 12
90166: ARRAY
90167: PPUSH
90168: LD_INT 60
90170: PPUSH
90171: CALL_OW 234
// end ;
90175: PPOPN 1
90177: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90178: LD_EXP 118
90182: PUSH
90183: LD_EXP 148
90187: AND
90188: IFFALSE 90287
90190: GO 90192
90192: DISABLE
90193: LD_INT 0
90195: PPUSH
90196: PPUSH
// begin enable ;
90197: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90198: LD_ADDR_VAR 0 1
90202: PUSH
90203: LD_INT 22
90205: PUSH
90206: LD_OWVAR 2
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 61
90217: PUSH
90218: EMPTY
90219: LIST
90220: PUSH
90221: LD_INT 33
90223: PUSH
90224: LD_INT 2
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: LIST
90235: PPUSH
90236: CALL_OW 69
90240: ST_TO_ADDR
// if not tmp then
90241: LD_VAR 0 1
90245: NOT
90246: IFFALSE 90250
// exit ;
90248: GO 90287
// for i in tmp do
90250: LD_ADDR_VAR 0 2
90254: PUSH
90255: LD_VAR 0 1
90259: PUSH
90260: FOR_IN
90261: IFFALSE 90285
// if IsControledBy ( i ) then
90263: LD_VAR 0 2
90267: PPUSH
90268: CALL_OW 312
90272: IFFALSE 90283
// ComUnlink ( i ) ;
90274: LD_VAR 0 2
90278: PPUSH
90279: CALL_OW 136
90283: GO 90260
90285: POP
90286: POP
// end ;
90287: PPOPN 2
90289: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90290: LD_EXP 118
90294: PUSH
90295: LD_EXP 149
90299: AND
90300: IFFALSE 90440
90302: GO 90304
90304: DISABLE
90305: LD_INT 0
90307: PPUSH
90308: PPUSH
// begin ToLua ( displayPowell(); ) ;
90309: LD_STRING displayPowell();
90311: PPUSH
90312: CALL_OW 559
// uc_side := 0 ;
90316: LD_ADDR_OWVAR 20
90320: PUSH
90321: LD_INT 0
90323: ST_TO_ADDR
// uc_nation := 2 ;
90324: LD_ADDR_OWVAR 21
90328: PUSH
90329: LD_INT 2
90331: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90332: LD_ADDR_OWVAR 37
90336: PUSH
90337: LD_INT 14
90339: ST_TO_ADDR
// vc_engine := engine_siberite ;
90340: LD_ADDR_OWVAR 39
90344: PUSH
90345: LD_INT 3
90347: ST_TO_ADDR
// vc_control := control_apeman ;
90348: LD_ADDR_OWVAR 38
90352: PUSH
90353: LD_INT 5
90355: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90356: LD_ADDR_OWVAR 40
90360: PUSH
90361: LD_INT 29
90363: ST_TO_ADDR
// un := CreateVehicle ;
90364: LD_ADDR_VAR 0 2
90368: PUSH
90369: CALL_OW 45
90373: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90374: LD_VAR 0 2
90378: PPUSH
90379: LD_INT 1
90381: PPUSH
90382: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90386: LD_INT 35
90388: PPUSH
90389: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90393: LD_VAR 0 2
90397: PPUSH
90398: LD_INT 22
90400: PUSH
90401: LD_OWVAR 2
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PPUSH
90410: CALL_OW 69
90414: PPUSH
90415: LD_VAR 0 2
90419: PPUSH
90420: CALL_OW 74
90424: PPUSH
90425: CALL_OW 115
// until IsDead ( un ) ;
90429: LD_VAR 0 2
90433: PPUSH
90434: CALL_OW 301
90438: IFFALSE 90386
// end ;
90440: PPOPN 2
90442: END
// every 0 0$1 trigger StreamModeActive and sStu do
90443: LD_EXP 118
90447: PUSH
90448: LD_EXP 157
90452: AND
90453: IFFALSE 90469
90455: GO 90457
90457: DISABLE
// begin ToLua ( displayStucuk(); ) ;
90458: LD_STRING displayStucuk();
90460: PPUSH
90461: CALL_OW 559
// ResetFog ;
90465: CALL_OW 335
// end ;
90469: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
90470: LD_EXP 118
90474: PUSH
90475: LD_EXP 150
90479: AND
90480: IFFALSE 90621
90482: GO 90484
90484: DISABLE
90485: LD_INT 0
90487: PPUSH
90488: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90489: LD_ADDR_VAR 0 2
90493: PUSH
90494: LD_INT 22
90496: PUSH
90497: LD_OWVAR 2
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 21
90508: PUSH
90509: LD_INT 1
90511: PUSH
90512: EMPTY
90513: LIST
90514: LIST
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PPUSH
90520: CALL_OW 69
90524: ST_TO_ADDR
// if not tmp then
90525: LD_VAR 0 2
90529: NOT
90530: IFFALSE 90534
// exit ;
90532: GO 90621
// un := tmp [ rand ( 1 , tmp ) ] ;
90534: LD_ADDR_VAR 0 1
90538: PUSH
90539: LD_VAR 0 2
90543: PUSH
90544: LD_INT 1
90546: PPUSH
90547: LD_VAR 0 2
90551: PPUSH
90552: CALL_OW 12
90556: ARRAY
90557: ST_TO_ADDR
// SetSide ( un , 0 ) ;
90558: LD_VAR 0 1
90562: PPUSH
90563: LD_INT 0
90565: PPUSH
90566: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
90570: LD_VAR 0 1
90574: PPUSH
90575: LD_OWVAR 3
90579: PUSH
90580: LD_VAR 0 1
90584: DIFF
90585: PPUSH
90586: LD_VAR 0 1
90590: PPUSH
90591: CALL_OW 74
90595: PPUSH
90596: CALL_OW 115
// wait ( 0 0$20 ) ;
90600: LD_INT 700
90602: PPUSH
90603: CALL_OW 67
// SetSide ( un , your_side ) ;
90607: LD_VAR 0 1
90611: PPUSH
90612: LD_OWVAR 2
90616: PPUSH
90617: CALL_OW 235
// end ;
90621: PPOPN 2
90623: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
90624: LD_EXP 118
90628: PUSH
90629: LD_EXP 151
90633: AND
90634: IFFALSE 90740
90636: GO 90638
90638: DISABLE
90639: LD_INT 0
90641: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90642: LD_ADDR_VAR 0 1
90646: PUSH
90647: LD_INT 22
90649: PUSH
90650: LD_OWVAR 2
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 2
90661: PUSH
90662: LD_INT 30
90664: PUSH
90665: LD_INT 0
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 30
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PPUSH
90691: CALL_OW 69
90695: ST_TO_ADDR
// if not depot then
90696: LD_VAR 0 1
90700: NOT
90701: IFFALSE 90705
// exit ;
90703: GO 90740
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
90705: LD_VAR 0 1
90709: PUSH
90710: LD_INT 1
90712: ARRAY
90713: PPUSH
90714: CALL_OW 250
90718: PPUSH
90719: LD_VAR 0 1
90723: PUSH
90724: LD_INT 1
90726: ARRAY
90727: PPUSH
90728: CALL_OW 251
90732: PPUSH
90733: LD_INT 70
90735: PPUSH
90736: CALL_OW 495
// end ;
90740: PPOPN 1
90742: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90743: LD_EXP 118
90747: PUSH
90748: LD_EXP 152
90752: AND
90753: IFFALSE 90964
90755: GO 90757
90757: DISABLE
90758: LD_INT 0
90760: PPUSH
90761: PPUSH
90762: PPUSH
90763: PPUSH
90764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90765: LD_ADDR_VAR 0 5
90769: PUSH
90770: LD_INT 22
90772: PUSH
90773: LD_OWVAR 2
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 21
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PPUSH
90796: CALL_OW 69
90800: ST_TO_ADDR
// if not tmp then
90801: LD_VAR 0 5
90805: NOT
90806: IFFALSE 90810
// exit ;
90808: GO 90964
// for i in tmp do
90810: LD_ADDR_VAR 0 1
90814: PUSH
90815: LD_VAR 0 5
90819: PUSH
90820: FOR_IN
90821: IFFALSE 90962
// begin d := rand ( 0 , 5 ) ;
90823: LD_ADDR_VAR 0 4
90827: PUSH
90828: LD_INT 0
90830: PPUSH
90831: LD_INT 5
90833: PPUSH
90834: CALL_OW 12
90838: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
90839: LD_ADDR_VAR 0 2
90843: PUSH
90844: LD_VAR 0 1
90848: PPUSH
90849: CALL_OW 250
90853: PPUSH
90854: LD_VAR 0 4
90858: PPUSH
90859: LD_INT 3
90861: PPUSH
90862: LD_INT 12
90864: PPUSH
90865: CALL_OW 12
90869: PPUSH
90870: CALL_OW 272
90874: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
90875: LD_ADDR_VAR 0 3
90879: PUSH
90880: LD_VAR 0 1
90884: PPUSH
90885: CALL_OW 251
90889: PPUSH
90890: LD_VAR 0 4
90894: PPUSH
90895: LD_INT 3
90897: PPUSH
90898: LD_INT 12
90900: PPUSH
90901: CALL_OW 12
90905: PPUSH
90906: CALL_OW 273
90910: ST_TO_ADDR
// if ValidHex ( x , y ) then
90911: LD_VAR 0 2
90915: PPUSH
90916: LD_VAR 0 3
90920: PPUSH
90921: CALL_OW 488
90925: IFFALSE 90960
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
90927: LD_VAR 0 1
90931: PPUSH
90932: LD_VAR 0 2
90936: PPUSH
90937: LD_VAR 0 3
90941: PPUSH
90942: LD_INT 3
90944: PPUSH
90945: LD_INT 6
90947: PPUSH
90948: CALL_OW 12
90952: PPUSH
90953: LD_INT 1
90955: PPUSH
90956: CALL_OW 483
// end ;
90960: GO 90820
90962: POP
90963: POP
// end ;
90964: PPOPN 5
90966: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
90967: LD_EXP 118
90971: PUSH
90972: LD_EXP 153
90976: AND
90977: IFFALSE 91071
90979: GO 90981
90981: DISABLE
90982: LD_INT 0
90984: PPUSH
90985: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90986: LD_ADDR_VAR 0 2
90990: PUSH
90991: LD_INT 22
90993: PUSH
90994: LD_OWVAR 2
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 32
91005: PUSH
91006: LD_INT 1
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: PUSH
91013: LD_INT 21
91015: PUSH
91016: LD_INT 2
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: LIST
91027: PPUSH
91028: CALL_OW 69
91032: ST_TO_ADDR
// if not tmp then
91033: LD_VAR 0 2
91037: NOT
91038: IFFALSE 91042
// exit ;
91040: GO 91071
// for i in tmp do
91042: LD_ADDR_VAR 0 1
91046: PUSH
91047: LD_VAR 0 2
91051: PUSH
91052: FOR_IN
91053: IFFALSE 91069
// SetFuel ( i , 0 ) ;
91055: LD_VAR 0 1
91059: PPUSH
91060: LD_INT 0
91062: PPUSH
91063: CALL_OW 240
91067: GO 91052
91069: POP
91070: POP
// end ;
91071: PPOPN 2
91073: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91074: LD_EXP 118
91078: PUSH
91079: LD_EXP 154
91083: AND
91084: IFFALSE 91150
91086: GO 91088
91088: DISABLE
91089: LD_INT 0
91091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91092: LD_ADDR_VAR 0 1
91096: PUSH
91097: LD_INT 22
91099: PUSH
91100: LD_OWVAR 2
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 30
91111: PUSH
91112: LD_INT 29
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PPUSH
91123: CALL_OW 69
91127: ST_TO_ADDR
// if not tmp then
91128: LD_VAR 0 1
91132: NOT
91133: IFFALSE 91137
// exit ;
91135: GO 91150
// DestroyUnit ( tmp [ 1 ] ) ;
91137: LD_VAR 0 1
91141: PUSH
91142: LD_INT 1
91144: ARRAY
91145: PPUSH
91146: CALL_OW 65
// end ;
91150: PPOPN 1
91152: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91153: LD_EXP 118
91157: PUSH
91158: LD_EXP 156
91162: AND
91163: IFFALSE 91292
91165: GO 91167
91167: DISABLE
91168: LD_INT 0
91170: PPUSH
// begin uc_side := 0 ;
91171: LD_ADDR_OWVAR 20
91175: PUSH
91176: LD_INT 0
91178: ST_TO_ADDR
// uc_nation := nation_arabian ;
91179: LD_ADDR_OWVAR 21
91183: PUSH
91184: LD_INT 2
91186: ST_TO_ADDR
// hc_gallery :=  ;
91187: LD_ADDR_OWVAR 33
91191: PUSH
91192: LD_STRING 
91194: ST_TO_ADDR
// hc_name :=  ;
91195: LD_ADDR_OWVAR 26
91199: PUSH
91200: LD_STRING 
91202: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91203: LD_INT 1
91205: PPUSH
91206: LD_INT 11
91208: PPUSH
91209: LD_INT 10
91211: PPUSH
91212: CALL_OW 380
// un := CreateHuman ;
91216: LD_ADDR_VAR 0 1
91220: PUSH
91221: CALL_OW 44
91225: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91226: LD_VAR 0 1
91230: PPUSH
91231: LD_INT 1
91233: PPUSH
91234: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91238: LD_INT 35
91240: PPUSH
91241: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91245: LD_VAR 0 1
91249: PPUSH
91250: LD_INT 22
91252: PUSH
91253: LD_OWVAR 2
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PPUSH
91262: CALL_OW 69
91266: PPUSH
91267: LD_VAR 0 1
91271: PPUSH
91272: CALL_OW 74
91276: PPUSH
91277: CALL_OW 115
// until IsDead ( un ) ;
91281: LD_VAR 0 1
91285: PPUSH
91286: CALL_OW 301
91290: IFFALSE 91238
// end ;
91292: PPOPN 1
91294: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91295: LD_EXP 118
91299: PUSH
91300: LD_EXP 158
91304: AND
91305: IFFALSE 91317
91307: GO 91309
91309: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91310: LD_STRING earthquake(getX(game), 0, 32)
91312: PPUSH
91313: CALL_OW 559
91317: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91318: LD_EXP 118
91322: PUSH
91323: LD_EXP 159
91327: AND
91328: IFFALSE 91419
91330: GO 91332
91332: DISABLE
91333: LD_INT 0
91335: PPUSH
// begin enable ;
91336: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91337: LD_ADDR_VAR 0 1
91341: PUSH
91342: LD_INT 22
91344: PUSH
91345: LD_OWVAR 2
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 21
91356: PUSH
91357: LD_INT 2
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PUSH
91364: LD_INT 33
91366: PUSH
91367: LD_INT 3
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: LIST
91378: PPUSH
91379: CALL_OW 69
91383: ST_TO_ADDR
// if not tmp then
91384: LD_VAR 0 1
91388: NOT
91389: IFFALSE 91393
// exit ;
91391: GO 91419
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91393: LD_VAR 0 1
91397: PUSH
91398: LD_INT 1
91400: PPUSH
91401: LD_VAR 0 1
91405: PPUSH
91406: CALL_OW 12
91410: ARRAY
91411: PPUSH
91412: LD_INT 1
91414: PPUSH
91415: CALL_OW 234
// end ;
91419: PPOPN 1
91421: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
91422: LD_EXP 118
91426: PUSH
91427: LD_EXP 160
91431: AND
91432: IFFALSE 91573
91434: GO 91436
91436: DISABLE
91437: LD_INT 0
91439: PPUSH
91440: PPUSH
91441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91442: LD_ADDR_VAR 0 3
91446: PUSH
91447: LD_INT 22
91449: PUSH
91450: LD_OWVAR 2
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 25
91461: PUSH
91462: LD_INT 1
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: PPUSH
91473: CALL_OW 69
91477: ST_TO_ADDR
// if not tmp then
91478: LD_VAR 0 3
91482: NOT
91483: IFFALSE 91487
// exit ;
91485: GO 91573
// un := tmp [ rand ( 1 , tmp ) ] ;
91487: LD_ADDR_VAR 0 2
91491: PUSH
91492: LD_VAR 0 3
91496: PUSH
91497: LD_INT 1
91499: PPUSH
91500: LD_VAR 0 3
91504: PPUSH
91505: CALL_OW 12
91509: ARRAY
91510: ST_TO_ADDR
// if Crawls ( un ) then
91511: LD_VAR 0 2
91515: PPUSH
91516: CALL_OW 318
91520: IFFALSE 91531
// ComWalk ( un ) ;
91522: LD_VAR 0 2
91526: PPUSH
91527: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
91531: LD_VAR 0 2
91535: PPUSH
91536: LD_INT 9
91538: PPUSH
91539: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
91543: LD_INT 28
91545: PPUSH
91546: LD_OWVAR 2
91550: PPUSH
91551: LD_INT 2
91553: PPUSH
91554: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
91558: LD_INT 29
91560: PPUSH
91561: LD_OWVAR 2
91565: PPUSH
91566: LD_INT 2
91568: PPUSH
91569: CALL_OW 322
// end ;
91573: PPOPN 3
91575: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
91576: LD_EXP 118
91580: PUSH
91581: LD_EXP 161
91585: AND
91586: IFFALSE 91697
91588: GO 91590
91590: DISABLE
91591: LD_INT 0
91593: PPUSH
91594: PPUSH
91595: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91596: LD_ADDR_VAR 0 3
91600: PUSH
91601: LD_INT 22
91603: PUSH
91604: LD_OWVAR 2
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 25
91615: PUSH
91616: LD_INT 1
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PPUSH
91627: CALL_OW 69
91631: ST_TO_ADDR
// if not tmp then
91632: LD_VAR 0 3
91636: NOT
91637: IFFALSE 91641
// exit ;
91639: GO 91697
// un := tmp [ rand ( 1 , tmp ) ] ;
91641: LD_ADDR_VAR 0 2
91645: PUSH
91646: LD_VAR 0 3
91650: PUSH
91651: LD_INT 1
91653: PPUSH
91654: LD_VAR 0 3
91658: PPUSH
91659: CALL_OW 12
91663: ARRAY
91664: ST_TO_ADDR
// if Crawls ( un ) then
91665: LD_VAR 0 2
91669: PPUSH
91670: CALL_OW 318
91674: IFFALSE 91685
// ComWalk ( un ) ;
91676: LD_VAR 0 2
91680: PPUSH
91681: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91685: LD_VAR 0 2
91689: PPUSH
91690: LD_INT 8
91692: PPUSH
91693: CALL_OW 336
// end ;
91697: PPOPN 3
91699: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
91700: LD_EXP 118
91704: PUSH
91705: LD_EXP 162
91709: AND
91710: IFFALSE 91854
91712: GO 91714
91714: DISABLE
91715: LD_INT 0
91717: PPUSH
91718: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
91719: LD_ADDR_VAR 0 2
91723: PUSH
91724: LD_INT 22
91726: PUSH
91727: LD_OWVAR 2
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 21
91738: PUSH
91739: LD_INT 2
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 2
91748: PUSH
91749: LD_INT 34
91751: PUSH
91752: LD_INT 12
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: LD_INT 34
91761: PUSH
91762: LD_INT 51
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 34
91771: PUSH
91772: LD_INT 32
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: LIST
91789: PPUSH
91790: CALL_OW 69
91794: ST_TO_ADDR
// if not tmp then
91795: LD_VAR 0 2
91799: NOT
91800: IFFALSE 91804
// exit ;
91802: GO 91854
// for i in tmp do
91804: LD_ADDR_VAR 0 1
91808: PUSH
91809: LD_VAR 0 2
91813: PUSH
91814: FOR_IN
91815: IFFALSE 91852
// if GetCargo ( i , mat_artifact ) = 0 then
91817: LD_VAR 0 1
91821: PPUSH
91822: LD_INT 4
91824: PPUSH
91825: CALL_OW 289
91829: PUSH
91830: LD_INT 0
91832: EQUAL
91833: IFFALSE 91850
// SetCargo ( i , mat_siberit , 100 ) ;
91835: LD_VAR 0 1
91839: PPUSH
91840: LD_INT 3
91842: PPUSH
91843: LD_INT 100
91845: PPUSH
91846: CALL_OW 290
91850: GO 91814
91852: POP
91853: POP
// end ;
91854: PPOPN 2
91856: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
91857: LD_EXP 118
91861: PUSH
91862: LD_EXP 163
91866: AND
91867: IFFALSE 92050
91869: GO 91871
91871: DISABLE
91872: LD_INT 0
91874: PPUSH
91875: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
91876: LD_ADDR_VAR 0 2
91880: PUSH
91881: LD_INT 22
91883: PUSH
91884: LD_OWVAR 2
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PPUSH
91893: CALL_OW 69
91897: ST_TO_ADDR
// if not tmp then
91898: LD_VAR 0 2
91902: NOT
91903: IFFALSE 91907
// exit ;
91905: GO 92050
// for i := 1 to 2 do
91907: LD_ADDR_VAR 0 1
91911: PUSH
91912: DOUBLE
91913: LD_INT 1
91915: DEC
91916: ST_TO_ADDR
91917: LD_INT 2
91919: PUSH
91920: FOR_TO
91921: IFFALSE 92048
// begin uc_side := your_side ;
91923: LD_ADDR_OWVAR 20
91927: PUSH
91928: LD_OWVAR 2
91932: ST_TO_ADDR
// uc_nation := nation_american ;
91933: LD_ADDR_OWVAR 21
91937: PUSH
91938: LD_INT 1
91940: ST_TO_ADDR
// vc_chassis := us_morphling ;
91941: LD_ADDR_OWVAR 37
91945: PUSH
91946: LD_INT 5
91948: ST_TO_ADDR
// vc_engine := engine_siberite ;
91949: LD_ADDR_OWVAR 39
91953: PUSH
91954: LD_INT 3
91956: ST_TO_ADDR
// vc_control := control_computer ;
91957: LD_ADDR_OWVAR 38
91961: PUSH
91962: LD_INT 3
91964: ST_TO_ADDR
// vc_weapon := us_double_laser ;
91965: LD_ADDR_OWVAR 40
91969: PUSH
91970: LD_INT 10
91972: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
91973: LD_VAR 0 2
91977: PUSH
91978: LD_INT 1
91980: ARRAY
91981: PPUSH
91982: CALL_OW 310
91986: NOT
91987: IFFALSE 92034
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91989: CALL_OW 45
91993: PPUSH
91994: LD_VAR 0 2
91998: PUSH
91999: LD_INT 1
92001: ARRAY
92002: PPUSH
92003: CALL_OW 250
92007: PPUSH
92008: LD_VAR 0 2
92012: PUSH
92013: LD_INT 1
92015: ARRAY
92016: PPUSH
92017: CALL_OW 251
92021: PPUSH
92022: LD_INT 12
92024: PPUSH
92025: LD_INT 1
92027: PPUSH
92028: CALL_OW 50
92032: GO 92046
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92034: CALL_OW 45
92038: PPUSH
92039: LD_INT 1
92041: PPUSH
92042: CALL_OW 51
// end ;
92046: GO 91920
92048: POP
92049: POP
// end ;
92050: PPOPN 2
92052: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92053: LD_EXP 118
92057: PUSH
92058: LD_EXP 164
92062: AND
92063: IFFALSE 92285
92065: GO 92067
92067: DISABLE
92068: LD_INT 0
92070: PPUSH
92071: PPUSH
92072: PPUSH
92073: PPUSH
92074: PPUSH
92075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92076: LD_ADDR_VAR 0 6
92080: PUSH
92081: LD_INT 22
92083: PUSH
92084: LD_OWVAR 2
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 21
92095: PUSH
92096: LD_INT 1
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: PUSH
92103: LD_INT 3
92105: PUSH
92106: LD_INT 23
92108: PUSH
92109: LD_INT 0
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: PPUSH
92125: CALL_OW 69
92129: ST_TO_ADDR
// if not tmp then
92130: LD_VAR 0 6
92134: NOT
92135: IFFALSE 92139
// exit ;
92137: GO 92285
// s1 := rand ( 1 , 4 ) ;
92139: LD_ADDR_VAR 0 2
92143: PUSH
92144: LD_INT 1
92146: PPUSH
92147: LD_INT 4
92149: PPUSH
92150: CALL_OW 12
92154: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92155: LD_ADDR_VAR 0 4
92159: PUSH
92160: LD_VAR 0 6
92164: PUSH
92165: LD_INT 1
92167: ARRAY
92168: PPUSH
92169: LD_VAR 0 2
92173: PPUSH
92174: CALL_OW 259
92178: ST_TO_ADDR
// if s1 = 1 then
92179: LD_VAR 0 2
92183: PUSH
92184: LD_INT 1
92186: EQUAL
92187: IFFALSE 92207
// s2 := rand ( 2 , 4 ) else
92189: LD_ADDR_VAR 0 3
92193: PUSH
92194: LD_INT 2
92196: PPUSH
92197: LD_INT 4
92199: PPUSH
92200: CALL_OW 12
92204: ST_TO_ADDR
92205: GO 92215
// s2 := 1 ;
92207: LD_ADDR_VAR 0 3
92211: PUSH
92212: LD_INT 1
92214: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92215: LD_ADDR_VAR 0 5
92219: PUSH
92220: LD_VAR 0 6
92224: PUSH
92225: LD_INT 1
92227: ARRAY
92228: PPUSH
92229: LD_VAR 0 3
92233: PPUSH
92234: CALL_OW 259
92238: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92239: LD_VAR 0 6
92243: PUSH
92244: LD_INT 1
92246: ARRAY
92247: PPUSH
92248: LD_VAR 0 2
92252: PPUSH
92253: LD_VAR 0 5
92257: PPUSH
92258: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92262: LD_VAR 0 6
92266: PUSH
92267: LD_INT 1
92269: ARRAY
92270: PPUSH
92271: LD_VAR 0 3
92275: PPUSH
92276: LD_VAR 0 4
92280: PPUSH
92281: CALL_OW 237
// end ;
92285: PPOPN 6
92287: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92288: LD_EXP 118
92292: PUSH
92293: LD_EXP 165
92297: AND
92298: IFFALSE 92377
92300: GO 92302
92302: DISABLE
92303: LD_INT 0
92305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92306: LD_ADDR_VAR 0 1
92310: PUSH
92311: LD_INT 22
92313: PUSH
92314: LD_OWVAR 2
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 30
92325: PUSH
92326: LD_INT 3
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PPUSH
92337: CALL_OW 69
92341: ST_TO_ADDR
// if not tmp then
92342: LD_VAR 0 1
92346: NOT
92347: IFFALSE 92351
// exit ;
92349: GO 92377
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92351: LD_VAR 0 1
92355: PUSH
92356: LD_INT 1
92358: PPUSH
92359: LD_VAR 0 1
92363: PPUSH
92364: CALL_OW 12
92368: ARRAY
92369: PPUSH
92370: LD_INT 1
92372: PPUSH
92373: CALL_OW 234
// end ;
92377: PPOPN 1
92379: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92380: LD_EXP 118
92384: PUSH
92385: LD_EXP 166
92389: AND
92390: IFFALSE 92502
92392: GO 92394
92394: DISABLE
92395: LD_INT 0
92397: PPUSH
92398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92399: LD_ADDR_VAR 0 2
92403: PUSH
92404: LD_INT 22
92406: PUSH
92407: LD_OWVAR 2
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 2
92418: PUSH
92419: LD_INT 30
92421: PUSH
92422: LD_INT 27
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: PUSH
92429: LD_INT 30
92431: PUSH
92432: LD_INT 26
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 30
92441: PUSH
92442: LD_INT 28
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: PUSH
92455: EMPTY
92456: LIST
92457: LIST
92458: PPUSH
92459: CALL_OW 69
92463: ST_TO_ADDR
// if not tmp then
92464: LD_VAR 0 2
92468: NOT
92469: IFFALSE 92473
// exit ;
92471: GO 92502
// for i in tmp do
92473: LD_ADDR_VAR 0 1
92477: PUSH
92478: LD_VAR 0 2
92482: PUSH
92483: FOR_IN
92484: IFFALSE 92500
// SetLives ( i , 1 ) ;
92486: LD_VAR 0 1
92490: PPUSH
92491: LD_INT 1
92493: PPUSH
92494: CALL_OW 234
92498: GO 92483
92500: POP
92501: POP
// end ;
92502: PPOPN 2
92504: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
92505: LD_EXP 118
92509: PUSH
92510: LD_EXP 167
92514: AND
92515: IFFALSE 92789
92517: GO 92519
92519: DISABLE
92520: LD_INT 0
92522: PPUSH
92523: PPUSH
92524: PPUSH
// begin i := rand ( 1 , 7 ) ;
92525: LD_ADDR_VAR 0 1
92529: PUSH
92530: LD_INT 1
92532: PPUSH
92533: LD_INT 7
92535: PPUSH
92536: CALL_OW 12
92540: ST_TO_ADDR
// case i of 1 :
92541: LD_VAR 0 1
92545: PUSH
92546: LD_INT 1
92548: DOUBLE
92549: EQUAL
92550: IFTRUE 92554
92552: GO 92564
92554: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
92555: LD_STRING earthquake(getX(game), 0, 32)
92557: PPUSH
92558: CALL_OW 559
92562: GO 92789
92564: LD_INT 2
92566: DOUBLE
92567: EQUAL
92568: IFTRUE 92572
92570: GO 92586
92572: POP
// begin ToLua ( displayStucuk(); ) ;
92573: LD_STRING displayStucuk();
92575: PPUSH
92576: CALL_OW 559
// ResetFog ;
92580: CALL_OW 335
// end ; 3 :
92584: GO 92789
92586: LD_INT 3
92588: DOUBLE
92589: EQUAL
92590: IFTRUE 92594
92592: GO 92698
92594: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92595: LD_ADDR_VAR 0 2
92599: PUSH
92600: LD_INT 22
92602: PUSH
92603: LD_OWVAR 2
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 25
92614: PUSH
92615: LD_INT 1
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PPUSH
92626: CALL_OW 69
92630: ST_TO_ADDR
// if not tmp then
92631: LD_VAR 0 2
92635: NOT
92636: IFFALSE 92640
// exit ;
92638: GO 92789
// un := tmp [ rand ( 1 , tmp ) ] ;
92640: LD_ADDR_VAR 0 3
92644: PUSH
92645: LD_VAR 0 2
92649: PUSH
92650: LD_INT 1
92652: PPUSH
92653: LD_VAR 0 2
92657: PPUSH
92658: CALL_OW 12
92662: ARRAY
92663: ST_TO_ADDR
// if Crawls ( un ) then
92664: LD_VAR 0 3
92668: PPUSH
92669: CALL_OW 318
92673: IFFALSE 92684
// ComWalk ( un ) ;
92675: LD_VAR 0 3
92679: PPUSH
92680: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92684: LD_VAR 0 3
92688: PPUSH
92689: LD_INT 8
92691: PPUSH
92692: CALL_OW 336
// end ; 4 :
92696: GO 92789
92698: LD_INT 4
92700: DOUBLE
92701: EQUAL
92702: IFTRUE 92706
92704: GO 92767
92706: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92707: LD_ADDR_VAR 0 2
92711: PUSH
92712: LD_INT 22
92714: PUSH
92715: LD_OWVAR 2
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 30
92726: PUSH
92727: LD_INT 29
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PPUSH
92738: CALL_OW 69
92742: ST_TO_ADDR
// if not tmp then
92743: LD_VAR 0 2
92747: NOT
92748: IFFALSE 92752
// exit ;
92750: GO 92789
// DestroyUnit ( tmp [ 1 ] ) ;
92752: LD_VAR 0 2
92756: PUSH
92757: LD_INT 1
92759: ARRAY
92760: PPUSH
92761: CALL_OW 65
// end ; 5 .. 7 :
92765: GO 92789
92767: LD_INT 5
92769: DOUBLE
92770: GREATEREQUAL
92771: IFFALSE 92779
92773: LD_INT 7
92775: DOUBLE
92776: LESSEQUAL
92777: IFTRUE 92781
92779: GO 92788
92781: POP
// StreamSibBomb ; end ;
92782: CALL 89039 0 0
92786: GO 92789
92788: POP
// end ;
92789: PPOPN 3
92791: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92792: LD_EXP 118
92796: PUSH
92797: LD_EXP 168
92801: AND
92802: IFFALSE 92958
92804: GO 92806
92806: DISABLE
92807: LD_INT 0
92809: PPUSH
92810: PPUSH
92811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
92812: LD_ADDR_VAR 0 2
92816: PUSH
92817: LD_INT 81
92819: PUSH
92820: LD_OWVAR 2
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 2
92831: PUSH
92832: LD_INT 21
92834: PUSH
92835: LD_INT 1
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: LD_INT 21
92844: PUSH
92845: LD_INT 2
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: LIST
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PPUSH
92861: CALL_OW 69
92865: ST_TO_ADDR
// if not tmp then
92866: LD_VAR 0 2
92870: NOT
92871: IFFALSE 92875
// exit ;
92873: GO 92958
// p := 0 ;
92875: LD_ADDR_VAR 0 3
92879: PUSH
92880: LD_INT 0
92882: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92883: LD_INT 35
92885: PPUSH
92886: CALL_OW 67
// p := p + 1 ;
92890: LD_ADDR_VAR 0 3
92894: PUSH
92895: LD_VAR 0 3
92899: PUSH
92900: LD_INT 1
92902: PLUS
92903: ST_TO_ADDR
// for i in tmp do
92904: LD_ADDR_VAR 0 1
92908: PUSH
92909: LD_VAR 0 2
92913: PUSH
92914: FOR_IN
92915: IFFALSE 92946
// if GetLives ( i ) < 1000 then
92917: LD_VAR 0 1
92921: PPUSH
92922: CALL_OW 256
92926: PUSH
92927: LD_INT 1000
92929: LESS
92930: IFFALSE 92944
// SetLives ( i , 1000 ) ;
92932: LD_VAR 0 1
92936: PPUSH
92937: LD_INT 1000
92939: PPUSH
92940: CALL_OW 234
92944: GO 92914
92946: POP
92947: POP
// until p > 20 ;
92948: LD_VAR 0 3
92952: PUSH
92953: LD_INT 20
92955: GREATER
92956: IFFALSE 92883
// end ;
92958: PPOPN 3
92960: END
// every 0 0$1 trigger StreamModeActive and sTime do
92961: LD_EXP 118
92965: PUSH
92966: LD_EXP 169
92970: AND
92971: IFFALSE 93006
92973: GO 92975
92975: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
92976: LD_INT 28
92978: PPUSH
92979: LD_OWVAR 2
92983: PPUSH
92984: LD_INT 2
92986: PPUSH
92987: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92991: LD_INT 30
92993: PPUSH
92994: LD_OWVAR 2
92998: PPUSH
92999: LD_INT 2
93001: PPUSH
93002: CALL_OW 322
// end ;
93006: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93007: LD_EXP 118
93011: PUSH
93012: LD_EXP 170
93016: AND
93017: IFFALSE 93138
93019: GO 93021
93021: DISABLE
93022: LD_INT 0
93024: PPUSH
93025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93026: LD_ADDR_VAR 0 2
93030: PUSH
93031: LD_INT 22
93033: PUSH
93034: LD_OWVAR 2
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 21
93045: PUSH
93046: LD_INT 1
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 3
93055: PUSH
93056: LD_INT 23
93058: PUSH
93059: LD_INT 0
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: EMPTY
93067: LIST
93068: LIST
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: LIST
93074: PPUSH
93075: CALL_OW 69
93079: ST_TO_ADDR
// if not tmp then
93080: LD_VAR 0 2
93084: NOT
93085: IFFALSE 93089
// exit ;
93087: GO 93138
// for i in tmp do
93089: LD_ADDR_VAR 0 1
93093: PUSH
93094: LD_VAR 0 2
93098: PUSH
93099: FOR_IN
93100: IFFALSE 93136
// begin if Crawls ( i ) then
93102: LD_VAR 0 1
93106: PPUSH
93107: CALL_OW 318
93111: IFFALSE 93122
// ComWalk ( i ) ;
93113: LD_VAR 0 1
93117: PPUSH
93118: CALL_OW 138
// SetClass ( i , 2 ) ;
93122: LD_VAR 0 1
93126: PPUSH
93127: LD_INT 2
93129: PPUSH
93130: CALL_OW 336
// end ;
93134: GO 93099
93136: POP
93137: POP
// end ;
93138: PPOPN 2
93140: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93141: LD_EXP 118
93145: PUSH
93146: LD_EXP 171
93150: AND
93151: IFFALSE 93432
93153: GO 93155
93155: DISABLE
93156: LD_INT 0
93158: PPUSH
93159: PPUSH
93160: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93161: LD_OWVAR 2
93165: PPUSH
93166: LD_INT 9
93168: PPUSH
93169: LD_INT 1
93171: PPUSH
93172: LD_INT 1
93174: PPUSH
93175: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93179: LD_INT 9
93181: PPUSH
93182: LD_OWVAR 2
93186: PPUSH
93187: CALL_OW 343
// uc_side := 9 ;
93191: LD_ADDR_OWVAR 20
93195: PUSH
93196: LD_INT 9
93198: ST_TO_ADDR
// uc_nation := 2 ;
93199: LD_ADDR_OWVAR 21
93203: PUSH
93204: LD_INT 2
93206: ST_TO_ADDR
// hc_name := Dark Warrior ;
93207: LD_ADDR_OWVAR 26
93211: PUSH
93212: LD_STRING Dark Warrior
93214: ST_TO_ADDR
// hc_gallery :=  ;
93215: LD_ADDR_OWVAR 33
93219: PUSH
93220: LD_STRING 
93222: ST_TO_ADDR
// hc_noskilllimit := true ;
93223: LD_ADDR_OWVAR 76
93227: PUSH
93228: LD_INT 1
93230: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93231: LD_ADDR_OWVAR 31
93235: PUSH
93236: LD_INT 30
93238: PUSH
93239: LD_INT 30
93241: PUSH
93242: LD_INT 30
93244: PUSH
93245: LD_INT 30
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: ST_TO_ADDR
// un := CreateHuman ;
93254: LD_ADDR_VAR 0 3
93258: PUSH
93259: CALL_OW 44
93263: ST_TO_ADDR
// hc_noskilllimit := false ;
93264: LD_ADDR_OWVAR 76
93268: PUSH
93269: LD_INT 0
93271: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93272: LD_VAR 0 3
93276: PPUSH
93277: LD_INT 1
93279: PPUSH
93280: CALL_OW 51
// p := 0 ;
93284: LD_ADDR_VAR 0 2
93288: PUSH
93289: LD_INT 0
93291: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93292: LD_INT 35
93294: PPUSH
93295: CALL_OW 67
// p := p + 1 ;
93299: LD_ADDR_VAR 0 2
93303: PUSH
93304: LD_VAR 0 2
93308: PUSH
93309: LD_INT 1
93311: PLUS
93312: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93313: LD_VAR 0 3
93317: PPUSH
93318: CALL_OW 256
93322: PUSH
93323: LD_INT 1000
93325: LESS
93326: IFFALSE 93340
// SetLives ( un , 1000 ) ;
93328: LD_VAR 0 3
93332: PPUSH
93333: LD_INT 1000
93335: PPUSH
93336: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93340: LD_VAR 0 3
93344: PPUSH
93345: LD_INT 81
93347: PUSH
93348: LD_OWVAR 2
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: LD_INT 91
93359: PUSH
93360: LD_VAR 0 3
93364: PUSH
93365: LD_INT 30
93367: PUSH
93368: EMPTY
93369: LIST
93370: LIST
93371: LIST
93372: PUSH
93373: EMPTY
93374: LIST
93375: LIST
93376: PPUSH
93377: CALL_OW 69
93381: PPUSH
93382: LD_VAR 0 3
93386: PPUSH
93387: CALL_OW 74
93391: PPUSH
93392: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93396: LD_VAR 0 2
93400: PUSH
93401: LD_INT 60
93403: GREATER
93404: PUSH
93405: LD_VAR 0 3
93409: PPUSH
93410: CALL_OW 301
93414: OR
93415: IFFALSE 93292
// if un then
93417: LD_VAR 0 3
93421: IFFALSE 93432
// RemoveUnit ( un ) ;
93423: LD_VAR 0 3
93427: PPUSH
93428: CALL_OW 64
// end ;
93432: PPOPN 3
93434: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93435: LD_INT 0
93437: PPUSH
// case cmd of 301 :
93438: LD_VAR 0 1
93442: PUSH
93443: LD_INT 301
93445: DOUBLE
93446: EQUAL
93447: IFTRUE 93451
93449: GO 93483
93451: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
93452: LD_VAR 0 6
93456: PPUSH
93457: LD_VAR 0 7
93461: PPUSH
93462: LD_VAR 0 8
93466: PPUSH
93467: LD_VAR 0 4
93471: PPUSH
93472: LD_VAR 0 5
93476: PPUSH
93477: CALL 94684 0 5
93481: GO 93604
93483: LD_INT 302
93485: DOUBLE
93486: EQUAL
93487: IFTRUE 93491
93489: GO 93528
93491: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
93492: LD_VAR 0 6
93496: PPUSH
93497: LD_VAR 0 7
93501: PPUSH
93502: LD_VAR 0 8
93506: PPUSH
93507: LD_VAR 0 9
93511: PPUSH
93512: LD_VAR 0 4
93516: PPUSH
93517: LD_VAR 0 5
93521: PPUSH
93522: CALL 94775 0 6
93526: GO 93604
93528: LD_INT 303
93530: DOUBLE
93531: EQUAL
93532: IFTRUE 93536
93534: GO 93573
93536: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
93537: LD_VAR 0 6
93541: PPUSH
93542: LD_VAR 0 7
93546: PPUSH
93547: LD_VAR 0 8
93551: PPUSH
93552: LD_VAR 0 9
93556: PPUSH
93557: LD_VAR 0 4
93561: PPUSH
93562: LD_VAR 0 5
93566: PPUSH
93567: CALL 93609 0 6
93571: GO 93604
93573: LD_INT 304
93575: DOUBLE
93576: EQUAL
93577: IFTRUE 93581
93579: GO 93603
93581: POP
// hHackTeleport ( unit , x , y ) ; end ;
93582: LD_VAR 0 2
93586: PPUSH
93587: LD_VAR 0 4
93591: PPUSH
93592: LD_VAR 0 5
93596: PPUSH
93597: CALL 95368 0 3
93601: GO 93604
93603: POP
// end ;
93604: LD_VAR 0 12
93608: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
93609: LD_INT 0
93611: PPUSH
93612: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
93613: LD_VAR 0 1
93617: PUSH
93618: LD_INT 1
93620: LESS
93621: PUSH
93622: LD_VAR 0 1
93626: PUSH
93627: LD_INT 3
93629: GREATER
93630: OR
93631: PUSH
93632: LD_VAR 0 5
93636: PPUSH
93637: LD_VAR 0 6
93641: PPUSH
93642: CALL_OW 428
93646: OR
93647: IFFALSE 93651
// exit ;
93649: GO 94371
// uc_side := your_side ;
93651: LD_ADDR_OWVAR 20
93655: PUSH
93656: LD_OWVAR 2
93660: ST_TO_ADDR
// uc_nation := nation ;
93661: LD_ADDR_OWVAR 21
93665: PUSH
93666: LD_VAR 0 1
93670: ST_TO_ADDR
// bc_level = 1 ;
93671: LD_ADDR_OWVAR 43
93675: PUSH
93676: LD_INT 1
93678: ST_TO_ADDR
// case btype of 1 :
93679: LD_VAR 0 2
93683: PUSH
93684: LD_INT 1
93686: DOUBLE
93687: EQUAL
93688: IFTRUE 93692
93690: GO 93703
93692: POP
// bc_type := b_depot ; 2 :
93693: LD_ADDR_OWVAR 42
93697: PUSH
93698: LD_INT 0
93700: ST_TO_ADDR
93701: GO 94315
93703: LD_INT 2
93705: DOUBLE
93706: EQUAL
93707: IFTRUE 93711
93709: GO 93722
93711: POP
// bc_type := b_warehouse ; 3 :
93712: LD_ADDR_OWVAR 42
93716: PUSH
93717: LD_INT 1
93719: ST_TO_ADDR
93720: GO 94315
93722: LD_INT 3
93724: DOUBLE
93725: EQUAL
93726: IFTRUE 93730
93728: GO 93741
93730: POP
// bc_type := b_lab ; 4 .. 9 :
93731: LD_ADDR_OWVAR 42
93735: PUSH
93736: LD_INT 6
93738: ST_TO_ADDR
93739: GO 94315
93741: LD_INT 4
93743: DOUBLE
93744: GREATEREQUAL
93745: IFFALSE 93753
93747: LD_INT 9
93749: DOUBLE
93750: LESSEQUAL
93751: IFTRUE 93755
93753: GO 93807
93755: POP
// begin bc_type := b_lab_half ;
93756: LD_ADDR_OWVAR 42
93760: PUSH
93761: LD_INT 7
93763: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93764: LD_ADDR_OWVAR 44
93768: PUSH
93769: LD_INT 10
93771: PUSH
93772: LD_INT 11
93774: PUSH
93775: LD_INT 12
93777: PUSH
93778: LD_INT 15
93780: PUSH
93781: LD_INT 14
93783: PUSH
93784: LD_INT 13
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: PUSH
93795: LD_VAR 0 2
93799: PUSH
93800: LD_INT 3
93802: MINUS
93803: ARRAY
93804: ST_TO_ADDR
// end ; 10 .. 13 :
93805: GO 94315
93807: LD_INT 10
93809: DOUBLE
93810: GREATEREQUAL
93811: IFFALSE 93819
93813: LD_INT 13
93815: DOUBLE
93816: LESSEQUAL
93817: IFTRUE 93821
93819: GO 93898
93821: POP
// begin bc_type := b_lab_full ;
93822: LD_ADDR_OWVAR 42
93826: PUSH
93827: LD_INT 8
93829: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
93830: LD_ADDR_OWVAR 44
93834: PUSH
93835: LD_INT 10
93837: PUSH
93838: LD_INT 12
93840: PUSH
93841: LD_INT 14
93843: PUSH
93844: LD_INT 13
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: PUSH
93853: LD_VAR 0 2
93857: PUSH
93858: LD_INT 9
93860: MINUS
93861: ARRAY
93862: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
93863: LD_ADDR_OWVAR 45
93867: PUSH
93868: LD_INT 11
93870: PUSH
93871: LD_INT 15
93873: PUSH
93874: LD_INT 12
93876: PUSH
93877: LD_INT 15
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: PUSH
93886: LD_VAR 0 2
93890: PUSH
93891: LD_INT 9
93893: MINUS
93894: ARRAY
93895: ST_TO_ADDR
// end ; 14 :
93896: GO 94315
93898: LD_INT 14
93900: DOUBLE
93901: EQUAL
93902: IFTRUE 93906
93904: GO 93917
93906: POP
// bc_type := b_workshop ; 15 :
93907: LD_ADDR_OWVAR 42
93911: PUSH
93912: LD_INT 2
93914: ST_TO_ADDR
93915: GO 94315
93917: LD_INT 15
93919: DOUBLE
93920: EQUAL
93921: IFTRUE 93925
93923: GO 93936
93925: POP
// bc_type := b_factory ; 16 :
93926: LD_ADDR_OWVAR 42
93930: PUSH
93931: LD_INT 3
93933: ST_TO_ADDR
93934: GO 94315
93936: LD_INT 16
93938: DOUBLE
93939: EQUAL
93940: IFTRUE 93944
93942: GO 93955
93944: POP
// bc_type := b_ext_gun ; 17 :
93945: LD_ADDR_OWVAR 42
93949: PUSH
93950: LD_INT 17
93952: ST_TO_ADDR
93953: GO 94315
93955: LD_INT 17
93957: DOUBLE
93958: EQUAL
93959: IFTRUE 93963
93961: GO 93991
93963: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
93964: LD_ADDR_OWVAR 42
93968: PUSH
93969: LD_INT 19
93971: PUSH
93972: LD_INT 23
93974: PUSH
93975: LD_INT 19
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: LIST
93982: PUSH
93983: LD_VAR 0 1
93987: ARRAY
93988: ST_TO_ADDR
93989: GO 94315
93991: LD_INT 18
93993: DOUBLE
93994: EQUAL
93995: IFTRUE 93999
93997: GO 94010
93999: POP
// bc_type := b_ext_radar ; 19 :
94000: LD_ADDR_OWVAR 42
94004: PUSH
94005: LD_INT 20
94007: ST_TO_ADDR
94008: GO 94315
94010: LD_INT 19
94012: DOUBLE
94013: EQUAL
94014: IFTRUE 94018
94016: GO 94029
94018: POP
// bc_type := b_ext_radio ; 20 :
94019: LD_ADDR_OWVAR 42
94023: PUSH
94024: LD_INT 22
94026: ST_TO_ADDR
94027: GO 94315
94029: LD_INT 20
94031: DOUBLE
94032: EQUAL
94033: IFTRUE 94037
94035: GO 94048
94037: POP
// bc_type := b_ext_siberium ; 21 :
94038: LD_ADDR_OWVAR 42
94042: PUSH
94043: LD_INT 21
94045: ST_TO_ADDR
94046: GO 94315
94048: LD_INT 21
94050: DOUBLE
94051: EQUAL
94052: IFTRUE 94056
94054: GO 94067
94056: POP
// bc_type := b_ext_computer ; 22 :
94057: LD_ADDR_OWVAR 42
94061: PUSH
94062: LD_INT 24
94064: ST_TO_ADDR
94065: GO 94315
94067: LD_INT 22
94069: DOUBLE
94070: EQUAL
94071: IFTRUE 94075
94073: GO 94086
94075: POP
// bc_type := b_ext_track ; 23 :
94076: LD_ADDR_OWVAR 42
94080: PUSH
94081: LD_INT 16
94083: ST_TO_ADDR
94084: GO 94315
94086: LD_INT 23
94088: DOUBLE
94089: EQUAL
94090: IFTRUE 94094
94092: GO 94105
94094: POP
// bc_type := b_ext_laser ; 24 :
94095: LD_ADDR_OWVAR 42
94099: PUSH
94100: LD_INT 25
94102: ST_TO_ADDR
94103: GO 94315
94105: LD_INT 24
94107: DOUBLE
94108: EQUAL
94109: IFTRUE 94113
94111: GO 94124
94113: POP
// bc_type := b_control_tower ; 25 :
94114: LD_ADDR_OWVAR 42
94118: PUSH
94119: LD_INT 36
94121: ST_TO_ADDR
94122: GO 94315
94124: LD_INT 25
94126: DOUBLE
94127: EQUAL
94128: IFTRUE 94132
94130: GO 94143
94132: POP
// bc_type := b_breastwork ; 26 :
94133: LD_ADDR_OWVAR 42
94137: PUSH
94138: LD_INT 31
94140: ST_TO_ADDR
94141: GO 94315
94143: LD_INT 26
94145: DOUBLE
94146: EQUAL
94147: IFTRUE 94151
94149: GO 94162
94151: POP
// bc_type := b_bunker ; 27 :
94152: LD_ADDR_OWVAR 42
94156: PUSH
94157: LD_INT 32
94159: ST_TO_ADDR
94160: GO 94315
94162: LD_INT 27
94164: DOUBLE
94165: EQUAL
94166: IFTRUE 94170
94168: GO 94181
94170: POP
// bc_type := b_turret ; 28 :
94171: LD_ADDR_OWVAR 42
94175: PUSH
94176: LD_INT 33
94178: ST_TO_ADDR
94179: GO 94315
94181: LD_INT 28
94183: DOUBLE
94184: EQUAL
94185: IFTRUE 94189
94187: GO 94200
94189: POP
// bc_type := b_armoury ; 29 :
94190: LD_ADDR_OWVAR 42
94194: PUSH
94195: LD_INT 4
94197: ST_TO_ADDR
94198: GO 94315
94200: LD_INT 29
94202: DOUBLE
94203: EQUAL
94204: IFTRUE 94208
94206: GO 94219
94208: POP
// bc_type := b_barracks ; 30 :
94209: LD_ADDR_OWVAR 42
94213: PUSH
94214: LD_INT 5
94216: ST_TO_ADDR
94217: GO 94315
94219: LD_INT 30
94221: DOUBLE
94222: EQUAL
94223: IFTRUE 94227
94225: GO 94238
94227: POP
// bc_type := b_solar_power ; 31 :
94228: LD_ADDR_OWVAR 42
94232: PUSH
94233: LD_INT 27
94235: ST_TO_ADDR
94236: GO 94315
94238: LD_INT 31
94240: DOUBLE
94241: EQUAL
94242: IFTRUE 94246
94244: GO 94257
94246: POP
// bc_type := b_oil_power ; 32 :
94247: LD_ADDR_OWVAR 42
94251: PUSH
94252: LD_INT 26
94254: ST_TO_ADDR
94255: GO 94315
94257: LD_INT 32
94259: DOUBLE
94260: EQUAL
94261: IFTRUE 94265
94263: GO 94276
94265: POP
// bc_type := b_siberite_power ; 33 :
94266: LD_ADDR_OWVAR 42
94270: PUSH
94271: LD_INT 28
94273: ST_TO_ADDR
94274: GO 94315
94276: LD_INT 33
94278: DOUBLE
94279: EQUAL
94280: IFTRUE 94284
94282: GO 94295
94284: POP
// bc_type := b_oil_mine ; 34 :
94285: LD_ADDR_OWVAR 42
94289: PUSH
94290: LD_INT 29
94292: ST_TO_ADDR
94293: GO 94315
94295: LD_INT 34
94297: DOUBLE
94298: EQUAL
94299: IFTRUE 94303
94301: GO 94314
94303: POP
// bc_type := b_siberite_mine ; end ;
94304: LD_ADDR_OWVAR 42
94308: PUSH
94309: LD_INT 30
94311: ST_TO_ADDR
94312: GO 94315
94314: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94315: LD_ADDR_VAR 0 8
94319: PUSH
94320: LD_VAR 0 5
94324: PPUSH
94325: LD_VAR 0 6
94329: PPUSH
94330: LD_VAR 0 3
94334: PPUSH
94335: CALL_OW 47
94339: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94340: LD_OWVAR 42
94344: PUSH
94345: LD_INT 32
94347: PUSH
94348: LD_INT 33
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: IN
94355: IFFALSE 94371
// PlaceWeaponTurret ( b , weapon ) ;
94357: LD_VAR 0 8
94361: PPUSH
94362: LD_VAR 0 4
94366: PPUSH
94367: CALL_OW 431
// end ;
94371: LD_VAR 0 7
94375: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94376: LD_INT 0
94378: PPUSH
94379: PPUSH
94380: PPUSH
94381: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94382: LD_ADDR_VAR 0 4
94386: PUSH
94387: LD_INT 22
94389: PUSH
94390: LD_OWVAR 2
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: PUSH
94399: LD_INT 2
94401: PUSH
94402: LD_INT 30
94404: PUSH
94405: LD_INT 0
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 30
94414: PUSH
94415: LD_INT 1
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: LIST
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PPUSH
94431: CALL_OW 69
94435: ST_TO_ADDR
// if not tmp then
94436: LD_VAR 0 4
94440: NOT
94441: IFFALSE 94445
// exit ;
94443: GO 94504
// for i in tmp do
94445: LD_ADDR_VAR 0 2
94449: PUSH
94450: LD_VAR 0 4
94454: PUSH
94455: FOR_IN
94456: IFFALSE 94502
// for j = 1 to 3 do
94458: LD_ADDR_VAR 0 3
94462: PUSH
94463: DOUBLE
94464: LD_INT 1
94466: DEC
94467: ST_TO_ADDR
94468: LD_INT 3
94470: PUSH
94471: FOR_TO
94472: IFFALSE 94498
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
94474: LD_VAR 0 2
94478: PPUSH
94479: CALL_OW 274
94483: PPUSH
94484: LD_VAR 0 3
94488: PPUSH
94489: LD_INT 99999
94491: PPUSH
94492: CALL_OW 277
94496: GO 94471
94498: POP
94499: POP
94500: GO 94455
94502: POP
94503: POP
// end ;
94504: LD_VAR 0 1
94508: RET
// export function hHackSetLevel10 ; var i , j ; begin
94509: LD_INT 0
94511: PPUSH
94512: PPUSH
94513: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94514: LD_ADDR_VAR 0 2
94518: PUSH
94519: LD_INT 21
94521: PUSH
94522: LD_INT 1
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PPUSH
94529: CALL_OW 69
94533: PUSH
94534: FOR_IN
94535: IFFALSE 94587
// if IsSelected ( i ) then
94537: LD_VAR 0 2
94541: PPUSH
94542: CALL_OW 306
94546: IFFALSE 94585
// begin for j := 1 to 4 do
94548: LD_ADDR_VAR 0 3
94552: PUSH
94553: DOUBLE
94554: LD_INT 1
94556: DEC
94557: ST_TO_ADDR
94558: LD_INT 4
94560: PUSH
94561: FOR_TO
94562: IFFALSE 94583
// SetSkill ( i , j , 10 ) ;
94564: LD_VAR 0 2
94568: PPUSH
94569: LD_VAR 0 3
94573: PPUSH
94574: LD_INT 10
94576: PPUSH
94577: CALL_OW 237
94581: GO 94561
94583: POP
94584: POP
// end ;
94585: GO 94534
94587: POP
94588: POP
// end ;
94589: LD_VAR 0 1
94593: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
94594: LD_INT 0
94596: PPUSH
94597: PPUSH
94598: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
94599: LD_ADDR_VAR 0 2
94603: PUSH
94604: LD_INT 22
94606: PUSH
94607: LD_OWVAR 2
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 21
94618: PUSH
94619: LD_INT 1
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: PPUSH
94630: CALL_OW 69
94634: PUSH
94635: FOR_IN
94636: IFFALSE 94677
// begin for j := 1 to 4 do
94638: LD_ADDR_VAR 0 3
94642: PUSH
94643: DOUBLE
94644: LD_INT 1
94646: DEC
94647: ST_TO_ADDR
94648: LD_INT 4
94650: PUSH
94651: FOR_TO
94652: IFFALSE 94673
// SetSkill ( i , j , 10 ) ;
94654: LD_VAR 0 2
94658: PPUSH
94659: LD_VAR 0 3
94663: PPUSH
94664: LD_INT 10
94666: PPUSH
94667: CALL_OW 237
94671: GO 94651
94673: POP
94674: POP
// end ;
94675: GO 94635
94677: POP
94678: POP
// end ;
94679: LD_VAR 0 1
94683: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
94684: LD_INT 0
94686: PPUSH
// uc_side := your_side ;
94687: LD_ADDR_OWVAR 20
94691: PUSH
94692: LD_OWVAR 2
94696: ST_TO_ADDR
// uc_nation := nation ;
94697: LD_ADDR_OWVAR 21
94701: PUSH
94702: LD_VAR 0 1
94706: ST_TO_ADDR
// InitHc ;
94707: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
94711: LD_INT 0
94713: PPUSH
94714: LD_VAR 0 2
94718: PPUSH
94719: LD_VAR 0 3
94723: PPUSH
94724: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
94728: LD_VAR 0 4
94732: PPUSH
94733: LD_VAR 0 5
94737: PPUSH
94738: CALL_OW 428
94742: PUSH
94743: LD_INT 0
94745: EQUAL
94746: IFFALSE 94770
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94748: CALL_OW 44
94752: PPUSH
94753: LD_VAR 0 4
94757: PPUSH
94758: LD_VAR 0 5
94762: PPUSH
94763: LD_INT 1
94765: PPUSH
94766: CALL_OW 48
// end ;
94770: LD_VAR 0 6
94774: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94775: LD_INT 0
94777: PPUSH
94778: PPUSH
// uc_side := your_side ;
94779: LD_ADDR_OWVAR 20
94783: PUSH
94784: LD_OWVAR 2
94788: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94789: LD_VAR 0 1
94793: PUSH
94794: LD_INT 1
94796: PUSH
94797: LD_INT 2
94799: PUSH
94800: LD_INT 3
94802: PUSH
94803: LD_INT 4
94805: PUSH
94806: LD_INT 5
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: IN
94816: IFFALSE 94828
// uc_nation := nation_american else
94818: LD_ADDR_OWVAR 21
94822: PUSH
94823: LD_INT 1
94825: ST_TO_ADDR
94826: GO 94871
// if chassis in [ 11 , 12 , 13 , 14 ] then
94828: LD_VAR 0 1
94832: PUSH
94833: LD_INT 11
94835: PUSH
94836: LD_INT 12
94838: PUSH
94839: LD_INT 13
94841: PUSH
94842: LD_INT 14
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: IN
94851: IFFALSE 94863
// uc_nation := nation_arabian else
94853: LD_ADDR_OWVAR 21
94857: PUSH
94858: LD_INT 2
94860: ST_TO_ADDR
94861: GO 94871
// uc_nation := nation_russian ;
94863: LD_ADDR_OWVAR 21
94867: PUSH
94868: LD_INT 3
94870: ST_TO_ADDR
// vc_chassis := chassis ;
94871: LD_ADDR_OWVAR 37
94875: PUSH
94876: LD_VAR 0 1
94880: ST_TO_ADDR
// vc_engine := engine ;
94881: LD_ADDR_OWVAR 39
94885: PUSH
94886: LD_VAR 0 2
94890: ST_TO_ADDR
// vc_control := control ;
94891: LD_ADDR_OWVAR 38
94895: PUSH
94896: LD_VAR 0 3
94900: ST_TO_ADDR
// vc_weapon := weapon ;
94901: LD_ADDR_OWVAR 40
94905: PUSH
94906: LD_VAR 0 4
94910: ST_TO_ADDR
// un := CreateVehicle ;
94911: LD_ADDR_VAR 0 8
94915: PUSH
94916: CALL_OW 45
94920: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
94921: LD_VAR 0 8
94925: PPUSH
94926: LD_INT 0
94928: PPUSH
94929: LD_INT 5
94931: PPUSH
94932: CALL_OW 12
94936: PPUSH
94937: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
94941: LD_VAR 0 8
94945: PPUSH
94946: LD_VAR 0 5
94950: PPUSH
94951: LD_VAR 0 6
94955: PPUSH
94956: LD_INT 1
94958: PPUSH
94959: CALL_OW 48
// end ;
94963: LD_VAR 0 7
94967: RET
// export hInvincible ; every 1 do
94968: GO 94970
94970: DISABLE
// hInvincible := [ ] ;
94971: LD_ADDR_EXP 172
94975: PUSH
94976: EMPTY
94977: ST_TO_ADDR
94978: END
// every 10 do var i ;
94979: GO 94981
94981: DISABLE
94982: LD_INT 0
94984: PPUSH
// begin enable ;
94985: ENABLE
// if not hInvincible then
94986: LD_EXP 172
94990: NOT
94991: IFFALSE 94995
// exit ;
94993: GO 95039
// for i in hInvincible do
94995: LD_ADDR_VAR 0 1
94999: PUSH
95000: LD_EXP 172
95004: PUSH
95005: FOR_IN
95006: IFFALSE 95037
// if GetLives ( i ) < 1000 then
95008: LD_VAR 0 1
95012: PPUSH
95013: CALL_OW 256
95017: PUSH
95018: LD_INT 1000
95020: LESS
95021: IFFALSE 95035
// SetLives ( i , 1000 ) ;
95023: LD_VAR 0 1
95027: PPUSH
95028: LD_INT 1000
95030: PPUSH
95031: CALL_OW 234
95035: GO 95005
95037: POP
95038: POP
// end ;
95039: PPOPN 1
95041: END
// export function hHackInvincible ; var i ; begin
95042: LD_INT 0
95044: PPUSH
95045: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95046: LD_ADDR_VAR 0 2
95050: PUSH
95051: LD_INT 2
95053: PUSH
95054: LD_INT 21
95056: PUSH
95057: LD_INT 1
95059: PUSH
95060: EMPTY
95061: LIST
95062: LIST
95063: PUSH
95064: LD_INT 21
95066: PUSH
95067: LD_INT 2
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: EMPTY
95075: LIST
95076: LIST
95077: LIST
95078: PPUSH
95079: CALL_OW 69
95083: PUSH
95084: FOR_IN
95085: IFFALSE 95146
// if IsSelected ( i ) then
95087: LD_VAR 0 2
95091: PPUSH
95092: CALL_OW 306
95096: IFFALSE 95144
// begin if i in hInvincible then
95098: LD_VAR 0 2
95102: PUSH
95103: LD_EXP 172
95107: IN
95108: IFFALSE 95128
// hInvincible := hInvincible diff i else
95110: LD_ADDR_EXP 172
95114: PUSH
95115: LD_EXP 172
95119: PUSH
95120: LD_VAR 0 2
95124: DIFF
95125: ST_TO_ADDR
95126: GO 95144
// hInvincible := hInvincible union i ;
95128: LD_ADDR_EXP 172
95132: PUSH
95133: LD_EXP 172
95137: PUSH
95138: LD_VAR 0 2
95142: UNION
95143: ST_TO_ADDR
// end ;
95144: GO 95084
95146: POP
95147: POP
// end ;
95148: LD_VAR 0 1
95152: RET
// export function hHackInvisible ; var i , j ; begin
95153: LD_INT 0
95155: PPUSH
95156: PPUSH
95157: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95158: LD_ADDR_VAR 0 2
95162: PUSH
95163: LD_INT 21
95165: PUSH
95166: LD_INT 1
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PPUSH
95173: CALL_OW 69
95177: PUSH
95178: FOR_IN
95179: IFFALSE 95203
// if IsSelected ( i ) then
95181: LD_VAR 0 2
95185: PPUSH
95186: CALL_OW 306
95190: IFFALSE 95201
// ComForceInvisible ( i ) ;
95192: LD_VAR 0 2
95196: PPUSH
95197: CALL_OW 496
95201: GO 95178
95203: POP
95204: POP
// end ;
95205: LD_VAR 0 1
95209: RET
// export function hHackChangeYourSide ; begin
95210: LD_INT 0
95212: PPUSH
// if your_side = 8 then
95213: LD_OWVAR 2
95217: PUSH
95218: LD_INT 8
95220: EQUAL
95221: IFFALSE 95233
// your_side := 0 else
95223: LD_ADDR_OWVAR 2
95227: PUSH
95228: LD_INT 0
95230: ST_TO_ADDR
95231: GO 95247
// your_side := your_side + 1 ;
95233: LD_ADDR_OWVAR 2
95237: PUSH
95238: LD_OWVAR 2
95242: PUSH
95243: LD_INT 1
95245: PLUS
95246: ST_TO_ADDR
// end ;
95247: LD_VAR 0 1
95251: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95252: LD_INT 0
95254: PPUSH
95255: PPUSH
95256: PPUSH
// for i in all_units do
95257: LD_ADDR_VAR 0 2
95261: PUSH
95262: LD_OWVAR 3
95266: PUSH
95267: FOR_IN
95268: IFFALSE 95346
// if IsSelected ( i ) then
95270: LD_VAR 0 2
95274: PPUSH
95275: CALL_OW 306
95279: IFFALSE 95344
// begin j := GetSide ( i ) ;
95281: LD_ADDR_VAR 0 3
95285: PUSH
95286: LD_VAR 0 2
95290: PPUSH
95291: CALL_OW 255
95295: ST_TO_ADDR
// if j = 8 then
95296: LD_VAR 0 3
95300: PUSH
95301: LD_INT 8
95303: EQUAL
95304: IFFALSE 95316
// j := 0 else
95306: LD_ADDR_VAR 0 3
95310: PUSH
95311: LD_INT 0
95313: ST_TO_ADDR
95314: GO 95330
// j := j + 1 ;
95316: LD_ADDR_VAR 0 3
95320: PUSH
95321: LD_VAR 0 3
95325: PUSH
95326: LD_INT 1
95328: PLUS
95329: ST_TO_ADDR
// SetSide ( i , j ) ;
95330: LD_VAR 0 2
95334: PPUSH
95335: LD_VAR 0 3
95339: PPUSH
95340: CALL_OW 235
// end ;
95344: GO 95267
95346: POP
95347: POP
// end ;
95348: LD_VAR 0 1
95352: RET
// export function hHackFog ; begin
95353: LD_INT 0
95355: PPUSH
// FogOff ( true ) ;
95356: LD_INT 1
95358: PPUSH
95359: CALL_OW 344
// end ;
95363: LD_VAR 0 1
95367: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95368: LD_INT 0
95370: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95371: LD_VAR 0 1
95375: PPUSH
95376: LD_VAR 0 2
95380: PPUSH
95381: LD_VAR 0 3
95385: PPUSH
95386: LD_INT 1
95388: PPUSH
95389: LD_INT 1
95391: PPUSH
95392: CALL_OW 483
// CenterOnXY ( x , y ) ;
95396: LD_VAR 0 2
95400: PPUSH
95401: LD_VAR 0 3
95405: PPUSH
95406: CALL_OW 84
// end ; end_of_file
95410: LD_VAR 0 4
95414: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
95415: LD_INT 0
95417: PPUSH
95418: PPUSH
95419: PPUSH
95420: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
95421: LD_VAR 0 1
95425: PPUSH
95426: CALL_OW 264
95430: PUSH
95431: LD_EXP 106
95435: EQUAL
95436: IFFALSE 95508
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
95438: LD_INT 68
95440: PPUSH
95441: LD_VAR 0 1
95445: PPUSH
95446: CALL_OW 255
95450: PPUSH
95451: CALL_OW 321
95455: PUSH
95456: LD_INT 2
95458: EQUAL
95459: IFFALSE 95471
// eff := 70 else
95461: LD_ADDR_VAR 0 4
95465: PUSH
95466: LD_INT 70
95468: ST_TO_ADDR
95469: GO 95479
// eff := 30 ;
95471: LD_ADDR_VAR 0 4
95475: PUSH
95476: LD_INT 30
95478: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
95479: LD_VAR 0 1
95483: PPUSH
95484: CALL_OW 250
95488: PPUSH
95489: LD_VAR 0 1
95493: PPUSH
95494: CALL_OW 251
95498: PPUSH
95499: LD_VAR 0 4
95503: PPUSH
95504: CALL_OW 495
// end ; end ;
95508: LD_VAR 0 2
95512: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
95513: LD_INT 0
95515: PPUSH
// end ;
95516: LD_VAR 0 4
95520: RET
// export function SOS_Command ( cmd ) ; begin
95521: LD_INT 0
95523: PPUSH
// end ;
95524: LD_VAR 0 2
95528: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
95529: LD_INT 0
95531: PPUSH
// if cmd = 121 then
95532: LD_VAR 0 1
95536: PUSH
95537: LD_INT 121
95539: EQUAL
95540: IFFALSE 95542
// end ;
95542: LD_VAR 0 6
95546: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
95547: LD_INT 0
95549: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
95550: LD_VAR 0 1
95554: PUSH
95555: LD_INT 250
95557: EQUAL
95558: PUSH
95559: LD_VAR 0 2
95563: PPUSH
95564: CALL_OW 264
95568: PUSH
95569: LD_EXP 109
95573: EQUAL
95574: AND
95575: IFFALSE 95596
// MinerPlaceMine ( unit , x , y ) ;
95577: LD_VAR 0 2
95581: PPUSH
95582: LD_VAR 0 4
95586: PPUSH
95587: LD_VAR 0 5
95591: PPUSH
95592: CALL 97945 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
95596: LD_VAR 0 1
95600: PUSH
95601: LD_INT 251
95603: EQUAL
95604: PUSH
95605: LD_VAR 0 2
95609: PPUSH
95610: CALL_OW 264
95614: PUSH
95615: LD_EXP 109
95619: EQUAL
95620: AND
95621: IFFALSE 95642
// MinerDetonateMine ( unit , x , y ) ;
95623: LD_VAR 0 2
95627: PPUSH
95628: LD_VAR 0 4
95632: PPUSH
95633: LD_VAR 0 5
95637: PPUSH
95638: CALL 98222 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
95642: LD_VAR 0 1
95646: PUSH
95647: LD_INT 252
95649: EQUAL
95650: PUSH
95651: LD_VAR 0 2
95655: PPUSH
95656: CALL_OW 264
95660: PUSH
95661: LD_EXP 109
95665: EQUAL
95666: AND
95667: IFFALSE 95688
// MinerCreateMinefield ( unit , x , y ) ;
95669: LD_VAR 0 2
95673: PPUSH
95674: LD_VAR 0 4
95678: PPUSH
95679: LD_VAR 0 5
95683: PPUSH
95684: CALL 98639 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
95688: LD_VAR 0 1
95692: PUSH
95693: LD_INT 253
95695: EQUAL
95696: PUSH
95697: LD_VAR 0 2
95701: PPUSH
95702: CALL_OW 257
95706: PUSH
95707: LD_INT 5
95709: EQUAL
95710: AND
95711: IFFALSE 95732
// ComBinocular ( unit , x , y ) ;
95713: LD_VAR 0 2
95717: PPUSH
95718: LD_VAR 0 4
95722: PPUSH
95723: LD_VAR 0 5
95727: PPUSH
95728: CALL 99010 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
95732: LD_VAR 0 1
95736: PUSH
95737: LD_INT 254
95739: EQUAL
95740: PUSH
95741: LD_VAR 0 2
95745: PPUSH
95746: CALL_OW 264
95750: PUSH
95751: LD_EXP 104
95755: EQUAL
95756: AND
95757: PUSH
95758: LD_VAR 0 3
95762: PPUSH
95763: CALL_OW 263
95767: PUSH
95768: LD_INT 3
95770: EQUAL
95771: AND
95772: IFFALSE 95788
// HackDestroyVehicle ( unit , selectedUnit ) ;
95774: LD_VAR 0 2
95778: PPUSH
95779: LD_VAR 0 3
95783: PPUSH
95784: CALL 97305 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95788: LD_VAR 0 1
95792: PUSH
95793: LD_INT 255
95795: EQUAL
95796: PUSH
95797: LD_VAR 0 2
95801: PPUSH
95802: CALL_OW 264
95806: PUSH
95807: LD_INT 14
95809: PUSH
95810: LD_INT 53
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: IN
95817: AND
95818: PUSH
95819: LD_VAR 0 4
95823: PPUSH
95824: LD_VAR 0 5
95828: PPUSH
95829: CALL_OW 488
95833: AND
95834: IFFALSE 95858
// CutTreeXYR ( unit , x , y , 12 ) ;
95836: LD_VAR 0 2
95840: PPUSH
95841: LD_VAR 0 4
95845: PPUSH
95846: LD_VAR 0 5
95850: PPUSH
95851: LD_INT 12
95853: PPUSH
95854: CALL 95871 0 4
// end ;
95858: LD_VAR 0 6
95862: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
95863: LD_INT 0
95865: PPUSH
// end ;
95866: LD_VAR 0 4
95870: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
95871: LD_INT 0
95873: PPUSH
95874: PPUSH
95875: PPUSH
95876: PPUSH
95877: PPUSH
95878: PPUSH
95879: PPUSH
95880: PPUSH
95881: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
95882: LD_VAR 0 1
95886: NOT
95887: PUSH
95888: LD_VAR 0 2
95892: PPUSH
95893: LD_VAR 0 3
95897: PPUSH
95898: CALL_OW 488
95902: NOT
95903: OR
95904: PUSH
95905: LD_VAR 0 4
95909: NOT
95910: OR
95911: IFFALSE 95915
// exit ;
95913: GO 96255
// list := [ ] ;
95915: LD_ADDR_VAR 0 13
95919: PUSH
95920: EMPTY
95921: ST_TO_ADDR
// if x - r < 0 then
95922: LD_VAR 0 2
95926: PUSH
95927: LD_VAR 0 4
95931: MINUS
95932: PUSH
95933: LD_INT 0
95935: LESS
95936: IFFALSE 95948
// min_x := 0 else
95938: LD_ADDR_VAR 0 7
95942: PUSH
95943: LD_INT 0
95945: ST_TO_ADDR
95946: GO 95964
// min_x := x - r ;
95948: LD_ADDR_VAR 0 7
95952: PUSH
95953: LD_VAR 0 2
95957: PUSH
95958: LD_VAR 0 4
95962: MINUS
95963: ST_TO_ADDR
// if y - r < 0 then
95964: LD_VAR 0 3
95968: PUSH
95969: LD_VAR 0 4
95973: MINUS
95974: PUSH
95975: LD_INT 0
95977: LESS
95978: IFFALSE 95990
// min_y := 0 else
95980: LD_ADDR_VAR 0 8
95984: PUSH
95985: LD_INT 0
95987: ST_TO_ADDR
95988: GO 96006
// min_y := y - r ;
95990: LD_ADDR_VAR 0 8
95994: PUSH
95995: LD_VAR 0 3
95999: PUSH
96000: LD_VAR 0 4
96004: MINUS
96005: ST_TO_ADDR
// max_x := x + r ;
96006: LD_ADDR_VAR 0 9
96010: PUSH
96011: LD_VAR 0 2
96015: PUSH
96016: LD_VAR 0 4
96020: PLUS
96021: ST_TO_ADDR
// max_y := y + r ;
96022: LD_ADDR_VAR 0 10
96026: PUSH
96027: LD_VAR 0 3
96031: PUSH
96032: LD_VAR 0 4
96036: PLUS
96037: ST_TO_ADDR
// for _x = min_x to max_x do
96038: LD_ADDR_VAR 0 11
96042: PUSH
96043: DOUBLE
96044: LD_VAR 0 7
96048: DEC
96049: ST_TO_ADDR
96050: LD_VAR 0 9
96054: PUSH
96055: FOR_TO
96056: IFFALSE 96173
// for _y = min_y to max_y do
96058: LD_ADDR_VAR 0 12
96062: PUSH
96063: DOUBLE
96064: LD_VAR 0 8
96068: DEC
96069: ST_TO_ADDR
96070: LD_VAR 0 10
96074: PUSH
96075: FOR_TO
96076: IFFALSE 96169
// begin if not ValidHex ( _x , _y ) then
96078: LD_VAR 0 11
96082: PPUSH
96083: LD_VAR 0 12
96087: PPUSH
96088: CALL_OW 488
96092: NOT
96093: IFFALSE 96097
// continue ;
96095: GO 96075
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
96097: LD_VAR 0 11
96101: PPUSH
96102: LD_VAR 0 12
96106: PPUSH
96107: CALL_OW 351
96111: PUSH
96112: LD_VAR 0 11
96116: PPUSH
96117: LD_VAR 0 12
96121: PPUSH
96122: CALL_OW 554
96126: AND
96127: IFFALSE 96167
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
96129: LD_ADDR_VAR 0 13
96133: PUSH
96134: LD_VAR 0 13
96138: PPUSH
96139: LD_VAR 0 13
96143: PUSH
96144: LD_INT 1
96146: PLUS
96147: PPUSH
96148: LD_VAR 0 11
96152: PUSH
96153: LD_VAR 0 12
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: PPUSH
96162: CALL_OW 2
96166: ST_TO_ADDR
// end ;
96167: GO 96075
96169: POP
96170: POP
96171: GO 96055
96173: POP
96174: POP
// if not list then
96175: LD_VAR 0 13
96179: NOT
96180: IFFALSE 96184
// exit ;
96182: GO 96255
// for i in list do
96184: LD_ADDR_VAR 0 6
96188: PUSH
96189: LD_VAR 0 13
96193: PUSH
96194: FOR_IN
96195: IFFALSE 96253
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
96197: LD_VAR 0 1
96201: PPUSH
96202: LD_STRING M
96204: PUSH
96205: LD_VAR 0 6
96209: PUSH
96210: LD_INT 1
96212: ARRAY
96213: PUSH
96214: LD_VAR 0 6
96218: PUSH
96219: LD_INT 2
96221: ARRAY
96222: PUSH
96223: LD_INT 0
96225: PUSH
96226: LD_INT 0
96228: PUSH
96229: LD_INT 0
96231: PUSH
96232: LD_INT 0
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: PUSH
96244: EMPTY
96245: LIST
96246: PPUSH
96247: CALL_OW 447
96251: GO 96194
96253: POP
96254: POP
// end ;
96255: LD_VAR 0 5
96259: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
96260: LD_EXP 175
96264: NOT
96265: IFFALSE 96315
96267: GO 96269
96269: DISABLE
// begin initHack := true ;
96270: LD_ADDR_EXP 175
96274: PUSH
96275: LD_INT 1
96277: ST_TO_ADDR
// hackTanks := [ ] ;
96278: LD_ADDR_EXP 176
96282: PUSH
96283: EMPTY
96284: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
96285: LD_ADDR_EXP 177
96289: PUSH
96290: EMPTY
96291: ST_TO_ADDR
// hackLimit := 3 ;
96292: LD_ADDR_EXP 178
96296: PUSH
96297: LD_INT 3
96299: ST_TO_ADDR
// hackDist := 12 ;
96300: LD_ADDR_EXP 179
96304: PUSH
96305: LD_INT 12
96307: ST_TO_ADDR
// hackCounter := [ ] ;
96308: LD_ADDR_EXP 180
96312: PUSH
96313: EMPTY
96314: ST_TO_ADDR
// end ;
96315: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
96316: LD_EXP 175
96320: PUSH
96321: LD_INT 34
96323: PUSH
96324: LD_EXP 104
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PPUSH
96333: CALL_OW 69
96337: AND
96338: IFFALSE 96593
96340: GO 96342
96342: DISABLE
96343: LD_INT 0
96345: PPUSH
96346: PPUSH
// begin enable ;
96347: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
96348: LD_ADDR_VAR 0 1
96352: PUSH
96353: LD_INT 34
96355: PUSH
96356: LD_EXP 104
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: PPUSH
96365: CALL_OW 69
96369: PUSH
96370: FOR_IN
96371: IFFALSE 96591
// begin if not i in hackTanks then
96373: LD_VAR 0 1
96377: PUSH
96378: LD_EXP 176
96382: IN
96383: NOT
96384: IFFALSE 96467
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
96386: LD_ADDR_EXP 176
96390: PUSH
96391: LD_EXP 176
96395: PPUSH
96396: LD_EXP 176
96400: PUSH
96401: LD_INT 1
96403: PLUS
96404: PPUSH
96405: LD_VAR 0 1
96409: PPUSH
96410: CALL_OW 1
96414: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
96415: LD_ADDR_EXP 177
96419: PUSH
96420: LD_EXP 177
96424: PPUSH
96425: LD_EXP 177
96429: PUSH
96430: LD_INT 1
96432: PLUS
96433: PPUSH
96434: EMPTY
96435: PPUSH
96436: CALL_OW 1
96440: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
96441: LD_ADDR_EXP 180
96445: PUSH
96446: LD_EXP 180
96450: PPUSH
96451: LD_EXP 180
96455: PUSH
96456: LD_INT 1
96458: PLUS
96459: PPUSH
96460: EMPTY
96461: PPUSH
96462: CALL_OW 1
96466: ST_TO_ADDR
// end ; if not IsOk ( i ) then
96467: LD_VAR 0 1
96471: PPUSH
96472: CALL_OW 302
96476: NOT
96477: IFFALSE 96490
// begin HackUnlinkAll ( i ) ;
96479: LD_VAR 0 1
96483: PPUSH
96484: CALL 96596 0 1
// continue ;
96488: GO 96370
// end ; HackCheckCapturedStatus ( i ) ;
96490: LD_VAR 0 1
96494: PPUSH
96495: CALL 97039 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
96499: LD_ADDR_VAR 0 2
96503: PUSH
96504: LD_INT 81
96506: PUSH
96507: LD_VAR 0 1
96511: PPUSH
96512: CALL_OW 255
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 33
96523: PUSH
96524: LD_INT 3
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 91
96533: PUSH
96534: LD_VAR 0 1
96538: PUSH
96539: LD_EXP 179
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 50
96551: PUSH
96552: EMPTY
96553: LIST
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: PPUSH
96561: CALL_OW 69
96565: ST_TO_ADDR
// if not tmp then
96566: LD_VAR 0 2
96570: NOT
96571: IFFALSE 96575
// continue ;
96573: GO 96370
// HackLink ( i , tmp ) ;
96575: LD_VAR 0 1
96579: PPUSH
96580: LD_VAR 0 2
96584: PPUSH
96585: CALL 96732 0 2
// end ;
96589: GO 96370
96591: POP
96592: POP
// end ;
96593: PPOPN 2
96595: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
96596: LD_INT 0
96598: PPUSH
96599: PPUSH
96600: PPUSH
// if not hack in hackTanks then
96601: LD_VAR 0 1
96605: PUSH
96606: LD_EXP 176
96610: IN
96611: NOT
96612: IFFALSE 96616
// exit ;
96614: GO 96727
// index := GetElementIndex ( hackTanks , hack ) ;
96616: LD_ADDR_VAR 0 4
96620: PUSH
96621: LD_EXP 176
96625: PPUSH
96626: LD_VAR 0 1
96630: PPUSH
96631: CALL 19068 0 2
96635: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
96636: LD_EXP 177
96640: PUSH
96641: LD_VAR 0 4
96645: ARRAY
96646: IFFALSE 96727
// begin for i in hackTanksCaptured [ index ] do
96648: LD_ADDR_VAR 0 3
96652: PUSH
96653: LD_EXP 177
96657: PUSH
96658: LD_VAR 0 4
96662: ARRAY
96663: PUSH
96664: FOR_IN
96665: IFFALSE 96691
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
96667: LD_VAR 0 3
96671: PUSH
96672: LD_INT 1
96674: ARRAY
96675: PPUSH
96676: LD_VAR 0 3
96680: PUSH
96681: LD_INT 2
96683: ARRAY
96684: PPUSH
96685: CALL_OW 235
96689: GO 96664
96691: POP
96692: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
96693: LD_ADDR_EXP 177
96697: PUSH
96698: LD_EXP 177
96702: PPUSH
96703: LD_VAR 0 4
96707: PPUSH
96708: EMPTY
96709: PPUSH
96710: CALL_OW 1
96714: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
96715: LD_VAR 0 1
96719: PPUSH
96720: LD_INT 0
96722: PPUSH
96723: CALL_OW 505
// end ; end ;
96727: LD_VAR 0 2
96731: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
96732: LD_INT 0
96734: PPUSH
96735: PPUSH
96736: PPUSH
// if not hack in hackTanks or not vehicles then
96737: LD_VAR 0 1
96741: PUSH
96742: LD_EXP 176
96746: IN
96747: NOT
96748: PUSH
96749: LD_VAR 0 2
96753: NOT
96754: OR
96755: IFFALSE 96759
// exit ;
96757: GO 97034
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96759: LD_ADDR_VAR 0 2
96763: PUSH
96764: LD_VAR 0 1
96768: PPUSH
96769: LD_VAR 0 2
96773: PPUSH
96774: LD_INT 1
96776: PPUSH
96777: LD_INT 1
96779: PPUSH
96780: CALL 19718 0 4
96784: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96785: LD_ADDR_VAR 0 5
96789: PUSH
96790: LD_EXP 176
96794: PPUSH
96795: LD_VAR 0 1
96799: PPUSH
96800: CALL 19068 0 2
96804: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96805: LD_EXP 177
96809: PUSH
96810: LD_VAR 0 5
96814: ARRAY
96815: PUSH
96816: LD_EXP 178
96820: LESS
96821: IFFALSE 97010
// begin for i := 1 to vehicles do
96823: LD_ADDR_VAR 0 4
96827: PUSH
96828: DOUBLE
96829: LD_INT 1
96831: DEC
96832: ST_TO_ADDR
96833: LD_VAR 0 2
96837: PUSH
96838: FOR_TO
96839: IFFALSE 97008
// begin if hackTanksCaptured [ index ] = hackLimit then
96841: LD_EXP 177
96845: PUSH
96846: LD_VAR 0 5
96850: ARRAY
96851: PUSH
96852: LD_EXP 178
96856: EQUAL
96857: IFFALSE 96861
// break ;
96859: GO 97008
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96861: LD_ADDR_EXP 180
96865: PUSH
96866: LD_EXP 180
96870: PPUSH
96871: LD_VAR 0 5
96875: PPUSH
96876: LD_EXP 180
96880: PUSH
96881: LD_VAR 0 5
96885: ARRAY
96886: PUSH
96887: LD_INT 1
96889: PLUS
96890: PPUSH
96891: CALL_OW 1
96895: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96896: LD_ADDR_EXP 177
96900: PUSH
96901: LD_EXP 177
96905: PPUSH
96906: LD_VAR 0 5
96910: PUSH
96911: LD_EXP 177
96915: PUSH
96916: LD_VAR 0 5
96920: ARRAY
96921: PUSH
96922: LD_INT 1
96924: PLUS
96925: PUSH
96926: EMPTY
96927: LIST
96928: LIST
96929: PPUSH
96930: LD_VAR 0 2
96934: PUSH
96935: LD_VAR 0 4
96939: ARRAY
96940: PUSH
96941: LD_VAR 0 2
96945: PUSH
96946: LD_VAR 0 4
96950: ARRAY
96951: PPUSH
96952: CALL_OW 255
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PPUSH
96961: CALL 19283 0 3
96965: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96966: LD_VAR 0 2
96970: PUSH
96971: LD_VAR 0 4
96975: ARRAY
96976: PPUSH
96977: LD_VAR 0 1
96981: PPUSH
96982: CALL_OW 255
96986: PPUSH
96987: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96991: LD_VAR 0 2
96995: PUSH
96996: LD_VAR 0 4
97000: ARRAY
97001: PPUSH
97002: CALL_OW 141
// end ;
97006: GO 96838
97008: POP
97009: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97010: LD_VAR 0 1
97014: PPUSH
97015: LD_EXP 177
97019: PUSH
97020: LD_VAR 0 5
97024: ARRAY
97025: PUSH
97026: LD_INT 0
97028: PLUS
97029: PPUSH
97030: CALL_OW 505
// end ;
97034: LD_VAR 0 3
97038: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
97039: LD_INT 0
97041: PPUSH
97042: PPUSH
97043: PPUSH
97044: PPUSH
// if not hack in hackTanks then
97045: LD_VAR 0 1
97049: PUSH
97050: LD_EXP 176
97054: IN
97055: NOT
97056: IFFALSE 97060
// exit ;
97058: GO 97300
// index := GetElementIndex ( hackTanks , hack ) ;
97060: LD_ADDR_VAR 0 4
97064: PUSH
97065: LD_EXP 176
97069: PPUSH
97070: LD_VAR 0 1
97074: PPUSH
97075: CALL 19068 0 2
97079: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
97080: LD_ADDR_VAR 0 3
97084: PUSH
97085: DOUBLE
97086: LD_EXP 177
97090: PUSH
97091: LD_VAR 0 4
97095: ARRAY
97096: INC
97097: ST_TO_ADDR
97098: LD_INT 1
97100: PUSH
97101: FOR_DOWNTO
97102: IFFALSE 97274
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
97104: LD_ADDR_VAR 0 5
97108: PUSH
97109: LD_EXP 177
97113: PUSH
97114: LD_VAR 0 4
97118: ARRAY
97119: PUSH
97120: LD_VAR 0 3
97124: ARRAY
97125: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
97126: LD_VAR 0 5
97130: PUSH
97131: LD_INT 1
97133: ARRAY
97134: PPUSH
97135: CALL_OW 302
97139: NOT
97140: PUSH
97141: LD_VAR 0 5
97145: PUSH
97146: LD_INT 1
97148: ARRAY
97149: PPUSH
97150: CALL_OW 255
97154: PUSH
97155: LD_VAR 0 1
97159: PPUSH
97160: CALL_OW 255
97164: NONEQUAL
97165: OR
97166: IFFALSE 97272
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
97168: LD_VAR 0 5
97172: PUSH
97173: LD_INT 1
97175: ARRAY
97176: PPUSH
97177: CALL_OW 305
97181: PUSH
97182: LD_VAR 0 5
97186: PUSH
97187: LD_INT 1
97189: ARRAY
97190: PPUSH
97191: CALL_OW 255
97195: PUSH
97196: LD_VAR 0 1
97200: PPUSH
97201: CALL_OW 255
97205: EQUAL
97206: AND
97207: IFFALSE 97231
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
97209: LD_VAR 0 5
97213: PUSH
97214: LD_INT 1
97216: ARRAY
97217: PPUSH
97218: LD_VAR 0 5
97222: PUSH
97223: LD_INT 2
97225: ARRAY
97226: PPUSH
97227: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
97231: LD_ADDR_EXP 177
97235: PUSH
97236: LD_EXP 177
97240: PPUSH
97241: LD_VAR 0 4
97245: PPUSH
97246: LD_EXP 177
97250: PUSH
97251: LD_VAR 0 4
97255: ARRAY
97256: PPUSH
97257: LD_VAR 0 3
97261: PPUSH
97262: CALL_OW 3
97266: PPUSH
97267: CALL_OW 1
97271: ST_TO_ADDR
// end ; end ;
97272: GO 97101
97274: POP
97275: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97276: LD_VAR 0 1
97280: PPUSH
97281: LD_EXP 177
97285: PUSH
97286: LD_VAR 0 4
97290: ARRAY
97291: PUSH
97292: LD_INT 0
97294: PLUS
97295: PPUSH
97296: CALL_OW 505
// end ;
97300: LD_VAR 0 2
97304: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
97305: LD_INT 0
97307: PPUSH
97308: PPUSH
97309: PPUSH
97310: PPUSH
// if not hack in hackTanks then
97311: LD_VAR 0 1
97315: PUSH
97316: LD_EXP 176
97320: IN
97321: NOT
97322: IFFALSE 97326
// exit ;
97324: GO 97411
// index := GetElementIndex ( hackTanks , hack ) ;
97326: LD_ADDR_VAR 0 5
97330: PUSH
97331: LD_EXP 176
97335: PPUSH
97336: LD_VAR 0 1
97340: PPUSH
97341: CALL 19068 0 2
97345: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
97346: LD_ADDR_VAR 0 4
97350: PUSH
97351: DOUBLE
97352: LD_INT 1
97354: DEC
97355: ST_TO_ADDR
97356: LD_EXP 177
97360: PUSH
97361: LD_VAR 0 5
97365: ARRAY
97366: PUSH
97367: FOR_TO
97368: IFFALSE 97409
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
97370: LD_EXP 177
97374: PUSH
97375: LD_VAR 0 5
97379: ARRAY
97380: PUSH
97381: LD_VAR 0 4
97385: ARRAY
97386: PUSH
97387: LD_INT 1
97389: ARRAY
97390: PUSH
97391: LD_VAR 0 2
97395: EQUAL
97396: IFFALSE 97407
// KillUnit ( vehicle ) ;
97398: LD_VAR 0 2
97402: PPUSH
97403: CALL_OW 66
97407: GO 97367
97409: POP
97410: POP
// end ;
97411: LD_VAR 0 3
97415: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
97416: LD_EXP 181
97420: NOT
97421: IFFALSE 97456
97423: GO 97425
97425: DISABLE
// begin initMiner := true ;
97426: LD_ADDR_EXP 181
97430: PUSH
97431: LD_INT 1
97433: ST_TO_ADDR
// minersList := [ ] ;
97434: LD_ADDR_EXP 182
97438: PUSH
97439: EMPTY
97440: ST_TO_ADDR
// minerMinesList := [ ] ;
97441: LD_ADDR_EXP 183
97445: PUSH
97446: EMPTY
97447: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
97448: LD_ADDR_EXP 184
97452: PUSH
97453: LD_INT 5
97455: ST_TO_ADDR
// end ;
97456: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
97457: LD_EXP 181
97461: PUSH
97462: LD_INT 34
97464: PUSH
97465: LD_EXP 109
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PPUSH
97474: CALL_OW 69
97478: AND
97479: IFFALSE 97942
97481: GO 97483
97483: DISABLE
97484: LD_INT 0
97486: PPUSH
97487: PPUSH
97488: PPUSH
97489: PPUSH
// begin enable ;
97490: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
97491: LD_ADDR_VAR 0 1
97495: PUSH
97496: LD_INT 34
97498: PUSH
97499: LD_EXP 109
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PPUSH
97508: CALL_OW 69
97512: PUSH
97513: FOR_IN
97514: IFFALSE 97586
// begin if not i in minersList then
97516: LD_VAR 0 1
97520: PUSH
97521: LD_EXP 182
97525: IN
97526: NOT
97527: IFFALSE 97584
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
97529: LD_ADDR_EXP 182
97533: PUSH
97534: LD_EXP 182
97538: PPUSH
97539: LD_EXP 182
97543: PUSH
97544: LD_INT 1
97546: PLUS
97547: PPUSH
97548: LD_VAR 0 1
97552: PPUSH
97553: CALL_OW 1
97557: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
97558: LD_ADDR_EXP 183
97562: PUSH
97563: LD_EXP 183
97567: PPUSH
97568: LD_EXP 183
97572: PUSH
97573: LD_INT 1
97575: PLUS
97576: PPUSH
97577: EMPTY
97578: PPUSH
97579: CALL_OW 1
97583: ST_TO_ADDR
// end end ;
97584: GO 97513
97586: POP
97587: POP
// for i := minerMinesList downto 1 do
97588: LD_ADDR_VAR 0 1
97592: PUSH
97593: DOUBLE
97594: LD_EXP 183
97598: INC
97599: ST_TO_ADDR
97600: LD_INT 1
97602: PUSH
97603: FOR_DOWNTO
97604: IFFALSE 97940
// begin if IsLive ( minersList [ i ] ) then
97606: LD_EXP 182
97610: PUSH
97611: LD_VAR 0 1
97615: ARRAY
97616: PPUSH
97617: CALL_OW 300
97621: IFFALSE 97649
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
97623: LD_EXP 182
97627: PUSH
97628: LD_VAR 0 1
97632: ARRAY
97633: PPUSH
97634: LD_EXP 183
97638: PUSH
97639: LD_VAR 0 1
97643: ARRAY
97644: PPUSH
97645: CALL_OW 505
// if not minerMinesList [ i ] then
97649: LD_EXP 183
97653: PUSH
97654: LD_VAR 0 1
97658: ARRAY
97659: NOT
97660: IFFALSE 97664
// continue ;
97662: GO 97603
// for j := minerMinesList [ i ] downto 1 do
97664: LD_ADDR_VAR 0 2
97668: PUSH
97669: DOUBLE
97670: LD_EXP 183
97674: PUSH
97675: LD_VAR 0 1
97679: ARRAY
97680: INC
97681: ST_TO_ADDR
97682: LD_INT 1
97684: PUSH
97685: FOR_DOWNTO
97686: IFFALSE 97936
// begin side := GetSide ( minersList [ i ] ) ;
97688: LD_ADDR_VAR 0 3
97692: PUSH
97693: LD_EXP 182
97697: PUSH
97698: LD_VAR 0 1
97702: ARRAY
97703: PPUSH
97704: CALL_OW 255
97708: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97709: LD_ADDR_VAR 0 4
97713: PUSH
97714: LD_EXP 183
97718: PUSH
97719: LD_VAR 0 1
97723: ARRAY
97724: PUSH
97725: LD_VAR 0 2
97729: ARRAY
97730: PUSH
97731: LD_INT 1
97733: ARRAY
97734: PPUSH
97735: LD_EXP 183
97739: PUSH
97740: LD_VAR 0 1
97744: ARRAY
97745: PUSH
97746: LD_VAR 0 2
97750: ARRAY
97751: PUSH
97752: LD_INT 2
97754: ARRAY
97755: PPUSH
97756: CALL_OW 428
97760: ST_TO_ADDR
// if not tmp then
97761: LD_VAR 0 4
97765: NOT
97766: IFFALSE 97770
// continue ;
97768: GO 97685
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97770: LD_VAR 0 4
97774: PUSH
97775: LD_INT 81
97777: PUSH
97778: LD_VAR 0 3
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PPUSH
97787: CALL_OW 69
97791: IN
97792: PUSH
97793: LD_EXP 183
97797: PUSH
97798: LD_VAR 0 1
97802: ARRAY
97803: PUSH
97804: LD_VAR 0 2
97808: ARRAY
97809: PUSH
97810: LD_INT 1
97812: ARRAY
97813: PPUSH
97814: LD_EXP 183
97818: PUSH
97819: LD_VAR 0 1
97823: ARRAY
97824: PUSH
97825: LD_VAR 0 2
97829: ARRAY
97830: PUSH
97831: LD_INT 2
97833: ARRAY
97834: PPUSH
97835: CALL_OW 458
97839: AND
97840: IFFALSE 97934
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97842: LD_EXP 183
97846: PUSH
97847: LD_VAR 0 1
97851: ARRAY
97852: PUSH
97853: LD_VAR 0 2
97857: ARRAY
97858: PUSH
97859: LD_INT 1
97861: ARRAY
97862: PPUSH
97863: LD_EXP 183
97867: PUSH
97868: LD_VAR 0 1
97872: ARRAY
97873: PUSH
97874: LD_VAR 0 2
97878: ARRAY
97879: PUSH
97880: LD_INT 2
97882: ARRAY
97883: PPUSH
97884: LD_VAR 0 3
97888: PPUSH
97889: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97893: LD_ADDR_EXP 183
97897: PUSH
97898: LD_EXP 183
97902: PPUSH
97903: LD_VAR 0 1
97907: PPUSH
97908: LD_EXP 183
97912: PUSH
97913: LD_VAR 0 1
97917: ARRAY
97918: PPUSH
97919: LD_VAR 0 2
97923: PPUSH
97924: CALL_OW 3
97928: PPUSH
97929: CALL_OW 1
97933: ST_TO_ADDR
// end ; end ;
97934: GO 97685
97936: POP
97937: POP
// end ;
97938: GO 97603
97940: POP
97941: POP
// end ;
97942: PPOPN 4
97944: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
97945: LD_INT 0
97947: PPUSH
97948: PPUSH
// result := false ;
97949: LD_ADDR_VAR 0 4
97953: PUSH
97954: LD_INT 0
97956: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97957: LD_VAR 0 1
97961: PPUSH
97962: CALL_OW 264
97966: PUSH
97967: LD_EXP 109
97971: EQUAL
97972: NOT
97973: IFFALSE 97977
// exit ;
97975: GO 98217
// index := GetElementIndex ( minersList , unit ) ;
97977: LD_ADDR_VAR 0 5
97981: PUSH
97982: LD_EXP 182
97986: PPUSH
97987: LD_VAR 0 1
97991: PPUSH
97992: CALL 19068 0 2
97996: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97997: LD_EXP 183
98001: PUSH
98002: LD_VAR 0 5
98006: ARRAY
98007: PUSH
98008: LD_EXP 184
98012: GREATEREQUAL
98013: IFFALSE 98017
// exit ;
98015: GO 98217
// ComMoveXY ( unit , x , y ) ;
98017: LD_VAR 0 1
98021: PPUSH
98022: LD_VAR 0 2
98026: PPUSH
98027: LD_VAR 0 3
98031: PPUSH
98032: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98036: LD_INT 35
98038: PPUSH
98039: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
98043: LD_VAR 0 1
98047: PPUSH
98048: LD_VAR 0 2
98052: PPUSH
98053: LD_VAR 0 3
98057: PPUSH
98058: CALL 49465 0 3
98062: NOT
98063: PUSH
98064: LD_VAR 0 1
98068: PPUSH
98069: CALL_OW 314
98073: AND
98074: IFFALSE 98078
// exit ;
98076: GO 98217
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
98078: LD_VAR 0 2
98082: PPUSH
98083: LD_VAR 0 3
98087: PPUSH
98088: CALL_OW 428
98092: PUSH
98093: LD_VAR 0 1
98097: EQUAL
98098: PUSH
98099: LD_VAR 0 1
98103: PPUSH
98104: CALL_OW 314
98108: NOT
98109: AND
98110: IFFALSE 98036
// PlaySoundXY ( x , y , PlantMine ) ;
98112: LD_VAR 0 2
98116: PPUSH
98117: LD_VAR 0 3
98121: PPUSH
98122: LD_STRING PlantMine
98124: PPUSH
98125: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
98129: LD_VAR 0 2
98133: PPUSH
98134: LD_VAR 0 3
98138: PPUSH
98139: LD_VAR 0 1
98143: PPUSH
98144: CALL_OW 255
98148: PPUSH
98149: LD_INT 0
98151: PPUSH
98152: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
98156: LD_ADDR_EXP 183
98160: PUSH
98161: LD_EXP 183
98165: PPUSH
98166: LD_VAR 0 5
98170: PUSH
98171: LD_EXP 183
98175: PUSH
98176: LD_VAR 0 5
98180: ARRAY
98181: PUSH
98182: LD_INT 1
98184: PLUS
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: PPUSH
98190: LD_VAR 0 2
98194: PUSH
98195: LD_VAR 0 3
98199: PUSH
98200: EMPTY
98201: LIST
98202: LIST
98203: PPUSH
98204: CALL 19283 0 3
98208: ST_TO_ADDR
// result := true ;
98209: LD_ADDR_VAR 0 4
98213: PUSH
98214: LD_INT 1
98216: ST_TO_ADDR
// end ;
98217: LD_VAR 0 4
98221: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
98222: LD_INT 0
98224: PPUSH
98225: PPUSH
98226: PPUSH
// if not unit in minersList then
98227: LD_VAR 0 1
98231: PUSH
98232: LD_EXP 182
98236: IN
98237: NOT
98238: IFFALSE 98242
// exit ;
98240: GO 98634
// index := GetElementIndex ( minersList , unit ) ;
98242: LD_ADDR_VAR 0 6
98246: PUSH
98247: LD_EXP 182
98251: PPUSH
98252: LD_VAR 0 1
98256: PPUSH
98257: CALL 19068 0 2
98261: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
98262: LD_ADDR_VAR 0 5
98266: PUSH
98267: DOUBLE
98268: LD_EXP 183
98272: PUSH
98273: LD_VAR 0 6
98277: ARRAY
98278: INC
98279: ST_TO_ADDR
98280: LD_INT 1
98282: PUSH
98283: FOR_DOWNTO
98284: IFFALSE 98445
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
98286: LD_EXP 183
98290: PUSH
98291: LD_VAR 0 6
98295: ARRAY
98296: PUSH
98297: LD_VAR 0 5
98301: ARRAY
98302: PUSH
98303: LD_INT 1
98305: ARRAY
98306: PUSH
98307: LD_VAR 0 2
98311: EQUAL
98312: PUSH
98313: LD_EXP 183
98317: PUSH
98318: LD_VAR 0 6
98322: ARRAY
98323: PUSH
98324: LD_VAR 0 5
98328: ARRAY
98329: PUSH
98330: LD_INT 2
98332: ARRAY
98333: PUSH
98334: LD_VAR 0 3
98338: EQUAL
98339: AND
98340: IFFALSE 98443
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98342: LD_EXP 183
98346: PUSH
98347: LD_VAR 0 6
98351: ARRAY
98352: PUSH
98353: LD_VAR 0 5
98357: ARRAY
98358: PUSH
98359: LD_INT 1
98361: ARRAY
98362: PPUSH
98363: LD_EXP 183
98367: PUSH
98368: LD_VAR 0 6
98372: ARRAY
98373: PUSH
98374: LD_VAR 0 5
98378: ARRAY
98379: PUSH
98380: LD_INT 2
98382: ARRAY
98383: PPUSH
98384: LD_VAR 0 1
98388: PPUSH
98389: CALL_OW 255
98393: PPUSH
98394: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98398: LD_ADDR_EXP 183
98402: PUSH
98403: LD_EXP 183
98407: PPUSH
98408: LD_VAR 0 6
98412: PPUSH
98413: LD_EXP 183
98417: PUSH
98418: LD_VAR 0 6
98422: ARRAY
98423: PPUSH
98424: LD_VAR 0 5
98428: PPUSH
98429: CALL_OW 3
98433: PPUSH
98434: CALL_OW 1
98438: ST_TO_ADDR
// exit ;
98439: POP
98440: POP
98441: GO 98634
// end ; end ;
98443: GO 98283
98445: POP
98446: POP
// for i := minerMinesList [ index ] downto 1 do
98447: LD_ADDR_VAR 0 5
98451: PUSH
98452: DOUBLE
98453: LD_EXP 183
98457: PUSH
98458: LD_VAR 0 6
98462: ARRAY
98463: INC
98464: ST_TO_ADDR
98465: LD_INT 1
98467: PUSH
98468: FOR_DOWNTO
98469: IFFALSE 98632
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
98471: LD_EXP 183
98475: PUSH
98476: LD_VAR 0 6
98480: ARRAY
98481: PUSH
98482: LD_VAR 0 5
98486: ARRAY
98487: PUSH
98488: LD_INT 1
98490: ARRAY
98491: PPUSH
98492: LD_EXP 183
98496: PUSH
98497: LD_VAR 0 6
98501: ARRAY
98502: PUSH
98503: LD_VAR 0 5
98507: ARRAY
98508: PUSH
98509: LD_INT 2
98511: ARRAY
98512: PPUSH
98513: LD_VAR 0 2
98517: PPUSH
98518: LD_VAR 0 3
98522: PPUSH
98523: CALL_OW 298
98527: PUSH
98528: LD_INT 6
98530: LESS
98531: IFFALSE 98630
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98533: LD_EXP 183
98537: PUSH
98538: LD_VAR 0 6
98542: ARRAY
98543: PUSH
98544: LD_VAR 0 5
98548: ARRAY
98549: PUSH
98550: LD_INT 1
98552: ARRAY
98553: PPUSH
98554: LD_EXP 183
98558: PUSH
98559: LD_VAR 0 6
98563: ARRAY
98564: PUSH
98565: LD_VAR 0 5
98569: ARRAY
98570: PUSH
98571: LD_INT 2
98573: ARRAY
98574: PPUSH
98575: LD_VAR 0 1
98579: PPUSH
98580: CALL_OW 255
98584: PPUSH
98585: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98589: LD_ADDR_EXP 183
98593: PUSH
98594: LD_EXP 183
98598: PPUSH
98599: LD_VAR 0 6
98603: PPUSH
98604: LD_EXP 183
98608: PUSH
98609: LD_VAR 0 6
98613: ARRAY
98614: PPUSH
98615: LD_VAR 0 5
98619: PPUSH
98620: CALL_OW 3
98624: PPUSH
98625: CALL_OW 1
98629: ST_TO_ADDR
// end ; end ;
98630: GO 98468
98632: POP
98633: POP
// end ;
98634: LD_VAR 0 4
98638: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
98639: LD_INT 0
98641: PPUSH
98642: PPUSH
98643: PPUSH
98644: PPUSH
98645: PPUSH
98646: PPUSH
98647: PPUSH
98648: PPUSH
98649: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
98650: LD_VAR 0 1
98654: PPUSH
98655: CALL_OW 264
98659: PUSH
98660: LD_EXP 109
98664: EQUAL
98665: NOT
98666: PUSH
98667: LD_VAR 0 1
98671: PUSH
98672: LD_EXP 182
98676: IN
98677: NOT
98678: OR
98679: IFFALSE 98683
// exit ;
98681: GO 99005
// index := GetElementIndex ( minersList , unit ) ;
98683: LD_ADDR_VAR 0 6
98687: PUSH
98688: LD_EXP 182
98692: PPUSH
98693: LD_VAR 0 1
98697: PPUSH
98698: CALL 19068 0 2
98702: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98703: LD_ADDR_VAR 0 8
98707: PUSH
98708: LD_EXP 184
98712: PUSH
98713: LD_EXP 183
98717: PUSH
98718: LD_VAR 0 6
98722: ARRAY
98723: MINUS
98724: ST_TO_ADDR
// if not minesFreeAmount then
98725: LD_VAR 0 8
98729: NOT
98730: IFFALSE 98734
// exit ;
98732: GO 99005
// tmp := [ ] ;
98734: LD_ADDR_VAR 0 7
98738: PUSH
98739: EMPTY
98740: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98741: LD_ADDR_VAR 0 5
98745: PUSH
98746: DOUBLE
98747: LD_INT 1
98749: DEC
98750: ST_TO_ADDR
98751: LD_VAR 0 8
98755: PUSH
98756: FOR_TO
98757: IFFALSE 98952
// begin _d := rand ( 0 , 5 ) ;
98759: LD_ADDR_VAR 0 11
98763: PUSH
98764: LD_INT 0
98766: PPUSH
98767: LD_INT 5
98769: PPUSH
98770: CALL_OW 12
98774: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98775: LD_ADDR_VAR 0 12
98779: PUSH
98780: LD_INT 2
98782: PPUSH
98783: LD_INT 6
98785: PPUSH
98786: CALL_OW 12
98790: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98791: LD_ADDR_VAR 0 9
98795: PUSH
98796: LD_VAR 0 2
98800: PPUSH
98801: LD_VAR 0 11
98805: PPUSH
98806: LD_VAR 0 12
98810: PPUSH
98811: CALL_OW 272
98815: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98816: LD_ADDR_VAR 0 10
98820: PUSH
98821: LD_VAR 0 3
98825: PPUSH
98826: LD_VAR 0 11
98830: PPUSH
98831: LD_VAR 0 12
98835: PPUSH
98836: CALL_OW 273
98840: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98841: LD_VAR 0 9
98845: PPUSH
98846: LD_VAR 0 10
98850: PPUSH
98851: CALL_OW 488
98855: PUSH
98856: LD_VAR 0 9
98860: PUSH
98861: LD_VAR 0 10
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: LD_VAR 0 7
98874: IN
98875: NOT
98876: AND
98877: PUSH
98878: LD_VAR 0 9
98882: PPUSH
98883: LD_VAR 0 10
98887: PPUSH
98888: CALL_OW 458
98892: NOT
98893: AND
98894: IFFALSE 98936
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98896: LD_ADDR_VAR 0 7
98900: PUSH
98901: LD_VAR 0 7
98905: PPUSH
98906: LD_VAR 0 7
98910: PUSH
98911: LD_INT 1
98913: PLUS
98914: PPUSH
98915: LD_VAR 0 9
98919: PUSH
98920: LD_VAR 0 10
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: PPUSH
98929: CALL_OW 1
98933: ST_TO_ADDR
98934: GO 98950
// i := i - 1 ;
98936: LD_ADDR_VAR 0 5
98940: PUSH
98941: LD_VAR 0 5
98945: PUSH
98946: LD_INT 1
98948: MINUS
98949: ST_TO_ADDR
// end ;
98950: GO 98756
98952: POP
98953: POP
// for i in tmp do
98954: LD_ADDR_VAR 0 5
98958: PUSH
98959: LD_VAR 0 7
98963: PUSH
98964: FOR_IN
98965: IFFALSE 99003
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98967: LD_VAR 0 1
98971: PPUSH
98972: LD_VAR 0 5
98976: PUSH
98977: LD_INT 1
98979: ARRAY
98980: PPUSH
98981: LD_VAR 0 5
98985: PUSH
98986: LD_INT 2
98988: ARRAY
98989: PPUSH
98990: CALL 97945 0 3
98994: NOT
98995: IFFALSE 99001
// exit ;
98997: POP
98998: POP
98999: GO 99005
99001: GO 98964
99003: POP
99004: POP
// end ;
99005: LD_VAR 0 4
99009: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
99010: LD_INT 0
99012: PPUSH
99013: PPUSH
99014: PPUSH
99015: PPUSH
99016: PPUSH
99017: PPUSH
99018: PPUSH
// if not GetClass ( unit ) = class_sniper then
99019: LD_VAR 0 1
99023: PPUSH
99024: CALL_OW 257
99028: PUSH
99029: LD_INT 5
99031: EQUAL
99032: NOT
99033: IFFALSE 99037
// exit ;
99035: GO 99425
// dist := 8 ;
99037: LD_ADDR_VAR 0 5
99041: PUSH
99042: LD_INT 8
99044: ST_TO_ADDR
// viewRange := 12 ;
99045: LD_ADDR_VAR 0 7
99049: PUSH
99050: LD_INT 12
99052: ST_TO_ADDR
// side := GetSide ( unit ) ;
99053: LD_ADDR_VAR 0 6
99057: PUSH
99058: LD_VAR 0 1
99062: PPUSH
99063: CALL_OW 255
99067: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
99068: LD_INT 61
99070: PPUSH
99071: LD_VAR 0 6
99075: PPUSH
99076: CALL_OW 321
99080: PUSH
99081: LD_INT 2
99083: EQUAL
99084: IFFALSE 99094
// viewRange := 16 ;
99086: LD_ADDR_VAR 0 7
99090: PUSH
99091: LD_INT 16
99093: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
99094: LD_VAR 0 1
99098: PPUSH
99099: LD_VAR 0 2
99103: PPUSH
99104: LD_VAR 0 3
99108: PPUSH
99109: CALL_OW 297
99113: PUSH
99114: LD_VAR 0 5
99118: GREATER
99119: IFFALSE 99198
// begin ComMoveXY ( unit , x , y ) ;
99121: LD_VAR 0 1
99125: PPUSH
99126: LD_VAR 0 2
99130: PPUSH
99131: LD_VAR 0 3
99135: PPUSH
99136: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
99140: LD_INT 35
99142: PPUSH
99143: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
99147: LD_VAR 0 1
99151: PPUSH
99152: LD_VAR 0 2
99156: PPUSH
99157: LD_VAR 0 3
99161: PPUSH
99162: CALL 49465 0 3
99166: NOT
99167: IFFALSE 99171
// exit ;
99169: GO 99425
// until GetDistUnitXY ( unit , x , y ) < dist ;
99171: LD_VAR 0 1
99175: PPUSH
99176: LD_VAR 0 2
99180: PPUSH
99181: LD_VAR 0 3
99185: PPUSH
99186: CALL_OW 297
99190: PUSH
99191: LD_VAR 0 5
99195: LESS
99196: IFFALSE 99140
// end ; ComTurnXY ( unit , x , y ) ;
99198: LD_VAR 0 1
99202: PPUSH
99203: LD_VAR 0 2
99207: PPUSH
99208: LD_VAR 0 3
99212: PPUSH
99213: CALL_OW 118
// wait ( 5 ) ;
99217: LD_INT 5
99219: PPUSH
99220: CALL_OW 67
// _d := GetDir ( unit ) ;
99224: LD_ADDR_VAR 0 10
99228: PUSH
99229: LD_VAR 0 1
99233: PPUSH
99234: CALL_OW 254
99238: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
99239: LD_ADDR_VAR 0 8
99243: PUSH
99244: LD_VAR 0 1
99248: PPUSH
99249: CALL_OW 250
99253: PPUSH
99254: LD_VAR 0 10
99258: PPUSH
99259: LD_VAR 0 5
99263: PPUSH
99264: CALL_OW 272
99268: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
99269: LD_ADDR_VAR 0 9
99273: PUSH
99274: LD_VAR 0 1
99278: PPUSH
99279: CALL_OW 251
99283: PPUSH
99284: LD_VAR 0 10
99288: PPUSH
99289: LD_VAR 0 5
99293: PPUSH
99294: CALL_OW 273
99298: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
99299: LD_VAR 0 8
99303: PPUSH
99304: LD_VAR 0 9
99308: PPUSH
99309: CALL_OW 488
99313: NOT
99314: IFFALSE 99318
// exit ;
99316: GO 99425
// ComAnimCustom ( unit , 1 ) ;
99318: LD_VAR 0 1
99322: PPUSH
99323: LD_INT 1
99325: PPUSH
99326: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
99330: LD_VAR 0 8
99334: PPUSH
99335: LD_VAR 0 9
99339: PPUSH
99340: LD_VAR 0 6
99344: PPUSH
99345: LD_VAR 0 7
99349: PPUSH
99350: CALL_OW 330
// repeat wait ( 1 ) ;
99354: LD_INT 1
99356: PPUSH
99357: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
99361: LD_VAR 0 1
99365: PPUSH
99366: CALL_OW 316
99370: PUSH
99371: LD_VAR 0 1
99375: PPUSH
99376: CALL_OW 314
99380: OR
99381: PUSH
99382: LD_VAR 0 1
99386: PPUSH
99387: CALL_OW 302
99391: NOT
99392: OR
99393: PUSH
99394: LD_VAR 0 1
99398: PPUSH
99399: CALL_OW 301
99403: OR
99404: IFFALSE 99354
// RemoveSeeing ( _x , _y , side ) ;
99406: LD_VAR 0 8
99410: PPUSH
99411: LD_VAR 0 9
99415: PPUSH
99416: LD_VAR 0 6
99420: PPUSH
99421: CALL_OW 331
// end ; end_of_file
99425: LD_VAR 0 4
99429: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99430: LD_INT 0
99432: PPUSH
99433: PPUSH
99434: PPUSH
99435: PPUSH
99436: PPUSH
99437: PPUSH
99438: PPUSH
99439: PPUSH
99440: PPUSH
99441: PPUSH
99442: PPUSH
99443: PPUSH
99444: PPUSH
99445: PPUSH
99446: PPUSH
99447: PPUSH
99448: PPUSH
99449: PPUSH
99450: PPUSH
99451: PPUSH
99452: PPUSH
99453: PPUSH
99454: PPUSH
99455: PPUSH
99456: PPUSH
99457: PPUSH
99458: PPUSH
99459: PPUSH
99460: PPUSH
99461: PPUSH
99462: PPUSH
99463: PPUSH
99464: PPUSH
99465: PPUSH
// if not list then
99466: LD_VAR 0 1
99470: NOT
99471: IFFALSE 99475
// exit ;
99473: GO 104134
// base := list [ 1 ] ;
99475: LD_ADDR_VAR 0 3
99479: PUSH
99480: LD_VAR 0 1
99484: PUSH
99485: LD_INT 1
99487: ARRAY
99488: ST_TO_ADDR
// group := list [ 2 ] ;
99489: LD_ADDR_VAR 0 4
99493: PUSH
99494: LD_VAR 0 1
99498: PUSH
99499: LD_INT 2
99501: ARRAY
99502: ST_TO_ADDR
// path := list [ 3 ] ;
99503: LD_ADDR_VAR 0 5
99507: PUSH
99508: LD_VAR 0 1
99512: PUSH
99513: LD_INT 3
99515: ARRAY
99516: ST_TO_ADDR
// flags := list [ 4 ] ;
99517: LD_ADDR_VAR 0 6
99521: PUSH
99522: LD_VAR 0 1
99526: PUSH
99527: LD_INT 4
99529: ARRAY
99530: ST_TO_ADDR
// mined := [ ] ;
99531: LD_ADDR_VAR 0 27
99535: PUSH
99536: EMPTY
99537: ST_TO_ADDR
// bombed := [ ] ;
99538: LD_ADDR_VAR 0 28
99542: PUSH
99543: EMPTY
99544: ST_TO_ADDR
// healers := [ ] ;
99545: LD_ADDR_VAR 0 31
99549: PUSH
99550: EMPTY
99551: ST_TO_ADDR
// to_heal := [ ] ;
99552: LD_ADDR_VAR 0 30
99556: PUSH
99557: EMPTY
99558: ST_TO_ADDR
// repairs := [ ] ;
99559: LD_ADDR_VAR 0 33
99563: PUSH
99564: EMPTY
99565: ST_TO_ADDR
// to_repair := [ ] ;
99566: LD_ADDR_VAR 0 32
99570: PUSH
99571: EMPTY
99572: ST_TO_ADDR
// if not group or not path then
99573: LD_VAR 0 4
99577: NOT
99578: PUSH
99579: LD_VAR 0 5
99583: NOT
99584: OR
99585: IFFALSE 99589
// exit ;
99587: GO 104134
// side := GetSide ( group [ 1 ] ) ;
99589: LD_ADDR_VAR 0 35
99593: PUSH
99594: LD_VAR 0 4
99598: PUSH
99599: LD_INT 1
99601: ARRAY
99602: PPUSH
99603: CALL_OW 255
99607: ST_TO_ADDR
// if flags then
99608: LD_VAR 0 6
99612: IFFALSE 99756
// begin f_ignore_area := flags [ 1 ] ;
99614: LD_ADDR_VAR 0 17
99618: PUSH
99619: LD_VAR 0 6
99623: PUSH
99624: LD_INT 1
99626: ARRAY
99627: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99628: LD_ADDR_VAR 0 18
99632: PUSH
99633: LD_VAR 0 6
99637: PUSH
99638: LD_INT 2
99640: ARRAY
99641: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99642: LD_ADDR_VAR 0 19
99646: PUSH
99647: LD_VAR 0 6
99651: PUSH
99652: LD_INT 3
99654: ARRAY
99655: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99656: LD_ADDR_VAR 0 20
99660: PUSH
99661: LD_VAR 0 6
99665: PUSH
99666: LD_INT 4
99668: ARRAY
99669: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99670: LD_ADDR_VAR 0 21
99674: PUSH
99675: LD_VAR 0 6
99679: PUSH
99680: LD_INT 5
99682: ARRAY
99683: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99684: LD_ADDR_VAR 0 22
99688: PUSH
99689: LD_VAR 0 6
99693: PUSH
99694: LD_INT 6
99696: ARRAY
99697: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99698: LD_ADDR_VAR 0 23
99702: PUSH
99703: LD_VAR 0 6
99707: PUSH
99708: LD_INT 7
99710: ARRAY
99711: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99712: LD_ADDR_VAR 0 24
99716: PUSH
99717: LD_VAR 0 6
99721: PUSH
99722: LD_INT 8
99724: ARRAY
99725: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99726: LD_ADDR_VAR 0 25
99730: PUSH
99731: LD_VAR 0 6
99735: PUSH
99736: LD_INT 9
99738: ARRAY
99739: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99740: LD_ADDR_VAR 0 26
99744: PUSH
99745: LD_VAR 0 6
99749: PUSH
99750: LD_INT 10
99752: ARRAY
99753: ST_TO_ADDR
// end else
99754: GO 99836
// begin f_ignore_area := false ;
99756: LD_ADDR_VAR 0 17
99760: PUSH
99761: LD_INT 0
99763: ST_TO_ADDR
// f_capture := false ;
99764: LD_ADDR_VAR 0 18
99768: PUSH
99769: LD_INT 0
99771: ST_TO_ADDR
// f_ignore_civ := false ;
99772: LD_ADDR_VAR 0 19
99776: PUSH
99777: LD_INT 0
99779: ST_TO_ADDR
// f_murder := false ;
99780: LD_ADDR_VAR 0 20
99784: PUSH
99785: LD_INT 0
99787: ST_TO_ADDR
// f_mines := false ;
99788: LD_ADDR_VAR 0 21
99792: PUSH
99793: LD_INT 0
99795: ST_TO_ADDR
// f_repair := false ;
99796: LD_ADDR_VAR 0 22
99800: PUSH
99801: LD_INT 0
99803: ST_TO_ADDR
// f_heal := false ;
99804: LD_ADDR_VAR 0 23
99808: PUSH
99809: LD_INT 0
99811: ST_TO_ADDR
// f_spacetime := false ;
99812: LD_ADDR_VAR 0 24
99816: PUSH
99817: LD_INT 0
99819: ST_TO_ADDR
// f_attack_depot := false ;
99820: LD_ADDR_VAR 0 25
99824: PUSH
99825: LD_INT 0
99827: ST_TO_ADDR
// f_crawl := false ;
99828: LD_ADDR_VAR 0 26
99832: PUSH
99833: LD_INT 0
99835: ST_TO_ADDR
// end ; if f_heal then
99836: LD_VAR 0 23
99840: IFFALSE 99867
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99842: LD_ADDR_VAR 0 31
99846: PUSH
99847: LD_VAR 0 4
99851: PPUSH
99852: LD_INT 25
99854: PUSH
99855: LD_INT 4
99857: PUSH
99858: EMPTY
99859: LIST
99860: LIST
99861: PPUSH
99862: CALL_OW 72
99866: ST_TO_ADDR
// if f_repair then
99867: LD_VAR 0 22
99871: IFFALSE 99898
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99873: LD_ADDR_VAR 0 33
99877: PUSH
99878: LD_VAR 0 4
99882: PPUSH
99883: LD_INT 25
99885: PUSH
99886: LD_INT 3
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PPUSH
99893: CALL_OW 72
99897: ST_TO_ADDR
// units_path := [ ] ;
99898: LD_ADDR_VAR 0 16
99902: PUSH
99903: EMPTY
99904: ST_TO_ADDR
// for i = 1 to group do
99905: LD_ADDR_VAR 0 7
99909: PUSH
99910: DOUBLE
99911: LD_INT 1
99913: DEC
99914: ST_TO_ADDR
99915: LD_VAR 0 4
99919: PUSH
99920: FOR_TO
99921: IFFALSE 99950
// units_path := Replace ( units_path , i , path ) ;
99923: LD_ADDR_VAR 0 16
99927: PUSH
99928: LD_VAR 0 16
99932: PPUSH
99933: LD_VAR 0 7
99937: PPUSH
99938: LD_VAR 0 5
99942: PPUSH
99943: CALL_OW 1
99947: ST_TO_ADDR
99948: GO 99920
99950: POP
99951: POP
// repeat for i = group downto 1 do
99952: LD_ADDR_VAR 0 7
99956: PUSH
99957: DOUBLE
99958: LD_VAR 0 4
99962: INC
99963: ST_TO_ADDR
99964: LD_INT 1
99966: PUSH
99967: FOR_DOWNTO
99968: IFFALSE 104090
// begin wait ( 5 ) ;
99970: LD_INT 5
99972: PPUSH
99973: CALL_OW 67
// tmp := [ ] ;
99977: LD_ADDR_VAR 0 14
99981: PUSH
99982: EMPTY
99983: ST_TO_ADDR
// attacking := false ;
99984: LD_ADDR_VAR 0 29
99988: PUSH
99989: LD_INT 0
99991: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99992: LD_VAR 0 4
99996: PUSH
99997: LD_VAR 0 7
100001: ARRAY
100002: PPUSH
100003: CALL_OW 301
100007: PUSH
100008: LD_VAR 0 4
100012: PUSH
100013: LD_VAR 0 7
100017: ARRAY
100018: NOT
100019: OR
100020: IFFALSE 100129
// begin if GetType ( group [ i ] ) = unit_human then
100022: LD_VAR 0 4
100026: PUSH
100027: LD_VAR 0 7
100031: ARRAY
100032: PPUSH
100033: CALL_OW 247
100037: PUSH
100038: LD_INT 1
100040: EQUAL
100041: IFFALSE 100087
// begin to_heal := to_heal diff group [ i ] ;
100043: LD_ADDR_VAR 0 30
100047: PUSH
100048: LD_VAR 0 30
100052: PUSH
100053: LD_VAR 0 4
100057: PUSH
100058: LD_VAR 0 7
100062: ARRAY
100063: DIFF
100064: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100065: LD_ADDR_VAR 0 31
100069: PUSH
100070: LD_VAR 0 31
100074: PUSH
100075: LD_VAR 0 4
100079: PUSH
100080: LD_VAR 0 7
100084: ARRAY
100085: DIFF
100086: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100087: LD_ADDR_VAR 0 4
100091: PUSH
100092: LD_VAR 0 4
100096: PPUSH
100097: LD_VAR 0 7
100101: PPUSH
100102: CALL_OW 3
100106: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100107: LD_ADDR_VAR 0 16
100111: PUSH
100112: LD_VAR 0 16
100116: PPUSH
100117: LD_VAR 0 7
100121: PPUSH
100122: CALL_OW 3
100126: ST_TO_ADDR
// continue ;
100127: GO 99967
// end ; if f_repair then
100129: LD_VAR 0 22
100133: IFFALSE 100622
// begin if GetType ( group [ i ] ) = unit_vehicle then
100135: LD_VAR 0 4
100139: PUSH
100140: LD_VAR 0 7
100144: ARRAY
100145: PPUSH
100146: CALL_OW 247
100150: PUSH
100151: LD_INT 2
100153: EQUAL
100154: IFFALSE 100344
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100156: LD_VAR 0 4
100160: PUSH
100161: LD_VAR 0 7
100165: ARRAY
100166: PPUSH
100167: CALL_OW 256
100171: PUSH
100172: LD_INT 700
100174: LESS
100175: PUSH
100176: LD_VAR 0 4
100180: PUSH
100181: LD_VAR 0 7
100185: ARRAY
100186: PUSH
100187: LD_VAR 0 32
100191: IN
100192: NOT
100193: AND
100194: IFFALSE 100218
// to_repair := to_repair union group [ i ] ;
100196: LD_ADDR_VAR 0 32
100200: PUSH
100201: LD_VAR 0 32
100205: PUSH
100206: LD_VAR 0 4
100210: PUSH
100211: LD_VAR 0 7
100215: ARRAY
100216: UNION
100217: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100218: LD_VAR 0 4
100222: PUSH
100223: LD_VAR 0 7
100227: ARRAY
100228: PPUSH
100229: CALL_OW 256
100233: PUSH
100234: LD_INT 1000
100236: EQUAL
100237: PUSH
100238: LD_VAR 0 4
100242: PUSH
100243: LD_VAR 0 7
100247: ARRAY
100248: PUSH
100249: LD_VAR 0 32
100253: IN
100254: AND
100255: IFFALSE 100279
// to_repair := to_repair diff group [ i ] ;
100257: LD_ADDR_VAR 0 32
100261: PUSH
100262: LD_VAR 0 32
100266: PUSH
100267: LD_VAR 0 4
100271: PUSH
100272: LD_VAR 0 7
100276: ARRAY
100277: DIFF
100278: ST_TO_ADDR
// if group [ i ] in to_repair then
100279: LD_VAR 0 4
100283: PUSH
100284: LD_VAR 0 7
100288: ARRAY
100289: PUSH
100290: LD_VAR 0 32
100294: IN
100295: IFFALSE 100342
// begin if not IsInArea ( group [ i ] , f_repair ) then
100297: LD_VAR 0 4
100301: PUSH
100302: LD_VAR 0 7
100306: ARRAY
100307: PPUSH
100308: LD_VAR 0 22
100312: PPUSH
100313: CALL_OW 308
100317: NOT
100318: IFFALSE 100340
// ComMoveToArea ( group [ i ] , f_repair ) ;
100320: LD_VAR 0 4
100324: PUSH
100325: LD_VAR 0 7
100329: ARRAY
100330: PPUSH
100331: LD_VAR 0 22
100335: PPUSH
100336: CALL_OW 113
// continue ;
100340: GO 99967
// end ; end else
100342: GO 100622
// if group [ i ] in repairs then
100344: LD_VAR 0 4
100348: PUSH
100349: LD_VAR 0 7
100353: ARRAY
100354: PUSH
100355: LD_VAR 0 33
100359: IN
100360: IFFALSE 100622
// begin if IsInUnit ( group [ i ] ) then
100362: LD_VAR 0 4
100366: PUSH
100367: LD_VAR 0 7
100371: ARRAY
100372: PPUSH
100373: CALL_OW 310
100377: IFFALSE 100445
// begin z := IsInUnit ( group [ i ] ) ;
100379: LD_ADDR_VAR 0 13
100383: PUSH
100384: LD_VAR 0 4
100388: PUSH
100389: LD_VAR 0 7
100393: ARRAY
100394: PPUSH
100395: CALL_OW 310
100399: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100400: LD_VAR 0 13
100404: PUSH
100405: LD_VAR 0 32
100409: IN
100410: PUSH
100411: LD_VAR 0 13
100415: PPUSH
100416: LD_VAR 0 22
100420: PPUSH
100421: CALL_OW 308
100425: AND
100426: IFFALSE 100443
// ComExitVehicle ( group [ i ] ) ;
100428: LD_VAR 0 4
100432: PUSH
100433: LD_VAR 0 7
100437: ARRAY
100438: PPUSH
100439: CALL_OW 121
// end else
100443: GO 100622
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100445: LD_ADDR_VAR 0 13
100449: PUSH
100450: LD_VAR 0 4
100454: PPUSH
100455: LD_INT 95
100457: PUSH
100458: LD_VAR 0 22
100462: PUSH
100463: EMPTY
100464: LIST
100465: LIST
100466: PUSH
100467: LD_INT 58
100469: PUSH
100470: EMPTY
100471: LIST
100472: PUSH
100473: EMPTY
100474: LIST
100475: LIST
100476: PPUSH
100477: CALL_OW 72
100481: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100482: LD_VAR 0 4
100486: PUSH
100487: LD_VAR 0 7
100491: ARRAY
100492: PPUSH
100493: CALL_OW 314
100497: NOT
100498: IFFALSE 100620
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100500: LD_ADDR_VAR 0 10
100504: PUSH
100505: LD_VAR 0 13
100509: PPUSH
100510: LD_VAR 0 4
100514: PUSH
100515: LD_VAR 0 7
100519: ARRAY
100520: PPUSH
100521: CALL_OW 74
100525: ST_TO_ADDR
// if not x then
100526: LD_VAR 0 10
100530: NOT
100531: IFFALSE 100535
// continue ;
100533: GO 99967
// if GetLives ( x ) < 1000 then
100535: LD_VAR 0 10
100539: PPUSH
100540: CALL_OW 256
100544: PUSH
100545: LD_INT 1000
100547: LESS
100548: IFFALSE 100572
// ComRepairVehicle ( group [ i ] , x ) else
100550: LD_VAR 0 4
100554: PUSH
100555: LD_VAR 0 7
100559: ARRAY
100560: PPUSH
100561: LD_VAR 0 10
100565: PPUSH
100566: CALL_OW 129
100570: GO 100620
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100572: LD_VAR 0 23
100576: PUSH
100577: LD_VAR 0 4
100581: PUSH
100582: LD_VAR 0 7
100586: ARRAY
100587: PPUSH
100588: CALL_OW 256
100592: PUSH
100593: LD_INT 1000
100595: LESS
100596: AND
100597: NOT
100598: IFFALSE 100620
// ComEnterUnit ( group [ i ] , x ) ;
100600: LD_VAR 0 4
100604: PUSH
100605: LD_VAR 0 7
100609: ARRAY
100610: PPUSH
100611: LD_VAR 0 10
100615: PPUSH
100616: CALL_OW 120
// end ; continue ;
100620: GO 99967
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100622: LD_VAR 0 23
100626: PUSH
100627: LD_VAR 0 4
100631: PUSH
100632: LD_VAR 0 7
100636: ARRAY
100637: PPUSH
100638: CALL_OW 247
100642: PUSH
100643: LD_INT 1
100645: EQUAL
100646: AND
100647: IFFALSE 101125
// begin if group [ i ] in healers then
100649: LD_VAR 0 4
100653: PUSH
100654: LD_VAR 0 7
100658: ARRAY
100659: PUSH
100660: LD_VAR 0 31
100664: IN
100665: IFFALSE 100938
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100667: LD_VAR 0 4
100671: PUSH
100672: LD_VAR 0 7
100676: ARRAY
100677: PPUSH
100678: LD_VAR 0 23
100682: PPUSH
100683: CALL_OW 308
100687: NOT
100688: PUSH
100689: LD_VAR 0 4
100693: PUSH
100694: LD_VAR 0 7
100698: ARRAY
100699: PPUSH
100700: CALL_OW 314
100704: NOT
100705: AND
100706: IFFALSE 100730
// ComMoveToArea ( group [ i ] , f_heal ) else
100708: LD_VAR 0 4
100712: PUSH
100713: LD_VAR 0 7
100717: ARRAY
100718: PPUSH
100719: LD_VAR 0 23
100723: PPUSH
100724: CALL_OW 113
100728: GO 100936
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100730: LD_VAR 0 4
100734: PUSH
100735: LD_VAR 0 7
100739: ARRAY
100740: PPUSH
100741: CALL 47988 0 1
100745: PPUSH
100746: CALL_OW 256
100750: PUSH
100751: LD_INT 1000
100753: EQUAL
100754: IFFALSE 100773
// ComStop ( group [ i ] ) else
100756: LD_VAR 0 4
100760: PUSH
100761: LD_VAR 0 7
100765: ARRAY
100766: PPUSH
100767: CALL_OW 141
100771: GO 100936
// if not HasTask ( group [ i ] ) and to_heal then
100773: LD_VAR 0 4
100777: PUSH
100778: LD_VAR 0 7
100782: ARRAY
100783: PPUSH
100784: CALL_OW 314
100788: NOT
100789: PUSH
100790: LD_VAR 0 30
100794: AND
100795: IFFALSE 100936
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100797: LD_ADDR_VAR 0 13
100801: PUSH
100802: LD_VAR 0 30
100806: PPUSH
100807: LD_INT 3
100809: PUSH
100810: LD_INT 54
100812: PUSH
100813: EMPTY
100814: LIST
100815: PUSH
100816: EMPTY
100817: LIST
100818: LIST
100819: PPUSH
100820: CALL_OW 72
100824: PPUSH
100825: LD_VAR 0 4
100829: PUSH
100830: LD_VAR 0 7
100834: ARRAY
100835: PPUSH
100836: CALL_OW 74
100840: ST_TO_ADDR
// if z then
100841: LD_VAR 0 13
100845: IFFALSE 100936
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100847: LD_INT 91
100849: PUSH
100850: LD_VAR 0 13
100854: PUSH
100855: LD_INT 10
100857: PUSH
100858: EMPTY
100859: LIST
100860: LIST
100861: LIST
100862: PUSH
100863: LD_INT 81
100865: PUSH
100866: LD_VAR 0 13
100870: PPUSH
100871: CALL_OW 255
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PPUSH
100884: CALL_OW 69
100888: PUSH
100889: LD_INT 0
100891: EQUAL
100892: IFFALSE 100916
// ComHeal ( group [ i ] , z ) else
100894: LD_VAR 0 4
100898: PUSH
100899: LD_VAR 0 7
100903: ARRAY
100904: PPUSH
100905: LD_VAR 0 13
100909: PPUSH
100910: CALL_OW 128
100914: GO 100936
// ComMoveToArea ( group [ i ] , f_heal ) ;
100916: LD_VAR 0 4
100920: PUSH
100921: LD_VAR 0 7
100925: ARRAY
100926: PPUSH
100927: LD_VAR 0 23
100931: PPUSH
100932: CALL_OW 113
// end ; continue ;
100936: GO 99967
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100938: LD_VAR 0 4
100942: PUSH
100943: LD_VAR 0 7
100947: ARRAY
100948: PPUSH
100949: CALL_OW 256
100953: PUSH
100954: LD_INT 700
100956: LESS
100957: PUSH
100958: LD_VAR 0 4
100962: PUSH
100963: LD_VAR 0 7
100967: ARRAY
100968: PUSH
100969: LD_VAR 0 30
100973: IN
100974: NOT
100975: AND
100976: IFFALSE 101000
// to_heal := to_heal union group [ i ] ;
100978: LD_ADDR_VAR 0 30
100982: PUSH
100983: LD_VAR 0 30
100987: PUSH
100988: LD_VAR 0 4
100992: PUSH
100993: LD_VAR 0 7
100997: ARRAY
100998: UNION
100999: ST_TO_ADDR
// if group [ i ] in to_heal then
101000: LD_VAR 0 4
101004: PUSH
101005: LD_VAR 0 7
101009: ARRAY
101010: PUSH
101011: LD_VAR 0 30
101015: IN
101016: IFFALSE 101125
// begin if GetLives ( group [ i ] ) = 1000 then
101018: LD_VAR 0 4
101022: PUSH
101023: LD_VAR 0 7
101027: ARRAY
101028: PPUSH
101029: CALL_OW 256
101033: PUSH
101034: LD_INT 1000
101036: EQUAL
101037: IFFALSE 101063
// to_heal := to_heal diff group [ i ] else
101039: LD_ADDR_VAR 0 30
101043: PUSH
101044: LD_VAR 0 30
101048: PUSH
101049: LD_VAR 0 4
101053: PUSH
101054: LD_VAR 0 7
101058: ARRAY
101059: DIFF
101060: ST_TO_ADDR
101061: GO 101125
// begin if not IsInArea ( group [ i ] , to_heal ) then
101063: LD_VAR 0 4
101067: PUSH
101068: LD_VAR 0 7
101072: ARRAY
101073: PPUSH
101074: LD_VAR 0 30
101078: PPUSH
101079: CALL_OW 308
101083: NOT
101084: IFFALSE 101108
// ComMoveToArea ( group [ i ] , f_heal ) else
101086: LD_VAR 0 4
101090: PUSH
101091: LD_VAR 0 7
101095: ARRAY
101096: PPUSH
101097: LD_VAR 0 23
101101: PPUSH
101102: CALL_OW 113
101106: GO 101123
// ComHold ( group [ i ] ) ;
101108: LD_VAR 0 4
101112: PUSH
101113: LD_VAR 0 7
101117: ARRAY
101118: PPUSH
101119: CALL_OW 140
// continue ;
101123: GO 99967
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101125: LD_VAR 0 4
101129: PUSH
101130: LD_VAR 0 7
101134: ARRAY
101135: PPUSH
101136: LD_INT 10
101138: PPUSH
101139: CALL 46408 0 2
101143: NOT
101144: PUSH
101145: LD_VAR 0 16
101149: PUSH
101150: LD_VAR 0 7
101154: ARRAY
101155: PUSH
101156: EMPTY
101157: EQUAL
101158: NOT
101159: AND
101160: IFFALSE 101426
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101162: LD_VAR 0 4
101166: PUSH
101167: LD_VAR 0 7
101171: ARRAY
101172: PPUSH
101173: CALL_OW 262
101177: PUSH
101178: LD_INT 1
101180: PUSH
101181: LD_INT 2
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: IN
101188: IFFALSE 101229
// if GetFuel ( group [ i ] ) < 10 then
101190: LD_VAR 0 4
101194: PUSH
101195: LD_VAR 0 7
101199: ARRAY
101200: PPUSH
101201: CALL_OW 261
101205: PUSH
101206: LD_INT 10
101208: LESS
101209: IFFALSE 101229
// SetFuel ( group [ i ] , 12 ) ;
101211: LD_VAR 0 4
101215: PUSH
101216: LD_VAR 0 7
101220: ARRAY
101221: PPUSH
101222: LD_INT 12
101224: PPUSH
101225: CALL_OW 240
// if units_path [ i ] then
101229: LD_VAR 0 16
101233: PUSH
101234: LD_VAR 0 7
101238: ARRAY
101239: IFFALSE 101424
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101241: LD_VAR 0 4
101245: PUSH
101246: LD_VAR 0 7
101250: ARRAY
101251: PPUSH
101252: LD_VAR 0 16
101256: PUSH
101257: LD_VAR 0 7
101261: ARRAY
101262: PUSH
101263: LD_INT 1
101265: ARRAY
101266: PUSH
101267: LD_INT 1
101269: ARRAY
101270: PPUSH
101271: LD_VAR 0 16
101275: PUSH
101276: LD_VAR 0 7
101280: ARRAY
101281: PUSH
101282: LD_INT 1
101284: ARRAY
101285: PUSH
101286: LD_INT 2
101288: ARRAY
101289: PPUSH
101290: CALL_OW 297
101294: PUSH
101295: LD_INT 6
101297: GREATER
101298: IFFALSE 101373
// begin if not HasTask ( group [ i ] ) then
101300: LD_VAR 0 4
101304: PUSH
101305: LD_VAR 0 7
101309: ARRAY
101310: PPUSH
101311: CALL_OW 314
101315: NOT
101316: IFFALSE 101371
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101318: LD_VAR 0 4
101322: PUSH
101323: LD_VAR 0 7
101327: ARRAY
101328: PPUSH
101329: LD_VAR 0 16
101333: PUSH
101334: LD_VAR 0 7
101338: ARRAY
101339: PUSH
101340: LD_INT 1
101342: ARRAY
101343: PUSH
101344: LD_INT 1
101346: ARRAY
101347: PPUSH
101348: LD_VAR 0 16
101352: PUSH
101353: LD_VAR 0 7
101357: ARRAY
101358: PUSH
101359: LD_INT 1
101361: ARRAY
101362: PUSH
101363: LD_INT 2
101365: ARRAY
101366: PPUSH
101367: CALL_OW 114
// end else
101371: GO 101424
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101373: LD_ADDR_VAR 0 15
101377: PUSH
101378: LD_VAR 0 16
101382: PUSH
101383: LD_VAR 0 7
101387: ARRAY
101388: PPUSH
101389: LD_INT 1
101391: PPUSH
101392: CALL_OW 3
101396: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101397: LD_ADDR_VAR 0 16
101401: PUSH
101402: LD_VAR 0 16
101406: PPUSH
101407: LD_VAR 0 7
101411: PPUSH
101412: LD_VAR 0 15
101416: PPUSH
101417: CALL_OW 1
101421: ST_TO_ADDR
// continue ;
101422: GO 99967
// end ; end ; end else
101424: GO 104088
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101426: LD_ADDR_VAR 0 14
101430: PUSH
101431: LD_INT 81
101433: PUSH
101434: LD_VAR 0 4
101438: PUSH
101439: LD_VAR 0 7
101443: ARRAY
101444: PPUSH
101445: CALL_OW 255
101449: PUSH
101450: EMPTY
101451: LIST
101452: LIST
101453: PPUSH
101454: CALL_OW 69
101458: ST_TO_ADDR
// if not tmp then
101459: LD_VAR 0 14
101463: NOT
101464: IFFALSE 101468
// continue ;
101466: GO 99967
// if f_ignore_area then
101468: LD_VAR 0 17
101472: IFFALSE 101560
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101474: LD_ADDR_VAR 0 15
101478: PUSH
101479: LD_VAR 0 14
101483: PPUSH
101484: LD_INT 3
101486: PUSH
101487: LD_INT 92
101489: PUSH
101490: LD_VAR 0 17
101494: PUSH
101495: LD_INT 1
101497: ARRAY
101498: PUSH
101499: LD_VAR 0 17
101503: PUSH
101504: LD_INT 2
101506: ARRAY
101507: PUSH
101508: LD_VAR 0 17
101512: PUSH
101513: LD_INT 3
101515: ARRAY
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: PUSH
101523: EMPTY
101524: LIST
101525: LIST
101526: PPUSH
101527: CALL_OW 72
101531: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101532: LD_VAR 0 14
101536: PUSH
101537: LD_VAR 0 15
101541: DIFF
101542: IFFALSE 101560
// tmp := tmp diff tmp2 ;
101544: LD_ADDR_VAR 0 14
101548: PUSH
101549: LD_VAR 0 14
101553: PUSH
101554: LD_VAR 0 15
101558: DIFF
101559: ST_TO_ADDR
// end ; if not f_murder then
101560: LD_VAR 0 20
101564: NOT
101565: IFFALSE 101623
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101567: LD_ADDR_VAR 0 15
101571: PUSH
101572: LD_VAR 0 14
101576: PPUSH
101577: LD_INT 3
101579: PUSH
101580: LD_INT 50
101582: PUSH
101583: EMPTY
101584: LIST
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PPUSH
101590: CALL_OW 72
101594: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101595: LD_VAR 0 14
101599: PUSH
101600: LD_VAR 0 15
101604: DIFF
101605: IFFALSE 101623
// tmp := tmp diff tmp2 ;
101607: LD_ADDR_VAR 0 14
101611: PUSH
101612: LD_VAR 0 14
101616: PUSH
101617: LD_VAR 0 15
101621: DIFF
101622: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101623: LD_ADDR_VAR 0 14
101627: PUSH
101628: LD_VAR 0 4
101632: PUSH
101633: LD_VAR 0 7
101637: ARRAY
101638: PPUSH
101639: LD_VAR 0 14
101643: PPUSH
101644: LD_INT 1
101646: PPUSH
101647: LD_INT 1
101649: PPUSH
101650: CALL 19718 0 4
101654: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101655: LD_VAR 0 4
101659: PUSH
101660: LD_VAR 0 7
101664: ARRAY
101665: PPUSH
101666: CALL_OW 257
101670: PUSH
101671: LD_INT 1
101673: EQUAL
101674: IFFALSE 102122
// begin if WantPlant ( group [ i ] ) then
101676: LD_VAR 0 4
101680: PUSH
101681: LD_VAR 0 7
101685: ARRAY
101686: PPUSH
101687: CALL 19219 0 1
101691: IFFALSE 101695
// continue ;
101693: GO 99967
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101695: LD_VAR 0 18
101699: PUSH
101700: LD_VAR 0 4
101704: PUSH
101705: LD_VAR 0 7
101709: ARRAY
101710: PPUSH
101711: CALL_OW 310
101715: NOT
101716: AND
101717: PUSH
101718: LD_VAR 0 14
101722: PUSH
101723: LD_INT 1
101725: ARRAY
101726: PUSH
101727: LD_VAR 0 14
101731: PPUSH
101732: LD_INT 21
101734: PUSH
101735: LD_INT 2
101737: PUSH
101738: EMPTY
101739: LIST
101740: LIST
101741: PUSH
101742: LD_INT 58
101744: PUSH
101745: EMPTY
101746: LIST
101747: PUSH
101748: EMPTY
101749: LIST
101750: LIST
101751: PPUSH
101752: CALL_OW 72
101756: IN
101757: AND
101758: IFFALSE 101794
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101760: LD_VAR 0 4
101764: PUSH
101765: LD_VAR 0 7
101769: ARRAY
101770: PPUSH
101771: LD_VAR 0 14
101775: PUSH
101776: LD_INT 1
101778: ARRAY
101779: PPUSH
101780: CALL_OW 120
// attacking := true ;
101784: LD_ADDR_VAR 0 29
101788: PUSH
101789: LD_INT 1
101791: ST_TO_ADDR
// continue ;
101792: GO 99967
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101794: LD_VAR 0 26
101798: PUSH
101799: LD_VAR 0 4
101803: PUSH
101804: LD_VAR 0 7
101808: ARRAY
101809: PPUSH
101810: CALL_OW 257
101814: PUSH
101815: LD_INT 1
101817: EQUAL
101818: AND
101819: PUSH
101820: LD_VAR 0 4
101824: PUSH
101825: LD_VAR 0 7
101829: ARRAY
101830: PPUSH
101831: CALL_OW 256
101835: PUSH
101836: LD_INT 800
101838: LESS
101839: AND
101840: PUSH
101841: LD_VAR 0 4
101845: PUSH
101846: LD_VAR 0 7
101850: ARRAY
101851: PPUSH
101852: CALL_OW 318
101856: NOT
101857: AND
101858: IFFALSE 101875
// ComCrawl ( group [ i ] ) ;
101860: LD_VAR 0 4
101864: PUSH
101865: LD_VAR 0 7
101869: ARRAY
101870: PPUSH
101871: CALL_OW 137
// if f_mines then
101875: LD_VAR 0 21
101879: IFFALSE 102122
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101881: LD_VAR 0 14
101885: PUSH
101886: LD_INT 1
101888: ARRAY
101889: PPUSH
101890: CALL_OW 247
101894: PUSH
101895: LD_INT 3
101897: EQUAL
101898: PUSH
101899: LD_VAR 0 14
101903: PUSH
101904: LD_INT 1
101906: ARRAY
101907: PUSH
101908: LD_VAR 0 27
101912: IN
101913: NOT
101914: AND
101915: IFFALSE 102122
// begin x := GetX ( tmp [ 1 ] ) ;
101917: LD_ADDR_VAR 0 10
101921: PUSH
101922: LD_VAR 0 14
101926: PUSH
101927: LD_INT 1
101929: ARRAY
101930: PPUSH
101931: CALL_OW 250
101935: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101936: LD_ADDR_VAR 0 11
101940: PUSH
101941: LD_VAR 0 14
101945: PUSH
101946: LD_INT 1
101948: ARRAY
101949: PPUSH
101950: CALL_OW 251
101954: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101955: LD_ADDR_VAR 0 12
101959: PUSH
101960: LD_VAR 0 4
101964: PUSH
101965: LD_VAR 0 7
101969: ARRAY
101970: PPUSH
101971: CALL 46493 0 1
101975: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101976: LD_VAR 0 4
101980: PUSH
101981: LD_VAR 0 7
101985: ARRAY
101986: PPUSH
101987: LD_VAR 0 10
101991: PPUSH
101992: LD_VAR 0 11
101996: PPUSH
101997: LD_VAR 0 14
102001: PUSH
102002: LD_INT 1
102004: ARRAY
102005: PPUSH
102006: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102010: LD_VAR 0 4
102014: PUSH
102015: LD_VAR 0 7
102019: ARRAY
102020: PPUSH
102021: LD_VAR 0 10
102025: PPUSH
102026: LD_VAR 0 12
102030: PPUSH
102031: LD_INT 7
102033: PPUSH
102034: CALL_OW 272
102038: PPUSH
102039: LD_VAR 0 11
102043: PPUSH
102044: LD_VAR 0 12
102048: PPUSH
102049: LD_INT 7
102051: PPUSH
102052: CALL_OW 273
102056: PPUSH
102057: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102061: LD_VAR 0 4
102065: PUSH
102066: LD_VAR 0 7
102070: ARRAY
102071: PPUSH
102072: LD_INT 71
102074: PPUSH
102075: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102079: LD_ADDR_VAR 0 27
102083: PUSH
102084: LD_VAR 0 27
102088: PPUSH
102089: LD_VAR 0 27
102093: PUSH
102094: LD_INT 1
102096: PLUS
102097: PPUSH
102098: LD_VAR 0 14
102102: PUSH
102103: LD_INT 1
102105: ARRAY
102106: PPUSH
102107: CALL_OW 1
102111: ST_TO_ADDR
// attacking := true ;
102112: LD_ADDR_VAR 0 29
102116: PUSH
102117: LD_INT 1
102119: ST_TO_ADDR
// continue ;
102120: GO 99967
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102122: LD_VAR 0 4
102126: PUSH
102127: LD_VAR 0 7
102131: ARRAY
102132: PPUSH
102133: CALL_OW 257
102137: PUSH
102138: LD_INT 17
102140: EQUAL
102141: PUSH
102142: LD_VAR 0 4
102146: PUSH
102147: LD_VAR 0 7
102151: ARRAY
102152: PPUSH
102153: CALL_OW 110
102157: PUSH
102158: LD_INT 71
102160: EQUAL
102161: NOT
102162: AND
102163: IFFALSE 102309
// begin attacking := false ;
102165: LD_ADDR_VAR 0 29
102169: PUSH
102170: LD_INT 0
102172: ST_TO_ADDR
// k := 5 ;
102173: LD_ADDR_VAR 0 9
102177: PUSH
102178: LD_INT 5
102180: ST_TO_ADDR
// if tmp < k then
102181: LD_VAR 0 14
102185: PUSH
102186: LD_VAR 0 9
102190: LESS
102191: IFFALSE 102203
// k := tmp ;
102193: LD_ADDR_VAR 0 9
102197: PUSH
102198: LD_VAR 0 14
102202: ST_TO_ADDR
// for j = 1 to k do
102203: LD_ADDR_VAR 0 8
102207: PUSH
102208: DOUBLE
102209: LD_INT 1
102211: DEC
102212: ST_TO_ADDR
102213: LD_VAR 0 9
102217: PUSH
102218: FOR_TO
102219: IFFALSE 102307
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102221: LD_VAR 0 14
102225: PUSH
102226: LD_VAR 0 8
102230: ARRAY
102231: PUSH
102232: LD_VAR 0 14
102236: PPUSH
102237: LD_INT 58
102239: PUSH
102240: EMPTY
102241: LIST
102242: PPUSH
102243: CALL_OW 72
102247: IN
102248: NOT
102249: IFFALSE 102305
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102251: LD_VAR 0 4
102255: PUSH
102256: LD_VAR 0 7
102260: ARRAY
102261: PPUSH
102262: LD_VAR 0 14
102266: PUSH
102267: LD_VAR 0 8
102271: ARRAY
102272: PPUSH
102273: CALL_OW 115
// attacking := true ;
102277: LD_ADDR_VAR 0 29
102281: PUSH
102282: LD_INT 1
102284: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102285: LD_VAR 0 4
102289: PUSH
102290: LD_VAR 0 7
102294: ARRAY
102295: PPUSH
102296: LD_INT 71
102298: PPUSH
102299: CALL_OW 109
// continue ;
102303: GO 102218
// end ; end ;
102305: GO 102218
102307: POP
102308: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102309: LD_VAR 0 4
102313: PUSH
102314: LD_VAR 0 7
102318: ARRAY
102319: PPUSH
102320: CALL_OW 257
102324: PUSH
102325: LD_INT 8
102327: EQUAL
102328: PUSH
102329: LD_VAR 0 4
102333: PUSH
102334: LD_VAR 0 7
102338: ARRAY
102339: PPUSH
102340: CALL_OW 264
102344: PUSH
102345: LD_INT 28
102347: PUSH
102348: LD_INT 45
102350: PUSH
102351: LD_INT 7
102353: PUSH
102354: LD_INT 47
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: IN
102363: OR
102364: IFFALSE 102620
// begin attacking := false ;
102366: LD_ADDR_VAR 0 29
102370: PUSH
102371: LD_INT 0
102373: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102374: LD_VAR 0 14
102378: PUSH
102379: LD_INT 1
102381: ARRAY
102382: PPUSH
102383: CALL_OW 266
102387: PUSH
102388: LD_INT 32
102390: PUSH
102391: LD_INT 31
102393: PUSH
102394: LD_INT 33
102396: PUSH
102397: LD_INT 4
102399: PUSH
102400: LD_INT 5
102402: PUSH
102403: EMPTY
102404: LIST
102405: LIST
102406: LIST
102407: LIST
102408: LIST
102409: IN
102410: IFFALSE 102596
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102412: LD_ADDR_VAR 0 9
102416: PUSH
102417: LD_VAR 0 14
102421: PUSH
102422: LD_INT 1
102424: ARRAY
102425: PPUSH
102426: CALL_OW 266
102430: PPUSH
102431: LD_VAR 0 14
102435: PUSH
102436: LD_INT 1
102438: ARRAY
102439: PPUSH
102440: CALL_OW 250
102444: PPUSH
102445: LD_VAR 0 14
102449: PUSH
102450: LD_INT 1
102452: ARRAY
102453: PPUSH
102454: CALL_OW 251
102458: PPUSH
102459: LD_VAR 0 14
102463: PUSH
102464: LD_INT 1
102466: ARRAY
102467: PPUSH
102468: CALL_OW 254
102472: PPUSH
102473: LD_VAR 0 14
102477: PUSH
102478: LD_INT 1
102480: ARRAY
102481: PPUSH
102482: CALL_OW 248
102486: PPUSH
102487: LD_INT 0
102489: PPUSH
102490: CALL 27863 0 6
102494: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102495: LD_ADDR_VAR 0 8
102499: PUSH
102500: LD_VAR 0 4
102504: PUSH
102505: LD_VAR 0 7
102509: ARRAY
102510: PPUSH
102511: LD_VAR 0 9
102515: PPUSH
102516: CALL 46533 0 2
102520: ST_TO_ADDR
// if j then
102521: LD_VAR 0 8
102525: IFFALSE 102594
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102527: LD_VAR 0 8
102531: PUSH
102532: LD_INT 1
102534: ARRAY
102535: PPUSH
102536: LD_VAR 0 8
102540: PUSH
102541: LD_INT 2
102543: ARRAY
102544: PPUSH
102545: CALL_OW 488
102549: IFFALSE 102594
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102551: LD_VAR 0 4
102555: PUSH
102556: LD_VAR 0 7
102560: ARRAY
102561: PPUSH
102562: LD_VAR 0 8
102566: PUSH
102567: LD_INT 1
102569: ARRAY
102570: PPUSH
102571: LD_VAR 0 8
102575: PUSH
102576: LD_INT 2
102578: ARRAY
102579: PPUSH
102580: CALL_OW 116
// attacking := true ;
102584: LD_ADDR_VAR 0 29
102588: PUSH
102589: LD_INT 1
102591: ST_TO_ADDR
// continue ;
102592: GO 99967
// end ; end else
102594: GO 102620
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102596: LD_VAR 0 4
102600: PUSH
102601: LD_VAR 0 7
102605: ARRAY
102606: PPUSH
102607: LD_VAR 0 14
102611: PUSH
102612: LD_INT 1
102614: ARRAY
102615: PPUSH
102616: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102620: LD_VAR 0 4
102624: PUSH
102625: LD_VAR 0 7
102629: ARRAY
102630: PPUSH
102631: CALL_OW 265
102635: PUSH
102636: LD_INT 11
102638: EQUAL
102639: IFFALSE 102917
// begin k := 10 ;
102641: LD_ADDR_VAR 0 9
102645: PUSH
102646: LD_INT 10
102648: ST_TO_ADDR
// x := 0 ;
102649: LD_ADDR_VAR 0 10
102653: PUSH
102654: LD_INT 0
102656: ST_TO_ADDR
// if tmp < k then
102657: LD_VAR 0 14
102661: PUSH
102662: LD_VAR 0 9
102666: LESS
102667: IFFALSE 102679
// k := tmp ;
102669: LD_ADDR_VAR 0 9
102673: PUSH
102674: LD_VAR 0 14
102678: ST_TO_ADDR
// for j = k downto 1 do
102679: LD_ADDR_VAR 0 8
102683: PUSH
102684: DOUBLE
102685: LD_VAR 0 9
102689: INC
102690: ST_TO_ADDR
102691: LD_INT 1
102693: PUSH
102694: FOR_DOWNTO
102695: IFFALSE 102770
// begin if GetType ( tmp [ j ] ) = unit_human then
102697: LD_VAR 0 14
102701: PUSH
102702: LD_VAR 0 8
102706: ARRAY
102707: PPUSH
102708: CALL_OW 247
102712: PUSH
102713: LD_INT 1
102715: EQUAL
102716: IFFALSE 102768
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102718: LD_VAR 0 4
102722: PUSH
102723: LD_VAR 0 7
102727: ARRAY
102728: PPUSH
102729: LD_VAR 0 14
102733: PUSH
102734: LD_VAR 0 8
102738: ARRAY
102739: PPUSH
102740: CALL 46804 0 2
// x := tmp [ j ] ;
102744: LD_ADDR_VAR 0 10
102748: PUSH
102749: LD_VAR 0 14
102753: PUSH
102754: LD_VAR 0 8
102758: ARRAY
102759: ST_TO_ADDR
// attacking := true ;
102760: LD_ADDR_VAR 0 29
102764: PUSH
102765: LD_INT 1
102767: ST_TO_ADDR
// end ; end ;
102768: GO 102694
102770: POP
102771: POP
// if not x then
102772: LD_VAR 0 10
102776: NOT
102777: IFFALSE 102917
// begin attacking := true ;
102779: LD_ADDR_VAR 0 29
102783: PUSH
102784: LD_INT 1
102786: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102787: LD_VAR 0 4
102791: PUSH
102792: LD_VAR 0 7
102796: ARRAY
102797: PPUSH
102798: CALL_OW 250
102802: PPUSH
102803: LD_VAR 0 4
102807: PUSH
102808: LD_VAR 0 7
102812: ARRAY
102813: PPUSH
102814: CALL_OW 251
102818: PPUSH
102819: CALL_OW 546
102823: PUSH
102824: LD_INT 2
102826: ARRAY
102827: PUSH
102828: LD_VAR 0 14
102832: PUSH
102833: LD_INT 1
102835: ARRAY
102836: PPUSH
102837: CALL_OW 250
102841: PPUSH
102842: LD_VAR 0 14
102846: PUSH
102847: LD_INT 1
102849: ARRAY
102850: PPUSH
102851: CALL_OW 251
102855: PPUSH
102856: CALL_OW 546
102860: PUSH
102861: LD_INT 2
102863: ARRAY
102864: EQUAL
102865: IFFALSE 102893
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102867: LD_VAR 0 4
102871: PUSH
102872: LD_VAR 0 7
102876: ARRAY
102877: PPUSH
102878: LD_VAR 0 14
102882: PUSH
102883: LD_INT 1
102885: ARRAY
102886: PPUSH
102887: CALL 46804 0 2
102891: GO 102917
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102893: LD_VAR 0 4
102897: PUSH
102898: LD_VAR 0 7
102902: ARRAY
102903: PPUSH
102904: LD_VAR 0 14
102908: PUSH
102909: LD_INT 1
102911: ARRAY
102912: PPUSH
102913: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102917: LD_VAR 0 4
102921: PUSH
102922: LD_VAR 0 7
102926: ARRAY
102927: PPUSH
102928: CALL_OW 264
102932: PUSH
102933: LD_INT 29
102935: EQUAL
102936: IFFALSE 103302
// begin if WantsToAttack ( group [ i ] ) in bombed then
102938: LD_VAR 0 4
102942: PUSH
102943: LD_VAR 0 7
102947: ARRAY
102948: PPUSH
102949: CALL_OW 319
102953: PUSH
102954: LD_VAR 0 28
102958: IN
102959: IFFALSE 102963
// continue ;
102961: GO 99967
// k := 8 ;
102963: LD_ADDR_VAR 0 9
102967: PUSH
102968: LD_INT 8
102970: ST_TO_ADDR
// x := 0 ;
102971: LD_ADDR_VAR 0 10
102975: PUSH
102976: LD_INT 0
102978: ST_TO_ADDR
// if tmp < k then
102979: LD_VAR 0 14
102983: PUSH
102984: LD_VAR 0 9
102988: LESS
102989: IFFALSE 103001
// k := tmp ;
102991: LD_ADDR_VAR 0 9
102995: PUSH
102996: LD_VAR 0 14
103000: ST_TO_ADDR
// for j = 1 to k do
103001: LD_ADDR_VAR 0 8
103005: PUSH
103006: DOUBLE
103007: LD_INT 1
103009: DEC
103010: ST_TO_ADDR
103011: LD_VAR 0 9
103015: PUSH
103016: FOR_TO
103017: IFFALSE 103149
// begin if GetType ( tmp [ j ] ) = unit_building then
103019: LD_VAR 0 14
103023: PUSH
103024: LD_VAR 0 8
103028: ARRAY
103029: PPUSH
103030: CALL_OW 247
103034: PUSH
103035: LD_INT 3
103037: EQUAL
103038: IFFALSE 103147
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103040: LD_VAR 0 14
103044: PUSH
103045: LD_VAR 0 8
103049: ARRAY
103050: PUSH
103051: LD_VAR 0 28
103055: IN
103056: NOT
103057: PUSH
103058: LD_VAR 0 14
103062: PUSH
103063: LD_VAR 0 8
103067: ARRAY
103068: PPUSH
103069: CALL_OW 313
103073: AND
103074: IFFALSE 103147
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103076: LD_VAR 0 4
103080: PUSH
103081: LD_VAR 0 7
103085: ARRAY
103086: PPUSH
103087: LD_VAR 0 14
103091: PUSH
103092: LD_VAR 0 8
103096: ARRAY
103097: PPUSH
103098: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103102: LD_ADDR_VAR 0 28
103106: PUSH
103107: LD_VAR 0 28
103111: PPUSH
103112: LD_VAR 0 28
103116: PUSH
103117: LD_INT 1
103119: PLUS
103120: PPUSH
103121: LD_VAR 0 14
103125: PUSH
103126: LD_VAR 0 8
103130: ARRAY
103131: PPUSH
103132: CALL_OW 1
103136: ST_TO_ADDR
// attacking := true ;
103137: LD_ADDR_VAR 0 29
103141: PUSH
103142: LD_INT 1
103144: ST_TO_ADDR
// break ;
103145: GO 103149
// end ; end ;
103147: GO 103016
103149: POP
103150: POP
// if not attacking and f_attack_depot then
103151: LD_VAR 0 29
103155: NOT
103156: PUSH
103157: LD_VAR 0 25
103161: AND
103162: IFFALSE 103257
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103164: LD_ADDR_VAR 0 13
103168: PUSH
103169: LD_VAR 0 14
103173: PPUSH
103174: LD_INT 2
103176: PUSH
103177: LD_INT 30
103179: PUSH
103180: LD_INT 0
103182: PUSH
103183: EMPTY
103184: LIST
103185: LIST
103186: PUSH
103187: LD_INT 30
103189: PUSH
103190: LD_INT 1
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: LIST
103201: PPUSH
103202: CALL_OW 72
103206: ST_TO_ADDR
// if z then
103207: LD_VAR 0 13
103211: IFFALSE 103257
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103213: LD_VAR 0 4
103217: PUSH
103218: LD_VAR 0 7
103222: ARRAY
103223: PPUSH
103224: LD_VAR 0 13
103228: PPUSH
103229: LD_VAR 0 4
103233: PUSH
103234: LD_VAR 0 7
103238: ARRAY
103239: PPUSH
103240: CALL_OW 74
103244: PPUSH
103245: CALL_OW 115
// attacking := true ;
103249: LD_ADDR_VAR 0 29
103253: PUSH
103254: LD_INT 1
103256: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103257: LD_VAR 0 4
103261: PUSH
103262: LD_VAR 0 7
103266: ARRAY
103267: PPUSH
103268: CALL_OW 256
103272: PUSH
103273: LD_INT 500
103275: LESS
103276: IFFALSE 103302
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103278: LD_VAR 0 4
103282: PUSH
103283: LD_VAR 0 7
103287: ARRAY
103288: PPUSH
103289: LD_VAR 0 14
103293: PUSH
103294: LD_INT 1
103296: ARRAY
103297: PPUSH
103298: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103302: LD_VAR 0 4
103306: PUSH
103307: LD_VAR 0 7
103311: ARRAY
103312: PPUSH
103313: CALL_OW 264
103317: PUSH
103318: LD_INT 49
103320: EQUAL
103321: IFFALSE 103442
// begin if not HasTask ( group [ i ] ) then
103323: LD_VAR 0 4
103327: PUSH
103328: LD_VAR 0 7
103332: ARRAY
103333: PPUSH
103334: CALL_OW 314
103338: NOT
103339: IFFALSE 103442
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103341: LD_ADDR_VAR 0 9
103345: PUSH
103346: LD_INT 81
103348: PUSH
103349: LD_VAR 0 4
103353: PUSH
103354: LD_VAR 0 7
103358: ARRAY
103359: PPUSH
103360: CALL_OW 255
103364: PUSH
103365: EMPTY
103366: LIST
103367: LIST
103368: PPUSH
103369: CALL_OW 69
103373: PPUSH
103374: LD_VAR 0 4
103378: PUSH
103379: LD_VAR 0 7
103383: ARRAY
103384: PPUSH
103385: CALL_OW 74
103389: ST_TO_ADDR
// if k then
103390: LD_VAR 0 9
103394: IFFALSE 103442
// if GetDistUnits ( group [ i ] , k ) > 10 then
103396: LD_VAR 0 4
103400: PUSH
103401: LD_VAR 0 7
103405: ARRAY
103406: PPUSH
103407: LD_VAR 0 9
103411: PPUSH
103412: CALL_OW 296
103416: PUSH
103417: LD_INT 10
103419: GREATER
103420: IFFALSE 103442
// ComMoveUnit ( group [ i ] , k ) ;
103422: LD_VAR 0 4
103426: PUSH
103427: LD_VAR 0 7
103431: ARRAY
103432: PPUSH
103433: LD_VAR 0 9
103437: PPUSH
103438: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103442: LD_VAR 0 4
103446: PUSH
103447: LD_VAR 0 7
103451: ARRAY
103452: PPUSH
103453: CALL_OW 256
103457: PUSH
103458: LD_INT 250
103460: LESS
103461: PUSH
103462: LD_VAR 0 4
103466: PUSH
103467: LD_VAR 0 7
103471: ARRAY
103472: PUSH
103473: LD_INT 21
103475: PUSH
103476: LD_INT 2
103478: PUSH
103479: EMPTY
103480: LIST
103481: LIST
103482: PUSH
103483: LD_INT 23
103485: PUSH
103486: LD_INT 2
103488: PUSH
103489: EMPTY
103490: LIST
103491: LIST
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: PPUSH
103497: CALL_OW 69
103501: IN
103502: AND
103503: IFFALSE 103628
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103505: LD_ADDR_VAR 0 9
103509: PUSH
103510: LD_OWVAR 3
103514: PUSH
103515: LD_VAR 0 4
103519: PUSH
103520: LD_VAR 0 7
103524: ARRAY
103525: DIFF
103526: PPUSH
103527: LD_VAR 0 4
103531: PUSH
103532: LD_VAR 0 7
103536: ARRAY
103537: PPUSH
103538: CALL_OW 74
103542: ST_TO_ADDR
// if not k then
103543: LD_VAR 0 9
103547: NOT
103548: IFFALSE 103552
// continue ;
103550: GO 99967
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103552: LD_VAR 0 9
103556: PUSH
103557: LD_INT 81
103559: PUSH
103560: LD_VAR 0 4
103564: PUSH
103565: LD_VAR 0 7
103569: ARRAY
103570: PPUSH
103571: CALL_OW 255
103575: PUSH
103576: EMPTY
103577: LIST
103578: LIST
103579: PPUSH
103580: CALL_OW 69
103584: IN
103585: PUSH
103586: LD_VAR 0 9
103590: PPUSH
103591: LD_VAR 0 4
103595: PUSH
103596: LD_VAR 0 7
103600: ARRAY
103601: PPUSH
103602: CALL_OW 296
103606: PUSH
103607: LD_INT 5
103609: LESS
103610: AND
103611: IFFALSE 103628
// ComAutodestruct ( group [ i ] ) ;
103613: LD_VAR 0 4
103617: PUSH
103618: LD_VAR 0 7
103622: ARRAY
103623: PPUSH
103624: CALL 46702 0 1
// end ; if f_attack_depot then
103628: LD_VAR 0 25
103632: IFFALSE 103744
// begin k := 6 ;
103634: LD_ADDR_VAR 0 9
103638: PUSH
103639: LD_INT 6
103641: ST_TO_ADDR
// if tmp < k then
103642: LD_VAR 0 14
103646: PUSH
103647: LD_VAR 0 9
103651: LESS
103652: IFFALSE 103664
// k := tmp ;
103654: LD_ADDR_VAR 0 9
103658: PUSH
103659: LD_VAR 0 14
103663: ST_TO_ADDR
// for j = 1 to k do
103664: LD_ADDR_VAR 0 8
103668: PUSH
103669: DOUBLE
103670: LD_INT 1
103672: DEC
103673: ST_TO_ADDR
103674: LD_VAR 0 9
103678: PUSH
103679: FOR_TO
103680: IFFALSE 103742
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103682: LD_VAR 0 8
103686: PPUSH
103687: CALL_OW 266
103691: PUSH
103692: LD_INT 0
103694: PUSH
103695: LD_INT 1
103697: PUSH
103698: EMPTY
103699: LIST
103700: LIST
103701: IN
103702: IFFALSE 103740
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103704: LD_VAR 0 4
103708: PUSH
103709: LD_VAR 0 7
103713: ARRAY
103714: PPUSH
103715: LD_VAR 0 14
103719: PUSH
103720: LD_VAR 0 8
103724: ARRAY
103725: PPUSH
103726: CALL_OW 115
// attacking := true ;
103730: LD_ADDR_VAR 0 29
103734: PUSH
103735: LD_INT 1
103737: ST_TO_ADDR
// break ;
103738: GO 103742
// end ;
103740: GO 103679
103742: POP
103743: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103744: LD_VAR 0 4
103748: PUSH
103749: LD_VAR 0 7
103753: ARRAY
103754: PPUSH
103755: CALL_OW 302
103759: PUSH
103760: LD_VAR 0 29
103764: NOT
103765: AND
103766: IFFALSE 104088
// begin if GetTag ( group [ i ] ) = 71 then
103768: LD_VAR 0 4
103772: PUSH
103773: LD_VAR 0 7
103777: ARRAY
103778: PPUSH
103779: CALL_OW 110
103783: PUSH
103784: LD_INT 71
103786: EQUAL
103787: IFFALSE 103828
// begin if HasTask ( group [ i ] ) then
103789: LD_VAR 0 4
103793: PUSH
103794: LD_VAR 0 7
103798: ARRAY
103799: PPUSH
103800: CALL_OW 314
103804: IFFALSE 103810
// continue else
103806: GO 99967
103808: GO 103828
// SetTag ( group [ i ] , 0 ) ;
103810: LD_VAR 0 4
103814: PUSH
103815: LD_VAR 0 7
103819: ARRAY
103820: PPUSH
103821: LD_INT 0
103823: PPUSH
103824: CALL_OW 109
// end ; k := 8 ;
103828: LD_ADDR_VAR 0 9
103832: PUSH
103833: LD_INT 8
103835: ST_TO_ADDR
// x := 0 ;
103836: LD_ADDR_VAR 0 10
103840: PUSH
103841: LD_INT 0
103843: ST_TO_ADDR
// if tmp < k then
103844: LD_VAR 0 14
103848: PUSH
103849: LD_VAR 0 9
103853: LESS
103854: IFFALSE 103866
// k := tmp ;
103856: LD_ADDR_VAR 0 9
103860: PUSH
103861: LD_VAR 0 14
103865: ST_TO_ADDR
// for j = 1 to k do
103866: LD_ADDR_VAR 0 8
103870: PUSH
103871: DOUBLE
103872: LD_INT 1
103874: DEC
103875: ST_TO_ADDR
103876: LD_VAR 0 9
103880: PUSH
103881: FOR_TO
103882: IFFALSE 103980
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103884: LD_VAR 0 14
103888: PUSH
103889: LD_VAR 0 8
103893: ARRAY
103894: PPUSH
103895: CALL_OW 247
103899: PUSH
103900: LD_INT 1
103902: EQUAL
103903: PUSH
103904: LD_VAR 0 14
103908: PUSH
103909: LD_VAR 0 8
103913: ARRAY
103914: PPUSH
103915: CALL_OW 256
103919: PUSH
103920: LD_INT 250
103922: LESS
103923: PUSH
103924: LD_VAR 0 20
103928: AND
103929: PUSH
103930: LD_VAR 0 20
103934: NOT
103935: PUSH
103936: LD_VAR 0 14
103940: PUSH
103941: LD_VAR 0 8
103945: ARRAY
103946: PPUSH
103947: CALL_OW 256
103951: PUSH
103952: LD_INT 250
103954: GREATEREQUAL
103955: AND
103956: OR
103957: AND
103958: IFFALSE 103978
// begin x := tmp [ j ] ;
103960: LD_ADDR_VAR 0 10
103964: PUSH
103965: LD_VAR 0 14
103969: PUSH
103970: LD_VAR 0 8
103974: ARRAY
103975: ST_TO_ADDR
// break ;
103976: GO 103980
// end ;
103978: GO 103881
103980: POP
103981: POP
// if x then
103982: LD_VAR 0 10
103986: IFFALSE 104010
// ComAttackUnit ( group [ i ] , x ) else
103988: LD_VAR 0 4
103992: PUSH
103993: LD_VAR 0 7
103997: ARRAY
103998: PPUSH
103999: LD_VAR 0 10
104003: PPUSH
104004: CALL_OW 115
104008: GO 104034
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104010: LD_VAR 0 4
104014: PUSH
104015: LD_VAR 0 7
104019: ARRAY
104020: PPUSH
104021: LD_VAR 0 14
104025: PUSH
104026: LD_INT 1
104028: ARRAY
104029: PPUSH
104030: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104034: LD_VAR 0 4
104038: PUSH
104039: LD_VAR 0 7
104043: ARRAY
104044: PPUSH
104045: CALL_OW 314
104049: NOT
104050: IFFALSE 104088
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104052: LD_VAR 0 4
104056: PUSH
104057: LD_VAR 0 7
104061: ARRAY
104062: PPUSH
104063: LD_VAR 0 14
104067: PPUSH
104068: LD_VAR 0 4
104072: PUSH
104073: LD_VAR 0 7
104077: ARRAY
104078: PPUSH
104079: CALL_OW 74
104083: PPUSH
104084: CALL_OW 115
// end ; end ; end ;
104088: GO 99967
104090: POP
104091: POP
// wait ( 0 0$2 ) ;
104092: LD_INT 70
104094: PPUSH
104095: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104099: LD_VAR 0 4
104103: NOT
104104: PUSH
104105: LD_VAR 0 4
104109: PUSH
104110: EMPTY
104111: EQUAL
104112: OR
104113: PUSH
104114: LD_INT 81
104116: PUSH
104117: LD_VAR 0 35
104121: PUSH
104122: EMPTY
104123: LIST
104124: LIST
104125: PPUSH
104126: CALL_OW 69
104130: NOT
104131: OR
104132: IFFALSE 99952
// end ;
104134: LD_VAR 0 2
104138: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
104139: LD_INT 0
104141: PPUSH
104142: PPUSH
104143: PPUSH
104144: PPUSH
104145: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
104146: LD_VAR 0 1
104150: NOT
104151: PUSH
104152: LD_EXP 59
104156: PUSH
104157: LD_VAR 0 1
104161: ARRAY
104162: NOT
104163: OR
104164: PUSH
104165: LD_VAR 0 2
104169: NOT
104170: OR
104171: PUSH
104172: LD_VAR 0 3
104176: NOT
104177: OR
104178: IFFALSE 104182
// exit ;
104180: GO 104695
// side := mc_sides [ base ] ;
104182: LD_ADDR_VAR 0 6
104186: PUSH
104187: LD_EXP 85
104191: PUSH
104192: LD_VAR 0 1
104196: ARRAY
104197: ST_TO_ADDR
// if not side then
104198: LD_VAR 0 6
104202: NOT
104203: IFFALSE 104207
// exit ;
104205: GO 104695
// for i in solds do
104207: LD_ADDR_VAR 0 7
104211: PUSH
104212: LD_VAR 0 2
104216: PUSH
104217: FOR_IN
104218: IFFALSE 104279
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
104220: LD_VAR 0 7
104224: PPUSH
104225: CALL_OW 310
104229: PPUSH
104230: CALL_OW 266
104234: PUSH
104235: LD_INT 32
104237: PUSH
104238: LD_INT 31
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: IN
104245: IFFALSE 104265
// solds := solds diff i else
104247: LD_ADDR_VAR 0 2
104251: PUSH
104252: LD_VAR 0 2
104256: PUSH
104257: LD_VAR 0 7
104261: DIFF
104262: ST_TO_ADDR
104263: GO 104277
// SetTag ( i , 18 ) ;
104265: LD_VAR 0 7
104269: PPUSH
104270: LD_INT 18
104272: PPUSH
104273: CALL_OW 109
104277: GO 104217
104279: POP
104280: POP
// if not solds then
104281: LD_VAR 0 2
104285: NOT
104286: IFFALSE 104290
// exit ;
104288: GO 104695
// repeat wait ( 0 0$2 ) ;
104290: LD_INT 70
104292: PPUSH
104293: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
104297: LD_ADDR_VAR 0 5
104301: PUSH
104302: LD_VAR 0 6
104306: PPUSH
104307: LD_VAR 0 3
104311: PPUSH
104312: CALL 16084 0 2
104316: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104317: LD_EXP 59
104321: PUSH
104322: LD_VAR 0 1
104326: ARRAY
104327: NOT
104328: PUSH
104329: LD_EXP 59
104333: PUSH
104334: LD_VAR 0 1
104338: ARRAY
104339: PUSH
104340: EMPTY
104341: EQUAL
104342: OR
104343: IFFALSE 104380
// begin for i in solds do
104345: LD_ADDR_VAR 0 7
104349: PUSH
104350: LD_VAR 0 2
104354: PUSH
104355: FOR_IN
104356: IFFALSE 104369
// ComStop ( i ) ;
104358: LD_VAR 0 7
104362: PPUSH
104363: CALL_OW 141
104367: GO 104355
104369: POP
104370: POP
// solds := [ ] ;
104371: LD_ADDR_VAR 0 2
104375: PUSH
104376: EMPTY
104377: ST_TO_ADDR
// exit ;
104378: GO 104695
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
104380: LD_VAR 0 5
104384: NOT
104385: PUSH
104386: LD_VAR 0 5
104390: PUSH
104391: LD_INT 3
104393: GREATER
104394: OR
104395: PUSH
104396: LD_EXP 81
104400: PUSH
104401: LD_VAR 0 1
104405: ARRAY
104406: OR
104407: IFFALSE 104448
// begin for i in solds do
104409: LD_ADDR_VAR 0 7
104413: PUSH
104414: LD_VAR 0 2
104418: PUSH
104419: FOR_IN
104420: IFFALSE 104444
// if HasTask ( i ) then
104422: LD_VAR 0 7
104426: PPUSH
104427: CALL_OW 314
104431: IFFALSE 104442
// ComStop ( i ) ;
104433: LD_VAR 0 7
104437: PPUSH
104438: CALL_OW 141
104442: GO 104419
104444: POP
104445: POP
// break ;
104446: GO 104683
// end ; for i in solds do
104448: LD_ADDR_VAR 0 7
104452: PUSH
104453: LD_VAR 0 2
104457: PUSH
104458: FOR_IN
104459: IFFALSE 104675
// begin if IsInUnit ( i ) then
104461: LD_VAR 0 7
104465: PPUSH
104466: CALL_OW 310
104470: IFFALSE 104481
// ComExitBuilding ( i ) ;
104472: LD_VAR 0 7
104476: PPUSH
104477: CALL_OW 122
// if GetLives ( i ) > 333 then
104481: LD_VAR 0 7
104485: PPUSH
104486: CALL_OW 256
104490: PUSH
104491: LD_INT 333
104493: GREATER
104494: IFFALSE 104522
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104496: LD_VAR 0 7
104500: PPUSH
104501: LD_VAR 0 5
104505: PPUSH
104506: LD_VAR 0 7
104510: PPUSH
104511: CALL_OW 74
104515: PPUSH
104516: CALL_OW 115
104520: GO 104673
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
104522: LD_ADDR_VAR 0 8
104526: PUSH
104527: LD_EXP 59
104531: PUSH
104532: LD_VAR 0 1
104536: ARRAY
104537: PPUSH
104538: LD_INT 2
104540: PUSH
104541: LD_INT 30
104543: PUSH
104544: LD_INT 0
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: PUSH
104551: LD_INT 30
104553: PUSH
104554: LD_INT 1
104556: PUSH
104557: EMPTY
104558: LIST
104559: LIST
104560: PUSH
104561: LD_INT 30
104563: PUSH
104564: LD_INT 6
104566: PUSH
104567: EMPTY
104568: LIST
104569: LIST
104570: PUSH
104571: EMPTY
104572: LIST
104573: LIST
104574: LIST
104575: LIST
104576: PPUSH
104577: CALL_OW 72
104581: PPUSH
104582: LD_VAR 0 7
104586: PPUSH
104587: CALL_OW 74
104591: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
104592: LD_VAR 0 7
104596: PPUSH
104597: LD_VAR 0 8
104601: PPUSH
104602: CALL_OW 250
104606: PPUSH
104607: LD_INT 3
104609: PPUSH
104610: LD_INT 5
104612: PPUSH
104613: CALL_OW 272
104617: PPUSH
104618: LD_VAR 0 8
104622: PPUSH
104623: CALL_OW 251
104627: PPUSH
104628: LD_INT 3
104630: PPUSH
104631: LD_INT 5
104633: PPUSH
104634: CALL_OW 273
104638: PPUSH
104639: CALL_OW 111
// SetTag ( i , 0 ) ;
104643: LD_VAR 0 7
104647: PPUSH
104648: LD_INT 0
104650: PPUSH
104651: CALL_OW 109
// solds := solds diff i ;
104655: LD_ADDR_VAR 0 2
104659: PUSH
104660: LD_VAR 0 2
104664: PUSH
104665: LD_VAR 0 7
104669: DIFF
104670: ST_TO_ADDR
// continue ;
104671: GO 104458
// end ; end ;
104673: GO 104458
104675: POP
104676: POP
// until solds ;
104677: LD_VAR 0 2
104681: IFFALSE 104290
// MC_Reset ( base , 18 ) ;
104683: LD_VAR 0 1
104687: PPUSH
104688: LD_INT 18
104690: PPUSH
104691: CALL 56071 0 2
// end ;
104695: LD_VAR 0 4
104699: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
104700: LD_INT 0
104702: PPUSH
104703: PPUSH
104704: PPUSH
104705: PPUSH
104706: PPUSH
104707: PPUSH
104708: PPUSH
104709: PPUSH
104710: PPUSH
104711: PPUSH
104712: PPUSH
104713: PPUSH
104714: PPUSH
104715: PPUSH
104716: PPUSH
104717: PPUSH
104718: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
104719: LD_ADDR_VAR 0 13
104723: PUSH
104724: LD_EXP 59
104728: PUSH
104729: LD_VAR 0 1
104733: ARRAY
104734: PPUSH
104735: LD_INT 25
104737: PUSH
104738: LD_INT 3
104740: PUSH
104741: EMPTY
104742: LIST
104743: LIST
104744: PPUSH
104745: CALL_OW 72
104749: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104750: LD_EXP 99
104754: PUSH
104755: LD_VAR 0 1
104759: ARRAY
104760: IFFALSE 104784
// mechs := mechs diff mc_remote_driver [ base ] ;
104762: LD_ADDR_VAR 0 13
104766: PUSH
104767: LD_VAR 0 13
104771: PUSH
104772: LD_EXP 99
104776: PUSH
104777: LD_VAR 0 1
104781: ARRAY
104782: DIFF
104783: ST_TO_ADDR
// for i in mechs do
104784: LD_ADDR_VAR 0 5
104788: PUSH
104789: LD_VAR 0 13
104793: PUSH
104794: FOR_IN
104795: IFFALSE 104830
// if GetTag ( i ) > 0 then
104797: LD_VAR 0 5
104801: PPUSH
104802: CALL_OW 110
104806: PUSH
104807: LD_INT 0
104809: GREATER
104810: IFFALSE 104828
// mechs := mechs diff i ;
104812: LD_ADDR_VAR 0 13
104816: PUSH
104817: LD_VAR 0 13
104821: PUSH
104822: LD_VAR 0 5
104826: DIFF
104827: ST_TO_ADDR
104828: GO 104794
104830: POP
104831: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104832: LD_ADDR_VAR 0 9
104836: PUSH
104837: LD_EXP 59
104841: PUSH
104842: LD_VAR 0 1
104846: ARRAY
104847: PPUSH
104848: LD_INT 2
104850: PUSH
104851: LD_INT 25
104853: PUSH
104854: LD_INT 1
104856: PUSH
104857: EMPTY
104858: LIST
104859: LIST
104860: PUSH
104861: LD_INT 25
104863: PUSH
104864: LD_INT 5
104866: PUSH
104867: EMPTY
104868: LIST
104869: LIST
104870: PUSH
104871: LD_INT 25
104873: PUSH
104874: LD_INT 8
104876: PUSH
104877: EMPTY
104878: LIST
104879: LIST
104880: PUSH
104881: LD_INT 25
104883: PUSH
104884: LD_INT 9
104886: PUSH
104887: EMPTY
104888: LIST
104889: LIST
104890: PUSH
104891: EMPTY
104892: LIST
104893: LIST
104894: LIST
104895: LIST
104896: LIST
104897: PPUSH
104898: CALL_OW 72
104902: ST_TO_ADDR
// if not defenders and not solds then
104903: LD_VAR 0 2
104907: NOT
104908: PUSH
104909: LD_VAR 0 9
104913: NOT
104914: AND
104915: IFFALSE 104919
// exit ;
104917: GO 106609
// depot_under_attack := false ;
104919: LD_ADDR_VAR 0 17
104923: PUSH
104924: LD_INT 0
104926: ST_TO_ADDR
// sold_defenders := [ ] ;
104927: LD_ADDR_VAR 0 18
104931: PUSH
104932: EMPTY
104933: ST_TO_ADDR
// if mechs then
104934: LD_VAR 0 13
104938: IFFALSE 105091
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
104940: LD_ADDR_VAR 0 5
104944: PUSH
104945: LD_VAR 0 2
104949: PPUSH
104950: LD_INT 21
104952: PUSH
104953: LD_INT 2
104955: PUSH
104956: EMPTY
104957: LIST
104958: LIST
104959: PPUSH
104960: CALL_OW 72
104964: PUSH
104965: FOR_IN
104966: IFFALSE 105089
// begin if GetTag ( i ) <> 20 then
104968: LD_VAR 0 5
104972: PPUSH
104973: CALL_OW 110
104977: PUSH
104978: LD_INT 20
104980: NONEQUAL
104981: IFFALSE 104995
// SetTag ( i , 20 ) ;
104983: LD_VAR 0 5
104987: PPUSH
104988: LD_INT 20
104990: PPUSH
104991: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
104995: LD_VAR 0 5
104999: PPUSH
105000: CALL_OW 263
105004: PUSH
105005: LD_INT 1
105007: EQUAL
105008: PUSH
105009: LD_VAR 0 5
105013: PPUSH
105014: CALL_OW 311
105018: NOT
105019: AND
105020: IFFALSE 105087
// begin un := mechs [ 1 ] ;
105022: LD_ADDR_VAR 0 11
105026: PUSH
105027: LD_VAR 0 13
105031: PUSH
105032: LD_INT 1
105034: ARRAY
105035: ST_TO_ADDR
// ComExit ( un ) ;
105036: LD_VAR 0 11
105040: PPUSH
105041: CALL 51047 0 1
// AddComEnterUnit ( un , i ) ;
105045: LD_VAR 0 11
105049: PPUSH
105050: LD_VAR 0 5
105054: PPUSH
105055: CALL_OW 180
// SetTag ( un , 19 ) ;
105059: LD_VAR 0 11
105063: PPUSH
105064: LD_INT 19
105066: PPUSH
105067: CALL_OW 109
// mechs := mechs diff un ;
105071: LD_ADDR_VAR 0 13
105075: PUSH
105076: LD_VAR 0 13
105080: PUSH
105081: LD_VAR 0 11
105085: DIFF
105086: ST_TO_ADDR
// end ; end ;
105087: GO 104965
105089: POP
105090: POP
// if solds then
105091: LD_VAR 0 9
105095: IFFALSE 105154
// for i in solds do
105097: LD_ADDR_VAR 0 5
105101: PUSH
105102: LD_VAR 0 9
105106: PUSH
105107: FOR_IN
105108: IFFALSE 105152
// if not GetTag ( i ) then
105110: LD_VAR 0 5
105114: PPUSH
105115: CALL_OW 110
105119: NOT
105120: IFFALSE 105150
// begin defenders := defenders union i ;
105122: LD_ADDR_VAR 0 2
105126: PUSH
105127: LD_VAR 0 2
105131: PUSH
105132: LD_VAR 0 5
105136: UNION
105137: ST_TO_ADDR
// SetTag ( i , 18 ) ;
105138: LD_VAR 0 5
105142: PPUSH
105143: LD_INT 18
105145: PPUSH
105146: CALL_OW 109
// end ;
105150: GO 105107
105152: POP
105153: POP
// repeat wait ( 0 0$2 ) ;
105154: LD_INT 70
105156: PPUSH
105157: CALL_OW 67
// enemy := mc_scan [ base ] ;
105161: LD_ADDR_VAR 0 3
105165: PUSH
105166: LD_EXP 82
105170: PUSH
105171: LD_VAR 0 1
105175: ARRAY
105176: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105177: LD_EXP 59
105181: PUSH
105182: LD_VAR 0 1
105186: ARRAY
105187: NOT
105188: PUSH
105189: LD_EXP 59
105193: PUSH
105194: LD_VAR 0 1
105198: ARRAY
105199: PUSH
105200: EMPTY
105201: EQUAL
105202: OR
105203: IFFALSE 105240
// begin for i in defenders do
105205: LD_ADDR_VAR 0 5
105209: PUSH
105210: LD_VAR 0 2
105214: PUSH
105215: FOR_IN
105216: IFFALSE 105229
// ComStop ( i ) ;
105218: LD_VAR 0 5
105222: PPUSH
105223: CALL_OW 141
105227: GO 105215
105229: POP
105230: POP
// defenders := [ ] ;
105231: LD_ADDR_VAR 0 2
105235: PUSH
105236: EMPTY
105237: ST_TO_ADDR
// exit ;
105238: GO 106609
// end ; for i in defenders do
105240: LD_ADDR_VAR 0 5
105244: PUSH
105245: LD_VAR 0 2
105249: PUSH
105250: FOR_IN
105251: IFFALSE 106069
// begin e := NearestUnitToUnit ( enemy , i ) ;
105253: LD_ADDR_VAR 0 14
105257: PUSH
105258: LD_VAR 0 3
105262: PPUSH
105263: LD_VAR 0 5
105267: PPUSH
105268: CALL_OW 74
105272: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105273: LD_ADDR_VAR 0 8
105277: PUSH
105278: LD_EXP 59
105282: PUSH
105283: LD_VAR 0 1
105287: ARRAY
105288: PPUSH
105289: LD_INT 2
105291: PUSH
105292: LD_INT 30
105294: PUSH
105295: LD_INT 0
105297: PUSH
105298: EMPTY
105299: LIST
105300: LIST
105301: PUSH
105302: LD_INT 30
105304: PUSH
105305: LD_INT 1
105307: PUSH
105308: EMPTY
105309: LIST
105310: LIST
105311: PUSH
105312: EMPTY
105313: LIST
105314: LIST
105315: LIST
105316: PPUSH
105317: CALL_OW 72
105321: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
105322: LD_ADDR_VAR 0 17
105326: PUSH
105327: LD_VAR 0 8
105331: NOT
105332: PUSH
105333: LD_VAR 0 8
105337: PPUSH
105338: LD_INT 3
105340: PUSH
105341: LD_INT 24
105343: PUSH
105344: LD_INT 600
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: PUSH
105351: EMPTY
105352: LIST
105353: LIST
105354: PPUSH
105355: CALL_OW 72
105359: OR
105360: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
105361: LD_VAR 0 5
105365: PPUSH
105366: CALL_OW 247
105370: PUSH
105371: LD_INT 2
105373: DOUBLE
105374: EQUAL
105375: IFTRUE 105379
105377: GO 105775
105379: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
105380: LD_VAR 0 5
105384: PPUSH
105385: CALL_OW 256
105389: PUSH
105390: LD_INT 650
105392: GREATER
105393: PUSH
105394: LD_VAR 0 5
105398: PPUSH
105399: LD_VAR 0 14
105403: PPUSH
105404: CALL_OW 296
105408: PUSH
105409: LD_INT 40
105411: LESS
105412: PUSH
105413: LD_VAR 0 14
105417: PPUSH
105418: LD_EXP 84
105422: PUSH
105423: LD_VAR 0 1
105427: ARRAY
105428: PPUSH
105429: CALL_OW 308
105433: OR
105434: AND
105435: IFFALSE 105557
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
105437: LD_VAR 0 5
105441: PPUSH
105442: CALL_OW 262
105446: PUSH
105447: LD_INT 1
105449: EQUAL
105450: PUSH
105451: LD_VAR 0 5
105455: PPUSH
105456: CALL_OW 261
105460: PUSH
105461: LD_INT 30
105463: LESS
105464: AND
105465: PUSH
105466: LD_VAR 0 8
105470: AND
105471: IFFALSE 105541
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
105473: LD_VAR 0 5
105477: PPUSH
105478: LD_VAR 0 8
105482: PPUSH
105483: LD_VAR 0 5
105487: PPUSH
105488: CALL_OW 74
105492: PPUSH
105493: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
105497: LD_VAR 0 5
105501: PPUSH
105502: LD_VAR 0 8
105506: PPUSH
105507: LD_VAR 0 5
105511: PPUSH
105512: CALL_OW 74
105516: PPUSH
105517: CALL_OW 296
105521: PUSH
105522: LD_INT 6
105524: LESS
105525: IFFALSE 105539
// SetFuel ( i , 100 ) ;
105527: LD_VAR 0 5
105531: PPUSH
105532: LD_INT 100
105534: PPUSH
105535: CALL_OW 240
// end else
105539: GO 105555
// ComAttackUnit ( i , e ) ;
105541: LD_VAR 0 5
105545: PPUSH
105546: LD_VAR 0 14
105550: PPUSH
105551: CALL_OW 115
// end else
105555: GO 105658
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
105557: LD_VAR 0 14
105561: PPUSH
105562: LD_EXP 84
105566: PUSH
105567: LD_VAR 0 1
105571: ARRAY
105572: PPUSH
105573: CALL_OW 308
105577: NOT
105578: PUSH
105579: LD_VAR 0 5
105583: PPUSH
105584: LD_VAR 0 14
105588: PPUSH
105589: CALL_OW 296
105593: PUSH
105594: LD_INT 40
105596: GREATEREQUAL
105597: AND
105598: PUSH
105599: LD_VAR 0 5
105603: PPUSH
105604: CALL_OW 256
105608: PUSH
105609: LD_INT 650
105611: LESSEQUAL
105612: OR
105613: PUSH
105614: LD_VAR 0 5
105618: PPUSH
105619: LD_EXP 83
105623: PUSH
105624: LD_VAR 0 1
105628: ARRAY
105629: PPUSH
105630: CALL_OW 308
105634: NOT
105635: AND
105636: IFFALSE 105658
// ComMoveToArea ( i , mc_parking [ base ] ) ;
105638: LD_VAR 0 5
105642: PPUSH
105643: LD_EXP 83
105647: PUSH
105648: LD_VAR 0 1
105652: ARRAY
105653: PPUSH
105654: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
105658: LD_VAR 0 5
105662: PPUSH
105663: CALL_OW 256
105667: PUSH
105668: LD_INT 998
105670: LESS
105671: PUSH
105672: LD_VAR 0 5
105676: PPUSH
105677: CALL_OW 263
105681: PUSH
105682: LD_INT 1
105684: EQUAL
105685: AND
105686: PUSH
105687: LD_VAR 0 5
105691: PPUSH
105692: CALL_OW 311
105696: AND
105697: PUSH
105698: LD_VAR 0 5
105702: PPUSH
105703: LD_EXP 83
105707: PUSH
105708: LD_VAR 0 1
105712: ARRAY
105713: PPUSH
105714: CALL_OW 308
105718: AND
105719: IFFALSE 105773
// begin mech := IsDrivenBy ( i ) ;
105721: LD_ADDR_VAR 0 10
105725: PUSH
105726: LD_VAR 0 5
105730: PPUSH
105731: CALL_OW 311
105735: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105736: LD_VAR 0 10
105740: PPUSH
105741: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105745: LD_VAR 0 10
105749: PPUSH
105750: LD_VAR 0 5
105754: PPUSH
105755: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105759: LD_VAR 0 10
105763: PPUSH
105764: LD_VAR 0 5
105768: PPUSH
105769: CALL_OW 180
// end ; end ; unit_human :
105773: GO 106040
105775: LD_INT 1
105777: DOUBLE
105778: EQUAL
105779: IFTRUE 105783
105781: GO 106039
105783: POP
// begin b := IsInUnit ( i ) ;
105784: LD_ADDR_VAR 0 19
105788: PUSH
105789: LD_VAR 0 5
105793: PPUSH
105794: CALL_OW 310
105798: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105799: LD_ADDR_VAR 0 20
105803: PUSH
105804: LD_VAR 0 19
105808: NOT
105809: PUSH
105810: LD_VAR 0 19
105814: PPUSH
105815: CALL_OW 266
105819: PUSH
105820: LD_INT 32
105822: PUSH
105823: LD_INT 31
105825: PUSH
105826: EMPTY
105827: LIST
105828: LIST
105829: IN
105830: OR
105831: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
105832: LD_VAR 0 17
105836: PUSH
105837: LD_VAR 0 2
105841: PPUSH
105842: LD_INT 21
105844: PUSH
105845: LD_INT 2
105847: PUSH
105848: EMPTY
105849: LIST
105850: LIST
105851: PPUSH
105852: CALL_OW 72
105856: PUSH
105857: LD_INT 1
105859: LESSEQUAL
105860: OR
105861: PUSH
105862: LD_VAR 0 20
105866: AND
105867: PUSH
105868: LD_VAR 0 5
105872: PUSH
105873: LD_VAR 0 18
105877: IN
105878: NOT
105879: AND
105880: IFFALSE 105973
// begin if b then
105882: LD_VAR 0 19
105886: IFFALSE 105935
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
105888: LD_VAR 0 19
105892: PPUSH
105893: LD_VAR 0 3
105897: PPUSH
105898: LD_VAR 0 19
105902: PPUSH
105903: CALL_OW 74
105907: PPUSH
105908: CALL_OW 296
105912: PUSH
105913: LD_INT 10
105915: LESS
105916: PUSH
105917: LD_VAR 0 19
105921: PPUSH
105922: CALL_OW 461
105926: PUSH
105927: LD_INT 7
105929: NONEQUAL
105930: AND
105931: IFFALSE 105935
// continue ;
105933: GO 105250
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
105935: LD_ADDR_VAR 0 18
105939: PUSH
105940: LD_VAR 0 18
105944: PPUSH
105945: LD_VAR 0 18
105949: PUSH
105950: LD_INT 1
105952: PLUS
105953: PPUSH
105954: LD_VAR 0 5
105958: PPUSH
105959: CALL_OW 1
105963: ST_TO_ADDR
// ComExitBuilding ( i ) ;
105964: LD_VAR 0 5
105968: PPUSH
105969: CALL_OW 122
// end ; if sold_defenders then
105973: LD_VAR 0 18
105977: IFFALSE 106037
// if i in sold_defenders then
105979: LD_VAR 0 5
105983: PUSH
105984: LD_VAR 0 18
105988: IN
105989: IFFALSE 106037
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
105991: LD_VAR 0 5
105995: PPUSH
105996: CALL_OW 314
106000: NOT
106001: PUSH
106002: LD_VAR 0 5
106006: PPUSH
106007: LD_VAR 0 14
106011: PPUSH
106012: CALL_OW 296
106016: PUSH
106017: LD_INT 30
106019: LESS
106020: AND
106021: IFFALSE 106037
// ComAttackUnit ( i , e ) ;
106023: LD_VAR 0 5
106027: PPUSH
106028: LD_VAR 0 14
106032: PPUSH
106033: CALL_OW 115
// end ; end ; end ;
106037: GO 106040
106039: POP
// if IsDead ( i ) then
106040: LD_VAR 0 5
106044: PPUSH
106045: CALL_OW 301
106049: IFFALSE 106067
// defenders := defenders diff i ;
106051: LD_ADDR_VAR 0 2
106055: PUSH
106056: LD_VAR 0 2
106060: PUSH
106061: LD_VAR 0 5
106065: DIFF
106066: ST_TO_ADDR
// end ;
106067: GO 105250
106069: POP
106070: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
106071: LD_VAR 0 3
106075: NOT
106076: PUSH
106077: LD_VAR 0 2
106081: NOT
106082: OR
106083: PUSH
106084: LD_EXP 59
106088: PUSH
106089: LD_VAR 0 1
106093: ARRAY
106094: NOT
106095: OR
106096: IFFALSE 105154
// MC_Reset ( base , 18 ) ;
106098: LD_VAR 0 1
106102: PPUSH
106103: LD_INT 18
106105: PPUSH
106106: CALL 56071 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106110: LD_ADDR_VAR 0 2
106114: PUSH
106115: LD_VAR 0 2
106119: PUSH
106120: LD_VAR 0 2
106124: PPUSH
106125: LD_INT 2
106127: PUSH
106128: LD_INT 25
106130: PUSH
106131: LD_INT 1
106133: PUSH
106134: EMPTY
106135: LIST
106136: LIST
106137: PUSH
106138: LD_INT 25
106140: PUSH
106141: LD_INT 5
106143: PUSH
106144: EMPTY
106145: LIST
106146: LIST
106147: PUSH
106148: LD_INT 25
106150: PUSH
106151: LD_INT 8
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: PUSH
106158: LD_INT 25
106160: PUSH
106161: LD_INT 9
106163: PUSH
106164: EMPTY
106165: LIST
106166: LIST
106167: PUSH
106168: EMPTY
106169: LIST
106170: LIST
106171: LIST
106172: LIST
106173: LIST
106174: PPUSH
106175: CALL_OW 72
106179: DIFF
106180: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
106181: LD_VAR 0 3
106185: NOT
106186: PUSH
106187: LD_VAR 0 2
106191: PPUSH
106192: LD_INT 21
106194: PUSH
106195: LD_INT 2
106197: PUSH
106198: EMPTY
106199: LIST
106200: LIST
106201: PPUSH
106202: CALL_OW 72
106206: AND
106207: IFFALSE 106545
// begin tmp := FilterByTag ( defenders , 19 ) ;
106209: LD_ADDR_VAR 0 12
106213: PUSH
106214: LD_VAR 0 2
106218: PPUSH
106219: LD_INT 19
106221: PPUSH
106222: CALL 48177 0 2
106226: ST_TO_ADDR
// if tmp then
106227: LD_VAR 0 12
106231: IFFALSE 106301
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
106233: LD_ADDR_VAR 0 12
106237: PUSH
106238: LD_VAR 0 12
106242: PPUSH
106243: LD_INT 25
106245: PUSH
106246: LD_INT 3
106248: PUSH
106249: EMPTY
106250: LIST
106251: LIST
106252: PPUSH
106253: CALL_OW 72
106257: ST_TO_ADDR
// if tmp then
106258: LD_VAR 0 12
106262: IFFALSE 106301
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
106264: LD_ADDR_EXP 71
106268: PUSH
106269: LD_EXP 71
106273: PPUSH
106274: LD_VAR 0 1
106278: PPUSH
106279: LD_EXP 71
106283: PUSH
106284: LD_VAR 0 1
106288: ARRAY
106289: PUSH
106290: LD_VAR 0 12
106294: UNION
106295: PPUSH
106296: CALL_OW 1
106300: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
106301: LD_VAR 0 1
106305: PPUSH
106306: LD_INT 19
106308: PPUSH
106309: CALL 56071 0 2
// repeat wait ( 0 0$1 ) ;
106313: LD_INT 35
106315: PPUSH
106316: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106320: LD_EXP 59
106324: PUSH
106325: LD_VAR 0 1
106329: ARRAY
106330: NOT
106331: PUSH
106332: LD_EXP 59
106336: PUSH
106337: LD_VAR 0 1
106341: ARRAY
106342: PUSH
106343: EMPTY
106344: EQUAL
106345: OR
106346: IFFALSE 106383
// begin for i in defenders do
106348: LD_ADDR_VAR 0 5
106352: PUSH
106353: LD_VAR 0 2
106357: PUSH
106358: FOR_IN
106359: IFFALSE 106372
// ComStop ( i ) ;
106361: LD_VAR 0 5
106365: PPUSH
106366: CALL_OW 141
106370: GO 106358
106372: POP
106373: POP
// defenders := [ ] ;
106374: LD_ADDR_VAR 0 2
106378: PUSH
106379: EMPTY
106380: ST_TO_ADDR
// exit ;
106381: GO 106609
// end ; for i in defenders do
106383: LD_ADDR_VAR 0 5
106387: PUSH
106388: LD_VAR 0 2
106392: PUSH
106393: FOR_IN
106394: IFFALSE 106483
// begin if not IsInArea ( i , mc_parking [ base ] ) then
106396: LD_VAR 0 5
106400: PPUSH
106401: LD_EXP 83
106405: PUSH
106406: LD_VAR 0 1
106410: ARRAY
106411: PPUSH
106412: CALL_OW 308
106416: NOT
106417: IFFALSE 106441
// ComMoveToArea ( i , mc_parking [ base ] ) else
106419: LD_VAR 0 5
106423: PPUSH
106424: LD_EXP 83
106428: PUSH
106429: LD_VAR 0 1
106433: ARRAY
106434: PPUSH
106435: CALL_OW 113
106439: GO 106481
// if GetControl ( i ) = control_manual then
106441: LD_VAR 0 5
106445: PPUSH
106446: CALL_OW 263
106450: PUSH
106451: LD_INT 1
106453: EQUAL
106454: IFFALSE 106481
// if IsDrivenBy ( i ) then
106456: LD_VAR 0 5
106460: PPUSH
106461: CALL_OW 311
106465: IFFALSE 106481
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
106467: LD_VAR 0 5
106471: PPUSH
106472: CALL_OW 311
106476: PPUSH
106477: CALL_OW 121
// end ;
106481: GO 106393
106483: POP
106484: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
106485: LD_VAR 0 2
106489: PPUSH
106490: LD_INT 95
106492: PUSH
106493: LD_EXP 83
106497: PUSH
106498: LD_VAR 0 1
106502: ARRAY
106503: PUSH
106504: EMPTY
106505: LIST
106506: LIST
106507: PPUSH
106508: CALL_OW 72
106512: PUSH
106513: LD_VAR 0 2
106517: EQUAL
106518: PUSH
106519: LD_EXP 82
106523: PUSH
106524: LD_VAR 0 1
106528: ARRAY
106529: OR
106530: PUSH
106531: LD_EXP 59
106535: PUSH
106536: LD_VAR 0 1
106540: ARRAY
106541: NOT
106542: OR
106543: IFFALSE 106313
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
106545: LD_ADDR_EXP 81
106549: PUSH
106550: LD_EXP 81
106554: PPUSH
106555: LD_VAR 0 1
106559: PPUSH
106560: LD_VAR 0 2
106564: PPUSH
106565: LD_INT 21
106567: PUSH
106568: LD_INT 2
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PPUSH
106575: CALL_OW 72
106579: PPUSH
106580: CALL_OW 1
106584: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
106585: LD_VAR 0 1
106589: PPUSH
106590: LD_INT 19
106592: PPUSH
106593: CALL 56071 0 2
// MC_Reset ( base , 20 ) ;
106597: LD_VAR 0 1
106601: PPUSH
106602: LD_INT 20
106604: PPUSH
106605: CALL 56071 0 2
// end ; end_of_file
106609: LD_VAR 0 4
106613: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
106614: LD_VAR 0 1
106618: PUSH
106619: LD_INT 200
106621: DOUBLE
106622: GREATEREQUAL
106623: IFFALSE 106631
106625: LD_INT 299
106627: DOUBLE
106628: LESSEQUAL
106629: IFTRUE 106633
106631: GO 106665
106633: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
106634: LD_VAR 0 1
106638: PPUSH
106639: LD_VAR 0 2
106643: PPUSH
106644: LD_VAR 0 3
106648: PPUSH
106649: LD_VAR 0 4
106653: PPUSH
106654: LD_VAR 0 5
106658: PPUSH
106659: CALL 95547 0 5
106663: GO 106666
106665: POP
// end ;
106666: PPOPN 11
106668: END
