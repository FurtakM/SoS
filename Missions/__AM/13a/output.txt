// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 59216 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50813 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50813 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50813 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50813 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4551 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 61396 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8507 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 83113 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 83558 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84016 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 84285 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 83498 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 84192 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 83558 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84016 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 84285 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 83342 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 84603 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 83498 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 16445 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 16445 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 16445 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 16445 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 16445 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 16445 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 16445 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 16445 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 16445 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 16445 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 16445 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 16445 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 16445 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 16445 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 16445 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 16445 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 16445 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 16445 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 21285 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 21285 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 21285 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 25106 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 21285 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4073
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
// begin enable ;
3340: ENABLE
// base := 2 ;
3341: LD_ADDR_VAR 0 3
3345: PUSH
3346: LD_INT 2
3348: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3349: LD_ADDR_VAR 0 4
3353: PUSH
3354: LD_INT 22
3356: PUSH
3357: LD_INT 1
3359: PUSH
3360: LD_INT 3
3362: PUSH
3363: LD_INT 45
3365: PUSH
3366: EMPTY
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: PUSH
3372: LD_INT 21
3374: PUSH
3375: LD_INT 1
3377: PUSH
3378: LD_INT 3
3380: PUSH
3381: LD_INT 45
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: PUSH
3390: LD_INT 22
3392: PUSH
3393: LD_INT 1
3395: PUSH
3396: LD_INT 3
3398: PUSH
3399: LD_INT 45
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 23
3410: PUSH
3411: LD_INT 1
3413: PUSH
3414: LD_INT 3
3416: PUSH
3417: LD_INT 46
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: PUSH
3426: EMPTY
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: ST_TO_ADDR
// amount := Difficulty ;
3432: LD_ADDR_VAR 0 7
3436: PUSH
3437: LD_OWVAR 67
3441: ST_TO_ADDR
// if tick > 30 30$00 then
3442: LD_OWVAR 1
3446: PUSH
3447: LD_INT 63000
3449: GREATER
3450: IFFALSE 3487
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_VAR 0 7
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: LD_INT 3
3467: PUSH
3468: LD_INT 4
3470: PUSH
3471: LD_INT 4
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: PUSH
3480: LD_OWVAR 67
3484: ARRAY
3485: PLUS
3486: ST_TO_ADDR
// for i = 1 to amount do
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_VAR 0 7
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3591
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3505: LD_ADDR_VAR 0 4
3509: PUSH
3510: LD_VAR 0 4
3514: PPUSH
3515: LD_VAR 0 4
3519: PUSH
3520: LD_INT 1
3522: PLUS
3523: PPUSH
3524: LD_INT 23
3526: PUSH
3527: LD_INT 24
3529: PUSH
3530: EMPTY
3531: LIST
3532: LIST
3533: PUSH
3534: LD_INT 1
3536: PPUSH
3537: LD_INT 2
3539: PPUSH
3540: CALL_OW 12
3544: ARRAY
3545: PUSH
3546: LD_INT 1
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 46
3554: PUSH
3555: LD_INT 47
3557: PUSH
3558: LD_INT 45
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 1
3568: PPUSH
3569: LD_INT 3
3571: PPUSH
3572: CALL_OW 12
3576: ARRAY
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: PPUSH
3584: CALL_OW 2
3588: ST_TO_ADDR
3589: GO 3502
3591: POP
3592: POP
// p := 1 ;
3593: LD_ADDR_VAR 0 2
3597: PUSH
3598: LD_INT 1
3600: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3601: LD_VAR 0 3
3605: PPUSH
3606: LD_VAR 0 4
3610: PPUSH
3611: CALL 83498 0 2
// repeat wait ( 0 0$1 ) ;
3615: LD_INT 35
3617: PPUSH
3618: CALL_OW 67
// p := Inc ( p ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_VAR 0 2
3631: PPUSH
3632: CALL 55497 0 1
3636: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3637: LD_VAR 0 3
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: CALL 84916 0 2
3649: PUSH
3650: LD_VAR 0 7
3654: GREATEREQUAL
3655: PUSH
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 60
3663: GREATEREQUAL
3664: OR
3665: IFFALSE 3615
// wait ( 0 0$30 ) ;
3667: LD_INT 1050
3669: PPUSH
3670: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_INT 71
3681: PUSH
3682: LD_INT 19
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 91
3691: PUSH
3692: LD_INT 67
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 52
3701: PUSH
3702: LD_INT 44
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 68
3711: PUSH
3712: LD_INT 48
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ) diff mc_defender [ base ] ;
3725: LD_ADDR_VAR 0 6
3729: PUSH
3730: LD_INT 22
3732: PUSH
3733: LD_INT 3
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PUSH
3740: LD_INT 21
3742: PUSH
3743: LD_INT 2
3745: PUSH
3746: EMPTY
3747: LIST
3748: LIST
3749: PUSH
3750: LD_INT 3
3752: PUSH
3753: LD_INT 34
3755: PUSH
3756: LD_INT 52
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 34
3765: PUSH
3766: LD_INT 51
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: LIST
3782: PPUSH
3783: CALL_OW 69
3787: PUSH
3788: LD_EXP 83
3792: PUSH
3793: LD_VAR 0 3
3797: ARRAY
3798: DIFF
3799: ST_TO_ADDR
// if not attackers then
3800: LD_VAR 0 6
3804: NOT
3805: IFFALSE 3809
// exit ;
3807: GO 4073
// ru_attackers := attackers ;
3809: LD_ADDR_EXP 54
3813: PUSH
3814: LD_VAR 0 6
3818: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3819: LD_ADDR_EXP 80
3823: PUSH
3824: LD_EXP 80
3828: PPUSH
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_EXP 80
3838: PUSH
3839: LD_VAR 0 3
3843: ARRAY
3844: PUSH
3845: LD_VAR 0 6
3849: DIFF
3850: PPUSH
3851: CALL_OW 1
3855: ST_TO_ADDR
// for i = 1 to attackers do
3856: LD_ADDR_VAR 0 1
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_VAR 0 6
3870: PUSH
3871: FOR_TO
3872: IFFALSE 3949
// begin case i mod 3 of 0 :
3874: LD_VAR 0 1
3878: PUSH
3879: LD_INT 3
3881: MOD
3882: PUSH
3883: LD_INT 0
3885: DOUBLE
3886: EQUAL
3887: IFTRUE 3891
3889: GO 3894
3891: POP
// ; 1 :
3892: GO 3947
3894: LD_INT 1
3896: DOUBLE
3897: EQUAL
3898: IFTRUE 3902
3900: GO 3920
3902: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3903: LD_VAR 0 1
3907: PPUSH
3908: LD_INT 32
3910: PPUSH
3911: LD_INT 49
3913: PPUSH
3914: CALL_OW 114
3918: GO 3947
3920: LD_INT 2
3922: DOUBLE
3923: EQUAL
3924: IFTRUE 3928
3926: GO 3946
3928: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3929: LD_VAR 0 1
3933: PPUSH
3934: LD_INT 117
3936: PPUSH
3937: LD_INT 107
3939: PPUSH
3940: CALL_OW 114
3944: GO 3947
3946: POP
// end ;
3947: GO 3871
3949: POP
3950: POP
// p := 0 ;
3951: LD_ADDR_VAR 0 2
3955: PUSH
3956: LD_INT 0
3958: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3959: LD_INT 35
3961: PPUSH
3962: CALL_OW 67
// p := Inc ( p ) ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL 55497 0 1
3980: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_INT 60
3988: PUSH
3989: EMPTY
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: NOT
3997: PUSH
3998: LD_VAR 0 2
4002: PUSH
4003: LD_INT 30
4005: GREATER
4006: OR
4007: IFFALSE 3959
// if not first_attack then
4009: LD_EXP 7
4013: NOT
4014: IFFALSE 4024
// first_attack := true ;
4016: LD_ADDR_EXP 7
4020: PUSH
4021: LD_INT 1
4023: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4024: LD_INT 35
4026: PPUSH
4027: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4031: LD_ADDR_VAR 0 6
4035: PUSH
4036: LD_VAR 0 6
4040: PPUSH
4041: LD_INT 50
4043: PUSH
4044: EMPTY
4045: LIST
4046: PPUSH
4047: CALL_OW 72
4051: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PPUSH
4062: CALL 56740 0 2
// until not attackers ;
4066: LD_VAR 0 6
4070: NOT
4071: IFFALSE 4024
// end ;
4073: PPOPN 7
4075: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4076: LD_INT 0
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// uc_side := 6 ;
4084: LD_ADDR_OWVAR 20
4088: PUSH
4089: LD_INT 6
4091: ST_TO_ADDR
// uc_nation := 3 ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 3
4099: ST_TO_ADDR
// InitHc ;
4100: CALL_OW 19
// InitVc ;
4104: CALL_OW 20
// tmp := [ ] ;
4108: LD_ADDR_VAR 0 3
4112: PUSH
4113: EMPTY
4114: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4115: LD_ADDR_VAR 0 2
4119: PUSH
4120: DOUBLE
4121: LD_INT 1
4123: DEC
4124: ST_TO_ADDR
4125: LD_INT 4
4127: PUSH
4128: LD_INT 5
4130: PUSH
4131: LD_INT 6
4133: PUSH
4134: LD_INT 7
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PUSH
4149: FOR_TO
4150: IFFALSE 4404
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4152: LD_ADDR_VAR 0 5
4156: PUSH
4157: LD_INT 21
4159: PUSH
4160: LD_INT 22
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: EMPTY
4167: LIST
4168: LIST
4169: LIST
4170: PUSH
4171: LD_INT 1
4173: PPUSH
4174: LD_INT 3
4176: PPUSH
4177: CALL_OW 12
4181: ARRAY
4182: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4183: LD_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: DOUBLE
4191: EQUAL
4192: IFTRUE 4202
4194: LD_INT 22
4196: DOUBLE
4197: EQUAL
4198: IFTRUE 4202
4200: GO 4236
4202: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4203: LD_ADDR_VAR 0 6
4207: PUSH
4208: LD_INT 45
4210: PUSH
4211: LD_INT 44
4213: PUSH
4214: LD_INT 43
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 1
4224: PPUSH
4225: LD_INT 3
4227: PPUSH
4228: CALL_OW 12
4232: ARRAY
4233: ST_TO_ADDR
4234: GO 4283
4236: LD_INT 24
4238: DOUBLE
4239: EQUAL
4240: IFTRUE 4244
4242: GO 4282
4244: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4245: LD_ADDR_VAR 0 6
4249: PUSH
4250: LD_INT 46
4252: PUSH
4253: LD_INT 47
4255: PUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 46
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_INT 1
4270: PPUSH
4271: LD_INT 4
4273: PPUSH
4274: CALL_OW 12
4278: ARRAY
4279: ST_TO_ADDR
4280: GO 4283
4282: POP
// uc_side := 6 ;
4283: LD_ADDR_OWVAR 20
4287: PUSH
4288: LD_INT 6
4290: ST_TO_ADDR
// uc_nation := 3 ;
4291: LD_ADDR_OWVAR 21
4295: PUSH
4296: LD_INT 3
4298: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4299: LD_VAR 0 5
4303: PPUSH
4304: LD_INT 1
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 2
4319: PPUSH
4320: CALL_OW 12
4324: ARRAY
4325: PPUSH
4326: LD_INT 3
4328: PPUSH
4329: LD_VAR 0 6
4333: PPUSH
4334: LD_INT 70
4336: PPUSH
4337: LD_INT 90
4339: PPUSH
4340: CALL_OW 12
4344: PPUSH
4345: CALL 21285 0 5
// veh := CreateVehicle ;
4349: LD_ADDR_VAR 0 4
4353: PUSH
4354: CALL_OW 45
4358: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4359: LD_VAR 0 4
4363: PPUSH
4364: LD_INT 5
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4371: LD_VAR 0 4
4375: PPUSH
4376: LD_INT 16
4378: PPUSH
4379: LD_INT 0
4381: PPUSH
4382: CALL_OW 49
// tmp := tmp ^ veh ;
4386: LD_ADDR_VAR 0 3
4390: PUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_VAR 0 4
4400: ADD
4401: ST_TO_ADDR
// end ;
4402: GO 4149
4404: POP
4405: POP
// if not tmp then
4406: LD_VAR 0 3
4410: NOT
4411: IFFALSE 4415
// exit ;
4413: GO 4509
// repeat wait ( 0 0$2 ) ;
4415: LD_INT 70
4417: PPUSH
4418: CALL_OW 67
// for i in tmp do
4422: LD_ADDR_VAR 0 2
4426: PUSH
4427: LD_VAR 0 3
4431: PUSH
4432: FOR_IN
4433: IFFALSE 4500
// if IsOk ( i ) then
4435: LD_VAR 0 2
4439: PPUSH
4440: CALL_OW 302
4444: IFFALSE 4482
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4446: LD_VAR 0 2
4450: PPUSH
4451: LD_INT 22
4453: PUSH
4454: LD_INT 7
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: CALL_OW 69
4465: PPUSH
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 74
4475: PPUSH
4476: CALL_OW 115
4480: GO 4498
// tmp := tmp diff i ;
4482: LD_ADDR_VAR 0 3
4486: PUSH
4487: LD_VAR 0 3
4491: PUSH
4492: LD_VAR 0 2
4496: DIFF
4497: ST_TO_ADDR
4498: GO 4432
4500: POP
4501: POP
// until not tmp ;
4502: LD_VAR 0 3
4506: NOT
4507: IFFALSE 4415
// end ;
4509: LD_VAR 0 1
4513: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 do
4514: LD_EXP 7
4518: PUSH
4519: LD_INT 47
4521: PPUSH
4522: CALL_OW 302
4526: AND
4527: PUSH
4528: LD_INT 47
4530: PPUSH
4531: CALL_OW 255
4535: PUSH
4536: LD_INT 3
4538: EQUAL
4539: AND
4540: IFFALSE 4550
4542: GO 4544
4544: DISABLE
// begin enable ;
4545: ENABLE
// PrepareRussianAttack ;
4546: CALL 4076 0 0
// end ; end_of_file
4550: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
4559: PPUSH
// uc_side := 2 ;
4560: LD_ADDR_OWVAR 20
4564: PUSH
4565: LD_INT 2
4567: ST_TO_ADDR
// uc_nation := 2 ;
4568: LD_ADDR_OWVAR 21
4572: PUSH
4573: LD_INT 2
4575: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4576: LD_ADDR_EXP 57
4580: PUSH
4581: LD_STRING Abdul
4583: PPUSH
4584: CALL_OW 25
4588: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4589: LD_EXP 57
4593: PPUSH
4594: LD_INT 11
4596: PPUSH
4597: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4601: LD_EXP 57
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: CALL_OW 52
// vc_chassis := 31 ;
4613: LD_ADDR_OWVAR 37
4617: PUSH
4618: LD_INT 31
4620: ST_TO_ADDR
// vc_control := control_rider ;
4621: LD_ADDR_OWVAR 38
4625: PUSH
4626: LD_INT 4
4628: ST_TO_ADDR
// mastodont := CreateVehicle ;
4629: LD_ADDR_EXP 58
4633: PUSH
4634: CALL_OW 45
4638: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4639: LD_EXP 58
4643: PPUSH
4644: LD_INT 153
4646: PPUSH
4647: LD_INT 71
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// InitVc ;
4657: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4661: LD_ADDR_EXP 55
4665: PUSH
4666: LD_INT 1
4668: PPUSH
4669: LD_INT 3
4671: PPUSH
4672: LD_STRING kaba
4674: PPUSH
4675: LD_INT 7
4677: PUSH
4678: LD_INT 8
4680: PUSH
4681: LD_INT 9
4683: PUSH
4684: LD_INT 10
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 5000
4701: PUSH
4702: LD_INT 1000
4704: PUSH
4705: LD_INT 300
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 11
4715: PUSH
4716: LD_INT 5
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 7
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 25106 0 6
4735: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4736: LD_ADDR_EXP 61
4740: PUSH
4741: LD_EXP 61
4745: PPUSH
4746: LD_INT 1
4748: PPUSH
4749: LD_EXP 55
4753: PPUSH
4754: CALL_OW 1
4758: ST_TO_ADDR
// tmp := [ ] ;
4759: LD_ADDR_VAR 0 4
4763: PUSH
4764: EMPTY
4765: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4766: LD_ADDR_OWVAR 37
4770: PUSH
4771: LD_INT 13
4773: ST_TO_ADDR
// vc_engine := engine_siberite ;
4774: LD_ADDR_OWVAR 39
4778: PUSH
4779: LD_INT 3
4781: ST_TO_ADDR
// vc_control := control_manual ;
4782: LD_ADDR_OWVAR 38
4786: PUSH
4787: LD_INT 1
4789: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4790: LD_ADDR_OWVAR 40
4794: PUSH
4795: LD_INT 31
4797: ST_TO_ADDR
// for i = 1 to 3 do
4798: LD_ADDR_VAR 0 2
4802: PUSH
4803: DOUBLE
4804: LD_INT 1
4806: DEC
4807: ST_TO_ADDR
4808: LD_INT 3
4810: PUSH
4811: FOR_TO
4812: IFFALSE 5060
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4814: LD_ADDR_VAR 0 5
4818: PUSH
4819: LD_INT 153
4821: PUSH
4822: LD_INT 71
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: LD_INT 155
4831: PUSH
4832: LD_INT 81
4834: PUSH
4835: EMPTY
4836: LIST
4837: LIST
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_VAR 0 2
4847: PUSH
4848: LD_INT 2
4850: MOD
4851: PUSH
4852: LD_INT 1
4854: PLUS
4855: ARRAY
4856: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4857: LD_INT 0
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: LD_INT 7
4865: PUSH
4866: LD_INT 8
4868: PUSH
4869: LD_INT 10
4871: PUSH
4872: LD_INT 10
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PUSH
4881: LD_OWVAR 67
4885: ARRAY
4886: PPUSH
4887: CALL_OW 380
// un := CreateVehicle ;
4891: LD_ADDR_VAR 0 6
4895: PUSH
4896: CALL_OW 45
4900: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4901: LD_VAR 0 6
4905: PPUSH
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 12
4916: PPUSH
4917: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4921: LD_VAR 0 6
4925: PPUSH
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: PPUSH
4935: LD_VAR 0 5
4939: PUSH
4940: LD_INT 2
4942: ARRAY
4943: PPUSH
4944: LD_INT 6
4946: PPUSH
4947: LD_INT 0
4949: PPUSH
4950: CALL_OW 50
// un2 := CreateHuman ;
4954: LD_ADDR_VAR 0 7
4958: PUSH
4959: CALL_OW 44
4963: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4964: LD_VAR 0 7
4968: PPUSH
4969: LD_VAR 0 6
4973: PPUSH
4974: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4978: LD_ADDR_EXP 61
4982: PUSH
4983: LD_EXP 61
4987: PPUSH
4988: LD_INT 1
4990: PUSH
4991: LD_EXP 61
4995: PUSH
4996: LD_INT 1
4998: ARRAY
4999: PUSH
5000: LD_INT 1
5002: PLUS
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_VAR 0 6
5012: PPUSH
5013: CALL 21407 0 3
5017: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5018: LD_ADDR_EXP 61
5022: PUSH
5023: LD_EXP 61
5027: PPUSH
5028: LD_INT 1
5030: PUSH
5031: LD_EXP 61
5035: PUSH
5036: LD_INT 1
5038: ARRAY
5039: PUSH
5040: LD_INT 1
5042: PLUS
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PPUSH
5048: LD_VAR 0 7
5052: PPUSH
5053: CALL 21407 0 3
5057: ST_TO_ADDR
// end ;
5058: GO 4811
5060: POP
5061: POP
// for i = 1 to 5 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 5
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5169
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5078: LD_INT 13
5080: PPUSH
5081: LD_INT 3
5083: PPUSH
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 25
5089: PUSH
5090: LD_INT 28
5092: PUSH
5093: LD_INT 28
5095: PUSH
5096: LD_INT 26
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_VAR 0 2
5109: PUSH
5110: LD_INT 4
5112: MOD
5113: PUSH
5114: LD_INT 1
5116: PLUS
5117: ARRAY
5118: PPUSH
5119: LD_INT 100
5121: PPUSH
5122: CALL 21285 0 5
// veh := CreateVehicle ;
5126: LD_ADDR_VAR 0 3
5130: PUSH
5131: CALL_OW 45
5135: ST_TO_ADDR
// tmp := tmp ^ veh ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 3
5150: ADD
5151: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5152: LD_VAR 0 3
5156: PPUSH
5157: LD_INT 1
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 49
// end ;
5167: GO 5075
5169: POP
5170: POP
// arabian_guard := tmp ;
5171: LD_ADDR_EXP 56
5175: PUSH
5176: LD_VAR 0 4
5180: ST_TO_ADDR
// end ;
5181: LD_VAR 0 1
5185: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5186: LD_INT 22
5188: PUSH
5189: LD_INT 7
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 91
5198: PUSH
5199: LD_INT 1
5201: PUSH
5202: LD_INT 12
5204: PUSH
5205: EMPTY
5206: LIST
5207: LIST
5208: LIST
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: PPUSH
5214: CALL_OW 69
5218: PUSH
5219: LD_EXP 58
5223: PPUSH
5224: CALL_OW 256
5228: PUSH
5229: LD_INT 990
5231: LESS
5232: OR
5233: PUSH
5234: LD_EXP 57
5238: PPUSH
5239: CALL_OW 256
5243: PUSH
5244: LD_INT 990
5246: LESS
5247: OR
5248: IFFALSE 5391
5250: GO 5252
5252: DISABLE
// begin if IsInUnit ( Abdul ) then
5253: LD_EXP 57
5257: PPUSH
5258: CALL_OW 310
5262: IFFALSE 5273
// ComExitBuilding ( Abdul ) ;
5264: LD_EXP 57
5268: PPUSH
5269: CALL_OW 122
// if Mastodont then
5273: LD_EXP 58
5277: IFFALSE 5294
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5279: LD_EXP 58
5283: PPUSH
5284: LD_INT 205
5286: PPUSH
5287: LD_INT 132
5289: PPUSH
5290: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5294: LD_EXP 57
5298: PPUSH
5299: LD_INT 205
5301: PPUSH
5302: LD_INT 132
5304: PPUSH
5305: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5309: LD_INT 35
5311: PPUSH
5312: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5316: LD_EXP 57
5320: PPUSH
5321: LD_INT 21
5323: PPUSH
5324: CALL_OW 308
5328: IFFALSE 5309
// RemoveUnit ( Abdul ) ;
5330: LD_EXP 57
5334: PPUSH
5335: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5339: LD_INT 35
5341: PPUSH
5342: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5346: LD_EXP 58
5350: PPUSH
5351: LD_INT 21
5353: PPUSH
5354: CALL_OW 308
5358: PUSH
5359: LD_EXP 58
5363: PPUSH
5364: CALL_OW 301
5368: OR
5369: IFFALSE 5339
// if IsOk ( Mastodont ) then
5371: LD_EXP 58
5375: PPUSH
5376: CALL_OW 302
5380: IFFALSE 5391
// RemoveUnit ( Mastodont ) ;
5382: LD_EXP 58
5386: PPUSH
5387: CALL_OW 64
// end ;
5391: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5392: LD_EXP 57
5396: PPUSH
5397: CALL_OW 301
5401: PUSH
5402: LD_INT 22
5404: PUSH
5405: LD_INT 2
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 2
5414: PUSH
5415: LD_INT 25
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 25
5427: PUSH
5428: LD_INT 2
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 25
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PUSH
5445: LD_INT 25
5447: PUSH
5448: LD_INT 4
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 25
5457: PUSH
5458: LD_INT 8
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PPUSH
5477: CALL_OW 69
5481: PUSH
5482: LD_INT 16
5484: PUSH
5485: LD_INT 19
5487: PUSH
5488: LD_INT 22
5490: PUSH
5491: LD_INT 22
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: LESS
5506: OR
5507: IFFALSE 6180
5509: GO 5511
5511: DISABLE
5512: LD_INT 0
5514: PPUSH
5515: PPUSH
5516: PPUSH
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin MC_Kill ( 1 ) ;
5520: LD_INT 1
5522: PPUSH
5523: CALL 59473 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5527: LD_ADDR_VAR 0 2
5531: PUSH
5532: LD_INT 22
5534: PUSH
5535: LD_INT 2
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 25
5547: PUSH
5548: LD_INT 1
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 25
5557: PUSH
5558: LD_INT 2
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PUSH
5565: LD_INT 25
5567: PUSH
5568: LD_INT 3
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 25
5577: PUSH
5578: LD_INT 4
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 25
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: LIST
5600: LIST
5601: LIST
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: ST_TO_ADDR
// for i in tmp do
5612: LD_ADDR_VAR 0 5
5616: PUSH
5617: LD_VAR 0 2
5621: PUSH
5622: FOR_IN
5623: IFFALSE 5639
// SetTag ( i , 10 ) ;
5625: LD_VAR 0 5
5629: PPUSH
5630: LD_INT 10
5632: PPUSH
5633: CALL_OW 109
5637: GO 5622
5639: POP
5640: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 22
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 21
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 69
5674: PUSH
5675: LD_VAR 0 2
5679: DIFF
5680: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5681: LD_ADDR_VAR 0 1
5685: PUSH
5686: LD_INT 22
5688: PUSH
5689: LD_INT 2
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 21
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: PUSH
5706: LD_INT 24
5708: PUSH
5709: LD_INT 300
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 69
5725: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5726: LD_ADDR_VAR 0 4
5730: PUSH
5731: LD_VAR 0 1
5735: PPUSH
5736: LD_INT 33
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PUSH
5746: LD_INT 58
5748: PUSH
5749: EMPTY
5750: LIST
5751: PUSH
5752: EMPTY
5753: LIST
5754: LIST
5755: PPUSH
5756: CALL_OW 72
5760: ST_TO_ADDR
// for i in tmp do
5761: LD_ADDR_VAR 0 5
5765: PUSH
5766: LD_VAR 0 2
5770: PUSH
5771: FOR_IN
5772: IFFALSE 5956
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5774: LD_VAR 0 5
5778: PUSH
5779: LD_INT 55
5781: PUSH
5782: EMPTY
5783: LIST
5784: PPUSH
5785: CALL_OW 69
5789: IN
5790: IFFALSE 5809
// begin AddComMoveXY ( i , 209 , 132 ) ;
5792: LD_VAR 0 5
5796: PPUSH
5797: LD_INT 209
5799: PPUSH
5800: LD_INT 132
5802: PPUSH
5803: CALL_OW 171
// continue ;
5807: GO 5771
// end ; if IsInUnit ( i ) then
5809: LD_VAR 0 5
5813: PPUSH
5814: CALL_OW 310
5818: IFFALSE 5836
// begin ComExitBuilding ( i ) ;
5820: LD_VAR 0 5
5824: PPUSH
5825: CALL_OW 122
// wait ( 3 ) ;
5829: LD_INT 3
5831: PPUSH
5832: CALL_OW 67
// end ; if tmp_empty then
5836: LD_VAR 0 4
5840: IFFALSE 5939
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5842: LD_VAR 0 5
5846: PPUSH
5847: LD_VAR 0 4
5851: PPUSH
5852: LD_VAR 0 5
5856: PPUSH
5857: CALL_OW 74
5861: PPUSH
5862: CALL_OW 296
5866: PUSH
5867: LD_INT 25
5869: LESS
5870: IFFALSE 5939
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_VAR 0 4
5881: PPUSH
5882: LD_VAR 0 5
5886: PPUSH
5887: CALL_OW 74
5891: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5892: LD_VAR 0 5
5896: PPUSH
5897: LD_VAR 0 6
5901: PPUSH
5902: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5906: LD_VAR 0 5
5910: PPUSH
5911: LD_INT 209
5913: PPUSH
5914: LD_INT 132
5916: PPUSH
5917: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5921: LD_ADDR_VAR 0 4
5925: PUSH
5926: LD_VAR 0 4
5930: PUSH
5931: LD_VAR 0 6
5935: DIFF
5936: ST_TO_ADDR
// continue ;
5937: GO 5771
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5939: LD_VAR 0 5
5943: PPUSH
5944: LD_INT 201
5946: PPUSH
5947: LD_INT 132
5949: PPUSH
5950: CALL_OW 171
// end ;
5954: GO 5771
5956: POP
5957: POP
// for i in tmp_ape do
5958: LD_ADDR_VAR 0 5
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: FOR_IN
5969: IFFALSE 6008
// begin if IsInUnit ( i ) then
5971: LD_VAR 0 5
5975: PPUSH
5976: CALL_OW 310
5980: IFFALSE 5991
// ComExitBuilding ( i ) ;
5982: LD_VAR 0 5
5986: PPUSH
5987: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5991: LD_VAR 0 5
5995: PPUSH
5996: LD_INT 201
5998: PPUSH
5999: LD_INT 132
6001: PPUSH
6002: CALL_OW 171
// end ;
6006: GO 5968
6008: POP
6009: POP
// repeat wait ( 0 0$1 ) ;
6010: LD_INT 35
6012: PPUSH
6013: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_VAR 0 3
6031: UNION
6032: PUSH
6033: LD_VAR 0 1
6037: UNION
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6071
// if not HasTask ( i ) then
6042: LD_VAR 0 5
6046: PPUSH
6047: CALL_OW 314
6051: NOT
6052: IFFALSE 6069
// ComMoveXY ( i , 201 , 132 ) ;
6054: LD_VAR 0 5
6058: PPUSH
6059: LD_INT 201
6061: PPUSH
6062: LD_INT 132
6064: PPUSH
6065: CALL_OW 111
6069: GO 6039
6071: POP
6072: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6073: LD_INT 21
6075: PPUSH
6076: LD_INT 22
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 70
6090: IFFALSE 6131
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6092: LD_ADDR_VAR 0 5
6096: PUSH
6097: LD_INT 21
6099: PPUSH
6100: LD_INT 22
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 70
6114: PUSH
6115: FOR_IN
6116: IFFALSE 6129
// RemoveUnit ( i ) ;
6118: LD_VAR 0 5
6122: PPUSH
6123: CALL_OW 64
6127: GO 6115
6129: POP
6130: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6131: LD_INT 22
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: LD_INT 21
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 21
6156: PUSH
6157: LD_INT 2
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PPUSH
6173: CALL_OW 69
6177: NOT
6178: IFFALSE 6010
// end ;
6180: PPOPN 6
6182: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6183: LD_EXP 9
6187: PUSH
6188: LD_INT 92
6190: PPUSH
6191: LD_INT 40
6193: PPUSH
6194: CALL_OW 428
6198: PPUSH
6199: CALL_OW 266
6203: PUSH
6204: LD_INT 30
6206: EQUAL
6207: AND
6208: IFFALSE 6404
6210: GO 6212
6212: DISABLE
6213: LD_INT 0
6215: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6216: LD_ADDR_VAR 0 1
6220: PUSH
6221: LD_EXP 61
6225: PUSH
6226: LD_INT 1
6228: ARRAY
6229: PPUSH
6230: LD_INT 25
6232: PUSH
6233: LD_INT 4
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: PPUSH
6240: CALL_OW 72
6244: ST_TO_ADDR
// if not sci then
6245: LD_VAR 0 1
6249: NOT
6250: IFFALSE 6254
// exit ;
6252: GO 6404
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6254: LD_ADDR_EXP 61
6258: PUSH
6259: LD_EXP 61
6263: PPUSH
6264: LD_INT 1
6266: PPUSH
6267: LD_EXP 61
6271: PUSH
6272: LD_INT 1
6274: ARRAY
6275: PUSH
6276: LD_VAR 0 1
6280: PUSH
6281: LD_INT 1
6283: ARRAY
6284: DIFF
6285: PPUSH
6286: CALL_OW 1
6290: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6291: LD_VAR 0 1
6295: PUSH
6296: LD_INT 1
6298: ARRAY
6299: PPUSH
6300: CALL_OW 310
6304: IFFALSE 6319
// ComExitBuilding ( sci [ 1 ] ) ;
6306: LD_VAR 0 1
6310: PUSH
6311: LD_INT 1
6313: ARRAY
6314: PPUSH
6315: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6319: LD_INT 2
6321: PPUSH
6322: LD_INT 105
6324: PPUSH
6325: LD_INT 14
6327: PPUSH
6328: LD_INT 20
6330: PPUSH
6331: CALL 22671 0 4
6335: PUSH
6336: LD_INT 4
6338: ARRAY
6339: PUSH
6340: LD_INT 10
6342: LESS
6343: IFFALSE 6366
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6345: LD_VAR 0 1
6349: PUSH
6350: LD_INT 1
6352: ARRAY
6353: PPUSH
6354: LD_INT 105
6356: PPUSH
6357: LD_INT 14
6359: PPUSH
6360: CALL_OW 171
6364: GO 6385
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 1
6373: ARRAY
6374: PPUSH
6375: LD_INT 118
6377: PPUSH
6378: LD_INT 77
6380: PPUSH
6381: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6385: LD_VAR 0 1
6389: PUSH
6390: LD_INT 1
6392: ARRAY
6393: PPUSH
6394: LD_INT 92
6396: PPUSH
6397: LD_INT 40
6399: PPUSH
6400: CALL_OW 218
// end ;
6404: PPOPN 1
6406: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6407: LD_INT 1
6409: PPUSH
6410: CALL_OW 302
6414: PUSH
6415: LD_EXP 9
6419: AND
6420: IFFALSE 7291
6422: GO 6424
6424: DISABLE
6425: LD_INT 0
6427: PPUSH
6428: PPUSH
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// begin enable ;
6435: ENABLE
// base := 1 ;
6436: LD_ADDR_VAR 0 3
6440: PUSH
6441: LD_INT 1
6443: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6444: LD_ADDR_VAR 0 5
6448: PUSH
6449: LD_INT 0
6451: PUSH
6452: LD_INT 0
6454: PUSH
6455: LD_INT 0
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: LD_INT 0
6466: PUSH
6467: LD_INT 0
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 1
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 13
6498: PUSH
6499: LD_INT 1
6501: PUSH
6502: LD_INT 2
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 13
6516: PUSH
6517: LD_INT 1
6519: PUSH
6520: LD_INT 2
6522: PUSH
6523: LD_INT 28
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 13
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: LD_INT 2
6540: PUSH
6541: LD_INT 29
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6555: LD_ADDR_VAR 0 1
6559: PUSH
6560: DOUBLE
6561: LD_INT 1
6563: DEC
6564: ST_TO_ADDR
6565: LD_OWVAR 67
6569: PUSH
6570: LD_OWVAR 1
6574: PUSH
6575: LD_INT 21000
6577: DIV
6578: PLUS
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6654
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6583: LD_ADDR_VAR 0 4
6587: PUSH
6588: LD_VAR 0 4
6592: PPUSH
6593: LD_VAR 0 4
6597: PUSH
6598: LD_INT 1
6600: PLUS
6601: PPUSH
6602: LD_INT 13
6604: PUSH
6605: LD_INT 1
6607: PUSH
6608: LD_INT 2
6610: PUSH
6611: LD_INT 28
6613: PUSH
6614: LD_INT 29
6616: PUSH
6617: LD_INT 25
6619: PUSH
6620: LD_INT 26
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 4
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: LIST
6645: LIST
6646: PPUSH
6647: CALL_OW 2
6651: ST_TO_ADDR
6652: GO 6580
6654: POP
6655: POP
// MC_InsertProduceList ( base , tmp ) ;
6656: LD_VAR 0 3
6660: PPUSH
6661: LD_VAR 0 4
6665: PPUSH
6666: CALL 83498 0 2
// wait ( 3 3$20 ) ;
6670: LD_INT 7000
6672: PPUSH
6673: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6677: LD_ADDR_VAR 0 6
6681: PUSH
6682: LD_INT 124
6684: PUSH
6685: LD_INT 85
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: LD_INT 90
6694: PUSH
6695: LD_INT 61
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PUSH
6702: LD_INT 69
6704: PUSH
6705: LD_INT 48
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 68
6714: PUSH
6715: LD_INT 48
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6728: LD_ADDR_VAR 0 7
6732: PUSH
6733: LD_INT 22
6735: PUSH
6736: LD_INT 2
6738: PUSH
6739: EMPTY
6740: LIST
6741: LIST
6742: PUSH
6743: LD_INT 21
6745: PUSH
6746: LD_INT 2
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 3
6755: PUSH
6756: LD_INT 34
6758: PUSH
6759: LD_INT 31
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PUSH
6766: LD_INT 34
6768: PUSH
6769: LD_INT 88
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: PUSH
6776: LD_INT 34
6778: PUSH
6779: LD_INT 32
6781: PUSH
6782: EMPTY
6783: LIST
6784: LIST
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: LIST
6796: PPUSH
6797: CALL_OW 69
6801: PUSH
6802: LD_EXP 80
6806: PUSH
6807: LD_VAR 0 3
6811: ARRAY
6812: PPUSH
6813: LD_INT 2
6815: PUSH
6816: LD_INT 34
6818: PUSH
6819: LD_INT 32
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PUSH
6826: LD_INT 34
6828: PUSH
6829: LD_INT 88
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: LIST
6840: PPUSH
6841: CALL_OW 72
6845: DIFF
6846: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6847: LD_INT 0
6849: PPUSH
6850: LD_INT 1
6852: PPUSH
6853: CALL_OW 12
6857: IFFALSE 7007
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6859: LD_ADDR_VAR 0 1
6863: PUSH
6864: DOUBLE
6865: LD_INT 1
6867: DEC
6868: ST_TO_ADDR
6869: LD_INT 3
6871: PUSH
6872: LD_INT 4
6874: PUSH
6875: LD_INT 5
6877: PUSH
6878: LD_INT 6
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: LIST
6885: LIST
6886: PUSH
6887: LD_OWVAR 67
6891: ARRAY
6892: PUSH
6893: FOR_TO
6894: IFFALSE 7003
// begin uc_side := 2 ;
6896: LD_ADDR_OWVAR 20
6900: PUSH
6901: LD_INT 2
6903: ST_TO_ADDR
// uc_nation := 2 ;
6904: LD_ADDR_OWVAR 21
6908: PUSH
6909: LD_INT 2
6911: ST_TO_ADDR
// InitHc ;
6912: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6916: LD_INT 0
6918: PPUSH
6919: LD_INT 15
6921: PUSH
6922: LD_INT 17
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PUSH
6929: LD_INT 1
6931: PPUSH
6932: LD_INT 2
6934: PPUSH
6935: CALL_OW 12
6939: ARRAY
6940: PPUSH
6941: LD_INT 8
6943: PPUSH
6944: CALL_OW 380
// un := CreateHuman ;
6948: LD_ADDR_VAR 0 2
6952: PUSH
6953: CALL_OW 44
6957: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6958: LD_VAR 0 2
6962: PPUSH
6963: LD_INT 4
6965: PPUSH
6966: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 23
6977: PPUSH
6978: LD_INT 0
6980: PPUSH
6981: CALL_OW 49
// attackers := attackers union un ;
6985: LD_ADDR_VAR 0 7
6989: PUSH
6990: LD_VAR 0 7
6994: PUSH
6995: LD_VAR 0 2
6999: UNION
7000: ST_TO_ADDR
// end ;
7001: GO 6893
7003: POP
7004: POP
// end else
7005: GO 7165
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 2
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: LD_INT 5
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_OWVAR 67
7039: ARRAY
7040: PUSH
7041: FOR_TO
7042: IFFALSE 7163
// begin uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7064: LD_INT 14
7066: PPUSH
7067: LD_INT 3
7069: PPUSH
7070: LD_INT 5
7072: PPUSH
7073: LD_INT 29
7075: PUSH
7076: LD_INT 29
7078: PUSH
7079: LD_INT 26
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_VAR 0 1
7091: PUSH
7092: LD_INT 3
7094: MOD
7095: PUSH
7096: LD_INT 1
7098: PLUS
7099: ARRAY
7100: PPUSH
7101: LD_INT 100
7103: PPUSH
7104: CALL 21285 0 5
// un := CreateVehicle ;
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: CALL_OW 45
7117: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7118: LD_VAR 0 2
7122: PPUSH
7123: LD_INT 4
7125: PPUSH
7126: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7130: LD_VAR 0 2
7134: PPUSH
7135: LD_INT 23
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 49
// attackers := attackers union un ;
7145: LD_ADDR_VAR 0 7
7149: PUSH
7150: LD_VAR 0 7
7154: PUSH
7155: LD_VAR 0 2
7159: UNION
7160: ST_TO_ADDR
// end ;
7161: GO 7041
7163: POP
7164: POP
// end ; if not attackers then
7165: LD_VAR 0 7
7169: NOT
7170: IFFALSE 7174
// exit ;
7172: GO 7291
// ar_attackers := attackers ;
7174: LD_ADDR_EXP 11
7178: PUSH
7179: LD_VAR 0 7
7183: ST_TO_ADDR
// p := 0 ;
7184: LD_ADDR_VAR 0 8
7188: PUSH
7189: LD_INT 0
7191: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7192: LD_INT 35
7194: PPUSH
7195: CALL_OW 67
// p := Inc ( p ) ;
7199: LD_ADDR_VAR 0 8
7203: PUSH
7204: LD_VAR 0 8
7208: PPUSH
7209: CALL 55497 0 1
7213: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7214: LD_VAR 0 7
7218: PPUSH
7219: LD_INT 60
7221: PUSH
7222: EMPTY
7223: LIST
7224: PPUSH
7225: CALL_OW 72
7229: NOT
7230: PUSH
7231: LD_VAR 0 8
7235: PUSH
7236: LD_INT 30
7238: GREATER
7239: OR
7240: IFFALSE 7192
// repeat wait ( 0 0$1 ) ;
7242: LD_INT 35
7244: PPUSH
7245: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7249: LD_ADDR_VAR 0 7
7253: PUSH
7254: LD_VAR 0 7
7258: PPUSH
7259: LD_INT 50
7261: PUSH
7262: EMPTY
7263: LIST
7264: PPUSH
7265: CALL_OW 72
7269: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7270: LD_VAR 0 7
7274: PPUSH
7275: LD_VAR 0 6
7279: PPUSH
7280: CALL 56740 0 2
// until not attackers ;
7284: LD_VAR 0 7
7288: NOT
7289: IFFALSE 7242
// end ;
7291: PPOPN 8
7293: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7294: LD_INT 1
7296: PPUSH
7297: CALL_OW 302
7301: PUSH
7302: LD_EXP 9
7306: AND
7307: PUSH
7308: LD_EXP 51
7312: PPUSH
7313: LD_INT 22
7315: PPUSH
7316: CALL_OW 308
7320: AND
7321: IFFALSE 7809
7323: GO 7325
7325: DISABLE
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
7332: PPUSH
7333: PPUSH
7334: PPUSH
7335: PPUSH
// begin base := 1 ;
7336: LD_ADDR_VAR 0 2
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7344: LD_ADDR_VAR 0 4
7348: PUSH
7349: LD_INT 0
7351: PUSH
7352: LD_INT 0
7354: PUSH
7355: LD_INT 0
7357: PUSH
7358: LD_INT 0
7360: PUSH
7361: LD_INT 0
7363: PUSH
7364: LD_INT 0
7366: PUSH
7367: LD_INT 0
7369: PUSH
7370: LD_INT 0
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 0
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7391: LD_ADDR_VAR 0 3
7395: PUSH
7396: LD_INT 13
7398: PUSH
7399: LD_INT 1
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: LD_INT 28
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PUSH
7414: LD_INT 13
7416: PUSH
7417: LD_INT 1
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: LD_INT 27
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: LIST
7430: LIST
7431: PUSH
7432: LD_INT 13
7434: PUSH
7435: LD_INT 1
7437: PUSH
7438: LD_INT 2
7440: PUSH
7441: LD_INT 25
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 11
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: LD_INT 24
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: LD_INT 11
7470: PUSH
7471: LD_INT 2
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 24
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7493: LD_VAR 0 2
7497: PPUSH
7498: LD_VAR 0 3
7502: PPUSH
7503: CALL 83498 0 2
// wait ( 4 4$20 ) ;
7507: LD_INT 9100
7509: PPUSH
7510: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7514: LD_ADDR_VAR 0 5
7518: PUSH
7519: LD_INT 119
7521: PUSH
7522: LD_INT 9
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7532: LD_ADDR_VAR 0 6
7536: PUSH
7537: LD_EXP 80
7541: PUSH
7542: LD_VAR 0 2
7546: ARRAY
7547: PUSH
7548: LD_EXP 80
7552: PUSH
7553: LD_VAR 0 2
7557: ARRAY
7558: PPUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 34
7564: PUSH
7565: LD_INT 32
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 34
7574: PUSH
7575: LD_INT 88
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 72
7591: DIFF
7592: ST_TO_ADDR
// uc_side := 2 ;
7593: LD_ADDR_OWVAR 20
7597: PUSH
7598: LD_INT 2
7600: ST_TO_ADDR
// uc_nation := 2 ;
7601: LD_ADDR_OWVAR 21
7605: PUSH
7606: LD_INT 2
7608: ST_TO_ADDR
// InitHc ;
7609: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7613: LD_ADDR_VAR 0 1
7617: PUSH
7618: DOUBLE
7619: LD_INT 1
7621: DEC
7622: ST_TO_ADDR
7623: LD_INT 4
7625: PUSH
7626: LD_INT 5
7628: PUSH
7629: LD_INT 6
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: PUSH
7641: LD_OWVAR 67
7645: ARRAY
7646: PUSH
7647: FOR_TO
7648: IFFALSE 7725
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7650: LD_INT 0
7652: PPUSH
7653: LD_INT 15
7655: PUSH
7656: LD_INT 17
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: LD_INT 1
7665: PPUSH
7666: LD_INT 2
7668: PPUSH
7669: CALL_OW 12
7673: ARRAY
7674: PPUSH
7675: LD_INT 8
7677: PPUSH
7678: CALL_OW 380
// un := CreateHuman ;
7682: LD_ADDR_VAR 0 7
7686: PUSH
7687: CALL_OW 44
7691: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7692: LD_VAR 0 7
7696: PPUSH
7697: LD_INT 23
7699: PPUSH
7700: LD_INT 0
7702: PPUSH
7703: CALL_OW 49
// attackers := attackers union un ;
7707: LD_ADDR_VAR 0 6
7711: PUSH
7712: LD_VAR 0 6
7716: PUSH
7717: LD_VAR 0 7
7721: UNION
7722: ST_TO_ADDR
// end ;
7723: GO 7647
7725: POP
7726: POP
// p := 0 ;
7727: LD_ADDR_VAR 0 8
7731: PUSH
7732: LD_INT 0
7734: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7735: LD_INT 35
7737: PPUSH
7738: CALL_OW 67
// p := Inc ( p ) ;
7742: LD_ADDR_VAR 0 8
7746: PUSH
7747: LD_VAR 0 8
7751: PPUSH
7752: CALL 55497 0 1
7756: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7757: LD_VAR 0 6
7761: PPUSH
7762: LD_INT 60
7764: PUSH
7765: EMPTY
7766: LIST
7767: PPUSH
7768: CALL_OW 72
7772: NOT
7773: PUSH
7774: LD_VAR 0 8
7778: PUSH
7779: LD_INT 30
7781: GREATER
7782: OR
7783: IFFALSE 7735
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7785: LD_VAR 0 2
7789: PPUSH
7790: LD_VAR 0 6
7794: PPUSH
7795: LD_VAR 0 5
7799: PPUSH
7800: LD_VAR 0 4
7804: PPUSH
7805: CALL 83683 0 4
// end ; end_of_file
7809: PPOPN 8
7811: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7812: LD_INT 0
7814: PPUSH
7815: PPUSH
7816: PPUSH
7817: PPUSH
7818: PPUSH
7819: PPUSH
// uc_side := 1 ;
7820: LD_ADDR_OWVAR 20
7824: PUSH
7825: LD_INT 1
7827: ST_TO_ADDR
// uc_nation := 1 ;
7828: LD_ADDR_OWVAR 21
7832: PUSH
7833: LD_INT 1
7835: ST_TO_ADDR
// InitHc ;
7836: CALL_OW 19
// InitVc ;
7840: CALL_OW 20
// tmp := [ ] ;
7844: LD_ADDR_VAR 0 3
7848: PUSH
7849: EMPTY
7850: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7851: LD_ADDR_VAR 0 2
7855: PUSH
7856: DOUBLE
7857: LD_INT 1
7859: DEC
7860: ST_TO_ADDR
7861: LD_INT 6
7863: PUSH
7864: LD_INT 8
7866: PUSH
7867: LD_INT 10
7869: PUSH
7870: LD_INT 10
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: LIST
7878: PUSH
7879: LD_OWVAR 67
7883: ARRAY
7884: PUSH
7885: FOR_TO
7886: IFFALSE 8176
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7888: LD_ADDR_VAR 0 5
7892: PUSH
7893: LD_INT 2
7895: PUSH
7896: LD_INT 4
7898: PUSH
7899: LD_INT 5
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 1
7909: PPUSH
7910: LD_INT 3
7912: PPUSH
7913: CALL_OW 12
7917: ARRAY
7918: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7919: LD_VAR 0 5
7923: PUSH
7924: LD_INT 2
7926: DOUBLE
7927: EQUAL
7928: IFTRUE 7932
7930: GO 7966
7932: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7933: LD_ADDR_VAR 0 6
7937: PUSH
7938: LD_INT 9
7940: PUSH
7941: LD_INT 5
7943: PUSH
7944: LD_INT 7
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 1
7954: PPUSH
7955: LD_INT 3
7957: PPUSH
7958: CALL_OW 12
7962: ARRAY
7963: ST_TO_ADDR
7964: GO 8055
7966: LD_INT 4
7968: DOUBLE
7969: EQUAL
7970: IFTRUE 7974
7972: GO 8012
7974: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7975: LD_ADDR_VAR 0 6
7979: PUSH
7980: LD_INT 9
7982: PUSH
7983: LD_INT 6
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: LD_INT 7
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PUSH
7998: LD_INT 1
8000: PPUSH
8001: LD_INT 4
8003: PPUSH
8004: CALL_OW 12
8008: ARRAY
8009: ST_TO_ADDR
8010: GO 8055
8012: LD_INT 5
8014: DOUBLE
8015: EQUAL
8016: IFTRUE 8020
8018: GO 8054
8020: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8021: LD_ADDR_VAR 0 6
8025: PUSH
8026: LD_INT 9
8028: PUSH
8029: LD_INT 6
8031: PUSH
8032: LD_INT 7
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: PUSH
8040: LD_INT 1
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: CALL_OW 12
8050: ARRAY
8051: ST_TO_ADDR
8052: GO 8055
8054: POP
// uc_side := 1 ;
8055: LD_ADDR_OWVAR 20
8059: PUSH
8060: LD_INT 1
8062: ST_TO_ADDR
// uc_nation := 1 ;
8063: LD_ADDR_OWVAR 21
8067: PUSH
8068: LD_INT 1
8070: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8071: LD_VAR 0 5
8075: PPUSH
8076: LD_INT 1
8078: PUSH
8079: LD_INT 3
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 1
8088: PPUSH
8089: LD_INT 2
8091: PPUSH
8092: CALL_OW 12
8096: ARRAY
8097: PPUSH
8098: LD_INT 3
8100: PPUSH
8101: LD_VAR 0 6
8105: PPUSH
8106: LD_INT 70
8108: PPUSH
8109: LD_INT 90
8111: PPUSH
8112: CALL_OW 12
8116: PPUSH
8117: CALL 21285 0 5
// veh := CreateVehicle ;
8121: LD_ADDR_VAR 0 4
8125: PUSH
8126: CALL_OW 45
8130: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8131: LD_VAR 0 4
8135: PPUSH
8136: LD_INT 2
8138: PPUSH
8139: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8143: LD_VAR 0 4
8147: PPUSH
8148: LD_INT 17
8150: PPUSH
8151: LD_INT 0
8153: PPUSH
8154: CALL_OW 49
// tmp := tmp ^ veh ;
8158: LD_ADDR_VAR 0 3
8162: PUSH
8163: LD_VAR 0 3
8167: PUSH
8168: LD_VAR 0 4
8172: ADD
8173: ST_TO_ADDR
// end ;
8174: GO 7885
8176: POP
8177: POP
// if not tmp then
8178: LD_VAR 0 3
8182: NOT
8183: IFFALSE 8187
// exit ;
8185: GO 8296
// if not first_powell_attack then
8187: LD_EXP 12
8191: NOT
8192: IFFALSE 8202
// first_powell_attack := true ;
8194: LD_ADDR_EXP 12
8198: PUSH
8199: LD_INT 1
8201: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8202: LD_INT 70
8204: PPUSH
8205: CALL_OW 67
// for i in tmp do
8209: LD_ADDR_VAR 0 2
8213: PUSH
8214: LD_VAR 0 3
8218: PUSH
8219: FOR_IN
8220: IFFALSE 8287
// if IsOk ( i ) then
8222: LD_VAR 0 2
8226: PPUSH
8227: CALL_OW 302
8231: IFFALSE 8269
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8233: LD_VAR 0 2
8237: PPUSH
8238: LD_INT 81
8240: PUSH
8241: LD_INT 1
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PPUSH
8248: CALL_OW 69
8252: PPUSH
8253: LD_VAR 0 2
8257: PPUSH
8258: CALL_OW 74
8262: PPUSH
8263: CALL_OW 115
8267: GO 8285
// tmp := tmp diff i ;
8269: LD_ADDR_VAR 0 3
8273: PUSH
8274: LD_VAR 0 3
8278: PUSH
8279: LD_VAR 0 2
8283: DIFF
8284: ST_TO_ADDR
8285: GO 8219
8287: POP
8288: POP
// until not tmp ;
8289: LD_VAR 0 3
8293: NOT
8294: IFFALSE 8202
// end ;
8296: LD_VAR 0 1
8300: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
8301: LD_INT 0
8303: PPUSH
8304: PPUSH
// uc_side := 1 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 1
8312: ST_TO_ADDR
// uc_nation := 1 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 1
8320: ST_TO_ADDR
// InitHc ;
8321: CALL_OW 19
// InitVc ;
8325: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
8329: LD_INT 5
8331: PPUSH
8332: LD_INT 3
8334: PPUSH
8335: LD_INT 3
8337: PPUSH
8338: LD_INT 12
8340: PPUSH
8341: LD_INT 100
8343: PPUSH
8344: CALL 21285 0 5
// veh := CreateVehicle ;
8348: LD_ADDR_VAR 0 3
8352: PUSH
8353: CALL_OW 45
8357: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8358: LD_VAR 0 3
8362: PPUSH
8363: LD_INT 2
8365: PPUSH
8366: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8370: LD_VAR 0 3
8374: PPUSH
8375: LD_INT 17
8377: PPUSH
8378: LD_INT 0
8380: PPUSH
8381: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
8385: LD_VAR 0 3
8389: PPUSH
8390: LD_VAR 0 1
8394: PUSH
8395: LD_INT 1
8397: ARRAY
8398: PPUSH
8399: LD_VAR 0 1
8403: PUSH
8404: LD_INT 2
8406: ARRAY
8407: PPUSH
8408: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
8412: LD_VAR 0 3
8416: PPUSH
8417: LD_INT 59
8419: PPUSH
8420: LD_INT 2
8422: PPUSH
8423: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8427: LD_INT 35
8429: PPUSH
8430: CALL_OW 67
// if not IsOk ( veh ) then
8434: LD_VAR 0 3
8438: PPUSH
8439: CALL_OW 302
8443: NOT
8444: IFFALSE 8448
// exit ;
8446: GO 8502
// until IsAt ( veh , 59 , 2 ) ;
8448: LD_VAR 0 3
8452: PPUSH
8453: LD_INT 59
8455: PPUSH
8456: LD_INT 2
8458: PPUSH
8459: CALL_OW 307
8463: IFFALSE 8427
// RemoveUnit ( veh ) ;
8465: LD_VAR 0 3
8469: PPUSH
8470: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
8474: LD_VAR 0 3
8478: PPUSH
8479: LD_INT 4
8481: PPUSH
8482: CALL_OW 289
8486: IFFALSE 8502
// begin wait ( 0 0$2 ) ;
8488: LD_INT 70
8490: PPUSH
8491: CALL_OW 67
// YouLost ( Artifact ) ;
8495: LD_STRING Artifact
8497: PPUSH
8498: CALL_OW 104
// end ; end ; end_of_file
8502: LD_VAR 0 2
8506: RET
// export function Action ; var tmp , i , un ; begin
8507: LD_INT 0
8509: PPUSH
8510: PPUSH
8511: PPUSH
8512: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8513: LD_INT 68
8515: PPUSH
8516: LD_INT 39
8518: PPUSH
8519: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8523: LD_ADDR_VAR 0 2
8527: PUSH
8528: LD_INT 22
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PPUSH
8538: CALL_OW 69
8542: ST_TO_ADDR
// InGameOn ;
8543: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8547: LD_VAR 0 2
8551: PPUSH
8552: LD_INT 71
8554: PPUSH
8555: LD_INT 49
8557: PPUSH
8558: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8562: LD_INT 35
8564: PPUSH
8565: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8569: LD_INT 7
8571: PPUSH
8572: LD_INT 71
8574: PPUSH
8575: LD_INT 51
8577: PPUSH
8578: CALL_OW 293
8582: IFFALSE 8562
// DialogueOn ;
8584: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8588: LD_EXP 16
8592: PPUSH
8593: LD_STRING D1-JMM-1
8595: PPUSH
8596: CALL_OW 88
// if Joan then
8600: LD_EXP 31
8604: IFFALSE 8618
// Say ( Joan , D1-Joan-1 ) ;
8606: LD_EXP 31
8610: PPUSH
8611: LD_STRING D1-Joan-1
8613: PPUSH
8614: CALL_OW 88
// if Lisa then
8618: LD_EXP 18
8622: IFFALSE 8636
// Say ( Lisa , D1-Lisa-1 ) ;
8624: LD_EXP 18
8628: PPUSH
8629: LD_STRING D1-Lisa-1
8631: PPUSH
8632: CALL_OW 88
// if Joan or Lisa then
8636: LD_EXP 31
8640: PUSH
8641: LD_EXP 18
8645: OR
8646: IFFALSE 8660
// Say ( JMM , D1-JMM-2 ) ;
8648: LD_EXP 16
8652: PPUSH
8653: LD_STRING D1-JMM-2
8655: PPUSH
8656: CALL_OW 88
// DialogueOff ;
8660: CALL_OW 7
// InGameOff ;
8664: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8668: LD_INT 71
8670: PPUSH
8671: LD_INT 50
8673: PPUSH
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 30
8679: NEG
8680: PPUSH
8681: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8685: LD_INT 71
8687: PPUSH
8688: LD_INT 50
8690: PPUSH
8691: LD_INT 7
8693: PPUSH
8694: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8698: LD_STRING M1
8700: PPUSH
8701: CALL_OW 337
// SaveForQuickRestart ;
8705: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8716: LD_EXP 3
8720: PUSH
8721: LD_OWVAR 1
8725: PUSH
8726: LD_INT 2100
8728: GREATER
8729: OR
8730: IFFALSE 8709
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8732: LD_INT 350
8734: PPUSH
8735: LD_INT 700
8737: PPUSH
8738: CALL_OW 12
8742: PPUSH
8743: CALL_OW 67
// PrepareGossudarov ;
8747: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
8751: LD_INT 35
8753: PPUSH
8754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8758: LD_INT 22
8760: PUSH
8761: LD_INT 6
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: LD_INT 3
8770: PUSH
8771: LD_INT 24
8773: PUSH
8774: LD_INT 1000
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PPUSH
8789: CALL_OW 69
8793: PUSH
8794: LD_INT 7
8796: PPUSH
8797: LD_EXP 34
8801: PPUSH
8802: CALL_OW 292
8806: OR
8807: IFFALSE 8751
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8809: LD_ADDR_VAR 0 2
8813: PUSH
8814: LD_INT 22
8816: PUSH
8817: LD_INT 6
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PPUSH
8824: CALL_OW 69
8828: ST_TO_ADDR
// for i in tmp do
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_VAR 0 2
8838: PUSH
8839: FOR_IN
8840: IFFALSE 8856
// SetSide ( i , 7 ) ;
8842: LD_VAR 0 3
8846: PPUSH
8847: LD_INT 7
8849: PPUSH
8850: CALL_OW 235
8854: GO 8839
8856: POP
8857: POP
// DialogueOn ;
8858: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8862: LD_EXP 16
8866: PUSH
8867: LD_EXP 17
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: PPUSH
8876: LD_EXP 34
8880: PPUSH
8881: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8885: LD_EXP 34
8889: PPUSH
8890: CALL_OW 87
// if not Roth then
8894: LD_EXP 17
8898: NOT
8899: IFFALSE 8991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 3
8908: PUSH
8909: LD_INT 24
8911: PUSH
8912: LD_INT 1000
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: PPUSH
8923: CALL_OW 72
8927: IFFALSE 8941
// Say ( JMM , D2-JMM-1 ) ;
8929: LD_EXP 16
8933: PPUSH
8934: LD_STRING D2-JMM-1
8936: PPUSH
8937: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8941: LD_EXP 16
8945: PPUSH
8946: LD_STRING D2-JMM-1b
8948: PPUSH
8949: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8953: LD_EXP 34
8957: PPUSH
8958: LD_STRING D2-Gos-1
8960: PPUSH
8961: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8965: LD_EXP 16
8969: PPUSH
8970: LD_STRING D2-JMM-2
8972: PPUSH
8973: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8977: LD_EXP 34
8981: PPUSH
8982: LD_STRING D2-Gos-2
8984: PPUSH
8985: CALL_OW 88
// end else
8989: GO 9143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8991: LD_VAR 0 2
8995: PPUSH
8996: LD_INT 3
8998: PUSH
8999: LD_INT 24
9001: PUSH
9002: LD_INT 1000
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PPUSH
9013: CALL_OW 72
9017: IFFALSE 9043
// begin Say ( Roth , D2-Roth-2 ) ;
9019: LD_EXP 17
9023: PPUSH
9024: LD_STRING D2-Roth-2
9026: PPUSH
9027: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9031: LD_EXP 16
9035: PPUSH
9036: LD_STRING D2-JMM-1a
9038: PPUSH
9039: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9043: LD_EXP 17
9047: PPUSH
9048: LD_STRING D2-Roth-2a
9050: PPUSH
9051: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9055: LD_EXP 17
9059: PPUSH
9060: LD_STRING D2-Roth-2b
9062: PPUSH
9063: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9067: LD_EXP 16
9071: PPUSH
9072: LD_STRING D2-JMM-3
9074: PPUSH
9075: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9079: LD_VAR 0 2
9083: PPUSH
9084: LD_INT 3
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 1000
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PPUSH
9101: CALL_OW 72
9105: IFFALSE 9143
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9107: LD_EXP 34
9111: PPUSH
9112: LD_STRING D2-Gos-3
9114: PPUSH
9115: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9119: LD_EXP 16
9123: PPUSH
9124: LD_STRING D2-JMM-4
9126: PPUSH
9127: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9131: LD_EXP 34
9135: PPUSH
9136: LD_STRING D2-Gos-4
9138: PPUSH
9139: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9143: LD_EXP 16
9147: PPUSH
9148: LD_STRING D2-JMM-5
9150: PPUSH
9151: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9155: LD_EXP 34
9159: PPUSH
9160: LD_STRING D2-Gos-5
9162: PPUSH
9163: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9167: LD_EXP 16
9171: PPUSH
9172: LD_STRING D2-JMM-6
9174: PPUSH
9175: CALL_OW 88
// DialogueOff ;
9179: CALL_OW 7
// wait ( 0 0$2 ) ;
9183: LD_INT 70
9185: PPUSH
9186: CALL_OW 67
// if Kirilenkova then
9190: LD_EXP 35
9194: IFFALSE 9208
// Say ( Kirilenkova , D3-Kir-1 ) ;
9196: LD_EXP 35
9200: PPUSH
9201: LD_STRING D3-Kir-1
9203: PPUSH
9204: CALL_OW 88
// gossudarov_arrive := true ;
9208: LD_ADDR_EXP 4
9212: PUSH
9213: LD_INT 1
9215: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9216: LD_INT 35
9218: PPUSH
9219: CALL_OW 67
// until ru_lab_builded ;
9223: LD_EXP 5
9227: IFFALSE 9216
// DialogueOn ;
9229: CALL_OW 6
// if Kirilenkova then
9233: LD_EXP 35
9237: IFFALSE 9253
// Say ( Kirilenkova , D3a-Kir-1 ) else
9239: LD_EXP 35
9243: PPUSH
9244: LD_STRING D3a-Kir-1
9246: PPUSH
9247: CALL_OW 88
9251: GO 9275
// begin un := SciRu ;
9253: LD_ADDR_VAR 0 4
9257: PUSH
9258: CALL 14799 0 0
9262: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
9263: LD_VAR 0 4
9267: PPUSH
9268: LD_STRING D3a-Sci1-1
9270: PPUSH
9271: CALL_OW 88
// end ; if Kirilenkova or un then
9275: LD_EXP 35
9279: PUSH
9280: LD_VAR 0 4
9284: OR
9285: IFFALSE 9299
// Say ( JMM , D3a-JMM-1 ) ;
9287: LD_EXP 16
9291: PPUSH
9292: LD_STRING D3a-JMM-1
9294: PPUSH
9295: CALL_OW 88
// DialogueOff ;
9299: CALL_OW 7
// end ;
9303: LD_VAR 0 1
9307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9308: LD_EXP 4
9312: PUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 7
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: PUSH
9323: LD_INT 2
9325: PUSH
9326: LD_INT 25
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: EMPTY
9333: LIST
9334: LIST
9335: PUSH
9336: LD_INT 25
9338: PUSH
9339: LD_INT 2
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: PUSH
9346: LD_INT 25
9348: PUSH
9349: LD_INT 3
9351: PUSH
9352: EMPTY
9353: LIST
9354: LIST
9355: PUSH
9356: LD_INT 25
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: LD_INT 25
9368: PUSH
9369: LD_INT 5
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: PUSH
9376: LD_INT 25
9378: PUSH
9379: LD_INT 8
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 25
9388: PUSH
9389: LD_INT 9
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: PUSH
9415: LD_INT 7
9417: LESS
9418: AND
9419: IFFALSE 9431
9421: GO 9423
9423: DISABLE
// YouLost ( TooMany ) ;
9424: LD_STRING TooMany
9426: PPUSH
9427: CALL_OW 104
9431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9432: LD_EXP 34
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 7
9444: EQUAL
9445: IFFALSE 9662
9447: GO 9449
9449: DISABLE
9450: LD_INT 0
9452: PPUSH
9453: PPUSH
9454: PPUSH
// begin uc_side := 3 ;
9455: LD_ADDR_OWVAR 20
9459: PUSH
9460: LD_INT 3
9462: ST_TO_ADDR
// uc_nation := 3 ;
9463: LD_ADDR_OWVAR 21
9467: PUSH
9468: LD_INT 3
9470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9471: LD_INT 21
9473: PPUSH
9474: LD_INT 3
9476: PPUSH
9477: LD_INT 3
9479: PPUSH
9480: LD_INT 42
9482: PPUSH
9483: LD_INT 100
9485: PPUSH
9486: CALL 21285 0 5
// un := CreateVehicle ;
9490: LD_ADDR_VAR 0 3
9494: PUSH
9495: CALL_OW 45
9499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9500: LD_VAR 0 3
9504: PPUSH
9505: LD_INT 15
9507: PPUSH
9508: LD_INT 0
9510: PPUSH
9511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9515: LD_VAR 0 3
9519: PPUSH
9520: LD_INT 67
9522: PPUSH
9523: LD_INT 45
9525: PPUSH
9526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9530: LD_VAR 0 3
9534: PPUSH
9535: LD_INT 70
9537: PPUSH
9538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9542: LD_VAR 0 3
9546: PPUSH
9547: LD_INT 69
9549: PPUSH
9550: LD_INT 18
9552: PPUSH
9553: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9557: LD_VAR 0 3
9561: PPUSH
9562: LD_INT 60
9564: PPUSH
9565: LD_INT 3
9567: PPUSH
9568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9572: LD_INT 35
9574: PPUSH
9575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9579: LD_VAR 0 3
9583: PPUSH
9584: CALL_OW 302
9588: NOT
9589: PUSH
9590: LD_VAR 0 3
9594: PPUSH
9595: LD_INT 17
9597: PPUSH
9598: CALL_OW 308
9602: OR
9603: PUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: LD_INT 60
9611: PPUSH
9612: LD_INT 3
9614: PPUSH
9615: CALL_OW 307
9619: OR
9620: IFFALSE 9572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9622: LD_VAR 0 3
9626: PPUSH
9627: LD_INT 17
9629: PPUSH
9630: CALL_OW 308
9634: PUSH
9635: LD_VAR 0 3
9639: PPUSH
9640: LD_INT 60
9642: PPUSH
9643: LD_INT 3
9645: PPUSH
9646: CALL_OW 307
9650: OR
9651: IFFALSE 9662
// RemoveUnit ( un ) ;
9653: LD_VAR 0 3
9657: PPUSH
9658: CALL_OW 64
// end ;
9662: PPOPN 3
9664: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9665: LD_EXP 4
9669: IFFALSE 9911
9671: GO 9673
9673: DISABLE
9674: LD_INT 0
9676: PPUSH
9677: PPUSH
9678: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9679: LD_INT 70
9681: PPUSH
9682: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9686: LD_ADDR_VAR 0 3
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 7
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 101
9703: PUSH
9704: LD_INT 3
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: PPUSH
9715: CALL_OW 69
9719: ST_TO_ADDR
// until tmp ;
9720: LD_VAR 0 3
9724: IFFALSE 9679
// un := NearestUnitToUnit ( tmp , JMM ) ;
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_VAR 0 3
9735: PPUSH
9736: LD_EXP 16
9740: PPUSH
9741: CALL_OW 74
9745: ST_TO_ADDR
// player_spotted := true ;
9746: LD_ADDR_EXP 6
9750: PUSH
9751: LD_INT 1
9753: ST_TO_ADDR
// tmp := SciRu ;
9754: LD_ADDR_VAR 0 3
9758: PUSH
9759: CALL 14799 0 0
9763: ST_TO_ADDR
// if not tmp then
9764: LD_VAR 0 3
9768: NOT
9769: IFFALSE 9781
// tmp := SolRu ;
9771: LD_ADDR_VAR 0 3
9775: PUSH
9776: CALL 14946 0 0
9780: ST_TO_ADDR
// DialogueOn ;
9781: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9785: LD_VAR 0 2
9789: PPUSH
9790: CALL_OW 250
9794: PPUSH
9795: LD_VAR 0 2
9799: PPUSH
9800: CALL_OW 251
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: LD_INT 8
9810: NEG
9811: PPUSH
9812: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9816: LD_VAR 0 2
9820: PPUSH
9821: CALL_OW 87
// if tmp then
9825: LD_VAR 0 3
9829: IFFALSE 9843
// Say ( tmp , D4-RSci1-1 ) ;
9831: LD_VAR 0 3
9835: PPUSH
9836: LD_STRING D4-RSci1-1
9838: PPUSH
9839: CALL_OW 88
// if Gossudarov then
9843: LD_EXP 34
9847: IFFALSE 9873
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9849: LD_EXP 34
9853: PPUSH
9854: LD_STRING D4-Gos-1
9856: PPUSH
9857: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9861: LD_EXP 16
9865: PPUSH
9866: LD_STRING D4-JMM-1
9868: PPUSH
9869: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9873: LD_VAR 0 2
9877: PPUSH
9878: CALL_OW 250
9882: PPUSH
9883: LD_VAR 0 2
9887: PPUSH
9888: CALL_OW 251
9892: PPUSH
9893: LD_INT 7
9895: PPUSH
9896: CALL_OW 331
// DialogueOff ;
9900: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9904: LD_STRING M5
9906: PPUSH
9907: CALL_OW 337
// end ;
9911: PPOPN 3
9913: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9914: LD_EXP 6
9918: IFFALSE 10511
9920: GO 9922
9922: DISABLE
9923: LD_INT 0
9925: PPUSH
9926: PPUSH
9927: PPUSH
// begin PrepareBelkov ;
9928: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9932: LD_EXP 49
9936: PPUSH
9937: LD_INT 118
9939: PPUSH
9940: LD_INT 106
9942: PPUSH
9943: CALL_OW 111
// AddComHold ( Belkov ) ;
9947: LD_EXP 49
9951: PPUSH
9952: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9956: LD_INT 35
9958: PPUSH
9959: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9963: LD_EXP 49
9967: PPUSH
9968: LD_INT 118
9970: PPUSH
9971: LD_INT 106
9973: PPUSH
9974: CALL_OW 307
9978: IFFALSE 9956
// ChangeSideFog ( 4 , 7 ) ;
9980: LD_INT 4
9982: PPUSH
9983: LD_INT 7
9985: PPUSH
9986: CALL_OW 343
// if IsOk ( Belkov ) then
9990: LD_EXP 49
9994: PPUSH
9995: CALL_OW 302
9999: IFFALSE 10083
// begin InGameOn ;
10001: CALL_OW 8
// DialogueOn ;
10005: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10009: LD_EXP 49
10013: PPUSH
10014: LD_STRING D5-Bel-1
10016: PPUSH
10017: CALL_OW 94
// if Gossudarov then
10021: LD_EXP 34
10025: IFFALSE 10075
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10027: LD_EXP 34
10031: PPUSH
10032: LD_STRING D5-Gos-1
10034: PPUSH
10035: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10039: LD_EXP 16
10043: PPUSH
10044: LD_STRING D5-JMM-1
10046: PPUSH
10047: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10051: LD_EXP 34
10055: PPUSH
10056: LD_STRING D5-Gos-2
10058: PPUSH
10059: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10063: LD_EXP 16
10067: PPUSH
10068: LD_STRING D5-JMM-2
10070: PPUSH
10071: CALL_OW 88
// end ; DialogueOff ;
10075: CALL_OW 7
// InGameOff ;
10079: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10083: LD_STRING QSaveBelkov
10085: PPUSH
10086: CALL_OW 97
10090: PUSH
10091: LD_INT 1
10093: DOUBLE
10094: EQUAL
10095: IFTRUE 10099
10097: GO 10149
10099: POP
// begin DialogueOn ;
10100: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10104: LD_EXP 16
10108: PPUSH
10109: LD_STRING D5a-JMM-1
10111: PPUSH
10112: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10116: LD_EXP 49
10120: PPUSH
10121: LD_STRING D5a-Bel-1
10123: PPUSH
10124: CALL_OW 94
// DialogueOff ;
10128: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10132: LD_EXP 49
10136: PPUSH
10137: LD_INT 83
10139: PPUSH
10140: LD_INT 49
10142: PPUSH
10143: CALL_OW 111
// end ; 2 :
10147: GO 10182
10149: LD_INT 2
10151: DOUBLE
10152: EQUAL
10153: IFTRUE 10157
10155: GO 10181
10157: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10158: LD_EXP 16
10162: PPUSH
10163: LD_STRING D5a-JMM-2
10165: PPUSH
10166: CALL_OW 88
// ComHold ( Belkov ) ;
10170: LD_EXP 49
10174: PPUSH
10175: CALL_OW 140
// end ; end ;
10179: GO 10182
10181: POP
// time := 0 0$00 ;
10182: LD_ADDR_VAR 0 1
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
// vehSpawned := false ;
10190: LD_ADDR_VAR 0 3
10194: PUSH
10195: LD_INT 0
10197: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10198: LD_INT 35
10200: PPUSH
10201: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 350
10212: PUSH
10213: LD_INT 175
10215: PUSH
10216: LD_INT 105
10218: PUSH
10219: LD_INT 70
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_OWVAR 67
10232: ARRAY
10233: GREATEREQUAL
10234: PUSH
10235: LD_VAR 0 3
10239: NOT
10240: AND
10241: IFFALSE 10331
// begin vehSpawned := true ;
10243: LD_ADDR_VAR 0 3
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// uc_side := 3 ;
10251: LD_ADDR_OWVAR 20
10255: PUSH
10256: LD_INT 3
10258: ST_TO_ADDR
// uc_nation := 3 ;
10259: LD_ADDR_OWVAR 21
10263: PUSH
10264: LD_INT 3
10266: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
10267: LD_INT 22
10269: PPUSH
10270: LD_INT 3
10272: PPUSH
10273: LD_INT 3
10275: PPUSH
10276: LD_INT 43
10278: PPUSH
10279: LD_INT 100
10281: PPUSH
10282: CALL 21285 0 5
// veh := CreateVehicle ;
10286: LD_ADDR_VAR 0 2
10290: PUSH
10291: CALL_OW 45
10295: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10296: LD_VAR 0 2
10300: PPUSH
10301: LD_INT 130
10303: PPUSH
10304: LD_INT 131
10306: PPUSH
10307: LD_INT 0
10309: PPUSH
10310: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10314: LD_VAR 0 2
10318: PPUSH
10319: LD_INT 100
10321: PPUSH
10322: LD_INT 82
10324: PPUSH
10325: CALL_OW 114
// end else
10329: GO 10345
// time := time + 0 0$1 ;
10331: LD_ADDR_VAR 0 1
10335: PUSH
10336: LD_VAR 0 1
10340: PUSH
10341: LD_INT 35
10343: PLUS
10344: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10345: LD_EXP 49
10349: PPUSH
10350: CALL_OW 301
10354: PUSH
10355: LD_EXP 49
10359: PPUSH
10360: CALL_OW 255
10364: PUSH
10365: LD_INT 4
10367: EQUAL
10368: AND
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PPUSH
10380: CALL_OW 69
10384: PPUSH
10385: LD_EXP 49
10389: PPUSH
10390: CALL_OW 74
10394: PPUSH
10395: LD_EXP 49
10399: PPUSH
10400: CALL_OW 296
10404: PUSH
10405: LD_INT 10
10407: LESS
10408: OR
10409: IFFALSE 10198
// if IsDead ( Belkov ) then
10411: LD_EXP 49
10415: PPUSH
10416: CALL_OW 301
10420: IFFALSE 10445
// begin CenterNowOnUnits ( Belkov ) ;
10422: LD_EXP 49
10426: PPUSH
10427: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10431: LD_EXP 16
10435: PPUSH
10436: LD_STRING D5a-JMM-2a
10438: PPUSH
10439: CALL_OW 88
// exit ;
10443: GO 10511
// end ; if See ( 7 , Belkov ) then
10445: LD_INT 7
10447: PPUSH
10448: LD_EXP 49
10452: PPUSH
10453: CALL_OW 292
10457: IFFALSE 10471
// SetSide ( Belkov , 7 ) ;
10459: LD_EXP 49
10463: PPUSH
10464: LD_INT 7
10466: PPUSH
10467: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10478: LD_EXP 49
10482: PPUSH
10483: LD_INT 66
10485: PPUSH
10486: LD_INT 45
10488: PPUSH
10489: CALL_OW 297
10493: PUSH
10494: LD_INT 30
10496: LESS
10497: IFFALSE 10471
// Say ( Belkov , D6-Bel-1 ) ;
10499: LD_EXP 49
10503: PPUSH
10504: LD_STRING D6-Bel-1
10506: PPUSH
10507: CALL_OW 88
// end ;
10511: PPOPN 3
10513: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10514: LD_EXP 49
10518: PPUSH
10519: CALL_OW 302
10523: PUSH
10524: LD_EXP 49
10528: PPUSH
10529: CALL_OW 504
10533: PUSH
10534: LD_INT 2
10536: PUSH
10537: LD_INT 34
10539: PUSH
10540: LD_INT 47
10542: PUSH
10543: EMPTY
10544: LIST
10545: LIST
10546: PUSH
10547: LD_INT 34
10549: PUSH
10550: LD_INT 45
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PUSH
10557: EMPTY
10558: LIST
10559: LIST
10560: LIST
10561: PPUSH
10562: CALL_OW 69
10566: IN
10567: AND
10568: IFFALSE 10585
10570: GO 10572
10572: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10573: LD_EXP 49
10577: PPUSH
10578: LD_STRING D7-Bel-1
10580: PPUSH
10581: CALL_OW 88
10585: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10586: LD_INT 22
10588: PUSH
10589: LD_INT 7
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 101
10598: PUSH
10599: LD_INT 2
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 69
10614: PUSH
10615: LD_EXP 8
10619: NOT
10620: AND
10621: PUSH
10622: LD_EXP 48
10626: PPUSH
10627: CALL_OW 305
10631: NOT
10632: AND
10633: IFFALSE 11118
10635: GO 10637
10637: DISABLE
10638: LD_INT 0
10640: PPUSH
// begin ar_base_spotted := true ;
10641: LD_ADDR_EXP 8
10645: PUSH
10646: LD_INT 1
10648: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10649: LD_ADDR_VAR 0 1
10653: PUSH
10654: LD_INT 22
10656: PUSH
10657: LD_INT 2
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PUSH
10664: LD_INT 21
10666: PUSH
10667: LD_INT 3
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: PPUSH
10678: CALL_OW 69
10682: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10683: LD_ADDR_VAR 0 1
10687: PUSH
10688: LD_VAR 0 1
10692: PPUSH
10693: LD_EXP 16
10697: PPUSH
10698: CALL_OW 74
10702: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10703: LD_INT 7
10705: PPUSH
10706: LD_INT 3
10708: PPUSH
10709: CALL_OW 332
// DialogueOn ;
10713: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 250
10726: PPUSH
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 251
10736: PPUSH
10737: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10741: LD_ADDR_VAR 0 1
10745: PUSH
10746: LD_INT 22
10748: PUSH
10749: LD_INT 7
10751: PUSH
10752: EMPTY
10753: LIST
10754: LIST
10755: PUSH
10756: LD_INT 23
10758: PUSH
10759: LD_INT 1
10761: PUSH
10762: EMPTY
10763: LIST
10764: LIST
10765: PUSH
10766: LD_INT 26
10768: PUSH
10769: LD_INT 1
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: PPUSH
10781: CALL_OW 69
10785: PUSH
10786: LD_EXP 16
10790: PUSH
10791: LD_EXP 20
10795: PUSH
10796: LD_EXP 21
10800: PUSH
10801: LD_EXP 28
10805: PUSH
10806: LD_EXP 17
10810: PUSH
10811: LD_EXP 26
10815: PUSH
10816: LD_EXP 22
10820: PUSH
10821: LD_EXP 24
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: LIST
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: DIFF
10836: ST_TO_ADDR
// if not tmp then
10837: LD_VAR 0 1
10841: NOT
10842: IFFALSE 10916
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10844: LD_ADDR_VAR 0 1
10848: PUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 7
10854: PUSH
10855: EMPTY
10856: LIST
10857: LIST
10858: PUSH
10859: LD_INT 23
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 26
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: PUSH
10889: LD_EXP 31
10893: PUSH
10894: LD_EXP 18
10898: PUSH
10899: LD_EXP 29
10903: PUSH
10904: LD_EXP 30
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: LIST
10913: LIST
10914: DIFF
10915: ST_TO_ADDR
// if tmp then
10916: LD_VAR 0 1
10920: IFFALSE 10991
// case GetSex ( tmp [ 1 ] ) of sex_male :
10922: LD_VAR 0 1
10926: PUSH
10927: LD_INT 1
10929: ARRAY
10930: PPUSH
10931: CALL_OW 258
10935: PUSH
10936: LD_INT 1
10938: DOUBLE
10939: EQUAL
10940: IFTRUE 10944
10942: GO 10963
10944: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10945: LD_VAR 0 1
10949: PUSH
10950: LD_INT 1
10952: ARRAY
10953: PPUSH
10954: LD_STRING D9-Sol1-1
10956: PPUSH
10957: CALL_OW 88
10961: GO 10991
10963: LD_INT 2
10965: DOUBLE
10966: EQUAL
10967: IFTRUE 10971
10969: GO 10990
10971: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10972: LD_VAR 0 1
10976: PUSH
10977: LD_INT 1
10979: ARRAY
10980: PPUSH
10981: LD_STRING D9-FSol1-1
10983: PPUSH
10984: CALL_OW 88
10988: GO 10991
10990: POP
// if Frank then
10991: LD_EXP 28
10995: IFFALSE 11099
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10997: LD_EXP 58
11001: PPUSH
11002: CALL_OW 250
11006: PPUSH
11007: LD_EXP 58
11011: PPUSH
11012: CALL_OW 251
11016: PPUSH
11017: LD_INT 7
11019: PPUSH
11020: LD_INT 8
11022: PPUSH
11023: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11027: LD_EXP 58
11031: PPUSH
11032: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11036: LD_EXP 28
11040: PPUSH
11041: LD_STRING D9-Frank-1
11043: PPUSH
11044: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11048: LD_EXP 16
11052: PPUSH
11053: LD_STRING D9-JMM-1
11055: PPUSH
11056: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11060: LD_EXP 28
11064: PPUSH
11065: LD_STRING D9-Frank-2
11067: PPUSH
11068: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11072: LD_EXP 58
11076: PPUSH
11077: CALL_OW 250
11081: PPUSH
11082: LD_EXP 58
11086: PPUSH
11087: CALL_OW 251
11091: PPUSH
11092: LD_INT 7
11094: PPUSH
11095: CALL_OW 331
// end ; DialogueOff ;
11099: CALL_OW 7
// wait ( 1 1$00 ) ;
11103: LD_INT 2100
11105: PPUSH
11106: CALL_OW 67
// ar_active_attack := true ;
11110: LD_ADDR_EXP 9
11114: PUSH
11115: LD_INT 1
11117: ST_TO_ADDR
// end ;
11118: PPOPN 1
11120: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11121: LD_EXP 7
11125: PUSH
11126: LD_OWVAR 1
11130: PUSH
11131: LD_INT 42000
11133: GREATEREQUAL
11134: OR
11135: IFFALSE 12197
11137: GO 11139
11139: DISABLE
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
// begin selected_option := 1 ;
11144: LD_ADDR_VAR 0 2
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11152: LD_INT 10500
11154: PPUSH
11155: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until not ru_attackers ;
11166: LD_EXP 54
11170: NOT
11171: IFFALSE 11159
// PrepareBurlak ;
11173: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
11177: LD_INT 70
11179: PPUSH
11180: CALL_OW 67
// until not HasTask ( Burlak ) ;
11184: LD_EXP 48
11188: PPUSH
11189: CALL_OW 314
11193: NOT
11194: IFFALSE 11177
// InGameOn ;
11196: CALL_OW 8
// DialogueOn ;
11200: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
11204: LD_EXP 51
11208: PPUSH
11209: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
11213: LD_EXP 48
11217: PPUSH
11218: LD_STRING D10-Bur-1
11220: PPUSH
11221: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
11225: LD_EXP 49
11229: PUSH
11230: LD_EXP 49
11234: PPUSH
11235: CALL_OW 255
11239: PUSH
11240: LD_INT 7
11242: EQUAL
11243: AND
11244: IFFALSE 11258
// Say ( Belkov , D10-Bel-1 ) ;
11246: LD_EXP 49
11250: PPUSH
11251: LD_STRING D10-Bel-1
11253: PPUSH
11254: CALL_OW 88
// if Gossudarov then
11258: LD_EXP 34
11262: IFFALSE 11276
// Say ( Gossudarov , D10-Gos-1 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_STRING D10-Gos-1
11271: PPUSH
11272: CALL_OW 88
// if Kirilenkova then
11276: LD_EXP 35
11280: IFFALSE 11294
// Say ( Kirilenkova , D10-Kir-1 ) ;
11282: LD_EXP 35
11286: PPUSH
11287: LD_STRING D10-Kir-1
11289: PPUSH
11290: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
11294: CALL 14946 0 0
11298: PPUSH
11299: LD_STRING D10-RSol1-1
11301: PPUSH
11302: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11306: LD_EXP 48
11310: PPUSH
11311: LD_STRING D10-Bur-2
11313: PPUSH
11314: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11318: LD_EXP 16
11322: PPUSH
11323: LD_STRING D10-JMM-2
11325: PPUSH
11326: CALL_OW 88
// if Kirilenkova then
11330: LD_EXP 35
11334: IFFALSE 11350
// Say ( Kirilenkova , D10-Kir-2 ) else
11336: LD_EXP 35
11340: PPUSH
11341: LD_STRING D10-Kir-2
11343: PPUSH
11344: CALL_OW 88
11348: GO 11362
// Say ( SolRu , D10-RSol1-2 ) ;
11350: CALL 14946 0 0
11354: PPUSH
11355: LD_STRING D10-RSol1-2
11357: PPUSH
11358: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11362: LD_EXP 16
11366: PPUSH
11367: LD_STRING D10-JMM-3
11369: PPUSH
11370: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11374: LD_EXP 48
11378: PPUSH
11379: LD_STRING D10-Bur-3
11381: PPUSH
11382: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11386: LD_EXP 16
11390: PPUSH
11391: LD_STRING D10-JMM-4
11393: PPUSH
11394: CALL_OW 88
// DialogueOff ;
11398: CALL_OW 7
// InGameOff ;
11402: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11406: LD_STRING M2
11408: PPUSH
11409: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11413: LD_INT 35
11415: PPUSH
11416: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 91
11432: PUSH
11433: LD_EXP 48
11437: PUSH
11438: LD_INT 8
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: LIST
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PPUSH
11450: CALL_OW 69
11454: IFFALSE 11413
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11456: LD_ADDR_VAR 0 1
11460: PUSH
11461: LD_INT 22
11463: PUSH
11464: LD_INT 4
11466: PUSH
11467: EMPTY
11468: LIST
11469: LIST
11470: PPUSH
11471: CALL_OW 69
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11493
// SetSide ( i , 7 ) ;
11479: LD_VAR 0 1
11483: PPUSH
11484: LD_INT 7
11486: PPUSH
11487: CALL_OW 235
11491: GO 11476
11493: POP
11494: POP
// ChangeMissionObjectives ( M3 ) ;
11495: LD_STRING M3
11497: PPUSH
11498: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11502: LD_INT 35
11504: PPUSH
11505: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11509: LD_EXP 16
11513: PPUSH
11514: LD_EXP 48
11518: PPUSH
11519: CALL_OW 296
11523: PUSH
11524: LD_INT 8
11526: LESS
11527: IFFALSE 11502
// ComTurnUnit ( JMM , Burlak ) ;
11529: LD_EXP 16
11533: PPUSH
11534: LD_EXP 48
11538: PPUSH
11539: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11543: LD_EXP 48
11547: PPUSH
11548: LD_EXP 16
11552: PPUSH
11553: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11557: LD_INT 10
11559: PPUSH
11560: CALL_OW 67
// DialogueOn ;
11564: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11568: LD_EXP 16
11572: PPUSH
11573: LD_STRING D11-JMM-1
11575: PPUSH
11576: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11580: LD_EXP 48
11584: PPUSH
11585: LD_STRING D11-Bur-1
11587: PPUSH
11588: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11592: LD_EXP 16
11596: PPUSH
11597: LD_STRING D11-JMM-2
11599: PPUSH
11600: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11604: LD_EXP 48
11608: PPUSH
11609: LD_STRING D11-Bur-2
11611: PPUSH
11612: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11616: LD_EXP 16
11620: PPUSH
11621: LD_STRING D11-JMM-3
11623: PPUSH
11624: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11628: LD_EXP 48
11632: PPUSH
11633: LD_STRING D11-Bur-3
11635: PPUSH
11636: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11640: LD_EXP 16
11644: PPUSH
11645: LD_STRING D11-JMM-4
11647: PPUSH
11648: CALL_OW 88
// if ar_base_spotted then
11652: LD_EXP 8
11656: IFFALSE 11672
// Say ( Burlak , D12-Bur-1 ) else
11658: LD_EXP 48
11662: PPUSH
11663: LD_STRING D12-Bur-1
11665: PPUSH
11666: CALL_OW 88
11670: GO 11711
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11672: LD_INT 7
11674: PPUSH
11675: LD_INT 3
11677: PPUSH
11678: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11682: LD_INT 127
11684: PPUSH
11685: LD_INT 45
11687: PPUSH
11688: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11692: LD_EXP 48
11696: PPUSH
11697: LD_STRING D12-Bur-1a
11699: PPUSH
11700: CALL_OW 88
// dwait ( 0 0$2 ) ;
11704: LD_INT 70
11706: PPUSH
11707: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
11711: LD_EXP 57
11715: PPUSH
11716: CALL_OW 302
11720: NOT
11721: IFFALSE 11729
// begin DialogueOff ;
11723: CALL_OW 7
// exit ;
11727: GO 12197
// end ; Say ( Burlak , D12-Bur-1b ) ;
11729: LD_EXP 48
11733: PPUSH
11734: LD_STRING D12-Bur-1b
11736: PPUSH
11737: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11741: LD_EXP 16
11745: PPUSH
11746: LD_STRING D12-JMM-1
11748: PPUSH
11749: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11753: LD_EXP 48
11757: PPUSH
11758: LD_STRING D12-Bur-2
11760: PPUSH
11761: CALL_OW 88
// if Roth then
11765: LD_EXP 17
11769: IFFALSE 11785
// Say ( Roth , D12-Roth-2 ) else
11771: LD_EXP 17
11775: PPUSH
11776: LD_STRING D12-Roth-2
11778: PPUSH
11779: CALL_OW 88
11783: GO 11797
// Say ( SciRu , D12-RSci1-2 ) ;
11785: CALL 14799 0 0
11789: PPUSH
11790: LD_STRING D12-RSci1-2
11792: PPUSH
11793: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11797: LD_EXP 16
11801: PPUSH
11802: LD_STRING D12-JMM-2
11804: PPUSH
11805: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11809: LD_EXP 48
11813: PPUSH
11814: LD_STRING D12-Bur-3
11816: PPUSH
11817: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11821: LD_EXP 16
11825: PPUSH
11826: LD_STRING D12-JMM-3
11828: PPUSH
11829: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11833: LD_EXP 48
11837: PPUSH
11838: LD_STRING D12-Bur-4
11840: PPUSH
11841: CALL_OW 88
// case Query ( QBase ) of 1 :
11845: LD_STRING QBase
11847: PPUSH
11848: CALL_OW 97
11852: PUSH
11853: LD_INT 1
11855: DOUBLE
11856: EQUAL
11857: IFTRUE 11861
11859: GO 11979
11861: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11862: LD_EXP 16
11866: PPUSH
11867: LD_STRING D13a-JMM-1
11869: PPUSH
11870: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11874: LD_EXP 48
11878: PPUSH
11879: LD_STRING D13a-Bur-1
11881: PPUSH
11882: CALL_OW 88
// if Roth then
11886: LD_EXP 17
11890: IFFALSE 11906
// Say ( Roth , D13a-Roth-1 ) else
11892: LD_EXP 17
11896: PPUSH
11897: LD_STRING D13a-Roth-1
11899: PPUSH
11900: CALL_OW 88
11904: GO 11918
// Say ( SciRu , D13a-RSci1-1 ) ;
11906: CALL 14799 0 0
11910: PPUSH
11911: LD_STRING D13a-RSci1-1
11913: PPUSH
11914: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11918: LD_EXP 16
11922: PPUSH
11923: LD_STRING D13a-JMM-2
11925: PPUSH
11926: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11930: LD_STRING QBaseAgain
11932: PPUSH
11933: CALL_OW 97
11937: PUSH
11938: LD_INT 1
11940: DOUBLE
11941: EQUAL
11942: IFTRUE 11946
11944: GO 11957
11946: POP
// selected_option := 2 ; 2 :
11947: LD_ADDR_VAR 0 2
11951: PUSH
11952: LD_INT 2
11954: ST_TO_ADDR
11955: GO 11977
11957: LD_INT 2
11959: DOUBLE
11960: EQUAL
11961: IFTRUE 11965
11963: GO 11976
11965: POP
// selected_option := 3 ; end ;
11966: LD_ADDR_VAR 0 2
11970: PUSH
11971: LD_INT 3
11973: ST_TO_ADDR
11974: GO 11977
11976: POP
// end ; 2 :
11977: GO 12018
11979: LD_INT 2
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// selected_option := 2 ; 3 :
11988: LD_ADDR_VAR 0 2
11992: PUSH
11993: LD_INT 2
11995: ST_TO_ADDR
11996: GO 12018
11998: LD_INT 3
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// selected_option := 3 ; end ;
12007: LD_ADDR_VAR 0 2
12011: PUSH
12012: LD_INT 3
12014: ST_TO_ADDR
12015: GO 12018
12017: POP
// if selected_option = 2 then
12018: LD_VAR 0 2
12022: PUSH
12023: LD_INT 2
12025: EQUAL
12026: IFFALSE 12130
// begin Say ( JMM , D13b-JMM-1 ) ;
12028: LD_EXP 16
12032: PPUSH
12033: LD_STRING D13b-JMM-1
12035: PPUSH
12036: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12040: LD_EXP 48
12044: PPUSH
12045: LD_STRING D13b-Bur-1
12047: PPUSH
12048: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12052: LD_EXP 16
12056: PPUSH
12057: LD_STRING D13b-JMM-2
12059: PPUSH
12060: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12064: LD_EXP 57
12068: PPUSH
12069: LD_STRING D13b-Abd-2
12071: PPUSH
12072: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12076: LD_EXP 16
12080: PPUSH
12081: LD_STRING D13b-JMM-3
12083: PPUSH
12084: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12088: LD_EXP 57
12092: PPUSH
12093: LD_STRING D13b-Abd-3
12095: PPUSH
12096: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12100: LD_EXP 16
12104: PPUSH
12105: LD_STRING D13b-JMM-4
12107: PPUSH
12108: CALL_OW 88
// ar_active_attack := true ;
12112: LD_ADDR_EXP 9
12116: PUSH
12117: LD_INT 1
12119: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
12120: LD_INT 1
12122: PPUSH
12123: LD_STRING 13a_negotiationWithArabs
12125: PPUSH
12126: CALL_OW 39
// end ; if selected_option = 3 then
12130: LD_VAR 0 2
12134: PUSH
12135: LD_INT 3
12137: EQUAL
12138: IFFALSE 12164
// begin Say ( JMM , D13c-JMM-1 ) ;
12140: LD_EXP 16
12144: PPUSH
12145: LD_STRING D13c-JMM-1
12147: PPUSH
12148: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12152: LD_EXP 48
12156: PPUSH
12157: LD_STRING D13c-Bur-1
12159: PPUSH
12160: CALL_OW 88
// end ; DialogueOff ;
12164: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12168: LD_STRING M4
12170: PPUSH
12171: CALL_OW 337
// if not ar_active_attack then
12175: LD_EXP 9
12179: NOT
12180: IFFALSE 12197
// begin wait ( 6 6$00 ) ;
12182: LD_INT 12600
12184: PPUSH
12185: CALL_OW 67
// ar_active_attack := true ;
12189: LD_ADDR_EXP 9
12193: PUSH
12194: LD_INT 1
12196: ST_TO_ADDR
// end ; end ;
12197: PPOPN 2
12199: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
12200: LD_EXP 48
12204: PPUSH
12205: CALL_OW 305
12209: PUSH
12210: LD_EXP 48
12214: PPUSH
12215: CALL_OW 255
12219: PUSH
12220: LD_INT 7
12222: EQUAL
12223: AND
12224: IFFALSE 12447
12226: GO 12228
12228: DISABLE
12229: LD_INT 0
12231: PPUSH
// begin wait ( 4 4$40 ) ;
12232: LD_INT 9800
12234: PPUSH
12235: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12239: LD_INT 35
12241: PPUSH
12242: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
12246: LD_EXP 54
12250: NOT
12251: PUSH
12252: LD_INT 22
12254: PUSH
12255: LD_INT 6
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: PUSH
12262: LD_INT 50
12264: PUSH
12265: EMPTY
12266: LIST
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PPUSH
12272: CALL_OW 69
12276: NOT
12277: AND
12278: IFFALSE 12239
// PrepareGnyevko ;
12280: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
12284: LD_EXP 50
12288: PPUSH
12289: LD_INT 124
12291: PPUSH
12292: LD_INT 118
12294: PPUSH
12295: CALL_OW 111
// AddComHold ( Gnyevko ) ;
12299: LD_EXP 50
12303: PPUSH
12304: CALL_OW 200
// time := 0 0$00 ;
12308: LD_ADDR_VAR 0 1
12312: PUSH
12313: LD_INT 0
12315: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12316: LD_INT 35
12318: PPUSH
12319: CALL_OW 67
// time := time + 0 0$1 ;
12323: LD_ADDR_VAR 0 1
12327: PUSH
12328: LD_VAR 0 1
12332: PUSH
12333: LD_INT 35
12335: PLUS
12336: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12337: LD_EXP 50
12341: PPUSH
12342: LD_INT 124
12344: PPUSH
12345: LD_INT 118
12347: PPUSH
12348: CALL_OW 307
12352: PUSH
12353: LD_VAR 0 1
12357: PUSH
12358: LD_INT 1050
12360: GREATEREQUAL
12361: OR
12362: IFFALSE 12316
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12364: LD_EXP 50
12368: PPUSH
12369: LD_STRING DBelkov-Gny-1
12371: PPUSH
12372: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12376: LD_EXP 48
12380: PPUSH
12381: LD_STRING DBelkov-Bur-1a
12383: PPUSH
12384: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12388: LD_INT 35
12390: PPUSH
12391: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12395: LD_EXP 50
12399: PPUSH
12400: LD_INT 22
12402: PUSH
12403: LD_INT 7
12405: PUSH
12406: EMPTY
12407: LIST
12408: LIST
12409: PPUSH
12410: CALL_OW 69
12414: PPUSH
12415: LD_EXP 50
12419: PPUSH
12420: CALL_OW 74
12424: PPUSH
12425: CALL_OW 296
12429: PUSH
12430: LD_INT 8
12432: LESS
12433: IFFALSE 12388
// SetSide ( Gnyevko , 7 ) ;
12435: LD_EXP 50
12439: PPUSH
12440: LD_INT 7
12442: PPUSH
12443: CALL_OW 235
// end ;
12447: PPOPN 1
12449: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12450: LD_EXP 48
12454: PPUSH
12455: CALL_OW 255
12459: PUSH
12460: LD_INT 7
12462: EQUAL
12463: IFFALSE 12473
12465: GO 12467
12467: DISABLE
// begin enable ;
12468: ENABLE
// PrepareAmericanAttack ;
12469: CALL 7812 0 0
// end ;
12473: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12474: LD_INT 22
12476: PUSH
12477: LD_INT 1
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: PPUSH
12484: CALL_OW 69
12488: IFFALSE 12672
12490: GO 12492
12492: DISABLE
12493: LD_INT 0
12495: PPUSH
12496: PPUSH
// begin while true do
12497: LD_INT 1
12499: IFFALSE 12556
// begin wait ( 0 0$1 ) ;
12501: LD_INT 35
12503: PPUSH
12504: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12508: LD_ADDR_VAR 0 2
12512: PUSH
12513: LD_INT 22
12515: PUSH
12516: LD_INT 1
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PPUSH
12523: CALL_OW 69
12527: PPUSH
12528: LD_EXP 16
12532: PPUSH
12533: CALL_OW 74
12537: ST_TO_ADDR
// if See ( 7 , tmp ) then
12538: LD_INT 7
12540: PPUSH
12541: LD_VAR 0 2
12545: PPUSH
12546: CALL_OW 292
12550: IFFALSE 12554
// break ;
12552: GO 12556
// end ;
12554: GO 12497
// DialogueOn ;
12556: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12560: LD_VAR 0 2
12564: PPUSH
12565: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12569: LD_VAR 0 2
12573: PPUSH
12574: CALL_OW 250
12578: PPUSH
12579: LD_VAR 0 2
12583: PPUSH
12584: CALL_OW 251
12588: PPUSH
12589: LD_INT 7
12591: PPUSH
12592: LD_INT 8
12594: PPUSH
12595: CALL_OW 330
// if Denis then
12599: LD_EXP 22
12603: IFFALSE 12617
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12605: LD_EXP 22
12609: PPUSH
12610: LD_STRING DAmerAttack-Pet-1
12612: PPUSH
12613: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12617: LD_EXP 16
12621: PPUSH
12622: LD_STRING DAmerAttack-JMM-1
12624: PPUSH
12625: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12629: LD_EXP 48
12633: PPUSH
12634: LD_STRING DStop-Bur-1
12636: PPUSH
12637: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12641: LD_VAR 0 2
12645: PPUSH
12646: CALL_OW 250
12650: PPUSH
12651: LD_VAR 0 2
12655: PPUSH
12656: CALL_OW 251
12660: PPUSH
12661: LD_INT 7
12663: PPUSH
12664: CALL_OW 331
// DialogueOff ;
12668: CALL_OW 7
// end ;
12672: PPOPN 2
12674: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12675: LD_INT 22
12677: PUSH
12678: LD_INT 3
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: LD_INT 21
12687: PUSH
12688: LD_INT 1
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: EMPTY
12696: LIST
12697: LIST
12698: PPUSH
12699: CALL_OW 69
12703: PUSH
12704: LD_INT 0
12706: EQUAL
12707: IFFALSE 12749
12709: GO 12711
12711: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
12712: LD_STRING M5a
12714: PPUSH
12715: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12719: LD_EXP 16
12723: PPUSH
12724: LD_STRING D8-JMM-1
12726: PPUSH
12727: CALL_OW 88
// if Gossudarov then
12731: LD_EXP 34
12735: IFFALSE 12749
// Say ( Gossudarov , D8-Gos-1 ) ;
12737: LD_EXP 34
12741: PPUSH
12742: LD_STRING D8-Gos-1
12744: PPUSH
12745: CALL_OW 88
// end ;
12749: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12750: LD_INT 22
12752: PUSH
12753: LD_INT 2
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 21
12762: PUSH
12763: LD_INT 1
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PPUSH
12774: CALL_OW 69
12778: PUSH
12779: LD_INT 0
12781: EQUAL
12782: IFFALSE 12832
12784: GO 12786
12786: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
12787: LD_STRING M4c
12789: PPUSH
12790: CALL_OW 337
// if Roth then
12794: LD_EXP 17
12798: IFFALSE 12814
// Say ( Roth , DStop-Roth-1 ) else
12800: LD_EXP 17
12804: PPUSH
12805: LD_STRING DStop-Roth-1
12807: PPUSH
12808: CALL_OW 88
12812: GO 12832
// if Gossudarov then
12814: LD_EXP 34
12818: IFFALSE 12832
// Say ( Gossudarov , D8-Gos-1a ) ;
12820: LD_EXP 34
12824: PPUSH
12825: LD_STRING D8-Gos-1a
12827: PPUSH
12828: CALL_OW 88
// end ;
12832: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
12833: LD_INT 3
12835: PPUSH
12836: CALL_OW 469
12840: PUSH
12841: LD_EXP 12
12845: AND
12846: IFFALSE 12901
12848: GO 12850
12850: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12851: LD_INT 3
12853: PPUSH
12854: CALL_OW 469
12858: PPUSH
12859: CALL 8301 0 1
// if Difficulty > 2 then
12863: LD_OWVAR 67
12867: PUSH
12868: LD_INT 2
12870: GREATER
12871: IFFALSE 12901
// begin wait ( 5 5$00 ) ;
12873: LD_INT 10500
12875: PPUSH
12876: CALL_OW 67
// if FindArtifact ( 3 ) then
12880: LD_INT 3
12882: PPUSH
12883: CALL_OW 469
12887: IFFALSE 12901
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
12889: LD_INT 3
12891: PPUSH
12892: CALL_OW 469
12896: PPUSH
12897: CALL 8301 0 1
// end ; end ;
12901: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12902: LD_INT 7
12904: PPUSH
12905: LD_INT 1
12907: PPUSH
12908: LD_INT 1
12910: PPUSH
12911: CALL 16508 0 3
12915: PUSH
12916: LD_INT 0
12918: EQUAL
12919: PUSH
12920: LD_INT 7
12922: PPUSH
12923: LD_INT 3
12925: PPUSH
12926: LD_INT 1
12928: PPUSH
12929: CALL 16508 0 3
12933: PUSH
12934: LD_INT 0
12936: EQUAL
12937: AND
12938: IFFALSE 12950
12940: GO 12942
12942: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12943: LD_STRING M1a
12945: PPUSH
12946: CALL_OW 337
// end ;
12950: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12951: LD_INT 22
12953: PUSH
12954: LD_INT 2
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 23
12963: PUSH
12964: LD_INT 2
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: LD_INT 21
12973: PUSH
12974: LD_INT 1
12976: PUSH
12977: EMPTY
12978: LIST
12979: LIST
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: LIST
12985: PPUSH
12986: CALL_OW 69
12990: PUSH
12991: LD_INT 0
12993: EQUAL
12994: PUSH
12995: LD_INT 22
12997: PUSH
12998: LD_INT 3
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: PUSH
13005: LD_INT 23
13007: PUSH
13008: LD_INT 3
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 21
13017: PUSH
13018: LD_INT 1
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: LIST
13029: PPUSH
13030: CALL_OW 69
13034: PUSH
13035: LD_INT 0
13037: EQUAL
13038: AND
13039: PUSH
13040: LD_INT 22
13042: PUSH
13043: LD_INT 1
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PPUSH
13050: CALL_OW 69
13054: PUSH
13055: LD_INT 0
13057: EQUAL
13058: AND
13059: PUSH
13060: LD_INT 7
13062: PPUSH
13063: LD_INT 1
13065: PPUSH
13066: LD_INT 1
13068: PPUSH
13069: CALL 16508 0 3
13073: PUSH
13074: LD_INT 0
13076: EQUAL
13077: AND
13078: PUSH
13079: LD_INT 7
13081: PPUSH
13082: LD_INT 3
13084: PPUSH
13085: LD_INT 1
13087: PPUSH
13088: CALL 16508 0 3
13092: PUSH
13093: LD_INT 0
13095: EQUAL
13096: AND
13097: PUSH
13098: LD_EXP 48
13102: PPUSH
13103: CALL_OW 255
13107: PUSH
13108: LD_INT 7
13110: EQUAL
13111: AND
13112: PUSH
13113: LD_EXP 48
13117: PPUSH
13118: CALL_OW 302
13122: AND
13123: IFFALSE 14796
13125: GO 13127
13127: DISABLE
13128: LD_INT 0
13130: PPUSH
13131: PPUSH
13132: PPUSH
13133: PPUSH
13134: PPUSH
13135: PPUSH
// begin m1 := false ;
13136: LD_ADDR_VAR 0 4
13140: PUSH
13141: LD_INT 0
13143: ST_TO_ADDR
// m2 := false ;
13144: LD_ADDR_VAR 0 5
13148: PUSH
13149: LD_INT 0
13151: ST_TO_ADDR
// m3 := false ;
13152: LD_ADDR_VAR 0 6
13156: PUSH
13157: LD_INT 0
13159: ST_TO_ADDR
// if tick < 40 40$00 then
13160: LD_OWVAR 1
13164: PUSH
13165: LD_INT 84000
13167: LESS
13168: IFFALSE 13177
// SetAchievement ( ACH_ASPEED_17 ) ;
13170: LD_STRING ACH_ASPEED_17
13172: PPUSH
13173: CALL_OW 543
// wait ( 0 0$5 ) ;
13177: LD_INT 175
13179: PPUSH
13180: CALL_OW 67
// if not masha_killed then
13184: LD_EXP 10
13188: NOT
13189: IFFALSE 13211
// begin m1 := true ;
13191: LD_ADDR_VAR 0 4
13195: PUSH
13196: LD_INT 1
13198: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
13199: LD_STRING Masha
13201: PPUSH
13202: LD_INT 1
13204: PPUSH
13205: CALL_OW 101
// end else
13209: GO 13222
// AddMedal ( Masha , - 1 ) ;
13211: LD_STRING Masha
13213: PPUSH
13214: LD_INT 1
13216: NEG
13217: PPUSH
13218: CALL_OW 101
// if abdul_escaped then
13222: LD_EXP 13
13226: IFFALSE 13241
// AddMedal ( Abdul , - 1 ) else
13228: LD_STRING Abdul
13230: PPUSH
13231: LD_INT 1
13233: NEG
13234: PPUSH
13235: CALL_OW 101
13239: GO 13259
// begin m2 := true ;
13241: LD_ADDR_VAR 0 5
13245: PUSH
13246: LD_INT 1
13248: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
13249: LD_STRING Abdul
13251: PPUSH
13252: LD_INT 1
13254: PPUSH
13255: CALL_OW 101
// end ; if loss_counter = 0 then
13259: LD_EXP 14
13263: PUSH
13264: LD_INT 0
13266: EQUAL
13267: IFFALSE 13289
// begin m3 := true ;
13269: LD_ADDR_VAR 0 6
13273: PUSH
13274: LD_INT 1
13276: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
13277: LD_STRING People
13279: PPUSH
13280: LD_INT 2
13282: PPUSH
13283: CALL_OW 101
// end else
13287: GO 13351
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
13289: LD_EXP 14
13293: PUSH
13294: LD_INT 3
13296: PUSH
13297: LD_INT 2
13299: PUSH
13300: LD_INT 2
13302: PUSH
13303: LD_INT 1
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: PUSH
13312: LD_OWVAR 67
13316: ARRAY
13317: LESSEQUAL
13318: IFFALSE 13340
// begin AddMedal ( People , 1 ) ;
13320: LD_STRING People
13322: PPUSH
13323: LD_INT 1
13325: PPUSH
13326: CALL_OW 101
// m3 := true ;
13330: LD_ADDR_VAR 0 6
13334: PUSH
13335: LD_INT 1
13337: ST_TO_ADDR
// end else
13338: GO 13351
// AddMedal ( People , - 1 ) ;
13340: LD_STRING People
13342: PPUSH
13343: LD_INT 1
13345: NEG
13346: PPUSH
13347: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
13351: LD_OWVAR 67
13355: PUSH
13356: LD_INT 3
13358: GREATEREQUAL
13359: PUSH
13360: LD_VAR 0 4
13364: AND
13365: PUSH
13366: LD_VAR 0 5
13370: AND
13371: PUSH
13372: LD_VAR 0 6
13376: AND
13377: IFFALSE 13389
// SetAchievementEX ( ACH_AMER , 17 ) ;
13379: LD_STRING ACH_AMER
13381: PPUSH
13382: LD_INT 17
13384: PPUSH
13385: CALL_OW 564
// GiveMedals ( MAIN ) ;
13389: LD_STRING MAIN
13391: PPUSH
13392: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13396: LD_ADDR_VAR 0 2
13400: PUSH
13401: LD_INT 22
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PUSH
13411: LD_INT 50
13413: PUSH
13414: EMPTY
13415: LIST
13416: PUSH
13417: LD_INT 2
13419: PUSH
13420: LD_INT 25
13422: PUSH
13423: LD_INT 1
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PUSH
13430: LD_INT 25
13432: PUSH
13433: LD_INT 2
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PUSH
13440: LD_INT 25
13442: PUSH
13443: LD_INT 3
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 25
13452: PUSH
13453: LD_INT 4
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: LD_INT 25
13462: PUSH
13463: LD_INT 5
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 25
13472: PUSH
13473: LD_INT 8
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 25
13482: PUSH
13483: LD_INT 9
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: LIST
13497: LIST
13498: LIST
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: LIST
13504: PPUSH
13505: CALL_OW 69
13509: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13510: LD_VAR 0 2
13514: PPUSH
13515: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13519: LD_ADDR_VAR 0 3
13523: PUSH
13524: LD_EXP 16
13528: PUSH
13529: LD_EXP 17
13533: PUSH
13534: LD_EXP 18
13538: PUSH
13539: LD_EXP 19
13543: PUSH
13544: LD_EXP 20
13548: PUSH
13549: LD_EXP 21
13553: PUSH
13554: LD_EXP 22
13558: PUSH
13559: LD_EXP 23
13563: PUSH
13564: LD_EXP 24
13568: PUSH
13569: LD_EXP 25
13573: PUSH
13574: LD_EXP 26
13578: PUSH
13579: LD_EXP 27
13583: PUSH
13584: LD_EXP 28
13588: PUSH
13589: LD_EXP 29
13593: PUSH
13594: LD_EXP 30
13598: PUSH
13599: LD_EXP 31
13603: PUSH
13604: LD_EXP 32
13608: PUSH
13609: LD_EXP 34
13613: PUSH
13614: LD_EXP 35
13618: PUSH
13619: LD_EXP 36
13623: PUSH
13624: LD_EXP 38
13628: PUSH
13629: LD_EXP 39
13633: PUSH
13634: LD_EXP 40
13638: PUSH
13639: LD_EXP 41
13643: PUSH
13644: LD_EXP 42
13648: PUSH
13649: LD_EXP 43
13653: PUSH
13654: LD_EXP 44
13658: PUSH
13659: LD_EXP 45
13663: PUSH
13664: LD_EXP 46
13668: PUSH
13669: LD_EXP 47
13673: PUSH
13674: LD_EXP 48
13678: PUSH
13679: LD_EXP 49
13683: PUSH
13684: LD_EXP 50
13688: PUSH
13689: LD_EXP 33
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: ST_TO_ADDR
// if tmp diff tmp2 then
13730: LD_VAR 0 2
13734: PUSH
13735: LD_VAR 0 3
13739: DIFF
13740: IFFALSE 13760
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13742: LD_VAR 0 2
13746: PUSH
13747: LD_VAR 0 3
13751: DIFF
13752: PPUSH
13753: LD_STRING 13a_others
13755: PPUSH
13756: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13760: LD_EXP 16
13764: PPUSH
13765: LD_STRING 13a_JMM
13767: PPUSH
13768: CALL_OW 38
// if IsOk ( Mike ) then
13772: LD_EXP 33
13776: PPUSH
13777: CALL_OW 302
13781: IFFALSE 13795
// SaveCharacters ( Mike , 13a_Mike ) ;
13783: LD_EXP 33
13787: PPUSH
13788: LD_STRING 13a_Mike
13790: PPUSH
13791: CALL_OW 38
// if IsOk ( Titov ) then
13795: LD_EXP 36
13799: PPUSH
13800: CALL_OW 302
13804: IFFALSE 13818
// SaveCharacters ( Titov , 13a_Titov ) ;
13806: LD_EXP 36
13810: PPUSH
13811: LD_STRING 13a_Titov
13813: PPUSH
13814: CALL_OW 38
// if IsOk ( Dolgov ) then
13818: LD_EXP 38
13822: PPUSH
13823: CALL_OW 302
13827: IFFALSE 13841
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13829: LD_EXP 38
13833: PPUSH
13834: LD_STRING 13a_Dolgov
13836: PPUSH
13837: CALL_OW 38
// if IsOk ( Petrosyan ) then
13841: LD_EXP 39
13845: PPUSH
13846: CALL_OW 302
13850: IFFALSE 13864
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13852: LD_EXP 39
13856: PPUSH
13857: LD_STRING 13a_Petrosyan
13859: PPUSH
13860: CALL_OW 38
// if IsOk ( Scholtze ) then
13864: LD_EXP 40
13868: PPUSH
13869: CALL_OW 302
13873: IFFALSE 13887
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13875: LD_EXP 40
13879: PPUSH
13880: LD_STRING 13a_Scholtze
13882: PPUSH
13883: CALL_OW 38
// if IsOk ( Oblukov ) then
13887: LD_EXP 41
13891: PPUSH
13892: CALL_OW 302
13896: IFFALSE 13910
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13898: LD_EXP 41
13902: PPUSH
13903: LD_STRING 13a_Oblukov
13905: PPUSH
13906: CALL_OW 38
// if IsOk ( Kapitsova ) then
13910: LD_EXP 42
13914: PPUSH
13915: CALL_OW 302
13919: IFFALSE 13933
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13921: LD_EXP 42
13925: PPUSH
13926: LD_STRING 13a_Kapitsova
13928: PPUSH
13929: CALL_OW 38
// if IsOk ( Lipshchin ) then
13933: LD_EXP 43
13937: PPUSH
13938: CALL_OW 302
13942: IFFALSE 13956
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13944: LD_EXP 43
13948: PPUSH
13949: LD_STRING 13a_Lipshchin
13951: PPUSH
13952: CALL_OW 38
// if IsOk ( Petrovova ) then
13956: LD_EXP 44
13960: PPUSH
13961: CALL_OW 302
13965: IFFALSE 13979
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13967: LD_EXP 44
13971: PPUSH
13972: LD_STRING 13a_Petrovova
13974: PPUSH
13975: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13979: LD_EXP 45
13983: PPUSH
13984: CALL_OW 302
13988: IFFALSE 14002
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13990: LD_EXP 45
13994: PPUSH
13995: LD_STRING 13a_Kovalyuk
13997: PPUSH
13998: CALL_OW 38
// if IsOk ( Kuzmov ) then
14002: LD_EXP 46
14006: PPUSH
14007: CALL_OW 302
14011: IFFALSE 14025
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14013: LD_EXP 46
14017: PPUSH
14018: LD_STRING 13a_Kuzmov
14020: PPUSH
14021: CALL_OW 38
// if IsOk ( Karamazov ) then
14025: LD_EXP 47
14029: PPUSH
14030: CALL_OW 302
14034: IFFALSE 14048
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14036: LD_EXP 47
14040: PPUSH
14041: LD_STRING 13a_Karamazov
14043: PPUSH
14044: CALL_OW 38
// if Burlak then
14048: LD_EXP 48
14052: IFFALSE 14073
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14054: LD_STRING enableBioCharacter(BIO_GORKI)
14056: PPUSH
14057: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14061: LD_EXP 48
14065: PPUSH
14066: LD_STRING 13a_Burlak
14068: PPUSH
14069: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14073: LD_EXP 49
14077: PPUSH
14078: CALL_OW 302
14082: IFFALSE 14096
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14084: LD_EXP 49
14088: PPUSH
14089: LD_STRING 13a_Belkov
14091: PPUSH
14092: CALL_OW 38
// if IsOk ( Gnyevko ) then
14096: LD_EXP 50
14100: PPUSH
14101: CALL_OW 302
14105: IFFALSE 14119
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14107: LD_EXP 50
14111: PPUSH
14112: LD_STRING 13a_Gnyevko
14114: PPUSH
14115: CALL_OW 38
// if IsOk ( Lisa ) then
14119: LD_EXP 18
14123: PPUSH
14124: CALL_OW 302
14128: IFFALSE 14142
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14130: LD_EXP 18
14134: PPUSH
14135: LD_STRING 13a_Lisa
14137: PPUSH
14138: CALL_OW 38
// if IsOk ( Donaldson ) then
14142: LD_EXP 19
14146: PPUSH
14147: CALL_OW 302
14151: IFFALSE 14165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14153: LD_EXP 19
14157: PPUSH
14158: LD_STRING 13a_Donaldson
14160: PPUSH
14161: CALL_OW 38
// if IsOk ( Bobby ) then
14165: LD_EXP 20
14169: PPUSH
14170: CALL_OW 302
14174: IFFALSE 14188
// SaveCharacters ( Bobby , 13a_Bobby ) ;
14176: LD_EXP 20
14180: PPUSH
14181: LD_STRING 13a_Bobby
14183: PPUSH
14184: CALL_OW 38
// if IsOk ( Cyrus ) then
14188: LD_EXP 21
14192: PPUSH
14193: CALL_OW 302
14197: IFFALSE 14211
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
14199: LD_EXP 21
14203: PPUSH
14204: LD_STRING 13a_Cyrus
14206: PPUSH
14207: CALL_OW 38
// if IsOk ( Denis ) then
14211: LD_EXP 22
14215: PPUSH
14216: CALL_OW 302
14220: IFFALSE 14234
// SaveCharacters ( Denis , 13a_Denis ) ;
14222: LD_EXP 22
14226: PPUSH
14227: LD_STRING 13a_Denis
14229: PPUSH
14230: CALL_OW 38
// if IsOk ( Brown ) then
14234: LD_EXP 23
14238: PPUSH
14239: CALL_OW 302
14243: IFFALSE 14257
// SaveCharacters ( Brown , 13a_Brown ) ;
14245: LD_EXP 23
14249: PPUSH
14250: LD_STRING 13a_Brown
14252: PPUSH
14253: CALL_OW 38
// if IsOk ( Gladstone ) then
14257: LD_EXP 24
14261: PPUSH
14262: CALL_OW 302
14266: IFFALSE 14280
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
14268: LD_EXP 24
14272: PPUSH
14273: LD_STRING 13a_Gladstone
14275: PPUSH
14276: CALL_OW 38
// if IsOk ( Houten ) then
14280: LD_EXP 25
14284: PPUSH
14285: CALL_OW 302
14289: IFFALSE 14303
// SaveCharacters ( Houten , 13a_Houten ) ;
14291: LD_EXP 25
14295: PPUSH
14296: LD_STRING 13a_Houten
14298: PPUSH
14299: CALL_OW 38
// if IsOk ( Cornel ) then
14303: LD_EXP 26
14307: PPUSH
14308: CALL_OW 302
14312: IFFALSE 14326
// SaveCharacters ( Cornel , 13a_Cornel ) ;
14314: LD_EXP 26
14318: PPUSH
14319: LD_STRING 13a_Cornel
14321: PPUSH
14322: CALL_OW 38
// if IsOk ( Gary ) then
14326: LD_EXP 27
14330: PPUSH
14331: CALL_OW 302
14335: IFFALSE 14349
// SaveCharacters ( Gary , 13a_Gary ) ;
14337: LD_EXP 27
14341: PPUSH
14342: LD_STRING 13a_Gary
14344: PPUSH
14345: CALL_OW 38
// if IsOk ( Frank ) then
14349: LD_EXP 28
14353: PPUSH
14354: CALL_OW 302
14358: IFFALSE 14372
// SaveCharacters ( Frank , 13a_Frank ) ;
14360: LD_EXP 28
14364: PPUSH
14365: LD_STRING 13a_Frank
14367: PPUSH
14368: CALL_OW 38
// if IsOk ( Kikuchi ) then
14372: LD_EXP 29
14376: PPUSH
14377: CALL_OW 302
14381: IFFALSE 14395
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
14383: LD_EXP 29
14387: PPUSH
14388: LD_STRING 13a_Kikuchi
14390: PPUSH
14391: CALL_OW 38
// if IsOk ( Simms ) then
14395: LD_EXP 30
14399: PPUSH
14400: CALL_OW 302
14404: IFFALSE 14418
// SaveCharacters ( Simms , 13a_Simms ) ;
14406: LD_EXP 30
14410: PPUSH
14411: LD_STRING 13a_Simms
14413: PPUSH
14414: CALL_OW 38
// if IsOk ( Joan ) then
14418: LD_EXP 31
14422: PPUSH
14423: CALL_OW 302
14427: IFFALSE 14441
// SaveCharacters ( Joan , 13a_Joan ) ;
14429: LD_EXP 31
14433: PPUSH
14434: LD_STRING 13a_Joan
14436: PPUSH
14437: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14441: LD_EXP 32
14445: PPUSH
14446: CALL_OW 302
14450: IFFALSE 14464
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14452: LD_EXP 32
14456: PPUSH
14457: LD_STRING 13a_DeltaDoctor
14459: PPUSH
14460: CALL_OW 38
// if IsOk ( Gossudarov ) then
14464: LD_EXP 34
14468: PPUSH
14469: CALL_OW 302
14473: IFFALSE 14487
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14475: LD_EXP 34
14479: PPUSH
14480: LD_STRING 13a_Gossudarov
14482: PPUSH
14483: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14487: LD_EXP 35
14491: PPUSH
14492: CALL_OW 302
14496: IFFALSE 14510
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14498: LD_EXP 35
14502: PPUSH
14503: LD_STRING 13a_Kirilenkova
14505: PPUSH
14506: CALL_OW 38
// if IsOk ( Roth ) then
14510: LD_EXP 17
14514: PPUSH
14515: CALL_OW 302
14519: IFFALSE 14533
// SaveCharacters ( Roth , 13a_Roth ) ;
14521: LD_EXP 17
14525: PPUSH
14526: LD_STRING 13a_Roth
14528: PPUSH
14529: CALL_OW 38
// if Masha then
14533: LD_EXP 51
14537: IFFALSE 14592
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14539: LD_EXP 51
14543: PPUSH
14544: CALL_OW 265
14548: PUSH
14549: LD_EXP 51
14553: PPUSH
14554: CALL_OW 262
14558: PUSH
14559: LD_EXP 51
14563: PPUSH
14564: CALL_OW 263
14568: PUSH
14569: LD_EXP 51
14573: PPUSH
14574: CALL_OW 264
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: PPUSH
14585: LD_STRING 13a_Masha
14587: PPUSH
14588: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14592: LD_ADDR_VAR 0 2
14596: PUSH
14597: LD_INT 21
14599: PUSH
14600: LD_INT 3
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PPUSH
14607: CALL_OW 69
14611: ST_TO_ADDR
// tmp2 := [ ] ;
14612: LD_ADDR_VAR 0 3
14616: PUSH
14617: EMPTY
14618: ST_TO_ADDR
// if tmp then
14619: LD_VAR 0 2
14623: IFFALSE 14774
// for i in tmp do
14625: LD_ADDR_VAR 0 1
14629: PUSH
14630: LD_VAR 0 2
14634: PUSH
14635: FOR_IN
14636: IFFALSE 14772
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14638: LD_ADDR_VAR 0 3
14642: PUSH
14643: LD_VAR 0 3
14647: PUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 255
14657: PUSH
14658: LD_VAR 0 1
14662: PPUSH
14663: CALL_OW 248
14667: PUSH
14668: LD_VAR 0 1
14672: PPUSH
14673: CALL_OW 266
14677: PUSH
14678: LD_VAR 0 1
14682: PPUSH
14683: CALL_OW 250
14687: PUSH
14688: LD_VAR 0 1
14692: PPUSH
14693: CALL_OW 251
14697: PUSH
14698: LD_VAR 0 1
14702: PPUSH
14703: CALL_OW 254
14707: PUSH
14708: LD_VAR 0 1
14712: PPUSH
14713: CALL_OW 267
14717: PUSH
14718: LD_VAR 0 1
14722: PPUSH
14723: LD_INT 1
14725: PPUSH
14726: CALL_OW 268
14730: PUSH
14731: LD_VAR 0 1
14735: PPUSH
14736: LD_INT 2
14738: PPUSH
14739: CALL_OW 268
14743: PUSH
14744: LD_VAR 0 1
14748: PPUSH
14749: CALL_OW 269
14753: PUSH
14754: EMPTY
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: ADD
14769: ST_TO_ADDR
14770: GO 14635
14772: POP
14773: POP
// if tmp2 then
14774: LD_VAR 0 3
14778: IFFALSE 14792
// SaveVariable ( tmp2 , 13a_buildings ) ;
14780: LD_VAR 0 3
14784: PPUSH
14785: LD_STRING 13a_buildings
14787: PPUSH
14788: CALL_OW 39
// YouWin ;
14792: CALL_OW 103
// end ;
14796: PPOPN 6
14798: END
// export function SciRu ; var tmp , t ; begin
14799: LD_INT 0
14801: PPUSH
14802: PPUSH
14803: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14804: LD_ADDR_VAR 0 3
14808: PUSH
14809: LD_EXP 34
14813: PUSH
14814: LD_EXP 48
14818: PUSH
14819: LD_EXP 36
14823: PUSH
14824: LD_EXP 49
14828: PUSH
14829: LD_EXP 50
14833: PUSH
14834: LD_EXP 39
14838: PUSH
14839: LD_EXP 40
14843: PUSH
14844: LD_EXP 38
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14859: LD_ADDR_VAR 0 2
14863: PUSH
14864: LD_INT 22
14866: PUSH
14867: LD_INT 7
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 23
14876: PUSH
14877: LD_INT 3
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: LD_INT 25
14886: PUSH
14887: LD_INT 4
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: PUSH
14894: LD_INT 26
14896: PUSH
14897: LD_INT 1
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: PPUSH
14910: CALL_OW 69
14914: PUSH
14915: LD_VAR 0 3
14919: DIFF
14920: ST_TO_ADDR
// if tmp then
14921: LD_VAR 0 2
14925: IFFALSE 14941
// result := tmp [ 1 ] ;
14927: LD_ADDR_VAR 0 1
14931: PUSH
14932: LD_VAR 0 2
14936: PUSH
14937: LD_INT 1
14939: ARRAY
14940: ST_TO_ADDR
// end ;
14941: LD_VAR 0 1
14945: RET
// export function SolRu ; var tmp , t ; begin
14946: LD_INT 0
14948: PPUSH
14949: PPUSH
14950: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14951: LD_ADDR_VAR 0 3
14955: PUSH
14956: LD_EXP 34
14960: PUSH
14961: LD_EXP 48
14965: PUSH
14966: LD_EXP 36
14970: PUSH
14971: LD_EXP 49
14975: PUSH
14976: LD_EXP 50
14980: PUSH
14981: LD_EXP 39
14985: PUSH
14986: LD_EXP 40
14990: PUSH
14991: LD_EXP 38
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15006: LD_ADDR_VAR 0 2
15010: PUSH
15011: LD_INT 22
15013: PUSH
15014: LD_INT 7
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: PUSH
15021: LD_INT 23
15023: PUSH
15024: LD_INT 3
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 25
15033: PUSH
15034: LD_INT 1
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: LD_INT 26
15043: PUSH
15044: LD_INT 1
15046: PUSH
15047: EMPTY
15048: LIST
15049: LIST
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: PPUSH
15057: CALL_OW 69
15061: PUSH
15062: LD_VAR 0 3
15066: DIFF
15067: ST_TO_ADDR
// if tmp then
15068: LD_VAR 0 2
15072: IFFALSE 15088
// result := tmp [ 1 ] ;
15074: LD_ADDR_VAR 0 1
15078: PUSH
15079: LD_VAR 0 2
15083: PUSH
15084: LD_INT 1
15086: ARRAY
15087: ST_TO_ADDR
// end ; end_of_file
15088: LD_VAR 0 1
15092: RET
// export function CustomEvent ( event ) ; begin
15093: LD_INT 0
15095: PPUSH
// end ;
15096: LD_VAR 0 2
15100: RET
// on UnitDestroyed ( un ) do var i , side ;
15101: LD_INT 0
15103: PPUSH
15104: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15105: LD_VAR 0 1
15109: PPUSH
15110: CALL 105743 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15114: LD_VAR 0 1
15118: PUSH
15119: LD_INT 22
15121: PUSH
15122: LD_INT 7
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 2
15131: PUSH
15132: LD_INT 25
15134: PUSH
15135: LD_INT 1
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 25
15144: PUSH
15145: LD_INT 2
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: LD_INT 25
15154: PUSH
15155: LD_INT 3
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: PUSH
15162: LD_INT 25
15164: PUSH
15165: LD_INT 4
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: LD_INT 25
15174: PUSH
15175: LD_INT 5
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: PUSH
15182: LD_INT 25
15184: PUSH
15185: LD_INT 8
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PUSH
15192: LD_INT 25
15194: PUSH
15195: LD_INT 9
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: PPUSH
15216: CALL_OW 69
15220: IN
15221: IFFALSE 15237
// loss_counter := loss_counter + 1 ;
15223: LD_ADDR_EXP 14
15227: PUSH
15228: LD_EXP 14
15232: PUSH
15233: LD_INT 1
15235: PLUS
15236: ST_TO_ADDR
// if un = Abdul then
15237: LD_VAR 0 1
15241: PUSH
15242: LD_EXP 57
15246: EQUAL
15247: IFFALSE 15257
// abdul_escaped := false ;
15249: LD_ADDR_EXP 13
15253: PUSH
15254: LD_INT 0
15256: ST_TO_ADDR
// if un in ru_attackers then
15257: LD_VAR 0 1
15261: PUSH
15262: LD_EXP 54
15266: IN
15267: IFFALSE 15285
// ru_attackers := ru_attackers diff un ;
15269: LD_ADDR_EXP 54
15273: PUSH
15274: LD_EXP 54
15278: PUSH
15279: LD_VAR 0 1
15283: DIFF
15284: ST_TO_ADDR
// if un in ar_attackers then
15285: LD_VAR 0 1
15289: PUSH
15290: LD_EXP 11
15294: IN
15295: IFFALSE 15313
// ar_attackers := ar_attackers diff un ;
15297: LD_ADDR_EXP 11
15301: PUSH
15302: LD_EXP 11
15306: PUSH
15307: LD_VAR 0 1
15311: DIFF
15312: ST_TO_ADDR
// if un = JMM then
15313: LD_VAR 0 1
15317: PUSH
15318: LD_EXP 16
15322: EQUAL
15323: IFFALSE 15334
// begin YouLost ( JMM ) ;
15325: LD_STRING JMM
15327: PPUSH
15328: CALL_OW 104
// exit ;
15332: GO 15431
// end ; if un = Burlak then
15334: LD_VAR 0 1
15338: PUSH
15339: LD_EXP 48
15343: EQUAL
15344: IFFALSE 15355
// begin YouLost ( Burlak ) ;
15346: LD_STRING Burlak
15348: PPUSH
15349: CALL_OW 104
// exit ;
15353: GO 15431
// end ; if un = freedom then
15355: LD_VAR 0 1
15359: PUSH
15360: LD_EXP 3
15364: EQUAL
15365: IFFALSE 15376
// begin YouLost ( Destroyed ) ;
15367: LD_STRING Destroyed
15369: PPUSH
15370: CALL_OW 104
// exit ;
15374: GO 15431
// end ; if un = Masha then
15376: LD_VAR 0 1
15380: PUSH
15381: LD_EXP 51
15385: EQUAL
15386: IFFALSE 15403
// begin ChangeMissionObjectives ( M4b ) ;
15388: LD_STRING M4b
15390: PPUSH
15391: CALL_OW 337
// masha_killed := true ;
15395: LD_ADDR_EXP 10
15399: PUSH
15400: LD_INT 1
15402: ST_TO_ADDR
// end ; if un = Mastodont then
15403: LD_VAR 0 1
15407: PUSH
15408: LD_EXP 58
15412: EQUAL
15413: IFFALSE 15422
// ChangeMissionObjectives ( M4a ) ;
15415: LD_STRING M4a
15417: PPUSH
15418: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15422: LD_VAR 0 1
15426: PPUSH
15427: CALL 86940 0 1
// end ;
15431: PPOPN 3
15433: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15434: LD_VAR 0 1
15438: PPUSH
15439: LD_VAR 0 2
15443: PPUSH
15444: CALL 89272 0 2
// end ;
15448: PPOPN 2
15450: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15451: LD_VAR 0 1
15455: PPUSH
15456: CALL 88340 0 1
// end ;
15460: PPOPN 1
15462: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15463: LD_VAR 0 1
15467: PUSH
15468: LD_INT 22
15470: PUSH
15471: LD_INT 7
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: LD_INT 30
15480: PUSH
15481: LD_INT 0
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PPUSH
15492: CALL_OW 69
15496: IN
15497: IFFALSE 15536
// begin SetBName ( building , freedom ) ;
15499: LD_VAR 0 1
15503: PPUSH
15504: LD_STRING freedom
15506: PPUSH
15507: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15511: LD_INT 0
15513: PPUSH
15514: LD_INT 7
15516: PPUSH
15517: LD_INT 0
15519: PPUSH
15520: CALL_OW 324
// freedom := building ;
15524: LD_ADDR_EXP 3
15528: PUSH
15529: LD_VAR 0 1
15533: ST_TO_ADDR
// exit ;
15534: GO 15602
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15536: LD_VAR 0 1
15540: PUSH
15541: LD_INT 22
15543: PUSH
15544: LD_INT 7
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PUSH
15551: LD_INT 23
15553: PUSH
15554: LD_INT 3
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 30
15563: PUSH
15564: LD_INT 6
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: LIST
15575: PPUSH
15576: CALL_OW 69
15580: IN
15581: IFFALSE 15593
// begin ru_lab_builded := true ;
15583: LD_ADDR_EXP 5
15587: PUSH
15588: LD_INT 1
15590: ST_TO_ADDR
// exit ;
15591: GO 15602
// end ; MCE_BuildingComplete ( building ) ;
15593: LD_VAR 0 1
15597: PPUSH
15598: CALL 88581 0 1
// end ;
15602: PPOPN 1
15604: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_VAR 0 2
15614: PPUSH
15615: CALL 86636 0 2
// end ;
15619: PPOPN 2
15621: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15622: LD_VAR 0 1
15626: PPUSH
15627: LD_VAR 0 2
15631: PPUSH
15632: LD_VAR 0 3
15636: PPUSH
15637: LD_VAR 0 4
15641: PPUSH
15642: LD_VAR 0 5
15646: PPUSH
15647: CALL 86256 0 5
// end ;
15651: PPOPN 5
15653: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15654: LD_VAR 0 1
15658: PPUSH
15659: LD_VAR 0 2
15663: PPUSH
15664: CALL 105863 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15668: LD_VAR 0 1
15672: PPUSH
15673: LD_VAR 0 2
15677: PPUSH
15678: CALL 85809 0 2
// end ;
15682: PPOPN 2
15684: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15685: LD_VAR 0 1
15689: PPUSH
15690: CALL_OW 263
15694: PUSH
15695: LD_INT 3
15697: EQUAL
15698: PUSH
15699: LD_VAR 0 2
15703: PPUSH
15704: CALL_OW 263
15708: PUSH
15709: LD_INT 3
15711: EQUAL
15712: OR
15713: IFFALSE 15729
// hack_counter := hack_counter + 1 ;
15715: LD_ADDR_EXP 15
15719: PUSH
15720: LD_EXP 15
15724: PUSH
15725: LD_INT 1
15727: PLUS
15728: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: LD_VAR 0 2
15738: PPUSH
15739: LD_VAR 0 3
15743: PPUSH
15744: LD_VAR 0 4
15748: PPUSH
15749: CALL 85647 0 4
// end ;
15753: PPOPN 4
15755: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
15756: LD_VAR 0 1
15760: PUSH
15761: LD_INT 47
15763: EQUAL
15764: IFFALSE 15786
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
15766: LD_VAR 0 1
15770: PPUSH
15771: CALL_OW 274
15775: PPUSH
15776: LD_INT 1
15778: PPUSH
15779: LD_INT 600
15781: PPUSH
15782: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15786: LD_VAR 0 1
15790: PPUSH
15791: LD_VAR 0 2
15795: PPUSH
15796: LD_VAR 0 3
15800: PPUSH
15801: CALL 85422 0 3
// end ;
15805: PPOPN 3
15807: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15808: LD_VAR 0 1
15812: PPUSH
15813: LD_VAR 0 2
15817: PPUSH
15818: CALL 85307 0 2
// end ;
15822: PPOPN 2
15824: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 2
15834: PPUSH
15835: CALL 89567 0 2
// end ;
15839: PPOPN 2
15841: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15842: LD_VAR 0 1
15846: PPUSH
15847: LD_VAR 0 2
15851: PPUSH
15852: LD_VAR 0 3
15856: PPUSH
15857: LD_VAR 0 4
15861: PPUSH
15862: CALL 89783 0 4
// end ;
15866: PPOPN 4
15868: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15869: LD_VAR 0 1
15873: PPUSH
15874: LD_VAR 0 2
15878: PPUSH
15879: CALL 85116 0 2
// end ;
15883: PPOPN 2
15885: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15886: LD_VAR 0 1
15890: PPUSH
15891: CALL 105847 0 1
// end ; end_of_file
15895: PPOPN 1
15897: END
// every 0 0$30 do var cr , time ;
15898: GO 15900
15900: DISABLE
15901: LD_INT 0
15903: PPUSH
15904: PPUSH
// begin time := 0 0$20 ;
15905: LD_ADDR_VAR 0 2
15909: PUSH
15910: LD_INT 700
15912: ST_TO_ADDR
// while game do
15913: LD_EXP 2
15917: IFFALSE 16020
// begin wait ( time ) ;
15919: LD_VAR 0 2
15923: PPUSH
15924: CALL_OW 67
// if tick > 2 2$00 then
15928: LD_OWVAR 1
15932: PUSH
15933: LD_INT 4200
15935: GREATER
15936: IFFALSE 15973
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15938: LD_ADDR_VAR 0 2
15942: PUSH
15943: LD_VAR 0 2
15947: PUSH
15948: LD_INT 140
15950: PUSH
15951: LD_INT 140
15953: PUSH
15954: LD_INT 210
15956: PUSH
15957: LD_INT 280
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: LIST
15964: LIST
15965: PUSH
15966: LD_OWVAR 67
15970: ARRAY
15971: PLUS
15972: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15973: LD_INT 1
15975: PPUSH
15976: LD_INT 5
15978: PPUSH
15979: CALL_OW 12
15983: PPUSH
15984: LD_INT 70
15986: PPUSH
15987: LD_INT 49
15989: PPUSH
15990: LD_INT 25
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: CALL_OW 56
// if time > 3 3$00 then
16000: LD_VAR 0 2
16004: PUSH
16005: LD_INT 6300
16007: GREATER
16008: IFFALSE 16018
// time := 0 0$30 ;
16010: LD_ADDR_VAR 0 2
16014: PUSH
16015: LD_INT 1050
16017: ST_TO_ADDR
// end ;
16018: GO 15913
// end ;
16020: PPOPN 2
16022: END
// every 0 0$30 do var cr , time ;
16023: GO 16025
16025: DISABLE
16026: LD_INT 0
16028: PPUSH
16029: PPUSH
// begin time := 0 0$20 ;
16030: LD_ADDR_VAR 0 2
16034: PUSH
16035: LD_INT 700
16037: ST_TO_ADDR
// while game do
16038: LD_EXP 2
16042: IFFALSE 16135
// begin wait ( time ) ;
16044: LD_VAR 0 2
16048: PPUSH
16049: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16053: LD_ADDR_VAR 0 2
16057: PUSH
16058: LD_VAR 0 2
16062: PUSH
16063: LD_INT 140
16065: PUSH
16066: LD_INT 175
16068: PUSH
16069: LD_INT 210
16071: PUSH
16072: LD_INT 280
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: PUSH
16081: LD_OWVAR 67
16085: ARRAY
16086: PLUS
16087: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16088: LD_INT 3
16090: PPUSH
16091: LD_INT 5
16093: PPUSH
16094: CALL_OW 12
16098: PPUSH
16099: LD_INT 26
16101: PPUSH
16102: LD_INT 9
16104: PPUSH
16105: LD_INT 30
16107: PPUSH
16108: LD_INT 1
16110: PPUSH
16111: CALL_OW 56
// if time > 3 3$00 then
16115: LD_VAR 0 2
16119: PUSH
16120: LD_INT 6300
16122: GREATER
16123: IFFALSE 16133
// time := 0 0$20 ;
16125: LD_ADDR_VAR 0 2
16129: PUSH
16130: LD_INT 700
16132: ST_TO_ADDR
// end ;
16133: GO 16038
// end ;
16135: PPOPN 2
16137: END
// every 0 0$30 do var cr , time ;
16138: GO 16140
16140: DISABLE
16141: LD_INT 0
16143: PPUSH
16144: PPUSH
// begin time := 0 0$20 ;
16145: LD_ADDR_VAR 0 2
16149: PUSH
16150: LD_INT 700
16152: ST_TO_ADDR
// while game do
16153: LD_EXP 2
16157: IFFALSE 16286
// begin wait ( time ) ;
16159: LD_VAR 0 2
16163: PPUSH
16164: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16168: LD_ADDR_VAR 0 2
16172: PUSH
16173: LD_VAR 0 2
16177: PUSH
16178: LD_INT 175
16180: PUSH
16181: LD_INT 210
16183: PUSH
16184: LD_INT 280
16186: PUSH
16187: LD_INT 350
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: LIST
16194: LIST
16195: PUSH
16196: LD_OWVAR 67
16200: ARRAY
16201: PLUS
16202: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
16203: LD_INT 1
16205: PPUSH
16206: LD_INT 5
16208: PPUSH
16209: CALL_OW 12
16213: PPUSH
16214: LD_INT 179
16216: PPUSH
16217: LD_INT 101
16219: PPUSH
16220: LD_INT 20
16222: PPUSH
16223: LD_INT 1
16225: PPUSH
16226: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16230: LD_INT 350
16232: PPUSH
16233: LD_INT 525
16235: PPUSH
16236: CALL_OW 12
16240: PPUSH
16241: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
16245: LD_INT 1
16247: PPUSH
16248: LD_INT 5
16250: PPUSH
16251: CALL_OW 12
16255: PPUSH
16256: LD_INT 9
16258: PPUSH
16259: LD_INT 1
16261: PPUSH
16262: CALL_OW 55
// if time > 4 4$00 then
16266: LD_VAR 0 2
16270: PUSH
16271: LD_INT 8400
16273: GREATER
16274: IFFALSE 16284
// time := 0 0$30 ;
16276: LD_ADDR_VAR 0 2
16280: PUSH
16281: LD_INT 1050
16283: ST_TO_ADDR
// end ;
16284: GO 16153
// end ;
16286: PPOPN 2
16288: END
// every 0 0$30 do var cr , time ;
16289: GO 16291
16291: DISABLE
16292: LD_INT 0
16294: PPUSH
16295: PPUSH
// begin time := 0 0$10 ;
16296: LD_ADDR_VAR 0 2
16300: PUSH
16301: LD_INT 350
16303: ST_TO_ADDR
// while game do
16304: LD_EXP 2
16308: IFFALSE 16442
// begin wait ( time ) ;
16310: LD_VAR 0 2
16314: PPUSH
16315: CALL_OW 67
// time := time + 0 0$10 ;
16319: LD_ADDR_VAR 0 2
16323: PUSH
16324: LD_VAR 0 2
16328: PUSH
16329: LD_INT 350
16331: PLUS
16332: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
16333: LD_INT 1
16335: PPUSH
16336: LD_INT 5
16338: PPUSH
16339: CALL_OW 12
16343: PPUSH
16344: LD_INT 11
16346: PPUSH
16347: LD_INT 1
16349: PPUSH
16350: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
16354: LD_ADDR_VAR 0 1
16358: PUSH
16359: LD_INT 1
16361: PPUSH
16362: LD_INT 3
16364: PPUSH
16365: CALL_OW 12
16369: ST_TO_ADDR
// if cr = 1 then
16370: LD_VAR 0 1
16374: PUSH
16375: LD_INT 1
16377: EQUAL
16378: IFFALSE 16422
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
16380: LD_INT 700
16382: PPUSH
16383: LD_INT 1575
16385: PPUSH
16386: CALL_OW 12
16390: PPUSH
16391: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
16395: LD_INT 1
16397: PPUSH
16398: LD_INT 5
16400: PPUSH
16401: CALL_OW 12
16405: PPUSH
16406: LD_INT 34
16408: PPUSH
16409: LD_INT 50
16411: PPUSH
16412: LD_INT 7
16414: PPUSH
16415: LD_INT 1
16417: PPUSH
16418: CALL_OW 56
// end ; if time > 4 4$00 then
16422: LD_VAR 0 2
16426: PUSH
16427: LD_INT 8400
16429: GREATER
16430: IFFALSE 16440
// time := 0 0$40 ;
16432: LD_ADDR_VAR 0 2
16436: PUSH
16437: LD_INT 1400
16439: ST_TO_ADDR
// end ;
16440: GO 16304
// end ; end_of_file
16442: PPOPN 2
16444: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16445: LD_INT 0
16447: PPUSH
16448: PPUSH
// if exist_mode then
16449: LD_VAR 0 2
16453: IFFALSE 16478
// unit := CreateCharacter ( prefix & ident ) else
16455: LD_ADDR_VAR 0 5
16459: PUSH
16460: LD_VAR 0 3
16464: PUSH
16465: LD_VAR 0 1
16469: STR
16470: PPUSH
16471: CALL_OW 34
16475: ST_TO_ADDR
16476: GO 16493
// unit := NewCharacter ( ident ) ;
16478: LD_ADDR_VAR 0 5
16482: PUSH
16483: LD_VAR 0 1
16487: PPUSH
16488: CALL_OW 25
16492: ST_TO_ADDR
// result := unit ;
16493: LD_ADDR_VAR 0 4
16497: PUSH
16498: LD_VAR 0 5
16502: ST_TO_ADDR
// end ;
16503: LD_VAR 0 4
16507: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16508: LD_INT 0
16510: PPUSH
16511: PPUSH
// if not side or not nation then
16512: LD_VAR 0 1
16516: NOT
16517: PUSH
16518: LD_VAR 0 2
16522: NOT
16523: OR
16524: IFFALSE 16528
// exit ;
16526: GO 17296
// case nation of nation_american :
16528: LD_VAR 0 2
16532: PUSH
16533: LD_INT 1
16535: DOUBLE
16536: EQUAL
16537: IFTRUE 16541
16539: GO 16755
16541: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16542: LD_ADDR_VAR 0 4
16546: PUSH
16547: LD_INT 35
16549: PUSH
16550: LD_INT 45
16552: PUSH
16553: LD_INT 46
16555: PUSH
16556: LD_INT 47
16558: PUSH
16559: LD_INT 82
16561: PUSH
16562: LD_INT 83
16564: PUSH
16565: LD_INT 84
16567: PUSH
16568: LD_INT 85
16570: PUSH
16571: LD_INT 86
16573: PUSH
16574: LD_INT 1
16576: PUSH
16577: LD_INT 2
16579: PUSH
16580: LD_INT 6
16582: PUSH
16583: LD_INT 15
16585: PUSH
16586: LD_INT 16
16588: PUSH
16589: LD_INT 7
16591: PUSH
16592: LD_INT 12
16594: PUSH
16595: LD_INT 13
16597: PUSH
16598: LD_INT 10
16600: PUSH
16601: LD_INT 14
16603: PUSH
16604: LD_INT 20
16606: PUSH
16607: LD_INT 21
16609: PUSH
16610: LD_INT 22
16612: PUSH
16613: LD_INT 25
16615: PUSH
16616: LD_INT 32
16618: PUSH
16619: LD_INT 27
16621: PUSH
16622: LD_INT 36
16624: PUSH
16625: LD_INT 69
16627: PUSH
16628: LD_INT 39
16630: PUSH
16631: LD_INT 34
16633: PUSH
16634: LD_INT 40
16636: PUSH
16637: LD_INT 48
16639: PUSH
16640: LD_INT 49
16642: PUSH
16643: LD_INT 50
16645: PUSH
16646: LD_INT 51
16648: PUSH
16649: LD_INT 52
16651: PUSH
16652: LD_INT 53
16654: PUSH
16655: LD_INT 54
16657: PUSH
16658: LD_INT 55
16660: PUSH
16661: LD_INT 56
16663: PUSH
16664: LD_INT 57
16666: PUSH
16667: LD_INT 58
16669: PUSH
16670: LD_INT 59
16672: PUSH
16673: LD_INT 60
16675: PUSH
16676: LD_INT 61
16678: PUSH
16679: LD_INT 62
16681: PUSH
16682: LD_INT 80
16684: PUSH
16685: LD_INT 82
16687: PUSH
16688: LD_INT 83
16690: PUSH
16691: LD_INT 84
16693: PUSH
16694: LD_INT 85
16696: PUSH
16697: LD_INT 86
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: LIST
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: LIST
16734: LIST
16735: LIST
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: LIST
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: ST_TO_ADDR
16753: GO 17220
16755: LD_INT 2
16757: DOUBLE
16758: EQUAL
16759: IFTRUE 16763
16761: GO 16989
16763: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16764: LD_ADDR_VAR 0 4
16768: PUSH
16769: LD_INT 35
16771: PUSH
16772: LD_INT 45
16774: PUSH
16775: LD_INT 46
16777: PUSH
16778: LD_INT 47
16780: PUSH
16781: LD_INT 82
16783: PUSH
16784: LD_INT 83
16786: PUSH
16787: LD_INT 84
16789: PUSH
16790: LD_INT 85
16792: PUSH
16793: LD_INT 87
16795: PUSH
16796: LD_INT 70
16798: PUSH
16799: LD_INT 1
16801: PUSH
16802: LD_INT 11
16804: PUSH
16805: LD_INT 3
16807: PUSH
16808: LD_INT 4
16810: PUSH
16811: LD_INT 5
16813: PUSH
16814: LD_INT 6
16816: PUSH
16817: LD_INT 15
16819: PUSH
16820: LD_INT 18
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: LD_INT 17
16828: PUSH
16829: LD_INT 8
16831: PUSH
16832: LD_INT 20
16834: PUSH
16835: LD_INT 21
16837: PUSH
16838: LD_INT 22
16840: PUSH
16841: LD_INT 72
16843: PUSH
16844: LD_INT 26
16846: PUSH
16847: LD_INT 69
16849: PUSH
16850: LD_INT 39
16852: PUSH
16853: LD_INT 40
16855: PUSH
16856: LD_INT 41
16858: PUSH
16859: LD_INT 42
16861: PUSH
16862: LD_INT 43
16864: PUSH
16865: LD_INT 48
16867: PUSH
16868: LD_INT 49
16870: PUSH
16871: LD_INT 50
16873: PUSH
16874: LD_INT 51
16876: PUSH
16877: LD_INT 52
16879: PUSH
16880: LD_INT 53
16882: PUSH
16883: LD_INT 54
16885: PUSH
16886: LD_INT 55
16888: PUSH
16889: LD_INT 56
16891: PUSH
16892: LD_INT 60
16894: PUSH
16895: LD_INT 61
16897: PUSH
16898: LD_INT 62
16900: PUSH
16901: LD_INT 66
16903: PUSH
16904: LD_INT 67
16906: PUSH
16907: LD_INT 68
16909: PUSH
16910: LD_INT 81
16912: PUSH
16913: LD_INT 82
16915: PUSH
16916: LD_INT 83
16918: PUSH
16919: LD_INT 84
16921: PUSH
16922: LD_INT 85
16924: PUSH
16925: LD_INT 87
16927: PUSH
16928: LD_INT 88
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: LIST
16969: LIST
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: LIST
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: ST_TO_ADDR
16987: GO 17220
16989: LD_INT 3
16991: DOUBLE
16992: EQUAL
16993: IFTRUE 16997
16995: GO 17219
16997: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16998: LD_ADDR_VAR 0 4
17002: PUSH
17003: LD_INT 46
17005: PUSH
17006: LD_INT 47
17008: PUSH
17009: LD_INT 1
17011: PUSH
17012: LD_INT 2
17014: PUSH
17015: LD_INT 82
17017: PUSH
17018: LD_INT 83
17020: PUSH
17021: LD_INT 84
17023: PUSH
17024: LD_INT 85
17026: PUSH
17027: LD_INT 86
17029: PUSH
17030: LD_INT 11
17032: PUSH
17033: LD_INT 9
17035: PUSH
17036: LD_INT 20
17038: PUSH
17039: LD_INT 19
17041: PUSH
17042: LD_INT 21
17044: PUSH
17045: LD_INT 24
17047: PUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 25
17053: PUSH
17054: LD_INT 28
17056: PUSH
17057: LD_INT 29
17059: PUSH
17060: LD_INT 30
17062: PUSH
17063: LD_INT 31
17065: PUSH
17066: LD_INT 37
17068: PUSH
17069: LD_INT 38
17071: PUSH
17072: LD_INT 32
17074: PUSH
17075: LD_INT 27
17077: PUSH
17078: LD_INT 33
17080: PUSH
17081: LD_INT 69
17083: PUSH
17084: LD_INT 39
17086: PUSH
17087: LD_INT 34
17089: PUSH
17090: LD_INT 40
17092: PUSH
17093: LD_INT 71
17095: PUSH
17096: LD_INT 23
17098: PUSH
17099: LD_INT 44
17101: PUSH
17102: LD_INT 48
17104: PUSH
17105: LD_INT 49
17107: PUSH
17108: LD_INT 50
17110: PUSH
17111: LD_INT 51
17113: PUSH
17114: LD_INT 52
17116: PUSH
17117: LD_INT 53
17119: PUSH
17120: LD_INT 54
17122: PUSH
17123: LD_INT 55
17125: PUSH
17126: LD_INT 56
17128: PUSH
17129: LD_INT 57
17131: PUSH
17132: LD_INT 58
17134: PUSH
17135: LD_INT 59
17137: PUSH
17138: LD_INT 63
17140: PUSH
17141: LD_INT 64
17143: PUSH
17144: LD_INT 65
17146: PUSH
17147: LD_INT 82
17149: PUSH
17150: LD_INT 83
17152: PUSH
17153: LD_INT 84
17155: PUSH
17156: LD_INT 85
17158: PUSH
17159: LD_INT 86
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: ST_TO_ADDR
17217: GO 17220
17219: POP
// if state > - 1 and state < 3 then
17220: LD_VAR 0 3
17224: PUSH
17225: LD_INT 1
17227: NEG
17228: GREATER
17229: PUSH
17230: LD_VAR 0 3
17234: PUSH
17235: LD_INT 3
17237: LESS
17238: AND
17239: IFFALSE 17296
// for i in result do
17241: LD_ADDR_VAR 0 5
17245: PUSH
17246: LD_VAR 0 4
17250: PUSH
17251: FOR_IN
17252: IFFALSE 17294
// if GetTech ( i , side ) <> state then
17254: LD_VAR 0 5
17258: PPUSH
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL_OW 321
17268: PUSH
17269: LD_VAR 0 3
17273: NONEQUAL
17274: IFFALSE 17292
// result := result diff i ;
17276: LD_ADDR_VAR 0 4
17280: PUSH
17281: LD_VAR 0 4
17285: PUSH
17286: LD_VAR 0 5
17290: DIFF
17291: ST_TO_ADDR
17292: GO 17251
17294: POP
17295: POP
// end ;
17296: LD_VAR 0 4
17300: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
17301: LD_INT 0
17303: PPUSH
17304: PPUSH
17305: PPUSH
// result := true ;
17306: LD_ADDR_VAR 0 3
17310: PUSH
17311: LD_INT 1
17313: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
17314: LD_ADDR_VAR 0 5
17318: PUSH
17319: LD_VAR 0 2
17323: PPUSH
17324: CALL_OW 480
17328: ST_TO_ADDR
// if not tmp then
17329: LD_VAR 0 5
17333: NOT
17334: IFFALSE 17338
// exit ;
17336: GO 17387
// for i in tmp do
17338: LD_ADDR_VAR 0 4
17342: PUSH
17343: LD_VAR 0 5
17347: PUSH
17348: FOR_IN
17349: IFFALSE 17385
// if GetTech ( i , side ) <> state_researched then
17351: LD_VAR 0 4
17355: PPUSH
17356: LD_VAR 0 1
17360: PPUSH
17361: CALL_OW 321
17365: PUSH
17366: LD_INT 2
17368: NONEQUAL
17369: IFFALSE 17383
// begin result := false ;
17371: LD_ADDR_VAR 0 3
17375: PUSH
17376: LD_INT 0
17378: ST_TO_ADDR
// exit ;
17379: POP
17380: POP
17381: GO 17387
// end ;
17383: GO 17348
17385: POP
17386: POP
// end ;
17387: LD_VAR 0 3
17391: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
17392: LD_INT 0
17394: PPUSH
17395: PPUSH
17396: PPUSH
17397: PPUSH
17398: PPUSH
17399: PPUSH
17400: PPUSH
17401: PPUSH
17402: PPUSH
17403: PPUSH
17404: PPUSH
17405: PPUSH
17406: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
17407: LD_VAR 0 1
17411: NOT
17412: PUSH
17413: LD_VAR 0 1
17417: PPUSH
17418: CALL_OW 257
17422: PUSH
17423: LD_INT 9
17425: NONEQUAL
17426: OR
17427: IFFALSE 17431
// exit ;
17429: GO 18004
// side := GetSide ( unit ) ;
17431: LD_ADDR_VAR 0 9
17435: PUSH
17436: LD_VAR 0 1
17440: PPUSH
17441: CALL_OW 255
17445: ST_TO_ADDR
// tech_space := tech_spacanom ;
17446: LD_ADDR_VAR 0 12
17450: PUSH
17451: LD_INT 29
17453: ST_TO_ADDR
// tech_time := tech_taurad ;
17454: LD_ADDR_VAR 0 13
17458: PUSH
17459: LD_INT 28
17461: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17462: LD_ADDR_VAR 0 11
17466: PUSH
17467: LD_VAR 0 1
17471: PPUSH
17472: CALL_OW 310
17476: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17477: LD_VAR 0 11
17481: PPUSH
17482: CALL_OW 247
17486: PUSH
17487: LD_INT 2
17489: EQUAL
17490: IFFALSE 17494
// exit ;
17492: GO 18004
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17494: LD_ADDR_VAR 0 8
17498: PUSH
17499: LD_INT 81
17501: PUSH
17502: LD_VAR 0 9
17506: PUSH
17507: EMPTY
17508: LIST
17509: LIST
17510: PUSH
17511: LD_INT 3
17513: PUSH
17514: LD_INT 21
17516: PUSH
17517: LD_INT 3
17519: PUSH
17520: EMPTY
17521: LIST
17522: LIST
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: PPUSH
17532: CALL_OW 69
17536: ST_TO_ADDR
// if not tmp then
17537: LD_VAR 0 8
17541: NOT
17542: IFFALSE 17546
// exit ;
17544: GO 18004
// if in_unit then
17546: LD_VAR 0 11
17550: IFFALSE 17574
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17552: LD_ADDR_VAR 0 10
17556: PUSH
17557: LD_VAR 0 8
17561: PPUSH
17562: LD_VAR 0 11
17566: PPUSH
17567: CALL_OW 74
17571: ST_TO_ADDR
17572: GO 17594
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17574: LD_ADDR_VAR 0 10
17578: PUSH
17579: LD_VAR 0 8
17583: PPUSH
17584: LD_VAR 0 1
17588: PPUSH
17589: CALL_OW 74
17593: ST_TO_ADDR
// if not enemy then
17594: LD_VAR 0 10
17598: NOT
17599: IFFALSE 17603
// exit ;
17601: GO 18004
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17603: LD_VAR 0 11
17607: PUSH
17608: LD_VAR 0 11
17612: PPUSH
17613: LD_VAR 0 10
17617: PPUSH
17618: CALL_OW 296
17622: PUSH
17623: LD_INT 13
17625: GREATER
17626: AND
17627: PUSH
17628: LD_VAR 0 1
17632: PPUSH
17633: LD_VAR 0 10
17637: PPUSH
17638: CALL_OW 296
17642: PUSH
17643: LD_INT 12
17645: GREATER
17646: OR
17647: IFFALSE 17651
// exit ;
17649: GO 18004
// missile := [ 1 ] ;
17651: LD_ADDR_VAR 0 14
17655: PUSH
17656: LD_INT 1
17658: PUSH
17659: EMPTY
17660: LIST
17661: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17662: LD_VAR 0 9
17666: PPUSH
17667: LD_VAR 0 12
17671: PPUSH
17672: CALL_OW 325
17676: IFFALSE 17705
// missile := Replace ( missile , missile + 1 , 2 ) ;
17678: LD_ADDR_VAR 0 14
17682: PUSH
17683: LD_VAR 0 14
17687: PPUSH
17688: LD_VAR 0 14
17692: PUSH
17693: LD_INT 1
17695: PLUS
17696: PPUSH
17697: LD_INT 2
17699: PPUSH
17700: CALL_OW 1
17704: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17705: LD_VAR 0 9
17709: PPUSH
17710: LD_VAR 0 13
17714: PPUSH
17715: CALL_OW 325
17719: PUSH
17720: LD_VAR 0 10
17724: PPUSH
17725: CALL_OW 255
17729: PPUSH
17730: LD_VAR 0 13
17734: PPUSH
17735: CALL_OW 325
17739: NOT
17740: AND
17741: IFFALSE 17770
// missile := Replace ( missile , missile + 1 , 3 ) ;
17743: LD_ADDR_VAR 0 14
17747: PUSH
17748: LD_VAR 0 14
17752: PPUSH
17753: LD_VAR 0 14
17757: PUSH
17758: LD_INT 1
17760: PLUS
17761: PPUSH
17762: LD_INT 3
17764: PPUSH
17765: CALL_OW 1
17769: ST_TO_ADDR
// if missile < 2 then
17770: LD_VAR 0 14
17774: PUSH
17775: LD_INT 2
17777: LESS
17778: IFFALSE 17782
// exit ;
17780: GO 18004
// x := GetX ( enemy ) ;
17782: LD_ADDR_VAR 0 4
17786: PUSH
17787: LD_VAR 0 10
17791: PPUSH
17792: CALL_OW 250
17796: ST_TO_ADDR
// y := GetY ( enemy ) ;
17797: LD_ADDR_VAR 0 5
17801: PUSH
17802: LD_VAR 0 10
17806: PPUSH
17807: CALL_OW 251
17811: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17812: LD_ADDR_VAR 0 6
17816: PUSH
17817: LD_VAR 0 4
17821: PUSH
17822: LD_INT 1
17824: NEG
17825: PPUSH
17826: LD_INT 1
17828: PPUSH
17829: CALL_OW 12
17833: PLUS
17834: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17835: LD_ADDR_VAR 0 7
17839: PUSH
17840: LD_VAR 0 5
17844: PUSH
17845: LD_INT 1
17847: NEG
17848: PPUSH
17849: LD_INT 1
17851: PPUSH
17852: CALL_OW 12
17856: PLUS
17857: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17858: LD_VAR 0 6
17862: PPUSH
17863: LD_VAR 0 7
17867: PPUSH
17868: CALL_OW 488
17872: NOT
17873: IFFALSE 17895
// begin _x := x ;
17875: LD_ADDR_VAR 0 6
17879: PUSH
17880: LD_VAR 0 4
17884: ST_TO_ADDR
// _y := y ;
17885: LD_ADDR_VAR 0 7
17889: PUSH
17890: LD_VAR 0 5
17894: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17895: LD_ADDR_VAR 0 3
17899: PUSH
17900: LD_INT 1
17902: PPUSH
17903: LD_VAR 0 14
17907: PPUSH
17908: CALL_OW 12
17912: ST_TO_ADDR
// case i of 1 :
17913: LD_VAR 0 3
17917: PUSH
17918: LD_INT 1
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17943
17926: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17927: LD_VAR 0 1
17931: PPUSH
17932: LD_VAR 0 10
17936: PPUSH
17937: CALL_OW 115
17941: GO 18004
17943: LD_INT 2
17945: DOUBLE
17946: EQUAL
17947: IFTRUE 17951
17949: GO 17973
17951: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17952: LD_VAR 0 1
17956: PPUSH
17957: LD_VAR 0 6
17961: PPUSH
17962: LD_VAR 0 7
17966: PPUSH
17967: CALL_OW 153
17971: GO 18004
17973: LD_INT 3
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 18003
17981: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17982: LD_VAR 0 1
17986: PPUSH
17987: LD_VAR 0 6
17991: PPUSH
17992: LD_VAR 0 7
17996: PPUSH
17997: CALL_OW 154
18001: GO 18004
18003: POP
// end ;
18004: LD_VAR 0 2
18008: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
18009: LD_INT 0
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
18015: PPUSH
18016: PPUSH
// if not unit or not building then
18017: LD_VAR 0 1
18021: NOT
18022: PUSH
18023: LD_VAR 0 2
18027: NOT
18028: OR
18029: IFFALSE 18033
// exit ;
18031: GO 18191
// x := GetX ( building ) ;
18033: LD_ADDR_VAR 0 5
18037: PUSH
18038: LD_VAR 0 2
18042: PPUSH
18043: CALL_OW 250
18047: ST_TO_ADDR
// y := GetY ( building ) ;
18048: LD_ADDR_VAR 0 6
18052: PUSH
18053: LD_VAR 0 2
18057: PPUSH
18058: CALL_OW 251
18062: ST_TO_ADDR
// for i = 0 to 5 do
18063: LD_ADDR_VAR 0 4
18067: PUSH
18068: DOUBLE
18069: LD_INT 0
18071: DEC
18072: ST_TO_ADDR
18073: LD_INT 5
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18189
// begin _x := ShiftX ( x , i , 3 ) ;
18079: LD_ADDR_VAR 0 7
18083: PUSH
18084: LD_VAR 0 5
18088: PPUSH
18089: LD_VAR 0 4
18093: PPUSH
18094: LD_INT 3
18096: PPUSH
18097: CALL_OW 272
18101: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18102: LD_ADDR_VAR 0 8
18106: PUSH
18107: LD_VAR 0 6
18111: PPUSH
18112: LD_VAR 0 4
18116: PPUSH
18117: LD_INT 3
18119: PPUSH
18120: CALL_OW 273
18124: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18125: LD_VAR 0 7
18129: PPUSH
18130: LD_VAR 0 8
18134: PPUSH
18135: CALL_OW 488
18139: NOT
18140: IFFALSE 18144
// continue ;
18142: GO 18076
// if HexInfo ( _x , _y ) = 0 then
18144: LD_VAR 0 7
18148: PPUSH
18149: LD_VAR 0 8
18153: PPUSH
18154: CALL_OW 428
18158: PUSH
18159: LD_INT 0
18161: EQUAL
18162: IFFALSE 18187
// begin ComMoveXY ( unit , _x , _y ) ;
18164: LD_VAR 0 1
18168: PPUSH
18169: LD_VAR 0 7
18173: PPUSH
18174: LD_VAR 0 8
18178: PPUSH
18179: CALL_OW 111
// exit ;
18183: POP
18184: POP
18185: GO 18191
// end ; end ;
18187: GO 18076
18189: POP
18190: POP
// end ;
18191: LD_VAR 0 3
18195: RET
// export function ScanBase ( side , base_area ) ; begin
18196: LD_INT 0
18198: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
18199: LD_ADDR_VAR 0 3
18203: PUSH
18204: LD_VAR 0 2
18208: PPUSH
18209: LD_INT 81
18211: PUSH
18212: LD_VAR 0 1
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: PPUSH
18221: CALL_OW 70
18225: ST_TO_ADDR
// end ;
18226: LD_VAR 0 3
18230: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18231: LD_INT 0
18233: PPUSH
18234: PPUSH
18235: PPUSH
18236: PPUSH
// result := false ;
18237: LD_ADDR_VAR 0 2
18241: PUSH
18242: LD_INT 0
18244: ST_TO_ADDR
// side := GetSide ( unit ) ;
18245: LD_ADDR_VAR 0 3
18249: PUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: CALL_OW 255
18259: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18260: LD_ADDR_VAR 0 4
18264: PUSH
18265: LD_VAR 0 1
18269: PPUSH
18270: CALL_OW 248
18274: ST_TO_ADDR
// case nat of 1 :
18275: LD_VAR 0 4
18279: PUSH
18280: LD_INT 1
18282: DOUBLE
18283: EQUAL
18284: IFTRUE 18288
18286: GO 18299
18288: POP
// tech := tech_lassight ; 2 :
18289: LD_ADDR_VAR 0 5
18293: PUSH
18294: LD_INT 12
18296: ST_TO_ADDR
18297: GO 18338
18299: LD_INT 2
18301: DOUBLE
18302: EQUAL
18303: IFTRUE 18307
18305: GO 18318
18307: POP
// tech := tech_mortar ; 3 :
18308: LD_ADDR_VAR 0 5
18312: PUSH
18313: LD_INT 41
18315: ST_TO_ADDR
18316: GO 18338
18318: LD_INT 3
18320: DOUBLE
18321: EQUAL
18322: IFTRUE 18326
18324: GO 18337
18326: POP
// tech := tech_bazooka ; end ;
18327: LD_ADDR_VAR 0 5
18331: PUSH
18332: LD_INT 44
18334: ST_TO_ADDR
18335: GO 18338
18337: POP
// if Researched ( side , tech ) then
18338: LD_VAR 0 3
18342: PPUSH
18343: LD_VAR 0 5
18347: PPUSH
18348: CALL_OW 325
18352: IFFALSE 18379
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18354: LD_ADDR_VAR 0 2
18358: PUSH
18359: LD_INT 5
18361: PUSH
18362: LD_INT 8
18364: PUSH
18365: LD_INT 9
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: LIST
18372: PUSH
18373: LD_VAR 0 4
18377: ARRAY
18378: ST_TO_ADDR
// end ;
18379: LD_VAR 0 2
18383: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18384: LD_INT 0
18386: PPUSH
18387: PPUSH
18388: PPUSH
// if not mines then
18389: LD_VAR 0 2
18393: NOT
18394: IFFALSE 18398
// exit ;
18396: GO 18542
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18398: LD_ADDR_VAR 0 5
18402: PUSH
18403: LD_INT 81
18405: PUSH
18406: LD_VAR 0 1
18410: PUSH
18411: EMPTY
18412: LIST
18413: LIST
18414: PUSH
18415: LD_INT 3
18417: PUSH
18418: LD_INT 21
18420: PUSH
18421: LD_INT 3
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: PUSH
18428: EMPTY
18429: LIST
18430: LIST
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PPUSH
18436: CALL_OW 69
18440: ST_TO_ADDR
// for i in mines do
18441: LD_ADDR_VAR 0 4
18445: PUSH
18446: LD_VAR 0 2
18450: PUSH
18451: FOR_IN
18452: IFFALSE 18540
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18454: LD_VAR 0 4
18458: PUSH
18459: LD_INT 1
18461: ARRAY
18462: PPUSH
18463: LD_VAR 0 4
18467: PUSH
18468: LD_INT 2
18470: ARRAY
18471: PPUSH
18472: CALL_OW 458
18476: NOT
18477: IFFALSE 18481
// continue ;
18479: GO 18451
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18481: LD_VAR 0 4
18485: PUSH
18486: LD_INT 1
18488: ARRAY
18489: PPUSH
18490: LD_VAR 0 4
18494: PUSH
18495: LD_INT 2
18497: ARRAY
18498: PPUSH
18499: CALL_OW 428
18503: PUSH
18504: LD_VAR 0 5
18508: IN
18509: IFFALSE 18538
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18511: LD_VAR 0 4
18515: PUSH
18516: LD_INT 1
18518: ARRAY
18519: PPUSH
18520: LD_VAR 0 4
18524: PUSH
18525: LD_INT 2
18527: ARRAY
18528: PPUSH
18529: LD_VAR 0 1
18533: PPUSH
18534: CALL_OW 456
// end ;
18538: GO 18451
18540: POP
18541: POP
// end ;
18542: LD_VAR 0 3
18546: RET
// export function Count ( array ) ; begin
18547: LD_INT 0
18549: PPUSH
// result := array + 0 ;
18550: LD_ADDR_VAR 0 2
18554: PUSH
18555: LD_VAR 0 1
18559: PUSH
18560: LD_INT 0
18562: PLUS
18563: ST_TO_ADDR
// end ;
18564: LD_VAR 0 2
18568: RET
// export function IsEmpty ( building ) ; begin
18569: LD_INT 0
18571: PPUSH
// if not building then
18572: LD_VAR 0 1
18576: NOT
18577: IFFALSE 18581
// exit ;
18579: GO 18624
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18581: LD_ADDR_VAR 0 2
18585: PUSH
18586: LD_VAR 0 1
18590: PUSH
18591: LD_INT 22
18593: PUSH
18594: LD_VAR 0 1
18598: PPUSH
18599: CALL_OW 255
18603: PUSH
18604: EMPTY
18605: LIST
18606: LIST
18607: PUSH
18608: LD_INT 58
18610: PUSH
18611: EMPTY
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PPUSH
18618: CALL_OW 69
18622: IN
18623: ST_TO_ADDR
// end ;
18624: LD_VAR 0 2
18628: RET
// export function IsNotFull ( building ) ; var places ; begin
18629: LD_INT 0
18631: PPUSH
18632: PPUSH
// if not building then
18633: LD_VAR 0 1
18637: NOT
18638: IFFALSE 18642
// exit ;
18640: GO 18670
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18642: LD_ADDR_VAR 0 2
18646: PUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: LD_INT 3
18654: PUSH
18655: LD_INT 62
18657: PUSH
18658: EMPTY
18659: LIST
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: PPUSH
18665: CALL_OW 72
18669: ST_TO_ADDR
// end ;
18670: LD_VAR 0 2
18674: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18675: LD_INT 0
18677: PPUSH
18678: PPUSH
18679: PPUSH
18680: PPUSH
// tmp := [ ] ;
18681: LD_ADDR_VAR 0 3
18685: PUSH
18686: EMPTY
18687: ST_TO_ADDR
// list := [ ] ;
18688: LD_ADDR_VAR 0 5
18692: PUSH
18693: EMPTY
18694: ST_TO_ADDR
// for i = 16 to 25 do
18695: LD_ADDR_VAR 0 4
18699: PUSH
18700: DOUBLE
18701: LD_INT 16
18703: DEC
18704: ST_TO_ADDR
18705: LD_INT 25
18707: PUSH
18708: FOR_TO
18709: IFFALSE 18782
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18711: LD_ADDR_VAR 0 3
18715: PUSH
18716: LD_VAR 0 3
18720: PUSH
18721: LD_INT 22
18723: PUSH
18724: LD_VAR 0 1
18728: PPUSH
18729: CALL_OW 255
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PUSH
18738: LD_INT 91
18740: PUSH
18741: LD_VAR 0 1
18745: PUSH
18746: LD_INT 6
18748: PUSH
18749: EMPTY
18750: LIST
18751: LIST
18752: LIST
18753: PUSH
18754: LD_INT 30
18756: PUSH
18757: LD_VAR 0 4
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: LIST
18770: PUSH
18771: EMPTY
18772: LIST
18773: PPUSH
18774: CALL_OW 69
18778: ADD
18779: ST_TO_ADDR
18780: GO 18708
18782: POP
18783: POP
// for i = 1 to tmp do
18784: LD_ADDR_VAR 0 4
18788: PUSH
18789: DOUBLE
18790: LD_INT 1
18792: DEC
18793: ST_TO_ADDR
18794: LD_VAR 0 3
18798: PUSH
18799: FOR_TO
18800: IFFALSE 18888
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18802: LD_ADDR_VAR 0 5
18806: PUSH
18807: LD_VAR 0 5
18811: PUSH
18812: LD_VAR 0 3
18816: PUSH
18817: LD_VAR 0 4
18821: ARRAY
18822: PPUSH
18823: CALL_OW 266
18827: PUSH
18828: LD_VAR 0 3
18832: PUSH
18833: LD_VAR 0 4
18837: ARRAY
18838: PPUSH
18839: CALL_OW 250
18843: PUSH
18844: LD_VAR 0 3
18848: PUSH
18849: LD_VAR 0 4
18853: ARRAY
18854: PPUSH
18855: CALL_OW 251
18859: PUSH
18860: LD_VAR 0 3
18864: PUSH
18865: LD_VAR 0 4
18869: ARRAY
18870: PPUSH
18871: CALL_OW 254
18875: PUSH
18876: EMPTY
18877: LIST
18878: LIST
18879: LIST
18880: LIST
18881: PUSH
18882: EMPTY
18883: LIST
18884: ADD
18885: ST_TO_ADDR
18886: GO 18799
18888: POP
18889: POP
// result := list ;
18890: LD_ADDR_VAR 0 2
18894: PUSH
18895: LD_VAR 0 5
18899: ST_TO_ADDR
// end ;
18900: LD_VAR 0 2
18904: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18905: LD_INT 0
18907: PPUSH
18908: PPUSH
18909: PPUSH
18910: PPUSH
18911: PPUSH
18912: PPUSH
18913: PPUSH
// if not factory then
18914: LD_VAR 0 1
18918: NOT
18919: IFFALSE 18923
// exit ;
18921: GO 19516
// if control = control_apeman then
18923: LD_VAR 0 4
18927: PUSH
18928: LD_INT 5
18930: EQUAL
18931: IFFALSE 19040
// begin tmp := UnitsInside ( factory ) ;
18933: LD_ADDR_VAR 0 8
18937: PUSH
18938: LD_VAR 0 1
18942: PPUSH
18943: CALL_OW 313
18947: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18948: LD_VAR 0 8
18952: PPUSH
18953: LD_INT 25
18955: PUSH
18956: LD_INT 12
18958: PUSH
18959: EMPTY
18960: LIST
18961: LIST
18962: PPUSH
18963: CALL_OW 72
18967: NOT
18968: IFFALSE 18978
// control := control_manual ;
18970: LD_ADDR_VAR 0 4
18974: PUSH
18975: LD_INT 1
18977: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18978: LD_ADDR_VAR 0 8
18982: PUSH
18983: LD_VAR 0 1
18987: PPUSH
18988: CALL 18675 0 1
18992: ST_TO_ADDR
// if tmp then
18993: LD_VAR 0 8
18997: IFFALSE 19040
// begin for i in tmp do
18999: LD_ADDR_VAR 0 7
19003: PUSH
19004: LD_VAR 0 8
19008: PUSH
19009: FOR_IN
19010: IFFALSE 19038
// if i [ 1 ] = b_ext_radio then
19012: LD_VAR 0 7
19016: PUSH
19017: LD_INT 1
19019: ARRAY
19020: PUSH
19021: LD_INT 22
19023: EQUAL
19024: IFFALSE 19036
// begin control := control_remote ;
19026: LD_ADDR_VAR 0 4
19030: PUSH
19031: LD_INT 2
19033: ST_TO_ADDR
// break ;
19034: GO 19038
// end ;
19036: GO 19009
19038: POP
19039: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19040: LD_VAR 0 1
19044: PPUSH
19045: LD_VAR 0 2
19049: PPUSH
19050: LD_VAR 0 3
19054: PPUSH
19055: LD_VAR 0 4
19059: PPUSH
19060: LD_VAR 0 5
19064: PPUSH
19065: CALL_OW 448
19069: IFFALSE 19104
// begin result := [ chassis , engine , control , weapon ] ;
19071: LD_ADDR_VAR 0 6
19075: PUSH
19076: LD_VAR 0 2
19080: PUSH
19081: LD_VAR 0 3
19085: PUSH
19086: LD_VAR 0 4
19090: PUSH
19091: LD_VAR 0 5
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: ST_TO_ADDR
// exit ;
19102: GO 19516
// end ; _chassis := AvailableChassisList ( factory ) ;
19104: LD_ADDR_VAR 0 9
19108: PUSH
19109: LD_VAR 0 1
19113: PPUSH
19114: CALL_OW 475
19118: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19119: LD_ADDR_VAR 0 11
19123: PUSH
19124: LD_VAR 0 1
19128: PPUSH
19129: CALL_OW 476
19133: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19134: LD_ADDR_VAR 0 12
19138: PUSH
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 477
19148: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19149: LD_ADDR_VAR 0 10
19153: PUSH
19154: LD_VAR 0 1
19158: PPUSH
19159: CALL_OW 478
19163: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19164: LD_VAR 0 9
19168: NOT
19169: PUSH
19170: LD_VAR 0 11
19174: NOT
19175: OR
19176: PUSH
19177: LD_VAR 0 12
19181: NOT
19182: OR
19183: PUSH
19184: LD_VAR 0 10
19188: NOT
19189: OR
19190: IFFALSE 19225
// begin result := [ chassis , engine , control , weapon ] ;
19192: LD_ADDR_VAR 0 6
19196: PUSH
19197: LD_VAR 0 2
19201: PUSH
19202: LD_VAR 0 3
19206: PUSH
19207: LD_VAR 0 4
19211: PUSH
19212: LD_VAR 0 5
19216: PUSH
19217: EMPTY
19218: LIST
19219: LIST
19220: LIST
19221: LIST
19222: ST_TO_ADDR
// exit ;
19223: GO 19516
// end ; if not chassis in _chassis then
19225: LD_VAR 0 2
19229: PUSH
19230: LD_VAR 0 9
19234: IN
19235: NOT
19236: IFFALSE 19262
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19238: LD_ADDR_VAR 0 2
19242: PUSH
19243: LD_VAR 0 9
19247: PUSH
19248: LD_INT 1
19250: PPUSH
19251: LD_VAR 0 9
19255: PPUSH
19256: CALL_OW 12
19260: ARRAY
19261: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19262: LD_VAR 0 2
19266: PPUSH
19267: LD_VAR 0 3
19271: PPUSH
19272: CALL 19521 0 2
19276: NOT
19277: IFFALSE 19336
// repeat engine := _engine [ 1 ] ;
19279: LD_ADDR_VAR 0 3
19283: PUSH
19284: LD_VAR 0 11
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19293: LD_ADDR_VAR 0 11
19297: PUSH
19298: LD_VAR 0 11
19302: PPUSH
19303: LD_INT 1
19305: PPUSH
19306: CALL_OW 3
19310: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19311: LD_VAR 0 2
19315: PPUSH
19316: LD_VAR 0 3
19320: PPUSH
19321: CALL 19521 0 2
19325: PUSH
19326: LD_VAR 0 11
19330: PUSH
19331: EMPTY
19332: EQUAL
19333: OR
19334: IFFALSE 19279
// if not control in _control then
19336: LD_VAR 0 4
19340: PUSH
19341: LD_VAR 0 12
19345: IN
19346: NOT
19347: IFFALSE 19373
// control := _control [ rand ( 1 , _control ) ] ;
19349: LD_ADDR_VAR 0 4
19353: PUSH
19354: LD_VAR 0 12
19358: PUSH
19359: LD_INT 1
19361: PPUSH
19362: LD_VAR 0 12
19366: PPUSH
19367: CALL_OW 12
19371: ARRAY
19372: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19373: LD_VAR 0 2
19377: PPUSH
19378: LD_VAR 0 5
19382: PPUSH
19383: CALL 19741 0 2
19387: NOT
19388: IFFALSE 19447
// repeat weapon := _weapon [ 1 ] ;
19390: LD_ADDR_VAR 0 5
19394: PUSH
19395: LD_VAR 0 10
19399: PUSH
19400: LD_INT 1
19402: ARRAY
19403: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19404: LD_ADDR_VAR 0 10
19408: PUSH
19409: LD_VAR 0 10
19413: PPUSH
19414: LD_INT 1
19416: PPUSH
19417: CALL_OW 3
19421: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19422: LD_VAR 0 2
19426: PPUSH
19427: LD_VAR 0 5
19431: PPUSH
19432: CALL 19741 0 2
19436: PUSH
19437: LD_VAR 0 10
19441: PUSH
19442: EMPTY
19443: EQUAL
19444: OR
19445: IFFALSE 19390
// result := [ ] ;
19447: LD_ADDR_VAR 0 6
19451: PUSH
19452: EMPTY
19453: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19454: LD_VAR 0 1
19458: PPUSH
19459: LD_VAR 0 2
19463: PPUSH
19464: LD_VAR 0 3
19468: PPUSH
19469: LD_VAR 0 4
19473: PPUSH
19474: LD_VAR 0 5
19478: PPUSH
19479: CALL_OW 448
19483: IFFALSE 19516
// result := [ chassis , engine , control , weapon ] ;
19485: LD_ADDR_VAR 0 6
19489: PUSH
19490: LD_VAR 0 2
19494: PUSH
19495: LD_VAR 0 3
19499: PUSH
19500: LD_VAR 0 4
19504: PUSH
19505: LD_VAR 0 5
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: LIST
19514: LIST
19515: ST_TO_ADDR
// end ;
19516: LD_VAR 0 6
19520: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19521: LD_INT 0
19523: PPUSH
// if not chassis or not engine then
19524: LD_VAR 0 1
19528: NOT
19529: PUSH
19530: LD_VAR 0 2
19534: NOT
19535: OR
19536: IFFALSE 19540
// exit ;
19538: GO 19736
// case engine of engine_solar :
19540: LD_VAR 0 2
19544: PUSH
19545: LD_INT 2
19547: DOUBLE
19548: EQUAL
19549: IFTRUE 19553
19551: GO 19591
19553: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19554: LD_ADDR_VAR 0 3
19558: PUSH
19559: LD_INT 11
19561: PUSH
19562: LD_INT 12
19564: PUSH
19565: LD_INT 13
19567: PUSH
19568: LD_INT 14
19570: PUSH
19571: LD_INT 1
19573: PUSH
19574: LD_INT 2
19576: PUSH
19577: LD_INT 3
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: LIST
19587: LIST
19588: ST_TO_ADDR
19589: GO 19720
19591: LD_INT 1
19593: DOUBLE
19594: EQUAL
19595: IFTRUE 19599
19597: GO 19661
19599: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19600: LD_ADDR_VAR 0 3
19604: PUSH
19605: LD_INT 11
19607: PUSH
19608: LD_INT 12
19610: PUSH
19611: LD_INT 13
19613: PUSH
19614: LD_INT 14
19616: PUSH
19617: LD_INT 1
19619: PUSH
19620: LD_INT 2
19622: PUSH
19623: LD_INT 3
19625: PUSH
19626: LD_INT 4
19628: PUSH
19629: LD_INT 5
19631: PUSH
19632: LD_INT 21
19634: PUSH
19635: LD_INT 23
19637: PUSH
19638: LD_INT 22
19640: PUSH
19641: LD_INT 24
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: LIST
19648: LIST
19649: LIST
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: ST_TO_ADDR
19659: GO 19720
19661: LD_INT 3
19663: DOUBLE
19664: EQUAL
19665: IFTRUE 19669
19667: GO 19719
19669: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19670: LD_ADDR_VAR 0 3
19674: PUSH
19675: LD_INT 13
19677: PUSH
19678: LD_INT 14
19680: PUSH
19681: LD_INT 2
19683: PUSH
19684: LD_INT 3
19686: PUSH
19687: LD_INT 4
19689: PUSH
19690: LD_INT 5
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 23
19701: PUSH
19702: LD_INT 24
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: LIST
19716: ST_TO_ADDR
19717: GO 19720
19719: POP
// result := ( chassis in result ) ;
19720: LD_ADDR_VAR 0 3
19724: PUSH
19725: LD_VAR 0 1
19729: PUSH
19730: LD_VAR 0 3
19734: IN
19735: ST_TO_ADDR
// end ;
19736: LD_VAR 0 3
19740: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19741: LD_INT 0
19743: PPUSH
// if not chassis or not weapon then
19744: LD_VAR 0 1
19748: NOT
19749: PUSH
19750: LD_VAR 0 2
19754: NOT
19755: OR
19756: IFFALSE 19760
// exit ;
19758: GO 20820
// case weapon of us_machine_gun :
19760: LD_VAR 0 2
19764: PUSH
19765: LD_INT 2
19767: DOUBLE
19768: EQUAL
19769: IFTRUE 19773
19771: GO 19803
19773: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19774: LD_ADDR_VAR 0 3
19778: PUSH
19779: LD_INT 1
19781: PUSH
19782: LD_INT 2
19784: PUSH
19785: LD_INT 3
19787: PUSH
19788: LD_INT 4
19790: PUSH
19791: LD_INT 5
19793: PUSH
19794: EMPTY
19795: LIST
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: ST_TO_ADDR
19801: GO 20804
19803: LD_INT 3
19805: DOUBLE
19806: EQUAL
19807: IFTRUE 19811
19809: GO 19841
19811: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19812: LD_ADDR_VAR 0 3
19816: PUSH
19817: LD_INT 1
19819: PUSH
19820: LD_INT 2
19822: PUSH
19823: LD_INT 3
19825: PUSH
19826: LD_INT 4
19828: PUSH
19829: LD_INT 5
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: LIST
19838: ST_TO_ADDR
19839: GO 20804
19841: LD_INT 11
19843: DOUBLE
19844: EQUAL
19845: IFTRUE 19849
19847: GO 19879
19849: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19850: LD_ADDR_VAR 0 3
19854: PUSH
19855: LD_INT 1
19857: PUSH
19858: LD_INT 2
19860: PUSH
19861: LD_INT 3
19863: PUSH
19864: LD_INT 4
19866: PUSH
19867: LD_INT 5
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: LIST
19874: LIST
19875: LIST
19876: ST_TO_ADDR
19877: GO 20804
19879: LD_INT 4
19881: DOUBLE
19882: EQUAL
19883: IFTRUE 19887
19885: GO 19913
19887: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19888: LD_ADDR_VAR 0 3
19892: PUSH
19893: LD_INT 2
19895: PUSH
19896: LD_INT 3
19898: PUSH
19899: LD_INT 4
19901: PUSH
19902: LD_INT 5
19904: PUSH
19905: EMPTY
19906: LIST
19907: LIST
19908: LIST
19909: LIST
19910: ST_TO_ADDR
19911: GO 20804
19913: LD_INT 5
19915: DOUBLE
19916: EQUAL
19917: IFTRUE 19921
19919: GO 19947
19921: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19922: LD_ADDR_VAR 0 3
19926: PUSH
19927: LD_INT 2
19929: PUSH
19930: LD_INT 3
19932: PUSH
19933: LD_INT 4
19935: PUSH
19936: LD_INT 5
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: ST_TO_ADDR
19945: GO 20804
19947: LD_INT 9
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 19981
19955: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19956: LD_ADDR_VAR 0 3
19960: PUSH
19961: LD_INT 2
19963: PUSH
19964: LD_INT 3
19966: PUSH
19967: LD_INT 4
19969: PUSH
19970: LD_INT 5
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: ST_TO_ADDR
19979: GO 20804
19981: LD_INT 7
19983: DOUBLE
19984: EQUAL
19985: IFTRUE 19989
19987: GO 20015
19989: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19990: LD_ADDR_VAR 0 3
19994: PUSH
19995: LD_INT 2
19997: PUSH
19998: LD_INT 3
20000: PUSH
20001: LD_INT 4
20003: PUSH
20004: LD_INT 5
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: LIST
20011: LIST
20012: ST_TO_ADDR
20013: GO 20804
20015: LD_INT 12
20017: DOUBLE
20018: EQUAL
20019: IFTRUE 20023
20021: GO 20049
20023: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20024: LD_ADDR_VAR 0 3
20028: PUSH
20029: LD_INT 2
20031: PUSH
20032: LD_INT 3
20034: PUSH
20035: LD_INT 4
20037: PUSH
20038: LD_INT 5
20040: PUSH
20041: EMPTY
20042: LIST
20043: LIST
20044: LIST
20045: LIST
20046: ST_TO_ADDR
20047: GO 20804
20049: LD_INT 13
20051: DOUBLE
20052: EQUAL
20053: IFTRUE 20057
20055: GO 20083
20057: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20058: LD_ADDR_VAR 0 3
20062: PUSH
20063: LD_INT 2
20065: PUSH
20066: LD_INT 3
20068: PUSH
20069: LD_INT 4
20071: PUSH
20072: LD_INT 5
20074: PUSH
20075: EMPTY
20076: LIST
20077: LIST
20078: LIST
20079: LIST
20080: ST_TO_ADDR
20081: GO 20804
20083: LD_INT 14
20085: DOUBLE
20086: EQUAL
20087: IFTRUE 20091
20089: GO 20109
20091: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20092: LD_ADDR_VAR 0 3
20096: PUSH
20097: LD_INT 4
20099: PUSH
20100: LD_INT 5
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: ST_TO_ADDR
20107: GO 20804
20109: LD_INT 6
20111: DOUBLE
20112: EQUAL
20113: IFTRUE 20117
20115: GO 20135
20117: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20118: LD_ADDR_VAR 0 3
20122: PUSH
20123: LD_INT 4
20125: PUSH
20126: LD_INT 5
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: ST_TO_ADDR
20133: GO 20804
20135: LD_INT 10
20137: DOUBLE
20138: EQUAL
20139: IFTRUE 20143
20141: GO 20161
20143: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20144: LD_ADDR_VAR 0 3
20148: PUSH
20149: LD_INT 4
20151: PUSH
20152: LD_INT 5
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: ST_TO_ADDR
20159: GO 20804
20161: LD_INT 22
20163: DOUBLE
20164: EQUAL
20165: IFTRUE 20169
20167: GO 20195
20169: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20170: LD_ADDR_VAR 0 3
20174: PUSH
20175: LD_INT 11
20177: PUSH
20178: LD_INT 12
20180: PUSH
20181: LD_INT 13
20183: PUSH
20184: LD_INT 14
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: ST_TO_ADDR
20193: GO 20804
20195: LD_INT 23
20197: DOUBLE
20198: EQUAL
20199: IFTRUE 20203
20201: GO 20229
20203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20204: LD_ADDR_VAR 0 3
20208: PUSH
20209: LD_INT 11
20211: PUSH
20212: LD_INT 12
20214: PUSH
20215: LD_INT 13
20217: PUSH
20218: LD_INT 14
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: LIST
20225: LIST
20226: ST_TO_ADDR
20227: GO 20804
20229: LD_INT 24
20231: DOUBLE
20232: EQUAL
20233: IFTRUE 20237
20235: GO 20263
20237: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20238: LD_ADDR_VAR 0 3
20242: PUSH
20243: LD_INT 11
20245: PUSH
20246: LD_INT 12
20248: PUSH
20249: LD_INT 13
20251: PUSH
20252: LD_INT 14
20254: PUSH
20255: EMPTY
20256: LIST
20257: LIST
20258: LIST
20259: LIST
20260: ST_TO_ADDR
20261: GO 20804
20263: LD_INT 30
20265: DOUBLE
20266: EQUAL
20267: IFTRUE 20271
20269: GO 20297
20271: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20272: LD_ADDR_VAR 0 3
20276: PUSH
20277: LD_INT 11
20279: PUSH
20280: LD_INT 12
20282: PUSH
20283: LD_INT 13
20285: PUSH
20286: LD_INT 14
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: LIST
20293: LIST
20294: ST_TO_ADDR
20295: GO 20804
20297: LD_INT 25
20299: DOUBLE
20300: EQUAL
20301: IFTRUE 20305
20303: GO 20323
20305: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20306: LD_ADDR_VAR 0 3
20310: PUSH
20311: LD_INT 13
20313: PUSH
20314: LD_INT 14
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: ST_TO_ADDR
20321: GO 20804
20323: LD_INT 27
20325: DOUBLE
20326: EQUAL
20327: IFTRUE 20331
20329: GO 20349
20331: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
20332: LD_ADDR_VAR 0 3
20336: PUSH
20337: LD_INT 13
20339: PUSH
20340: LD_INT 14
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: ST_TO_ADDR
20347: GO 20804
20349: LD_INT 92
20351: DOUBLE
20352: EQUAL
20353: IFTRUE 20357
20355: GO 20383
20357: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20358: LD_ADDR_VAR 0 3
20362: PUSH
20363: LD_INT 11
20365: PUSH
20366: LD_INT 12
20368: PUSH
20369: LD_INT 13
20371: PUSH
20372: LD_INT 14
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: LIST
20379: LIST
20380: ST_TO_ADDR
20381: GO 20804
20383: LD_INT 28
20385: DOUBLE
20386: EQUAL
20387: IFTRUE 20391
20389: GO 20409
20391: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20392: LD_ADDR_VAR 0 3
20396: PUSH
20397: LD_INT 13
20399: PUSH
20400: LD_INT 14
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: ST_TO_ADDR
20407: GO 20804
20409: LD_INT 29
20411: DOUBLE
20412: EQUAL
20413: IFTRUE 20417
20415: GO 20435
20417: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20418: LD_ADDR_VAR 0 3
20422: PUSH
20423: LD_INT 13
20425: PUSH
20426: LD_INT 14
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: ST_TO_ADDR
20433: GO 20804
20435: LD_INT 31
20437: DOUBLE
20438: EQUAL
20439: IFTRUE 20443
20441: GO 20461
20443: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_INT 13
20451: PUSH
20452: LD_INT 14
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: ST_TO_ADDR
20459: GO 20804
20461: LD_INT 26
20463: DOUBLE
20464: EQUAL
20465: IFTRUE 20469
20467: GO 20487
20469: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20470: LD_ADDR_VAR 0 3
20474: PUSH
20475: LD_INT 13
20477: PUSH
20478: LD_INT 14
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: ST_TO_ADDR
20485: GO 20804
20487: LD_INT 42
20489: DOUBLE
20490: EQUAL
20491: IFTRUE 20495
20493: GO 20521
20495: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20496: LD_ADDR_VAR 0 3
20500: PUSH
20501: LD_INT 21
20503: PUSH
20504: LD_INT 22
20506: PUSH
20507: LD_INT 23
20509: PUSH
20510: LD_INT 24
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: LIST
20517: LIST
20518: ST_TO_ADDR
20519: GO 20804
20521: LD_INT 43
20523: DOUBLE
20524: EQUAL
20525: IFTRUE 20529
20527: GO 20555
20529: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20530: LD_ADDR_VAR 0 3
20534: PUSH
20535: LD_INT 21
20537: PUSH
20538: LD_INT 22
20540: PUSH
20541: LD_INT 23
20543: PUSH
20544: LD_INT 24
20546: PUSH
20547: EMPTY
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: ST_TO_ADDR
20553: GO 20804
20555: LD_INT 44
20557: DOUBLE
20558: EQUAL
20559: IFTRUE 20563
20561: GO 20589
20563: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20564: LD_ADDR_VAR 0 3
20568: PUSH
20569: LD_INT 21
20571: PUSH
20572: LD_INT 22
20574: PUSH
20575: LD_INT 23
20577: PUSH
20578: LD_INT 24
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
20587: GO 20804
20589: LD_INT 45
20591: DOUBLE
20592: EQUAL
20593: IFTRUE 20597
20595: GO 20623
20597: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20598: LD_ADDR_VAR 0 3
20602: PUSH
20603: LD_INT 21
20605: PUSH
20606: LD_INT 22
20608: PUSH
20609: LD_INT 23
20611: PUSH
20612: LD_INT 24
20614: PUSH
20615: EMPTY
20616: LIST
20617: LIST
20618: LIST
20619: LIST
20620: ST_TO_ADDR
20621: GO 20804
20623: LD_INT 49
20625: DOUBLE
20626: EQUAL
20627: IFTRUE 20631
20629: GO 20657
20631: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20632: LD_ADDR_VAR 0 3
20636: PUSH
20637: LD_INT 21
20639: PUSH
20640: LD_INT 22
20642: PUSH
20643: LD_INT 23
20645: PUSH
20646: LD_INT 24
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
20655: GO 20804
20657: LD_INT 51
20659: DOUBLE
20660: EQUAL
20661: IFTRUE 20665
20663: GO 20691
20665: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20666: LD_ADDR_VAR 0 3
20670: PUSH
20671: LD_INT 21
20673: PUSH
20674: LD_INT 22
20676: PUSH
20677: LD_INT 23
20679: PUSH
20680: LD_INT 24
20682: PUSH
20683: EMPTY
20684: LIST
20685: LIST
20686: LIST
20687: LIST
20688: ST_TO_ADDR
20689: GO 20804
20691: LD_INT 52
20693: DOUBLE
20694: EQUAL
20695: IFTRUE 20699
20697: GO 20725
20699: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 21
20707: PUSH
20708: LD_INT 22
20710: PUSH
20711: LD_INT 23
20713: PUSH
20714: LD_INT 24
20716: PUSH
20717: EMPTY
20718: LIST
20719: LIST
20720: LIST
20721: LIST
20722: ST_TO_ADDR
20723: GO 20804
20725: LD_INT 53
20727: DOUBLE
20728: EQUAL
20729: IFTRUE 20733
20731: GO 20751
20733: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20734: LD_ADDR_VAR 0 3
20738: PUSH
20739: LD_INT 23
20741: PUSH
20742: LD_INT 24
20744: PUSH
20745: EMPTY
20746: LIST
20747: LIST
20748: ST_TO_ADDR
20749: GO 20804
20751: LD_INT 46
20753: DOUBLE
20754: EQUAL
20755: IFTRUE 20759
20757: GO 20777
20759: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20760: LD_ADDR_VAR 0 3
20764: PUSH
20765: LD_INT 23
20767: PUSH
20768: LD_INT 24
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: ST_TO_ADDR
20775: GO 20804
20777: LD_INT 47
20779: DOUBLE
20780: EQUAL
20781: IFTRUE 20785
20783: GO 20803
20785: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20786: LD_ADDR_VAR 0 3
20790: PUSH
20791: LD_INT 23
20793: PUSH
20794: LD_INT 24
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: ST_TO_ADDR
20801: GO 20804
20803: POP
// result := ( chassis in result ) ;
20804: LD_ADDR_VAR 0 3
20808: PUSH
20809: LD_VAR 0 1
20813: PUSH
20814: LD_VAR 0 3
20818: IN
20819: ST_TO_ADDR
// end ;
20820: LD_VAR 0 3
20824: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20825: LD_INT 0
20827: PPUSH
20828: PPUSH
20829: PPUSH
20830: PPUSH
20831: PPUSH
20832: PPUSH
20833: PPUSH
// result := array ;
20834: LD_ADDR_VAR 0 5
20838: PUSH
20839: LD_VAR 0 1
20843: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20844: LD_VAR 0 1
20848: NOT
20849: PUSH
20850: LD_VAR 0 2
20854: NOT
20855: OR
20856: PUSH
20857: LD_VAR 0 3
20861: NOT
20862: OR
20863: PUSH
20864: LD_VAR 0 2
20868: PUSH
20869: LD_VAR 0 1
20873: GREATER
20874: OR
20875: PUSH
20876: LD_VAR 0 3
20880: PUSH
20881: LD_VAR 0 1
20885: GREATER
20886: OR
20887: IFFALSE 20891
// exit ;
20889: GO 21187
// if direction then
20891: LD_VAR 0 4
20895: IFFALSE 20959
// begin d := 1 ;
20897: LD_ADDR_VAR 0 9
20901: PUSH
20902: LD_INT 1
20904: ST_TO_ADDR
// if i_from > i_to then
20905: LD_VAR 0 2
20909: PUSH
20910: LD_VAR 0 3
20914: GREATER
20915: IFFALSE 20941
// length := ( array - i_from ) + i_to else
20917: LD_ADDR_VAR 0 11
20921: PUSH
20922: LD_VAR 0 1
20926: PUSH
20927: LD_VAR 0 2
20931: MINUS
20932: PUSH
20933: LD_VAR 0 3
20937: PLUS
20938: ST_TO_ADDR
20939: GO 20957
// length := i_to - i_from ;
20941: LD_ADDR_VAR 0 11
20945: PUSH
20946: LD_VAR 0 3
20950: PUSH
20951: LD_VAR 0 2
20955: MINUS
20956: ST_TO_ADDR
// end else
20957: GO 21020
// begin d := - 1 ;
20959: LD_ADDR_VAR 0 9
20963: PUSH
20964: LD_INT 1
20966: NEG
20967: ST_TO_ADDR
// if i_from > i_to then
20968: LD_VAR 0 2
20972: PUSH
20973: LD_VAR 0 3
20977: GREATER
20978: IFFALSE 20998
// length := i_from - i_to else
20980: LD_ADDR_VAR 0 11
20984: PUSH
20985: LD_VAR 0 2
20989: PUSH
20990: LD_VAR 0 3
20994: MINUS
20995: ST_TO_ADDR
20996: GO 21020
// length := ( array - i_to ) + i_from ;
20998: LD_ADDR_VAR 0 11
21002: PUSH
21003: LD_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: MINUS
21013: PUSH
21014: LD_VAR 0 2
21018: PLUS
21019: ST_TO_ADDR
// end ; if not length then
21020: LD_VAR 0 11
21024: NOT
21025: IFFALSE 21029
// exit ;
21027: GO 21187
// tmp := array ;
21029: LD_ADDR_VAR 0 10
21033: PUSH
21034: LD_VAR 0 1
21038: ST_TO_ADDR
// for i = 1 to length do
21039: LD_ADDR_VAR 0 6
21043: PUSH
21044: DOUBLE
21045: LD_INT 1
21047: DEC
21048: ST_TO_ADDR
21049: LD_VAR 0 11
21053: PUSH
21054: FOR_TO
21055: IFFALSE 21175
// begin for j = 1 to array do
21057: LD_ADDR_VAR 0 7
21061: PUSH
21062: DOUBLE
21063: LD_INT 1
21065: DEC
21066: ST_TO_ADDR
21067: LD_VAR 0 1
21071: PUSH
21072: FOR_TO
21073: IFFALSE 21161
// begin k := j + d ;
21075: LD_ADDR_VAR 0 8
21079: PUSH
21080: LD_VAR 0 7
21084: PUSH
21085: LD_VAR 0 9
21089: PLUS
21090: ST_TO_ADDR
// if k > array then
21091: LD_VAR 0 8
21095: PUSH
21096: LD_VAR 0 1
21100: GREATER
21101: IFFALSE 21111
// k := 1 ;
21103: LD_ADDR_VAR 0 8
21107: PUSH
21108: LD_INT 1
21110: ST_TO_ADDR
// if not k then
21111: LD_VAR 0 8
21115: NOT
21116: IFFALSE 21128
// k := array ;
21118: LD_ADDR_VAR 0 8
21122: PUSH
21123: LD_VAR 0 1
21127: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21128: LD_ADDR_VAR 0 10
21132: PUSH
21133: LD_VAR 0 10
21137: PPUSH
21138: LD_VAR 0 8
21142: PPUSH
21143: LD_VAR 0 1
21147: PUSH
21148: LD_VAR 0 7
21152: ARRAY
21153: PPUSH
21154: CALL_OW 1
21158: ST_TO_ADDR
// end ;
21159: GO 21072
21161: POP
21162: POP
// array := tmp ;
21163: LD_ADDR_VAR 0 1
21167: PUSH
21168: LD_VAR 0 10
21172: ST_TO_ADDR
// end ;
21173: GO 21054
21175: POP
21176: POP
// result := array ;
21177: LD_ADDR_VAR 0 5
21181: PUSH
21182: LD_VAR 0 1
21186: ST_TO_ADDR
// end ;
21187: LD_VAR 0 5
21191: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21192: LD_INT 0
21194: PPUSH
21195: PPUSH
// result := 0 ;
21196: LD_ADDR_VAR 0 3
21200: PUSH
21201: LD_INT 0
21203: ST_TO_ADDR
// if not array or not value in array then
21204: LD_VAR 0 1
21208: NOT
21209: PUSH
21210: LD_VAR 0 2
21214: PUSH
21215: LD_VAR 0 1
21219: IN
21220: NOT
21221: OR
21222: IFFALSE 21226
// exit ;
21224: GO 21280
// for i = 1 to array do
21226: LD_ADDR_VAR 0 4
21230: PUSH
21231: DOUBLE
21232: LD_INT 1
21234: DEC
21235: ST_TO_ADDR
21236: LD_VAR 0 1
21240: PUSH
21241: FOR_TO
21242: IFFALSE 21278
// if value = array [ i ] then
21244: LD_VAR 0 2
21248: PUSH
21249: LD_VAR 0 1
21253: PUSH
21254: LD_VAR 0 4
21258: ARRAY
21259: EQUAL
21260: IFFALSE 21276
// begin result := i ;
21262: LD_ADDR_VAR 0 3
21266: PUSH
21267: LD_VAR 0 4
21271: ST_TO_ADDR
// exit ;
21272: POP
21273: POP
21274: GO 21280
// end ;
21276: GO 21241
21278: POP
21279: POP
// end ;
21280: LD_VAR 0 3
21284: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21285: LD_INT 0
21287: PPUSH
// vc_chassis := chassis ;
21288: LD_ADDR_OWVAR 37
21292: PUSH
21293: LD_VAR 0 1
21297: ST_TO_ADDR
// vc_engine := engine ;
21298: LD_ADDR_OWVAR 39
21302: PUSH
21303: LD_VAR 0 2
21307: ST_TO_ADDR
// vc_control := control ;
21308: LD_ADDR_OWVAR 38
21312: PUSH
21313: LD_VAR 0 3
21317: ST_TO_ADDR
// vc_weapon := weapon ;
21318: LD_ADDR_OWVAR 40
21322: PUSH
21323: LD_VAR 0 4
21327: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21328: LD_ADDR_OWVAR 41
21332: PUSH
21333: LD_VAR 0 5
21337: ST_TO_ADDR
// end ;
21338: LD_VAR 0 6
21342: RET
// export function WantPlant ( unit ) ; var task ; begin
21343: LD_INT 0
21345: PPUSH
21346: PPUSH
// result := false ;
21347: LD_ADDR_VAR 0 2
21351: PUSH
21352: LD_INT 0
21354: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21355: LD_ADDR_VAR 0 3
21359: PUSH
21360: LD_VAR 0 1
21364: PPUSH
21365: CALL_OW 437
21369: ST_TO_ADDR
// if task then
21370: LD_VAR 0 3
21374: IFFALSE 21402
// if task [ 1 ] [ 1 ] = p then
21376: LD_VAR 0 3
21380: PUSH
21381: LD_INT 1
21383: ARRAY
21384: PUSH
21385: LD_INT 1
21387: ARRAY
21388: PUSH
21389: LD_STRING p
21391: EQUAL
21392: IFFALSE 21402
// result := true ;
21394: LD_ADDR_VAR 0 2
21398: PUSH
21399: LD_INT 1
21401: ST_TO_ADDR
// end ;
21402: LD_VAR 0 2
21406: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21407: LD_INT 0
21409: PPUSH
21410: PPUSH
21411: PPUSH
21412: PPUSH
// if pos < 1 then
21413: LD_VAR 0 2
21417: PUSH
21418: LD_INT 1
21420: LESS
21421: IFFALSE 21425
// exit ;
21423: GO 21728
// if pos = 1 then
21425: LD_VAR 0 2
21429: PUSH
21430: LD_INT 1
21432: EQUAL
21433: IFFALSE 21466
// result := Replace ( arr , pos [ 1 ] , value ) else
21435: LD_ADDR_VAR 0 4
21439: PUSH
21440: LD_VAR 0 1
21444: PPUSH
21445: LD_VAR 0 2
21449: PUSH
21450: LD_INT 1
21452: ARRAY
21453: PPUSH
21454: LD_VAR 0 3
21458: PPUSH
21459: CALL_OW 1
21463: ST_TO_ADDR
21464: GO 21728
// begin tmp := arr ;
21466: LD_ADDR_VAR 0 6
21470: PUSH
21471: LD_VAR 0 1
21475: ST_TO_ADDR
// s_arr := [ tmp ] ;
21476: LD_ADDR_VAR 0 7
21480: PUSH
21481: LD_VAR 0 6
21485: PUSH
21486: EMPTY
21487: LIST
21488: ST_TO_ADDR
// for i = 1 to pos - 1 do
21489: LD_ADDR_VAR 0 5
21493: PUSH
21494: DOUBLE
21495: LD_INT 1
21497: DEC
21498: ST_TO_ADDR
21499: LD_VAR 0 2
21503: PUSH
21504: LD_INT 1
21506: MINUS
21507: PUSH
21508: FOR_TO
21509: IFFALSE 21554
// begin tmp := tmp [ pos [ i ] ] ;
21511: LD_ADDR_VAR 0 6
21515: PUSH
21516: LD_VAR 0 6
21520: PUSH
21521: LD_VAR 0 2
21525: PUSH
21526: LD_VAR 0 5
21530: ARRAY
21531: ARRAY
21532: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21533: LD_ADDR_VAR 0 7
21537: PUSH
21538: LD_VAR 0 7
21542: PUSH
21543: LD_VAR 0 6
21547: PUSH
21548: EMPTY
21549: LIST
21550: ADD
21551: ST_TO_ADDR
// end ;
21552: GO 21508
21554: POP
21555: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21556: LD_ADDR_VAR 0 6
21560: PUSH
21561: LD_VAR 0 6
21565: PPUSH
21566: LD_VAR 0 2
21570: PUSH
21571: LD_VAR 0 2
21575: ARRAY
21576: PPUSH
21577: LD_VAR 0 3
21581: PPUSH
21582: CALL_OW 1
21586: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21587: LD_ADDR_VAR 0 7
21591: PUSH
21592: LD_VAR 0 7
21596: PPUSH
21597: LD_VAR 0 7
21601: PPUSH
21602: LD_VAR 0 6
21606: PPUSH
21607: CALL_OW 1
21611: ST_TO_ADDR
// for i = s_arr downto 2 do
21612: LD_ADDR_VAR 0 5
21616: PUSH
21617: DOUBLE
21618: LD_VAR 0 7
21622: INC
21623: ST_TO_ADDR
21624: LD_INT 2
21626: PUSH
21627: FOR_DOWNTO
21628: IFFALSE 21712
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21630: LD_ADDR_VAR 0 6
21634: PUSH
21635: LD_VAR 0 7
21639: PUSH
21640: LD_VAR 0 5
21644: PUSH
21645: LD_INT 1
21647: MINUS
21648: ARRAY
21649: PPUSH
21650: LD_VAR 0 2
21654: PUSH
21655: LD_VAR 0 5
21659: PUSH
21660: LD_INT 1
21662: MINUS
21663: ARRAY
21664: PPUSH
21665: LD_VAR 0 7
21669: PUSH
21670: LD_VAR 0 5
21674: ARRAY
21675: PPUSH
21676: CALL_OW 1
21680: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21681: LD_ADDR_VAR 0 7
21685: PUSH
21686: LD_VAR 0 7
21690: PPUSH
21691: LD_VAR 0 5
21695: PUSH
21696: LD_INT 1
21698: MINUS
21699: PPUSH
21700: LD_VAR 0 6
21704: PPUSH
21705: CALL_OW 1
21709: ST_TO_ADDR
// end ;
21710: GO 21627
21712: POP
21713: POP
// result := s_arr [ 1 ] ;
21714: LD_ADDR_VAR 0 4
21718: PUSH
21719: LD_VAR 0 7
21723: PUSH
21724: LD_INT 1
21726: ARRAY
21727: ST_TO_ADDR
// end ; end ;
21728: LD_VAR 0 4
21732: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21733: LD_INT 0
21735: PPUSH
21736: PPUSH
// if not list then
21737: LD_VAR 0 1
21741: NOT
21742: IFFALSE 21746
// exit ;
21744: GO 21837
// i := list [ pos1 ] ;
21746: LD_ADDR_VAR 0 5
21750: PUSH
21751: LD_VAR 0 1
21755: PUSH
21756: LD_VAR 0 2
21760: ARRAY
21761: ST_TO_ADDR
// if not i then
21762: LD_VAR 0 5
21766: NOT
21767: IFFALSE 21771
// exit ;
21769: GO 21837
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21771: LD_ADDR_VAR 0 1
21775: PUSH
21776: LD_VAR 0 1
21780: PPUSH
21781: LD_VAR 0 2
21785: PPUSH
21786: LD_VAR 0 1
21790: PUSH
21791: LD_VAR 0 3
21795: ARRAY
21796: PPUSH
21797: CALL_OW 1
21801: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21802: LD_ADDR_VAR 0 1
21806: PUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_VAR 0 3
21816: PPUSH
21817: LD_VAR 0 5
21821: PPUSH
21822: CALL_OW 1
21826: ST_TO_ADDR
// result := list ;
21827: LD_ADDR_VAR 0 4
21831: PUSH
21832: LD_VAR 0 1
21836: ST_TO_ADDR
// end ;
21837: LD_VAR 0 4
21841: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21842: LD_INT 0
21844: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21845: LD_ADDR_VAR 0 5
21849: PUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: CALL_OW 250
21859: PPUSH
21860: LD_VAR 0 1
21864: PPUSH
21865: CALL_OW 251
21869: PPUSH
21870: LD_VAR 0 2
21874: PPUSH
21875: LD_VAR 0 3
21879: PPUSH
21880: LD_VAR 0 4
21884: PPUSH
21885: CALL 22263 0 5
21889: ST_TO_ADDR
// end ;
21890: LD_VAR 0 5
21894: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21895: LD_INT 0
21897: PPUSH
21898: PPUSH
21899: PPUSH
21900: PPUSH
// if not list or not unit then
21901: LD_VAR 0 2
21905: NOT
21906: PUSH
21907: LD_VAR 0 1
21911: NOT
21912: OR
21913: IFFALSE 21917
// exit ;
21915: GO 22258
// result := [ ] ;
21917: LD_ADDR_VAR 0 5
21921: PUSH
21922: EMPTY
21923: ST_TO_ADDR
// for i in list do
21924: LD_ADDR_VAR 0 6
21928: PUSH
21929: LD_VAR 0 2
21933: PUSH
21934: FOR_IN
21935: IFFALSE 22153
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21937: LD_ADDR_VAR 0 8
21941: PUSH
21942: LD_VAR 0 1
21946: PPUSH
21947: LD_VAR 0 6
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PPUSH
21956: LD_VAR 0 6
21960: PUSH
21961: LD_INT 2
21963: ARRAY
21964: PPUSH
21965: CALL_OW 297
21969: ST_TO_ADDR
// if not Count ( result ) then
21970: LD_VAR 0 5
21974: PPUSH
21975: CALL 18547 0 1
21979: NOT
21980: IFFALSE 22013
// begin result := Join ( result , [ i , tmp ] ) ;
21982: LD_ADDR_VAR 0 5
21986: PUSH
21987: LD_VAR 0 5
21991: PPUSH
21992: LD_VAR 0 6
21996: PUSH
21997: LD_VAR 0 8
22001: PUSH
22002: EMPTY
22003: LIST
22004: LIST
22005: PPUSH
22006: CALL 54136 0 2
22010: ST_TO_ADDR
// continue ;
22011: GO 21934
// end ; if result [ result ] [ 2 ] <= tmp then
22013: LD_VAR 0 5
22017: PUSH
22018: LD_VAR 0 5
22022: ARRAY
22023: PUSH
22024: LD_INT 2
22026: ARRAY
22027: PUSH
22028: LD_VAR 0 8
22032: LESSEQUAL
22033: IFFALSE 22066
// result := Join ( result , [ i , tmp ] ) else
22035: LD_ADDR_VAR 0 5
22039: PUSH
22040: LD_VAR 0 5
22044: PPUSH
22045: LD_VAR 0 6
22049: PUSH
22050: LD_VAR 0 8
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PPUSH
22059: CALL 54136 0 2
22063: ST_TO_ADDR
22064: GO 22151
// begin for j := 1 to Count ( result ) do
22066: LD_ADDR_VAR 0 7
22070: PUSH
22071: DOUBLE
22072: LD_INT 1
22074: DEC
22075: ST_TO_ADDR
22076: LD_VAR 0 5
22080: PPUSH
22081: CALL 18547 0 1
22085: PUSH
22086: FOR_TO
22087: IFFALSE 22149
// begin if tmp < result [ j ] [ 2 ] then
22089: LD_VAR 0 8
22093: PUSH
22094: LD_VAR 0 5
22098: PUSH
22099: LD_VAR 0 7
22103: ARRAY
22104: PUSH
22105: LD_INT 2
22107: ARRAY
22108: LESS
22109: IFFALSE 22147
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22111: LD_ADDR_VAR 0 5
22115: PUSH
22116: LD_VAR 0 5
22120: PPUSH
22121: LD_VAR 0 7
22125: PPUSH
22126: LD_VAR 0 6
22130: PUSH
22131: LD_VAR 0 8
22135: PUSH
22136: EMPTY
22137: LIST
22138: LIST
22139: PPUSH
22140: CALL_OW 2
22144: ST_TO_ADDR
// break ;
22145: GO 22149
// end ; end ;
22147: GO 22086
22149: POP
22150: POP
// end ; end ;
22151: GO 21934
22153: POP
22154: POP
// if result and not asc then
22155: LD_VAR 0 5
22159: PUSH
22160: LD_VAR 0 3
22164: NOT
22165: AND
22166: IFFALSE 22183
// result := ReverseArray ( result ) ;
22168: LD_ADDR_VAR 0 5
22172: PUSH
22173: LD_VAR 0 5
22177: PPUSH
22178: CALL 49423 0 1
22182: ST_TO_ADDR
// tmp := [ ] ;
22183: LD_ADDR_VAR 0 8
22187: PUSH
22188: EMPTY
22189: ST_TO_ADDR
// if mode then
22190: LD_VAR 0 4
22194: IFFALSE 22258
// begin for i := 1 to result do
22196: LD_ADDR_VAR 0 6
22200: PUSH
22201: DOUBLE
22202: LD_INT 1
22204: DEC
22205: ST_TO_ADDR
22206: LD_VAR 0 5
22210: PUSH
22211: FOR_TO
22212: IFFALSE 22246
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
22214: LD_ADDR_VAR 0 8
22218: PUSH
22219: LD_VAR 0 8
22223: PPUSH
22224: LD_VAR 0 5
22228: PUSH
22229: LD_VAR 0 6
22233: ARRAY
22234: PUSH
22235: LD_INT 1
22237: ARRAY
22238: PPUSH
22239: CALL 54136 0 2
22243: ST_TO_ADDR
22244: GO 22211
22246: POP
22247: POP
// result := tmp ;
22248: LD_ADDR_VAR 0 5
22252: PUSH
22253: LD_VAR 0 8
22257: ST_TO_ADDR
// end ; end ;
22258: LD_VAR 0 5
22262: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22263: LD_INT 0
22265: PPUSH
22266: PPUSH
22267: PPUSH
22268: PPUSH
// if not list then
22269: LD_VAR 0 3
22273: NOT
22274: IFFALSE 22278
// exit ;
22276: GO 22666
// result := [ ] ;
22278: LD_ADDR_VAR 0 6
22282: PUSH
22283: EMPTY
22284: ST_TO_ADDR
// for i in list do
22285: LD_ADDR_VAR 0 7
22289: PUSH
22290: LD_VAR 0 3
22294: PUSH
22295: FOR_IN
22296: IFFALSE 22498
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22298: LD_ADDR_VAR 0 9
22302: PUSH
22303: LD_VAR 0 7
22307: PPUSH
22308: LD_VAR 0 1
22312: PPUSH
22313: LD_VAR 0 2
22317: PPUSH
22318: CALL_OW 297
22322: ST_TO_ADDR
// if not result then
22323: LD_VAR 0 6
22327: NOT
22328: IFFALSE 22354
// result := [ [ i , tmp ] ] else
22330: LD_ADDR_VAR 0 6
22334: PUSH
22335: LD_VAR 0 7
22339: PUSH
22340: LD_VAR 0 9
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: PUSH
22349: EMPTY
22350: LIST
22351: ST_TO_ADDR
22352: GO 22496
// begin if result [ result ] [ 2 ] < tmp then
22354: LD_VAR 0 6
22358: PUSH
22359: LD_VAR 0 6
22363: ARRAY
22364: PUSH
22365: LD_INT 2
22367: ARRAY
22368: PUSH
22369: LD_VAR 0 9
22373: LESS
22374: IFFALSE 22416
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
22376: LD_ADDR_VAR 0 6
22380: PUSH
22381: LD_VAR 0 6
22385: PPUSH
22386: LD_VAR 0 6
22390: PUSH
22391: LD_INT 1
22393: PLUS
22394: PPUSH
22395: LD_VAR 0 7
22399: PUSH
22400: LD_VAR 0 9
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PPUSH
22409: CALL_OW 2
22413: ST_TO_ADDR
22414: GO 22496
// for j = 1 to result do
22416: LD_ADDR_VAR 0 8
22420: PUSH
22421: DOUBLE
22422: LD_INT 1
22424: DEC
22425: ST_TO_ADDR
22426: LD_VAR 0 6
22430: PUSH
22431: FOR_TO
22432: IFFALSE 22494
// begin if tmp < result [ j ] [ 2 ] then
22434: LD_VAR 0 9
22438: PUSH
22439: LD_VAR 0 6
22443: PUSH
22444: LD_VAR 0 8
22448: ARRAY
22449: PUSH
22450: LD_INT 2
22452: ARRAY
22453: LESS
22454: IFFALSE 22492
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22456: LD_ADDR_VAR 0 6
22460: PUSH
22461: LD_VAR 0 6
22465: PPUSH
22466: LD_VAR 0 8
22470: PPUSH
22471: LD_VAR 0 7
22475: PUSH
22476: LD_VAR 0 9
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: PPUSH
22485: CALL_OW 2
22489: ST_TO_ADDR
// break ;
22490: GO 22494
// end ; end ;
22492: GO 22431
22494: POP
22495: POP
// end ; end ;
22496: GO 22295
22498: POP
22499: POP
// if result and not asc then
22500: LD_VAR 0 6
22504: PUSH
22505: LD_VAR 0 4
22509: NOT
22510: AND
22511: IFFALSE 22586
// begin tmp := result ;
22513: LD_ADDR_VAR 0 9
22517: PUSH
22518: LD_VAR 0 6
22522: ST_TO_ADDR
// for i = tmp downto 1 do
22523: LD_ADDR_VAR 0 7
22527: PUSH
22528: DOUBLE
22529: LD_VAR 0 9
22533: INC
22534: ST_TO_ADDR
22535: LD_INT 1
22537: PUSH
22538: FOR_DOWNTO
22539: IFFALSE 22584
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22541: LD_ADDR_VAR 0 6
22545: PUSH
22546: LD_VAR 0 6
22550: PPUSH
22551: LD_VAR 0 9
22555: PUSH
22556: LD_VAR 0 7
22560: MINUS
22561: PUSH
22562: LD_INT 1
22564: PLUS
22565: PPUSH
22566: LD_VAR 0 9
22570: PUSH
22571: LD_VAR 0 7
22575: ARRAY
22576: PPUSH
22577: CALL_OW 1
22581: ST_TO_ADDR
22582: GO 22538
22584: POP
22585: POP
// end ; tmp := [ ] ;
22586: LD_ADDR_VAR 0 9
22590: PUSH
22591: EMPTY
22592: ST_TO_ADDR
// if mode then
22593: LD_VAR 0 5
22597: IFFALSE 22666
// begin for i = 1 to result do
22599: LD_ADDR_VAR 0 7
22603: PUSH
22604: DOUBLE
22605: LD_INT 1
22607: DEC
22608: ST_TO_ADDR
22609: LD_VAR 0 6
22613: PUSH
22614: FOR_TO
22615: IFFALSE 22654
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22617: LD_ADDR_VAR 0 9
22621: PUSH
22622: LD_VAR 0 9
22626: PPUSH
22627: LD_VAR 0 7
22631: PPUSH
22632: LD_VAR 0 6
22636: PUSH
22637: LD_VAR 0 7
22641: ARRAY
22642: PUSH
22643: LD_INT 1
22645: ARRAY
22646: PPUSH
22647: CALL_OW 1
22651: ST_TO_ADDR
22652: GO 22614
22654: POP
22655: POP
// result := tmp ;
22656: LD_ADDR_VAR 0 6
22660: PUSH
22661: LD_VAR 0 9
22665: ST_TO_ADDR
// end ; end ;
22666: LD_VAR 0 6
22670: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22671: LD_INT 0
22673: PPUSH
22674: PPUSH
22675: PPUSH
22676: PPUSH
22677: PPUSH
22678: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22679: LD_ADDR_VAR 0 5
22683: PUSH
22684: LD_INT 0
22686: PUSH
22687: LD_INT 0
22689: PUSH
22690: LD_INT 0
22692: PUSH
22693: EMPTY
22694: PUSH
22695: EMPTY
22696: LIST
22697: LIST
22698: LIST
22699: LIST
22700: ST_TO_ADDR
// if not x or not y then
22701: LD_VAR 0 2
22705: NOT
22706: PUSH
22707: LD_VAR 0 3
22711: NOT
22712: OR
22713: IFFALSE 22717
// exit ;
22715: GO 24367
// if not range then
22717: LD_VAR 0 4
22721: NOT
22722: IFFALSE 22732
// range := 10 ;
22724: LD_ADDR_VAR 0 4
22728: PUSH
22729: LD_INT 10
22731: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22732: LD_ADDR_VAR 0 8
22736: PUSH
22737: LD_INT 81
22739: PUSH
22740: LD_VAR 0 1
22744: PUSH
22745: EMPTY
22746: LIST
22747: LIST
22748: PUSH
22749: LD_INT 92
22751: PUSH
22752: LD_VAR 0 2
22756: PUSH
22757: LD_VAR 0 3
22761: PUSH
22762: LD_VAR 0 4
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: PUSH
22773: LD_INT 3
22775: PUSH
22776: LD_INT 21
22778: PUSH
22779: LD_INT 3
22781: PUSH
22782: EMPTY
22783: LIST
22784: LIST
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: PPUSH
22795: CALL_OW 69
22799: ST_TO_ADDR
// if not tmp then
22800: LD_VAR 0 8
22804: NOT
22805: IFFALSE 22809
// exit ;
22807: GO 24367
// for i in tmp do
22809: LD_ADDR_VAR 0 6
22813: PUSH
22814: LD_VAR 0 8
22818: PUSH
22819: FOR_IN
22820: IFFALSE 24342
// begin points := [ 0 , 0 , 0 ] ;
22822: LD_ADDR_VAR 0 9
22826: PUSH
22827: LD_INT 0
22829: PUSH
22830: LD_INT 0
22832: PUSH
22833: LD_INT 0
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: LIST
22840: ST_TO_ADDR
// bpoints := 1 ;
22841: LD_ADDR_VAR 0 10
22845: PUSH
22846: LD_INT 1
22848: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22849: LD_VAR 0 6
22853: PPUSH
22854: CALL_OW 247
22858: PUSH
22859: LD_INT 1
22861: DOUBLE
22862: EQUAL
22863: IFTRUE 22867
22865: GO 23445
22867: POP
// begin if GetClass ( i ) = 1 then
22868: LD_VAR 0 6
22872: PPUSH
22873: CALL_OW 257
22877: PUSH
22878: LD_INT 1
22880: EQUAL
22881: IFFALSE 22902
// points := [ 10 , 5 , 3 ] ;
22883: LD_ADDR_VAR 0 9
22887: PUSH
22888: LD_INT 10
22890: PUSH
22891: LD_INT 5
22893: PUSH
22894: LD_INT 3
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: LIST
22901: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22902: LD_VAR 0 6
22906: PPUSH
22907: CALL_OW 257
22911: PUSH
22912: LD_INT 2
22914: PUSH
22915: LD_INT 3
22917: PUSH
22918: LD_INT 4
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: LIST
22925: IN
22926: IFFALSE 22947
// points := [ 3 , 2 , 1 ] ;
22928: LD_ADDR_VAR 0 9
22932: PUSH
22933: LD_INT 3
22935: PUSH
22936: LD_INT 2
22938: PUSH
22939: LD_INT 1
22941: PUSH
22942: EMPTY
22943: LIST
22944: LIST
22945: LIST
22946: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22947: LD_VAR 0 6
22951: PPUSH
22952: CALL_OW 257
22956: PUSH
22957: LD_INT 5
22959: EQUAL
22960: IFFALSE 22981
// points := [ 130 , 5 , 2 ] ;
22962: LD_ADDR_VAR 0 9
22966: PUSH
22967: LD_INT 130
22969: PUSH
22970: LD_INT 5
22972: PUSH
22973: LD_INT 2
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: LIST
22980: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22981: LD_VAR 0 6
22985: PPUSH
22986: CALL_OW 257
22990: PUSH
22991: LD_INT 8
22993: EQUAL
22994: IFFALSE 23015
// points := [ 35 , 35 , 30 ] ;
22996: LD_ADDR_VAR 0 9
23000: PUSH
23001: LD_INT 35
23003: PUSH
23004: LD_INT 35
23006: PUSH
23007: LD_INT 30
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: LIST
23014: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23015: LD_VAR 0 6
23019: PPUSH
23020: CALL_OW 257
23024: PUSH
23025: LD_INT 9
23027: EQUAL
23028: IFFALSE 23049
// points := [ 20 , 55 , 40 ] ;
23030: LD_ADDR_VAR 0 9
23034: PUSH
23035: LD_INT 20
23037: PUSH
23038: LD_INT 55
23040: PUSH
23041: LD_INT 40
23043: PUSH
23044: EMPTY
23045: LIST
23046: LIST
23047: LIST
23048: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23049: LD_VAR 0 6
23053: PPUSH
23054: CALL_OW 257
23058: PUSH
23059: LD_INT 12
23061: PUSH
23062: LD_INT 16
23064: PUSH
23065: EMPTY
23066: LIST
23067: LIST
23068: IN
23069: IFFALSE 23090
// points := [ 5 , 3 , 2 ] ;
23071: LD_ADDR_VAR 0 9
23075: PUSH
23076: LD_INT 5
23078: PUSH
23079: LD_INT 3
23081: PUSH
23082: LD_INT 2
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: LIST
23089: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23090: LD_VAR 0 6
23094: PPUSH
23095: CALL_OW 257
23099: PUSH
23100: LD_INT 17
23102: EQUAL
23103: IFFALSE 23124
// points := [ 100 , 50 , 75 ] ;
23105: LD_ADDR_VAR 0 9
23109: PUSH
23110: LD_INT 100
23112: PUSH
23113: LD_INT 50
23115: PUSH
23116: LD_INT 75
23118: PUSH
23119: EMPTY
23120: LIST
23121: LIST
23122: LIST
23123: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23124: LD_VAR 0 6
23128: PPUSH
23129: CALL_OW 257
23133: PUSH
23134: LD_INT 15
23136: EQUAL
23137: IFFALSE 23158
// points := [ 10 , 5 , 3 ] ;
23139: LD_ADDR_VAR 0 9
23143: PUSH
23144: LD_INT 10
23146: PUSH
23147: LD_INT 5
23149: PUSH
23150: LD_INT 3
23152: PUSH
23153: EMPTY
23154: LIST
23155: LIST
23156: LIST
23157: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23158: LD_VAR 0 6
23162: PPUSH
23163: CALL_OW 257
23167: PUSH
23168: LD_INT 14
23170: EQUAL
23171: IFFALSE 23192
// points := [ 10 , 0 , 0 ] ;
23173: LD_ADDR_VAR 0 9
23177: PUSH
23178: LD_INT 10
23180: PUSH
23181: LD_INT 0
23183: PUSH
23184: LD_INT 0
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: LIST
23191: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23192: LD_VAR 0 6
23196: PPUSH
23197: CALL_OW 257
23201: PUSH
23202: LD_INT 11
23204: EQUAL
23205: IFFALSE 23226
// points := [ 30 , 10 , 5 ] ;
23207: LD_ADDR_VAR 0 9
23211: PUSH
23212: LD_INT 30
23214: PUSH
23215: LD_INT 10
23217: PUSH
23218: LD_INT 5
23220: PUSH
23221: EMPTY
23222: LIST
23223: LIST
23224: LIST
23225: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23226: LD_VAR 0 1
23230: PPUSH
23231: LD_INT 5
23233: PPUSH
23234: CALL_OW 321
23238: PUSH
23239: LD_INT 2
23241: EQUAL
23242: IFFALSE 23259
// bpoints := bpoints * 1.8 ;
23244: LD_ADDR_VAR 0 10
23248: PUSH
23249: LD_VAR 0 10
23253: PUSH
23254: LD_REAL  1.80000000000000E+0000
23257: MUL
23258: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23259: LD_VAR 0 6
23263: PPUSH
23264: CALL_OW 257
23268: PUSH
23269: LD_INT 1
23271: PUSH
23272: LD_INT 2
23274: PUSH
23275: LD_INT 3
23277: PUSH
23278: LD_INT 4
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: IN
23287: PUSH
23288: LD_VAR 0 1
23292: PPUSH
23293: LD_INT 51
23295: PPUSH
23296: CALL_OW 321
23300: PUSH
23301: LD_INT 2
23303: EQUAL
23304: AND
23305: IFFALSE 23322
// bpoints := bpoints * 1.2 ;
23307: LD_ADDR_VAR 0 10
23311: PUSH
23312: LD_VAR 0 10
23316: PUSH
23317: LD_REAL  1.20000000000000E+0000
23320: MUL
23321: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23322: LD_VAR 0 6
23326: PPUSH
23327: CALL_OW 257
23331: PUSH
23332: LD_INT 5
23334: PUSH
23335: LD_INT 7
23337: PUSH
23338: LD_INT 9
23340: PUSH
23341: EMPTY
23342: LIST
23343: LIST
23344: LIST
23345: IN
23346: PUSH
23347: LD_VAR 0 1
23351: PPUSH
23352: LD_INT 52
23354: PPUSH
23355: CALL_OW 321
23359: PUSH
23360: LD_INT 2
23362: EQUAL
23363: AND
23364: IFFALSE 23381
// bpoints := bpoints * 1.5 ;
23366: LD_ADDR_VAR 0 10
23370: PUSH
23371: LD_VAR 0 10
23375: PUSH
23376: LD_REAL  1.50000000000000E+0000
23379: MUL
23380: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
23381: LD_VAR 0 1
23385: PPUSH
23386: LD_INT 66
23388: PPUSH
23389: CALL_OW 321
23393: PUSH
23394: LD_INT 2
23396: EQUAL
23397: IFFALSE 23414
// bpoints := bpoints * 1.1 ;
23399: LD_ADDR_VAR 0 10
23403: PUSH
23404: LD_VAR 0 10
23408: PUSH
23409: LD_REAL  1.10000000000000E+0000
23412: MUL
23413: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
23414: LD_ADDR_VAR 0 10
23418: PUSH
23419: LD_VAR 0 10
23423: PUSH
23424: LD_VAR 0 6
23428: PPUSH
23429: LD_INT 1
23431: PPUSH
23432: CALL_OW 259
23436: PUSH
23437: LD_REAL  1.15000000000000E+0000
23440: MUL
23441: MUL
23442: ST_TO_ADDR
// end ; unit_vehicle :
23443: GO 24271
23445: LD_INT 2
23447: DOUBLE
23448: EQUAL
23449: IFTRUE 23453
23451: GO 24259
23453: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23454: LD_VAR 0 6
23458: PPUSH
23459: CALL_OW 264
23463: PUSH
23464: LD_INT 2
23466: PUSH
23467: LD_INT 42
23469: PUSH
23470: LD_INT 24
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: LIST
23477: IN
23478: IFFALSE 23499
// points := [ 25 , 5 , 3 ] ;
23480: LD_ADDR_VAR 0 9
23484: PUSH
23485: LD_INT 25
23487: PUSH
23488: LD_INT 5
23490: PUSH
23491: LD_INT 3
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: LIST
23498: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23499: LD_VAR 0 6
23503: PPUSH
23504: CALL_OW 264
23508: PUSH
23509: LD_INT 4
23511: PUSH
23512: LD_INT 43
23514: PUSH
23515: LD_INT 25
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: LIST
23522: IN
23523: IFFALSE 23544
// points := [ 40 , 15 , 5 ] ;
23525: LD_ADDR_VAR 0 9
23529: PUSH
23530: LD_INT 40
23532: PUSH
23533: LD_INT 15
23535: PUSH
23536: LD_INT 5
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: LIST
23543: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23544: LD_VAR 0 6
23548: PPUSH
23549: CALL_OW 264
23553: PUSH
23554: LD_INT 3
23556: PUSH
23557: LD_INT 23
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: IN
23564: IFFALSE 23585
// points := [ 7 , 25 , 8 ] ;
23566: LD_ADDR_VAR 0 9
23570: PUSH
23571: LD_INT 7
23573: PUSH
23574: LD_INT 25
23576: PUSH
23577: LD_INT 8
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: LIST
23584: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23585: LD_VAR 0 6
23589: PPUSH
23590: CALL_OW 264
23594: PUSH
23595: LD_INT 5
23597: PUSH
23598: LD_INT 27
23600: PUSH
23601: LD_INT 44
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: LIST
23608: IN
23609: IFFALSE 23630
// points := [ 14 , 50 , 16 ] ;
23611: LD_ADDR_VAR 0 9
23615: PUSH
23616: LD_INT 14
23618: PUSH
23619: LD_INT 50
23621: PUSH
23622: LD_INT 16
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: LIST
23629: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23630: LD_VAR 0 6
23634: PPUSH
23635: CALL_OW 264
23639: PUSH
23640: LD_INT 6
23642: PUSH
23643: LD_INT 46
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: IN
23650: IFFALSE 23671
// points := [ 32 , 120 , 70 ] ;
23652: LD_ADDR_VAR 0 9
23656: PUSH
23657: LD_INT 32
23659: PUSH
23660: LD_INT 120
23662: PUSH
23663: LD_INT 70
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: LIST
23670: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23671: LD_VAR 0 6
23675: PPUSH
23676: CALL_OW 264
23680: PUSH
23681: LD_INT 7
23683: PUSH
23684: LD_INT 28
23686: PUSH
23687: LD_INT 45
23689: PUSH
23690: LD_INT 92
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: IN
23699: IFFALSE 23720
// points := [ 35 , 20 , 45 ] ;
23701: LD_ADDR_VAR 0 9
23705: PUSH
23706: LD_INT 35
23708: PUSH
23709: LD_INT 20
23711: PUSH
23712: LD_INT 45
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: LIST
23719: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23720: LD_VAR 0 6
23724: PPUSH
23725: CALL_OW 264
23729: PUSH
23730: LD_INT 47
23732: PUSH
23733: EMPTY
23734: LIST
23735: IN
23736: IFFALSE 23757
// points := [ 67 , 45 , 75 ] ;
23738: LD_ADDR_VAR 0 9
23742: PUSH
23743: LD_INT 67
23745: PUSH
23746: LD_INT 45
23748: PUSH
23749: LD_INT 75
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: LIST
23756: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23757: LD_VAR 0 6
23761: PPUSH
23762: CALL_OW 264
23766: PUSH
23767: LD_INT 26
23769: PUSH
23770: EMPTY
23771: LIST
23772: IN
23773: IFFALSE 23794
// points := [ 120 , 30 , 80 ] ;
23775: LD_ADDR_VAR 0 9
23779: PUSH
23780: LD_INT 120
23782: PUSH
23783: LD_INT 30
23785: PUSH
23786: LD_INT 80
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: LIST
23793: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23794: LD_VAR 0 6
23798: PPUSH
23799: CALL_OW 264
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: EMPTY
23808: LIST
23809: IN
23810: IFFALSE 23831
// points := [ 40 , 1 , 1 ] ;
23812: LD_ADDR_VAR 0 9
23816: PUSH
23817: LD_INT 40
23819: PUSH
23820: LD_INT 1
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: LIST
23830: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23831: LD_VAR 0 6
23835: PPUSH
23836: CALL_OW 264
23840: PUSH
23841: LD_INT 29
23843: PUSH
23844: EMPTY
23845: LIST
23846: IN
23847: IFFALSE 23868
// points := [ 70 , 200 , 400 ] ;
23849: LD_ADDR_VAR 0 9
23853: PUSH
23854: LD_INT 70
23856: PUSH
23857: LD_INT 200
23859: PUSH
23860: LD_INT 400
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: LIST
23867: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23868: LD_VAR 0 6
23872: PPUSH
23873: CALL_OW 264
23877: PUSH
23878: LD_INT 14
23880: PUSH
23881: LD_INT 53
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: IN
23888: IFFALSE 23909
// points := [ 40 , 10 , 20 ] ;
23890: LD_ADDR_VAR 0 9
23894: PUSH
23895: LD_INT 40
23897: PUSH
23898: LD_INT 10
23900: PUSH
23901: LD_INT 20
23903: PUSH
23904: EMPTY
23905: LIST
23906: LIST
23907: LIST
23908: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23909: LD_VAR 0 6
23913: PPUSH
23914: CALL_OW 264
23918: PUSH
23919: LD_INT 9
23921: PUSH
23922: EMPTY
23923: LIST
23924: IN
23925: IFFALSE 23946
// points := [ 5 , 70 , 20 ] ;
23927: LD_ADDR_VAR 0 9
23931: PUSH
23932: LD_INT 5
23934: PUSH
23935: LD_INT 70
23937: PUSH
23938: LD_INT 20
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23946: LD_VAR 0 6
23950: PPUSH
23951: CALL_OW 264
23955: PUSH
23956: LD_INT 10
23958: PUSH
23959: EMPTY
23960: LIST
23961: IN
23962: IFFALSE 23983
// points := [ 35 , 110 , 70 ] ;
23964: LD_ADDR_VAR 0 9
23968: PUSH
23969: LD_INT 35
23971: PUSH
23972: LD_INT 110
23974: PUSH
23975: LD_INT 70
23977: PUSH
23978: EMPTY
23979: LIST
23980: LIST
23981: LIST
23982: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23983: LD_VAR 0 6
23987: PPUSH
23988: CALL_OW 265
23992: PUSH
23993: LD_INT 25
23995: EQUAL
23996: IFFALSE 24017
// points := [ 80 , 65 , 100 ] ;
23998: LD_ADDR_VAR 0 9
24002: PUSH
24003: LD_INT 80
24005: PUSH
24006: LD_INT 65
24008: PUSH
24009: LD_INT 100
24011: PUSH
24012: EMPTY
24013: LIST
24014: LIST
24015: LIST
24016: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24017: LD_VAR 0 6
24021: PPUSH
24022: CALL_OW 263
24026: PUSH
24027: LD_INT 1
24029: EQUAL
24030: IFFALSE 24065
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24032: LD_ADDR_VAR 0 10
24036: PUSH
24037: LD_VAR 0 10
24041: PUSH
24042: LD_VAR 0 6
24046: PPUSH
24047: CALL_OW 311
24051: PPUSH
24052: LD_INT 3
24054: PPUSH
24055: CALL_OW 259
24059: PUSH
24060: LD_INT 4
24062: MUL
24063: MUL
24064: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24065: LD_VAR 0 6
24069: PPUSH
24070: CALL_OW 263
24074: PUSH
24075: LD_INT 2
24077: EQUAL
24078: IFFALSE 24129
// begin j := IsControledBy ( i ) ;
24080: LD_ADDR_VAR 0 7
24084: PUSH
24085: LD_VAR 0 6
24089: PPUSH
24090: CALL_OW 312
24094: ST_TO_ADDR
// if j then
24095: LD_VAR 0 7
24099: IFFALSE 24129
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24101: LD_ADDR_VAR 0 10
24105: PUSH
24106: LD_VAR 0 10
24110: PUSH
24111: LD_VAR 0 7
24115: PPUSH
24116: LD_INT 3
24118: PPUSH
24119: CALL_OW 259
24123: PUSH
24124: LD_INT 3
24126: MUL
24127: MUL
24128: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24129: LD_VAR 0 6
24133: PPUSH
24134: CALL_OW 264
24138: PUSH
24139: LD_INT 5
24141: PUSH
24142: LD_INT 6
24144: PUSH
24145: LD_INT 46
24147: PUSH
24148: LD_INT 44
24150: PUSH
24151: LD_INT 47
24153: PUSH
24154: LD_INT 45
24156: PUSH
24157: LD_INT 28
24159: PUSH
24160: LD_INT 7
24162: PUSH
24163: LD_INT 27
24165: PUSH
24166: LD_INT 29
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: LIST
24173: LIST
24174: LIST
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: IN
24181: PUSH
24182: LD_VAR 0 1
24186: PPUSH
24187: LD_INT 52
24189: PPUSH
24190: CALL_OW 321
24194: PUSH
24195: LD_INT 2
24197: EQUAL
24198: AND
24199: IFFALSE 24216
// bpoints := bpoints * 1.2 ;
24201: LD_ADDR_VAR 0 10
24205: PUSH
24206: LD_VAR 0 10
24210: PUSH
24211: LD_REAL  1.20000000000000E+0000
24214: MUL
24215: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24216: LD_VAR 0 6
24220: PPUSH
24221: CALL_OW 264
24225: PUSH
24226: LD_INT 6
24228: PUSH
24229: LD_INT 46
24231: PUSH
24232: LD_INT 47
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: LIST
24239: IN
24240: IFFALSE 24257
// bpoints := bpoints * 1.2 ;
24242: LD_ADDR_VAR 0 10
24246: PUSH
24247: LD_VAR 0 10
24251: PUSH
24252: LD_REAL  1.20000000000000E+0000
24255: MUL
24256: ST_TO_ADDR
// end ; unit_building :
24257: GO 24271
24259: LD_INT 3
24261: DOUBLE
24262: EQUAL
24263: IFTRUE 24267
24265: GO 24270
24267: POP
// ; end ;
24268: GO 24271
24270: POP
// for j = 1 to 3 do
24271: LD_ADDR_VAR 0 7
24275: PUSH
24276: DOUBLE
24277: LD_INT 1
24279: DEC
24280: ST_TO_ADDR
24281: LD_INT 3
24283: PUSH
24284: FOR_TO
24285: IFFALSE 24338
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24287: LD_ADDR_VAR 0 5
24291: PUSH
24292: LD_VAR 0 5
24296: PPUSH
24297: LD_VAR 0 7
24301: PPUSH
24302: LD_VAR 0 5
24306: PUSH
24307: LD_VAR 0 7
24311: ARRAY
24312: PUSH
24313: LD_VAR 0 9
24317: PUSH
24318: LD_VAR 0 7
24322: ARRAY
24323: PUSH
24324: LD_VAR 0 10
24328: MUL
24329: PLUS
24330: PPUSH
24331: CALL_OW 1
24335: ST_TO_ADDR
24336: GO 24284
24338: POP
24339: POP
// end ;
24340: GO 22819
24342: POP
24343: POP
// result := Replace ( result , 4 , tmp ) ;
24344: LD_ADDR_VAR 0 5
24348: PUSH
24349: LD_VAR 0 5
24353: PPUSH
24354: LD_INT 4
24356: PPUSH
24357: LD_VAR 0 8
24361: PPUSH
24362: CALL_OW 1
24366: ST_TO_ADDR
// end ;
24367: LD_VAR 0 5
24371: RET
// export function DangerAtRange ( unit , range ) ; begin
24372: LD_INT 0
24374: PPUSH
// if not unit then
24375: LD_VAR 0 1
24379: NOT
24380: IFFALSE 24384
// exit ;
24382: GO 24429
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
24384: LD_ADDR_VAR 0 3
24388: PUSH
24389: LD_VAR 0 1
24393: PPUSH
24394: CALL_OW 255
24398: PPUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 250
24408: PPUSH
24409: LD_VAR 0 1
24413: PPUSH
24414: CALL_OW 251
24418: PPUSH
24419: LD_VAR 0 2
24423: PPUSH
24424: CALL 22671 0 4
24428: ST_TO_ADDR
// end ;
24429: LD_VAR 0 3
24433: RET
// export function DangerInArea ( side , area ) ; begin
24434: LD_INT 0
24436: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24437: LD_ADDR_VAR 0 3
24441: PUSH
24442: LD_VAR 0 2
24446: PPUSH
24447: LD_INT 81
24449: PUSH
24450: LD_VAR 0 1
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 70
24463: ST_TO_ADDR
// end ;
24464: LD_VAR 0 3
24468: RET
// export function IsExtension ( b ) ; begin
24469: LD_INT 0
24471: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24472: LD_ADDR_VAR 0 2
24476: PUSH
24477: LD_VAR 0 1
24481: PUSH
24482: LD_INT 23
24484: PUSH
24485: LD_INT 20
24487: PUSH
24488: LD_INT 22
24490: PUSH
24491: LD_INT 17
24493: PUSH
24494: LD_INT 24
24496: PUSH
24497: LD_INT 21
24499: PUSH
24500: LD_INT 19
24502: PUSH
24503: LD_INT 16
24505: PUSH
24506: LD_INT 25
24508: PUSH
24509: LD_INT 18
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: LIST
24521: LIST
24522: LIST
24523: IN
24524: ST_TO_ADDR
// end ;
24525: LD_VAR 0 2
24529: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24530: LD_INT 0
24532: PPUSH
24533: PPUSH
24534: PPUSH
// result := [ ] ;
24535: LD_ADDR_VAR 0 4
24539: PUSH
24540: EMPTY
24541: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24542: LD_ADDR_VAR 0 5
24546: PUSH
24547: LD_VAR 0 2
24551: PPUSH
24552: LD_INT 21
24554: PUSH
24555: LD_INT 3
24557: PUSH
24558: EMPTY
24559: LIST
24560: LIST
24561: PPUSH
24562: CALL_OW 70
24566: ST_TO_ADDR
// if not tmp then
24567: LD_VAR 0 5
24571: NOT
24572: IFFALSE 24576
// exit ;
24574: GO 24640
// if checkLink then
24576: LD_VAR 0 3
24580: IFFALSE 24630
// begin for i in tmp do
24582: LD_ADDR_VAR 0 6
24586: PUSH
24587: LD_VAR 0 5
24591: PUSH
24592: FOR_IN
24593: IFFALSE 24628
// if GetBase ( i ) <> base then
24595: LD_VAR 0 6
24599: PPUSH
24600: CALL_OW 274
24604: PUSH
24605: LD_VAR 0 1
24609: NONEQUAL
24610: IFFALSE 24626
// ComLinkToBase ( base , i ) ;
24612: LD_VAR 0 1
24616: PPUSH
24617: LD_VAR 0 6
24621: PPUSH
24622: CALL_OW 169
24626: GO 24592
24628: POP
24629: POP
// end ; result := tmp ;
24630: LD_ADDR_VAR 0 4
24634: PUSH
24635: LD_VAR 0 5
24639: ST_TO_ADDR
// end ;
24640: LD_VAR 0 4
24644: RET
// export function ComComplete ( units , b ) ; var i ; begin
24645: LD_INT 0
24647: PPUSH
24648: PPUSH
// if not units then
24649: LD_VAR 0 1
24653: NOT
24654: IFFALSE 24658
// exit ;
24656: GO 24748
// for i in units do
24658: LD_ADDR_VAR 0 4
24662: PUSH
24663: LD_VAR 0 1
24667: PUSH
24668: FOR_IN
24669: IFFALSE 24746
// if BuildingStatus ( b ) = bs_build then
24671: LD_VAR 0 2
24675: PPUSH
24676: CALL_OW 461
24680: PUSH
24681: LD_INT 1
24683: EQUAL
24684: IFFALSE 24744
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24686: LD_VAR 0 4
24690: PPUSH
24691: LD_STRING h
24693: PUSH
24694: LD_VAR 0 2
24698: PPUSH
24699: CALL_OW 250
24703: PUSH
24704: LD_VAR 0 2
24708: PPUSH
24709: CALL_OW 251
24713: PUSH
24714: LD_VAR 0 2
24718: PUSH
24719: LD_INT 0
24721: PUSH
24722: LD_INT 0
24724: PUSH
24725: LD_INT 0
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: LIST
24733: LIST
24734: LIST
24735: LIST
24736: PUSH
24737: EMPTY
24738: LIST
24739: PPUSH
24740: CALL_OW 446
24744: GO 24668
24746: POP
24747: POP
// end ;
24748: LD_VAR 0 3
24752: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24753: LD_INT 0
24755: PPUSH
24756: PPUSH
24757: PPUSH
24758: PPUSH
24759: PPUSH
24760: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24761: LD_VAR 0 1
24765: NOT
24766: PUSH
24767: LD_VAR 0 1
24771: PPUSH
24772: CALL_OW 263
24776: PUSH
24777: LD_INT 2
24779: NONEQUAL
24780: OR
24781: IFFALSE 24785
// exit ;
24783: GO 25101
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24785: LD_ADDR_VAR 0 6
24789: PUSH
24790: LD_INT 22
24792: PUSH
24793: LD_VAR 0 1
24797: PPUSH
24798: CALL_OW 255
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 2
24809: PUSH
24810: LD_INT 30
24812: PUSH
24813: LD_INT 36
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: LD_INT 34
24822: PUSH
24823: LD_INT 31
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PPUSH
24839: CALL_OW 69
24843: ST_TO_ADDR
// if not tmp then
24844: LD_VAR 0 6
24848: NOT
24849: IFFALSE 24853
// exit ;
24851: GO 25101
// result := [ ] ;
24853: LD_ADDR_VAR 0 2
24857: PUSH
24858: EMPTY
24859: ST_TO_ADDR
// for i in tmp do
24860: LD_ADDR_VAR 0 3
24864: PUSH
24865: LD_VAR 0 6
24869: PUSH
24870: FOR_IN
24871: IFFALSE 24942
// begin t := UnitsInside ( i ) ;
24873: LD_ADDR_VAR 0 4
24877: PUSH
24878: LD_VAR 0 3
24882: PPUSH
24883: CALL_OW 313
24887: ST_TO_ADDR
// if t then
24888: LD_VAR 0 4
24892: IFFALSE 24940
// for j in t do
24894: LD_ADDR_VAR 0 7
24898: PUSH
24899: LD_VAR 0 4
24903: PUSH
24904: FOR_IN
24905: IFFALSE 24938
// result := Replace ( result , result + 1 , j ) ;
24907: LD_ADDR_VAR 0 2
24911: PUSH
24912: LD_VAR 0 2
24916: PPUSH
24917: LD_VAR 0 2
24921: PUSH
24922: LD_INT 1
24924: PLUS
24925: PPUSH
24926: LD_VAR 0 7
24930: PPUSH
24931: CALL_OW 1
24935: ST_TO_ADDR
24936: GO 24904
24938: POP
24939: POP
// end ;
24940: GO 24870
24942: POP
24943: POP
// if not result then
24944: LD_VAR 0 2
24948: NOT
24949: IFFALSE 24953
// exit ;
24951: GO 25101
// mech := result [ 1 ] ;
24953: LD_ADDR_VAR 0 5
24957: PUSH
24958: LD_VAR 0 2
24962: PUSH
24963: LD_INT 1
24965: ARRAY
24966: ST_TO_ADDR
// if result > 1 then
24967: LD_VAR 0 2
24971: PUSH
24972: LD_INT 1
24974: GREATER
24975: IFFALSE 25087
// begin for i = 2 to result do
24977: LD_ADDR_VAR 0 3
24981: PUSH
24982: DOUBLE
24983: LD_INT 2
24985: DEC
24986: ST_TO_ADDR
24987: LD_VAR 0 2
24991: PUSH
24992: FOR_TO
24993: IFFALSE 25085
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24995: LD_ADDR_VAR 0 4
24999: PUSH
25000: LD_VAR 0 2
25004: PUSH
25005: LD_VAR 0 3
25009: ARRAY
25010: PPUSH
25011: LD_INT 3
25013: PPUSH
25014: CALL_OW 259
25018: PUSH
25019: LD_VAR 0 2
25023: PUSH
25024: LD_VAR 0 3
25028: ARRAY
25029: PPUSH
25030: CALL_OW 432
25034: MINUS
25035: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25036: LD_VAR 0 4
25040: PUSH
25041: LD_VAR 0 5
25045: PPUSH
25046: LD_INT 3
25048: PPUSH
25049: CALL_OW 259
25053: PUSH
25054: LD_VAR 0 5
25058: PPUSH
25059: CALL_OW 432
25063: MINUS
25064: GREATEREQUAL
25065: IFFALSE 25083
// mech := result [ i ] ;
25067: LD_ADDR_VAR 0 5
25071: PUSH
25072: LD_VAR 0 2
25076: PUSH
25077: LD_VAR 0 3
25081: ARRAY
25082: ST_TO_ADDR
// end ;
25083: GO 24992
25085: POP
25086: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25087: LD_VAR 0 1
25091: PPUSH
25092: LD_VAR 0 5
25096: PPUSH
25097: CALL_OW 135
// end ;
25101: LD_VAR 0 2
25105: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25106: LD_INT 0
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
// result := [ ] ;
25121: LD_ADDR_VAR 0 7
25125: PUSH
25126: EMPTY
25127: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25128: LD_VAR 0 1
25132: PPUSH
25133: CALL_OW 266
25137: PUSH
25138: LD_INT 0
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: IN
25148: NOT
25149: IFFALSE 25153
// exit ;
25151: GO 26787
// if name then
25153: LD_VAR 0 3
25157: IFFALSE 25173
// SetBName ( base_dep , name ) ;
25159: LD_VAR 0 1
25163: PPUSH
25164: LD_VAR 0 3
25168: PPUSH
25169: CALL_OW 500
// base := GetBase ( base_dep ) ;
25173: LD_ADDR_VAR 0 15
25177: PUSH
25178: LD_VAR 0 1
25182: PPUSH
25183: CALL_OW 274
25187: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25188: LD_ADDR_VAR 0 16
25192: PUSH
25193: LD_VAR 0 1
25197: PPUSH
25198: CALL_OW 255
25202: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25203: LD_ADDR_VAR 0 17
25207: PUSH
25208: LD_VAR 0 1
25212: PPUSH
25213: CALL_OW 248
25217: ST_TO_ADDR
// if sources then
25218: LD_VAR 0 5
25222: IFFALSE 25269
// for i = 1 to 3 do
25224: LD_ADDR_VAR 0 8
25228: PUSH
25229: DOUBLE
25230: LD_INT 1
25232: DEC
25233: ST_TO_ADDR
25234: LD_INT 3
25236: PUSH
25237: FOR_TO
25238: IFFALSE 25267
// AddResourceType ( base , i , sources [ i ] ) ;
25240: LD_VAR 0 15
25244: PPUSH
25245: LD_VAR 0 8
25249: PPUSH
25250: LD_VAR 0 5
25254: PUSH
25255: LD_VAR 0 8
25259: ARRAY
25260: PPUSH
25261: CALL_OW 276
25265: GO 25237
25267: POP
25268: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25269: LD_ADDR_VAR 0 18
25273: PUSH
25274: LD_VAR 0 15
25278: PPUSH
25279: LD_VAR 0 2
25283: PPUSH
25284: LD_INT 1
25286: PPUSH
25287: CALL 24530 0 3
25291: ST_TO_ADDR
// InitHc ;
25292: CALL_OW 19
// InitUc ;
25296: CALL_OW 18
// uc_side := side ;
25300: LD_ADDR_OWVAR 20
25304: PUSH
25305: LD_VAR 0 16
25309: ST_TO_ADDR
// uc_nation := nation ;
25310: LD_ADDR_OWVAR 21
25314: PUSH
25315: LD_VAR 0 17
25319: ST_TO_ADDR
// if buildings then
25320: LD_VAR 0 18
25324: IFFALSE 26646
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25326: LD_ADDR_VAR 0 19
25330: PUSH
25331: LD_VAR 0 18
25335: PPUSH
25336: LD_INT 2
25338: PUSH
25339: LD_INT 30
25341: PUSH
25342: LD_INT 29
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: LD_INT 30
25351: PUSH
25352: LD_INT 30
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: LIST
25363: PPUSH
25364: CALL_OW 72
25368: ST_TO_ADDR
// if tmp then
25369: LD_VAR 0 19
25373: IFFALSE 25421
// for i in tmp do
25375: LD_ADDR_VAR 0 8
25379: PUSH
25380: LD_VAR 0 19
25384: PUSH
25385: FOR_IN
25386: IFFALSE 25419
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
25388: LD_VAR 0 8
25392: PPUSH
25393: CALL_OW 250
25397: PPUSH
25398: LD_VAR 0 8
25402: PPUSH
25403: CALL_OW 251
25407: PPUSH
25408: LD_VAR 0 16
25412: PPUSH
25413: CALL_OW 441
25417: GO 25385
25419: POP
25420: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
25421: LD_VAR 0 18
25425: PPUSH
25426: LD_INT 2
25428: PUSH
25429: LD_INT 30
25431: PUSH
25432: LD_INT 32
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 30
25441: PUSH
25442: LD_INT 33
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: LIST
25453: PPUSH
25454: CALL_OW 72
25458: IFFALSE 25546
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25460: LD_ADDR_VAR 0 8
25464: PUSH
25465: LD_VAR 0 18
25469: PPUSH
25470: LD_INT 2
25472: PUSH
25473: LD_INT 30
25475: PUSH
25476: LD_INT 32
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: PUSH
25483: LD_INT 30
25485: PUSH
25486: LD_INT 33
25488: PUSH
25489: EMPTY
25490: LIST
25491: LIST
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: LIST
25497: PPUSH
25498: CALL_OW 72
25502: PUSH
25503: FOR_IN
25504: IFFALSE 25544
// begin if not GetBWeapon ( i ) then
25506: LD_VAR 0 8
25510: PPUSH
25511: CALL_OW 269
25515: NOT
25516: IFFALSE 25542
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25518: LD_VAR 0 8
25522: PPUSH
25523: LD_VAR 0 8
25527: PPUSH
25528: LD_VAR 0 2
25532: PPUSH
25533: CALL 26792 0 2
25537: PPUSH
25538: CALL_OW 431
// end ;
25542: GO 25503
25544: POP
25545: POP
// end ; for i = 1 to personel do
25546: LD_ADDR_VAR 0 8
25550: PUSH
25551: DOUBLE
25552: LD_INT 1
25554: DEC
25555: ST_TO_ADDR
25556: LD_VAR 0 6
25560: PUSH
25561: FOR_TO
25562: IFFALSE 26626
// begin if i > 4 then
25564: LD_VAR 0 8
25568: PUSH
25569: LD_INT 4
25571: GREATER
25572: IFFALSE 25576
// break ;
25574: GO 26626
// case i of 1 :
25576: LD_VAR 0 8
25580: PUSH
25581: LD_INT 1
25583: DOUBLE
25584: EQUAL
25585: IFTRUE 25589
25587: GO 25669
25589: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25590: LD_ADDR_VAR 0 12
25594: PUSH
25595: LD_VAR 0 18
25599: PPUSH
25600: LD_INT 22
25602: PUSH
25603: LD_VAR 0 16
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 58
25614: PUSH
25615: EMPTY
25616: LIST
25617: PUSH
25618: LD_INT 2
25620: PUSH
25621: LD_INT 30
25623: PUSH
25624: LD_INT 32
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 30
25633: PUSH
25634: LD_INT 4
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: LD_INT 30
25643: PUSH
25644: LD_INT 5
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PUSH
25651: EMPTY
25652: LIST
25653: LIST
25654: LIST
25655: LIST
25656: PUSH
25657: EMPTY
25658: LIST
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 72
25666: ST_TO_ADDR
25667: GO 25891
25669: LD_INT 2
25671: DOUBLE
25672: EQUAL
25673: IFTRUE 25677
25675: GO 25739
25677: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25678: LD_ADDR_VAR 0 12
25682: PUSH
25683: LD_VAR 0 18
25687: PPUSH
25688: LD_INT 22
25690: PUSH
25691: LD_VAR 0 16
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 2
25702: PUSH
25703: LD_INT 30
25705: PUSH
25706: LD_INT 0
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: LD_INT 30
25715: PUSH
25716: LD_INT 1
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: LIST
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PPUSH
25732: CALL_OW 72
25736: ST_TO_ADDR
25737: GO 25891
25739: LD_INT 3
25741: DOUBLE
25742: EQUAL
25743: IFTRUE 25747
25745: GO 25809
25747: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25748: LD_ADDR_VAR 0 12
25752: PUSH
25753: LD_VAR 0 18
25757: PPUSH
25758: LD_INT 22
25760: PUSH
25761: LD_VAR 0 16
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PUSH
25770: LD_INT 2
25772: PUSH
25773: LD_INT 30
25775: PUSH
25776: LD_INT 2
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 30
25785: PUSH
25786: LD_INT 3
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: LIST
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PPUSH
25802: CALL_OW 72
25806: ST_TO_ADDR
25807: GO 25891
25809: LD_INT 4
25811: DOUBLE
25812: EQUAL
25813: IFTRUE 25817
25815: GO 25890
25817: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25818: LD_ADDR_VAR 0 12
25822: PUSH
25823: LD_VAR 0 18
25827: PPUSH
25828: LD_INT 22
25830: PUSH
25831: LD_VAR 0 16
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 2
25842: PUSH
25843: LD_INT 30
25845: PUSH
25846: LD_INT 6
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 30
25855: PUSH
25856: LD_INT 7
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 30
25865: PUSH
25866: LD_INT 8
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: LIST
25877: LIST
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PPUSH
25883: CALL_OW 72
25887: ST_TO_ADDR
25888: GO 25891
25890: POP
// if i = 1 then
25891: LD_VAR 0 8
25895: PUSH
25896: LD_INT 1
25898: EQUAL
25899: IFFALSE 26010
// begin tmp := [ ] ;
25901: LD_ADDR_VAR 0 19
25905: PUSH
25906: EMPTY
25907: ST_TO_ADDR
// for j in f do
25908: LD_ADDR_VAR 0 9
25912: PUSH
25913: LD_VAR 0 12
25917: PUSH
25918: FOR_IN
25919: IFFALSE 25992
// if GetBType ( j ) = b_bunker then
25921: LD_VAR 0 9
25925: PPUSH
25926: CALL_OW 266
25930: PUSH
25931: LD_INT 32
25933: EQUAL
25934: IFFALSE 25961
// tmp := Insert ( tmp , 1 , j ) else
25936: LD_ADDR_VAR 0 19
25940: PUSH
25941: LD_VAR 0 19
25945: PPUSH
25946: LD_INT 1
25948: PPUSH
25949: LD_VAR 0 9
25953: PPUSH
25954: CALL_OW 2
25958: ST_TO_ADDR
25959: GO 25990
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25961: LD_ADDR_VAR 0 19
25965: PUSH
25966: LD_VAR 0 19
25970: PPUSH
25971: LD_VAR 0 19
25975: PUSH
25976: LD_INT 1
25978: PLUS
25979: PPUSH
25980: LD_VAR 0 9
25984: PPUSH
25985: CALL_OW 2
25989: ST_TO_ADDR
25990: GO 25918
25992: POP
25993: POP
// if tmp then
25994: LD_VAR 0 19
25998: IFFALSE 26010
// f := tmp ;
26000: LD_ADDR_VAR 0 12
26004: PUSH
26005: LD_VAR 0 19
26009: ST_TO_ADDR
// end ; x := personel [ i ] ;
26010: LD_ADDR_VAR 0 13
26014: PUSH
26015: LD_VAR 0 6
26019: PUSH
26020: LD_VAR 0 8
26024: ARRAY
26025: ST_TO_ADDR
// if x = - 1 then
26026: LD_VAR 0 13
26030: PUSH
26031: LD_INT 1
26033: NEG
26034: EQUAL
26035: IFFALSE 26244
// begin for j in f do
26037: LD_ADDR_VAR 0 9
26041: PUSH
26042: LD_VAR 0 12
26046: PUSH
26047: FOR_IN
26048: IFFALSE 26240
// repeat InitHc ;
26050: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26054: LD_VAR 0 9
26058: PPUSH
26059: CALL_OW 266
26063: PUSH
26064: LD_INT 5
26066: EQUAL
26067: IFFALSE 26137
// begin if UnitsInside ( j ) < 3 then
26069: LD_VAR 0 9
26073: PPUSH
26074: CALL_OW 313
26078: PUSH
26079: LD_INT 3
26081: LESS
26082: IFFALSE 26118
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26084: LD_INT 0
26086: PPUSH
26087: LD_INT 5
26089: PUSH
26090: LD_INT 8
26092: PUSH
26093: LD_INT 9
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: LD_VAR 0 17
26105: ARRAY
26106: PPUSH
26107: LD_VAR 0 4
26111: PPUSH
26112: CALL_OW 380
26116: GO 26135
// PrepareHuman ( false , i , skill ) ;
26118: LD_INT 0
26120: PPUSH
26121: LD_VAR 0 8
26125: PPUSH
26126: LD_VAR 0 4
26130: PPUSH
26131: CALL_OW 380
// end else
26135: GO 26154
// PrepareHuman ( false , i , skill ) ;
26137: LD_INT 0
26139: PPUSH
26140: LD_VAR 0 8
26144: PPUSH
26145: LD_VAR 0 4
26149: PPUSH
26150: CALL_OW 380
// un := CreateHuman ;
26154: LD_ADDR_VAR 0 14
26158: PUSH
26159: CALL_OW 44
26163: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26164: LD_ADDR_VAR 0 7
26168: PUSH
26169: LD_VAR 0 7
26173: PPUSH
26174: LD_INT 1
26176: PPUSH
26177: LD_VAR 0 14
26181: PPUSH
26182: CALL_OW 2
26186: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26187: LD_VAR 0 14
26191: PPUSH
26192: LD_VAR 0 9
26196: PPUSH
26197: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26201: LD_VAR 0 9
26205: PPUSH
26206: CALL_OW 313
26210: PUSH
26211: LD_INT 6
26213: EQUAL
26214: PUSH
26215: LD_VAR 0 9
26219: PPUSH
26220: CALL_OW 266
26224: PUSH
26225: LD_INT 32
26227: PUSH
26228: LD_INT 31
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: IN
26235: OR
26236: IFFALSE 26050
26238: GO 26047
26240: POP
26241: POP
// end else
26242: GO 26624
// for j = 1 to x do
26244: LD_ADDR_VAR 0 9
26248: PUSH
26249: DOUBLE
26250: LD_INT 1
26252: DEC
26253: ST_TO_ADDR
26254: LD_VAR 0 13
26258: PUSH
26259: FOR_TO
26260: IFFALSE 26622
// begin InitHc ;
26262: CALL_OW 19
// if not f then
26266: LD_VAR 0 12
26270: NOT
26271: IFFALSE 26360
// begin PrepareHuman ( false , i , skill ) ;
26273: LD_INT 0
26275: PPUSH
26276: LD_VAR 0 8
26280: PPUSH
26281: LD_VAR 0 4
26285: PPUSH
26286: CALL_OW 380
// un := CreateHuman ;
26290: LD_ADDR_VAR 0 14
26294: PUSH
26295: CALL_OW 44
26299: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26300: LD_ADDR_VAR 0 7
26304: PUSH
26305: LD_VAR 0 7
26309: PPUSH
26310: LD_INT 1
26312: PPUSH
26313: LD_VAR 0 14
26317: PPUSH
26318: CALL_OW 2
26322: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26323: LD_VAR 0 14
26327: PPUSH
26328: LD_VAR 0 1
26332: PPUSH
26333: CALL_OW 250
26337: PPUSH
26338: LD_VAR 0 1
26342: PPUSH
26343: CALL_OW 251
26347: PPUSH
26348: LD_INT 10
26350: PPUSH
26351: LD_INT 0
26353: PPUSH
26354: CALL_OW 50
// continue ;
26358: GO 26259
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26360: LD_VAR 0 12
26364: PUSH
26365: LD_INT 1
26367: ARRAY
26368: PPUSH
26369: CALL_OW 313
26373: PUSH
26374: LD_VAR 0 12
26378: PUSH
26379: LD_INT 1
26381: ARRAY
26382: PPUSH
26383: CALL_OW 266
26387: PUSH
26388: LD_INT 32
26390: PUSH
26391: LD_INT 31
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: IN
26398: AND
26399: PUSH
26400: LD_VAR 0 12
26404: PUSH
26405: LD_INT 1
26407: ARRAY
26408: PPUSH
26409: CALL_OW 313
26413: PUSH
26414: LD_INT 6
26416: EQUAL
26417: OR
26418: IFFALSE 26438
// f := Delete ( f , 1 ) ;
26420: LD_ADDR_VAR 0 12
26424: PUSH
26425: LD_VAR 0 12
26429: PPUSH
26430: LD_INT 1
26432: PPUSH
26433: CALL_OW 3
26437: ST_TO_ADDR
// if not f then
26438: LD_VAR 0 12
26442: NOT
26443: IFFALSE 26461
// begin x := x + 2 ;
26445: LD_ADDR_VAR 0 13
26449: PUSH
26450: LD_VAR 0 13
26454: PUSH
26455: LD_INT 2
26457: PLUS
26458: ST_TO_ADDR
// continue ;
26459: GO 26259
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26461: LD_VAR 0 12
26465: PUSH
26466: LD_INT 1
26468: ARRAY
26469: PPUSH
26470: CALL_OW 266
26474: PUSH
26475: LD_INT 5
26477: EQUAL
26478: IFFALSE 26552
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26480: LD_VAR 0 12
26484: PUSH
26485: LD_INT 1
26487: ARRAY
26488: PPUSH
26489: CALL_OW 313
26493: PUSH
26494: LD_INT 3
26496: LESS
26497: IFFALSE 26533
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26499: LD_INT 0
26501: PPUSH
26502: LD_INT 5
26504: PUSH
26505: LD_INT 8
26507: PUSH
26508: LD_INT 9
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: LIST
26515: PUSH
26516: LD_VAR 0 17
26520: ARRAY
26521: PPUSH
26522: LD_VAR 0 4
26526: PPUSH
26527: CALL_OW 380
26531: GO 26550
// PrepareHuman ( false , i , skill ) ;
26533: LD_INT 0
26535: PPUSH
26536: LD_VAR 0 8
26540: PPUSH
26541: LD_VAR 0 4
26545: PPUSH
26546: CALL_OW 380
// end else
26550: GO 26569
// PrepareHuman ( false , i , skill ) ;
26552: LD_INT 0
26554: PPUSH
26555: LD_VAR 0 8
26559: PPUSH
26560: LD_VAR 0 4
26564: PPUSH
26565: CALL_OW 380
// un := CreateHuman ;
26569: LD_ADDR_VAR 0 14
26573: PUSH
26574: CALL_OW 44
26578: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26579: LD_ADDR_VAR 0 7
26583: PUSH
26584: LD_VAR 0 7
26588: PPUSH
26589: LD_INT 1
26591: PPUSH
26592: LD_VAR 0 14
26596: PPUSH
26597: CALL_OW 2
26601: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26602: LD_VAR 0 14
26606: PPUSH
26607: LD_VAR 0 12
26611: PUSH
26612: LD_INT 1
26614: ARRAY
26615: PPUSH
26616: CALL_OW 52
// end ;
26620: GO 26259
26622: POP
26623: POP
// end ;
26624: GO 25561
26626: POP
26627: POP
// result := result ^ buildings ;
26628: LD_ADDR_VAR 0 7
26632: PUSH
26633: LD_VAR 0 7
26637: PUSH
26638: LD_VAR 0 18
26642: ADD
26643: ST_TO_ADDR
// end else
26644: GO 26787
// begin for i = 1 to personel do
26646: LD_ADDR_VAR 0 8
26650: PUSH
26651: DOUBLE
26652: LD_INT 1
26654: DEC
26655: ST_TO_ADDR
26656: LD_VAR 0 6
26660: PUSH
26661: FOR_TO
26662: IFFALSE 26785
// begin if i > 4 then
26664: LD_VAR 0 8
26668: PUSH
26669: LD_INT 4
26671: GREATER
26672: IFFALSE 26676
// break ;
26674: GO 26785
// x := personel [ i ] ;
26676: LD_ADDR_VAR 0 13
26680: PUSH
26681: LD_VAR 0 6
26685: PUSH
26686: LD_VAR 0 8
26690: ARRAY
26691: ST_TO_ADDR
// if x = - 1 then
26692: LD_VAR 0 13
26696: PUSH
26697: LD_INT 1
26699: NEG
26700: EQUAL
26701: IFFALSE 26705
// continue ;
26703: GO 26661
// PrepareHuman ( false , i , skill ) ;
26705: LD_INT 0
26707: PPUSH
26708: LD_VAR 0 8
26712: PPUSH
26713: LD_VAR 0 4
26717: PPUSH
26718: CALL_OW 380
// un := CreateHuman ;
26722: LD_ADDR_VAR 0 14
26726: PUSH
26727: CALL_OW 44
26731: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26732: LD_VAR 0 14
26736: PPUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 250
26746: PPUSH
26747: LD_VAR 0 1
26751: PPUSH
26752: CALL_OW 251
26756: PPUSH
26757: LD_INT 10
26759: PPUSH
26760: LD_INT 0
26762: PPUSH
26763: CALL_OW 50
// result := result ^ un ;
26767: LD_ADDR_VAR 0 7
26771: PUSH
26772: LD_VAR 0 7
26776: PUSH
26777: LD_VAR 0 14
26781: ADD
26782: ST_TO_ADDR
// end ;
26783: GO 26661
26785: POP
26786: POP
// end ; end ;
26787: LD_VAR 0 7
26791: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26792: LD_INT 0
26794: PPUSH
26795: PPUSH
26796: PPUSH
26797: PPUSH
26798: PPUSH
26799: PPUSH
26800: PPUSH
26801: PPUSH
26802: PPUSH
26803: PPUSH
26804: PPUSH
26805: PPUSH
26806: PPUSH
26807: PPUSH
26808: PPUSH
26809: PPUSH
// result := false ;
26810: LD_ADDR_VAR 0 3
26814: PUSH
26815: LD_INT 0
26817: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26818: LD_VAR 0 1
26822: NOT
26823: PUSH
26824: LD_VAR 0 1
26828: PPUSH
26829: CALL_OW 266
26833: PUSH
26834: LD_INT 32
26836: PUSH
26837: LD_INT 33
26839: PUSH
26840: EMPTY
26841: LIST
26842: LIST
26843: IN
26844: NOT
26845: OR
26846: IFFALSE 26850
// exit ;
26848: GO 27959
// nat := GetNation ( tower ) ;
26850: LD_ADDR_VAR 0 12
26854: PUSH
26855: LD_VAR 0 1
26859: PPUSH
26860: CALL_OW 248
26864: ST_TO_ADDR
// side := GetSide ( tower ) ;
26865: LD_ADDR_VAR 0 16
26869: PUSH
26870: LD_VAR 0 1
26874: PPUSH
26875: CALL_OW 255
26879: ST_TO_ADDR
// x := GetX ( tower ) ;
26880: LD_ADDR_VAR 0 10
26884: PUSH
26885: LD_VAR 0 1
26889: PPUSH
26890: CALL_OW 250
26894: ST_TO_ADDR
// y := GetY ( tower ) ;
26895: LD_ADDR_VAR 0 11
26899: PUSH
26900: LD_VAR 0 1
26904: PPUSH
26905: CALL_OW 251
26909: ST_TO_ADDR
// if not x or not y then
26910: LD_VAR 0 10
26914: NOT
26915: PUSH
26916: LD_VAR 0 11
26920: NOT
26921: OR
26922: IFFALSE 26926
// exit ;
26924: GO 27959
// weapon := 0 ;
26926: LD_ADDR_VAR 0 18
26930: PUSH
26931: LD_INT 0
26933: ST_TO_ADDR
// fac_list := [ ] ;
26934: LD_ADDR_VAR 0 17
26938: PUSH
26939: EMPTY
26940: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26941: LD_ADDR_VAR 0 6
26945: PUSH
26946: LD_VAR 0 1
26950: PPUSH
26951: CALL_OW 274
26955: PPUSH
26956: LD_VAR 0 2
26960: PPUSH
26961: LD_INT 0
26963: PPUSH
26964: CALL 24530 0 3
26968: PPUSH
26969: LD_INT 30
26971: PUSH
26972: LD_INT 3
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: PPUSH
26979: CALL_OW 72
26983: ST_TO_ADDR
// if not factories then
26984: LD_VAR 0 6
26988: NOT
26989: IFFALSE 26993
// exit ;
26991: GO 27959
// for i in factories do
26993: LD_ADDR_VAR 0 8
26997: PUSH
26998: LD_VAR 0 6
27002: PUSH
27003: FOR_IN
27004: IFFALSE 27029
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27006: LD_ADDR_VAR 0 17
27010: PUSH
27011: LD_VAR 0 17
27015: PUSH
27016: LD_VAR 0 8
27020: PPUSH
27021: CALL_OW 478
27025: UNION
27026: ST_TO_ADDR
27027: GO 27003
27029: POP
27030: POP
// if not fac_list then
27031: LD_VAR 0 17
27035: NOT
27036: IFFALSE 27040
// exit ;
27038: GO 27959
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27040: LD_ADDR_VAR 0 5
27044: PUSH
27045: LD_INT 4
27047: PUSH
27048: LD_INT 5
27050: PUSH
27051: LD_INT 9
27053: PUSH
27054: LD_INT 10
27056: PUSH
27057: LD_INT 6
27059: PUSH
27060: LD_INT 7
27062: PUSH
27063: LD_INT 11
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: LIST
27070: LIST
27071: LIST
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 27
27077: PUSH
27078: LD_INT 28
27080: PUSH
27081: LD_INT 26
27083: PUSH
27084: LD_INT 30
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: PUSH
27093: LD_INT 43
27095: PUSH
27096: LD_INT 44
27098: PUSH
27099: LD_INT 46
27101: PUSH
27102: LD_INT 45
27104: PUSH
27105: LD_INT 47
27107: PUSH
27108: LD_INT 49
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: LIST
27115: LIST
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: LIST
27123: PUSH
27124: LD_VAR 0 12
27128: ARRAY
27129: ST_TO_ADDR
// list := list isect fac_list ;
27130: LD_ADDR_VAR 0 5
27134: PUSH
27135: LD_VAR 0 5
27139: PUSH
27140: LD_VAR 0 17
27144: ISECT
27145: ST_TO_ADDR
// if not list then
27146: LD_VAR 0 5
27150: NOT
27151: IFFALSE 27155
// exit ;
27153: GO 27959
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27155: LD_VAR 0 12
27159: PUSH
27160: LD_INT 3
27162: EQUAL
27163: PUSH
27164: LD_INT 49
27166: PUSH
27167: LD_VAR 0 5
27171: IN
27172: AND
27173: PUSH
27174: LD_INT 31
27176: PPUSH
27177: LD_VAR 0 16
27181: PPUSH
27182: CALL_OW 321
27186: PUSH
27187: LD_INT 2
27189: EQUAL
27190: AND
27191: IFFALSE 27251
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27193: LD_INT 22
27195: PUSH
27196: LD_VAR 0 16
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 35
27207: PUSH
27208: LD_INT 49
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: LD_INT 91
27217: PUSH
27218: LD_VAR 0 1
27222: PUSH
27223: LD_INT 10
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: LIST
27230: PUSH
27231: EMPTY
27232: LIST
27233: LIST
27234: LIST
27235: PPUSH
27236: CALL_OW 69
27240: NOT
27241: IFFALSE 27251
// weapon := ru_time_lapser ;
27243: LD_ADDR_VAR 0 18
27247: PUSH
27248: LD_INT 49
27250: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27251: LD_VAR 0 12
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: IN
27266: PUSH
27267: LD_INT 11
27269: PUSH
27270: LD_VAR 0 5
27274: IN
27275: PUSH
27276: LD_INT 30
27278: PUSH
27279: LD_VAR 0 5
27283: IN
27284: OR
27285: AND
27286: PUSH
27287: LD_INT 6
27289: PPUSH
27290: LD_VAR 0 16
27294: PPUSH
27295: CALL_OW 321
27299: PUSH
27300: LD_INT 2
27302: EQUAL
27303: AND
27304: IFFALSE 27469
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27306: LD_INT 22
27308: PUSH
27309: LD_VAR 0 16
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: PUSH
27318: LD_INT 2
27320: PUSH
27321: LD_INT 35
27323: PUSH
27324: LD_INT 11
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: LD_INT 35
27333: PUSH
27334: LD_INT 30
27336: PUSH
27337: EMPTY
27338: LIST
27339: LIST
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 91
27348: PUSH
27349: LD_VAR 0 1
27353: PUSH
27354: LD_INT 18
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: LIST
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: LIST
27366: PPUSH
27367: CALL_OW 69
27371: NOT
27372: PUSH
27373: LD_INT 22
27375: PUSH
27376: LD_VAR 0 16
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: LD_INT 2
27387: PUSH
27388: LD_INT 30
27390: PUSH
27391: LD_INT 32
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 30
27400: PUSH
27401: LD_INT 33
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: LIST
27412: PUSH
27413: LD_INT 91
27415: PUSH
27416: LD_VAR 0 1
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: LIST
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: PPUSH
27437: CALL_OW 69
27441: PUSH
27442: LD_INT 2
27444: GREATER
27445: AND
27446: IFFALSE 27469
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27448: LD_ADDR_VAR 0 18
27452: PUSH
27453: LD_INT 11
27455: PUSH
27456: LD_INT 30
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: PUSH
27463: LD_VAR 0 12
27467: ARRAY
27468: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27469: LD_VAR 0 18
27473: NOT
27474: PUSH
27475: LD_INT 40
27477: PPUSH
27478: LD_VAR 0 16
27482: PPUSH
27483: CALL_OW 321
27487: PUSH
27488: LD_INT 2
27490: EQUAL
27491: AND
27492: PUSH
27493: LD_INT 7
27495: PUSH
27496: LD_VAR 0 5
27500: IN
27501: PUSH
27502: LD_INT 28
27504: PUSH
27505: LD_VAR 0 5
27509: IN
27510: OR
27511: PUSH
27512: LD_INT 45
27514: PUSH
27515: LD_VAR 0 5
27519: IN
27520: OR
27521: AND
27522: IFFALSE 27776
// begin hex := GetHexInfo ( x , y ) ;
27524: LD_ADDR_VAR 0 4
27528: PUSH
27529: LD_VAR 0 10
27533: PPUSH
27534: LD_VAR 0 11
27538: PPUSH
27539: CALL_OW 546
27543: ST_TO_ADDR
// if hex [ 1 ] then
27544: LD_VAR 0 4
27548: PUSH
27549: LD_INT 1
27551: ARRAY
27552: IFFALSE 27556
// exit ;
27554: GO 27959
// height := hex [ 2 ] ;
27556: LD_ADDR_VAR 0 15
27560: PUSH
27561: LD_VAR 0 4
27565: PUSH
27566: LD_INT 2
27568: ARRAY
27569: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27570: LD_ADDR_VAR 0 14
27574: PUSH
27575: LD_INT 0
27577: PUSH
27578: LD_INT 2
27580: PUSH
27581: LD_INT 3
27583: PUSH
27584: LD_INT 5
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: ST_TO_ADDR
// for i in tmp do
27593: LD_ADDR_VAR 0 8
27597: PUSH
27598: LD_VAR 0 14
27602: PUSH
27603: FOR_IN
27604: IFFALSE 27774
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27606: LD_ADDR_VAR 0 9
27610: PUSH
27611: LD_VAR 0 10
27615: PPUSH
27616: LD_VAR 0 8
27620: PPUSH
27621: LD_INT 5
27623: PPUSH
27624: CALL_OW 272
27628: PUSH
27629: LD_VAR 0 11
27633: PPUSH
27634: LD_VAR 0 8
27638: PPUSH
27639: LD_INT 5
27641: PPUSH
27642: CALL_OW 273
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27651: LD_VAR 0 9
27655: PUSH
27656: LD_INT 1
27658: ARRAY
27659: PPUSH
27660: LD_VAR 0 9
27664: PUSH
27665: LD_INT 2
27667: ARRAY
27668: PPUSH
27669: CALL_OW 488
27673: IFFALSE 27772
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27675: LD_ADDR_VAR 0 4
27679: PUSH
27680: LD_VAR 0 9
27684: PUSH
27685: LD_INT 1
27687: ARRAY
27688: PPUSH
27689: LD_VAR 0 9
27693: PUSH
27694: LD_INT 2
27696: ARRAY
27697: PPUSH
27698: CALL_OW 546
27702: ST_TO_ADDR
// if hex [ 1 ] then
27703: LD_VAR 0 4
27707: PUSH
27708: LD_INT 1
27710: ARRAY
27711: IFFALSE 27715
// continue ;
27713: GO 27603
// h := hex [ 2 ] ;
27715: LD_ADDR_VAR 0 13
27719: PUSH
27720: LD_VAR 0 4
27724: PUSH
27725: LD_INT 2
27727: ARRAY
27728: ST_TO_ADDR
// if h + 7 < height then
27729: LD_VAR 0 13
27733: PUSH
27734: LD_INT 7
27736: PLUS
27737: PUSH
27738: LD_VAR 0 15
27742: LESS
27743: IFFALSE 27772
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27745: LD_ADDR_VAR 0 18
27749: PUSH
27750: LD_INT 7
27752: PUSH
27753: LD_INT 28
27755: PUSH
27756: LD_INT 45
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: LIST
27763: PUSH
27764: LD_VAR 0 12
27768: ARRAY
27769: ST_TO_ADDR
// break ;
27770: GO 27774
// end ; end ; end ;
27772: GO 27603
27774: POP
27775: POP
// end ; if not weapon then
27776: LD_VAR 0 18
27780: NOT
27781: IFFALSE 27841
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27783: LD_ADDR_VAR 0 5
27787: PUSH
27788: LD_VAR 0 5
27792: PUSH
27793: LD_INT 11
27795: PUSH
27796: LD_INT 30
27798: PUSH
27799: LD_INT 49
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: LIST
27806: DIFF
27807: ST_TO_ADDR
// if not list then
27808: LD_VAR 0 5
27812: NOT
27813: IFFALSE 27817
// exit ;
27815: GO 27959
// weapon := list [ rand ( 1 , list ) ] ;
27817: LD_ADDR_VAR 0 18
27821: PUSH
27822: LD_VAR 0 5
27826: PUSH
27827: LD_INT 1
27829: PPUSH
27830: LD_VAR 0 5
27834: PPUSH
27835: CALL_OW 12
27839: ARRAY
27840: ST_TO_ADDR
// end ; if weapon then
27841: LD_VAR 0 18
27845: IFFALSE 27959
// begin tmp := CostOfWeapon ( weapon ) ;
27847: LD_ADDR_VAR 0 14
27851: PUSH
27852: LD_VAR 0 18
27856: PPUSH
27857: CALL_OW 451
27861: ST_TO_ADDR
// j := GetBase ( tower ) ;
27862: LD_ADDR_VAR 0 9
27866: PUSH
27867: LD_VAR 0 1
27871: PPUSH
27872: CALL_OW 274
27876: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27877: LD_VAR 0 9
27881: PPUSH
27882: LD_INT 1
27884: PPUSH
27885: CALL_OW 275
27889: PUSH
27890: LD_VAR 0 14
27894: PUSH
27895: LD_INT 1
27897: ARRAY
27898: GREATEREQUAL
27899: PUSH
27900: LD_VAR 0 9
27904: PPUSH
27905: LD_INT 2
27907: PPUSH
27908: CALL_OW 275
27912: PUSH
27913: LD_VAR 0 14
27917: PUSH
27918: LD_INT 2
27920: ARRAY
27921: GREATEREQUAL
27922: AND
27923: PUSH
27924: LD_VAR 0 9
27928: PPUSH
27929: LD_INT 3
27931: PPUSH
27932: CALL_OW 275
27936: PUSH
27937: LD_VAR 0 14
27941: PUSH
27942: LD_INT 3
27944: ARRAY
27945: GREATEREQUAL
27946: AND
27947: IFFALSE 27959
// result := weapon ;
27949: LD_ADDR_VAR 0 3
27953: PUSH
27954: LD_VAR 0 18
27958: ST_TO_ADDR
// end ; end ;
27959: LD_VAR 0 3
27963: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27964: LD_INT 0
27966: PPUSH
27967: PPUSH
// result := true ;
27968: LD_ADDR_VAR 0 3
27972: PUSH
27973: LD_INT 1
27975: ST_TO_ADDR
// if array1 = array2 then
27976: LD_VAR 0 1
27980: PUSH
27981: LD_VAR 0 2
27985: EQUAL
27986: IFFALSE 28046
// begin for i = 1 to array1 do
27988: LD_ADDR_VAR 0 4
27992: PUSH
27993: DOUBLE
27994: LD_INT 1
27996: DEC
27997: ST_TO_ADDR
27998: LD_VAR 0 1
28002: PUSH
28003: FOR_TO
28004: IFFALSE 28042
// if array1 [ i ] <> array2 [ i ] then
28006: LD_VAR 0 1
28010: PUSH
28011: LD_VAR 0 4
28015: ARRAY
28016: PUSH
28017: LD_VAR 0 2
28021: PUSH
28022: LD_VAR 0 4
28026: ARRAY
28027: NONEQUAL
28028: IFFALSE 28040
// begin result := false ;
28030: LD_ADDR_VAR 0 3
28034: PUSH
28035: LD_INT 0
28037: ST_TO_ADDR
// break ;
28038: GO 28042
// end ;
28040: GO 28003
28042: POP
28043: POP
// end else
28044: GO 28054
// result := false ;
28046: LD_ADDR_VAR 0 3
28050: PUSH
28051: LD_INT 0
28053: ST_TO_ADDR
// end ;
28054: LD_VAR 0 3
28058: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28059: LD_INT 0
28061: PPUSH
28062: PPUSH
// if not array1 or not array2 then
28063: LD_VAR 0 1
28067: NOT
28068: PUSH
28069: LD_VAR 0 2
28073: NOT
28074: OR
28075: IFFALSE 28079
// exit ;
28077: GO 28143
// result := true ;
28079: LD_ADDR_VAR 0 3
28083: PUSH
28084: LD_INT 1
28086: ST_TO_ADDR
// for i = 1 to array1 do
28087: LD_ADDR_VAR 0 4
28091: PUSH
28092: DOUBLE
28093: LD_INT 1
28095: DEC
28096: ST_TO_ADDR
28097: LD_VAR 0 1
28101: PUSH
28102: FOR_TO
28103: IFFALSE 28141
// if array1 [ i ] <> array2 [ i ] then
28105: LD_VAR 0 1
28109: PUSH
28110: LD_VAR 0 4
28114: ARRAY
28115: PUSH
28116: LD_VAR 0 2
28120: PUSH
28121: LD_VAR 0 4
28125: ARRAY
28126: NONEQUAL
28127: IFFALSE 28139
// begin result := false ;
28129: LD_ADDR_VAR 0 3
28133: PUSH
28134: LD_INT 0
28136: ST_TO_ADDR
// break ;
28137: GO 28141
// end ;
28139: GO 28102
28141: POP
28142: POP
// end ;
28143: LD_VAR 0 3
28147: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28148: LD_INT 0
28150: PPUSH
28151: PPUSH
28152: PPUSH
// pom := GetBase ( fac ) ;
28153: LD_ADDR_VAR 0 5
28157: PUSH
28158: LD_VAR 0 1
28162: PPUSH
28163: CALL_OW 274
28167: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28168: LD_ADDR_VAR 0 4
28172: PUSH
28173: LD_VAR 0 2
28177: PUSH
28178: LD_INT 1
28180: ARRAY
28181: PPUSH
28182: LD_VAR 0 2
28186: PUSH
28187: LD_INT 2
28189: ARRAY
28190: PPUSH
28191: LD_VAR 0 2
28195: PUSH
28196: LD_INT 3
28198: ARRAY
28199: PPUSH
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 4
28207: ARRAY
28208: PPUSH
28209: CALL_OW 449
28213: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28214: LD_ADDR_VAR 0 3
28218: PUSH
28219: LD_VAR 0 5
28223: PPUSH
28224: LD_INT 1
28226: PPUSH
28227: CALL_OW 275
28231: PUSH
28232: LD_VAR 0 4
28236: PUSH
28237: LD_INT 1
28239: ARRAY
28240: GREATEREQUAL
28241: PUSH
28242: LD_VAR 0 5
28246: PPUSH
28247: LD_INT 2
28249: PPUSH
28250: CALL_OW 275
28254: PUSH
28255: LD_VAR 0 4
28259: PUSH
28260: LD_INT 2
28262: ARRAY
28263: GREATEREQUAL
28264: AND
28265: PUSH
28266: LD_VAR 0 5
28270: PPUSH
28271: LD_INT 3
28273: PPUSH
28274: CALL_OW 275
28278: PUSH
28279: LD_VAR 0 4
28283: PUSH
28284: LD_INT 3
28286: ARRAY
28287: GREATEREQUAL
28288: AND
28289: ST_TO_ADDR
// end ;
28290: LD_VAR 0 3
28294: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28295: LD_INT 0
28297: PPUSH
28298: PPUSH
28299: PPUSH
28300: PPUSH
// pom := GetBase ( building ) ;
28301: LD_ADDR_VAR 0 3
28305: PUSH
28306: LD_VAR 0 1
28310: PPUSH
28311: CALL_OW 274
28315: ST_TO_ADDR
// if not pom then
28316: LD_VAR 0 3
28320: NOT
28321: IFFALSE 28325
// exit ;
28323: GO 28495
// btype := GetBType ( building ) ;
28325: LD_ADDR_VAR 0 5
28329: PUSH
28330: LD_VAR 0 1
28334: PPUSH
28335: CALL_OW 266
28339: ST_TO_ADDR
// if btype = b_armoury then
28340: LD_VAR 0 5
28344: PUSH
28345: LD_INT 4
28347: EQUAL
28348: IFFALSE 28358
// btype := b_barracks ;
28350: LD_ADDR_VAR 0 5
28354: PUSH
28355: LD_INT 5
28357: ST_TO_ADDR
// if btype = b_depot then
28358: LD_VAR 0 5
28362: PUSH
28363: LD_INT 0
28365: EQUAL
28366: IFFALSE 28376
// btype := b_warehouse ;
28368: LD_ADDR_VAR 0 5
28372: PUSH
28373: LD_INT 1
28375: ST_TO_ADDR
// if btype = b_workshop then
28376: LD_VAR 0 5
28380: PUSH
28381: LD_INT 2
28383: EQUAL
28384: IFFALSE 28394
// btype := b_factory ;
28386: LD_ADDR_VAR 0 5
28390: PUSH
28391: LD_INT 3
28393: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28394: LD_ADDR_VAR 0 4
28398: PUSH
28399: LD_VAR 0 5
28403: PPUSH
28404: LD_VAR 0 1
28408: PPUSH
28409: CALL_OW 248
28413: PPUSH
28414: CALL_OW 450
28418: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28419: LD_ADDR_VAR 0 2
28423: PUSH
28424: LD_VAR 0 3
28428: PPUSH
28429: LD_INT 1
28431: PPUSH
28432: CALL_OW 275
28436: PUSH
28437: LD_VAR 0 4
28441: PUSH
28442: LD_INT 1
28444: ARRAY
28445: GREATEREQUAL
28446: PUSH
28447: LD_VAR 0 3
28451: PPUSH
28452: LD_INT 2
28454: PPUSH
28455: CALL_OW 275
28459: PUSH
28460: LD_VAR 0 4
28464: PUSH
28465: LD_INT 2
28467: ARRAY
28468: GREATEREQUAL
28469: AND
28470: PUSH
28471: LD_VAR 0 3
28475: PPUSH
28476: LD_INT 3
28478: PPUSH
28479: CALL_OW 275
28483: PUSH
28484: LD_VAR 0 4
28488: PUSH
28489: LD_INT 3
28491: ARRAY
28492: GREATEREQUAL
28493: AND
28494: ST_TO_ADDR
// end ;
28495: LD_VAR 0 2
28499: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28500: LD_INT 0
28502: PPUSH
28503: PPUSH
28504: PPUSH
// pom := GetBase ( building ) ;
28505: LD_ADDR_VAR 0 4
28509: PUSH
28510: LD_VAR 0 1
28514: PPUSH
28515: CALL_OW 274
28519: ST_TO_ADDR
// if not pom then
28520: LD_VAR 0 4
28524: NOT
28525: IFFALSE 28529
// exit ;
28527: GO 28630
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28529: LD_ADDR_VAR 0 5
28533: PUSH
28534: LD_VAR 0 2
28538: PPUSH
28539: LD_VAR 0 1
28543: PPUSH
28544: CALL_OW 248
28548: PPUSH
28549: CALL_OW 450
28553: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28554: LD_ADDR_VAR 0 3
28558: PUSH
28559: LD_VAR 0 4
28563: PPUSH
28564: LD_INT 1
28566: PPUSH
28567: CALL_OW 275
28571: PUSH
28572: LD_VAR 0 5
28576: PUSH
28577: LD_INT 1
28579: ARRAY
28580: GREATEREQUAL
28581: PUSH
28582: LD_VAR 0 4
28586: PPUSH
28587: LD_INT 2
28589: PPUSH
28590: CALL_OW 275
28594: PUSH
28595: LD_VAR 0 5
28599: PUSH
28600: LD_INT 2
28602: ARRAY
28603: GREATEREQUAL
28604: AND
28605: PUSH
28606: LD_VAR 0 4
28610: PPUSH
28611: LD_INT 3
28613: PPUSH
28614: CALL_OW 275
28618: PUSH
28619: LD_VAR 0 5
28623: PUSH
28624: LD_INT 3
28626: ARRAY
28627: GREATEREQUAL
28628: AND
28629: ST_TO_ADDR
// end ;
28630: LD_VAR 0 3
28634: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28635: LD_INT 0
28637: PPUSH
28638: PPUSH
28639: PPUSH
28640: PPUSH
28641: PPUSH
28642: PPUSH
28643: PPUSH
28644: PPUSH
28645: PPUSH
28646: PPUSH
28647: PPUSH
// result := false ;
28648: LD_ADDR_VAR 0 8
28652: PUSH
28653: LD_INT 0
28655: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28656: LD_VAR 0 5
28660: NOT
28661: PUSH
28662: LD_VAR 0 1
28666: NOT
28667: OR
28668: PUSH
28669: LD_VAR 0 2
28673: NOT
28674: OR
28675: PUSH
28676: LD_VAR 0 3
28680: NOT
28681: OR
28682: IFFALSE 28686
// exit ;
28684: GO 29500
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28686: LD_ADDR_VAR 0 14
28690: PUSH
28691: LD_VAR 0 1
28695: PPUSH
28696: LD_VAR 0 2
28700: PPUSH
28701: LD_VAR 0 3
28705: PPUSH
28706: LD_VAR 0 4
28710: PPUSH
28711: LD_VAR 0 5
28715: PUSH
28716: LD_INT 1
28718: ARRAY
28719: PPUSH
28720: CALL_OW 248
28724: PPUSH
28725: LD_INT 0
28727: PPUSH
28728: CALL 30753 0 6
28732: ST_TO_ADDR
// if not hexes then
28733: LD_VAR 0 14
28737: NOT
28738: IFFALSE 28742
// exit ;
28740: GO 29500
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28742: LD_ADDR_VAR 0 17
28746: PUSH
28747: LD_VAR 0 5
28751: PPUSH
28752: LD_INT 22
28754: PUSH
28755: LD_VAR 0 13
28759: PPUSH
28760: CALL_OW 255
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 2
28771: PUSH
28772: LD_INT 30
28774: PUSH
28775: LD_INT 0
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: LD_INT 30
28784: PUSH
28785: LD_INT 1
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: LIST
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PPUSH
28801: CALL_OW 72
28805: ST_TO_ADDR
// for i = 1 to hexes do
28806: LD_ADDR_VAR 0 9
28810: PUSH
28811: DOUBLE
28812: LD_INT 1
28814: DEC
28815: ST_TO_ADDR
28816: LD_VAR 0 14
28820: PUSH
28821: FOR_TO
28822: IFFALSE 29498
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28824: LD_ADDR_VAR 0 13
28828: PUSH
28829: LD_VAR 0 14
28833: PUSH
28834: LD_VAR 0 9
28838: ARRAY
28839: PUSH
28840: LD_INT 1
28842: ARRAY
28843: PPUSH
28844: LD_VAR 0 14
28848: PUSH
28849: LD_VAR 0 9
28853: ARRAY
28854: PUSH
28855: LD_INT 2
28857: ARRAY
28858: PPUSH
28859: CALL_OW 428
28863: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28864: LD_VAR 0 14
28868: PUSH
28869: LD_VAR 0 9
28873: ARRAY
28874: PUSH
28875: LD_INT 1
28877: ARRAY
28878: PPUSH
28879: LD_VAR 0 14
28883: PUSH
28884: LD_VAR 0 9
28888: ARRAY
28889: PUSH
28890: LD_INT 2
28892: ARRAY
28893: PPUSH
28894: CALL_OW 351
28898: PUSH
28899: LD_VAR 0 14
28903: PUSH
28904: LD_VAR 0 9
28908: ARRAY
28909: PUSH
28910: LD_INT 1
28912: ARRAY
28913: PPUSH
28914: LD_VAR 0 14
28918: PUSH
28919: LD_VAR 0 9
28923: ARRAY
28924: PUSH
28925: LD_INT 2
28927: ARRAY
28928: PPUSH
28929: CALL_OW 488
28933: NOT
28934: OR
28935: PUSH
28936: LD_VAR 0 13
28940: PPUSH
28941: CALL_OW 247
28945: PUSH
28946: LD_INT 3
28948: EQUAL
28949: OR
28950: IFFALSE 28956
// exit ;
28952: POP
28953: POP
28954: GO 29500
// if not tmp then
28956: LD_VAR 0 13
28960: NOT
28961: IFFALSE 28965
// continue ;
28963: GO 28821
// result := true ;
28965: LD_ADDR_VAR 0 8
28969: PUSH
28970: LD_INT 1
28972: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28973: LD_VAR 0 6
28977: PUSH
28978: LD_VAR 0 13
28982: PPUSH
28983: CALL_OW 247
28987: PUSH
28988: LD_INT 2
28990: EQUAL
28991: AND
28992: PUSH
28993: LD_VAR 0 13
28997: PPUSH
28998: CALL_OW 263
29002: PUSH
29003: LD_INT 1
29005: EQUAL
29006: AND
29007: IFFALSE 29171
// begin if IsDrivenBy ( tmp ) then
29009: LD_VAR 0 13
29013: PPUSH
29014: CALL_OW 311
29018: IFFALSE 29022
// continue ;
29020: GO 28821
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29022: LD_VAR 0 6
29026: PPUSH
29027: LD_INT 3
29029: PUSH
29030: LD_INT 60
29032: PUSH
29033: EMPTY
29034: LIST
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 3
29042: PUSH
29043: LD_INT 55
29045: PUSH
29046: EMPTY
29047: LIST
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PPUSH
29057: CALL_OW 72
29061: IFFALSE 29169
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29063: LD_ADDR_VAR 0 18
29067: PUSH
29068: LD_VAR 0 6
29072: PPUSH
29073: LD_INT 3
29075: PUSH
29076: LD_INT 60
29078: PUSH
29079: EMPTY
29080: LIST
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 3
29088: PUSH
29089: LD_INT 55
29091: PUSH
29092: EMPTY
29093: LIST
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PPUSH
29103: CALL_OW 72
29107: PUSH
29108: LD_INT 1
29110: ARRAY
29111: ST_TO_ADDR
// if IsInUnit ( driver ) then
29112: LD_VAR 0 18
29116: PPUSH
29117: CALL_OW 310
29121: IFFALSE 29132
// ComExit ( driver ) ;
29123: LD_VAR 0 18
29127: PPUSH
29128: CALL 54534 0 1
// AddComEnterUnit ( driver , tmp ) ;
29132: LD_VAR 0 18
29136: PPUSH
29137: LD_VAR 0 13
29141: PPUSH
29142: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29146: LD_VAR 0 18
29150: PPUSH
29151: LD_VAR 0 7
29155: PPUSH
29156: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29160: LD_VAR 0 18
29164: PPUSH
29165: CALL_OW 181
// end ; continue ;
29169: GO 28821
// end ; if not cleaners or not tmp in cleaners then
29171: LD_VAR 0 6
29175: NOT
29176: PUSH
29177: LD_VAR 0 13
29181: PUSH
29182: LD_VAR 0 6
29186: IN
29187: NOT
29188: OR
29189: IFFALSE 29496
// begin if dep then
29191: LD_VAR 0 17
29195: IFFALSE 29331
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29197: LD_ADDR_VAR 0 16
29201: PUSH
29202: LD_VAR 0 17
29206: PUSH
29207: LD_INT 1
29209: ARRAY
29210: PPUSH
29211: CALL_OW 250
29215: PPUSH
29216: LD_VAR 0 17
29220: PUSH
29221: LD_INT 1
29223: ARRAY
29224: PPUSH
29225: CALL_OW 254
29229: PPUSH
29230: LD_INT 5
29232: PPUSH
29233: CALL_OW 272
29237: PUSH
29238: LD_VAR 0 17
29242: PUSH
29243: LD_INT 1
29245: ARRAY
29246: PPUSH
29247: CALL_OW 251
29251: PPUSH
29252: LD_VAR 0 17
29256: PUSH
29257: LD_INT 1
29259: ARRAY
29260: PPUSH
29261: CALL_OW 254
29265: PPUSH
29266: LD_INT 5
29268: PPUSH
29269: CALL_OW 273
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29278: LD_VAR 0 16
29282: PUSH
29283: LD_INT 1
29285: ARRAY
29286: PPUSH
29287: LD_VAR 0 16
29291: PUSH
29292: LD_INT 2
29294: ARRAY
29295: PPUSH
29296: CALL_OW 488
29300: IFFALSE 29331
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29302: LD_VAR 0 13
29306: PPUSH
29307: LD_VAR 0 16
29311: PUSH
29312: LD_INT 1
29314: ARRAY
29315: PPUSH
29316: LD_VAR 0 16
29320: PUSH
29321: LD_INT 2
29323: ARRAY
29324: PPUSH
29325: CALL_OW 111
// continue ;
29329: GO 28821
// end ; end ; r := GetDir ( tmp ) ;
29331: LD_ADDR_VAR 0 15
29335: PUSH
29336: LD_VAR 0 13
29340: PPUSH
29341: CALL_OW 254
29345: ST_TO_ADDR
// if r = 5 then
29346: LD_VAR 0 15
29350: PUSH
29351: LD_INT 5
29353: EQUAL
29354: IFFALSE 29364
// r := 0 ;
29356: LD_ADDR_VAR 0 15
29360: PUSH
29361: LD_INT 0
29363: ST_TO_ADDR
// for j = r to 5 do
29364: LD_ADDR_VAR 0 10
29368: PUSH
29369: DOUBLE
29370: LD_VAR 0 15
29374: DEC
29375: ST_TO_ADDR
29376: LD_INT 5
29378: PUSH
29379: FOR_TO
29380: IFFALSE 29494
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29382: LD_ADDR_VAR 0 11
29386: PUSH
29387: LD_VAR 0 13
29391: PPUSH
29392: CALL_OW 250
29396: PPUSH
29397: LD_VAR 0 10
29401: PPUSH
29402: LD_INT 2
29404: PPUSH
29405: CALL_OW 272
29409: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29410: LD_ADDR_VAR 0 12
29414: PUSH
29415: LD_VAR 0 13
29419: PPUSH
29420: CALL_OW 251
29424: PPUSH
29425: LD_VAR 0 10
29429: PPUSH
29430: LD_INT 2
29432: PPUSH
29433: CALL_OW 273
29437: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29438: LD_VAR 0 11
29442: PPUSH
29443: LD_VAR 0 12
29447: PPUSH
29448: CALL_OW 488
29452: PUSH
29453: LD_VAR 0 11
29457: PPUSH
29458: LD_VAR 0 12
29462: PPUSH
29463: CALL_OW 428
29467: NOT
29468: AND
29469: IFFALSE 29492
// begin ComMoveXY ( tmp , _x , _y ) ;
29471: LD_VAR 0 13
29475: PPUSH
29476: LD_VAR 0 11
29480: PPUSH
29481: LD_VAR 0 12
29485: PPUSH
29486: CALL_OW 111
// break ;
29490: GO 29494
// end ; end ;
29492: GO 29379
29494: POP
29495: POP
// end ; end ;
29496: GO 28821
29498: POP
29499: POP
// end ;
29500: LD_VAR 0 8
29504: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29505: LD_INT 0
29507: PPUSH
// result := true ;
29508: LD_ADDR_VAR 0 3
29512: PUSH
29513: LD_INT 1
29515: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29516: LD_VAR 0 2
29520: PUSH
29521: LD_INT 24
29523: DOUBLE
29524: EQUAL
29525: IFTRUE 29535
29527: LD_INT 33
29529: DOUBLE
29530: EQUAL
29531: IFTRUE 29535
29533: GO 29560
29535: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29536: LD_ADDR_VAR 0 3
29540: PUSH
29541: LD_INT 32
29543: PPUSH
29544: LD_VAR 0 1
29548: PPUSH
29549: CALL_OW 321
29553: PUSH
29554: LD_INT 2
29556: EQUAL
29557: ST_TO_ADDR
29558: GO 29876
29560: LD_INT 20
29562: DOUBLE
29563: EQUAL
29564: IFTRUE 29568
29566: GO 29593
29568: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29569: LD_ADDR_VAR 0 3
29573: PUSH
29574: LD_INT 6
29576: PPUSH
29577: LD_VAR 0 1
29581: PPUSH
29582: CALL_OW 321
29586: PUSH
29587: LD_INT 2
29589: EQUAL
29590: ST_TO_ADDR
29591: GO 29876
29593: LD_INT 22
29595: DOUBLE
29596: EQUAL
29597: IFTRUE 29607
29599: LD_INT 36
29601: DOUBLE
29602: EQUAL
29603: IFTRUE 29607
29605: GO 29632
29607: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29608: LD_ADDR_VAR 0 3
29612: PUSH
29613: LD_INT 15
29615: PPUSH
29616: LD_VAR 0 1
29620: PPUSH
29621: CALL_OW 321
29625: PUSH
29626: LD_INT 2
29628: EQUAL
29629: ST_TO_ADDR
29630: GO 29876
29632: LD_INT 30
29634: DOUBLE
29635: EQUAL
29636: IFTRUE 29640
29638: GO 29665
29640: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29641: LD_ADDR_VAR 0 3
29645: PUSH
29646: LD_INT 20
29648: PPUSH
29649: LD_VAR 0 1
29653: PPUSH
29654: CALL_OW 321
29658: PUSH
29659: LD_INT 2
29661: EQUAL
29662: ST_TO_ADDR
29663: GO 29876
29665: LD_INT 28
29667: DOUBLE
29668: EQUAL
29669: IFTRUE 29679
29671: LD_INT 21
29673: DOUBLE
29674: EQUAL
29675: IFTRUE 29679
29677: GO 29704
29679: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29680: LD_ADDR_VAR 0 3
29684: PUSH
29685: LD_INT 21
29687: PPUSH
29688: LD_VAR 0 1
29692: PPUSH
29693: CALL_OW 321
29697: PUSH
29698: LD_INT 2
29700: EQUAL
29701: ST_TO_ADDR
29702: GO 29876
29704: LD_INT 16
29706: DOUBLE
29707: EQUAL
29708: IFTRUE 29712
29710: GO 29737
29712: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29713: LD_ADDR_VAR 0 3
29717: PUSH
29718: LD_INT 84
29720: PPUSH
29721: LD_VAR 0 1
29725: PPUSH
29726: CALL_OW 321
29730: PUSH
29731: LD_INT 2
29733: EQUAL
29734: ST_TO_ADDR
29735: GO 29876
29737: LD_INT 19
29739: DOUBLE
29740: EQUAL
29741: IFTRUE 29751
29743: LD_INT 23
29745: DOUBLE
29746: EQUAL
29747: IFTRUE 29751
29749: GO 29776
29751: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29752: LD_ADDR_VAR 0 3
29756: PUSH
29757: LD_INT 83
29759: PPUSH
29760: LD_VAR 0 1
29764: PPUSH
29765: CALL_OW 321
29769: PUSH
29770: LD_INT 2
29772: EQUAL
29773: ST_TO_ADDR
29774: GO 29876
29776: LD_INT 17
29778: DOUBLE
29779: EQUAL
29780: IFTRUE 29784
29782: GO 29809
29784: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29785: LD_ADDR_VAR 0 3
29789: PUSH
29790: LD_INT 39
29792: PPUSH
29793: LD_VAR 0 1
29797: PPUSH
29798: CALL_OW 321
29802: PUSH
29803: LD_INT 2
29805: EQUAL
29806: ST_TO_ADDR
29807: GO 29876
29809: LD_INT 18
29811: DOUBLE
29812: EQUAL
29813: IFTRUE 29817
29815: GO 29842
29817: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29818: LD_ADDR_VAR 0 3
29822: PUSH
29823: LD_INT 40
29825: PPUSH
29826: LD_VAR 0 1
29830: PPUSH
29831: CALL_OW 321
29835: PUSH
29836: LD_INT 2
29838: EQUAL
29839: ST_TO_ADDR
29840: GO 29876
29842: LD_INT 27
29844: DOUBLE
29845: EQUAL
29846: IFTRUE 29850
29848: GO 29875
29850: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29851: LD_ADDR_VAR 0 3
29855: PUSH
29856: LD_INT 35
29858: PPUSH
29859: LD_VAR 0 1
29863: PPUSH
29864: CALL_OW 321
29868: PUSH
29869: LD_INT 2
29871: EQUAL
29872: ST_TO_ADDR
29873: GO 29876
29875: POP
// end ;
29876: LD_VAR 0 3
29880: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29881: LD_INT 0
29883: PPUSH
29884: PPUSH
29885: PPUSH
29886: PPUSH
29887: PPUSH
29888: PPUSH
29889: PPUSH
29890: PPUSH
29891: PPUSH
29892: PPUSH
29893: PPUSH
// result := false ;
29894: LD_ADDR_VAR 0 6
29898: PUSH
29899: LD_INT 0
29901: ST_TO_ADDR
// if btype = b_depot then
29902: LD_VAR 0 2
29906: PUSH
29907: LD_INT 0
29909: EQUAL
29910: IFFALSE 29922
// begin result := true ;
29912: LD_ADDR_VAR 0 6
29916: PUSH
29917: LD_INT 1
29919: ST_TO_ADDR
// exit ;
29920: GO 30748
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29922: LD_VAR 0 1
29926: NOT
29927: PUSH
29928: LD_VAR 0 1
29932: PPUSH
29933: CALL_OW 266
29937: PUSH
29938: LD_INT 0
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: IN
29948: NOT
29949: OR
29950: PUSH
29951: LD_VAR 0 2
29955: NOT
29956: OR
29957: PUSH
29958: LD_VAR 0 5
29962: PUSH
29963: LD_INT 0
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: LD_INT 2
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: LD_INT 4
29977: PUSH
29978: LD_INT 5
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: IN
29989: NOT
29990: OR
29991: PUSH
29992: LD_VAR 0 3
29996: PPUSH
29997: LD_VAR 0 4
30001: PPUSH
30002: CALL_OW 488
30006: NOT
30007: OR
30008: IFFALSE 30012
// exit ;
30010: GO 30748
// side := GetSide ( depot ) ;
30012: LD_ADDR_VAR 0 9
30016: PUSH
30017: LD_VAR 0 1
30021: PPUSH
30022: CALL_OW 255
30026: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30027: LD_VAR 0 9
30031: PPUSH
30032: LD_VAR 0 2
30036: PPUSH
30037: CALL 29505 0 2
30041: NOT
30042: IFFALSE 30046
// exit ;
30044: GO 30748
// pom := GetBase ( depot ) ;
30046: LD_ADDR_VAR 0 10
30050: PUSH
30051: LD_VAR 0 1
30055: PPUSH
30056: CALL_OW 274
30060: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30061: LD_ADDR_VAR 0 11
30065: PUSH
30066: LD_VAR 0 2
30070: PPUSH
30071: LD_VAR 0 1
30075: PPUSH
30076: CALL_OW 248
30080: PPUSH
30081: CALL_OW 450
30085: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30086: LD_VAR 0 10
30090: PPUSH
30091: LD_INT 1
30093: PPUSH
30094: CALL_OW 275
30098: PUSH
30099: LD_VAR 0 11
30103: PUSH
30104: LD_INT 1
30106: ARRAY
30107: GREATEREQUAL
30108: PUSH
30109: LD_VAR 0 10
30113: PPUSH
30114: LD_INT 2
30116: PPUSH
30117: CALL_OW 275
30121: PUSH
30122: LD_VAR 0 11
30126: PUSH
30127: LD_INT 2
30129: ARRAY
30130: GREATEREQUAL
30131: AND
30132: PUSH
30133: LD_VAR 0 10
30137: PPUSH
30138: LD_INT 3
30140: PPUSH
30141: CALL_OW 275
30145: PUSH
30146: LD_VAR 0 11
30150: PUSH
30151: LD_INT 3
30153: ARRAY
30154: GREATEREQUAL
30155: AND
30156: NOT
30157: IFFALSE 30161
// exit ;
30159: GO 30748
// if GetBType ( depot ) = b_depot then
30161: LD_VAR 0 1
30165: PPUSH
30166: CALL_OW 266
30170: PUSH
30171: LD_INT 0
30173: EQUAL
30174: IFFALSE 30186
// dist := 28 else
30176: LD_ADDR_VAR 0 14
30180: PUSH
30181: LD_INT 28
30183: ST_TO_ADDR
30184: GO 30194
// dist := 36 ;
30186: LD_ADDR_VAR 0 14
30190: PUSH
30191: LD_INT 36
30193: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30194: LD_VAR 0 1
30198: PPUSH
30199: LD_VAR 0 3
30203: PPUSH
30204: LD_VAR 0 4
30208: PPUSH
30209: CALL_OW 297
30213: PUSH
30214: LD_VAR 0 14
30218: GREATER
30219: IFFALSE 30223
// exit ;
30221: GO 30748
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30223: LD_ADDR_VAR 0 12
30227: PUSH
30228: LD_VAR 0 2
30232: PPUSH
30233: LD_VAR 0 3
30237: PPUSH
30238: LD_VAR 0 4
30242: PPUSH
30243: LD_VAR 0 5
30247: PPUSH
30248: LD_VAR 0 1
30252: PPUSH
30253: CALL_OW 248
30257: PPUSH
30258: LD_INT 0
30260: PPUSH
30261: CALL 30753 0 6
30265: ST_TO_ADDR
// if not hexes then
30266: LD_VAR 0 12
30270: NOT
30271: IFFALSE 30275
// exit ;
30273: GO 30748
// hex := GetHexInfo ( x , y ) ;
30275: LD_ADDR_VAR 0 15
30279: PUSH
30280: LD_VAR 0 3
30284: PPUSH
30285: LD_VAR 0 4
30289: PPUSH
30290: CALL_OW 546
30294: ST_TO_ADDR
// if hex [ 1 ] then
30295: LD_VAR 0 15
30299: PUSH
30300: LD_INT 1
30302: ARRAY
30303: IFFALSE 30307
// exit ;
30305: GO 30748
// height := hex [ 2 ] ;
30307: LD_ADDR_VAR 0 13
30311: PUSH
30312: LD_VAR 0 15
30316: PUSH
30317: LD_INT 2
30319: ARRAY
30320: ST_TO_ADDR
// for i = 1 to hexes do
30321: LD_ADDR_VAR 0 7
30325: PUSH
30326: DOUBLE
30327: LD_INT 1
30329: DEC
30330: ST_TO_ADDR
30331: LD_VAR 0 12
30335: PUSH
30336: FOR_TO
30337: IFFALSE 30667
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30339: LD_VAR 0 12
30343: PUSH
30344: LD_VAR 0 7
30348: ARRAY
30349: PUSH
30350: LD_INT 1
30352: ARRAY
30353: PPUSH
30354: LD_VAR 0 12
30358: PUSH
30359: LD_VAR 0 7
30363: ARRAY
30364: PUSH
30365: LD_INT 2
30367: ARRAY
30368: PPUSH
30369: CALL_OW 488
30373: NOT
30374: PUSH
30375: LD_VAR 0 12
30379: PUSH
30380: LD_VAR 0 7
30384: ARRAY
30385: PUSH
30386: LD_INT 1
30388: ARRAY
30389: PPUSH
30390: LD_VAR 0 12
30394: PUSH
30395: LD_VAR 0 7
30399: ARRAY
30400: PUSH
30401: LD_INT 2
30403: ARRAY
30404: PPUSH
30405: CALL_OW 428
30409: PUSH
30410: LD_INT 0
30412: GREATER
30413: OR
30414: PUSH
30415: LD_VAR 0 12
30419: PUSH
30420: LD_VAR 0 7
30424: ARRAY
30425: PUSH
30426: LD_INT 1
30428: ARRAY
30429: PPUSH
30430: LD_VAR 0 12
30434: PUSH
30435: LD_VAR 0 7
30439: ARRAY
30440: PUSH
30441: LD_INT 2
30443: ARRAY
30444: PPUSH
30445: CALL_OW 351
30449: OR
30450: IFFALSE 30456
// exit ;
30452: POP
30453: POP
30454: GO 30748
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30456: LD_ADDR_VAR 0 8
30460: PUSH
30461: LD_VAR 0 12
30465: PUSH
30466: LD_VAR 0 7
30470: ARRAY
30471: PUSH
30472: LD_INT 1
30474: ARRAY
30475: PPUSH
30476: LD_VAR 0 12
30480: PUSH
30481: LD_VAR 0 7
30485: ARRAY
30486: PUSH
30487: LD_INT 2
30489: ARRAY
30490: PPUSH
30491: CALL_OW 546
30495: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30496: LD_VAR 0 8
30500: PUSH
30501: LD_INT 1
30503: ARRAY
30504: PUSH
30505: LD_VAR 0 8
30509: PUSH
30510: LD_INT 2
30512: ARRAY
30513: PUSH
30514: LD_VAR 0 13
30518: PUSH
30519: LD_INT 2
30521: PLUS
30522: GREATER
30523: OR
30524: PUSH
30525: LD_VAR 0 8
30529: PUSH
30530: LD_INT 2
30532: ARRAY
30533: PUSH
30534: LD_VAR 0 13
30538: PUSH
30539: LD_INT 2
30541: MINUS
30542: LESS
30543: OR
30544: PUSH
30545: LD_VAR 0 8
30549: PUSH
30550: LD_INT 3
30552: ARRAY
30553: PUSH
30554: LD_INT 0
30556: PUSH
30557: LD_INT 8
30559: PUSH
30560: LD_INT 9
30562: PUSH
30563: LD_INT 10
30565: PUSH
30566: LD_INT 11
30568: PUSH
30569: LD_INT 12
30571: PUSH
30572: LD_INT 13
30574: PUSH
30575: LD_INT 16
30577: PUSH
30578: LD_INT 17
30580: PUSH
30581: LD_INT 18
30583: PUSH
30584: LD_INT 19
30586: PUSH
30587: LD_INT 20
30589: PUSH
30590: LD_INT 21
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: IN
30608: NOT
30609: OR
30610: PUSH
30611: LD_VAR 0 8
30615: PUSH
30616: LD_INT 5
30618: ARRAY
30619: NOT
30620: OR
30621: PUSH
30622: LD_VAR 0 8
30626: PUSH
30627: LD_INT 6
30629: ARRAY
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: LD_INT 2
30636: PUSH
30637: LD_INT 7
30639: PUSH
30640: LD_INT 9
30642: PUSH
30643: LD_INT 10
30645: PUSH
30646: LD_INT 11
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: LIST
30653: LIST
30654: LIST
30655: LIST
30656: IN
30657: NOT
30658: OR
30659: IFFALSE 30665
// exit ;
30661: POP
30662: POP
30663: GO 30748
// end ;
30665: GO 30336
30667: POP
30668: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30669: LD_VAR 0 9
30673: PPUSH
30674: LD_VAR 0 3
30678: PPUSH
30679: LD_VAR 0 4
30683: PPUSH
30684: LD_INT 20
30686: PPUSH
30687: CALL 22671 0 4
30691: PUSH
30692: LD_INT 4
30694: ARRAY
30695: IFFALSE 30699
// exit ;
30697: GO 30748
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30699: LD_VAR 0 2
30703: PUSH
30704: LD_INT 29
30706: PUSH
30707: LD_INT 30
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: IN
30714: PUSH
30715: LD_VAR 0 3
30719: PPUSH
30720: LD_VAR 0 4
30724: PPUSH
30725: LD_VAR 0 9
30729: PPUSH
30730: CALL_OW 440
30734: NOT
30735: AND
30736: IFFALSE 30740
// exit ;
30738: GO 30748
// result := true ;
30740: LD_ADDR_VAR 0 6
30744: PUSH
30745: LD_INT 1
30747: ST_TO_ADDR
// end ;
30748: LD_VAR 0 6
30752: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30753: LD_INT 0
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
30766: PPUSH
30767: PPUSH
30768: PPUSH
30769: PPUSH
30770: PPUSH
30771: PPUSH
30772: PPUSH
30773: PPUSH
30774: PPUSH
30775: PPUSH
30776: PPUSH
30777: PPUSH
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
30782: PPUSH
30783: PPUSH
30784: PPUSH
30785: PPUSH
30786: PPUSH
30787: PPUSH
30788: PPUSH
30789: PPUSH
30790: PPUSH
30791: PPUSH
30792: PPUSH
30793: PPUSH
30794: PPUSH
30795: PPUSH
30796: PPUSH
30797: PPUSH
30798: PPUSH
30799: PPUSH
30800: PPUSH
30801: PPUSH
30802: PPUSH
30803: PPUSH
30804: PPUSH
30805: PPUSH
30806: PPUSH
30807: PPUSH
30808: PPUSH
30809: PPUSH
30810: PPUSH
30811: PPUSH
30812: PPUSH
// result = [ ] ;
30813: LD_ADDR_VAR 0 7
30817: PUSH
30818: EMPTY
30819: ST_TO_ADDR
// temp_list = [ ] ;
30820: LD_ADDR_VAR 0 9
30824: PUSH
30825: EMPTY
30826: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30827: LD_VAR 0 4
30831: PUSH
30832: LD_INT 0
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 2
30840: PUSH
30841: LD_INT 3
30843: PUSH
30844: LD_INT 4
30846: PUSH
30847: LD_INT 5
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: IN
30858: NOT
30859: PUSH
30860: LD_VAR 0 1
30864: PUSH
30865: LD_INT 0
30867: PUSH
30868: LD_INT 1
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: IN
30875: PUSH
30876: LD_VAR 0 5
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: LD_INT 2
30886: PUSH
30887: LD_INT 3
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: LIST
30894: IN
30895: NOT
30896: AND
30897: OR
30898: IFFALSE 30902
// exit ;
30900: GO 49293
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30902: LD_VAR 0 1
30906: PUSH
30907: LD_INT 6
30909: PUSH
30910: LD_INT 7
30912: PUSH
30913: LD_INT 8
30915: PUSH
30916: LD_INT 13
30918: PUSH
30919: LD_INT 12
30921: PUSH
30922: LD_INT 15
30924: PUSH
30925: LD_INT 11
30927: PUSH
30928: LD_INT 14
30930: PUSH
30931: LD_INT 10
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: IN
30945: IFFALSE 30955
// btype = b_lab ;
30947: LD_ADDR_VAR 0 1
30951: PUSH
30952: LD_INT 6
30954: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30955: LD_VAR 0 6
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: LD_INT 2
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: LIST
30973: IN
30974: NOT
30975: PUSH
30976: LD_VAR 0 1
30980: PUSH
30981: LD_INT 0
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: LD_INT 2
30989: PUSH
30990: LD_INT 3
30992: PUSH
30993: LD_INT 6
30995: PUSH
30996: LD_INT 36
30998: PUSH
30999: LD_INT 4
31001: PUSH
31002: LD_INT 5
31004: PUSH
31005: LD_INT 31
31007: PUSH
31008: LD_INT 32
31010: PUSH
31011: LD_INT 33
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: IN
31027: NOT
31028: PUSH
31029: LD_VAR 0 6
31033: PUSH
31034: LD_INT 1
31036: EQUAL
31037: AND
31038: OR
31039: PUSH
31040: LD_VAR 0 1
31044: PUSH
31045: LD_INT 2
31047: PUSH
31048: LD_INT 3
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: IN
31055: NOT
31056: PUSH
31057: LD_VAR 0 6
31061: PUSH
31062: LD_INT 2
31064: EQUAL
31065: AND
31066: OR
31067: IFFALSE 31077
// mode = 0 ;
31069: LD_ADDR_VAR 0 6
31073: PUSH
31074: LD_INT 0
31076: ST_TO_ADDR
// case mode of 0 :
31077: LD_VAR 0 6
31081: PUSH
31082: LD_INT 0
31084: DOUBLE
31085: EQUAL
31086: IFTRUE 31090
31088: GO 42543
31090: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31091: LD_ADDR_VAR 0 11
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 0
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 1
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 0
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: LD_INT 2
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 0
31184: PUSH
31185: LD_INT 2
31187: NEG
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 1
31198: NEG
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 1
31206: PUSH
31207: LD_INT 2
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 0
31216: PUSH
31217: LD_INT 2
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: NEG
31227: PUSH
31228: LD_INT 1
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: LD_INT 3
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: LD_INT 2
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31284: LD_ADDR_VAR 0 12
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 1
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 1
31396: NEG
31397: PUSH
31398: LD_INT 1
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 2
31407: NEG
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 2
31418: NEG
31419: PUSH
31420: LD_INT 1
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 2
31430: NEG
31431: PUSH
31432: LD_INT 1
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 3
31441: NEG
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 3
31452: NEG
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: LIST
31479: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31480: LD_ADDR_VAR 0 13
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 0
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: LD_INT 1
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: LD_INT 1
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 1
31538: NEG
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: NEG
31550: PUSH
31551: LD_INT 1
31553: NEG
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 1
31561: NEG
31562: PUSH
31563: LD_INT 2
31565: NEG
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: LD_INT 1
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 2
31583: PUSH
31584: LD_INT 2
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: LD_INT 2
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 2
31603: NEG
31604: PUSH
31605: LD_INT 1
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 2
31615: NEG
31616: PUSH
31617: LD_INT 2
31619: NEG
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PUSH
31625: LD_INT 2
31627: NEG
31628: PUSH
31629: LD_INT 3
31631: NEG
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 3
31639: NEG
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 3
31651: NEG
31652: PUSH
31653: LD_INT 3
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31679: LD_ADDR_VAR 0 14
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 0
31689: PUSH
31690: EMPTY
31691: LIST
31692: LIST
31693: PUSH
31694: LD_INT 0
31696: PUSH
31697: LD_INT 1
31699: NEG
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: LD_INT 0
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 1
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: LD_INT 1
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: LD_INT 0
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 1
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: LD_INT 2
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 0
31772: PUSH
31773: LD_INT 2
31775: NEG
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 1
31783: PUSH
31784: LD_INT 1
31786: NEG
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 1
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 0
31804: PUSH
31805: LD_INT 2
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: NEG
31815: PUSH
31816: LD_INT 1
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 3
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 3
31840: NEG
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: LD_INT 2
31851: NEG
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31875: LD_ADDR_VAR 0 15
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 0
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 0
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: LD_INT 1
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 1
31956: PUSH
31957: LD_INT 1
31959: NEG
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 2
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 2
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 1
31987: NEG
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 2
31998: NEG
31999: PUSH
32000: LD_INT 0
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: LD_INT 1
32013: NEG
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 2
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 3
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 3
32042: PUSH
32043: LD_INT 1
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32068: LD_ADDR_VAR 0 16
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: LD_INT 0
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 0
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 1
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 1
32126: NEG
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: NEG
32138: PUSH
32139: LD_INT 1
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 1
32149: NEG
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 2
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 1
32181: PUSH
32182: LD_INT 2
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 2
32203: NEG
32204: PUSH
32205: LD_INT 2
32207: NEG
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: LD_INT 2
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 3
32225: PUSH
32226: LD_INT 3
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 2
32235: PUSH
32236: LD_INT 3
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32261: LD_ADDR_VAR 0 17
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 0
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 0
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: LD_INT 1
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: NEG
32320: PUSH
32321: LD_INT 0
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: NEG
32331: PUSH
32332: LD_INT 1
32334: NEG
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 1
32342: NEG
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: LD_INT 2
32357: NEG
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: LD_INT 1
32368: NEG
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 2
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 1
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 0
32416: PUSH
32417: LD_INT 2
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: NEG
32427: PUSH
32428: LD_INT 1
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 2
32437: NEG
32438: PUSH
32439: LD_INT 0
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 2
32448: NEG
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 2
32460: NEG
32461: PUSH
32462: LD_INT 2
32464: NEG
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32491: LD_ADDR_VAR 0 18
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: LD_INT 0
32501: PUSH
32502: EMPTY
32503: LIST
32504: LIST
32505: PUSH
32506: LD_INT 0
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 1
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 1
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 0
32539: PUSH
32540: LD_INT 1
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 1
32549: NEG
32550: PUSH
32551: LD_INT 0
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 1
32560: NEG
32561: PUSH
32562: LD_INT 1
32564: NEG
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PUSH
32570: LD_INT 1
32572: NEG
32573: PUSH
32574: LD_INT 2
32576: NEG
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 0
32584: PUSH
32585: LD_INT 2
32587: NEG
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: PUSH
32596: LD_INT 1
32598: NEG
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: PUSH
32607: LD_INT 0
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PUSH
32614: LD_INT 2
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 2
32626: PUSH
32627: LD_INT 2
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 2
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 2
32667: NEG
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 2
32678: NEG
32679: PUSH
32680: LD_INT 1
32682: NEG
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 2
32690: NEG
32691: PUSH
32692: LD_INT 2
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32721: LD_ADDR_VAR 0 19
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: LD_INT 0
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: LD_INT 1
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 1
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: NEG
32791: PUSH
32792: LD_INT 1
32794: NEG
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: LD_INT 2
32806: NEG
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: LD_INT 2
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: LD_INT 0
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 1
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 2
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 1
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 0
32876: PUSH
32877: LD_INT 2
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 1
32886: NEG
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 2
32897: NEG
32898: PUSH
32899: LD_INT 0
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: NEG
32909: PUSH
32910: LD_INT 1
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 2
32920: NEG
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32951: LD_ADDR_VAR 0 20
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 1
32971: NEG
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 1
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 0
32999: PUSH
33000: LD_INT 1
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: LD_INT 1
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 1
33032: NEG
33033: PUSH
33034: LD_INT 2
33036: NEG
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 0
33044: PUSH
33045: LD_INT 2
33047: NEG
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 1
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 0
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: LD_INT 1
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 2
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: LD_INT 2
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: LD_INT 2
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 1
33116: NEG
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 2
33127: NEG
33128: PUSH
33129: LD_INT 0
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: NEG
33139: PUSH
33140: LD_INT 1
33142: NEG
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 2
33150: NEG
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: LIST
33180: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33181: LD_ADDR_VAR 0 21
33185: PUSH
33186: LD_INT 0
33188: PUSH
33189: LD_INT 0
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 0
33198: PUSH
33199: LD_INT 1
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 0
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 1
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 0
33229: PUSH
33230: LD_INT 1
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: LD_INT 0
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: LD_INT 1
33254: NEG
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 1
33262: NEG
33263: PUSH
33264: LD_INT 2
33266: NEG
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: LD_INT 2
33277: NEG
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: PUSH
33297: LD_INT 0
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: LD_INT 1
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 1
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 0
33336: PUSH
33337: LD_INT 2
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 1
33346: NEG
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: NEG
33358: PUSH
33359: LD_INT 0
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: NEG
33369: PUSH
33370: LD_INT 1
33372: NEG
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 2
33380: NEG
33381: PUSH
33382: LD_INT 2
33384: NEG
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33411: LD_ADDR_VAR 0 22
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: LD_INT 0
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 0
33428: PUSH
33429: LD_INT 1
33431: NEG
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: LD_INT 0
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 1
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 0
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 1
33469: NEG
33470: PUSH
33471: LD_INT 0
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 1
33480: NEG
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 1
33492: NEG
33493: PUSH
33494: LD_INT 2
33496: NEG
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: LD_INT 2
33507: NEG
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: PUSH
33516: LD_INT 1
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: PUSH
33537: LD_INT 1
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 2
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: PUSH
33557: LD_INT 2
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 0
33566: PUSH
33567: LD_INT 2
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: LD_INT 0
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: LD_INT 2
33598: NEG
33599: PUSH
33600: LD_INT 1
33602: NEG
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 2
33610: NEG
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33641: LD_ADDR_VAR 0 23
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: LD_INT 0
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: LD_INT 1
33661: NEG
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: LD_INT 1
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: LD_INT 1
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 1
33699: NEG
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: NEG
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 1
33722: NEG
33723: PUSH
33724: LD_INT 2
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: LD_INT 2
33737: NEG
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: PUSH
33757: LD_INT 0
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 2
33766: PUSH
33767: LD_INT 1
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 2
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 0
33796: PUSH
33797: LD_INT 2
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 1
33806: NEG
33807: PUSH
33808: LD_INT 1
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 2
33828: NEG
33829: PUSH
33830: LD_INT 1
33832: NEG
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: NEG
33841: PUSH
33842: LD_INT 2
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: NEG
33853: PUSH
33854: LD_INT 3
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: LD_INT 3
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: LD_INT 2
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: LD_INT 1
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33921: LD_ADDR_VAR 0 24
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: NEG
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 2
34017: NEG
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 2
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: LD_INT 2
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 1
34086: NEG
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 2
34097: NEG
34098: PUSH
34099: LD_INT 0
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 2
34108: NEG
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 2
34120: NEG
34121: PUSH
34122: LD_INT 2
34124: NEG
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: LD_INT 2
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: LD_INT 1
34146: NEG
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 3
34154: PUSH
34155: LD_INT 1
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 3
34164: PUSH
34165: LD_INT 2
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34197: LD_ADDR_VAR 0 25
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 0
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 0
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 0
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 0
34245: PUSH
34246: LD_INT 1
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: NEG
34267: PUSH
34268: LD_INT 1
34270: NEG
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 1
34278: NEG
34279: PUSH
34280: LD_INT 2
34282: NEG
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 2
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 1
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 2
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 2
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: LD_INT 2
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: NEG
34363: PUSH
34364: LD_INT 1
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 2
34373: NEG
34374: PUSH
34375: LD_INT 0
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 2
34384: NEG
34385: PUSH
34386: LD_INT 1
34388: NEG
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 2
34396: NEG
34397: PUSH
34398: LD_INT 2
34400: NEG
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 3
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 3
34418: PUSH
34419: LD_INT 2
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 2
34428: PUSH
34429: LD_INT 3
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 3
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34471: LD_ADDR_VAR 0 26
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: LD_INT 1
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 0
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: LD_INT 1
34544: NEG
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: NEG
34553: PUSH
34554: LD_INT 2
34556: NEG
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 0
34564: PUSH
34565: LD_INT 2
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 1
34575: PUSH
34576: LD_INT 1
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 2
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: LD_INT 1
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 1
34616: PUSH
34617: LD_INT 2
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 0
34626: PUSH
34627: LD_INT 2
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 1
34636: NEG
34637: PUSH
34638: LD_INT 1
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 2
34658: NEG
34659: PUSH
34660: LD_INT 1
34662: NEG
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 2
34670: NEG
34671: PUSH
34672: LD_INT 2
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 2
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: LD_INT 3
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: NEG
34703: PUSH
34704: LD_INT 2
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 2
34713: NEG
34714: PUSH
34715: LD_INT 1
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34747: LD_ADDR_VAR 0 27
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 0
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 1
34805: NEG
34806: PUSH
34807: LD_INT 0
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 1
34828: NEG
34829: PUSH
34830: LD_INT 2
34832: NEG
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 0
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: PUSH
34852: LD_INT 1
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 0
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 1
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 2
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 1
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: LD_INT 2
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 2
34923: NEG
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: LD_INT 1
34938: NEG
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 2
34946: NEG
34947: PUSH
34948: LD_INT 2
34950: NEG
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: NEG
34959: PUSH
34960: LD_INT 2
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 2
34969: NEG
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 3
34980: NEG
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 3
34992: NEG
34993: PUSH
34994: LD_INT 2
34996: NEG
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: LIST
35024: LIST
35025: LIST
35026: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35027: LD_ADDR_VAR 0 28
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: LD_INT 0
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 0
35044: PUSH
35045: LD_INT 1
35047: NEG
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 0
35075: PUSH
35076: LD_INT 1
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: LD_INT 0
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 1
35096: NEG
35097: PUSH
35098: LD_INT 1
35100: NEG
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: LD_INT 1
35108: NEG
35109: PUSH
35110: LD_INT 2
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: LD_INT 2
35123: NEG
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 1
35131: PUSH
35132: LD_INT 1
35134: NEG
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: LD_INT 0
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 2
35152: PUSH
35153: LD_INT 1
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: LD_INT 2
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 1
35172: PUSH
35173: LD_INT 2
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 2
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: LD_INT 1
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: NEG
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 2
35214: NEG
35215: PUSH
35216: LD_INT 1
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 2
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 2
35238: NEG
35239: PUSH
35240: LD_INT 3
35242: NEG
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: LD_INT 3
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 3
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 3
35274: NEG
35275: PUSH
35276: LD_INT 2
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35309: LD_ADDR_VAR 0 29
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: LD_INT 0
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: LD_INT 1
35329: NEG
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 1
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 0
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: LD_INT 1
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: NEG
35391: PUSH
35392: LD_INT 2
35394: NEG
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 0
35402: PUSH
35403: LD_INT 2
35405: NEG
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: LD_INT 1
35416: NEG
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 2
35424: PUSH
35425: LD_INT 0
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 2
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: PUSH
35445: LD_INT 2
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 0
35454: PUSH
35455: LD_INT 2
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: NEG
35465: PUSH
35466: LD_INT 1
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 2
35475: NEG
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 2
35487: NEG
35488: PUSH
35489: LD_INT 2
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 2
35499: NEG
35500: PUSH
35501: LD_INT 3
35503: NEG
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 3
35522: PUSH
35523: LD_INT 1
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: PUSH
35533: LD_INT 3
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: LD_INT 2
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 3
35553: NEG
35554: PUSH
35555: LD_INT 2
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35588: LD_ADDR_VAR 0 30
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: LD_INT 1
35608: NEG
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: LD_INT 0
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: LD_INT 1
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: LD_INT 0
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: LD_INT 2
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 0
35681: PUSH
35682: LD_INT 2
35684: NEG
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: PUSH
35714: LD_INT 1
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 2
35723: PUSH
35724: LD_INT 2
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: LD_INT 2
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 1
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: NEG
35755: PUSH
35756: LD_INT 0
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 2
35765: NEG
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: NEG
35778: PUSH
35779: LD_INT 3
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: LD_INT 2
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 2
35810: PUSH
35811: LD_INT 3
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 2
35820: NEG
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 3
35831: NEG
35832: PUSH
35833: LD_INT 1
35835: NEG
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35866: LD_ADDR_VAR 0 31
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 0
35883: PUSH
35884: LD_INT 1
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 0
35914: PUSH
35915: LD_INT 1
35917: PUSH
35918: EMPTY
35919: LIST
35920: LIST
35921: PUSH
35922: LD_INT 1
35924: NEG
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 1
35935: NEG
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 1
35947: NEG
35948: PUSH
35949: LD_INT 2
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 0
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 2
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 2
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 1
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: NEG
36044: PUSH
36045: LD_INT 2
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 2
36055: NEG
36056: PUSH
36057: LD_INT 3
36059: NEG
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 2
36067: PUSH
36068: LD_INT 1
36070: NEG
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 3
36078: PUSH
36079: LD_INT 1
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 1
36088: PUSH
36089: LD_INT 3
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 1
36098: NEG
36099: PUSH
36100: LD_INT 2
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 3
36109: NEG
36110: PUSH
36111: LD_INT 2
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36144: LD_ADDR_VAR 0 32
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 2
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 0
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 2
36321: NEG
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: LD_INT 2
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: PUSH
36367: LD_INT 3
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 2
36376: NEG
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 3
36387: NEG
36388: PUSH
36389: LD_INT 1
36391: NEG
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36422: LD_ADDR_VAR 0 33
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 0
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 1
36503: NEG
36504: PUSH
36505: LD_INT 2
36507: NEG
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 1
36515: PUSH
36516: LD_INT 1
36518: NEG
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 1
36546: PUSH
36547: LD_INT 2
36549: PUSH
36550: EMPTY
36551: LIST
36552: LIST
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: LD_INT 2
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 1
36566: NEG
36567: PUSH
36568: LD_INT 1
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: LD_INT 0
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 2
36588: NEG
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 2
36600: NEG
36601: PUSH
36602: LD_INT 2
36604: NEG
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: PUSH
36610: LD_INT 2
36612: NEG
36613: PUSH
36614: LD_INT 3
36616: NEG
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 2
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 3
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: LD_INT 3
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 1
36655: NEG
36656: PUSH
36657: LD_INT 2
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 3
36666: NEG
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36701: LD_ADDR_VAR 0 34
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: LD_INT 2
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 2
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 1
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 1
36846: NEG
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 2
36857: NEG
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 2
36868: NEG
36869: PUSH
36870: LD_INT 1
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 2
36880: NEG
36881: PUSH
36882: LD_INT 2
36884: NEG
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 1
36892: NEG
36893: PUSH
36894: LD_INT 3
36896: NEG
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: LD_INT 2
36907: NEG
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: PUSH
36916: LD_INT 2
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: LD_INT 3
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 2
36935: NEG
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 3
36946: NEG
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36981: LD_ADDR_VAR 0 35
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 0
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: PUSH
37007: LD_INT 1
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 1
37039: NEG
37040: PUSH
37041: LD_INT 0
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: NEG
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: LIST
37092: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37093: LD_ADDR_VAR 0 36
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 0
37110: PUSH
37111: LD_INT 1
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 0
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: LD_INT 1
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: NEG
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: NEG
37175: PUSH
37176: LD_INT 2
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 2
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: LIST
37198: LIST
37199: LIST
37200: LIST
37201: LIST
37202: LIST
37203: LIST
37204: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37205: LD_ADDR_VAR 0 37
37209: PUSH
37210: LD_INT 0
37212: PUSH
37213: LD_INT 0
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: LD_INT 1
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: LD_INT 0
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 0
37253: PUSH
37254: LD_INT 1
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 1
37263: NEG
37264: PUSH
37265: LD_INT 0
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: NEG
37275: PUSH
37276: LD_INT 1
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 1
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: NEG
37298: PUSH
37299: LD_INT 1
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37317: LD_ADDR_VAR 0 38
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 0
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 1
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 0
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: LD_INT 1
37375: NEG
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 1
37386: NEG
37387: PUSH
37388: LD_INT 1
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: LD_INT 1
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37429: LD_ADDR_VAR 0 39
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 0
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: LD_INT 1
37457: PUSH
37458: LD_INT 0
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 0
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: LD_INT 0
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 1
37498: NEG
37499: PUSH
37500: LD_INT 1
37502: NEG
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: NEG
37511: PUSH
37512: LD_INT 2
37514: NEG
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: LD_INT 2
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37541: LD_ADDR_VAR 0 40
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: LD_INT 0
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 0
37558: PUSH
37559: LD_INT 1
37561: NEG
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 1
37569: PUSH
37570: LD_INT 0
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 1
37579: PUSH
37580: LD_INT 1
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 0
37589: PUSH
37590: LD_INT 1
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: NEG
37600: PUSH
37601: LD_INT 0
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: PUSH
37623: LD_INT 1
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37653: LD_ADDR_VAR 0 41
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 1
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: LD_INT 1
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: NEG
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: NEG
37735: PUSH
37736: LD_INT 2
37738: NEG
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 1
37746: PUSH
37747: LD_INT 1
37749: NEG
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 2
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: PUSH
37768: LD_INT 1
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 2
37777: PUSH
37778: LD_INT 2
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 1
37787: PUSH
37788: LD_INT 2
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 1
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 2
37808: NEG
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 2
37819: NEG
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 2
37831: NEG
37832: PUSH
37833: LD_INT 2
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 2
37843: NEG
37844: PUSH
37845: LD_INT 3
37847: NEG
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 2
37855: PUSH
37856: LD_INT 1
37858: NEG
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 3
37866: PUSH
37867: LD_INT 0
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 3
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 2
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 3
37896: PUSH
37897: LD_INT 3
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 2
37906: PUSH
37907: LD_INT 3
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: PUSH
37914: LD_INT 2
37916: NEG
37917: PUSH
37918: LD_INT 1
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 3
37927: NEG
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 3
37938: NEG
37939: PUSH
37940: LD_INT 1
37942: NEG
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 3
37950: NEG
37951: PUSH
37952: LD_INT 2
37954: NEG
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 3
37962: NEG
37963: PUSH
37964: LD_INT 3
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38003: LD_ADDR_VAR 0 42
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: LD_INT 0
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: LD_INT 1
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: LD_INT 0
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 1
38041: PUSH
38042: LD_INT 1
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: LD_INT 1
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 1
38072: NEG
38073: PUSH
38074: LD_INT 1
38076: NEG
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: LD_INT 2
38088: NEG
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 0
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: LD_INT 1
38110: NEG
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 2
38118: PUSH
38119: LD_INT 1
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 2
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: LD_INT 2
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 2
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 1
38158: NEG
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 2
38169: NEG
38170: PUSH
38171: LD_INT 1
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: NEG
38182: PUSH
38183: LD_INT 2
38185: NEG
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: NEG
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 1
38205: NEG
38206: PUSH
38207: LD_INT 3
38209: NEG
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: LD_INT 3
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 3
38239: PUSH
38240: LD_INT 2
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 3
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 2
38259: PUSH
38260: LD_INT 3
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 3
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 3
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: LD_INT 2
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 3
38300: NEG
38301: PUSH
38302: LD_INT 2
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 3
38312: NEG
38313: PUSH
38314: LD_INT 3
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38353: LD_ADDR_VAR 0 43
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: LD_INT 1
38373: NEG
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: LD_INT 0
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 1
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 0
38401: PUSH
38402: LD_INT 1
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 1
38411: NEG
38412: PUSH
38413: LD_INT 0
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: NEG
38423: PUSH
38424: LD_INT 1
38426: NEG
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 1
38434: NEG
38435: PUSH
38436: LD_INT 2
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 0
38446: PUSH
38447: LD_INT 2
38449: NEG
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: LD_INT 0
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: PUSH
38479: LD_INT 1
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: LD_INT 2
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 0
38498: PUSH
38499: LD_INT 2
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 1
38508: NEG
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 2
38519: NEG
38520: PUSH
38521: LD_INT 0
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 2
38530: NEG
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: LD_INT 3
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 0
38554: PUSH
38555: LD_INT 3
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: LD_INT 2
38568: NEG
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 2
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 3
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 3
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: LD_INT 3
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: LD_INT 3
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: LD_INT 2
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 2
38638: NEG
38639: PUSH
38640: LD_INT 1
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 3
38649: NEG
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 3
38660: NEG
38661: PUSH
38662: LD_INT 1
38664: NEG
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38701: LD_ADDR_VAR 0 44
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 0
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 0
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 1
38739: PUSH
38740: LD_INT 1
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: LD_INT 1
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: NEG
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: LD_INT 2
38786: NEG
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PUSH
38792: LD_INT 1
38794: PUSH
38795: LD_INT 1
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 2
38805: PUSH
38806: LD_INT 0
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: PUSH
38816: LD_INT 1
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 2
38825: PUSH
38826: LD_INT 2
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 1
38835: PUSH
38836: LD_INT 2
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 1
38845: NEG
38846: PUSH
38847: LD_INT 1
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 2
38856: NEG
38857: PUSH
38858: LD_INT 0
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 2
38867: NEG
38868: PUSH
38869: LD_INT 1
38871: NEG
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 2
38879: NEG
38880: PUSH
38881: LD_INT 2
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 2
38891: NEG
38892: PUSH
38893: LD_INT 3
38895: NEG
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: LD_INT 2
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: LD_INT 3
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 3
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: NEG
38965: PUSH
38966: LD_INT 1
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 3
38975: NEG
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PUSH
38984: LD_INT 3
38986: NEG
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 3
38998: NEG
38999: PUSH
39000: LD_INT 2
39002: NEG
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 3
39010: NEG
39011: PUSH
39012: LD_INT 3
39014: NEG
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: LIST
39034: LIST
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39051: LD_ADDR_VAR 0 45
39055: PUSH
39056: LD_INT 0
39058: PUSH
39059: LD_INT 0
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 0
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 0
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PUSH
39087: LD_INT 1
39089: PUSH
39090: LD_INT 1
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: LD_INT 1
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PUSH
39130: LD_INT 1
39132: NEG
39133: PUSH
39134: LD_INT 2
39136: NEG
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 2
39147: NEG
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: PUSH
39156: LD_INT 1
39158: NEG
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 1
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 2
39176: PUSH
39177: LD_INT 2
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 1
39186: PUSH
39187: LD_INT 2
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 0
39196: PUSH
39197: LD_INT 2
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: LD_INT 1
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 2
39217: NEG
39218: PUSH
39219: LD_INT 1
39221: NEG
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 2
39241: NEG
39242: PUSH
39243: LD_INT 3
39245: NEG
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 1
39253: NEG
39254: PUSH
39255: LD_INT 3
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: LD_INT 3
39268: NEG
39269: PUSH
39270: EMPTY
39271: LIST
39272: LIST
39273: PUSH
39274: LD_INT 1
39276: PUSH
39277: LD_INT 2
39279: NEG
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 3
39287: PUSH
39288: LD_INT 2
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 3
39297: PUSH
39298: LD_INT 3
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 2
39307: PUSH
39308: LD_INT 3
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: LD_INT 3
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: LD_INT 3
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: LD_INT 2
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: LD_INT 3
39348: NEG
39349: PUSH
39350: LD_INT 2
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 3
39360: NEG
39361: PUSH
39362: LD_INT 3
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: LIST
39374: LIST
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: LIST
39385: LIST
39386: LIST
39387: LIST
39388: LIST
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39401: LD_ADDR_VAR 0 46
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: LD_INT 0
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 0
39449: PUSH
39450: LD_INT 1
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: LD_INT 0
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 1
39470: NEG
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 1
39482: NEG
39483: PUSH
39484: LD_INT 2
39486: NEG
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 0
39494: PUSH
39495: LD_INT 2
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: LD_INT 1
39508: NEG
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 2
39516: PUSH
39517: LD_INT 0
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 2
39526: PUSH
39527: LD_INT 1
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 1
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: LD_INT 2
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 1
39556: NEG
39557: PUSH
39558: LD_INT 1
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: LD_INT 0
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 2
39578: NEG
39579: PUSH
39580: LD_INT 1
39582: NEG
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: LD_INT 1
39590: NEG
39591: PUSH
39592: LD_INT 3
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 0
39602: PUSH
39603: LD_INT 3
39605: NEG
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 1
39613: PUSH
39614: LD_INT 2
39616: NEG
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 2
39624: PUSH
39625: LD_INT 1
39627: NEG
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 3
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: LD_INT 1
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: LD_INT 3
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: LD_INT 2
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 2
39686: NEG
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 3
39697: NEG
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 3
39708: NEG
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: LIST
39733: LIST
39734: LIST
39735: LIST
39736: LIST
39737: LIST
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39749: LD_ADDR_VAR 0 47
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: LD_INT 0
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: LD_INT 1
39769: NEG
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 1
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 0
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 1
39807: NEG
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 1
39818: NEG
39819: PUSH
39820: LD_INT 1
39822: NEG
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: LD_INT 2
39834: NEG
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 0
39842: PUSH
39843: LD_INT 2
39845: NEG
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: LD_INT 1
39853: PUSH
39854: LD_INT 1
39856: NEG
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 2
39864: NEG
39865: PUSH
39866: LD_INT 1
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 2
39876: NEG
39877: PUSH
39878: LD_INT 2
39880: NEG
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39900: LD_ADDR_VAR 0 48
39904: PUSH
39905: LD_INT 0
39907: PUSH
39908: LD_INT 0
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: LD_INT 1
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 1
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: LD_INT 1
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: LD_INT 1
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 1
39958: NEG
39959: PUSH
39960: LD_INT 0
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 1
39969: NEG
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 1
39981: NEG
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: LD_INT 2
39996: NEG
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: LD_INT 1
40007: NEG
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 2
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 2
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40047: LD_ADDR_VAR 0 49
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 0
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 0
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 1
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 0
40095: PUSH
40096: LD_INT 1
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 1
40105: NEG
40106: PUSH
40107: LD_INT 0
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 1
40116: NEG
40117: PUSH
40118: LD_INT 1
40120: NEG
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 1
40128: PUSH
40129: LD_INT 1
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 2
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 2
40159: PUSH
40160: LD_INT 2
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 1
40169: PUSH
40170: LD_INT 2
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40191: LD_ADDR_VAR 0 50
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: LD_INT 1
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: LD_INT 0
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 1
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 0
40239: PUSH
40240: LD_INT 1
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 1
40249: NEG
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 1
40260: NEG
40261: PUSH
40262: LD_INT 1
40264: NEG
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: LD_INT 1
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 2
40282: PUSH
40283: LD_INT 2
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 1
40292: PUSH
40293: LD_INT 2
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 0
40302: PUSH
40303: LD_INT 2
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: LD_INT 1
40312: NEG
40313: PUSH
40314: LD_INT 1
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40335: LD_ADDR_VAR 0 51
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 0
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 0
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: LD_INT 1
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: LD_INT 0
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: LD_INT 1
40408: NEG
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 1
40416: PUSH
40417: LD_INT 2
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 0
40426: PUSH
40427: LD_INT 2
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 1
40436: NEG
40437: PUSH
40438: LD_INT 1
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 2
40447: NEG
40448: PUSH
40449: LD_INT 0
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 2
40458: NEG
40459: PUSH
40460: LD_INT 1
40462: NEG
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: LIST
40472: LIST
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40482: LD_ADDR_VAR 0 52
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 0
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 1
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 1
40563: NEG
40564: PUSH
40565: LD_INT 2
40567: NEG
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: LD_INT 1
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 2
40586: NEG
40587: PUSH
40588: LD_INT 0
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: LD_INT 2
40613: NEG
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40633: LD_ADDR_VAR 0 53
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 0
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 1
40661: PUSH
40662: LD_INT 0
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 1
40671: PUSH
40672: LD_INT 1
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 0
40681: PUSH
40682: LD_INT 1
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 1
40691: NEG
40692: PUSH
40693: LD_INT 0
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 1
40702: NEG
40703: PUSH
40704: LD_INT 1
40706: NEG
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 1
40714: NEG
40715: PUSH
40716: LD_INT 2
40718: NEG
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: LD_INT 2
40729: NEG
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 1
40737: PUSH
40738: LD_INT 1
40740: NEG
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 2
40748: PUSH
40749: LD_INT 0
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 2
40758: PUSH
40759: LD_INT 1
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 2
40768: PUSH
40769: LD_INT 2
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: LD_INT 2
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: LD_INT 2
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 1
40798: NEG
40799: PUSH
40800: LD_INT 1
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 2
40809: NEG
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 2
40820: NEG
40821: PUSH
40822: LD_INT 1
40824: NEG
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 2
40832: NEG
40833: PUSH
40834: LD_INT 2
40836: NEG
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: LIST
40853: LIST
40854: LIST
40855: LIST
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40863: LD_ADDR_VAR 0 54
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 1
40891: PUSH
40892: LD_INT 0
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 1
40901: PUSH
40902: LD_INT 1
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: LD_INT 0
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 1
40921: NEG
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 1
40932: NEG
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 1
40944: NEG
40945: PUSH
40946: LD_INT 2
40948: NEG
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 0
40956: PUSH
40957: LD_INT 2
40959: NEG
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: LD_INT 1
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 2
40978: PUSH
40979: LD_INT 0
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 1
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 2
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 0
41018: PUSH
41019: LD_INT 2
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 1
41028: NEG
41029: PUSH
41030: LD_INT 1
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: LD_INT 1
41054: NEG
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: NEG
41063: PUSH
41064: LD_INT 2
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41093: LD_ADDR_VAR 0 55
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 0
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: LD_INT 1
41113: NEG
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 0
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 1
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 0
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 1
41151: NEG
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 1
41162: NEG
41163: PUSH
41164: LD_INT 1
41166: NEG
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 1
41174: NEG
41175: PUSH
41176: LD_INT 2
41178: NEG
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 0
41186: PUSH
41187: LD_INT 2
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 1
41197: PUSH
41198: LD_INT 1
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 2
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: PUSH
41219: LD_INT 1
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 2
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 1
41238: PUSH
41239: LD_INT 2
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 0
41248: PUSH
41249: LD_INT 2
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 1
41258: NEG
41259: PUSH
41260: LD_INT 1
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 2
41269: NEG
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 2
41280: NEG
41281: PUSH
41282: LD_INT 1
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 2
41292: NEG
41293: PUSH
41294: LD_INT 2
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: LIST
41315: LIST
41316: LIST
41317: LIST
41318: LIST
41319: LIST
41320: LIST
41321: LIST
41322: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41323: LD_ADDR_VAR 0 56
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: LD_INT 0
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 0
41340: PUSH
41341: LD_INT 1
41343: NEG
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 1
41361: PUSH
41362: LD_INT 1
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 0
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 1
41381: NEG
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: LD_INT 1
41396: NEG
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: LD_INT 2
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 0
41416: PUSH
41417: LD_INT 2
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 1
41427: PUSH
41428: LD_INT 1
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: LD_INT 0
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 2
41448: PUSH
41449: LD_INT 1
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 2
41458: PUSH
41459: LD_INT 2
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: LD_INT 2
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 0
41478: PUSH
41479: LD_INT 2
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 1
41488: NEG
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 2
41499: NEG
41500: PUSH
41501: LD_INT 0
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 2
41510: NEG
41511: PUSH
41512: LD_INT 1
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 2
41522: NEG
41523: PUSH
41524: LD_INT 2
41526: NEG
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41553: LD_ADDR_VAR 0 57
41557: PUSH
41558: LD_INT 0
41560: PUSH
41561: LD_INT 0
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 0
41570: PUSH
41571: LD_INT 1
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: LD_INT 0
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 1
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: LD_INT 1
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 1
41611: NEG
41612: PUSH
41613: LD_INT 0
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: LD_INT 1
41622: NEG
41623: PUSH
41624: LD_INT 1
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 1
41634: NEG
41635: PUSH
41636: LD_INT 2
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 0
41646: PUSH
41647: LD_INT 2
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: LD_INT 1
41660: NEG
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 2
41668: PUSH
41669: LD_INT 0
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 2
41678: PUSH
41679: LD_INT 1
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 2
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 1
41698: PUSH
41699: LD_INT 2
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 0
41708: PUSH
41709: LD_INT 2
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 1
41718: NEG
41719: PUSH
41720: LD_INT 1
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 2
41729: NEG
41730: PUSH
41731: LD_INT 0
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: PUSH
41738: LD_INT 2
41740: NEG
41741: PUSH
41742: LD_INT 1
41744: NEG
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: LD_INT 2
41752: NEG
41753: PUSH
41754: LD_INT 2
41756: NEG
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41783: LD_ADDR_VAR 0 58
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 0
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: LD_INT 1
41803: NEG
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 1
41811: PUSH
41812: LD_INT 0
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 1
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 0
41831: PUSH
41832: LD_INT 1
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: LD_INT 0
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 1
41852: NEG
41853: PUSH
41854: LD_INT 1
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 1
41864: NEG
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 0
41876: PUSH
41877: LD_INT 2
41879: NEG
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 1
41887: PUSH
41888: LD_INT 1
41890: NEG
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: PUSH
41899: LD_INT 0
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 2
41908: PUSH
41909: LD_INT 1
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 2
41918: PUSH
41919: LD_INT 2
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 1
41928: PUSH
41929: LD_INT 2
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 0
41938: PUSH
41939: LD_INT 2
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 1
41948: NEG
41949: PUSH
41950: LD_INT 1
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 2
41959: NEG
41960: PUSH
41961: LD_INT 0
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 2
41970: NEG
41971: PUSH
41972: LD_INT 1
41974: NEG
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 2
41982: NEG
41983: PUSH
41984: LD_INT 2
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: LIST
42008: LIST
42009: LIST
42010: LIST
42011: LIST
42012: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42013: LD_ADDR_VAR 0 59
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: LD_INT 0
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 0
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 1
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 1
42051: PUSH
42052: LD_INT 1
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 0
42061: PUSH
42062: LD_INT 1
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 1
42071: NEG
42072: PUSH
42073: LD_INT 0
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 1
42082: NEG
42083: PUSH
42084: LD_INT 1
42086: NEG
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42101: LD_ADDR_VAR 0 60
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PUSH
42116: LD_INT 0
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 1
42129: PUSH
42130: LD_INT 0
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 1
42139: PUSH
42140: LD_INT 1
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 0
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 1
42159: NEG
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 1
42170: NEG
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42189: LD_ADDR_VAR 0 61
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: LD_INT 0
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_INT 0
42206: PUSH
42207: LD_INT 1
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: PUSH
42218: LD_INT 0
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 1
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 0
42237: PUSH
42238: LD_INT 1
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 1
42247: NEG
42248: PUSH
42249: LD_INT 0
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 1
42258: NEG
42259: PUSH
42260: LD_INT 1
42262: NEG
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42277: LD_ADDR_VAR 0 62
42281: PUSH
42282: LD_INT 0
42284: PUSH
42285: LD_INT 0
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: LD_INT 0
42294: PUSH
42295: LD_INT 1
42297: NEG
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 1
42305: PUSH
42306: LD_INT 0
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 1
42315: PUSH
42316: LD_INT 1
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 0
42325: PUSH
42326: LD_INT 1
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 1
42335: NEG
42336: PUSH
42337: LD_INT 0
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 1
42346: NEG
42347: PUSH
42348: LD_INT 1
42350: NEG
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42365: LD_ADDR_VAR 0 63
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: LD_INT 0
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PUSH
42380: LD_INT 0
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 1
42393: PUSH
42394: LD_INT 0
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: LD_INT 1
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 1
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: EMPTY
42429: LIST
42430: LIST
42431: PUSH
42432: LD_INT 1
42434: NEG
42435: PUSH
42436: LD_INT 1
42438: NEG
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42453: LD_ADDR_VAR 0 64
42457: PUSH
42458: LD_INT 0
42460: PUSH
42461: LD_INT 0
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: LD_INT 1
42473: NEG
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 1
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: LD_INT 1
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: LD_INT 0
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 1
42522: NEG
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: LIST
42538: LIST
42539: LIST
42540: ST_TO_ADDR
// end ; 1 :
42541: GO 48438
42543: LD_INT 1
42545: DOUBLE
42546: EQUAL
42547: IFTRUE 42551
42549: GO 45174
42551: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42552: LD_ADDR_VAR 0 11
42556: PUSH
42557: LD_INT 1
42559: NEG
42560: PUSH
42561: LD_INT 3
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 0
42571: PUSH
42572: LD_INT 3
42574: NEG
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 1
42582: PUSH
42583: LD_INT 2
42585: NEG
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: LIST
42595: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42596: LD_ADDR_VAR 0 12
42600: PUSH
42601: LD_INT 2
42603: PUSH
42604: LD_INT 1
42606: NEG
42607: PUSH
42608: EMPTY
42609: LIST
42610: LIST
42611: PUSH
42612: LD_INT 3
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 3
42624: PUSH
42625: LD_INT 1
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: LIST
42636: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42637: LD_ADDR_VAR 0 13
42641: PUSH
42642: LD_INT 3
42644: PUSH
42645: LD_INT 2
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 3
42654: PUSH
42655: LD_INT 3
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 2
42664: PUSH
42665: LD_INT 3
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: LIST
42676: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42677: LD_ADDR_VAR 0 14
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 0
42694: PUSH
42695: LD_INT 3
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: NEG
42705: PUSH
42706: LD_INT 2
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: LIST
42717: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42718: LD_ADDR_VAR 0 15
42722: PUSH
42723: LD_INT 2
42725: NEG
42726: PUSH
42727: LD_INT 1
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 3
42736: NEG
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 3
42747: NEG
42748: PUSH
42749: LD_INT 1
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: LIST
42761: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42762: LD_ADDR_VAR 0 16
42766: PUSH
42767: LD_INT 2
42769: NEG
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 3
42781: NEG
42782: PUSH
42783: LD_INT 2
42785: NEG
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: LD_INT 3
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: EMPTY
42804: LIST
42805: LIST
42806: LIST
42807: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42808: LD_ADDR_VAR 0 17
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 3
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: LD_INT 3
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: PUSH
42839: LD_INT 2
42841: NEG
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: LIST
42851: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42852: LD_ADDR_VAR 0 18
42856: PUSH
42857: LD_INT 2
42859: PUSH
42860: LD_INT 1
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 0
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 3
42880: PUSH
42881: LD_INT 1
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42893: LD_ADDR_VAR 0 19
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 2
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 3
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 2
42920: PUSH
42921: LD_INT 3
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42933: LD_ADDR_VAR 0 20
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 0
42950: PUSH
42951: LD_INT 3
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 1
42960: NEG
42961: PUSH
42962: LD_INT 2
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42974: LD_ADDR_VAR 0 21
42978: PUSH
42979: LD_INT 2
42981: NEG
42982: PUSH
42983: LD_INT 1
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: NEG
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 3
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: LIST
43017: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43018: LD_ADDR_VAR 0 22
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: LD_INT 3
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 3
43037: NEG
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 3
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: LIST
43063: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43064: LD_ADDR_VAR 0 23
43068: PUSH
43069: LD_INT 0
43071: PUSH
43072: LD_INT 3
43074: NEG
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 1
43082: NEG
43083: PUSH
43084: LD_INT 4
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: LD_INT 3
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43108: LD_ADDR_VAR 0 24
43112: PUSH
43113: LD_INT 3
43115: PUSH
43116: LD_INT 0
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 3
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 4
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43149: LD_ADDR_VAR 0 25
43153: PUSH
43154: LD_INT 3
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 4
43166: PUSH
43167: LD_INT 3
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 3
43176: PUSH
43177: LD_INT 4
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43189: LD_ADDR_VAR 0 26
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: LD_INT 3
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 1
43206: PUSH
43207: LD_INT 4
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: LD_INT 3
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: LIST
43229: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43230: LD_ADDR_VAR 0 27
43234: PUSH
43235: LD_INT 3
43237: NEG
43238: PUSH
43239: LD_INT 0
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 3
43248: NEG
43249: PUSH
43250: LD_INT 1
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 4
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43274: LD_ADDR_VAR 0 28
43278: PUSH
43279: LD_INT 3
43281: NEG
43282: PUSH
43283: LD_INT 3
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 3
43293: NEG
43294: PUSH
43295: LD_INT 4
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 4
43305: NEG
43306: PUSH
43307: LD_INT 3
43309: NEG
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: LIST
43319: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43320: LD_ADDR_VAR 0 29
43324: PUSH
43325: LD_INT 1
43327: NEG
43328: PUSH
43329: LD_INT 3
43331: NEG
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 0
43339: PUSH
43340: LD_INT 3
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 1
43350: PUSH
43351: LD_INT 2
43353: NEG
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: PUSH
43359: LD_INT 1
43361: NEG
43362: PUSH
43363: LD_INT 4
43365: NEG
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 0
43373: PUSH
43374: LD_INT 4
43376: NEG
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: LD_INT 1
43384: PUSH
43385: LD_INT 3
43387: NEG
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 1
43395: NEG
43396: PUSH
43397: LD_INT 5
43399: NEG
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 0
43407: PUSH
43408: LD_INT 5
43410: NEG
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 1
43418: PUSH
43419: LD_INT 4
43421: NEG
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 1
43429: NEG
43430: PUSH
43431: LD_INT 6
43433: NEG
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 0
43441: PUSH
43442: LD_INT 6
43444: NEG
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: LD_INT 1
43452: PUSH
43453: LD_INT 5
43455: NEG
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: LIST
43467: LIST
43468: LIST
43469: LIST
43470: LIST
43471: LIST
43472: LIST
43473: LIST
43474: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43475: LD_ADDR_VAR 0 30
43479: PUSH
43480: LD_INT 2
43482: PUSH
43483: LD_INT 1
43485: NEG
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: PUSH
43504: LD_INT 1
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 3
43513: PUSH
43514: LD_INT 1
43516: NEG
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: LD_INT 0
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 4
43534: PUSH
43535: LD_INT 1
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 4
43544: PUSH
43545: LD_INT 1
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 5
43555: PUSH
43556: LD_INT 0
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 5
43565: PUSH
43566: LD_INT 1
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 5
43575: PUSH
43576: LD_INT 1
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 6
43586: PUSH
43587: LD_INT 0
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 6
43596: PUSH
43597: LD_INT 1
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: LIST
43616: LIST
43617: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43618: LD_ADDR_VAR 0 31
43622: PUSH
43623: LD_INT 3
43625: PUSH
43626: LD_INT 2
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 3
43635: PUSH
43636: LD_INT 3
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 2
43645: PUSH
43646: LD_INT 3
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 4
43655: PUSH
43656: LD_INT 3
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: LD_INT 4
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 4
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 5
43685: PUSH
43686: LD_INT 4
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 5
43695: PUSH
43696: LD_INT 5
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 4
43705: PUSH
43706: LD_INT 5
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 6
43715: PUSH
43716: LD_INT 5
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 6
43725: PUSH
43726: LD_INT 6
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: LD_INT 5
43735: PUSH
43736: LD_INT 6
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43757: LD_ADDR_VAR 0 32
43761: PUSH
43762: LD_INT 1
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 0
43774: PUSH
43775: LD_INT 3
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: LD_INT 1
43784: NEG
43785: PUSH
43786: LD_INT 2
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 1
43795: PUSH
43796: LD_INT 4
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: LD_INT 4
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: PUSH
43813: LD_INT 1
43815: NEG
43816: PUSH
43817: LD_INT 3
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 1
43826: PUSH
43827: LD_INT 5
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 5
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 1
43846: NEG
43847: PUSH
43848: LD_INT 4
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 1
43857: PUSH
43858: LD_INT 6
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 6
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 1
43877: NEG
43878: PUSH
43879: LD_INT 5
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43900: LD_ADDR_VAR 0 33
43904: PUSH
43905: LD_INT 2
43907: NEG
43908: PUSH
43909: LD_INT 1
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 3
43918: NEG
43919: PUSH
43920: LD_INT 0
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 3
43929: NEG
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 3
43941: NEG
43942: PUSH
43943: LD_INT 1
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 4
43952: NEG
43953: PUSH
43954: LD_INT 0
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 4
43963: NEG
43964: PUSH
43965: LD_INT 1
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 4
43975: NEG
43976: PUSH
43977: LD_INT 1
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 5
43986: NEG
43987: PUSH
43988: LD_INT 0
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 5
43997: NEG
43998: PUSH
43999: LD_INT 1
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 5
44009: NEG
44010: PUSH
44011: LD_INT 1
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 6
44020: NEG
44021: PUSH
44022: LD_INT 0
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 6
44031: NEG
44032: PUSH
44033: LD_INT 1
44035: NEG
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: LIST
44045: LIST
44046: LIST
44047: LIST
44048: LIST
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44055: LD_ADDR_VAR 0 34
44059: PUSH
44060: LD_INT 2
44062: NEG
44063: PUSH
44064: LD_INT 3
44066: NEG
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 3
44074: NEG
44075: PUSH
44076: LD_INT 2
44078: NEG
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: LD_INT 3
44090: NEG
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 3
44098: NEG
44099: PUSH
44100: LD_INT 4
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 4
44110: NEG
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 4
44122: NEG
44123: PUSH
44124: LD_INT 4
44126: NEG
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 4
44134: NEG
44135: PUSH
44136: LD_INT 5
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 5
44146: NEG
44147: PUSH
44148: LD_INT 4
44150: NEG
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 5
44158: NEG
44159: PUSH
44160: LD_INT 5
44162: NEG
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 5
44170: NEG
44171: PUSH
44172: LD_INT 6
44174: NEG
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 6
44182: NEG
44183: PUSH
44184: LD_INT 5
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 6
44194: NEG
44195: PUSH
44196: LD_INT 6
44198: NEG
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: LIST
44208: LIST
44209: LIST
44210: LIST
44211: LIST
44212: LIST
44213: LIST
44214: LIST
44215: LIST
44216: LIST
44217: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44218: LD_ADDR_VAR 0 41
44222: PUSH
44223: LD_INT 0
44225: PUSH
44226: LD_INT 2
44228: NEG
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 1
44236: NEG
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 1
44248: PUSH
44249: LD_INT 2
44251: NEG
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: LIST
44261: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44262: LD_ADDR_VAR 0 42
44266: PUSH
44267: LD_INT 2
44269: PUSH
44270: LD_INT 0
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 2
44279: PUSH
44280: LD_INT 1
44282: NEG
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 3
44290: PUSH
44291: LD_INT 1
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: LIST
44302: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44303: LD_ADDR_VAR 0 43
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 3
44320: PUSH
44321: LD_INT 2
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 3
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: LIST
44342: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44343: LD_ADDR_VAR 0 44
44347: PUSH
44348: LD_INT 0
44350: PUSH
44351: LD_INT 2
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 1
44360: PUSH
44361: LD_INT 3
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 1
44370: NEG
44371: PUSH
44372: LD_INT 2
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: LIST
44383: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44384: LD_ADDR_VAR 0 45
44388: PUSH
44389: LD_INT 2
44391: NEG
44392: PUSH
44393: LD_INT 0
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: LD_INT 2
44402: NEG
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: PUSH
44411: LD_INT 3
44413: NEG
44414: PUSH
44415: LD_INT 1
44417: NEG
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: LIST
44427: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44428: LD_ADDR_VAR 0 46
44432: PUSH
44433: LD_INT 2
44435: NEG
44436: PUSH
44437: LD_INT 2
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 2
44447: NEG
44448: PUSH
44449: LD_INT 3
44451: NEG
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 3
44459: NEG
44460: PUSH
44461: LD_INT 2
44463: NEG
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: LIST
44473: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44474: LD_ADDR_VAR 0 47
44478: PUSH
44479: LD_INT 2
44481: NEG
44482: PUSH
44483: LD_INT 3
44485: NEG
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 1
44493: NEG
44494: PUSH
44495: LD_INT 3
44497: NEG
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44507: LD_ADDR_VAR 0 48
44511: PUSH
44512: LD_INT 1
44514: PUSH
44515: LD_INT 2
44517: NEG
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 1
44528: NEG
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44538: LD_ADDR_VAR 0 49
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: LD_INT 1
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 3
44555: PUSH
44556: LD_INT 2
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44567: LD_ADDR_VAR 0 50
44571: PUSH
44572: LD_INT 2
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 1
44584: PUSH
44585: LD_INT 3
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44596: LD_ADDR_VAR 0 51
44600: PUSH
44601: LD_INT 1
44603: NEG
44604: PUSH
44605: LD_INT 2
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 2
44614: NEG
44615: PUSH
44616: LD_INT 1
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44627: LD_ADDR_VAR 0 52
44631: PUSH
44632: LD_INT 3
44634: NEG
44635: PUSH
44636: LD_INT 1
44638: NEG
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 3
44646: NEG
44647: PUSH
44648: LD_INT 2
44650: NEG
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44660: LD_ADDR_VAR 0 53
44664: PUSH
44665: LD_INT 1
44667: NEG
44668: PUSH
44669: LD_INT 3
44671: NEG
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 0
44679: PUSH
44680: LD_INT 3
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 1
44690: PUSH
44691: LD_INT 2
44693: NEG
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: LIST
44703: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44704: LD_ADDR_VAR 0 54
44708: PUSH
44709: LD_INT 2
44711: PUSH
44712: LD_INT 1
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: LD_INT 0
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 3
44732: PUSH
44733: LD_INT 1
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: LIST
44744: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44745: LD_ADDR_VAR 0 55
44749: PUSH
44750: LD_INT 3
44752: PUSH
44753: LD_INT 2
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 3
44762: PUSH
44763: LD_INT 3
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 2
44772: PUSH
44773: LD_INT 3
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: LIST
44784: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44785: LD_ADDR_VAR 0 56
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: LD_INT 0
44802: PUSH
44803: LD_INT 3
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 1
44812: NEG
44813: PUSH
44814: LD_INT 2
44816: PUSH
44817: EMPTY
44818: LIST
44819: LIST
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: LIST
44825: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44826: LD_ADDR_VAR 0 57
44830: PUSH
44831: LD_INT 2
44833: NEG
44834: PUSH
44835: LD_INT 1
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 3
44844: NEG
44845: PUSH
44846: LD_INT 0
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 3
44855: NEG
44856: PUSH
44857: LD_INT 1
44859: NEG
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: LIST
44869: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44870: LD_ADDR_VAR 0 58
44874: PUSH
44875: LD_INT 2
44877: NEG
44878: PUSH
44879: LD_INT 3
44881: NEG
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 3
44889: NEG
44890: PUSH
44891: LD_INT 2
44893: NEG
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 3
44901: NEG
44902: PUSH
44903: LD_INT 3
44905: NEG
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: LIST
44915: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44916: LD_ADDR_VAR 0 59
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: LD_INT 2
44927: NEG
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 0
44935: PUSH
44936: LD_INT 2
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 1
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: LIST
44959: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44960: LD_ADDR_VAR 0 60
44964: PUSH
44965: LD_INT 1
44967: PUSH
44968: LD_INT 1
44970: NEG
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 2
44978: PUSH
44979: LD_INT 0
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 2
44988: PUSH
44989: LD_INT 1
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: LIST
45000: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45001: LD_ADDR_VAR 0 61
45005: PUSH
45006: LD_INT 2
45008: PUSH
45009: LD_INT 1
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 2
45018: PUSH
45019: LD_INT 2
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 1
45028: PUSH
45029: LD_INT 2
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: LIST
45040: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45041: LD_ADDR_VAR 0 62
45045: PUSH
45046: LD_INT 1
45048: PUSH
45049: LD_INT 2
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 0
45058: PUSH
45059: LD_INT 2
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 1
45068: NEG
45069: PUSH
45070: LD_INT 1
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: LIST
45081: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45082: LD_ADDR_VAR 0 63
45086: PUSH
45087: LD_INT 1
45089: NEG
45090: PUSH
45091: LD_INT 1
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: PUSH
45098: LD_INT 2
45100: NEG
45101: PUSH
45102: LD_INT 0
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 2
45111: NEG
45112: PUSH
45113: LD_INT 1
45115: NEG
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: LIST
45125: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45126: LD_ADDR_VAR 0 64
45130: PUSH
45131: LD_INT 1
45133: NEG
45134: PUSH
45135: LD_INT 2
45137: NEG
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: LD_INT 2
45145: NEG
45146: PUSH
45147: LD_INT 1
45149: NEG
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 2
45157: NEG
45158: PUSH
45159: LD_INT 2
45161: NEG
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: LIST
45171: ST_TO_ADDR
// end ; 2 :
45172: GO 48438
45174: LD_INT 2
45176: DOUBLE
45177: EQUAL
45178: IFTRUE 45182
45180: GO 48437
45182: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45183: LD_ADDR_VAR 0 29
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: LD_INT 0
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 4
45200: PUSH
45201: LD_INT 1
45203: NEG
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 5
45211: PUSH
45212: LD_INT 0
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 5
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 4
45231: PUSH
45232: LD_INT 1
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: PUSH
45242: LD_INT 0
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 3
45251: PUSH
45252: LD_INT 1
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 3
45262: PUSH
45263: LD_INT 2
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 5
45273: PUSH
45274: LD_INT 2
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 3
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: LD_INT 2
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 4
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 4
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 3
45323: PUSH
45324: LD_INT 4
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: PUSH
45331: LD_INT 2
45333: PUSH
45334: LD_INT 3
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 2
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: PUSH
45351: LD_INT 4
45353: PUSH
45354: LD_INT 2
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 2
45363: PUSH
45364: LD_INT 4
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 0
45373: PUSH
45374: LD_INT 4
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 0
45383: PUSH
45384: LD_INT 3
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: LD_INT 4
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 1
45403: PUSH
45404: LD_INT 5
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 0
45413: PUSH
45414: LD_INT 5
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 1
45423: NEG
45424: PUSH
45425: LD_INT 4
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 1
45434: NEG
45435: PUSH
45436: LD_INT 3
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 2
45445: PUSH
45446: LD_INT 5
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 2
45455: NEG
45456: PUSH
45457: LD_INT 3
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 3
45466: NEG
45467: PUSH
45468: LD_INT 0
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: LD_INT 3
45477: NEG
45478: PUSH
45479: LD_INT 1
45481: NEG
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 2
45489: NEG
45490: PUSH
45491: LD_INT 0
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 2
45500: NEG
45501: PUSH
45502: LD_INT 1
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 3
45511: NEG
45512: PUSH
45513: LD_INT 1
45515: PUSH
45516: EMPTY
45517: LIST
45518: LIST
45519: PUSH
45520: LD_INT 4
45522: NEG
45523: PUSH
45524: LD_INT 0
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 4
45533: NEG
45534: PUSH
45535: LD_INT 1
45537: NEG
45538: PUSH
45539: EMPTY
45540: LIST
45541: LIST
45542: PUSH
45543: LD_INT 4
45545: NEG
45546: PUSH
45547: LD_INT 2
45549: NEG
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: PUSH
45555: LD_INT 2
45557: NEG
45558: PUSH
45559: LD_INT 2
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 4
45568: NEG
45569: PUSH
45570: LD_INT 4
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 4
45580: NEG
45581: PUSH
45582: LD_INT 5
45584: NEG
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 3
45592: NEG
45593: PUSH
45594: LD_INT 4
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: LD_INT 3
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 4
45616: NEG
45617: PUSH
45618: LD_INT 3
45620: NEG
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 5
45628: NEG
45629: PUSH
45630: LD_INT 4
45632: NEG
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 5
45640: NEG
45641: PUSH
45642: LD_INT 5
45644: NEG
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: LD_INT 3
45652: NEG
45653: PUSH
45654: LD_INT 5
45656: NEG
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 5
45664: NEG
45665: PUSH
45666: LD_INT 3
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: LIST
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45721: LD_ADDR_VAR 0 30
45725: PUSH
45726: LD_INT 4
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 4
45738: PUSH
45739: LD_INT 3
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 5
45748: PUSH
45749: LD_INT 4
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 5
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 4
45768: PUSH
45769: LD_INT 5
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 3
45778: PUSH
45779: LD_INT 4
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 3
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 5
45798: PUSH
45799: LD_INT 3
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 3
45808: PUSH
45809: LD_INT 5
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 0
45818: PUSH
45819: LD_INT 3
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 0
45828: PUSH
45829: LD_INT 2
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 1
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 0
45858: PUSH
45859: LD_INT 4
45861: PUSH
45862: EMPTY
45863: LIST
45864: LIST
45865: PUSH
45866: LD_INT 1
45868: NEG
45869: PUSH
45870: LD_INT 3
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: LD_INT 1
45879: NEG
45880: PUSH
45881: LD_INT 2
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 2
45890: PUSH
45891: LD_INT 4
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: PUSH
45898: LD_INT 2
45900: NEG
45901: PUSH
45902: LD_INT 2
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 4
45911: NEG
45912: PUSH
45913: LD_INT 0
45915: PUSH
45916: EMPTY
45917: LIST
45918: LIST
45919: PUSH
45920: LD_INT 4
45922: NEG
45923: PUSH
45924: LD_INT 1
45926: NEG
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PUSH
45932: LD_INT 3
45934: NEG
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 3
45945: NEG
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: NEG
45957: PUSH
45958: LD_INT 1
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 5
45967: NEG
45968: PUSH
45969: LD_INT 0
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 5
45978: NEG
45979: PUSH
45980: LD_INT 1
45982: NEG
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 5
45990: NEG
45991: PUSH
45992: LD_INT 2
45994: NEG
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 3
46002: NEG
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 3
46013: NEG
46014: PUSH
46015: LD_INT 3
46017: NEG
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 3
46025: NEG
46026: PUSH
46027: LD_INT 4
46029: NEG
46030: PUSH
46031: EMPTY
46032: LIST
46033: LIST
46034: PUSH
46035: LD_INT 2
46037: NEG
46038: PUSH
46039: LD_INT 3
46041: NEG
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PUSH
46047: LD_INT 2
46049: NEG
46050: PUSH
46051: LD_INT 2
46053: NEG
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 3
46061: NEG
46062: PUSH
46063: LD_INT 2
46065: NEG
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 4
46073: NEG
46074: PUSH
46075: LD_INT 3
46077: NEG
46078: PUSH
46079: EMPTY
46080: LIST
46081: LIST
46082: PUSH
46083: LD_INT 4
46085: NEG
46086: PUSH
46087: LD_INT 4
46089: NEG
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 2
46097: NEG
46098: PUSH
46099: LD_INT 4
46101: NEG
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 4
46109: NEG
46110: PUSH
46111: LD_INT 2
46113: NEG
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: PUSH
46119: LD_INT 0
46121: PUSH
46122: LD_INT 4
46124: NEG
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: LD_INT 0
46132: PUSH
46133: LD_INT 5
46135: NEG
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 1
46143: PUSH
46144: LD_INT 4
46146: NEG
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 1
46154: PUSH
46155: LD_INT 3
46157: NEG
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: PUSH
46163: LD_INT 0
46165: PUSH
46166: LD_INT 3
46168: NEG
46169: PUSH
46170: EMPTY
46171: LIST
46172: LIST
46173: PUSH
46174: LD_INT 1
46176: NEG
46177: PUSH
46178: LD_INT 4
46180: NEG
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 1
46188: NEG
46189: PUSH
46190: LD_INT 5
46192: NEG
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: LD_INT 3
46203: NEG
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 2
46211: NEG
46212: PUSH
46213: LD_INT 5
46215: NEG
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: LIST
46261: LIST
46262: LIST
46263: LIST
46264: LIST
46265: LIST
46266: LIST
46267: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46268: LD_ADDR_VAR 0 31
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: LD_INT 4
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 0
46285: PUSH
46286: LD_INT 3
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 1
46295: PUSH
46296: LD_INT 4
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 1
46305: PUSH
46306: LD_INT 5
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 0
46315: PUSH
46316: LD_INT 5
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 1
46325: NEG
46326: PUSH
46327: LD_INT 4
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 1
46336: NEG
46337: PUSH
46338: LD_INT 3
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 2
46347: PUSH
46348: LD_INT 5
46350: PUSH
46351: EMPTY
46352: LIST
46353: LIST
46354: PUSH
46355: LD_INT 2
46357: NEG
46358: PUSH
46359: LD_INT 3
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: PUSH
46366: LD_INT 3
46368: NEG
46369: PUSH
46370: LD_INT 0
46372: PUSH
46373: EMPTY
46374: LIST
46375: LIST
46376: PUSH
46377: LD_INT 3
46379: NEG
46380: PUSH
46381: LD_INT 1
46383: NEG
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 2
46391: NEG
46392: PUSH
46393: LD_INT 0
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PUSH
46400: LD_INT 2
46402: NEG
46403: PUSH
46404: LD_INT 1
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: LD_INT 3
46413: NEG
46414: PUSH
46415: LD_INT 1
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 4
46424: NEG
46425: PUSH
46426: LD_INT 0
46428: PUSH
46429: EMPTY
46430: LIST
46431: LIST
46432: PUSH
46433: LD_INT 4
46435: NEG
46436: PUSH
46437: LD_INT 1
46439: NEG
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 4
46447: NEG
46448: PUSH
46449: LD_INT 2
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 2
46459: NEG
46460: PUSH
46461: LD_INT 2
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 4
46470: NEG
46471: PUSH
46472: LD_INT 4
46474: NEG
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 4
46482: NEG
46483: PUSH
46484: LD_INT 5
46486: NEG
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 3
46494: NEG
46495: PUSH
46496: LD_INT 4
46498: NEG
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 3
46506: NEG
46507: PUSH
46508: LD_INT 3
46510: NEG
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: PUSH
46516: LD_INT 4
46518: NEG
46519: PUSH
46520: LD_INT 3
46522: NEG
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: PUSH
46528: LD_INT 5
46530: NEG
46531: PUSH
46532: LD_INT 4
46534: NEG
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 5
46542: NEG
46543: PUSH
46544: LD_INT 5
46546: NEG
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 3
46554: NEG
46555: PUSH
46556: LD_INT 5
46558: NEG
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 5
46566: NEG
46567: PUSH
46568: LD_INT 3
46570: NEG
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 0
46578: PUSH
46579: LD_INT 3
46581: NEG
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: PUSH
46587: LD_INT 0
46589: PUSH
46590: LD_INT 4
46592: NEG
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: LD_INT 3
46603: NEG
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 1
46611: PUSH
46612: LD_INT 2
46614: NEG
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 0
46622: PUSH
46623: LD_INT 2
46625: NEG
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 1
46633: NEG
46634: PUSH
46635: LD_INT 3
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: NEG
46646: PUSH
46647: LD_INT 4
46649: NEG
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 2
46657: PUSH
46658: LD_INT 2
46660: NEG
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: PUSH
46666: LD_INT 2
46668: NEG
46669: PUSH
46670: LD_INT 4
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 4
46680: PUSH
46681: LD_INT 0
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 4
46690: PUSH
46691: LD_INT 1
46693: NEG
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 5
46701: PUSH
46702: LD_INT 0
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 5
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 4
46721: PUSH
46722: LD_INT 1
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 3
46731: PUSH
46732: LD_INT 0
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 3
46741: PUSH
46742: LD_INT 1
46744: NEG
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_INT 3
46752: PUSH
46753: LD_INT 2
46755: NEG
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 5
46763: PUSH
46764: LD_INT 2
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46818: LD_ADDR_VAR 0 32
46822: PUSH
46823: LD_INT 4
46825: NEG
46826: PUSH
46827: LD_INT 0
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 4
46836: NEG
46837: PUSH
46838: LD_INT 1
46840: NEG
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: PUSH
46846: LD_INT 3
46848: NEG
46849: PUSH
46850: LD_INT 0
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 3
46859: NEG
46860: PUSH
46861: LD_INT 1
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 4
46870: NEG
46871: PUSH
46872: LD_INT 1
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: LD_INT 5
46881: NEG
46882: PUSH
46883: LD_INT 0
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 5
46892: NEG
46893: PUSH
46894: LD_INT 1
46896: NEG
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PUSH
46902: LD_INT 5
46904: NEG
46905: PUSH
46906: LD_INT 2
46908: NEG
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: LD_INT 3
46916: NEG
46917: PUSH
46918: LD_INT 2
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: PUSH
46925: LD_INT 3
46927: NEG
46928: PUSH
46929: LD_INT 3
46931: NEG
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PUSH
46937: LD_INT 3
46939: NEG
46940: PUSH
46941: LD_INT 4
46943: NEG
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: PUSH
46949: LD_INT 2
46951: NEG
46952: PUSH
46953: LD_INT 3
46955: NEG
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 2
46963: NEG
46964: PUSH
46965: LD_INT 2
46967: NEG
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: PUSH
46973: LD_INT 3
46975: NEG
46976: PUSH
46977: LD_INT 2
46979: NEG
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: PUSH
46985: LD_INT 4
46987: NEG
46988: PUSH
46989: LD_INT 3
46991: NEG
46992: PUSH
46993: EMPTY
46994: LIST
46995: LIST
46996: PUSH
46997: LD_INT 4
46999: NEG
47000: PUSH
47001: LD_INT 4
47003: NEG
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: PUSH
47009: LD_INT 2
47011: NEG
47012: PUSH
47013: LD_INT 4
47015: NEG
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 4
47023: NEG
47024: PUSH
47025: LD_INT 2
47027: NEG
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 0
47035: PUSH
47036: LD_INT 4
47038: NEG
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 0
47046: PUSH
47047: LD_INT 5
47049: NEG
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 1
47057: PUSH
47058: LD_INT 4
47060: NEG
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 1
47068: PUSH
47069: LD_INT 3
47071: NEG
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: PUSH
47077: LD_INT 0
47079: PUSH
47080: LD_INT 3
47082: NEG
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: LD_INT 1
47090: NEG
47091: PUSH
47092: LD_INT 4
47094: NEG
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PUSH
47100: LD_INT 1
47102: NEG
47103: PUSH
47104: LD_INT 5
47106: NEG
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: LD_INT 2
47114: PUSH
47115: LD_INT 3
47117: NEG
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: LD_INT 2
47125: NEG
47126: PUSH
47127: LD_INT 5
47129: NEG
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 3
47137: PUSH
47138: LD_INT 0
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 3
47147: PUSH
47148: LD_INT 1
47150: NEG
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: LD_INT 4
47158: PUSH
47159: LD_INT 0
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PUSH
47166: LD_INT 4
47168: PUSH
47169: LD_INT 1
47171: PUSH
47172: EMPTY
47173: LIST
47174: LIST
47175: PUSH
47176: LD_INT 3
47178: PUSH
47179: LD_INT 1
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 2
47188: PUSH
47189: LD_INT 0
47191: PUSH
47192: EMPTY
47193: LIST
47194: LIST
47195: PUSH
47196: LD_INT 2
47198: PUSH
47199: LD_INT 1
47201: NEG
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 2
47209: PUSH
47210: LD_INT 2
47212: NEG
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 4
47220: PUSH
47221: LD_INT 2
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 4
47230: PUSH
47231: LD_INT 4
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 4
47240: PUSH
47241: LD_INT 3
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PUSH
47248: LD_INT 5
47250: PUSH
47251: LD_INT 4
47253: PUSH
47254: EMPTY
47255: LIST
47256: LIST
47257: PUSH
47258: LD_INT 5
47260: PUSH
47261: LD_INT 5
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 4
47270: PUSH
47271: LD_INT 5
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: LD_INT 3
47280: PUSH
47281: LD_INT 4
47283: PUSH
47284: EMPTY
47285: LIST
47286: LIST
47287: PUSH
47288: LD_INT 3
47290: PUSH
47291: LD_INT 3
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 5
47300: PUSH
47301: LD_INT 3
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: LD_INT 3
47310: PUSH
47311: LD_INT 5
47313: PUSH
47314: EMPTY
47315: LIST
47316: LIST
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: LIST
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: LIST
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: LIST
47358: LIST
47359: LIST
47360: LIST
47361: LIST
47362: LIST
47363: LIST
47364: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47365: LD_ADDR_VAR 0 33
47369: PUSH
47370: LD_INT 4
47372: NEG
47373: PUSH
47374: LD_INT 4
47376: NEG
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PUSH
47382: LD_INT 4
47384: NEG
47385: PUSH
47386: LD_INT 5
47388: NEG
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PUSH
47394: LD_INT 3
47396: NEG
47397: PUSH
47398: LD_INT 4
47400: NEG
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 3
47408: NEG
47409: PUSH
47410: LD_INT 3
47412: NEG
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: PUSH
47418: LD_INT 4
47420: NEG
47421: PUSH
47422: LD_INT 3
47424: NEG
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: LD_INT 5
47432: NEG
47433: PUSH
47434: LD_INT 4
47436: NEG
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: PUSH
47442: LD_INT 5
47444: NEG
47445: PUSH
47446: LD_INT 5
47448: NEG
47449: PUSH
47450: EMPTY
47451: LIST
47452: LIST
47453: PUSH
47454: LD_INT 3
47456: NEG
47457: PUSH
47458: LD_INT 5
47460: NEG
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PUSH
47466: LD_INT 5
47468: NEG
47469: PUSH
47470: LD_INT 3
47472: NEG
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 0
47480: PUSH
47481: LD_INT 3
47483: NEG
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: LD_INT 0
47491: PUSH
47492: LD_INT 4
47494: NEG
47495: PUSH
47496: EMPTY
47497: LIST
47498: LIST
47499: PUSH
47500: LD_INT 1
47502: PUSH
47503: LD_INT 3
47505: NEG
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: PUSH
47511: LD_INT 1
47513: PUSH
47514: LD_INT 2
47516: NEG
47517: PUSH
47518: EMPTY
47519: LIST
47520: LIST
47521: PUSH
47522: LD_INT 0
47524: PUSH
47525: LD_INT 2
47527: NEG
47528: PUSH
47529: EMPTY
47530: LIST
47531: LIST
47532: PUSH
47533: LD_INT 1
47535: NEG
47536: PUSH
47537: LD_INT 3
47539: NEG
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 1
47547: NEG
47548: PUSH
47549: LD_INT 4
47551: NEG
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: PUSH
47557: LD_INT 2
47559: PUSH
47560: LD_INT 2
47562: NEG
47563: PUSH
47564: EMPTY
47565: LIST
47566: LIST
47567: PUSH
47568: LD_INT 2
47570: NEG
47571: PUSH
47572: LD_INT 4
47574: NEG
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 4
47582: PUSH
47583: LD_INT 0
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: LD_INT 4
47592: PUSH
47593: LD_INT 1
47595: NEG
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: PUSH
47601: LD_INT 5
47603: PUSH
47604: LD_INT 0
47606: PUSH
47607: EMPTY
47608: LIST
47609: LIST
47610: PUSH
47611: LD_INT 5
47613: PUSH
47614: LD_INT 1
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 4
47623: PUSH
47624: LD_INT 1
47626: PUSH
47627: EMPTY
47628: LIST
47629: LIST
47630: PUSH
47631: LD_INT 3
47633: PUSH
47634: LD_INT 0
47636: PUSH
47637: EMPTY
47638: LIST
47639: LIST
47640: PUSH
47641: LD_INT 3
47643: PUSH
47644: LD_INT 1
47646: NEG
47647: PUSH
47648: EMPTY
47649: LIST
47650: LIST
47651: PUSH
47652: LD_INT 3
47654: PUSH
47655: LD_INT 2
47657: NEG
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 5
47665: PUSH
47666: LD_INT 2
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: LD_INT 3
47675: PUSH
47676: LD_INT 3
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 3
47685: PUSH
47686: LD_INT 2
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: LD_INT 4
47695: PUSH
47696: LD_INT 3
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: PUSH
47703: LD_INT 4
47705: PUSH
47706: LD_INT 4
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 3
47715: PUSH
47716: LD_INT 4
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_INT 2
47725: PUSH
47726: LD_INT 3
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PUSH
47733: LD_INT 2
47735: PUSH
47736: LD_INT 2
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 4
47745: PUSH
47746: LD_INT 2
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 4
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: LD_INT 0
47765: PUSH
47766: LD_INT 4
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 0
47775: PUSH
47776: LD_INT 3
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 1
47785: PUSH
47786: LD_INT 4
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 1
47795: PUSH
47796: LD_INT 5
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: PUSH
47803: LD_INT 0
47805: PUSH
47806: LD_INT 5
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 1
47815: NEG
47816: PUSH
47817: LD_INT 4
47819: PUSH
47820: EMPTY
47821: LIST
47822: LIST
47823: PUSH
47824: LD_INT 1
47826: NEG
47827: PUSH
47828: LD_INT 3
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: LD_INT 2
47837: PUSH
47838: LD_INT 5
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PUSH
47845: LD_INT 2
47847: NEG
47848: PUSH
47849: LD_INT 3
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: LIST
47866: LIST
47867: LIST
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47903: LD_ADDR_VAR 0 34
47907: PUSH
47908: LD_INT 0
47910: PUSH
47911: LD_INT 4
47913: NEG
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PUSH
47919: LD_INT 0
47921: PUSH
47922: LD_INT 5
47924: NEG
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: PUSH
47930: LD_INT 1
47932: PUSH
47933: LD_INT 4
47935: NEG
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PUSH
47941: LD_INT 1
47943: PUSH
47944: LD_INT 3
47946: NEG
47947: PUSH
47948: EMPTY
47949: LIST
47950: LIST
47951: PUSH
47952: LD_INT 0
47954: PUSH
47955: LD_INT 3
47957: NEG
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: LD_INT 1
47965: NEG
47966: PUSH
47967: LD_INT 4
47969: NEG
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PUSH
47975: LD_INT 1
47977: NEG
47978: PUSH
47979: LD_INT 5
47981: NEG
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 2
47989: PUSH
47990: LD_INT 3
47992: NEG
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: LD_INT 2
48000: NEG
48001: PUSH
48002: LD_INT 5
48004: NEG
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_INT 3
48012: PUSH
48013: LD_INT 0
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: LD_INT 3
48022: PUSH
48023: LD_INT 1
48025: NEG
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 4
48033: PUSH
48034: LD_INT 0
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: LD_INT 4
48043: PUSH
48044: LD_INT 1
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 3
48053: PUSH
48054: LD_INT 1
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 2
48063: PUSH
48064: LD_INT 0
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: PUSH
48071: LD_INT 2
48073: PUSH
48074: LD_INT 1
48076: NEG
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_INT 2
48084: PUSH
48085: LD_INT 2
48087: NEG
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_INT 4
48095: PUSH
48096: LD_INT 2
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: LD_INT 4
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 4
48115: PUSH
48116: LD_INT 3
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 5
48125: PUSH
48126: LD_INT 4
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 5
48135: PUSH
48136: LD_INT 5
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 4
48145: PUSH
48146: LD_INT 5
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: LD_INT 4
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: LD_INT 3
48165: PUSH
48166: LD_INT 3
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 5
48175: PUSH
48176: LD_INT 3
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 3
48185: PUSH
48186: LD_INT 5
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 0
48195: PUSH
48196: LD_INT 3
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 0
48205: PUSH
48206: LD_INT 2
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 1
48215: PUSH
48216: LD_INT 3
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 1
48225: PUSH
48226: LD_INT 4
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: LD_INT 0
48235: PUSH
48236: LD_INT 4
48238: PUSH
48239: EMPTY
48240: LIST
48241: LIST
48242: PUSH
48243: LD_INT 1
48245: NEG
48246: PUSH
48247: LD_INT 3
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 1
48256: NEG
48257: PUSH
48258: LD_INT 2
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 2
48267: PUSH
48268: LD_INT 4
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: PUSH
48275: LD_INT 2
48277: NEG
48278: PUSH
48279: LD_INT 2
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: PUSH
48286: LD_INT 4
48288: NEG
48289: PUSH
48290: LD_INT 0
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 4
48299: NEG
48300: PUSH
48301: LD_INT 1
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 3
48311: NEG
48312: PUSH
48313: LD_INT 0
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PUSH
48320: LD_INT 3
48322: NEG
48323: PUSH
48324: LD_INT 1
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 4
48333: NEG
48334: PUSH
48335: LD_INT 1
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: PUSH
48342: LD_INT 5
48344: NEG
48345: PUSH
48346: LD_INT 0
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PUSH
48353: LD_INT 5
48355: NEG
48356: PUSH
48357: LD_INT 1
48359: NEG
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: PUSH
48365: LD_INT 5
48367: NEG
48368: PUSH
48369: LD_INT 2
48371: NEG
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 3
48379: NEG
48380: PUSH
48381: LD_INT 2
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: ST_TO_ADDR
// end ; end ;
48435: GO 48438
48437: POP
// case btype of b_depot , b_warehouse :
48438: LD_VAR 0 1
48442: PUSH
48443: LD_INT 0
48445: DOUBLE
48446: EQUAL
48447: IFTRUE 48457
48449: LD_INT 1
48451: DOUBLE
48452: EQUAL
48453: IFTRUE 48457
48455: GO 48658
48457: POP
// case nation of nation_american :
48458: LD_VAR 0 5
48462: PUSH
48463: LD_INT 1
48465: DOUBLE
48466: EQUAL
48467: IFTRUE 48471
48469: GO 48527
48471: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48472: LD_ADDR_VAR 0 9
48476: PUSH
48477: LD_VAR 0 11
48481: PUSH
48482: LD_VAR 0 12
48486: PUSH
48487: LD_VAR 0 13
48491: PUSH
48492: LD_VAR 0 14
48496: PUSH
48497: LD_VAR 0 15
48501: PUSH
48502: LD_VAR 0 16
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: PUSH
48515: LD_VAR 0 4
48519: PUSH
48520: LD_INT 1
48522: PLUS
48523: ARRAY
48524: ST_TO_ADDR
48525: GO 48656
48527: LD_INT 2
48529: DOUBLE
48530: EQUAL
48531: IFTRUE 48535
48533: GO 48591
48535: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48536: LD_ADDR_VAR 0 9
48540: PUSH
48541: LD_VAR 0 17
48545: PUSH
48546: LD_VAR 0 18
48550: PUSH
48551: LD_VAR 0 19
48555: PUSH
48556: LD_VAR 0 20
48560: PUSH
48561: LD_VAR 0 21
48565: PUSH
48566: LD_VAR 0 22
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: LIST
48575: LIST
48576: LIST
48577: LIST
48578: PUSH
48579: LD_VAR 0 4
48583: PUSH
48584: LD_INT 1
48586: PLUS
48587: ARRAY
48588: ST_TO_ADDR
48589: GO 48656
48591: LD_INT 3
48593: DOUBLE
48594: EQUAL
48595: IFTRUE 48599
48597: GO 48655
48599: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48600: LD_ADDR_VAR 0 9
48604: PUSH
48605: LD_VAR 0 23
48609: PUSH
48610: LD_VAR 0 24
48614: PUSH
48615: LD_VAR 0 25
48619: PUSH
48620: LD_VAR 0 26
48624: PUSH
48625: LD_VAR 0 27
48629: PUSH
48630: LD_VAR 0 28
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: LIST
48642: PUSH
48643: LD_VAR 0 4
48647: PUSH
48648: LD_INT 1
48650: PLUS
48651: ARRAY
48652: ST_TO_ADDR
48653: GO 48656
48655: POP
48656: GO 49211
48658: LD_INT 2
48660: DOUBLE
48661: EQUAL
48662: IFTRUE 48672
48664: LD_INT 3
48666: DOUBLE
48667: EQUAL
48668: IFTRUE 48672
48670: GO 48728
48672: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48673: LD_ADDR_VAR 0 9
48677: PUSH
48678: LD_VAR 0 29
48682: PUSH
48683: LD_VAR 0 30
48687: PUSH
48688: LD_VAR 0 31
48692: PUSH
48693: LD_VAR 0 32
48697: PUSH
48698: LD_VAR 0 33
48702: PUSH
48703: LD_VAR 0 34
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: PUSH
48716: LD_VAR 0 4
48720: PUSH
48721: LD_INT 1
48723: PLUS
48724: ARRAY
48725: ST_TO_ADDR
48726: GO 49211
48728: LD_INT 16
48730: DOUBLE
48731: EQUAL
48732: IFTRUE 48790
48734: LD_INT 17
48736: DOUBLE
48737: EQUAL
48738: IFTRUE 48790
48740: LD_INT 18
48742: DOUBLE
48743: EQUAL
48744: IFTRUE 48790
48746: LD_INT 19
48748: DOUBLE
48749: EQUAL
48750: IFTRUE 48790
48752: LD_INT 22
48754: DOUBLE
48755: EQUAL
48756: IFTRUE 48790
48758: LD_INT 20
48760: DOUBLE
48761: EQUAL
48762: IFTRUE 48790
48764: LD_INT 21
48766: DOUBLE
48767: EQUAL
48768: IFTRUE 48790
48770: LD_INT 23
48772: DOUBLE
48773: EQUAL
48774: IFTRUE 48790
48776: LD_INT 24
48778: DOUBLE
48779: EQUAL
48780: IFTRUE 48790
48782: LD_INT 25
48784: DOUBLE
48785: EQUAL
48786: IFTRUE 48790
48788: GO 48846
48790: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48791: LD_ADDR_VAR 0 9
48795: PUSH
48796: LD_VAR 0 35
48800: PUSH
48801: LD_VAR 0 36
48805: PUSH
48806: LD_VAR 0 37
48810: PUSH
48811: LD_VAR 0 38
48815: PUSH
48816: LD_VAR 0 39
48820: PUSH
48821: LD_VAR 0 40
48825: PUSH
48826: EMPTY
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: PUSH
48834: LD_VAR 0 4
48838: PUSH
48839: LD_INT 1
48841: PLUS
48842: ARRAY
48843: ST_TO_ADDR
48844: GO 49211
48846: LD_INT 6
48848: DOUBLE
48849: EQUAL
48850: IFTRUE 48902
48852: LD_INT 7
48854: DOUBLE
48855: EQUAL
48856: IFTRUE 48902
48858: LD_INT 8
48860: DOUBLE
48861: EQUAL
48862: IFTRUE 48902
48864: LD_INT 13
48866: DOUBLE
48867: EQUAL
48868: IFTRUE 48902
48870: LD_INT 12
48872: DOUBLE
48873: EQUAL
48874: IFTRUE 48902
48876: LD_INT 15
48878: DOUBLE
48879: EQUAL
48880: IFTRUE 48902
48882: LD_INT 11
48884: DOUBLE
48885: EQUAL
48886: IFTRUE 48902
48888: LD_INT 14
48890: DOUBLE
48891: EQUAL
48892: IFTRUE 48902
48894: LD_INT 10
48896: DOUBLE
48897: EQUAL
48898: IFTRUE 48902
48900: GO 48958
48902: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48903: LD_ADDR_VAR 0 9
48907: PUSH
48908: LD_VAR 0 41
48912: PUSH
48913: LD_VAR 0 42
48917: PUSH
48918: LD_VAR 0 43
48922: PUSH
48923: LD_VAR 0 44
48927: PUSH
48928: LD_VAR 0 45
48932: PUSH
48933: LD_VAR 0 46
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: PUSH
48946: LD_VAR 0 4
48950: PUSH
48951: LD_INT 1
48953: PLUS
48954: ARRAY
48955: ST_TO_ADDR
48956: GO 49211
48958: LD_INT 36
48960: DOUBLE
48961: EQUAL
48962: IFTRUE 48966
48964: GO 49022
48966: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48967: LD_ADDR_VAR 0 9
48971: PUSH
48972: LD_VAR 0 47
48976: PUSH
48977: LD_VAR 0 48
48981: PUSH
48982: LD_VAR 0 49
48986: PUSH
48987: LD_VAR 0 50
48991: PUSH
48992: LD_VAR 0 51
48996: PUSH
48997: LD_VAR 0 52
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: LIST
49006: LIST
49007: LIST
49008: LIST
49009: PUSH
49010: LD_VAR 0 4
49014: PUSH
49015: LD_INT 1
49017: PLUS
49018: ARRAY
49019: ST_TO_ADDR
49020: GO 49211
49022: LD_INT 4
49024: DOUBLE
49025: EQUAL
49026: IFTRUE 49048
49028: LD_INT 5
49030: DOUBLE
49031: EQUAL
49032: IFTRUE 49048
49034: LD_INT 34
49036: DOUBLE
49037: EQUAL
49038: IFTRUE 49048
49040: LD_INT 37
49042: DOUBLE
49043: EQUAL
49044: IFTRUE 49048
49046: GO 49104
49048: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49049: LD_ADDR_VAR 0 9
49053: PUSH
49054: LD_VAR 0 53
49058: PUSH
49059: LD_VAR 0 54
49063: PUSH
49064: LD_VAR 0 55
49068: PUSH
49069: LD_VAR 0 56
49073: PUSH
49074: LD_VAR 0 57
49078: PUSH
49079: LD_VAR 0 58
49083: PUSH
49084: EMPTY
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: PUSH
49092: LD_VAR 0 4
49096: PUSH
49097: LD_INT 1
49099: PLUS
49100: ARRAY
49101: ST_TO_ADDR
49102: GO 49211
49104: LD_INT 31
49106: DOUBLE
49107: EQUAL
49108: IFTRUE 49154
49110: LD_INT 32
49112: DOUBLE
49113: EQUAL
49114: IFTRUE 49154
49116: LD_INT 33
49118: DOUBLE
49119: EQUAL
49120: IFTRUE 49154
49122: LD_INT 27
49124: DOUBLE
49125: EQUAL
49126: IFTRUE 49154
49128: LD_INT 26
49130: DOUBLE
49131: EQUAL
49132: IFTRUE 49154
49134: LD_INT 28
49136: DOUBLE
49137: EQUAL
49138: IFTRUE 49154
49140: LD_INT 29
49142: DOUBLE
49143: EQUAL
49144: IFTRUE 49154
49146: LD_INT 30
49148: DOUBLE
49149: EQUAL
49150: IFTRUE 49154
49152: GO 49210
49154: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49155: LD_ADDR_VAR 0 9
49159: PUSH
49160: LD_VAR 0 59
49164: PUSH
49165: LD_VAR 0 60
49169: PUSH
49170: LD_VAR 0 61
49174: PUSH
49175: LD_VAR 0 62
49179: PUSH
49180: LD_VAR 0 63
49184: PUSH
49185: LD_VAR 0 64
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: LIST
49194: LIST
49195: LIST
49196: LIST
49197: PUSH
49198: LD_VAR 0 4
49202: PUSH
49203: LD_INT 1
49205: PLUS
49206: ARRAY
49207: ST_TO_ADDR
49208: GO 49211
49210: POP
// temp_list2 = [ ] ;
49211: LD_ADDR_VAR 0 10
49215: PUSH
49216: EMPTY
49217: ST_TO_ADDR
// for i in temp_list do
49218: LD_ADDR_VAR 0 8
49222: PUSH
49223: LD_VAR 0 9
49227: PUSH
49228: FOR_IN
49229: IFFALSE 49281
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49231: LD_ADDR_VAR 0 10
49235: PUSH
49236: LD_VAR 0 10
49240: PUSH
49241: LD_VAR 0 8
49245: PUSH
49246: LD_INT 1
49248: ARRAY
49249: PUSH
49250: LD_VAR 0 2
49254: PLUS
49255: PUSH
49256: LD_VAR 0 8
49260: PUSH
49261: LD_INT 2
49263: ARRAY
49264: PUSH
49265: LD_VAR 0 3
49269: PLUS
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PUSH
49275: EMPTY
49276: LIST
49277: ADD
49278: ST_TO_ADDR
49279: GO 49228
49281: POP
49282: POP
// result = temp_list2 ;
49283: LD_ADDR_VAR 0 7
49287: PUSH
49288: LD_VAR 0 10
49292: ST_TO_ADDR
// end ;
49293: LD_VAR 0 7
49297: RET
// export function EnemyInRange ( unit , dist ) ; begin
49298: LD_INT 0
49300: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49301: LD_ADDR_VAR 0 3
49305: PUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL_OW 255
49315: PPUSH
49316: LD_VAR 0 1
49320: PPUSH
49321: CALL_OW 250
49325: PPUSH
49326: LD_VAR 0 1
49330: PPUSH
49331: CALL_OW 251
49335: PPUSH
49336: LD_VAR 0 2
49340: PPUSH
49341: CALL 22671 0 4
49345: PUSH
49346: LD_INT 4
49348: ARRAY
49349: ST_TO_ADDR
// end ;
49350: LD_VAR 0 3
49354: RET
// export function PlayerSeeMe ( unit ) ; begin
49355: LD_INT 0
49357: PPUSH
// result := See ( your_side , unit ) ;
49358: LD_ADDR_VAR 0 2
49362: PUSH
49363: LD_OWVAR 2
49367: PPUSH
49368: LD_VAR 0 1
49372: PPUSH
49373: CALL_OW 292
49377: ST_TO_ADDR
// end ;
49378: LD_VAR 0 2
49382: RET
// export function ReverseDir ( unit ) ; begin
49383: LD_INT 0
49385: PPUSH
// if not unit then
49386: LD_VAR 0 1
49390: NOT
49391: IFFALSE 49395
// exit ;
49393: GO 49418
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49395: LD_ADDR_VAR 0 2
49399: PUSH
49400: LD_VAR 0 1
49404: PPUSH
49405: CALL_OW 254
49409: PUSH
49410: LD_INT 3
49412: PLUS
49413: PUSH
49414: LD_INT 6
49416: MOD
49417: ST_TO_ADDR
// end ;
49418: LD_VAR 0 2
49422: RET
// export function ReverseArray ( array ) ; var i ; begin
49423: LD_INT 0
49425: PPUSH
49426: PPUSH
// if not array then
49427: LD_VAR 0 1
49431: NOT
49432: IFFALSE 49436
// exit ;
49434: GO 49491
// result := [ ] ;
49436: LD_ADDR_VAR 0 2
49440: PUSH
49441: EMPTY
49442: ST_TO_ADDR
// for i := array downto 1 do
49443: LD_ADDR_VAR 0 3
49447: PUSH
49448: DOUBLE
49449: LD_VAR 0 1
49453: INC
49454: ST_TO_ADDR
49455: LD_INT 1
49457: PUSH
49458: FOR_DOWNTO
49459: IFFALSE 49489
// result := Join ( result , array [ i ] ) ;
49461: LD_ADDR_VAR 0 2
49465: PUSH
49466: LD_VAR 0 2
49470: PPUSH
49471: LD_VAR 0 1
49475: PUSH
49476: LD_VAR 0 3
49480: ARRAY
49481: PPUSH
49482: CALL 54136 0 2
49486: ST_TO_ADDR
49487: GO 49458
49489: POP
49490: POP
// end ;
49491: LD_VAR 0 2
49495: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49496: LD_INT 0
49498: PPUSH
49499: PPUSH
49500: PPUSH
49501: PPUSH
49502: PPUSH
49503: PPUSH
// if not unit or not hexes then
49504: LD_VAR 0 1
49508: NOT
49509: PUSH
49510: LD_VAR 0 2
49514: NOT
49515: OR
49516: IFFALSE 49520
// exit ;
49518: GO 49643
// dist := 9999 ;
49520: LD_ADDR_VAR 0 5
49524: PUSH
49525: LD_INT 9999
49527: ST_TO_ADDR
// for i = 1 to hexes do
49528: LD_ADDR_VAR 0 4
49532: PUSH
49533: DOUBLE
49534: LD_INT 1
49536: DEC
49537: ST_TO_ADDR
49538: LD_VAR 0 2
49542: PUSH
49543: FOR_TO
49544: IFFALSE 49631
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49546: LD_ADDR_VAR 0 6
49550: PUSH
49551: LD_VAR 0 1
49555: PPUSH
49556: LD_VAR 0 2
49560: PUSH
49561: LD_VAR 0 4
49565: ARRAY
49566: PUSH
49567: LD_INT 1
49569: ARRAY
49570: PPUSH
49571: LD_VAR 0 2
49575: PUSH
49576: LD_VAR 0 4
49580: ARRAY
49581: PUSH
49582: LD_INT 2
49584: ARRAY
49585: PPUSH
49586: CALL_OW 297
49590: ST_TO_ADDR
// if tdist < dist then
49591: LD_VAR 0 6
49595: PUSH
49596: LD_VAR 0 5
49600: LESS
49601: IFFALSE 49629
// begin hex := hexes [ i ] ;
49603: LD_ADDR_VAR 0 8
49607: PUSH
49608: LD_VAR 0 2
49612: PUSH
49613: LD_VAR 0 4
49617: ARRAY
49618: ST_TO_ADDR
// dist := tdist ;
49619: LD_ADDR_VAR 0 5
49623: PUSH
49624: LD_VAR 0 6
49628: ST_TO_ADDR
// end ; end ;
49629: GO 49543
49631: POP
49632: POP
// result := hex ;
49633: LD_ADDR_VAR 0 3
49637: PUSH
49638: LD_VAR 0 8
49642: ST_TO_ADDR
// end ;
49643: LD_VAR 0 3
49647: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49648: LD_INT 0
49650: PPUSH
49651: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49652: LD_VAR 0 1
49656: NOT
49657: PUSH
49658: LD_VAR 0 1
49662: PUSH
49663: LD_INT 21
49665: PUSH
49666: LD_INT 2
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: LD_INT 23
49675: PUSH
49676: LD_INT 2
49678: PUSH
49679: EMPTY
49680: LIST
49681: LIST
49682: PUSH
49683: EMPTY
49684: LIST
49685: LIST
49686: PPUSH
49687: CALL_OW 69
49691: IN
49692: NOT
49693: OR
49694: IFFALSE 49698
// exit ;
49696: GO 49745
// for i = 1 to 3 do
49698: LD_ADDR_VAR 0 3
49702: PUSH
49703: DOUBLE
49704: LD_INT 1
49706: DEC
49707: ST_TO_ADDR
49708: LD_INT 3
49710: PUSH
49711: FOR_TO
49712: IFFALSE 49743
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 250
49723: PPUSH
49724: LD_VAR 0 1
49728: PPUSH
49729: CALL_OW 251
49733: PPUSH
49734: LD_INT 1
49736: PPUSH
49737: CALL_OW 453
49741: GO 49711
49743: POP
49744: POP
// end ;
49745: LD_VAR 0 2
49749: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49750: LD_INT 0
49752: PPUSH
49753: PPUSH
49754: PPUSH
49755: PPUSH
49756: PPUSH
49757: PPUSH
// if not unit or not enemy_unit then
49758: LD_VAR 0 1
49762: NOT
49763: PUSH
49764: LD_VAR 0 2
49768: NOT
49769: OR
49770: IFFALSE 49774
// exit ;
49772: GO 50241
// if GetLives ( i ) < 250 then
49774: LD_VAR 0 4
49778: PPUSH
49779: CALL_OW 256
49783: PUSH
49784: LD_INT 250
49786: LESS
49787: IFFALSE 49800
// begin ComAutodestruct ( i ) ;
49789: LD_VAR 0 4
49793: PPUSH
49794: CALL 49648 0 1
// exit ;
49798: GO 50241
// end ; x := GetX ( enemy_unit ) ;
49800: LD_ADDR_VAR 0 7
49804: PUSH
49805: LD_VAR 0 2
49809: PPUSH
49810: CALL_OW 250
49814: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49815: LD_ADDR_VAR 0 8
49819: PUSH
49820: LD_VAR 0 2
49824: PPUSH
49825: CALL_OW 251
49829: ST_TO_ADDR
// if not x or not y then
49830: LD_VAR 0 7
49834: NOT
49835: PUSH
49836: LD_VAR 0 8
49840: NOT
49841: OR
49842: IFFALSE 49846
// exit ;
49844: GO 50241
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49846: LD_ADDR_VAR 0 6
49850: PUSH
49851: LD_VAR 0 7
49855: PPUSH
49856: LD_INT 0
49858: PPUSH
49859: LD_INT 4
49861: PPUSH
49862: CALL_OW 272
49866: PUSH
49867: LD_VAR 0 8
49871: PPUSH
49872: LD_INT 0
49874: PPUSH
49875: LD_INT 4
49877: PPUSH
49878: CALL_OW 273
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: PUSH
49887: LD_VAR 0 7
49891: PPUSH
49892: LD_INT 1
49894: PPUSH
49895: LD_INT 4
49897: PPUSH
49898: CALL_OW 272
49902: PUSH
49903: LD_VAR 0 8
49907: PPUSH
49908: LD_INT 1
49910: PPUSH
49911: LD_INT 4
49913: PPUSH
49914: CALL_OW 273
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: PUSH
49923: LD_VAR 0 7
49927: PPUSH
49928: LD_INT 2
49930: PPUSH
49931: LD_INT 4
49933: PPUSH
49934: CALL_OW 272
49938: PUSH
49939: LD_VAR 0 8
49943: PPUSH
49944: LD_INT 2
49946: PPUSH
49947: LD_INT 4
49949: PPUSH
49950: CALL_OW 273
49954: PUSH
49955: EMPTY
49956: LIST
49957: LIST
49958: PUSH
49959: LD_VAR 0 7
49963: PPUSH
49964: LD_INT 3
49966: PPUSH
49967: LD_INT 4
49969: PPUSH
49970: CALL_OW 272
49974: PUSH
49975: LD_VAR 0 8
49979: PPUSH
49980: LD_INT 3
49982: PPUSH
49983: LD_INT 4
49985: PPUSH
49986: CALL_OW 273
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PUSH
49995: LD_VAR 0 7
49999: PPUSH
50000: LD_INT 4
50002: PPUSH
50003: LD_INT 4
50005: PPUSH
50006: CALL_OW 272
50010: PUSH
50011: LD_VAR 0 8
50015: PPUSH
50016: LD_INT 4
50018: PPUSH
50019: LD_INT 4
50021: PPUSH
50022: CALL_OW 273
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_VAR 0 7
50035: PPUSH
50036: LD_INT 5
50038: PPUSH
50039: LD_INT 4
50041: PPUSH
50042: CALL_OW 272
50046: PUSH
50047: LD_VAR 0 8
50051: PPUSH
50052: LD_INT 5
50054: PPUSH
50055: LD_INT 4
50057: PPUSH
50058: CALL_OW 273
50062: PUSH
50063: EMPTY
50064: LIST
50065: LIST
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: LIST
50071: LIST
50072: LIST
50073: LIST
50074: ST_TO_ADDR
// for i = tmp downto 1 do
50075: LD_ADDR_VAR 0 4
50079: PUSH
50080: DOUBLE
50081: LD_VAR 0 6
50085: INC
50086: ST_TO_ADDR
50087: LD_INT 1
50089: PUSH
50090: FOR_DOWNTO
50091: IFFALSE 50192
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50093: LD_VAR 0 6
50097: PUSH
50098: LD_VAR 0 4
50102: ARRAY
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PPUSH
50108: LD_VAR 0 6
50112: PUSH
50113: LD_VAR 0 4
50117: ARRAY
50118: PUSH
50119: LD_INT 2
50121: ARRAY
50122: PPUSH
50123: CALL_OW 488
50127: NOT
50128: PUSH
50129: LD_VAR 0 6
50133: PUSH
50134: LD_VAR 0 4
50138: ARRAY
50139: PUSH
50140: LD_INT 1
50142: ARRAY
50143: PPUSH
50144: LD_VAR 0 6
50148: PUSH
50149: LD_VAR 0 4
50153: ARRAY
50154: PUSH
50155: LD_INT 2
50157: ARRAY
50158: PPUSH
50159: CALL_OW 428
50163: PUSH
50164: LD_INT 0
50166: NONEQUAL
50167: OR
50168: IFFALSE 50190
// tmp := Delete ( tmp , i ) ;
50170: LD_ADDR_VAR 0 6
50174: PUSH
50175: LD_VAR 0 6
50179: PPUSH
50180: LD_VAR 0 4
50184: PPUSH
50185: CALL_OW 3
50189: ST_TO_ADDR
50190: GO 50090
50192: POP
50193: POP
// j := GetClosestHex ( unit , tmp ) ;
50194: LD_ADDR_VAR 0 5
50198: PUSH
50199: LD_VAR 0 1
50203: PPUSH
50204: LD_VAR 0 6
50208: PPUSH
50209: CALL 49496 0 2
50213: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50214: LD_VAR 0 1
50218: PPUSH
50219: LD_VAR 0 5
50223: PUSH
50224: LD_INT 1
50226: ARRAY
50227: PPUSH
50228: LD_VAR 0 5
50232: PUSH
50233: LD_INT 2
50235: ARRAY
50236: PPUSH
50237: CALL_OW 111
// end ;
50241: LD_VAR 0 3
50245: RET
// export function PrepareApemanSoldier ( ) ; begin
50246: LD_INT 0
50248: PPUSH
// uc_nation := 0 ;
50249: LD_ADDR_OWVAR 21
50253: PUSH
50254: LD_INT 0
50256: ST_TO_ADDR
// hc_sex := sex_male ;
50257: LD_ADDR_OWVAR 27
50261: PUSH
50262: LD_INT 1
50264: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
50265: LD_ADDR_OWVAR 28
50269: PUSH
50270: LD_INT 15
50272: ST_TO_ADDR
// hc_gallery :=  ;
50273: LD_ADDR_OWVAR 33
50277: PUSH
50278: LD_STRING 
50280: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50281: LD_ADDR_OWVAR 31
50285: PUSH
50286: LD_INT 0
50288: PPUSH
50289: LD_INT 3
50291: PPUSH
50292: CALL_OW 12
50296: PUSH
50297: LD_INT 0
50299: PPUSH
50300: LD_INT 3
50302: PPUSH
50303: CALL_OW 12
50307: PUSH
50308: LD_INT 0
50310: PUSH
50311: LD_INT 0
50313: PUSH
50314: EMPTY
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: ST_TO_ADDR
// end ;
50320: LD_VAR 0 1
50324: RET
// export function PrepareApemanEngineer ( ) ; begin
50325: LD_INT 0
50327: PPUSH
// uc_nation := 0 ;
50328: LD_ADDR_OWVAR 21
50332: PUSH
50333: LD_INT 0
50335: ST_TO_ADDR
// hc_sex := sex_male ;
50336: LD_ADDR_OWVAR 27
50340: PUSH
50341: LD_INT 1
50343: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
50344: LD_ADDR_OWVAR 28
50348: PUSH
50349: LD_INT 16
50351: ST_TO_ADDR
// hc_gallery :=  ;
50352: LD_ADDR_OWVAR 33
50356: PUSH
50357: LD_STRING 
50359: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50360: LD_ADDR_OWVAR 31
50364: PUSH
50365: LD_INT 0
50367: PPUSH
50368: LD_INT 3
50370: PPUSH
50371: CALL_OW 12
50375: PUSH
50376: LD_INT 0
50378: PPUSH
50379: LD_INT 3
50381: PPUSH
50382: CALL_OW 12
50386: PUSH
50387: LD_INT 0
50389: PUSH
50390: LD_INT 0
50392: PUSH
50393: EMPTY
50394: LIST
50395: LIST
50396: LIST
50397: LIST
50398: ST_TO_ADDR
// end ;
50399: LD_VAR 0 1
50403: RET
// export function PrepareApeman ( agressivity ) ; begin
50404: LD_INT 0
50406: PPUSH
// uc_side := 0 ;
50407: LD_ADDR_OWVAR 20
50411: PUSH
50412: LD_INT 0
50414: ST_TO_ADDR
// uc_nation := 0 ;
50415: LD_ADDR_OWVAR 21
50419: PUSH
50420: LD_INT 0
50422: ST_TO_ADDR
// hc_sex := sex_male ;
50423: LD_ADDR_OWVAR 27
50427: PUSH
50428: LD_INT 1
50430: ST_TO_ADDR
// hc_class := class_apeman ;
50431: LD_ADDR_OWVAR 28
50435: PUSH
50436: LD_INT 12
50438: ST_TO_ADDR
// hc_gallery :=  ;
50439: LD_ADDR_OWVAR 33
50443: PUSH
50444: LD_STRING 
50446: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50447: LD_ADDR_OWVAR 35
50451: PUSH
50452: LD_VAR 0 1
50456: NEG
50457: PPUSH
50458: LD_VAR 0 1
50462: PPUSH
50463: CALL_OW 12
50467: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50468: LD_ADDR_OWVAR 31
50472: PUSH
50473: LD_INT 0
50475: PPUSH
50476: LD_INT 3
50478: PPUSH
50479: CALL_OW 12
50483: PUSH
50484: LD_INT 0
50486: PPUSH
50487: LD_INT 3
50489: PPUSH
50490: CALL_OW 12
50494: PUSH
50495: LD_INT 0
50497: PUSH
50498: LD_INT 0
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: ST_TO_ADDR
// end ;
50507: LD_VAR 0 2
50511: RET
// export function PrepareTiger ( agressivity ) ; begin
50512: LD_INT 0
50514: PPUSH
// uc_side := 0 ;
50515: LD_ADDR_OWVAR 20
50519: PUSH
50520: LD_INT 0
50522: ST_TO_ADDR
// uc_nation := 0 ;
50523: LD_ADDR_OWVAR 21
50527: PUSH
50528: LD_INT 0
50530: ST_TO_ADDR
// hc_class := class_tiger ;
50531: LD_ADDR_OWVAR 28
50535: PUSH
50536: LD_INT 14
50538: ST_TO_ADDR
// hc_gallery :=  ;
50539: LD_ADDR_OWVAR 33
50543: PUSH
50544: LD_STRING 
50546: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50547: LD_ADDR_OWVAR 35
50551: PUSH
50552: LD_VAR 0 1
50556: NEG
50557: PPUSH
50558: LD_VAR 0 1
50562: PPUSH
50563: CALL_OW 12
50567: ST_TO_ADDR
// end ;
50568: LD_VAR 0 2
50572: RET
// export function PrepareEnchidna ( ) ; begin
50573: LD_INT 0
50575: PPUSH
// uc_side := 0 ;
50576: LD_ADDR_OWVAR 20
50580: PUSH
50581: LD_INT 0
50583: ST_TO_ADDR
// uc_nation := 0 ;
50584: LD_ADDR_OWVAR 21
50588: PUSH
50589: LD_INT 0
50591: ST_TO_ADDR
// hc_class := class_baggie ;
50592: LD_ADDR_OWVAR 28
50596: PUSH
50597: LD_INT 13
50599: ST_TO_ADDR
// hc_gallery :=  ;
50600: LD_ADDR_OWVAR 33
50604: PUSH
50605: LD_STRING 
50607: ST_TO_ADDR
// end ;
50608: LD_VAR 0 1
50612: RET
// export function PrepareFrog ( ) ; begin
50613: LD_INT 0
50615: PPUSH
// uc_side := 0 ;
50616: LD_ADDR_OWVAR 20
50620: PUSH
50621: LD_INT 0
50623: ST_TO_ADDR
// uc_nation := 0 ;
50624: LD_ADDR_OWVAR 21
50628: PUSH
50629: LD_INT 0
50631: ST_TO_ADDR
// hc_class := class_frog ;
50632: LD_ADDR_OWVAR 28
50636: PUSH
50637: LD_INT 19
50639: ST_TO_ADDR
// hc_gallery :=  ;
50640: LD_ADDR_OWVAR 33
50644: PUSH
50645: LD_STRING 
50647: ST_TO_ADDR
// end ;
50648: LD_VAR 0 1
50652: RET
// export function PrepareFish ( ) ; begin
50653: LD_INT 0
50655: PPUSH
// uc_side := 0 ;
50656: LD_ADDR_OWVAR 20
50660: PUSH
50661: LD_INT 0
50663: ST_TO_ADDR
// uc_nation := 0 ;
50664: LD_ADDR_OWVAR 21
50668: PUSH
50669: LD_INT 0
50671: ST_TO_ADDR
// hc_class := class_fish ;
50672: LD_ADDR_OWVAR 28
50676: PUSH
50677: LD_INT 20
50679: ST_TO_ADDR
// hc_gallery :=  ;
50680: LD_ADDR_OWVAR 33
50684: PUSH
50685: LD_STRING 
50687: ST_TO_ADDR
// end ;
50688: LD_VAR 0 1
50692: RET
// export function PrepareBird ( ) ; begin
50693: LD_INT 0
50695: PPUSH
// uc_side := 0 ;
50696: LD_ADDR_OWVAR 20
50700: PUSH
50701: LD_INT 0
50703: ST_TO_ADDR
// uc_nation := 0 ;
50704: LD_ADDR_OWVAR 21
50708: PUSH
50709: LD_INT 0
50711: ST_TO_ADDR
// hc_class := class_phororhacos ;
50712: LD_ADDR_OWVAR 28
50716: PUSH
50717: LD_INT 18
50719: ST_TO_ADDR
// hc_gallery :=  ;
50720: LD_ADDR_OWVAR 33
50724: PUSH
50725: LD_STRING 
50727: ST_TO_ADDR
// end ;
50728: LD_VAR 0 1
50732: RET
// export function PrepareHorse ( ) ; begin
50733: LD_INT 0
50735: PPUSH
// uc_side := 0 ;
50736: LD_ADDR_OWVAR 20
50740: PUSH
50741: LD_INT 0
50743: ST_TO_ADDR
// uc_nation := 0 ;
50744: LD_ADDR_OWVAR 21
50748: PUSH
50749: LD_INT 0
50751: ST_TO_ADDR
// hc_class := class_horse ;
50752: LD_ADDR_OWVAR 28
50756: PUSH
50757: LD_INT 21
50759: ST_TO_ADDR
// hc_gallery :=  ;
50760: LD_ADDR_OWVAR 33
50764: PUSH
50765: LD_STRING 
50767: ST_TO_ADDR
// end ;
50768: LD_VAR 0 1
50772: RET
// export function PrepareMastodont ( ) ; begin
50773: LD_INT 0
50775: PPUSH
// uc_side := 0 ;
50776: LD_ADDR_OWVAR 20
50780: PUSH
50781: LD_INT 0
50783: ST_TO_ADDR
// uc_nation := 0 ;
50784: LD_ADDR_OWVAR 21
50788: PUSH
50789: LD_INT 0
50791: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50792: LD_ADDR_OWVAR 37
50796: PUSH
50797: LD_INT 31
50799: ST_TO_ADDR
// vc_control := control_rider ;
50800: LD_ADDR_OWVAR 38
50804: PUSH
50805: LD_INT 4
50807: ST_TO_ADDR
// end ;
50808: LD_VAR 0 1
50812: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50813: LD_INT 0
50815: PPUSH
50816: PPUSH
50817: PPUSH
// uc_side = 0 ;
50818: LD_ADDR_OWVAR 20
50822: PUSH
50823: LD_INT 0
50825: ST_TO_ADDR
// uc_nation = 0 ;
50826: LD_ADDR_OWVAR 21
50830: PUSH
50831: LD_INT 0
50833: ST_TO_ADDR
// InitHc_All ( ) ;
50834: CALL_OW 584
// InitVc ;
50838: CALL_OW 20
// if mastodonts then
50842: LD_VAR 0 6
50846: IFFALSE 50913
// for i = 1 to mastodonts do
50848: LD_ADDR_VAR 0 11
50852: PUSH
50853: DOUBLE
50854: LD_INT 1
50856: DEC
50857: ST_TO_ADDR
50858: LD_VAR 0 6
50862: PUSH
50863: FOR_TO
50864: IFFALSE 50911
// begin vc_chassis := 31 ;
50866: LD_ADDR_OWVAR 37
50870: PUSH
50871: LD_INT 31
50873: ST_TO_ADDR
// vc_control := control_rider ;
50874: LD_ADDR_OWVAR 38
50878: PUSH
50879: LD_INT 4
50881: ST_TO_ADDR
// animal := CreateVehicle ;
50882: LD_ADDR_VAR 0 12
50886: PUSH
50887: CALL_OW 45
50891: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50892: LD_VAR 0 12
50896: PPUSH
50897: LD_VAR 0 8
50901: PPUSH
50902: LD_INT 0
50904: PPUSH
50905: CALL 53041 0 3
// end ;
50909: GO 50863
50911: POP
50912: POP
// if horses then
50913: LD_VAR 0 5
50917: IFFALSE 50984
// for i = 1 to horses do
50919: LD_ADDR_VAR 0 11
50923: PUSH
50924: DOUBLE
50925: LD_INT 1
50927: DEC
50928: ST_TO_ADDR
50929: LD_VAR 0 5
50933: PUSH
50934: FOR_TO
50935: IFFALSE 50982
// begin hc_class := 21 ;
50937: LD_ADDR_OWVAR 28
50941: PUSH
50942: LD_INT 21
50944: ST_TO_ADDR
// hc_gallery :=  ;
50945: LD_ADDR_OWVAR 33
50949: PUSH
50950: LD_STRING 
50952: ST_TO_ADDR
// animal := CreateHuman ;
50953: LD_ADDR_VAR 0 12
50957: PUSH
50958: CALL_OW 44
50962: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50963: LD_VAR 0 12
50967: PPUSH
50968: LD_VAR 0 8
50972: PPUSH
50973: LD_INT 0
50975: PPUSH
50976: CALL 53041 0 3
// end ;
50980: GO 50934
50982: POP
50983: POP
// if birds then
50984: LD_VAR 0 1
50988: IFFALSE 51055
// for i = 1 to birds do
50990: LD_ADDR_VAR 0 11
50994: PUSH
50995: DOUBLE
50996: LD_INT 1
50998: DEC
50999: ST_TO_ADDR
51000: LD_VAR 0 1
51004: PUSH
51005: FOR_TO
51006: IFFALSE 51053
// begin hc_class := 18 ;
51008: LD_ADDR_OWVAR 28
51012: PUSH
51013: LD_INT 18
51015: ST_TO_ADDR
// hc_gallery =  ;
51016: LD_ADDR_OWVAR 33
51020: PUSH
51021: LD_STRING 
51023: ST_TO_ADDR
// animal := CreateHuman ;
51024: LD_ADDR_VAR 0 12
51028: PUSH
51029: CALL_OW 44
51033: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51034: LD_VAR 0 12
51038: PPUSH
51039: LD_VAR 0 8
51043: PPUSH
51044: LD_INT 0
51046: PPUSH
51047: CALL 53041 0 3
// end ;
51051: GO 51005
51053: POP
51054: POP
// if tigers then
51055: LD_VAR 0 2
51059: IFFALSE 51143
// for i = 1 to tigers do
51061: LD_ADDR_VAR 0 11
51065: PUSH
51066: DOUBLE
51067: LD_INT 1
51069: DEC
51070: ST_TO_ADDR
51071: LD_VAR 0 2
51075: PUSH
51076: FOR_TO
51077: IFFALSE 51141
// begin hc_class = class_tiger ;
51079: LD_ADDR_OWVAR 28
51083: PUSH
51084: LD_INT 14
51086: ST_TO_ADDR
// hc_gallery =  ;
51087: LD_ADDR_OWVAR 33
51091: PUSH
51092: LD_STRING 
51094: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51095: LD_ADDR_OWVAR 35
51099: PUSH
51100: LD_INT 7
51102: NEG
51103: PPUSH
51104: LD_INT 7
51106: PPUSH
51107: CALL_OW 12
51111: ST_TO_ADDR
// animal := CreateHuman ;
51112: LD_ADDR_VAR 0 12
51116: PUSH
51117: CALL_OW 44
51121: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51122: LD_VAR 0 12
51126: PPUSH
51127: LD_VAR 0 8
51131: PPUSH
51132: LD_INT 0
51134: PPUSH
51135: CALL 53041 0 3
// end ;
51139: GO 51076
51141: POP
51142: POP
// if apemans then
51143: LD_VAR 0 3
51147: IFFALSE 51270
// for i = 1 to apemans do
51149: LD_ADDR_VAR 0 11
51153: PUSH
51154: DOUBLE
51155: LD_INT 1
51157: DEC
51158: ST_TO_ADDR
51159: LD_VAR 0 3
51163: PUSH
51164: FOR_TO
51165: IFFALSE 51268
// begin hc_class = class_apeman ;
51167: LD_ADDR_OWVAR 28
51171: PUSH
51172: LD_INT 12
51174: ST_TO_ADDR
// hc_gallery =  ;
51175: LD_ADDR_OWVAR 33
51179: PUSH
51180: LD_STRING 
51182: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
51183: LD_ADDR_OWVAR 35
51187: PUSH
51188: LD_INT 2
51190: NEG
51191: PPUSH
51192: LD_INT 2
51194: PPUSH
51195: CALL_OW 12
51199: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
51200: LD_ADDR_OWVAR 31
51204: PUSH
51205: LD_INT 1
51207: PPUSH
51208: LD_INT 3
51210: PPUSH
51211: CALL_OW 12
51215: PUSH
51216: LD_INT 1
51218: PPUSH
51219: LD_INT 3
51221: PPUSH
51222: CALL_OW 12
51226: PUSH
51227: LD_INT 0
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: LIST
51237: LIST
51238: ST_TO_ADDR
// animal := CreateHuman ;
51239: LD_ADDR_VAR 0 12
51243: PUSH
51244: CALL_OW 44
51248: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51249: LD_VAR 0 12
51253: PPUSH
51254: LD_VAR 0 8
51258: PPUSH
51259: LD_INT 0
51261: PPUSH
51262: CALL 53041 0 3
// end ;
51266: GO 51164
51268: POP
51269: POP
// if enchidnas then
51270: LD_VAR 0 4
51274: IFFALSE 51341
// for i = 1 to enchidnas do
51276: LD_ADDR_VAR 0 11
51280: PUSH
51281: DOUBLE
51282: LD_INT 1
51284: DEC
51285: ST_TO_ADDR
51286: LD_VAR 0 4
51290: PUSH
51291: FOR_TO
51292: IFFALSE 51339
// begin hc_class = 13 ;
51294: LD_ADDR_OWVAR 28
51298: PUSH
51299: LD_INT 13
51301: ST_TO_ADDR
// hc_gallery =  ;
51302: LD_ADDR_OWVAR 33
51306: PUSH
51307: LD_STRING 
51309: ST_TO_ADDR
// animal := CreateHuman ;
51310: LD_ADDR_VAR 0 12
51314: PUSH
51315: CALL_OW 44
51319: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51320: LD_VAR 0 12
51324: PPUSH
51325: LD_VAR 0 8
51329: PPUSH
51330: LD_INT 0
51332: PPUSH
51333: CALL 53041 0 3
// end ;
51337: GO 51291
51339: POP
51340: POP
// if fishes then
51341: LD_VAR 0 7
51345: IFFALSE 51412
// for i = 1 to fishes do
51347: LD_ADDR_VAR 0 11
51351: PUSH
51352: DOUBLE
51353: LD_INT 1
51355: DEC
51356: ST_TO_ADDR
51357: LD_VAR 0 7
51361: PUSH
51362: FOR_TO
51363: IFFALSE 51410
// begin hc_class = 20 ;
51365: LD_ADDR_OWVAR 28
51369: PUSH
51370: LD_INT 20
51372: ST_TO_ADDR
// hc_gallery =  ;
51373: LD_ADDR_OWVAR 33
51377: PUSH
51378: LD_STRING 
51380: ST_TO_ADDR
// animal := CreateHuman ;
51381: LD_ADDR_VAR 0 12
51385: PUSH
51386: CALL_OW 44
51390: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51391: LD_VAR 0 12
51395: PPUSH
51396: LD_VAR 0 9
51400: PPUSH
51401: LD_INT 0
51403: PPUSH
51404: CALL 53041 0 3
// end ;
51408: GO 51362
51410: POP
51411: POP
// end ;
51412: LD_VAR 0 10
51416: RET
// export function WantHeal ( sci , unit ) ; begin
51417: LD_INT 0
51419: PPUSH
// if GetTaskList ( sci ) > 0 then
51420: LD_VAR 0 1
51424: PPUSH
51425: CALL_OW 437
51429: PUSH
51430: LD_INT 0
51432: GREATER
51433: IFFALSE 51503
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51435: LD_VAR 0 1
51439: PPUSH
51440: CALL_OW 437
51444: PUSH
51445: LD_INT 1
51447: ARRAY
51448: PUSH
51449: LD_INT 1
51451: ARRAY
51452: PUSH
51453: LD_STRING l
51455: EQUAL
51456: PUSH
51457: LD_VAR 0 1
51461: PPUSH
51462: CALL_OW 437
51466: PUSH
51467: LD_INT 1
51469: ARRAY
51470: PUSH
51471: LD_INT 4
51473: ARRAY
51474: PUSH
51475: LD_VAR 0 2
51479: EQUAL
51480: AND
51481: IFFALSE 51493
// result := true else
51483: LD_ADDR_VAR 0 3
51487: PUSH
51488: LD_INT 1
51490: ST_TO_ADDR
51491: GO 51501
// result := false ;
51493: LD_ADDR_VAR 0 3
51497: PUSH
51498: LD_INT 0
51500: ST_TO_ADDR
// end else
51501: GO 51511
// result := false ;
51503: LD_ADDR_VAR 0 3
51507: PUSH
51508: LD_INT 0
51510: ST_TO_ADDR
// end ;
51511: LD_VAR 0 3
51515: RET
// export function HealTarget ( sci ) ; begin
51516: LD_INT 0
51518: PPUSH
// if not sci then
51519: LD_VAR 0 1
51523: NOT
51524: IFFALSE 51528
// exit ;
51526: GO 51593
// result := 0 ;
51528: LD_ADDR_VAR 0 2
51532: PUSH
51533: LD_INT 0
51535: ST_TO_ADDR
// if GetTaskList ( sci ) then
51536: LD_VAR 0 1
51540: PPUSH
51541: CALL_OW 437
51545: IFFALSE 51593
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51547: LD_VAR 0 1
51551: PPUSH
51552: CALL_OW 437
51556: PUSH
51557: LD_INT 1
51559: ARRAY
51560: PUSH
51561: LD_INT 1
51563: ARRAY
51564: PUSH
51565: LD_STRING l
51567: EQUAL
51568: IFFALSE 51593
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51570: LD_ADDR_VAR 0 2
51574: PUSH
51575: LD_VAR 0 1
51579: PPUSH
51580: CALL_OW 437
51584: PUSH
51585: LD_INT 1
51587: ARRAY
51588: PUSH
51589: LD_INT 4
51591: ARRAY
51592: ST_TO_ADDR
// end ;
51593: LD_VAR 0 2
51597: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51598: LD_INT 0
51600: PPUSH
51601: PPUSH
51602: PPUSH
51603: PPUSH
// if not base_units then
51604: LD_VAR 0 1
51608: NOT
51609: IFFALSE 51613
// exit ;
51611: GO 51700
// result := false ;
51613: LD_ADDR_VAR 0 2
51617: PUSH
51618: LD_INT 0
51620: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51621: LD_ADDR_VAR 0 5
51625: PUSH
51626: LD_VAR 0 1
51630: PPUSH
51631: LD_INT 21
51633: PUSH
51634: LD_INT 3
51636: PUSH
51637: EMPTY
51638: LIST
51639: LIST
51640: PPUSH
51641: CALL_OW 72
51645: ST_TO_ADDR
// if not tmp then
51646: LD_VAR 0 5
51650: NOT
51651: IFFALSE 51655
// exit ;
51653: GO 51700
// for i in tmp do
51655: LD_ADDR_VAR 0 3
51659: PUSH
51660: LD_VAR 0 5
51664: PUSH
51665: FOR_IN
51666: IFFALSE 51698
// begin result := EnemyInRange ( i , 22 ) ;
51668: LD_ADDR_VAR 0 2
51672: PUSH
51673: LD_VAR 0 3
51677: PPUSH
51678: LD_INT 22
51680: PPUSH
51681: CALL 49298 0 2
51685: ST_TO_ADDR
// if result then
51686: LD_VAR 0 2
51690: IFFALSE 51696
// exit ;
51692: POP
51693: POP
51694: GO 51700
// end ;
51696: GO 51665
51698: POP
51699: POP
// end ;
51700: LD_VAR 0 2
51704: RET
// export function FilterByTag ( units , tag ) ; begin
51705: LD_INT 0
51707: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51708: LD_ADDR_VAR 0 3
51712: PUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: LD_INT 120
51720: PUSH
51721: LD_VAR 0 2
51725: PUSH
51726: EMPTY
51727: LIST
51728: LIST
51729: PPUSH
51730: CALL_OW 72
51734: ST_TO_ADDR
// end ;
51735: LD_VAR 0 3
51739: RET
// export function IsDriver ( un ) ; begin
51740: LD_INT 0
51742: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51743: LD_ADDR_VAR 0 2
51747: PUSH
51748: LD_VAR 0 1
51752: PUSH
51753: LD_INT 55
51755: PUSH
51756: EMPTY
51757: LIST
51758: PPUSH
51759: CALL_OW 69
51763: IN
51764: ST_TO_ADDR
// end ;
51765: LD_VAR 0 2
51769: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51770: LD_INT 0
51772: PPUSH
51773: PPUSH
// list := [ ] ;
51774: LD_ADDR_VAR 0 5
51778: PUSH
51779: EMPTY
51780: ST_TO_ADDR
// case d of 0 :
51781: LD_VAR 0 3
51785: PUSH
51786: LD_INT 0
51788: DOUBLE
51789: EQUAL
51790: IFTRUE 51794
51792: GO 51927
51794: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51795: LD_ADDR_VAR 0 5
51799: PUSH
51800: LD_VAR 0 1
51804: PUSH
51805: LD_INT 4
51807: MINUS
51808: PUSH
51809: LD_VAR 0 2
51813: PUSH
51814: LD_INT 4
51816: MINUS
51817: PUSH
51818: LD_INT 2
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: LIST
51825: PUSH
51826: LD_VAR 0 1
51830: PUSH
51831: LD_INT 3
51833: MINUS
51834: PUSH
51835: LD_VAR 0 2
51839: PUSH
51840: LD_INT 1
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: LIST
51847: PUSH
51848: LD_VAR 0 1
51852: PUSH
51853: LD_INT 4
51855: PLUS
51856: PUSH
51857: LD_VAR 0 2
51861: PUSH
51862: LD_INT 4
51864: PUSH
51865: EMPTY
51866: LIST
51867: LIST
51868: LIST
51869: PUSH
51870: LD_VAR 0 1
51874: PUSH
51875: LD_INT 3
51877: PLUS
51878: PUSH
51879: LD_VAR 0 2
51883: PUSH
51884: LD_INT 3
51886: PLUS
51887: PUSH
51888: LD_INT 5
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: LIST
51895: PUSH
51896: LD_VAR 0 1
51900: PUSH
51901: LD_VAR 0 2
51905: PUSH
51906: LD_INT 4
51908: PLUS
51909: PUSH
51910: LD_INT 0
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: LIST
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: LIST
51922: LIST
51923: LIST
51924: ST_TO_ADDR
// end ; 1 :
51925: GO 52625
51927: LD_INT 1
51929: DOUBLE
51930: EQUAL
51931: IFTRUE 51935
51933: GO 52068
51935: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51936: LD_ADDR_VAR 0 5
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_VAR 0 2
51950: PUSH
51951: LD_INT 4
51953: MINUS
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: EMPTY
51959: LIST
51960: LIST
51961: LIST
51962: PUSH
51963: LD_VAR 0 1
51967: PUSH
51968: LD_INT 3
51970: MINUS
51971: PUSH
51972: LD_VAR 0 2
51976: PUSH
51977: LD_INT 3
51979: MINUS
51980: PUSH
51981: LD_INT 2
51983: PUSH
51984: EMPTY
51985: LIST
51986: LIST
51987: LIST
51988: PUSH
51989: LD_VAR 0 1
51993: PUSH
51994: LD_INT 4
51996: MINUS
51997: PUSH
51998: LD_VAR 0 2
52002: PUSH
52003: LD_INT 1
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: LIST
52010: PUSH
52011: LD_VAR 0 1
52015: PUSH
52016: LD_VAR 0 2
52020: PUSH
52021: LD_INT 3
52023: PLUS
52024: PUSH
52025: LD_INT 0
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: LIST
52032: PUSH
52033: LD_VAR 0 1
52037: PUSH
52038: LD_INT 4
52040: PLUS
52041: PUSH
52042: LD_VAR 0 2
52046: PUSH
52047: LD_INT 4
52049: PLUS
52050: PUSH
52051: LD_INT 5
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: LIST
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: LIST
52063: LIST
52064: LIST
52065: ST_TO_ADDR
// end ; 2 :
52066: GO 52625
52068: LD_INT 2
52070: DOUBLE
52071: EQUAL
52072: IFTRUE 52076
52074: GO 52205
52076: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52077: LD_ADDR_VAR 0 5
52081: PUSH
52082: LD_VAR 0 1
52086: PUSH
52087: LD_VAR 0 2
52091: PUSH
52092: LD_INT 3
52094: MINUS
52095: PUSH
52096: LD_INT 3
52098: PUSH
52099: EMPTY
52100: LIST
52101: LIST
52102: LIST
52103: PUSH
52104: LD_VAR 0 1
52108: PUSH
52109: LD_INT 4
52111: PLUS
52112: PUSH
52113: LD_VAR 0 2
52117: PUSH
52118: LD_INT 4
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: LIST
52125: PUSH
52126: LD_VAR 0 1
52130: PUSH
52131: LD_VAR 0 2
52135: PUSH
52136: LD_INT 4
52138: PLUS
52139: PUSH
52140: LD_INT 0
52142: PUSH
52143: EMPTY
52144: LIST
52145: LIST
52146: LIST
52147: PUSH
52148: LD_VAR 0 1
52152: PUSH
52153: LD_INT 3
52155: MINUS
52156: PUSH
52157: LD_VAR 0 2
52161: PUSH
52162: LD_INT 1
52164: PUSH
52165: EMPTY
52166: LIST
52167: LIST
52168: LIST
52169: PUSH
52170: LD_VAR 0 1
52174: PUSH
52175: LD_INT 4
52177: MINUS
52178: PUSH
52179: LD_VAR 0 2
52183: PUSH
52184: LD_INT 4
52186: MINUS
52187: PUSH
52188: LD_INT 2
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: LIST
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: LIST
52200: LIST
52201: LIST
52202: ST_TO_ADDR
// end ; 3 :
52203: GO 52625
52205: LD_INT 3
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52346
52213: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
52214: LD_ADDR_VAR 0 5
52218: PUSH
52219: LD_VAR 0 1
52223: PUSH
52224: LD_INT 3
52226: PLUS
52227: PUSH
52228: LD_VAR 0 2
52232: PUSH
52233: LD_INT 4
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: LIST
52240: PUSH
52241: LD_VAR 0 1
52245: PUSH
52246: LD_INT 4
52248: PLUS
52249: PUSH
52250: LD_VAR 0 2
52254: PUSH
52255: LD_INT 4
52257: PLUS
52258: PUSH
52259: LD_INT 5
52261: PUSH
52262: EMPTY
52263: LIST
52264: LIST
52265: LIST
52266: PUSH
52267: LD_VAR 0 1
52271: PUSH
52272: LD_INT 4
52274: MINUS
52275: PUSH
52276: LD_VAR 0 2
52280: PUSH
52281: LD_INT 1
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: LIST
52288: PUSH
52289: LD_VAR 0 1
52293: PUSH
52294: LD_VAR 0 2
52298: PUSH
52299: LD_INT 4
52301: MINUS
52302: PUSH
52303: LD_INT 3
52305: PUSH
52306: EMPTY
52307: LIST
52308: LIST
52309: LIST
52310: PUSH
52311: LD_VAR 0 1
52315: PUSH
52316: LD_INT 3
52318: MINUS
52319: PUSH
52320: LD_VAR 0 2
52324: PUSH
52325: LD_INT 3
52327: MINUS
52328: PUSH
52329: LD_INT 2
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: LIST
52336: PUSH
52337: EMPTY
52338: LIST
52339: LIST
52340: LIST
52341: LIST
52342: LIST
52343: ST_TO_ADDR
// end ; 4 :
52344: GO 52625
52346: LD_INT 4
52348: DOUBLE
52349: EQUAL
52350: IFTRUE 52354
52352: GO 52487
52354: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52355: LD_ADDR_VAR 0 5
52359: PUSH
52360: LD_VAR 0 1
52364: PUSH
52365: LD_VAR 0 2
52369: PUSH
52370: LD_INT 4
52372: PLUS
52373: PUSH
52374: LD_INT 0
52376: PUSH
52377: EMPTY
52378: LIST
52379: LIST
52380: LIST
52381: PUSH
52382: LD_VAR 0 1
52386: PUSH
52387: LD_INT 3
52389: PLUS
52390: PUSH
52391: LD_VAR 0 2
52395: PUSH
52396: LD_INT 3
52398: PLUS
52399: PUSH
52400: LD_INT 5
52402: PUSH
52403: EMPTY
52404: LIST
52405: LIST
52406: LIST
52407: PUSH
52408: LD_VAR 0 1
52412: PUSH
52413: LD_INT 4
52415: PLUS
52416: PUSH
52417: LD_VAR 0 2
52421: PUSH
52422: LD_INT 4
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: LIST
52429: PUSH
52430: LD_VAR 0 1
52434: PUSH
52435: LD_VAR 0 2
52439: PUSH
52440: LD_INT 3
52442: MINUS
52443: PUSH
52444: LD_INT 3
52446: PUSH
52447: EMPTY
52448: LIST
52449: LIST
52450: LIST
52451: PUSH
52452: LD_VAR 0 1
52456: PUSH
52457: LD_INT 4
52459: MINUS
52460: PUSH
52461: LD_VAR 0 2
52465: PUSH
52466: LD_INT 4
52468: MINUS
52469: PUSH
52470: LD_INT 2
52472: PUSH
52473: EMPTY
52474: LIST
52475: LIST
52476: LIST
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: ST_TO_ADDR
// end ; 5 :
52485: GO 52625
52487: LD_INT 5
52489: DOUBLE
52490: EQUAL
52491: IFTRUE 52495
52493: GO 52624
52495: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52496: LD_ADDR_VAR 0 5
52500: PUSH
52501: LD_VAR 0 1
52505: PUSH
52506: LD_INT 4
52508: MINUS
52509: PUSH
52510: LD_VAR 0 2
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: LIST
52522: PUSH
52523: LD_VAR 0 1
52527: PUSH
52528: LD_VAR 0 2
52532: PUSH
52533: LD_INT 4
52535: MINUS
52536: PUSH
52537: LD_INT 3
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: LIST
52544: PUSH
52545: LD_VAR 0 1
52549: PUSH
52550: LD_INT 4
52552: PLUS
52553: PUSH
52554: LD_VAR 0 2
52558: PUSH
52559: LD_INT 4
52561: PLUS
52562: PUSH
52563: LD_INT 5
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: LIST
52570: PUSH
52571: LD_VAR 0 1
52575: PUSH
52576: LD_INT 3
52578: PLUS
52579: PUSH
52580: LD_VAR 0 2
52584: PUSH
52585: LD_INT 4
52587: PUSH
52588: EMPTY
52589: LIST
52590: LIST
52591: LIST
52592: PUSH
52593: LD_VAR 0 1
52597: PUSH
52598: LD_VAR 0 2
52602: PUSH
52603: LD_INT 3
52605: PLUS
52606: PUSH
52607: LD_INT 0
52609: PUSH
52610: EMPTY
52611: LIST
52612: LIST
52613: LIST
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: LIST
52619: LIST
52620: LIST
52621: ST_TO_ADDR
// end ; end ;
52622: GO 52625
52624: POP
// result := list ;
52625: LD_ADDR_VAR 0 4
52629: PUSH
52630: LD_VAR 0 5
52634: ST_TO_ADDR
// end ;
52635: LD_VAR 0 4
52639: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52640: LD_INT 0
52642: PPUSH
52643: PPUSH
52644: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52645: LD_VAR 0 1
52649: NOT
52650: PUSH
52651: LD_VAR 0 2
52655: PUSH
52656: LD_INT 1
52658: PUSH
52659: LD_INT 2
52661: PUSH
52662: LD_INT 3
52664: PUSH
52665: LD_INT 4
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: IN
52674: NOT
52675: OR
52676: IFFALSE 52680
// exit ;
52678: GO 52763
// tmp := [ ] ;
52680: LD_ADDR_VAR 0 5
52684: PUSH
52685: EMPTY
52686: ST_TO_ADDR
// for i in units do
52687: LD_ADDR_VAR 0 4
52691: PUSH
52692: LD_VAR 0 1
52696: PUSH
52697: FOR_IN
52698: IFFALSE 52732
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52700: LD_ADDR_VAR 0 5
52704: PUSH
52705: LD_VAR 0 5
52709: PPUSH
52710: LD_VAR 0 4
52714: PPUSH
52715: LD_VAR 0 2
52719: PPUSH
52720: CALL_OW 259
52724: PPUSH
52725: CALL 54136 0 2
52729: ST_TO_ADDR
52730: GO 52697
52732: POP
52733: POP
// if not tmp then
52734: LD_VAR 0 5
52738: NOT
52739: IFFALSE 52743
// exit ;
52741: GO 52763
// result := SortListByListDesc ( units , tmp ) ;
52743: LD_ADDR_VAR 0 3
52747: PUSH
52748: LD_VAR 0 1
52752: PPUSH
52753: LD_VAR 0 5
52757: PPUSH
52758: CALL_OW 77
52762: ST_TO_ADDR
// end ;
52763: LD_VAR 0 3
52767: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52768: LD_INT 0
52770: PPUSH
52771: PPUSH
52772: PPUSH
// result := false ;
52773: LD_ADDR_VAR 0 3
52777: PUSH
52778: LD_INT 0
52780: ST_TO_ADDR
// if not building then
52781: LD_VAR 0 2
52785: NOT
52786: IFFALSE 52790
// exit ;
52788: GO 52928
// x := GetX ( building ) ;
52790: LD_ADDR_VAR 0 4
52794: PUSH
52795: LD_VAR 0 2
52799: PPUSH
52800: CALL_OW 250
52804: ST_TO_ADDR
// y := GetY ( building ) ;
52805: LD_ADDR_VAR 0 5
52809: PUSH
52810: LD_VAR 0 2
52814: PPUSH
52815: CALL_OW 251
52819: ST_TO_ADDR
// if not x or not y then
52820: LD_VAR 0 4
52824: NOT
52825: PUSH
52826: LD_VAR 0 5
52830: NOT
52831: OR
52832: IFFALSE 52836
// exit ;
52834: GO 52928
// if GetTaskList ( unit ) then
52836: LD_VAR 0 1
52840: PPUSH
52841: CALL_OW 437
52845: IFFALSE 52928
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52847: LD_STRING e
52849: PUSH
52850: LD_VAR 0 1
52854: PPUSH
52855: CALL_OW 437
52859: PUSH
52860: LD_INT 1
52862: ARRAY
52863: PUSH
52864: LD_INT 1
52866: ARRAY
52867: EQUAL
52868: PUSH
52869: LD_VAR 0 4
52873: PUSH
52874: LD_VAR 0 1
52878: PPUSH
52879: CALL_OW 437
52883: PUSH
52884: LD_INT 1
52886: ARRAY
52887: PUSH
52888: LD_INT 2
52890: ARRAY
52891: EQUAL
52892: AND
52893: PUSH
52894: LD_VAR 0 5
52898: PUSH
52899: LD_VAR 0 1
52903: PPUSH
52904: CALL_OW 437
52908: PUSH
52909: LD_INT 1
52911: ARRAY
52912: PUSH
52913: LD_INT 3
52915: ARRAY
52916: EQUAL
52917: AND
52918: IFFALSE 52928
// result := true end ;
52920: LD_ADDR_VAR 0 3
52924: PUSH
52925: LD_INT 1
52927: ST_TO_ADDR
// end ;
52928: LD_VAR 0 3
52932: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52933: LD_INT 0
52935: PPUSH
// result := false ;
52936: LD_ADDR_VAR 0 4
52940: PUSH
52941: LD_INT 0
52943: ST_TO_ADDR
// if GetTaskList ( unit ) then
52944: LD_VAR 0 1
52948: PPUSH
52949: CALL_OW 437
52953: IFFALSE 53036
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52955: LD_STRING M
52957: PUSH
52958: LD_VAR 0 1
52962: PPUSH
52963: CALL_OW 437
52967: PUSH
52968: LD_INT 1
52970: ARRAY
52971: PUSH
52972: LD_INT 1
52974: ARRAY
52975: EQUAL
52976: PUSH
52977: LD_VAR 0 2
52981: PUSH
52982: LD_VAR 0 1
52986: PPUSH
52987: CALL_OW 437
52991: PUSH
52992: LD_INT 1
52994: ARRAY
52995: PUSH
52996: LD_INT 2
52998: ARRAY
52999: EQUAL
53000: AND
53001: PUSH
53002: LD_VAR 0 3
53006: PUSH
53007: LD_VAR 0 1
53011: PPUSH
53012: CALL_OW 437
53016: PUSH
53017: LD_INT 1
53019: ARRAY
53020: PUSH
53021: LD_INT 3
53023: ARRAY
53024: EQUAL
53025: AND
53026: IFFALSE 53036
// result := true ;
53028: LD_ADDR_VAR 0 4
53032: PUSH
53033: LD_INT 1
53035: ST_TO_ADDR
// end ; end ;
53036: LD_VAR 0 4
53040: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53041: LD_INT 0
53043: PPUSH
53044: PPUSH
53045: PPUSH
53046: PPUSH
// if not unit or not area then
53047: LD_VAR 0 1
53051: NOT
53052: PUSH
53053: LD_VAR 0 2
53057: NOT
53058: OR
53059: IFFALSE 53063
// exit ;
53061: GO 53239
// tmp := AreaToList ( area , i ) ;
53063: LD_ADDR_VAR 0 6
53067: PUSH
53068: LD_VAR 0 2
53072: PPUSH
53073: LD_VAR 0 5
53077: PPUSH
53078: CALL_OW 517
53082: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53083: LD_ADDR_VAR 0 5
53087: PUSH
53088: DOUBLE
53089: LD_INT 1
53091: DEC
53092: ST_TO_ADDR
53093: LD_VAR 0 6
53097: PUSH
53098: LD_INT 1
53100: ARRAY
53101: PUSH
53102: FOR_TO
53103: IFFALSE 53237
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53105: LD_ADDR_VAR 0 7
53109: PUSH
53110: LD_VAR 0 6
53114: PUSH
53115: LD_INT 1
53117: ARRAY
53118: PUSH
53119: LD_VAR 0 5
53123: ARRAY
53124: PUSH
53125: LD_VAR 0 6
53129: PUSH
53130: LD_INT 2
53132: ARRAY
53133: PUSH
53134: LD_VAR 0 5
53138: ARRAY
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
53144: LD_INT 92
53146: PUSH
53147: LD_VAR 0 7
53151: PUSH
53152: LD_INT 1
53154: ARRAY
53155: PUSH
53156: LD_VAR 0 7
53160: PUSH
53161: LD_INT 2
53163: ARRAY
53164: PUSH
53165: LD_INT 2
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: LIST
53172: LIST
53173: PPUSH
53174: CALL_OW 69
53178: PUSH
53179: LD_INT 0
53181: EQUAL
53182: IFFALSE 53235
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
53184: LD_VAR 0 1
53188: PPUSH
53189: LD_VAR 0 7
53193: PUSH
53194: LD_INT 1
53196: ARRAY
53197: PPUSH
53198: LD_VAR 0 7
53202: PUSH
53203: LD_INT 2
53205: ARRAY
53206: PPUSH
53207: LD_VAR 0 3
53211: PPUSH
53212: CALL_OW 48
// result := IsPlaced ( unit ) ;
53216: LD_ADDR_VAR 0 4
53220: PUSH
53221: LD_VAR 0 1
53225: PPUSH
53226: CALL_OW 305
53230: ST_TO_ADDR
// exit ;
53231: POP
53232: POP
53233: GO 53239
// end ; end ;
53235: GO 53102
53237: POP
53238: POP
// end ;
53239: LD_VAR 0 4
53243: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
53244: LD_INT 0
53246: PPUSH
53247: PPUSH
53248: PPUSH
// if not side or side > 8 then
53249: LD_VAR 0 1
53253: NOT
53254: PUSH
53255: LD_VAR 0 1
53259: PUSH
53260: LD_INT 8
53262: GREATER
53263: OR
53264: IFFALSE 53268
// exit ;
53266: GO 53455
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
53268: LD_ADDR_VAR 0 4
53272: PUSH
53273: LD_INT 22
53275: PUSH
53276: LD_VAR 0 1
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: PUSH
53285: LD_INT 21
53287: PUSH
53288: LD_INT 3
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: ST_TO_ADDR
// if not tmp then
53304: LD_VAR 0 4
53308: NOT
53309: IFFALSE 53313
// exit ;
53311: GO 53455
// enable_addtolog := true ;
53313: LD_ADDR_OWVAR 81
53317: PUSH
53318: LD_INT 1
53320: ST_TO_ADDR
// AddToLog ( [ ) ;
53321: LD_STRING [
53323: PPUSH
53324: CALL_OW 561
// for i in tmp do
53328: LD_ADDR_VAR 0 3
53332: PUSH
53333: LD_VAR 0 4
53337: PUSH
53338: FOR_IN
53339: IFFALSE 53446
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53341: LD_STRING [
53343: PUSH
53344: LD_VAR 0 3
53348: PPUSH
53349: CALL_OW 266
53353: STR
53354: PUSH
53355: LD_STRING , 
53357: STR
53358: PUSH
53359: LD_VAR 0 3
53363: PPUSH
53364: CALL_OW 250
53368: STR
53369: PUSH
53370: LD_STRING , 
53372: STR
53373: PUSH
53374: LD_VAR 0 3
53378: PPUSH
53379: CALL_OW 251
53383: STR
53384: PUSH
53385: LD_STRING , 
53387: STR
53388: PUSH
53389: LD_VAR 0 3
53393: PPUSH
53394: CALL_OW 254
53398: STR
53399: PUSH
53400: LD_STRING , 
53402: STR
53403: PUSH
53404: LD_VAR 0 3
53408: PPUSH
53409: LD_INT 1
53411: PPUSH
53412: CALL_OW 268
53416: STR
53417: PUSH
53418: LD_STRING , 
53420: STR
53421: PUSH
53422: LD_VAR 0 3
53426: PPUSH
53427: LD_INT 2
53429: PPUSH
53430: CALL_OW 268
53434: STR
53435: PUSH
53436: LD_STRING ],
53438: STR
53439: PPUSH
53440: CALL_OW 561
// end ;
53444: GO 53338
53446: POP
53447: POP
// AddToLog ( ]; ) ;
53448: LD_STRING ];
53450: PPUSH
53451: CALL_OW 561
// end ;
53455: LD_VAR 0 2
53459: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53460: LD_INT 0
53462: PPUSH
53463: PPUSH
53464: PPUSH
53465: PPUSH
53466: PPUSH
// if not area or not rate or not max then
53467: LD_VAR 0 1
53471: NOT
53472: PUSH
53473: LD_VAR 0 2
53477: NOT
53478: OR
53479: PUSH
53480: LD_VAR 0 4
53484: NOT
53485: OR
53486: IFFALSE 53490
// exit ;
53488: GO 53679
// while 1 do
53490: LD_INT 1
53492: IFFALSE 53679
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53494: LD_ADDR_VAR 0 9
53498: PUSH
53499: LD_VAR 0 1
53503: PPUSH
53504: LD_INT 1
53506: PPUSH
53507: CALL_OW 287
53511: PUSH
53512: LD_INT 10
53514: MUL
53515: ST_TO_ADDR
// r := rate / 10 ;
53516: LD_ADDR_VAR 0 7
53520: PUSH
53521: LD_VAR 0 2
53525: PUSH
53526: LD_INT 10
53528: DIVREAL
53529: ST_TO_ADDR
// time := 1 1$00 ;
53530: LD_ADDR_VAR 0 8
53534: PUSH
53535: LD_INT 2100
53537: ST_TO_ADDR
// if amount < min then
53538: LD_VAR 0 9
53542: PUSH
53543: LD_VAR 0 3
53547: LESS
53548: IFFALSE 53566
// r := r * 2 else
53550: LD_ADDR_VAR 0 7
53554: PUSH
53555: LD_VAR 0 7
53559: PUSH
53560: LD_INT 2
53562: MUL
53563: ST_TO_ADDR
53564: GO 53592
// if amount > max then
53566: LD_VAR 0 9
53570: PUSH
53571: LD_VAR 0 4
53575: GREATER
53576: IFFALSE 53592
// r := r / 2 ;
53578: LD_ADDR_VAR 0 7
53582: PUSH
53583: LD_VAR 0 7
53587: PUSH
53588: LD_INT 2
53590: DIVREAL
53591: ST_TO_ADDR
// time := time / r ;
53592: LD_ADDR_VAR 0 8
53596: PUSH
53597: LD_VAR 0 8
53601: PUSH
53602: LD_VAR 0 7
53606: DIVREAL
53607: ST_TO_ADDR
// if time < 0 then
53608: LD_VAR 0 8
53612: PUSH
53613: LD_INT 0
53615: LESS
53616: IFFALSE 53633
// time := time * - 1 ;
53618: LD_ADDR_VAR 0 8
53622: PUSH
53623: LD_VAR 0 8
53627: PUSH
53628: LD_INT 1
53630: NEG
53631: MUL
53632: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53633: LD_VAR 0 8
53637: PUSH
53638: LD_INT 35
53640: PPUSH
53641: LD_INT 875
53643: PPUSH
53644: CALL_OW 12
53648: PLUS
53649: PPUSH
53650: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53654: LD_INT 1
53656: PPUSH
53657: LD_INT 5
53659: PPUSH
53660: CALL_OW 12
53664: PPUSH
53665: LD_VAR 0 1
53669: PPUSH
53670: LD_INT 1
53672: PPUSH
53673: CALL_OW 55
// end ;
53677: GO 53490
// end ;
53679: LD_VAR 0 5
53683: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53684: LD_INT 0
53686: PPUSH
53687: PPUSH
53688: PPUSH
53689: PPUSH
53690: PPUSH
53691: PPUSH
53692: PPUSH
53693: PPUSH
// if not turrets or not factories then
53694: LD_VAR 0 1
53698: NOT
53699: PUSH
53700: LD_VAR 0 2
53704: NOT
53705: OR
53706: IFFALSE 53710
// exit ;
53708: GO 54017
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53710: LD_ADDR_VAR 0 10
53714: PUSH
53715: LD_INT 5
53717: PUSH
53718: LD_INT 6
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: LD_INT 2
53727: PUSH
53728: LD_INT 4
53730: PUSH
53731: EMPTY
53732: LIST
53733: LIST
53734: PUSH
53735: LD_INT 3
53737: PUSH
53738: LD_INT 5
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: PUSH
53745: EMPTY
53746: LIST
53747: LIST
53748: LIST
53749: PUSH
53750: LD_INT 24
53752: PUSH
53753: LD_INT 25
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: PUSH
53760: LD_INT 23
53762: PUSH
53763: LD_INT 27
53765: PUSH
53766: EMPTY
53767: LIST
53768: LIST
53769: PUSH
53770: EMPTY
53771: LIST
53772: LIST
53773: PUSH
53774: LD_INT 42
53776: PUSH
53777: LD_INT 43
53779: PUSH
53780: EMPTY
53781: LIST
53782: LIST
53783: PUSH
53784: LD_INT 44
53786: PUSH
53787: LD_INT 46
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: LD_INT 45
53796: PUSH
53797: LD_INT 47
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: LIST
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: LIST
53813: ST_TO_ADDR
// result := [ ] ;
53814: LD_ADDR_VAR 0 3
53818: PUSH
53819: EMPTY
53820: ST_TO_ADDR
// for i in turrets do
53821: LD_ADDR_VAR 0 4
53825: PUSH
53826: LD_VAR 0 1
53830: PUSH
53831: FOR_IN
53832: IFFALSE 54015
// begin nat := GetNation ( i ) ;
53834: LD_ADDR_VAR 0 7
53838: PUSH
53839: LD_VAR 0 4
53843: PPUSH
53844: CALL_OW 248
53848: ST_TO_ADDR
// weapon := 0 ;
53849: LD_ADDR_VAR 0 8
53853: PUSH
53854: LD_INT 0
53856: ST_TO_ADDR
// if not nat then
53857: LD_VAR 0 7
53861: NOT
53862: IFFALSE 53866
// continue ;
53864: GO 53831
// for j in list [ nat ] do
53866: LD_ADDR_VAR 0 5
53870: PUSH
53871: LD_VAR 0 10
53875: PUSH
53876: LD_VAR 0 7
53880: ARRAY
53881: PUSH
53882: FOR_IN
53883: IFFALSE 53924
// if GetBWeapon ( i ) = j [ 1 ] then
53885: LD_VAR 0 4
53889: PPUSH
53890: CALL_OW 269
53894: PUSH
53895: LD_VAR 0 5
53899: PUSH
53900: LD_INT 1
53902: ARRAY
53903: EQUAL
53904: IFFALSE 53922
// begin weapon := j [ 2 ] ;
53906: LD_ADDR_VAR 0 8
53910: PUSH
53911: LD_VAR 0 5
53915: PUSH
53916: LD_INT 2
53918: ARRAY
53919: ST_TO_ADDR
// break ;
53920: GO 53924
// end ;
53922: GO 53882
53924: POP
53925: POP
// if not weapon then
53926: LD_VAR 0 8
53930: NOT
53931: IFFALSE 53935
// continue ;
53933: GO 53831
// for k in factories do
53935: LD_ADDR_VAR 0 6
53939: PUSH
53940: LD_VAR 0 2
53944: PUSH
53945: FOR_IN
53946: IFFALSE 54011
// begin weapons := AvailableWeaponList ( k ) ;
53948: LD_ADDR_VAR 0 9
53952: PUSH
53953: LD_VAR 0 6
53957: PPUSH
53958: CALL_OW 478
53962: ST_TO_ADDR
// if not weapons then
53963: LD_VAR 0 9
53967: NOT
53968: IFFALSE 53972
// continue ;
53970: GO 53945
// if weapon in weapons then
53972: LD_VAR 0 8
53976: PUSH
53977: LD_VAR 0 9
53981: IN
53982: IFFALSE 54009
// begin result := [ i , weapon ] ;
53984: LD_ADDR_VAR 0 3
53988: PUSH
53989: LD_VAR 0 4
53993: PUSH
53994: LD_VAR 0 8
53998: PUSH
53999: EMPTY
54000: LIST
54001: LIST
54002: ST_TO_ADDR
// exit ;
54003: POP
54004: POP
54005: POP
54006: POP
54007: GO 54017
// end ; end ;
54009: GO 53945
54011: POP
54012: POP
// end ;
54013: GO 53831
54015: POP
54016: POP
// end ;
54017: LD_VAR 0 3
54021: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54022: LD_INT 0
54024: PPUSH
// if not side or side > 8 then
54025: LD_VAR 0 3
54029: NOT
54030: PUSH
54031: LD_VAR 0 3
54035: PUSH
54036: LD_INT 8
54038: GREATER
54039: OR
54040: IFFALSE 54044
// exit ;
54042: GO 54103
// if not range then
54044: LD_VAR 0 4
54048: NOT
54049: IFFALSE 54060
// range := - 12 ;
54051: LD_ADDR_VAR 0 4
54055: PUSH
54056: LD_INT 12
54058: NEG
54059: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54060: LD_VAR 0 1
54064: PPUSH
54065: LD_VAR 0 2
54069: PPUSH
54070: LD_VAR 0 3
54074: PPUSH
54075: LD_VAR 0 4
54079: PPUSH
54080: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54084: LD_VAR 0 1
54088: PPUSH
54089: LD_VAR 0 2
54093: PPUSH
54094: LD_VAR 0 3
54098: PPUSH
54099: CALL_OW 331
// end ;
54103: LD_VAR 0 5
54107: RET
// export function Video ( mode ) ; begin
54108: LD_INT 0
54110: PPUSH
// ingame_video = mode ;
54111: LD_ADDR_OWVAR 52
54115: PUSH
54116: LD_VAR 0 1
54120: ST_TO_ADDR
// interface_hidden = mode ;
54121: LD_ADDR_OWVAR 54
54125: PUSH
54126: LD_VAR 0 1
54130: ST_TO_ADDR
// end ;
54131: LD_VAR 0 2
54135: RET
// export function Join ( array , element ) ; begin
54136: LD_INT 0
54138: PPUSH
// result := Replace ( array , array + 1 , element ) ;
54139: LD_ADDR_VAR 0 3
54143: PUSH
54144: LD_VAR 0 1
54148: PPUSH
54149: LD_VAR 0 1
54153: PUSH
54154: LD_INT 1
54156: PLUS
54157: PPUSH
54158: LD_VAR 0 2
54162: PPUSH
54163: CALL_OW 1
54167: ST_TO_ADDR
// end ;
54168: LD_VAR 0 3
54172: RET
// export function JoinUnion ( array , element ) ; begin
54173: LD_INT 0
54175: PPUSH
// result := array union element ;
54176: LD_ADDR_VAR 0 3
54180: PUSH
54181: LD_VAR 0 1
54185: PUSH
54186: LD_VAR 0 2
54190: UNION
54191: ST_TO_ADDR
// end ;
54192: LD_VAR 0 3
54196: RET
// export function GetBehemoths ( side ) ; begin
54197: LD_INT 0
54199: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
54200: LD_ADDR_VAR 0 2
54204: PUSH
54205: LD_INT 22
54207: PUSH
54208: LD_VAR 0 1
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PUSH
54217: LD_INT 31
54219: PUSH
54220: LD_INT 25
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PPUSH
54231: CALL_OW 69
54235: ST_TO_ADDR
// end ;
54236: LD_VAR 0 2
54240: RET
// export function Shuffle ( array ) ; var i , index ; begin
54241: LD_INT 0
54243: PPUSH
54244: PPUSH
54245: PPUSH
// result := [ ] ;
54246: LD_ADDR_VAR 0 2
54250: PUSH
54251: EMPTY
54252: ST_TO_ADDR
// if not array then
54253: LD_VAR 0 1
54257: NOT
54258: IFFALSE 54262
// exit ;
54260: GO 54361
// Randomize ;
54262: CALL_OW 10
// for i = array downto 1 do
54266: LD_ADDR_VAR 0 3
54270: PUSH
54271: DOUBLE
54272: LD_VAR 0 1
54276: INC
54277: ST_TO_ADDR
54278: LD_INT 1
54280: PUSH
54281: FOR_DOWNTO
54282: IFFALSE 54359
// begin index := rand ( 1 , array ) ;
54284: LD_ADDR_VAR 0 4
54288: PUSH
54289: LD_INT 1
54291: PPUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: CALL_OW 12
54301: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
54302: LD_ADDR_VAR 0 2
54306: PUSH
54307: LD_VAR 0 2
54311: PPUSH
54312: LD_VAR 0 2
54316: PUSH
54317: LD_INT 1
54319: PLUS
54320: PPUSH
54321: LD_VAR 0 1
54325: PUSH
54326: LD_VAR 0 4
54330: ARRAY
54331: PPUSH
54332: CALL_OW 2
54336: ST_TO_ADDR
// array := Delete ( array , index ) ;
54337: LD_ADDR_VAR 0 1
54341: PUSH
54342: LD_VAR 0 1
54346: PPUSH
54347: LD_VAR 0 4
54351: PPUSH
54352: CALL_OW 3
54356: ST_TO_ADDR
// end ;
54357: GO 54281
54359: POP
54360: POP
// end ;
54361: LD_VAR 0 2
54365: RET
// export function GetBaseMaterials ( base ) ; begin
54366: LD_INT 0
54368: PPUSH
// result := [ 0 , 0 , 0 ] ;
54369: LD_ADDR_VAR 0 2
54373: PUSH
54374: LD_INT 0
54376: PUSH
54377: LD_INT 0
54379: PUSH
54380: LD_INT 0
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: LIST
54387: ST_TO_ADDR
// if not base then
54388: LD_VAR 0 1
54392: NOT
54393: IFFALSE 54397
// exit ;
54395: GO 54446
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54397: LD_ADDR_VAR 0 2
54401: PUSH
54402: LD_VAR 0 1
54406: PPUSH
54407: LD_INT 1
54409: PPUSH
54410: CALL_OW 275
54414: PUSH
54415: LD_VAR 0 1
54419: PPUSH
54420: LD_INT 2
54422: PPUSH
54423: CALL_OW 275
54427: PUSH
54428: LD_VAR 0 1
54432: PPUSH
54433: LD_INT 3
54435: PPUSH
54436: CALL_OW 275
54440: PUSH
54441: EMPTY
54442: LIST
54443: LIST
54444: LIST
54445: ST_TO_ADDR
// end ;
54446: LD_VAR 0 2
54450: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54451: LD_INT 0
54453: PPUSH
54454: PPUSH
// result := array ;
54455: LD_ADDR_VAR 0 3
54459: PUSH
54460: LD_VAR 0 1
54464: ST_TO_ADDR
// if size >= result then
54465: LD_VAR 0 2
54469: PUSH
54470: LD_VAR 0 3
54474: GREATEREQUAL
54475: IFFALSE 54479
// exit ;
54477: GO 54529
// if size then
54479: LD_VAR 0 2
54483: IFFALSE 54529
// for i := array downto size do
54485: LD_ADDR_VAR 0 4
54489: PUSH
54490: DOUBLE
54491: LD_VAR 0 1
54495: INC
54496: ST_TO_ADDR
54497: LD_VAR 0 2
54501: PUSH
54502: FOR_DOWNTO
54503: IFFALSE 54527
// result := Delete ( result , result ) ;
54505: LD_ADDR_VAR 0 3
54509: PUSH
54510: LD_VAR 0 3
54514: PPUSH
54515: LD_VAR 0 3
54519: PPUSH
54520: CALL_OW 3
54524: ST_TO_ADDR
54525: GO 54502
54527: POP
54528: POP
// end ;
54529: LD_VAR 0 3
54533: RET
// export function ComExit ( unit ) ; var tmp ; begin
54534: LD_INT 0
54536: PPUSH
54537: PPUSH
// if not IsInUnit ( unit ) then
54538: LD_VAR 0 1
54542: PPUSH
54543: CALL_OW 310
54547: NOT
54548: IFFALSE 54552
// exit ;
54550: GO 54612
// tmp := IsInUnit ( unit ) ;
54552: LD_ADDR_VAR 0 3
54556: PUSH
54557: LD_VAR 0 1
54561: PPUSH
54562: CALL_OW 310
54566: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54567: LD_VAR 0 3
54571: PPUSH
54572: CALL_OW 247
54576: PUSH
54577: LD_INT 2
54579: EQUAL
54580: IFFALSE 54593
// ComExitVehicle ( unit ) else
54582: LD_VAR 0 1
54586: PPUSH
54587: CALL_OW 121
54591: GO 54602
// ComExitBuilding ( unit ) ;
54593: LD_VAR 0 1
54597: PPUSH
54598: CALL_OW 122
// result := tmp ;
54602: LD_ADDR_VAR 0 2
54606: PUSH
54607: LD_VAR 0 3
54611: ST_TO_ADDR
// end ;
54612: LD_VAR 0 2
54616: RET
// export function ComExitAll ( units ) ; var i ; begin
54617: LD_INT 0
54619: PPUSH
54620: PPUSH
// if not units then
54621: LD_VAR 0 1
54625: NOT
54626: IFFALSE 54630
// exit ;
54628: GO 54656
// for i in units do
54630: LD_ADDR_VAR 0 3
54634: PUSH
54635: LD_VAR 0 1
54639: PUSH
54640: FOR_IN
54641: IFFALSE 54654
// ComExit ( i ) ;
54643: LD_VAR 0 3
54647: PPUSH
54648: CALL 54534 0 1
54652: GO 54640
54654: POP
54655: POP
// end ;
54656: LD_VAR 0 2
54660: RET
// export function ResetHc ; begin
54661: LD_INT 0
54663: PPUSH
// InitHc ;
54664: CALL_OW 19
// hc_importance := 0 ;
54668: LD_ADDR_OWVAR 32
54672: PUSH
54673: LD_INT 0
54675: ST_TO_ADDR
// end ;
54676: LD_VAR 0 1
54680: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54681: LD_INT 0
54683: PPUSH
54684: PPUSH
54685: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54686: LD_ADDR_VAR 0 6
54690: PUSH
54691: LD_VAR 0 1
54695: PUSH
54696: LD_VAR 0 3
54700: PLUS
54701: PUSH
54702: LD_INT 2
54704: DIV
54705: ST_TO_ADDR
// if _x < 0 then
54706: LD_VAR 0 6
54710: PUSH
54711: LD_INT 0
54713: LESS
54714: IFFALSE 54731
// _x := _x * - 1 ;
54716: LD_ADDR_VAR 0 6
54720: PUSH
54721: LD_VAR 0 6
54725: PUSH
54726: LD_INT 1
54728: NEG
54729: MUL
54730: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54731: LD_ADDR_VAR 0 7
54735: PUSH
54736: LD_VAR 0 2
54740: PUSH
54741: LD_VAR 0 4
54745: PLUS
54746: PUSH
54747: LD_INT 2
54749: DIV
54750: ST_TO_ADDR
// if _y < 0 then
54751: LD_VAR 0 7
54755: PUSH
54756: LD_INT 0
54758: LESS
54759: IFFALSE 54776
// _y := _y * - 1 ;
54761: LD_ADDR_VAR 0 7
54765: PUSH
54766: LD_VAR 0 7
54770: PUSH
54771: LD_INT 1
54773: NEG
54774: MUL
54775: ST_TO_ADDR
// result := [ _x , _y ] ;
54776: LD_ADDR_VAR 0 5
54780: PUSH
54781: LD_VAR 0 6
54785: PUSH
54786: LD_VAR 0 7
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: ST_TO_ADDR
// end ;
54795: LD_VAR 0 5
54799: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54800: LD_INT 0
54802: PPUSH
54803: PPUSH
54804: PPUSH
54805: PPUSH
// task := GetTaskList ( unit ) ;
54806: LD_ADDR_VAR 0 7
54810: PUSH
54811: LD_VAR 0 1
54815: PPUSH
54816: CALL_OW 437
54820: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54821: LD_VAR 0 7
54825: NOT
54826: PUSH
54827: LD_VAR 0 1
54831: PPUSH
54832: LD_VAR 0 2
54836: PPUSH
54837: CALL_OW 308
54841: NOT
54842: AND
54843: IFFALSE 54847
// exit ;
54845: GO 54965
// if IsInArea ( unit , area ) then
54847: LD_VAR 0 1
54851: PPUSH
54852: LD_VAR 0 2
54856: PPUSH
54857: CALL_OW 308
54861: IFFALSE 54879
// begin ComMoveToArea ( unit , goAway ) ;
54863: LD_VAR 0 1
54867: PPUSH
54868: LD_VAR 0 3
54872: PPUSH
54873: CALL_OW 113
// exit ;
54877: GO 54965
// end ; if task [ 1 ] [ 1 ] <> M then
54879: LD_VAR 0 7
54883: PUSH
54884: LD_INT 1
54886: ARRAY
54887: PUSH
54888: LD_INT 1
54890: ARRAY
54891: PUSH
54892: LD_STRING M
54894: NONEQUAL
54895: IFFALSE 54899
// exit ;
54897: GO 54965
// x := task [ 1 ] [ 2 ] ;
54899: LD_ADDR_VAR 0 5
54903: PUSH
54904: LD_VAR 0 7
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: PUSH
54913: LD_INT 2
54915: ARRAY
54916: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54917: LD_ADDR_VAR 0 6
54921: PUSH
54922: LD_VAR 0 7
54926: PUSH
54927: LD_INT 1
54929: ARRAY
54930: PUSH
54931: LD_INT 3
54933: ARRAY
54934: ST_TO_ADDR
// if InArea ( x , y , area ) then
54935: LD_VAR 0 5
54939: PPUSH
54940: LD_VAR 0 6
54944: PPUSH
54945: LD_VAR 0 2
54949: PPUSH
54950: CALL_OW 309
54954: IFFALSE 54965
// ComStop ( unit ) ;
54956: LD_VAR 0 1
54960: PPUSH
54961: CALL_OW 141
// end ;
54965: LD_VAR 0 4
54969: RET
// export function Abs ( value ) ; begin
54970: LD_INT 0
54972: PPUSH
// result := value ;
54973: LD_ADDR_VAR 0 2
54977: PUSH
54978: LD_VAR 0 1
54982: ST_TO_ADDR
// if value < 0 then
54983: LD_VAR 0 1
54987: PUSH
54988: LD_INT 0
54990: LESS
54991: IFFALSE 55008
// result := value * - 1 ;
54993: LD_ADDR_VAR 0 2
54997: PUSH
54998: LD_VAR 0 1
55002: PUSH
55003: LD_INT 1
55005: NEG
55006: MUL
55007: ST_TO_ADDR
// end ;
55008: LD_VAR 0 2
55012: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55013: LD_INT 0
55015: PPUSH
55016: PPUSH
55017: PPUSH
55018: PPUSH
55019: PPUSH
55020: PPUSH
55021: PPUSH
55022: PPUSH
// if not unit or not building then
55023: LD_VAR 0 1
55027: NOT
55028: PUSH
55029: LD_VAR 0 2
55033: NOT
55034: OR
55035: IFFALSE 55039
// exit ;
55037: GO 55265
// x := GetX ( building ) ;
55039: LD_ADDR_VAR 0 4
55043: PUSH
55044: LD_VAR 0 2
55048: PPUSH
55049: CALL_OW 250
55053: ST_TO_ADDR
// y := GetY ( building ) ;
55054: LD_ADDR_VAR 0 6
55058: PUSH
55059: LD_VAR 0 2
55063: PPUSH
55064: CALL_OW 251
55068: ST_TO_ADDR
// d := GetDir ( building ) ;
55069: LD_ADDR_VAR 0 8
55073: PUSH
55074: LD_VAR 0 2
55078: PPUSH
55079: CALL_OW 254
55083: ST_TO_ADDR
// r := 4 ;
55084: LD_ADDR_VAR 0 9
55088: PUSH
55089: LD_INT 4
55091: ST_TO_ADDR
// for i := 1 to 5 do
55092: LD_ADDR_VAR 0 10
55096: PUSH
55097: DOUBLE
55098: LD_INT 1
55100: DEC
55101: ST_TO_ADDR
55102: LD_INT 5
55104: PUSH
55105: FOR_TO
55106: IFFALSE 55263
// begin _x := ShiftX ( x , d , r + i ) ;
55108: LD_ADDR_VAR 0 5
55112: PUSH
55113: LD_VAR 0 4
55117: PPUSH
55118: LD_VAR 0 8
55122: PPUSH
55123: LD_VAR 0 9
55127: PUSH
55128: LD_VAR 0 10
55132: PLUS
55133: PPUSH
55134: CALL_OW 272
55138: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
55139: LD_ADDR_VAR 0 7
55143: PUSH
55144: LD_VAR 0 6
55148: PPUSH
55149: LD_VAR 0 8
55153: PPUSH
55154: LD_VAR 0 9
55158: PUSH
55159: LD_VAR 0 10
55163: PLUS
55164: PPUSH
55165: CALL_OW 273
55169: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
55170: LD_VAR 0 5
55174: PPUSH
55175: LD_VAR 0 7
55179: PPUSH
55180: CALL_OW 488
55184: PUSH
55185: LD_VAR 0 5
55189: PPUSH
55190: LD_VAR 0 7
55194: PPUSH
55195: CALL_OW 428
55199: PPUSH
55200: CALL_OW 247
55204: PUSH
55205: LD_INT 3
55207: PUSH
55208: LD_INT 2
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: IN
55215: NOT
55216: AND
55217: IFFALSE 55261
// begin ComMoveXY ( unit , _x , _y ) ;
55219: LD_VAR 0 1
55223: PPUSH
55224: LD_VAR 0 5
55228: PPUSH
55229: LD_VAR 0 7
55233: PPUSH
55234: CALL_OW 111
// result := [ _x , _y ] ;
55238: LD_ADDR_VAR 0 3
55242: PUSH
55243: LD_VAR 0 5
55247: PUSH
55248: LD_VAR 0 7
55252: PUSH
55253: EMPTY
55254: LIST
55255: LIST
55256: ST_TO_ADDR
// exit ;
55257: POP
55258: POP
55259: GO 55265
// end ; end ;
55261: GO 55105
55263: POP
55264: POP
// end ;
55265: LD_VAR 0 3
55269: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
55270: LD_INT 0
55272: PPUSH
55273: PPUSH
55274: PPUSH
// result := 0 ;
55275: LD_ADDR_VAR 0 3
55279: PUSH
55280: LD_INT 0
55282: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
55283: LD_VAR 0 1
55287: PUSH
55288: LD_INT 0
55290: LESS
55291: PUSH
55292: LD_VAR 0 1
55296: PUSH
55297: LD_INT 8
55299: GREATER
55300: OR
55301: PUSH
55302: LD_VAR 0 2
55306: PUSH
55307: LD_INT 0
55309: LESS
55310: OR
55311: PUSH
55312: LD_VAR 0 2
55316: PUSH
55317: LD_INT 8
55319: GREATER
55320: OR
55321: IFFALSE 55325
// exit ;
55323: GO 55400
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55325: LD_ADDR_VAR 0 4
55329: PUSH
55330: LD_INT 22
55332: PUSH
55333: LD_VAR 0 2
55337: PUSH
55338: EMPTY
55339: LIST
55340: LIST
55341: PPUSH
55342: CALL_OW 69
55346: PUSH
55347: FOR_IN
55348: IFFALSE 55398
// begin un := UnitShoot ( i ) ;
55350: LD_ADDR_VAR 0 5
55354: PUSH
55355: LD_VAR 0 4
55359: PPUSH
55360: CALL_OW 504
55364: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55365: LD_VAR 0 5
55369: PPUSH
55370: CALL_OW 255
55374: PUSH
55375: LD_VAR 0 1
55379: EQUAL
55380: IFFALSE 55396
// begin result := un ;
55382: LD_ADDR_VAR 0 3
55386: PUSH
55387: LD_VAR 0 5
55391: ST_TO_ADDR
// exit ;
55392: POP
55393: POP
55394: GO 55400
// end ; end ;
55396: GO 55347
55398: POP
55399: POP
// end ;
55400: LD_VAR 0 3
55404: RET
// export function GetCargoBay ( units ) ; begin
55405: LD_INT 0
55407: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55408: LD_ADDR_VAR 0 2
55412: PUSH
55413: LD_VAR 0 1
55417: PPUSH
55418: LD_INT 2
55420: PUSH
55421: LD_INT 34
55423: PUSH
55424: LD_INT 12
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 34
55433: PUSH
55434: LD_INT 51
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: LD_INT 34
55443: PUSH
55444: LD_INT 32
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PUSH
55451: LD_INT 34
55453: PUSH
55454: LD_INT 89
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: LIST
55466: LIST
55467: PPUSH
55468: CALL_OW 72
55472: ST_TO_ADDR
// end ;
55473: LD_VAR 0 2
55477: RET
// export function Negate ( value ) ; begin
55478: LD_INT 0
55480: PPUSH
// result := not value ;
55481: LD_ADDR_VAR 0 2
55485: PUSH
55486: LD_VAR 0 1
55490: NOT
55491: ST_TO_ADDR
// end ;
55492: LD_VAR 0 2
55496: RET
// export function Inc ( value ) ; begin
55497: LD_INT 0
55499: PPUSH
// result := value + 1 ;
55500: LD_ADDR_VAR 0 2
55504: PUSH
55505: LD_VAR 0 1
55509: PUSH
55510: LD_INT 1
55512: PLUS
55513: ST_TO_ADDR
// end ;
55514: LD_VAR 0 2
55518: RET
// export function Dec ( value ) ; begin
55519: LD_INT 0
55521: PPUSH
// result := value - 1 ;
55522: LD_ADDR_VAR 0 2
55526: PUSH
55527: LD_VAR 0 1
55531: PUSH
55532: LD_INT 1
55534: MINUS
55535: ST_TO_ADDR
// end ;
55536: LD_VAR 0 2
55540: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55541: LD_INT 0
55543: PPUSH
55544: PPUSH
55545: PPUSH
55546: PPUSH
55547: PPUSH
55548: PPUSH
55549: PPUSH
55550: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55551: LD_VAR 0 1
55555: PPUSH
55556: LD_VAR 0 2
55560: PPUSH
55561: CALL_OW 488
55565: NOT
55566: PUSH
55567: LD_VAR 0 3
55571: PPUSH
55572: LD_VAR 0 4
55576: PPUSH
55577: CALL_OW 488
55581: NOT
55582: OR
55583: IFFALSE 55596
// begin result := - 1 ;
55585: LD_ADDR_VAR 0 5
55589: PUSH
55590: LD_INT 1
55592: NEG
55593: ST_TO_ADDR
// exit ;
55594: GO 55831
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55596: LD_ADDR_VAR 0 12
55600: PUSH
55601: LD_VAR 0 1
55605: PPUSH
55606: LD_VAR 0 2
55610: PPUSH
55611: LD_VAR 0 3
55615: PPUSH
55616: LD_VAR 0 4
55620: PPUSH
55621: CALL 54681 0 4
55625: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55626: LD_ADDR_VAR 0 11
55630: PUSH
55631: LD_VAR 0 1
55635: PPUSH
55636: LD_VAR 0 2
55640: PPUSH
55641: LD_VAR 0 12
55645: PUSH
55646: LD_INT 1
55648: ARRAY
55649: PPUSH
55650: LD_VAR 0 12
55654: PUSH
55655: LD_INT 2
55657: ARRAY
55658: PPUSH
55659: CALL_OW 298
55663: ST_TO_ADDR
// distance := 9999 ;
55664: LD_ADDR_VAR 0 10
55668: PUSH
55669: LD_INT 9999
55671: ST_TO_ADDR
// for i := 0 to 5 do
55672: LD_ADDR_VAR 0 6
55676: PUSH
55677: DOUBLE
55678: LD_INT 0
55680: DEC
55681: ST_TO_ADDR
55682: LD_INT 5
55684: PUSH
55685: FOR_TO
55686: IFFALSE 55829
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55688: LD_ADDR_VAR 0 7
55692: PUSH
55693: LD_VAR 0 1
55697: PPUSH
55698: LD_VAR 0 6
55702: PPUSH
55703: LD_VAR 0 11
55707: PPUSH
55708: CALL_OW 272
55712: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55713: LD_ADDR_VAR 0 8
55717: PUSH
55718: LD_VAR 0 2
55722: PPUSH
55723: LD_VAR 0 6
55727: PPUSH
55728: LD_VAR 0 11
55732: PPUSH
55733: CALL_OW 273
55737: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55738: LD_VAR 0 7
55742: PPUSH
55743: LD_VAR 0 8
55747: PPUSH
55748: CALL_OW 488
55752: NOT
55753: IFFALSE 55757
// continue ;
55755: GO 55685
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55757: LD_ADDR_VAR 0 9
55761: PUSH
55762: LD_VAR 0 12
55766: PUSH
55767: LD_INT 1
55769: ARRAY
55770: PPUSH
55771: LD_VAR 0 12
55775: PUSH
55776: LD_INT 2
55778: ARRAY
55779: PPUSH
55780: LD_VAR 0 7
55784: PPUSH
55785: LD_VAR 0 8
55789: PPUSH
55790: CALL_OW 298
55794: ST_TO_ADDR
// if tmp < distance then
55795: LD_VAR 0 9
55799: PUSH
55800: LD_VAR 0 10
55804: LESS
55805: IFFALSE 55827
// begin result := i ;
55807: LD_ADDR_VAR 0 5
55811: PUSH
55812: LD_VAR 0 6
55816: ST_TO_ADDR
// distance := tmp ;
55817: LD_ADDR_VAR 0 10
55821: PUSH
55822: LD_VAR 0 9
55826: ST_TO_ADDR
// end ; end ;
55827: GO 55685
55829: POP
55830: POP
// end ;
55831: LD_VAR 0 5
55835: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55836: LD_INT 0
55838: PPUSH
55839: PPUSH
// if not driver or not IsInUnit ( driver ) then
55840: LD_VAR 0 1
55844: NOT
55845: PUSH
55846: LD_VAR 0 1
55850: PPUSH
55851: CALL_OW 310
55855: NOT
55856: OR
55857: IFFALSE 55861
// exit ;
55859: GO 55951
// vehicle := IsInUnit ( driver ) ;
55861: LD_ADDR_VAR 0 3
55865: PUSH
55866: LD_VAR 0 1
55870: PPUSH
55871: CALL_OW 310
55875: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55876: LD_VAR 0 1
55880: PPUSH
55881: LD_STRING \
55883: PUSH
55884: LD_INT 0
55886: PUSH
55887: LD_INT 0
55889: PUSH
55890: LD_INT 0
55892: PUSH
55893: LD_INT 0
55895: PUSH
55896: LD_INT 0
55898: PUSH
55899: LD_INT 0
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: LIST
55908: LIST
55909: LIST
55910: PUSH
55911: LD_STRING E
55913: PUSH
55914: LD_INT 0
55916: PUSH
55917: LD_INT 0
55919: PUSH
55920: LD_VAR 0 3
55924: PUSH
55925: LD_INT 0
55927: PUSH
55928: LD_INT 0
55930: PUSH
55931: LD_INT 0
55933: PUSH
55934: EMPTY
55935: LIST
55936: LIST
55937: LIST
55938: LIST
55939: LIST
55940: LIST
55941: LIST
55942: PUSH
55943: EMPTY
55944: LIST
55945: LIST
55946: PPUSH
55947: CALL_OW 446
// end ;
55951: LD_VAR 0 2
55955: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55956: LD_INT 0
55958: PPUSH
55959: PPUSH
// if not driver or not IsInUnit ( driver ) then
55960: LD_VAR 0 1
55964: NOT
55965: PUSH
55966: LD_VAR 0 1
55970: PPUSH
55971: CALL_OW 310
55975: NOT
55976: OR
55977: IFFALSE 55981
// exit ;
55979: GO 56071
// vehicle := IsInUnit ( driver ) ;
55981: LD_ADDR_VAR 0 3
55985: PUSH
55986: LD_VAR 0 1
55990: PPUSH
55991: CALL_OW 310
55995: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55996: LD_VAR 0 1
56000: PPUSH
56001: LD_STRING \
56003: PUSH
56004: LD_INT 0
56006: PUSH
56007: LD_INT 0
56009: PUSH
56010: LD_INT 0
56012: PUSH
56013: LD_INT 0
56015: PUSH
56016: LD_INT 0
56018: PUSH
56019: LD_INT 0
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: LIST
56026: LIST
56027: LIST
56028: LIST
56029: LIST
56030: PUSH
56031: LD_STRING E
56033: PUSH
56034: LD_INT 0
56036: PUSH
56037: LD_INT 0
56039: PUSH
56040: LD_VAR 0 3
56044: PUSH
56045: LD_INT 0
56047: PUSH
56048: LD_INT 0
56050: PUSH
56051: LD_INT 0
56053: PUSH
56054: EMPTY
56055: LIST
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: PUSH
56063: EMPTY
56064: LIST
56065: LIST
56066: PPUSH
56067: CALL_OW 447
// end ;
56071: LD_VAR 0 2
56075: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56076: LD_INT 0
56078: PPUSH
56079: PPUSH
56080: PPUSH
// tmp := [ ] ;
56081: LD_ADDR_VAR 0 5
56085: PUSH
56086: EMPTY
56087: ST_TO_ADDR
// for i in units do
56088: LD_ADDR_VAR 0 4
56092: PUSH
56093: LD_VAR 0 1
56097: PUSH
56098: FOR_IN
56099: IFFALSE 56137
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56101: LD_ADDR_VAR 0 5
56105: PUSH
56106: LD_VAR 0 5
56110: PPUSH
56111: LD_VAR 0 5
56115: PUSH
56116: LD_INT 1
56118: PLUS
56119: PPUSH
56120: LD_VAR 0 4
56124: PPUSH
56125: CALL_OW 256
56129: PPUSH
56130: CALL_OW 2
56134: ST_TO_ADDR
56135: GO 56098
56137: POP
56138: POP
// if not tmp then
56139: LD_VAR 0 5
56143: NOT
56144: IFFALSE 56148
// exit ;
56146: GO 56196
// if asc then
56148: LD_VAR 0 2
56152: IFFALSE 56176
// result := SortListByListAsc ( units , tmp ) else
56154: LD_ADDR_VAR 0 3
56158: PUSH
56159: LD_VAR 0 1
56163: PPUSH
56164: LD_VAR 0 5
56168: PPUSH
56169: CALL_OW 76
56173: ST_TO_ADDR
56174: GO 56196
// result := SortListByListDesc ( units , tmp ) ;
56176: LD_ADDR_VAR 0 3
56180: PUSH
56181: LD_VAR 0 1
56185: PPUSH
56186: LD_VAR 0 5
56190: PPUSH
56191: CALL_OW 77
56195: ST_TO_ADDR
// end ;
56196: LD_VAR 0 3
56200: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
56201: LD_INT 0
56203: PPUSH
56204: PPUSH
// task := GetTaskList ( mech ) ;
56205: LD_ADDR_VAR 0 4
56209: PUSH
56210: LD_VAR 0 1
56214: PPUSH
56215: CALL_OW 437
56219: ST_TO_ADDR
// if not task then
56220: LD_VAR 0 4
56224: NOT
56225: IFFALSE 56229
// exit ;
56227: GO 56271
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
56229: LD_ADDR_VAR 0 3
56233: PUSH
56234: LD_VAR 0 4
56238: PUSH
56239: LD_INT 1
56241: ARRAY
56242: PUSH
56243: LD_INT 1
56245: ARRAY
56246: PUSH
56247: LD_STRING r
56249: EQUAL
56250: PUSH
56251: LD_VAR 0 4
56255: PUSH
56256: LD_INT 1
56258: ARRAY
56259: PUSH
56260: LD_INT 4
56262: ARRAY
56263: PUSH
56264: LD_VAR 0 2
56268: EQUAL
56269: AND
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 3
56275: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
56276: LD_INT 0
56278: PPUSH
// SetDir ( unit , d ) ;
56279: LD_VAR 0 1
56283: PPUSH
56284: LD_VAR 0 4
56288: PPUSH
56289: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
56293: LD_VAR 0 1
56297: PPUSH
56298: LD_VAR 0 2
56302: PPUSH
56303: LD_VAR 0 3
56307: PPUSH
56308: LD_VAR 0 5
56312: PPUSH
56313: CALL_OW 48
// end ;
56317: LD_VAR 0 6
56321: RET
// export function ToNaturalNumber ( number ) ; begin
56322: LD_INT 0
56324: PPUSH
// result := number div 1 ;
56325: LD_ADDR_VAR 0 2
56329: PUSH
56330: LD_VAR 0 1
56334: PUSH
56335: LD_INT 1
56337: DIV
56338: ST_TO_ADDR
// if number < 0 then
56339: LD_VAR 0 1
56343: PUSH
56344: LD_INT 0
56346: LESS
56347: IFFALSE 56357
// result := 0 ;
56349: LD_ADDR_VAR 0 2
56353: PUSH
56354: LD_INT 0
56356: ST_TO_ADDR
// end ;
56357: LD_VAR 0 2
56361: RET
// export function SortByClass ( units , class ) ; var un ; begin
56362: LD_INT 0
56364: PPUSH
56365: PPUSH
// if not units or not class then
56366: LD_VAR 0 1
56370: NOT
56371: PUSH
56372: LD_VAR 0 2
56376: NOT
56377: OR
56378: IFFALSE 56382
// exit ;
56380: GO 56477
// result := [ ] ;
56382: LD_ADDR_VAR 0 3
56386: PUSH
56387: EMPTY
56388: ST_TO_ADDR
// for un in units do
56389: LD_ADDR_VAR 0 4
56393: PUSH
56394: LD_VAR 0 1
56398: PUSH
56399: FOR_IN
56400: IFFALSE 56475
// if GetClass ( un ) = class then
56402: LD_VAR 0 4
56406: PPUSH
56407: CALL_OW 257
56411: PUSH
56412: LD_VAR 0 2
56416: EQUAL
56417: IFFALSE 56444
// result := Insert ( result , 1 , un ) else
56419: LD_ADDR_VAR 0 3
56423: PUSH
56424: LD_VAR 0 3
56428: PPUSH
56429: LD_INT 1
56431: PPUSH
56432: LD_VAR 0 4
56436: PPUSH
56437: CALL_OW 2
56441: ST_TO_ADDR
56442: GO 56473
// result := Replace ( result , result + 1 , un ) ;
56444: LD_ADDR_VAR 0 3
56448: PUSH
56449: LD_VAR 0 3
56453: PPUSH
56454: LD_VAR 0 3
56458: PUSH
56459: LD_INT 1
56461: PLUS
56462: PPUSH
56463: LD_VAR 0 4
56467: PPUSH
56468: CALL_OW 1
56472: ST_TO_ADDR
56473: GO 56399
56475: POP
56476: POP
// end ;
56477: LD_VAR 0 3
56481: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56482: LD_INT 0
56484: PPUSH
56485: PPUSH
56486: PPUSH
56487: PPUSH
56488: PPUSH
56489: PPUSH
56490: PPUSH
// result := [ ] ;
56491: LD_ADDR_VAR 0 4
56495: PUSH
56496: EMPTY
56497: ST_TO_ADDR
// if x - r < 0 then
56498: LD_VAR 0 1
56502: PUSH
56503: LD_VAR 0 3
56507: MINUS
56508: PUSH
56509: LD_INT 0
56511: LESS
56512: IFFALSE 56524
// min_x := 0 else
56514: LD_ADDR_VAR 0 8
56518: PUSH
56519: LD_INT 0
56521: ST_TO_ADDR
56522: GO 56540
// min_x := x - r ;
56524: LD_ADDR_VAR 0 8
56528: PUSH
56529: LD_VAR 0 1
56533: PUSH
56534: LD_VAR 0 3
56538: MINUS
56539: ST_TO_ADDR
// if y - r < 0 then
56540: LD_VAR 0 2
56544: PUSH
56545: LD_VAR 0 3
56549: MINUS
56550: PUSH
56551: LD_INT 0
56553: LESS
56554: IFFALSE 56566
// min_y := 0 else
56556: LD_ADDR_VAR 0 7
56560: PUSH
56561: LD_INT 0
56563: ST_TO_ADDR
56564: GO 56582
// min_y := y - r ;
56566: LD_ADDR_VAR 0 7
56570: PUSH
56571: LD_VAR 0 2
56575: PUSH
56576: LD_VAR 0 3
56580: MINUS
56581: ST_TO_ADDR
// max_x := x + r ;
56582: LD_ADDR_VAR 0 9
56586: PUSH
56587: LD_VAR 0 1
56591: PUSH
56592: LD_VAR 0 3
56596: PLUS
56597: ST_TO_ADDR
// max_y := y + r ;
56598: LD_ADDR_VAR 0 10
56602: PUSH
56603: LD_VAR 0 2
56607: PUSH
56608: LD_VAR 0 3
56612: PLUS
56613: ST_TO_ADDR
// for _x = min_x to max_x do
56614: LD_ADDR_VAR 0 5
56618: PUSH
56619: DOUBLE
56620: LD_VAR 0 8
56624: DEC
56625: ST_TO_ADDR
56626: LD_VAR 0 9
56630: PUSH
56631: FOR_TO
56632: IFFALSE 56733
// for _y = min_y to max_y do
56634: LD_ADDR_VAR 0 6
56638: PUSH
56639: DOUBLE
56640: LD_VAR 0 7
56644: DEC
56645: ST_TO_ADDR
56646: LD_VAR 0 10
56650: PUSH
56651: FOR_TO
56652: IFFALSE 56729
// begin if not ValidHex ( _x , _y ) then
56654: LD_VAR 0 5
56658: PPUSH
56659: LD_VAR 0 6
56663: PPUSH
56664: CALL_OW 488
56668: NOT
56669: IFFALSE 56673
// continue ;
56671: GO 56651
// if GetResourceTypeXY ( _x , _y ) then
56673: LD_VAR 0 5
56677: PPUSH
56678: LD_VAR 0 6
56682: PPUSH
56683: CALL_OW 283
56687: IFFALSE 56727
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56689: LD_ADDR_VAR 0 4
56693: PUSH
56694: LD_VAR 0 4
56698: PPUSH
56699: LD_VAR 0 4
56703: PUSH
56704: LD_INT 1
56706: PLUS
56707: PPUSH
56708: LD_VAR 0 5
56712: PUSH
56713: LD_VAR 0 6
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: PPUSH
56722: CALL_OW 1
56726: ST_TO_ADDR
// end ;
56727: GO 56651
56729: POP
56730: POP
56731: GO 56631
56733: POP
56734: POP
// end ;
56735: LD_VAR 0 4
56739: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56740: LD_INT 0
56742: PPUSH
56743: PPUSH
56744: PPUSH
56745: PPUSH
56746: PPUSH
56747: PPUSH
56748: PPUSH
56749: PPUSH
// if not units then
56750: LD_VAR 0 1
56754: NOT
56755: IFFALSE 56759
// exit ;
56757: GO 57283
// result := UnitFilter ( units , [ f_ok ] ) ;
56759: LD_ADDR_VAR 0 3
56763: PUSH
56764: LD_VAR 0 1
56768: PPUSH
56769: LD_INT 50
56771: PUSH
56772: EMPTY
56773: LIST
56774: PPUSH
56775: CALL_OW 72
56779: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56780: LD_ADDR_VAR 0 8
56784: PUSH
56785: LD_VAR 0 1
56789: PUSH
56790: LD_INT 1
56792: ARRAY
56793: PPUSH
56794: CALL_OW 255
56798: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56799: LD_ADDR_VAR 0 10
56803: PUSH
56804: LD_INT 29
56806: PUSH
56807: LD_INT 91
56809: PUSH
56810: LD_INT 49
56812: PUSH
56813: EMPTY
56814: LIST
56815: LIST
56816: LIST
56817: ST_TO_ADDR
// if not result then
56818: LD_VAR 0 3
56822: NOT
56823: IFFALSE 56827
// exit ;
56825: GO 57283
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56827: LD_ADDR_VAR 0 5
56831: PUSH
56832: LD_INT 81
56834: PUSH
56835: LD_VAR 0 8
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PPUSH
56844: CALL_OW 69
56848: ST_TO_ADDR
// for i in result do
56849: LD_ADDR_VAR 0 4
56853: PUSH
56854: LD_VAR 0 3
56858: PUSH
56859: FOR_IN
56860: IFFALSE 57281
// begin tag := GetTag ( i ) + 1 ;
56862: LD_ADDR_VAR 0 9
56866: PUSH
56867: LD_VAR 0 4
56871: PPUSH
56872: CALL_OW 110
56876: PUSH
56877: LD_INT 1
56879: PLUS
56880: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
56881: LD_ADDR_VAR 0 7
56885: PUSH
56886: LD_VAR 0 4
56890: PPUSH
56891: CALL_OW 250
56895: PPUSH
56896: LD_VAR 0 4
56900: PPUSH
56901: CALL_OW 251
56905: PPUSH
56906: LD_INT 6
56908: PPUSH
56909: CALL 56482 0 3
56913: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
56914: LD_VAR 0 4
56918: PPUSH
56919: CALL_OW 247
56923: PUSH
56924: LD_INT 2
56926: EQUAL
56927: PUSH
56928: LD_VAR 0 7
56932: AND
56933: PUSH
56934: LD_VAR 0 4
56938: PPUSH
56939: CALL_OW 264
56943: PUSH
56944: LD_VAR 0 10
56948: IN
56949: NOT
56950: AND
56951: IFFALSE 56990
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56953: LD_VAR 0 4
56957: PPUSH
56958: LD_VAR 0 7
56962: PUSH
56963: LD_INT 1
56965: ARRAY
56966: PUSH
56967: LD_INT 1
56969: ARRAY
56970: PPUSH
56971: LD_VAR 0 7
56975: PUSH
56976: LD_INT 1
56978: ARRAY
56979: PUSH
56980: LD_INT 2
56982: ARRAY
56983: PPUSH
56984: CALL_OW 116
56988: GO 57279
// if path > tag then
56990: LD_VAR 0 2
56994: PUSH
56995: LD_VAR 0 9
56999: GREATER
57000: IFFALSE 57208
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57002: LD_ADDR_VAR 0 6
57006: PUSH
57007: LD_VAR 0 5
57011: PPUSH
57012: LD_INT 91
57014: PUSH
57015: LD_VAR 0 4
57019: PUSH
57020: LD_INT 8
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: LIST
57027: PPUSH
57028: CALL_OW 72
57032: ST_TO_ADDR
// if nearEnemy then
57033: LD_VAR 0 6
57037: IFFALSE 57106
// begin if GetWeapon ( i ) = ru_time_lapser then
57039: LD_VAR 0 4
57043: PPUSH
57044: CALL_OW 264
57048: PUSH
57049: LD_INT 49
57051: EQUAL
57052: IFFALSE 57080
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57054: LD_VAR 0 4
57058: PPUSH
57059: LD_VAR 0 6
57063: PPUSH
57064: LD_VAR 0 4
57068: PPUSH
57069: CALL_OW 74
57073: PPUSH
57074: CALL_OW 112
57078: GO 57104
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57080: LD_VAR 0 4
57084: PPUSH
57085: LD_VAR 0 6
57089: PPUSH
57090: LD_VAR 0 4
57094: PPUSH
57095: CALL_OW 74
57099: PPUSH
57100: CALL 58354 0 2
// end else
57104: GO 57206
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57106: LD_VAR 0 4
57110: PPUSH
57111: LD_VAR 0 2
57115: PUSH
57116: LD_VAR 0 9
57120: ARRAY
57121: PUSH
57122: LD_INT 1
57124: ARRAY
57125: PPUSH
57126: LD_VAR 0 2
57130: PUSH
57131: LD_VAR 0 9
57135: ARRAY
57136: PUSH
57137: LD_INT 2
57139: ARRAY
57140: PPUSH
57141: CALL_OW 297
57145: PUSH
57146: LD_INT 6
57148: GREATER
57149: IFFALSE 57192
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
57151: LD_VAR 0 4
57155: PPUSH
57156: LD_VAR 0 2
57160: PUSH
57161: LD_VAR 0 9
57165: ARRAY
57166: PUSH
57167: LD_INT 1
57169: ARRAY
57170: PPUSH
57171: LD_VAR 0 2
57175: PUSH
57176: LD_VAR 0 9
57180: ARRAY
57181: PUSH
57182: LD_INT 2
57184: ARRAY
57185: PPUSH
57186: CALL_OW 114
57190: GO 57206
// SetTag ( i , tag ) ;
57192: LD_VAR 0 4
57196: PPUSH
57197: LD_VAR 0 9
57201: PPUSH
57202: CALL_OW 109
// end else
57206: GO 57279
// if enemy then
57208: LD_VAR 0 5
57212: IFFALSE 57279
// begin if GetWeapon ( i ) = ru_time_lapser then
57214: LD_VAR 0 4
57218: PPUSH
57219: CALL_OW 264
57223: PUSH
57224: LD_INT 49
57226: EQUAL
57227: IFFALSE 57255
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
57229: LD_VAR 0 4
57233: PPUSH
57234: LD_VAR 0 5
57238: PPUSH
57239: LD_VAR 0 4
57243: PPUSH
57244: CALL_OW 74
57248: PPUSH
57249: CALL_OW 112
57253: GO 57279
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
57255: LD_VAR 0 4
57259: PPUSH
57260: LD_VAR 0 5
57264: PPUSH
57265: LD_VAR 0 4
57269: PPUSH
57270: CALL_OW 74
57274: PPUSH
57275: CALL 58354 0 2
// end ; end ;
57279: GO 56859
57281: POP
57282: POP
// end ;
57283: LD_VAR 0 3
57287: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
57288: LD_INT 0
57290: PPUSH
57291: PPUSH
57292: PPUSH
// if not unit or IsInUnit ( unit ) then
57293: LD_VAR 0 1
57297: NOT
57298: PUSH
57299: LD_VAR 0 1
57303: PPUSH
57304: CALL_OW 310
57308: OR
57309: IFFALSE 57313
// exit ;
57311: GO 57404
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
57313: LD_ADDR_VAR 0 4
57317: PUSH
57318: LD_VAR 0 1
57322: PPUSH
57323: CALL_OW 250
57327: PPUSH
57328: LD_VAR 0 2
57332: PPUSH
57333: LD_INT 1
57335: PPUSH
57336: CALL_OW 272
57340: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
57341: LD_ADDR_VAR 0 5
57345: PUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: CALL_OW 251
57355: PPUSH
57356: LD_VAR 0 2
57360: PPUSH
57361: LD_INT 1
57363: PPUSH
57364: CALL_OW 273
57368: ST_TO_ADDR
// if ValidHex ( x , y ) then
57369: LD_VAR 0 4
57373: PPUSH
57374: LD_VAR 0 5
57378: PPUSH
57379: CALL_OW 488
57383: IFFALSE 57404
// ComTurnXY ( unit , x , y ) ;
57385: LD_VAR 0 1
57389: PPUSH
57390: LD_VAR 0 4
57394: PPUSH
57395: LD_VAR 0 5
57399: PPUSH
57400: CALL_OW 118
// end ;
57404: LD_VAR 0 3
57408: RET
// export function SeeUnits ( side , units ) ; var i ; begin
57409: LD_INT 0
57411: PPUSH
57412: PPUSH
// result := false ;
57413: LD_ADDR_VAR 0 3
57417: PUSH
57418: LD_INT 0
57420: ST_TO_ADDR
// if not units then
57421: LD_VAR 0 2
57425: NOT
57426: IFFALSE 57430
// exit ;
57428: GO 57475
// for i in units do
57430: LD_ADDR_VAR 0 4
57434: PUSH
57435: LD_VAR 0 2
57439: PUSH
57440: FOR_IN
57441: IFFALSE 57473
// if See ( side , i ) then
57443: LD_VAR 0 1
57447: PPUSH
57448: LD_VAR 0 4
57452: PPUSH
57453: CALL_OW 292
57457: IFFALSE 57471
// begin result := true ;
57459: LD_ADDR_VAR 0 3
57463: PUSH
57464: LD_INT 1
57466: ST_TO_ADDR
// exit ;
57467: POP
57468: POP
57469: GO 57475
// end ;
57471: GO 57440
57473: POP
57474: POP
// end ;
57475: LD_VAR 0 3
57479: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57480: LD_INT 0
57482: PPUSH
57483: PPUSH
57484: PPUSH
57485: PPUSH
// if not unit or not points then
57486: LD_VAR 0 1
57490: NOT
57491: PUSH
57492: LD_VAR 0 2
57496: NOT
57497: OR
57498: IFFALSE 57502
// exit ;
57500: GO 57592
// dist := 99999 ;
57502: LD_ADDR_VAR 0 5
57506: PUSH
57507: LD_INT 99999
57509: ST_TO_ADDR
// for i in points do
57510: LD_ADDR_VAR 0 4
57514: PUSH
57515: LD_VAR 0 2
57519: PUSH
57520: FOR_IN
57521: IFFALSE 57590
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57523: LD_ADDR_VAR 0 6
57527: PUSH
57528: LD_VAR 0 1
57532: PPUSH
57533: LD_VAR 0 4
57537: PUSH
57538: LD_INT 1
57540: ARRAY
57541: PPUSH
57542: LD_VAR 0 4
57546: PUSH
57547: LD_INT 2
57549: ARRAY
57550: PPUSH
57551: CALL_OW 297
57555: ST_TO_ADDR
// if tmpDist < dist then
57556: LD_VAR 0 6
57560: PUSH
57561: LD_VAR 0 5
57565: LESS
57566: IFFALSE 57588
// begin result := i ;
57568: LD_ADDR_VAR 0 3
57572: PUSH
57573: LD_VAR 0 4
57577: ST_TO_ADDR
// dist := tmpDist ;
57578: LD_ADDR_VAR 0 5
57582: PUSH
57583: LD_VAR 0 6
57587: ST_TO_ADDR
// end ; end ;
57588: GO 57520
57590: POP
57591: POP
// end ;
57592: LD_VAR 0 3
57596: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57597: LD_INT 0
57599: PPUSH
// uc_side := side ;
57600: LD_ADDR_OWVAR 20
57604: PUSH
57605: LD_VAR 0 1
57609: ST_TO_ADDR
// uc_nation := 3 ;
57610: LD_ADDR_OWVAR 21
57614: PUSH
57615: LD_INT 3
57617: ST_TO_ADDR
// vc_chassis := 25 ;
57618: LD_ADDR_OWVAR 37
57622: PUSH
57623: LD_INT 25
57625: ST_TO_ADDR
// vc_engine := engine_siberite ;
57626: LD_ADDR_OWVAR 39
57630: PUSH
57631: LD_INT 3
57633: ST_TO_ADDR
// vc_control := control_computer ;
57634: LD_ADDR_OWVAR 38
57638: PUSH
57639: LD_INT 3
57641: ST_TO_ADDR
// vc_weapon := 59 ;
57642: LD_ADDR_OWVAR 40
57646: PUSH
57647: LD_INT 59
57649: ST_TO_ADDR
// result := CreateVehicle ;
57650: LD_ADDR_VAR 0 5
57654: PUSH
57655: CALL_OW 45
57659: ST_TO_ADDR
// SetDir ( result , d ) ;
57660: LD_VAR 0 5
57664: PPUSH
57665: LD_VAR 0 4
57669: PPUSH
57670: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57674: LD_VAR 0 5
57678: PPUSH
57679: LD_VAR 0 2
57683: PPUSH
57684: LD_VAR 0 3
57688: PPUSH
57689: LD_INT 0
57691: PPUSH
57692: CALL_OW 48
// end ;
57696: LD_VAR 0 5
57700: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57701: LD_INT 0
57703: PPUSH
57704: PPUSH
57705: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57706: LD_ADDR_VAR 0 2
57710: PUSH
57711: LD_INT 0
57713: PUSH
57714: LD_INT 0
57716: PUSH
57717: LD_INT 0
57719: PUSH
57720: LD_INT 0
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: LIST
57727: LIST
57728: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57729: LD_VAR 0 1
57733: NOT
57734: PUSH
57735: LD_VAR 0 1
57739: PPUSH
57740: CALL_OW 264
57744: PUSH
57745: LD_INT 12
57747: PUSH
57748: LD_INT 51
57750: PUSH
57751: LD_INT 32
57753: PUSH
57754: LD_INT 89
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: LIST
57761: LIST
57762: IN
57763: NOT
57764: OR
57765: IFFALSE 57769
// exit ;
57767: GO 57867
// for i := 1 to 3 do
57769: LD_ADDR_VAR 0 3
57773: PUSH
57774: DOUBLE
57775: LD_INT 1
57777: DEC
57778: ST_TO_ADDR
57779: LD_INT 3
57781: PUSH
57782: FOR_TO
57783: IFFALSE 57865
// begin tmp := GetCargo ( cargo , i ) ;
57785: LD_ADDR_VAR 0 4
57789: PUSH
57790: LD_VAR 0 1
57794: PPUSH
57795: LD_VAR 0 3
57799: PPUSH
57800: CALL_OW 289
57804: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57805: LD_ADDR_VAR 0 2
57809: PUSH
57810: LD_VAR 0 2
57814: PPUSH
57815: LD_VAR 0 3
57819: PPUSH
57820: LD_VAR 0 4
57824: PPUSH
57825: CALL_OW 1
57829: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57830: LD_ADDR_VAR 0 2
57834: PUSH
57835: LD_VAR 0 2
57839: PPUSH
57840: LD_INT 4
57842: PPUSH
57843: LD_VAR 0 2
57847: PUSH
57848: LD_INT 4
57850: ARRAY
57851: PUSH
57852: LD_VAR 0 4
57856: PLUS
57857: PPUSH
57858: CALL_OW 1
57862: ST_TO_ADDR
// end ;
57863: GO 57782
57865: POP
57866: POP
// end ;
57867: LD_VAR 0 2
57871: RET
// export function Length ( array ) ; begin
57872: LD_INT 0
57874: PPUSH
// result := array + 0 ;
57875: LD_ADDR_VAR 0 2
57879: PUSH
57880: LD_VAR 0 1
57884: PUSH
57885: LD_INT 0
57887: PLUS
57888: ST_TO_ADDR
// end ;
57889: LD_VAR 0 2
57893: RET
// export function PrepareArray ( array ) ; begin
57894: LD_INT 0
57896: PPUSH
// result := array diff 0 ;
57897: LD_ADDR_VAR 0 2
57901: PUSH
57902: LD_VAR 0 1
57906: PUSH
57907: LD_INT 0
57909: DIFF
57910: ST_TO_ADDR
// if not result [ 1 ] then
57911: LD_VAR 0 2
57915: PUSH
57916: LD_INT 1
57918: ARRAY
57919: NOT
57920: IFFALSE 57940
// result := Delete ( result , 1 ) ;
57922: LD_ADDR_VAR 0 2
57926: PUSH
57927: LD_VAR 0 2
57931: PPUSH
57932: LD_INT 1
57934: PPUSH
57935: CALL_OW 3
57939: ST_TO_ADDR
// end ;
57940: LD_VAR 0 2
57944: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57945: LD_INT 0
57947: PPUSH
57948: PPUSH
57949: PPUSH
57950: PPUSH
// sibRocketRange := 25 ;
57951: LD_ADDR_VAR 0 6
57955: PUSH
57956: LD_INT 25
57958: ST_TO_ADDR
// result := false ;
57959: LD_ADDR_VAR 0 4
57963: PUSH
57964: LD_INT 0
57966: ST_TO_ADDR
// for i := 0 to 5 do
57967: LD_ADDR_VAR 0 5
57971: PUSH
57972: DOUBLE
57973: LD_INT 0
57975: DEC
57976: ST_TO_ADDR
57977: LD_INT 5
57979: PUSH
57980: FOR_TO
57981: IFFALSE 58048
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57983: LD_VAR 0 1
57987: PPUSH
57988: LD_VAR 0 5
57992: PPUSH
57993: LD_VAR 0 6
57997: PPUSH
57998: CALL_OW 272
58002: PPUSH
58003: LD_VAR 0 2
58007: PPUSH
58008: LD_VAR 0 5
58012: PPUSH
58013: LD_VAR 0 6
58017: PPUSH
58018: CALL_OW 273
58022: PPUSH
58023: LD_VAR 0 3
58027: PPUSH
58028: CALL_OW 309
58032: IFFALSE 58046
// begin result := true ;
58034: LD_ADDR_VAR 0 4
58038: PUSH
58039: LD_INT 1
58041: ST_TO_ADDR
// exit ;
58042: POP
58043: POP
58044: GO 58050
// end ;
58046: GO 57980
58048: POP
58049: POP
// end ;
58050: LD_VAR 0 4
58054: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58055: LD_INT 0
58057: PPUSH
58058: PPUSH
58059: PPUSH
// if btype = b_depot then
58060: LD_VAR 0 2
58064: PUSH
58065: LD_INT 0
58067: EQUAL
58068: IFFALSE 58080
// begin result := true ;
58070: LD_ADDR_VAR 0 3
58074: PUSH
58075: LD_INT 1
58077: ST_TO_ADDR
// exit ;
58078: GO 58196
// end ; pom := GetBase ( depot ) ;
58080: LD_ADDR_VAR 0 4
58084: PUSH
58085: LD_VAR 0 1
58089: PPUSH
58090: CALL_OW 274
58094: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58095: LD_ADDR_VAR 0 5
58099: PUSH
58100: LD_VAR 0 2
58104: PPUSH
58105: LD_VAR 0 1
58109: PPUSH
58110: CALL_OW 248
58114: PPUSH
58115: CALL_OW 450
58119: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58120: LD_ADDR_VAR 0 3
58124: PUSH
58125: LD_VAR 0 4
58129: PPUSH
58130: LD_INT 1
58132: PPUSH
58133: CALL_OW 275
58137: PUSH
58138: LD_VAR 0 5
58142: PUSH
58143: LD_INT 1
58145: ARRAY
58146: GREATEREQUAL
58147: PUSH
58148: LD_VAR 0 4
58152: PPUSH
58153: LD_INT 2
58155: PPUSH
58156: CALL_OW 275
58160: PUSH
58161: LD_VAR 0 5
58165: PUSH
58166: LD_INT 2
58168: ARRAY
58169: GREATEREQUAL
58170: AND
58171: PUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: LD_INT 3
58179: PPUSH
58180: CALL_OW 275
58184: PUSH
58185: LD_VAR 0 5
58189: PUSH
58190: LD_INT 3
58192: ARRAY
58193: GREATEREQUAL
58194: AND
58195: ST_TO_ADDR
// end ;
58196: LD_VAR 0 3
58200: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
58201: LD_INT 0
58203: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
58204: LD_VAR 0 1
58208: PPUSH
58209: LD_VAR 0 2
58213: PPUSH
58214: LD_INT 0
58216: PPUSH
58217: LD_INT 0
58219: PPUSH
58220: LD_INT 1
58222: PPUSH
58223: LD_INT 0
58225: PPUSH
58226: CALL_OW 587
// end ;
58230: LD_VAR 0 3
58234: RET
// export function CenterOnNow ( unit ) ; begin
58235: LD_INT 0
58237: PPUSH
// result := IsInUnit ( unit ) ;
58238: LD_ADDR_VAR 0 2
58242: PUSH
58243: LD_VAR 0 1
58247: PPUSH
58248: CALL_OW 310
58252: ST_TO_ADDR
// if not result then
58253: LD_VAR 0 2
58257: NOT
58258: IFFALSE 58270
// result := unit ;
58260: LD_ADDR_VAR 0 2
58264: PUSH
58265: LD_VAR 0 1
58269: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
58270: LD_VAR 0 1
58274: PPUSH
58275: CALL_OW 87
// end ;
58279: LD_VAR 0 2
58283: RET
// export function ComMoveHex ( unit , hex ) ; begin
58284: LD_INT 0
58286: PPUSH
// if not hex then
58287: LD_VAR 0 2
58291: NOT
58292: IFFALSE 58296
// exit ;
58294: GO 58349
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
58296: LD_VAR 0 2
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: PPUSH
58305: LD_VAR 0 2
58309: PUSH
58310: LD_INT 2
58312: ARRAY
58313: PPUSH
58314: CALL_OW 428
58318: IFFALSE 58322
// exit ;
58320: GO 58349
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
58322: LD_VAR 0 1
58326: PPUSH
58327: LD_VAR 0 2
58331: PUSH
58332: LD_INT 1
58334: ARRAY
58335: PPUSH
58336: LD_VAR 0 2
58340: PUSH
58341: LD_INT 2
58343: ARRAY
58344: PPUSH
58345: CALL_OW 111
// end ;
58349: LD_VAR 0 3
58353: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
58354: LD_INT 0
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not unit or not enemy then
58359: LD_VAR 0 1
58363: NOT
58364: PUSH
58365: LD_VAR 0 2
58369: NOT
58370: OR
58371: IFFALSE 58375
// exit ;
58373: GO 58499
// x := GetX ( enemy ) ;
58375: LD_ADDR_VAR 0 4
58379: PUSH
58380: LD_VAR 0 2
58384: PPUSH
58385: CALL_OW 250
58389: ST_TO_ADDR
// y := GetY ( enemy ) ;
58390: LD_ADDR_VAR 0 5
58394: PUSH
58395: LD_VAR 0 2
58399: PPUSH
58400: CALL_OW 251
58404: ST_TO_ADDR
// if ValidHex ( x , y ) then
58405: LD_VAR 0 4
58409: PPUSH
58410: LD_VAR 0 5
58414: PPUSH
58415: CALL_OW 488
58419: IFFALSE 58499
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
58421: LD_VAR 0 2
58425: PPUSH
58426: CALL_OW 247
58430: PUSH
58431: LD_INT 3
58433: PUSH
58434: LD_INT 2
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: IN
58441: PUSH
58442: LD_VAR 0 1
58446: PPUSH
58447: CALL_OW 255
58451: PPUSH
58452: LD_VAR 0 2
58456: PPUSH
58457: CALL_OW 292
58461: OR
58462: IFFALSE 58480
// ComAttackUnit ( unit , enemy ) else
58464: LD_VAR 0 1
58468: PPUSH
58469: LD_VAR 0 2
58473: PPUSH
58474: CALL_OW 115
58478: GO 58499
// ComAgressiveMove ( unit , x , y ) ;
58480: LD_VAR 0 1
58484: PPUSH
58485: LD_VAR 0 4
58489: PPUSH
58490: LD_VAR 0 5
58494: PPUSH
58495: CALL_OW 114
// end ;
58499: LD_VAR 0 3
58503: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
58504: LD_INT 0
58506: PPUSH
58507: PPUSH
58508: PPUSH
// list := AreaToList ( area , 0 ) ;
58509: LD_ADDR_VAR 0 5
58513: PUSH
58514: LD_VAR 0 1
58518: PPUSH
58519: LD_INT 0
58521: PPUSH
58522: CALL_OW 517
58526: ST_TO_ADDR
// if not list then
58527: LD_VAR 0 5
58531: NOT
58532: IFFALSE 58536
// exit ;
58534: GO 58666
// if all then
58536: LD_VAR 0 2
58540: IFFALSE 58628
// begin for i := 1 to list [ 1 ] do
58542: LD_ADDR_VAR 0 4
58546: PUSH
58547: DOUBLE
58548: LD_INT 1
58550: DEC
58551: ST_TO_ADDR
58552: LD_VAR 0 5
58556: PUSH
58557: LD_INT 1
58559: ARRAY
58560: PUSH
58561: FOR_TO
58562: IFFALSE 58624
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58564: LD_ADDR_VAR 0 3
58568: PUSH
58569: LD_VAR 0 3
58573: PPUSH
58574: LD_VAR 0 3
58578: PUSH
58579: LD_INT 1
58581: PLUS
58582: PPUSH
58583: LD_VAR 0 5
58587: PUSH
58588: LD_INT 1
58590: ARRAY
58591: PUSH
58592: LD_VAR 0 4
58596: ARRAY
58597: PUSH
58598: LD_VAR 0 5
58602: PUSH
58603: LD_INT 2
58605: ARRAY
58606: PUSH
58607: LD_VAR 0 4
58611: ARRAY
58612: PUSH
58613: EMPTY
58614: LIST
58615: LIST
58616: PPUSH
58617: CALL_OW 1
58621: ST_TO_ADDR
58622: GO 58561
58624: POP
58625: POP
// exit ;
58626: GO 58666
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
58628: LD_ADDR_VAR 0 3
58632: PUSH
58633: LD_VAR 0 5
58637: PUSH
58638: LD_INT 1
58640: ARRAY
58641: PUSH
58642: LD_INT 1
58644: ARRAY
58645: PUSH
58646: LD_VAR 0 5
58650: PUSH
58651: LD_INT 2
58653: ARRAY
58654: PUSH
58655: LD_INT 1
58657: ARRAY
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: PUSH
58663: EMPTY
58664: LIST
58665: ST_TO_ADDR
// end ;
58666: LD_VAR 0 3
58670: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
58671: LD_INT 0
58673: PPUSH
58674: PPUSH
// list := AreaToList ( area , 0 ) ;
58675: LD_ADDR_VAR 0 4
58679: PUSH
58680: LD_VAR 0 1
58684: PPUSH
58685: LD_INT 0
58687: PPUSH
58688: CALL_OW 517
58692: ST_TO_ADDR
// if not list then
58693: LD_VAR 0 4
58697: NOT
58698: IFFALSE 58702
// exit ;
58700: GO 58743
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58702: LD_ADDR_VAR 0 3
58706: PUSH
58707: LD_VAR 0 4
58711: PUSH
58712: LD_INT 1
58714: ARRAY
58715: PUSH
58716: LD_INT 1
58718: ARRAY
58719: PUSH
58720: LD_VAR 0 4
58724: PUSH
58725: LD_INT 2
58727: ARRAY
58728: PUSH
58729: LD_INT 1
58731: ARRAY
58732: PUSH
58733: LD_VAR 0 2
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: LIST
58742: ST_TO_ADDR
// end ;
58743: LD_VAR 0 3
58747: RET
// export function First ( array ) ; begin
58748: LD_INT 0
58750: PPUSH
// if not array then
58751: LD_VAR 0 1
58755: NOT
58756: IFFALSE 58760
// exit ;
58758: GO 58774
// result := array [ 1 ] ;
58760: LD_ADDR_VAR 0 2
58764: PUSH
58765: LD_VAR 0 1
58769: PUSH
58770: LD_INT 1
58772: ARRAY
58773: ST_TO_ADDR
// end ;
58774: LD_VAR 0 2
58778: RET
// export function Last ( array ) ; begin
58779: LD_INT 0
58781: PPUSH
// if not array then
58782: LD_VAR 0 1
58786: NOT
58787: IFFALSE 58791
// exit ;
58789: GO 58807
// result := array [ array ] ;
58791: LD_ADDR_VAR 0 2
58795: PUSH
58796: LD_VAR 0 1
58800: PUSH
58801: LD_VAR 0 1
58805: ARRAY
58806: ST_TO_ADDR
// end ;
58807: LD_VAR 0 2
58811: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
58812: LD_INT 0
58814: PPUSH
58815: PPUSH
// result := [ ] ;
58816: LD_ADDR_VAR 0 5
58820: PUSH
58821: EMPTY
58822: ST_TO_ADDR
// if not array then
58823: LD_VAR 0 1
58827: NOT
58828: IFFALSE 58832
// exit ;
58830: GO 58944
// for i := 1 to array do
58832: LD_ADDR_VAR 0 6
58836: PUSH
58837: DOUBLE
58838: LD_INT 1
58840: DEC
58841: ST_TO_ADDR
58842: LD_VAR 0 1
58846: PUSH
58847: FOR_TO
58848: IFFALSE 58942
// if array [ i ] [ index ] = value then
58850: LD_VAR 0 1
58854: PUSH
58855: LD_VAR 0 6
58859: ARRAY
58860: PUSH
58861: LD_VAR 0 2
58865: ARRAY
58866: PUSH
58867: LD_VAR 0 3
58871: EQUAL
58872: IFFALSE 58940
// begin if indexColumn then
58874: LD_VAR 0 4
58878: IFFALSE 58914
// result := Join ( result , array [ i ] [ indexColumn ] ) else
58880: LD_ADDR_VAR 0 5
58884: PUSH
58885: LD_VAR 0 5
58889: PPUSH
58890: LD_VAR 0 1
58894: PUSH
58895: LD_VAR 0 6
58899: ARRAY
58900: PUSH
58901: LD_VAR 0 4
58905: ARRAY
58906: PPUSH
58907: CALL 54136 0 2
58911: ST_TO_ADDR
58912: GO 58940
// result := Join ( result , array [ i ] ) ;
58914: LD_ADDR_VAR 0 5
58918: PUSH
58919: LD_VAR 0 5
58923: PPUSH
58924: LD_VAR 0 1
58928: PUSH
58929: LD_VAR 0 6
58933: ARRAY
58934: PPUSH
58935: CALL 54136 0 2
58939: ST_TO_ADDR
// end ;
58940: GO 58847
58942: POP
58943: POP
// end ;
58944: LD_VAR 0 5
58948: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
58949: LD_INT 0
58951: PPUSH
// if not vehicles or not parkingPoint then
58952: LD_VAR 0 1
58956: NOT
58957: PUSH
58958: LD_VAR 0 2
58962: NOT
58963: OR
58964: IFFALSE 58968
// exit ;
58966: GO 59066
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
58968: LD_ADDR_VAR 0 1
58972: PUSH
58973: LD_VAR 0 1
58977: PPUSH
58978: LD_INT 50
58980: PUSH
58981: EMPTY
58982: LIST
58983: PUSH
58984: LD_INT 3
58986: PUSH
58987: LD_INT 92
58989: PUSH
58990: LD_VAR 0 2
58994: PUSH
58995: LD_INT 1
58997: ARRAY
58998: PUSH
58999: LD_VAR 0 2
59003: PUSH
59004: LD_INT 2
59006: ARRAY
59007: PUSH
59008: LD_INT 8
59010: PUSH
59011: EMPTY
59012: LIST
59013: LIST
59014: LIST
59015: LIST
59016: PUSH
59017: EMPTY
59018: LIST
59019: LIST
59020: PUSH
59021: EMPTY
59022: LIST
59023: LIST
59024: PPUSH
59025: CALL_OW 72
59029: ST_TO_ADDR
// if not vehicles then
59030: LD_VAR 0 1
59034: NOT
59035: IFFALSE 59039
// exit ;
59037: GO 59066
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59039: LD_VAR 0 1
59043: PPUSH
59044: LD_VAR 0 2
59048: PUSH
59049: LD_INT 1
59051: ARRAY
59052: PPUSH
59053: LD_VAR 0 2
59057: PUSH
59058: LD_INT 2
59060: ARRAY
59061: PPUSH
59062: CALL_OW 111
// end ;
59066: LD_VAR 0 3
59070: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
59071: LD_INT 0
59073: PPUSH
59074: PPUSH
59075: PPUSH
// if not side or not area then
59076: LD_VAR 0 1
59080: NOT
59081: PUSH
59082: LD_VAR 0 2
59086: NOT
59087: OR
59088: IFFALSE 59092
// exit ;
59090: GO 59211
// tmp := AreaToList ( area , 0 ) ;
59092: LD_ADDR_VAR 0 5
59096: PUSH
59097: LD_VAR 0 2
59101: PPUSH
59102: LD_INT 0
59104: PPUSH
59105: CALL_OW 517
59109: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
59110: LD_ADDR_VAR 0 4
59114: PUSH
59115: DOUBLE
59116: LD_INT 1
59118: DEC
59119: ST_TO_ADDR
59120: LD_VAR 0 5
59124: PUSH
59125: LD_INT 1
59127: ARRAY
59128: PUSH
59129: FOR_TO
59130: IFFALSE 59209
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
59132: LD_VAR 0 5
59136: PUSH
59137: LD_INT 1
59139: ARRAY
59140: PUSH
59141: LD_VAR 0 4
59145: ARRAY
59146: PPUSH
59147: LD_VAR 0 5
59151: PUSH
59152: LD_INT 2
59154: ARRAY
59155: PUSH
59156: LD_VAR 0 4
59160: ARRAY
59161: PPUSH
59162: CALL_OW 351
59166: IFFALSE 59207
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
59168: LD_VAR 0 5
59172: PUSH
59173: LD_INT 1
59175: ARRAY
59176: PUSH
59177: LD_VAR 0 4
59181: ARRAY
59182: PPUSH
59183: LD_VAR 0 5
59187: PUSH
59188: LD_INT 2
59190: ARRAY
59191: PUSH
59192: LD_VAR 0 4
59196: ARRAY
59197: PPUSH
59198: LD_VAR 0 1
59202: PPUSH
59203: CALL_OW 244
// end ;
59207: GO 59129
59209: POP
59210: POP
// end ; end_of_file
59211: LD_VAR 0 3
59215: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
59216: LD_INT 0
59218: PPUSH
59219: PPUSH
// skirmish := false ;
59220: LD_ADDR_EXP 59
59224: PUSH
59225: LD_INT 0
59227: ST_TO_ADDR
// debug_mc := false ;
59228: LD_ADDR_EXP 60
59232: PUSH
59233: LD_INT 0
59235: ST_TO_ADDR
// mc_bases := [ ] ;
59236: LD_ADDR_EXP 61
59240: PUSH
59241: EMPTY
59242: ST_TO_ADDR
// mc_sides := [ ] ;
59243: LD_ADDR_EXP 87
59247: PUSH
59248: EMPTY
59249: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
59250: LD_ADDR_EXP 62
59254: PUSH
59255: EMPTY
59256: ST_TO_ADDR
// mc_building_repairs := [ ] ;
59257: LD_ADDR_EXP 63
59261: PUSH
59262: EMPTY
59263: ST_TO_ADDR
// mc_need_heal := [ ] ;
59264: LD_ADDR_EXP 64
59268: PUSH
59269: EMPTY
59270: ST_TO_ADDR
// mc_healers := [ ] ;
59271: LD_ADDR_EXP 65
59275: PUSH
59276: EMPTY
59277: ST_TO_ADDR
// mc_build_list := [ ] ;
59278: LD_ADDR_EXP 66
59282: PUSH
59283: EMPTY
59284: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
59285: LD_ADDR_EXP 93
59289: PUSH
59290: EMPTY
59291: ST_TO_ADDR
// mc_builders := [ ] ;
59292: LD_ADDR_EXP 67
59296: PUSH
59297: EMPTY
59298: ST_TO_ADDR
// mc_construct_list := [ ] ;
59299: LD_ADDR_EXP 68
59303: PUSH
59304: EMPTY
59305: ST_TO_ADDR
// mc_turret_list := [ ] ;
59306: LD_ADDR_EXP 69
59310: PUSH
59311: EMPTY
59312: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
59313: LD_ADDR_EXP 70
59317: PUSH
59318: EMPTY
59319: ST_TO_ADDR
// mc_miners := [ ] ;
59320: LD_ADDR_EXP 75
59324: PUSH
59325: EMPTY
59326: ST_TO_ADDR
// mc_mines := [ ] ;
59327: LD_ADDR_EXP 74
59331: PUSH
59332: EMPTY
59333: ST_TO_ADDR
// mc_minefields := [ ] ;
59334: LD_ADDR_EXP 76
59338: PUSH
59339: EMPTY
59340: ST_TO_ADDR
// mc_crates := [ ] ;
59341: LD_ADDR_EXP 77
59345: PUSH
59346: EMPTY
59347: ST_TO_ADDR
// mc_crates_collector := [ ] ;
59348: LD_ADDR_EXP 78
59352: PUSH
59353: EMPTY
59354: ST_TO_ADDR
// mc_crates_area := [ ] ;
59355: LD_ADDR_EXP 79
59359: PUSH
59360: EMPTY
59361: ST_TO_ADDR
// mc_vehicles := [ ] ;
59362: LD_ADDR_EXP 80
59366: PUSH
59367: EMPTY
59368: ST_TO_ADDR
// mc_attack := [ ] ;
59369: LD_ADDR_EXP 81
59373: PUSH
59374: EMPTY
59375: ST_TO_ADDR
// mc_produce := [ ] ;
59376: LD_ADDR_EXP 82
59380: PUSH
59381: EMPTY
59382: ST_TO_ADDR
// mc_defender := [ ] ;
59383: LD_ADDR_EXP 83
59387: PUSH
59388: EMPTY
59389: ST_TO_ADDR
// mc_parking := [ ] ;
59390: LD_ADDR_EXP 85
59394: PUSH
59395: EMPTY
59396: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
59397: LD_ADDR_EXP 71
59401: PUSH
59402: EMPTY
59403: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
59404: LD_ADDR_EXP 73
59408: PUSH
59409: EMPTY
59410: ST_TO_ADDR
// mc_scan := [ ] ;
59411: LD_ADDR_EXP 84
59415: PUSH
59416: EMPTY
59417: ST_TO_ADDR
// mc_scan_area := [ ] ;
59418: LD_ADDR_EXP 86
59422: PUSH
59423: EMPTY
59424: ST_TO_ADDR
// mc_tech := [ ] ;
59425: LD_ADDR_EXP 88
59429: PUSH
59430: EMPTY
59431: ST_TO_ADDR
// mc_class := [ ] ;
59432: LD_ADDR_EXP 102
59436: PUSH
59437: EMPTY
59438: ST_TO_ADDR
// mc_class_case_use := [ ] ;
59439: LD_ADDR_EXP 103
59443: PUSH
59444: EMPTY
59445: ST_TO_ADDR
// mc_is_defending := [ ] ;
59446: LD_ADDR_EXP 104
59450: PUSH
59451: EMPTY
59452: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
59453: LD_ADDR_EXP 95
59457: PUSH
59458: EMPTY
59459: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
59460: LD_ADDR_EXP 105
59464: PUSH
59465: LD_INT 0
59467: ST_TO_ADDR
// end ;
59468: LD_VAR 0 1
59472: RET
// export function MC_Kill ( base ) ; begin
59473: LD_INT 0
59475: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
59476: LD_ADDR_EXP 61
59480: PUSH
59481: LD_EXP 61
59485: PPUSH
59486: LD_VAR 0 1
59490: PPUSH
59491: EMPTY
59492: PPUSH
59493: CALL_OW 1
59497: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59498: LD_ADDR_EXP 62
59502: PUSH
59503: LD_EXP 62
59507: PPUSH
59508: LD_VAR 0 1
59512: PPUSH
59513: EMPTY
59514: PPUSH
59515: CALL_OW 1
59519: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59520: LD_ADDR_EXP 63
59524: PUSH
59525: LD_EXP 63
59529: PPUSH
59530: LD_VAR 0 1
59534: PPUSH
59535: EMPTY
59536: PPUSH
59537: CALL_OW 1
59541: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59542: LD_ADDR_EXP 64
59546: PUSH
59547: LD_EXP 64
59551: PPUSH
59552: LD_VAR 0 1
59556: PPUSH
59557: EMPTY
59558: PPUSH
59559: CALL_OW 1
59563: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59564: LD_ADDR_EXP 65
59568: PUSH
59569: LD_EXP 65
59573: PPUSH
59574: LD_VAR 0 1
59578: PPUSH
59579: EMPTY
59580: PPUSH
59581: CALL_OW 1
59585: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59586: LD_ADDR_EXP 66
59590: PUSH
59591: LD_EXP 66
59595: PPUSH
59596: LD_VAR 0 1
59600: PPUSH
59601: EMPTY
59602: PPUSH
59603: CALL_OW 1
59607: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59608: LD_ADDR_EXP 67
59612: PUSH
59613: LD_EXP 67
59617: PPUSH
59618: LD_VAR 0 1
59622: PPUSH
59623: EMPTY
59624: PPUSH
59625: CALL_OW 1
59629: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59630: LD_ADDR_EXP 68
59634: PUSH
59635: LD_EXP 68
59639: PPUSH
59640: LD_VAR 0 1
59644: PPUSH
59645: EMPTY
59646: PPUSH
59647: CALL_OW 1
59651: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59652: LD_ADDR_EXP 69
59656: PUSH
59657: LD_EXP 69
59661: PPUSH
59662: LD_VAR 0 1
59666: PPUSH
59667: EMPTY
59668: PPUSH
59669: CALL_OW 1
59673: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59674: LD_ADDR_EXP 70
59678: PUSH
59679: LD_EXP 70
59683: PPUSH
59684: LD_VAR 0 1
59688: PPUSH
59689: EMPTY
59690: PPUSH
59691: CALL_OW 1
59695: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59696: LD_ADDR_EXP 71
59700: PUSH
59701: LD_EXP 71
59705: PPUSH
59706: LD_VAR 0 1
59710: PPUSH
59711: EMPTY
59712: PPUSH
59713: CALL_OW 1
59717: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59718: LD_ADDR_EXP 72
59722: PUSH
59723: LD_EXP 72
59727: PPUSH
59728: LD_VAR 0 1
59732: PPUSH
59733: LD_INT 0
59735: PPUSH
59736: CALL_OW 1
59740: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59741: LD_ADDR_EXP 73
59745: PUSH
59746: LD_EXP 73
59750: PPUSH
59751: LD_VAR 0 1
59755: PPUSH
59756: EMPTY
59757: PPUSH
59758: CALL_OW 1
59762: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59763: LD_ADDR_EXP 74
59767: PUSH
59768: LD_EXP 74
59772: PPUSH
59773: LD_VAR 0 1
59777: PPUSH
59778: EMPTY
59779: PPUSH
59780: CALL_OW 1
59784: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59785: LD_ADDR_EXP 75
59789: PUSH
59790: LD_EXP 75
59794: PPUSH
59795: LD_VAR 0 1
59799: PPUSH
59800: EMPTY
59801: PPUSH
59802: CALL_OW 1
59806: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59807: LD_ADDR_EXP 76
59811: PUSH
59812: LD_EXP 76
59816: PPUSH
59817: LD_VAR 0 1
59821: PPUSH
59822: EMPTY
59823: PPUSH
59824: CALL_OW 1
59828: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59829: LD_ADDR_EXP 77
59833: PUSH
59834: LD_EXP 77
59838: PPUSH
59839: LD_VAR 0 1
59843: PPUSH
59844: EMPTY
59845: PPUSH
59846: CALL_OW 1
59850: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59851: LD_ADDR_EXP 78
59855: PUSH
59856: LD_EXP 78
59860: PPUSH
59861: LD_VAR 0 1
59865: PPUSH
59866: EMPTY
59867: PPUSH
59868: CALL_OW 1
59872: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59873: LD_ADDR_EXP 79
59877: PUSH
59878: LD_EXP 79
59882: PPUSH
59883: LD_VAR 0 1
59887: PPUSH
59888: EMPTY
59889: PPUSH
59890: CALL_OW 1
59894: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59895: LD_ADDR_EXP 80
59899: PUSH
59900: LD_EXP 80
59904: PPUSH
59905: LD_VAR 0 1
59909: PPUSH
59910: EMPTY
59911: PPUSH
59912: CALL_OW 1
59916: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59917: LD_ADDR_EXP 81
59921: PUSH
59922: LD_EXP 81
59926: PPUSH
59927: LD_VAR 0 1
59931: PPUSH
59932: EMPTY
59933: PPUSH
59934: CALL_OW 1
59938: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59939: LD_ADDR_EXP 82
59943: PUSH
59944: LD_EXP 82
59948: PPUSH
59949: LD_VAR 0 1
59953: PPUSH
59954: EMPTY
59955: PPUSH
59956: CALL_OW 1
59960: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59961: LD_ADDR_EXP 83
59965: PUSH
59966: LD_EXP 83
59970: PPUSH
59971: LD_VAR 0 1
59975: PPUSH
59976: EMPTY
59977: PPUSH
59978: CALL_OW 1
59982: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59983: LD_ADDR_EXP 84
59987: PUSH
59988: LD_EXP 84
59992: PPUSH
59993: LD_VAR 0 1
59997: PPUSH
59998: EMPTY
59999: PPUSH
60000: CALL_OW 1
60004: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60005: LD_ADDR_EXP 85
60009: PUSH
60010: LD_EXP 85
60014: PPUSH
60015: LD_VAR 0 1
60019: PPUSH
60020: EMPTY
60021: PPUSH
60022: CALL_OW 1
60026: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60027: LD_ADDR_EXP 86
60031: PUSH
60032: LD_EXP 86
60036: PPUSH
60037: LD_VAR 0 1
60041: PPUSH
60042: EMPTY
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60049: LD_ADDR_EXP 88
60053: PUSH
60054: LD_EXP 88
60058: PPUSH
60059: LD_VAR 0 1
60063: PPUSH
60064: EMPTY
60065: PPUSH
60066: CALL_OW 1
60070: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60071: LD_ADDR_EXP 90
60075: PUSH
60076: LD_EXP 90
60080: PPUSH
60081: LD_VAR 0 1
60085: PPUSH
60086: EMPTY
60087: PPUSH
60088: CALL_OW 1
60092: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60093: LD_ADDR_EXP 91
60097: PUSH
60098: LD_EXP 91
60102: PPUSH
60103: LD_VAR 0 1
60107: PPUSH
60108: EMPTY
60109: PPUSH
60110: CALL_OW 1
60114: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60115: LD_ADDR_EXP 92
60119: PUSH
60120: LD_EXP 92
60124: PPUSH
60125: LD_VAR 0 1
60129: PPUSH
60130: EMPTY
60131: PPUSH
60132: CALL_OW 1
60136: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60137: LD_ADDR_EXP 93
60141: PUSH
60142: LD_EXP 93
60146: PPUSH
60147: LD_VAR 0 1
60151: PPUSH
60152: EMPTY
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60159: LD_ADDR_EXP 94
60163: PUSH
60164: LD_EXP 94
60168: PPUSH
60169: LD_VAR 0 1
60173: PPUSH
60174: EMPTY
60175: PPUSH
60176: CALL_OW 1
60180: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60181: LD_ADDR_EXP 95
60185: PUSH
60186: LD_EXP 95
60190: PPUSH
60191: LD_VAR 0 1
60195: PPUSH
60196: EMPTY
60197: PPUSH
60198: CALL_OW 1
60202: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60203: LD_ADDR_EXP 96
60207: PUSH
60208: LD_EXP 96
60212: PPUSH
60213: LD_VAR 0 1
60217: PPUSH
60218: EMPTY
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60225: LD_ADDR_EXP 97
60229: PUSH
60230: LD_EXP 97
60234: PPUSH
60235: LD_VAR 0 1
60239: PPUSH
60240: EMPTY
60241: PPUSH
60242: CALL_OW 1
60246: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60247: LD_ADDR_EXP 98
60251: PUSH
60252: LD_EXP 98
60256: PPUSH
60257: LD_VAR 0 1
60261: PPUSH
60262: EMPTY
60263: PPUSH
60264: CALL_OW 1
60268: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60269: LD_ADDR_EXP 99
60273: PUSH
60274: LD_EXP 99
60278: PPUSH
60279: LD_VAR 0 1
60283: PPUSH
60284: EMPTY
60285: PPUSH
60286: CALL_OW 1
60290: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60291: LD_ADDR_EXP 100
60295: PUSH
60296: LD_EXP 100
60300: PPUSH
60301: LD_VAR 0 1
60305: PPUSH
60306: EMPTY
60307: PPUSH
60308: CALL_OW 1
60312: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60313: LD_ADDR_EXP 101
60317: PUSH
60318: LD_EXP 101
60322: PPUSH
60323: LD_VAR 0 1
60327: PPUSH
60328: EMPTY
60329: PPUSH
60330: CALL_OW 1
60334: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60335: LD_ADDR_EXP 102
60339: PUSH
60340: LD_EXP 102
60344: PPUSH
60345: LD_VAR 0 1
60349: PPUSH
60350: EMPTY
60351: PPUSH
60352: CALL_OW 1
60356: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60357: LD_ADDR_EXP 103
60361: PUSH
60362: LD_EXP 103
60366: PPUSH
60367: LD_VAR 0 1
60371: PPUSH
60372: LD_INT 0
60374: PPUSH
60375: CALL_OW 1
60379: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60380: LD_ADDR_EXP 104
60384: PUSH
60385: LD_EXP 104
60389: PPUSH
60390: LD_VAR 0 1
60394: PPUSH
60395: LD_INT 0
60397: PPUSH
60398: CALL_OW 1
60402: ST_TO_ADDR
// end ;
60403: LD_VAR 0 2
60407: RET
// export function MC_Add ( side , units ) ; var base ; begin
60408: LD_INT 0
60410: PPUSH
60411: PPUSH
// base := mc_bases + 1 ;
60412: LD_ADDR_VAR 0 4
60416: PUSH
60417: LD_EXP 61
60421: PUSH
60422: LD_INT 1
60424: PLUS
60425: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
60426: LD_ADDR_EXP 87
60430: PUSH
60431: LD_EXP 87
60435: PPUSH
60436: LD_VAR 0 4
60440: PPUSH
60441: LD_VAR 0 1
60445: PPUSH
60446: CALL_OW 1
60450: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
60451: LD_ADDR_EXP 61
60455: PUSH
60456: LD_EXP 61
60460: PPUSH
60461: LD_VAR 0 4
60465: PPUSH
60466: LD_VAR 0 2
60470: PPUSH
60471: CALL_OW 1
60475: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60476: LD_ADDR_EXP 62
60480: PUSH
60481: LD_EXP 62
60485: PPUSH
60486: LD_VAR 0 4
60490: PPUSH
60491: EMPTY
60492: PPUSH
60493: CALL_OW 1
60497: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60498: LD_ADDR_EXP 63
60502: PUSH
60503: LD_EXP 63
60507: PPUSH
60508: LD_VAR 0 4
60512: PPUSH
60513: EMPTY
60514: PPUSH
60515: CALL_OW 1
60519: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60520: LD_ADDR_EXP 64
60524: PUSH
60525: LD_EXP 64
60529: PPUSH
60530: LD_VAR 0 4
60534: PPUSH
60535: EMPTY
60536: PPUSH
60537: CALL_OW 1
60541: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60542: LD_ADDR_EXP 65
60546: PUSH
60547: LD_EXP 65
60551: PPUSH
60552: LD_VAR 0 4
60556: PPUSH
60557: EMPTY
60558: PPUSH
60559: CALL_OW 1
60563: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60564: LD_ADDR_EXP 66
60568: PUSH
60569: LD_EXP 66
60573: PPUSH
60574: LD_VAR 0 4
60578: PPUSH
60579: EMPTY
60580: PPUSH
60581: CALL_OW 1
60585: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60586: LD_ADDR_EXP 67
60590: PUSH
60591: LD_EXP 67
60595: PPUSH
60596: LD_VAR 0 4
60600: PPUSH
60601: EMPTY
60602: PPUSH
60603: CALL_OW 1
60607: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60608: LD_ADDR_EXP 68
60612: PUSH
60613: LD_EXP 68
60617: PPUSH
60618: LD_VAR 0 4
60622: PPUSH
60623: EMPTY
60624: PPUSH
60625: CALL_OW 1
60629: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60630: LD_ADDR_EXP 69
60634: PUSH
60635: LD_EXP 69
60639: PPUSH
60640: LD_VAR 0 4
60644: PPUSH
60645: EMPTY
60646: PPUSH
60647: CALL_OW 1
60651: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60652: LD_ADDR_EXP 70
60656: PUSH
60657: LD_EXP 70
60661: PPUSH
60662: LD_VAR 0 4
60666: PPUSH
60667: EMPTY
60668: PPUSH
60669: CALL_OW 1
60673: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60674: LD_ADDR_EXP 71
60678: PUSH
60679: LD_EXP 71
60683: PPUSH
60684: LD_VAR 0 4
60688: PPUSH
60689: EMPTY
60690: PPUSH
60691: CALL_OW 1
60695: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60696: LD_ADDR_EXP 72
60700: PUSH
60701: LD_EXP 72
60705: PPUSH
60706: LD_VAR 0 4
60710: PPUSH
60711: LD_INT 0
60713: PPUSH
60714: CALL_OW 1
60718: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60719: LD_ADDR_EXP 73
60723: PUSH
60724: LD_EXP 73
60728: PPUSH
60729: LD_VAR 0 4
60733: PPUSH
60734: EMPTY
60735: PPUSH
60736: CALL_OW 1
60740: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60741: LD_ADDR_EXP 74
60745: PUSH
60746: LD_EXP 74
60750: PPUSH
60751: LD_VAR 0 4
60755: PPUSH
60756: EMPTY
60757: PPUSH
60758: CALL_OW 1
60762: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60763: LD_ADDR_EXP 75
60767: PUSH
60768: LD_EXP 75
60772: PPUSH
60773: LD_VAR 0 4
60777: PPUSH
60778: EMPTY
60779: PPUSH
60780: CALL_OW 1
60784: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60785: LD_ADDR_EXP 76
60789: PUSH
60790: LD_EXP 76
60794: PPUSH
60795: LD_VAR 0 4
60799: PPUSH
60800: EMPTY
60801: PPUSH
60802: CALL_OW 1
60806: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60807: LD_ADDR_EXP 77
60811: PUSH
60812: LD_EXP 77
60816: PPUSH
60817: LD_VAR 0 4
60821: PPUSH
60822: EMPTY
60823: PPUSH
60824: CALL_OW 1
60828: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60829: LD_ADDR_EXP 78
60833: PUSH
60834: LD_EXP 78
60838: PPUSH
60839: LD_VAR 0 4
60843: PPUSH
60844: EMPTY
60845: PPUSH
60846: CALL_OW 1
60850: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60851: LD_ADDR_EXP 79
60855: PUSH
60856: LD_EXP 79
60860: PPUSH
60861: LD_VAR 0 4
60865: PPUSH
60866: EMPTY
60867: PPUSH
60868: CALL_OW 1
60872: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60873: LD_ADDR_EXP 80
60877: PUSH
60878: LD_EXP 80
60882: PPUSH
60883: LD_VAR 0 4
60887: PPUSH
60888: EMPTY
60889: PPUSH
60890: CALL_OW 1
60894: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60895: LD_ADDR_EXP 81
60899: PUSH
60900: LD_EXP 81
60904: PPUSH
60905: LD_VAR 0 4
60909: PPUSH
60910: EMPTY
60911: PPUSH
60912: CALL_OW 1
60916: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60917: LD_ADDR_EXP 82
60921: PUSH
60922: LD_EXP 82
60926: PPUSH
60927: LD_VAR 0 4
60931: PPUSH
60932: EMPTY
60933: PPUSH
60934: CALL_OW 1
60938: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60939: LD_ADDR_EXP 83
60943: PUSH
60944: LD_EXP 83
60948: PPUSH
60949: LD_VAR 0 4
60953: PPUSH
60954: EMPTY
60955: PPUSH
60956: CALL_OW 1
60960: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60961: LD_ADDR_EXP 84
60965: PUSH
60966: LD_EXP 84
60970: PPUSH
60971: LD_VAR 0 4
60975: PPUSH
60976: EMPTY
60977: PPUSH
60978: CALL_OW 1
60982: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60983: LD_ADDR_EXP 85
60987: PUSH
60988: LD_EXP 85
60992: PPUSH
60993: LD_VAR 0 4
60997: PPUSH
60998: EMPTY
60999: PPUSH
61000: CALL_OW 1
61004: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61005: LD_ADDR_EXP 86
61009: PUSH
61010: LD_EXP 86
61014: PPUSH
61015: LD_VAR 0 4
61019: PPUSH
61020: EMPTY
61021: PPUSH
61022: CALL_OW 1
61026: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61027: LD_ADDR_EXP 88
61031: PUSH
61032: LD_EXP 88
61036: PPUSH
61037: LD_VAR 0 4
61041: PPUSH
61042: EMPTY
61043: PPUSH
61044: CALL_OW 1
61048: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61049: LD_ADDR_EXP 90
61053: PUSH
61054: LD_EXP 90
61058: PPUSH
61059: LD_VAR 0 4
61063: PPUSH
61064: EMPTY
61065: PPUSH
61066: CALL_OW 1
61070: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61071: LD_ADDR_EXP 91
61075: PUSH
61076: LD_EXP 91
61080: PPUSH
61081: LD_VAR 0 4
61085: PPUSH
61086: EMPTY
61087: PPUSH
61088: CALL_OW 1
61092: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61093: LD_ADDR_EXP 92
61097: PUSH
61098: LD_EXP 92
61102: PPUSH
61103: LD_VAR 0 4
61107: PPUSH
61108: EMPTY
61109: PPUSH
61110: CALL_OW 1
61114: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61115: LD_ADDR_EXP 93
61119: PUSH
61120: LD_EXP 93
61124: PPUSH
61125: LD_VAR 0 4
61129: PPUSH
61130: EMPTY
61131: PPUSH
61132: CALL_OW 1
61136: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61137: LD_ADDR_EXP 94
61141: PUSH
61142: LD_EXP 94
61146: PPUSH
61147: LD_VAR 0 4
61151: PPUSH
61152: EMPTY
61153: PPUSH
61154: CALL_OW 1
61158: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61159: LD_ADDR_EXP 95
61163: PUSH
61164: LD_EXP 95
61168: PPUSH
61169: LD_VAR 0 4
61173: PPUSH
61174: EMPTY
61175: PPUSH
61176: CALL_OW 1
61180: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61181: LD_ADDR_EXP 96
61185: PUSH
61186: LD_EXP 96
61190: PPUSH
61191: LD_VAR 0 4
61195: PPUSH
61196: EMPTY
61197: PPUSH
61198: CALL_OW 1
61202: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61203: LD_ADDR_EXP 97
61207: PUSH
61208: LD_EXP 97
61212: PPUSH
61213: LD_VAR 0 4
61217: PPUSH
61218: EMPTY
61219: PPUSH
61220: CALL_OW 1
61224: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61225: LD_ADDR_EXP 98
61229: PUSH
61230: LD_EXP 98
61234: PPUSH
61235: LD_VAR 0 4
61239: PPUSH
61240: EMPTY
61241: PPUSH
61242: CALL_OW 1
61246: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61247: LD_ADDR_EXP 99
61251: PUSH
61252: LD_EXP 99
61256: PPUSH
61257: LD_VAR 0 4
61261: PPUSH
61262: EMPTY
61263: PPUSH
61264: CALL_OW 1
61268: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61269: LD_ADDR_EXP 100
61273: PUSH
61274: LD_EXP 100
61278: PPUSH
61279: LD_VAR 0 4
61283: PPUSH
61284: EMPTY
61285: PPUSH
61286: CALL_OW 1
61290: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61291: LD_ADDR_EXP 101
61295: PUSH
61296: LD_EXP 101
61300: PPUSH
61301: LD_VAR 0 4
61305: PPUSH
61306: EMPTY
61307: PPUSH
61308: CALL_OW 1
61312: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61313: LD_ADDR_EXP 102
61317: PUSH
61318: LD_EXP 102
61322: PPUSH
61323: LD_VAR 0 4
61327: PPUSH
61328: EMPTY
61329: PPUSH
61330: CALL_OW 1
61334: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61335: LD_ADDR_EXP 103
61339: PUSH
61340: LD_EXP 103
61344: PPUSH
61345: LD_VAR 0 4
61349: PPUSH
61350: LD_INT 0
61352: PPUSH
61353: CALL_OW 1
61357: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61358: LD_ADDR_EXP 104
61362: PUSH
61363: LD_EXP 104
61367: PPUSH
61368: LD_VAR 0 4
61372: PPUSH
61373: LD_INT 0
61375: PPUSH
61376: CALL_OW 1
61380: ST_TO_ADDR
// result := base ;
61381: LD_ADDR_VAR 0 3
61385: PUSH
61386: LD_VAR 0 4
61390: ST_TO_ADDR
// end ;
61391: LD_VAR 0 3
61395: RET
// export function MC_Start ( ) ; var i ; begin
61396: LD_INT 0
61398: PPUSH
61399: PPUSH
// for i = 1 to mc_bases do
61400: LD_ADDR_VAR 0 2
61404: PUSH
61405: DOUBLE
61406: LD_INT 1
61408: DEC
61409: ST_TO_ADDR
61410: LD_EXP 61
61414: PUSH
61415: FOR_TO
61416: IFFALSE 62516
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
61418: LD_ADDR_EXP 61
61422: PUSH
61423: LD_EXP 61
61427: PPUSH
61428: LD_VAR 0 2
61432: PPUSH
61433: LD_EXP 61
61437: PUSH
61438: LD_VAR 0 2
61442: ARRAY
61443: PUSH
61444: LD_INT 0
61446: DIFF
61447: PPUSH
61448: CALL_OW 1
61452: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
61453: LD_ADDR_EXP 62
61457: PUSH
61458: LD_EXP 62
61462: PPUSH
61463: LD_VAR 0 2
61467: PPUSH
61468: EMPTY
61469: PPUSH
61470: CALL_OW 1
61474: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61475: LD_ADDR_EXP 63
61479: PUSH
61480: LD_EXP 63
61484: PPUSH
61485: LD_VAR 0 2
61489: PPUSH
61490: EMPTY
61491: PPUSH
61492: CALL_OW 1
61496: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
61497: LD_ADDR_EXP 64
61501: PUSH
61502: LD_EXP 64
61506: PPUSH
61507: LD_VAR 0 2
61511: PPUSH
61512: EMPTY
61513: PPUSH
61514: CALL_OW 1
61518: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
61519: LD_ADDR_EXP 65
61523: PUSH
61524: LD_EXP 65
61528: PPUSH
61529: LD_VAR 0 2
61533: PPUSH
61534: EMPTY
61535: PUSH
61536: EMPTY
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: PPUSH
61542: CALL_OW 1
61546: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
61547: LD_ADDR_EXP 66
61551: PUSH
61552: LD_EXP 66
61556: PPUSH
61557: LD_VAR 0 2
61561: PPUSH
61562: EMPTY
61563: PPUSH
61564: CALL_OW 1
61568: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
61569: LD_ADDR_EXP 93
61573: PUSH
61574: LD_EXP 93
61578: PPUSH
61579: LD_VAR 0 2
61583: PPUSH
61584: EMPTY
61585: PPUSH
61586: CALL_OW 1
61590: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
61591: LD_ADDR_EXP 67
61595: PUSH
61596: LD_EXP 67
61600: PPUSH
61601: LD_VAR 0 2
61605: PPUSH
61606: EMPTY
61607: PPUSH
61608: CALL_OW 1
61612: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
61613: LD_ADDR_EXP 68
61617: PUSH
61618: LD_EXP 68
61622: PPUSH
61623: LD_VAR 0 2
61627: PPUSH
61628: EMPTY
61629: PPUSH
61630: CALL_OW 1
61634: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
61635: LD_ADDR_EXP 69
61639: PUSH
61640: LD_EXP 69
61644: PPUSH
61645: LD_VAR 0 2
61649: PPUSH
61650: LD_EXP 61
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PPUSH
61661: LD_INT 2
61663: PUSH
61664: LD_INT 30
61666: PUSH
61667: LD_INT 32
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: PUSH
61674: LD_INT 30
61676: PUSH
61677: LD_INT 33
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: EMPTY
61685: LIST
61686: LIST
61687: LIST
61688: PPUSH
61689: CALL_OW 72
61693: PPUSH
61694: CALL_OW 1
61698: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
61699: LD_ADDR_EXP 70
61703: PUSH
61704: LD_EXP 70
61708: PPUSH
61709: LD_VAR 0 2
61713: PPUSH
61714: LD_EXP 61
61718: PUSH
61719: LD_VAR 0 2
61723: ARRAY
61724: PPUSH
61725: LD_INT 2
61727: PUSH
61728: LD_INT 30
61730: PUSH
61731: LD_INT 32
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: PUSH
61738: LD_INT 30
61740: PUSH
61741: LD_INT 31
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: LIST
61752: PUSH
61753: LD_INT 58
61755: PUSH
61756: EMPTY
61757: LIST
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: PPUSH
61768: CALL_OW 1
61772: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
61773: LD_ADDR_EXP 71
61777: PUSH
61778: LD_EXP 71
61782: PPUSH
61783: LD_VAR 0 2
61787: PPUSH
61788: EMPTY
61789: PPUSH
61790: CALL_OW 1
61794: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
61795: LD_ADDR_EXP 75
61799: PUSH
61800: LD_EXP 75
61804: PPUSH
61805: LD_VAR 0 2
61809: PPUSH
61810: EMPTY
61811: PPUSH
61812: CALL_OW 1
61816: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
61817: LD_ADDR_EXP 74
61821: PUSH
61822: LD_EXP 74
61826: PPUSH
61827: LD_VAR 0 2
61831: PPUSH
61832: EMPTY
61833: PPUSH
61834: CALL_OW 1
61838: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
61839: LD_ADDR_EXP 76
61843: PUSH
61844: LD_EXP 76
61848: PPUSH
61849: LD_VAR 0 2
61853: PPUSH
61854: EMPTY
61855: PPUSH
61856: CALL_OW 1
61860: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
61861: LD_ADDR_EXP 77
61865: PUSH
61866: LD_EXP 77
61870: PPUSH
61871: LD_VAR 0 2
61875: PPUSH
61876: EMPTY
61877: PPUSH
61878: CALL_OW 1
61882: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
61883: LD_ADDR_EXP 78
61887: PUSH
61888: LD_EXP 78
61892: PPUSH
61893: LD_VAR 0 2
61897: PPUSH
61898: EMPTY
61899: PPUSH
61900: CALL_OW 1
61904: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
61905: LD_ADDR_EXP 79
61909: PUSH
61910: LD_EXP 79
61914: PPUSH
61915: LD_VAR 0 2
61919: PPUSH
61920: EMPTY
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
61927: LD_ADDR_EXP 80
61931: PUSH
61932: LD_EXP 80
61936: PPUSH
61937: LD_VAR 0 2
61941: PPUSH
61942: EMPTY
61943: PPUSH
61944: CALL_OW 1
61948: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
61949: LD_ADDR_EXP 81
61953: PUSH
61954: LD_EXP 81
61958: PPUSH
61959: LD_VAR 0 2
61963: PPUSH
61964: EMPTY
61965: PPUSH
61966: CALL_OW 1
61970: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
61971: LD_ADDR_EXP 82
61975: PUSH
61976: LD_EXP 82
61980: PPUSH
61981: LD_VAR 0 2
61985: PPUSH
61986: EMPTY
61987: PPUSH
61988: CALL_OW 1
61992: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
61993: LD_ADDR_EXP 83
61997: PUSH
61998: LD_EXP 83
62002: PPUSH
62003: LD_VAR 0 2
62007: PPUSH
62008: EMPTY
62009: PPUSH
62010: CALL_OW 1
62014: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62015: LD_ADDR_EXP 72
62019: PUSH
62020: LD_EXP 72
62024: PPUSH
62025: LD_VAR 0 2
62029: PPUSH
62030: LD_INT 0
62032: PPUSH
62033: CALL_OW 1
62037: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62038: LD_ADDR_EXP 85
62042: PUSH
62043: LD_EXP 85
62047: PPUSH
62048: LD_VAR 0 2
62052: PPUSH
62053: LD_INT 0
62055: PPUSH
62056: CALL_OW 1
62060: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62061: LD_ADDR_EXP 73
62065: PUSH
62066: LD_EXP 73
62070: PPUSH
62071: LD_VAR 0 2
62075: PPUSH
62076: EMPTY
62077: PPUSH
62078: CALL_OW 1
62082: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62083: LD_ADDR_EXP 84
62087: PUSH
62088: LD_EXP 84
62092: PPUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: LD_INT 0
62100: PPUSH
62101: CALL_OW 1
62105: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
62106: LD_ADDR_EXP 86
62110: PUSH
62111: LD_EXP 86
62115: PPUSH
62116: LD_VAR 0 2
62120: PPUSH
62121: EMPTY
62122: PPUSH
62123: CALL_OW 1
62127: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
62128: LD_ADDR_EXP 89
62132: PUSH
62133: LD_EXP 89
62137: PPUSH
62138: LD_VAR 0 2
62142: PPUSH
62143: LD_INT 0
62145: PPUSH
62146: CALL_OW 1
62150: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
62151: LD_ADDR_EXP 90
62155: PUSH
62156: LD_EXP 90
62160: PPUSH
62161: LD_VAR 0 2
62165: PPUSH
62166: EMPTY
62167: PPUSH
62168: CALL_OW 1
62172: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62173: LD_ADDR_EXP 91
62177: PUSH
62178: LD_EXP 91
62182: PPUSH
62183: LD_VAR 0 2
62187: PPUSH
62188: EMPTY
62189: PPUSH
62190: CALL_OW 1
62194: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62195: LD_ADDR_EXP 92
62199: PUSH
62200: LD_EXP 92
62204: PPUSH
62205: LD_VAR 0 2
62209: PPUSH
62210: EMPTY
62211: PPUSH
62212: CALL_OW 1
62216: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
62217: LD_ADDR_EXP 94
62221: PUSH
62222: LD_EXP 94
62226: PPUSH
62227: LD_VAR 0 2
62231: PPUSH
62232: LD_EXP 61
62236: PUSH
62237: LD_VAR 0 2
62241: ARRAY
62242: PPUSH
62243: LD_INT 2
62245: PUSH
62246: LD_INT 30
62248: PUSH
62249: LD_INT 6
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: LD_INT 30
62258: PUSH
62259: LD_INT 7
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: LD_INT 30
62268: PUSH
62269: LD_INT 8
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: LIST
62280: LIST
62281: PPUSH
62282: CALL_OW 72
62286: PPUSH
62287: CALL_OW 1
62291: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
62292: LD_ADDR_EXP 95
62296: PUSH
62297: LD_EXP 95
62301: PPUSH
62302: LD_VAR 0 2
62306: PPUSH
62307: EMPTY
62308: PPUSH
62309: CALL_OW 1
62313: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
62314: LD_ADDR_EXP 96
62318: PUSH
62319: LD_EXP 96
62323: PPUSH
62324: LD_VAR 0 2
62328: PPUSH
62329: EMPTY
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
62336: LD_ADDR_EXP 97
62340: PUSH
62341: LD_EXP 97
62345: PPUSH
62346: LD_VAR 0 2
62350: PPUSH
62351: EMPTY
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
62358: LD_ADDR_EXP 98
62362: PUSH
62363: LD_EXP 98
62367: PPUSH
62368: LD_VAR 0 2
62372: PPUSH
62373: EMPTY
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62380: LD_ADDR_EXP 99
62384: PUSH
62385: LD_EXP 99
62389: PPUSH
62390: LD_VAR 0 2
62394: PPUSH
62395: EMPTY
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
62402: LD_ADDR_EXP 100
62406: PUSH
62407: LD_EXP 100
62411: PPUSH
62412: LD_VAR 0 2
62416: PPUSH
62417: EMPTY
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
62424: LD_ADDR_EXP 101
62428: PUSH
62429: LD_EXP 101
62433: PPUSH
62434: LD_VAR 0 2
62438: PPUSH
62439: EMPTY
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
62446: LD_ADDR_EXP 102
62450: PUSH
62451: LD_EXP 102
62455: PPUSH
62456: LD_VAR 0 2
62460: PPUSH
62461: EMPTY
62462: PPUSH
62463: CALL_OW 1
62467: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
62468: LD_ADDR_EXP 103
62472: PUSH
62473: LD_EXP 103
62477: PPUSH
62478: LD_VAR 0 2
62482: PPUSH
62483: LD_INT 0
62485: PPUSH
62486: CALL_OW 1
62490: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
62491: LD_ADDR_EXP 104
62495: PUSH
62496: LD_EXP 104
62500: PPUSH
62501: LD_VAR 0 2
62505: PPUSH
62506: LD_INT 0
62508: PPUSH
62509: CALL_OW 1
62513: ST_TO_ADDR
// end ;
62514: GO 61415
62516: POP
62517: POP
// MC_InitSides ( ) ;
62518: CALL 62804 0 0
// MC_InitResearch ( ) ;
62522: CALL 62543 0 0
// CustomInitMacro ( ) ;
62526: CALL 219 0 0
// skirmish := true ;
62530: LD_ADDR_EXP 59
62534: PUSH
62535: LD_INT 1
62537: ST_TO_ADDR
// end ;
62538: LD_VAR 0 1
62542: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
62543: LD_INT 0
62545: PPUSH
62546: PPUSH
62547: PPUSH
62548: PPUSH
62549: PPUSH
62550: PPUSH
// if not mc_bases then
62551: LD_EXP 61
62555: NOT
62556: IFFALSE 62560
// exit ;
62558: GO 62799
// for i = 1 to 8 do
62560: LD_ADDR_VAR 0 2
62564: PUSH
62565: DOUBLE
62566: LD_INT 1
62568: DEC
62569: ST_TO_ADDR
62570: LD_INT 8
62572: PUSH
62573: FOR_TO
62574: IFFALSE 62600
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
62576: LD_ADDR_EXP 88
62580: PUSH
62581: LD_EXP 88
62585: PPUSH
62586: LD_VAR 0 2
62590: PPUSH
62591: EMPTY
62592: PPUSH
62593: CALL_OW 1
62597: ST_TO_ADDR
62598: GO 62573
62600: POP
62601: POP
// tmp := [ ] ;
62602: LD_ADDR_VAR 0 5
62606: PUSH
62607: EMPTY
62608: ST_TO_ADDR
// for i = 1 to mc_sides do
62609: LD_ADDR_VAR 0 2
62613: PUSH
62614: DOUBLE
62615: LD_INT 1
62617: DEC
62618: ST_TO_ADDR
62619: LD_EXP 87
62623: PUSH
62624: FOR_TO
62625: IFFALSE 62683
// if not mc_sides [ i ] in tmp then
62627: LD_EXP 87
62631: PUSH
62632: LD_VAR 0 2
62636: ARRAY
62637: PUSH
62638: LD_VAR 0 5
62642: IN
62643: NOT
62644: IFFALSE 62681
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
62646: LD_ADDR_VAR 0 5
62650: PUSH
62651: LD_VAR 0 5
62655: PPUSH
62656: LD_VAR 0 5
62660: PUSH
62661: LD_INT 1
62663: PLUS
62664: PPUSH
62665: LD_EXP 87
62669: PUSH
62670: LD_VAR 0 2
62674: ARRAY
62675: PPUSH
62676: CALL_OW 2
62680: ST_TO_ADDR
62681: GO 62624
62683: POP
62684: POP
// if not tmp then
62685: LD_VAR 0 5
62689: NOT
62690: IFFALSE 62694
// exit ;
62692: GO 62799
// for j in tmp do
62694: LD_ADDR_VAR 0 3
62698: PUSH
62699: LD_VAR 0 5
62703: PUSH
62704: FOR_IN
62705: IFFALSE 62797
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
62707: LD_ADDR_VAR 0 6
62711: PUSH
62712: LD_INT 22
62714: PUSH
62715: LD_VAR 0 3
62719: PUSH
62720: EMPTY
62721: LIST
62722: LIST
62723: PPUSH
62724: CALL_OW 69
62728: ST_TO_ADDR
// if not un then
62729: LD_VAR 0 6
62733: NOT
62734: IFFALSE 62738
// continue ;
62736: GO 62704
// nation := GetNation ( un [ 1 ] ) ;
62738: LD_ADDR_VAR 0 4
62742: PUSH
62743: LD_VAR 0 6
62747: PUSH
62748: LD_INT 1
62750: ARRAY
62751: PPUSH
62752: CALL_OW 248
62756: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
62757: LD_ADDR_EXP 88
62761: PUSH
62762: LD_EXP 88
62766: PPUSH
62767: LD_VAR 0 3
62771: PPUSH
62772: LD_VAR 0 3
62776: PPUSH
62777: LD_VAR 0 4
62781: PPUSH
62782: LD_INT 1
62784: PPUSH
62785: CALL 16508 0 3
62789: PPUSH
62790: CALL_OW 1
62794: ST_TO_ADDR
// end ;
62795: GO 62704
62797: POP
62798: POP
// end ;
62799: LD_VAR 0 1
62803: RET
// export function MC_InitSides ( ) ; var i ; begin
62804: LD_INT 0
62806: PPUSH
62807: PPUSH
// if not mc_bases then
62808: LD_EXP 61
62812: NOT
62813: IFFALSE 62817
// exit ;
62815: GO 62891
// for i = 1 to mc_bases do
62817: LD_ADDR_VAR 0 2
62821: PUSH
62822: DOUBLE
62823: LD_INT 1
62825: DEC
62826: ST_TO_ADDR
62827: LD_EXP 61
62831: PUSH
62832: FOR_TO
62833: IFFALSE 62889
// if mc_bases [ i ] then
62835: LD_EXP 61
62839: PUSH
62840: LD_VAR 0 2
62844: ARRAY
62845: IFFALSE 62887
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
62847: LD_ADDR_EXP 87
62851: PUSH
62852: LD_EXP 87
62856: PPUSH
62857: LD_VAR 0 2
62861: PPUSH
62862: LD_EXP 61
62866: PUSH
62867: LD_VAR 0 2
62871: ARRAY
62872: PUSH
62873: LD_INT 1
62875: ARRAY
62876: PPUSH
62877: CALL_OW 255
62881: PPUSH
62882: CALL_OW 1
62886: ST_TO_ADDR
62887: GO 62832
62889: POP
62890: POP
// end ;
62891: LD_VAR 0 1
62895: RET
// every 0 0$03 trigger skirmish do
62896: LD_EXP 59
62900: IFFALSE 63054
62902: GO 62904
62904: DISABLE
// begin enable ;
62905: ENABLE
// MC_CheckBuildings ( ) ;
62906: CALL 67566 0 0
// MC_CheckPeopleLife ( ) ;
62910: CALL 67727 0 0
// RaiseSailEvent ( 100 ) ;
62914: LD_INT 100
62916: PPUSH
62917: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
62921: LD_INT 103
62923: PPUSH
62924: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
62928: LD_INT 104
62930: PPUSH
62931: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
62935: LD_INT 105
62937: PPUSH
62938: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
62942: LD_INT 106
62944: PPUSH
62945: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
62949: LD_INT 107
62951: PPUSH
62952: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
62956: LD_INT 108
62958: PPUSH
62959: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
62963: LD_INT 109
62965: PPUSH
62966: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
62970: LD_INT 110
62972: PPUSH
62973: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
62977: LD_INT 111
62979: PPUSH
62980: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
62984: LD_INT 112
62986: PPUSH
62987: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
62991: LD_INT 113
62993: PPUSH
62994: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
62998: LD_INT 120
63000: PPUSH
63001: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63005: LD_INT 121
63007: PPUSH
63008: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63012: LD_INT 122
63014: PPUSH
63015: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63019: LD_INT 123
63021: PPUSH
63022: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63026: LD_INT 124
63028: PPUSH
63029: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63033: LD_INT 125
63035: PPUSH
63036: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63040: LD_INT 126
63042: PPUSH
63043: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63047: LD_INT 200
63049: PPUSH
63050: CALL_OW 427
// end ;
63054: END
// on SailEvent ( event ) do begin if event < 100 then
63055: LD_VAR 0 1
63059: PUSH
63060: LD_INT 100
63062: LESS
63063: IFFALSE 63074
// CustomEvent ( event ) ;
63065: LD_VAR 0 1
63069: PPUSH
63070: CALL 15093 0 1
// if event = 100 then
63074: LD_VAR 0 1
63078: PUSH
63079: LD_INT 100
63081: EQUAL
63082: IFFALSE 63088
// MC_ClassManager ( ) ;
63084: CALL 63480 0 0
// if event = 101 then
63088: LD_VAR 0 1
63092: PUSH
63093: LD_INT 101
63095: EQUAL
63096: IFFALSE 63102
// MC_RepairBuildings ( ) ;
63098: CALL 68312 0 0
// if event = 102 then
63102: LD_VAR 0 1
63106: PUSH
63107: LD_INT 102
63109: EQUAL
63110: IFFALSE 63116
// MC_Heal ( ) ;
63112: CALL 69247 0 0
// if event = 103 then
63116: LD_VAR 0 1
63120: PUSH
63121: LD_INT 103
63123: EQUAL
63124: IFFALSE 63130
// MC_Build ( ) ;
63126: CALL 69669 0 0
// if event = 104 then
63130: LD_VAR 0 1
63134: PUSH
63135: LD_INT 104
63137: EQUAL
63138: IFFALSE 63144
// MC_TurretWeapon ( ) ;
63140: CALL 71303 0 0
// if event = 105 then
63144: LD_VAR 0 1
63148: PUSH
63149: LD_INT 105
63151: EQUAL
63152: IFFALSE 63158
// MC_BuildUpgrade ( ) ;
63154: CALL 70854 0 0
// if event = 106 then
63158: LD_VAR 0 1
63162: PUSH
63163: LD_INT 106
63165: EQUAL
63166: IFFALSE 63172
// MC_PlantMines ( ) ;
63168: CALL 71733 0 0
// if event = 107 then
63172: LD_VAR 0 1
63176: PUSH
63177: LD_INT 107
63179: EQUAL
63180: IFFALSE 63186
// MC_CollectCrates ( ) ;
63182: CALL 72531 0 0
// if event = 108 then
63186: LD_VAR 0 1
63190: PUSH
63191: LD_INT 108
63193: EQUAL
63194: IFFALSE 63200
// MC_LinkRemoteControl ( ) ;
63196: CALL 74381 0 0
// if event = 109 then
63200: LD_VAR 0 1
63204: PUSH
63205: LD_INT 109
63207: EQUAL
63208: IFFALSE 63214
// MC_ProduceVehicle ( ) ;
63210: CALL 74562 0 0
// if event = 110 then
63214: LD_VAR 0 1
63218: PUSH
63219: LD_INT 110
63221: EQUAL
63222: IFFALSE 63228
// MC_SendAttack ( ) ;
63224: CALL 75028 0 0
// if event = 111 then
63228: LD_VAR 0 1
63232: PUSH
63233: LD_INT 111
63235: EQUAL
63236: IFFALSE 63242
// MC_Defend ( ) ;
63238: CALL 75136 0 0
// if event = 112 then
63242: LD_VAR 0 1
63246: PUSH
63247: LD_INT 112
63249: EQUAL
63250: IFFALSE 63256
// MC_Research ( ) ;
63252: CALL 76016 0 0
// if event = 113 then
63256: LD_VAR 0 1
63260: PUSH
63261: LD_INT 113
63263: EQUAL
63264: IFFALSE 63270
// MC_MinesTrigger ( ) ;
63266: CALL 77130 0 0
// if event = 120 then
63270: LD_VAR 0 1
63274: PUSH
63275: LD_INT 120
63277: EQUAL
63278: IFFALSE 63284
// MC_RepairVehicle ( ) ;
63280: CALL 77229 0 0
// if event = 121 then
63284: LD_VAR 0 1
63288: PUSH
63289: LD_INT 121
63291: EQUAL
63292: IFFALSE 63298
// MC_TameApe ( ) ;
63294: CALL 77998 0 0
// if event = 122 then
63298: LD_VAR 0 1
63302: PUSH
63303: LD_INT 122
63305: EQUAL
63306: IFFALSE 63312
// MC_ChangeApeClass ( ) ;
63308: CALL 78827 0 0
// if event = 123 then
63312: LD_VAR 0 1
63316: PUSH
63317: LD_INT 123
63319: EQUAL
63320: IFFALSE 63326
// MC_Bazooka ( ) ;
63322: CALL 79477 0 0
// if event = 124 then
63326: LD_VAR 0 1
63330: PUSH
63331: LD_INT 124
63333: EQUAL
63334: IFFALSE 63340
// MC_TeleportExit ( ) ;
63336: CALL 79675 0 0
// if event = 125 then
63340: LD_VAR 0 1
63344: PUSH
63345: LD_INT 125
63347: EQUAL
63348: IFFALSE 63354
// MC_Deposits ( ) ;
63350: CALL 80322 0 0
// if event = 126 then
63354: LD_VAR 0 1
63358: PUSH
63359: LD_INT 126
63361: EQUAL
63362: IFFALSE 63368
// MC_RemoteDriver ( ) ;
63364: CALL 80947 0 0
// if event = 200 then
63368: LD_VAR 0 1
63372: PUSH
63373: LD_INT 200
63375: EQUAL
63376: IFFALSE 63382
// MC_Idle ( ) ;
63378: CALL 82854 0 0
// end ;
63382: PPOPN 1
63384: END
// export function MC_Reset ( base , tag ) ; var i ; begin
63385: LD_INT 0
63387: PPUSH
63388: PPUSH
// if not mc_bases [ base ] or not tag then
63389: LD_EXP 61
63393: PUSH
63394: LD_VAR 0 1
63398: ARRAY
63399: NOT
63400: PUSH
63401: LD_VAR 0 2
63405: NOT
63406: OR
63407: IFFALSE 63411
// exit ;
63409: GO 63475
// for i in mc_bases [ base ] union mc_ape [ base ] do
63411: LD_ADDR_VAR 0 4
63415: PUSH
63416: LD_EXP 61
63420: PUSH
63421: LD_VAR 0 1
63425: ARRAY
63426: PUSH
63427: LD_EXP 90
63431: PUSH
63432: LD_VAR 0 1
63436: ARRAY
63437: UNION
63438: PUSH
63439: FOR_IN
63440: IFFALSE 63473
// if GetTag ( i ) = tag then
63442: LD_VAR 0 4
63446: PPUSH
63447: CALL_OW 110
63451: PUSH
63452: LD_VAR 0 2
63456: EQUAL
63457: IFFALSE 63471
// SetTag ( i , 0 ) ;
63459: LD_VAR 0 4
63463: PPUSH
63464: LD_INT 0
63466: PPUSH
63467: CALL_OW 109
63471: GO 63439
63473: POP
63474: POP
// end ;
63475: LD_VAR 0 3
63479: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
63480: LD_INT 0
63482: PPUSH
63483: PPUSH
63484: PPUSH
63485: PPUSH
63486: PPUSH
63487: PPUSH
63488: PPUSH
63489: PPUSH
// if not mc_bases then
63490: LD_EXP 61
63494: NOT
63495: IFFALSE 63499
// exit ;
63497: GO 63948
// for i = 1 to mc_bases do
63499: LD_ADDR_VAR 0 2
63503: PUSH
63504: DOUBLE
63505: LD_INT 1
63507: DEC
63508: ST_TO_ADDR
63509: LD_EXP 61
63513: PUSH
63514: FOR_TO
63515: IFFALSE 63946
// begin tmp := MC_ClassCheckReq ( i ) ;
63517: LD_ADDR_VAR 0 4
63521: PUSH
63522: LD_VAR 0 2
63526: PPUSH
63527: CALL 63953 0 1
63531: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
63532: LD_ADDR_EXP 102
63536: PUSH
63537: LD_EXP 102
63541: PPUSH
63542: LD_VAR 0 2
63546: PPUSH
63547: LD_VAR 0 4
63551: PPUSH
63552: CALL_OW 1
63556: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
63557: LD_ADDR_VAR 0 6
63561: PUSH
63562: LD_EXP 61
63566: PUSH
63567: LD_VAR 0 2
63571: ARRAY
63572: PPUSH
63573: LD_INT 2
63575: PUSH
63576: LD_INT 30
63578: PUSH
63579: LD_INT 4
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 30
63588: PUSH
63589: LD_INT 5
63591: PUSH
63592: EMPTY
63593: LIST
63594: LIST
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: LIST
63600: PPUSH
63601: CALL_OW 72
63605: PUSH
63606: LD_EXP 61
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: PPUSH
63617: LD_INT 2
63619: PUSH
63620: LD_INT 30
63622: PUSH
63623: LD_INT 0
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 30
63632: PUSH
63633: LD_INT 1
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: LIST
63644: PPUSH
63645: CALL_OW 72
63649: PUSH
63650: LD_EXP 61
63654: PUSH
63655: LD_VAR 0 2
63659: ARRAY
63660: PPUSH
63661: LD_INT 30
63663: PUSH
63664: LD_INT 3
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PPUSH
63671: CALL_OW 72
63675: PUSH
63676: LD_EXP 61
63680: PUSH
63681: LD_VAR 0 2
63685: ARRAY
63686: PPUSH
63687: LD_INT 2
63689: PUSH
63690: LD_INT 30
63692: PUSH
63693: LD_INT 6
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 30
63702: PUSH
63703: LD_INT 7
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 30
63712: PUSH
63713: LD_INT 8
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: PPUSH
63726: CALL_OW 72
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: ST_TO_ADDR
// for j := 1 to 4 do
63737: LD_ADDR_VAR 0 3
63741: PUSH
63742: DOUBLE
63743: LD_INT 1
63745: DEC
63746: ST_TO_ADDR
63747: LD_INT 4
63749: PUSH
63750: FOR_TO
63751: IFFALSE 63942
// begin if not tmp [ j ] then
63753: LD_VAR 0 4
63757: PUSH
63758: LD_VAR 0 3
63762: ARRAY
63763: NOT
63764: IFFALSE 63768
// continue ;
63766: GO 63750
// for p in tmp [ j ] do
63768: LD_ADDR_VAR 0 5
63772: PUSH
63773: LD_VAR 0 4
63777: PUSH
63778: LD_VAR 0 3
63782: ARRAY
63783: PUSH
63784: FOR_IN
63785: IFFALSE 63938
// begin if not b [ j ] then
63787: LD_VAR 0 6
63791: PUSH
63792: LD_VAR 0 3
63796: ARRAY
63797: NOT
63798: IFFALSE 63802
// break ;
63800: GO 63938
// e := 0 ;
63802: LD_ADDR_VAR 0 7
63806: PUSH
63807: LD_INT 0
63809: ST_TO_ADDR
// for k in b [ j ] do
63810: LD_ADDR_VAR 0 8
63814: PUSH
63815: LD_VAR 0 6
63819: PUSH
63820: LD_VAR 0 3
63824: ARRAY
63825: PUSH
63826: FOR_IN
63827: IFFALSE 63854
// if IsNotFull ( k ) then
63829: LD_VAR 0 8
63833: PPUSH
63834: CALL 18629 0 1
63838: IFFALSE 63852
// begin e := k ;
63840: LD_ADDR_VAR 0 7
63844: PUSH
63845: LD_VAR 0 8
63849: ST_TO_ADDR
// break ;
63850: GO 63854
// end ;
63852: GO 63826
63854: POP
63855: POP
// if e and not UnitGoingToBuilding ( p , e ) then
63856: LD_VAR 0 7
63860: PUSH
63861: LD_VAR 0 5
63865: PPUSH
63866: LD_VAR 0 7
63870: PPUSH
63871: CALL 52768 0 2
63875: NOT
63876: AND
63877: IFFALSE 63936
// begin if IsInUnit ( p ) then
63879: LD_VAR 0 5
63883: PPUSH
63884: CALL_OW 310
63888: IFFALSE 63899
// ComExitBuilding ( p ) ;
63890: LD_VAR 0 5
63894: PPUSH
63895: CALL_OW 122
// ComEnterUnit ( p , e ) ;
63899: LD_VAR 0 5
63903: PPUSH
63904: LD_VAR 0 7
63908: PPUSH
63909: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
63913: LD_VAR 0 5
63917: PPUSH
63918: LD_VAR 0 3
63922: PPUSH
63923: CALL_OW 183
// AddComExitBuilding ( p ) ;
63927: LD_VAR 0 5
63931: PPUSH
63932: CALL_OW 182
// end ; end ;
63936: GO 63784
63938: POP
63939: POP
// end ;
63940: GO 63750
63942: POP
63943: POP
// end ;
63944: GO 63514
63946: POP
63947: POP
// end ;
63948: LD_VAR 0 1
63952: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
63953: LD_INT 0
63955: PPUSH
63956: PPUSH
63957: PPUSH
63958: PPUSH
63959: PPUSH
63960: PPUSH
63961: PPUSH
63962: PPUSH
63963: PPUSH
63964: PPUSH
63965: PPUSH
63966: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
63967: LD_ADDR_VAR 0 2
63971: PUSH
63972: LD_INT 0
63974: PUSH
63975: LD_INT 0
63977: PUSH
63978: LD_INT 0
63980: PUSH
63981: LD_INT 0
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: LIST
63988: LIST
63989: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63990: LD_VAR 0 1
63994: NOT
63995: PUSH
63996: LD_EXP 61
64000: PUSH
64001: LD_VAR 0 1
64005: ARRAY
64006: NOT
64007: OR
64008: PUSH
64009: LD_EXP 61
64013: PUSH
64014: LD_VAR 0 1
64018: ARRAY
64019: PPUSH
64020: LD_INT 2
64022: PUSH
64023: LD_INT 30
64025: PUSH
64026: LD_INT 0
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 30
64035: PUSH
64036: LD_INT 1
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: LIST
64047: PPUSH
64048: CALL_OW 72
64052: NOT
64053: OR
64054: IFFALSE 64058
// exit ;
64056: GO 67561
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64058: LD_ADDR_VAR 0 4
64062: PUSH
64063: LD_EXP 61
64067: PUSH
64068: LD_VAR 0 1
64072: ARRAY
64073: PPUSH
64074: LD_INT 2
64076: PUSH
64077: LD_INT 25
64079: PUSH
64080: LD_INT 1
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 25
64089: PUSH
64090: LD_INT 2
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 25
64099: PUSH
64100: LD_INT 3
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 25
64109: PUSH
64110: LD_INT 4
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 25
64119: PUSH
64120: LD_INT 5
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 25
64129: PUSH
64130: LD_INT 8
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 25
64139: PUSH
64140: LD_INT 9
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: PPUSH
64157: CALL_OW 72
64161: ST_TO_ADDR
// if not tmp then
64162: LD_VAR 0 4
64166: NOT
64167: IFFALSE 64171
// exit ;
64169: GO 67561
// for i in tmp do
64171: LD_ADDR_VAR 0 3
64175: PUSH
64176: LD_VAR 0 4
64180: PUSH
64181: FOR_IN
64182: IFFALSE 64213
// if GetTag ( i ) then
64184: LD_VAR 0 3
64188: PPUSH
64189: CALL_OW 110
64193: IFFALSE 64211
// tmp := tmp diff i ;
64195: LD_ADDR_VAR 0 4
64199: PUSH
64200: LD_VAR 0 4
64204: PUSH
64205: LD_VAR 0 3
64209: DIFF
64210: ST_TO_ADDR
64211: GO 64181
64213: POP
64214: POP
// if not tmp then
64215: LD_VAR 0 4
64219: NOT
64220: IFFALSE 64224
// exit ;
64222: GO 67561
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64224: LD_ADDR_VAR 0 5
64228: PUSH
64229: LD_EXP 61
64233: PUSH
64234: LD_VAR 0 1
64238: ARRAY
64239: PPUSH
64240: LD_INT 2
64242: PUSH
64243: LD_INT 25
64245: PUSH
64246: LD_INT 1
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PUSH
64253: LD_INT 25
64255: PUSH
64256: LD_INT 5
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: PUSH
64263: LD_INT 25
64265: PUSH
64266: LD_INT 8
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 25
64275: PUSH
64276: LD_INT 9
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: PPUSH
64290: CALL_OW 72
64294: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
64295: LD_ADDR_VAR 0 6
64299: PUSH
64300: LD_EXP 61
64304: PUSH
64305: LD_VAR 0 1
64309: ARRAY
64310: PPUSH
64311: LD_INT 25
64313: PUSH
64314: LD_INT 2
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PPUSH
64321: CALL_OW 72
64325: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
64326: LD_ADDR_VAR 0 7
64330: PUSH
64331: LD_EXP 61
64335: PUSH
64336: LD_VAR 0 1
64340: ARRAY
64341: PPUSH
64342: LD_INT 25
64344: PUSH
64345: LD_INT 3
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PPUSH
64352: CALL_OW 72
64356: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
64357: LD_ADDR_VAR 0 8
64361: PUSH
64362: LD_EXP 61
64366: PUSH
64367: LD_VAR 0 1
64371: ARRAY
64372: PPUSH
64373: LD_INT 25
64375: PUSH
64376: LD_INT 4
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 24
64385: PUSH
64386: LD_INT 251
64388: PUSH
64389: EMPTY
64390: LIST
64391: LIST
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PPUSH
64397: CALL_OW 72
64401: ST_TO_ADDR
// if mc_is_defending [ base ] then
64402: LD_EXP 104
64406: PUSH
64407: LD_VAR 0 1
64411: ARRAY
64412: IFFALSE 64873
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
64414: LD_ADDR_EXP 103
64418: PUSH
64419: LD_EXP 103
64423: PPUSH
64424: LD_VAR 0 1
64428: PPUSH
64429: LD_INT 4
64431: PPUSH
64432: CALL_OW 1
64436: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64437: LD_ADDR_VAR 0 12
64441: PUSH
64442: LD_EXP 61
64446: PUSH
64447: LD_VAR 0 1
64451: ARRAY
64452: PPUSH
64453: LD_INT 2
64455: PUSH
64456: LD_INT 30
64458: PUSH
64459: LD_INT 4
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 30
64468: PUSH
64469: LD_INT 5
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: LIST
64480: PPUSH
64481: CALL_OW 72
64485: ST_TO_ADDR
// if not b then
64486: LD_VAR 0 12
64490: NOT
64491: IFFALSE 64495
// exit ;
64493: GO 67561
// p := [ ] ;
64495: LD_ADDR_VAR 0 11
64499: PUSH
64500: EMPTY
64501: ST_TO_ADDR
// if sci >= 2 then
64502: LD_VAR 0 8
64506: PUSH
64507: LD_INT 2
64509: GREATEREQUAL
64510: IFFALSE 64541
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
64512: LD_ADDR_VAR 0 8
64516: PUSH
64517: LD_VAR 0 8
64521: PUSH
64522: LD_INT 1
64524: ARRAY
64525: PUSH
64526: LD_VAR 0 8
64530: PUSH
64531: LD_INT 2
64533: ARRAY
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: ST_TO_ADDR
64539: GO 64602
// if sci = 1 then
64541: LD_VAR 0 8
64545: PUSH
64546: LD_INT 1
64548: EQUAL
64549: IFFALSE 64570
// sci := [ sci [ 1 ] ] else
64551: LD_ADDR_VAR 0 8
64555: PUSH
64556: LD_VAR 0 8
64560: PUSH
64561: LD_INT 1
64563: ARRAY
64564: PUSH
64565: EMPTY
64566: LIST
64567: ST_TO_ADDR
64568: GO 64602
// if sci = 0 then
64570: LD_VAR 0 8
64574: PUSH
64575: LD_INT 0
64577: EQUAL
64578: IFFALSE 64602
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
64580: LD_ADDR_VAR 0 11
64584: PUSH
64585: LD_VAR 0 4
64589: PPUSH
64590: LD_INT 4
64592: PPUSH
64593: CALL 52640 0 2
64597: PUSH
64598: LD_INT 1
64600: ARRAY
64601: ST_TO_ADDR
// if eng > 4 then
64602: LD_VAR 0 6
64606: PUSH
64607: LD_INT 4
64609: GREATER
64610: IFFALSE 64656
// for i = eng downto 4 do
64612: LD_ADDR_VAR 0 3
64616: PUSH
64617: DOUBLE
64618: LD_VAR 0 6
64622: INC
64623: ST_TO_ADDR
64624: LD_INT 4
64626: PUSH
64627: FOR_DOWNTO
64628: IFFALSE 64654
// eng := eng diff eng [ i ] ;
64630: LD_ADDR_VAR 0 6
64634: PUSH
64635: LD_VAR 0 6
64639: PUSH
64640: LD_VAR 0 6
64644: PUSH
64645: LD_VAR 0 3
64649: ARRAY
64650: DIFF
64651: ST_TO_ADDR
64652: GO 64627
64654: POP
64655: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
64656: LD_ADDR_VAR 0 4
64660: PUSH
64661: LD_VAR 0 4
64665: PUSH
64666: LD_VAR 0 5
64670: PUSH
64671: LD_VAR 0 6
64675: UNION
64676: PUSH
64677: LD_VAR 0 7
64681: UNION
64682: PUSH
64683: LD_VAR 0 8
64687: UNION
64688: DIFF
64689: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
64690: LD_ADDR_VAR 0 13
64694: PUSH
64695: LD_EXP 61
64699: PUSH
64700: LD_VAR 0 1
64704: ARRAY
64705: PPUSH
64706: LD_INT 2
64708: PUSH
64709: LD_INT 30
64711: PUSH
64712: LD_INT 32
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: LD_INT 30
64721: PUSH
64722: LD_INT 31
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: LIST
64733: PPUSH
64734: CALL_OW 72
64738: PUSH
64739: LD_EXP 61
64743: PUSH
64744: LD_VAR 0 1
64748: ARRAY
64749: PPUSH
64750: LD_INT 2
64752: PUSH
64753: LD_INT 30
64755: PUSH
64756: LD_INT 4
64758: PUSH
64759: EMPTY
64760: LIST
64761: LIST
64762: PUSH
64763: LD_INT 30
64765: PUSH
64766: LD_INT 5
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: LIST
64777: PPUSH
64778: CALL_OW 72
64782: PUSH
64783: LD_INT 6
64785: MUL
64786: PLUS
64787: ST_TO_ADDR
// if bcount < tmp then
64788: LD_VAR 0 13
64792: PUSH
64793: LD_VAR 0 4
64797: LESS
64798: IFFALSE 64844
// for i = tmp downto bcount do
64800: LD_ADDR_VAR 0 3
64804: PUSH
64805: DOUBLE
64806: LD_VAR 0 4
64810: INC
64811: ST_TO_ADDR
64812: LD_VAR 0 13
64816: PUSH
64817: FOR_DOWNTO
64818: IFFALSE 64842
// tmp := Delete ( tmp , tmp ) ;
64820: LD_ADDR_VAR 0 4
64824: PUSH
64825: LD_VAR 0 4
64829: PPUSH
64830: LD_VAR 0 4
64834: PPUSH
64835: CALL_OW 3
64839: ST_TO_ADDR
64840: GO 64817
64842: POP
64843: POP
// result := [ tmp , 0 , 0 , p ] ;
64844: LD_ADDR_VAR 0 2
64848: PUSH
64849: LD_VAR 0 4
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 0
64859: PUSH
64860: LD_VAR 0 11
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: LIST
64869: LIST
64870: ST_TO_ADDR
// exit ;
64871: GO 67561
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64873: LD_EXP 61
64877: PUSH
64878: LD_VAR 0 1
64882: ARRAY
64883: PPUSH
64884: LD_INT 2
64886: PUSH
64887: LD_INT 30
64889: PUSH
64890: LD_INT 6
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 30
64899: PUSH
64900: LD_INT 7
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 30
64909: PUSH
64910: LD_INT 8
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: PPUSH
64923: CALL_OW 72
64927: NOT
64928: PUSH
64929: LD_EXP 61
64933: PUSH
64934: LD_VAR 0 1
64938: ARRAY
64939: PPUSH
64940: LD_INT 30
64942: PUSH
64943: LD_INT 3
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PPUSH
64950: CALL_OW 72
64954: NOT
64955: AND
64956: IFFALSE 65028
// begin if eng = tmp then
64958: LD_VAR 0 6
64962: PUSH
64963: LD_VAR 0 4
64967: EQUAL
64968: IFFALSE 64972
// exit ;
64970: GO 67561
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
64972: LD_ADDR_EXP 103
64976: PUSH
64977: LD_EXP 103
64981: PPUSH
64982: LD_VAR 0 1
64986: PPUSH
64987: LD_INT 1
64989: PPUSH
64990: CALL_OW 1
64994: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
64995: LD_ADDR_VAR 0 2
64999: PUSH
65000: LD_INT 0
65002: PUSH
65003: LD_VAR 0 4
65007: PUSH
65008: LD_VAR 0 6
65012: DIFF
65013: PUSH
65014: LD_INT 0
65016: PUSH
65017: LD_INT 0
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: ST_TO_ADDR
// exit ;
65026: GO 67561
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65028: LD_EXP 88
65032: PUSH
65033: LD_EXP 87
65037: PUSH
65038: LD_VAR 0 1
65042: ARRAY
65043: ARRAY
65044: PUSH
65045: LD_EXP 61
65049: PUSH
65050: LD_VAR 0 1
65054: ARRAY
65055: PPUSH
65056: LD_INT 2
65058: PUSH
65059: LD_INT 30
65061: PUSH
65062: LD_INT 6
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 30
65071: PUSH
65072: LD_INT 7
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 30
65081: PUSH
65082: LD_INT 8
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: EMPTY
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: PPUSH
65095: CALL_OW 72
65099: AND
65100: PUSH
65101: LD_EXP 61
65105: PUSH
65106: LD_VAR 0 1
65110: ARRAY
65111: PPUSH
65112: LD_INT 30
65114: PUSH
65115: LD_INT 3
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PPUSH
65122: CALL_OW 72
65126: NOT
65127: AND
65128: IFFALSE 65342
// begin if sci >= 6 then
65130: LD_VAR 0 8
65134: PUSH
65135: LD_INT 6
65137: GREATEREQUAL
65138: IFFALSE 65142
// exit ;
65140: GO 67561
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
65142: LD_ADDR_EXP 103
65146: PUSH
65147: LD_EXP 103
65151: PPUSH
65152: LD_VAR 0 1
65156: PPUSH
65157: LD_INT 2
65159: PPUSH
65160: CALL_OW 1
65164: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
65165: LD_ADDR_VAR 0 9
65169: PUSH
65170: LD_VAR 0 4
65174: PUSH
65175: LD_VAR 0 8
65179: DIFF
65180: PPUSH
65181: LD_INT 4
65183: PPUSH
65184: CALL 52640 0 2
65188: ST_TO_ADDR
// p := [ ] ;
65189: LD_ADDR_VAR 0 11
65193: PUSH
65194: EMPTY
65195: ST_TO_ADDR
// if sci < 6 and sort > 6 then
65196: LD_VAR 0 8
65200: PUSH
65201: LD_INT 6
65203: LESS
65204: PUSH
65205: LD_VAR 0 9
65209: PUSH
65210: LD_INT 6
65212: GREATER
65213: AND
65214: IFFALSE 65295
// begin for i = 1 to 6 - sci do
65216: LD_ADDR_VAR 0 3
65220: PUSH
65221: DOUBLE
65222: LD_INT 1
65224: DEC
65225: ST_TO_ADDR
65226: LD_INT 6
65228: PUSH
65229: LD_VAR 0 8
65233: MINUS
65234: PUSH
65235: FOR_TO
65236: IFFALSE 65291
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
65238: LD_ADDR_VAR 0 11
65242: PUSH
65243: LD_VAR 0 11
65247: PPUSH
65248: LD_VAR 0 11
65252: PUSH
65253: LD_INT 1
65255: PLUS
65256: PPUSH
65257: LD_VAR 0 9
65261: PUSH
65262: LD_INT 1
65264: ARRAY
65265: PPUSH
65266: CALL_OW 2
65270: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
65271: LD_ADDR_VAR 0 9
65275: PUSH
65276: LD_VAR 0 9
65280: PPUSH
65281: LD_INT 1
65283: PPUSH
65284: CALL_OW 3
65288: ST_TO_ADDR
// end ;
65289: GO 65235
65291: POP
65292: POP
// end else
65293: GO 65315
// if sort then
65295: LD_VAR 0 9
65299: IFFALSE 65315
// p := sort [ 1 ] ;
65301: LD_ADDR_VAR 0 11
65305: PUSH
65306: LD_VAR 0 9
65310: PUSH
65311: LD_INT 1
65313: ARRAY
65314: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
65315: LD_ADDR_VAR 0 2
65319: PUSH
65320: LD_INT 0
65322: PUSH
65323: LD_INT 0
65325: PUSH
65326: LD_INT 0
65328: PUSH
65329: LD_VAR 0 11
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: ST_TO_ADDR
// exit ;
65340: GO 67561
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65342: LD_EXP 88
65346: PUSH
65347: LD_EXP 87
65351: PUSH
65352: LD_VAR 0 1
65356: ARRAY
65357: ARRAY
65358: PUSH
65359: LD_EXP 61
65363: PUSH
65364: LD_VAR 0 1
65368: ARRAY
65369: PPUSH
65370: LD_INT 2
65372: PUSH
65373: LD_INT 30
65375: PUSH
65376: LD_INT 6
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 30
65385: PUSH
65386: LD_INT 7
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 30
65395: PUSH
65396: LD_INT 8
65398: PUSH
65399: EMPTY
65400: LIST
65401: LIST
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: PPUSH
65409: CALL_OW 72
65413: AND
65414: PUSH
65415: LD_EXP 61
65419: PUSH
65420: LD_VAR 0 1
65424: ARRAY
65425: PPUSH
65426: LD_INT 30
65428: PUSH
65429: LD_INT 3
65431: PUSH
65432: EMPTY
65433: LIST
65434: LIST
65435: PPUSH
65436: CALL_OW 72
65440: AND
65441: IFFALSE 66175
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
65443: LD_ADDR_EXP 103
65447: PUSH
65448: LD_EXP 103
65452: PPUSH
65453: LD_VAR 0 1
65457: PPUSH
65458: LD_INT 3
65460: PPUSH
65461: CALL_OW 1
65465: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65466: LD_ADDR_VAR 0 2
65470: PUSH
65471: LD_INT 0
65473: PUSH
65474: LD_INT 0
65476: PUSH
65477: LD_INT 0
65479: PUSH
65480: LD_INT 0
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: ST_TO_ADDR
// if not eng then
65489: LD_VAR 0 6
65493: NOT
65494: IFFALSE 65557
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
65496: LD_ADDR_VAR 0 11
65500: PUSH
65501: LD_VAR 0 4
65505: PPUSH
65506: LD_INT 2
65508: PPUSH
65509: CALL 52640 0 2
65513: PUSH
65514: LD_INT 1
65516: ARRAY
65517: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
65518: LD_ADDR_VAR 0 2
65522: PUSH
65523: LD_VAR 0 2
65527: PPUSH
65528: LD_INT 2
65530: PPUSH
65531: LD_VAR 0 11
65535: PPUSH
65536: CALL_OW 1
65540: ST_TO_ADDR
// tmp := tmp diff p ;
65541: LD_ADDR_VAR 0 4
65545: PUSH
65546: LD_VAR 0 4
65550: PUSH
65551: LD_VAR 0 11
65555: DIFF
65556: ST_TO_ADDR
// end ; if tmp and sci < 6 then
65557: LD_VAR 0 4
65561: PUSH
65562: LD_VAR 0 8
65566: PUSH
65567: LD_INT 6
65569: LESS
65570: AND
65571: IFFALSE 65759
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
65573: LD_ADDR_VAR 0 9
65577: PUSH
65578: LD_VAR 0 4
65582: PUSH
65583: LD_VAR 0 8
65587: PUSH
65588: LD_VAR 0 7
65592: UNION
65593: DIFF
65594: PPUSH
65595: LD_INT 4
65597: PPUSH
65598: CALL 52640 0 2
65602: ST_TO_ADDR
// p := [ ] ;
65603: LD_ADDR_VAR 0 11
65607: PUSH
65608: EMPTY
65609: ST_TO_ADDR
// if sort then
65610: LD_VAR 0 9
65614: IFFALSE 65730
// for i = 1 to 6 - sci do
65616: LD_ADDR_VAR 0 3
65620: PUSH
65621: DOUBLE
65622: LD_INT 1
65624: DEC
65625: ST_TO_ADDR
65626: LD_INT 6
65628: PUSH
65629: LD_VAR 0 8
65633: MINUS
65634: PUSH
65635: FOR_TO
65636: IFFALSE 65728
// begin if i = sort then
65638: LD_VAR 0 3
65642: PUSH
65643: LD_VAR 0 9
65647: EQUAL
65648: IFFALSE 65652
// break ;
65650: GO 65728
// if GetClass ( i ) = 4 then
65652: LD_VAR 0 3
65656: PPUSH
65657: CALL_OW 257
65661: PUSH
65662: LD_INT 4
65664: EQUAL
65665: IFFALSE 65669
// continue ;
65667: GO 65635
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65669: LD_ADDR_VAR 0 11
65673: PUSH
65674: LD_VAR 0 11
65678: PPUSH
65679: LD_VAR 0 11
65683: PUSH
65684: LD_INT 1
65686: PLUS
65687: PPUSH
65688: LD_VAR 0 9
65692: PUSH
65693: LD_VAR 0 3
65697: ARRAY
65698: PPUSH
65699: CALL_OW 2
65703: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65704: LD_ADDR_VAR 0 4
65708: PUSH
65709: LD_VAR 0 4
65713: PUSH
65714: LD_VAR 0 9
65718: PUSH
65719: LD_VAR 0 3
65723: ARRAY
65724: DIFF
65725: ST_TO_ADDR
// end ;
65726: GO 65635
65728: POP
65729: POP
// if p then
65730: LD_VAR 0 11
65734: IFFALSE 65759
// result := Replace ( result , 4 , p ) ;
65736: LD_ADDR_VAR 0 2
65740: PUSH
65741: LD_VAR 0 2
65745: PPUSH
65746: LD_INT 4
65748: PPUSH
65749: LD_VAR 0 11
65753: PPUSH
65754: CALL_OW 1
65758: ST_TO_ADDR
// end ; if tmp and mech < 6 then
65759: LD_VAR 0 4
65763: PUSH
65764: LD_VAR 0 7
65768: PUSH
65769: LD_INT 6
65771: LESS
65772: AND
65773: IFFALSE 65961
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65775: LD_ADDR_VAR 0 9
65779: PUSH
65780: LD_VAR 0 4
65784: PUSH
65785: LD_VAR 0 8
65789: PUSH
65790: LD_VAR 0 7
65794: UNION
65795: DIFF
65796: PPUSH
65797: LD_INT 3
65799: PPUSH
65800: CALL 52640 0 2
65804: ST_TO_ADDR
// p := [ ] ;
65805: LD_ADDR_VAR 0 11
65809: PUSH
65810: EMPTY
65811: ST_TO_ADDR
// if sort then
65812: LD_VAR 0 9
65816: IFFALSE 65932
// for i = 1 to 6 - mech do
65818: LD_ADDR_VAR 0 3
65822: PUSH
65823: DOUBLE
65824: LD_INT 1
65826: DEC
65827: ST_TO_ADDR
65828: LD_INT 6
65830: PUSH
65831: LD_VAR 0 7
65835: MINUS
65836: PUSH
65837: FOR_TO
65838: IFFALSE 65930
// begin if i = sort then
65840: LD_VAR 0 3
65844: PUSH
65845: LD_VAR 0 9
65849: EQUAL
65850: IFFALSE 65854
// break ;
65852: GO 65930
// if GetClass ( i ) = 3 then
65854: LD_VAR 0 3
65858: PPUSH
65859: CALL_OW 257
65863: PUSH
65864: LD_INT 3
65866: EQUAL
65867: IFFALSE 65871
// continue ;
65869: GO 65837
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65871: LD_ADDR_VAR 0 11
65875: PUSH
65876: LD_VAR 0 11
65880: PPUSH
65881: LD_VAR 0 11
65885: PUSH
65886: LD_INT 1
65888: PLUS
65889: PPUSH
65890: LD_VAR 0 9
65894: PUSH
65895: LD_VAR 0 3
65899: ARRAY
65900: PPUSH
65901: CALL_OW 2
65905: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65906: LD_ADDR_VAR 0 4
65910: PUSH
65911: LD_VAR 0 4
65915: PUSH
65916: LD_VAR 0 9
65920: PUSH
65921: LD_VAR 0 3
65925: ARRAY
65926: DIFF
65927: ST_TO_ADDR
// end ;
65928: GO 65837
65930: POP
65931: POP
// if p then
65932: LD_VAR 0 11
65936: IFFALSE 65961
// result := Replace ( result , 3 , p ) ;
65938: LD_ADDR_VAR 0 2
65942: PUSH
65943: LD_VAR 0 2
65947: PPUSH
65948: LD_INT 3
65950: PPUSH
65951: LD_VAR 0 11
65955: PPUSH
65956: CALL_OW 1
65960: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
65961: LD_VAR 0 4
65965: PUSH
65966: LD_INT 6
65968: GREATER
65969: PUSH
65970: LD_VAR 0 6
65974: PUSH
65975: LD_INT 6
65977: LESS
65978: AND
65979: IFFALSE 66173
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
65981: LD_ADDR_VAR 0 9
65985: PUSH
65986: LD_VAR 0 4
65990: PUSH
65991: LD_VAR 0 8
65995: PUSH
65996: LD_VAR 0 7
66000: UNION
66001: PUSH
66002: LD_VAR 0 6
66006: UNION
66007: DIFF
66008: PPUSH
66009: LD_INT 2
66011: PPUSH
66012: CALL 52640 0 2
66016: ST_TO_ADDR
// p := [ ] ;
66017: LD_ADDR_VAR 0 11
66021: PUSH
66022: EMPTY
66023: ST_TO_ADDR
// if sort then
66024: LD_VAR 0 9
66028: IFFALSE 66144
// for i = 1 to 6 - eng do
66030: LD_ADDR_VAR 0 3
66034: PUSH
66035: DOUBLE
66036: LD_INT 1
66038: DEC
66039: ST_TO_ADDR
66040: LD_INT 6
66042: PUSH
66043: LD_VAR 0 6
66047: MINUS
66048: PUSH
66049: FOR_TO
66050: IFFALSE 66142
// begin if i = sort then
66052: LD_VAR 0 3
66056: PUSH
66057: LD_VAR 0 9
66061: EQUAL
66062: IFFALSE 66066
// break ;
66064: GO 66142
// if GetClass ( i ) = 2 then
66066: LD_VAR 0 3
66070: PPUSH
66071: CALL_OW 257
66075: PUSH
66076: LD_INT 2
66078: EQUAL
66079: IFFALSE 66083
// continue ;
66081: GO 66049
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66083: LD_ADDR_VAR 0 11
66087: PUSH
66088: LD_VAR 0 11
66092: PPUSH
66093: LD_VAR 0 11
66097: PUSH
66098: LD_INT 1
66100: PLUS
66101: PPUSH
66102: LD_VAR 0 9
66106: PUSH
66107: LD_VAR 0 3
66111: ARRAY
66112: PPUSH
66113: CALL_OW 2
66117: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66118: LD_ADDR_VAR 0 4
66122: PUSH
66123: LD_VAR 0 4
66127: PUSH
66128: LD_VAR 0 9
66132: PUSH
66133: LD_VAR 0 3
66137: ARRAY
66138: DIFF
66139: ST_TO_ADDR
// end ;
66140: GO 66049
66142: POP
66143: POP
// if p then
66144: LD_VAR 0 11
66148: IFFALSE 66173
// result := Replace ( result , 2 , p ) ;
66150: LD_ADDR_VAR 0 2
66154: PUSH
66155: LD_VAR 0 2
66159: PPUSH
66160: LD_INT 2
66162: PPUSH
66163: LD_VAR 0 11
66167: PPUSH
66168: CALL_OW 1
66172: ST_TO_ADDR
// end ; exit ;
66173: GO 67561
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
66175: LD_EXP 88
66179: PUSH
66180: LD_EXP 87
66184: PUSH
66185: LD_VAR 0 1
66189: ARRAY
66190: ARRAY
66191: NOT
66192: PUSH
66193: LD_EXP 61
66197: PUSH
66198: LD_VAR 0 1
66202: ARRAY
66203: PPUSH
66204: LD_INT 30
66206: PUSH
66207: LD_INT 3
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PPUSH
66214: CALL_OW 72
66218: AND
66219: PUSH
66220: LD_EXP 66
66224: PUSH
66225: LD_VAR 0 1
66229: ARRAY
66230: AND
66231: IFFALSE 66839
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
66233: LD_ADDR_EXP 103
66237: PUSH
66238: LD_EXP 103
66242: PPUSH
66243: LD_VAR 0 1
66247: PPUSH
66248: LD_INT 5
66250: PPUSH
66251: CALL_OW 1
66255: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66256: LD_ADDR_VAR 0 2
66260: PUSH
66261: LD_INT 0
66263: PUSH
66264: LD_INT 0
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: LD_INT 0
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: ST_TO_ADDR
// if sci > 1 then
66279: LD_VAR 0 8
66283: PUSH
66284: LD_INT 1
66286: GREATER
66287: IFFALSE 66315
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
66289: LD_ADDR_VAR 0 4
66293: PUSH
66294: LD_VAR 0 4
66298: PUSH
66299: LD_VAR 0 8
66303: PUSH
66304: LD_VAR 0 8
66308: PUSH
66309: LD_INT 1
66311: ARRAY
66312: DIFF
66313: DIFF
66314: ST_TO_ADDR
// if tmp and not sci then
66315: LD_VAR 0 4
66319: PUSH
66320: LD_VAR 0 8
66324: NOT
66325: AND
66326: IFFALSE 66395
// begin sort := SortBySkill ( tmp , 4 ) ;
66328: LD_ADDR_VAR 0 9
66332: PUSH
66333: LD_VAR 0 4
66337: PPUSH
66338: LD_INT 4
66340: PPUSH
66341: CALL 52640 0 2
66345: ST_TO_ADDR
// if sort then
66346: LD_VAR 0 9
66350: IFFALSE 66366
// p := sort [ 1 ] ;
66352: LD_ADDR_VAR 0 11
66356: PUSH
66357: LD_VAR 0 9
66361: PUSH
66362: LD_INT 1
66364: ARRAY
66365: ST_TO_ADDR
// if p then
66366: LD_VAR 0 11
66370: IFFALSE 66395
// result := Replace ( result , 4 , p ) ;
66372: LD_ADDR_VAR 0 2
66376: PUSH
66377: LD_VAR 0 2
66381: PPUSH
66382: LD_INT 4
66384: PPUSH
66385: LD_VAR 0 11
66389: PPUSH
66390: CALL_OW 1
66394: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66395: LD_ADDR_VAR 0 4
66399: PUSH
66400: LD_VAR 0 4
66404: PUSH
66405: LD_VAR 0 7
66409: DIFF
66410: ST_TO_ADDR
// if tmp and mech < 6 then
66411: LD_VAR 0 4
66415: PUSH
66416: LD_VAR 0 7
66420: PUSH
66421: LD_INT 6
66423: LESS
66424: AND
66425: IFFALSE 66613
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66427: LD_ADDR_VAR 0 9
66431: PUSH
66432: LD_VAR 0 4
66436: PUSH
66437: LD_VAR 0 8
66441: PUSH
66442: LD_VAR 0 7
66446: UNION
66447: DIFF
66448: PPUSH
66449: LD_INT 3
66451: PPUSH
66452: CALL 52640 0 2
66456: ST_TO_ADDR
// p := [ ] ;
66457: LD_ADDR_VAR 0 11
66461: PUSH
66462: EMPTY
66463: ST_TO_ADDR
// if sort then
66464: LD_VAR 0 9
66468: IFFALSE 66584
// for i = 1 to 6 - mech do
66470: LD_ADDR_VAR 0 3
66474: PUSH
66475: DOUBLE
66476: LD_INT 1
66478: DEC
66479: ST_TO_ADDR
66480: LD_INT 6
66482: PUSH
66483: LD_VAR 0 7
66487: MINUS
66488: PUSH
66489: FOR_TO
66490: IFFALSE 66582
// begin if i = sort then
66492: LD_VAR 0 3
66496: PUSH
66497: LD_VAR 0 9
66501: EQUAL
66502: IFFALSE 66506
// break ;
66504: GO 66582
// if GetClass ( i ) = 3 then
66506: LD_VAR 0 3
66510: PPUSH
66511: CALL_OW 257
66515: PUSH
66516: LD_INT 3
66518: EQUAL
66519: IFFALSE 66523
// continue ;
66521: GO 66489
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66523: LD_ADDR_VAR 0 11
66527: PUSH
66528: LD_VAR 0 11
66532: PPUSH
66533: LD_VAR 0 11
66537: PUSH
66538: LD_INT 1
66540: PLUS
66541: PPUSH
66542: LD_VAR 0 9
66546: PUSH
66547: LD_VAR 0 3
66551: ARRAY
66552: PPUSH
66553: CALL_OW 2
66557: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66558: LD_ADDR_VAR 0 4
66562: PUSH
66563: LD_VAR 0 4
66567: PUSH
66568: LD_VAR 0 9
66572: PUSH
66573: LD_VAR 0 3
66577: ARRAY
66578: DIFF
66579: ST_TO_ADDR
// end ;
66580: GO 66489
66582: POP
66583: POP
// if p then
66584: LD_VAR 0 11
66588: IFFALSE 66613
// result := Replace ( result , 3 , p ) ;
66590: LD_ADDR_VAR 0 2
66594: PUSH
66595: LD_VAR 0 2
66599: PPUSH
66600: LD_INT 3
66602: PPUSH
66603: LD_VAR 0 11
66607: PPUSH
66608: CALL_OW 1
66612: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66613: LD_ADDR_VAR 0 4
66617: PUSH
66618: LD_VAR 0 4
66622: PUSH
66623: LD_VAR 0 6
66627: DIFF
66628: ST_TO_ADDR
// if tmp and eng < 6 then
66629: LD_VAR 0 4
66633: PUSH
66634: LD_VAR 0 6
66638: PUSH
66639: LD_INT 6
66641: LESS
66642: AND
66643: IFFALSE 66837
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66645: LD_ADDR_VAR 0 9
66649: PUSH
66650: LD_VAR 0 4
66654: PUSH
66655: LD_VAR 0 8
66659: PUSH
66660: LD_VAR 0 7
66664: UNION
66665: PUSH
66666: LD_VAR 0 6
66670: UNION
66671: DIFF
66672: PPUSH
66673: LD_INT 2
66675: PPUSH
66676: CALL 52640 0 2
66680: ST_TO_ADDR
// p := [ ] ;
66681: LD_ADDR_VAR 0 11
66685: PUSH
66686: EMPTY
66687: ST_TO_ADDR
// if sort then
66688: LD_VAR 0 9
66692: IFFALSE 66808
// for i = 1 to 6 - eng do
66694: LD_ADDR_VAR 0 3
66698: PUSH
66699: DOUBLE
66700: LD_INT 1
66702: DEC
66703: ST_TO_ADDR
66704: LD_INT 6
66706: PUSH
66707: LD_VAR 0 6
66711: MINUS
66712: PUSH
66713: FOR_TO
66714: IFFALSE 66806
// begin if i = sort then
66716: LD_VAR 0 3
66720: PUSH
66721: LD_VAR 0 9
66725: EQUAL
66726: IFFALSE 66730
// break ;
66728: GO 66806
// if GetClass ( i ) = 2 then
66730: LD_VAR 0 3
66734: PPUSH
66735: CALL_OW 257
66739: PUSH
66740: LD_INT 2
66742: EQUAL
66743: IFFALSE 66747
// continue ;
66745: GO 66713
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66747: LD_ADDR_VAR 0 11
66751: PUSH
66752: LD_VAR 0 11
66756: PPUSH
66757: LD_VAR 0 11
66761: PUSH
66762: LD_INT 1
66764: PLUS
66765: PPUSH
66766: LD_VAR 0 9
66770: PUSH
66771: LD_VAR 0 3
66775: ARRAY
66776: PPUSH
66777: CALL_OW 2
66781: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66782: LD_ADDR_VAR 0 4
66786: PUSH
66787: LD_VAR 0 4
66791: PUSH
66792: LD_VAR 0 9
66796: PUSH
66797: LD_VAR 0 3
66801: ARRAY
66802: DIFF
66803: ST_TO_ADDR
// end ;
66804: GO 66713
66806: POP
66807: POP
// if p then
66808: LD_VAR 0 11
66812: IFFALSE 66837
// result := Replace ( result , 2 , p ) ;
66814: LD_ADDR_VAR 0 2
66818: PUSH
66819: LD_VAR 0 2
66823: PPUSH
66824: LD_INT 2
66826: PPUSH
66827: LD_VAR 0 11
66831: PPUSH
66832: CALL_OW 1
66836: ST_TO_ADDR
// end ; exit ;
66837: GO 67561
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
66839: LD_EXP 88
66843: PUSH
66844: LD_EXP 87
66848: PUSH
66849: LD_VAR 0 1
66853: ARRAY
66854: ARRAY
66855: NOT
66856: PUSH
66857: LD_EXP 61
66861: PUSH
66862: LD_VAR 0 1
66866: ARRAY
66867: PPUSH
66868: LD_INT 30
66870: PUSH
66871: LD_INT 3
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PPUSH
66878: CALL_OW 72
66882: AND
66883: PUSH
66884: LD_EXP 66
66888: PUSH
66889: LD_VAR 0 1
66893: ARRAY
66894: NOT
66895: AND
66896: IFFALSE 67561
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
66898: LD_ADDR_EXP 103
66902: PUSH
66903: LD_EXP 103
66907: PPUSH
66908: LD_VAR 0 1
66912: PPUSH
66913: LD_INT 6
66915: PPUSH
66916: CALL_OW 1
66920: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66921: LD_ADDR_VAR 0 2
66925: PUSH
66926: LD_INT 0
66928: PUSH
66929: LD_INT 0
66931: PUSH
66932: LD_INT 0
66934: PUSH
66935: LD_INT 0
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: ST_TO_ADDR
// if sci >= 1 then
66944: LD_VAR 0 8
66948: PUSH
66949: LD_INT 1
66951: GREATEREQUAL
66952: IFFALSE 66974
// tmp := tmp diff sci [ 1 ] ;
66954: LD_ADDR_VAR 0 4
66958: PUSH
66959: LD_VAR 0 4
66963: PUSH
66964: LD_VAR 0 8
66968: PUSH
66969: LD_INT 1
66971: ARRAY
66972: DIFF
66973: ST_TO_ADDR
// if tmp and not sci then
66974: LD_VAR 0 4
66978: PUSH
66979: LD_VAR 0 8
66983: NOT
66984: AND
66985: IFFALSE 67054
// begin sort := SortBySkill ( tmp , 4 ) ;
66987: LD_ADDR_VAR 0 9
66991: PUSH
66992: LD_VAR 0 4
66996: PPUSH
66997: LD_INT 4
66999: PPUSH
67000: CALL 52640 0 2
67004: ST_TO_ADDR
// if sort then
67005: LD_VAR 0 9
67009: IFFALSE 67025
// p := sort [ 1 ] ;
67011: LD_ADDR_VAR 0 11
67015: PUSH
67016: LD_VAR 0 9
67020: PUSH
67021: LD_INT 1
67023: ARRAY
67024: ST_TO_ADDR
// if p then
67025: LD_VAR 0 11
67029: IFFALSE 67054
// result := Replace ( result , 4 , p ) ;
67031: LD_ADDR_VAR 0 2
67035: PUSH
67036: LD_VAR 0 2
67040: PPUSH
67041: LD_INT 4
67043: PPUSH
67044: LD_VAR 0 11
67048: PPUSH
67049: CALL_OW 1
67053: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67054: LD_ADDR_VAR 0 4
67058: PUSH
67059: LD_VAR 0 4
67063: PUSH
67064: LD_VAR 0 7
67068: DIFF
67069: ST_TO_ADDR
// if tmp and mech < 6 then
67070: LD_VAR 0 4
67074: PUSH
67075: LD_VAR 0 7
67079: PUSH
67080: LD_INT 6
67082: LESS
67083: AND
67084: IFFALSE 67266
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67086: LD_ADDR_VAR 0 9
67090: PUSH
67091: LD_VAR 0 4
67095: PUSH
67096: LD_VAR 0 7
67100: DIFF
67101: PPUSH
67102: LD_INT 3
67104: PPUSH
67105: CALL 52640 0 2
67109: ST_TO_ADDR
// p := [ ] ;
67110: LD_ADDR_VAR 0 11
67114: PUSH
67115: EMPTY
67116: ST_TO_ADDR
// if sort then
67117: LD_VAR 0 9
67121: IFFALSE 67237
// for i = 1 to 6 - mech do
67123: LD_ADDR_VAR 0 3
67127: PUSH
67128: DOUBLE
67129: LD_INT 1
67131: DEC
67132: ST_TO_ADDR
67133: LD_INT 6
67135: PUSH
67136: LD_VAR 0 7
67140: MINUS
67141: PUSH
67142: FOR_TO
67143: IFFALSE 67235
// begin if i = sort then
67145: LD_VAR 0 3
67149: PUSH
67150: LD_VAR 0 9
67154: EQUAL
67155: IFFALSE 67159
// break ;
67157: GO 67235
// if GetClass ( i ) = 3 then
67159: LD_VAR 0 3
67163: PPUSH
67164: CALL_OW 257
67168: PUSH
67169: LD_INT 3
67171: EQUAL
67172: IFFALSE 67176
// continue ;
67174: GO 67142
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67176: LD_ADDR_VAR 0 11
67180: PUSH
67181: LD_VAR 0 11
67185: PPUSH
67186: LD_VAR 0 11
67190: PUSH
67191: LD_INT 1
67193: PLUS
67194: PPUSH
67195: LD_VAR 0 9
67199: PUSH
67200: LD_VAR 0 3
67204: ARRAY
67205: PPUSH
67206: CALL_OW 2
67210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67211: LD_ADDR_VAR 0 4
67215: PUSH
67216: LD_VAR 0 4
67220: PUSH
67221: LD_VAR 0 9
67225: PUSH
67226: LD_VAR 0 3
67230: ARRAY
67231: DIFF
67232: ST_TO_ADDR
// end ;
67233: GO 67142
67235: POP
67236: POP
// if p then
67237: LD_VAR 0 11
67241: IFFALSE 67266
// result := Replace ( result , 3 , p ) ;
67243: LD_ADDR_VAR 0 2
67247: PUSH
67248: LD_VAR 0 2
67252: PPUSH
67253: LD_INT 3
67255: PPUSH
67256: LD_VAR 0 11
67260: PPUSH
67261: CALL_OW 1
67265: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67266: LD_ADDR_VAR 0 4
67270: PUSH
67271: LD_VAR 0 4
67275: PUSH
67276: LD_VAR 0 6
67280: DIFF
67281: ST_TO_ADDR
// if tmp and eng < 4 then
67282: LD_VAR 0 4
67286: PUSH
67287: LD_VAR 0 6
67291: PUSH
67292: LD_INT 4
67294: LESS
67295: AND
67296: IFFALSE 67486
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
67298: LD_ADDR_VAR 0 9
67302: PUSH
67303: LD_VAR 0 4
67307: PUSH
67308: LD_VAR 0 7
67312: PUSH
67313: LD_VAR 0 6
67317: UNION
67318: DIFF
67319: PPUSH
67320: LD_INT 2
67322: PPUSH
67323: CALL 52640 0 2
67327: ST_TO_ADDR
// p := [ ] ;
67328: LD_ADDR_VAR 0 11
67332: PUSH
67333: EMPTY
67334: ST_TO_ADDR
// if sort then
67335: LD_VAR 0 9
67339: IFFALSE 67455
// for i = 1 to 4 - eng do
67341: LD_ADDR_VAR 0 3
67345: PUSH
67346: DOUBLE
67347: LD_INT 1
67349: DEC
67350: ST_TO_ADDR
67351: LD_INT 4
67353: PUSH
67354: LD_VAR 0 6
67358: MINUS
67359: PUSH
67360: FOR_TO
67361: IFFALSE 67453
// begin if i = sort then
67363: LD_VAR 0 3
67367: PUSH
67368: LD_VAR 0 9
67372: EQUAL
67373: IFFALSE 67377
// break ;
67375: GO 67453
// if GetClass ( i ) = 2 then
67377: LD_VAR 0 3
67381: PPUSH
67382: CALL_OW 257
67386: PUSH
67387: LD_INT 2
67389: EQUAL
67390: IFFALSE 67394
// continue ;
67392: GO 67360
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67394: LD_ADDR_VAR 0 11
67398: PUSH
67399: LD_VAR 0 11
67403: PPUSH
67404: LD_VAR 0 11
67408: PUSH
67409: LD_INT 1
67411: PLUS
67412: PPUSH
67413: LD_VAR 0 9
67417: PUSH
67418: LD_VAR 0 3
67422: ARRAY
67423: PPUSH
67424: CALL_OW 2
67428: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67429: LD_ADDR_VAR 0 4
67433: PUSH
67434: LD_VAR 0 4
67438: PUSH
67439: LD_VAR 0 9
67443: PUSH
67444: LD_VAR 0 3
67448: ARRAY
67449: DIFF
67450: ST_TO_ADDR
// end ;
67451: GO 67360
67453: POP
67454: POP
// if p then
67455: LD_VAR 0 11
67459: IFFALSE 67484
// result := Replace ( result , 2 , p ) ;
67461: LD_ADDR_VAR 0 2
67465: PUSH
67466: LD_VAR 0 2
67470: PPUSH
67471: LD_INT 2
67473: PPUSH
67474: LD_VAR 0 11
67478: PPUSH
67479: CALL_OW 1
67483: ST_TO_ADDR
// end else
67484: GO 67530
// for i = eng downto 5 do
67486: LD_ADDR_VAR 0 3
67490: PUSH
67491: DOUBLE
67492: LD_VAR 0 6
67496: INC
67497: ST_TO_ADDR
67498: LD_INT 5
67500: PUSH
67501: FOR_DOWNTO
67502: IFFALSE 67528
// tmp := tmp union eng [ i ] ;
67504: LD_ADDR_VAR 0 4
67508: PUSH
67509: LD_VAR 0 4
67513: PUSH
67514: LD_VAR 0 6
67518: PUSH
67519: LD_VAR 0 3
67523: ARRAY
67524: UNION
67525: ST_TO_ADDR
67526: GO 67501
67528: POP
67529: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
67530: LD_ADDR_VAR 0 2
67534: PUSH
67535: LD_VAR 0 2
67539: PPUSH
67540: LD_INT 1
67542: PPUSH
67543: LD_VAR 0 4
67547: PUSH
67548: LD_VAR 0 5
67552: DIFF
67553: PPUSH
67554: CALL_OW 1
67558: ST_TO_ADDR
// exit ;
67559: GO 67561
// end ; end ;
67561: LD_VAR 0 2
67565: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
67566: LD_INT 0
67568: PPUSH
67569: PPUSH
67570: PPUSH
// if not mc_bases then
67571: LD_EXP 61
67575: NOT
67576: IFFALSE 67580
// exit ;
67578: GO 67722
// for i = 1 to mc_bases do
67580: LD_ADDR_VAR 0 2
67584: PUSH
67585: DOUBLE
67586: LD_INT 1
67588: DEC
67589: ST_TO_ADDR
67590: LD_EXP 61
67594: PUSH
67595: FOR_TO
67596: IFFALSE 67713
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67598: LD_ADDR_VAR 0 3
67602: PUSH
67603: LD_EXP 61
67607: PUSH
67608: LD_VAR 0 2
67612: ARRAY
67613: PPUSH
67614: LD_INT 21
67616: PUSH
67617: LD_INT 3
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 3
67626: PUSH
67627: LD_INT 2
67629: PUSH
67630: LD_INT 30
67632: PUSH
67633: LD_INT 29
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 30
67642: PUSH
67643: LD_INT 30
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: LIST
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 3
67661: PUSH
67662: LD_INT 24
67664: PUSH
67665: LD_INT 1000
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: LIST
67680: PPUSH
67681: CALL_OW 72
67685: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
67686: LD_ADDR_EXP 62
67690: PUSH
67691: LD_EXP 62
67695: PPUSH
67696: LD_VAR 0 2
67700: PPUSH
67701: LD_VAR 0 3
67705: PPUSH
67706: CALL_OW 1
67710: ST_TO_ADDR
// end ;
67711: GO 67595
67713: POP
67714: POP
// RaiseSailEvent ( 101 ) ;
67715: LD_INT 101
67717: PPUSH
67718: CALL_OW 427
// end ;
67722: LD_VAR 0 1
67726: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
67727: LD_INT 0
67729: PPUSH
67730: PPUSH
67731: PPUSH
67732: PPUSH
67733: PPUSH
67734: PPUSH
67735: PPUSH
// if not mc_bases then
67736: LD_EXP 61
67740: NOT
67741: IFFALSE 67745
// exit ;
67743: GO 68307
// for i = 1 to mc_bases do
67745: LD_ADDR_VAR 0 2
67749: PUSH
67750: DOUBLE
67751: LD_INT 1
67753: DEC
67754: ST_TO_ADDR
67755: LD_EXP 61
67759: PUSH
67760: FOR_TO
67761: IFFALSE 68298
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
67763: LD_ADDR_VAR 0 5
67767: PUSH
67768: LD_EXP 61
67772: PUSH
67773: LD_VAR 0 2
67777: ARRAY
67778: PUSH
67779: LD_EXP 90
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: UNION
67790: PPUSH
67791: LD_INT 21
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: LD_INT 3
67806: PUSH
67807: LD_INT 54
67809: PUSH
67810: EMPTY
67811: LIST
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 3
67819: PUSH
67820: LD_INT 24
67822: PUSH
67823: LD_INT 1000
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: LIST
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PPUSH
67843: CALL_OW 72
67847: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
67848: LD_ADDR_VAR 0 6
67852: PUSH
67853: LD_EXP 61
67857: PUSH
67858: LD_VAR 0 2
67862: ARRAY
67863: PPUSH
67864: LD_INT 21
67866: PUSH
67867: LD_INT 1
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 1
67876: PUSH
67877: LD_INT 3
67879: PUSH
67880: LD_INT 54
67882: PUSH
67883: EMPTY
67884: LIST
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 3
67892: PUSH
67893: LD_INT 24
67895: PUSH
67896: LD_INT 250
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: LIST
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PPUSH
67916: CALL_OW 72
67920: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
67921: LD_ADDR_VAR 0 7
67925: PUSH
67926: LD_VAR 0 5
67930: PUSH
67931: LD_VAR 0 6
67935: DIFF
67936: ST_TO_ADDR
// if not need_heal_1 then
67937: LD_VAR 0 6
67941: NOT
67942: IFFALSE 67975
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
67944: LD_ADDR_EXP 64
67948: PUSH
67949: LD_EXP 64
67953: PPUSH
67954: LD_VAR 0 2
67958: PUSH
67959: LD_INT 1
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PPUSH
67966: EMPTY
67967: PPUSH
67968: CALL 21407 0 3
67972: ST_TO_ADDR
67973: GO 68045
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
67975: LD_ADDR_EXP 64
67979: PUSH
67980: LD_EXP 64
67984: PPUSH
67985: LD_VAR 0 2
67989: PUSH
67990: LD_INT 1
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PPUSH
67997: LD_EXP 64
68001: PUSH
68002: LD_VAR 0 2
68006: ARRAY
68007: PUSH
68008: LD_INT 1
68010: ARRAY
68011: PPUSH
68012: LD_INT 3
68014: PUSH
68015: LD_INT 24
68017: PUSH
68018: LD_INT 1000
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PPUSH
68029: CALL_OW 72
68033: PUSH
68034: LD_VAR 0 6
68038: UNION
68039: PPUSH
68040: CALL 21407 0 3
68044: ST_TO_ADDR
// if not need_heal_2 then
68045: LD_VAR 0 7
68049: NOT
68050: IFFALSE 68083
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68052: LD_ADDR_EXP 64
68056: PUSH
68057: LD_EXP 64
68061: PPUSH
68062: LD_VAR 0 2
68066: PUSH
68067: LD_INT 2
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PPUSH
68074: EMPTY
68075: PPUSH
68076: CALL 21407 0 3
68080: ST_TO_ADDR
68081: GO 68115
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68083: LD_ADDR_EXP 64
68087: PUSH
68088: LD_EXP 64
68092: PPUSH
68093: LD_VAR 0 2
68097: PUSH
68098: LD_INT 2
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PPUSH
68105: LD_VAR 0 7
68109: PPUSH
68110: CALL 21407 0 3
68114: ST_TO_ADDR
// if need_heal_2 then
68115: LD_VAR 0 7
68119: IFFALSE 68280
// for j in need_heal_2 do
68121: LD_ADDR_VAR 0 3
68125: PUSH
68126: LD_VAR 0 7
68130: PUSH
68131: FOR_IN
68132: IFFALSE 68278
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68134: LD_ADDR_VAR 0 5
68138: PUSH
68139: LD_EXP 61
68143: PUSH
68144: LD_VAR 0 2
68148: ARRAY
68149: PPUSH
68150: LD_INT 2
68152: PUSH
68153: LD_INT 30
68155: PUSH
68156: LD_INT 6
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 30
68165: PUSH
68166: LD_INT 7
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 30
68175: PUSH
68176: LD_INT 8
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 30
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 30
68195: PUSH
68196: LD_INT 1
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: PPUSH
68211: CALL_OW 72
68215: ST_TO_ADDR
// if tmp then
68216: LD_VAR 0 5
68220: IFFALSE 68276
// begin k := NearestUnitToUnit ( tmp , j ) ;
68222: LD_ADDR_VAR 0 4
68226: PUSH
68227: LD_VAR 0 5
68231: PPUSH
68232: LD_VAR 0 3
68236: PPUSH
68237: CALL_OW 74
68241: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
68242: LD_VAR 0 3
68246: PPUSH
68247: LD_VAR 0 4
68251: PPUSH
68252: CALL_OW 296
68256: PUSH
68257: LD_INT 5
68259: GREATER
68260: IFFALSE 68276
// ComMoveToNearbyEntrance ( j , k ) ;
68262: LD_VAR 0 3
68266: PPUSH
68267: LD_VAR 0 4
68271: PPUSH
68272: CALL 55013 0 2
// end ; end ;
68276: GO 68131
68278: POP
68279: POP
// if not need_heal_1 and not need_heal_2 then
68280: LD_VAR 0 6
68284: NOT
68285: PUSH
68286: LD_VAR 0 7
68290: NOT
68291: AND
68292: IFFALSE 68296
// continue ;
68294: GO 67760
// end ;
68296: GO 67760
68298: POP
68299: POP
// RaiseSailEvent ( 102 ) ;
68300: LD_INT 102
68302: PPUSH
68303: CALL_OW 427
// end ;
68307: LD_VAR 0 1
68311: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
68312: LD_INT 0
68314: PPUSH
68315: PPUSH
68316: PPUSH
68317: PPUSH
68318: PPUSH
68319: PPUSH
68320: PPUSH
68321: PPUSH
// if not mc_bases then
68322: LD_EXP 61
68326: NOT
68327: IFFALSE 68331
// exit ;
68329: GO 69242
// for i = 1 to mc_bases do
68331: LD_ADDR_VAR 0 2
68335: PUSH
68336: DOUBLE
68337: LD_INT 1
68339: DEC
68340: ST_TO_ADDR
68341: LD_EXP 61
68345: PUSH
68346: FOR_TO
68347: IFFALSE 69240
// begin if not mc_building_need_repair [ i ] then
68349: LD_EXP 62
68353: PUSH
68354: LD_VAR 0 2
68358: ARRAY
68359: NOT
68360: IFFALSE 68545
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
68362: LD_ADDR_VAR 0 6
68366: PUSH
68367: LD_EXP 80
68371: PUSH
68372: LD_VAR 0 2
68376: ARRAY
68377: PPUSH
68378: LD_INT 3
68380: PUSH
68381: LD_INT 24
68383: PUSH
68384: LD_INT 1000
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 2
68397: PUSH
68398: LD_INT 34
68400: PUSH
68401: LD_INT 13
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 34
68410: PUSH
68411: LD_INT 52
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 34
68420: PUSH
68421: LD_INT 88
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PPUSH
68438: CALL_OW 72
68442: ST_TO_ADDR
// if cranes then
68443: LD_VAR 0 6
68447: IFFALSE 68509
// for j in cranes do
68449: LD_ADDR_VAR 0 3
68453: PUSH
68454: LD_VAR 0 6
68458: PUSH
68459: FOR_IN
68460: IFFALSE 68507
// if not IsInArea ( j , mc_parking [ i ] ) then
68462: LD_VAR 0 3
68466: PPUSH
68467: LD_EXP 85
68471: PUSH
68472: LD_VAR 0 2
68476: ARRAY
68477: PPUSH
68478: CALL_OW 308
68482: NOT
68483: IFFALSE 68505
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68485: LD_VAR 0 3
68489: PPUSH
68490: LD_EXP 85
68494: PUSH
68495: LD_VAR 0 2
68499: ARRAY
68500: PPUSH
68501: CALL_OW 113
68505: GO 68459
68507: POP
68508: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
68509: LD_ADDR_EXP 63
68513: PUSH
68514: LD_EXP 63
68518: PPUSH
68519: LD_VAR 0 2
68523: PPUSH
68524: EMPTY
68525: PPUSH
68526: CALL_OW 1
68530: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
68531: LD_VAR 0 2
68535: PPUSH
68536: LD_INT 101
68538: PPUSH
68539: CALL 63385 0 2
// continue ;
68543: GO 68346
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
68545: LD_ADDR_EXP 67
68549: PUSH
68550: LD_EXP 67
68554: PPUSH
68555: LD_VAR 0 2
68559: PPUSH
68560: EMPTY
68561: PPUSH
68562: CALL_OW 1
68566: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68567: LD_VAR 0 2
68571: PPUSH
68572: LD_INT 103
68574: PPUSH
68575: CALL 63385 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
68579: LD_ADDR_VAR 0 5
68583: PUSH
68584: LD_EXP 61
68588: PUSH
68589: LD_VAR 0 2
68593: ARRAY
68594: PUSH
68595: LD_EXP 90
68599: PUSH
68600: LD_VAR 0 2
68604: ARRAY
68605: UNION
68606: PPUSH
68607: LD_INT 2
68609: PUSH
68610: LD_INT 25
68612: PUSH
68613: LD_INT 2
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: PUSH
68620: LD_INT 25
68622: PUSH
68623: LD_INT 16
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: LIST
68634: PUSH
68635: EMPTY
68636: LIST
68637: PPUSH
68638: CALL_OW 72
68642: ST_TO_ADDR
// if mc_need_heal [ i ] then
68643: LD_EXP 64
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: IFFALSE 68697
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
68655: LD_ADDR_VAR 0 5
68659: PUSH
68660: LD_VAR 0 5
68664: PUSH
68665: LD_EXP 64
68669: PUSH
68670: LD_VAR 0 2
68674: ARRAY
68675: PUSH
68676: LD_INT 1
68678: ARRAY
68679: PUSH
68680: LD_EXP 64
68684: PUSH
68685: LD_VAR 0 2
68689: ARRAY
68690: PUSH
68691: LD_INT 2
68693: ARRAY
68694: UNION
68695: DIFF
68696: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
68697: LD_ADDR_VAR 0 6
68701: PUSH
68702: LD_EXP 80
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PPUSH
68713: LD_INT 2
68715: PUSH
68716: LD_INT 34
68718: PUSH
68719: LD_INT 13
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 34
68728: PUSH
68729: LD_INT 52
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 34
68738: PUSH
68739: LD_INT 88
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: PPUSH
68752: CALL_OW 72
68756: ST_TO_ADDR
// if cranes then
68757: LD_VAR 0 6
68761: IFFALSE 68929
// begin for j in cranes do
68763: LD_ADDR_VAR 0 3
68767: PUSH
68768: LD_VAR 0 6
68772: PUSH
68773: FOR_IN
68774: IFFALSE 68927
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
68776: LD_VAR 0 3
68780: PPUSH
68781: CALL_OW 256
68785: PUSH
68786: LD_INT 1000
68788: EQUAL
68789: PUSH
68790: LD_VAR 0 3
68794: PPUSH
68795: CALL_OW 314
68799: NOT
68800: AND
68801: IFFALSE 68867
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
68803: LD_ADDR_VAR 0 8
68807: PUSH
68808: LD_EXP 62
68812: PUSH
68813: LD_VAR 0 2
68817: ARRAY
68818: PPUSH
68819: LD_VAR 0 3
68823: PPUSH
68824: CALL_OW 74
68828: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
68829: LD_VAR 0 8
68833: PPUSH
68834: LD_INT 16
68836: PPUSH
68837: CALL 24372 0 2
68841: PUSH
68842: LD_INT 4
68844: ARRAY
68845: PUSH
68846: LD_INT 10
68848: LESS
68849: IFFALSE 68865
// ComRepairBuilding ( j , to_repair ) ;
68851: LD_VAR 0 3
68855: PPUSH
68856: LD_VAR 0 8
68860: PPUSH
68861: CALL_OW 130
// end else
68865: GO 68925
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
68867: LD_VAR 0 3
68871: PPUSH
68872: CALL_OW 256
68876: PUSH
68877: LD_INT 500
68879: LESS
68880: PUSH
68881: LD_VAR 0 3
68885: PPUSH
68886: LD_EXP 85
68890: PUSH
68891: LD_VAR 0 2
68895: ARRAY
68896: PPUSH
68897: CALL_OW 308
68901: NOT
68902: AND
68903: IFFALSE 68925
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68905: LD_VAR 0 3
68909: PPUSH
68910: LD_EXP 85
68914: PUSH
68915: LD_VAR 0 2
68919: ARRAY
68920: PPUSH
68921: CALL_OW 113
// end ;
68925: GO 68773
68927: POP
68928: POP
// end ; if tmp > 3 then
68929: LD_VAR 0 5
68933: PUSH
68934: LD_INT 3
68936: GREATER
68937: IFFALSE 68957
// tmp := ShrinkArray ( tmp , 4 ) ;
68939: LD_ADDR_VAR 0 5
68943: PUSH
68944: LD_VAR 0 5
68948: PPUSH
68949: LD_INT 4
68951: PPUSH
68952: CALL 54451 0 2
68956: ST_TO_ADDR
// if not tmp then
68957: LD_VAR 0 5
68961: NOT
68962: IFFALSE 68966
// continue ;
68964: GO 68346
// for j in tmp do
68966: LD_ADDR_VAR 0 3
68970: PUSH
68971: LD_VAR 0 5
68975: PUSH
68976: FOR_IN
68977: IFFALSE 69236
// begin if IsInUnit ( j ) then
68979: LD_VAR 0 3
68983: PPUSH
68984: CALL_OW 310
68988: IFFALSE 68999
// ComExitBuilding ( j ) ;
68990: LD_VAR 0 3
68994: PPUSH
68995: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
68999: LD_VAR 0 3
69003: PUSH
69004: LD_EXP 63
69008: PUSH
69009: LD_VAR 0 2
69013: ARRAY
69014: IN
69015: NOT
69016: IFFALSE 69074
// begin SetTag ( j , 101 ) ;
69018: LD_VAR 0 3
69022: PPUSH
69023: LD_INT 101
69025: PPUSH
69026: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69030: LD_ADDR_EXP 63
69034: PUSH
69035: LD_EXP 63
69039: PPUSH
69040: LD_VAR 0 2
69044: PUSH
69045: LD_EXP 63
69049: PUSH
69050: LD_VAR 0 2
69054: ARRAY
69055: PUSH
69056: LD_INT 1
69058: PLUS
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PPUSH
69064: LD_VAR 0 3
69068: PPUSH
69069: CALL 21407 0 3
69073: ST_TO_ADDR
// end ; wait ( 1 ) ;
69074: LD_INT 1
69076: PPUSH
69077: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69081: LD_ADDR_VAR 0 7
69085: PUSH
69086: LD_EXP 62
69090: PUSH
69091: LD_VAR 0 2
69095: ARRAY
69096: ST_TO_ADDR
// if mc_scan [ i ] then
69097: LD_EXP 84
69101: PUSH
69102: LD_VAR 0 2
69106: ARRAY
69107: IFFALSE 69169
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69109: LD_ADDR_VAR 0 7
69113: PUSH
69114: LD_EXP 62
69118: PUSH
69119: LD_VAR 0 2
69123: ARRAY
69124: PPUSH
69125: LD_INT 3
69127: PUSH
69128: LD_INT 30
69130: PUSH
69131: LD_INT 32
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 30
69140: PUSH
69141: LD_INT 33
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 30
69150: PUSH
69151: LD_INT 31
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: PPUSH
69164: CALL_OW 72
69168: ST_TO_ADDR
// if not to_repair_tmp then
69169: LD_VAR 0 7
69173: NOT
69174: IFFALSE 69178
// continue ;
69176: GO 68976
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
69178: LD_ADDR_VAR 0 8
69182: PUSH
69183: LD_VAR 0 7
69187: PPUSH
69188: LD_VAR 0 3
69192: PPUSH
69193: CALL_OW 74
69197: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
69198: LD_VAR 0 8
69202: PPUSH
69203: LD_INT 16
69205: PPUSH
69206: CALL 24372 0 2
69210: PUSH
69211: LD_INT 4
69213: ARRAY
69214: PUSH
69215: LD_INT 14
69217: LESS
69218: IFFALSE 69234
// ComRepairBuilding ( j , to_repair ) ;
69220: LD_VAR 0 3
69224: PPUSH
69225: LD_VAR 0 8
69229: PPUSH
69230: CALL_OW 130
// end ;
69234: GO 68976
69236: POP
69237: POP
// end ;
69238: GO 68346
69240: POP
69241: POP
// end ;
69242: LD_VAR 0 1
69246: RET
// export function MC_Heal ; var i , j , tmp ; begin
69247: LD_INT 0
69249: PPUSH
69250: PPUSH
69251: PPUSH
69252: PPUSH
// if not mc_bases then
69253: LD_EXP 61
69257: NOT
69258: IFFALSE 69262
// exit ;
69260: GO 69664
// for i = 1 to mc_bases do
69262: LD_ADDR_VAR 0 2
69266: PUSH
69267: DOUBLE
69268: LD_INT 1
69270: DEC
69271: ST_TO_ADDR
69272: LD_EXP 61
69276: PUSH
69277: FOR_TO
69278: IFFALSE 69662
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
69280: LD_EXP 64
69284: PUSH
69285: LD_VAR 0 2
69289: ARRAY
69290: PUSH
69291: LD_INT 1
69293: ARRAY
69294: NOT
69295: PUSH
69296: LD_EXP 64
69300: PUSH
69301: LD_VAR 0 2
69305: ARRAY
69306: PUSH
69307: LD_INT 2
69309: ARRAY
69310: NOT
69311: AND
69312: IFFALSE 69350
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
69314: LD_ADDR_EXP 65
69318: PUSH
69319: LD_EXP 65
69323: PPUSH
69324: LD_VAR 0 2
69328: PPUSH
69329: EMPTY
69330: PPUSH
69331: CALL_OW 1
69335: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
69336: LD_VAR 0 2
69340: PPUSH
69341: LD_INT 102
69343: PPUSH
69344: CALL 63385 0 2
// continue ;
69348: GO 69277
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
69350: LD_ADDR_VAR 0 4
69354: PUSH
69355: LD_EXP 61
69359: PUSH
69360: LD_VAR 0 2
69364: ARRAY
69365: PPUSH
69366: LD_INT 25
69368: PUSH
69369: LD_INT 4
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PPUSH
69376: CALL_OW 72
69380: ST_TO_ADDR
// if not tmp then
69381: LD_VAR 0 4
69385: NOT
69386: IFFALSE 69390
// continue ;
69388: GO 69277
// if mc_taming [ i ] then
69390: LD_EXP 92
69394: PUSH
69395: LD_VAR 0 2
69399: ARRAY
69400: IFFALSE 69424
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69402: LD_ADDR_EXP 92
69406: PUSH
69407: LD_EXP 92
69411: PPUSH
69412: LD_VAR 0 2
69416: PPUSH
69417: EMPTY
69418: PPUSH
69419: CALL_OW 1
69423: ST_TO_ADDR
// for j in tmp do
69424: LD_ADDR_VAR 0 3
69428: PUSH
69429: LD_VAR 0 4
69433: PUSH
69434: FOR_IN
69435: IFFALSE 69658
// begin if IsInUnit ( j ) then
69437: LD_VAR 0 3
69441: PPUSH
69442: CALL_OW 310
69446: IFFALSE 69457
// ComExitBuilding ( j ) ;
69448: LD_VAR 0 3
69452: PPUSH
69453: CALL_OW 122
// if not j in mc_healers [ i ] then
69457: LD_VAR 0 3
69461: PUSH
69462: LD_EXP 65
69466: PUSH
69467: LD_VAR 0 2
69471: ARRAY
69472: IN
69473: NOT
69474: IFFALSE 69520
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
69476: LD_ADDR_EXP 65
69480: PUSH
69481: LD_EXP 65
69485: PPUSH
69486: LD_VAR 0 2
69490: PUSH
69491: LD_EXP 65
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PUSH
69502: LD_INT 1
69504: PLUS
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PPUSH
69510: LD_VAR 0 3
69514: PPUSH
69515: CALL 21407 0 3
69519: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
69520: LD_VAR 0 3
69524: PPUSH
69525: CALL_OW 110
69529: PUSH
69530: LD_INT 102
69532: NONEQUAL
69533: IFFALSE 69547
// SetTag ( j , 102 ) ;
69535: LD_VAR 0 3
69539: PPUSH
69540: LD_INT 102
69542: PPUSH
69543: CALL_OW 109
// Wait ( 3 ) ;
69547: LD_INT 3
69549: PPUSH
69550: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
69554: LD_EXP 64
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: PUSH
69565: LD_INT 1
69567: ARRAY
69568: IFFALSE 69600
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
69570: LD_VAR 0 3
69574: PPUSH
69575: LD_EXP 64
69579: PUSH
69580: LD_VAR 0 2
69584: ARRAY
69585: PUSH
69586: LD_INT 1
69588: ARRAY
69589: PUSH
69590: LD_INT 1
69592: ARRAY
69593: PPUSH
69594: CALL_OW 128
69598: GO 69656
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
69600: LD_VAR 0 3
69604: PPUSH
69605: CALL_OW 314
69609: NOT
69610: PUSH
69611: LD_EXP 64
69615: PUSH
69616: LD_VAR 0 2
69620: ARRAY
69621: PUSH
69622: LD_INT 2
69624: ARRAY
69625: AND
69626: IFFALSE 69656
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
69628: LD_VAR 0 3
69632: PPUSH
69633: LD_EXP 64
69637: PUSH
69638: LD_VAR 0 2
69642: ARRAY
69643: PUSH
69644: LD_INT 2
69646: ARRAY
69647: PUSH
69648: LD_INT 1
69650: ARRAY
69651: PPUSH
69652: CALL_OW 128
// end ;
69656: GO 69434
69658: POP
69659: POP
// end ;
69660: GO 69277
69662: POP
69663: POP
// end ;
69664: LD_VAR 0 1
69668: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
69669: LD_INT 0
69671: PPUSH
69672: PPUSH
69673: PPUSH
69674: PPUSH
69675: PPUSH
69676: PPUSH
// if not mc_bases then
69677: LD_EXP 61
69681: NOT
69682: IFFALSE 69686
// exit ;
69684: GO 70849
// for i = 1 to mc_bases do
69686: LD_ADDR_VAR 0 2
69690: PUSH
69691: DOUBLE
69692: LD_INT 1
69694: DEC
69695: ST_TO_ADDR
69696: LD_EXP 61
69700: PUSH
69701: FOR_TO
69702: IFFALSE 70847
// begin if mc_scan [ i ] then
69704: LD_EXP 84
69708: PUSH
69709: LD_VAR 0 2
69713: ARRAY
69714: IFFALSE 69718
// continue ;
69716: GO 69701
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
69718: LD_EXP 66
69722: PUSH
69723: LD_VAR 0 2
69727: ARRAY
69728: NOT
69729: PUSH
69730: LD_EXP 68
69734: PUSH
69735: LD_VAR 0 2
69739: ARRAY
69740: NOT
69741: AND
69742: PUSH
69743: LD_EXP 67
69747: PUSH
69748: LD_VAR 0 2
69752: ARRAY
69753: AND
69754: IFFALSE 69792
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
69756: LD_ADDR_EXP 67
69760: PUSH
69761: LD_EXP 67
69765: PPUSH
69766: LD_VAR 0 2
69770: PPUSH
69771: EMPTY
69772: PPUSH
69773: CALL_OW 1
69777: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69778: LD_VAR 0 2
69782: PPUSH
69783: LD_INT 103
69785: PPUSH
69786: CALL 63385 0 2
// continue ;
69790: GO 69701
// end ; if mc_construct_list [ i ] then
69792: LD_EXP 68
69796: PUSH
69797: LD_VAR 0 2
69801: ARRAY
69802: IFFALSE 70022
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69804: LD_ADDR_VAR 0 5
69808: PUSH
69809: LD_EXP 61
69813: PUSH
69814: LD_VAR 0 2
69818: ARRAY
69819: PPUSH
69820: LD_INT 25
69822: PUSH
69823: LD_INT 2
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PPUSH
69830: CALL_OW 72
69834: PUSH
69835: LD_EXP 63
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: DIFF
69846: ST_TO_ADDR
// if not tmp then
69847: LD_VAR 0 5
69851: NOT
69852: IFFALSE 69856
// continue ;
69854: GO 69701
// for j in tmp do
69856: LD_ADDR_VAR 0 3
69860: PUSH
69861: LD_VAR 0 5
69865: PUSH
69866: FOR_IN
69867: IFFALSE 70018
// begin if not mc_builders [ i ] then
69869: LD_EXP 67
69873: PUSH
69874: LD_VAR 0 2
69878: ARRAY
69879: NOT
69880: IFFALSE 69938
// begin SetTag ( j , 103 ) ;
69882: LD_VAR 0 3
69886: PPUSH
69887: LD_INT 103
69889: PPUSH
69890: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69894: LD_ADDR_EXP 67
69898: PUSH
69899: LD_EXP 67
69903: PPUSH
69904: LD_VAR 0 2
69908: PUSH
69909: LD_EXP 67
69913: PUSH
69914: LD_VAR 0 2
69918: ARRAY
69919: PUSH
69920: LD_INT 1
69922: PLUS
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: PPUSH
69928: LD_VAR 0 3
69932: PPUSH
69933: CALL 21407 0 3
69937: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69938: LD_VAR 0 3
69942: PPUSH
69943: CALL_OW 310
69947: IFFALSE 69958
// ComExitBuilding ( j ) ;
69949: LD_VAR 0 3
69953: PPUSH
69954: CALL_OW 122
// wait ( 3 ) ;
69958: LD_INT 3
69960: PPUSH
69961: CALL_OW 67
// if not mc_construct_list [ i ] then
69965: LD_EXP 68
69969: PUSH
69970: LD_VAR 0 2
69974: ARRAY
69975: NOT
69976: IFFALSE 69980
// break ;
69978: GO 70018
// if not HasTask ( j ) then
69980: LD_VAR 0 3
69984: PPUSH
69985: CALL_OW 314
69989: NOT
69990: IFFALSE 70016
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
69992: LD_VAR 0 3
69996: PPUSH
69997: LD_EXP 68
70001: PUSH
70002: LD_VAR 0 2
70006: ARRAY
70007: PUSH
70008: LD_INT 1
70010: ARRAY
70011: PPUSH
70012: CALL 24645 0 2
// end ;
70016: GO 69866
70018: POP
70019: POP
// end else
70020: GO 70845
// if mc_build_list [ i ] then
70022: LD_EXP 66
70026: PUSH
70027: LD_VAR 0 2
70031: ARRAY
70032: IFFALSE 70845
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70034: LD_EXP 66
70038: PUSH
70039: LD_VAR 0 2
70043: ARRAY
70044: PUSH
70045: LD_INT 1
70047: ARRAY
70048: PUSH
70049: LD_INT 1
70051: ARRAY
70052: PPUSH
70053: CALL 24469 0 1
70057: PUSH
70058: LD_EXP 61
70062: PUSH
70063: LD_VAR 0 2
70067: ARRAY
70068: PPUSH
70069: LD_INT 2
70071: PUSH
70072: LD_INT 30
70074: PUSH
70075: LD_INT 2
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 30
70084: PUSH
70085: LD_INT 3
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: LIST
70096: PPUSH
70097: CALL_OW 72
70101: NOT
70102: AND
70103: IFFALSE 70208
// begin for j = 1 to mc_build_list [ i ] do
70105: LD_ADDR_VAR 0 3
70109: PUSH
70110: DOUBLE
70111: LD_INT 1
70113: DEC
70114: ST_TO_ADDR
70115: LD_EXP 66
70119: PUSH
70120: LD_VAR 0 2
70124: ARRAY
70125: PUSH
70126: FOR_TO
70127: IFFALSE 70206
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
70129: LD_EXP 66
70133: PUSH
70134: LD_VAR 0 2
70138: ARRAY
70139: PUSH
70140: LD_VAR 0 3
70144: ARRAY
70145: PUSH
70146: LD_INT 1
70148: ARRAY
70149: PUSH
70150: LD_INT 2
70152: EQUAL
70153: IFFALSE 70204
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
70155: LD_ADDR_EXP 66
70159: PUSH
70160: LD_EXP 66
70164: PPUSH
70165: LD_VAR 0 2
70169: PPUSH
70170: LD_EXP 66
70174: PUSH
70175: LD_VAR 0 2
70179: ARRAY
70180: PPUSH
70181: LD_VAR 0 3
70185: PPUSH
70186: LD_INT 1
70188: PPUSH
70189: LD_INT 0
70191: PPUSH
70192: CALL 20825 0 4
70196: PPUSH
70197: CALL_OW 1
70201: ST_TO_ADDR
// break ;
70202: GO 70206
// end ;
70204: GO 70126
70206: POP
70207: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70208: LD_ADDR_VAR 0 6
70212: PUSH
70213: LD_EXP 61
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PPUSH
70224: LD_INT 2
70226: PUSH
70227: LD_INT 30
70229: PUSH
70230: LD_INT 0
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 30
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: LIST
70251: PPUSH
70252: CALL_OW 72
70256: ST_TO_ADDR
// for k := 1 to depot do
70257: LD_ADDR_VAR 0 4
70261: PUSH
70262: DOUBLE
70263: LD_INT 1
70265: DEC
70266: ST_TO_ADDR
70267: LD_VAR 0 6
70271: PUSH
70272: FOR_TO
70273: IFFALSE 70843
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
70275: LD_EXP 66
70279: PUSH
70280: LD_VAR 0 2
70284: ARRAY
70285: PUSH
70286: LD_INT 1
70288: ARRAY
70289: PUSH
70290: LD_INT 1
70292: ARRAY
70293: PUSH
70294: LD_INT 0
70296: EQUAL
70297: PUSH
70298: LD_VAR 0 6
70302: PUSH
70303: LD_VAR 0 4
70307: ARRAY
70308: PPUSH
70309: LD_EXP 66
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: PUSH
70320: LD_INT 1
70322: ARRAY
70323: PUSH
70324: LD_INT 1
70326: ARRAY
70327: PPUSH
70328: LD_EXP 66
70332: PUSH
70333: LD_VAR 0 2
70337: ARRAY
70338: PUSH
70339: LD_INT 1
70341: ARRAY
70342: PUSH
70343: LD_INT 2
70345: ARRAY
70346: PPUSH
70347: LD_EXP 66
70351: PUSH
70352: LD_VAR 0 2
70356: ARRAY
70357: PUSH
70358: LD_INT 1
70360: ARRAY
70361: PUSH
70362: LD_INT 3
70364: ARRAY
70365: PPUSH
70366: LD_EXP 66
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: PUSH
70377: LD_INT 1
70379: ARRAY
70380: PUSH
70381: LD_INT 4
70383: ARRAY
70384: PPUSH
70385: CALL 29881 0 5
70389: OR
70390: IFFALSE 70671
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70392: LD_ADDR_VAR 0 5
70396: PUSH
70397: LD_EXP 61
70401: PUSH
70402: LD_VAR 0 2
70406: ARRAY
70407: PPUSH
70408: LD_INT 25
70410: PUSH
70411: LD_INT 2
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PPUSH
70418: CALL_OW 72
70422: PUSH
70423: LD_EXP 63
70427: PUSH
70428: LD_VAR 0 2
70432: ARRAY
70433: DIFF
70434: ST_TO_ADDR
// if not tmp then
70435: LD_VAR 0 5
70439: NOT
70440: IFFALSE 70444
// continue ;
70442: GO 70272
// for j in tmp do
70444: LD_ADDR_VAR 0 3
70448: PUSH
70449: LD_VAR 0 5
70453: PUSH
70454: FOR_IN
70455: IFFALSE 70667
// begin if not mc_builders [ i ] then
70457: LD_EXP 67
70461: PUSH
70462: LD_VAR 0 2
70466: ARRAY
70467: NOT
70468: IFFALSE 70526
// begin SetTag ( j , 103 ) ;
70470: LD_VAR 0 3
70474: PPUSH
70475: LD_INT 103
70477: PPUSH
70478: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70482: LD_ADDR_EXP 67
70486: PUSH
70487: LD_EXP 67
70491: PPUSH
70492: LD_VAR 0 2
70496: PUSH
70497: LD_EXP 67
70501: PUSH
70502: LD_VAR 0 2
70506: ARRAY
70507: PUSH
70508: LD_INT 1
70510: PLUS
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PPUSH
70516: LD_VAR 0 3
70520: PPUSH
70521: CALL 21407 0 3
70525: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70526: LD_VAR 0 3
70530: PPUSH
70531: CALL_OW 310
70535: IFFALSE 70546
// ComExitBuilding ( j ) ;
70537: LD_VAR 0 3
70541: PPUSH
70542: CALL_OW 122
// wait ( 3 ) ;
70546: LD_INT 3
70548: PPUSH
70549: CALL_OW 67
// if not mc_build_list [ i ] then
70553: LD_EXP 66
70557: PUSH
70558: LD_VAR 0 2
70562: ARRAY
70563: NOT
70564: IFFALSE 70568
// break ;
70566: GO 70667
// if not HasTask ( j ) then
70568: LD_VAR 0 3
70572: PPUSH
70573: CALL_OW 314
70577: NOT
70578: IFFALSE 70665
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
70580: LD_VAR 0 3
70584: PPUSH
70585: LD_EXP 66
70589: PUSH
70590: LD_VAR 0 2
70594: ARRAY
70595: PUSH
70596: LD_INT 1
70598: ARRAY
70599: PUSH
70600: LD_INT 1
70602: ARRAY
70603: PPUSH
70604: LD_EXP 66
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: PUSH
70615: LD_INT 1
70617: ARRAY
70618: PUSH
70619: LD_INT 2
70621: ARRAY
70622: PPUSH
70623: LD_EXP 66
70627: PUSH
70628: LD_VAR 0 2
70632: ARRAY
70633: PUSH
70634: LD_INT 1
70636: ARRAY
70637: PUSH
70638: LD_INT 3
70640: ARRAY
70641: PPUSH
70642: LD_EXP 66
70646: PUSH
70647: LD_VAR 0 2
70651: ARRAY
70652: PUSH
70653: LD_INT 1
70655: ARRAY
70656: PUSH
70657: LD_INT 4
70659: ARRAY
70660: PPUSH
70661: CALL_OW 145
// end ;
70665: GO 70454
70667: POP
70668: POP
// end else
70669: GO 70841
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
70671: LD_EXP 61
70675: PUSH
70676: LD_VAR 0 2
70680: ARRAY
70681: PPUSH
70682: LD_EXP 66
70686: PUSH
70687: LD_VAR 0 2
70691: ARRAY
70692: PUSH
70693: LD_INT 1
70695: ARRAY
70696: PUSH
70697: LD_INT 1
70699: ARRAY
70700: PPUSH
70701: LD_EXP 66
70705: PUSH
70706: LD_VAR 0 2
70710: ARRAY
70711: PUSH
70712: LD_INT 1
70714: ARRAY
70715: PUSH
70716: LD_INT 2
70718: ARRAY
70719: PPUSH
70720: LD_EXP 66
70724: PUSH
70725: LD_VAR 0 2
70729: ARRAY
70730: PUSH
70731: LD_INT 1
70733: ARRAY
70734: PUSH
70735: LD_INT 3
70737: ARRAY
70738: PPUSH
70739: LD_EXP 66
70743: PUSH
70744: LD_VAR 0 2
70748: ARRAY
70749: PUSH
70750: LD_INT 1
70752: ARRAY
70753: PUSH
70754: LD_INT 4
70756: ARRAY
70757: PPUSH
70758: LD_EXP 61
70762: PUSH
70763: LD_VAR 0 2
70767: ARRAY
70768: PPUSH
70769: LD_INT 21
70771: PUSH
70772: LD_INT 3
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PPUSH
70779: CALL_OW 72
70783: PPUSH
70784: EMPTY
70785: PPUSH
70786: CALL 28635 0 7
70790: NOT
70791: IFFALSE 70841
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
70793: LD_ADDR_EXP 66
70797: PUSH
70798: LD_EXP 66
70802: PPUSH
70803: LD_VAR 0 2
70807: PPUSH
70808: LD_EXP 66
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PPUSH
70819: LD_INT 1
70821: PPUSH
70822: LD_INT 1
70824: NEG
70825: PPUSH
70826: LD_INT 0
70828: PPUSH
70829: CALL 20825 0 4
70833: PPUSH
70834: CALL_OW 1
70838: ST_TO_ADDR
// continue ;
70839: GO 70272
// end ; end ;
70841: GO 70272
70843: POP
70844: POP
// end ; end ;
70845: GO 69701
70847: POP
70848: POP
// end ;
70849: LD_VAR 0 1
70853: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
70854: LD_INT 0
70856: PPUSH
70857: PPUSH
70858: PPUSH
70859: PPUSH
70860: PPUSH
70861: PPUSH
// if not mc_bases then
70862: LD_EXP 61
70866: NOT
70867: IFFALSE 70871
// exit ;
70869: GO 71298
// for i = 1 to mc_bases do
70871: LD_ADDR_VAR 0 2
70875: PUSH
70876: DOUBLE
70877: LD_INT 1
70879: DEC
70880: ST_TO_ADDR
70881: LD_EXP 61
70885: PUSH
70886: FOR_TO
70887: IFFALSE 71296
// begin tmp := mc_build_upgrade [ i ] ;
70889: LD_ADDR_VAR 0 4
70893: PUSH
70894: LD_EXP 93
70898: PUSH
70899: LD_VAR 0 2
70903: ARRAY
70904: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
70905: LD_ADDR_VAR 0 6
70909: PUSH
70910: LD_EXP 94
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: PPUSH
70921: LD_INT 2
70923: PUSH
70924: LD_INT 30
70926: PUSH
70927: LD_INT 6
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 30
70936: PUSH
70937: LD_INT 7
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: LIST
70948: PPUSH
70949: CALL_OW 72
70953: ST_TO_ADDR
// if not tmp and not lab then
70954: LD_VAR 0 4
70958: NOT
70959: PUSH
70960: LD_VAR 0 6
70964: NOT
70965: AND
70966: IFFALSE 70970
// continue ;
70968: GO 70886
// if tmp then
70970: LD_VAR 0 4
70974: IFFALSE 71094
// for j in tmp do
70976: LD_ADDR_VAR 0 3
70980: PUSH
70981: LD_VAR 0 4
70985: PUSH
70986: FOR_IN
70987: IFFALSE 71092
// begin if UpgradeCost ( j ) then
70989: LD_VAR 0 3
70993: PPUSH
70994: CALL 28295 0 1
70998: IFFALSE 71090
// begin ComUpgrade ( j ) ;
71000: LD_VAR 0 3
71004: PPUSH
71005: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71009: LD_ADDR_EXP 93
71013: PUSH
71014: LD_EXP 93
71018: PPUSH
71019: LD_VAR 0 2
71023: PPUSH
71024: LD_EXP 93
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: PUSH
71035: LD_VAR 0 3
71039: DIFF
71040: PPUSH
71041: CALL_OW 1
71045: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71046: LD_ADDR_EXP 68
71050: PUSH
71051: LD_EXP 68
71055: PPUSH
71056: LD_VAR 0 2
71060: PUSH
71061: LD_EXP 68
71065: PUSH
71066: LD_VAR 0 2
71070: ARRAY
71071: PUSH
71072: LD_INT 1
71074: PLUS
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PPUSH
71080: LD_VAR 0 3
71084: PPUSH
71085: CALL 21407 0 3
71089: ST_TO_ADDR
// end ; end ;
71090: GO 70986
71092: POP
71093: POP
// if not lab or not mc_lab_upgrade [ i ] then
71094: LD_VAR 0 6
71098: NOT
71099: PUSH
71100: LD_EXP 95
71104: PUSH
71105: LD_VAR 0 2
71109: ARRAY
71110: NOT
71111: OR
71112: IFFALSE 71116
// continue ;
71114: GO 70886
// for j in lab do
71116: LD_ADDR_VAR 0 3
71120: PUSH
71121: LD_VAR 0 6
71125: PUSH
71126: FOR_IN
71127: IFFALSE 71292
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
71129: LD_VAR 0 3
71133: PPUSH
71134: CALL_OW 266
71138: PUSH
71139: LD_INT 6
71141: PUSH
71142: LD_INT 7
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: IN
71149: PUSH
71150: LD_VAR 0 3
71154: PPUSH
71155: CALL_OW 461
71159: PUSH
71160: LD_INT 1
71162: NONEQUAL
71163: AND
71164: IFFALSE 71290
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
71166: LD_VAR 0 3
71170: PPUSH
71171: LD_EXP 95
71175: PUSH
71176: LD_VAR 0 2
71180: ARRAY
71181: PUSH
71182: LD_INT 1
71184: ARRAY
71185: PPUSH
71186: CALL 28500 0 2
71190: IFFALSE 71290
// begin ComCancel ( j ) ;
71192: LD_VAR 0 3
71196: PPUSH
71197: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
71201: LD_VAR 0 3
71205: PPUSH
71206: LD_EXP 95
71210: PUSH
71211: LD_VAR 0 2
71215: ARRAY
71216: PUSH
71217: LD_INT 1
71219: ARRAY
71220: PPUSH
71221: CALL_OW 207
// if not j in mc_construct_list [ i ] then
71225: LD_VAR 0 3
71229: PUSH
71230: LD_EXP 68
71234: PUSH
71235: LD_VAR 0 2
71239: ARRAY
71240: IN
71241: NOT
71242: IFFALSE 71288
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71244: LD_ADDR_EXP 68
71248: PUSH
71249: LD_EXP 68
71253: PPUSH
71254: LD_VAR 0 2
71258: PUSH
71259: LD_EXP 68
71263: PUSH
71264: LD_VAR 0 2
71268: ARRAY
71269: PUSH
71270: LD_INT 1
71272: PLUS
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PPUSH
71278: LD_VAR 0 3
71282: PPUSH
71283: CALL 21407 0 3
71287: ST_TO_ADDR
// break ;
71288: GO 71292
// end ; end ; end ;
71290: GO 71126
71292: POP
71293: POP
// end ;
71294: GO 70886
71296: POP
71297: POP
// end ;
71298: LD_VAR 0 1
71302: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
71303: LD_INT 0
71305: PPUSH
71306: PPUSH
71307: PPUSH
71308: PPUSH
71309: PPUSH
71310: PPUSH
71311: PPUSH
71312: PPUSH
71313: PPUSH
// if not mc_bases then
71314: LD_EXP 61
71318: NOT
71319: IFFALSE 71323
// exit ;
71321: GO 71728
// for i = 1 to mc_bases do
71323: LD_ADDR_VAR 0 2
71327: PUSH
71328: DOUBLE
71329: LD_INT 1
71331: DEC
71332: ST_TO_ADDR
71333: LD_EXP 61
71337: PUSH
71338: FOR_TO
71339: IFFALSE 71726
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
71341: LD_EXP 69
71345: PUSH
71346: LD_VAR 0 2
71350: ARRAY
71351: NOT
71352: PUSH
71353: LD_EXP 61
71357: PUSH
71358: LD_VAR 0 2
71362: ARRAY
71363: PPUSH
71364: LD_INT 30
71366: PUSH
71367: LD_INT 3
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PPUSH
71374: CALL_OW 72
71378: NOT
71379: OR
71380: IFFALSE 71384
// continue ;
71382: GO 71338
// busy := false ;
71384: LD_ADDR_VAR 0 8
71388: PUSH
71389: LD_INT 0
71391: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71392: LD_ADDR_VAR 0 4
71396: PUSH
71397: LD_EXP 61
71401: PUSH
71402: LD_VAR 0 2
71406: ARRAY
71407: PPUSH
71408: LD_INT 30
71410: PUSH
71411: LD_INT 3
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PPUSH
71418: CALL_OW 72
71422: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
71423: LD_ADDR_VAR 0 6
71427: PUSH
71428: LD_EXP 69
71432: PUSH
71433: LD_VAR 0 2
71437: ARRAY
71438: PPUSH
71439: LD_INT 2
71441: PUSH
71442: LD_INT 30
71444: PUSH
71445: LD_INT 32
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 30
71454: PUSH
71455: LD_INT 33
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: LIST
71466: PPUSH
71467: CALL_OW 72
71471: ST_TO_ADDR
// if not t then
71472: LD_VAR 0 6
71476: NOT
71477: IFFALSE 71481
// continue ;
71479: GO 71338
// for j in tmp do
71481: LD_ADDR_VAR 0 3
71485: PUSH
71486: LD_VAR 0 4
71490: PUSH
71491: FOR_IN
71492: IFFALSE 71522
// if not BuildingStatus ( j ) = bs_idle then
71494: LD_VAR 0 3
71498: PPUSH
71499: CALL_OW 461
71503: PUSH
71504: LD_INT 2
71506: EQUAL
71507: NOT
71508: IFFALSE 71520
// begin busy := true ;
71510: LD_ADDR_VAR 0 8
71514: PUSH
71515: LD_INT 1
71517: ST_TO_ADDR
// break ;
71518: GO 71522
// end ;
71520: GO 71491
71522: POP
71523: POP
// if busy then
71524: LD_VAR 0 8
71528: IFFALSE 71532
// continue ;
71530: GO 71338
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
71532: LD_ADDR_VAR 0 7
71536: PUSH
71537: LD_VAR 0 6
71541: PPUSH
71542: LD_INT 35
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PPUSH
71552: CALL_OW 72
71556: ST_TO_ADDR
// if tw then
71557: LD_VAR 0 7
71561: IFFALSE 71638
// begin tw := tw [ 1 ] ;
71563: LD_ADDR_VAR 0 7
71567: PUSH
71568: LD_VAR 0 7
71572: PUSH
71573: LD_INT 1
71575: ARRAY
71576: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
71577: LD_ADDR_VAR 0 9
71581: PUSH
71582: LD_VAR 0 7
71586: PPUSH
71587: LD_EXP 86
71591: PUSH
71592: LD_VAR 0 2
71596: ARRAY
71597: PPUSH
71598: CALL 26792 0 2
71602: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
71603: LD_EXP 100
71607: PUSH
71608: LD_VAR 0 2
71612: ARRAY
71613: IFFALSE 71636
// if not weapon in mc_allowed_tower_weapons [ i ] then
71615: LD_VAR 0 9
71619: PUSH
71620: LD_EXP 100
71624: PUSH
71625: LD_VAR 0 2
71629: ARRAY
71630: IN
71631: NOT
71632: IFFALSE 71636
// continue ;
71634: GO 71338
// end else
71636: GO 71701
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
71638: LD_ADDR_VAR 0 5
71642: PUSH
71643: LD_EXP 69
71647: PUSH
71648: LD_VAR 0 2
71652: ARRAY
71653: PPUSH
71654: LD_VAR 0 4
71658: PPUSH
71659: CALL 53684 0 2
71663: ST_TO_ADDR
// if not tmp2 then
71664: LD_VAR 0 5
71668: NOT
71669: IFFALSE 71673
// continue ;
71671: GO 71338
// tw := tmp2 [ 1 ] ;
71673: LD_ADDR_VAR 0 7
71677: PUSH
71678: LD_VAR 0 5
71682: PUSH
71683: LD_INT 1
71685: ARRAY
71686: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
71687: LD_ADDR_VAR 0 9
71691: PUSH
71692: LD_VAR 0 5
71696: PUSH
71697: LD_INT 2
71699: ARRAY
71700: ST_TO_ADDR
// end ; if not weapon then
71701: LD_VAR 0 9
71705: NOT
71706: IFFALSE 71710
// continue ;
71708: GO 71338
// ComPlaceWeapon ( tw , weapon ) ;
71710: LD_VAR 0 7
71714: PPUSH
71715: LD_VAR 0 9
71719: PPUSH
71720: CALL_OW 148
// end ;
71724: GO 71338
71726: POP
71727: POP
// end ;
71728: LD_VAR 0 1
71732: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
71733: LD_INT 0
71735: PPUSH
71736: PPUSH
71737: PPUSH
71738: PPUSH
71739: PPUSH
71740: PPUSH
71741: PPUSH
// if not mc_bases then
71742: LD_EXP 61
71746: NOT
71747: IFFALSE 71751
// exit ;
71749: GO 72526
// for i = 1 to mc_bases do
71751: LD_ADDR_VAR 0 2
71755: PUSH
71756: DOUBLE
71757: LD_INT 1
71759: DEC
71760: ST_TO_ADDR
71761: LD_EXP 61
71765: PUSH
71766: FOR_TO
71767: IFFALSE 72524
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
71769: LD_EXP 74
71773: PUSH
71774: LD_VAR 0 2
71778: ARRAY
71779: NOT
71780: PUSH
71781: LD_EXP 74
71785: PUSH
71786: LD_VAR 0 2
71790: ARRAY
71791: PUSH
71792: LD_EXP 75
71796: PUSH
71797: LD_VAR 0 2
71801: ARRAY
71802: EQUAL
71803: OR
71804: PUSH
71805: LD_EXP 84
71809: PUSH
71810: LD_VAR 0 2
71814: ARRAY
71815: OR
71816: IFFALSE 71820
// continue ;
71818: GO 71766
// if mc_miners [ i ] then
71820: LD_EXP 75
71824: PUSH
71825: LD_VAR 0 2
71829: ARRAY
71830: IFFALSE 72211
// begin for j = mc_miners [ i ] downto 1 do
71832: LD_ADDR_VAR 0 3
71836: PUSH
71837: DOUBLE
71838: LD_EXP 75
71842: PUSH
71843: LD_VAR 0 2
71847: ARRAY
71848: INC
71849: ST_TO_ADDR
71850: LD_INT 1
71852: PUSH
71853: FOR_DOWNTO
71854: IFFALSE 72209
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
71856: LD_EXP 75
71860: PUSH
71861: LD_VAR 0 2
71865: ARRAY
71866: PUSH
71867: LD_VAR 0 3
71871: ARRAY
71872: PPUSH
71873: CALL_OW 301
71877: PUSH
71878: LD_EXP 75
71882: PUSH
71883: LD_VAR 0 2
71887: ARRAY
71888: PUSH
71889: LD_VAR 0 3
71893: ARRAY
71894: PPUSH
71895: CALL_OW 257
71899: PUSH
71900: LD_INT 1
71902: NONEQUAL
71903: OR
71904: IFFALSE 71967
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
71906: LD_ADDR_VAR 0 5
71910: PUSH
71911: LD_EXP 75
71915: PUSH
71916: LD_VAR 0 2
71920: ARRAY
71921: PUSH
71922: LD_EXP 75
71926: PUSH
71927: LD_VAR 0 2
71931: ARRAY
71932: PUSH
71933: LD_VAR 0 3
71937: ARRAY
71938: DIFF
71939: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
71940: LD_ADDR_EXP 75
71944: PUSH
71945: LD_EXP 75
71949: PPUSH
71950: LD_VAR 0 2
71954: PPUSH
71955: LD_VAR 0 5
71959: PPUSH
71960: CALL_OW 1
71964: ST_TO_ADDR
// continue ;
71965: GO 71853
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
71967: LD_EXP 75
71971: PUSH
71972: LD_VAR 0 2
71976: ARRAY
71977: PUSH
71978: LD_VAR 0 3
71982: ARRAY
71983: PPUSH
71984: CALL_OW 257
71988: PUSH
71989: LD_INT 1
71991: EQUAL
71992: PUSH
71993: LD_EXP 75
71997: PUSH
71998: LD_VAR 0 2
72002: ARRAY
72003: PUSH
72004: LD_VAR 0 3
72008: ARRAY
72009: PPUSH
72010: CALL_OW 459
72014: NOT
72015: AND
72016: PUSH
72017: LD_EXP 75
72021: PUSH
72022: LD_VAR 0 2
72026: ARRAY
72027: PUSH
72028: LD_VAR 0 3
72032: ARRAY
72033: PPUSH
72034: CALL_OW 314
72038: NOT
72039: AND
72040: IFFALSE 72207
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72042: LD_EXP 75
72046: PUSH
72047: LD_VAR 0 2
72051: ARRAY
72052: PUSH
72053: LD_VAR 0 3
72057: ARRAY
72058: PPUSH
72059: CALL_OW 310
72063: IFFALSE 72086
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72065: LD_EXP 75
72069: PUSH
72070: LD_VAR 0 2
72074: ARRAY
72075: PUSH
72076: LD_VAR 0 3
72080: ARRAY
72081: PPUSH
72082: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72086: LD_EXP 75
72090: PUSH
72091: LD_VAR 0 2
72095: ARRAY
72096: PUSH
72097: LD_VAR 0 3
72101: ARRAY
72102: PPUSH
72103: CALL_OW 314
72107: NOT
72108: IFFALSE 72207
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
72110: LD_ADDR_VAR 0 7
72114: PUSH
72115: LD_VAR 0 3
72119: PUSH
72120: LD_EXP 74
72124: PUSH
72125: LD_VAR 0 2
72129: ARRAY
72130: PPUSH
72131: CALL 18547 0 1
72135: MOD
72136: PUSH
72137: LD_INT 1
72139: PLUS
72140: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
72141: LD_EXP 75
72145: PUSH
72146: LD_VAR 0 2
72150: ARRAY
72151: PUSH
72152: LD_VAR 0 3
72156: ARRAY
72157: PPUSH
72158: LD_EXP 74
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PUSH
72169: LD_VAR 0 7
72173: ARRAY
72174: PUSH
72175: LD_INT 1
72177: ARRAY
72178: PPUSH
72179: LD_EXP 74
72183: PUSH
72184: LD_VAR 0 2
72188: ARRAY
72189: PUSH
72190: LD_VAR 0 7
72194: ARRAY
72195: PUSH
72196: LD_INT 2
72198: ARRAY
72199: PPUSH
72200: LD_INT 0
72202: PPUSH
72203: CALL_OW 193
// end ; end ; end ;
72207: GO 71853
72209: POP
72210: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
72211: LD_ADDR_VAR 0 5
72215: PUSH
72216: LD_EXP 61
72220: PUSH
72221: LD_VAR 0 2
72225: ARRAY
72226: PPUSH
72227: LD_INT 2
72229: PUSH
72230: LD_INT 30
72232: PUSH
72233: LD_INT 4
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 30
72242: PUSH
72243: LD_INT 5
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 30
72252: PUSH
72253: LD_INT 32
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: PPUSH
72266: CALL_OW 72
72270: ST_TO_ADDR
// if not tmp then
72271: LD_VAR 0 5
72275: NOT
72276: IFFALSE 72280
// continue ;
72278: GO 71766
// list := [ ] ;
72280: LD_ADDR_VAR 0 6
72284: PUSH
72285: EMPTY
72286: ST_TO_ADDR
// for j in tmp do
72287: LD_ADDR_VAR 0 3
72291: PUSH
72292: LD_VAR 0 5
72296: PUSH
72297: FOR_IN
72298: IFFALSE 72367
// begin for k in UnitsInside ( j ) do
72300: LD_ADDR_VAR 0 4
72304: PUSH
72305: LD_VAR 0 3
72309: PPUSH
72310: CALL_OW 313
72314: PUSH
72315: FOR_IN
72316: IFFALSE 72363
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
72318: LD_VAR 0 4
72322: PPUSH
72323: CALL_OW 257
72327: PUSH
72328: LD_INT 1
72330: EQUAL
72331: PUSH
72332: LD_VAR 0 4
72336: PPUSH
72337: CALL_OW 459
72341: NOT
72342: AND
72343: IFFALSE 72361
// list := list ^ k ;
72345: LD_ADDR_VAR 0 6
72349: PUSH
72350: LD_VAR 0 6
72354: PUSH
72355: LD_VAR 0 4
72359: ADD
72360: ST_TO_ADDR
72361: GO 72315
72363: POP
72364: POP
// end ;
72365: GO 72297
72367: POP
72368: POP
// list := list diff mc_miners [ i ] ;
72369: LD_ADDR_VAR 0 6
72373: PUSH
72374: LD_VAR 0 6
72378: PUSH
72379: LD_EXP 75
72383: PUSH
72384: LD_VAR 0 2
72388: ARRAY
72389: DIFF
72390: ST_TO_ADDR
// if not list then
72391: LD_VAR 0 6
72395: NOT
72396: IFFALSE 72400
// continue ;
72398: GO 71766
// k := mc_mines [ i ] - mc_miners [ i ] ;
72400: LD_ADDR_VAR 0 4
72404: PUSH
72405: LD_EXP 74
72409: PUSH
72410: LD_VAR 0 2
72414: ARRAY
72415: PUSH
72416: LD_EXP 75
72420: PUSH
72421: LD_VAR 0 2
72425: ARRAY
72426: MINUS
72427: ST_TO_ADDR
// if k > list then
72428: LD_VAR 0 4
72432: PUSH
72433: LD_VAR 0 6
72437: GREATER
72438: IFFALSE 72450
// k := list ;
72440: LD_ADDR_VAR 0 4
72444: PUSH
72445: LD_VAR 0 6
72449: ST_TO_ADDR
// for j = 1 to k do
72450: LD_ADDR_VAR 0 3
72454: PUSH
72455: DOUBLE
72456: LD_INT 1
72458: DEC
72459: ST_TO_ADDR
72460: LD_VAR 0 4
72464: PUSH
72465: FOR_TO
72466: IFFALSE 72520
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
72468: LD_ADDR_EXP 75
72472: PUSH
72473: LD_EXP 75
72477: PPUSH
72478: LD_VAR 0 2
72482: PUSH
72483: LD_EXP 75
72487: PUSH
72488: LD_VAR 0 2
72492: ARRAY
72493: PUSH
72494: LD_INT 1
72496: PLUS
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: LD_VAR 0 6
72506: PUSH
72507: LD_VAR 0 3
72511: ARRAY
72512: PPUSH
72513: CALL 21407 0 3
72517: ST_TO_ADDR
72518: GO 72465
72520: POP
72521: POP
// end ;
72522: GO 71766
72524: POP
72525: POP
// end ;
72526: LD_VAR 0 1
72530: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
72531: LD_INT 0
72533: PPUSH
72534: PPUSH
72535: PPUSH
72536: PPUSH
72537: PPUSH
72538: PPUSH
72539: PPUSH
72540: PPUSH
72541: PPUSH
72542: PPUSH
72543: PPUSH
// if not mc_bases then
72544: LD_EXP 61
72548: NOT
72549: IFFALSE 72553
// exit ;
72551: GO 74376
// for i = 1 to mc_bases do
72553: LD_ADDR_VAR 0 2
72557: PUSH
72558: DOUBLE
72559: LD_INT 1
72561: DEC
72562: ST_TO_ADDR
72563: LD_EXP 61
72567: PUSH
72568: FOR_TO
72569: IFFALSE 74374
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
72571: LD_EXP 61
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: NOT
72582: PUSH
72583: LD_EXP 68
72587: PUSH
72588: LD_VAR 0 2
72592: ARRAY
72593: OR
72594: IFFALSE 72598
// continue ;
72596: GO 72568
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
72598: LD_EXP 77
72602: PUSH
72603: LD_VAR 0 2
72607: ARRAY
72608: NOT
72609: PUSH
72610: LD_EXP 78
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: AND
72621: IFFALSE 72659
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
72623: LD_ADDR_EXP 78
72627: PUSH
72628: LD_EXP 78
72632: PPUSH
72633: LD_VAR 0 2
72637: PPUSH
72638: EMPTY
72639: PPUSH
72640: CALL_OW 1
72644: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
72645: LD_VAR 0 2
72649: PPUSH
72650: LD_INT 107
72652: PPUSH
72653: CALL 63385 0 2
// continue ;
72657: GO 72568
// end ; target := [ ] ;
72659: LD_ADDR_VAR 0 7
72663: PUSH
72664: EMPTY
72665: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72666: LD_ADDR_VAR 0 6
72670: PUSH
72671: LD_EXP 61
72675: PUSH
72676: LD_VAR 0 2
72680: ARRAY
72681: PUSH
72682: LD_INT 1
72684: ARRAY
72685: PPUSH
72686: CALL_OW 255
72690: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72691: LD_ADDR_VAR 0 9
72695: PUSH
72696: LD_EXP 61
72700: PUSH
72701: LD_VAR 0 2
72705: ARRAY
72706: PPUSH
72707: LD_INT 2
72709: PUSH
72710: LD_INT 30
72712: PUSH
72713: LD_INT 0
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 30
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: LIST
72734: PPUSH
72735: CALL_OW 72
72739: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
72740: LD_ADDR_VAR 0 3
72744: PUSH
72745: DOUBLE
72746: LD_EXP 77
72750: PUSH
72751: LD_VAR 0 2
72755: ARRAY
72756: INC
72757: ST_TO_ADDR
72758: LD_INT 1
72760: PUSH
72761: FOR_DOWNTO
72762: IFFALSE 73007
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
72764: LD_EXP 77
72768: PUSH
72769: LD_VAR 0 2
72773: ARRAY
72774: PUSH
72775: LD_VAR 0 3
72779: ARRAY
72780: PUSH
72781: LD_INT 2
72783: ARRAY
72784: PPUSH
72785: LD_EXP 77
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: PUSH
72796: LD_VAR 0 3
72800: ARRAY
72801: PUSH
72802: LD_INT 3
72804: ARRAY
72805: PPUSH
72806: CALL_OW 488
72810: PUSH
72811: LD_EXP 77
72815: PUSH
72816: LD_VAR 0 2
72820: ARRAY
72821: PUSH
72822: LD_VAR 0 3
72826: ARRAY
72827: PUSH
72828: LD_INT 2
72830: ARRAY
72831: PPUSH
72832: LD_EXP 77
72836: PUSH
72837: LD_VAR 0 2
72841: ARRAY
72842: PUSH
72843: LD_VAR 0 3
72847: ARRAY
72848: PUSH
72849: LD_INT 3
72851: ARRAY
72852: PPUSH
72853: CALL_OW 284
72857: PUSH
72858: LD_INT 0
72860: EQUAL
72861: AND
72862: IFFALSE 72917
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
72864: LD_ADDR_VAR 0 5
72868: PUSH
72869: LD_EXP 77
72873: PUSH
72874: LD_VAR 0 2
72878: ARRAY
72879: PPUSH
72880: LD_VAR 0 3
72884: PPUSH
72885: CALL_OW 3
72889: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
72890: LD_ADDR_EXP 77
72894: PUSH
72895: LD_EXP 77
72899: PPUSH
72900: LD_VAR 0 2
72904: PPUSH
72905: LD_VAR 0 5
72909: PPUSH
72910: CALL_OW 1
72914: ST_TO_ADDR
// continue ;
72915: GO 72761
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
72917: LD_VAR 0 6
72921: PPUSH
72922: LD_EXP 77
72926: PUSH
72927: LD_VAR 0 2
72931: ARRAY
72932: PUSH
72933: LD_VAR 0 3
72937: ARRAY
72938: PUSH
72939: LD_INT 2
72941: ARRAY
72942: PPUSH
72943: LD_EXP 77
72947: PUSH
72948: LD_VAR 0 2
72952: ARRAY
72953: PUSH
72954: LD_VAR 0 3
72958: ARRAY
72959: PUSH
72960: LD_INT 3
72962: ARRAY
72963: PPUSH
72964: LD_INT 30
72966: PPUSH
72967: CALL 22671 0 4
72971: PUSH
72972: LD_INT 4
72974: ARRAY
72975: PUSH
72976: LD_INT 0
72978: EQUAL
72979: IFFALSE 73005
// begin target := mc_crates [ i ] [ j ] ;
72981: LD_ADDR_VAR 0 7
72985: PUSH
72986: LD_EXP 77
72990: PUSH
72991: LD_VAR 0 2
72995: ARRAY
72996: PUSH
72997: LD_VAR 0 3
73001: ARRAY
73002: ST_TO_ADDR
// break ;
73003: GO 73007
// end ; end ;
73005: GO 72761
73007: POP
73008: POP
// if not target then
73009: LD_VAR 0 7
73013: NOT
73014: IFFALSE 73018
// continue ;
73016: GO 72568
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73018: LD_ADDR_VAR 0 8
73022: PUSH
73023: LD_EXP 80
73027: PUSH
73028: LD_VAR 0 2
73032: ARRAY
73033: PPUSH
73034: LD_INT 2
73036: PUSH
73037: LD_INT 3
73039: PUSH
73040: LD_INT 58
73042: PUSH
73043: EMPTY
73044: LIST
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 61
73052: PUSH
73053: EMPTY
73054: LIST
73055: PUSH
73056: LD_INT 33
73058: PUSH
73059: LD_INT 5
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 33
73068: PUSH
73069: LD_INT 3
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 2
73085: PUSH
73086: LD_INT 34
73088: PUSH
73089: LD_INT 32
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 34
73098: PUSH
73099: LD_INT 51
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 34
73108: PUSH
73109: LD_INT 12
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PPUSH
73126: CALL_OW 72
73130: ST_TO_ADDR
// if not cargo then
73131: LD_VAR 0 8
73135: NOT
73136: IFFALSE 73842
// begin if mc_crates_collector [ i ] < 5 then
73138: LD_EXP 78
73142: PUSH
73143: LD_VAR 0 2
73147: ARRAY
73148: PUSH
73149: LD_INT 5
73151: LESS
73152: IFFALSE 73518
// begin if mc_ape [ i ] then
73154: LD_EXP 90
73158: PUSH
73159: LD_VAR 0 2
73163: ARRAY
73164: IFFALSE 73211
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
73166: LD_ADDR_VAR 0 5
73170: PUSH
73171: LD_EXP 90
73175: PUSH
73176: LD_VAR 0 2
73180: ARRAY
73181: PPUSH
73182: LD_INT 25
73184: PUSH
73185: LD_INT 16
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 24
73194: PUSH
73195: LD_INT 750
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PPUSH
73206: CALL_OW 72
73210: ST_TO_ADDR
// if not tmp then
73211: LD_VAR 0 5
73215: NOT
73216: IFFALSE 73263
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
73218: LD_ADDR_VAR 0 5
73222: PUSH
73223: LD_EXP 61
73227: PUSH
73228: LD_VAR 0 2
73232: ARRAY
73233: PPUSH
73234: LD_INT 25
73236: PUSH
73237: LD_INT 2
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 24
73246: PUSH
73247: LD_INT 750
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PPUSH
73258: CALL_OW 72
73262: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
73263: LD_EXP 90
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: PUSH
73274: LD_EXP 61
73278: PUSH
73279: LD_VAR 0 2
73283: ARRAY
73284: PPUSH
73285: LD_INT 25
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 24
73297: PUSH
73298: LD_INT 750
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PPUSH
73309: CALL_OW 72
73313: AND
73314: PUSH
73315: LD_VAR 0 5
73319: PUSH
73320: LD_INT 5
73322: LESS
73323: AND
73324: IFFALSE 73406
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
73326: LD_ADDR_VAR 0 3
73330: PUSH
73331: LD_EXP 61
73335: PUSH
73336: LD_VAR 0 2
73340: ARRAY
73341: PPUSH
73342: LD_INT 25
73344: PUSH
73345: LD_INT 2
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 24
73354: PUSH
73355: LD_INT 750
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PPUSH
73366: CALL_OW 72
73370: PUSH
73371: FOR_IN
73372: IFFALSE 73404
// begin tmp := tmp union j ;
73374: LD_ADDR_VAR 0 5
73378: PUSH
73379: LD_VAR 0 5
73383: PUSH
73384: LD_VAR 0 3
73388: UNION
73389: ST_TO_ADDR
// if tmp >= 5 then
73390: LD_VAR 0 5
73394: PUSH
73395: LD_INT 5
73397: GREATEREQUAL
73398: IFFALSE 73402
// break ;
73400: GO 73404
// end ;
73402: GO 73371
73404: POP
73405: POP
// end ; if not tmp then
73406: LD_VAR 0 5
73410: NOT
73411: IFFALSE 73415
// continue ;
73413: GO 72568
// for j in tmp do
73415: LD_ADDR_VAR 0 3
73419: PUSH
73420: LD_VAR 0 5
73424: PUSH
73425: FOR_IN
73426: IFFALSE 73516
// if not GetTag ( j ) then
73428: LD_VAR 0 3
73432: PPUSH
73433: CALL_OW 110
73437: NOT
73438: IFFALSE 73514
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
73440: LD_ADDR_EXP 78
73444: PUSH
73445: LD_EXP 78
73449: PPUSH
73450: LD_VAR 0 2
73454: PUSH
73455: LD_EXP 78
73459: PUSH
73460: LD_VAR 0 2
73464: ARRAY
73465: PUSH
73466: LD_INT 1
73468: PLUS
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PPUSH
73474: LD_VAR 0 3
73478: PPUSH
73479: CALL 21407 0 3
73483: ST_TO_ADDR
// SetTag ( j , 107 ) ;
73484: LD_VAR 0 3
73488: PPUSH
73489: LD_INT 107
73491: PPUSH
73492: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
73496: LD_EXP 78
73500: PUSH
73501: LD_VAR 0 2
73505: ARRAY
73506: PUSH
73507: LD_INT 5
73509: GREATEREQUAL
73510: IFFALSE 73514
// break ;
73512: GO 73516
// end ;
73514: GO 73425
73516: POP
73517: POP
// end ; if mc_crates_collector [ i ] and target then
73518: LD_EXP 78
73522: PUSH
73523: LD_VAR 0 2
73527: ARRAY
73528: PUSH
73529: LD_VAR 0 7
73533: AND
73534: IFFALSE 73840
// begin if mc_crates_collector [ i ] < target [ 1 ] then
73536: LD_EXP 78
73540: PUSH
73541: LD_VAR 0 2
73545: ARRAY
73546: PUSH
73547: LD_VAR 0 7
73551: PUSH
73552: LD_INT 1
73554: ARRAY
73555: LESS
73556: IFFALSE 73576
// tmp := mc_crates_collector [ i ] else
73558: LD_ADDR_VAR 0 5
73562: PUSH
73563: LD_EXP 78
73567: PUSH
73568: LD_VAR 0 2
73572: ARRAY
73573: ST_TO_ADDR
73574: GO 73590
// tmp := target [ 1 ] ;
73576: LD_ADDR_VAR 0 5
73580: PUSH
73581: LD_VAR 0 7
73585: PUSH
73586: LD_INT 1
73588: ARRAY
73589: ST_TO_ADDR
// k := 0 ;
73590: LD_ADDR_VAR 0 4
73594: PUSH
73595: LD_INT 0
73597: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
73598: LD_ADDR_VAR 0 3
73602: PUSH
73603: LD_EXP 78
73607: PUSH
73608: LD_VAR 0 2
73612: ARRAY
73613: PUSH
73614: FOR_IN
73615: IFFALSE 73838
// begin k := k + 1 ;
73617: LD_ADDR_VAR 0 4
73621: PUSH
73622: LD_VAR 0 4
73626: PUSH
73627: LD_INT 1
73629: PLUS
73630: ST_TO_ADDR
// if k > tmp then
73631: LD_VAR 0 4
73635: PUSH
73636: LD_VAR 0 5
73640: GREATER
73641: IFFALSE 73645
// break ;
73643: GO 73838
// if not GetClass ( j ) in [ 2 , 16 ] then
73645: LD_VAR 0 3
73649: PPUSH
73650: CALL_OW 257
73654: PUSH
73655: LD_INT 2
73657: PUSH
73658: LD_INT 16
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: IN
73665: NOT
73666: IFFALSE 73719
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
73668: LD_ADDR_EXP 78
73672: PUSH
73673: LD_EXP 78
73677: PPUSH
73678: LD_VAR 0 2
73682: PPUSH
73683: LD_EXP 78
73687: PUSH
73688: LD_VAR 0 2
73692: ARRAY
73693: PUSH
73694: LD_VAR 0 3
73698: DIFF
73699: PPUSH
73700: CALL_OW 1
73704: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73705: LD_VAR 0 3
73709: PPUSH
73710: LD_INT 0
73712: PPUSH
73713: CALL_OW 109
// continue ;
73717: GO 73614
// end ; if IsInUnit ( j ) then
73719: LD_VAR 0 3
73723: PPUSH
73724: CALL_OW 310
73728: IFFALSE 73739
// ComExitBuilding ( j ) ;
73730: LD_VAR 0 3
73734: PPUSH
73735: CALL_OW 122
// wait ( 3 ) ;
73739: LD_INT 3
73741: PPUSH
73742: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
73746: LD_VAR 0 3
73750: PPUSH
73751: CALL_OW 314
73755: PUSH
73756: LD_VAR 0 6
73760: PPUSH
73761: LD_VAR 0 7
73765: PUSH
73766: LD_INT 2
73768: ARRAY
73769: PPUSH
73770: LD_VAR 0 7
73774: PUSH
73775: LD_INT 3
73777: ARRAY
73778: PPUSH
73779: LD_INT 30
73781: PPUSH
73782: CALL 22671 0 4
73786: PUSH
73787: LD_INT 4
73789: ARRAY
73790: AND
73791: IFFALSE 73809
// ComStandNearbyBuilding ( j , depot ) else
73793: LD_VAR 0 3
73797: PPUSH
73798: LD_VAR 0 9
73802: PPUSH
73803: CALL 18009 0 2
73807: GO 73836
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73809: LD_VAR 0 3
73813: PPUSH
73814: LD_VAR 0 7
73818: PUSH
73819: LD_INT 2
73821: ARRAY
73822: PPUSH
73823: LD_VAR 0 7
73827: PUSH
73828: LD_INT 3
73830: ARRAY
73831: PPUSH
73832: CALL_OW 117
// end ;
73836: GO 73614
73838: POP
73839: POP
// end ; end else
73840: GO 74372
// begin for j in cargo do
73842: LD_ADDR_VAR 0 3
73846: PUSH
73847: LD_VAR 0 8
73851: PUSH
73852: FOR_IN
73853: IFFALSE 74370
// begin if GetTag ( j ) <> 0 then
73855: LD_VAR 0 3
73859: PPUSH
73860: CALL_OW 110
73864: PUSH
73865: LD_INT 0
73867: NONEQUAL
73868: IFFALSE 73872
// continue ;
73870: GO 73852
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
73872: LD_VAR 0 3
73876: PPUSH
73877: CALL_OW 256
73881: PUSH
73882: LD_INT 1000
73884: LESS
73885: PUSH
73886: LD_VAR 0 3
73890: PPUSH
73891: LD_EXP 85
73895: PUSH
73896: LD_VAR 0 2
73900: ARRAY
73901: PPUSH
73902: CALL_OW 308
73906: NOT
73907: AND
73908: IFFALSE 73930
// ComMoveToArea ( j , mc_parking [ i ] ) ;
73910: LD_VAR 0 3
73914: PPUSH
73915: LD_EXP 85
73919: PUSH
73920: LD_VAR 0 2
73924: ARRAY
73925: PPUSH
73926: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
73930: LD_VAR 0 3
73934: PPUSH
73935: CALL_OW 256
73939: PUSH
73940: LD_INT 1000
73942: LESS
73943: PUSH
73944: LD_VAR 0 3
73948: PPUSH
73949: LD_EXP 85
73953: PUSH
73954: LD_VAR 0 2
73958: ARRAY
73959: PPUSH
73960: CALL_OW 308
73964: AND
73965: IFFALSE 73969
// continue ;
73967: GO 73852
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
73969: LD_VAR 0 3
73973: PPUSH
73974: CALL_OW 262
73978: PUSH
73979: LD_INT 2
73981: EQUAL
73982: PUSH
73983: LD_VAR 0 3
73987: PPUSH
73988: CALL_OW 261
73992: PUSH
73993: LD_INT 15
73995: LESS
73996: AND
73997: IFFALSE 74001
// continue ;
73999: GO 73852
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74001: LD_VAR 0 3
74005: PPUSH
74006: CALL_OW 262
74010: PUSH
74011: LD_INT 1
74013: EQUAL
74014: PUSH
74015: LD_VAR 0 3
74019: PPUSH
74020: CALL_OW 261
74024: PUSH
74025: LD_INT 10
74027: LESS
74028: AND
74029: IFFALSE 74309
// begin if not depot then
74031: LD_VAR 0 9
74035: NOT
74036: IFFALSE 74040
// continue ;
74038: GO 73852
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74040: LD_VAR 0 3
74044: PPUSH
74045: LD_VAR 0 9
74049: PPUSH
74050: LD_VAR 0 3
74054: PPUSH
74055: CALL_OW 74
74059: PPUSH
74060: CALL_OW 296
74064: PUSH
74065: LD_INT 6
74067: LESS
74068: IFFALSE 74084
// SetFuel ( j , 100 ) else
74070: LD_VAR 0 3
74074: PPUSH
74075: LD_INT 100
74077: PPUSH
74078: CALL_OW 240
74082: GO 74309
// if GetFuel ( j ) = 0 then
74084: LD_VAR 0 3
74088: PPUSH
74089: CALL_OW 261
74093: PUSH
74094: LD_INT 0
74096: EQUAL
74097: IFFALSE 74309
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74099: LD_ADDR_EXP 80
74103: PUSH
74104: LD_EXP 80
74108: PPUSH
74109: LD_VAR 0 2
74113: PPUSH
74114: LD_EXP 80
74118: PUSH
74119: LD_VAR 0 2
74123: ARRAY
74124: PUSH
74125: LD_VAR 0 3
74129: DIFF
74130: PPUSH
74131: CALL_OW 1
74135: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
74136: LD_VAR 0 3
74140: PPUSH
74141: CALL_OW 263
74145: PUSH
74146: LD_INT 1
74148: EQUAL
74149: IFFALSE 74165
// ComExitVehicle ( IsInUnit ( j ) ) ;
74151: LD_VAR 0 3
74155: PPUSH
74156: CALL_OW 310
74160: PPUSH
74161: CALL_OW 121
// if GetControl ( j ) = control_remote then
74165: LD_VAR 0 3
74169: PPUSH
74170: CALL_OW 263
74174: PUSH
74175: LD_INT 2
74177: EQUAL
74178: IFFALSE 74189
// ComUnlink ( j ) ;
74180: LD_VAR 0 3
74184: PPUSH
74185: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
74189: LD_ADDR_VAR 0 10
74193: PUSH
74194: LD_VAR 0 2
74198: PPUSH
74199: LD_INT 3
74201: PPUSH
74202: CALL 83953 0 2
74206: ST_TO_ADDR
// if fac then
74207: LD_VAR 0 10
74211: IFFALSE 74307
// begin for k in fac do
74213: LD_ADDR_VAR 0 4
74217: PUSH
74218: LD_VAR 0 10
74222: PUSH
74223: FOR_IN
74224: IFFALSE 74305
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
74226: LD_ADDR_VAR 0 11
74230: PUSH
74231: LD_VAR 0 10
74235: PPUSH
74236: LD_VAR 0 3
74240: PPUSH
74241: CALL_OW 265
74245: PPUSH
74246: LD_VAR 0 3
74250: PPUSH
74251: CALL_OW 262
74255: PPUSH
74256: LD_VAR 0 3
74260: PPUSH
74261: CALL_OW 263
74265: PPUSH
74266: LD_VAR 0 3
74270: PPUSH
74271: CALL_OW 264
74275: PPUSH
74276: CALL 18905 0 5
74280: ST_TO_ADDR
// if components then
74281: LD_VAR 0 11
74285: IFFALSE 74303
// begin MC_InsertProduceList ( i , components ) ;
74287: LD_VAR 0 2
74291: PPUSH
74292: LD_VAR 0 11
74296: PPUSH
74297: CALL 83498 0 2
// break ;
74301: GO 74305
// end ; end ;
74303: GO 74223
74305: POP
74306: POP
// end ; continue ;
74307: GO 73852
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
74309: LD_VAR 0 3
74313: PPUSH
74314: LD_INT 1
74316: PPUSH
74317: CALL_OW 289
74321: PUSH
74322: LD_INT 100
74324: LESS
74325: PUSH
74326: LD_VAR 0 3
74330: PPUSH
74331: CALL_OW 314
74335: NOT
74336: AND
74337: IFFALSE 74366
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74339: LD_VAR 0 3
74343: PPUSH
74344: LD_VAR 0 7
74348: PUSH
74349: LD_INT 2
74351: ARRAY
74352: PPUSH
74353: LD_VAR 0 7
74357: PUSH
74358: LD_INT 3
74360: ARRAY
74361: PPUSH
74362: CALL_OW 117
// break ;
74366: GO 74370
// end ;
74368: GO 73852
74370: POP
74371: POP
// end ; end ;
74372: GO 72568
74374: POP
74375: POP
// end ;
74376: LD_VAR 0 1
74380: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
74381: LD_INT 0
74383: PPUSH
74384: PPUSH
74385: PPUSH
74386: PPUSH
// if not mc_bases then
74387: LD_EXP 61
74391: NOT
74392: IFFALSE 74396
// exit ;
74394: GO 74557
// for i = 1 to mc_bases do
74396: LD_ADDR_VAR 0 2
74400: PUSH
74401: DOUBLE
74402: LD_INT 1
74404: DEC
74405: ST_TO_ADDR
74406: LD_EXP 61
74410: PUSH
74411: FOR_TO
74412: IFFALSE 74555
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
74414: LD_ADDR_VAR 0 4
74418: PUSH
74419: LD_EXP 80
74423: PUSH
74424: LD_VAR 0 2
74428: ARRAY
74429: PUSH
74430: LD_EXP 83
74434: PUSH
74435: LD_VAR 0 2
74439: ARRAY
74440: UNION
74441: PPUSH
74442: LD_INT 33
74444: PUSH
74445: LD_INT 2
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PPUSH
74452: CALL_OW 72
74456: ST_TO_ADDR
// if tmp then
74457: LD_VAR 0 4
74461: IFFALSE 74553
// for j in tmp do
74463: LD_ADDR_VAR 0 3
74467: PUSH
74468: LD_VAR 0 4
74472: PUSH
74473: FOR_IN
74474: IFFALSE 74551
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
74476: LD_VAR 0 3
74480: PPUSH
74481: CALL_OW 312
74485: NOT
74486: PUSH
74487: LD_VAR 0 3
74491: PPUSH
74492: CALL_OW 256
74496: PUSH
74497: LD_INT 250
74499: GREATEREQUAL
74500: AND
74501: IFFALSE 74514
// Connect ( j ) else
74503: LD_VAR 0 3
74507: PPUSH
74508: CALL 24753 0 1
74512: GO 74549
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
74514: LD_VAR 0 3
74518: PPUSH
74519: CALL_OW 256
74523: PUSH
74524: LD_INT 250
74526: LESS
74527: PUSH
74528: LD_VAR 0 3
74532: PPUSH
74533: CALL_OW 312
74537: AND
74538: IFFALSE 74549
// ComUnlink ( j ) ;
74540: LD_VAR 0 3
74544: PPUSH
74545: CALL_OW 136
74549: GO 74473
74551: POP
74552: POP
// end ;
74553: GO 74411
74555: POP
74556: POP
// end ;
74557: LD_VAR 0 1
74561: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
74562: LD_INT 0
74564: PPUSH
74565: PPUSH
74566: PPUSH
74567: PPUSH
74568: PPUSH
// if not mc_bases then
74569: LD_EXP 61
74573: NOT
74574: IFFALSE 74578
// exit ;
74576: GO 75023
// for i = 1 to mc_bases do
74578: LD_ADDR_VAR 0 2
74582: PUSH
74583: DOUBLE
74584: LD_INT 1
74586: DEC
74587: ST_TO_ADDR
74588: LD_EXP 61
74592: PUSH
74593: FOR_TO
74594: IFFALSE 75021
// begin if not mc_produce [ i ] then
74596: LD_EXP 82
74600: PUSH
74601: LD_VAR 0 2
74605: ARRAY
74606: NOT
74607: IFFALSE 74611
// continue ;
74609: GO 74593
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74611: LD_ADDR_VAR 0 5
74615: PUSH
74616: LD_EXP 61
74620: PUSH
74621: LD_VAR 0 2
74625: ARRAY
74626: PPUSH
74627: LD_INT 30
74629: PUSH
74630: LD_INT 3
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PPUSH
74637: CALL_OW 72
74641: ST_TO_ADDR
// if not fac then
74642: LD_VAR 0 5
74646: NOT
74647: IFFALSE 74651
// continue ;
74649: GO 74593
// for j in fac do
74651: LD_ADDR_VAR 0 3
74655: PUSH
74656: LD_VAR 0 5
74660: PUSH
74661: FOR_IN
74662: IFFALSE 75017
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
74664: LD_VAR 0 3
74668: PPUSH
74669: CALL_OW 461
74673: PUSH
74674: LD_INT 2
74676: NONEQUAL
74677: PUSH
74678: LD_VAR 0 3
74682: PPUSH
74683: LD_INT 15
74685: PPUSH
74686: CALL 24372 0 2
74690: PUSH
74691: LD_INT 4
74693: ARRAY
74694: OR
74695: IFFALSE 74699
// continue ;
74697: GO 74661
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
74699: LD_VAR 0 3
74703: PPUSH
74704: LD_EXP 82
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: PUSH
74719: LD_INT 1
74721: ARRAY
74722: PPUSH
74723: LD_EXP 82
74727: PUSH
74728: LD_VAR 0 2
74732: ARRAY
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: PUSH
74738: LD_INT 2
74740: ARRAY
74741: PPUSH
74742: LD_EXP 82
74746: PUSH
74747: LD_VAR 0 2
74751: ARRAY
74752: PUSH
74753: LD_INT 1
74755: ARRAY
74756: PUSH
74757: LD_INT 3
74759: ARRAY
74760: PPUSH
74761: LD_EXP 82
74765: PUSH
74766: LD_VAR 0 2
74770: ARRAY
74771: PUSH
74772: LD_INT 1
74774: ARRAY
74775: PUSH
74776: LD_INT 4
74778: ARRAY
74779: PPUSH
74780: CALL_OW 448
74784: PUSH
74785: LD_VAR 0 3
74789: PPUSH
74790: LD_EXP 82
74794: PUSH
74795: LD_VAR 0 2
74799: ARRAY
74800: PUSH
74801: LD_INT 1
74803: ARRAY
74804: PUSH
74805: LD_INT 1
74807: ARRAY
74808: PUSH
74809: LD_EXP 82
74813: PUSH
74814: LD_VAR 0 2
74818: ARRAY
74819: PUSH
74820: LD_INT 1
74822: ARRAY
74823: PUSH
74824: LD_INT 2
74826: ARRAY
74827: PUSH
74828: LD_EXP 82
74832: PUSH
74833: LD_VAR 0 2
74837: ARRAY
74838: PUSH
74839: LD_INT 1
74841: ARRAY
74842: PUSH
74843: LD_INT 3
74845: ARRAY
74846: PUSH
74847: LD_EXP 82
74851: PUSH
74852: LD_VAR 0 2
74856: ARRAY
74857: PUSH
74858: LD_INT 1
74860: ARRAY
74861: PUSH
74862: LD_INT 4
74864: ARRAY
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: PPUSH
74872: CALL 28148 0 2
74876: AND
74877: IFFALSE 75015
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
74879: LD_VAR 0 3
74883: PPUSH
74884: LD_EXP 82
74888: PUSH
74889: LD_VAR 0 2
74893: ARRAY
74894: PUSH
74895: LD_INT 1
74897: ARRAY
74898: PUSH
74899: LD_INT 1
74901: ARRAY
74902: PPUSH
74903: LD_EXP 82
74907: PUSH
74908: LD_VAR 0 2
74912: ARRAY
74913: PUSH
74914: LD_INT 1
74916: ARRAY
74917: PUSH
74918: LD_INT 2
74920: ARRAY
74921: PPUSH
74922: LD_EXP 82
74926: PUSH
74927: LD_VAR 0 2
74931: ARRAY
74932: PUSH
74933: LD_INT 1
74935: ARRAY
74936: PUSH
74937: LD_INT 3
74939: ARRAY
74940: PPUSH
74941: LD_EXP 82
74945: PUSH
74946: LD_VAR 0 2
74950: ARRAY
74951: PUSH
74952: LD_INT 1
74954: ARRAY
74955: PUSH
74956: LD_INT 4
74958: ARRAY
74959: PPUSH
74960: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
74964: LD_ADDR_VAR 0 4
74968: PUSH
74969: LD_EXP 82
74973: PUSH
74974: LD_VAR 0 2
74978: ARRAY
74979: PPUSH
74980: LD_INT 1
74982: PPUSH
74983: CALL_OW 3
74987: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74988: LD_ADDR_EXP 82
74992: PUSH
74993: LD_EXP 82
74997: PPUSH
74998: LD_VAR 0 2
75002: PPUSH
75003: LD_VAR 0 4
75007: PPUSH
75008: CALL_OW 1
75012: ST_TO_ADDR
// break ;
75013: GO 75017
// end ; end ;
75015: GO 74661
75017: POP
75018: POP
// end ;
75019: GO 74593
75021: POP
75022: POP
// end ;
75023: LD_VAR 0 1
75027: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75028: LD_INT 0
75030: PPUSH
75031: PPUSH
75032: PPUSH
// if not mc_bases then
75033: LD_EXP 61
75037: NOT
75038: IFFALSE 75042
// exit ;
75040: GO 75131
// for i = 1 to mc_bases do
75042: LD_ADDR_VAR 0 2
75046: PUSH
75047: DOUBLE
75048: LD_INT 1
75050: DEC
75051: ST_TO_ADDR
75052: LD_EXP 61
75056: PUSH
75057: FOR_TO
75058: IFFALSE 75129
// begin if mc_attack [ i ] then
75060: LD_EXP 81
75064: PUSH
75065: LD_VAR 0 2
75069: ARRAY
75070: IFFALSE 75127
// begin tmp := mc_attack [ i ] [ 1 ] ;
75072: LD_ADDR_VAR 0 3
75076: PUSH
75077: LD_EXP 81
75081: PUSH
75082: LD_VAR 0 2
75086: ARRAY
75087: PUSH
75088: LD_INT 1
75090: ARRAY
75091: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75092: LD_ADDR_EXP 81
75096: PUSH
75097: LD_EXP 81
75101: PPUSH
75102: LD_VAR 0 2
75106: PPUSH
75107: EMPTY
75108: PPUSH
75109: CALL_OW 1
75113: ST_TO_ADDR
// Attack ( tmp ) ;
75114: LD_VAR 0 3
75118: PPUSH
75119: CALL 110637 0 1
// exit ;
75123: POP
75124: POP
75125: GO 75131
// end ; end ;
75127: GO 75057
75129: POP
75130: POP
// end ;
75131: LD_VAR 0 1
75135: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
75136: LD_INT 0
75138: PPUSH
75139: PPUSH
75140: PPUSH
75141: PPUSH
75142: PPUSH
75143: PPUSH
75144: PPUSH
// if not mc_bases then
75145: LD_EXP 61
75149: NOT
75150: IFFALSE 75154
// exit ;
75152: GO 76011
// for i = 1 to mc_bases do
75154: LD_ADDR_VAR 0 2
75158: PUSH
75159: DOUBLE
75160: LD_INT 1
75162: DEC
75163: ST_TO_ADDR
75164: LD_EXP 61
75168: PUSH
75169: FOR_TO
75170: IFFALSE 76009
// begin if not mc_bases [ i ] then
75172: LD_EXP 61
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: NOT
75183: IFFALSE 75187
// continue ;
75185: GO 75169
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
75187: LD_ADDR_VAR 0 7
75191: PUSH
75192: LD_EXP 61
75196: PUSH
75197: LD_VAR 0 2
75201: ARRAY
75202: PUSH
75203: LD_INT 1
75205: ARRAY
75206: PPUSH
75207: CALL 18231 0 1
75211: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
75212: LD_ADDR_EXP 84
75216: PUSH
75217: LD_EXP 84
75221: PPUSH
75222: LD_VAR 0 2
75226: PPUSH
75227: LD_EXP 61
75231: PUSH
75232: LD_VAR 0 2
75236: ARRAY
75237: PUSH
75238: LD_INT 1
75240: ARRAY
75241: PPUSH
75242: CALL_OW 255
75246: PPUSH
75247: LD_EXP 86
75251: PUSH
75252: LD_VAR 0 2
75256: ARRAY
75257: PPUSH
75258: CALL 18196 0 2
75262: PPUSH
75263: CALL_OW 1
75267: ST_TO_ADDR
// if not mc_scan [ i ] then
75268: LD_EXP 84
75272: PUSH
75273: LD_VAR 0 2
75277: ARRAY
75278: NOT
75279: IFFALSE 75457
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
75281: LD_ADDR_EXP 104
75285: PUSH
75286: LD_EXP 104
75290: PPUSH
75291: LD_VAR 0 2
75295: PPUSH
75296: LD_INT 0
75298: PPUSH
75299: CALL_OW 1
75303: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75304: LD_ADDR_VAR 0 4
75308: PUSH
75309: LD_EXP 61
75313: PUSH
75314: LD_VAR 0 2
75318: ARRAY
75319: PPUSH
75320: LD_INT 2
75322: PUSH
75323: LD_INT 25
75325: PUSH
75326: LD_INT 5
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 25
75335: PUSH
75336: LD_INT 8
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 25
75345: PUSH
75346: LD_INT 9
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: PPUSH
75359: CALL_OW 72
75363: ST_TO_ADDR
// if not tmp then
75364: LD_VAR 0 4
75368: NOT
75369: IFFALSE 75373
// continue ;
75371: GO 75169
// for j in tmp do
75373: LD_ADDR_VAR 0 3
75377: PUSH
75378: LD_VAR 0 4
75382: PUSH
75383: FOR_IN
75384: IFFALSE 75455
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
75386: LD_VAR 0 3
75390: PPUSH
75391: CALL_OW 310
75395: PPUSH
75396: CALL_OW 266
75400: PUSH
75401: LD_INT 5
75403: EQUAL
75404: PUSH
75405: LD_VAR 0 3
75409: PPUSH
75410: CALL_OW 257
75414: PUSH
75415: LD_INT 1
75417: EQUAL
75418: AND
75419: PUSH
75420: LD_VAR 0 3
75424: PPUSH
75425: CALL_OW 459
75429: NOT
75430: AND
75431: PUSH
75432: LD_VAR 0 7
75436: AND
75437: IFFALSE 75453
// ComChangeProfession ( j , class ) ;
75439: LD_VAR 0 3
75443: PPUSH
75444: LD_VAR 0 7
75448: PPUSH
75449: CALL_OW 123
75453: GO 75383
75455: POP
75456: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
75457: LD_EXP 84
75461: PUSH
75462: LD_VAR 0 2
75466: ARRAY
75467: PUSH
75468: LD_EXP 104
75472: PUSH
75473: LD_VAR 0 2
75477: ARRAY
75478: NOT
75479: AND
75480: PUSH
75481: LD_EXP 83
75485: PUSH
75486: LD_VAR 0 2
75490: ARRAY
75491: NOT
75492: AND
75493: PUSH
75494: LD_EXP 61
75498: PUSH
75499: LD_VAR 0 2
75503: ARRAY
75504: PPUSH
75505: LD_INT 50
75507: PUSH
75508: EMPTY
75509: LIST
75510: PUSH
75511: LD_INT 2
75513: PUSH
75514: LD_INT 30
75516: PUSH
75517: LD_INT 32
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 30
75526: PUSH
75527: LD_INT 33
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 30
75536: PUSH
75537: LD_INT 4
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 30
75546: PUSH
75547: LD_INT 5
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PPUSH
75565: CALL_OW 72
75569: PUSH
75570: LD_INT 4
75572: LESS
75573: PUSH
75574: LD_EXP 61
75578: PUSH
75579: LD_VAR 0 2
75583: ARRAY
75584: PPUSH
75585: LD_INT 3
75587: PUSH
75588: LD_INT 24
75590: PUSH
75591: LD_INT 1000
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 2
75604: PUSH
75605: LD_INT 30
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: PUSH
75615: LD_INT 30
75617: PUSH
75618: LD_INT 1
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: LIST
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PPUSH
75634: CALL_OW 72
75638: OR
75639: AND
75640: IFFALSE 75891
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75642: LD_ADDR_EXP 104
75646: PUSH
75647: LD_EXP 104
75651: PPUSH
75652: LD_VAR 0 2
75656: PPUSH
75657: LD_INT 1
75659: PPUSH
75660: CALL_OW 1
75664: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
75665: LD_ADDR_VAR 0 4
75669: PUSH
75670: LD_EXP 61
75674: PUSH
75675: LD_VAR 0 2
75679: ARRAY
75680: PPUSH
75681: LD_INT 2
75683: PUSH
75684: LD_INT 25
75686: PUSH
75687: LD_INT 1
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 25
75696: PUSH
75697: LD_INT 5
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 25
75706: PUSH
75707: LD_INT 8
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 25
75716: PUSH
75717: LD_INT 9
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: PPUSH
75731: CALL_OW 72
75735: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
75736: LD_ADDR_VAR 0 4
75740: PUSH
75741: LD_VAR 0 4
75745: PUSH
75746: LD_VAR 0 4
75750: PPUSH
75751: LD_INT 18
75753: PPUSH
75754: CALL 51705 0 2
75758: DIFF
75759: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
75760: LD_VAR 0 4
75764: NOT
75765: PUSH
75766: LD_EXP 61
75770: PUSH
75771: LD_VAR 0 2
75775: ARRAY
75776: PPUSH
75777: LD_INT 2
75779: PUSH
75780: LD_INT 30
75782: PUSH
75783: LD_INT 4
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 30
75792: PUSH
75793: LD_INT 5
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: PPUSH
75805: CALL_OW 72
75809: NOT
75810: AND
75811: IFFALSE 75873
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
75813: LD_ADDR_VAR 0 4
75817: PUSH
75818: LD_EXP 61
75822: PUSH
75823: LD_VAR 0 2
75827: ARRAY
75828: PPUSH
75829: LD_INT 2
75831: PUSH
75832: LD_INT 25
75834: PUSH
75835: LD_INT 2
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 25
75844: PUSH
75845: LD_INT 3
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 25
75854: PUSH
75855: LD_INT 4
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: PPUSH
75868: CALL_OW 72
75872: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
75873: LD_VAR 0 2
75877: PPUSH
75878: LD_VAR 0 4
75882: PPUSH
75883: CALL 115346 0 2
// exit ;
75887: POP
75888: POP
75889: GO 76011
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
75891: LD_EXP 84
75895: PUSH
75896: LD_VAR 0 2
75900: ARRAY
75901: PUSH
75902: LD_EXP 104
75906: PUSH
75907: LD_VAR 0 2
75911: ARRAY
75912: NOT
75913: AND
75914: PUSH
75915: LD_EXP 83
75919: PUSH
75920: LD_VAR 0 2
75924: ARRAY
75925: AND
75926: IFFALSE 76007
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
75928: LD_ADDR_EXP 104
75932: PUSH
75933: LD_EXP 104
75937: PPUSH
75938: LD_VAR 0 2
75942: PPUSH
75943: LD_INT 1
75945: PPUSH
75946: CALL_OW 1
75950: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
75951: LD_ADDR_VAR 0 4
75955: PUSH
75956: LD_EXP 83
75960: PUSH
75961: LD_VAR 0 2
75965: ARRAY
75966: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
75967: LD_ADDR_EXP 83
75971: PUSH
75972: LD_EXP 83
75976: PPUSH
75977: LD_VAR 0 2
75981: PPUSH
75982: EMPTY
75983: PPUSH
75984: CALL_OW 1
75988: ST_TO_ADDR
// Defend ( i , tmp ) ;
75989: LD_VAR 0 2
75993: PPUSH
75994: LD_VAR 0 4
75998: PPUSH
75999: CALL 115942 0 2
// exit ;
76003: POP
76004: POP
76005: GO 76011
// end ; end ;
76007: GO 75169
76009: POP
76010: POP
// end ;
76011: LD_VAR 0 1
76015: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76016: LD_INT 0
76018: PPUSH
76019: PPUSH
76020: PPUSH
76021: PPUSH
76022: PPUSH
76023: PPUSH
76024: PPUSH
76025: PPUSH
76026: PPUSH
76027: PPUSH
76028: PPUSH
// if not mc_bases then
76029: LD_EXP 61
76033: NOT
76034: IFFALSE 76038
// exit ;
76036: GO 77125
// for i = 1 to mc_bases do
76038: LD_ADDR_VAR 0 2
76042: PUSH
76043: DOUBLE
76044: LD_INT 1
76046: DEC
76047: ST_TO_ADDR
76048: LD_EXP 61
76052: PUSH
76053: FOR_TO
76054: IFFALSE 77123
// begin tmp := mc_lab [ i ] ;
76056: LD_ADDR_VAR 0 6
76060: PUSH
76061: LD_EXP 94
76065: PUSH
76066: LD_VAR 0 2
76070: ARRAY
76071: ST_TO_ADDR
// if not tmp then
76072: LD_VAR 0 6
76076: NOT
76077: IFFALSE 76081
// continue ;
76079: GO 76053
// idle_lab := 0 ;
76081: LD_ADDR_VAR 0 11
76085: PUSH
76086: LD_INT 0
76088: ST_TO_ADDR
// for j in tmp do
76089: LD_ADDR_VAR 0 3
76093: PUSH
76094: LD_VAR 0 6
76098: PUSH
76099: FOR_IN
76100: IFFALSE 77119
// begin researching := false ;
76102: LD_ADDR_VAR 0 10
76106: PUSH
76107: LD_INT 0
76109: ST_TO_ADDR
// side := GetSide ( j ) ;
76110: LD_ADDR_VAR 0 4
76114: PUSH
76115: LD_VAR 0 3
76119: PPUSH
76120: CALL_OW 255
76124: ST_TO_ADDR
// if not mc_tech [ side ] then
76125: LD_EXP 88
76129: PUSH
76130: LD_VAR 0 4
76134: ARRAY
76135: NOT
76136: IFFALSE 76140
// continue ;
76138: GO 76099
// if BuildingStatus ( j ) = bs_idle then
76140: LD_VAR 0 3
76144: PPUSH
76145: CALL_OW 461
76149: PUSH
76150: LD_INT 2
76152: EQUAL
76153: IFFALSE 76341
// begin if idle_lab and UnitsInside ( j ) < 6 then
76155: LD_VAR 0 11
76159: PUSH
76160: LD_VAR 0 3
76164: PPUSH
76165: CALL_OW 313
76169: PUSH
76170: LD_INT 6
76172: LESS
76173: AND
76174: IFFALSE 76245
// begin tmp2 := UnitsInside ( idle_lab ) ;
76176: LD_ADDR_VAR 0 9
76180: PUSH
76181: LD_VAR 0 11
76185: PPUSH
76186: CALL_OW 313
76190: ST_TO_ADDR
// if tmp2 then
76191: LD_VAR 0 9
76195: IFFALSE 76237
// for x in tmp2 do
76197: LD_ADDR_VAR 0 7
76201: PUSH
76202: LD_VAR 0 9
76206: PUSH
76207: FOR_IN
76208: IFFALSE 76235
// begin ComExitBuilding ( x ) ;
76210: LD_VAR 0 7
76214: PPUSH
76215: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76219: LD_VAR 0 7
76223: PPUSH
76224: LD_VAR 0 3
76228: PPUSH
76229: CALL_OW 180
// end ;
76233: GO 76207
76235: POP
76236: POP
// idle_lab := 0 ;
76237: LD_ADDR_VAR 0 11
76241: PUSH
76242: LD_INT 0
76244: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
76245: LD_ADDR_VAR 0 5
76249: PUSH
76250: LD_EXP 88
76254: PUSH
76255: LD_VAR 0 4
76259: ARRAY
76260: PUSH
76261: FOR_IN
76262: IFFALSE 76322
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
76264: LD_VAR 0 3
76268: PPUSH
76269: LD_VAR 0 5
76273: PPUSH
76274: CALL_OW 430
76278: PUSH
76279: LD_VAR 0 4
76283: PPUSH
76284: LD_VAR 0 5
76288: PPUSH
76289: CALL 17301 0 2
76293: AND
76294: IFFALSE 76320
// begin researching := true ;
76296: LD_ADDR_VAR 0 10
76300: PUSH
76301: LD_INT 1
76303: ST_TO_ADDR
// ComResearch ( j , t ) ;
76304: LD_VAR 0 3
76308: PPUSH
76309: LD_VAR 0 5
76313: PPUSH
76314: CALL_OW 124
// break ;
76318: GO 76322
// end ;
76320: GO 76261
76322: POP
76323: POP
// if not researching then
76324: LD_VAR 0 10
76328: NOT
76329: IFFALSE 76341
// idle_lab := j ;
76331: LD_ADDR_VAR 0 11
76335: PUSH
76336: LD_VAR 0 3
76340: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
76341: LD_VAR 0 3
76345: PPUSH
76346: CALL_OW 461
76350: PUSH
76351: LD_INT 10
76353: EQUAL
76354: IFFALSE 76942
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
76356: LD_EXP 90
76360: PUSH
76361: LD_VAR 0 2
76365: ARRAY
76366: NOT
76367: PUSH
76368: LD_EXP 91
76372: PUSH
76373: LD_VAR 0 2
76377: ARRAY
76378: NOT
76379: AND
76380: PUSH
76381: LD_EXP 88
76385: PUSH
76386: LD_VAR 0 4
76390: ARRAY
76391: PUSH
76392: LD_INT 1
76394: GREATER
76395: AND
76396: IFFALSE 76527
// begin ComCancel ( j ) ;
76398: LD_VAR 0 3
76402: PPUSH
76403: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
76407: LD_ADDR_EXP 88
76411: PUSH
76412: LD_EXP 88
76416: PPUSH
76417: LD_VAR 0 4
76421: PPUSH
76422: LD_EXP 88
76426: PUSH
76427: LD_VAR 0 4
76431: ARRAY
76432: PPUSH
76433: LD_EXP 88
76437: PUSH
76438: LD_VAR 0 4
76442: ARRAY
76443: PUSH
76444: LD_INT 1
76446: MINUS
76447: PPUSH
76448: LD_EXP 88
76452: PUSH
76453: LD_VAR 0 4
76457: ARRAY
76458: PPUSH
76459: LD_INT 0
76461: PPUSH
76462: CALL 20825 0 4
76466: PPUSH
76467: CALL_OW 1
76471: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
76472: LD_ADDR_EXP 88
76476: PUSH
76477: LD_EXP 88
76481: PPUSH
76482: LD_VAR 0 4
76486: PPUSH
76487: LD_EXP 88
76491: PUSH
76492: LD_VAR 0 4
76496: ARRAY
76497: PPUSH
76498: LD_EXP 88
76502: PUSH
76503: LD_VAR 0 4
76507: ARRAY
76508: PPUSH
76509: LD_INT 1
76511: PPUSH
76512: LD_INT 0
76514: PPUSH
76515: CALL 20825 0 4
76519: PPUSH
76520: CALL_OW 1
76524: ST_TO_ADDR
// continue ;
76525: GO 76099
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
76527: LD_EXP 90
76531: PUSH
76532: LD_VAR 0 2
76536: ARRAY
76537: PUSH
76538: LD_EXP 91
76542: PUSH
76543: LD_VAR 0 2
76547: ARRAY
76548: NOT
76549: AND
76550: IFFALSE 76677
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
76552: LD_ADDR_EXP 91
76556: PUSH
76557: LD_EXP 91
76561: PPUSH
76562: LD_VAR 0 2
76566: PUSH
76567: LD_EXP 91
76571: PUSH
76572: LD_VAR 0 2
76576: ARRAY
76577: PUSH
76578: LD_INT 1
76580: PLUS
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PPUSH
76586: LD_EXP 90
76590: PUSH
76591: LD_VAR 0 2
76595: ARRAY
76596: PUSH
76597: LD_INT 1
76599: ARRAY
76600: PPUSH
76601: CALL 21407 0 3
76605: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
76606: LD_EXP 90
76610: PUSH
76611: LD_VAR 0 2
76615: ARRAY
76616: PUSH
76617: LD_INT 1
76619: ARRAY
76620: PPUSH
76621: LD_INT 112
76623: PPUSH
76624: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
76628: LD_ADDR_VAR 0 9
76632: PUSH
76633: LD_EXP 90
76637: PUSH
76638: LD_VAR 0 2
76642: ARRAY
76643: PPUSH
76644: LD_INT 1
76646: PPUSH
76647: CALL_OW 3
76651: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
76652: LD_ADDR_EXP 90
76656: PUSH
76657: LD_EXP 90
76661: PPUSH
76662: LD_VAR 0 2
76666: PPUSH
76667: LD_VAR 0 9
76671: PPUSH
76672: CALL_OW 1
76676: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
76677: LD_EXP 90
76681: PUSH
76682: LD_VAR 0 2
76686: ARRAY
76687: PUSH
76688: LD_EXP 91
76692: PUSH
76693: LD_VAR 0 2
76697: ARRAY
76698: AND
76699: PUSH
76700: LD_EXP 91
76704: PUSH
76705: LD_VAR 0 2
76709: ARRAY
76710: PUSH
76711: LD_INT 1
76713: ARRAY
76714: PPUSH
76715: CALL_OW 310
76719: NOT
76720: AND
76721: PUSH
76722: LD_VAR 0 3
76726: PPUSH
76727: CALL_OW 313
76731: PUSH
76732: LD_INT 6
76734: EQUAL
76735: AND
76736: IFFALSE 76792
// begin tmp2 := UnitsInside ( j ) ;
76738: LD_ADDR_VAR 0 9
76742: PUSH
76743: LD_VAR 0 3
76747: PPUSH
76748: CALL_OW 313
76752: ST_TO_ADDR
// if tmp2 = 6 then
76753: LD_VAR 0 9
76757: PUSH
76758: LD_INT 6
76760: EQUAL
76761: IFFALSE 76792
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
76763: LD_VAR 0 9
76767: PUSH
76768: LD_INT 1
76770: ARRAY
76771: PPUSH
76772: LD_INT 112
76774: PPUSH
76775: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
76779: LD_VAR 0 9
76783: PUSH
76784: LD_INT 1
76786: ARRAY
76787: PPUSH
76788: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
76792: LD_EXP 91
76796: PUSH
76797: LD_VAR 0 2
76801: ARRAY
76802: PUSH
76803: LD_EXP 91
76807: PUSH
76808: LD_VAR 0 2
76812: ARRAY
76813: PUSH
76814: LD_INT 1
76816: ARRAY
76817: PPUSH
76818: CALL_OW 314
76822: NOT
76823: AND
76824: PUSH
76825: LD_EXP 91
76829: PUSH
76830: LD_VAR 0 2
76834: ARRAY
76835: PUSH
76836: LD_INT 1
76838: ARRAY
76839: PPUSH
76840: CALL_OW 310
76844: NOT
76845: AND
76846: IFFALSE 76872
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
76848: LD_EXP 91
76852: PUSH
76853: LD_VAR 0 2
76857: ARRAY
76858: PUSH
76859: LD_INT 1
76861: ARRAY
76862: PPUSH
76863: LD_VAR 0 3
76867: PPUSH
76868: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
76872: LD_EXP 91
76876: PUSH
76877: LD_VAR 0 2
76881: ARRAY
76882: PUSH
76883: LD_INT 1
76885: ARRAY
76886: PPUSH
76887: CALL_OW 310
76891: PUSH
76892: LD_EXP 91
76896: PUSH
76897: LD_VAR 0 2
76901: ARRAY
76902: PUSH
76903: LD_INT 1
76905: ARRAY
76906: PPUSH
76907: CALL_OW 310
76911: PPUSH
76912: CALL_OW 461
76916: PUSH
76917: LD_INT 3
76919: NONEQUAL
76920: AND
76921: IFFALSE 76942
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
76923: LD_EXP 91
76927: PUSH
76928: LD_VAR 0 2
76932: ARRAY
76933: PUSH
76934: LD_INT 1
76936: ARRAY
76937: PPUSH
76938: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
76942: LD_VAR 0 3
76946: PPUSH
76947: CALL_OW 461
76951: PUSH
76952: LD_INT 6
76954: EQUAL
76955: PUSH
76956: LD_VAR 0 6
76960: PUSH
76961: LD_INT 1
76963: GREATER
76964: AND
76965: IFFALSE 77117
// begin sci := [ ] ;
76967: LD_ADDR_VAR 0 8
76971: PUSH
76972: EMPTY
76973: ST_TO_ADDR
// for x in ( tmp diff j ) do
76974: LD_ADDR_VAR 0 7
76978: PUSH
76979: LD_VAR 0 6
76983: PUSH
76984: LD_VAR 0 3
76988: DIFF
76989: PUSH
76990: FOR_IN
76991: IFFALSE 77043
// begin if sci = 6 then
76993: LD_VAR 0 8
76997: PUSH
76998: LD_INT 6
77000: EQUAL
77001: IFFALSE 77005
// break ;
77003: GO 77043
// if BuildingStatus ( x ) = bs_idle then
77005: LD_VAR 0 7
77009: PPUSH
77010: CALL_OW 461
77014: PUSH
77015: LD_INT 2
77017: EQUAL
77018: IFFALSE 77041
// sci := sci ^ UnitsInside ( x ) ;
77020: LD_ADDR_VAR 0 8
77024: PUSH
77025: LD_VAR 0 8
77029: PUSH
77030: LD_VAR 0 7
77034: PPUSH
77035: CALL_OW 313
77039: ADD
77040: ST_TO_ADDR
// end ;
77041: GO 76990
77043: POP
77044: POP
// if not sci then
77045: LD_VAR 0 8
77049: NOT
77050: IFFALSE 77054
// continue ;
77052: GO 76099
// for x in sci do
77054: LD_ADDR_VAR 0 7
77058: PUSH
77059: LD_VAR 0 8
77063: PUSH
77064: FOR_IN
77065: IFFALSE 77115
// if IsInUnit ( x ) and not HasTask ( x ) then
77067: LD_VAR 0 7
77071: PPUSH
77072: CALL_OW 310
77076: PUSH
77077: LD_VAR 0 7
77081: PPUSH
77082: CALL_OW 314
77086: NOT
77087: AND
77088: IFFALSE 77113
// begin ComExitBuilding ( x ) ;
77090: LD_VAR 0 7
77094: PPUSH
77095: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77099: LD_VAR 0 7
77103: PPUSH
77104: LD_VAR 0 3
77108: PPUSH
77109: CALL_OW 180
// end ;
77113: GO 77064
77115: POP
77116: POP
// end ; end ;
77117: GO 76099
77119: POP
77120: POP
// end ;
77121: GO 76053
77123: POP
77124: POP
// end ;
77125: LD_VAR 0 1
77129: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
77130: LD_INT 0
77132: PPUSH
77133: PPUSH
// if not mc_bases then
77134: LD_EXP 61
77138: NOT
77139: IFFALSE 77143
// exit ;
77141: GO 77224
// for i = 1 to mc_bases do
77143: LD_ADDR_VAR 0 2
77147: PUSH
77148: DOUBLE
77149: LD_INT 1
77151: DEC
77152: ST_TO_ADDR
77153: LD_EXP 61
77157: PUSH
77158: FOR_TO
77159: IFFALSE 77222
// if mc_mines [ i ] and mc_miners [ i ] then
77161: LD_EXP 74
77165: PUSH
77166: LD_VAR 0 2
77170: ARRAY
77171: PUSH
77172: LD_EXP 75
77176: PUSH
77177: LD_VAR 0 2
77181: ARRAY
77182: AND
77183: IFFALSE 77220
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
77185: LD_EXP 75
77189: PUSH
77190: LD_VAR 0 2
77194: ARRAY
77195: PUSH
77196: LD_INT 1
77198: ARRAY
77199: PPUSH
77200: CALL_OW 255
77204: PPUSH
77205: LD_EXP 74
77209: PUSH
77210: LD_VAR 0 2
77214: ARRAY
77215: PPUSH
77216: CALL 18384 0 2
77220: GO 77158
77222: POP
77223: POP
// end ;
77224: LD_VAR 0 1
77228: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
77229: LD_INT 0
77231: PPUSH
77232: PPUSH
77233: PPUSH
77234: PPUSH
77235: PPUSH
77236: PPUSH
77237: PPUSH
77238: PPUSH
// if not mc_bases or not mc_parking then
77239: LD_EXP 61
77243: NOT
77244: PUSH
77245: LD_EXP 85
77249: NOT
77250: OR
77251: IFFALSE 77255
// exit ;
77253: GO 77993
// for i = 1 to mc_bases do
77255: LD_ADDR_VAR 0 2
77259: PUSH
77260: DOUBLE
77261: LD_INT 1
77263: DEC
77264: ST_TO_ADDR
77265: LD_EXP 61
77269: PUSH
77270: FOR_TO
77271: IFFALSE 77991
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
77273: LD_EXP 61
77277: PUSH
77278: LD_VAR 0 2
77282: ARRAY
77283: NOT
77284: PUSH
77285: LD_EXP 85
77289: PUSH
77290: LD_VAR 0 2
77294: ARRAY
77295: NOT
77296: OR
77297: IFFALSE 77301
// continue ;
77299: GO 77270
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
77301: LD_ADDR_VAR 0 5
77305: PUSH
77306: LD_EXP 61
77310: PUSH
77311: LD_VAR 0 2
77315: ARRAY
77316: PUSH
77317: LD_INT 1
77319: ARRAY
77320: PPUSH
77321: CALL_OW 255
77325: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77326: LD_ADDR_VAR 0 6
77330: PUSH
77331: LD_EXP 61
77335: PUSH
77336: LD_VAR 0 2
77340: ARRAY
77341: PPUSH
77342: LD_INT 30
77344: PUSH
77345: LD_INT 3
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PPUSH
77352: CALL_OW 72
77356: ST_TO_ADDR
// if not fac then
77357: LD_VAR 0 6
77361: NOT
77362: IFFALSE 77413
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77364: LD_ADDR_VAR 0 6
77368: PUSH
77369: LD_EXP 61
77373: PUSH
77374: LD_VAR 0 2
77378: ARRAY
77379: PPUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 30
77385: PUSH
77386: LD_INT 0
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 30
77395: PUSH
77396: LD_INT 1
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: LIST
77407: PPUSH
77408: CALL_OW 72
77412: ST_TO_ADDR
// if not fac then
77413: LD_VAR 0 6
77417: NOT
77418: IFFALSE 77422
// continue ;
77420: GO 77270
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77422: LD_ADDR_VAR 0 7
77426: PUSH
77427: LD_EXP 85
77431: PUSH
77432: LD_VAR 0 2
77436: ARRAY
77437: PPUSH
77438: LD_INT 22
77440: PUSH
77441: LD_VAR 0 5
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 21
77452: PUSH
77453: LD_INT 2
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 3
77462: PUSH
77463: LD_INT 60
77465: PUSH
77466: EMPTY
77467: LIST
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 3
77475: PUSH
77476: LD_INT 24
77478: PUSH
77479: LD_INT 1000
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: PPUSH
77496: CALL_OW 70
77500: ST_TO_ADDR
// for j in fac do
77501: LD_ADDR_VAR 0 3
77505: PUSH
77506: LD_VAR 0 6
77510: PUSH
77511: FOR_IN
77512: IFFALSE 77607
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
77514: LD_ADDR_VAR 0 7
77518: PUSH
77519: LD_VAR 0 7
77523: PUSH
77524: LD_INT 22
77526: PUSH
77527: LD_VAR 0 5
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 91
77538: PUSH
77539: LD_VAR 0 3
77543: PUSH
77544: LD_INT 15
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 21
77554: PUSH
77555: LD_INT 2
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 3
77564: PUSH
77565: LD_INT 60
77567: PUSH
77568: EMPTY
77569: LIST
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: PUSH
77578: LD_INT 24
77580: PUSH
77581: LD_INT 1000
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: PPUSH
77599: CALL_OW 69
77603: UNION
77604: ST_TO_ADDR
77605: GO 77511
77607: POP
77608: POP
// if not vehs then
77609: LD_VAR 0 7
77613: NOT
77614: IFFALSE 77640
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
77616: LD_ADDR_EXP 73
77620: PUSH
77621: LD_EXP 73
77625: PPUSH
77626: LD_VAR 0 2
77630: PPUSH
77631: EMPTY
77632: PPUSH
77633: CALL_OW 1
77637: ST_TO_ADDR
// continue ;
77638: GO 77270
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77640: LD_ADDR_VAR 0 8
77644: PUSH
77645: LD_EXP 61
77649: PUSH
77650: LD_VAR 0 2
77654: ARRAY
77655: PPUSH
77656: LD_INT 30
77658: PUSH
77659: LD_INT 3
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PPUSH
77666: CALL_OW 72
77670: ST_TO_ADDR
// if tmp then
77671: LD_VAR 0 8
77675: IFFALSE 77778
// begin for j in tmp do
77677: LD_ADDR_VAR 0 3
77681: PUSH
77682: LD_VAR 0 8
77686: PUSH
77687: FOR_IN
77688: IFFALSE 77776
// for k in UnitsInside ( j ) do
77690: LD_ADDR_VAR 0 4
77694: PUSH
77695: LD_VAR 0 3
77699: PPUSH
77700: CALL_OW 313
77704: PUSH
77705: FOR_IN
77706: IFFALSE 77772
// if k then
77708: LD_VAR 0 4
77712: IFFALSE 77770
// if not k in mc_repair_vehicle [ i ] then
77714: LD_VAR 0 4
77718: PUSH
77719: LD_EXP 73
77723: PUSH
77724: LD_VAR 0 2
77728: ARRAY
77729: IN
77730: NOT
77731: IFFALSE 77770
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
77733: LD_ADDR_EXP 73
77737: PUSH
77738: LD_EXP 73
77742: PPUSH
77743: LD_VAR 0 2
77747: PPUSH
77748: LD_EXP 73
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PUSH
77759: LD_VAR 0 4
77763: UNION
77764: PPUSH
77765: CALL_OW 1
77769: ST_TO_ADDR
77770: GO 77705
77772: POP
77773: POP
77774: GO 77687
77776: POP
77777: POP
// end ; if not mc_repair_vehicle [ i ] then
77778: LD_EXP 73
77782: PUSH
77783: LD_VAR 0 2
77787: ARRAY
77788: NOT
77789: IFFALSE 77793
// continue ;
77791: GO 77270
// for j in mc_repair_vehicle [ i ] do
77793: LD_ADDR_VAR 0 3
77797: PUSH
77798: LD_EXP 73
77802: PUSH
77803: LD_VAR 0 2
77807: ARRAY
77808: PUSH
77809: FOR_IN
77810: IFFALSE 77987
// begin if GetClass ( j ) <> 3 then
77812: LD_VAR 0 3
77816: PPUSH
77817: CALL_OW 257
77821: PUSH
77822: LD_INT 3
77824: NONEQUAL
77825: IFFALSE 77866
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
77827: LD_ADDR_EXP 73
77831: PUSH
77832: LD_EXP 73
77836: PPUSH
77837: LD_VAR 0 2
77841: PPUSH
77842: LD_EXP 73
77846: PUSH
77847: LD_VAR 0 2
77851: ARRAY
77852: PUSH
77853: LD_VAR 0 3
77857: DIFF
77858: PPUSH
77859: CALL_OW 1
77863: ST_TO_ADDR
// continue ;
77864: GO 77809
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77866: LD_VAR 0 3
77870: PPUSH
77871: CALL_OW 311
77875: NOT
77876: PUSH
77877: LD_VAR 0 3
77881: PUSH
77882: LD_EXP 64
77886: PUSH
77887: LD_VAR 0 2
77891: ARRAY
77892: PUSH
77893: LD_INT 1
77895: ARRAY
77896: IN
77897: NOT
77898: AND
77899: PUSH
77900: LD_VAR 0 3
77904: PUSH
77905: LD_EXP 64
77909: PUSH
77910: LD_VAR 0 2
77914: ARRAY
77915: PUSH
77916: LD_INT 2
77918: ARRAY
77919: IN
77920: NOT
77921: AND
77922: IFFALSE 77985
// begin if IsInUnit ( j ) then
77924: LD_VAR 0 3
77928: PPUSH
77929: CALL_OW 310
77933: IFFALSE 77946
// ComExitBuilding ( j ) else
77935: LD_VAR 0 3
77939: PPUSH
77940: CALL_OW 122
77944: GO 77985
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
77946: LD_VAR 0 3
77950: PPUSH
77951: LD_VAR 0 7
77955: PUSH
77956: LD_INT 1
77958: ARRAY
77959: PPUSH
77960: CALL 56201 0 2
77964: NOT
77965: IFFALSE 77985
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
77967: LD_VAR 0 3
77971: PPUSH
77972: LD_VAR 0 7
77976: PUSH
77977: LD_INT 1
77979: ARRAY
77980: PPUSH
77981: CALL_OW 129
// end ; end ;
77985: GO 77809
77987: POP
77988: POP
// end ;
77989: GO 77270
77991: POP
77992: POP
// end ;
77993: LD_VAR 0 1
77997: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
77998: LD_INT 0
78000: PPUSH
78001: PPUSH
78002: PPUSH
78003: PPUSH
78004: PPUSH
78005: PPUSH
78006: PPUSH
78007: PPUSH
78008: PPUSH
78009: PPUSH
78010: PPUSH
// if not mc_bases then
78011: LD_EXP 61
78015: NOT
78016: IFFALSE 78020
// exit ;
78018: GO 78822
// for i = 1 to mc_bases do
78020: LD_ADDR_VAR 0 2
78024: PUSH
78025: DOUBLE
78026: LD_INT 1
78028: DEC
78029: ST_TO_ADDR
78030: LD_EXP 61
78034: PUSH
78035: FOR_TO
78036: IFFALSE 78820
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78038: LD_EXP 89
78042: PUSH
78043: LD_VAR 0 2
78047: ARRAY
78048: NOT
78049: PUSH
78050: LD_EXP 64
78054: PUSH
78055: LD_VAR 0 2
78059: ARRAY
78060: PUSH
78061: LD_INT 1
78063: ARRAY
78064: OR
78065: PUSH
78066: LD_EXP 64
78070: PUSH
78071: LD_VAR 0 2
78075: ARRAY
78076: PUSH
78077: LD_INT 2
78079: ARRAY
78080: OR
78081: PUSH
78082: LD_EXP 87
78086: PUSH
78087: LD_VAR 0 2
78091: ARRAY
78092: PPUSH
78093: LD_INT 1
78095: PPUSH
78096: CALL_OW 325
78100: NOT
78101: OR
78102: PUSH
78103: LD_EXP 84
78107: PUSH
78108: LD_VAR 0 2
78112: ARRAY
78113: OR
78114: IFFALSE 78118
// continue ;
78116: GO 78035
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78118: LD_ADDR_VAR 0 8
78122: PUSH
78123: LD_EXP 61
78127: PUSH
78128: LD_VAR 0 2
78132: ARRAY
78133: PPUSH
78134: LD_INT 25
78136: PUSH
78137: LD_INT 4
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 50
78146: PUSH
78147: EMPTY
78148: LIST
78149: PUSH
78150: LD_INT 3
78152: PUSH
78153: LD_INT 60
78155: PUSH
78156: EMPTY
78157: LIST
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: LIST
78167: PPUSH
78168: CALL_OW 72
78172: PUSH
78173: LD_EXP 65
78177: PUSH
78178: LD_VAR 0 2
78182: ARRAY
78183: DIFF
78184: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78185: LD_ADDR_VAR 0 9
78189: PUSH
78190: LD_EXP 61
78194: PUSH
78195: LD_VAR 0 2
78199: ARRAY
78200: PPUSH
78201: LD_INT 2
78203: PUSH
78204: LD_INT 30
78206: PUSH
78207: LD_INT 0
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 30
78216: PUSH
78217: LD_INT 1
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: LIST
78228: PPUSH
78229: CALL_OW 72
78233: ST_TO_ADDR
// if not tmp or not dep then
78234: LD_VAR 0 8
78238: NOT
78239: PUSH
78240: LD_VAR 0 9
78244: NOT
78245: OR
78246: IFFALSE 78250
// continue ;
78248: GO 78035
// side := GetSide ( tmp [ 1 ] ) ;
78250: LD_ADDR_VAR 0 11
78254: PUSH
78255: LD_VAR 0 8
78259: PUSH
78260: LD_INT 1
78262: ARRAY
78263: PPUSH
78264: CALL_OW 255
78268: ST_TO_ADDR
// dep := dep [ 1 ] ;
78269: LD_ADDR_VAR 0 9
78273: PUSH
78274: LD_VAR 0 9
78278: PUSH
78279: LD_INT 1
78281: ARRAY
78282: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
78283: LD_ADDR_VAR 0 7
78287: PUSH
78288: LD_EXP 89
78292: PUSH
78293: LD_VAR 0 2
78297: ARRAY
78298: PPUSH
78299: LD_INT 22
78301: PUSH
78302: LD_INT 0
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 25
78311: PUSH
78312: LD_INT 12
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PPUSH
78323: CALL_OW 70
78327: PUSH
78328: LD_INT 22
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 25
78340: PUSH
78341: LD_INT 12
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 91
78350: PUSH
78351: LD_VAR 0 9
78355: PUSH
78356: LD_INT 20
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: PPUSH
78369: CALL_OW 69
78373: UNION
78374: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
78375: LD_ADDR_VAR 0 10
78379: PUSH
78380: LD_EXP 89
78384: PUSH
78385: LD_VAR 0 2
78389: ARRAY
78390: PPUSH
78391: LD_INT 81
78393: PUSH
78394: LD_VAR 0 11
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PPUSH
78403: CALL_OW 70
78407: ST_TO_ADDR
// if not apes or danger_at_area then
78408: LD_VAR 0 7
78412: NOT
78413: PUSH
78414: LD_VAR 0 10
78418: OR
78419: IFFALSE 78469
// begin if mc_taming [ i ] then
78421: LD_EXP 92
78425: PUSH
78426: LD_VAR 0 2
78430: ARRAY
78431: IFFALSE 78467
// begin MC_Reset ( i , 121 ) ;
78433: LD_VAR 0 2
78437: PPUSH
78438: LD_INT 121
78440: PPUSH
78441: CALL 63385 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
78445: LD_ADDR_EXP 92
78449: PUSH
78450: LD_EXP 92
78454: PPUSH
78455: LD_VAR 0 2
78459: PPUSH
78460: EMPTY
78461: PPUSH
78462: CALL_OW 1
78466: ST_TO_ADDR
// end ; continue ;
78467: GO 78035
// end ; for j in tmp do
78469: LD_ADDR_VAR 0 3
78473: PUSH
78474: LD_VAR 0 8
78478: PUSH
78479: FOR_IN
78480: IFFALSE 78816
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
78482: LD_VAR 0 3
78486: PUSH
78487: LD_EXP 92
78491: PUSH
78492: LD_VAR 0 2
78496: ARRAY
78497: IN
78498: NOT
78499: PUSH
78500: LD_EXP 92
78504: PUSH
78505: LD_VAR 0 2
78509: ARRAY
78510: PUSH
78511: LD_INT 3
78513: LESS
78514: AND
78515: IFFALSE 78573
// begin SetTag ( j , 121 ) ;
78517: LD_VAR 0 3
78521: PPUSH
78522: LD_INT 121
78524: PPUSH
78525: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
78529: LD_ADDR_EXP 92
78533: PUSH
78534: LD_EXP 92
78538: PPUSH
78539: LD_VAR 0 2
78543: PUSH
78544: LD_EXP 92
78548: PUSH
78549: LD_VAR 0 2
78553: ARRAY
78554: PUSH
78555: LD_INT 1
78557: PLUS
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PPUSH
78563: LD_VAR 0 3
78567: PPUSH
78568: CALL 21407 0 3
78572: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
78573: LD_VAR 0 3
78577: PUSH
78578: LD_EXP 92
78582: PUSH
78583: LD_VAR 0 2
78587: ARRAY
78588: IN
78589: IFFALSE 78814
// begin if GetClass ( j ) <> 4 then
78591: LD_VAR 0 3
78595: PPUSH
78596: CALL_OW 257
78600: PUSH
78601: LD_INT 4
78603: NONEQUAL
78604: IFFALSE 78657
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
78606: LD_ADDR_EXP 92
78610: PUSH
78611: LD_EXP 92
78615: PPUSH
78616: LD_VAR 0 2
78620: PPUSH
78621: LD_EXP 92
78625: PUSH
78626: LD_VAR 0 2
78630: ARRAY
78631: PUSH
78632: LD_VAR 0 3
78636: DIFF
78637: PPUSH
78638: CALL_OW 1
78642: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78643: LD_VAR 0 3
78647: PPUSH
78648: LD_INT 0
78650: PPUSH
78651: CALL_OW 109
// continue ;
78655: GO 78479
// end ; if IsInUnit ( j ) then
78657: LD_VAR 0 3
78661: PPUSH
78662: CALL_OW 310
78666: IFFALSE 78677
// ComExitBuilding ( j ) ;
78668: LD_VAR 0 3
78672: PPUSH
78673: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
78677: LD_ADDR_VAR 0 6
78681: PUSH
78682: LD_VAR 0 7
78686: PPUSH
78687: LD_VAR 0 3
78691: PPUSH
78692: CALL_OW 74
78696: ST_TO_ADDR
// if not ape then
78697: LD_VAR 0 6
78701: NOT
78702: IFFALSE 78706
// break ;
78704: GO 78816
// x := GetX ( ape ) ;
78706: LD_ADDR_VAR 0 4
78710: PUSH
78711: LD_VAR 0 6
78715: PPUSH
78716: CALL_OW 250
78720: ST_TO_ADDR
// y := GetY ( ape ) ;
78721: LD_ADDR_VAR 0 5
78725: PUSH
78726: LD_VAR 0 6
78730: PPUSH
78731: CALL_OW 251
78735: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78736: LD_VAR 0 4
78740: PPUSH
78741: LD_VAR 0 5
78745: PPUSH
78746: CALL_OW 488
78750: NOT
78751: PUSH
78752: LD_VAR 0 11
78756: PPUSH
78757: LD_VAR 0 4
78761: PPUSH
78762: LD_VAR 0 5
78766: PPUSH
78767: LD_INT 20
78769: PPUSH
78770: CALL 22671 0 4
78774: PUSH
78775: LD_INT 4
78777: ARRAY
78778: OR
78779: IFFALSE 78783
// break ;
78781: GO 78816
// if not HasTask ( j ) then
78783: LD_VAR 0 3
78787: PPUSH
78788: CALL_OW 314
78792: NOT
78793: IFFALSE 78814
// ComTameXY ( j , x , y ) ;
78795: LD_VAR 0 3
78799: PPUSH
78800: LD_VAR 0 4
78804: PPUSH
78805: LD_VAR 0 5
78809: PPUSH
78810: CALL_OW 131
// end ; end ;
78814: GO 78479
78816: POP
78817: POP
// end ;
78818: GO 78035
78820: POP
78821: POP
// end ;
78822: LD_VAR 0 1
78826: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
78827: LD_INT 0
78829: PPUSH
78830: PPUSH
78831: PPUSH
78832: PPUSH
78833: PPUSH
78834: PPUSH
78835: PPUSH
78836: PPUSH
// if not mc_bases then
78837: LD_EXP 61
78841: NOT
78842: IFFALSE 78846
// exit ;
78844: GO 79472
// for i = 1 to mc_bases do
78846: LD_ADDR_VAR 0 2
78850: PUSH
78851: DOUBLE
78852: LD_INT 1
78854: DEC
78855: ST_TO_ADDR
78856: LD_EXP 61
78860: PUSH
78861: FOR_TO
78862: IFFALSE 79470
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
78864: LD_EXP 90
78868: PUSH
78869: LD_VAR 0 2
78873: ARRAY
78874: NOT
78875: PUSH
78876: LD_EXP 90
78880: PUSH
78881: LD_VAR 0 2
78885: ARRAY
78886: PPUSH
78887: LD_INT 25
78889: PUSH
78890: LD_INT 12
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PPUSH
78897: CALL_OW 72
78901: NOT
78902: OR
78903: IFFALSE 78907
// continue ;
78905: GO 78861
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
78907: LD_ADDR_VAR 0 5
78911: PUSH
78912: LD_EXP 90
78916: PUSH
78917: LD_VAR 0 2
78921: ARRAY
78922: PUSH
78923: LD_INT 1
78925: ARRAY
78926: PPUSH
78927: CALL_OW 255
78931: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
78932: LD_VAR 0 5
78936: PPUSH
78937: LD_INT 2
78939: PPUSH
78940: CALL_OW 325
78944: IFFALSE 79197
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78946: LD_ADDR_VAR 0 4
78950: PUSH
78951: LD_EXP 90
78955: PUSH
78956: LD_VAR 0 2
78960: ARRAY
78961: PPUSH
78962: LD_INT 25
78964: PUSH
78965: LD_INT 16
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PPUSH
78972: CALL_OW 72
78976: ST_TO_ADDR
// if tmp < 6 then
78977: LD_VAR 0 4
78981: PUSH
78982: LD_INT 6
78984: LESS
78985: IFFALSE 79197
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78987: LD_ADDR_VAR 0 6
78991: PUSH
78992: LD_EXP 61
78996: PUSH
78997: LD_VAR 0 2
79001: ARRAY
79002: PPUSH
79003: LD_INT 2
79005: PUSH
79006: LD_INT 30
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 30
79018: PUSH
79019: LD_INT 1
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: LIST
79030: PPUSH
79031: CALL_OW 72
79035: ST_TO_ADDR
// if depot then
79036: LD_VAR 0 6
79040: IFFALSE 79197
// begin selected := 0 ;
79042: LD_ADDR_VAR 0 7
79046: PUSH
79047: LD_INT 0
79049: ST_TO_ADDR
// for j in depot do
79050: LD_ADDR_VAR 0 3
79054: PUSH
79055: LD_VAR 0 6
79059: PUSH
79060: FOR_IN
79061: IFFALSE 79092
// begin if UnitsInside ( j ) < 6 then
79063: LD_VAR 0 3
79067: PPUSH
79068: CALL_OW 313
79072: PUSH
79073: LD_INT 6
79075: LESS
79076: IFFALSE 79090
// begin selected := j ;
79078: LD_ADDR_VAR 0 7
79082: PUSH
79083: LD_VAR 0 3
79087: ST_TO_ADDR
// break ;
79088: GO 79092
// end ; end ;
79090: GO 79060
79092: POP
79093: POP
// if selected then
79094: LD_VAR 0 7
79098: IFFALSE 79197
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79100: LD_ADDR_VAR 0 3
79104: PUSH
79105: LD_EXP 90
79109: PUSH
79110: LD_VAR 0 2
79114: ARRAY
79115: PPUSH
79116: LD_INT 25
79118: PUSH
79119: LD_INT 12
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PPUSH
79126: CALL_OW 72
79130: PUSH
79131: FOR_IN
79132: IFFALSE 79195
// if not HasTask ( j ) then
79134: LD_VAR 0 3
79138: PPUSH
79139: CALL_OW 314
79143: NOT
79144: IFFALSE 79193
// begin if not IsInUnit ( j ) then
79146: LD_VAR 0 3
79150: PPUSH
79151: CALL_OW 310
79155: NOT
79156: IFFALSE 79172
// ComEnterUnit ( j , selected ) ;
79158: LD_VAR 0 3
79162: PPUSH
79163: LD_VAR 0 7
79167: PPUSH
79168: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
79172: LD_VAR 0 3
79176: PPUSH
79177: LD_INT 16
79179: PPUSH
79180: CALL_OW 183
// AddComExitBuilding ( j ) ;
79184: LD_VAR 0 3
79188: PPUSH
79189: CALL_OW 182
// end ;
79193: GO 79131
79195: POP
79196: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
79197: LD_VAR 0 5
79201: PPUSH
79202: LD_INT 11
79204: PPUSH
79205: CALL_OW 325
79209: IFFALSE 79468
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79211: LD_ADDR_VAR 0 4
79215: PUSH
79216: LD_EXP 90
79220: PUSH
79221: LD_VAR 0 2
79225: ARRAY
79226: PPUSH
79227: LD_INT 25
79229: PUSH
79230: LD_INT 16
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PPUSH
79237: CALL_OW 72
79241: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
79242: LD_VAR 0 4
79246: PUSH
79247: LD_INT 6
79249: GREATEREQUAL
79250: PUSH
79251: LD_VAR 0 5
79255: PPUSH
79256: LD_INT 2
79258: PPUSH
79259: CALL_OW 325
79263: NOT
79264: OR
79265: IFFALSE 79468
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79267: LD_ADDR_VAR 0 8
79271: PUSH
79272: LD_EXP 61
79276: PUSH
79277: LD_VAR 0 2
79281: ARRAY
79282: PPUSH
79283: LD_INT 2
79285: PUSH
79286: LD_INT 30
79288: PUSH
79289: LD_INT 4
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 30
79298: PUSH
79299: LD_INT 5
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: LIST
79310: PPUSH
79311: CALL_OW 72
79315: ST_TO_ADDR
// if barracks then
79316: LD_VAR 0 8
79320: IFFALSE 79468
// begin selected := 0 ;
79322: LD_ADDR_VAR 0 7
79326: PUSH
79327: LD_INT 0
79329: ST_TO_ADDR
// for j in barracks do
79330: LD_ADDR_VAR 0 3
79334: PUSH
79335: LD_VAR 0 8
79339: PUSH
79340: FOR_IN
79341: IFFALSE 79372
// begin if UnitsInside ( j ) < 6 then
79343: LD_VAR 0 3
79347: PPUSH
79348: CALL_OW 313
79352: PUSH
79353: LD_INT 6
79355: LESS
79356: IFFALSE 79370
// begin selected := j ;
79358: LD_ADDR_VAR 0 7
79362: PUSH
79363: LD_VAR 0 3
79367: ST_TO_ADDR
// break ;
79368: GO 79372
// end ; end ;
79370: GO 79340
79372: POP
79373: POP
// if selected then
79374: LD_VAR 0 7
79378: IFFALSE 79468
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79380: LD_ADDR_VAR 0 3
79384: PUSH
79385: LD_EXP 90
79389: PUSH
79390: LD_VAR 0 2
79394: ARRAY
79395: PPUSH
79396: LD_INT 25
79398: PUSH
79399: LD_INT 12
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PPUSH
79406: CALL_OW 72
79410: PUSH
79411: FOR_IN
79412: IFFALSE 79466
// if not IsInUnit ( j ) and not HasTask ( j ) then
79414: LD_VAR 0 3
79418: PPUSH
79419: CALL_OW 310
79423: NOT
79424: PUSH
79425: LD_VAR 0 3
79429: PPUSH
79430: CALL_OW 314
79434: NOT
79435: AND
79436: IFFALSE 79464
// begin ComEnterUnit ( j , selected ) ;
79438: LD_VAR 0 3
79442: PPUSH
79443: LD_VAR 0 7
79447: PPUSH
79448: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
79452: LD_VAR 0 3
79456: PPUSH
79457: LD_INT 15
79459: PPUSH
79460: CALL_OW 183
// end ;
79464: GO 79411
79466: POP
79467: POP
// end ; end ; end ; end ; end ;
79468: GO 78861
79470: POP
79471: POP
// end ;
79472: LD_VAR 0 1
79476: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
79477: LD_INT 0
79479: PPUSH
79480: PPUSH
79481: PPUSH
79482: PPUSH
// if not mc_bases then
79483: LD_EXP 61
79487: NOT
79488: IFFALSE 79492
// exit ;
79490: GO 79670
// for i = 1 to mc_bases do
79492: LD_ADDR_VAR 0 2
79496: PUSH
79497: DOUBLE
79498: LD_INT 1
79500: DEC
79501: ST_TO_ADDR
79502: LD_EXP 61
79506: PUSH
79507: FOR_TO
79508: IFFALSE 79668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
79510: LD_ADDR_VAR 0 4
79514: PUSH
79515: LD_EXP 61
79519: PUSH
79520: LD_VAR 0 2
79524: ARRAY
79525: PPUSH
79526: LD_INT 25
79528: PUSH
79529: LD_INT 9
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PPUSH
79536: CALL_OW 72
79540: ST_TO_ADDR
// if not tmp then
79541: LD_VAR 0 4
79545: NOT
79546: IFFALSE 79550
// continue ;
79548: GO 79507
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
79550: LD_EXP 87
79554: PUSH
79555: LD_VAR 0 2
79559: ARRAY
79560: PPUSH
79561: LD_INT 29
79563: PPUSH
79564: CALL_OW 325
79568: NOT
79569: PUSH
79570: LD_EXP 87
79574: PUSH
79575: LD_VAR 0 2
79579: ARRAY
79580: PPUSH
79581: LD_INT 28
79583: PPUSH
79584: CALL_OW 325
79588: NOT
79589: AND
79590: IFFALSE 79594
// continue ;
79592: GO 79507
// for j in tmp do
79594: LD_ADDR_VAR 0 3
79598: PUSH
79599: LD_VAR 0 4
79603: PUSH
79604: FOR_IN
79605: IFFALSE 79664
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79607: LD_VAR 0 3
79611: PUSH
79612: LD_EXP 64
79616: PUSH
79617: LD_VAR 0 2
79621: ARRAY
79622: PUSH
79623: LD_INT 1
79625: ARRAY
79626: IN
79627: NOT
79628: PUSH
79629: LD_VAR 0 3
79633: PUSH
79634: LD_EXP 64
79638: PUSH
79639: LD_VAR 0 2
79643: ARRAY
79644: PUSH
79645: LD_INT 2
79647: ARRAY
79648: IN
79649: NOT
79650: AND
79651: IFFALSE 79662
// ComSpaceTimeShoot ( j ) ;
79653: LD_VAR 0 3
79657: PPUSH
79658: CALL 17392 0 1
79662: GO 79604
79664: POP
79665: POP
// end ;
79666: GO 79507
79668: POP
79669: POP
// end ;
79670: LD_VAR 0 1
79674: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
79675: LD_INT 0
79677: PPUSH
79678: PPUSH
79679: PPUSH
79680: PPUSH
79681: PPUSH
79682: PPUSH
79683: PPUSH
79684: PPUSH
79685: PPUSH
// if not mc_bases then
79686: LD_EXP 61
79690: NOT
79691: IFFALSE 79695
// exit ;
79693: GO 80317
// for i = 1 to mc_bases do
79695: LD_ADDR_VAR 0 2
79699: PUSH
79700: DOUBLE
79701: LD_INT 1
79703: DEC
79704: ST_TO_ADDR
79705: LD_EXP 61
79709: PUSH
79710: FOR_TO
79711: IFFALSE 80315
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
79713: LD_EXP 96
79717: PUSH
79718: LD_VAR 0 2
79722: ARRAY
79723: NOT
79724: PUSH
79725: LD_INT 38
79727: PPUSH
79728: LD_EXP 87
79732: PUSH
79733: LD_VAR 0 2
79737: ARRAY
79738: PPUSH
79739: CALL_OW 321
79743: PUSH
79744: LD_INT 2
79746: NONEQUAL
79747: OR
79748: IFFALSE 79752
// continue ;
79750: GO 79710
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
79752: LD_ADDR_VAR 0 8
79756: PUSH
79757: LD_EXP 61
79761: PUSH
79762: LD_VAR 0 2
79766: ARRAY
79767: PPUSH
79768: LD_INT 30
79770: PUSH
79771: LD_INT 34
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PPUSH
79778: CALL_OW 72
79782: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
79783: LD_ADDR_VAR 0 9
79787: PUSH
79788: LD_EXP 61
79792: PUSH
79793: LD_VAR 0 2
79797: ARRAY
79798: PPUSH
79799: LD_INT 25
79801: PUSH
79802: LD_INT 4
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PPUSH
79809: CALL_OW 72
79813: PPUSH
79814: LD_INT 0
79816: PPUSH
79817: CALL 51705 0 2
79821: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
79822: LD_VAR 0 9
79826: NOT
79827: PUSH
79828: LD_VAR 0 8
79832: NOT
79833: OR
79834: PUSH
79835: LD_EXP 61
79839: PUSH
79840: LD_VAR 0 2
79844: ARRAY
79845: PPUSH
79846: LD_INT 124
79848: PPUSH
79849: CALL 51705 0 2
79853: OR
79854: IFFALSE 79858
// continue ;
79856: GO 79710
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
79858: LD_EXP 97
79862: PUSH
79863: LD_VAR 0 2
79867: ARRAY
79868: PUSH
79869: LD_EXP 96
79873: PUSH
79874: LD_VAR 0 2
79878: ARRAY
79879: LESS
79880: PUSH
79881: LD_EXP 97
79885: PUSH
79886: LD_VAR 0 2
79890: ARRAY
79891: PUSH
79892: LD_VAR 0 8
79896: LESS
79897: AND
79898: IFFALSE 80313
// begin tmp := sci [ 1 ] ;
79900: LD_ADDR_VAR 0 7
79904: PUSH
79905: LD_VAR 0 9
79909: PUSH
79910: LD_INT 1
79912: ARRAY
79913: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
79914: LD_VAR 0 7
79918: PPUSH
79919: LD_INT 124
79921: PPUSH
79922: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
79926: LD_ADDR_VAR 0 3
79930: PUSH
79931: DOUBLE
79932: LD_EXP 96
79936: PUSH
79937: LD_VAR 0 2
79941: ARRAY
79942: INC
79943: ST_TO_ADDR
79944: LD_EXP 96
79948: PUSH
79949: LD_VAR 0 2
79953: ARRAY
79954: PUSH
79955: FOR_DOWNTO
79956: IFFALSE 80299
// begin if IsInUnit ( tmp ) then
79958: LD_VAR 0 7
79962: PPUSH
79963: CALL_OW 310
79967: IFFALSE 79978
// ComExitBuilding ( tmp ) ;
79969: LD_VAR 0 7
79973: PPUSH
79974: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
79978: LD_INT 35
79980: PPUSH
79981: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
79985: LD_VAR 0 7
79989: PPUSH
79990: CALL_OW 310
79994: NOT
79995: PUSH
79996: LD_VAR 0 7
80000: PPUSH
80001: CALL_OW 314
80005: NOT
80006: AND
80007: IFFALSE 79978
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80009: LD_ADDR_VAR 0 6
80013: PUSH
80014: LD_VAR 0 7
80018: PPUSH
80019: CALL_OW 250
80023: PUSH
80024: LD_VAR 0 7
80028: PPUSH
80029: CALL_OW 251
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80038: LD_INT 35
80040: PPUSH
80041: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80045: LD_ADDR_VAR 0 4
80049: PUSH
80050: LD_EXP 96
80054: PUSH
80055: LD_VAR 0 2
80059: ARRAY
80060: PUSH
80061: LD_VAR 0 3
80065: ARRAY
80066: PUSH
80067: LD_INT 1
80069: ARRAY
80070: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80071: LD_ADDR_VAR 0 5
80075: PUSH
80076: LD_EXP 96
80080: PUSH
80081: LD_VAR 0 2
80085: ARRAY
80086: PUSH
80087: LD_VAR 0 3
80091: ARRAY
80092: PUSH
80093: LD_INT 2
80095: ARRAY
80096: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80097: LD_VAR 0 7
80101: PPUSH
80102: LD_INT 10
80104: PPUSH
80105: CALL 24372 0 2
80109: PUSH
80110: LD_INT 4
80112: ARRAY
80113: IFFALSE 80151
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80115: LD_VAR 0 7
80119: PPUSH
80120: LD_VAR 0 6
80124: PUSH
80125: LD_INT 1
80127: ARRAY
80128: PPUSH
80129: LD_VAR 0 6
80133: PUSH
80134: LD_INT 2
80136: ARRAY
80137: PPUSH
80138: CALL_OW 111
// wait ( 0 0$10 ) ;
80142: LD_INT 350
80144: PPUSH
80145: CALL_OW 67
// end else
80149: GO 80177
// begin ComMoveXY ( tmp , x , y ) ;
80151: LD_VAR 0 7
80155: PPUSH
80156: LD_VAR 0 4
80160: PPUSH
80161: LD_VAR 0 5
80165: PPUSH
80166: CALL_OW 111
// wait ( 0 0$3 ) ;
80170: LD_INT 105
80172: PPUSH
80173: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
80177: LD_VAR 0 7
80181: PPUSH
80182: LD_VAR 0 4
80186: PPUSH
80187: LD_VAR 0 5
80191: PPUSH
80192: CALL_OW 307
80196: IFFALSE 80038
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
80198: LD_VAR 0 7
80202: PPUSH
80203: LD_VAR 0 4
80207: PPUSH
80208: LD_VAR 0 5
80212: PPUSH
80213: LD_VAR 0 8
80217: PUSH
80218: LD_VAR 0 3
80222: ARRAY
80223: PPUSH
80224: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
80228: LD_INT 35
80230: PPUSH
80231: CALL_OW 67
// until not HasTask ( tmp ) ;
80235: LD_VAR 0 7
80239: PPUSH
80240: CALL_OW 314
80244: NOT
80245: IFFALSE 80228
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
80247: LD_ADDR_EXP 97
80251: PUSH
80252: LD_EXP 97
80256: PPUSH
80257: LD_VAR 0 2
80261: PUSH
80262: LD_EXP 97
80266: PUSH
80267: LD_VAR 0 2
80271: ARRAY
80272: PUSH
80273: LD_INT 1
80275: PLUS
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PPUSH
80281: LD_VAR 0 8
80285: PUSH
80286: LD_VAR 0 3
80290: ARRAY
80291: PPUSH
80292: CALL 21407 0 3
80296: ST_TO_ADDR
// end ;
80297: GO 79955
80299: POP
80300: POP
// MC_Reset ( i , 124 ) ;
80301: LD_VAR 0 2
80305: PPUSH
80306: LD_INT 124
80308: PPUSH
80309: CALL 63385 0 2
// end ; end ;
80313: GO 79710
80315: POP
80316: POP
// end ;
80317: LD_VAR 0 1
80321: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
80322: LD_INT 0
80324: PPUSH
80325: PPUSH
80326: PPUSH
// if not mc_bases then
80327: LD_EXP 61
80331: NOT
80332: IFFALSE 80336
// exit ;
80334: GO 80942
// for i = 1 to mc_bases do
80336: LD_ADDR_VAR 0 2
80340: PUSH
80341: DOUBLE
80342: LD_INT 1
80344: DEC
80345: ST_TO_ADDR
80346: LD_EXP 61
80350: PUSH
80351: FOR_TO
80352: IFFALSE 80940
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
80354: LD_ADDR_VAR 0 3
80358: PUSH
80359: LD_EXP 61
80363: PUSH
80364: LD_VAR 0 2
80368: ARRAY
80369: PPUSH
80370: LD_INT 25
80372: PUSH
80373: LD_INT 4
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PPUSH
80380: CALL_OW 72
80384: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80385: LD_VAR 0 3
80389: NOT
80390: PUSH
80391: LD_EXP 98
80395: PUSH
80396: LD_VAR 0 2
80400: ARRAY
80401: NOT
80402: OR
80403: PUSH
80404: LD_EXP 61
80408: PUSH
80409: LD_VAR 0 2
80413: ARRAY
80414: PPUSH
80415: LD_INT 2
80417: PUSH
80418: LD_INT 30
80420: PUSH
80421: LD_INT 0
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 30
80430: PUSH
80431: LD_INT 1
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: LIST
80442: PPUSH
80443: CALL_OW 72
80447: NOT
80448: OR
80449: IFFALSE 80499
// begin if mc_deposits_finder [ i ] then
80451: LD_EXP 99
80455: PUSH
80456: LD_VAR 0 2
80460: ARRAY
80461: IFFALSE 80497
// begin MC_Reset ( i , 125 ) ;
80463: LD_VAR 0 2
80467: PPUSH
80468: LD_INT 125
80470: PPUSH
80471: CALL 63385 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80475: LD_ADDR_EXP 99
80479: PUSH
80480: LD_EXP 99
80484: PPUSH
80485: LD_VAR 0 2
80489: PPUSH
80490: EMPTY
80491: PPUSH
80492: CALL_OW 1
80496: ST_TO_ADDR
// end ; continue ;
80497: GO 80351
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
80499: LD_EXP 98
80503: PUSH
80504: LD_VAR 0 2
80508: ARRAY
80509: PUSH
80510: LD_INT 1
80512: ARRAY
80513: PUSH
80514: LD_INT 3
80516: ARRAY
80517: PUSH
80518: LD_INT 1
80520: EQUAL
80521: PUSH
80522: LD_INT 20
80524: PPUSH
80525: LD_EXP 87
80529: PUSH
80530: LD_VAR 0 2
80534: ARRAY
80535: PPUSH
80536: CALL_OW 321
80540: PUSH
80541: LD_INT 2
80543: NONEQUAL
80544: AND
80545: IFFALSE 80595
// begin if mc_deposits_finder [ i ] then
80547: LD_EXP 99
80551: PUSH
80552: LD_VAR 0 2
80556: ARRAY
80557: IFFALSE 80593
// begin MC_Reset ( i , 125 ) ;
80559: LD_VAR 0 2
80563: PPUSH
80564: LD_INT 125
80566: PPUSH
80567: CALL 63385 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
80571: LD_ADDR_EXP 99
80575: PUSH
80576: LD_EXP 99
80580: PPUSH
80581: LD_VAR 0 2
80585: PPUSH
80586: EMPTY
80587: PPUSH
80588: CALL_OW 1
80592: ST_TO_ADDR
// end ; continue ;
80593: GO 80351
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
80595: LD_EXP 98
80599: PUSH
80600: LD_VAR 0 2
80604: ARRAY
80605: PUSH
80606: LD_INT 1
80608: ARRAY
80609: PUSH
80610: LD_INT 1
80612: ARRAY
80613: PPUSH
80614: LD_EXP 98
80618: PUSH
80619: LD_VAR 0 2
80623: ARRAY
80624: PUSH
80625: LD_INT 1
80627: ARRAY
80628: PUSH
80629: LD_INT 2
80631: ARRAY
80632: PPUSH
80633: LD_EXP 87
80637: PUSH
80638: LD_VAR 0 2
80642: ARRAY
80643: PPUSH
80644: CALL_OW 440
80648: IFFALSE 80691
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
80650: LD_ADDR_EXP 98
80654: PUSH
80655: LD_EXP 98
80659: PPUSH
80660: LD_VAR 0 2
80664: PPUSH
80665: LD_EXP 98
80669: PUSH
80670: LD_VAR 0 2
80674: ARRAY
80675: PPUSH
80676: LD_INT 1
80678: PPUSH
80679: CALL_OW 3
80683: PPUSH
80684: CALL_OW 1
80688: ST_TO_ADDR
80689: GO 80938
// begin if not mc_deposits_finder [ i ] then
80691: LD_EXP 99
80695: PUSH
80696: LD_VAR 0 2
80700: ARRAY
80701: NOT
80702: IFFALSE 80754
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
80704: LD_ADDR_EXP 99
80708: PUSH
80709: LD_EXP 99
80713: PPUSH
80714: LD_VAR 0 2
80718: PPUSH
80719: LD_VAR 0 3
80723: PUSH
80724: LD_INT 1
80726: ARRAY
80727: PUSH
80728: EMPTY
80729: LIST
80730: PPUSH
80731: CALL_OW 1
80735: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
80736: LD_VAR 0 3
80740: PUSH
80741: LD_INT 1
80743: ARRAY
80744: PPUSH
80745: LD_INT 125
80747: PPUSH
80748: CALL_OW 109
// end else
80752: GO 80938
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
80754: LD_EXP 99
80758: PUSH
80759: LD_VAR 0 2
80763: ARRAY
80764: PUSH
80765: LD_INT 1
80767: ARRAY
80768: PPUSH
80769: CALL_OW 310
80773: IFFALSE 80796
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
80775: LD_EXP 99
80779: PUSH
80780: LD_VAR 0 2
80784: ARRAY
80785: PUSH
80786: LD_INT 1
80788: ARRAY
80789: PPUSH
80790: CALL_OW 122
80794: GO 80938
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
80796: LD_EXP 99
80800: PUSH
80801: LD_VAR 0 2
80805: ARRAY
80806: PUSH
80807: LD_INT 1
80809: ARRAY
80810: PPUSH
80811: CALL_OW 314
80815: NOT
80816: PUSH
80817: LD_EXP 99
80821: PUSH
80822: LD_VAR 0 2
80826: ARRAY
80827: PUSH
80828: LD_INT 1
80830: ARRAY
80831: PPUSH
80832: LD_EXP 98
80836: PUSH
80837: LD_VAR 0 2
80841: ARRAY
80842: PUSH
80843: LD_INT 1
80845: ARRAY
80846: PUSH
80847: LD_INT 1
80849: ARRAY
80850: PPUSH
80851: LD_EXP 98
80855: PUSH
80856: LD_VAR 0 2
80860: ARRAY
80861: PUSH
80862: LD_INT 1
80864: ARRAY
80865: PUSH
80866: LD_INT 2
80868: ARRAY
80869: PPUSH
80870: CALL_OW 297
80874: PUSH
80875: LD_INT 6
80877: GREATER
80878: AND
80879: IFFALSE 80938
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
80881: LD_EXP 99
80885: PUSH
80886: LD_VAR 0 2
80890: ARRAY
80891: PUSH
80892: LD_INT 1
80894: ARRAY
80895: PPUSH
80896: LD_EXP 98
80900: PUSH
80901: LD_VAR 0 2
80905: ARRAY
80906: PUSH
80907: LD_INT 1
80909: ARRAY
80910: PUSH
80911: LD_INT 1
80913: ARRAY
80914: PPUSH
80915: LD_EXP 98
80919: PUSH
80920: LD_VAR 0 2
80924: ARRAY
80925: PUSH
80926: LD_INT 1
80928: ARRAY
80929: PUSH
80930: LD_INT 2
80932: ARRAY
80933: PPUSH
80934: CALL_OW 111
// end ; end ; end ;
80938: GO 80351
80940: POP
80941: POP
// end ;
80942: LD_VAR 0 1
80946: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
80947: LD_INT 0
80949: PPUSH
80950: PPUSH
80951: PPUSH
80952: PPUSH
80953: PPUSH
80954: PPUSH
80955: PPUSH
80956: PPUSH
80957: PPUSH
80958: PPUSH
80959: PPUSH
// if not mc_bases then
80960: LD_EXP 61
80964: NOT
80965: IFFALSE 80969
// exit ;
80967: GO 81909
// for i = 1 to mc_bases do
80969: LD_ADDR_VAR 0 2
80973: PUSH
80974: DOUBLE
80975: LD_INT 1
80977: DEC
80978: ST_TO_ADDR
80979: LD_EXP 61
80983: PUSH
80984: FOR_TO
80985: IFFALSE 81907
// begin if not mc_bases [ i ] or mc_scan [ i ] then
80987: LD_EXP 61
80991: PUSH
80992: LD_VAR 0 2
80996: ARRAY
80997: NOT
80998: PUSH
80999: LD_EXP 84
81003: PUSH
81004: LD_VAR 0 2
81008: ARRAY
81009: OR
81010: IFFALSE 81014
// continue ;
81012: GO 80984
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81014: LD_ADDR_VAR 0 7
81018: PUSH
81019: LD_EXP 61
81023: PUSH
81024: LD_VAR 0 2
81028: ARRAY
81029: PUSH
81030: LD_INT 1
81032: ARRAY
81033: PPUSH
81034: CALL_OW 248
81038: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81039: LD_VAR 0 7
81043: PUSH
81044: LD_INT 3
81046: EQUAL
81047: PUSH
81048: LD_EXP 80
81052: PUSH
81053: LD_VAR 0 2
81057: ARRAY
81058: PUSH
81059: LD_EXP 83
81063: PUSH
81064: LD_VAR 0 2
81068: ARRAY
81069: UNION
81070: PPUSH
81071: LD_INT 33
81073: PUSH
81074: LD_INT 2
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PPUSH
81081: CALL_OW 72
81085: NOT
81086: OR
81087: IFFALSE 81091
// continue ;
81089: GO 80984
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81091: LD_ADDR_VAR 0 9
81095: PUSH
81096: LD_EXP 61
81100: PUSH
81101: LD_VAR 0 2
81105: ARRAY
81106: PPUSH
81107: LD_INT 30
81109: PUSH
81110: LD_INT 36
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PPUSH
81117: CALL_OW 72
81121: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81122: LD_ADDR_VAR 0 10
81126: PUSH
81127: LD_EXP 80
81131: PUSH
81132: LD_VAR 0 2
81136: ARRAY
81137: PPUSH
81138: LD_INT 34
81140: PUSH
81141: LD_INT 31
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PPUSH
81148: CALL_OW 72
81152: ST_TO_ADDR
// if not cts and not mcts then
81153: LD_VAR 0 9
81157: NOT
81158: PUSH
81159: LD_VAR 0 10
81163: NOT
81164: AND
81165: IFFALSE 81169
// continue ;
81167: GO 80984
// x := cts ;
81169: LD_ADDR_VAR 0 11
81173: PUSH
81174: LD_VAR 0 9
81178: ST_TO_ADDR
// if not x then
81179: LD_VAR 0 11
81183: NOT
81184: IFFALSE 81196
// x := mcts ;
81186: LD_ADDR_VAR 0 11
81190: PUSH
81191: LD_VAR 0 10
81195: ST_TO_ADDR
// if not x then
81196: LD_VAR 0 11
81200: NOT
81201: IFFALSE 81205
// continue ;
81203: GO 80984
// if mc_remote_driver [ i ] then
81205: LD_EXP 101
81209: PUSH
81210: LD_VAR 0 2
81214: ARRAY
81215: IFFALSE 81602
// for j in mc_remote_driver [ i ] do
81217: LD_ADDR_VAR 0 3
81221: PUSH
81222: LD_EXP 101
81226: PUSH
81227: LD_VAR 0 2
81231: ARRAY
81232: PUSH
81233: FOR_IN
81234: IFFALSE 81600
// begin if GetClass ( j ) <> 3 then
81236: LD_VAR 0 3
81240: PPUSH
81241: CALL_OW 257
81245: PUSH
81246: LD_INT 3
81248: NONEQUAL
81249: IFFALSE 81302
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
81251: LD_ADDR_EXP 101
81255: PUSH
81256: LD_EXP 101
81260: PPUSH
81261: LD_VAR 0 2
81265: PPUSH
81266: LD_EXP 101
81270: PUSH
81271: LD_VAR 0 2
81275: ARRAY
81276: PUSH
81277: LD_VAR 0 3
81281: DIFF
81282: PPUSH
81283: CALL_OW 1
81287: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81288: LD_VAR 0 3
81292: PPUSH
81293: LD_INT 0
81295: PPUSH
81296: CALL_OW 109
// continue ;
81300: GO 81233
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
81302: LD_EXP 80
81306: PUSH
81307: LD_VAR 0 2
81311: ARRAY
81312: PPUSH
81313: LD_INT 34
81315: PUSH
81316: LD_INT 31
81318: PUSH
81319: EMPTY
81320: LIST
81321: LIST
81322: PUSH
81323: LD_INT 58
81325: PUSH
81326: EMPTY
81327: LIST
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PPUSH
81333: CALL_OW 72
81337: PUSH
81338: LD_VAR 0 3
81342: PPUSH
81343: CALL 51740 0 1
81347: NOT
81348: AND
81349: IFFALSE 81420
// begin if IsInUnit ( j ) then
81351: LD_VAR 0 3
81355: PPUSH
81356: CALL_OW 310
81360: IFFALSE 81371
// ComExitBuilding ( j ) ;
81362: LD_VAR 0 3
81366: PPUSH
81367: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
81371: LD_VAR 0 3
81375: PPUSH
81376: LD_EXP 80
81380: PUSH
81381: LD_VAR 0 2
81385: ARRAY
81386: PPUSH
81387: LD_INT 34
81389: PUSH
81390: LD_INT 31
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 58
81399: PUSH
81400: EMPTY
81401: LIST
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PPUSH
81407: CALL_OW 72
81411: PUSH
81412: LD_INT 1
81414: ARRAY
81415: PPUSH
81416: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
81420: LD_VAR 0 3
81424: PPUSH
81425: CALL_OW 310
81429: NOT
81430: PUSH
81431: LD_VAR 0 3
81435: PPUSH
81436: CALL_OW 310
81440: PPUSH
81441: CALL_OW 266
81445: PUSH
81446: LD_INT 36
81448: NONEQUAL
81449: PUSH
81450: LD_VAR 0 3
81454: PPUSH
81455: CALL 51740 0 1
81459: NOT
81460: AND
81461: OR
81462: IFFALSE 81598
// begin if IsInUnit ( j ) then
81464: LD_VAR 0 3
81468: PPUSH
81469: CALL_OW 310
81473: IFFALSE 81484
// ComExitBuilding ( j ) ;
81475: LD_VAR 0 3
81479: PPUSH
81480: CALL_OW 122
// ct := 0 ;
81484: LD_ADDR_VAR 0 8
81488: PUSH
81489: LD_INT 0
81491: ST_TO_ADDR
// for k in x do
81492: LD_ADDR_VAR 0 4
81496: PUSH
81497: LD_VAR 0 11
81501: PUSH
81502: FOR_IN
81503: IFFALSE 81576
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
81505: LD_VAR 0 4
81509: PPUSH
81510: CALL_OW 264
81514: PUSH
81515: LD_INT 31
81517: EQUAL
81518: PUSH
81519: LD_VAR 0 4
81523: PPUSH
81524: CALL_OW 311
81528: NOT
81529: AND
81530: PUSH
81531: LD_VAR 0 4
81535: PPUSH
81536: CALL_OW 266
81540: PUSH
81541: LD_INT 36
81543: EQUAL
81544: PUSH
81545: LD_VAR 0 4
81549: PPUSH
81550: CALL_OW 313
81554: PUSH
81555: LD_INT 3
81557: LESS
81558: AND
81559: OR
81560: IFFALSE 81574
// begin ct := k ;
81562: LD_ADDR_VAR 0 8
81566: PUSH
81567: LD_VAR 0 4
81571: ST_TO_ADDR
// break ;
81572: GO 81576
// end ;
81574: GO 81502
81576: POP
81577: POP
// if ct then
81578: LD_VAR 0 8
81582: IFFALSE 81598
// ComEnterUnit ( j , ct ) ;
81584: LD_VAR 0 3
81588: PPUSH
81589: LD_VAR 0 8
81593: PPUSH
81594: CALL_OW 120
// end ; end ;
81598: GO 81233
81600: POP
81601: POP
// places := 0 ;
81602: LD_ADDR_VAR 0 5
81606: PUSH
81607: LD_INT 0
81609: ST_TO_ADDR
// for j = 1 to x do
81610: LD_ADDR_VAR 0 3
81614: PUSH
81615: DOUBLE
81616: LD_INT 1
81618: DEC
81619: ST_TO_ADDR
81620: LD_VAR 0 11
81624: PUSH
81625: FOR_TO
81626: IFFALSE 81702
// if GetWeapon ( x [ j ] ) = ar_control_tower then
81628: LD_VAR 0 11
81632: PUSH
81633: LD_VAR 0 3
81637: ARRAY
81638: PPUSH
81639: CALL_OW 264
81643: PUSH
81644: LD_INT 31
81646: EQUAL
81647: IFFALSE 81665
// places := places + 1 else
81649: LD_ADDR_VAR 0 5
81653: PUSH
81654: LD_VAR 0 5
81658: PUSH
81659: LD_INT 1
81661: PLUS
81662: ST_TO_ADDR
81663: GO 81700
// if GetBType ( x [ j ] ) = b_control_tower then
81665: LD_VAR 0 11
81669: PUSH
81670: LD_VAR 0 3
81674: ARRAY
81675: PPUSH
81676: CALL_OW 266
81680: PUSH
81681: LD_INT 36
81683: EQUAL
81684: IFFALSE 81700
// places := places + 3 ;
81686: LD_ADDR_VAR 0 5
81690: PUSH
81691: LD_VAR 0 5
81695: PUSH
81696: LD_INT 3
81698: PLUS
81699: ST_TO_ADDR
81700: GO 81625
81702: POP
81703: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
81704: LD_VAR 0 5
81708: PUSH
81709: LD_INT 0
81711: EQUAL
81712: PUSH
81713: LD_VAR 0 5
81717: PUSH
81718: LD_EXP 101
81722: PUSH
81723: LD_VAR 0 2
81727: ARRAY
81728: LESSEQUAL
81729: OR
81730: IFFALSE 81734
// continue ;
81732: GO 80984
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
81734: LD_ADDR_VAR 0 6
81738: PUSH
81739: LD_EXP 61
81743: PUSH
81744: LD_VAR 0 2
81748: ARRAY
81749: PPUSH
81750: LD_INT 25
81752: PUSH
81753: LD_INT 3
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: PPUSH
81760: CALL_OW 72
81764: PUSH
81765: LD_EXP 101
81769: PUSH
81770: LD_VAR 0 2
81774: ARRAY
81775: DIFF
81776: PPUSH
81777: LD_INT 3
81779: PPUSH
81780: CALL 52640 0 2
81784: ST_TO_ADDR
// for j in tmp do
81785: LD_ADDR_VAR 0 3
81789: PUSH
81790: LD_VAR 0 6
81794: PUSH
81795: FOR_IN
81796: IFFALSE 81831
// if GetTag ( j ) > 0 then
81798: LD_VAR 0 3
81802: PPUSH
81803: CALL_OW 110
81807: PUSH
81808: LD_INT 0
81810: GREATER
81811: IFFALSE 81829
// tmp := tmp diff j ;
81813: LD_ADDR_VAR 0 6
81817: PUSH
81818: LD_VAR 0 6
81822: PUSH
81823: LD_VAR 0 3
81827: DIFF
81828: ST_TO_ADDR
81829: GO 81795
81831: POP
81832: POP
// if not tmp then
81833: LD_VAR 0 6
81837: NOT
81838: IFFALSE 81842
// continue ;
81840: GO 80984
// if places then
81842: LD_VAR 0 5
81846: IFFALSE 81905
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
81848: LD_ADDR_EXP 101
81852: PUSH
81853: LD_EXP 101
81857: PPUSH
81858: LD_VAR 0 2
81862: PPUSH
81863: LD_EXP 101
81867: PUSH
81868: LD_VAR 0 2
81872: ARRAY
81873: PUSH
81874: LD_VAR 0 6
81878: PUSH
81879: LD_INT 1
81881: ARRAY
81882: UNION
81883: PPUSH
81884: CALL_OW 1
81888: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
81889: LD_VAR 0 6
81893: PUSH
81894: LD_INT 1
81896: ARRAY
81897: PPUSH
81898: LD_INT 126
81900: PPUSH
81901: CALL_OW 109
// end ; end ;
81905: GO 80984
81907: POP
81908: POP
// end ;
81909: LD_VAR 0 1
81913: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
81914: LD_INT 0
81916: PPUSH
81917: PPUSH
81918: PPUSH
81919: PPUSH
81920: PPUSH
81921: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
81922: LD_VAR 0 1
81926: NOT
81927: PUSH
81928: LD_VAR 0 2
81932: NOT
81933: OR
81934: PUSH
81935: LD_VAR 0 3
81939: NOT
81940: OR
81941: PUSH
81942: LD_VAR 0 4
81946: PUSH
81947: LD_INT 1
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: LD_INT 3
81955: PUSH
81956: LD_INT 4
81958: PUSH
81959: LD_INT 5
81961: PUSH
81962: LD_INT 8
81964: PUSH
81965: LD_INT 9
81967: PUSH
81968: LD_INT 15
81970: PUSH
81971: LD_INT 16
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: IN
81985: NOT
81986: OR
81987: IFFALSE 81991
// exit ;
81989: GO 82849
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
81991: LD_ADDR_VAR 0 2
81995: PUSH
81996: LD_VAR 0 2
82000: PPUSH
82001: LD_INT 21
82003: PUSH
82004: LD_INT 3
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 24
82013: PUSH
82014: LD_INT 250
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PPUSH
82025: CALL_OW 72
82029: ST_TO_ADDR
// case class of 1 , 15 :
82030: LD_VAR 0 4
82034: PUSH
82035: LD_INT 1
82037: DOUBLE
82038: EQUAL
82039: IFTRUE 82049
82041: LD_INT 15
82043: DOUBLE
82044: EQUAL
82045: IFTRUE 82049
82047: GO 82134
82049: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82050: LD_ADDR_VAR 0 8
82054: PUSH
82055: LD_VAR 0 2
82059: PPUSH
82060: LD_INT 2
82062: PUSH
82063: LD_INT 30
82065: PUSH
82066: LD_INT 32
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 30
82075: PUSH
82076: LD_INT 31
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: LIST
82087: PPUSH
82088: CALL_OW 72
82092: PUSH
82093: LD_VAR 0 2
82097: PPUSH
82098: LD_INT 2
82100: PUSH
82101: LD_INT 30
82103: PUSH
82104: LD_INT 4
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 30
82113: PUSH
82114: LD_INT 5
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: LIST
82125: PPUSH
82126: CALL_OW 72
82130: ADD
82131: ST_TO_ADDR
82132: GO 82380
82134: LD_INT 2
82136: DOUBLE
82137: EQUAL
82138: IFTRUE 82148
82140: LD_INT 16
82142: DOUBLE
82143: EQUAL
82144: IFTRUE 82148
82146: GO 82194
82148: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
82149: LD_ADDR_VAR 0 8
82153: PUSH
82154: LD_VAR 0 2
82158: PPUSH
82159: LD_INT 2
82161: PUSH
82162: LD_INT 30
82164: PUSH
82165: LD_INT 0
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 30
82174: PUSH
82175: LD_INT 1
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: LIST
82186: PPUSH
82187: CALL_OW 72
82191: ST_TO_ADDR
82192: GO 82380
82194: LD_INT 3
82196: DOUBLE
82197: EQUAL
82198: IFTRUE 82202
82200: GO 82248
82202: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
82203: LD_ADDR_VAR 0 8
82207: PUSH
82208: LD_VAR 0 2
82212: PPUSH
82213: LD_INT 2
82215: PUSH
82216: LD_INT 30
82218: PUSH
82219: LD_INT 2
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 30
82228: PUSH
82229: LD_INT 3
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: LIST
82240: PPUSH
82241: CALL_OW 72
82245: ST_TO_ADDR
82246: GO 82380
82248: LD_INT 4
82250: DOUBLE
82251: EQUAL
82252: IFTRUE 82256
82254: GO 82313
82256: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
82257: LD_ADDR_VAR 0 8
82261: PUSH
82262: LD_VAR 0 2
82266: PPUSH
82267: LD_INT 2
82269: PUSH
82270: LD_INT 30
82272: PUSH
82273: LD_INT 6
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 30
82282: PUSH
82283: LD_INT 7
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 30
82292: PUSH
82293: LD_INT 8
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: PPUSH
82306: CALL_OW 72
82310: ST_TO_ADDR
82311: GO 82380
82313: LD_INT 5
82315: DOUBLE
82316: EQUAL
82317: IFTRUE 82333
82319: LD_INT 8
82321: DOUBLE
82322: EQUAL
82323: IFTRUE 82333
82325: LD_INT 9
82327: DOUBLE
82328: EQUAL
82329: IFTRUE 82333
82331: GO 82379
82333: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
82334: LD_ADDR_VAR 0 8
82338: PUSH
82339: LD_VAR 0 2
82343: PPUSH
82344: LD_INT 2
82346: PUSH
82347: LD_INT 30
82349: PUSH
82350: LD_INT 4
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 30
82359: PUSH
82360: LD_INT 5
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: LIST
82371: PPUSH
82372: CALL_OW 72
82376: ST_TO_ADDR
82377: GO 82380
82379: POP
// if not tmp then
82380: LD_VAR 0 8
82384: NOT
82385: IFFALSE 82389
// exit ;
82387: GO 82849
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
82389: LD_VAR 0 4
82393: PUSH
82394: LD_INT 1
82396: PUSH
82397: LD_INT 15
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: IN
82404: PUSH
82405: LD_EXP 70
82409: PUSH
82410: LD_VAR 0 1
82414: ARRAY
82415: AND
82416: IFFALSE 82572
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
82418: LD_ADDR_VAR 0 9
82422: PUSH
82423: LD_EXP 70
82427: PUSH
82428: LD_VAR 0 1
82432: ARRAY
82433: PUSH
82434: LD_INT 1
82436: ARRAY
82437: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
82438: LD_VAR 0 9
82442: PUSH
82443: LD_EXP 71
82447: PUSH
82448: LD_VAR 0 1
82452: ARRAY
82453: IN
82454: NOT
82455: IFFALSE 82570
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
82457: LD_ADDR_EXP 71
82461: PUSH
82462: LD_EXP 71
82466: PPUSH
82467: LD_VAR 0 1
82471: PUSH
82472: LD_EXP 71
82476: PUSH
82477: LD_VAR 0 1
82481: ARRAY
82482: PUSH
82483: LD_INT 1
82485: PLUS
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PPUSH
82491: LD_VAR 0 9
82495: PPUSH
82496: CALL 21407 0 3
82500: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
82501: LD_ADDR_EXP 70
82505: PUSH
82506: LD_EXP 70
82510: PPUSH
82511: LD_VAR 0 1
82515: PPUSH
82516: LD_EXP 70
82520: PUSH
82521: LD_VAR 0 1
82525: ARRAY
82526: PUSH
82527: LD_VAR 0 9
82531: DIFF
82532: PPUSH
82533: CALL_OW 1
82537: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
82538: LD_VAR 0 3
82542: PPUSH
82543: LD_EXP 71
82547: PUSH
82548: LD_VAR 0 1
82552: ARRAY
82553: PUSH
82554: LD_EXP 71
82558: PUSH
82559: LD_VAR 0 1
82563: ARRAY
82564: ARRAY
82565: PPUSH
82566: CALL_OW 120
// end ; exit ;
82570: GO 82849
// end ; if tmp > 1 then
82572: LD_VAR 0 8
82576: PUSH
82577: LD_INT 1
82579: GREATER
82580: IFFALSE 82684
// for i = 2 to tmp do
82582: LD_ADDR_VAR 0 6
82586: PUSH
82587: DOUBLE
82588: LD_INT 2
82590: DEC
82591: ST_TO_ADDR
82592: LD_VAR 0 8
82596: PUSH
82597: FOR_TO
82598: IFFALSE 82682
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
82600: LD_VAR 0 8
82604: PUSH
82605: LD_VAR 0 6
82609: ARRAY
82610: PPUSH
82611: CALL_OW 461
82615: PUSH
82616: LD_INT 6
82618: EQUAL
82619: IFFALSE 82680
// begin x := tmp [ i ] ;
82621: LD_ADDR_VAR 0 9
82625: PUSH
82626: LD_VAR 0 8
82630: PUSH
82631: LD_VAR 0 6
82635: ARRAY
82636: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
82637: LD_ADDR_VAR 0 8
82641: PUSH
82642: LD_VAR 0 8
82646: PPUSH
82647: LD_VAR 0 6
82651: PPUSH
82652: CALL_OW 3
82656: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
82657: LD_ADDR_VAR 0 8
82661: PUSH
82662: LD_VAR 0 8
82666: PPUSH
82667: LD_INT 1
82669: PPUSH
82670: LD_VAR 0 9
82674: PPUSH
82675: CALL_OW 2
82679: ST_TO_ADDR
// end ;
82680: GO 82597
82682: POP
82683: POP
// for i in tmp do
82684: LD_ADDR_VAR 0 6
82688: PUSH
82689: LD_VAR 0 8
82693: PUSH
82694: FOR_IN
82695: IFFALSE 82722
// begin if IsNotFull ( i ) then
82697: LD_VAR 0 6
82701: PPUSH
82702: CALL 18629 0 1
82706: IFFALSE 82720
// begin j := i ;
82708: LD_ADDR_VAR 0 7
82712: PUSH
82713: LD_VAR 0 6
82717: ST_TO_ADDR
// break ;
82718: GO 82722
// end ; end ;
82720: GO 82694
82722: POP
82723: POP
// if j then
82724: LD_VAR 0 7
82728: IFFALSE 82746
// ComEnterUnit ( unit , j ) else
82730: LD_VAR 0 3
82734: PPUSH
82735: LD_VAR 0 7
82739: PPUSH
82740: CALL_OW 120
82744: GO 82849
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82746: LD_ADDR_VAR 0 10
82750: PUSH
82751: LD_VAR 0 2
82755: PPUSH
82756: LD_INT 2
82758: PUSH
82759: LD_INT 30
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 30
82771: PUSH
82772: LD_INT 1
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: LIST
82783: PPUSH
82784: CALL_OW 72
82788: ST_TO_ADDR
// if depot then
82789: LD_VAR 0 10
82793: IFFALSE 82849
// begin depot := NearestUnitToUnit ( depot , unit ) ;
82795: LD_ADDR_VAR 0 10
82799: PUSH
82800: LD_VAR 0 10
82804: PPUSH
82805: LD_VAR 0 3
82809: PPUSH
82810: CALL_OW 74
82814: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
82815: LD_VAR 0 3
82819: PPUSH
82820: LD_VAR 0 10
82824: PPUSH
82825: CALL_OW 296
82829: PUSH
82830: LD_INT 10
82832: GREATER
82833: IFFALSE 82849
// ComStandNearbyBuilding ( unit , depot ) ;
82835: LD_VAR 0 3
82839: PPUSH
82840: LD_VAR 0 10
82844: PPUSH
82845: CALL 18009 0 2
// end ; end ; end ;
82849: LD_VAR 0 5
82853: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
82854: LD_INT 0
82856: PPUSH
82857: PPUSH
82858: PPUSH
82859: PPUSH
// if not mc_bases then
82860: LD_EXP 61
82864: NOT
82865: IFFALSE 82869
// exit ;
82867: GO 83108
// for i = 1 to mc_bases do
82869: LD_ADDR_VAR 0 2
82873: PUSH
82874: DOUBLE
82875: LD_INT 1
82877: DEC
82878: ST_TO_ADDR
82879: LD_EXP 61
82883: PUSH
82884: FOR_TO
82885: IFFALSE 83106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
82887: LD_ADDR_VAR 0 4
82891: PUSH
82892: LD_EXP 61
82896: PUSH
82897: LD_VAR 0 2
82901: ARRAY
82902: PPUSH
82903: LD_INT 21
82905: PUSH
82906: LD_INT 1
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PPUSH
82913: CALL_OW 72
82917: PUSH
82918: LD_EXP 90
82922: PUSH
82923: LD_VAR 0 2
82927: ARRAY
82928: UNION
82929: ST_TO_ADDR
// if not tmp then
82930: LD_VAR 0 4
82934: NOT
82935: IFFALSE 82939
// continue ;
82937: GO 82884
// for j in tmp do
82939: LD_ADDR_VAR 0 3
82943: PUSH
82944: LD_VAR 0 4
82948: PUSH
82949: FOR_IN
82950: IFFALSE 83102
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
82952: LD_VAR 0 3
82956: PPUSH
82957: CALL_OW 110
82961: NOT
82962: PUSH
82963: LD_VAR 0 3
82967: PPUSH
82968: CALL_OW 314
82972: NOT
82973: AND
82974: PUSH
82975: LD_VAR 0 3
82979: PPUSH
82980: CALL_OW 311
82984: NOT
82985: AND
82986: PUSH
82987: LD_VAR 0 3
82991: PPUSH
82992: CALL_OW 310
82996: NOT
82997: AND
82998: PUSH
82999: LD_VAR 0 3
83003: PUSH
83004: LD_EXP 64
83008: PUSH
83009: LD_VAR 0 2
83013: ARRAY
83014: PUSH
83015: LD_INT 1
83017: ARRAY
83018: IN
83019: NOT
83020: AND
83021: PUSH
83022: LD_VAR 0 3
83026: PUSH
83027: LD_EXP 64
83031: PUSH
83032: LD_VAR 0 2
83036: ARRAY
83037: PUSH
83038: LD_INT 2
83040: ARRAY
83041: IN
83042: NOT
83043: AND
83044: PUSH
83045: LD_VAR 0 3
83049: PUSH
83050: LD_EXP 73
83054: PUSH
83055: LD_VAR 0 2
83059: ARRAY
83060: IN
83061: NOT
83062: AND
83063: IFFALSE 83100
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83065: LD_VAR 0 2
83069: PPUSH
83070: LD_EXP 61
83074: PUSH
83075: LD_VAR 0 2
83079: ARRAY
83080: PPUSH
83081: LD_VAR 0 3
83085: PPUSH
83086: LD_VAR 0 3
83090: PPUSH
83091: CALL_OW 257
83095: PPUSH
83096: CALL 81914 0 4
// end ;
83100: GO 82949
83102: POP
83103: POP
// end ;
83104: GO 82884
83106: POP
83107: POP
// end ;
83108: LD_VAR 0 1
83112: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
83113: LD_INT 0
83115: PPUSH
83116: PPUSH
83117: PPUSH
83118: PPUSH
83119: PPUSH
83120: PPUSH
// if not mc_bases [ base ] then
83121: LD_EXP 61
83125: PUSH
83126: LD_VAR 0 1
83130: ARRAY
83131: NOT
83132: IFFALSE 83136
// exit ;
83134: GO 83337
// tmp := [ ] ;
83136: LD_ADDR_VAR 0 6
83140: PUSH
83141: EMPTY
83142: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
83143: LD_ADDR_VAR 0 7
83147: PUSH
83148: LD_VAR 0 3
83152: PPUSH
83153: LD_INT 0
83155: PPUSH
83156: CALL_OW 517
83160: ST_TO_ADDR
// if not list then
83161: LD_VAR 0 7
83165: NOT
83166: IFFALSE 83170
// exit ;
83168: GO 83337
// c := Count ( list [ 1 ] ) ;
83170: LD_ADDR_VAR 0 9
83174: PUSH
83175: LD_VAR 0 7
83179: PUSH
83180: LD_INT 1
83182: ARRAY
83183: PPUSH
83184: CALL 18547 0 1
83188: ST_TO_ADDR
// if amount > c then
83189: LD_VAR 0 2
83193: PUSH
83194: LD_VAR 0 9
83198: GREATER
83199: IFFALSE 83211
// amount := c ;
83201: LD_ADDR_VAR 0 2
83205: PUSH
83206: LD_VAR 0 9
83210: ST_TO_ADDR
// for i := 1 to amount do
83211: LD_ADDR_VAR 0 5
83215: PUSH
83216: DOUBLE
83217: LD_INT 1
83219: DEC
83220: ST_TO_ADDR
83221: LD_VAR 0 2
83225: PUSH
83226: FOR_TO
83227: IFFALSE 83285
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
83229: LD_ADDR_VAR 0 6
83233: PUSH
83234: LD_VAR 0 6
83238: PPUSH
83239: LD_VAR 0 5
83243: PPUSH
83244: LD_VAR 0 7
83248: PUSH
83249: LD_INT 1
83251: ARRAY
83252: PUSH
83253: LD_VAR 0 5
83257: ARRAY
83258: PUSH
83259: LD_VAR 0 7
83263: PUSH
83264: LD_INT 2
83266: ARRAY
83267: PUSH
83268: LD_VAR 0 5
83272: ARRAY
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PPUSH
83278: CALL_OW 1
83282: ST_TO_ADDR
83283: GO 83226
83285: POP
83286: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
83287: LD_ADDR_EXP 74
83291: PUSH
83292: LD_EXP 74
83296: PPUSH
83297: LD_VAR 0 1
83301: PPUSH
83302: LD_VAR 0 6
83306: PPUSH
83307: CALL_OW 1
83311: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
83312: LD_ADDR_EXP 76
83316: PUSH
83317: LD_EXP 76
83321: PPUSH
83322: LD_VAR 0 1
83326: PPUSH
83327: LD_VAR 0 3
83331: PPUSH
83332: CALL_OW 1
83336: ST_TO_ADDR
// end ;
83337: LD_VAR 0 4
83341: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
83342: LD_INT 0
83344: PPUSH
// if not mc_bases [ base ] then
83345: LD_EXP 61
83349: PUSH
83350: LD_VAR 0 1
83354: ARRAY
83355: NOT
83356: IFFALSE 83360
// exit ;
83358: GO 83385
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
83360: LD_ADDR_EXP 66
83364: PUSH
83365: LD_EXP 66
83369: PPUSH
83370: LD_VAR 0 1
83374: PPUSH
83375: LD_VAR 0 2
83379: PPUSH
83380: CALL_OW 1
83384: ST_TO_ADDR
// end ;
83385: LD_VAR 0 3
83389: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
83390: LD_INT 0
83392: PPUSH
// if not mc_bases [ base ] then
83393: LD_EXP 61
83397: PUSH
83398: LD_VAR 0 1
83402: ARRAY
83403: NOT
83404: IFFALSE 83408
// exit ;
83406: GO 83445
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
83408: LD_ADDR_EXP 66
83412: PUSH
83413: LD_EXP 66
83417: PPUSH
83418: LD_VAR 0 1
83422: PPUSH
83423: LD_EXP 66
83427: PUSH
83428: LD_VAR 0 1
83432: ARRAY
83433: PUSH
83434: LD_VAR 0 2
83438: UNION
83439: PPUSH
83440: CALL_OW 1
83444: ST_TO_ADDR
// end ;
83445: LD_VAR 0 3
83449: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
83450: LD_INT 0
83452: PPUSH
// if not mc_bases [ base ] then
83453: LD_EXP 61
83457: PUSH
83458: LD_VAR 0 1
83462: ARRAY
83463: NOT
83464: IFFALSE 83468
// exit ;
83466: GO 83493
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
83468: LD_ADDR_EXP 82
83472: PUSH
83473: LD_EXP 82
83477: PPUSH
83478: LD_VAR 0 1
83482: PPUSH
83483: LD_VAR 0 2
83487: PPUSH
83488: CALL_OW 1
83492: ST_TO_ADDR
// end ;
83493: LD_VAR 0 3
83497: RET
// export function MC_InsertProduceList ( base , components ) ; begin
83498: LD_INT 0
83500: PPUSH
// if not mc_bases [ base ] then
83501: LD_EXP 61
83505: PUSH
83506: LD_VAR 0 1
83510: ARRAY
83511: NOT
83512: IFFALSE 83516
// exit ;
83514: GO 83553
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
83516: LD_ADDR_EXP 82
83520: PUSH
83521: LD_EXP 82
83525: PPUSH
83526: LD_VAR 0 1
83530: PPUSH
83531: LD_EXP 82
83535: PUSH
83536: LD_VAR 0 1
83540: ARRAY
83541: PUSH
83542: LD_VAR 0 2
83546: ADD
83547: PPUSH
83548: CALL_OW 1
83552: ST_TO_ADDR
// end ;
83553: LD_VAR 0 3
83557: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
83558: LD_INT 0
83560: PPUSH
// if not mc_bases [ base ] then
83561: LD_EXP 61
83565: PUSH
83566: LD_VAR 0 1
83570: ARRAY
83571: NOT
83572: IFFALSE 83576
// exit ;
83574: GO 83630
// mc_defender := Replace ( mc_defender , base , deflist ) ;
83576: LD_ADDR_EXP 83
83580: PUSH
83581: LD_EXP 83
83585: PPUSH
83586: LD_VAR 0 1
83590: PPUSH
83591: LD_VAR 0 2
83595: PPUSH
83596: CALL_OW 1
83600: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
83601: LD_ADDR_EXP 72
83605: PUSH
83606: LD_EXP 72
83610: PPUSH
83611: LD_VAR 0 1
83615: PPUSH
83616: LD_VAR 0 2
83620: PUSH
83621: LD_INT 0
83623: PLUS
83624: PPUSH
83625: CALL_OW 1
83629: ST_TO_ADDR
// end ;
83630: LD_VAR 0 3
83634: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
83635: LD_INT 0
83637: PPUSH
// if not mc_bases [ base ] then
83638: LD_EXP 61
83642: PUSH
83643: LD_VAR 0 1
83647: ARRAY
83648: NOT
83649: IFFALSE 83653
// exit ;
83651: GO 83678
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
83653: LD_ADDR_EXP 72
83657: PUSH
83658: LD_EXP 72
83662: PPUSH
83663: LD_VAR 0 1
83667: PPUSH
83668: LD_VAR 0 2
83672: PPUSH
83673: CALL_OW 1
83677: ST_TO_ADDR
// end ;
83678: LD_VAR 0 3
83682: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
83683: LD_INT 0
83685: PPUSH
83686: PPUSH
83687: PPUSH
83688: PPUSH
// if not mc_bases [ base ] then
83689: LD_EXP 61
83693: PUSH
83694: LD_VAR 0 1
83698: ARRAY
83699: NOT
83700: IFFALSE 83704
// exit ;
83702: GO 83769
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
83704: LD_ADDR_EXP 81
83708: PUSH
83709: LD_EXP 81
83713: PPUSH
83714: LD_VAR 0 1
83718: PUSH
83719: LD_EXP 81
83723: PUSH
83724: LD_VAR 0 1
83728: ARRAY
83729: PUSH
83730: LD_INT 1
83732: PLUS
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PPUSH
83738: LD_VAR 0 1
83742: PUSH
83743: LD_VAR 0 2
83747: PUSH
83748: LD_VAR 0 3
83752: PUSH
83753: LD_VAR 0 4
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: PPUSH
83764: CALL 21407 0 3
83768: ST_TO_ADDR
// end ;
83769: LD_VAR 0 5
83773: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
83774: LD_INT 0
83776: PPUSH
// if not mc_bases [ base ] then
83777: LD_EXP 61
83781: PUSH
83782: LD_VAR 0 1
83786: ARRAY
83787: NOT
83788: IFFALSE 83792
// exit ;
83790: GO 83817
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
83792: LD_ADDR_EXP 98
83796: PUSH
83797: LD_EXP 98
83801: PPUSH
83802: LD_VAR 0 1
83806: PPUSH
83807: LD_VAR 0 2
83811: PPUSH
83812: CALL_OW 1
83816: ST_TO_ADDR
// end ;
83817: LD_VAR 0 3
83821: RET
// export function MC_GetMinesField ( base ) ; begin
83822: LD_INT 0
83824: PPUSH
// result := mc_mines [ base ] ;
83825: LD_ADDR_VAR 0 2
83829: PUSH
83830: LD_EXP 74
83834: PUSH
83835: LD_VAR 0 1
83839: ARRAY
83840: ST_TO_ADDR
// end ;
83841: LD_VAR 0 2
83845: RET
// export function MC_GetProduceList ( base ) ; begin
83846: LD_INT 0
83848: PPUSH
// result := mc_produce [ base ] ;
83849: LD_ADDR_VAR 0 2
83853: PUSH
83854: LD_EXP 82
83858: PUSH
83859: LD_VAR 0 1
83863: ARRAY
83864: ST_TO_ADDR
// end ;
83865: LD_VAR 0 2
83869: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
83870: LD_INT 0
83872: PPUSH
83873: PPUSH
// if not mc_bases then
83874: LD_EXP 61
83878: NOT
83879: IFFALSE 83883
// exit ;
83881: GO 83948
// if mc_bases [ base ] then
83883: LD_EXP 61
83887: PUSH
83888: LD_VAR 0 1
83892: ARRAY
83893: IFFALSE 83948
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83895: LD_ADDR_VAR 0 3
83899: PUSH
83900: LD_EXP 61
83904: PUSH
83905: LD_VAR 0 1
83909: ARRAY
83910: PPUSH
83911: LD_INT 30
83913: PUSH
83914: LD_VAR 0 2
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PPUSH
83923: CALL_OW 72
83927: ST_TO_ADDR
// if result then
83928: LD_VAR 0 3
83932: IFFALSE 83948
// result := result [ 1 ] ;
83934: LD_ADDR_VAR 0 3
83938: PUSH
83939: LD_VAR 0 3
83943: PUSH
83944: LD_INT 1
83946: ARRAY
83947: ST_TO_ADDR
// end ; end ;
83948: LD_VAR 0 3
83952: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
83953: LD_INT 0
83955: PPUSH
83956: PPUSH
// if not mc_bases then
83957: LD_EXP 61
83961: NOT
83962: IFFALSE 83966
// exit ;
83964: GO 84011
// if mc_bases [ base ] then
83966: LD_EXP 61
83970: PUSH
83971: LD_VAR 0 1
83975: ARRAY
83976: IFFALSE 84011
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83978: LD_ADDR_VAR 0 3
83982: PUSH
83983: LD_EXP 61
83987: PUSH
83988: LD_VAR 0 1
83992: ARRAY
83993: PPUSH
83994: LD_INT 30
83996: PUSH
83997: LD_VAR 0 2
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PPUSH
84006: CALL_OW 72
84010: ST_TO_ADDR
// end ;
84011: LD_VAR 0 3
84015: RET
// export function MC_SetTame ( base , area ) ; begin
84016: LD_INT 0
84018: PPUSH
// if not mc_bases or not base then
84019: LD_EXP 61
84023: NOT
84024: PUSH
84025: LD_VAR 0 1
84029: NOT
84030: OR
84031: IFFALSE 84035
// exit ;
84033: GO 84060
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84035: LD_ADDR_EXP 89
84039: PUSH
84040: LD_EXP 89
84044: PPUSH
84045: LD_VAR 0 1
84049: PPUSH
84050: LD_VAR 0 2
84054: PPUSH
84055: CALL_OW 1
84059: ST_TO_ADDR
// end ;
84060: LD_VAR 0 3
84064: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84065: LD_INT 0
84067: PPUSH
84068: PPUSH
// if not mc_bases or not base then
84069: LD_EXP 61
84073: NOT
84074: PUSH
84075: LD_VAR 0 1
84079: NOT
84080: OR
84081: IFFALSE 84085
// exit ;
84083: GO 84187
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84085: LD_ADDR_VAR 0 4
84089: PUSH
84090: LD_EXP 61
84094: PUSH
84095: LD_VAR 0 1
84099: ARRAY
84100: PPUSH
84101: LD_INT 30
84103: PUSH
84104: LD_VAR 0 2
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PPUSH
84113: CALL_OW 72
84117: ST_TO_ADDR
// if not tmp then
84118: LD_VAR 0 4
84122: NOT
84123: IFFALSE 84127
// exit ;
84125: GO 84187
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
84127: LD_ADDR_EXP 93
84131: PUSH
84132: LD_EXP 93
84136: PPUSH
84137: LD_VAR 0 1
84141: PPUSH
84142: LD_EXP 93
84146: PUSH
84147: LD_VAR 0 1
84151: ARRAY
84152: PPUSH
84153: LD_EXP 93
84157: PUSH
84158: LD_VAR 0 1
84162: ARRAY
84163: PUSH
84164: LD_INT 1
84166: PLUS
84167: PPUSH
84168: LD_VAR 0 4
84172: PUSH
84173: LD_INT 1
84175: ARRAY
84176: PPUSH
84177: CALL_OW 2
84181: PPUSH
84182: CALL_OW 1
84186: ST_TO_ADDR
// end ;
84187: LD_VAR 0 3
84191: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
84192: LD_INT 0
84194: PPUSH
84195: PPUSH
// if not mc_bases or not base or not kinds then
84196: LD_EXP 61
84200: NOT
84201: PUSH
84202: LD_VAR 0 1
84206: NOT
84207: OR
84208: PUSH
84209: LD_VAR 0 2
84213: NOT
84214: OR
84215: IFFALSE 84219
// exit ;
84217: GO 84280
// for i in kinds do
84219: LD_ADDR_VAR 0 4
84223: PUSH
84224: LD_VAR 0 2
84228: PUSH
84229: FOR_IN
84230: IFFALSE 84278
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
84232: LD_ADDR_EXP 95
84236: PUSH
84237: LD_EXP 95
84241: PPUSH
84242: LD_VAR 0 1
84246: PUSH
84247: LD_EXP 95
84251: PUSH
84252: LD_VAR 0 1
84256: ARRAY
84257: PUSH
84258: LD_INT 1
84260: PLUS
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PPUSH
84266: LD_VAR 0 4
84270: PPUSH
84271: CALL 21407 0 3
84275: ST_TO_ADDR
84276: GO 84229
84278: POP
84279: POP
// end ;
84280: LD_VAR 0 3
84284: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
84285: LD_INT 0
84287: PPUSH
// if not mc_bases or not base or not areas then
84288: LD_EXP 61
84292: NOT
84293: PUSH
84294: LD_VAR 0 1
84298: NOT
84299: OR
84300: PUSH
84301: LD_VAR 0 2
84305: NOT
84306: OR
84307: IFFALSE 84311
// exit ;
84309: GO 84336
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
84311: LD_ADDR_EXP 79
84315: PUSH
84316: LD_EXP 79
84320: PPUSH
84321: LD_VAR 0 1
84325: PPUSH
84326: LD_VAR 0 2
84330: PPUSH
84331: CALL_OW 1
84335: ST_TO_ADDR
// end ;
84336: LD_VAR 0 3
84340: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
84341: LD_INT 0
84343: PPUSH
// if not mc_bases or not base or not teleports_exit then
84344: LD_EXP 61
84348: NOT
84349: PUSH
84350: LD_VAR 0 1
84354: NOT
84355: OR
84356: PUSH
84357: LD_VAR 0 2
84361: NOT
84362: OR
84363: IFFALSE 84367
// exit ;
84365: GO 84392
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
84367: LD_ADDR_EXP 96
84371: PUSH
84372: LD_EXP 96
84376: PPUSH
84377: LD_VAR 0 1
84381: PPUSH
84382: LD_VAR 0 2
84386: PPUSH
84387: CALL_OW 1
84391: ST_TO_ADDR
// end ;
84392: LD_VAR 0 3
84396: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
84397: LD_INT 0
84399: PPUSH
84400: PPUSH
84401: PPUSH
// if not mc_bases or not base or not ext_list then
84402: LD_EXP 61
84406: NOT
84407: PUSH
84408: LD_VAR 0 1
84412: NOT
84413: OR
84414: PUSH
84415: LD_VAR 0 5
84419: NOT
84420: OR
84421: IFFALSE 84425
// exit ;
84423: GO 84598
// tmp := GetFacExtXYD ( x , y , d ) ;
84425: LD_ADDR_VAR 0 8
84429: PUSH
84430: LD_VAR 0 2
84434: PPUSH
84435: LD_VAR 0 3
84439: PPUSH
84440: LD_VAR 0 4
84444: PPUSH
84445: CALL 51770 0 3
84449: ST_TO_ADDR
// if not tmp then
84450: LD_VAR 0 8
84454: NOT
84455: IFFALSE 84459
// exit ;
84457: GO 84598
// for i in tmp do
84459: LD_ADDR_VAR 0 7
84463: PUSH
84464: LD_VAR 0 8
84468: PUSH
84469: FOR_IN
84470: IFFALSE 84596
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
84472: LD_ADDR_EXP 66
84476: PUSH
84477: LD_EXP 66
84481: PPUSH
84482: LD_VAR 0 1
84486: PPUSH
84487: LD_EXP 66
84491: PUSH
84492: LD_VAR 0 1
84496: ARRAY
84497: PPUSH
84498: LD_EXP 66
84502: PUSH
84503: LD_VAR 0 1
84507: ARRAY
84508: PUSH
84509: LD_INT 1
84511: PLUS
84512: PPUSH
84513: LD_VAR 0 5
84517: PUSH
84518: LD_INT 1
84520: ARRAY
84521: PUSH
84522: LD_VAR 0 7
84526: PUSH
84527: LD_INT 1
84529: ARRAY
84530: PUSH
84531: LD_VAR 0 7
84535: PUSH
84536: LD_INT 2
84538: ARRAY
84539: PUSH
84540: LD_VAR 0 7
84544: PUSH
84545: LD_INT 3
84547: ARRAY
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: PPUSH
84555: CALL_OW 2
84559: PPUSH
84560: CALL_OW 1
84564: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
84565: LD_ADDR_VAR 0 5
84569: PUSH
84570: LD_VAR 0 5
84574: PPUSH
84575: LD_INT 1
84577: PPUSH
84578: CALL_OW 3
84582: ST_TO_ADDR
// if not ext_list then
84583: LD_VAR 0 5
84587: NOT
84588: IFFALSE 84594
// exit ;
84590: POP
84591: POP
84592: GO 84598
// end ;
84594: GO 84469
84596: POP
84597: POP
// end ;
84598: LD_VAR 0 6
84602: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
84603: LD_INT 0
84605: PPUSH
// if not mc_bases or not base or not weapon_list then
84606: LD_EXP 61
84610: NOT
84611: PUSH
84612: LD_VAR 0 1
84616: NOT
84617: OR
84618: PUSH
84619: LD_VAR 0 2
84623: NOT
84624: OR
84625: IFFALSE 84629
// exit ;
84627: GO 84654
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
84629: LD_ADDR_EXP 100
84633: PUSH
84634: LD_EXP 100
84638: PPUSH
84639: LD_VAR 0 1
84643: PPUSH
84644: LD_VAR 0 2
84648: PPUSH
84649: CALL_OW 1
84653: ST_TO_ADDR
// end ;
84654: LD_VAR 0 3
84658: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
84659: LD_INT 0
84661: PPUSH
// if not mc_bases or not base or not tech_list then
84662: LD_EXP 61
84666: NOT
84667: PUSH
84668: LD_VAR 0 1
84672: NOT
84673: OR
84674: PUSH
84675: LD_VAR 0 2
84679: NOT
84680: OR
84681: IFFALSE 84685
// exit ;
84683: GO 84710
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
84685: LD_ADDR_EXP 88
84689: PUSH
84690: LD_EXP 88
84694: PPUSH
84695: LD_VAR 0 1
84699: PPUSH
84700: LD_VAR 0 2
84704: PPUSH
84705: CALL_OW 1
84709: ST_TO_ADDR
// end ;
84710: LD_VAR 0 3
84714: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
84715: LD_INT 0
84717: PPUSH
// if not mc_bases or not parking_area or not base then
84718: LD_EXP 61
84722: NOT
84723: PUSH
84724: LD_VAR 0 2
84728: NOT
84729: OR
84730: PUSH
84731: LD_VAR 0 1
84735: NOT
84736: OR
84737: IFFALSE 84741
// exit ;
84739: GO 84766
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
84741: LD_ADDR_EXP 85
84745: PUSH
84746: LD_EXP 85
84750: PPUSH
84751: LD_VAR 0 1
84755: PPUSH
84756: LD_VAR 0 2
84760: PPUSH
84761: CALL_OW 1
84765: ST_TO_ADDR
// end ;
84766: LD_VAR 0 3
84770: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
84771: LD_INT 0
84773: PPUSH
// if not mc_bases or not base or not scan_area then
84774: LD_EXP 61
84778: NOT
84779: PUSH
84780: LD_VAR 0 1
84784: NOT
84785: OR
84786: PUSH
84787: LD_VAR 0 2
84791: NOT
84792: OR
84793: IFFALSE 84797
// exit ;
84795: GO 84822
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
84797: LD_ADDR_EXP 86
84801: PUSH
84802: LD_EXP 86
84806: PPUSH
84807: LD_VAR 0 1
84811: PPUSH
84812: LD_VAR 0 2
84816: PPUSH
84817: CALL_OW 1
84821: ST_TO_ADDR
// end ;
84822: LD_VAR 0 3
84826: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
84827: LD_INT 0
84829: PPUSH
84830: PPUSH
// if not mc_bases or not base then
84831: LD_EXP 61
84835: NOT
84836: PUSH
84837: LD_VAR 0 1
84841: NOT
84842: OR
84843: IFFALSE 84847
// exit ;
84845: GO 84911
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
84847: LD_ADDR_VAR 0 3
84851: PUSH
84852: LD_INT 1
84854: PUSH
84855: LD_INT 2
84857: PUSH
84858: LD_INT 3
84860: PUSH
84861: LD_INT 4
84863: PUSH
84864: LD_INT 11
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
84874: LD_ADDR_EXP 88
84878: PUSH
84879: LD_EXP 88
84883: PPUSH
84884: LD_VAR 0 1
84888: PPUSH
84889: LD_EXP 88
84893: PUSH
84894: LD_VAR 0 1
84898: ARRAY
84899: PUSH
84900: LD_VAR 0 3
84904: DIFF
84905: PPUSH
84906: CALL_OW 1
84910: ST_TO_ADDR
// end ;
84911: LD_VAR 0 2
84915: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
84916: LD_INT 0
84918: PPUSH
// result := mc_vehicles [ base ] ;
84919: LD_ADDR_VAR 0 3
84923: PUSH
84924: LD_EXP 80
84928: PUSH
84929: LD_VAR 0 1
84933: ARRAY
84934: ST_TO_ADDR
// if onlyCombat then
84935: LD_VAR 0 2
84939: IFFALSE 85111
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
84941: LD_ADDR_VAR 0 3
84945: PUSH
84946: LD_VAR 0 3
84950: PUSH
84951: LD_VAR 0 3
84955: PPUSH
84956: LD_INT 2
84958: PUSH
84959: LD_INT 34
84961: PUSH
84962: LD_INT 12
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 34
84971: PUSH
84972: LD_INT 51
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 34
84981: PUSH
84982: LD_INT 89
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 34
84991: PUSH
84992: LD_INT 32
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 34
85001: PUSH
85002: LD_INT 13
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 34
85011: PUSH
85012: LD_INT 52
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 34
85021: PUSH
85022: LD_INT 88
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 34
85031: PUSH
85032: LD_INT 14
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 34
85041: PUSH
85042: LD_INT 53
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 34
85051: PUSH
85052: LD_INT 98
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 34
85061: PUSH
85062: LD_INT 31
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 34
85071: PUSH
85072: LD_INT 48
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 34
85081: PUSH
85082: LD_INT 8
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: PPUSH
85105: CALL_OW 72
85109: DIFF
85110: ST_TO_ADDR
// end ; end_of_file
85111: LD_VAR 0 3
85115: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85116: LD_INT 0
85118: PPUSH
85119: PPUSH
85120: PPUSH
// if not mc_bases or not skirmish then
85121: LD_EXP 61
85125: NOT
85126: PUSH
85127: LD_EXP 59
85131: NOT
85132: OR
85133: IFFALSE 85137
// exit ;
85135: GO 85302
// for i = 1 to mc_bases do
85137: LD_ADDR_VAR 0 4
85141: PUSH
85142: DOUBLE
85143: LD_INT 1
85145: DEC
85146: ST_TO_ADDR
85147: LD_EXP 61
85151: PUSH
85152: FOR_TO
85153: IFFALSE 85300
// begin if sci in mc_bases [ i ] then
85155: LD_VAR 0 2
85159: PUSH
85160: LD_EXP 61
85164: PUSH
85165: LD_VAR 0 4
85169: ARRAY
85170: IN
85171: IFFALSE 85298
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
85173: LD_ADDR_EXP 90
85177: PUSH
85178: LD_EXP 90
85182: PPUSH
85183: LD_VAR 0 4
85187: PUSH
85188: LD_EXP 90
85192: PUSH
85193: LD_VAR 0 4
85197: ARRAY
85198: PUSH
85199: LD_INT 1
85201: PLUS
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PPUSH
85207: LD_VAR 0 1
85211: PPUSH
85212: CALL 21407 0 3
85216: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
85217: LD_ADDR_VAR 0 5
85221: PUSH
85222: LD_EXP 61
85226: PUSH
85227: LD_VAR 0 4
85231: ARRAY
85232: PPUSH
85233: LD_INT 2
85235: PUSH
85236: LD_INT 30
85238: PUSH
85239: LD_INT 0
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 30
85248: PUSH
85249: LD_INT 1
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: LIST
85260: PPUSH
85261: CALL_OW 72
85265: PPUSH
85266: LD_VAR 0 1
85270: PPUSH
85271: CALL_OW 74
85275: ST_TO_ADDR
// if tmp then
85276: LD_VAR 0 5
85280: IFFALSE 85296
// ComStandNearbyBuilding ( ape , tmp ) ;
85282: LD_VAR 0 1
85286: PPUSH
85287: LD_VAR 0 5
85291: PPUSH
85292: CALL 18009 0 2
// break ;
85296: GO 85300
// end ; end ;
85298: GO 85152
85300: POP
85301: POP
// end ;
85302: LD_VAR 0 3
85306: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
85307: LD_INT 0
85309: PPUSH
85310: PPUSH
85311: PPUSH
// if not mc_bases or not skirmish then
85312: LD_EXP 61
85316: NOT
85317: PUSH
85318: LD_EXP 59
85322: NOT
85323: OR
85324: IFFALSE 85328
// exit ;
85326: GO 85417
// for i = 1 to mc_bases do
85328: LD_ADDR_VAR 0 4
85332: PUSH
85333: DOUBLE
85334: LD_INT 1
85336: DEC
85337: ST_TO_ADDR
85338: LD_EXP 61
85342: PUSH
85343: FOR_TO
85344: IFFALSE 85415
// begin if building in mc_busy_turret_list [ i ] then
85346: LD_VAR 0 1
85350: PUSH
85351: LD_EXP 71
85355: PUSH
85356: LD_VAR 0 4
85360: ARRAY
85361: IN
85362: IFFALSE 85413
// begin tmp := mc_busy_turret_list [ i ] diff building ;
85364: LD_ADDR_VAR 0 5
85368: PUSH
85369: LD_EXP 71
85373: PUSH
85374: LD_VAR 0 4
85378: ARRAY
85379: PUSH
85380: LD_VAR 0 1
85384: DIFF
85385: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
85386: LD_ADDR_EXP 71
85390: PUSH
85391: LD_EXP 71
85395: PPUSH
85396: LD_VAR 0 4
85400: PPUSH
85401: LD_VAR 0 5
85405: PPUSH
85406: CALL_OW 1
85410: ST_TO_ADDR
// break ;
85411: GO 85415
// end ; end ;
85413: GO 85343
85415: POP
85416: POP
// end ;
85417: LD_VAR 0 3
85421: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
85422: LD_INT 0
85424: PPUSH
85425: PPUSH
85426: PPUSH
// if not mc_bases or not skirmish then
85427: LD_EXP 61
85431: NOT
85432: PUSH
85433: LD_EXP 59
85437: NOT
85438: OR
85439: IFFALSE 85443
// exit ;
85441: GO 85642
// for i = 1 to mc_bases do
85443: LD_ADDR_VAR 0 5
85447: PUSH
85448: DOUBLE
85449: LD_INT 1
85451: DEC
85452: ST_TO_ADDR
85453: LD_EXP 61
85457: PUSH
85458: FOR_TO
85459: IFFALSE 85640
// if building in mc_bases [ i ] then
85461: LD_VAR 0 1
85465: PUSH
85466: LD_EXP 61
85470: PUSH
85471: LD_VAR 0 5
85475: ARRAY
85476: IN
85477: IFFALSE 85638
// begin tmp := mc_bases [ i ] diff building ;
85479: LD_ADDR_VAR 0 6
85483: PUSH
85484: LD_EXP 61
85488: PUSH
85489: LD_VAR 0 5
85493: ARRAY
85494: PUSH
85495: LD_VAR 0 1
85499: DIFF
85500: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
85501: LD_ADDR_EXP 61
85505: PUSH
85506: LD_EXP 61
85510: PPUSH
85511: LD_VAR 0 5
85515: PPUSH
85516: LD_VAR 0 6
85520: PPUSH
85521: CALL_OW 1
85525: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
85526: LD_VAR 0 1
85530: PUSH
85531: LD_EXP 69
85535: PUSH
85536: LD_VAR 0 5
85540: ARRAY
85541: IN
85542: IFFALSE 85581
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
85544: LD_ADDR_EXP 69
85548: PUSH
85549: LD_EXP 69
85553: PPUSH
85554: LD_VAR 0 5
85558: PPUSH
85559: LD_EXP 69
85563: PUSH
85564: LD_VAR 0 5
85568: ARRAY
85569: PUSH
85570: LD_VAR 0 1
85574: DIFF
85575: PPUSH
85576: CALL_OW 1
85580: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
85581: LD_VAR 0 1
85585: PUSH
85586: LD_EXP 70
85590: PUSH
85591: LD_VAR 0 5
85595: ARRAY
85596: IN
85597: IFFALSE 85636
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
85599: LD_ADDR_EXP 70
85603: PUSH
85604: LD_EXP 70
85608: PPUSH
85609: LD_VAR 0 5
85613: PPUSH
85614: LD_EXP 70
85618: PUSH
85619: LD_VAR 0 5
85623: ARRAY
85624: PUSH
85625: LD_VAR 0 1
85629: DIFF
85630: PPUSH
85631: CALL_OW 1
85635: ST_TO_ADDR
// break ;
85636: GO 85640
// end ;
85638: GO 85458
85640: POP
85641: POP
// end ;
85642: LD_VAR 0 4
85646: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
85647: LD_INT 0
85649: PPUSH
85650: PPUSH
85651: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
85652: LD_EXP 61
85656: NOT
85657: PUSH
85658: LD_EXP 59
85662: NOT
85663: OR
85664: PUSH
85665: LD_VAR 0 3
85669: PUSH
85670: LD_EXP 87
85674: IN
85675: NOT
85676: OR
85677: IFFALSE 85681
// exit ;
85679: GO 85804
// for i = 1 to mc_vehicles do
85681: LD_ADDR_VAR 0 6
85685: PUSH
85686: DOUBLE
85687: LD_INT 1
85689: DEC
85690: ST_TO_ADDR
85691: LD_EXP 80
85695: PUSH
85696: FOR_TO
85697: IFFALSE 85802
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
85699: LD_VAR 0 2
85703: PUSH
85704: LD_EXP 80
85708: PUSH
85709: LD_VAR 0 6
85713: ARRAY
85714: IN
85715: PUSH
85716: LD_VAR 0 1
85720: PUSH
85721: LD_EXP 80
85725: PUSH
85726: LD_VAR 0 6
85730: ARRAY
85731: IN
85732: OR
85733: IFFALSE 85800
// begin tmp := mc_vehicles [ i ] diff old ;
85735: LD_ADDR_VAR 0 7
85739: PUSH
85740: LD_EXP 80
85744: PUSH
85745: LD_VAR 0 6
85749: ARRAY
85750: PUSH
85751: LD_VAR 0 2
85755: DIFF
85756: ST_TO_ADDR
// tmp := tmp diff new ;
85757: LD_ADDR_VAR 0 7
85761: PUSH
85762: LD_VAR 0 7
85766: PUSH
85767: LD_VAR 0 1
85771: DIFF
85772: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
85773: LD_ADDR_EXP 80
85777: PUSH
85778: LD_EXP 80
85782: PPUSH
85783: LD_VAR 0 6
85787: PPUSH
85788: LD_VAR 0 7
85792: PPUSH
85793: CALL_OW 1
85797: ST_TO_ADDR
// break ;
85798: GO 85802
// end ;
85800: GO 85696
85802: POP
85803: POP
// end ;
85804: LD_VAR 0 5
85808: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
85809: LD_INT 0
85811: PPUSH
85812: PPUSH
85813: PPUSH
85814: PPUSH
// if not mc_bases or not skirmish then
85815: LD_EXP 61
85819: NOT
85820: PUSH
85821: LD_EXP 59
85825: NOT
85826: OR
85827: IFFALSE 85831
// exit ;
85829: GO 86251
// repeat wait ( 0 0$1 ) ;
85831: LD_INT 35
85833: PPUSH
85834: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
85838: LD_EXP 105
85842: NOT
85843: IFFALSE 85831
// mc_block_vehicle_constructed_thread := true ;
85845: LD_ADDR_EXP 105
85849: PUSH
85850: LD_INT 1
85852: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
85853: LD_ADDR_VAR 0 5
85857: PUSH
85858: LD_VAR 0 1
85862: PPUSH
85863: CALL_OW 255
85867: ST_TO_ADDR
// for i = 1 to mc_bases do
85868: LD_ADDR_VAR 0 4
85872: PUSH
85873: DOUBLE
85874: LD_INT 1
85876: DEC
85877: ST_TO_ADDR
85878: LD_EXP 61
85882: PUSH
85883: FOR_TO
85884: IFFALSE 86241
// begin if factory in mc_bases [ i ] then
85886: LD_VAR 0 2
85890: PUSH
85891: LD_EXP 61
85895: PUSH
85896: LD_VAR 0 4
85900: ARRAY
85901: IN
85902: IFFALSE 86239
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
85904: LD_EXP 83
85908: PUSH
85909: LD_VAR 0 4
85913: ARRAY
85914: PUSH
85915: LD_EXP 72
85919: PUSH
85920: LD_VAR 0 4
85924: ARRAY
85925: LESS
85926: PUSH
85927: LD_VAR 0 1
85931: PPUSH
85932: CALL_OW 264
85936: PUSH
85937: LD_INT 31
85939: PUSH
85940: LD_INT 32
85942: PUSH
85943: LD_INT 51
85945: PUSH
85946: LD_INT 89
85948: PUSH
85949: LD_INT 12
85951: PUSH
85952: LD_INT 30
85954: PUSH
85955: LD_INT 98
85957: PUSH
85958: LD_INT 11
85960: PUSH
85961: LD_INT 53
85963: PUSH
85964: LD_INT 14
85966: PUSH
85967: LD_INT 91
85969: PUSH
85970: LD_INT 29
85972: PUSH
85973: LD_INT 99
85975: PUSH
85976: LD_INT 13
85978: PUSH
85979: LD_INT 52
85981: PUSH
85982: LD_INT 88
85984: PUSH
85985: LD_INT 48
85987: PUSH
85988: LD_INT 8
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: IN
86011: NOT
86012: AND
86013: IFFALSE 86061
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86015: LD_ADDR_EXP 83
86019: PUSH
86020: LD_EXP 83
86024: PPUSH
86025: LD_VAR 0 4
86029: PUSH
86030: LD_EXP 83
86034: PUSH
86035: LD_VAR 0 4
86039: ARRAY
86040: PUSH
86041: LD_INT 1
86043: PLUS
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PPUSH
86049: LD_VAR 0 1
86053: PPUSH
86054: CALL 21407 0 3
86058: ST_TO_ADDR
86059: GO 86105
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86061: LD_ADDR_EXP 80
86065: PUSH
86066: LD_EXP 80
86070: PPUSH
86071: LD_VAR 0 4
86075: PUSH
86076: LD_EXP 80
86080: PUSH
86081: LD_VAR 0 4
86085: ARRAY
86086: PUSH
86087: LD_INT 1
86089: PLUS
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PPUSH
86095: LD_VAR 0 1
86099: PPUSH
86100: CALL 21407 0 3
86104: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
86105: LD_ADDR_EXP 105
86109: PUSH
86110: LD_INT 0
86112: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86113: LD_VAR 0 1
86117: PPUSH
86118: CALL_OW 263
86122: PUSH
86123: LD_INT 2
86125: EQUAL
86126: IFFALSE 86155
// begin repeat wait ( 0 0$3 ) ;
86128: LD_INT 105
86130: PPUSH
86131: CALL_OW 67
// Connect ( vehicle ) ;
86135: LD_VAR 0 1
86139: PPUSH
86140: CALL 24753 0 1
// until IsControledBy ( vehicle ) ;
86144: LD_VAR 0 1
86148: PPUSH
86149: CALL_OW 312
86153: IFFALSE 86128
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
86155: LD_VAR 0 1
86159: PPUSH
86160: LD_EXP 85
86164: PUSH
86165: LD_VAR 0 4
86169: ARRAY
86170: PPUSH
86171: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
86175: LD_VAR 0 1
86179: PPUSH
86180: CALL_OW 263
86184: PUSH
86185: LD_INT 1
86187: NONEQUAL
86188: IFFALSE 86192
// break ;
86190: GO 86241
// repeat wait ( 0 0$1 ) ;
86192: LD_INT 35
86194: PPUSH
86195: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
86199: LD_VAR 0 1
86203: PPUSH
86204: LD_EXP 85
86208: PUSH
86209: LD_VAR 0 4
86213: ARRAY
86214: PPUSH
86215: CALL_OW 308
86219: IFFALSE 86192
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
86221: LD_VAR 0 1
86225: PPUSH
86226: CALL_OW 311
86230: PPUSH
86231: CALL_OW 121
// exit ;
86235: POP
86236: POP
86237: GO 86251
// end ; end ;
86239: GO 85883
86241: POP
86242: POP
// mc_block_vehicle_constructed_thread := false ;
86243: LD_ADDR_EXP 105
86247: PUSH
86248: LD_INT 0
86250: ST_TO_ADDR
// end ;
86251: LD_VAR 0 3
86255: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
86256: LD_INT 0
86258: PPUSH
86259: PPUSH
86260: PPUSH
86261: PPUSH
// if not mc_bases or not skirmish then
86262: LD_EXP 61
86266: NOT
86267: PUSH
86268: LD_EXP 59
86272: NOT
86273: OR
86274: IFFALSE 86278
// exit ;
86276: GO 86631
// repeat wait ( 0 0$1 ) ;
86278: LD_INT 35
86280: PPUSH
86281: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
86285: LD_VAR 0 2
86289: PPUSH
86290: LD_VAR 0 3
86294: PPUSH
86295: CALL_OW 284
86299: IFFALSE 86278
// if GetResourceTypeXY ( x , y ) = mat_artefact then
86301: LD_VAR 0 2
86305: PPUSH
86306: LD_VAR 0 3
86310: PPUSH
86311: CALL_OW 283
86315: PUSH
86316: LD_INT 4
86318: EQUAL
86319: IFFALSE 86323
// exit ;
86321: GO 86631
// for i = 1 to mc_bases do
86323: LD_ADDR_VAR 0 7
86327: PUSH
86328: DOUBLE
86329: LD_INT 1
86331: DEC
86332: ST_TO_ADDR
86333: LD_EXP 61
86337: PUSH
86338: FOR_TO
86339: IFFALSE 86629
// begin if mc_crates_area [ i ] then
86341: LD_EXP 79
86345: PUSH
86346: LD_VAR 0 7
86350: ARRAY
86351: IFFALSE 86462
// for j in mc_crates_area [ i ] do
86353: LD_ADDR_VAR 0 8
86357: PUSH
86358: LD_EXP 79
86362: PUSH
86363: LD_VAR 0 7
86367: ARRAY
86368: PUSH
86369: FOR_IN
86370: IFFALSE 86460
// if InArea ( x , y , j ) then
86372: LD_VAR 0 2
86376: PPUSH
86377: LD_VAR 0 3
86381: PPUSH
86382: LD_VAR 0 8
86386: PPUSH
86387: CALL_OW 309
86391: IFFALSE 86458
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86393: LD_ADDR_EXP 77
86397: PUSH
86398: LD_EXP 77
86402: PPUSH
86403: LD_VAR 0 7
86407: PUSH
86408: LD_EXP 77
86412: PUSH
86413: LD_VAR 0 7
86417: ARRAY
86418: PUSH
86419: LD_INT 1
86421: PLUS
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PPUSH
86427: LD_VAR 0 4
86431: PUSH
86432: LD_VAR 0 2
86436: PUSH
86437: LD_VAR 0 3
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: LIST
86446: PPUSH
86447: CALL 21407 0 3
86451: ST_TO_ADDR
// exit ;
86452: POP
86453: POP
86454: POP
86455: POP
86456: GO 86631
// end ;
86458: GO 86369
86460: POP
86461: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86462: LD_ADDR_VAR 0 9
86466: PUSH
86467: LD_EXP 61
86471: PUSH
86472: LD_VAR 0 7
86476: ARRAY
86477: PPUSH
86478: LD_INT 2
86480: PUSH
86481: LD_INT 30
86483: PUSH
86484: LD_INT 0
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 30
86493: PUSH
86494: LD_INT 1
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: LIST
86505: PPUSH
86506: CALL_OW 72
86510: ST_TO_ADDR
// if not depot then
86511: LD_VAR 0 9
86515: NOT
86516: IFFALSE 86520
// continue ;
86518: GO 86338
// for j in depot do
86520: LD_ADDR_VAR 0 8
86524: PUSH
86525: LD_VAR 0 9
86529: PUSH
86530: FOR_IN
86531: IFFALSE 86625
// if GetDistUnitXY ( j , x , y ) < 30 then
86533: LD_VAR 0 8
86537: PPUSH
86538: LD_VAR 0 2
86542: PPUSH
86543: LD_VAR 0 3
86547: PPUSH
86548: CALL_OW 297
86552: PUSH
86553: LD_INT 30
86555: LESS
86556: IFFALSE 86623
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
86558: LD_ADDR_EXP 77
86562: PUSH
86563: LD_EXP 77
86567: PPUSH
86568: LD_VAR 0 7
86572: PUSH
86573: LD_EXP 77
86577: PUSH
86578: LD_VAR 0 7
86582: ARRAY
86583: PUSH
86584: LD_INT 1
86586: PLUS
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PPUSH
86592: LD_VAR 0 4
86596: PUSH
86597: LD_VAR 0 2
86601: PUSH
86602: LD_VAR 0 3
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: LIST
86611: PPUSH
86612: CALL 21407 0 3
86616: ST_TO_ADDR
// exit ;
86617: POP
86618: POP
86619: POP
86620: POP
86621: GO 86631
// end ;
86623: GO 86530
86625: POP
86626: POP
// end ;
86627: GO 86338
86629: POP
86630: POP
// end ;
86631: LD_VAR 0 6
86635: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
86636: LD_INT 0
86638: PPUSH
86639: PPUSH
86640: PPUSH
86641: PPUSH
// if not mc_bases or not skirmish then
86642: LD_EXP 61
86646: NOT
86647: PUSH
86648: LD_EXP 59
86652: NOT
86653: OR
86654: IFFALSE 86658
// exit ;
86656: GO 86935
// side := GetSide ( lab ) ;
86658: LD_ADDR_VAR 0 4
86662: PUSH
86663: LD_VAR 0 2
86667: PPUSH
86668: CALL_OW 255
86672: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
86673: LD_VAR 0 4
86677: PUSH
86678: LD_EXP 87
86682: IN
86683: NOT
86684: PUSH
86685: LD_EXP 88
86689: NOT
86690: OR
86691: PUSH
86692: LD_EXP 61
86696: NOT
86697: OR
86698: IFFALSE 86702
// exit ;
86700: GO 86935
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
86702: LD_ADDR_EXP 88
86706: PUSH
86707: LD_EXP 88
86711: PPUSH
86712: LD_VAR 0 4
86716: PPUSH
86717: LD_EXP 88
86721: PUSH
86722: LD_VAR 0 4
86726: ARRAY
86727: PUSH
86728: LD_VAR 0 1
86732: DIFF
86733: PPUSH
86734: CALL_OW 1
86738: ST_TO_ADDR
// for i = 1 to mc_bases do
86739: LD_ADDR_VAR 0 5
86743: PUSH
86744: DOUBLE
86745: LD_INT 1
86747: DEC
86748: ST_TO_ADDR
86749: LD_EXP 61
86753: PUSH
86754: FOR_TO
86755: IFFALSE 86933
// begin if lab in mc_bases [ i ] then
86757: LD_VAR 0 2
86761: PUSH
86762: LD_EXP 61
86766: PUSH
86767: LD_VAR 0 5
86771: ARRAY
86772: IN
86773: IFFALSE 86931
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
86775: LD_VAR 0 1
86779: PUSH
86780: LD_INT 11
86782: PUSH
86783: LD_INT 4
86785: PUSH
86786: LD_INT 3
86788: PUSH
86789: LD_INT 2
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: IN
86798: PUSH
86799: LD_EXP 91
86803: PUSH
86804: LD_VAR 0 5
86808: ARRAY
86809: AND
86810: IFFALSE 86931
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
86812: LD_ADDR_VAR 0 6
86816: PUSH
86817: LD_EXP 91
86821: PUSH
86822: LD_VAR 0 5
86826: ARRAY
86827: PUSH
86828: LD_INT 1
86830: ARRAY
86831: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86832: LD_ADDR_EXP 91
86836: PUSH
86837: LD_EXP 91
86841: PPUSH
86842: LD_VAR 0 5
86846: PPUSH
86847: EMPTY
86848: PPUSH
86849: CALL_OW 1
86853: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
86854: LD_VAR 0 6
86858: PPUSH
86859: LD_INT 0
86861: PPUSH
86862: CALL_OW 109
// ComExitBuilding ( tmp ) ;
86866: LD_VAR 0 6
86870: PPUSH
86871: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
86875: LD_ADDR_EXP 90
86879: PUSH
86880: LD_EXP 90
86884: PPUSH
86885: LD_VAR 0 5
86889: PPUSH
86890: LD_EXP 90
86894: PUSH
86895: LD_VAR 0 5
86899: ARRAY
86900: PPUSH
86901: LD_INT 1
86903: PPUSH
86904: LD_VAR 0 6
86908: PPUSH
86909: CALL_OW 2
86913: PPUSH
86914: CALL_OW 1
86918: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
86919: LD_VAR 0 5
86923: PPUSH
86924: LD_INT 112
86926: PPUSH
86927: CALL 63385 0 2
// end ; end ; end ;
86931: GO 86754
86933: POP
86934: POP
// end ;
86935: LD_VAR 0 3
86939: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
86940: LD_INT 0
86942: PPUSH
86943: PPUSH
86944: PPUSH
86945: PPUSH
86946: PPUSH
86947: PPUSH
86948: PPUSH
86949: PPUSH
// if not mc_bases or not skirmish then
86950: LD_EXP 61
86954: NOT
86955: PUSH
86956: LD_EXP 59
86960: NOT
86961: OR
86962: IFFALSE 86966
// exit ;
86964: GO 88335
// for i = 1 to mc_bases do
86966: LD_ADDR_VAR 0 3
86970: PUSH
86971: DOUBLE
86972: LD_INT 1
86974: DEC
86975: ST_TO_ADDR
86976: LD_EXP 61
86980: PUSH
86981: FOR_TO
86982: IFFALSE 88333
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
86984: LD_VAR 0 1
86988: PUSH
86989: LD_EXP 61
86993: PUSH
86994: LD_VAR 0 3
86998: ARRAY
86999: IN
87000: PUSH
87001: LD_VAR 0 1
87005: PUSH
87006: LD_EXP 68
87010: PUSH
87011: LD_VAR 0 3
87015: ARRAY
87016: IN
87017: OR
87018: PUSH
87019: LD_VAR 0 1
87023: PUSH
87024: LD_EXP 83
87028: PUSH
87029: LD_VAR 0 3
87033: ARRAY
87034: IN
87035: OR
87036: PUSH
87037: LD_VAR 0 1
87041: PUSH
87042: LD_EXP 80
87046: PUSH
87047: LD_VAR 0 3
87051: ARRAY
87052: IN
87053: OR
87054: PUSH
87055: LD_VAR 0 1
87059: PUSH
87060: LD_EXP 90
87064: PUSH
87065: LD_VAR 0 3
87069: ARRAY
87070: IN
87071: OR
87072: PUSH
87073: LD_VAR 0 1
87077: PUSH
87078: LD_EXP 91
87082: PUSH
87083: LD_VAR 0 3
87087: ARRAY
87088: IN
87089: OR
87090: IFFALSE 88331
// begin if un in mc_ape [ i ] then
87092: LD_VAR 0 1
87096: PUSH
87097: LD_EXP 90
87101: PUSH
87102: LD_VAR 0 3
87106: ARRAY
87107: IN
87108: IFFALSE 87147
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87110: LD_ADDR_EXP 90
87114: PUSH
87115: LD_EXP 90
87119: PPUSH
87120: LD_VAR 0 3
87124: PPUSH
87125: LD_EXP 90
87129: PUSH
87130: LD_VAR 0 3
87134: ARRAY
87135: PUSH
87136: LD_VAR 0 1
87140: DIFF
87141: PPUSH
87142: CALL_OW 1
87146: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
87147: LD_VAR 0 1
87151: PUSH
87152: LD_EXP 91
87156: PUSH
87157: LD_VAR 0 3
87161: ARRAY
87162: IN
87163: IFFALSE 87187
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87165: LD_ADDR_EXP 91
87169: PUSH
87170: LD_EXP 91
87174: PPUSH
87175: LD_VAR 0 3
87179: PPUSH
87180: EMPTY
87181: PPUSH
87182: CALL_OW 1
87186: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
87187: LD_VAR 0 1
87191: PPUSH
87192: CALL_OW 247
87196: PUSH
87197: LD_INT 2
87199: EQUAL
87200: PUSH
87201: LD_VAR 0 1
87205: PPUSH
87206: CALL_OW 110
87210: PUSH
87211: LD_INT 20
87213: EQUAL
87214: PUSH
87215: LD_VAR 0 1
87219: PUSH
87220: LD_EXP 83
87224: PUSH
87225: LD_VAR 0 3
87229: ARRAY
87230: IN
87231: OR
87232: PUSH
87233: LD_VAR 0 1
87237: PPUSH
87238: CALL_OW 264
87242: PUSH
87243: LD_INT 12
87245: PUSH
87246: LD_INT 51
87248: PUSH
87249: LD_INT 89
87251: PUSH
87252: LD_INT 32
87254: PUSH
87255: LD_INT 13
87257: PUSH
87258: LD_INT 52
87260: PUSH
87261: LD_INT 31
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: IN
87273: OR
87274: AND
87275: IFFALSE 87583
// begin if un in mc_defender [ i ] then
87277: LD_VAR 0 1
87281: PUSH
87282: LD_EXP 83
87286: PUSH
87287: LD_VAR 0 3
87291: ARRAY
87292: IN
87293: IFFALSE 87332
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87295: LD_ADDR_EXP 83
87299: PUSH
87300: LD_EXP 83
87304: PPUSH
87305: LD_VAR 0 3
87309: PPUSH
87310: LD_EXP 83
87314: PUSH
87315: LD_VAR 0 3
87319: ARRAY
87320: PUSH
87321: LD_VAR 0 1
87325: DIFF
87326: PPUSH
87327: CALL_OW 1
87331: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
87332: LD_ADDR_VAR 0 8
87336: PUSH
87337: LD_VAR 0 3
87341: PPUSH
87342: LD_INT 3
87344: PPUSH
87345: CALL 83953 0 2
87349: ST_TO_ADDR
// if fac then
87350: LD_VAR 0 8
87354: IFFALSE 87583
// begin for j in fac do
87356: LD_ADDR_VAR 0 4
87360: PUSH
87361: LD_VAR 0 8
87365: PUSH
87366: FOR_IN
87367: IFFALSE 87581
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
87369: LD_ADDR_VAR 0 9
87373: PUSH
87374: LD_VAR 0 8
87378: PPUSH
87379: LD_VAR 0 1
87383: PPUSH
87384: CALL_OW 265
87388: PPUSH
87389: LD_VAR 0 1
87393: PPUSH
87394: CALL_OW 262
87398: PPUSH
87399: LD_VAR 0 1
87403: PPUSH
87404: CALL_OW 263
87408: PPUSH
87409: LD_VAR 0 1
87413: PPUSH
87414: CALL_OW 264
87418: PPUSH
87419: CALL 18905 0 5
87423: ST_TO_ADDR
// if components then
87424: LD_VAR 0 9
87428: IFFALSE 87579
// begin if GetWeapon ( un ) = ar_control_tower then
87430: LD_VAR 0 1
87434: PPUSH
87435: CALL_OW 264
87439: PUSH
87440: LD_INT 31
87442: EQUAL
87443: IFFALSE 87560
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
87445: LD_VAR 0 1
87449: PPUSH
87450: CALL_OW 311
87454: PPUSH
87455: LD_INT 0
87457: PPUSH
87458: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
87462: LD_ADDR_EXP 101
87466: PUSH
87467: LD_EXP 101
87471: PPUSH
87472: LD_VAR 0 3
87476: PPUSH
87477: LD_EXP 101
87481: PUSH
87482: LD_VAR 0 3
87486: ARRAY
87487: PUSH
87488: LD_VAR 0 1
87492: PPUSH
87493: CALL_OW 311
87497: DIFF
87498: PPUSH
87499: CALL_OW 1
87503: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
87504: LD_ADDR_VAR 0 7
87508: PUSH
87509: LD_EXP 82
87513: PUSH
87514: LD_VAR 0 3
87518: ARRAY
87519: PPUSH
87520: LD_INT 1
87522: PPUSH
87523: LD_VAR 0 9
87527: PPUSH
87528: CALL_OW 2
87532: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
87533: LD_ADDR_EXP 82
87537: PUSH
87538: LD_EXP 82
87542: PPUSH
87543: LD_VAR 0 3
87547: PPUSH
87548: LD_VAR 0 7
87552: PPUSH
87553: CALL_OW 1
87557: ST_TO_ADDR
// end else
87558: GO 87577
// MC_InsertProduceList ( i , [ components ] ) ;
87560: LD_VAR 0 3
87564: PPUSH
87565: LD_VAR 0 9
87569: PUSH
87570: EMPTY
87571: LIST
87572: PPUSH
87573: CALL 83498 0 2
// break ;
87577: GO 87581
// end ; end ;
87579: GO 87366
87581: POP
87582: POP
// end ; end ; if GetType ( un ) = unit_building then
87583: LD_VAR 0 1
87587: PPUSH
87588: CALL_OW 247
87592: PUSH
87593: LD_INT 3
87595: EQUAL
87596: IFFALSE 87999
// begin btype := GetBType ( un ) ;
87598: LD_ADDR_VAR 0 5
87602: PUSH
87603: LD_VAR 0 1
87607: PPUSH
87608: CALL_OW 266
87612: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
87613: LD_VAR 0 5
87617: PUSH
87618: LD_INT 29
87620: PUSH
87621: LD_INT 30
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: IN
87628: IFFALSE 87701
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
87630: LD_VAR 0 1
87634: PPUSH
87635: CALL_OW 250
87639: PPUSH
87640: LD_VAR 0 1
87644: PPUSH
87645: CALL_OW 251
87649: PPUSH
87650: LD_VAR 0 1
87654: PPUSH
87655: CALL_OW 255
87659: PPUSH
87660: CALL_OW 440
87664: NOT
87665: IFFALSE 87701
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
87667: LD_VAR 0 1
87671: PPUSH
87672: CALL_OW 250
87676: PPUSH
87677: LD_VAR 0 1
87681: PPUSH
87682: CALL_OW 251
87686: PPUSH
87687: LD_VAR 0 1
87691: PPUSH
87692: CALL_OW 255
87696: PPUSH
87697: CALL_OW 441
// end ; if btype = b_warehouse then
87701: LD_VAR 0 5
87705: PUSH
87706: LD_INT 1
87708: EQUAL
87709: IFFALSE 87727
// begin btype := b_depot ;
87711: LD_ADDR_VAR 0 5
87715: PUSH
87716: LD_INT 0
87718: ST_TO_ADDR
// pos := 1 ;
87719: LD_ADDR_VAR 0 6
87723: PUSH
87724: LD_INT 1
87726: ST_TO_ADDR
// end ; if btype = b_factory then
87727: LD_VAR 0 5
87731: PUSH
87732: LD_INT 3
87734: EQUAL
87735: IFFALSE 87753
// begin btype := b_workshop ;
87737: LD_ADDR_VAR 0 5
87741: PUSH
87742: LD_INT 2
87744: ST_TO_ADDR
// pos := 1 ;
87745: LD_ADDR_VAR 0 6
87749: PUSH
87750: LD_INT 1
87752: ST_TO_ADDR
// end ; if btype = b_barracks then
87753: LD_VAR 0 5
87757: PUSH
87758: LD_INT 5
87760: EQUAL
87761: IFFALSE 87771
// btype := b_armoury ;
87763: LD_ADDR_VAR 0 5
87767: PUSH
87768: LD_INT 4
87770: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
87771: LD_VAR 0 5
87775: PUSH
87776: LD_INT 7
87778: PUSH
87779: LD_INT 8
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: IN
87786: IFFALSE 87796
// btype := b_lab ;
87788: LD_ADDR_VAR 0 5
87792: PUSH
87793: LD_INT 6
87795: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
87796: LD_ADDR_EXP 66
87800: PUSH
87801: LD_EXP 66
87805: PPUSH
87806: LD_VAR 0 3
87810: PUSH
87811: LD_EXP 66
87815: PUSH
87816: LD_VAR 0 3
87820: ARRAY
87821: PUSH
87822: LD_INT 1
87824: PLUS
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PPUSH
87830: LD_VAR 0 5
87834: PUSH
87835: LD_VAR 0 1
87839: PPUSH
87840: CALL_OW 250
87844: PUSH
87845: LD_VAR 0 1
87849: PPUSH
87850: CALL_OW 251
87854: PUSH
87855: LD_VAR 0 1
87859: PPUSH
87860: CALL_OW 254
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: PPUSH
87871: CALL 21407 0 3
87875: ST_TO_ADDR
// if pos = 1 then
87876: LD_VAR 0 6
87880: PUSH
87881: LD_INT 1
87883: EQUAL
87884: IFFALSE 87999
// begin tmp := mc_build_list [ i ] ;
87886: LD_ADDR_VAR 0 7
87890: PUSH
87891: LD_EXP 66
87895: PUSH
87896: LD_VAR 0 3
87900: ARRAY
87901: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
87902: LD_VAR 0 7
87906: PPUSH
87907: LD_INT 2
87909: PUSH
87910: LD_INT 30
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: LD_INT 30
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: LIST
87934: PPUSH
87935: CALL_OW 72
87939: IFFALSE 87949
// pos := 2 ;
87941: LD_ADDR_VAR 0 6
87945: PUSH
87946: LD_INT 2
87948: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
87949: LD_ADDR_VAR 0 7
87953: PUSH
87954: LD_VAR 0 7
87958: PPUSH
87959: LD_VAR 0 6
87963: PPUSH
87964: LD_VAR 0 7
87968: PPUSH
87969: CALL 21733 0 3
87973: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
87974: LD_ADDR_EXP 66
87978: PUSH
87979: LD_EXP 66
87983: PPUSH
87984: LD_VAR 0 3
87988: PPUSH
87989: LD_VAR 0 7
87993: PPUSH
87994: CALL_OW 1
87998: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
87999: LD_VAR 0 1
88003: PUSH
88004: LD_EXP 61
88008: PUSH
88009: LD_VAR 0 3
88013: ARRAY
88014: IN
88015: IFFALSE 88054
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88017: LD_ADDR_EXP 61
88021: PUSH
88022: LD_EXP 61
88026: PPUSH
88027: LD_VAR 0 3
88031: PPUSH
88032: LD_EXP 61
88036: PUSH
88037: LD_VAR 0 3
88041: ARRAY
88042: PUSH
88043: LD_VAR 0 1
88047: DIFF
88048: PPUSH
88049: CALL_OW 1
88053: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88054: LD_VAR 0 1
88058: PUSH
88059: LD_EXP 68
88063: PUSH
88064: LD_VAR 0 3
88068: ARRAY
88069: IN
88070: IFFALSE 88109
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88072: LD_ADDR_EXP 68
88076: PUSH
88077: LD_EXP 68
88081: PPUSH
88082: LD_VAR 0 3
88086: PPUSH
88087: LD_EXP 68
88091: PUSH
88092: LD_VAR 0 3
88096: ARRAY
88097: PUSH
88098: LD_VAR 0 1
88102: DIFF
88103: PPUSH
88104: CALL_OW 1
88108: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88109: LD_VAR 0 1
88113: PUSH
88114: LD_EXP 80
88118: PUSH
88119: LD_VAR 0 3
88123: ARRAY
88124: IN
88125: IFFALSE 88164
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
88127: LD_ADDR_EXP 80
88131: PUSH
88132: LD_EXP 80
88136: PPUSH
88137: LD_VAR 0 3
88141: PPUSH
88142: LD_EXP 80
88146: PUSH
88147: LD_VAR 0 3
88151: ARRAY
88152: PUSH
88153: LD_VAR 0 1
88157: DIFF
88158: PPUSH
88159: CALL_OW 1
88163: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
88164: LD_VAR 0 1
88168: PUSH
88169: LD_EXP 83
88173: PUSH
88174: LD_VAR 0 3
88178: ARRAY
88179: IN
88180: IFFALSE 88219
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88182: LD_ADDR_EXP 83
88186: PUSH
88187: LD_EXP 83
88191: PPUSH
88192: LD_VAR 0 3
88196: PPUSH
88197: LD_EXP 83
88201: PUSH
88202: LD_VAR 0 3
88206: ARRAY
88207: PUSH
88208: LD_VAR 0 1
88212: DIFF
88213: PPUSH
88214: CALL_OW 1
88218: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
88219: LD_VAR 0 1
88223: PUSH
88224: LD_EXP 70
88228: PUSH
88229: LD_VAR 0 3
88233: ARRAY
88234: IN
88235: IFFALSE 88274
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
88237: LD_ADDR_EXP 70
88241: PUSH
88242: LD_EXP 70
88246: PPUSH
88247: LD_VAR 0 3
88251: PPUSH
88252: LD_EXP 70
88256: PUSH
88257: LD_VAR 0 3
88261: ARRAY
88262: PUSH
88263: LD_VAR 0 1
88267: DIFF
88268: PPUSH
88269: CALL_OW 1
88273: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
88274: LD_VAR 0 1
88278: PUSH
88279: LD_EXP 69
88283: PUSH
88284: LD_VAR 0 3
88288: ARRAY
88289: IN
88290: IFFALSE 88329
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
88292: LD_ADDR_EXP 69
88296: PUSH
88297: LD_EXP 69
88301: PPUSH
88302: LD_VAR 0 3
88306: PPUSH
88307: LD_EXP 69
88311: PUSH
88312: LD_VAR 0 3
88316: ARRAY
88317: PUSH
88318: LD_VAR 0 1
88322: DIFF
88323: PPUSH
88324: CALL_OW 1
88328: ST_TO_ADDR
// end ; break ;
88329: GO 88333
// end ;
88331: GO 86981
88333: POP
88334: POP
// end ;
88335: LD_VAR 0 2
88339: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
88340: LD_INT 0
88342: PPUSH
88343: PPUSH
88344: PPUSH
// if not mc_bases or not skirmish then
88345: LD_EXP 61
88349: NOT
88350: PUSH
88351: LD_EXP 59
88355: NOT
88356: OR
88357: IFFALSE 88361
// exit ;
88359: GO 88576
// for i = 1 to mc_bases do
88361: LD_ADDR_VAR 0 3
88365: PUSH
88366: DOUBLE
88367: LD_INT 1
88369: DEC
88370: ST_TO_ADDR
88371: LD_EXP 61
88375: PUSH
88376: FOR_TO
88377: IFFALSE 88574
// begin if building in mc_construct_list [ i ] then
88379: LD_VAR 0 1
88383: PUSH
88384: LD_EXP 68
88388: PUSH
88389: LD_VAR 0 3
88393: ARRAY
88394: IN
88395: IFFALSE 88572
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88397: LD_ADDR_EXP 68
88401: PUSH
88402: LD_EXP 68
88406: PPUSH
88407: LD_VAR 0 3
88411: PPUSH
88412: LD_EXP 68
88416: PUSH
88417: LD_VAR 0 3
88421: ARRAY
88422: PUSH
88423: LD_VAR 0 1
88427: DIFF
88428: PPUSH
88429: CALL_OW 1
88433: ST_TO_ADDR
// if building in mc_lab [ i ] then
88434: LD_VAR 0 1
88438: PUSH
88439: LD_EXP 94
88443: PUSH
88444: LD_VAR 0 3
88448: ARRAY
88449: IN
88450: IFFALSE 88505
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
88452: LD_ADDR_EXP 95
88456: PUSH
88457: LD_EXP 95
88461: PPUSH
88462: LD_VAR 0 3
88466: PPUSH
88467: LD_EXP 95
88471: PUSH
88472: LD_VAR 0 3
88476: ARRAY
88477: PPUSH
88478: LD_INT 1
88480: PPUSH
88481: LD_EXP 95
88485: PUSH
88486: LD_VAR 0 3
88490: ARRAY
88491: PPUSH
88492: LD_INT 0
88494: PPUSH
88495: CALL 20825 0 4
88499: PPUSH
88500: CALL_OW 1
88504: ST_TO_ADDR
// if not building in mc_bases [ i ] then
88505: LD_VAR 0 1
88509: PUSH
88510: LD_EXP 61
88514: PUSH
88515: LD_VAR 0 3
88519: ARRAY
88520: IN
88521: NOT
88522: IFFALSE 88568
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88524: LD_ADDR_EXP 61
88528: PUSH
88529: LD_EXP 61
88533: PPUSH
88534: LD_VAR 0 3
88538: PUSH
88539: LD_EXP 61
88543: PUSH
88544: LD_VAR 0 3
88548: ARRAY
88549: PUSH
88550: LD_INT 1
88552: PLUS
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PPUSH
88558: LD_VAR 0 1
88562: PPUSH
88563: CALL 21407 0 3
88567: ST_TO_ADDR
// exit ;
88568: POP
88569: POP
88570: GO 88576
// end ; end ;
88572: GO 88376
88574: POP
88575: POP
// end ;
88576: LD_VAR 0 2
88580: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
88581: LD_INT 0
88583: PPUSH
88584: PPUSH
88585: PPUSH
88586: PPUSH
88587: PPUSH
88588: PPUSH
88589: PPUSH
// if not mc_bases or not skirmish then
88590: LD_EXP 61
88594: NOT
88595: PUSH
88596: LD_EXP 59
88600: NOT
88601: OR
88602: IFFALSE 88606
// exit ;
88604: GO 89267
// for i = 1 to mc_bases do
88606: LD_ADDR_VAR 0 3
88610: PUSH
88611: DOUBLE
88612: LD_INT 1
88614: DEC
88615: ST_TO_ADDR
88616: LD_EXP 61
88620: PUSH
88621: FOR_TO
88622: IFFALSE 89265
// begin if building in mc_construct_list [ i ] then
88624: LD_VAR 0 1
88628: PUSH
88629: LD_EXP 68
88633: PUSH
88634: LD_VAR 0 3
88638: ARRAY
88639: IN
88640: IFFALSE 89263
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
88642: LD_ADDR_EXP 68
88646: PUSH
88647: LD_EXP 68
88651: PPUSH
88652: LD_VAR 0 3
88656: PPUSH
88657: LD_EXP 68
88661: PUSH
88662: LD_VAR 0 3
88666: ARRAY
88667: PUSH
88668: LD_VAR 0 1
88672: DIFF
88673: PPUSH
88674: CALL_OW 1
88678: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
88679: LD_ADDR_EXP 61
88683: PUSH
88684: LD_EXP 61
88688: PPUSH
88689: LD_VAR 0 3
88693: PUSH
88694: LD_EXP 61
88698: PUSH
88699: LD_VAR 0 3
88703: ARRAY
88704: PUSH
88705: LD_INT 1
88707: PLUS
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PPUSH
88713: LD_VAR 0 1
88717: PPUSH
88718: CALL 21407 0 3
88722: ST_TO_ADDR
// btype := GetBType ( building ) ;
88723: LD_ADDR_VAR 0 5
88727: PUSH
88728: LD_VAR 0 1
88732: PPUSH
88733: CALL_OW 266
88737: ST_TO_ADDR
// side := GetSide ( building ) ;
88738: LD_ADDR_VAR 0 8
88742: PUSH
88743: LD_VAR 0 1
88747: PPUSH
88748: CALL_OW 255
88752: ST_TO_ADDR
// if btype = b_lab then
88753: LD_VAR 0 5
88757: PUSH
88758: LD_INT 6
88760: EQUAL
88761: IFFALSE 88811
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
88763: LD_ADDR_EXP 94
88767: PUSH
88768: LD_EXP 94
88772: PPUSH
88773: LD_VAR 0 3
88777: PUSH
88778: LD_EXP 94
88782: PUSH
88783: LD_VAR 0 3
88787: ARRAY
88788: PUSH
88789: LD_INT 1
88791: PLUS
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PPUSH
88797: LD_VAR 0 1
88801: PPUSH
88802: CALL 21407 0 3
88806: ST_TO_ADDR
// exit ;
88807: POP
88808: POP
88809: GO 89267
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
88811: LD_VAR 0 5
88815: PUSH
88816: LD_INT 0
88818: PUSH
88819: LD_INT 2
88821: PUSH
88822: LD_INT 4
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: LIST
88829: IN
88830: IFFALSE 88954
// begin if btype = b_armoury then
88832: LD_VAR 0 5
88836: PUSH
88837: LD_INT 4
88839: EQUAL
88840: IFFALSE 88850
// btype := b_barracks ;
88842: LD_ADDR_VAR 0 5
88846: PUSH
88847: LD_INT 5
88849: ST_TO_ADDR
// if btype = b_depot then
88850: LD_VAR 0 5
88854: PUSH
88855: LD_INT 0
88857: EQUAL
88858: IFFALSE 88868
// btype := b_warehouse ;
88860: LD_ADDR_VAR 0 5
88864: PUSH
88865: LD_INT 1
88867: ST_TO_ADDR
// if btype = b_workshop then
88868: LD_VAR 0 5
88872: PUSH
88873: LD_INT 2
88875: EQUAL
88876: IFFALSE 88886
// btype := b_factory ;
88878: LD_ADDR_VAR 0 5
88882: PUSH
88883: LD_INT 3
88885: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
88886: LD_VAR 0 5
88890: PPUSH
88891: LD_VAR 0 8
88895: PPUSH
88896: CALL_OW 323
88900: PUSH
88901: LD_INT 1
88903: EQUAL
88904: IFFALSE 88950
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
88906: LD_ADDR_EXP 93
88910: PUSH
88911: LD_EXP 93
88915: PPUSH
88916: LD_VAR 0 3
88920: PUSH
88921: LD_EXP 93
88925: PUSH
88926: LD_VAR 0 3
88930: ARRAY
88931: PUSH
88932: LD_INT 1
88934: PLUS
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PPUSH
88940: LD_VAR 0 1
88944: PPUSH
88945: CALL 21407 0 3
88949: ST_TO_ADDR
// exit ;
88950: POP
88951: POP
88952: GO 89267
// end ; if btype in [ b_bunker , b_turret ] then
88954: LD_VAR 0 5
88958: PUSH
88959: LD_INT 32
88961: PUSH
88962: LD_INT 33
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: IN
88969: IFFALSE 89259
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
88971: LD_ADDR_EXP 69
88975: PUSH
88976: LD_EXP 69
88980: PPUSH
88981: LD_VAR 0 3
88985: PUSH
88986: LD_EXP 69
88990: PUSH
88991: LD_VAR 0 3
88995: ARRAY
88996: PUSH
88997: LD_INT 1
88999: PLUS
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PPUSH
89005: LD_VAR 0 1
89009: PPUSH
89010: CALL 21407 0 3
89014: ST_TO_ADDR
// if btype = b_bunker then
89015: LD_VAR 0 5
89019: PUSH
89020: LD_INT 32
89022: EQUAL
89023: IFFALSE 89259
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89025: LD_ADDR_EXP 70
89029: PUSH
89030: LD_EXP 70
89034: PPUSH
89035: LD_VAR 0 3
89039: PUSH
89040: LD_EXP 70
89044: PUSH
89045: LD_VAR 0 3
89049: ARRAY
89050: PUSH
89051: LD_INT 1
89053: PLUS
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PPUSH
89059: LD_VAR 0 1
89063: PPUSH
89064: CALL 21407 0 3
89068: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89069: LD_ADDR_VAR 0 6
89073: PUSH
89074: LD_EXP 61
89078: PUSH
89079: LD_VAR 0 3
89083: ARRAY
89084: PPUSH
89085: LD_INT 25
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 3
89097: PUSH
89098: LD_INT 54
89100: PUSH
89101: EMPTY
89102: LIST
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PPUSH
89112: CALL_OW 72
89116: ST_TO_ADDR
// if tmp then
89117: LD_VAR 0 6
89121: IFFALSE 89127
// exit ;
89123: POP
89124: POP
89125: GO 89267
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
89127: LD_ADDR_VAR 0 6
89131: PUSH
89132: LD_EXP 61
89136: PUSH
89137: LD_VAR 0 3
89141: ARRAY
89142: PPUSH
89143: LD_INT 2
89145: PUSH
89146: LD_INT 30
89148: PUSH
89149: LD_INT 4
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 30
89158: PUSH
89159: LD_INT 5
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: LIST
89170: PPUSH
89171: CALL_OW 72
89175: ST_TO_ADDR
// if not tmp then
89176: LD_VAR 0 6
89180: NOT
89181: IFFALSE 89187
// exit ;
89183: POP
89184: POP
89185: GO 89267
// for j in tmp do
89187: LD_ADDR_VAR 0 4
89191: PUSH
89192: LD_VAR 0 6
89196: PUSH
89197: FOR_IN
89198: IFFALSE 89257
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
89200: LD_ADDR_VAR 0 7
89204: PUSH
89205: LD_VAR 0 4
89209: PPUSH
89210: CALL_OW 313
89214: PPUSH
89215: LD_INT 25
89217: PUSH
89218: LD_INT 1
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PPUSH
89225: CALL_OW 72
89229: ST_TO_ADDR
// if units then
89230: LD_VAR 0 7
89234: IFFALSE 89255
// begin ComExitBuilding ( units [ 1 ] ) ;
89236: LD_VAR 0 7
89240: PUSH
89241: LD_INT 1
89243: ARRAY
89244: PPUSH
89245: CALL_OW 122
// exit ;
89249: POP
89250: POP
89251: POP
89252: POP
89253: GO 89267
// end ; end ;
89255: GO 89197
89257: POP
89258: POP
// end ; end ; exit ;
89259: POP
89260: POP
89261: GO 89267
// end ; end ;
89263: GO 88621
89265: POP
89266: POP
// end ;
89267: LD_VAR 0 2
89271: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
89272: LD_INT 0
89274: PPUSH
89275: PPUSH
89276: PPUSH
89277: PPUSH
89278: PPUSH
89279: PPUSH
89280: PPUSH
// if not mc_bases or not skirmish then
89281: LD_EXP 61
89285: NOT
89286: PUSH
89287: LD_EXP 59
89291: NOT
89292: OR
89293: IFFALSE 89297
// exit ;
89295: GO 89562
// btype := GetBType ( building ) ;
89297: LD_ADDR_VAR 0 6
89301: PUSH
89302: LD_VAR 0 1
89306: PPUSH
89307: CALL_OW 266
89311: ST_TO_ADDR
// x := GetX ( building ) ;
89312: LD_ADDR_VAR 0 7
89316: PUSH
89317: LD_VAR 0 1
89321: PPUSH
89322: CALL_OW 250
89326: ST_TO_ADDR
// y := GetY ( building ) ;
89327: LD_ADDR_VAR 0 8
89331: PUSH
89332: LD_VAR 0 1
89336: PPUSH
89337: CALL_OW 251
89341: ST_TO_ADDR
// d := GetDir ( building ) ;
89342: LD_ADDR_VAR 0 9
89346: PUSH
89347: LD_VAR 0 1
89351: PPUSH
89352: CALL_OW 254
89356: ST_TO_ADDR
// for i = 1 to mc_bases do
89357: LD_ADDR_VAR 0 4
89361: PUSH
89362: DOUBLE
89363: LD_INT 1
89365: DEC
89366: ST_TO_ADDR
89367: LD_EXP 61
89371: PUSH
89372: FOR_TO
89373: IFFALSE 89560
// begin if not mc_build_list [ i ] then
89375: LD_EXP 66
89379: PUSH
89380: LD_VAR 0 4
89384: ARRAY
89385: NOT
89386: IFFALSE 89390
// continue ;
89388: GO 89372
// for j := 1 to mc_build_list [ i ] do
89390: LD_ADDR_VAR 0 5
89394: PUSH
89395: DOUBLE
89396: LD_INT 1
89398: DEC
89399: ST_TO_ADDR
89400: LD_EXP 66
89404: PUSH
89405: LD_VAR 0 4
89409: ARRAY
89410: PUSH
89411: FOR_TO
89412: IFFALSE 89556
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
89414: LD_VAR 0 6
89418: PUSH
89419: LD_VAR 0 7
89423: PUSH
89424: LD_VAR 0 8
89428: PUSH
89429: LD_VAR 0 9
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: PPUSH
89440: LD_EXP 66
89444: PUSH
89445: LD_VAR 0 4
89449: ARRAY
89450: PUSH
89451: LD_VAR 0 5
89455: ARRAY
89456: PPUSH
89457: CALL 27964 0 2
89461: IFFALSE 89554
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
89463: LD_ADDR_EXP 66
89467: PUSH
89468: LD_EXP 66
89472: PPUSH
89473: LD_VAR 0 4
89477: PPUSH
89478: LD_EXP 66
89482: PUSH
89483: LD_VAR 0 4
89487: ARRAY
89488: PPUSH
89489: LD_VAR 0 5
89493: PPUSH
89494: CALL_OW 3
89498: PPUSH
89499: CALL_OW 1
89503: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
89504: LD_ADDR_EXP 68
89508: PUSH
89509: LD_EXP 68
89513: PPUSH
89514: LD_VAR 0 4
89518: PUSH
89519: LD_EXP 68
89523: PUSH
89524: LD_VAR 0 4
89528: ARRAY
89529: PUSH
89530: LD_INT 1
89532: PLUS
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PPUSH
89538: LD_VAR 0 1
89542: PPUSH
89543: CALL 21407 0 3
89547: ST_TO_ADDR
// exit ;
89548: POP
89549: POP
89550: POP
89551: POP
89552: GO 89562
// end ;
89554: GO 89411
89556: POP
89557: POP
// end ;
89558: GO 89372
89560: POP
89561: POP
// end ;
89562: LD_VAR 0 3
89566: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
89567: LD_INT 0
89569: PPUSH
89570: PPUSH
89571: PPUSH
// if not mc_bases or not skirmish then
89572: LD_EXP 61
89576: NOT
89577: PUSH
89578: LD_EXP 59
89582: NOT
89583: OR
89584: IFFALSE 89588
// exit ;
89586: GO 89778
// for i = 1 to mc_bases do
89588: LD_ADDR_VAR 0 4
89592: PUSH
89593: DOUBLE
89594: LD_INT 1
89596: DEC
89597: ST_TO_ADDR
89598: LD_EXP 61
89602: PUSH
89603: FOR_TO
89604: IFFALSE 89691
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
89606: LD_VAR 0 1
89610: PUSH
89611: LD_EXP 69
89615: PUSH
89616: LD_VAR 0 4
89620: ARRAY
89621: IN
89622: PUSH
89623: LD_VAR 0 1
89627: PUSH
89628: LD_EXP 70
89632: PUSH
89633: LD_VAR 0 4
89637: ARRAY
89638: IN
89639: NOT
89640: AND
89641: IFFALSE 89689
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89643: LD_ADDR_EXP 70
89647: PUSH
89648: LD_EXP 70
89652: PPUSH
89653: LD_VAR 0 4
89657: PUSH
89658: LD_EXP 70
89662: PUSH
89663: LD_VAR 0 4
89667: ARRAY
89668: PUSH
89669: LD_INT 1
89671: PLUS
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PPUSH
89677: LD_VAR 0 1
89681: PPUSH
89682: CALL 21407 0 3
89686: ST_TO_ADDR
// break ;
89687: GO 89691
// end ; end ;
89689: GO 89603
89691: POP
89692: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
89693: LD_VAR 0 1
89697: PPUSH
89698: CALL_OW 257
89702: PUSH
89703: LD_EXP 87
89707: IN
89708: PUSH
89709: LD_VAR 0 1
89713: PPUSH
89714: CALL_OW 266
89718: PUSH
89719: LD_INT 5
89721: EQUAL
89722: AND
89723: PUSH
89724: LD_VAR 0 2
89728: PPUSH
89729: CALL_OW 110
89733: PUSH
89734: LD_INT 18
89736: NONEQUAL
89737: AND
89738: IFFALSE 89778
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
89740: LD_VAR 0 2
89744: PPUSH
89745: CALL_OW 257
89749: PUSH
89750: LD_INT 5
89752: PUSH
89753: LD_INT 8
89755: PUSH
89756: LD_INT 9
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: LIST
89763: IN
89764: IFFALSE 89778
// SetClass ( unit , 1 ) ;
89766: LD_VAR 0 2
89770: PPUSH
89771: LD_INT 1
89773: PPUSH
89774: CALL_OW 336
// end ;
89778: LD_VAR 0 3
89782: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
89783: LD_INT 0
89785: PPUSH
89786: PPUSH
// if not mc_bases or not skirmish then
89787: LD_EXP 61
89791: NOT
89792: PUSH
89793: LD_EXP 59
89797: NOT
89798: OR
89799: IFFALSE 89803
// exit ;
89801: GO 89919
// if GetLives ( abandoned_vehicle ) > 250 then
89803: LD_VAR 0 2
89807: PPUSH
89808: CALL_OW 256
89812: PUSH
89813: LD_INT 250
89815: GREATER
89816: IFFALSE 89820
// exit ;
89818: GO 89919
// for i = 1 to mc_bases do
89820: LD_ADDR_VAR 0 6
89824: PUSH
89825: DOUBLE
89826: LD_INT 1
89828: DEC
89829: ST_TO_ADDR
89830: LD_EXP 61
89834: PUSH
89835: FOR_TO
89836: IFFALSE 89917
// begin if driver in mc_bases [ i ] then
89838: LD_VAR 0 1
89842: PUSH
89843: LD_EXP 61
89847: PUSH
89848: LD_VAR 0 6
89852: ARRAY
89853: IN
89854: IFFALSE 89915
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
89856: LD_VAR 0 1
89860: PPUSH
89861: LD_EXP 61
89865: PUSH
89866: LD_VAR 0 6
89870: ARRAY
89871: PPUSH
89872: LD_INT 2
89874: PUSH
89875: LD_INT 30
89877: PUSH
89878: LD_INT 0
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 30
89887: PUSH
89888: LD_INT 1
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: LIST
89899: PPUSH
89900: CALL_OW 72
89904: PUSH
89905: LD_INT 1
89907: ARRAY
89908: PPUSH
89909: CALL 55013 0 2
// break ;
89913: GO 89917
// end ; end ;
89915: GO 89835
89917: POP
89918: POP
// end ; end_of_file end_of_file
89919: LD_VAR 0 5
89923: RET
// export globalGameSaveCounter ; every 0 0$1 do
89924: GO 89926
89926: DISABLE
// begin enable ;
89927: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
89928: LD_STRING updateTimer(
89930: PUSH
89931: LD_OWVAR 1
89935: STR
89936: PUSH
89937: LD_STRING );
89939: STR
89940: PPUSH
89941: CALL_OW 559
// end ;
89945: END
// every 0 0$1 do
89946: GO 89948
89948: DISABLE
// begin globalGameSaveCounter := 0 ;
89949: LD_ADDR_EXP 106
89953: PUSH
89954: LD_INT 0
89956: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
89957: LD_STRING setGameSaveCounter(0)
89959: PPUSH
89960: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
89964: LD_STRING initStreamRollete();
89966: PPUSH
89967: CALL_OW 559
// InitStreamMode ;
89971: CALL 91314 0 0
// DefineStreamItems ( false ) ;
89975: LD_INT 0
89977: PPUSH
89978: CALL 91778 0 1
// end ;
89982: END
// export function SOS_MapStart ( ) ; begin
89983: LD_INT 0
89985: PPUSH
// if streamModeActive then
89986: LD_EXP 107
89990: IFFALSE 89999
// DefineStreamItems ( true ) ;
89992: LD_INT 1
89994: PPUSH
89995: CALL 91778 0 1
// UpdateLuaVariables ( ) ;
89999: CALL 90016 0 0
// UpdateFactoryWaypoints ( ) ;
90003: CALL 104647 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90007: CALL 104904 0 0
// end ;
90011: LD_VAR 0 1
90015: RET
// function UpdateLuaVariables ( ) ; begin
90016: LD_INT 0
90018: PPUSH
// if globalGameSaveCounter then
90019: LD_EXP 106
90023: IFFALSE 90057
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90025: LD_ADDR_EXP 106
90029: PUSH
90030: LD_EXP 106
90034: PPUSH
90035: CALL 55497 0 1
90039: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90040: LD_STRING setGameSaveCounter(
90042: PUSH
90043: LD_EXP 106
90047: STR
90048: PUSH
90049: LD_STRING )
90051: STR
90052: PPUSH
90053: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90057: LD_STRING setGameDifficulty(
90059: PUSH
90060: LD_OWVAR 67
90064: STR
90065: PUSH
90066: LD_STRING )
90068: STR
90069: PPUSH
90070: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
90074: LD_STRING displayDifficulty(
90076: PUSH
90077: LD_OWVAR 67
90081: STR
90082: PUSH
90083: LD_STRING )
90085: STR
90086: PPUSH
90087: CALL_OW 559
// end ;
90091: LD_VAR 0 1
90095: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90096: LD_INT 0
90098: PPUSH
// if p2 = stream_mode then
90099: LD_VAR 0 2
90103: PUSH
90104: LD_INT 100
90106: EQUAL
90107: IFFALSE 91110
// begin if not StreamModeActive then
90109: LD_EXP 107
90113: NOT
90114: IFFALSE 90124
// StreamModeActive := true ;
90116: LD_ADDR_EXP 107
90120: PUSH
90121: LD_INT 1
90123: ST_TO_ADDR
// if p3 = 0 then
90124: LD_VAR 0 3
90128: PUSH
90129: LD_INT 0
90131: EQUAL
90132: IFFALSE 90138
// InitStreamMode ;
90134: CALL 91314 0 0
// if p3 = 1 then
90138: LD_VAR 0 3
90142: PUSH
90143: LD_INT 1
90145: EQUAL
90146: IFFALSE 90156
// sRocket := true ;
90148: LD_ADDR_EXP 112
90152: PUSH
90153: LD_INT 1
90155: ST_TO_ADDR
// if p3 = 2 then
90156: LD_VAR 0 3
90160: PUSH
90161: LD_INT 2
90163: EQUAL
90164: IFFALSE 90174
// sSpeed := true ;
90166: LD_ADDR_EXP 111
90170: PUSH
90171: LD_INT 1
90173: ST_TO_ADDR
// if p3 = 3 then
90174: LD_VAR 0 3
90178: PUSH
90179: LD_INT 3
90181: EQUAL
90182: IFFALSE 90192
// sEngine := true ;
90184: LD_ADDR_EXP 113
90188: PUSH
90189: LD_INT 1
90191: ST_TO_ADDR
// if p3 = 4 then
90192: LD_VAR 0 3
90196: PUSH
90197: LD_INT 4
90199: EQUAL
90200: IFFALSE 90210
// sSpec := true ;
90202: LD_ADDR_EXP 110
90206: PUSH
90207: LD_INT 1
90209: ST_TO_ADDR
// if p3 = 5 then
90210: LD_VAR 0 3
90214: PUSH
90215: LD_INT 5
90217: EQUAL
90218: IFFALSE 90228
// sLevel := true ;
90220: LD_ADDR_EXP 114
90224: PUSH
90225: LD_INT 1
90227: ST_TO_ADDR
// if p3 = 6 then
90228: LD_VAR 0 3
90232: PUSH
90233: LD_INT 6
90235: EQUAL
90236: IFFALSE 90246
// sArmoury := true ;
90238: LD_ADDR_EXP 115
90242: PUSH
90243: LD_INT 1
90245: ST_TO_ADDR
// if p3 = 7 then
90246: LD_VAR 0 3
90250: PUSH
90251: LD_INT 7
90253: EQUAL
90254: IFFALSE 90264
// sRadar := true ;
90256: LD_ADDR_EXP 116
90260: PUSH
90261: LD_INT 1
90263: ST_TO_ADDR
// if p3 = 8 then
90264: LD_VAR 0 3
90268: PUSH
90269: LD_INT 8
90271: EQUAL
90272: IFFALSE 90282
// sBunker := true ;
90274: LD_ADDR_EXP 117
90278: PUSH
90279: LD_INT 1
90281: ST_TO_ADDR
// if p3 = 9 then
90282: LD_VAR 0 3
90286: PUSH
90287: LD_INT 9
90289: EQUAL
90290: IFFALSE 90300
// sHack := true ;
90292: LD_ADDR_EXP 118
90296: PUSH
90297: LD_INT 1
90299: ST_TO_ADDR
// if p3 = 10 then
90300: LD_VAR 0 3
90304: PUSH
90305: LD_INT 10
90307: EQUAL
90308: IFFALSE 90318
// sFire := true ;
90310: LD_ADDR_EXP 119
90314: PUSH
90315: LD_INT 1
90317: ST_TO_ADDR
// if p3 = 11 then
90318: LD_VAR 0 3
90322: PUSH
90323: LD_INT 11
90325: EQUAL
90326: IFFALSE 90336
// sRefresh := true ;
90328: LD_ADDR_EXP 120
90332: PUSH
90333: LD_INT 1
90335: ST_TO_ADDR
// if p3 = 12 then
90336: LD_VAR 0 3
90340: PUSH
90341: LD_INT 12
90343: EQUAL
90344: IFFALSE 90354
// sExp := true ;
90346: LD_ADDR_EXP 121
90350: PUSH
90351: LD_INT 1
90353: ST_TO_ADDR
// if p3 = 13 then
90354: LD_VAR 0 3
90358: PUSH
90359: LD_INT 13
90361: EQUAL
90362: IFFALSE 90372
// sDepot := true ;
90364: LD_ADDR_EXP 122
90368: PUSH
90369: LD_INT 1
90371: ST_TO_ADDR
// if p3 = 14 then
90372: LD_VAR 0 3
90376: PUSH
90377: LD_INT 14
90379: EQUAL
90380: IFFALSE 90390
// sFlag := true ;
90382: LD_ADDR_EXP 123
90386: PUSH
90387: LD_INT 1
90389: ST_TO_ADDR
// if p3 = 15 then
90390: LD_VAR 0 3
90394: PUSH
90395: LD_INT 15
90397: EQUAL
90398: IFFALSE 90408
// sKamikadze := true ;
90400: LD_ADDR_EXP 131
90404: PUSH
90405: LD_INT 1
90407: ST_TO_ADDR
// if p3 = 16 then
90408: LD_VAR 0 3
90412: PUSH
90413: LD_INT 16
90415: EQUAL
90416: IFFALSE 90426
// sTroll := true ;
90418: LD_ADDR_EXP 132
90422: PUSH
90423: LD_INT 1
90425: ST_TO_ADDR
// if p3 = 17 then
90426: LD_VAR 0 3
90430: PUSH
90431: LD_INT 17
90433: EQUAL
90434: IFFALSE 90444
// sSlow := true ;
90436: LD_ADDR_EXP 133
90440: PUSH
90441: LD_INT 1
90443: ST_TO_ADDR
// if p3 = 18 then
90444: LD_VAR 0 3
90448: PUSH
90449: LD_INT 18
90451: EQUAL
90452: IFFALSE 90462
// sLack := true ;
90454: LD_ADDR_EXP 134
90458: PUSH
90459: LD_INT 1
90461: ST_TO_ADDR
// if p3 = 19 then
90462: LD_VAR 0 3
90466: PUSH
90467: LD_INT 19
90469: EQUAL
90470: IFFALSE 90480
// sTank := true ;
90472: LD_ADDR_EXP 136
90476: PUSH
90477: LD_INT 1
90479: ST_TO_ADDR
// if p3 = 20 then
90480: LD_VAR 0 3
90484: PUSH
90485: LD_INT 20
90487: EQUAL
90488: IFFALSE 90498
// sRemote := true ;
90490: LD_ADDR_EXP 137
90494: PUSH
90495: LD_INT 1
90497: ST_TO_ADDR
// if p3 = 21 then
90498: LD_VAR 0 3
90502: PUSH
90503: LD_INT 21
90505: EQUAL
90506: IFFALSE 90516
// sPowell := true ;
90508: LD_ADDR_EXP 138
90512: PUSH
90513: LD_INT 1
90515: ST_TO_ADDR
// if p3 = 22 then
90516: LD_VAR 0 3
90520: PUSH
90521: LD_INT 22
90523: EQUAL
90524: IFFALSE 90534
// sTeleport := true ;
90526: LD_ADDR_EXP 141
90530: PUSH
90531: LD_INT 1
90533: ST_TO_ADDR
// if p3 = 23 then
90534: LD_VAR 0 3
90538: PUSH
90539: LD_INT 23
90541: EQUAL
90542: IFFALSE 90552
// sOilTower := true ;
90544: LD_ADDR_EXP 143
90548: PUSH
90549: LD_INT 1
90551: ST_TO_ADDR
// if p3 = 24 then
90552: LD_VAR 0 3
90556: PUSH
90557: LD_INT 24
90559: EQUAL
90560: IFFALSE 90570
// sShovel := true ;
90562: LD_ADDR_EXP 144
90566: PUSH
90567: LD_INT 1
90569: ST_TO_ADDR
// if p3 = 25 then
90570: LD_VAR 0 3
90574: PUSH
90575: LD_INT 25
90577: EQUAL
90578: IFFALSE 90588
// sSheik := true ;
90580: LD_ADDR_EXP 145
90584: PUSH
90585: LD_INT 1
90587: ST_TO_ADDR
// if p3 = 26 then
90588: LD_VAR 0 3
90592: PUSH
90593: LD_INT 26
90595: EQUAL
90596: IFFALSE 90606
// sEarthquake := true ;
90598: LD_ADDR_EXP 147
90602: PUSH
90603: LD_INT 1
90605: ST_TO_ADDR
// if p3 = 27 then
90606: LD_VAR 0 3
90610: PUSH
90611: LD_INT 27
90613: EQUAL
90614: IFFALSE 90624
// sAI := true ;
90616: LD_ADDR_EXP 148
90620: PUSH
90621: LD_INT 1
90623: ST_TO_ADDR
// if p3 = 28 then
90624: LD_VAR 0 3
90628: PUSH
90629: LD_INT 28
90631: EQUAL
90632: IFFALSE 90642
// sCargo := true ;
90634: LD_ADDR_EXP 151
90638: PUSH
90639: LD_INT 1
90641: ST_TO_ADDR
// if p3 = 29 then
90642: LD_VAR 0 3
90646: PUSH
90647: LD_INT 29
90649: EQUAL
90650: IFFALSE 90660
// sDLaser := true ;
90652: LD_ADDR_EXP 152
90656: PUSH
90657: LD_INT 1
90659: ST_TO_ADDR
// if p3 = 30 then
90660: LD_VAR 0 3
90664: PUSH
90665: LD_INT 30
90667: EQUAL
90668: IFFALSE 90678
// sExchange := true ;
90670: LD_ADDR_EXP 153
90674: PUSH
90675: LD_INT 1
90677: ST_TO_ADDR
// if p3 = 31 then
90678: LD_VAR 0 3
90682: PUSH
90683: LD_INT 31
90685: EQUAL
90686: IFFALSE 90696
// sFac := true ;
90688: LD_ADDR_EXP 154
90692: PUSH
90693: LD_INT 1
90695: ST_TO_ADDR
// if p3 = 32 then
90696: LD_VAR 0 3
90700: PUSH
90701: LD_INT 32
90703: EQUAL
90704: IFFALSE 90714
// sPower := true ;
90706: LD_ADDR_EXP 155
90710: PUSH
90711: LD_INT 1
90713: ST_TO_ADDR
// if p3 = 33 then
90714: LD_VAR 0 3
90718: PUSH
90719: LD_INT 33
90721: EQUAL
90722: IFFALSE 90732
// sRandom := true ;
90724: LD_ADDR_EXP 156
90728: PUSH
90729: LD_INT 1
90731: ST_TO_ADDR
// if p3 = 34 then
90732: LD_VAR 0 3
90736: PUSH
90737: LD_INT 34
90739: EQUAL
90740: IFFALSE 90750
// sShield := true ;
90742: LD_ADDR_EXP 157
90746: PUSH
90747: LD_INT 1
90749: ST_TO_ADDR
// if p3 = 35 then
90750: LD_VAR 0 3
90754: PUSH
90755: LD_INT 35
90757: EQUAL
90758: IFFALSE 90768
// sTime := true ;
90760: LD_ADDR_EXP 158
90764: PUSH
90765: LD_INT 1
90767: ST_TO_ADDR
// if p3 = 36 then
90768: LD_VAR 0 3
90772: PUSH
90773: LD_INT 36
90775: EQUAL
90776: IFFALSE 90786
// sTools := true ;
90778: LD_ADDR_EXP 159
90782: PUSH
90783: LD_INT 1
90785: ST_TO_ADDR
// if p3 = 101 then
90786: LD_VAR 0 3
90790: PUSH
90791: LD_INT 101
90793: EQUAL
90794: IFFALSE 90804
// sSold := true ;
90796: LD_ADDR_EXP 124
90800: PUSH
90801: LD_INT 1
90803: ST_TO_ADDR
// if p3 = 102 then
90804: LD_VAR 0 3
90808: PUSH
90809: LD_INT 102
90811: EQUAL
90812: IFFALSE 90822
// sDiff := true ;
90814: LD_ADDR_EXP 125
90818: PUSH
90819: LD_INT 1
90821: ST_TO_ADDR
// if p3 = 103 then
90822: LD_VAR 0 3
90826: PUSH
90827: LD_INT 103
90829: EQUAL
90830: IFFALSE 90840
// sFog := true ;
90832: LD_ADDR_EXP 128
90836: PUSH
90837: LD_INT 1
90839: ST_TO_ADDR
// if p3 = 104 then
90840: LD_VAR 0 3
90844: PUSH
90845: LD_INT 104
90847: EQUAL
90848: IFFALSE 90858
// sReset := true ;
90850: LD_ADDR_EXP 129
90854: PUSH
90855: LD_INT 1
90857: ST_TO_ADDR
// if p3 = 105 then
90858: LD_VAR 0 3
90862: PUSH
90863: LD_INT 105
90865: EQUAL
90866: IFFALSE 90876
// sSun := true ;
90868: LD_ADDR_EXP 130
90872: PUSH
90873: LD_INT 1
90875: ST_TO_ADDR
// if p3 = 106 then
90876: LD_VAR 0 3
90880: PUSH
90881: LD_INT 106
90883: EQUAL
90884: IFFALSE 90894
// sTiger := true ;
90886: LD_ADDR_EXP 126
90890: PUSH
90891: LD_INT 1
90893: ST_TO_ADDR
// if p3 = 107 then
90894: LD_VAR 0 3
90898: PUSH
90899: LD_INT 107
90901: EQUAL
90902: IFFALSE 90912
// sBomb := true ;
90904: LD_ADDR_EXP 127
90908: PUSH
90909: LD_INT 1
90911: ST_TO_ADDR
// if p3 = 108 then
90912: LD_VAR 0 3
90916: PUSH
90917: LD_INT 108
90919: EQUAL
90920: IFFALSE 90930
// sWound := true ;
90922: LD_ADDR_EXP 135
90926: PUSH
90927: LD_INT 1
90929: ST_TO_ADDR
// if p3 = 109 then
90930: LD_VAR 0 3
90934: PUSH
90935: LD_INT 109
90937: EQUAL
90938: IFFALSE 90948
// sBetray := true ;
90940: LD_ADDR_EXP 139
90944: PUSH
90945: LD_INT 1
90947: ST_TO_ADDR
// if p3 = 110 then
90948: LD_VAR 0 3
90952: PUSH
90953: LD_INT 110
90955: EQUAL
90956: IFFALSE 90966
// sContamin := true ;
90958: LD_ADDR_EXP 140
90962: PUSH
90963: LD_INT 1
90965: ST_TO_ADDR
// if p3 = 111 then
90966: LD_VAR 0 3
90970: PUSH
90971: LD_INT 111
90973: EQUAL
90974: IFFALSE 90984
// sOil := true ;
90976: LD_ADDR_EXP 142
90980: PUSH
90981: LD_INT 1
90983: ST_TO_ADDR
// if p3 = 112 then
90984: LD_VAR 0 3
90988: PUSH
90989: LD_INT 112
90991: EQUAL
90992: IFFALSE 91002
// sStu := true ;
90994: LD_ADDR_EXP 146
90998: PUSH
90999: LD_INT 1
91001: ST_TO_ADDR
// if p3 = 113 then
91002: LD_VAR 0 3
91006: PUSH
91007: LD_INT 113
91009: EQUAL
91010: IFFALSE 91020
// sBazooka := true ;
91012: LD_ADDR_EXP 149
91016: PUSH
91017: LD_INT 1
91019: ST_TO_ADDR
// if p3 = 114 then
91020: LD_VAR 0 3
91024: PUSH
91025: LD_INT 114
91027: EQUAL
91028: IFFALSE 91038
// sMortar := true ;
91030: LD_ADDR_EXP 150
91034: PUSH
91035: LD_INT 1
91037: ST_TO_ADDR
// if p3 = 115 then
91038: LD_VAR 0 3
91042: PUSH
91043: LD_INT 115
91045: EQUAL
91046: IFFALSE 91056
// sRanger := true ;
91048: LD_ADDR_EXP 160
91052: PUSH
91053: LD_INT 1
91055: ST_TO_ADDR
// if p3 = 116 then
91056: LD_VAR 0 3
91060: PUSH
91061: LD_INT 116
91063: EQUAL
91064: IFFALSE 91074
// sComputer := true ;
91066: LD_ADDR_EXP 161
91070: PUSH
91071: LD_INT 1
91073: ST_TO_ADDR
// if p3 = 117 then
91074: LD_VAR 0 3
91078: PUSH
91079: LD_INT 117
91081: EQUAL
91082: IFFALSE 91092
// s30 := true ;
91084: LD_ADDR_EXP 162
91088: PUSH
91089: LD_INT 1
91091: ST_TO_ADDR
// if p3 = 118 then
91092: LD_VAR 0 3
91096: PUSH
91097: LD_INT 118
91099: EQUAL
91100: IFFALSE 91110
// s60 := true ;
91102: LD_ADDR_EXP 163
91106: PUSH
91107: LD_INT 1
91109: ST_TO_ADDR
// end ; if p2 = hack_mode then
91110: LD_VAR 0 2
91114: PUSH
91115: LD_INT 101
91117: EQUAL
91118: IFFALSE 91246
// begin case p3 of 1 :
91120: LD_VAR 0 3
91124: PUSH
91125: LD_INT 1
91127: DOUBLE
91128: EQUAL
91129: IFTRUE 91133
91131: GO 91140
91133: POP
// hHackUnlimitedResources ; 2 :
91134: CALL 103393 0 0
91138: GO 91246
91140: LD_INT 2
91142: DOUBLE
91143: EQUAL
91144: IFTRUE 91148
91146: GO 91155
91148: POP
// hHackSetLevel10 ; 3 :
91149: CALL 103526 0 0
91153: GO 91246
91155: LD_INT 3
91157: DOUBLE
91158: EQUAL
91159: IFTRUE 91163
91161: GO 91170
91163: POP
// hHackSetLevel10YourUnits ; 4 :
91164: CALL 103611 0 0
91168: GO 91246
91170: LD_INT 4
91172: DOUBLE
91173: EQUAL
91174: IFTRUE 91178
91176: GO 91185
91178: POP
// hHackInvincible ; 5 :
91179: CALL 104059 0 0
91183: GO 91246
91185: LD_INT 5
91187: DOUBLE
91188: EQUAL
91189: IFTRUE 91193
91191: GO 91200
91193: POP
// hHackInvisible ; 6 :
91194: CALL 104170 0 0
91198: GO 91246
91200: LD_INT 6
91202: DOUBLE
91203: EQUAL
91204: IFTRUE 91208
91206: GO 91215
91208: POP
// hHackChangeYourSide ; 7 :
91209: CALL 104227 0 0
91213: GO 91246
91215: LD_INT 7
91217: DOUBLE
91218: EQUAL
91219: IFTRUE 91223
91221: GO 91230
91223: POP
// hHackChangeUnitSide ; 8 :
91224: CALL 104269 0 0
91228: GO 91246
91230: LD_INT 8
91232: DOUBLE
91233: EQUAL
91234: IFTRUE 91238
91236: GO 91245
91238: POP
// hHackFog ; end ;
91239: CALL 104370 0 0
91243: GO 91246
91245: POP
// end ; if p2 = game_save_mode then
91246: LD_VAR 0 2
91250: PUSH
91251: LD_INT 102
91253: EQUAL
91254: IFFALSE 91309
// begin if p3 = 1 then
91256: LD_VAR 0 3
91260: PUSH
91261: LD_INT 1
91263: EQUAL
91264: IFFALSE 91276
// globalGameSaveCounter := p4 ;
91266: LD_ADDR_EXP 106
91270: PUSH
91271: LD_VAR 0 4
91275: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91276: LD_VAR 0 3
91280: PUSH
91281: LD_INT 2
91283: EQUAL
91284: PUSH
91285: LD_EXP 106
91289: AND
91290: IFFALSE 91309
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91292: LD_STRING setGameSaveCounter(
91294: PUSH
91295: LD_EXP 106
91299: STR
91300: PUSH
91301: LD_STRING )
91303: STR
91304: PPUSH
91305: CALL_OW 559
// end ; end ;
91309: LD_VAR 0 7
91313: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
91314: LD_INT 0
91316: PPUSH
// streamModeActive := false ;
91317: LD_ADDR_EXP 107
91321: PUSH
91322: LD_INT 0
91324: ST_TO_ADDR
// normalCounter := 36 ;
91325: LD_ADDR_EXP 108
91329: PUSH
91330: LD_INT 36
91332: ST_TO_ADDR
// hardcoreCounter := 18 ;
91333: LD_ADDR_EXP 109
91337: PUSH
91338: LD_INT 18
91340: ST_TO_ADDR
// sRocket := false ;
91341: LD_ADDR_EXP 112
91345: PUSH
91346: LD_INT 0
91348: ST_TO_ADDR
// sSpeed := false ;
91349: LD_ADDR_EXP 111
91353: PUSH
91354: LD_INT 0
91356: ST_TO_ADDR
// sEngine := false ;
91357: LD_ADDR_EXP 113
91361: PUSH
91362: LD_INT 0
91364: ST_TO_ADDR
// sSpec := false ;
91365: LD_ADDR_EXP 110
91369: PUSH
91370: LD_INT 0
91372: ST_TO_ADDR
// sLevel := false ;
91373: LD_ADDR_EXP 114
91377: PUSH
91378: LD_INT 0
91380: ST_TO_ADDR
// sArmoury := false ;
91381: LD_ADDR_EXP 115
91385: PUSH
91386: LD_INT 0
91388: ST_TO_ADDR
// sRadar := false ;
91389: LD_ADDR_EXP 116
91393: PUSH
91394: LD_INT 0
91396: ST_TO_ADDR
// sBunker := false ;
91397: LD_ADDR_EXP 117
91401: PUSH
91402: LD_INT 0
91404: ST_TO_ADDR
// sHack := false ;
91405: LD_ADDR_EXP 118
91409: PUSH
91410: LD_INT 0
91412: ST_TO_ADDR
// sFire := false ;
91413: LD_ADDR_EXP 119
91417: PUSH
91418: LD_INT 0
91420: ST_TO_ADDR
// sRefresh := false ;
91421: LD_ADDR_EXP 120
91425: PUSH
91426: LD_INT 0
91428: ST_TO_ADDR
// sExp := false ;
91429: LD_ADDR_EXP 121
91433: PUSH
91434: LD_INT 0
91436: ST_TO_ADDR
// sDepot := false ;
91437: LD_ADDR_EXP 122
91441: PUSH
91442: LD_INT 0
91444: ST_TO_ADDR
// sFlag := false ;
91445: LD_ADDR_EXP 123
91449: PUSH
91450: LD_INT 0
91452: ST_TO_ADDR
// sKamikadze := false ;
91453: LD_ADDR_EXP 131
91457: PUSH
91458: LD_INT 0
91460: ST_TO_ADDR
// sTroll := false ;
91461: LD_ADDR_EXP 132
91465: PUSH
91466: LD_INT 0
91468: ST_TO_ADDR
// sSlow := false ;
91469: LD_ADDR_EXP 133
91473: PUSH
91474: LD_INT 0
91476: ST_TO_ADDR
// sLack := false ;
91477: LD_ADDR_EXP 134
91481: PUSH
91482: LD_INT 0
91484: ST_TO_ADDR
// sTank := false ;
91485: LD_ADDR_EXP 136
91489: PUSH
91490: LD_INT 0
91492: ST_TO_ADDR
// sRemote := false ;
91493: LD_ADDR_EXP 137
91497: PUSH
91498: LD_INT 0
91500: ST_TO_ADDR
// sPowell := false ;
91501: LD_ADDR_EXP 138
91505: PUSH
91506: LD_INT 0
91508: ST_TO_ADDR
// sTeleport := false ;
91509: LD_ADDR_EXP 141
91513: PUSH
91514: LD_INT 0
91516: ST_TO_ADDR
// sOilTower := false ;
91517: LD_ADDR_EXP 143
91521: PUSH
91522: LD_INT 0
91524: ST_TO_ADDR
// sShovel := false ;
91525: LD_ADDR_EXP 144
91529: PUSH
91530: LD_INT 0
91532: ST_TO_ADDR
// sSheik := false ;
91533: LD_ADDR_EXP 145
91537: PUSH
91538: LD_INT 0
91540: ST_TO_ADDR
// sEarthquake := false ;
91541: LD_ADDR_EXP 147
91545: PUSH
91546: LD_INT 0
91548: ST_TO_ADDR
// sAI := false ;
91549: LD_ADDR_EXP 148
91553: PUSH
91554: LD_INT 0
91556: ST_TO_ADDR
// sCargo := false ;
91557: LD_ADDR_EXP 151
91561: PUSH
91562: LD_INT 0
91564: ST_TO_ADDR
// sDLaser := false ;
91565: LD_ADDR_EXP 152
91569: PUSH
91570: LD_INT 0
91572: ST_TO_ADDR
// sExchange := false ;
91573: LD_ADDR_EXP 153
91577: PUSH
91578: LD_INT 0
91580: ST_TO_ADDR
// sFac := false ;
91581: LD_ADDR_EXP 154
91585: PUSH
91586: LD_INT 0
91588: ST_TO_ADDR
// sPower := false ;
91589: LD_ADDR_EXP 155
91593: PUSH
91594: LD_INT 0
91596: ST_TO_ADDR
// sRandom := false ;
91597: LD_ADDR_EXP 156
91601: PUSH
91602: LD_INT 0
91604: ST_TO_ADDR
// sShield := false ;
91605: LD_ADDR_EXP 157
91609: PUSH
91610: LD_INT 0
91612: ST_TO_ADDR
// sTime := false ;
91613: LD_ADDR_EXP 158
91617: PUSH
91618: LD_INT 0
91620: ST_TO_ADDR
// sTools := false ;
91621: LD_ADDR_EXP 159
91625: PUSH
91626: LD_INT 0
91628: ST_TO_ADDR
// sSold := false ;
91629: LD_ADDR_EXP 124
91633: PUSH
91634: LD_INT 0
91636: ST_TO_ADDR
// sDiff := false ;
91637: LD_ADDR_EXP 125
91641: PUSH
91642: LD_INT 0
91644: ST_TO_ADDR
// sFog := false ;
91645: LD_ADDR_EXP 128
91649: PUSH
91650: LD_INT 0
91652: ST_TO_ADDR
// sReset := false ;
91653: LD_ADDR_EXP 129
91657: PUSH
91658: LD_INT 0
91660: ST_TO_ADDR
// sSun := false ;
91661: LD_ADDR_EXP 130
91665: PUSH
91666: LD_INT 0
91668: ST_TO_ADDR
// sTiger := false ;
91669: LD_ADDR_EXP 126
91673: PUSH
91674: LD_INT 0
91676: ST_TO_ADDR
// sBomb := false ;
91677: LD_ADDR_EXP 127
91681: PUSH
91682: LD_INT 0
91684: ST_TO_ADDR
// sWound := false ;
91685: LD_ADDR_EXP 135
91689: PUSH
91690: LD_INT 0
91692: ST_TO_ADDR
// sBetray := false ;
91693: LD_ADDR_EXP 139
91697: PUSH
91698: LD_INT 0
91700: ST_TO_ADDR
// sContamin := false ;
91701: LD_ADDR_EXP 140
91705: PUSH
91706: LD_INT 0
91708: ST_TO_ADDR
// sOil := false ;
91709: LD_ADDR_EXP 142
91713: PUSH
91714: LD_INT 0
91716: ST_TO_ADDR
// sStu := false ;
91717: LD_ADDR_EXP 146
91721: PUSH
91722: LD_INT 0
91724: ST_TO_ADDR
// sBazooka := false ;
91725: LD_ADDR_EXP 149
91729: PUSH
91730: LD_INT 0
91732: ST_TO_ADDR
// sMortar := false ;
91733: LD_ADDR_EXP 150
91737: PUSH
91738: LD_INT 0
91740: ST_TO_ADDR
// sRanger := false ;
91741: LD_ADDR_EXP 160
91745: PUSH
91746: LD_INT 0
91748: ST_TO_ADDR
// sComputer := false ;
91749: LD_ADDR_EXP 161
91753: PUSH
91754: LD_INT 0
91756: ST_TO_ADDR
// s30 := false ;
91757: LD_ADDR_EXP 162
91761: PUSH
91762: LD_INT 0
91764: ST_TO_ADDR
// s60 := false ;
91765: LD_ADDR_EXP 163
91769: PUSH
91770: LD_INT 0
91772: ST_TO_ADDR
// end ;
91773: LD_VAR 0 1
91777: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91778: LD_INT 0
91780: PPUSH
91781: PPUSH
91782: PPUSH
91783: PPUSH
91784: PPUSH
91785: PPUSH
91786: PPUSH
// result := [ ] ;
91787: LD_ADDR_VAR 0 2
91791: PUSH
91792: EMPTY
91793: ST_TO_ADDR
// if campaign_id = 1 then
91794: LD_OWVAR 69
91798: PUSH
91799: LD_INT 1
91801: EQUAL
91802: IFFALSE 94968
// begin case mission_number of 1 :
91804: LD_OWVAR 70
91808: PUSH
91809: LD_INT 1
91811: DOUBLE
91812: EQUAL
91813: IFTRUE 91817
91815: GO 91893
91817: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91818: LD_ADDR_VAR 0 2
91822: PUSH
91823: LD_INT 2
91825: PUSH
91826: LD_INT 4
91828: PUSH
91829: LD_INT 11
91831: PUSH
91832: LD_INT 12
91834: PUSH
91835: LD_INT 15
91837: PUSH
91838: LD_INT 16
91840: PUSH
91841: LD_INT 22
91843: PUSH
91844: LD_INT 23
91846: PUSH
91847: LD_INT 26
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 101
91863: PUSH
91864: LD_INT 102
91866: PUSH
91867: LD_INT 106
91869: PUSH
91870: LD_INT 116
91872: PUSH
91873: LD_INT 117
91875: PUSH
91876: LD_INT 118
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: ST_TO_ADDR
91891: GO 94966
91893: LD_INT 2
91895: DOUBLE
91896: EQUAL
91897: IFTRUE 91901
91899: GO 91985
91901: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91902: LD_ADDR_VAR 0 2
91906: PUSH
91907: LD_INT 2
91909: PUSH
91910: LD_INT 4
91912: PUSH
91913: LD_INT 11
91915: PUSH
91916: LD_INT 12
91918: PUSH
91919: LD_INT 15
91921: PUSH
91922: LD_INT 16
91924: PUSH
91925: LD_INT 22
91927: PUSH
91928: LD_INT 23
91930: PUSH
91931: LD_INT 26
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 101
91947: PUSH
91948: LD_INT 102
91950: PUSH
91951: LD_INT 105
91953: PUSH
91954: LD_INT 106
91956: PUSH
91957: LD_INT 108
91959: PUSH
91960: LD_INT 116
91962: PUSH
91963: LD_INT 117
91965: PUSH
91966: LD_INT 118
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: ST_TO_ADDR
91983: GO 94966
91985: LD_INT 3
91987: DOUBLE
91988: EQUAL
91989: IFTRUE 91993
91991: GO 92081
91993: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91994: LD_ADDR_VAR 0 2
91998: PUSH
91999: LD_INT 2
92001: PUSH
92002: LD_INT 4
92004: PUSH
92005: LD_INT 5
92007: PUSH
92008: LD_INT 11
92010: PUSH
92011: LD_INT 12
92013: PUSH
92014: LD_INT 15
92016: PUSH
92017: LD_INT 16
92019: PUSH
92020: LD_INT 22
92022: PUSH
92023: LD_INT 26
92025: PUSH
92026: LD_INT 36
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 101
92043: PUSH
92044: LD_INT 102
92046: PUSH
92047: LD_INT 105
92049: PUSH
92050: LD_INT 106
92052: PUSH
92053: LD_INT 108
92055: PUSH
92056: LD_INT 116
92058: PUSH
92059: LD_INT 117
92061: PUSH
92062: LD_INT 118
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: ST_TO_ADDR
92079: GO 94966
92081: LD_INT 4
92083: DOUBLE
92084: EQUAL
92085: IFTRUE 92089
92087: GO 92185
92089: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92090: LD_ADDR_VAR 0 2
92094: PUSH
92095: LD_INT 2
92097: PUSH
92098: LD_INT 4
92100: PUSH
92101: LD_INT 5
92103: PUSH
92104: LD_INT 8
92106: PUSH
92107: LD_INT 11
92109: PUSH
92110: LD_INT 12
92112: PUSH
92113: LD_INT 15
92115: PUSH
92116: LD_INT 16
92118: PUSH
92119: LD_INT 22
92121: PUSH
92122: LD_INT 23
92124: PUSH
92125: LD_INT 26
92127: PUSH
92128: LD_INT 36
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 101
92147: PUSH
92148: LD_INT 102
92150: PUSH
92151: LD_INT 105
92153: PUSH
92154: LD_INT 106
92156: PUSH
92157: LD_INT 108
92159: PUSH
92160: LD_INT 116
92162: PUSH
92163: LD_INT 117
92165: PUSH
92166: LD_INT 118
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: ST_TO_ADDR
92183: GO 94966
92185: LD_INT 5
92187: DOUBLE
92188: EQUAL
92189: IFTRUE 92193
92191: GO 92305
92193: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92194: LD_ADDR_VAR 0 2
92198: PUSH
92199: LD_INT 2
92201: PUSH
92202: LD_INT 4
92204: PUSH
92205: LD_INT 5
92207: PUSH
92208: LD_INT 6
92210: PUSH
92211: LD_INT 8
92213: PUSH
92214: LD_INT 11
92216: PUSH
92217: LD_INT 12
92219: PUSH
92220: LD_INT 15
92222: PUSH
92223: LD_INT 16
92225: PUSH
92226: LD_INT 22
92228: PUSH
92229: LD_INT 23
92231: PUSH
92232: LD_INT 25
92234: PUSH
92235: LD_INT 26
92237: PUSH
92238: LD_INT 36
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 101
92259: PUSH
92260: LD_INT 102
92262: PUSH
92263: LD_INT 105
92265: PUSH
92266: LD_INT 106
92268: PUSH
92269: LD_INT 108
92271: PUSH
92272: LD_INT 109
92274: PUSH
92275: LD_INT 112
92277: PUSH
92278: LD_INT 116
92280: PUSH
92281: LD_INT 117
92283: PUSH
92284: LD_INT 118
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: ST_TO_ADDR
92303: GO 94966
92305: LD_INT 6
92307: DOUBLE
92308: EQUAL
92309: IFTRUE 92313
92311: GO 92445
92313: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92314: LD_ADDR_VAR 0 2
92318: PUSH
92319: LD_INT 2
92321: PUSH
92322: LD_INT 4
92324: PUSH
92325: LD_INT 5
92327: PUSH
92328: LD_INT 6
92330: PUSH
92331: LD_INT 8
92333: PUSH
92334: LD_INT 11
92336: PUSH
92337: LD_INT 12
92339: PUSH
92340: LD_INT 15
92342: PUSH
92343: LD_INT 16
92345: PUSH
92346: LD_INT 20
92348: PUSH
92349: LD_INT 21
92351: PUSH
92352: LD_INT 22
92354: PUSH
92355: LD_INT 23
92357: PUSH
92358: LD_INT 25
92360: PUSH
92361: LD_INT 26
92363: PUSH
92364: LD_INT 30
92366: PUSH
92367: LD_INT 31
92369: PUSH
92370: LD_INT 32
92372: PUSH
92373: LD_INT 36
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 101
92399: PUSH
92400: LD_INT 102
92402: PUSH
92403: LD_INT 105
92405: PUSH
92406: LD_INT 106
92408: PUSH
92409: LD_INT 108
92411: PUSH
92412: LD_INT 109
92414: PUSH
92415: LD_INT 112
92417: PUSH
92418: LD_INT 116
92420: PUSH
92421: LD_INT 117
92423: PUSH
92424: LD_INT 118
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: ST_TO_ADDR
92443: GO 94966
92445: LD_INT 7
92447: DOUBLE
92448: EQUAL
92449: IFTRUE 92453
92451: GO 92565
92453: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92454: LD_ADDR_VAR 0 2
92458: PUSH
92459: LD_INT 2
92461: PUSH
92462: LD_INT 4
92464: PUSH
92465: LD_INT 5
92467: PUSH
92468: LD_INT 7
92470: PUSH
92471: LD_INT 11
92473: PUSH
92474: LD_INT 12
92476: PUSH
92477: LD_INT 15
92479: PUSH
92480: LD_INT 16
92482: PUSH
92483: LD_INT 20
92485: PUSH
92486: LD_INT 21
92488: PUSH
92489: LD_INT 22
92491: PUSH
92492: LD_INT 23
92494: PUSH
92495: LD_INT 25
92497: PUSH
92498: LD_INT 26
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 101
92519: PUSH
92520: LD_INT 102
92522: PUSH
92523: LD_INT 103
92525: PUSH
92526: LD_INT 105
92528: PUSH
92529: LD_INT 106
92531: PUSH
92532: LD_INT 108
92534: PUSH
92535: LD_INT 112
92537: PUSH
92538: LD_INT 116
92540: PUSH
92541: LD_INT 117
92543: PUSH
92544: LD_INT 118
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: ST_TO_ADDR
92563: GO 94966
92565: LD_INT 8
92567: DOUBLE
92568: EQUAL
92569: IFTRUE 92573
92571: GO 92713
92573: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92574: LD_ADDR_VAR 0 2
92578: PUSH
92579: LD_INT 2
92581: PUSH
92582: LD_INT 4
92584: PUSH
92585: LD_INT 5
92587: PUSH
92588: LD_INT 6
92590: PUSH
92591: LD_INT 7
92593: PUSH
92594: LD_INT 8
92596: PUSH
92597: LD_INT 11
92599: PUSH
92600: LD_INT 12
92602: PUSH
92603: LD_INT 15
92605: PUSH
92606: LD_INT 16
92608: PUSH
92609: LD_INT 20
92611: PUSH
92612: LD_INT 21
92614: PUSH
92615: LD_INT 22
92617: PUSH
92618: LD_INT 23
92620: PUSH
92621: LD_INT 25
92623: PUSH
92624: LD_INT 26
92626: PUSH
92627: LD_INT 30
92629: PUSH
92630: LD_INT 31
92632: PUSH
92633: LD_INT 32
92635: PUSH
92636: LD_INT 36
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: PUSH
92661: LD_INT 101
92663: PUSH
92664: LD_INT 102
92666: PUSH
92667: LD_INT 103
92669: PUSH
92670: LD_INT 105
92672: PUSH
92673: LD_INT 106
92675: PUSH
92676: LD_INT 108
92678: PUSH
92679: LD_INT 109
92681: PUSH
92682: LD_INT 112
92684: PUSH
92685: LD_INT 116
92687: PUSH
92688: LD_INT 117
92690: PUSH
92691: LD_INT 118
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: ST_TO_ADDR
92711: GO 94966
92713: LD_INT 9
92715: DOUBLE
92716: EQUAL
92717: IFTRUE 92721
92719: GO 92869
92721: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92722: LD_ADDR_VAR 0 2
92726: PUSH
92727: LD_INT 2
92729: PUSH
92730: LD_INT 4
92732: PUSH
92733: LD_INT 5
92735: PUSH
92736: LD_INT 6
92738: PUSH
92739: LD_INT 7
92741: PUSH
92742: LD_INT 8
92744: PUSH
92745: LD_INT 11
92747: PUSH
92748: LD_INT 12
92750: PUSH
92751: LD_INT 15
92753: PUSH
92754: LD_INT 16
92756: PUSH
92757: LD_INT 20
92759: PUSH
92760: LD_INT 21
92762: PUSH
92763: LD_INT 22
92765: PUSH
92766: LD_INT 23
92768: PUSH
92769: LD_INT 25
92771: PUSH
92772: LD_INT 26
92774: PUSH
92775: LD_INT 28
92777: PUSH
92778: LD_INT 30
92780: PUSH
92781: LD_INT 31
92783: PUSH
92784: LD_INT 32
92786: PUSH
92787: LD_INT 36
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 101
92815: PUSH
92816: LD_INT 102
92818: PUSH
92819: LD_INT 103
92821: PUSH
92822: LD_INT 105
92824: PUSH
92825: LD_INT 106
92827: PUSH
92828: LD_INT 108
92830: PUSH
92831: LD_INT 109
92833: PUSH
92834: LD_INT 112
92836: PUSH
92837: LD_INT 114
92839: PUSH
92840: LD_INT 116
92842: PUSH
92843: LD_INT 117
92845: PUSH
92846: LD_INT 118
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: ST_TO_ADDR
92867: GO 94966
92869: LD_INT 10
92871: DOUBLE
92872: EQUAL
92873: IFTRUE 92877
92875: GO 93073
92877: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92878: LD_ADDR_VAR 0 2
92882: PUSH
92883: LD_INT 2
92885: PUSH
92886: LD_INT 4
92888: PUSH
92889: LD_INT 5
92891: PUSH
92892: LD_INT 6
92894: PUSH
92895: LD_INT 7
92897: PUSH
92898: LD_INT 8
92900: PUSH
92901: LD_INT 9
92903: PUSH
92904: LD_INT 10
92906: PUSH
92907: LD_INT 11
92909: PUSH
92910: LD_INT 12
92912: PUSH
92913: LD_INT 13
92915: PUSH
92916: LD_INT 14
92918: PUSH
92919: LD_INT 15
92921: PUSH
92922: LD_INT 16
92924: PUSH
92925: LD_INT 17
92927: PUSH
92928: LD_INT 18
92930: PUSH
92931: LD_INT 19
92933: PUSH
92934: LD_INT 20
92936: PUSH
92937: LD_INT 21
92939: PUSH
92940: LD_INT 22
92942: PUSH
92943: LD_INT 23
92945: PUSH
92946: LD_INT 24
92948: PUSH
92949: LD_INT 25
92951: PUSH
92952: LD_INT 26
92954: PUSH
92955: LD_INT 28
92957: PUSH
92958: LD_INT 30
92960: PUSH
92961: LD_INT 31
92963: PUSH
92964: LD_INT 32
92966: PUSH
92967: LD_INT 36
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: PUSH
93001: LD_INT 101
93003: PUSH
93004: LD_INT 102
93006: PUSH
93007: LD_INT 103
93009: PUSH
93010: LD_INT 104
93012: PUSH
93013: LD_INT 105
93015: PUSH
93016: LD_INT 106
93018: PUSH
93019: LD_INT 107
93021: PUSH
93022: LD_INT 108
93024: PUSH
93025: LD_INT 109
93027: PUSH
93028: LD_INT 110
93030: PUSH
93031: LD_INT 111
93033: PUSH
93034: LD_INT 112
93036: PUSH
93037: LD_INT 114
93039: PUSH
93040: LD_INT 116
93042: PUSH
93043: LD_INT 117
93045: PUSH
93046: LD_INT 118
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: ST_TO_ADDR
93071: GO 94966
93073: LD_INT 11
93075: DOUBLE
93076: EQUAL
93077: IFTRUE 93081
93079: GO 93285
93081: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93082: LD_ADDR_VAR 0 2
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: LD_INT 3
93092: PUSH
93093: LD_INT 4
93095: PUSH
93096: LD_INT 5
93098: PUSH
93099: LD_INT 6
93101: PUSH
93102: LD_INT 7
93104: PUSH
93105: LD_INT 8
93107: PUSH
93108: LD_INT 9
93110: PUSH
93111: LD_INT 10
93113: PUSH
93114: LD_INT 11
93116: PUSH
93117: LD_INT 12
93119: PUSH
93120: LD_INT 13
93122: PUSH
93123: LD_INT 14
93125: PUSH
93126: LD_INT 15
93128: PUSH
93129: LD_INT 16
93131: PUSH
93132: LD_INT 17
93134: PUSH
93135: LD_INT 18
93137: PUSH
93138: LD_INT 19
93140: PUSH
93141: LD_INT 20
93143: PUSH
93144: LD_INT 21
93146: PUSH
93147: LD_INT 22
93149: PUSH
93150: LD_INT 23
93152: PUSH
93153: LD_INT 24
93155: PUSH
93156: LD_INT 25
93158: PUSH
93159: LD_INT 26
93161: PUSH
93162: LD_INT 28
93164: PUSH
93165: LD_INT 30
93167: PUSH
93168: LD_INT 31
93170: PUSH
93171: LD_INT 32
93173: PUSH
93174: LD_INT 34
93176: PUSH
93177: LD_INT 36
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 101
93215: PUSH
93216: LD_INT 102
93218: PUSH
93219: LD_INT 103
93221: PUSH
93222: LD_INT 104
93224: PUSH
93225: LD_INT 105
93227: PUSH
93228: LD_INT 106
93230: PUSH
93231: LD_INT 107
93233: PUSH
93234: LD_INT 108
93236: PUSH
93237: LD_INT 109
93239: PUSH
93240: LD_INT 110
93242: PUSH
93243: LD_INT 111
93245: PUSH
93246: LD_INT 112
93248: PUSH
93249: LD_INT 114
93251: PUSH
93252: LD_INT 116
93254: PUSH
93255: LD_INT 117
93257: PUSH
93258: LD_INT 118
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: ST_TO_ADDR
93283: GO 94966
93285: LD_INT 12
93287: DOUBLE
93288: EQUAL
93289: IFTRUE 93293
93291: GO 93513
93293: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93294: LD_ADDR_VAR 0 2
93298: PUSH
93299: LD_INT 1
93301: PUSH
93302: LD_INT 2
93304: PUSH
93305: LD_INT 3
93307: PUSH
93308: LD_INT 4
93310: PUSH
93311: LD_INT 5
93313: PUSH
93314: LD_INT 6
93316: PUSH
93317: LD_INT 7
93319: PUSH
93320: LD_INT 8
93322: PUSH
93323: LD_INT 9
93325: PUSH
93326: LD_INT 10
93328: PUSH
93329: LD_INT 11
93331: PUSH
93332: LD_INT 12
93334: PUSH
93335: LD_INT 13
93337: PUSH
93338: LD_INT 14
93340: PUSH
93341: LD_INT 15
93343: PUSH
93344: LD_INT 16
93346: PUSH
93347: LD_INT 17
93349: PUSH
93350: LD_INT 18
93352: PUSH
93353: LD_INT 19
93355: PUSH
93356: LD_INT 20
93358: PUSH
93359: LD_INT 21
93361: PUSH
93362: LD_INT 22
93364: PUSH
93365: LD_INT 23
93367: PUSH
93368: LD_INT 24
93370: PUSH
93371: LD_INT 25
93373: PUSH
93374: LD_INT 26
93376: PUSH
93377: LD_INT 27
93379: PUSH
93380: LD_INT 28
93382: PUSH
93383: LD_INT 30
93385: PUSH
93386: LD_INT 31
93388: PUSH
93389: LD_INT 32
93391: PUSH
93392: LD_INT 33
93394: PUSH
93395: LD_INT 34
93397: PUSH
93398: LD_INT 36
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 101
93439: PUSH
93440: LD_INT 102
93442: PUSH
93443: LD_INT 103
93445: PUSH
93446: LD_INT 104
93448: PUSH
93449: LD_INT 105
93451: PUSH
93452: LD_INT 106
93454: PUSH
93455: LD_INT 107
93457: PUSH
93458: LD_INT 108
93460: PUSH
93461: LD_INT 109
93463: PUSH
93464: LD_INT 110
93466: PUSH
93467: LD_INT 111
93469: PUSH
93470: LD_INT 112
93472: PUSH
93473: LD_INT 113
93475: PUSH
93476: LD_INT 114
93478: PUSH
93479: LD_INT 116
93481: PUSH
93482: LD_INT 117
93484: PUSH
93485: LD_INT 118
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: PUSH
93507: EMPTY
93508: LIST
93509: LIST
93510: ST_TO_ADDR
93511: GO 94966
93513: LD_INT 13
93515: DOUBLE
93516: EQUAL
93517: IFTRUE 93521
93519: GO 93729
93521: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93522: LD_ADDR_VAR 0 2
93526: PUSH
93527: LD_INT 1
93529: PUSH
93530: LD_INT 2
93532: PUSH
93533: LD_INT 3
93535: PUSH
93536: LD_INT 4
93538: PUSH
93539: LD_INT 5
93541: PUSH
93542: LD_INT 8
93544: PUSH
93545: LD_INT 9
93547: PUSH
93548: LD_INT 10
93550: PUSH
93551: LD_INT 11
93553: PUSH
93554: LD_INT 12
93556: PUSH
93557: LD_INT 14
93559: PUSH
93560: LD_INT 15
93562: PUSH
93563: LD_INT 16
93565: PUSH
93566: LD_INT 17
93568: PUSH
93569: LD_INT 18
93571: PUSH
93572: LD_INT 19
93574: PUSH
93575: LD_INT 20
93577: PUSH
93578: LD_INT 21
93580: PUSH
93581: LD_INT 22
93583: PUSH
93584: LD_INT 23
93586: PUSH
93587: LD_INT 24
93589: PUSH
93590: LD_INT 25
93592: PUSH
93593: LD_INT 26
93595: PUSH
93596: LD_INT 27
93598: PUSH
93599: LD_INT 28
93601: PUSH
93602: LD_INT 30
93604: PUSH
93605: LD_INT 31
93607: PUSH
93608: LD_INT 32
93610: PUSH
93611: LD_INT 33
93613: PUSH
93614: LD_INT 34
93616: PUSH
93617: LD_INT 36
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: LIST
93624: LIST
93625: LIST
93626: LIST
93627: LIST
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: PUSH
93653: LD_INT 101
93655: PUSH
93656: LD_INT 102
93658: PUSH
93659: LD_INT 103
93661: PUSH
93662: LD_INT 104
93664: PUSH
93665: LD_INT 105
93667: PUSH
93668: LD_INT 106
93670: PUSH
93671: LD_INT 107
93673: PUSH
93674: LD_INT 108
93676: PUSH
93677: LD_INT 109
93679: PUSH
93680: LD_INT 110
93682: PUSH
93683: LD_INT 111
93685: PUSH
93686: LD_INT 112
93688: PUSH
93689: LD_INT 113
93691: PUSH
93692: LD_INT 114
93694: PUSH
93695: LD_INT 116
93697: PUSH
93698: LD_INT 117
93700: PUSH
93701: LD_INT 118
93703: PUSH
93704: EMPTY
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: ST_TO_ADDR
93727: GO 94966
93729: LD_INT 14
93731: DOUBLE
93732: EQUAL
93733: IFTRUE 93737
93735: GO 93961
93737: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93738: LD_ADDR_VAR 0 2
93742: PUSH
93743: LD_INT 1
93745: PUSH
93746: LD_INT 2
93748: PUSH
93749: LD_INT 3
93751: PUSH
93752: LD_INT 4
93754: PUSH
93755: LD_INT 5
93757: PUSH
93758: LD_INT 6
93760: PUSH
93761: LD_INT 7
93763: PUSH
93764: LD_INT 8
93766: PUSH
93767: LD_INT 9
93769: PUSH
93770: LD_INT 10
93772: PUSH
93773: LD_INT 11
93775: PUSH
93776: LD_INT 12
93778: PUSH
93779: LD_INT 13
93781: PUSH
93782: LD_INT 14
93784: PUSH
93785: LD_INT 15
93787: PUSH
93788: LD_INT 16
93790: PUSH
93791: LD_INT 17
93793: PUSH
93794: LD_INT 18
93796: PUSH
93797: LD_INT 19
93799: PUSH
93800: LD_INT 20
93802: PUSH
93803: LD_INT 21
93805: PUSH
93806: LD_INT 22
93808: PUSH
93809: LD_INT 23
93811: PUSH
93812: LD_INT 24
93814: PUSH
93815: LD_INT 25
93817: PUSH
93818: LD_INT 26
93820: PUSH
93821: LD_INT 27
93823: PUSH
93824: LD_INT 28
93826: PUSH
93827: LD_INT 29
93829: PUSH
93830: LD_INT 30
93832: PUSH
93833: LD_INT 31
93835: PUSH
93836: LD_INT 32
93838: PUSH
93839: LD_INT 33
93841: PUSH
93842: LD_INT 34
93844: PUSH
93845: LD_INT 36
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 101
93887: PUSH
93888: LD_INT 102
93890: PUSH
93891: LD_INT 103
93893: PUSH
93894: LD_INT 104
93896: PUSH
93897: LD_INT 105
93899: PUSH
93900: LD_INT 106
93902: PUSH
93903: LD_INT 107
93905: PUSH
93906: LD_INT 108
93908: PUSH
93909: LD_INT 109
93911: PUSH
93912: LD_INT 110
93914: PUSH
93915: LD_INT 111
93917: PUSH
93918: LD_INT 112
93920: PUSH
93921: LD_INT 113
93923: PUSH
93924: LD_INT 114
93926: PUSH
93927: LD_INT 116
93929: PUSH
93930: LD_INT 117
93932: PUSH
93933: LD_INT 118
93935: PUSH
93936: EMPTY
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: ST_TO_ADDR
93959: GO 94966
93961: LD_INT 15
93963: DOUBLE
93964: EQUAL
93965: IFTRUE 93969
93967: GO 94193
93969: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93970: LD_ADDR_VAR 0 2
93974: PUSH
93975: LD_INT 1
93977: PUSH
93978: LD_INT 2
93980: PUSH
93981: LD_INT 3
93983: PUSH
93984: LD_INT 4
93986: PUSH
93987: LD_INT 5
93989: PUSH
93990: LD_INT 6
93992: PUSH
93993: LD_INT 7
93995: PUSH
93996: LD_INT 8
93998: PUSH
93999: LD_INT 9
94001: PUSH
94002: LD_INT 10
94004: PUSH
94005: LD_INT 11
94007: PUSH
94008: LD_INT 12
94010: PUSH
94011: LD_INT 13
94013: PUSH
94014: LD_INT 14
94016: PUSH
94017: LD_INT 15
94019: PUSH
94020: LD_INT 16
94022: PUSH
94023: LD_INT 17
94025: PUSH
94026: LD_INT 18
94028: PUSH
94029: LD_INT 19
94031: PUSH
94032: LD_INT 20
94034: PUSH
94035: LD_INT 21
94037: PUSH
94038: LD_INT 22
94040: PUSH
94041: LD_INT 23
94043: PUSH
94044: LD_INT 24
94046: PUSH
94047: LD_INT 25
94049: PUSH
94050: LD_INT 26
94052: PUSH
94053: LD_INT 27
94055: PUSH
94056: LD_INT 28
94058: PUSH
94059: LD_INT 29
94061: PUSH
94062: LD_INT 30
94064: PUSH
94065: LD_INT 31
94067: PUSH
94068: LD_INT 32
94070: PUSH
94071: LD_INT 33
94073: PUSH
94074: LD_INT 34
94076: PUSH
94077: LD_INT 36
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: PUSH
94117: LD_INT 101
94119: PUSH
94120: LD_INT 102
94122: PUSH
94123: LD_INT 103
94125: PUSH
94126: LD_INT 104
94128: PUSH
94129: LD_INT 105
94131: PUSH
94132: LD_INT 106
94134: PUSH
94135: LD_INT 107
94137: PUSH
94138: LD_INT 108
94140: PUSH
94141: LD_INT 109
94143: PUSH
94144: LD_INT 110
94146: PUSH
94147: LD_INT 111
94149: PUSH
94150: LD_INT 112
94152: PUSH
94153: LD_INT 113
94155: PUSH
94156: LD_INT 114
94158: PUSH
94159: LD_INT 116
94161: PUSH
94162: LD_INT 117
94164: PUSH
94165: LD_INT 118
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: ST_TO_ADDR
94191: GO 94966
94193: LD_INT 16
94195: DOUBLE
94196: EQUAL
94197: IFTRUE 94201
94199: GO 94337
94201: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94202: LD_ADDR_VAR 0 2
94206: PUSH
94207: LD_INT 2
94209: PUSH
94210: LD_INT 4
94212: PUSH
94213: LD_INT 5
94215: PUSH
94216: LD_INT 7
94218: PUSH
94219: LD_INT 11
94221: PUSH
94222: LD_INT 12
94224: PUSH
94225: LD_INT 15
94227: PUSH
94228: LD_INT 16
94230: PUSH
94231: LD_INT 20
94233: PUSH
94234: LD_INT 21
94236: PUSH
94237: LD_INT 22
94239: PUSH
94240: LD_INT 23
94242: PUSH
94243: LD_INT 25
94245: PUSH
94246: LD_INT 26
94248: PUSH
94249: LD_INT 30
94251: PUSH
94252: LD_INT 31
94254: PUSH
94255: LD_INT 32
94257: PUSH
94258: LD_INT 33
94260: PUSH
94261: LD_INT 34
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 101
94287: PUSH
94288: LD_INT 102
94290: PUSH
94291: LD_INT 103
94293: PUSH
94294: LD_INT 106
94296: PUSH
94297: LD_INT 108
94299: PUSH
94300: LD_INT 112
94302: PUSH
94303: LD_INT 113
94305: PUSH
94306: LD_INT 114
94308: PUSH
94309: LD_INT 116
94311: PUSH
94312: LD_INT 117
94314: PUSH
94315: LD_INT 118
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: ST_TO_ADDR
94335: GO 94966
94337: LD_INT 17
94339: DOUBLE
94340: EQUAL
94341: IFTRUE 94345
94343: GO 94569
94345: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94346: LD_ADDR_VAR 0 2
94350: PUSH
94351: LD_INT 1
94353: PUSH
94354: LD_INT 2
94356: PUSH
94357: LD_INT 3
94359: PUSH
94360: LD_INT 4
94362: PUSH
94363: LD_INT 5
94365: PUSH
94366: LD_INT 6
94368: PUSH
94369: LD_INT 7
94371: PUSH
94372: LD_INT 8
94374: PUSH
94375: LD_INT 9
94377: PUSH
94378: LD_INT 10
94380: PUSH
94381: LD_INT 11
94383: PUSH
94384: LD_INT 12
94386: PUSH
94387: LD_INT 13
94389: PUSH
94390: LD_INT 14
94392: PUSH
94393: LD_INT 15
94395: PUSH
94396: LD_INT 16
94398: PUSH
94399: LD_INT 17
94401: PUSH
94402: LD_INT 18
94404: PUSH
94405: LD_INT 19
94407: PUSH
94408: LD_INT 20
94410: PUSH
94411: LD_INT 21
94413: PUSH
94414: LD_INT 22
94416: PUSH
94417: LD_INT 23
94419: PUSH
94420: LD_INT 24
94422: PUSH
94423: LD_INT 25
94425: PUSH
94426: LD_INT 26
94428: PUSH
94429: LD_INT 27
94431: PUSH
94432: LD_INT 28
94434: PUSH
94435: LD_INT 29
94437: PUSH
94438: LD_INT 30
94440: PUSH
94441: LD_INT 31
94443: PUSH
94444: LD_INT 32
94446: PUSH
94447: LD_INT 33
94449: PUSH
94450: LD_INT 34
94452: PUSH
94453: LD_INT 36
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 101
94495: PUSH
94496: LD_INT 102
94498: PUSH
94499: LD_INT 103
94501: PUSH
94502: LD_INT 104
94504: PUSH
94505: LD_INT 105
94507: PUSH
94508: LD_INT 106
94510: PUSH
94511: LD_INT 107
94513: PUSH
94514: LD_INT 108
94516: PUSH
94517: LD_INT 109
94519: PUSH
94520: LD_INT 110
94522: PUSH
94523: LD_INT 111
94525: PUSH
94526: LD_INT 112
94528: PUSH
94529: LD_INT 113
94531: PUSH
94532: LD_INT 114
94534: PUSH
94535: LD_INT 116
94537: PUSH
94538: LD_INT 117
94540: PUSH
94541: LD_INT 118
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: ST_TO_ADDR
94567: GO 94966
94569: LD_INT 18
94571: DOUBLE
94572: EQUAL
94573: IFTRUE 94577
94575: GO 94725
94577: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94578: LD_ADDR_VAR 0 2
94582: PUSH
94583: LD_INT 2
94585: PUSH
94586: LD_INT 4
94588: PUSH
94589: LD_INT 5
94591: PUSH
94592: LD_INT 7
94594: PUSH
94595: LD_INT 11
94597: PUSH
94598: LD_INT 12
94600: PUSH
94601: LD_INT 15
94603: PUSH
94604: LD_INT 16
94606: PUSH
94607: LD_INT 20
94609: PUSH
94610: LD_INT 21
94612: PUSH
94613: LD_INT 22
94615: PUSH
94616: LD_INT 23
94618: PUSH
94619: LD_INT 25
94621: PUSH
94622: LD_INT 26
94624: PUSH
94625: LD_INT 30
94627: PUSH
94628: LD_INT 31
94630: PUSH
94631: LD_INT 32
94633: PUSH
94634: LD_INT 33
94636: PUSH
94637: LD_INT 34
94639: PUSH
94640: LD_INT 35
94642: PUSH
94643: LD_INT 36
94645: PUSH
94646: EMPTY
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 101
94671: PUSH
94672: LD_INT 102
94674: PUSH
94675: LD_INT 103
94677: PUSH
94678: LD_INT 106
94680: PUSH
94681: LD_INT 108
94683: PUSH
94684: LD_INT 112
94686: PUSH
94687: LD_INT 113
94689: PUSH
94690: LD_INT 114
94692: PUSH
94693: LD_INT 115
94695: PUSH
94696: LD_INT 116
94698: PUSH
94699: LD_INT 117
94701: PUSH
94702: LD_INT 118
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: ST_TO_ADDR
94723: GO 94966
94725: LD_INT 19
94727: DOUBLE
94728: EQUAL
94729: IFTRUE 94733
94731: GO 94965
94733: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94734: LD_ADDR_VAR 0 2
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: LD_INT 2
94744: PUSH
94745: LD_INT 3
94747: PUSH
94748: LD_INT 4
94750: PUSH
94751: LD_INT 5
94753: PUSH
94754: LD_INT 6
94756: PUSH
94757: LD_INT 7
94759: PUSH
94760: LD_INT 8
94762: PUSH
94763: LD_INT 9
94765: PUSH
94766: LD_INT 10
94768: PUSH
94769: LD_INT 11
94771: PUSH
94772: LD_INT 12
94774: PUSH
94775: LD_INT 13
94777: PUSH
94778: LD_INT 14
94780: PUSH
94781: LD_INT 15
94783: PUSH
94784: LD_INT 16
94786: PUSH
94787: LD_INT 17
94789: PUSH
94790: LD_INT 18
94792: PUSH
94793: LD_INT 19
94795: PUSH
94796: LD_INT 20
94798: PUSH
94799: LD_INT 21
94801: PUSH
94802: LD_INT 22
94804: PUSH
94805: LD_INT 23
94807: PUSH
94808: LD_INT 24
94810: PUSH
94811: LD_INT 25
94813: PUSH
94814: LD_INT 26
94816: PUSH
94817: LD_INT 27
94819: PUSH
94820: LD_INT 28
94822: PUSH
94823: LD_INT 29
94825: PUSH
94826: LD_INT 30
94828: PUSH
94829: LD_INT 31
94831: PUSH
94832: LD_INT 32
94834: PUSH
94835: LD_INT 33
94837: PUSH
94838: LD_INT 34
94840: PUSH
94841: LD_INT 35
94843: PUSH
94844: LD_INT 36
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 101
94887: PUSH
94888: LD_INT 102
94890: PUSH
94891: LD_INT 103
94893: PUSH
94894: LD_INT 104
94896: PUSH
94897: LD_INT 105
94899: PUSH
94900: LD_INT 106
94902: PUSH
94903: LD_INT 107
94905: PUSH
94906: LD_INT 108
94908: PUSH
94909: LD_INT 109
94911: PUSH
94912: LD_INT 110
94914: PUSH
94915: LD_INT 111
94917: PUSH
94918: LD_INT 112
94920: PUSH
94921: LD_INT 113
94923: PUSH
94924: LD_INT 114
94926: PUSH
94927: LD_INT 115
94929: PUSH
94930: LD_INT 116
94932: PUSH
94933: LD_INT 117
94935: PUSH
94936: LD_INT 118
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: ST_TO_ADDR
94963: GO 94966
94965: POP
// end else
94966: GO 95197
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94968: LD_ADDR_VAR 0 2
94972: PUSH
94973: LD_INT 1
94975: PUSH
94976: LD_INT 2
94978: PUSH
94979: LD_INT 3
94981: PUSH
94982: LD_INT 4
94984: PUSH
94985: LD_INT 5
94987: PUSH
94988: LD_INT 6
94990: PUSH
94991: LD_INT 7
94993: PUSH
94994: LD_INT 8
94996: PUSH
94997: LD_INT 9
94999: PUSH
95000: LD_INT 10
95002: PUSH
95003: LD_INT 11
95005: PUSH
95006: LD_INT 12
95008: PUSH
95009: LD_INT 13
95011: PUSH
95012: LD_INT 14
95014: PUSH
95015: LD_INT 15
95017: PUSH
95018: LD_INT 16
95020: PUSH
95021: LD_INT 17
95023: PUSH
95024: LD_INT 18
95026: PUSH
95027: LD_INT 19
95029: PUSH
95030: LD_INT 20
95032: PUSH
95033: LD_INT 21
95035: PUSH
95036: LD_INT 22
95038: PUSH
95039: LD_INT 23
95041: PUSH
95042: LD_INT 24
95044: PUSH
95045: LD_INT 25
95047: PUSH
95048: LD_INT 26
95050: PUSH
95051: LD_INT 27
95053: PUSH
95054: LD_INT 28
95056: PUSH
95057: LD_INT 29
95059: PUSH
95060: LD_INT 30
95062: PUSH
95063: LD_INT 31
95065: PUSH
95066: LD_INT 32
95068: PUSH
95069: LD_INT 33
95071: PUSH
95072: LD_INT 34
95074: PUSH
95075: LD_INT 35
95077: PUSH
95078: LD_INT 36
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 101
95121: PUSH
95122: LD_INT 102
95124: PUSH
95125: LD_INT 103
95127: PUSH
95128: LD_INT 104
95130: PUSH
95131: LD_INT 105
95133: PUSH
95134: LD_INT 106
95136: PUSH
95137: LD_INT 107
95139: PUSH
95140: LD_INT 108
95142: PUSH
95143: LD_INT 109
95145: PUSH
95146: LD_INT 110
95148: PUSH
95149: LD_INT 111
95151: PUSH
95152: LD_INT 112
95154: PUSH
95155: LD_INT 113
95157: PUSH
95158: LD_INT 114
95160: PUSH
95161: LD_INT 115
95163: PUSH
95164: LD_INT 116
95166: PUSH
95167: LD_INT 117
95169: PUSH
95170: LD_INT 118
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: ST_TO_ADDR
// if result then
95197: LD_VAR 0 2
95201: IFFALSE 95987
// begin normal :=  ;
95203: LD_ADDR_VAR 0 5
95207: PUSH
95208: LD_STRING 
95210: ST_TO_ADDR
// hardcore :=  ;
95211: LD_ADDR_VAR 0 6
95215: PUSH
95216: LD_STRING 
95218: ST_TO_ADDR
// active :=  ;
95219: LD_ADDR_VAR 0 7
95223: PUSH
95224: LD_STRING 
95226: ST_TO_ADDR
// for i = 1 to normalCounter do
95227: LD_ADDR_VAR 0 8
95231: PUSH
95232: DOUBLE
95233: LD_INT 1
95235: DEC
95236: ST_TO_ADDR
95237: LD_EXP 108
95241: PUSH
95242: FOR_TO
95243: IFFALSE 95344
// begin tmp := 0 ;
95245: LD_ADDR_VAR 0 3
95249: PUSH
95250: LD_STRING 0
95252: ST_TO_ADDR
// if result [ 1 ] then
95253: LD_VAR 0 2
95257: PUSH
95258: LD_INT 1
95260: ARRAY
95261: IFFALSE 95326
// if result [ 1 ] [ 1 ] = i then
95263: LD_VAR 0 2
95267: PUSH
95268: LD_INT 1
95270: ARRAY
95271: PUSH
95272: LD_INT 1
95274: ARRAY
95275: PUSH
95276: LD_VAR 0 8
95280: EQUAL
95281: IFFALSE 95326
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95283: LD_ADDR_VAR 0 2
95287: PUSH
95288: LD_VAR 0 2
95292: PPUSH
95293: LD_INT 1
95295: PPUSH
95296: LD_VAR 0 2
95300: PUSH
95301: LD_INT 1
95303: ARRAY
95304: PPUSH
95305: LD_INT 1
95307: PPUSH
95308: CALL_OW 3
95312: PPUSH
95313: CALL_OW 1
95317: ST_TO_ADDR
// tmp := 1 ;
95318: LD_ADDR_VAR 0 3
95322: PUSH
95323: LD_STRING 1
95325: ST_TO_ADDR
// end ; normal := normal & tmp ;
95326: LD_ADDR_VAR 0 5
95330: PUSH
95331: LD_VAR 0 5
95335: PUSH
95336: LD_VAR 0 3
95340: STR
95341: ST_TO_ADDR
// end ;
95342: GO 95242
95344: POP
95345: POP
// for i = 1 to hardcoreCounter do
95346: LD_ADDR_VAR 0 8
95350: PUSH
95351: DOUBLE
95352: LD_INT 1
95354: DEC
95355: ST_TO_ADDR
95356: LD_EXP 109
95360: PUSH
95361: FOR_TO
95362: IFFALSE 95467
// begin tmp := 0 ;
95364: LD_ADDR_VAR 0 3
95368: PUSH
95369: LD_STRING 0
95371: ST_TO_ADDR
// if result [ 2 ] then
95372: LD_VAR 0 2
95376: PUSH
95377: LD_INT 2
95379: ARRAY
95380: IFFALSE 95449
// if result [ 2 ] [ 1 ] = 100 + i then
95382: LD_VAR 0 2
95386: PUSH
95387: LD_INT 2
95389: ARRAY
95390: PUSH
95391: LD_INT 1
95393: ARRAY
95394: PUSH
95395: LD_INT 100
95397: PUSH
95398: LD_VAR 0 8
95402: PLUS
95403: EQUAL
95404: IFFALSE 95449
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95406: LD_ADDR_VAR 0 2
95410: PUSH
95411: LD_VAR 0 2
95415: PPUSH
95416: LD_INT 2
95418: PPUSH
95419: LD_VAR 0 2
95423: PUSH
95424: LD_INT 2
95426: ARRAY
95427: PPUSH
95428: LD_INT 1
95430: PPUSH
95431: CALL_OW 3
95435: PPUSH
95436: CALL_OW 1
95440: ST_TO_ADDR
// tmp := 1 ;
95441: LD_ADDR_VAR 0 3
95445: PUSH
95446: LD_STRING 1
95448: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95449: LD_ADDR_VAR 0 6
95453: PUSH
95454: LD_VAR 0 6
95458: PUSH
95459: LD_VAR 0 3
95463: STR
95464: ST_TO_ADDR
// end ;
95465: GO 95361
95467: POP
95468: POP
// if isGameLoad then
95469: LD_VAR 0 1
95473: IFFALSE 95948
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95475: LD_ADDR_VAR 0 4
95479: PUSH
95480: LD_EXP 112
95484: PUSH
95485: LD_EXP 111
95489: PUSH
95490: LD_EXP 113
95494: PUSH
95495: LD_EXP 110
95499: PUSH
95500: LD_EXP 114
95504: PUSH
95505: LD_EXP 115
95509: PUSH
95510: LD_EXP 116
95514: PUSH
95515: LD_EXP 117
95519: PUSH
95520: LD_EXP 118
95524: PUSH
95525: LD_EXP 119
95529: PUSH
95530: LD_EXP 120
95534: PUSH
95535: LD_EXP 121
95539: PUSH
95540: LD_EXP 122
95544: PUSH
95545: LD_EXP 123
95549: PUSH
95550: LD_EXP 131
95554: PUSH
95555: LD_EXP 132
95559: PUSH
95560: LD_EXP 133
95564: PUSH
95565: LD_EXP 134
95569: PUSH
95570: LD_EXP 136
95574: PUSH
95575: LD_EXP 137
95579: PUSH
95580: LD_EXP 138
95584: PUSH
95585: LD_EXP 141
95589: PUSH
95590: LD_EXP 143
95594: PUSH
95595: LD_EXP 144
95599: PUSH
95600: LD_EXP 145
95604: PUSH
95605: LD_EXP 147
95609: PUSH
95610: LD_EXP 148
95614: PUSH
95615: LD_EXP 151
95619: PUSH
95620: LD_EXP 152
95624: PUSH
95625: LD_EXP 153
95629: PUSH
95630: LD_EXP 154
95634: PUSH
95635: LD_EXP 155
95639: PUSH
95640: LD_EXP 156
95644: PUSH
95645: LD_EXP 157
95649: PUSH
95650: LD_EXP 158
95654: PUSH
95655: LD_EXP 159
95659: PUSH
95660: LD_EXP 124
95664: PUSH
95665: LD_EXP 125
95669: PUSH
95670: LD_EXP 128
95674: PUSH
95675: LD_EXP 129
95679: PUSH
95680: LD_EXP 130
95684: PUSH
95685: LD_EXP 126
95689: PUSH
95690: LD_EXP 127
95694: PUSH
95695: LD_EXP 135
95699: PUSH
95700: LD_EXP 139
95704: PUSH
95705: LD_EXP 140
95709: PUSH
95710: LD_EXP 142
95714: PUSH
95715: LD_EXP 146
95719: PUSH
95720: LD_EXP 149
95724: PUSH
95725: LD_EXP 150
95729: PUSH
95730: LD_EXP 160
95734: PUSH
95735: LD_EXP 161
95739: PUSH
95740: LD_EXP 162
95744: PUSH
95745: LD_EXP 163
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: ST_TO_ADDR
// tmp :=  ;
95806: LD_ADDR_VAR 0 3
95810: PUSH
95811: LD_STRING 
95813: ST_TO_ADDR
// for i = 1 to normalCounter do
95814: LD_ADDR_VAR 0 8
95818: PUSH
95819: DOUBLE
95820: LD_INT 1
95822: DEC
95823: ST_TO_ADDR
95824: LD_EXP 108
95828: PUSH
95829: FOR_TO
95830: IFFALSE 95866
// begin if flags [ i ] then
95832: LD_VAR 0 4
95836: PUSH
95837: LD_VAR 0 8
95841: ARRAY
95842: IFFALSE 95864
// tmp := tmp & i & ; ;
95844: LD_ADDR_VAR 0 3
95848: PUSH
95849: LD_VAR 0 3
95853: PUSH
95854: LD_VAR 0 8
95858: STR
95859: PUSH
95860: LD_STRING ;
95862: STR
95863: ST_TO_ADDR
// end ;
95864: GO 95829
95866: POP
95867: POP
// for i = 1 to hardcoreCounter do
95868: LD_ADDR_VAR 0 8
95872: PUSH
95873: DOUBLE
95874: LD_INT 1
95876: DEC
95877: ST_TO_ADDR
95878: LD_EXP 109
95882: PUSH
95883: FOR_TO
95884: IFFALSE 95930
// begin if flags [ normalCounter + i ] then
95886: LD_VAR 0 4
95890: PUSH
95891: LD_EXP 108
95895: PUSH
95896: LD_VAR 0 8
95900: PLUS
95901: ARRAY
95902: IFFALSE 95928
// tmp := tmp & ( 100 + i ) & ; ;
95904: LD_ADDR_VAR 0 3
95908: PUSH
95909: LD_VAR 0 3
95913: PUSH
95914: LD_INT 100
95916: PUSH
95917: LD_VAR 0 8
95921: PLUS
95922: STR
95923: PUSH
95924: LD_STRING ;
95926: STR
95927: ST_TO_ADDR
// end ;
95928: GO 95883
95930: POP
95931: POP
// if tmp then
95932: LD_VAR 0 3
95936: IFFALSE 95948
// active := tmp ;
95938: LD_ADDR_VAR 0 7
95942: PUSH
95943: LD_VAR 0 3
95947: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95948: LD_STRING getStreamItemsFromMission("
95950: PUSH
95951: LD_VAR 0 5
95955: STR
95956: PUSH
95957: LD_STRING ","
95959: STR
95960: PUSH
95961: LD_VAR 0 6
95965: STR
95966: PUSH
95967: LD_STRING ","
95969: STR
95970: PUSH
95971: LD_VAR 0 7
95975: STR
95976: PUSH
95977: LD_STRING ")
95979: STR
95980: PPUSH
95981: CALL_OW 559
// end else
95985: GO 95994
// ToLua ( getStreamItemsFromMission("","","") ) ;
95987: LD_STRING getStreamItemsFromMission("","","")
95989: PPUSH
95990: CALL_OW 559
// end ;
95994: LD_VAR 0 2
95998: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95999: LD_EXP 107
96003: PUSH
96004: LD_EXP 112
96008: AND
96009: IFFALSE 96133
96011: GO 96013
96013: DISABLE
96014: LD_INT 0
96016: PPUSH
96017: PPUSH
// begin enable ;
96018: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96019: LD_ADDR_VAR 0 2
96023: PUSH
96024: LD_INT 22
96026: PUSH
96027: LD_OWVAR 2
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 2
96038: PUSH
96039: LD_INT 34
96041: PUSH
96042: LD_INT 7
96044: PUSH
96045: EMPTY
96046: LIST
96047: LIST
96048: PUSH
96049: LD_INT 34
96051: PUSH
96052: LD_INT 45
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 34
96061: PUSH
96062: LD_INT 28
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 34
96071: PUSH
96072: LD_INT 47
96074: PUSH
96075: EMPTY
96076: LIST
96077: LIST
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: PUSH
96086: EMPTY
96087: LIST
96088: LIST
96089: PPUSH
96090: CALL_OW 69
96094: ST_TO_ADDR
// if not tmp then
96095: LD_VAR 0 2
96099: NOT
96100: IFFALSE 96104
// exit ;
96102: GO 96133
// for i in tmp do
96104: LD_ADDR_VAR 0 1
96108: PUSH
96109: LD_VAR 0 2
96113: PUSH
96114: FOR_IN
96115: IFFALSE 96131
// begin SetLives ( i , 0 ) ;
96117: LD_VAR 0 1
96121: PPUSH
96122: LD_INT 0
96124: PPUSH
96125: CALL_OW 234
// end ;
96129: GO 96114
96131: POP
96132: POP
// end ;
96133: PPOPN 2
96135: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96136: LD_EXP 107
96140: PUSH
96141: LD_EXP 113
96145: AND
96146: IFFALSE 96230
96148: GO 96150
96150: DISABLE
96151: LD_INT 0
96153: PPUSH
96154: PPUSH
// begin enable ;
96155: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96156: LD_ADDR_VAR 0 2
96160: PUSH
96161: LD_INT 22
96163: PUSH
96164: LD_OWVAR 2
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 32
96175: PUSH
96176: LD_INT 3
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PPUSH
96187: CALL_OW 69
96191: ST_TO_ADDR
// if not tmp then
96192: LD_VAR 0 2
96196: NOT
96197: IFFALSE 96201
// exit ;
96199: GO 96230
// for i in tmp do
96201: LD_ADDR_VAR 0 1
96205: PUSH
96206: LD_VAR 0 2
96210: PUSH
96211: FOR_IN
96212: IFFALSE 96228
// begin SetLives ( i , 0 ) ;
96214: LD_VAR 0 1
96218: PPUSH
96219: LD_INT 0
96221: PPUSH
96222: CALL_OW 234
// end ;
96226: GO 96211
96228: POP
96229: POP
// end ;
96230: PPOPN 2
96232: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96233: LD_EXP 107
96237: PUSH
96238: LD_EXP 110
96242: AND
96243: IFFALSE 96336
96245: GO 96247
96247: DISABLE
96248: LD_INT 0
96250: PPUSH
// begin enable ;
96251: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96252: LD_ADDR_VAR 0 1
96256: PUSH
96257: LD_INT 22
96259: PUSH
96260: LD_OWVAR 2
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 2
96271: PUSH
96272: LD_INT 25
96274: PUSH
96275: LD_INT 5
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 25
96284: PUSH
96285: LD_INT 9
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: LD_INT 25
96294: PUSH
96295: LD_INT 8
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PPUSH
96312: CALL_OW 69
96316: PUSH
96317: FOR_IN
96318: IFFALSE 96334
// begin SetClass ( i , 1 ) ;
96320: LD_VAR 0 1
96324: PPUSH
96325: LD_INT 1
96327: PPUSH
96328: CALL_OW 336
// end ;
96332: GO 96317
96334: POP
96335: POP
// end ;
96336: PPOPN 1
96338: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96339: LD_EXP 107
96343: PUSH
96344: LD_EXP 111
96348: AND
96349: PUSH
96350: LD_OWVAR 65
96354: PUSH
96355: LD_INT 7
96357: LESS
96358: AND
96359: IFFALSE 96373
96361: GO 96363
96363: DISABLE
// begin enable ;
96364: ENABLE
// game_speed := 7 ;
96365: LD_ADDR_OWVAR 65
96369: PUSH
96370: LD_INT 7
96372: ST_TO_ADDR
// end ;
96373: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96374: LD_EXP 107
96378: PUSH
96379: LD_EXP 114
96383: AND
96384: IFFALSE 96586
96386: GO 96388
96388: DISABLE
96389: LD_INT 0
96391: PPUSH
96392: PPUSH
96393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96394: LD_ADDR_VAR 0 3
96398: PUSH
96399: LD_INT 81
96401: PUSH
96402: LD_OWVAR 2
96406: PUSH
96407: EMPTY
96408: LIST
96409: LIST
96410: PUSH
96411: LD_INT 21
96413: PUSH
96414: LD_INT 1
96416: PUSH
96417: EMPTY
96418: LIST
96419: LIST
96420: PUSH
96421: EMPTY
96422: LIST
96423: LIST
96424: PPUSH
96425: CALL_OW 69
96429: ST_TO_ADDR
// if not tmp then
96430: LD_VAR 0 3
96434: NOT
96435: IFFALSE 96439
// exit ;
96437: GO 96586
// if tmp > 5 then
96439: LD_VAR 0 3
96443: PUSH
96444: LD_INT 5
96446: GREATER
96447: IFFALSE 96459
// k := 5 else
96449: LD_ADDR_VAR 0 2
96453: PUSH
96454: LD_INT 5
96456: ST_TO_ADDR
96457: GO 96469
// k := tmp ;
96459: LD_ADDR_VAR 0 2
96463: PUSH
96464: LD_VAR 0 3
96468: ST_TO_ADDR
// for i := 1 to k do
96469: LD_ADDR_VAR 0 1
96473: PUSH
96474: DOUBLE
96475: LD_INT 1
96477: DEC
96478: ST_TO_ADDR
96479: LD_VAR 0 2
96483: PUSH
96484: FOR_TO
96485: IFFALSE 96584
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96487: LD_VAR 0 3
96491: PUSH
96492: LD_VAR 0 1
96496: ARRAY
96497: PPUSH
96498: LD_VAR 0 1
96502: PUSH
96503: LD_INT 4
96505: MOD
96506: PUSH
96507: LD_INT 1
96509: PLUS
96510: PPUSH
96511: CALL_OW 259
96515: PUSH
96516: LD_INT 10
96518: LESS
96519: IFFALSE 96582
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96521: LD_VAR 0 3
96525: PUSH
96526: LD_VAR 0 1
96530: ARRAY
96531: PPUSH
96532: LD_VAR 0 1
96536: PUSH
96537: LD_INT 4
96539: MOD
96540: PUSH
96541: LD_INT 1
96543: PLUS
96544: PPUSH
96545: LD_VAR 0 3
96549: PUSH
96550: LD_VAR 0 1
96554: ARRAY
96555: PPUSH
96556: LD_VAR 0 1
96560: PUSH
96561: LD_INT 4
96563: MOD
96564: PUSH
96565: LD_INT 1
96567: PLUS
96568: PPUSH
96569: CALL_OW 259
96573: PUSH
96574: LD_INT 1
96576: PLUS
96577: PPUSH
96578: CALL_OW 237
96582: GO 96484
96584: POP
96585: POP
// end ;
96586: PPOPN 3
96588: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96589: LD_EXP 107
96593: PUSH
96594: LD_EXP 115
96598: AND
96599: IFFALSE 96619
96601: GO 96603
96603: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96604: LD_INT 4
96606: PPUSH
96607: LD_OWVAR 2
96611: PPUSH
96612: LD_INT 0
96614: PPUSH
96615: CALL_OW 324
96619: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96620: LD_EXP 107
96624: PUSH
96625: LD_EXP 144
96629: AND
96630: IFFALSE 96650
96632: GO 96634
96634: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96635: LD_INT 19
96637: PPUSH
96638: LD_OWVAR 2
96642: PPUSH
96643: LD_INT 0
96645: PPUSH
96646: CALL_OW 324
96650: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96651: LD_EXP 107
96655: PUSH
96656: LD_EXP 116
96660: AND
96661: IFFALSE 96763
96663: GO 96665
96665: DISABLE
96666: LD_INT 0
96668: PPUSH
96669: PPUSH
// begin enable ;
96670: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96671: LD_ADDR_VAR 0 2
96675: PUSH
96676: LD_INT 22
96678: PUSH
96679: LD_OWVAR 2
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 2
96690: PUSH
96691: LD_INT 34
96693: PUSH
96694: LD_INT 11
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: PUSH
96701: LD_INT 34
96703: PUSH
96704: LD_INT 30
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: LIST
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PPUSH
96720: CALL_OW 69
96724: ST_TO_ADDR
// if not tmp then
96725: LD_VAR 0 2
96729: NOT
96730: IFFALSE 96734
// exit ;
96732: GO 96763
// for i in tmp do
96734: LD_ADDR_VAR 0 1
96738: PUSH
96739: LD_VAR 0 2
96743: PUSH
96744: FOR_IN
96745: IFFALSE 96761
// begin SetLives ( i , 0 ) ;
96747: LD_VAR 0 1
96751: PPUSH
96752: LD_INT 0
96754: PPUSH
96755: CALL_OW 234
// end ;
96759: GO 96744
96761: POP
96762: POP
// end ;
96763: PPOPN 2
96765: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96766: LD_EXP 107
96770: PUSH
96771: LD_EXP 117
96775: AND
96776: IFFALSE 96796
96778: GO 96780
96780: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96781: LD_INT 32
96783: PPUSH
96784: LD_OWVAR 2
96788: PPUSH
96789: LD_INT 0
96791: PPUSH
96792: CALL_OW 324
96796: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96797: LD_EXP 107
96801: PUSH
96802: LD_EXP 118
96806: AND
96807: IFFALSE 96988
96809: GO 96811
96811: DISABLE
96812: LD_INT 0
96814: PPUSH
96815: PPUSH
96816: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96817: LD_ADDR_VAR 0 2
96821: PUSH
96822: LD_INT 22
96824: PUSH
96825: LD_OWVAR 2
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 33
96836: PUSH
96837: LD_INT 3
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PPUSH
96848: CALL_OW 69
96852: ST_TO_ADDR
// if not tmp then
96853: LD_VAR 0 2
96857: NOT
96858: IFFALSE 96862
// exit ;
96860: GO 96988
// side := 0 ;
96862: LD_ADDR_VAR 0 3
96866: PUSH
96867: LD_INT 0
96869: ST_TO_ADDR
// for i := 1 to 8 do
96870: LD_ADDR_VAR 0 1
96874: PUSH
96875: DOUBLE
96876: LD_INT 1
96878: DEC
96879: ST_TO_ADDR
96880: LD_INT 8
96882: PUSH
96883: FOR_TO
96884: IFFALSE 96932
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96886: LD_OWVAR 2
96890: PUSH
96891: LD_VAR 0 1
96895: NONEQUAL
96896: PUSH
96897: LD_OWVAR 2
96901: PPUSH
96902: LD_VAR 0 1
96906: PPUSH
96907: CALL_OW 81
96911: PUSH
96912: LD_INT 2
96914: EQUAL
96915: AND
96916: IFFALSE 96930
// begin side := i ;
96918: LD_ADDR_VAR 0 3
96922: PUSH
96923: LD_VAR 0 1
96927: ST_TO_ADDR
// break ;
96928: GO 96932
// end ;
96930: GO 96883
96932: POP
96933: POP
// if not side then
96934: LD_VAR 0 3
96938: NOT
96939: IFFALSE 96943
// exit ;
96941: GO 96988
// for i := 1 to tmp do
96943: LD_ADDR_VAR 0 1
96947: PUSH
96948: DOUBLE
96949: LD_INT 1
96951: DEC
96952: ST_TO_ADDR
96953: LD_VAR 0 2
96957: PUSH
96958: FOR_TO
96959: IFFALSE 96986
// if Prob ( 60 ) then
96961: LD_INT 60
96963: PPUSH
96964: CALL_OW 13
96968: IFFALSE 96984
// SetSide ( i , side ) ;
96970: LD_VAR 0 1
96974: PPUSH
96975: LD_VAR 0 3
96979: PPUSH
96980: CALL_OW 235
96984: GO 96958
96986: POP
96987: POP
// end ;
96988: PPOPN 3
96990: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96991: LD_EXP 107
96995: PUSH
96996: LD_EXP 120
97000: AND
97001: IFFALSE 97120
97003: GO 97005
97005: DISABLE
97006: LD_INT 0
97008: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97009: LD_ADDR_VAR 0 1
97013: PUSH
97014: LD_INT 22
97016: PUSH
97017: LD_OWVAR 2
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 21
97028: PUSH
97029: LD_INT 1
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: LD_INT 3
97038: PUSH
97039: LD_INT 23
97041: PUSH
97042: LD_INT 0
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: LIST
97057: PPUSH
97058: CALL_OW 69
97062: PUSH
97063: FOR_IN
97064: IFFALSE 97118
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97066: LD_VAR 0 1
97070: PPUSH
97071: CALL_OW 257
97075: PUSH
97076: LD_INT 1
97078: PUSH
97079: LD_INT 2
97081: PUSH
97082: LD_INT 3
97084: PUSH
97085: LD_INT 4
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: IN
97094: IFFALSE 97116
// SetClass ( un , rand ( 1 , 4 ) ) ;
97096: LD_VAR 0 1
97100: PPUSH
97101: LD_INT 1
97103: PPUSH
97104: LD_INT 4
97106: PPUSH
97107: CALL_OW 12
97111: PPUSH
97112: CALL_OW 336
97116: GO 97063
97118: POP
97119: POP
// end ;
97120: PPOPN 1
97122: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97123: LD_EXP 107
97127: PUSH
97128: LD_EXP 119
97132: AND
97133: IFFALSE 97212
97135: GO 97137
97137: DISABLE
97138: LD_INT 0
97140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97141: LD_ADDR_VAR 0 1
97145: PUSH
97146: LD_INT 22
97148: PUSH
97149: LD_OWVAR 2
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 21
97160: PUSH
97161: LD_INT 3
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PPUSH
97172: CALL_OW 69
97176: ST_TO_ADDR
// if not tmp then
97177: LD_VAR 0 1
97181: NOT
97182: IFFALSE 97186
// exit ;
97184: GO 97212
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97186: LD_VAR 0 1
97190: PUSH
97191: LD_INT 1
97193: PPUSH
97194: LD_VAR 0 1
97198: PPUSH
97199: CALL_OW 12
97203: ARRAY
97204: PPUSH
97205: LD_INT 100
97207: PPUSH
97208: CALL_OW 234
// end ;
97212: PPOPN 1
97214: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97215: LD_EXP 107
97219: PUSH
97220: LD_EXP 121
97224: AND
97225: IFFALSE 97323
97227: GO 97229
97229: DISABLE
97230: LD_INT 0
97232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97233: LD_ADDR_VAR 0 1
97237: PUSH
97238: LD_INT 22
97240: PUSH
97241: LD_OWVAR 2
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: LD_INT 21
97252: PUSH
97253: LD_INT 1
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PPUSH
97264: CALL_OW 69
97268: ST_TO_ADDR
// if not tmp then
97269: LD_VAR 0 1
97273: NOT
97274: IFFALSE 97278
// exit ;
97276: GO 97323
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97278: LD_VAR 0 1
97282: PUSH
97283: LD_INT 1
97285: PPUSH
97286: LD_VAR 0 1
97290: PPUSH
97291: CALL_OW 12
97295: ARRAY
97296: PPUSH
97297: LD_INT 1
97299: PPUSH
97300: LD_INT 4
97302: PPUSH
97303: CALL_OW 12
97307: PPUSH
97308: LD_INT 3000
97310: PPUSH
97311: LD_INT 9000
97313: PPUSH
97314: CALL_OW 12
97318: PPUSH
97319: CALL_OW 492
// end ;
97323: PPOPN 1
97325: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97326: LD_EXP 107
97330: PUSH
97331: LD_EXP 122
97335: AND
97336: IFFALSE 97356
97338: GO 97340
97340: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97341: LD_INT 1
97343: PPUSH
97344: LD_OWVAR 2
97348: PPUSH
97349: LD_INT 0
97351: PPUSH
97352: CALL_OW 324
97356: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97357: LD_EXP 107
97361: PUSH
97362: LD_EXP 123
97366: AND
97367: IFFALSE 97450
97369: GO 97371
97371: DISABLE
97372: LD_INT 0
97374: PPUSH
97375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97376: LD_ADDR_VAR 0 2
97380: PUSH
97381: LD_INT 22
97383: PUSH
97384: LD_OWVAR 2
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 21
97395: PUSH
97396: LD_INT 3
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PPUSH
97407: CALL_OW 69
97411: ST_TO_ADDR
// if not tmp then
97412: LD_VAR 0 2
97416: NOT
97417: IFFALSE 97421
// exit ;
97419: GO 97450
// for i in tmp do
97421: LD_ADDR_VAR 0 1
97425: PUSH
97426: LD_VAR 0 2
97430: PUSH
97431: FOR_IN
97432: IFFALSE 97448
// SetBLevel ( i , 10 ) ;
97434: LD_VAR 0 1
97438: PPUSH
97439: LD_INT 10
97441: PPUSH
97442: CALL_OW 241
97446: GO 97431
97448: POP
97449: POP
// end ;
97450: PPOPN 2
97452: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97453: LD_EXP 107
97457: PUSH
97458: LD_EXP 124
97462: AND
97463: IFFALSE 97574
97465: GO 97467
97467: DISABLE
97468: LD_INT 0
97470: PPUSH
97471: PPUSH
97472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97473: LD_ADDR_VAR 0 3
97477: PUSH
97478: LD_INT 22
97480: PUSH
97481: LD_OWVAR 2
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 25
97492: PUSH
97493: LD_INT 1
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PPUSH
97504: CALL_OW 69
97508: ST_TO_ADDR
// if not tmp then
97509: LD_VAR 0 3
97513: NOT
97514: IFFALSE 97518
// exit ;
97516: GO 97574
// un := tmp [ rand ( 1 , tmp ) ] ;
97518: LD_ADDR_VAR 0 2
97522: PUSH
97523: LD_VAR 0 3
97527: PUSH
97528: LD_INT 1
97530: PPUSH
97531: LD_VAR 0 3
97535: PPUSH
97536: CALL_OW 12
97540: ARRAY
97541: ST_TO_ADDR
// if Crawls ( un ) then
97542: LD_VAR 0 2
97546: PPUSH
97547: CALL_OW 318
97551: IFFALSE 97562
// ComWalk ( un ) ;
97553: LD_VAR 0 2
97557: PPUSH
97558: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97562: LD_VAR 0 2
97566: PPUSH
97567: LD_INT 5
97569: PPUSH
97570: CALL_OW 336
// end ;
97574: PPOPN 3
97576: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97577: LD_EXP 107
97581: PUSH
97582: LD_EXP 125
97586: AND
97587: PUSH
97588: LD_OWVAR 67
97592: PUSH
97593: LD_INT 4
97595: LESS
97596: AND
97597: IFFALSE 97616
97599: GO 97601
97601: DISABLE
// begin Difficulty := Difficulty + 1 ;
97602: LD_ADDR_OWVAR 67
97606: PUSH
97607: LD_OWVAR 67
97611: PUSH
97612: LD_INT 1
97614: PLUS
97615: ST_TO_ADDR
// end ;
97616: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97617: LD_EXP 107
97621: PUSH
97622: LD_EXP 126
97626: AND
97627: IFFALSE 97730
97629: GO 97631
97631: DISABLE
97632: LD_INT 0
97634: PPUSH
// begin for i := 1 to 5 do
97635: LD_ADDR_VAR 0 1
97639: PUSH
97640: DOUBLE
97641: LD_INT 1
97643: DEC
97644: ST_TO_ADDR
97645: LD_INT 5
97647: PUSH
97648: FOR_TO
97649: IFFALSE 97728
// begin uc_nation := nation_nature ;
97651: LD_ADDR_OWVAR 21
97655: PUSH
97656: LD_INT 0
97658: ST_TO_ADDR
// uc_side := 0 ;
97659: LD_ADDR_OWVAR 20
97663: PUSH
97664: LD_INT 0
97666: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97667: LD_ADDR_OWVAR 29
97671: PUSH
97672: LD_INT 12
97674: PUSH
97675: LD_INT 12
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: ST_TO_ADDR
// hc_agressivity := 20 ;
97682: LD_ADDR_OWVAR 35
97686: PUSH
97687: LD_INT 20
97689: ST_TO_ADDR
// hc_class := class_tiger ;
97690: LD_ADDR_OWVAR 28
97694: PUSH
97695: LD_INT 14
97697: ST_TO_ADDR
// hc_gallery :=  ;
97698: LD_ADDR_OWVAR 33
97702: PUSH
97703: LD_STRING 
97705: ST_TO_ADDR
// hc_name :=  ;
97706: LD_ADDR_OWVAR 26
97710: PUSH
97711: LD_STRING 
97713: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97714: CALL_OW 44
97718: PPUSH
97719: LD_INT 0
97721: PPUSH
97722: CALL_OW 51
// end ;
97726: GO 97648
97728: POP
97729: POP
// end ;
97730: PPOPN 1
97732: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97733: LD_EXP 107
97737: PUSH
97738: LD_EXP 127
97742: AND
97743: IFFALSE 97752
97745: GO 97747
97747: DISABLE
// StreamSibBomb ;
97748: CALL 97753 0 0
97752: END
// export function StreamSibBomb ; var i , x , y ; begin
97753: LD_INT 0
97755: PPUSH
97756: PPUSH
97757: PPUSH
97758: PPUSH
// result := false ;
97759: LD_ADDR_VAR 0 1
97763: PUSH
97764: LD_INT 0
97766: ST_TO_ADDR
// for i := 1 to 16 do
97767: LD_ADDR_VAR 0 2
97771: PUSH
97772: DOUBLE
97773: LD_INT 1
97775: DEC
97776: ST_TO_ADDR
97777: LD_INT 16
97779: PUSH
97780: FOR_TO
97781: IFFALSE 97980
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97783: LD_ADDR_VAR 0 3
97787: PUSH
97788: LD_INT 10
97790: PUSH
97791: LD_INT 20
97793: PUSH
97794: LD_INT 30
97796: PUSH
97797: LD_INT 40
97799: PUSH
97800: LD_INT 50
97802: PUSH
97803: LD_INT 60
97805: PUSH
97806: LD_INT 70
97808: PUSH
97809: LD_INT 80
97811: PUSH
97812: LD_INT 90
97814: PUSH
97815: LD_INT 100
97817: PUSH
97818: LD_INT 110
97820: PUSH
97821: LD_INT 120
97823: PUSH
97824: LD_INT 130
97826: PUSH
97827: LD_INT 140
97829: PUSH
97830: LD_INT 150
97832: PUSH
97833: EMPTY
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: PUSH
97850: LD_INT 1
97852: PPUSH
97853: LD_INT 15
97855: PPUSH
97856: CALL_OW 12
97860: ARRAY
97861: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97862: LD_ADDR_VAR 0 4
97866: PUSH
97867: LD_INT 10
97869: PUSH
97870: LD_INT 20
97872: PUSH
97873: LD_INT 30
97875: PUSH
97876: LD_INT 40
97878: PUSH
97879: LD_INT 50
97881: PUSH
97882: LD_INT 60
97884: PUSH
97885: LD_INT 70
97887: PUSH
97888: LD_INT 80
97890: PUSH
97891: LD_INT 90
97893: PUSH
97894: LD_INT 100
97896: PUSH
97897: LD_INT 110
97899: PUSH
97900: LD_INT 120
97902: PUSH
97903: LD_INT 130
97905: PUSH
97906: LD_INT 140
97908: PUSH
97909: LD_INT 150
97911: PUSH
97912: EMPTY
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: PUSH
97929: LD_INT 1
97931: PPUSH
97932: LD_INT 15
97934: PPUSH
97935: CALL_OW 12
97939: ARRAY
97940: ST_TO_ADDR
// if ValidHex ( x , y ) then
97941: LD_VAR 0 3
97945: PPUSH
97946: LD_VAR 0 4
97950: PPUSH
97951: CALL_OW 488
97955: IFFALSE 97978
// begin result := [ x , y ] ;
97957: LD_ADDR_VAR 0 1
97961: PUSH
97962: LD_VAR 0 3
97966: PUSH
97967: LD_VAR 0 4
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: ST_TO_ADDR
// break ;
97976: GO 97980
// end ; end ;
97978: GO 97780
97980: POP
97981: POP
// if result then
97982: LD_VAR 0 1
97986: IFFALSE 98046
// begin ToLua ( playSibBomb() ) ;
97988: LD_STRING playSibBomb()
97990: PPUSH
97991: CALL_OW 559
// wait ( 0 0$14 ) ;
97995: LD_INT 490
97997: PPUSH
97998: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98002: LD_VAR 0 1
98006: PUSH
98007: LD_INT 1
98009: ARRAY
98010: PPUSH
98011: LD_VAR 0 1
98015: PUSH
98016: LD_INT 2
98018: ARRAY
98019: PPUSH
98020: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98024: LD_VAR 0 1
98028: PUSH
98029: LD_INT 1
98031: ARRAY
98032: PPUSH
98033: LD_VAR 0 1
98037: PUSH
98038: LD_INT 2
98040: ARRAY
98041: PPUSH
98042: CALL_OW 429
// end ; end ;
98046: LD_VAR 0 1
98050: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98051: LD_EXP 107
98055: PUSH
98056: LD_EXP 129
98060: AND
98061: IFFALSE 98073
98063: GO 98065
98065: DISABLE
// YouLost (  ) ;
98066: LD_STRING 
98068: PPUSH
98069: CALL_OW 104
98073: END
// every 0 0$1 trigger StreamModeActive and sFog do
98074: LD_EXP 107
98078: PUSH
98079: LD_EXP 128
98083: AND
98084: IFFALSE 98098
98086: GO 98088
98088: DISABLE
// FogOff ( your_side ) ;
98089: LD_OWVAR 2
98093: PPUSH
98094: CALL_OW 344
98098: END
// every 0 0$1 trigger StreamModeActive and sSun do
98099: LD_EXP 107
98103: PUSH
98104: LD_EXP 130
98108: AND
98109: IFFALSE 98137
98111: GO 98113
98113: DISABLE
// begin solar_recharge_percent := 0 ;
98114: LD_ADDR_OWVAR 79
98118: PUSH
98119: LD_INT 0
98121: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98122: LD_INT 10500
98124: PPUSH
98125: CALL_OW 67
// solar_recharge_percent := 100 ;
98129: LD_ADDR_OWVAR 79
98133: PUSH
98134: LD_INT 100
98136: ST_TO_ADDR
// end ;
98137: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98138: LD_EXP 107
98142: PUSH
98143: LD_EXP 131
98147: AND
98148: IFFALSE 98387
98150: GO 98152
98152: DISABLE
98153: LD_INT 0
98155: PPUSH
98156: PPUSH
98157: PPUSH
// begin tmp := [ ] ;
98158: LD_ADDR_VAR 0 3
98162: PUSH
98163: EMPTY
98164: ST_TO_ADDR
// for i := 1 to 6 do
98165: LD_ADDR_VAR 0 1
98169: PUSH
98170: DOUBLE
98171: LD_INT 1
98173: DEC
98174: ST_TO_ADDR
98175: LD_INT 6
98177: PUSH
98178: FOR_TO
98179: IFFALSE 98284
// begin uc_nation := nation_nature ;
98181: LD_ADDR_OWVAR 21
98185: PUSH
98186: LD_INT 0
98188: ST_TO_ADDR
// uc_side := 0 ;
98189: LD_ADDR_OWVAR 20
98193: PUSH
98194: LD_INT 0
98196: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98197: LD_ADDR_OWVAR 29
98201: PUSH
98202: LD_INT 12
98204: PUSH
98205: LD_INT 12
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: ST_TO_ADDR
// hc_agressivity := 20 ;
98212: LD_ADDR_OWVAR 35
98216: PUSH
98217: LD_INT 20
98219: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98220: LD_ADDR_OWVAR 28
98224: PUSH
98225: LD_INT 17
98227: ST_TO_ADDR
// hc_gallery :=  ;
98228: LD_ADDR_OWVAR 33
98232: PUSH
98233: LD_STRING 
98235: ST_TO_ADDR
// hc_name :=  ;
98236: LD_ADDR_OWVAR 26
98240: PUSH
98241: LD_STRING 
98243: ST_TO_ADDR
// un := CreateHuman ;
98244: LD_ADDR_VAR 0 2
98248: PUSH
98249: CALL_OW 44
98253: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98254: LD_VAR 0 2
98258: PPUSH
98259: LD_INT 1
98261: PPUSH
98262: CALL_OW 51
// tmp := tmp ^ un ;
98266: LD_ADDR_VAR 0 3
98270: PUSH
98271: LD_VAR 0 3
98275: PUSH
98276: LD_VAR 0 2
98280: ADD
98281: ST_TO_ADDR
// end ;
98282: GO 98178
98284: POP
98285: POP
// repeat wait ( 0 0$1 ) ;
98286: LD_INT 35
98288: PPUSH
98289: CALL_OW 67
// for un in tmp do
98293: LD_ADDR_VAR 0 2
98297: PUSH
98298: LD_VAR 0 3
98302: PUSH
98303: FOR_IN
98304: IFFALSE 98378
// begin if IsDead ( un ) then
98306: LD_VAR 0 2
98310: PPUSH
98311: CALL_OW 301
98315: IFFALSE 98335
// begin tmp := tmp diff un ;
98317: LD_ADDR_VAR 0 3
98321: PUSH
98322: LD_VAR 0 3
98326: PUSH
98327: LD_VAR 0 2
98331: DIFF
98332: ST_TO_ADDR
// continue ;
98333: GO 98303
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98335: LD_VAR 0 2
98339: PPUSH
98340: LD_INT 3
98342: PUSH
98343: LD_INT 22
98345: PUSH
98346: LD_INT 0
98348: PUSH
98349: EMPTY
98350: LIST
98351: LIST
98352: PUSH
98353: EMPTY
98354: LIST
98355: LIST
98356: PPUSH
98357: CALL_OW 69
98361: PPUSH
98362: LD_VAR 0 2
98366: PPUSH
98367: CALL_OW 74
98371: PPUSH
98372: CALL_OW 115
// end ;
98376: GO 98303
98378: POP
98379: POP
// until not tmp ;
98380: LD_VAR 0 3
98384: NOT
98385: IFFALSE 98286
// end ;
98387: PPOPN 3
98389: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98390: LD_EXP 107
98394: PUSH
98395: LD_EXP 132
98399: AND
98400: IFFALSE 98454
98402: GO 98404
98404: DISABLE
// begin ToLua ( displayTroll(); ) ;
98405: LD_STRING displayTroll();
98407: PPUSH
98408: CALL_OW 559
// wait ( 3 3$00 ) ;
98412: LD_INT 6300
98414: PPUSH
98415: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98419: LD_STRING hideTroll();
98421: PPUSH
98422: CALL_OW 559
// wait ( 1 1$00 ) ;
98426: LD_INT 2100
98428: PPUSH
98429: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98433: LD_STRING displayTroll();
98435: PPUSH
98436: CALL_OW 559
// wait ( 1 1$00 ) ;
98440: LD_INT 2100
98442: PPUSH
98443: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98447: LD_STRING hideTroll();
98449: PPUSH
98450: CALL_OW 559
// end ;
98454: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98455: LD_EXP 107
98459: PUSH
98460: LD_EXP 133
98464: AND
98465: IFFALSE 98528
98467: GO 98469
98469: DISABLE
98470: LD_INT 0
98472: PPUSH
// begin p := 0 ;
98473: LD_ADDR_VAR 0 1
98477: PUSH
98478: LD_INT 0
98480: ST_TO_ADDR
// repeat game_speed := 1 ;
98481: LD_ADDR_OWVAR 65
98485: PUSH
98486: LD_INT 1
98488: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98489: LD_INT 35
98491: PPUSH
98492: CALL_OW 67
// p := p + 1 ;
98496: LD_ADDR_VAR 0 1
98500: PUSH
98501: LD_VAR 0 1
98505: PUSH
98506: LD_INT 1
98508: PLUS
98509: ST_TO_ADDR
// until p >= 60 ;
98510: LD_VAR 0 1
98514: PUSH
98515: LD_INT 60
98517: GREATEREQUAL
98518: IFFALSE 98481
// game_speed := 4 ;
98520: LD_ADDR_OWVAR 65
98524: PUSH
98525: LD_INT 4
98527: ST_TO_ADDR
// end ;
98528: PPOPN 1
98530: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98531: LD_EXP 107
98535: PUSH
98536: LD_EXP 134
98540: AND
98541: IFFALSE 98687
98543: GO 98545
98545: DISABLE
98546: LD_INT 0
98548: PPUSH
98549: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98550: LD_ADDR_VAR 0 1
98554: PUSH
98555: LD_INT 22
98557: PUSH
98558: LD_OWVAR 2
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 2
98569: PUSH
98570: LD_INT 30
98572: PUSH
98573: LD_INT 0
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: PUSH
98580: LD_INT 30
98582: PUSH
98583: LD_INT 1
98585: PUSH
98586: EMPTY
98587: LIST
98588: LIST
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: LIST
98594: PUSH
98595: EMPTY
98596: LIST
98597: LIST
98598: PPUSH
98599: CALL_OW 69
98603: ST_TO_ADDR
// if not depot then
98604: LD_VAR 0 1
98608: NOT
98609: IFFALSE 98613
// exit ;
98611: GO 98687
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98613: LD_ADDR_VAR 0 2
98617: PUSH
98618: LD_VAR 0 1
98622: PUSH
98623: LD_INT 1
98625: PPUSH
98626: LD_VAR 0 1
98630: PPUSH
98631: CALL_OW 12
98635: ARRAY
98636: PPUSH
98637: CALL_OW 274
98641: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98642: LD_VAR 0 2
98646: PPUSH
98647: LD_INT 1
98649: PPUSH
98650: LD_INT 0
98652: PPUSH
98653: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98657: LD_VAR 0 2
98661: PPUSH
98662: LD_INT 2
98664: PPUSH
98665: LD_INT 0
98667: PPUSH
98668: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98672: LD_VAR 0 2
98676: PPUSH
98677: LD_INT 3
98679: PPUSH
98680: LD_INT 0
98682: PPUSH
98683: CALL_OW 277
// end ;
98687: PPOPN 2
98689: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98690: LD_EXP 107
98694: PUSH
98695: LD_EXP 135
98699: AND
98700: IFFALSE 98797
98702: GO 98704
98704: DISABLE
98705: LD_INT 0
98707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98708: LD_ADDR_VAR 0 1
98712: PUSH
98713: LD_INT 22
98715: PUSH
98716: LD_OWVAR 2
98720: PUSH
98721: EMPTY
98722: LIST
98723: LIST
98724: PUSH
98725: LD_INT 21
98727: PUSH
98728: LD_INT 1
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 3
98737: PUSH
98738: LD_INT 23
98740: PUSH
98741: LD_INT 0
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: EMPTY
98749: LIST
98750: LIST
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: LIST
98756: PPUSH
98757: CALL_OW 69
98761: ST_TO_ADDR
// if not tmp then
98762: LD_VAR 0 1
98766: NOT
98767: IFFALSE 98771
// exit ;
98769: GO 98797
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98771: LD_VAR 0 1
98775: PUSH
98776: LD_INT 1
98778: PPUSH
98779: LD_VAR 0 1
98783: PPUSH
98784: CALL_OW 12
98788: ARRAY
98789: PPUSH
98790: LD_INT 200
98792: PPUSH
98793: CALL_OW 234
// end ;
98797: PPOPN 1
98799: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98800: LD_EXP 107
98804: PUSH
98805: LD_EXP 136
98809: AND
98810: IFFALSE 98889
98812: GO 98814
98814: DISABLE
98815: LD_INT 0
98817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98818: LD_ADDR_VAR 0 1
98822: PUSH
98823: LD_INT 22
98825: PUSH
98826: LD_OWVAR 2
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 21
98837: PUSH
98838: LD_INT 2
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: EMPTY
98846: LIST
98847: LIST
98848: PPUSH
98849: CALL_OW 69
98853: ST_TO_ADDR
// if not tmp then
98854: LD_VAR 0 1
98858: NOT
98859: IFFALSE 98863
// exit ;
98861: GO 98889
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98863: LD_VAR 0 1
98867: PUSH
98868: LD_INT 1
98870: PPUSH
98871: LD_VAR 0 1
98875: PPUSH
98876: CALL_OW 12
98880: ARRAY
98881: PPUSH
98882: LD_INT 60
98884: PPUSH
98885: CALL_OW 234
// end ;
98889: PPOPN 1
98891: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98892: LD_EXP 107
98896: PUSH
98897: LD_EXP 137
98901: AND
98902: IFFALSE 99001
98904: GO 98906
98906: DISABLE
98907: LD_INT 0
98909: PPUSH
98910: PPUSH
// begin enable ;
98911: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98912: LD_ADDR_VAR 0 1
98916: PUSH
98917: LD_INT 22
98919: PUSH
98920: LD_OWVAR 2
98924: PUSH
98925: EMPTY
98926: LIST
98927: LIST
98928: PUSH
98929: LD_INT 61
98931: PUSH
98932: EMPTY
98933: LIST
98934: PUSH
98935: LD_INT 33
98937: PUSH
98938: LD_INT 2
98940: PUSH
98941: EMPTY
98942: LIST
98943: LIST
98944: PUSH
98945: EMPTY
98946: LIST
98947: LIST
98948: LIST
98949: PPUSH
98950: CALL_OW 69
98954: ST_TO_ADDR
// if not tmp then
98955: LD_VAR 0 1
98959: NOT
98960: IFFALSE 98964
// exit ;
98962: GO 99001
// for i in tmp do
98964: LD_ADDR_VAR 0 2
98968: PUSH
98969: LD_VAR 0 1
98973: PUSH
98974: FOR_IN
98975: IFFALSE 98999
// if IsControledBy ( i ) then
98977: LD_VAR 0 2
98981: PPUSH
98982: CALL_OW 312
98986: IFFALSE 98997
// ComUnlink ( i ) ;
98988: LD_VAR 0 2
98992: PPUSH
98993: CALL_OW 136
98997: GO 98974
98999: POP
99000: POP
// end ;
99001: PPOPN 2
99003: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99004: LD_EXP 107
99008: PUSH
99009: LD_EXP 138
99013: AND
99014: IFFALSE 99154
99016: GO 99018
99018: DISABLE
99019: LD_INT 0
99021: PPUSH
99022: PPUSH
// begin ToLua ( displayPowell(); ) ;
99023: LD_STRING displayPowell();
99025: PPUSH
99026: CALL_OW 559
// uc_side := 0 ;
99030: LD_ADDR_OWVAR 20
99034: PUSH
99035: LD_INT 0
99037: ST_TO_ADDR
// uc_nation := 2 ;
99038: LD_ADDR_OWVAR 21
99042: PUSH
99043: LD_INT 2
99045: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99046: LD_ADDR_OWVAR 37
99050: PUSH
99051: LD_INT 14
99053: ST_TO_ADDR
// vc_engine := engine_siberite ;
99054: LD_ADDR_OWVAR 39
99058: PUSH
99059: LD_INT 3
99061: ST_TO_ADDR
// vc_control := control_apeman ;
99062: LD_ADDR_OWVAR 38
99066: PUSH
99067: LD_INT 5
99069: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99070: LD_ADDR_OWVAR 40
99074: PUSH
99075: LD_INT 29
99077: ST_TO_ADDR
// un := CreateVehicle ;
99078: LD_ADDR_VAR 0 2
99082: PUSH
99083: CALL_OW 45
99087: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99088: LD_VAR 0 2
99092: PPUSH
99093: LD_INT 1
99095: PPUSH
99096: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99100: LD_INT 35
99102: PPUSH
99103: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99107: LD_VAR 0 2
99111: PPUSH
99112: LD_INT 22
99114: PUSH
99115: LD_OWVAR 2
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: PPUSH
99124: CALL_OW 69
99128: PPUSH
99129: LD_VAR 0 2
99133: PPUSH
99134: CALL_OW 74
99138: PPUSH
99139: CALL_OW 115
// until IsDead ( un ) ;
99143: LD_VAR 0 2
99147: PPUSH
99148: CALL_OW 301
99152: IFFALSE 99100
// end ;
99154: PPOPN 2
99156: END
// every 0 0$1 trigger StreamModeActive and sStu do
99157: LD_EXP 107
99161: PUSH
99162: LD_EXP 146
99166: AND
99167: IFFALSE 99183
99169: GO 99171
99171: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99172: LD_STRING displayStucuk();
99174: PPUSH
99175: CALL_OW 559
// ResetFog ;
99179: CALL_OW 335
// end ;
99183: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99184: LD_EXP 107
99188: PUSH
99189: LD_EXP 139
99193: AND
99194: IFFALSE 99335
99196: GO 99198
99198: DISABLE
99199: LD_INT 0
99201: PPUSH
99202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99203: LD_ADDR_VAR 0 2
99207: PUSH
99208: LD_INT 22
99210: PUSH
99211: LD_OWVAR 2
99215: PUSH
99216: EMPTY
99217: LIST
99218: LIST
99219: PUSH
99220: LD_INT 21
99222: PUSH
99223: LD_INT 1
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: PPUSH
99234: CALL_OW 69
99238: ST_TO_ADDR
// if not tmp then
99239: LD_VAR 0 2
99243: NOT
99244: IFFALSE 99248
// exit ;
99246: GO 99335
// un := tmp [ rand ( 1 , tmp ) ] ;
99248: LD_ADDR_VAR 0 1
99252: PUSH
99253: LD_VAR 0 2
99257: PUSH
99258: LD_INT 1
99260: PPUSH
99261: LD_VAR 0 2
99265: PPUSH
99266: CALL_OW 12
99270: ARRAY
99271: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99272: LD_VAR 0 1
99276: PPUSH
99277: LD_INT 0
99279: PPUSH
99280: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99284: LD_VAR 0 1
99288: PPUSH
99289: LD_OWVAR 3
99293: PUSH
99294: LD_VAR 0 1
99298: DIFF
99299: PPUSH
99300: LD_VAR 0 1
99304: PPUSH
99305: CALL_OW 74
99309: PPUSH
99310: CALL_OW 115
// wait ( 0 0$20 ) ;
99314: LD_INT 700
99316: PPUSH
99317: CALL_OW 67
// SetSide ( un , your_side ) ;
99321: LD_VAR 0 1
99325: PPUSH
99326: LD_OWVAR 2
99330: PPUSH
99331: CALL_OW 235
// end ;
99335: PPOPN 2
99337: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99338: LD_EXP 107
99342: PUSH
99343: LD_EXP 140
99347: AND
99348: IFFALSE 99454
99350: GO 99352
99352: DISABLE
99353: LD_INT 0
99355: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99356: LD_ADDR_VAR 0 1
99360: PUSH
99361: LD_INT 22
99363: PUSH
99364: LD_OWVAR 2
99368: PUSH
99369: EMPTY
99370: LIST
99371: LIST
99372: PUSH
99373: LD_INT 2
99375: PUSH
99376: LD_INT 30
99378: PUSH
99379: LD_INT 0
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: PUSH
99386: LD_INT 30
99388: PUSH
99389: LD_INT 1
99391: PUSH
99392: EMPTY
99393: LIST
99394: LIST
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: LIST
99400: PUSH
99401: EMPTY
99402: LIST
99403: LIST
99404: PPUSH
99405: CALL_OW 69
99409: ST_TO_ADDR
// if not depot then
99410: LD_VAR 0 1
99414: NOT
99415: IFFALSE 99419
// exit ;
99417: GO 99454
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99419: LD_VAR 0 1
99423: PUSH
99424: LD_INT 1
99426: ARRAY
99427: PPUSH
99428: CALL_OW 250
99432: PPUSH
99433: LD_VAR 0 1
99437: PUSH
99438: LD_INT 1
99440: ARRAY
99441: PPUSH
99442: CALL_OW 251
99446: PPUSH
99447: LD_INT 70
99449: PPUSH
99450: CALL_OW 495
// end ;
99454: PPOPN 1
99456: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99457: LD_EXP 107
99461: PUSH
99462: LD_EXP 141
99466: AND
99467: IFFALSE 99678
99469: GO 99471
99471: DISABLE
99472: LD_INT 0
99474: PPUSH
99475: PPUSH
99476: PPUSH
99477: PPUSH
99478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99479: LD_ADDR_VAR 0 5
99483: PUSH
99484: LD_INT 22
99486: PUSH
99487: LD_OWVAR 2
99491: PUSH
99492: EMPTY
99493: LIST
99494: LIST
99495: PUSH
99496: LD_INT 21
99498: PUSH
99499: LD_INT 1
99501: PUSH
99502: EMPTY
99503: LIST
99504: LIST
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: PPUSH
99510: CALL_OW 69
99514: ST_TO_ADDR
// if not tmp then
99515: LD_VAR 0 5
99519: NOT
99520: IFFALSE 99524
// exit ;
99522: GO 99678
// for i in tmp do
99524: LD_ADDR_VAR 0 1
99528: PUSH
99529: LD_VAR 0 5
99533: PUSH
99534: FOR_IN
99535: IFFALSE 99676
// begin d := rand ( 0 , 5 ) ;
99537: LD_ADDR_VAR 0 4
99541: PUSH
99542: LD_INT 0
99544: PPUSH
99545: LD_INT 5
99547: PPUSH
99548: CALL_OW 12
99552: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99553: LD_ADDR_VAR 0 2
99557: PUSH
99558: LD_VAR 0 1
99562: PPUSH
99563: CALL_OW 250
99567: PPUSH
99568: LD_VAR 0 4
99572: PPUSH
99573: LD_INT 3
99575: PPUSH
99576: LD_INT 12
99578: PPUSH
99579: CALL_OW 12
99583: PPUSH
99584: CALL_OW 272
99588: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99589: LD_ADDR_VAR 0 3
99593: PUSH
99594: LD_VAR 0 1
99598: PPUSH
99599: CALL_OW 251
99603: PPUSH
99604: LD_VAR 0 4
99608: PPUSH
99609: LD_INT 3
99611: PPUSH
99612: LD_INT 12
99614: PPUSH
99615: CALL_OW 12
99619: PPUSH
99620: CALL_OW 273
99624: ST_TO_ADDR
// if ValidHex ( x , y ) then
99625: LD_VAR 0 2
99629: PPUSH
99630: LD_VAR 0 3
99634: PPUSH
99635: CALL_OW 488
99639: IFFALSE 99674
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99641: LD_VAR 0 1
99645: PPUSH
99646: LD_VAR 0 2
99650: PPUSH
99651: LD_VAR 0 3
99655: PPUSH
99656: LD_INT 3
99658: PPUSH
99659: LD_INT 6
99661: PPUSH
99662: CALL_OW 12
99666: PPUSH
99667: LD_INT 1
99669: PPUSH
99670: CALL_OW 483
// end ;
99674: GO 99534
99676: POP
99677: POP
// end ;
99678: PPOPN 5
99680: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99681: LD_EXP 107
99685: PUSH
99686: LD_EXP 142
99690: AND
99691: IFFALSE 99785
99693: GO 99695
99695: DISABLE
99696: LD_INT 0
99698: PPUSH
99699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99700: LD_ADDR_VAR 0 2
99704: PUSH
99705: LD_INT 22
99707: PUSH
99708: LD_OWVAR 2
99712: PUSH
99713: EMPTY
99714: LIST
99715: LIST
99716: PUSH
99717: LD_INT 32
99719: PUSH
99720: LD_INT 1
99722: PUSH
99723: EMPTY
99724: LIST
99725: LIST
99726: PUSH
99727: LD_INT 21
99729: PUSH
99730: LD_INT 2
99732: PUSH
99733: EMPTY
99734: LIST
99735: LIST
99736: PUSH
99737: EMPTY
99738: LIST
99739: LIST
99740: LIST
99741: PPUSH
99742: CALL_OW 69
99746: ST_TO_ADDR
// if not tmp then
99747: LD_VAR 0 2
99751: NOT
99752: IFFALSE 99756
// exit ;
99754: GO 99785
// for i in tmp do
99756: LD_ADDR_VAR 0 1
99760: PUSH
99761: LD_VAR 0 2
99765: PUSH
99766: FOR_IN
99767: IFFALSE 99783
// SetFuel ( i , 0 ) ;
99769: LD_VAR 0 1
99773: PPUSH
99774: LD_INT 0
99776: PPUSH
99777: CALL_OW 240
99781: GO 99766
99783: POP
99784: POP
// end ;
99785: PPOPN 2
99787: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99788: LD_EXP 107
99792: PUSH
99793: LD_EXP 143
99797: AND
99798: IFFALSE 99864
99800: GO 99802
99802: DISABLE
99803: LD_INT 0
99805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99806: LD_ADDR_VAR 0 1
99810: PUSH
99811: LD_INT 22
99813: PUSH
99814: LD_OWVAR 2
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: PUSH
99823: LD_INT 30
99825: PUSH
99826: LD_INT 29
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: PUSH
99833: EMPTY
99834: LIST
99835: LIST
99836: PPUSH
99837: CALL_OW 69
99841: ST_TO_ADDR
// if not tmp then
99842: LD_VAR 0 1
99846: NOT
99847: IFFALSE 99851
// exit ;
99849: GO 99864
// DestroyUnit ( tmp [ 1 ] ) ;
99851: LD_VAR 0 1
99855: PUSH
99856: LD_INT 1
99858: ARRAY
99859: PPUSH
99860: CALL_OW 65
// end ;
99864: PPOPN 1
99866: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99867: LD_EXP 107
99871: PUSH
99872: LD_EXP 145
99876: AND
99877: IFFALSE 100006
99879: GO 99881
99881: DISABLE
99882: LD_INT 0
99884: PPUSH
// begin uc_side := 0 ;
99885: LD_ADDR_OWVAR 20
99889: PUSH
99890: LD_INT 0
99892: ST_TO_ADDR
// uc_nation := nation_arabian ;
99893: LD_ADDR_OWVAR 21
99897: PUSH
99898: LD_INT 2
99900: ST_TO_ADDR
// hc_gallery :=  ;
99901: LD_ADDR_OWVAR 33
99905: PUSH
99906: LD_STRING 
99908: ST_TO_ADDR
// hc_name :=  ;
99909: LD_ADDR_OWVAR 26
99913: PUSH
99914: LD_STRING 
99916: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99917: LD_INT 1
99919: PPUSH
99920: LD_INT 11
99922: PPUSH
99923: LD_INT 10
99925: PPUSH
99926: CALL_OW 380
// un := CreateHuman ;
99930: LD_ADDR_VAR 0 1
99934: PUSH
99935: CALL_OW 44
99939: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99940: LD_VAR 0 1
99944: PPUSH
99945: LD_INT 1
99947: PPUSH
99948: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99952: LD_INT 35
99954: PPUSH
99955: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99959: LD_VAR 0 1
99963: PPUSH
99964: LD_INT 22
99966: PUSH
99967: LD_OWVAR 2
99971: PUSH
99972: EMPTY
99973: LIST
99974: LIST
99975: PPUSH
99976: CALL_OW 69
99980: PPUSH
99981: LD_VAR 0 1
99985: PPUSH
99986: CALL_OW 74
99990: PPUSH
99991: CALL_OW 115
// until IsDead ( un ) ;
99995: LD_VAR 0 1
99999: PPUSH
100000: CALL_OW 301
100004: IFFALSE 99952
// end ;
100006: PPOPN 1
100008: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100009: LD_EXP 107
100013: PUSH
100014: LD_EXP 147
100018: AND
100019: IFFALSE 100031
100021: GO 100023
100023: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100024: LD_STRING earthquake(getX(game), 0, 32)
100026: PPUSH
100027: CALL_OW 559
100031: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100032: LD_EXP 107
100036: PUSH
100037: LD_EXP 148
100041: AND
100042: IFFALSE 100133
100044: GO 100046
100046: DISABLE
100047: LD_INT 0
100049: PPUSH
// begin enable ;
100050: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100051: LD_ADDR_VAR 0 1
100055: PUSH
100056: LD_INT 22
100058: PUSH
100059: LD_OWVAR 2
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: PUSH
100068: LD_INT 21
100070: PUSH
100071: LD_INT 2
100073: PUSH
100074: EMPTY
100075: LIST
100076: LIST
100077: PUSH
100078: LD_INT 33
100080: PUSH
100081: LD_INT 3
100083: PUSH
100084: EMPTY
100085: LIST
100086: LIST
100087: PUSH
100088: EMPTY
100089: LIST
100090: LIST
100091: LIST
100092: PPUSH
100093: CALL_OW 69
100097: ST_TO_ADDR
// if not tmp then
100098: LD_VAR 0 1
100102: NOT
100103: IFFALSE 100107
// exit ;
100105: GO 100133
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100107: LD_VAR 0 1
100111: PUSH
100112: LD_INT 1
100114: PPUSH
100115: LD_VAR 0 1
100119: PPUSH
100120: CALL_OW 12
100124: ARRAY
100125: PPUSH
100126: LD_INT 1
100128: PPUSH
100129: CALL_OW 234
// end ;
100133: PPOPN 1
100135: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100136: LD_EXP 107
100140: PUSH
100141: LD_EXP 149
100145: AND
100146: IFFALSE 100287
100148: GO 100150
100150: DISABLE
100151: LD_INT 0
100153: PPUSH
100154: PPUSH
100155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100156: LD_ADDR_VAR 0 3
100160: PUSH
100161: LD_INT 22
100163: PUSH
100164: LD_OWVAR 2
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: PUSH
100173: LD_INT 25
100175: PUSH
100176: LD_INT 1
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: PPUSH
100187: CALL_OW 69
100191: ST_TO_ADDR
// if not tmp then
100192: LD_VAR 0 3
100196: NOT
100197: IFFALSE 100201
// exit ;
100199: GO 100287
// un := tmp [ rand ( 1 , tmp ) ] ;
100201: LD_ADDR_VAR 0 2
100205: PUSH
100206: LD_VAR 0 3
100210: PUSH
100211: LD_INT 1
100213: PPUSH
100214: LD_VAR 0 3
100218: PPUSH
100219: CALL_OW 12
100223: ARRAY
100224: ST_TO_ADDR
// if Crawls ( un ) then
100225: LD_VAR 0 2
100229: PPUSH
100230: CALL_OW 318
100234: IFFALSE 100245
// ComWalk ( un ) ;
100236: LD_VAR 0 2
100240: PPUSH
100241: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100245: LD_VAR 0 2
100249: PPUSH
100250: LD_INT 9
100252: PPUSH
100253: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100257: LD_INT 28
100259: PPUSH
100260: LD_OWVAR 2
100264: PPUSH
100265: LD_INT 2
100267: PPUSH
100268: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100272: LD_INT 29
100274: PPUSH
100275: LD_OWVAR 2
100279: PPUSH
100280: LD_INT 2
100282: PPUSH
100283: CALL_OW 322
// end ;
100287: PPOPN 3
100289: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100290: LD_EXP 107
100294: PUSH
100295: LD_EXP 150
100299: AND
100300: IFFALSE 100411
100302: GO 100304
100304: DISABLE
100305: LD_INT 0
100307: PPUSH
100308: PPUSH
100309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100310: LD_ADDR_VAR 0 3
100314: PUSH
100315: LD_INT 22
100317: PUSH
100318: LD_OWVAR 2
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: PUSH
100327: LD_INT 25
100329: PUSH
100330: LD_INT 1
100332: PUSH
100333: EMPTY
100334: LIST
100335: LIST
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PPUSH
100341: CALL_OW 69
100345: ST_TO_ADDR
// if not tmp then
100346: LD_VAR 0 3
100350: NOT
100351: IFFALSE 100355
// exit ;
100353: GO 100411
// un := tmp [ rand ( 1 , tmp ) ] ;
100355: LD_ADDR_VAR 0 2
100359: PUSH
100360: LD_VAR 0 3
100364: PUSH
100365: LD_INT 1
100367: PPUSH
100368: LD_VAR 0 3
100372: PPUSH
100373: CALL_OW 12
100377: ARRAY
100378: ST_TO_ADDR
// if Crawls ( un ) then
100379: LD_VAR 0 2
100383: PPUSH
100384: CALL_OW 318
100388: IFFALSE 100399
// ComWalk ( un ) ;
100390: LD_VAR 0 2
100394: PPUSH
100395: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100399: LD_VAR 0 2
100403: PPUSH
100404: LD_INT 8
100406: PPUSH
100407: CALL_OW 336
// end ;
100411: PPOPN 3
100413: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100414: LD_EXP 107
100418: PUSH
100419: LD_EXP 151
100423: AND
100424: IFFALSE 100568
100426: GO 100428
100428: DISABLE
100429: LD_INT 0
100431: PPUSH
100432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100433: LD_ADDR_VAR 0 2
100437: PUSH
100438: LD_INT 22
100440: PUSH
100441: LD_OWVAR 2
100445: PUSH
100446: EMPTY
100447: LIST
100448: LIST
100449: PUSH
100450: LD_INT 21
100452: PUSH
100453: LD_INT 2
100455: PUSH
100456: EMPTY
100457: LIST
100458: LIST
100459: PUSH
100460: LD_INT 2
100462: PUSH
100463: LD_INT 34
100465: PUSH
100466: LD_INT 12
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PUSH
100473: LD_INT 34
100475: PUSH
100476: LD_INT 51
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: LD_INT 34
100485: PUSH
100486: LD_INT 32
100488: PUSH
100489: EMPTY
100490: LIST
100491: LIST
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: PUSH
100499: EMPTY
100500: LIST
100501: LIST
100502: LIST
100503: PPUSH
100504: CALL_OW 69
100508: ST_TO_ADDR
// if not tmp then
100509: LD_VAR 0 2
100513: NOT
100514: IFFALSE 100518
// exit ;
100516: GO 100568
// for i in tmp do
100518: LD_ADDR_VAR 0 1
100522: PUSH
100523: LD_VAR 0 2
100527: PUSH
100528: FOR_IN
100529: IFFALSE 100566
// if GetCargo ( i , mat_artifact ) = 0 then
100531: LD_VAR 0 1
100535: PPUSH
100536: LD_INT 4
100538: PPUSH
100539: CALL_OW 289
100543: PUSH
100544: LD_INT 0
100546: EQUAL
100547: IFFALSE 100564
// SetCargo ( i , mat_siberit , 100 ) ;
100549: LD_VAR 0 1
100553: PPUSH
100554: LD_INT 3
100556: PPUSH
100557: LD_INT 100
100559: PPUSH
100560: CALL_OW 290
100564: GO 100528
100566: POP
100567: POP
// end ;
100568: PPOPN 2
100570: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100571: LD_EXP 107
100575: PUSH
100576: LD_EXP 152
100580: AND
100581: IFFALSE 100764
100583: GO 100585
100585: DISABLE
100586: LD_INT 0
100588: PPUSH
100589: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100590: LD_ADDR_VAR 0 2
100594: PUSH
100595: LD_INT 22
100597: PUSH
100598: LD_OWVAR 2
100602: PUSH
100603: EMPTY
100604: LIST
100605: LIST
100606: PPUSH
100607: CALL_OW 69
100611: ST_TO_ADDR
// if not tmp then
100612: LD_VAR 0 2
100616: NOT
100617: IFFALSE 100621
// exit ;
100619: GO 100764
// for i := 1 to 2 do
100621: LD_ADDR_VAR 0 1
100625: PUSH
100626: DOUBLE
100627: LD_INT 1
100629: DEC
100630: ST_TO_ADDR
100631: LD_INT 2
100633: PUSH
100634: FOR_TO
100635: IFFALSE 100762
// begin uc_side := your_side ;
100637: LD_ADDR_OWVAR 20
100641: PUSH
100642: LD_OWVAR 2
100646: ST_TO_ADDR
// uc_nation := nation_american ;
100647: LD_ADDR_OWVAR 21
100651: PUSH
100652: LD_INT 1
100654: ST_TO_ADDR
// vc_chassis := us_morphling ;
100655: LD_ADDR_OWVAR 37
100659: PUSH
100660: LD_INT 5
100662: ST_TO_ADDR
// vc_engine := engine_siberite ;
100663: LD_ADDR_OWVAR 39
100667: PUSH
100668: LD_INT 3
100670: ST_TO_ADDR
// vc_control := control_computer ;
100671: LD_ADDR_OWVAR 38
100675: PUSH
100676: LD_INT 3
100678: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100679: LD_ADDR_OWVAR 40
100683: PUSH
100684: LD_INT 10
100686: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100687: LD_VAR 0 2
100691: PUSH
100692: LD_INT 1
100694: ARRAY
100695: PPUSH
100696: CALL_OW 310
100700: NOT
100701: IFFALSE 100748
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100703: CALL_OW 45
100707: PPUSH
100708: LD_VAR 0 2
100712: PUSH
100713: LD_INT 1
100715: ARRAY
100716: PPUSH
100717: CALL_OW 250
100721: PPUSH
100722: LD_VAR 0 2
100726: PUSH
100727: LD_INT 1
100729: ARRAY
100730: PPUSH
100731: CALL_OW 251
100735: PPUSH
100736: LD_INT 12
100738: PPUSH
100739: LD_INT 1
100741: PPUSH
100742: CALL_OW 50
100746: GO 100760
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100748: CALL_OW 45
100752: PPUSH
100753: LD_INT 1
100755: PPUSH
100756: CALL_OW 51
// end ;
100760: GO 100634
100762: POP
100763: POP
// end ;
100764: PPOPN 2
100766: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100767: LD_EXP 107
100771: PUSH
100772: LD_EXP 153
100776: AND
100777: IFFALSE 100999
100779: GO 100781
100781: DISABLE
100782: LD_INT 0
100784: PPUSH
100785: PPUSH
100786: PPUSH
100787: PPUSH
100788: PPUSH
100789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100790: LD_ADDR_VAR 0 6
100794: PUSH
100795: LD_INT 22
100797: PUSH
100798: LD_OWVAR 2
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 21
100809: PUSH
100810: LD_INT 1
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: PUSH
100817: LD_INT 3
100819: PUSH
100820: LD_INT 23
100822: PUSH
100823: LD_INT 0
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: PUSH
100830: EMPTY
100831: LIST
100832: LIST
100833: PUSH
100834: EMPTY
100835: LIST
100836: LIST
100837: LIST
100838: PPUSH
100839: CALL_OW 69
100843: ST_TO_ADDR
// if not tmp then
100844: LD_VAR 0 6
100848: NOT
100849: IFFALSE 100853
// exit ;
100851: GO 100999
// s1 := rand ( 1 , 4 ) ;
100853: LD_ADDR_VAR 0 2
100857: PUSH
100858: LD_INT 1
100860: PPUSH
100861: LD_INT 4
100863: PPUSH
100864: CALL_OW 12
100868: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100869: LD_ADDR_VAR 0 4
100873: PUSH
100874: LD_VAR 0 6
100878: PUSH
100879: LD_INT 1
100881: ARRAY
100882: PPUSH
100883: LD_VAR 0 2
100887: PPUSH
100888: CALL_OW 259
100892: ST_TO_ADDR
// if s1 = 1 then
100893: LD_VAR 0 2
100897: PUSH
100898: LD_INT 1
100900: EQUAL
100901: IFFALSE 100921
// s2 := rand ( 2 , 4 ) else
100903: LD_ADDR_VAR 0 3
100907: PUSH
100908: LD_INT 2
100910: PPUSH
100911: LD_INT 4
100913: PPUSH
100914: CALL_OW 12
100918: ST_TO_ADDR
100919: GO 100929
// s2 := 1 ;
100921: LD_ADDR_VAR 0 3
100925: PUSH
100926: LD_INT 1
100928: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100929: LD_ADDR_VAR 0 5
100933: PUSH
100934: LD_VAR 0 6
100938: PUSH
100939: LD_INT 1
100941: ARRAY
100942: PPUSH
100943: LD_VAR 0 3
100947: PPUSH
100948: CALL_OW 259
100952: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100953: LD_VAR 0 6
100957: PUSH
100958: LD_INT 1
100960: ARRAY
100961: PPUSH
100962: LD_VAR 0 2
100966: PPUSH
100967: LD_VAR 0 5
100971: PPUSH
100972: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100976: LD_VAR 0 6
100980: PUSH
100981: LD_INT 1
100983: ARRAY
100984: PPUSH
100985: LD_VAR 0 3
100989: PPUSH
100990: LD_VAR 0 4
100994: PPUSH
100995: CALL_OW 237
// end ;
100999: PPOPN 6
101001: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101002: LD_EXP 107
101006: PUSH
101007: LD_EXP 154
101011: AND
101012: IFFALSE 101091
101014: GO 101016
101016: DISABLE
101017: LD_INT 0
101019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101020: LD_ADDR_VAR 0 1
101024: PUSH
101025: LD_INT 22
101027: PUSH
101028: LD_OWVAR 2
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: PUSH
101037: LD_INT 30
101039: PUSH
101040: LD_INT 3
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: PUSH
101047: EMPTY
101048: LIST
101049: LIST
101050: PPUSH
101051: CALL_OW 69
101055: ST_TO_ADDR
// if not tmp then
101056: LD_VAR 0 1
101060: NOT
101061: IFFALSE 101065
// exit ;
101063: GO 101091
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101065: LD_VAR 0 1
101069: PUSH
101070: LD_INT 1
101072: PPUSH
101073: LD_VAR 0 1
101077: PPUSH
101078: CALL_OW 12
101082: ARRAY
101083: PPUSH
101084: LD_INT 1
101086: PPUSH
101087: CALL_OW 234
// end ;
101091: PPOPN 1
101093: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101094: LD_EXP 107
101098: PUSH
101099: LD_EXP 155
101103: AND
101104: IFFALSE 101216
101106: GO 101108
101108: DISABLE
101109: LD_INT 0
101111: PPUSH
101112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101113: LD_ADDR_VAR 0 2
101117: PUSH
101118: LD_INT 22
101120: PUSH
101121: LD_OWVAR 2
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PUSH
101130: LD_INT 2
101132: PUSH
101133: LD_INT 30
101135: PUSH
101136: LD_INT 27
101138: PUSH
101139: EMPTY
101140: LIST
101141: LIST
101142: PUSH
101143: LD_INT 30
101145: PUSH
101146: LD_INT 26
101148: PUSH
101149: EMPTY
101150: LIST
101151: LIST
101152: PUSH
101153: LD_INT 30
101155: PUSH
101156: LD_INT 28
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: EMPTY
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PPUSH
101173: CALL_OW 69
101177: ST_TO_ADDR
// if not tmp then
101178: LD_VAR 0 2
101182: NOT
101183: IFFALSE 101187
// exit ;
101185: GO 101216
// for i in tmp do
101187: LD_ADDR_VAR 0 1
101191: PUSH
101192: LD_VAR 0 2
101196: PUSH
101197: FOR_IN
101198: IFFALSE 101214
// SetLives ( i , 1 ) ;
101200: LD_VAR 0 1
101204: PPUSH
101205: LD_INT 1
101207: PPUSH
101208: CALL_OW 234
101212: GO 101197
101214: POP
101215: POP
// end ;
101216: PPOPN 2
101218: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101219: LD_EXP 107
101223: PUSH
101224: LD_EXP 156
101228: AND
101229: IFFALSE 101516
101231: GO 101233
101233: DISABLE
101234: LD_INT 0
101236: PPUSH
101237: PPUSH
101238: PPUSH
// begin i := rand ( 1 , 7 ) ;
101239: LD_ADDR_VAR 0 1
101243: PUSH
101244: LD_INT 1
101246: PPUSH
101247: LD_INT 7
101249: PPUSH
101250: CALL_OW 12
101254: ST_TO_ADDR
// case i of 1 :
101255: LD_VAR 0 1
101259: PUSH
101260: LD_INT 1
101262: DOUBLE
101263: EQUAL
101264: IFTRUE 101268
101266: GO 101278
101268: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101269: LD_STRING earthquake(getX(game), 0, 32)
101271: PPUSH
101272: CALL_OW 559
101276: GO 101516
101278: LD_INT 2
101280: DOUBLE
101281: EQUAL
101282: IFTRUE 101286
101284: GO 101300
101286: POP
// begin ToLua ( displayStucuk(); ) ;
101287: LD_STRING displayStucuk();
101289: PPUSH
101290: CALL_OW 559
// ResetFog ;
101294: CALL_OW 335
// end ; 3 :
101298: GO 101516
101300: LD_INT 3
101302: DOUBLE
101303: EQUAL
101304: IFTRUE 101308
101306: GO 101412
101308: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101309: LD_ADDR_VAR 0 2
101313: PUSH
101314: LD_INT 22
101316: PUSH
101317: LD_OWVAR 2
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 25
101328: PUSH
101329: LD_INT 1
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: PPUSH
101340: CALL_OW 69
101344: ST_TO_ADDR
// if not tmp then
101345: LD_VAR 0 2
101349: NOT
101350: IFFALSE 101354
// exit ;
101352: GO 101516
// un := tmp [ rand ( 1 , tmp ) ] ;
101354: LD_ADDR_VAR 0 3
101358: PUSH
101359: LD_VAR 0 2
101363: PUSH
101364: LD_INT 1
101366: PPUSH
101367: LD_VAR 0 2
101371: PPUSH
101372: CALL_OW 12
101376: ARRAY
101377: ST_TO_ADDR
// if Crawls ( un ) then
101378: LD_VAR 0 3
101382: PPUSH
101383: CALL_OW 318
101387: IFFALSE 101398
// ComWalk ( un ) ;
101389: LD_VAR 0 3
101393: PPUSH
101394: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101398: LD_VAR 0 3
101402: PPUSH
101403: LD_INT 8
101405: PPUSH
101406: CALL_OW 336
// end ; 4 :
101410: GO 101516
101412: LD_INT 4
101414: DOUBLE
101415: EQUAL
101416: IFTRUE 101420
101418: GO 101494
101420: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101421: LD_ADDR_VAR 0 2
101425: PUSH
101426: LD_INT 22
101428: PUSH
101429: LD_OWVAR 2
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 30
101440: PUSH
101441: LD_INT 29
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: EMPTY
101449: LIST
101450: LIST
101451: PPUSH
101452: CALL_OW 69
101456: ST_TO_ADDR
// if not tmp then
101457: LD_VAR 0 2
101461: NOT
101462: IFFALSE 101466
// exit ;
101464: GO 101516
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101466: LD_VAR 0 2
101470: PUSH
101471: LD_INT 1
101473: ARRAY
101474: PPUSH
101475: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101479: LD_VAR 0 2
101483: PUSH
101484: LD_INT 1
101486: ARRAY
101487: PPUSH
101488: CALL_OW 65
// end ; 5 .. 7 :
101492: GO 101516
101494: LD_INT 5
101496: DOUBLE
101497: GREATEREQUAL
101498: IFFALSE 101506
101500: LD_INT 7
101502: DOUBLE
101503: LESSEQUAL
101504: IFTRUE 101508
101506: GO 101515
101508: POP
// StreamSibBomb ; end ;
101509: CALL 97753 0 0
101513: GO 101516
101515: POP
// end ;
101516: PPOPN 3
101518: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101519: LD_EXP 107
101523: PUSH
101524: LD_EXP 157
101528: AND
101529: IFFALSE 101685
101531: GO 101533
101533: DISABLE
101534: LD_INT 0
101536: PPUSH
101537: PPUSH
101538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101539: LD_ADDR_VAR 0 2
101543: PUSH
101544: LD_INT 81
101546: PUSH
101547: LD_OWVAR 2
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: LD_INT 2
101558: PUSH
101559: LD_INT 21
101561: PUSH
101562: LD_INT 1
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: PUSH
101569: LD_INT 21
101571: PUSH
101572: LD_INT 2
101574: PUSH
101575: EMPTY
101576: LIST
101577: LIST
101578: PUSH
101579: EMPTY
101580: LIST
101581: LIST
101582: LIST
101583: PUSH
101584: EMPTY
101585: LIST
101586: LIST
101587: PPUSH
101588: CALL_OW 69
101592: ST_TO_ADDR
// if not tmp then
101593: LD_VAR 0 2
101597: NOT
101598: IFFALSE 101602
// exit ;
101600: GO 101685
// p := 0 ;
101602: LD_ADDR_VAR 0 3
101606: PUSH
101607: LD_INT 0
101609: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101610: LD_INT 35
101612: PPUSH
101613: CALL_OW 67
// p := p + 1 ;
101617: LD_ADDR_VAR 0 3
101621: PUSH
101622: LD_VAR 0 3
101626: PUSH
101627: LD_INT 1
101629: PLUS
101630: ST_TO_ADDR
// for i in tmp do
101631: LD_ADDR_VAR 0 1
101635: PUSH
101636: LD_VAR 0 2
101640: PUSH
101641: FOR_IN
101642: IFFALSE 101673
// if GetLives ( i ) < 1000 then
101644: LD_VAR 0 1
101648: PPUSH
101649: CALL_OW 256
101653: PUSH
101654: LD_INT 1000
101656: LESS
101657: IFFALSE 101671
// SetLives ( i , 1000 ) ;
101659: LD_VAR 0 1
101663: PPUSH
101664: LD_INT 1000
101666: PPUSH
101667: CALL_OW 234
101671: GO 101641
101673: POP
101674: POP
// until p > 20 ;
101675: LD_VAR 0 3
101679: PUSH
101680: LD_INT 20
101682: GREATER
101683: IFFALSE 101610
// end ;
101685: PPOPN 3
101687: END
// every 0 0$1 trigger StreamModeActive and sTime do
101688: LD_EXP 107
101692: PUSH
101693: LD_EXP 158
101697: AND
101698: IFFALSE 101733
101700: GO 101702
101702: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101703: LD_INT 28
101705: PPUSH
101706: LD_OWVAR 2
101710: PPUSH
101711: LD_INT 2
101713: PPUSH
101714: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101718: LD_INT 30
101720: PPUSH
101721: LD_OWVAR 2
101725: PPUSH
101726: LD_INT 2
101728: PPUSH
101729: CALL_OW 322
// end ;
101733: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101734: LD_EXP 107
101738: PUSH
101739: LD_EXP 159
101743: AND
101744: IFFALSE 101865
101746: GO 101748
101748: DISABLE
101749: LD_INT 0
101751: PPUSH
101752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101753: LD_ADDR_VAR 0 2
101757: PUSH
101758: LD_INT 22
101760: PUSH
101761: LD_OWVAR 2
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: LD_INT 21
101772: PUSH
101773: LD_INT 1
101775: PUSH
101776: EMPTY
101777: LIST
101778: LIST
101779: PUSH
101780: LD_INT 3
101782: PUSH
101783: LD_INT 23
101785: PUSH
101786: LD_INT 0
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: PUSH
101793: EMPTY
101794: LIST
101795: LIST
101796: PUSH
101797: EMPTY
101798: LIST
101799: LIST
101800: LIST
101801: PPUSH
101802: CALL_OW 69
101806: ST_TO_ADDR
// if not tmp then
101807: LD_VAR 0 2
101811: NOT
101812: IFFALSE 101816
// exit ;
101814: GO 101865
// for i in tmp do
101816: LD_ADDR_VAR 0 1
101820: PUSH
101821: LD_VAR 0 2
101825: PUSH
101826: FOR_IN
101827: IFFALSE 101863
// begin if Crawls ( i ) then
101829: LD_VAR 0 1
101833: PPUSH
101834: CALL_OW 318
101838: IFFALSE 101849
// ComWalk ( i ) ;
101840: LD_VAR 0 1
101844: PPUSH
101845: CALL_OW 138
// SetClass ( i , 2 ) ;
101849: LD_VAR 0 1
101853: PPUSH
101854: LD_INT 2
101856: PPUSH
101857: CALL_OW 336
// end ;
101861: GO 101826
101863: POP
101864: POP
// end ;
101865: PPOPN 2
101867: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101868: LD_EXP 107
101872: PUSH
101873: LD_EXP 160
101877: AND
101878: IFFALSE 102166
101880: GO 101882
101882: DISABLE
101883: LD_INT 0
101885: PPUSH
101886: PPUSH
101887: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101888: LD_OWVAR 2
101892: PPUSH
101893: LD_INT 9
101895: PPUSH
101896: LD_INT 1
101898: PPUSH
101899: LD_INT 1
101901: PPUSH
101902: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101906: LD_INT 9
101908: PPUSH
101909: LD_OWVAR 2
101913: PPUSH
101914: CALL_OW 343
// uc_side := 9 ;
101918: LD_ADDR_OWVAR 20
101922: PUSH
101923: LD_INT 9
101925: ST_TO_ADDR
// uc_nation := 2 ;
101926: LD_ADDR_OWVAR 21
101930: PUSH
101931: LD_INT 2
101933: ST_TO_ADDR
// hc_name := Dark Warrior ;
101934: LD_ADDR_OWVAR 26
101938: PUSH
101939: LD_STRING Dark Warrior
101941: ST_TO_ADDR
// hc_gallery :=  ;
101942: LD_ADDR_OWVAR 33
101946: PUSH
101947: LD_STRING 
101949: ST_TO_ADDR
// hc_noskilllimit := true ;
101950: LD_ADDR_OWVAR 76
101954: PUSH
101955: LD_INT 1
101957: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101958: LD_ADDR_OWVAR 31
101962: PUSH
101963: LD_INT 30
101965: PUSH
101966: LD_INT 30
101968: PUSH
101969: LD_INT 30
101971: PUSH
101972: LD_INT 30
101974: PUSH
101975: EMPTY
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: ST_TO_ADDR
// un := CreateHuman ;
101981: LD_ADDR_VAR 0 3
101985: PUSH
101986: CALL_OW 44
101990: ST_TO_ADDR
// hc_noskilllimit := false ;
101991: LD_ADDR_OWVAR 76
101995: PUSH
101996: LD_INT 0
101998: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101999: LD_VAR 0 3
102003: PPUSH
102004: LD_INT 1
102006: PPUSH
102007: CALL_OW 51
// ToLua ( playRanger() ) ;
102011: LD_STRING playRanger()
102013: PPUSH
102014: CALL_OW 559
// p := 0 ;
102018: LD_ADDR_VAR 0 2
102022: PUSH
102023: LD_INT 0
102025: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102026: LD_INT 35
102028: PPUSH
102029: CALL_OW 67
// p := p + 1 ;
102033: LD_ADDR_VAR 0 2
102037: PUSH
102038: LD_VAR 0 2
102042: PUSH
102043: LD_INT 1
102045: PLUS
102046: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102047: LD_VAR 0 3
102051: PPUSH
102052: CALL_OW 256
102056: PUSH
102057: LD_INT 1000
102059: LESS
102060: IFFALSE 102074
// SetLives ( un , 1000 ) ;
102062: LD_VAR 0 3
102066: PPUSH
102067: LD_INT 1000
102069: PPUSH
102070: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102074: LD_VAR 0 3
102078: PPUSH
102079: LD_INT 81
102081: PUSH
102082: LD_OWVAR 2
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: PUSH
102091: LD_INT 91
102093: PUSH
102094: LD_VAR 0 3
102098: PUSH
102099: LD_INT 30
102101: PUSH
102102: EMPTY
102103: LIST
102104: LIST
102105: LIST
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PPUSH
102111: CALL_OW 69
102115: PPUSH
102116: LD_VAR 0 3
102120: PPUSH
102121: CALL_OW 74
102125: PPUSH
102126: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102130: LD_VAR 0 2
102134: PUSH
102135: LD_INT 80
102137: GREATER
102138: PUSH
102139: LD_VAR 0 3
102143: PPUSH
102144: CALL_OW 301
102148: OR
102149: IFFALSE 102026
// if un then
102151: LD_VAR 0 3
102155: IFFALSE 102166
// RemoveUnit ( un ) ;
102157: LD_VAR 0 3
102161: PPUSH
102162: CALL_OW 64
// end ;
102166: PPOPN 3
102168: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102169: LD_EXP 161
102173: IFFALSE 102289
102175: GO 102177
102177: DISABLE
102178: LD_INT 0
102180: PPUSH
102181: PPUSH
102182: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102183: LD_ADDR_VAR 0 2
102187: PUSH
102188: LD_INT 81
102190: PUSH
102191: LD_OWVAR 2
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PUSH
102200: LD_INT 21
102202: PUSH
102203: LD_INT 1
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PPUSH
102214: CALL_OW 69
102218: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102219: LD_STRING playComputer()
102221: PPUSH
102222: CALL_OW 559
// if not tmp then
102226: LD_VAR 0 2
102230: NOT
102231: IFFALSE 102235
// exit ;
102233: GO 102289
// for i in tmp do
102235: LD_ADDR_VAR 0 1
102239: PUSH
102240: LD_VAR 0 2
102244: PUSH
102245: FOR_IN
102246: IFFALSE 102287
// for j := 1 to 4 do
102248: LD_ADDR_VAR 0 3
102252: PUSH
102253: DOUBLE
102254: LD_INT 1
102256: DEC
102257: ST_TO_ADDR
102258: LD_INT 4
102260: PUSH
102261: FOR_TO
102262: IFFALSE 102283
// SetSkill ( i , j , 10 ) ;
102264: LD_VAR 0 1
102268: PPUSH
102269: LD_VAR 0 3
102273: PPUSH
102274: LD_INT 10
102276: PPUSH
102277: CALL_OW 237
102281: GO 102261
102283: POP
102284: POP
102285: GO 102245
102287: POP
102288: POP
// end ;
102289: PPOPN 3
102291: END
// every 0 0$1 trigger s30 do var i , tmp ;
102292: LD_EXP 162
102296: IFFALSE 102365
102298: GO 102300
102300: DISABLE
102301: LD_INT 0
102303: PPUSH
102304: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102305: LD_ADDR_VAR 0 2
102309: PUSH
102310: LD_INT 22
102312: PUSH
102313: LD_OWVAR 2
102317: PUSH
102318: EMPTY
102319: LIST
102320: LIST
102321: PPUSH
102322: CALL_OW 69
102326: ST_TO_ADDR
// if not tmp then
102327: LD_VAR 0 2
102331: NOT
102332: IFFALSE 102336
// exit ;
102334: GO 102365
// for i in tmp do
102336: LD_ADDR_VAR 0 1
102340: PUSH
102341: LD_VAR 0 2
102345: PUSH
102346: FOR_IN
102347: IFFALSE 102363
// SetLives ( i , 300 ) ;
102349: LD_VAR 0 1
102353: PPUSH
102354: LD_INT 300
102356: PPUSH
102357: CALL_OW 234
102361: GO 102346
102363: POP
102364: POP
// end ;
102365: PPOPN 2
102367: END
// every 0 0$1 trigger s60 do var i , tmp ;
102368: LD_EXP 163
102372: IFFALSE 102441
102374: GO 102376
102376: DISABLE
102377: LD_INT 0
102379: PPUSH
102380: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102381: LD_ADDR_VAR 0 2
102385: PUSH
102386: LD_INT 22
102388: PUSH
102389: LD_OWVAR 2
102393: PUSH
102394: EMPTY
102395: LIST
102396: LIST
102397: PPUSH
102398: CALL_OW 69
102402: ST_TO_ADDR
// if not tmp then
102403: LD_VAR 0 2
102407: NOT
102408: IFFALSE 102412
// exit ;
102410: GO 102441
// for i in tmp do
102412: LD_ADDR_VAR 0 1
102416: PUSH
102417: LD_VAR 0 2
102421: PUSH
102422: FOR_IN
102423: IFFALSE 102439
// SetLives ( i , 600 ) ;
102425: LD_VAR 0 1
102429: PPUSH
102430: LD_INT 600
102432: PPUSH
102433: CALL_OW 234
102437: GO 102422
102439: POP
102440: POP
// end ;
102441: PPOPN 2
102443: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102444: LD_INT 0
102446: PPUSH
// case cmd of 301 :
102447: LD_VAR 0 1
102451: PUSH
102452: LD_INT 301
102454: DOUBLE
102455: EQUAL
102456: IFTRUE 102460
102458: GO 102492
102460: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102461: LD_VAR 0 6
102465: PPUSH
102466: LD_VAR 0 7
102470: PPUSH
102471: LD_VAR 0 8
102475: PPUSH
102476: LD_VAR 0 4
102480: PPUSH
102481: LD_VAR 0 5
102485: PPUSH
102486: CALL 103701 0 5
102490: GO 102613
102492: LD_INT 302
102494: DOUBLE
102495: EQUAL
102496: IFTRUE 102500
102498: GO 102537
102500: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102501: LD_VAR 0 6
102505: PPUSH
102506: LD_VAR 0 7
102510: PPUSH
102511: LD_VAR 0 8
102515: PPUSH
102516: LD_VAR 0 9
102520: PPUSH
102521: LD_VAR 0 4
102525: PPUSH
102526: LD_VAR 0 5
102530: PPUSH
102531: CALL 103792 0 6
102535: GO 102613
102537: LD_INT 303
102539: DOUBLE
102540: EQUAL
102541: IFTRUE 102545
102543: GO 102582
102545: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102546: LD_VAR 0 6
102550: PPUSH
102551: LD_VAR 0 7
102555: PPUSH
102556: LD_VAR 0 8
102560: PPUSH
102561: LD_VAR 0 9
102565: PPUSH
102566: LD_VAR 0 4
102570: PPUSH
102571: LD_VAR 0 5
102575: PPUSH
102576: CALL 102618 0 6
102580: GO 102613
102582: LD_INT 304
102584: DOUBLE
102585: EQUAL
102586: IFTRUE 102590
102588: GO 102612
102590: POP
// hHackTeleport ( unit , x , y ) ; end ;
102591: LD_VAR 0 2
102595: PPUSH
102596: LD_VAR 0 4
102600: PPUSH
102601: LD_VAR 0 5
102605: PPUSH
102606: CALL 104385 0 3
102610: GO 102613
102612: POP
// end ;
102613: LD_VAR 0 12
102617: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102618: LD_INT 0
102620: PPUSH
102621: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102622: LD_VAR 0 1
102626: PUSH
102627: LD_INT 1
102629: LESS
102630: PUSH
102631: LD_VAR 0 1
102635: PUSH
102636: LD_INT 3
102638: GREATER
102639: OR
102640: PUSH
102641: LD_VAR 0 5
102645: PPUSH
102646: LD_VAR 0 6
102650: PPUSH
102651: CALL_OW 428
102655: OR
102656: IFFALSE 102660
// exit ;
102658: GO 103388
// uc_side := your_side ;
102660: LD_ADDR_OWVAR 20
102664: PUSH
102665: LD_OWVAR 2
102669: ST_TO_ADDR
// uc_nation := nation ;
102670: LD_ADDR_OWVAR 21
102674: PUSH
102675: LD_VAR 0 1
102679: ST_TO_ADDR
// bc_level = 1 ;
102680: LD_ADDR_OWVAR 43
102684: PUSH
102685: LD_INT 1
102687: ST_TO_ADDR
// case btype of 1 :
102688: LD_VAR 0 2
102692: PUSH
102693: LD_INT 1
102695: DOUBLE
102696: EQUAL
102697: IFTRUE 102701
102699: GO 102712
102701: POP
// bc_type := b_depot ; 2 :
102702: LD_ADDR_OWVAR 42
102706: PUSH
102707: LD_INT 0
102709: ST_TO_ADDR
102710: GO 103332
102712: LD_INT 2
102714: DOUBLE
102715: EQUAL
102716: IFTRUE 102720
102718: GO 102731
102720: POP
// bc_type := b_warehouse ; 3 :
102721: LD_ADDR_OWVAR 42
102725: PUSH
102726: LD_INT 1
102728: ST_TO_ADDR
102729: GO 103332
102731: LD_INT 3
102733: DOUBLE
102734: EQUAL
102735: IFTRUE 102739
102737: GO 102750
102739: POP
// bc_type := b_lab ; 4 .. 9 :
102740: LD_ADDR_OWVAR 42
102744: PUSH
102745: LD_INT 6
102747: ST_TO_ADDR
102748: GO 103332
102750: LD_INT 4
102752: DOUBLE
102753: GREATEREQUAL
102754: IFFALSE 102762
102756: LD_INT 9
102758: DOUBLE
102759: LESSEQUAL
102760: IFTRUE 102764
102762: GO 102824
102764: POP
// begin bc_type := b_lab_half ;
102765: LD_ADDR_OWVAR 42
102769: PUSH
102770: LD_INT 7
102772: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102773: LD_ADDR_OWVAR 44
102777: PUSH
102778: LD_INT 10
102780: PUSH
102781: LD_INT 11
102783: PUSH
102784: LD_INT 12
102786: PUSH
102787: LD_INT 15
102789: PUSH
102790: LD_INT 14
102792: PUSH
102793: LD_INT 13
102795: PUSH
102796: EMPTY
102797: LIST
102798: LIST
102799: LIST
102800: LIST
102801: LIST
102802: LIST
102803: PUSH
102804: LD_VAR 0 2
102808: PUSH
102809: LD_INT 3
102811: MINUS
102812: ARRAY
102813: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
102814: LD_ADDR_OWVAR 45
102818: PUSH
102819: LD_INT 9
102821: ST_TO_ADDR
// end ; 10 .. 13 :
102822: GO 103332
102824: LD_INT 10
102826: DOUBLE
102827: GREATEREQUAL
102828: IFFALSE 102836
102830: LD_INT 13
102832: DOUBLE
102833: LESSEQUAL
102834: IFTRUE 102838
102836: GO 102915
102838: POP
// begin bc_type := b_lab_full ;
102839: LD_ADDR_OWVAR 42
102843: PUSH
102844: LD_INT 8
102846: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102847: LD_ADDR_OWVAR 44
102851: PUSH
102852: LD_INT 10
102854: PUSH
102855: LD_INT 12
102857: PUSH
102858: LD_INT 14
102860: PUSH
102861: LD_INT 13
102863: PUSH
102864: EMPTY
102865: LIST
102866: LIST
102867: LIST
102868: LIST
102869: PUSH
102870: LD_VAR 0 2
102874: PUSH
102875: LD_INT 9
102877: MINUS
102878: ARRAY
102879: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102880: LD_ADDR_OWVAR 45
102884: PUSH
102885: LD_INT 11
102887: PUSH
102888: LD_INT 15
102890: PUSH
102891: LD_INT 12
102893: PUSH
102894: LD_INT 15
102896: PUSH
102897: EMPTY
102898: LIST
102899: LIST
102900: LIST
102901: LIST
102902: PUSH
102903: LD_VAR 0 2
102907: PUSH
102908: LD_INT 9
102910: MINUS
102911: ARRAY
102912: ST_TO_ADDR
// end ; 14 :
102913: GO 103332
102915: LD_INT 14
102917: DOUBLE
102918: EQUAL
102919: IFTRUE 102923
102921: GO 102934
102923: POP
// bc_type := b_workshop ; 15 :
102924: LD_ADDR_OWVAR 42
102928: PUSH
102929: LD_INT 2
102931: ST_TO_ADDR
102932: GO 103332
102934: LD_INT 15
102936: DOUBLE
102937: EQUAL
102938: IFTRUE 102942
102940: GO 102953
102942: POP
// bc_type := b_factory ; 16 :
102943: LD_ADDR_OWVAR 42
102947: PUSH
102948: LD_INT 3
102950: ST_TO_ADDR
102951: GO 103332
102953: LD_INT 16
102955: DOUBLE
102956: EQUAL
102957: IFTRUE 102961
102959: GO 102972
102961: POP
// bc_type := b_ext_gun ; 17 :
102962: LD_ADDR_OWVAR 42
102966: PUSH
102967: LD_INT 17
102969: ST_TO_ADDR
102970: GO 103332
102972: LD_INT 17
102974: DOUBLE
102975: EQUAL
102976: IFTRUE 102980
102978: GO 103008
102980: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102981: LD_ADDR_OWVAR 42
102985: PUSH
102986: LD_INT 19
102988: PUSH
102989: LD_INT 23
102991: PUSH
102992: LD_INT 19
102994: PUSH
102995: EMPTY
102996: LIST
102997: LIST
102998: LIST
102999: PUSH
103000: LD_VAR 0 1
103004: ARRAY
103005: ST_TO_ADDR
103006: GO 103332
103008: LD_INT 18
103010: DOUBLE
103011: EQUAL
103012: IFTRUE 103016
103014: GO 103027
103016: POP
// bc_type := b_ext_radar ; 19 :
103017: LD_ADDR_OWVAR 42
103021: PUSH
103022: LD_INT 20
103024: ST_TO_ADDR
103025: GO 103332
103027: LD_INT 19
103029: DOUBLE
103030: EQUAL
103031: IFTRUE 103035
103033: GO 103046
103035: POP
// bc_type := b_ext_radio ; 20 :
103036: LD_ADDR_OWVAR 42
103040: PUSH
103041: LD_INT 22
103043: ST_TO_ADDR
103044: GO 103332
103046: LD_INT 20
103048: DOUBLE
103049: EQUAL
103050: IFTRUE 103054
103052: GO 103065
103054: POP
// bc_type := b_ext_siberium ; 21 :
103055: LD_ADDR_OWVAR 42
103059: PUSH
103060: LD_INT 21
103062: ST_TO_ADDR
103063: GO 103332
103065: LD_INT 21
103067: DOUBLE
103068: EQUAL
103069: IFTRUE 103073
103071: GO 103084
103073: POP
// bc_type := b_ext_computer ; 22 :
103074: LD_ADDR_OWVAR 42
103078: PUSH
103079: LD_INT 24
103081: ST_TO_ADDR
103082: GO 103332
103084: LD_INT 22
103086: DOUBLE
103087: EQUAL
103088: IFTRUE 103092
103090: GO 103103
103092: POP
// bc_type := b_ext_track ; 23 :
103093: LD_ADDR_OWVAR 42
103097: PUSH
103098: LD_INT 16
103100: ST_TO_ADDR
103101: GO 103332
103103: LD_INT 23
103105: DOUBLE
103106: EQUAL
103107: IFTRUE 103111
103109: GO 103122
103111: POP
// bc_type := b_ext_laser ; 24 :
103112: LD_ADDR_OWVAR 42
103116: PUSH
103117: LD_INT 25
103119: ST_TO_ADDR
103120: GO 103332
103122: LD_INT 24
103124: DOUBLE
103125: EQUAL
103126: IFTRUE 103130
103128: GO 103141
103130: POP
// bc_type := b_control_tower ; 25 :
103131: LD_ADDR_OWVAR 42
103135: PUSH
103136: LD_INT 36
103138: ST_TO_ADDR
103139: GO 103332
103141: LD_INT 25
103143: DOUBLE
103144: EQUAL
103145: IFTRUE 103149
103147: GO 103160
103149: POP
// bc_type := b_breastwork ; 26 :
103150: LD_ADDR_OWVAR 42
103154: PUSH
103155: LD_INT 31
103157: ST_TO_ADDR
103158: GO 103332
103160: LD_INT 26
103162: DOUBLE
103163: EQUAL
103164: IFTRUE 103168
103166: GO 103179
103168: POP
// bc_type := b_bunker ; 27 :
103169: LD_ADDR_OWVAR 42
103173: PUSH
103174: LD_INT 32
103176: ST_TO_ADDR
103177: GO 103332
103179: LD_INT 27
103181: DOUBLE
103182: EQUAL
103183: IFTRUE 103187
103185: GO 103198
103187: POP
// bc_type := b_turret ; 28 :
103188: LD_ADDR_OWVAR 42
103192: PUSH
103193: LD_INT 33
103195: ST_TO_ADDR
103196: GO 103332
103198: LD_INT 28
103200: DOUBLE
103201: EQUAL
103202: IFTRUE 103206
103204: GO 103217
103206: POP
// bc_type := b_armoury ; 29 :
103207: LD_ADDR_OWVAR 42
103211: PUSH
103212: LD_INT 4
103214: ST_TO_ADDR
103215: GO 103332
103217: LD_INT 29
103219: DOUBLE
103220: EQUAL
103221: IFTRUE 103225
103223: GO 103236
103225: POP
// bc_type := b_barracks ; 30 :
103226: LD_ADDR_OWVAR 42
103230: PUSH
103231: LD_INT 5
103233: ST_TO_ADDR
103234: GO 103332
103236: LD_INT 30
103238: DOUBLE
103239: EQUAL
103240: IFTRUE 103244
103242: GO 103255
103244: POP
// bc_type := b_solar_power ; 31 :
103245: LD_ADDR_OWVAR 42
103249: PUSH
103250: LD_INT 27
103252: ST_TO_ADDR
103253: GO 103332
103255: LD_INT 31
103257: DOUBLE
103258: EQUAL
103259: IFTRUE 103263
103261: GO 103274
103263: POP
// bc_type := b_oil_power ; 32 :
103264: LD_ADDR_OWVAR 42
103268: PUSH
103269: LD_INT 26
103271: ST_TO_ADDR
103272: GO 103332
103274: LD_INT 32
103276: DOUBLE
103277: EQUAL
103278: IFTRUE 103282
103280: GO 103293
103282: POP
// bc_type := b_siberite_power ; 33 :
103283: LD_ADDR_OWVAR 42
103287: PUSH
103288: LD_INT 28
103290: ST_TO_ADDR
103291: GO 103332
103293: LD_INT 33
103295: DOUBLE
103296: EQUAL
103297: IFTRUE 103301
103299: GO 103312
103301: POP
// bc_type := b_oil_mine ; 34 :
103302: LD_ADDR_OWVAR 42
103306: PUSH
103307: LD_INT 29
103309: ST_TO_ADDR
103310: GO 103332
103312: LD_INT 34
103314: DOUBLE
103315: EQUAL
103316: IFTRUE 103320
103318: GO 103331
103320: POP
// bc_type := b_siberite_mine ; end ;
103321: LD_ADDR_OWVAR 42
103325: PUSH
103326: LD_INT 30
103328: ST_TO_ADDR
103329: GO 103332
103331: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103332: LD_ADDR_VAR 0 8
103336: PUSH
103337: LD_VAR 0 5
103341: PPUSH
103342: LD_VAR 0 6
103346: PPUSH
103347: LD_VAR 0 3
103351: PPUSH
103352: CALL_OW 47
103356: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103357: LD_OWVAR 42
103361: PUSH
103362: LD_INT 32
103364: PUSH
103365: LD_INT 33
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: IN
103372: IFFALSE 103388
// PlaceWeaponTurret ( b , weapon ) ;
103374: LD_VAR 0 8
103378: PPUSH
103379: LD_VAR 0 4
103383: PPUSH
103384: CALL_OW 431
// end ;
103388: LD_VAR 0 7
103392: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103393: LD_INT 0
103395: PPUSH
103396: PPUSH
103397: PPUSH
103398: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103399: LD_ADDR_VAR 0 4
103403: PUSH
103404: LD_INT 22
103406: PUSH
103407: LD_OWVAR 2
103411: PUSH
103412: EMPTY
103413: LIST
103414: LIST
103415: PUSH
103416: LD_INT 2
103418: PUSH
103419: LD_INT 30
103421: PUSH
103422: LD_INT 0
103424: PUSH
103425: EMPTY
103426: LIST
103427: LIST
103428: PUSH
103429: LD_INT 30
103431: PUSH
103432: LD_INT 1
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: LIST
103443: PUSH
103444: EMPTY
103445: LIST
103446: LIST
103447: PPUSH
103448: CALL_OW 69
103452: ST_TO_ADDR
// if not tmp then
103453: LD_VAR 0 4
103457: NOT
103458: IFFALSE 103462
// exit ;
103460: GO 103521
// for i in tmp do
103462: LD_ADDR_VAR 0 2
103466: PUSH
103467: LD_VAR 0 4
103471: PUSH
103472: FOR_IN
103473: IFFALSE 103519
// for j = 1 to 3 do
103475: LD_ADDR_VAR 0 3
103479: PUSH
103480: DOUBLE
103481: LD_INT 1
103483: DEC
103484: ST_TO_ADDR
103485: LD_INT 3
103487: PUSH
103488: FOR_TO
103489: IFFALSE 103515
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103491: LD_VAR 0 2
103495: PPUSH
103496: CALL_OW 274
103500: PPUSH
103501: LD_VAR 0 3
103505: PPUSH
103506: LD_INT 99999
103508: PPUSH
103509: CALL_OW 277
103513: GO 103488
103515: POP
103516: POP
103517: GO 103472
103519: POP
103520: POP
// end ;
103521: LD_VAR 0 1
103525: RET
// export function hHackSetLevel10 ; var i , j ; begin
103526: LD_INT 0
103528: PPUSH
103529: PPUSH
103530: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103531: LD_ADDR_VAR 0 2
103535: PUSH
103536: LD_INT 21
103538: PUSH
103539: LD_INT 1
103541: PUSH
103542: EMPTY
103543: LIST
103544: LIST
103545: PPUSH
103546: CALL_OW 69
103550: PUSH
103551: FOR_IN
103552: IFFALSE 103604
// if IsSelected ( i ) then
103554: LD_VAR 0 2
103558: PPUSH
103559: CALL_OW 306
103563: IFFALSE 103602
// begin for j := 1 to 4 do
103565: LD_ADDR_VAR 0 3
103569: PUSH
103570: DOUBLE
103571: LD_INT 1
103573: DEC
103574: ST_TO_ADDR
103575: LD_INT 4
103577: PUSH
103578: FOR_TO
103579: IFFALSE 103600
// SetSkill ( i , j , 10 ) ;
103581: LD_VAR 0 2
103585: PPUSH
103586: LD_VAR 0 3
103590: PPUSH
103591: LD_INT 10
103593: PPUSH
103594: CALL_OW 237
103598: GO 103578
103600: POP
103601: POP
// end ;
103602: GO 103551
103604: POP
103605: POP
// end ;
103606: LD_VAR 0 1
103610: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103611: LD_INT 0
103613: PPUSH
103614: PPUSH
103615: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103616: LD_ADDR_VAR 0 2
103620: PUSH
103621: LD_INT 22
103623: PUSH
103624: LD_OWVAR 2
103628: PUSH
103629: EMPTY
103630: LIST
103631: LIST
103632: PUSH
103633: LD_INT 21
103635: PUSH
103636: LD_INT 1
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: PUSH
103643: EMPTY
103644: LIST
103645: LIST
103646: PPUSH
103647: CALL_OW 69
103651: PUSH
103652: FOR_IN
103653: IFFALSE 103694
// begin for j := 1 to 4 do
103655: LD_ADDR_VAR 0 3
103659: PUSH
103660: DOUBLE
103661: LD_INT 1
103663: DEC
103664: ST_TO_ADDR
103665: LD_INT 4
103667: PUSH
103668: FOR_TO
103669: IFFALSE 103690
// SetSkill ( i , j , 10 ) ;
103671: LD_VAR 0 2
103675: PPUSH
103676: LD_VAR 0 3
103680: PPUSH
103681: LD_INT 10
103683: PPUSH
103684: CALL_OW 237
103688: GO 103668
103690: POP
103691: POP
// end ;
103692: GO 103652
103694: POP
103695: POP
// end ;
103696: LD_VAR 0 1
103700: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103701: LD_INT 0
103703: PPUSH
// uc_side := your_side ;
103704: LD_ADDR_OWVAR 20
103708: PUSH
103709: LD_OWVAR 2
103713: ST_TO_ADDR
// uc_nation := nation ;
103714: LD_ADDR_OWVAR 21
103718: PUSH
103719: LD_VAR 0 1
103723: ST_TO_ADDR
// InitHc ;
103724: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103728: LD_INT 0
103730: PPUSH
103731: LD_VAR 0 2
103735: PPUSH
103736: LD_VAR 0 3
103740: PPUSH
103741: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103745: LD_VAR 0 4
103749: PPUSH
103750: LD_VAR 0 5
103754: PPUSH
103755: CALL_OW 428
103759: PUSH
103760: LD_INT 0
103762: EQUAL
103763: IFFALSE 103787
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103765: CALL_OW 44
103769: PPUSH
103770: LD_VAR 0 4
103774: PPUSH
103775: LD_VAR 0 5
103779: PPUSH
103780: LD_INT 1
103782: PPUSH
103783: CALL_OW 48
// end ;
103787: LD_VAR 0 6
103791: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103792: LD_INT 0
103794: PPUSH
103795: PPUSH
// uc_side := your_side ;
103796: LD_ADDR_OWVAR 20
103800: PUSH
103801: LD_OWVAR 2
103805: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103806: LD_VAR 0 1
103810: PUSH
103811: LD_INT 1
103813: PUSH
103814: LD_INT 2
103816: PUSH
103817: LD_INT 3
103819: PUSH
103820: LD_INT 4
103822: PUSH
103823: LD_INT 5
103825: PUSH
103826: EMPTY
103827: LIST
103828: LIST
103829: LIST
103830: LIST
103831: LIST
103832: IN
103833: IFFALSE 103845
// uc_nation := nation_american else
103835: LD_ADDR_OWVAR 21
103839: PUSH
103840: LD_INT 1
103842: ST_TO_ADDR
103843: GO 103888
// if chassis in [ 11 , 12 , 13 , 14 ] then
103845: LD_VAR 0 1
103849: PUSH
103850: LD_INT 11
103852: PUSH
103853: LD_INT 12
103855: PUSH
103856: LD_INT 13
103858: PUSH
103859: LD_INT 14
103861: PUSH
103862: EMPTY
103863: LIST
103864: LIST
103865: LIST
103866: LIST
103867: IN
103868: IFFALSE 103880
// uc_nation := nation_arabian else
103870: LD_ADDR_OWVAR 21
103874: PUSH
103875: LD_INT 2
103877: ST_TO_ADDR
103878: GO 103888
// uc_nation := nation_russian ;
103880: LD_ADDR_OWVAR 21
103884: PUSH
103885: LD_INT 3
103887: ST_TO_ADDR
// vc_chassis := chassis ;
103888: LD_ADDR_OWVAR 37
103892: PUSH
103893: LD_VAR 0 1
103897: ST_TO_ADDR
// vc_engine := engine ;
103898: LD_ADDR_OWVAR 39
103902: PUSH
103903: LD_VAR 0 2
103907: ST_TO_ADDR
// vc_control := control ;
103908: LD_ADDR_OWVAR 38
103912: PUSH
103913: LD_VAR 0 3
103917: ST_TO_ADDR
// vc_weapon := weapon ;
103918: LD_ADDR_OWVAR 40
103922: PUSH
103923: LD_VAR 0 4
103927: ST_TO_ADDR
// un := CreateVehicle ;
103928: LD_ADDR_VAR 0 8
103932: PUSH
103933: CALL_OW 45
103937: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103938: LD_VAR 0 8
103942: PPUSH
103943: LD_INT 0
103945: PPUSH
103946: LD_INT 5
103948: PPUSH
103949: CALL_OW 12
103953: PPUSH
103954: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103958: LD_VAR 0 8
103962: PPUSH
103963: LD_VAR 0 5
103967: PPUSH
103968: LD_VAR 0 6
103972: PPUSH
103973: LD_INT 1
103975: PPUSH
103976: CALL_OW 48
// end ;
103980: LD_VAR 0 7
103984: RET
// export hInvincible ; every 1 do
103985: GO 103987
103987: DISABLE
// hInvincible := [ ] ;
103988: LD_ADDR_EXP 164
103992: PUSH
103993: EMPTY
103994: ST_TO_ADDR
103995: END
// every 10 do var i ;
103996: GO 103998
103998: DISABLE
103999: LD_INT 0
104001: PPUSH
// begin enable ;
104002: ENABLE
// if not hInvincible then
104003: LD_EXP 164
104007: NOT
104008: IFFALSE 104012
// exit ;
104010: GO 104056
// for i in hInvincible do
104012: LD_ADDR_VAR 0 1
104016: PUSH
104017: LD_EXP 164
104021: PUSH
104022: FOR_IN
104023: IFFALSE 104054
// if GetLives ( i ) < 1000 then
104025: LD_VAR 0 1
104029: PPUSH
104030: CALL_OW 256
104034: PUSH
104035: LD_INT 1000
104037: LESS
104038: IFFALSE 104052
// SetLives ( i , 1000 ) ;
104040: LD_VAR 0 1
104044: PPUSH
104045: LD_INT 1000
104047: PPUSH
104048: CALL_OW 234
104052: GO 104022
104054: POP
104055: POP
// end ;
104056: PPOPN 1
104058: END
// export function hHackInvincible ; var i ; begin
104059: LD_INT 0
104061: PPUSH
104062: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104063: LD_ADDR_VAR 0 2
104067: PUSH
104068: LD_INT 2
104070: PUSH
104071: LD_INT 21
104073: PUSH
104074: LD_INT 1
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PUSH
104081: LD_INT 21
104083: PUSH
104084: LD_INT 2
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: PUSH
104091: EMPTY
104092: LIST
104093: LIST
104094: LIST
104095: PPUSH
104096: CALL_OW 69
104100: PUSH
104101: FOR_IN
104102: IFFALSE 104163
// if IsSelected ( i ) then
104104: LD_VAR 0 2
104108: PPUSH
104109: CALL_OW 306
104113: IFFALSE 104161
// begin if i in hInvincible then
104115: LD_VAR 0 2
104119: PUSH
104120: LD_EXP 164
104124: IN
104125: IFFALSE 104145
// hInvincible := hInvincible diff i else
104127: LD_ADDR_EXP 164
104131: PUSH
104132: LD_EXP 164
104136: PUSH
104137: LD_VAR 0 2
104141: DIFF
104142: ST_TO_ADDR
104143: GO 104161
// hInvincible := hInvincible union i ;
104145: LD_ADDR_EXP 164
104149: PUSH
104150: LD_EXP 164
104154: PUSH
104155: LD_VAR 0 2
104159: UNION
104160: ST_TO_ADDR
// end ;
104161: GO 104101
104163: POP
104164: POP
// end ;
104165: LD_VAR 0 1
104169: RET
// export function hHackInvisible ; var i , j ; begin
104170: LD_INT 0
104172: PPUSH
104173: PPUSH
104174: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104175: LD_ADDR_VAR 0 2
104179: PUSH
104180: LD_INT 21
104182: PUSH
104183: LD_INT 1
104185: PUSH
104186: EMPTY
104187: LIST
104188: LIST
104189: PPUSH
104190: CALL_OW 69
104194: PUSH
104195: FOR_IN
104196: IFFALSE 104220
// if IsSelected ( i ) then
104198: LD_VAR 0 2
104202: PPUSH
104203: CALL_OW 306
104207: IFFALSE 104218
// ComForceInvisible ( i ) ;
104209: LD_VAR 0 2
104213: PPUSH
104214: CALL_OW 496
104218: GO 104195
104220: POP
104221: POP
// end ;
104222: LD_VAR 0 1
104226: RET
// export function hHackChangeYourSide ; begin
104227: LD_INT 0
104229: PPUSH
// if your_side = 8 then
104230: LD_OWVAR 2
104234: PUSH
104235: LD_INT 8
104237: EQUAL
104238: IFFALSE 104250
// your_side := 0 else
104240: LD_ADDR_OWVAR 2
104244: PUSH
104245: LD_INT 0
104247: ST_TO_ADDR
104248: GO 104264
// your_side := your_side + 1 ;
104250: LD_ADDR_OWVAR 2
104254: PUSH
104255: LD_OWVAR 2
104259: PUSH
104260: LD_INT 1
104262: PLUS
104263: ST_TO_ADDR
// end ;
104264: LD_VAR 0 1
104268: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104269: LD_INT 0
104271: PPUSH
104272: PPUSH
104273: PPUSH
// for i in all_units do
104274: LD_ADDR_VAR 0 2
104278: PUSH
104279: LD_OWVAR 3
104283: PUSH
104284: FOR_IN
104285: IFFALSE 104363
// if IsSelected ( i ) then
104287: LD_VAR 0 2
104291: PPUSH
104292: CALL_OW 306
104296: IFFALSE 104361
// begin j := GetSide ( i ) ;
104298: LD_ADDR_VAR 0 3
104302: PUSH
104303: LD_VAR 0 2
104307: PPUSH
104308: CALL_OW 255
104312: ST_TO_ADDR
// if j = 8 then
104313: LD_VAR 0 3
104317: PUSH
104318: LD_INT 8
104320: EQUAL
104321: IFFALSE 104333
// j := 0 else
104323: LD_ADDR_VAR 0 3
104327: PUSH
104328: LD_INT 0
104330: ST_TO_ADDR
104331: GO 104347
// j := j + 1 ;
104333: LD_ADDR_VAR 0 3
104337: PUSH
104338: LD_VAR 0 3
104342: PUSH
104343: LD_INT 1
104345: PLUS
104346: ST_TO_ADDR
// SetSide ( i , j ) ;
104347: LD_VAR 0 2
104351: PPUSH
104352: LD_VAR 0 3
104356: PPUSH
104357: CALL_OW 235
// end ;
104361: GO 104284
104363: POP
104364: POP
// end ;
104365: LD_VAR 0 1
104369: RET
// export function hHackFog ; begin
104370: LD_INT 0
104372: PPUSH
// FogOff ( true ) ;
104373: LD_INT 1
104375: PPUSH
104376: CALL_OW 344
// end ;
104380: LD_VAR 0 1
104384: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104385: LD_INT 0
104387: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104388: LD_VAR 0 1
104392: PPUSH
104393: LD_VAR 0 2
104397: PPUSH
104398: LD_VAR 0 3
104402: PPUSH
104403: LD_INT 1
104405: PPUSH
104406: LD_INT 1
104408: PPUSH
104409: CALL_OW 483
// CenterOnXY ( x , y ) ;
104413: LD_VAR 0 2
104417: PPUSH
104418: LD_VAR 0 3
104422: PPUSH
104423: CALL_OW 84
// end ;
104427: LD_VAR 0 4
104431: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104432: LD_INT 0
104434: PPUSH
104435: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104436: LD_VAR 0 1
104440: NOT
104441: PUSH
104442: LD_VAR 0 2
104446: PPUSH
104447: LD_VAR 0 3
104451: PPUSH
104452: CALL_OW 488
104456: NOT
104457: OR
104458: PUSH
104459: LD_VAR 0 1
104463: PPUSH
104464: CALL_OW 266
104468: PUSH
104469: LD_INT 3
104471: NONEQUAL
104472: PUSH
104473: LD_VAR 0 1
104477: PPUSH
104478: CALL_OW 247
104482: PUSH
104483: LD_INT 1
104485: EQUAL
104486: NOT
104487: AND
104488: OR
104489: IFFALSE 104493
// exit ;
104491: GO 104642
// if GetType ( factory ) = unit_human then
104493: LD_VAR 0 1
104497: PPUSH
104498: CALL_OW 247
104502: PUSH
104503: LD_INT 1
104505: EQUAL
104506: IFFALSE 104523
// factory := IsInUnit ( factory ) ;
104508: LD_ADDR_VAR 0 1
104512: PUSH
104513: LD_VAR 0 1
104517: PPUSH
104518: CALL_OW 310
104522: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104523: LD_VAR 0 1
104527: PPUSH
104528: CALL_OW 266
104532: PUSH
104533: LD_INT 3
104535: NONEQUAL
104536: IFFALSE 104540
// exit ;
104538: GO 104642
// if HexInfo ( x , y ) = factory then
104540: LD_VAR 0 2
104544: PPUSH
104545: LD_VAR 0 3
104549: PPUSH
104550: CALL_OW 428
104554: PUSH
104555: LD_VAR 0 1
104559: EQUAL
104560: IFFALSE 104587
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104562: LD_ADDR_EXP 165
104566: PUSH
104567: LD_EXP 165
104571: PPUSH
104572: LD_VAR 0 1
104576: PPUSH
104577: LD_INT 0
104579: PPUSH
104580: CALL_OW 1
104584: ST_TO_ADDR
104585: GO 104638
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104587: LD_ADDR_EXP 165
104591: PUSH
104592: LD_EXP 165
104596: PPUSH
104597: LD_VAR 0 1
104601: PPUSH
104602: LD_VAR 0 1
104606: PPUSH
104607: CALL_OW 255
104611: PUSH
104612: LD_VAR 0 1
104616: PUSH
104617: LD_VAR 0 2
104621: PUSH
104622: LD_VAR 0 3
104626: PUSH
104627: EMPTY
104628: LIST
104629: LIST
104630: LIST
104631: LIST
104632: PPUSH
104633: CALL_OW 1
104637: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104638: CALL 104647 0 0
// end ;
104642: LD_VAR 0 4
104646: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104647: LD_INT 0
104649: PPUSH
104650: PPUSH
104651: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104652: LD_STRING resetFactoryWaypoint();
104654: PPUSH
104655: CALL_OW 559
// if factoryWaypoints then
104659: LD_EXP 165
104663: IFFALSE 104789
// begin list := PrepareArray ( factoryWaypoints ) ;
104665: LD_ADDR_VAR 0 3
104669: PUSH
104670: LD_EXP 165
104674: PPUSH
104675: CALL 57894 0 1
104679: ST_TO_ADDR
// for i := 1 to list do
104680: LD_ADDR_VAR 0 2
104684: PUSH
104685: DOUBLE
104686: LD_INT 1
104688: DEC
104689: ST_TO_ADDR
104690: LD_VAR 0 3
104694: PUSH
104695: FOR_TO
104696: IFFALSE 104787
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104698: LD_STRING setFactoryWaypointXY(
104700: PUSH
104701: LD_VAR 0 3
104705: PUSH
104706: LD_VAR 0 2
104710: ARRAY
104711: PUSH
104712: LD_INT 1
104714: ARRAY
104715: STR
104716: PUSH
104717: LD_STRING ,
104719: STR
104720: PUSH
104721: LD_VAR 0 3
104725: PUSH
104726: LD_VAR 0 2
104730: ARRAY
104731: PUSH
104732: LD_INT 2
104734: ARRAY
104735: STR
104736: PUSH
104737: LD_STRING ,
104739: STR
104740: PUSH
104741: LD_VAR 0 3
104745: PUSH
104746: LD_VAR 0 2
104750: ARRAY
104751: PUSH
104752: LD_INT 3
104754: ARRAY
104755: STR
104756: PUSH
104757: LD_STRING ,
104759: STR
104760: PUSH
104761: LD_VAR 0 3
104765: PUSH
104766: LD_VAR 0 2
104770: ARRAY
104771: PUSH
104772: LD_INT 4
104774: ARRAY
104775: STR
104776: PUSH
104777: LD_STRING )
104779: STR
104780: PPUSH
104781: CALL_OW 559
104785: GO 104695
104787: POP
104788: POP
// end ; end ;
104789: LD_VAR 0 1
104793: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104794: LD_INT 0
104796: PPUSH
// if HexInfo ( x , y ) = warehouse then
104797: LD_VAR 0 2
104801: PPUSH
104802: LD_VAR 0 3
104806: PPUSH
104807: CALL_OW 428
104811: PUSH
104812: LD_VAR 0 1
104816: EQUAL
104817: IFFALSE 104844
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104819: LD_ADDR_EXP 166
104823: PUSH
104824: LD_EXP 166
104828: PPUSH
104829: LD_VAR 0 1
104833: PPUSH
104834: LD_INT 0
104836: PPUSH
104837: CALL_OW 1
104841: ST_TO_ADDR
104842: GO 104895
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104844: LD_ADDR_EXP 166
104848: PUSH
104849: LD_EXP 166
104853: PPUSH
104854: LD_VAR 0 1
104858: PPUSH
104859: LD_VAR 0 1
104863: PPUSH
104864: CALL_OW 255
104868: PUSH
104869: LD_VAR 0 1
104873: PUSH
104874: LD_VAR 0 2
104878: PUSH
104879: LD_VAR 0 3
104883: PUSH
104884: EMPTY
104885: LIST
104886: LIST
104887: LIST
104888: LIST
104889: PPUSH
104890: CALL_OW 1
104894: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104895: CALL 104904 0 0
// end ;
104899: LD_VAR 0 4
104903: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104904: LD_INT 0
104906: PPUSH
104907: PPUSH
104908: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104909: LD_STRING resetWarehouseGatheringPoints();
104911: PPUSH
104912: CALL_OW 559
// if warehouseGatheringPoints then
104916: LD_EXP 166
104920: IFFALSE 105046
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104922: LD_ADDR_VAR 0 3
104926: PUSH
104927: LD_EXP 166
104931: PPUSH
104932: CALL 57894 0 1
104936: ST_TO_ADDR
// for i := 1 to list do
104937: LD_ADDR_VAR 0 2
104941: PUSH
104942: DOUBLE
104943: LD_INT 1
104945: DEC
104946: ST_TO_ADDR
104947: LD_VAR 0 3
104951: PUSH
104952: FOR_TO
104953: IFFALSE 105044
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104955: LD_STRING setWarehouseGatheringPointXY(
104957: PUSH
104958: LD_VAR 0 3
104962: PUSH
104963: LD_VAR 0 2
104967: ARRAY
104968: PUSH
104969: LD_INT 1
104971: ARRAY
104972: STR
104973: PUSH
104974: LD_STRING ,
104976: STR
104977: PUSH
104978: LD_VAR 0 3
104982: PUSH
104983: LD_VAR 0 2
104987: ARRAY
104988: PUSH
104989: LD_INT 2
104991: ARRAY
104992: STR
104993: PUSH
104994: LD_STRING ,
104996: STR
104997: PUSH
104998: LD_VAR 0 3
105002: PUSH
105003: LD_VAR 0 2
105007: ARRAY
105008: PUSH
105009: LD_INT 3
105011: ARRAY
105012: STR
105013: PUSH
105014: LD_STRING ,
105016: STR
105017: PUSH
105018: LD_VAR 0 3
105022: PUSH
105023: LD_VAR 0 2
105027: ARRAY
105028: PUSH
105029: LD_INT 4
105031: ARRAY
105032: STR
105033: PUSH
105034: LD_STRING )
105036: STR
105037: PPUSH
105038: CALL_OW 559
105042: GO 104952
105044: POP
105045: POP
// end ; end ;
105046: LD_VAR 0 1
105050: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105051: LD_EXP 166
105055: IFFALSE 105740
105057: GO 105059
105059: DISABLE
105060: LD_INT 0
105062: PPUSH
105063: PPUSH
105064: PPUSH
105065: PPUSH
105066: PPUSH
105067: PPUSH
105068: PPUSH
105069: PPUSH
105070: PPUSH
// begin enable ;
105071: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105072: LD_ADDR_VAR 0 3
105076: PUSH
105077: LD_EXP 166
105081: PPUSH
105082: CALL 57894 0 1
105086: ST_TO_ADDR
// if not list then
105087: LD_VAR 0 3
105091: NOT
105092: IFFALSE 105096
// exit ;
105094: GO 105740
// for i := 1 to list do
105096: LD_ADDR_VAR 0 1
105100: PUSH
105101: DOUBLE
105102: LD_INT 1
105104: DEC
105105: ST_TO_ADDR
105106: LD_VAR 0 3
105110: PUSH
105111: FOR_TO
105112: IFFALSE 105738
// begin depot := list [ i ] [ 2 ] ;
105114: LD_ADDR_VAR 0 8
105118: PUSH
105119: LD_VAR 0 3
105123: PUSH
105124: LD_VAR 0 1
105128: ARRAY
105129: PUSH
105130: LD_INT 2
105132: ARRAY
105133: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105134: LD_ADDR_VAR 0 5
105138: PUSH
105139: LD_VAR 0 3
105143: PUSH
105144: LD_VAR 0 1
105148: ARRAY
105149: PUSH
105150: LD_INT 1
105152: ARRAY
105153: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105154: LD_VAR 0 8
105158: PPUSH
105159: CALL_OW 301
105163: PUSH
105164: LD_VAR 0 5
105168: PUSH
105169: LD_VAR 0 8
105173: PPUSH
105174: CALL_OW 255
105178: NONEQUAL
105179: OR
105180: IFFALSE 105209
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105182: LD_ADDR_EXP 166
105186: PUSH
105187: LD_EXP 166
105191: PPUSH
105192: LD_VAR 0 8
105196: PPUSH
105197: LD_INT 0
105199: PPUSH
105200: CALL_OW 1
105204: ST_TO_ADDR
// exit ;
105205: POP
105206: POP
105207: GO 105740
// end ; x := list [ i ] [ 3 ] ;
105209: LD_ADDR_VAR 0 6
105213: PUSH
105214: LD_VAR 0 3
105218: PUSH
105219: LD_VAR 0 1
105223: ARRAY
105224: PUSH
105225: LD_INT 3
105227: ARRAY
105228: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105229: LD_ADDR_VAR 0 7
105233: PUSH
105234: LD_VAR 0 3
105238: PUSH
105239: LD_VAR 0 1
105243: ARRAY
105244: PUSH
105245: LD_INT 4
105247: ARRAY
105248: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105249: LD_ADDR_VAR 0 9
105253: PUSH
105254: LD_VAR 0 6
105258: PPUSH
105259: LD_VAR 0 7
105263: PPUSH
105264: LD_INT 16
105266: PPUSH
105267: CALL 56482 0 3
105271: ST_TO_ADDR
// if not cratesNearbyPoint then
105272: LD_VAR 0 9
105276: NOT
105277: IFFALSE 105283
// exit ;
105279: POP
105280: POP
105281: GO 105740
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105283: LD_ADDR_VAR 0 4
105287: PUSH
105288: LD_INT 22
105290: PUSH
105291: LD_VAR 0 5
105295: PUSH
105296: EMPTY
105297: LIST
105298: LIST
105299: PUSH
105300: LD_INT 3
105302: PUSH
105303: LD_INT 60
105305: PUSH
105306: EMPTY
105307: LIST
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: PUSH
105313: LD_INT 91
105315: PUSH
105316: LD_VAR 0 8
105320: PUSH
105321: LD_INT 6
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: LIST
105328: PUSH
105329: LD_INT 2
105331: PUSH
105332: LD_INT 25
105334: PUSH
105335: LD_INT 2
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: PUSH
105342: LD_INT 25
105344: PUSH
105345: LD_INT 16
105347: PUSH
105348: EMPTY
105349: LIST
105350: LIST
105351: PUSH
105352: EMPTY
105353: LIST
105354: LIST
105355: LIST
105356: PUSH
105357: EMPTY
105358: LIST
105359: LIST
105360: LIST
105361: LIST
105362: PPUSH
105363: CALL_OW 69
105367: PUSH
105368: LD_VAR 0 8
105372: PPUSH
105373: CALL_OW 313
105377: PPUSH
105378: LD_INT 3
105380: PUSH
105381: LD_INT 60
105383: PUSH
105384: EMPTY
105385: LIST
105386: PUSH
105387: EMPTY
105388: LIST
105389: LIST
105390: PUSH
105391: LD_INT 2
105393: PUSH
105394: LD_INT 25
105396: PUSH
105397: LD_INT 2
105399: PUSH
105400: EMPTY
105401: LIST
105402: LIST
105403: PUSH
105404: LD_INT 25
105406: PUSH
105407: LD_INT 16
105409: PUSH
105410: EMPTY
105411: LIST
105412: LIST
105413: PUSH
105414: EMPTY
105415: LIST
105416: LIST
105417: LIST
105418: PUSH
105419: EMPTY
105420: LIST
105421: LIST
105422: PPUSH
105423: CALL_OW 72
105427: UNION
105428: ST_TO_ADDR
// if tmp then
105429: LD_VAR 0 4
105433: IFFALSE 105513
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105435: LD_ADDR_VAR 0 4
105439: PUSH
105440: LD_VAR 0 4
105444: PPUSH
105445: LD_INT 3
105447: PPUSH
105448: CALL 54451 0 2
105452: ST_TO_ADDR
// for j in tmp do
105453: LD_ADDR_VAR 0 2
105457: PUSH
105458: LD_VAR 0 4
105462: PUSH
105463: FOR_IN
105464: IFFALSE 105507
// begin if IsInUnit ( j ) then
105466: LD_VAR 0 2
105470: PPUSH
105471: CALL_OW 310
105475: IFFALSE 105486
// ComExit ( j ) ;
105477: LD_VAR 0 2
105481: PPUSH
105482: CALL 54534 0 1
// AddComCollect ( j , x , y ) ;
105486: LD_VAR 0 2
105490: PPUSH
105491: LD_VAR 0 6
105495: PPUSH
105496: LD_VAR 0 7
105500: PPUSH
105501: CALL_OW 177
// end ;
105505: GO 105463
105507: POP
105508: POP
// exit ;
105509: POP
105510: POP
105511: GO 105740
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105513: LD_ADDR_VAR 0 4
105517: PUSH
105518: LD_INT 22
105520: PUSH
105521: LD_VAR 0 5
105525: PUSH
105526: EMPTY
105527: LIST
105528: LIST
105529: PUSH
105530: LD_INT 91
105532: PUSH
105533: LD_VAR 0 8
105537: PUSH
105538: LD_INT 8
105540: PUSH
105541: EMPTY
105542: LIST
105543: LIST
105544: LIST
105545: PUSH
105546: LD_INT 2
105548: PUSH
105549: LD_INT 34
105551: PUSH
105552: LD_INT 12
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: PUSH
105559: LD_INT 34
105561: PUSH
105562: LD_INT 51
105564: PUSH
105565: EMPTY
105566: LIST
105567: LIST
105568: PUSH
105569: LD_INT 34
105571: PUSH
105572: LD_INT 32
105574: PUSH
105575: EMPTY
105576: LIST
105577: LIST
105578: PUSH
105579: LD_INT 34
105581: PUSH
105582: LD_INT 89
105584: PUSH
105585: EMPTY
105586: LIST
105587: LIST
105588: PUSH
105589: EMPTY
105590: LIST
105591: LIST
105592: LIST
105593: LIST
105594: LIST
105595: PUSH
105596: EMPTY
105597: LIST
105598: LIST
105599: LIST
105600: PPUSH
105601: CALL_OW 69
105605: ST_TO_ADDR
// if tmp then
105606: LD_VAR 0 4
105610: IFFALSE 105736
// begin for j in tmp do
105612: LD_ADDR_VAR 0 2
105616: PUSH
105617: LD_VAR 0 4
105621: PUSH
105622: FOR_IN
105623: IFFALSE 105734
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105625: LD_VAR 0 2
105629: PPUSH
105630: CALL_OW 262
105634: PUSH
105635: LD_INT 3
105637: EQUAL
105638: PUSH
105639: LD_VAR 0 2
105643: PPUSH
105644: CALL_OW 261
105648: PUSH
105649: LD_INT 20
105651: GREATER
105652: OR
105653: PUSH
105654: LD_VAR 0 2
105658: PPUSH
105659: CALL_OW 314
105663: NOT
105664: AND
105665: PUSH
105666: LD_VAR 0 2
105670: PPUSH
105671: CALL_OW 263
105675: PUSH
105676: LD_INT 1
105678: NONEQUAL
105679: PUSH
105680: LD_VAR 0 2
105684: PPUSH
105685: CALL_OW 311
105689: OR
105690: AND
105691: IFFALSE 105732
// begin ComCollect ( j , x , y ) ;
105693: LD_VAR 0 2
105697: PPUSH
105698: LD_VAR 0 6
105702: PPUSH
105703: LD_VAR 0 7
105707: PPUSH
105708: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105712: LD_VAR 0 2
105716: PPUSH
105717: LD_VAR 0 8
105721: PPUSH
105722: CALL_OW 172
// exit ;
105726: POP
105727: POP
105728: POP
105729: POP
105730: GO 105740
// end ;
105732: GO 105622
105734: POP
105735: POP
// end ; end ;
105736: GO 105111
105738: POP
105739: POP
// end ; end_of_file
105740: PPOPN 9
105742: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105743: LD_INT 0
105745: PPUSH
105746: PPUSH
105747: PPUSH
105748: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105749: LD_VAR 0 1
105753: PPUSH
105754: CALL_OW 264
105758: PUSH
105759: LD_INT 91
105761: EQUAL
105762: IFFALSE 105834
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105764: LD_INT 68
105766: PPUSH
105767: LD_VAR 0 1
105771: PPUSH
105772: CALL_OW 255
105776: PPUSH
105777: CALL_OW 321
105781: PUSH
105782: LD_INT 2
105784: EQUAL
105785: IFFALSE 105797
// eff := 70 else
105787: LD_ADDR_VAR 0 4
105791: PUSH
105792: LD_INT 70
105794: ST_TO_ADDR
105795: GO 105805
// eff := 30 ;
105797: LD_ADDR_VAR 0 4
105801: PUSH
105802: LD_INT 30
105804: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105805: LD_VAR 0 1
105809: PPUSH
105810: CALL_OW 250
105814: PPUSH
105815: LD_VAR 0 1
105819: PPUSH
105820: CALL_OW 251
105824: PPUSH
105825: LD_VAR 0 4
105829: PPUSH
105830: CALL_OW 495
// end ; end ;
105834: LD_VAR 0 2
105838: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105839: LD_INT 0
105841: PPUSH
// end ;
105842: LD_VAR 0 4
105846: RET
// export function SOS_Command ( cmd ) ; begin
105847: LD_INT 0
105849: PPUSH
// end ;
105850: LD_VAR 0 2
105854: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105855: LD_INT 0
105857: PPUSH
// end ;
105858: LD_VAR 0 6
105862: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105863: LD_INT 0
105865: PPUSH
105866: PPUSH
// if not vehicle or not factory then
105867: LD_VAR 0 1
105871: NOT
105872: PUSH
105873: LD_VAR 0 2
105877: NOT
105878: OR
105879: IFFALSE 105883
// exit ;
105881: GO 106114
// if factoryWaypoints >= factory then
105883: LD_EXP 165
105887: PUSH
105888: LD_VAR 0 2
105892: GREATEREQUAL
105893: IFFALSE 106114
// if factoryWaypoints [ factory ] then
105895: LD_EXP 165
105899: PUSH
105900: LD_VAR 0 2
105904: ARRAY
105905: IFFALSE 106114
// begin if GetControl ( vehicle ) = control_manual then
105907: LD_VAR 0 1
105911: PPUSH
105912: CALL_OW 263
105916: PUSH
105917: LD_INT 1
105919: EQUAL
105920: IFFALSE 106001
// begin driver := IsDrivenBy ( vehicle ) ;
105922: LD_ADDR_VAR 0 4
105926: PUSH
105927: LD_VAR 0 1
105931: PPUSH
105932: CALL_OW 311
105936: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105937: LD_VAR 0 4
105941: PPUSH
105942: LD_EXP 165
105946: PUSH
105947: LD_VAR 0 2
105951: ARRAY
105952: PUSH
105953: LD_INT 3
105955: ARRAY
105956: PPUSH
105957: LD_EXP 165
105961: PUSH
105962: LD_VAR 0 2
105966: ARRAY
105967: PUSH
105968: LD_INT 4
105970: ARRAY
105971: PPUSH
105972: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105976: LD_VAR 0 4
105980: PPUSH
105981: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105985: LD_VAR 0 4
105989: PPUSH
105990: LD_VAR 0 2
105994: PPUSH
105995: CALL_OW 180
// end else
105999: GO 106114
// if GetControl ( vehicle ) = control_remote then
106001: LD_VAR 0 1
106005: PPUSH
106006: CALL_OW 263
106010: PUSH
106011: LD_INT 2
106013: EQUAL
106014: IFFALSE 106075
// begin wait ( 0 0$2 ) ;
106016: LD_INT 70
106018: PPUSH
106019: CALL_OW 67
// if Connect ( vehicle ) then
106023: LD_VAR 0 1
106027: PPUSH
106028: CALL 24753 0 1
106032: IFFALSE 106073
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106034: LD_VAR 0 1
106038: PPUSH
106039: LD_EXP 165
106043: PUSH
106044: LD_VAR 0 2
106048: ARRAY
106049: PUSH
106050: LD_INT 3
106052: ARRAY
106053: PPUSH
106054: LD_EXP 165
106058: PUSH
106059: LD_VAR 0 2
106063: ARRAY
106064: PUSH
106065: LD_INT 4
106067: ARRAY
106068: PPUSH
106069: CALL_OW 171
// end else
106073: GO 106114
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106075: LD_VAR 0 1
106079: PPUSH
106080: LD_EXP 165
106084: PUSH
106085: LD_VAR 0 2
106089: ARRAY
106090: PUSH
106091: LD_INT 3
106093: ARRAY
106094: PPUSH
106095: LD_EXP 165
106099: PUSH
106100: LD_VAR 0 2
106104: ARRAY
106105: PUSH
106106: LD_INT 4
106108: ARRAY
106109: PPUSH
106110: CALL_OW 171
// end ; end ;
106114: LD_VAR 0 3
106118: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106119: LD_INT 0
106121: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106122: LD_VAR 0 1
106126: PUSH
106127: LD_INT 250
106129: EQUAL
106130: PUSH
106131: LD_VAR 0 2
106135: PPUSH
106136: CALL_OW 264
106140: PUSH
106141: LD_INT 81
106143: EQUAL
106144: AND
106145: IFFALSE 106166
// MinerPlaceMine ( unit , x , y ) ;
106147: LD_VAR 0 2
106151: PPUSH
106152: LD_VAR 0 4
106156: PPUSH
106157: LD_VAR 0 5
106161: PPUSH
106162: CALL 109156 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106166: LD_VAR 0 1
106170: PUSH
106171: LD_INT 251
106173: EQUAL
106174: PUSH
106175: LD_VAR 0 2
106179: PPUSH
106180: CALL_OW 264
106184: PUSH
106185: LD_INT 81
106187: EQUAL
106188: AND
106189: IFFALSE 106210
// MinerDetonateMine ( unit , x , y ) ;
106191: LD_VAR 0 2
106195: PPUSH
106196: LD_VAR 0 4
106200: PPUSH
106201: LD_VAR 0 5
106205: PPUSH
106206: CALL 109431 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106210: LD_VAR 0 1
106214: PUSH
106215: LD_INT 252
106217: EQUAL
106218: PUSH
106219: LD_VAR 0 2
106223: PPUSH
106224: CALL_OW 264
106228: PUSH
106229: LD_INT 81
106231: EQUAL
106232: AND
106233: IFFALSE 106254
// MinerCreateMinefield ( unit , x , y ) ;
106235: LD_VAR 0 2
106239: PPUSH
106240: LD_VAR 0 4
106244: PPUSH
106245: LD_VAR 0 5
106249: PPUSH
106250: CALL 109848 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106254: LD_VAR 0 1
106258: PUSH
106259: LD_INT 253
106261: EQUAL
106262: PUSH
106263: LD_VAR 0 2
106267: PPUSH
106268: CALL_OW 257
106272: PUSH
106273: LD_INT 5
106275: EQUAL
106276: AND
106277: IFFALSE 106298
// ComBinocular ( unit , x , y ) ;
106279: LD_VAR 0 2
106283: PPUSH
106284: LD_VAR 0 4
106288: PPUSH
106289: LD_VAR 0 5
106293: PPUSH
106294: CALL 110217 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106298: LD_VAR 0 1
106302: PUSH
106303: LD_INT 254
106305: EQUAL
106306: PUSH
106307: LD_VAR 0 2
106311: PPUSH
106312: CALL_OW 264
106316: PUSH
106317: LD_INT 99
106319: EQUAL
106320: AND
106321: PUSH
106322: LD_VAR 0 3
106326: PPUSH
106327: CALL_OW 263
106331: PUSH
106332: LD_INT 3
106334: EQUAL
106335: AND
106336: IFFALSE 106352
// HackDestroyVehicle ( unit , selectedUnit ) ;
106338: LD_VAR 0 2
106342: PPUSH
106343: LD_VAR 0 3
106347: PPUSH
106348: CALL 108520 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106352: LD_VAR 0 1
106356: PUSH
106357: LD_INT 255
106359: EQUAL
106360: PUSH
106361: LD_VAR 0 2
106365: PPUSH
106366: CALL_OW 264
106370: PUSH
106371: LD_INT 14
106373: PUSH
106374: LD_INT 53
106376: PUSH
106377: EMPTY
106378: LIST
106379: LIST
106380: IN
106381: AND
106382: PUSH
106383: LD_VAR 0 4
106387: PPUSH
106388: LD_VAR 0 5
106392: PPUSH
106393: CALL_OW 488
106397: AND
106398: IFFALSE 106422
// CutTreeXYR ( unit , x , y , 12 ) ;
106400: LD_VAR 0 2
106404: PPUSH
106405: LD_VAR 0 4
106409: PPUSH
106410: LD_VAR 0 5
106414: PPUSH
106415: LD_INT 12
106417: PPUSH
106418: CALL 106517 0 4
// if cmd = 256 then
106422: LD_VAR 0 1
106426: PUSH
106427: LD_INT 256
106429: EQUAL
106430: IFFALSE 106451
// SetFactoryWaypoint ( unit , x , y ) ;
106432: LD_VAR 0 2
106436: PPUSH
106437: LD_VAR 0 4
106441: PPUSH
106442: LD_VAR 0 5
106446: PPUSH
106447: CALL 104432 0 3
// if cmd = 257 then
106451: LD_VAR 0 1
106455: PUSH
106456: LD_INT 257
106458: EQUAL
106459: IFFALSE 106480
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106461: LD_VAR 0 2
106465: PPUSH
106466: LD_VAR 0 4
106470: PPUSH
106471: LD_VAR 0 5
106475: PPUSH
106476: CALL 104794 0 3
// if cmd = 258 then
106480: LD_VAR 0 1
106484: PUSH
106485: LD_INT 258
106487: EQUAL
106488: IFFALSE 106512
// BurnTreeXYR ( unit , x , y , 8 ) ;
106490: LD_VAR 0 2
106494: PPUSH
106495: LD_VAR 0 4
106499: PPUSH
106500: LD_VAR 0 5
106504: PPUSH
106505: LD_INT 8
106507: PPUSH
106508: CALL 106911 0 4
// end ;
106512: LD_VAR 0 6
106516: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106517: LD_INT 0
106519: PPUSH
106520: PPUSH
106521: PPUSH
106522: PPUSH
106523: PPUSH
106524: PPUSH
106525: PPUSH
106526: PPUSH
106527: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
106528: LD_VAR 0 1
106532: PPUSH
106533: CALL_OW 302
106537: NOT
106538: PUSH
106539: LD_VAR 0 2
106543: PPUSH
106544: LD_VAR 0 3
106548: PPUSH
106549: CALL_OW 488
106553: NOT
106554: OR
106555: PUSH
106556: LD_VAR 0 4
106560: NOT
106561: OR
106562: IFFALSE 106566
// exit ;
106564: GO 106906
// list := [ ] ;
106566: LD_ADDR_VAR 0 13
106570: PUSH
106571: EMPTY
106572: ST_TO_ADDR
// if x - r < 0 then
106573: LD_VAR 0 2
106577: PUSH
106578: LD_VAR 0 4
106582: MINUS
106583: PUSH
106584: LD_INT 0
106586: LESS
106587: IFFALSE 106599
// min_x := 0 else
106589: LD_ADDR_VAR 0 7
106593: PUSH
106594: LD_INT 0
106596: ST_TO_ADDR
106597: GO 106615
// min_x := x - r ;
106599: LD_ADDR_VAR 0 7
106603: PUSH
106604: LD_VAR 0 2
106608: PUSH
106609: LD_VAR 0 4
106613: MINUS
106614: ST_TO_ADDR
// if y - r < 0 then
106615: LD_VAR 0 3
106619: PUSH
106620: LD_VAR 0 4
106624: MINUS
106625: PUSH
106626: LD_INT 0
106628: LESS
106629: IFFALSE 106641
// min_y := 0 else
106631: LD_ADDR_VAR 0 8
106635: PUSH
106636: LD_INT 0
106638: ST_TO_ADDR
106639: GO 106657
// min_y := y - r ;
106641: LD_ADDR_VAR 0 8
106645: PUSH
106646: LD_VAR 0 3
106650: PUSH
106651: LD_VAR 0 4
106655: MINUS
106656: ST_TO_ADDR
// max_x := x + r ;
106657: LD_ADDR_VAR 0 9
106661: PUSH
106662: LD_VAR 0 2
106666: PUSH
106667: LD_VAR 0 4
106671: PLUS
106672: ST_TO_ADDR
// max_y := y + r ;
106673: LD_ADDR_VAR 0 10
106677: PUSH
106678: LD_VAR 0 3
106682: PUSH
106683: LD_VAR 0 4
106687: PLUS
106688: ST_TO_ADDR
// for _x = min_x to max_x do
106689: LD_ADDR_VAR 0 11
106693: PUSH
106694: DOUBLE
106695: LD_VAR 0 7
106699: DEC
106700: ST_TO_ADDR
106701: LD_VAR 0 9
106705: PUSH
106706: FOR_TO
106707: IFFALSE 106824
// for _y = min_y to max_y do
106709: LD_ADDR_VAR 0 12
106713: PUSH
106714: DOUBLE
106715: LD_VAR 0 8
106719: DEC
106720: ST_TO_ADDR
106721: LD_VAR 0 10
106725: PUSH
106726: FOR_TO
106727: IFFALSE 106820
// begin if not ValidHex ( _x , _y ) then
106729: LD_VAR 0 11
106733: PPUSH
106734: LD_VAR 0 12
106738: PPUSH
106739: CALL_OW 488
106743: NOT
106744: IFFALSE 106748
// continue ;
106746: GO 106726
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106748: LD_VAR 0 11
106752: PPUSH
106753: LD_VAR 0 12
106757: PPUSH
106758: CALL_OW 351
106762: PUSH
106763: LD_VAR 0 11
106767: PPUSH
106768: LD_VAR 0 12
106772: PPUSH
106773: CALL_OW 554
106777: AND
106778: IFFALSE 106818
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106780: LD_ADDR_VAR 0 13
106784: PUSH
106785: LD_VAR 0 13
106789: PPUSH
106790: LD_VAR 0 13
106794: PUSH
106795: LD_INT 1
106797: PLUS
106798: PPUSH
106799: LD_VAR 0 11
106803: PUSH
106804: LD_VAR 0 12
106808: PUSH
106809: EMPTY
106810: LIST
106811: LIST
106812: PPUSH
106813: CALL_OW 2
106817: ST_TO_ADDR
// end ;
106818: GO 106726
106820: POP
106821: POP
106822: GO 106706
106824: POP
106825: POP
// if not list then
106826: LD_VAR 0 13
106830: NOT
106831: IFFALSE 106835
// exit ;
106833: GO 106906
// for i in list do
106835: LD_ADDR_VAR 0 6
106839: PUSH
106840: LD_VAR 0 13
106844: PUSH
106845: FOR_IN
106846: IFFALSE 106904
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106848: LD_VAR 0 1
106852: PPUSH
106853: LD_STRING M
106855: PUSH
106856: LD_VAR 0 6
106860: PUSH
106861: LD_INT 1
106863: ARRAY
106864: PUSH
106865: LD_VAR 0 6
106869: PUSH
106870: LD_INT 2
106872: ARRAY
106873: PUSH
106874: LD_INT 0
106876: PUSH
106877: LD_INT 0
106879: PUSH
106880: LD_INT 0
106882: PUSH
106883: LD_INT 0
106885: PUSH
106886: EMPTY
106887: LIST
106888: LIST
106889: LIST
106890: LIST
106891: LIST
106892: LIST
106893: LIST
106894: PUSH
106895: EMPTY
106896: LIST
106897: PPUSH
106898: CALL_OW 447
106902: GO 106845
106904: POP
106905: POP
// end ;
106906: LD_VAR 0 5
106910: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
106911: LD_INT 0
106913: PPUSH
106914: PPUSH
106915: PPUSH
106916: PPUSH
106917: PPUSH
106918: PPUSH
106919: PPUSH
106920: PPUSH
106921: PPUSH
106922: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
106923: LD_VAR 0 1
106927: PPUSH
106928: CALL_OW 302
106932: NOT
106933: PUSH
106934: LD_VAR 0 2
106938: PPUSH
106939: LD_VAR 0 3
106943: PPUSH
106944: CALL_OW 488
106948: NOT
106949: OR
106950: PUSH
106951: LD_VAR 0 4
106955: NOT
106956: OR
106957: IFFALSE 106961
// exit ;
106959: GO 107474
// list := [ ] ;
106961: LD_ADDR_VAR 0 13
106965: PUSH
106966: EMPTY
106967: ST_TO_ADDR
// if x - r < 0 then
106968: LD_VAR 0 2
106972: PUSH
106973: LD_VAR 0 4
106977: MINUS
106978: PUSH
106979: LD_INT 0
106981: LESS
106982: IFFALSE 106994
// min_x := 0 else
106984: LD_ADDR_VAR 0 7
106988: PUSH
106989: LD_INT 0
106991: ST_TO_ADDR
106992: GO 107010
// min_x := x - r ;
106994: LD_ADDR_VAR 0 7
106998: PUSH
106999: LD_VAR 0 2
107003: PUSH
107004: LD_VAR 0 4
107008: MINUS
107009: ST_TO_ADDR
// if y - r < 0 then
107010: LD_VAR 0 3
107014: PUSH
107015: LD_VAR 0 4
107019: MINUS
107020: PUSH
107021: LD_INT 0
107023: LESS
107024: IFFALSE 107036
// min_y := 0 else
107026: LD_ADDR_VAR 0 8
107030: PUSH
107031: LD_INT 0
107033: ST_TO_ADDR
107034: GO 107052
// min_y := y - r ;
107036: LD_ADDR_VAR 0 8
107040: PUSH
107041: LD_VAR 0 3
107045: PUSH
107046: LD_VAR 0 4
107050: MINUS
107051: ST_TO_ADDR
// max_x := x + r ;
107052: LD_ADDR_VAR 0 9
107056: PUSH
107057: LD_VAR 0 2
107061: PUSH
107062: LD_VAR 0 4
107066: PLUS
107067: ST_TO_ADDR
// max_y := y + r ;
107068: LD_ADDR_VAR 0 10
107072: PUSH
107073: LD_VAR 0 3
107077: PUSH
107078: LD_VAR 0 4
107082: PLUS
107083: ST_TO_ADDR
// for _x = min_x to max_x do
107084: LD_ADDR_VAR 0 11
107088: PUSH
107089: DOUBLE
107090: LD_VAR 0 7
107094: DEC
107095: ST_TO_ADDR
107096: LD_VAR 0 9
107100: PUSH
107101: FOR_TO
107102: IFFALSE 107219
// for _y = min_y to max_y do
107104: LD_ADDR_VAR 0 12
107108: PUSH
107109: DOUBLE
107110: LD_VAR 0 8
107114: DEC
107115: ST_TO_ADDR
107116: LD_VAR 0 10
107120: PUSH
107121: FOR_TO
107122: IFFALSE 107215
// begin if not ValidHex ( _x , _y ) then
107124: LD_VAR 0 11
107128: PPUSH
107129: LD_VAR 0 12
107133: PPUSH
107134: CALL_OW 488
107138: NOT
107139: IFFALSE 107143
// continue ;
107141: GO 107121
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107143: LD_VAR 0 11
107147: PPUSH
107148: LD_VAR 0 12
107152: PPUSH
107153: CALL_OW 351
107157: PUSH
107158: LD_VAR 0 11
107162: PPUSH
107163: LD_VAR 0 12
107167: PPUSH
107168: CALL_OW 554
107172: AND
107173: IFFALSE 107213
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107175: LD_ADDR_VAR 0 13
107179: PUSH
107180: LD_VAR 0 13
107184: PPUSH
107185: LD_VAR 0 13
107189: PUSH
107190: LD_INT 1
107192: PLUS
107193: PPUSH
107194: LD_VAR 0 11
107198: PUSH
107199: LD_VAR 0 12
107203: PUSH
107204: EMPTY
107205: LIST
107206: LIST
107207: PPUSH
107208: CALL_OW 2
107212: ST_TO_ADDR
// end ;
107213: GO 107121
107215: POP
107216: POP
107217: GO 107101
107219: POP
107220: POP
// if not list then
107221: LD_VAR 0 13
107225: NOT
107226: IFFALSE 107230
// exit ;
107228: GO 107474
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
107230: LD_ADDR_VAR 0 13
107234: PUSH
107235: LD_VAR 0 1
107239: PPUSH
107240: LD_VAR 0 13
107244: PPUSH
107245: LD_INT 1
107247: PPUSH
107248: LD_INT 1
107250: PPUSH
107251: CALL 21895 0 4
107255: ST_TO_ADDR
// ComStop ( flame ) ;
107256: LD_VAR 0 1
107260: PPUSH
107261: CALL_OW 141
// for i in list do
107265: LD_ADDR_VAR 0 6
107269: PUSH
107270: LD_VAR 0 13
107274: PUSH
107275: FOR_IN
107276: IFFALSE 107307
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
107278: LD_VAR 0 1
107282: PPUSH
107283: LD_VAR 0 6
107287: PUSH
107288: LD_INT 1
107290: ARRAY
107291: PPUSH
107292: LD_VAR 0 6
107296: PUSH
107297: LD_INT 2
107299: ARRAY
107300: PPUSH
107301: CALL_OW 176
107305: GO 107275
107307: POP
107308: POP
// repeat wait ( 0 0$1 ) ;
107309: LD_INT 35
107311: PPUSH
107312: CALL_OW 67
// task := GetTaskList ( flame ) ;
107316: LD_ADDR_VAR 0 14
107320: PUSH
107321: LD_VAR 0 1
107325: PPUSH
107326: CALL_OW 437
107330: ST_TO_ADDR
// if not task then
107331: LD_VAR 0 14
107335: NOT
107336: IFFALSE 107340
// exit ;
107338: GO 107474
// if task [ 1 ] [ 1 ] <> | then
107340: LD_VAR 0 14
107344: PUSH
107345: LD_INT 1
107347: ARRAY
107348: PUSH
107349: LD_INT 1
107351: ARRAY
107352: PUSH
107353: LD_STRING |
107355: NONEQUAL
107356: IFFALSE 107360
// exit ;
107358: GO 107474
// _x := task [ 1 ] [ 2 ] ;
107360: LD_ADDR_VAR 0 11
107364: PUSH
107365: LD_VAR 0 14
107369: PUSH
107370: LD_INT 1
107372: ARRAY
107373: PUSH
107374: LD_INT 2
107376: ARRAY
107377: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
107378: LD_ADDR_VAR 0 12
107382: PUSH
107383: LD_VAR 0 14
107387: PUSH
107388: LD_INT 1
107390: ARRAY
107391: PUSH
107392: LD_INT 3
107394: ARRAY
107395: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
107396: LD_VAR 0 11
107400: PPUSH
107401: LD_VAR 0 12
107405: PPUSH
107406: CALL_OW 351
107410: NOT
107411: PUSH
107412: LD_VAR 0 11
107416: PPUSH
107417: LD_VAR 0 12
107421: PPUSH
107422: CALL_OW 554
107426: NOT
107427: OR
107428: IFFALSE 107462
// begin task := Delete ( task , 1 ) ;
107430: LD_ADDR_VAR 0 14
107434: PUSH
107435: LD_VAR 0 14
107439: PPUSH
107440: LD_INT 1
107442: PPUSH
107443: CALL_OW 3
107447: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
107448: LD_VAR 0 1
107452: PPUSH
107453: LD_VAR 0 14
107457: PPUSH
107458: CALL_OW 446
// end ; until not HasTask ( flame ) ;
107462: LD_VAR 0 1
107466: PPUSH
107467: CALL_OW 314
107471: NOT
107472: IFFALSE 107309
// end ;
107474: LD_VAR 0 5
107478: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107479: LD_EXP 168
107483: NOT
107484: IFFALSE 107534
107486: GO 107488
107488: DISABLE
// begin initHack := true ;
107489: LD_ADDR_EXP 168
107493: PUSH
107494: LD_INT 1
107496: ST_TO_ADDR
// hackTanks := [ ] ;
107497: LD_ADDR_EXP 169
107501: PUSH
107502: EMPTY
107503: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107504: LD_ADDR_EXP 170
107508: PUSH
107509: EMPTY
107510: ST_TO_ADDR
// hackLimit := 3 ;
107511: LD_ADDR_EXP 171
107515: PUSH
107516: LD_INT 3
107518: ST_TO_ADDR
// hackDist := 12 ;
107519: LD_ADDR_EXP 172
107523: PUSH
107524: LD_INT 12
107526: ST_TO_ADDR
// hackCounter := [ ] ;
107527: LD_ADDR_EXP 173
107531: PUSH
107532: EMPTY
107533: ST_TO_ADDR
// end ;
107534: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107535: LD_EXP 168
107539: PUSH
107540: LD_INT 34
107542: PUSH
107543: LD_INT 99
107545: PUSH
107546: EMPTY
107547: LIST
107548: LIST
107549: PPUSH
107550: CALL_OW 69
107554: AND
107555: IFFALSE 107808
107557: GO 107559
107559: DISABLE
107560: LD_INT 0
107562: PPUSH
107563: PPUSH
// begin enable ;
107564: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107565: LD_ADDR_VAR 0 1
107569: PUSH
107570: LD_INT 34
107572: PUSH
107573: LD_INT 99
107575: PUSH
107576: EMPTY
107577: LIST
107578: LIST
107579: PPUSH
107580: CALL_OW 69
107584: PUSH
107585: FOR_IN
107586: IFFALSE 107806
// begin if not i in hackTanks then
107588: LD_VAR 0 1
107592: PUSH
107593: LD_EXP 169
107597: IN
107598: NOT
107599: IFFALSE 107682
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107601: LD_ADDR_EXP 169
107605: PUSH
107606: LD_EXP 169
107610: PPUSH
107611: LD_EXP 169
107615: PUSH
107616: LD_INT 1
107618: PLUS
107619: PPUSH
107620: LD_VAR 0 1
107624: PPUSH
107625: CALL_OW 1
107629: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107630: LD_ADDR_EXP 170
107634: PUSH
107635: LD_EXP 170
107639: PPUSH
107640: LD_EXP 170
107644: PUSH
107645: LD_INT 1
107647: PLUS
107648: PPUSH
107649: EMPTY
107650: PPUSH
107651: CALL_OW 1
107655: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107656: LD_ADDR_EXP 173
107660: PUSH
107661: LD_EXP 173
107665: PPUSH
107666: LD_EXP 173
107670: PUSH
107671: LD_INT 1
107673: PLUS
107674: PPUSH
107675: EMPTY
107676: PPUSH
107677: CALL_OW 1
107681: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107682: LD_VAR 0 1
107686: PPUSH
107687: CALL_OW 302
107691: NOT
107692: IFFALSE 107705
// begin HackUnlinkAll ( i ) ;
107694: LD_VAR 0 1
107698: PPUSH
107699: CALL 107811 0 1
// continue ;
107703: GO 107585
// end ; HackCheckCapturedStatus ( i ) ;
107705: LD_VAR 0 1
107709: PPUSH
107710: CALL 108254 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107714: LD_ADDR_VAR 0 2
107718: PUSH
107719: LD_INT 81
107721: PUSH
107722: LD_VAR 0 1
107726: PPUSH
107727: CALL_OW 255
107731: PUSH
107732: EMPTY
107733: LIST
107734: LIST
107735: PUSH
107736: LD_INT 33
107738: PUSH
107739: LD_INT 3
107741: PUSH
107742: EMPTY
107743: LIST
107744: LIST
107745: PUSH
107746: LD_INT 91
107748: PUSH
107749: LD_VAR 0 1
107753: PUSH
107754: LD_EXP 172
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: LIST
107763: PUSH
107764: LD_INT 50
107766: PUSH
107767: EMPTY
107768: LIST
107769: PUSH
107770: EMPTY
107771: LIST
107772: LIST
107773: LIST
107774: LIST
107775: PPUSH
107776: CALL_OW 69
107780: ST_TO_ADDR
// if not tmp then
107781: LD_VAR 0 2
107785: NOT
107786: IFFALSE 107790
// continue ;
107788: GO 107585
// HackLink ( i , tmp ) ;
107790: LD_VAR 0 1
107794: PPUSH
107795: LD_VAR 0 2
107799: PPUSH
107800: CALL 107947 0 2
// end ;
107804: GO 107585
107806: POP
107807: POP
// end ;
107808: PPOPN 2
107810: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107811: LD_INT 0
107813: PPUSH
107814: PPUSH
107815: PPUSH
// if not hack in hackTanks then
107816: LD_VAR 0 1
107820: PUSH
107821: LD_EXP 169
107825: IN
107826: NOT
107827: IFFALSE 107831
// exit ;
107829: GO 107942
// index := GetElementIndex ( hackTanks , hack ) ;
107831: LD_ADDR_VAR 0 4
107835: PUSH
107836: LD_EXP 169
107840: PPUSH
107841: LD_VAR 0 1
107845: PPUSH
107846: CALL 21192 0 2
107850: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107851: LD_EXP 170
107855: PUSH
107856: LD_VAR 0 4
107860: ARRAY
107861: IFFALSE 107942
// begin for i in hackTanksCaptured [ index ] do
107863: LD_ADDR_VAR 0 3
107867: PUSH
107868: LD_EXP 170
107872: PUSH
107873: LD_VAR 0 4
107877: ARRAY
107878: PUSH
107879: FOR_IN
107880: IFFALSE 107906
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107882: LD_VAR 0 3
107886: PUSH
107887: LD_INT 1
107889: ARRAY
107890: PPUSH
107891: LD_VAR 0 3
107895: PUSH
107896: LD_INT 2
107898: ARRAY
107899: PPUSH
107900: CALL_OW 235
107904: GO 107879
107906: POP
107907: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107908: LD_ADDR_EXP 170
107912: PUSH
107913: LD_EXP 170
107917: PPUSH
107918: LD_VAR 0 4
107922: PPUSH
107923: EMPTY
107924: PPUSH
107925: CALL_OW 1
107929: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107930: LD_VAR 0 1
107934: PPUSH
107935: LD_INT 0
107937: PPUSH
107938: CALL_OW 505
// end ; end ;
107942: LD_VAR 0 2
107946: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107947: LD_INT 0
107949: PPUSH
107950: PPUSH
107951: PPUSH
// if not hack in hackTanks or not vehicles then
107952: LD_VAR 0 1
107956: PUSH
107957: LD_EXP 169
107961: IN
107962: NOT
107963: PUSH
107964: LD_VAR 0 2
107968: NOT
107969: OR
107970: IFFALSE 107974
// exit ;
107972: GO 108249
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107974: LD_ADDR_VAR 0 2
107978: PUSH
107979: LD_VAR 0 1
107983: PPUSH
107984: LD_VAR 0 2
107988: PPUSH
107989: LD_INT 1
107991: PPUSH
107992: LD_INT 1
107994: PPUSH
107995: CALL 21842 0 4
107999: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108000: LD_ADDR_VAR 0 5
108004: PUSH
108005: LD_EXP 169
108009: PPUSH
108010: LD_VAR 0 1
108014: PPUSH
108015: CALL 21192 0 2
108019: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108020: LD_EXP 170
108024: PUSH
108025: LD_VAR 0 5
108029: ARRAY
108030: PUSH
108031: LD_EXP 171
108035: LESS
108036: IFFALSE 108225
// begin for i := 1 to vehicles do
108038: LD_ADDR_VAR 0 4
108042: PUSH
108043: DOUBLE
108044: LD_INT 1
108046: DEC
108047: ST_TO_ADDR
108048: LD_VAR 0 2
108052: PUSH
108053: FOR_TO
108054: IFFALSE 108223
// begin if hackTanksCaptured [ index ] = hackLimit then
108056: LD_EXP 170
108060: PUSH
108061: LD_VAR 0 5
108065: ARRAY
108066: PUSH
108067: LD_EXP 171
108071: EQUAL
108072: IFFALSE 108076
// break ;
108074: GO 108223
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108076: LD_ADDR_EXP 173
108080: PUSH
108081: LD_EXP 173
108085: PPUSH
108086: LD_VAR 0 5
108090: PPUSH
108091: LD_EXP 173
108095: PUSH
108096: LD_VAR 0 5
108100: ARRAY
108101: PUSH
108102: LD_INT 1
108104: PLUS
108105: PPUSH
108106: CALL_OW 1
108110: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108111: LD_ADDR_EXP 170
108115: PUSH
108116: LD_EXP 170
108120: PPUSH
108121: LD_VAR 0 5
108125: PUSH
108126: LD_EXP 170
108130: PUSH
108131: LD_VAR 0 5
108135: ARRAY
108136: PUSH
108137: LD_INT 1
108139: PLUS
108140: PUSH
108141: EMPTY
108142: LIST
108143: LIST
108144: PPUSH
108145: LD_VAR 0 2
108149: PUSH
108150: LD_VAR 0 4
108154: ARRAY
108155: PUSH
108156: LD_VAR 0 2
108160: PUSH
108161: LD_VAR 0 4
108165: ARRAY
108166: PPUSH
108167: CALL_OW 255
108171: PUSH
108172: EMPTY
108173: LIST
108174: LIST
108175: PPUSH
108176: CALL 21407 0 3
108180: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108181: LD_VAR 0 2
108185: PUSH
108186: LD_VAR 0 4
108190: ARRAY
108191: PPUSH
108192: LD_VAR 0 1
108196: PPUSH
108197: CALL_OW 255
108201: PPUSH
108202: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108206: LD_VAR 0 2
108210: PUSH
108211: LD_VAR 0 4
108215: ARRAY
108216: PPUSH
108217: CALL_OW 141
// end ;
108221: GO 108053
108223: POP
108224: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108225: LD_VAR 0 1
108229: PPUSH
108230: LD_EXP 170
108234: PUSH
108235: LD_VAR 0 5
108239: ARRAY
108240: PUSH
108241: LD_INT 0
108243: PLUS
108244: PPUSH
108245: CALL_OW 505
// end ;
108249: LD_VAR 0 3
108253: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108254: LD_INT 0
108256: PPUSH
108257: PPUSH
108258: PPUSH
108259: PPUSH
// if not hack in hackTanks then
108260: LD_VAR 0 1
108264: PUSH
108265: LD_EXP 169
108269: IN
108270: NOT
108271: IFFALSE 108275
// exit ;
108273: GO 108515
// index := GetElementIndex ( hackTanks , hack ) ;
108275: LD_ADDR_VAR 0 4
108279: PUSH
108280: LD_EXP 169
108284: PPUSH
108285: LD_VAR 0 1
108289: PPUSH
108290: CALL 21192 0 2
108294: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108295: LD_ADDR_VAR 0 3
108299: PUSH
108300: DOUBLE
108301: LD_EXP 170
108305: PUSH
108306: LD_VAR 0 4
108310: ARRAY
108311: INC
108312: ST_TO_ADDR
108313: LD_INT 1
108315: PUSH
108316: FOR_DOWNTO
108317: IFFALSE 108489
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108319: LD_ADDR_VAR 0 5
108323: PUSH
108324: LD_EXP 170
108328: PUSH
108329: LD_VAR 0 4
108333: ARRAY
108334: PUSH
108335: LD_VAR 0 3
108339: ARRAY
108340: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108341: LD_VAR 0 5
108345: PUSH
108346: LD_INT 1
108348: ARRAY
108349: PPUSH
108350: CALL_OW 302
108354: NOT
108355: PUSH
108356: LD_VAR 0 5
108360: PUSH
108361: LD_INT 1
108363: ARRAY
108364: PPUSH
108365: CALL_OW 255
108369: PUSH
108370: LD_VAR 0 1
108374: PPUSH
108375: CALL_OW 255
108379: NONEQUAL
108380: OR
108381: IFFALSE 108487
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108383: LD_VAR 0 5
108387: PUSH
108388: LD_INT 1
108390: ARRAY
108391: PPUSH
108392: CALL_OW 305
108396: PUSH
108397: LD_VAR 0 5
108401: PUSH
108402: LD_INT 1
108404: ARRAY
108405: PPUSH
108406: CALL_OW 255
108410: PUSH
108411: LD_VAR 0 1
108415: PPUSH
108416: CALL_OW 255
108420: EQUAL
108421: AND
108422: IFFALSE 108446
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108424: LD_VAR 0 5
108428: PUSH
108429: LD_INT 1
108431: ARRAY
108432: PPUSH
108433: LD_VAR 0 5
108437: PUSH
108438: LD_INT 2
108440: ARRAY
108441: PPUSH
108442: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108446: LD_ADDR_EXP 170
108450: PUSH
108451: LD_EXP 170
108455: PPUSH
108456: LD_VAR 0 4
108460: PPUSH
108461: LD_EXP 170
108465: PUSH
108466: LD_VAR 0 4
108470: ARRAY
108471: PPUSH
108472: LD_VAR 0 3
108476: PPUSH
108477: CALL_OW 3
108481: PPUSH
108482: CALL_OW 1
108486: ST_TO_ADDR
// end ; end ;
108487: GO 108316
108489: POP
108490: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108491: LD_VAR 0 1
108495: PPUSH
108496: LD_EXP 170
108500: PUSH
108501: LD_VAR 0 4
108505: ARRAY
108506: PUSH
108507: LD_INT 0
108509: PLUS
108510: PPUSH
108511: CALL_OW 505
// end ;
108515: LD_VAR 0 2
108519: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108520: LD_INT 0
108522: PPUSH
108523: PPUSH
108524: PPUSH
108525: PPUSH
// if not hack in hackTanks then
108526: LD_VAR 0 1
108530: PUSH
108531: LD_EXP 169
108535: IN
108536: NOT
108537: IFFALSE 108541
// exit ;
108539: GO 108626
// index := GetElementIndex ( hackTanks , hack ) ;
108541: LD_ADDR_VAR 0 5
108545: PUSH
108546: LD_EXP 169
108550: PPUSH
108551: LD_VAR 0 1
108555: PPUSH
108556: CALL 21192 0 2
108560: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108561: LD_ADDR_VAR 0 4
108565: PUSH
108566: DOUBLE
108567: LD_INT 1
108569: DEC
108570: ST_TO_ADDR
108571: LD_EXP 170
108575: PUSH
108576: LD_VAR 0 5
108580: ARRAY
108581: PUSH
108582: FOR_TO
108583: IFFALSE 108624
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108585: LD_EXP 170
108589: PUSH
108590: LD_VAR 0 5
108594: ARRAY
108595: PUSH
108596: LD_VAR 0 4
108600: ARRAY
108601: PUSH
108602: LD_INT 1
108604: ARRAY
108605: PUSH
108606: LD_VAR 0 2
108610: EQUAL
108611: IFFALSE 108622
// KillUnit ( vehicle ) ;
108613: LD_VAR 0 2
108617: PPUSH
108618: CALL_OW 66
108622: GO 108582
108624: POP
108625: POP
// end ;
108626: LD_VAR 0 3
108630: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108631: LD_EXP 174
108635: NOT
108636: IFFALSE 108671
108638: GO 108640
108640: DISABLE
// begin initMiner := true ;
108641: LD_ADDR_EXP 174
108645: PUSH
108646: LD_INT 1
108648: ST_TO_ADDR
// minersList := [ ] ;
108649: LD_ADDR_EXP 175
108653: PUSH
108654: EMPTY
108655: ST_TO_ADDR
// minerMinesList := [ ] ;
108656: LD_ADDR_EXP 176
108660: PUSH
108661: EMPTY
108662: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108663: LD_ADDR_EXP 177
108667: PUSH
108668: LD_INT 5
108670: ST_TO_ADDR
// end ;
108671: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108672: LD_EXP 174
108676: PUSH
108677: LD_INT 34
108679: PUSH
108680: LD_INT 81
108682: PUSH
108683: EMPTY
108684: LIST
108685: LIST
108686: PPUSH
108687: CALL_OW 69
108691: AND
108692: IFFALSE 109153
108694: GO 108696
108696: DISABLE
108697: LD_INT 0
108699: PPUSH
108700: PPUSH
108701: PPUSH
108702: PPUSH
// begin enable ;
108703: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108704: LD_ADDR_VAR 0 1
108708: PUSH
108709: LD_INT 34
108711: PUSH
108712: LD_INT 81
108714: PUSH
108715: EMPTY
108716: LIST
108717: LIST
108718: PPUSH
108719: CALL_OW 69
108723: PUSH
108724: FOR_IN
108725: IFFALSE 108797
// begin if not i in minersList then
108727: LD_VAR 0 1
108731: PUSH
108732: LD_EXP 175
108736: IN
108737: NOT
108738: IFFALSE 108795
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108740: LD_ADDR_EXP 175
108744: PUSH
108745: LD_EXP 175
108749: PPUSH
108750: LD_EXP 175
108754: PUSH
108755: LD_INT 1
108757: PLUS
108758: PPUSH
108759: LD_VAR 0 1
108763: PPUSH
108764: CALL_OW 1
108768: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108769: LD_ADDR_EXP 176
108773: PUSH
108774: LD_EXP 176
108778: PPUSH
108779: LD_EXP 176
108783: PUSH
108784: LD_INT 1
108786: PLUS
108787: PPUSH
108788: EMPTY
108789: PPUSH
108790: CALL_OW 1
108794: ST_TO_ADDR
// end end ;
108795: GO 108724
108797: POP
108798: POP
// for i := minerMinesList downto 1 do
108799: LD_ADDR_VAR 0 1
108803: PUSH
108804: DOUBLE
108805: LD_EXP 176
108809: INC
108810: ST_TO_ADDR
108811: LD_INT 1
108813: PUSH
108814: FOR_DOWNTO
108815: IFFALSE 109151
// begin if IsLive ( minersList [ i ] ) then
108817: LD_EXP 175
108821: PUSH
108822: LD_VAR 0 1
108826: ARRAY
108827: PPUSH
108828: CALL_OW 300
108832: IFFALSE 108860
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108834: LD_EXP 175
108838: PUSH
108839: LD_VAR 0 1
108843: ARRAY
108844: PPUSH
108845: LD_EXP 176
108849: PUSH
108850: LD_VAR 0 1
108854: ARRAY
108855: PPUSH
108856: CALL_OW 505
// if not minerMinesList [ i ] then
108860: LD_EXP 176
108864: PUSH
108865: LD_VAR 0 1
108869: ARRAY
108870: NOT
108871: IFFALSE 108875
// continue ;
108873: GO 108814
// for j := minerMinesList [ i ] downto 1 do
108875: LD_ADDR_VAR 0 2
108879: PUSH
108880: DOUBLE
108881: LD_EXP 176
108885: PUSH
108886: LD_VAR 0 1
108890: ARRAY
108891: INC
108892: ST_TO_ADDR
108893: LD_INT 1
108895: PUSH
108896: FOR_DOWNTO
108897: IFFALSE 109147
// begin side := GetSide ( minersList [ i ] ) ;
108899: LD_ADDR_VAR 0 3
108903: PUSH
108904: LD_EXP 175
108908: PUSH
108909: LD_VAR 0 1
108913: ARRAY
108914: PPUSH
108915: CALL_OW 255
108919: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108920: LD_ADDR_VAR 0 4
108924: PUSH
108925: LD_EXP 176
108929: PUSH
108930: LD_VAR 0 1
108934: ARRAY
108935: PUSH
108936: LD_VAR 0 2
108940: ARRAY
108941: PUSH
108942: LD_INT 1
108944: ARRAY
108945: PPUSH
108946: LD_EXP 176
108950: PUSH
108951: LD_VAR 0 1
108955: ARRAY
108956: PUSH
108957: LD_VAR 0 2
108961: ARRAY
108962: PUSH
108963: LD_INT 2
108965: ARRAY
108966: PPUSH
108967: CALL_OW 428
108971: ST_TO_ADDR
// if not tmp then
108972: LD_VAR 0 4
108976: NOT
108977: IFFALSE 108981
// continue ;
108979: GO 108896
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108981: LD_VAR 0 4
108985: PUSH
108986: LD_INT 81
108988: PUSH
108989: LD_VAR 0 3
108993: PUSH
108994: EMPTY
108995: LIST
108996: LIST
108997: PPUSH
108998: CALL_OW 69
109002: IN
109003: PUSH
109004: LD_EXP 176
109008: PUSH
109009: LD_VAR 0 1
109013: ARRAY
109014: PUSH
109015: LD_VAR 0 2
109019: ARRAY
109020: PUSH
109021: LD_INT 1
109023: ARRAY
109024: PPUSH
109025: LD_EXP 176
109029: PUSH
109030: LD_VAR 0 1
109034: ARRAY
109035: PUSH
109036: LD_VAR 0 2
109040: ARRAY
109041: PUSH
109042: LD_INT 2
109044: ARRAY
109045: PPUSH
109046: CALL_OW 458
109050: AND
109051: IFFALSE 109145
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109053: LD_EXP 176
109057: PUSH
109058: LD_VAR 0 1
109062: ARRAY
109063: PUSH
109064: LD_VAR 0 2
109068: ARRAY
109069: PUSH
109070: LD_INT 1
109072: ARRAY
109073: PPUSH
109074: LD_EXP 176
109078: PUSH
109079: LD_VAR 0 1
109083: ARRAY
109084: PUSH
109085: LD_VAR 0 2
109089: ARRAY
109090: PUSH
109091: LD_INT 2
109093: ARRAY
109094: PPUSH
109095: LD_VAR 0 3
109099: PPUSH
109100: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109104: LD_ADDR_EXP 176
109108: PUSH
109109: LD_EXP 176
109113: PPUSH
109114: LD_VAR 0 1
109118: PPUSH
109119: LD_EXP 176
109123: PUSH
109124: LD_VAR 0 1
109128: ARRAY
109129: PPUSH
109130: LD_VAR 0 2
109134: PPUSH
109135: CALL_OW 3
109139: PPUSH
109140: CALL_OW 1
109144: ST_TO_ADDR
// end ; end ;
109145: GO 108896
109147: POP
109148: POP
// end ;
109149: GO 108814
109151: POP
109152: POP
// end ;
109153: PPOPN 4
109155: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109156: LD_INT 0
109158: PPUSH
109159: PPUSH
// result := false ;
109160: LD_ADDR_VAR 0 4
109164: PUSH
109165: LD_INT 0
109167: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109168: LD_VAR 0 1
109172: PPUSH
109173: CALL_OW 264
109177: PUSH
109178: LD_INT 81
109180: EQUAL
109181: NOT
109182: IFFALSE 109186
// exit ;
109184: GO 109426
// index := GetElementIndex ( minersList , unit ) ;
109186: LD_ADDR_VAR 0 5
109190: PUSH
109191: LD_EXP 175
109195: PPUSH
109196: LD_VAR 0 1
109200: PPUSH
109201: CALL 21192 0 2
109205: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109206: LD_EXP 176
109210: PUSH
109211: LD_VAR 0 5
109215: ARRAY
109216: PUSH
109217: LD_EXP 177
109221: GREATEREQUAL
109222: IFFALSE 109226
// exit ;
109224: GO 109426
// ComMoveXY ( unit , x , y ) ;
109226: LD_VAR 0 1
109230: PPUSH
109231: LD_VAR 0 2
109235: PPUSH
109236: LD_VAR 0 3
109240: PPUSH
109241: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109245: LD_INT 35
109247: PPUSH
109248: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109252: LD_VAR 0 1
109256: PPUSH
109257: LD_VAR 0 2
109261: PPUSH
109262: LD_VAR 0 3
109266: PPUSH
109267: CALL 52933 0 3
109271: NOT
109272: PUSH
109273: LD_VAR 0 1
109277: PPUSH
109278: CALL_OW 314
109282: AND
109283: IFFALSE 109287
// exit ;
109285: GO 109426
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109287: LD_VAR 0 2
109291: PPUSH
109292: LD_VAR 0 3
109296: PPUSH
109297: CALL_OW 428
109301: PUSH
109302: LD_VAR 0 1
109306: EQUAL
109307: PUSH
109308: LD_VAR 0 1
109312: PPUSH
109313: CALL_OW 314
109317: NOT
109318: AND
109319: IFFALSE 109245
// PlaySoundXY ( x , y , PlantMine ) ;
109321: LD_VAR 0 2
109325: PPUSH
109326: LD_VAR 0 3
109330: PPUSH
109331: LD_STRING PlantMine
109333: PPUSH
109334: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109338: LD_VAR 0 2
109342: PPUSH
109343: LD_VAR 0 3
109347: PPUSH
109348: LD_VAR 0 1
109352: PPUSH
109353: CALL_OW 255
109357: PPUSH
109358: LD_INT 0
109360: PPUSH
109361: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109365: LD_ADDR_EXP 176
109369: PUSH
109370: LD_EXP 176
109374: PPUSH
109375: LD_VAR 0 5
109379: PUSH
109380: LD_EXP 176
109384: PUSH
109385: LD_VAR 0 5
109389: ARRAY
109390: PUSH
109391: LD_INT 1
109393: PLUS
109394: PUSH
109395: EMPTY
109396: LIST
109397: LIST
109398: PPUSH
109399: LD_VAR 0 2
109403: PUSH
109404: LD_VAR 0 3
109408: PUSH
109409: EMPTY
109410: LIST
109411: LIST
109412: PPUSH
109413: CALL 21407 0 3
109417: ST_TO_ADDR
// result := true ;
109418: LD_ADDR_VAR 0 4
109422: PUSH
109423: LD_INT 1
109425: ST_TO_ADDR
// end ;
109426: LD_VAR 0 4
109430: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109431: LD_INT 0
109433: PPUSH
109434: PPUSH
109435: PPUSH
// if not unit in minersList then
109436: LD_VAR 0 1
109440: PUSH
109441: LD_EXP 175
109445: IN
109446: NOT
109447: IFFALSE 109451
// exit ;
109449: GO 109843
// index := GetElementIndex ( minersList , unit ) ;
109451: LD_ADDR_VAR 0 6
109455: PUSH
109456: LD_EXP 175
109460: PPUSH
109461: LD_VAR 0 1
109465: PPUSH
109466: CALL 21192 0 2
109470: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109471: LD_ADDR_VAR 0 5
109475: PUSH
109476: DOUBLE
109477: LD_EXP 176
109481: PUSH
109482: LD_VAR 0 6
109486: ARRAY
109487: INC
109488: ST_TO_ADDR
109489: LD_INT 1
109491: PUSH
109492: FOR_DOWNTO
109493: IFFALSE 109654
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109495: LD_EXP 176
109499: PUSH
109500: LD_VAR 0 6
109504: ARRAY
109505: PUSH
109506: LD_VAR 0 5
109510: ARRAY
109511: PUSH
109512: LD_INT 1
109514: ARRAY
109515: PUSH
109516: LD_VAR 0 2
109520: EQUAL
109521: PUSH
109522: LD_EXP 176
109526: PUSH
109527: LD_VAR 0 6
109531: ARRAY
109532: PUSH
109533: LD_VAR 0 5
109537: ARRAY
109538: PUSH
109539: LD_INT 2
109541: ARRAY
109542: PUSH
109543: LD_VAR 0 3
109547: EQUAL
109548: AND
109549: IFFALSE 109652
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109551: LD_EXP 176
109555: PUSH
109556: LD_VAR 0 6
109560: ARRAY
109561: PUSH
109562: LD_VAR 0 5
109566: ARRAY
109567: PUSH
109568: LD_INT 1
109570: ARRAY
109571: PPUSH
109572: LD_EXP 176
109576: PUSH
109577: LD_VAR 0 6
109581: ARRAY
109582: PUSH
109583: LD_VAR 0 5
109587: ARRAY
109588: PUSH
109589: LD_INT 2
109591: ARRAY
109592: PPUSH
109593: LD_VAR 0 1
109597: PPUSH
109598: CALL_OW 255
109602: PPUSH
109603: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109607: LD_ADDR_EXP 176
109611: PUSH
109612: LD_EXP 176
109616: PPUSH
109617: LD_VAR 0 6
109621: PPUSH
109622: LD_EXP 176
109626: PUSH
109627: LD_VAR 0 6
109631: ARRAY
109632: PPUSH
109633: LD_VAR 0 5
109637: PPUSH
109638: CALL_OW 3
109642: PPUSH
109643: CALL_OW 1
109647: ST_TO_ADDR
// exit ;
109648: POP
109649: POP
109650: GO 109843
// end ; end ;
109652: GO 109492
109654: POP
109655: POP
// for i := minerMinesList [ index ] downto 1 do
109656: LD_ADDR_VAR 0 5
109660: PUSH
109661: DOUBLE
109662: LD_EXP 176
109666: PUSH
109667: LD_VAR 0 6
109671: ARRAY
109672: INC
109673: ST_TO_ADDR
109674: LD_INT 1
109676: PUSH
109677: FOR_DOWNTO
109678: IFFALSE 109841
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109680: LD_EXP 176
109684: PUSH
109685: LD_VAR 0 6
109689: ARRAY
109690: PUSH
109691: LD_VAR 0 5
109695: ARRAY
109696: PUSH
109697: LD_INT 1
109699: ARRAY
109700: PPUSH
109701: LD_EXP 176
109705: PUSH
109706: LD_VAR 0 6
109710: ARRAY
109711: PUSH
109712: LD_VAR 0 5
109716: ARRAY
109717: PUSH
109718: LD_INT 2
109720: ARRAY
109721: PPUSH
109722: LD_VAR 0 2
109726: PPUSH
109727: LD_VAR 0 3
109731: PPUSH
109732: CALL_OW 298
109736: PUSH
109737: LD_INT 6
109739: LESS
109740: IFFALSE 109839
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109742: LD_EXP 176
109746: PUSH
109747: LD_VAR 0 6
109751: ARRAY
109752: PUSH
109753: LD_VAR 0 5
109757: ARRAY
109758: PUSH
109759: LD_INT 1
109761: ARRAY
109762: PPUSH
109763: LD_EXP 176
109767: PUSH
109768: LD_VAR 0 6
109772: ARRAY
109773: PUSH
109774: LD_VAR 0 5
109778: ARRAY
109779: PUSH
109780: LD_INT 2
109782: ARRAY
109783: PPUSH
109784: LD_VAR 0 1
109788: PPUSH
109789: CALL_OW 255
109793: PPUSH
109794: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109798: LD_ADDR_EXP 176
109802: PUSH
109803: LD_EXP 176
109807: PPUSH
109808: LD_VAR 0 6
109812: PPUSH
109813: LD_EXP 176
109817: PUSH
109818: LD_VAR 0 6
109822: ARRAY
109823: PPUSH
109824: LD_VAR 0 5
109828: PPUSH
109829: CALL_OW 3
109833: PPUSH
109834: CALL_OW 1
109838: ST_TO_ADDR
// end ; end ;
109839: GO 109677
109841: POP
109842: POP
// end ;
109843: LD_VAR 0 4
109847: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109848: LD_INT 0
109850: PPUSH
109851: PPUSH
109852: PPUSH
109853: PPUSH
109854: PPUSH
109855: PPUSH
109856: PPUSH
109857: PPUSH
109858: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109859: LD_VAR 0 1
109863: PPUSH
109864: CALL_OW 264
109868: PUSH
109869: LD_INT 81
109871: EQUAL
109872: NOT
109873: PUSH
109874: LD_VAR 0 1
109878: PUSH
109879: LD_EXP 175
109883: IN
109884: NOT
109885: OR
109886: IFFALSE 109890
// exit ;
109888: GO 110212
// index := GetElementIndex ( minersList , unit ) ;
109890: LD_ADDR_VAR 0 6
109894: PUSH
109895: LD_EXP 175
109899: PPUSH
109900: LD_VAR 0 1
109904: PPUSH
109905: CALL 21192 0 2
109909: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109910: LD_ADDR_VAR 0 8
109914: PUSH
109915: LD_EXP 177
109919: PUSH
109920: LD_EXP 176
109924: PUSH
109925: LD_VAR 0 6
109929: ARRAY
109930: MINUS
109931: ST_TO_ADDR
// if not minesFreeAmount then
109932: LD_VAR 0 8
109936: NOT
109937: IFFALSE 109941
// exit ;
109939: GO 110212
// tmp := [ ] ;
109941: LD_ADDR_VAR 0 7
109945: PUSH
109946: EMPTY
109947: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109948: LD_ADDR_VAR 0 5
109952: PUSH
109953: DOUBLE
109954: LD_INT 1
109956: DEC
109957: ST_TO_ADDR
109958: LD_VAR 0 8
109962: PUSH
109963: FOR_TO
109964: IFFALSE 110159
// begin _d := rand ( 0 , 5 ) ;
109966: LD_ADDR_VAR 0 11
109970: PUSH
109971: LD_INT 0
109973: PPUSH
109974: LD_INT 5
109976: PPUSH
109977: CALL_OW 12
109981: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109982: LD_ADDR_VAR 0 12
109986: PUSH
109987: LD_INT 2
109989: PPUSH
109990: LD_INT 6
109992: PPUSH
109993: CALL_OW 12
109997: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109998: LD_ADDR_VAR 0 9
110002: PUSH
110003: LD_VAR 0 2
110007: PPUSH
110008: LD_VAR 0 11
110012: PPUSH
110013: LD_VAR 0 12
110017: PPUSH
110018: CALL_OW 272
110022: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110023: LD_ADDR_VAR 0 10
110027: PUSH
110028: LD_VAR 0 3
110032: PPUSH
110033: LD_VAR 0 11
110037: PPUSH
110038: LD_VAR 0 12
110042: PPUSH
110043: CALL_OW 273
110047: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110048: LD_VAR 0 9
110052: PPUSH
110053: LD_VAR 0 10
110057: PPUSH
110058: CALL_OW 488
110062: PUSH
110063: LD_VAR 0 9
110067: PUSH
110068: LD_VAR 0 10
110072: PUSH
110073: EMPTY
110074: LIST
110075: LIST
110076: PUSH
110077: LD_VAR 0 7
110081: IN
110082: NOT
110083: AND
110084: PUSH
110085: LD_VAR 0 9
110089: PPUSH
110090: LD_VAR 0 10
110094: PPUSH
110095: CALL_OW 458
110099: NOT
110100: AND
110101: IFFALSE 110143
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110103: LD_ADDR_VAR 0 7
110107: PUSH
110108: LD_VAR 0 7
110112: PPUSH
110113: LD_VAR 0 7
110117: PUSH
110118: LD_INT 1
110120: PLUS
110121: PPUSH
110122: LD_VAR 0 9
110126: PUSH
110127: LD_VAR 0 10
110131: PUSH
110132: EMPTY
110133: LIST
110134: LIST
110135: PPUSH
110136: CALL_OW 1
110140: ST_TO_ADDR
110141: GO 110157
// i := i - 1 ;
110143: LD_ADDR_VAR 0 5
110147: PUSH
110148: LD_VAR 0 5
110152: PUSH
110153: LD_INT 1
110155: MINUS
110156: ST_TO_ADDR
// end ;
110157: GO 109963
110159: POP
110160: POP
// for i in tmp do
110161: LD_ADDR_VAR 0 5
110165: PUSH
110166: LD_VAR 0 7
110170: PUSH
110171: FOR_IN
110172: IFFALSE 110210
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110174: LD_VAR 0 1
110178: PPUSH
110179: LD_VAR 0 5
110183: PUSH
110184: LD_INT 1
110186: ARRAY
110187: PPUSH
110188: LD_VAR 0 5
110192: PUSH
110193: LD_INT 2
110195: ARRAY
110196: PPUSH
110197: CALL 109156 0 3
110201: NOT
110202: IFFALSE 110208
// exit ;
110204: POP
110205: POP
110206: GO 110212
110208: GO 110171
110210: POP
110211: POP
// end ;
110212: LD_VAR 0 4
110216: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110217: LD_INT 0
110219: PPUSH
110220: PPUSH
110221: PPUSH
110222: PPUSH
110223: PPUSH
110224: PPUSH
110225: PPUSH
// if not GetClass ( unit ) = class_sniper then
110226: LD_VAR 0 1
110230: PPUSH
110231: CALL_OW 257
110235: PUSH
110236: LD_INT 5
110238: EQUAL
110239: NOT
110240: IFFALSE 110244
// exit ;
110242: GO 110632
// dist := 8 ;
110244: LD_ADDR_VAR 0 5
110248: PUSH
110249: LD_INT 8
110251: ST_TO_ADDR
// viewRange := 12 ;
110252: LD_ADDR_VAR 0 7
110256: PUSH
110257: LD_INT 12
110259: ST_TO_ADDR
// side := GetSide ( unit ) ;
110260: LD_ADDR_VAR 0 6
110264: PUSH
110265: LD_VAR 0 1
110269: PPUSH
110270: CALL_OW 255
110274: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110275: LD_INT 61
110277: PPUSH
110278: LD_VAR 0 6
110282: PPUSH
110283: CALL_OW 321
110287: PUSH
110288: LD_INT 2
110290: EQUAL
110291: IFFALSE 110301
// viewRange := 16 ;
110293: LD_ADDR_VAR 0 7
110297: PUSH
110298: LD_INT 16
110300: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110301: LD_VAR 0 1
110305: PPUSH
110306: LD_VAR 0 2
110310: PPUSH
110311: LD_VAR 0 3
110315: PPUSH
110316: CALL_OW 297
110320: PUSH
110321: LD_VAR 0 5
110325: GREATER
110326: IFFALSE 110405
// begin ComMoveXY ( unit , x , y ) ;
110328: LD_VAR 0 1
110332: PPUSH
110333: LD_VAR 0 2
110337: PPUSH
110338: LD_VAR 0 3
110342: PPUSH
110343: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110347: LD_INT 35
110349: PPUSH
110350: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110354: LD_VAR 0 1
110358: PPUSH
110359: LD_VAR 0 2
110363: PPUSH
110364: LD_VAR 0 3
110368: PPUSH
110369: CALL 52933 0 3
110373: NOT
110374: IFFALSE 110378
// exit ;
110376: GO 110632
// until GetDistUnitXY ( unit , x , y ) < dist ;
110378: LD_VAR 0 1
110382: PPUSH
110383: LD_VAR 0 2
110387: PPUSH
110388: LD_VAR 0 3
110392: PPUSH
110393: CALL_OW 297
110397: PUSH
110398: LD_VAR 0 5
110402: LESS
110403: IFFALSE 110347
// end ; ComTurnXY ( unit , x , y ) ;
110405: LD_VAR 0 1
110409: PPUSH
110410: LD_VAR 0 2
110414: PPUSH
110415: LD_VAR 0 3
110419: PPUSH
110420: CALL_OW 118
// wait ( 5 ) ;
110424: LD_INT 5
110426: PPUSH
110427: CALL_OW 67
// _d := GetDir ( unit ) ;
110431: LD_ADDR_VAR 0 10
110435: PUSH
110436: LD_VAR 0 1
110440: PPUSH
110441: CALL_OW 254
110445: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110446: LD_ADDR_VAR 0 8
110450: PUSH
110451: LD_VAR 0 1
110455: PPUSH
110456: CALL_OW 250
110460: PPUSH
110461: LD_VAR 0 10
110465: PPUSH
110466: LD_VAR 0 5
110470: PPUSH
110471: CALL_OW 272
110475: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110476: LD_ADDR_VAR 0 9
110480: PUSH
110481: LD_VAR 0 1
110485: PPUSH
110486: CALL_OW 251
110490: PPUSH
110491: LD_VAR 0 10
110495: PPUSH
110496: LD_VAR 0 5
110500: PPUSH
110501: CALL_OW 273
110505: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110506: LD_VAR 0 8
110510: PPUSH
110511: LD_VAR 0 9
110515: PPUSH
110516: CALL_OW 488
110520: NOT
110521: IFFALSE 110525
// exit ;
110523: GO 110632
// ComAnimCustom ( unit , 1 ) ;
110525: LD_VAR 0 1
110529: PPUSH
110530: LD_INT 1
110532: PPUSH
110533: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110537: LD_VAR 0 8
110541: PPUSH
110542: LD_VAR 0 9
110546: PPUSH
110547: LD_VAR 0 6
110551: PPUSH
110552: LD_VAR 0 7
110556: PPUSH
110557: CALL_OW 330
// repeat wait ( 1 ) ;
110561: LD_INT 1
110563: PPUSH
110564: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110568: LD_VAR 0 1
110572: PPUSH
110573: CALL_OW 316
110577: PUSH
110578: LD_VAR 0 1
110582: PPUSH
110583: CALL_OW 314
110587: OR
110588: PUSH
110589: LD_VAR 0 1
110593: PPUSH
110594: CALL_OW 302
110598: NOT
110599: OR
110600: PUSH
110601: LD_VAR 0 1
110605: PPUSH
110606: CALL_OW 301
110610: OR
110611: IFFALSE 110561
// RemoveSeeing ( _x , _y , side ) ;
110613: LD_VAR 0 8
110617: PPUSH
110618: LD_VAR 0 9
110622: PPUSH
110623: LD_VAR 0 6
110627: PPUSH
110628: CALL_OW 331
// end ; end_of_file
110632: LD_VAR 0 4
110636: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110637: LD_INT 0
110639: PPUSH
110640: PPUSH
110641: PPUSH
110642: PPUSH
110643: PPUSH
110644: PPUSH
110645: PPUSH
110646: PPUSH
110647: PPUSH
110648: PPUSH
110649: PPUSH
110650: PPUSH
110651: PPUSH
110652: PPUSH
110653: PPUSH
110654: PPUSH
110655: PPUSH
110656: PPUSH
110657: PPUSH
110658: PPUSH
110659: PPUSH
110660: PPUSH
110661: PPUSH
110662: PPUSH
110663: PPUSH
110664: PPUSH
110665: PPUSH
110666: PPUSH
110667: PPUSH
110668: PPUSH
110669: PPUSH
110670: PPUSH
110671: PPUSH
110672: PPUSH
// if not list then
110673: LD_VAR 0 1
110677: NOT
110678: IFFALSE 110682
// exit ;
110680: GO 115341
// base := list [ 1 ] ;
110682: LD_ADDR_VAR 0 3
110686: PUSH
110687: LD_VAR 0 1
110691: PUSH
110692: LD_INT 1
110694: ARRAY
110695: ST_TO_ADDR
// group := list [ 2 ] ;
110696: LD_ADDR_VAR 0 4
110700: PUSH
110701: LD_VAR 0 1
110705: PUSH
110706: LD_INT 2
110708: ARRAY
110709: ST_TO_ADDR
// path := list [ 3 ] ;
110710: LD_ADDR_VAR 0 5
110714: PUSH
110715: LD_VAR 0 1
110719: PUSH
110720: LD_INT 3
110722: ARRAY
110723: ST_TO_ADDR
// flags := list [ 4 ] ;
110724: LD_ADDR_VAR 0 6
110728: PUSH
110729: LD_VAR 0 1
110733: PUSH
110734: LD_INT 4
110736: ARRAY
110737: ST_TO_ADDR
// mined := [ ] ;
110738: LD_ADDR_VAR 0 27
110742: PUSH
110743: EMPTY
110744: ST_TO_ADDR
// bombed := [ ] ;
110745: LD_ADDR_VAR 0 28
110749: PUSH
110750: EMPTY
110751: ST_TO_ADDR
// healers := [ ] ;
110752: LD_ADDR_VAR 0 31
110756: PUSH
110757: EMPTY
110758: ST_TO_ADDR
// to_heal := [ ] ;
110759: LD_ADDR_VAR 0 30
110763: PUSH
110764: EMPTY
110765: ST_TO_ADDR
// repairs := [ ] ;
110766: LD_ADDR_VAR 0 33
110770: PUSH
110771: EMPTY
110772: ST_TO_ADDR
// to_repair := [ ] ;
110773: LD_ADDR_VAR 0 32
110777: PUSH
110778: EMPTY
110779: ST_TO_ADDR
// if not group or not path then
110780: LD_VAR 0 4
110784: NOT
110785: PUSH
110786: LD_VAR 0 5
110790: NOT
110791: OR
110792: IFFALSE 110796
// exit ;
110794: GO 115341
// side := GetSide ( group [ 1 ] ) ;
110796: LD_ADDR_VAR 0 35
110800: PUSH
110801: LD_VAR 0 4
110805: PUSH
110806: LD_INT 1
110808: ARRAY
110809: PPUSH
110810: CALL_OW 255
110814: ST_TO_ADDR
// if flags then
110815: LD_VAR 0 6
110819: IFFALSE 110963
// begin f_ignore_area := flags [ 1 ] ;
110821: LD_ADDR_VAR 0 17
110825: PUSH
110826: LD_VAR 0 6
110830: PUSH
110831: LD_INT 1
110833: ARRAY
110834: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110835: LD_ADDR_VAR 0 18
110839: PUSH
110840: LD_VAR 0 6
110844: PUSH
110845: LD_INT 2
110847: ARRAY
110848: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110849: LD_ADDR_VAR 0 19
110853: PUSH
110854: LD_VAR 0 6
110858: PUSH
110859: LD_INT 3
110861: ARRAY
110862: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110863: LD_ADDR_VAR 0 20
110867: PUSH
110868: LD_VAR 0 6
110872: PUSH
110873: LD_INT 4
110875: ARRAY
110876: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110877: LD_ADDR_VAR 0 21
110881: PUSH
110882: LD_VAR 0 6
110886: PUSH
110887: LD_INT 5
110889: ARRAY
110890: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110891: LD_ADDR_VAR 0 22
110895: PUSH
110896: LD_VAR 0 6
110900: PUSH
110901: LD_INT 6
110903: ARRAY
110904: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110905: LD_ADDR_VAR 0 23
110909: PUSH
110910: LD_VAR 0 6
110914: PUSH
110915: LD_INT 7
110917: ARRAY
110918: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110919: LD_ADDR_VAR 0 24
110923: PUSH
110924: LD_VAR 0 6
110928: PUSH
110929: LD_INT 8
110931: ARRAY
110932: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110933: LD_ADDR_VAR 0 25
110937: PUSH
110938: LD_VAR 0 6
110942: PUSH
110943: LD_INT 9
110945: ARRAY
110946: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110947: LD_ADDR_VAR 0 26
110951: PUSH
110952: LD_VAR 0 6
110956: PUSH
110957: LD_INT 10
110959: ARRAY
110960: ST_TO_ADDR
// end else
110961: GO 111043
// begin f_ignore_area := false ;
110963: LD_ADDR_VAR 0 17
110967: PUSH
110968: LD_INT 0
110970: ST_TO_ADDR
// f_capture := false ;
110971: LD_ADDR_VAR 0 18
110975: PUSH
110976: LD_INT 0
110978: ST_TO_ADDR
// f_ignore_civ := false ;
110979: LD_ADDR_VAR 0 19
110983: PUSH
110984: LD_INT 0
110986: ST_TO_ADDR
// f_murder := false ;
110987: LD_ADDR_VAR 0 20
110991: PUSH
110992: LD_INT 0
110994: ST_TO_ADDR
// f_mines := false ;
110995: LD_ADDR_VAR 0 21
110999: PUSH
111000: LD_INT 0
111002: ST_TO_ADDR
// f_repair := false ;
111003: LD_ADDR_VAR 0 22
111007: PUSH
111008: LD_INT 0
111010: ST_TO_ADDR
// f_heal := false ;
111011: LD_ADDR_VAR 0 23
111015: PUSH
111016: LD_INT 0
111018: ST_TO_ADDR
// f_spacetime := false ;
111019: LD_ADDR_VAR 0 24
111023: PUSH
111024: LD_INT 0
111026: ST_TO_ADDR
// f_attack_depot := false ;
111027: LD_ADDR_VAR 0 25
111031: PUSH
111032: LD_INT 0
111034: ST_TO_ADDR
// f_crawl := false ;
111035: LD_ADDR_VAR 0 26
111039: PUSH
111040: LD_INT 0
111042: ST_TO_ADDR
// end ; if f_heal then
111043: LD_VAR 0 23
111047: IFFALSE 111074
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111049: LD_ADDR_VAR 0 31
111053: PUSH
111054: LD_VAR 0 4
111058: PPUSH
111059: LD_INT 25
111061: PUSH
111062: LD_INT 4
111064: PUSH
111065: EMPTY
111066: LIST
111067: LIST
111068: PPUSH
111069: CALL_OW 72
111073: ST_TO_ADDR
// if f_repair then
111074: LD_VAR 0 22
111078: IFFALSE 111105
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111080: LD_ADDR_VAR 0 33
111084: PUSH
111085: LD_VAR 0 4
111089: PPUSH
111090: LD_INT 25
111092: PUSH
111093: LD_INT 3
111095: PUSH
111096: EMPTY
111097: LIST
111098: LIST
111099: PPUSH
111100: CALL_OW 72
111104: ST_TO_ADDR
// units_path := [ ] ;
111105: LD_ADDR_VAR 0 16
111109: PUSH
111110: EMPTY
111111: ST_TO_ADDR
// for i = 1 to group do
111112: LD_ADDR_VAR 0 7
111116: PUSH
111117: DOUBLE
111118: LD_INT 1
111120: DEC
111121: ST_TO_ADDR
111122: LD_VAR 0 4
111126: PUSH
111127: FOR_TO
111128: IFFALSE 111157
// units_path := Replace ( units_path , i , path ) ;
111130: LD_ADDR_VAR 0 16
111134: PUSH
111135: LD_VAR 0 16
111139: PPUSH
111140: LD_VAR 0 7
111144: PPUSH
111145: LD_VAR 0 5
111149: PPUSH
111150: CALL_OW 1
111154: ST_TO_ADDR
111155: GO 111127
111157: POP
111158: POP
// repeat for i = group downto 1 do
111159: LD_ADDR_VAR 0 7
111163: PUSH
111164: DOUBLE
111165: LD_VAR 0 4
111169: INC
111170: ST_TO_ADDR
111171: LD_INT 1
111173: PUSH
111174: FOR_DOWNTO
111175: IFFALSE 115297
// begin wait ( 5 ) ;
111177: LD_INT 5
111179: PPUSH
111180: CALL_OW 67
// tmp := [ ] ;
111184: LD_ADDR_VAR 0 14
111188: PUSH
111189: EMPTY
111190: ST_TO_ADDR
// attacking := false ;
111191: LD_ADDR_VAR 0 29
111195: PUSH
111196: LD_INT 0
111198: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111199: LD_VAR 0 4
111203: PUSH
111204: LD_VAR 0 7
111208: ARRAY
111209: PPUSH
111210: CALL_OW 301
111214: PUSH
111215: LD_VAR 0 4
111219: PUSH
111220: LD_VAR 0 7
111224: ARRAY
111225: NOT
111226: OR
111227: IFFALSE 111336
// begin if GetType ( group [ i ] ) = unit_human then
111229: LD_VAR 0 4
111233: PUSH
111234: LD_VAR 0 7
111238: ARRAY
111239: PPUSH
111240: CALL_OW 247
111244: PUSH
111245: LD_INT 1
111247: EQUAL
111248: IFFALSE 111294
// begin to_heal := to_heal diff group [ i ] ;
111250: LD_ADDR_VAR 0 30
111254: PUSH
111255: LD_VAR 0 30
111259: PUSH
111260: LD_VAR 0 4
111264: PUSH
111265: LD_VAR 0 7
111269: ARRAY
111270: DIFF
111271: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111272: LD_ADDR_VAR 0 31
111276: PUSH
111277: LD_VAR 0 31
111281: PUSH
111282: LD_VAR 0 4
111286: PUSH
111287: LD_VAR 0 7
111291: ARRAY
111292: DIFF
111293: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111294: LD_ADDR_VAR 0 4
111298: PUSH
111299: LD_VAR 0 4
111303: PPUSH
111304: LD_VAR 0 7
111308: PPUSH
111309: CALL_OW 3
111313: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111314: LD_ADDR_VAR 0 16
111318: PUSH
111319: LD_VAR 0 16
111323: PPUSH
111324: LD_VAR 0 7
111328: PPUSH
111329: CALL_OW 3
111333: ST_TO_ADDR
// continue ;
111334: GO 111174
// end ; if f_repair then
111336: LD_VAR 0 22
111340: IFFALSE 111829
// begin if GetType ( group [ i ] ) = unit_vehicle then
111342: LD_VAR 0 4
111346: PUSH
111347: LD_VAR 0 7
111351: ARRAY
111352: PPUSH
111353: CALL_OW 247
111357: PUSH
111358: LD_INT 2
111360: EQUAL
111361: IFFALSE 111551
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111363: LD_VAR 0 4
111367: PUSH
111368: LD_VAR 0 7
111372: ARRAY
111373: PPUSH
111374: CALL_OW 256
111378: PUSH
111379: LD_INT 700
111381: LESS
111382: PUSH
111383: LD_VAR 0 4
111387: PUSH
111388: LD_VAR 0 7
111392: ARRAY
111393: PUSH
111394: LD_VAR 0 32
111398: IN
111399: NOT
111400: AND
111401: IFFALSE 111425
// to_repair := to_repair union group [ i ] ;
111403: LD_ADDR_VAR 0 32
111407: PUSH
111408: LD_VAR 0 32
111412: PUSH
111413: LD_VAR 0 4
111417: PUSH
111418: LD_VAR 0 7
111422: ARRAY
111423: UNION
111424: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111425: LD_VAR 0 4
111429: PUSH
111430: LD_VAR 0 7
111434: ARRAY
111435: PPUSH
111436: CALL_OW 256
111440: PUSH
111441: LD_INT 1000
111443: EQUAL
111444: PUSH
111445: LD_VAR 0 4
111449: PUSH
111450: LD_VAR 0 7
111454: ARRAY
111455: PUSH
111456: LD_VAR 0 32
111460: IN
111461: AND
111462: IFFALSE 111486
// to_repair := to_repair diff group [ i ] ;
111464: LD_ADDR_VAR 0 32
111468: PUSH
111469: LD_VAR 0 32
111473: PUSH
111474: LD_VAR 0 4
111478: PUSH
111479: LD_VAR 0 7
111483: ARRAY
111484: DIFF
111485: ST_TO_ADDR
// if group [ i ] in to_repair then
111486: LD_VAR 0 4
111490: PUSH
111491: LD_VAR 0 7
111495: ARRAY
111496: PUSH
111497: LD_VAR 0 32
111501: IN
111502: IFFALSE 111549
// begin if not IsInArea ( group [ i ] , f_repair ) then
111504: LD_VAR 0 4
111508: PUSH
111509: LD_VAR 0 7
111513: ARRAY
111514: PPUSH
111515: LD_VAR 0 22
111519: PPUSH
111520: CALL_OW 308
111524: NOT
111525: IFFALSE 111547
// ComMoveToArea ( group [ i ] , f_repair ) ;
111527: LD_VAR 0 4
111531: PUSH
111532: LD_VAR 0 7
111536: ARRAY
111537: PPUSH
111538: LD_VAR 0 22
111542: PPUSH
111543: CALL_OW 113
// continue ;
111547: GO 111174
// end ; end else
111549: GO 111829
// if group [ i ] in repairs then
111551: LD_VAR 0 4
111555: PUSH
111556: LD_VAR 0 7
111560: ARRAY
111561: PUSH
111562: LD_VAR 0 33
111566: IN
111567: IFFALSE 111829
// begin if IsInUnit ( group [ i ] ) then
111569: LD_VAR 0 4
111573: PUSH
111574: LD_VAR 0 7
111578: ARRAY
111579: PPUSH
111580: CALL_OW 310
111584: IFFALSE 111652
// begin z := IsInUnit ( group [ i ] ) ;
111586: LD_ADDR_VAR 0 13
111590: PUSH
111591: LD_VAR 0 4
111595: PUSH
111596: LD_VAR 0 7
111600: ARRAY
111601: PPUSH
111602: CALL_OW 310
111606: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111607: LD_VAR 0 13
111611: PUSH
111612: LD_VAR 0 32
111616: IN
111617: PUSH
111618: LD_VAR 0 13
111622: PPUSH
111623: LD_VAR 0 22
111627: PPUSH
111628: CALL_OW 308
111632: AND
111633: IFFALSE 111650
// ComExitVehicle ( group [ i ] ) ;
111635: LD_VAR 0 4
111639: PUSH
111640: LD_VAR 0 7
111644: ARRAY
111645: PPUSH
111646: CALL_OW 121
// end else
111650: GO 111829
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111652: LD_ADDR_VAR 0 13
111656: PUSH
111657: LD_VAR 0 4
111661: PPUSH
111662: LD_INT 95
111664: PUSH
111665: LD_VAR 0 22
111669: PUSH
111670: EMPTY
111671: LIST
111672: LIST
111673: PUSH
111674: LD_INT 58
111676: PUSH
111677: EMPTY
111678: LIST
111679: PUSH
111680: EMPTY
111681: LIST
111682: LIST
111683: PPUSH
111684: CALL_OW 72
111688: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111689: LD_VAR 0 4
111693: PUSH
111694: LD_VAR 0 7
111698: ARRAY
111699: PPUSH
111700: CALL_OW 314
111704: NOT
111705: IFFALSE 111827
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111707: LD_ADDR_VAR 0 10
111711: PUSH
111712: LD_VAR 0 13
111716: PPUSH
111717: LD_VAR 0 4
111721: PUSH
111722: LD_VAR 0 7
111726: ARRAY
111727: PPUSH
111728: CALL_OW 74
111732: ST_TO_ADDR
// if not x then
111733: LD_VAR 0 10
111737: NOT
111738: IFFALSE 111742
// continue ;
111740: GO 111174
// if GetLives ( x ) < 1000 then
111742: LD_VAR 0 10
111746: PPUSH
111747: CALL_OW 256
111751: PUSH
111752: LD_INT 1000
111754: LESS
111755: IFFALSE 111779
// ComRepairVehicle ( group [ i ] , x ) else
111757: LD_VAR 0 4
111761: PUSH
111762: LD_VAR 0 7
111766: ARRAY
111767: PPUSH
111768: LD_VAR 0 10
111772: PPUSH
111773: CALL_OW 129
111777: GO 111827
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111779: LD_VAR 0 23
111783: PUSH
111784: LD_VAR 0 4
111788: PUSH
111789: LD_VAR 0 7
111793: ARRAY
111794: PPUSH
111795: CALL_OW 256
111799: PUSH
111800: LD_INT 1000
111802: LESS
111803: AND
111804: NOT
111805: IFFALSE 111827
// ComEnterUnit ( group [ i ] , x ) ;
111807: LD_VAR 0 4
111811: PUSH
111812: LD_VAR 0 7
111816: ARRAY
111817: PPUSH
111818: LD_VAR 0 10
111822: PPUSH
111823: CALL_OW 120
// end ; continue ;
111827: GO 111174
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111829: LD_VAR 0 23
111833: PUSH
111834: LD_VAR 0 4
111838: PUSH
111839: LD_VAR 0 7
111843: ARRAY
111844: PPUSH
111845: CALL_OW 247
111849: PUSH
111850: LD_INT 1
111852: EQUAL
111853: AND
111854: IFFALSE 112332
// begin if group [ i ] in healers then
111856: LD_VAR 0 4
111860: PUSH
111861: LD_VAR 0 7
111865: ARRAY
111866: PUSH
111867: LD_VAR 0 31
111871: IN
111872: IFFALSE 112145
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111874: LD_VAR 0 4
111878: PUSH
111879: LD_VAR 0 7
111883: ARRAY
111884: PPUSH
111885: LD_VAR 0 23
111889: PPUSH
111890: CALL_OW 308
111894: NOT
111895: PUSH
111896: LD_VAR 0 4
111900: PUSH
111901: LD_VAR 0 7
111905: ARRAY
111906: PPUSH
111907: CALL_OW 314
111911: NOT
111912: AND
111913: IFFALSE 111937
// ComMoveToArea ( group [ i ] , f_heal ) else
111915: LD_VAR 0 4
111919: PUSH
111920: LD_VAR 0 7
111924: ARRAY
111925: PPUSH
111926: LD_VAR 0 23
111930: PPUSH
111931: CALL_OW 113
111935: GO 112143
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111937: LD_VAR 0 4
111941: PUSH
111942: LD_VAR 0 7
111946: ARRAY
111947: PPUSH
111948: CALL 51516 0 1
111952: PPUSH
111953: CALL_OW 256
111957: PUSH
111958: LD_INT 1000
111960: EQUAL
111961: IFFALSE 111980
// ComStop ( group [ i ] ) else
111963: LD_VAR 0 4
111967: PUSH
111968: LD_VAR 0 7
111972: ARRAY
111973: PPUSH
111974: CALL_OW 141
111978: GO 112143
// if not HasTask ( group [ i ] ) and to_heal then
111980: LD_VAR 0 4
111984: PUSH
111985: LD_VAR 0 7
111989: ARRAY
111990: PPUSH
111991: CALL_OW 314
111995: NOT
111996: PUSH
111997: LD_VAR 0 30
112001: AND
112002: IFFALSE 112143
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112004: LD_ADDR_VAR 0 13
112008: PUSH
112009: LD_VAR 0 30
112013: PPUSH
112014: LD_INT 3
112016: PUSH
112017: LD_INT 54
112019: PUSH
112020: EMPTY
112021: LIST
112022: PUSH
112023: EMPTY
112024: LIST
112025: LIST
112026: PPUSH
112027: CALL_OW 72
112031: PPUSH
112032: LD_VAR 0 4
112036: PUSH
112037: LD_VAR 0 7
112041: ARRAY
112042: PPUSH
112043: CALL_OW 74
112047: ST_TO_ADDR
// if z then
112048: LD_VAR 0 13
112052: IFFALSE 112143
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112054: LD_INT 91
112056: PUSH
112057: LD_VAR 0 13
112061: PUSH
112062: LD_INT 10
112064: PUSH
112065: EMPTY
112066: LIST
112067: LIST
112068: LIST
112069: PUSH
112070: LD_INT 81
112072: PUSH
112073: LD_VAR 0 13
112077: PPUSH
112078: CALL_OW 255
112082: PUSH
112083: EMPTY
112084: LIST
112085: LIST
112086: PUSH
112087: EMPTY
112088: LIST
112089: LIST
112090: PPUSH
112091: CALL_OW 69
112095: PUSH
112096: LD_INT 0
112098: EQUAL
112099: IFFALSE 112123
// ComHeal ( group [ i ] , z ) else
112101: LD_VAR 0 4
112105: PUSH
112106: LD_VAR 0 7
112110: ARRAY
112111: PPUSH
112112: LD_VAR 0 13
112116: PPUSH
112117: CALL_OW 128
112121: GO 112143
// ComMoveToArea ( group [ i ] , f_heal ) ;
112123: LD_VAR 0 4
112127: PUSH
112128: LD_VAR 0 7
112132: ARRAY
112133: PPUSH
112134: LD_VAR 0 23
112138: PPUSH
112139: CALL_OW 113
// end ; continue ;
112143: GO 111174
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112145: LD_VAR 0 4
112149: PUSH
112150: LD_VAR 0 7
112154: ARRAY
112155: PPUSH
112156: CALL_OW 256
112160: PUSH
112161: LD_INT 700
112163: LESS
112164: PUSH
112165: LD_VAR 0 4
112169: PUSH
112170: LD_VAR 0 7
112174: ARRAY
112175: PUSH
112176: LD_VAR 0 30
112180: IN
112181: NOT
112182: AND
112183: IFFALSE 112207
// to_heal := to_heal union group [ i ] ;
112185: LD_ADDR_VAR 0 30
112189: PUSH
112190: LD_VAR 0 30
112194: PUSH
112195: LD_VAR 0 4
112199: PUSH
112200: LD_VAR 0 7
112204: ARRAY
112205: UNION
112206: ST_TO_ADDR
// if group [ i ] in to_heal then
112207: LD_VAR 0 4
112211: PUSH
112212: LD_VAR 0 7
112216: ARRAY
112217: PUSH
112218: LD_VAR 0 30
112222: IN
112223: IFFALSE 112332
// begin if GetLives ( group [ i ] ) = 1000 then
112225: LD_VAR 0 4
112229: PUSH
112230: LD_VAR 0 7
112234: ARRAY
112235: PPUSH
112236: CALL_OW 256
112240: PUSH
112241: LD_INT 1000
112243: EQUAL
112244: IFFALSE 112270
// to_heal := to_heal diff group [ i ] else
112246: LD_ADDR_VAR 0 30
112250: PUSH
112251: LD_VAR 0 30
112255: PUSH
112256: LD_VAR 0 4
112260: PUSH
112261: LD_VAR 0 7
112265: ARRAY
112266: DIFF
112267: ST_TO_ADDR
112268: GO 112332
// begin if not IsInArea ( group [ i ] , to_heal ) then
112270: LD_VAR 0 4
112274: PUSH
112275: LD_VAR 0 7
112279: ARRAY
112280: PPUSH
112281: LD_VAR 0 30
112285: PPUSH
112286: CALL_OW 308
112290: NOT
112291: IFFALSE 112315
// ComMoveToArea ( group [ i ] , f_heal ) else
112293: LD_VAR 0 4
112297: PUSH
112298: LD_VAR 0 7
112302: ARRAY
112303: PPUSH
112304: LD_VAR 0 23
112308: PPUSH
112309: CALL_OW 113
112313: GO 112330
// ComHold ( group [ i ] ) ;
112315: LD_VAR 0 4
112319: PUSH
112320: LD_VAR 0 7
112324: ARRAY
112325: PPUSH
112326: CALL_OW 140
// continue ;
112330: GO 111174
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112332: LD_VAR 0 4
112336: PUSH
112337: LD_VAR 0 7
112341: ARRAY
112342: PPUSH
112343: LD_INT 10
112345: PPUSH
112346: CALL 49298 0 2
112350: NOT
112351: PUSH
112352: LD_VAR 0 16
112356: PUSH
112357: LD_VAR 0 7
112361: ARRAY
112362: PUSH
112363: EMPTY
112364: EQUAL
112365: NOT
112366: AND
112367: IFFALSE 112633
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112369: LD_VAR 0 4
112373: PUSH
112374: LD_VAR 0 7
112378: ARRAY
112379: PPUSH
112380: CALL_OW 262
112384: PUSH
112385: LD_INT 1
112387: PUSH
112388: LD_INT 2
112390: PUSH
112391: EMPTY
112392: LIST
112393: LIST
112394: IN
112395: IFFALSE 112436
// if GetFuel ( group [ i ] ) < 10 then
112397: LD_VAR 0 4
112401: PUSH
112402: LD_VAR 0 7
112406: ARRAY
112407: PPUSH
112408: CALL_OW 261
112412: PUSH
112413: LD_INT 10
112415: LESS
112416: IFFALSE 112436
// SetFuel ( group [ i ] , 12 ) ;
112418: LD_VAR 0 4
112422: PUSH
112423: LD_VAR 0 7
112427: ARRAY
112428: PPUSH
112429: LD_INT 12
112431: PPUSH
112432: CALL_OW 240
// if units_path [ i ] then
112436: LD_VAR 0 16
112440: PUSH
112441: LD_VAR 0 7
112445: ARRAY
112446: IFFALSE 112631
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112448: LD_VAR 0 4
112452: PUSH
112453: LD_VAR 0 7
112457: ARRAY
112458: PPUSH
112459: LD_VAR 0 16
112463: PUSH
112464: LD_VAR 0 7
112468: ARRAY
112469: PUSH
112470: LD_INT 1
112472: ARRAY
112473: PUSH
112474: LD_INT 1
112476: ARRAY
112477: PPUSH
112478: LD_VAR 0 16
112482: PUSH
112483: LD_VAR 0 7
112487: ARRAY
112488: PUSH
112489: LD_INT 1
112491: ARRAY
112492: PUSH
112493: LD_INT 2
112495: ARRAY
112496: PPUSH
112497: CALL_OW 297
112501: PUSH
112502: LD_INT 6
112504: GREATER
112505: IFFALSE 112580
// begin if not HasTask ( group [ i ] ) then
112507: LD_VAR 0 4
112511: PUSH
112512: LD_VAR 0 7
112516: ARRAY
112517: PPUSH
112518: CALL_OW 314
112522: NOT
112523: IFFALSE 112578
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112525: LD_VAR 0 4
112529: PUSH
112530: LD_VAR 0 7
112534: ARRAY
112535: PPUSH
112536: LD_VAR 0 16
112540: PUSH
112541: LD_VAR 0 7
112545: ARRAY
112546: PUSH
112547: LD_INT 1
112549: ARRAY
112550: PUSH
112551: LD_INT 1
112553: ARRAY
112554: PPUSH
112555: LD_VAR 0 16
112559: PUSH
112560: LD_VAR 0 7
112564: ARRAY
112565: PUSH
112566: LD_INT 1
112568: ARRAY
112569: PUSH
112570: LD_INT 2
112572: ARRAY
112573: PPUSH
112574: CALL_OW 114
// end else
112578: GO 112631
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112580: LD_ADDR_VAR 0 15
112584: PUSH
112585: LD_VAR 0 16
112589: PUSH
112590: LD_VAR 0 7
112594: ARRAY
112595: PPUSH
112596: LD_INT 1
112598: PPUSH
112599: CALL_OW 3
112603: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112604: LD_ADDR_VAR 0 16
112608: PUSH
112609: LD_VAR 0 16
112613: PPUSH
112614: LD_VAR 0 7
112618: PPUSH
112619: LD_VAR 0 15
112623: PPUSH
112624: CALL_OW 1
112628: ST_TO_ADDR
// continue ;
112629: GO 111174
// end ; end ; end else
112631: GO 115295
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112633: LD_ADDR_VAR 0 14
112637: PUSH
112638: LD_INT 81
112640: PUSH
112641: LD_VAR 0 4
112645: PUSH
112646: LD_VAR 0 7
112650: ARRAY
112651: PPUSH
112652: CALL_OW 255
112656: PUSH
112657: EMPTY
112658: LIST
112659: LIST
112660: PPUSH
112661: CALL_OW 69
112665: ST_TO_ADDR
// if not tmp then
112666: LD_VAR 0 14
112670: NOT
112671: IFFALSE 112675
// continue ;
112673: GO 111174
// if f_ignore_area then
112675: LD_VAR 0 17
112679: IFFALSE 112767
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112681: LD_ADDR_VAR 0 15
112685: PUSH
112686: LD_VAR 0 14
112690: PPUSH
112691: LD_INT 3
112693: PUSH
112694: LD_INT 92
112696: PUSH
112697: LD_VAR 0 17
112701: PUSH
112702: LD_INT 1
112704: ARRAY
112705: PUSH
112706: LD_VAR 0 17
112710: PUSH
112711: LD_INT 2
112713: ARRAY
112714: PUSH
112715: LD_VAR 0 17
112719: PUSH
112720: LD_INT 3
112722: ARRAY
112723: PUSH
112724: EMPTY
112725: LIST
112726: LIST
112727: LIST
112728: LIST
112729: PUSH
112730: EMPTY
112731: LIST
112732: LIST
112733: PPUSH
112734: CALL_OW 72
112738: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112739: LD_VAR 0 14
112743: PUSH
112744: LD_VAR 0 15
112748: DIFF
112749: IFFALSE 112767
// tmp := tmp diff tmp2 ;
112751: LD_ADDR_VAR 0 14
112755: PUSH
112756: LD_VAR 0 14
112760: PUSH
112761: LD_VAR 0 15
112765: DIFF
112766: ST_TO_ADDR
// end ; if not f_murder then
112767: LD_VAR 0 20
112771: NOT
112772: IFFALSE 112830
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112774: LD_ADDR_VAR 0 15
112778: PUSH
112779: LD_VAR 0 14
112783: PPUSH
112784: LD_INT 3
112786: PUSH
112787: LD_INT 50
112789: PUSH
112790: EMPTY
112791: LIST
112792: PUSH
112793: EMPTY
112794: LIST
112795: LIST
112796: PPUSH
112797: CALL_OW 72
112801: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112802: LD_VAR 0 14
112806: PUSH
112807: LD_VAR 0 15
112811: DIFF
112812: IFFALSE 112830
// tmp := tmp diff tmp2 ;
112814: LD_ADDR_VAR 0 14
112818: PUSH
112819: LD_VAR 0 14
112823: PUSH
112824: LD_VAR 0 15
112828: DIFF
112829: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112830: LD_ADDR_VAR 0 14
112834: PUSH
112835: LD_VAR 0 4
112839: PUSH
112840: LD_VAR 0 7
112844: ARRAY
112845: PPUSH
112846: LD_VAR 0 14
112850: PPUSH
112851: LD_INT 1
112853: PPUSH
112854: LD_INT 1
112856: PPUSH
112857: CALL 21842 0 4
112861: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112862: LD_VAR 0 4
112866: PUSH
112867: LD_VAR 0 7
112871: ARRAY
112872: PPUSH
112873: CALL_OW 257
112877: PUSH
112878: LD_INT 1
112880: EQUAL
112881: IFFALSE 113329
// begin if WantPlant ( group [ i ] ) then
112883: LD_VAR 0 4
112887: PUSH
112888: LD_VAR 0 7
112892: ARRAY
112893: PPUSH
112894: CALL 21343 0 1
112898: IFFALSE 112902
// continue ;
112900: GO 111174
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112902: LD_VAR 0 18
112906: PUSH
112907: LD_VAR 0 4
112911: PUSH
112912: LD_VAR 0 7
112916: ARRAY
112917: PPUSH
112918: CALL_OW 310
112922: NOT
112923: AND
112924: PUSH
112925: LD_VAR 0 14
112929: PUSH
112930: LD_INT 1
112932: ARRAY
112933: PUSH
112934: LD_VAR 0 14
112938: PPUSH
112939: LD_INT 21
112941: PUSH
112942: LD_INT 2
112944: PUSH
112945: EMPTY
112946: LIST
112947: LIST
112948: PUSH
112949: LD_INT 58
112951: PUSH
112952: EMPTY
112953: LIST
112954: PUSH
112955: EMPTY
112956: LIST
112957: LIST
112958: PPUSH
112959: CALL_OW 72
112963: IN
112964: AND
112965: IFFALSE 113001
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112967: LD_VAR 0 4
112971: PUSH
112972: LD_VAR 0 7
112976: ARRAY
112977: PPUSH
112978: LD_VAR 0 14
112982: PUSH
112983: LD_INT 1
112985: ARRAY
112986: PPUSH
112987: CALL_OW 120
// attacking := true ;
112991: LD_ADDR_VAR 0 29
112995: PUSH
112996: LD_INT 1
112998: ST_TO_ADDR
// continue ;
112999: GO 111174
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113001: LD_VAR 0 26
113005: PUSH
113006: LD_VAR 0 4
113010: PUSH
113011: LD_VAR 0 7
113015: ARRAY
113016: PPUSH
113017: CALL_OW 257
113021: PUSH
113022: LD_INT 1
113024: EQUAL
113025: AND
113026: PUSH
113027: LD_VAR 0 4
113031: PUSH
113032: LD_VAR 0 7
113036: ARRAY
113037: PPUSH
113038: CALL_OW 256
113042: PUSH
113043: LD_INT 800
113045: LESS
113046: AND
113047: PUSH
113048: LD_VAR 0 4
113052: PUSH
113053: LD_VAR 0 7
113057: ARRAY
113058: PPUSH
113059: CALL_OW 318
113063: NOT
113064: AND
113065: IFFALSE 113082
// ComCrawl ( group [ i ] ) ;
113067: LD_VAR 0 4
113071: PUSH
113072: LD_VAR 0 7
113076: ARRAY
113077: PPUSH
113078: CALL_OW 137
// if f_mines then
113082: LD_VAR 0 21
113086: IFFALSE 113329
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113088: LD_VAR 0 14
113092: PUSH
113093: LD_INT 1
113095: ARRAY
113096: PPUSH
113097: CALL_OW 247
113101: PUSH
113102: LD_INT 3
113104: EQUAL
113105: PUSH
113106: LD_VAR 0 14
113110: PUSH
113111: LD_INT 1
113113: ARRAY
113114: PUSH
113115: LD_VAR 0 27
113119: IN
113120: NOT
113121: AND
113122: IFFALSE 113329
// begin x := GetX ( tmp [ 1 ] ) ;
113124: LD_ADDR_VAR 0 10
113128: PUSH
113129: LD_VAR 0 14
113133: PUSH
113134: LD_INT 1
113136: ARRAY
113137: PPUSH
113138: CALL_OW 250
113142: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113143: LD_ADDR_VAR 0 11
113147: PUSH
113148: LD_VAR 0 14
113152: PUSH
113153: LD_INT 1
113155: ARRAY
113156: PPUSH
113157: CALL_OW 251
113161: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113162: LD_ADDR_VAR 0 12
113166: PUSH
113167: LD_VAR 0 4
113171: PUSH
113172: LD_VAR 0 7
113176: ARRAY
113177: PPUSH
113178: CALL 49383 0 1
113182: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113183: LD_VAR 0 4
113187: PUSH
113188: LD_VAR 0 7
113192: ARRAY
113193: PPUSH
113194: LD_VAR 0 10
113198: PPUSH
113199: LD_VAR 0 11
113203: PPUSH
113204: LD_VAR 0 14
113208: PUSH
113209: LD_INT 1
113211: ARRAY
113212: PPUSH
113213: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113217: LD_VAR 0 4
113221: PUSH
113222: LD_VAR 0 7
113226: ARRAY
113227: PPUSH
113228: LD_VAR 0 10
113232: PPUSH
113233: LD_VAR 0 12
113237: PPUSH
113238: LD_INT 7
113240: PPUSH
113241: CALL_OW 272
113245: PPUSH
113246: LD_VAR 0 11
113250: PPUSH
113251: LD_VAR 0 12
113255: PPUSH
113256: LD_INT 7
113258: PPUSH
113259: CALL_OW 273
113263: PPUSH
113264: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113268: LD_VAR 0 4
113272: PUSH
113273: LD_VAR 0 7
113277: ARRAY
113278: PPUSH
113279: LD_INT 71
113281: PPUSH
113282: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113286: LD_ADDR_VAR 0 27
113290: PUSH
113291: LD_VAR 0 27
113295: PPUSH
113296: LD_VAR 0 27
113300: PUSH
113301: LD_INT 1
113303: PLUS
113304: PPUSH
113305: LD_VAR 0 14
113309: PUSH
113310: LD_INT 1
113312: ARRAY
113313: PPUSH
113314: CALL_OW 1
113318: ST_TO_ADDR
// attacking := true ;
113319: LD_ADDR_VAR 0 29
113323: PUSH
113324: LD_INT 1
113326: ST_TO_ADDR
// continue ;
113327: GO 111174
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113329: LD_VAR 0 4
113333: PUSH
113334: LD_VAR 0 7
113338: ARRAY
113339: PPUSH
113340: CALL_OW 257
113344: PUSH
113345: LD_INT 17
113347: EQUAL
113348: PUSH
113349: LD_VAR 0 4
113353: PUSH
113354: LD_VAR 0 7
113358: ARRAY
113359: PPUSH
113360: CALL_OW 110
113364: PUSH
113365: LD_INT 71
113367: EQUAL
113368: NOT
113369: AND
113370: IFFALSE 113516
// begin attacking := false ;
113372: LD_ADDR_VAR 0 29
113376: PUSH
113377: LD_INT 0
113379: ST_TO_ADDR
// k := 5 ;
113380: LD_ADDR_VAR 0 9
113384: PUSH
113385: LD_INT 5
113387: ST_TO_ADDR
// if tmp < k then
113388: LD_VAR 0 14
113392: PUSH
113393: LD_VAR 0 9
113397: LESS
113398: IFFALSE 113410
// k := tmp ;
113400: LD_ADDR_VAR 0 9
113404: PUSH
113405: LD_VAR 0 14
113409: ST_TO_ADDR
// for j = 1 to k do
113410: LD_ADDR_VAR 0 8
113414: PUSH
113415: DOUBLE
113416: LD_INT 1
113418: DEC
113419: ST_TO_ADDR
113420: LD_VAR 0 9
113424: PUSH
113425: FOR_TO
113426: IFFALSE 113514
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113428: LD_VAR 0 14
113432: PUSH
113433: LD_VAR 0 8
113437: ARRAY
113438: PUSH
113439: LD_VAR 0 14
113443: PPUSH
113444: LD_INT 58
113446: PUSH
113447: EMPTY
113448: LIST
113449: PPUSH
113450: CALL_OW 72
113454: IN
113455: NOT
113456: IFFALSE 113512
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113458: LD_VAR 0 4
113462: PUSH
113463: LD_VAR 0 7
113467: ARRAY
113468: PPUSH
113469: LD_VAR 0 14
113473: PUSH
113474: LD_VAR 0 8
113478: ARRAY
113479: PPUSH
113480: CALL_OW 115
// attacking := true ;
113484: LD_ADDR_VAR 0 29
113488: PUSH
113489: LD_INT 1
113491: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113492: LD_VAR 0 4
113496: PUSH
113497: LD_VAR 0 7
113501: ARRAY
113502: PPUSH
113503: LD_INT 71
113505: PPUSH
113506: CALL_OW 109
// continue ;
113510: GO 113425
// end ; end ;
113512: GO 113425
113514: POP
113515: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113516: LD_VAR 0 4
113520: PUSH
113521: LD_VAR 0 7
113525: ARRAY
113526: PPUSH
113527: CALL_OW 257
113531: PUSH
113532: LD_INT 8
113534: EQUAL
113535: PUSH
113536: LD_VAR 0 4
113540: PUSH
113541: LD_VAR 0 7
113545: ARRAY
113546: PPUSH
113547: CALL_OW 264
113551: PUSH
113552: LD_INT 28
113554: PUSH
113555: LD_INT 45
113557: PUSH
113558: LD_INT 7
113560: PUSH
113561: LD_INT 47
113563: PUSH
113564: EMPTY
113565: LIST
113566: LIST
113567: LIST
113568: LIST
113569: IN
113570: OR
113571: IFFALSE 113827
// begin attacking := false ;
113573: LD_ADDR_VAR 0 29
113577: PUSH
113578: LD_INT 0
113580: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113581: LD_VAR 0 14
113585: PUSH
113586: LD_INT 1
113588: ARRAY
113589: PPUSH
113590: CALL_OW 266
113594: PUSH
113595: LD_INT 32
113597: PUSH
113598: LD_INT 31
113600: PUSH
113601: LD_INT 33
113603: PUSH
113604: LD_INT 4
113606: PUSH
113607: LD_INT 5
113609: PUSH
113610: EMPTY
113611: LIST
113612: LIST
113613: LIST
113614: LIST
113615: LIST
113616: IN
113617: IFFALSE 113803
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113619: LD_ADDR_VAR 0 9
113623: PUSH
113624: LD_VAR 0 14
113628: PUSH
113629: LD_INT 1
113631: ARRAY
113632: PPUSH
113633: CALL_OW 266
113637: PPUSH
113638: LD_VAR 0 14
113642: PUSH
113643: LD_INT 1
113645: ARRAY
113646: PPUSH
113647: CALL_OW 250
113651: PPUSH
113652: LD_VAR 0 14
113656: PUSH
113657: LD_INT 1
113659: ARRAY
113660: PPUSH
113661: CALL_OW 251
113665: PPUSH
113666: LD_VAR 0 14
113670: PUSH
113671: LD_INT 1
113673: ARRAY
113674: PPUSH
113675: CALL_OW 254
113679: PPUSH
113680: LD_VAR 0 14
113684: PUSH
113685: LD_INT 1
113687: ARRAY
113688: PPUSH
113689: CALL_OW 248
113693: PPUSH
113694: LD_INT 0
113696: PPUSH
113697: CALL 30753 0 6
113701: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113702: LD_ADDR_VAR 0 8
113706: PUSH
113707: LD_VAR 0 4
113711: PUSH
113712: LD_VAR 0 7
113716: ARRAY
113717: PPUSH
113718: LD_VAR 0 9
113722: PPUSH
113723: CALL 49496 0 2
113727: ST_TO_ADDR
// if j then
113728: LD_VAR 0 8
113732: IFFALSE 113801
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113734: LD_VAR 0 8
113738: PUSH
113739: LD_INT 1
113741: ARRAY
113742: PPUSH
113743: LD_VAR 0 8
113747: PUSH
113748: LD_INT 2
113750: ARRAY
113751: PPUSH
113752: CALL_OW 488
113756: IFFALSE 113801
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113758: LD_VAR 0 4
113762: PUSH
113763: LD_VAR 0 7
113767: ARRAY
113768: PPUSH
113769: LD_VAR 0 8
113773: PUSH
113774: LD_INT 1
113776: ARRAY
113777: PPUSH
113778: LD_VAR 0 8
113782: PUSH
113783: LD_INT 2
113785: ARRAY
113786: PPUSH
113787: CALL_OW 116
// attacking := true ;
113791: LD_ADDR_VAR 0 29
113795: PUSH
113796: LD_INT 1
113798: ST_TO_ADDR
// continue ;
113799: GO 111174
// end ; end else
113801: GO 113827
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113803: LD_VAR 0 4
113807: PUSH
113808: LD_VAR 0 7
113812: ARRAY
113813: PPUSH
113814: LD_VAR 0 14
113818: PUSH
113819: LD_INT 1
113821: ARRAY
113822: PPUSH
113823: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113827: LD_VAR 0 4
113831: PUSH
113832: LD_VAR 0 7
113836: ARRAY
113837: PPUSH
113838: CALL_OW 265
113842: PUSH
113843: LD_INT 11
113845: EQUAL
113846: IFFALSE 114124
// begin k := 10 ;
113848: LD_ADDR_VAR 0 9
113852: PUSH
113853: LD_INT 10
113855: ST_TO_ADDR
// x := 0 ;
113856: LD_ADDR_VAR 0 10
113860: PUSH
113861: LD_INT 0
113863: ST_TO_ADDR
// if tmp < k then
113864: LD_VAR 0 14
113868: PUSH
113869: LD_VAR 0 9
113873: LESS
113874: IFFALSE 113886
// k := tmp ;
113876: LD_ADDR_VAR 0 9
113880: PUSH
113881: LD_VAR 0 14
113885: ST_TO_ADDR
// for j = k downto 1 do
113886: LD_ADDR_VAR 0 8
113890: PUSH
113891: DOUBLE
113892: LD_VAR 0 9
113896: INC
113897: ST_TO_ADDR
113898: LD_INT 1
113900: PUSH
113901: FOR_DOWNTO
113902: IFFALSE 113977
// begin if GetType ( tmp [ j ] ) = unit_human then
113904: LD_VAR 0 14
113908: PUSH
113909: LD_VAR 0 8
113913: ARRAY
113914: PPUSH
113915: CALL_OW 247
113919: PUSH
113920: LD_INT 1
113922: EQUAL
113923: IFFALSE 113975
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113925: LD_VAR 0 4
113929: PUSH
113930: LD_VAR 0 7
113934: ARRAY
113935: PPUSH
113936: LD_VAR 0 14
113940: PUSH
113941: LD_VAR 0 8
113945: ARRAY
113946: PPUSH
113947: CALL 49750 0 2
// x := tmp [ j ] ;
113951: LD_ADDR_VAR 0 10
113955: PUSH
113956: LD_VAR 0 14
113960: PUSH
113961: LD_VAR 0 8
113965: ARRAY
113966: ST_TO_ADDR
// attacking := true ;
113967: LD_ADDR_VAR 0 29
113971: PUSH
113972: LD_INT 1
113974: ST_TO_ADDR
// end ; end ;
113975: GO 113901
113977: POP
113978: POP
// if not x then
113979: LD_VAR 0 10
113983: NOT
113984: IFFALSE 114124
// begin attacking := true ;
113986: LD_ADDR_VAR 0 29
113990: PUSH
113991: LD_INT 1
113993: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113994: LD_VAR 0 4
113998: PUSH
113999: LD_VAR 0 7
114003: ARRAY
114004: PPUSH
114005: CALL_OW 250
114009: PPUSH
114010: LD_VAR 0 4
114014: PUSH
114015: LD_VAR 0 7
114019: ARRAY
114020: PPUSH
114021: CALL_OW 251
114025: PPUSH
114026: CALL_OW 546
114030: PUSH
114031: LD_INT 2
114033: ARRAY
114034: PUSH
114035: LD_VAR 0 14
114039: PUSH
114040: LD_INT 1
114042: ARRAY
114043: PPUSH
114044: CALL_OW 250
114048: PPUSH
114049: LD_VAR 0 14
114053: PUSH
114054: LD_INT 1
114056: ARRAY
114057: PPUSH
114058: CALL_OW 251
114062: PPUSH
114063: CALL_OW 546
114067: PUSH
114068: LD_INT 2
114070: ARRAY
114071: EQUAL
114072: IFFALSE 114100
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114074: LD_VAR 0 4
114078: PUSH
114079: LD_VAR 0 7
114083: ARRAY
114084: PPUSH
114085: LD_VAR 0 14
114089: PUSH
114090: LD_INT 1
114092: ARRAY
114093: PPUSH
114094: CALL 49750 0 2
114098: GO 114124
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114100: LD_VAR 0 4
114104: PUSH
114105: LD_VAR 0 7
114109: ARRAY
114110: PPUSH
114111: LD_VAR 0 14
114115: PUSH
114116: LD_INT 1
114118: ARRAY
114119: PPUSH
114120: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114124: LD_VAR 0 4
114128: PUSH
114129: LD_VAR 0 7
114133: ARRAY
114134: PPUSH
114135: CALL_OW 264
114139: PUSH
114140: LD_INT 29
114142: EQUAL
114143: IFFALSE 114509
// begin if WantsToAttack ( group [ i ] ) in bombed then
114145: LD_VAR 0 4
114149: PUSH
114150: LD_VAR 0 7
114154: ARRAY
114155: PPUSH
114156: CALL_OW 319
114160: PUSH
114161: LD_VAR 0 28
114165: IN
114166: IFFALSE 114170
// continue ;
114168: GO 111174
// k := 8 ;
114170: LD_ADDR_VAR 0 9
114174: PUSH
114175: LD_INT 8
114177: ST_TO_ADDR
// x := 0 ;
114178: LD_ADDR_VAR 0 10
114182: PUSH
114183: LD_INT 0
114185: ST_TO_ADDR
// if tmp < k then
114186: LD_VAR 0 14
114190: PUSH
114191: LD_VAR 0 9
114195: LESS
114196: IFFALSE 114208
// k := tmp ;
114198: LD_ADDR_VAR 0 9
114202: PUSH
114203: LD_VAR 0 14
114207: ST_TO_ADDR
// for j = 1 to k do
114208: LD_ADDR_VAR 0 8
114212: PUSH
114213: DOUBLE
114214: LD_INT 1
114216: DEC
114217: ST_TO_ADDR
114218: LD_VAR 0 9
114222: PUSH
114223: FOR_TO
114224: IFFALSE 114356
// begin if GetType ( tmp [ j ] ) = unit_building then
114226: LD_VAR 0 14
114230: PUSH
114231: LD_VAR 0 8
114235: ARRAY
114236: PPUSH
114237: CALL_OW 247
114241: PUSH
114242: LD_INT 3
114244: EQUAL
114245: IFFALSE 114354
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114247: LD_VAR 0 14
114251: PUSH
114252: LD_VAR 0 8
114256: ARRAY
114257: PUSH
114258: LD_VAR 0 28
114262: IN
114263: NOT
114264: PUSH
114265: LD_VAR 0 14
114269: PUSH
114270: LD_VAR 0 8
114274: ARRAY
114275: PPUSH
114276: CALL_OW 313
114280: AND
114281: IFFALSE 114354
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114283: LD_VAR 0 4
114287: PUSH
114288: LD_VAR 0 7
114292: ARRAY
114293: PPUSH
114294: LD_VAR 0 14
114298: PUSH
114299: LD_VAR 0 8
114303: ARRAY
114304: PPUSH
114305: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114309: LD_ADDR_VAR 0 28
114313: PUSH
114314: LD_VAR 0 28
114318: PPUSH
114319: LD_VAR 0 28
114323: PUSH
114324: LD_INT 1
114326: PLUS
114327: PPUSH
114328: LD_VAR 0 14
114332: PUSH
114333: LD_VAR 0 8
114337: ARRAY
114338: PPUSH
114339: CALL_OW 1
114343: ST_TO_ADDR
// attacking := true ;
114344: LD_ADDR_VAR 0 29
114348: PUSH
114349: LD_INT 1
114351: ST_TO_ADDR
// break ;
114352: GO 114356
// end ; end ;
114354: GO 114223
114356: POP
114357: POP
// if not attacking and f_attack_depot then
114358: LD_VAR 0 29
114362: NOT
114363: PUSH
114364: LD_VAR 0 25
114368: AND
114369: IFFALSE 114464
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114371: LD_ADDR_VAR 0 13
114375: PUSH
114376: LD_VAR 0 14
114380: PPUSH
114381: LD_INT 2
114383: PUSH
114384: LD_INT 30
114386: PUSH
114387: LD_INT 0
114389: PUSH
114390: EMPTY
114391: LIST
114392: LIST
114393: PUSH
114394: LD_INT 30
114396: PUSH
114397: LD_INT 1
114399: PUSH
114400: EMPTY
114401: LIST
114402: LIST
114403: PUSH
114404: EMPTY
114405: LIST
114406: LIST
114407: LIST
114408: PPUSH
114409: CALL_OW 72
114413: ST_TO_ADDR
// if z then
114414: LD_VAR 0 13
114418: IFFALSE 114464
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114420: LD_VAR 0 4
114424: PUSH
114425: LD_VAR 0 7
114429: ARRAY
114430: PPUSH
114431: LD_VAR 0 13
114435: PPUSH
114436: LD_VAR 0 4
114440: PUSH
114441: LD_VAR 0 7
114445: ARRAY
114446: PPUSH
114447: CALL_OW 74
114451: PPUSH
114452: CALL_OW 115
// attacking := true ;
114456: LD_ADDR_VAR 0 29
114460: PUSH
114461: LD_INT 1
114463: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114464: LD_VAR 0 4
114468: PUSH
114469: LD_VAR 0 7
114473: ARRAY
114474: PPUSH
114475: CALL_OW 256
114479: PUSH
114480: LD_INT 500
114482: LESS
114483: IFFALSE 114509
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114485: LD_VAR 0 4
114489: PUSH
114490: LD_VAR 0 7
114494: ARRAY
114495: PPUSH
114496: LD_VAR 0 14
114500: PUSH
114501: LD_INT 1
114503: ARRAY
114504: PPUSH
114505: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114509: LD_VAR 0 4
114513: PUSH
114514: LD_VAR 0 7
114518: ARRAY
114519: PPUSH
114520: CALL_OW 264
114524: PUSH
114525: LD_INT 49
114527: EQUAL
114528: IFFALSE 114649
// begin if not HasTask ( group [ i ] ) then
114530: LD_VAR 0 4
114534: PUSH
114535: LD_VAR 0 7
114539: ARRAY
114540: PPUSH
114541: CALL_OW 314
114545: NOT
114546: IFFALSE 114649
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114548: LD_ADDR_VAR 0 9
114552: PUSH
114553: LD_INT 81
114555: PUSH
114556: LD_VAR 0 4
114560: PUSH
114561: LD_VAR 0 7
114565: ARRAY
114566: PPUSH
114567: CALL_OW 255
114571: PUSH
114572: EMPTY
114573: LIST
114574: LIST
114575: PPUSH
114576: CALL_OW 69
114580: PPUSH
114581: LD_VAR 0 4
114585: PUSH
114586: LD_VAR 0 7
114590: ARRAY
114591: PPUSH
114592: CALL_OW 74
114596: ST_TO_ADDR
// if k then
114597: LD_VAR 0 9
114601: IFFALSE 114649
// if GetDistUnits ( group [ i ] , k ) > 10 then
114603: LD_VAR 0 4
114607: PUSH
114608: LD_VAR 0 7
114612: ARRAY
114613: PPUSH
114614: LD_VAR 0 9
114618: PPUSH
114619: CALL_OW 296
114623: PUSH
114624: LD_INT 10
114626: GREATER
114627: IFFALSE 114649
// ComMoveUnit ( group [ i ] , k ) ;
114629: LD_VAR 0 4
114633: PUSH
114634: LD_VAR 0 7
114638: ARRAY
114639: PPUSH
114640: LD_VAR 0 9
114644: PPUSH
114645: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114649: LD_VAR 0 4
114653: PUSH
114654: LD_VAR 0 7
114658: ARRAY
114659: PPUSH
114660: CALL_OW 256
114664: PUSH
114665: LD_INT 250
114667: LESS
114668: PUSH
114669: LD_VAR 0 4
114673: PUSH
114674: LD_VAR 0 7
114678: ARRAY
114679: PUSH
114680: LD_INT 21
114682: PUSH
114683: LD_INT 2
114685: PUSH
114686: EMPTY
114687: LIST
114688: LIST
114689: PUSH
114690: LD_INT 23
114692: PUSH
114693: LD_INT 2
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: PUSH
114700: EMPTY
114701: LIST
114702: LIST
114703: PPUSH
114704: CALL_OW 69
114708: IN
114709: AND
114710: IFFALSE 114835
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114712: LD_ADDR_VAR 0 9
114716: PUSH
114717: LD_OWVAR 3
114721: PUSH
114722: LD_VAR 0 4
114726: PUSH
114727: LD_VAR 0 7
114731: ARRAY
114732: DIFF
114733: PPUSH
114734: LD_VAR 0 4
114738: PUSH
114739: LD_VAR 0 7
114743: ARRAY
114744: PPUSH
114745: CALL_OW 74
114749: ST_TO_ADDR
// if not k then
114750: LD_VAR 0 9
114754: NOT
114755: IFFALSE 114759
// continue ;
114757: GO 111174
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114759: LD_VAR 0 9
114763: PUSH
114764: LD_INT 81
114766: PUSH
114767: LD_VAR 0 4
114771: PUSH
114772: LD_VAR 0 7
114776: ARRAY
114777: PPUSH
114778: CALL_OW 255
114782: PUSH
114783: EMPTY
114784: LIST
114785: LIST
114786: PPUSH
114787: CALL_OW 69
114791: IN
114792: PUSH
114793: LD_VAR 0 9
114797: PPUSH
114798: LD_VAR 0 4
114802: PUSH
114803: LD_VAR 0 7
114807: ARRAY
114808: PPUSH
114809: CALL_OW 296
114813: PUSH
114814: LD_INT 5
114816: LESS
114817: AND
114818: IFFALSE 114835
// ComAutodestruct ( group [ i ] ) ;
114820: LD_VAR 0 4
114824: PUSH
114825: LD_VAR 0 7
114829: ARRAY
114830: PPUSH
114831: CALL 49648 0 1
// end ; if f_attack_depot then
114835: LD_VAR 0 25
114839: IFFALSE 114951
// begin k := 6 ;
114841: LD_ADDR_VAR 0 9
114845: PUSH
114846: LD_INT 6
114848: ST_TO_ADDR
// if tmp < k then
114849: LD_VAR 0 14
114853: PUSH
114854: LD_VAR 0 9
114858: LESS
114859: IFFALSE 114871
// k := tmp ;
114861: LD_ADDR_VAR 0 9
114865: PUSH
114866: LD_VAR 0 14
114870: ST_TO_ADDR
// for j = 1 to k do
114871: LD_ADDR_VAR 0 8
114875: PUSH
114876: DOUBLE
114877: LD_INT 1
114879: DEC
114880: ST_TO_ADDR
114881: LD_VAR 0 9
114885: PUSH
114886: FOR_TO
114887: IFFALSE 114949
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114889: LD_VAR 0 8
114893: PPUSH
114894: CALL_OW 266
114898: PUSH
114899: LD_INT 0
114901: PUSH
114902: LD_INT 1
114904: PUSH
114905: EMPTY
114906: LIST
114907: LIST
114908: IN
114909: IFFALSE 114947
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114911: LD_VAR 0 4
114915: PUSH
114916: LD_VAR 0 7
114920: ARRAY
114921: PPUSH
114922: LD_VAR 0 14
114926: PUSH
114927: LD_VAR 0 8
114931: ARRAY
114932: PPUSH
114933: CALL_OW 115
// attacking := true ;
114937: LD_ADDR_VAR 0 29
114941: PUSH
114942: LD_INT 1
114944: ST_TO_ADDR
// break ;
114945: GO 114949
// end ;
114947: GO 114886
114949: POP
114950: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114951: LD_VAR 0 4
114955: PUSH
114956: LD_VAR 0 7
114960: ARRAY
114961: PPUSH
114962: CALL_OW 302
114966: PUSH
114967: LD_VAR 0 29
114971: NOT
114972: AND
114973: IFFALSE 115295
// begin if GetTag ( group [ i ] ) = 71 then
114975: LD_VAR 0 4
114979: PUSH
114980: LD_VAR 0 7
114984: ARRAY
114985: PPUSH
114986: CALL_OW 110
114990: PUSH
114991: LD_INT 71
114993: EQUAL
114994: IFFALSE 115035
// begin if HasTask ( group [ i ] ) then
114996: LD_VAR 0 4
115000: PUSH
115001: LD_VAR 0 7
115005: ARRAY
115006: PPUSH
115007: CALL_OW 314
115011: IFFALSE 115017
// continue else
115013: GO 111174
115015: GO 115035
// SetTag ( group [ i ] , 0 ) ;
115017: LD_VAR 0 4
115021: PUSH
115022: LD_VAR 0 7
115026: ARRAY
115027: PPUSH
115028: LD_INT 0
115030: PPUSH
115031: CALL_OW 109
// end ; k := 8 ;
115035: LD_ADDR_VAR 0 9
115039: PUSH
115040: LD_INT 8
115042: ST_TO_ADDR
// x := 0 ;
115043: LD_ADDR_VAR 0 10
115047: PUSH
115048: LD_INT 0
115050: ST_TO_ADDR
// if tmp < k then
115051: LD_VAR 0 14
115055: PUSH
115056: LD_VAR 0 9
115060: LESS
115061: IFFALSE 115073
// k := tmp ;
115063: LD_ADDR_VAR 0 9
115067: PUSH
115068: LD_VAR 0 14
115072: ST_TO_ADDR
// for j = 1 to k do
115073: LD_ADDR_VAR 0 8
115077: PUSH
115078: DOUBLE
115079: LD_INT 1
115081: DEC
115082: ST_TO_ADDR
115083: LD_VAR 0 9
115087: PUSH
115088: FOR_TO
115089: IFFALSE 115187
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115091: LD_VAR 0 14
115095: PUSH
115096: LD_VAR 0 8
115100: ARRAY
115101: PPUSH
115102: CALL_OW 247
115106: PUSH
115107: LD_INT 1
115109: EQUAL
115110: PUSH
115111: LD_VAR 0 14
115115: PUSH
115116: LD_VAR 0 8
115120: ARRAY
115121: PPUSH
115122: CALL_OW 256
115126: PUSH
115127: LD_INT 250
115129: LESS
115130: PUSH
115131: LD_VAR 0 20
115135: AND
115136: PUSH
115137: LD_VAR 0 20
115141: NOT
115142: PUSH
115143: LD_VAR 0 14
115147: PUSH
115148: LD_VAR 0 8
115152: ARRAY
115153: PPUSH
115154: CALL_OW 256
115158: PUSH
115159: LD_INT 250
115161: GREATEREQUAL
115162: AND
115163: OR
115164: AND
115165: IFFALSE 115185
// begin x := tmp [ j ] ;
115167: LD_ADDR_VAR 0 10
115171: PUSH
115172: LD_VAR 0 14
115176: PUSH
115177: LD_VAR 0 8
115181: ARRAY
115182: ST_TO_ADDR
// break ;
115183: GO 115187
// end ;
115185: GO 115088
115187: POP
115188: POP
// if x then
115189: LD_VAR 0 10
115193: IFFALSE 115217
// ComAttackUnit ( group [ i ] , x ) else
115195: LD_VAR 0 4
115199: PUSH
115200: LD_VAR 0 7
115204: ARRAY
115205: PPUSH
115206: LD_VAR 0 10
115210: PPUSH
115211: CALL_OW 115
115215: GO 115241
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115217: LD_VAR 0 4
115221: PUSH
115222: LD_VAR 0 7
115226: ARRAY
115227: PPUSH
115228: LD_VAR 0 14
115232: PUSH
115233: LD_INT 1
115235: ARRAY
115236: PPUSH
115237: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115241: LD_VAR 0 4
115245: PUSH
115246: LD_VAR 0 7
115250: ARRAY
115251: PPUSH
115252: CALL_OW 314
115256: NOT
115257: IFFALSE 115295
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115259: LD_VAR 0 4
115263: PUSH
115264: LD_VAR 0 7
115268: ARRAY
115269: PPUSH
115270: LD_VAR 0 14
115274: PPUSH
115275: LD_VAR 0 4
115279: PUSH
115280: LD_VAR 0 7
115284: ARRAY
115285: PPUSH
115286: CALL_OW 74
115290: PPUSH
115291: CALL_OW 115
// end ; end ; end ;
115295: GO 111174
115297: POP
115298: POP
// wait ( 0 0$2 ) ;
115299: LD_INT 70
115301: PPUSH
115302: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115306: LD_VAR 0 4
115310: NOT
115311: PUSH
115312: LD_VAR 0 4
115316: PUSH
115317: EMPTY
115318: EQUAL
115319: OR
115320: PUSH
115321: LD_INT 81
115323: PUSH
115324: LD_VAR 0 35
115328: PUSH
115329: EMPTY
115330: LIST
115331: LIST
115332: PPUSH
115333: CALL_OW 69
115337: NOT
115338: OR
115339: IFFALSE 111159
// end ;
115341: LD_VAR 0 2
115345: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115346: LD_INT 0
115348: PPUSH
115349: PPUSH
115350: PPUSH
115351: PPUSH
115352: PPUSH
115353: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115354: LD_VAR 0 1
115358: NOT
115359: PUSH
115360: LD_EXP 61
115364: PUSH
115365: LD_VAR 0 1
115369: ARRAY
115370: NOT
115371: OR
115372: PUSH
115373: LD_VAR 0 2
115377: NOT
115378: OR
115379: IFFALSE 115383
// exit ;
115381: GO 115937
// side := mc_sides [ base ] ;
115383: LD_ADDR_VAR 0 6
115387: PUSH
115388: LD_EXP 87
115392: PUSH
115393: LD_VAR 0 1
115397: ARRAY
115398: ST_TO_ADDR
// if not side then
115399: LD_VAR 0 6
115403: NOT
115404: IFFALSE 115408
// exit ;
115406: GO 115937
// for i in solds do
115408: LD_ADDR_VAR 0 7
115412: PUSH
115413: LD_VAR 0 2
115417: PUSH
115418: FOR_IN
115419: IFFALSE 115480
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115421: LD_VAR 0 7
115425: PPUSH
115426: CALL_OW 310
115430: PPUSH
115431: CALL_OW 266
115435: PUSH
115436: LD_INT 32
115438: PUSH
115439: LD_INT 31
115441: PUSH
115442: EMPTY
115443: LIST
115444: LIST
115445: IN
115446: IFFALSE 115466
// solds := solds diff i else
115448: LD_ADDR_VAR 0 2
115452: PUSH
115453: LD_VAR 0 2
115457: PUSH
115458: LD_VAR 0 7
115462: DIFF
115463: ST_TO_ADDR
115464: GO 115478
// SetTag ( i , 18 ) ;
115466: LD_VAR 0 7
115470: PPUSH
115471: LD_INT 18
115473: PPUSH
115474: CALL_OW 109
115478: GO 115418
115480: POP
115481: POP
// if not solds then
115482: LD_VAR 0 2
115486: NOT
115487: IFFALSE 115491
// exit ;
115489: GO 115937
// repeat wait ( 0 0$2 ) ;
115491: LD_INT 70
115493: PPUSH
115494: CALL_OW 67
// enemy := mc_scan [ base ] ;
115498: LD_ADDR_VAR 0 4
115502: PUSH
115503: LD_EXP 84
115507: PUSH
115508: LD_VAR 0 1
115512: ARRAY
115513: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115514: LD_EXP 61
115518: PUSH
115519: LD_VAR 0 1
115523: ARRAY
115524: NOT
115525: PUSH
115526: LD_EXP 61
115530: PUSH
115531: LD_VAR 0 1
115535: ARRAY
115536: PUSH
115537: EMPTY
115538: EQUAL
115539: OR
115540: IFFALSE 115577
// begin for i in solds do
115542: LD_ADDR_VAR 0 7
115546: PUSH
115547: LD_VAR 0 2
115551: PUSH
115552: FOR_IN
115553: IFFALSE 115566
// ComStop ( i ) ;
115555: LD_VAR 0 7
115559: PPUSH
115560: CALL_OW 141
115564: GO 115552
115566: POP
115567: POP
// solds := [ ] ;
115568: LD_ADDR_VAR 0 2
115572: PUSH
115573: EMPTY
115574: ST_TO_ADDR
// exit ;
115575: GO 115937
// end ; for i in solds do
115577: LD_ADDR_VAR 0 7
115581: PUSH
115582: LD_VAR 0 2
115586: PUSH
115587: FOR_IN
115588: IFFALSE 115909
// begin if IsInUnit ( i ) then
115590: LD_VAR 0 7
115594: PPUSH
115595: CALL_OW 310
115599: IFFALSE 115610
// ComExitBuilding ( i ) ;
115601: LD_VAR 0 7
115605: PPUSH
115606: CALL_OW 122
// if GetLives ( i ) > 500 then
115610: LD_VAR 0 7
115614: PPUSH
115615: CALL_OW 256
115619: PUSH
115620: LD_INT 500
115622: GREATER
115623: IFFALSE 115676
// begin e := NearestUnitToUnit ( enemy , i ) ;
115625: LD_ADDR_VAR 0 5
115629: PUSH
115630: LD_VAR 0 4
115634: PPUSH
115635: LD_VAR 0 7
115639: PPUSH
115640: CALL_OW 74
115644: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115645: LD_VAR 0 7
115649: PPUSH
115650: LD_VAR 0 5
115654: PPUSH
115655: CALL_OW 250
115659: PPUSH
115660: LD_VAR 0 5
115664: PPUSH
115665: CALL_OW 251
115669: PPUSH
115670: CALL_OW 114
// end else
115674: GO 115907
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115676: LD_VAR 0 7
115680: PPUSH
115681: LD_EXP 61
115685: PUSH
115686: LD_VAR 0 1
115690: ARRAY
115691: PPUSH
115692: LD_INT 2
115694: PUSH
115695: LD_INT 30
115697: PUSH
115698: LD_INT 0
115700: PUSH
115701: EMPTY
115702: LIST
115703: LIST
115704: PUSH
115705: LD_INT 30
115707: PUSH
115708: LD_INT 1
115710: PUSH
115711: EMPTY
115712: LIST
115713: LIST
115714: PUSH
115715: LD_INT 30
115717: PUSH
115718: LD_INT 6
115720: PUSH
115721: EMPTY
115722: LIST
115723: LIST
115724: PUSH
115725: EMPTY
115726: LIST
115727: LIST
115728: LIST
115729: LIST
115730: PPUSH
115731: CALL_OW 72
115735: PPUSH
115736: LD_VAR 0 7
115740: PPUSH
115741: CALL_OW 74
115745: PPUSH
115746: CALL_OW 296
115750: PUSH
115751: LD_INT 10
115753: GREATER
115754: IFFALSE 115907
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115756: LD_ADDR_VAR 0 8
115760: PUSH
115761: LD_EXP 61
115765: PUSH
115766: LD_VAR 0 1
115770: ARRAY
115771: PPUSH
115772: LD_INT 2
115774: PUSH
115775: LD_INT 30
115777: PUSH
115778: LD_INT 0
115780: PUSH
115781: EMPTY
115782: LIST
115783: LIST
115784: PUSH
115785: LD_INT 30
115787: PUSH
115788: LD_INT 1
115790: PUSH
115791: EMPTY
115792: LIST
115793: LIST
115794: PUSH
115795: LD_INT 30
115797: PUSH
115798: LD_INT 6
115800: PUSH
115801: EMPTY
115802: LIST
115803: LIST
115804: PUSH
115805: EMPTY
115806: LIST
115807: LIST
115808: LIST
115809: LIST
115810: PPUSH
115811: CALL_OW 72
115815: PPUSH
115816: LD_VAR 0 7
115820: PPUSH
115821: CALL_OW 74
115825: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115826: LD_VAR 0 7
115830: PPUSH
115831: LD_VAR 0 8
115835: PPUSH
115836: CALL_OW 250
115840: PPUSH
115841: LD_INT 3
115843: PPUSH
115844: LD_INT 5
115846: PPUSH
115847: CALL_OW 272
115851: PPUSH
115852: LD_VAR 0 8
115856: PPUSH
115857: CALL_OW 251
115861: PPUSH
115862: LD_INT 3
115864: PPUSH
115865: LD_INT 5
115867: PPUSH
115868: CALL_OW 273
115872: PPUSH
115873: CALL_OW 111
// SetTag ( i , 0 ) ;
115877: LD_VAR 0 7
115881: PPUSH
115882: LD_INT 0
115884: PPUSH
115885: CALL_OW 109
// solds := solds diff i ;
115889: LD_ADDR_VAR 0 2
115893: PUSH
115894: LD_VAR 0 2
115898: PUSH
115899: LD_VAR 0 7
115903: DIFF
115904: ST_TO_ADDR
// continue ;
115905: GO 115587
// end ; end ;
115907: GO 115587
115909: POP
115910: POP
// until not solds or not enemy ;
115911: LD_VAR 0 2
115915: NOT
115916: PUSH
115917: LD_VAR 0 4
115921: NOT
115922: OR
115923: IFFALSE 115491
// MC_Reset ( base , 18 ) ;
115925: LD_VAR 0 1
115929: PPUSH
115930: LD_INT 18
115932: PPUSH
115933: CALL 63385 0 2
// end ;
115937: LD_VAR 0 3
115941: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115942: LD_INT 0
115944: PPUSH
115945: PPUSH
115946: PPUSH
115947: PPUSH
115948: PPUSH
115949: PPUSH
115950: PPUSH
115951: PPUSH
115952: PPUSH
115953: PPUSH
115954: PPUSH
115955: PPUSH
115956: PPUSH
115957: PPUSH
115958: PPUSH
115959: PPUSH
115960: PPUSH
115961: PPUSH
115962: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115963: LD_ADDR_VAR 0 12
115967: PUSH
115968: LD_EXP 61
115972: PUSH
115973: LD_VAR 0 1
115977: ARRAY
115978: PPUSH
115979: LD_INT 25
115981: PUSH
115982: LD_INT 3
115984: PUSH
115985: EMPTY
115986: LIST
115987: LIST
115988: PPUSH
115989: CALL_OW 72
115993: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115994: LD_EXP 101
115998: PUSH
115999: LD_VAR 0 1
116003: ARRAY
116004: IFFALSE 116028
// mechs := mechs diff mc_remote_driver [ base ] ;
116006: LD_ADDR_VAR 0 12
116010: PUSH
116011: LD_VAR 0 12
116015: PUSH
116016: LD_EXP 101
116020: PUSH
116021: LD_VAR 0 1
116025: ARRAY
116026: DIFF
116027: ST_TO_ADDR
// for i in mechs do
116028: LD_ADDR_VAR 0 4
116032: PUSH
116033: LD_VAR 0 12
116037: PUSH
116038: FOR_IN
116039: IFFALSE 116074
// if GetTag ( i ) > 0 then
116041: LD_VAR 0 4
116045: PPUSH
116046: CALL_OW 110
116050: PUSH
116051: LD_INT 0
116053: GREATER
116054: IFFALSE 116072
// mechs := mechs diff i ;
116056: LD_ADDR_VAR 0 12
116060: PUSH
116061: LD_VAR 0 12
116065: PUSH
116066: LD_VAR 0 4
116070: DIFF
116071: ST_TO_ADDR
116072: GO 116038
116074: POP
116075: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116076: LD_ADDR_VAR 0 8
116080: PUSH
116081: LD_EXP 61
116085: PUSH
116086: LD_VAR 0 1
116090: ARRAY
116091: PPUSH
116092: LD_INT 2
116094: PUSH
116095: LD_INT 25
116097: PUSH
116098: LD_INT 1
116100: PUSH
116101: EMPTY
116102: LIST
116103: LIST
116104: PUSH
116105: LD_INT 25
116107: PUSH
116108: LD_INT 5
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PUSH
116115: LD_INT 25
116117: PUSH
116118: LD_INT 8
116120: PUSH
116121: EMPTY
116122: LIST
116123: LIST
116124: PUSH
116125: LD_INT 25
116127: PUSH
116128: LD_INT 9
116130: PUSH
116131: EMPTY
116132: LIST
116133: LIST
116134: PUSH
116135: EMPTY
116136: LIST
116137: LIST
116138: LIST
116139: LIST
116140: LIST
116141: PPUSH
116142: CALL_OW 72
116146: ST_TO_ADDR
// if not defenders and not solds then
116147: LD_VAR 0 2
116151: NOT
116152: PUSH
116153: LD_VAR 0 8
116157: NOT
116158: AND
116159: IFFALSE 116163
// exit ;
116161: GO 117933
// depot_under_attack := false ;
116163: LD_ADDR_VAR 0 16
116167: PUSH
116168: LD_INT 0
116170: ST_TO_ADDR
// sold_defenders := [ ] ;
116171: LD_ADDR_VAR 0 17
116175: PUSH
116176: EMPTY
116177: ST_TO_ADDR
// if mechs then
116178: LD_VAR 0 12
116182: IFFALSE 116335
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116184: LD_ADDR_VAR 0 4
116188: PUSH
116189: LD_VAR 0 2
116193: PPUSH
116194: LD_INT 21
116196: PUSH
116197: LD_INT 2
116199: PUSH
116200: EMPTY
116201: LIST
116202: LIST
116203: PPUSH
116204: CALL_OW 72
116208: PUSH
116209: FOR_IN
116210: IFFALSE 116333
// begin if GetTag ( i ) <> 20 then
116212: LD_VAR 0 4
116216: PPUSH
116217: CALL_OW 110
116221: PUSH
116222: LD_INT 20
116224: NONEQUAL
116225: IFFALSE 116239
// SetTag ( i , 20 ) ;
116227: LD_VAR 0 4
116231: PPUSH
116232: LD_INT 20
116234: PPUSH
116235: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116239: LD_VAR 0 4
116243: PPUSH
116244: CALL_OW 263
116248: PUSH
116249: LD_INT 1
116251: EQUAL
116252: PUSH
116253: LD_VAR 0 4
116257: PPUSH
116258: CALL_OW 311
116262: NOT
116263: AND
116264: IFFALSE 116331
// begin un := mechs [ 1 ] ;
116266: LD_ADDR_VAR 0 10
116270: PUSH
116271: LD_VAR 0 12
116275: PUSH
116276: LD_INT 1
116278: ARRAY
116279: ST_TO_ADDR
// ComExit ( un ) ;
116280: LD_VAR 0 10
116284: PPUSH
116285: CALL 54534 0 1
// AddComEnterUnit ( un , i ) ;
116289: LD_VAR 0 10
116293: PPUSH
116294: LD_VAR 0 4
116298: PPUSH
116299: CALL_OW 180
// SetTag ( un , 19 ) ;
116303: LD_VAR 0 10
116307: PPUSH
116308: LD_INT 19
116310: PPUSH
116311: CALL_OW 109
// mechs := mechs diff un ;
116315: LD_ADDR_VAR 0 12
116319: PUSH
116320: LD_VAR 0 12
116324: PUSH
116325: LD_VAR 0 10
116329: DIFF
116330: ST_TO_ADDR
// end ; end ;
116331: GO 116209
116333: POP
116334: POP
// if solds then
116335: LD_VAR 0 8
116339: IFFALSE 116398
// for i in solds do
116341: LD_ADDR_VAR 0 4
116345: PUSH
116346: LD_VAR 0 8
116350: PUSH
116351: FOR_IN
116352: IFFALSE 116396
// if not GetTag ( i ) then
116354: LD_VAR 0 4
116358: PPUSH
116359: CALL_OW 110
116363: NOT
116364: IFFALSE 116394
// begin defenders := defenders union i ;
116366: LD_ADDR_VAR 0 2
116370: PUSH
116371: LD_VAR 0 2
116375: PUSH
116376: LD_VAR 0 4
116380: UNION
116381: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116382: LD_VAR 0 4
116386: PPUSH
116387: LD_INT 18
116389: PPUSH
116390: CALL_OW 109
// end ;
116394: GO 116351
116396: POP
116397: POP
// repeat wait ( 0 0$2 ) ;
116398: LD_INT 70
116400: PPUSH
116401: CALL_OW 67
// enemy := mc_scan [ base ] ;
116405: LD_ADDR_VAR 0 21
116409: PUSH
116410: LD_EXP 84
116414: PUSH
116415: LD_VAR 0 1
116419: ARRAY
116420: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116421: LD_EXP 61
116425: PUSH
116426: LD_VAR 0 1
116430: ARRAY
116431: NOT
116432: PUSH
116433: LD_EXP 61
116437: PUSH
116438: LD_VAR 0 1
116442: ARRAY
116443: PUSH
116444: EMPTY
116445: EQUAL
116446: OR
116447: IFFALSE 116484
// begin for i in defenders do
116449: LD_ADDR_VAR 0 4
116453: PUSH
116454: LD_VAR 0 2
116458: PUSH
116459: FOR_IN
116460: IFFALSE 116473
// ComStop ( i ) ;
116462: LD_VAR 0 4
116466: PPUSH
116467: CALL_OW 141
116471: GO 116459
116473: POP
116474: POP
// defenders := [ ] ;
116475: LD_ADDR_VAR 0 2
116479: PUSH
116480: EMPTY
116481: ST_TO_ADDR
// exit ;
116482: GO 117933
// end ; for i in defenders do
116484: LD_ADDR_VAR 0 4
116488: PUSH
116489: LD_VAR 0 2
116493: PUSH
116494: FOR_IN
116495: IFFALSE 117393
// begin e := NearestUnitToUnit ( enemy , i ) ;
116497: LD_ADDR_VAR 0 13
116501: PUSH
116502: LD_VAR 0 21
116506: PPUSH
116507: LD_VAR 0 4
116511: PPUSH
116512: CALL_OW 74
116516: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116517: LD_ADDR_VAR 0 7
116521: PUSH
116522: LD_EXP 61
116526: PUSH
116527: LD_VAR 0 1
116531: ARRAY
116532: PPUSH
116533: LD_INT 2
116535: PUSH
116536: LD_INT 30
116538: PUSH
116539: LD_INT 0
116541: PUSH
116542: EMPTY
116543: LIST
116544: LIST
116545: PUSH
116546: LD_INT 30
116548: PUSH
116549: LD_INT 1
116551: PUSH
116552: EMPTY
116553: LIST
116554: LIST
116555: PUSH
116556: EMPTY
116557: LIST
116558: LIST
116559: LIST
116560: PPUSH
116561: CALL_OW 72
116565: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116566: LD_ADDR_VAR 0 16
116570: PUSH
116571: LD_VAR 0 7
116575: NOT
116576: PUSH
116577: LD_VAR 0 7
116581: PPUSH
116582: LD_INT 3
116584: PUSH
116585: LD_INT 24
116587: PUSH
116588: LD_INT 600
116590: PUSH
116591: EMPTY
116592: LIST
116593: LIST
116594: PUSH
116595: EMPTY
116596: LIST
116597: LIST
116598: PPUSH
116599: CALL_OW 72
116603: OR
116604: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116605: LD_VAR 0 4
116609: PPUSH
116610: CALL_OW 247
116614: PUSH
116615: LD_INT 2
116617: DOUBLE
116618: EQUAL
116619: IFTRUE 116623
116621: GO 117019
116623: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116624: LD_VAR 0 4
116628: PPUSH
116629: CALL_OW 256
116633: PUSH
116634: LD_INT 1000
116636: EQUAL
116637: PUSH
116638: LD_VAR 0 4
116642: PPUSH
116643: LD_VAR 0 13
116647: PPUSH
116648: CALL_OW 296
116652: PUSH
116653: LD_INT 40
116655: LESS
116656: PUSH
116657: LD_VAR 0 13
116661: PPUSH
116662: LD_EXP 86
116666: PUSH
116667: LD_VAR 0 1
116671: ARRAY
116672: PPUSH
116673: CALL_OW 308
116677: OR
116678: AND
116679: IFFALSE 116801
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116681: LD_VAR 0 4
116685: PPUSH
116686: CALL_OW 262
116690: PUSH
116691: LD_INT 1
116693: EQUAL
116694: PUSH
116695: LD_VAR 0 4
116699: PPUSH
116700: CALL_OW 261
116704: PUSH
116705: LD_INT 30
116707: LESS
116708: AND
116709: PUSH
116710: LD_VAR 0 7
116714: AND
116715: IFFALSE 116785
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116717: LD_VAR 0 4
116721: PPUSH
116722: LD_VAR 0 7
116726: PPUSH
116727: LD_VAR 0 4
116731: PPUSH
116732: CALL_OW 74
116736: PPUSH
116737: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116741: LD_VAR 0 4
116745: PPUSH
116746: LD_VAR 0 7
116750: PPUSH
116751: LD_VAR 0 4
116755: PPUSH
116756: CALL_OW 74
116760: PPUSH
116761: CALL_OW 296
116765: PUSH
116766: LD_INT 6
116768: LESS
116769: IFFALSE 116783
// SetFuel ( i , 100 ) ;
116771: LD_VAR 0 4
116775: PPUSH
116776: LD_INT 100
116778: PPUSH
116779: CALL_OW 240
// end else
116783: GO 116799
// ComAttackUnit ( i , e ) ;
116785: LD_VAR 0 4
116789: PPUSH
116790: LD_VAR 0 13
116794: PPUSH
116795: CALL_OW 115
// end else
116799: GO 116902
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116801: LD_VAR 0 13
116805: PPUSH
116806: LD_EXP 86
116810: PUSH
116811: LD_VAR 0 1
116815: ARRAY
116816: PPUSH
116817: CALL_OW 308
116821: NOT
116822: PUSH
116823: LD_VAR 0 4
116827: PPUSH
116828: LD_VAR 0 13
116832: PPUSH
116833: CALL_OW 296
116837: PUSH
116838: LD_INT 40
116840: GREATEREQUAL
116841: AND
116842: PUSH
116843: LD_VAR 0 4
116847: PPUSH
116848: CALL_OW 256
116852: PUSH
116853: LD_INT 650
116855: LESSEQUAL
116856: OR
116857: PUSH
116858: LD_VAR 0 4
116862: PPUSH
116863: LD_EXP 85
116867: PUSH
116868: LD_VAR 0 1
116872: ARRAY
116873: PPUSH
116874: CALL_OW 308
116878: NOT
116879: AND
116880: IFFALSE 116902
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116882: LD_VAR 0 4
116886: PPUSH
116887: LD_EXP 85
116891: PUSH
116892: LD_VAR 0 1
116896: ARRAY
116897: PPUSH
116898: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116902: LD_VAR 0 4
116906: PPUSH
116907: CALL_OW 256
116911: PUSH
116912: LD_INT 1000
116914: LESS
116915: PUSH
116916: LD_VAR 0 4
116920: PPUSH
116921: CALL_OW 263
116925: PUSH
116926: LD_INT 1
116928: EQUAL
116929: AND
116930: PUSH
116931: LD_VAR 0 4
116935: PPUSH
116936: CALL_OW 311
116940: AND
116941: PUSH
116942: LD_VAR 0 4
116946: PPUSH
116947: LD_EXP 85
116951: PUSH
116952: LD_VAR 0 1
116956: ARRAY
116957: PPUSH
116958: CALL_OW 308
116962: AND
116963: IFFALSE 117017
// begin mech := IsDrivenBy ( i ) ;
116965: LD_ADDR_VAR 0 9
116969: PUSH
116970: LD_VAR 0 4
116974: PPUSH
116975: CALL_OW 311
116979: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116980: LD_VAR 0 9
116984: PPUSH
116985: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116989: LD_VAR 0 9
116993: PPUSH
116994: LD_VAR 0 4
116998: PPUSH
116999: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117003: LD_VAR 0 9
117007: PPUSH
117008: LD_VAR 0 4
117012: PPUSH
117013: CALL_OW 180
// end ; end ; unit_human :
117017: GO 117364
117019: LD_INT 1
117021: DOUBLE
117022: EQUAL
117023: IFTRUE 117027
117025: GO 117363
117027: POP
// begin b := IsInUnit ( i ) ;
117028: LD_ADDR_VAR 0 18
117032: PUSH
117033: LD_VAR 0 4
117037: PPUSH
117038: CALL_OW 310
117042: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117043: LD_ADDR_VAR 0 19
117047: PUSH
117048: LD_VAR 0 18
117052: NOT
117053: PUSH
117054: LD_VAR 0 18
117058: PPUSH
117059: CALL_OW 266
117063: PUSH
117064: LD_INT 32
117066: PUSH
117067: LD_INT 31
117069: PUSH
117070: EMPTY
117071: LIST
117072: LIST
117073: IN
117074: OR
117075: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117076: LD_VAR 0 18
117080: PPUSH
117081: CALL_OW 266
117085: PUSH
117086: LD_INT 5
117088: EQUAL
117089: PUSH
117090: LD_VAR 0 4
117094: PPUSH
117095: CALL_OW 257
117099: PUSH
117100: LD_INT 1
117102: PUSH
117103: LD_INT 2
117105: PUSH
117106: LD_INT 3
117108: PUSH
117109: LD_INT 4
117111: PUSH
117112: EMPTY
117113: LIST
117114: LIST
117115: LIST
117116: LIST
117117: IN
117118: AND
117119: IFFALSE 117156
// begin class := AllowSpecClass ( i ) ;
117121: LD_ADDR_VAR 0 20
117125: PUSH
117126: LD_VAR 0 4
117130: PPUSH
117131: CALL 18231 0 1
117135: ST_TO_ADDR
// if class then
117136: LD_VAR 0 20
117140: IFFALSE 117156
// ComChangeProfession ( i , class ) ;
117142: LD_VAR 0 4
117146: PPUSH
117147: LD_VAR 0 20
117151: PPUSH
117152: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117156: LD_VAR 0 16
117160: PUSH
117161: LD_VAR 0 2
117165: PPUSH
117166: LD_INT 21
117168: PUSH
117169: LD_INT 2
117171: PUSH
117172: EMPTY
117173: LIST
117174: LIST
117175: PPUSH
117176: CALL_OW 72
117180: PUSH
117181: LD_INT 1
117183: LESSEQUAL
117184: OR
117185: PUSH
117186: LD_VAR 0 19
117190: AND
117191: PUSH
117192: LD_VAR 0 4
117196: PUSH
117197: LD_VAR 0 17
117201: IN
117202: NOT
117203: AND
117204: IFFALSE 117297
// begin if b then
117206: LD_VAR 0 18
117210: IFFALSE 117259
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117212: LD_VAR 0 18
117216: PPUSH
117217: LD_VAR 0 21
117221: PPUSH
117222: LD_VAR 0 18
117226: PPUSH
117227: CALL_OW 74
117231: PPUSH
117232: CALL_OW 296
117236: PUSH
117237: LD_INT 10
117239: LESS
117240: PUSH
117241: LD_VAR 0 18
117245: PPUSH
117246: CALL_OW 461
117250: PUSH
117251: LD_INT 7
117253: NONEQUAL
117254: AND
117255: IFFALSE 117259
// continue ;
117257: GO 116494
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117259: LD_ADDR_VAR 0 17
117263: PUSH
117264: LD_VAR 0 17
117268: PPUSH
117269: LD_VAR 0 17
117273: PUSH
117274: LD_INT 1
117276: PLUS
117277: PPUSH
117278: LD_VAR 0 4
117282: PPUSH
117283: CALL_OW 1
117287: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117288: LD_VAR 0 4
117292: PPUSH
117293: CALL_OW 122
// end ; if sold_defenders then
117297: LD_VAR 0 17
117301: IFFALSE 117361
// if i in sold_defenders then
117303: LD_VAR 0 4
117307: PUSH
117308: LD_VAR 0 17
117312: IN
117313: IFFALSE 117361
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117315: LD_VAR 0 4
117319: PPUSH
117320: CALL_OW 314
117324: NOT
117325: PUSH
117326: LD_VAR 0 4
117330: PPUSH
117331: LD_VAR 0 13
117335: PPUSH
117336: CALL_OW 296
117340: PUSH
117341: LD_INT 30
117343: LESS
117344: AND
117345: IFFALSE 117361
// ComAttackUnit ( i , e ) ;
117347: LD_VAR 0 4
117351: PPUSH
117352: LD_VAR 0 13
117356: PPUSH
117357: CALL_OW 115
// end ; end ; end ;
117361: GO 117364
117363: POP
// if IsDead ( i ) then
117364: LD_VAR 0 4
117368: PPUSH
117369: CALL_OW 301
117373: IFFALSE 117391
// defenders := defenders diff i ;
117375: LD_ADDR_VAR 0 2
117379: PUSH
117380: LD_VAR 0 2
117384: PUSH
117385: LD_VAR 0 4
117389: DIFF
117390: ST_TO_ADDR
// end ;
117391: GO 116494
117393: POP
117394: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117395: LD_VAR 0 21
117399: NOT
117400: PUSH
117401: LD_VAR 0 2
117405: NOT
117406: OR
117407: PUSH
117408: LD_EXP 61
117412: PUSH
117413: LD_VAR 0 1
117417: ARRAY
117418: NOT
117419: OR
117420: IFFALSE 116398
// MC_Reset ( base , 18 ) ;
117422: LD_VAR 0 1
117426: PPUSH
117427: LD_INT 18
117429: PPUSH
117430: CALL 63385 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117434: LD_ADDR_VAR 0 2
117438: PUSH
117439: LD_VAR 0 2
117443: PUSH
117444: LD_VAR 0 2
117448: PPUSH
117449: LD_INT 2
117451: PUSH
117452: LD_INT 25
117454: PUSH
117455: LD_INT 1
117457: PUSH
117458: EMPTY
117459: LIST
117460: LIST
117461: PUSH
117462: LD_INT 25
117464: PUSH
117465: LD_INT 5
117467: PUSH
117468: EMPTY
117469: LIST
117470: LIST
117471: PUSH
117472: LD_INT 25
117474: PUSH
117475: LD_INT 8
117477: PUSH
117478: EMPTY
117479: LIST
117480: LIST
117481: PUSH
117482: LD_INT 25
117484: PUSH
117485: LD_INT 9
117487: PUSH
117488: EMPTY
117489: LIST
117490: LIST
117491: PUSH
117492: EMPTY
117493: LIST
117494: LIST
117495: LIST
117496: LIST
117497: LIST
117498: PPUSH
117499: CALL_OW 72
117503: DIFF
117504: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117505: LD_VAR 0 21
117509: NOT
117510: PUSH
117511: LD_VAR 0 2
117515: PPUSH
117516: LD_INT 21
117518: PUSH
117519: LD_INT 2
117521: PUSH
117522: EMPTY
117523: LIST
117524: LIST
117525: PPUSH
117526: CALL_OW 72
117530: AND
117531: IFFALSE 117869
// begin tmp := FilterByTag ( defenders , 19 ) ;
117533: LD_ADDR_VAR 0 11
117537: PUSH
117538: LD_VAR 0 2
117542: PPUSH
117543: LD_INT 19
117545: PPUSH
117546: CALL 51705 0 2
117550: ST_TO_ADDR
// if tmp then
117551: LD_VAR 0 11
117555: IFFALSE 117625
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117557: LD_ADDR_VAR 0 11
117561: PUSH
117562: LD_VAR 0 11
117566: PPUSH
117567: LD_INT 25
117569: PUSH
117570: LD_INT 3
117572: PUSH
117573: EMPTY
117574: LIST
117575: LIST
117576: PPUSH
117577: CALL_OW 72
117581: ST_TO_ADDR
// if tmp then
117582: LD_VAR 0 11
117586: IFFALSE 117625
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117588: LD_ADDR_EXP 73
117592: PUSH
117593: LD_EXP 73
117597: PPUSH
117598: LD_VAR 0 1
117602: PPUSH
117603: LD_EXP 73
117607: PUSH
117608: LD_VAR 0 1
117612: ARRAY
117613: PUSH
117614: LD_VAR 0 11
117618: UNION
117619: PPUSH
117620: CALL_OW 1
117624: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117625: LD_VAR 0 1
117629: PPUSH
117630: LD_INT 19
117632: PPUSH
117633: CALL 63385 0 2
// repeat wait ( 0 0$1 ) ;
117637: LD_INT 35
117639: PPUSH
117640: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117644: LD_EXP 61
117648: PUSH
117649: LD_VAR 0 1
117653: ARRAY
117654: NOT
117655: PUSH
117656: LD_EXP 61
117660: PUSH
117661: LD_VAR 0 1
117665: ARRAY
117666: PUSH
117667: EMPTY
117668: EQUAL
117669: OR
117670: IFFALSE 117707
// begin for i in defenders do
117672: LD_ADDR_VAR 0 4
117676: PUSH
117677: LD_VAR 0 2
117681: PUSH
117682: FOR_IN
117683: IFFALSE 117696
// ComStop ( i ) ;
117685: LD_VAR 0 4
117689: PPUSH
117690: CALL_OW 141
117694: GO 117682
117696: POP
117697: POP
// defenders := [ ] ;
117698: LD_ADDR_VAR 0 2
117702: PUSH
117703: EMPTY
117704: ST_TO_ADDR
// exit ;
117705: GO 117933
// end ; for i in defenders do
117707: LD_ADDR_VAR 0 4
117711: PUSH
117712: LD_VAR 0 2
117716: PUSH
117717: FOR_IN
117718: IFFALSE 117807
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117720: LD_VAR 0 4
117724: PPUSH
117725: LD_EXP 85
117729: PUSH
117730: LD_VAR 0 1
117734: ARRAY
117735: PPUSH
117736: CALL_OW 308
117740: NOT
117741: IFFALSE 117765
// ComMoveToArea ( i , mc_parking [ base ] ) else
117743: LD_VAR 0 4
117747: PPUSH
117748: LD_EXP 85
117752: PUSH
117753: LD_VAR 0 1
117757: ARRAY
117758: PPUSH
117759: CALL_OW 113
117763: GO 117805
// if GetControl ( i ) = control_manual then
117765: LD_VAR 0 4
117769: PPUSH
117770: CALL_OW 263
117774: PUSH
117775: LD_INT 1
117777: EQUAL
117778: IFFALSE 117805
// if IsDrivenBy ( i ) then
117780: LD_VAR 0 4
117784: PPUSH
117785: CALL_OW 311
117789: IFFALSE 117805
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117791: LD_VAR 0 4
117795: PPUSH
117796: CALL_OW 311
117800: PPUSH
117801: CALL_OW 121
// end ;
117805: GO 117717
117807: POP
117808: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117809: LD_VAR 0 2
117813: PPUSH
117814: LD_INT 95
117816: PUSH
117817: LD_EXP 85
117821: PUSH
117822: LD_VAR 0 1
117826: ARRAY
117827: PUSH
117828: EMPTY
117829: LIST
117830: LIST
117831: PPUSH
117832: CALL_OW 72
117836: PUSH
117837: LD_VAR 0 2
117841: EQUAL
117842: PUSH
117843: LD_EXP 84
117847: PUSH
117848: LD_VAR 0 1
117852: ARRAY
117853: OR
117854: PUSH
117855: LD_EXP 61
117859: PUSH
117860: LD_VAR 0 1
117864: ARRAY
117865: NOT
117866: OR
117867: IFFALSE 117637
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117869: LD_ADDR_EXP 83
117873: PUSH
117874: LD_EXP 83
117878: PPUSH
117879: LD_VAR 0 1
117883: PPUSH
117884: LD_VAR 0 2
117888: PPUSH
117889: LD_INT 21
117891: PUSH
117892: LD_INT 2
117894: PUSH
117895: EMPTY
117896: LIST
117897: LIST
117898: PPUSH
117899: CALL_OW 72
117903: PPUSH
117904: CALL_OW 1
117908: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117909: LD_VAR 0 1
117913: PPUSH
117914: LD_INT 19
117916: PPUSH
117917: CALL 63385 0 2
// MC_Reset ( base , 20 ) ;
117921: LD_VAR 0 1
117925: PPUSH
117926: LD_INT 20
117928: PPUSH
117929: CALL 63385 0 2
// end ; end_of_file
117933: LD_VAR 0 3
117937: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117938: LD_VAR 0 1
117942: PUSH
117943: LD_INT 200
117945: DOUBLE
117946: GREATEREQUAL
117947: IFFALSE 117955
117949: LD_INT 299
117951: DOUBLE
117952: LESSEQUAL
117953: IFTRUE 117957
117955: GO 117989
117957: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117958: LD_VAR 0 1
117962: PPUSH
117963: LD_VAR 0 2
117967: PPUSH
117968: LD_VAR 0 3
117972: PPUSH
117973: LD_VAR 0 4
117977: PPUSH
117978: LD_VAR 0 5
117982: PPUSH
117983: CALL 106119 0 5
117987: GO 118066
117989: LD_INT 300
117991: DOUBLE
117992: GREATEREQUAL
117993: IFFALSE 118001
117995: LD_INT 399
117997: DOUBLE
117998: LESSEQUAL
117999: IFTRUE 118003
118001: GO 118065
118003: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118004: LD_VAR 0 1
118008: PPUSH
118009: LD_VAR 0 2
118013: PPUSH
118014: LD_VAR 0 3
118018: PPUSH
118019: LD_VAR 0 4
118023: PPUSH
118024: LD_VAR 0 5
118028: PPUSH
118029: LD_VAR 0 6
118033: PPUSH
118034: LD_VAR 0 7
118038: PPUSH
118039: LD_VAR 0 8
118043: PPUSH
118044: LD_VAR 0 9
118048: PPUSH
118049: LD_VAR 0 10
118053: PPUSH
118054: LD_VAR 0 11
118058: PPUSH
118059: CALL 102444 0 11
118063: GO 118066
118065: POP
// end ;
118066: PPOPN 11
118068: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118069: LD_VAR 0 1
118073: PPUSH
118074: LD_VAR 0 2
118078: PPUSH
118079: LD_VAR 0 3
118083: PPUSH
118084: LD_VAR 0 4
118088: PPUSH
118089: LD_VAR 0 5
118093: PPUSH
118094: CALL 105855 0 5
// end ; end_of_file
118098: PPOPN 5
118100: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118101: LD_VAR 0 1
118105: PPUSH
118106: LD_VAR 0 2
118110: PPUSH
118111: LD_VAR 0 3
118115: PPUSH
118116: LD_VAR 0 4
118120: PPUSH
118121: LD_VAR 0 5
118125: PPUSH
118126: LD_VAR 0 6
118130: PPUSH
118131: CALL 90096 0 6
// end ;
118135: PPOPN 6
118137: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118138: LD_INT 0
118140: PPUSH
// begin if not units then
118141: LD_VAR 0 1
118145: NOT
118146: IFFALSE 118150
// exit ;
118148: GO 118150
// end ;
118150: PPOPN 7
118152: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118153: CALL 89983 0 0
// end ;
118157: PPOPN 1
118159: END
