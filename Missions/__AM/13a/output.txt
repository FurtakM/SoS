// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 682 0 0
// InitGlobalVariables ;
  19: CALL 82642 0 0
// InitMacro ;
  23: CALL 52349 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 47641 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 47641 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 47641 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 47641 0 9
// PrepareArabian ;
 168: CALL 3932 0 0
// PrepareRussian ;
 172: CALL 2911 0 0
// PrepareAlliance ;
 176: CALL 884 0 0
// MC_Start ( ) ;
 180: CALL 54514 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7274 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 83
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 84
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: PUSH
 253: LD_OWVAR 67
 257: ARRAY
 258: PPUSH
 259: LD_INT 7
 261: PPUSH
 262: CALL 75879 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_EXP 54
 273: PPUSH
 274: CALL 76305 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 278: LD_INT 1
 280: PPUSH
 281: LD_INT 6
 283: PPUSH
 284: CALL 76763 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 288: LD_INT 1
 290: PPUSH
 291: LD_INT 9
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77032 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 13
 306: PUSH
 307: LD_INT 1
 309: PUSH
 310: LD_INT 2
 312: PUSH
 313: LD_INT 32
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_INT 13
 324: PUSH
 325: LD_INT 1
 327: PUSH
 328: LD_INT 2
 330: PUSH
 331: LD_EXP 109
 335: PUSH
 336: EMPTY
 337: LIST
 338: LIST
 339: LIST
 340: LIST
 341: PUSH
 342: EMPTY
 343: LIST
 344: LIST
 345: PPUSH
 346: CALL 76245 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 350: LD_INT 2
 352: PPUSH
 353: LD_INT 12
 355: PUSH
 356: LD_INT 14
 358: PUSH
 359: LD_INT 10
 361: PUSH
 362: LD_INT 11
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL 76939 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 375: LD_INT 2
 377: PPUSH
 378: LD_EXP 51
 382: PPUSH
 383: CALL 76305 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 387: LD_INT 2
 389: PPUSH
 390: LD_INT 8
 392: PPUSH
 393: CALL 76763 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 397: LD_INT 2
 399: PPUSH
 400: LD_INT 10
 402: PUSH
 403: EMPTY
 404: LIST
 405: PPUSH
 406: CALL 77032 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 6
 415: PUSH
 416: LD_INT 71
 418: PUSH
 419: LD_INT 116
 421: PUSH
 422: LD_INT 4
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PUSH
 431: LD_INT 4
 433: PUSH
 434: LD_INT 85
 436: PUSH
 437: LD_INT 116
 439: PUSH
 440: LD_INT 4
 442: PUSH
 443: EMPTY
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: PUSH
 449: LD_INT 32
 451: PUSH
 452: LD_INT 83
 454: PUSH
 455: LD_INT 111
 457: PUSH
 458: LD_INT 4
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: PUSH
 467: LD_INT 32
 469: PUSH
 470: LD_INT 87
 472: PUSH
 473: LD_INT 121
 475: PUSH
 476: LD_INT 4
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: LIST
 483: LIST
 484: PUSH
 485: LD_INT 33
 487: PUSH
 488: LD_INT 88
 490: PUSH
 491: LD_INT 128
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: EMPTY
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: PUSH
 503: LD_INT 32
 505: PUSH
 506: LD_INT 59
 508: PUSH
 509: LD_INT 89
 511: PUSH
 512: LD_INT 3
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: LD_INT 33
 523: PUSH
 524: LD_INT 69
 526: PUSH
 527: LD_INT 98
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: PUSH
 539: LD_INT 33
 541: PUSH
 542: LD_INT 77
 544: PUSH
 545: LD_INT 103
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: PUSH
 557: LD_INT 33
 559: PUSH
 560: LD_INT 83
 562: PUSH
 563: LD_INT 105
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PUSH
 575: LD_INT 33
 577: PUSH
 578: LD_INT 71
 580: PUSH
 581: LD_INT 125
 583: PUSH
 584: LD_INT 5
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PPUSH
 605: CALL 76089 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 609: LD_INT 2
 611: PPUSH
 612: LD_INT 43
 614: PUSH
 615: LD_INT 47
 617: PUSH
 618: LD_INT 46
 620: PUSH
 621: EMPTY
 622: LIST
 623: LIST
 624: LIST
 625: PPUSH
 626: CALL 77350 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 630: LD_INT 2
 632: PPUSH
 633: LD_INT 21
 635: PUSH
 636: LD_INT 1
 638: PUSH
 639: LD_INT 3
 641: PUSH
 642: LD_INT 51
 644: PUSH
 645: EMPTY
 646: LIST
 647: LIST
 648: LIST
 649: LIST
 650: PUSH
 651: LD_INT 22
 653: PUSH
 654: LD_INT 1
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 52
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PUSH
 669: EMPTY
 670: LIST
 671: LIST
 672: PPUSH
 673: CALL 76245 0 2
// end ;
 677: LD_VAR 0 1
 681: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 682: LD_INT 0
 684: PPUSH
// debug := false ;
 685: LD_ADDR_EXP 1
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// game := true ;
 693: LD_ADDR_EXP 2
 697: PUSH
 698: LD_INT 1
 700: ST_TO_ADDR
// gossudarov_arrive := false ;
 701: LD_ADDR_EXP 4
 705: PUSH
 706: LD_INT 0
 708: ST_TO_ADDR
// ru_lab_builded := false ;
 709: LD_ADDR_EXP 5
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// player_spotted := false ;
 717: LD_ADDR_EXP 6
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// first_attack := false ;
 725: LD_ADDR_EXP 7
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// ru_attackers := [ ] ;
 733: LD_ADDR_EXP 52
 737: PUSH
 738: EMPTY
 739: ST_TO_ADDR
// ar_base_spotted := false ;
 740: LD_ADDR_EXP 8
 744: PUSH
 745: LD_INT 0
 747: ST_TO_ADDR
// ar_active_attack := false ;
 748: LD_ADDR_EXP 9
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_attackers := [ ] ;
 756: LD_ADDR_EXP 10
 760: PUSH
 761: EMPTY
 762: ST_TO_ADDR
// first_powell_attack := false ;
 763: LD_ADDR_EXP 11
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// abdul_escaped := true ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 1
 778: ST_TO_ADDR
// loss_counter := 0 ;
 779: LD_ADDR_EXP 13
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// hack_counter := 0 ;
 787: LD_ADDR_EXP 14
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// end ;
 795: LD_VAR 0 1
 799: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 800: LD_EXP 48
 804: PPUSH
 805: CALL_OW 255
 809: PUSH
 810: LD_INT 7
 812: EQUAL
 813: PUSH
 814: LD_EXP 47
 818: PPUSH
 819: CALL_OW 255
 823: PUSH
 824: LD_INT 7
 826: EQUAL
 827: AND
 828: PUSH
 829: LD_EXP 48
 833: PPUSH
 834: CALL_OW 302
 838: AND
 839: PUSH
 840: LD_EXP 47
 844: PPUSH
 845: CALL_OW 302
 849: AND
 850: IFFALSE 862
 852: GO 854
 854: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 855: LD_STRING ACH_COMRADE
 857: PPUSH
 858: CALL_OW 543
 862: END
// every 0 0$1 trigger hack_counter >= 10 do
 863: LD_EXP 14
 867: PUSH
 868: LD_INT 10
 870: GREATEREQUAL
 871: IFFALSE 883
 873: GO 875
 875: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 876: LD_STRING ACH_HACK
 878: PPUSH
 879: CALL_OW 543
 883: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 884: LD_INT 0
 886: PPUSH
 887: PPUSH
 888: PPUSH
 889: PPUSH
// uc_side := 7 ;
 890: LD_ADDR_OWVAR 20
 894: PUSH
 895: LD_INT 7
 897: ST_TO_ADDR
// uc_nation := 1 ;
 898: LD_ADDR_OWVAR 21
 902: PUSH
 903: LD_INT 1
 905: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 906: LD_ADDR_EXP 15
 910: PUSH
 911: LD_STRING JMM
 913: PPUSH
 914: LD_EXP 1
 918: NOT
 919: PPUSH
 920: LD_STRING 12a_
 922: PPUSH
 923: CALL 14723 0 3
 927: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 928: LD_EXP 15
 932: PPUSH
 933: LD_INT 71
 935: PPUSH
 936: LD_INT 23
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 946: LD_EXP 15
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 958: LD_ADDR_EXP 16
 962: PUSH
 963: LD_STRING Roth
 965: PPUSH
 966: LD_EXP 1
 970: NOT
 971: PPUSH
 972: LD_STRING 12a_
 974: PPUSH
 975: CALL 14723 0 3
 979: ST_TO_ADDR
// if Roth then
 980: LD_EXP 16
 984: IFFALSE 1004
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 986: LD_EXP 16
 990: PPUSH
 991: LD_INT 71
 993: PPUSH
 994: LD_INT 21
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1004: LD_ADDR_EXP 17
1008: PUSH
1009: LD_STRING Lisa
1011: PPUSH
1012: LD_EXP 1
1016: NOT
1017: PPUSH
1018: LD_STRING 12a_
1020: PPUSH
1021: CALL 14723 0 3
1025: ST_TO_ADDR
// if Lisa then
1026: LD_EXP 17
1030: IFFALSE 1047
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1032: LD_EXP 17
1036: PPUSH
1037: LD_INT 13
1039: PPUSH
1040: LD_INT 0
1042: PPUSH
1043: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1047: LD_ADDR_EXP 18
1051: PUSH
1052: LD_STRING Donaldson
1054: PPUSH
1055: LD_EXP 1
1059: NOT
1060: PPUSH
1061: LD_STRING 12a_
1063: PPUSH
1064: CALL 14723 0 3
1068: ST_TO_ADDR
// if Donaldson then
1069: LD_EXP 18
1073: IFFALSE 1090
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1075: LD_EXP 18
1079: PPUSH
1080: LD_INT 13
1082: PPUSH
1083: LD_INT 0
1085: PPUSH
1086: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1090: LD_ADDR_EXP 19
1094: PUSH
1095: LD_STRING Bobby
1097: PPUSH
1098: LD_EXP 1
1102: NOT
1103: PPUSH
1104: LD_STRING 12a_
1106: PPUSH
1107: CALL 14723 0 3
1111: ST_TO_ADDR
// if Bobby then
1112: LD_EXP 19
1116: IFFALSE 1133
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1118: LD_EXP 19
1122: PPUSH
1123: LD_INT 13
1125: PPUSH
1126: LD_INT 0
1128: PPUSH
1129: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1133: LD_ADDR_EXP 20
1137: PUSH
1138: LD_STRING Cyrus
1140: PPUSH
1141: LD_EXP 1
1145: NOT
1146: PPUSH
1147: LD_STRING 12a_
1149: PPUSH
1150: CALL 14723 0 3
1154: ST_TO_ADDR
// if Cyrus then
1155: LD_EXP 20
1159: IFFALSE 1176
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1161: LD_EXP 20
1165: PPUSH
1166: LD_INT 13
1168: PPUSH
1169: LD_INT 0
1171: PPUSH
1172: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1176: LD_ADDR_EXP 21
1180: PUSH
1181: LD_STRING Denis
1183: PPUSH
1184: LD_EXP 1
1188: NOT
1189: PPUSH
1190: LD_STRING 12a_
1192: PPUSH
1193: CALL 14723 0 3
1197: ST_TO_ADDR
// if Denis then
1198: LD_EXP 21
1202: IFFALSE 1219
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1204: LD_EXP 21
1208: PPUSH
1209: LD_INT 13
1211: PPUSH
1212: LD_INT 0
1214: PPUSH
1215: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1219: LD_ADDR_EXP 22
1223: PUSH
1224: LD_STRING Brown
1226: PPUSH
1227: LD_EXP 1
1231: NOT
1232: PPUSH
1233: LD_STRING 12a_
1235: PPUSH
1236: CALL 14723 0 3
1240: ST_TO_ADDR
// if Brown then
1241: LD_EXP 22
1245: IFFALSE 1262
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1247: LD_EXP 22
1251: PPUSH
1252: LD_INT 13
1254: PPUSH
1255: LD_INT 0
1257: PPUSH
1258: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1262: LD_ADDR_EXP 23
1266: PUSH
1267: LD_STRING Gladstone
1269: PPUSH
1270: LD_EXP 1
1274: NOT
1275: PPUSH
1276: LD_STRING 12a_
1278: PPUSH
1279: CALL 14723 0 3
1283: ST_TO_ADDR
// if Gladstone then
1284: LD_EXP 23
1288: IFFALSE 1305
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1290: LD_EXP 23
1294: PPUSH
1295: LD_INT 13
1297: PPUSH
1298: LD_INT 0
1300: PPUSH
1301: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1305: LD_ADDR_EXP 24
1309: PUSH
1310: LD_STRING Houten
1312: PPUSH
1313: LD_EXP 1
1317: NOT
1318: PPUSH
1319: LD_STRING 12a_
1321: PPUSH
1322: CALL 14723 0 3
1326: ST_TO_ADDR
// if Houten then
1327: LD_EXP 24
1331: IFFALSE 1348
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1333: LD_EXP 24
1337: PPUSH
1338: LD_INT 13
1340: PPUSH
1341: LD_INT 0
1343: PPUSH
1344: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1348: LD_ADDR_EXP 25
1352: PUSH
1353: LD_STRING Cornell
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: LD_STRING 12a_
1364: PPUSH
1365: CALL 14723 0 3
1369: ST_TO_ADDR
// if Cornel then
1370: LD_EXP 25
1374: IFFALSE 1391
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1376: LD_EXP 25
1380: PPUSH
1381: LD_INT 13
1383: PPUSH
1384: LD_INT 0
1386: PPUSH
1387: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1391: LD_ADDR_EXP 26
1395: PUSH
1396: LD_STRING Gary
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: LD_STRING 12a_
1407: PPUSH
1408: CALL 14723 0 3
1412: ST_TO_ADDR
// if Gary then
1413: LD_EXP 26
1417: IFFALSE 1434
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1419: LD_EXP 26
1423: PPUSH
1424: LD_INT 13
1426: PPUSH
1427: LD_INT 0
1429: PPUSH
1430: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1434: LD_ADDR_EXP 27
1438: PUSH
1439: LD_STRING Frank
1441: PPUSH
1442: LD_EXP 1
1446: NOT
1447: PPUSH
1448: LD_STRING 12a_
1450: PPUSH
1451: CALL 14723 0 3
1455: ST_TO_ADDR
// if Frank then
1456: LD_EXP 27
1460: IFFALSE 1477
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1462: LD_EXP 27
1466: PPUSH
1467: LD_INT 13
1469: PPUSH
1470: LD_INT 0
1472: PPUSH
1473: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1477: LD_ADDR_EXP 28
1481: PUSH
1482: LD_STRING Kikuchi
1484: PPUSH
1485: LD_EXP 1
1489: NOT
1490: PPUSH
1491: LD_STRING 12a_
1493: PPUSH
1494: CALL 14723 0 3
1498: ST_TO_ADDR
// if Kikuchi then
1499: LD_EXP 28
1503: IFFALSE 1520
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1505: LD_EXP 28
1509: PPUSH
1510: LD_INT 13
1512: PPUSH
1513: LD_INT 0
1515: PPUSH
1516: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1520: LD_ADDR_EXP 29
1524: PUSH
1525: LD_STRING Simms
1527: PPUSH
1528: LD_EXP 1
1532: NOT
1533: PPUSH
1534: LD_STRING 12a_
1536: PPUSH
1537: CALL 14723 0 3
1541: ST_TO_ADDR
// if Simms then
1542: LD_EXP 29
1546: IFFALSE 1563
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1548: LD_EXP 29
1552: PPUSH
1553: LD_INT 13
1555: PPUSH
1556: LD_INT 0
1558: PPUSH
1559: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1563: LD_ADDR_EXP 30
1567: PUSH
1568: LD_STRING Joan
1570: PPUSH
1571: LD_EXP 1
1575: NOT
1576: PPUSH
1577: LD_STRING 12a_
1579: PPUSH
1580: CALL 14723 0 3
1584: ST_TO_ADDR
// if Joan then
1585: LD_EXP 30
1589: IFFALSE 1606
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1591: LD_EXP 30
1595: PPUSH
1596: LD_INT 13
1598: PPUSH
1599: LD_INT 0
1601: PPUSH
1602: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1606: LD_ADDR_EXP 31
1610: PUSH
1611: LD_STRING DeltaDoctor
1613: PPUSH
1614: LD_EXP 1
1618: NOT
1619: PPUSH
1620: LD_STRING 12a_
1622: PPUSH
1623: CALL 14723 0 3
1627: ST_TO_ADDR
// if DeltaDoctor then
1628: LD_EXP 31
1632: IFFALSE 1649
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1634: LD_EXP 31
1638: PPUSH
1639: LD_INT 13
1641: PPUSH
1642: LD_INT 0
1644: PPUSH
1645: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1649: LD_ADDR_VAR 0 4
1653: PUSH
1654: LD_STRING 12a_others
1656: PPUSH
1657: CALL_OW 31
1661: ST_TO_ADDR
// if tmp then
1662: LD_VAR 0 4
1666: IFFALSE 1700
// for i in tmp do
1668: LD_ADDR_VAR 0 3
1672: PUSH
1673: LD_VAR 0 4
1677: PUSH
1678: FOR_IN
1679: IFFALSE 1698
// PlaceUnitArea ( i , alliance_start , false ) ;
1681: LD_VAR 0 3
1685: PPUSH
1686: LD_INT 13
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 49
1696: GO 1678
1698: POP
1699: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1700: LD_INT 3
1702: PPUSH
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 100
1714: PPUSH
1715: CALL 19547 0 5
// veh := CreateVehicle ;
1719: LD_ADDR_VAR 0 2
1723: PUSH
1724: CALL_OW 45
1728: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1729: LD_VAR 0 2
1733: PPUSH
1734: LD_INT 2
1736: PPUSH
1737: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1741: LD_VAR 0 2
1745: PPUSH
1746: LD_INT 60
1748: PPUSH
1749: LD_INT 6
1751: PPUSH
1752: LD_INT 0
1754: PPUSH
1755: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1759: LD_VAR 0 2
1763: PPUSH
1764: LD_INT 4
1766: PPUSH
1767: LD_INT 30
1769: PPUSH
1770: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1774: LD_STRING 11_artifact_captured
1776: PPUSH
1777: LD_INT 0
1779: PPUSH
1780: CALL_OW 30
1784: IFFALSE 1860
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1786: LD_INT 3
1788: PPUSH
1789: LD_INT 3
1791: PPUSH
1792: LD_INT 3
1794: PPUSH
1795: LD_INT 12
1797: PPUSH
1798: LD_INT 100
1800: PPUSH
1801: CALL 19547 0 5
// veh := CreateVehicle ;
1805: LD_ADDR_VAR 0 2
1809: PUSH
1810: CALL_OW 45
1814: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1815: LD_VAR 0 2
1819: PPUSH
1820: LD_INT 3
1822: PPUSH
1823: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1827: LD_VAR 0 2
1831: PPUSH
1832: LD_INT 75
1834: PPUSH
1835: LD_INT 6
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: LD_INT 4
1852: PPUSH
1853: LD_INT 50
1855: PPUSH
1856: CALL_OW 290
// end ; end ;
1860: LD_VAR 0 1
1864: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1865: LD_INT 0
1867: PPUSH
1868: PPUSH
1869: PPUSH
1870: PPUSH
// uc_side := 6 ;
1871: LD_ADDR_OWVAR 20
1875: PUSH
1876: LD_INT 6
1878: ST_TO_ADDR
// uc_nation := 3 ;
1879: LD_ADDR_OWVAR 21
1883: PUSH
1884: LD_INT 3
1886: ST_TO_ADDR
// InitHc ;
1887: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1891: LD_ADDR_EXP 32
1895: PUSH
1896: LD_STRING Gossudarov
1898: PPUSH
1899: CALL_OW 25
1903: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1904: LD_ADDR_EXP 33
1908: PUSH
1909: LD_STRING Kirilenkova
1911: PPUSH
1912: CALL_OW 25
1916: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1917: LD_ADDR_EXP 34
1921: PUSH
1922: LD_STRING Titov
1924: PPUSH
1925: CALL_OW 25
1929: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Oblukov
1937: PPUSH
1938: CALL_OW 25
1942: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1943: LD_ADDR_EXP 36
1947: PUSH
1948: LD_STRING Dolgov
1950: PPUSH
1951: CALL_OW 25
1955: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1956: LD_ADDR_EXP 37
1960: PUSH
1961: LD_STRING Petrosyan
1963: PPUSH
1964: CALL_OW 25
1968: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1969: LD_ADDR_EXP 38
1973: PUSH
1974: LD_STRING Scholtze
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1982: LD_ADDR_EXP 40
1986: PUSH
1987: LD_STRING Kapitsova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1995: LD_ADDR_VAR 0 2
1999: PUSH
2000: LD_EXP 32
2004: PUSH
2005: LD_EXP 33
2009: PUSH
2010: LD_EXP 34
2014: PUSH
2015: LD_EXP 39
2019: PUSH
2020: LD_EXP 36
2024: PUSH
2025: LD_EXP 37
2029: PUSH
2030: LD_EXP 38
2034: PUSH
2035: LD_EXP 40
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 4
2055: PPUSH
2056: LD_INT 8
2058: PPUSH
2059: CALL_OW 380
// un := CreateHuman ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: CALL_OW 44
2072: ST_TO_ADDR
// tmp := tmp ^ un ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_VAR 0 2
2082: PUSH
2083: LD_VAR 0 4
2087: ADD
2088: ST_TO_ADDR
// for i in tmp do
2089: LD_ADDR_VAR 0 3
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: FOR_IN
2100: IFFALSE 2119
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 14
2109: PPUSH
2110: LD_INT 0
2112: PPUSH
2113: CALL_OW 49
2117: GO 2099
2119: POP
2120: POP
// if freedom then
2121: LD_EXP 3
2125: IFFALSE 2158
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2127: LD_VAR 0 2
2131: PPUSH
2132: LD_EXP 3
2136: PPUSH
2137: CALL_OW 250
2141: PPUSH
2142: LD_EXP 3
2146: PPUSH
2147: CALL_OW 251
2151: PPUSH
2152: CALL_OW 111
2156: GO 2173
// ComMoveXY ( tmp , 70 , 48 ) ;
2158: LD_VAR 0 2
2162: PPUSH
2163: LD_INT 70
2165: PPUSH
2166: LD_INT 48
2168: PPUSH
2169: CALL_OW 111
// end ;
2173: LD_VAR 0 1
2177: RET
// export function PrepareBelkov ; begin
2178: LD_INT 0
2180: PPUSH
// uc_side := 4 ;
2181: LD_ADDR_OWVAR 20
2185: PUSH
2186: LD_INT 4
2188: ST_TO_ADDR
// uc_nation := 3 ;
2189: LD_ADDR_OWVAR 21
2193: PUSH
2194: LD_INT 3
2196: ST_TO_ADDR
// InitHc ;
2197: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2201: LD_ADDR_EXP 47
2205: PUSH
2206: LD_STRING Belkov
2208: PPUSH
2209: CALL_OW 25
2213: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2214: LD_EXP 47
2218: PPUSH
2219: LD_INT 14
2221: PPUSH
2222: LD_INT 0
2224: PPUSH
2225: CALL_OW 49
// end ;
2229: LD_VAR 0 1
2233: RET
// export function PrepareGnyevko ; begin
2234: LD_INT 0
2236: PPUSH
// uc_side := 4 ;
2237: LD_ADDR_OWVAR 20
2241: PUSH
2242: LD_INT 4
2244: ST_TO_ADDR
// uc_nation := 3 ;
2245: LD_ADDR_OWVAR 21
2249: PUSH
2250: LD_INT 3
2252: ST_TO_ADDR
// InitHc ;
2253: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2257: LD_ADDR_EXP 48
2261: PUSH
2262: LD_STRING Gnyevko
2264: PPUSH
2265: CALL_OW 25
2269: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2270: LD_EXP 48
2274: PPUSH
2275: LD_INT 14
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// end ;
2285: LD_VAR 0 1
2289: RET
// export function PrepareBurlak ; var i , tmp ; begin
2290: LD_INT 0
2292: PPUSH
2293: PPUSH
2294: PPUSH
// uc_side := 4 ;
2295: LD_ADDR_OWVAR 20
2299: PUSH
2300: LD_INT 4
2302: ST_TO_ADDR
// uc_nation := 3 ;
2303: LD_ADDR_OWVAR 21
2307: PUSH
2308: LD_INT 3
2310: ST_TO_ADDR
// InitHc ;
2311: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2315: LD_ADDR_EXP 46
2319: PUSH
2320: LD_STRING Burlak
2322: PPUSH
2323: CALL_OW 25
2327: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2328: LD_INT 24
2330: PUSH
2331: LD_INT 23
2333: PUSH
2334: LD_INT 22
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: LIST
2341: PUSH
2342: LD_OWVAR 67
2346: ARRAY
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_INT 1
2353: PPUSH
2354: LD_INT 45
2356: PUSH
2357: LD_INT 44
2359: PUSH
2360: LD_INT 43
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: LIST
2367: PUSH
2368: LD_OWVAR 67
2372: ARRAY
2373: PPUSH
2374: LD_INT 0
2376: PPUSH
2377: CALL 19547 0 5
// Masha := CreateVehicle ;
2381: LD_ADDR_EXP 49
2385: PUSH
2386: CALL_OW 45
2390: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2391: LD_EXP 49
2395: PUSH
2396: LD_EXP 46
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PPUSH
2405: LD_INT 499
2407: PPUSH
2408: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2412: LD_EXP 49
2416: PPUSH
2417: LD_INT 3
2419: PPUSH
2420: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2424: LD_EXP 49
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 18
2441: PPUSH
2442: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2446: LD_INT 35
2448: PPUSH
2449: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_INT 18
2460: PPUSH
2461: EMPTY
2462: PPUSH
2463: CALL_OW 70
2467: ST_TO_ADDR
// if tmp then
2468: LD_VAR 0 3
2472: IFFALSE 2506
// for i in tmp do
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 3
2483: PUSH
2484: FOR_IN
2485: IFFALSE 2504
// ComMoveXY ( i , 114 , 9 ) ;
2487: LD_VAR 0 2
2491: PPUSH
2492: LD_INT 114
2494: PPUSH
2495: LD_INT 9
2497: PPUSH
2498: CALL_OW 111
2502: GO 2484
2504: POP
2505: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2506: LD_INT 18
2508: PPUSH
2509: EMPTY
2510: PPUSH
2511: CALL_OW 70
2515: NOT
2516: PUSH
2517: LD_INT 123
2519: PPUSH
2520: LD_INT 3
2522: PPUSH
2523: CALL_OW 428
2527: PUSH
2528: LD_INT 0
2530: EQUAL
2531: AND
2532: IFFALSE 2446
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2534: LD_EXP 49
2538: PPUSH
2539: LD_INT 123
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2552: LD_EXP 46
2556: PPUSH
2557: LD_INT 125
2559: PPUSH
2560: LD_INT 1
2562: PPUSH
2563: LD_INT 0
2565: PPUSH
2566: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2570: LD_EXP 46
2574: PPUSH
2575: LD_EXP 49
2579: PPUSH
2580: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2584: LD_INT 10
2586: PPUSH
2587: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2591: LD_EXP 49
2595: PPUSH
2596: LD_INT 110
2598: PPUSH
2599: LD_INT 10
2601: PPUSH
2602: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2606: LD_ADDR_EXP 42
2610: PUSH
2611: LD_STRING Petrovova
2613: PPUSH
2614: CALL_OW 25
2618: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2619: LD_ADDR_EXP 44
2623: PUSH
2624: LD_STRING Kuzmov
2626: PPUSH
2627: CALL_OW 25
2631: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2632: LD_ADDR_EXP 43
2636: PUSH
2637: LD_STRING Kovalyuk
2639: PPUSH
2640: CALL_OW 25
2644: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2645: LD_ADDR_EXP 41
2649: PUSH
2650: LD_STRING Lipshchin
2652: PPUSH
2653: CALL_OW 25
2657: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2658: LD_ADDR_EXP 45
2662: PUSH
2663: LD_STRING Karamazov
2665: PPUSH
2666: CALL_OW 25
2670: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 42
2680: PUSH
2681: LD_EXP 44
2685: PUSH
2686: LD_EXP 43
2690: PUSH
2691: LD_EXP 41
2695: PUSH
2696: LD_EXP 45
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: ST_TO_ADDR
// for i in tmp do
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 3
2717: PUSH
2718: FOR_IN
2719: IFFALSE 2758
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2721: LD_VAR 0 2
2725: PPUSH
2726: LD_INT 399
2728: PPUSH
2729: LD_INT 799
2731: PPUSH
2732: CALL_OW 12
2736: PPUSH
2737: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: LD_INT 0
2751: PPUSH
2752: CALL_OW 49
// end ;
2756: GO 2718
2758: POP
2759: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2760: LD_VAR 0 3
2764: PPUSH
2765: LD_INT 116
2767: PPUSH
2768: LD_INT 8
2770: PPUSH
2771: CALL_OW 111
// AddComHold ( tmp ) ;
2775: LD_VAR 0 3
2779: PPUSH
2780: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2784: LD_ADDR_VAR 0 2
2788: PUSH
2789: LD_VAR 0 3
2793: PPUSH
2794: LD_INT 25
2796: PUSH
2797: LD_INT 1
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PPUSH
2804: CALL_OW 72
2808: PUSH
2809: FOR_IN
2810: IFFALSE 2850
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2812: LD_VAR 0 2
2816: PPUSH
2817: LD_INT 20
2819: PPUSH
2820: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2824: LD_VAR 0 2
2828: PPUSH
2829: LD_INT 147
2831: PPUSH
2832: LD_INT 45
2834: PPUSH
2835: CALL_OW 178
// AddComCrawl ( i ) ;
2839: LD_VAR 0 2
2843: PPUSH
2844: CALL_OW 197
// end ;
2848: GO 2809
2850: POP
2851: POP
// repeat wait ( 0 0$1 ) ;
2852: LD_INT 35
2854: PPUSH
2855: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2859: LD_EXP 49
2863: PPUSH
2864: LD_INT 110
2866: PPUSH
2867: LD_INT 10
2869: PPUSH
2870: CALL_OW 307
2874: PUSH
2875: LD_EXP 49
2879: PPUSH
2880: CALL_OW 305
2884: NOT
2885: OR
2886: IFFALSE 2852
// ComStop ( Burlak ) ;
2888: LD_EXP 46
2892: PPUSH
2893: CALL_OW 141
// AddComHold ( Burlak ) ;
2897: LD_EXP 46
2901: PPUSH
2902: CALL_OW 200
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// uc_side := 3 ;
2918: LD_ADDR_OWVAR 20
2922: PUSH
2923: LD_INT 3
2925: ST_TO_ADDR
// uc_nation := 3 ;
2926: LD_ADDR_OWVAR 21
2930: PUSH
2931: LD_INT 3
2933: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2934: LD_ADDR_EXP 50
2938: PUSH
2939: LD_INT 47
2941: PPUSH
2942: LD_INT 4
2944: PPUSH
2945: LD_STRING 
2947: PPUSH
2948: LD_INT 7
2950: PUSH
2951: LD_INT 8
2953: PUSH
2954: LD_INT 10
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: PUSH
2962: LD_OWVAR 67
2966: ARRAY
2967: PPUSH
2968: LD_INT 10000
2970: PUSH
2971: LD_INT 3000
2973: PUSH
2974: LD_INT 300
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: LIST
2981: PPUSH
2982: LD_INT 9
2984: PUSH
2985: LD_INT 5
2987: PUSH
2988: LD_INT 6
2990: PUSH
2991: LD_INT 6
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL 22988 0 6
3004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3005: LD_ADDR_EXP 59
3009: PUSH
3010: LD_EXP 59
3014: PPUSH
3015: LD_INT 2
3017: PPUSH
3018: LD_EXP 50
3022: PPUSH
3023: CALL_OW 1
3027: ST_TO_ADDR
// tmp := [ ] ;
3028: LD_ADDR_VAR 0 4
3032: PUSH
3033: EMPTY
3034: ST_TO_ADDR
// for i = 1 to 4 do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: DOUBLE
3041: LD_INT 1
3043: DEC
3044: ST_TO_ADDR
3045: LD_INT 4
3047: PUSH
3048: FOR_TO
3049: IFFALSE 3142
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3051: LD_INT 22
3053: PPUSH
3054: LD_INT 3
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: LD_INT 43
3062: PUSH
3063: LD_INT 45
3065: PUSH
3066: LD_INT 45
3068: PUSH
3069: LD_INT 44
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_INT 4
3085: MOD
3086: PUSH
3087: LD_INT 1
3089: PLUS
3090: ARRAY
3091: PPUSH
3092: LD_INT 100
3094: PPUSH
3095: CALL 19547 0 5
// veh := CreateVehicle ;
3099: LD_ADDR_VAR 0 3
3103: PUSH
3104: CALL_OW 45
3108: ST_TO_ADDR
// tmp := tmp ^ veh ;
3109: LD_ADDR_VAR 0 4
3113: PUSH
3114: LD_VAR 0 4
3118: PUSH
3119: LD_VAR 0 3
3123: ADD
3124: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3125: LD_VAR 0 3
3129: PPUSH
3130: LD_INT 2
3132: PPUSH
3133: LD_INT 0
3135: PPUSH
3136: CALL_OW 49
// end ;
3140: GO 3048
3142: POP
3143: POP
// russian_guard := tmp ;
3144: LD_ADDR_EXP 51
3148: PUSH
3149: LD_VAR 0 4
3153: ST_TO_ADDR
// if Difficulty = 3 then
3154: LD_OWVAR 67
3158: PUSH
3159: LD_INT 3
3161: EQUAL
3162: IFFALSE 3226
// begin bc_type := b_breastwork ;
3164: LD_ADDR_OWVAR 42
3168: PUSH
3169: LD_INT 31
3171: ST_TO_ADDR
// bc_level := 10 ;
3172: LD_ADDR_OWVAR 43
3176: PUSH
3177: LD_INT 10
3179: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3180: LD_ADDR_VAR 0 5
3184: PUSH
3185: LD_INT 96
3187: PPUSH
3188: LD_INT 105
3190: PPUSH
3191: LD_INT 3
3193: PPUSH
3194: CALL_OW 47
3198: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3199: LD_INT 0
3201: PPUSH
3202: LD_INT 9
3204: PPUSH
3205: LD_INT 10
3207: PPUSH
3208: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3212: CALL_OW 44
3216: PPUSH
3217: LD_VAR 0 5
3221: PPUSH
3222: CALL_OW 52
// end ; end ;
3226: LD_VAR 0 1
3230: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3231: LD_INT 47
3233: PPUSH
3234: CALL_OW 302
3238: PUSH
3239: LD_EXP 6
3243: AND
3244: IFFALSE 3929
3246: GO 3248
3248: DISABLE
3249: LD_INT 0
3251: PPUSH
3252: PPUSH
3253: PPUSH
3254: PPUSH
3255: PPUSH
3256: PPUSH
3257: PPUSH
// begin enable ;
3258: ENABLE
// base := 2 ;
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: LD_INT 2
3266: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3267: LD_ADDR_VAR 0 4
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: LD_INT 0
3277: PUSH
3278: LD_INT 0
3280: PUSH
3281: LD_INT 0
3283: PUSH
3284: LD_INT 0
3286: PUSH
3287: LD_INT 0
3289: PUSH
3290: LD_INT 0
3292: PUSH
3293: LD_INT 0
3295: PUSH
3296: LD_INT 1
3298: PUSH
3299: LD_INT 0
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: LIST
3311: LIST
3312: LIST
3313: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3314: LD_ADDR_VAR 0 3
3318: PUSH
3319: LD_INT 22
3321: PUSH
3322: LD_INT 1
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 45
3330: PUSH
3331: EMPTY
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: PUSH
3337: LD_INT 21
3339: PUSH
3340: LD_INT 1
3342: PUSH
3343: LD_INT 3
3345: PUSH
3346: LD_INT 45
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: PUSH
3355: LD_INT 22
3357: PUSH
3358: LD_INT 1
3360: PUSH
3361: LD_INT 3
3363: PUSH
3364: LD_INT 45
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 23
3375: PUSH
3376: LD_INT 1
3378: PUSH
3379: LD_INT 3
3381: PUSH
3382: LD_INT 46
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// amount := Difficulty ;
3397: LD_ADDR_VAR 0 7
3401: PUSH
3402: LD_OWVAR 67
3406: ST_TO_ADDR
// if tick > 30 30$00 then
3407: LD_OWVAR 1
3411: PUSH
3412: LD_INT 63000
3414: GREATER
3415: IFFALSE 3448
// amount := amount + [ 2 , 3 , 4 ] [ Difficulty ] ;
3417: LD_ADDR_VAR 0 7
3421: PUSH
3422: LD_VAR 0 7
3426: PUSH
3427: LD_INT 2
3429: PUSH
3430: LD_INT 3
3432: PUSH
3433: LD_INT 4
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: LD_OWVAR 67
3445: ARRAY
3446: PLUS
3447: ST_TO_ADDR
// for i = 1 to amount do
3448: LD_ADDR_VAR 0 1
3452: PUSH
3453: DOUBLE
3454: LD_INT 1
3456: DEC
3457: ST_TO_ADDR
3458: LD_VAR 0 7
3462: PUSH
3463: FOR_TO
3464: IFFALSE 3552
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3466: LD_ADDR_VAR 0 3
3470: PUSH
3471: LD_VAR 0 3
3475: PPUSH
3476: LD_VAR 0 3
3480: PUSH
3481: LD_INT 1
3483: PLUS
3484: PPUSH
3485: LD_INT 23
3487: PUSH
3488: LD_INT 24
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: PUSH
3495: LD_INT 1
3497: PPUSH
3498: LD_INT 2
3500: PPUSH
3501: CALL_OW 12
3505: ARRAY
3506: PUSH
3507: LD_INT 1
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: LD_INT 46
3515: PUSH
3516: LD_INT 47
3518: PUSH
3519: LD_INT 45
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 3
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: PPUSH
3545: CALL_OW 2
3549: ST_TO_ADDR
3550: GO 3463
3552: POP
3553: POP
// MC_InsertProduceList ( base , tmp ) ;
3554: LD_VAR 0 2
3558: PPUSH
3559: LD_VAR 0 3
3563: PPUSH
3564: CALL 76245 0 2
// repeat wait ( 0 0$1 ) ;
3568: LD_INT 35
3570: PPUSH
3571: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3575: LD_VAR 0 2
3579: PPUSH
3580: LD_INT 1
3582: PPUSH
3583: CALL 77663 0 2
3587: PUSH
3588: LD_VAR 0 7
3592: GREATEREQUAL
3593: IFFALSE 3568
// wait ( 0 0$30 ) ;
3595: LD_INT 1050
3597: PPUSH
3598: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_INT 71
3609: PUSH
3610: LD_INT 19
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 91
3619: PUSH
3620: LD_INT 67
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 52
3629: PUSH
3630: LD_INT 44
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 68
3639: PUSH
3640: LD_INT 48
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_EXP 78
3662: PUSH
3663: LD_VAR 0 2
3667: ARRAY
3668: PUSH
3669: LD_EXP 78
3673: PUSH
3674: LD_VAR 0 2
3678: ARRAY
3679: PPUSH
3680: LD_INT 2
3682: PUSH
3683: LD_INT 34
3685: PUSH
3686: LD_INT 51
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: LD_INT 34
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PPUSH
3708: CALL_OW 72
3712: DIFF
3713: ST_TO_ADDR
// if not attackers then
3714: LD_VAR 0 6
3718: NOT
3719: IFFALSE 3723
// exit ;
3721: GO 3929
// ru_attackers := attackers ;
3723: LD_ADDR_EXP 52
3727: PUSH
3728: LD_VAR 0 6
3732: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3733: LD_ADDR_EXP 78
3737: PUSH
3738: LD_EXP 78
3742: PPUSH
3743: LD_VAR 0 2
3747: PPUSH
3748: LD_EXP 78
3752: PUSH
3753: LD_VAR 0 2
3757: ARRAY
3758: PUSH
3759: LD_VAR 0 6
3763: DIFF
3764: PPUSH
3765: CALL_OW 1
3769: ST_TO_ADDR
// for i = 1 to attackers do
3770: LD_ADDR_VAR 0 1
3774: PUSH
3775: DOUBLE
3776: LD_INT 1
3778: DEC
3779: ST_TO_ADDR
3780: LD_VAR 0 6
3784: PUSH
3785: FOR_TO
3786: IFFALSE 3863
// begin case i mod 3 of 0 :
3788: LD_VAR 0 1
3792: PUSH
3793: LD_INT 3
3795: MOD
3796: PUSH
3797: LD_INT 0
3799: DOUBLE
3800: EQUAL
3801: IFTRUE 3805
3803: GO 3808
3805: POP
// ; 1 :
3806: GO 3861
3808: LD_INT 1
3810: DOUBLE
3811: EQUAL
3812: IFTRUE 3816
3814: GO 3834
3816: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3817: LD_VAR 0 1
3821: PPUSH
3822: LD_INT 32
3824: PPUSH
3825: LD_INT 49
3827: PPUSH
3828: CALL_OW 114
3832: GO 3861
3834: LD_INT 2
3836: DOUBLE
3837: EQUAL
3838: IFTRUE 3842
3840: GO 3860
3842: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3843: LD_VAR 0 1
3847: PPUSH
3848: LD_INT 117
3850: PPUSH
3851: LD_INT 107
3853: PPUSH
3854: CALL_OW 114
3858: GO 3861
3860: POP
// end ;
3861: GO 3785
3863: POP
3864: POP
// repeat wait ( 0 0$1 ) ;
3865: LD_INT 35
3867: PPUSH
3868: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_INT 60
3879: PUSH
3880: EMPTY
3881: LIST
3882: PPUSH
3883: CALL_OW 72
3887: NOT
3888: IFFALSE 3865
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3890: LD_VAR 0 2
3894: PPUSH
3895: LD_VAR 0 6
3899: PPUSH
3900: LD_VAR 0 5
3904: PPUSH
3905: LD_VAR 0 4
3909: PPUSH
3910: CALL 76430 0 4
// if not first_attack then
3914: LD_EXP 7
3918: NOT
3919: IFFALSE 3929
// first_attack := true ;
3921: LD_ADDR_EXP 7
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// end ; end_of_file
3929: PPOPN 7
3931: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3932: LD_INT 0
3934: PPUSH
3935: PPUSH
3936: PPUSH
3937: PPUSH
3938: PPUSH
3939: PPUSH
3940: PPUSH
// uc_side := 2 ;
3941: LD_ADDR_OWVAR 20
3945: PUSH
3946: LD_INT 2
3948: ST_TO_ADDR
// uc_nation := 2 ;
3949: LD_ADDR_OWVAR 21
3953: PUSH
3954: LD_INT 2
3956: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3957: LD_ADDR_EXP 55
3961: PUSH
3962: LD_STRING Abdul
3964: PPUSH
3965: CALL_OW 25
3969: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3970: LD_EXP 55
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3982: LD_EXP 55
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: CALL_OW 52
// vc_chassis := 31 ;
3994: LD_ADDR_OWVAR 37
3998: PUSH
3999: LD_INT 31
4001: ST_TO_ADDR
// vc_control := control_rider ;
4002: LD_ADDR_OWVAR 38
4006: PUSH
4007: LD_INT 4
4009: ST_TO_ADDR
// mastodont := CreateVehicle ;
4010: LD_ADDR_EXP 56
4014: PUSH
4015: CALL_OW 45
4019: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4020: LD_EXP 56
4024: PPUSH
4025: LD_INT 153
4027: PPUSH
4028: LD_INT 71
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 48
// InitVc ;
4038: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_INT 1
4049: PPUSH
4050: LD_INT 3
4052: PPUSH
4053: LD_STRING 
4055: PPUSH
4056: LD_INT 7
4058: PUSH
4059: LD_INT 8
4061: PUSH
4062: LD_INT 10
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: LIST
4069: PUSH
4070: LD_OWVAR 67
4074: ARRAY
4075: PPUSH
4076: LD_INT 5000
4078: PUSH
4079: LD_INT 1000
4081: PUSH
4082: LD_INT 300
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PPUSH
4090: LD_INT 18
4092: PUSH
4093: LD_INT 5
4095: PUSH
4096: LD_INT 6
4098: PUSH
4099: LD_INT 9
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: PPUSH
4108: CALL 22988 0 6
4112: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4113: LD_ADDR_EXP 59
4117: PUSH
4118: LD_EXP 59
4122: PPUSH
4123: LD_INT 1
4125: PPUSH
4126: LD_EXP 53
4130: PPUSH
4131: CALL_OW 1
4135: ST_TO_ADDR
// tmp := [ ] ;
4136: LD_ADDR_VAR 0 4
4140: PUSH
4141: EMPTY
4142: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4143: LD_ADDR_OWVAR 37
4147: PUSH
4148: LD_INT 14
4150: ST_TO_ADDR
// vc_engine := engine_siberite ;
4151: LD_ADDR_OWVAR 39
4155: PUSH
4156: LD_INT 3
4158: ST_TO_ADDR
// vc_control := control_manual ;
4159: LD_ADDR_OWVAR 38
4163: PUSH
4164: LD_INT 1
4166: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4167: LD_ADDR_OWVAR 40
4171: PUSH
4172: LD_INT 31
4174: ST_TO_ADDR
// for i = 1 to 3 do
4175: LD_ADDR_VAR 0 2
4179: PUSH
4180: DOUBLE
4181: LD_INT 1
4183: DEC
4184: ST_TO_ADDR
4185: LD_INT 3
4187: PUSH
4188: FOR_TO
4189: IFFALSE 4433
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4191: LD_ADDR_VAR 0 5
4195: PUSH
4196: LD_INT 153
4198: PUSH
4199: LD_INT 71
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 155
4208: PUSH
4209: LD_INT 81
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_VAR 0 2
4224: PUSH
4225: LD_INT 2
4227: MOD
4228: PUSH
4229: LD_INT 1
4231: PLUS
4232: ARRAY
4233: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 ] [ Difficulty ] ) ;
4234: LD_INT 0
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 7
4242: PUSH
4243: LD_INT 8
4245: PUSH
4246: LD_INT 10
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: LIST
4253: PUSH
4254: LD_OWVAR 67
4258: ARRAY
4259: PPUSH
4260: CALL_OW 380
// un := CreateVehicle ;
4264: LD_ADDR_VAR 0 6
4268: PUSH
4269: CALL_OW 45
4273: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4274: LD_VAR 0 6
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: LD_INT 5
4284: PPUSH
4285: CALL_OW 12
4289: PPUSH
4290: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4294: LD_VAR 0 6
4298: PPUSH
4299: LD_VAR 0 5
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PPUSH
4308: LD_VAR 0 5
4312: PUSH
4313: LD_INT 2
4315: ARRAY
4316: PPUSH
4317: LD_INT 6
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 50
// un2 := CreateHuman ;
4327: LD_ADDR_VAR 0 7
4331: PUSH
4332: CALL_OW 44
4336: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4337: LD_VAR 0 7
4341: PPUSH
4342: LD_VAR 0 6
4346: PPUSH
4347: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4351: LD_ADDR_EXP 59
4355: PUSH
4356: LD_EXP 59
4360: PPUSH
4361: LD_INT 1
4363: PUSH
4364: LD_EXP 59
4368: PUSH
4369: LD_INT 1
4371: ARRAY
4372: PUSH
4373: LD_INT 1
4375: PLUS
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: LD_VAR 0 6
4385: PPUSH
4386: CALL 19669 0 3
4390: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4391: LD_ADDR_EXP 59
4395: PUSH
4396: LD_EXP 59
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 59
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 7
4425: PPUSH
4426: CALL 19669 0 3
4430: ST_TO_ADDR
// end ;
4431: GO 4188
4433: POP
4434: POP
// for i = 1 to 5 do
4435: LD_ADDR_VAR 0 2
4439: PUSH
4440: DOUBLE
4441: LD_INT 1
4443: DEC
4444: ST_TO_ADDR
4445: LD_INT 5
4447: PUSH
4448: FOR_TO
4449: IFFALSE 4542
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4451: LD_INT 14
4453: PPUSH
4454: LD_INT 3
4456: PPUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 25
4462: PUSH
4463: LD_INT 28
4465: PUSH
4466: LD_INT 28
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_VAR 0 2
4482: PUSH
4483: LD_INT 4
4485: MOD
4486: PUSH
4487: LD_INT 1
4489: PLUS
4490: ARRAY
4491: PPUSH
4492: LD_INT 100
4494: PPUSH
4495: CALL 19547 0 5
// veh := CreateVehicle ;
4499: LD_ADDR_VAR 0 3
4503: PUSH
4504: CALL_OW 45
4508: ST_TO_ADDR
// tmp := tmp ^ veh ;
4509: LD_ADDR_VAR 0 4
4513: PUSH
4514: LD_VAR 0 4
4518: PUSH
4519: LD_VAR 0 3
4523: ADD
4524: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4525: LD_VAR 0 3
4529: PPUSH
4530: LD_INT 1
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 49
// end ;
4540: GO 4448
4542: POP
4543: POP
// arabian_guard := tmp ;
4544: LD_ADDR_EXP 54
4548: PUSH
4549: LD_VAR 0 4
4553: ST_TO_ADDR
// end ;
4554: LD_VAR 0 1
4558: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4559: LD_INT 22
4561: PUSH
4562: LD_INT 7
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PUSH
4569: LD_INT 91
4571: PUSH
4572: LD_INT 1
4574: PUSH
4575: LD_INT 12
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 69
4591: PUSH
4592: LD_EXP 56
4596: PPUSH
4597: CALL_OW 256
4601: PUSH
4602: LD_INT 990
4604: LESS
4605: OR
4606: PUSH
4607: LD_EXP 55
4611: PPUSH
4612: CALL_OW 256
4616: PUSH
4617: LD_INT 990
4619: LESS
4620: OR
4621: IFFALSE 4764
4623: GO 4625
4625: DISABLE
// begin if IsInUnit ( Abdul ) then
4626: LD_EXP 55
4630: PPUSH
4631: CALL_OW 310
4635: IFFALSE 4646
// ComExitBuilding ( Abdul ) ;
4637: LD_EXP 55
4641: PPUSH
4642: CALL_OW 122
// if Mastodont then
4646: LD_EXP 56
4650: IFFALSE 4667
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4652: LD_EXP 56
4656: PPUSH
4657: LD_INT 205
4659: PPUSH
4660: LD_INT 132
4662: PPUSH
4663: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4667: LD_EXP 55
4671: PPUSH
4672: LD_INT 205
4674: PPUSH
4675: LD_INT 132
4677: PPUSH
4678: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4682: LD_INT 35
4684: PPUSH
4685: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4689: LD_EXP 55
4693: PPUSH
4694: LD_INT 21
4696: PPUSH
4697: CALL_OW 308
4701: IFFALSE 4682
// RemoveUnit ( Abdul ) ;
4703: LD_EXP 55
4707: PPUSH
4708: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4712: LD_INT 35
4714: PPUSH
4715: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4719: LD_EXP 56
4723: PPUSH
4724: LD_INT 21
4726: PPUSH
4727: CALL_OW 308
4731: PUSH
4732: LD_EXP 56
4736: PPUSH
4737: CALL_OW 301
4741: OR
4742: IFFALSE 4712
// if IsOk ( Mastodont ) then
4744: LD_EXP 56
4748: PPUSH
4749: CALL_OW 302
4753: IFFALSE 4764
// RemoveUnit ( Mastodont ) ;
4755: LD_EXP 56
4759: PPUSH
4760: CALL_OW 64
// end ;
4764: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4765: LD_EXP 55
4769: PPUSH
4770: CALL_OW 301
4774: PUSH
4775: LD_INT 22
4777: PUSH
4778: LD_INT 2
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 2
4787: PUSH
4788: LD_INT 25
4790: PUSH
4791: LD_INT 1
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 25
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 25
4810: PUSH
4811: LD_INT 3
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 25
4820: PUSH
4821: LD_INT 4
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 8
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PPUSH
4850: CALL_OW 69
4854: PUSH
4855: LD_INT 16
4857: PUSH
4858: LD_INT 19
4860: PUSH
4861: LD_INT 22
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: PUSH
4869: LD_OWVAR 67
4873: ARRAY
4874: LESS
4875: OR
4876: IFFALSE 5549
4878: GO 4880
4880: DISABLE
4881: LD_INT 0
4883: PPUSH
4884: PPUSH
4885: PPUSH
4886: PPUSH
4887: PPUSH
4888: PPUSH
// begin MC_Kill ( 1 ) ;
4889: LD_INT 1
4891: PPUSH
4892: CALL 52591 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4896: LD_ADDR_VAR 0 2
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 2
4913: PUSH
4914: LD_INT 25
4916: PUSH
4917: LD_INT 1
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: PUSH
4924: LD_INT 25
4926: PUSH
4927: LD_INT 2
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 25
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 25
4946: PUSH
4947: LD_INT 4
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 25
4956: PUSH
4957: LD_INT 8
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PPUSH
4976: CALL_OW 69
4980: ST_TO_ADDR
// for i in tmp do
4981: LD_ADDR_VAR 0 5
4985: PUSH
4986: LD_VAR 0 2
4990: PUSH
4991: FOR_IN
4992: IFFALSE 5008
// SetTag ( i , 10 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 10
5001: PPUSH
5002: CALL_OW 109
5006: GO 4991
5008: POP
5009: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5010: LD_ADDR_VAR 0 3
5014: PUSH
5015: LD_INT 22
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 21
5027: PUSH
5028: LD_INT 1
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PPUSH
5039: CALL_OW 69
5043: PUSH
5044: LD_VAR 0 2
5048: DIFF
5049: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_INT 2
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 2
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 24
5077: PUSH
5078: LD_INT 300
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5095: LD_ADDR_VAR 0 4
5099: PUSH
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_INT 33
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: LD_INT 58
5117: PUSH
5118: EMPTY
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 72
5129: ST_TO_ADDR
// for i in tmp do
5130: LD_ADDR_VAR 0 5
5134: PUSH
5135: LD_VAR 0 2
5139: PUSH
5140: FOR_IN
5141: IFFALSE 5325
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5143: LD_VAR 0 5
5147: PUSH
5148: LD_INT 55
5150: PUSH
5151: EMPTY
5152: LIST
5153: PPUSH
5154: CALL_OW 69
5158: IN
5159: IFFALSE 5178
// begin AddComMoveXY ( i , 209 , 132 ) ;
5161: LD_VAR 0 5
5165: PPUSH
5166: LD_INT 209
5168: PPUSH
5169: LD_INT 132
5171: PPUSH
5172: CALL_OW 171
// continue ;
5176: GO 5140
// end ; if IsInUnit ( i ) then
5178: LD_VAR 0 5
5182: PPUSH
5183: CALL_OW 310
5187: IFFALSE 5205
// begin ComExitBuilding ( i ) ;
5189: LD_VAR 0 5
5193: PPUSH
5194: CALL_OW 122
// wait ( 3 ) ;
5198: LD_INT 3
5200: PPUSH
5201: CALL_OW 67
// end ; if tmp_empty then
5205: LD_VAR 0 4
5209: IFFALSE 5308
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5211: LD_VAR 0 5
5215: PPUSH
5216: LD_VAR 0 4
5220: PPUSH
5221: LD_VAR 0 5
5225: PPUSH
5226: CALL_OW 74
5230: PPUSH
5231: CALL_OW 296
5235: PUSH
5236: LD_INT 25
5238: LESS
5239: IFFALSE 5308
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5241: LD_ADDR_VAR 0 6
5245: PUSH
5246: LD_VAR 0 4
5250: PPUSH
5251: LD_VAR 0 5
5255: PPUSH
5256: CALL_OW 74
5260: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5261: LD_VAR 0 5
5265: PPUSH
5266: LD_VAR 0 6
5270: PPUSH
5271: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5275: LD_VAR 0 5
5279: PPUSH
5280: LD_INT 209
5282: PPUSH
5283: LD_INT 132
5285: PPUSH
5286: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5290: LD_ADDR_VAR 0 4
5294: PUSH
5295: LD_VAR 0 4
5299: PUSH
5300: LD_VAR 0 6
5304: DIFF
5305: ST_TO_ADDR
// continue ;
5306: GO 5140
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5308: LD_VAR 0 5
5312: PPUSH
5313: LD_INT 201
5315: PPUSH
5316: LD_INT 132
5318: PPUSH
5319: CALL_OW 171
// end ;
5323: GO 5140
5325: POP
5326: POP
// for i in tmp_ape do
5327: LD_ADDR_VAR 0 5
5331: PUSH
5332: LD_VAR 0 3
5336: PUSH
5337: FOR_IN
5338: IFFALSE 5377
// begin if IsInUnit ( i ) then
5340: LD_VAR 0 5
5344: PPUSH
5345: CALL_OW 310
5349: IFFALSE 5360
// ComExitBuilding ( i ) ;
5351: LD_VAR 0 5
5355: PPUSH
5356: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5360: LD_VAR 0 5
5364: PPUSH
5365: LD_INT 201
5367: PPUSH
5368: LD_INT 132
5370: PPUSH
5371: CALL_OW 171
// end ;
5375: GO 5337
5377: POP
5378: POP
// repeat wait ( 0 0$1 ) ;
5379: LD_INT 35
5381: PPUSH
5382: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5386: LD_ADDR_VAR 0 5
5390: PUSH
5391: LD_VAR 0 2
5395: PUSH
5396: LD_VAR 0 3
5400: UNION
5401: PUSH
5402: LD_VAR 0 1
5406: UNION
5407: PUSH
5408: FOR_IN
5409: IFFALSE 5440
// if not HasTask ( i ) then
5411: LD_VAR 0 5
5415: PPUSH
5416: CALL_OW 314
5420: NOT
5421: IFFALSE 5438
// ComMoveXY ( i , 201 , 132 ) ;
5423: LD_VAR 0 5
5427: PPUSH
5428: LD_INT 201
5430: PPUSH
5431: LD_INT 132
5433: PPUSH
5434: CALL_OW 111
5438: GO 5408
5440: POP
5441: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5442: LD_INT 21
5444: PPUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 2
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PPUSH
5455: CALL_OW 70
5459: IFFALSE 5500
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5461: LD_ADDR_VAR 0 5
5465: PUSH
5466: LD_INT 21
5468: PPUSH
5469: LD_INT 22
5471: PUSH
5472: LD_INT 2
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: CALL_OW 70
5483: PUSH
5484: FOR_IN
5485: IFFALSE 5498
// RemoveUnit ( i ) ;
5487: LD_VAR 0 5
5491: PPUSH
5492: CALL_OW 64
5496: GO 5484
5498: POP
5499: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5500: LD_INT 22
5502: PUSH
5503: LD_INT 2
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: LD_INT 21
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 21
5525: PUSH
5526: LD_INT 2
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: LIST
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PPUSH
5542: CALL_OW 69
5546: NOT
5547: IFFALSE 5379
// end ;
5549: PPOPN 6
5551: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5552: LD_EXP 9
5556: PUSH
5557: LD_INT 92
5559: PPUSH
5560: LD_INT 40
5562: PPUSH
5563: CALL_OW 428
5567: PPUSH
5568: CALL_OW 266
5572: PUSH
5573: LD_INT 30
5575: EQUAL
5576: AND
5577: IFFALSE 5773
5579: GO 5581
5581: DISABLE
5582: LD_INT 0
5584: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5585: LD_ADDR_VAR 0 1
5589: PUSH
5590: LD_EXP 59
5594: PUSH
5595: LD_INT 1
5597: ARRAY
5598: PPUSH
5599: LD_INT 25
5601: PUSH
5602: LD_INT 4
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 72
5613: ST_TO_ADDR
// if not sci then
5614: LD_VAR 0 1
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 5773
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5623: LD_ADDR_EXP 59
5627: PUSH
5628: LD_EXP 59
5632: PPUSH
5633: LD_INT 1
5635: PPUSH
5636: LD_EXP 59
5640: PUSH
5641: LD_INT 1
5643: ARRAY
5644: PUSH
5645: LD_VAR 0 1
5649: PUSH
5650: LD_INT 1
5652: ARRAY
5653: DIFF
5654: PPUSH
5655: CALL_OW 1
5659: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5660: LD_VAR 0 1
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: CALL_OW 310
5673: IFFALSE 5688
// ComExitBuilding ( sci [ 1 ] ) ;
5675: LD_VAR 0 1
5679: PUSH
5680: LD_INT 1
5682: ARRAY
5683: PPUSH
5684: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5688: LD_INT 2
5690: PPUSH
5691: LD_INT 105
5693: PPUSH
5694: LD_INT 14
5696: PPUSH
5697: LD_INT 20
5699: PPUSH
5700: CALL 20565 0 4
5704: PUSH
5705: LD_INT 4
5707: ARRAY
5708: PUSH
5709: LD_INT 10
5711: LESS
5712: IFFALSE 5735
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5714: LD_VAR 0 1
5718: PUSH
5719: LD_INT 1
5721: ARRAY
5722: PPUSH
5723: LD_INT 105
5725: PPUSH
5726: LD_INT 14
5728: PPUSH
5729: CALL_OW 171
5733: GO 5754
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5735: LD_VAR 0 1
5739: PUSH
5740: LD_INT 1
5742: ARRAY
5743: PPUSH
5744: LD_INT 118
5746: PPUSH
5747: LD_INT 77
5749: PPUSH
5750: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 1
5761: ARRAY
5762: PPUSH
5763: LD_INT 92
5765: PPUSH
5766: LD_INT 40
5768: PPUSH
5769: CALL_OW 218
// end ;
5773: PPOPN 1
5775: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5776: LD_INT 1
5778: PPUSH
5779: CALL_OW 302
5783: PUSH
5784: LD_EXP 9
5788: AND
5789: IFFALSE 6268
5791: GO 5793
5793: DISABLE
5794: LD_INT 0
5796: PPUSH
5797: PPUSH
5798: PPUSH
5799: PPUSH
5800: PPUSH
5801: PPUSH
// begin enable ;
5802: ENABLE
// base := 1 ;
5803: LD_ADDR_VAR 0 2
5807: PUSH
5808: LD_INT 1
5810: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5811: LD_ADDR_VAR 0 4
5815: PUSH
5816: LD_INT 0
5818: PUSH
5819: LD_INT 0
5821: PUSH
5822: LD_INT 0
5824: PUSH
5825: LD_INT 0
5827: PUSH
5828: LD_INT 0
5830: PUSH
5831: LD_INT 0
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 1
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5858: LD_ADDR_VAR 0 3
5862: PUSH
5863: LD_INT 14
5865: PUSH
5866: LD_INT 1
5868: PUSH
5869: LD_INT 2
5871: PUSH
5872: LD_INT 26
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 14
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 29
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5922: LD_ADDR_VAR 0 1
5926: PUSH
5927: DOUBLE
5928: LD_INT 1
5930: DEC
5931: ST_TO_ADDR
5932: LD_OWVAR 67
5936: PUSH
5937: LD_OWVAR 1
5941: PUSH
5942: LD_INT 21000
5944: DIV
5945: PLUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 6040
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5950: LD_ADDR_VAR 0 3
5954: PUSH
5955: LD_VAR 0 3
5959: PPUSH
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 1
5967: PLUS
5968: PPUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 14
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 1
5981: PPUSH
5982: LD_INT 2
5984: PPUSH
5985: CALL_OW 12
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: LD_INT 2
5996: PUSH
5997: LD_INT 28
5999: PUSH
6000: LD_INT 29
6002: PUSH
6003: LD_INT 25
6005: PUSH
6006: LD_INT 26
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 4
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PPUSH
6033: CALL_OW 2
6037: ST_TO_ADDR
6038: GO 5947
6040: POP
6041: POP
// MC_InsertProduceList ( base , tmp ) ;
6042: LD_VAR 0 2
6046: PPUSH
6047: LD_VAR 0 3
6051: PPUSH
6052: CALL 76245 0 2
// repeat wait ( 0 0$1 ) ;
6056: LD_INT 35
6058: PPUSH
6059: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6063: LD_EXP 78
6067: PUSH
6068: LD_VAR 0 2
6072: ARRAY
6073: PUSH
6074: LD_INT 6
6076: GREATER
6077: IFFALSE 6056
// wait ( 0 0$20 ) ;
6079: LD_INT 700
6081: PPUSH
6082: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6086: LD_ADDR_VAR 0 5
6090: PUSH
6091: LD_INT 124
6093: PUSH
6094: LD_INT 85
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 90
6103: PUSH
6104: LD_INT 61
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 69
6113: PUSH
6114: LD_INT 48
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 68
6123: PUSH
6124: LD_INT 48
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6137: LD_ADDR_VAR 0 6
6141: PUSH
6142: LD_EXP 78
6146: PUSH
6147: LD_VAR 0 2
6151: ARRAY
6152: PUSH
6153: LD_EXP 78
6157: PUSH
6158: LD_VAR 0 2
6162: ARRAY
6163: PPUSH
6164: LD_INT 2
6166: PUSH
6167: LD_INT 34
6169: PUSH
6170: LD_INT 32
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 34
6179: PUSH
6180: LD_EXP 109
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: DIFF
6199: ST_TO_ADDR
// if not attackers then
6200: LD_VAR 0 6
6204: NOT
6205: IFFALSE 6209
// exit ;
6207: GO 6268
// ar_attackers := attackers ;
6209: LD_ADDR_EXP 10
6213: PUSH
6214: LD_VAR 0 6
6218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6219: LD_INT 35
6221: PPUSH
6222: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6226: LD_VAR 0 6
6230: PPUSH
6231: LD_INT 60
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL_OW 72
6241: NOT
6242: IFFALSE 6219
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6244: LD_VAR 0 2
6248: PPUSH
6249: LD_VAR 0 6
6253: PPUSH
6254: LD_VAR 0 5
6258: PPUSH
6259: LD_VAR 0 4
6263: PPUSH
6264: CALL 76430 0 4
// end ;
6268: PPOPN 6
6270: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 302
6278: PUSH
6279: LD_EXP 9
6283: AND
6284: PUSH
6285: LD_EXP 49
6289: PPUSH
6290: LD_INT 22
6292: PPUSH
6293: CALL_OW 308
6297: AND
6298: PUSH
6299: LD_INT 1
6301: PPUSH
6302: CALL 76593 0 1
6306: PUSH
6307: LD_INT 0
6309: EQUAL
6310: AND
6311: PUSH
6312: LD_EXP 10
6316: NOT
6317: AND
6318: IFFALSE 6802
6320: GO 6322
6322: DISABLE
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
6330: PPUSH
6331: PPUSH
// begin base := 1 ;
6332: LD_ADDR_VAR 0 2
6336: PUSH
6337: LD_INT 1
6339: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6340: LD_ADDR_VAR 0 4
6344: PUSH
6345: LD_INT 0
6347: PUSH
6348: LD_INT 0
6350: PUSH
6351: LD_INT 0
6353: PUSH
6354: LD_INT 0
6356: PUSH
6357: LD_INT 0
6359: PUSH
6360: LD_INT 0
6362: PUSH
6363: LD_INT 0
6365: PUSH
6366: LD_INT 0
6368: PUSH
6369: LD_INT 1
6371: PUSH
6372: LD_INT 0
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: LIST
6385: LIST
6386: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6387: LD_ADDR_VAR 0 3
6391: PUSH
6392: LD_INT 13
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 28
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 13
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 27
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 25
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 11
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 24
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6489: LD_VAR 0 2
6493: PPUSH
6494: LD_VAR 0 3
6498: PPUSH
6499: CALL 76245 0 2
// repeat wait ( 0 0$1 ) ;
6503: LD_INT 35
6505: PPUSH
6506: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6510: LD_EXP 78
6514: PUSH
6515: LD_VAR 0 2
6519: ARRAY
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: IFFALSE 6503
// wait ( 0 0$20 ) ;
6526: LD_INT 700
6528: PPUSH
6529: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6533: LD_ADDR_VAR 0 5
6537: PUSH
6538: LD_INT 119
6540: PUSH
6541: LD_INT 9
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PUSH
6548: EMPTY
6549: LIST
6550: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6551: LD_ADDR_VAR 0 6
6555: PUSH
6556: LD_EXP 78
6560: PUSH
6561: LD_VAR 0 2
6565: ARRAY
6566: PUSH
6567: LD_EXP 78
6571: PUSH
6572: LD_VAR 0 2
6576: ARRAY
6577: PPUSH
6578: LD_INT 2
6580: PUSH
6581: LD_INT 34
6583: PUSH
6584: LD_INT 32
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 34
6593: PUSH
6594: LD_EXP 109
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: PPUSH
6608: CALL_OW 72
6612: DIFF
6613: ST_TO_ADDR
// if not attackers then
6614: LD_VAR 0 6
6618: NOT
6619: IFFALSE 6623
// exit ;
6621: GO 6802
// uc_side := 2 ;
6623: LD_ADDR_OWVAR 20
6627: PUSH
6628: LD_INT 2
6630: ST_TO_ADDR
// uc_nation := 2 ;
6631: LD_ADDR_OWVAR 21
6635: PUSH
6636: LD_INT 2
6638: ST_TO_ADDR
// InitHc ;
6639: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6643: LD_ADDR_VAR 0 1
6647: PUSH
6648: DOUBLE
6649: LD_INT 1
6651: DEC
6652: ST_TO_ADDR
6653: LD_INT 4
6655: PUSH
6656: LD_INT 5
6658: PUSH
6659: LD_INT 6
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: PUSH
6667: LD_OWVAR 67
6671: ARRAY
6672: PUSH
6673: FOR_TO
6674: IFFALSE 6751
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6676: LD_INT 0
6678: PPUSH
6679: LD_INT 15
6681: PUSH
6682: LD_INT 17
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 2
6694: PPUSH
6695: CALL_OW 12
6699: ARRAY
6700: PPUSH
6701: LD_INT 8
6703: PPUSH
6704: CALL_OW 380
// un := CreateHuman ;
6708: LD_ADDR_VAR 0 7
6712: PUSH
6713: CALL_OW 44
6717: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6718: LD_VAR 0 7
6722: PPUSH
6723: LD_INT 23
6725: PPUSH
6726: LD_INT 0
6728: PPUSH
6729: CALL_OW 49
// attackers := attackers union un ;
6733: LD_ADDR_VAR 0 6
6737: PUSH
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 7
6747: UNION
6748: ST_TO_ADDR
// end ;
6749: GO 6673
6751: POP
6752: POP
// repeat wait ( 0 0$1 ) ;
6753: LD_INT 35
6755: PPUSH
6756: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_INT 60
6767: PUSH
6768: EMPTY
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: NOT
6776: IFFALSE 6753
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6778: LD_VAR 0 2
6782: PPUSH
6783: LD_VAR 0 6
6787: PPUSH
6788: LD_VAR 0 5
6792: PPUSH
6793: LD_VAR 0 4
6797: PPUSH
6798: CALL 76430 0 4
// end ; end_of_file
6802: PPOPN 7
6804: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6805: LD_INT 0
6807: PPUSH
6808: PPUSH
6809: PPUSH
6810: PPUSH
6811: PPUSH
6812: PPUSH
// uc_side := 1 ;
6813: LD_ADDR_OWVAR 20
6817: PUSH
6818: LD_INT 1
6820: ST_TO_ADDR
// uc_nation := 1 ;
6821: LD_ADDR_OWVAR 21
6825: PUSH
6826: LD_INT 1
6828: ST_TO_ADDR
// InitHc ;
6829: CALL_OW 19
// InitVc ;
6833: CALL_OW 20
// tmp := [ ] ;
6837: LD_ADDR_VAR 0 3
6841: PUSH
6842: EMPTY
6843: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 ] [ Difficulty ] do
6844: LD_ADDR_VAR 0 2
6848: PUSH
6849: DOUBLE
6850: LD_INT 1
6852: DEC
6853: ST_TO_ADDR
6854: LD_INT 6
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: LD_INT 10
6862: PUSH
6863: EMPTY
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_OWVAR 67
6872: ARRAY
6873: PUSH
6874: FOR_TO
6875: IFFALSE 7149
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6877: LD_ADDR_VAR 0 5
6881: PUSH
6882: LD_INT 2
6884: PUSH
6885: LD_INT 4
6887: PUSH
6888: LD_INT 5
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 1
6898: PPUSH
6899: LD_INT 3
6901: PPUSH
6902: CALL_OW 12
6906: ARRAY
6907: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6908: LD_VAR 0 5
6912: PUSH
6913: LD_INT 2
6915: DOUBLE
6916: EQUAL
6917: IFTRUE 6921
6919: GO 6955
6921: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6922: LD_ADDR_VAR 0 6
6926: PUSH
6927: LD_INT 9
6929: PUSH
6930: LD_INT 5
6932: PUSH
6933: LD_INT 7
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 1
6943: PPUSH
6944: LD_INT 3
6946: PPUSH
6947: CALL_OW 12
6951: ARRAY
6952: ST_TO_ADDR
6953: GO 7044
6955: LD_INT 4
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 7001
6963: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: LD_INT 9
6971: PUSH
6972: LD_INT 6
6974: PUSH
6975: LD_INT 6
6977: PUSH
6978: LD_INT 7
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: LD_INT 1
6989: PPUSH
6990: LD_INT 4
6992: PPUSH
6993: CALL_OW 12
6997: ARRAY
6998: ST_TO_ADDR
6999: GO 7044
7001: LD_INT 5
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7043
7009: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7010: LD_ADDR_VAR 0 6
7014: PUSH
7015: LD_INT 9
7017: PUSH
7018: LD_INT 6
7020: PUSH
7021: LD_INT 7
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: LIST
7028: PUSH
7029: LD_INT 1
7031: PPUSH
7032: LD_INT 3
7034: PPUSH
7035: CALL_OW 12
7039: ARRAY
7040: ST_TO_ADDR
7041: GO 7044
7043: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7044: LD_VAR 0 5
7048: PPUSH
7049: LD_INT 1
7051: PUSH
7052: LD_INT 3
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 1
7061: PPUSH
7062: LD_INT 2
7064: PPUSH
7065: CALL_OW 12
7069: ARRAY
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_VAR 0 6
7078: PPUSH
7079: LD_INT 70
7081: PPUSH
7082: LD_INT 90
7084: PPUSH
7085: CALL_OW 12
7089: PPUSH
7090: CALL 19547 0 5
// veh := CreateVehicle ;
7094: LD_ADDR_VAR 0 4
7098: PUSH
7099: CALL_OW 45
7103: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7104: LD_VAR 0 4
7108: PPUSH
7109: LD_INT 2
7111: PPUSH
7112: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7116: LD_VAR 0 4
7120: PPUSH
7121: LD_INT 17
7123: PPUSH
7124: LD_INT 0
7126: PPUSH
7127: CALL_OW 49
// tmp := tmp ^ veh ;
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: LD_VAR 0 3
7140: PUSH
7141: LD_VAR 0 4
7145: ADD
7146: ST_TO_ADDR
// end ;
7147: GO 6874
7149: POP
7150: POP
// if not tmp then
7151: LD_VAR 0 3
7155: NOT
7156: IFFALSE 7160
// exit ;
7158: GO 7269
// if not first_powell_attack then
7160: LD_EXP 11
7164: NOT
7165: IFFALSE 7175
// first_powell_attack := true ;
7167: LD_ADDR_EXP 11
7171: PUSH
7172: LD_INT 1
7174: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7175: LD_INT 70
7177: PPUSH
7178: CALL_OW 67
// for i in tmp do
7182: LD_ADDR_VAR 0 2
7186: PUSH
7187: LD_VAR 0 3
7191: PUSH
7192: FOR_IN
7193: IFFALSE 7260
// if IsOk ( i ) then
7195: LD_VAR 0 2
7199: PPUSH
7200: CALL_OW 302
7204: IFFALSE 7242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7206: LD_VAR 0 2
7210: PPUSH
7211: LD_INT 81
7213: PUSH
7214: LD_INT 1
7216: PUSH
7217: EMPTY
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: LD_VAR 0 2
7230: PPUSH
7231: CALL_OW 74
7235: PPUSH
7236: CALL_OW 115
7240: GO 7258
// tmp := tmp diff i ;
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: LD_VAR 0 3
7251: PUSH
7252: LD_VAR 0 2
7256: DIFF
7257: ST_TO_ADDR
7258: GO 7192
7260: POP
7261: POP
// until not tmp ;
7262: LD_VAR 0 3
7266: NOT
7267: IFFALSE 7175
// end ; end_of_file
7269: LD_VAR 0 1
7273: RET
// export function Action ; var tmp , i , un ; begin
7274: LD_INT 0
7276: PPUSH
7277: PPUSH
7278: PPUSH
7279: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7280: LD_INT 68
7282: PPUSH
7283: LD_INT 39
7285: PPUSH
7286: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: PPUSH
7305: CALL_OW 69
7309: ST_TO_ADDR
// InGameOn ;
7310: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7314: LD_VAR 0 2
7318: PPUSH
7319: LD_INT 71
7321: PPUSH
7322: LD_INT 49
7324: PPUSH
7325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7329: LD_INT 35
7331: PPUSH
7332: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7336: LD_INT 7
7338: PPUSH
7339: LD_INT 71
7341: PPUSH
7342: LD_INT 51
7344: PPUSH
7345: CALL_OW 293
7349: IFFALSE 7329
// DialogueOn ;
7351: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7355: LD_EXP 15
7359: PPUSH
7360: LD_STRING D1-JMM-1
7362: PPUSH
7363: CALL_OW 88
// if Joan then
7367: LD_EXP 30
7371: IFFALSE 7385
// Say ( Joan , D1-Joan-1 ) ;
7373: LD_EXP 30
7377: PPUSH
7378: LD_STRING D1-Joan-1
7380: PPUSH
7381: CALL_OW 88
// if Lisa then
7385: LD_EXP 17
7389: IFFALSE 7403
// Say ( Lisa , D1-Lisa-1 ) ;
7391: LD_EXP 17
7395: PPUSH
7396: LD_STRING D1-Lisa-1
7398: PPUSH
7399: CALL_OW 88
// if Joan or Lisa then
7403: LD_EXP 30
7407: PUSH
7408: LD_EXP 17
7412: OR
7413: IFFALSE 7427
// Say ( JMM , D1-JMM-2 ) ;
7415: LD_EXP 15
7419: PPUSH
7420: LD_STRING D1-JMM-2
7422: PPUSH
7423: CALL_OW 88
// DialogueOff ;
7427: CALL_OW 7
// InGameOff ;
7431: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7435: LD_INT 71
7437: PPUSH
7438: LD_INT 50
7440: PPUSH
7441: LD_INT 7
7443: PPUSH
7444: LD_INT 30
7446: NEG
7447: PPUSH
7448: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7452: LD_INT 71
7454: PPUSH
7455: LD_INT 50
7457: PPUSH
7458: LD_INT 7
7460: PPUSH
7461: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7465: LD_STRING M1
7467: PPUSH
7468: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7472: LD_INT 35
7474: PPUSH
7475: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7479: LD_EXP 3
7483: PUSH
7484: LD_OWVAR 1
7488: PUSH
7489: LD_INT 2100
7491: GREATER
7492: OR
7493: IFFALSE 7472
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7495: LD_INT 350
7497: PPUSH
7498: LD_INT 700
7500: PPUSH
7501: CALL_OW 12
7505: PPUSH
7506: CALL_OW 67
// PrepareGossudarov ;
7510: CALL 1865 0 0
// repeat wait ( 0 0$1 ) ;
7514: LD_INT 35
7516: PPUSH
7517: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7521: LD_INT 22
7523: PUSH
7524: LD_INT 6
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: PUSH
7531: LD_INT 3
7533: PUSH
7534: LD_INT 24
7536: PUSH
7537: LD_INT 1000
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PPUSH
7552: CALL_OW 69
7556: PUSH
7557: LD_INT 7
7559: PPUSH
7560: LD_EXP 32
7564: PPUSH
7565: CALL_OW 292
7569: OR
7570: IFFALSE 7514
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7572: LD_ADDR_VAR 0 2
7576: PUSH
7577: LD_INT 22
7579: PUSH
7580: LD_INT 6
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 69
7591: ST_TO_ADDR
// for i in tmp do
7592: LD_ADDR_VAR 0 3
7596: PUSH
7597: LD_VAR 0 2
7601: PUSH
7602: FOR_IN
7603: IFFALSE 7619
// SetSide ( i , 7 ) ;
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 7
7612: PPUSH
7613: CALL_OW 235
7617: GO 7602
7619: POP
7620: POP
// DialogueOn ;
7621: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7625: LD_EXP 15
7629: PUSH
7630: LD_EXP 16
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: LD_EXP 32
7643: PPUSH
7644: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7648: LD_EXP 32
7652: PPUSH
7653: CALL_OW 87
// if not Roth then
7657: LD_EXP 16
7661: NOT
7662: IFFALSE 7754
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7664: LD_VAR 0 2
7668: PPUSH
7669: LD_INT 3
7671: PUSH
7672: LD_INT 24
7674: PUSH
7675: LD_INT 1000
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PPUSH
7686: CALL_OW 72
7690: IFFALSE 7704
// Say ( JMM , D2-JMM-1 ) ;
7692: LD_EXP 15
7696: PPUSH
7697: LD_STRING D2-JMM-1
7699: PPUSH
7700: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7704: LD_EXP 15
7708: PPUSH
7709: LD_STRING D2-JMM-1b
7711: PPUSH
7712: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7716: LD_EXP 32
7720: PPUSH
7721: LD_STRING D2-Gos-1
7723: PPUSH
7724: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7728: LD_EXP 15
7732: PPUSH
7733: LD_STRING D2-JMM-2
7735: PPUSH
7736: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7740: LD_EXP 32
7744: PPUSH
7745: LD_STRING D2-Gos-2
7747: PPUSH
7748: CALL_OW 88
// end else
7752: GO 7906
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7754: LD_VAR 0 2
7758: PPUSH
7759: LD_INT 3
7761: PUSH
7762: LD_INT 24
7764: PUSH
7765: LD_INT 1000
7767: PUSH
7768: EMPTY
7769: LIST
7770: LIST
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PPUSH
7776: CALL_OW 72
7780: IFFALSE 7806
// begin Say ( Roth , D2-Roth-2 ) ;
7782: LD_EXP 16
7786: PPUSH
7787: LD_STRING D2-Roth-2
7789: PPUSH
7790: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7794: LD_EXP 15
7798: PPUSH
7799: LD_STRING D2-JMM-1a
7801: PPUSH
7802: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7806: LD_EXP 16
7810: PPUSH
7811: LD_STRING D2-Roth-2a
7813: PPUSH
7814: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7818: LD_EXP 16
7822: PPUSH
7823: LD_STRING D2-Roth-2b
7825: PPUSH
7826: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7830: LD_EXP 15
7834: PPUSH
7835: LD_STRING D2-JMM-3
7837: PPUSH
7838: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7842: LD_VAR 0 2
7846: PPUSH
7847: LD_INT 3
7849: PUSH
7850: LD_INT 24
7852: PUSH
7853: LD_INT 1000
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PPUSH
7864: CALL_OW 72
7868: IFFALSE 7906
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7870: LD_EXP 32
7874: PPUSH
7875: LD_STRING D2-Gos-3
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7882: LD_EXP 15
7886: PPUSH
7887: LD_STRING D2-JMM-4
7889: PPUSH
7890: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7894: LD_EXP 32
7898: PPUSH
7899: LD_STRING D2-Gos-4
7901: PPUSH
7902: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7906: LD_EXP 15
7910: PPUSH
7911: LD_STRING D2-JMM-5
7913: PPUSH
7914: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7918: LD_EXP 32
7922: PPUSH
7923: LD_STRING D2-Gos-5
7925: PPUSH
7926: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7930: LD_EXP 15
7934: PPUSH
7935: LD_STRING D2-JMM-6
7937: PPUSH
7938: CALL_OW 88
// DialogueOff ;
7942: CALL_OW 7
// wait ( 0 0$2 ) ;
7946: LD_INT 70
7948: PPUSH
7949: CALL_OW 67
// if Kirilenkova then
7953: LD_EXP 33
7957: IFFALSE 7971
// Say ( Kirilenkova , D3-Kir-1 ) ;
7959: LD_EXP 33
7963: PPUSH
7964: LD_STRING D3-Kir-1
7966: PPUSH
7967: CALL_OW 88
// gossudarov_arrive := true ;
7971: LD_ADDR_EXP 4
7975: PUSH
7976: LD_INT 1
7978: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7979: LD_INT 35
7981: PPUSH
7982: CALL_OW 67
// until ru_lab_builded ;
7986: LD_EXP 5
7990: IFFALSE 7979
// DialogueOn ;
7992: CALL_OW 6
// if Kirilenkova then
7996: LD_EXP 33
8000: IFFALSE 8016
// Say ( Kirilenkova , D3a-Kir-1 ) else
8002: LD_EXP 33
8006: PPUSH
8007: LD_STRING D3a-Kir-1
8009: PPUSH
8010: CALL_OW 88
8014: GO 8038
// begin un := SciRu ;
8016: LD_ADDR_VAR 0 4
8020: PUSH
8021: CALL 13150 0 0
8025: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8026: LD_VAR 0 4
8030: PPUSH
8031: LD_STRING D3a-Sci1-1
8033: PPUSH
8034: CALL_OW 88
// end ; if Kirilenkova or un then
8038: LD_EXP 33
8042: PUSH
8043: LD_VAR 0 4
8047: OR
8048: IFFALSE 8062
// Say ( JMM , D3a-JMM-1 ) ;
8050: LD_EXP 15
8054: PPUSH
8055: LD_STRING D3a-JMM-1
8057: PPUSH
8058: CALL_OW 88
// DialogueOff ;
8062: CALL_OW 7
// end ;
8066: LD_VAR 0 1
8070: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8071: LD_EXP 4
8075: PUSH
8076: LD_INT 22
8078: PUSH
8079: LD_INT 7
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: PUSH
8086: LD_INT 2
8088: PUSH
8089: LD_INT 25
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 25
8101: PUSH
8102: LD_INT 2
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 25
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: LD_INT 25
8121: PUSH
8122: LD_INT 4
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: LD_INT 25
8131: PUSH
8132: LD_INT 5
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_INT 25
8141: PUSH
8142: LD_INT 8
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 25
8151: PUSH
8152: LD_INT 9
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 7
8180: LESS
8181: AND
8182: IFFALSE 8194
8184: GO 8186
8186: DISABLE
// YouLost ( TooMany ) ;
8187: LD_STRING TooMany
8189: PPUSH
8190: CALL_OW 104
8194: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8195: LD_EXP 32
8199: PPUSH
8200: CALL_OW 255
8204: PUSH
8205: LD_INT 7
8207: EQUAL
8208: IFFALSE 8408
8210: GO 8212
8212: DISABLE
8213: LD_INT 0
8215: PPUSH
8216: PPUSH
8217: PPUSH
// begin uc_side := 3 ;
8218: LD_ADDR_OWVAR 20
8222: PUSH
8223: LD_INT 3
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8234: LD_INT 21
8236: PPUSH
8237: LD_INT 3
8239: PPUSH
8240: LD_INT 3
8242: PPUSH
8243: LD_INT 42
8245: PPUSH
8246: LD_INT 100
8248: PPUSH
8249: CALL 19547 0 5
// un := CreateVehicle ;
8253: LD_ADDR_VAR 0 3
8257: PUSH
8258: CALL_OW 45
8262: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8263: LD_VAR 0 3
8267: PPUSH
8268: LD_INT 15
8270: PPUSH
8271: LD_INT 0
8273: PPUSH
8274: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8278: LD_VAR 0 3
8282: PPUSH
8283: LD_INT 67
8285: PPUSH
8286: LD_INT 45
8288: PPUSH
8289: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8293: LD_VAR 0 3
8297: PPUSH
8298: LD_INT 70
8300: PPUSH
8301: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8305: LD_VAR 0 3
8309: PPUSH
8310: LD_INT 69
8312: PPUSH
8313: LD_INT 18
8315: PPUSH
8316: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
8320: LD_VAR 0 3
8324: PPUSH
8325: LD_INT 60
8327: PPUSH
8328: LD_INT 2
8330: PPUSH
8331: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8335: LD_INT 35
8337: PPUSH
8338: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
8342: LD_VAR 0 3
8346: PPUSH
8347: CALL_OW 302
8351: NOT
8352: PUSH
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 17
8360: PPUSH
8361: CALL_OW 308
8365: OR
8366: IFFALSE 8335
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
8368: LD_VAR 0 3
8372: PPUSH
8373: LD_INT 17
8375: PPUSH
8376: CALL_OW 308
8380: PUSH
8381: LD_VAR 0 3
8385: PPUSH
8386: LD_INT 60
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 307
8396: OR
8397: IFFALSE 8408
// RemoveUnit ( un ) ;
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 64
// end ;
8408: PPOPN 3
8410: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8411: LD_EXP 4
8415: IFFALSE 8657
8417: GO 8419
8419: DISABLE
8420: LD_INT 0
8422: PPUSH
8423: PPUSH
8424: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8425: LD_INT 70
8427: PPUSH
8428: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8432: LD_ADDR_VAR 0 3
8436: PUSH
8437: LD_INT 22
8439: PUSH
8440: LD_INT 7
8442: PUSH
8443: EMPTY
8444: LIST
8445: LIST
8446: PUSH
8447: LD_INT 101
8449: PUSH
8450: LD_INT 3
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: PUSH
8457: EMPTY
8458: LIST
8459: LIST
8460: PPUSH
8461: CALL_OW 69
8465: ST_TO_ADDR
// until tmp ;
8466: LD_VAR 0 3
8470: IFFALSE 8425
// un := NearestUnitToUnit ( tmp , JMM ) ;
8472: LD_ADDR_VAR 0 2
8476: PUSH
8477: LD_VAR 0 3
8481: PPUSH
8482: LD_EXP 15
8486: PPUSH
8487: CALL_OW 74
8491: ST_TO_ADDR
// player_spotted := true ;
8492: LD_ADDR_EXP 6
8496: PUSH
8497: LD_INT 1
8499: ST_TO_ADDR
// tmp := SciRu ;
8500: LD_ADDR_VAR 0 3
8504: PUSH
8505: CALL 13150 0 0
8509: ST_TO_ADDR
// if not tmp then
8510: LD_VAR 0 3
8514: NOT
8515: IFFALSE 8527
// tmp := SolRu ;
8517: LD_ADDR_VAR 0 3
8521: PUSH
8522: CALL 13297 0 0
8526: ST_TO_ADDR
// DialogueOn ;
8527: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8531: LD_VAR 0 2
8535: PPUSH
8536: CALL_OW 250
8540: PPUSH
8541: LD_VAR 0 2
8545: PPUSH
8546: CALL_OW 251
8550: PPUSH
8551: LD_INT 7
8553: PPUSH
8554: LD_INT 8
8556: NEG
8557: PPUSH
8558: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8562: LD_VAR 0 2
8566: PPUSH
8567: CALL_OW 87
// if tmp then
8571: LD_VAR 0 3
8575: IFFALSE 8589
// Say ( tmp , D4-RSci1-1 ) ;
8577: LD_VAR 0 3
8581: PPUSH
8582: LD_STRING D4-RSci1-1
8584: PPUSH
8585: CALL_OW 88
// if Gossudarov then
8589: LD_EXP 32
8593: IFFALSE 8619
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8595: LD_EXP 32
8599: PPUSH
8600: LD_STRING D4-Gos-1
8602: PPUSH
8603: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8607: LD_EXP 15
8611: PPUSH
8612: LD_STRING D4-JMM-1
8614: PPUSH
8615: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8619: LD_VAR 0 2
8623: PPUSH
8624: CALL_OW 250
8628: PPUSH
8629: LD_VAR 0 2
8633: PPUSH
8634: CALL_OW 251
8638: PPUSH
8639: LD_INT 7
8641: PPUSH
8642: CALL_OW 331
// DialogueOff ;
8646: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8650: LD_STRING M5
8652: PPUSH
8653: CALL_OW 337
// end ;
8657: PPOPN 3
8659: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8660: LD_EXP 6
8664: IFFALSE 9253
8666: GO 8668
8668: DISABLE
8669: LD_INT 0
8671: PPUSH
8672: PPUSH
8673: PPUSH
// begin PrepareBelkov ;
8674: CALL 2178 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8678: LD_EXP 47
8682: PPUSH
8683: LD_INT 118
8685: PPUSH
8686: LD_INT 106
8688: PPUSH
8689: CALL_OW 111
// AddComHold ( Belkov ) ;
8693: LD_EXP 47
8697: PPUSH
8698: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8702: LD_INT 35
8704: PPUSH
8705: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8709: LD_EXP 47
8713: PPUSH
8714: LD_INT 118
8716: PPUSH
8717: LD_INT 106
8719: PPUSH
8720: CALL_OW 307
8724: IFFALSE 8702
// ChangeSideFog ( 4 , 7 ) ;
8726: LD_INT 4
8728: PPUSH
8729: LD_INT 7
8731: PPUSH
8732: CALL_OW 343
// if IsOk ( Belkov ) then
8736: LD_EXP 47
8740: PPUSH
8741: CALL_OW 302
8745: IFFALSE 8829
// begin InGameOn ;
8747: CALL_OW 8
// DialogueOn ;
8751: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8755: LD_EXP 47
8759: PPUSH
8760: LD_STRING D5-Bel-1
8762: PPUSH
8763: CALL_OW 94
// if Gossudarov then
8767: LD_EXP 32
8771: IFFALSE 8821
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8773: LD_EXP 32
8777: PPUSH
8778: LD_STRING D5-Gos-1
8780: PPUSH
8781: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8785: LD_EXP 15
8789: PPUSH
8790: LD_STRING D5-JMM-1
8792: PPUSH
8793: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8797: LD_EXP 32
8801: PPUSH
8802: LD_STRING D5-Gos-2
8804: PPUSH
8805: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8809: LD_EXP 15
8813: PPUSH
8814: LD_STRING D5-JMM-2
8816: PPUSH
8817: CALL_OW 88
// end ; DialogueOff ;
8821: CALL_OW 7
// InGameOff ;
8825: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8829: LD_STRING QSaveBelkov
8831: PPUSH
8832: CALL_OW 97
8836: PUSH
8837: LD_INT 1
8839: DOUBLE
8840: EQUAL
8841: IFTRUE 8845
8843: GO 8895
8845: POP
// begin DialogueOn ;
8846: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8850: LD_EXP 15
8854: PPUSH
8855: LD_STRING D5a-JMM-1
8857: PPUSH
8858: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8862: LD_EXP 47
8866: PPUSH
8867: LD_STRING D5a-Bel-1
8869: PPUSH
8870: CALL_OW 94
// DialogueOff ;
8874: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8878: LD_EXP 47
8882: PPUSH
8883: LD_INT 83
8885: PPUSH
8886: LD_INT 49
8888: PPUSH
8889: CALL_OW 111
// end ; 2 :
8893: GO 8928
8895: LD_INT 2
8897: DOUBLE
8898: EQUAL
8899: IFTRUE 8903
8901: GO 8927
8903: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8904: LD_EXP 15
8908: PPUSH
8909: LD_STRING D5a-JMM-2
8911: PPUSH
8912: CALL_OW 88
// ComHold ( Belkov ) ;
8916: LD_EXP 47
8920: PPUSH
8921: CALL_OW 140
// end ; end ;
8925: GO 8928
8927: POP
// time := 0 0$00 ;
8928: LD_ADDR_VAR 0 1
8932: PUSH
8933: LD_INT 0
8935: ST_TO_ADDR
// vehSpawned := false ;
8936: LD_ADDR_VAR 0 3
8940: PUSH
8941: LD_INT 0
8943: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8944: LD_INT 35
8946: PPUSH
8947: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8951: LD_VAR 0 1
8955: PUSH
8956: LD_INT 350
8958: PUSH
8959: LD_INT 175
8961: PUSH
8962: LD_INT 70
8964: PUSH
8965: EMPTY
8966: LIST
8967: LIST
8968: LIST
8969: PUSH
8970: LD_OWVAR 67
8974: ARRAY
8975: GREATEREQUAL
8976: PUSH
8977: LD_VAR 0 3
8981: NOT
8982: AND
8983: IFFALSE 9073
// begin vehSpawned := true ;
8985: LD_ADDR_VAR 0 3
8989: PUSH
8990: LD_INT 1
8992: ST_TO_ADDR
// uc_side := 3 ;
8993: LD_ADDR_OWVAR 20
8997: PUSH
8998: LD_INT 3
9000: ST_TO_ADDR
// uc_nation := 3 ;
9001: LD_ADDR_OWVAR 21
9005: PUSH
9006: LD_INT 3
9008: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9009: LD_INT 22
9011: PPUSH
9012: LD_INT 3
9014: PPUSH
9015: LD_INT 3
9017: PPUSH
9018: LD_INT 43
9020: PPUSH
9021: LD_INT 100
9023: PPUSH
9024: CALL 19547 0 5
// veh := CreateVehicle ;
9028: LD_ADDR_VAR 0 2
9032: PUSH
9033: CALL_OW 45
9037: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9038: LD_VAR 0 2
9042: PPUSH
9043: LD_INT 130
9045: PPUSH
9046: LD_INT 131
9048: PPUSH
9049: LD_INT 0
9051: PPUSH
9052: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9056: LD_VAR 0 2
9060: PPUSH
9061: LD_INT 100
9063: PPUSH
9064: LD_INT 82
9066: PPUSH
9067: CALL_OW 114
// end else
9071: GO 9087
// time := time + 0 0$1 ;
9073: LD_ADDR_VAR 0 1
9077: PUSH
9078: LD_VAR 0 1
9082: PUSH
9083: LD_INT 35
9085: PLUS
9086: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9087: LD_EXP 47
9091: PPUSH
9092: CALL_OW 301
9096: PUSH
9097: LD_EXP 47
9101: PPUSH
9102: CALL_OW 255
9106: PUSH
9107: LD_INT 4
9109: EQUAL
9110: AND
9111: PUSH
9112: LD_INT 22
9114: PUSH
9115: LD_INT 7
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PPUSH
9122: CALL_OW 69
9126: PPUSH
9127: LD_EXP 47
9131: PPUSH
9132: CALL_OW 74
9136: PPUSH
9137: LD_EXP 47
9141: PPUSH
9142: CALL_OW 296
9146: PUSH
9147: LD_INT 10
9149: LESS
9150: OR
9151: IFFALSE 8944
// if IsDead ( Belkov ) then
9153: LD_EXP 47
9157: PPUSH
9158: CALL_OW 301
9162: IFFALSE 9187
// begin CenterNowOnUnits ( Belkov ) ;
9164: LD_EXP 47
9168: PPUSH
9169: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9173: LD_EXP 15
9177: PPUSH
9178: LD_STRING D5a-JMM-2a
9180: PPUSH
9181: CALL_OW 88
// exit ;
9185: GO 9253
// end ; if See ( 7 , Belkov ) then
9187: LD_INT 7
9189: PPUSH
9190: LD_EXP 47
9194: PPUSH
9195: CALL_OW 292
9199: IFFALSE 9213
// SetSide ( Belkov , 7 ) ;
9201: LD_EXP 47
9205: PPUSH
9206: LD_INT 7
9208: PPUSH
9209: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9213: LD_INT 35
9215: PPUSH
9216: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9220: LD_EXP 47
9224: PPUSH
9225: LD_INT 66
9227: PPUSH
9228: LD_INT 45
9230: PPUSH
9231: CALL_OW 297
9235: PUSH
9236: LD_INT 30
9238: LESS
9239: IFFALSE 9213
// Say ( Belkov , D6-Bel-1 ) ;
9241: LD_EXP 47
9245: PPUSH
9246: LD_STRING D6-Bel-1
9248: PPUSH
9249: CALL_OW 88
// end ;
9253: PPOPN 3
9255: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9256: LD_EXP 47
9260: PPUSH
9261: CALL_OW 302
9265: PUSH
9266: LD_EXP 47
9270: PPUSH
9271: CALL_OW 504
9275: PUSH
9276: LD_INT 2
9278: PUSH
9279: LD_INT 34
9281: PUSH
9282: LD_INT 47
9284: PUSH
9285: EMPTY
9286: LIST
9287: LIST
9288: PUSH
9289: LD_INT 34
9291: PUSH
9292: LD_INT 45
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: PUSH
9299: EMPTY
9300: LIST
9301: LIST
9302: LIST
9303: PPUSH
9304: CALL_OW 69
9308: IN
9309: AND
9310: IFFALSE 9327
9312: GO 9314
9314: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9315: LD_EXP 47
9319: PPUSH
9320: LD_STRING D7-Bel-1
9322: PPUSH
9323: CALL_OW 88
9327: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9328: LD_INT 22
9330: PUSH
9331: LD_INT 7
9333: PUSH
9334: EMPTY
9335: LIST
9336: LIST
9337: PUSH
9338: LD_INT 101
9340: PUSH
9341: LD_INT 2
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL_OW 69
9356: PUSH
9357: LD_EXP 8
9361: NOT
9362: AND
9363: PUSH
9364: LD_EXP 46
9368: PPUSH
9369: CALL_OW 305
9373: NOT
9374: AND
9375: IFFALSE 9845
9377: GO 9379
9379: DISABLE
9380: LD_INT 0
9382: PPUSH
// begin ar_base_spotted := true ;
9383: LD_ADDR_EXP 8
9387: PUSH
9388: LD_INT 1
9390: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9391: LD_ADDR_VAR 0 1
9395: PUSH
9396: LD_INT 22
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: LD_INT 21
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 69
9424: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9425: LD_ADDR_VAR 0 1
9429: PUSH
9430: LD_VAR 0 1
9434: PPUSH
9435: LD_EXP 15
9439: PPUSH
9440: CALL_OW 74
9444: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9445: LD_INT 7
9447: PPUSH
9448: LD_INT 3
9450: PPUSH
9451: CALL_OW 332
// DialogueOn ;
9455: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9459: LD_VAR 0 1
9463: PPUSH
9464: CALL_OW 250
9468: PPUSH
9469: LD_VAR 0 1
9473: PPUSH
9474: CALL_OW 251
9478: PPUSH
9479: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9483: LD_ADDR_VAR 0 1
9487: PUSH
9488: LD_INT 22
9490: PUSH
9491: LD_INT 7
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 23
9500: PUSH
9501: LD_INT 1
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 26
9510: PUSH
9511: LD_INT 1
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: PPUSH
9523: CALL_OW 69
9527: PUSH
9528: LD_EXP 15
9532: PUSH
9533: LD_EXP 19
9537: PUSH
9538: LD_EXP 20
9542: PUSH
9543: LD_EXP 27
9547: PUSH
9548: LD_EXP 16
9552: PUSH
9553: LD_EXP 25
9557: PUSH
9558: LD_EXP 21
9562: PUSH
9563: LD_EXP 23
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: DIFF
9578: ST_TO_ADDR
// if not tmp then
9579: LD_VAR 0 1
9583: NOT
9584: IFFALSE 9658
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9586: LD_ADDR_VAR 0 1
9590: PUSH
9591: LD_INT 22
9593: PUSH
9594: LD_INT 7
9596: PUSH
9597: EMPTY
9598: LIST
9599: LIST
9600: PUSH
9601: LD_INT 23
9603: PUSH
9604: LD_INT 1
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 26
9613: PUSH
9614: LD_INT 2
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PPUSH
9626: CALL_OW 69
9630: PUSH
9631: LD_EXP 30
9635: PUSH
9636: LD_EXP 17
9640: PUSH
9641: LD_EXP 28
9645: PUSH
9646: LD_EXP 29
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: DIFF
9657: ST_TO_ADDR
// if tmp then
9658: LD_VAR 0 1
9662: IFFALSE 9733
// case GetSex ( tmp [ 1 ] ) of sex_male :
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 1
9671: ARRAY
9672: PPUSH
9673: CALL_OW 258
9677: PUSH
9678: LD_INT 1
9680: DOUBLE
9681: EQUAL
9682: IFTRUE 9686
9684: GO 9705
9686: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9687: LD_VAR 0 1
9691: PUSH
9692: LD_INT 1
9694: ARRAY
9695: PPUSH
9696: LD_STRING D9-Sol1-1
9698: PPUSH
9699: CALL_OW 88
9703: GO 9733
9705: LD_INT 2
9707: DOUBLE
9708: EQUAL
9709: IFTRUE 9713
9711: GO 9732
9713: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9714: LD_VAR 0 1
9718: PUSH
9719: LD_INT 1
9721: ARRAY
9722: PPUSH
9723: LD_STRING D9-FSol1-1
9725: PPUSH
9726: CALL_OW 88
9730: GO 9733
9732: POP
// if Frank then
9733: LD_EXP 27
9737: IFFALSE 9841
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9739: LD_EXP 56
9743: PPUSH
9744: CALL_OW 250
9748: PPUSH
9749: LD_EXP 56
9753: PPUSH
9754: CALL_OW 251
9758: PPUSH
9759: LD_INT 7
9761: PPUSH
9762: LD_INT 8
9764: PPUSH
9765: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9769: LD_EXP 56
9773: PPUSH
9774: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9778: LD_EXP 27
9782: PPUSH
9783: LD_STRING D9-Frank-1
9785: PPUSH
9786: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9790: LD_EXP 15
9794: PPUSH
9795: LD_STRING D9-JMM-1
9797: PPUSH
9798: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9802: LD_EXP 27
9806: PPUSH
9807: LD_STRING D9-Frank-2
9809: PPUSH
9810: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9814: LD_EXP 56
9818: PPUSH
9819: CALL_OW 250
9823: PPUSH
9824: LD_EXP 56
9828: PPUSH
9829: CALL_OW 251
9833: PPUSH
9834: LD_INT 7
9836: PPUSH
9837: CALL_OW 331
// end ; DialogueOff ;
9841: CALL_OW 7
// end ;
9845: PPOPN 1
9847: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9848: LD_EXP 7
9852: PUSH
9853: LD_OWVAR 1
9857: PUSH
9858: LD_INT 42000
9860: GREATEREQUAL
9861: OR
9862: IFFALSE 10889
9864: GO 9866
9866: DISABLE
9867: LD_INT 0
9869: PPUSH
9870: PPUSH
// begin selected_option := 1 ;
9871: LD_ADDR_VAR 0 2
9875: PUSH
9876: LD_INT 1
9878: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9879: LD_INT 10500
9881: PPUSH
9882: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9886: LD_INT 35
9888: PPUSH
9889: CALL_OW 67
// until not ru_attackers ;
9893: LD_EXP 52
9897: NOT
9898: IFFALSE 9886
// PrepareBurlak ;
9900: CALL 2290 0 0
// repeat wait ( 0 0$2 ) ;
9904: LD_INT 70
9906: PPUSH
9907: CALL_OW 67
// until not HasTask ( Burlak ) ;
9911: LD_EXP 46
9915: PPUSH
9916: CALL_OW 314
9920: NOT
9921: IFFALSE 9904
// InGameOn ;
9923: CALL_OW 8
// DialogueOn ;
9927: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9931: LD_EXP 49
9935: PPUSH
9936: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9940: LD_EXP 46
9944: PPUSH
9945: LD_STRING D10-Bur-1
9947: PPUSH
9948: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9952: LD_EXP 47
9956: PUSH
9957: LD_EXP 47
9961: PPUSH
9962: CALL_OW 255
9966: PUSH
9967: LD_INT 7
9969: EQUAL
9970: AND
9971: IFFALSE 9985
// Say ( Belkov , D10-Bel-1 ) ;
9973: LD_EXP 47
9977: PPUSH
9978: LD_STRING D10-Bel-1
9980: PPUSH
9981: CALL_OW 88
// if Gossudarov then
9985: LD_EXP 32
9989: IFFALSE 10003
// Say ( Gossudarov , D10-Gos-1 ) ;
9991: LD_EXP 32
9995: PPUSH
9996: LD_STRING D10-Gos-1
9998: PPUSH
9999: CALL_OW 88
// if Kirilenkova then
10003: LD_EXP 33
10007: IFFALSE 10021
// Say ( Kirilenkova , D10-Kir-1 ) ;
10009: LD_EXP 33
10013: PPUSH
10014: LD_STRING D10-Kir-1
10016: PPUSH
10017: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10021: CALL 13297 0 0
10025: PPUSH
10026: LD_STRING D10-RSol1-1
10028: PPUSH
10029: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10033: LD_EXP 46
10037: PPUSH
10038: LD_STRING D10-Bur-2
10040: PPUSH
10041: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10045: LD_EXP 15
10049: PPUSH
10050: LD_STRING D10-JMM-2
10052: PPUSH
10053: CALL_OW 88
// if Kirilenkova then
10057: LD_EXP 33
10061: IFFALSE 10077
// Say ( Kirilenkova , D10-Kir-2 ) else
10063: LD_EXP 33
10067: PPUSH
10068: LD_STRING D10-Kir-2
10070: PPUSH
10071: CALL_OW 88
10075: GO 10089
// Say ( SolRu , D10-RSol1-2 ) ;
10077: CALL 13297 0 0
10081: PPUSH
10082: LD_STRING D10-RSol1-2
10084: PPUSH
10085: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10089: LD_EXP 15
10093: PPUSH
10094: LD_STRING D10-JMM-3
10096: PPUSH
10097: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10101: LD_EXP 46
10105: PPUSH
10106: LD_STRING D10-Bur-3
10108: PPUSH
10109: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10113: LD_EXP 15
10117: PPUSH
10118: LD_STRING D10-JMM-4
10120: PPUSH
10121: CALL_OW 88
// DialogueOff ;
10125: CALL_OW 7
// InGameOff ;
10129: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10133: LD_STRING M2
10135: PPUSH
10136: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10140: LD_INT 35
10142: PPUSH
10143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10147: LD_INT 22
10149: PUSH
10150: LD_INT 7
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: LD_INT 91
10159: PUSH
10160: LD_EXP 46
10164: PUSH
10165: LD_INT 8
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PPUSH
10177: CALL_OW 69
10181: IFFALSE 10140
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10183: LD_ADDR_VAR 0 1
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 4
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PPUSH
10198: CALL_OW 69
10202: PUSH
10203: FOR_IN
10204: IFFALSE 10220
// SetSide ( i , 7 ) ;
10206: LD_VAR 0 1
10210: PPUSH
10211: LD_INT 7
10213: PPUSH
10214: CALL_OW 235
10218: GO 10203
10220: POP
10221: POP
// ChangeMissionObjectives ( M3 ) ;
10222: LD_STRING M3
10224: PPUSH
10225: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10229: LD_INT 35
10231: PPUSH
10232: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10236: LD_EXP 15
10240: PPUSH
10241: LD_EXP 46
10245: PPUSH
10246: CALL_OW 296
10250: PUSH
10251: LD_INT 8
10253: LESS
10254: IFFALSE 10229
// ComTurnUnit ( JMM , Burlak ) ;
10256: LD_EXP 15
10260: PPUSH
10261: LD_EXP 46
10265: PPUSH
10266: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10270: LD_EXP 46
10274: PPUSH
10275: LD_EXP 15
10279: PPUSH
10280: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10284: LD_INT 10
10286: PPUSH
10287: CALL_OW 67
// DialogueOn ;
10291: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10295: LD_EXP 15
10299: PPUSH
10300: LD_STRING D11-JMM-1
10302: PPUSH
10303: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10307: LD_EXP 46
10311: PPUSH
10312: LD_STRING D11-Bur-1
10314: PPUSH
10315: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10319: LD_EXP 15
10323: PPUSH
10324: LD_STRING D11-JMM-2
10326: PPUSH
10327: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10331: LD_EXP 46
10335: PPUSH
10336: LD_STRING D11-Bur-2
10338: PPUSH
10339: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10343: LD_EXP 15
10347: PPUSH
10348: LD_STRING D11-JMM-3
10350: PPUSH
10351: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10355: LD_EXP 46
10359: PPUSH
10360: LD_STRING D11-Bur-3
10362: PPUSH
10363: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10367: LD_EXP 15
10371: PPUSH
10372: LD_STRING D11-JMM-4
10374: PPUSH
10375: CALL_OW 88
// if ar_base_spotted then
10379: LD_EXP 8
10383: IFFALSE 10399
// Say ( Burlak , D12-Bur-1 ) else
10385: LD_EXP 46
10389: PPUSH
10390: LD_STRING D12-Bur-1
10392: PPUSH
10393: CALL_OW 88
10397: GO 10438
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10399: LD_INT 7
10401: PPUSH
10402: LD_INT 3
10404: PPUSH
10405: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10409: LD_INT 127
10411: PPUSH
10412: LD_INT 45
10414: PPUSH
10415: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10419: LD_EXP 46
10423: PPUSH
10424: LD_STRING D12-Bur-1a
10426: PPUSH
10427: CALL_OW 88
// dwait ( 0 0$2 ) ;
10431: LD_INT 70
10433: PPUSH
10434: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10438: LD_EXP 46
10442: PPUSH
10443: LD_STRING D12-Bur-1b
10445: PPUSH
10446: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10450: LD_EXP 15
10454: PPUSH
10455: LD_STRING D12-JMM-1
10457: PPUSH
10458: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10462: LD_EXP 46
10466: PPUSH
10467: LD_STRING D12-Bur-2
10469: PPUSH
10470: CALL_OW 88
// if Roth then
10474: LD_EXP 16
10478: IFFALSE 10494
// Say ( Roth , D12-Roth-2 ) else
10480: LD_EXP 16
10484: PPUSH
10485: LD_STRING D12-Roth-2
10487: PPUSH
10488: CALL_OW 88
10492: GO 10506
// Say ( SciRu , D12-RSci1-2 ) ;
10494: CALL 13150 0 0
10498: PPUSH
10499: LD_STRING D12-RSci1-2
10501: PPUSH
10502: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10506: LD_EXP 15
10510: PPUSH
10511: LD_STRING D12-JMM-2
10513: PPUSH
10514: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10518: LD_EXP 46
10522: PPUSH
10523: LD_STRING D12-Bur-3
10525: PPUSH
10526: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10530: LD_EXP 15
10534: PPUSH
10535: LD_STRING D12-JMM-3
10537: PPUSH
10538: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10542: LD_EXP 46
10546: PPUSH
10547: LD_STRING D12-Bur-4
10549: PPUSH
10550: CALL_OW 88
// case Query ( QBase ) of 1 :
10554: LD_STRING QBase
10556: PPUSH
10557: CALL_OW 97
10561: PUSH
10562: LD_INT 1
10564: DOUBLE
10565: EQUAL
10566: IFTRUE 10570
10568: GO 10688
10570: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10571: LD_EXP 15
10575: PPUSH
10576: LD_STRING D13a-JMM-1
10578: PPUSH
10579: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10583: LD_EXP 46
10587: PPUSH
10588: LD_STRING D13a-Bur-1
10590: PPUSH
10591: CALL_OW 88
// if Roth then
10595: LD_EXP 16
10599: IFFALSE 10615
// Say ( Roth , D13a-Roth-1 ) else
10601: LD_EXP 16
10605: PPUSH
10606: LD_STRING D13a-Roth-1
10608: PPUSH
10609: CALL_OW 88
10613: GO 10627
// Say ( SciRu , D13a-RSci1-1 ) ;
10615: CALL 13150 0 0
10619: PPUSH
10620: LD_STRING D13a-RSci1-1
10622: PPUSH
10623: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10627: LD_EXP 15
10631: PPUSH
10632: LD_STRING D13a-JMM-2
10634: PPUSH
10635: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10639: LD_STRING QBaseAgain
10641: PPUSH
10642: CALL_OW 97
10646: PUSH
10647: LD_INT 1
10649: DOUBLE
10650: EQUAL
10651: IFTRUE 10655
10653: GO 10666
10655: POP
// selected_option := 2 ; 2 :
10656: LD_ADDR_VAR 0 2
10660: PUSH
10661: LD_INT 2
10663: ST_TO_ADDR
10664: GO 10686
10666: LD_INT 2
10668: DOUBLE
10669: EQUAL
10670: IFTRUE 10674
10672: GO 10685
10674: POP
// selected_option := 3 ; end ;
10675: LD_ADDR_VAR 0 2
10679: PUSH
10680: LD_INT 3
10682: ST_TO_ADDR
10683: GO 10686
10685: POP
// end ; 2 :
10686: GO 10727
10688: LD_INT 2
10690: DOUBLE
10691: EQUAL
10692: IFTRUE 10696
10694: GO 10707
10696: POP
// selected_option := 2 ; 3 :
10697: LD_ADDR_VAR 0 2
10701: PUSH
10702: LD_INT 2
10704: ST_TO_ADDR
10705: GO 10727
10707: LD_INT 3
10709: DOUBLE
10710: EQUAL
10711: IFTRUE 10715
10713: GO 10726
10715: POP
// selected_option := 3 ; end ;
10716: LD_ADDR_VAR 0 2
10720: PUSH
10721: LD_INT 3
10723: ST_TO_ADDR
10724: GO 10727
10726: POP
// if selected_option = 2 then
10727: LD_VAR 0 2
10731: PUSH
10732: LD_INT 2
10734: EQUAL
10735: IFFALSE 10829
// begin Say ( JMM , D13b-JMM-1 ) ;
10737: LD_EXP 15
10741: PPUSH
10742: LD_STRING D13b-JMM-1
10744: PPUSH
10745: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10749: LD_EXP 46
10753: PPUSH
10754: LD_STRING D13b-Bur-1
10756: PPUSH
10757: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10761: LD_EXP 15
10765: PPUSH
10766: LD_STRING D13b-JMM-2
10768: PPUSH
10769: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10773: LD_EXP 55
10777: PPUSH
10778: LD_STRING D13b-Abd-2
10780: PPUSH
10781: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10785: LD_EXP 15
10789: PPUSH
10790: LD_STRING D13b-JMM-3
10792: PPUSH
10793: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10797: LD_EXP 55
10801: PPUSH
10802: LD_STRING D13b-Abd-3
10804: PPUSH
10805: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10809: LD_EXP 15
10813: PPUSH
10814: LD_STRING D13b-JMM-4
10816: PPUSH
10817: CALL_OW 88
// ar_active_attack := true ;
10821: LD_ADDR_EXP 9
10825: PUSH
10826: LD_INT 1
10828: ST_TO_ADDR
// end ; if selected_option = 3 then
10829: LD_VAR 0 2
10833: PUSH
10834: LD_INT 3
10836: EQUAL
10837: IFFALSE 10863
// begin Say ( JMM , D13c-JMM-1 ) ;
10839: LD_EXP 15
10843: PPUSH
10844: LD_STRING D13c-JMM-1
10846: PPUSH
10847: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10851: LD_EXP 46
10855: PPUSH
10856: LD_STRING D13c-Bur-1
10858: PPUSH
10859: CALL_OW 88
// end ; DialogueOff ;
10863: CALL_OW 7
// if not ar_active_attack then
10867: LD_EXP 9
10871: NOT
10872: IFFALSE 10889
// begin wait ( 6 6$00 ) ;
10874: LD_INT 12600
10876: PPUSH
10877: CALL_OW 67
// ar_active_attack := true ;
10881: LD_ADDR_EXP 9
10885: PUSH
10886: LD_INT 1
10888: ST_TO_ADDR
// end ; end ;
10889: PPOPN 2
10891: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10892: LD_EXP 46
10896: PPUSH
10897: CALL_OW 305
10901: PUSH
10902: LD_EXP 46
10906: PPUSH
10907: CALL_OW 255
10911: PUSH
10912: LD_INT 7
10914: EQUAL
10915: AND
10916: IFFALSE 11112
10918: GO 10920
10920: DISABLE
10921: LD_INT 0
10923: PPUSH
// begin wait ( 4 4$40 ) ;
10924: LD_INT 9800
10926: PPUSH
10927: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10931: LD_INT 35
10933: PPUSH
10934: CALL_OW 67
// until not ru_attackers ;
10938: LD_EXP 52
10942: NOT
10943: IFFALSE 10931
// PrepareGnyevko ;
10945: CALL 2234 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10949: LD_EXP 48
10953: PPUSH
10954: LD_INT 124
10956: PPUSH
10957: LD_INT 118
10959: PPUSH
10960: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10964: LD_EXP 48
10968: PPUSH
10969: CALL_OW 200
// time := 0 0$00 ;
10973: LD_ADDR_VAR 0 1
10977: PUSH
10978: LD_INT 0
10980: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10981: LD_INT 35
10983: PPUSH
10984: CALL_OW 67
// time := time + 0 0$1 ;
10988: LD_ADDR_VAR 0 1
10992: PUSH
10993: LD_VAR 0 1
10997: PUSH
10998: LD_INT 35
11000: PLUS
11001: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11002: LD_EXP 48
11006: PPUSH
11007: LD_INT 124
11009: PPUSH
11010: LD_INT 118
11012: PPUSH
11013: CALL_OW 307
11017: PUSH
11018: LD_VAR 0 1
11022: PUSH
11023: LD_INT 1050
11025: GREATEREQUAL
11026: OR
11027: IFFALSE 10981
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11029: LD_EXP 48
11033: PPUSH
11034: LD_STRING DBelkov-Gny-1
11036: PPUSH
11037: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11041: LD_EXP 46
11045: PPUSH
11046: LD_STRING DBelkov-Bur-1a
11048: PPUSH
11049: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11053: LD_INT 35
11055: PPUSH
11056: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11060: LD_EXP 48
11064: PPUSH
11065: LD_INT 22
11067: PUSH
11068: LD_INT 7
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PPUSH
11075: CALL_OW 69
11079: PPUSH
11080: LD_EXP 48
11084: PPUSH
11085: CALL_OW 74
11089: PPUSH
11090: CALL_OW 296
11094: PUSH
11095: LD_INT 8
11097: LESS
11098: IFFALSE 11053
// SetSide ( Gnyevko , 7 ) ;
11100: LD_EXP 48
11104: PPUSH
11105: LD_INT 7
11107: PPUSH
11108: CALL_OW 235
// end ;
11112: PPOPN 1
11114: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11115: LD_EXP 46
11119: PPUSH
11120: CALL_OW 255
11124: PUSH
11125: LD_INT 7
11127: EQUAL
11128: IFFALSE 11138
11130: GO 11132
11132: DISABLE
// begin enable ;
11133: ENABLE
// PrepareAmericanAttack ;
11134: CALL 6805 0 0
// end ;
11138: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11139: LD_INT 22
11141: PUSH
11142: LD_INT 1
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: PPUSH
11149: CALL_OW 69
11153: IFFALSE 11337
11155: GO 11157
11157: DISABLE
11158: LD_INT 0
11160: PPUSH
11161: PPUSH
// begin while true do
11162: LD_INT 1
11164: IFFALSE 11221
// begin wait ( 0 0$1 ) ;
11166: LD_INT 35
11168: PPUSH
11169: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 1
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PPUSH
11188: CALL_OW 69
11192: PPUSH
11193: LD_EXP 15
11197: PPUSH
11198: CALL_OW 74
11202: ST_TO_ADDR
// if See ( 7 , tmp ) then
11203: LD_INT 7
11205: PPUSH
11206: LD_VAR 0 2
11210: PPUSH
11211: CALL_OW 292
11215: IFFALSE 11219
// break ;
11217: GO 11221
// end ;
11219: GO 11162
// DialogueOn ;
11221: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11225: LD_VAR 0 2
11229: PPUSH
11230: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11234: LD_VAR 0 2
11238: PPUSH
11239: CALL_OW 250
11243: PPUSH
11244: LD_VAR 0 2
11248: PPUSH
11249: CALL_OW 251
11253: PPUSH
11254: LD_INT 7
11256: PPUSH
11257: LD_INT 8
11259: PPUSH
11260: CALL_OW 330
// if Denis then
11264: LD_EXP 21
11268: IFFALSE 11282
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11270: LD_EXP 21
11274: PPUSH
11275: LD_STRING DAmerAttack-Pet-1
11277: PPUSH
11278: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11282: LD_EXP 15
11286: PPUSH
11287: LD_STRING DAmerAttack-JMM-1
11289: PPUSH
11290: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11294: LD_EXP 46
11298: PPUSH
11299: LD_STRING DStop-Bur-1
11301: PPUSH
11302: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11306: LD_VAR 0 2
11310: PPUSH
11311: CALL_OW 250
11315: PPUSH
11316: LD_VAR 0 2
11320: PPUSH
11321: CALL_OW 251
11325: PPUSH
11326: LD_INT 7
11328: PPUSH
11329: CALL_OW 331
// DialogueOff ;
11333: CALL_OW 7
// end ;
11337: PPOPN 2
11339: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11340: LD_INT 22
11342: PUSH
11343: LD_INT 3
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 21
11352: PUSH
11353: LD_INT 1
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PUSH
11360: EMPTY
11361: LIST
11362: LIST
11363: PPUSH
11364: CALL_OW 69
11368: PUSH
11369: LD_INT 0
11371: EQUAL
11372: IFFALSE 11414
11374: GO 11376
11376: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11377: LD_STRING M5a
11379: PPUSH
11380: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11384: LD_EXP 15
11388: PPUSH
11389: LD_STRING D8-JMM-1
11391: PPUSH
11392: CALL_OW 88
// if Gossudarov then
11396: LD_EXP 32
11400: IFFALSE 11414
// Say ( Gossudarov , D8-Gos-1 ) ;
11402: LD_EXP 32
11406: PPUSH
11407: LD_STRING D8-Gos-1
11409: PPUSH
11410: CALL_OW 88
// end ;
11414: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11415: LD_INT 22
11417: PUSH
11418: LD_INT 2
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PUSH
11425: LD_INT 21
11427: PUSH
11428: LD_INT 1
11430: PUSH
11431: EMPTY
11432: LIST
11433: LIST
11434: PUSH
11435: EMPTY
11436: LIST
11437: LIST
11438: PPUSH
11439: CALL_OW 69
11443: PUSH
11444: LD_INT 0
11446: EQUAL
11447: IFFALSE 11497
11449: GO 11451
11451: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11452: LD_STRING M4c
11454: PPUSH
11455: CALL_OW 337
// if Roth then
11459: LD_EXP 16
11463: IFFALSE 11479
// Say ( Roth , DStop-Roth-1 ) else
11465: LD_EXP 16
11469: PPUSH
11470: LD_STRING DStop-Roth-1
11472: PPUSH
11473: CALL_OW 88
11477: GO 11497
// if Gossudarov then
11479: LD_EXP 32
11483: IFFALSE 11497
// Say ( Gossudarov , D8-Gos-1a ) ;
11485: LD_EXP 32
11489: PPUSH
11490: LD_STRING D8-Gos-1a
11492: PPUSH
11493: CALL_OW 88
// end ;
11497: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11498: LD_INT 7
11500: PPUSH
11501: LD_INT 1
11503: PPUSH
11504: LD_INT 1
11506: PPUSH
11507: CALL 14786 0 3
11511: PUSH
11512: LD_INT 0
11514: EQUAL
11515: PUSH
11516: LD_INT 7
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: LD_INT 1
11524: PPUSH
11525: CALL 14786 0 3
11529: PUSH
11530: LD_INT 0
11532: EQUAL
11533: AND
11534: IFFALSE 11546
11536: GO 11538
11538: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11539: LD_STRING M1a
11541: PPUSH
11542: CALL_OW 337
// end ;
11546: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11547: LD_INT 22
11549: PUSH
11550: LD_INT 2
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: PUSH
11557: LD_INT 21
11559: PUSH
11560: LD_INT 1
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PPUSH
11571: CALL_OW 69
11575: PUSH
11576: LD_INT 0
11578: EQUAL
11579: PUSH
11580: LD_INT 22
11582: PUSH
11583: LD_INT 3
11585: PUSH
11586: EMPTY
11587: LIST
11588: LIST
11589: PUSH
11590: LD_INT 21
11592: PUSH
11593: LD_INT 1
11595: PUSH
11596: EMPTY
11597: LIST
11598: LIST
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PPUSH
11604: CALL_OW 69
11608: PUSH
11609: LD_INT 0
11611: EQUAL
11612: AND
11613: PUSH
11614: LD_INT 22
11616: PUSH
11617: LD_INT 1
11619: PUSH
11620: EMPTY
11621: LIST
11622: LIST
11623: PPUSH
11624: CALL_OW 69
11628: PUSH
11629: LD_INT 0
11631: EQUAL
11632: AND
11633: PUSH
11634: LD_INT 7
11636: PPUSH
11637: LD_INT 1
11639: PPUSH
11640: LD_INT 1
11642: PPUSH
11643: CALL 14786 0 3
11647: PUSH
11648: LD_INT 0
11650: EQUAL
11651: AND
11652: PUSH
11653: LD_INT 7
11655: PPUSH
11656: LD_INT 3
11658: PPUSH
11659: LD_INT 1
11661: PPUSH
11662: CALL 14786 0 3
11666: PUSH
11667: LD_INT 0
11669: EQUAL
11670: AND
11671: IFFALSE 13147
11673: GO 11675
11675: DISABLE
11676: LD_INT 0
11678: PPUSH
11679: PPUSH
11680: PPUSH
11681: PPUSH
11682: PPUSH
11683: PPUSH
// begin m1 := false ;
11684: LD_ADDR_VAR 0 4
11688: PUSH
11689: LD_INT 0
11691: ST_TO_ADDR
// m2 := false ;
11692: LD_ADDR_VAR 0 5
11696: PUSH
11697: LD_INT 0
11699: ST_TO_ADDR
// m3 := false ;
11700: LD_ADDR_VAR 0 6
11704: PUSH
11705: LD_INT 0
11707: ST_TO_ADDR
// if tick < 40 40$00 then
11708: LD_OWVAR 1
11712: PUSH
11713: LD_INT 84000
11715: LESS
11716: IFFALSE 11725
// SetAchievement ( ACH_ASPEED_17 ) ;
11718: LD_STRING ACH_ASPEED_17
11720: PPUSH
11721: CALL_OW 543
// wait ( 0 0$5 ) ;
11725: LD_INT 175
11727: PPUSH
11728: CALL_OW 67
// if not IsDead ( Masha ) then
11732: LD_EXP 49
11736: PPUSH
11737: CALL_OW 301
11741: NOT
11742: IFFALSE 11764
// begin m1 := true ;
11744: LD_ADDR_VAR 0 4
11748: PUSH
11749: LD_INT 1
11751: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11752: LD_STRING Masha
11754: PPUSH
11755: LD_INT 1
11757: PPUSH
11758: CALL_OW 101
// end else
11762: GO 11775
// AddMedal ( Masha , - 1 ) ;
11764: LD_STRING Masha
11766: PPUSH
11767: LD_INT 1
11769: NEG
11770: PPUSH
11771: CALL_OW 101
// if abdul_escaped then
11775: LD_EXP 12
11779: IFFALSE 11794
// AddMedal ( Abdul , - 1 ) else
11781: LD_STRING Abdul
11783: PPUSH
11784: LD_INT 1
11786: NEG
11787: PPUSH
11788: CALL_OW 101
11792: GO 11812
// begin m2 := true ;
11794: LD_ADDR_VAR 0 5
11798: PUSH
11799: LD_INT 1
11801: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11802: LD_STRING Abdul
11804: PPUSH
11805: LD_INT 1
11807: PPUSH
11808: CALL_OW 101
// end ; if loss_counter = 0 then
11812: LD_EXP 13
11816: PUSH
11817: LD_INT 0
11819: EQUAL
11820: IFFALSE 11842
// begin m3 := true ;
11822: LD_ADDR_VAR 0 6
11826: PUSH
11827: LD_INT 1
11829: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11830: LD_STRING People
11832: PPUSH
11833: LD_INT 2
11835: PPUSH
11836: CALL_OW 101
// end else
11840: GO 11900
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11842: LD_EXP 13
11846: PUSH
11847: LD_INT 3
11849: PUSH
11850: LD_INT 2
11852: PUSH
11853: LD_INT 2
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: LIST
11860: PUSH
11861: LD_OWVAR 67
11865: ARRAY
11866: LESSEQUAL
11867: IFFALSE 11889
// begin AddMedal ( People , 1 ) ;
11869: LD_STRING People
11871: PPUSH
11872: LD_INT 1
11874: PPUSH
11875: CALL_OW 101
// m3 := true ;
11879: LD_ADDR_VAR 0 6
11883: PUSH
11884: LD_INT 1
11886: ST_TO_ADDR
// end else
11887: GO 11900
// AddMedal ( People , - 1 ) ;
11889: LD_STRING People
11891: PPUSH
11892: LD_INT 1
11894: NEG
11895: PPUSH
11896: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11900: LD_OWVAR 67
11904: PUSH
11905: LD_INT 3
11907: EQUAL
11908: PUSH
11909: LD_VAR 0 4
11913: AND
11914: PUSH
11915: LD_VAR 0 5
11919: AND
11920: PUSH
11921: LD_VAR 0 6
11925: AND
11926: IFFALSE 11938
// SetAchievementEX ( ACH_AMER , 17 ) ;
11928: LD_STRING ACH_AMER
11930: PPUSH
11931: LD_INT 17
11933: PPUSH
11934: CALL_OW 564
// GiveMedals ( MAIN ) ;
11938: LD_STRING MAIN
11940: PPUSH
11941: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11945: LD_ADDR_VAR 0 2
11949: PUSH
11950: LD_INT 22
11952: PUSH
11953: LD_INT 7
11955: PUSH
11956: EMPTY
11957: LIST
11958: LIST
11959: PUSH
11960: LD_INT 2
11962: PUSH
11963: LD_INT 25
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PUSH
11973: LD_INT 25
11975: PUSH
11976: LD_INT 2
11978: PUSH
11979: EMPTY
11980: LIST
11981: LIST
11982: PUSH
11983: LD_INT 25
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: PUSH
11993: LD_INT 25
11995: PUSH
11996: LD_INT 4
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: LD_INT 25
12005: PUSH
12006: LD_INT 5
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: PUSH
12013: LD_INT 25
12015: PUSH
12016: LD_INT 8
12018: PUSH
12019: EMPTY
12020: LIST
12021: LIST
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 9
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PPUSH
12047: CALL_OW 69
12051: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12052: LD_VAR 0 2
12056: PPUSH
12057: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12061: LD_ADDR_VAR 0 3
12065: PUSH
12066: LD_EXP 15
12070: PUSH
12071: LD_EXP 16
12075: PUSH
12076: LD_EXP 17
12080: PUSH
12081: LD_EXP 18
12085: PUSH
12086: LD_EXP 19
12090: PUSH
12091: LD_EXP 20
12095: PUSH
12096: LD_EXP 21
12100: PUSH
12101: LD_EXP 22
12105: PUSH
12106: LD_EXP 23
12110: PUSH
12111: LD_EXP 24
12115: PUSH
12116: LD_EXP 25
12120: PUSH
12121: LD_EXP 26
12125: PUSH
12126: LD_EXP 27
12130: PUSH
12131: LD_EXP 28
12135: PUSH
12136: LD_EXP 29
12140: PUSH
12141: LD_EXP 30
12145: PUSH
12146: LD_EXP 31
12150: PUSH
12151: LD_EXP 32
12155: PUSH
12156: LD_EXP 33
12160: PUSH
12161: LD_EXP 34
12165: PUSH
12166: LD_EXP 36
12170: PUSH
12171: LD_EXP 37
12175: PUSH
12176: LD_EXP 38
12180: PUSH
12181: LD_EXP 39
12185: PUSH
12186: LD_EXP 40
12190: PUSH
12191: LD_EXP 41
12195: PUSH
12196: LD_EXP 42
12200: PUSH
12201: LD_EXP 43
12205: PUSH
12206: LD_EXP 44
12210: PUSH
12211: LD_EXP 45
12215: PUSH
12216: LD_EXP 46
12220: PUSH
12221: LD_EXP 47
12225: PUSH
12226: LD_EXP 48
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: ST_TO_ADDR
// if tmp diff tmp2 then
12266: LD_VAR 0 2
12270: PUSH
12271: LD_VAR 0 3
12275: DIFF
12276: IFFALSE 12296
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12278: LD_VAR 0 2
12282: PUSH
12283: LD_VAR 0 3
12287: DIFF
12288: PPUSH
12289: LD_STRING 13a_others
12291: PPUSH
12292: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12296: LD_EXP 15
12300: PPUSH
12301: LD_STRING 13a_JMM
12303: PPUSH
12304: CALL_OW 38
// if Titov then
12308: LD_EXP 34
12312: IFFALSE 12326
// SaveCharacters ( Titov , 13a_Titov ) ;
12314: LD_EXP 34
12318: PPUSH
12319: LD_STRING 13a_Titov
12321: PPUSH
12322: CALL_OW 38
// if Dolgov then
12326: LD_EXP 36
12330: IFFALSE 12344
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12332: LD_EXP 36
12336: PPUSH
12337: LD_STRING 13a_Dolgov
12339: PPUSH
12340: CALL_OW 38
// if Petrosyan then
12344: LD_EXP 37
12348: IFFALSE 12362
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12350: LD_EXP 37
12354: PPUSH
12355: LD_STRING 13a_Petrosyan
12357: PPUSH
12358: CALL_OW 38
// if Scholtze then
12362: LD_EXP 38
12366: IFFALSE 12380
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12368: LD_EXP 38
12372: PPUSH
12373: LD_STRING 13a_Scholtze
12375: PPUSH
12376: CALL_OW 38
// if Oblukov then
12380: LD_EXP 39
12384: IFFALSE 12398
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12386: LD_EXP 39
12390: PPUSH
12391: LD_STRING 13a_Oblukov
12393: PPUSH
12394: CALL_OW 38
// if Kapitsova then
12398: LD_EXP 40
12402: IFFALSE 12416
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12404: LD_EXP 40
12408: PPUSH
12409: LD_STRING 13a_Kapitsova
12411: PPUSH
12412: CALL_OW 38
// if Lipshchin then
12416: LD_EXP 41
12420: IFFALSE 12434
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12422: LD_EXP 41
12426: PPUSH
12427: LD_STRING 13a_Lipshchin
12429: PPUSH
12430: CALL_OW 38
// if Petrovova then
12434: LD_EXP 42
12438: IFFALSE 12452
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12440: LD_EXP 42
12444: PPUSH
12445: LD_STRING 13a_Petrovova
12447: PPUSH
12448: CALL_OW 38
// if Kovalyuk then
12452: LD_EXP 43
12456: IFFALSE 12470
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12458: LD_EXP 43
12462: PPUSH
12463: LD_STRING 13a_Kovalyuk
12465: PPUSH
12466: CALL_OW 38
// if Kuzmov then
12470: LD_EXP 44
12474: IFFALSE 12488
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12476: LD_EXP 44
12480: PPUSH
12481: LD_STRING 13a_Kuzmov
12483: PPUSH
12484: CALL_OW 38
// if Karamazov then
12488: LD_EXP 45
12492: IFFALSE 12506
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12494: LD_EXP 45
12498: PPUSH
12499: LD_STRING 13a_Karamazov
12501: PPUSH
12502: CALL_OW 38
// if Burlak then
12506: LD_EXP 46
12510: IFFALSE 12524
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12512: LD_EXP 46
12516: PPUSH
12517: LD_STRING 13a_Burlak
12519: PPUSH
12520: CALL_OW 38
// if Belkov then
12524: LD_EXP 47
12528: IFFALSE 12542
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12530: LD_EXP 47
12534: PPUSH
12535: LD_STRING 13a_Belkov
12537: PPUSH
12538: CALL_OW 38
// if Gnyevko then
12542: LD_EXP 48
12546: IFFALSE 12560
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12548: LD_EXP 48
12552: PPUSH
12553: LD_STRING 13a_Gnyevko
12555: PPUSH
12556: CALL_OW 38
// if Lisa then
12560: LD_EXP 17
12564: IFFALSE 12578
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12566: LD_EXP 17
12570: PPUSH
12571: LD_STRING 13a_Lisa
12573: PPUSH
12574: CALL_OW 38
// if Donaldson then
12578: LD_EXP 18
12582: IFFALSE 12596
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12584: LD_EXP 18
12588: PPUSH
12589: LD_STRING 13a_Donaldson
12591: PPUSH
12592: CALL_OW 38
// if Bobby then
12596: LD_EXP 19
12600: IFFALSE 12614
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12602: LD_EXP 19
12606: PPUSH
12607: LD_STRING 13a_Bobby
12609: PPUSH
12610: CALL_OW 38
// if Cyrus then
12614: LD_EXP 20
12618: IFFALSE 12632
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12620: LD_EXP 20
12624: PPUSH
12625: LD_STRING 13a_Cyrus
12627: PPUSH
12628: CALL_OW 38
// if Denis then
12632: LD_EXP 21
12636: IFFALSE 12650
// SaveCharacters ( Denis , 13a_Denis ) ;
12638: LD_EXP 21
12642: PPUSH
12643: LD_STRING 13a_Denis
12645: PPUSH
12646: CALL_OW 38
// if Brown then
12650: LD_EXP 22
12654: IFFALSE 12668
// SaveCharacters ( Brown , 13a_Brown ) ;
12656: LD_EXP 22
12660: PPUSH
12661: LD_STRING 13a_Brown
12663: PPUSH
12664: CALL_OW 38
// if Gladstone then
12668: LD_EXP 23
12672: IFFALSE 12686
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12674: LD_EXP 23
12678: PPUSH
12679: LD_STRING 13a_Gladstone
12681: PPUSH
12682: CALL_OW 38
// if Houten then
12686: LD_EXP 24
12690: IFFALSE 12704
// SaveCharacters ( Houten , 13a_Houten ) ;
12692: LD_EXP 24
12696: PPUSH
12697: LD_STRING 13a_Houten
12699: PPUSH
12700: CALL_OW 38
// if Cornel then
12704: LD_EXP 25
12708: IFFALSE 12722
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12710: LD_EXP 25
12714: PPUSH
12715: LD_STRING 13a_Cornel
12717: PPUSH
12718: CALL_OW 38
// if Gary then
12722: LD_EXP 26
12726: IFFALSE 12740
// SaveCharacters ( Gary , 13a_Gary ) ;
12728: LD_EXP 26
12732: PPUSH
12733: LD_STRING 13a_Gary
12735: PPUSH
12736: CALL_OW 38
// if Frank then
12740: LD_EXP 27
12744: IFFALSE 12758
// SaveCharacters ( Frank , 13a_Frank ) ;
12746: LD_EXP 27
12750: PPUSH
12751: LD_STRING 13a_Frank
12753: PPUSH
12754: CALL_OW 38
// if Kikuchi then
12758: LD_EXP 28
12762: IFFALSE 12776
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12764: LD_EXP 28
12768: PPUSH
12769: LD_STRING 13a_Kikuchi
12771: PPUSH
12772: CALL_OW 38
// if Simms then
12776: LD_EXP 29
12780: IFFALSE 12794
// SaveCharacters ( Simms , 13a_Simms ) ;
12782: LD_EXP 29
12786: PPUSH
12787: LD_STRING 13a_Simms
12789: PPUSH
12790: CALL_OW 38
// if Joan then
12794: LD_EXP 30
12798: IFFALSE 12812
// SaveCharacters ( Joan , 13a_Joan ) ;
12800: LD_EXP 30
12804: PPUSH
12805: LD_STRING 13a_Joan
12807: PPUSH
12808: CALL_OW 38
// if DeltaDoctor then
12812: LD_EXP 31
12816: IFFALSE 12830
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12818: LD_EXP 31
12822: PPUSH
12823: LD_STRING 13a_DeltaDoctor
12825: PPUSH
12826: CALL_OW 38
// if Gossudarov then
12830: LD_EXP 32
12834: IFFALSE 12848
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12836: LD_EXP 32
12840: PPUSH
12841: LD_STRING 13a_Gossudarov
12843: PPUSH
12844: CALL_OW 38
// if Kirilenkova then
12848: LD_EXP 33
12852: IFFALSE 12866
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12854: LD_EXP 33
12858: PPUSH
12859: LD_STRING 13a_Kirilenkova
12861: PPUSH
12862: CALL_OW 38
// if Roth then
12866: LD_EXP 16
12870: IFFALSE 12884
// SaveCharacters ( Roth , 13a_Roth ) ;
12872: LD_EXP 16
12876: PPUSH
12877: LD_STRING 13a_Roth
12879: PPUSH
12880: CALL_OW 38
// if Masha then
12884: LD_EXP 49
12888: IFFALSE 12943
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12890: LD_EXP 49
12894: PPUSH
12895: CALL_OW 265
12899: PUSH
12900: LD_EXP 49
12904: PPUSH
12905: CALL_OW 262
12909: PUSH
12910: LD_EXP 49
12914: PPUSH
12915: CALL_OW 263
12919: PUSH
12920: LD_EXP 49
12924: PPUSH
12925: CALL_OW 264
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: PPUSH
12936: LD_STRING 13a_Masha
12938: PPUSH
12939: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12943: LD_ADDR_VAR 0 2
12947: PUSH
12948: LD_INT 21
12950: PUSH
12951: LD_INT 3
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PPUSH
12958: CALL_OW 69
12962: ST_TO_ADDR
// tmp2 := [ ] ;
12963: LD_ADDR_VAR 0 3
12967: PUSH
12968: EMPTY
12969: ST_TO_ADDR
// if tmp then
12970: LD_VAR 0 2
12974: IFFALSE 13125
// for i in tmp do
12976: LD_ADDR_VAR 0 1
12980: PUSH
12981: LD_VAR 0 2
12985: PUSH
12986: FOR_IN
12987: IFFALSE 13123
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12989: LD_ADDR_VAR 0 3
12993: PUSH
12994: LD_VAR 0 3
12998: PUSH
12999: LD_VAR 0 1
13003: PPUSH
13004: CALL_OW 255
13008: PUSH
13009: LD_VAR 0 1
13013: PPUSH
13014: CALL_OW 248
13018: PUSH
13019: LD_VAR 0 1
13023: PPUSH
13024: CALL_OW 266
13028: PUSH
13029: LD_VAR 0 1
13033: PPUSH
13034: CALL_OW 250
13038: PUSH
13039: LD_VAR 0 1
13043: PPUSH
13044: CALL_OW 251
13048: PUSH
13049: LD_VAR 0 1
13053: PPUSH
13054: CALL_OW 254
13058: PUSH
13059: LD_VAR 0 1
13063: PPUSH
13064: CALL_OW 267
13068: PUSH
13069: LD_VAR 0 1
13073: PPUSH
13074: LD_INT 1
13076: PPUSH
13077: CALL_OW 268
13081: PUSH
13082: LD_VAR 0 1
13086: PPUSH
13087: LD_INT 2
13089: PPUSH
13090: CALL_OW 268
13094: PUSH
13095: LD_VAR 0 1
13099: PPUSH
13100: CALL_OW 269
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: PUSH
13117: EMPTY
13118: LIST
13119: ADD
13120: ST_TO_ADDR
13121: GO 12986
13123: POP
13124: POP
// if tmp2 then
13125: LD_VAR 0 3
13129: IFFALSE 13143
// SaveVariable ( tmp2 , 13a_buildings ) ;
13131: LD_VAR 0 3
13135: PPUSH
13136: LD_STRING 13a_buildings
13138: PPUSH
13139: CALL_OW 39
// YouWin ;
13143: CALL_OW 103
// end ;
13147: PPOPN 6
13149: END
// export function SciRu ; var tmp , t ; begin
13150: LD_INT 0
13152: PPUSH
13153: PPUSH
13154: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13155: LD_ADDR_VAR 0 3
13159: PUSH
13160: LD_EXP 32
13164: PUSH
13165: LD_EXP 46
13169: PUSH
13170: LD_EXP 34
13174: PUSH
13175: LD_EXP 47
13179: PUSH
13180: LD_EXP 48
13184: PUSH
13185: LD_EXP 37
13189: PUSH
13190: LD_EXP 38
13194: PUSH
13195: LD_EXP 36
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13210: LD_ADDR_VAR 0 2
13214: PUSH
13215: LD_INT 22
13217: PUSH
13218: LD_INT 7
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: LD_INT 23
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 25
13237: PUSH
13238: LD_INT 4
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PUSH
13245: LD_INT 26
13247: PUSH
13248: LD_INT 1
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: PPUSH
13261: CALL_OW 69
13265: PUSH
13266: LD_VAR 0 3
13270: DIFF
13271: ST_TO_ADDR
// if tmp then
13272: LD_VAR 0 2
13276: IFFALSE 13292
// result := tmp [ 1 ] ;
13278: LD_ADDR_VAR 0 1
13282: PUSH
13283: LD_VAR 0 2
13287: PUSH
13288: LD_INT 1
13290: ARRAY
13291: ST_TO_ADDR
// end ;
13292: LD_VAR 0 1
13296: RET
// export function SolRu ; var tmp , t ; begin
13297: LD_INT 0
13299: PPUSH
13300: PPUSH
13301: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13302: LD_ADDR_VAR 0 3
13306: PUSH
13307: LD_EXP 32
13311: PUSH
13312: LD_EXP 46
13316: PUSH
13317: LD_EXP 34
13321: PUSH
13322: LD_EXP 47
13326: PUSH
13327: LD_EXP 48
13331: PUSH
13332: LD_EXP 37
13336: PUSH
13337: LD_EXP 38
13341: PUSH
13342: LD_EXP 36
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13357: LD_ADDR_VAR 0 2
13361: PUSH
13362: LD_INT 22
13364: PUSH
13365: LD_INT 7
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: PUSH
13372: LD_INT 23
13374: PUSH
13375: LD_INT 3
13377: PUSH
13378: EMPTY
13379: LIST
13380: LIST
13381: PUSH
13382: LD_INT 25
13384: PUSH
13385: LD_INT 1
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 26
13394: PUSH
13395: LD_INT 1
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: LIST
13407: PPUSH
13408: CALL_OW 69
13412: PUSH
13413: LD_VAR 0 3
13417: DIFF
13418: ST_TO_ADDR
// if tmp then
13419: LD_VAR 0 2
13423: IFFALSE 13439
// result := tmp [ 1 ] ;
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: LD_INT 1
13437: ARRAY
13438: ST_TO_ADDR
// end ; end_of_file
13439: LD_VAR 0 1
13443: RET
// export function CustomEvent ( event ) ; begin
13444: LD_INT 0
13446: PPUSH
// end ;
13447: LD_VAR 0 2
13451: RET
// on UnitDestroyed ( un ) do var i , side ;
13452: LD_INT 0
13454: PPUSH
13455: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13456: LD_VAR 0 1
13460: PUSH
13461: LD_INT 22
13463: PUSH
13464: LD_INT 7
13466: PUSH
13467: EMPTY
13468: LIST
13469: LIST
13470: PUSH
13471: LD_INT 2
13473: PUSH
13474: LD_INT 25
13476: PUSH
13477: LD_INT 1
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: LD_INT 25
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: LD_INT 25
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: LD_INT 25
13506: PUSH
13507: LD_INT 4
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PUSH
13514: LD_INT 25
13516: PUSH
13517: LD_INT 5
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: LD_INT 25
13526: PUSH
13527: LD_INT 8
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: LD_INT 25
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: LIST
13552: LIST
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: PPUSH
13558: CALL_OW 69
13562: IN
13563: IFFALSE 13579
// loss_counter := loss_counter + 1 ;
13565: LD_ADDR_EXP 13
13569: PUSH
13570: LD_EXP 13
13574: PUSH
13575: LD_INT 1
13577: PLUS
13578: ST_TO_ADDR
// if un = Abdul then
13579: LD_VAR 0 1
13583: PUSH
13584: LD_EXP 55
13588: EQUAL
13589: IFFALSE 13599
// abdul_escaped := false ;
13591: LD_ADDR_EXP 12
13595: PUSH
13596: LD_INT 0
13598: ST_TO_ADDR
// if un in ru_attackers then
13599: LD_VAR 0 1
13603: PUSH
13604: LD_EXP 52
13608: IN
13609: IFFALSE 13627
// ru_attackers := ru_attackers diff un ;
13611: LD_ADDR_EXP 52
13615: PUSH
13616: LD_EXP 52
13620: PUSH
13621: LD_VAR 0 1
13625: DIFF
13626: ST_TO_ADDR
// if un in ar_attackers then
13627: LD_VAR 0 1
13631: PUSH
13632: LD_EXP 10
13636: IN
13637: IFFALSE 13655
// ar_attackers := ar_attackers diff un ;
13639: LD_ADDR_EXP 10
13643: PUSH
13644: LD_EXP 10
13648: PUSH
13649: LD_VAR 0 1
13653: DIFF
13654: ST_TO_ADDR
// if un = JMM then
13655: LD_VAR 0 1
13659: PUSH
13660: LD_EXP 15
13664: EQUAL
13665: IFFALSE 13676
// begin YouLost ( JMM ) ;
13667: LD_STRING JMM
13669: PPUSH
13670: CALL_OW 104
// exit ;
13674: GO 13765
// end ; if un = Burlak then
13676: LD_VAR 0 1
13680: PUSH
13681: LD_EXP 46
13685: EQUAL
13686: IFFALSE 13697
// begin YouLost ( Burlak ) ;
13688: LD_STRING Burlak
13690: PPUSH
13691: CALL_OW 104
// exit ;
13695: GO 13765
// end ; if un = freedom then
13697: LD_VAR 0 1
13701: PUSH
13702: LD_EXP 3
13706: EQUAL
13707: IFFALSE 13718
// begin YouLost ( Destroyed ) ;
13709: LD_STRING Destroyed
13711: PPUSH
13712: CALL_OW 104
// exit ;
13716: GO 13765
// end ; if un = Masha then
13718: LD_VAR 0 1
13722: PUSH
13723: LD_EXP 49
13727: EQUAL
13728: IFFALSE 13737
// ChangeMissionObjectives ( M4b ) ;
13730: LD_STRING M4b
13732: PPUSH
13733: CALL_OW 337
// if un = Mastodont then
13737: LD_VAR 0 1
13741: PUSH
13742: LD_EXP 56
13746: EQUAL
13747: IFFALSE 13756
// ChangeMissionObjectives ( M4a ) ;
13749: LD_STRING M4a
13751: PPUSH
13752: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13756: LD_VAR 0 1
13760: PPUSH
13761: CALL 79656 0 1
// end ;
13765: PPOPN 3
13767: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13768: LD_VAR 0 1
13772: PPUSH
13773: LD_VAR 0 2
13777: PPUSH
13778: CALL 81990 0 2
// end ;
13782: PPOPN 2
13784: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: CALL 81058 0 1
// end ;
13794: PPOPN 1
13796: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13797: LD_VAR 0 1
13801: PUSH
13802: LD_INT 22
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: LD_INT 30
13814: PUSH
13815: LD_INT 0
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: PPUSH
13826: CALL_OW 69
13830: IN
13831: IFFALSE 13870
// begin SetBName ( building , freedom ) ;
13833: LD_VAR 0 1
13837: PPUSH
13838: LD_STRING freedom
13840: PPUSH
13841: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13845: LD_INT 0
13847: PPUSH
13848: LD_INT 7
13850: PPUSH
13851: LD_INT 0
13853: PPUSH
13854: CALL_OW 324
// freedom := building ;
13858: LD_ADDR_EXP 3
13862: PUSH
13863: LD_VAR 0 1
13867: ST_TO_ADDR
// exit ;
13868: GO 13936
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13870: LD_VAR 0 1
13874: PUSH
13875: LD_INT 22
13877: PUSH
13878: LD_INT 7
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: PUSH
13885: LD_INT 23
13887: PUSH
13888: LD_INT 3
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: PUSH
13895: LD_INT 30
13897: PUSH
13898: LD_INT 6
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: LIST
13909: PPUSH
13910: CALL_OW 69
13914: IN
13915: IFFALSE 13927
// begin ru_lab_builded := true ;
13917: LD_ADDR_EXP 5
13921: PUSH
13922: LD_INT 1
13924: ST_TO_ADDR
// exit ;
13925: GO 13936
// end ; MCE_BuildingComplete ( building ) ;
13927: LD_VAR 0 1
13931: PPUSH
13932: CALL 81299 0 1
// end ;
13936: PPOPN 1
13938: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13939: LD_VAR 0 1
13943: PPUSH
13944: LD_VAR 0 2
13948: PPUSH
13949: CALL 79352 0 2
// end ;
13953: PPOPN 2
13955: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13956: LD_VAR 0 1
13960: PPUSH
13961: LD_VAR 0 2
13965: PPUSH
13966: LD_VAR 0 3
13970: PPUSH
13971: LD_VAR 0 4
13975: PPUSH
13976: LD_VAR 0 5
13980: PPUSH
13981: CALL 78972 0 5
// end ;
13985: PPOPN 5
13987: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13988: LD_VAR 0 1
13992: PPUSH
13993: LD_VAR 0 2
13997: PPUSH
13998: CALL 78562 0 2
// end ;
14002: PPOPN 2
14004: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14005: LD_VAR 0 1
14009: PPUSH
14010: CALL_OW 263
14014: PUSH
14015: LD_INT 3
14017: EQUAL
14018: PUSH
14019: LD_VAR 0 2
14023: PPUSH
14024: CALL_OW 263
14028: PUSH
14029: LD_INT 3
14031: EQUAL
14032: OR
14033: IFFALSE 14049
// hack_counter := hack_counter + 1 ;
14035: LD_ADDR_EXP 14
14039: PUSH
14040: LD_EXP 14
14044: PUSH
14045: LD_INT 1
14047: PLUS
14048: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14049: LD_VAR 0 1
14053: PPUSH
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_VAR 0 3
14063: PPUSH
14064: LD_VAR 0 4
14068: PPUSH
14069: CALL 78400 0 4
// end ;
14073: PPOPN 4
14075: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14076: LD_VAR 0 1
14080: PPUSH
14081: LD_VAR 0 2
14085: PPUSH
14086: LD_VAR 0 3
14090: PPUSH
14091: CALL 78175 0 3
// end ;
14095: PPOPN 3
14097: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14098: LD_VAR 0 1
14102: PPUSH
14103: LD_VAR 0 2
14107: PPUSH
14108: CALL 78060 0 2
// end ;
14112: PPOPN 2
14114: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14115: LD_VAR 0 1
14119: PPUSH
14120: LD_VAR 0 2
14124: PPUSH
14125: CALL 82285 0 2
// end ;
14129: PPOPN 2
14131: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14132: LD_VAR 0 1
14136: PPUSH
14137: LD_VAR 0 2
14141: PPUSH
14142: LD_VAR 0 3
14146: PPUSH
14147: LD_VAR 0 4
14151: PPUSH
14152: CALL 82501 0 4
// end ;
14156: PPOPN 4
14158: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14159: LD_VAR 0 1
14163: PPUSH
14164: LD_VAR 0 2
14168: PPUSH
14169: CALL 77869 0 2
// end ;
14173: PPOPN 2
14175: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14176: LD_VAR 0 1
14180: PPUSH
14181: CALL 96088 0 1
// end ; end_of_file
14185: PPOPN 1
14187: END
// every 0 0$30 do var cr , time ;
14188: GO 14190
14190: DISABLE
14191: LD_INT 0
14193: PPUSH
14194: PPUSH
// begin time := 0 0$20 ;
14195: LD_ADDR_VAR 0 2
14199: PUSH
14200: LD_INT 700
14202: ST_TO_ADDR
// while game do
14203: LD_EXP 2
14207: IFFALSE 14306
// begin wait ( time ) ;
14209: LD_VAR 0 2
14213: PPUSH
14214: CALL_OW 67
// if tick > 2 2$00 then
14218: LD_OWVAR 1
14222: PUSH
14223: LD_INT 4200
14225: GREATER
14226: IFFALSE 14259
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 ] [ Difficulty ] ;
14228: LD_ADDR_VAR 0 2
14232: PUSH
14233: LD_VAR 0 2
14237: PUSH
14238: LD_INT 140
14240: PUSH
14241: LD_INT 140
14243: PUSH
14244: LD_INT 210
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: LIST
14251: PUSH
14252: LD_OWVAR 67
14256: ARRAY
14257: PLUS
14258: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14259: LD_INT 1
14261: PPUSH
14262: LD_INT 5
14264: PPUSH
14265: CALL_OW 12
14269: PPUSH
14270: LD_INT 70
14272: PPUSH
14273: LD_INT 49
14275: PPUSH
14276: LD_INT 25
14278: PPUSH
14279: LD_INT 1
14281: PPUSH
14282: CALL_OW 56
// if time > 3 3$00 then
14286: LD_VAR 0 2
14290: PUSH
14291: LD_INT 6300
14293: GREATER
14294: IFFALSE 14304
// time := 0 0$30 ;
14296: LD_ADDR_VAR 0 2
14300: PUSH
14301: LD_INT 1050
14303: ST_TO_ADDR
// end ;
14304: GO 14203
// end ;
14306: PPOPN 2
14308: END
// every 0 0$30 do var cr , time ;
14309: GO 14311
14311: DISABLE
14312: LD_INT 0
14314: PPUSH
14315: PPUSH
// begin time := 0 0$20 ;
14316: LD_ADDR_VAR 0 2
14320: PUSH
14321: LD_INT 700
14323: ST_TO_ADDR
// while game do
14324: LD_EXP 2
14328: IFFALSE 14417
// begin wait ( time ) ;
14330: LD_VAR 0 2
14334: PPUSH
14335: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 ] [ Difficulty ] ;
14339: LD_ADDR_VAR 0 2
14343: PUSH
14344: LD_VAR 0 2
14348: PUSH
14349: LD_INT 140
14351: PUSH
14352: LD_INT 175
14354: PUSH
14355: LD_INT 210
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PUSH
14363: LD_OWVAR 67
14367: ARRAY
14368: PLUS
14369: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14370: LD_INT 3
14372: PPUSH
14373: LD_INT 5
14375: PPUSH
14376: CALL_OW 12
14380: PPUSH
14381: LD_INT 26
14383: PPUSH
14384: LD_INT 9
14386: PPUSH
14387: LD_INT 30
14389: PPUSH
14390: LD_INT 1
14392: PPUSH
14393: CALL_OW 56
// if time > 3 3$00 then
14397: LD_VAR 0 2
14401: PUSH
14402: LD_INT 6300
14404: GREATER
14405: IFFALSE 14415
// time := 0 0$20 ;
14407: LD_ADDR_VAR 0 2
14411: PUSH
14412: LD_INT 700
14414: ST_TO_ADDR
// end ;
14415: GO 14324
// end ;
14417: PPOPN 2
14419: END
// every 0 0$30 do var cr , time ;
14420: GO 14422
14422: DISABLE
14423: LD_INT 0
14425: PPUSH
14426: PPUSH
// begin time := 0 0$20 ;
14427: LD_ADDR_VAR 0 2
14431: PUSH
14432: LD_INT 700
14434: ST_TO_ADDR
// while game do
14435: LD_EXP 2
14439: IFFALSE 14564
// begin wait ( time ) ;
14441: LD_VAR 0 2
14445: PPUSH
14446: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14450: LD_ADDR_VAR 0 2
14454: PUSH
14455: LD_VAR 0 2
14459: PUSH
14460: LD_INT 175
14462: PUSH
14463: LD_INT 210
14465: PUSH
14466: LD_INT 280
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: LIST
14473: PUSH
14474: LD_OWVAR 67
14478: ARRAY
14479: PLUS
14480: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14481: LD_INT 1
14483: PPUSH
14484: LD_INT 5
14486: PPUSH
14487: CALL_OW 12
14491: PPUSH
14492: LD_INT 179
14494: PPUSH
14495: LD_INT 101
14497: PPUSH
14498: LD_INT 20
14500: PPUSH
14501: LD_INT 1
14503: PPUSH
14504: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14508: LD_INT 350
14510: PPUSH
14511: LD_INT 525
14513: PPUSH
14514: CALL_OW 12
14518: PPUSH
14519: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14523: LD_INT 1
14525: PPUSH
14526: LD_INT 5
14528: PPUSH
14529: CALL_OW 12
14533: PPUSH
14534: LD_INT 9
14536: PPUSH
14537: LD_INT 1
14539: PPUSH
14540: CALL_OW 55
// if time > 4 4$00 then
14544: LD_VAR 0 2
14548: PUSH
14549: LD_INT 8400
14551: GREATER
14552: IFFALSE 14562
// time := 0 0$30 ;
14554: LD_ADDR_VAR 0 2
14558: PUSH
14559: LD_INT 1050
14561: ST_TO_ADDR
// end ;
14562: GO 14435
// end ;
14564: PPOPN 2
14566: END
// every 0 0$30 do var cr , time ;
14567: GO 14569
14569: DISABLE
14570: LD_INT 0
14572: PPUSH
14573: PPUSH
// begin time := 0 0$10 ;
14574: LD_ADDR_VAR 0 2
14578: PUSH
14579: LD_INT 350
14581: ST_TO_ADDR
// while game do
14582: LD_EXP 2
14586: IFFALSE 14720
// begin wait ( time ) ;
14588: LD_VAR 0 2
14592: PPUSH
14593: CALL_OW 67
// time := time + 0 0$10 ;
14597: LD_ADDR_VAR 0 2
14601: PUSH
14602: LD_VAR 0 2
14606: PUSH
14607: LD_INT 350
14609: PLUS
14610: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14611: LD_INT 1
14613: PPUSH
14614: LD_INT 5
14616: PPUSH
14617: CALL_OW 12
14621: PPUSH
14622: LD_INT 11
14624: PPUSH
14625: LD_INT 1
14627: PPUSH
14628: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14632: LD_ADDR_VAR 0 1
14636: PUSH
14637: LD_INT 1
14639: PPUSH
14640: LD_INT 3
14642: PPUSH
14643: CALL_OW 12
14647: ST_TO_ADDR
// if cr = 1 then
14648: LD_VAR 0 1
14652: PUSH
14653: LD_INT 1
14655: EQUAL
14656: IFFALSE 14700
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14658: LD_INT 700
14660: PPUSH
14661: LD_INT 1575
14663: PPUSH
14664: CALL_OW 12
14668: PPUSH
14669: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14673: LD_INT 1
14675: PPUSH
14676: LD_INT 5
14678: PPUSH
14679: CALL_OW 12
14683: PPUSH
14684: LD_INT 34
14686: PPUSH
14687: LD_INT 50
14689: PPUSH
14690: LD_INT 7
14692: PPUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL_OW 56
// end ; if time > 4 4$00 then
14700: LD_VAR 0 2
14704: PUSH
14705: LD_INT 8400
14707: GREATER
14708: IFFALSE 14718
// time := 0 0$40 ;
14710: LD_ADDR_VAR 0 2
14714: PUSH
14715: LD_INT 1400
14717: ST_TO_ADDR
// end ;
14718: GO 14582
// end ; end_of_file
14720: PPOPN 2
14722: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14723: LD_INT 0
14725: PPUSH
14726: PPUSH
// if exist_mode then
14727: LD_VAR 0 2
14731: IFFALSE 14756
// unit := CreateCharacter ( prefix & ident ) else
14733: LD_ADDR_VAR 0 5
14737: PUSH
14738: LD_VAR 0 3
14742: PUSH
14743: LD_VAR 0 1
14747: STR
14748: PPUSH
14749: CALL_OW 34
14753: ST_TO_ADDR
14754: GO 14771
// unit := NewCharacter ( ident ) ;
14756: LD_ADDR_VAR 0 5
14760: PUSH
14761: LD_VAR 0 1
14765: PPUSH
14766: CALL_OW 25
14770: ST_TO_ADDR
// result := unit ;
14771: LD_ADDR_VAR 0 4
14775: PUSH
14776: LD_VAR 0 5
14780: ST_TO_ADDR
// end ;
14781: LD_VAR 0 4
14785: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14786: LD_INT 0
14788: PPUSH
14789: PPUSH
// if not side or not nation then
14790: LD_VAR 0 1
14794: NOT
14795: PUSH
14796: LD_VAR 0 2
14800: NOT
14801: OR
14802: IFFALSE 14806
// exit ;
14804: GO 15570
// case nation of nation_american :
14806: LD_VAR 0 2
14810: PUSH
14811: LD_INT 1
14813: DOUBLE
14814: EQUAL
14815: IFTRUE 14819
14817: GO 15033
14819: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14820: LD_ADDR_VAR 0 4
14824: PUSH
14825: LD_INT 35
14827: PUSH
14828: LD_INT 45
14830: PUSH
14831: LD_INT 46
14833: PUSH
14834: LD_INT 47
14836: PUSH
14837: LD_INT 82
14839: PUSH
14840: LD_INT 83
14842: PUSH
14843: LD_INT 84
14845: PUSH
14846: LD_INT 85
14848: PUSH
14849: LD_INT 86
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 6
14860: PUSH
14861: LD_INT 15
14863: PUSH
14864: LD_INT 16
14866: PUSH
14867: LD_INT 7
14869: PUSH
14870: LD_INT 12
14872: PUSH
14873: LD_INT 13
14875: PUSH
14876: LD_INT 10
14878: PUSH
14879: LD_INT 14
14881: PUSH
14882: LD_INT 20
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 22
14890: PUSH
14891: LD_INT 25
14893: PUSH
14894: LD_INT 32
14896: PUSH
14897: LD_INT 27
14899: PUSH
14900: LD_INT 36
14902: PUSH
14903: LD_INT 69
14905: PUSH
14906: LD_INT 39
14908: PUSH
14909: LD_INT 34
14911: PUSH
14912: LD_INT 40
14914: PUSH
14915: LD_INT 48
14917: PUSH
14918: LD_INT 49
14920: PUSH
14921: LD_INT 50
14923: PUSH
14924: LD_INT 51
14926: PUSH
14927: LD_INT 52
14929: PUSH
14930: LD_INT 53
14932: PUSH
14933: LD_INT 54
14935: PUSH
14936: LD_INT 55
14938: PUSH
14939: LD_INT 56
14941: PUSH
14942: LD_INT 57
14944: PUSH
14945: LD_INT 58
14947: PUSH
14948: LD_INT 59
14950: PUSH
14951: LD_INT 60
14953: PUSH
14954: LD_INT 61
14956: PUSH
14957: LD_INT 62
14959: PUSH
14960: LD_INT 80
14962: PUSH
14963: LD_INT 82
14965: PUSH
14966: LD_INT 83
14968: PUSH
14969: LD_INT 84
14971: PUSH
14972: LD_INT 85
14974: PUSH
14975: LD_INT 86
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: LIST
14986: LIST
14987: LIST
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: ST_TO_ADDR
15031: GO 15494
15033: LD_INT 2
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15263
15041: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
15042: LD_ADDR_VAR 0 4
15046: PUSH
15047: LD_INT 35
15049: PUSH
15050: LD_INT 45
15052: PUSH
15053: LD_INT 46
15055: PUSH
15056: LD_INT 47
15058: PUSH
15059: LD_INT 82
15061: PUSH
15062: LD_INT 83
15064: PUSH
15065: LD_INT 84
15067: PUSH
15068: LD_INT 85
15070: PUSH
15071: LD_INT 87
15073: PUSH
15074: LD_INT 70
15076: PUSH
15077: LD_INT 1
15079: PUSH
15080: LD_INT 11
15082: PUSH
15083: LD_INT 3
15085: PUSH
15086: LD_INT 4
15088: PUSH
15089: LD_INT 5
15091: PUSH
15092: LD_INT 6
15094: PUSH
15095: LD_INT 15
15097: PUSH
15098: LD_INT 18
15100: PUSH
15101: LD_INT 7
15103: PUSH
15104: LD_INT 17
15106: PUSH
15107: LD_INT 8
15109: PUSH
15110: LD_INT 20
15112: PUSH
15113: LD_INT 21
15115: PUSH
15116: LD_INT 22
15118: PUSH
15119: LD_INT 72
15121: PUSH
15122: LD_INT 26
15124: PUSH
15125: LD_INT 69
15127: PUSH
15128: LD_INT 39
15130: PUSH
15131: LD_INT 40
15133: PUSH
15134: LD_INT 41
15136: PUSH
15137: LD_INT 42
15139: PUSH
15140: LD_INT 43
15142: PUSH
15143: LD_INT 48
15145: PUSH
15146: LD_INT 49
15148: PUSH
15149: LD_INT 50
15151: PUSH
15152: LD_INT 51
15154: PUSH
15155: LD_INT 52
15157: PUSH
15158: LD_INT 53
15160: PUSH
15161: LD_INT 54
15163: PUSH
15164: LD_INT 55
15166: PUSH
15167: LD_INT 56
15169: PUSH
15170: LD_INT 60
15172: PUSH
15173: LD_INT 61
15175: PUSH
15176: LD_INT 62
15178: PUSH
15179: LD_INT 66
15181: PUSH
15182: LD_INT 67
15184: PUSH
15185: LD_INT 68
15187: PUSH
15188: LD_INT 81
15190: PUSH
15191: LD_INT 82
15193: PUSH
15194: LD_INT 83
15196: PUSH
15197: LD_INT 84
15199: PUSH
15200: LD_INT 85
15202: PUSH
15203: LD_INT 87
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: LIST
15258: LIST
15259: LIST
15260: ST_TO_ADDR
15261: GO 15494
15263: LD_INT 3
15265: DOUBLE
15266: EQUAL
15267: IFTRUE 15271
15269: GO 15493
15271: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_INT 46
15279: PUSH
15280: LD_INT 47
15282: PUSH
15283: LD_INT 1
15285: PUSH
15286: LD_INT 2
15288: PUSH
15289: LD_INT 82
15291: PUSH
15292: LD_INT 83
15294: PUSH
15295: LD_INT 84
15297: PUSH
15298: LD_INT 85
15300: PUSH
15301: LD_INT 86
15303: PUSH
15304: LD_INT 11
15306: PUSH
15307: LD_INT 9
15309: PUSH
15310: LD_INT 20
15312: PUSH
15313: LD_INT 19
15315: PUSH
15316: LD_INT 21
15318: PUSH
15319: LD_INT 24
15321: PUSH
15322: LD_INT 22
15324: PUSH
15325: LD_INT 25
15327: PUSH
15328: LD_INT 28
15330: PUSH
15331: LD_INT 29
15333: PUSH
15334: LD_INT 30
15336: PUSH
15337: LD_INT 31
15339: PUSH
15340: LD_INT 37
15342: PUSH
15343: LD_INT 38
15345: PUSH
15346: LD_INT 32
15348: PUSH
15349: LD_INT 27
15351: PUSH
15352: LD_INT 33
15354: PUSH
15355: LD_INT 69
15357: PUSH
15358: LD_INT 39
15360: PUSH
15361: LD_INT 34
15363: PUSH
15364: LD_INT 40
15366: PUSH
15367: LD_INT 71
15369: PUSH
15370: LD_INT 23
15372: PUSH
15373: LD_INT 44
15375: PUSH
15376: LD_INT 48
15378: PUSH
15379: LD_INT 49
15381: PUSH
15382: LD_INT 50
15384: PUSH
15385: LD_INT 51
15387: PUSH
15388: LD_INT 52
15390: PUSH
15391: LD_INT 53
15393: PUSH
15394: LD_INT 54
15396: PUSH
15397: LD_INT 55
15399: PUSH
15400: LD_INT 56
15402: PUSH
15403: LD_INT 57
15405: PUSH
15406: LD_INT 58
15408: PUSH
15409: LD_INT 59
15411: PUSH
15412: LD_INT 63
15414: PUSH
15415: LD_INT 64
15417: PUSH
15418: LD_INT 65
15420: PUSH
15421: LD_INT 82
15423: PUSH
15424: LD_INT 83
15426: PUSH
15427: LD_INT 84
15429: PUSH
15430: LD_INT 85
15432: PUSH
15433: LD_INT 86
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: ST_TO_ADDR
15491: GO 15494
15493: POP
// if state > - 1 and state < 3 then
15494: LD_VAR 0 3
15498: PUSH
15499: LD_INT 1
15501: NEG
15502: GREATER
15503: PUSH
15504: LD_VAR 0 3
15508: PUSH
15509: LD_INT 3
15511: LESS
15512: AND
15513: IFFALSE 15570
// for i in result do
15515: LD_ADDR_VAR 0 5
15519: PUSH
15520: LD_VAR 0 4
15524: PUSH
15525: FOR_IN
15526: IFFALSE 15568
// if GetTech ( i , side ) <> state then
15528: LD_VAR 0 5
15532: PPUSH
15533: LD_VAR 0 1
15537: PPUSH
15538: CALL_OW 321
15542: PUSH
15543: LD_VAR 0 3
15547: NONEQUAL
15548: IFFALSE 15566
// result := result diff i ;
15550: LD_ADDR_VAR 0 4
15554: PUSH
15555: LD_VAR 0 4
15559: PUSH
15560: LD_VAR 0 5
15564: DIFF
15565: ST_TO_ADDR
15566: GO 15525
15568: POP
15569: POP
// end ;
15570: LD_VAR 0 4
15574: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15575: LD_INT 0
15577: PPUSH
15578: PPUSH
15579: PPUSH
// result := true ;
15580: LD_ADDR_VAR 0 3
15584: PUSH
15585: LD_INT 1
15587: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15588: LD_ADDR_VAR 0 5
15592: PUSH
15593: LD_VAR 0 2
15597: PPUSH
15598: CALL_OW 480
15602: ST_TO_ADDR
// if not tmp then
15603: LD_VAR 0 5
15607: NOT
15608: IFFALSE 15612
// exit ;
15610: GO 15661
// for i in tmp do
15612: LD_ADDR_VAR 0 4
15616: PUSH
15617: LD_VAR 0 5
15621: PUSH
15622: FOR_IN
15623: IFFALSE 15659
// if GetTech ( i , side ) <> state_researched then
15625: LD_VAR 0 4
15629: PPUSH
15630: LD_VAR 0 1
15634: PPUSH
15635: CALL_OW 321
15639: PUSH
15640: LD_INT 2
15642: NONEQUAL
15643: IFFALSE 15657
// begin result := false ;
15645: LD_ADDR_VAR 0 3
15649: PUSH
15650: LD_INT 0
15652: ST_TO_ADDR
// exit ;
15653: POP
15654: POP
15655: GO 15661
// end ;
15657: GO 15622
15659: POP
15660: POP
// end ;
15661: LD_VAR 0 3
15665: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15666: LD_INT 0
15668: PPUSH
15669: PPUSH
15670: PPUSH
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
15679: PPUSH
15680: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15681: LD_VAR 0 1
15685: NOT
15686: PUSH
15687: LD_VAR 0 1
15691: PPUSH
15692: CALL_OW 257
15696: PUSH
15697: LD_INT 9
15699: NONEQUAL
15700: OR
15701: IFFALSE 15705
// exit ;
15703: GO 16278
// side := GetSide ( unit ) ;
15705: LD_ADDR_VAR 0 9
15709: PUSH
15710: LD_VAR 0 1
15714: PPUSH
15715: CALL_OW 255
15719: ST_TO_ADDR
// tech_space := tech_spacanom ;
15720: LD_ADDR_VAR 0 12
15724: PUSH
15725: LD_INT 29
15727: ST_TO_ADDR
// tech_time := tech_taurad ;
15728: LD_ADDR_VAR 0 13
15732: PUSH
15733: LD_INT 28
15735: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15736: LD_ADDR_VAR 0 11
15740: PUSH
15741: LD_VAR 0 1
15745: PPUSH
15746: CALL_OW 310
15750: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15751: LD_VAR 0 11
15755: PPUSH
15756: CALL_OW 247
15760: PUSH
15761: LD_INT 2
15763: EQUAL
15764: IFFALSE 15768
// exit ;
15766: GO 16278
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15768: LD_ADDR_VAR 0 8
15772: PUSH
15773: LD_INT 81
15775: PUSH
15776: LD_VAR 0 9
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: LD_INT 3
15787: PUSH
15788: LD_INT 21
15790: PUSH
15791: LD_INT 3
15793: PUSH
15794: EMPTY
15795: LIST
15796: LIST
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PPUSH
15806: CALL_OW 69
15810: ST_TO_ADDR
// if not tmp then
15811: LD_VAR 0 8
15815: NOT
15816: IFFALSE 15820
// exit ;
15818: GO 16278
// if in_unit then
15820: LD_VAR 0 11
15824: IFFALSE 15848
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15826: LD_ADDR_VAR 0 10
15830: PUSH
15831: LD_VAR 0 8
15835: PPUSH
15836: LD_VAR 0 11
15840: PPUSH
15841: CALL_OW 74
15845: ST_TO_ADDR
15846: GO 15868
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15848: LD_ADDR_VAR 0 10
15852: PUSH
15853: LD_VAR 0 8
15857: PPUSH
15858: LD_VAR 0 1
15862: PPUSH
15863: CALL_OW 74
15867: ST_TO_ADDR
// if not enemy then
15868: LD_VAR 0 10
15872: NOT
15873: IFFALSE 15877
// exit ;
15875: GO 16278
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15877: LD_VAR 0 11
15881: PUSH
15882: LD_VAR 0 11
15886: PPUSH
15887: LD_VAR 0 10
15891: PPUSH
15892: CALL_OW 296
15896: PUSH
15897: LD_INT 13
15899: GREATER
15900: AND
15901: PUSH
15902: LD_VAR 0 1
15906: PPUSH
15907: LD_VAR 0 10
15911: PPUSH
15912: CALL_OW 296
15916: PUSH
15917: LD_INT 12
15919: GREATER
15920: OR
15921: IFFALSE 15925
// exit ;
15923: GO 16278
// missile := [ 1 ] ;
15925: LD_ADDR_VAR 0 14
15929: PUSH
15930: LD_INT 1
15932: PUSH
15933: EMPTY
15934: LIST
15935: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15936: LD_VAR 0 9
15940: PPUSH
15941: LD_VAR 0 12
15945: PPUSH
15946: CALL_OW 325
15950: IFFALSE 15979
// missile := Insert ( missile , missile + 1 , 2 ) ;
15952: LD_ADDR_VAR 0 14
15956: PUSH
15957: LD_VAR 0 14
15961: PPUSH
15962: LD_VAR 0 14
15966: PUSH
15967: LD_INT 1
15969: PLUS
15970: PPUSH
15971: LD_INT 2
15973: PPUSH
15974: CALL_OW 2
15978: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15979: LD_VAR 0 9
15983: PPUSH
15984: LD_VAR 0 13
15988: PPUSH
15989: CALL_OW 325
15993: PUSH
15994: LD_VAR 0 10
15998: PPUSH
15999: CALL_OW 255
16003: PPUSH
16004: LD_VAR 0 13
16008: PPUSH
16009: CALL_OW 325
16013: NOT
16014: AND
16015: IFFALSE 16044
// missile := Insert ( missile , missile + 1 , 3 ) ;
16017: LD_ADDR_VAR 0 14
16021: PUSH
16022: LD_VAR 0 14
16026: PPUSH
16027: LD_VAR 0 14
16031: PUSH
16032: LD_INT 1
16034: PLUS
16035: PPUSH
16036: LD_INT 3
16038: PPUSH
16039: CALL_OW 2
16043: ST_TO_ADDR
// if missile < 2 then
16044: LD_VAR 0 14
16048: PUSH
16049: LD_INT 2
16051: LESS
16052: IFFALSE 16056
// exit ;
16054: GO 16278
// x := GetX ( enemy ) ;
16056: LD_ADDR_VAR 0 4
16060: PUSH
16061: LD_VAR 0 10
16065: PPUSH
16066: CALL_OW 250
16070: ST_TO_ADDR
// y := GetY ( enemy ) ;
16071: LD_ADDR_VAR 0 5
16075: PUSH
16076: LD_VAR 0 10
16080: PPUSH
16081: CALL_OW 251
16085: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16086: LD_ADDR_VAR 0 6
16090: PUSH
16091: LD_VAR 0 4
16095: PUSH
16096: LD_INT 1
16098: NEG
16099: PPUSH
16100: LD_INT 1
16102: PPUSH
16103: CALL_OW 12
16107: PLUS
16108: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16109: LD_ADDR_VAR 0 7
16113: PUSH
16114: LD_VAR 0 5
16118: PUSH
16119: LD_INT 1
16121: NEG
16122: PPUSH
16123: LD_INT 1
16125: PPUSH
16126: CALL_OW 12
16130: PLUS
16131: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16132: LD_VAR 0 6
16136: PPUSH
16137: LD_VAR 0 7
16141: PPUSH
16142: CALL_OW 488
16146: NOT
16147: IFFALSE 16169
// begin _x := x ;
16149: LD_ADDR_VAR 0 6
16153: PUSH
16154: LD_VAR 0 4
16158: ST_TO_ADDR
// _y := y ;
16159: LD_ADDR_VAR 0 7
16163: PUSH
16164: LD_VAR 0 5
16168: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16169: LD_ADDR_VAR 0 3
16173: PUSH
16174: LD_INT 1
16176: PPUSH
16177: LD_VAR 0 14
16181: PPUSH
16182: CALL_OW 12
16186: ST_TO_ADDR
// case i of 1 :
16187: LD_VAR 0 3
16191: PUSH
16192: LD_INT 1
16194: DOUBLE
16195: EQUAL
16196: IFTRUE 16200
16198: GO 16217
16200: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16201: LD_VAR 0 1
16205: PPUSH
16206: LD_VAR 0 10
16210: PPUSH
16211: CALL_OW 115
16215: GO 16278
16217: LD_INT 2
16219: DOUBLE
16220: EQUAL
16221: IFTRUE 16225
16223: GO 16247
16225: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16226: LD_VAR 0 1
16230: PPUSH
16231: LD_VAR 0 6
16235: PPUSH
16236: LD_VAR 0 7
16240: PPUSH
16241: CALL_OW 153
16245: GO 16278
16247: LD_INT 3
16249: DOUBLE
16250: EQUAL
16251: IFTRUE 16255
16253: GO 16277
16255: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16256: LD_VAR 0 1
16260: PPUSH
16261: LD_VAR 0 6
16265: PPUSH
16266: LD_VAR 0 7
16270: PPUSH
16271: CALL_OW 154
16275: GO 16278
16277: POP
// end ;
16278: LD_VAR 0 2
16282: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16283: LD_INT 0
16285: PPUSH
16286: PPUSH
16287: PPUSH
16288: PPUSH
16289: PPUSH
16290: PPUSH
// if not unit or not building then
16291: LD_VAR 0 1
16295: NOT
16296: PUSH
16297: LD_VAR 0 2
16301: NOT
16302: OR
16303: IFFALSE 16307
// exit ;
16305: GO 16465
// x := GetX ( building ) ;
16307: LD_ADDR_VAR 0 5
16311: PUSH
16312: LD_VAR 0 2
16316: PPUSH
16317: CALL_OW 250
16321: ST_TO_ADDR
// y := GetY ( building ) ;
16322: LD_ADDR_VAR 0 6
16326: PUSH
16327: LD_VAR 0 2
16331: PPUSH
16332: CALL_OW 251
16336: ST_TO_ADDR
// for i = 0 to 5 do
16337: LD_ADDR_VAR 0 4
16341: PUSH
16342: DOUBLE
16343: LD_INT 0
16345: DEC
16346: ST_TO_ADDR
16347: LD_INT 5
16349: PUSH
16350: FOR_TO
16351: IFFALSE 16463
// begin _x := ShiftX ( x , i , 3 ) ;
16353: LD_ADDR_VAR 0 7
16357: PUSH
16358: LD_VAR 0 5
16362: PPUSH
16363: LD_VAR 0 4
16367: PPUSH
16368: LD_INT 3
16370: PPUSH
16371: CALL_OW 272
16375: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16376: LD_ADDR_VAR 0 8
16380: PUSH
16381: LD_VAR 0 6
16385: PPUSH
16386: LD_VAR 0 4
16390: PPUSH
16391: LD_INT 3
16393: PPUSH
16394: CALL_OW 273
16398: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16399: LD_VAR 0 7
16403: PPUSH
16404: LD_VAR 0 8
16408: PPUSH
16409: CALL_OW 488
16413: NOT
16414: IFFALSE 16418
// continue ;
16416: GO 16350
// if HexInfo ( _x , _y ) = 0 then
16418: LD_VAR 0 7
16422: PPUSH
16423: LD_VAR 0 8
16427: PPUSH
16428: CALL_OW 428
16432: PUSH
16433: LD_INT 0
16435: EQUAL
16436: IFFALSE 16461
// begin ComMoveXY ( unit , _x , _y ) ;
16438: LD_VAR 0 1
16442: PPUSH
16443: LD_VAR 0 7
16447: PPUSH
16448: LD_VAR 0 8
16452: PPUSH
16453: CALL_OW 111
// exit ;
16457: POP
16458: POP
16459: GO 16465
// end ; end ;
16461: GO 16350
16463: POP
16464: POP
// end ;
16465: LD_VAR 0 3
16469: RET
// export function ScanBase ( side , base_area ) ; begin
16470: LD_INT 0
16472: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: LD_VAR 0 2
16482: PPUSH
16483: LD_INT 81
16485: PUSH
16486: LD_VAR 0 1
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: PPUSH
16495: CALL_OW 70
16499: ST_TO_ADDR
// end ;
16500: LD_VAR 0 3
16504: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16505: LD_INT 0
16507: PPUSH
16508: PPUSH
16509: PPUSH
16510: PPUSH
// result := false ;
16511: LD_ADDR_VAR 0 2
16515: PUSH
16516: LD_INT 0
16518: ST_TO_ADDR
// side := GetSide ( unit ) ;
16519: LD_ADDR_VAR 0 3
16523: PUSH
16524: LD_VAR 0 1
16528: PPUSH
16529: CALL_OW 255
16533: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16534: LD_ADDR_VAR 0 4
16538: PUSH
16539: LD_VAR 0 1
16543: PPUSH
16544: CALL_OW 248
16548: ST_TO_ADDR
// case nat of 1 :
16549: LD_VAR 0 4
16553: PUSH
16554: LD_INT 1
16556: DOUBLE
16557: EQUAL
16558: IFTRUE 16562
16560: GO 16573
16562: POP
// tech := tech_lassight ; 2 :
16563: LD_ADDR_VAR 0 5
16567: PUSH
16568: LD_INT 12
16570: ST_TO_ADDR
16571: GO 16612
16573: LD_INT 2
16575: DOUBLE
16576: EQUAL
16577: IFTRUE 16581
16579: GO 16592
16581: POP
// tech := tech_mortar ; 3 :
16582: LD_ADDR_VAR 0 5
16586: PUSH
16587: LD_INT 41
16589: ST_TO_ADDR
16590: GO 16612
16592: LD_INT 3
16594: DOUBLE
16595: EQUAL
16596: IFTRUE 16600
16598: GO 16611
16600: POP
// tech := tech_bazooka ; end ;
16601: LD_ADDR_VAR 0 5
16605: PUSH
16606: LD_INT 44
16608: ST_TO_ADDR
16609: GO 16612
16611: POP
// if Researched ( side , tech ) then
16612: LD_VAR 0 3
16616: PPUSH
16617: LD_VAR 0 5
16621: PPUSH
16622: CALL_OW 325
16626: IFFALSE 16653
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16628: LD_ADDR_VAR 0 2
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: LD_INT 8
16638: PUSH
16639: LD_INT 9
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: LIST
16646: PUSH
16647: LD_VAR 0 4
16651: ARRAY
16652: ST_TO_ADDR
// end ;
16653: LD_VAR 0 2
16657: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16658: LD_INT 0
16660: PPUSH
16661: PPUSH
16662: PPUSH
// if not mines then
16663: LD_VAR 0 2
16667: NOT
16668: IFFALSE 16672
// exit ;
16670: GO 16816
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16672: LD_ADDR_VAR 0 5
16676: PUSH
16677: LD_INT 81
16679: PUSH
16680: LD_VAR 0 1
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: PUSH
16689: LD_INT 3
16691: PUSH
16692: LD_INT 21
16694: PUSH
16695: LD_INT 3
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: PUSH
16702: EMPTY
16703: LIST
16704: LIST
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PPUSH
16710: CALL_OW 69
16714: ST_TO_ADDR
// for i in mines do
16715: LD_ADDR_VAR 0 4
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: FOR_IN
16726: IFFALSE 16814
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16728: LD_VAR 0 4
16732: PUSH
16733: LD_INT 1
16735: ARRAY
16736: PPUSH
16737: LD_VAR 0 4
16741: PUSH
16742: LD_INT 2
16744: ARRAY
16745: PPUSH
16746: CALL_OW 458
16750: NOT
16751: IFFALSE 16755
// continue ;
16753: GO 16725
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16755: LD_VAR 0 4
16759: PUSH
16760: LD_INT 1
16762: ARRAY
16763: PPUSH
16764: LD_VAR 0 4
16768: PUSH
16769: LD_INT 2
16771: ARRAY
16772: PPUSH
16773: CALL_OW 428
16777: PUSH
16778: LD_VAR 0 5
16782: IN
16783: IFFALSE 16812
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16785: LD_VAR 0 4
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: PPUSH
16794: LD_VAR 0 4
16798: PUSH
16799: LD_INT 2
16801: ARRAY
16802: PPUSH
16803: LD_VAR 0 1
16807: PPUSH
16808: CALL_OW 456
// end ;
16812: GO 16725
16814: POP
16815: POP
// end ;
16816: LD_VAR 0 3
16820: RET
// export function Count ( array ) ; var i ; begin
16821: LD_INT 0
16823: PPUSH
16824: PPUSH
// result := 0 ;
16825: LD_ADDR_VAR 0 2
16829: PUSH
16830: LD_INT 0
16832: ST_TO_ADDR
// for i in array do
16833: LD_ADDR_VAR 0 3
16837: PUSH
16838: LD_VAR 0 1
16842: PUSH
16843: FOR_IN
16844: IFFALSE 16868
// if i then
16846: LD_VAR 0 3
16850: IFFALSE 16866
// result := result + 1 ;
16852: LD_ADDR_VAR 0 2
16856: PUSH
16857: LD_VAR 0 2
16861: PUSH
16862: LD_INT 1
16864: PLUS
16865: ST_TO_ADDR
16866: GO 16843
16868: POP
16869: POP
// end ;
16870: LD_VAR 0 2
16874: RET
// export function IsEmpty ( building ) ; begin
16875: LD_INT 0
16877: PPUSH
// if not building then
16878: LD_VAR 0 1
16882: NOT
16883: IFFALSE 16887
// exit ;
16885: GO 16930
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16887: LD_ADDR_VAR 0 2
16891: PUSH
16892: LD_VAR 0 1
16896: PUSH
16897: LD_INT 22
16899: PUSH
16900: LD_VAR 0 1
16904: PPUSH
16905: CALL_OW 255
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: PUSH
16914: LD_INT 58
16916: PUSH
16917: EMPTY
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PPUSH
16924: CALL_OW 69
16928: IN
16929: ST_TO_ADDR
// end ;
16930: LD_VAR 0 2
16934: RET
// export function IsNotFull ( building ) ; begin
16935: LD_INT 0
16937: PPUSH
// if not building then
16938: LD_VAR 0 1
16942: NOT
16943: IFFALSE 16947
// exit ;
16945: GO 16966
// result := UnitsInside ( building ) < 6 ;
16947: LD_ADDR_VAR 0 2
16951: PUSH
16952: LD_VAR 0 1
16956: PPUSH
16957: CALL_OW 313
16961: PUSH
16962: LD_INT 6
16964: LESS
16965: ST_TO_ADDR
// end ;
16966: LD_VAR 0 2
16970: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16971: LD_INT 0
16973: PPUSH
16974: PPUSH
16975: PPUSH
16976: PPUSH
// tmp := [ ] ;
16977: LD_ADDR_VAR 0 3
16981: PUSH
16982: EMPTY
16983: ST_TO_ADDR
// list := [ ] ;
16984: LD_ADDR_VAR 0 5
16988: PUSH
16989: EMPTY
16990: ST_TO_ADDR
// for i = 16 to 25 do
16991: LD_ADDR_VAR 0 4
16995: PUSH
16996: DOUBLE
16997: LD_INT 16
16999: DEC
17000: ST_TO_ADDR
17001: LD_INT 25
17003: PUSH
17004: FOR_TO
17005: IFFALSE 17078
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17007: LD_ADDR_VAR 0 3
17011: PUSH
17012: LD_VAR 0 3
17016: PUSH
17017: LD_INT 22
17019: PUSH
17020: LD_VAR 0 1
17024: PPUSH
17025: CALL_OW 255
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: PUSH
17034: LD_INT 91
17036: PUSH
17037: LD_VAR 0 1
17041: PUSH
17042: LD_INT 6
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PUSH
17050: LD_INT 30
17052: PUSH
17053: LD_VAR 0 4
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: LIST
17066: PUSH
17067: EMPTY
17068: LIST
17069: PPUSH
17070: CALL_OW 69
17074: ADD
17075: ST_TO_ADDR
17076: GO 17004
17078: POP
17079: POP
// for i = 1 to tmp do
17080: LD_ADDR_VAR 0 4
17084: PUSH
17085: DOUBLE
17086: LD_INT 1
17088: DEC
17089: ST_TO_ADDR
17090: LD_VAR 0 3
17094: PUSH
17095: FOR_TO
17096: IFFALSE 17184
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17098: LD_ADDR_VAR 0 5
17102: PUSH
17103: LD_VAR 0 5
17107: PUSH
17108: LD_VAR 0 3
17112: PUSH
17113: LD_VAR 0 4
17117: ARRAY
17118: PPUSH
17119: CALL_OW 266
17123: PUSH
17124: LD_VAR 0 3
17128: PUSH
17129: LD_VAR 0 4
17133: ARRAY
17134: PPUSH
17135: CALL_OW 250
17139: PUSH
17140: LD_VAR 0 3
17144: PUSH
17145: LD_VAR 0 4
17149: ARRAY
17150: PPUSH
17151: CALL_OW 251
17155: PUSH
17156: LD_VAR 0 3
17160: PUSH
17161: LD_VAR 0 4
17165: ARRAY
17166: PPUSH
17167: CALL_OW 254
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: PUSH
17178: EMPTY
17179: LIST
17180: ADD
17181: ST_TO_ADDR
17182: GO 17095
17184: POP
17185: POP
// result := list ;
17186: LD_ADDR_VAR 0 2
17190: PUSH
17191: LD_VAR 0 5
17195: ST_TO_ADDR
// end ;
17196: LD_VAR 0 2
17200: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17201: LD_INT 0
17203: PPUSH
17204: PPUSH
17205: PPUSH
17206: PPUSH
17207: PPUSH
17208: PPUSH
17209: PPUSH
// if not factory then
17210: LD_VAR 0 1
17214: NOT
17215: IFFALSE 17219
// exit ;
17217: GO 17812
// if control = control_apeman then
17219: LD_VAR 0 4
17223: PUSH
17224: LD_INT 5
17226: EQUAL
17227: IFFALSE 17336
// begin tmp := UnitsInside ( factory ) ;
17229: LD_ADDR_VAR 0 8
17233: PUSH
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL_OW 313
17243: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17244: LD_VAR 0 8
17248: PPUSH
17249: LD_INT 25
17251: PUSH
17252: LD_INT 12
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: PPUSH
17259: CALL_OW 72
17263: NOT
17264: IFFALSE 17274
// control := control_manual ;
17266: LD_ADDR_VAR 0 4
17270: PUSH
17271: LD_INT 1
17273: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17274: LD_ADDR_VAR 0 8
17278: PUSH
17279: LD_VAR 0 1
17283: PPUSH
17284: CALL 16971 0 1
17288: ST_TO_ADDR
// if tmp then
17289: LD_VAR 0 8
17293: IFFALSE 17336
// begin for i in tmp do
17295: LD_ADDR_VAR 0 7
17299: PUSH
17300: LD_VAR 0 8
17304: PUSH
17305: FOR_IN
17306: IFFALSE 17334
// if i [ 1 ] = b_ext_radio then
17308: LD_VAR 0 7
17312: PUSH
17313: LD_INT 1
17315: ARRAY
17316: PUSH
17317: LD_INT 22
17319: EQUAL
17320: IFFALSE 17332
// begin control := control_remote ;
17322: LD_ADDR_VAR 0 4
17326: PUSH
17327: LD_INT 2
17329: ST_TO_ADDR
// break ;
17330: GO 17334
// end ;
17332: GO 17305
17334: POP
17335: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17336: LD_VAR 0 1
17340: PPUSH
17341: LD_VAR 0 2
17345: PPUSH
17346: LD_VAR 0 3
17350: PPUSH
17351: LD_VAR 0 4
17355: PPUSH
17356: LD_VAR 0 5
17360: PPUSH
17361: CALL_OW 448
17365: IFFALSE 17400
// begin result := [ chassis , engine , control , weapon ] ;
17367: LD_ADDR_VAR 0 6
17371: PUSH
17372: LD_VAR 0 2
17376: PUSH
17377: LD_VAR 0 3
17381: PUSH
17382: LD_VAR 0 4
17386: PUSH
17387: LD_VAR 0 5
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: ST_TO_ADDR
// exit ;
17398: GO 17812
// end ; _chassis := AvailableChassisList ( factory ) ;
17400: LD_ADDR_VAR 0 9
17404: PUSH
17405: LD_VAR 0 1
17409: PPUSH
17410: CALL_OW 475
17414: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17415: LD_ADDR_VAR 0 11
17419: PUSH
17420: LD_VAR 0 1
17424: PPUSH
17425: CALL_OW 476
17429: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17430: LD_ADDR_VAR 0 12
17434: PUSH
17435: LD_VAR 0 1
17439: PPUSH
17440: CALL_OW 477
17444: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17445: LD_ADDR_VAR 0 10
17449: PUSH
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 478
17459: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17460: LD_VAR 0 9
17464: NOT
17465: PUSH
17466: LD_VAR 0 11
17470: NOT
17471: OR
17472: PUSH
17473: LD_VAR 0 12
17477: NOT
17478: OR
17479: PUSH
17480: LD_VAR 0 10
17484: NOT
17485: OR
17486: IFFALSE 17521
// begin result := [ chassis , engine , control , weapon ] ;
17488: LD_ADDR_VAR 0 6
17492: PUSH
17493: LD_VAR 0 2
17497: PUSH
17498: LD_VAR 0 3
17502: PUSH
17503: LD_VAR 0 4
17507: PUSH
17508: LD_VAR 0 5
17512: PUSH
17513: EMPTY
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: ST_TO_ADDR
// exit ;
17519: GO 17812
// end ; if not chassis in _chassis then
17521: LD_VAR 0 2
17525: PUSH
17526: LD_VAR 0 9
17530: IN
17531: NOT
17532: IFFALSE 17558
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17534: LD_ADDR_VAR 0 2
17538: PUSH
17539: LD_VAR 0 9
17543: PUSH
17544: LD_INT 1
17546: PPUSH
17547: LD_VAR 0 9
17551: PPUSH
17552: CALL_OW 12
17556: ARRAY
17557: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17558: LD_VAR 0 2
17562: PPUSH
17563: LD_VAR 0 3
17567: PPUSH
17568: CALL 17817 0 2
17572: NOT
17573: IFFALSE 17632
// repeat engine := _engine [ 1 ] ;
17575: LD_ADDR_VAR 0 3
17579: PUSH
17580: LD_VAR 0 11
17584: PUSH
17585: LD_INT 1
17587: ARRAY
17588: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17589: LD_ADDR_VAR 0 11
17593: PUSH
17594: LD_VAR 0 11
17598: PPUSH
17599: LD_INT 1
17601: PPUSH
17602: CALL_OW 3
17606: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17607: LD_VAR 0 2
17611: PPUSH
17612: LD_VAR 0 3
17616: PPUSH
17617: CALL 17817 0 2
17621: PUSH
17622: LD_VAR 0 11
17626: PUSH
17627: EMPTY
17628: EQUAL
17629: OR
17630: IFFALSE 17575
// if not control in _control then
17632: LD_VAR 0 4
17636: PUSH
17637: LD_VAR 0 12
17641: IN
17642: NOT
17643: IFFALSE 17669
// control := _control [ rand ( 1 , _control ) ] ;
17645: LD_ADDR_VAR 0 4
17649: PUSH
17650: LD_VAR 0 12
17654: PUSH
17655: LD_INT 1
17657: PPUSH
17658: LD_VAR 0 12
17662: PPUSH
17663: CALL_OW 12
17667: ARRAY
17668: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17669: LD_VAR 0 2
17673: PPUSH
17674: LD_VAR 0 5
17678: PPUSH
17679: CALL 18037 0 2
17683: NOT
17684: IFFALSE 17743
// repeat weapon := _weapon [ 1 ] ;
17686: LD_ADDR_VAR 0 5
17690: PUSH
17691: LD_VAR 0 10
17695: PUSH
17696: LD_INT 1
17698: ARRAY
17699: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17700: LD_ADDR_VAR 0 10
17704: PUSH
17705: LD_VAR 0 10
17709: PPUSH
17710: LD_INT 1
17712: PPUSH
17713: CALL_OW 3
17717: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17718: LD_VAR 0 2
17722: PPUSH
17723: LD_VAR 0 5
17727: PPUSH
17728: CALL 18037 0 2
17732: PUSH
17733: LD_VAR 0 10
17737: PUSH
17738: EMPTY
17739: EQUAL
17740: OR
17741: IFFALSE 17686
// result := [ ] ;
17743: LD_ADDR_VAR 0 6
17747: PUSH
17748: EMPTY
17749: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17750: LD_VAR 0 1
17754: PPUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: LD_VAR 0 3
17764: PPUSH
17765: LD_VAR 0 4
17769: PPUSH
17770: LD_VAR 0 5
17774: PPUSH
17775: CALL_OW 448
17779: IFFALSE 17812
// result := [ chassis , engine , control , weapon ] ;
17781: LD_ADDR_VAR 0 6
17785: PUSH
17786: LD_VAR 0 2
17790: PUSH
17791: LD_VAR 0 3
17795: PUSH
17796: LD_VAR 0 4
17800: PUSH
17801: LD_VAR 0 5
17805: PUSH
17806: EMPTY
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: ST_TO_ADDR
// end ;
17812: LD_VAR 0 6
17816: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17817: LD_INT 0
17819: PPUSH
// if not chassis or not engine then
17820: LD_VAR 0 1
17824: NOT
17825: PUSH
17826: LD_VAR 0 2
17830: NOT
17831: OR
17832: IFFALSE 17836
// exit ;
17834: GO 18032
// case engine of engine_solar :
17836: LD_VAR 0 2
17840: PUSH
17841: LD_INT 2
17843: DOUBLE
17844: EQUAL
17845: IFTRUE 17849
17847: GO 17887
17849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17850: LD_ADDR_VAR 0 3
17854: PUSH
17855: LD_INT 11
17857: PUSH
17858: LD_INT 12
17860: PUSH
17861: LD_INT 13
17863: PUSH
17864: LD_INT 14
17866: PUSH
17867: LD_INT 1
17869: PUSH
17870: LD_INT 2
17872: PUSH
17873: LD_INT 3
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: LIST
17884: ST_TO_ADDR
17885: GO 18016
17887: LD_INT 1
17889: DOUBLE
17890: EQUAL
17891: IFTRUE 17895
17893: GO 17957
17895: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17896: LD_ADDR_VAR 0 3
17900: PUSH
17901: LD_INT 11
17903: PUSH
17904: LD_INT 12
17906: PUSH
17907: LD_INT 13
17909: PUSH
17910: LD_INT 14
17912: PUSH
17913: LD_INT 1
17915: PUSH
17916: LD_INT 2
17918: PUSH
17919: LD_INT 3
17921: PUSH
17922: LD_INT 4
17924: PUSH
17925: LD_INT 5
17927: PUSH
17928: LD_INT 21
17930: PUSH
17931: LD_INT 23
17933: PUSH
17934: LD_INT 22
17936: PUSH
17937: LD_INT 24
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: LIST
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: LIST
17954: ST_TO_ADDR
17955: GO 18016
17957: LD_INT 3
17959: DOUBLE
17960: EQUAL
17961: IFTRUE 17965
17963: GO 18015
17965: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17966: LD_ADDR_VAR 0 3
17970: PUSH
17971: LD_INT 13
17973: PUSH
17974: LD_INT 14
17976: PUSH
17977: LD_INT 2
17979: PUSH
17980: LD_INT 3
17982: PUSH
17983: LD_INT 4
17985: PUSH
17986: LD_INT 5
17988: PUSH
17989: LD_INT 21
17991: PUSH
17992: LD_INT 22
17994: PUSH
17995: LD_INT 23
17997: PUSH
17998: LD_INT 24
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: ST_TO_ADDR
18013: GO 18016
18015: POP
// result := ( chassis in result ) ;
18016: LD_ADDR_VAR 0 3
18020: PUSH
18021: LD_VAR 0 1
18025: PUSH
18026: LD_VAR 0 3
18030: IN
18031: ST_TO_ADDR
// end ;
18032: LD_VAR 0 3
18036: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18037: LD_INT 0
18039: PPUSH
// if not chassis or not weapon then
18040: LD_VAR 0 1
18044: NOT
18045: PUSH
18046: LD_VAR 0 2
18050: NOT
18051: OR
18052: IFFALSE 18056
// exit ;
18054: GO 19082
// case weapon of us_machine_gun :
18056: LD_VAR 0 2
18060: PUSH
18061: LD_INT 2
18063: DOUBLE
18064: EQUAL
18065: IFTRUE 18069
18067: GO 18099
18069: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18070: LD_ADDR_VAR 0 3
18074: PUSH
18075: LD_INT 1
18077: PUSH
18078: LD_INT 2
18080: PUSH
18081: LD_INT 3
18083: PUSH
18084: LD_INT 4
18086: PUSH
18087: LD_INT 5
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: LIST
18094: LIST
18095: LIST
18096: ST_TO_ADDR
18097: GO 19066
18099: LD_INT 3
18101: DOUBLE
18102: EQUAL
18103: IFTRUE 18107
18105: GO 18137
18107: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18108: LD_ADDR_VAR 0 3
18112: PUSH
18113: LD_INT 1
18115: PUSH
18116: LD_INT 2
18118: PUSH
18119: LD_INT 3
18121: PUSH
18122: LD_INT 4
18124: PUSH
18125: LD_INT 5
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: LIST
18132: LIST
18133: LIST
18134: ST_TO_ADDR
18135: GO 19066
18137: LD_INT 11
18139: DOUBLE
18140: EQUAL
18141: IFTRUE 18145
18143: GO 18175
18145: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18146: LD_ADDR_VAR 0 3
18150: PUSH
18151: LD_INT 1
18153: PUSH
18154: LD_INT 2
18156: PUSH
18157: LD_INT 3
18159: PUSH
18160: LD_INT 4
18162: PUSH
18163: LD_INT 5
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: LIST
18171: LIST
18172: ST_TO_ADDR
18173: GO 19066
18175: LD_INT 4
18177: DOUBLE
18178: EQUAL
18179: IFTRUE 18183
18181: GO 18209
18183: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18184: LD_ADDR_VAR 0 3
18188: PUSH
18189: LD_INT 2
18191: PUSH
18192: LD_INT 3
18194: PUSH
18195: LD_INT 4
18197: PUSH
18198: LD_INT 5
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: ST_TO_ADDR
18207: GO 19066
18209: LD_INT 5
18211: DOUBLE
18212: EQUAL
18213: IFTRUE 18217
18215: GO 18243
18217: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18218: LD_ADDR_VAR 0 3
18222: PUSH
18223: LD_INT 2
18225: PUSH
18226: LD_INT 3
18228: PUSH
18229: LD_INT 4
18231: PUSH
18232: LD_INT 5
18234: PUSH
18235: EMPTY
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: ST_TO_ADDR
18241: GO 19066
18243: LD_INT 9
18245: DOUBLE
18246: EQUAL
18247: IFTRUE 18251
18249: GO 18277
18251: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_INT 2
18259: PUSH
18260: LD_INT 3
18262: PUSH
18263: LD_INT 4
18265: PUSH
18266: LD_INT 5
18268: PUSH
18269: EMPTY
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: ST_TO_ADDR
18275: GO 19066
18277: LD_INT 7
18279: DOUBLE
18280: EQUAL
18281: IFTRUE 18285
18283: GO 18311
18285: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18286: LD_ADDR_VAR 0 3
18290: PUSH
18291: LD_INT 2
18293: PUSH
18294: LD_INT 3
18296: PUSH
18297: LD_INT 4
18299: PUSH
18300: LD_INT 5
18302: PUSH
18303: EMPTY
18304: LIST
18305: LIST
18306: LIST
18307: LIST
18308: ST_TO_ADDR
18309: GO 19066
18311: LD_INT 12
18313: DOUBLE
18314: EQUAL
18315: IFTRUE 18319
18317: GO 18345
18319: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18320: LD_ADDR_VAR 0 3
18324: PUSH
18325: LD_INT 2
18327: PUSH
18328: LD_INT 3
18330: PUSH
18331: LD_INT 4
18333: PUSH
18334: LD_INT 5
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: LIST
18341: LIST
18342: ST_TO_ADDR
18343: GO 19066
18345: LD_INT 13
18347: DOUBLE
18348: EQUAL
18349: IFTRUE 18353
18351: GO 18379
18353: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18354: LD_ADDR_VAR 0 3
18358: PUSH
18359: LD_INT 2
18361: PUSH
18362: LD_INT 3
18364: PUSH
18365: LD_INT 4
18367: PUSH
18368: LD_INT 5
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: LIST
18375: LIST
18376: ST_TO_ADDR
18377: GO 19066
18379: LD_INT 14
18381: DOUBLE
18382: EQUAL
18383: IFTRUE 18387
18385: GO 18405
18387: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18388: LD_ADDR_VAR 0 3
18392: PUSH
18393: LD_INT 4
18395: PUSH
18396: LD_INT 5
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: ST_TO_ADDR
18403: GO 19066
18405: LD_INT 6
18407: DOUBLE
18408: EQUAL
18409: IFTRUE 18413
18411: GO 18431
18413: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18414: LD_ADDR_VAR 0 3
18418: PUSH
18419: LD_INT 4
18421: PUSH
18422: LD_INT 5
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: ST_TO_ADDR
18429: GO 19066
18431: LD_INT 10
18433: DOUBLE
18434: EQUAL
18435: IFTRUE 18439
18437: GO 18457
18439: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18440: LD_ADDR_VAR 0 3
18444: PUSH
18445: LD_INT 4
18447: PUSH
18448: LD_INT 5
18450: PUSH
18451: EMPTY
18452: LIST
18453: LIST
18454: ST_TO_ADDR
18455: GO 19066
18457: LD_INT 22
18459: DOUBLE
18460: EQUAL
18461: IFTRUE 18465
18463: GO 18491
18465: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18466: LD_ADDR_VAR 0 3
18470: PUSH
18471: LD_INT 11
18473: PUSH
18474: LD_INT 12
18476: PUSH
18477: LD_INT 13
18479: PUSH
18480: LD_INT 14
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: LIST
18487: LIST
18488: ST_TO_ADDR
18489: GO 19066
18491: LD_INT 23
18493: DOUBLE
18494: EQUAL
18495: IFTRUE 18499
18497: GO 18525
18499: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18500: LD_ADDR_VAR 0 3
18504: PUSH
18505: LD_INT 11
18507: PUSH
18508: LD_INT 12
18510: PUSH
18511: LD_INT 13
18513: PUSH
18514: LD_INT 14
18516: PUSH
18517: EMPTY
18518: LIST
18519: LIST
18520: LIST
18521: LIST
18522: ST_TO_ADDR
18523: GO 19066
18525: LD_INT 24
18527: DOUBLE
18528: EQUAL
18529: IFTRUE 18533
18531: GO 18559
18533: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18534: LD_ADDR_VAR 0 3
18538: PUSH
18539: LD_INT 11
18541: PUSH
18542: LD_INT 12
18544: PUSH
18545: LD_INT 13
18547: PUSH
18548: LD_INT 14
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: ST_TO_ADDR
18557: GO 19066
18559: LD_INT 30
18561: DOUBLE
18562: EQUAL
18563: IFTRUE 18567
18565: GO 18593
18567: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18568: LD_ADDR_VAR 0 3
18572: PUSH
18573: LD_INT 11
18575: PUSH
18576: LD_INT 12
18578: PUSH
18579: LD_INT 13
18581: PUSH
18582: LD_INT 14
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: ST_TO_ADDR
18591: GO 19066
18593: LD_INT 25
18595: DOUBLE
18596: EQUAL
18597: IFTRUE 18601
18599: GO 18619
18601: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18602: LD_ADDR_VAR 0 3
18606: PUSH
18607: LD_INT 13
18609: PUSH
18610: LD_INT 14
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: ST_TO_ADDR
18617: GO 19066
18619: LD_INT 27
18621: DOUBLE
18622: EQUAL
18623: IFTRUE 18627
18625: GO 18645
18627: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18628: LD_ADDR_VAR 0 3
18632: PUSH
18633: LD_INT 13
18635: PUSH
18636: LD_INT 14
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: ST_TO_ADDR
18643: GO 19066
18645: LD_INT 28
18647: DOUBLE
18648: EQUAL
18649: IFTRUE 18653
18651: GO 18671
18653: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18654: LD_ADDR_VAR 0 3
18658: PUSH
18659: LD_INT 13
18661: PUSH
18662: LD_INT 14
18664: PUSH
18665: EMPTY
18666: LIST
18667: LIST
18668: ST_TO_ADDR
18669: GO 19066
18671: LD_INT 29
18673: DOUBLE
18674: EQUAL
18675: IFTRUE 18679
18677: GO 18697
18679: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18680: LD_ADDR_VAR 0 3
18684: PUSH
18685: LD_INT 13
18687: PUSH
18688: LD_INT 14
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: ST_TO_ADDR
18695: GO 19066
18697: LD_INT 31
18699: DOUBLE
18700: EQUAL
18701: IFTRUE 18705
18703: GO 18723
18705: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18706: LD_ADDR_VAR 0 3
18710: PUSH
18711: LD_INT 13
18713: PUSH
18714: LD_INT 14
18716: PUSH
18717: EMPTY
18718: LIST
18719: LIST
18720: ST_TO_ADDR
18721: GO 19066
18723: LD_INT 26
18725: DOUBLE
18726: EQUAL
18727: IFTRUE 18731
18729: GO 18749
18731: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18732: LD_ADDR_VAR 0 3
18736: PUSH
18737: LD_INT 13
18739: PUSH
18740: LD_INT 14
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: ST_TO_ADDR
18747: GO 19066
18749: LD_INT 42
18751: DOUBLE
18752: EQUAL
18753: IFTRUE 18757
18755: GO 18783
18757: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18758: LD_ADDR_VAR 0 3
18762: PUSH
18763: LD_INT 21
18765: PUSH
18766: LD_INT 22
18768: PUSH
18769: LD_INT 23
18771: PUSH
18772: LD_INT 24
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: LIST
18779: LIST
18780: ST_TO_ADDR
18781: GO 19066
18783: LD_INT 43
18785: DOUBLE
18786: EQUAL
18787: IFTRUE 18791
18789: GO 18817
18791: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18792: LD_ADDR_VAR 0 3
18796: PUSH
18797: LD_INT 21
18799: PUSH
18800: LD_INT 22
18802: PUSH
18803: LD_INT 23
18805: PUSH
18806: LD_INT 24
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: ST_TO_ADDR
18815: GO 19066
18817: LD_INT 44
18819: DOUBLE
18820: EQUAL
18821: IFTRUE 18825
18823: GO 18851
18825: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_INT 21
18833: PUSH
18834: LD_INT 22
18836: PUSH
18837: LD_INT 23
18839: PUSH
18840: LD_INT 24
18842: PUSH
18843: EMPTY
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: ST_TO_ADDR
18849: GO 19066
18851: LD_INT 45
18853: DOUBLE
18854: EQUAL
18855: IFTRUE 18859
18857: GO 18885
18859: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18860: LD_ADDR_VAR 0 3
18864: PUSH
18865: LD_INT 21
18867: PUSH
18868: LD_INT 22
18870: PUSH
18871: LD_INT 23
18873: PUSH
18874: LD_INT 24
18876: PUSH
18877: EMPTY
18878: LIST
18879: LIST
18880: LIST
18881: LIST
18882: ST_TO_ADDR
18883: GO 19066
18885: LD_INT 49
18887: DOUBLE
18888: EQUAL
18889: IFTRUE 18893
18891: GO 18919
18893: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18894: LD_ADDR_VAR 0 3
18898: PUSH
18899: LD_INT 21
18901: PUSH
18902: LD_INT 22
18904: PUSH
18905: LD_INT 23
18907: PUSH
18908: LD_INT 24
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: ST_TO_ADDR
18917: GO 19066
18919: LD_INT 51
18921: DOUBLE
18922: EQUAL
18923: IFTRUE 18927
18925: GO 18953
18927: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18928: LD_ADDR_VAR 0 3
18932: PUSH
18933: LD_INT 21
18935: PUSH
18936: LD_INT 22
18938: PUSH
18939: LD_INT 23
18941: PUSH
18942: LD_INT 24
18944: PUSH
18945: EMPTY
18946: LIST
18947: LIST
18948: LIST
18949: LIST
18950: ST_TO_ADDR
18951: GO 19066
18953: LD_INT 52
18955: DOUBLE
18956: EQUAL
18957: IFTRUE 18961
18959: GO 18987
18961: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18962: LD_ADDR_VAR 0 3
18966: PUSH
18967: LD_INT 21
18969: PUSH
18970: LD_INT 22
18972: PUSH
18973: LD_INT 23
18975: PUSH
18976: LD_INT 24
18978: PUSH
18979: EMPTY
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: ST_TO_ADDR
18985: GO 19066
18987: LD_INT 53
18989: DOUBLE
18990: EQUAL
18991: IFTRUE 18995
18993: GO 19013
18995: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18996: LD_ADDR_VAR 0 3
19000: PUSH
19001: LD_INT 23
19003: PUSH
19004: LD_INT 24
19006: PUSH
19007: EMPTY
19008: LIST
19009: LIST
19010: ST_TO_ADDR
19011: GO 19066
19013: LD_INT 46
19015: DOUBLE
19016: EQUAL
19017: IFTRUE 19021
19019: GO 19039
19021: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_INT 23
19029: PUSH
19030: LD_INT 24
19032: PUSH
19033: EMPTY
19034: LIST
19035: LIST
19036: ST_TO_ADDR
19037: GO 19066
19039: LD_INT 47
19041: DOUBLE
19042: EQUAL
19043: IFTRUE 19047
19045: GO 19065
19047: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19048: LD_ADDR_VAR 0 3
19052: PUSH
19053: LD_INT 23
19055: PUSH
19056: LD_INT 24
19058: PUSH
19059: EMPTY
19060: LIST
19061: LIST
19062: ST_TO_ADDR
19063: GO 19066
19065: POP
// result := ( chassis in result ) ;
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_VAR 0 1
19075: PUSH
19076: LD_VAR 0 3
19080: IN
19081: ST_TO_ADDR
// end ;
19082: LD_VAR 0 3
19086: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19087: LD_INT 0
19089: PPUSH
19090: PPUSH
19091: PPUSH
19092: PPUSH
19093: PPUSH
19094: PPUSH
19095: PPUSH
// result := array ;
19096: LD_ADDR_VAR 0 5
19100: PUSH
19101: LD_VAR 0 1
19105: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19106: LD_VAR 0 1
19110: NOT
19111: PUSH
19112: LD_VAR 0 2
19116: NOT
19117: OR
19118: PUSH
19119: LD_VAR 0 3
19123: NOT
19124: OR
19125: PUSH
19126: LD_VAR 0 2
19130: PUSH
19131: LD_VAR 0 1
19135: GREATER
19136: OR
19137: PUSH
19138: LD_VAR 0 3
19142: PUSH
19143: LD_VAR 0 1
19147: GREATER
19148: OR
19149: IFFALSE 19153
// exit ;
19151: GO 19449
// if direction then
19153: LD_VAR 0 4
19157: IFFALSE 19221
// begin d := 1 ;
19159: LD_ADDR_VAR 0 9
19163: PUSH
19164: LD_INT 1
19166: ST_TO_ADDR
// if i_from > i_to then
19167: LD_VAR 0 2
19171: PUSH
19172: LD_VAR 0 3
19176: GREATER
19177: IFFALSE 19203
// length := ( array - i_from ) + i_to else
19179: LD_ADDR_VAR 0 11
19183: PUSH
19184: LD_VAR 0 1
19188: PUSH
19189: LD_VAR 0 2
19193: MINUS
19194: PUSH
19195: LD_VAR 0 3
19199: PLUS
19200: ST_TO_ADDR
19201: GO 19219
// length := i_to - i_from ;
19203: LD_ADDR_VAR 0 11
19207: PUSH
19208: LD_VAR 0 3
19212: PUSH
19213: LD_VAR 0 2
19217: MINUS
19218: ST_TO_ADDR
// end else
19219: GO 19282
// begin d := - 1 ;
19221: LD_ADDR_VAR 0 9
19225: PUSH
19226: LD_INT 1
19228: NEG
19229: ST_TO_ADDR
// if i_from > i_to then
19230: LD_VAR 0 2
19234: PUSH
19235: LD_VAR 0 3
19239: GREATER
19240: IFFALSE 19260
// length := i_from - i_to else
19242: LD_ADDR_VAR 0 11
19246: PUSH
19247: LD_VAR 0 2
19251: PUSH
19252: LD_VAR 0 3
19256: MINUS
19257: ST_TO_ADDR
19258: GO 19282
// length := ( array - i_to ) + i_from ;
19260: LD_ADDR_VAR 0 11
19264: PUSH
19265: LD_VAR 0 1
19269: PUSH
19270: LD_VAR 0 3
19274: MINUS
19275: PUSH
19276: LD_VAR 0 2
19280: PLUS
19281: ST_TO_ADDR
// end ; if not length then
19282: LD_VAR 0 11
19286: NOT
19287: IFFALSE 19291
// exit ;
19289: GO 19449
// tmp := array ;
19291: LD_ADDR_VAR 0 10
19295: PUSH
19296: LD_VAR 0 1
19300: ST_TO_ADDR
// for i = 1 to length do
19301: LD_ADDR_VAR 0 6
19305: PUSH
19306: DOUBLE
19307: LD_INT 1
19309: DEC
19310: ST_TO_ADDR
19311: LD_VAR 0 11
19315: PUSH
19316: FOR_TO
19317: IFFALSE 19437
// begin for j = 1 to array do
19319: LD_ADDR_VAR 0 7
19323: PUSH
19324: DOUBLE
19325: LD_INT 1
19327: DEC
19328: ST_TO_ADDR
19329: LD_VAR 0 1
19333: PUSH
19334: FOR_TO
19335: IFFALSE 19423
// begin k := j + d ;
19337: LD_ADDR_VAR 0 8
19341: PUSH
19342: LD_VAR 0 7
19346: PUSH
19347: LD_VAR 0 9
19351: PLUS
19352: ST_TO_ADDR
// if k > array then
19353: LD_VAR 0 8
19357: PUSH
19358: LD_VAR 0 1
19362: GREATER
19363: IFFALSE 19373
// k := 1 ;
19365: LD_ADDR_VAR 0 8
19369: PUSH
19370: LD_INT 1
19372: ST_TO_ADDR
// if not k then
19373: LD_VAR 0 8
19377: NOT
19378: IFFALSE 19390
// k := array ;
19380: LD_ADDR_VAR 0 8
19384: PUSH
19385: LD_VAR 0 1
19389: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19390: LD_ADDR_VAR 0 10
19394: PUSH
19395: LD_VAR 0 10
19399: PPUSH
19400: LD_VAR 0 8
19404: PPUSH
19405: LD_VAR 0 1
19409: PUSH
19410: LD_VAR 0 7
19414: ARRAY
19415: PPUSH
19416: CALL_OW 1
19420: ST_TO_ADDR
// end ;
19421: GO 19334
19423: POP
19424: POP
// array := tmp ;
19425: LD_ADDR_VAR 0 1
19429: PUSH
19430: LD_VAR 0 10
19434: ST_TO_ADDR
// end ;
19435: GO 19316
19437: POP
19438: POP
// result := array ;
19439: LD_ADDR_VAR 0 5
19443: PUSH
19444: LD_VAR 0 1
19448: ST_TO_ADDR
// end ;
19449: LD_VAR 0 5
19453: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19454: LD_INT 0
19456: PPUSH
19457: PPUSH
// result := 0 ;
19458: LD_ADDR_VAR 0 3
19462: PUSH
19463: LD_INT 0
19465: ST_TO_ADDR
// if not array or not value in array then
19466: LD_VAR 0 1
19470: NOT
19471: PUSH
19472: LD_VAR 0 2
19476: PUSH
19477: LD_VAR 0 1
19481: IN
19482: NOT
19483: OR
19484: IFFALSE 19488
// exit ;
19486: GO 19542
// for i = 1 to array do
19488: LD_ADDR_VAR 0 4
19492: PUSH
19493: DOUBLE
19494: LD_INT 1
19496: DEC
19497: ST_TO_ADDR
19498: LD_VAR 0 1
19502: PUSH
19503: FOR_TO
19504: IFFALSE 19540
// if value = array [ i ] then
19506: LD_VAR 0 2
19510: PUSH
19511: LD_VAR 0 1
19515: PUSH
19516: LD_VAR 0 4
19520: ARRAY
19521: EQUAL
19522: IFFALSE 19538
// begin result := i ;
19524: LD_ADDR_VAR 0 3
19528: PUSH
19529: LD_VAR 0 4
19533: ST_TO_ADDR
// exit ;
19534: POP
19535: POP
19536: GO 19542
// end ;
19538: GO 19503
19540: POP
19541: POP
// end ;
19542: LD_VAR 0 3
19546: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19547: LD_INT 0
19549: PPUSH
// vc_chassis := chassis ;
19550: LD_ADDR_OWVAR 37
19554: PUSH
19555: LD_VAR 0 1
19559: ST_TO_ADDR
// vc_engine := engine ;
19560: LD_ADDR_OWVAR 39
19564: PUSH
19565: LD_VAR 0 2
19569: ST_TO_ADDR
// vc_control := control ;
19570: LD_ADDR_OWVAR 38
19574: PUSH
19575: LD_VAR 0 3
19579: ST_TO_ADDR
// vc_weapon := weapon ;
19580: LD_ADDR_OWVAR 40
19584: PUSH
19585: LD_VAR 0 4
19589: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19590: LD_ADDR_OWVAR 41
19594: PUSH
19595: LD_VAR 0 5
19599: ST_TO_ADDR
// end ;
19600: LD_VAR 0 6
19604: RET
// export function WantPlant ( unit ) ; var task ; begin
19605: LD_INT 0
19607: PPUSH
19608: PPUSH
// result := false ;
19609: LD_ADDR_VAR 0 2
19613: PUSH
19614: LD_INT 0
19616: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19617: LD_ADDR_VAR 0 3
19621: PUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 437
19631: ST_TO_ADDR
// if task then
19632: LD_VAR 0 3
19636: IFFALSE 19664
// if task [ 1 ] [ 1 ] = p then
19638: LD_VAR 0 3
19642: PUSH
19643: LD_INT 1
19645: ARRAY
19646: PUSH
19647: LD_INT 1
19649: ARRAY
19650: PUSH
19651: LD_STRING p
19653: EQUAL
19654: IFFALSE 19664
// result := true ;
19656: LD_ADDR_VAR 0 2
19660: PUSH
19661: LD_INT 1
19663: ST_TO_ADDR
// end ;
19664: LD_VAR 0 2
19668: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
// if pos < 1 then
19675: LD_VAR 0 2
19679: PUSH
19680: LD_INT 1
19682: LESS
19683: IFFALSE 19687
// exit ;
19685: GO 19990
// if pos = 1 then
19687: LD_VAR 0 2
19691: PUSH
19692: LD_INT 1
19694: EQUAL
19695: IFFALSE 19728
// result := Replace ( arr , pos [ 1 ] , value ) else
19697: LD_ADDR_VAR 0 4
19701: PUSH
19702: LD_VAR 0 1
19706: PPUSH
19707: LD_VAR 0 2
19711: PUSH
19712: LD_INT 1
19714: ARRAY
19715: PPUSH
19716: LD_VAR 0 3
19720: PPUSH
19721: CALL_OW 1
19725: ST_TO_ADDR
19726: GO 19990
// begin tmp := arr ;
19728: LD_ADDR_VAR 0 6
19732: PUSH
19733: LD_VAR 0 1
19737: ST_TO_ADDR
// s_arr := [ tmp ] ;
19738: LD_ADDR_VAR 0 7
19742: PUSH
19743: LD_VAR 0 6
19747: PUSH
19748: EMPTY
19749: LIST
19750: ST_TO_ADDR
// for i = 1 to pos - 1 do
19751: LD_ADDR_VAR 0 5
19755: PUSH
19756: DOUBLE
19757: LD_INT 1
19759: DEC
19760: ST_TO_ADDR
19761: LD_VAR 0 2
19765: PUSH
19766: LD_INT 1
19768: MINUS
19769: PUSH
19770: FOR_TO
19771: IFFALSE 19816
// begin tmp := tmp [ pos [ i ] ] ;
19773: LD_ADDR_VAR 0 6
19777: PUSH
19778: LD_VAR 0 6
19782: PUSH
19783: LD_VAR 0 2
19787: PUSH
19788: LD_VAR 0 5
19792: ARRAY
19793: ARRAY
19794: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19795: LD_ADDR_VAR 0 7
19799: PUSH
19800: LD_VAR 0 7
19804: PUSH
19805: LD_VAR 0 6
19809: PUSH
19810: EMPTY
19811: LIST
19812: ADD
19813: ST_TO_ADDR
// end ;
19814: GO 19770
19816: POP
19817: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19818: LD_ADDR_VAR 0 6
19822: PUSH
19823: LD_VAR 0 6
19827: PPUSH
19828: LD_VAR 0 2
19832: PUSH
19833: LD_VAR 0 2
19837: ARRAY
19838: PPUSH
19839: LD_VAR 0 3
19843: PPUSH
19844: CALL_OW 1
19848: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19849: LD_ADDR_VAR 0 7
19853: PUSH
19854: LD_VAR 0 7
19858: PPUSH
19859: LD_VAR 0 7
19863: PPUSH
19864: LD_VAR 0 6
19868: PPUSH
19869: CALL_OW 1
19873: ST_TO_ADDR
// for i = s_arr downto 2 do
19874: LD_ADDR_VAR 0 5
19878: PUSH
19879: DOUBLE
19880: LD_VAR 0 7
19884: INC
19885: ST_TO_ADDR
19886: LD_INT 2
19888: PUSH
19889: FOR_DOWNTO
19890: IFFALSE 19974
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19892: LD_ADDR_VAR 0 6
19896: PUSH
19897: LD_VAR 0 7
19901: PUSH
19902: LD_VAR 0 5
19906: PUSH
19907: LD_INT 1
19909: MINUS
19910: ARRAY
19911: PPUSH
19912: LD_VAR 0 2
19916: PUSH
19917: LD_VAR 0 5
19921: PUSH
19922: LD_INT 1
19924: MINUS
19925: ARRAY
19926: PPUSH
19927: LD_VAR 0 7
19931: PUSH
19932: LD_VAR 0 5
19936: ARRAY
19937: PPUSH
19938: CALL_OW 1
19942: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19943: LD_ADDR_VAR 0 7
19947: PUSH
19948: LD_VAR 0 7
19952: PPUSH
19953: LD_VAR 0 5
19957: PUSH
19958: LD_INT 1
19960: MINUS
19961: PPUSH
19962: LD_VAR 0 6
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ;
19972: GO 19889
19974: POP
19975: POP
// result := s_arr [ 1 ] ;
19976: LD_ADDR_VAR 0 4
19980: PUSH
19981: LD_VAR 0 7
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: ST_TO_ADDR
// end ; end ;
19990: LD_VAR 0 4
19994: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19995: LD_INT 0
19997: PPUSH
19998: PPUSH
// if not list then
19999: LD_VAR 0 1
20003: NOT
20004: IFFALSE 20008
// exit ;
20006: GO 20099
// i := list [ pos1 ] ;
20008: LD_ADDR_VAR 0 5
20012: PUSH
20013: LD_VAR 0 1
20017: PUSH
20018: LD_VAR 0 2
20022: ARRAY
20023: ST_TO_ADDR
// if not i then
20024: LD_VAR 0 5
20028: NOT
20029: IFFALSE 20033
// exit ;
20031: GO 20099
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20033: LD_ADDR_VAR 0 1
20037: PUSH
20038: LD_VAR 0 1
20042: PPUSH
20043: LD_VAR 0 2
20047: PPUSH
20048: LD_VAR 0 1
20052: PUSH
20053: LD_VAR 0 3
20057: ARRAY
20058: PPUSH
20059: CALL_OW 1
20063: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20064: LD_ADDR_VAR 0 1
20068: PUSH
20069: LD_VAR 0 1
20073: PPUSH
20074: LD_VAR 0 3
20078: PPUSH
20079: LD_VAR 0 5
20083: PPUSH
20084: CALL_OW 1
20088: ST_TO_ADDR
// result := list ;
20089: LD_ADDR_VAR 0 4
20093: PUSH
20094: LD_VAR 0 1
20098: ST_TO_ADDR
// end ;
20099: LD_VAR 0 4
20103: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20104: LD_INT 0
20106: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20107: LD_ADDR_VAR 0 5
20111: PUSH
20112: LD_VAR 0 1
20116: PPUSH
20117: CALL_OW 250
20121: PPUSH
20122: LD_VAR 0 1
20126: PPUSH
20127: CALL_OW 251
20131: PPUSH
20132: LD_VAR 0 2
20136: PPUSH
20137: LD_VAR 0 3
20141: PPUSH
20142: LD_VAR 0 4
20146: PPUSH
20147: CALL 20157 0 5
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
20161: PPUSH
20162: PPUSH
// if not list then
20163: LD_VAR 0 3
20167: NOT
20168: IFFALSE 20172
// exit ;
20170: GO 20560
// result := [ ] ;
20172: LD_ADDR_VAR 0 6
20176: PUSH
20177: EMPTY
20178: ST_TO_ADDR
// for i in list do
20179: LD_ADDR_VAR 0 7
20183: PUSH
20184: LD_VAR 0 3
20188: PUSH
20189: FOR_IN
20190: IFFALSE 20392
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20192: LD_ADDR_VAR 0 9
20196: PUSH
20197: LD_VAR 0 7
20201: PPUSH
20202: LD_VAR 0 1
20206: PPUSH
20207: LD_VAR 0 2
20211: PPUSH
20212: CALL_OW 297
20216: ST_TO_ADDR
// if not result then
20217: LD_VAR 0 6
20221: NOT
20222: IFFALSE 20248
// result := [ [ i , tmp ] ] else
20224: LD_ADDR_VAR 0 6
20228: PUSH
20229: LD_VAR 0 7
20233: PUSH
20234: LD_VAR 0 9
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: EMPTY
20244: LIST
20245: ST_TO_ADDR
20246: GO 20390
// begin if result [ result ] [ 2 ] < tmp then
20248: LD_VAR 0 6
20252: PUSH
20253: LD_VAR 0 6
20257: ARRAY
20258: PUSH
20259: LD_INT 2
20261: ARRAY
20262: PUSH
20263: LD_VAR 0 9
20267: LESS
20268: IFFALSE 20310
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20270: LD_ADDR_VAR 0 6
20274: PUSH
20275: LD_VAR 0 6
20279: PPUSH
20280: LD_VAR 0 6
20284: PUSH
20285: LD_INT 1
20287: PLUS
20288: PPUSH
20289: LD_VAR 0 7
20293: PUSH
20294: LD_VAR 0 9
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PPUSH
20303: CALL_OW 2
20307: ST_TO_ADDR
20308: GO 20390
// for j = 1 to result do
20310: LD_ADDR_VAR 0 8
20314: PUSH
20315: DOUBLE
20316: LD_INT 1
20318: DEC
20319: ST_TO_ADDR
20320: LD_VAR 0 6
20324: PUSH
20325: FOR_TO
20326: IFFALSE 20388
// begin if tmp < result [ j ] [ 2 ] then
20328: LD_VAR 0 9
20332: PUSH
20333: LD_VAR 0 6
20337: PUSH
20338: LD_VAR 0 8
20342: ARRAY
20343: PUSH
20344: LD_INT 2
20346: ARRAY
20347: LESS
20348: IFFALSE 20386
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20350: LD_ADDR_VAR 0 6
20354: PUSH
20355: LD_VAR 0 6
20359: PPUSH
20360: LD_VAR 0 8
20364: PPUSH
20365: LD_VAR 0 7
20369: PUSH
20370: LD_VAR 0 9
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PPUSH
20379: CALL_OW 2
20383: ST_TO_ADDR
// break ;
20384: GO 20388
// end ; end ;
20386: GO 20325
20388: POP
20389: POP
// end ; end ;
20390: GO 20189
20392: POP
20393: POP
// if result and not asc then
20394: LD_VAR 0 6
20398: PUSH
20399: LD_VAR 0 4
20403: NOT
20404: AND
20405: IFFALSE 20480
// begin tmp := result ;
20407: LD_ADDR_VAR 0 9
20411: PUSH
20412: LD_VAR 0 6
20416: ST_TO_ADDR
// for i = tmp downto 1 do
20417: LD_ADDR_VAR 0 7
20421: PUSH
20422: DOUBLE
20423: LD_VAR 0 9
20427: INC
20428: ST_TO_ADDR
20429: LD_INT 1
20431: PUSH
20432: FOR_DOWNTO
20433: IFFALSE 20478
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20435: LD_ADDR_VAR 0 6
20439: PUSH
20440: LD_VAR 0 6
20444: PPUSH
20445: LD_VAR 0 9
20449: PUSH
20450: LD_VAR 0 7
20454: MINUS
20455: PUSH
20456: LD_INT 1
20458: PLUS
20459: PPUSH
20460: LD_VAR 0 9
20464: PUSH
20465: LD_VAR 0 7
20469: ARRAY
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
20476: GO 20432
20478: POP
20479: POP
// end ; tmp := [ ] ;
20480: LD_ADDR_VAR 0 9
20484: PUSH
20485: EMPTY
20486: ST_TO_ADDR
// if mode then
20487: LD_VAR 0 5
20491: IFFALSE 20560
// begin for i = 1 to result do
20493: LD_ADDR_VAR 0 7
20497: PUSH
20498: DOUBLE
20499: LD_INT 1
20501: DEC
20502: ST_TO_ADDR
20503: LD_VAR 0 6
20507: PUSH
20508: FOR_TO
20509: IFFALSE 20548
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20511: LD_ADDR_VAR 0 9
20515: PUSH
20516: LD_VAR 0 9
20520: PPUSH
20521: LD_VAR 0 7
20525: PPUSH
20526: LD_VAR 0 6
20530: PUSH
20531: LD_VAR 0 7
20535: ARRAY
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: CALL_OW 1
20545: ST_TO_ADDR
20546: GO 20508
20548: POP
20549: POP
// result := tmp ;
20550: LD_ADDR_VAR 0 6
20554: PUSH
20555: LD_VAR 0 9
20559: ST_TO_ADDR
// end ; end ;
20560: LD_VAR 0 6
20564: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20565: LD_INT 0
20567: PPUSH
20568: PPUSH
20569: PPUSH
20570: PPUSH
20571: PPUSH
20572: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20573: LD_ADDR_VAR 0 5
20577: PUSH
20578: LD_INT 0
20580: PUSH
20581: LD_INT 0
20583: PUSH
20584: LD_INT 0
20586: PUSH
20587: EMPTY
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: LIST
20594: ST_TO_ADDR
// if not x or not y then
20595: LD_VAR 0 2
20599: NOT
20600: PUSH
20601: LD_VAR 0 3
20605: NOT
20606: OR
20607: IFFALSE 20611
// exit ;
20609: GO 22257
// if not range then
20611: LD_VAR 0 4
20615: NOT
20616: IFFALSE 20626
// range := 10 ;
20618: LD_ADDR_VAR 0 4
20622: PUSH
20623: LD_INT 10
20625: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20626: LD_ADDR_VAR 0 8
20630: PUSH
20631: LD_INT 81
20633: PUSH
20634: LD_VAR 0 1
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: LD_INT 92
20645: PUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_VAR 0 3
20655: PUSH
20656: LD_VAR 0 4
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: PUSH
20667: LD_INT 3
20669: PUSH
20670: LD_INT 21
20672: PUSH
20673: LD_INT 3
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PUSH
20680: EMPTY
20681: LIST
20682: LIST
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: PPUSH
20689: CALL_OW 69
20693: ST_TO_ADDR
// if not tmp then
20694: LD_VAR 0 8
20698: NOT
20699: IFFALSE 20703
// exit ;
20701: GO 22257
// for i in tmp do
20703: LD_ADDR_VAR 0 6
20707: PUSH
20708: LD_VAR 0 8
20712: PUSH
20713: FOR_IN
20714: IFFALSE 22232
// begin points := [ 0 , 0 , 0 ] ;
20716: LD_ADDR_VAR 0 9
20720: PUSH
20721: LD_INT 0
20723: PUSH
20724: LD_INT 0
20726: PUSH
20727: LD_INT 0
20729: PUSH
20730: EMPTY
20731: LIST
20732: LIST
20733: LIST
20734: ST_TO_ADDR
// bpoints := 1 ;
20735: LD_ADDR_VAR 0 10
20739: PUSH
20740: LD_INT 1
20742: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20743: LD_VAR 0 6
20747: PPUSH
20748: CALL_OW 247
20752: PUSH
20753: LD_INT 1
20755: DOUBLE
20756: EQUAL
20757: IFTRUE 20761
20759: GO 21339
20761: POP
// begin if GetClass ( i ) = 1 then
20762: LD_VAR 0 6
20766: PPUSH
20767: CALL_OW 257
20771: PUSH
20772: LD_INT 1
20774: EQUAL
20775: IFFALSE 20796
// points := [ 10 , 5 , 3 ] ;
20777: LD_ADDR_VAR 0 9
20781: PUSH
20782: LD_INT 10
20784: PUSH
20785: LD_INT 5
20787: PUSH
20788: LD_INT 3
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: LIST
20795: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20796: LD_VAR 0 6
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 2
20808: PUSH
20809: LD_INT 3
20811: PUSH
20812: LD_INT 4
20814: PUSH
20815: EMPTY
20816: LIST
20817: LIST
20818: LIST
20819: IN
20820: IFFALSE 20841
// points := [ 3 , 2 , 1 ] ;
20822: LD_ADDR_VAR 0 9
20826: PUSH
20827: LD_INT 3
20829: PUSH
20830: LD_INT 2
20832: PUSH
20833: LD_INT 1
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: LIST
20840: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20841: LD_VAR 0 6
20845: PPUSH
20846: CALL_OW 257
20850: PUSH
20851: LD_INT 5
20853: EQUAL
20854: IFFALSE 20875
// points := [ 130 , 5 , 2 ] ;
20856: LD_ADDR_VAR 0 9
20860: PUSH
20861: LD_INT 130
20863: PUSH
20864: LD_INT 5
20866: PUSH
20867: LD_INT 2
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: LIST
20874: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20875: LD_VAR 0 6
20879: PPUSH
20880: CALL_OW 257
20884: PUSH
20885: LD_INT 8
20887: EQUAL
20888: IFFALSE 20909
// points := [ 35 , 35 , 30 ] ;
20890: LD_ADDR_VAR 0 9
20894: PUSH
20895: LD_INT 35
20897: PUSH
20898: LD_INT 35
20900: PUSH
20901: LD_INT 30
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: LIST
20908: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20909: LD_VAR 0 6
20913: PPUSH
20914: CALL_OW 257
20918: PUSH
20919: LD_INT 9
20921: EQUAL
20922: IFFALSE 20943
// points := [ 20 , 55 , 40 ] ;
20924: LD_ADDR_VAR 0 9
20928: PUSH
20929: LD_INT 20
20931: PUSH
20932: LD_INT 55
20934: PUSH
20935: LD_INT 40
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: LIST
20942: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20943: LD_VAR 0 6
20947: PPUSH
20948: CALL_OW 257
20952: PUSH
20953: LD_INT 12
20955: PUSH
20956: LD_INT 16
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: IN
20963: IFFALSE 20984
// points := [ 5 , 3 , 2 ] ;
20965: LD_ADDR_VAR 0 9
20969: PUSH
20970: LD_INT 5
20972: PUSH
20973: LD_INT 3
20975: PUSH
20976: LD_INT 2
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: LIST
20983: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20984: LD_VAR 0 6
20988: PPUSH
20989: CALL_OW 257
20993: PUSH
20994: LD_INT 17
20996: EQUAL
20997: IFFALSE 21018
// points := [ 100 , 50 , 75 ] ;
20999: LD_ADDR_VAR 0 9
21003: PUSH
21004: LD_INT 100
21006: PUSH
21007: LD_INT 50
21009: PUSH
21010: LD_INT 75
21012: PUSH
21013: EMPTY
21014: LIST
21015: LIST
21016: LIST
21017: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21018: LD_VAR 0 6
21022: PPUSH
21023: CALL_OW 257
21027: PUSH
21028: LD_INT 15
21030: EQUAL
21031: IFFALSE 21052
// points := [ 10 , 5 , 3 ] ;
21033: LD_ADDR_VAR 0 9
21037: PUSH
21038: LD_INT 10
21040: PUSH
21041: LD_INT 5
21043: PUSH
21044: LD_INT 3
21046: PUSH
21047: EMPTY
21048: LIST
21049: LIST
21050: LIST
21051: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21052: LD_VAR 0 6
21056: PPUSH
21057: CALL_OW 257
21061: PUSH
21062: LD_INT 14
21064: EQUAL
21065: IFFALSE 21086
// points := [ 10 , 0 , 0 ] ;
21067: LD_ADDR_VAR 0 9
21071: PUSH
21072: LD_INT 10
21074: PUSH
21075: LD_INT 0
21077: PUSH
21078: LD_INT 0
21080: PUSH
21081: EMPTY
21082: LIST
21083: LIST
21084: LIST
21085: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21086: LD_VAR 0 6
21090: PPUSH
21091: CALL_OW 257
21095: PUSH
21096: LD_INT 11
21098: EQUAL
21099: IFFALSE 21120
// points := [ 30 , 10 , 5 ] ;
21101: LD_ADDR_VAR 0 9
21105: PUSH
21106: LD_INT 30
21108: PUSH
21109: LD_INT 10
21111: PUSH
21112: LD_INT 5
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: LIST
21119: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21120: LD_VAR 0 1
21124: PPUSH
21125: LD_INT 5
21127: PPUSH
21128: CALL_OW 321
21132: PUSH
21133: LD_INT 2
21135: EQUAL
21136: IFFALSE 21153
// bpoints := bpoints * 1.8 ;
21138: LD_ADDR_VAR 0 10
21142: PUSH
21143: LD_VAR 0 10
21147: PUSH
21148: LD_REAL  1.80000000000000E+0000
21151: MUL
21152: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21153: LD_VAR 0 6
21157: PPUSH
21158: CALL_OW 257
21162: PUSH
21163: LD_INT 1
21165: PUSH
21166: LD_INT 2
21168: PUSH
21169: LD_INT 3
21171: PUSH
21172: LD_INT 4
21174: PUSH
21175: EMPTY
21176: LIST
21177: LIST
21178: LIST
21179: LIST
21180: IN
21181: PUSH
21182: LD_VAR 0 1
21186: PPUSH
21187: LD_INT 51
21189: PPUSH
21190: CALL_OW 321
21194: PUSH
21195: LD_INT 2
21197: EQUAL
21198: AND
21199: IFFALSE 21216
// bpoints := bpoints * 1.2 ;
21201: LD_ADDR_VAR 0 10
21205: PUSH
21206: LD_VAR 0 10
21210: PUSH
21211: LD_REAL  1.20000000000000E+0000
21214: MUL
21215: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21216: LD_VAR 0 6
21220: PPUSH
21221: CALL_OW 257
21225: PUSH
21226: LD_INT 5
21228: PUSH
21229: LD_INT 7
21231: PUSH
21232: LD_INT 9
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: LIST
21239: IN
21240: PUSH
21241: LD_VAR 0 1
21245: PPUSH
21246: LD_INT 52
21248: PPUSH
21249: CALL_OW 321
21253: PUSH
21254: LD_INT 2
21256: EQUAL
21257: AND
21258: IFFALSE 21275
// bpoints := bpoints * 1.5 ;
21260: LD_ADDR_VAR 0 10
21264: PUSH
21265: LD_VAR 0 10
21269: PUSH
21270: LD_REAL  1.50000000000000E+0000
21273: MUL
21274: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21275: LD_VAR 0 1
21279: PPUSH
21280: LD_INT 66
21282: PPUSH
21283: CALL_OW 321
21287: PUSH
21288: LD_INT 2
21290: EQUAL
21291: IFFALSE 21308
// bpoints := bpoints * 1.1 ;
21293: LD_ADDR_VAR 0 10
21297: PUSH
21298: LD_VAR 0 10
21302: PUSH
21303: LD_REAL  1.10000000000000E+0000
21306: MUL
21307: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21308: LD_ADDR_VAR 0 10
21312: PUSH
21313: LD_VAR 0 10
21317: PUSH
21318: LD_VAR 0 6
21322: PPUSH
21323: LD_INT 1
21325: PPUSH
21326: CALL_OW 259
21330: PUSH
21331: LD_REAL  1.15000000000000E+0000
21334: MUL
21335: MUL
21336: ST_TO_ADDR
// end ; unit_vehicle :
21337: GO 22161
21339: LD_INT 2
21341: DOUBLE
21342: EQUAL
21343: IFTRUE 21347
21345: GO 22149
21347: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21348: LD_VAR 0 6
21352: PPUSH
21353: CALL_OW 264
21357: PUSH
21358: LD_INT 2
21360: PUSH
21361: LD_INT 42
21363: PUSH
21364: LD_INT 24
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: IN
21372: IFFALSE 21393
// points := [ 25 , 5 , 3 ] ;
21374: LD_ADDR_VAR 0 9
21378: PUSH
21379: LD_INT 25
21381: PUSH
21382: LD_INT 5
21384: PUSH
21385: LD_INT 3
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: LIST
21392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21393: LD_VAR 0 6
21397: PPUSH
21398: CALL_OW 264
21402: PUSH
21403: LD_INT 4
21405: PUSH
21406: LD_INT 43
21408: PUSH
21409: LD_INT 25
21411: PUSH
21412: EMPTY
21413: LIST
21414: LIST
21415: LIST
21416: IN
21417: IFFALSE 21438
// points := [ 40 , 15 , 5 ] ;
21419: LD_ADDR_VAR 0 9
21423: PUSH
21424: LD_INT 40
21426: PUSH
21427: LD_INT 15
21429: PUSH
21430: LD_INT 5
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: LIST
21437: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21438: LD_VAR 0 6
21442: PPUSH
21443: CALL_OW 264
21447: PUSH
21448: LD_INT 3
21450: PUSH
21451: LD_INT 23
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: IN
21458: IFFALSE 21479
// points := [ 7 , 25 , 8 ] ;
21460: LD_ADDR_VAR 0 9
21464: PUSH
21465: LD_INT 7
21467: PUSH
21468: LD_INT 25
21470: PUSH
21471: LD_INT 8
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: LIST
21478: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21479: LD_VAR 0 6
21483: PPUSH
21484: CALL_OW 264
21488: PUSH
21489: LD_INT 5
21491: PUSH
21492: LD_INT 27
21494: PUSH
21495: LD_INT 44
21497: PUSH
21498: EMPTY
21499: LIST
21500: LIST
21501: LIST
21502: IN
21503: IFFALSE 21524
// points := [ 14 , 50 , 16 ] ;
21505: LD_ADDR_VAR 0 9
21509: PUSH
21510: LD_INT 14
21512: PUSH
21513: LD_INT 50
21515: PUSH
21516: LD_INT 16
21518: PUSH
21519: EMPTY
21520: LIST
21521: LIST
21522: LIST
21523: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21524: LD_VAR 0 6
21528: PPUSH
21529: CALL_OW 264
21533: PUSH
21534: LD_INT 6
21536: PUSH
21537: LD_INT 46
21539: PUSH
21540: EMPTY
21541: LIST
21542: LIST
21543: IN
21544: IFFALSE 21565
// points := [ 32 , 120 , 70 ] ;
21546: LD_ADDR_VAR 0 9
21550: PUSH
21551: LD_INT 32
21553: PUSH
21554: LD_INT 120
21556: PUSH
21557: LD_INT 70
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: LIST
21564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21565: LD_VAR 0 6
21569: PPUSH
21570: CALL_OW 264
21574: PUSH
21575: LD_INT 7
21577: PUSH
21578: LD_INT 28
21580: PUSH
21581: LD_INT 45
21583: PUSH
21584: EMPTY
21585: LIST
21586: LIST
21587: LIST
21588: IN
21589: IFFALSE 21610
// points := [ 35 , 20 , 45 ] ;
21591: LD_ADDR_VAR 0 9
21595: PUSH
21596: LD_INT 35
21598: PUSH
21599: LD_INT 20
21601: PUSH
21602: LD_INT 45
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: LIST
21609: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21610: LD_VAR 0 6
21614: PPUSH
21615: CALL_OW 264
21619: PUSH
21620: LD_INT 47
21622: PUSH
21623: EMPTY
21624: LIST
21625: IN
21626: IFFALSE 21647
// points := [ 67 , 45 , 75 ] ;
21628: LD_ADDR_VAR 0 9
21632: PUSH
21633: LD_INT 67
21635: PUSH
21636: LD_INT 45
21638: PUSH
21639: LD_INT 75
21641: PUSH
21642: EMPTY
21643: LIST
21644: LIST
21645: LIST
21646: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21647: LD_VAR 0 6
21651: PPUSH
21652: CALL_OW 264
21656: PUSH
21657: LD_INT 26
21659: PUSH
21660: EMPTY
21661: LIST
21662: IN
21663: IFFALSE 21684
// points := [ 120 , 30 , 80 ] ;
21665: LD_ADDR_VAR 0 9
21669: PUSH
21670: LD_INT 120
21672: PUSH
21673: LD_INT 30
21675: PUSH
21676: LD_INT 80
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: LIST
21683: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21684: LD_VAR 0 6
21688: PPUSH
21689: CALL_OW 264
21693: PUSH
21694: LD_INT 22
21696: PUSH
21697: EMPTY
21698: LIST
21699: IN
21700: IFFALSE 21721
// points := [ 40 , 1 , 1 ] ;
21702: LD_ADDR_VAR 0 9
21706: PUSH
21707: LD_INT 40
21709: PUSH
21710: LD_INT 1
21712: PUSH
21713: LD_INT 1
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21721: LD_VAR 0 6
21725: PPUSH
21726: CALL_OW 264
21730: PUSH
21731: LD_INT 29
21733: PUSH
21734: EMPTY
21735: LIST
21736: IN
21737: IFFALSE 21758
// points := [ 70 , 200 , 400 ] ;
21739: LD_ADDR_VAR 0 9
21743: PUSH
21744: LD_INT 70
21746: PUSH
21747: LD_INT 200
21749: PUSH
21750: LD_INT 400
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: LIST
21757: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21758: LD_VAR 0 6
21762: PPUSH
21763: CALL_OW 264
21767: PUSH
21768: LD_INT 14
21770: PUSH
21771: LD_INT 53
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: IN
21778: IFFALSE 21799
// points := [ 40 , 10 , 20 ] ;
21780: LD_ADDR_VAR 0 9
21784: PUSH
21785: LD_INT 40
21787: PUSH
21788: LD_INT 10
21790: PUSH
21791: LD_INT 20
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: LIST
21798: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21799: LD_VAR 0 6
21803: PPUSH
21804: CALL_OW 264
21808: PUSH
21809: LD_INT 9
21811: PUSH
21812: EMPTY
21813: LIST
21814: IN
21815: IFFALSE 21836
// points := [ 5 , 70 , 20 ] ;
21817: LD_ADDR_VAR 0 9
21821: PUSH
21822: LD_INT 5
21824: PUSH
21825: LD_INT 70
21827: PUSH
21828: LD_INT 20
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: LIST
21835: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21836: LD_VAR 0 6
21840: PPUSH
21841: CALL_OW 264
21845: PUSH
21846: LD_INT 10
21848: PUSH
21849: EMPTY
21850: LIST
21851: IN
21852: IFFALSE 21873
// points := [ 35 , 110 , 70 ] ;
21854: LD_ADDR_VAR 0 9
21858: PUSH
21859: LD_INT 35
21861: PUSH
21862: LD_INT 110
21864: PUSH
21865: LD_INT 70
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: LIST
21872: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21873: LD_VAR 0 6
21877: PPUSH
21878: CALL_OW 265
21882: PUSH
21883: LD_INT 25
21885: EQUAL
21886: IFFALSE 21907
// points := [ 80 , 65 , 100 ] ;
21888: LD_ADDR_VAR 0 9
21892: PUSH
21893: LD_INT 80
21895: PUSH
21896: LD_INT 65
21898: PUSH
21899: LD_INT 100
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: LIST
21906: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21907: LD_VAR 0 6
21911: PPUSH
21912: CALL_OW 263
21916: PUSH
21917: LD_INT 1
21919: EQUAL
21920: IFFALSE 21955
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21922: LD_ADDR_VAR 0 10
21926: PUSH
21927: LD_VAR 0 10
21931: PUSH
21932: LD_VAR 0 6
21936: PPUSH
21937: CALL_OW 311
21941: PPUSH
21942: LD_INT 3
21944: PPUSH
21945: CALL_OW 259
21949: PUSH
21950: LD_INT 4
21952: MUL
21953: MUL
21954: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21955: LD_VAR 0 6
21959: PPUSH
21960: CALL_OW 263
21964: PUSH
21965: LD_INT 2
21967: EQUAL
21968: IFFALSE 22019
// begin j := IsControledBy ( i ) ;
21970: LD_ADDR_VAR 0 7
21974: PUSH
21975: LD_VAR 0 6
21979: PPUSH
21980: CALL_OW 312
21984: ST_TO_ADDR
// if j then
21985: LD_VAR 0 7
21989: IFFALSE 22019
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21991: LD_ADDR_VAR 0 10
21995: PUSH
21996: LD_VAR 0 10
22000: PUSH
22001: LD_VAR 0 7
22005: PPUSH
22006: LD_INT 3
22008: PPUSH
22009: CALL_OW 259
22013: PUSH
22014: LD_INT 3
22016: MUL
22017: MUL
22018: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22019: LD_VAR 0 6
22023: PPUSH
22024: CALL_OW 264
22028: PUSH
22029: LD_INT 5
22031: PUSH
22032: LD_INT 6
22034: PUSH
22035: LD_INT 46
22037: PUSH
22038: LD_INT 44
22040: PUSH
22041: LD_INT 47
22043: PUSH
22044: LD_INT 45
22046: PUSH
22047: LD_INT 28
22049: PUSH
22050: LD_INT 7
22052: PUSH
22053: LD_INT 27
22055: PUSH
22056: LD_INT 29
22058: PUSH
22059: EMPTY
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: LIST
22065: LIST
22066: LIST
22067: LIST
22068: LIST
22069: LIST
22070: IN
22071: PUSH
22072: LD_VAR 0 1
22076: PPUSH
22077: LD_INT 52
22079: PPUSH
22080: CALL_OW 321
22084: PUSH
22085: LD_INT 2
22087: EQUAL
22088: AND
22089: IFFALSE 22106
// bpoints := bpoints * 1.2 ;
22091: LD_ADDR_VAR 0 10
22095: PUSH
22096: LD_VAR 0 10
22100: PUSH
22101: LD_REAL  1.20000000000000E+0000
22104: MUL
22105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22106: LD_VAR 0 6
22110: PPUSH
22111: CALL_OW 264
22115: PUSH
22116: LD_INT 6
22118: PUSH
22119: LD_INT 46
22121: PUSH
22122: LD_INT 47
22124: PUSH
22125: EMPTY
22126: LIST
22127: LIST
22128: LIST
22129: IN
22130: IFFALSE 22147
// bpoints := bpoints * 1.2 ;
22132: LD_ADDR_VAR 0 10
22136: PUSH
22137: LD_VAR 0 10
22141: PUSH
22142: LD_REAL  1.20000000000000E+0000
22145: MUL
22146: ST_TO_ADDR
// end ; unit_building :
22147: GO 22161
22149: LD_INT 3
22151: DOUBLE
22152: EQUAL
22153: IFTRUE 22157
22155: GO 22160
22157: POP
// ; end ;
22158: GO 22161
22160: POP
// for j = 1 to 3 do
22161: LD_ADDR_VAR 0 7
22165: PUSH
22166: DOUBLE
22167: LD_INT 1
22169: DEC
22170: ST_TO_ADDR
22171: LD_INT 3
22173: PUSH
22174: FOR_TO
22175: IFFALSE 22228
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22177: LD_ADDR_VAR 0 5
22181: PUSH
22182: LD_VAR 0 5
22186: PPUSH
22187: LD_VAR 0 7
22191: PPUSH
22192: LD_VAR 0 5
22196: PUSH
22197: LD_VAR 0 7
22201: ARRAY
22202: PUSH
22203: LD_VAR 0 9
22207: PUSH
22208: LD_VAR 0 7
22212: ARRAY
22213: PUSH
22214: LD_VAR 0 10
22218: MUL
22219: PLUS
22220: PPUSH
22221: CALL_OW 1
22225: ST_TO_ADDR
22226: GO 22174
22228: POP
22229: POP
// end ;
22230: GO 20713
22232: POP
22233: POP
// result := Replace ( result , 4 , tmp ) ;
22234: LD_ADDR_VAR 0 5
22238: PUSH
22239: LD_VAR 0 5
22243: PPUSH
22244: LD_INT 4
22246: PPUSH
22247: LD_VAR 0 8
22251: PPUSH
22252: CALL_OW 1
22256: ST_TO_ADDR
// end ;
22257: LD_VAR 0 5
22261: RET
// export function DangerAtRange ( unit , range ) ; begin
22262: LD_INT 0
22264: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22265: LD_ADDR_VAR 0 3
22269: PUSH
22270: LD_VAR 0 1
22274: PPUSH
22275: CALL_OW 255
22279: PPUSH
22280: LD_VAR 0 1
22284: PPUSH
22285: CALL_OW 250
22289: PPUSH
22290: LD_VAR 0 1
22294: PPUSH
22295: CALL_OW 251
22299: PPUSH
22300: LD_VAR 0 2
22304: PPUSH
22305: CALL 20565 0 4
22309: ST_TO_ADDR
// end ;
22310: LD_VAR 0 3
22314: RET
// export function DangerInArea ( side , area ) ; begin
22315: LD_INT 0
22317: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22318: LD_ADDR_VAR 0 3
22322: PUSH
22323: LD_VAR 0 2
22327: PPUSH
22328: LD_INT 81
22330: PUSH
22331: LD_VAR 0 1
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PPUSH
22340: CALL_OW 70
22344: ST_TO_ADDR
// end ;
22345: LD_VAR 0 3
22349: RET
// export function IsExtension ( b ) ; begin
22350: LD_INT 0
22352: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22353: LD_ADDR_VAR 0 2
22357: PUSH
22358: LD_VAR 0 1
22362: PUSH
22363: LD_INT 23
22365: PUSH
22366: LD_INT 20
22368: PUSH
22369: LD_INT 22
22371: PUSH
22372: LD_INT 17
22374: PUSH
22375: LD_INT 24
22377: PUSH
22378: LD_INT 21
22380: PUSH
22381: LD_INT 19
22383: PUSH
22384: LD_INT 16
22386: PUSH
22387: LD_INT 25
22389: PUSH
22390: LD_INT 18
22392: PUSH
22393: EMPTY
22394: LIST
22395: LIST
22396: LIST
22397: LIST
22398: LIST
22399: LIST
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: IN
22405: ST_TO_ADDR
// end ;
22406: LD_VAR 0 2
22410: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22411: LD_INT 0
22413: PPUSH
22414: PPUSH
22415: PPUSH
// result := [ ] ;
22416: LD_ADDR_VAR 0 4
22420: PUSH
22421: EMPTY
22422: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22423: LD_ADDR_VAR 0 5
22427: PUSH
22428: LD_VAR 0 2
22432: PPUSH
22433: LD_INT 21
22435: PUSH
22436: LD_INT 3
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: PPUSH
22443: CALL_OW 70
22447: ST_TO_ADDR
// if not tmp then
22448: LD_VAR 0 5
22452: NOT
22453: IFFALSE 22457
// exit ;
22455: GO 22521
// if checkLink then
22457: LD_VAR 0 3
22461: IFFALSE 22511
// begin for i in tmp do
22463: LD_ADDR_VAR 0 6
22467: PUSH
22468: LD_VAR 0 5
22472: PUSH
22473: FOR_IN
22474: IFFALSE 22509
// if GetBase ( i ) <> base then
22476: LD_VAR 0 6
22480: PPUSH
22481: CALL_OW 274
22485: PUSH
22486: LD_VAR 0 1
22490: NONEQUAL
22491: IFFALSE 22507
// ComLinkToBase ( base , i ) ;
22493: LD_VAR 0 1
22497: PPUSH
22498: LD_VAR 0 6
22502: PPUSH
22503: CALL_OW 169
22507: GO 22473
22509: POP
22510: POP
// end ; result := tmp ;
22511: LD_ADDR_VAR 0 4
22515: PUSH
22516: LD_VAR 0 5
22520: ST_TO_ADDR
// end ;
22521: LD_VAR 0 4
22525: RET
// export function ComComplete ( units , b ) ; var i ; begin
22526: LD_INT 0
22528: PPUSH
22529: PPUSH
// if not units then
22530: LD_VAR 0 1
22534: NOT
22535: IFFALSE 22539
// exit ;
22537: GO 22629
// for i in units do
22539: LD_ADDR_VAR 0 4
22543: PUSH
22544: LD_VAR 0 1
22548: PUSH
22549: FOR_IN
22550: IFFALSE 22627
// if BuildingStatus ( b ) = bs_build then
22552: LD_VAR 0 2
22556: PPUSH
22557: CALL_OW 461
22561: PUSH
22562: LD_INT 1
22564: EQUAL
22565: IFFALSE 22625
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22567: LD_VAR 0 4
22571: PPUSH
22572: LD_STRING h
22574: PUSH
22575: LD_VAR 0 2
22579: PPUSH
22580: CALL_OW 250
22584: PUSH
22585: LD_VAR 0 2
22589: PPUSH
22590: CALL_OW 251
22594: PUSH
22595: LD_VAR 0 2
22599: PUSH
22600: LD_INT 0
22602: PUSH
22603: LD_INT 0
22605: PUSH
22606: LD_INT 0
22608: PUSH
22609: EMPTY
22610: LIST
22611: LIST
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: PUSH
22618: EMPTY
22619: LIST
22620: PPUSH
22621: CALL_OW 446
22625: GO 22549
22627: POP
22628: POP
// end ;
22629: LD_VAR 0 3
22633: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22634: LD_INT 0
22636: PPUSH
22637: PPUSH
22638: PPUSH
22639: PPUSH
22640: PPUSH
22641: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22642: LD_VAR 0 1
22646: NOT
22647: PUSH
22648: LD_VAR 0 1
22652: PPUSH
22653: CALL_OW 263
22657: PUSH
22658: LD_INT 2
22660: EQUAL
22661: NOT
22662: OR
22663: IFFALSE 22667
// exit ;
22665: GO 22983
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22667: LD_ADDR_VAR 0 6
22671: PUSH
22672: LD_INT 22
22674: PUSH
22675: LD_VAR 0 1
22679: PPUSH
22680: CALL_OW 255
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: PUSH
22689: LD_INT 2
22691: PUSH
22692: LD_INT 30
22694: PUSH
22695: LD_INT 36
22697: PUSH
22698: EMPTY
22699: LIST
22700: LIST
22701: PUSH
22702: LD_INT 34
22704: PUSH
22705: LD_INT 31
22707: PUSH
22708: EMPTY
22709: LIST
22710: LIST
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PPUSH
22721: CALL_OW 69
22725: ST_TO_ADDR
// if not tmp then
22726: LD_VAR 0 6
22730: NOT
22731: IFFALSE 22735
// exit ;
22733: GO 22983
// result := [ ] ;
22735: LD_ADDR_VAR 0 2
22739: PUSH
22740: EMPTY
22741: ST_TO_ADDR
// for i in tmp do
22742: LD_ADDR_VAR 0 3
22746: PUSH
22747: LD_VAR 0 6
22751: PUSH
22752: FOR_IN
22753: IFFALSE 22824
// begin t := UnitsInside ( i ) ;
22755: LD_ADDR_VAR 0 4
22759: PUSH
22760: LD_VAR 0 3
22764: PPUSH
22765: CALL_OW 313
22769: ST_TO_ADDR
// if t then
22770: LD_VAR 0 4
22774: IFFALSE 22822
// for j in t do
22776: LD_ADDR_VAR 0 7
22780: PUSH
22781: LD_VAR 0 4
22785: PUSH
22786: FOR_IN
22787: IFFALSE 22820
// result := Insert ( result , result + 1 , j ) ;
22789: LD_ADDR_VAR 0 2
22793: PUSH
22794: LD_VAR 0 2
22798: PPUSH
22799: LD_VAR 0 2
22803: PUSH
22804: LD_INT 1
22806: PLUS
22807: PPUSH
22808: LD_VAR 0 7
22812: PPUSH
22813: CALL_OW 2
22817: ST_TO_ADDR
22818: GO 22786
22820: POP
22821: POP
// end ;
22822: GO 22752
22824: POP
22825: POP
// if not result then
22826: LD_VAR 0 2
22830: NOT
22831: IFFALSE 22835
// exit ;
22833: GO 22983
// mech := result [ 1 ] ;
22835: LD_ADDR_VAR 0 5
22839: PUSH
22840: LD_VAR 0 2
22844: PUSH
22845: LD_INT 1
22847: ARRAY
22848: ST_TO_ADDR
// if result > 1 then
22849: LD_VAR 0 2
22853: PUSH
22854: LD_INT 1
22856: GREATER
22857: IFFALSE 22969
// for i = 2 to result do
22859: LD_ADDR_VAR 0 3
22863: PUSH
22864: DOUBLE
22865: LD_INT 2
22867: DEC
22868: ST_TO_ADDR
22869: LD_VAR 0 2
22873: PUSH
22874: FOR_TO
22875: IFFALSE 22967
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22877: LD_ADDR_VAR 0 4
22881: PUSH
22882: LD_VAR 0 2
22886: PUSH
22887: LD_VAR 0 3
22891: ARRAY
22892: PPUSH
22893: LD_INT 3
22895: PPUSH
22896: CALL_OW 259
22900: PUSH
22901: LD_VAR 0 2
22905: PUSH
22906: LD_VAR 0 3
22910: ARRAY
22911: PPUSH
22912: CALL_OW 432
22916: MINUS
22917: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22918: LD_VAR 0 4
22922: PUSH
22923: LD_VAR 0 5
22927: PPUSH
22928: LD_INT 3
22930: PPUSH
22931: CALL_OW 259
22935: PUSH
22936: LD_VAR 0 5
22940: PPUSH
22941: CALL_OW 432
22945: MINUS
22946: GREATEREQUAL
22947: IFFALSE 22965
// mech := result [ i ] ;
22949: LD_ADDR_VAR 0 5
22953: PUSH
22954: LD_VAR 0 2
22958: PUSH
22959: LD_VAR 0 3
22963: ARRAY
22964: ST_TO_ADDR
// end ;
22965: GO 22874
22967: POP
22968: POP
// ComLinkTo ( vehicle , mech ) ;
22969: LD_VAR 0 1
22973: PPUSH
22974: LD_VAR 0 5
22978: PPUSH
22979: CALL_OW 135
// end ;
22983: LD_VAR 0 2
22987: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22988: LD_INT 0
22990: PPUSH
22991: PPUSH
22992: PPUSH
22993: PPUSH
22994: PPUSH
22995: PPUSH
22996: PPUSH
22997: PPUSH
22998: PPUSH
22999: PPUSH
23000: PPUSH
23001: PPUSH
23002: PPUSH
// result := [ ] ;
23003: LD_ADDR_VAR 0 7
23007: PUSH
23008: EMPTY
23009: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23010: LD_VAR 0 1
23014: PPUSH
23015: CALL_OW 266
23019: PUSH
23020: LD_INT 0
23022: PUSH
23023: LD_INT 1
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: IN
23030: NOT
23031: IFFALSE 23035
// exit ;
23033: GO 24669
// if name then
23035: LD_VAR 0 3
23039: IFFALSE 23055
// SetBName ( base_dep , name ) ;
23041: LD_VAR 0 1
23045: PPUSH
23046: LD_VAR 0 3
23050: PPUSH
23051: CALL_OW 500
// base := GetBase ( base_dep ) ;
23055: LD_ADDR_VAR 0 15
23059: PUSH
23060: LD_VAR 0 1
23064: PPUSH
23065: CALL_OW 274
23069: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23070: LD_ADDR_VAR 0 16
23074: PUSH
23075: LD_VAR 0 1
23079: PPUSH
23080: CALL_OW 255
23084: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23085: LD_ADDR_VAR 0 17
23089: PUSH
23090: LD_VAR 0 1
23094: PPUSH
23095: CALL_OW 248
23099: ST_TO_ADDR
// if sources then
23100: LD_VAR 0 5
23104: IFFALSE 23151
// for i = 1 to 3 do
23106: LD_ADDR_VAR 0 8
23110: PUSH
23111: DOUBLE
23112: LD_INT 1
23114: DEC
23115: ST_TO_ADDR
23116: LD_INT 3
23118: PUSH
23119: FOR_TO
23120: IFFALSE 23149
// AddResourceType ( base , i , sources [ i ] ) ;
23122: LD_VAR 0 15
23126: PPUSH
23127: LD_VAR 0 8
23131: PPUSH
23132: LD_VAR 0 5
23136: PUSH
23137: LD_VAR 0 8
23141: ARRAY
23142: PPUSH
23143: CALL_OW 276
23147: GO 23119
23149: POP
23150: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23151: LD_ADDR_VAR 0 18
23155: PUSH
23156: LD_VAR 0 15
23160: PPUSH
23161: LD_VAR 0 2
23165: PPUSH
23166: LD_INT 1
23168: PPUSH
23169: CALL 22411 0 3
23173: ST_TO_ADDR
// InitHc ;
23174: CALL_OW 19
// InitUc ;
23178: CALL_OW 18
// uc_side := side ;
23182: LD_ADDR_OWVAR 20
23186: PUSH
23187: LD_VAR 0 16
23191: ST_TO_ADDR
// uc_nation := nation ;
23192: LD_ADDR_OWVAR 21
23196: PUSH
23197: LD_VAR 0 17
23201: ST_TO_ADDR
// if buildings then
23202: LD_VAR 0 18
23206: IFFALSE 24528
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23208: LD_ADDR_VAR 0 19
23212: PUSH
23213: LD_VAR 0 18
23217: PPUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 30
23223: PUSH
23224: LD_INT 29
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 30
23233: PUSH
23234: LD_INT 30
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: LIST
23245: PPUSH
23246: CALL_OW 72
23250: ST_TO_ADDR
// if tmp then
23251: LD_VAR 0 19
23255: IFFALSE 23303
// for i in tmp do
23257: LD_ADDR_VAR 0 8
23261: PUSH
23262: LD_VAR 0 19
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23301
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23270: LD_VAR 0 8
23274: PPUSH
23275: CALL_OW 250
23279: PPUSH
23280: LD_VAR 0 8
23284: PPUSH
23285: CALL_OW 251
23289: PPUSH
23290: LD_VAR 0 16
23294: PPUSH
23295: CALL_OW 441
23299: GO 23267
23301: POP
23302: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23303: LD_VAR 0 18
23307: PPUSH
23308: LD_INT 2
23310: PUSH
23311: LD_INT 30
23313: PUSH
23314: LD_INT 32
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: PUSH
23321: LD_INT 30
23323: PUSH
23324: LD_INT 33
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: PUSH
23331: EMPTY
23332: LIST
23333: LIST
23334: LIST
23335: PPUSH
23336: CALL_OW 72
23340: IFFALSE 23428
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23342: LD_ADDR_VAR 0 8
23346: PUSH
23347: LD_VAR 0 18
23351: PPUSH
23352: LD_INT 2
23354: PUSH
23355: LD_INT 30
23357: PUSH
23358: LD_INT 32
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 30
23367: PUSH
23368: LD_INT 33
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: LIST
23379: PPUSH
23380: CALL_OW 72
23384: PUSH
23385: FOR_IN
23386: IFFALSE 23426
// begin if not GetBWeapon ( i ) then
23388: LD_VAR 0 8
23392: PPUSH
23393: CALL_OW 269
23397: NOT
23398: IFFALSE 23424
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23400: LD_VAR 0 8
23404: PPUSH
23405: LD_VAR 0 8
23409: PPUSH
23410: LD_VAR 0 2
23414: PPUSH
23415: CALL 24674 0 2
23419: PPUSH
23420: CALL_OW 431
// end ;
23424: GO 23385
23426: POP
23427: POP
// end ; for i = 1 to personel do
23428: LD_ADDR_VAR 0 8
23432: PUSH
23433: DOUBLE
23434: LD_INT 1
23436: DEC
23437: ST_TO_ADDR
23438: LD_VAR 0 6
23442: PUSH
23443: FOR_TO
23444: IFFALSE 24508
// begin if i > 4 then
23446: LD_VAR 0 8
23450: PUSH
23451: LD_INT 4
23453: GREATER
23454: IFFALSE 23458
// break ;
23456: GO 24508
// case i of 1 :
23458: LD_VAR 0 8
23462: PUSH
23463: LD_INT 1
23465: DOUBLE
23466: EQUAL
23467: IFTRUE 23471
23469: GO 23551
23471: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23472: LD_ADDR_VAR 0 12
23476: PUSH
23477: LD_VAR 0 18
23481: PPUSH
23482: LD_INT 22
23484: PUSH
23485: LD_VAR 0 16
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 58
23496: PUSH
23497: EMPTY
23498: LIST
23499: PUSH
23500: LD_INT 2
23502: PUSH
23503: LD_INT 30
23505: PUSH
23506: LD_INT 32
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: PUSH
23513: LD_INT 30
23515: PUSH
23516: LD_INT 4
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: PUSH
23523: LD_INT 30
23525: PUSH
23526: LD_INT 5
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: LIST
23537: LIST
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: LIST
23543: PPUSH
23544: CALL_OW 72
23548: ST_TO_ADDR
23549: GO 23773
23551: LD_INT 2
23553: DOUBLE
23554: EQUAL
23555: IFTRUE 23559
23557: GO 23621
23559: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23560: LD_ADDR_VAR 0 12
23564: PUSH
23565: LD_VAR 0 18
23569: PPUSH
23570: LD_INT 22
23572: PUSH
23573: LD_VAR 0 16
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PUSH
23582: LD_INT 2
23584: PUSH
23585: LD_INT 30
23587: PUSH
23588: LD_INT 0
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PUSH
23595: LD_INT 30
23597: PUSH
23598: LD_INT 1
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: LIST
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PPUSH
23614: CALL_OW 72
23618: ST_TO_ADDR
23619: GO 23773
23621: LD_INT 3
23623: DOUBLE
23624: EQUAL
23625: IFTRUE 23629
23627: GO 23691
23629: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23630: LD_ADDR_VAR 0 12
23634: PUSH
23635: LD_VAR 0 18
23639: PPUSH
23640: LD_INT 22
23642: PUSH
23643: LD_VAR 0 16
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: LD_INT 2
23654: PUSH
23655: LD_INT 30
23657: PUSH
23658: LD_INT 2
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: LD_INT 30
23667: PUSH
23668: LD_INT 3
23670: PUSH
23671: EMPTY
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PUSH
23680: EMPTY
23681: LIST
23682: LIST
23683: PPUSH
23684: CALL_OW 72
23688: ST_TO_ADDR
23689: GO 23773
23691: LD_INT 4
23693: DOUBLE
23694: EQUAL
23695: IFTRUE 23699
23697: GO 23772
23699: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23700: LD_ADDR_VAR 0 12
23704: PUSH
23705: LD_VAR 0 18
23709: PPUSH
23710: LD_INT 22
23712: PUSH
23713: LD_VAR 0 16
23717: PUSH
23718: EMPTY
23719: LIST
23720: LIST
23721: PUSH
23722: LD_INT 2
23724: PUSH
23725: LD_INT 30
23727: PUSH
23728: LD_INT 6
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: LD_INT 30
23737: PUSH
23738: LD_INT 7
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PUSH
23745: LD_INT 30
23747: PUSH
23748: LD_INT 8
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: EMPTY
23756: LIST
23757: LIST
23758: LIST
23759: LIST
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PPUSH
23765: CALL_OW 72
23769: ST_TO_ADDR
23770: GO 23773
23772: POP
// if i = 1 then
23773: LD_VAR 0 8
23777: PUSH
23778: LD_INT 1
23780: EQUAL
23781: IFFALSE 23892
// begin tmp := [ ] ;
23783: LD_ADDR_VAR 0 19
23787: PUSH
23788: EMPTY
23789: ST_TO_ADDR
// for j in f do
23790: LD_ADDR_VAR 0 9
23794: PUSH
23795: LD_VAR 0 12
23799: PUSH
23800: FOR_IN
23801: IFFALSE 23874
// if GetBType ( j ) = b_bunker then
23803: LD_VAR 0 9
23807: PPUSH
23808: CALL_OW 266
23812: PUSH
23813: LD_INT 32
23815: EQUAL
23816: IFFALSE 23843
// tmp := Insert ( tmp , 1 , j ) else
23818: LD_ADDR_VAR 0 19
23822: PUSH
23823: LD_VAR 0 19
23827: PPUSH
23828: LD_INT 1
23830: PPUSH
23831: LD_VAR 0 9
23835: PPUSH
23836: CALL_OW 2
23840: ST_TO_ADDR
23841: GO 23872
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23843: LD_ADDR_VAR 0 19
23847: PUSH
23848: LD_VAR 0 19
23852: PPUSH
23853: LD_VAR 0 19
23857: PUSH
23858: LD_INT 1
23860: PLUS
23861: PPUSH
23862: LD_VAR 0 9
23866: PPUSH
23867: CALL_OW 2
23871: ST_TO_ADDR
23872: GO 23800
23874: POP
23875: POP
// if tmp then
23876: LD_VAR 0 19
23880: IFFALSE 23892
// f := tmp ;
23882: LD_ADDR_VAR 0 12
23886: PUSH
23887: LD_VAR 0 19
23891: ST_TO_ADDR
// end ; x := personel [ i ] ;
23892: LD_ADDR_VAR 0 13
23896: PUSH
23897: LD_VAR 0 6
23901: PUSH
23902: LD_VAR 0 8
23906: ARRAY
23907: ST_TO_ADDR
// if x = - 1 then
23908: LD_VAR 0 13
23912: PUSH
23913: LD_INT 1
23915: NEG
23916: EQUAL
23917: IFFALSE 24126
// begin for j in f do
23919: LD_ADDR_VAR 0 9
23923: PUSH
23924: LD_VAR 0 12
23928: PUSH
23929: FOR_IN
23930: IFFALSE 24122
// repeat InitHc ;
23932: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23936: LD_VAR 0 9
23940: PPUSH
23941: CALL_OW 266
23945: PUSH
23946: LD_INT 5
23948: EQUAL
23949: IFFALSE 24019
// begin if UnitsInside ( j ) < 3 then
23951: LD_VAR 0 9
23955: PPUSH
23956: CALL_OW 313
23960: PUSH
23961: LD_INT 3
23963: LESS
23964: IFFALSE 24000
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23966: LD_INT 0
23968: PPUSH
23969: LD_INT 5
23971: PUSH
23972: LD_INT 8
23974: PUSH
23975: LD_INT 9
23977: PUSH
23978: EMPTY
23979: LIST
23980: LIST
23981: LIST
23982: PUSH
23983: LD_VAR 0 17
23987: ARRAY
23988: PPUSH
23989: LD_VAR 0 4
23993: PPUSH
23994: CALL_OW 380
23998: GO 24017
// PrepareHuman ( false , i , skill ) ;
24000: LD_INT 0
24002: PPUSH
24003: LD_VAR 0 8
24007: PPUSH
24008: LD_VAR 0 4
24012: PPUSH
24013: CALL_OW 380
// end else
24017: GO 24036
// PrepareHuman ( false , i , skill ) ;
24019: LD_INT 0
24021: PPUSH
24022: LD_VAR 0 8
24026: PPUSH
24027: LD_VAR 0 4
24031: PPUSH
24032: CALL_OW 380
// un := CreateHuman ;
24036: LD_ADDR_VAR 0 14
24040: PUSH
24041: CALL_OW 44
24045: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24046: LD_ADDR_VAR 0 7
24050: PUSH
24051: LD_VAR 0 7
24055: PPUSH
24056: LD_INT 1
24058: PPUSH
24059: LD_VAR 0 14
24063: PPUSH
24064: CALL_OW 2
24068: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24069: LD_VAR 0 14
24073: PPUSH
24074: LD_VAR 0 9
24078: PPUSH
24079: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24083: LD_VAR 0 9
24087: PPUSH
24088: CALL_OW 313
24092: PUSH
24093: LD_INT 6
24095: EQUAL
24096: PUSH
24097: LD_VAR 0 9
24101: PPUSH
24102: CALL_OW 266
24106: PUSH
24107: LD_INT 32
24109: PUSH
24110: LD_INT 31
24112: PUSH
24113: EMPTY
24114: LIST
24115: LIST
24116: IN
24117: OR
24118: IFFALSE 23932
24120: GO 23929
24122: POP
24123: POP
// end else
24124: GO 24506
// for j = 1 to x do
24126: LD_ADDR_VAR 0 9
24130: PUSH
24131: DOUBLE
24132: LD_INT 1
24134: DEC
24135: ST_TO_ADDR
24136: LD_VAR 0 13
24140: PUSH
24141: FOR_TO
24142: IFFALSE 24504
// begin InitHc ;
24144: CALL_OW 19
// if not f then
24148: LD_VAR 0 12
24152: NOT
24153: IFFALSE 24242
// begin PrepareHuman ( false , i , skill ) ;
24155: LD_INT 0
24157: PPUSH
24158: LD_VAR 0 8
24162: PPUSH
24163: LD_VAR 0 4
24167: PPUSH
24168: CALL_OW 380
// un := CreateHuman ;
24172: LD_ADDR_VAR 0 14
24176: PUSH
24177: CALL_OW 44
24181: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24182: LD_ADDR_VAR 0 7
24186: PUSH
24187: LD_VAR 0 7
24191: PPUSH
24192: LD_INT 1
24194: PPUSH
24195: LD_VAR 0 14
24199: PPUSH
24200: CALL_OW 2
24204: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24205: LD_VAR 0 14
24209: PPUSH
24210: LD_VAR 0 1
24214: PPUSH
24215: CALL_OW 250
24219: PPUSH
24220: LD_VAR 0 1
24224: PPUSH
24225: CALL_OW 251
24229: PPUSH
24230: LD_INT 10
24232: PPUSH
24233: LD_INT 0
24235: PPUSH
24236: CALL_OW 50
// continue ;
24240: GO 24141
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24242: LD_VAR 0 12
24246: PUSH
24247: LD_INT 1
24249: ARRAY
24250: PPUSH
24251: CALL_OW 313
24255: PUSH
24256: LD_VAR 0 12
24260: PUSH
24261: LD_INT 1
24263: ARRAY
24264: PPUSH
24265: CALL_OW 266
24269: PUSH
24270: LD_INT 32
24272: PUSH
24273: LD_INT 31
24275: PUSH
24276: EMPTY
24277: LIST
24278: LIST
24279: IN
24280: AND
24281: PUSH
24282: LD_VAR 0 12
24286: PUSH
24287: LD_INT 1
24289: ARRAY
24290: PPUSH
24291: CALL_OW 313
24295: PUSH
24296: LD_INT 6
24298: EQUAL
24299: OR
24300: IFFALSE 24320
// f := Delete ( f , 1 ) ;
24302: LD_ADDR_VAR 0 12
24306: PUSH
24307: LD_VAR 0 12
24311: PPUSH
24312: LD_INT 1
24314: PPUSH
24315: CALL_OW 3
24319: ST_TO_ADDR
// if not f then
24320: LD_VAR 0 12
24324: NOT
24325: IFFALSE 24343
// begin x := x + 2 ;
24327: LD_ADDR_VAR 0 13
24331: PUSH
24332: LD_VAR 0 13
24336: PUSH
24337: LD_INT 2
24339: PLUS
24340: ST_TO_ADDR
// continue ;
24341: GO 24141
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24343: LD_VAR 0 12
24347: PUSH
24348: LD_INT 1
24350: ARRAY
24351: PPUSH
24352: CALL_OW 266
24356: PUSH
24357: LD_INT 5
24359: EQUAL
24360: IFFALSE 24434
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24362: LD_VAR 0 12
24366: PUSH
24367: LD_INT 1
24369: ARRAY
24370: PPUSH
24371: CALL_OW 313
24375: PUSH
24376: LD_INT 3
24378: LESS
24379: IFFALSE 24415
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24381: LD_INT 0
24383: PPUSH
24384: LD_INT 5
24386: PUSH
24387: LD_INT 8
24389: PUSH
24390: LD_INT 9
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: PUSH
24398: LD_VAR 0 17
24402: ARRAY
24403: PPUSH
24404: LD_VAR 0 4
24408: PPUSH
24409: CALL_OW 380
24413: GO 24432
// PrepareHuman ( false , i , skill ) ;
24415: LD_INT 0
24417: PPUSH
24418: LD_VAR 0 8
24422: PPUSH
24423: LD_VAR 0 4
24427: PPUSH
24428: CALL_OW 380
// end else
24432: GO 24451
// PrepareHuman ( false , i , skill ) ;
24434: LD_INT 0
24436: PPUSH
24437: LD_VAR 0 8
24441: PPUSH
24442: LD_VAR 0 4
24446: PPUSH
24447: CALL_OW 380
// un := CreateHuman ;
24451: LD_ADDR_VAR 0 14
24455: PUSH
24456: CALL_OW 44
24460: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24461: LD_ADDR_VAR 0 7
24465: PUSH
24466: LD_VAR 0 7
24470: PPUSH
24471: LD_INT 1
24473: PPUSH
24474: LD_VAR 0 14
24478: PPUSH
24479: CALL_OW 2
24483: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24484: LD_VAR 0 14
24488: PPUSH
24489: LD_VAR 0 12
24493: PUSH
24494: LD_INT 1
24496: ARRAY
24497: PPUSH
24498: CALL_OW 52
// end ;
24502: GO 24141
24504: POP
24505: POP
// end ;
24506: GO 23443
24508: POP
24509: POP
// result := result ^ buildings ;
24510: LD_ADDR_VAR 0 7
24514: PUSH
24515: LD_VAR 0 7
24519: PUSH
24520: LD_VAR 0 18
24524: ADD
24525: ST_TO_ADDR
// end else
24526: GO 24669
// begin for i = 1 to personel do
24528: LD_ADDR_VAR 0 8
24532: PUSH
24533: DOUBLE
24534: LD_INT 1
24536: DEC
24537: ST_TO_ADDR
24538: LD_VAR 0 6
24542: PUSH
24543: FOR_TO
24544: IFFALSE 24667
// begin if i > 4 then
24546: LD_VAR 0 8
24550: PUSH
24551: LD_INT 4
24553: GREATER
24554: IFFALSE 24558
// break ;
24556: GO 24667
// x := personel [ i ] ;
24558: LD_ADDR_VAR 0 13
24562: PUSH
24563: LD_VAR 0 6
24567: PUSH
24568: LD_VAR 0 8
24572: ARRAY
24573: ST_TO_ADDR
// if x = - 1 then
24574: LD_VAR 0 13
24578: PUSH
24579: LD_INT 1
24581: NEG
24582: EQUAL
24583: IFFALSE 24587
// continue ;
24585: GO 24543
// PrepareHuman ( false , i , skill ) ;
24587: LD_INT 0
24589: PPUSH
24590: LD_VAR 0 8
24594: PPUSH
24595: LD_VAR 0 4
24599: PPUSH
24600: CALL_OW 380
// un := CreateHuman ;
24604: LD_ADDR_VAR 0 14
24608: PUSH
24609: CALL_OW 44
24613: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24614: LD_VAR 0 14
24618: PPUSH
24619: LD_VAR 0 1
24623: PPUSH
24624: CALL_OW 250
24628: PPUSH
24629: LD_VAR 0 1
24633: PPUSH
24634: CALL_OW 251
24638: PPUSH
24639: LD_INT 10
24641: PPUSH
24642: LD_INT 0
24644: PPUSH
24645: CALL_OW 50
// result := result ^ un ;
24649: LD_ADDR_VAR 0 7
24653: PUSH
24654: LD_VAR 0 7
24658: PUSH
24659: LD_VAR 0 14
24663: ADD
24664: ST_TO_ADDR
// end ;
24665: GO 24543
24667: POP
24668: POP
// end ; end ;
24669: LD_VAR 0 7
24673: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24674: LD_INT 0
24676: PPUSH
24677: PPUSH
24678: PPUSH
24679: PPUSH
24680: PPUSH
24681: PPUSH
24682: PPUSH
24683: PPUSH
24684: PPUSH
24685: PPUSH
24686: PPUSH
24687: PPUSH
24688: PPUSH
24689: PPUSH
24690: PPUSH
24691: PPUSH
// result := false ;
24692: LD_ADDR_VAR 0 3
24696: PUSH
24697: LD_INT 0
24699: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24700: LD_VAR 0 1
24704: NOT
24705: PUSH
24706: LD_VAR 0 1
24710: PPUSH
24711: CALL_OW 266
24715: PUSH
24716: LD_INT 32
24718: PUSH
24719: LD_INT 33
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: IN
24726: NOT
24727: OR
24728: IFFALSE 24732
// exit ;
24730: GO 25841
// nat := GetNation ( tower ) ;
24732: LD_ADDR_VAR 0 12
24736: PUSH
24737: LD_VAR 0 1
24741: PPUSH
24742: CALL_OW 248
24746: ST_TO_ADDR
// side := GetSide ( tower ) ;
24747: LD_ADDR_VAR 0 16
24751: PUSH
24752: LD_VAR 0 1
24756: PPUSH
24757: CALL_OW 255
24761: ST_TO_ADDR
// x := GetX ( tower ) ;
24762: LD_ADDR_VAR 0 10
24766: PUSH
24767: LD_VAR 0 1
24771: PPUSH
24772: CALL_OW 250
24776: ST_TO_ADDR
// y := GetY ( tower ) ;
24777: LD_ADDR_VAR 0 11
24781: PUSH
24782: LD_VAR 0 1
24786: PPUSH
24787: CALL_OW 251
24791: ST_TO_ADDR
// if not x or not y then
24792: LD_VAR 0 10
24796: NOT
24797: PUSH
24798: LD_VAR 0 11
24802: NOT
24803: OR
24804: IFFALSE 24808
// exit ;
24806: GO 25841
// weapon := 0 ;
24808: LD_ADDR_VAR 0 18
24812: PUSH
24813: LD_INT 0
24815: ST_TO_ADDR
// fac_list := [ ] ;
24816: LD_ADDR_VAR 0 17
24820: PUSH
24821: EMPTY
24822: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24823: LD_ADDR_VAR 0 6
24827: PUSH
24828: LD_VAR 0 1
24832: PPUSH
24833: CALL_OW 274
24837: PPUSH
24838: LD_VAR 0 2
24842: PPUSH
24843: LD_INT 0
24845: PPUSH
24846: CALL 22411 0 3
24850: PPUSH
24851: LD_INT 30
24853: PUSH
24854: LD_INT 3
24856: PUSH
24857: EMPTY
24858: LIST
24859: LIST
24860: PPUSH
24861: CALL_OW 72
24865: ST_TO_ADDR
// if not factories then
24866: LD_VAR 0 6
24870: NOT
24871: IFFALSE 24875
// exit ;
24873: GO 25841
// for i in factories do
24875: LD_ADDR_VAR 0 8
24879: PUSH
24880: LD_VAR 0 6
24884: PUSH
24885: FOR_IN
24886: IFFALSE 24911
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24888: LD_ADDR_VAR 0 17
24892: PUSH
24893: LD_VAR 0 17
24897: PUSH
24898: LD_VAR 0 8
24902: PPUSH
24903: CALL_OW 478
24907: UNION
24908: ST_TO_ADDR
24909: GO 24885
24911: POP
24912: POP
// if not fac_list then
24913: LD_VAR 0 17
24917: NOT
24918: IFFALSE 24922
// exit ;
24920: GO 25841
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24922: LD_ADDR_VAR 0 5
24926: PUSH
24927: LD_INT 4
24929: PUSH
24930: LD_INT 5
24932: PUSH
24933: LD_INT 9
24935: PUSH
24936: LD_INT 10
24938: PUSH
24939: LD_INT 6
24941: PUSH
24942: LD_INT 7
24944: PUSH
24945: LD_INT 11
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 27
24959: PUSH
24960: LD_INT 28
24962: PUSH
24963: LD_INT 26
24965: PUSH
24966: LD_INT 30
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: LIST
24973: LIST
24974: PUSH
24975: LD_INT 43
24977: PUSH
24978: LD_INT 44
24980: PUSH
24981: LD_INT 46
24983: PUSH
24984: LD_INT 45
24986: PUSH
24987: LD_INT 47
24989: PUSH
24990: LD_INT 49
24992: PUSH
24993: EMPTY
24994: LIST
24995: LIST
24996: LIST
24997: LIST
24998: LIST
24999: LIST
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: LIST
25005: PUSH
25006: LD_VAR 0 12
25010: ARRAY
25011: ST_TO_ADDR
// list := list isect fac_list ;
25012: LD_ADDR_VAR 0 5
25016: PUSH
25017: LD_VAR 0 5
25021: PUSH
25022: LD_VAR 0 17
25026: ISECT
25027: ST_TO_ADDR
// if not list then
25028: LD_VAR 0 5
25032: NOT
25033: IFFALSE 25037
// exit ;
25035: GO 25841
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25037: LD_VAR 0 12
25041: PUSH
25042: LD_INT 3
25044: EQUAL
25045: PUSH
25046: LD_INT 49
25048: PUSH
25049: LD_VAR 0 5
25053: IN
25054: AND
25055: PUSH
25056: LD_INT 31
25058: PPUSH
25059: LD_VAR 0 16
25063: PPUSH
25064: CALL_OW 321
25068: PUSH
25069: LD_INT 2
25071: EQUAL
25072: AND
25073: IFFALSE 25133
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25075: LD_INT 22
25077: PUSH
25078: LD_VAR 0 16
25082: PUSH
25083: EMPTY
25084: LIST
25085: LIST
25086: PUSH
25087: LD_INT 35
25089: PUSH
25090: LD_INT 49
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PUSH
25097: LD_INT 91
25099: PUSH
25100: LD_VAR 0 1
25104: PUSH
25105: LD_INT 10
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: LIST
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: LIST
25117: PPUSH
25118: CALL_OW 69
25122: NOT
25123: IFFALSE 25133
// weapon := ru_time_lapser ;
25125: LD_ADDR_VAR 0 18
25129: PUSH
25130: LD_INT 49
25132: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25133: LD_VAR 0 12
25137: PUSH
25138: LD_INT 1
25140: PUSH
25141: LD_INT 2
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: IN
25148: PUSH
25149: LD_INT 11
25151: PUSH
25152: LD_VAR 0 5
25156: IN
25157: PUSH
25158: LD_INT 30
25160: PUSH
25161: LD_VAR 0 5
25165: IN
25166: OR
25167: AND
25168: PUSH
25169: LD_INT 6
25171: PPUSH
25172: LD_VAR 0 16
25176: PPUSH
25177: CALL_OW 321
25181: PUSH
25182: LD_INT 2
25184: EQUAL
25185: AND
25186: IFFALSE 25351
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25188: LD_INT 22
25190: PUSH
25191: LD_VAR 0 16
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 2
25202: PUSH
25203: LD_INT 35
25205: PUSH
25206: LD_INT 11
25208: PUSH
25209: EMPTY
25210: LIST
25211: LIST
25212: PUSH
25213: LD_INT 35
25215: PUSH
25216: LD_INT 30
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 91
25230: PUSH
25231: LD_VAR 0 1
25235: PUSH
25236: LD_INT 18
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: LIST
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: LIST
25248: PPUSH
25249: CALL_OW 69
25253: NOT
25254: PUSH
25255: LD_INT 22
25257: PUSH
25258: LD_VAR 0 16
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: LD_INT 2
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 32
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 33
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: EMPTY
25291: LIST
25292: LIST
25293: LIST
25294: PUSH
25295: LD_INT 91
25297: PUSH
25298: LD_VAR 0 1
25302: PUSH
25303: LD_INT 12
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: LIST
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: PUSH
25316: EMPTY
25317: LIST
25318: PPUSH
25319: CALL_OW 69
25323: PUSH
25324: LD_INT 2
25326: GREATER
25327: AND
25328: IFFALSE 25351
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25330: LD_ADDR_VAR 0 18
25334: PUSH
25335: LD_INT 11
25337: PUSH
25338: LD_INT 30
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_VAR 0 12
25349: ARRAY
25350: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25351: LD_VAR 0 18
25355: NOT
25356: PUSH
25357: LD_INT 40
25359: PPUSH
25360: LD_VAR 0 16
25364: PPUSH
25365: CALL_OW 321
25369: PUSH
25370: LD_INT 2
25372: EQUAL
25373: AND
25374: PUSH
25375: LD_INT 7
25377: PUSH
25378: LD_VAR 0 5
25382: IN
25383: PUSH
25384: LD_INT 28
25386: PUSH
25387: LD_VAR 0 5
25391: IN
25392: OR
25393: PUSH
25394: LD_INT 45
25396: PUSH
25397: LD_VAR 0 5
25401: IN
25402: OR
25403: AND
25404: IFFALSE 25658
// begin hex := GetHexInfo ( x , y ) ;
25406: LD_ADDR_VAR 0 4
25410: PUSH
25411: LD_VAR 0 10
25415: PPUSH
25416: LD_VAR 0 11
25420: PPUSH
25421: CALL_OW 546
25425: ST_TO_ADDR
// if hex [ 1 ] then
25426: LD_VAR 0 4
25430: PUSH
25431: LD_INT 1
25433: ARRAY
25434: IFFALSE 25438
// exit ;
25436: GO 25841
// height := hex [ 2 ] ;
25438: LD_ADDR_VAR 0 15
25442: PUSH
25443: LD_VAR 0 4
25447: PUSH
25448: LD_INT 2
25450: ARRAY
25451: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25452: LD_ADDR_VAR 0 14
25456: PUSH
25457: LD_INT 0
25459: PUSH
25460: LD_INT 2
25462: PUSH
25463: LD_INT 3
25465: PUSH
25466: LD_INT 5
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: ST_TO_ADDR
// for i in tmp do
25475: LD_ADDR_VAR 0 8
25479: PUSH
25480: LD_VAR 0 14
25484: PUSH
25485: FOR_IN
25486: IFFALSE 25656
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25488: LD_ADDR_VAR 0 9
25492: PUSH
25493: LD_VAR 0 10
25497: PPUSH
25498: LD_VAR 0 8
25502: PPUSH
25503: LD_INT 5
25505: PPUSH
25506: CALL_OW 272
25510: PUSH
25511: LD_VAR 0 11
25515: PPUSH
25516: LD_VAR 0 8
25520: PPUSH
25521: LD_INT 5
25523: PPUSH
25524: CALL_OW 273
25528: PUSH
25529: EMPTY
25530: LIST
25531: LIST
25532: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25533: LD_VAR 0 9
25537: PUSH
25538: LD_INT 1
25540: ARRAY
25541: PPUSH
25542: LD_VAR 0 9
25546: PUSH
25547: LD_INT 2
25549: ARRAY
25550: PPUSH
25551: CALL_OW 488
25555: IFFALSE 25654
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25557: LD_ADDR_VAR 0 4
25561: PUSH
25562: LD_VAR 0 9
25566: PUSH
25567: LD_INT 1
25569: ARRAY
25570: PPUSH
25571: LD_VAR 0 9
25575: PUSH
25576: LD_INT 2
25578: ARRAY
25579: PPUSH
25580: CALL_OW 546
25584: ST_TO_ADDR
// if hex [ 1 ] then
25585: LD_VAR 0 4
25589: PUSH
25590: LD_INT 1
25592: ARRAY
25593: IFFALSE 25597
// continue ;
25595: GO 25485
// h := hex [ 2 ] ;
25597: LD_ADDR_VAR 0 13
25601: PUSH
25602: LD_VAR 0 4
25606: PUSH
25607: LD_INT 2
25609: ARRAY
25610: ST_TO_ADDR
// if h + 7 < height then
25611: LD_VAR 0 13
25615: PUSH
25616: LD_INT 7
25618: PLUS
25619: PUSH
25620: LD_VAR 0 15
25624: LESS
25625: IFFALSE 25654
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25627: LD_ADDR_VAR 0 18
25631: PUSH
25632: LD_INT 7
25634: PUSH
25635: LD_INT 28
25637: PUSH
25638: LD_INT 45
25640: PUSH
25641: EMPTY
25642: LIST
25643: LIST
25644: LIST
25645: PUSH
25646: LD_VAR 0 12
25650: ARRAY
25651: ST_TO_ADDR
// break ;
25652: GO 25656
// end ; end ; end ;
25654: GO 25485
25656: POP
25657: POP
// end ; if not weapon then
25658: LD_VAR 0 18
25662: NOT
25663: IFFALSE 25723
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25665: LD_ADDR_VAR 0 5
25669: PUSH
25670: LD_VAR 0 5
25674: PUSH
25675: LD_INT 11
25677: PUSH
25678: LD_INT 30
25680: PUSH
25681: LD_INT 49
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: LIST
25688: DIFF
25689: ST_TO_ADDR
// if not list then
25690: LD_VAR 0 5
25694: NOT
25695: IFFALSE 25699
// exit ;
25697: GO 25841
// weapon := list [ rand ( 1 , list ) ] ;
25699: LD_ADDR_VAR 0 18
25703: PUSH
25704: LD_VAR 0 5
25708: PUSH
25709: LD_INT 1
25711: PPUSH
25712: LD_VAR 0 5
25716: PPUSH
25717: CALL_OW 12
25721: ARRAY
25722: ST_TO_ADDR
// end ; if weapon then
25723: LD_VAR 0 18
25727: IFFALSE 25841
// begin tmp := CostOfWeapon ( weapon ) ;
25729: LD_ADDR_VAR 0 14
25733: PUSH
25734: LD_VAR 0 18
25738: PPUSH
25739: CALL_OW 451
25743: ST_TO_ADDR
// j := GetBase ( tower ) ;
25744: LD_ADDR_VAR 0 9
25748: PUSH
25749: LD_VAR 0 1
25753: PPUSH
25754: CALL_OW 274
25758: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25759: LD_VAR 0 9
25763: PPUSH
25764: LD_INT 1
25766: PPUSH
25767: CALL_OW 275
25771: PUSH
25772: LD_VAR 0 14
25776: PUSH
25777: LD_INT 1
25779: ARRAY
25780: GREATEREQUAL
25781: PUSH
25782: LD_VAR 0 9
25786: PPUSH
25787: LD_INT 2
25789: PPUSH
25790: CALL_OW 275
25794: PUSH
25795: LD_VAR 0 14
25799: PUSH
25800: LD_INT 2
25802: ARRAY
25803: GREATEREQUAL
25804: AND
25805: PUSH
25806: LD_VAR 0 9
25810: PPUSH
25811: LD_INT 3
25813: PPUSH
25814: CALL_OW 275
25818: PUSH
25819: LD_VAR 0 14
25823: PUSH
25824: LD_INT 3
25826: ARRAY
25827: GREATEREQUAL
25828: AND
25829: IFFALSE 25841
// result := weapon ;
25831: LD_ADDR_VAR 0 3
25835: PUSH
25836: LD_VAR 0 18
25840: ST_TO_ADDR
// end ; end ;
25841: LD_VAR 0 3
25845: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25846: LD_INT 0
25848: PPUSH
25849: PPUSH
// result := true ;
25850: LD_ADDR_VAR 0 3
25854: PUSH
25855: LD_INT 1
25857: ST_TO_ADDR
// if array1 = array2 then
25858: LD_VAR 0 1
25862: PUSH
25863: LD_VAR 0 2
25867: EQUAL
25868: IFFALSE 25928
// begin for i = 1 to array1 do
25870: LD_ADDR_VAR 0 4
25874: PUSH
25875: DOUBLE
25876: LD_INT 1
25878: DEC
25879: ST_TO_ADDR
25880: LD_VAR 0 1
25884: PUSH
25885: FOR_TO
25886: IFFALSE 25924
// if array1 [ i ] <> array2 [ i ] then
25888: LD_VAR 0 1
25892: PUSH
25893: LD_VAR 0 4
25897: ARRAY
25898: PUSH
25899: LD_VAR 0 2
25903: PUSH
25904: LD_VAR 0 4
25908: ARRAY
25909: NONEQUAL
25910: IFFALSE 25922
// begin result := false ;
25912: LD_ADDR_VAR 0 3
25916: PUSH
25917: LD_INT 0
25919: ST_TO_ADDR
// break ;
25920: GO 25924
// end ;
25922: GO 25885
25924: POP
25925: POP
// end else
25926: GO 25936
// result := false ;
25928: LD_ADDR_VAR 0 3
25932: PUSH
25933: LD_INT 0
25935: ST_TO_ADDR
// end ;
25936: LD_VAR 0 3
25940: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25941: LD_INT 0
25943: PPUSH
25944: PPUSH
// if not array1 or not array2 then
25945: LD_VAR 0 1
25949: NOT
25950: PUSH
25951: LD_VAR 0 2
25955: NOT
25956: OR
25957: IFFALSE 25961
// exit ;
25959: GO 26025
// result := true ;
25961: LD_ADDR_VAR 0 3
25965: PUSH
25966: LD_INT 1
25968: ST_TO_ADDR
// for i = 1 to array1 do
25969: LD_ADDR_VAR 0 4
25973: PUSH
25974: DOUBLE
25975: LD_INT 1
25977: DEC
25978: ST_TO_ADDR
25979: LD_VAR 0 1
25983: PUSH
25984: FOR_TO
25985: IFFALSE 26023
// if array1 [ i ] <> array2 [ i ] then
25987: LD_VAR 0 1
25991: PUSH
25992: LD_VAR 0 4
25996: ARRAY
25997: PUSH
25998: LD_VAR 0 2
26002: PUSH
26003: LD_VAR 0 4
26007: ARRAY
26008: NONEQUAL
26009: IFFALSE 26021
// begin result := false ;
26011: LD_ADDR_VAR 0 3
26015: PUSH
26016: LD_INT 0
26018: ST_TO_ADDR
// break ;
26019: GO 26023
// end ;
26021: GO 25984
26023: POP
26024: POP
// end ;
26025: LD_VAR 0 3
26029: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26030: LD_INT 0
26032: PPUSH
26033: PPUSH
26034: PPUSH
// pom := GetBase ( fac ) ;
26035: LD_ADDR_VAR 0 5
26039: PUSH
26040: LD_VAR 0 1
26044: PPUSH
26045: CALL_OW 274
26049: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26050: LD_ADDR_VAR 0 4
26054: PUSH
26055: LD_VAR 0 2
26059: PUSH
26060: LD_INT 1
26062: ARRAY
26063: PPUSH
26064: LD_VAR 0 2
26068: PUSH
26069: LD_INT 2
26071: ARRAY
26072: PPUSH
26073: LD_VAR 0 2
26077: PUSH
26078: LD_INT 3
26080: ARRAY
26081: PPUSH
26082: LD_VAR 0 2
26086: PUSH
26087: LD_INT 4
26089: ARRAY
26090: PPUSH
26091: CALL_OW 449
26095: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26096: LD_ADDR_VAR 0 3
26100: PUSH
26101: LD_VAR 0 5
26105: PPUSH
26106: LD_INT 1
26108: PPUSH
26109: CALL_OW 275
26113: PUSH
26114: LD_VAR 0 4
26118: PUSH
26119: LD_INT 1
26121: ARRAY
26122: GREATEREQUAL
26123: PUSH
26124: LD_VAR 0 5
26128: PPUSH
26129: LD_INT 2
26131: PPUSH
26132: CALL_OW 275
26136: PUSH
26137: LD_VAR 0 4
26141: PUSH
26142: LD_INT 2
26144: ARRAY
26145: GREATEREQUAL
26146: AND
26147: PUSH
26148: LD_VAR 0 5
26152: PPUSH
26153: LD_INT 3
26155: PPUSH
26156: CALL_OW 275
26160: PUSH
26161: LD_VAR 0 4
26165: PUSH
26166: LD_INT 3
26168: ARRAY
26169: GREATEREQUAL
26170: AND
26171: ST_TO_ADDR
// end ;
26172: LD_VAR 0 3
26176: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26177: LD_INT 0
26179: PPUSH
26180: PPUSH
26181: PPUSH
26182: PPUSH
// pom := GetBase ( building ) ;
26183: LD_ADDR_VAR 0 3
26187: PUSH
26188: LD_VAR 0 1
26192: PPUSH
26193: CALL_OW 274
26197: ST_TO_ADDR
// if not pom then
26198: LD_VAR 0 3
26202: NOT
26203: IFFALSE 26207
// exit ;
26205: GO 26377
// btype := GetBType ( building ) ;
26207: LD_ADDR_VAR 0 5
26211: PUSH
26212: LD_VAR 0 1
26216: PPUSH
26217: CALL_OW 266
26221: ST_TO_ADDR
// if btype = b_armoury then
26222: LD_VAR 0 5
26226: PUSH
26227: LD_INT 4
26229: EQUAL
26230: IFFALSE 26240
// btype := b_barracks ;
26232: LD_ADDR_VAR 0 5
26236: PUSH
26237: LD_INT 5
26239: ST_TO_ADDR
// if btype = b_depot then
26240: LD_VAR 0 5
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: IFFALSE 26258
// btype := b_warehouse ;
26250: LD_ADDR_VAR 0 5
26254: PUSH
26255: LD_INT 1
26257: ST_TO_ADDR
// if btype = b_workshop then
26258: LD_VAR 0 5
26262: PUSH
26263: LD_INT 2
26265: EQUAL
26266: IFFALSE 26276
// btype := b_factory ;
26268: LD_ADDR_VAR 0 5
26272: PUSH
26273: LD_INT 3
26275: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26276: LD_ADDR_VAR 0 4
26280: PUSH
26281: LD_VAR 0 5
26285: PPUSH
26286: LD_VAR 0 1
26290: PPUSH
26291: CALL_OW 248
26295: PPUSH
26296: CALL_OW 450
26300: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26301: LD_ADDR_VAR 0 2
26305: PUSH
26306: LD_VAR 0 3
26310: PPUSH
26311: LD_INT 1
26313: PPUSH
26314: CALL_OW 275
26318: PUSH
26319: LD_VAR 0 4
26323: PUSH
26324: LD_INT 1
26326: ARRAY
26327: GREATEREQUAL
26328: PUSH
26329: LD_VAR 0 3
26333: PPUSH
26334: LD_INT 2
26336: PPUSH
26337: CALL_OW 275
26341: PUSH
26342: LD_VAR 0 4
26346: PUSH
26347: LD_INT 2
26349: ARRAY
26350: GREATEREQUAL
26351: AND
26352: PUSH
26353: LD_VAR 0 3
26357: PPUSH
26358: LD_INT 3
26360: PPUSH
26361: CALL_OW 275
26365: PUSH
26366: LD_VAR 0 4
26370: PUSH
26371: LD_INT 3
26373: ARRAY
26374: GREATEREQUAL
26375: AND
26376: ST_TO_ADDR
// end ;
26377: LD_VAR 0 2
26381: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26382: LD_INT 0
26384: PPUSH
26385: PPUSH
26386: PPUSH
// pom := GetBase ( building ) ;
26387: LD_ADDR_VAR 0 4
26391: PUSH
26392: LD_VAR 0 1
26396: PPUSH
26397: CALL_OW 274
26401: ST_TO_ADDR
// if not pom then
26402: LD_VAR 0 4
26406: NOT
26407: IFFALSE 26411
// exit ;
26409: GO 26512
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26411: LD_ADDR_VAR 0 5
26415: PUSH
26416: LD_VAR 0 2
26420: PPUSH
26421: LD_VAR 0 1
26425: PPUSH
26426: CALL_OW 248
26430: PPUSH
26431: CALL_OW 450
26435: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26436: LD_ADDR_VAR 0 3
26440: PUSH
26441: LD_VAR 0 4
26445: PPUSH
26446: LD_INT 1
26448: PPUSH
26449: CALL_OW 275
26453: PUSH
26454: LD_VAR 0 5
26458: PUSH
26459: LD_INT 1
26461: ARRAY
26462: GREATEREQUAL
26463: PUSH
26464: LD_VAR 0 4
26468: PPUSH
26469: LD_INT 2
26471: PPUSH
26472: CALL_OW 275
26476: PUSH
26477: LD_VAR 0 5
26481: PUSH
26482: LD_INT 2
26484: ARRAY
26485: GREATEREQUAL
26486: AND
26487: PUSH
26488: LD_VAR 0 4
26492: PPUSH
26493: LD_INT 3
26495: PPUSH
26496: CALL_OW 275
26500: PUSH
26501: LD_VAR 0 5
26505: PUSH
26506: LD_INT 3
26508: ARRAY
26509: GREATEREQUAL
26510: AND
26511: ST_TO_ADDR
// end ;
26512: LD_VAR 0 3
26516: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26517: LD_INT 0
26519: PPUSH
26520: PPUSH
26521: PPUSH
26522: PPUSH
26523: PPUSH
26524: PPUSH
26525: PPUSH
26526: PPUSH
26527: PPUSH
26528: PPUSH
26529: PPUSH
// result := false ;
26530: LD_ADDR_VAR 0 8
26534: PUSH
26535: LD_INT 0
26537: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26538: LD_VAR 0 5
26542: NOT
26543: PUSH
26544: LD_VAR 0 1
26548: NOT
26549: OR
26550: PUSH
26551: LD_VAR 0 2
26555: NOT
26556: OR
26557: PUSH
26558: LD_VAR 0 3
26562: NOT
26563: OR
26564: IFFALSE 26568
// exit ;
26566: GO 27382
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26568: LD_ADDR_VAR 0 14
26572: PUSH
26573: LD_VAR 0 1
26577: PPUSH
26578: LD_VAR 0 2
26582: PPUSH
26583: LD_VAR 0 3
26587: PPUSH
26588: LD_VAR 0 4
26592: PPUSH
26593: LD_VAR 0 5
26597: PUSH
26598: LD_INT 1
26600: ARRAY
26601: PPUSH
26602: CALL_OW 248
26606: PPUSH
26607: LD_INT 0
26609: PPUSH
26610: CALL 28219 0 6
26614: ST_TO_ADDR
// if not hexes then
26615: LD_VAR 0 14
26619: NOT
26620: IFFALSE 26624
// exit ;
26622: GO 27382
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26624: LD_ADDR_VAR 0 17
26628: PUSH
26629: LD_VAR 0 5
26633: PPUSH
26634: LD_INT 22
26636: PUSH
26637: LD_VAR 0 13
26641: PPUSH
26642: CALL_OW 255
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 2
26653: PUSH
26654: LD_INT 30
26656: PUSH
26657: LD_INT 0
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: LD_INT 30
26666: PUSH
26667: LD_INT 1
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: LIST
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: PPUSH
26683: CALL_OW 72
26687: ST_TO_ADDR
// for i = 1 to hexes do
26688: LD_ADDR_VAR 0 9
26692: PUSH
26693: DOUBLE
26694: LD_INT 1
26696: DEC
26697: ST_TO_ADDR
26698: LD_VAR 0 14
26702: PUSH
26703: FOR_TO
26704: IFFALSE 27380
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26706: LD_ADDR_VAR 0 13
26710: PUSH
26711: LD_VAR 0 14
26715: PUSH
26716: LD_VAR 0 9
26720: ARRAY
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PPUSH
26726: LD_VAR 0 14
26730: PUSH
26731: LD_VAR 0 9
26735: ARRAY
26736: PUSH
26737: LD_INT 2
26739: ARRAY
26740: PPUSH
26741: CALL_OW 428
26745: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26746: LD_VAR 0 14
26750: PUSH
26751: LD_VAR 0 9
26755: ARRAY
26756: PUSH
26757: LD_INT 1
26759: ARRAY
26760: PPUSH
26761: LD_VAR 0 14
26765: PUSH
26766: LD_VAR 0 9
26770: ARRAY
26771: PUSH
26772: LD_INT 2
26774: ARRAY
26775: PPUSH
26776: CALL_OW 351
26780: PUSH
26781: LD_VAR 0 14
26785: PUSH
26786: LD_VAR 0 9
26790: ARRAY
26791: PUSH
26792: LD_INT 1
26794: ARRAY
26795: PPUSH
26796: LD_VAR 0 14
26800: PUSH
26801: LD_VAR 0 9
26805: ARRAY
26806: PUSH
26807: LD_INT 2
26809: ARRAY
26810: PPUSH
26811: CALL_OW 488
26815: NOT
26816: OR
26817: PUSH
26818: LD_VAR 0 13
26822: PPUSH
26823: CALL_OW 247
26827: PUSH
26828: LD_INT 3
26830: EQUAL
26831: OR
26832: IFFALSE 26838
// exit ;
26834: POP
26835: POP
26836: GO 27382
// if not tmp then
26838: LD_VAR 0 13
26842: NOT
26843: IFFALSE 26847
// continue ;
26845: GO 26703
// result := true ;
26847: LD_ADDR_VAR 0 8
26851: PUSH
26852: LD_INT 1
26854: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26855: LD_VAR 0 6
26859: PUSH
26860: LD_VAR 0 13
26864: PPUSH
26865: CALL_OW 247
26869: PUSH
26870: LD_INT 2
26872: EQUAL
26873: AND
26874: PUSH
26875: LD_VAR 0 13
26879: PPUSH
26880: CALL_OW 263
26884: PUSH
26885: LD_INT 1
26887: EQUAL
26888: AND
26889: IFFALSE 27053
// begin if IsDrivenBy ( tmp ) then
26891: LD_VAR 0 13
26895: PPUSH
26896: CALL_OW 311
26900: IFFALSE 26904
// continue ;
26902: GO 26703
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26904: LD_VAR 0 6
26908: PPUSH
26909: LD_INT 3
26911: PUSH
26912: LD_INT 60
26914: PUSH
26915: EMPTY
26916: LIST
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: LD_INT 3
26924: PUSH
26925: LD_INT 55
26927: PUSH
26928: EMPTY
26929: LIST
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PPUSH
26939: CALL_OW 72
26943: IFFALSE 27051
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26945: LD_ADDR_VAR 0 18
26949: PUSH
26950: LD_VAR 0 6
26954: PPUSH
26955: LD_INT 3
26957: PUSH
26958: LD_INT 60
26960: PUSH
26961: EMPTY
26962: LIST
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 3
26970: PUSH
26971: LD_INT 55
26973: PUSH
26974: EMPTY
26975: LIST
26976: PUSH
26977: EMPTY
26978: LIST
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PPUSH
26985: CALL_OW 72
26989: PUSH
26990: LD_INT 1
26992: ARRAY
26993: ST_TO_ADDR
// if IsInUnit ( driver ) then
26994: LD_VAR 0 18
26998: PPUSH
26999: CALL_OW 310
27003: IFFALSE 27014
// ComExit ( driver ) ;
27005: LD_VAR 0 18
27009: PPUSH
27010: CALL 51403 0 1
// AddComEnterUnit ( driver , tmp ) ;
27014: LD_VAR 0 18
27018: PPUSH
27019: LD_VAR 0 13
27023: PPUSH
27024: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27028: LD_VAR 0 18
27032: PPUSH
27033: LD_VAR 0 7
27037: PPUSH
27038: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27042: LD_VAR 0 18
27046: PPUSH
27047: CALL_OW 181
// end ; continue ;
27051: GO 26703
// end ; if not cleaners or not tmp in cleaners then
27053: LD_VAR 0 6
27057: NOT
27058: PUSH
27059: LD_VAR 0 13
27063: PUSH
27064: LD_VAR 0 6
27068: IN
27069: NOT
27070: OR
27071: IFFALSE 27378
// begin if dep then
27073: LD_VAR 0 17
27077: IFFALSE 27213
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27079: LD_ADDR_VAR 0 16
27083: PUSH
27084: LD_VAR 0 17
27088: PUSH
27089: LD_INT 1
27091: ARRAY
27092: PPUSH
27093: CALL_OW 250
27097: PPUSH
27098: LD_VAR 0 17
27102: PUSH
27103: LD_INT 1
27105: ARRAY
27106: PPUSH
27107: CALL_OW 254
27111: PPUSH
27112: LD_INT 5
27114: PPUSH
27115: CALL_OW 272
27119: PUSH
27120: LD_VAR 0 17
27124: PUSH
27125: LD_INT 1
27127: ARRAY
27128: PPUSH
27129: CALL_OW 251
27133: PPUSH
27134: LD_VAR 0 17
27138: PUSH
27139: LD_INT 1
27141: ARRAY
27142: PPUSH
27143: CALL_OW 254
27147: PPUSH
27148: LD_INT 5
27150: PPUSH
27151: CALL_OW 273
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27160: LD_VAR 0 16
27164: PUSH
27165: LD_INT 1
27167: ARRAY
27168: PPUSH
27169: LD_VAR 0 16
27173: PUSH
27174: LD_INT 2
27176: ARRAY
27177: PPUSH
27178: CALL_OW 488
27182: IFFALSE 27213
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27184: LD_VAR 0 13
27188: PPUSH
27189: LD_VAR 0 16
27193: PUSH
27194: LD_INT 1
27196: ARRAY
27197: PPUSH
27198: LD_VAR 0 16
27202: PUSH
27203: LD_INT 2
27205: ARRAY
27206: PPUSH
27207: CALL_OW 111
// continue ;
27211: GO 26703
// end ; end ; r := GetDir ( tmp ) ;
27213: LD_ADDR_VAR 0 15
27217: PUSH
27218: LD_VAR 0 13
27222: PPUSH
27223: CALL_OW 254
27227: ST_TO_ADDR
// if r = 5 then
27228: LD_VAR 0 15
27232: PUSH
27233: LD_INT 5
27235: EQUAL
27236: IFFALSE 27246
// r := 0 ;
27238: LD_ADDR_VAR 0 15
27242: PUSH
27243: LD_INT 0
27245: ST_TO_ADDR
// for j = r to 5 do
27246: LD_ADDR_VAR 0 10
27250: PUSH
27251: DOUBLE
27252: LD_VAR 0 15
27256: DEC
27257: ST_TO_ADDR
27258: LD_INT 5
27260: PUSH
27261: FOR_TO
27262: IFFALSE 27376
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27264: LD_ADDR_VAR 0 11
27268: PUSH
27269: LD_VAR 0 13
27273: PPUSH
27274: CALL_OW 250
27278: PPUSH
27279: LD_VAR 0 10
27283: PPUSH
27284: LD_INT 2
27286: PPUSH
27287: CALL_OW 272
27291: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27292: LD_ADDR_VAR 0 12
27296: PUSH
27297: LD_VAR 0 13
27301: PPUSH
27302: CALL_OW 251
27306: PPUSH
27307: LD_VAR 0 10
27311: PPUSH
27312: LD_INT 2
27314: PPUSH
27315: CALL_OW 273
27319: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27320: LD_VAR 0 11
27324: PPUSH
27325: LD_VAR 0 12
27329: PPUSH
27330: CALL_OW 488
27334: PUSH
27335: LD_VAR 0 11
27339: PPUSH
27340: LD_VAR 0 12
27344: PPUSH
27345: CALL_OW 428
27349: NOT
27350: AND
27351: IFFALSE 27374
// begin ComMoveXY ( tmp , _x , _y ) ;
27353: LD_VAR 0 13
27357: PPUSH
27358: LD_VAR 0 11
27362: PPUSH
27363: LD_VAR 0 12
27367: PPUSH
27368: CALL_OW 111
// break ;
27372: GO 27376
// end ; end ;
27374: GO 27261
27376: POP
27377: POP
// end ; end ;
27378: GO 26703
27380: POP
27381: POP
// end ;
27382: LD_VAR 0 8
27386: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27387: LD_INT 0
27389: PPUSH
27390: PPUSH
27391: PPUSH
27392: PPUSH
27393: PPUSH
27394: PPUSH
27395: PPUSH
27396: PPUSH
27397: PPUSH
27398: PPUSH
// result := false ;
27399: LD_ADDR_VAR 0 6
27403: PUSH
27404: LD_INT 0
27406: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27407: LD_VAR 0 1
27411: NOT
27412: PUSH
27413: LD_VAR 0 1
27417: PPUSH
27418: CALL_OW 266
27422: PUSH
27423: LD_INT 0
27425: PUSH
27426: LD_INT 1
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: IN
27433: NOT
27434: OR
27435: PUSH
27436: LD_VAR 0 2
27440: NOT
27441: OR
27442: PUSH
27443: LD_VAR 0 5
27447: PUSH
27448: LD_INT 0
27450: PUSH
27451: LD_INT 1
27453: PUSH
27454: LD_INT 2
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 4
27462: PUSH
27463: LD_INT 5
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: IN
27474: NOT
27475: OR
27476: PUSH
27477: LD_VAR 0 3
27481: PPUSH
27482: LD_VAR 0 4
27486: PPUSH
27487: CALL_OW 488
27491: NOT
27492: OR
27493: IFFALSE 27497
// exit ;
27495: GO 28214
// pom := GetBase ( depot ) ;
27497: LD_ADDR_VAR 0 10
27501: PUSH
27502: LD_VAR 0 1
27506: PPUSH
27507: CALL_OW 274
27511: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27512: LD_ADDR_VAR 0 11
27516: PUSH
27517: LD_VAR 0 2
27521: PPUSH
27522: LD_VAR 0 1
27526: PPUSH
27527: CALL_OW 248
27531: PPUSH
27532: CALL_OW 450
27536: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27537: LD_VAR 0 10
27541: PPUSH
27542: LD_INT 1
27544: PPUSH
27545: CALL_OW 275
27549: PUSH
27550: LD_VAR 0 11
27554: PUSH
27555: LD_INT 1
27557: ARRAY
27558: GREATEREQUAL
27559: PUSH
27560: LD_VAR 0 10
27564: PPUSH
27565: LD_INT 2
27567: PPUSH
27568: CALL_OW 275
27572: PUSH
27573: LD_VAR 0 11
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: GREATEREQUAL
27582: AND
27583: PUSH
27584: LD_VAR 0 10
27588: PPUSH
27589: LD_INT 3
27591: PPUSH
27592: CALL_OW 275
27596: PUSH
27597: LD_VAR 0 11
27601: PUSH
27602: LD_INT 3
27604: ARRAY
27605: GREATEREQUAL
27606: AND
27607: NOT
27608: IFFALSE 27612
// exit ;
27610: GO 28214
// if GetBType ( depot ) = b_depot then
27612: LD_VAR 0 1
27616: PPUSH
27617: CALL_OW 266
27621: PUSH
27622: LD_INT 0
27624: EQUAL
27625: IFFALSE 27637
// dist := 28 else
27627: LD_ADDR_VAR 0 14
27631: PUSH
27632: LD_INT 28
27634: ST_TO_ADDR
27635: GO 27645
// dist := 36 ;
27637: LD_ADDR_VAR 0 14
27641: PUSH
27642: LD_INT 36
27644: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27645: LD_VAR 0 1
27649: PPUSH
27650: LD_VAR 0 3
27654: PPUSH
27655: LD_VAR 0 4
27659: PPUSH
27660: CALL_OW 297
27664: PUSH
27665: LD_VAR 0 14
27669: GREATER
27670: IFFALSE 27674
// exit ;
27672: GO 28214
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27674: LD_ADDR_VAR 0 12
27678: PUSH
27679: LD_VAR 0 2
27683: PPUSH
27684: LD_VAR 0 3
27688: PPUSH
27689: LD_VAR 0 4
27693: PPUSH
27694: LD_VAR 0 5
27698: PPUSH
27699: LD_VAR 0 1
27703: PPUSH
27704: CALL_OW 248
27708: PPUSH
27709: LD_INT 0
27711: PPUSH
27712: CALL 28219 0 6
27716: ST_TO_ADDR
// if not hexes then
27717: LD_VAR 0 12
27721: NOT
27722: IFFALSE 27726
// exit ;
27724: GO 28214
// hex := GetHexInfo ( x , y ) ;
27726: LD_ADDR_VAR 0 15
27730: PUSH
27731: LD_VAR 0 3
27735: PPUSH
27736: LD_VAR 0 4
27740: PPUSH
27741: CALL_OW 546
27745: ST_TO_ADDR
// if hex [ 1 ] then
27746: LD_VAR 0 15
27750: PUSH
27751: LD_INT 1
27753: ARRAY
27754: IFFALSE 27758
// exit ;
27756: GO 28214
// height := hex [ 2 ] ;
27758: LD_ADDR_VAR 0 13
27762: PUSH
27763: LD_VAR 0 15
27767: PUSH
27768: LD_INT 2
27770: ARRAY
27771: ST_TO_ADDR
// for i = 1 to hexes do
27772: LD_ADDR_VAR 0 7
27776: PUSH
27777: DOUBLE
27778: LD_INT 1
27780: DEC
27781: ST_TO_ADDR
27782: LD_VAR 0 12
27786: PUSH
27787: FOR_TO
27788: IFFALSE 28118
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27790: LD_VAR 0 12
27794: PUSH
27795: LD_VAR 0 7
27799: ARRAY
27800: PUSH
27801: LD_INT 1
27803: ARRAY
27804: PPUSH
27805: LD_VAR 0 12
27809: PUSH
27810: LD_VAR 0 7
27814: ARRAY
27815: PUSH
27816: LD_INT 2
27818: ARRAY
27819: PPUSH
27820: CALL_OW 488
27824: NOT
27825: PUSH
27826: LD_VAR 0 12
27830: PUSH
27831: LD_VAR 0 7
27835: ARRAY
27836: PUSH
27837: LD_INT 1
27839: ARRAY
27840: PPUSH
27841: LD_VAR 0 12
27845: PUSH
27846: LD_VAR 0 7
27850: ARRAY
27851: PUSH
27852: LD_INT 2
27854: ARRAY
27855: PPUSH
27856: CALL_OW 428
27860: PUSH
27861: LD_INT 0
27863: GREATER
27864: OR
27865: PUSH
27866: LD_VAR 0 12
27870: PUSH
27871: LD_VAR 0 7
27875: ARRAY
27876: PUSH
27877: LD_INT 1
27879: ARRAY
27880: PPUSH
27881: LD_VAR 0 12
27885: PUSH
27886: LD_VAR 0 7
27890: ARRAY
27891: PUSH
27892: LD_INT 2
27894: ARRAY
27895: PPUSH
27896: CALL_OW 351
27900: OR
27901: IFFALSE 27907
// exit ;
27903: POP
27904: POP
27905: GO 28214
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27907: LD_ADDR_VAR 0 8
27911: PUSH
27912: LD_VAR 0 12
27916: PUSH
27917: LD_VAR 0 7
27921: ARRAY
27922: PUSH
27923: LD_INT 1
27925: ARRAY
27926: PPUSH
27927: LD_VAR 0 12
27931: PUSH
27932: LD_VAR 0 7
27936: ARRAY
27937: PUSH
27938: LD_INT 2
27940: ARRAY
27941: PPUSH
27942: CALL_OW 546
27946: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27947: LD_VAR 0 8
27951: PUSH
27952: LD_INT 1
27954: ARRAY
27955: PUSH
27956: LD_VAR 0 8
27960: PUSH
27961: LD_INT 2
27963: ARRAY
27964: PUSH
27965: LD_VAR 0 13
27969: PUSH
27970: LD_INT 2
27972: PLUS
27973: GREATER
27974: OR
27975: PUSH
27976: LD_VAR 0 8
27980: PUSH
27981: LD_INT 2
27983: ARRAY
27984: PUSH
27985: LD_VAR 0 13
27989: PUSH
27990: LD_INT 2
27992: MINUS
27993: LESS
27994: OR
27995: PUSH
27996: LD_VAR 0 8
28000: PUSH
28001: LD_INT 3
28003: ARRAY
28004: PUSH
28005: LD_INT 0
28007: PUSH
28008: LD_INT 8
28010: PUSH
28011: LD_INT 9
28013: PUSH
28014: LD_INT 10
28016: PUSH
28017: LD_INT 11
28019: PUSH
28020: LD_INT 12
28022: PUSH
28023: LD_INT 13
28025: PUSH
28026: LD_INT 16
28028: PUSH
28029: LD_INT 17
28031: PUSH
28032: LD_INT 18
28034: PUSH
28035: LD_INT 19
28037: PUSH
28038: LD_INT 20
28040: PUSH
28041: LD_INT 21
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: IN
28059: NOT
28060: OR
28061: PUSH
28062: LD_VAR 0 8
28066: PUSH
28067: LD_INT 5
28069: ARRAY
28070: NOT
28071: OR
28072: PUSH
28073: LD_VAR 0 8
28077: PUSH
28078: LD_INT 6
28080: ARRAY
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: LD_INT 2
28087: PUSH
28088: LD_INT 7
28090: PUSH
28091: LD_INT 9
28093: PUSH
28094: LD_INT 10
28096: PUSH
28097: LD_INT 11
28099: PUSH
28100: EMPTY
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: IN
28108: NOT
28109: OR
28110: IFFALSE 28116
// exit ;
28112: POP
28113: POP
28114: GO 28214
// end ;
28116: GO 27787
28118: POP
28119: POP
// side := GetSide ( depot ) ;
28120: LD_ADDR_VAR 0 9
28124: PUSH
28125: LD_VAR 0 1
28129: PPUSH
28130: CALL_OW 255
28134: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28135: LD_VAR 0 9
28139: PPUSH
28140: LD_VAR 0 3
28144: PPUSH
28145: LD_VAR 0 4
28149: PPUSH
28150: LD_INT 20
28152: PPUSH
28153: CALL 20565 0 4
28157: PUSH
28158: LD_INT 4
28160: ARRAY
28161: IFFALSE 28165
// exit ;
28163: GO 28214
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28165: LD_VAR 0 2
28169: PUSH
28170: LD_INT 29
28172: PUSH
28173: LD_INT 30
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: IN
28180: PUSH
28181: LD_VAR 0 3
28185: PPUSH
28186: LD_VAR 0 4
28190: PPUSH
28191: LD_VAR 0 9
28195: PPUSH
28196: CALL_OW 440
28200: NOT
28201: AND
28202: IFFALSE 28206
// exit ;
28204: GO 28214
// result := true ;
28206: LD_ADDR_VAR 0 6
28210: PUSH
28211: LD_INT 1
28213: ST_TO_ADDR
// end ;
28214: LD_VAR 0 6
28218: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28219: LD_INT 0
28221: PPUSH
28222: PPUSH
28223: PPUSH
28224: PPUSH
28225: PPUSH
28226: PPUSH
28227: PPUSH
28228: PPUSH
28229: PPUSH
28230: PPUSH
28231: PPUSH
28232: PPUSH
28233: PPUSH
28234: PPUSH
28235: PPUSH
28236: PPUSH
28237: PPUSH
28238: PPUSH
28239: PPUSH
28240: PPUSH
28241: PPUSH
28242: PPUSH
28243: PPUSH
28244: PPUSH
28245: PPUSH
28246: PPUSH
28247: PPUSH
28248: PPUSH
28249: PPUSH
28250: PPUSH
28251: PPUSH
28252: PPUSH
28253: PPUSH
28254: PPUSH
28255: PPUSH
28256: PPUSH
28257: PPUSH
28258: PPUSH
28259: PPUSH
28260: PPUSH
28261: PPUSH
28262: PPUSH
28263: PPUSH
28264: PPUSH
28265: PPUSH
28266: PPUSH
28267: PPUSH
28268: PPUSH
28269: PPUSH
28270: PPUSH
28271: PPUSH
28272: PPUSH
28273: PPUSH
28274: PPUSH
28275: PPUSH
28276: PPUSH
28277: PPUSH
28278: PPUSH
// result = [ ] ;
28279: LD_ADDR_VAR 0 7
28283: PUSH
28284: EMPTY
28285: ST_TO_ADDR
// temp_list = [ ] ;
28286: LD_ADDR_VAR 0 9
28290: PUSH
28291: EMPTY
28292: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28293: LD_VAR 0 4
28297: PUSH
28298: LD_INT 0
28300: PUSH
28301: LD_INT 1
28303: PUSH
28304: LD_INT 2
28306: PUSH
28307: LD_INT 3
28309: PUSH
28310: LD_INT 4
28312: PUSH
28313: LD_INT 5
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: LIST
28320: LIST
28321: LIST
28322: LIST
28323: IN
28324: NOT
28325: PUSH
28326: LD_VAR 0 1
28330: PUSH
28331: LD_INT 0
28333: PUSH
28334: LD_INT 1
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: IN
28341: PUSH
28342: LD_VAR 0 5
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 3
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: LIST
28360: IN
28361: NOT
28362: AND
28363: OR
28364: IFFALSE 28368
// exit ;
28366: GO 46759
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28368: LD_VAR 0 1
28372: PUSH
28373: LD_INT 6
28375: PUSH
28376: LD_INT 7
28378: PUSH
28379: LD_INT 8
28381: PUSH
28382: LD_INT 13
28384: PUSH
28385: LD_INT 12
28387: PUSH
28388: LD_INT 15
28390: PUSH
28391: LD_INT 11
28393: PUSH
28394: LD_INT 14
28396: PUSH
28397: LD_INT 10
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: IN
28411: IFFALSE 28421
// btype = b_lab ;
28413: LD_ADDR_VAR 0 1
28417: PUSH
28418: LD_INT 6
28420: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28421: LD_VAR 0 6
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: PUSH
28432: LD_INT 2
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: LIST
28439: IN
28440: NOT
28441: PUSH
28442: LD_VAR 0 1
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: LD_INT 2
28455: PUSH
28456: LD_INT 3
28458: PUSH
28459: LD_INT 6
28461: PUSH
28462: LD_INT 36
28464: PUSH
28465: LD_INT 4
28467: PUSH
28468: LD_INT 5
28470: PUSH
28471: LD_INT 31
28473: PUSH
28474: LD_INT 32
28476: PUSH
28477: LD_INT 33
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: IN
28493: NOT
28494: PUSH
28495: LD_VAR 0 6
28499: PUSH
28500: LD_INT 1
28502: EQUAL
28503: AND
28504: OR
28505: PUSH
28506: LD_VAR 0 1
28510: PUSH
28511: LD_INT 2
28513: PUSH
28514: LD_INT 3
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: IN
28521: NOT
28522: PUSH
28523: LD_VAR 0 6
28527: PUSH
28528: LD_INT 2
28530: EQUAL
28531: AND
28532: OR
28533: IFFALSE 28543
// mode = 0 ;
28535: LD_ADDR_VAR 0 6
28539: PUSH
28540: LD_INT 0
28542: ST_TO_ADDR
// case mode of 0 :
28543: LD_VAR 0 6
28547: PUSH
28548: LD_INT 0
28550: DOUBLE
28551: EQUAL
28552: IFTRUE 28556
28554: GO 40009
28556: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28557: LD_ADDR_VAR 0 11
28561: PUSH
28562: LD_INT 0
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 0
28574: PUSH
28575: LD_INT 1
28577: NEG
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PUSH
28583: LD_INT 1
28585: PUSH
28586: LD_INT 0
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: LD_INT 1
28595: PUSH
28596: LD_INT 1
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 0
28605: PUSH
28606: LD_INT 1
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: NEG
28616: PUSH
28617: LD_INT 0
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 1
28626: NEG
28627: PUSH
28628: LD_INT 1
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 1
28638: NEG
28639: PUSH
28640: LD_INT 2
28642: NEG
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 0
28650: PUSH
28651: LD_INT 2
28653: NEG
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: LD_INT 1
28664: NEG
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: LD_INT 2
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 2
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 1
28692: NEG
28693: PUSH
28694: LD_INT 1
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 3
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 0
28713: PUSH
28714: LD_INT 3
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 1
28723: NEG
28724: PUSH
28725: LD_INT 2
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: LIST
28736: LIST
28737: LIST
28738: LIST
28739: LIST
28740: LIST
28741: LIST
28742: LIST
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28750: LD_ADDR_VAR 0 12
28754: PUSH
28755: LD_INT 0
28757: PUSH
28758: LD_INT 0
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 1
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 1
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 0
28798: PUSH
28799: LD_INT 1
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: NEG
28809: PUSH
28810: LD_INT 0
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 1
28819: NEG
28820: PUSH
28821: LD_INT 1
28823: NEG
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: LD_INT 1
28834: NEG
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: LD_INT 0
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: LD_INT 2
28852: PUSH
28853: LD_INT 1
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 1
28862: NEG
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 2
28873: NEG
28874: PUSH
28875: LD_INT 0
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 2
28884: NEG
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 2
28896: NEG
28897: PUSH
28898: LD_INT 1
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: LD_INT 3
28907: NEG
28908: PUSH
28909: LD_INT 0
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 3
28918: NEG
28919: PUSH
28920: LD_INT 1
28922: NEG
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28946: LD_ADDR_VAR 0 13
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 0
28963: PUSH
28964: LD_INT 1
28966: NEG
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 1
28974: PUSH
28975: LD_INT 0
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 1
28984: PUSH
28985: LD_INT 1
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 0
28994: PUSH
28995: LD_INT 1
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 1
29004: NEG
29005: PUSH
29006: LD_INT 0
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 1
29015: NEG
29016: PUSH
29017: LD_INT 1
29019: NEG
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: LD_INT 1
29027: NEG
29028: PUSH
29029: LD_INT 2
29031: NEG
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 2
29039: PUSH
29040: LD_INT 1
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 2
29049: PUSH
29050: LD_INT 2
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: LD_INT 2
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: LD_INT 2
29069: NEG
29070: PUSH
29071: LD_INT 1
29073: NEG
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 2
29081: NEG
29082: PUSH
29083: LD_INT 2
29085: NEG
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 2
29093: NEG
29094: PUSH
29095: LD_INT 3
29097: NEG
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PUSH
29103: LD_INT 3
29105: NEG
29106: PUSH
29107: LD_INT 2
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 3
29117: NEG
29118: PUSH
29119: LD_INT 3
29121: NEG
29122: PUSH
29123: EMPTY
29124: LIST
29125: LIST
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: LIST
29141: LIST
29142: LIST
29143: LIST
29144: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29145: LD_ADDR_VAR 0 14
29149: PUSH
29150: LD_INT 0
29152: PUSH
29153: LD_INT 0
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 0
29162: PUSH
29163: LD_INT 1
29165: NEG
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 1
29173: PUSH
29174: LD_INT 0
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 1
29183: PUSH
29184: LD_INT 1
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: LD_INT 1
29196: PUSH
29197: EMPTY
29198: LIST
29199: LIST
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: LD_INT 0
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: LD_INT 1
29214: NEG
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 1
29226: NEG
29227: PUSH
29228: LD_INT 2
29230: NEG
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: PUSH
29236: LD_INT 0
29238: PUSH
29239: LD_INT 2
29241: NEG
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 1
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: LD_INT 2
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 0
29270: PUSH
29271: LD_INT 2
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: NEG
29281: PUSH
29282: LD_INT 1
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: LD_INT 1
29291: NEG
29292: PUSH
29293: LD_INT 3
29295: NEG
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 3
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: LIST
29336: LIST
29337: LIST
29338: LIST
29339: LIST
29340: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29341: LD_ADDR_VAR 0 15
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: LD_INT 0
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 0
29358: PUSH
29359: LD_INT 1
29361: NEG
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 1
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 1
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 0
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 1
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 2
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 2
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: NEG
29454: PUSH
29455: LD_INT 1
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 2
29464: NEG
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 2
29475: NEG
29476: PUSH
29477: LD_INT 1
29479: NEG
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 2
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 3
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: EMPTY
29503: LIST
29504: LIST
29505: PUSH
29506: LD_INT 3
29508: PUSH
29509: LD_INT 1
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: LIST
29520: LIST
29521: LIST
29522: LIST
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: LIST
29530: LIST
29531: LIST
29532: LIST
29533: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29534: LD_ADDR_VAR 0 16
29538: PUSH
29539: LD_INT 0
29541: PUSH
29542: LD_INT 0
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: LD_INT 1
29554: NEG
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: LD_INT 0
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 0
29582: PUSH
29583: LD_INT 1
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: LD_INT 0
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 1
29603: NEG
29604: PUSH
29605: LD_INT 1
29607: NEG
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 1
29615: NEG
29616: PUSH
29617: LD_INT 2
29619: NEG
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 2
29627: PUSH
29628: LD_INT 1
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 2
29637: PUSH
29638: LD_INT 2
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: LD_INT 2
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 2
29657: NEG
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 2
29669: NEG
29670: PUSH
29671: LD_INT 2
29673: NEG
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 3
29681: PUSH
29682: LD_INT 2
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 3
29691: PUSH
29692: LD_INT 3
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 2
29701: PUSH
29702: LD_INT 3
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: LIST
29717: LIST
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29727: LD_ADDR_VAR 0 17
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: LD_INT 0
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 0
29744: PUSH
29745: LD_INT 1
29747: NEG
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 1
29785: NEG
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 1
29796: NEG
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: NEG
29809: PUSH
29810: LD_INT 2
29812: NEG
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 2
29823: NEG
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: LD_INT 1
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 2
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 2
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: PUSH
29873: LD_INT 2
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: LD_INT 2
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 1
29892: NEG
29893: PUSH
29894: LD_INT 1
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 2
29903: NEG
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 2
29914: NEG
29915: PUSH
29916: LD_INT 1
29918: NEG
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 2
29926: NEG
29927: PUSH
29928: LD_INT 2
29930: NEG
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29957: LD_ADDR_VAR 0 18
29961: PUSH
29962: LD_INT 0
29964: PUSH
29965: LD_INT 0
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 0
29974: PUSH
29975: LD_INT 1
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 1
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: PUSH
29993: LD_INT 1
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: LD_INT 1
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 1
30015: NEG
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: LD_INT 1
30026: NEG
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 1
30038: NEG
30039: PUSH
30040: LD_INT 2
30042: NEG
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 0
30050: PUSH
30051: LD_INT 2
30053: NEG
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: LD_INT 1
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 2
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: EMPTY
30077: LIST
30078: LIST
30079: PUSH
30080: LD_INT 2
30082: PUSH
30083: LD_INT 1
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 2
30092: PUSH
30093: LD_INT 2
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 1
30102: PUSH
30103: LD_INT 2
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 0
30112: PUSH
30113: LD_INT 2
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: NEG
30123: PUSH
30124: LD_INT 1
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PUSH
30131: LD_INT 2
30133: NEG
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 2
30144: NEG
30145: PUSH
30146: LD_INT 1
30148: NEG
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: LD_INT 2
30156: NEG
30157: PUSH
30158: LD_INT 2
30160: NEG
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: LIST
30182: LIST
30183: LIST
30184: LIST
30185: LIST
30186: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30187: LD_ADDR_VAR 0 19
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: LD_INT 0
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 0
30204: PUSH
30205: LD_INT 1
30207: NEG
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PUSH
30213: LD_INT 1
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 1
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: LD_INT 1
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: LD_INT 0
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 1
30256: NEG
30257: PUSH
30258: LD_INT 1
30260: NEG
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: LD_INT 2
30272: NEG
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: LD_INT 2
30283: NEG
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 1
30291: PUSH
30292: LD_INT 1
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: LD_INT 0
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 2
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 1
30332: PUSH
30333: LD_INT 2
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 0
30342: PUSH
30343: LD_INT 2
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 1
30352: NEG
30353: PUSH
30354: LD_INT 1
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 2
30363: NEG
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 2
30374: NEG
30375: PUSH
30376: LD_INT 1
30378: NEG
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 2
30386: NEG
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30417: LD_ADDR_VAR 0 20
30421: PUSH
30422: LD_INT 0
30424: PUSH
30425: LD_INT 0
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 0
30434: PUSH
30435: LD_INT 1
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 1
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: PUSH
30456: LD_INT 1
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 0
30465: PUSH
30466: LD_INT 1
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: LD_INT 1
30490: NEG
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 1
30498: NEG
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 1
30521: PUSH
30522: LD_INT 1
30524: NEG
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 2
30532: PUSH
30533: LD_INT 0
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 2
30542: PUSH
30543: LD_INT 1
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 2
30552: PUSH
30553: LD_INT 2
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 1
30562: PUSH
30563: LD_INT 2
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 0
30572: PUSH
30573: LD_INT 2
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 1
30582: NEG
30583: PUSH
30584: LD_INT 1
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 2
30593: NEG
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 2
30604: NEG
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 2
30616: NEG
30617: PUSH
30618: LD_INT 2
30620: NEG
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30647: LD_ADDR_VAR 0 21
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: LD_INT 0
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: LD_INT 1
30667: NEG
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 1
30675: PUSH
30676: LD_INT 0
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: LD_INT 1
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 1
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: NEG
30717: PUSH
30718: LD_INT 1
30720: NEG
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 1
30728: NEG
30729: PUSH
30730: LD_INT 2
30732: NEG
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 2
30743: NEG
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: LD_INT 1
30754: NEG
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 2
30762: PUSH
30763: LD_INT 0
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 2
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 2
30782: PUSH
30783: LD_INT 2
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 1
30792: PUSH
30793: LD_INT 2
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 0
30802: PUSH
30803: LD_INT 2
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 1
30812: NEG
30813: PUSH
30814: LD_INT 1
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 2
30823: NEG
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: LD_INT 2
30834: NEG
30835: PUSH
30836: LD_INT 1
30838: NEG
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 2
30846: NEG
30847: PUSH
30848: LD_INT 2
30850: NEG
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30877: LD_ADDR_VAR 0 22
30881: PUSH
30882: LD_INT 0
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 0
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: LD_INT 1
30950: NEG
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: LD_INT 1
30958: NEG
30959: PUSH
30960: LD_INT 2
30962: NEG
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: LD_INT 2
30973: NEG
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: LD_INT 1
30984: NEG
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 0
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 2
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 2
31012: PUSH
31013: LD_INT 2
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 1
31022: PUSH
31023: LD_INT 2
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 0
31032: PUSH
31033: LD_INT 2
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 1
31042: NEG
31043: PUSH
31044: LD_INT 1
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 2
31053: NEG
31054: PUSH
31055: LD_INT 0
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: NEG
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: LD_INT 2
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31107: LD_ADDR_VAR 0 23
31111: PUSH
31112: LD_INT 0
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 0
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 1
31135: PUSH
31136: LD_INT 0
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 1
31145: PUSH
31146: LD_INT 1
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: LD_INT 1
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: LD_INT 2
31192: NEG
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 0
31200: PUSH
31201: LD_INT 2
31203: NEG
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 2
31222: PUSH
31223: LD_INT 0
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 2
31232: PUSH
31233: LD_INT 1
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 2
31242: PUSH
31243: LD_INT 2
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: LD_INT 2
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 0
31262: PUSH
31263: LD_INT 2
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: LD_INT 1
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: LD_INT 0
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: NEG
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: LD_INT 2
31306: NEG
31307: PUSH
31308: LD_INT 2
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: NEG
31319: PUSH
31320: LD_INT 3
31322: NEG
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: LD_INT 3
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: PUSH
31343: LD_INT 2
31345: NEG
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: PUSH
31354: LD_INT 1
31356: NEG
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31387: LD_ADDR_VAR 0 24
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 1
31415: PUSH
31416: LD_INT 0
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 1
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: LD_INT 0
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 2
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 2
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 2
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: LD_INT 1
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: NEG
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 2
31609: PUSH
31610: LD_INT 1
31612: NEG
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 3
31620: PUSH
31621: LD_INT 1
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 3
31630: PUSH
31631: LD_INT 2
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31663: LD_ADDR_VAR 0 25
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: LD_INT 0
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 0
31680: PUSH
31681: LD_INT 1
31683: NEG
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 1
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 0
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 1
31721: NEG
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 1
31732: NEG
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 1
31744: NEG
31745: PUSH
31746: LD_INT 2
31748: NEG
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 0
31756: PUSH
31757: LD_INT 2
31759: NEG
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: LD_INT 1
31770: NEG
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 2
31778: PUSH
31779: LD_INT 0
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 2
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 2
31798: PUSH
31799: LD_INT 2
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: LD_INT 2
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 0
31818: PUSH
31819: LD_INT 2
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: LD_INT 1
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 2
31839: NEG
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 2
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 3
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 3
31884: PUSH
31885: LD_INT 2
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: LD_INT 3
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 3
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31937: LD_ADDR_VAR 0 26
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: LD_INT 0
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 0
31954: PUSH
31955: LD_INT 1
31957: NEG
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 1
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 0
31985: PUSH
31986: LD_INT 1
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 1
31995: NEG
31996: PUSH
31997: LD_INT 0
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 1
32006: NEG
32007: PUSH
32008: LD_INT 1
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: LD_INT 1
32018: NEG
32019: PUSH
32020: LD_INT 2
32022: NEG
32023: PUSH
32024: EMPTY
32025: LIST
32026: LIST
32027: PUSH
32028: LD_INT 0
32030: PUSH
32031: LD_INT 2
32033: NEG
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: LD_INT 1
32041: PUSH
32042: LD_INT 1
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 2
32052: PUSH
32053: LD_INT 0
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 2
32062: PUSH
32063: LD_INT 1
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: LD_INT 2
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: LD_INT 2
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 0
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PUSH
32100: LD_INT 1
32102: NEG
32103: PUSH
32104: LD_INT 1
32106: PUSH
32107: EMPTY
32108: LIST
32109: LIST
32110: PUSH
32111: LD_INT 2
32113: NEG
32114: PUSH
32115: LD_INT 0
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 2
32124: NEG
32125: PUSH
32126: LD_INT 1
32128: NEG
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 2
32136: NEG
32137: PUSH
32138: LD_INT 2
32140: NEG
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 2
32148: PUSH
32149: LD_INT 3
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 1
32158: PUSH
32159: LD_INT 3
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 2
32179: NEG
32180: PUSH
32181: LD_INT 1
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32213: LD_ADDR_VAR 0 27
32217: PUSH
32218: LD_INT 0
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 0
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 1
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: LD_INT 0
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 1
32282: NEG
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: LD_INT 2
32298: NEG
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 0
32306: PUSH
32307: LD_INT 2
32309: NEG
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 1
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 2
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: LD_INT 2
32338: PUSH
32339: LD_INT 1
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: LD_INT 2
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 2
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 2
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 1
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 2
32389: NEG
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PUSH
32398: LD_INT 2
32400: NEG
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: NEG
32425: PUSH
32426: LD_INT 2
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: LD_INT 3
32446: NEG
32447: PUSH
32448: LD_INT 1
32450: NEG
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 3
32458: NEG
32459: PUSH
32460: LD_INT 2
32462: NEG
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32493: LD_ADDR_VAR 0 28
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 0
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: LD_INT 2
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: LD_INT 2
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 2
32669: NEG
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 2
32704: NEG
32705: PUSH
32706: LD_INT 3
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: NEG
32717: PUSH
32718: LD_INT 3
32720: NEG
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 3
32728: NEG
32729: PUSH
32730: LD_INT 1
32732: NEG
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 3
32740: NEG
32741: PUSH
32742: LD_INT 2
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32775: LD_ADDR_VAR 0 29
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: LD_INT 1
32795: NEG
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: LD_INT 0
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: LD_INT 1
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 0
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 1
32833: NEG
32834: PUSH
32835: LD_INT 0
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: LD_INT 1
32848: NEG
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: LD_INT 2
32860: NEG
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: LD_INT 2
32871: NEG
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: PUSH
32880: LD_INT 1
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 2
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 2
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 1
32910: PUSH
32911: LD_INT 2
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 0
32920: PUSH
32921: LD_INT 2
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 1
32930: NEG
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 2
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 2
32953: NEG
32954: PUSH
32955: LD_INT 2
32957: NEG
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 2
32965: NEG
32966: PUSH
32967: LD_INT 3
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 2
32977: PUSH
32978: LD_INT 1
32980: NEG
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 3
32988: PUSH
32989: LD_INT 1
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 1
32998: PUSH
32999: LD_INT 3
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: LD_INT 2
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 3
33019: NEG
33020: PUSH
33021: LD_INT 2
33023: NEG
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33054: LD_ADDR_VAR 0 30
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 0
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: NEG
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 1
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 1
33135: NEG
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: LD_INT 0
33147: PUSH
33148: LD_INT 2
33150: NEG
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 2
33169: PUSH
33170: LD_INT 0
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 2
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: PUSH
33190: LD_INT 2
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 2
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: NEG
33210: PUSH
33211: LD_INT 1
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 2
33220: NEG
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 1
33243: NEG
33244: PUSH
33245: LD_INT 3
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 1
33255: PUSH
33256: LD_INT 2
33258: NEG
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 3
33266: PUSH
33267: LD_INT 2
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 2
33276: PUSH
33277: LD_INT 3
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: NEG
33287: PUSH
33288: LD_INT 1
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 3
33297: NEG
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33332: LD_ADDR_VAR 0 31
33336: PUSH
33337: LD_INT 0
33339: PUSH
33340: LD_INT 0
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: LD_INT 1
33352: NEG
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 0
33380: PUSH
33381: LD_INT 1
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 1
33390: NEG
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 1
33401: NEG
33402: PUSH
33403: LD_INT 1
33405: NEG
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: LD_INT 2
33417: NEG
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: LD_INT 1
33428: NEG
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 2
33436: PUSH
33437: LD_INT 0
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 2
33446: PUSH
33447: LD_INT 1
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 0
33476: PUSH
33477: LD_INT 2
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: NEG
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 2
33509: NEG
33510: PUSH
33511: LD_INT 2
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: NEG
33522: PUSH
33523: LD_INT 3
33525: NEG
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: LD_INT 1
33536: NEG
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 3
33544: PUSH
33545: LD_INT 1
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 3
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: LD_INT 2
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 3
33575: NEG
33576: PUSH
33577: LD_INT 2
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33610: LD_ADDR_VAR 0 32
33614: PUSH
33615: LD_INT 0
33617: PUSH
33618: LD_INT 0
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 0
33627: PUSH
33628: LD_INT 1
33630: NEG
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 1
33648: PUSH
33649: LD_INT 1
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 0
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: NEG
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 1
33691: NEG
33692: PUSH
33693: LD_INT 2
33695: NEG
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 2
33706: NEG
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 1
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 2
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 2
33735: PUSH
33736: LD_INT 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 2
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 2
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 1
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 2
33776: NEG
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: NEG
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: NEG
33800: PUSH
33801: LD_INT 3
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 3
33822: PUSH
33823: LD_INT 2
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: LD_INT 3
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: NEG
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 3
33853: NEG
33854: PUSH
33855: LD_INT 1
33857: NEG
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33888: LD_ADDR_VAR 0 33
33892: PUSH
33893: LD_INT 0
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 0
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 1
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 1
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 0
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 1
33946: NEG
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: LD_INT 2
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: PUSH
33982: LD_INT 1
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: LD_INT 2
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 1
34032: NEG
34033: PUSH
34034: LD_INT 1
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 2
34043: NEG
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 2
34054: NEG
34055: PUSH
34056: LD_INT 1
34058: NEG
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 2
34066: NEG
34067: PUSH
34068: LD_INT 2
34070: NEG
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 2
34078: NEG
34079: PUSH
34080: LD_INT 3
34082: NEG
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 2
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 3
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 1
34111: PUSH
34112: LD_INT 3
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: NEG
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 3
34132: NEG
34133: PUSH
34134: LD_INT 2
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34167: LD_ADDR_VAR 0 34
34171: PUSH
34172: LD_INT 0
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 1
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: LD_INT 1
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: NEG
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: NEG
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 1
34248: NEG
34249: PUSH
34250: LD_INT 2
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 0
34260: PUSH
34261: LD_INT 2
34263: NEG
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 1
34271: PUSH
34272: LD_INT 1
34274: NEG
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 2
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 2
34323: NEG
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 2
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: LD_INT 3
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 1
34370: PUSH
34371: LD_INT 2
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 3
34381: PUSH
34382: LD_INT 2
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 2
34391: PUSH
34392: LD_INT 3
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 2
34401: NEG
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 3
34412: NEG
34413: PUSH
34414: LD_INT 1
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34447: LD_ADDR_VAR 0 35
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 1
34467: NEG
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 2
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: LD_INT 1
34542: NEG
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34559: LD_ADDR_VAR 0 36
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 0
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: PUSH
34588: LD_INT 0
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: LD_INT 1
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 1
34617: NEG
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 1
34640: NEG
34641: PUSH
34642: LD_INT 2
34644: NEG
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: LD_INT 2
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34671: LD_ADDR_VAR 0 37
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: LD_INT 1
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: PUSH
34700: LD_INT 0
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 1
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 1
34729: NEG
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: LD_INT 1
34744: NEG
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34783: LD_ADDR_VAR 0 38
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: LD_INT 0
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: PUSH
34822: LD_INT 1
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: LD_INT 0
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 2
34874: NEG
34875: PUSH
34876: LD_INT 1
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34895: LD_ADDR_VAR 0 39
34899: PUSH
34900: LD_INT 0
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: PUSH
34924: LD_INT 0
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 1
34933: PUSH
34934: LD_INT 1
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 1
34953: NEG
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: LD_INT 1
34968: NEG
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 1
34976: NEG
34977: PUSH
34978: LD_INT 2
34980: NEG
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 1
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35007: LD_ADDR_VAR 0 40
35011: PUSH
35012: LD_INT 0
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 0
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: NEG
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 1
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 1
35099: NEG
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35119: LD_ADDR_VAR 0 41
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 1
35139: NEG
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 0
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 1
35188: NEG
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: LD_INT 1
35215: NEG
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: LD_INT 1
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: PUSH
35244: LD_INT 2
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 1
35253: PUSH
35254: LD_INT 2
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: LD_INT 1
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 2
35274: NEG
35275: PUSH
35276: LD_INT 0
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 2
35285: NEG
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 2
35297: NEG
35298: PUSH
35299: LD_INT 2
35301: NEG
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 2
35309: NEG
35310: PUSH
35311: LD_INT 3
35313: NEG
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 2
35321: PUSH
35322: LD_INT 1
35324: NEG
35325: PUSH
35326: EMPTY
35327: LIST
35328: LIST
35329: PUSH
35330: LD_INT 3
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: LD_INT 1
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: LD_INT 2
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 3
35362: PUSH
35363: LD_INT 3
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 2
35372: PUSH
35373: LD_INT 3
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: LD_INT 2
35382: NEG
35383: PUSH
35384: LD_INT 1
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 3
35393: NEG
35394: PUSH
35395: LD_INT 0
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 3
35404: NEG
35405: PUSH
35406: LD_INT 1
35408: NEG
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 3
35416: NEG
35417: PUSH
35418: LD_INT 2
35420: NEG
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 3
35428: NEG
35429: PUSH
35430: LD_INT 3
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35469: LD_ADDR_VAR 0 42
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 0
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: LD_INT 2
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 0
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: PUSH
35574: LD_INT 1
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 2
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 2
35594: PUSH
35595: LD_INT 2
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 1
35604: PUSH
35605: LD_INT 2
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: LD_INT 2
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: NEG
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 2
35647: NEG
35648: PUSH
35649: LD_INT 2
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 2
35659: NEG
35660: PUSH
35661: LD_INT 3
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 1
35671: NEG
35672: PUSH
35673: LD_INT 3
35675: NEG
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 0
35683: PUSH
35684: LD_INT 3
35686: NEG
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: LD_INT 2
35697: NEG
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: LD_INT 3
35705: PUSH
35706: LD_INT 2
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 3
35715: PUSH
35716: LD_INT 3
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 2
35725: PUSH
35726: LD_INT 3
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 1
35735: PUSH
35736: LD_INT 3
35738: PUSH
35739: EMPTY
35740: LIST
35741: LIST
35742: PUSH
35743: LD_INT 0
35745: PUSH
35746: LD_INT 3
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: LD_INT 2
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 3
35766: NEG
35767: PUSH
35768: LD_INT 2
35770: NEG
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 3
35778: NEG
35779: PUSH
35780: LD_INT 3
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35819: LD_ADDR_VAR 0 43
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 0
35836: PUSH
35837: LD_INT 1
35839: NEG
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 1
35847: PUSH
35848: LD_INT 0
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 1
35857: PUSH
35858: LD_INT 1
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 0
35867: PUSH
35868: LD_INT 1
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: NEG
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: NEG
35889: PUSH
35890: LD_INT 1
35892: NEG
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 1
35900: NEG
35901: PUSH
35902: LD_INT 2
35904: NEG
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: LD_INT 2
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: LD_INT 1
35926: NEG
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 2
35934: PUSH
35935: LD_INT 0
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: PUSH
35945: LD_INT 1
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: LD_INT 2
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: PUSH
35962: LD_INT 0
35964: PUSH
35965: LD_INT 2
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: LD_INT 1
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 2
35985: NEG
35986: PUSH
35987: LD_INT 0
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 2
35996: NEG
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: NEG
36009: PUSH
36010: LD_INT 3
36012: NEG
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 0
36020: PUSH
36021: LD_INT 3
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 2
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 2
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 3
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 3
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: EMPTY
36068: LIST
36069: LIST
36070: PUSH
36071: LD_INT 1
36073: PUSH
36074: LD_INT 3
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 0
36083: PUSH
36084: LD_INT 3
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 1
36093: NEG
36094: PUSH
36095: LD_INT 2
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 2
36104: NEG
36105: PUSH
36106: LD_INT 1
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: LD_INT 3
36115: NEG
36116: PUSH
36117: LD_INT 0
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 3
36126: NEG
36127: PUSH
36128: LD_INT 1
36130: NEG
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36167: LD_ADDR_VAR 0 44
36171: PUSH
36172: LD_INT 0
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 0
36184: PUSH
36185: LD_INT 1
36187: NEG
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: LD_INT 0
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 1
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 1
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 0
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: NEG
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: LD_INT 2
36252: NEG
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 1
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: LD_INT 0
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: LD_INT 1
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: PUSH
36289: LD_INT 2
36291: PUSH
36292: LD_INT 2
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: LD_INT 2
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 1
36311: NEG
36312: PUSH
36313: LD_INT 1
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: LD_INT 0
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 2
36345: NEG
36346: PUSH
36347: LD_INT 2
36349: NEG
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 2
36357: NEG
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 2
36369: PUSH
36370: LD_INT 1
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 3
36380: PUSH
36381: LD_INT 0
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: LD_INT 2
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 3
36410: PUSH
36411: LD_INT 3
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 2
36420: PUSH
36421: LD_INT 3
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 2
36430: NEG
36431: PUSH
36432: LD_INT 1
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 3
36441: NEG
36442: PUSH
36443: LD_INT 0
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 3
36452: NEG
36453: PUSH
36454: LD_INT 1
36456: NEG
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 3
36464: NEG
36465: PUSH
36466: LD_INT 2
36468: NEG
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 3
36476: NEG
36477: PUSH
36478: LD_INT 3
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36517: LD_ADDR_VAR 0 45
36521: PUSH
36522: LD_INT 0
36524: PUSH
36525: LD_INT 0
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: LD_INT 1
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: LD_INT 0
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: PUSH
36556: LD_INT 1
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: LD_INT 1
36590: NEG
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: NEG
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 0
36610: PUSH
36611: LD_INT 2
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 2
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: LD_INT 2
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: LD_INT 2
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 2
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 1
36672: NEG
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 2
36683: NEG
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 2
36695: NEG
36696: PUSH
36697: LD_INT 2
36699: NEG
36700: PUSH
36701: EMPTY
36702: LIST
36703: LIST
36704: PUSH
36705: LD_INT 2
36707: NEG
36708: PUSH
36709: LD_INT 3
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: NEG
36720: PUSH
36721: LD_INT 3
36723: NEG
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: LD_INT 3
36734: NEG
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: LD_INT 2
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 3
36753: PUSH
36754: LD_INT 2
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 3
36763: PUSH
36764: LD_INT 3
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: LD_INT 3
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: LD_INT 3
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 0
36793: PUSH
36794: LD_INT 3
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 1
36803: NEG
36804: PUSH
36805: LD_INT 2
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 3
36814: NEG
36815: PUSH
36816: LD_INT 2
36818: NEG
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 3
36826: NEG
36827: PUSH
36828: LD_INT 3
36830: NEG
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36867: LD_ADDR_VAR 0 46
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: LD_INT 0
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 0
36884: PUSH
36885: LD_INT 1
36887: NEG
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: PUSH
36896: LD_INT 0
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 1
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 0
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: LD_INT 0
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 1
36936: NEG
36937: PUSH
36938: LD_INT 1
36940: NEG
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: LD_INT 1
36948: NEG
36949: PUSH
36950: LD_INT 2
36952: NEG
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 0
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 1
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 2
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 2
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 1
37002: PUSH
37003: LD_INT 2
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 0
37012: PUSH
37013: LD_INT 2
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: NEG
37023: PUSH
37024: LD_INT 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: LD_INT 0
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 2
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 3
37060: NEG
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: LD_INT 0
37068: PUSH
37069: LD_INT 3
37071: NEG
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: PUSH
37080: LD_INT 2
37082: NEG
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 2
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 3
37101: PUSH
37102: LD_INT 0
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 3
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 3
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 0
37131: PUSH
37132: LD_INT 3
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: LD_INT 2
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 2
37152: NEG
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 3
37163: NEG
37164: PUSH
37165: LD_INT 0
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 3
37174: NEG
37175: PUSH
37176: LD_INT 1
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: LIST
37199: LIST
37200: LIST
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37215: LD_ADDR_VAR 0 47
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: LD_INT 0
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 0
37232: PUSH
37233: LD_INT 1
37235: NEG
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 1
37253: PUSH
37254: LD_INT 1
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: NEG
37285: PUSH
37286: LD_INT 1
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: LD_INT 2
37300: NEG
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 0
37308: PUSH
37309: LD_INT 2
37311: NEG
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: LD_INT 1
37322: NEG
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 2
37330: NEG
37331: PUSH
37332: LD_INT 1
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 2
37342: NEG
37343: PUSH
37344: LD_INT 2
37346: NEG
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37366: LD_ADDR_VAR 0 48
37370: PUSH
37371: LD_INT 0
37373: PUSH
37374: LD_INT 0
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 1
37386: NEG
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: LD_INT 0
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 1
37435: NEG
37436: PUSH
37437: LD_INT 1
37439: NEG
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: LD_INT 2
37451: NEG
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 2
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 2
37481: PUSH
37482: LD_INT 0
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: LD_INT 2
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37513: LD_ADDR_VAR 0 49
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 0
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: LD_INT 1
37533: NEG
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 1
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 1
37571: NEG
37572: PUSH
37573: LD_INT 0
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 1
37582: NEG
37583: PUSH
37584: LD_INT 1
37586: NEG
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 1
37594: PUSH
37595: LD_INT 1
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 2
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 2
37615: PUSH
37616: LD_INT 1
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 2
37625: PUSH
37626: LD_INT 2
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: LD_INT 2
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37657: LD_ADDR_VAR 0 50
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: NEG
37727: PUSH
37728: LD_INT 1
37730: NEG
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 2
37738: PUSH
37739: LD_INT 1
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 2
37748: PUSH
37749: LD_INT 2
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 0
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 1
37778: NEG
37779: PUSH
37780: LD_INT 1
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: LIST
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37801: LD_ADDR_VAR 0 51
37805: PUSH
37806: LD_INT 0
37808: PUSH
37809: LD_INT 0
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 0
37818: PUSH
37819: LD_INT 1
37821: NEG
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 1
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 1
37839: PUSH
37840: LD_INT 1
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: LD_INT 1
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: LD_INT 1
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 2
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 0
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 1
37902: NEG
37903: PUSH
37904: LD_INT 1
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 2
37913: NEG
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 2
37924: NEG
37925: PUSH
37926: LD_INT 1
37928: NEG
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37948: LD_ADDR_VAR 0 52
37952: PUSH
37953: LD_INT 0
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 0
37965: PUSH
37966: LD_INT 1
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: LD_INT 0
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 1
37986: PUSH
37987: LD_INT 1
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 0
37996: PUSH
37997: LD_INT 1
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 1
38017: NEG
38018: PUSH
38019: LD_INT 1
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: LD_INT 2
38033: NEG
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 1
38041: NEG
38042: PUSH
38043: LD_INT 1
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 2
38052: NEG
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 2
38063: NEG
38064: PUSH
38065: LD_INT 1
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 2
38075: NEG
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: LIST
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38099: LD_ADDR_VAR 0 53
38103: PUSH
38104: LD_INT 0
38106: PUSH
38107: LD_INT 0
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 0
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 0
38147: PUSH
38148: LD_INT 1
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 1
38157: NEG
38158: PUSH
38159: LD_INT 0
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 1
38168: NEG
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 1
38180: NEG
38181: PUSH
38182: LD_INT 2
38184: NEG
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: LD_INT 2
38195: NEG
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: PUSH
38204: LD_INT 1
38206: NEG
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 2
38224: PUSH
38225: LD_INT 1
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 2
38234: PUSH
38235: LD_INT 2
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 1
38244: PUSH
38245: LD_INT 2
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: LD_INT 2
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 2
38275: NEG
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 2
38286: NEG
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 2
38298: NEG
38299: PUSH
38300: LD_INT 2
38302: NEG
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38329: LD_ADDR_VAR 0 54
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 0
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 1
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 1
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: LD_INT 1
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 1
38387: NEG
38388: PUSH
38389: LD_INT 0
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: LD_INT 1
38398: NEG
38399: PUSH
38400: LD_INT 1
38402: NEG
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 1
38410: NEG
38411: PUSH
38412: LD_INT 2
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: NEG
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 2
38444: PUSH
38445: LD_INT 0
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 2
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 2
38464: PUSH
38465: LD_INT 2
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 0
38484: PUSH
38485: LD_INT 2
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 2
38505: NEG
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 2
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: LD_INT 2
38532: NEG
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38559: LD_ADDR_VAR 0 55
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 0
38576: PUSH
38577: LD_INT 1
38579: NEG
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 1
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 1
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 0
38607: PUSH
38608: LD_INT 1
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: LD_INT 1
38617: NEG
38618: PUSH
38619: LD_INT 0
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 1
38628: NEG
38629: PUSH
38630: LD_INT 1
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 1
38640: NEG
38641: PUSH
38642: LD_INT 2
38644: NEG
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 0
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: LD_INT 1
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 2
38674: PUSH
38675: LD_INT 0
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 2
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: LD_INT 2
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 1
38724: NEG
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 2
38735: NEG
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 2
38746: NEG
38747: PUSH
38748: LD_INT 1
38750: NEG
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 2
38758: NEG
38759: PUSH
38760: LD_INT 2
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: LIST
38781: LIST
38782: LIST
38783: LIST
38784: LIST
38785: LIST
38786: LIST
38787: LIST
38788: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38789: LD_ADDR_VAR 0 56
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 0
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 0
38806: PUSH
38807: LD_INT 1
38809: NEG
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 1
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: PUSH
38828: LD_INT 1
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 1
38847: NEG
38848: PUSH
38849: LD_INT 0
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 1
38858: NEG
38859: PUSH
38860: LD_INT 1
38862: NEG
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 1
38870: NEG
38871: PUSH
38872: LD_INT 2
38874: NEG
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 1
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 2
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 2
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 2
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: LD_INT 2
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 0
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 1
38954: NEG
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 2
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 2
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 2
38988: NEG
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39019: LD_ADDR_VAR 0 57
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 0
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 0
39067: PUSH
39068: LD_INT 1
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: LD_INT 0
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 1
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 0
39112: PUSH
39113: LD_INT 2
39115: NEG
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 2
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 2
39154: PUSH
39155: LD_INT 2
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: PUSH
39165: LD_INT 2
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 0
39174: PUSH
39175: LD_INT 2
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: NEG
39185: PUSH
39186: LD_INT 1
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 2
39195: NEG
39196: PUSH
39197: LD_INT 0
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 2
39206: NEG
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 2
39218: NEG
39219: PUSH
39220: LD_INT 2
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39249: LD_ADDR_VAR 0 58
39253: PUSH
39254: LD_INT 0
39256: PUSH
39257: LD_INT 0
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 1
39277: PUSH
39278: LD_INT 0
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 1
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: LD_INT 1
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: LD_INT 0
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 1
39330: NEG
39331: PUSH
39332: LD_INT 2
39334: NEG
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: LD_INT 0
39342: PUSH
39343: LD_INT 2
39345: NEG
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 1
39353: PUSH
39354: LD_INT 1
39356: NEG
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 2
39364: PUSH
39365: LD_INT 0
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 2
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 2
39384: PUSH
39385: LD_INT 2
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: LD_INT 2
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: LD_INT 2
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 1
39414: NEG
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: LD_INT 0
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 2
39436: NEG
39437: PUSH
39438: LD_INT 1
39440: NEG
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 2
39448: NEG
39449: PUSH
39450: LD_INT 2
39452: NEG
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: LIST
39474: LIST
39475: LIST
39476: LIST
39477: LIST
39478: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39479: LD_ADDR_VAR 0 59
39483: PUSH
39484: LD_INT 0
39486: PUSH
39487: LD_INT 0
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 0
39496: PUSH
39497: LD_INT 1
39499: NEG
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: LD_INT 0
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 1
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 0
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 1
39548: NEG
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39567: LD_ADDR_VAR 0 60
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: LD_INT 1
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 0
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 1
39605: PUSH
39606: LD_INT 1
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 0
39615: PUSH
39616: LD_INT 1
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: NEG
39626: PUSH
39627: LD_INT 0
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: LD_INT 1
39640: NEG
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39655: LD_ADDR_VAR 0 61
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 0
39672: PUSH
39673: LD_INT 1
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 1
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: LD_INT 1
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 1
39713: NEG
39714: PUSH
39715: LD_INT 0
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 1
39724: NEG
39725: PUSH
39726: LD_INT 1
39728: NEG
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: LIST
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39743: LD_ADDR_VAR 0 62
39747: PUSH
39748: LD_INT 0
39750: PUSH
39751: LD_INT 0
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 1
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: LD_INT 1
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: LD_INT 0
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 1
39812: NEG
39813: PUSH
39814: LD_INT 1
39816: NEG
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39831: LD_ADDR_VAR 0 63
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: LD_INT 1
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: PUSH
39860: LD_INT 0
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: LD_INT 1
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 1
39889: NEG
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 1
39900: NEG
39901: PUSH
39902: LD_INT 1
39904: NEG
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39919: LD_ADDR_VAR 0 64
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: LD_INT 1
39939: NEG
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: LD_INT 0
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 1
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 1
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: LD_INT 0
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 1
39988: NEG
39989: PUSH
39990: LD_INT 1
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: ST_TO_ADDR
// end ; 1 :
40007: GO 45904
40009: LD_INT 1
40011: DOUBLE
40012: EQUAL
40013: IFTRUE 40017
40015: GO 42640
40017: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40018: LD_ADDR_VAR 0 11
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: LD_INT 3
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: LD_INT 3
40040: NEG
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: LD_INT 2
40051: NEG
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: LIST
40061: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40062: LD_ADDR_VAR 0 12
40066: PUSH
40067: LD_INT 2
40069: PUSH
40070: LD_INT 1
40072: NEG
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 3
40080: PUSH
40081: LD_INT 0
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 3
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: LIST
40102: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40103: LD_ADDR_VAR 0 13
40107: PUSH
40108: LD_INT 3
40110: PUSH
40111: LD_INT 2
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 3
40120: PUSH
40121: LD_INT 3
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 2
40130: PUSH
40131: LD_INT 3
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: LIST
40142: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40143: LD_ADDR_VAR 0 14
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 3
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: LD_INT 3
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: NEG
40171: PUSH
40172: LD_INT 2
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: LIST
40183: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40184: LD_ADDR_VAR 0 15
40188: PUSH
40189: LD_INT 2
40191: NEG
40192: PUSH
40193: LD_INT 1
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 3
40202: NEG
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: LD_INT 3
40213: NEG
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: LIST
40227: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40228: LD_ADDR_VAR 0 16
40232: PUSH
40233: LD_INT 2
40235: NEG
40236: PUSH
40237: LD_INT 3
40239: NEG
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 3
40247: NEG
40248: PUSH
40249: LD_INT 2
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 3
40259: NEG
40260: PUSH
40261: LD_INT 3
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: LIST
40273: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40274: LD_ADDR_VAR 0 17
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: LD_INT 3
40285: NEG
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 0
40293: PUSH
40294: LD_INT 3
40296: NEG
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: LD_INT 2
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: LIST
40317: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40318: LD_ADDR_VAR 0 18
40322: PUSH
40323: LD_INT 2
40325: PUSH
40326: LD_INT 1
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 3
40336: PUSH
40337: LD_INT 0
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 3
40346: PUSH
40347: LD_INT 1
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: LIST
40358: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40359: LD_ADDR_VAR 0 19
40363: PUSH
40364: LD_INT 3
40366: PUSH
40367: LD_INT 2
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 3
40376: PUSH
40377: LD_INT 3
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 2
40386: PUSH
40387: LD_INT 3
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: LIST
40398: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40399: LD_ADDR_VAR 0 20
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 3
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 3
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 2
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: LIST
40439: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40440: LD_ADDR_VAR 0 21
40444: PUSH
40445: LD_INT 2
40447: NEG
40448: PUSH
40449: LD_INT 1
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 3
40458: NEG
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 3
40469: NEG
40470: PUSH
40471: LD_INT 1
40473: NEG
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: LIST
40483: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40484: LD_ADDR_VAR 0 22
40488: PUSH
40489: LD_INT 2
40491: NEG
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 3
40503: NEG
40504: PUSH
40505: LD_INT 2
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: NEG
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: LIST
40529: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40530: LD_ADDR_VAR 0 23
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 3
40540: NEG
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 1
40548: NEG
40549: PUSH
40550: LD_INT 4
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 1
40560: PUSH
40561: LD_INT 3
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: LIST
40573: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40574: LD_ADDR_VAR 0 24
40578: PUSH
40579: LD_INT 3
40581: PUSH
40582: LD_INT 0
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 3
40591: PUSH
40592: LD_INT 1
40594: NEG
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 4
40602: PUSH
40603: LD_INT 1
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: LIST
40614: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40615: LD_ADDR_VAR 0 25
40619: PUSH
40620: LD_INT 3
40622: PUSH
40623: LD_INT 3
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 4
40632: PUSH
40633: LD_INT 3
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 3
40642: PUSH
40643: LD_INT 4
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: LIST
40654: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40655: LD_ADDR_VAR 0 26
40659: PUSH
40660: LD_INT 0
40662: PUSH
40663: LD_INT 3
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: LD_INT 4
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: NEG
40683: PUSH
40684: LD_INT 3
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: LIST
40695: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40696: LD_ADDR_VAR 0 27
40700: PUSH
40701: LD_INT 3
40703: NEG
40704: PUSH
40705: LD_INT 0
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 3
40714: NEG
40715: PUSH
40716: LD_INT 1
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 4
40725: NEG
40726: PUSH
40727: LD_INT 1
40729: NEG
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40740: LD_ADDR_VAR 0 28
40744: PUSH
40745: LD_INT 3
40747: NEG
40748: PUSH
40749: LD_INT 3
40751: NEG
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 3
40759: NEG
40760: PUSH
40761: LD_INT 4
40763: NEG
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 4
40771: NEG
40772: PUSH
40773: LD_INT 3
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: LIST
40785: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40786: LD_ADDR_VAR 0 29
40790: PUSH
40791: LD_INT 1
40793: NEG
40794: PUSH
40795: LD_INT 3
40797: NEG
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 0
40805: PUSH
40806: LD_INT 3
40808: NEG
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 1
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 4
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 0
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 1
40850: PUSH
40851: LD_INT 3
40853: NEG
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 1
40861: NEG
40862: PUSH
40863: LD_INT 5
40865: NEG
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: LD_INT 5
40876: NEG
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 1
40884: PUSH
40885: LD_INT 4
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 1
40895: NEG
40896: PUSH
40897: LD_INT 6
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 0
40907: PUSH
40908: LD_INT 6
40910: NEG
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 1
40918: PUSH
40919: LD_INT 5
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40941: LD_ADDR_VAR 0 30
40945: PUSH
40946: LD_INT 2
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 3
40959: PUSH
40960: LD_INT 0
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 3
40969: PUSH
40970: LD_INT 1
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 3
40979: PUSH
40980: LD_INT 1
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 4
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: LD_INT 4
41000: PUSH
41001: LD_INT 1
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 4
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 5
41021: PUSH
41022: LD_INT 0
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 5
41031: PUSH
41032: LD_INT 1
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: LD_INT 5
41041: PUSH
41042: LD_INT 1
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 6
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 6
41062: PUSH
41063: LD_INT 1
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41084: LD_ADDR_VAR 0 31
41088: PUSH
41089: LD_INT 3
41091: PUSH
41092: LD_INT 2
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 3
41101: PUSH
41102: LD_INT 3
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 2
41111: PUSH
41112: LD_INT 3
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: LD_INT 4
41121: PUSH
41122: LD_INT 3
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 4
41131: PUSH
41132: LD_INT 4
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 3
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 5
41151: PUSH
41152: LD_INT 4
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 5
41161: PUSH
41162: LD_INT 5
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 4
41171: PUSH
41172: LD_INT 5
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 6
41181: PUSH
41182: LD_INT 5
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 6
41191: PUSH
41192: LD_INT 6
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: LD_INT 5
41201: PUSH
41202: LD_INT 6
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41223: LD_ADDR_VAR 0 32
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: LD_INT 3
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 0
41240: PUSH
41241: LD_INT 3
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: NEG
41251: PUSH
41252: LD_INT 2
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: LD_INT 1
41261: PUSH
41262: LD_INT 4
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: LD_INT 4
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: NEG
41282: PUSH
41283: LD_INT 3
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 1
41292: PUSH
41293: LD_INT 5
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: LD_INT 5
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 1
41312: NEG
41313: PUSH
41314: LD_INT 4
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 1
41323: PUSH
41324: LD_INT 6
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: LD_INT 0
41333: PUSH
41334: LD_INT 6
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 1
41343: NEG
41344: PUSH
41345: LD_INT 5
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: LIST
41364: LIST
41365: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41366: LD_ADDR_VAR 0 33
41370: PUSH
41371: LD_INT 2
41373: NEG
41374: PUSH
41375: LD_INT 1
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: LD_INT 3
41384: NEG
41385: PUSH
41386: LD_INT 0
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 3
41395: NEG
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 3
41407: NEG
41408: PUSH
41409: LD_INT 1
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 4
41418: NEG
41419: PUSH
41420: LD_INT 0
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 4
41429: NEG
41430: PUSH
41431: LD_INT 1
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 4
41441: NEG
41442: PUSH
41443: LD_INT 1
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 5
41452: NEG
41453: PUSH
41454: LD_INT 0
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 5
41463: NEG
41464: PUSH
41465: LD_INT 1
41467: NEG
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 5
41475: NEG
41476: PUSH
41477: LD_INT 1
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 6
41486: NEG
41487: PUSH
41488: LD_INT 0
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 6
41497: NEG
41498: PUSH
41499: LD_INT 1
41501: NEG
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41521: LD_ADDR_VAR 0 34
41525: PUSH
41526: LD_INT 2
41528: NEG
41529: PUSH
41530: LD_INT 3
41532: NEG
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 3
41540: NEG
41541: PUSH
41542: LD_INT 2
41544: NEG
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: NEG
41553: PUSH
41554: LD_INT 3
41556: NEG
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 3
41564: NEG
41565: PUSH
41566: LD_INT 4
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: NEG
41577: PUSH
41578: LD_INT 3
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 4
41588: NEG
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 4
41600: NEG
41601: PUSH
41602: LD_INT 5
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 5
41612: NEG
41613: PUSH
41614: LD_INT 4
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: NEG
41625: PUSH
41626: LD_INT 5
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 5
41636: NEG
41637: PUSH
41638: LD_INT 6
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 6
41648: NEG
41649: PUSH
41650: LD_INT 5
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 6
41660: NEG
41661: PUSH
41662: LD_INT 6
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41684: LD_ADDR_VAR 0 41
41688: PUSH
41689: LD_INT 0
41691: PUSH
41692: LD_INT 2
41694: NEG
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: LD_INT 3
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 1
41714: PUSH
41715: LD_INT 2
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: LIST
41727: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41728: LD_ADDR_VAR 0 42
41732: PUSH
41733: LD_INT 2
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 2
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 3
41756: PUSH
41757: LD_INT 1
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: LIST
41768: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41769: LD_ADDR_VAR 0 43
41773: PUSH
41774: LD_INT 2
41776: PUSH
41777: LD_INT 2
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: LD_INT 2
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 2
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: LIST
41808: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41809: LD_ADDR_VAR 0 44
41813: PUSH
41814: LD_INT 0
41816: PUSH
41817: LD_INT 2
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 1
41826: PUSH
41827: LD_INT 3
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 1
41836: NEG
41837: PUSH
41838: LD_INT 2
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: LIST
41849: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41850: LD_ADDR_VAR 0 45
41854: PUSH
41855: LD_INT 2
41857: NEG
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 3
41879: NEG
41880: PUSH
41881: LD_INT 1
41883: NEG
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: LIST
41893: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41894: LD_ADDR_VAR 0 46
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: LD_INT 2
41905: NEG
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 2
41913: NEG
41914: PUSH
41915: LD_INT 3
41917: NEG
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 3
41925: NEG
41926: PUSH
41927: LD_INT 2
41929: NEG
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: LIST
41939: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41940: LD_ADDR_VAR 0 47
41944: PUSH
41945: LD_INT 2
41947: NEG
41948: PUSH
41949: LD_INT 3
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 1
41959: NEG
41960: PUSH
41961: LD_INT 3
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: EMPTY
41970: LIST
41971: LIST
41972: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41973: LD_ADDR_VAR 0 48
41977: PUSH
41978: LD_INT 1
41980: PUSH
41981: LD_INT 2
41983: NEG
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 2
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42004: LD_ADDR_VAR 0 49
42008: PUSH
42009: LD_INT 3
42011: PUSH
42012: LD_INT 1
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 3
42021: PUSH
42022: LD_INT 2
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42033: LD_ADDR_VAR 0 50
42037: PUSH
42038: LD_INT 2
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 1
42050: PUSH
42051: LD_INT 3
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42062: LD_ADDR_VAR 0 51
42066: PUSH
42067: LD_INT 1
42069: NEG
42070: PUSH
42071: LD_INT 2
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 2
42080: NEG
42081: PUSH
42082: LD_INT 1
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42093: LD_ADDR_VAR 0 52
42097: PUSH
42098: LD_INT 3
42100: NEG
42101: PUSH
42102: LD_INT 1
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 3
42112: NEG
42113: PUSH
42114: LD_INT 2
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42126: LD_ADDR_VAR 0 53
42130: PUSH
42131: LD_INT 1
42133: NEG
42134: PUSH
42135: LD_INT 3
42137: NEG
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 3
42148: NEG
42149: PUSH
42150: EMPTY
42151: LIST
42152: LIST
42153: PUSH
42154: LD_INT 1
42156: PUSH
42157: LD_INT 2
42159: NEG
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: LIST
42169: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42170: LD_ADDR_VAR 0 54
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 3
42188: PUSH
42189: LD_INT 0
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: LD_INT 1
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: LIST
42210: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42211: LD_ADDR_VAR 0 55
42215: PUSH
42216: LD_INT 3
42218: PUSH
42219: LD_INT 2
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: LD_INT 3
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 2
42238: PUSH
42239: LD_INT 3
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: LIST
42250: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42251: LD_ADDR_VAR 0 56
42255: PUSH
42256: LD_INT 1
42258: PUSH
42259: LD_INT 3
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 0
42268: PUSH
42269: LD_INT 3
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 1
42278: NEG
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42292: LD_ADDR_VAR 0 57
42296: PUSH
42297: LD_INT 2
42299: NEG
42300: PUSH
42301: LD_INT 1
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 3
42310: NEG
42311: PUSH
42312: LD_INT 0
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 3
42321: NEG
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: LIST
42335: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42336: LD_ADDR_VAR 0 58
42340: PUSH
42341: LD_INT 2
42343: NEG
42344: PUSH
42345: LD_INT 3
42347: NEG
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 3
42355: NEG
42356: PUSH
42357: LD_INT 2
42359: NEG
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 3
42367: NEG
42368: PUSH
42369: LD_INT 3
42371: NEG
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: LIST
42381: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42382: LD_ADDR_VAR 0 59
42386: PUSH
42387: LD_INT 1
42389: NEG
42390: PUSH
42391: LD_INT 2
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 0
42401: PUSH
42402: LD_INT 2
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 1
42412: PUSH
42413: LD_INT 1
42415: NEG
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: LIST
42425: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42426: LD_ADDR_VAR 0 60
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 1
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 2
42444: PUSH
42445: LD_INT 0
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 2
42454: PUSH
42455: LD_INT 1
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42467: LD_ADDR_VAR 0 61
42471: PUSH
42472: LD_INT 2
42474: PUSH
42475: LD_INT 1
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 2
42484: PUSH
42485: LD_INT 2
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: LIST
42506: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42507: LD_ADDR_VAR 0 62
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: LD_INT 2
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 0
42524: PUSH
42525: LD_INT 2
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 1
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: LIST
42547: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42548: LD_ADDR_VAR 0 63
42552: PUSH
42553: LD_INT 1
42555: NEG
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 2
42566: NEG
42567: PUSH
42568: LD_INT 0
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 2
42577: NEG
42578: PUSH
42579: LD_INT 1
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42592: LD_ADDR_VAR 0 64
42596: PUSH
42597: LD_INT 1
42599: NEG
42600: PUSH
42601: LD_INT 2
42603: NEG
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 2
42611: NEG
42612: PUSH
42613: LD_INT 1
42615: NEG
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 2
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: LIST
42637: ST_TO_ADDR
// end ; 2 :
42638: GO 45904
42640: LD_INT 2
42642: DOUBLE
42643: EQUAL
42644: IFTRUE 42648
42646: GO 45903
42648: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42649: LD_ADDR_VAR 0 29
42653: PUSH
42654: LD_INT 4
42656: PUSH
42657: LD_INT 0
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 4
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 5
42677: PUSH
42678: LD_INT 0
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 5
42687: PUSH
42688: LD_INT 1
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: LD_INT 4
42697: PUSH
42698: LD_INT 1
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 3
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 3
42717: PUSH
42718: LD_INT 1
42720: NEG
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 3
42728: PUSH
42729: LD_INT 2
42731: NEG
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 5
42739: PUSH
42740: LD_INT 2
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 3
42749: PUSH
42750: LD_INT 3
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 3
42759: PUSH
42760: LD_INT 2
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 4
42769: PUSH
42770: LD_INT 3
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 4
42779: PUSH
42780: LD_INT 4
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 3
42789: PUSH
42790: LD_INT 4
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 2
42799: PUSH
42800: LD_INT 3
42802: PUSH
42803: EMPTY
42804: LIST
42805: LIST
42806: PUSH
42807: LD_INT 2
42809: PUSH
42810: LD_INT 2
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 4
42819: PUSH
42820: LD_INT 2
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: PUSH
42830: LD_INT 4
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 0
42839: PUSH
42840: LD_INT 4
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 0
42849: PUSH
42850: LD_INT 3
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 1
42859: PUSH
42860: LD_INT 4
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 1
42869: PUSH
42870: LD_INT 5
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: LD_INT 0
42879: PUSH
42880: LD_INT 5
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 1
42889: NEG
42890: PUSH
42891: LD_INT 4
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 1
42900: NEG
42901: PUSH
42902: LD_INT 3
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 2
42911: PUSH
42912: LD_INT 5
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 2
42921: NEG
42922: PUSH
42923: LD_INT 3
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 3
42932: NEG
42933: PUSH
42934: LD_INT 0
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 3
42943: NEG
42944: PUSH
42945: LD_INT 1
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: LD_INT 2
42955: NEG
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: LD_INT 2
42966: NEG
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 3
42977: NEG
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 4
42988: NEG
42989: PUSH
42990: LD_INT 0
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 4
42999: NEG
43000: PUSH
43001: LD_INT 1
43003: NEG
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PUSH
43009: LD_INT 4
43011: NEG
43012: PUSH
43013: LD_INT 2
43015: NEG
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 2
43023: NEG
43024: PUSH
43025: LD_INT 2
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: LD_INT 4
43034: NEG
43035: PUSH
43036: LD_INT 4
43038: NEG
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 4
43046: NEG
43047: PUSH
43048: LD_INT 5
43050: NEG
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 3
43058: NEG
43059: PUSH
43060: LD_INT 4
43062: NEG
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 3
43070: NEG
43071: PUSH
43072: LD_INT 3
43074: NEG
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 4
43082: NEG
43083: PUSH
43084: LD_INT 3
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 5
43094: NEG
43095: PUSH
43096: LD_INT 4
43098: NEG
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 5
43106: NEG
43107: PUSH
43108: LD_INT 5
43110: NEG
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 3
43118: NEG
43119: PUSH
43120: LD_INT 5
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 5
43130: NEG
43131: PUSH
43132: LD_INT 3
43134: NEG
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: LIST
43144: LIST
43145: LIST
43146: LIST
43147: LIST
43148: LIST
43149: LIST
43150: LIST
43151: LIST
43152: LIST
43153: LIST
43154: LIST
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43187: LD_ADDR_VAR 0 30
43191: PUSH
43192: LD_INT 4
43194: PUSH
43195: LD_INT 4
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 4
43204: PUSH
43205: LD_INT 3
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 5
43214: PUSH
43215: LD_INT 4
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 5
43224: PUSH
43225: LD_INT 5
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: LD_INT 5
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 3
43244: PUSH
43245: LD_INT 4
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 3
43254: PUSH
43255: LD_INT 3
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 5
43264: PUSH
43265: LD_INT 3
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 3
43274: PUSH
43275: LD_INT 5
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 0
43284: PUSH
43285: LD_INT 3
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 0
43294: PUSH
43295: LD_INT 2
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 1
43304: PUSH
43305: LD_INT 3
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 1
43314: PUSH
43315: LD_INT 4
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 4
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 1
43334: NEG
43335: PUSH
43336: LD_INT 3
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 1
43345: NEG
43346: PUSH
43347: LD_INT 2
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: LD_INT 4
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: LD_INT 2
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 4
43377: NEG
43378: PUSH
43379: LD_INT 0
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: PUSH
43386: LD_INT 4
43388: NEG
43389: PUSH
43390: LD_INT 1
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 3
43400: NEG
43401: PUSH
43402: LD_INT 0
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 3
43411: NEG
43412: PUSH
43413: LD_INT 1
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: NEG
43423: PUSH
43424: LD_INT 1
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 5
43433: NEG
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 5
43444: NEG
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 5
43456: NEG
43457: PUSH
43458: LD_INT 2
43460: NEG
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 3
43468: NEG
43469: PUSH
43470: LD_INT 2
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 3
43479: NEG
43480: PUSH
43481: LD_INT 3
43483: NEG
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 3
43491: NEG
43492: PUSH
43493: LD_INT 4
43495: NEG
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 2
43503: NEG
43504: PUSH
43505: LD_INT 3
43507: NEG
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 2
43515: NEG
43516: PUSH
43517: LD_INT 2
43519: NEG
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: LD_INT 3
43527: NEG
43528: PUSH
43529: LD_INT 2
43531: NEG
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 4
43539: NEG
43540: PUSH
43541: LD_INT 3
43543: NEG
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 4
43551: NEG
43552: PUSH
43553: LD_INT 4
43555: NEG
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: NEG
43564: PUSH
43565: LD_INT 4
43567: NEG
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 4
43575: NEG
43576: PUSH
43577: LD_INT 2
43579: NEG
43580: PUSH
43581: EMPTY
43582: LIST
43583: LIST
43584: PUSH
43585: LD_INT 0
43587: PUSH
43588: LD_INT 4
43590: NEG
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 5
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 1
43609: PUSH
43610: LD_INT 4
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: LD_INT 3
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 0
43631: PUSH
43632: LD_INT 3
43634: NEG
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 1
43642: NEG
43643: PUSH
43644: LD_INT 4
43646: NEG
43647: PUSH
43648: EMPTY
43649: LIST
43650: LIST
43651: PUSH
43652: LD_INT 1
43654: NEG
43655: PUSH
43656: LD_INT 5
43658: NEG
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: LD_INT 3
43669: NEG
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: PUSH
43675: LD_INT 2
43677: NEG
43678: PUSH
43679: LD_INT 5
43681: NEG
43682: PUSH
43683: EMPTY
43684: LIST
43685: LIST
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43734: LD_ADDR_VAR 0 31
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: LD_INT 4
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 0
43751: PUSH
43752: LD_INT 3
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 1
43761: PUSH
43762: LD_INT 4
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 1
43771: PUSH
43772: LD_INT 5
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: LD_INT 5
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 1
43791: NEG
43792: PUSH
43793: LD_INT 4
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 1
43802: NEG
43803: PUSH
43804: LD_INT 3
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 2
43813: PUSH
43814: LD_INT 5
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 2
43823: NEG
43824: PUSH
43825: LD_INT 3
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 3
43834: NEG
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 3
43845: NEG
43846: PUSH
43847: LD_INT 1
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 0
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 2
43868: NEG
43869: PUSH
43870: LD_INT 1
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: NEG
43880: PUSH
43881: LD_INT 1
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 4
43890: NEG
43891: PUSH
43892: LD_INT 0
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 4
43901: NEG
43902: PUSH
43903: LD_INT 1
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 4
43913: NEG
43914: PUSH
43915: LD_INT 2
43917: NEG
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 2
43925: NEG
43926: PUSH
43927: LD_INT 2
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 4
43936: NEG
43937: PUSH
43938: LD_INT 4
43940: NEG
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: NEG
43949: PUSH
43950: LD_INT 5
43952: NEG
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 3
43960: NEG
43961: PUSH
43962: LD_INT 4
43964: NEG
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 3
43972: NEG
43973: PUSH
43974: LD_INT 3
43976: NEG
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 4
43984: NEG
43985: PUSH
43986: LD_INT 3
43988: NEG
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 5
43996: NEG
43997: PUSH
43998: LD_INT 4
44000: NEG
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 5
44008: NEG
44009: PUSH
44010: LD_INT 5
44012: NEG
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 3
44020: NEG
44021: PUSH
44022: LD_INT 5
44024: NEG
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 5
44032: NEG
44033: PUSH
44034: LD_INT 3
44036: NEG
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 0
44044: PUSH
44045: LD_INT 3
44047: NEG
44048: PUSH
44049: EMPTY
44050: LIST
44051: LIST
44052: PUSH
44053: LD_INT 0
44055: PUSH
44056: LD_INT 4
44058: NEG
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 1
44066: PUSH
44067: LD_INT 3
44069: NEG
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 1
44077: PUSH
44078: LD_INT 2
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 0
44088: PUSH
44089: LD_INT 2
44091: NEG
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 1
44099: NEG
44100: PUSH
44101: LD_INT 3
44103: NEG
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 1
44111: NEG
44112: PUSH
44113: LD_INT 4
44115: NEG
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 2
44134: NEG
44135: PUSH
44136: LD_INT 4
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 4
44146: PUSH
44147: LD_INT 0
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 4
44156: PUSH
44157: LD_INT 1
44159: NEG
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 5
44167: PUSH
44168: LD_INT 0
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 5
44177: PUSH
44178: LD_INT 1
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 4
44187: PUSH
44188: LD_INT 1
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 3
44197: PUSH
44198: LD_INT 0
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: PUSH
44208: LD_INT 1
44210: NEG
44211: PUSH
44212: EMPTY
44213: LIST
44214: LIST
44215: PUSH
44216: LD_INT 3
44218: PUSH
44219: LD_INT 2
44221: NEG
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 5
44229: PUSH
44230: LD_INT 2
44232: PUSH
44233: EMPTY
44234: LIST
44235: LIST
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44284: LD_ADDR_VAR 0 32
44288: PUSH
44289: LD_INT 4
44291: NEG
44292: PUSH
44293: LD_INT 0
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 4
44302: NEG
44303: PUSH
44304: LD_INT 1
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 3
44314: NEG
44315: PUSH
44316: LD_INT 0
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: LD_INT 3
44325: NEG
44326: PUSH
44327: LD_INT 1
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 4
44336: NEG
44337: PUSH
44338: LD_INT 1
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: PUSH
44345: LD_INT 5
44347: NEG
44348: PUSH
44349: LD_INT 0
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 5
44358: NEG
44359: PUSH
44360: LD_INT 1
44362: NEG
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 5
44370: NEG
44371: PUSH
44372: LD_INT 2
44374: NEG
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 3
44382: NEG
44383: PUSH
44384: LD_INT 2
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 3
44393: NEG
44394: PUSH
44395: LD_INT 3
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 3
44405: NEG
44406: PUSH
44407: LD_INT 4
44409: NEG
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 2
44417: NEG
44418: PUSH
44419: LD_INT 3
44421: NEG
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 2
44429: NEG
44430: PUSH
44431: LD_INT 2
44433: NEG
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 3
44441: NEG
44442: PUSH
44443: LD_INT 2
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 4
44453: NEG
44454: PUSH
44455: LD_INT 3
44457: NEG
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 4
44465: NEG
44466: PUSH
44467: LD_INT 4
44469: NEG
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 2
44477: NEG
44478: PUSH
44479: LD_INT 4
44481: NEG
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: LD_INT 4
44489: NEG
44490: PUSH
44491: LD_INT 2
44493: NEG
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 0
44501: PUSH
44502: LD_INT 4
44504: NEG
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 0
44512: PUSH
44513: LD_INT 5
44515: NEG
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 1
44523: PUSH
44524: LD_INT 4
44526: NEG
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 1
44534: PUSH
44535: LD_INT 3
44537: NEG
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 0
44545: PUSH
44546: LD_INT 3
44548: NEG
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 1
44556: NEG
44557: PUSH
44558: LD_INT 4
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 1
44568: NEG
44569: PUSH
44570: LD_INT 5
44572: NEG
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 2
44580: PUSH
44581: LD_INT 3
44583: NEG
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 2
44591: NEG
44592: PUSH
44593: LD_INT 5
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 3
44603: PUSH
44604: LD_INT 0
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 3
44613: PUSH
44614: LD_INT 1
44616: NEG
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: LD_INT 4
44624: PUSH
44625: LD_INT 0
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 4
44634: PUSH
44635: LD_INT 1
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 3
44644: PUSH
44645: LD_INT 1
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 2
44654: PUSH
44655: LD_INT 0
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 2
44664: PUSH
44665: LD_INT 1
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: LD_INT 2
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 4
44686: PUSH
44687: LD_INT 2
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: PUSH
44694: LD_INT 4
44696: PUSH
44697: LD_INT 4
44699: PUSH
44700: EMPTY
44701: LIST
44702: LIST
44703: PUSH
44704: LD_INT 4
44706: PUSH
44707: LD_INT 3
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 5
44716: PUSH
44717: LD_INT 4
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 5
44726: PUSH
44727: LD_INT 5
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 4
44736: PUSH
44737: LD_INT 5
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 3
44746: PUSH
44747: LD_INT 4
44749: PUSH
44750: EMPTY
44751: LIST
44752: LIST
44753: PUSH
44754: LD_INT 3
44756: PUSH
44757: LD_INT 3
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 5
44766: PUSH
44767: LD_INT 3
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 3
44776: PUSH
44777: LD_INT 5
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44831: LD_ADDR_VAR 0 33
44835: PUSH
44836: LD_INT 4
44838: NEG
44839: PUSH
44840: LD_INT 4
44842: NEG
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PUSH
44848: LD_INT 4
44850: NEG
44851: PUSH
44852: LD_INT 5
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 3
44862: NEG
44863: PUSH
44864: LD_INT 4
44866: NEG
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 3
44874: NEG
44875: PUSH
44876: LD_INT 3
44878: NEG
44879: PUSH
44880: EMPTY
44881: LIST
44882: LIST
44883: PUSH
44884: LD_INT 4
44886: NEG
44887: PUSH
44888: LD_INT 3
44890: NEG
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PUSH
44896: LD_INT 5
44898: NEG
44899: PUSH
44900: LD_INT 4
44902: NEG
44903: PUSH
44904: EMPTY
44905: LIST
44906: LIST
44907: PUSH
44908: LD_INT 5
44910: NEG
44911: PUSH
44912: LD_INT 5
44914: NEG
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 3
44922: NEG
44923: PUSH
44924: LD_INT 5
44926: NEG
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 5
44934: NEG
44935: PUSH
44936: LD_INT 3
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 0
44946: PUSH
44947: LD_INT 3
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 0
44957: PUSH
44958: LD_INT 4
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 1
44968: PUSH
44969: LD_INT 3
44971: NEG
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 1
44979: PUSH
44980: LD_INT 2
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 0
44990: PUSH
44991: LD_INT 2
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 1
45001: NEG
45002: PUSH
45003: LD_INT 3
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 1
45013: NEG
45014: PUSH
45015: LD_INT 4
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 2
45025: PUSH
45026: LD_INT 2
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 2
45036: NEG
45037: PUSH
45038: LD_INT 4
45040: NEG
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: PUSH
45046: LD_INT 4
45048: PUSH
45049: LD_INT 0
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: LD_INT 4
45058: PUSH
45059: LD_INT 1
45061: NEG
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 5
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 5
45079: PUSH
45080: LD_INT 1
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: PUSH
45090: LD_INT 1
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: LD_INT 0
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: LD_INT 1
45112: NEG
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 3
45120: PUSH
45121: LD_INT 2
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 5
45131: PUSH
45132: LD_INT 2
45134: PUSH
45135: EMPTY
45136: LIST
45137: LIST
45138: PUSH
45139: LD_INT 3
45141: PUSH
45142: LD_INT 3
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 3
45151: PUSH
45152: LD_INT 2
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: LD_INT 3
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: PUSH
45172: LD_INT 4
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: LD_INT 4
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 2
45191: PUSH
45192: LD_INT 3
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 2
45201: PUSH
45202: LD_INT 2
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 4
45211: PUSH
45212: LD_INT 2
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 2
45221: PUSH
45222: LD_INT 4
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 0
45231: PUSH
45232: LD_INT 4
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 0
45241: PUSH
45242: LD_INT 3
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 1
45251: PUSH
45252: LD_INT 4
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PUSH
45259: LD_INT 1
45261: PUSH
45262: LD_INT 5
45264: PUSH
45265: EMPTY
45266: LIST
45267: LIST
45268: PUSH
45269: LD_INT 0
45271: PUSH
45272: LD_INT 5
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 1
45281: NEG
45282: PUSH
45283: LD_INT 4
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 1
45292: NEG
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 2
45303: PUSH
45304: LD_INT 5
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 2
45313: NEG
45314: PUSH
45315: LD_INT 3
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45369: LD_ADDR_VAR 0 34
45373: PUSH
45374: LD_INT 0
45376: PUSH
45377: LD_INT 4
45379: NEG
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 0
45387: PUSH
45388: LD_INT 5
45390: NEG
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 1
45398: PUSH
45399: LD_INT 4
45401: NEG
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 1
45409: PUSH
45410: LD_INT 3
45412: NEG
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PUSH
45418: LD_INT 0
45420: PUSH
45421: LD_INT 3
45423: NEG
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 1
45431: NEG
45432: PUSH
45433: LD_INT 4
45435: NEG
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: PUSH
45441: LD_INT 1
45443: NEG
45444: PUSH
45445: LD_INT 5
45447: NEG
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 2
45455: PUSH
45456: LD_INT 3
45458: NEG
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 2
45466: NEG
45467: PUSH
45468: LD_INT 5
45470: NEG
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 3
45478: PUSH
45479: LD_INT 0
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 3
45488: PUSH
45489: LD_INT 1
45491: NEG
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: PUSH
45497: LD_INT 4
45499: PUSH
45500: LD_INT 0
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 4
45509: PUSH
45510: LD_INT 1
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 3
45519: PUSH
45520: LD_INT 1
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 2
45529: PUSH
45530: LD_INT 0
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: LD_INT 2
45539: PUSH
45540: LD_INT 1
45542: NEG
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 2
45550: PUSH
45551: LD_INT 2
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 4
45561: PUSH
45562: LD_INT 2
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 4
45571: PUSH
45572: LD_INT 4
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 4
45581: PUSH
45582: LD_INT 3
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: PUSH
45589: LD_INT 5
45591: PUSH
45592: LD_INT 4
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 5
45601: PUSH
45602: LD_INT 5
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: LD_INT 5
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 3
45621: PUSH
45622: LD_INT 4
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 3
45631: PUSH
45632: LD_INT 3
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 5
45641: PUSH
45642: LD_INT 3
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 3
45651: PUSH
45652: LD_INT 5
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 0
45661: PUSH
45662: LD_INT 3
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 0
45671: PUSH
45672: LD_INT 2
45674: PUSH
45675: EMPTY
45676: LIST
45677: LIST
45678: PUSH
45679: LD_INT 1
45681: PUSH
45682: LD_INT 3
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 1
45691: PUSH
45692: LD_INT 4
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 0
45701: PUSH
45702: LD_INT 4
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 1
45711: NEG
45712: PUSH
45713: LD_INT 3
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 1
45722: NEG
45723: PUSH
45724: LD_INT 2
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 2
45733: PUSH
45734: LD_INT 4
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: PUSH
45741: LD_INT 2
45743: NEG
45744: PUSH
45745: LD_INT 2
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 4
45754: NEG
45755: PUSH
45756: LD_INT 0
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: LD_INT 4
45765: NEG
45766: PUSH
45767: LD_INT 1
45769: NEG
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 3
45777: NEG
45778: PUSH
45779: LD_INT 0
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 3
45788: NEG
45789: PUSH
45790: LD_INT 1
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 4
45799: NEG
45800: PUSH
45801: LD_INT 1
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 5
45810: NEG
45811: PUSH
45812: LD_INT 0
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PUSH
45819: LD_INT 5
45821: NEG
45822: PUSH
45823: LD_INT 1
45825: NEG
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 5
45833: NEG
45834: PUSH
45835: LD_INT 2
45837: NEG
45838: PUSH
45839: EMPTY
45840: LIST
45841: LIST
45842: PUSH
45843: LD_INT 3
45845: NEG
45846: PUSH
45847: LD_INT 2
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: ST_TO_ADDR
// end ; end ;
45901: GO 45904
45903: POP
// case btype of b_depot , b_warehouse :
45904: LD_VAR 0 1
45908: PUSH
45909: LD_INT 0
45911: DOUBLE
45912: EQUAL
45913: IFTRUE 45923
45915: LD_INT 1
45917: DOUBLE
45918: EQUAL
45919: IFTRUE 45923
45921: GO 46124
45923: POP
// case nation of nation_american :
45924: LD_VAR 0 5
45928: PUSH
45929: LD_INT 1
45931: DOUBLE
45932: EQUAL
45933: IFTRUE 45937
45935: GO 45993
45937: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45938: LD_ADDR_VAR 0 9
45942: PUSH
45943: LD_VAR 0 11
45947: PUSH
45948: LD_VAR 0 12
45952: PUSH
45953: LD_VAR 0 13
45957: PUSH
45958: LD_VAR 0 14
45962: PUSH
45963: LD_VAR 0 15
45967: PUSH
45968: LD_VAR 0 16
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: PUSH
45981: LD_VAR 0 4
45985: PUSH
45986: LD_INT 1
45988: PLUS
45989: ARRAY
45990: ST_TO_ADDR
45991: GO 46122
45993: LD_INT 2
45995: DOUBLE
45996: EQUAL
45997: IFTRUE 46001
45999: GO 46057
46001: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46002: LD_ADDR_VAR 0 9
46006: PUSH
46007: LD_VAR 0 17
46011: PUSH
46012: LD_VAR 0 18
46016: PUSH
46017: LD_VAR 0 19
46021: PUSH
46022: LD_VAR 0 20
46026: PUSH
46027: LD_VAR 0 21
46031: PUSH
46032: LD_VAR 0 22
46036: PUSH
46037: EMPTY
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: PUSH
46045: LD_VAR 0 4
46049: PUSH
46050: LD_INT 1
46052: PLUS
46053: ARRAY
46054: ST_TO_ADDR
46055: GO 46122
46057: LD_INT 3
46059: DOUBLE
46060: EQUAL
46061: IFTRUE 46065
46063: GO 46121
46065: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46066: LD_ADDR_VAR 0 9
46070: PUSH
46071: LD_VAR 0 23
46075: PUSH
46076: LD_VAR 0 24
46080: PUSH
46081: LD_VAR 0 25
46085: PUSH
46086: LD_VAR 0 26
46090: PUSH
46091: LD_VAR 0 27
46095: PUSH
46096: LD_VAR 0 28
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: LIST
46105: LIST
46106: LIST
46107: LIST
46108: PUSH
46109: LD_VAR 0 4
46113: PUSH
46114: LD_INT 1
46116: PLUS
46117: ARRAY
46118: ST_TO_ADDR
46119: GO 46122
46121: POP
46122: GO 46677
46124: LD_INT 2
46126: DOUBLE
46127: EQUAL
46128: IFTRUE 46138
46130: LD_INT 3
46132: DOUBLE
46133: EQUAL
46134: IFTRUE 46138
46136: GO 46194
46138: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46139: LD_ADDR_VAR 0 9
46143: PUSH
46144: LD_VAR 0 29
46148: PUSH
46149: LD_VAR 0 30
46153: PUSH
46154: LD_VAR 0 31
46158: PUSH
46159: LD_VAR 0 32
46163: PUSH
46164: LD_VAR 0 33
46168: PUSH
46169: LD_VAR 0 34
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: PUSH
46182: LD_VAR 0 4
46186: PUSH
46187: LD_INT 1
46189: PLUS
46190: ARRAY
46191: ST_TO_ADDR
46192: GO 46677
46194: LD_INT 16
46196: DOUBLE
46197: EQUAL
46198: IFTRUE 46256
46200: LD_INT 17
46202: DOUBLE
46203: EQUAL
46204: IFTRUE 46256
46206: LD_INT 18
46208: DOUBLE
46209: EQUAL
46210: IFTRUE 46256
46212: LD_INT 19
46214: DOUBLE
46215: EQUAL
46216: IFTRUE 46256
46218: LD_INT 22
46220: DOUBLE
46221: EQUAL
46222: IFTRUE 46256
46224: LD_INT 20
46226: DOUBLE
46227: EQUAL
46228: IFTRUE 46256
46230: LD_INT 21
46232: DOUBLE
46233: EQUAL
46234: IFTRUE 46256
46236: LD_INT 23
46238: DOUBLE
46239: EQUAL
46240: IFTRUE 46256
46242: LD_INT 24
46244: DOUBLE
46245: EQUAL
46246: IFTRUE 46256
46248: LD_INT 25
46250: DOUBLE
46251: EQUAL
46252: IFTRUE 46256
46254: GO 46312
46256: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46257: LD_ADDR_VAR 0 9
46261: PUSH
46262: LD_VAR 0 35
46266: PUSH
46267: LD_VAR 0 36
46271: PUSH
46272: LD_VAR 0 37
46276: PUSH
46277: LD_VAR 0 38
46281: PUSH
46282: LD_VAR 0 39
46286: PUSH
46287: LD_VAR 0 40
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: PUSH
46300: LD_VAR 0 4
46304: PUSH
46305: LD_INT 1
46307: PLUS
46308: ARRAY
46309: ST_TO_ADDR
46310: GO 46677
46312: LD_INT 6
46314: DOUBLE
46315: EQUAL
46316: IFTRUE 46368
46318: LD_INT 7
46320: DOUBLE
46321: EQUAL
46322: IFTRUE 46368
46324: LD_INT 8
46326: DOUBLE
46327: EQUAL
46328: IFTRUE 46368
46330: LD_INT 13
46332: DOUBLE
46333: EQUAL
46334: IFTRUE 46368
46336: LD_INT 12
46338: DOUBLE
46339: EQUAL
46340: IFTRUE 46368
46342: LD_INT 15
46344: DOUBLE
46345: EQUAL
46346: IFTRUE 46368
46348: LD_INT 11
46350: DOUBLE
46351: EQUAL
46352: IFTRUE 46368
46354: LD_INT 14
46356: DOUBLE
46357: EQUAL
46358: IFTRUE 46368
46360: LD_INT 10
46362: DOUBLE
46363: EQUAL
46364: IFTRUE 46368
46366: GO 46424
46368: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46369: LD_ADDR_VAR 0 9
46373: PUSH
46374: LD_VAR 0 41
46378: PUSH
46379: LD_VAR 0 42
46383: PUSH
46384: LD_VAR 0 43
46388: PUSH
46389: LD_VAR 0 44
46393: PUSH
46394: LD_VAR 0 45
46398: PUSH
46399: LD_VAR 0 46
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: PUSH
46412: LD_VAR 0 4
46416: PUSH
46417: LD_INT 1
46419: PLUS
46420: ARRAY
46421: ST_TO_ADDR
46422: GO 46677
46424: LD_INT 36
46426: DOUBLE
46427: EQUAL
46428: IFTRUE 46432
46430: GO 46488
46432: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46433: LD_ADDR_VAR 0 9
46437: PUSH
46438: LD_VAR 0 47
46442: PUSH
46443: LD_VAR 0 48
46447: PUSH
46448: LD_VAR 0 49
46452: PUSH
46453: LD_VAR 0 50
46457: PUSH
46458: LD_VAR 0 51
46462: PUSH
46463: LD_VAR 0 52
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: LIST
46472: LIST
46473: LIST
46474: LIST
46475: PUSH
46476: LD_VAR 0 4
46480: PUSH
46481: LD_INT 1
46483: PLUS
46484: ARRAY
46485: ST_TO_ADDR
46486: GO 46677
46488: LD_INT 4
46490: DOUBLE
46491: EQUAL
46492: IFTRUE 46514
46494: LD_INT 5
46496: DOUBLE
46497: EQUAL
46498: IFTRUE 46514
46500: LD_INT 34
46502: DOUBLE
46503: EQUAL
46504: IFTRUE 46514
46506: LD_INT 37
46508: DOUBLE
46509: EQUAL
46510: IFTRUE 46514
46512: GO 46570
46514: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46515: LD_ADDR_VAR 0 9
46519: PUSH
46520: LD_VAR 0 53
46524: PUSH
46525: LD_VAR 0 54
46529: PUSH
46530: LD_VAR 0 55
46534: PUSH
46535: LD_VAR 0 56
46539: PUSH
46540: LD_VAR 0 57
46544: PUSH
46545: LD_VAR 0 58
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: PUSH
46558: LD_VAR 0 4
46562: PUSH
46563: LD_INT 1
46565: PLUS
46566: ARRAY
46567: ST_TO_ADDR
46568: GO 46677
46570: LD_INT 31
46572: DOUBLE
46573: EQUAL
46574: IFTRUE 46620
46576: LD_INT 32
46578: DOUBLE
46579: EQUAL
46580: IFTRUE 46620
46582: LD_INT 33
46584: DOUBLE
46585: EQUAL
46586: IFTRUE 46620
46588: LD_INT 27
46590: DOUBLE
46591: EQUAL
46592: IFTRUE 46620
46594: LD_INT 26
46596: DOUBLE
46597: EQUAL
46598: IFTRUE 46620
46600: LD_INT 28
46602: DOUBLE
46603: EQUAL
46604: IFTRUE 46620
46606: LD_INT 29
46608: DOUBLE
46609: EQUAL
46610: IFTRUE 46620
46612: LD_INT 30
46614: DOUBLE
46615: EQUAL
46616: IFTRUE 46620
46618: GO 46676
46620: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46621: LD_ADDR_VAR 0 9
46625: PUSH
46626: LD_VAR 0 59
46630: PUSH
46631: LD_VAR 0 60
46635: PUSH
46636: LD_VAR 0 61
46640: PUSH
46641: LD_VAR 0 62
46645: PUSH
46646: LD_VAR 0 63
46650: PUSH
46651: LD_VAR 0 64
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: PUSH
46664: LD_VAR 0 4
46668: PUSH
46669: LD_INT 1
46671: PLUS
46672: ARRAY
46673: ST_TO_ADDR
46674: GO 46677
46676: POP
// temp_list2 = [ ] ;
46677: LD_ADDR_VAR 0 10
46681: PUSH
46682: EMPTY
46683: ST_TO_ADDR
// for i in temp_list do
46684: LD_ADDR_VAR 0 8
46688: PUSH
46689: LD_VAR 0 9
46693: PUSH
46694: FOR_IN
46695: IFFALSE 46747
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46697: LD_ADDR_VAR 0 10
46701: PUSH
46702: LD_VAR 0 10
46706: PUSH
46707: LD_VAR 0 8
46711: PUSH
46712: LD_INT 1
46714: ARRAY
46715: PUSH
46716: LD_VAR 0 2
46720: PLUS
46721: PUSH
46722: LD_VAR 0 8
46726: PUSH
46727: LD_INT 2
46729: ARRAY
46730: PUSH
46731: LD_VAR 0 3
46735: PLUS
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PUSH
46741: EMPTY
46742: LIST
46743: ADD
46744: ST_TO_ADDR
46745: GO 46694
46747: POP
46748: POP
// result = temp_list2 ;
46749: LD_ADDR_VAR 0 7
46753: PUSH
46754: LD_VAR 0 10
46758: ST_TO_ADDR
// end ;
46759: LD_VAR 0 7
46763: RET
// export function EnemyInRange ( unit , dist ) ; begin
46764: LD_INT 0
46766: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46767: LD_ADDR_VAR 0 3
46771: PUSH
46772: LD_VAR 0 1
46776: PPUSH
46777: CALL_OW 255
46781: PPUSH
46782: LD_VAR 0 1
46786: PPUSH
46787: CALL_OW 250
46791: PPUSH
46792: LD_VAR 0 1
46796: PPUSH
46797: CALL_OW 251
46801: PPUSH
46802: LD_VAR 0 2
46806: PPUSH
46807: CALL 20565 0 4
46811: PUSH
46812: LD_INT 4
46814: ARRAY
46815: ST_TO_ADDR
// end ;
46816: LD_VAR 0 3
46820: RET
// export function PlayerSeeMe ( unit ) ; begin
46821: LD_INT 0
46823: PPUSH
// result := See ( your_side , unit ) ;
46824: LD_ADDR_VAR 0 2
46828: PUSH
46829: LD_OWVAR 2
46833: PPUSH
46834: LD_VAR 0 1
46838: PPUSH
46839: CALL_OW 292
46843: ST_TO_ADDR
// end ;
46844: LD_VAR 0 2
46848: RET
// export function ReverseDir ( unit ) ; begin
46849: LD_INT 0
46851: PPUSH
// if not unit then
46852: LD_VAR 0 1
46856: NOT
46857: IFFALSE 46861
// exit ;
46859: GO 46884
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46861: LD_ADDR_VAR 0 2
46865: PUSH
46866: LD_VAR 0 1
46870: PPUSH
46871: CALL_OW 254
46875: PUSH
46876: LD_INT 3
46878: PLUS
46879: PUSH
46880: LD_INT 6
46882: MOD
46883: ST_TO_ADDR
// end ;
46884: LD_VAR 0 2
46888: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46889: LD_INT 0
46891: PPUSH
46892: PPUSH
46893: PPUSH
46894: PPUSH
46895: PPUSH
// if not hexes then
46896: LD_VAR 0 2
46900: NOT
46901: IFFALSE 46905
// exit ;
46903: GO 47053
// dist := 9999 ;
46905: LD_ADDR_VAR 0 5
46909: PUSH
46910: LD_INT 9999
46912: ST_TO_ADDR
// for i = 1 to hexes do
46913: LD_ADDR_VAR 0 4
46917: PUSH
46918: DOUBLE
46919: LD_INT 1
46921: DEC
46922: ST_TO_ADDR
46923: LD_VAR 0 2
46927: PUSH
46928: FOR_TO
46929: IFFALSE 47041
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46931: LD_VAR 0 1
46935: PPUSH
46936: LD_VAR 0 2
46940: PUSH
46941: LD_VAR 0 4
46945: ARRAY
46946: PUSH
46947: LD_INT 1
46949: ARRAY
46950: PPUSH
46951: LD_VAR 0 2
46955: PUSH
46956: LD_VAR 0 4
46960: ARRAY
46961: PUSH
46962: LD_INT 2
46964: ARRAY
46965: PPUSH
46966: CALL_OW 297
46970: PUSH
46971: LD_VAR 0 5
46975: LESS
46976: IFFALSE 47039
// begin hex := hexes [ i ] ;
46978: LD_ADDR_VAR 0 7
46982: PUSH
46983: LD_VAR 0 2
46987: PUSH
46988: LD_VAR 0 4
46992: ARRAY
46993: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46994: LD_ADDR_VAR 0 5
46998: PUSH
46999: LD_VAR 0 1
47003: PPUSH
47004: LD_VAR 0 2
47008: PUSH
47009: LD_VAR 0 4
47013: ARRAY
47014: PUSH
47015: LD_INT 1
47017: ARRAY
47018: PPUSH
47019: LD_VAR 0 2
47023: PUSH
47024: LD_VAR 0 4
47028: ARRAY
47029: PUSH
47030: LD_INT 2
47032: ARRAY
47033: PPUSH
47034: CALL_OW 297
47038: ST_TO_ADDR
// end ; end ;
47039: GO 46928
47041: POP
47042: POP
// result := hex ;
47043: LD_ADDR_VAR 0 3
47047: PUSH
47048: LD_VAR 0 7
47052: ST_TO_ADDR
// end ;
47053: LD_VAR 0 3
47057: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47058: LD_INT 0
47060: PPUSH
47061: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47062: LD_VAR 0 1
47066: NOT
47067: PUSH
47068: LD_VAR 0 1
47072: PUSH
47073: LD_INT 21
47075: PUSH
47076: LD_INT 2
47078: PUSH
47079: EMPTY
47080: LIST
47081: LIST
47082: PUSH
47083: LD_INT 23
47085: PUSH
47086: LD_INT 2
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PPUSH
47097: CALL_OW 69
47101: IN
47102: NOT
47103: OR
47104: IFFALSE 47108
// exit ;
47106: GO 47155
// for i = 1 to 3 do
47108: LD_ADDR_VAR 0 3
47112: PUSH
47113: DOUBLE
47114: LD_INT 1
47116: DEC
47117: ST_TO_ADDR
47118: LD_INT 3
47120: PUSH
47121: FOR_TO
47122: IFFALSE 47153
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47124: LD_VAR 0 1
47128: PPUSH
47129: CALL_OW 250
47133: PPUSH
47134: LD_VAR 0 1
47138: PPUSH
47139: CALL_OW 251
47143: PPUSH
47144: LD_INT 1
47146: PPUSH
47147: CALL_OW 453
47151: GO 47121
47153: POP
47154: POP
// end ;
47155: LD_VAR 0 2
47159: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47160: LD_INT 0
47162: PPUSH
47163: PPUSH
47164: PPUSH
47165: PPUSH
47166: PPUSH
47167: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47168: LD_VAR 0 1
47172: NOT
47173: PUSH
47174: LD_VAR 0 2
47178: NOT
47179: OR
47180: PUSH
47181: LD_VAR 0 1
47185: PPUSH
47186: CALL_OW 314
47190: OR
47191: IFFALSE 47195
// exit ;
47193: GO 47636
// x := GetX ( enemy_unit ) ;
47195: LD_ADDR_VAR 0 7
47199: PUSH
47200: LD_VAR 0 2
47204: PPUSH
47205: CALL_OW 250
47209: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47210: LD_ADDR_VAR 0 8
47214: PUSH
47215: LD_VAR 0 2
47219: PPUSH
47220: CALL_OW 251
47224: ST_TO_ADDR
// if not x or not y then
47225: LD_VAR 0 7
47229: NOT
47230: PUSH
47231: LD_VAR 0 8
47235: NOT
47236: OR
47237: IFFALSE 47241
// exit ;
47239: GO 47636
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47241: LD_ADDR_VAR 0 6
47245: PUSH
47246: LD_VAR 0 7
47250: PPUSH
47251: LD_INT 0
47253: PPUSH
47254: LD_INT 4
47256: PPUSH
47257: CALL_OW 272
47261: PUSH
47262: LD_VAR 0 8
47266: PPUSH
47267: LD_INT 0
47269: PPUSH
47270: LD_INT 4
47272: PPUSH
47273: CALL_OW 273
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: PUSH
47282: LD_VAR 0 7
47286: PPUSH
47287: LD_INT 1
47289: PPUSH
47290: LD_INT 4
47292: PPUSH
47293: CALL_OW 272
47297: PUSH
47298: LD_VAR 0 8
47302: PPUSH
47303: LD_INT 1
47305: PPUSH
47306: LD_INT 4
47308: PPUSH
47309: CALL_OW 273
47313: PUSH
47314: EMPTY
47315: LIST
47316: LIST
47317: PUSH
47318: LD_VAR 0 7
47322: PPUSH
47323: LD_INT 2
47325: PPUSH
47326: LD_INT 4
47328: PPUSH
47329: CALL_OW 272
47333: PUSH
47334: LD_VAR 0 8
47338: PPUSH
47339: LD_INT 2
47341: PPUSH
47342: LD_INT 4
47344: PPUSH
47345: CALL_OW 273
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: PUSH
47354: LD_VAR 0 7
47358: PPUSH
47359: LD_INT 3
47361: PPUSH
47362: LD_INT 4
47364: PPUSH
47365: CALL_OW 272
47369: PUSH
47370: LD_VAR 0 8
47374: PPUSH
47375: LD_INT 3
47377: PPUSH
47378: LD_INT 4
47380: PPUSH
47381: CALL_OW 273
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: LD_VAR 0 7
47394: PPUSH
47395: LD_INT 4
47397: PPUSH
47398: LD_INT 4
47400: PPUSH
47401: CALL_OW 272
47405: PUSH
47406: LD_VAR 0 8
47410: PPUSH
47411: LD_INT 4
47413: PPUSH
47414: LD_INT 4
47416: PPUSH
47417: CALL_OW 273
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: PUSH
47426: LD_VAR 0 7
47430: PPUSH
47431: LD_INT 5
47433: PPUSH
47434: LD_INT 4
47436: PPUSH
47437: CALL_OW 272
47441: PUSH
47442: LD_VAR 0 8
47446: PPUSH
47447: LD_INT 5
47449: PPUSH
47450: LD_INT 4
47452: PPUSH
47453: CALL_OW 273
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: ST_TO_ADDR
// for i = tmp downto 1 do
47470: LD_ADDR_VAR 0 4
47474: PUSH
47475: DOUBLE
47476: LD_VAR 0 6
47480: INC
47481: ST_TO_ADDR
47482: LD_INT 1
47484: PUSH
47485: FOR_DOWNTO
47486: IFFALSE 47587
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47488: LD_VAR 0 6
47492: PUSH
47493: LD_VAR 0 4
47497: ARRAY
47498: PUSH
47499: LD_INT 1
47501: ARRAY
47502: PPUSH
47503: LD_VAR 0 6
47507: PUSH
47508: LD_VAR 0 4
47512: ARRAY
47513: PUSH
47514: LD_INT 2
47516: ARRAY
47517: PPUSH
47518: CALL_OW 488
47522: NOT
47523: PUSH
47524: LD_VAR 0 6
47528: PUSH
47529: LD_VAR 0 4
47533: ARRAY
47534: PUSH
47535: LD_INT 1
47537: ARRAY
47538: PPUSH
47539: LD_VAR 0 6
47543: PUSH
47544: LD_VAR 0 4
47548: ARRAY
47549: PUSH
47550: LD_INT 2
47552: ARRAY
47553: PPUSH
47554: CALL_OW 428
47558: PUSH
47559: LD_INT 0
47561: NONEQUAL
47562: OR
47563: IFFALSE 47585
// tmp := Delete ( tmp , i ) ;
47565: LD_ADDR_VAR 0 6
47569: PUSH
47570: LD_VAR 0 6
47574: PPUSH
47575: LD_VAR 0 4
47579: PPUSH
47580: CALL_OW 3
47584: ST_TO_ADDR
47585: GO 47485
47587: POP
47588: POP
// j := GetClosestHex ( unit , tmp ) ;
47589: LD_ADDR_VAR 0 5
47593: PUSH
47594: LD_VAR 0 1
47598: PPUSH
47599: LD_VAR 0 6
47603: PPUSH
47604: CALL 46889 0 2
47608: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47609: LD_VAR 0 1
47613: PPUSH
47614: LD_VAR 0 5
47618: PUSH
47619: LD_INT 1
47621: ARRAY
47622: PPUSH
47623: LD_VAR 0 5
47627: PUSH
47628: LD_INT 2
47630: ARRAY
47631: PPUSH
47632: CALL_OW 111
// end ;
47636: LD_VAR 0 3
47640: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47641: LD_INT 0
47643: PPUSH
47644: PPUSH
47645: PPUSH
// uc_side = 0 ;
47646: LD_ADDR_OWVAR 20
47650: PUSH
47651: LD_INT 0
47653: ST_TO_ADDR
// uc_nation = 0 ;
47654: LD_ADDR_OWVAR 21
47658: PUSH
47659: LD_INT 0
47661: ST_TO_ADDR
// InitHc_All ( ) ;
47662: CALL_OW 584
// InitVc ;
47666: CALL_OW 20
// if mastodonts then
47670: LD_VAR 0 6
47674: IFFALSE 47741
// for i = 1 to mastodonts do
47676: LD_ADDR_VAR 0 11
47680: PUSH
47681: DOUBLE
47682: LD_INT 1
47684: DEC
47685: ST_TO_ADDR
47686: LD_VAR 0 6
47690: PUSH
47691: FOR_TO
47692: IFFALSE 47739
// begin vc_chassis := 31 ;
47694: LD_ADDR_OWVAR 37
47698: PUSH
47699: LD_INT 31
47701: ST_TO_ADDR
// vc_control := control_rider ;
47702: LD_ADDR_OWVAR 38
47706: PUSH
47707: LD_INT 4
47709: ST_TO_ADDR
// animal := CreateVehicle ;
47710: LD_ADDR_VAR 0 12
47714: PUSH
47715: CALL_OW 45
47719: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47720: LD_VAR 0 12
47724: PPUSH
47725: LD_VAR 0 8
47729: PPUSH
47730: LD_INT 0
47732: PPUSH
47733: CALL 49929 0 3
// end ;
47737: GO 47691
47739: POP
47740: POP
// if horses then
47741: LD_VAR 0 5
47745: IFFALSE 47812
// for i = 1 to horses do
47747: LD_ADDR_VAR 0 11
47751: PUSH
47752: DOUBLE
47753: LD_INT 1
47755: DEC
47756: ST_TO_ADDR
47757: LD_VAR 0 5
47761: PUSH
47762: FOR_TO
47763: IFFALSE 47810
// begin hc_class := 21 ;
47765: LD_ADDR_OWVAR 28
47769: PUSH
47770: LD_INT 21
47772: ST_TO_ADDR
// hc_gallery :=  ;
47773: LD_ADDR_OWVAR 33
47777: PUSH
47778: LD_STRING 
47780: ST_TO_ADDR
// animal := CreateHuman ;
47781: LD_ADDR_VAR 0 12
47785: PUSH
47786: CALL_OW 44
47790: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47791: LD_VAR 0 12
47795: PPUSH
47796: LD_VAR 0 8
47800: PPUSH
47801: LD_INT 0
47803: PPUSH
47804: CALL 49929 0 3
// end ;
47808: GO 47762
47810: POP
47811: POP
// if birds then
47812: LD_VAR 0 1
47816: IFFALSE 47883
// for i = 1 to birds do
47818: LD_ADDR_VAR 0 11
47822: PUSH
47823: DOUBLE
47824: LD_INT 1
47826: DEC
47827: ST_TO_ADDR
47828: LD_VAR 0 1
47832: PUSH
47833: FOR_TO
47834: IFFALSE 47881
// begin hc_class = 18 ;
47836: LD_ADDR_OWVAR 28
47840: PUSH
47841: LD_INT 18
47843: ST_TO_ADDR
// hc_gallery =  ;
47844: LD_ADDR_OWVAR 33
47848: PUSH
47849: LD_STRING 
47851: ST_TO_ADDR
// animal := CreateHuman ;
47852: LD_ADDR_VAR 0 12
47856: PUSH
47857: CALL_OW 44
47861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47862: LD_VAR 0 12
47866: PPUSH
47867: LD_VAR 0 8
47871: PPUSH
47872: LD_INT 0
47874: PPUSH
47875: CALL 49929 0 3
// end ;
47879: GO 47833
47881: POP
47882: POP
// if tigers then
47883: LD_VAR 0 2
47887: IFFALSE 47971
// for i = 1 to tigers do
47889: LD_ADDR_VAR 0 11
47893: PUSH
47894: DOUBLE
47895: LD_INT 1
47897: DEC
47898: ST_TO_ADDR
47899: LD_VAR 0 2
47903: PUSH
47904: FOR_TO
47905: IFFALSE 47969
// begin hc_class = class_tiger ;
47907: LD_ADDR_OWVAR 28
47911: PUSH
47912: LD_INT 14
47914: ST_TO_ADDR
// hc_gallery =  ;
47915: LD_ADDR_OWVAR 33
47919: PUSH
47920: LD_STRING 
47922: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47923: LD_ADDR_OWVAR 35
47927: PUSH
47928: LD_INT 7
47930: NEG
47931: PPUSH
47932: LD_INT 7
47934: PPUSH
47935: CALL_OW 12
47939: ST_TO_ADDR
// animal := CreateHuman ;
47940: LD_ADDR_VAR 0 12
47944: PUSH
47945: CALL_OW 44
47949: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47950: LD_VAR 0 12
47954: PPUSH
47955: LD_VAR 0 8
47959: PPUSH
47960: LD_INT 0
47962: PPUSH
47963: CALL 49929 0 3
// end ;
47967: GO 47904
47969: POP
47970: POP
// if apemans then
47971: LD_VAR 0 3
47975: IFFALSE 48098
// for i = 1 to apemans do
47977: LD_ADDR_VAR 0 11
47981: PUSH
47982: DOUBLE
47983: LD_INT 1
47985: DEC
47986: ST_TO_ADDR
47987: LD_VAR 0 3
47991: PUSH
47992: FOR_TO
47993: IFFALSE 48096
// begin hc_class = class_apeman ;
47995: LD_ADDR_OWVAR 28
47999: PUSH
48000: LD_INT 12
48002: ST_TO_ADDR
// hc_gallery =  ;
48003: LD_ADDR_OWVAR 33
48007: PUSH
48008: LD_STRING 
48010: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48011: LD_ADDR_OWVAR 35
48015: PUSH
48016: LD_INT 5
48018: NEG
48019: PPUSH
48020: LD_INT 5
48022: PPUSH
48023: CALL_OW 12
48027: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48028: LD_ADDR_OWVAR 31
48032: PUSH
48033: LD_INT 1
48035: PPUSH
48036: LD_INT 3
48038: PPUSH
48039: CALL_OW 12
48043: PUSH
48044: LD_INT 1
48046: PPUSH
48047: LD_INT 3
48049: PPUSH
48050: CALL_OW 12
48054: PUSH
48055: LD_INT 0
48057: PUSH
48058: LD_INT 0
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: LIST
48065: LIST
48066: ST_TO_ADDR
// animal := CreateHuman ;
48067: LD_ADDR_VAR 0 12
48071: PUSH
48072: CALL_OW 44
48076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48077: LD_VAR 0 12
48081: PPUSH
48082: LD_VAR 0 8
48086: PPUSH
48087: LD_INT 0
48089: PPUSH
48090: CALL 49929 0 3
// end ;
48094: GO 47992
48096: POP
48097: POP
// if enchidnas then
48098: LD_VAR 0 4
48102: IFFALSE 48169
// for i = 1 to enchidnas do
48104: LD_ADDR_VAR 0 11
48108: PUSH
48109: DOUBLE
48110: LD_INT 1
48112: DEC
48113: ST_TO_ADDR
48114: LD_VAR 0 4
48118: PUSH
48119: FOR_TO
48120: IFFALSE 48167
// begin hc_class = 13 ;
48122: LD_ADDR_OWVAR 28
48126: PUSH
48127: LD_INT 13
48129: ST_TO_ADDR
// hc_gallery =  ;
48130: LD_ADDR_OWVAR 33
48134: PUSH
48135: LD_STRING 
48137: ST_TO_ADDR
// animal := CreateHuman ;
48138: LD_ADDR_VAR 0 12
48142: PUSH
48143: CALL_OW 44
48147: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48148: LD_VAR 0 12
48152: PPUSH
48153: LD_VAR 0 8
48157: PPUSH
48158: LD_INT 0
48160: PPUSH
48161: CALL 49929 0 3
// end ;
48165: GO 48119
48167: POP
48168: POP
// if fishes then
48169: LD_VAR 0 7
48173: IFFALSE 48240
// for i = 1 to fishes do
48175: LD_ADDR_VAR 0 11
48179: PUSH
48180: DOUBLE
48181: LD_INT 1
48183: DEC
48184: ST_TO_ADDR
48185: LD_VAR 0 7
48189: PUSH
48190: FOR_TO
48191: IFFALSE 48238
// begin hc_class = 20 ;
48193: LD_ADDR_OWVAR 28
48197: PUSH
48198: LD_INT 20
48200: ST_TO_ADDR
// hc_gallery =  ;
48201: LD_ADDR_OWVAR 33
48205: PUSH
48206: LD_STRING 
48208: ST_TO_ADDR
// animal := CreateHuman ;
48209: LD_ADDR_VAR 0 12
48213: PUSH
48214: CALL_OW 44
48218: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48219: LD_VAR 0 12
48223: PPUSH
48224: LD_VAR 0 9
48228: PPUSH
48229: LD_INT 0
48231: PPUSH
48232: CALL 49929 0 3
// end ;
48236: GO 48190
48238: POP
48239: POP
// end ;
48240: LD_VAR 0 10
48244: RET
// export function WantHeal ( sci , unit ) ; begin
48245: LD_INT 0
48247: PPUSH
// if GetTaskList ( sci ) > 0 then
48248: LD_VAR 0 1
48252: PPUSH
48253: CALL_OW 437
48257: PUSH
48258: LD_INT 0
48260: GREATER
48261: IFFALSE 48331
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48263: LD_VAR 0 1
48267: PPUSH
48268: CALL_OW 437
48272: PUSH
48273: LD_INT 1
48275: ARRAY
48276: PUSH
48277: LD_INT 1
48279: ARRAY
48280: PUSH
48281: LD_STRING l
48283: EQUAL
48284: PUSH
48285: LD_VAR 0 1
48289: PPUSH
48290: CALL_OW 437
48294: PUSH
48295: LD_INT 1
48297: ARRAY
48298: PUSH
48299: LD_INT 4
48301: ARRAY
48302: PUSH
48303: LD_VAR 0 2
48307: EQUAL
48308: AND
48309: IFFALSE 48321
// result := true else
48311: LD_ADDR_VAR 0 3
48315: PUSH
48316: LD_INT 1
48318: ST_TO_ADDR
48319: GO 48329
// result := false ;
48321: LD_ADDR_VAR 0 3
48325: PUSH
48326: LD_INT 0
48328: ST_TO_ADDR
// end else
48329: GO 48339
// result := false ;
48331: LD_ADDR_VAR 0 3
48335: PUSH
48336: LD_INT 0
48338: ST_TO_ADDR
// end ;
48339: LD_VAR 0 3
48343: RET
// export function HealTarget ( sci ) ; begin
48344: LD_INT 0
48346: PPUSH
// if not sci then
48347: LD_VAR 0 1
48351: NOT
48352: IFFALSE 48356
// exit ;
48354: GO 48421
// result := 0 ;
48356: LD_ADDR_VAR 0 2
48360: PUSH
48361: LD_INT 0
48363: ST_TO_ADDR
// if GetTaskList ( sci ) then
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 437
48373: IFFALSE 48421
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48375: LD_VAR 0 1
48379: PPUSH
48380: CALL_OW 437
48384: PUSH
48385: LD_INT 1
48387: ARRAY
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PUSH
48393: LD_STRING l
48395: EQUAL
48396: IFFALSE 48421
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48398: LD_ADDR_VAR 0 2
48402: PUSH
48403: LD_VAR 0 1
48407: PPUSH
48408: CALL_OW 437
48412: PUSH
48413: LD_INT 1
48415: ARRAY
48416: PUSH
48417: LD_INT 4
48419: ARRAY
48420: ST_TO_ADDR
// end ;
48421: LD_VAR 0 2
48425: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48426: LD_INT 0
48428: PPUSH
48429: PPUSH
48430: PPUSH
48431: PPUSH
// if not base_units then
48432: LD_VAR 0 1
48436: NOT
48437: IFFALSE 48441
// exit ;
48439: GO 48528
// result := false ;
48441: LD_ADDR_VAR 0 2
48445: PUSH
48446: LD_INT 0
48448: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48449: LD_ADDR_VAR 0 5
48453: PUSH
48454: LD_VAR 0 1
48458: PPUSH
48459: LD_INT 21
48461: PUSH
48462: LD_INT 3
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: PPUSH
48469: CALL_OW 72
48473: ST_TO_ADDR
// if not tmp then
48474: LD_VAR 0 5
48478: NOT
48479: IFFALSE 48483
// exit ;
48481: GO 48528
// for i in tmp do
48483: LD_ADDR_VAR 0 3
48487: PUSH
48488: LD_VAR 0 5
48492: PUSH
48493: FOR_IN
48494: IFFALSE 48526
// begin result := EnemyInRange ( i , 22 ) ;
48496: LD_ADDR_VAR 0 2
48500: PUSH
48501: LD_VAR 0 3
48505: PPUSH
48506: LD_INT 22
48508: PPUSH
48509: CALL 46764 0 2
48513: ST_TO_ADDR
// if result then
48514: LD_VAR 0 2
48518: IFFALSE 48524
// exit ;
48520: POP
48521: POP
48522: GO 48528
// end ;
48524: GO 48493
48526: POP
48527: POP
// end ;
48528: LD_VAR 0 2
48532: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48533: LD_INT 0
48535: PPUSH
48536: PPUSH
// if not units then
48537: LD_VAR 0 1
48541: NOT
48542: IFFALSE 48546
// exit ;
48544: GO 48616
// result := [ ] ;
48546: LD_ADDR_VAR 0 3
48550: PUSH
48551: EMPTY
48552: ST_TO_ADDR
// for i in units do
48553: LD_ADDR_VAR 0 4
48557: PUSH
48558: LD_VAR 0 1
48562: PUSH
48563: FOR_IN
48564: IFFALSE 48614
// if GetTag ( i ) = tag then
48566: LD_VAR 0 4
48570: PPUSH
48571: CALL_OW 110
48575: PUSH
48576: LD_VAR 0 2
48580: EQUAL
48581: IFFALSE 48612
// result := Insert ( result , result + 1 , i ) ;
48583: LD_ADDR_VAR 0 3
48587: PUSH
48588: LD_VAR 0 3
48592: PPUSH
48593: LD_VAR 0 3
48597: PUSH
48598: LD_INT 1
48600: PLUS
48601: PPUSH
48602: LD_VAR 0 4
48606: PPUSH
48607: CALL_OW 2
48611: ST_TO_ADDR
48612: GO 48563
48614: POP
48615: POP
// end ;
48616: LD_VAR 0 3
48620: RET
// export function IsDriver ( un ) ; begin
48621: LD_INT 0
48623: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48624: LD_ADDR_VAR 0 2
48628: PUSH
48629: LD_VAR 0 1
48633: PUSH
48634: LD_INT 55
48636: PUSH
48637: EMPTY
48638: LIST
48639: PPUSH
48640: CALL_OW 69
48644: IN
48645: ST_TO_ADDR
// end ;
48646: LD_VAR 0 2
48650: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48651: LD_INT 0
48653: PPUSH
48654: PPUSH
// list := [ ] ;
48655: LD_ADDR_VAR 0 5
48659: PUSH
48660: EMPTY
48661: ST_TO_ADDR
// case d of 0 :
48662: LD_VAR 0 3
48666: PUSH
48667: LD_INT 0
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48808
48675: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48676: LD_ADDR_VAR 0 5
48680: PUSH
48681: LD_VAR 0 1
48685: PUSH
48686: LD_INT 4
48688: MINUS
48689: PUSH
48690: LD_VAR 0 2
48694: PUSH
48695: LD_INT 4
48697: MINUS
48698: PUSH
48699: LD_INT 2
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: LIST
48706: PUSH
48707: LD_VAR 0 1
48711: PUSH
48712: LD_INT 3
48714: MINUS
48715: PUSH
48716: LD_VAR 0 2
48720: PUSH
48721: LD_INT 1
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: LIST
48728: PUSH
48729: LD_VAR 0 1
48733: PUSH
48734: LD_INT 4
48736: PLUS
48737: PUSH
48738: LD_VAR 0 2
48742: PUSH
48743: LD_INT 4
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: LIST
48750: PUSH
48751: LD_VAR 0 1
48755: PUSH
48756: LD_INT 3
48758: PLUS
48759: PUSH
48760: LD_VAR 0 2
48764: PUSH
48765: LD_INT 3
48767: PLUS
48768: PUSH
48769: LD_INT 5
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: LIST
48776: PUSH
48777: LD_VAR 0 1
48781: PUSH
48782: LD_VAR 0 2
48786: PUSH
48787: LD_INT 4
48789: PLUS
48790: PUSH
48791: LD_INT 0
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: LIST
48798: PUSH
48799: EMPTY
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: ST_TO_ADDR
// end ; 1 :
48806: GO 49506
48808: LD_INT 1
48810: DOUBLE
48811: EQUAL
48812: IFTRUE 48816
48814: GO 48949
48816: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_VAR 0 1
48826: PUSH
48827: LD_VAR 0 2
48831: PUSH
48832: LD_INT 4
48834: MINUS
48835: PUSH
48836: LD_INT 3
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: LIST
48843: PUSH
48844: LD_VAR 0 1
48848: PUSH
48849: LD_INT 3
48851: MINUS
48852: PUSH
48853: LD_VAR 0 2
48857: PUSH
48858: LD_INT 3
48860: MINUS
48861: PUSH
48862: LD_INT 2
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: LIST
48869: PUSH
48870: LD_VAR 0 1
48874: PUSH
48875: LD_INT 4
48877: MINUS
48878: PUSH
48879: LD_VAR 0 2
48883: PUSH
48884: LD_INT 1
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: LIST
48891: PUSH
48892: LD_VAR 0 1
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 3
48904: PLUS
48905: PUSH
48906: LD_INT 0
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: LIST
48913: PUSH
48914: LD_VAR 0 1
48918: PUSH
48919: LD_INT 4
48921: PLUS
48922: PUSH
48923: LD_VAR 0 2
48927: PUSH
48928: LD_INT 4
48930: PLUS
48931: PUSH
48932: LD_INT 5
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: LIST
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: ST_TO_ADDR
// end ; 2 :
48947: GO 49506
48949: LD_INT 2
48951: DOUBLE
48952: EQUAL
48953: IFTRUE 48957
48955: GO 49086
48957: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48958: LD_ADDR_VAR 0 5
48962: PUSH
48963: LD_VAR 0 1
48967: PUSH
48968: LD_VAR 0 2
48972: PUSH
48973: LD_INT 3
48975: MINUS
48976: PUSH
48977: LD_INT 3
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: LIST
48984: PUSH
48985: LD_VAR 0 1
48989: PUSH
48990: LD_INT 4
48992: PLUS
48993: PUSH
48994: LD_VAR 0 2
48998: PUSH
48999: LD_INT 4
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: LIST
49006: PUSH
49007: LD_VAR 0 1
49011: PUSH
49012: LD_VAR 0 2
49016: PUSH
49017: LD_INT 4
49019: PLUS
49020: PUSH
49021: LD_INT 0
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: LIST
49028: PUSH
49029: LD_VAR 0 1
49033: PUSH
49034: LD_INT 3
49036: MINUS
49037: PUSH
49038: LD_VAR 0 2
49042: PUSH
49043: LD_INT 1
49045: PUSH
49046: EMPTY
49047: LIST
49048: LIST
49049: LIST
49050: PUSH
49051: LD_VAR 0 1
49055: PUSH
49056: LD_INT 4
49058: MINUS
49059: PUSH
49060: LD_VAR 0 2
49064: PUSH
49065: LD_INT 4
49067: MINUS
49068: PUSH
49069: LD_INT 2
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: LIST
49076: PUSH
49077: EMPTY
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: ST_TO_ADDR
// end ; 3 :
49084: GO 49506
49086: LD_INT 3
49088: DOUBLE
49089: EQUAL
49090: IFTRUE 49094
49092: GO 49227
49094: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49095: LD_ADDR_VAR 0 5
49099: PUSH
49100: LD_VAR 0 1
49104: PUSH
49105: LD_INT 3
49107: PLUS
49108: PUSH
49109: LD_VAR 0 2
49113: PUSH
49114: LD_INT 4
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: LIST
49121: PUSH
49122: LD_VAR 0 1
49126: PUSH
49127: LD_INT 4
49129: PLUS
49130: PUSH
49131: LD_VAR 0 2
49135: PUSH
49136: LD_INT 4
49138: PLUS
49139: PUSH
49140: LD_INT 5
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: LIST
49147: PUSH
49148: LD_VAR 0 1
49152: PUSH
49153: LD_INT 4
49155: MINUS
49156: PUSH
49157: LD_VAR 0 2
49161: PUSH
49162: LD_INT 1
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: LIST
49169: PUSH
49170: LD_VAR 0 1
49174: PUSH
49175: LD_VAR 0 2
49179: PUSH
49180: LD_INT 4
49182: MINUS
49183: PUSH
49184: LD_INT 3
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: LIST
49191: PUSH
49192: LD_VAR 0 1
49196: PUSH
49197: LD_INT 3
49199: MINUS
49200: PUSH
49201: LD_VAR 0 2
49205: PUSH
49206: LD_INT 3
49208: MINUS
49209: PUSH
49210: LD_INT 2
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: LIST
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: ST_TO_ADDR
// end ; 4 :
49225: GO 49506
49227: LD_INT 4
49229: DOUBLE
49230: EQUAL
49231: IFTRUE 49235
49233: GO 49368
49235: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49236: LD_ADDR_VAR 0 5
49240: PUSH
49241: LD_VAR 0 1
49245: PUSH
49246: LD_VAR 0 2
49250: PUSH
49251: LD_INT 4
49253: PLUS
49254: PUSH
49255: LD_INT 0
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: LIST
49262: PUSH
49263: LD_VAR 0 1
49267: PUSH
49268: LD_INT 3
49270: PLUS
49271: PUSH
49272: LD_VAR 0 2
49276: PUSH
49277: LD_INT 3
49279: PLUS
49280: PUSH
49281: LD_INT 5
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: LIST
49288: PUSH
49289: LD_VAR 0 1
49293: PUSH
49294: LD_INT 4
49296: PLUS
49297: PUSH
49298: LD_VAR 0 2
49302: PUSH
49303: LD_INT 4
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: LIST
49310: PUSH
49311: LD_VAR 0 1
49315: PUSH
49316: LD_VAR 0 2
49320: PUSH
49321: LD_INT 3
49323: MINUS
49324: PUSH
49325: LD_INT 3
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: PUSH
49333: LD_VAR 0 1
49337: PUSH
49338: LD_INT 4
49340: MINUS
49341: PUSH
49342: LD_VAR 0 2
49346: PUSH
49347: LD_INT 4
49349: MINUS
49350: PUSH
49351: LD_INT 2
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: LIST
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: ST_TO_ADDR
// end ; 5 :
49366: GO 49506
49368: LD_INT 5
49370: DOUBLE
49371: EQUAL
49372: IFTRUE 49376
49374: GO 49505
49376: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49377: LD_ADDR_VAR 0 5
49381: PUSH
49382: LD_VAR 0 1
49386: PUSH
49387: LD_INT 4
49389: MINUS
49390: PUSH
49391: LD_VAR 0 2
49395: PUSH
49396: LD_INT 1
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: LIST
49403: PUSH
49404: LD_VAR 0 1
49408: PUSH
49409: LD_VAR 0 2
49413: PUSH
49414: LD_INT 4
49416: MINUS
49417: PUSH
49418: LD_INT 3
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: LIST
49425: PUSH
49426: LD_VAR 0 1
49430: PUSH
49431: LD_INT 4
49433: PLUS
49434: PUSH
49435: LD_VAR 0 2
49439: PUSH
49440: LD_INT 4
49442: PLUS
49443: PUSH
49444: LD_INT 5
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: LIST
49451: PUSH
49452: LD_VAR 0 1
49456: PUSH
49457: LD_INT 3
49459: PLUS
49460: PUSH
49461: LD_VAR 0 2
49465: PUSH
49466: LD_INT 4
49468: PUSH
49469: EMPTY
49470: LIST
49471: LIST
49472: LIST
49473: PUSH
49474: LD_VAR 0 1
49478: PUSH
49479: LD_VAR 0 2
49483: PUSH
49484: LD_INT 3
49486: PLUS
49487: PUSH
49488: LD_INT 0
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: LIST
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: LIST
49500: LIST
49501: LIST
49502: ST_TO_ADDR
// end ; end ;
49503: GO 49506
49505: POP
// result := list ;
49506: LD_ADDR_VAR 0 4
49510: PUSH
49511: LD_VAR 0 5
49515: ST_TO_ADDR
// end ;
49516: LD_VAR 0 4
49520: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49521: LD_INT 0
49523: PPUSH
49524: PPUSH
49525: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49526: LD_VAR 0 1
49530: NOT
49531: PUSH
49532: LD_VAR 0 2
49536: PUSH
49537: LD_INT 1
49539: PUSH
49540: LD_INT 2
49542: PUSH
49543: LD_INT 3
49545: PUSH
49546: LD_INT 4
49548: PUSH
49549: EMPTY
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: IN
49555: NOT
49556: OR
49557: IFFALSE 49561
// exit ;
49559: GO 49653
// tmp := [ ] ;
49561: LD_ADDR_VAR 0 5
49565: PUSH
49566: EMPTY
49567: ST_TO_ADDR
// for i in units do
49568: LD_ADDR_VAR 0 4
49572: PUSH
49573: LD_VAR 0 1
49577: PUSH
49578: FOR_IN
49579: IFFALSE 49622
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49581: LD_ADDR_VAR 0 5
49585: PUSH
49586: LD_VAR 0 5
49590: PPUSH
49591: LD_VAR 0 5
49595: PUSH
49596: LD_INT 1
49598: PLUS
49599: PPUSH
49600: LD_VAR 0 4
49604: PPUSH
49605: LD_VAR 0 2
49609: PPUSH
49610: CALL_OW 259
49614: PPUSH
49615: CALL_OW 2
49619: ST_TO_ADDR
49620: GO 49578
49622: POP
49623: POP
// if not tmp then
49624: LD_VAR 0 5
49628: NOT
49629: IFFALSE 49633
// exit ;
49631: GO 49653
// result := SortListByListDesc ( units , tmp ) ;
49633: LD_ADDR_VAR 0 3
49637: PUSH
49638: LD_VAR 0 1
49642: PPUSH
49643: LD_VAR 0 5
49647: PPUSH
49648: CALL_OW 77
49652: ST_TO_ADDR
// end ;
49653: LD_VAR 0 3
49657: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49658: LD_INT 0
49660: PPUSH
49661: PPUSH
49662: PPUSH
// result := false ;
49663: LD_ADDR_VAR 0 3
49667: PUSH
49668: LD_INT 0
49670: ST_TO_ADDR
// x := GetX ( building ) ;
49671: LD_ADDR_VAR 0 4
49675: PUSH
49676: LD_VAR 0 2
49680: PPUSH
49681: CALL_OW 250
49685: ST_TO_ADDR
// y := GetY ( building ) ;
49686: LD_ADDR_VAR 0 5
49690: PUSH
49691: LD_VAR 0 2
49695: PPUSH
49696: CALL_OW 251
49700: ST_TO_ADDR
// if not building or not x or not y then
49701: LD_VAR 0 2
49705: NOT
49706: PUSH
49707: LD_VAR 0 4
49711: NOT
49712: OR
49713: PUSH
49714: LD_VAR 0 5
49718: NOT
49719: OR
49720: IFFALSE 49724
// exit ;
49722: GO 49816
// if GetTaskList ( unit ) then
49724: LD_VAR 0 1
49728: PPUSH
49729: CALL_OW 437
49733: IFFALSE 49816
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49735: LD_STRING e
49737: PUSH
49738: LD_VAR 0 1
49742: PPUSH
49743: CALL_OW 437
49747: PUSH
49748: LD_INT 1
49750: ARRAY
49751: PUSH
49752: LD_INT 1
49754: ARRAY
49755: EQUAL
49756: PUSH
49757: LD_VAR 0 4
49761: PUSH
49762: LD_VAR 0 1
49766: PPUSH
49767: CALL_OW 437
49771: PUSH
49772: LD_INT 1
49774: ARRAY
49775: PUSH
49776: LD_INT 2
49778: ARRAY
49779: EQUAL
49780: AND
49781: PUSH
49782: LD_VAR 0 5
49786: PUSH
49787: LD_VAR 0 1
49791: PPUSH
49792: CALL_OW 437
49796: PUSH
49797: LD_INT 1
49799: ARRAY
49800: PUSH
49801: LD_INT 3
49803: ARRAY
49804: EQUAL
49805: AND
49806: IFFALSE 49816
// result := true end ;
49808: LD_ADDR_VAR 0 3
49812: PUSH
49813: LD_INT 1
49815: ST_TO_ADDR
// end ;
49816: LD_VAR 0 3
49820: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49821: LD_INT 0
49823: PPUSH
// result := false ;
49824: LD_ADDR_VAR 0 4
49828: PUSH
49829: LD_INT 0
49831: ST_TO_ADDR
// if GetTaskList ( unit ) then
49832: LD_VAR 0 1
49836: PPUSH
49837: CALL_OW 437
49841: IFFALSE 49924
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49843: LD_STRING M
49845: PUSH
49846: LD_VAR 0 1
49850: PPUSH
49851: CALL_OW 437
49855: PUSH
49856: LD_INT 1
49858: ARRAY
49859: PUSH
49860: LD_INT 1
49862: ARRAY
49863: EQUAL
49864: PUSH
49865: LD_VAR 0 2
49869: PUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: CALL_OW 437
49879: PUSH
49880: LD_INT 1
49882: ARRAY
49883: PUSH
49884: LD_INT 2
49886: ARRAY
49887: EQUAL
49888: AND
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_VAR 0 1
49899: PPUSH
49900: CALL_OW 437
49904: PUSH
49905: LD_INT 1
49907: ARRAY
49908: PUSH
49909: LD_INT 3
49911: ARRAY
49912: EQUAL
49913: AND
49914: IFFALSE 49924
// result := true ;
49916: LD_ADDR_VAR 0 4
49920: PUSH
49921: LD_INT 1
49923: ST_TO_ADDR
// end ; end ;
49924: LD_VAR 0 4
49928: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49929: LD_INT 0
49931: PPUSH
49932: PPUSH
49933: PPUSH
49934: PPUSH
// if not unit or not area then
49935: LD_VAR 0 1
49939: NOT
49940: PUSH
49941: LD_VAR 0 2
49945: NOT
49946: OR
49947: IFFALSE 49951
// exit ;
49949: GO 50115
// tmp := AreaToList ( area , i ) ;
49951: LD_ADDR_VAR 0 6
49955: PUSH
49956: LD_VAR 0 2
49960: PPUSH
49961: LD_VAR 0 5
49965: PPUSH
49966: CALL_OW 517
49970: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49971: LD_ADDR_VAR 0 5
49975: PUSH
49976: DOUBLE
49977: LD_INT 1
49979: DEC
49980: ST_TO_ADDR
49981: LD_VAR 0 6
49985: PUSH
49986: LD_INT 1
49988: ARRAY
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50113
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49993: LD_ADDR_VAR 0 7
49997: PUSH
49998: LD_VAR 0 6
50002: PUSH
50003: LD_INT 1
50005: ARRAY
50006: PUSH
50007: LD_VAR 0 5
50011: ARRAY
50012: PUSH
50013: LD_VAR 0 6
50017: PUSH
50018: LD_INT 2
50020: ARRAY
50021: PUSH
50022: LD_VAR 0 5
50026: ARRAY
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50032: LD_VAR 0 7
50036: PUSH
50037: LD_INT 1
50039: ARRAY
50040: PPUSH
50041: LD_VAR 0 7
50045: PUSH
50046: LD_INT 2
50048: ARRAY
50049: PPUSH
50050: CALL_OW 428
50054: PUSH
50055: LD_INT 0
50057: EQUAL
50058: IFFALSE 50111
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50060: LD_VAR 0 1
50064: PPUSH
50065: LD_VAR 0 7
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PPUSH
50074: LD_VAR 0 7
50078: PUSH
50079: LD_INT 2
50081: ARRAY
50082: PPUSH
50083: LD_VAR 0 3
50087: PPUSH
50088: CALL_OW 48
// result := IsPlaced ( unit ) ;
50092: LD_ADDR_VAR 0 4
50096: PUSH
50097: LD_VAR 0 1
50101: PPUSH
50102: CALL_OW 305
50106: ST_TO_ADDR
// exit ;
50107: POP
50108: POP
50109: GO 50115
// end ; end ;
50111: GO 49990
50113: POP
50114: POP
// end ;
50115: LD_VAR 0 4
50119: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50120: LD_INT 0
50122: PPUSH
50123: PPUSH
50124: PPUSH
// if not side or side > 8 then
50125: LD_VAR 0 1
50129: NOT
50130: PUSH
50131: LD_VAR 0 1
50135: PUSH
50136: LD_INT 8
50138: GREATER
50139: OR
50140: IFFALSE 50144
// exit ;
50142: GO 50331
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50144: LD_ADDR_VAR 0 4
50148: PUSH
50149: LD_INT 22
50151: PUSH
50152: LD_VAR 0 1
50156: PUSH
50157: EMPTY
50158: LIST
50159: LIST
50160: PUSH
50161: LD_INT 21
50163: PUSH
50164: LD_INT 3
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PPUSH
50175: CALL_OW 69
50179: ST_TO_ADDR
// if not tmp then
50180: LD_VAR 0 4
50184: NOT
50185: IFFALSE 50189
// exit ;
50187: GO 50331
// enable_addtolog := true ;
50189: LD_ADDR_OWVAR 81
50193: PUSH
50194: LD_INT 1
50196: ST_TO_ADDR
// AddToLog ( [ ) ;
50197: LD_STRING [
50199: PPUSH
50200: CALL_OW 561
// for i in tmp do
50204: LD_ADDR_VAR 0 3
50208: PUSH
50209: LD_VAR 0 4
50213: PUSH
50214: FOR_IN
50215: IFFALSE 50322
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50217: LD_STRING [
50219: PUSH
50220: LD_VAR 0 3
50224: PPUSH
50225: CALL_OW 266
50229: STR
50230: PUSH
50231: LD_STRING , 
50233: STR
50234: PUSH
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 250
50244: STR
50245: PUSH
50246: LD_STRING , 
50248: STR
50249: PUSH
50250: LD_VAR 0 3
50254: PPUSH
50255: CALL_OW 251
50259: STR
50260: PUSH
50261: LD_STRING , 
50263: STR
50264: PUSH
50265: LD_VAR 0 3
50269: PPUSH
50270: CALL_OW 254
50274: STR
50275: PUSH
50276: LD_STRING , 
50278: STR
50279: PUSH
50280: LD_VAR 0 3
50284: PPUSH
50285: LD_INT 1
50287: PPUSH
50288: CALL_OW 268
50292: STR
50293: PUSH
50294: LD_STRING , 
50296: STR
50297: PUSH
50298: LD_VAR 0 3
50302: PPUSH
50303: LD_INT 2
50305: PPUSH
50306: CALL_OW 268
50310: STR
50311: PUSH
50312: LD_STRING ],
50314: STR
50315: PPUSH
50316: CALL_OW 561
// end ;
50320: GO 50214
50322: POP
50323: POP
// AddToLog ( ]; ) ;
50324: LD_STRING ];
50326: PPUSH
50327: CALL_OW 561
// end ;
50331: LD_VAR 0 2
50335: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50336: LD_INT 0
50338: PPUSH
50339: PPUSH
50340: PPUSH
50341: PPUSH
50342: PPUSH
// if not area or not rate or not max then
50343: LD_VAR 0 1
50347: NOT
50348: PUSH
50349: LD_VAR 0 2
50353: NOT
50354: OR
50355: PUSH
50356: LD_VAR 0 4
50360: NOT
50361: OR
50362: IFFALSE 50366
// exit ;
50364: GO 50558
// while 1 do
50366: LD_INT 1
50368: IFFALSE 50558
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50370: LD_ADDR_VAR 0 9
50374: PUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: LD_INT 1
50382: PPUSH
50383: CALL_OW 287
50387: PUSH
50388: LD_INT 10
50390: MUL
50391: ST_TO_ADDR
// r := rate / 10 ;
50392: LD_ADDR_VAR 0 7
50396: PUSH
50397: LD_VAR 0 2
50401: PUSH
50402: LD_INT 10
50404: DIVREAL
50405: ST_TO_ADDR
// time := 1 1$00 ;
50406: LD_ADDR_VAR 0 8
50410: PUSH
50411: LD_INT 2100
50413: ST_TO_ADDR
// if amount < min then
50414: LD_VAR 0 9
50418: PUSH
50419: LD_VAR 0 3
50423: LESS
50424: IFFALSE 50442
// r := r * 2 else
50426: LD_ADDR_VAR 0 7
50430: PUSH
50431: LD_VAR 0 7
50435: PUSH
50436: LD_INT 2
50438: MUL
50439: ST_TO_ADDR
50440: GO 50468
// if amount > max then
50442: LD_VAR 0 9
50446: PUSH
50447: LD_VAR 0 4
50451: GREATER
50452: IFFALSE 50468
// r := r / 2 ;
50454: LD_ADDR_VAR 0 7
50458: PUSH
50459: LD_VAR 0 7
50463: PUSH
50464: LD_INT 2
50466: DIVREAL
50467: ST_TO_ADDR
// time := time / r ;
50468: LD_ADDR_VAR 0 8
50472: PUSH
50473: LD_VAR 0 8
50477: PUSH
50478: LD_VAR 0 7
50482: DIVREAL
50483: ST_TO_ADDR
// if time < 0 then
50484: LD_VAR 0 8
50488: PUSH
50489: LD_INT 0
50491: LESS
50492: IFFALSE 50509
// time := time * - 1 ;
50494: LD_ADDR_VAR 0 8
50498: PUSH
50499: LD_VAR 0 8
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: MUL
50508: ST_TO_ADDR
// wait ( time ) ;
50509: LD_VAR 0 8
50513: PPUSH
50514: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50518: LD_INT 35
50520: PPUSH
50521: LD_INT 875
50523: PPUSH
50524: CALL_OW 12
50528: PPUSH
50529: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50533: LD_INT 1
50535: PPUSH
50536: LD_INT 5
50538: PPUSH
50539: CALL_OW 12
50543: PPUSH
50544: LD_VAR 0 1
50548: PPUSH
50549: LD_INT 1
50551: PPUSH
50552: CALL_OW 55
// end ;
50556: GO 50366
// end ;
50558: LD_VAR 0 5
50562: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50563: LD_INT 0
50565: PPUSH
50566: PPUSH
50567: PPUSH
50568: PPUSH
50569: PPUSH
50570: PPUSH
50571: PPUSH
50572: PPUSH
// if not turrets or not factories then
50573: LD_VAR 0 1
50577: NOT
50578: PUSH
50579: LD_VAR 0 2
50583: NOT
50584: OR
50585: IFFALSE 50589
// exit ;
50587: GO 50896
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50589: LD_ADDR_VAR 0 10
50593: PUSH
50594: LD_INT 5
50596: PUSH
50597: LD_INT 6
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PUSH
50604: LD_INT 2
50606: PUSH
50607: LD_INT 4
50609: PUSH
50610: EMPTY
50611: LIST
50612: LIST
50613: PUSH
50614: LD_INT 3
50616: PUSH
50617: LD_INT 5
50619: PUSH
50620: EMPTY
50621: LIST
50622: LIST
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: LIST
50628: PUSH
50629: LD_INT 24
50631: PUSH
50632: LD_INT 25
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: LD_INT 23
50641: PUSH
50642: LD_INT 27
50644: PUSH
50645: EMPTY
50646: LIST
50647: LIST
50648: PUSH
50649: EMPTY
50650: LIST
50651: LIST
50652: PUSH
50653: LD_INT 42
50655: PUSH
50656: LD_INT 43
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: LD_INT 44
50665: PUSH
50666: LD_INT 46
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PUSH
50673: LD_INT 45
50675: PUSH
50676: LD_INT 47
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: LIST
50687: PUSH
50688: EMPTY
50689: LIST
50690: LIST
50691: LIST
50692: ST_TO_ADDR
// result := [ ] ;
50693: LD_ADDR_VAR 0 3
50697: PUSH
50698: EMPTY
50699: ST_TO_ADDR
// for i in turrets do
50700: LD_ADDR_VAR 0 4
50704: PUSH
50705: LD_VAR 0 1
50709: PUSH
50710: FOR_IN
50711: IFFALSE 50894
// begin nat := GetNation ( i ) ;
50713: LD_ADDR_VAR 0 7
50717: PUSH
50718: LD_VAR 0 4
50722: PPUSH
50723: CALL_OW 248
50727: ST_TO_ADDR
// weapon := 0 ;
50728: LD_ADDR_VAR 0 8
50732: PUSH
50733: LD_INT 0
50735: ST_TO_ADDR
// if not nat then
50736: LD_VAR 0 7
50740: NOT
50741: IFFALSE 50745
// continue ;
50743: GO 50710
// for j in list [ nat ] do
50745: LD_ADDR_VAR 0 5
50749: PUSH
50750: LD_VAR 0 10
50754: PUSH
50755: LD_VAR 0 7
50759: ARRAY
50760: PUSH
50761: FOR_IN
50762: IFFALSE 50803
// if GetBWeapon ( i ) = j [ 1 ] then
50764: LD_VAR 0 4
50768: PPUSH
50769: CALL_OW 269
50773: PUSH
50774: LD_VAR 0 5
50778: PUSH
50779: LD_INT 1
50781: ARRAY
50782: EQUAL
50783: IFFALSE 50801
// begin weapon := j [ 2 ] ;
50785: LD_ADDR_VAR 0 8
50789: PUSH
50790: LD_VAR 0 5
50794: PUSH
50795: LD_INT 2
50797: ARRAY
50798: ST_TO_ADDR
// break ;
50799: GO 50803
// end ;
50801: GO 50761
50803: POP
50804: POP
// if not weapon then
50805: LD_VAR 0 8
50809: NOT
50810: IFFALSE 50814
// continue ;
50812: GO 50710
// for k in factories do
50814: LD_ADDR_VAR 0 6
50818: PUSH
50819: LD_VAR 0 2
50823: PUSH
50824: FOR_IN
50825: IFFALSE 50890
// begin weapons := AvailableWeaponList ( k ) ;
50827: LD_ADDR_VAR 0 9
50831: PUSH
50832: LD_VAR 0 6
50836: PPUSH
50837: CALL_OW 478
50841: ST_TO_ADDR
// if not weapons then
50842: LD_VAR 0 9
50846: NOT
50847: IFFALSE 50851
// continue ;
50849: GO 50824
// if weapon in weapons then
50851: LD_VAR 0 8
50855: PUSH
50856: LD_VAR 0 9
50860: IN
50861: IFFALSE 50888
// begin result := [ i , weapon ] ;
50863: LD_ADDR_VAR 0 3
50867: PUSH
50868: LD_VAR 0 4
50872: PUSH
50873: LD_VAR 0 8
50877: PUSH
50878: EMPTY
50879: LIST
50880: LIST
50881: ST_TO_ADDR
// exit ;
50882: POP
50883: POP
50884: POP
50885: POP
50886: GO 50896
// end ; end ;
50888: GO 50824
50890: POP
50891: POP
// end ;
50892: GO 50710
50894: POP
50895: POP
// end ;
50896: LD_VAR 0 3
50900: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50901: LD_INT 0
50903: PPUSH
// if not side or side > 8 then
50904: LD_VAR 0 3
50908: NOT
50909: PUSH
50910: LD_VAR 0 3
50914: PUSH
50915: LD_INT 8
50917: GREATER
50918: OR
50919: IFFALSE 50923
// exit ;
50921: GO 50982
// if not range then
50923: LD_VAR 0 4
50927: NOT
50928: IFFALSE 50939
// range := - 12 ;
50930: LD_ADDR_VAR 0 4
50934: PUSH
50935: LD_INT 12
50937: NEG
50938: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50939: LD_VAR 0 1
50943: PPUSH
50944: LD_VAR 0 2
50948: PPUSH
50949: LD_VAR 0 3
50953: PPUSH
50954: LD_VAR 0 4
50958: PPUSH
50959: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50963: LD_VAR 0 1
50967: PPUSH
50968: LD_VAR 0 2
50972: PPUSH
50973: LD_VAR 0 3
50977: PPUSH
50978: CALL_OW 331
// end ;
50982: LD_VAR 0 5
50986: RET
// export function Video ( mode ) ; begin
50987: LD_INT 0
50989: PPUSH
// ingame_video = mode ;
50990: LD_ADDR_OWVAR 52
50994: PUSH
50995: LD_VAR 0 1
50999: ST_TO_ADDR
// interface_hidden = mode ;
51000: LD_ADDR_OWVAR 54
51004: PUSH
51005: LD_VAR 0 1
51009: ST_TO_ADDR
// end ;
51010: LD_VAR 0 2
51014: RET
// export function Join ( array , element ) ; begin
51015: LD_INT 0
51017: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51018: LD_ADDR_VAR 0 3
51022: PUSH
51023: LD_VAR 0 1
51027: PPUSH
51028: LD_VAR 0 1
51032: PUSH
51033: LD_INT 1
51035: PLUS
51036: PPUSH
51037: LD_VAR 0 2
51041: PPUSH
51042: CALL_OW 1
51046: ST_TO_ADDR
// end ;
51047: LD_VAR 0 3
51051: RET
// export function JoinUnion ( array , element ) ; begin
51052: LD_INT 0
51054: PPUSH
// result := array union element ;
51055: LD_ADDR_VAR 0 3
51059: PUSH
51060: LD_VAR 0 1
51064: PUSH
51065: LD_VAR 0 2
51069: UNION
51070: ST_TO_ADDR
// end ;
51071: LD_VAR 0 3
51075: RET
// export function GetBehemoths ( side ) ; begin
51076: LD_INT 0
51078: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51079: LD_ADDR_VAR 0 2
51083: PUSH
51084: LD_INT 22
51086: PUSH
51087: LD_VAR 0 1
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PUSH
51096: LD_INT 31
51098: PUSH
51099: LD_INT 25
51101: PUSH
51102: EMPTY
51103: LIST
51104: LIST
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: PPUSH
51110: CALL_OW 69
51114: ST_TO_ADDR
// end ;
51115: LD_VAR 0 2
51119: RET
// export function Shuffle ( array ) ; var i , index ; begin
51120: LD_INT 0
51122: PPUSH
51123: PPUSH
51124: PPUSH
// result := [ ] ;
51125: LD_ADDR_VAR 0 2
51129: PUSH
51130: EMPTY
51131: ST_TO_ADDR
// if not array then
51132: LD_VAR 0 1
51136: NOT
51137: IFFALSE 51141
// exit ;
51139: GO 51240
// Randomize ;
51141: CALL_OW 10
// for i = array downto 1 do
51145: LD_ADDR_VAR 0 3
51149: PUSH
51150: DOUBLE
51151: LD_VAR 0 1
51155: INC
51156: ST_TO_ADDR
51157: LD_INT 1
51159: PUSH
51160: FOR_DOWNTO
51161: IFFALSE 51238
// begin index := rand ( 1 , array ) ;
51163: LD_ADDR_VAR 0 4
51167: PUSH
51168: LD_INT 1
51170: PPUSH
51171: LD_VAR 0 1
51175: PPUSH
51176: CALL_OW 12
51180: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51181: LD_ADDR_VAR 0 2
51185: PUSH
51186: LD_VAR 0 2
51190: PPUSH
51191: LD_VAR 0 2
51195: PUSH
51196: LD_INT 1
51198: PLUS
51199: PPUSH
51200: LD_VAR 0 1
51204: PUSH
51205: LD_VAR 0 4
51209: ARRAY
51210: PPUSH
51211: CALL_OW 2
51215: ST_TO_ADDR
// array := Delete ( array , index ) ;
51216: LD_ADDR_VAR 0 1
51220: PUSH
51221: LD_VAR 0 1
51225: PPUSH
51226: LD_VAR 0 4
51230: PPUSH
51231: CALL_OW 3
51235: ST_TO_ADDR
// end ;
51236: GO 51160
51238: POP
51239: POP
// end ;
51240: LD_VAR 0 2
51244: RET
// export function GetBaseMaterials ( base ) ; begin
51245: LD_INT 0
51247: PPUSH
// result := [ 0 , 0 , 0 ] ;
51248: LD_ADDR_VAR 0 2
51252: PUSH
51253: LD_INT 0
51255: PUSH
51256: LD_INT 0
51258: PUSH
51259: LD_INT 0
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: LIST
51266: ST_TO_ADDR
// if not base then
51267: LD_VAR 0 1
51271: NOT
51272: IFFALSE 51276
// exit ;
51274: GO 51325
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51276: LD_ADDR_VAR 0 2
51280: PUSH
51281: LD_VAR 0 1
51285: PPUSH
51286: LD_INT 1
51288: PPUSH
51289: CALL_OW 275
51293: PUSH
51294: LD_VAR 0 1
51298: PPUSH
51299: LD_INT 2
51301: PPUSH
51302: CALL_OW 275
51306: PUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: LD_INT 3
51314: PPUSH
51315: CALL_OW 275
51319: PUSH
51320: EMPTY
51321: LIST
51322: LIST
51323: LIST
51324: ST_TO_ADDR
// end ;
51325: LD_VAR 0 2
51329: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51330: LD_INT 0
51332: PPUSH
51333: PPUSH
// result := array ;
51334: LD_ADDR_VAR 0 3
51338: PUSH
51339: LD_VAR 0 1
51343: ST_TO_ADDR
// if size > 0 then
51344: LD_VAR 0 2
51348: PUSH
51349: LD_INT 0
51351: GREATER
51352: IFFALSE 51398
// for i := array downto size do
51354: LD_ADDR_VAR 0 4
51358: PUSH
51359: DOUBLE
51360: LD_VAR 0 1
51364: INC
51365: ST_TO_ADDR
51366: LD_VAR 0 2
51370: PUSH
51371: FOR_DOWNTO
51372: IFFALSE 51396
// result := Delete ( result , result ) ;
51374: LD_ADDR_VAR 0 3
51378: PUSH
51379: LD_VAR 0 3
51383: PPUSH
51384: LD_VAR 0 3
51388: PPUSH
51389: CALL_OW 3
51393: ST_TO_ADDR
51394: GO 51371
51396: POP
51397: POP
// end ;
51398: LD_VAR 0 3
51402: RET
// export function ComExit ( unit ) ; var tmp ; begin
51403: LD_INT 0
51405: PPUSH
51406: PPUSH
// if not IsInUnit ( unit ) then
51407: LD_VAR 0 1
51411: PPUSH
51412: CALL_OW 310
51416: NOT
51417: IFFALSE 51421
// exit ;
51419: GO 51481
// tmp := IsInUnit ( unit ) ;
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_VAR 0 1
51430: PPUSH
51431: CALL_OW 310
51435: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51436: LD_VAR 0 3
51440: PPUSH
51441: CALL_OW 247
51445: PUSH
51446: LD_INT 2
51448: EQUAL
51449: IFFALSE 51462
// ComExitVehicle ( unit ) else
51451: LD_VAR 0 1
51455: PPUSH
51456: CALL_OW 121
51460: GO 51471
// ComExitBuilding ( unit ) ;
51462: LD_VAR 0 1
51466: PPUSH
51467: CALL_OW 122
// result := tmp ;
51471: LD_ADDR_VAR 0 2
51475: PUSH
51476: LD_VAR 0 3
51480: ST_TO_ADDR
// end ;
51481: LD_VAR 0 2
51485: RET
// export function ComExitAll ( units ) ; var i ; begin
51486: LD_INT 0
51488: PPUSH
51489: PPUSH
// if not units then
51490: LD_VAR 0 1
51494: NOT
51495: IFFALSE 51499
// exit ;
51497: GO 51525
// for i in units do
51499: LD_ADDR_VAR 0 3
51503: PUSH
51504: LD_VAR 0 1
51508: PUSH
51509: FOR_IN
51510: IFFALSE 51523
// ComExit ( i ) ;
51512: LD_VAR 0 3
51516: PPUSH
51517: CALL 51403 0 1
51521: GO 51509
51523: POP
51524: POP
// end ;
51525: LD_VAR 0 2
51529: RET
// export function ResetHc ; begin
51530: LD_INT 0
51532: PPUSH
// InitHc ;
51533: CALL_OW 19
// hc_importance := 0 ;
51537: LD_ADDR_OWVAR 32
51541: PUSH
51542: LD_INT 0
51544: ST_TO_ADDR
// end ;
51545: LD_VAR 0 1
51549: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51550: LD_INT 0
51552: PPUSH
51553: PPUSH
51554: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51555: LD_ADDR_VAR 0 6
51559: PUSH
51560: LD_VAR 0 1
51564: PUSH
51565: LD_VAR 0 3
51569: PLUS
51570: PUSH
51571: LD_INT 2
51573: DIV
51574: ST_TO_ADDR
// if _x < 0 then
51575: LD_VAR 0 6
51579: PUSH
51580: LD_INT 0
51582: LESS
51583: IFFALSE 51600
// _x := _x * - 1 ;
51585: LD_ADDR_VAR 0 6
51589: PUSH
51590: LD_VAR 0 6
51594: PUSH
51595: LD_INT 1
51597: NEG
51598: MUL
51599: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51600: LD_ADDR_VAR 0 7
51604: PUSH
51605: LD_VAR 0 2
51609: PUSH
51610: LD_VAR 0 4
51614: PLUS
51615: PUSH
51616: LD_INT 2
51618: DIV
51619: ST_TO_ADDR
// if _y < 0 then
51620: LD_VAR 0 7
51624: PUSH
51625: LD_INT 0
51627: LESS
51628: IFFALSE 51645
// _y := _y * - 1 ;
51630: LD_ADDR_VAR 0 7
51634: PUSH
51635: LD_VAR 0 7
51639: PUSH
51640: LD_INT 1
51642: NEG
51643: MUL
51644: ST_TO_ADDR
// result := [ _x , _y ] ;
51645: LD_ADDR_VAR 0 5
51649: PUSH
51650: LD_VAR 0 6
51654: PUSH
51655: LD_VAR 0 7
51659: PUSH
51660: EMPTY
51661: LIST
51662: LIST
51663: ST_TO_ADDR
// end ;
51664: LD_VAR 0 5
51668: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51669: LD_INT 0
51671: PPUSH
51672: PPUSH
51673: PPUSH
51674: PPUSH
// task := GetTaskList ( unit ) ;
51675: LD_ADDR_VAR 0 7
51679: PUSH
51680: LD_VAR 0 1
51684: PPUSH
51685: CALL_OW 437
51689: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51690: LD_VAR 0 7
51694: NOT
51695: PUSH
51696: LD_VAR 0 1
51700: PPUSH
51701: LD_VAR 0 2
51705: PPUSH
51706: CALL_OW 308
51710: NOT
51711: AND
51712: IFFALSE 51716
// exit ;
51714: GO 51834
// if IsInArea ( unit , area ) then
51716: LD_VAR 0 1
51720: PPUSH
51721: LD_VAR 0 2
51725: PPUSH
51726: CALL_OW 308
51730: IFFALSE 51748
// begin ComMoveToArea ( unit , goAway ) ;
51732: LD_VAR 0 1
51736: PPUSH
51737: LD_VAR 0 3
51741: PPUSH
51742: CALL_OW 113
// exit ;
51746: GO 51834
// end ; if task [ 1 ] [ 1 ] <> M then
51748: LD_VAR 0 7
51752: PUSH
51753: LD_INT 1
51755: ARRAY
51756: PUSH
51757: LD_INT 1
51759: ARRAY
51760: PUSH
51761: LD_STRING M
51763: NONEQUAL
51764: IFFALSE 51768
// exit ;
51766: GO 51834
// x := task [ 1 ] [ 2 ] ;
51768: LD_ADDR_VAR 0 5
51772: PUSH
51773: LD_VAR 0 7
51777: PUSH
51778: LD_INT 1
51780: ARRAY
51781: PUSH
51782: LD_INT 2
51784: ARRAY
51785: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51786: LD_ADDR_VAR 0 6
51790: PUSH
51791: LD_VAR 0 7
51795: PUSH
51796: LD_INT 1
51798: ARRAY
51799: PUSH
51800: LD_INT 3
51802: ARRAY
51803: ST_TO_ADDR
// if InArea ( x , y , area ) then
51804: LD_VAR 0 5
51808: PPUSH
51809: LD_VAR 0 6
51813: PPUSH
51814: LD_VAR 0 2
51818: PPUSH
51819: CALL_OW 309
51823: IFFALSE 51834
// ComStop ( unit ) ;
51825: LD_VAR 0 1
51829: PPUSH
51830: CALL_OW 141
// end ;
51834: LD_VAR 0 4
51838: RET
// export function Abs ( value ) ; begin
51839: LD_INT 0
51841: PPUSH
// result := value ;
51842: LD_ADDR_VAR 0 2
51846: PUSH
51847: LD_VAR 0 1
51851: ST_TO_ADDR
// if value < 0 then
51852: LD_VAR 0 1
51856: PUSH
51857: LD_INT 0
51859: LESS
51860: IFFALSE 51877
// result := value * - 1 ;
51862: LD_ADDR_VAR 0 2
51866: PUSH
51867: LD_VAR 0 1
51871: PUSH
51872: LD_INT 1
51874: NEG
51875: MUL
51876: ST_TO_ADDR
// end ;
51877: LD_VAR 0 2
51881: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51882: LD_INT 0
51884: PPUSH
51885: PPUSH
51886: PPUSH
51887: PPUSH
51888: PPUSH
51889: PPUSH
51890: PPUSH
51891: PPUSH
// if not unit or not building then
51892: LD_VAR 0 1
51896: NOT
51897: PUSH
51898: LD_VAR 0 2
51902: NOT
51903: OR
51904: IFFALSE 51908
// exit ;
51906: GO 52134
// x := GetX ( building ) ;
51908: LD_ADDR_VAR 0 4
51912: PUSH
51913: LD_VAR 0 2
51917: PPUSH
51918: CALL_OW 250
51922: ST_TO_ADDR
// y := GetY ( building ) ;
51923: LD_ADDR_VAR 0 6
51927: PUSH
51928: LD_VAR 0 2
51932: PPUSH
51933: CALL_OW 251
51937: ST_TO_ADDR
// d := GetDir ( building ) ;
51938: LD_ADDR_VAR 0 8
51942: PUSH
51943: LD_VAR 0 2
51947: PPUSH
51948: CALL_OW 254
51952: ST_TO_ADDR
// r := 4 ;
51953: LD_ADDR_VAR 0 9
51957: PUSH
51958: LD_INT 4
51960: ST_TO_ADDR
// for i := 1 to 5 do
51961: LD_ADDR_VAR 0 10
51965: PUSH
51966: DOUBLE
51967: LD_INT 1
51969: DEC
51970: ST_TO_ADDR
51971: LD_INT 5
51973: PUSH
51974: FOR_TO
51975: IFFALSE 52132
// begin _x := ShiftX ( x , d , r + i ) ;
51977: LD_ADDR_VAR 0 5
51981: PUSH
51982: LD_VAR 0 4
51986: PPUSH
51987: LD_VAR 0 8
51991: PPUSH
51992: LD_VAR 0 9
51996: PUSH
51997: LD_VAR 0 10
52001: PLUS
52002: PPUSH
52003: CALL_OW 272
52007: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52008: LD_ADDR_VAR 0 7
52012: PUSH
52013: LD_VAR 0 6
52017: PPUSH
52018: LD_VAR 0 8
52022: PPUSH
52023: LD_VAR 0 9
52027: PUSH
52028: LD_VAR 0 10
52032: PLUS
52033: PPUSH
52034: CALL_OW 273
52038: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52039: LD_VAR 0 5
52043: PPUSH
52044: LD_VAR 0 7
52048: PPUSH
52049: CALL_OW 488
52053: PUSH
52054: LD_VAR 0 5
52058: PPUSH
52059: LD_VAR 0 7
52063: PPUSH
52064: CALL_OW 428
52068: PPUSH
52069: CALL_OW 247
52073: PUSH
52074: LD_INT 3
52076: PUSH
52077: LD_INT 2
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: IN
52084: NOT
52085: AND
52086: IFFALSE 52130
// begin ComMoveXY ( unit , _x , _y ) ;
52088: LD_VAR 0 1
52092: PPUSH
52093: LD_VAR 0 5
52097: PPUSH
52098: LD_VAR 0 7
52102: PPUSH
52103: CALL_OW 111
// result := [ _x , _y ] ;
52107: LD_ADDR_VAR 0 3
52111: PUSH
52112: LD_VAR 0 5
52116: PUSH
52117: LD_VAR 0 7
52121: PUSH
52122: EMPTY
52123: LIST
52124: LIST
52125: ST_TO_ADDR
// exit ;
52126: POP
52127: POP
52128: GO 52134
// end ; end ;
52130: GO 51974
52132: POP
52133: POP
// end ;
52134: LD_VAR 0 3
52138: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52139: LD_INT 0
52141: PPUSH
52142: PPUSH
52143: PPUSH
// result := 0 ;
52144: LD_ADDR_VAR 0 3
52148: PUSH
52149: LD_INT 0
52151: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52152: LD_VAR 0 1
52156: PUSH
52157: LD_INT 0
52159: LESS
52160: PUSH
52161: LD_VAR 0 1
52165: PUSH
52166: LD_INT 8
52168: GREATER
52169: OR
52170: PUSH
52171: LD_VAR 0 2
52175: PUSH
52176: LD_INT 0
52178: LESS
52179: OR
52180: PUSH
52181: LD_VAR 0 2
52185: PUSH
52186: LD_INT 8
52188: GREATER
52189: OR
52190: IFFALSE 52194
// exit ;
52192: GO 52269
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52194: LD_ADDR_VAR 0 4
52198: PUSH
52199: LD_INT 22
52201: PUSH
52202: LD_VAR 0 2
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: PPUSH
52211: CALL_OW 69
52215: PUSH
52216: FOR_IN
52217: IFFALSE 52267
// begin un := UnitShoot ( i ) ;
52219: LD_ADDR_VAR 0 5
52223: PUSH
52224: LD_VAR 0 4
52228: PPUSH
52229: CALL_OW 504
52233: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52234: LD_VAR 0 5
52238: PPUSH
52239: CALL_OW 255
52243: PUSH
52244: LD_VAR 0 1
52248: EQUAL
52249: IFFALSE 52265
// begin result := un ;
52251: LD_ADDR_VAR 0 3
52255: PUSH
52256: LD_VAR 0 5
52260: ST_TO_ADDR
// exit ;
52261: POP
52262: POP
52263: GO 52269
// end ; end ;
52265: GO 52216
52267: POP
52268: POP
// end ;
52269: LD_VAR 0 3
52273: RET
// export function GetCargoBay ( units ) ; begin
52274: LD_INT 0
52276: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52277: LD_ADDR_VAR 0 2
52281: PUSH
52282: LD_VAR 0 1
52286: PPUSH
52287: LD_INT 2
52289: PUSH
52290: LD_INT 34
52292: PUSH
52293: LD_INT 12
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_INT 34
52302: PUSH
52303: LD_INT 51
52305: PUSH
52306: EMPTY
52307: LIST
52308: LIST
52309: PUSH
52310: LD_INT 34
52312: PUSH
52313: LD_INT 32
52315: PUSH
52316: EMPTY
52317: LIST
52318: LIST
52319: PUSH
52320: LD_INT 34
52322: PUSH
52323: LD_EXP 104
52327: PUSH
52328: EMPTY
52329: LIST
52330: LIST
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: PPUSH
52339: CALL_OW 72
52343: ST_TO_ADDR
// end ; end_of_file
52344: LD_VAR 0 2
52348: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52349: LD_INT 0
52351: PPUSH
52352: PPUSH
// skirmish := false ;
52353: LD_ADDR_EXP 57
52357: PUSH
52358: LD_INT 0
52360: ST_TO_ADDR
// debug_mc := false ;
52361: LD_ADDR_EXP 58
52365: PUSH
52366: LD_INT 0
52368: ST_TO_ADDR
// mc_bases := [ ] ;
52369: LD_ADDR_EXP 59
52373: PUSH
52374: EMPTY
52375: ST_TO_ADDR
// mc_sides := [ ] ;
52376: LD_ADDR_EXP 85
52380: PUSH
52381: EMPTY
52382: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52383: LD_ADDR_EXP 60
52387: PUSH
52388: EMPTY
52389: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52390: LD_ADDR_EXP 61
52394: PUSH
52395: EMPTY
52396: ST_TO_ADDR
// mc_need_heal := [ ] ;
52397: LD_ADDR_EXP 62
52401: PUSH
52402: EMPTY
52403: ST_TO_ADDR
// mc_healers := [ ] ;
52404: LD_ADDR_EXP 63
52408: PUSH
52409: EMPTY
52410: ST_TO_ADDR
// mc_build_list := [ ] ;
52411: LD_ADDR_EXP 64
52415: PUSH
52416: EMPTY
52417: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52418: LD_ADDR_EXP 91
52422: PUSH
52423: EMPTY
52424: ST_TO_ADDR
// mc_builders := [ ] ;
52425: LD_ADDR_EXP 65
52429: PUSH
52430: EMPTY
52431: ST_TO_ADDR
// mc_construct_list := [ ] ;
52432: LD_ADDR_EXP 66
52436: PUSH
52437: EMPTY
52438: ST_TO_ADDR
// mc_turret_list := [ ] ;
52439: LD_ADDR_EXP 67
52443: PUSH
52444: EMPTY
52445: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52446: LD_ADDR_EXP 68
52450: PUSH
52451: EMPTY
52452: ST_TO_ADDR
// mc_miners := [ ] ;
52453: LD_ADDR_EXP 73
52457: PUSH
52458: EMPTY
52459: ST_TO_ADDR
// mc_mines := [ ] ;
52460: LD_ADDR_EXP 72
52464: PUSH
52465: EMPTY
52466: ST_TO_ADDR
// mc_minefields := [ ] ;
52467: LD_ADDR_EXP 74
52471: PUSH
52472: EMPTY
52473: ST_TO_ADDR
// mc_crates := [ ] ;
52474: LD_ADDR_EXP 75
52478: PUSH
52479: EMPTY
52480: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52481: LD_ADDR_EXP 76
52485: PUSH
52486: EMPTY
52487: ST_TO_ADDR
// mc_crates_area := [ ] ;
52488: LD_ADDR_EXP 77
52492: PUSH
52493: EMPTY
52494: ST_TO_ADDR
// mc_vehicles := [ ] ;
52495: LD_ADDR_EXP 78
52499: PUSH
52500: EMPTY
52501: ST_TO_ADDR
// mc_attack := [ ] ;
52502: LD_ADDR_EXP 79
52506: PUSH
52507: EMPTY
52508: ST_TO_ADDR
// mc_produce := [ ] ;
52509: LD_ADDR_EXP 80
52513: PUSH
52514: EMPTY
52515: ST_TO_ADDR
// mc_defender := [ ] ;
52516: LD_ADDR_EXP 81
52520: PUSH
52521: EMPTY
52522: ST_TO_ADDR
// mc_parking := [ ] ;
52523: LD_ADDR_EXP 83
52527: PUSH
52528: EMPTY
52529: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52530: LD_ADDR_EXP 69
52534: PUSH
52535: EMPTY
52536: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52537: LD_ADDR_EXP 71
52541: PUSH
52542: EMPTY
52543: ST_TO_ADDR
// mc_scan := [ ] ;
52544: LD_ADDR_EXP 82
52548: PUSH
52549: EMPTY
52550: ST_TO_ADDR
// mc_scan_area := [ ] ;
52551: LD_ADDR_EXP 84
52555: PUSH
52556: EMPTY
52557: ST_TO_ADDR
// mc_tech := [ ] ;
52558: LD_ADDR_EXP 86
52562: PUSH
52563: EMPTY
52564: ST_TO_ADDR
// mc_class := [ ] ;
52565: LD_ADDR_EXP 100
52569: PUSH
52570: EMPTY
52571: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52572: LD_ADDR_EXP 101
52576: PUSH
52577: EMPTY
52578: ST_TO_ADDR
// mc_is_defending := [ ] ;
52579: LD_ADDR_EXP 102
52583: PUSH
52584: EMPTY
52585: ST_TO_ADDR
// end ;
52586: LD_VAR 0 1
52590: RET
// export function MC_Kill ( base ) ; begin
52591: LD_INT 0
52593: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52594: LD_ADDR_EXP 59
52598: PUSH
52599: LD_EXP 59
52603: PPUSH
52604: LD_VAR 0 1
52608: PPUSH
52609: EMPTY
52610: PPUSH
52611: CALL_OW 1
52615: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52616: LD_ADDR_EXP 60
52620: PUSH
52621: LD_EXP 60
52625: PPUSH
52626: LD_VAR 0 1
52630: PPUSH
52631: EMPTY
52632: PPUSH
52633: CALL_OW 1
52637: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52638: LD_ADDR_EXP 61
52642: PUSH
52643: LD_EXP 61
52647: PPUSH
52648: LD_VAR 0 1
52652: PPUSH
52653: EMPTY
52654: PPUSH
52655: CALL_OW 1
52659: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52660: LD_ADDR_EXP 62
52664: PUSH
52665: LD_EXP 62
52669: PPUSH
52670: LD_VAR 0 1
52674: PPUSH
52675: EMPTY
52676: PPUSH
52677: CALL_OW 1
52681: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52682: LD_ADDR_EXP 63
52686: PUSH
52687: LD_EXP 63
52691: PPUSH
52692: LD_VAR 0 1
52696: PPUSH
52697: EMPTY
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52704: LD_ADDR_EXP 64
52708: PUSH
52709: LD_EXP 64
52713: PPUSH
52714: LD_VAR 0 1
52718: PPUSH
52719: EMPTY
52720: PPUSH
52721: CALL_OW 1
52725: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52726: LD_ADDR_EXP 65
52730: PUSH
52731: LD_EXP 65
52735: PPUSH
52736: LD_VAR 0 1
52740: PPUSH
52741: EMPTY
52742: PPUSH
52743: CALL_OW 1
52747: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52748: LD_ADDR_EXP 66
52752: PUSH
52753: LD_EXP 66
52757: PPUSH
52758: LD_VAR 0 1
52762: PPUSH
52763: EMPTY
52764: PPUSH
52765: CALL_OW 1
52769: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52770: LD_ADDR_EXP 67
52774: PUSH
52775: LD_EXP 67
52779: PPUSH
52780: LD_VAR 0 1
52784: PPUSH
52785: EMPTY
52786: PPUSH
52787: CALL_OW 1
52791: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52792: LD_ADDR_EXP 68
52796: PUSH
52797: LD_EXP 68
52801: PPUSH
52802: LD_VAR 0 1
52806: PPUSH
52807: EMPTY
52808: PPUSH
52809: CALL_OW 1
52813: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52814: LD_ADDR_EXP 69
52818: PUSH
52819: LD_EXP 69
52823: PPUSH
52824: LD_VAR 0 1
52828: PPUSH
52829: EMPTY
52830: PPUSH
52831: CALL_OW 1
52835: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52836: LD_ADDR_EXP 70
52840: PUSH
52841: LD_EXP 70
52845: PPUSH
52846: LD_VAR 0 1
52850: PPUSH
52851: LD_INT 0
52853: PPUSH
52854: CALL_OW 1
52858: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52859: LD_ADDR_EXP 71
52863: PUSH
52864: LD_EXP 71
52868: PPUSH
52869: LD_VAR 0 1
52873: PPUSH
52874: EMPTY
52875: PPUSH
52876: CALL_OW 1
52880: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52881: LD_ADDR_EXP 72
52885: PUSH
52886: LD_EXP 72
52890: PPUSH
52891: LD_VAR 0 1
52895: PPUSH
52896: EMPTY
52897: PPUSH
52898: CALL_OW 1
52902: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52903: LD_ADDR_EXP 73
52907: PUSH
52908: LD_EXP 73
52912: PPUSH
52913: LD_VAR 0 1
52917: PPUSH
52918: EMPTY
52919: PPUSH
52920: CALL_OW 1
52924: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52925: LD_ADDR_EXP 74
52929: PUSH
52930: LD_EXP 74
52934: PPUSH
52935: LD_VAR 0 1
52939: PPUSH
52940: EMPTY
52941: PPUSH
52942: CALL_OW 1
52946: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52947: LD_ADDR_EXP 75
52951: PUSH
52952: LD_EXP 75
52956: PPUSH
52957: LD_VAR 0 1
52961: PPUSH
52962: EMPTY
52963: PPUSH
52964: CALL_OW 1
52968: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52969: LD_ADDR_EXP 76
52973: PUSH
52974: LD_EXP 76
52978: PPUSH
52979: LD_VAR 0 1
52983: PPUSH
52984: EMPTY
52985: PPUSH
52986: CALL_OW 1
52990: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52991: LD_ADDR_EXP 77
52995: PUSH
52996: LD_EXP 77
53000: PPUSH
53001: LD_VAR 0 1
53005: PPUSH
53006: EMPTY
53007: PPUSH
53008: CALL_OW 1
53012: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53013: LD_ADDR_EXP 78
53017: PUSH
53018: LD_EXP 78
53022: PPUSH
53023: LD_VAR 0 1
53027: PPUSH
53028: EMPTY
53029: PPUSH
53030: CALL_OW 1
53034: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53035: LD_ADDR_EXP 79
53039: PUSH
53040: LD_EXP 79
53044: PPUSH
53045: LD_VAR 0 1
53049: PPUSH
53050: EMPTY
53051: PPUSH
53052: CALL_OW 1
53056: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53057: LD_ADDR_EXP 80
53061: PUSH
53062: LD_EXP 80
53066: PPUSH
53067: LD_VAR 0 1
53071: PPUSH
53072: EMPTY
53073: PPUSH
53074: CALL_OW 1
53078: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53079: LD_ADDR_EXP 81
53083: PUSH
53084: LD_EXP 81
53088: PPUSH
53089: LD_VAR 0 1
53093: PPUSH
53094: EMPTY
53095: PPUSH
53096: CALL_OW 1
53100: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53101: LD_ADDR_EXP 82
53105: PUSH
53106: LD_EXP 82
53110: PPUSH
53111: LD_VAR 0 1
53115: PPUSH
53116: EMPTY
53117: PPUSH
53118: CALL_OW 1
53122: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53123: LD_ADDR_EXP 83
53127: PUSH
53128: LD_EXP 83
53132: PPUSH
53133: LD_VAR 0 1
53137: PPUSH
53138: EMPTY
53139: PPUSH
53140: CALL_OW 1
53144: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53145: LD_ADDR_EXP 84
53149: PUSH
53150: LD_EXP 84
53154: PPUSH
53155: LD_VAR 0 1
53159: PPUSH
53160: EMPTY
53161: PPUSH
53162: CALL_OW 1
53166: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53167: LD_ADDR_EXP 86
53171: PUSH
53172: LD_EXP 86
53176: PPUSH
53177: LD_VAR 0 1
53181: PPUSH
53182: EMPTY
53183: PPUSH
53184: CALL_OW 1
53188: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53189: LD_ADDR_EXP 88
53193: PUSH
53194: LD_EXP 88
53198: PPUSH
53199: LD_VAR 0 1
53203: PPUSH
53204: EMPTY
53205: PPUSH
53206: CALL_OW 1
53210: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53211: LD_ADDR_EXP 89
53215: PUSH
53216: LD_EXP 89
53220: PPUSH
53221: LD_VAR 0 1
53225: PPUSH
53226: EMPTY
53227: PPUSH
53228: CALL_OW 1
53232: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53233: LD_ADDR_EXP 90
53237: PUSH
53238: LD_EXP 90
53242: PPUSH
53243: LD_VAR 0 1
53247: PPUSH
53248: EMPTY
53249: PPUSH
53250: CALL_OW 1
53254: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53255: LD_ADDR_EXP 91
53259: PUSH
53260: LD_EXP 91
53264: PPUSH
53265: LD_VAR 0 1
53269: PPUSH
53270: EMPTY
53271: PPUSH
53272: CALL_OW 1
53276: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53277: LD_ADDR_EXP 92
53281: PUSH
53282: LD_EXP 92
53286: PPUSH
53287: LD_VAR 0 1
53291: PPUSH
53292: EMPTY
53293: PPUSH
53294: CALL_OW 1
53298: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53299: LD_ADDR_EXP 93
53303: PUSH
53304: LD_EXP 93
53308: PPUSH
53309: LD_VAR 0 1
53313: PPUSH
53314: EMPTY
53315: PPUSH
53316: CALL_OW 1
53320: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53321: LD_ADDR_EXP 94
53325: PUSH
53326: LD_EXP 94
53330: PPUSH
53331: LD_VAR 0 1
53335: PPUSH
53336: EMPTY
53337: PPUSH
53338: CALL_OW 1
53342: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53343: LD_ADDR_EXP 95
53347: PUSH
53348: LD_EXP 95
53352: PPUSH
53353: LD_VAR 0 1
53357: PPUSH
53358: EMPTY
53359: PPUSH
53360: CALL_OW 1
53364: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53365: LD_ADDR_EXP 96
53369: PUSH
53370: LD_EXP 96
53374: PPUSH
53375: LD_VAR 0 1
53379: PPUSH
53380: EMPTY
53381: PPUSH
53382: CALL_OW 1
53386: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53387: LD_ADDR_EXP 97
53391: PUSH
53392: LD_EXP 97
53396: PPUSH
53397: LD_VAR 0 1
53401: PPUSH
53402: EMPTY
53403: PPUSH
53404: CALL_OW 1
53408: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53409: LD_ADDR_EXP 98
53413: PUSH
53414: LD_EXP 98
53418: PPUSH
53419: LD_VAR 0 1
53423: PPUSH
53424: EMPTY
53425: PPUSH
53426: CALL_OW 1
53430: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53431: LD_ADDR_EXP 99
53435: PUSH
53436: LD_EXP 99
53440: PPUSH
53441: LD_VAR 0 1
53445: PPUSH
53446: EMPTY
53447: PPUSH
53448: CALL_OW 1
53452: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53453: LD_ADDR_EXP 100
53457: PUSH
53458: LD_EXP 100
53462: PPUSH
53463: LD_VAR 0 1
53467: PPUSH
53468: EMPTY
53469: PPUSH
53470: CALL_OW 1
53474: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53475: LD_ADDR_EXP 101
53479: PUSH
53480: LD_EXP 101
53484: PPUSH
53485: LD_VAR 0 1
53489: PPUSH
53490: LD_INT 0
53492: PPUSH
53493: CALL_OW 1
53497: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53498: LD_ADDR_EXP 102
53502: PUSH
53503: LD_EXP 102
53507: PPUSH
53508: LD_VAR 0 1
53512: PPUSH
53513: LD_INT 0
53515: PPUSH
53516: CALL_OW 1
53520: ST_TO_ADDR
// end ;
53521: LD_VAR 0 2
53525: RET
// export function MC_Add ( side , units ) ; var base ; begin
53526: LD_INT 0
53528: PPUSH
53529: PPUSH
// base := mc_bases + 1 ;
53530: LD_ADDR_VAR 0 4
53534: PUSH
53535: LD_EXP 59
53539: PUSH
53540: LD_INT 1
53542: PLUS
53543: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53544: LD_ADDR_EXP 85
53548: PUSH
53549: LD_EXP 85
53553: PPUSH
53554: LD_VAR 0 4
53558: PPUSH
53559: LD_VAR 0 1
53563: PPUSH
53564: CALL_OW 1
53568: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53569: LD_ADDR_EXP 59
53573: PUSH
53574: LD_EXP 59
53578: PPUSH
53579: LD_VAR 0 4
53583: PPUSH
53584: LD_VAR 0 2
53588: PPUSH
53589: CALL_OW 1
53593: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53594: LD_ADDR_EXP 60
53598: PUSH
53599: LD_EXP 60
53603: PPUSH
53604: LD_VAR 0 4
53608: PPUSH
53609: EMPTY
53610: PPUSH
53611: CALL_OW 1
53615: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53616: LD_ADDR_EXP 61
53620: PUSH
53621: LD_EXP 61
53625: PPUSH
53626: LD_VAR 0 4
53630: PPUSH
53631: EMPTY
53632: PPUSH
53633: CALL_OW 1
53637: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53638: LD_ADDR_EXP 62
53642: PUSH
53643: LD_EXP 62
53647: PPUSH
53648: LD_VAR 0 4
53652: PPUSH
53653: EMPTY
53654: PPUSH
53655: CALL_OW 1
53659: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53660: LD_ADDR_EXP 63
53664: PUSH
53665: LD_EXP 63
53669: PPUSH
53670: LD_VAR 0 4
53674: PPUSH
53675: EMPTY
53676: PPUSH
53677: CALL_OW 1
53681: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53682: LD_ADDR_EXP 64
53686: PUSH
53687: LD_EXP 64
53691: PPUSH
53692: LD_VAR 0 4
53696: PPUSH
53697: EMPTY
53698: PPUSH
53699: CALL_OW 1
53703: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53704: LD_ADDR_EXP 65
53708: PUSH
53709: LD_EXP 65
53713: PPUSH
53714: LD_VAR 0 4
53718: PPUSH
53719: EMPTY
53720: PPUSH
53721: CALL_OW 1
53725: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53726: LD_ADDR_EXP 66
53730: PUSH
53731: LD_EXP 66
53735: PPUSH
53736: LD_VAR 0 4
53740: PPUSH
53741: EMPTY
53742: PPUSH
53743: CALL_OW 1
53747: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53748: LD_ADDR_EXP 67
53752: PUSH
53753: LD_EXP 67
53757: PPUSH
53758: LD_VAR 0 4
53762: PPUSH
53763: EMPTY
53764: PPUSH
53765: CALL_OW 1
53769: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53770: LD_ADDR_EXP 68
53774: PUSH
53775: LD_EXP 68
53779: PPUSH
53780: LD_VAR 0 4
53784: PPUSH
53785: EMPTY
53786: PPUSH
53787: CALL_OW 1
53791: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53792: LD_ADDR_EXP 69
53796: PUSH
53797: LD_EXP 69
53801: PPUSH
53802: LD_VAR 0 4
53806: PPUSH
53807: EMPTY
53808: PPUSH
53809: CALL_OW 1
53813: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53814: LD_ADDR_EXP 70
53818: PUSH
53819: LD_EXP 70
53823: PPUSH
53824: LD_VAR 0 4
53828: PPUSH
53829: LD_INT 0
53831: PPUSH
53832: CALL_OW 1
53836: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53837: LD_ADDR_EXP 71
53841: PUSH
53842: LD_EXP 71
53846: PPUSH
53847: LD_VAR 0 4
53851: PPUSH
53852: EMPTY
53853: PPUSH
53854: CALL_OW 1
53858: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53859: LD_ADDR_EXP 72
53863: PUSH
53864: LD_EXP 72
53868: PPUSH
53869: LD_VAR 0 4
53873: PPUSH
53874: EMPTY
53875: PPUSH
53876: CALL_OW 1
53880: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53881: LD_ADDR_EXP 73
53885: PUSH
53886: LD_EXP 73
53890: PPUSH
53891: LD_VAR 0 4
53895: PPUSH
53896: EMPTY
53897: PPUSH
53898: CALL_OW 1
53902: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53903: LD_ADDR_EXP 74
53907: PUSH
53908: LD_EXP 74
53912: PPUSH
53913: LD_VAR 0 4
53917: PPUSH
53918: EMPTY
53919: PPUSH
53920: CALL_OW 1
53924: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53925: LD_ADDR_EXP 75
53929: PUSH
53930: LD_EXP 75
53934: PPUSH
53935: LD_VAR 0 4
53939: PPUSH
53940: EMPTY
53941: PPUSH
53942: CALL_OW 1
53946: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53947: LD_ADDR_EXP 76
53951: PUSH
53952: LD_EXP 76
53956: PPUSH
53957: LD_VAR 0 4
53961: PPUSH
53962: EMPTY
53963: PPUSH
53964: CALL_OW 1
53968: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53969: LD_ADDR_EXP 77
53973: PUSH
53974: LD_EXP 77
53978: PPUSH
53979: LD_VAR 0 4
53983: PPUSH
53984: EMPTY
53985: PPUSH
53986: CALL_OW 1
53990: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53991: LD_ADDR_EXP 78
53995: PUSH
53996: LD_EXP 78
54000: PPUSH
54001: LD_VAR 0 4
54005: PPUSH
54006: EMPTY
54007: PPUSH
54008: CALL_OW 1
54012: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54013: LD_ADDR_EXP 79
54017: PUSH
54018: LD_EXP 79
54022: PPUSH
54023: LD_VAR 0 4
54027: PPUSH
54028: EMPTY
54029: PPUSH
54030: CALL_OW 1
54034: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54035: LD_ADDR_EXP 80
54039: PUSH
54040: LD_EXP 80
54044: PPUSH
54045: LD_VAR 0 4
54049: PPUSH
54050: EMPTY
54051: PPUSH
54052: CALL_OW 1
54056: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54057: LD_ADDR_EXP 81
54061: PUSH
54062: LD_EXP 81
54066: PPUSH
54067: LD_VAR 0 4
54071: PPUSH
54072: EMPTY
54073: PPUSH
54074: CALL_OW 1
54078: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54079: LD_ADDR_EXP 82
54083: PUSH
54084: LD_EXP 82
54088: PPUSH
54089: LD_VAR 0 4
54093: PPUSH
54094: EMPTY
54095: PPUSH
54096: CALL_OW 1
54100: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54101: LD_ADDR_EXP 83
54105: PUSH
54106: LD_EXP 83
54110: PPUSH
54111: LD_VAR 0 4
54115: PPUSH
54116: EMPTY
54117: PPUSH
54118: CALL_OW 1
54122: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54123: LD_ADDR_EXP 84
54127: PUSH
54128: LD_EXP 84
54132: PPUSH
54133: LD_VAR 0 4
54137: PPUSH
54138: EMPTY
54139: PPUSH
54140: CALL_OW 1
54144: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54145: LD_ADDR_EXP 86
54149: PUSH
54150: LD_EXP 86
54154: PPUSH
54155: LD_VAR 0 4
54159: PPUSH
54160: EMPTY
54161: PPUSH
54162: CALL_OW 1
54166: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54167: LD_ADDR_EXP 88
54171: PUSH
54172: LD_EXP 88
54176: PPUSH
54177: LD_VAR 0 4
54181: PPUSH
54182: EMPTY
54183: PPUSH
54184: CALL_OW 1
54188: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54189: LD_ADDR_EXP 89
54193: PUSH
54194: LD_EXP 89
54198: PPUSH
54199: LD_VAR 0 4
54203: PPUSH
54204: EMPTY
54205: PPUSH
54206: CALL_OW 1
54210: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54211: LD_ADDR_EXP 90
54215: PUSH
54216: LD_EXP 90
54220: PPUSH
54221: LD_VAR 0 4
54225: PPUSH
54226: EMPTY
54227: PPUSH
54228: CALL_OW 1
54232: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54233: LD_ADDR_EXP 91
54237: PUSH
54238: LD_EXP 91
54242: PPUSH
54243: LD_VAR 0 4
54247: PPUSH
54248: EMPTY
54249: PPUSH
54250: CALL_OW 1
54254: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54255: LD_ADDR_EXP 92
54259: PUSH
54260: LD_EXP 92
54264: PPUSH
54265: LD_VAR 0 4
54269: PPUSH
54270: EMPTY
54271: PPUSH
54272: CALL_OW 1
54276: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54277: LD_ADDR_EXP 93
54281: PUSH
54282: LD_EXP 93
54286: PPUSH
54287: LD_VAR 0 4
54291: PPUSH
54292: EMPTY
54293: PPUSH
54294: CALL_OW 1
54298: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54299: LD_ADDR_EXP 94
54303: PUSH
54304: LD_EXP 94
54308: PPUSH
54309: LD_VAR 0 4
54313: PPUSH
54314: EMPTY
54315: PPUSH
54316: CALL_OW 1
54320: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54321: LD_ADDR_EXP 95
54325: PUSH
54326: LD_EXP 95
54330: PPUSH
54331: LD_VAR 0 4
54335: PPUSH
54336: EMPTY
54337: PPUSH
54338: CALL_OW 1
54342: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54343: LD_ADDR_EXP 96
54347: PUSH
54348: LD_EXP 96
54352: PPUSH
54353: LD_VAR 0 4
54357: PPUSH
54358: EMPTY
54359: PPUSH
54360: CALL_OW 1
54364: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54365: LD_ADDR_EXP 97
54369: PUSH
54370: LD_EXP 97
54374: PPUSH
54375: LD_VAR 0 4
54379: PPUSH
54380: EMPTY
54381: PPUSH
54382: CALL_OW 1
54386: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54387: LD_ADDR_EXP 98
54391: PUSH
54392: LD_EXP 98
54396: PPUSH
54397: LD_VAR 0 4
54401: PPUSH
54402: EMPTY
54403: PPUSH
54404: CALL_OW 1
54408: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54409: LD_ADDR_EXP 99
54413: PUSH
54414: LD_EXP 99
54418: PPUSH
54419: LD_VAR 0 4
54423: PPUSH
54424: EMPTY
54425: PPUSH
54426: CALL_OW 1
54430: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54431: LD_ADDR_EXP 100
54435: PUSH
54436: LD_EXP 100
54440: PPUSH
54441: LD_VAR 0 4
54445: PPUSH
54446: EMPTY
54447: PPUSH
54448: CALL_OW 1
54452: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54453: LD_ADDR_EXP 101
54457: PUSH
54458: LD_EXP 101
54462: PPUSH
54463: LD_VAR 0 4
54467: PPUSH
54468: LD_INT 0
54470: PPUSH
54471: CALL_OW 1
54475: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54476: LD_ADDR_EXP 102
54480: PUSH
54481: LD_EXP 102
54485: PPUSH
54486: LD_VAR 0 4
54490: PPUSH
54491: LD_INT 0
54493: PPUSH
54494: CALL_OW 1
54498: ST_TO_ADDR
// result := base ;
54499: LD_ADDR_VAR 0 3
54503: PUSH
54504: LD_VAR 0 4
54508: ST_TO_ADDR
// end ;
54509: LD_VAR 0 3
54513: RET
// export function MC_Start ( ) ; var i ; begin
54514: LD_INT 0
54516: PPUSH
54517: PPUSH
// for i = 1 to mc_bases do
54518: LD_ADDR_VAR 0 2
54522: PUSH
54523: DOUBLE
54524: LD_INT 1
54526: DEC
54527: ST_TO_ADDR
54528: LD_EXP 59
54532: PUSH
54533: FOR_TO
54534: IFFALSE 55611
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54536: LD_ADDR_EXP 59
54540: PUSH
54541: LD_EXP 59
54545: PPUSH
54546: LD_VAR 0 2
54550: PPUSH
54551: LD_EXP 59
54555: PUSH
54556: LD_VAR 0 2
54560: ARRAY
54561: PUSH
54562: LD_INT 0
54564: DIFF
54565: PPUSH
54566: CALL_OW 1
54570: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54571: LD_ADDR_EXP 60
54575: PUSH
54576: LD_EXP 60
54580: PPUSH
54581: LD_VAR 0 2
54585: PPUSH
54586: EMPTY
54587: PPUSH
54588: CALL_OW 1
54592: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54593: LD_ADDR_EXP 61
54597: PUSH
54598: LD_EXP 61
54602: PPUSH
54603: LD_VAR 0 2
54607: PPUSH
54608: EMPTY
54609: PPUSH
54610: CALL_OW 1
54614: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54615: LD_ADDR_EXP 62
54619: PUSH
54620: LD_EXP 62
54624: PPUSH
54625: LD_VAR 0 2
54629: PPUSH
54630: EMPTY
54631: PPUSH
54632: CALL_OW 1
54636: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54637: LD_ADDR_EXP 63
54641: PUSH
54642: LD_EXP 63
54646: PPUSH
54647: LD_VAR 0 2
54651: PPUSH
54652: EMPTY
54653: PUSH
54654: EMPTY
54655: PUSH
54656: EMPTY
54657: LIST
54658: LIST
54659: PPUSH
54660: CALL_OW 1
54664: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54665: LD_ADDR_EXP 64
54669: PUSH
54670: LD_EXP 64
54674: PPUSH
54675: LD_VAR 0 2
54679: PPUSH
54680: EMPTY
54681: PPUSH
54682: CALL_OW 1
54686: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54687: LD_ADDR_EXP 91
54691: PUSH
54692: LD_EXP 91
54696: PPUSH
54697: LD_VAR 0 2
54701: PPUSH
54702: EMPTY
54703: PPUSH
54704: CALL_OW 1
54708: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54709: LD_ADDR_EXP 65
54713: PUSH
54714: LD_EXP 65
54718: PPUSH
54719: LD_VAR 0 2
54723: PPUSH
54724: EMPTY
54725: PPUSH
54726: CALL_OW 1
54730: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54731: LD_ADDR_EXP 66
54735: PUSH
54736: LD_EXP 66
54740: PPUSH
54741: LD_VAR 0 2
54745: PPUSH
54746: EMPTY
54747: PPUSH
54748: CALL_OW 1
54752: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54753: LD_ADDR_EXP 67
54757: PUSH
54758: LD_EXP 67
54762: PPUSH
54763: LD_VAR 0 2
54767: PPUSH
54768: LD_EXP 59
54772: PUSH
54773: LD_VAR 0 2
54777: ARRAY
54778: PPUSH
54779: LD_INT 2
54781: PUSH
54782: LD_INT 30
54784: PUSH
54785: LD_INT 32
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: PUSH
54792: LD_INT 30
54794: PUSH
54795: LD_INT 33
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: PUSH
54802: EMPTY
54803: LIST
54804: LIST
54805: LIST
54806: PPUSH
54807: CALL_OW 72
54811: PPUSH
54812: CALL_OW 1
54816: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54817: LD_ADDR_EXP 68
54821: PUSH
54822: LD_EXP 68
54826: PPUSH
54827: LD_VAR 0 2
54831: PPUSH
54832: LD_EXP 59
54836: PUSH
54837: LD_VAR 0 2
54841: ARRAY
54842: PPUSH
54843: LD_INT 2
54845: PUSH
54846: LD_INT 30
54848: PUSH
54849: LD_INT 32
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: PUSH
54856: LD_INT 30
54858: PUSH
54859: LD_INT 31
54861: PUSH
54862: EMPTY
54863: LIST
54864: LIST
54865: PUSH
54866: EMPTY
54867: LIST
54868: LIST
54869: LIST
54870: PUSH
54871: LD_INT 58
54873: PUSH
54874: EMPTY
54875: LIST
54876: PUSH
54877: EMPTY
54878: LIST
54879: LIST
54880: PPUSH
54881: CALL_OW 72
54885: PPUSH
54886: CALL_OW 1
54890: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54891: LD_ADDR_EXP 69
54895: PUSH
54896: LD_EXP 69
54900: PPUSH
54901: LD_VAR 0 2
54905: PPUSH
54906: EMPTY
54907: PPUSH
54908: CALL_OW 1
54912: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54913: LD_ADDR_EXP 73
54917: PUSH
54918: LD_EXP 73
54922: PPUSH
54923: LD_VAR 0 2
54927: PPUSH
54928: EMPTY
54929: PPUSH
54930: CALL_OW 1
54934: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54935: LD_ADDR_EXP 72
54939: PUSH
54940: LD_EXP 72
54944: PPUSH
54945: LD_VAR 0 2
54949: PPUSH
54950: EMPTY
54951: PPUSH
54952: CALL_OW 1
54956: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54957: LD_ADDR_EXP 74
54961: PUSH
54962: LD_EXP 74
54966: PPUSH
54967: LD_VAR 0 2
54971: PPUSH
54972: EMPTY
54973: PPUSH
54974: CALL_OW 1
54978: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54979: LD_ADDR_EXP 75
54983: PUSH
54984: LD_EXP 75
54988: PPUSH
54989: LD_VAR 0 2
54993: PPUSH
54994: EMPTY
54995: PPUSH
54996: CALL_OW 1
55000: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55001: LD_ADDR_EXP 76
55005: PUSH
55006: LD_EXP 76
55010: PPUSH
55011: LD_VAR 0 2
55015: PPUSH
55016: EMPTY
55017: PPUSH
55018: CALL_OW 1
55022: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55023: LD_ADDR_EXP 77
55027: PUSH
55028: LD_EXP 77
55032: PPUSH
55033: LD_VAR 0 2
55037: PPUSH
55038: EMPTY
55039: PPUSH
55040: CALL_OW 1
55044: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55045: LD_ADDR_EXP 78
55049: PUSH
55050: LD_EXP 78
55054: PPUSH
55055: LD_VAR 0 2
55059: PPUSH
55060: EMPTY
55061: PPUSH
55062: CALL_OW 1
55066: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55067: LD_ADDR_EXP 79
55071: PUSH
55072: LD_EXP 79
55076: PPUSH
55077: LD_VAR 0 2
55081: PPUSH
55082: EMPTY
55083: PPUSH
55084: CALL_OW 1
55088: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55089: LD_ADDR_EXP 80
55093: PUSH
55094: LD_EXP 80
55098: PPUSH
55099: LD_VAR 0 2
55103: PPUSH
55104: EMPTY
55105: PPUSH
55106: CALL_OW 1
55110: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55111: LD_ADDR_EXP 81
55115: PUSH
55116: LD_EXP 81
55120: PPUSH
55121: LD_VAR 0 2
55125: PPUSH
55126: EMPTY
55127: PPUSH
55128: CALL_OW 1
55132: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55133: LD_ADDR_EXP 70
55137: PUSH
55138: LD_EXP 70
55142: PPUSH
55143: LD_VAR 0 2
55147: PPUSH
55148: LD_INT 0
55150: PPUSH
55151: CALL_OW 1
55155: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55156: LD_ADDR_EXP 83
55160: PUSH
55161: LD_EXP 83
55165: PPUSH
55166: LD_VAR 0 2
55170: PPUSH
55171: LD_INT 0
55173: PPUSH
55174: CALL_OW 1
55178: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55179: LD_ADDR_EXP 71
55183: PUSH
55184: LD_EXP 71
55188: PPUSH
55189: LD_VAR 0 2
55193: PPUSH
55194: EMPTY
55195: PPUSH
55196: CALL_OW 1
55200: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55201: LD_ADDR_EXP 82
55205: PUSH
55206: LD_EXP 82
55210: PPUSH
55211: LD_VAR 0 2
55215: PPUSH
55216: LD_INT 0
55218: PPUSH
55219: CALL_OW 1
55223: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55224: LD_ADDR_EXP 84
55228: PUSH
55229: LD_EXP 84
55233: PPUSH
55234: LD_VAR 0 2
55238: PPUSH
55239: EMPTY
55240: PPUSH
55241: CALL_OW 1
55245: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55246: LD_ADDR_EXP 87
55250: PUSH
55251: LD_EXP 87
55255: PPUSH
55256: LD_VAR 0 2
55260: PPUSH
55261: LD_INT 0
55263: PPUSH
55264: CALL_OW 1
55268: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55269: LD_ADDR_EXP 88
55273: PUSH
55274: LD_EXP 88
55278: PPUSH
55279: LD_VAR 0 2
55283: PPUSH
55284: EMPTY
55285: PPUSH
55286: CALL_OW 1
55290: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55291: LD_ADDR_EXP 89
55295: PUSH
55296: LD_EXP 89
55300: PPUSH
55301: LD_VAR 0 2
55305: PPUSH
55306: EMPTY
55307: PPUSH
55308: CALL_OW 1
55312: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55313: LD_ADDR_EXP 90
55317: PUSH
55318: LD_EXP 90
55322: PPUSH
55323: LD_VAR 0 2
55327: PPUSH
55328: EMPTY
55329: PPUSH
55330: CALL_OW 1
55334: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55335: LD_ADDR_EXP 92
55339: PUSH
55340: LD_EXP 92
55344: PPUSH
55345: LD_VAR 0 2
55349: PPUSH
55350: LD_EXP 59
55354: PUSH
55355: LD_VAR 0 2
55359: ARRAY
55360: PPUSH
55361: LD_INT 2
55363: PUSH
55364: LD_INT 30
55366: PUSH
55367: LD_INT 6
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: PUSH
55374: LD_INT 30
55376: PUSH
55377: LD_INT 7
55379: PUSH
55380: EMPTY
55381: LIST
55382: LIST
55383: PUSH
55384: LD_INT 30
55386: PUSH
55387: LD_INT 8
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: LIST
55398: LIST
55399: PPUSH
55400: CALL_OW 72
55404: PPUSH
55405: CALL_OW 1
55409: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55410: LD_ADDR_EXP 93
55414: PUSH
55415: LD_EXP 93
55419: PPUSH
55420: LD_VAR 0 2
55424: PPUSH
55425: EMPTY
55426: PPUSH
55427: CALL_OW 1
55431: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55432: LD_ADDR_EXP 94
55436: PUSH
55437: LD_EXP 94
55441: PPUSH
55442: LD_VAR 0 2
55446: PPUSH
55447: EMPTY
55448: PPUSH
55449: CALL_OW 1
55453: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55454: LD_ADDR_EXP 95
55458: PUSH
55459: LD_EXP 95
55463: PPUSH
55464: LD_VAR 0 2
55468: PPUSH
55469: EMPTY
55470: PPUSH
55471: CALL_OW 1
55475: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55476: LD_ADDR_EXP 96
55480: PUSH
55481: LD_EXP 96
55485: PPUSH
55486: LD_VAR 0 2
55490: PPUSH
55491: EMPTY
55492: PPUSH
55493: CALL_OW 1
55497: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55498: LD_ADDR_EXP 97
55502: PUSH
55503: LD_EXP 97
55507: PPUSH
55508: LD_VAR 0 2
55512: PPUSH
55513: EMPTY
55514: PPUSH
55515: CALL_OW 1
55519: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55520: LD_ADDR_EXP 98
55524: PUSH
55525: LD_EXP 98
55529: PPUSH
55530: LD_VAR 0 2
55534: PPUSH
55535: EMPTY
55536: PPUSH
55537: CALL_OW 1
55541: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55542: LD_ADDR_EXP 99
55546: PUSH
55547: LD_EXP 99
55551: PPUSH
55552: LD_VAR 0 2
55556: PPUSH
55557: EMPTY
55558: PPUSH
55559: CALL_OW 1
55563: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55564: LD_ADDR_EXP 100
55568: PUSH
55569: LD_EXP 100
55573: PPUSH
55574: LD_VAR 0 2
55578: PPUSH
55579: EMPTY
55580: PPUSH
55581: CALL_OW 1
55585: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55586: LD_ADDR_EXP 101
55590: PUSH
55591: LD_EXP 101
55595: PPUSH
55596: LD_VAR 0 2
55600: PPUSH
55601: LD_INT 0
55603: PPUSH
55604: CALL_OW 1
55608: ST_TO_ADDR
// end ;
55609: GO 54533
55611: POP
55612: POP
// MC_InitSides ( ) ;
55613: CALL 55899 0 0
// MC_InitResearch ( ) ;
55617: CALL 55638 0 0
// CustomInitMacro ( ) ;
55621: CALL 202 0 0
// skirmish := true ;
55625: LD_ADDR_EXP 57
55629: PUSH
55630: LD_INT 1
55632: ST_TO_ADDR
// end ;
55633: LD_VAR 0 1
55637: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55638: LD_INT 0
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
55644: PPUSH
55645: PPUSH
// if not mc_bases then
55646: LD_EXP 59
55650: NOT
55651: IFFALSE 55655
// exit ;
55653: GO 55894
// for i = 1 to 8 do
55655: LD_ADDR_VAR 0 2
55659: PUSH
55660: DOUBLE
55661: LD_INT 1
55663: DEC
55664: ST_TO_ADDR
55665: LD_INT 8
55667: PUSH
55668: FOR_TO
55669: IFFALSE 55695
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55671: LD_ADDR_EXP 86
55675: PUSH
55676: LD_EXP 86
55680: PPUSH
55681: LD_VAR 0 2
55685: PPUSH
55686: EMPTY
55687: PPUSH
55688: CALL_OW 1
55692: ST_TO_ADDR
55693: GO 55668
55695: POP
55696: POP
// tmp := [ ] ;
55697: LD_ADDR_VAR 0 5
55701: PUSH
55702: EMPTY
55703: ST_TO_ADDR
// for i = 1 to mc_sides do
55704: LD_ADDR_VAR 0 2
55708: PUSH
55709: DOUBLE
55710: LD_INT 1
55712: DEC
55713: ST_TO_ADDR
55714: LD_EXP 85
55718: PUSH
55719: FOR_TO
55720: IFFALSE 55778
// if not mc_sides [ i ] in tmp then
55722: LD_EXP 85
55726: PUSH
55727: LD_VAR 0 2
55731: ARRAY
55732: PUSH
55733: LD_VAR 0 5
55737: IN
55738: NOT
55739: IFFALSE 55776
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55741: LD_ADDR_VAR 0 5
55745: PUSH
55746: LD_VAR 0 5
55750: PPUSH
55751: LD_VAR 0 5
55755: PUSH
55756: LD_INT 1
55758: PLUS
55759: PPUSH
55760: LD_EXP 85
55764: PUSH
55765: LD_VAR 0 2
55769: ARRAY
55770: PPUSH
55771: CALL_OW 2
55775: ST_TO_ADDR
55776: GO 55719
55778: POP
55779: POP
// if not tmp then
55780: LD_VAR 0 5
55784: NOT
55785: IFFALSE 55789
// exit ;
55787: GO 55894
// for j in tmp do
55789: LD_ADDR_VAR 0 3
55793: PUSH
55794: LD_VAR 0 5
55798: PUSH
55799: FOR_IN
55800: IFFALSE 55892
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55802: LD_ADDR_VAR 0 6
55806: PUSH
55807: LD_INT 22
55809: PUSH
55810: LD_VAR 0 3
55814: PUSH
55815: EMPTY
55816: LIST
55817: LIST
55818: PPUSH
55819: CALL_OW 69
55823: ST_TO_ADDR
// if not un then
55824: LD_VAR 0 6
55828: NOT
55829: IFFALSE 55833
// continue ;
55831: GO 55799
// nation := GetNation ( un [ 1 ] ) ;
55833: LD_ADDR_VAR 0 4
55837: PUSH
55838: LD_VAR 0 6
55842: PUSH
55843: LD_INT 1
55845: ARRAY
55846: PPUSH
55847: CALL_OW 248
55851: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55852: LD_ADDR_EXP 86
55856: PUSH
55857: LD_EXP 86
55861: PPUSH
55862: LD_VAR 0 3
55866: PPUSH
55867: LD_VAR 0 3
55871: PPUSH
55872: LD_VAR 0 4
55876: PPUSH
55877: LD_INT 1
55879: PPUSH
55880: CALL 14786 0 3
55884: PPUSH
55885: CALL_OW 1
55889: ST_TO_ADDR
// end ;
55890: GO 55799
55892: POP
55893: POP
// end ;
55894: LD_VAR 0 1
55898: RET
// export function MC_InitSides ( ) ; var i ; begin
55899: LD_INT 0
55901: PPUSH
55902: PPUSH
// if not mc_bases then
55903: LD_EXP 59
55907: NOT
55908: IFFALSE 55912
// exit ;
55910: GO 55986
// for i = 1 to mc_bases do
55912: LD_ADDR_VAR 0 2
55916: PUSH
55917: DOUBLE
55918: LD_INT 1
55920: DEC
55921: ST_TO_ADDR
55922: LD_EXP 59
55926: PUSH
55927: FOR_TO
55928: IFFALSE 55984
// if mc_bases [ i ] then
55930: LD_EXP 59
55934: PUSH
55935: LD_VAR 0 2
55939: ARRAY
55940: IFFALSE 55982
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55942: LD_ADDR_EXP 85
55946: PUSH
55947: LD_EXP 85
55951: PPUSH
55952: LD_VAR 0 2
55956: PPUSH
55957: LD_EXP 59
55961: PUSH
55962: LD_VAR 0 2
55966: ARRAY
55967: PUSH
55968: LD_INT 1
55970: ARRAY
55971: PPUSH
55972: CALL_OW 255
55976: PPUSH
55977: CALL_OW 1
55981: ST_TO_ADDR
55982: GO 55927
55984: POP
55985: POP
// end ;
55986: LD_VAR 0 1
55990: RET
// every 0 0$03 trigger skirmish do
55991: LD_EXP 57
55995: IFFALSE 56149
55997: GO 55999
55999: DISABLE
// begin enable ;
56000: ENABLE
// MC_CheckBuildings ( ) ;
56001: CALL 60647 0 0
// MC_CheckPeopleLife ( ) ;
56005: CALL 60772 0 0
// RaiseSailEvent ( 100 ) ;
56009: LD_INT 100
56011: PPUSH
56012: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56016: LD_INT 103
56018: PPUSH
56019: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56023: LD_INT 104
56025: PPUSH
56026: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56030: LD_INT 105
56032: PPUSH
56033: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56037: LD_INT 106
56039: PPUSH
56040: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56044: LD_INT 107
56046: PPUSH
56047: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56051: LD_INT 108
56053: PPUSH
56054: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56058: LD_INT 109
56060: PPUSH
56061: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56065: LD_INT 110
56067: PPUSH
56068: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56072: LD_INT 111
56074: PPUSH
56075: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56079: LD_INT 112
56081: PPUSH
56082: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56086: LD_INT 113
56088: PPUSH
56089: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56093: LD_INT 120
56095: PPUSH
56096: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56100: LD_INT 121
56102: PPUSH
56103: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56107: LD_INT 122
56109: PPUSH
56110: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56114: LD_INT 123
56116: PPUSH
56117: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56121: LD_INT 124
56123: PPUSH
56124: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56128: LD_INT 125
56130: PPUSH
56131: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56135: LD_INT 126
56137: PPUSH
56138: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56142: LD_INT 200
56144: PPUSH
56145: CALL_OW 427
// end ;
56149: END
// on SailEvent ( event ) do begin if event < 100 then
56150: LD_VAR 0 1
56154: PUSH
56155: LD_INT 100
56157: LESS
56158: IFFALSE 56169
// CustomEvent ( event ) ;
56160: LD_VAR 0 1
56164: PPUSH
56165: CALL 13444 0 1
// if event = 100 then
56169: LD_VAR 0 1
56173: PUSH
56174: LD_INT 100
56176: EQUAL
56177: IFFALSE 56183
// MC_ClassManager ( ) ;
56179: CALL 56575 0 0
// if event = 101 then
56183: LD_VAR 0 1
56187: PUSH
56188: LD_INT 101
56190: EQUAL
56191: IFFALSE 56197
// MC_RepairBuildings ( ) ;
56193: CALL 61357 0 0
// if event = 102 then
56197: LD_VAR 0 1
56201: PUSH
56202: LD_INT 102
56204: EQUAL
56205: IFFALSE 56211
// MC_Heal ( ) ;
56207: CALL 62242 0 0
// if event = 103 then
56211: LD_VAR 0 1
56215: PUSH
56216: LD_INT 103
56218: EQUAL
56219: IFFALSE 56225
// MC_Build ( ) ;
56221: CALL 62664 0 0
// if event = 104 then
56225: LD_VAR 0 1
56229: PUSH
56230: LD_INT 104
56232: EQUAL
56233: IFFALSE 56239
// MC_TurretWeapon ( ) ;
56235: CALL 64305 0 0
// if event = 105 then
56239: LD_VAR 0 1
56243: PUSH
56244: LD_INT 105
56246: EQUAL
56247: IFFALSE 56253
// MC_BuildUpgrade ( ) ;
56249: CALL 63856 0 0
// if event = 106 then
56253: LD_VAR 0 1
56257: PUSH
56258: LD_INT 106
56260: EQUAL
56261: IFFALSE 56267
// MC_PlantMines ( ) ;
56263: CALL 64735 0 0
// if event = 107 then
56267: LD_VAR 0 1
56271: PUSH
56272: LD_INT 107
56274: EQUAL
56275: IFFALSE 56281
// MC_CollectCrates ( ) ;
56277: CALL 65526 0 0
// if event = 108 then
56281: LD_VAR 0 1
56285: PUSH
56286: LD_INT 108
56288: EQUAL
56289: IFFALSE 56295
// MC_LinkRemoteControl ( ) ;
56291: CALL 67302 0 0
// if event = 109 then
56295: LD_VAR 0 1
56299: PUSH
56300: LD_INT 109
56302: EQUAL
56303: IFFALSE 56309
// MC_ProduceVehicle ( ) ;
56305: CALL 67483 0 0
// if event = 110 then
56309: LD_VAR 0 1
56313: PUSH
56314: LD_INT 110
56316: EQUAL
56317: IFFALSE 56323
// MC_SendAttack ( ) ;
56319: CALL 67949 0 0
// if event = 111 then
56323: LD_VAR 0 1
56327: PUSH
56328: LD_INT 111
56330: EQUAL
56331: IFFALSE 56337
// MC_Defend ( ) ;
56333: CALL 68057 0 0
// if event = 112 then
56337: LD_VAR 0 1
56341: PUSH
56342: LD_INT 112
56344: EQUAL
56345: IFFALSE 56351
// MC_Research ( ) ;
56347: CALL 68779 0 0
// if event = 113 then
56351: LD_VAR 0 1
56355: PUSH
56356: LD_INT 113
56358: EQUAL
56359: IFFALSE 56365
// MC_MinesTrigger ( ) ;
56361: CALL 69893 0 0
// if event = 120 then
56365: LD_VAR 0 1
56369: PUSH
56370: LD_INT 120
56372: EQUAL
56373: IFFALSE 56379
// MC_RepairVehicle ( ) ;
56375: CALL 69992 0 0
// if event = 121 then
56379: LD_VAR 0 1
56383: PUSH
56384: LD_INT 121
56386: EQUAL
56387: IFFALSE 56393
// MC_TameApe ( ) ;
56389: CALL 70722 0 0
// if event = 122 then
56393: LD_VAR 0 1
56397: PUSH
56398: LD_INT 122
56400: EQUAL
56401: IFFALSE 56407
// MC_ChangeApeClass ( ) ;
56403: CALL 71551 0 0
// if event = 123 then
56407: LD_VAR 0 1
56411: PUSH
56412: LD_INT 123
56414: EQUAL
56415: IFFALSE 56421
// MC_Bazooka ( ) ;
56417: CALL 72201 0 0
// if event = 124 then
56421: LD_VAR 0 1
56425: PUSH
56426: LD_INT 124
56428: EQUAL
56429: IFFALSE 56435
// MC_TeleportExit ( ) ;
56431: CALL 72399 0 0
// if event = 125 then
56435: LD_VAR 0 1
56439: PUSH
56440: LD_INT 125
56442: EQUAL
56443: IFFALSE 56449
// MC_Deposits ( ) ;
56445: CALL 73046 0 0
// if event = 126 then
56449: LD_VAR 0 1
56453: PUSH
56454: LD_INT 126
56456: EQUAL
56457: IFFALSE 56463
// MC_RemoteDriver ( ) ;
56459: CALL 73671 0 0
// if event = 200 then
56463: LD_VAR 0 1
56467: PUSH
56468: LD_INT 200
56470: EQUAL
56471: IFFALSE 56477
// MC_Idle ( ) ;
56473: CALL 75620 0 0
// end ;
56477: PPOPN 1
56479: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56480: LD_INT 0
56482: PPUSH
56483: PPUSH
// if not mc_bases [ base ] or not tag then
56484: LD_EXP 59
56488: PUSH
56489: LD_VAR 0 1
56493: ARRAY
56494: NOT
56495: PUSH
56496: LD_VAR 0 2
56500: NOT
56501: OR
56502: IFFALSE 56506
// exit ;
56504: GO 56570
// for i in mc_bases [ base ] union mc_ape [ base ] do
56506: LD_ADDR_VAR 0 4
56510: PUSH
56511: LD_EXP 59
56515: PUSH
56516: LD_VAR 0 1
56520: ARRAY
56521: PUSH
56522: LD_EXP 88
56526: PUSH
56527: LD_VAR 0 1
56531: ARRAY
56532: UNION
56533: PUSH
56534: FOR_IN
56535: IFFALSE 56568
// if GetTag ( i ) = tag then
56537: LD_VAR 0 4
56541: PPUSH
56542: CALL_OW 110
56546: PUSH
56547: LD_VAR 0 2
56551: EQUAL
56552: IFFALSE 56566
// SetTag ( i , 0 ) ;
56554: LD_VAR 0 4
56558: PPUSH
56559: LD_INT 0
56561: PPUSH
56562: CALL_OW 109
56566: GO 56534
56568: POP
56569: POP
// end ;
56570: LD_VAR 0 3
56574: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56575: LD_INT 0
56577: PPUSH
56578: PPUSH
56579: PPUSH
56580: PPUSH
56581: PPUSH
56582: PPUSH
56583: PPUSH
56584: PPUSH
// if not mc_bases then
56585: LD_EXP 59
56589: NOT
56590: IFFALSE 56594
// exit ;
56592: GO 57052
// for i = 1 to mc_bases do
56594: LD_ADDR_VAR 0 2
56598: PUSH
56599: DOUBLE
56600: LD_INT 1
56602: DEC
56603: ST_TO_ADDR
56604: LD_EXP 59
56608: PUSH
56609: FOR_TO
56610: IFFALSE 57050
// begin tmp := MC_ClassCheckReq ( i ) ;
56612: LD_ADDR_VAR 0 4
56616: PUSH
56617: LD_VAR 0 2
56621: PPUSH
56622: CALL 57057 0 1
56626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56627: LD_ADDR_EXP 100
56631: PUSH
56632: LD_EXP 100
56636: PPUSH
56637: LD_VAR 0 2
56641: PPUSH
56642: LD_VAR 0 4
56646: PPUSH
56647: CALL_OW 1
56651: ST_TO_ADDR
// if not tmp then
56652: LD_VAR 0 4
56656: NOT
56657: IFFALSE 56661
// continue ;
56659: GO 56609
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56661: LD_ADDR_VAR 0 6
56665: PUSH
56666: LD_EXP 59
56670: PUSH
56671: LD_VAR 0 2
56675: ARRAY
56676: PPUSH
56677: LD_INT 2
56679: PUSH
56680: LD_INT 30
56682: PUSH
56683: LD_INT 4
56685: PUSH
56686: EMPTY
56687: LIST
56688: LIST
56689: PUSH
56690: LD_INT 30
56692: PUSH
56693: LD_INT 5
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: PUSH
56700: EMPTY
56701: LIST
56702: LIST
56703: LIST
56704: PPUSH
56705: CALL_OW 72
56709: PUSH
56710: LD_EXP 59
56714: PUSH
56715: LD_VAR 0 2
56719: ARRAY
56720: PPUSH
56721: LD_INT 2
56723: PUSH
56724: LD_INT 30
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: EMPTY
56731: LIST
56732: LIST
56733: PUSH
56734: LD_INT 30
56736: PUSH
56737: LD_INT 1
56739: PUSH
56740: EMPTY
56741: LIST
56742: LIST
56743: PUSH
56744: EMPTY
56745: LIST
56746: LIST
56747: LIST
56748: PPUSH
56749: CALL_OW 72
56753: PUSH
56754: LD_EXP 59
56758: PUSH
56759: LD_VAR 0 2
56763: ARRAY
56764: PPUSH
56765: LD_INT 30
56767: PUSH
56768: LD_INT 3
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PPUSH
56775: CALL_OW 72
56779: PUSH
56780: LD_EXP 59
56784: PUSH
56785: LD_VAR 0 2
56789: ARRAY
56790: PPUSH
56791: LD_INT 2
56793: PUSH
56794: LD_INT 30
56796: PUSH
56797: LD_INT 6
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: PUSH
56804: LD_INT 30
56806: PUSH
56807: LD_INT 7
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: PUSH
56814: LD_INT 30
56816: PUSH
56817: LD_INT 8
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: LIST
56828: LIST
56829: PPUSH
56830: CALL_OW 72
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: LIST
56840: ST_TO_ADDR
// for j = 1 to 4 do
56841: LD_ADDR_VAR 0 3
56845: PUSH
56846: DOUBLE
56847: LD_INT 1
56849: DEC
56850: ST_TO_ADDR
56851: LD_INT 4
56853: PUSH
56854: FOR_TO
56855: IFFALSE 57046
// begin if not tmp [ j ] then
56857: LD_VAR 0 4
56861: PUSH
56862: LD_VAR 0 3
56866: ARRAY
56867: NOT
56868: IFFALSE 56872
// continue ;
56870: GO 56854
// for p in tmp [ j ] do
56872: LD_ADDR_VAR 0 5
56876: PUSH
56877: LD_VAR 0 4
56881: PUSH
56882: LD_VAR 0 3
56886: ARRAY
56887: PUSH
56888: FOR_IN
56889: IFFALSE 57042
// begin if not b [ j ] then
56891: LD_VAR 0 6
56895: PUSH
56896: LD_VAR 0 3
56900: ARRAY
56901: NOT
56902: IFFALSE 56906
// break ;
56904: GO 57042
// e := 0 ;
56906: LD_ADDR_VAR 0 7
56910: PUSH
56911: LD_INT 0
56913: ST_TO_ADDR
// for k in b [ j ] do
56914: LD_ADDR_VAR 0 8
56918: PUSH
56919: LD_VAR 0 6
56923: PUSH
56924: LD_VAR 0 3
56928: ARRAY
56929: PUSH
56930: FOR_IN
56931: IFFALSE 56958
// if IsNotFull ( k ) then
56933: LD_VAR 0 8
56937: PPUSH
56938: CALL 16935 0 1
56942: IFFALSE 56956
// begin e := k ;
56944: LD_ADDR_VAR 0 7
56948: PUSH
56949: LD_VAR 0 8
56953: ST_TO_ADDR
// break ;
56954: GO 56958
// end ;
56956: GO 56930
56958: POP
56959: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56960: LD_VAR 0 7
56964: PUSH
56965: LD_VAR 0 5
56969: PPUSH
56970: LD_VAR 0 7
56974: PPUSH
56975: CALL 49658 0 2
56979: NOT
56980: AND
56981: IFFALSE 57040
// begin if IsInUnit ( p ) then
56983: LD_VAR 0 5
56987: PPUSH
56988: CALL_OW 310
56992: IFFALSE 57003
// ComExitBuilding ( p ) ;
56994: LD_VAR 0 5
56998: PPUSH
56999: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57003: LD_VAR 0 5
57007: PPUSH
57008: LD_VAR 0 7
57012: PPUSH
57013: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57017: LD_VAR 0 5
57021: PPUSH
57022: LD_VAR 0 3
57026: PPUSH
57027: CALL_OW 183
// AddComExitBuilding ( p ) ;
57031: LD_VAR 0 5
57035: PPUSH
57036: CALL_OW 182
// end ; end ;
57040: GO 56888
57042: POP
57043: POP
// end ;
57044: GO 56854
57046: POP
57047: POP
// end ;
57048: GO 56609
57050: POP
57051: POP
// end ;
57052: LD_VAR 0 1
57056: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57057: LD_INT 0
57059: PPUSH
57060: PPUSH
57061: PPUSH
57062: PPUSH
57063: PPUSH
57064: PPUSH
57065: PPUSH
57066: PPUSH
57067: PPUSH
57068: PPUSH
57069: PPUSH
57070: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57071: LD_VAR 0 1
57075: NOT
57076: PUSH
57077: LD_EXP 59
57081: PUSH
57082: LD_VAR 0 1
57086: ARRAY
57087: NOT
57088: OR
57089: PUSH
57090: LD_EXP 59
57094: PUSH
57095: LD_VAR 0 1
57099: ARRAY
57100: PPUSH
57101: LD_INT 2
57103: PUSH
57104: LD_INT 30
57106: PUSH
57107: LD_INT 0
57109: PUSH
57110: EMPTY
57111: LIST
57112: LIST
57113: PUSH
57114: LD_INT 30
57116: PUSH
57117: LD_INT 1
57119: PUSH
57120: EMPTY
57121: LIST
57122: LIST
57123: PUSH
57124: EMPTY
57125: LIST
57126: LIST
57127: LIST
57128: PPUSH
57129: CALL_OW 72
57133: NOT
57134: OR
57135: IFFALSE 57139
// exit ;
57137: GO 60642
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57139: LD_ADDR_VAR 0 4
57143: PUSH
57144: LD_EXP 59
57148: PUSH
57149: LD_VAR 0 1
57153: ARRAY
57154: PPUSH
57155: LD_INT 2
57157: PUSH
57158: LD_INT 25
57160: PUSH
57161: LD_INT 1
57163: PUSH
57164: EMPTY
57165: LIST
57166: LIST
57167: PUSH
57168: LD_INT 25
57170: PUSH
57171: LD_INT 2
57173: PUSH
57174: EMPTY
57175: LIST
57176: LIST
57177: PUSH
57178: LD_INT 25
57180: PUSH
57181: LD_INT 3
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 25
57190: PUSH
57191: LD_INT 4
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: LD_INT 25
57200: PUSH
57201: LD_INT 5
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: LD_INT 25
57210: PUSH
57211: LD_INT 8
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: PUSH
57218: LD_INT 25
57220: PUSH
57221: LD_INT 9
57223: PUSH
57224: EMPTY
57225: LIST
57226: LIST
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: LIST
57234: LIST
57235: LIST
57236: LIST
57237: PPUSH
57238: CALL_OW 72
57242: ST_TO_ADDR
// if not tmp then
57243: LD_VAR 0 4
57247: NOT
57248: IFFALSE 57252
// exit ;
57250: GO 60642
// for i in tmp do
57252: LD_ADDR_VAR 0 3
57256: PUSH
57257: LD_VAR 0 4
57261: PUSH
57262: FOR_IN
57263: IFFALSE 57294
// if GetTag ( i ) then
57265: LD_VAR 0 3
57269: PPUSH
57270: CALL_OW 110
57274: IFFALSE 57292
// tmp := tmp diff i ;
57276: LD_ADDR_VAR 0 4
57280: PUSH
57281: LD_VAR 0 4
57285: PUSH
57286: LD_VAR 0 3
57290: DIFF
57291: ST_TO_ADDR
57292: GO 57262
57294: POP
57295: POP
// if not tmp then
57296: LD_VAR 0 4
57300: NOT
57301: IFFALSE 57305
// exit ;
57303: GO 60642
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57305: LD_ADDR_VAR 0 5
57309: PUSH
57310: LD_EXP 59
57314: PUSH
57315: LD_VAR 0 1
57319: ARRAY
57320: PPUSH
57321: LD_INT 2
57323: PUSH
57324: LD_INT 25
57326: PUSH
57327: LD_INT 1
57329: PUSH
57330: EMPTY
57331: LIST
57332: LIST
57333: PUSH
57334: LD_INT 25
57336: PUSH
57337: LD_INT 5
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: PUSH
57344: LD_INT 25
57346: PUSH
57347: LD_INT 8
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PUSH
57354: LD_INT 25
57356: PUSH
57357: LD_INT 9
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: LIST
57368: LIST
57369: LIST
57370: PPUSH
57371: CALL_OW 72
57375: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57376: LD_ADDR_VAR 0 6
57380: PUSH
57381: LD_EXP 59
57385: PUSH
57386: LD_VAR 0 1
57390: ARRAY
57391: PPUSH
57392: LD_INT 25
57394: PUSH
57395: LD_INT 2
57397: PUSH
57398: EMPTY
57399: LIST
57400: LIST
57401: PPUSH
57402: CALL_OW 72
57406: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57407: LD_ADDR_VAR 0 7
57411: PUSH
57412: LD_EXP 59
57416: PUSH
57417: LD_VAR 0 1
57421: ARRAY
57422: PPUSH
57423: LD_INT 25
57425: PUSH
57426: LD_INT 3
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: PPUSH
57433: CALL_OW 72
57437: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57438: LD_ADDR_VAR 0 8
57442: PUSH
57443: LD_EXP 59
57447: PUSH
57448: LD_VAR 0 1
57452: ARRAY
57453: PPUSH
57454: LD_INT 25
57456: PUSH
57457: LD_INT 4
57459: PUSH
57460: EMPTY
57461: LIST
57462: LIST
57463: PUSH
57464: LD_INT 24
57466: PUSH
57467: LD_INT 251
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: PUSH
57474: EMPTY
57475: LIST
57476: LIST
57477: PPUSH
57478: CALL_OW 72
57482: ST_TO_ADDR
// if mc_scan [ base ] then
57483: LD_EXP 82
57487: PUSH
57488: LD_VAR 0 1
57492: ARRAY
57493: IFFALSE 57954
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57495: LD_ADDR_EXP 101
57499: PUSH
57500: LD_EXP 101
57504: PPUSH
57505: LD_VAR 0 1
57509: PPUSH
57510: LD_INT 4
57512: PPUSH
57513: CALL_OW 1
57517: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57518: LD_ADDR_VAR 0 12
57522: PUSH
57523: LD_EXP 59
57527: PUSH
57528: LD_VAR 0 1
57532: ARRAY
57533: PPUSH
57534: LD_INT 2
57536: PUSH
57537: LD_INT 30
57539: PUSH
57540: LD_INT 4
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: PUSH
57547: LD_INT 30
57549: PUSH
57550: LD_INT 5
57552: PUSH
57553: EMPTY
57554: LIST
57555: LIST
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: LIST
57561: PPUSH
57562: CALL_OW 72
57566: ST_TO_ADDR
// if not b then
57567: LD_VAR 0 12
57571: NOT
57572: IFFALSE 57576
// exit ;
57574: GO 60642
// p := [ ] ;
57576: LD_ADDR_VAR 0 11
57580: PUSH
57581: EMPTY
57582: ST_TO_ADDR
// if sci >= 2 then
57583: LD_VAR 0 8
57587: PUSH
57588: LD_INT 2
57590: GREATEREQUAL
57591: IFFALSE 57622
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57593: LD_ADDR_VAR 0 8
57597: PUSH
57598: LD_VAR 0 8
57602: PUSH
57603: LD_INT 1
57605: ARRAY
57606: PUSH
57607: LD_VAR 0 8
57611: PUSH
57612: LD_INT 2
57614: ARRAY
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: ST_TO_ADDR
57620: GO 57683
// if sci = 1 then
57622: LD_VAR 0 8
57626: PUSH
57627: LD_INT 1
57629: EQUAL
57630: IFFALSE 57651
// sci := [ sci [ 1 ] ] else
57632: LD_ADDR_VAR 0 8
57636: PUSH
57637: LD_VAR 0 8
57641: PUSH
57642: LD_INT 1
57644: ARRAY
57645: PUSH
57646: EMPTY
57647: LIST
57648: ST_TO_ADDR
57649: GO 57683
// if sci = 0 then
57651: LD_VAR 0 8
57655: PUSH
57656: LD_INT 0
57658: EQUAL
57659: IFFALSE 57683
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57661: LD_ADDR_VAR 0 11
57665: PUSH
57666: LD_VAR 0 4
57670: PPUSH
57671: LD_INT 4
57673: PPUSH
57674: CALL 49521 0 2
57678: PUSH
57679: LD_INT 1
57681: ARRAY
57682: ST_TO_ADDR
// if eng > 4 then
57683: LD_VAR 0 6
57687: PUSH
57688: LD_INT 4
57690: GREATER
57691: IFFALSE 57737
// for i = eng downto 4 do
57693: LD_ADDR_VAR 0 3
57697: PUSH
57698: DOUBLE
57699: LD_VAR 0 6
57703: INC
57704: ST_TO_ADDR
57705: LD_INT 4
57707: PUSH
57708: FOR_DOWNTO
57709: IFFALSE 57735
// eng := eng diff eng [ i ] ;
57711: LD_ADDR_VAR 0 6
57715: PUSH
57716: LD_VAR 0 6
57720: PUSH
57721: LD_VAR 0 6
57725: PUSH
57726: LD_VAR 0 3
57730: ARRAY
57731: DIFF
57732: ST_TO_ADDR
57733: GO 57708
57735: POP
57736: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57737: LD_ADDR_VAR 0 4
57741: PUSH
57742: LD_VAR 0 4
57746: PUSH
57747: LD_VAR 0 5
57751: PUSH
57752: LD_VAR 0 6
57756: UNION
57757: PUSH
57758: LD_VAR 0 7
57762: UNION
57763: PUSH
57764: LD_VAR 0 8
57768: UNION
57769: DIFF
57770: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57771: LD_ADDR_VAR 0 13
57775: PUSH
57776: LD_EXP 59
57780: PUSH
57781: LD_VAR 0 1
57785: ARRAY
57786: PPUSH
57787: LD_INT 2
57789: PUSH
57790: LD_INT 30
57792: PUSH
57793: LD_INT 32
57795: PUSH
57796: EMPTY
57797: LIST
57798: LIST
57799: PUSH
57800: LD_INT 30
57802: PUSH
57803: LD_INT 31
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: PUSH
57810: EMPTY
57811: LIST
57812: LIST
57813: LIST
57814: PPUSH
57815: CALL_OW 72
57819: PUSH
57820: LD_EXP 59
57824: PUSH
57825: LD_VAR 0 1
57829: ARRAY
57830: PPUSH
57831: LD_INT 2
57833: PUSH
57834: LD_INT 30
57836: PUSH
57837: LD_INT 4
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: PUSH
57844: LD_INT 30
57846: PUSH
57847: LD_INT 5
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: LIST
57858: PPUSH
57859: CALL_OW 72
57863: PUSH
57864: LD_INT 6
57866: MUL
57867: PLUS
57868: ST_TO_ADDR
// if bcount < tmp then
57869: LD_VAR 0 13
57873: PUSH
57874: LD_VAR 0 4
57878: LESS
57879: IFFALSE 57925
// for i = tmp downto bcount do
57881: LD_ADDR_VAR 0 3
57885: PUSH
57886: DOUBLE
57887: LD_VAR 0 4
57891: INC
57892: ST_TO_ADDR
57893: LD_VAR 0 13
57897: PUSH
57898: FOR_DOWNTO
57899: IFFALSE 57923
// tmp := Delete ( tmp , tmp ) ;
57901: LD_ADDR_VAR 0 4
57905: PUSH
57906: LD_VAR 0 4
57910: PPUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: CALL_OW 3
57920: ST_TO_ADDR
57921: GO 57898
57923: POP
57924: POP
// result := [ tmp , 0 , 0 , p ] ;
57925: LD_ADDR_VAR 0 2
57929: PUSH
57930: LD_VAR 0 4
57934: PUSH
57935: LD_INT 0
57937: PUSH
57938: LD_INT 0
57940: PUSH
57941: LD_VAR 0 11
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: LIST
57950: LIST
57951: ST_TO_ADDR
// exit ;
57952: GO 60642
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57954: LD_EXP 59
57958: PUSH
57959: LD_VAR 0 1
57963: ARRAY
57964: PPUSH
57965: LD_INT 2
57967: PUSH
57968: LD_INT 30
57970: PUSH
57971: LD_INT 6
57973: PUSH
57974: EMPTY
57975: LIST
57976: LIST
57977: PUSH
57978: LD_INT 30
57980: PUSH
57981: LD_INT 7
57983: PUSH
57984: EMPTY
57985: LIST
57986: LIST
57987: PUSH
57988: LD_INT 30
57990: PUSH
57991: LD_INT 8
57993: PUSH
57994: EMPTY
57995: LIST
57996: LIST
57997: PUSH
57998: EMPTY
57999: LIST
58000: LIST
58001: LIST
58002: LIST
58003: PPUSH
58004: CALL_OW 72
58008: NOT
58009: PUSH
58010: LD_EXP 59
58014: PUSH
58015: LD_VAR 0 1
58019: ARRAY
58020: PPUSH
58021: LD_INT 30
58023: PUSH
58024: LD_INT 3
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PPUSH
58031: CALL_OW 72
58035: NOT
58036: AND
58037: IFFALSE 58109
// begin if eng = tmp then
58039: LD_VAR 0 6
58043: PUSH
58044: LD_VAR 0 4
58048: EQUAL
58049: IFFALSE 58053
// exit ;
58051: GO 60642
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58053: LD_ADDR_EXP 101
58057: PUSH
58058: LD_EXP 101
58062: PPUSH
58063: LD_VAR 0 1
58067: PPUSH
58068: LD_INT 1
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58076: LD_ADDR_VAR 0 2
58080: PUSH
58081: LD_INT 0
58083: PUSH
58084: LD_VAR 0 4
58088: PUSH
58089: LD_VAR 0 6
58093: DIFF
58094: PUSH
58095: LD_INT 0
58097: PUSH
58098: LD_INT 0
58100: PUSH
58101: EMPTY
58102: LIST
58103: LIST
58104: LIST
58105: LIST
58106: ST_TO_ADDR
// exit ;
58107: GO 60642
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58109: LD_EXP 86
58113: PUSH
58114: LD_EXP 85
58118: PUSH
58119: LD_VAR 0 1
58123: ARRAY
58124: ARRAY
58125: PUSH
58126: LD_EXP 59
58130: PUSH
58131: LD_VAR 0 1
58135: ARRAY
58136: PPUSH
58137: LD_INT 2
58139: PUSH
58140: LD_INT 30
58142: PUSH
58143: LD_INT 6
58145: PUSH
58146: EMPTY
58147: LIST
58148: LIST
58149: PUSH
58150: LD_INT 30
58152: PUSH
58153: LD_INT 7
58155: PUSH
58156: EMPTY
58157: LIST
58158: LIST
58159: PUSH
58160: LD_INT 30
58162: PUSH
58163: LD_INT 8
58165: PUSH
58166: EMPTY
58167: LIST
58168: LIST
58169: PUSH
58170: EMPTY
58171: LIST
58172: LIST
58173: LIST
58174: LIST
58175: PPUSH
58176: CALL_OW 72
58180: AND
58181: PUSH
58182: LD_EXP 59
58186: PUSH
58187: LD_VAR 0 1
58191: ARRAY
58192: PPUSH
58193: LD_INT 30
58195: PUSH
58196: LD_INT 3
58198: PUSH
58199: EMPTY
58200: LIST
58201: LIST
58202: PPUSH
58203: CALL_OW 72
58207: NOT
58208: AND
58209: IFFALSE 58423
// begin if sci >= 6 then
58211: LD_VAR 0 8
58215: PUSH
58216: LD_INT 6
58218: GREATEREQUAL
58219: IFFALSE 58223
// exit ;
58221: GO 60642
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58223: LD_ADDR_EXP 101
58227: PUSH
58228: LD_EXP 101
58232: PPUSH
58233: LD_VAR 0 1
58237: PPUSH
58238: LD_INT 2
58240: PPUSH
58241: CALL_OW 1
58245: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58246: LD_ADDR_VAR 0 9
58250: PUSH
58251: LD_VAR 0 4
58255: PUSH
58256: LD_VAR 0 8
58260: DIFF
58261: PPUSH
58262: LD_INT 4
58264: PPUSH
58265: CALL 49521 0 2
58269: ST_TO_ADDR
// p := [ ] ;
58270: LD_ADDR_VAR 0 11
58274: PUSH
58275: EMPTY
58276: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58277: LD_VAR 0 8
58281: PUSH
58282: LD_INT 6
58284: LESS
58285: PUSH
58286: LD_VAR 0 9
58290: PUSH
58291: LD_INT 6
58293: GREATER
58294: AND
58295: IFFALSE 58376
// begin for i = 1 to 6 - sci do
58297: LD_ADDR_VAR 0 3
58301: PUSH
58302: DOUBLE
58303: LD_INT 1
58305: DEC
58306: ST_TO_ADDR
58307: LD_INT 6
58309: PUSH
58310: LD_VAR 0 8
58314: MINUS
58315: PUSH
58316: FOR_TO
58317: IFFALSE 58372
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58319: LD_ADDR_VAR 0 11
58323: PUSH
58324: LD_VAR 0 11
58328: PPUSH
58329: LD_VAR 0 11
58333: PUSH
58334: LD_INT 1
58336: PLUS
58337: PPUSH
58338: LD_VAR 0 9
58342: PUSH
58343: LD_INT 1
58345: ARRAY
58346: PPUSH
58347: CALL_OW 2
58351: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58352: LD_ADDR_VAR 0 9
58356: PUSH
58357: LD_VAR 0 9
58361: PPUSH
58362: LD_INT 1
58364: PPUSH
58365: CALL_OW 3
58369: ST_TO_ADDR
// end ;
58370: GO 58316
58372: POP
58373: POP
// end else
58374: GO 58396
// if sort then
58376: LD_VAR 0 9
58380: IFFALSE 58396
// p := sort [ 1 ] ;
58382: LD_ADDR_VAR 0 11
58386: PUSH
58387: LD_VAR 0 9
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58396: LD_ADDR_VAR 0 2
58400: PUSH
58401: LD_INT 0
58403: PUSH
58404: LD_INT 0
58406: PUSH
58407: LD_INT 0
58409: PUSH
58410: LD_VAR 0 11
58414: PUSH
58415: EMPTY
58416: LIST
58417: LIST
58418: LIST
58419: LIST
58420: ST_TO_ADDR
// exit ;
58421: GO 60642
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58423: LD_EXP 86
58427: PUSH
58428: LD_EXP 85
58432: PUSH
58433: LD_VAR 0 1
58437: ARRAY
58438: ARRAY
58439: PUSH
58440: LD_EXP 59
58444: PUSH
58445: LD_VAR 0 1
58449: ARRAY
58450: PPUSH
58451: LD_INT 2
58453: PUSH
58454: LD_INT 30
58456: PUSH
58457: LD_INT 6
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: PUSH
58464: LD_INT 30
58466: PUSH
58467: LD_INT 7
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: PUSH
58474: LD_INT 30
58476: PUSH
58477: LD_INT 8
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: LIST
58488: LIST
58489: PPUSH
58490: CALL_OW 72
58494: AND
58495: PUSH
58496: LD_EXP 59
58500: PUSH
58501: LD_VAR 0 1
58505: ARRAY
58506: PPUSH
58507: LD_INT 30
58509: PUSH
58510: LD_INT 3
58512: PUSH
58513: EMPTY
58514: LIST
58515: LIST
58516: PPUSH
58517: CALL_OW 72
58521: AND
58522: IFFALSE 59256
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58524: LD_ADDR_EXP 101
58528: PUSH
58529: LD_EXP 101
58533: PPUSH
58534: LD_VAR 0 1
58538: PPUSH
58539: LD_INT 3
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58547: LD_ADDR_VAR 0 2
58551: PUSH
58552: LD_INT 0
58554: PUSH
58555: LD_INT 0
58557: PUSH
58558: LD_INT 0
58560: PUSH
58561: LD_INT 0
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: LIST
58568: LIST
58569: ST_TO_ADDR
// if not eng then
58570: LD_VAR 0 6
58574: NOT
58575: IFFALSE 58638
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58577: LD_ADDR_VAR 0 11
58581: PUSH
58582: LD_VAR 0 4
58586: PPUSH
58587: LD_INT 2
58589: PPUSH
58590: CALL 49521 0 2
58594: PUSH
58595: LD_INT 1
58597: ARRAY
58598: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58599: LD_ADDR_VAR 0 2
58603: PUSH
58604: LD_VAR 0 2
58608: PPUSH
58609: LD_INT 2
58611: PPUSH
58612: LD_VAR 0 11
58616: PPUSH
58617: CALL_OW 1
58621: ST_TO_ADDR
// tmp := tmp diff p ;
58622: LD_ADDR_VAR 0 4
58626: PUSH
58627: LD_VAR 0 4
58631: PUSH
58632: LD_VAR 0 11
58636: DIFF
58637: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58638: LD_VAR 0 4
58642: PUSH
58643: LD_VAR 0 8
58647: PUSH
58648: LD_INT 6
58650: LESS
58651: AND
58652: IFFALSE 58840
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58654: LD_ADDR_VAR 0 9
58658: PUSH
58659: LD_VAR 0 4
58663: PUSH
58664: LD_VAR 0 8
58668: PUSH
58669: LD_VAR 0 7
58673: UNION
58674: DIFF
58675: PPUSH
58676: LD_INT 4
58678: PPUSH
58679: CALL 49521 0 2
58683: ST_TO_ADDR
// p := [ ] ;
58684: LD_ADDR_VAR 0 11
58688: PUSH
58689: EMPTY
58690: ST_TO_ADDR
// if sort then
58691: LD_VAR 0 9
58695: IFFALSE 58811
// for i = 1 to 6 - sci do
58697: LD_ADDR_VAR 0 3
58701: PUSH
58702: DOUBLE
58703: LD_INT 1
58705: DEC
58706: ST_TO_ADDR
58707: LD_INT 6
58709: PUSH
58710: LD_VAR 0 8
58714: MINUS
58715: PUSH
58716: FOR_TO
58717: IFFALSE 58809
// begin if i = sort then
58719: LD_VAR 0 3
58723: PUSH
58724: LD_VAR 0 9
58728: EQUAL
58729: IFFALSE 58733
// break ;
58731: GO 58809
// if GetClass ( i ) = 4 then
58733: LD_VAR 0 3
58737: PPUSH
58738: CALL_OW 257
58742: PUSH
58743: LD_INT 4
58745: EQUAL
58746: IFFALSE 58750
// continue ;
58748: GO 58716
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58750: LD_ADDR_VAR 0 11
58754: PUSH
58755: LD_VAR 0 11
58759: PPUSH
58760: LD_VAR 0 11
58764: PUSH
58765: LD_INT 1
58767: PLUS
58768: PPUSH
58769: LD_VAR 0 9
58773: PUSH
58774: LD_VAR 0 3
58778: ARRAY
58779: PPUSH
58780: CALL_OW 2
58784: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58785: LD_ADDR_VAR 0 4
58789: PUSH
58790: LD_VAR 0 4
58794: PUSH
58795: LD_VAR 0 9
58799: PUSH
58800: LD_VAR 0 3
58804: ARRAY
58805: DIFF
58806: ST_TO_ADDR
// end ;
58807: GO 58716
58809: POP
58810: POP
// if p then
58811: LD_VAR 0 11
58815: IFFALSE 58840
// result := Replace ( result , 4 , p ) ;
58817: LD_ADDR_VAR 0 2
58821: PUSH
58822: LD_VAR 0 2
58826: PPUSH
58827: LD_INT 4
58829: PPUSH
58830: LD_VAR 0 11
58834: PPUSH
58835: CALL_OW 1
58839: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58840: LD_VAR 0 4
58844: PUSH
58845: LD_VAR 0 7
58849: PUSH
58850: LD_INT 6
58852: LESS
58853: AND
58854: IFFALSE 59042
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58856: LD_ADDR_VAR 0 9
58860: PUSH
58861: LD_VAR 0 4
58865: PUSH
58866: LD_VAR 0 8
58870: PUSH
58871: LD_VAR 0 7
58875: UNION
58876: DIFF
58877: PPUSH
58878: LD_INT 3
58880: PPUSH
58881: CALL 49521 0 2
58885: ST_TO_ADDR
// p := [ ] ;
58886: LD_ADDR_VAR 0 11
58890: PUSH
58891: EMPTY
58892: ST_TO_ADDR
// if sort then
58893: LD_VAR 0 9
58897: IFFALSE 59013
// for i = 1 to 6 - mech do
58899: LD_ADDR_VAR 0 3
58903: PUSH
58904: DOUBLE
58905: LD_INT 1
58907: DEC
58908: ST_TO_ADDR
58909: LD_INT 6
58911: PUSH
58912: LD_VAR 0 7
58916: MINUS
58917: PUSH
58918: FOR_TO
58919: IFFALSE 59011
// begin if i = sort then
58921: LD_VAR 0 3
58925: PUSH
58926: LD_VAR 0 9
58930: EQUAL
58931: IFFALSE 58935
// break ;
58933: GO 59011
// if GetClass ( i ) = 3 then
58935: LD_VAR 0 3
58939: PPUSH
58940: CALL_OW 257
58944: PUSH
58945: LD_INT 3
58947: EQUAL
58948: IFFALSE 58952
// continue ;
58950: GO 58918
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58952: LD_ADDR_VAR 0 11
58956: PUSH
58957: LD_VAR 0 11
58961: PPUSH
58962: LD_VAR 0 11
58966: PUSH
58967: LD_INT 1
58969: PLUS
58970: PPUSH
58971: LD_VAR 0 9
58975: PUSH
58976: LD_VAR 0 3
58980: ARRAY
58981: PPUSH
58982: CALL_OW 2
58986: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58987: LD_ADDR_VAR 0 4
58991: PUSH
58992: LD_VAR 0 4
58996: PUSH
58997: LD_VAR 0 9
59001: PUSH
59002: LD_VAR 0 3
59006: ARRAY
59007: DIFF
59008: ST_TO_ADDR
// end ;
59009: GO 58918
59011: POP
59012: POP
// if p then
59013: LD_VAR 0 11
59017: IFFALSE 59042
// result := Replace ( result , 3 , p ) ;
59019: LD_ADDR_VAR 0 2
59023: PUSH
59024: LD_VAR 0 2
59028: PPUSH
59029: LD_INT 3
59031: PPUSH
59032: LD_VAR 0 11
59036: PPUSH
59037: CALL_OW 1
59041: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59042: LD_VAR 0 4
59046: PUSH
59047: LD_INT 6
59049: GREATER
59050: PUSH
59051: LD_VAR 0 6
59055: PUSH
59056: LD_INT 6
59058: LESS
59059: AND
59060: IFFALSE 59254
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59062: LD_ADDR_VAR 0 9
59066: PUSH
59067: LD_VAR 0 4
59071: PUSH
59072: LD_VAR 0 8
59076: PUSH
59077: LD_VAR 0 7
59081: UNION
59082: PUSH
59083: LD_VAR 0 6
59087: UNION
59088: DIFF
59089: PPUSH
59090: LD_INT 2
59092: PPUSH
59093: CALL 49521 0 2
59097: ST_TO_ADDR
// p := [ ] ;
59098: LD_ADDR_VAR 0 11
59102: PUSH
59103: EMPTY
59104: ST_TO_ADDR
// if sort then
59105: LD_VAR 0 9
59109: IFFALSE 59225
// for i = 1 to 6 - eng do
59111: LD_ADDR_VAR 0 3
59115: PUSH
59116: DOUBLE
59117: LD_INT 1
59119: DEC
59120: ST_TO_ADDR
59121: LD_INT 6
59123: PUSH
59124: LD_VAR 0 6
59128: MINUS
59129: PUSH
59130: FOR_TO
59131: IFFALSE 59223
// begin if i = sort then
59133: LD_VAR 0 3
59137: PUSH
59138: LD_VAR 0 9
59142: EQUAL
59143: IFFALSE 59147
// break ;
59145: GO 59223
// if GetClass ( i ) = 2 then
59147: LD_VAR 0 3
59151: PPUSH
59152: CALL_OW 257
59156: PUSH
59157: LD_INT 2
59159: EQUAL
59160: IFFALSE 59164
// continue ;
59162: GO 59130
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59164: LD_ADDR_VAR 0 11
59168: PUSH
59169: LD_VAR 0 11
59173: PPUSH
59174: LD_VAR 0 11
59178: PUSH
59179: LD_INT 1
59181: PLUS
59182: PPUSH
59183: LD_VAR 0 9
59187: PUSH
59188: LD_VAR 0 3
59192: ARRAY
59193: PPUSH
59194: CALL_OW 2
59198: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59199: LD_ADDR_VAR 0 4
59203: PUSH
59204: LD_VAR 0 4
59208: PUSH
59209: LD_VAR 0 9
59213: PUSH
59214: LD_VAR 0 3
59218: ARRAY
59219: DIFF
59220: ST_TO_ADDR
// end ;
59221: GO 59130
59223: POP
59224: POP
// if p then
59225: LD_VAR 0 11
59229: IFFALSE 59254
// result := Replace ( result , 2 , p ) ;
59231: LD_ADDR_VAR 0 2
59235: PUSH
59236: LD_VAR 0 2
59240: PPUSH
59241: LD_INT 2
59243: PPUSH
59244: LD_VAR 0 11
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// end ; exit ;
59254: GO 60642
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59256: LD_EXP 86
59260: PUSH
59261: LD_EXP 85
59265: PUSH
59266: LD_VAR 0 1
59270: ARRAY
59271: ARRAY
59272: NOT
59273: PUSH
59274: LD_EXP 59
59278: PUSH
59279: LD_VAR 0 1
59283: ARRAY
59284: PPUSH
59285: LD_INT 30
59287: PUSH
59288: LD_INT 3
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: PPUSH
59295: CALL_OW 72
59299: AND
59300: PUSH
59301: LD_EXP 64
59305: PUSH
59306: LD_VAR 0 1
59310: ARRAY
59311: AND
59312: IFFALSE 59920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59314: LD_ADDR_EXP 101
59318: PUSH
59319: LD_EXP 101
59323: PPUSH
59324: LD_VAR 0 1
59328: PPUSH
59329: LD_INT 5
59331: PPUSH
59332: CALL_OW 1
59336: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59337: LD_ADDR_VAR 0 2
59341: PUSH
59342: LD_INT 0
59344: PUSH
59345: LD_INT 0
59347: PUSH
59348: LD_INT 0
59350: PUSH
59351: LD_INT 0
59353: PUSH
59354: EMPTY
59355: LIST
59356: LIST
59357: LIST
59358: LIST
59359: ST_TO_ADDR
// if sci > 1 then
59360: LD_VAR 0 8
59364: PUSH
59365: LD_INT 1
59367: GREATER
59368: IFFALSE 59396
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59370: LD_ADDR_VAR 0 4
59374: PUSH
59375: LD_VAR 0 4
59379: PUSH
59380: LD_VAR 0 8
59384: PUSH
59385: LD_VAR 0 8
59389: PUSH
59390: LD_INT 1
59392: ARRAY
59393: DIFF
59394: DIFF
59395: ST_TO_ADDR
// if tmp and not sci then
59396: LD_VAR 0 4
59400: PUSH
59401: LD_VAR 0 8
59405: NOT
59406: AND
59407: IFFALSE 59476
// begin sort := SortBySkill ( tmp , 4 ) ;
59409: LD_ADDR_VAR 0 9
59413: PUSH
59414: LD_VAR 0 4
59418: PPUSH
59419: LD_INT 4
59421: PPUSH
59422: CALL 49521 0 2
59426: ST_TO_ADDR
// if sort then
59427: LD_VAR 0 9
59431: IFFALSE 59447
// p := sort [ 1 ] ;
59433: LD_ADDR_VAR 0 11
59437: PUSH
59438: LD_VAR 0 9
59442: PUSH
59443: LD_INT 1
59445: ARRAY
59446: ST_TO_ADDR
// if p then
59447: LD_VAR 0 11
59451: IFFALSE 59476
// result := Replace ( result , 4 , p ) ;
59453: LD_ADDR_VAR 0 2
59457: PUSH
59458: LD_VAR 0 2
59462: PPUSH
59463: LD_INT 4
59465: PPUSH
59466: LD_VAR 0 11
59470: PPUSH
59471: CALL_OW 1
59475: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59476: LD_ADDR_VAR 0 4
59480: PUSH
59481: LD_VAR 0 4
59485: PUSH
59486: LD_VAR 0 7
59490: DIFF
59491: ST_TO_ADDR
// if tmp and mech < 6 then
59492: LD_VAR 0 4
59496: PUSH
59497: LD_VAR 0 7
59501: PUSH
59502: LD_INT 6
59504: LESS
59505: AND
59506: IFFALSE 59694
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59508: LD_ADDR_VAR 0 9
59512: PUSH
59513: LD_VAR 0 4
59517: PUSH
59518: LD_VAR 0 8
59522: PUSH
59523: LD_VAR 0 7
59527: UNION
59528: DIFF
59529: PPUSH
59530: LD_INT 3
59532: PPUSH
59533: CALL 49521 0 2
59537: ST_TO_ADDR
// p := [ ] ;
59538: LD_ADDR_VAR 0 11
59542: PUSH
59543: EMPTY
59544: ST_TO_ADDR
// if sort then
59545: LD_VAR 0 9
59549: IFFALSE 59665
// for i = 1 to 6 - mech do
59551: LD_ADDR_VAR 0 3
59555: PUSH
59556: DOUBLE
59557: LD_INT 1
59559: DEC
59560: ST_TO_ADDR
59561: LD_INT 6
59563: PUSH
59564: LD_VAR 0 7
59568: MINUS
59569: PUSH
59570: FOR_TO
59571: IFFALSE 59663
// begin if i = sort then
59573: LD_VAR 0 3
59577: PUSH
59578: LD_VAR 0 9
59582: EQUAL
59583: IFFALSE 59587
// break ;
59585: GO 59663
// if GetClass ( i ) = 3 then
59587: LD_VAR 0 3
59591: PPUSH
59592: CALL_OW 257
59596: PUSH
59597: LD_INT 3
59599: EQUAL
59600: IFFALSE 59604
// continue ;
59602: GO 59570
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59604: LD_ADDR_VAR 0 11
59608: PUSH
59609: LD_VAR 0 11
59613: PPUSH
59614: LD_VAR 0 11
59618: PUSH
59619: LD_INT 1
59621: PLUS
59622: PPUSH
59623: LD_VAR 0 9
59627: PUSH
59628: LD_VAR 0 3
59632: ARRAY
59633: PPUSH
59634: CALL_OW 2
59638: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59639: LD_ADDR_VAR 0 4
59643: PUSH
59644: LD_VAR 0 4
59648: PUSH
59649: LD_VAR 0 9
59653: PUSH
59654: LD_VAR 0 3
59658: ARRAY
59659: DIFF
59660: ST_TO_ADDR
// end ;
59661: GO 59570
59663: POP
59664: POP
// if p then
59665: LD_VAR 0 11
59669: IFFALSE 59694
// result := Replace ( result , 3 , p ) ;
59671: LD_ADDR_VAR 0 2
59675: PUSH
59676: LD_VAR 0 2
59680: PPUSH
59681: LD_INT 3
59683: PPUSH
59684: LD_VAR 0 11
59688: PPUSH
59689: CALL_OW 1
59693: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59694: LD_ADDR_VAR 0 4
59698: PUSH
59699: LD_VAR 0 4
59703: PUSH
59704: LD_VAR 0 6
59708: DIFF
59709: ST_TO_ADDR
// if tmp and eng < 6 then
59710: LD_VAR 0 4
59714: PUSH
59715: LD_VAR 0 6
59719: PUSH
59720: LD_INT 6
59722: LESS
59723: AND
59724: IFFALSE 59918
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59726: LD_ADDR_VAR 0 9
59730: PUSH
59731: LD_VAR 0 4
59735: PUSH
59736: LD_VAR 0 8
59740: PUSH
59741: LD_VAR 0 7
59745: UNION
59746: PUSH
59747: LD_VAR 0 6
59751: UNION
59752: DIFF
59753: PPUSH
59754: LD_INT 2
59756: PPUSH
59757: CALL 49521 0 2
59761: ST_TO_ADDR
// p := [ ] ;
59762: LD_ADDR_VAR 0 11
59766: PUSH
59767: EMPTY
59768: ST_TO_ADDR
// if sort then
59769: LD_VAR 0 9
59773: IFFALSE 59889
// for i = 1 to 6 - eng do
59775: LD_ADDR_VAR 0 3
59779: PUSH
59780: DOUBLE
59781: LD_INT 1
59783: DEC
59784: ST_TO_ADDR
59785: LD_INT 6
59787: PUSH
59788: LD_VAR 0 6
59792: MINUS
59793: PUSH
59794: FOR_TO
59795: IFFALSE 59887
// begin if i = sort then
59797: LD_VAR 0 3
59801: PUSH
59802: LD_VAR 0 9
59806: EQUAL
59807: IFFALSE 59811
// break ;
59809: GO 59887
// if GetClass ( i ) = 2 then
59811: LD_VAR 0 3
59815: PPUSH
59816: CALL_OW 257
59820: PUSH
59821: LD_INT 2
59823: EQUAL
59824: IFFALSE 59828
// continue ;
59826: GO 59794
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59828: LD_ADDR_VAR 0 11
59832: PUSH
59833: LD_VAR 0 11
59837: PPUSH
59838: LD_VAR 0 11
59842: PUSH
59843: LD_INT 1
59845: PLUS
59846: PPUSH
59847: LD_VAR 0 9
59851: PUSH
59852: LD_VAR 0 3
59856: ARRAY
59857: PPUSH
59858: CALL_OW 2
59862: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59863: LD_ADDR_VAR 0 4
59867: PUSH
59868: LD_VAR 0 4
59872: PUSH
59873: LD_VAR 0 9
59877: PUSH
59878: LD_VAR 0 3
59882: ARRAY
59883: DIFF
59884: ST_TO_ADDR
// end ;
59885: GO 59794
59887: POP
59888: POP
// if p then
59889: LD_VAR 0 11
59893: IFFALSE 59918
// result := Replace ( result , 2 , p ) ;
59895: LD_ADDR_VAR 0 2
59899: PUSH
59900: LD_VAR 0 2
59904: PPUSH
59905: LD_INT 2
59907: PPUSH
59908: LD_VAR 0 11
59912: PPUSH
59913: CALL_OW 1
59917: ST_TO_ADDR
// end ; exit ;
59918: GO 60642
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59920: LD_EXP 86
59924: PUSH
59925: LD_EXP 85
59929: PUSH
59930: LD_VAR 0 1
59934: ARRAY
59935: ARRAY
59936: NOT
59937: PUSH
59938: LD_EXP 59
59942: PUSH
59943: LD_VAR 0 1
59947: ARRAY
59948: PPUSH
59949: LD_INT 30
59951: PUSH
59952: LD_INT 3
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: PPUSH
59959: CALL_OW 72
59963: AND
59964: PUSH
59965: LD_EXP 64
59969: PUSH
59970: LD_VAR 0 1
59974: ARRAY
59975: NOT
59976: AND
59977: IFFALSE 60642
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59979: LD_ADDR_EXP 101
59983: PUSH
59984: LD_EXP 101
59988: PPUSH
59989: LD_VAR 0 1
59993: PPUSH
59994: LD_INT 6
59996: PPUSH
59997: CALL_OW 1
60001: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60002: LD_ADDR_VAR 0 2
60006: PUSH
60007: LD_INT 0
60009: PUSH
60010: LD_INT 0
60012: PUSH
60013: LD_INT 0
60015: PUSH
60016: LD_INT 0
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: LIST
60023: LIST
60024: ST_TO_ADDR
// if sci >= 1 then
60025: LD_VAR 0 8
60029: PUSH
60030: LD_INT 1
60032: GREATEREQUAL
60033: IFFALSE 60055
// tmp := tmp diff sci [ 1 ] ;
60035: LD_ADDR_VAR 0 4
60039: PUSH
60040: LD_VAR 0 4
60044: PUSH
60045: LD_VAR 0 8
60049: PUSH
60050: LD_INT 1
60052: ARRAY
60053: DIFF
60054: ST_TO_ADDR
// if tmp and not sci then
60055: LD_VAR 0 4
60059: PUSH
60060: LD_VAR 0 8
60064: NOT
60065: AND
60066: IFFALSE 60135
// begin sort := SortBySkill ( tmp , 4 ) ;
60068: LD_ADDR_VAR 0 9
60072: PUSH
60073: LD_VAR 0 4
60077: PPUSH
60078: LD_INT 4
60080: PPUSH
60081: CALL 49521 0 2
60085: ST_TO_ADDR
// if sort then
60086: LD_VAR 0 9
60090: IFFALSE 60106
// p := sort [ 1 ] ;
60092: LD_ADDR_VAR 0 11
60096: PUSH
60097: LD_VAR 0 9
60101: PUSH
60102: LD_INT 1
60104: ARRAY
60105: ST_TO_ADDR
// if p then
60106: LD_VAR 0 11
60110: IFFALSE 60135
// result := Replace ( result , 4 , p ) ;
60112: LD_ADDR_VAR 0 2
60116: PUSH
60117: LD_VAR 0 2
60121: PPUSH
60122: LD_INT 4
60124: PPUSH
60125: LD_VAR 0 11
60129: PPUSH
60130: CALL_OW 1
60134: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60135: LD_ADDR_VAR 0 4
60139: PUSH
60140: LD_VAR 0 4
60144: PUSH
60145: LD_VAR 0 7
60149: DIFF
60150: ST_TO_ADDR
// if tmp and mech < 6 then
60151: LD_VAR 0 4
60155: PUSH
60156: LD_VAR 0 7
60160: PUSH
60161: LD_INT 6
60163: LESS
60164: AND
60165: IFFALSE 60347
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60167: LD_ADDR_VAR 0 9
60171: PUSH
60172: LD_VAR 0 4
60176: PUSH
60177: LD_VAR 0 7
60181: DIFF
60182: PPUSH
60183: LD_INT 3
60185: PPUSH
60186: CALL 49521 0 2
60190: ST_TO_ADDR
// p := [ ] ;
60191: LD_ADDR_VAR 0 11
60195: PUSH
60196: EMPTY
60197: ST_TO_ADDR
// if sort then
60198: LD_VAR 0 9
60202: IFFALSE 60318
// for i = 1 to 6 - mech do
60204: LD_ADDR_VAR 0 3
60208: PUSH
60209: DOUBLE
60210: LD_INT 1
60212: DEC
60213: ST_TO_ADDR
60214: LD_INT 6
60216: PUSH
60217: LD_VAR 0 7
60221: MINUS
60222: PUSH
60223: FOR_TO
60224: IFFALSE 60316
// begin if i = sort then
60226: LD_VAR 0 3
60230: PUSH
60231: LD_VAR 0 9
60235: EQUAL
60236: IFFALSE 60240
// break ;
60238: GO 60316
// if GetClass ( i ) = 3 then
60240: LD_VAR 0 3
60244: PPUSH
60245: CALL_OW 257
60249: PUSH
60250: LD_INT 3
60252: EQUAL
60253: IFFALSE 60257
// continue ;
60255: GO 60223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60257: LD_ADDR_VAR 0 11
60261: PUSH
60262: LD_VAR 0 11
60266: PPUSH
60267: LD_VAR 0 11
60271: PUSH
60272: LD_INT 1
60274: PLUS
60275: PPUSH
60276: LD_VAR 0 9
60280: PUSH
60281: LD_VAR 0 3
60285: ARRAY
60286: PPUSH
60287: CALL_OW 2
60291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60292: LD_ADDR_VAR 0 4
60296: PUSH
60297: LD_VAR 0 4
60301: PUSH
60302: LD_VAR 0 9
60306: PUSH
60307: LD_VAR 0 3
60311: ARRAY
60312: DIFF
60313: ST_TO_ADDR
// end ;
60314: GO 60223
60316: POP
60317: POP
// if p then
60318: LD_VAR 0 11
60322: IFFALSE 60347
// result := Replace ( result , 3 , p ) ;
60324: LD_ADDR_VAR 0 2
60328: PUSH
60329: LD_VAR 0 2
60333: PPUSH
60334: LD_INT 3
60336: PPUSH
60337: LD_VAR 0 11
60341: PPUSH
60342: CALL_OW 1
60346: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60347: LD_ADDR_VAR 0 4
60351: PUSH
60352: LD_VAR 0 4
60356: PUSH
60357: LD_VAR 0 6
60361: DIFF
60362: ST_TO_ADDR
// if tmp and eng < 4 then
60363: LD_VAR 0 4
60367: PUSH
60368: LD_VAR 0 6
60372: PUSH
60373: LD_INT 4
60375: LESS
60376: AND
60377: IFFALSE 60567
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60379: LD_ADDR_VAR 0 9
60383: PUSH
60384: LD_VAR 0 4
60388: PUSH
60389: LD_VAR 0 7
60393: PUSH
60394: LD_VAR 0 6
60398: UNION
60399: DIFF
60400: PPUSH
60401: LD_INT 2
60403: PPUSH
60404: CALL 49521 0 2
60408: ST_TO_ADDR
// p := [ ] ;
60409: LD_ADDR_VAR 0 11
60413: PUSH
60414: EMPTY
60415: ST_TO_ADDR
// if sort then
60416: LD_VAR 0 9
60420: IFFALSE 60536
// for i = 1 to 4 - eng do
60422: LD_ADDR_VAR 0 3
60426: PUSH
60427: DOUBLE
60428: LD_INT 1
60430: DEC
60431: ST_TO_ADDR
60432: LD_INT 4
60434: PUSH
60435: LD_VAR 0 6
60439: MINUS
60440: PUSH
60441: FOR_TO
60442: IFFALSE 60534
// begin if i = sort then
60444: LD_VAR 0 3
60448: PUSH
60449: LD_VAR 0 9
60453: EQUAL
60454: IFFALSE 60458
// break ;
60456: GO 60534
// if GetClass ( i ) = 2 then
60458: LD_VAR 0 3
60462: PPUSH
60463: CALL_OW 257
60467: PUSH
60468: LD_INT 2
60470: EQUAL
60471: IFFALSE 60475
// continue ;
60473: GO 60441
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60475: LD_ADDR_VAR 0 11
60479: PUSH
60480: LD_VAR 0 11
60484: PPUSH
60485: LD_VAR 0 11
60489: PUSH
60490: LD_INT 1
60492: PLUS
60493: PPUSH
60494: LD_VAR 0 9
60498: PUSH
60499: LD_VAR 0 3
60503: ARRAY
60504: PPUSH
60505: CALL_OW 2
60509: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60510: LD_ADDR_VAR 0 4
60514: PUSH
60515: LD_VAR 0 4
60519: PUSH
60520: LD_VAR 0 9
60524: PUSH
60525: LD_VAR 0 3
60529: ARRAY
60530: DIFF
60531: ST_TO_ADDR
// end ;
60532: GO 60441
60534: POP
60535: POP
// if p then
60536: LD_VAR 0 11
60540: IFFALSE 60565
// result := Replace ( result , 2 , p ) ;
60542: LD_ADDR_VAR 0 2
60546: PUSH
60547: LD_VAR 0 2
60551: PPUSH
60552: LD_INT 2
60554: PPUSH
60555: LD_VAR 0 11
60559: PPUSH
60560: CALL_OW 1
60564: ST_TO_ADDR
// end else
60565: GO 60611
// for i = eng downto 5 do
60567: LD_ADDR_VAR 0 3
60571: PUSH
60572: DOUBLE
60573: LD_VAR 0 6
60577: INC
60578: ST_TO_ADDR
60579: LD_INT 5
60581: PUSH
60582: FOR_DOWNTO
60583: IFFALSE 60609
// tmp := tmp union eng [ i ] ;
60585: LD_ADDR_VAR 0 4
60589: PUSH
60590: LD_VAR 0 4
60594: PUSH
60595: LD_VAR 0 6
60599: PUSH
60600: LD_VAR 0 3
60604: ARRAY
60605: UNION
60606: ST_TO_ADDR
60607: GO 60582
60609: POP
60610: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60611: LD_ADDR_VAR 0 2
60615: PUSH
60616: LD_VAR 0 2
60620: PPUSH
60621: LD_INT 1
60623: PPUSH
60624: LD_VAR 0 4
60628: PUSH
60629: LD_VAR 0 5
60633: DIFF
60634: PPUSH
60635: CALL_OW 1
60639: ST_TO_ADDR
// exit ;
60640: GO 60642
// end ; end ;
60642: LD_VAR 0 2
60646: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60647: LD_INT 0
60649: PPUSH
60650: PPUSH
60651: PPUSH
// if not mc_bases then
60652: LD_EXP 59
60656: NOT
60657: IFFALSE 60661
// exit ;
60659: GO 60767
// for i = 1 to mc_bases do
60661: LD_ADDR_VAR 0 2
60665: PUSH
60666: DOUBLE
60667: LD_INT 1
60669: DEC
60670: ST_TO_ADDR
60671: LD_EXP 59
60675: PUSH
60676: FOR_TO
60677: IFFALSE 60758
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60679: LD_ADDR_VAR 0 3
60683: PUSH
60684: LD_EXP 59
60688: PUSH
60689: LD_VAR 0 2
60693: ARRAY
60694: PPUSH
60695: LD_INT 21
60697: PUSH
60698: LD_INT 3
60700: PUSH
60701: EMPTY
60702: LIST
60703: LIST
60704: PUSH
60705: LD_INT 3
60707: PUSH
60708: LD_INT 24
60710: PUSH
60711: LD_INT 1000
60713: PUSH
60714: EMPTY
60715: LIST
60716: LIST
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: PUSH
60722: EMPTY
60723: LIST
60724: LIST
60725: PPUSH
60726: CALL_OW 72
60730: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60731: LD_ADDR_EXP 60
60735: PUSH
60736: LD_EXP 60
60740: PPUSH
60741: LD_VAR 0 2
60745: PPUSH
60746: LD_VAR 0 3
60750: PPUSH
60751: CALL_OW 1
60755: ST_TO_ADDR
// end ;
60756: GO 60676
60758: POP
60759: POP
// RaiseSailEvent ( 101 ) ;
60760: LD_INT 101
60762: PPUSH
60763: CALL_OW 427
// end ;
60767: LD_VAR 0 1
60771: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60772: LD_INT 0
60774: PPUSH
60775: PPUSH
60776: PPUSH
60777: PPUSH
60778: PPUSH
60779: PPUSH
60780: PPUSH
// if not mc_bases then
60781: LD_EXP 59
60785: NOT
60786: IFFALSE 60790
// exit ;
60788: GO 61352
// for i = 1 to mc_bases do
60790: LD_ADDR_VAR 0 2
60794: PUSH
60795: DOUBLE
60796: LD_INT 1
60798: DEC
60799: ST_TO_ADDR
60800: LD_EXP 59
60804: PUSH
60805: FOR_TO
60806: IFFALSE 61343
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60808: LD_ADDR_VAR 0 5
60812: PUSH
60813: LD_EXP 59
60817: PUSH
60818: LD_VAR 0 2
60822: ARRAY
60823: PUSH
60824: LD_EXP 88
60828: PUSH
60829: LD_VAR 0 2
60833: ARRAY
60834: UNION
60835: PPUSH
60836: LD_INT 21
60838: PUSH
60839: LD_INT 1
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: PUSH
60846: LD_INT 1
60848: PUSH
60849: LD_INT 3
60851: PUSH
60852: LD_INT 54
60854: PUSH
60855: EMPTY
60856: LIST
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PUSH
60862: LD_INT 3
60864: PUSH
60865: LD_INT 24
60867: PUSH
60868: LD_INT 1000
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: LIST
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: PPUSH
60888: CALL_OW 72
60892: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60893: LD_ADDR_VAR 0 6
60897: PUSH
60898: LD_EXP 59
60902: PUSH
60903: LD_VAR 0 2
60907: ARRAY
60908: PPUSH
60909: LD_INT 21
60911: PUSH
60912: LD_INT 1
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: PUSH
60919: LD_INT 1
60921: PUSH
60922: LD_INT 3
60924: PUSH
60925: LD_INT 54
60927: PUSH
60928: EMPTY
60929: LIST
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: LD_INT 3
60937: PUSH
60938: LD_INT 24
60940: PUSH
60941: LD_INT 250
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: LIST
60956: PUSH
60957: EMPTY
60958: LIST
60959: LIST
60960: PPUSH
60961: CALL_OW 72
60965: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60966: LD_ADDR_VAR 0 7
60970: PUSH
60971: LD_VAR 0 5
60975: PUSH
60976: LD_VAR 0 6
60980: DIFF
60981: ST_TO_ADDR
// if not need_heal_1 then
60982: LD_VAR 0 6
60986: NOT
60987: IFFALSE 61020
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60989: LD_ADDR_EXP 62
60993: PUSH
60994: LD_EXP 62
60998: PPUSH
60999: LD_VAR 0 2
61003: PUSH
61004: LD_INT 1
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PPUSH
61011: EMPTY
61012: PPUSH
61013: CALL 19669 0 3
61017: ST_TO_ADDR
61018: GO 61090
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61020: LD_ADDR_EXP 62
61024: PUSH
61025: LD_EXP 62
61029: PPUSH
61030: LD_VAR 0 2
61034: PUSH
61035: LD_INT 1
61037: PUSH
61038: EMPTY
61039: LIST
61040: LIST
61041: PPUSH
61042: LD_EXP 62
61046: PUSH
61047: LD_VAR 0 2
61051: ARRAY
61052: PUSH
61053: LD_INT 1
61055: ARRAY
61056: PPUSH
61057: LD_INT 3
61059: PUSH
61060: LD_INT 24
61062: PUSH
61063: LD_INT 1000
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PPUSH
61074: CALL_OW 72
61078: PUSH
61079: LD_VAR 0 6
61083: UNION
61084: PPUSH
61085: CALL 19669 0 3
61089: ST_TO_ADDR
// if not need_heal_2 then
61090: LD_VAR 0 7
61094: NOT
61095: IFFALSE 61128
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61097: LD_ADDR_EXP 62
61101: PUSH
61102: LD_EXP 62
61106: PPUSH
61107: LD_VAR 0 2
61111: PUSH
61112: LD_INT 2
61114: PUSH
61115: EMPTY
61116: LIST
61117: LIST
61118: PPUSH
61119: EMPTY
61120: PPUSH
61121: CALL 19669 0 3
61125: ST_TO_ADDR
61126: GO 61160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61128: LD_ADDR_EXP 62
61132: PUSH
61133: LD_EXP 62
61137: PPUSH
61138: LD_VAR 0 2
61142: PUSH
61143: LD_INT 2
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: LD_VAR 0 7
61154: PPUSH
61155: CALL 19669 0 3
61159: ST_TO_ADDR
// if need_heal_2 then
61160: LD_VAR 0 7
61164: IFFALSE 61325
// for j in need_heal_2 do
61166: LD_ADDR_VAR 0 3
61170: PUSH
61171: LD_VAR 0 7
61175: PUSH
61176: FOR_IN
61177: IFFALSE 61323
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61179: LD_ADDR_VAR 0 5
61183: PUSH
61184: LD_EXP 59
61188: PUSH
61189: LD_VAR 0 2
61193: ARRAY
61194: PPUSH
61195: LD_INT 2
61197: PUSH
61198: LD_INT 30
61200: PUSH
61201: LD_INT 6
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PUSH
61208: LD_INT 30
61210: PUSH
61211: LD_INT 7
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 30
61220: PUSH
61221: LD_INT 8
61223: PUSH
61224: EMPTY
61225: LIST
61226: LIST
61227: PUSH
61228: LD_INT 30
61230: PUSH
61231: LD_INT 0
61233: PUSH
61234: EMPTY
61235: LIST
61236: LIST
61237: PUSH
61238: LD_INT 30
61240: PUSH
61241: LD_INT 1
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PUSH
61248: EMPTY
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: PPUSH
61256: CALL_OW 72
61260: ST_TO_ADDR
// if tmp then
61261: LD_VAR 0 5
61265: IFFALSE 61321
// begin k := NearestUnitToUnit ( tmp , j ) ;
61267: LD_ADDR_VAR 0 4
61271: PUSH
61272: LD_VAR 0 5
61276: PPUSH
61277: LD_VAR 0 3
61281: PPUSH
61282: CALL_OW 74
61286: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61287: LD_VAR 0 3
61291: PPUSH
61292: LD_VAR 0 4
61296: PPUSH
61297: CALL_OW 296
61301: PUSH
61302: LD_INT 5
61304: GREATER
61305: IFFALSE 61321
// ComMoveToNearbyEntrance ( j , k ) ;
61307: LD_VAR 0 3
61311: PPUSH
61312: LD_VAR 0 4
61316: PPUSH
61317: CALL 51882 0 2
// end ; end ;
61321: GO 61176
61323: POP
61324: POP
// if not need_heal_1 and not need_heal_2 then
61325: LD_VAR 0 6
61329: NOT
61330: PUSH
61331: LD_VAR 0 7
61335: NOT
61336: AND
61337: IFFALSE 61341
// continue ;
61339: GO 60805
// end ;
61341: GO 60805
61343: POP
61344: POP
// RaiseSailEvent ( 102 ) ;
61345: LD_INT 102
61347: PPUSH
61348: CALL_OW 427
// end ;
61352: LD_VAR 0 1
61356: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61357: LD_INT 0
61359: PPUSH
61360: PPUSH
61361: PPUSH
61362: PPUSH
61363: PPUSH
61364: PPUSH
61365: PPUSH
61366: PPUSH
// if not mc_bases then
61367: LD_EXP 59
61371: NOT
61372: IFFALSE 61376
// exit ;
61374: GO 62237
// for i = 1 to mc_bases do
61376: LD_ADDR_VAR 0 2
61380: PUSH
61381: DOUBLE
61382: LD_INT 1
61384: DEC
61385: ST_TO_ADDR
61386: LD_EXP 59
61390: PUSH
61391: FOR_TO
61392: IFFALSE 62235
// begin if not mc_building_need_repair [ i ] then
61394: LD_EXP 60
61398: PUSH
61399: LD_VAR 0 2
61403: ARRAY
61404: NOT
61405: IFFALSE 61592
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61407: LD_ADDR_VAR 0 6
61411: PUSH
61412: LD_EXP 78
61416: PUSH
61417: LD_VAR 0 2
61421: ARRAY
61422: PPUSH
61423: LD_INT 3
61425: PUSH
61426: LD_INT 24
61428: PUSH
61429: LD_INT 1000
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: EMPTY
61437: LIST
61438: LIST
61439: PUSH
61440: LD_INT 2
61442: PUSH
61443: LD_INT 34
61445: PUSH
61446: LD_INT 13
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: LD_INT 34
61455: PUSH
61456: LD_INT 52
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: LD_INT 34
61465: PUSH
61466: LD_EXP 109
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: PUSH
61475: EMPTY
61476: LIST
61477: LIST
61478: LIST
61479: LIST
61480: PUSH
61481: EMPTY
61482: LIST
61483: LIST
61484: PPUSH
61485: CALL_OW 72
61489: ST_TO_ADDR
// if cranes then
61490: LD_VAR 0 6
61494: IFFALSE 61556
// for j in cranes do
61496: LD_ADDR_VAR 0 3
61500: PUSH
61501: LD_VAR 0 6
61505: PUSH
61506: FOR_IN
61507: IFFALSE 61554
// if not IsInArea ( j , mc_parking [ i ] ) then
61509: LD_VAR 0 3
61513: PPUSH
61514: LD_EXP 83
61518: PUSH
61519: LD_VAR 0 2
61523: ARRAY
61524: PPUSH
61525: CALL_OW 308
61529: NOT
61530: IFFALSE 61552
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61532: LD_VAR 0 3
61536: PPUSH
61537: LD_EXP 83
61541: PUSH
61542: LD_VAR 0 2
61546: ARRAY
61547: PPUSH
61548: CALL_OW 113
61552: GO 61506
61554: POP
61555: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61556: LD_ADDR_EXP 61
61560: PUSH
61561: LD_EXP 61
61565: PPUSH
61566: LD_VAR 0 2
61570: PPUSH
61571: EMPTY
61572: PPUSH
61573: CALL_OW 1
61577: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61578: LD_VAR 0 2
61582: PPUSH
61583: LD_INT 101
61585: PPUSH
61586: CALL 56480 0 2
// continue ;
61590: GO 61391
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61592: LD_ADDR_EXP 65
61596: PUSH
61597: LD_EXP 65
61601: PPUSH
61602: LD_VAR 0 2
61606: PPUSH
61607: EMPTY
61608: PPUSH
61609: CALL_OW 1
61613: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61614: LD_VAR 0 2
61618: PPUSH
61619: LD_INT 103
61621: PPUSH
61622: CALL 56480 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61626: LD_ADDR_VAR 0 5
61630: PUSH
61631: LD_EXP 59
61635: PUSH
61636: LD_VAR 0 2
61640: ARRAY
61641: PUSH
61642: LD_EXP 88
61646: PUSH
61647: LD_VAR 0 2
61651: ARRAY
61652: UNION
61653: PPUSH
61654: LD_INT 2
61656: PUSH
61657: LD_INT 25
61659: PUSH
61660: LD_INT 2
61662: PUSH
61663: EMPTY
61664: LIST
61665: LIST
61666: PUSH
61667: LD_INT 25
61669: PUSH
61670: LD_INT 16
61672: PUSH
61673: EMPTY
61674: LIST
61675: LIST
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: LIST
61681: PUSH
61682: EMPTY
61683: LIST
61684: PPUSH
61685: CALL_OW 72
61689: PUSH
61690: LD_EXP 62
61694: PUSH
61695: LD_VAR 0 2
61699: ARRAY
61700: PUSH
61701: LD_INT 1
61703: ARRAY
61704: PUSH
61705: LD_EXP 62
61709: PUSH
61710: LD_VAR 0 2
61714: ARRAY
61715: PUSH
61716: LD_INT 2
61718: ARRAY
61719: UNION
61720: DIFF
61721: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61722: LD_ADDR_VAR 0 6
61726: PUSH
61727: LD_EXP 78
61731: PUSH
61732: LD_VAR 0 2
61736: ARRAY
61737: PPUSH
61738: LD_INT 2
61740: PUSH
61741: LD_INT 34
61743: PUSH
61744: LD_INT 13
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: PUSH
61751: LD_INT 34
61753: PUSH
61754: LD_INT 52
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: PUSH
61761: LD_INT 34
61763: PUSH
61764: LD_EXP 109
61768: PUSH
61769: EMPTY
61770: LIST
61771: LIST
61772: PUSH
61773: EMPTY
61774: LIST
61775: LIST
61776: LIST
61777: LIST
61778: PPUSH
61779: CALL_OW 72
61783: ST_TO_ADDR
// if cranes then
61784: LD_VAR 0 6
61788: IFFALSE 61924
// begin for j in cranes do
61790: LD_ADDR_VAR 0 3
61794: PUSH
61795: LD_VAR 0 6
61799: PUSH
61800: FOR_IN
61801: IFFALSE 61922
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61803: LD_VAR 0 3
61807: PPUSH
61808: CALL_OW 256
61812: PUSH
61813: LD_INT 1000
61815: EQUAL
61816: PUSH
61817: LD_VAR 0 3
61821: PPUSH
61822: CALL_OW 314
61826: NOT
61827: AND
61828: IFFALSE 61862
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61830: LD_VAR 0 3
61834: PPUSH
61835: LD_EXP 60
61839: PUSH
61840: LD_VAR 0 2
61844: ARRAY
61845: PPUSH
61846: LD_VAR 0 3
61850: PPUSH
61851: CALL_OW 74
61855: PPUSH
61856: CALL_OW 130
61860: GO 61920
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61862: LD_VAR 0 3
61866: PPUSH
61867: CALL_OW 256
61871: PUSH
61872: LD_INT 500
61874: LESS
61875: PUSH
61876: LD_VAR 0 3
61880: PPUSH
61881: LD_EXP 83
61885: PUSH
61886: LD_VAR 0 2
61890: ARRAY
61891: PPUSH
61892: CALL_OW 308
61896: NOT
61897: AND
61898: IFFALSE 61920
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61900: LD_VAR 0 3
61904: PPUSH
61905: LD_EXP 83
61909: PUSH
61910: LD_VAR 0 2
61914: ARRAY
61915: PPUSH
61916: CALL_OW 113
// end ;
61920: GO 61800
61922: POP
61923: POP
// end ; if tmp > 3 then
61924: LD_VAR 0 5
61928: PUSH
61929: LD_INT 3
61931: GREATER
61932: IFFALSE 61952
// tmp := ShrinkArray ( tmp , 4 ) ;
61934: LD_ADDR_VAR 0 5
61938: PUSH
61939: LD_VAR 0 5
61943: PPUSH
61944: LD_INT 4
61946: PPUSH
61947: CALL 51330 0 2
61951: ST_TO_ADDR
// if not tmp then
61952: LD_VAR 0 5
61956: NOT
61957: IFFALSE 61961
// continue ;
61959: GO 61391
// for j in tmp do
61961: LD_ADDR_VAR 0 3
61965: PUSH
61966: LD_VAR 0 5
61970: PUSH
61971: FOR_IN
61972: IFFALSE 62231
// begin if IsInUnit ( j ) then
61974: LD_VAR 0 3
61978: PPUSH
61979: CALL_OW 310
61983: IFFALSE 61994
// ComExitBuilding ( j ) ;
61985: LD_VAR 0 3
61989: PPUSH
61990: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61994: LD_VAR 0 3
61998: PUSH
61999: LD_EXP 61
62003: PUSH
62004: LD_VAR 0 2
62008: ARRAY
62009: IN
62010: NOT
62011: IFFALSE 62069
// begin SetTag ( j , 101 ) ;
62013: LD_VAR 0 3
62017: PPUSH
62018: LD_INT 101
62020: PPUSH
62021: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62025: LD_ADDR_EXP 61
62029: PUSH
62030: LD_EXP 61
62034: PPUSH
62035: LD_VAR 0 2
62039: PUSH
62040: LD_EXP 61
62044: PUSH
62045: LD_VAR 0 2
62049: ARRAY
62050: PUSH
62051: LD_INT 1
62053: PLUS
62054: PUSH
62055: EMPTY
62056: LIST
62057: LIST
62058: PPUSH
62059: LD_VAR 0 3
62063: PPUSH
62064: CALL 19669 0 3
62068: ST_TO_ADDR
// end ; wait ( 1 ) ;
62069: LD_INT 1
62071: PPUSH
62072: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62076: LD_ADDR_VAR 0 7
62080: PUSH
62081: LD_EXP 60
62085: PUSH
62086: LD_VAR 0 2
62090: ARRAY
62091: ST_TO_ADDR
// if mc_scan [ i ] then
62092: LD_EXP 82
62096: PUSH
62097: LD_VAR 0 2
62101: ARRAY
62102: IFFALSE 62164
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62104: LD_ADDR_VAR 0 7
62108: PUSH
62109: LD_EXP 60
62113: PUSH
62114: LD_VAR 0 2
62118: ARRAY
62119: PPUSH
62120: LD_INT 3
62122: PUSH
62123: LD_INT 30
62125: PUSH
62126: LD_INT 32
62128: PUSH
62129: EMPTY
62130: LIST
62131: LIST
62132: PUSH
62133: LD_INT 30
62135: PUSH
62136: LD_INT 33
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PUSH
62143: LD_INT 30
62145: PUSH
62146: LD_INT 31
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PUSH
62153: EMPTY
62154: LIST
62155: LIST
62156: LIST
62157: LIST
62158: PPUSH
62159: CALL_OW 72
62163: ST_TO_ADDR
// if not to_repair_tmp then
62164: LD_VAR 0 7
62168: NOT
62169: IFFALSE 62173
// continue ;
62171: GO 61971
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62173: LD_ADDR_VAR 0 8
62177: PUSH
62178: LD_VAR 0 7
62182: PPUSH
62183: LD_VAR 0 3
62187: PPUSH
62188: CALL_OW 74
62192: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62193: LD_VAR 0 8
62197: PPUSH
62198: LD_INT 16
62200: PPUSH
62201: CALL 22262 0 2
62205: PUSH
62206: LD_INT 4
62208: ARRAY
62209: PUSH
62210: LD_INT 10
62212: LESS
62213: IFFALSE 62229
// ComRepairBuilding ( j , to_repair ) ;
62215: LD_VAR 0 3
62219: PPUSH
62220: LD_VAR 0 8
62224: PPUSH
62225: CALL_OW 130
// end ;
62229: GO 61971
62231: POP
62232: POP
// end ;
62233: GO 61391
62235: POP
62236: POP
// end ;
62237: LD_VAR 0 1
62241: RET
// export function MC_Heal ; var i , j , tmp ; begin
62242: LD_INT 0
62244: PPUSH
62245: PPUSH
62246: PPUSH
62247: PPUSH
// if not mc_bases then
62248: LD_EXP 59
62252: NOT
62253: IFFALSE 62257
// exit ;
62255: GO 62659
// for i = 1 to mc_bases do
62257: LD_ADDR_VAR 0 2
62261: PUSH
62262: DOUBLE
62263: LD_INT 1
62265: DEC
62266: ST_TO_ADDR
62267: LD_EXP 59
62271: PUSH
62272: FOR_TO
62273: IFFALSE 62657
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62275: LD_EXP 62
62279: PUSH
62280: LD_VAR 0 2
62284: ARRAY
62285: PUSH
62286: LD_INT 1
62288: ARRAY
62289: NOT
62290: PUSH
62291: LD_EXP 62
62295: PUSH
62296: LD_VAR 0 2
62300: ARRAY
62301: PUSH
62302: LD_INT 2
62304: ARRAY
62305: NOT
62306: AND
62307: IFFALSE 62345
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62309: LD_ADDR_EXP 63
62313: PUSH
62314: LD_EXP 63
62318: PPUSH
62319: LD_VAR 0 2
62323: PPUSH
62324: EMPTY
62325: PPUSH
62326: CALL_OW 1
62330: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62331: LD_VAR 0 2
62335: PPUSH
62336: LD_INT 102
62338: PPUSH
62339: CALL 56480 0 2
// continue ;
62343: GO 62272
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62345: LD_ADDR_VAR 0 4
62349: PUSH
62350: LD_EXP 59
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PPUSH
62361: LD_INT 25
62363: PUSH
62364: LD_INT 4
62366: PUSH
62367: EMPTY
62368: LIST
62369: LIST
62370: PPUSH
62371: CALL_OW 72
62375: ST_TO_ADDR
// if not tmp then
62376: LD_VAR 0 4
62380: NOT
62381: IFFALSE 62385
// continue ;
62383: GO 62272
// if mc_taming [ i ] then
62385: LD_EXP 90
62389: PUSH
62390: LD_VAR 0 2
62394: ARRAY
62395: IFFALSE 62419
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62397: LD_ADDR_EXP 90
62401: PUSH
62402: LD_EXP 90
62406: PPUSH
62407: LD_VAR 0 2
62411: PPUSH
62412: EMPTY
62413: PPUSH
62414: CALL_OW 1
62418: ST_TO_ADDR
// for j in tmp do
62419: LD_ADDR_VAR 0 3
62423: PUSH
62424: LD_VAR 0 4
62428: PUSH
62429: FOR_IN
62430: IFFALSE 62653
// begin if IsInUnit ( j ) then
62432: LD_VAR 0 3
62436: PPUSH
62437: CALL_OW 310
62441: IFFALSE 62452
// ComExitBuilding ( j ) ;
62443: LD_VAR 0 3
62447: PPUSH
62448: CALL_OW 122
// if not j in mc_healers [ i ] then
62452: LD_VAR 0 3
62456: PUSH
62457: LD_EXP 63
62461: PUSH
62462: LD_VAR 0 2
62466: ARRAY
62467: IN
62468: NOT
62469: IFFALSE 62515
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62471: LD_ADDR_EXP 63
62475: PUSH
62476: LD_EXP 63
62480: PPUSH
62481: LD_VAR 0 2
62485: PUSH
62486: LD_EXP 63
62490: PUSH
62491: LD_VAR 0 2
62495: ARRAY
62496: PUSH
62497: LD_INT 1
62499: PLUS
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: PPUSH
62505: LD_VAR 0 3
62509: PPUSH
62510: CALL 19669 0 3
62514: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62515: LD_VAR 0 3
62519: PPUSH
62520: CALL_OW 110
62524: PUSH
62525: LD_INT 102
62527: NONEQUAL
62528: IFFALSE 62542
// SetTag ( j , 102 ) ;
62530: LD_VAR 0 3
62534: PPUSH
62535: LD_INT 102
62537: PPUSH
62538: CALL_OW 109
// Wait ( 3 ) ;
62542: LD_INT 3
62544: PPUSH
62545: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62549: LD_EXP 62
62553: PUSH
62554: LD_VAR 0 2
62558: ARRAY
62559: PUSH
62560: LD_INT 1
62562: ARRAY
62563: IFFALSE 62595
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62565: LD_VAR 0 3
62569: PPUSH
62570: LD_EXP 62
62574: PUSH
62575: LD_VAR 0 2
62579: ARRAY
62580: PUSH
62581: LD_INT 1
62583: ARRAY
62584: PUSH
62585: LD_INT 1
62587: ARRAY
62588: PPUSH
62589: CALL_OW 128
62593: GO 62651
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62595: LD_VAR 0 3
62599: PPUSH
62600: CALL_OW 314
62604: NOT
62605: PUSH
62606: LD_EXP 62
62610: PUSH
62611: LD_VAR 0 2
62615: ARRAY
62616: PUSH
62617: LD_INT 2
62619: ARRAY
62620: AND
62621: IFFALSE 62651
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62623: LD_VAR 0 3
62627: PPUSH
62628: LD_EXP 62
62632: PUSH
62633: LD_VAR 0 2
62637: ARRAY
62638: PUSH
62639: LD_INT 2
62641: ARRAY
62642: PUSH
62643: LD_INT 1
62645: ARRAY
62646: PPUSH
62647: CALL_OW 128
// end ;
62651: GO 62429
62653: POP
62654: POP
// end ;
62655: GO 62272
62657: POP
62658: POP
// end ;
62659: LD_VAR 0 1
62663: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62664: LD_INT 0
62666: PPUSH
62667: PPUSH
62668: PPUSH
62669: PPUSH
62670: PPUSH
// if not mc_bases then
62671: LD_EXP 59
62675: NOT
62676: IFFALSE 62680
// exit ;
62678: GO 63851
// for i = 1 to mc_bases do
62680: LD_ADDR_VAR 0 2
62684: PUSH
62685: DOUBLE
62686: LD_INT 1
62688: DEC
62689: ST_TO_ADDR
62690: LD_EXP 59
62694: PUSH
62695: FOR_TO
62696: IFFALSE 63849
// begin if mc_scan [ i ] then
62698: LD_EXP 82
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: IFFALSE 62712
// continue ;
62710: GO 62695
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62712: LD_EXP 64
62716: PUSH
62717: LD_VAR 0 2
62721: ARRAY
62722: NOT
62723: PUSH
62724: LD_EXP 66
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: NOT
62735: AND
62736: PUSH
62737: LD_EXP 65
62741: PUSH
62742: LD_VAR 0 2
62746: ARRAY
62747: AND
62748: IFFALSE 62786
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62750: LD_ADDR_EXP 65
62754: PUSH
62755: LD_EXP 65
62759: PPUSH
62760: LD_VAR 0 2
62764: PPUSH
62765: EMPTY
62766: PPUSH
62767: CALL_OW 1
62771: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62772: LD_VAR 0 2
62776: PPUSH
62777: LD_INT 103
62779: PPUSH
62780: CALL 56480 0 2
// continue ;
62784: GO 62695
// end ; if mc_construct_list [ i ] then
62786: LD_EXP 66
62790: PUSH
62791: LD_VAR 0 2
62795: ARRAY
62796: IFFALSE 63016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62798: LD_ADDR_VAR 0 4
62802: PUSH
62803: LD_EXP 59
62807: PUSH
62808: LD_VAR 0 2
62812: ARRAY
62813: PPUSH
62814: LD_INT 25
62816: PUSH
62817: LD_INT 2
62819: PUSH
62820: EMPTY
62821: LIST
62822: LIST
62823: PPUSH
62824: CALL_OW 72
62828: PUSH
62829: LD_EXP 61
62833: PUSH
62834: LD_VAR 0 2
62838: ARRAY
62839: DIFF
62840: ST_TO_ADDR
// if not tmp then
62841: LD_VAR 0 4
62845: NOT
62846: IFFALSE 62850
// continue ;
62848: GO 62695
// for j in tmp do
62850: LD_ADDR_VAR 0 3
62854: PUSH
62855: LD_VAR 0 4
62859: PUSH
62860: FOR_IN
62861: IFFALSE 63012
// begin if not mc_builders [ i ] then
62863: LD_EXP 65
62867: PUSH
62868: LD_VAR 0 2
62872: ARRAY
62873: NOT
62874: IFFALSE 62932
// begin SetTag ( j , 103 ) ;
62876: LD_VAR 0 3
62880: PPUSH
62881: LD_INT 103
62883: PPUSH
62884: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62888: LD_ADDR_EXP 65
62892: PUSH
62893: LD_EXP 65
62897: PPUSH
62898: LD_VAR 0 2
62902: PUSH
62903: LD_EXP 65
62907: PUSH
62908: LD_VAR 0 2
62912: ARRAY
62913: PUSH
62914: LD_INT 1
62916: PLUS
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: PPUSH
62922: LD_VAR 0 3
62926: PPUSH
62927: CALL 19669 0 3
62931: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62932: LD_VAR 0 3
62936: PPUSH
62937: CALL_OW 310
62941: IFFALSE 62952
// ComExitBuilding ( j ) ;
62943: LD_VAR 0 3
62947: PPUSH
62948: CALL_OW 122
// wait ( 3 ) ;
62952: LD_INT 3
62954: PPUSH
62955: CALL_OW 67
// if not mc_construct_list [ i ] then
62959: LD_EXP 66
62963: PUSH
62964: LD_VAR 0 2
62968: ARRAY
62969: NOT
62970: IFFALSE 62974
// break ;
62972: GO 63012
// if not HasTask ( j ) then
62974: LD_VAR 0 3
62978: PPUSH
62979: CALL_OW 314
62983: NOT
62984: IFFALSE 63010
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62986: LD_VAR 0 3
62990: PPUSH
62991: LD_EXP 66
62995: PUSH
62996: LD_VAR 0 2
63000: ARRAY
63001: PUSH
63002: LD_INT 1
63004: ARRAY
63005: PPUSH
63006: CALL 22526 0 2
// end ;
63010: GO 62860
63012: POP
63013: POP
// end else
63014: GO 63847
// if mc_build_list [ i ] then
63016: LD_EXP 64
63020: PUSH
63021: LD_VAR 0 2
63025: ARRAY
63026: IFFALSE 63847
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63028: LD_ADDR_VAR 0 5
63032: PUSH
63033: LD_EXP 59
63037: PUSH
63038: LD_VAR 0 2
63042: ARRAY
63043: PPUSH
63044: LD_INT 2
63046: PUSH
63047: LD_INT 30
63049: PUSH
63050: LD_INT 0
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PUSH
63057: LD_INT 30
63059: PUSH
63060: LD_INT 1
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: LIST
63071: PPUSH
63072: CALL_OW 72
63076: ST_TO_ADDR
// if depot then
63077: LD_VAR 0 5
63081: IFFALSE 63099
// depot := depot [ 1 ] else
63083: LD_ADDR_VAR 0 5
63087: PUSH
63088: LD_VAR 0 5
63092: PUSH
63093: LD_INT 1
63095: ARRAY
63096: ST_TO_ADDR
63097: GO 63107
// depot := 0 ;
63099: LD_ADDR_VAR 0 5
63103: PUSH
63104: LD_INT 0
63106: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63107: LD_EXP 64
63111: PUSH
63112: LD_VAR 0 2
63116: ARRAY
63117: PUSH
63118: LD_INT 1
63120: ARRAY
63121: PUSH
63122: LD_INT 1
63124: ARRAY
63125: PPUSH
63126: CALL 22350 0 1
63130: PUSH
63131: LD_EXP 59
63135: PUSH
63136: LD_VAR 0 2
63140: ARRAY
63141: PPUSH
63142: LD_INT 2
63144: PUSH
63145: LD_INT 30
63147: PUSH
63148: LD_INT 2
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 30
63157: PUSH
63158: LD_INT 3
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: LIST
63169: PPUSH
63170: CALL_OW 72
63174: NOT
63175: AND
63176: IFFALSE 63281
// begin for j = 1 to mc_build_list [ i ] do
63178: LD_ADDR_VAR 0 3
63182: PUSH
63183: DOUBLE
63184: LD_INT 1
63186: DEC
63187: ST_TO_ADDR
63188: LD_EXP 64
63192: PUSH
63193: LD_VAR 0 2
63197: ARRAY
63198: PUSH
63199: FOR_TO
63200: IFFALSE 63279
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63202: LD_EXP 64
63206: PUSH
63207: LD_VAR 0 2
63211: ARRAY
63212: PUSH
63213: LD_VAR 0 3
63217: ARRAY
63218: PUSH
63219: LD_INT 1
63221: ARRAY
63222: PUSH
63223: LD_INT 2
63225: EQUAL
63226: IFFALSE 63277
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63228: LD_ADDR_EXP 64
63232: PUSH
63233: LD_EXP 64
63237: PPUSH
63238: LD_VAR 0 2
63242: PPUSH
63243: LD_EXP 64
63247: PUSH
63248: LD_VAR 0 2
63252: ARRAY
63253: PPUSH
63254: LD_VAR 0 3
63258: PPUSH
63259: LD_INT 1
63261: PPUSH
63262: LD_INT 0
63264: PPUSH
63265: CALL 19087 0 4
63269: PPUSH
63270: CALL_OW 1
63274: ST_TO_ADDR
// break ;
63275: GO 63279
// end ;
63277: GO 63199
63279: POP
63280: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
63281: LD_EXP 64
63285: PUSH
63286: LD_VAR 0 2
63290: ARRAY
63291: PUSH
63292: LD_INT 1
63294: ARRAY
63295: PUSH
63296: LD_INT 1
63298: ARRAY
63299: PUSH
63300: LD_INT 0
63302: EQUAL
63303: PUSH
63304: LD_VAR 0 5
63308: PUSH
63309: LD_VAR 0 5
63313: PPUSH
63314: LD_EXP 64
63318: PUSH
63319: LD_VAR 0 2
63323: ARRAY
63324: PUSH
63325: LD_INT 1
63327: ARRAY
63328: PUSH
63329: LD_INT 1
63331: ARRAY
63332: PPUSH
63333: LD_EXP 64
63337: PUSH
63338: LD_VAR 0 2
63342: ARRAY
63343: PUSH
63344: LD_INT 1
63346: ARRAY
63347: PUSH
63348: LD_INT 2
63350: ARRAY
63351: PPUSH
63352: LD_EXP 64
63356: PUSH
63357: LD_VAR 0 2
63361: ARRAY
63362: PUSH
63363: LD_INT 1
63365: ARRAY
63366: PUSH
63367: LD_INT 3
63369: ARRAY
63370: PPUSH
63371: LD_EXP 64
63375: PUSH
63376: LD_VAR 0 2
63380: ARRAY
63381: PUSH
63382: LD_INT 1
63384: ARRAY
63385: PUSH
63386: LD_INT 4
63388: ARRAY
63389: PPUSH
63390: CALL 27387 0 5
63394: AND
63395: OR
63396: IFFALSE 63677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63398: LD_ADDR_VAR 0 4
63402: PUSH
63403: LD_EXP 59
63407: PUSH
63408: LD_VAR 0 2
63412: ARRAY
63413: PPUSH
63414: LD_INT 25
63416: PUSH
63417: LD_INT 2
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: PPUSH
63424: CALL_OW 72
63428: PUSH
63429: LD_EXP 61
63433: PUSH
63434: LD_VAR 0 2
63438: ARRAY
63439: DIFF
63440: ST_TO_ADDR
// if not tmp then
63441: LD_VAR 0 4
63445: NOT
63446: IFFALSE 63450
// continue ;
63448: GO 62695
// for j in tmp do
63450: LD_ADDR_VAR 0 3
63454: PUSH
63455: LD_VAR 0 4
63459: PUSH
63460: FOR_IN
63461: IFFALSE 63673
// begin if not mc_builders [ i ] then
63463: LD_EXP 65
63467: PUSH
63468: LD_VAR 0 2
63472: ARRAY
63473: NOT
63474: IFFALSE 63532
// begin SetTag ( j , 103 ) ;
63476: LD_VAR 0 3
63480: PPUSH
63481: LD_INT 103
63483: PPUSH
63484: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63488: LD_ADDR_EXP 65
63492: PUSH
63493: LD_EXP 65
63497: PPUSH
63498: LD_VAR 0 2
63502: PUSH
63503: LD_EXP 65
63507: PUSH
63508: LD_VAR 0 2
63512: ARRAY
63513: PUSH
63514: LD_INT 1
63516: PLUS
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PPUSH
63522: LD_VAR 0 3
63526: PPUSH
63527: CALL 19669 0 3
63531: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63532: LD_VAR 0 3
63536: PPUSH
63537: CALL_OW 310
63541: IFFALSE 63552
// ComExitBuilding ( j ) ;
63543: LD_VAR 0 3
63547: PPUSH
63548: CALL_OW 122
// wait ( 3 ) ;
63552: LD_INT 3
63554: PPUSH
63555: CALL_OW 67
// if not mc_build_list [ i ] then
63559: LD_EXP 64
63563: PUSH
63564: LD_VAR 0 2
63568: ARRAY
63569: NOT
63570: IFFALSE 63574
// break ;
63572: GO 63673
// if not HasTask ( j ) then
63574: LD_VAR 0 3
63578: PPUSH
63579: CALL_OW 314
63583: NOT
63584: IFFALSE 63671
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63586: LD_VAR 0 3
63590: PPUSH
63591: LD_EXP 64
63595: PUSH
63596: LD_VAR 0 2
63600: ARRAY
63601: PUSH
63602: LD_INT 1
63604: ARRAY
63605: PUSH
63606: LD_INT 1
63608: ARRAY
63609: PPUSH
63610: LD_EXP 64
63614: PUSH
63615: LD_VAR 0 2
63619: ARRAY
63620: PUSH
63621: LD_INT 1
63623: ARRAY
63624: PUSH
63625: LD_INT 2
63627: ARRAY
63628: PPUSH
63629: LD_EXP 64
63633: PUSH
63634: LD_VAR 0 2
63638: ARRAY
63639: PUSH
63640: LD_INT 1
63642: ARRAY
63643: PUSH
63644: LD_INT 3
63646: ARRAY
63647: PPUSH
63648: LD_EXP 64
63652: PUSH
63653: LD_VAR 0 2
63657: ARRAY
63658: PUSH
63659: LD_INT 1
63661: ARRAY
63662: PUSH
63663: LD_INT 4
63665: ARRAY
63666: PPUSH
63667: CALL_OW 145
// end ;
63671: GO 63460
63673: POP
63674: POP
// end else
63675: GO 63847
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63677: LD_EXP 59
63681: PUSH
63682: LD_VAR 0 2
63686: ARRAY
63687: PPUSH
63688: LD_EXP 64
63692: PUSH
63693: LD_VAR 0 2
63697: ARRAY
63698: PUSH
63699: LD_INT 1
63701: ARRAY
63702: PUSH
63703: LD_INT 1
63705: ARRAY
63706: PPUSH
63707: LD_EXP 64
63711: PUSH
63712: LD_VAR 0 2
63716: ARRAY
63717: PUSH
63718: LD_INT 1
63720: ARRAY
63721: PUSH
63722: LD_INT 2
63724: ARRAY
63725: PPUSH
63726: LD_EXP 64
63730: PUSH
63731: LD_VAR 0 2
63735: ARRAY
63736: PUSH
63737: LD_INT 1
63739: ARRAY
63740: PUSH
63741: LD_INT 3
63743: ARRAY
63744: PPUSH
63745: LD_EXP 64
63749: PUSH
63750: LD_VAR 0 2
63754: ARRAY
63755: PUSH
63756: LD_INT 1
63758: ARRAY
63759: PUSH
63760: LD_INT 4
63762: ARRAY
63763: PPUSH
63764: LD_EXP 59
63768: PUSH
63769: LD_VAR 0 2
63773: ARRAY
63774: PPUSH
63775: LD_INT 21
63777: PUSH
63778: LD_INT 3
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PPUSH
63785: CALL_OW 72
63789: PPUSH
63790: EMPTY
63791: PPUSH
63792: CALL 26517 0 7
63796: NOT
63797: IFFALSE 63847
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63799: LD_ADDR_EXP 64
63803: PUSH
63804: LD_EXP 64
63808: PPUSH
63809: LD_VAR 0 2
63813: PPUSH
63814: LD_EXP 64
63818: PUSH
63819: LD_VAR 0 2
63823: ARRAY
63824: PPUSH
63825: LD_INT 1
63827: PPUSH
63828: LD_INT 1
63830: NEG
63831: PPUSH
63832: LD_INT 0
63834: PPUSH
63835: CALL 19087 0 4
63839: PPUSH
63840: CALL_OW 1
63844: ST_TO_ADDR
// continue ;
63845: GO 62695
// end ; end ; end ;
63847: GO 62695
63849: POP
63850: POP
// end ;
63851: LD_VAR 0 1
63855: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63856: LD_INT 0
63858: PPUSH
63859: PPUSH
63860: PPUSH
63861: PPUSH
63862: PPUSH
63863: PPUSH
// if not mc_bases then
63864: LD_EXP 59
63868: NOT
63869: IFFALSE 63873
// exit ;
63871: GO 64300
// for i = 1 to mc_bases do
63873: LD_ADDR_VAR 0 2
63877: PUSH
63878: DOUBLE
63879: LD_INT 1
63881: DEC
63882: ST_TO_ADDR
63883: LD_EXP 59
63887: PUSH
63888: FOR_TO
63889: IFFALSE 64298
// begin tmp := mc_build_upgrade [ i ] ;
63891: LD_ADDR_VAR 0 4
63895: PUSH
63896: LD_EXP 91
63900: PUSH
63901: LD_VAR 0 2
63905: ARRAY
63906: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63907: LD_ADDR_VAR 0 6
63911: PUSH
63912: LD_EXP 92
63916: PUSH
63917: LD_VAR 0 2
63921: ARRAY
63922: PPUSH
63923: LD_INT 2
63925: PUSH
63926: LD_INT 30
63928: PUSH
63929: LD_INT 6
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: PUSH
63936: LD_INT 30
63938: PUSH
63939: LD_INT 7
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: LIST
63950: PPUSH
63951: CALL_OW 72
63955: ST_TO_ADDR
// if not tmp and not lab then
63956: LD_VAR 0 4
63960: NOT
63961: PUSH
63962: LD_VAR 0 6
63966: NOT
63967: AND
63968: IFFALSE 63972
// continue ;
63970: GO 63888
// if tmp then
63972: LD_VAR 0 4
63976: IFFALSE 64096
// for j in tmp do
63978: LD_ADDR_VAR 0 3
63982: PUSH
63983: LD_VAR 0 4
63987: PUSH
63988: FOR_IN
63989: IFFALSE 64094
// begin if UpgradeCost ( j ) then
63991: LD_VAR 0 3
63995: PPUSH
63996: CALL 26177 0 1
64000: IFFALSE 64092
// begin ComUpgrade ( j ) ;
64002: LD_VAR 0 3
64006: PPUSH
64007: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64011: LD_ADDR_EXP 91
64015: PUSH
64016: LD_EXP 91
64020: PPUSH
64021: LD_VAR 0 2
64025: PPUSH
64026: LD_EXP 91
64030: PUSH
64031: LD_VAR 0 2
64035: ARRAY
64036: PUSH
64037: LD_VAR 0 3
64041: DIFF
64042: PPUSH
64043: CALL_OW 1
64047: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64048: LD_ADDR_EXP 66
64052: PUSH
64053: LD_EXP 66
64057: PPUSH
64058: LD_VAR 0 2
64062: PUSH
64063: LD_EXP 66
64067: PUSH
64068: LD_VAR 0 2
64072: ARRAY
64073: PUSH
64074: LD_INT 1
64076: PLUS
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PPUSH
64082: LD_VAR 0 3
64086: PPUSH
64087: CALL 19669 0 3
64091: ST_TO_ADDR
// end ; end ;
64092: GO 63988
64094: POP
64095: POP
// if not lab or not mc_lab_upgrade [ i ] then
64096: LD_VAR 0 6
64100: NOT
64101: PUSH
64102: LD_EXP 93
64106: PUSH
64107: LD_VAR 0 2
64111: ARRAY
64112: NOT
64113: OR
64114: IFFALSE 64118
// continue ;
64116: GO 63888
// for j in lab do
64118: LD_ADDR_VAR 0 3
64122: PUSH
64123: LD_VAR 0 6
64127: PUSH
64128: FOR_IN
64129: IFFALSE 64294
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64131: LD_VAR 0 3
64135: PPUSH
64136: CALL_OW 266
64140: PUSH
64141: LD_INT 6
64143: PUSH
64144: LD_INT 7
64146: PUSH
64147: EMPTY
64148: LIST
64149: LIST
64150: IN
64151: PUSH
64152: LD_VAR 0 3
64156: PPUSH
64157: CALL_OW 461
64161: PUSH
64162: LD_INT 1
64164: NONEQUAL
64165: AND
64166: IFFALSE 64292
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64168: LD_VAR 0 3
64172: PPUSH
64173: LD_EXP 93
64177: PUSH
64178: LD_VAR 0 2
64182: ARRAY
64183: PUSH
64184: LD_INT 1
64186: ARRAY
64187: PPUSH
64188: CALL 26382 0 2
64192: IFFALSE 64292
// begin ComCancel ( j ) ;
64194: LD_VAR 0 3
64198: PPUSH
64199: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64203: LD_VAR 0 3
64207: PPUSH
64208: LD_EXP 93
64212: PUSH
64213: LD_VAR 0 2
64217: ARRAY
64218: PUSH
64219: LD_INT 1
64221: ARRAY
64222: PPUSH
64223: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64227: LD_VAR 0 3
64231: PUSH
64232: LD_EXP 66
64236: PUSH
64237: LD_VAR 0 2
64241: ARRAY
64242: IN
64243: NOT
64244: IFFALSE 64290
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64246: LD_ADDR_EXP 66
64250: PUSH
64251: LD_EXP 66
64255: PPUSH
64256: LD_VAR 0 2
64260: PUSH
64261: LD_EXP 66
64265: PUSH
64266: LD_VAR 0 2
64270: ARRAY
64271: PUSH
64272: LD_INT 1
64274: PLUS
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PPUSH
64280: LD_VAR 0 3
64284: PPUSH
64285: CALL 19669 0 3
64289: ST_TO_ADDR
// break ;
64290: GO 64294
// end ; end ; end ;
64292: GO 64128
64294: POP
64295: POP
// end ;
64296: GO 63888
64298: POP
64299: POP
// end ;
64300: LD_VAR 0 1
64304: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64305: LD_INT 0
64307: PPUSH
64308: PPUSH
64309: PPUSH
64310: PPUSH
64311: PPUSH
64312: PPUSH
64313: PPUSH
64314: PPUSH
64315: PPUSH
// if not mc_bases then
64316: LD_EXP 59
64320: NOT
64321: IFFALSE 64325
// exit ;
64323: GO 64730
// for i = 1 to mc_bases do
64325: LD_ADDR_VAR 0 2
64329: PUSH
64330: DOUBLE
64331: LD_INT 1
64333: DEC
64334: ST_TO_ADDR
64335: LD_EXP 59
64339: PUSH
64340: FOR_TO
64341: IFFALSE 64728
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64343: LD_EXP 67
64347: PUSH
64348: LD_VAR 0 2
64352: ARRAY
64353: NOT
64354: PUSH
64355: LD_EXP 59
64359: PUSH
64360: LD_VAR 0 2
64364: ARRAY
64365: PPUSH
64366: LD_INT 30
64368: PUSH
64369: LD_INT 3
64371: PUSH
64372: EMPTY
64373: LIST
64374: LIST
64375: PPUSH
64376: CALL_OW 72
64380: NOT
64381: OR
64382: IFFALSE 64386
// continue ;
64384: GO 64340
// busy := false ;
64386: LD_ADDR_VAR 0 8
64390: PUSH
64391: LD_INT 0
64393: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64394: LD_ADDR_VAR 0 4
64398: PUSH
64399: LD_EXP 59
64403: PUSH
64404: LD_VAR 0 2
64408: ARRAY
64409: PPUSH
64410: LD_INT 30
64412: PUSH
64413: LD_INT 3
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PPUSH
64420: CALL_OW 72
64424: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64425: LD_ADDR_VAR 0 6
64429: PUSH
64430: LD_EXP 67
64434: PUSH
64435: LD_VAR 0 2
64439: ARRAY
64440: PPUSH
64441: LD_INT 2
64443: PUSH
64444: LD_INT 30
64446: PUSH
64447: LD_INT 32
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: PUSH
64454: LD_INT 30
64456: PUSH
64457: LD_INT 33
64459: PUSH
64460: EMPTY
64461: LIST
64462: LIST
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: LIST
64468: PPUSH
64469: CALL_OW 72
64473: ST_TO_ADDR
// if not t then
64474: LD_VAR 0 6
64478: NOT
64479: IFFALSE 64483
// continue ;
64481: GO 64340
// for j in tmp do
64483: LD_ADDR_VAR 0 3
64487: PUSH
64488: LD_VAR 0 4
64492: PUSH
64493: FOR_IN
64494: IFFALSE 64524
// if not BuildingStatus ( j ) = bs_idle then
64496: LD_VAR 0 3
64500: PPUSH
64501: CALL_OW 461
64505: PUSH
64506: LD_INT 2
64508: EQUAL
64509: NOT
64510: IFFALSE 64522
// begin busy := true ;
64512: LD_ADDR_VAR 0 8
64516: PUSH
64517: LD_INT 1
64519: ST_TO_ADDR
// break ;
64520: GO 64524
// end ;
64522: GO 64493
64524: POP
64525: POP
// if busy then
64526: LD_VAR 0 8
64530: IFFALSE 64534
// continue ;
64532: GO 64340
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64534: LD_ADDR_VAR 0 7
64538: PUSH
64539: LD_VAR 0 6
64543: PPUSH
64544: LD_INT 35
64546: PUSH
64547: LD_INT 0
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PPUSH
64554: CALL_OW 72
64558: ST_TO_ADDR
// if tw then
64559: LD_VAR 0 7
64563: IFFALSE 64640
// begin tw := tw [ 1 ] ;
64565: LD_ADDR_VAR 0 7
64569: PUSH
64570: LD_VAR 0 7
64574: PUSH
64575: LD_INT 1
64577: ARRAY
64578: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64579: LD_ADDR_VAR 0 9
64583: PUSH
64584: LD_VAR 0 7
64588: PPUSH
64589: LD_EXP 84
64593: PUSH
64594: LD_VAR 0 2
64598: ARRAY
64599: PPUSH
64600: CALL 24674 0 2
64604: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64605: LD_EXP 98
64609: PUSH
64610: LD_VAR 0 2
64614: ARRAY
64615: IFFALSE 64638
// if not weapon in mc_allowed_tower_weapons [ i ] then
64617: LD_VAR 0 9
64621: PUSH
64622: LD_EXP 98
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: IN
64633: NOT
64634: IFFALSE 64638
// continue ;
64636: GO 64340
// end else
64638: GO 64703
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64640: LD_ADDR_VAR 0 5
64644: PUSH
64645: LD_EXP 67
64649: PUSH
64650: LD_VAR 0 2
64654: ARRAY
64655: PPUSH
64656: LD_VAR 0 4
64660: PPUSH
64661: CALL 50563 0 2
64665: ST_TO_ADDR
// if not tmp2 then
64666: LD_VAR 0 5
64670: NOT
64671: IFFALSE 64675
// continue ;
64673: GO 64340
// tw := tmp2 [ 1 ] ;
64675: LD_ADDR_VAR 0 7
64679: PUSH
64680: LD_VAR 0 5
64684: PUSH
64685: LD_INT 1
64687: ARRAY
64688: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64689: LD_ADDR_VAR 0 9
64693: PUSH
64694: LD_VAR 0 5
64698: PUSH
64699: LD_INT 2
64701: ARRAY
64702: ST_TO_ADDR
// end ; if not weapon then
64703: LD_VAR 0 9
64707: NOT
64708: IFFALSE 64712
// continue ;
64710: GO 64340
// ComPlaceWeapon ( tw , weapon ) ;
64712: LD_VAR 0 7
64716: PPUSH
64717: LD_VAR 0 9
64721: PPUSH
64722: CALL_OW 148
// end ;
64726: GO 64340
64728: POP
64729: POP
// end ;
64730: LD_VAR 0 1
64734: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64735: LD_INT 0
64737: PPUSH
64738: PPUSH
64739: PPUSH
64740: PPUSH
64741: PPUSH
64742: PPUSH
64743: PPUSH
// if not mc_bases then
64744: LD_EXP 59
64748: NOT
64749: IFFALSE 64753
// exit ;
64751: GO 65521
// for i = 1 to mc_bases do
64753: LD_ADDR_VAR 0 2
64757: PUSH
64758: DOUBLE
64759: LD_INT 1
64761: DEC
64762: ST_TO_ADDR
64763: LD_EXP 59
64767: PUSH
64768: FOR_TO
64769: IFFALSE 65519
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64771: LD_EXP 72
64775: PUSH
64776: LD_VAR 0 2
64780: ARRAY
64781: NOT
64782: PUSH
64783: LD_EXP 72
64787: PUSH
64788: LD_VAR 0 2
64792: ARRAY
64793: PUSH
64794: LD_EXP 73
64798: PUSH
64799: LD_VAR 0 2
64803: ARRAY
64804: EQUAL
64805: OR
64806: PUSH
64807: LD_EXP 82
64811: PUSH
64812: LD_VAR 0 2
64816: ARRAY
64817: OR
64818: IFFALSE 64822
// continue ;
64820: GO 64768
// if mc_miners [ i ] then
64822: LD_EXP 73
64826: PUSH
64827: LD_VAR 0 2
64831: ARRAY
64832: IFFALSE 65206
// begin for j = mc_miners [ i ] downto 1 do
64834: LD_ADDR_VAR 0 3
64838: PUSH
64839: DOUBLE
64840: LD_EXP 73
64844: PUSH
64845: LD_VAR 0 2
64849: ARRAY
64850: INC
64851: ST_TO_ADDR
64852: LD_INT 1
64854: PUSH
64855: FOR_DOWNTO
64856: IFFALSE 65204
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64858: LD_EXP 73
64862: PUSH
64863: LD_VAR 0 2
64867: ARRAY
64868: PUSH
64869: LD_VAR 0 3
64873: ARRAY
64874: PPUSH
64875: CALL_OW 301
64879: PUSH
64880: LD_EXP 73
64884: PUSH
64885: LD_VAR 0 2
64889: ARRAY
64890: PUSH
64891: LD_VAR 0 3
64895: ARRAY
64896: PPUSH
64897: CALL_OW 257
64901: PUSH
64902: LD_INT 1
64904: NONEQUAL
64905: OR
64906: IFFALSE 64969
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64908: LD_ADDR_VAR 0 5
64912: PUSH
64913: LD_EXP 73
64917: PUSH
64918: LD_VAR 0 2
64922: ARRAY
64923: PUSH
64924: LD_EXP 73
64928: PUSH
64929: LD_VAR 0 2
64933: ARRAY
64934: PUSH
64935: LD_VAR 0 3
64939: ARRAY
64940: DIFF
64941: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64942: LD_ADDR_EXP 73
64946: PUSH
64947: LD_EXP 73
64951: PPUSH
64952: LD_VAR 0 2
64956: PPUSH
64957: LD_VAR 0 5
64961: PPUSH
64962: CALL_OW 1
64966: ST_TO_ADDR
// continue ;
64967: GO 64855
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64969: LD_EXP 73
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PUSH
64980: LD_VAR 0 3
64984: ARRAY
64985: PPUSH
64986: CALL_OW 257
64990: PUSH
64991: LD_INT 1
64993: EQUAL
64994: PUSH
64995: LD_EXP 73
64999: PUSH
65000: LD_VAR 0 2
65004: ARRAY
65005: PUSH
65006: LD_VAR 0 3
65010: ARRAY
65011: PPUSH
65012: CALL_OW 459
65016: NOT
65017: AND
65018: PUSH
65019: LD_EXP 73
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PUSH
65030: LD_VAR 0 3
65034: ARRAY
65035: PPUSH
65036: CALL_OW 314
65040: NOT
65041: AND
65042: IFFALSE 65202
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65044: LD_EXP 73
65048: PUSH
65049: LD_VAR 0 2
65053: ARRAY
65054: PUSH
65055: LD_VAR 0 3
65059: ARRAY
65060: PPUSH
65061: CALL_OW 310
65065: IFFALSE 65088
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65067: LD_EXP 73
65071: PUSH
65072: LD_VAR 0 2
65076: ARRAY
65077: PUSH
65078: LD_VAR 0 3
65082: ARRAY
65083: PPUSH
65084: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65088: LD_EXP 73
65092: PUSH
65093: LD_VAR 0 2
65097: ARRAY
65098: PUSH
65099: LD_VAR 0 3
65103: ARRAY
65104: PPUSH
65105: CALL_OW 314
65109: NOT
65110: IFFALSE 65202
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65112: LD_ADDR_VAR 0 7
65116: PUSH
65117: LD_INT 1
65119: PPUSH
65120: LD_EXP 72
65124: PUSH
65125: LD_VAR 0 2
65129: ARRAY
65130: PPUSH
65131: CALL_OW 12
65135: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65136: LD_EXP 73
65140: PUSH
65141: LD_VAR 0 2
65145: ARRAY
65146: PUSH
65147: LD_VAR 0 3
65151: ARRAY
65152: PPUSH
65153: LD_EXP 72
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: PUSH
65164: LD_VAR 0 7
65168: ARRAY
65169: PUSH
65170: LD_INT 1
65172: ARRAY
65173: PPUSH
65174: LD_EXP 72
65178: PUSH
65179: LD_VAR 0 2
65183: ARRAY
65184: PUSH
65185: LD_VAR 0 7
65189: ARRAY
65190: PUSH
65191: LD_INT 2
65193: ARRAY
65194: PPUSH
65195: LD_INT 0
65197: PPUSH
65198: CALL_OW 193
// end ; end ; end ;
65202: GO 64855
65204: POP
65205: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65206: LD_ADDR_VAR 0 5
65210: PUSH
65211: LD_EXP 59
65215: PUSH
65216: LD_VAR 0 2
65220: ARRAY
65221: PPUSH
65222: LD_INT 2
65224: PUSH
65225: LD_INT 30
65227: PUSH
65228: LD_INT 4
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: PUSH
65235: LD_INT 30
65237: PUSH
65238: LD_INT 5
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 30
65247: PUSH
65248: LD_INT 32
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: PPUSH
65261: CALL_OW 72
65265: ST_TO_ADDR
// if not tmp then
65266: LD_VAR 0 5
65270: NOT
65271: IFFALSE 65275
// continue ;
65273: GO 64768
// list := [ ] ;
65275: LD_ADDR_VAR 0 6
65279: PUSH
65280: EMPTY
65281: ST_TO_ADDR
// for j in tmp do
65282: LD_ADDR_VAR 0 3
65286: PUSH
65287: LD_VAR 0 5
65291: PUSH
65292: FOR_IN
65293: IFFALSE 65362
// begin for k in UnitsInside ( j ) do
65295: LD_ADDR_VAR 0 4
65299: PUSH
65300: LD_VAR 0 3
65304: PPUSH
65305: CALL_OW 313
65309: PUSH
65310: FOR_IN
65311: IFFALSE 65358
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65313: LD_VAR 0 4
65317: PPUSH
65318: CALL_OW 257
65322: PUSH
65323: LD_INT 1
65325: EQUAL
65326: PUSH
65327: LD_VAR 0 4
65331: PPUSH
65332: CALL_OW 459
65336: NOT
65337: AND
65338: IFFALSE 65356
// list := list ^ k ;
65340: LD_ADDR_VAR 0 6
65344: PUSH
65345: LD_VAR 0 6
65349: PUSH
65350: LD_VAR 0 4
65354: ADD
65355: ST_TO_ADDR
65356: GO 65310
65358: POP
65359: POP
// end ;
65360: GO 65292
65362: POP
65363: POP
// list := list diff mc_miners [ i ] ;
65364: LD_ADDR_VAR 0 6
65368: PUSH
65369: LD_VAR 0 6
65373: PUSH
65374: LD_EXP 73
65378: PUSH
65379: LD_VAR 0 2
65383: ARRAY
65384: DIFF
65385: ST_TO_ADDR
// if not list then
65386: LD_VAR 0 6
65390: NOT
65391: IFFALSE 65395
// continue ;
65393: GO 64768
// k := mc_mines [ i ] - mc_miners [ i ] ;
65395: LD_ADDR_VAR 0 4
65399: PUSH
65400: LD_EXP 72
65404: PUSH
65405: LD_VAR 0 2
65409: ARRAY
65410: PUSH
65411: LD_EXP 73
65415: PUSH
65416: LD_VAR 0 2
65420: ARRAY
65421: MINUS
65422: ST_TO_ADDR
// if k > list then
65423: LD_VAR 0 4
65427: PUSH
65428: LD_VAR 0 6
65432: GREATER
65433: IFFALSE 65445
// k := list ;
65435: LD_ADDR_VAR 0 4
65439: PUSH
65440: LD_VAR 0 6
65444: ST_TO_ADDR
// for j = 1 to k do
65445: LD_ADDR_VAR 0 3
65449: PUSH
65450: DOUBLE
65451: LD_INT 1
65453: DEC
65454: ST_TO_ADDR
65455: LD_VAR 0 4
65459: PUSH
65460: FOR_TO
65461: IFFALSE 65515
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65463: LD_ADDR_EXP 73
65467: PUSH
65468: LD_EXP 73
65472: PPUSH
65473: LD_VAR 0 2
65477: PUSH
65478: LD_EXP 73
65482: PUSH
65483: LD_VAR 0 2
65487: ARRAY
65488: PUSH
65489: LD_INT 1
65491: PLUS
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PPUSH
65497: LD_VAR 0 6
65501: PUSH
65502: LD_VAR 0 3
65506: ARRAY
65507: PPUSH
65508: CALL 19669 0 3
65512: ST_TO_ADDR
65513: GO 65460
65515: POP
65516: POP
// end ;
65517: GO 64768
65519: POP
65520: POP
// end ;
65521: LD_VAR 0 1
65525: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
65526: LD_INT 0
65528: PPUSH
65529: PPUSH
65530: PPUSH
65531: PPUSH
65532: PPUSH
65533: PPUSH
65534: PPUSH
65535: PPUSH
65536: PPUSH
65537: PPUSH
// if not mc_bases then
65538: LD_EXP 59
65542: NOT
65543: IFFALSE 65547
// exit ;
65545: GO 67297
// for i = 1 to mc_bases do
65547: LD_ADDR_VAR 0 2
65551: PUSH
65552: DOUBLE
65553: LD_INT 1
65555: DEC
65556: ST_TO_ADDR
65557: LD_EXP 59
65561: PUSH
65562: FOR_TO
65563: IFFALSE 67295
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65565: LD_EXP 59
65569: PUSH
65570: LD_VAR 0 2
65574: ARRAY
65575: NOT
65576: PUSH
65577: LD_EXP 66
65581: PUSH
65582: LD_VAR 0 2
65586: ARRAY
65587: OR
65588: IFFALSE 65592
// continue ;
65590: GO 65562
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65592: LD_EXP 75
65596: PUSH
65597: LD_VAR 0 2
65601: ARRAY
65602: NOT
65603: PUSH
65604: LD_EXP 76
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: AND
65615: IFFALSE 65653
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65617: LD_ADDR_EXP 76
65621: PUSH
65622: LD_EXP 76
65626: PPUSH
65627: LD_VAR 0 2
65631: PPUSH
65632: EMPTY
65633: PPUSH
65634: CALL_OW 1
65638: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65639: LD_VAR 0 2
65643: PPUSH
65644: LD_INT 107
65646: PPUSH
65647: CALL 56480 0 2
// continue ;
65651: GO 65562
// end ; target := [ ] ;
65653: LD_ADDR_VAR 0 6
65657: PUSH
65658: EMPTY
65659: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65660: LD_ADDR_VAR 0 3
65664: PUSH
65665: DOUBLE
65666: LD_EXP 75
65670: PUSH
65671: LD_VAR 0 2
65675: ARRAY
65676: INC
65677: ST_TO_ADDR
65678: LD_INT 1
65680: PUSH
65681: FOR_DOWNTO
65682: IFFALSE 65942
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65684: LD_EXP 75
65688: PUSH
65689: LD_VAR 0 2
65693: ARRAY
65694: PUSH
65695: LD_VAR 0 3
65699: ARRAY
65700: PUSH
65701: LD_INT 2
65703: ARRAY
65704: PPUSH
65705: LD_EXP 75
65709: PUSH
65710: LD_VAR 0 2
65714: ARRAY
65715: PUSH
65716: LD_VAR 0 3
65720: ARRAY
65721: PUSH
65722: LD_INT 3
65724: ARRAY
65725: PPUSH
65726: CALL_OW 488
65730: PUSH
65731: LD_EXP 75
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: PUSH
65742: LD_VAR 0 3
65746: ARRAY
65747: PUSH
65748: LD_INT 2
65750: ARRAY
65751: PPUSH
65752: LD_EXP 75
65756: PUSH
65757: LD_VAR 0 2
65761: ARRAY
65762: PUSH
65763: LD_VAR 0 3
65767: ARRAY
65768: PUSH
65769: LD_INT 3
65771: ARRAY
65772: PPUSH
65773: CALL_OW 284
65777: PUSH
65778: LD_INT 0
65780: EQUAL
65781: AND
65782: IFFALSE 65837
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65784: LD_ADDR_VAR 0 5
65788: PUSH
65789: LD_EXP 75
65793: PUSH
65794: LD_VAR 0 2
65798: ARRAY
65799: PPUSH
65800: LD_VAR 0 3
65804: PPUSH
65805: CALL_OW 3
65809: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65810: LD_ADDR_EXP 75
65814: PUSH
65815: LD_EXP 75
65819: PPUSH
65820: LD_VAR 0 2
65824: PPUSH
65825: LD_VAR 0 5
65829: PPUSH
65830: CALL_OW 1
65834: ST_TO_ADDR
// continue ;
65835: GO 65681
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65837: LD_EXP 59
65841: PUSH
65842: LD_VAR 0 2
65846: ARRAY
65847: PUSH
65848: LD_INT 1
65850: ARRAY
65851: PPUSH
65852: CALL_OW 255
65856: PPUSH
65857: LD_EXP 75
65861: PUSH
65862: LD_VAR 0 2
65866: ARRAY
65867: PUSH
65868: LD_VAR 0 3
65872: ARRAY
65873: PUSH
65874: LD_INT 2
65876: ARRAY
65877: PPUSH
65878: LD_EXP 75
65882: PUSH
65883: LD_VAR 0 2
65887: ARRAY
65888: PUSH
65889: LD_VAR 0 3
65893: ARRAY
65894: PUSH
65895: LD_INT 3
65897: ARRAY
65898: PPUSH
65899: LD_INT 30
65901: PPUSH
65902: CALL 20565 0 4
65906: PUSH
65907: LD_INT 4
65909: ARRAY
65910: PUSH
65911: LD_INT 0
65913: EQUAL
65914: IFFALSE 65940
// begin target := mc_crates [ i ] [ j ] ;
65916: LD_ADDR_VAR 0 6
65920: PUSH
65921: LD_EXP 75
65925: PUSH
65926: LD_VAR 0 2
65930: ARRAY
65931: PUSH
65932: LD_VAR 0 3
65936: ARRAY
65937: ST_TO_ADDR
// break ;
65938: GO 65942
// end ; end ;
65940: GO 65681
65942: POP
65943: POP
// if not target then
65944: LD_VAR 0 6
65948: NOT
65949: IFFALSE 65953
// continue ;
65951: GO 65562
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65953: LD_ADDR_VAR 0 7
65957: PUSH
65958: LD_EXP 78
65962: PUSH
65963: LD_VAR 0 2
65967: ARRAY
65968: PPUSH
65969: LD_INT 2
65971: PUSH
65972: LD_INT 3
65974: PUSH
65975: LD_INT 58
65977: PUSH
65978: EMPTY
65979: LIST
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 61
65987: PUSH
65988: EMPTY
65989: LIST
65990: PUSH
65991: LD_INT 33
65993: PUSH
65994: LD_INT 5
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: LD_INT 33
66003: PUSH
66004: LD_INT 3
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: EMPTY
66012: LIST
66013: LIST
66014: LIST
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 34
66023: PUSH
66024: LD_INT 32
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 34
66033: PUSH
66034: LD_INT 51
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: LD_INT 34
66043: PUSH
66044: LD_INT 12
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PPUSH
66061: CALL_OW 72
66065: ST_TO_ADDR
// if not cargo then
66066: LD_VAR 0 7
66070: NOT
66071: IFFALSE 66714
// begin if mc_crates_collector [ i ] < 5 then
66073: LD_EXP 76
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: PUSH
66084: LD_INT 5
66086: LESS
66087: IFFALSE 66453
// begin if mc_ape [ i ] then
66089: LD_EXP 88
66093: PUSH
66094: LD_VAR 0 2
66098: ARRAY
66099: IFFALSE 66146
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66101: LD_ADDR_VAR 0 5
66105: PUSH
66106: LD_EXP 88
66110: PUSH
66111: LD_VAR 0 2
66115: ARRAY
66116: PPUSH
66117: LD_INT 25
66119: PUSH
66120: LD_INT 16
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 24
66129: PUSH
66130: LD_INT 750
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PPUSH
66141: CALL_OW 72
66145: ST_TO_ADDR
// if not tmp then
66146: LD_VAR 0 5
66150: NOT
66151: IFFALSE 66198
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66153: LD_ADDR_VAR 0 5
66157: PUSH
66158: LD_EXP 59
66162: PUSH
66163: LD_VAR 0 2
66167: ARRAY
66168: PPUSH
66169: LD_INT 25
66171: PUSH
66172: LD_INT 2
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 24
66181: PUSH
66182: LD_INT 750
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PPUSH
66193: CALL_OW 72
66197: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66198: LD_EXP 88
66202: PUSH
66203: LD_VAR 0 2
66207: ARRAY
66208: PUSH
66209: LD_EXP 59
66213: PUSH
66214: LD_VAR 0 2
66218: ARRAY
66219: PPUSH
66220: LD_INT 25
66222: PUSH
66223: LD_INT 2
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 24
66232: PUSH
66233: LD_INT 750
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PPUSH
66244: CALL_OW 72
66248: AND
66249: PUSH
66250: LD_VAR 0 5
66254: PUSH
66255: LD_INT 5
66257: LESS
66258: AND
66259: IFFALSE 66341
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66261: LD_ADDR_VAR 0 3
66265: PUSH
66266: LD_EXP 59
66270: PUSH
66271: LD_VAR 0 2
66275: ARRAY
66276: PPUSH
66277: LD_INT 25
66279: PUSH
66280: LD_INT 2
66282: PUSH
66283: EMPTY
66284: LIST
66285: LIST
66286: PUSH
66287: LD_INT 24
66289: PUSH
66290: LD_INT 750
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PPUSH
66301: CALL_OW 72
66305: PUSH
66306: FOR_IN
66307: IFFALSE 66339
// begin tmp := tmp union j ;
66309: LD_ADDR_VAR 0 5
66313: PUSH
66314: LD_VAR 0 5
66318: PUSH
66319: LD_VAR 0 3
66323: UNION
66324: ST_TO_ADDR
// if tmp >= 5 then
66325: LD_VAR 0 5
66329: PUSH
66330: LD_INT 5
66332: GREATEREQUAL
66333: IFFALSE 66337
// break ;
66335: GO 66339
// end ;
66337: GO 66306
66339: POP
66340: POP
// end ; if not tmp then
66341: LD_VAR 0 5
66345: NOT
66346: IFFALSE 66350
// continue ;
66348: GO 65562
// for j in tmp do
66350: LD_ADDR_VAR 0 3
66354: PUSH
66355: LD_VAR 0 5
66359: PUSH
66360: FOR_IN
66361: IFFALSE 66451
// if not GetTag ( j ) then
66363: LD_VAR 0 3
66367: PPUSH
66368: CALL_OW 110
66372: NOT
66373: IFFALSE 66449
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66375: LD_ADDR_EXP 76
66379: PUSH
66380: LD_EXP 76
66384: PPUSH
66385: LD_VAR 0 2
66389: PUSH
66390: LD_EXP 76
66394: PUSH
66395: LD_VAR 0 2
66399: ARRAY
66400: PUSH
66401: LD_INT 1
66403: PLUS
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PPUSH
66409: LD_VAR 0 3
66413: PPUSH
66414: CALL 19669 0 3
66418: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66419: LD_VAR 0 3
66423: PPUSH
66424: LD_INT 107
66426: PPUSH
66427: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66431: LD_EXP 76
66435: PUSH
66436: LD_VAR 0 2
66440: ARRAY
66441: PUSH
66442: LD_INT 5
66444: GREATEREQUAL
66445: IFFALSE 66449
// break ;
66447: GO 66451
// end ;
66449: GO 66360
66451: POP
66452: POP
// end ; if mc_crates_collector [ i ] and target then
66453: LD_EXP 76
66457: PUSH
66458: LD_VAR 0 2
66462: ARRAY
66463: PUSH
66464: LD_VAR 0 6
66468: AND
66469: IFFALSE 66712
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66471: LD_EXP 76
66475: PUSH
66476: LD_VAR 0 2
66480: ARRAY
66481: PUSH
66482: LD_VAR 0 6
66486: PUSH
66487: LD_INT 1
66489: ARRAY
66490: LESS
66491: IFFALSE 66511
// tmp := mc_crates_collector [ i ] else
66493: LD_ADDR_VAR 0 5
66497: PUSH
66498: LD_EXP 76
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: ST_TO_ADDR
66509: GO 66525
// tmp := target [ 1 ] ;
66511: LD_ADDR_VAR 0 5
66515: PUSH
66516: LD_VAR 0 6
66520: PUSH
66521: LD_INT 1
66523: ARRAY
66524: ST_TO_ADDR
// k := 0 ;
66525: LD_ADDR_VAR 0 4
66529: PUSH
66530: LD_INT 0
66532: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66533: LD_ADDR_VAR 0 3
66537: PUSH
66538: LD_EXP 76
66542: PUSH
66543: LD_VAR 0 2
66547: ARRAY
66548: PUSH
66549: FOR_IN
66550: IFFALSE 66710
// begin k := k + 1 ;
66552: LD_ADDR_VAR 0 4
66556: PUSH
66557: LD_VAR 0 4
66561: PUSH
66562: LD_INT 1
66564: PLUS
66565: ST_TO_ADDR
// if k > tmp then
66566: LD_VAR 0 4
66570: PUSH
66571: LD_VAR 0 5
66575: GREATER
66576: IFFALSE 66580
// break ;
66578: GO 66710
// if not GetClass ( j ) in [ 2 , 16 ] then
66580: LD_VAR 0 3
66584: PPUSH
66585: CALL_OW 257
66589: PUSH
66590: LD_INT 2
66592: PUSH
66593: LD_INT 16
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: IN
66600: NOT
66601: IFFALSE 66654
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66603: LD_ADDR_EXP 76
66607: PUSH
66608: LD_EXP 76
66612: PPUSH
66613: LD_VAR 0 2
66617: PPUSH
66618: LD_EXP 76
66622: PUSH
66623: LD_VAR 0 2
66627: ARRAY
66628: PUSH
66629: LD_VAR 0 3
66633: DIFF
66634: PPUSH
66635: CALL_OW 1
66639: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66640: LD_VAR 0 3
66644: PPUSH
66645: LD_INT 0
66647: PPUSH
66648: CALL_OW 109
// continue ;
66652: GO 66549
// end ; if IsInUnit ( j ) then
66654: LD_VAR 0 3
66658: PPUSH
66659: CALL_OW 310
66663: IFFALSE 66674
// ComExitBuilding ( j ) ;
66665: LD_VAR 0 3
66669: PPUSH
66670: CALL_OW 122
// wait ( 3 ) ;
66674: LD_INT 3
66676: PPUSH
66677: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66681: LD_VAR 0 3
66685: PPUSH
66686: LD_VAR 0 6
66690: PUSH
66691: LD_INT 2
66693: ARRAY
66694: PPUSH
66695: LD_VAR 0 6
66699: PUSH
66700: LD_INT 3
66702: ARRAY
66703: PPUSH
66704: CALL_OW 117
// end ;
66708: GO 66549
66710: POP
66711: POP
// end ; end else
66712: GO 67293
// begin for j in cargo do
66714: LD_ADDR_VAR 0 3
66718: PUSH
66719: LD_VAR 0 7
66723: PUSH
66724: FOR_IN
66725: IFFALSE 67291
// begin if GetTag ( j ) <> 0 then
66727: LD_VAR 0 3
66731: PPUSH
66732: CALL_OW 110
66736: PUSH
66737: LD_INT 0
66739: NONEQUAL
66740: IFFALSE 66744
// continue ;
66742: GO 66724
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66744: LD_VAR 0 3
66748: PPUSH
66749: CALL_OW 256
66753: PUSH
66754: LD_INT 1000
66756: LESS
66757: PUSH
66758: LD_VAR 0 3
66762: PPUSH
66763: LD_EXP 83
66767: PUSH
66768: LD_VAR 0 2
66772: ARRAY
66773: PPUSH
66774: CALL_OW 308
66778: NOT
66779: AND
66780: IFFALSE 66802
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66782: LD_VAR 0 3
66786: PPUSH
66787: LD_EXP 83
66791: PUSH
66792: LD_VAR 0 2
66796: ARRAY
66797: PPUSH
66798: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66802: LD_VAR 0 3
66806: PPUSH
66807: CALL_OW 256
66811: PUSH
66812: LD_INT 1000
66814: LESS
66815: PUSH
66816: LD_VAR 0 3
66820: PPUSH
66821: LD_EXP 83
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: PPUSH
66832: CALL_OW 308
66836: AND
66837: IFFALSE 66841
// continue ;
66839: GO 66724
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66841: LD_VAR 0 3
66845: PPUSH
66846: CALL_OW 262
66850: PUSH
66851: LD_INT 2
66853: EQUAL
66854: PUSH
66855: LD_VAR 0 3
66859: PPUSH
66860: CALL_OW 261
66864: PUSH
66865: LD_INT 15
66867: LESS
66868: AND
66869: IFFALSE 66873
// continue ;
66871: GO 66724
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66873: LD_VAR 0 3
66877: PPUSH
66878: CALL_OW 262
66882: PUSH
66883: LD_INT 1
66885: EQUAL
66886: PUSH
66887: LD_VAR 0 3
66891: PPUSH
66892: CALL_OW 261
66896: PUSH
66897: LD_INT 10
66899: LESS
66900: AND
66901: IFFALSE 67230
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66903: LD_ADDR_VAR 0 8
66907: PUSH
66908: LD_EXP 59
66912: PUSH
66913: LD_VAR 0 2
66917: ARRAY
66918: PPUSH
66919: LD_INT 2
66921: PUSH
66922: LD_INT 30
66924: PUSH
66925: LD_INT 0
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: LD_INT 30
66934: PUSH
66935: LD_INT 1
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: LIST
66946: PPUSH
66947: CALL_OW 72
66951: ST_TO_ADDR
// if not depot then
66952: LD_VAR 0 8
66956: NOT
66957: IFFALSE 66961
// continue ;
66959: GO 66724
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66961: LD_VAR 0 3
66965: PPUSH
66966: LD_VAR 0 8
66970: PPUSH
66971: LD_VAR 0 3
66975: PPUSH
66976: CALL_OW 74
66980: PPUSH
66981: CALL_OW 296
66985: PUSH
66986: LD_INT 6
66988: LESS
66989: IFFALSE 67005
// SetFuel ( j , 100 ) else
66991: LD_VAR 0 3
66995: PPUSH
66996: LD_INT 100
66998: PPUSH
66999: CALL_OW 240
67003: GO 67230
// if GetFuel ( j ) = 0 then
67005: LD_VAR 0 3
67009: PPUSH
67010: CALL_OW 261
67014: PUSH
67015: LD_INT 0
67017: EQUAL
67018: IFFALSE 67230
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67020: LD_ADDR_EXP 78
67024: PUSH
67025: LD_EXP 78
67029: PPUSH
67030: LD_VAR 0 2
67034: PPUSH
67035: LD_EXP 78
67039: PUSH
67040: LD_VAR 0 2
67044: ARRAY
67045: PUSH
67046: LD_VAR 0 3
67050: DIFF
67051: PPUSH
67052: CALL_OW 1
67056: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67057: LD_VAR 0 3
67061: PPUSH
67062: CALL_OW 263
67066: PUSH
67067: LD_INT 1
67069: EQUAL
67070: IFFALSE 67086
// ComExitVehicle ( IsInUnit ( j ) ) ;
67072: LD_VAR 0 3
67076: PPUSH
67077: CALL_OW 310
67081: PPUSH
67082: CALL_OW 121
// if GetControl ( j ) = control_remote then
67086: LD_VAR 0 3
67090: PPUSH
67091: CALL_OW 263
67095: PUSH
67096: LD_INT 2
67098: EQUAL
67099: IFFALSE 67110
// ComUnlink ( j ) ;
67101: LD_VAR 0 3
67105: PPUSH
67106: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67110: LD_ADDR_VAR 0 9
67114: PUSH
67115: LD_VAR 0 2
67119: PPUSH
67120: LD_INT 3
67122: PPUSH
67123: CALL 76700 0 2
67127: ST_TO_ADDR
// if fac then
67128: LD_VAR 0 9
67132: IFFALSE 67228
// begin for k in fac do
67134: LD_ADDR_VAR 0 4
67138: PUSH
67139: LD_VAR 0 9
67143: PUSH
67144: FOR_IN
67145: IFFALSE 67226
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67147: LD_ADDR_VAR 0 10
67151: PUSH
67152: LD_VAR 0 9
67156: PPUSH
67157: LD_VAR 0 3
67161: PPUSH
67162: CALL_OW 265
67166: PPUSH
67167: LD_VAR 0 3
67171: PPUSH
67172: CALL_OW 262
67176: PPUSH
67177: LD_VAR 0 3
67181: PPUSH
67182: CALL_OW 263
67186: PPUSH
67187: LD_VAR 0 3
67191: PPUSH
67192: CALL_OW 264
67196: PPUSH
67197: CALL 17201 0 5
67201: ST_TO_ADDR
// if components then
67202: LD_VAR 0 10
67206: IFFALSE 67224
// begin MC_InsertProduceList ( i , components ) ;
67208: LD_VAR 0 2
67212: PPUSH
67213: LD_VAR 0 10
67217: PPUSH
67218: CALL 76245 0 2
// break ;
67222: GO 67226
// end ; end ;
67224: GO 67144
67226: POP
67227: POP
// end ; continue ;
67228: GO 66724
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67230: LD_VAR 0 3
67234: PPUSH
67235: LD_INT 1
67237: PPUSH
67238: CALL_OW 289
67242: PUSH
67243: LD_INT 100
67245: LESS
67246: PUSH
67247: LD_VAR 0 3
67251: PPUSH
67252: CALL_OW 314
67256: NOT
67257: AND
67258: IFFALSE 67287
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67260: LD_VAR 0 3
67264: PPUSH
67265: LD_VAR 0 6
67269: PUSH
67270: LD_INT 2
67272: ARRAY
67273: PPUSH
67274: LD_VAR 0 6
67278: PUSH
67279: LD_INT 3
67281: ARRAY
67282: PPUSH
67283: CALL_OW 117
// break ;
67287: GO 67291
// end ;
67289: GO 66724
67291: POP
67292: POP
// end ; end ;
67293: GO 65562
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 1
67301: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
67306: PPUSH
67307: PPUSH
// if not mc_bases then
67308: LD_EXP 59
67312: NOT
67313: IFFALSE 67317
// exit ;
67315: GO 67478
// for i = 1 to mc_bases do
67317: LD_ADDR_VAR 0 2
67321: PUSH
67322: DOUBLE
67323: LD_INT 1
67325: DEC
67326: ST_TO_ADDR
67327: LD_EXP 59
67331: PUSH
67332: FOR_TO
67333: IFFALSE 67476
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67335: LD_ADDR_VAR 0 4
67339: PUSH
67340: LD_EXP 78
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: PUSH
67351: LD_EXP 81
67355: PUSH
67356: LD_VAR 0 2
67360: ARRAY
67361: UNION
67362: PPUSH
67363: LD_INT 33
67365: PUSH
67366: LD_INT 2
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PPUSH
67373: CALL_OW 72
67377: ST_TO_ADDR
// if tmp then
67378: LD_VAR 0 4
67382: IFFALSE 67474
// for j in tmp do
67384: LD_ADDR_VAR 0 3
67388: PUSH
67389: LD_VAR 0 4
67393: PUSH
67394: FOR_IN
67395: IFFALSE 67472
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67397: LD_VAR 0 3
67401: PPUSH
67402: CALL_OW 312
67406: NOT
67407: PUSH
67408: LD_VAR 0 3
67412: PPUSH
67413: CALL_OW 256
67417: PUSH
67418: LD_INT 250
67420: GREATEREQUAL
67421: AND
67422: IFFALSE 67435
// Connect ( j ) else
67424: LD_VAR 0 3
67428: PPUSH
67429: CALL 22634 0 1
67433: GO 67470
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67435: LD_VAR 0 3
67439: PPUSH
67440: CALL_OW 256
67444: PUSH
67445: LD_INT 250
67447: LESS
67448: PUSH
67449: LD_VAR 0 3
67453: PPUSH
67454: CALL_OW 312
67458: AND
67459: IFFALSE 67470
// ComUnlink ( j ) ;
67461: LD_VAR 0 3
67465: PPUSH
67466: CALL_OW 136
67470: GO 67394
67472: POP
67473: POP
// end ;
67474: GO 67332
67476: POP
67477: POP
// end ;
67478: LD_VAR 0 1
67482: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67483: LD_INT 0
67485: PPUSH
67486: PPUSH
67487: PPUSH
67488: PPUSH
67489: PPUSH
// if not mc_bases then
67490: LD_EXP 59
67494: NOT
67495: IFFALSE 67499
// exit ;
67497: GO 67944
// for i = 1 to mc_bases do
67499: LD_ADDR_VAR 0 2
67503: PUSH
67504: DOUBLE
67505: LD_INT 1
67507: DEC
67508: ST_TO_ADDR
67509: LD_EXP 59
67513: PUSH
67514: FOR_TO
67515: IFFALSE 67942
// begin if not mc_produce [ i ] then
67517: LD_EXP 80
67521: PUSH
67522: LD_VAR 0 2
67526: ARRAY
67527: NOT
67528: IFFALSE 67532
// continue ;
67530: GO 67514
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67532: LD_ADDR_VAR 0 5
67536: PUSH
67537: LD_EXP 59
67541: PUSH
67542: LD_VAR 0 2
67546: ARRAY
67547: PPUSH
67548: LD_INT 30
67550: PUSH
67551: LD_INT 3
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PPUSH
67558: CALL_OW 72
67562: ST_TO_ADDR
// if not fac then
67563: LD_VAR 0 5
67567: NOT
67568: IFFALSE 67572
// continue ;
67570: GO 67514
// for j in fac do
67572: LD_ADDR_VAR 0 3
67576: PUSH
67577: LD_VAR 0 5
67581: PUSH
67582: FOR_IN
67583: IFFALSE 67938
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67585: LD_VAR 0 3
67589: PPUSH
67590: CALL_OW 461
67594: PUSH
67595: LD_INT 2
67597: NONEQUAL
67598: PUSH
67599: LD_VAR 0 3
67603: PPUSH
67604: LD_INT 15
67606: PPUSH
67607: CALL 22262 0 2
67611: PUSH
67612: LD_INT 4
67614: ARRAY
67615: OR
67616: IFFALSE 67620
// continue ;
67618: GO 67582
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67620: LD_VAR 0 3
67624: PPUSH
67625: LD_EXP 80
67629: PUSH
67630: LD_VAR 0 2
67634: ARRAY
67635: PUSH
67636: LD_INT 1
67638: ARRAY
67639: PUSH
67640: LD_INT 1
67642: ARRAY
67643: PPUSH
67644: LD_EXP 80
67648: PUSH
67649: LD_VAR 0 2
67653: ARRAY
67654: PUSH
67655: LD_INT 1
67657: ARRAY
67658: PUSH
67659: LD_INT 2
67661: ARRAY
67662: PPUSH
67663: LD_EXP 80
67667: PUSH
67668: LD_VAR 0 2
67672: ARRAY
67673: PUSH
67674: LD_INT 1
67676: ARRAY
67677: PUSH
67678: LD_INT 3
67680: ARRAY
67681: PPUSH
67682: LD_EXP 80
67686: PUSH
67687: LD_VAR 0 2
67691: ARRAY
67692: PUSH
67693: LD_INT 1
67695: ARRAY
67696: PUSH
67697: LD_INT 4
67699: ARRAY
67700: PPUSH
67701: CALL_OW 448
67705: PUSH
67706: LD_VAR 0 3
67710: PPUSH
67711: LD_EXP 80
67715: PUSH
67716: LD_VAR 0 2
67720: ARRAY
67721: PUSH
67722: LD_INT 1
67724: ARRAY
67725: PUSH
67726: LD_INT 1
67728: ARRAY
67729: PUSH
67730: LD_EXP 80
67734: PUSH
67735: LD_VAR 0 2
67739: ARRAY
67740: PUSH
67741: LD_INT 1
67743: ARRAY
67744: PUSH
67745: LD_INT 2
67747: ARRAY
67748: PUSH
67749: LD_EXP 80
67753: PUSH
67754: LD_VAR 0 2
67758: ARRAY
67759: PUSH
67760: LD_INT 1
67762: ARRAY
67763: PUSH
67764: LD_INT 3
67766: ARRAY
67767: PUSH
67768: LD_EXP 80
67772: PUSH
67773: LD_VAR 0 2
67777: ARRAY
67778: PUSH
67779: LD_INT 1
67781: ARRAY
67782: PUSH
67783: LD_INT 4
67785: ARRAY
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: LIST
67791: LIST
67792: PPUSH
67793: CALL 26030 0 2
67797: AND
67798: IFFALSE 67936
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67800: LD_VAR 0 3
67804: PPUSH
67805: LD_EXP 80
67809: PUSH
67810: LD_VAR 0 2
67814: ARRAY
67815: PUSH
67816: LD_INT 1
67818: ARRAY
67819: PUSH
67820: LD_INT 1
67822: ARRAY
67823: PPUSH
67824: LD_EXP 80
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: PUSH
67835: LD_INT 1
67837: ARRAY
67838: PUSH
67839: LD_INT 2
67841: ARRAY
67842: PPUSH
67843: LD_EXP 80
67847: PUSH
67848: LD_VAR 0 2
67852: ARRAY
67853: PUSH
67854: LD_INT 1
67856: ARRAY
67857: PUSH
67858: LD_INT 3
67860: ARRAY
67861: PPUSH
67862: LD_EXP 80
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PUSH
67873: LD_INT 1
67875: ARRAY
67876: PUSH
67877: LD_INT 4
67879: ARRAY
67880: PPUSH
67881: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67885: LD_ADDR_VAR 0 4
67889: PUSH
67890: LD_EXP 80
67894: PUSH
67895: LD_VAR 0 2
67899: ARRAY
67900: PPUSH
67901: LD_INT 1
67903: PPUSH
67904: CALL_OW 3
67908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67909: LD_ADDR_EXP 80
67913: PUSH
67914: LD_EXP 80
67918: PPUSH
67919: LD_VAR 0 2
67923: PPUSH
67924: LD_VAR 0 4
67928: PPUSH
67929: CALL_OW 1
67933: ST_TO_ADDR
// break ;
67934: GO 67938
// end ; end ;
67936: GO 67582
67938: POP
67939: POP
// end ;
67940: GO 67514
67942: POP
67943: POP
// end ;
67944: LD_VAR 0 1
67948: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67949: LD_INT 0
67951: PPUSH
67952: PPUSH
67953: PPUSH
// if not mc_bases then
67954: LD_EXP 59
67958: NOT
67959: IFFALSE 67963
// exit ;
67961: GO 68052
// for i = 1 to mc_bases do
67963: LD_ADDR_VAR 0 2
67967: PUSH
67968: DOUBLE
67969: LD_INT 1
67971: DEC
67972: ST_TO_ADDR
67973: LD_EXP 59
67977: PUSH
67978: FOR_TO
67979: IFFALSE 68050
// begin if mc_attack [ i ] then
67981: LD_EXP 79
67985: PUSH
67986: LD_VAR 0 2
67990: ARRAY
67991: IFFALSE 68048
// begin tmp := mc_attack [ i ] [ 1 ] ;
67993: LD_ADDR_VAR 0 3
67997: PUSH
67998: LD_EXP 79
68002: PUSH
68003: LD_VAR 0 2
68007: ARRAY
68008: PUSH
68009: LD_INT 1
68011: ARRAY
68012: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68013: LD_ADDR_EXP 79
68017: PUSH
68018: LD_EXP 79
68022: PPUSH
68023: LD_VAR 0 2
68027: PPUSH
68028: EMPTY
68029: PPUSH
68030: CALL_OW 1
68034: ST_TO_ADDR
// Attack ( tmp ) ;
68035: LD_VAR 0 3
68039: PPUSH
68040: CALL 99997 0 1
// exit ;
68044: POP
68045: POP
68046: GO 68052
// end ; end ;
68048: GO 67978
68050: POP
68051: POP
// end ;
68052: LD_VAR 0 1
68056: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68057: LD_INT 0
68059: PPUSH
68060: PPUSH
68061: PPUSH
68062: PPUSH
68063: PPUSH
68064: PPUSH
68065: PPUSH
// if not mc_bases then
68066: LD_EXP 59
68070: NOT
68071: IFFALSE 68075
// exit ;
68073: GO 68774
// for i = 1 to mc_bases do
68075: LD_ADDR_VAR 0 2
68079: PUSH
68080: DOUBLE
68081: LD_INT 1
68083: DEC
68084: ST_TO_ADDR
68085: LD_EXP 59
68089: PUSH
68090: FOR_TO
68091: IFFALSE 68772
// begin if not mc_bases [ i ] then
68093: LD_EXP 59
68097: PUSH
68098: LD_VAR 0 2
68102: ARRAY
68103: NOT
68104: IFFALSE 68108
// continue ;
68106: GO 68090
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68108: LD_ADDR_VAR 0 7
68112: PUSH
68113: LD_EXP 59
68117: PUSH
68118: LD_VAR 0 2
68122: ARRAY
68123: PUSH
68124: LD_INT 1
68126: ARRAY
68127: PPUSH
68128: CALL 16505 0 1
68132: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68133: LD_ADDR_EXP 82
68137: PUSH
68138: LD_EXP 82
68142: PPUSH
68143: LD_VAR 0 2
68147: PPUSH
68148: LD_EXP 59
68152: PUSH
68153: LD_VAR 0 2
68157: ARRAY
68158: PUSH
68159: LD_INT 1
68161: ARRAY
68162: PPUSH
68163: CALL_OW 255
68167: PPUSH
68168: LD_EXP 84
68172: PUSH
68173: LD_VAR 0 2
68177: ARRAY
68178: PPUSH
68179: CALL 16470 0 2
68183: PPUSH
68184: CALL_OW 1
68188: ST_TO_ADDR
// if not mc_scan [ i ] then
68189: LD_EXP 82
68193: PUSH
68194: LD_VAR 0 2
68198: ARRAY
68199: NOT
68200: IFFALSE 68378
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68202: LD_ADDR_VAR 0 4
68206: PUSH
68207: LD_EXP 59
68211: PUSH
68212: LD_VAR 0 2
68216: ARRAY
68217: PPUSH
68218: LD_INT 2
68220: PUSH
68221: LD_INT 25
68223: PUSH
68224: LD_INT 5
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 25
68233: PUSH
68234: LD_INT 8
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 25
68243: PUSH
68244: LD_INT 9
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: LIST
68255: LIST
68256: PPUSH
68257: CALL_OW 72
68261: ST_TO_ADDR
// if not tmp then
68262: LD_VAR 0 4
68266: NOT
68267: IFFALSE 68271
// continue ;
68269: GO 68090
// for j in tmp do
68271: LD_ADDR_VAR 0 3
68275: PUSH
68276: LD_VAR 0 4
68280: PUSH
68281: FOR_IN
68282: IFFALSE 68353
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68284: LD_VAR 0 3
68288: PPUSH
68289: CALL_OW 310
68293: PPUSH
68294: CALL_OW 266
68298: PUSH
68299: LD_INT 5
68301: EQUAL
68302: PUSH
68303: LD_VAR 0 3
68307: PPUSH
68308: CALL_OW 257
68312: PUSH
68313: LD_INT 1
68315: EQUAL
68316: AND
68317: PUSH
68318: LD_VAR 0 3
68322: PPUSH
68323: CALL_OW 459
68327: NOT
68328: AND
68329: PUSH
68330: LD_VAR 0 7
68334: AND
68335: IFFALSE 68351
// ComChangeProfession ( j , class ) ;
68337: LD_VAR 0 3
68341: PPUSH
68342: LD_VAR 0 7
68346: PPUSH
68347: CALL_OW 123
68351: GO 68281
68353: POP
68354: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68355: LD_ADDR_EXP 102
68359: PUSH
68360: LD_EXP 102
68364: PPUSH
68365: LD_VAR 0 2
68369: PPUSH
68370: LD_INT 0
68372: PPUSH
68373: CALL_OW 1
68377: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68378: LD_EXP 82
68382: PUSH
68383: LD_VAR 0 2
68387: ARRAY
68388: PUSH
68389: LD_EXP 102
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: NOT
68400: AND
68401: PUSH
68402: LD_EXP 81
68406: PUSH
68407: LD_VAR 0 2
68411: ARRAY
68412: NOT
68413: AND
68414: PUSH
68415: LD_EXP 59
68419: PUSH
68420: LD_VAR 0 2
68424: ARRAY
68425: PPUSH
68426: LD_INT 30
68428: PUSH
68429: LD_INT 32
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PPUSH
68436: CALL_OW 72
68440: NOT
68441: AND
68442: PUSH
68443: LD_EXP 59
68447: PUSH
68448: LD_VAR 0 2
68452: ARRAY
68453: PPUSH
68454: LD_INT 2
68456: PUSH
68457: LD_INT 30
68459: PUSH
68460: LD_INT 4
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 30
68469: PUSH
68470: LD_INT 5
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: LIST
68481: PPUSH
68482: CALL_OW 72
68486: NOT
68487: AND
68488: IFFALSE 68643
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68490: LD_ADDR_VAR 0 4
68494: PUSH
68495: LD_EXP 59
68499: PUSH
68500: LD_VAR 0 2
68504: ARRAY
68505: PPUSH
68506: LD_INT 2
68508: PUSH
68509: LD_INT 25
68511: PUSH
68512: LD_INT 1
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 25
68521: PUSH
68522: LD_INT 5
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 25
68531: PUSH
68532: LD_INT 8
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 25
68541: PUSH
68542: LD_INT 9
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: PPUSH
68556: CALL_OW 72
68560: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68561: LD_ADDR_VAR 0 4
68565: PUSH
68566: LD_VAR 0 4
68570: PUSH
68571: LD_VAR 0 4
68575: PPUSH
68576: LD_INT 18
68578: PPUSH
68579: CALL 48533 0 2
68583: DIFF
68584: ST_TO_ADDR
// if tmp then
68585: LD_VAR 0 4
68589: IFFALSE 68643
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68591: LD_ADDR_EXP 102
68595: PUSH
68596: LD_EXP 102
68600: PPUSH
68601: LD_VAR 0 2
68605: PPUSH
68606: LD_INT 1
68608: PPUSH
68609: CALL_OW 1
68613: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
68614: LD_VAR 0 2
68618: PPUSH
68619: LD_VAR 0 4
68623: PPUSH
68624: LD_EXP 84
68628: PUSH
68629: LD_VAR 0 2
68633: ARRAY
68634: PPUSH
68635: CALL 104706 0 3
// exit ;
68639: POP
68640: POP
68641: GO 68774
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68643: LD_EXP 82
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PUSH
68654: LD_EXP 102
68658: PUSH
68659: LD_VAR 0 2
68663: ARRAY
68664: NOT
68665: AND
68666: PUSH
68667: LD_EXP 81
68671: PUSH
68672: LD_VAR 0 2
68676: ARRAY
68677: AND
68678: IFFALSE 68770
// begin tmp := mc_defender [ i ] ;
68680: LD_ADDR_VAR 0 4
68684: PUSH
68685: LD_EXP 81
68689: PUSH
68690: LD_VAR 0 2
68694: ARRAY
68695: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68696: LD_ADDR_EXP 81
68700: PUSH
68701: LD_EXP 81
68705: PPUSH
68706: LD_VAR 0 2
68710: PPUSH
68711: EMPTY
68712: PPUSH
68713: CALL_OW 1
68717: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68718: LD_ADDR_EXP 102
68722: PUSH
68723: LD_EXP 102
68727: PPUSH
68728: LD_VAR 0 2
68732: PPUSH
68733: LD_INT 1
68735: PPUSH
68736: CALL_OW 1
68740: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
68741: LD_VAR 0 2
68745: PPUSH
68746: LD_VAR 0 4
68750: PPUSH
68751: LD_EXP 82
68755: PUSH
68756: LD_VAR 0 2
68760: ARRAY
68761: PPUSH
68762: CALL 105267 0 3
// exit ;
68766: POP
68767: POP
68768: GO 68774
// end ; end ;
68770: GO 68090
68772: POP
68773: POP
// end ;
68774: LD_VAR 0 1
68778: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68779: LD_INT 0
68781: PPUSH
68782: PPUSH
68783: PPUSH
68784: PPUSH
68785: PPUSH
68786: PPUSH
68787: PPUSH
68788: PPUSH
68789: PPUSH
68790: PPUSH
68791: PPUSH
// if not mc_bases then
68792: LD_EXP 59
68796: NOT
68797: IFFALSE 68801
// exit ;
68799: GO 69888
// for i = 1 to mc_bases do
68801: LD_ADDR_VAR 0 2
68805: PUSH
68806: DOUBLE
68807: LD_INT 1
68809: DEC
68810: ST_TO_ADDR
68811: LD_EXP 59
68815: PUSH
68816: FOR_TO
68817: IFFALSE 69886
// begin tmp := mc_lab [ i ] ;
68819: LD_ADDR_VAR 0 6
68823: PUSH
68824: LD_EXP 92
68828: PUSH
68829: LD_VAR 0 2
68833: ARRAY
68834: ST_TO_ADDR
// if not tmp then
68835: LD_VAR 0 6
68839: NOT
68840: IFFALSE 68844
// continue ;
68842: GO 68816
// idle_lab := 0 ;
68844: LD_ADDR_VAR 0 11
68848: PUSH
68849: LD_INT 0
68851: ST_TO_ADDR
// for j in tmp do
68852: LD_ADDR_VAR 0 3
68856: PUSH
68857: LD_VAR 0 6
68861: PUSH
68862: FOR_IN
68863: IFFALSE 69882
// begin researching := false ;
68865: LD_ADDR_VAR 0 10
68869: PUSH
68870: LD_INT 0
68872: ST_TO_ADDR
// side := GetSide ( j ) ;
68873: LD_ADDR_VAR 0 4
68877: PUSH
68878: LD_VAR 0 3
68882: PPUSH
68883: CALL_OW 255
68887: ST_TO_ADDR
// if not mc_tech [ side ] then
68888: LD_EXP 86
68892: PUSH
68893: LD_VAR 0 4
68897: ARRAY
68898: NOT
68899: IFFALSE 68903
// continue ;
68901: GO 68862
// if BuildingStatus ( j ) = bs_idle then
68903: LD_VAR 0 3
68907: PPUSH
68908: CALL_OW 461
68912: PUSH
68913: LD_INT 2
68915: EQUAL
68916: IFFALSE 69104
// begin if idle_lab and UnitsInside ( j ) < 6 then
68918: LD_VAR 0 11
68922: PUSH
68923: LD_VAR 0 3
68927: PPUSH
68928: CALL_OW 313
68932: PUSH
68933: LD_INT 6
68935: LESS
68936: AND
68937: IFFALSE 69008
// begin tmp2 := UnitsInside ( idle_lab ) ;
68939: LD_ADDR_VAR 0 9
68943: PUSH
68944: LD_VAR 0 11
68948: PPUSH
68949: CALL_OW 313
68953: ST_TO_ADDR
// if tmp2 then
68954: LD_VAR 0 9
68958: IFFALSE 69000
// for x in tmp2 do
68960: LD_ADDR_VAR 0 7
68964: PUSH
68965: LD_VAR 0 9
68969: PUSH
68970: FOR_IN
68971: IFFALSE 68998
// begin ComExitBuilding ( x ) ;
68973: LD_VAR 0 7
68977: PPUSH
68978: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68982: LD_VAR 0 7
68986: PPUSH
68987: LD_VAR 0 3
68991: PPUSH
68992: CALL_OW 180
// end ;
68996: GO 68970
68998: POP
68999: POP
// idle_lab := 0 ;
69000: LD_ADDR_VAR 0 11
69004: PUSH
69005: LD_INT 0
69007: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69008: LD_ADDR_VAR 0 5
69012: PUSH
69013: LD_EXP 86
69017: PUSH
69018: LD_VAR 0 4
69022: ARRAY
69023: PUSH
69024: FOR_IN
69025: IFFALSE 69085
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69027: LD_VAR 0 3
69031: PPUSH
69032: LD_VAR 0 5
69036: PPUSH
69037: CALL_OW 430
69041: PUSH
69042: LD_VAR 0 4
69046: PPUSH
69047: LD_VAR 0 5
69051: PPUSH
69052: CALL 15575 0 2
69056: AND
69057: IFFALSE 69083
// begin researching := true ;
69059: LD_ADDR_VAR 0 10
69063: PUSH
69064: LD_INT 1
69066: ST_TO_ADDR
// ComResearch ( j , t ) ;
69067: LD_VAR 0 3
69071: PPUSH
69072: LD_VAR 0 5
69076: PPUSH
69077: CALL_OW 124
// break ;
69081: GO 69085
// end ;
69083: GO 69024
69085: POP
69086: POP
// if not researching then
69087: LD_VAR 0 10
69091: NOT
69092: IFFALSE 69104
// idle_lab := j ;
69094: LD_ADDR_VAR 0 11
69098: PUSH
69099: LD_VAR 0 3
69103: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69104: LD_VAR 0 3
69108: PPUSH
69109: CALL_OW 461
69113: PUSH
69114: LD_INT 10
69116: EQUAL
69117: IFFALSE 69705
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69119: LD_EXP 88
69123: PUSH
69124: LD_VAR 0 2
69128: ARRAY
69129: NOT
69130: PUSH
69131: LD_EXP 89
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: NOT
69142: AND
69143: PUSH
69144: LD_EXP 86
69148: PUSH
69149: LD_VAR 0 4
69153: ARRAY
69154: PUSH
69155: LD_INT 1
69157: GREATER
69158: AND
69159: IFFALSE 69290
// begin ComCancel ( j ) ;
69161: LD_VAR 0 3
69165: PPUSH
69166: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69170: LD_ADDR_EXP 86
69174: PUSH
69175: LD_EXP 86
69179: PPUSH
69180: LD_VAR 0 4
69184: PPUSH
69185: LD_EXP 86
69189: PUSH
69190: LD_VAR 0 4
69194: ARRAY
69195: PPUSH
69196: LD_EXP 86
69200: PUSH
69201: LD_VAR 0 4
69205: ARRAY
69206: PUSH
69207: LD_INT 1
69209: MINUS
69210: PPUSH
69211: LD_EXP 86
69215: PUSH
69216: LD_VAR 0 4
69220: ARRAY
69221: PPUSH
69222: LD_INT 0
69224: PPUSH
69225: CALL 19087 0 4
69229: PPUSH
69230: CALL_OW 1
69234: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69235: LD_ADDR_EXP 86
69239: PUSH
69240: LD_EXP 86
69244: PPUSH
69245: LD_VAR 0 4
69249: PPUSH
69250: LD_EXP 86
69254: PUSH
69255: LD_VAR 0 4
69259: ARRAY
69260: PPUSH
69261: LD_EXP 86
69265: PUSH
69266: LD_VAR 0 4
69270: ARRAY
69271: PPUSH
69272: LD_INT 1
69274: PPUSH
69275: LD_INT 0
69277: PPUSH
69278: CALL 19087 0 4
69282: PPUSH
69283: CALL_OW 1
69287: ST_TO_ADDR
// continue ;
69288: GO 68862
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69290: LD_EXP 88
69294: PUSH
69295: LD_VAR 0 2
69299: ARRAY
69300: PUSH
69301: LD_EXP 89
69305: PUSH
69306: LD_VAR 0 2
69310: ARRAY
69311: NOT
69312: AND
69313: IFFALSE 69440
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69315: LD_ADDR_EXP 89
69319: PUSH
69320: LD_EXP 89
69324: PPUSH
69325: LD_VAR 0 2
69329: PUSH
69330: LD_EXP 89
69334: PUSH
69335: LD_VAR 0 2
69339: ARRAY
69340: PUSH
69341: LD_INT 1
69343: PLUS
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PPUSH
69349: LD_EXP 88
69353: PUSH
69354: LD_VAR 0 2
69358: ARRAY
69359: PUSH
69360: LD_INT 1
69362: ARRAY
69363: PPUSH
69364: CALL 19669 0 3
69368: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69369: LD_EXP 88
69373: PUSH
69374: LD_VAR 0 2
69378: ARRAY
69379: PUSH
69380: LD_INT 1
69382: ARRAY
69383: PPUSH
69384: LD_INT 112
69386: PPUSH
69387: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69391: LD_ADDR_VAR 0 9
69395: PUSH
69396: LD_EXP 88
69400: PUSH
69401: LD_VAR 0 2
69405: ARRAY
69406: PPUSH
69407: LD_INT 1
69409: PPUSH
69410: CALL_OW 3
69414: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69415: LD_ADDR_EXP 88
69419: PUSH
69420: LD_EXP 88
69424: PPUSH
69425: LD_VAR 0 2
69429: PPUSH
69430: LD_VAR 0 9
69434: PPUSH
69435: CALL_OW 1
69439: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69440: LD_EXP 88
69444: PUSH
69445: LD_VAR 0 2
69449: ARRAY
69450: PUSH
69451: LD_EXP 89
69455: PUSH
69456: LD_VAR 0 2
69460: ARRAY
69461: AND
69462: PUSH
69463: LD_EXP 89
69467: PUSH
69468: LD_VAR 0 2
69472: ARRAY
69473: PUSH
69474: LD_INT 1
69476: ARRAY
69477: PPUSH
69478: CALL_OW 310
69482: NOT
69483: AND
69484: PUSH
69485: LD_VAR 0 3
69489: PPUSH
69490: CALL_OW 313
69494: PUSH
69495: LD_INT 6
69497: EQUAL
69498: AND
69499: IFFALSE 69555
// begin tmp2 := UnitsInside ( j ) ;
69501: LD_ADDR_VAR 0 9
69505: PUSH
69506: LD_VAR 0 3
69510: PPUSH
69511: CALL_OW 313
69515: ST_TO_ADDR
// if tmp2 = 6 then
69516: LD_VAR 0 9
69520: PUSH
69521: LD_INT 6
69523: EQUAL
69524: IFFALSE 69555
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69526: LD_VAR 0 9
69530: PUSH
69531: LD_INT 1
69533: ARRAY
69534: PPUSH
69535: LD_INT 112
69537: PPUSH
69538: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69542: LD_VAR 0 9
69546: PUSH
69547: LD_INT 1
69549: ARRAY
69550: PPUSH
69551: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69555: LD_EXP 89
69559: PUSH
69560: LD_VAR 0 2
69564: ARRAY
69565: PUSH
69566: LD_EXP 89
69570: PUSH
69571: LD_VAR 0 2
69575: ARRAY
69576: PUSH
69577: LD_INT 1
69579: ARRAY
69580: PPUSH
69581: CALL_OW 314
69585: NOT
69586: AND
69587: PUSH
69588: LD_EXP 89
69592: PUSH
69593: LD_VAR 0 2
69597: ARRAY
69598: PUSH
69599: LD_INT 1
69601: ARRAY
69602: PPUSH
69603: CALL_OW 310
69607: NOT
69608: AND
69609: IFFALSE 69635
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69611: LD_EXP 89
69615: PUSH
69616: LD_VAR 0 2
69620: ARRAY
69621: PUSH
69622: LD_INT 1
69624: ARRAY
69625: PPUSH
69626: LD_VAR 0 3
69630: PPUSH
69631: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69635: LD_EXP 89
69639: PUSH
69640: LD_VAR 0 2
69644: ARRAY
69645: PUSH
69646: LD_INT 1
69648: ARRAY
69649: PPUSH
69650: CALL_OW 310
69654: PUSH
69655: LD_EXP 89
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: PUSH
69666: LD_INT 1
69668: ARRAY
69669: PPUSH
69670: CALL_OW 310
69674: PPUSH
69675: CALL_OW 461
69679: PUSH
69680: LD_INT 3
69682: NONEQUAL
69683: AND
69684: IFFALSE 69705
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69686: LD_EXP 89
69690: PUSH
69691: LD_VAR 0 2
69695: ARRAY
69696: PUSH
69697: LD_INT 1
69699: ARRAY
69700: PPUSH
69701: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69705: LD_VAR 0 3
69709: PPUSH
69710: CALL_OW 461
69714: PUSH
69715: LD_INT 6
69717: EQUAL
69718: PUSH
69719: LD_VAR 0 6
69723: PUSH
69724: LD_INT 1
69726: GREATER
69727: AND
69728: IFFALSE 69880
// begin sci := [ ] ;
69730: LD_ADDR_VAR 0 8
69734: PUSH
69735: EMPTY
69736: ST_TO_ADDR
// for x in ( tmp diff j ) do
69737: LD_ADDR_VAR 0 7
69741: PUSH
69742: LD_VAR 0 6
69746: PUSH
69747: LD_VAR 0 3
69751: DIFF
69752: PUSH
69753: FOR_IN
69754: IFFALSE 69806
// begin if sci = 6 then
69756: LD_VAR 0 8
69760: PUSH
69761: LD_INT 6
69763: EQUAL
69764: IFFALSE 69768
// break ;
69766: GO 69806
// if BuildingStatus ( x ) = bs_idle then
69768: LD_VAR 0 7
69772: PPUSH
69773: CALL_OW 461
69777: PUSH
69778: LD_INT 2
69780: EQUAL
69781: IFFALSE 69804
// sci := sci ^ UnitsInside ( x ) ;
69783: LD_ADDR_VAR 0 8
69787: PUSH
69788: LD_VAR 0 8
69792: PUSH
69793: LD_VAR 0 7
69797: PPUSH
69798: CALL_OW 313
69802: ADD
69803: ST_TO_ADDR
// end ;
69804: GO 69753
69806: POP
69807: POP
// if not sci then
69808: LD_VAR 0 8
69812: NOT
69813: IFFALSE 69817
// continue ;
69815: GO 68862
// for x in sci do
69817: LD_ADDR_VAR 0 7
69821: PUSH
69822: LD_VAR 0 8
69826: PUSH
69827: FOR_IN
69828: IFFALSE 69878
// if IsInUnit ( x ) and not HasTask ( x ) then
69830: LD_VAR 0 7
69834: PPUSH
69835: CALL_OW 310
69839: PUSH
69840: LD_VAR 0 7
69844: PPUSH
69845: CALL_OW 314
69849: NOT
69850: AND
69851: IFFALSE 69876
// begin ComExitBuilding ( x ) ;
69853: LD_VAR 0 7
69857: PPUSH
69858: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69862: LD_VAR 0 7
69866: PPUSH
69867: LD_VAR 0 3
69871: PPUSH
69872: CALL_OW 180
// end ;
69876: GO 69827
69878: POP
69879: POP
// end ; end ;
69880: GO 68862
69882: POP
69883: POP
// end ;
69884: GO 68816
69886: POP
69887: POP
// end ;
69888: LD_VAR 0 1
69892: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69893: LD_INT 0
69895: PPUSH
69896: PPUSH
// if not mc_bases then
69897: LD_EXP 59
69901: NOT
69902: IFFALSE 69906
// exit ;
69904: GO 69987
// for i = 1 to mc_bases do
69906: LD_ADDR_VAR 0 2
69910: PUSH
69911: DOUBLE
69912: LD_INT 1
69914: DEC
69915: ST_TO_ADDR
69916: LD_EXP 59
69920: PUSH
69921: FOR_TO
69922: IFFALSE 69985
// if mc_mines [ i ] and mc_miners [ i ] then
69924: LD_EXP 72
69928: PUSH
69929: LD_VAR 0 2
69933: ARRAY
69934: PUSH
69935: LD_EXP 73
69939: PUSH
69940: LD_VAR 0 2
69944: ARRAY
69945: AND
69946: IFFALSE 69983
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69948: LD_EXP 73
69952: PUSH
69953: LD_VAR 0 2
69957: ARRAY
69958: PUSH
69959: LD_INT 1
69961: ARRAY
69962: PPUSH
69963: CALL_OW 255
69967: PPUSH
69968: LD_EXP 72
69972: PUSH
69973: LD_VAR 0 2
69977: ARRAY
69978: PPUSH
69979: CALL 16658 0 2
69983: GO 69921
69985: POP
69986: POP
// end ;
69987: LD_VAR 0 1
69991: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69992: LD_INT 0
69994: PPUSH
69995: PPUSH
69996: PPUSH
69997: PPUSH
69998: PPUSH
69999: PPUSH
70000: PPUSH
70001: PPUSH
// if not mc_bases or not mc_parking then
70002: LD_EXP 59
70006: NOT
70007: PUSH
70008: LD_EXP 83
70012: NOT
70013: OR
70014: IFFALSE 70018
// exit ;
70016: GO 70717
// for i = 1 to mc_bases do
70018: LD_ADDR_VAR 0 2
70022: PUSH
70023: DOUBLE
70024: LD_INT 1
70026: DEC
70027: ST_TO_ADDR
70028: LD_EXP 59
70032: PUSH
70033: FOR_TO
70034: IFFALSE 70715
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70036: LD_EXP 59
70040: PUSH
70041: LD_VAR 0 2
70045: ARRAY
70046: NOT
70047: PUSH
70048: LD_EXP 83
70052: PUSH
70053: LD_VAR 0 2
70057: ARRAY
70058: NOT
70059: OR
70060: IFFALSE 70064
// continue ;
70062: GO 70033
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70064: LD_ADDR_VAR 0 5
70068: PUSH
70069: LD_EXP 59
70073: PUSH
70074: LD_VAR 0 2
70078: ARRAY
70079: PUSH
70080: LD_INT 1
70082: ARRAY
70083: PPUSH
70084: CALL_OW 255
70088: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70089: LD_ADDR_VAR 0 6
70093: PUSH
70094: LD_EXP 59
70098: PUSH
70099: LD_VAR 0 2
70103: ARRAY
70104: PPUSH
70105: LD_INT 30
70107: PUSH
70108: LD_INT 3
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PPUSH
70115: CALL_OW 72
70119: ST_TO_ADDR
// if not fac then
70120: LD_VAR 0 6
70124: NOT
70125: IFFALSE 70176
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70127: LD_ADDR_VAR 0 6
70131: PUSH
70132: LD_EXP 59
70136: PUSH
70137: LD_VAR 0 2
70141: ARRAY
70142: PPUSH
70143: LD_INT 2
70145: PUSH
70146: LD_INT 30
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 30
70158: PUSH
70159: LD_INT 1
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: LIST
70170: PPUSH
70171: CALL_OW 72
70175: ST_TO_ADDR
// if not fac then
70176: LD_VAR 0 6
70180: NOT
70181: IFFALSE 70185
// continue ;
70183: GO 70033
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70185: LD_ADDR_VAR 0 7
70189: PUSH
70190: LD_EXP 83
70194: PUSH
70195: LD_VAR 0 2
70199: ARRAY
70200: PPUSH
70201: LD_INT 22
70203: PUSH
70204: LD_VAR 0 5
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 21
70215: PUSH
70216: LD_INT 2
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 3
70225: PUSH
70226: LD_INT 24
70228: PUSH
70229: LD_INT 1000
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: LIST
70244: PPUSH
70245: CALL_OW 70
70249: ST_TO_ADDR
// for j in fac do
70250: LD_ADDR_VAR 0 3
70254: PUSH
70255: LD_VAR 0 6
70259: PUSH
70260: FOR_IN
70261: IFFALSE 70342
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70263: LD_ADDR_VAR 0 7
70267: PUSH
70268: LD_VAR 0 7
70272: PUSH
70273: LD_INT 22
70275: PUSH
70276: LD_VAR 0 5
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 91
70287: PUSH
70288: LD_VAR 0 3
70292: PUSH
70293: LD_INT 15
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 21
70303: PUSH
70304: LD_INT 2
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: PUSH
70311: LD_INT 3
70313: PUSH
70314: LD_INT 24
70316: PUSH
70317: LD_INT 1000
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: PPUSH
70334: CALL_OW 69
70338: UNION
70339: ST_TO_ADDR
70340: GO 70260
70342: POP
70343: POP
// if not vehs then
70344: LD_VAR 0 7
70348: NOT
70349: IFFALSE 70375
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70351: LD_ADDR_EXP 71
70355: PUSH
70356: LD_EXP 71
70360: PPUSH
70361: LD_VAR 0 2
70365: PPUSH
70366: EMPTY
70367: PPUSH
70368: CALL_OW 1
70372: ST_TO_ADDR
// continue ;
70373: GO 70033
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70375: LD_ADDR_VAR 0 8
70379: PUSH
70380: LD_EXP 59
70384: PUSH
70385: LD_VAR 0 2
70389: ARRAY
70390: PPUSH
70391: LD_INT 30
70393: PUSH
70394: LD_INT 3
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PPUSH
70401: CALL_OW 72
70405: ST_TO_ADDR
// if tmp then
70406: LD_VAR 0 8
70410: IFFALSE 70513
// begin for j in tmp do
70412: LD_ADDR_VAR 0 3
70416: PUSH
70417: LD_VAR 0 8
70421: PUSH
70422: FOR_IN
70423: IFFALSE 70511
// for k in UnitsInside ( j ) do
70425: LD_ADDR_VAR 0 4
70429: PUSH
70430: LD_VAR 0 3
70434: PPUSH
70435: CALL_OW 313
70439: PUSH
70440: FOR_IN
70441: IFFALSE 70507
// if k then
70443: LD_VAR 0 4
70447: IFFALSE 70505
// if not k in mc_repair_vehicle [ i ] then
70449: LD_VAR 0 4
70453: PUSH
70454: LD_EXP 71
70458: PUSH
70459: LD_VAR 0 2
70463: ARRAY
70464: IN
70465: NOT
70466: IFFALSE 70505
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70468: LD_ADDR_EXP 71
70472: PUSH
70473: LD_EXP 71
70477: PPUSH
70478: LD_VAR 0 2
70482: PPUSH
70483: LD_EXP 71
70487: PUSH
70488: LD_VAR 0 2
70492: ARRAY
70493: PUSH
70494: LD_VAR 0 4
70498: UNION
70499: PPUSH
70500: CALL_OW 1
70504: ST_TO_ADDR
70505: GO 70440
70507: POP
70508: POP
70509: GO 70422
70511: POP
70512: POP
// end ; if not mc_repair_vehicle [ i ] then
70513: LD_EXP 71
70517: PUSH
70518: LD_VAR 0 2
70522: ARRAY
70523: NOT
70524: IFFALSE 70528
// continue ;
70526: GO 70033
// for j in mc_repair_vehicle [ i ] do
70528: LD_ADDR_VAR 0 3
70532: PUSH
70533: LD_EXP 71
70537: PUSH
70538: LD_VAR 0 2
70542: ARRAY
70543: PUSH
70544: FOR_IN
70545: IFFALSE 70711
// begin if GetClass ( j ) <> 3 then
70547: LD_VAR 0 3
70551: PPUSH
70552: CALL_OW 257
70556: PUSH
70557: LD_INT 3
70559: NONEQUAL
70560: IFFALSE 70601
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70562: LD_ADDR_EXP 71
70566: PUSH
70567: LD_EXP 71
70571: PPUSH
70572: LD_VAR 0 2
70576: PPUSH
70577: LD_EXP 71
70581: PUSH
70582: LD_VAR 0 2
70586: ARRAY
70587: PUSH
70588: LD_VAR 0 3
70592: DIFF
70593: PPUSH
70594: CALL_OW 1
70598: ST_TO_ADDR
// continue ;
70599: GO 70544
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70601: LD_VAR 0 3
70605: PPUSH
70606: CALL_OW 311
70610: NOT
70611: PUSH
70612: LD_VAR 0 3
70616: PUSH
70617: LD_EXP 62
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PUSH
70628: LD_INT 1
70630: ARRAY
70631: IN
70632: NOT
70633: AND
70634: PUSH
70635: LD_VAR 0 3
70639: PUSH
70640: LD_EXP 62
70644: PUSH
70645: LD_VAR 0 2
70649: ARRAY
70650: PUSH
70651: LD_INT 2
70653: ARRAY
70654: IN
70655: NOT
70656: AND
70657: IFFALSE 70709
// begin if IsInUnit ( j ) then
70659: LD_VAR 0 3
70663: PPUSH
70664: CALL_OW 310
70668: IFFALSE 70679
// ComExitBuilding ( j ) ;
70670: LD_VAR 0 3
70674: PPUSH
70675: CALL_OW 122
// if not HasTask ( j ) then
70679: LD_VAR 0 3
70683: PPUSH
70684: CALL_OW 314
70688: NOT
70689: IFFALSE 70709
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
70691: LD_VAR 0 3
70695: PPUSH
70696: LD_VAR 0 7
70700: PUSH
70701: LD_INT 1
70703: ARRAY
70704: PPUSH
70705: CALL_OW 189
// end ; end ;
70709: GO 70544
70711: POP
70712: POP
// end ;
70713: GO 70033
70715: POP
70716: POP
// end ;
70717: LD_VAR 0 1
70721: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70722: LD_INT 0
70724: PPUSH
70725: PPUSH
70726: PPUSH
70727: PPUSH
70728: PPUSH
70729: PPUSH
70730: PPUSH
70731: PPUSH
70732: PPUSH
70733: PPUSH
70734: PPUSH
// if not mc_bases then
70735: LD_EXP 59
70739: NOT
70740: IFFALSE 70744
// exit ;
70742: GO 71546
// for i = 1 to mc_bases do
70744: LD_ADDR_VAR 0 2
70748: PUSH
70749: DOUBLE
70750: LD_INT 1
70752: DEC
70753: ST_TO_ADDR
70754: LD_EXP 59
70758: PUSH
70759: FOR_TO
70760: IFFALSE 71544
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70762: LD_EXP 87
70766: PUSH
70767: LD_VAR 0 2
70771: ARRAY
70772: NOT
70773: PUSH
70774: LD_EXP 62
70778: PUSH
70779: LD_VAR 0 2
70783: ARRAY
70784: PUSH
70785: LD_INT 1
70787: ARRAY
70788: OR
70789: PUSH
70790: LD_EXP 62
70794: PUSH
70795: LD_VAR 0 2
70799: ARRAY
70800: PUSH
70801: LD_INT 2
70803: ARRAY
70804: OR
70805: PUSH
70806: LD_EXP 85
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: PPUSH
70817: LD_INT 1
70819: PPUSH
70820: CALL_OW 325
70824: NOT
70825: OR
70826: PUSH
70827: LD_EXP 82
70831: PUSH
70832: LD_VAR 0 2
70836: ARRAY
70837: OR
70838: IFFALSE 70842
// continue ;
70840: GO 70759
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70842: LD_ADDR_VAR 0 8
70846: PUSH
70847: LD_EXP 59
70851: PUSH
70852: LD_VAR 0 2
70856: ARRAY
70857: PPUSH
70858: LD_INT 25
70860: PUSH
70861: LD_INT 4
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 50
70870: PUSH
70871: EMPTY
70872: LIST
70873: PUSH
70874: LD_INT 3
70876: PUSH
70877: LD_INT 60
70879: PUSH
70880: EMPTY
70881: LIST
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: LIST
70891: PPUSH
70892: CALL_OW 72
70896: PUSH
70897: LD_EXP 63
70901: PUSH
70902: LD_VAR 0 2
70906: ARRAY
70907: DIFF
70908: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70909: LD_ADDR_VAR 0 9
70913: PUSH
70914: LD_EXP 59
70918: PUSH
70919: LD_VAR 0 2
70923: ARRAY
70924: PPUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 30
70930: PUSH
70931: LD_INT 0
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 30
70940: PUSH
70941: LD_INT 1
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: LIST
70952: PPUSH
70953: CALL_OW 72
70957: ST_TO_ADDR
// if not tmp or not dep then
70958: LD_VAR 0 8
70962: NOT
70963: PUSH
70964: LD_VAR 0 9
70968: NOT
70969: OR
70970: IFFALSE 70974
// continue ;
70972: GO 70759
// side := GetSide ( tmp [ 1 ] ) ;
70974: LD_ADDR_VAR 0 11
70978: PUSH
70979: LD_VAR 0 8
70983: PUSH
70984: LD_INT 1
70986: ARRAY
70987: PPUSH
70988: CALL_OW 255
70992: ST_TO_ADDR
// dep := dep [ 1 ] ;
70993: LD_ADDR_VAR 0 9
70997: PUSH
70998: LD_VAR 0 9
71002: PUSH
71003: LD_INT 1
71005: ARRAY
71006: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71007: LD_ADDR_VAR 0 7
71011: PUSH
71012: LD_EXP 87
71016: PUSH
71017: LD_VAR 0 2
71021: ARRAY
71022: PPUSH
71023: LD_INT 22
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 25
71035: PUSH
71036: LD_INT 12
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PPUSH
71047: CALL_OW 70
71051: PUSH
71052: LD_INT 22
71054: PUSH
71055: LD_INT 0
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 25
71064: PUSH
71065: LD_INT 12
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 91
71074: PUSH
71075: LD_VAR 0 9
71079: PUSH
71080: LD_INT 20
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: LIST
71092: PPUSH
71093: CALL_OW 69
71097: UNION
71098: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71099: LD_ADDR_VAR 0 10
71103: PUSH
71104: LD_EXP 87
71108: PUSH
71109: LD_VAR 0 2
71113: ARRAY
71114: PPUSH
71115: LD_INT 81
71117: PUSH
71118: LD_VAR 0 11
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PPUSH
71127: CALL_OW 70
71131: ST_TO_ADDR
// if not apes or danger_at_area then
71132: LD_VAR 0 7
71136: NOT
71137: PUSH
71138: LD_VAR 0 10
71142: OR
71143: IFFALSE 71193
// begin if mc_taming [ i ] then
71145: LD_EXP 90
71149: PUSH
71150: LD_VAR 0 2
71154: ARRAY
71155: IFFALSE 71191
// begin MC_Reset ( i , 121 ) ;
71157: LD_VAR 0 2
71161: PPUSH
71162: LD_INT 121
71164: PPUSH
71165: CALL 56480 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71169: LD_ADDR_EXP 90
71173: PUSH
71174: LD_EXP 90
71178: PPUSH
71179: LD_VAR 0 2
71183: PPUSH
71184: EMPTY
71185: PPUSH
71186: CALL_OW 1
71190: ST_TO_ADDR
// end ; continue ;
71191: GO 70759
// end ; for j in tmp do
71193: LD_ADDR_VAR 0 3
71197: PUSH
71198: LD_VAR 0 8
71202: PUSH
71203: FOR_IN
71204: IFFALSE 71540
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71206: LD_VAR 0 3
71210: PUSH
71211: LD_EXP 90
71215: PUSH
71216: LD_VAR 0 2
71220: ARRAY
71221: IN
71222: NOT
71223: PUSH
71224: LD_EXP 90
71228: PUSH
71229: LD_VAR 0 2
71233: ARRAY
71234: PUSH
71235: LD_INT 3
71237: LESS
71238: AND
71239: IFFALSE 71297
// begin SetTag ( j , 121 ) ;
71241: LD_VAR 0 3
71245: PPUSH
71246: LD_INT 121
71248: PPUSH
71249: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71253: LD_ADDR_EXP 90
71257: PUSH
71258: LD_EXP 90
71262: PPUSH
71263: LD_VAR 0 2
71267: PUSH
71268: LD_EXP 90
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PUSH
71279: LD_INT 1
71281: PLUS
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PPUSH
71287: LD_VAR 0 3
71291: PPUSH
71292: CALL 19669 0 3
71296: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71297: LD_VAR 0 3
71301: PUSH
71302: LD_EXP 90
71306: PUSH
71307: LD_VAR 0 2
71311: ARRAY
71312: IN
71313: IFFALSE 71538
// begin if GetClass ( j ) <> 4 then
71315: LD_VAR 0 3
71319: PPUSH
71320: CALL_OW 257
71324: PUSH
71325: LD_INT 4
71327: NONEQUAL
71328: IFFALSE 71381
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71330: LD_ADDR_EXP 90
71334: PUSH
71335: LD_EXP 90
71339: PPUSH
71340: LD_VAR 0 2
71344: PPUSH
71345: LD_EXP 90
71349: PUSH
71350: LD_VAR 0 2
71354: ARRAY
71355: PUSH
71356: LD_VAR 0 3
71360: DIFF
71361: PPUSH
71362: CALL_OW 1
71366: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71367: LD_VAR 0 3
71371: PPUSH
71372: LD_INT 0
71374: PPUSH
71375: CALL_OW 109
// continue ;
71379: GO 71203
// end ; if IsInUnit ( j ) then
71381: LD_VAR 0 3
71385: PPUSH
71386: CALL_OW 310
71390: IFFALSE 71401
// ComExitBuilding ( j ) ;
71392: LD_VAR 0 3
71396: PPUSH
71397: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71401: LD_ADDR_VAR 0 6
71405: PUSH
71406: LD_VAR 0 7
71410: PPUSH
71411: LD_VAR 0 3
71415: PPUSH
71416: CALL_OW 74
71420: ST_TO_ADDR
// if not ape then
71421: LD_VAR 0 6
71425: NOT
71426: IFFALSE 71430
// break ;
71428: GO 71540
// x := GetX ( ape ) ;
71430: LD_ADDR_VAR 0 4
71434: PUSH
71435: LD_VAR 0 6
71439: PPUSH
71440: CALL_OW 250
71444: ST_TO_ADDR
// y := GetY ( ape ) ;
71445: LD_ADDR_VAR 0 5
71449: PUSH
71450: LD_VAR 0 6
71454: PPUSH
71455: CALL_OW 251
71459: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71460: LD_VAR 0 4
71464: PPUSH
71465: LD_VAR 0 5
71469: PPUSH
71470: CALL_OW 488
71474: NOT
71475: PUSH
71476: LD_VAR 0 11
71480: PPUSH
71481: LD_VAR 0 4
71485: PPUSH
71486: LD_VAR 0 5
71490: PPUSH
71491: LD_INT 20
71493: PPUSH
71494: CALL 20565 0 4
71498: PUSH
71499: LD_INT 4
71501: ARRAY
71502: OR
71503: IFFALSE 71507
// break ;
71505: GO 71540
// if not HasTask ( j ) then
71507: LD_VAR 0 3
71511: PPUSH
71512: CALL_OW 314
71516: NOT
71517: IFFALSE 71538
// ComTameXY ( j , x , y ) ;
71519: LD_VAR 0 3
71523: PPUSH
71524: LD_VAR 0 4
71528: PPUSH
71529: LD_VAR 0 5
71533: PPUSH
71534: CALL_OW 131
// end ; end ;
71538: GO 71203
71540: POP
71541: POP
// end ;
71542: GO 70759
71544: POP
71545: POP
// end ;
71546: LD_VAR 0 1
71550: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71551: LD_INT 0
71553: PPUSH
71554: PPUSH
71555: PPUSH
71556: PPUSH
71557: PPUSH
71558: PPUSH
71559: PPUSH
71560: PPUSH
// if not mc_bases then
71561: LD_EXP 59
71565: NOT
71566: IFFALSE 71570
// exit ;
71568: GO 72196
// for i = 1 to mc_bases do
71570: LD_ADDR_VAR 0 2
71574: PUSH
71575: DOUBLE
71576: LD_INT 1
71578: DEC
71579: ST_TO_ADDR
71580: LD_EXP 59
71584: PUSH
71585: FOR_TO
71586: IFFALSE 72194
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71588: LD_EXP 88
71592: PUSH
71593: LD_VAR 0 2
71597: ARRAY
71598: NOT
71599: PUSH
71600: LD_EXP 88
71604: PUSH
71605: LD_VAR 0 2
71609: ARRAY
71610: PPUSH
71611: LD_INT 25
71613: PUSH
71614: LD_INT 12
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PPUSH
71621: CALL_OW 72
71625: NOT
71626: OR
71627: IFFALSE 71631
// continue ;
71629: GO 71585
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71631: LD_ADDR_VAR 0 5
71635: PUSH
71636: LD_EXP 88
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: PUSH
71647: LD_INT 1
71649: ARRAY
71650: PPUSH
71651: CALL_OW 255
71655: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71656: LD_VAR 0 5
71660: PPUSH
71661: LD_INT 2
71663: PPUSH
71664: CALL_OW 325
71668: IFFALSE 71921
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71670: LD_ADDR_VAR 0 4
71674: PUSH
71675: LD_EXP 88
71679: PUSH
71680: LD_VAR 0 2
71684: ARRAY
71685: PPUSH
71686: LD_INT 25
71688: PUSH
71689: LD_INT 16
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PPUSH
71696: CALL_OW 72
71700: ST_TO_ADDR
// if tmp < 6 then
71701: LD_VAR 0 4
71705: PUSH
71706: LD_INT 6
71708: LESS
71709: IFFALSE 71921
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71711: LD_ADDR_VAR 0 6
71715: PUSH
71716: LD_EXP 59
71720: PUSH
71721: LD_VAR 0 2
71725: ARRAY
71726: PPUSH
71727: LD_INT 2
71729: PUSH
71730: LD_INT 30
71732: PUSH
71733: LD_INT 0
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 30
71742: PUSH
71743: LD_INT 1
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: LIST
71754: PPUSH
71755: CALL_OW 72
71759: ST_TO_ADDR
// if depot then
71760: LD_VAR 0 6
71764: IFFALSE 71921
// begin selected := 0 ;
71766: LD_ADDR_VAR 0 7
71770: PUSH
71771: LD_INT 0
71773: ST_TO_ADDR
// for j in depot do
71774: LD_ADDR_VAR 0 3
71778: PUSH
71779: LD_VAR 0 6
71783: PUSH
71784: FOR_IN
71785: IFFALSE 71816
// begin if UnitsInside ( j ) < 6 then
71787: LD_VAR 0 3
71791: PPUSH
71792: CALL_OW 313
71796: PUSH
71797: LD_INT 6
71799: LESS
71800: IFFALSE 71814
// begin selected := j ;
71802: LD_ADDR_VAR 0 7
71806: PUSH
71807: LD_VAR 0 3
71811: ST_TO_ADDR
// break ;
71812: GO 71816
// end ; end ;
71814: GO 71784
71816: POP
71817: POP
// if selected then
71818: LD_VAR 0 7
71822: IFFALSE 71921
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71824: LD_ADDR_VAR 0 3
71828: PUSH
71829: LD_EXP 88
71833: PUSH
71834: LD_VAR 0 2
71838: ARRAY
71839: PPUSH
71840: LD_INT 25
71842: PUSH
71843: LD_INT 12
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PPUSH
71850: CALL_OW 72
71854: PUSH
71855: FOR_IN
71856: IFFALSE 71919
// if not HasTask ( j ) then
71858: LD_VAR 0 3
71862: PPUSH
71863: CALL_OW 314
71867: NOT
71868: IFFALSE 71917
// begin if not IsInUnit ( j ) then
71870: LD_VAR 0 3
71874: PPUSH
71875: CALL_OW 310
71879: NOT
71880: IFFALSE 71896
// ComEnterUnit ( j , selected ) ;
71882: LD_VAR 0 3
71886: PPUSH
71887: LD_VAR 0 7
71891: PPUSH
71892: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71896: LD_VAR 0 3
71900: PPUSH
71901: LD_INT 16
71903: PPUSH
71904: CALL_OW 183
// AddComExitBuilding ( j ) ;
71908: LD_VAR 0 3
71912: PPUSH
71913: CALL_OW 182
// end ;
71917: GO 71855
71919: POP
71920: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71921: LD_VAR 0 5
71925: PPUSH
71926: LD_INT 11
71928: PPUSH
71929: CALL_OW 325
71933: IFFALSE 72192
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71935: LD_ADDR_VAR 0 4
71939: PUSH
71940: LD_EXP 88
71944: PUSH
71945: LD_VAR 0 2
71949: ARRAY
71950: PPUSH
71951: LD_INT 25
71953: PUSH
71954: LD_INT 16
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PPUSH
71961: CALL_OW 72
71965: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71966: LD_VAR 0 4
71970: PUSH
71971: LD_INT 6
71973: GREATEREQUAL
71974: PUSH
71975: LD_VAR 0 5
71979: PPUSH
71980: LD_INT 2
71982: PPUSH
71983: CALL_OW 325
71987: NOT
71988: OR
71989: IFFALSE 72192
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71991: LD_ADDR_VAR 0 8
71995: PUSH
71996: LD_EXP 59
72000: PUSH
72001: LD_VAR 0 2
72005: ARRAY
72006: PPUSH
72007: LD_INT 2
72009: PUSH
72010: LD_INT 30
72012: PUSH
72013: LD_INT 4
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 30
72022: PUSH
72023: LD_INT 5
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: LIST
72034: PPUSH
72035: CALL_OW 72
72039: ST_TO_ADDR
// if barracks then
72040: LD_VAR 0 8
72044: IFFALSE 72192
// begin selected := 0 ;
72046: LD_ADDR_VAR 0 7
72050: PUSH
72051: LD_INT 0
72053: ST_TO_ADDR
// for j in barracks do
72054: LD_ADDR_VAR 0 3
72058: PUSH
72059: LD_VAR 0 8
72063: PUSH
72064: FOR_IN
72065: IFFALSE 72096
// begin if UnitsInside ( j ) < 6 then
72067: LD_VAR 0 3
72071: PPUSH
72072: CALL_OW 313
72076: PUSH
72077: LD_INT 6
72079: LESS
72080: IFFALSE 72094
// begin selected := j ;
72082: LD_ADDR_VAR 0 7
72086: PUSH
72087: LD_VAR 0 3
72091: ST_TO_ADDR
// break ;
72092: GO 72096
// end ; end ;
72094: GO 72064
72096: POP
72097: POP
// if selected then
72098: LD_VAR 0 7
72102: IFFALSE 72192
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72104: LD_ADDR_VAR 0 3
72108: PUSH
72109: LD_EXP 88
72113: PUSH
72114: LD_VAR 0 2
72118: ARRAY
72119: PPUSH
72120: LD_INT 25
72122: PUSH
72123: LD_INT 12
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PPUSH
72130: CALL_OW 72
72134: PUSH
72135: FOR_IN
72136: IFFALSE 72190
// if not IsInUnit ( j ) and not HasTask ( j ) then
72138: LD_VAR 0 3
72142: PPUSH
72143: CALL_OW 310
72147: NOT
72148: PUSH
72149: LD_VAR 0 3
72153: PPUSH
72154: CALL_OW 314
72158: NOT
72159: AND
72160: IFFALSE 72188
// begin ComEnterUnit ( j , selected ) ;
72162: LD_VAR 0 3
72166: PPUSH
72167: LD_VAR 0 7
72171: PPUSH
72172: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72176: LD_VAR 0 3
72180: PPUSH
72181: LD_INT 15
72183: PPUSH
72184: CALL_OW 183
// end ;
72188: GO 72135
72190: POP
72191: POP
// end ; end ; end ; end ; end ;
72192: GO 71585
72194: POP
72195: POP
// end ;
72196: LD_VAR 0 1
72200: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72201: LD_INT 0
72203: PPUSH
72204: PPUSH
72205: PPUSH
72206: PPUSH
// if not mc_bases then
72207: LD_EXP 59
72211: NOT
72212: IFFALSE 72216
// exit ;
72214: GO 72394
// for i = 1 to mc_bases do
72216: LD_ADDR_VAR 0 2
72220: PUSH
72221: DOUBLE
72222: LD_INT 1
72224: DEC
72225: ST_TO_ADDR
72226: LD_EXP 59
72230: PUSH
72231: FOR_TO
72232: IFFALSE 72392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72234: LD_ADDR_VAR 0 4
72238: PUSH
72239: LD_EXP 59
72243: PUSH
72244: LD_VAR 0 2
72248: ARRAY
72249: PPUSH
72250: LD_INT 25
72252: PUSH
72253: LD_INT 9
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PPUSH
72260: CALL_OW 72
72264: ST_TO_ADDR
// if not tmp then
72265: LD_VAR 0 4
72269: NOT
72270: IFFALSE 72274
// continue ;
72272: GO 72231
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72274: LD_EXP 85
72278: PUSH
72279: LD_VAR 0 2
72283: ARRAY
72284: PPUSH
72285: LD_INT 29
72287: PPUSH
72288: CALL_OW 325
72292: NOT
72293: PUSH
72294: LD_EXP 85
72298: PUSH
72299: LD_VAR 0 2
72303: ARRAY
72304: PPUSH
72305: LD_INT 28
72307: PPUSH
72308: CALL_OW 325
72312: NOT
72313: AND
72314: IFFALSE 72318
// continue ;
72316: GO 72231
// for j in tmp do
72318: LD_ADDR_VAR 0 3
72322: PUSH
72323: LD_VAR 0 4
72327: PUSH
72328: FOR_IN
72329: IFFALSE 72388
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72331: LD_VAR 0 3
72335: PUSH
72336: LD_EXP 62
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: LD_INT 1
72349: ARRAY
72350: IN
72351: NOT
72352: PUSH
72353: LD_VAR 0 3
72357: PUSH
72358: LD_EXP 62
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PUSH
72369: LD_INT 2
72371: ARRAY
72372: IN
72373: NOT
72374: AND
72375: IFFALSE 72386
// ComSpaceTimeShoot ( j ) ;
72377: LD_VAR 0 3
72381: PPUSH
72382: CALL 15666 0 1
72386: GO 72328
72388: POP
72389: POP
// end ;
72390: GO 72231
72392: POP
72393: POP
// end ;
72394: LD_VAR 0 1
72398: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72399: LD_INT 0
72401: PPUSH
72402: PPUSH
72403: PPUSH
72404: PPUSH
72405: PPUSH
72406: PPUSH
72407: PPUSH
72408: PPUSH
72409: PPUSH
// if not mc_bases then
72410: LD_EXP 59
72414: NOT
72415: IFFALSE 72419
// exit ;
72417: GO 73041
// for i = 1 to mc_bases do
72419: LD_ADDR_VAR 0 2
72423: PUSH
72424: DOUBLE
72425: LD_INT 1
72427: DEC
72428: ST_TO_ADDR
72429: LD_EXP 59
72433: PUSH
72434: FOR_TO
72435: IFFALSE 73039
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72437: LD_EXP 94
72441: PUSH
72442: LD_VAR 0 2
72446: ARRAY
72447: NOT
72448: PUSH
72449: LD_INT 38
72451: PPUSH
72452: LD_EXP 85
72456: PUSH
72457: LD_VAR 0 2
72461: ARRAY
72462: PPUSH
72463: CALL_OW 321
72467: PUSH
72468: LD_INT 2
72470: NONEQUAL
72471: OR
72472: IFFALSE 72476
// continue ;
72474: GO 72434
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72476: LD_ADDR_VAR 0 8
72480: PUSH
72481: LD_EXP 59
72485: PUSH
72486: LD_VAR 0 2
72490: ARRAY
72491: PPUSH
72492: LD_INT 30
72494: PUSH
72495: LD_INT 34
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: CALL_OW 72
72506: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72507: LD_ADDR_VAR 0 9
72511: PUSH
72512: LD_EXP 59
72516: PUSH
72517: LD_VAR 0 2
72521: ARRAY
72522: PPUSH
72523: LD_INT 25
72525: PUSH
72526: LD_INT 4
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PPUSH
72533: CALL_OW 72
72537: PPUSH
72538: LD_INT 0
72540: PPUSH
72541: CALL 48533 0 2
72545: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72546: LD_VAR 0 9
72550: NOT
72551: PUSH
72552: LD_VAR 0 8
72556: NOT
72557: OR
72558: PUSH
72559: LD_EXP 59
72563: PUSH
72564: LD_VAR 0 2
72568: ARRAY
72569: PPUSH
72570: LD_INT 124
72572: PPUSH
72573: CALL 48533 0 2
72577: OR
72578: IFFALSE 72582
// continue ;
72580: GO 72434
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72582: LD_EXP 95
72586: PUSH
72587: LD_VAR 0 2
72591: ARRAY
72592: PUSH
72593: LD_EXP 94
72597: PUSH
72598: LD_VAR 0 2
72602: ARRAY
72603: LESS
72604: PUSH
72605: LD_EXP 95
72609: PUSH
72610: LD_VAR 0 2
72614: ARRAY
72615: PUSH
72616: LD_VAR 0 8
72620: LESS
72621: AND
72622: IFFALSE 73037
// begin tmp := sci [ 1 ] ;
72624: LD_ADDR_VAR 0 7
72628: PUSH
72629: LD_VAR 0 9
72633: PUSH
72634: LD_INT 1
72636: ARRAY
72637: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72638: LD_VAR 0 7
72642: PPUSH
72643: LD_INT 124
72645: PPUSH
72646: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72650: LD_ADDR_VAR 0 3
72654: PUSH
72655: DOUBLE
72656: LD_EXP 94
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: INC
72667: ST_TO_ADDR
72668: LD_EXP 94
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: PUSH
72679: FOR_DOWNTO
72680: IFFALSE 73023
// begin if IsInUnit ( tmp ) then
72682: LD_VAR 0 7
72686: PPUSH
72687: CALL_OW 310
72691: IFFALSE 72702
// ComExitBuilding ( tmp ) ;
72693: LD_VAR 0 7
72697: PPUSH
72698: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72702: LD_INT 35
72704: PPUSH
72705: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72709: LD_VAR 0 7
72713: PPUSH
72714: CALL_OW 310
72718: NOT
72719: PUSH
72720: LD_VAR 0 7
72724: PPUSH
72725: CALL_OW 314
72729: NOT
72730: AND
72731: IFFALSE 72702
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72733: LD_ADDR_VAR 0 6
72737: PUSH
72738: LD_VAR 0 7
72742: PPUSH
72743: CALL_OW 250
72747: PUSH
72748: LD_VAR 0 7
72752: PPUSH
72753: CALL_OW 251
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72762: LD_INT 35
72764: PPUSH
72765: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72769: LD_ADDR_VAR 0 4
72773: PUSH
72774: LD_EXP 94
72778: PUSH
72779: LD_VAR 0 2
72783: ARRAY
72784: PUSH
72785: LD_VAR 0 3
72789: ARRAY
72790: PUSH
72791: LD_INT 1
72793: ARRAY
72794: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72795: LD_ADDR_VAR 0 5
72799: PUSH
72800: LD_EXP 94
72804: PUSH
72805: LD_VAR 0 2
72809: ARRAY
72810: PUSH
72811: LD_VAR 0 3
72815: ARRAY
72816: PUSH
72817: LD_INT 2
72819: ARRAY
72820: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72821: LD_VAR 0 7
72825: PPUSH
72826: LD_INT 10
72828: PPUSH
72829: CALL 22262 0 2
72833: PUSH
72834: LD_INT 4
72836: ARRAY
72837: IFFALSE 72875
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72839: LD_VAR 0 7
72843: PPUSH
72844: LD_VAR 0 6
72848: PUSH
72849: LD_INT 1
72851: ARRAY
72852: PPUSH
72853: LD_VAR 0 6
72857: PUSH
72858: LD_INT 2
72860: ARRAY
72861: PPUSH
72862: CALL_OW 111
// wait ( 0 0$10 ) ;
72866: LD_INT 350
72868: PPUSH
72869: CALL_OW 67
// end else
72873: GO 72901
// begin ComMoveXY ( tmp , x , y ) ;
72875: LD_VAR 0 7
72879: PPUSH
72880: LD_VAR 0 4
72884: PPUSH
72885: LD_VAR 0 5
72889: PPUSH
72890: CALL_OW 111
// wait ( 0 0$3 ) ;
72894: LD_INT 105
72896: PPUSH
72897: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72901: LD_VAR 0 7
72905: PPUSH
72906: LD_VAR 0 4
72910: PPUSH
72911: LD_VAR 0 5
72915: PPUSH
72916: CALL_OW 307
72920: IFFALSE 72762
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72922: LD_VAR 0 7
72926: PPUSH
72927: LD_VAR 0 4
72931: PPUSH
72932: LD_VAR 0 5
72936: PPUSH
72937: LD_VAR 0 8
72941: PUSH
72942: LD_VAR 0 3
72946: ARRAY
72947: PPUSH
72948: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72952: LD_INT 35
72954: PPUSH
72955: CALL_OW 67
// until not HasTask ( tmp ) ;
72959: LD_VAR 0 7
72963: PPUSH
72964: CALL_OW 314
72968: NOT
72969: IFFALSE 72952
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72971: LD_ADDR_EXP 95
72975: PUSH
72976: LD_EXP 95
72980: PPUSH
72981: LD_VAR 0 2
72985: PUSH
72986: LD_EXP 95
72990: PUSH
72991: LD_VAR 0 2
72995: ARRAY
72996: PUSH
72997: LD_INT 1
72999: PLUS
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PPUSH
73005: LD_VAR 0 8
73009: PUSH
73010: LD_VAR 0 3
73014: ARRAY
73015: PPUSH
73016: CALL 19669 0 3
73020: ST_TO_ADDR
// end ;
73021: GO 72679
73023: POP
73024: POP
// MC_Reset ( i , 124 ) ;
73025: LD_VAR 0 2
73029: PPUSH
73030: LD_INT 124
73032: PPUSH
73033: CALL 56480 0 2
// end ; end ;
73037: GO 72434
73039: POP
73040: POP
// end ;
73041: LD_VAR 0 1
73045: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73046: LD_INT 0
73048: PPUSH
73049: PPUSH
73050: PPUSH
// if not mc_bases then
73051: LD_EXP 59
73055: NOT
73056: IFFALSE 73060
// exit ;
73058: GO 73666
// for i = 1 to mc_bases do
73060: LD_ADDR_VAR 0 2
73064: PUSH
73065: DOUBLE
73066: LD_INT 1
73068: DEC
73069: ST_TO_ADDR
73070: LD_EXP 59
73074: PUSH
73075: FOR_TO
73076: IFFALSE 73664
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73078: LD_ADDR_VAR 0 3
73082: PUSH
73083: LD_EXP 59
73087: PUSH
73088: LD_VAR 0 2
73092: ARRAY
73093: PPUSH
73094: LD_INT 25
73096: PUSH
73097: LD_INT 4
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PPUSH
73104: CALL_OW 72
73108: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73109: LD_VAR 0 3
73113: NOT
73114: PUSH
73115: LD_EXP 96
73119: PUSH
73120: LD_VAR 0 2
73124: ARRAY
73125: NOT
73126: OR
73127: PUSH
73128: LD_EXP 59
73132: PUSH
73133: LD_VAR 0 2
73137: ARRAY
73138: PPUSH
73139: LD_INT 2
73141: PUSH
73142: LD_INT 30
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 30
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: LIST
73166: PPUSH
73167: CALL_OW 72
73171: NOT
73172: OR
73173: IFFALSE 73223
// begin if mc_deposits_finder [ i ] then
73175: LD_EXP 97
73179: PUSH
73180: LD_VAR 0 2
73184: ARRAY
73185: IFFALSE 73221
// begin MC_Reset ( i , 125 ) ;
73187: LD_VAR 0 2
73191: PPUSH
73192: LD_INT 125
73194: PPUSH
73195: CALL 56480 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73199: LD_ADDR_EXP 97
73203: PUSH
73204: LD_EXP 97
73208: PPUSH
73209: LD_VAR 0 2
73213: PPUSH
73214: EMPTY
73215: PPUSH
73216: CALL_OW 1
73220: ST_TO_ADDR
// end ; continue ;
73221: GO 73075
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73223: LD_EXP 96
73227: PUSH
73228: LD_VAR 0 2
73232: ARRAY
73233: PUSH
73234: LD_INT 1
73236: ARRAY
73237: PUSH
73238: LD_INT 3
73240: ARRAY
73241: PUSH
73242: LD_INT 1
73244: EQUAL
73245: PUSH
73246: LD_INT 20
73248: PPUSH
73249: LD_EXP 85
73253: PUSH
73254: LD_VAR 0 2
73258: ARRAY
73259: PPUSH
73260: CALL_OW 321
73264: PUSH
73265: LD_INT 2
73267: NONEQUAL
73268: AND
73269: IFFALSE 73319
// begin if mc_deposits_finder [ i ] then
73271: LD_EXP 97
73275: PUSH
73276: LD_VAR 0 2
73280: ARRAY
73281: IFFALSE 73317
// begin MC_Reset ( i , 125 ) ;
73283: LD_VAR 0 2
73287: PPUSH
73288: LD_INT 125
73290: PPUSH
73291: CALL 56480 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73295: LD_ADDR_EXP 97
73299: PUSH
73300: LD_EXP 97
73304: PPUSH
73305: LD_VAR 0 2
73309: PPUSH
73310: EMPTY
73311: PPUSH
73312: CALL_OW 1
73316: ST_TO_ADDR
// end ; continue ;
73317: GO 73075
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73319: LD_EXP 96
73323: PUSH
73324: LD_VAR 0 2
73328: ARRAY
73329: PUSH
73330: LD_INT 1
73332: ARRAY
73333: PUSH
73334: LD_INT 1
73336: ARRAY
73337: PPUSH
73338: LD_EXP 96
73342: PUSH
73343: LD_VAR 0 2
73347: ARRAY
73348: PUSH
73349: LD_INT 1
73351: ARRAY
73352: PUSH
73353: LD_INT 2
73355: ARRAY
73356: PPUSH
73357: LD_EXP 85
73361: PUSH
73362: LD_VAR 0 2
73366: ARRAY
73367: PPUSH
73368: CALL_OW 440
73372: IFFALSE 73415
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73374: LD_ADDR_EXP 96
73378: PUSH
73379: LD_EXP 96
73383: PPUSH
73384: LD_VAR 0 2
73388: PPUSH
73389: LD_EXP 96
73393: PUSH
73394: LD_VAR 0 2
73398: ARRAY
73399: PPUSH
73400: LD_INT 1
73402: PPUSH
73403: CALL_OW 3
73407: PPUSH
73408: CALL_OW 1
73412: ST_TO_ADDR
73413: GO 73662
// begin if not mc_deposits_finder [ i ] then
73415: LD_EXP 97
73419: PUSH
73420: LD_VAR 0 2
73424: ARRAY
73425: NOT
73426: IFFALSE 73478
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73428: LD_ADDR_EXP 97
73432: PUSH
73433: LD_EXP 97
73437: PPUSH
73438: LD_VAR 0 2
73442: PPUSH
73443: LD_VAR 0 3
73447: PUSH
73448: LD_INT 1
73450: ARRAY
73451: PUSH
73452: EMPTY
73453: LIST
73454: PPUSH
73455: CALL_OW 1
73459: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73460: LD_VAR 0 3
73464: PUSH
73465: LD_INT 1
73467: ARRAY
73468: PPUSH
73469: LD_INT 125
73471: PPUSH
73472: CALL_OW 109
// end else
73476: GO 73662
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73478: LD_EXP 97
73482: PUSH
73483: LD_VAR 0 2
73487: ARRAY
73488: PUSH
73489: LD_INT 1
73491: ARRAY
73492: PPUSH
73493: CALL_OW 310
73497: IFFALSE 73520
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73499: LD_EXP 97
73503: PUSH
73504: LD_VAR 0 2
73508: ARRAY
73509: PUSH
73510: LD_INT 1
73512: ARRAY
73513: PPUSH
73514: CALL_OW 122
73518: GO 73662
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73520: LD_EXP 97
73524: PUSH
73525: LD_VAR 0 2
73529: ARRAY
73530: PUSH
73531: LD_INT 1
73533: ARRAY
73534: PPUSH
73535: CALL_OW 314
73539: NOT
73540: PUSH
73541: LD_EXP 97
73545: PUSH
73546: LD_VAR 0 2
73550: ARRAY
73551: PUSH
73552: LD_INT 1
73554: ARRAY
73555: PPUSH
73556: LD_EXP 96
73560: PUSH
73561: LD_VAR 0 2
73565: ARRAY
73566: PUSH
73567: LD_INT 1
73569: ARRAY
73570: PUSH
73571: LD_INT 1
73573: ARRAY
73574: PPUSH
73575: LD_EXP 96
73579: PUSH
73580: LD_VAR 0 2
73584: ARRAY
73585: PUSH
73586: LD_INT 1
73588: ARRAY
73589: PUSH
73590: LD_INT 2
73592: ARRAY
73593: PPUSH
73594: CALL_OW 297
73598: PUSH
73599: LD_INT 6
73601: GREATER
73602: AND
73603: IFFALSE 73662
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73605: LD_EXP 97
73609: PUSH
73610: LD_VAR 0 2
73614: ARRAY
73615: PUSH
73616: LD_INT 1
73618: ARRAY
73619: PPUSH
73620: LD_EXP 96
73624: PUSH
73625: LD_VAR 0 2
73629: ARRAY
73630: PUSH
73631: LD_INT 1
73633: ARRAY
73634: PUSH
73635: LD_INT 1
73637: ARRAY
73638: PPUSH
73639: LD_EXP 96
73643: PUSH
73644: LD_VAR 0 2
73648: ARRAY
73649: PUSH
73650: LD_INT 1
73652: ARRAY
73653: PUSH
73654: LD_INT 2
73656: ARRAY
73657: PPUSH
73658: CALL_OW 111
// end ; end ; end ;
73662: GO 73075
73664: POP
73665: POP
// end ;
73666: LD_VAR 0 1
73670: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73671: LD_INT 0
73673: PPUSH
73674: PPUSH
73675: PPUSH
73676: PPUSH
73677: PPUSH
73678: PPUSH
73679: PPUSH
73680: PPUSH
73681: PPUSH
73682: PPUSH
73683: PPUSH
// if not mc_bases then
73684: LD_EXP 59
73688: NOT
73689: IFFALSE 73693
// exit ;
73691: GO 74633
// for i = 1 to mc_bases do
73693: LD_ADDR_VAR 0 2
73697: PUSH
73698: DOUBLE
73699: LD_INT 1
73701: DEC
73702: ST_TO_ADDR
73703: LD_EXP 59
73707: PUSH
73708: FOR_TO
73709: IFFALSE 74631
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73711: LD_EXP 59
73715: PUSH
73716: LD_VAR 0 2
73720: ARRAY
73721: NOT
73722: PUSH
73723: LD_EXP 82
73727: PUSH
73728: LD_VAR 0 2
73732: ARRAY
73733: OR
73734: IFFALSE 73738
// continue ;
73736: GO 73708
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73738: LD_ADDR_VAR 0 7
73742: PUSH
73743: LD_EXP 59
73747: PUSH
73748: LD_VAR 0 2
73752: ARRAY
73753: PUSH
73754: LD_INT 1
73756: ARRAY
73757: PPUSH
73758: CALL_OW 248
73762: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73763: LD_VAR 0 7
73767: PUSH
73768: LD_INT 3
73770: EQUAL
73771: PUSH
73772: LD_EXP 78
73776: PUSH
73777: LD_VAR 0 2
73781: ARRAY
73782: PUSH
73783: LD_EXP 81
73787: PUSH
73788: LD_VAR 0 2
73792: ARRAY
73793: UNION
73794: PPUSH
73795: LD_INT 33
73797: PUSH
73798: LD_INT 2
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PPUSH
73805: CALL_OW 72
73809: NOT
73810: OR
73811: IFFALSE 73815
// continue ;
73813: GO 73708
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73815: LD_ADDR_VAR 0 9
73819: PUSH
73820: LD_EXP 59
73824: PUSH
73825: LD_VAR 0 2
73829: ARRAY
73830: PPUSH
73831: LD_INT 30
73833: PUSH
73834: LD_INT 36
73836: PUSH
73837: EMPTY
73838: LIST
73839: LIST
73840: PPUSH
73841: CALL_OW 72
73845: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73846: LD_ADDR_VAR 0 10
73850: PUSH
73851: LD_EXP 78
73855: PUSH
73856: LD_VAR 0 2
73860: ARRAY
73861: PPUSH
73862: LD_INT 34
73864: PUSH
73865: LD_INT 31
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PPUSH
73872: CALL_OW 72
73876: ST_TO_ADDR
// if not cts and not mcts then
73877: LD_VAR 0 9
73881: NOT
73882: PUSH
73883: LD_VAR 0 10
73887: NOT
73888: AND
73889: IFFALSE 73893
// continue ;
73891: GO 73708
// x := cts ;
73893: LD_ADDR_VAR 0 11
73897: PUSH
73898: LD_VAR 0 9
73902: ST_TO_ADDR
// if not x then
73903: LD_VAR 0 11
73907: NOT
73908: IFFALSE 73920
// x := mcts ;
73910: LD_ADDR_VAR 0 11
73914: PUSH
73915: LD_VAR 0 10
73919: ST_TO_ADDR
// if not x then
73920: LD_VAR 0 11
73924: NOT
73925: IFFALSE 73929
// continue ;
73927: GO 73708
// if mc_remote_driver [ i ] then
73929: LD_EXP 99
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: IFFALSE 74326
// for j in mc_remote_driver [ i ] do
73941: LD_ADDR_VAR 0 3
73945: PUSH
73946: LD_EXP 99
73950: PUSH
73951: LD_VAR 0 2
73955: ARRAY
73956: PUSH
73957: FOR_IN
73958: IFFALSE 74324
// begin if GetClass ( j ) <> 3 then
73960: LD_VAR 0 3
73964: PPUSH
73965: CALL_OW 257
73969: PUSH
73970: LD_INT 3
73972: NONEQUAL
73973: IFFALSE 74026
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73975: LD_ADDR_EXP 99
73979: PUSH
73980: LD_EXP 99
73984: PPUSH
73985: LD_VAR 0 2
73989: PPUSH
73990: LD_EXP 99
73994: PUSH
73995: LD_VAR 0 2
73999: ARRAY
74000: PUSH
74001: LD_VAR 0 3
74005: DIFF
74006: PPUSH
74007: CALL_OW 1
74011: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74012: LD_VAR 0 3
74016: PPUSH
74017: LD_INT 0
74019: PPUSH
74020: CALL_OW 109
// continue ;
74024: GO 73957
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74026: LD_EXP 78
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: PPUSH
74037: LD_INT 34
74039: PUSH
74040: LD_INT 31
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 58
74049: PUSH
74050: EMPTY
74051: LIST
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PPUSH
74057: CALL_OW 72
74061: PUSH
74062: LD_VAR 0 3
74066: PPUSH
74067: CALL 48621 0 1
74071: NOT
74072: AND
74073: IFFALSE 74144
// begin if IsInUnit ( j ) then
74075: LD_VAR 0 3
74079: PPUSH
74080: CALL_OW 310
74084: IFFALSE 74095
// ComExitBuilding ( j ) ;
74086: LD_VAR 0 3
74090: PPUSH
74091: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74095: LD_VAR 0 3
74099: PPUSH
74100: LD_EXP 78
74104: PUSH
74105: LD_VAR 0 2
74109: ARRAY
74110: PPUSH
74111: LD_INT 34
74113: PUSH
74114: LD_INT 31
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: LD_INT 58
74123: PUSH
74124: EMPTY
74125: LIST
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PPUSH
74131: CALL_OW 72
74135: PUSH
74136: LD_INT 1
74138: ARRAY
74139: PPUSH
74140: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74144: LD_VAR 0 3
74148: PPUSH
74149: CALL_OW 310
74153: NOT
74154: PUSH
74155: LD_VAR 0 3
74159: PPUSH
74160: CALL_OW 310
74164: PPUSH
74165: CALL_OW 266
74169: PUSH
74170: LD_INT 36
74172: NONEQUAL
74173: PUSH
74174: LD_VAR 0 3
74178: PPUSH
74179: CALL 48621 0 1
74183: NOT
74184: AND
74185: OR
74186: IFFALSE 74322
// begin if IsInUnit ( j ) then
74188: LD_VAR 0 3
74192: PPUSH
74193: CALL_OW 310
74197: IFFALSE 74208
// ComExitBuilding ( j ) ;
74199: LD_VAR 0 3
74203: PPUSH
74204: CALL_OW 122
// ct := 0 ;
74208: LD_ADDR_VAR 0 8
74212: PUSH
74213: LD_INT 0
74215: ST_TO_ADDR
// for k in x do
74216: LD_ADDR_VAR 0 4
74220: PUSH
74221: LD_VAR 0 11
74225: PUSH
74226: FOR_IN
74227: IFFALSE 74300
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74229: LD_VAR 0 4
74233: PPUSH
74234: CALL_OW 264
74238: PUSH
74239: LD_INT 31
74241: EQUAL
74242: PUSH
74243: LD_VAR 0 4
74247: PPUSH
74248: CALL_OW 311
74252: NOT
74253: AND
74254: PUSH
74255: LD_VAR 0 4
74259: PPUSH
74260: CALL_OW 266
74264: PUSH
74265: LD_INT 36
74267: EQUAL
74268: PUSH
74269: LD_VAR 0 4
74273: PPUSH
74274: CALL_OW 313
74278: PUSH
74279: LD_INT 3
74281: LESS
74282: AND
74283: OR
74284: IFFALSE 74298
// begin ct := k ;
74286: LD_ADDR_VAR 0 8
74290: PUSH
74291: LD_VAR 0 4
74295: ST_TO_ADDR
// break ;
74296: GO 74300
// end ;
74298: GO 74226
74300: POP
74301: POP
// if ct then
74302: LD_VAR 0 8
74306: IFFALSE 74322
// ComEnterUnit ( j , ct ) ;
74308: LD_VAR 0 3
74312: PPUSH
74313: LD_VAR 0 8
74317: PPUSH
74318: CALL_OW 120
// end ; end ;
74322: GO 73957
74324: POP
74325: POP
// places := 0 ;
74326: LD_ADDR_VAR 0 5
74330: PUSH
74331: LD_INT 0
74333: ST_TO_ADDR
// for j = 1 to x do
74334: LD_ADDR_VAR 0 3
74338: PUSH
74339: DOUBLE
74340: LD_INT 1
74342: DEC
74343: ST_TO_ADDR
74344: LD_VAR 0 11
74348: PUSH
74349: FOR_TO
74350: IFFALSE 74426
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74352: LD_VAR 0 11
74356: PUSH
74357: LD_VAR 0 3
74361: ARRAY
74362: PPUSH
74363: CALL_OW 264
74367: PUSH
74368: LD_INT 31
74370: EQUAL
74371: IFFALSE 74389
// places := places + 1 else
74373: LD_ADDR_VAR 0 5
74377: PUSH
74378: LD_VAR 0 5
74382: PUSH
74383: LD_INT 1
74385: PLUS
74386: ST_TO_ADDR
74387: GO 74424
// if GetBType ( x [ j ] ) = b_control_tower then
74389: LD_VAR 0 11
74393: PUSH
74394: LD_VAR 0 3
74398: ARRAY
74399: PPUSH
74400: CALL_OW 266
74404: PUSH
74405: LD_INT 36
74407: EQUAL
74408: IFFALSE 74424
// places := places + 3 ;
74410: LD_ADDR_VAR 0 5
74414: PUSH
74415: LD_VAR 0 5
74419: PUSH
74420: LD_INT 3
74422: PLUS
74423: ST_TO_ADDR
74424: GO 74349
74426: POP
74427: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74428: LD_VAR 0 5
74432: PUSH
74433: LD_INT 0
74435: EQUAL
74436: PUSH
74437: LD_VAR 0 5
74441: PUSH
74442: LD_EXP 99
74446: PUSH
74447: LD_VAR 0 2
74451: ARRAY
74452: LESSEQUAL
74453: OR
74454: IFFALSE 74458
// continue ;
74456: GO 73708
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74458: LD_ADDR_VAR 0 6
74462: PUSH
74463: LD_EXP 59
74467: PUSH
74468: LD_VAR 0 2
74472: ARRAY
74473: PPUSH
74474: LD_INT 25
74476: PUSH
74477: LD_INT 3
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PPUSH
74484: CALL_OW 72
74488: PUSH
74489: LD_EXP 99
74493: PUSH
74494: LD_VAR 0 2
74498: ARRAY
74499: DIFF
74500: PPUSH
74501: LD_INT 3
74503: PPUSH
74504: CALL 49521 0 2
74508: ST_TO_ADDR
// for j in tmp do
74509: LD_ADDR_VAR 0 3
74513: PUSH
74514: LD_VAR 0 6
74518: PUSH
74519: FOR_IN
74520: IFFALSE 74555
// if GetTag ( j ) > 0 then
74522: LD_VAR 0 3
74526: PPUSH
74527: CALL_OW 110
74531: PUSH
74532: LD_INT 0
74534: GREATER
74535: IFFALSE 74553
// tmp := tmp diff j ;
74537: LD_ADDR_VAR 0 6
74541: PUSH
74542: LD_VAR 0 6
74546: PUSH
74547: LD_VAR 0 3
74551: DIFF
74552: ST_TO_ADDR
74553: GO 74519
74555: POP
74556: POP
// if not tmp then
74557: LD_VAR 0 6
74561: NOT
74562: IFFALSE 74566
// continue ;
74564: GO 73708
// if places then
74566: LD_VAR 0 5
74570: IFFALSE 74629
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74572: LD_ADDR_EXP 99
74576: PUSH
74577: LD_EXP 99
74581: PPUSH
74582: LD_VAR 0 2
74586: PPUSH
74587: LD_EXP 99
74591: PUSH
74592: LD_VAR 0 2
74596: ARRAY
74597: PUSH
74598: LD_VAR 0 6
74602: PUSH
74603: LD_INT 1
74605: ARRAY
74606: UNION
74607: PPUSH
74608: CALL_OW 1
74612: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74613: LD_VAR 0 6
74617: PUSH
74618: LD_INT 1
74620: ARRAY
74621: PPUSH
74622: LD_INT 126
74624: PPUSH
74625: CALL_OW 109
// end ; end ;
74629: GO 73708
74631: POP
74632: POP
// end ;
74633: LD_VAR 0 1
74637: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74638: LD_INT 0
74640: PPUSH
74641: PPUSH
74642: PPUSH
74643: PPUSH
74644: PPUSH
74645: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74646: LD_VAR 0 1
74650: NOT
74651: PUSH
74652: LD_VAR 0 2
74656: NOT
74657: OR
74658: PUSH
74659: LD_VAR 0 3
74663: NOT
74664: OR
74665: PUSH
74666: LD_VAR 0 4
74670: PUSH
74671: LD_INT 1
74673: PUSH
74674: LD_INT 2
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: LD_INT 4
74682: PUSH
74683: LD_INT 5
74685: PUSH
74686: LD_INT 8
74688: PUSH
74689: LD_INT 9
74691: PUSH
74692: LD_INT 15
74694: PUSH
74695: LD_INT 16
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: LIST
74702: LIST
74703: LIST
74704: LIST
74705: LIST
74706: LIST
74707: LIST
74708: IN
74709: NOT
74710: OR
74711: IFFALSE 74715
// exit ;
74713: GO 75615
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74715: LD_ADDR_VAR 0 2
74719: PUSH
74720: LD_VAR 0 2
74724: PPUSH
74725: LD_INT 21
74727: PUSH
74728: LD_INT 3
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 24
74737: PUSH
74738: LD_INT 250
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PPUSH
74749: CALL_OW 72
74753: ST_TO_ADDR
// case class of 1 , 15 :
74754: LD_VAR 0 4
74758: PUSH
74759: LD_INT 1
74761: DOUBLE
74762: EQUAL
74763: IFTRUE 74773
74765: LD_INT 15
74767: DOUBLE
74768: EQUAL
74769: IFTRUE 74773
74771: GO 74858
74773: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74774: LD_ADDR_VAR 0 8
74778: PUSH
74779: LD_VAR 0 2
74783: PPUSH
74784: LD_INT 2
74786: PUSH
74787: LD_INT 30
74789: PUSH
74790: LD_INT 32
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 30
74799: PUSH
74800: LD_INT 31
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: LIST
74811: PPUSH
74812: CALL_OW 72
74816: PUSH
74817: LD_VAR 0 2
74821: PPUSH
74822: LD_INT 2
74824: PUSH
74825: LD_INT 30
74827: PUSH
74828: LD_INT 4
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 30
74837: PUSH
74838: LD_INT 5
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: LIST
74849: PPUSH
74850: CALL_OW 72
74854: ADD
74855: ST_TO_ADDR
74856: GO 75104
74858: LD_INT 2
74860: DOUBLE
74861: EQUAL
74862: IFTRUE 74872
74864: LD_INT 16
74866: DOUBLE
74867: EQUAL
74868: IFTRUE 74872
74870: GO 74918
74872: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74873: LD_ADDR_VAR 0 8
74877: PUSH
74878: LD_VAR 0 2
74882: PPUSH
74883: LD_INT 2
74885: PUSH
74886: LD_INT 30
74888: PUSH
74889: LD_INT 0
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 30
74898: PUSH
74899: LD_INT 1
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: LIST
74910: PPUSH
74911: CALL_OW 72
74915: ST_TO_ADDR
74916: GO 75104
74918: LD_INT 3
74920: DOUBLE
74921: EQUAL
74922: IFTRUE 74926
74924: GO 74972
74926: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74927: LD_ADDR_VAR 0 8
74931: PUSH
74932: LD_VAR 0 2
74936: PPUSH
74937: LD_INT 2
74939: PUSH
74940: LD_INT 30
74942: PUSH
74943: LD_INT 2
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 30
74952: PUSH
74953: LD_INT 3
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: LIST
74964: PPUSH
74965: CALL_OW 72
74969: ST_TO_ADDR
74970: GO 75104
74972: LD_INT 4
74974: DOUBLE
74975: EQUAL
74976: IFTRUE 74980
74978: GO 75037
74980: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74981: LD_ADDR_VAR 0 8
74985: PUSH
74986: LD_VAR 0 2
74990: PPUSH
74991: LD_INT 2
74993: PUSH
74994: LD_INT 30
74996: PUSH
74997: LD_INT 6
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 30
75006: PUSH
75007: LD_INT 7
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 30
75016: PUSH
75017: LD_INT 8
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: PPUSH
75030: CALL_OW 72
75034: ST_TO_ADDR
75035: GO 75104
75037: LD_INT 5
75039: DOUBLE
75040: EQUAL
75041: IFTRUE 75057
75043: LD_INT 8
75045: DOUBLE
75046: EQUAL
75047: IFTRUE 75057
75049: LD_INT 9
75051: DOUBLE
75052: EQUAL
75053: IFTRUE 75057
75055: GO 75103
75057: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75058: LD_ADDR_VAR 0 8
75062: PUSH
75063: LD_VAR 0 2
75067: PPUSH
75068: LD_INT 2
75070: PUSH
75071: LD_INT 30
75073: PUSH
75074: LD_INT 4
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 30
75083: PUSH
75084: LD_INT 5
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: LIST
75095: PPUSH
75096: CALL_OW 72
75100: ST_TO_ADDR
75101: GO 75104
75103: POP
// if not tmp then
75104: LD_VAR 0 8
75108: NOT
75109: IFFALSE 75113
// exit ;
75111: GO 75615
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75113: LD_VAR 0 4
75117: PUSH
75118: LD_INT 1
75120: PUSH
75121: LD_INT 15
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: IN
75128: PUSH
75129: LD_EXP 68
75133: PUSH
75134: LD_VAR 0 1
75138: ARRAY
75139: AND
75140: IFFALSE 75296
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75142: LD_ADDR_VAR 0 9
75146: PUSH
75147: LD_EXP 68
75151: PUSH
75152: LD_VAR 0 1
75156: ARRAY
75157: PUSH
75158: LD_INT 1
75160: ARRAY
75161: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75162: LD_VAR 0 9
75166: PUSH
75167: LD_EXP 69
75171: PUSH
75172: LD_VAR 0 1
75176: ARRAY
75177: IN
75178: NOT
75179: IFFALSE 75294
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75181: LD_ADDR_EXP 69
75185: PUSH
75186: LD_EXP 69
75190: PPUSH
75191: LD_VAR 0 1
75195: PUSH
75196: LD_EXP 69
75200: PUSH
75201: LD_VAR 0 1
75205: ARRAY
75206: PUSH
75207: LD_INT 1
75209: PLUS
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PPUSH
75215: LD_VAR 0 9
75219: PPUSH
75220: CALL 19669 0 3
75224: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75225: LD_ADDR_EXP 68
75229: PUSH
75230: LD_EXP 68
75234: PPUSH
75235: LD_VAR 0 1
75239: PPUSH
75240: LD_EXP 68
75244: PUSH
75245: LD_VAR 0 1
75249: ARRAY
75250: PUSH
75251: LD_VAR 0 9
75255: DIFF
75256: PPUSH
75257: CALL_OW 1
75261: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75262: LD_VAR 0 3
75266: PPUSH
75267: LD_EXP 69
75271: PUSH
75272: LD_VAR 0 1
75276: ARRAY
75277: PUSH
75278: LD_EXP 69
75282: PUSH
75283: LD_VAR 0 1
75287: ARRAY
75288: ARRAY
75289: PPUSH
75290: CALL_OW 120
// end ; exit ;
75294: GO 75615
// end ; if tmp > 1 then
75296: LD_VAR 0 8
75300: PUSH
75301: LD_INT 1
75303: GREATER
75304: IFFALSE 75408
// for i = 2 to tmp do
75306: LD_ADDR_VAR 0 6
75310: PUSH
75311: DOUBLE
75312: LD_INT 2
75314: DEC
75315: ST_TO_ADDR
75316: LD_VAR 0 8
75320: PUSH
75321: FOR_TO
75322: IFFALSE 75406
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75324: LD_VAR 0 8
75328: PUSH
75329: LD_VAR 0 6
75333: ARRAY
75334: PPUSH
75335: CALL_OW 461
75339: PUSH
75340: LD_INT 6
75342: EQUAL
75343: IFFALSE 75404
// begin x := tmp [ i ] ;
75345: LD_ADDR_VAR 0 9
75349: PUSH
75350: LD_VAR 0 8
75354: PUSH
75355: LD_VAR 0 6
75359: ARRAY
75360: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75361: LD_ADDR_VAR 0 8
75365: PUSH
75366: LD_VAR 0 8
75370: PPUSH
75371: LD_VAR 0 6
75375: PPUSH
75376: CALL_OW 3
75380: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75381: LD_ADDR_VAR 0 8
75385: PUSH
75386: LD_VAR 0 8
75390: PPUSH
75391: LD_INT 1
75393: PPUSH
75394: LD_VAR 0 9
75398: PPUSH
75399: CALL_OW 2
75403: ST_TO_ADDR
// end ;
75404: GO 75321
75406: POP
75407: POP
// for i in tmp do
75408: LD_ADDR_VAR 0 6
75412: PUSH
75413: LD_VAR 0 8
75417: PUSH
75418: FOR_IN
75419: IFFALSE 75488
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75421: LD_VAR 0 6
75425: PPUSH
75426: CALL_OW 313
75430: PUSH
75431: LD_INT 6
75433: LESS
75434: PUSH
75435: LD_VAR 0 6
75439: PPUSH
75440: CALL_OW 266
75444: PUSH
75445: LD_INT 31
75447: PUSH
75448: LD_INT 32
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: IN
75455: NOT
75456: AND
75457: PUSH
75458: LD_VAR 0 6
75462: PPUSH
75463: CALL_OW 313
75467: PUSH
75468: LD_INT 0
75470: EQUAL
75471: OR
75472: IFFALSE 75486
// begin j := i ;
75474: LD_ADDR_VAR 0 7
75478: PUSH
75479: LD_VAR 0 6
75483: ST_TO_ADDR
// break ;
75484: GO 75488
// end ; end ;
75486: GO 75418
75488: POP
75489: POP
// if j then
75490: LD_VAR 0 7
75494: IFFALSE 75512
// ComEnterUnit ( unit , j ) else
75496: LD_VAR 0 3
75500: PPUSH
75501: LD_VAR 0 7
75505: PPUSH
75506: CALL_OW 120
75510: GO 75615
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75512: LD_ADDR_VAR 0 10
75516: PUSH
75517: LD_VAR 0 2
75521: PPUSH
75522: LD_INT 2
75524: PUSH
75525: LD_INT 30
75527: PUSH
75528: LD_INT 0
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 30
75537: PUSH
75538: LD_INT 1
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: LIST
75549: PPUSH
75550: CALL_OW 72
75554: ST_TO_ADDR
// if depot then
75555: LD_VAR 0 10
75559: IFFALSE 75615
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75561: LD_ADDR_VAR 0 10
75565: PUSH
75566: LD_VAR 0 10
75570: PPUSH
75571: LD_VAR 0 3
75575: PPUSH
75576: CALL_OW 74
75580: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75581: LD_VAR 0 3
75585: PPUSH
75586: LD_VAR 0 10
75590: PPUSH
75591: CALL_OW 296
75595: PUSH
75596: LD_INT 10
75598: GREATER
75599: IFFALSE 75615
// ComStandNearbyBuilding ( unit , depot ) ;
75601: LD_VAR 0 3
75605: PPUSH
75606: LD_VAR 0 10
75610: PPUSH
75611: CALL 16283 0 2
// end ; end ; end ;
75615: LD_VAR 0 5
75619: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75620: LD_INT 0
75622: PPUSH
75623: PPUSH
75624: PPUSH
75625: PPUSH
// if not mc_bases then
75626: LD_EXP 59
75630: NOT
75631: IFFALSE 75635
// exit ;
75633: GO 75874
// for i = 1 to mc_bases do
75635: LD_ADDR_VAR 0 2
75639: PUSH
75640: DOUBLE
75641: LD_INT 1
75643: DEC
75644: ST_TO_ADDR
75645: LD_EXP 59
75649: PUSH
75650: FOR_TO
75651: IFFALSE 75872
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75653: LD_ADDR_VAR 0 4
75657: PUSH
75658: LD_EXP 59
75662: PUSH
75663: LD_VAR 0 2
75667: ARRAY
75668: PPUSH
75669: LD_INT 21
75671: PUSH
75672: LD_INT 1
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PPUSH
75679: CALL_OW 72
75683: PUSH
75684: LD_EXP 88
75688: PUSH
75689: LD_VAR 0 2
75693: ARRAY
75694: UNION
75695: ST_TO_ADDR
// if not tmp then
75696: LD_VAR 0 4
75700: NOT
75701: IFFALSE 75705
// continue ;
75703: GO 75650
// for j in tmp do
75705: LD_ADDR_VAR 0 3
75709: PUSH
75710: LD_VAR 0 4
75714: PUSH
75715: FOR_IN
75716: IFFALSE 75868
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75718: LD_VAR 0 3
75722: PPUSH
75723: CALL_OW 110
75727: NOT
75728: PUSH
75729: LD_VAR 0 3
75733: PPUSH
75734: CALL_OW 314
75738: NOT
75739: AND
75740: PUSH
75741: LD_VAR 0 3
75745: PPUSH
75746: CALL_OW 311
75750: NOT
75751: AND
75752: PUSH
75753: LD_VAR 0 3
75757: PPUSH
75758: CALL_OW 310
75762: NOT
75763: AND
75764: PUSH
75765: LD_VAR 0 3
75769: PUSH
75770: LD_EXP 62
75774: PUSH
75775: LD_VAR 0 2
75779: ARRAY
75780: PUSH
75781: LD_INT 1
75783: ARRAY
75784: IN
75785: NOT
75786: AND
75787: PUSH
75788: LD_VAR 0 3
75792: PUSH
75793: LD_EXP 62
75797: PUSH
75798: LD_VAR 0 2
75802: ARRAY
75803: PUSH
75804: LD_INT 2
75806: ARRAY
75807: IN
75808: NOT
75809: AND
75810: PUSH
75811: LD_VAR 0 3
75815: PUSH
75816: LD_EXP 71
75820: PUSH
75821: LD_VAR 0 2
75825: ARRAY
75826: IN
75827: NOT
75828: AND
75829: IFFALSE 75866
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75831: LD_VAR 0 2
75835: PPUSH
75836: LD_EXP 59
75840: PUSH
75841: LD_VAR 0 2
75845: ARRAY
75846: PPUSH
75847: LD_VAR 0 3
75851: PPUSH
75852: LD_VAR 0 3
75856: PPUSH
75857: CALL_OW 257
75861: PPUSH
75862: CALL 74638 0 4
// end ;
75866: GO 75715
75868: POP
75869: POP
// end ;
75870: GO 75650
75872: POP
75873: POP
// end ;
75874: LD_VAR 0 1
75878: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75879: LD_INT 0
75881: PPUSH
75882: PPUSH
75883: PPUSH
75884: PPUSH
75885: PPUSH
75886: PPUSH
// if not mc_bases [ base ] then
75887: LD_EXP 59
75891: PUSH
75892: LD_VAR 0 1
75896: ARRAY
75897: NOT
75898: IFFALSE 75902
// exit ;
75900: GO 76084
// tmp := [ ] ;
75902: LD_ADDR_VAR 0 6
75906: PUSH
75907: EMPTY
75908: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75909: LD_ADDR_VAR 0 7
75913: PUSH
75914: LD_VAR 0 3
75918: PPUSH
75919: LD_INT 0
75921: PPUSH
75922: CALL_OW 517
75926: ST_TO_ADDR
// if not list then
75927: LD_VAR 0 7
75931: NOT
75932: IFFALSE 75936
// exit ;
75934: GO 76084
// for i = 1 to amount do
75936: LD_ADDR_VAR 0 5
75940: PUSH
75941: DOUBLE
75942: LD_INT 1
75944: DEC
75945: ST_TO_ADDR
75946: LD_VAR 0 2
75950: PUSH
75951: FOR_TO
75952: IFFALSE 76032
// begin x := rand ( 1 , list [ 1 ] ) ;
75954: LD_ADDR_VAR 0 8
75958: PUSH
75959: LD_INT 1
75961: PPUSH
75962: LD_VAR 0 7
75966: PUSH
75967: LD_INT 1
75969: ARRAY
75970: PPUSH
75971: CALL_OW 12
75975: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75976: LD_ADDR_VAR 0 6
75980: PUSH
75981: LD_VAR 0 6
75985: PPUSH
75986: LD_VAR 0 5
75990: PPUSH
75991: LD_VAR 0 7
75995: PUSH
75996: LD_INT 1
75998: ARRAY
75999: PUSH
76000: LD_VAR 0 8
76004: ARRAY
76005: PUSH
76006: LD_VAR 0 7
76010: PUSH
76011: LD_INT 2
76013: ARRAY
76014: PUSH
76015: LD_VAR 0 8
76019: ARRAY
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PPUSH
76025: CALL_OW 1
76029: ST_TO_ADDR
// end ;
76030: GO 75951
76032: POP
76033: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76034: LD_ADDR_EXP 72
76038: PUSH
76039: LD_EXP 72
76043: PPUSH
76044: LD_VAR 0 1
76048: PPUSH
76049: LD_VAR 0 6
76053: PPUSH
76054: CALL_OW 1
76058: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76059: LD_ADDR_EXP 74
76063: PUSH
76064: LD_EXP 74
76068: PPUSH
76069: LD_VAR 0 1
76073: PPUSH
76074: LD_VAR 0 3
76078: PPUSH
76079: CALL_OW 1
76083: ST_TO_ADDR
// end ;
76084: LD_VAR 0 4
76088: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76089: LD_INT 0
76091: PPUSH
// if not mc_bases [ base ] then
76092: LD_EXP 59
76096: PUSH
76097: LD_VAR 0 1
76101: ARRAY
76102: NOT
76103: IFFALSE 76107
// exit ;
76105: GO 76132
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76107: LD_ADDR_EXP 64
76111: PUSH
76112: LD_EXP 64
76116: PPUSH
76117: LD_VAR 0 1
76121: PPUSH
76122: LD_VAR 0 2
76126: PPUSH
76127: CALL_OW 1
76131: ST_TO_ADDR
// end ;
76132: LD_VAR 0 3
76136: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76137: LD_INT 0
76139: PPUSH
// if not mc_bases [ base ] then
76140: LD_EXP 59
76144: PUSH
76145: LD_VAR 0 1
76149: ARRAY
76150: NOT
76151: IFFALSE 76155
// exit ;
76153: GO 76192
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76155: LD_ADDR_EXP 64
76159: PUSH
76160: LD_EXP 64
76164: PPUSH
76165: LD_VAR 0 1
76169: PPUSH
76170: LD_EXP 64
76174: PUSH
76175: LD_VAR 0 1
76179: ARRAY
76180: PUSH
76181: LD_VAR 0 2
76185: UNION
76186: PPUSH
76187: CALL_OW 1
76191: ST_TO_ADDR
// end ;
76192: LD_VAR 0 3
76196: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76197: LD_INT 0
76199: PPUSH
// if not mc_bases [ base ] then
76200: LD_EXP 59
76204: PUSH
76205: LD_VAR 0 1
76209: ARRAY
76210: NOT
76211: IFFALSE 76215
// exit ;
76213: GO 76240
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76215: LD_ADDR_EXP 80
76219: PUSH
76220: LD_EXP 80
76224: PPUSH
76225: LD_VAR 0 1
76229: PPUSH
76230: LD_VAR 0 2
76234: PPUSH
76235: CALL_OW 1
76239: ST_TO_ADDR
// end ;
76240: LD_VAR 0 3
76244: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76245: LD_INT 0
76247: PPUSH
// if not mc_bases [ base ] then
76248: LD_EXP 59
76252: PUSH
76253: LD_VAR 0 1
76257: ARRAY
76258: NOT
76259: IFFALSE 76263
// exit ;
76261: GO 76300
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76263: LD_ADDR_EXP 80
76267: PUSH
76268: LD_EXP 80
76272: PPUSH
76273: LD_VAR 0 1
76277: PPUSH
76278: LD_EXP 80
76282: PUSH
76283: LD_VAR 0 1
76287: ARRAY
76288: PUSH
76289: LD_VAR 0 2
76293: ADD
76294: PPUSH
76295: CALL_OW 1
76299: ST_TO_ADDR
// end ;
76300: LD_VAR 0 3
76304: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76305: LD_INT 0
76307: PPUSH
// if not mc_bases [ base ] then
76308: LD_EXP 59
76312: PUSH
76313: LD_VAR 0 1
76317: ARRAY
76318: NOT
76319: IFFALSE 76323
// exit ;
76321: GO 76377
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76323: LD_ADDR_EXP 81
76327: PUSH
76328: LD_EXP 81
76332: PPUSH
76333: LD_VAR 0 1
76337: PPUSH
76338: LD_VAR 0 2
76342: PPUSH
76343: CALL_OW 1
76347: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76348: LD_ADDR_EXP 70
76352: PUSH
76353: LD_EXP 70
76357: PPUSH
76358: LD_VAR 0 1
76362: PPUSH
76363: LD_VAR 0 2
76367: PUSH
76368: LD_INT 0
76370: PLUS
76371: PPUSH
76372: CALL_OW 1
76376: ST_TO_ADDR
// end ;
76377: LD_VAR 0 3
76381: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76382: LD_INT 0
76384: PPUSH
// if not mc_bases [ base ] then
76385: LD_EXP 59
76389: PUSH
76390: LD_VAR 0 1
76394: ARRAY
76395: NOT
76396: IFFALSE 76400
// exit ;
76398: GO 76425
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76400: LD_ADDR_EXP 70
76404: PUSH
76405: LD_EXP 70
76409: PPUSH
76410: LD_VAR 0 1
76414: PPUSH
76415: LD_VAR 0 2
76419: PPUSH
76420: CALL_OW 1
76424: ST_TO_ADDR
// end ;
76425: LD_VAR 0 3
76429: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76430: LD_INT 0
76432: PPUSH
76433: PPUSH
76434: PPUSH
76435: PPUSH
// if not mc_bases [ base ] then
76436: LD_EXP 59
76440: PUSH
76441: LD_VAR 0 1
76445: ARRAY
76446: NOT
76447: IFFALSE 76451
// exit ;
76449: GO 76516
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76451: LD_ADDR_EXP 79
76455: PUSH
76456: LD_EXP 79
76460: PPUSH
76461: LD_VAR 0 1
76465: PUSH
76466: LD_EXP 79
76470: PUSH
76471: LD_VAR 0 1
76475: ARRAY
76476: PUSH
76477: LD_INT 1
76479: PLUS
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PPUSH
76485: LD_VAR 0 1
76489: PUSH
76490: LD_VAR 0 2
76494: PUSH
76495: LD_VAR 0 3
76499: PUSH
76500: LD_VAR 0 4
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: PPUSH
76511: CALL 19669 0 3
76515: ST_TO_ADDR
// end ;
76516: LD_VAR 0 5
76520: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76521: LD_INT 0
76523: PPUSH
// if not mc_bases [ base ] then
76524: LD_EXP 59
76528: PUSH
76529: LD_VAR 0 1
76533: ARRAY
76534: NOT
76535: IFFALSE 76539
// exit ;
76537: GO 76564
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76539: LD_ADDR_EXP 96
76543: PUSH
76544: LD_EXP 96
76548: PPUSH
76549: LD_VAR 0 1
76553: PPUSH
76554: LD_VAR 0 2
76558: PPUSH
76559: CALL_OW 1
76563: ST_TO_ADDR
// end ;
76564: LD_VAR 0 3
76568: RET
// export function MC_GetMinesField ( base ) ; begin
76569: LD_INT 0
76571: PPUSH
// result := mc_mines [ base ] ;
76572: LD_ADDR_VAR 0 2
76576: PUSH
76577: LD_EXP 72
76581: PUSH
76582: LD_VAR 0 1
76586: ARRAY
76587: ST_TO_ADDR
// end ;
76588: LD_VAR 0 2
76592: RET
// export function MC_GetProduceList ( base ) ; begin
76593: LD_INT 0
76595: PPUSH
// result := mc_produce [ base ] ;
76596: LD_ADDR_VAR 0 2
76600: PUSH
76601: LD_EXP 80
76605: PUSH
76606: LD_VAR 0 1
76610: ARRAY
76611: ST_TO_ADDR
// end ;
76612: LD_VAR 0 2
76616: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76617: LD_INT 0
76619: PPUSH
76620: PPUSH
// if not mc_bases then
76621: LD_EXP 59
76625: NOT
76626: IFFALSE 76630
// exit ;
76628: GO 76695
// if mc_bases [ base ] then
76630: LD_EXP 59
76634: PUSH
76635: LD_VAR 0 1
76639: ARRAY
76640: IFFALSE 76695
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76642: LD_ADDR_VAR 0 3
76646: PUSH
76647: LD_EXP 59
76651: PUSH
76652: LD_VAR 0 1
76656: ARRAY
76657: PPUSH
76658: LD_INT 30
76660: PUSH
76661: LD_VAR 0 2
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PPUSH
76670: CALL_OW 72
76674: ST_TO_ADDR
// if result then
76675: LD_VAR 0 3
76679: IFFALSE 76695
// result := result [ 1 ] ;
76681: LD_ADDR_VAR 0 3
76685: PUSH
76686: LD_VAR 0 3
76690: PUSH
76691: LD_INT 1
76693: ARRAY
76694: ST_TO_ADDR
// end ; end ;
76695: LD_VAR 0 3
76699: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76700: LD_INT 0
76702: PPUSH
76703: PPUSH
// if not mc_bases then
76704: LD_EXP 59
76708: NOT
76709: IFFALSE 76713
// exit ;
76711: GO 76758
// if mc_bases [ base ] then
76713: LD_EXP 59
76717: PUSH
76718: LD_VAR 0 1
76722: ARRAY
76723: IFFALSE 76758
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76725: LD_ADDR_VAR 0 3
76729: PUSH
76730: LD_EXP 59
76734: PUSH
76735: LD_VAR 0 1
76739: ARRAY
76740: PPUSH
76741: LD_INT 30
76743: PUSH
76744: LD_VAR 0 2
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PPUSH
76753: CALL_OW 72
76757: ST_TO_ADDR
// end ;
76758: LD_VAR 0 3
76762: RET
// export function MC_SetTame ( base , area ) ; begin
76763: LD_INT 0
76765: PPUSH
// if not mc_bases or not base then
76766: LD_EXP 59
76770: NOT
76771: PUSH
76772: LD_VAR 0 1
76776: NOT
76777: OR
76778: IFFALSE 76782
// exit ;
76780: GO 76807
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76782: LD_ADDR_EXP 87
76786: PUSH
76787: LD_EXP 87
76791: PPUSH
76792: LD_VAR 0 1
76796: PPUSH
76797: LD_VAR 0 2
76801: PPUSH
76802: CALL_OW 1
76806: ST_TO_ADDR
// end ;
76807: LD_VAR 0 3
76811: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76812: LD_INT 0
76814: PPUSH
76815: PPUSH
// if not mc_bases or not base then
76816: LD_EXP 59
76820: NOT
76821: PUSH
76822: LD_VAR 0 1
76826: NOT
76827: OR
76828: IFFALSE 76832
// exit ;
76830: GO 76934
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76832: LD_ADDR_VAR 0 4
76836: PUSH
76837: LD_EXP 59
76841: PUSH
76842: LD_VAR 0 1
76846: ARRAY
76847: PPUSH
76848: LD_INT 30
76850: PUSH
76851: LD_VAR 0 2
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PPUSH
76860: CALL_OW 72
76864: ST_TO_ADDR
// if not tmp then
76865: LD_VAR 0 4
76869: NOT
76870: IFFALSE 76874
// exit ;
76872: GO 76934
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76874: LD_ADDR_EXP 91
76878: PUSH
76879: LD_EXP 91
76883: PPUSH
76884: LD_VAR 0 1
76888: PPUSH
76889: LD_EXP 91
76893: PUSH
76894: LD_VAR 0 1
76898: ARRAY
76899: PPUSH
76900: LD_EXP 91
76904: PUSH
76905: LD_VAR 0 1
76909: ARRAY
76910: PUSH
76911: LD_INT 1
76913: PLUS
76914: PPUSH
76915: LD_VAR 0 4
76919: PUSH
76920: LD_INT 1
76922: ARRAY
76923: PPUSH
76924: CALL_OW 2
76928: PPUSH
76929: CALL_OW 1
76933: ST_TO_ADDR
// end ;
76934: LD_VAR 0 3
76938: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76939: LD_INT 0
76941: PPUSH
76942: PPUSH
// if not mc_bases or not base or not kinds then
76943: LD_EXP 59
76947: NOT
76948: PUSH
76949: LD_VAR 0 1
76953: NOT
76954: OR
76955: PUSH
76956: LD_VAR 0 2
76960: NOT
76961: OR
76962: IFFALSE 76966
// exit ;
76964: GO 77027
// for i in kinds do
76966: LD_ADDR_VAR 0 4
76970: PUSH
76971: LD_VAR 0 2
76975: PUSH
76976: FOR_IN
76977: IFFALSE 77025
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76979: LD_ADDR_EXP 93
76983: PUSH
76984: LD_EXP 93
76988: PPUSH
76989: LD_VAR 0 1
76993: PUSH
76994: LD_EXP 93
76998: PUSH
76999: LD_VAR 0 1
77003: ARRAY
77004: PUSH
77005: LD_INT 1
77007: PLUS
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PPUSH
77013: LD_VAR 0 4
77017: PPUSH
77018: CALL 19669 0 3
77022: ST_TO_ADDR
77023: GO 76976
77025: POP
77026: POP
// end ;
77027: LD_VAR 0 3
77031: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77032: LD_INT 0
77034: PPUSH
// if not mc_bases or not base or not areas then
77035: LD_EXP 59
77039: NOT
77040: PUSH
77041: LD_VAR 0 1
77045: NOT
77046: OR
77047: PUSH
77048: LD_VAR 0 2
77052: NOT
77053: OR
77054: IFFALSE 77058
// exit ;
77056: GO 77083
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77058: LD_ADDR_EXP 77
77062: PUSH
77063: LD_EXP 77
77067: PPUSH
77068: LD_VAR 0 1
77072: PPUSH
77073: LD_VAR 0 2
77077: PPUSH
77078: CALL_OW 1
77082: ST_TO_ADDR
// end ;
77083: LD_VAR 0 3
77087: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77088: LD_INT 0
77090: PPUSH
// if not mc_bases or not base or not teleports_exit then
77091: LD_EXP 59
77095: NOT
77096: PUSH
77097: LD_VAR 0 1
77101: NOT
77102: OR
77103: PUSH
77104: LD_VAR 0 2
77108: NOT
77109: OR
77110: IFFALSE 77114
// exit ;
77112: GO 77139
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77114: LD_ADDR_EXP 94
77118: PUSH
77119: LD_EXP 94
77123: PPUSH
77124: LD_VAR 0 1
77128: PPUSH
77129: LD_VAR 0 2
77133: PPUSH
77134: CALL_OW 1
77138: ST_TO_ADDR
// end ;
77139: LD_VAR 0 3
77143: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77144: LD_INT 0
77146: PPUSH
77147: PPUSH
77148: PPUSH
// if not mc_bases or not base or not ext_list then
77149: LD_EXP 59
77153: NOT
77154: PUSH
77155: LD_VAR 0 1
77159: NOT
77160: OR
77161: PUSH
77162: LD_VAR 0 5
77166: NOT
77167: OR
77168: IFFALSE 77172
// exit ;
77170: GO 77345
// tmp := GetFacExtXYD ( x , y , d ) ;
77172: LD_ADDR_VAR 0 8
77176: PUSH
77177: LD_VAR 0 2
77181: PPUSH
77182: LD_VAR 0 3
77186: PPUSH
77187: LD_VAR 0 4
77191: PPUSH
77192: CALL 48651 0 3
77196: ST_TO_ADDR
// if not tmp then
77197: LD_VAR 0 8
77201: NOT
77202: IFFALSE 77206
// exit ;
77204: GO 77345
// for i in tmp do
77206: LD_ADDR_VAR 0 7
77210: PUSH
77211: LD_VAR 0 8
77215: PUSH
77216: FOR_IN
77217: IFFALSE 77343
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77219: LD_ADDR_EXP 64
77223: PUSH
77224: LD_EXP 64
77228: PPUSH
77229: LD_VAR 0 1
77233: PPUSH
77234: LD_EXP 64
77238: PUSH
77239: LD_VAR 0 1
77243: ARRAY
77244: PPUSH
77245: LD_EXP 64
77249: PUSH
77250: LD_VAR 0 1
77254: ARRAY
77255: PUSH
77256: LD_INT 1
77258: PLUS
77259: PPUSH
77260: LD_VAR 0 5
77264: PUSH
77265: LD_INT 1
77267: ARRAY
77268: PUSH
77269: LD_VAR 0 7
77273: PUSH
77274: LD_INT 1
77276: ARRAY
77277: PUSH
77278: LD_VAR 0 7
77282: PUSH
77283: LD_INT 2
77285: ARRAY
77286: PUSH
77287: LD_VAR 0 7
77291: PUSH
77292: LD_INT 3
77294: ARRAY
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: PPUSH
77302: CALL_OW 2
77306: PPUSH
77307: CALL_OW 1
77311: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77312: LD_ADDR_VAR 0 5
77316: PUSH
77317: LD_VAR 0 5
77321: PPUSH
77322: LD_INT 1
77324: PPUSH
77325: CALL_OW 3
77329: ST_TO_ADDR
// if not ext_list then
77330: LD_VAR 0 5
77334: NOT
77335: IFFALSE 77341
// exit ;
77337: POP
77338: POP
77339: GO 77345
// end ;
77341: GO 77216
77343: POP
77344: POP
// end ;
77345: LD_VAR 0 6
77349: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77350: LD_INT 0
77352: PPUSH
// if not mc_bases or not base or not weapon_list then
77353: LD_EXP 59
77357: NOT
77358: PUSH
77359: LD_VAR 0 1
77363: NOT
77364: OR
77365: PUSH
77366: LD_VAR 0 2
77370: NOT
77371: OR
77372: IFFALSE 77376
// exit ;
77374: GO 77401
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77376: LD_ADDR_EXP 98
77380: PUSH
77381: LD_EXP 98
77385: PPUSH
77386: LD_VAR 0 1
77390: PPUSH
77391: LD_VAR 0 2
77395: PPUSH
77396: CALL_OW 1
77400: ST_TO_ADDR
// end ;
77401: LD_VAR 0 3
77405: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77406: LD_INT 0
77408: PPUSH
// if not mc_bases or not base or not tech_list then
77409: LD_EXP 59
77413: NOT
77414: PUSH
77415: LD_VAR 0 1
77419: NOT
77420: OR
77421: PUSH
77422: LD_VAR 0 2
77426: NOT
77427: OR
77428: IFFALSE 77432
// exit ;
77430: GO 77457
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77432: LD_ADDR_EXP 86
77436: PUSH
77437: LD_EXP 86
77441: PPUSH
77442: LD_VAR 0 1
77446: PPUSH
77447: LD_VAR 0 2
77451: PPUSH
77452: CALL_OW 1
77456: ST_TO_ADDR
// end ;
77457: LD_VAR 0 3
77461: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77462: LD_INT 0
77464: PPUSH
// if not mc_bases or not parking_area or not base then
77465: LD_EXP 59
77469: NOT
77470: PUSH
77471: LD_VAR 0 2
77475: NOT
77476: OR
77477: PUSH
77478: LD_VAR 0 1
77482: NOT
77483: OR
77484: IFFALSE 77488
// exit ;
77486: GO 77513
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77488: LD_ADDR_EXP 83
77492: PUSH
77493: LD_EXP 83
77497: PPUSH
77498: LD_VAR 0 1
77502: PPUSH
77503: LD_VAR 0 2
77507: PPUSH
77508: CALL_OW 1
77512: ST_TO_ADDR
// end ;
77513: LD_VAR 0 3
77517: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77518: LD_INT 0
77520: PPUSH
// if not mc_bases or not base or not scan_area then
77521: LD_EXP 59
77525: NOT
77526: PUSH
77527: LD_VAR 0 1
77531: NOT
77532: OR
77533: PUSH
77534: LD_VAR 0 2
77538: NOT
77539: OR
77540: IFFALSE 77544
// exit ;
77542: GO 77569
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77544: LD_ADDR_EXP 84
77548: PUSH
77549: LD_EXP 84
77553: PPUSH
77554: LD_VAR 0 1
77558: PPUSH
77559: LD_VAR 0 2
77563: PPUSH
77564: CALL_OW 1
77568: ST_TO_ADDR
// end ;
77569: LD_VAR 0 3
77573: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77574: LD_INT 0
77576: PPUSH
77577: PPUSH
// if not mc_bases or not base then
77578: LD_EXP 59
77582: NOT
77583: PUSH
77584: LD_VAR 0 1
77588: NOT
77589: OR
77590: IFFALSE 77594
// exit ;
77592: GO 77658
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77594: LD_ADDR_VAR 0 3
77598: PUSH
77599: LD_INT 1
77601: PUSH
77602: LD_INT 2
77604: PUSH
77605: LD_INT 3
77607: PUSH
77608: LD_INT 4
77610: PUSH
77611: LD_INT 11
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77621: LD_ADDR_EXP 86
77625: PUSH
77626: LD_EXP 86
77630: PPUSH
77631: LD_VAR 0 1
77635: PPUSH
77636: LD_EXP 86
77640: PUSH
77641: LD_VAR 0 1
77645: ARRAY
77646: PUSH
77647: LD_VAR 0 3
77651: DIFF
77652: PPUSH
77653: CALL_OW 1
77657: ST_TO_ADDR
// end ;
77658: LD_VAR 0 2
77662: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77663: LD_INT 0
77665: PPUSH
// result := mc_vehicles [ base ] ;
77666: LD_ADDR_VAR 0 3
77670: PUSH
77671: LD_EXP 78
77675: PUSH
77676: LD_VAR 0 1
77680: ARRAY
77681: ST_TO_ADDR
// if onlyCombat then
77682: LD_VAR 0 2
77686: IFFALSE 77864
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77688: LD_ADDR_VAR 0 3
77692: PUSH
77693: LD_VAR 0 3
77697: PUSH
77698: LD_VAR 0 3
77702: PPUSH
77703: LD_INT 2
77705: PUSH
77706: LD_INT 34
77708: PUSH
77709: LD_INT 12
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 34
77718: PUSH
77719: LD_INT 51
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 34
77728: PUSH
77729: LD_EXP 104
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 34
77740: PUSH
77741: LD_INT 32
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 34
77750: PUSH
77751: LD_INT 13
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 34
77760: PUSH
77761: LD_INT 52
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 34
77770: PUSH
77771: LD_EXP 109
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 34
77782: PUSH
77783: LD_INT 14
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 34
77792: PUSH
77793: LD_INT 53
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 34
77802: PUSH
77803: LD_EXP 103
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 34
77814: PUSH
77815: LD_INT 31
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 34
77824: PUSH
77825: LD_INT 48
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 34
77834: PUSH
77835: LD_INT 8
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: LIST
77857: PPUSH
77858: CALL_OW 72
77862: DIFF
77863: ST_TO_ADDR
// end ; end_of_file
77864: LD_VAR 0 3
77868: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77869: LD_INT 0
77871: PPUSH
77872: PPUSH
77873: PPUSH
// if not mc_bases or not skirmish then
77874: LD_EXP 59
77878: NOT
77879: PUSH
77880: LD_EXP 57
77884: NOT
77885: OR
77886: IFFALSE 77890
// exit ;
77888: GO 78055
// for i = 1 to mc_bases do
77890: LD_ADDR_VAR 0 4
77894: PUSH
77895: DOUBLE
77896: LD_INT 1
77898: DEC
77899: ST_TO_ADDR
77900: LD_EXP 59
77904: PUSH
77905: FOR_TO
77906: IFFALSE 78053
// begin if sci in mc_bases [ i ] then
77908: LD_VAR 0 2
77912: PUSH
77913: LD_EXP 59
77917: PUSH
77918: LD_VAR 0 4
77922: ARRAY
77923: IN
77924: IFFALSE 78051
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77926: LD_ADDR_EXP 88
77930: PUSH
77931: LD_EXP 88
77935: PPUSH
77936: LD_VAR 0 4
77940: PUSH
77941: LD_EXP 88
77945: PUSH
77946: LD_VAR 0 4
77950: ARRAY
77951: PUSH
77952: LD_INT 1
77954: PLUS
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PPUSH
77960: LD_VAR 0 1
77964: PPUSH
77965: CALL 19669 0 3
77969: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77970: LD_ADDR_VAR 0 5
77974: PUSH
77975: LD_EXP 59
77979: PUSH
77980: LD_VAR 0 4
77984: ARRAY
77985: PPUSH
77986: LD_INT 2
77988: PUSH
77989: LD_INT 30
77991: PUSH
77992: LD_INT 0
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: PUSH
77999: LD_INT 30
78001: PUSH
78002: LD_INT 1
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: LIST
78013: PPUSH
78014: CALL_OW 72
78018: PPUSH
78019: LD_VAR 0 1
78023: PPUSH
78024: CALL_OW 74
78028: ST_TO_ADDR
// if tmp then
78029: LD_VAR 0 5
78033: IFFALSE 78049
// ComStandNearbyBuilding ( ape , tmp ) ;
78035: LD_VAR 0 1
78039: PPUSH
78040: LD_VAR 0 5
78044: PPUSH
78045: CALL 16283 0 2
// break ;
78049: GO 78053
// end ; end ;
78051: GO 77905
78053: POP
78054: POP
// end ;
78055: LD_VAR 0 3
78059: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78060: LD_INT 0
78062: PPUSH
78063: PPUSH
78064: PPUSH
// if not mc_bases or not skirmish then
78065: LD_EXP 59
78069: NOT
78070: PUSH
78071: LD_EXP 57
78075: NOT
78076: OR
78077: IFFALSE 78081
// exit ;
78079: GO 78170
// for i = 1 to mc_bases do
78081: LD_ADDR_VAR 0 4
78085: PUSH
78086: DOUBLE
78087: LD_INT 1
78089: DEC
78090: ST_TO_ADDR
78091: LD_EXP 59
78095: PUSH
78096: FOR_TO
78097: IFFALSE 78168
// begin if building in mc_busy_turret_list [ i ] then
78099: LD_VAR 0 1
78103: PUSH
78104: LD_EXP 69
78108: PUSH
78109: LD_VAR 0 4
78113: ARRAY
78114: IN
78115: IFFALSE 78166
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78117: LD_ADDR_VAR 0 5
78121: PUSH
78122: LD_EXP 69
78126: PUSH
78127: LD_VAR 0 4
78131: ARRAY
78132: PUSH
78133: LD_VAR 0 1
78137: DIFF
78138: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78139: LD_ADDR_EXP 69
78143: PUSH
78144: LD_EXP 69
78148: PPUSH
78149: LD_VAR 0 4
78153: PPUSH
78154: LD_VAR 0 5
78158: PPUSH
78159: CALL_OW 1
78163: ST_TO_ADDR
// break ;
78164: GO 78168
// end ; end ;
78166: GO 78096
78168: POP
78169: POP
// end ;
78170: LD_VAR 0 3
78174: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78175: LD_INT 0
78177: PPUSH
78178: PPUSH
78179: PPUSH
// if not mc_bases or not skirmish then
78180: LD_EXP 59
78184: NOT
78185: PUSH
78186: LD_EXP 57
78190: NOT
78191: OR
78192: IFFALSE 78196
// exit ;
78194: GO 78395
// for i = 1 to mc_bases do
78196: LD_ADDR_VAR 0 5
78200: PUSH
78201: DOUBLE
78202: LD_INT 1
78204: DEC
78205: ST_TO_ADDR
78206: LD_EXP 59
78210: PUSH
78211: FOR_TO
78212: IFFALSE 78393
// if building in mc_bases [ i ] then
78214: LD_VAR 0 1
78218: PUSH
78219: LD_EXP 59
78223: PUSH
78224: LD_VAR 0 5
78228: ARRAY
78229: IN
78230: IFFALSE 78391
// begin tmp := mc_bases [ i ] diff building ;
78232: LD_ADDR_VAR 0 6
78236: PUSH
78237: LD_EXP 59
78241: PUSH
78242: LD_VAR 0 5
78246: ARRAY
78247: PUSH
78248: LD_VAR 0 1
78252: DIFF
78253: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78254: LD_ADDR_EXP 59
78258: PUSH
78259: LD_EXP 59
78263: PPUSH
78264: LD_VAR 0 5
78268: PPUSH
78269: LD_VAR 0 6
78273: PPUSH
78274: CALL_OW 1
78278: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78279: LD_VAR 0 1
78283: PUSH
78284: LD_EXP 67
78288: PUSH
78289: LD_VAR 0 5
78293: ARRAY
78294: IN
78295: IFFALSE 78334
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78297: LD_ADDR_EXP 67
78301: PUSH
78302: LD_EXP 67
78306: PPUSH
78307: LD_VAR 0 5
78311: PPUSH
78312: LD_EXP 67
78316: PUSH
78317: LD_VAR 0 5
78321: ARRAY
78322: PUSH
78323: LD_VAR 0 1
78327: DIFF
78328: PPUSH
78329: CALL_OW 1
78333: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78334: LD_VAR 0 1
78338: PUSH
78339: LD_EXP 68
78343: PUSH
78344: LD_VAR 0 5
78348: ARRAY
78349: IN
78350: IFFALSE 78389
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78352: LD_ADDR_EXP 68
78356: PUSH
78357: LD_EXP 68
78361: PPUSH
78362: LD_VAR 0 5
78366: PPUSH
78367: LD_EXP 68
78371: PUSH
78372: LD_VAR 0 5
78376: ARRAY
78377: PUSH
78378: LD_VAR 0 1
78382: DIFF
78383: PPUSH
78384: CALL_OW 1
78388: ST_TO_ADDR
// break ;
78389: GO 78393
// end ;
78391: GO 78211
78393: POP
78394: POP
// end ;
78395: LD_VAR 0 4
78399: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78400: LD_INT 0
78402: PPUSH
78403: PPUSH
78404: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78405: LD_EXP 59
78409: NOT
78410: PUSH
78411: LD_EXP 57
78415: NOT
78416: OR
78417: PUSH
78418: LD_VAR 0 3
78422: PUSH
78423: LD_EXP 85
78427: IN
78428: NOT
78429: OR
78430: IFFALSE 78434
// exit ;
78432: GO 78557
// for i = 1 to mc_vehicles do
78434: LD_ADDR_VAR 0 6
78438: PUSH
78439: DOUBLE
78440: LD_INT 1
78442: DEC
78443: ST_TO_ADDR
78444: LD_EXP 78
78448: PUSH
78449: FOR_TO
78450: IFFALSE 78555
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78452: LD_VAR 0 2
78456: PUSH
78457: LD_EXP 78
78461: PUSH
78462: LD_VAR 0 6
78466: ARRAY
78467: IN
78468: PUSH
78469: LD_VAR 0 1
78473: PUSH
78474: LD_EXP 78
78478: PUSH
78479: LD_VAR 0 6
78483: ARRAY
78484: IN
78485: OR
78486: IFFALSE 78553
// begin tmp := mc_vehicles [ i ] diff old ;
78488: LD_ADDR_VAR 0 7
78492: PUSH
78493: LD_EXP 78
78497: PUSH
78498: LD_VAR 0 6
78502: ARRAY
78503: PUSH
78504: LD_VAR 0 2
78508: DIFF
78509: ST_TO_ADDR
// tmp := tmp diff new ;
78510: LD_ADDR_VAR 0 7
78514: PUSH
78515: LD_VAR 0 7
78519: PUSH
78520: LD_VAR 0 1
78524: DIFF
78525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78526: LD_ADDR_EXP 78
78530: PUSH
78531: LD_EXP 78
78535: PPUSH
78536: LD_VAR 0 6
78540: PPUSH
78541: LD_VAR 0 7
78545: PPUSH
78546: CALL_OW 1
78550: ST_TO_ADDR
// break ;
78551: GO 78555
// end ;
78553: GO 78449
78555: POP
78556: POP
// end ;
78557: LD_VAR 0 5
78561: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78562: LD_INT 0
78564: PPUSH
78565: PPUSH
78566: PPUSH
78567: PPUSH
// if not mc_bases or not skirmish then
78568: LD_EXP 59
78572: NOT
78573: PUSH
78574: LD_EXP 57
78578: NOT
78579: OR
78580: IFFALSE 78584
// exit ;
78582: GO 78967
// side := GetSide ( vehicle ) ;
78584: LD_ADDR_VAR 0 5
78588: PUSH
78589: LD_VAR 0 1
78593: PPUSH
78594: CALL_OW 255
78598: ST_TO_ADDR
// for i = 1 to mc_bases do
78599: LD_ADDR_VAR 0 4
78603: PUSH
78604: DOUBLE
78605: LD_INT 1
78607: DEC
78608: ST_TO_ADDR
78609: LD_EXP 59
78613: PUSH
78614: FOR_TO
78615: IFFALSE 78965
// begin if factory in mc_bases [ i ] then
78617: LD_VAR 0 2
78621: PUSH
78622: LD_EXP 59
78626: PUSH
78627: LD_VAR 0 4
78631: ARRAY
78632: IN
78633: IFFALSE 78963
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78635: LD_EXP 81
78639: PUSH
78640: LD_VAR 0 4
78644: ARRAY
78645: PUSH
78646: LD_EXP 70
78650: PUSH
78651: LD_VAR 0 4
78655: ARRAY
78656: LESS
78657: PUSH
78658: LD_VAR 0 1
78662: PPUSH
78663: CALL_OW 264
78667: PUSH
78668: LD_INT 31
78670: PUSH
78671: LD_INT 32
78673: PUSH
78674: LD_INT 51
78676: PUSH
78677: LD_EXP 104
78681: PUSH
78682: LD_INT 12
78684: PUSH
78685: LD_INT 30
78687: PUSH
78688: LD_EXP 103
78692: PUSH
78693: LD_INT 11
78695: PUSH
78696: LD_INT 53
78698: PUSH
78699: LD_INT 14
78701: PUSH
78702: LD_EXP 107
78706: PUSH
78707: LD_INT 29
78709: PUSH
78710: LD_EXP 105
78714: PUSH
78715: LD_INT 13
78717: PUSH
78718: LD_INT 52
78720: PUSH
78721: LD_EXP 109
78725: PUSH
78726: LD_INT 48
78728: PUSH
78729: LD_INT 8
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: IN
78752: NOT
78753: AND
78754: IFFALSE 78802
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78756: LD_ADDR_EXP 81
78760: PUSH
78761: LD_EXP 81
78765: PPUSH
78766: LD_VAR 0 4
78770: PUSH
78771: LD_EXP 81
78775: PUSH
78776: LD_VAR 0 4
78780: ARRAY
78781: PUSH
78782: LD_INT 1
78784: PLUS
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PPUSH
78790: LD_VAR 0 1
78794: PPUSH
78795: CALL 19669 0 3
78799: ST_TO_ADDR
78800: GO 78846
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78802: LD_ADDR_EXP 78
78806: PUSH
78807: LD_EXP 78
78811: PPUSH
78812: LD_VAR 0 4
78816: PUSH
78817: LD_EXP 78
78821: PUSH
78822: LD_VAR 0 4
78826: ARRAY
78827: PUSH
78828: LD_INT 1
78830: PLUS
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PPUSH
78836: LD_VAR 0 1
78840: PPUSH
78841: CALL 19669 0 3
78845: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78846: LD_VAR 0 1
78850: PPUSH
78851: CALL_OW 263
78855: PUSH
78856: LD_INT 2
78858: EQUAL
78859: IFFALSE 78879
// begin repeat wait ( 0 0$1 ) ;
78861: LD_INT 35
78863: PPUSH
78864: CALL_OW 67
// until IsControledBy ( vehicle ) ;
78868: LD_VAR 0 1
78872: PPUSH
78873: CALL_OW 312
78877: IFFALSE 78861
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78879: LD_VAR 0 1
78883: PPUSH
78884: LD_EXP 83
78888: PUSH
78889: LD_VAR 0 4
78893: ARRAY
78894: PPUSH
78895: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78899: LD_VAR 0 1
78903: PPUSH
78904: CALL_OW 263
78908: PUSH
78909: LD_INT 1
78911: NONEQUAL
78912: IFFALSE 78916
// break ;
78914: GO 78965
// repeat wait ( 0 0$1 ) ;
78916: LD_INT 35
78918: PPUSH
78919: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78923: LD_VAR 0 1
78927: PPUSH
78928: LD_EXP 83
78932: PUSH
78933: LD_VAR 0 4
78937: ARRAY
78938: PPUSH
78939: CALL_OW 308
78943: IFFALSE 78916
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78945: LD_VAR 0 1
78949: PPUSH
78950: CALL_OW 311
78954: PPUSH
78955: CALL_OW 121
// exit ;
78959: POP
78960: POP
78961: GO 78967
// end ; end ;
78963: GO 78614
78965: POP
78966: POP
// end ;
78967: LD_VAR 0 3
78971: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78972: LD_INT 0
78974: PPUSH
78975: PPUSH
78976: PPUSH
78977: PPUSH
// if not mc_bases or not skirmish then
78978: LD_EXP 59
78982: NOT
78983: PUSH
78984: LD_EXP 57
78988: NOT
78989: OR
78990: IFFALSE 78994
// exit ;
78992: GO 79347
// repeat wait ( 0 0$1 ) ;
78994: LD_INT 35
78996: PPUSH
78997: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79001: LD_VAR 0 2
79005: PPUSH
79006: LD_VAR 0 3
79010: PPUSH
79011: CALL_OW 284
79015: IFFALSE 78994
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79017: LD_VAR 0 2
79021: PPUSH
79022: LD_VAR 0 3
79026: PPUSH
79027: CALL_OW 283
79031: PUSH
79032: LD_INT 4
79034: EQUAL
79035: IFFALSE 79039
// exit ;
79037: GO 79347
// for i = 1 to mc_bases do
79039: LD_ADDR_VAR 0 7
79043: PUSH
79044: DOUBLE
79045: LD_INT 1
79047: DEC
79048: ST_TO_ADDR
79049: LD_EXP 59
79053: PUSH
79054: FOR_TO
79055: IFFALSE 79345
// begin if mc_crates_area [ i ] then
79057: LD_EXP 77
79061: PUSH
79062: LD_VAR 0 7
79066: ARRAY
79067: IFFALSE 79178
// for j in mc_crates_area [ i ] do
79069: LD_ADDR_VAR 0 8
79073: PUSH
79074: LD_EXP 77
79078: PUSH
79079: LD_VAR 0 7
79083: ARRAY
79084: PUSH
79085: FOR_IN
79086: IFFALSE 79176
// if InArea ( x , y , j ) then
79088: LD_VAR 0 2
79092: PPUSH
79093: LD_VAR 0 3
79097: PPUSH
79098: LD_VAR 0 8
79102: PPUSH
79103: CALL_OW 309
79107: IFFALSE 79174
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79109: LD_ADDR_EXP 75
79113: PUSH
79114: LD_EXP 75
79118: PPUSH
79119: LD_VAR 0 7
79123: PUSH
79124: LD_EXP 75
79128: PUSH
79129: LD_VAR 0 7
79133: ARRAY
79134: PUSH
79135: LD_INT 1
79137: PLUS
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PPUSH
79143: LD_VAR 0 4
79147: PUSH
79148: LD_VAR 0 2
79152: PUSH
79153: LD_VAR 0 3
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: LIST
79162: PPUSH
79163: CALL 19669 0 3
79167: ST_TO_ADDR
// exit ;
79168: POP
79169: POP
79170: POP
79171: POP
79172: GO 79347
// end ;
79174: GO 79085
79176: POP
79177: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79178: LD_ADDR_VAR 0 9
79182: PUSH
79183: LD_EXP 59
79187: PUSH
79188: LD_VAR 0 7
79192: ARRAY
79193: PPUSH
79194: LD_INT 2
79196: PUSH
79197: LD_INT 30
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 30
79209: PUSH
79210: LD_INT 1
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: LIST
79221: PPUSH
79222: CALL_OW 72
79226: ST_TO_ADDR
// if not depot then
79227: LD_VAR 0 9
79231: NOT
79232: IFFALSE 79236
// continue ;
79234: GO 79054
// for j in depot do
79236: LD_ADDR_VAR 0 8
79240: PUSH
79241: LD_VAR 0 9
79245: PUSH
79246: FOR_IN
79247: IFFALSE 79341
// if GetDistUnitXY ( j , x , y ) < 30 then
79249: LD_VAR 0 8
79253: PPUSH
79254: LD_VAR 0 2
79258: PPUSH
79259: LD_VAR 0 3
79263: PPUSH
79264: CALL_OW 297
79268: PUSH
79269: LD_INT 30
79271: LESS
79272: IFFALSE 79339
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79274: LD_ADDR_EXP 75
79278: PUSH
79279: LD_EXP 75
79283: PPUSH
79284: LD_VAR 0 7
79288: PUSH
79289: LD_EXP 75
79293: PUSH
79294: LD_VAR 0 7
79298: ARRAY
79299: PUSH
79300: LD_INT 1
79302: PLUS
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PPUSH
79308: LD_VAR 0 4
79312: PUSH
79313: LD_VAR 0 2
79317: PUSH
79318: LD_VAR 0 3
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: LIST
79327: PPUSH
79328: CALL 19669 0 3
79332: ST_TO_ADDR
// exit ;
79333: POP
79334: POP
79335: POP
79336: POP
79337: GO 79347
// end ;
79339: GO 79246
79341: POP
79342: POP
// end ;
79343: GO 79054
79345: POP
79346: POP
// end ;
79347: LD_VAR 0 6
79351: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79352: LD_INT 0
79354: PPUSH
79355: PPUSH
79356: PPUSH
79357: PPUSH
// if not mc_bases or not skirmish then
79358: LD_EXP 59
79362: NOT
79363: PUSH
79364: LD_EXP 57
79368: NOT
79369: OR
79370: IFFALSE 79374
// exit ;
79372: GO 79651
// side := GetSide ( lab ) ;
79374: LD_ADDR_VAR 0 4
79378: PUSH
79379: LD_VAR 0 2
79383: PPUSH
79384: CALL_OW 255
79388: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79389: LD_VAR 0 4
79393: PUSH
79394: LD_EXP 85
79398: IN
79399: NOT
79400: PUSH
79401: LD_EXP 86
79405: NOT
79406: OR
79407: PUSH
79408: LD_EXP 59
79412: NOT
79413: OR
79414: IFFALSE 79418
// exit ;
79416: GO 79651
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79418: LD_ADDR_EXP 86
79422: PUSH
79423: LD_EXP 86
79427: PPUSH
79428: LD_VAR 0 4
79432: PPUSH
79433: LD_EXP 86
79437: PUSH
79438: LD_VAR 0 4
79442: ARRAY
79443: PUSH
79444: LD_VAR 0 1
79448: DIFF
79449: PPUSH
79450: CALL_OW 1
79454: ST_TO_ADDR
// for i = 1 to mc_bases do
79455: LD_ADDR_VAR 0 5
79459: PUSH
79460: DOUBLE
79461: LD_INT 1
79463: DEC
79464: ST_TO_ADDR
79465: LD_EXP 59
79469: PUSH
79470: FOR_TO
79471: IFFALSE 79649
// begin if lab in mc_bases [ i ] then
79473: LD_VAR 0 2
79477: PUSH
79478: LD_EXP 59
79482: PUSH
79483: LD_VAR 0 5
79487: ARRAY
79488: IN
79489: IFFALSE 79647
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79491: LD_VAR 0 1
79495: PUSH
79496: LD_INT 11
79498: PUSH
79499: LD_INT 4
79501: PUSH
79502: LD_INT 3
79504: PUSH
79505: LD_INT 2
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: IN
79514: PUSH
79515: LD_EXP 89
79519: PUSH
79520: LD_VAR 0 5
79524: ARRAY
79525: AND
79526: IFFALSE 79647
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79528: LD_ADDR_VAR 0 6
79532: PUSH
79533: LD_EXP 89
79537: PUSH
79538: LD_VAR 0 5
79542: ARRAY
79543: PUSH
79544: LD_INT 1
79546: ARRAY
79547: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79548: LD_ADDR_EXP 89
79552: PUSH
79553: LD_EXP 89
79557: PPUSH
79558: LD_VAR 0 5
79562: PPUSH
79563: EMPTY
79564: PPUSH
79565: CALL_OW 1
79569: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79570: LD_VAR 0 6
79574: PPUSH
79575: LD_INT 0
79577: PPUSH
79578: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79582: LD_VAR 0 6
79586: PPUSH
79587: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79591: LD_ADDR_EXP 88
79595: PUSH
79596: LD_EXP 88
79600: PPUSH
79601: LD_VAR 0 5
79605: PPUSH
79606: LD_EXP 88
79610: PUSH
79611: LD_VAR 0 5
79615: ARRAY
79616: PPUSH
79617: LD_INT 1
79619: PPUSH
79620: LD_VAR 0 6
79624: PPUSH
79625: CALL_OW 2
79629: PPUSH
79630: CALL_OW 1
79634: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79635: LD_VAR 0 5
79639: PPUSH
79640: LD_INT 112
79642: PPUSH
79643: CALL 56480 0 2
// end ; end ; end ;
79647: GO 79470
79649: POP
79650: POP
// end ;
79651: LD_VAR 0 3
79655: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79656: LD_INT 0
79658: PPUSH
79659: PPUSH
79660: PPUSH
79661: PPUSH
79662: PPUSH
79663: PPUSH
79664: PPUSH
79665: PPUSH
// if not mc_bases or not skirmish then
79666: LD_EXP 59
79670: NOT
79671: PUSH
79672: LD_EXP 57
79676: NOT
79677: OR
79678: IFFALSE 79682
// exit ;
79680: GO 81053
// for i = 1 to mc_bases do
79682: LD_ADDR_VAR 0 3
79686: PUSH
79687: DOUBLE
79688: LD_INT 1
79690: DEC
79691: ST_TO_ADDR
79692: LD_EXP 59
79696: PUSH
79697: FOR_TO
79698: IFFALSE 81051
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79700: LD_VAR 0 1
79704: PUSH
79705: LD_EXP 59
79709: PUSH
79710: LD_VAR 0 3
79714: ARRAY
79715: IN
79716: PUSH
79717: LD_VAR 0 1
79721: PUSH
79722: LD_EXP 66
79726: PUSH
79727: LD_VAR 0 3
79731: ARRAY
79732: IN
79733: OR
79734: PUSH
79735: LD_VAR 0 1
79739: PUSH
79740: LD_EXP 81
79744: PUSH
79745: LD_VAR 0 3
79749: ARRAY
79750: IN
79751: OR
79752: PUSH
79753: LD_VAR 0 1
79757: PUSH
79758: LD_EXP 78
79762: PUSH
79763: LD_VAR 0 3
79767: ARRAY
79768: IN
79769: OR
79770: PUSH
79771: LD_VAR 0 1
79775: PUSH
79776: LD_EXP 88
79780: PUSH
79781: LD_VAR 0 3
79785: ARRAY
79786: IN
79787: OR
79788: PUSH
79789: LD_VAR 0 1
79793: PUSH
79794: LD_EXP 89
79798: PUSH
79799: LD_VAR 0 3
79803: ARRAY
79804: IN
79805: OR
79806: IFFALSE 81049
// begin if un in mc_ape [ i ] then
79808: LD_VAR 0 1
79812: PUSH
79813: LD_EXP 88
79817: PUSH
79818: LD_VAR 0 3
79822: ARRAY
79823: IN
79824: IFFALSE 79863
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79826: LD_ADDR_EXP 88
79830: PUSH
79831: LD_EXP 88
79835: PPUSH
79836: LD_VAR 0 3
79840: PPUSH
79841: LD_EXP 88
79845: PUSH
79846: LD_VAR 0 3
79850: ARRAY
79851: PUSH
79852: LD_VAR 0 1
79856: DIFF
79857: PPUSH
79858: CALL_OW 1
79862: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79863: LD_VAR 0 1
79867: PUSH
79868: LD_EXP 89
79872: PUSH
79873: LD_VAR 0 3
79877: ARRAY
79878: IN
79879: IFFALSE 79903
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79881: LD_ADDR_EXP 89
79885: PUSH
79886: LD_EXP 89
79890: PPUSH
79891: LD_VAR 0 3
79895: PPUSH
79896: EMPTY
79897: PPUSH
79898: CALL_OW 1
79902: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79903: LD_VAR 0 1
79907: PPUSH
79908: CALL_OW 247
79912: PUSH
79913: LD_INT 2
79915: EQUAL
79916: PUSH
79917: LD_VAR 0 1
79921: PPUSH
79922: CALL_OW 110
79926: PUSH
79927: LD_INT 20
79929: EQUAL
79930: PUSH
79931: LD_VAR 0 1
79935: PUSH
79936: LD_EXP 81
79940: PUSH
79941: LD_VAR 0 3
79945: ARRAY
79946: IN
79947: OR
79948: PUSH
79949: LD_VAR 0 1
79953: PPUSH
79954: CALL_OW 264
79958: PUSH
79959: LD_INT 12
79961: PUSH
79962: LD_INT 51
79964: PUSH
79965: LD_EXP 104
79969: PUSH
79970: LD_INT 32
79972: PUSH
79973: LD_INT 13
79975: PUSH
79976: LD_INT 52
79978: PUSH
79979: LD_INT 31
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: IN
79991: OR
79992: AND
79993: IFFALSE 80301
// begin if un in mc_defender [ i ] then
79995: LD_VAR 0 1
79999: PUSH
80000: LD_EXP 81
80004: PUSH
80005: LD_VAR 0 3
80009: ARRAY
80010: IN
80011: IFFALSE 80050
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80013: LD_ADDR_EXP 81
80017: PUSH
80018: LD_EXP 81
80022: PPUSH
80023: LD_VAR 0 3
80027: PPUSH
80028: LD_EXP 81
80032: PUSH
80033: LD_VAR 0 3
80037: ARRAY
80038: PUSH
80039: LD_VAR 0 1
80043: DIFF
80044: PPUSH
80045: CALL_OW 1
80049: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80050: LD_ADDR_VAR 0 8
80054: PUSH
80055: LD_VAR 0 3
80059: PPUSH
80060: LD_INT 3
80062: PPUSH
80063: CALL 76700 0 2
80067: ST_TO_ADDR
// if fac then
80068: LD_VAR 0 8
80072: IFFALSE 80301
// begin for j in fac do
80074: LD_ADDR_VAR 0 4
80078: PUSH
80079: LD_VAR 0 8
80083: PUSH
80084: FOR_IN
80085: IFFALSE 80299
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80087: LD_ADDR_VAR 0 9
80091: PUSH
80092: LD_VAR 0 8
80096: PPUSH
80097: LD_VAR 0 1
80101: PPUSH
80102: CALL_OW 265
80106: PPUSH
80107: LD_VAR 0 1
80111: PPUSH
80112: CALL_OW 262
80116: PPUSH
80117: LD_VAR 0 1
80121: PPUSH
80122: CALL_OW 263
80126: PPUSH
80127: LD_VAR 0 1
80131: PPUSH
80132: CALL_OW 264
80136: PPUSH
80137: CALL 17201 0 5
80141: ST_TO_ADDR
// if components then
80142: LD_VAR 0 9
80146: IFFALSE 80297
// begin if GetWeapon ( un ) = ar_control_tower then
80148: LD_VAR 0 1
80152: PPUSH
80153: CALL_OW 264
80157: PUSH
80158: LD_INT 31
80160: EQUAL
80161: IFFALSE 80278
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80163: LD_VAR 0 1
80167: PPUSH
80168: CALL_OW 311
80172: PPUSH
80173: LD_INT 0
80175: PPUSH
80176: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80180: LD_ADDR_EXP 99
80184: PUSH
80185: LD_EXP 99
80189: PPUSH
80190: LD_VAR 0 3
80194: PPUSH
80195: LD_EXP 99
80199: PUSH
80200: LD_VAR 0 3
80204: ARRAY
80205: PUSH
80206: LD_VAR 0 1
80210: PPUSH
80211: CALL_OW 311
80215: DIFF
80216: PPUSH
80217: CALL_OW 1
80221: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80222: LD_ADDR_VAR 0 7
80226: PUSH
80227: LD_EXP 80
80231: PUSH
80232: LD_VAR 0 3
80236: ARRAY
80237: PPUSH
80238: LD_INT 1
80240: PPUSH
80241: LD_VAR 0 9
80245: PPUSH
80246: CALL_OW 2
80250: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80251: LD_ADDR_EXP 80
80255: PUSH
80256: LD_EXP 80
80260: PPUSH
80261: LD_VAR 0 3
80265: PPUSH
80266: LD_VAR 0 7
80270: PPUSH
80271: CALL_OW 1
80275: ST_TO_ADDR
// end else
80276: GO 80295
// MC_InsertProduceList ( i , [ components ] ) ;
80278: LD_VAR 0 3
80282: PPUSH
80283: LD_VAR 0 9
80287: PUSH
80288: EMPTY
80289: LIST
80290: PPUSH
80291: CALL 76245 0 2
// break ;
80295: GO 80299
// end ; end ;
80297: GO 80084
80299: POP
80300: POP
// end ; end ; if GetType ( un ) = unit_building then
80301: LD_VAR 0 1
80305: PPUSH
80306: CALL_OW 247
80310: PUSH
80311: LD_INT 3
80313: EQUAL
80314: IFFALSE 80717
// begin btype := GetBType ( un ) ;
80316: LD_ADDR_VAR 0 5
80320: PUSH
80321: LD_VAR 0 1
80325: PPUSH
80326: CALL_OW 266
80330: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80331: LD_VAR 0 5
80335: PUSH
80336: LD_INT 29
80338: PUSH
80339: LD_INT 30
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: IN
80346: IFFALSE 80419
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80348: LD_VAR 0 1
80352: PPUSH
80353: CALL_OW 250
80357: PPUSH
80358: LD_VAR 0 1
80362: PPUSH
80363: CALL_OW 251
80367: PPUSH
80368: LD_VAR 0 1
80372: PPUSH
80373: CALL_OW 255
80377: PPUSH
80378: CALL_OW 440
80382: NOT
80383: IFFALSE 80419
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80385: LD_VAR 0 1
80389: PPUSH
80390: CALL_OW 250
80394: PPUSH
80395: LD_VAR 0 1
80399: PPUSH
80400: CALL_OW 251
80404: PPUSH
80405: LD_VAR 0 1
80409: PPUSH
80410: CALL_OW 255
80414: PPUSH
80415: CALL_OW 441
// end ; if btype = b_warehouse then
80419: LD_VAR 0 5
80423: PUSH
80424: LD_INT 1
80426: EQUAL
80427: IFFALSE 80445
// begin btype := b_depot ;
80429: LD_ADDR_VAR 0 5
80433: PUSH
80434: LD_INT 0
80436: ST_TO_ADDR
// pos := 1 ;
80437: LD_ADDR_VAR 0 6
80441: PUSH
80442: LD_INT 1
80444: ST_TO_ADDR
// end ; if btype = b_factory then
80445: LD_VAR 0 5
80449: PUSH
80450: LD_INT 3
80452: EQUAL
80453: IFFALSE 80471
// begin btype := b_workshop ;
80455: LD_ADDR_VAR 0 5
80459: PUSH
80460: LD_INT 2
80462: ST_TO_ADDR
// pos := 1 ;
80463: LD_ADDR_VAR 0 6
80467: PUSH
80468: LD_INT 1
80470: ST_TO_ADDR
// end ; if btype = b_barracks then
80471: LD_VAR 0 5
80475: PUSH
80476: LD_INT 5
80478: EQUAL
80479: IFFALSE 80489
// btype := b_armoury ;
80481: LD_ADDR_VAR 0 5
80485: PUSH
80486: LD_INT 4
80488: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80489: LD_VAR 0 5
80493: PUSH
80494: LD_INT 7
80496: PUSH
80497: LD_INT 8
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: IN
80504: IFFALSE 80514
// btype := b_lab ;
80506: LD_ADDR_VAR 0 5
80510: PUSH
80511: LD_INT 6
80513: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80514: LD_ADDR_EXP 64
80518: PUSH
80519: LD_EXP 64
80523: PPUSH
80524: LD_VAR 0 3
80528: PUSH
80529: LD_EXP 64
80533: PUSH
80534: LD_VAR 0 3
80538: ARRAY
80539: PUSH
80540: LD_INT 1
80542: PLUS
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PPUSH
80548: LD_VAR 0 5
80552: PUSH
80553: LD_VAR 0 1
80557: PPUSH
80558: CALL_OW 250
80562: PUSH
80563: LD_VAR 0 1
80567: PPUSH
80568: CALL_OW 251
80572: PUSH
80573: LD_VAR 0 1
80577: PPUSH
80578: CALL_OW 254
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: PPUSH
80589: CALL 19669 0 3
80593: ST_TO_ADDR
// if pos = 1 then
80594: LD_VAR 0 6
80598: PUSH
80599: LD_INT 1
80601: EQUAL
80602: IFFALSE 80717
// begin tmp := mc_build_list [ i ] ;
80604: LD_ADDR_VAR 0 7
80608: PUSH
80609: LD_EXP 64
80613: PUSH
80614: LD_VAR 0 3
80618: ARRAY
80619: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80620: LD_VAR 0 7
80624: PPUSH
80625: LD_INT 2
80627: PUSH
80628: LD_INT 30
80630: PUSH
80631: LD_INT 0
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 30
80640: PUSH
80641: LD_INT 1
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: LIST
80652: PPUSH
80653: CALL_OW 72
80657: IFFALSE 80667
// pos := 2 ;
80659: LD_ADDR_VAR 0 6
80663: PUSH
80664: LD_INT 2
80666: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80667: LD_ADDR_VAR 0 7
80671: PUSH
80672: LD_VAR 0 7
80676: PPUSH
80677: LD_VAR 0 6
80681: PPUSH
80682: LD_VAR 0 7
80686: PPUSH
80687: CALL 19995 0 3
80691: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80692: LD_ADDR_EXP 64
80696: PUSH
80697: LD_EXP 64
80701: PPUSH
80702: LD_VAR 0 3
80706: PPUSH
80707: LD_VAR 0 7
80711: PPUSH
80712: CALL_OW 1
80716: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80717: LD_VAR 0 1
80721: PUSH
80722: LD_EXP 59
80726: PUSH
80727: LD_VAR 0 3
80731: ARRAY
80732: IN
80733: IFFALSE 80772
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80735: LD_ADDR_EXP 59
80739: PUSH
80740: LD_EXP 59
80744: PPUSH
80745: LD_VAR 0 3
80749: PPUSH
80750: LD_EXP 59
80754: PUSH
80755: LD_VAR 0 3
80759: ARRAY
80760: PUSH
80761: LD_VAR 0 1
80765: DIFF
80766: PPUSH
80767: CALL_OW 1
80771: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80772: LD_VAR 0 1
80776: PUSH
80777: LD_EXP 66
80781: PUSH
80782: LD_VAR 0 3
80786: ARRAY
80787: IN
80788: IFFALSE 80827
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80790: LD_ADDR_EXP 66
80794: PUSH
80795: LD_EXP 66
80799: PPUSH
80800: LD_VAR 0 3
80804: PPUSH
80805: LD_EXP 66
80809: PUSH
80810: LD_VAR 0 3
80814: ARRAY
80815: PUSH
80816: LD_VAR 0 1
80820: DIFF
80821: PPUSH
80822: CALL_OW 1
80826: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80827: LD_VAR 0 1
80831: PUSH
80832: LD_EXP 78
80836: PUSH
80837: LD_VAR 0 3
80841: ARRAY
80842: IN
80843: IFFALSE 80882
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80845: LD_ADDR_EXP 78
80849: PUSH
80850: LD_EXP 78
80854: PPUSH
80855: LD_VAR 0 3
80859: PPUSH
80860: LD_EXP 78
80864: PUSH
80865: LD_VAR 0 3
80869: ARRAY
80870: PUSH
80871: LD_VAR 0 1
80875: DIFF
80876: PPUSH
80877: CALL_OW 1
80881: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80882: LD_VAR 0 1
80886: PUSH
80887: LD_EXP 81
80891: PUSH
80892: LD_VAR 0 3
80896: ARRAY
80897: IN
80898: IFFALSE 80937
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80900: LD_ADDR_EXP 81
80904: PUSH
80905: LD_EXP 81
80909: PPUSH
80910: LD_VAR 0 3
80914: PPUSH
80915: LD_EXP 81
80919: PUSH
80920: LD_VAR 0 3
80924: ARRAY
80925: PUSH
80926: LD_VAR 0 1
80930: DIFF
80931: PPUSH
80932: CALL_OW 1
80936: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80937: LD_VAR 0 1
80941: PUSH
80942: LD_EXP 68
80946: PUSH
80947: LD_VAR 0 3
80951: ARRAY
80952: IN
80953: IFFALSE 80992
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80955: LD_ADDR_EXP 68
80959: PUSH
80960: LD_EXP 68
80964: PPUSH
80965: LD_VAR 0 3
80969: PPUSH
80970: LD_EXP 68
80974: PUSH
80975: LD_VAR 0 3
80979: ARRAY
80980: PUSH
80981: LD_VAR 0 1
80985: DIFF
80986: PPUSH
80987: CALL_OW 1
80991: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80992: LD_VAR 0 1
80996: PUSH
80997: LD_EXP 67
81001: PUSH
81002: LD_VAR 0 3
81006: ARRAY
81007: IN
81008: IFFALSE 81047
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81010: LD_ADDR_EXP 67
81014: PUSH
81015: LD_EXP 67
81019: PPUSH
81020: LD_VAR 0 3
81024: PPUSH
81025: LD_EXP 67
81029: PUSH
81030: LD_VAR 0 3
81034: ARRAY
81035: PUSH
81036: LD_VAR 0 1
81040: DIFF
81041: PPUSH
81042: CALL_OW 1
81046: ST_TO_ADDR
// end ; break ;
81047: GO 81051
// end ;
81049: GO 79697
81051: POP
81052: POP
// end ;
81053: LD_VAR 0 2
81057: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81058: LD_INT 0
81060: PPUSH
81061: PPUSH
81062: PPUSH
// if not mc_bases or not skirmish then
81063: LD_EXP 59
81067: NOT
81068: PUSH
81069: LD_EXP 57
81073: NOT
81074: OR
81075: IFFALSE 81079
// exit ;
81077: GO 81294
// for i = 1 to mc_bases do
81079: LD_ADDR_VAR 0 3
81083: PUSH
81084: DOUBLE
81085: LD_INT 1
81087: DEC
81088: ST_TO_ADDR
81089: LD_EXP 59
81093: PUSH
81094: FOR_TO
81095: IFFALSE 81292
// begin if building in mc_construct_list [ i ] then
81097: LD_VAR 0 1
81101: PUSH
81102: LD_EXP 66
81106: PUSH
81107: LD_VAR 0 3
81111: ARRAY
81112: IN
81113: IFFALSE 81290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81115: LD_ADDR_EXP 66
81119: PUSH
81120: LD_EXP 66
81124: PPUSH
81125: LD_VAR 0 3
81129: PPUSH
81130: LD_EXP 66
81134: PUSH
81135: LD_VAR 0 3
81139: ARRAY
81140: PUSH
81141: LD_VAR 0 1
81145: DIFF
81146: PPUSH
81147: CALL_OW 1
81151: ST_TO_ADDR
// if building in mc_lab [ i ] then
81152: LD_VAR 0 1
81156: PUSH
81157: LD_EXP 92
81161: PUSH
81162: LD_VAR 0 3
81166: ARRAY
81167: IN
81168: IFFALSE 81223
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81170: LD_ADDR_EXP 93
81174: PUSH
81175: LD_EXP 93
81179: PPUSH
81180: LD_VAR 0 3
81184: PPUSH
81185: LD_EXP 93
81189: PUSH
81190: LD_VAR 0 3
81194: ARRAY
81195: PPUSH
81196: LD_INT 1
81198: PPUSH
81199: LD_EXP 93
81203: PUSH
81204: LD_VAR 0 3
81208: ARRAY
81209: PPUSH
81210: LD_INT 0
81212: PPUSH
81213: CALL 19087 0 4
81217: PPUSH
81218: CALL_OW 1
81222: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81223: LD_VAR 0 1
81227: PUSH
81228: LD_EXP 59
81232: PUSH
81233: LD_VAR 0 3
81237: ARRAY
81238: IN
81239: NOT
81240: IFFALSE 81286
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81242: LD_ADDR_EXP 59
81246: PUSH
81247: LD_EXP 59
81251: PPUSH
81252: LD_VAR 0 3
81256: PUSH
81257: LD_EXP 59
81261: PUSH
81262: LD_VAR 0 3
81266: ARRAY
81267: PUSH
81268: LD_INT 1
81270: PLUS
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PPUSH
81276: LD_VAR 0 1
81280: PPUSH
81281: CALL 19669 0 3
81285: ST_TO_ADDR
// exit ;
81286: POP
81287: POP
81288: GO 81294
// end ; end ;
81290: GO 81094
81292: POP
81293: POP
// end ;
81294: LD_VAR 0 2
81298: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81299: LD_INT 0
81301: PPUSH
81302: PPUSH
81303: PPUSH
81304: PPUSH
81305: PPUSH
81306: PPUSH
81307: PPUSH
// if not mc_bases or not skirmish then
81308: LD_EXP 59
81312: NOT
81313: PUSH
81314: LD_EXP 57
81318: NOT
81319: OR
81320: IFFALSE 81324
// exit ;
81322: GO 81985
// for i = 1 to mc_bases do
81324: LD_ADDR_VAR 0 3
81328: PUSH
81329: DOUBLE
81330: LD_INT 1
81332: DEC
81333: ST_TO_ADDR
81334: LD_EXP 59
81338: PUSH
81339: FOR_TO
81340: IFFALSE 81983
// begin if building in mc_construct_list [ i ] then
81342: LD_VAR 0 1
81346: PUSH
81347: LD_EXP 66
81351: PUSH
81352: LD_VAR 0 3
81356: ARRAY
81357: IN
81358: IFFALSE 81981
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81360: LD_ADDR_EXP 66
81364: PUSH
81365: LD_EXP 66
81369: PPUSH
81370: LD_VAR 0 3
81374: PPUSH
81375: LD_EXP 66
81379: PUSH
81380: LD_VAR 0 3
81384: ARRAY
81385: PUSH
81386: LD_VAR 0 1
81390: DIFF
81391: PPUSH
81392: CALL_OW 1
81396: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81397: LD_ADDR_EXP 59
81401: PUSH
81402: LD_EXP 59
81406: PPUSH
81407: LD_VAR 0 3
81411: PUSH
81412: LD_EXP 59
81416: PUSH
81417: LD_VAR 0 3
81421: ARRAY
81422: PUSH
81423: LD_INT 1
81425: PLUS
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PPUSH
81431: LD_VAR 0 1
81435: PPUSH
81436: CALL 19669 0 3
81440: ST_TO_ADDR
// btype := GetBType ( building ) ;
81441: LD_ADDR_VAR 0 5
81445: PUSH
81446: LD_VAR 0 1
81450: PPUSH
81451: CALL_OW 266
81455: ST_TO_ADDR
// side := GetSide ( building ) ;
81456: LD_ADDR_VAR 0 8
81460: PUSH
81461: LD_VAR 0 1
81465: PPUSH
81466: CALL_OW 255
81470: ST_TO_ADDR
// if btype = b_lab then
81471: LD_VAR 0 5
81475: PUSH
81476: LD_INT 6
81478: EQUAL
81479: IFFALSE 81529
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81481: LD_ADDR_EXP 92
81485: PUSH
81486: LD_EXP 92
81490: PPUSH
81491: LD_VAR 0 3
81495: PUSH
81496: LD_EXP 92
81500: PUSH
81501: LD_VAR 0 3
81505: ARRAY
81506: PUSH
81507: LD_INT 1
81509: PLUS
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PPUSH
81515: LD_VAR 0 1
81519: PPUSH
81520: CALL 19669 0 3
81524: ST_TO_ADDR
// exit ;
81525: POP
81526: POP
81527: GO 81985
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81529: LD_VAR 0 5
81533: PUSH
81534: LD_INT 0
81536: PUSH
81537: LD_INT 2
81539: PUSH
81540: LD_INT 4
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: LIST
81547: IN
81548: IFFALSE 81672
// begin if btype = b_armoury then
81550: LD_VAR 0 5
81554: PUSH
81555: LD_INT 4
81557: EQUAL
81558: IFFALSE 81568
// btype := b_barracks ;
81560: LD_ADDR_VAR 0 5
81564: PUSH
81565: LD_INT 5
81567: ST_TO_ADDR
// if btype = b_depot then
81568: LD_VAR 0 5
81572: PUSH
81573: LD_INT 0
81575: EQUAL
81576: IFFALSE 81586
// btype := b_warehouse ;
81578: LD_ADDR_VAR 0 5
81582: PUSH
81583: LD_INT 1
81585: ST_TO_ADDR
// if btype = b_workshop then
81586: LD_VAR 0 5
81590: PUSH
81591: LD_INT 2
81593: EQUAL
81594: IFFALSE 81604
// btype := b_factory ;
81596: LD_ADDR_VAR 0 5
81600: PUSH
81601: LD_INT 3
81603: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81604: LD_VAR 0 5
81608: PPUSH
81609: LD_VAR 0 8
81613: PPUSH
81614: CALL_OW 323
81618: PUSH
81619: LD_INT 1
81621: EQUAL
81622: IFFALSE 81668
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81624: LD_ADDR_EXP 91
81628: PUSH
81629: LD_EXP 91
81633: PPUSH
81634: LD_VAR 0 3
81638: PUSH
81639: LD_EXP 91
81643: PUSH
81644: LD_VAR 0 3
81648: ARRAY
81649: PUSH
81650: LD_INT 1
81652: PLUS
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PPUSH
81658: LD_VAR 0 1
81662: PPUSH
81663: CALL 19669 0 3
81667: ST_TO_ADDR
// exit ;
81668: POP
81669: POP
81670: GO 81985
// end ; if btype in [ b_bunker , b_turret ] then
81672: LD_VAR 0 5
81676: PUSH
81677: LD_INT 32
81679: PUSH
81680: LD_INT 33
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: IN
81687: IFFALSE 81977
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81689: LD_ADDR_EXP 67
81693: PUSH
81694: LD_EXP 67
81698: PPUSH
81699: LD_VAR 0 3
81703: PUSH
81704: LD_EXP 67
81708: PUSH
81709: LD_VAR 0 3
81713: ARRAY
81714: PUSH
81715: LD_INT 1
81717: PLUS
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PPUSH
81723: LD_VAR 0 1
81727: PPUSH
81728: CALL 19669 0 3
81732: ST_TO_ADDR
// if btype = b_bunker then
81733: LD_VAR 0 5
81737: PUSH
81738: LD_INT 32
81740: EQUAL
81741: IFFALSE 81977
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81743: LD_ADDR_EXP 68
81747: PUSH
81748: LD_EXP 68
81752: PPUSH
81753: LD_VAR 0 3
81757: PUSH
81758: LD_EXP 68
81762: PUSH
81763: LD_VAR 0 3
81767: ARRAY
81768: PUSH
81769: LD_INT 1
81771: PLUS
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PPUSH
81777: LD_VAR 0 1
81781: PPUSH
81782: CALL 19669 0 3
81786: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81787: LD_ADDR_VAR 0 6
81791: PUSH
81792: LD_EXP 59
81796: PUSH
81797: LD_VAR 0 3
81801: ARRAY
81802: PPUSH
81803: LD_INT 25
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 3
81815: PUSH
81816: LD_INT 54
81818: PUSH
81819: EMPTY
81820: LIST
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PPUSH
81830: CALL_OW 72
81834: ST_TO_ADDR
// if tmp then
81835: LD_VAR 0 6
81839: IFFALSE 81845
// exit ;
81841: POP
81842: POP
81843: GO 81985
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81845: LD_ADDR_VAR 0 6
81849: PUSH
81850: LD_EXP 59
81854: PUSH
81855: LD_VAR 0 3
81859: ARRAY
81860: PPUSH
81861: LD_INT 2
81863: PUSH
81864: LD_INT 30
81866: PUSH
81867: LD_INT 4
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 30
81876: PUSH
81877: LD_INT 5
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: LIST
81888: PPUSH
81889: CALL_OW 72
81893: ST_TO_ADDR
// if not tmp then
81894: LD_VAR 0 6
81898: NOT
81899: IFFALSE 81905
// exit ;
81901: POP
81902: POP
81903: GO 81985
// for j in tmp do
81905: LD_ADDR_VAR 0 4
81909: PUSH
81910: LD_VAR 0 6
81914: PUSH
81915: FOR_IN
81916: IFFALSE 81975
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81918: LD_ADDR_VAR 0 7
81922: PUSH
81923: LD_VAR 0 4
81927: PPUSH
81928: CALL_OW 313
81932: PPUSH
81933: LD_INT 25
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PPUSH
81943: CALL_OW 72
81947: ST_TO_ADDR
// if units then
81948: LD_VAR 0 7
81952: IFFALSE 81973
// begin ComExitBuilding ( units [ 1 ] ) ;
81954: LD_VAR 0 7
81958: PUSH
81959: LD_INT 1
81961: ARRAY
81962: PPUSH
81963: CALL_OW 122
// exit ;
81967: POP
81968: POP
81969: POP
81970: POP
81971: GO 81985
// end ; end ;
81973: GO 81915
81975: POP
81976: POP
// end ; end ; exit ;
81977: POP
81978: POP
81979: GO 81985
// end ; end ;
81981: GO 81339
81983: POP
81984: POP
// end ;
81985: LD_VAR 0 2
81989: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81990: LD_INT 0
81992: PPUSH
81993: PPUSH
81994: PPUSH
81995: PPUSH
81996: PPUSH
81997: PPUSH
81998: PPUSH
// if not mc_bases or not skirmish then
81999: LD_EXP 59
82003: NOT
82004: PUSH
82005: LD_EXP 57
82009: NOT
82010: OR
82011: IFFALSE 82015
// exit ;
82013: GO 82280
// btype := GetBType ( building ) ;
82015: LD_ADDR_VAR 0 6
82019: PUSH
82020: LD_VAR 0 1
82024: PPUSH
82025: CALL_OW 266
82029: ST_TO_ADDR
// x := GetX ( building ) ;
82030: LD_ADDR_VAR 0 7
82034: PUSH
82035: LD_VAR 0 1
82039: PPUSH
82040: CALL_OW 250
82044: ST_TO_ADDR
// y := GetY ( building ) ;
82045: LD_ADDR_VAR 0 8
82049: PUSH
82050: LD_VAR 0 1
82054: PPUSH
82055: CALL_OW 251
82059: ST_TO_ADDR
// d := GetDir ( building ) ;
82060: LD_ADDR_VAR 0 9
82064: PUSH
82065: LD_VAR 0 1
82069: PPUSH
82070: CALL_OW 254
82074: ST_TO_ADDR
// for i = 1 to mc_bases do
82075: LD_ADDR_VAR 0 4
82079: PUSH
82080: DOUBLE
82081: LD_INT 1
82083: DEC
82084: ST_TO_ADDR
82085: LD_EXP 59
82089: PUSH
82090: FOR_TO
82091: IFFALSE 82278
// begin if not mc_build_list [ i ] then
82093: LD_EXP 64
82097: PUSH
82098: LD_VAR 0 4
82102: ARRAY
82103: NOT
82104: IFFALSE 82108
// continue ;
82106: GO 82090
// for j := 1 to mc_build_list [ i ] do
82108: LD_ADDR_VAR 0 5
82112: PUSH
82113: DOUBLE
82114: LD_INT 1
82116: DEC
82117: ST_TO_ADDR
82118: LD_EXP 64
82122: PUSH
82123: LD_VAR 0 4
82127: ARRAY
82128: PUSH
82129: FOR_TO
82130: IFFALSE 82274
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82132: LD_VAR 0 6
82136: PUSH
82137: LD_VAR 0 7
82141: PUSH
82142: LD_VAR 0 8
82146: PUSH
82147: LD_VAR 0 9
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: PPUSH
82158: LD_EXP 64
82162: PUSH
82163: LD_VAR 0 4
82167: ARRAY
82168: PUSH
82169: LD_VAR 0 5
82173: ARRAY
82174: PPUSH
82175: CALL 25846 0 2
82179: IFFALSE 82272
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82181: LD_ADDR_EXP 64
82185: PUSH
82186: LD_EXP 64
82190: PPUSH
82191: LD_VAR 0 4
82195: PPUSH
82196: LD_EXP 64
82200: PUSH
82201: LD_VAR 0 4
82205: ARRAY
82206: PPUSH
82207: LD_VAR 0 5
82211: PPUSH
82212: CALL_OW 3
82216: PPUSH
82217: CALL_OW 1
82221: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82222: LD_ADDR_EXP 66
82226: PUSH
82227: LD_EXP 66
82231: PPUSH
82232: LD_VAR 0 4
82236: PUSH
82237: LD_EXP 66
82241: PUSH
82242: LD_VAR 0 4
82246: ARRAY
82247: PUSH
82248: LD_INT 1
82250: PLUS
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PPUSH
82256: LD_VAR 0 1
82260: PPUSH
82261: CALL 19669 0 3
82265: ST_TO_ADDR
// exit ;
82266: POP
82267: POP
82268: POP
82269: POP
82270: GO 82280
// end ;
82272: GO 82129
82274: POP
82275: POP
// end ;
82276: GO 82090
82278: POP
82279: POP
// end ;
82280: LD_VAR 0 3
82284: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82285: LD_INT 0
82287: PPUSH
82288: PPUSH
82289: PPUSH
// if not mc_bases or not skirmish then
82290: LD_EXP 59
82294: NOT
82295: PUSH
82296: LD_EXP 57
82300: NOT
82301: OR
82302: IFFALSE 82306
// exit ;
82304: GO 82496
// for i = 1 to mc_bases do
82306: LD_ADDR_VAR 0 4
82310: PUSH
82311: DOUBLE
82312: LD_INT 1
82314: DEC
82315: ST_TO_ADDR
82316: LD_EXP 59
82320: PUSH
82321: FOR_TO
82322: IFFALSE 82409
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82324: LD_VAR 0 1
82328: PUSH
82329: LD_EXP 67
82333: PUSH
82334: LD_VAR 0 4
82338: ARRAY
82339: IN
82340: PUSH
82341: LD_VAR 0 1
82345: PUSH
82346: LD_EXP 68
82350: PUSH
82351: LD_VAR 0 4
82355: ARRAY
82356: IN
82357: NOT
82358: AND
82359: IFFALSE 82407
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82361: LD_ADDR_EXP 68
82365: PUSH
82366: LD_EXP 68
82370: PPUSH
82371: LD_VAR 0 4
82375: PUSH
82376: LD_EXP 68
82380: PUSH
82381: LD_VAR 0 4
82385: ARRAY
82386: PUSH
82387: LD_INT 1
82389: PLUS
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PPUSH
82395: LD_VAR 0 1
82399: PPUSH
82400: CALL 19669 0 3
82404: ST_TO_ADDR
// break ;
82405: GO 82409
// end ; end ;
82407: GO 82321
82409: POP
82410: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82411: LD_VAR 0 1
82415: PPUSH
82416: CALL_OW 257
82420: PUSH
82421: LD_EXP 85
82425: IN
82426: PUSH
82427: LD_VAR 0 1
82431: PPUSH
82432: CALL_OW 266
82436: PUSH
82437: LD_INT 5
82439: EQUAL
82440: AND
82441: PUSH
82442: LD_VAR 0 2
82446: PPUSH
82447: CALL_OW 110
82451: PUSH
82452: LD_INT 18
82454: NONEQUAL
82455: AND
82456: IFFALSE 82496
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82458: LD_VAR 0 2
82462: PPUSH
82463: CALL_OW 257
82467: PUSH
82468: LD_INT 5
82470: PUSH
82471: LD_INT 8
82473: PUSH
82474: LD_INT 9
82476: PUSH
82477: EMPTY
82478: LIST
82479: LIST
82480: LIST
82481: IN
82482: IFFALSE 82496
// SetClass ( unit , 1 ) ;
82484: LD_VAR 0 2
82488: PPUSH
82489: LD_INT 1
82491: PPUSH
82492: CALL_OW 336
// end ;
82496: LD_VAR 0 3
82500: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82501: LD_INT 0
82503: PPUSH
82504: PPUSH
// if not mc_bases or not skirmish then
82505: LD_EXP 59
82509: NOT
82510: PUSH
82511: LD_EXP 57
82515: NOT
82516: OR
82517: IFFALSE 82521
// exit ;
82519: GO 82637
// if GetLives ( abandoned_vehicle ) > 250 then
82521: LD_VAR 0 2
82525: PPUSH
82526: CALL_OW 256
82530: PUSH
82531: LD_INT 250
82533: GREATER
82534: IFFALSE 82538
// exit ;
82536: GO 82637
// for i = 1 to mc_bases do
82538: LD_ADDR_VAR 0 6
82542: PUSH
82543: DOUBLE
82544: LD_INT 1
82546: DEC
82547: ST_TO_ADDR
82548: LD_EXP 59
82552: PUSH
82553: FOR_TO
82554: IFFALSE 82635
// begin if driver in mc_bases [ i ] then
82556: LD_VAR 0 1
82560: PUSH
82561: LD_EXP 59
82565: PUSH
82566: LD_VAR 0 6
82570: ARRAY
82571: IN
82572: IFFALSE 82633
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82574: LD_VAR 0 1
82578: PPUSH
82579: LD_EXP 59
82583: PUSH
82584: LD_VAR 0 6
82588: ARRAY
82589: PPUSH
82590: LD_INT 2
82592: PUSH
82593: LD_INT 30
82595: PUSH
82596: LD_INT 0
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 30
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: LIST
82617: PPUSH
82618: CALL_OW 72
82622: PUSH
82623: LD_INT 1
82625: ARRAY
82626: PPUSH
82627: CALL 51882 0 2
// break ;
82631: GO 82635
// end ; end ;
82633: GO 82553
82635: POP
82636: POP
// end ; end_of_file
82637: LD_VAR 0 5
82641: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
82642: LD_INT 0
82644: PPUSH
// ar_miner := 81 ;
82645: LD_ADDR_EXP 110
82649: PUSH
82650: LD_INT 81
82652: ST_TO_ADDR
// ar_crane := 88 ;
82653: LD_ADDR_EXP 109
82657: PUSH
82658: LD_INT 88
82660: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
82661: LD_ADDR_EXP 104
82665: PUSH
82666: LD_INT 89
82668: ST_TO_ADDR
// us_hack := 99 ;
82669: LD_ADDR_EXP 105
82673: PUSH
82674: LD_INT 99
82676: ST_TO_ADDR
// us_artillery := 97 ;
82677: LD_ADDR_EXP 106
82681: PUSH
82682: LD_INT 97
82684: ST_TO_ADDR
// ar_bio_bomb := 91 ;
82685: LD_ADDR_EXP 107
82689: PUSH
82690: LD_INT 91
82692: ST_TO_ADDR
// ar_mortar := 92 ;
82693: LD_ADDR_EXP 108
82697: PUSH
82698: LD_INT 92
82700: ST_TO_ADDR
// ru_radar := 98 ;
82701: LD_ADDR_EXP 103
82705: PUSH
82706: LD_INT 98
82708: ST_TO_ADDR
// tech_Artillery := 80 ;
82709: LD_ADDR_EXP 111
82713: PUSH
82714: LD_INT 80
82716: ST_TO_ADDR
// tech_RadMat := 81 ;
82717: LD_ADDR_EXP 112
82721: PUSH
82722: LD_INT 81
82724: ST_TO_ADDR
// tech_BasicTools := 82 ;
82725: LD_ADDR_EXP 113
82729: PUSH
82730: LD_INT 82
82732: ST_TO_ADDR
// tech_Cargo := 83 ;
82733: LD_ADDR_EXP 114
82737: PUSH
82738: LD_INT 83
82740: ST_TO_ADDR
// tech_Track := 84 ;
82741: LD_ADDR_EXP 115
82745: PUSH
82746: LD_INT 84
82748: ST_TO_ADDR
// tech_Crane := 85 ;
82749: LD_ADDR_EXP 116
82753: PUSH
82754: LD_INT 85
82756: ST_TO_ADDR
// tech_Bulldozer := 86 ;
82757: LD_ADDR_EXP 117
82761: PUSH
82762: LD_INT 86
82764: ST_TO_ADDR
// tech_Hovercraft := 87 ;
82765: LD_ADDR_EXP 118
82769: PUSH
82770: LD_INT 87
82772: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
82773: LD_ADDR_EXP 119
82777: PUSH
82778: LD_INT 88
82780: ST_TO_ADDR
// class_mastodont := 31 ;
82781: LD_ADDR_EXP 120
82785: PUSH
82786: LD_INT 31
82788: ST_TO_ADDR
// class_horse := 21 ;
82789: LD_ADDR_EXP 121
82793: PUSH
82794: LD_INT 21
82796: ST_TO_ADDR
// end ;
82797: LD_VAR 0 1
82801: RET
// every 1 do
82802: GO 82804
82804: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
82805: CALL 82642 0 0
82809: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
82810: LD_INT 0
82812: PPUSH
// if p2 = 100 then
82813: LD_VAR 0 2
82817: PUSH
82818: LD_INT 100
82820: EQUAL
82821: IFFALSE 83770
// begin if not StreamModeActive then
82823: LD_EXP 122
82827: NOT
82828: IFFALSE 82838
// StreamModeActive := true ;
82830: LD_ADDR_EXP 122
82834: PUSH
82835: LD_INT 1
82837: ST_TO_ADDR
// if p3 = 0 then
82838: LD_VAR 0 3
82842: PUSH
82843: LD_INT 0
82845: EQUAL
82846: IFFALSE 82852
// InitStreamMode ;
82848: CALL 83930 0 0
// if p3 = 1 then
82852: LD_VAR 0 3
82856: PUSH
82857: LD_INT 1
82859: EQUAL
82860: IFFALSE 82870
// sRocket := true ;
82862: LD_ADDR_EXP 127
82866: PUSH
82867: LD_INT 1
82869: ST_TO_ADDR
// if p3 = 2 then
82870: LD_VAR 0 3
82874: PUSH
82875: LD_INT 2
82877: EQUAL
82878: IFFALSE 82888
// sSpeed := true ;
82880: LD_ADDR_EXP 126
82884: PUSH
82885: LD_INT 1
82887: ST_TO_ADDR
// if p3 = 3 then
82888: LD_VAR 0 3
82892: PUSH
82893: LD_INT 3
82895: EQUAL
82896: IFFALSE 82906
// sEngine := true ;
82898: LD_ADDR_EXP 128
82902: PUSH
82903: LD_INT 1
82905: ST_TO_ADDR
// if p3 = 4 then
82906: LD_VAR 0 3
82910: PUSH
82911: LD_INT 4
82913: EQUAL
82914: IFFALSE 82924
// sSpec := true ;
82916: LD_ADDR_EXP 125
82920: PUSH
82921: LD_INT 1
82923: ST_TO_ADDR
// if p3 = 5 then
82924: LD_VAR 0 3
82928: PUSH
82929: LD_INT 5
82931: EQUAL
82932: IFFALSE 82942
// sLevel := true ;
82934: LD_ADDR_EXP 129
82938: PUSH
82939: LD_INT 1
82941: ST_TO_ADDR
// if p3 = 6 then
82942: LD_VAR 0 3
82946: PUSH
82947: LD_INT 6
82949: EQUAL
82950: IFFALSE 82960
// sArmoury := true ;
82952: LD_ADDR_EXP 130
82956: PUSH
82957: LD_INT 1
82959: ST_TO_ADDR
// if p3 = 7 then
82960: LD_VAR 0 3
82964: PUSH
82965: LD_INT 7
82967: EQUAL
82968: IFFALSE 82978
// sRadar := true ;
82970: LD_ADDR_EXP 131
82974: PUSH
82975: LD_INT 1
82977: ST_TO_ADDR
// if p3 = 8 then
82978: LD_VAR 0 3
82982: PUSH
82983: LD_INT 8
82985: EQUAL
82986: IFFALSE 82996
// sBunker := true ;
82988: LD_ADDR_EXP 132
82992: PUSH
82993: LD_INT 1
82995: ST_TO_ADDR
// if p3 = 9 then
82996: LD_VAR 0 3
83000: PUSH
83001: LD_INT 9
83003: EQUAL
83004: IFFALSE 83014
// sHack := true ;
83006: LD_ADDR_EXP 133
83010: PUSH
83011: LD_INT 1
83013: ST_TO_ADDR
// if p3 = 10 then
83014: LD_VAR 0 3
83018: PUSH
83019: LD_INT 10
83021: EQUAL
83022: IFFALSE 83032
// sFire := true ;
83024: LD_ADDR_EXP 134
83028: PUSH
83029: LD_INT 1
83031: ST_TO_ADDR
// if p3 = 11 then
83032: LD_VAR 0 3
83036: PUSH
83037: LD_INT 11
83039: EQUAL
83040: IFFALSE 83050
// sRefresh := true ;
83042: LD_ADDR_EXP 135
83046: PUSH
83047: LD_INT 1
83049: ST_TO_ADDR
// if p3 = 12 then
83050: LD_VAR 0 3
83054: PUSH
83055: LD_INT 12
83057: EQUAL
83058: IFFALSE 83068
// sExp := true ;
83060: LD_ADDR_EXP 136
83064: PUSH
83065: LD_INT 1
83067: ST_TO_ADDR
// if p3 = 13 then
83068: LD_VAR 0 3
83072: PUSH
83073: LD_INT 13
83075: EQUAL
83076: IFFALSE 83086
// sDepot := true ;
83078: LD_ADDR_EXP 137
83082: PUSH
83083: LD_INT 1
83085: ST_TO_ADDR
// if p3 = 14 then
83086: LD_VAR 0 3
83090: PUSH
83091: LD_INT 14
83093: EQUAL
83094: IFFALSE 83104
// sFlag := true ;
83096: LD_ADDR_EXP 138
83100: PUSH
83101: LD_INT 1
83103: ST_TO_ADDR
// if p3 = 15 then
83104: LD_VAR 0 3
83108: PUSH
83109: LD_INT 15
83111: EQUAL
83112: IFFALSE 83122
// sKamikadze := true ;
83114: LD_ADDR_EXP 146
83118: PUSH
83119: LD_INT 1
83121: ST_TO_ADDR
// if p3 = 16 then
83122: LD_VAR 0 3
83126: PUSH
83127: LD_INT 16
83129: EQUAL
83130: IFFALSE 83140
// sTroll := true ;
83132: LD_ADDR_EXP 147
83136: PUSH
83137: LD_INT 1
83139: ST_TO_ADDR
// if p3 = 17 then
83140: LD_VAR 0 3
83144: PUSH
83145: LD_INT 17
83147: EQUAL
83148: IFFALSE 83158
// sSlow := true ;
83150: LD_ADDR_EXP 148
83154: PUSH
83155: LD_INT 1
83157: ST_TO_ADDR
// if p3 = 18 then
83158: LD_VAR 0 3
83162: PUSH
83163: LD_INT 18
83165: EQUAL
83166: IFFALSE 83176
// sLack := true ;
83168: LD_ADDR_EXP 149
83172: PUSH
83173: LD_INT 1
83175: ST_TO_ADDR
// if p3 = 19 then
83176: LD_VAR 0 3
83180: PUSH
83181: LD_INT 19
83183: EQUAL
83184: IFFALSE 83194
// sTank := true ;
83186: LD_ADDR_EXP 151
83190: PUSH
83191: LD_INT 1
83193: ST_TO_ADDR
// if p3 = 20 then
83194: LD_VAR 0 3
83198: PUSH
83199: LD_INT 20
83201: EQUAL
83202: IFFALSE 83212
// sRemote := true ;
83204: LD_ADDR_EXP 152
83208: PUSH
83209: LD_INT 1
83211: ST_TO_ADDR
// if p3 = 21 then
83212: LD_VAR 0 3
83216: PUSH
83217: LD_INT 21
83219: EQUAL
83220: IFFALSE 83230
// sPowell := true ;
83222: LD_ADDR_EXP 153
83226: PUSH
83227: LD_INT 1
83229: ST_TO_ADDR
// if p3 = 22 then
83230: LD_VAR 0 3
83234: PUSH
83235: LD_INT 22
83237: EQUAL
83238: IFFALSE 83248
// sTeleport := true ;
83240: LD_ADDR_EXP 156
83244: PUSH
83245: LD_INT 1
83247: ST_TO_ADDR
// if p3 = 23 then
83248: LD_VAR 0 3
83252: PUSH
83253: LD_INT 23
83255: EQUAL
83256: IFFALSE 83266
// sOilTower := true ;
83258: LD_ADDR_EXP 158
83262: PUSH
83263: LD_INT 1
83265: ST_TO_ADDR
// if p3 = 24 then
83266: LD_VAR 0 3
83270: PUSH
83271: LD_INT 24
83273: EQUAL
83274: IFFALSE 83284
// sShovel := true ;
83276: LD_ADDR_EXP 159
83280: PUSH
83281: LD_INT 1
83283: ST_TO_ADDR
// if p3 = 25 then
83284: LD_VAR 0 3
83288: PUSH
83289: LD_INT 25
83291: EQUAL
83292: IFFALSE 83302
// sSheik := true ;
83294: LD_ADDR_EXP 160
83298: PUSH
83299: LD_INT 1
83301: ST_TO_ADDR
// if p3 = 26 then
83302: LD_VAR 0 3
83306: PUSH
83307: LD_INT 26
83309: EQUAL
83310: IFFALSE 83320
// sEarthquake := true ;
83312: LD_ADDR_EXP 162
83316: PUSH
83317: LD_INT 1
83319: ST_TO_ADDR
// if p3 = 27 then
83320: LD_VAR 0 3
83324: PUSH
83325: LD_INT 27
83327: EQUAL
83328: IFFALSE 83338
// sAI := true ;
83330: LD_ADDR_EXP 163
83334: PUSH
83335: LD_INT 1
83337: ST_TO_ADDR
// if p3 = 28 then
83338: LD_VAR 0 3
83342: PUSH
83343: LD_INT 28
83345: EQUAL
83346: IFFALSE 83356
// sCargo := true ;
83348: LD_ADDR_EXP 166
83352: PUSH
83353: LD_INT 1
83355: ST_TO_ADDR
// if p3 = 29 then
83356: LD_VAR 0 3
83360: PUSH
83361: LD_INT 29
83363: EQUAL
83364: IFFALSE 83374
// sDLaser := true ;
83366: LD_ADDR_EXP 167
83370: PUSH
83371: LD_INT 1
83373: ST_TO_ADDR
// if p3 = 30 then
83374: LD_VAR 0 3
83378: PUSH
83379: LD_INT 30
83381: EQUAL
83382: IFFALSE 83392
// sExchange := true ;
83384: LD_ADDR_EXP 168
83388: PUSH
83389: LD_INT 1
83391: ST_TO_ADDR
// if p3 = 31 then
83392: LD_VAR 0 3
83396: PUSH
83397: LD_INT 31
83399: EQUAL
83400: IFFALSE 83410
// sFac := true ;
83402: LD_ADDR_EXP 169
83406: PUSH
83407: LD_INT 1
83409: ST_TO_ADDR
// if p3 = 32 then
83410: LD_VAR 0 3
83414: PUSH
83415: LD_INT 32
83417: EQUAL
83418: IFFALSE 83428
// sPower := true ;
83420: LD_ADDR_EXP 170
83424: PUSH
83425: LD_INT 1
83427: ST_TO_ADDR
// if p3 = 33 then
83428: LD_VAR 0 3
83432: PUSH
83433: LD_INT 33
83435: EQUAL
83436: IFFALSE 83446
// sRandom := true ;
83438: LD_ADDR_EXP 171
83442: PUSH
83443: LD_INT 1
83445: ST_TO_ADDR
// if p3 = 34 then
83446: LD_VAR 0 3
83450: PUSH
83451: LD_INT 34
83453: EQUAL
83454: IFFALSE 83464
// sShield := true ;
83456: LD_ADDR_EXP 172
83460: PUSH
83461: LD_INT 1
83463: ST_TO_ADDR
// if p3 = 35 then
83464: LD_VAR 0 3
83468: PUSH
83469: LD_INT 35
83471: EQUAL
83472: IFFALSE 83482
// sTime := true ;
83474: LD_ADDR_EXP 173
83478: PUSH
83479: LD_INT 1
83481: ST_TO_ADDR
// if p3 = 36 then
83482: LD_VAR 0 3
83486: PUSH
83487: LD_INT 36
83489: EQUAL
83490: IFFALSE 83500
// sTools := true ;
83492: LD_ADDR_EXP 174
83496: PUSH
83497: LD_INT 1
83499: ST_TO_ADDR
// if p3 = 101 then
83500: LD_VAR 0 3
83504: PUSH
83505: LD_INT 101
83507: EQUAL
83508: IFFALSE 83518
// sSold := true ;
83510: LD_ADDR_EXP 139
83514: PUSH
83515: LD_INT 1
83517: ST_TO_ADDR
// if p3 = 102 then
83518: LD_VAR 0 3
83522: PUSH
83523: LD_INT 102
83525: EQUAL
83526: IFFALSE 83536
// sDiff := true ;
83528: LD_ADDR_EXP 140
83532: PUSH
83533: LD_INT 1
83535: ST_TO_ADDR
// if p3 = 103 then
83536: LD_VAR 0 3
83540: PUSH
83541: LD_INT 103
83543: EQUAL
83544: IFFALSE 83554
// sFog := true ;
83546: LD_ADDR_EXP 143
83550: PUSH
83551: LD_INT 1
83553: ST_TO_ADDR
// if p3 = 104 then
83554: LD_VAR 0 3
83558: PUSH
83559: LD_INT 104
83561: EQUAL
83562: IFFALSE 83572
// sReset := true ;
83564: LD_ADDR_EXP 144
83568: PUSH
83569: LD_INT 1
83571: ST_TO_ADDR
// if p3 = 105 then
83572: LD_VAR 0 3
83576: PUSH
83577: LD_INT 105
83579: EQUAL
83580: IFFALSE 83590
// sSun := true ;
83582: LD_ADDR_EXP 145
83586: PUSH
83587: LD_INT 1
83589: ST_TO_ADDR
// if p3 = 106 then
83590: LD_VAR 0 3
83594: PUSH
83595: LD_INT 106
83597: EQUAL
83598: IFFALSE 83608
// sTiger := true ;
83600: LD_ADDR_EXP 141
83604: PUSH
83605: LD_INT 1
83607: ST_TO_ADDR
// if p3 = 107 then
83608: LD_VAR 0 3
83612: PUSH
83613: LD_INT 107
83615: EQUAL
83616: IFFALSE 83626
// sBomb := true ;
83618: LD_ADDR_EXP 142
83622: PUSH
83623: LD_INT 1
83625: ST_TO_ADDR
// if p3 = 108 then
83626: LD_VAR 0 3
83630: PUSH
83631: LD_INT 108
83633: EQUAL
83634: IFFALSE 83644
// sWound := true ;
83636: LD_ADDR_EXP 150
83640: PUSH
83641: LD_INT 1
83643: ST_TO_ADDR
// if p3 = 109 then
83644: LD_VAR 0 3
83648: PUSH
83649: LD_INT 109
83651: EQUAL
83652: IFFALSE 83662
// sBetray := true ;
83654: LD_ADDR_EXP 154
83658: PUSH
83659: LD_INT 1
83661: ST_TO_ADDR
// if p3 = 110 then
83662: LD_VAR 0 3
83666: PUSH
83667: LD_INT 110
83669: EQUAL
83670: IFFALSE 83680
// sContamin := true ;
83672: LD_ADDR_EXP 155
83676: PUSH
83677: LD_INT 1
83679: ST_TO_ADDR
// if p3 = 111 then
83680: LD_VAR 0 3
83684: PUSH
83685: LD_INT 111
83687: EQUAL
83688: IFFALSE 83698
// sOil := true ;
83690: LD_ADDR_EXP 157
83694: PUSH
83695: LD_INT 1
83697: ST_TO_ADDR
// if p3 = 112 then
83698: LD_VAR 0 3
83702: PUSH
83703: LD_INT 112
83705: EQUAL
83706: IFFALSE 83716
// sStu := true ;
83708: LD_ADDR_EXP 161
83712: PUSH
83713: LD_INT 1
83715: ST_TO_ADDR
// if p3 = 113 then
83716: LD_VAR 0 3
83720: PUSH
83721: LD_INT 113
83723: EQUAL
83724: IFFALSE 83734
// sBazooka := true ;
83726: LD_ADDR_EXP 164
83730: PUSH
83731: LD_INT 1
83733: ST_TO_ADDR
// if p3 = 114 then
83734: LD_VAR 0 3
83738: PUSH
83739: LD_INT 114
83741: EQUAL
83742: IFFALSE 83752
// sMortar := true ;
83744: LD_ADDR_EXP 165
83748: PUSH
83749: LD_INT 1
83751: ST_TO_ADDR
// if p3 = 115 then
83752: LD_VAR 0 3
83756: PUSH
83757: LD_INT 115
83759: EQUAL
83760: IFFALSE 83770
// sRanger := true ;
83762: LD_ADDR_EXP 175
83766: PUSH
83767: LD_INT 1
83769: ST_TO_ADDR
// end ; if p2 = 101 then
83770: LD_VAR 0 2
83774: PUSH
83775: LD_INT 101
83777: EQUAL
83778: IFFALSE 83906
// begin case p3 of 1 :
83780: LD_VAR 0 3
83784: PUSH
83785: LD_INT 1
83787: DOUBLE
83788: EQUAL
83789: IFTRUE 83793
83791: GO 83800
83793: POP
// hHackUnlimitedResources ; 2 :
83794: CALL 94943 0 0
83798: GO 83906
83800: LD_INT 2
83802: DOUBLE
83803: EQUAL
83804: IFTRUE 83808
83806: GO 83815
83808: POP
// hHackSetLevel10 ; 3 :
83809: CALL 95076 0 0
83813: GO 83906
83815: LD_INT 3
83817: DOUBLE
83818: EQUAL
83819: IFTRUE 83823
83821: GO 83830
83823: POP
// hHackSetLevel10YourUnits ; 4 :
83824: CALL 95161 0 0
83828: GO 83906
83830: LD_INT 4
83832: DOUBLE
83833: EQUAL
83834: IFTRUE 83838
83836: GO 83845
83838: POP
// hHackInvincible ; 5 :
83839: CALL 95609 0 0
83843: GO 83906
83845: LD_INT 5
83847: DOUBLE
83848: EQUAL
83849: IFTRUE 83853
83851: GO 83860
83853: POP
// hHackInvisible ; 6 :
83854: CALL 95720 0 0
83858: GO 83906
83860: LD_INT 6
83862: DOUBLE
83863: EQUAL
83864: IFTRUE 83868
83866: GO 83875
83868: POP
// hHackChangeYourSide ; 7 :
83869: CALL 95777 0 0
83873: GO 83906
83875: LD_INT 7
83877: DOUBLE
83878: EQUAL
83879: IFTRUE 83883
83881: GO 83890
83883: POP
// hHackChangeUnitSide ; 8 :
83884: CALL 95819 0 0
83888: GO 83906
83890: LD_INT 8
83892: DOUBLE
83893: EQUAL
83894: IFTRUE 83898
83896: GO 83905
83898: POP
// hHackFog ; end ;
83899: CALL 95920 0 0
83903: GO 83906
83905: POP
// end ; end ;
83906: LD_VAR 0 7
83910: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83911: GO 83913
83913: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83914: LD_STRING initStreamRollete();
83916: PPUSH
83917: CALL_OW 559
// InitStreamMode ;
83921: CALL 83930 0 0
// DefineStreamItems ( ) ;
83925: CALL 84370 0 0
// end ;
83929: END
// function InitStreamMode ; begin
83930: LD_INT 0
83932: PPUSH
// streamModeActive := false ;
83933: LD_ADDR_EXP 122
83937: PUSH
83938: LD_INT 0
83940: ST_TO_ADDR
// normalCounter := 36 ;
83941: LD_ADDR_EXP 123
83945: PUSH
83946: LD_INT 36
83948: ST_TO_ADDR
// hardcoreCounter := 16 ;
83949: LD_ADDR_EXP 124
83953: PUSH
83954: LD_INT 16
83956: ST_TO_ADDR
// sRocket := false ;
83957: LD_ADDR_EXP 127
83961: PUSH
83962: LD_INT 0
83964: ST_TO_ADDR
// sSpeed := false ;
83965: LD_ADDR_EXP 126
83969: PUSH
83970: LD_INT 0
83972: ST_TO_ADDR
// sEngine := false ;
83973: LD_ADDR_EXP 128
83977: PUSH
83978: LD_INT 0
83980: ST_TO_ADDR
// sSpec := false ;
83981: LD_ADDR_EXP 125
83985: PUSH
83986: LD_INT 0
83988: ST_TO_ADDR
// sLevel := false ;
83989: LD_ADDR_EXP 129
83993: PUSH
83994: LD_INT 0
83996: ST_TO_ADDR
// sArmoury := false ;
83997: LD_ADDR_EXP 130
84001: PUSH
84002: LD_INT 0
84004: ST_TO_ADDR
// sRadar := false ;
84005: LD_ADDR_EXP 131
84009: PUSH
84010: LD_INT 0
84012: ST_TO_ADDR
// sBunker := false ;
84013: LD_ADDR_EXP 132
84017: PUSH
84018: LD_INT 0
84020: ST_TO_ADDR
// sHack := false ;
84021: LD_ADDR_EXP 133
84025: PUSH
84026: LD_INT 0
84028: ST_TO_ADDR
// sFire := false ;
84029: LD_ADDR_EXP 134
84033: PUSH
84034: LD_INT 0
84036: ST_TO_ADDR
// sRefresh := false ;
84037: LD_ADDR_EXP 135
84041: PUSH
84042: LD_INT 0
84044: ST_TO_ADDR
// sExp := false ;
84045: LD_ADDR_EXP 136
84049: PUSH
84050: LD_INT 0
84052: ST_TO_ADDR
// sDepot := false ;
84053: LD_ADDR_EXP 137
84057: PUSH
84058: LD_INT 0
84060: ST_TO_ADDR
// sFlag := false ;
84061: LD_ADDR_EXP 138
84065: PUSH
84066: LD_INT 0
84068: ST_TO_ADDR
// sKamikadze := false ;
84069: LD_ADDR_EXP 146
84073: PUSH
84074: LD_INT 0
84076: ST_TO_ADDR
// sTroll := false ;
84077: LD_ADDR_EXP 147
84081: PUSH
84082: LD_INT 0
84084: ST_TO_ADDR
// sSlow := false ;
84085: LD_ADDR_EXP 148
84089: PUSH
84090: LD_INT 0
84092: ST_TO_ADDR
// sLack := false ;
84093: LD_ADDR_EXP 149
84097: PUSH
84098: LD_INT 0
84100: ST_TO_ADDR
// sTank := false ;
84101: LD_ADDR_EXP 151
84105: PUSH
84106: LD_INT 0
84108: ST_TO_ADDR
// sRemote := false ;
84109: LD_ADDR_EXP 152
84113: PUSH
84114: LD_INT 0
84116: ST_TO_ADDR
// sPowell := false ;
84117: LD_ADDR_EXP 153
84121: PUSH
84122: LD_INT 0
84124: ST_TO_ADDR
// sTeleport := false ;
84125: LD_ADDR_EXP 156
84129: PUSH
84130: LD_INT 0
84132: ST_TO_ADDR
// sOilTower := false ;
84133: LD_ADDR_EXP 158
84137: PUSH
84138: LD_INT 0
84140: ST_TO_ADDR
// sShovel := false ;
84141: LD_ADDR_EXP 159
84145: PUSH
84146: LD_INT 0
84148: ST_TO_ADDR
// sSheik := false ;
84149: LD_ADDR_EXP 160
84153: PUSH
84154: LD_INT 0
84156: ST_TO_ADDR
// sEarthquake := false ;
84157: LD_ADDR_EXP 162
84161: PUSH
84162: LD_INT 0
84164: ST_TO_ADDR
// sAI := false ;
84165: LD_ADDR_EXP 163
84169: PUSH
84170: LD_INT 0
84172: ST_TO_ADDR
// sCargo := false ;
84173: LD_ADDR_EXP 166
84177: PUSH
84178: LD_INT 0
84180: ST_TO_ADDR
// sDLaser := false ;
84181: LD_ADDR_EXP 167
84185: PUSH
84186: LD_INT 0
84188: ST_TO_ADDR
// sExchange := false ;
84189: LD_ADDR_EXP 168
84193: PUSH
84194: LD_INT 0
84196: ST_TO_ADDR
// sFac := false ;
84197: LD_ADDR_EXP 169
84201: PUSH
84202: LD_INT 0
84204: ST_TO_ADDR
// sPower := false ;
84205: LD_ADDR_EXP 170
84209: PUSH
84210: LD_INT 0
84212: ST_TO_ADDR
// sRandom := false ;
84213: LD_ADDR_EXP 171
84217: PUSH
84218: LD_INT 0
84220: ST_TO_ADDR
// sShield := false ;
84221: LD_ADDR_EXP 172
84225: PUSH
84226: LD_INT 0
84228: ST_TO_ADDR
// sTime := false ;
84229: LD_ADDR_EXP 173
84233: PUSH
84234: LD_INT 0
84236: ST_TO_ADDR
// sTools := false ;
84237: LD_ADDR_EXP 174
84241: PUSH
84242: LD_INT 0
84244: ST_TO_ADDR
// sSold := false ;
84245: LD_ADDR_EXP 139
84249: PUSH
84250: LD_INT 0
84252: ST_TO_ADDR
// sDiff := false ;
84253: LD_ADDR_EXP 140
84257: PUSH
84258: LD_INT 0
84260: ST_TO_ADDR
// sFog := false ;
84261: LD_ADDR_EXP 143
84265: PUSH
84266: LD_INT 0
84268: ST_TO_ADDR
// sReset := false ;
84269: LD_ADDR_EXP 144
84273: PUSH
84274: LD_INT 0
84276: ST_TO_ADDR
// sSun := false ;
84277: LD_ADDR_EXP 145
84281: PUSH
84282: LD_INT 0
84284: ST_TO_ADDR
// sTiger := false ;
84285: LD_ADDR_EXP 141
84289: PUSH
84290: LD_INT 0
84292: ST_TO_ADDR
// sBomb := false ;
84293: LD_ADDR_EXP 142
84297: PUSH
84298: LD_INT 0
84300: ST_TO_ADDR
// sWound := false ;
84301: LD_ADDR_EXP 150
84305: PUSH
84306: LD_INT 0
84308: ST_TO_ADDR
// sBetray := false ;
84309: LD_ADDR_EXP 154
84313: PUSH
84314: LD_INT 0
84316: ST_TO_ADDR
// sContamin := false ;
84317: LD_ADDR_EXP 155
84321: PUSH
84322: LD_INT 0
84324: ST_TO_ADDR
// sOil := false ;
84325: LD_ADDR_EXP 157
84329: PUSH
84330: LD_INT 0
84332: ST_TO_ADDR
// sStu := false ;
84333: LD_ADDR_EXP 161
84337: PUSH
84338: LD_INT 0
84340: ST_TO_ADDR
// sBazooka := false ;
84341: LD_ADDR_EXP 164
84345: PUSH
84346: LD_INT 0
84348: ST_TO_ADDR
// sMortar := false ;
84349: LD_ADDR_EXP 165
84353: PUSH
84354: LD_INT 0
84356: ST_TO_ADDR
// sRanger := false ;
84357: LD_ADDR_EXP 175
84361: PUSH
84362: LD_INT 0
84364: ST_TO_ADDR
// end ;
84365: LD_VAR 0 1
84369: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84370: LD_INT 0
84372: PPUSH
84373: PPUSH
84374: PPUSH
84375: PPUSH
84376: PPUSH
// result := [ ] ;
84377: LD_ADDR_VAR 0 1
84381: PUSH
84382: EMPTY
84383: ST_TO_ADDR
// if campaign_id = 1 then
84384: LD_OWVAR 69
84388: PUSH
84389: LD_INT 1
84391: EQUAL
84392: IFFALSE 87330
// begin case mission_number of 1 :
84394: LD_OWVAR 70
84398: PUSH
84399: LD_INT 1
84401: DOUBLE
84402: EQUAL
84403: IFTRUE 84407
84405: GO 84471
84407: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84408: LD_ADDR_VAR 0 1
84412: PUSH
84413: LD_INT 2
84415: PUSH
84416: LD_INT 4
84418: PUSH
84419: LD_INT 11
84421: PUSH
84422: LD_INT 12
84424: PUSH
84425: LD_INT 15
84427: PUSH
84428: LD_INT 16
84430: PUSH
84431: LD_INT 22
84433: PUSH
84434: LD_INT 23
84436: PUSH
84437: LD_INT 26
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 101
84453: PUSH
84454: LD_INT 102
84456: PUSH
84457: LD_INT 106
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: LIST
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: ST_TO_ADDR
84469: GO 87328
84471: LD_INT 2
84473: DOUBLE
84474: EQUAL
84475: IFTRUE 84479
84477: GO 84551
84479: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84480: LD_ADDR_VAR 0 1
84484: PUSH
84485: LD_INT 2
84487: PUSH
84488: LD_INT 4
84490: PUSH
84491: LD_INT 11
84493: PUSH
84494: LD_INT 12
84496: PUSH
84497: LD_INT 15
84499: PUSH
84500: LD_INT 16
84502: PUSH
84503: LD_INT 22
84505: PUSH
84506: LD_INT 23
84508: PUSH
84509: LD_INT 26
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 101
84525: PUSH
84526: LD_INT 102
84528: PUSH
84529: LD_INT 105
84531: PUSH
84532: LD_INT 106
84534: PUSH
84535: LD_INT 108
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: ST_TO_ADDR
84549: GO 87328
84551: LD_INT 3
84553: DOUBLE
84554: EQUAL
84555: IFTRUE 84559
84557: GO 84635
84559: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84560: LD_ADDR_VAR 0 1
84564: PUSH
84565: LD_INT 2
84567: PUSH
84568: LD_INT 4
84570: PUSH
84571: LD_INT 5
84573: PUSH
84574: LD_INT 11
84576: PUSH
84577: LD_INT 12
84579: PUSH
84580: LD_INT 15
84582: PUSH
84583: LD_INT 16
84585: PUSH
84586: LD_INT 22
84588: PUSH
84589: LD_INT 26
84591: PUSH
84592: LD_INT 36
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 101
84609: PUSH
84610: LD_INT 102
84612: PUSH
84613: LD_INT 105
84615: PUSH
84616: LD_INT 106
84618: PUSH
84619: LD_INT 108
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: LIST
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: ST_TO_ADDR
84633: GO 87328
84635: LD_INT 4
84637: DOUBLE
84638: EQUAL
84639: IFTRUE 84643
84641: GO 84727
84643: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84644: LD_ADDR_VAR 0 1
84648: PUSH
84649: LD_INT 2
84651: PUSH
84652: LD_INT 4
84654: PUSH
84655: LD_INT 5
84657: PUSH
84658: LD_INT 8
84660: PUSH
84661: LD_INT 11
84663: PUSH
84664: LD_INT 12
84666: PUSH
84667: LD_INT 15
84669: PUSH
84670: LD_INT 16
84672: PUSH
84673: LD_INT 22
84675: PUSH
84676: LD_INT 23
84678: PUSH
84679: LD_INT 26
84681: PUSH
84682: LD_INT 36
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 101
84701: PUSH
84702: LD_INT 102
84704: PUSH
84705: LD_INT 105
84707: PUSH
84708: LD_INT 106
84710: PUSH
84711: LD_INT 108
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: ST_TO_ADDR
84725: GO 87328
84727: LD_INT 5
84729: DOUBLE
84730: EQUAL
84731: IFTRUE 84735
84733: GO 84835
84735: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84736: LD_ADDR_VAR 0 1
84740: PUSH
84741: LD_INT 2
84743: PUSH
84744: LD_INT 4
84746: PUSH
84747: LD_INT 5
84749: PUSH
84750: LD_INT 6
84752: PUSH
84753: LD_INT 8
84755: PUSH
84756: LD_INT 11
84758: PUSH
84759: LD_INT 12
84761: PUSH
84762: LD_INT 15
84764: PUSH
84765: LD_INT 16
84767: PUSH
84768: LD_INT 22
84770: PUSH
84771: LD_INT 23
84773: PUSH
84774: LD_INT 25
84776: PUSH
84777: LD_INT 26
84779: PUSH
84780: LD_INT 36
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 101
84801: PUSH
84802: LD_INT 102
84804: PUSH
84805: LD_INT 105
84807: PUSH
84808: LD_INT 106
84810: PUSH
84811: LD_INT 108
84813: PUSH
84814: LD_INT 109
84816: PUSH
84817: LD_INT 112
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: ST_TO_ADDR
84833: GO 87328
84835: LD_INT 6
84837: DOUBLE
84838: EQUAL
84839: IFTRUE 84843
84841: GO 84963
84843: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84844: LD_ADDR_VAR 0 1
84848: PUSH
84849: LD_INT 2
84851: PUSH
84852: LD_INT 4
84854: PUSH
84855: LD_INT 5
84857: PUSH
84858: LD_INT 6
84860: PUSH
84861: LD_INT 8
84863: PUSH
84864: LD_INT 11
84866: PUSH
84867: LD_INT 12
84869: PUSH
84870: LD_INT 15
84872: PUSH
84873: LD_INT 16
84875: PUSH
84876: LD_INT 20
84878: PUSH
84879: LD_INT 21
84881: PUSH
84882: LD_INT 22
84884: PUSH
84885: LD_INT 23
84887: PUSH
84888: LD_INT 25
84890: PUSH
84891: LD_INT 26
84893: PUSH
84894: LD_INT 30
84896: PUSH
84897: LD_INT 31
84899: PUSH
84900: LD_INT 32
84902: PUSH
84903: LD_INT 36
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 101
84929: PUSH
84930: LD_INT 102
84932: PUSH
84933: LD_INT 105
84935: PUSH
84936: LD_INT 106
84938: PUSH
84939: LD_INT 108
84941: PUSH
84942: LD_INT 109
84944: PUSH
84945: LD_INT 112
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: ST_TO_ADDR
84961: GO 87328
84963: LD_INT 7
84965: DOUBLE
84966: EQUAL
84967: IFTRUE 84971
84969: GO 85071
84971: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84972: LD_ADDR_VAR 0 1
84976: PUSH
84977: LD_INT 2
84979: PUSH
84980: LD_INT 4
84982: PUSH
84983: LD_INT 5
84985: PUSH
84986: LD_INT 7
84988: PUSH
84989: LD_INT 11
84991: PUSH
84992: LD_INT 12
84994: PUSH
84995: LD_INT 15
84997: PUSH
84998: LD_INT 16
85000: PUSH
85001: LD_INT 20
85003: PUSH
85004: LD_INT 21
85006: PUSH
85007: LD_INT 22
85009: PUSH
85010: LD_INT 23
85012: PUSH
85013: LD_INT 25
85015: PUSH
85016: LD_INT 26
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 101
85037: PUSH
85038: LD_INT 102
85040: PUSH
85041: LD_INT 103
85043: PUSH
85044: LD_INT 105
85046: PUSH
85047: LD_INT 106
85049: PUSH
85050: LD_INT 108
85052: PUSH
85053: LD_INT 112
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: ST_TO_ADDR
85069: GO 87328
85071: LD_INT 8
85073: DOUBLE
85074: EQUAL
85075: IFTRUE 85079
85077: GO 85207
85079: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
85080: LD_ADDR_VAR 0 1
85084: PUSH
85085: LD_INT 2
85087: PUSH
85088: LD_INT 4
85090: PUSH
85091: LD_INT 5
85093: PUSH
85094: LD_INT 6
85096: PUSH
85097: LD_INT 7
85099: PUSH
85100: LD_INT 8
85102: PUSH
85103: LD_INT 11
85105: PUSH
85106: LD_INT 12
85108: PUSH
85109: LD_INT 15
85111: PUSH
85112: LD_INT 16
85114: PUSH
85115: LD_INT 20
85117: PUSH
85118: LD_INT 21
85120: PUSH
85121: LD_INT 22
85123: PUSH
85124: LD_INT 23
85126: PUSH
85127: LD_INT 25
85129: PUSH
85130: LD_INT 26
85132: PUSH
85133: LD_INT 30
85135: PUSH
85136: LD_INT 31
85138: PUSH
85139: LD_INT 32
85141: PUSH
85142: LD_INT 36
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 101
85169: PUSH
85170: LD_INT 102
85172: PUSH
85173: LD_INT 103
85175: PUSH
85176: LD_INT 105
85178: PUSH
85179: LD_INT 106
85181: PUSH
85182: LD_INT 108
85184: PUSH
85185: LD_INT 109
85187: PUSH
85188: LD_INT 112
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: ST_TO_ADDR
85205: GO 87328
85207: LD_INT 9
85209: DOUBLE
85210: EQUAL
85211: IFTRUE 85215
85213: GO 85351
85215: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85216: LD_ADDR_VAR 0 1
85220: PUSH
85221: LD_INT 2
85223: PUSH
85224: LD_INT 4
85226: PUSH
85227: LD_INT 5
85229: PUSH
85230: LD_INT 6
85232: PUSH
85233: LD_INT 7
85235: PUSH
85236: LD_INT 8
85238: PUSH
85239: LD_INT 11
85241: PUSH
85242: LD_INT 12
85244: PUSH
85245: LD_INT 15
85247: PUSH
85248: LD_INT 16
85250: PUSH
85251: LD_INT 20
85253: PUSH
85254: LD_INT 21
85256: PUSH
85257: LD_INT 22
85259: PUSH
85260: LD_INT 23
85262: PUSH
85263: LD_INT 25
85265: PUSH
85266: LD_INT 26
85268: PUSH
85269: LD_INT 28
85271: PUSH
85272: LD_INT 30
85274: PUSH
85275: LD_INT 31
85277: PUSH
85278: LD_INT 32
85280: PUSH
85281: LD_INT 36
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 101
85309: PUSH
85310: LD_INT 102
85312: PUSH
85313: LD_INT 103
85315: PUSH
85316: LD_INT 105
85318: PUSH
85319: LD_INT 106
85321: PUSH
85322: LD_INT 108
85324: PUSH
85325: LD_INT 109
85327: PUSH
85328: LD_INT 112
85330: PUSH
85331: LD_INT 114
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: ST_TO_ADDR
85349: GO 87328
85351: LD_INT 10
85353: DOUBLE
85354: EQUAL
85355: IFTRUE 85359
85357: GO 85543
85359: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85360: LD_ADDR_VAR 0 1
85364: PUSH
85365: LD_INT 2
85367: PUSH
85368: LD_INT 4
85370: PUSH
85371: LD_INT 5
85373: PUSH
85374: LD_INT 6
85376: PUSH
85377: LD_INT 7
85379: PUSH
85380: LD_INT 8
85382: PUSH
85383: LD_INT 9
85385: PUSH
85386: LD_INT 10
85388: PUSH
85389: LD_INT 11
85391: PUSH
85392: LD_INT 12
85394: PUSH
85395: LD_INT 13
85397: PUSH
85398: LD_INT 14
85400: PUSH
85401: LD_INT 15
85403: PUSH
85404: LD_INT 16
85406: PUSH
85407: LD_INT 17
85409: PUSH
85410: LD_INT 18
85412: PUSH
85413: LD_INT 19
85415: PUSH
85416: LD_INT 20
85418: PUSH
85419: LD_INT 21
85421: PUSH
85422: LD_INT 22
85424: PUSH
85425: LD_INT 23
85427: PUSH
85428: LD_INT 24
85430: PUSH
85431: LD_INT 25
85433: PUSH
85434: LD_INT 26
85436: PUSH
85437: LD_INT 28
85439: PUSH
85440: LD_INT 30
85442: PUSH
85443: LD_INT 31
85445: PUSH
85446: LD_INT 32
85448: PUSH
85449: LD_INT 36
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 101
85485: PUSH
85486: LD_INT 102
85488: PUSH
85489: LD_INT 103
85491: PUSH
85492: LD_INT 104
85494: PUSH
85495: LD_INT 105
85497: PUSH
85498: LD_INT 106
85500: PUSH
85501: LD_INT 107
85503: PUSH
85504: LD_INT 108
85506: PUSH
85507: LD_INT 109
85509: PUSH
85510: LD_INT 110
85512: PUSH
85513: LD_INT 111
85515: PUSH
85516: LD_INT 112
85518: PUSH
85519: LD_INT 114
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: ST_TO_ADDR
85541: GO 87328
85543: LD_INT 11
85545: DOUBLE
85546: EQUAL
85547: IFTRUE 85551
85549: GO 85743
85551: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85552: LD_ADDR_VAR 0 1
85556: PUSH
85557: LD_INT 2
85559: PUSH
85560: LD_INT 3
85562: PUSH
85563: LD_INT 4
85565: PUSH
85566: LD_INT 5
85568: PUSH
85569: LD_INT 6
85571: PUSH
85572: LD_INT 7
85574: PUSH
85575: LD_INT 8
85577: PUSH
85578: LD_INT 9
85580: PUSH
85581: LD_INT 10
85583: PUSH
85584: LD_INT 11
85586: PUSH
85587: LD_INT 12
85589: PUSH
85590: LD_INT 13
85592: PUSH
85593: LD_INT 14
85595: PUSH
85596: LD_INT 15
85598: PUSH
85599: LD_INT 16
85601: PUSH
85602: LD_INT 17
85604: PUSH
85605: LD_INT 18
85607: PUSH
85608: LD_INT 19
85610: PUSH
85611: LD_INT 20
85613: PUSH
85614: LD_INT 21
85616: PUSH
85617: LD_INT 22
85619: PUSH
85620: LD_INT 23
85622: PUSH
85623: LD_INT 24
85625: PUSH
85626: LD_INT 25
85628: PUSH
85629: LD_INT 26
85631: PUSH
85632: LD_INT 28
85634: PUSH
85635: LD_INT 30
85637: PUSH
85638: LD_INT 31
85640: PUSH
85641: LD_INT 32
85643: PUSH
85644: LD_INT 34
85646: PUSH
85647: LD_INT 36
85649: PUSH
85650: EMPTY
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 101
85685: PUSH
85686: LD_INT 102
85688: PUSH
85689: LD_INT 103
85691: PUSH
85692: LD_INT 104
85694: PUSH
85695: LD_INT 105
85697: PUSH
85698: LD_INT 106
85700: PUSH
85701: LD_INT 107
85703: PUSH
85704: LD_INT 108
85706: PUSH
85707: LD_INT 109
85709: PUSH
85710: LD_INT 110
85712: PUSH
85713: LD_INT 111
85715: PUSH
85716: LD_INT 112
85718: PUSH
85719: LD_INT 114
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: ST_TO_ADDR
85741: GO 87328
85743: LD_INT 12
85745: DOUBLE
85746: EQUAL
85747: IFTRUE 85751
85749: GO 85959
85751: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85752: LD_ADDR_VAR 0 1
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: LD_INT 3
85765: PUSH
85766: LD_INT 4
85768: PUSH
85769: LD_INT 5
85771: PUSH
85772: LD_INT 6
85774: PUSH
85775: LD_INT 7
85777: PUSH
85778: LD_INT 8
85780: PUSH
85781: LD_INT 9
85783: PUSH
85784: LD_INT 10
85786: PUSH
85787: LD_INT 11
85789: PUSH
85790: LD_INT 12
85792: PUSH
85793: LD_INT 13
85795: PUSH
85796: LD_INT 14
85798: PUSH
85799: LD_INT 15
85801: PUSH
85802: LD_INT 16
85804: PUSH
85805: LD_INT 17
85807: PUSH
85808: LD_INT 18
85810: PUSH
85811: LD_INT 19
85813: PUSH
85814: LD_INT 20
85816: PUSH
85817: LD_INT 21
85819: PUSH
85820: LD_INT 22
85822: PUSH
85823: LD_INT 23
85825: PUSH
85826: LD_INT 24
85828: PUSH
85829: LD_INT 25
85831: PUSH
85832: LD_INT 26
85834: PUSH
85835: LD_INT 27
85837: PUSH
85838: LD_INT 28
85840: PUSH
85841: LD_INT 30
85843: PUSH
85844: LD_INT 31
85846: PUSH
85847: LD_INT 32
85849: PUSH
85850: LD_INT 33
85852: PUSH
85853: LD_INT 34
85855: PUSH
85856: LD_INT 36
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 101
85897: PUSH
85898: LD_INT 102
85900: PUSH
85901: LD_INT 103
85903: PUSH
85904: LD_INT 104
85906: PUSH
85907: LD_INT 105
85909: PUSH
85910: LD_INT 106
85912: PUSH
85913: LD_INT 107
85915: PUSH
85916: LD_INT 108
85918: PUSH
85919: LD_INT 109
85921: PUSH
85922: LD_INT 110
85924: PUSH
85925: LD_INT 111
85927: PUSH
85928: LD_INT 112
85930: PUSH
85931: LD_INT 113
85933: PUSH
85934: LD_INT 114
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: ST_TO_ADDR
85957: GO 87328
85959: LD_INT 13
85961: DOUBLE
85962: EQUAL
85963: IFTRUE 85967
85965: GO 86163
85967: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85968: LD_ADDR_VAR 0 1
85972: PUSH
85973: LD_INT 1
85975: PUSH
85976: LD_INT 2
85978: PUSH
85979: LD_INT 3
85981: PUSH
85982: LD_INT 4
85984: PUSH
85985: LD_INT 5
85987: PUSH
85988: LD_INT 8
85990: PUSH
85991: LD_INT 9
85993: PUSH
85994: LD_INT 10
85996: PUSH
85997: LD_INT 11
85999: PUSH
86000: LD_INT 12
86002: PUSH
86003: LD_INT 14
86005: PUSH
86006: LD_INT 15
86008: PUSH
86009: LD_INT 16
86011: PUSH
86012: LD_INT 17
86014: PUSH
86015: LD_INT 18
86017: PUSH
86018: LD_INT 19
86020: PUSH
86021: LD_INT 20
86023: PUSH
86024: LD_INT 21
86026: PUSH
86027: LD_INT 22
86029: PUSH
86030: LD_INT 23
86032: PUSH
86033: LD_INT 24
86035: PUSH
86036: LD_INT 25
86038: PUSH
86039: LD_INT 26
86041: PUSH
86042: LD_INT 27
86044: PUSH
86045: LD_INT 28
86047: PUSH
86048: LD_INT 30
86050: PUSH
86051: LD_INT 31
86053: PUSH
86054: LD_INT 32
86056: PUSH
86057: LD_INT 33
86059: PUSH
86060: LD_INT 34
86062: PUSH
86063: LD_INT 36
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 101
86101: PUSH
86102: LD_INT 102
86104: PUSH
86105: LD_INT 103
86107: PUSH
86108: LD_INT 104
86110: PUSH
86111: LD_INT 105
86113: PUSH
86114: LD_INT 106
86116: PUSH
86117: LD_INT 107
86119: PUSH
86120: LD_INT 108
86122: PUSH
86123: LD_INT 109
86125: PUSH
86126: LD_INT 110
86128: PUSH
86129: LD_INT 111
86131: PUSH
86132: LD_INT 112
86134: PUSH
86135: LD_INT 113
86137: PUSH
86138: LD_INT 114
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: ST_TO_ADDR
86161: GO 87328
86163: LD_INT 14
86165: DOUBLE
86166: EQUAL
86167: IFTRUE 86171
86169: GO 86383
86171: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
86172: LD_ADDR_VAR 0 1
86176: PUSH
86177: LD_INT 1
86179: PUSH
86180: LD_INT 2
86182: PUSH
86183: LD_INT 3
86185: PUSH
86186: LD_INT 4
86188: PUSH
86189: LD_INT 5
86191: PUSH
86192: LD_INT 6
86194: PUSH
86195: LD_INT 7
86197: PUSH
86198: LD_INT 8
86200: PUSH
86201: LD_INT 9
86203: PUSH
86204: LD_INT 10
86206: PUSH
86207: LD_INT 11
86209: PUSH
86210: LD_INT 12
86212: PUSH
86213: LD_INT 13
86215: PUSH
86216: LD_INT 14
86218: PUSH
86219: LD_INT 15
86221: PUSH
86222: LD_INT 16
86224: PUSH
86225: LD_INT 17
86227: PUSH
86228: LD_INT 18
86230: PUSH
86231: LD_INT 19
86233: PUSH
86234: LD_INT 20
86236: PUSH
86237: LD_INT 21
86239: PUSH
86240: LD_INT 22
86242: PUSH
86243: LD_INT 23
86245: PUSH
86246: LD_INT 24
86248: PUSH
86249: LD_INT 25
86251: PUSH
86252: LD_INT 26
86254: PUSH
86255: LD_INT 27
86257: PUSH
86258: LD_INT 28
86260: PUSH
86261: LD_INT 29
86263: PUSH
86264: LD_INT 30
86266: PUSH
86267: LD_INT 31
86269: PUSH
86270: LD_INT 32
86272: PUSH
86273: LD_INT 33
86275: PUSH
86276: LD_INT 34
86278: PUSH
86279: LD_INT 36
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: LIST
86286: LIST
86287: LIST
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 101
86321: PUSH
86322: LD_INT 102
86324: PUSH
86325: LD_INT 103
86327: PUSH
86328: LD_INT 104
86330: PUSH
86331: LD_INT 105
86333: PUSH
86334: LD_INT 106
86336: PUSH
86337: LD_INT 107
86339: PUSH
86340: LD_INT 108
86342: PUSH
86343: LD_INT 109
86345: PUSH
86346: LD_INT 110
86348: PUSH
86349: LD_INT 111
86351: PUSH
86352: LD_INT 112
86354: PUSH
86355: LD_INT 113
86357: PUSH
86358: LD_INT 114
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: ST_TO_ADDR
86381: GO 87328
86383: LD_INT 15
86385: DOUBLE
86386: EQUAL
86387: IFTRUE 86391
86389: GO 86603
86391: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86392: LD_ADDR_VAR 0 1
86396: PUSH
86397: LD_INT 1
86399: PUSH
86400: LD_INT 2
86402: PUSH
86403: LD_INT 3
86405: PUSH
86406: LD_INT 4
86408: PUSH
86409: LD_INT 5
86411: PUSH
86412: LD_INT 6
86414: PUSH
86415: LD_INT 7
86417: PUSH
86418: LD_INT 8
86420: PUSH
86421: LD_INT 9
86423: PUSH
86424: LD_INT 10
86426: PUSH
86427: LD_INT 11
86429: PUSH
86430: LD_INT 12
86432: PUSH
86433: LD_INT 13
86435: PUSH
86436: LD_INT 14
86438: PUSH
86439: LD_INT 15
86441: PUSH
86442: LD_INT 16
86444: PUSH
86445: LD_INT 17
86447: PUSH
86448: LD_INT 18
86450: PUSH
86451: LD_INT 19
86453: PUSH
86454: LD_INT 20
86456: PUSH
86457: LD_INT 21
86459: PUSH
86460: LD_INT 22
86462: PUSH
86463: LD_INT 23
86465: PUSH
86466: LD_INT 24
86468: PUSH
86469: LD_INT 25
86471: PUSH
86472: LD_INT 26
86474: PUSH
86475: LD_INT 27
86477: PUSH
86478: LD_INT 28
86480: PUSH
86481: LD_INT 29
86483: PUSH
86484: LD_INT 30
86486: PUSH
86487: LD_INT 31
86489: PUSH
86490: LD_INT 32
86492: PUSH
86493: LD_INT 33
86495: PUSH
86496: LD_INT 34
86498: PUSH
86499: LD_INT 36
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 101
86541: PUSH
86542: LD_INT 102
86544: PUSH
86545: LD_INT 103
86547: PUSH
86548: LD_INT 104
86550: PUSH
86551: LD_INT 105
86553: PUSH
86554: LD_INT 106
86556: PUSH
86557: LD_INT 107
86559: PUSH
86560: LD_INT 108
86562: PUSH
86563: LD_INT 109
86565: PUSH
86566: LD_INT 110
86568: PUSH
86569: LD_INT 111
86571: PUSH
86572: LD_INT 112
86574: PUSH
86575: LD_INT 113
86577: PUSH
86578: LD_INT 114
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: ST_TO_ADDR
86601: GO 87328
86603: LD_INT 16
86605: DOUBLE
86606: EQUAL
86607: IFTRUE 86611
86609: GO 86735
86611: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86612: LD_ADDR_VAR 0 1
86616: PUSH
86617: LD_INT 2
86619: PUSH
86620: LD_INT 4
86622: PUSH
86623: LD_INT 5
86625: PUSH
86626: LD_INT 7
86628: PUSH
86629: LD_INT 11
86631: PUSH
86632: LD_INT 12
86634: PUSH
86635: LD_INT 15
86637: PUSH
86638: LD_INT 16
86640: PUSH
86641: LD_INT 20
86643: PUSH
86644: LD_INT 21
86646: PUSH
86647: LD_INT 22
86649: PUSH
86650: LD_INT 23
86652: PUSH
86653: LD_INT 25
86655: PUSH
86656: LD_INT 26
86658: PUSH
86659: LD_INT 30
86661: PUSH
86662: LD_INT 31
86664: PUSH
86665: LD_INT 32
86667: PUSH
86668: LD_INT 33
86670: PUSH
86671: LD_INT 34
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 101
86697: PUSH
86698: LD_INT 102
86700: PUSH
86701: LD_INT 103
86703: PUSH
86704: LD_INT 106
86706: PUSH
86707: LD_INT 108
86709: PUSH
86710: LD_INT 112
86712: PUSH
86713: LD_INT 113
86715: PUSH
86716: LD_INT 114
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: ST_TO_ADDR
86733: GO 87328
86735: LD_INT 17
86737: DOUBLE
86738: EQUAL
86739: IFTRUE 86743
86741: GO 86955
86743: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86744: LD_ADDR_VAR 0 1
86748: PUSH
86749: LD_INT 1
86751: PUSH
86752: LD_INT 2
86754: PUSH
86755: LD_INT 3
86757: PUSH
86758: LD_INT 4
86760: PUSH
86761: LD_INT 5
86763: PUSH
86764: LD_INT 6
86766: PUSH
86767: LD_INT 7
86769: PUSH
86770: LD_INT 8
86772: PUSH
86773: LD_INT 9
86775: PUSH
86776: LD_INT 10
86778: PUSH
86779: LD_INT 11
86781: PUSH
86782: LD_INT 12
86784: PUSH
86785: LD_INT 13
86787: PUSH
86788: LD_INT 14
86790: PUSH
86791: LD_INT 15
86793: PUSH
86794: LD_INT 16
86796: PUSH
86797: LD_INT 17
86799: PUSH
86800: LD_INT 18
86802: PUSH
86803: LD_INT 19
86805: PUSH
86806: LD_INT 20
86808: PUSH
86809: LD_INT 21
86811: PUSH
86812: LD_INT 22
86814: PUSH
86815: LD_INT 23
86817: PUSH
86818: LD_INT 24
86820: PUSH
86821: LD_INT 25
86823: PUSH
86824: LD_INT 26
86826: PUSH
86827: LD_INT 27
86829: PUSH
86830: LD_INT 28
86832: PUSH
86833: LD_INT 29
86835: PUSH
86836: LD_INT 30
86838: PUSH
86839: LD_INT 31
86841: PUSH
86842: LD_INT 32
86844: PUSH
86845: LD_INT 33
86847: PUSH
86848: LD_INT 34
86850: PUSH
86851: LD_INT 36
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 101
86893: PUSH
86894: LD_INT 102
86896: PUSH
86897: LD_INT 103
86899: PUSH
86900: LD_INT 104
86902: PUSH
86903: LD_INT 105
86905: PUSH
86906: LD_INT 106
86908: PUSH
86909: LD_INT 107
86911: PUSH
86912: LD_INT 108
86914: PUSH
86915: LD_INT 109
86917: PUSH
86918: LD_INT 110
86920: PUSH
86921: LD_INT 111
86923: PUSH
86924: LD_INT 112
86926: PUSH
86927: LD_INT 113
86929: PUSH
86930: LD_INT 114
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: ST_TO_ADDR
86953: GO 87328
86955: LD_INT 18
86957: DOUBLE
86958: EQUAL
86959: IFTRUE 86963
86961: GO 87099
86963: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86964: LD_ADDR_VAR 0 1
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: LD_INT 4
86974: PUSH
86975: LD_INT 5
86977: PUSH
86978: LD_INT 7
86980: PUSH
86981: LD_INT 11
86983: PUSH
86984: LD_INT 12
86986: PUSH
86987: LD_INT 15
86989: PUSH
86990: LD_INT 16
86992: PUSH
86993: LD_INT 20
86995: PUSH
86996: LD_INT 21
86998: PUSH
86999: LD_INT 22
87001: PUSH
87002: LD_INT 23
87004: PUSH
87005: LD_INT 25
87007: PUSH
87008: LD_INT 26
87010: PUSH
87011: LD_INT 30
87013: PUSH
87014: LD_INT 31
87016: PUSH
87017: LD_INT 32
87019: PUSH
87020: LD_INT 33
87022: PUSH
87023: LD_INT 34
87025: PUSH
87026: LD_INT 35
87028: PUSH
87029: LD_INT 36
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 101
87057: PUSH
87058: LD_INT 102
87060: PUSH
87061: LD_INT 103
87063: PUSH
87064: LD_INT 106
87066: PUSH
87067: LD_INT 108
87069: PUSH
87070: LD_INT 112
87072: PUSH
87073: LD_INT 113
87075: PUSH
87076: LD_INT 114
87078: PUSH
87079: LD_INT 115
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: ST_TO_ADDR
87097: GO 87328
87099: LD_INT 19
87101: DOUBLE
87102: EQUAL
87103: IFTRUE 87107
87105: GO 87327
87107: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87108: LD_ADDR_VAR 0 1
87112: PUSH
87113: LD_INT 1
87115: PUSH
87116: LD_INT 2
87118: PUSH
87119: LD_INT 3
87121: PUSH
87122: LD_INT 4
87124: PUSH
87125: LD_INT 5
87127: PUSH
87128: LD_INT 6
87130: PUSH
87131: LD_INT 7
87133: PUSH
87134: LD_INT 8
87136: PUSH
87137: LD_INT 9
87139: PUSH
87140: LD_INT 10
87142: PUSH
87143: LD_INT 11
87145: PUSH
87146: LD_INT 12
87148: PUSH
87149: LD_INT 13
87151: PUSH
87152: LD_INT 14
87154: PUSH
87155: LD_INT 15
87157: PUSH
87158: LD_INT 16
87160: PUSH
87161: LD_INT 17
87163: PUSH
87164: LD_INT 18
87166: PUSH
87167: LD_INT 19
87169: PUSH
87170: LD_INT 20
87172: PUSH
87173: LD_INT 21
87175: PUSH
87176: LD_INT 22
87178: PUSH
87179: LD_INT 23
87181: PUSH
87182: LD_INT 24
87184: PUSH
87185: LD_INT 25
87187: PUSH
87188: LD_INT 26
87190: PUSH
87191: LD_INT 27
87193: PUSH
87194: LD_INT 28
87196: PUSH
87197: LD_INT 29
87199: PUSH
87200: LD_INT 30
87202: PUSH
87203: LD_INT 31
87205: PUSH
87206: LD_INT 32
87208: PUSH
87209: LD_INT 33
87211: PUSH
87212: LD_INT 34
87214: PUSH
87215: LD_INT 35
87217: PUSH
87218: LD_INT 36
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 101
87261: PUSH
87262: LD_INT 102
87264: PUSH
87265: LD_INT 103
87267: PUSH
87268: LD_INT 104
87270: PUSH
87271: LD_INT 105
87273: PUSH
87274: LD_INT 106
87276: PUSH
87277: LD_INT 107
87279: PUSH
87280: LD_INT 108
87282: PUSH
87283: LD_INT 109
87285: PUSH
87286: LD_INT 110
87288: PUSH
87289: LD_INT 111
87291: PUSH
87292: LD_INT 112
87294: PUSH
87295: LD_INT 113
87297: PUSH
87298: LD_INT 114
87300: PUSH
87301: LD_INT 115
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: ST_TO_ADDR
87325: GO 87328
87327: POP
// end else
87328: GO 87547
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87330: LD_ADDR_VAR 0 1
87334: PUSH
87335: LD_INT 1
87337: PUSH
87338: LD_INT 2
87340: PUSH
87341: LD_INT 3
87343: PUSH
87344: LD_INT 4
87346: PUSH
87347: LD_INT 5
87349: PUSH
87350: LD_INT 6
87352: PUSH
87353: LD_INT 7
87355: PUSH
87356: LD_INT 8
87358: PUSH
87359: LD_INT 9
87361: PUSH
87362: LD_INT 10
87364: PUSH
87365: LD_INT 11
87367: PUSH
87368: LD_INT 12
87370: PUSH
87371: LD_INT 13
87373: PUSH
87374: LD_INT 14
87376: PUSH
87377: LD_INT 15
87379: PUSH
87380: LD_INT 16
87382: PUSH
87383: LD_INT 17
87385: PUSH
87386: LD_INT 18
87388: PUSH
87389: LD_INT 19
87391: PUSH
87392: LD_INT 20
87394: PUSH
87395: LD_INT 21
87397: PUSH
87398: LD_INT 22
87400: PUSH
87401: LD_INT 23
87403: PUSH
87404: LD_INT 24
87406: PUSH
87407: LD_INT 25
87409: PUSH
87410: LD_INT 26
87412: PUSH
87413: LD_INT 27
87415: PUSH
87416: LD_INT 28
87418: PUSH
87419: LD_INT 29
87421: PUSH
87422: LD_INT 30
87424: PUSH
87425: LD_INT 31
87427: PUSH
87428: LD_INT 32
87430: PUSH
87431: LD_INT 33
87433: PUSH
87434: LD_INT 34
87436: PUSH
87437: LD_INT 35
87439: PUSH
87440: LD_INT 36
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 101
87483: PUSH
87484: LD_INT 102
87486: PUSH
87487: LD_INT 103
87489: PUSH
87490: LD_INT 104
87492: PUSH
87493: LD_INT 105
87495: PUSH
87496: LD_INT 106
87498: PUSH
87499: LD_INT 107
87501: PUSH
87502: LD_INT 108
87504: PUSH
87505: LD_INT 109
87507: PUSH
87508: LD_INT 110
87510: PUSH
87511: LD_INT 111
87513: PUSH
87514: LD_INT 112
87516: PUSH
87517: LD_INT 113
87519: PUSH
87520: LD_INT 114
87522: PUSH
87523: LD_INT 115
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: ST_TO_ADDR
// if result then
87547: LD_VAR 0 1
87551: IFFALSE 87840
// begin normal :=  ;
87553: LD_ADDR_VAR 0 3
87557: PUSH
87558: LD_STRING 
87560: ST_TO_ADDR
// hardcore :=  ;
87561: LD_ADDR_VAR 0 4
87565: PUSH
87566: LD_STRING 
87568: ST_TO_ADDR
// for i = 1 to normalCounter do
87569: LD_ADDR_VAR 0 5
87573: PUSH
87574: DOUBLE
87575: LD_INT 1
87577: DEC
87578: ST_TO_ADDR
87579: LD_EXP 123
87583: PUSH
87584: FOR_TO
87585: IFFALSE 87686
// begin tmp := 0 ;
87587: LD_ADDR_VAR 0 2
87591: PUSH
87592: LD_STRING 0
87594: ST_TO_ADDR
// if result [ 1 ] then
87595: LD_VAR 0 1
87599: PUSH
87600: LD_INT 1
87602: ARRAY
87603: IFFALSE 87668
// if result [ 1 ] [ 1 ] = i then
87605: LD_VAR 0 1
87609: PUSH
87610: LD_INT 1
87612: ARRAY
87613: PUSH
87614: LD_INT 1
87616: ARRAY
87617: PUSH
87618: LD_VAR 0 5
87622: EQUAL
87623: IFFALSE 87668
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87625: LD_ADDR_VAR 0 1
87629: PUSH
87630: LD_VAR 0 1
87634: PPUSH
87635: LD_INT 1
87637: PPUSH
87638: LD_VAR 0 1
87642: PUSH
87643: LD_INT 1
87645: ARRAY
87646: PPUSH
87647: LD_INT 1
87649: PPUSH
87650: CALL_OW 3
87654: PPUSH
87655: CALL_OW 1
87659: ST_TO_ADDR
// tmp := 1 ;
87660: LD_ADDR_VAR 0 2
87664: PUSH
87665: LD_STRING 1
87667: ST_TO_ADDR
// end ; normal := normal & tmp ;
87668: LD_ADDR_VAR 0 3
87672: PUSH
87673: LD_VAR 0 3
87677: PUSH
87678: LD_VAR 0 2
87682: STR
87683: ST_TO_ADDR
// end ;
87684: GO 87584
87686: POP
87687: POP
// for i = 1 to hardcoreCounter do
87688: LD_ADDR_VAR 0 5
87692: PUSH
87693: DOUBLE
87694: LD_INT 1
87696: DEC
87697: ST_TO_ADDR
87698: LD_EXP 124
87702: PUSH
87703: FOR_TO
87704: IFFALSE 87809
// begin tmp := 0 ;
87706: LD_ADDR_VAR 0 2
87710: PUSH
87711: LD_STRING 0
87713: ST_TO_ADDR
// if result [ 2 ] then
87714: LD_VAR 0 1
87718: PUSH
87719: LD_INT 2
87721: ARRAY
87722: IFFALSE 87791
// if result [ 2 ] [ 1 ] = 100 + i then
87724: LD_VAR 0 1
87728: PUSH
87729: LD_INT 2
87731: ARRAY
87732: PUSH
87733: LD_INT 1
87735: ARRAY
87736: PUSH
87737: LD_INT 100
87739: PUSH
87740: LD_VAR 0 5
87744: PLUS
87745: EQUAL
87746: IFFALSE 87791
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87748: LD_ADDR_VAR 0 1
87752: PUSH
87753: LD_VAR 0 1
87757: PPUSH
87758: LD_INT 2
87760: PPUSH
87761: LD_VAR 0 1
87765: PUSH
87766: LD_INT 2
87768: ARRAY
87769: PPUSH
87770: LD_INT 1
87772: PPUSH
87773: CALL_OW 3
87777: PPUSH
87778: CALL_OW 1
87782: ST_TO_ADDR
// tmp := 1 ;
87783: LD_ADDR_VAR 0 2
87787: PUSH
87788: LD_STRING 1
87790: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87791: LD_ADDR_VAR 0 4
87795: PUSH
87796: LD_VAR 0 4
87800: PUSH
87801: LD_VAR 0 2
87805: STR
87806: ST_TO_ADDR
// end ;
87807: GO 87703
87809: POP
87810: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87811: LD_STRING getStreamItemsFromMission("
87813: PUSH
87814: LD_VAR 0 3
87818: STR
87819: PUSH
87820: LD_STRING ","
87822: STR
87823: PUSH
87824: LD_VAR 0 4
87828: STR
87829: PUSH
87830: LD_STRING ")
87832: STR
87833: PPUSH
87834: CALL_OW 559
// end else
87838: GO 87847
// ToLua ( getStreamItemsFromMission("","") ) ;
87840: LD_STRING getStreamItemsFromMission("","")
87842: PPUSH
87843: CALL_OW 559
// end ;
87847: LD_VAR 0 1
87851: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87852: LD_EXP 122
87856: PUSH
87857: LD_EXP 127
87861: AND
87862: IFFALSE 87986
87864: GO 87866
87866: DISABLE
87867: LD_INT 0
87869: PPUSH
87870: PPUSH
// begin enable ;
87871: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87872: LD_ADDR_VAR 0 2
87876: PUSH
87877: LD_INT 22
87879: PUSH
87880: LD_OWVAR 2
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 2
87891: PUSH
87892: LD_INT 34
87894: PUSH
87895: LD_INT 7
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 34
87904: PUSH
87905: LD_INT 45
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 34
87914: PUSH
87915: LD_INT 28
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 34
87924: PUSH
87925: LD_INT 47
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: PUSH
87939: EMPTY
87940: LIST
87941: LIST
87942: PPUSH
87943: CALL_OW 69
87947: ST_TO_ADDR
// if not tmp then
87948: LD_VAR 0 2
87952: NOT
87953: IFFALSE 87957
// exit ;
87955: GO 87986
// for i in tmp do
87957: LD_ADDR_VAR 0 1
87961: PUSH
87962: LD_VAR 0 2
87966: PUSH
87967: FOR_IN
87968: IFFALSE 87984
// begin SetLives ( i , 0 ) ;
87970: LD_VAR 0 1
87974: PPUSH
87975: LD_INT 0
87977: PPUSH
87978: CALL_OW 234
// end ;
87982: GO 87967
87984: POP
87985: POP
// end ;
87986: PPOPN 2
87988: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
87989: LD_EXP 122
87993: PUSH
87994: LD_EXP 128
87998: AND
87999: IFFALSE 88083
88001: GO 88003
88003: DISABLE
88004: LD_INT 0
88006: PPUSH
88007: PPUSH
// begin enable ;
88008: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88009: LD_ADDR_VAR 0 2
88013: PUSH
88014: LD_INT 22
88016: PUSH
88017: LD_OWVAR 2
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: LD_INT 32
88028: PUSH
88029: LD_INT 3
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PPUSH
88040: CALL_OW 69
88044: ST_TO_ADDR
// if not tmp then
88045: LD_VAR 0 2
88049: NOT
88050: IFFALSE 88054
// exit ;
88052: GO 88083
// for i in tmp do
88054: LD_ADDR_VAR 0 1
88058: PUSH
88059: LD_VAR 0 2
88063: PUSH
88064: FOR_IN
88065: IFFALSE 88081
// begin SetLives ( i , 0 ) ;
88067: LD_VAR 0 1
88071: PPUSH
88072: LD_INT 0
88074: PPUSH
88075: CALL_OW 234
// end ;
88079: GO 88064
88081: POP
88082: POP
// end ;
88083: PPOPN 2
88085: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88086: LD_EXP 122
88090: PUSH
88091: LD_EXP 125
88095: AND
88096: IFFALSE 88189
88098: GO 88100
88100: DISABLE
88101: LD_INT 0
88103: PPUSH
// begin enable ;
88104: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88105: LD_ADDR_VAR 0 1
88109: PUSH
88110: LD_INT 22
88112: PUSH
88113: LD_OWVAR 2
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 2
88124: PUSH
88125: LD_INT 25
88127: PUSH
88128: LD_INT 5
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 25
88137: PUSH
88138: LD_INT 9
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 25
88147: PUSH
88148: LD_INT 8
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: PPUSH
88165: CALL_OW 69
88169: PUSH
88170: FOR_IN
88171: IFFALSE 88187
// begin SetClass ( i , 1 ) ;
88173: LD_VAR 0 1
88177: PPUSH
88178: LD_INT 1
88180: PPUSH
88181: CALL_OW 336
// end ;
88185: GO 88170
88187: POP
88188: POP
// end ;
88189: PPOPN 1
88191: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88192: LD_EXP 122
88196: PUSH
88197: LD_EXP 126
88201: AND
88202: PUSH
88203: LD_OWVAR 65
88207: PUSH
88208: LD_INT 7
88210: LESS
88211: AND
88212: IFFALSE 88226
88214: GO 88216
88216: DISABLE
// begin enable ;
88217: ENABLE
// game_speed := 7 ;
88218: LD_ADDR_OWVAR 65
88222: PUSH
88223: LD_INT 7
88225: ST_TO_ADDR
// end ;
88226: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88227: LD_EXP 122
88231: PUSH
88232: LD_EXP 129
88236: AND
88237: IFFALSE 88439
88239: GO 88241
88241: DISABLE
88242: LD_INT 0
88244: PPUSH
88245: PPUSH
88246: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88247: LD_ADDR_VAR 0 3
88251: PUSH
88252: LD_INT 81
88254: PUSH
88255: LD_OWVAR 2
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 21
88266: PUSH
88267: LD_INT 1
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PPUSH
88278: CALL_OW 69
88282: ST_TO_ADDR
// if not tmp then
88283: LD_VAR 0 3
88287: NOT
88288: IFFALSE 88292
// exit ;
88290: GO 88439
// if tmp > 5 then
88292: LD_VAR 0 3
88296: PUSH
88297: LD_INT 5
88299: GREATER
88300: IFFALSE 88312
// k := 5 else
88302: LD_ADDR_VAR 0 2
88306: PUSH
88307: LD_INT 5
88309: ST_TO_ADDR
88310: GO 88322
// k := tmp ;
88312: LD_ADDR_VAR 0 2
88316: PUSH
88317: LD_VAR 0 3
88321: ST_TO_ADDR
// for i := 1 to k do
88322: LD_ADDR_VAR 0 1
88326: PUSH
88327: DOUBLE
88328: LD_INT 1
88330: DEC
88331: ST_TO_ADDR
88332: LD_VAR 0 2
88336: PUSH
88337: FOR_TO
88338: IFFALSE 88437
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
88340: LD_VAR 0 3
88344: PUSH
88345: LD_VAR 0 1
88349: ARRAY
88350: PPUSH
88351: LD_VAR 0 1
88355: PUSH
88356: LD_INT 4
88358: MOD
88359: PUSH
88360: LD_INT 1
88362: PLUS
88363: PPUSH
88364: CALL_OW 259
88368: PUSH
88369: LD_INT 10
88371: LESS
88372: IFFALSE 88435
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88374: LD_VAR 0 3
88378: PUSH
88379: LD_VAR 0 1
88383: ARRAY
88384: PPUSH
88385: LD_VAR 0 1
88389: PUSH
88390: LD_INT 4
88392: MOD
88393: PUSH
88394: LD_INT 1
88396: PLUS
88397: PPUSH
88398: LD_VAR 0 3
88402: PUSH
88403: LD_VAR 0 1
88407: ARRAY
88408: PPUSH
88409: LD_VAR 0 1
88413: PUSH
88414: LD_INT 4
88416: MOD
88417: PUSH
88418: LD_INT 1
88420: PLUS
88421: PPUSH
88422: CALL_OW 259
88426: PUSH
88427: LD_INT 1
88429: PLUS
88430: PPUSH
88431: CALL_OW 237
88435: GO 88337
88437: POP
88438: POP
// end ;
88439: PPOPN 3
88441: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88442: LD_EXP 122
88446: PUSH
88447: LD_EXP 130
88451: AND
88452: IFFALSE 88472
88454: GO 88456
88456: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88457: LD_INT 4
88459: PPUSH
88460: LD_OWVAR 2
88464: PPUSH
88465: LD_INT 0
88467: PPUSH
88468: CALL_OW 324
88472: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88473: LD_EXP 122
88477: PUSH
88478: LD_EXP 159
88482: AND
88483: IFFALSE 88503
88485: GO 88487
88487: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88488: LD_INT 19
88490: PPUSH
88491: LD_OWVAR 2
88495: PPUSH
88496: LD_INT 0
88498: PPUSH
88499: CALL_OW 324
88503: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88504: LD_EXP 122
88508: PUSH
88509: LD_EXP 131
88513: AND
88514: IFFALSE 88616
88516: GO 88518
88518: DISABLE
88519: LD_INT 0
88521: PPUSH
88522: PPUSH
// begin enable ;
88523: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88524: LD_ADDR_VAR 0 2
88528: PUSH
88529: LD_INT 22
88531: PUSH
88532: LD_OWVAR 2
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: LD_INT 34
88546: PUSH
88547: LD_INT 11
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 34
88556: PUSH
88557: LD_INT 30
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: LIST
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: PPUSH
88573: CALL_OW 69
88577: ST_TO_ADDR
// if not tmp then
88578: LD_VAR 0 2
88582: NOT
88583: IFFALSE 88587
// exit ;
88585: GO 88616
// for i in tmp do
88587: LD_ADDR_VAR 0 1
88591: PUSH
88592: LD_VAR 0 2
88596: PUSH
88597: FOR_IN
88598: IFFALSE 88614
// begin SetLives ( i , 0 ) ;
88600: LD_VAR 0 1
88604: PPUSH
88605: LD_INT 0
88607: PPUSH
88608: CALL_OW 234
// end ;
88612: GO 88597
88614: POP
88615: POP
// end ;
88616: PPOPN 2
88618: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88619: LD_EXP 122
88623: PUSH
88624: LD_EXP 132
88628: AND
88629: IFFALSE 88649
88631: GO 88633
88633: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88634: LD_INT 32
88636: PPUSH
88637: LD_OWVAR 2
88641: PPUSH
88642: LD_INT 0
88644: PPUSH
88645: CALL_OW 324
88649: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88650: LD_EXP 122
88654: PUSH
88655: LD_EXP 133
88659: AND
88660: IFFALSE 88841
88662: GO 88664
88664: DISABLE
88665: LD_INT 0
88667: PPUSH
88668: PPUSH
88669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88670: LD_ADDR_VAR 0 2
88674: PUSH
88675: LD_INT 22
88677: PUSH
88678: LD_OWVAR 2
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 33
88689: PUSH
88690: LD_INT 3
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PPUSH
88701: CALL_OW 69
88705: ST_TO_ADDR
// if not tmp then
88706: LD_VAR 0 2
88710: NOT
88711: IFFALSE 88715
// exit ;
88713: GO 88841
// side := 0 ;
88715: LD_ADDR_VAR 0 3
88719: PUSH
88720: LD_INT 0
88722: ST_TO_ADDR
// for i := 1 to 8 do
88723: LD_ADDR_VAR 0 1
88727: PUSH
88728: DOUBLE
88729: LD_INT 1
88731: DEC
88732: ST_TO_ADDR
88733: LD_INT 8
88735: PUSH
88736: FOR_TO
88737: IFFALSE 88785
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88739: LD_OWVAR 2
88743: PUSH
88744: LD_VAR 0 1
88748: NONEQUAL
88749: PUSH
88750: LD_OWVAR 2
88754: PPUSH
88755: LD_VAR 0 1
88759: PPUSH
88760: CALL_OW 81
88764: PUSH
88765: LD_INT 2
88767: EQUAL
88768: AND
88769: IFFALSE 88783
// begin side := i ;
88771: LD_ADDR_VAR 0 3
88775: PUSH
88776: LD_VAR 0 1
88780: ST_TO_ADDR
// break ;
88781: GO 88785
// end ;
88783: GO 88736
88785: POP
88786: POP
// if not side then
88787: LD_VAR 0 3
88791: NOT
88792: IFFALSE 88796
// exit ;
88794: GO 88841
// for i := 1 to tmp do
88796: LD_ADDR_VAR 0 1
88800: PUSH
88801: DOUBLE
88802: LD_INT 1
88804: DEC
88805: ST_TO_ADDR
88806: LD_VAR 0 2
88810: PUSH
88811: FOR_TO
88812: IFFALSE 88839
// if Prob ( 60 ) then
88814: LD_INT 60
88816: PPUSH
88817: CALL_OW 13
88821: IFFALSE 88837
// SetSide ( i , side ) ;
88823: LD_VAR 0 1
88827: PPUSH
88828: LD_VAR 0 3
88832: PPUSH
88833: CALL_OW 235
88837: GO 88811
88839: POP
88840: POP
// end ;
88841: PPOPN 3
88843: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88844: LD_EXP 122
88848: PUSH
88849: LD_EXP 135
88853: AND
88854: IFFALSE 88973
88856: GO 88858
88858: DISABLE
88859: LD_INT 0
88861: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88862: LD_ADDR_VAR 0 1
88866: PUSH
88867: LD_INT 22
88869: PUSH
88870: LD_OWVAR 2
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 21
88881: PUSH
88882: LD_INT 1
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 3
88891: PUSH
88892: LD_INT 23
88894: PUSH
88895: LD_INT 0
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: LIST
88910: PPUSH
88911: CALL_OW 69
88915: PUSH
88916: FOR_IN
88917: IFFALSE 88971
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88919: LD_VAR 0 1
88923: PPUSH
88924: CALL_OW 257
88928: PUSH
88929: LD_INT 1
88931: PUSH
88932: LD_INT 2
88934: PUSH
88935: LD_INT 3
88937: PUSH
88938: LD_INT 4
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: IN
88947: IFFALSE 88969
// SetClass ( un , rand ( 1 , 4 ) ) ;
88949: LD_VAR 0 1
88953: PPUSH
88954: LD_INT 1
88956: PPUSH
88957: LD_INT 4
88959: PPUSH
88960: CALL_OW 12
88964: PPUSH
88965: CALL_OW 336
88969: GO 88916
88971: POP
88972: POP
// end ;
88973: PPOPN 1
88975: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88976: LD_EXP 122
88980: PUSH
88981: LD_EXP 134
88985: AND
88986: IFFALSE 89065
88988: GO 88990
88990: DISABLE
88991: LD_INT 0
88993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88994: LD_ADDR_VAR 0 1
88998: PUSH
88999: LD_INT 22
89001: PUSH
89002: LD_OWVAR 2
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 21
89013: PUSH
89014: LD_INT 3
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PPUSH
89025: CALL_OW 69
89029: ST_TO_ADDR
// if not tmp then
89030: LD_VAR 0 1
89034: NOT
89035: IFFALSE 89039
// exit ;
89037: GO 89065
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89039: LD_VAR 0 1
89043: PUSH
89044: LD_INT 1
89046: PPUSH
89047: LD_VAR 0 1
89051: PPUSH
89052: CALL_OW 12
89056: ARRAY
89057: PPUSH
89058: LD_INT 100
89060: PPUSH
89061: CALL_OW 234
// end ;
89065: PPOPN 1
89067: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89068: LD_EXP 122
89072: PUSH
89073: LD_EXP 136
89077: AND
89078: IFFALSE 89176
89080: GO 89082
89082: DISABLE
89083: LD_INT 0
89085: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89086: LD_ADDR_VAR 0 1
89090: PUSH
89091: LD_INT 22
89093: PUSH
89094: LD_OWVAR 2
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: PUSH
89103: LD_INT 21
89105: PUSH
89106: LD_INT 1
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PPUSH
89117: CALL_OW 69
89121: ST_TO_ADDR
// if not tmp then
89122: LD_VAR 0 1
89126: NOT
89127: IFFALSE 89131
// exit ;
89129: GO 89176
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89131: LD_VAR 0 1
89135: PUSH
89136: LD_INT 1
89138: PPUSH
89139: LD_VAR 0 1
89143: PPUSH
89144: CALL_OW 12
89148: ARRAY
89149: PPUSH
89150: LD_INT 1
89152: PPUSH
89153: LD_INT 4
89155: PPUSH
89156: CALL_OW 12
89160: PPUSH
89161: LD_INT 3000
89163: PPUSH
89164: LD_INT 9000
89166: PPUSH
89167: CALL_OW 12
89171: PPUSH
89172: CALL_OW 492
// end ;
89176: PPOPN 1
89178: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89179: LD_EXP 122
89183: PUSH
89184: LD_EXP 137
89188: AND
89189: IFFALSE 89209
89191: GO 89193
89193: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89194: LD_INT 1
89196: PPUSH
89197: LD_OWVAR 2
89201: PPUSH
89202: LD_INT 0
89204: PPUSH
89205: CALL_OW 324
89209: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89210: LD_EXP 122
89214: PUSH
89215: LD_EXP 138
89219: AND
89220: IFFALSE 89303
89222: GO 89224
89224: DISABLE
89225: LD_INT 0
89227: PPUSH
89228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89229: LD_ADDR_VAR 0 2
89233: PUSH
89234: LD_INT 22
89236: PUSH
89237: LD_OWVAR 2
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: PUSH
89246: LD_INT 21
89248: PUSH
89249: LD_INT 3
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PPUSH
89260: CALL_OW 69
89264: ST_TO_ADDR
// if not tmp then
89265: LD_VAR 0 2
89269: NOT
89270: IFFALSE 89274
// exit ;
89272: GO 89303
// for i in tmp do
89274: LD_ADDR_VAR 0 1
89278: PUSH
89279: LD_VAR 0 2
89283: PUSH
89284: FOR_IN
89285: IFFALSE 89301
// SetBLevel ( i , 10 ) ;
89287: LD_VAR 0 1
89291: PPUSH
89292: LD_INT 10
89294: PPUSH
89295: CALL_OW 241
89299: GO 89284
89301: POP
89302: POP
// end ;
89303: PPOPN 2
89305: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
89306: LD_EXP 122
89310: PUSH
89311: LD_EXP 139
89315: AND
89316: IFFALSE 89427
89318: GO 89320
89320: DISABLE
89321: LD_INT 0
89323: PPUSH
89324: PPUSH
89325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89326: LD_ADDR_VAR 0 3
89330: PUSH
89331: LD_INT 22
89333: PUSH
89334: LD_OWVAR 2
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 25
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PPUSH
89357: CALL_OW 69
89361: ST_TO_ADDR
// if not tmp then
89362: LD_VAR 0 3
89366: NOT
89367: IFFALSE 89371
// exit ;
89369: GO 89427
// un := tmp [ rand ( 1 , tmp ) ] ;
89371: LD_ADDR_VAR 0 2
89375: PUSH
89376: LD_VAR 0 3
89380: PUSH
89381: LD_INT 1
89383: PPUSH
89384: LD_VAR 0 3
89388: PPUSH
89389: CALL_OW 12
89393: ARRAY
89394: ST_TO_ADDR
// if Crawls ( un ) then
89395: LD_VAR 0 2
89399: PPUSH
89400: CALL_OW 318
89404: IFFALSE 89415
// ComWalk ( un ) ;
89406: LD_VAR 0 2
89410: PPUSH
89411: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89415: LD_VAR 0 2
89419: PPUSH
89420: LD_INT 5
89422: PPUSH
89423: CALL_OW 336
// end ;
89427: PPOPN 3
89429: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89430: LD_EXP 122
89434: PUSH
89435: LD_EXP 140
89439: AND
89440: PUSH
89441: LD_OWVAR 67
89445: PUSH
89446: LD_INT 3
89448: LESS
89449: AND
89450: IFFALSE 89469
89452: GO 89454
89454: DISABLE
// Difficulty := Difficulty + 1 ;
89455: LD_ADDR_OWVAR 67
89459: PUSH
89460: LD_OWVAR 67
89464: PUSH
89465: LD_INT 1
89467: PLUS
89468: ST_TO_ADDR
89469: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89470: LD_EXP 122
89474: PUSH
89475: LD_EXP 141
89479: AND
89480: IFFALSE 89583
89482: GO 89484
89484: DISABLE
89485: LD_INT 0
89487: PPUSH
// begin for i := 1 to 5 do
89488: LD_ADDR_VAR 0 1
89492: PUSH
89493: DOUBLE
89494: LD_INT 1
89496: DEC
89497: ST_TO_ADDR
89498: LD_INT 5
89500: PUSH
89501: FOR_TO
89502: IFFALSE 89581
// begin uc_nation := nation_nature ;
89504: LD_ADDR_OWVAR 21
89508: PUSH
89509: LD_INT 0
89511: ST_TO_ADDR
// uc_side := 0 ;
89512: LD_ADDR_OWVAR 20
89516: PUSH
89517: LD_INT 0
89519: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89520: LD_ADDR_OWVAR 29
89524: PUSH
89525: LD_INT 12
89527: PUSH
89528: LD_INT 12
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: ST_TO_ADDR
// hc_agressivity := 20 ;
89535: LD_ADDR_OWVAR 35
89539: PUSH
89540: LD_INT 20
89542: ST_TO_ADDR
// hc_class := class_tiger ;
89543: LD_ADDR_OWVAR 28
89547: PUSH
89548: LD_INT 14
89550: ST_TO_ADDR
// hc_gallery :=  ;
89551: LD_ADDR_OWVAR 33
89555: PUSH
89556: LD_STRING 
89558: ST_TO_ADDR
// hc_name :=  ;
89559: LD_ADDR_OWVAR 26
89563: PUSH
89564: LD_STRING 
89566: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89567: CALL_OW 44
89571: PPUSH
89572: LD_INT 0
89574: PPUSH
89575: CALL_OW 51
// end ;
89579: GO 89501
89581: POP
89582: POP
// end ;
89583: PPOPN 1
89585: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89586: LD_EXP 122
89590: PUSH
89591: LD_EXP 142
89595: AND
89596: IFFALSE 89605
89598: GO 89600
89600: DISABLE
// StreamSibBomb ;
89601: CALL 89606 0 0
89605: END
// export function StreamSibBomb ; var i , x , y ; begin
89606: LD_INT 0
89608: PPUSH
89609: PPUSH
89610: PPUSH
89611: PPUSH
// result := false ;
89612: LD_ADDR_VAR 0 1
89616: PUSH
89617: LD_INT 0
89619: ST_TO_ADDR
// for i := 1 to 16 do
89620: LD_ADDR_VAR 0 2
89624: PUSH
89625: DOUBLE
89626: LD_INT 1
89628: DEC
89629: ST_TO_ADDR
89630: LD_INT 16
89632: PUSH
89633: FOR_TO
89634: IFFALSE 89833
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89636: LD_ADDR_VAR 0 3
89640: PUSH
89641: LD_INT 10
89643: PUSH
89644: LD_INT 20
89646: PUSH
89647: LD_INT 30
89649: PUSH
89650: LD_INT 40
89652: PUSH
89653: LD_INT 50
89655: PUSH
89656: LD_INT 60
89658: PUSH
89659: LD_INT 70
89661: PUSH
89662: LD_INT 80
89664: PUSH
89665: LD_INT 90
89667: PUSH
89668: LD_INT 100
89670: PUSH
89671: LD_INT 110
89673: PUSH
89674: LD_INT 120
89676: PUSH
89677: LD_INT 130
89679: PUSH
89680: LD_INT 140
89682: PUSH
89683: LD_INT 150
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 1
89705: PPUSH
89706: LD_INT 15
89708: PPUSH
89709: CALL_OW 12
89713: ARRAY
89714: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89715: LD_ADDR_VAR 0 4
89719: PUSH
89720: LD_INT 10
89722: PUSH
89723: LD_INT 20
89725: PUSH
89726: LD_INT 30
89728: PUSH
89729: LD_INT 40
89731: PUSH
89732: LD_INT 50
89734: PUSH
89735: LD_INT 60
89737: PUSH
89738: LD_INT 70
89740: PUSH
89741: LD_INT 80
89743: PUSH
89744: LD_INT 90
89746: PUSH
89747: LD_INT 100
89749: PUSH
89750: LD_INT 110
89752: PUSH
89753: LD_INT 120
89755: PUSH
89756: LD_INT 130
89758: PUSH
89759: LD_INT 140
89761: PUSH
89762: LD_INT 150
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 1
89784: PPUSH
89785: LD_INT 15
89787: PPUSH
89788: CALL_OW 12
89792: ARRAY
89793: ST_TO_ADDR
// if ValidHex ( x , y ) then
89794: LD_VAR 0 3
89798: PPUSH
89799: LD_VAR 0 4
89803: PPUSH
89804: CALL_OW 488
89808: IFFALSE 89831
// begin result := [ x , y ] ;
89810: LD_ADDR_VAR 0 1
89814: PUSH
89815: LD_VAR 0 3
89819: PUSH
89820: LD_VAR 0 4
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: ST_TO_ADDR
// break ;
89829: GO 89833
// end ; end ;
89831: GO 89633
89833: POP
89834: POP
// if result then
89835: LD_VAR 0 1
89839: IFFALSE 89899
// begin ToLua ( playSibBomb() ) ;
89841: LD_STRING playSibBomb()
89843: PPUSH
89844: CALL_OW 559
// wait ( 0 0$14 ) ;
89848: LD_INT 490
89850: PPUSH
89851: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89855: LD_VAR 0 1
89859: PUSH
89860: LD_INT 1
89862: ARRAY
89863: PPUSH
89864: LD_VAR 0 1
89868: PUSH
89869: LD_INT 2
89871: ARRAY
89872: PPUSH
89873: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89877: LD_VAR 0 1
89881: PUSH
89882: LD_INT 1
89884: ARRAY
89885: PPUSH
89886: LD_VAR 0 1
89890: PUSH
89891: LD_INT 2
89893: ARRAY
89894: PPUSH
89895: CALL_OW 429
// end ; end ;
89899: LD_VAR 0 1
89903: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89904: LD_EXP 122
89908: PUSH
89909: LD_EXP 144
89913: AND
89914: IFFALSE 89926
89916: GO 89918
89918: DISABLE
// YouLost (  ) ;
89919: LD_STRING 
89921: PPUSH
89922: CALL_OW 104
89926: END
// every 0 0$1 trigger StreamModeActive and sFog do
89927: LD_EXP 122
89931: PUSH
89932: LD_EXP 143
89936: AND
89937: IFFALSE 89951
89939: GO 89941
89941: DISABLE
// FogOff ( your_side ) ;
89942: LD_OWVAR 2
89946: PPUSH
89947: CALL_OW 344
89951: END
// every 0 0$1 trigger StreamModeActive and sSun do
89952: LD_EXP 122
89956: PUSH
89957: LD_EXP 145
89961: AND
89962: IFFALSE 89990
89964: GO 89966
89966: DISABLE
// begin solar_recharge_percent := 0 ;
89967: LD_ADDR_OWVAR 79
89971: PUSH
89972: LD_INT 0
89974: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89975: LD_INT 10500
89977: PPUSH
89978: CALL_OW 67
// solar_recharge_percent := 100 ;
89982: LD_ADDR_OWVAR 79
89986: PUSH
89987: LD_INT 100
89989: ST_TO_ADDR
// end ;
89990: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
89991: LD_EXP 122
89995: PUSH
89996: LD_EXP 146
90000: AND
90001: IFFALSE 90240
90003: GO 90005
90005: DISABLE
90006: LD_INT 0
90008: PPUSH
90009: PPUSH
90010: PPUSH
// begin tmp := [ ] ;
90011: LD_ADDR_VAR 0 3
90015: PUSH
90016: EMPTY
90017: ST_TO_ADDR
// for i := 1 to 6 do
90018: LD_ADDR_VAR 0 1
90022: PUSH
90023: DOUBLE
90024: LD_INT 1
90026: DEC
90027: ST_TO_ADDR
90028: LD_INT 6
90030: PUSH
90031: FOR_TO
90032: IFFALSE 90137
// begin uc_nation := nation_nature ;
90034: LD_ADDR_OWVAR 21
90038: PUSH
90039: LD_INT 0
90041: ST_TO_ADDR
// uc_side := 0 ;
90042: LD_ADDR_OWVAR 20
90046: PUSH
90047: LD_INT 0
90049: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90050: LD_ADDR_OWVAR 29
90054: PUSH
90055: LD_INT 12
90057: PUSH
90058: LD_INT 12
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: ST_TO_ADDR
// hc_agressivity := 20 ;
90065: LD_ADDR_OWVAR 35
90069: PUSH
90070: LD_INT 20
90072: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90073: LD_ADDR_OWVAR 28
90077: PUSH
90078: LD_INT 17
90080: ST_TO_ADDR
// hc_gallery :=  ;
90081: LD_ADDR_OWVAR 33
90085: PUSH
90086: LD_STRING 
90088: ST_TO_ADDR
// hc_name :=  ;
90089: LD_ADDR_OWVAR 26
90093: PUSH
90094: LD_STRING 
90096: ST_TO_ADDR
// un := CreateHuman ;
90097: LD_ADDR_VAR 0 2
90101: PUSH
90102: CALL_OW 44
90106: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90107: LD_VAR 0 2
90111: PPUSH
90112: LD_INT 1
90114: PPUSH
90115: CALL_OW 51
// tmp := tmp ^ un ;
90119: LD_ADDR_VAR 0 3
90123: PUSH
90124: LD_VAR 0 3
90128: PUSH
90129: LD_VAR 0 2
90133: ADD
90134: ST_TO_ADDR
// end ;
90135: GO 90031
90137: POP
90138: POP
// repeat wait ( 0 0$1 ) ;
90139: LD_INT 35
90141: PPUSH
90142: CALL_OW 67
// for un in tmp do
90146: LD_ADDR_VAR 0 2
90150: PUSH
90151: LD_VAR 0 3
90155: PUSH
90156: FOR_IN
90157: IFFALSE 90231
// begin if IsDead ( un ) then
90159: LD_VAR 0 2
90163: PPUSH
90164: CALL_OW 301
90168: IFFALSE 90188
// begin tmp := tmp diff un ;
90170: LD_ADDR_VAR 0 3
90174: PUSH
90175: LD_VAR 0 3
90179: PUSH
90180: LD_VAR 0 2
90184: DIFF
90185: ST_TO_ADDR
// continue ;
90186: GO 90156
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90188: LD_VAR 0 2
90192: PPUSH
90193: LD_INT 3
90195: PUSH
90196: LD_INT 22
90198: PUSH
90199: LD_INT 0
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PPUSH
90210: CALL_OW 69
90214: PPUSH
90215: LD_VAR 0 2
90219: PPUSH
90220: CALL_OW 74
90224: PPUSH
90225: CALL_OW 115
// end ;
90229: GO 90156
90231: POP
90232: POP
// until not tmp ;
90233: LD_VAR 0 3
90237: NOT
90238: IFFALSE 90139
// end ;
90240: PPOPN 3
90242: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90243: LD_EXP 122
90247: PUSH
90248: LD_EXP 147
90252: AND
90253: IFFALSE 90307
90255: GO 90257
90257: DISABLE
// begin ToLua ( displayTroll(); ) ;
90258: LD_STRING displayTroll();
90260: PPUSH
90261: CALL_OW 559
// wait ( 3 3$00 ) ;
90265: LD_INT 6300
90267: PPUSH
90268: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90272: LD_STRING hideTroll();
90274: PPUSH
90275: CALL_OW 559
// wait ( 1 1$00 ) ;
90279: LD_INT 2100
90281: PPUSH
90282: CALL_OW 67
// ToLua ( displayTroll(); ) ;
90286: LD_STRING displayTroll();
90288: PPUSH
90289: CALL_OW 559
// wait ( 1 1$00 ) ;
90293: LD_INT 2100
90295: PPUSH
90296: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90300: LD_STRING hideTroll();
90302: PPUSH
90303: CALL_OW 559
// end ;
90307: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
90308: LD_EXP 122
90312: PUSH
90313: LD_EXP 148
90317: AND
90318: IFFALSE 90381
90320: GO 90322
90322: DISABLE
90323: LD_INT 0
90325: PPUSH
// begin p := 0 ;
90326: LD_ADDR_VAR 0 1
90330: PUSH
90331: LD_INT 0
90333: ST_TO_ADDR
// repeat game_speed := 1 ;
90334: LD_ADDR_OWVAR 65
90338: PUSH
90339: LD_INT 1
90341: ST_TO_ADDR
// wait ( 0 0$1 ) ;
90342: LD_INT 35
90344: PPUSH
90345: CALL_OW 67
// p := p + 1 ;
90349: LD_ADDR_VAR 0 1
90353: PUSH
90354: LD_VAR 0 1
90358: PUSH
90359: LD_INT 1
90361: PLUS
90362: ST_TO_ADDR
// until p >= 60 ;
90363: LD_VAR 0 1
90367: PUSH
90368: LD_INT 60
90370: GREATEREQUAL
90371: IFFALSE 90334
// game_speed := 4 ;
90373: LD_ADDR_OWVAR 65
90377: PUSH
90378: LD_INT 4
90380: ST_TO_ADDR
// end ;
90381: PPOPN 1
90383: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90384: LD_EXP 122
90388: PUSH
90389: LD_EXP 149
90393: AND
90394: IFFALSE 90540
90396: GO 90398
90398: DISABLE
90399: LD_INT 0
90401: PPUSH
90402: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90403: LD_ADDR_VAR 0 1
90407: PUSH
90408: LD_INT 22
90410: PUSH
90411: LD_OWVAR 2
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 2
90422: PUSH
90423: LD_INT 30
90425: PUSH
90426: LD_INT 0
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 30
90435: PUSH
90436: LD_INT 1
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: LIST
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PPUSH
90452: CALL_OW 69
90456: ST_TO_ADDR
// if not depot then
90457: LD_VAR 0 1
90461: NOT
90462: IFFALSE 90466
// exit ;
90464: GO 90540
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90466: LD_ADDR_VAR 0 2
90470: PUSH
90471: LD_VAR 0 1
90475: PUSH
90476: LD_INT 1
90478: PPUSH
90479: LD_VAR 0 1
90483: PPUSH
90484: CALL_OW 12
90488: ARRAY
90489: PPUSH
90490: CALL_OW 274
90494: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90495: LD_VAR 0 2
90499: PPUSH
90500: LD_INT 1
90502: PPUSH
90503: LD_INT 0
90505: PPUSH
90506: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90510: LD_VAR 0 2
90514: PPUSH
90515: LD_INT 2
90517: PPUSH
90518: LD_INT 0
90520: PPUSH
90521: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90525: LD_VAR 0 2
90529: PPUSH
90530: LD_INT 3
90532: PPUSH
90533: LD_INT 0
90535: PPUSH
90536: CALL_OW 277
// end ;
90540: PPOPN 2
90542: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90543: LD_EXP 122
90547: PUSH
90548: LD_EXP 150
90552: AND
90553: IFFALSE 90650
90555: GO 90557
90557: DISABLE
90558: LD_INT 0
90560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90561: LD_ADDR_VAR 0 1
90565: PUSH
90566: LD_INT 22
90568: PUSH
90569: LD_OWVAR 2
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 21
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 3
90590: PUSH
90591: LD_INT 23
90593: PUSH
90594: LD_INT 0
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: LIST
90609: PPUSH
90610: CALL_OW 69
90614: ST_TO_ADDR
// if not tmp then
90615: LD_VAR 0 1
90619: NOT
90620: IFFALSE 90624
// exit ;
90622: GO 90650
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90624: LD_VAR 0 1
90628: PUSH
90629: LD_INT 1
90631: PPUSH
90632: LD_VAR 0 1
90636: PPUSH
90637: CALL_OW 12
90641: ARRAY
90642: PPUSH
90643: LD_INT 200
90645: PPUSH
90646: CALL_OW 234
// end ;
90650: PPOPN 1
90652: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90653: LD_EXP 122
90657: PUSH
90658: LD_EXP 151
90662: AND
90663: IFFALSE 90742
90665: GO 90667
90667: DISABLE
90668: LD_INT 0
90670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90671: LD_ADDR_VAR 0 1
90675: PUSH
90676: LD_INT 22
90678: PUSH
90679: LD_OWVAR 2
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 21
90690: PUSH
90691: LD_INT 2
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: PPUSH
90702: CALL_OW 69
90706: ST_TO_ADDR
// if not tmp then
90707: LD_VAR 0 1
90711: NOT
90712: IFFALSE 90716
// exit ;
90714: GO 90742
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90716: LD_VAR 0 1
90720: PUSH
90721: LD_INT 1
90723: PPUSH
90724: LD_VAR 0 1
90728: PPUSH
90729: CALL_OW 12
90733: ARRAY
90734: PPUSH
90735: LD_INT 60
90737: PPUSH
90738: CALL_OW 234
// end ;
90742: PPOPN 1
90744: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90745: LD_EXP 122
90749: PUSH
90750: LD_EXP 152
90754: AND
90755: IFFALSE 90854
90757: GO 90759
90759: DISABLE
90760: LD_INT 0
90762: PPUSH
90763: PPUSH
// begin enable ;
90764: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90765: LD_ADDR_VAR 0 1
90769: PUSH
90770: LD_INT 22
90772: PUSH
90773: LD_OWVAR 2
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 61
90784: PUSH
90785: EMPTY
90786: LIST
90787: PUSH
90788: LD_INT 33
90790: PUSH
90791: LD_INT 2
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: LIST
90802: PPUSH
90803: CALL_OW 69
90807: ST_TO_ADDR
// if not tmp then
90808: LD_VAR 0 1
90812: NOT
90813: IFFALSE 90817
// exit ;
90815: GO 90854
// for i in tmp do
90817: LD_ADDR_VAR 0 2
90821: PUSH
90822: LD_VAR 0 1
90826: PUSH
90827: FOR_IN
90828: IFFALSE 90852
// if IsControledBy ( i ) then
90830: LD_VAR 0 2
90834: PPUSH
90835: CALL_OW 312
90839: IFFALSE 90850
// ComUnlink ( i ) ;
90841: LD_VAR 0 2
90845: PPUSH
90846: CALL_OW 136
90850: GO 90827
90852: POP
90853: POP
// end ;
90854: PPOPN 2
90856: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90857: LD_EXP 122
90861: PUSH
90862: LD_EXP 153
90866: AND
90867: IFFALSE 91007
90869: GO 90871
90871: DISABLE
90872: LD_INT 0
90874: PPUSH
90875: PPUSH
// begin ToLua ( displayPowell(); ) ;
90876: LD_STRING displayPowell();
90878: PPUSH
90879: CALL_OW 559
// uc_side := 0 ;
90883: LD_ADDR_OWVAR 20
90887: PUSH
90888: LD_INT 0
90890: ST_TO_ADDR
// uc_nation := 2 ;
90891: LD_ADDR_OWVAR 21
90895: PUSH
90896: LD_INT 2
90898: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90899: LD_ADDR_OWVAR 37
90903: PUSH
90904: LD_INT 14
90906: ST_TO_ADDR
// vc_engine := engine_siberite ;
90907: LD_ADDR_OWVAR 39
90911: PUSH
90912: LD_INT 3
90914: ST_TO_ADDR
// vc_control := control_apeman ;
90915: LD_ADDR_OWVAR 38
90919: PUSH
90920: LD_INT 5
90922: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90923: LD_ADDR_OWVAR 40
90927: PUSH
90928: LD_INT 29
90930: ST_TO_ADDR
// un := CreateVehicle ;
90931: LD_ADDR_VAR 0 2
90935: PUSH
90936: CALL_OW 45
90940: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90941: LD_VAR 0 2
90945: PPUSH
90946: LD_INT 1
90948: PPUSH
90949: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90953: LD_INT 35
90955: PPUSH
90956: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90960: LD_VAR 0 2
90964: PPUSH
90965: LD_INT 22
90967: PUSH
90968: LD_OWVAR 2
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PPUSH
90977: CALL_OW 69
90981: PPUSH
90982: LD_VAR 0 2
90986: PPUSH
90987: CALL_OW 74
90991: PPUSH
90992: CALL_OW 115
// until IsDead ( un ) ;
90996: LD_VAR 0 2
91000: PPUSH
91001: CALL_OW 301
91005: IFFALSE 90953
// end ;
91007: PPOPN 2
91009: END
// every 0 0$1 trigger StreamModeActive and sStu do
91010: LD_EXP 122
91014: PUSH
91015: LD_EXP 161
91019: AND
91020: IFFALSE 91036
91022: GO 91024
91024: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91025: LD_STRING displayStucuk();
91027: PPUSH
91028: CALL_OW 559
// ResetFog ;
91032: CALL_OW 335
// end ;
91036: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91037: LD_EXP 122
91041: PUSH
91042: LD_EXP 154
91046: AND
91047: IFFALSE 91188
91049: GO 91051
91051: DISABLE
91052: LD_INT 0
91054: PPUSH
91055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91056: LD_ADDR_VAR 0 2
91060: PUSH
91061: LD_INT 22
91063: PUSH
91064: LD_OWVAR 2
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 21
91075: PUSH
91076: LD_INT 1
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PPUSH
91087: CALL_OW 69
91091: ST_TO_ADDR
// if not tmp then
91092: LD_VAR 0 2
91096: NOT
91097: IFFALSE 91101
// exit ;
91099: GO 91188
// un := tmp [ rand ( 1 , tmp ) ] ;
91101: LD_ADDR_VAR 0 1
91105: PUSH
91106: LD_VAR 0 2
91110: PUSH
91111: LD_INT 1
91113: PPUSH
91114: LD_VAR 0 2
91118: PPUSH
91119: CALL_OW 12
91123: ARRAY
91124: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91125: LD_VAR 0 1
91129: PPUSH
91130: LD_INT 0
91132: PPUSH
91133: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91137: LD_VAR 0 1
91141: PPUSH
91142: LD_OWVAR 3
91146: PUSH
91147: LD_VAR 0 1
91151: DIFF
91152: PPUSH
91153: LD_VAR 0 1
91157: PPUSH
91158: CALL_OW 74
91162: PPUSH
91163: CALL_OW 115
// wait ( 0 0$20 ) ;
91167: LD_INT 700
91169: PPUSH
91170: CALL_OW 67
// SetSide ( un , your_side ) ;
91174: LD_VAR 0 1
91178: PPUSH
91179: LD_OWVAR 2
91183: PPUSH
91184: CALL_OW 235
// end ;
91188: PPOPN 2
91190: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91191: LD_EXP 122
91195: PUSH
91196: LD_EXP 155
91200: AND
91201: IFFALSE 91307
91203: GO 91205
91205: DISABLE
91206: LD_INT 0
91208: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91209: LD_ADDR_VAR 0 1
91213: PUSH
91214: LD_INT 22
91216: PUSH
91217: LD_OWVAR 2
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 2
91228: PUSH
91229: LD_INT 30
91231: PUSH
91232: LD_INT 0
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 30
91241: PUSH
91242: LD_INT 1
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: LIST
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PPUSH
91258: CALL_OW 69
91262: ST_TO_ADDR
// if not depot then
91263: LD_VAR 0 1
91267: NOT
91268: IFFALSE 91272
// exit ;
91270: GO 91307
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
91272: LD_VAR 0 1
91276: PUSH
91277: LD_INT 1
91279: ARRAY
91280: PPUSH
91281: CALL_OW 250
91285: PPUSH
91286: LD_VAR 0 1
91290: PUSH
91291: LD_INT 1
91293: ARRAY
91294: PPUSH
91295: CALL_OW 251
91299: PPUSH
91300: LD_INT 70
91302: PPUSH
91303: CALL_OW 495
// end ;
91307: PPOPN 1
91309: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
91310: LD_EXP 122
91314: PUSH
91315: LD_EXP 156
91319: AND
91320: IFFALSE 91531
91322: GO 91324
91324: DISABLE
91325: LD_INT 0
91327: PPUSH
91328: PPUSH
91329: PPUSH
91330: PPUSH
91331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91332: LD_ADDR_VAR 0 5
91336: PUSH
91337: LD_INT 22
91339: PUSH
91340: LD_OWVAR 2
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 21
91351: PUSH
91352: LD_INT 1
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PPUSH
91363: CALL_OW 69
91367: ST_TO_ADDR
// if not tmp then
91368: LD_VAR 0 5
91372: NOT
91373: IFFALSE 91377
// exit ;
91375: GO 91531
// for i in tmp do
91377: LD_ADDR_VAR 0 1
91381: PUSH
91382: LD_VAR 0 5
91386: PUSH
91387: FOR_IN
91388: IFFALSE 91529
// begin d := rand ( 0 , 5 ) ;
91390: LD_ADDR_VAR 0 4
91394: PUSH
91395: LD_INT 0
91397: PPUSH
91398: LD_INT 5
91400: PPUSH
91401: CALL_OW 12
91405: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91406: LD_ADDR_VAR 0 2
91410: PUSH
91411: LD_VAR 0 1
91415: PPUSH
91416: CALL_OW 250
91420: PPUSH
91421: LD_VAR 0 4
91425: PPUSH
91426: LD_INT 3
91428: PPUSH
91429: LD_INT 12
91431: PPUSH
91432: CALL_OW 12
91436: PPUSH
91437: CALL_OW 272
91441: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91442: LD_ADDR_VAR 0 3
91446: PUSH
91447: LD_VAR 0 1
91451: PPUSH
91452: CALL_OW 251
91456: PPUSH
91457: LD_VAR 0 4
91461: PPUSH
91462: LD_INT 3
91464: PPUSH
91465: LD_INT 12
91467: PPUSH
91468: CALL_OW 12
91472: PPUSH
91473: CALL_OW 273
91477: ST_TO_ADDR
// if ValidHex ( x , y ) then
91478: LD_VAR 0 2
91482: PPUSH
91483: LD_VAR 0 3
91487: PPUSH
91488: CALL_OW 488
91492: IFFALSE 91527
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91494: LD_VAR 0 1
91498: PPUSH
91499: LD_VAR 0 2
91503: PPUSH
91504: LD_VAR 0 3
91508: PPUSH
91509: LD_INT 3
91511: PPUSH
91512: LD_INT 6
91514: PPUSH
91515: CALL_OW 12
91519: PPUSH
91520: LD_INT 1
91522: PPUSH
91523: CALL_OW 483
// end ;
91527: GO 91387
91529: POP
91530: POP
// end ;
91531: PPOPN 5
91533: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91534: LD_EXP 122
91538: PUSH
91539: LD_EXP 157
91543: AND
91544: IFFALSE 91638
91546: GO 91548
91548: DISABLE
91549: LD_INT 0
91551: PPUSH
91552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91553: LD_ADDR_VAR 0 2
91557: PUSH
91558: LD_INT 22
91560: PUSH
91561: LD_OWVAR 2
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 32
91572: PUSH
91573: LD_INT 1
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PUSH
91580: LD_INT 21
91582: PUSH
91583: LD_INT 2
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: LIST
91594: PPUSH
91595: CALL_OW 69
91599: ST_TO_ADDR
// if not tmp then
91600: LD_VAR 0 2
91604: NOT
91605: IFFALSE 91609
// exit ;
91607: GO 91638
// for i in tmp do
91609: LD_ADDR_VAR 0 1
91613: PUSH
91614: LD_VAR 0 2
91618: PUSH
91619: FOR_IN
91620: IFFALSE 91636
// SetFuel ( i , 0 ) ;
91622: LD_VAR 0 1
91626: PPUSH
91627: LD_INT 0
91629: PPUSH
91630: CALL_OW 240
91634: GO 91619
91636: POP
91637: POP
// end ;
91638: PPOPN 2
91640: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91641: LD_EXP 122
91645: PUSH
91646: LD_EXP 158
91650: AND
91651: IFFALSE 91717
91653: GO 91655
91655: DISABLE
91656: LD_INT 0
91658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91659: LD_ADDR_VAR 0 1
91663: PUSH
91664: LD_INT 22
91666: PUSH
91667: LD_OWVAR 2
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 30
91678: PUSH
91679: LD_INT 29
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PPUSH
91690: CALL_OW 69
91694: ST_TO_ADDR
// if not tmp then
91695: LD_VAR 0 1
91699: NOT
91700: IFFALSE 91704
// exit ;
91702: GO 91717
// DestroyUnit ( tmp [ 1 ] ) ;
91704: LD_VAR 0 1
91708: PUSH
91709: LD_INT 1
91711: ARRAY
91712: PPUSH
91713: CALL_OW 65
// end ;
91717: PPOPN 1
91719: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91720: LD_EXP 122
91724: PUSH
91725: LD_EXP 160
91729: AND
91730: IFFALSE 91859
91732: GO 91734
91734: DISABLE
91735: LD_INT 0
91737: PPUSH
// begin uc_side := 0 ;
91738: LD_ADDR_OWVAR 20
91742: PUSH
91743: LD_INT 0
91745: ST_TO_ADDR
// uc_nation := nation_arabian ;
91746: LD_ADDR_OWVAR 21
91750: PUSH
91751: LD_INT 2
91753: ST_TO_ADDR
// hc_gallery :=  ;
91754: LD_ADDR_OWVAR 33
91758: PUSH
91759: LD_STRING 
91761: ST_TO_ADDR
// hc_name :=  ;
91762: LD_ADDR_OWVAR 26
91766: PUSH
91767: LD_STRING 
91769: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91770: LD_INT 1
91772: PPUSH
91773: LD_INT 11
91775: PPUSH
91776: LD_INT 10
91778: PPUSH
91779: CALL_OW 380
// un := CreateHuman ;
91783: LD_ADDR_VAR 0 1
91787: PUSH
91788: CALL_OW 44
91792: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91793: LD_VAR 0 1
91797: PPUSH
91798: LD_INT 1
91800: PPUSH
91801: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91805: LD_INT 35
91807: PPUSH
91808: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91812: LD_VAR 0 1
91816: PPUSH
91817: LD_INT 22
91819: PUSH
91820: LD_OWVAR 2
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PPUSH
91829: CALL_OW 69
91833: PPUSH
91834: LD_VAR 0 1
91838: PPUSH
91839: CALL_OW 74
91843: PPUSH
91844: CALL_OW 115
// until IsDead ( un ) ;
91848: LD_VAR 0 1
91852: PPUSH
91853: CALL_OW 301
91857: IFFALSE 91805
// end ;
91859: PPOPN 1
91861: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91862: LD_EXP 122
91866: PUSH
91867: LD_EXP 162
91871: AND
91872: IFFALSE 91884
91874: GO 91876
91876: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91877: LD_STRING earthquake(getX(game), 0, 32)
91879: PPUSH
91880: CALL_OW 559
91884: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91885: LD_EXP 122
91889: PUSH
91890: LD_EXP 163
91894: AND
91895: IFFALSE 91986
91897: GO 91899
91899: DISABLE
91900: LD_INT 0
91902: PPUSH
// begin enable ;
91903: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91904: LD_ADDR_VAR 0 1
91908: PUSH
91909: LD_INT 22
91911: PUSH
91912: LD_OWVAR 2
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 21
91923: PUSH
91924: LD_INT 2
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 33
91933: PUSH
91934: LD_INT 3
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: PPUSH
91946: CALL_OW 69
91950: ST_TO_ADDR
// if not tmp then
91951: LD_VAR 0 1
91955: NOT
91956: IFFALSE 91960
// exit ;
91958: GO 91986
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91960: LD_VAR 0 1
91964: PUSH
91965: LD_INT 1
91967: PPUSH
91968: LD_VAR 0 1
91972: PPUSH
91973: CALL_OW 12
91977: ARRAY
91978: PPUSH
91979: LD_INT 1
91981: PPUSH
91982: CALL_OW 234
// end ;
91986: PPOPN 1
91988: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
91989: LD_EXP 122
91993: PUSH
91994: LD_EXP 164
91998: AND
91999: IFFALSE 92140
92001: GO 92003
92003: DISABLE
92004: LD_INT 0
92006: PPUSH
92007: PPUSH
92008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92009: LD_ADDR_VAR 0 3
92013: PUSH
92014: LD_INT 22
92016: PUSH
92017: LD_OWVAR 2
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 25
92028: PUSH
92029: LD_INT 1
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PPUSH
92040: CALL_OW 69
92044: ST_TO_ADDR
// if not tmp then
92045: LD_VAR 0 3
92049: NOT
92050: IFFALSE 92054
// exit ;
92052: GO 92140
// un := tmp [ rand ( 1 , tmp ) ] ;
92054: LD_ADDR_VAR 0 2
92058: PUSH
92059: LD_VAR 0 3
92063: PUSH
92064: LD_INT 1
92066: PPUSH
92067: LD_VAR 0 3
92071: PPUSH
92072: CALL_OW 12
92076: ARRAY
92077: ST_TO_ADDR
// if Crawls ( un ) then
92078: LD_VAR 0 2
92082: PPUSH
92083: CALL_OW 318
92087: IFFALSE 92098
// ComWalk ( un ) ;
92089: LD_VAR 0 2
92093: PPUSH
92094: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92098: LD_VAR 0 2
92102: PPUSH
92103: LD_INT 9
92105: PPUSH
92106: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92110: LD_INT 28
92112: PPUSH
92113: LD_OWVAR 2
92117: PPUSH
92118: LD_INT 2
92120: PPUSH
92121: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92125: LD_INT 29
92127: PPUSH
92128: LD_OWVAR 2
92132: PPUSH
92133: LD_INT 2
92135: PPUSH
92136: CALL_OW 322
// end ;
92140: PPOPN 3
92142: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92143: LD_EXP 122
92147: PUSH
92148: LD_EXP 165
92152: AND
92153: IFFALSE 92264
92155: GO 92157
92157: DISABLE
92158: LD_INT 0
92160: PPUSH
92161: PPUSH
92162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92163: LD_ADDR_VAR 0 3
92167: PUSH
92168: LD_INT 22
92170: PUSH
92171: LD_OWVAR 2
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 25
92182: PUSH
92183: LD_INT 1
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PPUSH
92194: CALL_OW 69
92198: ST_TO_ADDR
// if not tmp then
92199: LD_VAR 0 3
92203: NOT
92204: IFFALSE 92208
// exit ;
92206: GO 92264
// un := tmp [ rand ( 1 , tmp ) ] ;
92208: LD_ADDR_VAR 0 2
92212: PUSH
92213: LD_VAR 0 3
92217: PUSH
92218: LD_INT 1
92220: PPUSH
92221: LD_VAR 0 3
92225: PPUSH
92226: CALL_OW 12
92230: ARRAY
92231: ST_TO_ADDR
// if Crawls ( un ) then
92232: LD_VAR 0 2
92236: PPUSH
92237: CALL_OW 318
92241: IFFALSE 92252
// ComWalk ( un ) ;
92243: LD_VAR 0 2
92247: PPUSH
92248: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92252: LD_VAR 0 2
92256: PPUSH
92257: LD_INT 8
92259: PPUSH
92260: CALL_OW 336
// end ;
92264: PPOPN 3
92266: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
92267: LD_EXP 122
92271: PUSH
92272: LD_EXP 166
92276: AND
92277: IFFALSE 92421
92279: GO 92281
92281: DISABLE
92282: LD_INT 0
92284: PPUSH
92285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
92286: LD_ADDR_VAR 0 2
92290: PUSH
92291: LD_INT 22
92293: PUSH
92294: LD_OWVAR 2
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 21
92305: PUSH
92306: LD_INT 2
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PUSH
92313: LD_INT 2
92315: PUSH
92316: LD_INT 34
92318: PUSH
92319: LD_INT 12
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 34
92328: PUSH
92329: LD_INT 51
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 34
92338: PUSH
92339: LD_INT 32
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: LIST
92356: PPUSH
92357: CALL_OW 69
92361: ST_TO_ADDR
// if not tmp then
92362: LD_VAR 0 2
92366: NOT
92367: IFFALSE 92371
// exit ;
92369: GO 92421
// for i in tmp do
92371: LD_ADDR_VAR 0 1
92375: PUSH
92376: LD_VAR 0 2
92380: PUSH
92381: FOR_IN
92382: IFFALSE 92419
// if GetCargo ( i , mat_artifact ) = 0 then
92384: LD_VAR 0 1
92388: PPUSH
92389: LD_INT 4
92391: PPUSH
92392: CALL_OW 289
92396: PUSH
92397: LD_INT 0
92399: EQUAL
92400: IFFALSE 92417
// SetCargo ( i , mat_siberit , 100 ) ;
92402: LD_VAR 0 1
92406: PPUSH
92407: LD_INT 3
92409: PPUSH
92410: LD_INT 100
92412: PPUSH
92413: CALL_OW 290
92417: GO 92381
92419: POP
92420: POP
// end ;
92421: PPOPN 2
92423: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92424: LD_EXP 122
92428: PUSH
92429: LD_EXP 167
92433: AND
92434: IFFALSE 92617
92436: GO 92438
92438: DISABLE
92439: LD_INT 0
92441: PPUSH
92442: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92443: LD_ADDR_VAR 0 2
92447: PUSH
92448: LD_INT 22
92450: PUSH
92451: LD_OWVAR 2
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PPUSH
92460: CALL_OW 69
92464: ST_TO_ADDR
// if not tmp then
92465: LD_VAR 0 2
92469: NOT
92470: IFFALSE 92474
// exit ;
92472: GO 92617
// for i := 1 to 2 do
92474: LD_ADDR_VAR 0 1
92478: PUSH
92479: DOUBLE
92480: LD_INT 1
92482: DEC
92483: ST_TO_ADDR
92484: LD_INT 2
92486: PUSH
92487: FOR_TO
92488: IFFALSE 92615
// begin uc_side := your_side ;
92490: LD_ADDR_OWVAR 20
92494: PUSH
92495: LD_OWVAR 2
92499: ST_TO_ADDR
// uc_nation := nation_american ;
92500: LD_ADDR_OWVAR 21
92504: PUSH
92505: LD_INT 1
92507: ST_TO_ADDR
// vc_chassis := us_morphling ;
92508: LD_ADDR_OWVAR 37
92512: PUSH
92513: LD_INT 5
92515: ST_TO_ADDR
// vc_engine := engine_siberite ;
92516: LD_ADDR_OWVAR 39
92520: PUSH
92521: LD_INT 3
92523: ST_TO_ADDR
// vc_control := control_computer ;
92524: LD_ADDR_OWVAR 38
92528: PUSH
92529: LD_INT 3
92531: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92532: LD_ADDR_OWVAR 40
92536: PUSH
92537: LD_INT 10
92539: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92540: LD_VAR 0 2
92544: PUSH
92545: LD_INT 1
92547: ARRAY
92548: PPUSH
92549: CALL_OW 310
92553: NOT
92554: IFFALSE 92601
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92556: CALL_OW 45
92560: PPUSH
92561: LD_VAR 0 2
92565: PUSH
92566: LD_INT 1
92568: ARRAY
92569: PPUSH
92570: CALL_OW 250
92574: PPUSH
92575: LD_VAR 0 2
92579: PUSH
92580: LD_INT 1
92582: ARRAY
92583: PPUSH
92584: CALL_OW 251
92588: PPUSH
92589: LD_INT 12
92591: PPUSH
92592: LD_INT 1
92594: PPUSH
92595: CALL_OW 50
92599: GO 92613
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92601: CALL_OW 45
92605: PPUSH
92606: LD_INT 1
92608: PPUSH
92609: CALL_OW 51
// end ;
92613: GO 92487
92615: POP
92616: POP
// end ;
92617: PPOPN 2
92619: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92620: LD_EXP 122
92624: PUSH
92625: LD_EXP 168
92629: AND
92630: IFFALSE 92852
92632: GO 92634
92634: DISABLE
92635: LD_INT 0
92637: PPUSH
92638: PPUSH
92639: PPUSH
92640: PPUSH
92641: PPUSH
92642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92643: LD_ADDR_VAR 0 6
92647: PUSH
92648: LD_INT 22
92650: PUSH
92651: LD_OWVAR 2
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 21
92662: PUSH
92663: LD_INT 1
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 3
92672: PUSH
92673: LD_INT 23
92675: PUSH
92676: LD_INT 0
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: LIST
92691: PPUSH
92692: CALL_OW 69
92696: ST_TO_ADDR
// if not tmp then
92697: LD_VAR 0 6
92701: NOT
92702: IFFALSE 92706
// exit ;
92704: GO 92852
// s1 := rand ( 1 , 4 ) ;
92706: LD_ADDR_VAR 0 2
92710: PUSH
92711: LD_INT 1
92713: PPUSH
92714: LD_INT 4
92716: PPUSH
92717: CALL_OW 12
92721: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92722: LD_ADDR_VAR 0 4
92726: PUSH
92727: LD_VAR 0 6
92731: PUSH
92732: LD_INT 1
92734: ARRAY
92735: PPUSH
92736: LD_VAR 0 2
92740: PPUSH
92741: CALL_OW 259
92745: ST_TO_ADDR
// if s1 = 1 then
92746: LD_VAR 0 2
92750: PUSH
92751: LD_INT 1
92753: EQUAL
92754: IFFALSE 92774
// s2 := rand ( 2 , 4 ) else
92756: LD_ADDR_VAR 0 3
92760: PUSH
92761: LD_INT 2
92763: PPUSH
92764: LD_INT 4
92766: PPUSH
92767: CALL_OW 12
92771: ST_TO_ADDR
92772: GO 92782
// s2 := 1 ;
92774: LD_ADDR_VAR 0 3
92778: PUSH
92779: LD_INT 1
92781: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92782: LD_ADDR_VAR 0 5
92786: PUSH
92787: LD_VAR 0 6
92791: PUSH
92792: LD_INT 1
92794: ARRAY
92795: PPUSH
92796: LD_VAR 0 3
92800: PPUSH
92801: CALL_OW 259
92805: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92806: LD_VAR 0 6
92810: PUSH
92811: LD_INT 1
92813: ARRAY
92814: PPUSH
92815: LD_VAR 0 2
92819: PPUSH
92820: LD_VAR 0 5
92824: PPUSH
92825: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92829: LD_VAR 0 6
92833: PUSH
92834: LD_INT 1
92836: ARRAY
92837: PPUSH
92838: LD_VAR 0 3
92842: PPUSH
92843: LD_VAR 0 4
92847: PPUSH
92848: CALL_OW 237
// end ;
92852: PPOPN 6
92854: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92855: LD_EXP 122
92859: PUSH
92860: LD_EXP 169
92864: AND
92865: IFFALSE 92944
92867: GO 92869
92869: DISABLE
92870: LD_INT 0
92872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92873: LD_ADDR_VAR 0 1
92877: PUSH
92878: LD_INT 22
92880: PUSH
92881: LD_OWVAR 2
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 30
92892: PUSH
92893: LD_INT 3
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PPUSH
92904: CALL_OW 69
92908: ST_TO_ADDR
// if not tmp then
92909: LD_VAR 0 1
92913: NOT
92914: IFFALSE 92918
// exit ;
92916: GO 92944
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92918: LD_VAR 0 1
92922: PUSH
92923: LD_INT 1
92925: PPUSH
92926: LD_VAR 0 1
92930: PPUSH
92931: CALL_OW 12
92935: ARRAY
92936: PPUSH
92937: LD_INT 1
92939: PPUSH
92940: CALL_OW 234
// end ;
92944: PPOPN 1
92946: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92947: LD_EXP 122
92951: PUSH
92952: LD_EXP 170
92956: AND
92957: IFFALSE 93069
92959: GO 92961
92961: DISABLE
92962: LD_INT 0
92964: PPUSH
92965: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92966: LD_ADDR_VAR 0 2
92970: PUSH
92971: LD_INT 22
92973: PUSH
92974: LD_OWVAR 2
92978: PUSH
92979: EMPTY
92980: LIST
92981: LIST
92982: PUSH
92983: LD_INT 2
92985: PUSH
92986: LD_INT 30
92988: PUSH
92989: LD_INT 27
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 30
92998: PUSH
92999: LD_INT 26
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 30
93008: PUSH
93009: LD_INT 28
93011: PUSH
93012: EMPTY
93013: LIST
93014: LIST
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PPUSH
93026: CALL_OW 69
93030: ST_TO_ADDR
// if not tmp then
93031: LD_VAR 0 2
93035: NOT
93036: IFFALSE 93040
// exit ;
93038: GO 93069
// for i in tmp do
93040: LD_ADDR_VAR 0 1
93044: PUSH
93045: LD_VAR 0 2
93049: PUSH
93050: FOR_IN
93051: IFFALSE 93067
// SetLives ( i , 1 ) ;
93053: LD_VAR 0 1
93057: PPUSH
93058: LD_INT 1
93060: PPUSH
93061: CALL_OW 234
93065: GO 93050
93067: POP
93068: POP
// end ;
93069: PPOPN 2
93071: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93072: LD_EXP 122
93076: PUSH
93077: LD_EXP 171
93081: AND
93082: IFFALSE 93356
93084: GO 93086
93086: DISABLE
93087: LD_INT 0
93089: PPUSH
93090: PPUSH
93091: PPUSH
// begin i := rand ( 1 , 7 ) ;
93092: LD_ADDR_VAR 0 1
93096: PUSH
93097: LD_INT 1
93099: PPUSH
93100: LD_INT 7
93102: PPUSH
93103: CALL_OW 12
93107: ST_TO_ADDR
// case i of 1 :
93108: LD_VAR 0 1
93112: PUSH
93113: LD_INT 1
93115: DOUBLE
93116: EQUAL
93117: IFTRUE 93121
93119: GO 93131
93121: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93122: LD_STRING earthquake(getX(game), 0, 32)
93124: PPUSH
93125: CALL_OW 559
93129: GO 93356
93131: LD_INT 2
93133: DOUBLE
93134: EQUAL
93135: IFTRUE 93139
93137: GO 93153
93139: POP
// begin ToLua ( displayStucuk(); ) ;
93140: LD_STRING displayStucuk();
93142: PPUSH
93143: CALL_OW 559
// ResetFog ;
93147: CALL_OW 335
// end ; 3 :
93151: GO 93356
93153: LD_INT 3
93155: DOUBLE
93156: EQUAL
93157: IFTRUE 93161
93159: GO 93265
93161: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93162: LD_ADDR_VAR 0 2
93166: PUSH
93167: LD_INT 22
93169: PUSH
93170: LD_OWVAR 2
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 25
93181: PUSH
93182: LD_INT 1
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PPUSH
93193: CALL_OW 69
93197: ST_TO_ADDR
// if not tmp then
93198: LD_VAR 0 2
93202: NOT
93203: IFFALSE 93207
// exit ;
93205: GO 93356
// un := tmp [ rand ( 1 , tmp ) ] ;
93207: LD_ADDR_VAR 0 3
93211: PUSH
93212: LD_VAR 0 2
93216: PUSH
93217: LD_INT 1
93219: PPUSH
93220: LD_VAR 0 2
93224: PPUSH
93225: CALL_OW 12
93229: ARRAY
93230: ST_TO_ADDR
// if Crawls ( un ) then
93231: LD_VAR 0 3
93235: PPUSH
93236: CALL_OW 318
93240: IFFALSE 93251
// ComWalk ( un ) ;
93242: LD_VAR 0 3
93246: PPUSH
93247: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93251: LD_VAR 0 3
93255: PPUSH
93256: LD_INT 8
93258: PPUSH
93259: CALL_OW 336
// end ; 4 :
93263: GO 93356
93265: LD_INT 4
93267: DOUBLE
93268: EQUAL
93269: IFTRUE 93273
93271: GO 93334
93273: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93274: LD_ADDR_VAR 0 2
93278: PUSH
93279: LD_INT 22
93281: PUSH
93282: LD_OWVAR 2
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 30
93293: PUSH
93294: LD_INT 29
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PPUSH
93305: CALL_OW 69
93309: ST_TO_ADDR
// if not tmp then
93310: LD_VAR 0 2
93314: NOT
93315: IFFALSE 93319
// exit ;
93317: GO 93356
// DestroyUnit ( tmp [ 1 ] ) ;
93319: LD_VAR 0 2
93323: PUSH
93324: LD_INT 1
93326: ARRAY
93327: PPUSH
93328: CALL_OW 65
// end ; 5 .. 7 :
93332: GO 93356
93334: LD_INT 5
93336: DOUBLE
93337: GREATEREQUAL
93338: IFFALSE 93346
93340: LD_INT 7
93342: DOUBLE
93343: LESSEQUAL
93344: IFTRUE 93348
93346: GO 93355
93348: POP
// StreamSibBomb ; end ;
93349: CALL 89606 0 0
93353: GO 93356
93355: POP
// end ;
93356: PPOPN 3
93358: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
93359: LD_EXP 122
93363: PUSH
93364: LD_EXP 172
93368: AND
93369: IFFALSE 93525
93371: GO 93373
93373: DISABLE
93374: LD_INT 0
93376: PPUSH
93377: PPUSH
93378: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93379: LD_ADDR_VAR 0 2
93383: PUSH
93384: LD_INT 81
93386: PUSH
93387: LD_OWVAR 2
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 2
93398: PUSH
93399: LD_INT 21
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 21
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: LIST
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PPUSH
93428: CALL_OW 69
93432: ST_TO_ADDR
// if not tmp then
93433: LD_VAR 0 2
93437: NOT
93438: IFFALSE 93442
// exit ;
93440: GO 93525
// p := 0 ;
93442: LD_ADDR_VAR 0 3
93446: PUSH
93447: LD_INT 0
93449: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93450: LD_INT 35
93452: PPUSH
93453: CALL_OW 67
// p := p + 1 ;
93457: LD_ADDR_VAR 0 3
93461: PUSH
93462: LD_VAR 0 3
93466: PUSH
93467: LD_INT 1
93469: PLUS
93470: ST_TO_ADDR
// for i in tmp do
93471: LD_ADDR_VAR 0 1
93475: PUSH
93476: LD_VAR 0 2
93480: PUSH
93481: FOR_IN
93482: IFFALSE 93513
// if GetLives ( i ) < 1000 then
93484: LD_VAR 0 1
93488: PPUSH
93489: CALL_OW 256
93493: PUSH
93494: LD_INT 1000
93496: LESS
93497: IFFALSE 93511
// SetLives ( i , 1000 ) ;
93499: LD_VAR 0 1
93503: PPUSH
93504: LD_INT 1000
93506: PPUSH
93507: CALL_OW 234
93511: GO 93481
93513: POP
93514: POP
// until p > 20 ;
93515: LD_VAR 0 3
93519: PUSH
93520: LD_INT 20
93522: GREATER
93523: IFFALSE 93450
// end ;
93525: PPOPN 3
93527: END
// every 0 0$1 trigger StreamModeActive and sTime do
93528: LD_EXP 122
93532: PUSH
93533: LD_EXP 173
93537: AND
93538: IFFALSE 93573
93540: GO 93542
93542: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93543: LD_INT 28
93545: PPUSH
93546: LD_OWVAR 2
93550: PPUSH
93551: LD_INT 2
93553: PPUSH
93554: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93558: LD_INT 30
93560: PPUSH
93561: LD_OWVAR 2
93565: PPUSH
93566: LD_INT 2
93568: PPUSH
93569: CALL_OW 322
// end ;
93573: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93574: LD_EXP 122
93578: PUSH
93579: LD_EXP 174
93583: AND
93584: IFFALSE 93705
93586: GO 93588
93588: DISABLE
93589: LD_INT 0
93591: PPUSH
93592: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93593: LD_ADDR_VAR 0 2
93597: PUSH
93598: LD_INT 22
93600: PUSH
93601: LD_OWVAR 2
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 21
93612: PUSH
93613: LD_INT 1
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 3
93622: PUSH
93623: LD_INT 23
93625: PUSH
93626: LD_INT 0
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: LIST
93641: PPUSH
93642: CALL_OW 69
93646: ST_TO_ADDR
// if not tmp then
93647: LD_VAR 0 2
93651: NOT
93652: IFFALSE 93656
// exit ;
93654: GO 93705
// for i in tmp do
93656: LD_ADDR_VAR 0 1
93660: PUSH
93661: LD_VAR 0 2
93665: PUSH
93666: FOR_IN
93667: IFFALSE 93703
// begin if Crawls ( i ) then
93669: LD_VAR 0 1
93673: PPUSH
93674: CALL_OW 318
93678: IFFALSE 93689
// ComWalk ( i ) ;
93680: LD_VAR 0 1
93684: PPUSH
93685: CALL_OW 138
// SetClass ( i , 2 ) ;
93689: LD_VAR 0 1
93693: PPUSH
93694: LD_INT 2
93696: PPUSH
93697: CALL_OW 336
// end ;
93701: GO 93666
93703: POP
93704: POP
// end ;
93705: PPOPN 2
93707: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93708: LD_EXP 122
93712: PUSH
93713: LD_EXP 175
93717: AND
93718: IFFALSE 93999
93720: GO 93722
93722: DISABLE
93723: LD_INT 0
93725: PPUSH
93726: PPUSH
93727: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93728: LD_OWVAR 2
93732: PPUSH
93733: LD_INT 9
93735: PPUSH
93736: LD_INT 1
93738: PPUSH
93739: LD_INT 1
93741: PPUSH
93742: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93746: LD_INT 9
93748: PPUSH
93749: LD_OWVAR 2
93753: PPUSH
93754: CALL_OW 343
// uc_side := 9 ;
93758: LD_ADDR_OWVAR 20
93762: PUSH
93763: LD_INT 9
93765: ST_TO_ADDR
// uc_nation := 2 ;
93766: LD_ADDR_OWVAR 21
93770: PUSH
93771: LD_INT 2
93773: ST_TO_ADDR
// hc_name := Dark Warrior ;
93774: LD_ADDR_OWVAR 26
93778: PUSH
93779: LD_STRING Dark Warrior
93781: ST_TO_ADDR
// hc_gallery :=  ;
93782: LD_ADDR_OWVAR 33
93786: PUSH
93787: LD_STRING 
93789: ST_TO_ADDR
// hc_noskilllimit := true ;
93790: LD_ADDR_OWVAR 76
93794: PUSH
93795: LD_INT 1
93797: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93798: LD_ADDR_OWVAR 31
93802: PUSH
93803: LD_INT 30
93805: PUSH
93806: LD_INT 30
93808: PUSH
93809: LD_INT 30
93811: PUSH
93812: LD_INT 30
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: ST_TO_ADDR
// un := CreateHuman ;
93821: LD_ADDR_VAR 0 3
93825: PUSH
93826: CALL_OW 44
93830: ST_TO_ADDR
// hc_noskilllimit := false ;
93831: LD_ADDR_OWVAR 76
93835: PUSH
93836: LD_INT 0
93838: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93839: LD_VAR 0 3
93843: PPUSH
93844: LD_INT 1
93846: PPUSH
93847: CALL_OW 51
// p := 0 ;
93851: LD_ADDR_VAR 0 2
93855: PUSH
93856: LD_INT 0
93858: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93859: LD_INT 35
93861: PPUSH
93862: CALL_OW 67
// p := p + 1 ;
93866: LD_ADDR_VAR 0 2
93870: PUSH
93871: LD_VAR 0 2
93875: PUSH
93876: LD_INT 1
93878: PLUS
93879: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93880: LD_VAR 0 3
93884: PPUSH
93885: CALL_OW 256
93889: PUSH
93890: LD_INT 1000
93892: LESS
93893: IFFALSE 93907
// SetLives ( un , 1000 ) ;
93895: LD_VAR 0 3
93899: PPUSH
93900: LD_INT 1000
93902: PPUSH
93903: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93907: LD_VAR 0 3
93911: PPUSH
93912: LD_INT 81
93914: PUSH
93915: LD_OWVAR 2
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 91
93926: PUSH
93927: LD_VAR 0 3
93931: PUSH
93932: LD_INT 30
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: LIST
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PPUSH
93944: CALL_OW 69
93948: PPUSH
93949: LD_VAR 0 3
93953: PPUSH
93954: CALL_OW 74
93958: PPUSH
93959: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93963: LD_VAR 0 2
93967: PUSH
93968: LD_INT 60
93970: GREATER
93971: PUSH
93972: LD_VAR 0 3
93976: PPUSH
93977: CALL_OW 301
93981: OR
93982: IFFALSE 93859
// if un then
93984: LD_VAR 0 3
93988: IFFALSE 93999
// RemoveUnit ( un ) ;
93990: LD_VAR 0 3
93994: PPUSH
93995: CALL_OW 64
// end ;
93999: PPOPN 3
94001: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94002: LD_INT 0
94004: PPUSH
// case cmd of 301 :
94005: LD_VAR 0 1
94009: PUSH
94010: LD_INT 301
94012: DOUBLE
94013: EQUAL
94014: IFTRUE 94018
94016: GO 94050
94018: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
94019: LD_VAR 0 6
94023: PPUSH
94024: LD_VAR 0 7
94028: PPUSH
94029: LD_VAR 0 8
94033: PPUSH
94034: LD_VAR 0 4
94038: PPUSH
94039: LD_VAR 0 5
94043: PPUSH
94044: CALL 95251 0 5
94048: GO 94171
94050: LD_INT 302
94052: DOUBLE
94053: EQUAL
94054: IFTRUE 94058
94056: GO 94095
94058: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
94059: LD_VAR 0 6
94063: PPUSH
94064: LD_VAR 0 7
94068: PPUSH
94069: LD_VAR 0 8
94073: PPUSH
94074: LD_VAR 0 9
94078: PPUSH
94079: LD_VAR 0 4
94083: PPUSH
94084: LD_VAR 0 5
94088: PPUSH
94089: CALL 95342 0 6
94093: GO 94171
94095: LD_INT 303
94097: DOUBLE
94098: EQUAL
94099: IFTRUE 94103
94101: GO 94140
94103: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
94104: LD_VAR 0 6
94108: PPUSH
94109: LD_VAR 0 7
94113: PPUSH
94114: LD_VAR 0 8
94118: PPUSH
94119: LD_VAR 0 9
94123: PPUSH
94124: LD_VAR 0 4
94128: PPUSH
94129: LD_VAR 0 5
94133: PPUSH
94134: CALL 94176 0 6
94138: GO 94171
94140: LD_INT 304
94142: DOUBLE
94143: EQUAL
94144: IFTRUE 94148
94146: GO 94170
94148: POP
// hHackTeleport ( unit , x , y ) ; end ;
94149: LD_VAR 0 2
94153: PPUSH
94154: LD_VAR 0 4
94158: PPUSH
94159: LD_VAR 0 5
94163: PPUSH
94164: CALL 95935 0 3
94168: GO 94171
94170: POP
// end ;
94171: LD_VAR 0 12
94175: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
94176: LD_INT 0
94178: PPUSH
94179: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
94180: LD_VAR 0 1
94184: PUSH
94185: LD_INT 1
94187: LESS
94188: PUSH
94189: LD_VAR 0 1
94193: PUSH
94194: LD_INT 3
94196: GREATER
94197: OR
94198: PUSH
94199: LD_VAR 0 5
94203: PPUSH
94204: LD_VAR 0 6
94208: PPUSH
94209: CALL_OW 428
94213: OR
94214: IFFALSE 94218
// exit ;
94216: GO 94938
// uc_side := your_side ;
94218: LD_ADDR_OWVAR 20
94222: PUSH
94223: LD_OWVAR 2
94227: ST_TO_ADDR
// uc_nation := nation ;
94228: LD_ADDR_OWVAR 21
94232: PUSH
94233: LD_VAR 0 1
94237: ST_TO_ADDR
// bc_level = 1 ;
94238: LD_ADDR_OWVAR 43
94242: PUSH
94243: LD_INT 1
94245: ST_TO_ADDR
// case btype of 1 :
94246: LD_VAR 0 2
94250: PUSH
94251: LD_INT 1
94253: DOUBLE
94254: EQUAL
94255: IFTRUE 94259
94257: GO 94270
94259: POP
// bc_type := b_depot ; 2 :
94260: LD_ADDR_OWVAR 42
94264: PUSH
94265: LD_INT 0
94267: ST_TO_ADDR
94268: GO 94882
94270: LD_INT 2
94272: DOUBLE
94273: EQUAL
94274: IFTRUE 94278
94276: GO 94289
94278: POP
// bc_type := b_warehouse ; 3 :
94279: LD_ADDR_OWVAR 42
94283: PUSH
94284: LD_INT 1
94286: ST_TO_ADDR
94287: GO 94882
94289: LD_INT 3
94291: DOUBLE
94292: EQUAL
94293: IFTRUE 94297
94295: GO 94308
94297: POP
// bc_type := b_lab ; 4 .. 9 :
94298: LD_ADDR_OWVAR 42
94302: PUSH
94303: LD_INT 6
94305: ST_TO_ADDR
94306: GO 94882
94308: LD_INT 4
94310: DOUBLE
94311: GREATEREQUAL
94312: IFFALSE 94320
94314: LD_INT 9
94316: DOUBLE
94317: LESSEQUAL
94318: IFTRUE 94322
94320: GO 94374
94322: POP
// begin bc_type := b_lab_half ;
94323: LD_ADDR_OWVAR 42
94327: PUSH
94328: LD_INT 7
94330: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
94331: LD_ADDR_OWVAR 44
94335: PUSH
94336: LD_INT 10
94338: PUSH
94339: LD_INT 11
94341: PUSH
94342: LD_INT 12
94344: PUSH
94345: LD_INT 15
94347: PUSH
94348: LD_INT 14
94350: PUSH
94351: LD_INT 13
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: PUSH
94362: LD_VAR 0 2
94366: PUSH
94367: LD_INT 3
94369: MINUS
94370: ARRAY
94371: ST_TO_ADDR
// end ; 10 .. 13 :
94372: GO 94882
94374: LD_INT 10
94376: DOUBLE
94377: GREATEREQUAL
94378: IFFALSE 94386
94380: LD_INT 13
94382: DOUBLE
94383: LESSEQUAL
94384: IFTRUE 94388
94386: GO 94465
94388: POP
// begin bc_type := b_lab_full ;
94389: LD_ADDR_OWVAR 42
94393: PUSH
94394: LD_INT 8
94396: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94397: LD_ADDR_OWVAR 44
94401: PUSH
94402: LD_INT 10
94404: PUSH
94405: LD_INT 12
94407: PUSH
94408: LD_INT 14
94410: PUSH
94411: LD_INT 13
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: PUSH
94420: LD_VAR 0 2
94424: PUSH
94425: LD_INT 9
94427: MINUS
94428: ARRAY
94429: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94430: LD_ADDR_OWVAR 45
94434: PUSH
94435: LD_INT 11
94437: PUSH
94438: LD_INT 15
94440: PUSH
94441: LD_INT 12
94443: PUSH
94444: LD_INT 15
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: PUSH
94453: LD_VAR 0 2
94457: PUSH
94458: LD_INT 9
94460: MINUS
94461: ARRAY
94462: ST_TO_ADDR
// end ; 14 :
94463: GO 94882
94465: LD_INT 14
94467: DOUBLE
94468: EQUAL
94469: IFTRUE 94473
94471: GO 94484
94473: POP
// bc_type := b_workshop ; 15 :
94474: LD_ADDR_OWVAR 42
94478: PUSH
94479: LD_INT 2
94481: ST_TO_ADDR
94482: GO 94882
94484: LD_INT 15
94486: DOUBLE
94487: EQUAL
94488: IFTRUE 94492
94490: GO 94503
94492: POP
// bc_type := b_factory ; 16 :
94493: LD_ADDR_OWVAR 42
94497: PUSH
94498: LD_INT 3
94500: ST_TO_ADDR
94501: GO 94882
94503: LD_INT 16
94505: DOUBLE
94506: EQUAL
94507: IFTRUE 94511
94509: GO 94522
94511: POP
// bc_type := b_ext_gun ; 17 :
94512: LD_ADDR_OWVAR 42
94516: PUSH
94517: LD_INT 17
94519: ST_TO_ADDR
94520: GO 94882
94522: LD_INT 17
94524: DOUBLE
94525: EQUAL
94526: IFTRUE 94530
94528: GO 94558
94530: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94531: LD_ADDR_OWVAR 42
94535: PUSH
94536: LD_INT 19
94538: PUSH
94539: LD_INT 23
94541: PUSH
94542: LD_INT 19
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: LIST
94549: PUSH
94550: LD_VAR 0 1
94554: ARRAY
94555: ST_TO_ADDR
94556: GO 94882
94558: LD_INT 18
94560: DOUBLE
94561: EQUAL
94562: IFTRUE 94566
94564: GO 94577
94566: POP
// bc_type := b_ext_radar ; 19 :
94567: LD_ADDR_OWVAR 42
94571: PUSH
94572: LD_INT 20
94574: ST_TO_ADDR
94575: GO 94882
94577: LD_INT 19
94579: DOUBLE
94580: EQUAL
94581: IFTRUE 94585
94583: GO 94596
94585: POP
// bc_type := b_ext_radio ; 20 :
94586: LD_ADDR_OWVAR 42
94590: PUSH
94591: LD_INT 22
94593: ST_TO_ADDR
94594: GO 94882
94596: LD_INT 20
94598: DOUBLE
94599: EQUAL
94600: IFTRUE 94604
94602: GO 94615
94604: POP
// bc_type := b_ext_siberium ; 21 :
94605: LD_ADDR_OWVAR 42
94609: PUSH
94610: LD_INT 21
94612: ST_TO_ADDR
94613: GO 94882
94615: LD_INT 21
94617: DOUBLE
94618: EQUAL
94619: IFTRUE 94623
94621: GO 94634
94623: POP
// bc_type := b_ext_computer ; 22 :
94624: LD_ADDR_OWVAR 42
94628: PUSH
94629: LD_INT 24
94631: ST_TO_ADDR
94632: GO 94882
94634: LD_INT 22
94636: DOUBLE
94637: EQUAL
94638: IFTRUE 94642
94640: GO 94653
94642: POP
// bc_type := b_ext_track ; 23 :
94643: LD_ADDR_OWVAR 42
94647: PUSH
94648: LD_INT 16
94650: ST_TO_ADDR
94651: GO 94882
94653: LD_INT 23
94655: DOUBLE
94656: EQUAL
94657: IFTRUE 94661
94659: GO 94672
94661: POP
// bc_type := b_ext_laser ; 24 :
94662: LD_ADDR_OWVAR 42
94666: PUSH
94667: LD_INT 25
94669: ST_TO_ADDR
94670: GO 94882
94672: LD_INT 24
94674: DOUBLE
94675: EQUAL
94676: IFTRUE 94680
94678: GO 94691
94680: POP
// bc_type := b_control_tower ; 25 :
94681: LD_ADDR_OWVAR 42
94685: PUSH
94686: LD_INT 36
94688: ST_TO_ADDR
94689: GO 94882
94691: LD_INT 25
94693: DOUBLE
94694: EQUAL
94695: IFTRUE 94699
94697: GO 94710
94699: POP
// bc_type := b_breastwork ; 26 :
94700: LD_ADDR_OWVAR 42
94704: PUSH
94705: LD_INT 31
94707: ST_TO_ADDR
94708: GO 94882
94710: LD_INT 26
94712: DOUBLE
94713: EQUAL
94714: IFTRUE 94718
94716: GO 94729
94718: POP
// bc_type := b_bunker ; 27 :
94719: LD_ADDR_OWVAR 42
94723: PUSH
94724: LD_INT 32
94726: ST_TO_ADDR
94727: GO 94882
94729: LD_INT 27
94731: DOUBLE
94732: EQUAL
94733: IFTRUE 94737
94735: GO 94748
94737: POP
// bc_type := b_turret ; 28 :
94738: LD_ADDR_OWVAR 42
94742: PUSH
94743: LD_INT 33
94745: ST_TO_ADDR
94746: GO 94882
94748: LD_INT 28
94750: DOUBLE
94751: EQUAL
94752: IFTRUE 94756
94754: GO 94767
94756: POP
// bc_type := b_armoury ; 29 :
94757: LD_ADDR_OWVAR 42
94761: PUSH
94762: LD_INT 4
94764: ST_TO_ADDR
94765: GO 94882
94767: LD_INT 29
94769: DOUBLE
94770: EQUAL
94771: IFTRUE 94775
94773: GO 94786
94775: POP
// bc_type := b_barracks ; 30 :
94776: LD_ADDR_OWVAR 42
94780: PUSH
94781: LD_INT 5
94783: ST_TO_ADDR
94784: GO 94882
94786: LD_INT 30
94788: DOUBLE
94789: EQUAL
94790: IFTRUE 94794
94792: GO 94805
94794: POP
// bc_type := b_solar_power ; 31 :
94795: LD_ADDR_OWVAR 42
94799: PUSH
94800: LD_INT 27
94802: ST_TO_ADDR
94803: GO 94882
94805: LD_INT 31
94807: DOUBLE
94808: EQUAL
94809: IFTRUE 94813
94811: GO 94824
94813: POP
// bc_type := b_oil_power ; 32 :
94814: LD_ADDR_OWVAR 42
94818: PUSH
94819: LD_INT 26
94821: ST_TO_ADDR
94822: GO 94882
94824: LD_INT 32
94826: DOUBLE
94827: EQUAL
94828: IFTRUE 94832
94830: GO 94843
94832: POP
// bc_type := b_siberite_power ; 33 :
94833: LD_ADDR_OWVAR 42
94837: PUSH
94838: LD_INT 28
94840: ST_TO_ADDR
94841: GO 94882
94843: LD_INT 33
94845: DOUBLE
94846: EQUAL
94847: IFTRUE 94851
94849: GO 94862
94851: POP
// bc_type := b_oil_mine ; 34 :
94852: LD_ADDR_OWVAR 42
94856: PUSH
94857: LD_INT 29
94859: ST_TO_ADDR
94860: GO 94882
94862: LD_INT 34
94864: DOUBLE
94865: EQUAL
94866: IFTRUE 94870
94868: GO 94881
94870: POP
// bc_type := b_siberite_mine ; end ;
94871: LD_ADDR_OWVAR 42
94875: PUSH
94876: LD_INT 30
94878: ST_TO_ADDR
94879: GO 94882
94881: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94882: LD_ADDR_VAR 0 8
94886: PUSH
94887: LD_VAR 0 5
94891: PPUSH
94892: LD_VAR 0 6
94896: PPUSH
94897: LD_VAR 0 3
94901: PPUSH
94902: CALL_OW 47
94906: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94907: LD_OWVAR 42
94911: PUSH
94912: LD_INT 32
94914: PUSH
94915: LD_INT 33
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: IN
94922: IFFALSE 94938
// PlaceWeaponTurret ( b , weapon ) ;
94924: LD_VAR 0 8
94928: PPUSH
94929: LD_VAR 0 4
94933: PPUSH
94934: CALL_OW 431
// end ;
94938: LD_VAR 0 7
94942: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94943: LD_INT 0
94945: PPUSH
94946: PPUSH
94947: PPUSH
94948: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94949: LD_ADDR_VAR 0 4
94953: PUSH
94954: LD_INT 22
94956: PUSH
94957: LD_OWVAR 2
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: LD_INT 30
94971: PUSH
94972: LD_INT 0
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: LD_INT 30
94981: PUSH
94982: LD_INT 1
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: LIST
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PPUSH
94998: CALL_OW 69
95002: ST_TO_ADDR
// if not tmp then
95003: LD_VAR 0 4
95007: NOT
95008: IFFALSE 95012
// exit ;
95010: GO 95071
// for i in tmp do
95012: LD_ADDR_VAR 0 2
95016: PUSH
95017: LD_VAR 0 4
95021: PUSH
95022: FOR_IN
95023: IFFALSE 95069
// for j = 1 to 3 do
95025: LD_ADDR_VAR 0 3
95029: PUSH
95030: DOUBLE
95031: LD_INT 1
95033: DEC
95034: ST_TO_ADDR
95035: LD_INT 3
95037: PUSH
95038: FOR_TO
95039: IFFALSE 95065
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95041: LD_VAR 0 2
95045: PPUSH
95046: CALL_OW 274
95050: PPUSH
95051: LD_VAR 0 3
95055: PPUSH
95056: LD_INT 99999
95058: PPUSH
95059: CALL_OW 277
95063: GO 95038
95065: POP
95066: POP
95067: GO 95022
95069: POP
95070: POP
// end ;
95071: LD_VAR 0 1
95075: RET
// export function hHackSetLevel10 ; var i , j ; begin
95076: LD_INT 0
95078: PPUSH
95079: PPUSH
95080: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95081: LD_ADDR_VAR 0 2
95085: PUSH
95086: LD_INT 21
95088: PUSH
95089: LD_INT 1
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PPUSH
95096: CALL_OW 69
95100: PUSH
95101: FOR_IN
95102: IFFALSE 95154
// if IsSelected ( i ) then
95104: LD_VAR 0 2
95108: PPUSH
95109: CALL_OW 306
95113: IFFALSE 95152
// begin for j := 1 to 4 do
95115: LD_ADDR_VAR 0 3
95119: PUSH
95120: DOUBLE
95121: LD_INT 1
95123: DEC
95124: ST_TO_ADDR
95125: LD_INT 4
95127: PUSH
95128: FOR_TO
95129: IFFALSE 95150
// SetSkill ( i , j , 10 ) ;
95131: LD_VAR 0 2
95135: PPUSH
95136: LD_VAR 0 3
95140: PPUSH
95141: LD_INT 10
95143: PPUSH
95144: CALL_OW 237
95148: GO 95128
95150: POP
95151: POP
// end ;
95152: GO 95101
95154: POP
95155: POP
// end ;
95156: LD_VAR 0 1
95160: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95161: LD_INT 0
95163: PPUSH
95164: PPUSH
95165: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95166: LD_ADDR_VAR 0 2
95170: PUSH
95171: LD_INT 22
95173: PUSH
95174: LD_OWVAR 2
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 21
95185: PUSH
95186: LD_INT 1
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PPUSH
95197: CALL_OW 69
95201: PUSH
95202: FOR_IN
95203: IFFALSE 95244
// begin for j := 1 to 4 do
95205: LD_ADDR_VAR 0 3
95209: PUSH
95210: DOUBLE
95211: LD_INT 1
95213: DEC
95214: ST_TO_ADDR
95215: LD_INT 4
95217: PUSH
95218: FOR_TO
95219: IFFALSE 95240
// SetSkill ( i , j , 10 ) ;
95221: LD_VAR 0 2
95225: PPUSH
95226: LD_VAR 0 3
95230: PPUSH
95231: LD_INT 10
95233: PPUSH
95234: CALL_OW 237
95238: GO 95218
95240: POP
95241: POP
// end ;
95242: GO 95202
95244: POP
95245: POP
// end ;
95246: LD_VAR 0 1
95250: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
95251: LD_INT 0
95253: PPUSH
// uc_side := your_side ;
95254: LD_ADDR_OWVAR 20
95258: PUSH
95259: LD_OWVAR 2
95263: ST_TO_ADDR
// uc_nation := nation ;
95264: LD_ADDR_OWVAR 21
95268: PUSH
95269: LD_VAR 0 1
95273: ST_TO_ADDR
// InitHc ;
95274: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95278: LD_INT 0
95280: PPUSH
95281: LD_VAR 0 2
95285: PPUSH
95286: LD_VAR 0 3
95290: PPUSH
95291: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
95295: LD_VAR 0 4
95299: PPUSH
95300: LD_VAR 0 5
95304: PPUSH
95305: CALL_OW 428
95309: PUSH
95310: LD_INT 0
95312: EQUAL
95313: IFFALSE 95337
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
95315: CALL_OW 44
95319: PPUSH
95320: LD_VAR 0 4
95324: PPUSH
95325: LD_VAR 0 5
95329: PPUSH
95330: LD_INT 1
95332: PPUSH
95333: CALL_OW 48
// end ;
95337: LD_VAR 0 6
95341: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
95342: LD_INT 0
95344: PPUSH
95345: PPUSH
// uc_side := your_side ;
95346: LD_ADDR_OWVAR 20
95350: PUSH
95351: LD_OWVAR 2
95355: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
95356: LD_VAR 0 1
95360: PUSH
95361: LD_INT 1
95363: PUSH
95364: LD_INT 2
95366: PUSH
95367: LD_INT 3
95369: PUSH
95370: LD_INT 4
95372: PUSH
95373: LD_INT 5
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: IN
95383: IFFALSE 95395
// uc_nation := nation_american else
95385: LD_ADDR_OWVAR 21
95389: PUSH
95390: LD_INT 1
95392: ST_TO_ADDR
95393: GO 95438
// if chassis in [ 11 , 12 , 13 , 14 ] then
95395: LD_VAR 0 1
95399: PUSH
95400: LD_INT 11
95402: PUSH
95403: LD_INT 12
95405: PUSH
95406: LD_INT 13
95408: PUSH
95409: LD_INT 14
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: IN
95418: IFFALSE 95430
// uc_nation := nation_arabian else
95420: LD_ADDR_OWVAR 21
95424: PUSH
95425: LD_INT 2
95427: ST_TO_ADDR
95428: GO 95438
// uc_nation := nation_russian ;
95430: LD_ADDR_OWVAR 21
95434: PUSH
95435: LD_INT 3
95437: ST_TO_ADDR
// vc_chassis := chassis ;
95438: LD_ADDR_OWVAR 37
95442: PUSH
95443: LD_VAR 0 1
95447: ST_TO_ADDR
// vc_engine := engine ;
95448: LD_ADDR_OWVAR 39
95452: PUSH
95453: LD_VAR 0 2
95457: ST_TO_ADDR
// vc_control := control ;
95458: LD_ADDR_OWVAR 38
95462: PUSH
95463: LD_VAR 0 3
95467: ST_TO_ADDR
// vc_weapon := weapon ;
95468: LD_ADDR_OWVAR 40
95472: PUSH
95473: LD_VAR 0 4
95477: ST_TO_ADDR
// un := CreateVehicle ;
95478: LD_ADDR_VAR 0 8
95482: PUSH
95483: CALL_OW 45
95487: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95488: LD_VAR 0 8
95492: PPUSH
95493: LD_INT 0
95495: PPUSH
95496: LD_INT 5
95498: PPUSH
95499: CALL_OW 12
95503: PPUSH
95504: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95508: LD_VAR 0 8
95512: PPUSH
95513: LD_VAR 0 5
95517: PPUSH
95518: LD_VAR 0 6
95522: PPUSH
95523: LD_INT 1
95525: PPUSH
95526: CALL_OW 48
// end ;
95530: LD_VAR 0 7
95534: RET
// export hInvincible ; every 1 do
95535: GO 95537
95537: DISABLE
// hInvincible := [ ] ;
95538: LD_ADDR_EXP 176
95542: PUSH
95543: EMPTY
95544: ST_TO_ADDR
95545: END
// every 10 do var i ;
95546: GO 95548
95548: DISABLE
95549: LD_INT 0
95551: PPUSH
// begin enable ;
95552: ENABLE
// if not hInvincible then
95553: LD_EXP 176
95557: NOT
95558: IFFALSE 95562
// exit ;
95560: GO 95606
// for i in hInvincible do
95562: LD_ADDR_VAR 0 1
95566: PUSH
95567: LD_EXP 176
95571: PUSH
95572: FOR_IN
95573: IFFALSE 95604
// if GetLives ( i ) < 1000 then
95575: LD_VAR 0 1
95579: PPUSH
95580: CALL_OW 256
95584: PUSH
95585: LD_INT 1000
95587: LESS
95588: IFFALSE 95602
// SetLives ( i , 1000 ) ;
95590: LD_VAR 0 1
95594: PPUSH
95595: LD_INT 1000
95597: PPUSH
95598: CALL_OW 234
95602: GO 95572
95604: POP
95605: POP
// end ;
95606: PPOPN 1
95608: END
// export function hHackInvincible ; var i ; begin
95609: LD_INT 0
95611: PPUSH
95612: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95613: LD_ADDR_VAR 0 2
95617: PUSH
95618: LD_INT 2
95620: PUSH
95621: LD_INT 21
95623: PUSH
95624: LD_INT 1
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 21
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: LIST
95645: PPUSH
95646: CALL_OW 69
95650: PUSH
95651: FOR_IN
95652: IFFALSE 95713
// if IsSelected ( i ) then
95654: LD_VAR 0 2
95658: PPUSH
95659: CALL_OW 306
95663: IFFALSE 95711
// begin if i in hInvincible then
95665: LD_VAR 0 2
95669: PUSH
95670: LD_EXP 176
95674: IN
95675: IFFALSE 95695
// hInvincible := hInvincible diff i else
95677: LD_ADDR_EXP 176
95681: PUSH
95682: LD_EXP 176
95686: PUSH
95687: LD_VAR 0 2
95691: DIFF
95692: ST_TO_ADDR
95693: GO 95711
// hInvincible := hInvincible union i ;
95695: LD_ADDR_EXP 176
95699: PUSH
95700: LD_EXP 176
95704: PUSH
95705: LD_VAR 0 2
95709: UNION
95710: ST_TO_ADDR
// end ;
95711: GO 95651
95713: POP
95714: POP
// end ;
95715: LD_VAR 0 1
95719: RET
// export function hHackInvisible ; var i , j ; begin
95720: LD_INT 0
95722: PPUSH
95723: PPUSH
95724: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95725: LD_ADDR_VAR 0 2
95729: PUSH
95730: LD_INT 21
95732: PUSH
95733: LD_INT 1
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PPUSH
95740: CALL_OW 69
95744: PUSH
95745: FOR_IN
95746: IFFALSE 95770
// if IsSelected ( i ) then
95748: LD_VAR 0 2
95752: PPUSH
95753: CALL_OW 306
95757: IFFALSE 95768
// ComForceInvisible ( i ) ;
95759: LD_VAR 0 2
95763: PPUSH
95764: CALL_OW 496
95768: GO 95745
95770: POP
95771: POP
// end ;
95772: LD_VAR 0 1
95776: RET
// export function hHackChangeYourSide ; begin
95777: LD_INT 0
95779: PPUSH
// if your_side = 8 then
95780: LD_OWVAR 2
95784: PUSH
95785: LD_INT 8
95787: EQUAL
95788: IFFALSE 95800
// your_side := 0 else
95790: LD_ADDR_OWVAR 2
95794: PUSH
95795: LD_INT 0
95797: ST_TO_ADDR
95798: GO 95814
// your_side := your_side + 1 ;
95800: LD_ADDR_OWVAR 2
95804: PUSH
95805: LD_OWVAR 2
95809: PUSH
95810: LD_INT 1
95812: PLUS
95813: ST_TO_ADDR
// end ;
95814: LD_VAR 0 1
95818: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95819: LD_INT 0
95821: PPUSH
95822: PPUSH
95823: PPUSH
// for i in all_units do
95824: LD_ADDR_VAR 0 2
95828: PUSH
95829: LD_OWVAR 3
95833: PUSH
95834: FOR_IN
95835: IFFALSE 95913
// if IsSelected ( i ) then
95837: LD_VAR 0 2
95841: PPUSH
95842: CALL_OW 306
95846: IFFALSE 95911
// begin j := GetSide ( i ) ;
95848: LD_ADDR_VAR 0 3
95852: PUSH
95853: LD_VAR 0 2
95857: PPUSH
95858: CALL_OW 255
95862: ST_TO_ADDR
// if j = 8 then
95863: LD_VAR 0 3
95867: PUSH
95868: LD_INT 8
95870: EQUAL
95871: IFFALSE 95883
// j := 0 else
95873: LD_ADDR_VAR 0 3
95877: PUSH
95878: LD_INT 0
95880: ST_TO_ADDR
95881: GO 95897
// j := j + 1 ;
95883: LD_ADDR_VAR 0 3
95887: PUSH
95888: LD_VAR 0 3
95892: PUSH
95893: LD_INT 1
95895: PLUS
95896: ST_TO_ADDR
// SetSide ( i , j ) ;
95897: LD_VAR 0 2
95901: PPUSH
95902: LD_VAR 0 3
95906: PPUSH
95907: CALL_OW 235
// end ;
95911: GO 95834
95913: POP
95914: POP
// end ;
95915: LD_VAR 0 1
95919: RET
// export function hHackFog ; begin
95920: LD_INT 0
95922: PPUSH
// FogOff ( true ) ;
95923: LD_INT 1
95925: PPUSH
95926: CALL_OW 344
// end ;
95930: LD_VAR 0 1
95934: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95935: LD_INT 0
95937: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95938: LD_VAR 0 1
95942: PPUSH
95943: LD_VAR 0 2
95947: PPUSH
95948: LD_VAR 0 3
95952: PPUSH
95953: LD_INT 1
95955: PPUSH
95956: LD_INT 1
95958: PPUSH
95959: CALL_OW 483
// CenterOnXY ( x , y ) ;
95963: LD_VAR 0 2
95967: PPUSH
95968: LD_VAR 0 3
95972: PPUSH
95973: CALL_OW 84
// end ; end_of_file
95977: LD_VAR 0 4
95981: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
95982: LD_INT 0
95984: PPUSH
95985: PPUSH
95986: PPUSH
95987: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
95988: LD_VAR 0 1
95992: PPUSH
95993: CALL_OW 264
95997: PUSH
95998: LD_EXP 107
96002: EQUAL
96003: IFFALSE 96075
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
96005: LD_INT 68
96007: PPUSH
96008: LD_VAR 0 1
96012: PPUSH
96013: CALL_OW 255
96017: PPUSH
96018: CALL_OW 321
96022: PUSH
96023: LD_INT 2
96025: EQUAL
96026: IFFALSE 96038
// eff := 70 else
96028: LD_ADDR_VAR 0 4
96032: PUSH
96033: LD_INT 70
96035: ST_TO_ADDR
96036: GO 96046
// eff := 30 ;
96038: LD_ADDR_VAR 0 4
96042: PUSH
96043: LD_INT 30
96045: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
96046: LD_VAR 0 1
96050: PPUSH
96051: CALL_OW 250
96055: PPUSH
96056: LD_VAR 0 1
96060: PPUSH
96061: CALL_OW 251
96065: PPUSH
96066: LD_VAR 0 4
96070: PPUSH
96071: CALL_OW 495
// end ; end ;
96075: LD_VAR 0 2
96079: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
96080: LD_INT 0
96082: PPUSH
// end ;
96083: LD_VAR 0 4
96087: RET
// export function SOS_Command ( cmd ) ; begin
96088: LD_INT 0
96090: PPUSH
// end ;
96091: LD_VAR 0 2
96095: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
96096: LD_INT 0
96098: PPUSH
// if cmd = 121 then
96099: LD_VAR 0 1
96103: PUSH
96104: LD_INT 121
96106: EQUAL
96107: IFFALSE 96109
// end ;
96109: LD_VAR 0 6
96113: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
96114: LD_INT 0
96116: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
96117: LD_VAR 0 1
96121: PUSH
96122: LD_INT 250
96124: EQUAL
96125: PUSH
96126: LD_VAR 0 2
96130: PPUSH
96131: CALL_OW 264
96135: PUSH
96136: LD_EXP 110
96140: EQUAL
96141: AND
96142: IFFALSE 96163
// MinerPlaceMine ( unit , x , y ) ;
96144: LD_VAR 0 2
96148: PPUSH
96149: LD_VAR 0 4
96153: PPUSH
96154: LD_VAR 0 5
96158: PPUSH
96159: CALL 98512 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
96163: LD_VAR 0 1
96167: PUSH
96168: LD_INT 251
96170: EQUAL
96171: PUSH
96172: LD_VAR 0 2
96176: PPUSH
96177: CALL_OW 264
96181: PUSH
96182: LD_EXP 110
96186: EQUAL
96187: AND
96188: IFFALSE 96209
// MinerDetonateMine ( unit , x , y ) ;
96190: LD_VAR 0 2
96194: PPUSH
96195: LD_VAR 0 4
96199: PPUSH
96200: LD_VAR 0 5
96204: PPUSH
96205: CALL 98789 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
96209: LD_VAR 0 1
96213: PUSH
96214: LD_INT 252
96216: EQUAL
96217: PUSH
96218: LD_VAR 0 2
96222: PPUSH
96223: CALL_OW 264
96227: PUSH
96228: LD_EXP 110
96232: EQUAL
96233: AND
96234: IFFALSE 96255
// MinerCreateMinefield ( unit , x , y ) ;
96236: LD_VAR 0 2
96240: PPUSH
96241: LD_VAR 0 4
96245: PPUSH
96246: LD_VAR 0 5
96250: PPUSH
96251: CALL 99206 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
96255: LD_VAR 0 1
96259: PUSH
96260: LD_INT 253
96262: EQUAL
96263: PUSH
96264: LD_VAR 0 2
96268: PPUSH
96269: CALL_OW 257
96273: PUSH
96274: LD_INT 5
96276: EQUAL
96277: AND
96278: IFFALSE 96299
// ComBinocular ( unit , x , y ) ;
96280: LD_VAR 0 2
96284: PPUSH
96285: LD_VAR 0 4
96289: PPUSH
96290: LD_VAR 0 5
96294: PPUSH
96295: CALL 99577 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
96299: LD_VAR 0 1
96303: PUSH
96304: LD_INT 254
96306: EQUAL
96307: PUSH
96308: LD_VAR 0 2
96312: PPUSH
96313: CALL_OW 264
96317: PUSH
96318: LD_EXP 105
96322: EQUAL
96323: AND
96324: PUSH
96325: LD_VAR 0 3
96329: PPUSH
96330: CALL_OW 263
96334: PUSH
96335: LD_INT 3
96337: EQUAL
96338: AND
96339: IFFALSE 96355
// HackDestroyVehicle ( unit , selectedUnit ) ;
96341: LD_VAR 0 2
96345: PPUSH
96346: LD_VAR 0 3
96350: PPUSH
96351: CALL 97872 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
96355: LD_VAR 0 1
96359: PUSH
96360: LD_INT 255
96362: EQUAL
96363: PUSH
96364: LD_VAR 0 2
96368: PPUSH
96369: CALL_OW 264
96373: PUSH
96374: LD_INT 14
96376: PUSH
96377: LD_INT 53
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: IN
96384: AND
96385: PUSH
96386: LD_VAR 0 4
96390: PPUSH
96391: LD_VAR 0 5
96395: PPUSH
96396: CALL_OW 488
96400: AND
96401: IFFALSE 96425
// CutTreeXYR ( unit , x , y , 12 ) ;
96403: LD_VAR 0 2
96407: PPUSH
96408: LD_VAR 0 4
96412: PPUSH
96413: LD_VAR 0 5
96417: PPUSH
96418: LD_INT 12
96420: PPUSH
96421: CALL 96438 0 4
// end ;
96425: LD_VAR 0 6
96429: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
96430: LD_INT 0
96432: PPUSH
// end ;
96433: LD_VAR 0 4
96437: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
96438: LD_INT 0
96440: PPUSH
96441: PPUSH
96442: PPUSH
96443: PPUSH
96444: PPUSH
96445: PPUSH
96446: PPUSH
96447: PPUSH
96448: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
96449: LD_VAR 0 1
96453: NOT
96454: PUSH
96455: LD_VAR 0 2
96459: PPUSH
96460: LD_VAR 0 3
96464: PPUSH
96465: CALL_OW 488
96469: NOT
96470: OR
96471: PUSH
96472: LD_VAR 0 4
96476: NOT
96477: OR
96478: IFFALSE 96482
// exit ;
96480: GO 96822
// list := [ ] ;
96482: LD_ADDR_VAR 0 13
96486: PUSH
96487: EMPTY
96488: ST_TO_ADDR
// if x - r < 0 then
96489: LD_VAR 0 2
96493: PUSH
96494: LD_VAR 0 4
96498: MINUS
96499: PUSH
96500: LD_INT 0
96502: LESS
96503: IFFALSE 96515
// min_x := 0 else
96505: LD_ADDR_VAR 0 7
96509: PUSH
96510: LD_INT 0
96512: ST_TO_ADDR
96513: GO 96531
// min_x := x - r ;
96515: LD_ADDR_VAR 0 7
96519: PUSH
96520: LD_VAR 0 2
96524: PUSH
96525: LD_VAR 0 4
96529: MINUS
96530: ST_TO_ADDR
// if y - r < 0 then
96531: LD_VAR 0 3
96535: PUSH
96536: LD_VAR 0 4
96540: MINUS
96541: PUSH
96542: LD_INT 0
96544: LESS
96545: IFFALSE 96557
// min_y := 0 else
96547: LD_ADDR_VAR 0 8
96551: PUSH
96552: LD_INT 0
96554: ST_TO_ADDR
96555: GO 96573
// min_y := y - r ;
96557: LD_ADDR_VAR 0 8
96561: PUSH
96562: LD_VAR 0 3
96566: PUSH
96567: LD_VAR 0 4
96571: MINUS
96572: ST_TO_ADDR
// max_x := x + r ;
96573: LD_ADDR_VAR 0 9
96577: PUSH
96578: LD_VAR 0 2
96582: PUSH
96583: LD_VAR 0 4
96587: PLUS
96588: ST_TO_ADDR
// max_y := y + r ;
96589: LD_ADDR_VAR 0 10
96593: PUSH
96594: LD_VAR 0 3
96598: PUSH
96599: LD_VAR 0 4
96603: PLUS
96604: ST_TO_ADDR
// for _x = min_x to max_x do
96605: LD_ADDR_VAR 0 11
96609: PUSH
96610: DOUBLE
96611: LD_VAR 0 7
96615: DEC
96616: ST_TO_ADDR
96617: LD_VAR 0 9
96621: PUSH
96622: FOR_TO
96623: IFFALSE 96740
// for _y = min_y to max_y do
96625: LD_ADDR_VAR 0 12
96629: PUSH
96630: DOUBLE
96631: LD_VAR 0 8
96635: DEC
96636: ST_TO_ADDR
96637: LD_VAR 0 10
96641: PUSH
96642: FOR_TO
96643: IFFALSE 96736
// begin if not ValidHex ( _x , _y ) then
96645: LD_VAR 0 11
96649: PPUSH
96650: LD_VAR 0 12
96654: PPUSH
96655: CALL_OW 488
96659: NOT
96660: IFFALSE 96664
// continue ;
96662: GO 96642
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
96664: LD_VAR 0 11
96668: PPUSH
96669: LD_VAR 0 12
96673: PPUSH
96674: CALL_OW 351
96678: PUSH
96679: LD_VAR 0 11
96683: PPUSH
96684: LD_VAR 0 12
96688: PPUSH
96689: CALL_OW 554
96693: AND
96694: IFFALSE 96734
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
96696: LD_ADDR_VAR 0 13
96700: PUSH
96701: LD_VAR 0 13
96705: PPUSH
96706: LD_VAR 0 13
96710: PUSH
96711: LD_INT 1
96713: PLUS
96714: PPUSH
96715: LD_VAR 0 11
96719: PUSH
96720: LD_VAR 0 12
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: PPUSH
96729: CALL_OW 2
96733: ST_TO_ADDR
// end ;
96734: GO 96642
96736: POP
96737: POP
96738: GO 96622
96740: POP
96741: POP
// if not list then
96742: LD_VAR 0 13
96746: NOT
96747: IFFALSE 96751
// exit ;
96749: GO 96822
// for i in list do
96751: LD_ADDR_VAR 0 6
96755: PUSH
96756: LD_VAR 0 13
96760: PUSH
96761: FOR_IN
96762: IFFALSE 96820
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
96764: LD_VAR 0 1
96768: PPUSH
96769: LD_STRING M
96771: PUSH
96772: LD_VAR 0 6
96776: PUSH
96777: LD_INT 1
96779: ARRAY
96780: PUSH
96781: LD_VAR 0 6
96785: PUSH
96786: LD_INT 2
96788: ARRAY
96789: PUSH
96790: LD_INT 0
96792: PUSH
96793: LD_INT 0
96795: PUSH
96796: LD_INT 0
96798: PUSH
96799: LD_INT 0
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: LIST
96809: LIST
96810: PUSH
96811: EMPTY
96812: LIST
96813: PPUSH
96814: CALL_OW 447
96818: GO 96761
96820: POP
96821: POP
// end ;
96822: LD_VAR 0 5
96826: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
96827: LD_EXP 179
96831: NOT
96832: IFFALSE 96882
96834: GO 96836
96836: DISABLE
// begin initHack := true ;
96837: LD_ADDR_EXP 179
96841: PUSH
96842: LD_INT 1
96844: ST_TO_ADDR
// hackTanks := [ ] ;
96845: LD_ADDR_EXP 180
96849: PUSH
96850: EMPTY
96851: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
96852: LD_ADDR_EXP 181
96856: PUSH
96857: EMPTY
96858: ST_TO_ADDR
// hackLimit := 3 ;
96859: LD_ADDR_EXP 182
96863: PUSH
96864: LD_INT 3
96866: ST_TO_ADDR
// hackDist := 12 ;
96867: LD_ADDR_EXP 183
96871: PUSH
96872: LD_INT 12
96874: ST_TO_ADDR
// hackCounter := [ ] ;
96875: LD_ADDR_EXP 184
96879: PUSH
96880: EMPTY
96881: ST_TO_ADDR
// end ;
96882: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
96883: LD_EXP 179
96887: PUSH
96888: LD_INT 34
96890: PUSH
96891: LD_EXP 105
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PPUSH
96900: CALL_OW 69
96904: AND
96905: IFFALSE 97160
96907: GO 96909
96909: DISABLE
96910: LD_INT 0
96912: PPUSH
96913: PPUSH
// begin enable ;
96914: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
96915: LD_ADDR_VAR 0 1
96919: PUSH
96920: LD_INT 34
96922: PUSH
96923: LD_EXP 105
96927: PUSH
96928: EMPTY
96929: LIST
96930: LIST
96931: PPUSH
96932: CALL_OW 69
96936: PUSH
96937: FOR_IN
96938: IFFALSE 97158
// begin if not i in hackTanks then
96940: LD_VAR 0 1
96944: PUSH
96945: LD_EXP 180
96949: IN
96950: NOT
96951: IFFALSE 97034
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
96953: LD_ADDR_EXP 180
96957: PUSH
96958: LD_EXP 180
96962: PPUSH
96963: LD_EXP 180
96967: PUSH
96968: LD_INT 1
96970: PLUS
96971: PPUSH
96972: LD_VAR 0 1
96976: PPUSH
96977: CALL_OW 1
96981: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
96982: LD_ADDR_EXP 181
96986: PUSH
96987: LD_EXP 181
96991: PPUSH
96992: LD_EXP 181
96996: PUSH
96997: LD_INT 1
96999: PLUS
97000: PPUSH
97001: EMPTY
97002: PPUSH
97003: CALL_OW 1
97007: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
97008: LD_ADDR_EXP 184
97012: PUSH
97013: LD_EXP 184
97017: PPUSH
97018: LD_EXP 184
97022: PUSH
97023: LD_INT 1
97025: PLUS
97026: PPUSH
97027: EMPTY
97028: PPUSH
97029: CALL_OW 1
97033: ST_TO_ADDR
// end ; if not IsOk ( i ) then
97034: LD_VAR 0 1
97038: PPUSH
97039: CALL_OW 302
97043: NOT
97044: IFFALSE 97057
// begin HackUnlinkAll ( i ) ;
97046: LD_VAR 0 1
97050: PPUSH
97051: CALL 97163 0 1
// continue ;
97055: GO 96937
// end ; HackCheckCapturedStatus ( i ) ;
97057: LD_VAR 0 1
97061: PPUSH
97062: CALL 97606 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
97066: LD_ADDR_VAR 0 2
97070: PUSH
97071: LD_INT 81
97073: PUSH
97074: LD_VAR 0 1
97078: PPUSH
97079: CALL_OW 255
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 33
97090: PUSH
97091: LD_INT 3
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: PUSH
97098: LD_INT 91
97100: PUSH
97101: LD_VAR 0 1
97105: PUSH
97106: LD_EXP 183
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: LIST
97115: PUSH
97116: LD_INT 50
97118: PUSH
97119: EMPTY
97120: LIST
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: PPUSH
97128: CALL_OW 69
97132: ST_TO_ADDR
// if not tmp then
97133: LD_VAR 0 2
97137: NOT
97138: IFFALSE 97142
// continue ;
97140: GO 96937
// HackLink ( i , tmp ) ;
97142: LD_VAR 0 1
97146: PPUSH
97147: LD_VAR 0 2
97151: PPUSH
97152: CALL 97299 0 2
// end ;
97156: GO 96937
97158: POP
97159: POP
// end ;
97160: PPOPN 2
97162: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
97163: LD_INT 0
97165: PPUSH
97166: PPUSH
97167: PPUSH
// if not hack in hackTanks then
97168: LD_VAR 0 1
97172: PUSH
97173: LD_EXP 180
97177: IN
97178: NOT
97179: IFFALSE 97183
// exit ;
97181: GO 97294
// index := GetElementIndex ( hackTanks , hack ) ;
97183: LD_ADDR_VAR 0 4
97187: PUSH
97188: LD_EXP 180
97192: PPUSH
97193: LD_VAR 0 1
97197: PPUSH
97198: CALL 19454 0 2
97202: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
97203: LD_EXP 181
97207: PUSH
97208: LD_VAR 0 4
97212: ARRAY
97213: IFFALSE 97294
// begin for i in hackTanksCaptured [ index ] do
97215: LD_ADDR_VAR 0 3
97219: PUSH
97220: LD_EXP 181
97224: PUSH
97225: LD_VAR 0 4
97229: ARRAY
97230: PUSH
97231: FOR_IN
97232: IFFALSE 97258
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
97234: LD_VAR 0 3
97238: PUSH
97239: LD_INT 1
97241: ARRAY
97242: PPUSH
97243: LD_VAR 0 3
97247: PUSH
97248: LD_INT 2
97250: ARRAY
97251: PPUSH
97252: CALL_OW 235
97256: GO 97231
97258: POP
97259: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
97260: LD_ADDR_EXP 181
97264: PUSH
97265: LD_EXP 181
97269: PPUSH
97270: LD_VAR 0 4
97274: PPUSH
97275: EMPTY
97276: PPUSH
97277: CALL_OW 1
97281: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
97282: LD_VAR 0 1
97286: PPUSH
97287: LD_INT 0
97289: PPUSH
97290: CALL_OW 505
// end ; end ;
97294: LD_VAR 0 2
97298: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
97299: LD_INT 0
97301: PPUSH
97302: PPUSH
97303: PPUSH
// if not hack in hackTanks or not vehicles then
97304: LD_VAR 0 1
97308: PUSH
97309: LD_EXP 180
97313: IN
97314: NOT
97315: PUSH
97316: LD_VAR 0 2
97320: NOT
97321: OR
97322: IFFALSE 97326
// exit ;
97324: GO 97601
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
97326: LD_ADDR_VAR 0 2
97330: PUSH
97331: LD_VAR 0 1
97335: PPUSH
97336: LD_VAR 0 2
97340: PPUSH
97341: LD_INT 1
97343: PPUSH
97344: LD_INT 1
97346: PPUSH
97347: CALL 20104 0 4
97351: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
97352: LD_ADDR_VAR 0 5
97356: PUSH
97357: LD_EXP 180
97361: PPUSH
97362: LD_VAR 0 1
97366: PPUSH
97367: CALL 19454 0 2
97371: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
97372: LD_EXP 181
97376: PUSH
97377: LD_VAR 0 5
97381: ARRAY
97382: PUSH
97383: LD_EXP 182
97387: LESS
97388: IFFALSE 97577
// begin for i := 1 to vehicles do
97390: LD_ADDR_VAR 0 4
97394: PUSH
97395: DOUBLE
97396: LD_INT 1
97398: DEC
97399: ST_TO_ADDR
97400: LD_VAR 0 2
97404: PUSH
97405: FOR_TO
97406: IFFALSE 97575
// begin if hackTanksCaptured [ index ] = hackLimit then
97408: LD_EXP 181
97412: PUSH
97413: LD_VAR 0 5
97417: ARRAY
97418: PUSH
97419: LD_EXP 182
97423: EQUAL
97424: IFFALSE 97428
// break ;
97426: GO 97575
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
97428: LD_ADDR_EXP 184
97432: PUSH
97433: LD_EXP 184
97437: PPUSH
97438: LD_VAR 0 5
97442: PPUSH
97443: LD_EXP 184
97447: PUSH
97448: LD_VAR 0 5
97452: ARRAY
97453: PUSH
97454: LD_INT 1
97456: PLUS
97457: PPUSH
97458: CALL_OW 1
97462: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
97463: LD_ADDR_EXP 181
97467: PUSH
97468: LD_EXP 181
97472: PPUSH
97473: LD_VAR 0 5
97477: PUSH
97478: LD_EXP 181
97482: PUSH
97483: LD_VAR 0 5
97487: ARRAY
97488: PUSH
97489: LD_INT 1
97491: PLUS
97492: PUSH
97493: EMPTY
97494: LIST
97495: LIST
97496: PPUSH
97497: LD_VAR 0 2
97501: PUSH
97502: LD_VAR 0 4
97506: ARRAY
97507: PUSH
97508: LD_VAR 0 2
97512: PUSH
97513: LD_VAR 0 4
97517: ARRAY
97518: PPUSH
97519: CALL_OW 255
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: PPUSH
97528: CALL 19669 0 3
97532: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
97533: LD_VAR 0 2
97537: PUSH
97538: LD_VAR 0 4
97542: ARRAY
97543: PPUSH
97544: LD_VAR 0 1
97548: PPUSH
97549: CALL_OW 255
97553: PPUSH
97554: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
97558: LD_VAR 0 2
97562: PUSH
97563: LD_VAR 0 4
97567: ARRAY
97568: PPUSH
97569: CALL_OW 141
// end ;
97573: GO 97405
97575: POP
97576: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97577: LD_VAR 0 1
97581: PPUSH
97582: LD_EXP 181
97586: PUSH
97587: LD_VAR 0 5
97591: ARRAY
97592: PUSH
97593: LD_INT 0
97595: PLUS
97596: PPUSH
97597: CALL_OW 505
// end ;
97601: LD_VAR 0 3
97605: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
97606: LD_INT 0
97608: PPUSH
97609: PPUSH
97610: PPUSH
97611: PPUSH
// if not hack in hackTanks then
97612: LD_VAR 0 1
97616: PUSH
97617: LD_EXP 180
97621: IN
97622: NOT
97623: IFFALSE 97627
// exit ;
97625: GO 97867
// index := GetElementIndex ( hackTanks , hack ) ;
97627: LD_ADDR_VAR 0 4
97631: PUSH
97632: LD_EXP 180
97636: PPUSH
97637: LD_VAR 0 1
97641: PPUSH
97642: CALL 19454 0 2
97646: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
97647: LD_ADDR_VAR 0 3
97651: PUSH
97652: DOUBLE
97653: LD_EXP 181
97657: PUSH
97658: LD_VAR 0 4
97662: ARRAY
97663: INC
97664: ST_TO_ADDR
97665: LD_INT 1
97667: PUSH
97668: FOR_DOWNTO
97669: IFFALSE 97841
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
97671: LD_ADDR_VAR 0 5
97675: PUSH
97676: LD_EXP 181
97680: PUSH
97681: LD_VAR 0 4
97685: ARRAY
97686: PUSH
97687: LD_VAR 0 3
97691: ARRAY
97692: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
97693: LD_VAR 0 5
97697: PUSH
97698: LD_INT 1
97700: ARRAY
97701: PPUSH
97702: CALL_OW 302
97706: NOT
97707: PUSH
97708: LD_VAR 0 5
97712: PUSH
97713: LD_INT 1
97715: ARRAY
97716: PPUSH
97717: CALL_OW 255
97721: PUSH
97722: LD_VAR 0 1
97726: PPUSH
97727: CALL_OW 255
97731: NONEQUAL
97732: OR
97733: IFFALSE 97839
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
97735: LD_VAR 0 5
97739: PUSH
97740: LD_INT 1
97742: ARRAY
97743: PPUSH
97744: CALL_OW 305
97748: PUSH
97749: LD_VAR 0 5
97753: PUSH
97754: LD_INT 1
97756: ARRAY
97757: PPUSH
97758: CALL_OW 255
97762: PUSH
97763: LD_VAR 0 1
97767: PPUSH
97768: CALL_OW 255
97772: EQUAL
97773: AND
97774: IFFALSE 97798
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
97776: LD_VAR 0 5
97780: PUSH
97781: LD_INT 1
97783: ARRAY
97784: PPUSH
97785: LD_VAR 0 5
97789: PUSH
97790: LD_INT 2
97792: ARRAY
97793: PPUSH
97794: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
97798: LD_ADDR_EXP 181
97802: PUSH
97803: LD_EXP 181
97807: PPUSH
97808: LD_VAR 0 4
97812: PPUSH
97813: LD_EXP 181
97817: PUSH
97818: LD_VAR 0 4
97822: ARRAY
97823: PPUSH
97824: LD_VAR 0 3
97828: PPUSH
97829: CALL_OW 3
97833: PPUSH
97834: CALL_OW 1
97838: ST_TO_ADDR
// end ; end ;
97839: GO 97668
97841: POP
97842: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97843: LD_VAR 0 1
97847: PPUSH
97848: LD_EXP 181
97852: PUSH
97853: LD_VAR 0 4
97857: ARRAY
97858: PUSH
97859: LD_INT 0
97861: PLUS
97862: PPUSH
97863: CALL_OW 505
// end ;
97867: LD_VAR 0 2
97871: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
97872: LD_INT 0
97874: PPUSH
97875: PPUSH
97876: PPUSH
97877: PPUSH
// if not hack in hackTanks then
97878: LD_VAR 0 1
97882: PUSH
97883: LD_EXP 180
97887: IN
97888: NOT
97889: IFFALSE 97893
// exit ;
97891: GO 97978
// index := GetElementIndex ( hackTanks , hack ) ;
97893: LD_ADDR_VAR 0 5
97897: PUSH
97898: LD_EXP 180
97902: PPUSH
97903: LD_VAR 0 1
97907: PPUSH
97908: CALL 19454 0 2
97912: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
97913: LD_ADDR_VAR 0 4
97917: PUSH
97918: DOUBLE
97919: LD_INT 1
97921: DEC
97922: ST_TO_ADDR
97923: LD_EXP 181
97927: PUSH
97928: LD_VAR 0 5
97932: ARRAY
97933: PUSH
97934: FOR_TO
97935: IFFALSE 97976
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
97937: LD_EXP 181
97941: PUSH
97942: LD_VAR 0 5
97946: ARRAY
97947: PUSH
97948: LD_VAR 0 4
97952: ARRAY
97953: PUSH
97954: LD_INT 1
97956: ARRAY
97957: PUSH
97958: LD_VAR 0 2
97962: EQUAL
97963: IFFALSE 97974
// KillUnit ( vehicle ) ;
97965: LD_VAR 0 2
97969: PPUSH
97970: CALL_OW 66
97974: GO 97934
97976: POP
97977: POP
// end ;
97978: LD_VAR 0 3
97982: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
97983: LD_EXP 185
97987: NOT
97988: IFFALSE 98023
97990: GO 97992
97992: DISABLE
// begin initMiner := true ;
97993: LD_ADDR_EXP 185
97997: PUSH
97998: LD_INT 1
98000: ST_TO_ADDR
// minersList := [ ] ;
98001: LD_ADDR_EXP 186
98005: PUSH
98006: EMPTY
98007: ST_TO_ADDR
// minerMinesList := [ ] ;
98008: LD_ADDR_EXP 187
98012: PUSH
98013: EMPTY
98014: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
98015: LD_ADDR_EXP 188
98019: PUSH
98020: LD_INT 5
98022: ST_TO_ADDR
// end ;
98023: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
98024: LD_EXP 185
98028: PUSH
98029: LD_INT 34
98031: PUSH
98032: LD_EXP 110
98036: PUSH
98037: EMPTY
98038: LIST
98039: LIST
98040: PPUSH
98041: CALL_OW 69
98045: AND
98046: IFFALSE 98509
98048: GO 98050
98050: DISABLE
98051: LD_INT 0
98053: PPUSH
98054: PPUSH
98055: PPUSH
98056: PPUSH
// begin enable ;
98057: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
98058: LD_ADDR_VAR 0 1
98062: PUSH
98063: LD_INT 34
98065: PUSH
98066: LD_EXP 110
98070: PUSH
98071: EMPTY
98072: LIST
98073: LIST
98074: PPUSH
98075: CALL_OW 69
98079: PUSH
98080: FOR_IN
98081: IFFALSE 98153
// begin if not i in minersList then
98083: LD_VAR 0 1
98087: PUSH
98088: LD_EXP 186
98092: IN
98093: NOT
98094: IFFALSE 98151
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
98096: LD_ADDR_EXP 186
98100: PUSH
98101: LD_EXP 186
98105: PPUSH
98106: LD_EXP 186
98110: PUSH
98111: LD_INT 1
98113: PLUS
98114: PPUSH
98115: LD_VAR 0 1
98119: PPUSH
98120: CALL_OW 1
98124: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
98125: LD_ADDR_EXP 187
98129: PUSH
98130: LD_EXP 187
98134: PPUSH
98135: LD_EXP 187
98139: PUSH
98140: LD_INT 1
98142: PLUS
98143: PPUSH
98144: EMPTY
98145: PPUSH
98146: CALL_OW 1
98150: ST_TO_ADDR
// end end ;
98151: GO 98080
98153: POP
98154: POP
// for i := minerMinesList downto 1 do
98155: LD_ADDR_VAR 0 1
98159: PUSH
98160: DOUBLE
98161: LD_EXP 187
98165: INC
98166: ST_TO_ADDR
98167: LD_INT 1
98169: PUSH
98170: FOR_DOWNTO
98171: IFFALSE 98507
// begin if IsLive ( minersList [ i ] ) then
98173: LD_EXP 186
98177: PUSH
98178: LD_VAR 0 1
98182: ARRAY
98183: PPUSH
98184: CALL_OW 300
98188: IFFALSE 98216
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
98190: LD_EXP 186
98194: PUSH
98195: LD_VAR 0 1
98199: ARRAY
98200: PPUSH
98201: LD_EXP 187
98205: PUSH
98206: LD_VAR 0 1
98210: ARRAY
98211: PPUSH
98212: CALL_OW 505
// if not minerMinesList [ i ] then
98216: LD_EXP 187
98220: PUSH
98221: LD_VAR 0 1
98225: ARRAY
98226: NOT
98227: IFFALSE 98231
// continue ;
98229: GO 98170
// for j := minerMinesList [ i ] downto 1 do
98231: LD_ADDR_VAR 0 2
98235: PUSH
98236: DOUBLE
98237: LD_EXP 187
98241: PUSH
98242: LD_VAR 0 1
98246: ARRAY
98247: INC
98248: ST_TO_ADDR
98249: LD_INT 1
98251: PUSH
98252: FOR_DOWNTO
98253: IFFALSE 98503
// begin side := GetSide ( minersList [ i ] ) ;
98255: LD_ADDR_VAR 0 3
98259: PUSH
98260: LD_EXP 186
98264: PUSH
98265: LD_VAR 0 1
98269: ARRAY
98270: PPUSH
98271: CALL_OW 255
98275: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
98276: LD_ADDR_VAR 0 4
98280: PUSH
98281: LD_EXP 187
98285: PUSH
98286: LD_VAR 0 1
98290: ARRAY
98291: PUSH
98292: LD_VAR 0 2
98296: ARRAY
98297: PUSH
98298: LD_INT 1
98300: ARRAY
98301: PPUSH
98302: LD_EXP 187
98306: PUSH
98307: LD_VAR 0 1
98311: ARRAY
98312: PUSH
98313: LD_VAR 0 2
98317: ARRAY
98318: PUSH
98319: LD_INT 2
98321: ARRAY
98322: PPUSH
98323: CALL_OW 428
98327: ST_TO_ADDR
// if not tmp then
98328: LD_VAR 0 4
98332: NOT
98333: IFFALSE 98337
// continue ;
98335: GO 98252
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
98337: LD_VAR 0 4
98341: PUSH
98342: LD_INT 81
98344: PUSH
98345: LD_VAR 0 3
98349: PUSH
98350: EMPTY
98351: LIST
98352: LIST
98353: PPUSH
98354: CALL_OW 69
98358: IN
98359: PUSH
98360: LD_EXP 187
98364: PUSH
98365: LD_VAR 0 1
98369: ARRAY
98370: PUSH
98371: LD_VAR 0 2
98375: ARRAY
98376: PUSH
98377: LD_INT 1
98379: ARRAY
98380: PPUSH
98381: LD_EXP 187
98385: PUSH
98386: LD_VAR 0 1
98390: ARRAY
98391: PUSH
98392: LD_VAR 0 2
98396: ARRAY
98397: PUSH
98398: LD_INT 2
98400: ARRAY
98401: PPUSH
98402: CALL_OW 458
98406: AND
98407: IFFALSE 98501
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
98409: LD_EXP 187
98413: PUSH
98414: LD_VAR 0 1
98418: ARRAY
98419: PUSH
98420: LD_VAR 0 2
98424: ARRAY
98425: PUSH
98426: LD_INT 1
98428: ARRAY
98429: PPUSH
98430: LD_EXP 187
98434: PUSH
98435: LD_VAR 0 1
98439: ARRAY
98440: PUSH
98441: LD_VAR 0 2
98445: ARRAY
98446: PUSH
98447: LD_INT 2
98449: ARRAY
98450: PPUSH
98451: LD_VAR 0 3
98455: PPUSH
98456: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
98460: LD_ADDR_EXP 187
98464: PUSH
98465: LD_EXP 187
98469: PPUSH
98470: LD_VAR 0 1
98474: PPUSH
98475: LD_EXP 187
98479: PUSH
98480: LD_VAR 0 1
98484: ARRAY
98485: PPUSH
98486: LD_VAR 0 2
98490: PPUSH
98491: CALL_OW 3
98495: PPUSH
98496: CALL_OW 1
98500: ST_TO_ADDR
// end ; end ;
98501: GO 98252
98503: POP
98504: POP
// end ;
98505: GO 98170
98507: POP
98508: POP
// end ;
98509: PPOPN 4
98511: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
98512: LD_INT 0
98514: PPUSH
98515: PPUSH
// result := false ;
98516: LD_ADDR_VAR 0 4
98520: PUSH
98521: LD_INT 0
98523: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
98524: LD_VAR 0 1
98528: PPUSH
98529: CALL_OW 264
98533: PUSH
98534: LD_EXP 110
98538: EQUAL
98539: NOT
98540: IFFALSE 98544
// exit ;
98542: GO 98784
// index := GetElementIndex ( minersList , unit ) ;
98544: LD_ADDR_VAR 0 5
98548: PUSH
98549: LD_EXP 186
98553: PPUSH
98554: LD_VAR 0 1
98558: PPUSH
98559: CALL 19454 0 2
98563: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
98564: LD_EXP 187
98568: PUSH
98569: LD_VAR 0 5
98573: ARRAY
98574: PUSH
98575: LD_EXP 188
98579: GREATEREQUAL
98580: IFFALSE 98584
// exit ;
98582: GO 98784
// ComMoveXY ( unit , x , y ) ;
98584: LD_VAR 0 1
98588: PPUSH
98589: LD_VAR 0 2
98593: PPUSH
98594: LD_VAR 0 3
98598: PPUSH
98599: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98603: LD_INT 35
98605: PPUSH
98606: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
98610: LD_VAR 0 1
98614: PPUSH
98615: LD_VAR 0 2
98619: PPUSH
98620: LD_VAR 0 3
98624: PPUSH
98625: CALL 49821 0 3
98629: NOT
98630: PUSH
98631: LD_VAR 0 1
98635: PPUSH
98636: CALL_OW 314
98640: AND
98641: IFFALSE 98645
// exit ;
98643: GO 98784
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
98645: LD_VAR 0 2
98649: PPUSH
98650: LD_VAR 0 3
98654: PPUSH
98655: CALL_OW 428
98659: PUSH
98660: LD_VAR 0 1
98664: EQUAL
98665: PUSH
98666: LD_VAR 0 1
98670: PPUSH
98671: CALL_OW 314
98675: NOT
98676: AND
98677: IFFALSE 98603
// PlaySoundXY ( x , y , PlantMine ) ;
98679: LD_VAR 0 2
98683: PPUSH
98684: LD_VAR 0 3
98688: PPUSH
98689: LD_STRING PlantMine
98691: PPUSH
98692: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
98696: LD_VAR 0 2
98700: PPUSH
98701: LD_VAR 0 3
98705: PPUSH
98706: LD_VAR 0 1
98710: PPUSH
98711: CALL_OW 255
98715: PPUSH
98716: LD_INT 0
98718: PPUSH
98719: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
98723: LD_ADDR_EXP 187
98727: PUSH
98728: LD_EXP 187
98732: PPUSH
98733: LD_VAR 0 5
98737: PUSH
98738: LD_EXP 187
98742: PUSH
98743: LD_VAR 0 5
98747: ARRAY
98748: PUSH
98749: LD_INT 1
98751: PLUS
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PPUSH
98757: LD_VAR 0 2
98761: PUSH
98762: LD_VAR 0 3
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PPUSH
98771: CALL 19669 0 3
98775: ST_TO_ADDR
// result := true ;
98776: LD_ADDR_VAR 0 4
98780: PUSH
98781: LD_INT 1
98783: ST_TO_ADDR
// end ;
98784: LD_VAR 0 4
98788: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
98789: LD_INT 0
98791: PPUSH
98792: PPUSH
98793: PPUSH
// if not unit in minersList then
98794: LD_VAR 0 1
98798: PUSH
98799: LD_EXP 186
98803: IN
98804: NOT
98805: IFFALSE 98809
// exit ;
98807: GO 99201
// index := GetElementIndex ( minersList , unit ) ;
98809: LD_ADDR_VAR 0 6
98813: PUSH
98814: LD_EXP 186
98818: PPUSH
98819: LD_VAR 0 1
98823: PPUSH
98824: CALL 19454 0 2
98828: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
98829: LD_ADDR_VAR 0 5
98833: PUSH
98834: DOUBLE
98835: LD_EXP 187
98839: PUSH
98840: LD_VAR 0 6
98844: ARRAY
98845: INC
98846: ST_TO_ADDR
98847: LD_INT 1
98849: PUSH
98850: FOR_DOWNTO
98851: IFFALSE 99012
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
98853: LD_EXP 187
98857: PUSH
98858: LD_VAR 0 6
98862: ARRAY
98863: PUSH
98864: LD_VAR 0 5
98868: ARRAY
98869: PUSH
98870: LD_INT 1
98872: ARRAY
98873: PUSH
98874: LD_VAR 0 2
98878: EQUAL
98879: PUSH
98880: LD_EXP 187
98884: PUSH
98885: LD_VAR 0 6
98889: ARRAY
98890: PUSH
98891: LD_VAR 0 5
98895: ARRAY
98896: PUSH
98897: LD_INT 2
98899: ARRAY
98900: PUSH
98901: LD_VAR 0 3
98905: EQUAL
98906: AND
98907: IFFALSE 99010
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98909: LD_EXP 187
98913: PUSH
98914: LD_VAR 0 6
98918: ARRAY
98919: PUSH
98920: LD_VAR 0 5
98924: ARRAY
98925: PUSH
98926: LD_INT 1
98928: ARRAY
98929: PPUSH
98930: LD_EXP 187
98934: PUSH
98935: LD_VAR 0 6
98939: ARRAY
98940: PUSH
98941: LD_VAR 0 5
98945: ARRAY
98946: PUSH
98947: LD_INT 2
98949: ARRAY
98950: PPUSH
98951: LD_VAR 0 1
98955: PPUSH
98956: CALL_OW 255
98960: PPUSH
98961: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98965: LD_ADDR_EXP 187
98969: PUSH
98970: LD_EXP 187
98974: PPUSH
98975: LD_VAR 0 6
98979: PPUSH
98980: LD_EXP 187
98984: PUSH
98985: LD_VAR 0 6
98989: ARRAY
98990: PPUSH
98991: LD_VAR 0 5
98995: PPUSH
98996: CALL_OW 3
99000: PPUSH
99001: CALL_OW 1
99005: ST_TO_ADDR
// exit ;
99006: POP
99007: POP
99008: GO 99201
// end ; end ;
99010: GO 98850
99012: POP
99013: POP
// for i := minerMinesList [ index ] downto 1 do
99014: LD_ADDR_VAR 0 5
99018: PUSH
99019: DOUBLE
99020: LD_EXP 187
99024: PUSH
99025: LD_VAR 0 6
99029: ARRAY
99030: INC
99031: ST_TO_ADDR
99032: LD_INT 1
99034: PUSH
99035: FOR_DOWNTO
99036: IFFALSE 99199
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
99038: LD_EXP 187
99042: PUSH
99043: LD_VAR 0 6
99047: ARRAY
99048: PUSH
99049: LD_VAR 0 5
99053: ARRAY
99054: PUSH
99055: LD_INT 1
99057: ARRAY
99058: PPUSH
99059: LD_EXP 187
99063: PUSH
99064: LD_VAR 0 6
99068: ARRAY
99069: PUSH
99070: LD_VAR 0 5
99074: ARRAY
99075: PUSH
99076: LD_INT 2
99078: ARRAY
99079: PPUSH
99080: LD_VAR 0 2
99084: PPUSH
99085: LD_VAR 0 3
99089: PPUSH
99090: CALL_OW 298
99094: PUSH
99095: LD_INT 6
99097: LESS
99098: IFFALSE 99197
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
99100: LD_EXP 187
99104: PUSH
99105: LD_VAR 0 6
99109: ARRAY
99110: PUSH
99111: LD_VAR 0 5
99115: ARRAY
99116: PUSH
99117: LD_INT 1
99119: ARRAY
99120: PPUSH
99121: LD_EXP 187
99125: PUSH
99126: LD_VAR 0 6
99130: ARRAY
99131: PUSH
99132: LD_VAR 0 5
99136: ARRAY
99137: PUSH
99138: LD_INT 2
99140: ARRAY
99141: PPUSH
99142: LD_VAR 0 1
99146: PPUSH
99147: CALL_OW 255
99151: PPUSH
99152: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
99156: LD_ADDR_EXP 187
99160: PUSH
99161: LD_EXP 187
99165: PPUSH
99166: LD_VAR 0 6
99170: PPUSH
99171: LD_EXP 187
99175: PUSH
99176: LD_VAR 0 6
99180: ARRAY
99181: PPUSH
99182: LD_VAR 0 5
99186: PPUSH
99187: CALL_OW 3
99191: PPUSH
99192: CALL_OW 1
99196: ST_TO_ADDR
// end ; end ;
99197: GO 99035
99199: POP
99200: POP
// end ;
99201: LD_VAR 0 4
99205: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
99206: LD_INT 0
99208: PPUSH
99209: PPUSH
99210: PPUSH
99211: PPUSH
99212: PPUSH
99213: PPUSH
99214: PPUSH
99215: PPUSH
99216: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
99217: LD_VAR 0 1
99221: PPUSH
99222: CALL_OW 264
99226: PUSH
99227: LD_EXP 110
99231: EQUAL
99232: NOT
99233: PUSH
99234: LD_VAR 0 1
99238: PUSH
99239: LD_EXP 186
99243: IN
99244: NOT
99245: OR
99246: IFFALSE 99250
// exit ;
99248: GO 99572
// index := GetElementIndex ( minersList , unit ) ;
99250: LD_ADDR_VAR 0 6
99254: PUSH
99255: LD_EXP 186
99259: PPUSH
99260: LD_VAR 0 1
99264: PPUSH
99265: CALL 19454 0 2
99269: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
99270: LD_ADDR_VAR 0 8
99274: PUSH
99275: LD_EXP 188
99279: PUSH
99280: LD_EXP 187
99284: PUSH
99285: LD_VAR 0 6
99289: ARRAY
99290: MINUS
99291: ST_TO_ADDR
// if not minesFreeAmount then
99292: LD_VAR 0 8
99296: NOT
99297: IFFALSE 99301
// exit ;
99299: GO 99572
// tmp := [ ] ;
99301: LD_ADDR_VAR 0 7
99305: PUSH
99306: EMPTY
99307: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
99308: LD_ADDR_VAR 0 5
99312: PUSH
99313: DOUBLE
99314: LD_INT 1
99316: DEC
99317: ST_TO_ADDR
99318: LD_VAR 0 8
99322: PUSH
99323: FOR_TO
99324: IFFALSE 99519
// begin _d := rand ( 0 , 5 ) ;
99326: LD_ADDR_VAR 0 11
99330: PUSH
99331: LD_INT 0
99333: PPUSH
99334: LD_INT 5
99336: PPUSH
99337: CALL_OW 12
99341: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
99342: LD_ADDR_VAR 0 12
99346: PUSH
99347: LD_INT 2
99349: PPUSH
99350: LD_INT 6
99352: PPUSH
99353: CALL_OW 12
99357: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
99358: LD_ADDR_VAR 0 9
99362: PUSH
99363: LD_VAR 0 2
99367: PPUSH
99368: LD_VAR 0 11
99372: PPUSH
99373: LD_VAR 0 12
99377: PPUSH
99378: CALL_OW 272
99382: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
99383: LD_ADDR_VAR 0 10
99387: PUSH
99388: LD_VAR 0 3
99392: PPUSH
99393: LD_VAR 0 11
99397: PPUSH
99398: LD_VAR 0 12
99402: PPUSH
99403: CALL_OW 273
99407: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
99408: LD_VAR 0 9
99412: PPUSH
99413: LD_VAR 0 10
99417: PPUSH
99418: CALL_OW 488
99422: PUSH
99423: LD_VAR 0 9
99427: PUSH
99428: LD_VAR 0 10
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: LD_VAR 0 7
99441: IN
99442: NOT
99443: AND
99444: PUSH
99445: LD_VAR 0 9
99449: PPUSH
99450: LD_VAR 0 10
99454: PPUSH
99455: CALL_OW 458
99459: NOT
99460: AND
99461: IFFALSE 99503
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
99463: LD_ADDR_VAR 0 7
99467: PUSH
99468: LD_VAR 0 7
99472: PPUSH
99473: LD_VAR 0 7
99477: PUSH
99478: LD_INT 1
99480: PLUS
99481: PPUSH
99482: LD_VAR 0 9
99486: PUSH
99487: LD_VAR 0 10
99491: PUSH
99492: EMPTY
99493: LIST
99494: LIST
99495: PPUSH
99496: CALL_OW 1
99500: ST_TO_ADDR
99501: GO 99517
// i := i - 1 ;
99503: LD_ADDR_VAR 0 5
99507: PUSH
99508: LD_VAR 0 5
99512: PUSH
99513: LD_INT 1
99515: MINUS
99516: ST_TO_ADDR
// end ;
99517: GO 99323
99519: POP
99520: POP
// for i in tmp do
99521: LD_ADDR_VAR 0 5
99525: PUSH
99526: LD_VAR 0 7
99530: PUSH
99531: FOR_IN
99532: IFFALSE 99570
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
99534: LD_VAR 0 1
99538: PPUSH
99539: LD_VAR 0 5
99543: PUSH
99544: LD_INT 1
99546: ARRAY
99547: PPUSH
99548: LD_VAR 0 5
99552: PUSH
99553: LD_INT 2
99555: ARRAY
99556: PPUSH
99557: CALL 98512 0 3
99561: NOT
99562: IFFALSE 99568
// exit ;
99564: POP
99565: POP
99566: GO 99572
99568: GO 99531
99570: POP
99571: POP
// end ;
99572: LD_VAR 0 4
99576: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
99577: LD_INT 0
99579: PPUSH
99580: PPUSH
99581: PPUSH
99582: PPUSH
99583: PPUSH
99584: PPUSH
99585: PPUSH
// if not GetClass ( unit ) = class_sniper then
99586: LD_VAR 0 1
99590: PPUSH
99591: CALL_OW 257
99595: PUSH
99596: LD_INT 5
99598: EQUAL
99599: NOT
99600: IFFALSE 99604
// exit ;
99602: GO 99992
// dist := 8 ;
99604: LD_ADDR_VAR 0 5
99608: PUSH
99609: LD_INT 8
99611: ST_TO_ADDR
// viewRange := 12 ;
99612: LD_ADDR_VAR 0 7
99616: PUSH
99617: LD_INT 12
99619: ST_TO_ADDR
// side := GetSide ( unit ) ;
99620: LD_ADDR_VAR 0 6
99624: PUSH
99625: LD_VAR 0 1
99629: PPUSH
99630: CALL_OW 255
99634: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
99635: LD_INT 61
99637: PPUSH
99638: LD_VAR 0 6
99642: PPUSH
99643: CALL_OW 321
99647: PUSH
99648: LD_INT 2
99650: EQUAL
99651: IFFALSE 99661
// viewRange := 16 ;
99653: LD_ADDR_VAR 0 7
99657: PUSH
99658: LD_INT 16
99660: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
99661: LD_VAR 0 1
99665: PPUSH
99666: LD_VAR 0 2
99670: PPUSH
99671: LD_VAR 0 3
99675: PPUSH
99676: CALL_OW 297
99680: PUSH
99681: LD_VAR 0 5
99685: GREATER
99686: IFFALSE 99765
// begin ComMoveXY ( unit , x , y ) ;
99688: LD_VAR 0 1
99692: PPUSH
99693: LD_VAR 0 2
99697: PPUSH
99698: LD_VAR 0 3
99702: PPUSH
99703: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
99707: LD_INT 35
99709: PPUSH
99710: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
99714: LD_VAR 0 1
99718: PPUSH
99719: LD_VAR 0 2
99723: PPUSH
99724: LD_VAR 0 3
99728: PPUSH
99729: CALL 49821 0 3
99733: NOT
99734: IFFALSE 99738
// exit ;
99736: GO 99992
// until GetDistUnitXY ( unit , x , y ) < dist ;
99738: LD_VAR 0 1
99742: PPUSH
99743: LD_VAR 0 2
99747: PPUSH
99748: LD_VAR 0 3
99752: PPUSH
99753: CALL_OW 297
99757: PUSH
99758: LD_VAR 0 5
99762: LESS
99763: IFFALSE 99707
// end ; ComTurnXY ( unit , x , y ) ;
99765: LD_VAR 0 1
99769: PPUSH
99770: LD_VAR 0 2
99774: PPUSH
99775: LD_VAR 0 3
99779: PPUSH
99780: CALL_OW 118
// wait ( 5 ) ;
99784: LD_INT 5
99786: PPUSH
99787: CALL_OW 67
// _d := GetDir ( unit ) ;
99791: LD_ADDR_VAR 0 10
99795: PUSH
99796: LD_VAR 0 1
99800: PPUSH
99801: CALL_OW 254
99805: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
99806: LD_ADDR_VAR 0 8
99810: PUSH
99811: LD_VAR 0 1
99815: PPUSH
99816: CALL_OW 250
99820: PPUSH
99821: LD_VAR 0 10
99825: PPUSH
99826: LD_VAR 0 5
99830: PPUSH
99831: CALL_OW 272
99835: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
99836: LD_ADDR_VAR 0 9
99840: PUSH
99841: LD_VAR 0 1
99845: PPUSH
99846: CALL_OW 251
99850: PPUSH
99851: LD_VAR 0 10
99855: PPUSH
99856: LD_VAR 0 5
99860: PPUSH
99861: CALL_OW 273
99865: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
99866: LD_VAR 0 8
99870: PPUSH
99871: LD_VAR 0 9
99875: PPUSH
99876: CALL_OW 488
99880: NOT
99881: IFFALSE 99885
// exit ;
99883: GO 99992
// ComAnimCustom ( unit , 1 ) ;
99885: LD_VAR 0 1
99889: PPUSH
99890: LD_INT 1
99892: PPUSH
99893: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
99897: LD_VAR 0 8
99901: PPUSH
99902: LD_VAR 0 9
99906: PPUSH
99907: LD_VAR 0 6
99911: PPUSH
99912: LD_VAR 0 7
99916: PPUSH
99917: CALL_OW 330
// repeat wait ( 1 ) ;
99921: LD_INT 1
99923: PPUSH
99924: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
99928: LD_VAR 0 1
99932: PPUSH
99933: CALL_OW 316
99937: PUSH
99938: LD_VAR 0 1
99942: PPUSH
99943: CALL_OW 314
99947: OR
99948: PUSH
99949: LD_VAR 0 1
99953: PPUSH
99954: CALL_OW 302
99958: NOT
99959: OR
99960: PUSH
99961: LD_VAR 0 1
99965: PPUSH
99966: CALL_OW 301
99970: OR
99971: IFFALSE 99921
// RemoveSeeing ( _x , _y , side ) ;
99973: LD_VAR 0 8
99977: PPUSH
99978: LD_VAR 0 9
99982: PPUSH
99983: LD_VAR 0 6
99987: PPUSH
99988: CALL_OW 331
// end ; end_of_file
99992: LD_VAR 0 4
99996: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99997: LD_INT 0
99999: PPUSH
100000: PPUSH
100001: PPUSH
100002: PPUSH
100003: PPUSH
100004: PPUSH
100005: PPUSH
100006: PPUSH
100007: PPUSH
100008: PPUSH
100009: PPUSH
100010: PPUSH
100011: PPUSH
100012: PPUSH
100013: PPUSH
100014: PPUSH
100015: PPUSH
100016: PPUSH
100017: PPUSH
100018: PPUSH
100019: PPUSH
100020: PPUSH
100021: PPUSH
100022: PPUSH
100023: PPUSH
100024: PPUSH
100025: PPUSH
100026: PPUSH
100027: PPUSH
100028: PPUSH
100029: PPUSH
100030: PPUSH
100031: PPUSH
100032: PPUSH
// if not list then
100033: LD_VAR 0 1
100037: NOT
100038: IFFALSE 100042
// exit ;
100040: GO 104701
// base := list [ 1 ] ;
100042: LD_ADDR_VAR 0 3
100046: PUSH
100047: LD_VAR 0 1
100051: PUSH
100052: LD_INT 1
100054: ARRAY
100055: ST_TO_ADDR
// group := list [ 2 ] ;
100056: LD_ADDR_VAR 0 4
100060: PUSH
100061: LD_VAR 0 1
100065: PUSH
100066: LD_INT 2
100068: ARRAY
100069: ST_TO_ADDR
// path := list [ 3 ] ;
100070: LD_ADDR_VAR 0 5
100074: PUSH
100075: LD_VAR 0 1
100079: PUSH
100080: LD_INT 3
100082: ARRAY
100083: ST_TO_ADDR
// flags := list [ 4 ] ;
100084: LD_ADDR_VAR 0 6
100088: PUSH
100089: LD_VAR 0 1
100093: PUSH
100094: LD_INT 4
100096: ARRAY
100097: ST_TO_ADDR
// mined := [ ] ;
100098: LD_ADDR_VAR 0 27
100102: PUSH
100103: EMPTY
100104: ST_TO_ADDR
// bombed := [ ] ;
100105: LD_ADDR_VAR 0 28
100109: PUSH
100110: EMPTY
100111: ST_TO_ADDR
// healers := [ ] ;
100112: LD_ADDR_VAR 0 31
100116: PUSH
100117: EMPTY
100118: ST_TO_ADDR
// to_heal := [ ] ;
100119: LD_ADDR_VAR 0 30
100123: PUSH
100124: EMPTY
100125: ST_TO_ADDR
// repairs := [ ] ;
100126: LD_ADDR_VAR 0 33
100130: PUSH
100131: EMPTY
100132: ST_TO_ADDR
// to_repair := [ ] ;
100133: LD_ADDR_VAR 0 32
100137: PUSH
100138: EMPTY
100139: ST_TO_ADDR
// if not group or not path then
100140: LD_VAR 0 4
100144: NOT
100145: PUSH
100146: LD_VAR 0 5
100150: NOT
100151: OR
100152: IFFALSE 100156
// exit ;
100154: GO 104701
// side := GetSide ( group [ 1 ] ) ;
100156: LD_ADDR_VAR 0 35
100160: PUSH
100161: LD_VAR 0 4
100165: PUSH
100166: LD_INT 1
100168: ARRAY
100169: PPUSH
100170: CALL_OW 255
100174: ST_TO_ADDR
// if flags then
100175: LD_VAR 0 6
100179: IFFALSE 100323
// begin f_ignore_area := flags [ 1 ] ;
100181: LD_ADDR_VAR 0 17
100185: PUSH
100186: LD_VAR 0 6
100190: PUSH
100191: LD_INT 1
100193: ARRAY
100194: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100195: LD_ADDR_VAR 0 18
100199: PUSH
100200: LD_VAR 0 6
100204: PUSH
100205: LD_INT 2
100207: ARRAY
100208: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100209: LD_ADDR_VAR 0 19
100213: PUSH
100214: LD_VAR 0 6
100218: PUSH
100219: LD_INT 3
100221: ARRAY
100222: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100223: LD_ADDR_VAR 0 20
100227: PUSH
100228: LD_VAR 0 6
100232: PUSH
100233: LD_INT 4
100235: ARRAY
100236: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100237: LD_ADDR_VAR 0 21
100241: PUSH
100242: LD_VAR 0 6
100246: PUSH
100247: LD_INT 5
100249: ARRAY
100250: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100251: LD_ADDR_VAR 0 22
100255: PUSH
100256: LD_VAR 0 6
100260: PUSH
100261: LD_INT 6
100263: ARRAY
100264: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100265: LD_ADDR_VAR 0 23
100269: PUSH
100270: LD_VAR 0 6
100274: PUSH
100275: LD_INT 7
100277: ARRAY
100278: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100279: LD_ADDR_VAR 0 24
100283: PUSH
100284: LD_VAR 0 6
100288: PUSH
100289: LD_INT 8
100291: ARRAY
100292: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100293: LD_ADDR_VAR 0 25
100297: PUSH
100298: LD_VAR 0 6
100302: PUSH
100303: LD_INT 9
100305: ARRAY
100306: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100307: LD_ADDR_VAR 0 26
100311: PUSH
100312: LD_VAR 0 6
100316: PUSH
100317: LD_INT 10
100319: ARRAY
100320: ST_TO_ADDR
// end else
100321: GO 100403
// begin f_ignore_area := false ;
100323: LD_ADDR_VAR 0 17
100327: PUSH
100328: LD_INT 0
100330: ST_TO_ADDR
// f_capture := false ;
100331: LD_ADDR_VAR 0 18
100335: PUSH
100336: LD_INT 0
100338: ST_TO_ADDR
// f_ignore_civ := false ;
100339: LD_ADDR_VAR 0 19
100343: PUSH
100344: LD_INT 0
100346: ST_TO_ADDR
// f_murder := false ;
100347: LD_ADDR_VAR 0 20
100351: PUSH
100352: LD_INT 0
100354: ST_TO_ADDR
// f_mines := false ;
100355: LD_ADDR_VAR 0 21
100359: PUSH
100360: LD_INT 0
100362: ST_TO_ADDR
// f_repair := false ;
100363: LD_ADDR_VAR 0 22
100367: PUSH
100368: LD_INT 0
100370: ST_TO_ADDR
// f_heal := false ;
100371: LD_ADDR_VAR 0 23
100375: PUSH
100376: LD_INT 0
100378: ST_TO_ADDR
// f_spacetime := false ;
100379: LD_ADDR_VAR 0 24
100383: PUSH
100384: LD_INT 0
100386: ST_TO_ADDR
// f_attack_depot := false ;
100387: LD_ADDR_VAR 0 25
100391: PUSH
100392: LD_INT 0
100394: ST_TO_ADDR
// f_crawl := false ;
100395: LD_ADDR_VAR 0 26
100399: PUSH
100400: LD_INT 0
100402: ST_TO_ADDR
// end ; if f_heal then
100403: LD_VAR 0 23
100407: IFFALSE 100434
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100409: LD_ADDR_VAR 0 31
100413: PUSH
100414: LD_VAR 0 4
100418: PPUSH
100419: LD_INT 25
100421: PUSH
100422: LD_INT 4
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PPUSH
100429: CALL_OW 72
100433: ST_TO_ADDR
// if f_repair then
100434: LD_VAR 0 22
100438: IFFALSE 100465
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100440: LD_ADDR_VAR 0 33
100444: PUSH
100445: LD_VAR 0 4
100449: PPUSH
100450: LD_INT 25
100452: PUSH
100453: LD_INT 3
100455: PUSH
100456: EMPTY
100457: LIST
100458: LIST
100459: PPUSH
100460: CALL_OW 72
100464: ST_TO_ADDR
// units_path := [ ] ;
100465: LD_ADDR_VAR 0 16
100469: PUSH
100470: EMPTY
100471: ST_TO_ADDR
// for i = 1 to group do
100472: LD_ADDR_VAR 0 7
100476: PUSH
100477: DOUBLE
100478: LD_INT 1
100480: DEC
100481: ST_TO_ADDR
100482: LD_VAR 0 4
100486: PUSH
100487: FOR_TO
100488: IFFALSE 100517
// units_path := Replace ( units_path , i , path ) ;
100490: LD_ADDR_VAR 0 16
100494: PUSH
100495: LD_VAR 0 16
100499: PPUSH
100500: LD_VAR 0 7
100504: PPUSH
100505: LD_VAR 0 5
100509: PPUSH
100510: CALL_OW 1
100514: ST_TO_ADDR
100515: GO 100487
100517: POP
100518: POP
// repeat for i = group downto 1 do
100519: LD_ADDR_VAR 0 7
100523: PUSH
100524: DOUBLE
100525: LD_VAR 0 4
100529: INC
100530: ST_TO_ADDR
100531: LD_INT 1
100533: PUSH
100534: FOR_DOWNTO
100535: IFFALSE 104657
// begin wait ( 5 ) ;
100537: LD_INT 5
100539: PPUSH
100540: CALL_OW 67
// tmp := [ ] ;
100544: LD_ADDR_VAR 0 14
100548: PUSH
100549: EMPTY
100550: ST_TO_ADDR
// attacking := false ;
100551: LD_ADDR_VAR 0 29
100555: PUSH
100556: LD_INT 0
100558: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100559: LD_VAR 0 4
100563: PUSH
100564: LD_VAR 0 7
100568: ARRAY
100569: PPUSH
100570: CALL_OW 301
100574: PUSH
100575: LD_VAR 0 4
100579: PUSH
100580: LD_VAR 0 7
100584: ARRAY
100585: NOT
100586: OR
100587: IFFALSE 100696
// begin if GetType ( group [ i ] ) = unit_human then
100589: LD_VAR 0 4
100593: PUSH
100594: LD_VAR 0 7
100598: ARRAY
100599: PPUSH
100600: CALL_OW 247
100604: PUSH
100605: LD_INT 1
100607: EQUAL
100608: IFFALSE 100654
// begin to_heal := to_heal diff group [ i ] ;
100610: LD_ADDR_VAR 0 30
100614: PUSH
100615: LD_VAR 0 30
100619: PUSH
100620: LD_VAR 0 4
100624: PUSH
100625: LD_VAR 0 7
100629: ARRAY
100630: DIFF
100631: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100632: LD_ADDR_VAR 0 31
100636: PUSH
100637: LD_VAR 0 31
100641: PUSH
100642: LD_VAR 0 4
100646: PUSH
100647: LD_VAR 0 7
100651: ARRAY
100652: DIFF
100653: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100654: LD_ADDR_VAR 0 4
100658: PUSH
100659: LD_VAR 0 4
100663: PPUSH
100664: LD_VAR 0 7
100668: PPUSH
100669: CALL_OW 3
100673: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100674: LD_ADDR_VAR 0 16
100678: PUSH
100679: LD_VAR 0 16
100683: PPUSH
100684: LD_VAR 0 7
100688: PPUSH
100689: CALL_OW 3
100693: ST_TO_ADDR
// continue ;
100694: GO 100534
// end ; if f_repair then
100696: LD_VAR 0 22
100700: IFFALSE 101189
// begin if GetType ( group [ i ] ) = unit_vehicle then
100702: LD_VAR 0 4
100706: PUSH
100707: LD_VAR 0 7
100711: ARRAY
100712: PPUSH
100713: CALL_OW 247
100717: PUSH
100718: LD_INT 2
100720: EQUAL
100721: IFFALSE 100911
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100723: LD_VAR 0 4
100727: PUSH
100728: LD_VAR 0 7
100732: ARRAY
100733: PPUSH
100734: CALL_OW 256
100738: PUSH
100739: LD_INT 700
100741: LESS
100742: PUSH
100743: LD_VAR 0 4
100747: PUSH
100748: LD_VAR 0 7
100752: ARRAY
100753: PUSH
100754: LD_VAR 0 32
100758: IN
100759: NOT
100760: AND
100761: IFFALSE 100785
// to_repair := to_repair union group [ i ] ;
100763: LD_ADDR_VAR 0 32
100767: PUSH
100768: LD_VAR 0 32
100772: PUSH
100773: LD_VAR 0 4
100777: PUSH
100778: LD_VAR 0 7
100782: ARRAY
100783: UNION
100784: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100785: LD_VAR 0 4
100789: PUSH
100790: LD_VAR 0 7
100794: ARRAY
100795: PPUSH
100796: CALL_OW 256
100800: PUSH
100801: LD_INT 1000
100803: EQUAL
100804: PUSH
100805: LD_VAR 0 4
100809: PUSH
100810: LD_VAR 0 7
100814: ARRAY
100815: PUSH
100816: LD_VAR 0 32
100820: IN
100821: AND
100822: IFFALSE 100846
// to_repair := to_repair diff group [ i ] ;
100824: LD_ADDR_VAR 0 32
100828: PUSH
100829: LD_VAR 0 32
100833: PUSH
100834: LD_VAR 0 4
100838: PUSH
100839: LD_VAR 0 7
100843: ARRAY
100844: DIFF
100845: ST_TO_ADDR
// if group [ i ] in to_repair then
100846: LD_VAR 0 4
100850: PUSH
100851: LD_VAR 0 7
100855: ARRAY
100856: PUSH
100857: LD_VAR 0 32
100861: IN
100862: IFFALSE 100909
// begin if not IsInArea ( group [ i ] , f_repair ) then
100864: LD_VAR 0 4
100868: PUSH
100869: LD_VAR 0 7
100873: ARRAY
100874: PPUSH
100875: LD_VAR 0 22
100879: PPUSH
100880: CALL_OW 308
100884: NOT
100885: IFFALSE 100907
// ComMoveToArea ( group [ i ] , f_repair ) ;
100887: LD_VAR 0 4
100891: PUSH
100892: LD_VAR 0 7
100896: ARRAY
100897: PPUSH
100898: LD_VAR 0 22
100902: PPUSH
100903: CALL_OW 113
// continue ;
100907: GO 100534
// end ; end else
100909: GO 101189
// if group [ i ] in repairs then
100911: LD_VAR 0 4
100915: PUSH
100916: LD_VAR 0 7
100920: ARRAY
100921: PUSH
100922: LD_VAR 0 33
100926: IN
100927: IFFALSE 101189
// begin if IsInUnit ( group [ i ] ) then
100929: LD_VAR 0 4
100933: PUSH
100934: LD_VAR 0 7
100938: ARRAY
100939: PPUSH
100940: CALL_OW 310
100944: IFFALSE 101012
// begin z := IsInUnit ( group [ i ] ) ;
100946: LD_ADDR_VAR 0 13
100950: PUSH
100951: LD_VAR 0 4
100955: PUSH
100956: LD_VAR 0 7
100960: ARRAY
100961: PPUSH
100962: CALL_OW 310
100966: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100967: LD_VAR 0 13
100971: PUSH
100972: LD_VAR 0 32
100976: IN
100977: PUSH
100978: LD_VAR 0 13
100982: PPUSH
100983: LD_VAR 0 22
100987: PPUSH
100988: CALL_OW 308
100992: AND
100993: IFFALSE 101010
// ComExitVehicle ( group [ i ] ) ;
100995: LD_VAR 0 4
100999: PUSH
101000: LD_VAR 0 7
101004: ARRAY
101005: PPUSH
101006: CALL_OW 121
// end else
101010: GO 101189
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101012: LD_ADDR_VAR 0 13
101016: PUSH
101017: LD_VAR 0 4
101021: PPUSH
101022: LD_INT 95
101024: PUSH
101025: LD_VAR 0 22
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: PUSH
101034: LD_INT 58
101036: PUSH
101037: EMPTY
101038: LIST
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PPUSH
101044: CALL_OW 72
101048: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101049: LD_VAR 0 4
101053: PUSH
101054: LD_VAR 0 7
101058: ARRAY
101059: PPUSH
101060: CALL_OW 314
101064: NOT
101065: IFFALSE 101187
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101067: LD_ADDR_VAR 0 10
101071: PUSH
101072: LD_VAR 0 13
101076: PPUSH
101077: LD_VAR 0 4
101081: PUSH
101082: LD_VAR 0 7
101086: ARRAY
101087: PPUSH
101088: CALL_OW 74
101092: ST_TO_ADDR
// if not x then
101093: LD_VAR 0 10
101097: NOT
101098: IFFALSE 101102
// continue ;
101100: GO 100534
// if GetLives ( x ) < 1000 then
101102: LD_VAR 0 10
101106: PPUSH
101107: CALL_OW 256
101111: PUSH
101112: LD_INT 1000
101114: LESS
101115: IFFALSE 101139
// ComRepairVehicle ( group [ i ] , x ) else
101117: LD_VAR 0 4
101121: PUSH
101122: LD_VAR 0 7
101126: ARRAY
101127: PPUSH
101128: LD_VAR 0 10
101132: PPUSH
101133: CALL_OW 129
101137: GO 101187
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101139: LD_VAR 0 23
101143: PUSH
101144: LD_VAR 0 4
101148: PUSH
101149: LD_VAR 0 7
101153: ARRAY
101154: PPUSH
101155: CALL_OW 256
101159: PUSH
101160: LD_INT 1000
101162: LESS
101163: AND
101164: NOT
101165: IFFALSE 101187
// ComEnterUnit ( group [ i ] , x ) ;
101167: LD_VAR 0 4
101171: PUSH
101172: LD_VAR 0 7
101176: ARRAY
101177: PPUSH
101178: LD_VAR 0 10
101182: PPUSH
101183: CALL_OW 120
// end ; continue ;
101187: GO 100534
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101189: LD_VAR 0 23
101193: PUSH
101194: LD_VAR 0 4
101198: PUSH
101199: LD_VAR 0 7
101203: ARRAY
101204: PPUSH
101205: CALL_OW 247
101209: PUSH
101210: LD_INT 1
101212: EQUAL
101213: AND
101214: IFFALSE 101692
// begin if group [ i ] in healers then
101216: LD_VAR 0 4
101220: PUSH
101221: LD_VAR 0 7
101225: ARRAY
101226: PUSH
101227: LD_VAR 0 31
101231: IN
101232: IFFALSE 101505
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101234: LD_VAR 0 4
101238: PUSH
101239: LD_VAR 0 7
101243: ARRAY
101244: PPUSH
101245: LD_VAR 0 23
101249: PPUSH
101250: CALL_OW 308
101254: NOT
101255: PUSH
101256: LD_VAR 0 4
101260: PUSH
101261: LD_VAR 0 7
101265: ARRAY
101266: PPUSH
101267: CALL_OW 314
101271: NOT
101272: AND
101273: IFFALSE 101297
// ComMoveToArea ( group [ i ] , f_heal ) else
101275: LD_VAR 0 4
101279: PUSH
101280: LD_VAR 0 7
101284: ARRAY
101285: PPUSH
101286: LD_VAR 0 23
101290: PPUSH
101291: CALL_OW 113
101295: GO 101503
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101297: LD_VAR 0 4
101301: PUSH
101302: LD_VAR 0 7
101306: ARRAY
101307: PPUSH
101308: CALL 48344 0 1
101312: PPUSH
101313: CALL_OW 256
101317: PUSH
101318: LD_INT 1000
101320: EQUAL
101321: IFFALSE 101340
// ComStop ( group [ i ] ) else
101323: LD_VAR 0 4
101327: PUSH
101328: LD_VAR 0 7
101332: ARRAY
101333: PPUSH
101334: CALL_OW 141
101338: GO 101503
// if not HasTask ( group [ i ] ) and to_heal then
101340: LD_VAR 0 4
101344: PUSH
101345: LD_VAR 0 7
101349: ARRAY
101350: PPUSH
101351: CALL_OW 314
101355: NOT
101356: PUSH
101357: LD_VAR 0 30
101361: AND
101362: IFFALSE 101503
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101364: LD_ADDR_VAR 0 13
101368: PUSH
101369: LD_VAR 0 30
101373: PPUSH
101374: LD_INT 3
101376: PUSH
101377: LD_INT 54
101379: PUSH
101380: EMPTY
101381: LIST
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PPUSH
101387: CALL_OW 72
101391: PPUSH
101392: LD_VAR 0 4
101396: PUSH
101397: LD_VAR 0 7
101401: ARRAY
101402: PPUSH
101403: CALL_OW 74
101407: ST_TO_ADDR
// if z then
101408: LD_VAR 0 13
101412: IFFALSE 101503
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101414: LD_INT 91
101416: PUSH
101417: LD_VAR 0 13
101421: PUSH
101422: LD_INT 10
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: LIST
101429: PUSH
101430: LD_INT 81
101432: PUSH
101433: LD_VAR 0 13
101437: PPUSH
101438: CALL_OW 255
101442: PUSH
101443: EMPTY
101444: LIST
101445: LIST
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: PPUSH
101451: CALL_OW 69
101455: PUSH
101456: LD_INT 0
101458: EQUAL
101459: IFFALSE 101483
// ComHeal ( group [ i ] , z ) else
101461: LD_VAR 0 4
101465: PUSH
101466: LD_VAR 0 7
101470: ARRAY
101471: PPUSH
101472: LD_VAR 0 13
101476: PPUSH
101477: CALL_OW 128
101481: GO 101503
// ComMoveToArea ( group [ i ] , f_heal ) ;
101483: LD_VAR 0 4
101487: PUSH
101488: LD_VAR 0 7
101492: ARRAY
101493: PPUSH
101494: LD_VAR 0 23
101498: PPUSH
101499: CALL_OW 113
// end ; continue ;
101503: GO 100534
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101505: LD_VAR 0 4
101509: PUSH
101510: LD_VAR 0 7
101514: ARRAY
101515: PPUSH
101516: CALL_OW 256
101520: PUSH
101521: LD_INT 700
101523: LESS
101524: PUSH
101525: LD_VAR 0 4
101529: PUSH
101530: LD_VAR 0 7
101534: ARRAY
101535: PUSH
101536: LD_VAR 0 30
101540: IN
101541: NOT
101542: AND
101543: IFFALSE 101567
// to_heal := to_heal union group [ i ] ;
101545: LD_ADDR_VAR 0 30
101549: PUSH
101550: LD_VAR 0 30
101554: PUSH
101555: LD_VAR 0 4
101559: PUSH
101560: LD_VAR 0 7
101564: ARRAY
101565: UNION
101566: ST_TO_ADDR
// if group [ i ] in to_heal then
101567: LD_VAR 0 4
101571: PUSH
101572: LD_VAR 0 7
101576: ARRAY
101577: PUSH
101578: LD_VAR 0 30
101582: IN
101583: IFFALSE 101692
// begin if GetLives ( group [ i ] ) = 1000 then
101585: LD_VAR 0 4
101589: PUSH
101590: LD_VAR 0 7
101594: ARRAY
101595: PPUSH
101596: CALL_OW 256
101600: PUSH
101601: LD_INT 1000
101603: EQUAL
101604: IFFALSE 101630
// to_heal := to_heal diff group [ i ] else
101606: LD_ADDR_VAR 0 30
101610: PUSH
101611: LD_VAR 0 30
101615: PUSH
101616: LD_VAR 0 4
101620: PUSH
101621: LD_VAR 0 7
101625: ARRAY
101626: DIFF
101627: ST_TO_ADDR
101628: GO 101692
// begin if not IsInArea ( group [ i ] , to_heal ) then
101630: LD_VAR 0 4
101634: PUSH
101635: LD_VAR 0 7
101639: ARRAY
101640: PPUSH
101641: LD_VAR 0 30
101645: PPUSH
101646: CALL_OW 308
101650: NOT
101651: IFFALSE 101675
// ComMoveToArea ( group [ i ] , f_heal ) else
101653: LD_VAR 0 4
101657: PUSH
101658: LD_VAR 0 7
101662: ARRAY
101663: PPUSH
101664: LD_VAR 0 23
101668: PPUSH
101669: CALL_OW 113
101673: GO 101690
// ComHold ( group [ i ] ) ;
101675: LD_VAR 0 4
101679: PUSH
101680: LD_VAR 0 7
101684: ARRAY
101685: PPUSH
101686: CALL_OW 140
// continue ;
101690: GO 100534
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101692: LD_VAR 0 4
101696: PUSH
101697: LD_VAR 0 7
101701: ARRAY
101702: PPUSH
101703: LD_INT 10
101705: PPUSH
101706: CALL 46764 0 2
101710: NOT
101711: PUSH
101712: LD_VAR 0 16
101716: PUSH
101717: LD_VAR 0 7
101721: ARRAY
101722: PUSH
101723: EMPTY
101724: EQUAL
101725: NOT
101726: AND
101727: IFFALSE 101993
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101729: LD_VAR 0 4
101733: PUSH
101734: LD_VAR 0 7
101738: ARRAY
101739: PPUSH
101740: CALL_OW 262
101744: PUSH
101745: LD_INT 1
101747: PUSH
101748: LD_INT 2
101750: PUSH
101751: EMPTY
101752: LIST
101753: LIST
101754: IN
101755: IFFALSE 101796
// if GetFuel ( group [ i ] ) < 10 then
101757: LD_VAR 0 4
101761: PUSH
101762: LD_VAR 0 7
101766: ARRAY
101767: PPUSH
101768: CALL_OW 261
101772: PUSH
101773: LD_INT 10
101775: LESS
101776: IFFALSE 101796
// SetFuel ( group [ i ] , 12 ) ;
101778: LD_VAR 0 4
101782: PUSH
101783: LD_VAR 0 7
101787: ARRAY
101788: PPUSH
101789: LD_INT 12
101791: PPUSH
101792: CALL_OW 240
// if units_path [ i ] then
101796: LD_VAR 0 16
101800: PUSH
101801: LD_VAR 0 7
101805: ARRAY
101806: IFFALSE 101991
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101808: LD_VAR 0 4
101812: PUSH
101813: LD_VAR 0 7
101817: ARRAY
101818: PPUSH
101819: LD_VAR 0 16
101823: PUSH
101824: LD_VAR 0 7
101828: ARRAY
101829: PUSH
101830: LD_INT 1
101832: ARRAY
101833: PUSH
101834: LD_INT 1
101836: ARRAY
101837: PPUSH
101838: LD_VAR 0 16
101842: PUSH
101843: LD_VAR 0 7
101847: ARRAY
101848: PUSH
101849: LD_INT 1
101851: ARRAY
101852: PUSH
101853: LD_INT 2
101855: ARRAY
101856: PPUSH
101857: CALL_OW 297
101861: PUSH
101862: LD_INT 6
101864: GREATER
101865: IFFALSE 101940
// begin if not HasTask ( group [ i ] ) then
101867: LD_VAR 0 4
101871: PUSH
101872: LD_VAR 0 7
101876: ARRAY
101877: PPUSH
101878: CALL_OW 314
101882: NOT
101883: IFFALSE 101938
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101885: LD_VAR 0 4
101889: PUSH
101890: LD_VAR 0 7
101894: ARRAY
101895: PPUSH
101896: LD_VAR 0 16
101900: PUSH
101901: LD_VAR 0 7
101905: ARRAY
101906: PUSH
101907: LD_INT 1
101909: ARRAY
101910: PUSH
101911: LD_INT 1
101913: ARRAY
101914: PPUSH
101915: LD_VAR 0 16
101919: PUSH
101920: LD_VAR 0 7
101924: ARRAY
101925: PUSH
101926: LD_INT 1
101928: ARRAY
101929: PUSH
101930: LD_INT 2
101932: ARRAY
101933: PPUSH
101934: CALL_OW 114
// end else
101938: GO 101991
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101940: LD_ADDR_VAR 0 15
101944: PUSH
101945: LD_VAR 0 16
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PPUSH
101956: LD_INT 1
101958: PPUSH
101959: CALL_OW 3
101963: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101964: LD_ADDR_VAR 0 16
101968: PUSH
101969: LD_VAR 0 16
101973: PPUSH
101974: LD_VAR 0 7
101978: PPUSH
101979: LD_VAR 0 15
101983: PPUSH
101984: CALL_OW 1
101988: ST_TO_ADDR
// continue ;
101989: GO 100534
// end ; end ; end else
101991: GO 104655
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101993: LD_ADDR_VAR 0 14
101997: PUSH
101998: LD_INT 81
102000: PUSH
102001: LD_VAR 0 4
102005: PUSH
102006: LD_VAR 0 7
102010: ARRAY
102011: PPUSH
102012: CALL_OW 255
102016: PUSH
102017: EMPTY
102018: LIST
102019: LIST
102020: PPUSH
102021: CALL_OW 69
102025: ST_TO_ADDR
// if not tmp then
102026: LD_VAR 0 14
102030: NOT
102031: IFFALSE 102035
// continue ;
102033: GO 100534
// if f_ignore_area then
102035: LD_VAR 0 17
102039: IFFALSE 102127
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102041: LD_ADDR_VAR 0 15
102045: PUSH
102046: LD_VAR 0 14
102050: PPUSH
102051: LD_INT 3
102053: PUSH
102054: LD_INT 92
102056: PUSH
102057: LD_VAR 0 17
102061: PUSH
102062: LD_INT 1
102064: ARRAY
102065: PUSH
102066: LD_VAR 0 17
102070: PUSH
102071: LD_INT 2
102073: ARRAY
102074: PUSH
102075: LD_VAR 0 17
102079: PUSH
102080: LD_INT 3
102082: ARRAY
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: PUSH
102090: EMPTY
102091: LIST
102092: LIST
102093: PPUSH
102094: CALL_OW 72
102098: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102099: LD_VAR 0 14
102103: PUSH
102104: LD_VAR 0 15
102108: DIFF
102109: IFFALSE 102127
// tmp := tmp diff tmp2 ;
102111: LD_ADDR_VAR 0 14
102115: PUSH
102116: LD_VAR 0 14
102120: PUSH
102121: LD_VAR 0 15
102125: DIFF
102126: ST_TO_ADDR
// end ; if not f_murder then
102127: LD_VAR 0 20
102131: NOT
102132: IFFALSE 102190
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102134: LD_ADDR_VAR 0 15
102138: PUSH
102139: LD_VAR 0 14
102143: PPUSH
102144: LD_INT 3
102146: PUSH
102147: LD_INT 50
102149: PUSH
102150: EMPTY
102151: LIST
102152: PUSH
102153: EMPTY
102154: LIST
102155: LIST
102156: PPUSH
102157: CALL_OW 72
102161: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102162: LD_VAR 0 14
102166: PUSH
102167: LD_VAR 0 15
102171: DIFF
102172: IFFALSE 102190
// tmp := tmp diff tmp2 ;
102174: LD_ADDR_VAR 0 14
102178: PUSH
102179: LD_VAR 0 14
102183: PUSH
102184: LD_VAR 0 15
102188: DIFF
102189: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102190: LD_ADDR_VAR 0 14
102194: PUSH
102195: LD_VAR 0 4
102199: PUSH
102200: LD_VAR 0 7
102204: ARRAY
102205: PPUSH
102206: LD_VAR 0 14
102210: PPUSH
102211: LD_INT 1
102213: PPUSH
102214: LD_INT 1
102216: PPUSH
102217: CALL 20104 0 4
102221: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102222: LD_VAR 0 4
102226: PUSH
102227: LD_VAR 0 7
102231: ARRAY
102232: PPUSH
102233: CALL_OW 257
102237: PUSH
102238: LD_INT 1
102240: EQUAL
102241: IFFALSE 102689
// begin if WantPlant ( group [ i ] ) then
102243: LD_VAR 0 4
102247: PUSH
102248: LD_VAR 0 7
102252: ARRAY
102253: PPUSH
102254: CALL 19605 0 1
102258: IFFALSE 102262
// continue ;
102260: GO 100534
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102262: LD_VAR 0 18
102266: PUSH
102267: LD_VAR 0 4
102271: PUSH
102272: LD_VAR 0 7
102276: ARRAY
102277: PPUSH
102278: CALL_OW 310
102282: NOT
102283: AND
102284: PUSH
102285: LD_VAR 0 14
102289: PUSH
102290: LD_INT 1
102292: ARRAY
102293: PUSH
102294: LD_VAR 0 14
102298: PPUSH
102299: LD_INT 21
102301: PUSH
102302: LD_INT 2
102304: PUSH
102305: EMPTY
102306: LIST
102307: LIST
102308: PUSH
102309: LD_INT 58
102311: PUSH
102312: EMPTY
102313: LIST
102314: PUSH
102315: EMPTY
102316: LIST
102317: LIST
102318: PPUSH
102319: CALL_OW 72
102323: IN
102324: AND
102325: IFFALSE 102361
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102327: LD_VAR 0 4
102331: PUSH
102332: LD_VAR 0 7
102336: ARRAY
102337: PPUSH
102338: LD_VAR 0 14
102342: PUSH
102343: LD_INT 1
102345: ARRAY
102346: PPUSH
102347: CALL_OW 120
// attacking := true ;
102351: LD_ADDR_VAR 0 29
102355: PUSH
102356: LD_INT 1
102358: ST_TO_ADDR
// continue ;
102359: GO 100534
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102361: LD_VAR 0 26
102365: PUSH
102366: LD_VAR 0 4
102370: PUSH
102371: LD_VAR 0 7
102375: ARRAY
102376: PPUSH
102377: CALL_OW 257
102381: PUSH
102382: LD_INT 1
102384: EQUAL
102385: AND
102386: PUSH
102387: LD_VAR 0 4
102391: PUSH
102392: LD_VAR 0 7
102396: ARRAY
102397: PPUSH
102398: CALL_OW 256
102402: PUSH
102403: LD_INT 800
102405: LESS
102406: AND
102407: PUSH
102408: LD_VAR 0 4
102412: PUSH
102413: LD_VAR 0 7
102417: ARRAY
102418: PPUSH
102419: CALL_OW 318
102423: NOT
102424: AND
102425: IFFALSE 102442
// ComCrawl ( group [ i ] ) ;
102427: LD_VAR 0 4
102431: PUSH
102432: LD_VAR 0 7
102436: ARRAY
102437: PPUSH
102438: CALL_OW 137
// if f_mines then
102442: LD_VAR 0 21
102446: IFFALSE 102689
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102448: LD_VAR 0 14
102452: PUSH
102453: LD_INT 1
102455: ARRAY
102456: PPUSH
102457: CALL_OW 247
102461: PUSH
102462: LD_INT 3
102464: EQUAL
102465: PUSH
102466: LD_VAR 0 14
102470: PUSH
102471: LD_INT 1
102473: ARRAY
102474: PUSH
102475: LD_VAR 0 27
102479: IN
102480: NOT
102481: AND
102482: IFFALSE 102689
// begin x := GetX ( tmp [ 1 ] ) ;
102484: LD_ADDR_VAR 0 10
102488: PUSH
102489: LD_VAR 0 14
102493: PUSH
102494: LD_INT 1
102496: ARRAY
102497: PPUSH
102498: CALL_OW 250
102502: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102503: LD_ADDR_VAR 0 11
102507: PUSH
102508: LD_VAR 0 14
102512: PUSH
102513: LD_INT 1
102515: ARRAY
102516: PPUSH
102517: CALL_OW 251
102521: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102522: LD_ADDR_VAR 0 12
102526: PUSH
102527: LD_VAR 0 4
102531: PUSH
102532: LD_VAR 0 7
102536: ARRAY
102537: PPUSH
102538: CALL 46849 0 1
102542: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102543: LD_VAR 0 4
102547: PUSH
102548: LD_VAR 0 7
102552: ARRAY
102553: PPUSH
102554: LD_VAR 0 10
102558: PPUSH
102559: LD_VAR 0 11
102563: PPUSH
102564: LD_VAR 0 14
102568: PUSH
102569: LD_INT 1
102571: ARRAY
102572: PPUSH
102573: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102577: LD_VAR 0 4
102581: PUSH
102582: LD_VAR 0 7
102586: ARRAY
102587: PPUSH
102588: LD_VAR 0 10
102592: PPUSH
102593: LD_VAR 0 12
102597: PPUSH
102598: LD_INT 7
102600: PPUSH
102601: CALL_OW 272
102605: PPUSH
102606: LD_VAR 0 11
102610: PPUSH
102611: LD_VAR 0 12
102615: PPUSH
102616: LD_INT 7
102618: PPUSH
102619: CALL_OW 273
102623: PPUSH
102624: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102628: LD_VAR 0 4
102632: PUSH
102633: LD_VAR 0 7
102637: ARRAY
102638: PPUSH
102639: LD_INT 71
102641: PPUSH
102642: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102646: LD_ADDR_VAR 0 27
102650: PUSH
102651: LD_VAR 0 27
102655: PPUSH
102656: LD_VAR 0 27
102660: PUSH
102661: LD_INT 1
102663: PLUS
102664: PPUSH
102665: LD_VAR 0 14
102669: PUSH
102670: LD_INT 1
102672: ARRAY
102673: PPUSH
102674: CALL_OW 1
102678: ST_TO_ADDR
// attacking := true ;
102679: LD_ADDR_VAR 0 29
102683: PUSH
102684: LD_INT 1
102686: ST_TO_ADDR
// continue ;
102687: GO 100534
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102689: LD_VAR 0 4
102693: PUSH
102694: LD_VAR 0 7
102698: ARRAY
102699: PPUSH
102700: CALL_OW 257
102704: PUSH
102705: LD_INT 17
102707: EQUAL
102708: PUSH
102709: LD_VAR 0 4
102713: PUSH
102714: LD_VAR 0 7
102718: ARRAY
102719: PPUSH
102720: CALL_OW 110
102724: PUSH
102725: LD_INT 71
102727: EQUAL
102728: NOT
102729: AND
102730: IFFALSE 102876
// begin attacking := false ;
102732: LD_ADDR_VAR 0 29
102736: PUSH
102737: LD_INT 0
102739: ST_TO_ADDR
// k := 5 ;
102740: LD_ADDR_VAR 0 9
102744: PUSH
102745: LD_INT 5
102747: ST_TO_ADDR
// if tmp < k then
102748: LD_VAR 0 14
102752: PUSH
102753: LD_VAR 0 9
102757: LESS
102758: IFFALSE 102770
// k := tmp ;
102760: LD_ADDR_VAR 0 9
102764: PUSH
102765: LD_VAR 0 14
102769: ST_TO_ADDR
// for j = 1 to k do
102770: LD_ADDR_VAR 0 8
102774: PUSH
102775: DOUBLE
102776: LD_INT 1
102778: DEC
102779: ST_TO_ADDR
102780: LD_VAR 0 9
102784: PUSH
102785: FOR_TO
102786: IFFALSE 102874
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102788: LD_VAR 0 14
102792: PUSH
102793: LD_VAR 0 8
102797: ARRAY
102798: PUSH
102799: LD_VAR 0 14
102803: PPUSH
102804: LD_INT 58
102806: PUSH
102807: EMPTY
102808: LIST
102809: PPUSH
102810: CALL_OW 72
102814: IN
102815: NOT
102816: IFFALSE 102872
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102818: LD_VAR 0 4
102822: PUSH
102823: LD_VAR 0 7
102827: ARRAY
102828: PPUSH
102829: LD_VAR 0 14
102833: PUSH
102834: LD_VAR 0 8
102838: ARRAY
102839: PPUSH
102840: CALL_OW 115
// attacking := true ;
102844: LD_ADDR_VAR 0 29
102848: PUSH
102849: LD_INT 1
102851: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102852: LD_VAR 0 4
102856: PUSH
102857: LD_VAR 0 7
102861: ARRAY
102862: PPUSH
102863: LD_INT 71
102865: PPUSH
102866: CALL_OW 109
// continue ;
102870: GO 102785
// end ; end ;
102872: GO 102785
102874: POP
102875: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102876: LD_VAR 0 4
102880: PUSH
102881: LD_VAR 0 7
102885: ARRAY
102886: PPUSH
102887: CALL_OW 257
102891: PUSH
102892: LD_INT 8
102894: EQUAL
102895: PUSH
102896: LD_VAR 0 4
102900: PUSH
102901: LD_VAR 0 7
102905: ARRAY
102906: PPUSH
102907: CALL_OW 264
102911: PUSH
102912: LD_INT 28
102914: PUSH
102915: LD_INT 45
102917: PUSH
102918: LD_INT 7
102920: PUSH
102921: LD_INT 47
102923: PUSH
102924: EMPTY
102925: LIST
102926: LIST
102927: LIST
102928: LIST
102929: IN
102930: OR
102931: IFFALSE 103187
// begin attacking := false ;
102933: LD_ADDR_VAR 0 29
102937: PUSH
102938: LD_INT 0
102940: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102941: LD_VAR 0 14
102945: PUSH
102946: LD_INT 1
102948: ARRAY
102949: PPUSH
102950: CALL_OW 266
102954: PUSH
102955: LD_INT 32
102957: PUSH
102958: LD_INT 31
102960: PUSH
102961: LD_INT 33
102963: PUSH
102964: LD_INT 4
102966: PUSH
102967: LD_INT 5
102969: PUSH
102970: EMPTY
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: IN
102977: IFFALSE 103163
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102979: LD_ADDR_VAR 0 9
102983: PUSH
102984: LD_VAR 0 14
102988: PUSH
102989: LD_INT 1
102991: ARRAY
102992: PPUSH
102993: CALL_OW 266
102997: PPUSH
102998: LD_VAR 0 14
103002: PUSH
103003: LD_INT 1
103005: ARRAY
103006: PPUSH
103007: CALL_OW 250
103011: PPUSH
103012: LD_VAR 0 14
103016: PUSH
103017: LD_INT 1
103019: ARRAY
103020: PPUSH
103021: CALL_OW 251
103025: PPUSH
103026: LD_VAR 0 14
103030: PUSH
103031: LD_INT 1
103033: ARRAY
103034: PPUSH
103035: CALL_OW 254
103039: PPUSH
103040: LD_VAR 0 14
103044: PUSH
103045: LD_INT 1
103047: ARRAY
103048: PPUSH
103049: CALL_OW 248
103053: PPUSH
103054: LD_INT 0
103056: PPUSH
103057: CALL 28219 0 6
103061: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103062: LD_ADDR_VAR 0 8
103066: PUSH
103067: LD_VAR 0 4
103071: PUSH
103072: LD_VAR 0 7
103076: ARRAY
103077: PPUSH
103078: LD_VAR 0 9
103082: PPUSH
103083: CALL 46889 0 2
103087: ST_TO_ADDR
// if j then
103088: LD_VAR 0 8
103092: IFFALSE 103161
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103094: LD_VAR 0 8
103098: PUSH
103099: LD_INT 1
103101: ARRAY
103102: PPUSH
103103: LD_VAR 0 8
103107: PUSH
103108: LD_INT 2
103110: ARRAY
103111: PPUSH
103112: CALL_OW 488
103116: IFFALSE 103161
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103118: LD_VAR 0 4
103122: PUSH
103123: LD_VAR 0 7
103127: ARRAY
103128: PPUSH
103129: LD_VAR 0 8
103133: PUSH
103134: LD_INT 1
103136: ARRAY
103137: PPUSH
103138: LD_VAR 0 8
103142: PUSH
103143: LD_INT 2
103145: ARRAY
103146: PPUSH
103147: CALL_OW 116
// attacking := true ;
103151: LD_ADDR_VAR 0 29
103155: PUSH
103156: LD_INT 1
103158: ST_TO_ADDR
// continue ;
103159: GO 100534
// end ; end else
103161: GO 103187
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103163: LD_VAR 0 4
103167: PUSH
103168: LD_VAR 0 7
103172: ARRAY
103173: PPUSH
103174: LD_VAR 0 14
103178: PUSH
103179: LD_INT 1
103181: ARRAY
103182: PPUSH
103183: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103187: LD_VAR 0 4
103191: PUSH
103192: LD_VAR 0 7
103196: ARRAY
103197: PPUSH
103198: CALL_OW 265
103202: PUSH
103203: LD_INT 11
103205: EQUAL
103206: IFFALSE 103484
// begin k := 10 ;
103208: LD_ADDR_VAR 0 9
103212: PUSH
103213: LD_INT 10
103215: ST_TO_ADDR
// x := 0 ;
103216: LD_ADDR_VAR 0 10
103220: PUSH
103221: LD_INT 0
103223: ST_TO_ADDR
// if tmp < k then
103224: LD_VAR 0 14
103228: PUSH
103229: LD_VAR 0 9
103233: LESS
103234: IFFALSE 103246
// k := tmp ;
103236: LD_ADDR_VAR 0 9
103240: PUSH
103241: LD_VAR 0 14
103245: ST_TO_ADDR
// for j = k downto 1 do
103246: LD_ADDR_VAR 0 8
103250: PUSH
103251: DOUBLE
103252: LD_VAR 0 9
103256: INC
103257: ST_TO_ADDR
103258: LD_INT 1
103260: PUSH
103261: FOR_DOWNTO
103262: IFFALSE 103337
// begin if GetType ( tmp [ j ] ) = unit_human then
103264: LD_VAR 0 14
103268: PUSH
103269: LD_VAR 0 8
103273: ARRAY
103274: PPUSH
103275: CALL_OW 247
103279: PUSH
103280: LD_INT 1
103282: EQUAL
103283: IFFALSE 103335
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103285: LD_VAR 0 4
103289: PUSH
103290: LD_VAR 0 7
103294: ARRAY
103295: PPUSH
103296: LD_VAR 0 14
103300: PUSH
103301: LD_VAR 0 8
103305: ARRAY
103306: PPUSH
103307: CALL 47160 0 2
// x := tmp [ j ] ;
103311: LD_ADDR_VAR 0 10
103315: PUSH
103316: LD_VAR 0 14
103320: PUSH
103321: LD_VAR 0 8
103325: ARRAY
103326: ST_TO_ADDR
// attacking := true ;
103327: LD_ADDR_VAR 0 29
103331: PUSH
103332: LD_INT 1
103334: ST_TO_ADDR
// end ; end ;
103335: GO 103261
103337: POP
103338: POP
// if not x then
103339: LD_VAR 0 10
103343: NOT
103344: IFFALSE 103484
// begin attacking := true ;
103346: LD_ADDR_VAR 0 29
103350: PUSH
103351: LD_INT 1
103353: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103354: LD_VAR 0 4
103358: PUSH
103359: LD_VAR 0 7
103363: ARRAY
103364: PPUSH
103365: CALL_OW 250
103369: PPUSH
103370: LD_VAR 0 4
103374: PUSH
103375: LD_VAR 0 7
103379: ARRAY
103380: PPUSH
103381: CALL_OW 251
103385: PPUSH
103386: CALL_OW 546
103390: PUSH
103391: LD_INT 2
103393: ARRAY
103394: PUSH
103395: LD_VAR 0 14
103399: PUSH
103400: LD_INT 1
103402: ARRAY
103403: PPUSH
103404: CALL_OW 250
103408: PPUSH
103409: LD_VAR 0 14
103413: PUSH
103414: LD_INT 1
103416: ARRAY
103417: PPUSH
103418: CALL_OW 251
103422: PPUSH
103423: CALL_OW 546
103427: PUSH
103428: LD_INT 2
103430: ARRAY
103431: EQUAL
103432: IFFALSE 103460
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103434: LD_VAR 0 4
103438: PUSH
103439: LD_VAR 0 7
103443: ARRAY
103444: PPUSH
103445: LD_VAR 0 14
103449: PUSH
103450: LD_INT 1
103452: ARRAY
103453: PPUSH
103454: CALL 47160 0 2
103458: GO 103484
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103460: LD_VAR 0 4
103464: PUSH
103465: LD_VAR 0 7
103469: ARRAY
103470: PPUSH
103471: LD_VAR 0 14
103475: PUSH
103476: LD_INT 1
103478: ARRAY
103479: PPUSH
103480: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103484: LD_VAR 0 4
103488: PUSH
103489: LD_VAR 0 7
103493: ARRAY
103494: PPUSH
103495: CALL_OW 264
103499: PUSH
103500: LD_INT 29
103502: EQUAL
103503: IFFALSE 103869
// begin if WantsToAttack ( group [ i ] ) in bombed then
103505: LD_VAR 0 4
103509: PUSH
103510: LD_VAR 0 7
103514: ARRAY
103515: PPUSH
103516: CALL_OW 319
103520: PUSH
103521: LD_VAR 0 28
103525: IN
103526: IFFALSE 103530
// continue ;
103528: GO 100534
// k := 8 ;
103530: LD_ADDR_VAR 0 9
103534: PUSH
103535: LD_INT 8
103537: ST_TO_ADDR
// x := 0 ;
103538: LD_ADDR_VAR 0 10
103542: PUSH
103543: LD_INT 0
103545: ST_TO_ADDR
// if tmp < k then
103546: LD_VAR 0 14
103550: PUSH
103551: LD_VAR 0 9
103555: LESS
103556: IFFALSE 103568
// k := tmp ;
103558: LD_ADDR_VAR 0 9
103562: PUSH
103563: LD_VAR 0 14
103567: ST_TO_ADDR
// for j = 1 to k do
103568: LD_ADDR_VAR 0 8
103572: PUSH
103573: DOUBLE
103574: LD_INT 1
103576: DEC
103577: ST_TO_ADDR
103578: LD_VAR 0 9
103582: PUSH
103583: FOR_TO
103584: IFFALSE 103716
// begin if GetType ( tmp [ j ] ) = unit_building then
103586: LD_VAR 0 14
103590: PUSH
103591: LD_VAR 0 8
103595: ARRAY
103596: PPUSH
103597: CALL_OW 247
103601: PUSH
103602: LD_INT 3
103604: EQUAL
103605: IFFALSE 103714
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103607: LD_VAR 0 14
103611: PUSH
103612: LD_VAR 0 8
103616: ARRAY
103617: PUSH
103618: LD_VAR 0 28
103622: IN
103623: NOT
103624: PUSH
103625: LD_VAR 0 14
103629: PUSH
103630: LD_VAR 0 8
103634: ARRAY
103635: PPUSH
103636: CALL_OW 313
103640: AND
103641: IFFALSE 103714
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103643: LD_VAR 0 4
103647: PUSH
103648: LD_VAR 0 7
103652: ARRAY
103653: PPUSH
103654: LD_VAR 0 14
103658: PUSH
103659: LD_VAR 0 8
103663: ARRAY
103664: PPUSH
103665: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103669: LD_ADDR_VAR 0 28
103673: PUSH
103674: LD_VAR 0 28
103678: PPUSH
103679: LD_VAR 0 28
103683: PUSH
103684: LD_INT 1
103686: PLUS
103687: PPUSH
103688: LD_VAR 0 14
103692: PUSH
103693: LD_VAR 0 8
103697: ARRAY
103698: PPUSH
103699: CALL_OW 1
103703: ST_TO_ADDR
// attacking := true ;
103704: LD_ADDR_VAR 0 29
103708: PUSH
103709: LD_INT 1
103711: ST_TO_ADDR
// break ;
103712: GO 103716
// end ; end ;
103714: GO 103583
103716: POP
103717: POP
// if not attacking and f_attack_depot then
103718: LD_VAR 0 29
103722: NOT
103723: PUSH
103724: LD_VAR 0 25
103728: AND
103729: IFFALSE 103824
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103731: LD_ADDR_VAR 0 13
103735: PUSH
103736: LD_VAR 0 14
103740: PPUSH
103741: LD_INT 2
103743: PUSH
103744: LD_INT 30
103746: PUSH
103747: LD_INT 0
103749: PUSH
103750: EMPTY
103751: LIST
103752: LIST
103753: PUSH
103754: LD_INT 30
103756: PUSH
103757: LD_INT 1
103759: PUSH
103760: EMPTY
103761: LIST
103762: LIST
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: LIST
103768: PPUSH
103769: CALL_OW 72
103773: ST_TO_ADDR
// if z then
103774: LD_VAR 0 13
103778: IFFALSE 103824
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103780: LD_VAR 0 4
103784: PUSH
103785: LD_VAR 0 7
103789: ARRAY
103790: PPUSH
103791: LD_VAR 0 13
103795: PPUSH
103796: LD_VAR 0 4
103800: PUSH
103801: LD_VAR 0 7
103805: ARRAY
103806: PPUSH
103807: CALL_OW 74
103811: PPUSH
103812: CALL_OW 115
// attacking := true ;
103816: LD_ADDR_VAR 0 29
103820: PUSH
103821: LD_INT 1
103823: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103824: LD_VAR 0 4
103828: PUSH
103829: LD_VAR 0 7
103833: ARRAY
103834: PPUSH
103835: CALL_OW 256
103839: PUSH
103840: LD_INT 500
103842: LESS
103843: IFFALSE 103869
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103845: LD_VAR 0 4
103849: PUSH
103850: LD_VAR 0 7
103854: ARRAY
103855: PPUSH
103856: LD_VAR 0 14
103860: PUSH
103861: LD_INT 1
103863: ARRAY
103864: PPUSH
103865: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103869: LD_VAR 0 4
103873: PUSH
103874: LD_VAR 0 7
103878: ARRAY
103879: PPUSH
103880: CALL_OW 264
103884: PUSH
103885: LD_INT 49
103887: EQUAL
103888: IFFALSE 104009
// begin if not HasTask ( group [ i ] ) then
103890: LD_VAR 0 4
103894: PUSH
103895: LD_VAR 0 7
103899: ARRAY
103900: PPUSH
103901: CALL_OW 314
103905: NOT
103906: IFFALSE 104009
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103908: LD_ADDR_VAR 0 9
103912: PUSH
103913: LD_INT 81
103915: PUSH
103916: LD_VAR 0 4
103920: PUSH
103921: LD_VAR 0 7
103925: ARRAY
103926: PPUSH
103927: CALL_OW 255
103931: PUSH
103932: EMPTY
103933: LIST
103934: LIST
103935: PPUSH
103936: CALL_OW 69
103940: PPUSH
103941: LD_VAR 0 4
103945: PUSH
103946: LD_VAR 0 7
103950: ARRAY
103951: PPUSH
103952: CALL_OW 74
103956: ST_TO_ADDR
// if k then
103957: LD_VAR 0 9
103961: IFFALSE 104009
// if GetDistUnits ( group [ i ] , k ) > 10 then
103963: LD_VAR 0 4
103967: PUSH
103968: LD_VAR 0 7
103972: ARRAY
103973: PPUSH
103974: LD_VAR 0 9
103978: PPUSH
103979: CALL_OW 296
103983: PUSH
103984: LD_INT 10
103986: GREATER
103987: IFFALSE 104009
// ComMoveUnit ( group [ i ] , k ) ;
103989: LD_VAR 0 4
103993: PUSH
103994: LD_VAR 0 7
103998: ARRAY
103999: PPUSH
104000: LD_VAR 0 9
104004: PPUSH
104005: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104009: LD_VAR 0 4
104013: PUSH
104014: LD_VAR 0 7
104018: ARRAY
104019: PPUSH
104020: CALL_OW 256
104024: PUSH
104025: LD_INT 250
104027: LESS
104028: PUSH
104029: LD_VAR 0 4
104033: PUSH
104034: LD_VAR 0 7
104038: ARRAY
104039: PUSH
104040: LD_INT 21
104042: PUSH
104043: LD_INT 2
104045: PUSH
104046: EMPTY
104047: LIST
104048: LIST
104049: PUSH
104050: LD_INT 23
104052: PUSH
104053: LD_INT 2
104055: PUSH
104056: EMPTY
104057: LIST
104058: LIST
104059: PUSH
104060: EMPTY
104061: LIST
104062: LIST
104063: PPUSH
104064: CALL_OW 69
104068: IN
104069: AND
104070: IFFALSE 104195
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104072: LD_ADDR_VAR 0 9
104076: PUSH
104077: LD_OWVAR 3
104081: PUSH
104082: LD_VAR 0 4
104086: PUSH
104087: LD_VAR 0 7
104091: ARRAY
104092: DIFF
104093: PPUSH
104094: LD_VAR 0 4
104098: PUSH
104099: LD_VAR 0 7
104103: ARRAY
104104: PPUSH
104105: CALL_OW 74
104109: ST_TO_ADDR
// if not k then
104110: LD_VAR 0 9
104114: NOT
104115: IFFALSE 104119
// continue ;
104117: GO 100534
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104119: LD_VAR 0 9
104123: PUSH
104124: LD_INT 81
104126: PUSH
104127: LD_VAR 0 4
104131: PUSH
104132: LD_VAR 0 7
104136: ARRAY
104137: PPUSH
104138: CALL_OW 255
104142: PUSH
104143: EMPTY
104144: LIST
104145: LIST
104146: PPUSH
104147: CALL_OW 69
104151: IN
104152: PUSH
104153: LD_VAR 0 9
104157: PPUSH
104158: LD_VAR 0 4
104162: PUSH
104163: LD_VAR 0 7
104167: ARRAY
104168: PPUSH
104169: CALL_OW 296
104173: PUSH
104174: LD_INT 5
104176: LESS
104177: AND
104178: IFFALSE 104195
// ComAutodestruct ( group [ i ] ) ;
104180: LD_VAR 0 4
104184: PUSH
104185: LD_VAR 0 7
104189: ARRAY
104190: PPUSH
104191: CALL 47058 0 1
// end ; if f_attack_depot then
104195: LD_VAR 0 25
104199: IFFALSE 104311
// begin k := 6 ;
104201: LD_ADDR_VAR 0 9
104205: PUSH
104206: LD_INT 6
104208: ST_TO_ADDR
// if tmp < k then
104209: LD_VAR 0 14
104213: PUSH
104214: LD_VAR 0 9
104218: LESS
104219: IFFALSE 104231
// k := tmp ;
104221: LD_ADDR_VAR 0 9
104225: PUSH
104226: LD_VAR 0 14
104230: ST_TO_ADDR
// for j = 1 to k do
104231: LD_ADDR_VAR 0 8
104235: PUSH
104236: DOUBLE
104237: LD_INT 1
104239: DEC
104240: ST_TO_ADDR
104241: LD_VAR 0 9
104245: PUSH
104246: FOR_TO
104247: IFFALSE 104309
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104249: LD_VAR 0 8
104253: PPUSH
104254: CALL_OW 266
104258: PUSH
104259: LD_INT 0
104261: PUSH
104262: LD_INT 1
104264: PUSH
104265: EMPTY
104266: LIST
104267: LIST
104268: IN
104269: IFFALSE 104307
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104271: LD_VAR 0 4
104275: PUSH
104276: LD_VAR 0 7
104280: ARRAY
104281: PPUSH
104282: LD_VAR 0 14
104286: PUSH
104287: LD_VAR 0 8
104291: ARRAY
104292: PPUSH
104293: CALL_OW 115
// attacking := true ;
104297: LD_ADDR_VAR 0 29
104301: PUSH
104302: LD_INT 1
104304: ST_TO_ADDR
// break ;
104305: GO 104309
// end ;
104307: GO 104246
104309: POP
104310: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104311: LD_VAR 0 4
104315: PUSH
104316: LD_VAR 0 7
104320: ARRAY
104321: PPUSH
104322: CALL_OW 302
104326: PUSH
104327: LD_VAR 0 29
104331: NOT
104332: AND
104333: IFFALSE 104655
// begin if GetTag ( group [ i ] ) = 71 then
104335: LD_VAR 0 4
104339: PUSH
104340: LD_VAR 0 7
104344: ARRAY
104345: PPUSH
104346: CALL_OW 110
104350: PUSH
104351: LD_INT 71
104353: EQUAL
104354: IFFALSE 104395
// begin if HasTask ( group [ i ] ) then
104356: LD_VAR 0 4
104360: PUSH
104361: LD_VAR 0 7
104365: ARRAY
104366: PPUSH
104367: CALL_OW 314
104371: IFFALSE 104377
// continue else
104373: GO 100534
104375: GO 104395
// SetTag ( group [ i ] , 0 ) ;
104377: LD_VAR 0 4
104381: PUSH
104382: LD_VAR 0 7
104386: ARRAY
104387: PPUSH
104388: LD_INT 0
104390: PPUSH
104391: CALL_OW 109
// end ; k := 8 ;
104395: LD_ADDR_VAR 0 9
104399: PUSH
104400: LD_INT 8
104402: ST_TO_ADDR
// x := 0 ;
104403: LD_ADDR_VAR 0 10
104407: PUSH
104408: LD_INT 0
104410: ST_TO_ADDR
// if tmp < k then
104411: LD_VAR 0 14
104415: PUSH
104416: LD_VAR 0 9
104420: LESS
104421: IFFALSE 104433
// k := tmp ;
104423: LD_ADDR_VAR 0 9
104427: PUSH
104428: LD_VAR 0 14
104432: ST_TO_ADDR
// for j = 1 to k do
104433: LD_ADDR_VAR 0 8
104437: PUSH
104438: DOUBLE
104439: LD_INT 1
104441: DEC
104442: ST_TO_ADDR
104443: LD_VAR 0 9
104447: PUSH
104448: FOR_TO
104449: IFFALSE 104547
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104451: LD_VAR 0 14
104455: PUSH
104456: LD_VAR 0 8
104460: ARRAY
104461: PPUSH
104462: CALL_OW 247
104466: PUSH
104467: LD_INT 1
104469: EQUAL
104470: PUSH
104471: LD_VAR 0 14
104475: PUSH
104476: LD_VAR 0 8
104480: ARRAY
104481: PPUSH
104482: CALL_OW 256
104486: PUSH
104487: LD_INT 250
104489: LESS
104490: PUSH
104491: LD_VAR 0 20
104495: AND
104496: PUSH
104497: LD_VAR 0 20
104501: NOT
104502: PUSH
104503: LD_VAR 0 14
104507: PUSH
104508: LD_VAR 0 8
104512: ARRAY
104513: PPUSH
104514: CALL_OW 256
104518: PUSH
104519: LD_INT 250
104521: GREATEREQUAL
104522: AND
104523: OR
104524: AND
104525: IFFALSE 104545
// begin x := tmp [ j ] ;
104527: LD_ADDR_VAR 0 10
104531: PUSH
104532: LD_VAR 0 14
104536: PUSH
104537: LD_VAR 0 8
104541: ARRAY
104542: ST_TO_ADDR
// break ;
104543: GO 104547
// end ;
104545: GO 104448
104547: POP
104548: POP
// if x then
104549: LD_VAR 0 10
104553: IFFALSE 104577
// ComAttackUnit ( group [ i ] , x ) else
104555: LD_VAR 0 4
104559: PUSH
104560: LD_VAR 0 7
104564: ARRAY
104565: PPUSH
104566: LD_VAR 0 10
104570: PPUSH
104571: CALL_OW 115
104575: GO 104601
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104577: LD_VAR 0 4
104581: PUSH
104582: LD_VAR 0 7
104586: ARRAY
104587: PPUSH
104588: LD_VAR 0 14
104592: PUSH
104593: LD_INT 1
104595: ARRAY
104596: PPUSH
104597: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104601: LD_VAR 0 4
104605: PUSH
104606: LD_VAR 0 7
104610: ARRAY
104611: PPUSH
104612: CALL_OW 314
104616: NOT
104617: IFFALSE 104655
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104619: LD_VAR 0 4
104623: PUSH
104624: LD_VAR 0 7
104628: ARRAY
104629: PPUSH
104630: LD_VAR 0 14
104634: PPUSH
104635: LD_VAR 0 4
104639: PUSH
104640: LD_VAR 0 7
104644: ARRAY
104645: PPUSH
104646: CALL_OW 74
104650: PPUSH
104651: CALL_OW 115
// end ; end ; end ;
104655: GO 100534
104657: POP
104658: POP
// wait ( 0 0$2 ) ;
104659: LD_INT 70
104661: PPUSH
104662: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104666: LD_VAR 0 4
104670: NOT
104671: PUSH
104672: LD_VAR 0 4
104676: PUSH
104677: EMPTY
104678: EQUAL
104679: OR
104680: PUSH
104681: LD_INT 81
104683: PUSH
104684: LD_VAR 0 35
104688: PUSH
104689: EMPTY
104690: LIST
104691: LIST
104692: PPUSH
104693: CALL_OW 69
104697: NOT
104698: OR
104699: IFFALSE 100519
// end ;
104701: LD_VAR 0 2
104705: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
104706: LD_INT 0
104708: PPUSH
104709: PPUSH
104710: PPUSH
104711: PPUSH
104712: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
104713: LD_VAR 0 1
104717: NOT
104718: PUSH
104719: LD_EXP 59
104723: PUSH
104724: LD_VAR 0 1
104728: ARRAY
104729: NOT
104730: OR
104731: PUSH
104732: LD_VAR 0 2
104736: NOT
104737: OR
104738: PUSH
104739: LD_VAR 0 3
104743: NOT
104744: OR
104745: IFFALSE 104749
// exit ;
104747: GO 105262
// side := mc_sides [ base ] ;
104749: LD_ADDR_VAR 0 6
104753: PUSH
104754: LD_EXP 85
104758: PUSH
104759: LD_VAR 0 1
104763: ARRAY
104764: ST_TO_ADDR
// if not side then
104765: LD_VAR 0 6
104769: NOT
104770: IFFALSE 104774
// exit ;
104772: GO 105262
// for i in solds do
104774: LD_ADDR_VAR 0 7
104778: PUSH
104779: LD_VAR 0 2
104783: PUSH
104784: FOR_IN
104785: IFFALSE 104846
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
104787: LD_VAR 0 7
104791: PPUSH
104792: CALL_OW 310
104796: PPUSH
104797: CALL_OW 266
104801: PUSH
104802: LD_INT 32
104804: PUSH
104805: LD_INT 31
104807: PUSH
104808: EMPTY
104809: LIST
104810: LIST
104811: IN
104812: IFFALSE 104832
// solds := solds diff i else
104814: LD_ADDR_VAR 0 2
104818: PUSH
104819: LD_VAR 0 2
104823: PUSH
104824: LD_VAR 0 7
104828: DIFF
104829: ST_TO_ADDR
104830: GO 104844
// SetTag ( i , 18 ) ;
104832: LD_VAR 0 7
104836: PPUSH
104837: LD_INT 18
104839: PPUSH
104840: CALL_OW 109
104844: GO 104784
104846: POP
104847: POP
// if not solds then
104848: LD_VAR 0 2
104852: NOT
104853: IFFALSE 104857
// exit ;
104855: GO 105262
// repeat wait ( 0 0$2 ) ;
104857: LD_INT 70
104859: PPUSH
104860: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
104864: LD_ADDR_VAR 0 5
104868: PUSH
104869: LD_VAR 0 6
104873: PPUSH
104874: LD_VAR 0 3
104878: PPUSH
104879: CALL 16470 0 2
104883: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104884: LD_EXP 59
104888: PUSH
104889: LD_VAR 0 1
104893: ARRAY
104894: NOT
104895: PUSH
104896: LD_EXP 59
104900: PUSH
104901: LD_VAR 0 1
104905: ARRAY
104906: PUSH
104907: EMPTY
104908: EQUAL
104909: OR
104910: IFFALSE 104947
// begin for i in solds do
104912: LD_ADDR_VAR 0 7
104916: PUSH
104917: LD_VAR 0 2
104921: PUSH
104922: FOR_IN
104923: IFFALSE 104936
// ComStop ( i ) ;
104925: LD_VAR 0 7
104929: PPUSH
104930: CALL_OW 141
104934: GO 104922
104936: POP
104937: POP
// solds := [ ] ;
104938: LD_ADDR_VAR 0 2
104942: PUSH
104943: EMPTY
104944: ST_TO_ADDR
// exit ;
104945: GO 105262
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
104947: LD_VAR 0 5
104951: NOT
104952: PUSH
104953: LD_VAR 0 5
104957: PUSH
104958: LD_INT 3
104960: GREATER
104961: OR
104962: PUSH
104963: LD_EXP 81
104967: PUSH
104968: LD_VAR 0 1
104972: ARRAY
104973: OR
104974: IFFALSE 105015
// begin for i in solds do
104976: LD_ADDR_VAR 0 7
104980: PUSH
104981: LD_VAR 0 2
104985: PUSH
104986: FOR_IN
104987: IFFALSE 105011
// if HasTask ( i ) then
104989: LD_VAR 0 7
104993: PPUSH
104994: CALL_OW 314
104998: IFFALSE 105009
// ComStop ( i ) ;
105000: LD_VAR 0 7
105004: PPUSH
105005: CALL_OW 141
105009: GO 104986
105011: POP
105012: POP
// break ;
105013: GO 105250
// end ; for i in solds do
105015: LD_ADDR_VAR 0 7
105019: PUSH
105020: LD_VAR 0 2
105024: PUSH
105025: FOR_IN
105026: IFFALSE 105242
// begin if IsInUnit ( i ) then
105028: LD_VAR 0 7
105032: PPUSH
105033: CALL_OW 310
105037: IFFALSE 105048
// ComExitBuilding ( i ) ;
105039: LD_VAR 0 7
105043: PPUSH
105044: CALL_OW 122
// if GetLives ( i ) > 333 then
105048: LD_VAR 0 7
105052: PPUSH
105053: CALL_OW 256
105057: PUSH
105058: LD_INT 333
105060: GREATER
105061: IFFALSE 105089
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
105063: LD_VAR 0 7
105067: PPUSH
105068: LD_VAR 0 5
105072: PPUSH
105073: LD_VAR 0 7
105077: PPUSH
105078: CALL_OW 74
105082: PPUSH
105083: CALL_OW 115
105087: GO 105240
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
105089: LD_ADDR_VAR 0 8
105093: PUSH
105094: LD_EXP 59
105098: PUSH
105099: LD_VAR 0 1
105103: ARRAY
105104: PPUSH
105105: LD_INT 2
105107: PUSH
105108: LD_INT 30
105110: PUSH
105111: LD_INT 0
105113: PUSH
105114: EMPTY
105115: LIST
105116: LIST
105117: PUSH
105118: LD_INT 30
105120: PUSH
105121: LD_INT 1
105123: PUSH
105124: EMPTY
105125: LIST
105126: LIST
105127: PUSH
105128: LD_INT 30
105130: PUSH
105131: LD_INT 6
105133: PUSH
105134: EMPTY
105135: LIST
105136: LIST
105137: PUSH
105138: EMPTY
105139: LIST
105140: LIST
105141: LIST
105142: LIST
105143: PPUSH
105144: CALL_OW 72
105148: PPUSH
105149: LD_VAR 0 7
105153: PPUSH
105154: CALL_OW 74
105158: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
105159: LD_VAR 0 7
105163: PPUSH
105164: LD_VAR 0 8
105168: PPUSH
105169: CALL_OW 250
105173: PPUSH
105174: LD_INT 3
105176: PPUSH
105177: LD_INT 5
105179: PPUSH
105180: CALL_OW 272
105184: PPUSH
105185: LD_VAR 0 8
105189: PPUSH
105190: CALL_OW 251
105194: PPUSH
105195: LD_INT 3
105197: PPUSH
105198: LD_INT 5
105200: PPUSH
105201: CALL_OW 273
105205: PPUSH
105206: CALL_OW 111
// SetTag ( i , 0 ) ;
105210: LD_VAR 0 7
105214: PPUSH
105215: LD_INT 0
105217: PPUSH
105218: CALL_OW 109
// solds := solds diff i ;
105222: LD_ADDR_VAR 0 2
105226: PUSH
105227: LD_VAR 0 2
105231: PUSH
105232: LD_VAR 0 7
105236: DIFF
105237: ST_TO_ADDR
// continue ;
105238: GO 105025
// end ; end ;
105240: GO 105025
105242: POP
105243: POP
// until solds ;
105244: LD_VAR 0 2
105248: IFFALSE 104857
// MC_Reset ( base , 18 ) ;
105250: LD_VAR 0 1
105254: PPUSH
105255: LD_INT 18
105257: PPUSH
105258: CALL 56480 0 2
// end ;
105262: LD_VAR 0 4
105266: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
105267: LD_INT 0
105269: PPUSH
105270: PPUSH
105271: PPUSH
105272: PPUSH
105273: PPUSH
105274: PPUSH
105275: PPUSH
105276: PPUSH
105277: PPUSH
105278: PPUSH
105279: PPUSH
105280: PPUSH
105281: PPUSH
105282: PPUSH
105283: PPUSH
105284: PPUSH
105285: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
105286: LD_ADDR_VAR 0 13
105290: PUSH
105291: LD_EXP 59
105295: PUSH
105296: LD_VAR 0 1
105300: ARRAY
105301: PPUSH
105302: LD_INT 25
105304: PUSH
105305: LD_INT 3
105307: PUSH
105308: EMPTY
105309: LIST
105310: LIST
105311: PPUSH
105312: CALL_OW 72
105316: ST_TO_ADDR
// if mc_remote_driver [ base ] then
105317: LD_EXP 99
105321: PUSH
105322: LD_VAR 0 1
105326: ARRAY
105327: IFFALSE 105351
// mechs := mechs diff mc_remote_driver [ base ] ;
105329: LD_ADDR_VAR 0 13
105333: PUSH
105334: LD_VAR 0 13
105338: PUSH
105339: LD_EXP 99
105343: PUSH
105344: LD_VAR 0 1
105348: ARRAY
105349: DIFF
105350: ST_TO_ADDR
// for i in mechs do
105351: LD_ADDR_VAR 0 5
105355: PUSH
105356: LD_VAR 0 13
105360: PUSH
105361: FOR_IN
105362: IFFALSE 105397
// if GetTag ( i ) > 0 then
105364: LD_VAR 0 5
105368: PPUSH
105369: CALL_OW 110
105373: PUSH
105374: LD_INT 0
105376: GREATER
105377: IFFALSE 105395
// mechs := mechs diff i ;
105379: LD_ADDR_VAR 0 13
105383: PUSH
105384: LD_VAR 0 13
105388: PUSH
105389: LD_VAR 0 5
105393: DIFF
105394: ST_TO_ADDR
105395: GO 105361
105397: POP
105398: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105399: LD_ADDR_VAR 0 9
105403: PUSH
105404: LD_EXP 59
105408: PUSH
105409: LD_VAR 0 1
105413: ARRAY
105414: PPUSH
105415: LD_INT 2
105417: PUSH
105418: LD_INT 25
105420: PUSH
105421: LD_INT 1
105423: PUSH
105424: EMPTY
105425: LIST
105426: LIST
105427: PUSH
105428: LD_INT 25
105430: PUSH
105431: LD_INT 5
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: PUSH
105438: LD_INT 25
105440: PUSH
105441: LD_INT 8
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: PUSH
105448: LD_INT 25
105450: PUSH
105451: LD_INT 9
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: PUSH
105458: EMPTY
105459: LIST
105460: LIST
105461: LIST
105462: LIST
105463: LIST
105464: PPUSH
105465: CALL_OW 72
105469: ST_TO_ADDR
// if not defenders and not solds then
105470: LD_VAR 0 2
105474: NOT
105475: PUSH
105476: LD_VAR 0 9
105480: NOT
105481: AND
105482: IFFALSE 105486
// exit ;
105484: GO 107176
// depot_under_attack := false ;
105486: LD_ADDR_VAR 0 17
105490: PUSH
105491: LD_INT 0
105493: ST_TO_ADDR
// sold_defenders := [ ] ;
105494: LD_ADDR_VAR 0 18
105498: PUSH
105499: EMPTY
105500: ST_TO_ADDR
// if mechs then
105501: LD_VAR 0 13
105505: IFFALSE 105658
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
105507: LD_ADDR_VAR 0 5
105511: PUSH
105512: LD_VAR 0 2
105516: PPUSH
105517: LD_INT 21
105519: PUSH
105520: LD_INT 2
105522: PUSH
105523: EMPTY
105524: LIST
105525: LIST
105526: PPUSH
105527: CALL_OW 72
105531: PUSH
105532: FOR_IN
105533: IFFALSE 105656
// begin if GetTag ( i ) <> 20 then
105535: LD_VAR 0 5
105539: PPUSH
105540: CALL_OW 110
105544: PUSH
105545: LD_INT 20
105547: NONEQUAL
105548: IFFALSE 105562
// SetTag ( i , 20 ) ;
105550: LD_VAR 0 5
105554: PPUSH
105555: LD_INT 20
105557: PPUSH
105558: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
105562: LD_VAR 0 5
105566: PPUSH
105567: CALL_OW 263
105571: PUSH
105572: LD_INT 1
105574: EQUAL
105575: PUSH
105576: LD_VAR 0 5
105580: PPUSH
105581: CALL_OW 311
105585: NOT
105586: AND
105587: IFFALSE 105654
// begin un := mechs [ 1 ] ;
105589: LD_ADDR_VAR 0 11
105593: PUSH
105594: LD_VAR 0 13
105598: PUSH
105599: LD_INT 1
105601: ARRAY
105602: ST_TO_ADDR
// ComExit ( un ) ;
105603: LD_VAR 0 11
105607: PPUSH
105608: CALL 51403 0 1
// AddComEnterUnit ( un , i ) ;
105612: LD_VAR 0 11
105616: PPUSH
105617: LD_VAR 0 5
105621: PPUSH
105622: CALL_OW 180
// SetTag ( un , 19 ) ;
105626: LD_VAR 0 11
105630: PPUSH
105631: LD_INT 19
105633: PPUSH
105634: CALL_OW 109
// mechs := mechs diff un ;
105638: LD_ADDR_VAR 0 13
105642: PUSH
105643: LD_VAR 0 13
105647: PUSH
105648: LD_VAR 0 11
105652: DIFF
105653: ST_TO_ADDR
// end ; end ;
105654: GO 105532
105656: POP
105657: POP
// if solds then
105658: LD_VAR 0 9
105662: IFFALSE 105721
// for i in solds do
105664: LD_ADDR_VAR 0 5
105668: PUSH
105669: LD_VAR 0 9
105673: PUSH
105674: FOR_IN
105675: IFFALSE 105719
// if not GetTag ( i ) then
105677: LD_VAR 0 5
105681: PPUSH
105682: CALL_OW 110
105686: NOT
105687: IFFALSE 105717
// begin defenders := defenders union i ;
105689: LD_ADDR_VAR 0 2
105693: PUSH
105694: LD_VAR 0 2
105698: PUSH
105699: LD_VAR 0 5
105703: UNION
105704: ST_TO_ADDR
// SetTag ( i , 18 ) ;
105705: LD_VAR 0 5
105709: PPUSH
105710: LD_INT 18
105712: PPUSH
105713: CALL_OW 109
// end ;
105717: GO 105674
105719: POP
105720: POP
// repeat wait ( 0 0$2 ) ;
105721: LD_INT 70
105723: PPUSH
105724: CALL_OW 67
// enemy := mc_scan [ base ] ;
105728: LD_ADDR_VAR 0 3
105732: PUSH
105733: LD_EXP 82
105737: PUSH
105738: LD_VAR 0 1
105742: ARRAY
105743: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105744: LD_EXP 59
105748: PUSH
105749: LD_VAR 0 1
105753: ARRAY
105754: NOT
105755: PUSH
105756: LD_EXP 59
105760: PUSH
105761: LD_VAR 0 1
105765: ARRAY
105766: PUSH
105767: EMPTY
105768: EQUAL
105769: OR
105770: IFFALSE 105807
// begin for i in defenders do
105772: LD_ADDR_VAR 0 5
105776: PUSH
105777: LD_VAR 0 2
105781: PUSH
105782: FOR_IN
105783: IFFALSE 105796
// ComStop ( i ) ;
105785: LD_VAR 0 5
105789: PPUSH
105790: CALL_OW 141
105794: GO 105782
105796: POP
105797: POP
// defenders := [ ] ;
105798: LD_ADDR_VAR 0 2
105802: PUSH
105803: EMPTY
105804: ST_TO_ADDR
// exit ;
105805: GO 107176
// end ; for i in defenders do
105807: LD_ADDR_VAR 0 5
105811: PUSH
105812: LD_VAR 0 2
105816: PUSH
105817: FOR_IN
105818: IFFALSE 106636
// begin e := NearestUnitToUnit ( enemy , i ) ;
105820: LD_ADDR_VAR 0 14
105824: PUSH
105825: LD_VAR 0 3
105829: PPUSH
105830: LD_VAR 0 5
105834: PPUSH
105835: CALL_OW 74
105839: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105840: LD_ADDR_VAR 0 8
105844: PUSH
105845: LD_EXP 59
105849: PUSH
105850: LD_VAR 0 1
105854: ARRAY
105855: PPUSH
105856: LD_INT 2
105858: PUSH
105859: LD_INT 30
105861: PUSH
105862: LD_INT 0
105864: PUSH
105865: EMPTY
105866: LIST
105867: LIST
105868: PUSH
105869: LD_INT 30
105871: PUSH
105872: LD_INT 1
105874: PUSH
105875: EMPTY
105876: LIST
105877: LIST
105878: PUSH
105879: EMPTY
105880: LIST
105881: LIST
105882: LIST
105883: PPUSH
105884: CALL_OW 72
105888: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
105889: LD_ADDR_VAR 0 17
105893: PUSH
105894: LD_VAR 0 8
105898: NOT
105899: PUSH
105900: LD_VAR 0 8
105904: PPUSH
105905: LD_INT 3
105907: PUSH
105908: LD_INT 24
105910: PUSH
105911: LD_INT 600
105913: PUSH
105914: EMPTY
105915: LIST
105916: LIST
105917: PUSH
105918: EMPTY
105919: LIST
105920: LIST
105921: PPUSH
105922: CALL_OW 72
105926: OR
105927: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
105928: LD_VAR 0 5
105932: PPUSH
105933: CALL_OW 247
105937: PUSH
105938: LD_INT 2
105940: DOUBLE
105941: EQUAL
105942: IFTRUE 105946
105944: GO 106342
105946: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
105947: LD_VAR 0 5
105951: PPUSH
105952: CALL_OW 256
105956: PUSH
105957: LD_INT 1000
105959: EQUAL
105960: PUSH
105961: LD_VAR 0 5
105965: PPUSH
105966: LD_VAR 0 14
105970: PPUSH
105971: CALL_OW 296
105975: PUSH
105976: LD_INT 40
105978: LESS
105979: PUSH
105980: LD_VAR 0 14
105984: PPUSH
105985: LD_EXP 84
105989: PUSH
105990: LD_VAR 0 1
105994: ARRAY
105995: PPUSH
105996: CALL_OW 308
106000: OR
106001: AND
106002: IFFALSE 106124
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
106004: LD_VAR 0 5
106008: PPUSH
106009: CALL_OW 262
106013: PUSH
106014: LD_INT 1
106016: EQUAL
106017: PUSH
106018: LD_VAR 0 5
106022: PPUSH
106023: CALL_OW 261
106027: PUSH
106028: LD_INT 30
106030: LESS
106031: AND
106032: PUSH
106033: LD_VAR 0 8
106037: AND
106038: IFFALSE 106108
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
106040: LD_VAR 0 5
106044: PPUSH
106045: LD_VAR 0 8
106049: PPUSH
106050: LD_VAR 0 5
106054: PPUSH
106055: CALL_OW 74
106059: PPUSH
106060: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
106064: LD_VAR 0 5
106068: PPUSH
106069: LD_VAR 0 8
106073: PPUSH
106074: LD_VAR 0 5
106078: PPUSH
106079: CALL_OW 74
106083: PPUSH
106084: CALL_OW 296
106088: PUSH
106089: LD_INT 6
106091: LESS
106092: IFFALSE 106106
// SetFuel ( i , 100 ) ;
106094: LD_VAR 0 5
106098: PPUSH
106099: LD_INT 100
106101: PPUSH
106102: CALL_OW 240
// end else
106106: GO 106122
// ComAttackUnit ( i , e ) ;
106108: LD_VAR 0 5
106112: PPUSH
106113: LD_VAR 0 14
106117: PPUSH
106118: CALL_OW 115
// end else
106122: GO 106225
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
106124: LD_VAR 0 14
106128: PPUSH
106129: LD_EXP 84
106133: PUSH
106134: LD_VAR 0 1
106138: ARRAY
106139: PPUSH
106140: CALL_OW 308
106144: NOT
106145: PUSH
106146: LD_VAR 0 5
106150: PPUSH
106151: LD_VAR 0 14
106155: PPUSH
106156: CALL_OW 296
106160: PUSH
106161: LD_INT 40
106163: GREATEREQUAL
106164: AND
106165: PUSH
106166: LD_VAR 0 5
106170: PPUSH
106171: CALL_OW 256
106175: PUSH
106176: LD_INT 650
106178: LESSEQUAL
106179: OR
106180: PUSH
106181: LD_VAR 0 5
106185: PPUSH
106186: LD_EXP 83
106190: PUSH
106191: LD_VAR 0 1
106195: ARRAY
106196: PPUSH
106197: CALL_OW 308
106201: NOT
106202: AND
106203: IFFALSE 106225
// ComMoveToArea ( i , mc_parking [ base ] ) ;
106205: LD_VAR 0 5
106209: PPUSH
106210: LD_EXP 83
106214: PUSH
106215: LD_VAR 0 1
106219: ARRAY
106220: PPUSH
106221: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
106225: LD_VAR 0 5
106229: PPUSH
106230: CALL_OW 256
106234: PUSH
106235: LD_INT 1000
106237: LESS
106238: PUSH
106239: LD_VAR 0 5
106243: PPUSH
106244: CALL_OW 263
106248: PUSH
106249: LD_INT 1
106251: EQUAL
106252: AND
106253: PUSH
106254: LD_VAR 0 5
106258: PPUSH
106259: CALL_OW 311
106263: AND
106264: PUSH
106265: LD_VAR 0 5
106269: PPUSH
106270: LD_EXP 83
106274: PUSH
106275: LD_VAR 0 1
106279: ARRAY
106280: PPUSH
106281: CALL_OW 308
106285: AND
106286: IFFALSE 106340
// begin mech := IsDrivenBy ( i ) ;
106288: LD_ADDR_VAR 0 10
106292: PUSH
106293: LD_VAR 0 5
106297: PPUSH
106298: CALL_OW 311
106302: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
106303: LD_VAR 0 10
106307: PPUSH
106308: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
106312: LD_VAR 0 10
106316: PPUSH
106317: LD_VAR 0 5
106321: PPUSH
106322: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
106326: LD_VAR 0 10
106330: PPUSH
106331: LD_VAR 0 5
106335: PPUSH
106336: CALL_OW 180
// end ; end ; unit_human :
106340: GO 106607
106342: LD_INT 1
106344: DOUBLE
106345: EQUAL
106346: IFTRUE 106350
106348: GO 106606
106350: POP
// begin b := IsInUnit ( i ) ;
106351: LD_ADDR_VAR 0 19
106355: PUSH
106356: LD_VAR 0 5
106360: PPUSH
106361: CALL_OW 310
106365: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
106366: LD_ADDR_VAR 0 20
106370: PUSH
106371: LD_VAR 0 19
106375: NOT
106376: PUSH
106377: LD_VAR 0 19
106381: PPUSH
106382: CALL_OW 266
106386: PUSH
106387: LD_INT 32
106389: PUSH
106390: LD_INT 31
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: IN
106397: OR
106398: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
106399: LD_VAR 0 17
106403: PUSH
106404: LD_VAR 0 2
106408: PPUSH
106409: LD_INT 21
106411: PUSH
106412: LD_INT 2
106414: PUSH
106415: EMPTY
106416: LIST
106417: LIST
106418: PPUSH
106419: CALL_OW 72
106423: PUSH
106424: LD_INT 1
106426: LESSEQUAL
106427: OR
106428: PUSH
106429: LD_VAR 0 20
106433: AND
106434: PUSH
106435: LD_VAR 0 5
106439: PUSH
106440: LD_VAR 0 18
106444: IN
106445: NOT
106446: AND
106447: IFFALSE 106540
// begin if b then
106449: LD_VAR 0 19
106453: IFFALSE 106502
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
106455: LD_VAR 0 19
106459: PPUSH
106460: LD_VAR 0 3
106464: PPUSH
106465: LD_VAR 0 19
106469: PPUSH
106470: CALL_OW 74
106474: PPUSH
106475: CALL_OW 296
106479: PUSH
106480: LD_INT 10
106482: LESS
106483: PUSH
106484: LD_VAR 0 19
106488: PPUSH
106489: CALL_OW 461
106493: PUSH
106494: LD_INT 7
106496: NONEQUAL
106497: AND
106498: IFFALSE 106502
// continue ;
106500: GO 105817
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
106502: LD_ADDR_VAR 0 18
106506: PUSH
106507: LD_VAR 0 18
106511: PPUSH
106512: LD_VAR 0 18
106516: PUSH
106517: LD_INT 1
106519: PLUS
106520: PPUSH
106521: LD_VAR 0 5
106525: PPUSH
106526: CALL_OW 1
106530: ST_TO_ADDR
// ComExitBuilding ( i ) ;
106531: LD_VAR 0 5
106535: PPUSH
106536: CALL_OW 122
// end ; if sold_defenders then
106540: LD_VAR 0 18
106544: IFFALSE 106604
// if i in sold_defenders then
106546: LD_VAR 0 5
106550: PUSH
106551: LD_VAR 0 18
106555: IN
106556: IFFALSE 106604
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
106558: LD_VAR 0 5
106562: PPUSH
106563: CALL_OW 314
106567: NOT
106568: PUSH
106569: LD_VAR 0 5
106573: PPUSH
106574: LD_VAR 0 14
106578: PPUSH
106579: CALL_OW 296
106583: PUSH
106584: LD_INT 30
106586: LESS
106587: AND
106588: IFFALSE 106604
// ComAttackUnit ( i , e ) ;
106590: LD_VAR 0 5
106594: PPUSH
106595: LD_VAR 0 14
106599: PPUSH
106600: CALL_OW 115
// end ; end ; end ;
106604: GO 106607
106606: POP
// if IsDead ( i ) then
106607: LD_VAR 0 5
106611: PPUSH
106612: CALL_OW 301
106616: IFFALSE 106634
// defenders := defenders diff i ;
106618: LD_ADDR_VAR 0 2
106622: PUSH
106623: LD_VAR 0 2
106627: PUSH
106628: LD_VAR 0 5
106632: DIFF
106633: ST_TO_ADDR
// end ;
106634: GO 105817
106636: POP
106637: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
106638: LD_VAR 0 3
106642: NOT
106643: PUSH
106644: LD_VAR 0 2
106648: NOT
106649: OR
106650: PUSH
106651: LD_EXP 59
106655: PUSH
106656: LD_VAR 0 1
106660: ARRAY
106661: NOT
106662: OR
106663: IFFALSE 105721
// MC_Reset ( base , 18 ) ;
106665: LD_VAR 0 1
106669: PPUSH
106670: LD_INT 18
106672: PPUSH
106673: CALL 56480 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106677: LD_ADDR_VAR 0 2
106681: PUSH
106682: LD_VAR 0 2
106686: PUSH
106687: LD_VAR 0 2
106691: PPUSH
106692: LD_INT 2
106694: PUSH
106695: LD_INT 25
106697: PUSH
106698: LD_INT 1
106700: PUSH
106701: EMPTY
106702: LIST
106703: LIST
106704: PUSH
106705: LD_INT 25
106707: PUSH
106708: LD_INT 5
106710: PUSH
106711: EMPTY
106712: LIST
106713: LIST
106714: PUSH
106715: LD_INT 25
106717: PUSH
106718: LD_INT 8
106720: PUSH
106721: EMPTY
106722: LIST
106723: LIST
106724: PUSH
106725: LD_INT 25
106727: PUSH
106728: LD_INT 9
106730: PUSH
106731: EMPTY
106732: LIST
106733: LIST
106734: PUSH
106735: EMPTY
106736: LIST
106737: LIST
106738: LIST
106739: LIST
106740: LIST
106741: PPUSH
106742: CALL_OW 72
106746: DIFF
106747: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
106748: LD_VAR 0 3
106752: NOT
106753: PUSH
106754: LD_VAR 0 2
106758: PPUSH
106759: LD_INT 21
106761: PUSH
106762: LD_INT 2
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: PPUSH
106769: CALL_OW 72
106773: AND
106774: IFFALSE 107112
// begin tmp := FilterByTag ( defenders , 19 ) ;
106776: LD_ADDR_VAR 0 12
106780: PUSH
106781: LD_VAR 0 2
106785: PPUSH
106786: LD_INT 19
106788: PPUSH
106789: CALL 48533 0 2
106793: ST_TO_ADDR
// if tmp then
106794: LD_VAR 0 12
106798: IFFALSE 106868
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
106800: LD_ADDR_VAR 0 12
106804: PUSH
106805: LD_VAR 0 12
106809: PPUSH
106810: LD_INT 25
106812: PUSH
106813: LD_INT 3
106815: PUSH
106816: EMPTY
106817: LIST
106818: LIST
106819: PPUSH
106820: CALL_OW 72
106824: ST_TO_ADDR
// if tmp then
106825: LD_VAR 0 12
106829: IFFALSE 106868
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
106831: LD_ADDR_EXP 71
106835: PUSH
106836: LD_EXP 71
106840: PPUSH
106841: LD_VAR 0 1
106845: PPUSH
106846: LD_EXP 71
106850: PUSH
106851: LD_VAR 0 1
106855: ARRAY
106856: PUSH
106857: LD_VAR 0 12
106861: UNION
106862: PPUSH
106863: CALL_OW 1
106867: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
106868: LD_VAR 0 1
106872: PPUSH
106873: LD_INT 19
106875: PPUSH
106876: CALL 56480 0 2
// repeat wait ( 0 0$1 ) ;
106880: LD_INT 35
106882: PPUSH
106883: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106887: LD_EXP 59
106891: PUSH
106892: LD_VAR 0 1
106896: ARRAY
106897: NOT
106898: PUSH
106899: LD_EXP 59
106903: PUSH
106904: LD_VAR 0 1
106908: ARRAY
106909: PUSH
106910: EMPTY
106911: EQUAL
106912: OR
106913: IFFALSE 106950
// begin for i in defenders do
106915: LD_ADDR_VAR 0 5
106919: PUSH
106920: LD_VAR 0 2
106924: PUSH
106925: FOR_IN
106926: IFFALSE 106939
// ComStop ( i ) ;
106928: LD_VAR 0 5
106932: PPUSH
106933: CALL_OW 141
106937: GO 106925
106939: POP
106940: POP
// defenders := [ ] ;
106941: LD_ADDR_VAR 0 2
106945: PUSH
106946: EMPTY
106947: ST_TO_ADDR
// exit ;
106948: GO 107176
// end ; for i in defenders do
106950: LD_ADDR_VAR 0 5
106954: PUSH
106955: LD_VAR 0 2
106959: PUSH
106960: FOR_IN
106961: IFFALSE 107050
// begin if not IsInArea ( i , mc_parking [ base ] ) then
106963: LD_VAR 0 5
106967: PPUSH
106968: LD_EXP 83
106972: PUSH
106973: LD_VAR 0 1
106977: ARRAY
106978: PPUSH
106979: CALL_OW 308
106983: NOT
106984: IFFALSE 107008
// ComMoveToArea ( i , mc_parking [ base ] ) else
106986: LD_VAR 0 5
106990: PPUSH
106991: LD_EXP 83
106995: PUSH
106996: LD_VAR 0 1
107000: ARRAY
107001: PPUSH
107002: CALL_OW 113
107006: GO 107048
// if GetControl ( i ) = control_manual then
107008: LD_VAR 0 5
107012: PPUSH
107013: CALL_OW 263
107017: PUSH
107018: LD_INT 1
107020: EQUAL
107021: IFFALSE 107048
// if IsDrivenBy ( i ) then
107023: LD_VAR 0 5
107027: PPUSH
107028: CALL_OW 311
107032: IFFALSE 107048
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
107034: LD_VAR 0 5
107038: PPUSH
107039: CALL_OW 311
107043: PPUSH
107044: CALL_OW 121
// end ;
107048: GO 106960
107050: POP
107051: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
107052: LD_VAR 0 2
107056: PPUSH
107057: LD_INT 95
107059: PUSH
107060: LD_EXP 83
107064: PUSH
107065: LD_VAR 0 1
107069: ARRAY
107070: PUSH
107071: EMPTY
107072: LIST
107073: LIST
107074: PPUSH
107075: CALL_OW 72
107079: PUSH
107080: LD_VAR 0 2
107084: EQUAL
107085: PUSH
107086: LD_EXP 82
107090: PUSH
107091: LD_VAR 0 1
107095: ARRAY
107096: OR
107097: PUSH
107098: LD_EXP 59
107102: PUSH
107103: LD_VAR 0 1
107107: ARRAY
107108: NOT
107109: OR
107110: IFFALSE 106880
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
107112: LD_ADDR_EXP 81
107116: PUSH
107117: LD_EXP 81
107121: PPUSH
107122: LD_VAR 0 1
107126: PPUSH
107127: LD_VAR 0 2
107131: PPUSH
107132: LD_INT 21
107134: PUSH
107135: LD_INT 2
107137: PUSH
107138: EMPTY
107139: LIST
107140: LIST
107141: PPUSH
107142: CALL_OW 72
107146: PPUSH
107147: CALL_OW 1
107151: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
107152: LD_VAR 0 1
107156: PPUSH
107157: LD_INT 19
107159: PPUSH
107160: CALL 56480 0 2
// MC_Reset ( base , 20 ) ;
107164: LD_VAR 0 1
107168: PPUSH
107169: LD_INT 20
107171: PPUSH
107172: CALL 56480 0 2
// end ; end_of_file
107176: LD_VAR 0 4
107180: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
107181: LD_VAR 0 1
107185: PUSH
107186: LD_INT 200
107188: DOUBLE
107189: GREATEREQUAL
107190: IFFALSE 107198
107192: LD_INT 299
107194: DOUBLE
107195: LESSEQUAL
107196: IFTRUE 107200
107198: GO 107232
107200: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
107201: LD_VAR 0 1
107205: PPUSH
107206: LD_VAR 0 2
107210: PPUSH
107211: LD_VAR 0 3
107215: PPUSH
107216: LD_VAR 0 4
107220: PPUSH
107221: LD_VAR 0 5
107225: PPUSH
107226: CALL 96114 0 5
107230: GO 107309
107232: LD_INT 300
107234: DOUBLE
107235: GREATEREQUAL
107236: IFFALSE 107244
107238: LD_INT 399
107240: DOUBLE
107241: LESSEQUAL
107242: IFTRUE 107246
107244: GO 107308
107246: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
107247: LD_VAR 0 1
107251: PPUSH
107252: LD_VAR 0 2
107256: PPUSH
107257: LD_VAR 0 3
107261: PPUSH
107262: LD_VAR 0 4
107266: PPUSH
107267: LD_VAR 0 5
107271: PPUSH
107272: LD_VAR 0 6
107276: PPUSH
107277: LD_VAR 0 7
107281: PPUSH
107282: LD_VAR 0 8
107286: PPUSH
107287: LD_VAR 0 9
107291: PPUSH
107292: LD_VAR 0 10
107296: PPUSH
107297: LD_VAR 0 11
107301: PPUSH
107302: CALL 94002 0 11
107306: GO 107309
107308: POP
// end ;
107309: PPOPN 11
107311: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
107312: LD_VAR 0 1
107316: PPUSH
107317: LD_VAR 0 2
107321: PPUSH
107322: LD_VAR 0 3
107326: PPUSH
107327: LD_VAR 0 4
107331: PPUSH
107332: LD_VAR 0 5
107336: PPUSH
107337: CALL 96096 0 5
// end ; end_of_file
107341: PPOPN 5
107343: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
107344: LD_VAR 0 1
107348: PPUSH
107349: LD_VAR 0 2
107353: PPUSH
107354: LD_VAR 0 3
107358: PPUSH
107359: LD_VAR 0 4
107363: PPUSH
107364: LD_VAR 0 5
107368: PPUSH
107369: LD_VAR 0 6
107373: PPUSH
107374: CALL 82810 0 6
// end ;
107378: PPOPN 6
107380: END
