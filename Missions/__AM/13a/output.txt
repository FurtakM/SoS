// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 58184 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 50398 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 50398 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 50398 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 50398 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4560 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 60364 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 8227 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 82081 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 82526 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 82984 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 83253 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 82466 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 83160 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 82526 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 82984 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 83253 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 82310 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 83571 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 82466 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 16019 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 16019 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 16019 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 16019 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 16019 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 16019 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 16019 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 16019 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 16019 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 16019 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 16019 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 16019 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 16019 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 16019 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 16019 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 16019 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 16019 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 16019 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 20859 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 20859 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 20859 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 24680 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 20859 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4082
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
// begin enable ;
3341: ENABLE
// base := 2 ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 2
3349: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: LD_INT 0
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 0
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3397: LD_ADDR_VAR 0 4
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 21
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 22
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 45
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: LD_INT 23
3458: PUSH
3459: LD_INT 1
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: LD_INT 46
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: ST_TO_ADDR
// amount := Difficulty ;
3480: LD_ADDR_VAR 0 8
3484: PUSH
3485: LD_OWVAR 67
3489: ST_TO_ADDR
// if tick > 30 30$00 then
3490: LD_OWVAR 1
3494: PUSH
3495: LD_INT 63000
3497: GREATER
3498: IFFALSE 3535
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3500: LD_ADDR_VAR 0 8
3504: PUSH
3505: LD_VAR 0 8
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: LD_INT 3
3515: PUSH
3516: LD_INT 4
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_OWVAR 67
3532: ARRAY
3533: PLUS
3534: ST_TO_ADDR
// for i = 1 to amount do
3535: LD_ADDR_VAR 0 1
3539: PUSH
3540: DOUBLE
3541: LD_INT 1
3543: DEC
3544: ST_TO_ADDR
3545: LD_VAR 0 8
3549: PUSH
3550: FOR_TO
3551: IFFALSE 3639
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3553: LD_ADDR_VAR 0 4
3557: PUSH
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_VAR 0 4
3567: PUSH
3568: LD_INT 1
3570: PLUS
3571: PPUSH
3572: LD_INT 23
3574: PUSH
3575: LD_INT 24
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 1
3584: PPUSH
3585: LD_INT 2
3587: PPUSH
3588: CALL_OW 12
3592: ARRAY
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: LD_INT 3
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 47
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: CALL_OW 12
3624: ARRAY
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 2
3636: ST_TO_ADDR
3637: GO 3550
3639: POP
3640: POP
// p := 1 ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_VAR 0 4
3658: PPUSH
3659: CALL 82466 0 2
// repeat wait ( 0 0$1 ) ;
3663: LD_INT 35
3665: PPUSH
3666: CALL_OW 67
// p := Inc ( p ) ;
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: CALL 55082 0 1
3684: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 80 ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL 83884 0 2
3697: PUSH
3698: LD_VAR 0 8
3702: GREATEREQUAL
3703: PUSH
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 80
3711: GREATEREQUAL
3712: OR
3713: IFFALSE 3663
// wait ( 0 0$30 ) ;
3715: LD_INT 1050
3717: PPUSH
3718: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_INT 71
3729: PUSH
3730: LD_INT 19
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 91
3739: PUSH
3740: LD_INT 67
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 52
3749: PUSH
3750: LD_INT 44
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 68
3759: PUSH
3760: LD_INT 48
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_EXP 80
3782: PUSH
3783: LD_VAR 0 3
3787: ARRAY
3788: PUSH
3789: LD_EXP 80
3793: PUSH
3794: LD_VAR 0 3
3798: ARRAY
3799: PPUSH
3800: LD_INT 2
3802: PUSH
3803: LD_INT 34
3805: PUSH
3806: LD_INT 51
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 34
3815: PUSH
3816: LD_INT 52
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 72
3832: DIFF
3833: ST_TO_ADDR
// if not attackers then
3834: LD_VAR 0 7
3838: NOT
3839: IFFALSE 3843
// exit ;
3841: GO 4082
// ru_attackers := attackers ;
3843: LD_ADDR_EXP 54
3847: PUSH
3848: LD_VAR 0 7
3852: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3853: LD_ADDR_EXP 80
3857: PUSH
3858: LD_EXP 80
3862: PPUSH
3863: LD_VAR 0 3
3867: PPUSH
3868: LD_EXP 80
3872: PUSH
3873: LD_VAR 0 3
3877: ARRAY
3878: PUSH
3879: LD_VAR 0 7
3883: DIFF
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// for i = 1 to attackers do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: DOUBLE
3896: LD_INT 1
3898: DEC
3899: ST_TO_ADDR
3900: LD_VAR 0 7
3904: PUSH
3905: FOR_TO
3906: IFFALSE 3983
// begin case i mod 3 of 0 :
3908: LD_VAR 0 1
3912: PUSH
3913: LD_INT 3
3915: MOD
3916: PUSH
3917: LD_INT 0
3919: DOUBLE
3920: EQUAL
3921: IFTRUE 3925
3923: GO 3928
3925: POP
// ; 1 :
3926: GO 3981
3928: LD_INT 1
3930: DOUBLE
3931: EQUAL
3932: IFTRUE 3936
3934: GO 3954
3936: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3937: LD_VAR 0 1
3941: PPUSH
3942: LD_INT 32
3944: PPUSH
3945: LD_INT 49
3947: PPUSH
3948: CALL_OW 114
3952: GO 3981
3954: LD_INT 2
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 3980
3962: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_INT 117
3970: PPUSH
3971: LD_INT 107
3973: PPUSH
3974: CALL_OW 114
3978: GO 3981
3980: POP
// end ;
3981: GO 3905
3983: POP
3984: POP
// p := 0 ;
3985: LD_ADDR_VAR 0 2
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// p := Inc ( p ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_VAR 0 2
4009: PPUSH
4010: CALL 55082 0 1
4014: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 60
4022: PUSH
4023: EMPTY
4024: LIST
4025: PPUSH
4026: CALL_OW 72
4030: NOT
4031: PUSH
4032: LD_VAR 0 2
4036: PUSH
4037: LD_INT 30
4039: GREATER
4040: OR
4041: IFFALSE 3993
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
4043: LD_VAR 0 3
4047: PPUSH
4048: LD_VAR 0 7
4052: PPUSH
4053: LD_VAR 0 6
4057: PPUSH
4058: LD_VAR 0 5
4062: PPUSH
4063: CALL 82651 0 4
// if not first_attack then
4067: LD_EXP 7
4071: NOT
4072: IFFALSE 4082
// first_attack := true ;
4074: LD_ADDR_EXP 7
4078: PUSH
4079: LD_INT 1
4081: ST_TO_ADDR
// end ;
4082: PPOPN 8
4084: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
// uc_side := 6 ;
4093: LD_ADDR_OWVAR 20
4097: PUSH
4098: LD_INT 6
4100: ST_TO_ADDR
// uc_nation := 3 ;
4101: LD_ADDR_OWVAR 21
4105: PUSH
4106: LD_INT 3
4108: ST_TO_ADDR
// InitHc ;
4109: CALL_OW 19
// InitVc ;
4113: CALL_OW 20
// tmp := [ ] ;
4117: LD_ADDR_VAR 0 3
4121: PUSH
4122: EMPTY
4123: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4124: LD_ADDR_VAR 0 2
4128: PUSH
4129: DOUBLE
4130: LD_INT 1
4132: DEC
4133: ST_TO_ADDR
4134: LD_INT 4
4136: PUSH
4137: LD_INT 5
4139: PUSH
4140: LD_INT 6
4142: PUSH
4143: LD_INT 7
4145: PUSH
4146: EMPTY
4147: LIST
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_OWVAR 67
4156: ARRAY
4157: PUSH
4158: FOR_TO
4159: IFFALSE 4413
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4161: LD_ADDR_VAR 0 5
4165: PUSH
4166: LD_INT 21
4168: PUSH
4169: LD_INT 22
4171: PUSH
4172: LD_INT 24
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: LD_INT 1
4182: PPUSH
4183: LD_INT 3
4185: PPUSH
4186: CALL_OW 12
4190: ARRAY
4191: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4192: LD_VAR 0 5
4196: PUSH
4197: LD_INT 21
4199: DOUBLE
4200: EQUAL
4201: IFTRUE 4211
4203: LD_INT 22
4205: DOUBLE
4206: EQUAL
4207: IFTRUE 4211
4209: GO 4245
4211: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4212: LD_ADDR_VAR 0 6
4216: PUSH
4217: LD_INT 45
4219: PUSH
4220: LD_INT 44
4222: PUSH
4223: LD_INT 43
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 1
4233: PPUSH
4234: LD_INT 3
4236: PPUSH
4237: CALL_OW 12
4241: ARRAY
4242: ST_TO_ADDR
4243: GO 4292
4245: LD_INT 24
4247: DOUBLE
4248: EQUAL
4249: IFTRUE 4253
4251: GO 4291
4253: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4254: LD_ADDR_VAR 0 6
4258: PUSH
4259: LD_INT 46
4261: PUSH
4262: LD_INT 47
4264: PUSH
4265: LD_INT 45
4267: PUSH
4268: LD_INT 46
4270: PUSH
4271: EMPTY
4272: LIST
4273: LIST
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 1
4279: PPUSH
4280: LD_INT 4
4282: PPUSH
4283: CALL_OW 12
4287: ARRAY
4288: ST_TO_ADDR
4289: GO 4292
4291: POP
// uc_side := 6 ;
4292: LD_ADDR_OWVAR 20
4296: PUSH
4297: LD_INT 6
4299: ST_TO_ADDR
// uc_nation := 3 ;
4300: LD_ADDR_OWVAR 21
4304: PUSH
4305: LD_INT 3
4307: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4308: LD_VAR 0 5
4312: PPUSH
4313: LD_INT 1
4315: PUSH
4316: LD_INT 3
4318: PUSH
4319: EMPTY
4320: LIST
4321: LIST
4322: PUSH
4323: LD_INT 1
4325: PPUSH
4326: LD_INT 2
4328: PPUSH
4329: CALL_OW 12
4333: ARRAY
4334: PPUSH
4335: LD_INT 3
4337: PPUSH
4338: LD_VAR 0 6
4342: PPUSH
4343: LD_INT 70
4345: PPUSH
4346: LD_INT 90
4348: PPUSH
4349: CALL_OW 12
4353: PPUSH
4354: CALL 20859 0 5
// veh := CreateVehicle ;
4358: LD_ADDR_VAR 0 4
4362: PUSH
4363: CALL_OW 45
4367: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4368: LD_VAR 0 4
4372: PPUSH
4373: LD_INT 5
4375: PPUSH
4376: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4380: LD_VAR 0 4
4384: PPUSH
4385: LD_INT 16
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 49
// tmp := tmp ^ veh ;
4395: LD_ADDR_VAR 0 3
4399: PUSH
4400: LD_VAR 0 3
4404: PUSH
4405: LD_VAR 0 4
4409: ADD
4410: ST_TO_ADDR
// end ;
4411: GO 4158
4413: POP
4414: POP
// if not tmp then
4415: LD_VAR 0 3
4419: NOT
4420: IFFALSE 4424
// exit ;
4422: GO 4518
// repeat wait ( 0 0$2 ) ;
4424: LD_INT 70
4426: PPUSH
4427: CALL_OW 67
// for i in tmp do
4431: LD_ADDR_VAR 0 2
4435: PUSH
4436: LD_VAR 0 3
4440: PUSH
4441: FOR_IN
4442: IFFALSE 4509
// if IsOk ( i ) then
4444: LD_VAR 0 2
4448: PPUSH
4449: CALL_OW 302
4453: IFFALSE 4491
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
4455: LD_VAR 0 2
4459: PPUSH
4460: LD_INT 81
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: PPUSH
4475: LD_VAR 0 2
4479: PPUSH
4480: CALL_OW 74
4484: PPUSH
4485: CALL_OW 115
4489: GO 4507
// tmp := tmp diff i ;
4491: LD_ADDR_VAR 0 3
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_VAR 0 2
4505: DIFF
4506: ST_TO_ADDR
4507: GO 4441
4509: POP
4510: POP
// until not tmp ;
4511: LD_VAR 0 3
4515: NOT
4516: IFFALSE 4424
// end ;
4518: LD_VAR 0 1
4522: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 do
4523: LD_EXP 7
4527: PUSH
4528: LD_INT 47
4530: PPUSH
4531: CALL_OW 302
4535: AND
4536: PUSH
4537: LD_INT 47
4539: PPUSH
4540: CALL_OW 255
4544: PUSH
4545: LD_INT 3
4547: EQUAL
4548: AND
4549: IFFALSE 4559
4551: GO 4553
4553: DISABLE
// begin enable ;
4554: ENABLE
// PrepareRussianAttack ;
4555: CALL 4085 0 0
// end ; end_of_file
4559: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4560: LD_INT 0
4562: PPUSH
4563: PPUSH
4564: PPUSH
4565: PPUSH
4566: PPUSH
4567: PPUSH
4568: PPUSH
// uc_side := 2 ;
4569: LD_ADDR_OWVAR 20
4573: PUSH
4574: LD_INT 2
4576: ST_TO_ADDR
// uc_nation := 2 ;
4577: LD_ADDR_OWVAR 21
4581: PUSH
4582: LD_INT 2
4584: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4585: LD_ADDR_EXP 57
4589: PUSH
4590: LD_STRING Abdul
4592: PPUSH
4593: CALL_OW 25
4597: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4598: LD_EXP 57
4602: PPUSH
4603: LD_INT 11
4605: PPUSH
4606: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4610: LD_EXP 57
4614: PPUSH
4615: LD_INT 1
4617: PPUSH
4618: CALL_OW 52
// vc_chassis := 31 ;
4622: LD_ADDR_OWVAR 37
4626: PUSH
4627: LD_INT 31
4629: ST_TO_ADDR
// vc_control := control_rider ;
4630: LD_ADDR_OWVAR 38
4634: PUSH
4635: LD_INT 4
4637: ST_TO_ADDR
// mastodont := CreateVehicle ;
4638: LD_ADDR_EXP 58
4642: PUSH
4643: CALL_OW 45
4647: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4648: LD_EXP 58
4652: PPUSH
4653: LD_INT 153
4655: PPUSH
4656: LD_INT 71
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 48
// InitVc ;
4666: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 7 ] ) ;
4670: LD_ADDR_EXP 55
4674: PUSH
4675: LD_INT 1
4677: PPUSH
4678: LD_INT 3
4680: PPUSH
4681: LD_STRING kaba
4683: PPUSH
4684: LD_INT 7
4686: PUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: LIST
4700: LIST
4701: PUSH
4702: LD_OWVAR 67
4706: ARRAY
4707: PPUSH
4708: LD_INT 5000
4710: PUSH
4711: LD_INT 1000
4713: PUSH
4714: LD_INT 300
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: LIST
4721: PPUSH
4722: LD_INT 18
4724: PUSH
4725: LD_INT 5
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: LIST
4738: LIST
4739: PPUSH
4740: CALL 24680 0 6
4744: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4745: LD_ADDR_EXP 61
4749: PUSH
4750: LD_EXP 61
4754: PPUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_EXP 55
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// tmp := [ ] ;
4768: LD_ADDR_VAR 0 4
4772: PUSH
4773: EMPTY
4774: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4775: LD_ADDR_OWVAR 37
4779: PUSH
4780: LD_INT 13
4782: ST_TO_ADDR
// vc_engine := engine_siberite ;
4783: LD_ADDR_OWVAR 39
4787: PUSH
4788: LD_INT 3
4790: ST_TO_ADDR
// vc_control := control_manual ;
4791: LD_ADDR_OWVAR 38
4795: PUSH
4796: LD_INT 1
4798: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4799: LD_ADDR_OWVAR 40
4803: PUSH
4804: LD_INT 31
4806: ST_TO_ADDR
// for i = 1 to 3 do
4807: LD_ADDR_VAR 0 2
4811: PUSH
4812: DOUBLE
4813: LD_INT 1
4815: DEC
4816: ST_TO_ADDR
4817: LD_INT 3
4819: PUSH
4820: FOR_TO
4821: IFFALSE 5069
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4823: LD_ADDR_VAR 0 5
4827: PUSH
4828: LD_INT 153
4830: PUSH
4831: LD_INT 71
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 155
4840: PUSH
4841: LD_INT 81
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_VAR 0 2
4856: PUSH
4857: LD_INT 2
4859: MOD
4860: PUSH
4861: LD_INT 1
4863: PLUS
4864: ARRAY
4865: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4866: LD_INT 0
4868: PPUSH
4869: LD_INT 3
4871: PPUSH
4872: LD_INT 7
4874: PUSH
4875: LD_INT 8
4877: PUSH
4878: LD_INT 10
4880: PUSH
4881: LD_INT 10
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: PUSH
4890: LD_OWVAR 67
4894: ARRAY
4895: PPUSH
4896: CALL_OW 380
// un := CreateVehicle ;
4900: LD_ADDR_VAR 0 6
4904: PUSH
4905: CALL_OW 45
4909: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4910: LD_VAR 0 6
4914: PPUSH
4915: LD_INT 0
4917: PPUSH
4918: LD_INT 5
4920: PPUSH
4921: CALL_OW 12
4925: PPUSH
4926: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4930: LD_VAR 0 6
4934: PPUSH
4935: LD_VAR 0 5
4939: PUSH
4940: LD_INT 1
4942: ARRAY
4943: PPUSH
4944: LD_VAR 0 5
4948: PUSH
4949: LD_INT 2
4951: ARRAY
4952: PPUSH
4953: LD_INT 6
4955: PPUSH
4956: LD_INT 0
4958: PPUSH
4959: CALL_OW 50
// un2 := CreateHuman ;
4963: LD_ADDR_VAR 0 7
4967: PUSH
4968: CALL_OW 44
4972: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4973: LD_VAR 0 7
4977: PPUSH
4978: LD_VAR 0 6
4982: PPUSH
4983: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4987: LD_ADDR_EXP 61
4991: PUSH
4992: LD_EXP 61
4996: PPUSH
4997: LD_INT 1
4999: PUSH
5000: LD_EXP 61
5004: PUSH
5005: LD_INT 1
5007: ARRAY
5008: PUSH
5009: LD_INT 1
5011: PLUS
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PPUSH
5017: LD_VAR 0 6
5021: PPUSH
5022: CALL 20981 0 3
5026: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5027: LD_ADDR_EXP 61
5031: PUSH
5032: LD_EXP 61
5036: PPUSH
5037: LD_INT 1
5039: PUSH
5040: LD_EXP 61
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PUSH
5049: LD_INT 1
5051: PLUS
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: LD_VAR 0 7
5061: PPUSH
5062: CALL 20981 0 3
5066: ST_TO_ADDR
// end ;
5067: GO 4820
5069: POP
5070: POP
// for i = 1 to 5 do
5071: LD_ADDR_VAR 0 2
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 5
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5178
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5087: LD_INT 13
5089: PPUSH
5090: LD_INT 3
5092: PPUSH
5093: LD_INT 1
5095: PPUSH
5096: LD_INT 25
5098: PUSH
5099: LD_INT 28
5101: PUSH
5102: LD_INT 28
5104: PUSH
5105: LD_INT 26
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: LIST
5112: LIST
5113: PUSH
5114: LD_VAR 0 2
5118: PUSH
5119: LD_INT 4
5121: MOD
5122: PUSH
5123: LD_INT 1
5125: PLUS
5126: ARRAY
5127: PPUSH
5128: LD_INT 100
5130: PPUSH
5131: CALL 20859 0 5
// veh := CreateVehicle ;
5135: LD_ADDR_VAR 0 3
5139: PUSH
5140: CALL_OW 45
5144: ST_TO_ADDR
// tmp := tmp ^ veh ;
5145: LD_ADDR_VAR 0 4
5149: PUSH
5150: LD_VAR 0 4
5154: PUSH
5155: LD_VAR 0 3
5159: ADD
5160: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5161: LD_VAR 0 3
5165: PPUSH
5166: LD_INT 1
5168: PPUSH
5169: LD_INT 0
5171: PPUSH
5172: CALL_OW 49
// end ;
5176: GO 5084
5178: POP
5179: POP
// arabian_guard := tmp ;
5180: LD_ADDR_EXP 56
5184: PUSH
5185: LD_VAR 0 4
5189: ST_TO_ADDR
// end ;
5190: LD_VAR 0 1
5194: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5195: LD_INT 22
5197: PUSH
5198: LD_INT 7
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: PUSH
5205: LD_INT 91
5207: PUSH
5208: LD_INT 1
5210: PUSH
5211: LD_INT 12
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: LIST
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PPUSH
5223: CALL_OW 69
5227: PUSH
5228: LD_EXP 58
5232: PPUSH
5233: CALL_OW 256
5237: PUSH
5238: LD_INT 990
5240: LESS
5241: OR
5242: PUSH
5243: LD_EXP 57
5247: PPUSH
5248: CALL_OW 256
5252: PUSH
5253: LD_INT 990
5255: LESS
5256: OR
5257: IFFALSE 5400
5259: GO 5261
5261: DISABLE
// begin if IsInUnit ( Abdul ) then
5262: LD_EXP 57
5266: PPUSH
5267: CALL_OW 310
5271: IFFALSE 5282
// ComExitBuilding ( Abdul ) ;
5273: LD_EXP 57
5277: PPUSH
5278: CALL_OW 122
// if Mastodont then
5282: LD_EXP 58
5286: IFFALSE 5303
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5288: LD_EXP 58
5292: PPUSH
5293: LD_INT 205
5295: PPUSH
5296: LD_INT 132
5298: PPUSH
5299: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5303: LD_EXP 57
5307: PPUSH
5308: LD_INT 205
5310: PPUSH
5311: LD_INT 132
5313: PPUSH
5314: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5318: LD_INT 35
5320: PPUSH
5321: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5325: LD_EXP 57
5329: PPUSH
5330: LD_INT 21
5332: PPUSH
5333: CALL_OW 308
5337: IFFALSE 5318
// RemoveUnit ( Abdul ) ;
5339: LD_EXP 57
5343: PPUSH
5344: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5348: LD_INT 35
5350: PPUSH
5351: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5355: LD_EXP 58
5359: PPUSH
5360: LD_INT 21
5362: PPUSH
5363: CALL_OW 308
5367: PUSH
5368: LD_EXP 58
5372: PPUSH
5373: CALL_OW 301
5377: OR
5378: IFFALSE 5348
// if IsOk ( Mastodont ) then
5380: LD_EXP 58
5384: PPUSH
5385: CALL_OW 302
5389: IFFALSE 5400
// RemoveUnit ( Mastodont ) ;
5391: LD_EXP 58
5395: PPUSH
5396: CALL_OW 64
// end ;
5400: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5401: LD_EXP 57
5405: PPUSH
5406: CALL_OW 301
5410: PUSH
5411: LD_INT 22
5413: PUSH
5414: LD_INT 2
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: LD_INT 2
5423: PUSH
5424: LD_INT 25
5426: PUSH
5427: LD_INT 1
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: PUSH
5434: LD_INT 25
5436: PUSH
5437: LD_INT 2
5439: PUSH
5440: EMPTY
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 25
5446: PUSH
5447: LD_INT 3
5449: PUSH
5450: EMPTY
5451: LIST
5452: LIST
5453: PUSH
5454: LD_INT 25
5456: PUSH
5457: LD_INT 4
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 25
5466: PUSH
5467: LD_INT 8
5469: PUSH
5470: EMPTY
5471: LIST
5472: LIST
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: CALL_OW 69
5490: PUSH
5491: LD_INT 16
5493: PUSH
5494: LD_INT 19
5496: PUSH
5497: LD_INT 22
5499: PUSH
5500: LD_INT 22
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: PUSH
5509: LD_OWVAR 67
5513: ARRAY
5514: LESS
5515: OR
5516: IFFALSE 6189
5518: GO 5520
5520: DISABLE
5521: LD_INT 0
5523: PPUSH
5524: PPUSH
5525: PPUSH
5526: PPUSH
5527: PPUSH
5528: PPUSH
// begin MC_Kill ( 1 ) ;
5529: LD_INT 1
5531: PPUSH
5532: CALL 58441 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5536: LD_ADDR_VAR 0 2
5540: PUSH
5541: LD_INT 22
5543: PUSH
5544: LD_INT 2
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: PUSH
5551: LD_INT 2
5553: PUSH
5554: LD_INT 25
5556: PUSH
5557: LD_INT 1
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 25
5566: PUSH
5567: LD_INT 2
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 25
5576: PUSH
5577: LD_INT 3
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 25
5586: PUSH
5587: LD_INT 4
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: LD_INT 25
5596: PUSH
5597: LD_INT 8
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PPUSH
5616: CALL_OW 69
5620: ST_TO_ADDR
// for i in tmp do
5621: LD_ADDR_VAR 0 5
5625: PUSH
5626: LD_VAR 0 2
5630: PUSH
5631: FOR_IN
5632: IFFALSE 5648
// SetTag ( i , 10 ) ;
5634: LD_VAR 0 5
5638: PPUSH
5639: LD_INT 10
5641: PPUSH
5642: CALL_OW 109
5646: GO 5631
5648: POP
5649: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5650: LD_ADDR_VAR 0 3
5654: PUSH
5655: LD_INT 22
5657: PUSH
5658: LD_INT 2
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 21
5667: PUSH
5668: LD_INT 1
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: PUSH
5684: LD_VAR 0 2
5688: DIFF
5689: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5690: LD_ADDR_VAR 0 1
5694: PUSH
5695: LD_INT 22
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PUSH
5705: LD_INT 21
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 24
5717: PUSH
5718: LD_INT 300
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL_OW 69
5734: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5735: LD_ADDR_VAR 0 4
5739: PUSH
5740: LD_VAR 0 1
5744: PPUSH
5745: LD_INT 33
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 58
5757: PUSH
5758: EMPTY
5759: LIST
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PPUSH
5765: CALL_OW 72
5769: ST_TO_ADDR
// for i in tmp do
5770: LD_ADDR_VAR 0 5
5774: PUSH
5775: LD_VAR 0 2
5779: PUSH
5780: FOR_IN
5781: IFFALSE 5965
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5783: LD_VAR 0 5
5787: PUSH
5788: LD_INT 55
5790: PUSH
5791: EMPTY
5792: LIST
5793: PPUSH
5794: CALL_OW 69
5798: IN
5799: IFFALSE 5818
// begin AddComMoveXY ( i , 209 , 132 ) ;
5801: LD_VAR 0 5
5805: PPUSH
5806: LD_INT 209
5808: PPUSH
5809: LD_INT 132
5811: PPUSH
5812: CALL_OW 171
// continue ;
5816: GO 5780
// end ; if IsInUnit ( i ) then
5818: LD_VAR 0 5
5822: PPUSH
5823: CALL_OW 310
5827: IFFALSE 5845
// begin ComExitBuilding ( i ) ;
5829: LD_VAR 0 5
5833: PPUSH
5834: CALL_OW 122
// wait ( 3 ) ;
5838: LD_INT 3
5840: PPUSH
5841: CALL_OW 67
// end ; if tmp_empty then
5845: LD_VAR 0 4
5849: IFFALSE 5948
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5851: LD_VAR 0 5
5855: PPUSH
5856: LD_VAR 0 4
5860: PPUSH
5861: LD_VAR 0 5
5865: PPUSH
5866: CALL_OW 74
5870: PPUSH
5871: CALL_OW 296
5875: PUSH
5876: LD_INT 25
5878: LESS
5879: IFFALSE 5948
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5881: LD_ADDR_VAR 0 6
5885: PUSH
5886: LD_VAR 0 4
5890: PPUSH
5891: LD_VAR 0 5
5895: PPUSH
5896: CALL_OW 74
5900: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5901: LD_VAR 0 5
5905: PPUSH
5906: LD_VAR 0 6
5910: PPUSH
5911: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5915: LD_VAR 0 5
5919: PPUSH
5920: LD_INT 209
5922: PPUSH
5923: LD_INT 132
5925: PPUSH
5926: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5930: LD_ADDR_VAR 0 4
5934: PUSH
5935: LD_VAR 0 4
5939: PUSH
5940: LD_VAR 0 6
5944: DIFF
5945: ST_TO_ADDR
// continue ;
5946: GO 5780
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5948: LD_VAR 0 5
5952: PPUSH
5953: LD_INT 201
5955: PPUSH
5956: LD_INT 132
5958: PPUSH
5959: CALL_OW 171
// end ;
5963: GO 5780
5965: POP
5966: POP
// for i in tmp_ape do
5967: LD_ADDR_VAR 0 5
5971: PUSH
5972: LD_VAR 0 3
5976: PUSH
5977: FOR_IN
5978: IFFALSE 6017
// begin if IsInUnit ( i ) then
5980: LD_VAR 0 5
5984: PPUSH
5985: CALL_OW 310
5989: IFFALSE 6000
// ComExitBuilding ( i ) ;
5991: LD_VAR 0 5
5995: PPUSH
5996: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6000: LD_VAR 0 5
6004: PPUSH
6005: LD_INT 201
6007: PPUSH
6008: LD_INT 132
6010: PPUSH
6011: CALL_OW 171
// end ;
6015: GO 5977
6017: POP
6018: POP
// repeat wait ( 0 0$1 ) ;
6019: LD_INT 35
6021: PPUSH
6022: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6026: LD_ADDR_VAR 0 5
6030: PUSH
6031: LD_VAR 0 2
6035: PUSH
6036: LD_VAR 0 3
6040: UNION
6041: PUSH
6042: LD_VAR 0 1
6046: UNION
6047: PUSH
6048: FOR_IN
6049: IFFALSE 6080
// if not HasTask ( i ) then
6051: LD_VAR 0 5
6055: PPUSH
6056: CALL_OW 314
6060: NOT
6061: IFFALSE 6078
// ComMoveXY ( i , 201 , 132 ) ;
6063: LD_VAR 0 5
6067: PPUSH
6068: LD_INT 201
6070: PPUSH
6071: LD_INT 132
6073: PPUSH
6074: CALL_OW 111
6078: GO 6048
6080: POP
6081: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6082: LD_INT 21
6084: PPUSH
6085: LD_INT 22
6087: PUSH
6088: LD_INT 2
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PPUSH
6095: CALL_OW 70
6099: IFFALSE 6140
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6101: LD_ADDR_VAR 0 5
6105: PUSH
6106: LD_INT 21
6108: PPUSH
6109: LD_INT 22
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PPUSH
6119: CALL_OW 70
6123: PUSH
6124: FOR_IN
6125: IFFALSE 6138
// RemoveUnit ( i ) ;
6127: LD_VAR 0 5
6131: PPUSH
6132: CALL_OW 64
6136: GO 6124
6138: POP
6139: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6140: LD_INT 22
6142: PUSH
6143: LD_INT 2
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: LD_INT 2
6152: PUSH
6153: LD_INT 21
6155: PUSH
6156: LD_INT 1
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 21
6165: PUSH
6166: LD_INT 2
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 69
6186: NOT
6187: IFFALSE 6019
// end ;
6189: PPOPN 6
6191: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6192: LD_EXP 9
6196: PUSH
6197: LD_INT 92
6199: PPUSH
6200: LD_INT 40
6202: PPUSH
6203: CALL_OW 428
6207: PPUSH
6208: CALL_OW 266
6212: PUSH
6213: LD_INT 30
6215: EQUAL
6216: AND
6217: IFFALSE 6413
6219: GO 6221
6221: DISABLE
6222: LD_INT 0
6224: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_EXP 61
6234: PUSH
6235: LD_INT 1
6237: ARRAY
6238: PPUSH
6239: LD_INT 25
6241: PUSH
6242: LD_INT 4
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: PPUSH
6249: CALL_OW 72
6253: ST_TO_ADDR
// if not sci then
6254: LD_VAR 0 1
6258: NOT
6259: IFFALSE 6263
// exit ;
6261: GO 6413
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6263: LD_ADDR_EXP 61
6267: PUSH
6268: LD_EXP 61
6272: PPUSH
6273: LD_INT 1
6275: PPUSH
6276: LD_EXP 61
6280: PUSH
6281: LD_INT 1
6283: ARRAY
6284: PUSH
6285: LD_VAR 0 1
6289: PUSH
6290: LD_INT 1
6292: ARRAY
6293: DIFF
6294: PPUSH
6295: CALL_OW 1
6299: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6300: LD_VAR 0 1
6304: PUSH
6305: LD_INT 1
6307: ARRAY
6308: PPUSH
6309: CALL_OW 310
6313: IFFALSE 6328
// ComExitBuilding ( sci [ 1 ] ) ;
6315: LD_VAR 0 1
6319: PUSH
6320: LD_INT 1
6322: ARRAY
6323: PPUSH
6324: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6328: LD_INT 2
6330: PPUSH
6331: LD_INT 105
6333: PPUSH
6334: LD_INT 14
6336: PPUSH
6337: LD_INT 20
6339: PPUSH
6340: CALL 22245 0 4
6344: PUSH
6345: LD_INT 4
6347: ARRAY
6348: PUSH
6349: LD_INT 10
6351: LESS
6352: IFFALSE 6375
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6354: LD_VAR 0 1
6358: PUSH
6359: LD_INT 1
6361: ARRAY
6362: PPUSH
6363: LD_INT 105
6365: PPUSH
6366: LD_INT 14
6368: PPUSH
6369: CALL_OW 171
6373: GO 6394
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6375: LD_VAR 0 1
6379: PUSH
6380: LD_INT 1
6382: ARRAY
6383: PPUSH
6384: LD_INT 118
6386: PPUSH
6387: LD_INT 77
6389: PPUSH
6390: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6394: LD_VAR 0 1
6398: PUSH
6399: LD_INT 1
6401: ARRAY
6402: PPUSH
6403: LD_INT 92
6405: PPUSH
6406: LD_INT 40
6408: PPUSH
6409: CALL_OW 218
// end ;
6413: PPOPN 1
6415: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6416: LD_INT 1
6418: PPUSH
6419: CALL_OW 302
6423: PUSH
6424: LD_EXP 9
6428: AND
6429: IFFALSE 7217
6431: GO 6433
6433: DISABLE
6434: LD_INT 0
6436: PPUSH
6437: PPUSH
6438: PPUSH
6439: PPUSH
6440: PPUSH
6441: PPUSH
6442: PPUSH
6443: PPUSH
// begin enable ;
6444: ENABLE
// base := 1 ;
6445: LD_ADDR_VAR 0 3
6449: PUSH
6450: LD_INT 1
6452: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6453: LD_ADDR_VAR 0 5
6457: PUSH
6458: LD_INT 0
6460: PUSH
6461: LD_INT 0
6463: PUSH
6464: LD_INT 0
6466: PUSH
6467: LD_INT 0
6469: PUSH
6470: LD_INT 0
6472: PUSH
6473: LD_INT 0
6475: PUSH
6476: LD_INT 0
6478: PUSH
6479: LD_INT 0
6481: PUSH
6482: LD_INT 1
6484: PUSH
6485: LD_INT 0
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6500: LD_ADDR_VAR 0 4
6504: PUSH
6505: LD_INT 13
6507: PUSH
6508: LD_INT 1
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 26
6516: PUSH
6517: EMPTY
6518: LIST
6519: LIST
6520: LIST
6521: LIST
6522: PUSH
6523: LD_INT 13
6525: PUSH
6526: LD_INT 1
6528: PUSH
6529: LD_INT 2
6531: PUSH
6532: LD_INT 28
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: LIST
6539: LIST
6540: PUSH
6541: LD_INT 13
6543: PUSH
6544: LD_INT 1
6546: PUSH
6547: LD_INT 2
6549: PUSH
6550: LD_INT 29
6552: PUSH
6553: EMPTY
6554: LIST
6555: LIST
6556: LIST
6557: LIST
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: LIST
6563: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6564: LD_ADDR_VAR 0 1
6568: PUSH
6569: DOUBLE
6570: LD_INT 1
6572: DEC
6573: ST_TO_ADDR
6574: LD_OWVAR 67
6578: PUSH
6579: LD_OWVAR 1
6583: PUSH
6584: LD_INT 21000
6586: DIV
6587: PLUS
6588: PUSH
6589: FOR_TO
6590: IFFALSE 6663
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6592: LD_ADDR_VAR 0 4
6596: PUSH
6597: LD_VAR 0 4
6601: PPUSH
6602: LD_VAR 0 4
6606: PUSH
6607: LD_INT 1
6609: PLUS
6610: PPUSH
6611: LD_INT 13
6613: PUSH
6614: LD_INT 1
6616: PUSH
6617: LD_INT 2
6619: PUSH
6620: LD_INT 28
6622: PUSH
6623: LD_INT 29
6625: PUSH
6626: LD_INT 25
6628: PUSH
6629: LD_INT 26
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 1
6640: PPUSH
6641: LD_INT 4
6643: PPUSH
6644: CALL_OW 12
6648: ARRAY
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: PPUSH
6656: CALL_OW 2
6660: ST_TO_ADDR
6661: GO 6589
6663: POP
6664: POP
// MC_InsertProduceList ( base , tmp ) ;
6665: LD_VAR 0 3
6669: PPUSH
6670: LD_VAR 0 4
6674: PPUSH
6675: CALL 82466 0 2
// wait ( 3 3$20 ) ;
6679: LD_INT 7000
6681: PPUSH
6682: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6686: LD_ADDR_VAR 0 6
6690: PUSH
6691: LD_INT 124
6693: PUSH
6694: LD_INT 85
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: PUSH
6701: LD_INT 90
6703: PUSH
6704: LD_INT 61
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: PUSH
6711: LD_INT 69
6713: PUSH
6714: LD_INT 48
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 68
6723: PUSH
6724: LD_INT 48
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: LIST
6736: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6737: LD_ADDR_VAR 0 7
6741: PUSH
6742: LD_EXP 80
6746: PUSH
6747: LD_VAR 0 3
6751: ARRAY
6752: PUSH
6753: LD_EXP 80
6757: PUSH
6758: LD_VAR 0 3
6762: ARRAY
6763: PPUSH
6764: LD_INT 2
6766: PUSH
6767: LD_INT 34
6769: PUSH
6770: LD_INT 32
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 34
6779: PUSH
6780: LD_INT 88
6782: PUSH
6783: EMPTY
6784: LIST
6785: LIST
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: LIST
6791: PPUSH
6792: CALL_OW 72
6796: DIFF
6797: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6798: LD_INT 0
6800: PPUSH
6801: LD_INT 1
6803: PPUSH
6804: CALL_OW 12
6808: IFFALSE 6958
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6810: LD_ADDR_VAR 0 1
6814: PUSH
6815: DOUBLE
6816: LD_INT 1
6818: DEC
6819: ST_TO_ADDR
6820: LD_INT 3
6822: PUSH
6823: LD_INT 4
6825: PUSH
6826: LD_INT 5
6828: PUSH
6829: LD_INT 6
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PUSH
6838: LD_OWVAR 67
6842: ARRAY
6843: PUSH
6844: FOR_TO
6845: IFFALSE 6954
// begin uc_side := 2 ;
6847: LD_ADDR_OWVAR 20
6851: PUSH
6852: LD_INT 2
6854: ST_TO_ADDR
// uc_nation := 2 ;
6855: LD_ADDR_OWVAR 21
6859: PUSH
6860: LD_INT 2
6862: ST_TO_ADDR
// InitHc ;
6863: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6867: LD_INT 0
6869: PPUSH
6870: LD_INT 15
6872: PUSH
6873: LD_INT 17
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 1
6882: PPUSH
6883: LD_INT 2
6885: PPUSH
6886: CALL_OW 12
6890: ARRAY
6891: PPUSH
6892: LD_INT 8
6894: PPUSH
6895: CALL_OW 380
// un := CreateHuman ;
6899: LD_ADDR_VAR 0 2
6903: PUSH
6904: CALL_OW 44
6908: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6909: LD_VAR 0 2
6913: PPUSH
6914: LD_INT 4
6916: PPUSH
6917: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6921: LD_VAR 0 2
6925: PPUSH
6926: LD_INT 23
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 49
// attackers := attackers union un ;
6936: LD_ADDR_VAR 0 7
6940: PUSH
6941: LD_VAR 0 7
6945: PUSH
6946: LD_VAR 0 2
6950: UNION
6951: ST_TO_ADDR
// end ;
6952: GO 6844
6954: POP
6955: POP
// end else
6956: GO 7116
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6958: LD_ADDR_VAR 0 1
6962: PUSH
6963: DOUBLE
6964: LD_INT 1
6966: DEC
6967: ST_TO_ADDR
6968: LD_INT 2
6970: PUSH
6971: LD_INT 3
6973: PUSH
6974: LD_INT 4
6976: PUSH
6977: LD_INT 5
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: LIST
6985: PUSH
6986: LD_OWVAR 67
6990: ARRAY
6991: PUSH
6992: FOR_TO
6993: IFFALSE 7114
// begin uc_side := 2 ;
6995: LD_ADDR_OWVAR 20
6999: PUSH
7000: LD_INT 2
7002: ST_TO_ADDR
// uc_nation := 2 ;
7003: LD_ADDR_OWVAR 21
7007: PUSH
7008: LD_INT 2
7010: ST_TO_ADDR
// InitHc ;
7011: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7015: LD_INT 14
7017: PPUSH
7018: LD_INT 3
7020: PPUSH
7021: LD_INT 5
7023: PPUSH
7024: LD_INT 29
7026: PUSH
7027: LD_INT 29
7029: PUSH
7030: LD_INT 26
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PUSH
7038: LD_VAR 0 1
7042: PUSH
7043: LD_INT 3
7045: MOD
7046: PUSH
7047: LD_INT 1
7049: PLUS
7050: ARRAY
7051: PPUSH
7052: LD_INT 100
7054: PPUSH
7055: CALL 20859 0 5
// un := CreateVehicle ;
7059: LD_ADDR_VAR 0 2
7063: PUSH
7064: CALL_OW 45
7068: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7069: LD_VAR 0 2
7073: PPUSH
7074: LD_INT 4
7076: PPUSH
7077: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7081: LD_VAR 0 2
7085: PPUSH
7086: LD_INT 23
7088: PPUSH
7089: LD_INT 0
7091: PPUSH
7092: CALL_OW 49
// attackers := attackers union un ;
7096: LD_ADDR_VAR 0 7
7100: PUSH
7101: LD_VAR 0 7
7105: PUSH
7106: LD_VAR 0 2
7110: UNION
7111: ST_TO_ADDR
// end ;
7112: GO 6992
7114: POP
7115: POP
// end ; if not attackers then
7116: LD_VAR 0 7
7120: NOT
7121: IFFALSE 7125
// exit ;
7123: GO 7217
// ar_attackers := attackers ;
7125: LD_ADDR_EXP 11
7129: PUSH
7130: LD_VAR 0 7
7134: ST_TO_ADDR
// p := 0 ;
7135: LD_ADDR_VAR 0 8
7139: PUSH
7140: LD_INT 0
7142: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7143: LD_INT 35
7145: PPUSH
7146: CALL_OW 67
// p := Inc ( p ) ;
7150: LD_ADDR_VAR 0 8
7154: PUSH
7155: LD_VAR 0 8
7159: PPUSH
7160: CALL 55082 0 1
7164: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7165: LD_VAR 0 7
7169: PPUSH
7170: LD_INT 60
7172: PUSH
7173: EMPTY
7174: LIST
7175: PPUSH
7176: CALL_OW 72
7180: NOT
7181: PUSH
7182: LD_VAR 0 8
7186: PUSH
7187: LD_INT 30
7189: GREATER
7190: OR
7191: IFFALSE 7143
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7193: LD_VAR 0 3
7197: PPUSH
7198: LD_VAR 0 7
7202: PPUSH
7203: LD_VAR 0 6
7207: PPUSH
7208: LD_VAR 0 5
7212: PPUSH
7213: CALL 82651 0 4
// end ;
7217: PPOPN 8
7219: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7220: LD_INT 1
7222: PPUSH
7223: CALL_OW 302
7227: PUSH
7228: LD_EXP 9
7232: AND
7233: PUSH
7234: LD_EXP 51
7238: PPUSH
7239: LD_INT 22
7241: PPUSH
7242: CALL_OW 308
7246: AND
7247: IFFALSE 7735
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
7255: PPUSH
7256: PPUSH
7257: PPUSH
7258: PPUSH
7259: PPUSH
7260: PPUSH
7261: PPUSH
// begin base := 1 ;
7262: LD_ADDR_VAR 0 2
7266: PUSH
7267: LD_INT 1
7269: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7270: LD_ADDR_VAR 0 4
7274: PUSH
7275: LD_INT 0
7277: PUSH
7278: LD_INT 0
7280: PUSH
7281: LD_INT 0
7283: PUSH
7284: LD_INT 0
7286: PUSH
7287: LD_INT 0
7289: PUSH
7290: LD_INT 0
7292: PUSH
7293: LD_INT 0
7295: PUSH
7296: LD_INT 0
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: LD_INT 0
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: LIST
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: LIST
7315: LIST
7316: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7317: LD_ADDR_VAR 0 3
7321: PUSH
7322: LD_INT 13
7324: PUSH
7325: LD_INT 1
7327: PUSH
7328: LD_INT 2
7330: PUSH
7331: LD_INT 28
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 13
7342: PUSH
7343: LD_INT 1
7345: PUSH
7346: LD_INT 2
7348: PUSH
7349: LD_INT 27
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 13
7360: PUSH
7361: LD_INT 1
7363: PUSH
7364: LD_INT 2
7366: PUSH
7367: LD_INT 25
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 11
7378: PUSH
7379: LD_INT 2
7381: PUSH
7382: LD_INT 2
7384: PUSH
7385: LD_INT 24
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 11
7396: PUSH
7397: LD_INT 2
7399: PUSH
7400: LD_INT 2
7402: PUSH
7403: LD_INT 24
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: LIST
7416: LIST
7417: LIST
7418: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7419: LD_VAR 0 2
7423: PPUSH
7424: LD_VAR 0 3
7428: PPUSH
7429: CALL 82466 0 2
// wait ( 4 4$20 ) ;
7433: LD_INT 9100
7435: PPUSH
7436: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7440: LD_ADDR_VAR 0 5
7444: PUSH
7445: LD_INT 119
7447: PUSH
7448: LD_INT 9
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PUSH
7455: EMPTY
7456: LIST
7457: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7458: LD_ADDR_VAR 0 6
7462: PUSH
7463: LD_EXP 80
7467: PUSH
7468: LD_VAR 0 2
7472: ARRAY
7473: PUSH
7474: LD_EXP 80
7478: PUSH
7479: LD_VAR 0 2
7483: ARRAY
7484: PPUSH
7485: LD_INT 2
7487: PUSH
7488: LD_INT 34
7490: PUSH
7491: LD_INT 32
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PUSH
7498: LD_INT 34
7500: PUSH
7501: LD_INT 88
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: LIST
7512: PPUSH
7513: CALL_OW 72
7517: DIFF
7518: ST_TO_ADDR
// uc_side := 2 ;
7519: LD_ADDR_OWVAR 20
7523: PUSH
7524: LD_INT 2
7526: ST_TO_ADDR
// uc_nation := 2 ;
7527: LD_ADDR_OWVAR 21
7531: PUSH
7532: LD_INT 2
7534: ST_TO_ADDR
// InitHc ;
7535: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7539: LD_ADDR_VAR 0 1
7543: PUSH
7544: DOUBLE
7545: LD_INT 1
7547: DEC
7548: ST_TO_ADDR
7549: LD_INT 4
7551: PUSH
7552: LD_INT 5
7554: PUSH
7555: LD_INT 6
7557: PUSH
7558: LD_INT 6
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: PUSH
7567: LD_OWVAR 67
7571: ARRAY
7572: PUSH
7573: FOR_TO
7574: IFFALSE 7651
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7576: LD_INT 0
7578: PPUSH
7579: LD_INT 15
7581: PUSH
7582: LD_INT 17
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 1
7591: PPUSH
7592: LD_INT 2
7594: PPUSH
7595: CALL_OW 12
7599: ARRAY
7600: PPUSH
7601: LD_INT 8
7603: PPUSH
7604: CALL_OW 380
// un := CreateHuman ;
7608: LD_ADDR_VAR 0 7
7612: PUSH
7613: CALL_OW 44
7617: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7618: LD_VAR 0 7
7622: PPUSH
7623: LD_INT 23
7625: PPUSH
7626: LD_INT 0
7628: PPUSH
7629: CALL_OW 49
// attackers := attackers union un ;
7633: LD_ADDR_VAR 0 6
7637: PUSH
7638: LD_VAR 0 6
7642: PUSH
7643: LD_VAR 0 7
7647: UNION
7648: ST_TO_ADDR
// end ;
7649: GO 7573
7651: POP
7652: POP
// p := 0 ;
7653: LD_ADDR_VAR 0 8
7657: PUSH
7658: LD_INT 0
7660: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7661: LD_INT 35
7663: PPUSH
7664: CALL_OW 67
// p := Inc ( p ) ;
7668: LD_ADDR_VAR 0 8
7672: PUSH
7673: LD_VAR 0 8
7677: PPUSH
7678: CALL 55082 0 1
7682: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7683: LD_VAR 0 6
7687: PPUSH
7688: LD_INT 60
7690: PUSH
7691: EMPTY
7692: LIST
7693: PPUSH
7694: CALL_OW 72
7698: NOT
7699: PUSH
7700: LD_VAR 0 8
7704: PUSH
7705: LD_INT 30
7707: GREATER
7708: OR
7709: IFFALSE 7661
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7711: LD_VAR 0 2
7715: PPUSH
7716: LD_VAR 0 6
7720: PPUSH
7721: LD_VAR 0 5
7725: PPUSH
7726: LD_VAR 0 4
7730: PPUSH
7731: CALL 82651 0 4
// end ; end_of_file
7735: PPOPN 8
7737: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7738: LD_INT 0
7740: PPUSH
7741: PPUSH
7742: PPUSH
7743: PPUSH
7744: PPUSH
7745: PPUSH
// uc_side := 1 ;
7746: LD_ADDR_OWVAR 20
7750: PUSH
7751: LD_INT 1
7753: ST_TO_ADDR
// uc_nation := 1 ;
7754: LD_ADDR_OWVAR 21
7758: PUSH
7759: LD_INT 1
7761: ST_TO_ADDR
// InitHc ;
7762: CALL_OW 19
// InitVc ;
7766: CALL_OW 20
// tmp := [ ] ;
7770: LD_ADDR_VAR 0 3
7774: PUSH
7775: EMPTY
7776: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7777: LD_ADDR_VAR 0 2
7781: PUSH
7782: DOUBLE
7783: LD_INT 1
7785: DEC
7786: ST_TO_ADDR
7787: LD_INT 6
7789: PUSH
7790: LD_INT 8
7792: PUSH
7793: LD_INT 10
7795: PUSH
7796: LD_INT 10
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: LIST
7803: LIST
7804: PUSH
7805: LD_OWVAR 67
7809: ARRAY
7810: PUSH
7811: FOR_TO
7812: IFFALSE 8102
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7814: LD_ADDR_VAR 0 5
7818: PUSH
7819: LD_INT 2
7821: PUSH
7822: LD_INT 4
7824: PUSH
7825: LD_INT 5
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PUSH
7833: LD_INT 1
7835: PPUSH
7836: LD_INT 3
7838: PPUSH
7839: CALL_OW 12
7843: ARRAY
7844: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7845: LD_VAR 0 5
7849: PUSH
7850: LD_INT 2
7852: DOUBLE
7853: EQUAL
7854: IFTRUE 7858
7856: GO 7892
7858: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7859: LD_ADDR_VAR 0 6
7863: PUSH
7864: LD_INT 9
7866: PUSH
7867: LD_INT 5
7869: PUSH
7870: LD_INT 7
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 1
7880: PPUSH
7881: LD_INT 3
7883: PPUSH
7884: CALL_OW 12
7888: ARRAY
7889: ST_TO_ADDR
7890: GO 7981
7892: LD_INT 4
7894: DOUBLE
7895: EQUAL
7896: IFTRUE 7900
7898: GO 7938
7900: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7901: LD_ADDR_VAR 0 6
7905: PUSH
7906: LD_INT 9
7908: PUSH
7909: LD_INT 6
7911: PUSH
7912: LD_INT 6
7914: PUSH
7915: LD_INT 7
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: LIST
7922: LIST
7923: PUSH
7924: LD_INT 1
7926: PPUSH
7927: LD_INT 4
7929: PPUSH
7930: CALL_OW 12
7934: ARRAY
7935: ST_TO_ADDR
7936: GO 7981
7938: LD_INT 5
7940: DOUBLE
7941: EQUAL
7942: IFTRUE 7946
7944: GO 7980
7946: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7947: LD_ADDR_VAR 0 6
7951: PUSH
7952: LD_INT 9
7954: PUSH
7955: LD_INT 6
7957: PUSH
7958: LD_INT 7
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: PUSH
7966: LD_INT 1
7968: PPUSH
7969: LD_INT 3
7971: PPUSH
7972: CALL_OW 12
7976: ARRAY
7977: ST_TO_ADDR
7978: GO 7981
7980: POP
// uc_side := 1 ;
7981: LD_ADDR_OWVAR 20
7985: PUSH
7986: LD_INT 1
7988: ST_TO_ADDR
// uc_nation := 1 ;
7989: LD_ADDR_OWVAR 21
7993: PUSH
7994: LD_INT 1
7996: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7997: LD_VAR 0 5
8001: PPUSH
8002: LD_INT 1
8004: PUSH
8005: LD_INT 3
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: LD_INT 1
8014: PPUSH
8015: LD_INT 2
8017: PPUSH
8018: CALL_OW 12
8022: ARRAY
8023: PPUSH
8024: LD_INT 3
8026: PPUSH
8027: LD_VAR 0 6
8031: PPUSH
8032: LD_INT 70
8034: PPUSH
8035: LD_INT 90
8037: PPUSH
8038: CALL_OW 12
8042: PPUSH
8043: CALL 20859 0 5
// veh := CreateVehicle ;
8047: LD_ADDR_VAR 0 4
8051: PUSH
8052: CALL_OW 45
8056: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8057: LD_VAR 0 4
8061: PPUSH
8062: LD_INT 2
8064: PPUSH
8065: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8069: LD_VAR 0 4
8073: PPUSH
8074: LD_INT 17
8076: PPUSH
8077: LD_INT 0
8079: PPUSH
8080: CALL_OW 49
// tmp := tmp ^ veh ;
8084: LD_ADDR_VAR 0 3
8088: PUSH
8089: LD_VAR 0 3
8093: PUSH
8094: LD_VAR 0 4
8098: ADD
8099: ST_TO_ADDR
// end ;
8100: GO 7811
8102: POP
8103: POP
// if not tmp then
8104: LD_VAR 0 3
8108: NOT
8109: IFFALSE 8113
// exit ;
8111: GO 8222
// if not first_powell_attack then
8113: LD_EXP 12
8117: NOT
8118: IFFALSE 8128
// first_powell_attack := true ;
8120: LD_ADDR_EXP 12
8124: PUSH
8125: LD_INT 1
8127: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
8128: LD_INT 70
8130: PPUSH
8131: CALL_OW 67
// for i in tmp do
8135: LD_ADDR_VAR 0 2
8139: PUSH
8140: LD_VAR 0 3
8144: PUSH
8145: FOR_IN
8146: IFFALSE 8213
// if IsOk ( i ) then
8148: LD_VAR 0 2
8152: PPUSH
8153: CALL_OW 302
8157: IFFALSE 8195
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
8159: LD_VAR 0 2
8163: PPUSH
8164: LD_INT 81
8166: PUSH
8167: LD_INT 1
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: PPUSH
8179: LD_VAR 0 2
8183: PPUSH
8184: CALL_OW 74
8188: PPUSH
8189: CALL_OW 115
8193: GO 8211
// tmp := tmp diff i ;
8195: LD_ADDR_VAR 0 3
8199: PUSH
8200: LD_VAR 0 3
8204: PUSH
8205: LD_VAR 0 2
8209: DIFF
8210: ST_TO_ADDR
8211: GO 8145
8213: POP
8214: POP
// until not tmp ;
8215: LD_VAR 0 3
8219: NOT
8220: IFFALSE 8128
// end ; end_of_file
8222: LD_VAR 0 1
8226: RET
// export function Action ; var tmp , i , un ; begin
8227: LD_INT 0
8229: PPUSH
8230: PPUSH
8231: PPUSH
8232: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
8233: LD_INT 68
8235: PPUSH
8236: LD_INT 39
8238: PPUSH
8239: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
8243: LD_ADDR_VAR 0 2
8247: PUSH
8248: LD_INT 22
8250: PUSH
8251: LD_INT 7
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PPUSH
8258: CALL_OW 69
8262: ST_TO_ADDR
// InGameOn ;
8263: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
8267: LD_VAR 0 2
8271: PPUSH
8272: LD_INT 71
8274: PPUSH
8275: LD_INT 49
8277: PPUSH
8278: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
8289: LD_INT 7
8291: PPUSH
8292: LD_INT 71
8294: PPUSH
8295: LD_INT 51
8297: PPUSH
8298: CALL_OW 293
8302: IFFALSE 8282
// DialogueOn ;
8304: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
8308: LD_EXP 16
8312: PPUSH
8313: LD_STRING D1-JMM-1
8315: PPUSH
8316: CALL_OW 88
// if Joan then
8320: LD_EXP 31
8324: IFFALSE 8338
// Say ( Joan , D1-Joan-1 ) ;
8326: LD_EXP 31
8330: PPUSH
8331: LD_STRING D1-Joan-1
8333: PPUSH
8334: CALL_OW 88
// if Lisa then
8338: LD_EXP 18
8342: IFFALSE 8356
// Say ( Lisa , D1-Lisa-1 ) ;
8344: LD_EXP 18
8348: PPUSH
8349: LD_STRING D1-Lisa-1
8351: PPUSH
8352: CALL_OW 88
// if Joan or Lisa then
8356: LD_EXP 31
8360: PUSH
8361: LD_EXP 18
8365: OR
8366: IFFALSE 8380
// Say ( JMM , D1-JMM-2 ) ;
8368: LD_EXP 16
8372: PPUSH
8373: LD_STRING D1-JMM-2
8375: PPUSH
8376: CALL_OW 88
// DialogueOff ;
8380: CALL_OW 7
// InGameOff ;
8384: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
8388: LD_INT 71
8390: PPUSH
8391: LD_INT 50
8393: PPUSH
8394: LD_INT 7
8396: PPUSH
8397: LD_INT 30
8399: NEG
8400: PPUSH
8401: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
8405: LD_INT 71
8407: PPUSH
8408: LD_INT 50
8410: PPUSH
8411: LD_INT 7
8413: PPUSH
8414: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
8418: LD_STRING M1
8420: PPUSH
8421: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
8425: LD_INT 35
8427: PPUSH
8428: CALL_OW 67
// until freedom or tick > 1 1$00 ;
8432: LD_EXP 3
8436: PUSH
8437: LD_OWVAR 1
8441: PUSH
8442: LD_INT 2100
8444: GREATER
8445: OR
8446: IFFALSE 8425
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
8448: LD_INT 350
8450: PPUSH
8451: LD_INT 700
8453: PPUSH
8454: CALL_OW 12
8458: PPUSH
8459: CALL_OW 67
// PrepareGossudarov ;
8463: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
8467: LD_INT 35
8469: PPUSH
8470: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
8474: LD_INT 22
8476: PUSH
8477: LD_INT 6
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: LD_INT 3
8486: PUSH
8487: LD_INT 24
8489: PUSH
8490: LD_INT 1000
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: PUSH
8510: LD_INT 7
8512: PPUSH
8513: LD_EXP 34
8517: PPUSH
8518: CALL_OW 292
8522: OR
8523: IFFALSE 8467
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_INT 22
8532: PUSH
8533: LD_INT 6
8535: PUSH
8536: EMPTY
8537: LIST
8538: LIST
8539: PPUSH
8540: CALL_OW 69
8544: ST_TO_ADDR
// for i in tmp do
8545: LD_ADDR_VAR 0 3
8549: PUSH
8550: LD_VAR 0 2
8554: PUSH
8555: FOR_IN
8556: IFFALSE 8572
// SetSide ( i , 7 ) ;
8558: LD_VAR 0 3
8562: PPUSH
8563: LD_INT 7
8565: PPUSH
8566: CALL_OW 235
8570: GO 8555
8572: POP
8573: POP
// DialogueOn ;
8574: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8578: LD_EXP 16
8582: PUSH
8583: LD_EXP 17
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PPUSH
8592: LD_EXP 34
8596: PPUSH
8597: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8601: LD_EXP 34
8605: PPUSH
8606: CALL_OW 87
// if not Roth then
8610: LD_EXP 17
8614: NOT
8615: IFFALSE 8707
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8617: LD_VAR 0 2
8621: PPUSH
8622: LD_INT 3
8624: PUSH
8625: LD_INT 24
8627: PUSH
8628: LD_INT 1000
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: PPUSH
8639: CALL_OW 72
8643: IFFALSE 8657
// Say ( JMM , D2-JMM-1 ) ;
8645: LD_EXP 16
8649: PPUSH
8650: LD_STRING D2-JMM-1
8652: PPUSH
8653: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8657: LD_EXP 16
8661: PPUSH
8662: LD_STRING D2-JMM-1b
8664: PPUSH
8665: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8669: LD_EXP 34
8673: PPUSH
8674: LD_STRING D2-Gos-1
8676: PPUSH
8677: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8681: LD_EXP 16
8685: PPUSH
8686: LD_STRING D2-JMM-2
8688: PPUSH
8689: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8693: LD_EXP 34
8697: PPUSH
8698: LD_STRING D2-Gos-2
8700: PPUSH
8701: CALL_OW 88
// end else
8705: GO 8859
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8707: LD_VAR 0 2
8711: PPUSH
8712: LD_INT 3
8714: PUSH
8715: LD_INT 24
8717: PUSH
8718: LD_INT 1000
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PPUSH
8729: CALL_OW 72
8733: IFFALSE 8759
// begin Say ( Roth , D2-Roth-2 ) ;
8735: LD_EXP 17
8739: PPUSH
8740: LD_STRING D2-Roth-2
8742: PPUSH
8743: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
8747: LD_EXP 16
8751: PPUSH
8752: LD_STRING D2-JMM-1a
8754: PPUSH
8755: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
8759: LD_EXP 17
8763: PPUSH
8764: LD_STRING D2-Roth-2a
8766: PPUSH
8767: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
8771: LD_EXP 17
8775: PPUSH
8776: LD_STRING D2-Roth-2b
8778: PPUSH
8779: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
8783: LD_EXP 16
8787: PPUSH
8788: LD_STRING D2-JMM-3
8790: PPUSH
8791: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8795: LD_VAR 0 2
8799: PPUSH
8800: LD_INT 3
8802: PUSH
8803: LD_INT 24
8805: PUSH
8806: LD_INT 1000
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PPUSH
8817: CALL_OW 72
8821: IFFALSE 8859
// begin Say ( Gossudarov , D2-Gos-3 ) ;
8823: LD_EXP 34
8827: PPUSH
8828: LD_STRING D2-Gos-3
8830: PPUSH
8831: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
8835: LD_EXP 16
8839: PPUSH
8840: LD_STRING D2-JMM-4
8842: PPUSH
8843: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
8847: LD_EXP 34
8851: PPUSH
8852: LD_STRING D2-Gos-4
8854: PPUSH
8855: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8859: LD_EXP 16
8863: PPUSH
8864: LD_STRING D2-JMM-5
8866: PPUSH
8867: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8871: LD_EXP 34
8875: PPUSH
8876: LD_STRING D2-Gos-5
8878: PPUSH
8879: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8883: LD_EXP 16
8887: PPUSH
8888: LD_STRING D2-JMM-6
8890: PPUSH
8891: CALL_OW 88
// DialogueOff ;
8895: CALL_OW 7
// wait ( 0 0$2 ) ;
8899: LD_INT 70
8901: PPUSH
8902: CALL_OW 67
// if Kirilenkova then
8906: LD_EXP 35
8910: IFFALSE 8924
// Say ( Kirilenkova , D3-Kir-1 ) ;
8912: LD_EXP 35
8916: PPUSH
8917: LD_STRING D3-Kir-1
8919: PPUSH
8920: CALL_OW 88
// gossudarov_arrive := true ;
8924: LD_ADDR_EXP 4
8928: PUSH
8929: LD_INT 1
8931: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8932: LD_INT 35
8934: PPUSH
8935: CALL_OW 67
// until ru_lab_builded ;
8939: LD_EXP 5
8943: IFFALSE 8932
// DialogueOn ;
8945: CALL_OW 6
// if Kirilenkova then
8949: LD_EXP 35
8953: IFFALSE 8969
// Say ( Kirilenkova , D3a-Kir-1 ) else
8955: LD_EXP 35
8959: PPUSH
8960: LD_STRING D3a-Kir-1
8962: PPUSH
8963: CALL_OW 88
8967: GO 8991
// begin un := SciRu ;
8969: LD_ADDR_VAR 0 4
8973: PUSH
8974: CALL 14403 0 0
8978: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8979: LD_VAR 0 4
8983: PPUSH
8984: LD_STRING D3a-Sci1-1
8986: PPUSH
8987: CALL_OW 88
// end ; if Kirilenkova or un then
8991: LD_EXP 35
8995: PUSH
8996: LD_VAR 0 4
9000: OR
9001: IFFALSE 9015
// Say ( JMM , D3a-JMM-1 ) ;
9003: LD_EXP 16
9007: PPUSH
9008: LD_STRING D3a-JMM-1
9010: PPUSH
9011: CALL_OW 88
// DialogueOff ;
9015: CALL_OW 7
// end ;
9019: LD_VAR 0 1
9023: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
9024: LD_EXP 4
9028: PUSH
9029: LD_INT 22
9031: PUSH
9032: LD_INT 7
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: PUSH
9039: LD_INT 2
9041: PUSH
9042: LD_INT 25
9044: PUSH
9045: LD_INT 1
9047: PUSH
9048: EMPTY
9049: LIST
9050: LIST
9051: PUSH
9052: LD_INT 25
9054: PUSH
9055: LD_INT 2
9057: PUSH
9058: EMPTY
9059: LIST
9060: LIST
9061: PUSH
9062: LD_INT 25
9064: PUSH
9065: LD_INT 3
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: LD_INT 25
9074: PUSH
9075: LD_INT 4
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 25
9084: PUSH
9085: LD_INT 5
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 25
9094: PUSH
9095: LD_INT 8
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 25
9104: PUSH
9105: LD_INT 9
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: LIST
9117: LIST
9118: LIST
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PPUSH
9126: CALL_OW 69
9130: PUSH
9131: LD_INT 7
9133: LESS
9134: AND
9135: IFFALSE 9147
9137: GO 9139
9139: DISABLE
// YouLost ( TooMany ) ;
9140: LD_STRING TooMany
9142: PPUSH
9143: CALL_OW 104
9147: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
9148: LD_EXP 34
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_INT 7
9160: EQUAL
9161: IFFALSE 9378
9163: GO 9165
9165: DISABLE
9166: LD_INT 0
9168: PPUSH
9169: PPUSH
9170: PPUSH
// begin uc_side := 3 ;
9171: LD_ADDR_OWVAR 20
9175: PUSH
9176: LD_INT 3
9178: ST_TO_ADDR
// uc_nation := 3 ;
9179: LD_ADDR_OWVAR 21
9183: PUSH
9184: LD_INT 3
9186: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
9187: LD_INT 21
9189: PPUSH
9190: LD_INT 3
9192: PPUSH
9193: LD_INT 3
9195: PPUSH
9196: LD_INT 42
9198: PPUSH
9199: LD_INT 100
9201: PPUSH
9202: CALL 20859 0 5
// un := CreateVehicle ;
9206: LD_ADDR_VAR 0 3
9210: PUSH
9211: CALL_OW 45
9215: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
9216: LD_VAR 0 3
9220: PPUSH
9221: LD_INT 15
9223: PPUSH
9224: LD_INT 0
9226: PPUSH
9227: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
9231: LD_VAR 0 3
9235: PPUSH
9236: LD_INT 67
9238: PPUSH
9239: LD_INT 45
9241: PPUSH
9242: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
9246: LD_VAR 0 3
9250: PPUSH
9251: LD_INT 70
9253: PPUSH
9254: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
9258: LD_VAR 0 3
9262: PPUSH
9263: LD_INT 69
9265: PPUSH
9266: LD_INT 18
9268: PPUSH
9269: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
9273: LD_VAR 0 3
9277: PPUSH
9278: LD_INT 60
9280: PPUSH
9281: LD_INT 3
9283: PPUSH
9284: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9288: LD_INT 35
9290: PPUSH
9291: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
9295: LD_VAR 0 3
9299: PPUSH
9300: CALL_OW 302
9304: NOT
9305: PUSH
9306: LD_VAR 0 3
9310: PPUSH
9311: LD_INT 17
9313: PPUSH
9314: CALL_OW 308
9318: OR
9319: PUSH
9320: LD_VAR 0 3
9324: PPUSH
9325: LD_INT 60
9327: PPUSH
9328: LD_INT 3
9330: PPUSH
9331: CALL_OW 307
9335: OR
9336: IFFALSE 9288
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
9338: LD_VAR 0 3
9342: PPUSH
9343: LD_INT 17
9345: PPUSH
9346: CALL_OW 308
9350: PUSH
9351: LD_VAR 0 3
9355: PPUSH
9356: LD_INT 60
9358: PPUSH
9359: LD_INT 3
9361: PPUSH
9362: CALL_OW 307
9366: OR
9367: IFFALSE 9378
// RemoveUnit ( un ) ;
9369: LD_VAR 0 3
9373: PPUSH
9374: CALL_OW 64
// end ;
9378: PPOPN 3
9380: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
9381: LD_EXP 4
9385: IFFALSE 9627
9387: GO 9389
9389: DISABLE
9390: LD_INT 0
9392: PPUSH
9393: PPUSH
9394: PPUSH
// begin repeat wait ( 0 0$2 ) ;
9395: LD_INT 70
9397: PPUSH
9398: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
9402: LD_ADDR_VAR 0 3
9406: PUSH
9407: LD_INT 22
9409: PUSH
9410: LD_INT 7
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: PUSH
9417: LD_INT 101
9419: PUSH
9420: LD_INT 3
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: PPUSH
9431: CALL_OW 69
9435: ST_TO_ADDR
// until tmp ;
9436: LD_VAR 0 3
9440: IFFALSE 9395
// un := NearestUnitToUnit ( tmp , JMM ) ;
9442: LD_ADDR_VAR 0 2
9446: PUSH
9447: LD_VAR 0 3
9451: PPUSH
9452: LD_EXP 16
9456: PPUSH
9457: CALL_OW 74
9461: ST_TO_ADDR
// player_spotted := true ;
9462: LD_ADDR_EXP 6
9466: PUSH
9467: LD_INT 1
9469: ST_TO_ADDR
// tmp := SciRu ;
9470: LD_ADDR_VAR 0 3
9474: PUSH
9475: CALL 14403 0 0
9479: ST_TO_ADDR
// if not tmp then
9480: LD_VAR 0 3
9484: NOT
9485: IFFALSE 9497
// tmp := SolRu ;
9487: LD_ADDR_VAR 0 3
9491: PUSH
9492: CALL 14550 0 0
9496: ST_TO_ADDR
// DialogueOn ;
9497: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9501: LD_VAR 0 2
9505: PPUSH
9506: CALL_OW 250
9510: PPUSH
9511: LD_VAR 0 2
9515: PPUSH
9516: CALL_OW 251
9520: PPUSH
9521: LD_INT 7
9523: PPUSH
9524: LD_INT 8
9526: NEG
9527: PPUSH
9528: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9532: LD_VAR 0 2
9536: PPUSH
9537: CALL_OW 87
// if tmp then
9541: LD_VAR 0 3
9545: IFFALSE 9559
// Say ( tmp , D4-RSci1-1 ) ;
9547: LD_VAR 0 3
9551: PPUSH
9552: LD_STRING D4-RSci1-1
9554: PPUSH
9555: CALL_OW 88
// if Gossudarov then
9559: LD_EXP 34
9563: IFFALSE 9589
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9565: LD_EXP 34
9569: PPUSH
9570: LD_STRING D4-Gos-1
9572: PPUSH
9573: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9577: LD_EXP 16
9581: PPUSH
9582: LD_STRING D4-JMM-1
9584: PPUSH
9585: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9589: LD_VAR 0 2
9593: PPUSH
9594: CALL_OW 250
9598: PPUSH
9599: LD_VAR 0 2
9603: PPUSH
9604: CALL_OW 251
9608: PPUSH
9609: LD_INT 7
9611: PPUSH
9612: CALL_OW 331
// DialogueOff ;
9616: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9620: LD_STRING M5
9622: PPUSH
9623: CALL_OW 337
// end ;
9627: PPOPN 3
9629: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9630: LD_EXP 6
9634: IFFALSE 10227
9636: GO 9638
9638: DISABLE
9639: LD_INT 0
9641: PPUSH
9642: PPUSH
9643: PPUSH
// begin PrepareBelkov ;
9644: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9648: LD_EXP 49
9652: PPUSH
9653: LD_INT 118
9655: PPUSH
9656: LD_INT 106
9658: PPUSH
9659: CALL_OW 111
// AddComHold ( Belkov ) ;
9663: LD_EXP 49
9667: PPUSH
9668: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9672: LD_INT 35
9674: PPUSH
9675: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9679: LD_EXP 49
9683: PPUSH
9684: LD_INT 118
9686: PPUSH
9687: LD_INT 106
9689: PPUSH
9690: CALL_OW 307
9694: IFFALSE 9672
// ChangeSideFog ( 4 , 7 ) ;
9696: LD_INT 4
9698: PPUSH
9699: LD_INT 7
9701: PPUSH
9702: CALL_OW 343
// if IsOk ( Belkov ) then
9706: LD_EXP 49
9710: PPUSH
9711: CALL_OW 302
9715: IFFALSE 9799
// begin InGameOn ;
9717: CALL_OW 8
// DialogueOn ;
9721: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
9725: LD_EXP 49
9729: PPUSH
9730: LD_STRING D5-Bel-1
9732: PPUSH
9733: CALL_OW 94
// if Gossudarov then
9737: LD_EXP 34
9741: IFFALSE 9791
// begin Say ( Gossudarov , D5-Gos-1 ) ;
9743: LD_EXP 34
9747: PPUSH
9748: LD_STRING D5-Gos-1
9750: PPUSH
9751: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
9755: LD_EXP 16
9759: PPUSH
9760: LD_STRING D5-JMM-1
9762: PPUSH
9763: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
9767: LD_EXP 34
9771: PPUSH
9772: LD_STRING D5-Gos-2
9774: PPUSH
9775: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
9779: LD_EXP 16
9783: PPUSH
9784: LD_STRING D5-JMM-2
9786: PPUSH
9787: CALL_OW 88
// end ; DialogueOff ;
9791: CALL_OW 7
// InGameOff ;
9795: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
9799: LD_STRING QSaveBelkov
9801: PPUSH
9802: CALL_OW 97
9806: PUSH
9807: LD_INT 1
9809: DOUBLE
9810: EQUAL
9811: IFTRUE 9815
9813: GO 9865
9815: POP
// begin DialogueOn ;
9816: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
9820: LD_EXP 16
9824: PPUSH
9825: LD_STRING D5a-JMM-1
9827: PPUSH
9828: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
9832: LD_EXP 49
9836: PPUSH
9837: LD_STRING D5a-Bel-1
9839: PPUSH
9840: CALL_OW 94
// DialogueOff ;
9844: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
9848: LD_EXP 49
9852: PPUSH
9853: LD_INT 83
9855: PPUSH
9856: LD_INT 49
9858: PPUSH
9859: CALL_OW 111
// end ; 2 :
9863: GO 9898
9865: LD_INT 2
9867: DOUBLE
9868: EQUAL
9869: IFTRUE 9873
9871: GO 9897
9873: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9874: LD_EXP 16
9878: PPUSH
9879: LD_STRING D5a-JMM-2
9881: PPUSH
9882: CALL_OW 88
// ComHold ( Belkov ) ;
9886: LD_EXP 49
9890: PPUSH
9891: CALL_OW 140
// end ; end ;
9895: GO 9898
9897: POP
// time := 0 0$00 ;
9898: LD_ADDR_VAR 0 1
9902: PUSH
9903: LD_INT 0
9905: ST_TO_ADDR
// vehSpawned := false ;
9906: LD_ADDR_VAR 0 3
9910: PUSH
9911: LD_INT 0
9913: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9914: LD_INT 35
9916: PPUSH
9917: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9921: LD_VAR 0 1
9925: PUSH
9926: LD_INT 350
9928: PUSH
9929: LD_INT 175
9931: PUSH
9932: LD_INT 105
9934: PUSH
9935: LD_INT 70
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: LIST
9942: LIST
9943: PUSH
9944: LD_OWVAR 67
9948: ARRAY
9949: GREATEREQUAL
9950: PUSH
9951: LD_VAR 0 3
9955: NOT
9956: AND
9957: IFFALSE 10047
// begin vehSpawned := true ;
9959: LD_ADDR_VAR 0 3
9963: PUSH
9964: LD_INT 1
9966: ST_TO_ADDR
// uc_side := 3 ;
9967: LD_ADDR_OWVAR 20
9971: PUSH
9972: LD_INT 3
9974: ST_TO_ADDR
// uc_nation := 3 ;
9975: LD_ADDR_OWVAR 21
9979: PUSH
9980: LD_INT 3
9982: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9983: LD_INT 22
9985: PPUSH
9986: LD_INT 3
9988: PPUSH
9989: LD_INT 3
9991: PPUSH
9992: LD_INT 43
9994: PPUSH
9995: LD_INT 100
9997: PPUSH
9998: CALL 20859 0 5
// veh := CreateVehicle ;
10002: LD_ADDR_VAR 0 2
10006: PUSH
10007: CALL_OW 45
10011: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
10012: LD_VAR 0 2
10016: PPUSH
10017: LD_INT 130
10019: PPUSH
10020: LD_INT 131
10022: PPUSH
10023: LD_INT 0
10025: PPUSH
10026: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
10030: LD_VAR 0 2
10034: PPUSH
10035: LD_INT 100
10037: PPUSH
10038: LD_INT 82
10040: PPUSH
10041: CALL_OW 114
// end else
10045: GO 10061
// time := time + 0 0$1 ;
10047: LD_ADDR_VAR 0 1
10051: PUSH
10052: LD_VAR 0 1
10056: PUSH
10057: LD_INT 35
10059: PLUS
10060: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
10061: LD_EXP 49
10065: PPUSH
10066: CALL_OW 301
10070: PUSH
10071: LD_EXP 49
10075: PPUSH
10076: CALL_OW 255
10080: PUSH
10081: LD_INT 4
10083: EQUAL
10084: AND
10085: PUSH
10086: LD_INT 22
10088: PUSH
10089: LD_INT 7
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PPUSH
10096: CALL_OW 69
10100: PPUSH
10101: LD_EXP 49
10105: PPUSH
10106: CALL_OW 74
10110: PPUSH
10111: LD_EXP 49
10115: PPUSH
10116: CALL_OW 296
10120: PUSH
10121: LD_INT 10
10123: LESS
10124: OR
10125: IFFALSE 9914
// if IsDead ( Belkov ) then
10127: LD_EXP 49
10131: PPUSH
10132: CALL_OW 301
10136: IFFALSE 10161
// begin CenterNowOnUnits ( Belkov ) ;
10138: LD_EXP 49
10142: PPUSH
10143: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
10147: LD_EXP 16
10151: PPUSH
10152: LD_STRING D5a-JMM-2a
10154: PPUSH
10155: CALL_OW 88
// exit ;
10159: GO 10227
// end ; if See ( 7 , Belkov ) then
10161: LD_INT 7
10163: PPUSH
10164: LD_EXP 49
10168: PPUSH
10169: CALL_OW 292
10173: IFFALSE 10187
// SetSide ( Belkov , 7 ) ;
10175: LD_EXP 49
10179: PPUSH
10180: LD_INT 7
10182: PPUSH
10183: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
10187: LD_INT 35
10189: PPUSH
10190: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
10194: LD_EXP 49
10198: PPUSH
10199: LD_INT 66
10201: PPUSH
10202: LD_INT 45
10204: PPUSH
10205: CALL_OW 297
10209: PUSH
10210: LD_INT 30
10212: LESS
10213: IFFALSE 10187
// Say ( Belkov , D6-Bel-1 ) ;
10215: LD_EXP 49
10219: PPUSH
10220: LD_STRING D6-Bel-1
10222: PPUSH
10223: CALL_OW 88
// end ;
10227: PPOPN 3
10229: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
10230: LD_EXP 49
10234: PPUSH
10235: CALL_OW 302
10239: PUSH
10240: LD_EXP 49
10244: PPUSH
10245: CALL_OW 504
10249: PUSH
10250: LD_INT 2
10252: PUSH
10253: LD_INT 34
10255: PUSH
10256: LD_INT 47
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 34
10265: PUSH
10266: LD_INT 45
10268: PUSH
10269: EMPTY
10270: LIST
10271: LIST
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: PPUSH
10278: CALL_OW 69
10282: IN
10283: AND
10284: IFFALSE 10301
10286: GO 10288
10288: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
10289: LD_EXP 49
10293: PPUSH
10294: LD_STRING D7-Bel-1
10296: PPUSH
10297: CALL_OW 88
10301: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
10302: LD_INT 22
10304: PUSH
10305: LD_INT 7
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: LD_INT 101
10314: PUSH
10315: LD_INT 2
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PPUSH
10326: CALL_OW 69
10330: PUSH
10331: LD_EXP 8
10335: NOT
10336: AND
10337: PUSH
10338: LD_EXP 48
10342: PPUSH
10343: CALL_OW 305
10347: NOT
10348: AND
10349: IFFALSE 10819
10351: GO 10353
10353: DISABLE
10354: LD_INT 0
10356: PPUSH
// begin ar_base_spotted := true ;
10357: LD_ADDR_EXP 8
10361: PUSH
10362: LD_INT 1
10364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
10365: LD_ADDR_VAR 0 1
10369: PUSH
10370: LD_INT 22
10372: PUSH
10373: LD_INT 2
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 21
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: PPUSH
10394: CALL_OW 69
10398: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
10399: LD_ADDR_VAR 0 1
10403: PUSH
10404: LD_VAR 0 1
10408: PPUSH
10409: LD_EXP 16
10413: PPUSH
10414: CALL_OW 74
10418: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
10419: LD_INT 7
10421: PPUSH
10422: LD_INT 3
10424: PPUSH
10425: CALL_OW 332
// DialogueOn ;
10429: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
10433: LD_VAR 0 1
10437: PPUSH
10438: CALL_OW 250
10442: PPUSH
10443: LD_VAR 0 1
10447: PPUSH
10448: CALL_OW 251
10452: PPUSH
10453: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
10457: LD_ADDR_VAR 0 1
10461: PUSH
10462: LD_INT 22
10464: PUSH
10465: LD_INT 7
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: LD_INT 23
10474: PUSH
10475: LD_INT 1
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: LD_INT 26
10484: PUSH
10485: LD_INT 1
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: PPUSH
10497: CALL_OW 69
10501: PUSH
10502: LD_EXP 16
10506: PUSH
10507: LD_EXP 20
10511: PUSH
10512: LD_EXP 21
10516: PUSH
10517: LD_EXP 28
10521: PUSH
10522: LD_EXP 17
10526: PUSH
10527: LD_EXP 26
10531: PUSH
10532: LD_EXP 22
10536: PUSH
10537: LD_EXP 24
10541: PUSH
10542: EMPTY
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: DIFF
10552: ST_TO_ADDR
// if not tmp then
10553: LD_VAR 0 1
10557: NOT
10558: IFFALSE 10632
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10560: LD_ADDR_VAR 0 1
10564: PUSH
10565: LD_INT 22
10567: PUSH
10568: LD_INT 7
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: LD_INT 23
10577: PUSH
10578: LD_INT 1
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: LD_INT 26
10587: PUSH
10588: LD_INT 2
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: LIST
10599: PPUSH
10600: CALL_OW 69
10604: PUSH
10605: LD_EXP 31
10609: PUSH
10610: LD_EXP 18
10614: PUSH
10615: LD_EXP 29
10619: PUSH
10620: LD_EXP 30
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: LIST
10629: LIST
10630: DIFF
10631: ST_TO_ADDR
// if tmp then
10632: LD_VAR 0 1
10636: IFFALSE 10707
// case GetSex ( tmp [ 1 ] ) of sex_male :
10638: LD_VAR 0 1
10642: PUSH
10643: LD_INT 1
10645: ARRAY
10646: PPUSH
10647: CALL_OW 258
10651: PUSH
10652: LD_INT 1
10654: DOUBLE
10655: EQUAL
10656: IFTRUE 10660
10658: GO 10679
10660: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10661: LD_VAR 0 1
10665: PUSH
10666: LD_INT 1
10668: ARRAY
10669: PPUSH
10670: LD_STRING D9-Sol1-1
10672: PPUSH
10673: CALL_OW 88
10677: GO 10707
10679: LD_INT 2
10681: DOUBLE
10682: EQUAL
10683: IFTRUE 10687
10685: GO 10706
10687: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10688: LD_VAR 0 1
10692: PUSH
10693: LD_INT 1
10695: ARRAY
10696: PPUSH
10697: LD_STRING D9-FSol1-1
10699: PPUSH
10700: CALL_OW 88
10704: GO 10707
10706: POP
// if Frank then
10707: LD_EXP 28
10711: IFFALSE 10815
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10713: LD_EXP 58
10717: PPUSH
10718: CALL_OW 250
10722: PPUSH
10723: LD_EXP 58
10727: PPUSH
10728: CALL_OW 251
10732: PPUSH
10733: LD_INT 7
10735: PPUSH
10736: LD_INT 8
10738: PPUSH
10739: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
10743: LD_EXP 58
10747: PPUSH
10748: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
10752: LD_EXP 28
10756: PPUSH
10757: LD_STRING D9-Frank-1
10759: PPUSH
10760: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
10764: LD_EXP 16
10768: PPUSH
10769: LD_STRING D9-JMM-1
10771: PPUSH
10772: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
10776: LD_EXP 28
10780: PPUSH
10781: LD_STRING D9-Frank-2
10783: PPUSH
10784: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
10788: LD_EXP 58
10792: PPUSH
10793: CALL_OW 250
10797: PPUSH
10798: LD_EXP 58
10802: PPUSH
10803: CALL_OW 251
10807: PPUSH
10808: LD_INT 7
10810: PPUSH
10811: CALL_OW 331
// end ; DialogueOff ;
10815: CALL_OW 7
// end ;
10819: PPOPN 1
10821: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
10822: LD_EXP 7
10826: PUSH
10827: LD_OWVAR 1
10831: PUSH
10832: LD_INT 42000
10834: GREATEREQUAL
10835: OR
10836: IFFALSE 11870
10838: GO 10840
10840: DISABLE
10841: LD_INT 0
10843: PPUSH
10844: PPUSH
// begin selected_option := 1 ;
10845: LD_ADDR_VAR 0 2
10849: PUSH
10850: LD_INT 1
10852: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10853: LD_INT 10500
10855: PPUSH
10856: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10860: LD_INT 35
10862: PPUSH
10863: CALL_OW 67
// until not ru_attackers ;
10867: LD_EXP 54
10871: NOT
10872: IFFALSE 10860
// PrepareBurlak ;
10874: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10878: LD_INT 70
10880: PPUSH
10881: CALL_OW 67
// until not HasTask ( Burlak ) ;
10885: LD_EXP 48
10889: PPUSH
10890: CALL_OW 314
10894: NOT
10895: IFFALSE 10878
// InGameOn ;
10897: CALL_OW 8
// DialogueOn ;
10901: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10905: LD_EXP 51
10909: PPUSH
10910: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10914: LD_EXP 48
10918: PPUSH
10919: LD_STRING D10-Bur-1
10921: PPUSH
10922: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10926: LD_EXP 49
10930: PUSH
10931: LD_EXP 49
10935: PPUSH
10936: CALL_OW 255
10940: PUSH
10941: LD_INT 7
10943: EQUAL
10944: AND
10945: IFFALSE 10959
// Say ( Belkov , D10-Bel-1 ) ;
10947: LD_EXP 49
10951: PPUSH
10952: LD_STRING D10-Bel-1
10954: PPUSH
10955: CALL_OW 88
// if Gossudarov then
10959: LD_EXP 34
10963: IFFALSE 10977
// Say ( Gossudarov , D10-Gos-1 ) ;
10965: LD_EXP 34
10969: PPUSH
10970: LD_STRING D10-Gos-1
10972: PPUSH
10973: CALL_OW 88
// if Kirilenkova then
10977: LD_EXP 35
10981: IFFALSE 10995
// Say ( Kirilenkova , D10-Kir-1 ) ;
10983: LD_EXP 35
10987: PPUSH
10988: LD_STRING D10-Kir-1
10990: PPUSH
10991: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10995: CALL 14550 0 0
10999: PPUSH
11000: LD_STRING D10-RSol1-1
11002: PPUSH
11003: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
11007: LD_EXP 48
11011: PPUSH
11012: LD_STRING D10-Bur-2
11014: PPUSH
11015: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
11019: LD_EXP 16
11023: PPUSH
11024: LD_STRING D10-JMM-2
11026: PPUSH
11027: CALL_OW 88
// if Kirilenkova then
11031: LD_EXP 35
11035: IFFALSE 11051
// Say ( Kirilenkova , D10-Kir-2 ) else
11037: LD_EXP 35
11041: PPUSH
11042: LD_STRING D10-Kir-2
11044: PPUSH
11045: CALL_OW 88
11049: GO 11063
// Say ( SolRu , D10-RSol1-2 ) ;
11051: CALL 14550 0 0
11055: PPUSH
11056: LD_STRING D10-RSol1-2
11058: PPUSH
11059: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
11063: LD_EXP 16
11067: PPUSH
11068: LD_STRING D10-JMM-3
11070: PPUSH
11071: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
11075: LD_EXP 48
11079: PPUSH
11080: LD_STRING D10-Bur-3
11082: PPUSH
11083: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
11087: LD_EXP 16
11091: PPUSH
11092: LD_STRING D10-JMM-4
11094: PPUSH
11095: CALL_OW 88
// DialogueOff ;
11099: CALL_OW 7
// InGameOff ;
11103: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
11107: LD_STRING M2
11109: PPUSH
11110: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11114: LD_INT 35
11116: PPUSH
11117: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
11121: LD_INT 22
11123: PUSH
11124: LD_INT 7
11126: PUSH
11127: EMPTY
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 91
11133: PUSH
11134: LD_EXP 48
11138: PUSH
11139: LD_INT 8
11141: PUSH
11142: EMPTY
11143: LIST
11144: LIST
11145: LIST
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PPUSH
11151: CALL_OW 69
11155: IFFALSE 11114
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
11157: LD_ADDR_VAR 0 1
11161: PUSH
11162: LD_INT 22
11164: PUSH
11165: LD_INT 4
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PPUSH
11172: CALL_OW 69
11176: PUSH
11177: FOR_IN
11178: IFFALSE 11194
// SetSide ( i , 7 ) ;
11180: LD_VAR 0 1
11184: PPUSH
11185: LD_INT 7
11187: PPUSH
11188: CALL_OW 235
11192: GO 11177
11194: POP
11195: POP
// ChangeMissionObjectives ( M3 ) ;
11196: LD_STRING M3
11198: PPUSH
11199: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
11203: LD_INT 35
11205: PPUSH
11206: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
11210: LD_EXP 16
11214: PPUSH
11215: LD_EXP 48
11219: PPUSH
11220: CALL_OW 296
11224: PUSH
11225: LD_INT 8
11227: LESS
11228: IFFALSE 11203
// ComTurnUnit ( JMM , Burlak ) ;
11230: LD_EXP 16
11234: PPUSH
11235: LD_EXP 48
11239: PPUSH
11240: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
11244: LD_EXP 48
11248: PPUSH
11249: LD_EXP 16
11253: PPUSH
11254: CALL_OW 119
// wait ( 0 0$0.3 ) ;
11258: LD_INT 10
11260: PPUSH
11261: CALL_OW 67
// DialogueOn ;
11265: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
11269: LD_EXP 16
11273: PPUSH
11274: LD_STRING D11-JMM-1
11276: PPUSH
11277: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
11281: LD_EXP 48
11285: PPUSH
11286: LD_STRING D11-Bur-1
11288: PPUSH
11289: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
11293: LD_EXP 16
11297: PPUSH
11298: LD_STRING D11-JMM-2
11300: PPUSH
11301: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
11305: LD_EXP 48
11309: PPUSH
11310: LD_STRING D11-Bur-2
11312: PPUSH
11313: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
11317: LD_EXP 16
11321: PPUSH
11322: LD_STRING D11-JMM-3
11324: PPUSH
11325: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
11329: LD_EXP 48
11333: PPUSH
11334: LD_STRING D11-Bur-3
11336: PPUSH
11337: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
11341: LD_EXP 16
11345: PPUSH
11346: LD_STRING D11-JMM-4
11348: PPUSH
11349: CALL_OW 88
// if ar_base_spotted then
11353: LD_EXP 8
11357: IFFALSE 11373
// Say ( Burlak , D12-Bur-1 ) else
11359: LD_EXP 48
11363: PPUSH
11364: LD_STRING D12-Bur-1
11366: PPUSH
11367: CALL_OW 88
11371: GO 11412
// begin RevealFogArea ( 7 , area_base_arabian ) ;
11373: LD_INT 7
11375: PPUSH
11376: LD_INT 3
11378: PPUSH
11379: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
11383: LD_INT 127
11385: PPUSH
11386: LD_INT 45
11388: PPUSH
11389: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
11393: LD_EXP 48
11397: PPUSH
11398: LD_STRING D12-Bur-1a
11400: PPUSH
11401: CALL_OW 88
// dwait ( 0 0$2 ) ;
11405: LD_INT 70
11407: PPUSH
11408: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
11412: LD_EXP 48
11416: PPUSH
11417: LD_STRING D12-Bur-1b
11419: PPUSH
11420: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
11424: LD_EXP 16
11428: PPUSH
11429: LD_STRING D12-JMM-1
11431: PPUSH
11432: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
11436: LD_EXP 48
11440: PPUSH
11441: LD_STRING D12-Bur-2
11443: PPUSH
11444: CALL_OW 88
// if Roth then
11448: LD_EXP 17
11452: IFFALSE 11468
// Say ( Roth , D12-Roth-2 ) else
11454: LD_EXP 17
11458: PPUSH
11459: LD_STRING D12-Roth-2
11461: PPUSH
11462: CALL_OW 88
11466: GO 11480
// Say ( SciRu , D12-RSci1-2 ) ;
11468: CALL 14403 0 0
11472: PPUSH
11473: LD_STRING D12-RSci1-2
11475: PPUSH
11476: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
11480: LD_EXP 16
11484: PPUSH
11485: LD_STRING D12-JMM-2
11487: PPUSH
11488: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11492: LD_EXP 48
11496: PPUSH
11497: LD_STRING D12-Bur-3
11499: PPUSH
11500: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11504: LD_EXP 16
11508: PPUSH
11509: LD_STRING D12-JMM-3
11511: PPUSH
11512: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11516: LD_EXP 48
11520: PPUSH
11521: LD_STRING D12-Bur-4
11523: PPUSH
11524: CALL_OW 88
// case Query ( QBase ) of 1 :
11528: LD_STRING QBase
11530: PPUSH
11531: CALL_OW 97
11535: PUSH
11536: LD_INT 1
11538: DOUBLE
11539: EQUAL
11540: IFTRUE 11544
11542: GO 11662
11544: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11545: LD_EXP 16
11549: PPUSH
11550: LD_STRING D13a-JMM-1
11552: PPUSH
11553: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11557: LD_EXP 48
11561: PPUSH
11562: LD_STRING D13a-Bur-1
11564: PPUSH
11565: CALL_OW 88
// if Roth then
11569: LD_EXP 17
11573: IFFALSE 11589
// Say ( Roth , D13a-Roth-1 ) else
11575: LD_EXP 17
11579: PPUSH
11580: LD_STRING D13a-Roth-1
11582: PPUSH
11583: CALL_OW 88
11587: GO 11601
// Say ( SciRu , D13a-RSci1-1 ) ;
11589: CALL 14403 0 0
11593: PPUSH
11594: LD_STRING D13a-RSci1-1
11596: PPUSH
11597: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11601: LD_EXP 16
11605: PPUSH
11606: LD_STRING D13a-JMM-2
11608: PPUSH
11609: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11613: LD_STRING QBaseAgain
11615: PPUSH
11616: CALL_OW 97
11620: PUSH
11621: LD_INT 1
11623: DOUBLE
11624: EQUAL
11625: IFTRUE 11629
11627: GO 11640
11629: POP
// selected_option := 2 ; 2 :
11630: LD_ADDR_VAR 0 2
11634: PUSH
11635: LD_INT 2
11637: ST_TO_ADDR
11638: GO 11660
11640: LD_INT 2
11642: DOUBLE
11643: EQUAL
11644: IFTRUE 11648
11646: GO 11659
11648: POP
// selected_option := 3 ; end ;
11649: LD_ADDR_VAR 0 2
11653: PUSH
11654: LD_INT 3
11656: ST_TO_ADDR
11657: GO 11660
11659: POP
// end ; 2 :
11660: GO 11701
11662: LD_INT 2
11664: DOUBLE
11665: EQUAL
11666: IFTRUE 11670
11668: GO 11681
11670: POP
// selected_option := 2 ; 3 :
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_INT 2
11678: ST_TO_ADDR
11679: GO 11701
11681: LD_INT 3
11683: DOUBLE
11684: EQUAL
11685: IFTRUE 11689
11687: GO 11700
11689: POP
// selected_option := 3 ; end ;
11690: LD_ADDR_VAR 0 2
11694: PUSH
11695: LD_INT 3
11697: ST_TO_ADDR
11698: GO 11701
11700: POP
// if selected_option = 2 then
11701: LD_VAR 0 2
11705: PUSH
11706: LD_INT 2
11708: EQUAL
11709: IFFALSE 11803
// begin Say ( JMM , D13b-JMM-1 ) ;
11711: LD_EXP 16
11715: PPUSH
11716: LD_STRING D13b-JMM-1
11718: PPUSH
11719: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
11723: LD_EXP 48
11727: PPUSH
11728: LD_STRING D13b-Bur-1
11730: PPUSH
11731: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
11735: LD_EXP 16
11739: PPUSH
11740: LD_STRING D13b-JMM-2
11742: PPUSH
11743: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
11747: LD_EXP 57
11751: PPUSH
11752: LD_STRING D13b-Abd-2
11754: PPUSH
11755: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
11759: LD_EXP 16
11763: PPUSH
11764: LD_STRING D13b-JMM-3
11766: PPUSH
11767: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
11771: LD_EXP 57
11775: PPUSH
11776: LD_STRING D13b-Abd-3
11778: PPUSH
11779: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
11783: LD_EXP 16
11787: PPUSH
11788: LD_STRING D13b-JMM-4
11790: PPUSH
11791: CALL_OW 88
// ar_active_attack := true ;
11795: LD_ADDR_EXP 9
11799: PUSH
11800: LD_INT 1
11802: ST_TO_ADDR
// end ; if selected_option = 3 then
11803: LD_VAR 0 2
11807: PUSH
11808: LD_INT 3
11810: EQUAL
11811: IFFALSE 11837
// begin Say ( JMM , D13c-JMM-1 ) ;
11813: LD_EXP 16
11817: PPUSH
11818: LD_STRING D13c-JMM-1
11820: PPUSH
11821: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
11825: LD_EXP 48
11829: PPUSH
11830: LD_STRING D13c-Bur-1
11832: PPUSH
11833: CALL_OW 88
// end ; DialogueOff ;
11837: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
11841: LD_STRING M4
11843: PPUSH
11844: CALL_OW 337
// if not ar_active_attack then
11848: LD_EXP 9
11852: NOT
11853: IFFALSE 11870
// begin wait ( 6 6$00 ) ;
11855: LD_INT 12600
11857: PPUSH
11858: CALL_OW 67
// ar_active_attack := true ;
11862: LD_ADDR_EXP 9
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// end ; end ;
11870: PPOPN 2
11872: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11873: LD_EXP 48
11877: PPUSH
11878: CALL_OW 305
11882: PUSH
11883: LD_EXP 48
11887: PPUSH
11888: CALL_OW 255
11892: PUSH
11893: LD_INT 7
11895: EQUAL
11896: AND
11897: IFFALSE 12120
11899: GO 11901
11901: DISABLE
11902: LD_INT 0
11904: PPUSH
// begin wait ( 4 4$40 ) ;
11905: LD_INT 9800
11907: PPUSH
11908: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11912: LD_INT 35
11914: PPUSH
11915: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
11919: LD_EXP 54
11923: NOT
11924: PUSH
11925: LD_INT 22
11927: PUSH
11928: LD_INT 6
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: PUSH
11935: LD_INT 50
11937: PUSH
11938: EMPTY
11939: LIST
11940: PUSH
11941: EMPTY
11942: LIST
11943: LIST
11944: PPUSH
11945: CALL_OW 69
11949: NOT
11950: AND
11951: IFFALSE 11912
// PrepareGnyevko ;
11953: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11957: LD_EXP 50
11961: PPUSH
11962: LD_INT 124
11964: PPUSH
11965: LD_INT 118
11967: PPUSH
11968: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11972: LD_EXP 50
11976: PPUSH
11977: CALL_OW 200
// time := 0 0$00 ;
11981: LD_ADDR_VAR 0 1
11985: PUSH
11986: LD_INT 0
11988: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11989: LD_INT 35
11991: PPUSH
11992: CALL_OW 67
// time := time + 0 0$1 ;
11996: LD_ADDR_VAR 0 1
12000: PUSH
12001: LD_VAR 0 1
12005: PUSH
12006: LD_INT 35
12008: PLUS
12009: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
12010: LD_EXP 50
12014: PPUSH
12015: LD_INT 124
12017: PPUSH
12018: LD_INT 118
12020: PPUSH
12021: CALL_OW 307
12025: PUSH
12026: LD_VAR 0 1
12030: PUSH
12031: LD_INT 1050
12033: GREATEREQUAL
12034: OR
12035: IFFALSE 11989
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
12037: LD_EXP 50
12041: PPUSH
12042: LD_STRING DBelkov-Gny-1
12044: PPUSH
12045: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
12049: LD_EXP 48
12053: PPUSH
12054: LD_STRING DBelkov-Bur-1a
12056: PPUSH
12057: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
12061: LD_INT 35
12063: PPUSH
12064: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
12068: LD_EXP 50
12072: PPUSH
12073: LD_INT 22
12075: PUSH
12076: LD_INT 7
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PPUSH
12083: CALL_OW 69
12087: PPUSH
12088: LD_EXP 50
12092: PPUSH
12093: CALL_OW 74
12097: PPUSH
12098: CALL_OW 296
12102: PUSH
12103: LD_INT 8
12105: LESS
12106: IFFALSE 12061
// SetSide ( Gnyevko , 7 ) ;
12108: LD_EXP 50
12112: PPUSH
12113: LD_INT 7
12115: PPUSH
12116: CALL_OW 235
// end ;
12120: PPOPN 1
12122: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
12123: LD_EXP 48
12127: PPUSH
12128: CALL_OW 255
12132: PUSH
12133: LD_INT 7
12135: EQUAL
12136: IFFALSE 12146
12138: GO 12140
12140: DISABLE
// begin enable ;
12141: ENABLE
// PrepareAmericanAttack ;
12142: CALL 7738 0 0
// end ;
12146: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
12147: LD_INT 22
12149: PUSH
12150: LD_INT 1
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PPUSH
12157: CALL_OW 69
12161: IFFALSE 12345
12163: GO 12165
12165: DISABLE
12166: LD_INT 0
12168: PPUSH
12169: PPUSH
// begin while true do
12170: LD_INT 1
12172: IFFALSE 12229
// begin wait ( 0 0$1 ) ;
12174: LD_INT 35
12176: PPUSH
12177: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
12181: LD_ADDR_VAR 0 2
12185: PUSH
12186: LD_INT 22
12188: PUSH
12189: LD_INT 1
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PPUSH
12196: CALL_OW 69
12200: PPUSH
12201: LD_EXP 16
12205: PPUSH
12206: CALL_OW 74
12210: ST_TO_ADDR
// if See ( 7 , tmp ) then
12211: LD_INT 7
12213: PPUSH
12214: LD_VAR 0 2
12218: PPUSH
12219: CALL_OW 292
12223: IFFALSE 12227
// break ;
12225: GO 12229
// end ;
12227: GO 12170
// DialogueOn ;
12229: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
12233: LD_VAR 0 2
12237: PPUSH
12238: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
12242: LD_VAR 0 2
12246: PPUSH
12247: CALL_OW 250
12251: PPUSH
12252: LD_VAR 0 2
12256: PPUSH
12257: CALL_OW 251
12261: PPUSH
12262: LD_INT 7
12264: PPUSH
12265: LD_INT 8
12267: PPUSH
12268: CALL_OW 330
// if Denis then
12272: LD_EXP 22
12276: IFFALSE 12290
// Say ( Denis , DAmerAttack-Pet-1 ) ;
12278: LD_EXP 22
12282: PPUSH
12283: LD_STRING DAmerAttack-Pet-1
12285: PPUSH
12286: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
12290: LD_EXP 16
12294: PPUSH
12295: LD_STRING DAmerAttack-JMM-1
12297: PPUSH
12298: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
12302: LD_EXP 48
12306: PPUSH
12307: LD_STRING DStop-Bur-1
12309: PPUSH
12310: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
12314: LD_VAR 0 2
12318: PPUSH
12319: CALL_OW 250
12323: PPUSH
12324: LD_VAR 0 2
12328: PPUSH
12329: CALL_OW 251
12333: PPUSH
12334: LD_INT 7
12336: PPUSH
12337: CALL_OW 331
// DialogueOff ;
12341: CALL_OW 7
// end ;
12345: PPOPN 2
12347: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
12348: LD_INT 22
12350: PUSH
12351: LD_INT 3
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 21
12360: PUSH
12361: LD_INT 1
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PPUSH
12372: CALL_OW 69
12376: PUSH
12377: LD_INT 0
12379: EQUAL
12380: IFFALSE 12422
12382: GO 12384
12384: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
12385: LD_STRING M5a
12387: PPUSH
12388: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
12392: LD_EXP 16
12396: PPUSH
12397: LD_STRING D8-JMM-1
12399: PPUSH
12400: CALL_OW 88
// if Gossudarov then
12404: LD_EXP 34
12408: IFFALSE 12422
// Say ( Gossudarov , D8-Gos-1 ) ;
12410: LD_EXP 34
12414: PPUSH
12415: LD_STRING D8-Gos-1
12417: PPUSH
12418: CALL_OW 88
// end ;
12422: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
12423: LD_INT 22
12425: PUSH
12426: LD_INT 2
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: LD_INT 21
12435: PUSH
12436: LD_INT 1
12438: PUSH
12439: EMPTY
12440: LIST
12441: LIST
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PPUSH
12447: CALL_OW 69
12451: PUSH
12452: LD_INT 0
12454: EQUAL
12455: IFFALSE 12505
12457: GO 12459
12459: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
12460: LD_STRING M4c
12462: PPUSH
12463: CALL_OW 337
// if Roth then
12467: LD_EXP 17
12471: IFFALSE 12487
// Say ( Roth , DStop-Roth-1 ) else
12473: LD_EXP 17
12477: PPUSH
12478: LD_STRING DStop-Roth-1
12480: PPUSH
12481: CALL_OW 88
12485: GO 12505
// if Gossudarov then
12487: LD_EXP 34
12491: IFFALSE 12505
// Say ( Gossudarov , D8-Gos-1a ) ;
12493: LD_EXP 34
12497: PPUSH
12498: LD_STRING D8-Gos-1a
12500: PPUSH
12501: CALL_OW 88
// end ;
12505: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
12506: LD_INT 7
12508: PPUSH
12509: LD_INT 1
12511: PPUSH
12512: LD_INT 1
12514: PPUSH
12515: CALL 16082 0 3
12519: PUSH
12520: LD_INT 0
12522: EQUAL
12523: PUSH
12524: LD_INT 7
12526: PPUSH
12527: LD_INT 3
12529: PPUSH
12530: LD_INT 1
12532: PPUSH
12533: CALL 16082 0 3
12537: PUSH
12538: LD_INT 0
12540: EQUAL
12541: AND
12542: IFFALSE 12554
12544: GO 12546
12546: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12547: LD_STRING M1a
12549: PPUSH
12550: CALL_OW 337
// end ;
12554: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12555: LD_INT 22
12557: PUSH
12558: LD_INT 2
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: PUSH
12565: LD_INT 23
12567: PUSH
12568: LD_INT 2
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PUSH
12575: LD_INT 21
12577: PUSH
12578: LD_INT 1
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: LIST
12589: PPUSH
12590: CALL_OW 69
12594: PUSH
12595: LD_INT 0
12597: EQUAL
12598: PUSH
12599: LD_INT 22
12601: PUSH
12602: LD_INT 3
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 23
12611: PUSH
12612: LD_INT 3
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: LD_INT 21
12621: PUSH
12622: LD_INT 1
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: LIST
12633: PPUSH
12634: CALL_OW 69
12638: PUSH
12639: LD_INT 0
12641: EQUAL
12642: AND
12643: PUSH
12644: LD_INT 22
12646: PUSH
12647: LD_INT 1
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PPUSH
12654: CALL_OW 69
12658: PUSH
12659: LD_INT 0
12661: EQUAL
12662: AND
12663: PUSH
12664: LD_INT 7
12666: PPUSH
12667: LD_INT 1
12669: PPUSH
12670: LD_INT 1
12672: PPUSH
12673: CALL 16082 0 3
12677: PUSH
12678: LD_INT 0
12680: EQUAL
12681: AND
12682: PUSH
12683: LD_INT 7
12685: PPUSH
12686: LD_INT 3
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL 16082 0 3
12696: PUSH
12697: LD_INT 0
12699: EQUAL
12700: AND
12701: PUSH
12702: LD_EXP 48
12706: PPUSH
12707: CALL_OW 255
12711: PUSH
12712: LD_INT 7
12714: EQUAL
12715: AND
12716: PUSH
12717: LD_EXP 48
12721: PPUSH
12722: CALL_OW 302
12726: AND
12727: IFFALSE 14400
12729: GO 12731
12731: DISABLE
12732: LD_INT 0
12734: PPUSH
12735: PPUSH
12736: PPUSH
12737: PPUSH
12738: PPUSH
12739: PPUSH
// begin m1 := false ;
12740: LD_ADDR_VAR 0 4
12744: PUSH
12745: LD_INT 0
12747: ST_TO_ADDR
// m2 := false ;
12748: LD_ADDR_VAR 0 5
12752: PUSH
12753: LD_INT 0
12755: ST_TO_ADDR
// m3 := false ;
12756: LD_ADDR_VAR 0 6
12760: PUSH
12761: LD_INT 0
12763: ST_TO_ADDR
// if tick < 40 40$00 then
12764: LD_OWVAR 1
12768: PUSH
12769: LD_INT 84000
12771: LESS
12772: IFFALSE 12781
// SetAchievement ( ACH_ASPEED_17 ) ;
12774: LD_STRING ACH_ASPEED_17
12776: PPUSH
12777: CALL_OW 543
// wait ( 0 0$5 ) ;
12781: LD_INT 175
12783: PPUSH
12784: CALL_OW 67
// if not masha_killed then
12788: LD_EXP 10
12792: NOT
12793: IFFALSE 12815
// begin m1 := true ;
12795: LD_ADDR_VAR 0 4
12799: PUSH
12800: LD_INT 1
12802: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
12803: LD_STRING Masha
12805: PPUSH
12806: LD_INT 1
12808: PPUSH
12809: CALL_OW 101
// end else
12813: GO 12826
// AddMedal ( Masha , - 1 ) ;
12815: LD_STRING Masha
12817: PPUSH
12818: LD_INT 1
12820: NEG
12821: PPUSH
12822: CALL_OW 101
// if abdul_escaped then
12826: LD_EXP 13
12830: IFFALSE 12845
// AddMedal ( Abdul , - 1 ) else
12832: LD_STRING Abdul
12834: PPUSH
12835: LD_INT 1
12837: NEG
12838: PPUSH
12839: CALL_OW 101
12843: GO 12863
// begin m2 := true ;
12845: LD_ADDR_VAR 0 5
12849: PUSH
12850: LD_INT 1
12852: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
12853: LD_STRING Abdul
12855: PPUSH
12856: LD_INT 1
12858: PPUSH
12859: CALL_OW 101
// end ; if loss_counter = 0 then
12863: LD_EXP 14
12867: PUSH
12868: LD_INT 0
12870: EQUAL
12871: IFFALSE 12893
// begin m3 := true ;
12873: LD_ADDR_VAR 0 6
12877: PUSH
12878: LD_INT 1
12880: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
12881: LD_STRING People
12883: PPUSH
12884: LD_INT 2
12886: PPUSH
12887: CALL_OW 101
// end else
12891: GO 12955
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
12893: LD_EXP 14
12897: PUSH
12898: LD_INT 3
12900: PUSH
12901: LD_INT 2
12903: PUSH
12904: LD_INT 2
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: PUSH
12916: LD_OWVAR 67
12920: ARRAY
12921: LESSEQUAL
12922: IFFALSE 12944
// begin AddMedal ( People , 1 ) ;
12924: LD_STRING People
12926: PPUSH
12927: LD_INT 1
12929: PPUSH
12930: CALL_OW 101
// m3 := true ;
12934: LD_ADDR_VAR 0 6
12938: PUSH
12939: LD_INT 1
12941: ST_TO_ADDR
// end else
12942: GO 12955
// AddMedal ( People , - 1 ) ;
12944: LD_STRING People
12946: PPUSH
12947: LD_INT 1
12949: NEG
12950: PPUSH
12951: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12955: LD_OWVAR 67
12959: PUSH
12960: LD_INT 3
12962: GREATEREQUAL
12963: PUSH
12964: LD_VAR 0 4
12968: AND
12969: PUSH
12970: LD_VAR 0 5
12974: AND
12975: PUSH
12976: LD_VAR 0 6
12980: AND
12981: IFFALSE 12993
// SetAchievementEX ( ACH_AMER , 17 ) ;
12983: LD_STRING ACH_AMER
12985: PPUSH
12986: LD_INT 17
12988: PPUSH
12989: CALL_OW 564
// GiveMedals ( MAIN ) ;
12993: LD_STRING MAIN
12995: PPUSH
12996: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 7
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 50
13017: PUSH
13018: EMPTY
13019: LIST
13020: PUSH
13021: LD_INT 2
13023: PUSH
13024: LD_INT 25
13026: PUSH
13027: LD_INT 1
13029: PUSH
13030: EMPTY
13031: LIST
13032: LIST
13033: PUSH
13034: LD_INT 25
13036: PUSH
13037: LD_INT 2
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 25
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: LD_INT 25
13056: PUSH
13057: LD_INT 4
13059: PUSH
13060: EMPTY
13061: LIST
13062: LIST
13063: PUSH
13064: LD_INT 25
13066: PUSH
13067: LD_INT 5
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 25
13076: PUSH
13077: LD_INT 8
13079: PUSH
13080: EMPTY
13081: LIST
13082: LIST
13083: PUSH
13084: LD_INT 25
13086: PUSH
13087: LD_INT 9
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: LIST
13101: LIST
13102: LIST
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: LIST
13108: PPUSH
13109: CALL_OW 69
13113: ST_TO_ADDR
// RewardPeople ( tmp ) ;
13114: LD_VAR 0 2
13118: PPUSH
13119: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
13123: LD_ADDR_VAR 0 3
13127: PUSH
13128: LD_EXP 16
13132: PUSH
13133: LD_EXP 17
13137: PUSH
13138: LD_EXP 18
13142: PUSH
13143: LD_EXP 19
13147: PUSH
13148: LD_EXP 20
13152: PUSH
13153: LD_EXP 21
13157: PUSH
13158: LD_EXP 22
13162: PUSH
13163: LD_EXP 23
13167: PUSH
13168: LD_EXP 24
13172: PUSH
13173: LD_EXP 25
13177: PUSH
13178: LD_EXP 26
13182: PUSH
13183: LD_EXP 27
13187: PUSH
13188: LD_EXP 28
13192: PUSH
13193: LD_EXP 29
13197: PUSH
13198: LD_EXP 30
13202: PUSH
13203: LD_EXP 31
13207: PUSH
13208: LD_EXP 32
13212: PUSH
13213: LD_EXP 34
13217: PUSH
13218: LD_EXP 35
13222: PUSH
13223: LD_EXP 36
13227: PUSH
13228: LD_EXP 38
13232: PUSH
13233: LD_EXP 39
13237: PUSH
13238: LD_EXP 40
13242: PUSH
13243: LD_EXP 41
13247: PUSH
13248: LD_EXP 42
13252: PUSH
13253: LD_EXP 43
13257: PUSH
13258: LD_EXP 44
13262: PUSH
13263: LD_EXP 45
13267: PUSH
13268: LD_EXP 46
13272: PUSH
13273: LD_EXP 47
13277: PUSH
13278: LD_EXP 48
13282: PUSH
13283: LD_EXP 49
13287: PUSH
13288: LD_EXP 50
13292: PUSH
13293: LD_EXP 33
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: LIST
13315: LIST
13316: LIST
13317: LIST
13318: LIST
13319: LIST
13320: LIST
13321: LIST
13322: LIST
13323: LIST
13324: LIST
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: ST_TO_ADDR
// if tmp diff tmp2 then
13334: LD_VAR 0 2
13338: PUSH
13339: LD_VAR 0 3
13343: DIFF
13344: IFFALSE 13364
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
13346: LD_VAR 0 2
13350: PUSH
13351: LD_VAR 0 3
13355: DIFF
13356: PPUSH
13357: LD_STRING 13a_others
13359: PPUSH
13360: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
13364: LD_EXP 16
13368: PPUSH
13369: LD_STRING 13a_JMM
13371: PPUSH
13372: CALL_OW 38
// if IsOk ( Mike ) then
13376: LD_EXP 33
13380: PPUSH
13381: CALL_OW 302
13385: IFFALSE 13399
// SaveCharacters ( Mike , 13a_Mike ) ;
13387: LD_EXP 33
13391: PPUSH
13392: LD_STRING 13a_Mike
13394: PPUSH
13395: CALL_OW 38
// if IsOk ( Titov ) then
13399: LD_EXP 36
13403: PPUSH
13404: CALL_OW 302
13408: IFFALSE 13422
// SaveCharacters ( Titov , 13a_Titov ) ;
13410: LD_EXP 36
13414: PPUSH
13415: LD_STRING 13a_Titov
13417: PPUSH
13418: CALL_OW 38
// if IsOk ( Dolgov ) then
13422: LD_EXP 38
13426: PPUSH
13427: CALL_OW 302
13431: IFFALSE 13445
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
13433: LD_EXP 38
13437: PPUSH
13438: LD_STRING 13a_Dolgov
13440: PPUSH
13441: CALL_OW 38
// if IsOk ( Petrosyan ) then
13445: LD_EXP 39
13449: PPUSH
13450: CALL_OW 302
13454: IFFALSE 13468
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
13456: LD_EXP 39
13460: PPUSH
13461: LD_STRING 13a_Petrosyan
13463: PPUSH
13464: CALL_OW 38
// if IsOk ( Scholtze ) then
13468: LD_EXP 40
13472: PPUSH
13473: CALL_OW 302
13477: IFFALSE 13491
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
13479: LD_EXP 40
13483: PPUSH
13484: LD_STRING 13a_Scholtze
13486: PPUSH
13487: CALL_OW 38
// if IsOk ( Oblukov ) then
13491: LD_EXP 41
13495: PPUSH
13496: CALL_OW 302
13500: IFFALSE 13514
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
13502: LD_EXP 41
13506: PPUSH
13507: LD_STRING 13a_Oblukov
13509: PPUSH
13510: CALL_OW 38
// if IsOk ( Kapitsova ) then
13514: LD_EXP 42
13518: PPUSH
13519: CALL_OW 302
13523: IFFALSE 13537
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13525: LD_EXP 42
13529: PPUSH
13530: LD_STRING 13a_Kapitsova
13532: PPUSH
13533: CALL_OW 38
// if IsOk ( Lipshchin ) then
13537: LD_EXP 43
13541: PPUSH
13542: CALL_OW 302
13546: IFFALSE 13560
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13548: LD_EXP 43
13552: PPUSH
13553: LD_STRING 13a_Lipshchin
13555: PPUSH
13556: CALL_OW 38
// if IsOk ( Petrovova ) then
13560: LD_EXP 44
13564: PPUSH
13565: CALL_OW 302
13569: IFFALSE 13583
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13571: LD_EXP 44
13575: PPUSH
13576: LD_STRING 13a_Petrovova
13578: PPUSH
13579: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13583: LD_EXP 45
13587: PPUSH
13588: CALL_OW 302
13592: IFFALSE 13606
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13594: LD_EXP 45
13598: PPUSH
13599: LD_STRING 13a_Kovalyuk
13601: PPUSH
13602: CALL_OW 38
// if IsOk ( Kuzmov ) then
13606: LD_EXP 46
13610: PPUSH
13611: CALL_OW 302
13615: IFFALSE 13629
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
13617: LD_EXP 46
13621: PPUSH
13622: LD_STRING 13a_Kuzmov
13624: PPUSH
13625: CALL_OW 38
// if IsOk ( Karamazov ) then
13629: LD_EXP 47
13633: PPUSH
13634: CALL_OW 302
13638: IFFALSE 13652
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
13640: LD_EXP 47
13644: PPUSH
13645: LD_STRING 13a_Karamazov
13647: PPUSH
13648: CALL_OW 38
// if Burlak then
13652: LD_EXP 48
13656: IFFALSE 13677
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
13658: LD_STRING enableBioCharacter(BIO_GORKI)
13660: PPUSH
13661: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
13665: LD_EXP 48
13669: PPUSH
13670: LD_STRING 13a_Burlak
13672: PPUSH
13673: CALL_OW 38
// end ; if IsOk ( Belkov ) then
13677: LD_EXP 49
13681: PPUSH
13682: CALL_OW 302
13686: IFFALSE 13700
// SaveCharacters ( Belkov , 13a_Belkov ) ;
13688: LD_EXP 49
13692: PPUSH
13693: LD_STRING 13a_Belkov
13695: PPUSH
13696: CALL_OW 38
// if IsOk ( Gnyevko ) then
13700: LD_EXP 50
13704: PPUSH
13705: CALL_OW 302
13709: IFFALSE 13723
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
13711: LD_EXP 50
13715: PPUSH
13716: LD_STRING 13a_Gnyevko
13718: PPUSH
13719: CALL_OW 38
// if IsOk ( Lisa ) then
13723: LD_EXP 18
13727: PPUSH
13728: CALL_OW 302
13732: IFFALSE 13746
// SaveCharacters ( Lisa , 13a_Lisa ) ;
13734: LD_EXP 18
13738: PPUSH
13739: LD_STRING 13a_Lisa
13741: PPUSH
13742: CALL_OW 38
// if IsOk ( Donaldson ) then
13746: LD_EXP 19
13750: PPUSH
13751: CALL_OW 302
13755: IFFALSE 13769
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
13757: LD_EXP 19
13761: PPUSH
13762: LD_STRING 13a_Donaldson
13764: PPUSH
13765: CALL_OW 38
// if IsOk ( Bobby ) then
13769: LD_EXP 20
13773: PPUSH
13774: CALL_OW 302
13778: IFFALSE 13792
// SaveCharacters ( Bobby , 13a_Bobby ) ;
13780: LD_EXP 20
13784: PPUSH
13785: LD_STRING 13a_Bobby
13787: PPUSH
13788: CALL_OW 38
// if IsOk ( Cyrus ) then
13792: LD_EXP 21
13796: PPUSH
13797: CALL_OW 302
13801: IFFALSE 13815
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
13803: LD_EXP 21
13807: PPUSH
13808: LD_STRING 13a_Cyrus
13810: PPUSH
13811: CALL_OW 38
// if IsOk ( Denis ) then
13815: LD_EXP 22
13819: PPUSH
13820: CALL_OW 302
13824: IFFALSE 13838
// SaveCharacters ( Denis , 13a_Denis ) ;
13826: LD_EXP 22
13830: PPUSH
13831: LD_STRING 13a_Denis
13833: PPUSH
13834: CALL_OW 38
// if IsOk ( Brown ) then
13838: LD_EXP 23
13842: PPUSH
13843: CALL_OW 302
13847: IFFALSE 13861
// SaveCharacters ( Brown , 13a_Brown ) ;
13849: LD_EXP 23
13853: PPUSH
13854: LD_STRING 13a_Brown
13856: PPUSH
13857: CALL_OW 38
// if IsOk ( Gladstone ) then
13861: LD_EXP 24
13865: PPUSH
13866: CALL_OW 302
13870: IFFALSE 13884
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
13872: LD_EXP 24
13876: PPUSH
13877: LD_STRING 13a_Gladstone
13879: PPUSH
13880: CALL_OW 38
// if IsOk ( Houten ) then
13884: LD_EXP 25
13888: PPUSH
13889: CALL_OW 302
13893: IFFALSE 13907
// SaveCharacters ( Houten , 13a_Houten ) ;
13895: LD_EXP 25
13899: PPUSH
13900: LD_STRING 13a_Houten
13902: PPUSH
13903: CALL_OW 38
// if IsOk ( Cornel ) then
13907: LD_EXP 26
13911: PPUSH
13912: CALL_OW 302
13916: IFFALSE 13930
// SaveCharacters ( Cornel , 13a_Cornel ) ;
13918: LD_EXP 26
13922: PPUSH
13923: LD_STRING 13a_Cornel
13925: PPUSH
13926: CALL_OW 38
// if IsOk ( Gary ) then
13930: LD_EXP 27
13934: PPUSH
13935: CALL_OW 302
13939: IFFALSE 13953
// SaveCharacters ( Gary , 13a_Gary ) ;
13941: LD_EXP 27
13945: PPUSH
13946: LD_STRING 13a_Gary
13948: PPUSH
13949: CALL_OW 38
// if IsOk ( Frank ) then
13953: LD_EXP 28
13957: PPUSH
13958: CALL_OW 302
13962: IFFALSE 13976
// SaveCharacters ( Frank , 13a_Frank ) ;
13964: LD_EXP 28
13968: PPUSH
13969: LD_STRING 13a_Frank
13971: PPUSH
13972: CALL_OW 38
// if IsOk ( Kikuchi ) then
13976: LD_EXP 29
13980: PPUSH
13981: CALL_OW 302
13985: IFFALSE 13999
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
13987: LD_EXP 29
13991: PPUSH
13992: LD_STRING 13a_Kikuchi
13994: PPUSH
13995: CALL_OW 38
// if IsOk ( Simms ) then
13999: LD_EXP 30
14003: PPUSH
14004: CALL_OW 302
14008: IFFALSE 14022
// SaveCharacters ( Simms , 13a_Simms ) ;
14010: LD_EXP 30
14014: PPUSH
14015: LD_STRING 13a_Simms
14017: PPUSH
14018: CALL_OW 38
// if IsOk ( Joan ) then
14022: LD_EXP 31
14026: PPUSH
14027: CALL_OW 302
14031: IFFALSE 14045
// SaveCharacters ( Joan , 13a_Joan ) ;
14033: LD_EXP 31
14037: PPUSH
14038: LD_STRING 13a_Joan
14040: PPUSH
14041: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
14045: LD_EXP 32
14049: PPUSH
14050: CALL_OW 302
14054: IFFALSE 14068
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
14056: LD_EXP 32
14060: PPUSH
14061: LD_STRING 13a_DeltaDoctor
14063: PPUSH
14064: CALL_OW 38
// if IsOk ( Gossudarov ) then
14068: LD_EXP 34
14072: PPUSH
14073: CALL_OW 302
14077: IFFALSE 14091
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
14079: LD_EXP 34
14083: PPUSH
14084: LD_STRING 13a_Gossudarov
14086: PPUSH
14087: CALL_OW 38
// if IsOk ( Kirilenkova ) then
14091: LD_EXP 35
14095: PPUSH
14096: CALL_OW 302
14100: IFFALSE 14114
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
14102: LD_EXP 35
14106: PPUSH
14107: LD_STRING 13a_Kirilenkova
14109: PPUSH
14110: CALL_OW 38
// if IsOk ( Roth ) then
14114: LD_EXP 17
14118: PPUSH
14119: CALL_OW 302
14123: IFFALSE 14137
// SaveCharacters ( Roth , 13a_Roth ) ;
14125: LD_EXP 17
14129: PPUSH
14130: LD_STRING 13a_Roth
14132: PPUSH
14133: CALL_OW 38
// if Masha then
14137: LD_EXP 51
14141: IFFALSE 14196
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
14143: LD_EXP 51
14147: PPUSH
14148: CALL_OW 265
14152: PUSH
14153: LD_EXP 51
14157: PPUSH
14158: CALL_OW 262
14162: PUSH
14163: LD_EXP 51
14167: PPUSH
14168: CALL_OW 263
14172: PUSH
14173: LD_EXP 51
14177: PPUSH
14178: CALL_OW 264
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PPUSH
14189: LD_STRING 13a_Masha
14191: PPUSH
14192: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
14196: LD_ADDR_VAR 0 2
14200: PUSH
14201: LD_INT 21
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PPUSH
14211: CALL_OW 69
14215: ST_TO_ADDR
// tmp2 := [ ] ;
14216: LD_ADDR_VAR 0 3
14220: PUSH
14221: EMPTY
14222: ST_TO_ADDR
// if tmp then
14223: LD_VAR 0 2
14227: IFFALSE 14378
// for i in tmp do
14229: LD_ADDR_VAR 0 1
14233: PUSH
14234: LD_VAR 0 2
14238: PUSH
14239: FOR_IN
14240: IFFALSE 14376
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
14242: LD_ADDR_VAR 0 3
14246: PUSH
14247: LD_VAR 0 3
14251: PUSH
14252: LD_VAR 0 1
14256: PPUSH
14257: CALL_OW 255
14261: PUSH
14262: LD_VAR 0 1
14266: PPUSH
14267: CALL_OW 248
14271: PUSH
14272: LD_VAR 0 1
14276: PPUSH
14277: CALL_OW 266
14281: PUSH
14282: LD_VAR 0 1
14286: PPUSH
14287: CALL_OW 250
14291: PUSH
14292: LD_VAR 0 1
14296: PPUSH
14297: CALL_OW 251
14301: PUSH
14302: LD_VAR 0 1
14306: PPUSH
14307: CALL_OW 254
14311: PUSH
14312: LD_VAR 0 1
14316: PPUSH
14317: CALL_OW 267
14321: PUSH
14322: LD_VAR 0 1
14326: PPUSH
14327: LD_INT 1
14329: PPUSH
14330: CALL_OW 268
14334: PUSH
14335: LD_VAR 0 1
14339: PPUSH
14340: LD_INT 2
14342: PPUSH
14343: CALL_OW 268
14347: PUSH
14348: LD_VAR 0 1
14352: PPUSH
14353: CALL_OW 269
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: PUSH
14370: EMPTY
14371: LIST
14372: ADD
14373: ST_TO_ADDR
14374: GO 14239
14376: POP
14377: POP
// if tmp2 then
14378: LD_VAR 0 3
14382: IFFALSE 14396
// SaveVariable ( tmp2 , 13a_buildings ) ;
14384: LD_VAR 0 3
14388: PPUSH
14389: LD_STRING 13a_buildings
14391: PPUSH
14392: CALL_OW 39
// YouWin ;
14396: CALL_OW 103
// end ;
14400: PPOPN 6
14402: END
// export function SciRu ; var tmp , t ; begin
14403: LD_INT 0
14405: PPUSH
14406: PPUSH
14407: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14408: LD_ADDR_VAR 0 3
14412: PUSH
14413: LD_EXP 34
14417: PUSH
14418: LD_EXP 48
14422: PUSH
14423: LD_EXP 36
14427: PUSH
14428: LD_EXP 49
14432: PUSH
14433: LD_EXP 50
14437: PUSH
14438: LD_EXP 39
14442: PUSH
14443: LD_EXP 40
14447: PUSH
14448: LD_EXP 38
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
14463: LD_ADDR_VAR 0 2
14467: PUSH
14468: LD_INT 22
14470: PUSH
14471: LD_INT 7
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PUSH
14478: LD_INT 23
14480: PUSH
14481: LD_INT 3
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: LD_INT 25
14490: PUSH
14491: LD_INT 4
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: LD_INT 26
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: PPUSH
14514: CALL_OW 69
14518: PUSH
14519: LD_VAR 0 3
14523: DIFF
14524: ST_TO_ADDR
// if tmp then
14525: LD_VAR 0 2
14529: IFFALSE 14545
// result := tmp [ 1 ] ;
14531: LD_ADDR_VAR 0 1
14535: PUSH
14536: LD_VAR 0 2
14540: PUSH
14541: LD_INT 1
14543: ARRAY
14544: ST_TO_ADDR
// end ;
14545: LD_VAR 0 1
14549: RET
// export function SolRu ; var tmp , t ; begin
14550: LD_INT 0
14552: PPUSH
14553: PPUSH
14554: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14555: LD_ADDR_VAR 0 3
14559: PUSH
14560: LD_EXP 34
14564: PUSH
14565: LD_EXP 48
14569: PUSH
14570: LD_EXP 36
14574: PUSH
14575: LD_EXP 49
14579: PUSH
14580: LD_EXP 50
14584: PUSH
14585: LD_EXP 39
14589: PUSH
14590: LD_EXP 40
14594: PUSH
14595: LD_EXP 38
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14610: LD_ADDR_VAR 0 2
14614: PUSH
14615: LD_INT 22
14617: PUSH
14618: LD_INT 7
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 23
14627: PUSH
14628: LD_INT 3
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: LD_INT 25
14637: PUSH
14638: LD_INT 1
14640: PUSH
14641: EMPTY
14642: LIST
14643: LIST
14644: PUSH
14645: LD_INT 26
14647: PUSH
14648: LD_INT 1
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: PPUSH
14661: CALL_OW 69
14665: PUSH
14666: LD_VAR 0 3
14670: DIFF
14671: ST_TO_ADDR
// if tmp then
14672: LD_VAR 0 2
14676: IFFALSE 14692
// result := tmp [ 1 ] ;
14678: LD_ADDR_VAR 0 1
14682: PUSH
14683: LD_VAR 0 2
14687: PUSH
14688: LD_INT 1
14690: ARRAY
14691: ST_TO_ADDR
// end ; end_of_file
14692: LD_VAR 0 1
14696: RET
// export function CustomEvent ( event ) ; begin
14697: LD_INT 0
14699: PPUSH
// end ;
14700: LD_VAR 0 2
14704: RET
// on UnitDestroyed ( un ) do var i , side ;
14705: LD_INT 0
14707: PPUSH
14708: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
14709: LD_VAR 0 1
14713: PPUSH
14714: CALL 104694 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
14718: LD_VAR 0 1
14722: PUSH
14723: LD_INT 22
14725: PUSH
14726: LD_INT 7
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: LD_INT 25
14738: PUSH
14739: LD_INT 1
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 25
14748: PUSH
14749: LD_INT 2
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 25
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: LD_INT 25
14768: PUSH
14769: LD_INT 4
14771: PUSH
14772: EMPTY
14773: LIST
14774: LIST
14775: PUSH
14776: LD_INT 25
14778: PUSH
14779: LD_INT 5
14781: PUSH
14782: EMPTY
14783: LIST
14784: LIST
14785: PUSH
14786: LD_INT 25
14788: PUSH
14789: LD_INT 8
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: PUSH
14796: LD_INT 25
14798: PUSH
14799: LD_INT 9
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: PPUSH
14820: CALL_OW 69
14824: IN
14825: IFFALSE 14841
// loss_counter := loss_counter + 1 ;
14827: LD_ADDR_EXP 14
14831: PUSH
14832: LD_EXP 14
14836: PUSH
14837: LD_INT 1
14839: PLUS
14840: ST_TO_ADDR
// if un = Abdul then
14841: LD_VAR 0 1
14845: PUSH
14846: LD_EXP 57
14850: EQUAL
14851: IFFALSE 14861
// abdul_escaped := false ;
14853: LD_ADDR_EXP 13
14857: PUSH
14858: LD_INT 0
14860: ST_TO_ADDR
// if un in ru_attackers then
14861: LD_VAR 0 1
14865: PUSH
14866: LD_EXP 54
14870: IN
14871: IFFALSE 14889
// ru_attackers := ru_attackers diff un ;
14873: LD_ADDR_EXP 54
14877: PUSH
14878: LD_EXP 54
14882: PUSH
14883: LD_VAR 0 1
14887: DIFF
14888: ST_TO_ADDR
// if un in ar_attackers then
14889: LD_VAR 0 1
14893: PUSH
14894: LD_EXP 11
14898: IN
14899: IFFALSE 14917
// ar_attackers := ar_attackers diff un ;
14901: LD_ADDR_EXP 11
14905: PUSH
14906: LD_EXP 11
14910: PUSH
14911: LD_VAR 0 1
14915: DIFF
14916: ST_TO_ADDR
// if un = JMM then
14917: LD_VAR 0 1
14921: PUSH
14922: LD_EXP 16
14926: EQUAL
14927: IFFALSE 14938
// begin YouLost ( JMM ) ;
14929: LD_STRING JMM
14931: PPUSH
14932: CALL_OW 104
// exit ;
14936: GO 15035
// end ; if un = Burlak then
14938: LD_VAR 0 1
14942: PUSH
14943: LD_EXP 48
14947: EQUAL
14948: IFFALSE 14959
// begin YouLost ( Burlak ) ;
14950: LD_STRING Burlak
14952: PPUSH
14953: CALL_OW 104
// exit ;
14957: GO 15035
// end ; if un = freedom then
14959: LD_VAR 0 1
14963: PUSH
14964: LD_EXP 3
14968: EQUAL
14969: IFFALSE 14980
// begin YouLost ( Destroyed ) ;
14971: LD_STRING Destroyed
14973: PPUSH
14974: CALL_OW 104
// exit ;
14978: GO 15035
// end ; if un = Masha then
14980: LD_VAR 0 1
14984: PUSH
14985: LD_EXP 51
14989: EQUAL
14990: IFFALSE 15007
// begin ChangeMissionObjectives ( M4b ) ;
14992: LD_STRING M4b
14994: PPUSH
14995: CALL_OW 337
// masha_killed := true ;
14999: LD_ADDR_EXP 10
15003: PUSH
15004: LD_INT 1
15006: ST_TO_ADDR
// end ; if un = Mastodont then
15007: LD_VAR 0 1
15011: PUSH
15012: LD_EXP 58
15016: EQUAL
15017: IFFALSE 15026
// ChangeMissionObjectives ( M4a ) ;
15019: LD_STRING M4a
15021: PPUSH
15022: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
15026: LD_VAR 0 1
15030: PPUSH
15031: CALL 85908 0 1
// end ;
15035: PPOPN 3
15037: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15038: LD_VAR 0 1
15042: PPUSH
15043: LD_VAR 0 2
15047: PPUSH
15048: CALL 88240 0 2
// end ;
15052: PPOPN 2
15054: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
15055: LD_VAR 0 1
15059: PPUSH
15060: CALL 87308 0 1
// end ;
15064: PPOPN 1
15066: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
15067: LD_VAR 0 1
15071: PUSH
15072: LD_INT 22
15074: PUSH
15075: LD_INT 7
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: PUSH
15082: LD_INT 30
15084: PUSH
15085: LD_INT 0
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PUSH
15092: EMPTY
15093: LIST
15094: LIST
15095: PPUSH
15096: CALL_OW 69
15100: IN
15101: IFFALSE 15140
// begin SetBName ( building , freedom ) ;
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_STRING freedom
15110: PPUSH
15111: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
15115: LD_INT 0
15117: PPUSH
15118: LD_INT 7
15120: PPUSH
15121: LD_INT 0
15123: PPUSH
15124: CALL_OW 324
// freedom := building ;
15128: LD_ADDR_EXP 3
15132: PUSH
15133: LD_VAR 0 1
15137: ST_TO_ADDR
// exit ;
15138: GO 15206
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
15140: LD_VAR 0 1
15144: PUSH
15145: LD_INT 22
15147: PUSH
15148: LD_INT 7
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 23
15157: PUSH
15158: LD_INT 3
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: PUSH
15165: LD_INT 30
15167: PUSH
15168: LD_INT 6
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: LIST
15179: PPUSH
15180: CALL_OW 69
15184: IN
15185: IFFALSE 15197
// begin ru_lab_builded := true ;
15187: LD_ADDR_EXP 5
15191: PUSH
15192: LD_INT 1
15194: ST_TO_ADDR
// exit ;
15195: GO 15206
// end ; MCE_BuildingComplete ( building ) ;
15197: LD_VAR 0 1
15201: PPUSH
15202: CALL 87549 0 1
// end ;
15206: PPOPN 1
15208: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
15209: LD_VAR 0 1
15213: PPUSH
15214: LD_VAR 0 2
15218: PPUSH
15219: CALL 85604 0 2
// end ;
15223: PPOPN 2
15225: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15226: LD_VAR 0 1
15230: PPUSH
15231: LD_VAR 0 2
15235: PPUSH
15236: LD_VAR 0 3
15240: PPUSH
15241: LD_VAR 0 4
15245: PPUSH
15246: LD_VAR 0 5
15250: PPUSH
15251: CALL 85224 0 5
// end ;
15255: PPOPN 5
15257: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
15258: LD_VAR 0 1
15262: PPUSH
15263: LD_VAR 0 2
15267: PPUSH
15268: CALL 104814 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
15272: LD_VAR 0 1
15276: PPUSH
15277: LD_VAR 0 2
15281: PPUSH
15282: CALL 84777 0 2
// end ;
15286: PPOPN 2
15288: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
15289: LD_VAR 0 1
15293: PPUSH
15294: CALL_OW 263
15298: PUSH
15299: LD_INT 3
15301: EQUAL
15302: PUSH
15303: LD_VAR 0 2
15307: PPUSH
15308: CALL_OW 263
15312: PUSH
15313: LD_INT 3
15315: EQUAL
15316: OR
15317: IFFALSE 15333
// hack_counter := hack_counter + 1 ;
15319: LD_ADDR_EXP 15
15323: PUSH
15324: LD_EXP 15
15328: PUSH
15329: LD_INT 1
15331: PLUS
15332: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15333: LD_VAR 0 1
15337: PPUSH
15338: LD_VAR 0 2
15342: PPUSH
15343: LD_VAR 0 3
15347: PPUSH
15348: LD_VAR 0 4
15352: PPUSH
15353: CALL 84615 0 4
// end ;
15357: PPOPN 4
15359: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
15360: LD_VAR 0 1
15364: PPUSH
15365: LD_VAR 0 2
15369: PPUSH
15370: LD_VAR 0 3
15374: PPUSH
15375: CALL 84390 0 3
// end ;
15379: PPOPN 3
15381: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
15382: LD_VAR 0 1
15386: PPUSH
15387: LD_VAR 0 2
15391: PPUSH
15392: CALL 84275 0 2
// end ;
15396: PPOPN 2
15398: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
15399: LD_VAR 0 1
15403: PPUSH
15404: LD_VAR 0 2
15408: PPUSH
15409: CALL 88535 0 2
// end ;
15413: PPOPN 2
15415: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
15416: LD_VAR 0 1
15420: PPUSH
15421: LD_VAR 0 2
15425: PPUSH
15426: LD_VAR 0 3
15430: PPUSH
15431: LD_VAR 0 4
15435: PPUSH
15436: CALL 88751 0 4
// end ;
15440: PPOPN 4
15442: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 2
15452: PPUSH
15453: CALL 84084 0 2
// end ;
15457: PPOPN 2
15459: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
15460: LD_VAR 0 1
15464: PPUSH
15465: CALL 104798 0 1
// end ; end_of_file
15469: PPOPN 1
15471: END
// every 0 0$30 do var cr , time ;
15472: GO 15474
15474: DISABLE
15475: LD_INT 0
15477: PPUSH
15478: PPUSH
// begin time := 0 0$20 ;
15479: LD_ADDR_VAR 0 2
15483: PUSH
15484: LD_INT 700
15486: ST_TO_ADDR
// while game do
15487: LD_EXP 2
15491: IFFALSE 15594
// begin wait ( time ) ;
15493: LD_VAR 0 2
15497: PPUSH
15498: CALL_OW 67
// if tick > 2 2$00 then
15502: LD_OWVAR 1
15506: PUSH
15507: LD_INT 4200
15509: GREATER
15510: IFFALSE 15547
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15512: LD_ADDR_VAR 0 2
15516: PUSH
15517: LD_VAR 0 2
15521: PUSH
15522: LD_INT 140
15524: PUSH
15525: LD_INT 140
15527: PUSH
15528: LD_INT 210
15530: PUSH
15531: LD_INT 280
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: PUSH
15540: LD_OWVAR 67
15544: ARRAY
15545: PLUS
15546: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15547: LD_INT 1
15549: PPUSH
15550: LD_INT 5
15552: PPUSH
15553: CALL_OW 12
15557: PPUSH
15558: LD_INT 70
15560: PPUSH
15561: LD_INT 49
15563: PPUSH
15564: LD_INT 25
15566: PPUSH
15567: LD_INT 1
15569: PPUSH
15570: CALL_OW 56
// if time > 3 3$00 then
15574: LD_VAR 0 2
15578: PUSH
15579: LD_INT 6300
15581: GREATER
15582: IFFALSE 15592
// time := 0 0$30 ;
15584: LD_ADDR_VAR 0 2
15588: PUSH
15589: LD_INT 1050
15591: ST_TO_ADDR
// end ;
15592: GO 15487
// end ;
15594: PPOPN 2
15596: END
// every 0 0$30 do var cr , time ;
15597: GO 15599
15599: DISABLE
15600: LD_INT 0
15602: PPUSH
15603: PPUSH
// begin time := 0 0$20 ;
15604: LD_ADDR_VAR 0 2
15608: PUSH
15609: LD_INT 700
15611: ST_TO_ADDR
// while game do
15612: LD_EXP 2
15616: IFFALSE 15709
// begin wait ( time ) ;
15618: LD_VAR 0 2
15622: PPUSH
15623: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15627: LD_ADDR_VAR 0 2
15631: PUSH
15632: LD_VAR 0 2
15636: PUSH
15637: LD_INT 140
15639: PUSH
15640: LD_INT 175
15642: PUSH
15643: LD_INT 210
15645: PUSH
15646: LD_INT 280
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: LIST
15653: LIST
15654: PUSH
15655: LD_OWVAR 67
15659: ARRAY
15660: PLUS
15661: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
15662: LD_INT 3
15664: PPUSH
15665: LD_INT 5
15667: PPUSH
15668: CALL_OW 12
15672: PPUSH
15673: LD_INT 26
15675: PPUSH
15676: LD_INT 9
15678: PPUSH
15679: LD_INT 30
15681: PPUSH
15682: LD_INT 1
15684: PPUSH
15685: CALL_OW 56
// if time > 3 3$00 then
15689: LD_VAR 0 2
15693: PUSH
15694: LD_INT 6300
15696: GREATER
15697: IFFALSE 15707
// time := 0 0$20 ;
15699: LD_ADDR_VAR 0 2
15703: PUSH
15704: LD_INT 700
15706: ST_TO_ADDR
// end ;
15707: GO 15612
// end ;
15709: PPOPN 2
15711: END
// every 0 0$30 do var cr , time ;
15712: GO 15714
15714: DISABLE
15715: LD_INT 0
15717: PPUSH
15718: PPUSH
// begin time := 0 0$20 ;
15719: LD_ADDR_VAR 0 2
15723: PUSH
15724: LD_INT 700
15726: ST_TO_ADDR
// while game do
15727: LD_EXP 2
15731: IFFALSE 15860
// begin wait ( time ) ;
15733: LD_VAR 0 2
15737: PPUSH
15738: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
15742: LD_ADDR_VAR 0 2
15746: PUSH
15747: LD_VAR 0 2
15751: PUSH
15752: LD_INT 175
15754: PUSH
15755: LD_INT 210
15757: PUSH
15758: LD_INT 280
15760: PUSH
15761: LD_INT 350
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: PUSH
15770: LD_OWVAR 67
15774: ARRAY
15775: PLUS
15776: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
15777: LD_INT 1
15779: PPUSH
15780: LD_INT 5
15782: PPUSH
15783: CALL_OW 12
15787: PPUSH
15788: LD_INT 179
15790: PPUSH
15791: LD_INT 101
15793: PPUSH
15794: LD_INT 20
15796: PPUSH
15797: LD_INT 1
15799: PPUSH
15800: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
15804: LD_INT 350
15806: PPUSH
15807: LD_INT 525
15809: PPUSH
15810: CALL_OW 12
15814: PPUSH
15815: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
15819: LD_INT 1
15821: PPUSH
15822: LD_INT 5
15824: PPUSH
15825: CALL_OW 12
15829: PPUSH
15830: LD_INT 9
15832: PPUSH
15833: LD_INT 1
15835: PPUSH
15836: CALL_OW 55
// if time > 4 4$00 then
15840: LD_VAR 0 2
15844: PUSH
15845: LD_INT 8400
15847: GREATER
15848: IFFALSE 15858
// time := 0 0$30 ;
15850: LD_ADDR_VAR 0 2
15854: PUSH
15855: LD_INT 1050
15857: ST_TO_ADDR
// end ;
15858: GO 15727
// end ;
15860: PPOPN 2
15862: END
// every 0 0$30 do var cr , time ;
15863: GO 15865
15865: DISABLE
15866: LD_INT 0
15868: PPUSH
15869: PPUSH
// begin time := 0 0$10 ;
15870: LD_ADDR_VAR 0 2
15874: PUSH
15875: LD_INT 350
15877: ST_TO_ADDR
// while game do
15878: LD_EXP 2
15882: IFFALSE 16016
// begin wait ( time ) ;
15884: LD_VAR 0 2
15888: PPUSH
15889: CALL_OW 67
// time := time + 0 0$10 ;
15893: LD_ADDR_VAR 0 2
15897: PUSH
15898: LD_VAR 0 2
15902: PUSH
15903: LD_INT 350
15905: PLUS
15906: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
15907: LD_INT 1
15909: PPUSH
15910: LD_INT 5
15912: PPUSH
15913: CALL_OW 12
15917: PPUSH
15918: LD_INT 11
15920: PPUSH
15921: LD_INT 1
15923: PPUSH
15924: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
15928: LD_ADDR_VAR 0 1
15932: PUSH
15933: LD_INT 1
15935: PPUSH
15936: LD_INT 3
15938: PPUSH
15939: CALL_OW 12
15943: ST_TO_ADDR
// if cr = 1 then
15944: LD_VAR 0 1
15948: PUSH
15949: LD_INT 1
15951: EQUAL
15952: IFFALSE 15996
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
15954: LD_INT 700
15956: PPUSH
15957: LD_INT 1575
15959: PPUSH
15960: CALL_OW 12
15964: PPUSH
15965: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
15969: LD_INT 1
15971: PPUSH
15972: LD_INT 5
15974: PPUSH
15975: CALL_OW 12
15979: PPUSH
15980: LD_INT 34
15982: PPUSH
15983: LD_INT 50
15985: PPUSH
15986: LD_INT 7
15988: PPUSH
15989: LD_INT 1
15991: PPUSH
15992: CALL_OW 56
// end ; if time > 4 4$00 then
15996: LD_VAR 0 2
16000: PUSH
16001: LD_INT 8400
16003: GREATER
16004: IFFALSE 16014
// time := 0 0$40 ;
16006: LD_ADDR_VAR 0 2
16010: PUSH
16011: LD_INT 1400
16013: ST_TO_ADDR
// end ;
16014: GO 15878
// end ; end_of_file
16016: PPOPN 2
16018: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
16019: LD_INT 0
16021: PPUSH
16022: PPUSH
// if exist_mode then
16023: LD_VAR 0 2
16027: IFFALSE 16052
// unit := CreateCharacter ( prefix & ident ) else
16029: LD_ADDR_VAR 0 5
16033: PUSH
16034: LD_VAR 0 3
16038: PUSH
16039: LD_VAR 0 1
16043: STR
16044: PPUSH
16045: CALL_OW 34
16049: ST_TO_ADDR
16050: GO 16067
// unit := NewCharacter ( ident ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: CALL_OW 25
16066: ST_TO_ADDR
// result := unit ;
16067: LD_ADDR_VAR 0 4
16071: PUSH
16072: LD_VAR 0 5
16076: ST_TO_ADDR
// end ;
16077: LD_VAR 0 4
16081: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
16082: LD_INT 0
16084: PPUSH
16085: PPUSH
// if not side or not nation then
16086: LD_VAR 0 1
16090: NOT
16091: PUSH
16092: LD_VAR 0 2
16096: NOT
16097: OR
16098: IFFALSE 16102
// exit ;
16100: GO 16870
// case nation of nation_american :
16102: LD_VAR 0 2
16106: PUSH
16107: LD_INT 1
16109: DOUBLE
16110: EQUAL
16111: IFTRUE 16115
16113: GO 16329
16115: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
16116: LD_ADDR_VAR 0 4
16120: PUSH
16121: LD_INT 35
16123: PUSH
16124: LD_INT 45
16126: PUSH
16127: LD_INT 46
16129: PUSH
16130: LD_INT 47
16132: PUSH
16133: LD_INT 82
16135: PUSH
16136: LD_INT 83
16138: PUSH
16139: LD_INT 84
16141: PUSH
16142: LD_INT 85
16144: PUSH
16145: LD_INT 86
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: LD_INT 2
16153: PUSH
16154: LD_INT 6
16156: PUSH
16157: LD_INT 15
16159: PUSH
16160: LD_INT 16
16162: PUSH
16163: LD_INT 7
16165: PUSH
16166: LD_INT 12
16168: PUSH
16169: LD_INT 13
16171: PUSH
16172: LD_INT 10
16174: PUSH
16175: LD_INT 14
16177: PUSH
16178: LD_INT 20
16180: PUSH
16181: LD_INT 21
16183: PUSH
16184: LD_INT 22
16186: PUSH
16187: LD_INT 25
16189: PUSH
16190: LD_INT 32
16192: PUSH
16193: LD_INT 27
16195: PUSH
16196: LD_INT 36
16198: PUSH
16199: LD_INT 69
16201: PUSH
16202: LD_INT 39
16204: PUSH
16205: LD_INT 34
16207: PUSH
16208: LD_INT 40
16210: PUSH
16211: LD_INT 48
16213: PUSH
16214: LD_INT 49
16216: PUSH
16217: LD_INT 50
16219: PUSH
16220: LD_INT 51
16222: PUSH
16223: LD_INT 52
16225: PUSH
16226: LD_INT 53
16228: PUSH
16229: LD_INT 54
16231: PUSH
16232: LD_INT 55
16234: PUSH
16235: LD_INT 56
16237: PUSH
16238: LD_INT 57
16240: PUSH
16241: LD_INT 58
16243: PUSH
16244: LD_INT 59
16246: PUSH
16247: LD_INT 60
16249: PUSH
16250: LD_INT 61
16252: PUSH
16253: LD_INT 62
16255: PUSH
16256: LD_INT 80
16258: PUSH
16259: LD_INT 82
16261: PUSH
16262: LD_INT 83
16264: PUSH
16265: LD_INT 84
16267: PUSH
16268: LD_INT 85
16270: PUSH
16271: LD_INT 86
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: LIST
16278: LIST
16279: LIST
16280: LIST
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: LIST
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: LIST
16294: LIST
16295: LIST
16296: LIST
16297: LIST
16298: LIST
16299: LIST
16300: LIST
16301: LIST
16302: LIST
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: LIST
16309: LIST
16310: LIST
16311: LIST
16312: LIST
16313: LIST
16314: LIST
16315: LIST
16316: LIST
16317: LIST
16318: LIST
16319: LIST
16320: LIST
16321: LIST
16322: LIST
16323: LIST
16324: LIST
16325: LIST
16326: ST_TO_ADDR
16327: GO 16794
16329: LD_INT 2
16331: DOUBLE
16332: EQUAL
16333: IFTRUE 16337
16335: GO 16563
16337: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
16338: LD_ADDR_VAR 0 4
16342: PUSH
16343: LD_INT 35
16345: PUSH
16346: LD_INT 45
16348: PUSH
16349: LD_INT 46
16351: PUSH
16352: LD_INT 47
16354: PUSH
16355: LD_INT 82
16357: PUSH
16358: LD_INT 83
16360: PUSH
16361: LD_INT 84
16363: PUSH
16364: LD_INT 85
16366: PUSH
16367: LD_INT 87
16369: PUSH
16370: LD_INT 70
16372: PUSH
16373: LD_INT 1
16375: PUSH
16376: LD_INT 11
16378: PUSH
16379: LD_INT 3
16381: PUSH
16382: LD_INT 4
16384: PUSH
16385: LD_INT 5
16387: PUSH
16388: LD_INT 6
16390: PUSH
16391: LD_INT 15
16393: PUSH
16394: LD_INT 18
16396: PUSH
16397: LD_INT 7
16399: PUSH
16400: LD_INT 17
16402: PUSH
16403: LD_INT 8
16405: PUSH
16406: LD_INT 20
16408: PUSH
16409: LD_INT 21
16411: PUSH
16412: LD_INT 22
16414: PUSH
16415: LD_INT 72
16417: PUSH
16418: LD_INT 26
16420: PUSH
16421: LD_INT 69
16423: PUSH
16424: LD_INT 39
16426: PUSH
16427: LD_INT 40
16429: PUSH
16430: LD_INT 41
16432: PUSH
16433: LD_INT 42
16435: PUSH
16436: LD_INT 43
16438: PUSH
16439: LD_INT 48
16441: PUSH
16442: LD_INT 49
16444: PUSH
16445: LD_INT 50
16447: PUSH
16448: LD_INT 51
16450: PUSH
16451: LD_INT 52
16453: PUSH
16454: LD_INT 53
16456: PUSH
16457: LD_INT 54
16459: PUSH
16460: LD_INT 55
16462: PUSH
16463: LD_INT 56
16465: PUSH
16466: LD_INT 60
16468: PUSH
16469: LD_INT 61
16471: PUSH
16472: LD_INT 62
16474: PUSH
16475: LD_INT 66
16477: PUSH
16478: LD_INT 67
16480: PUSH
16481: LD_INT 68
16483: PUSH
16484: LD_INT 81
16486: PUSH
16487: LD_INT 82
16489: PUSH
16490: LD_INT 83
16492: PUSH
16493: LD_INT 84
16495: PUSH
16496: LD_INT 85
16498: PUSH
16499: LD_INT 87
16501: PUSH
16502: LD_INT 88
16504: PUSH
16505: EMPTY
16506: LIST
16507: LIST
16508: LIST
16509: LIST
16510: LIST
16511: LIST
16512: LIST
16513: LIST
16514: LIST
16515: LIST
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: LIST
16530: LIST
16531: LIST
16532: LIST
16533: LIST
16534: LIST
16535: LIST
16536: LIST
16537: LIST
16538: LIST
16539: LIST
16540: LIST
16541: LIST
16542: LIST
16543: LIST
16544: LIST
16545: LIST
16546: LIST
16547: LIST
16548: LIST
16549: LIST
16550: LIST
16551: LIST
16552: LIST
16553: LIST
16554: LIST
16555: LIST
16556: LIST
16557: LIST
16558: LIST
16559: LIST
16560: ST_TO_ADDR
16561: GO 16794
16563: LD_INT 3
16565: DOUBLE
16566: EQUAL
16567: IFTRUE 16571
16569: GO 16793
16571: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16572: LD_ADDR_VAR 0 4
16576: PUSH
16577: LD_INT 46
16579: PUSH
16580: LD_INT 47
16582: PUSH
16583: LD_INT 1
16585: PUSH
16586: LD_INT 2
16588: PUSH
16589: LD_INT 82
16591: PUSH
16592: LD_INT 83
16594: PUSH
16595: LD_INT 84
16597: PUSH
16598: LD_INT 85
16600: PUSH
16601: LD_INT 86
16603: PUSH
16604: LD_INT 11
16606: PUSH
16607: LD_INT 9
16609: PUSH
16610: LD_INT 20
16612: PUSH
16613: LD_INT 19
16615: PUSH
16616: LD_INT 21
16618: PUSH
16619: LD_INT 24
16621: PUSH
16622: LD_INT 22
16624: PUSH
16625: LD_INT 25
16627: PUSH
16628: LD_INT 28
16630: PUSH
16631: LD_INT 29
16633: PUSH
16634: LD_INT 30
16636: PUSH
16637: LD_INT 31
16639: PUSH
16640: LD_INT 37
16642: PUSH
16643: LD_INT 38
16645: PUSH
16646: LD_INT 32
16648: PUSH
16649: LD_INT 27
16651: PUSH
16652: LD_INT 33
16654: PUSH
16655: LD_INT 69
16657: PUSH
16658: LD_INT 39
16660: PUSH
16661: LD_INT 34
16663: PUSH
16664: LD_INT 40
16666: PUSH
16667: LD_INT 71
16669: PUSH
16670: LD_INT 23
16672: PUSH
16673: LD_INT 44
16675: PUSH
16676: LD_INT 48
16678: PUSH
16679: LD_INT 49
16681: PUSH
16682: LD_INT 50
16684: PUSH
16685: LD_INT 51
16687: PUSH
16688: LD_INT 52
16690: PUSH
16691: LD_INT 53
16693: PUSH
16694: LD_INT 54
16696: PUSH
16697: LD_INT 55
16699: PUSH
16700: LD_INT 56
16702: PUSH
16703: LD_INT 57
16705: PUSH
16706: LD_INT 58
16708: PUSH
16709: LD_INT 59
16711: PUSH
16712: LD_INT 63
16714: PUSH
16715: LD_INT 64
16717: PUSH
16718: LD_INT 65
16720: PUSH
16721: LD_INT 82
16723: PUSH
16724: LD_INT 83
16726: PUSH
16727: LD_INT 84
16729: PUSH
16730: LD_INT 85
16732: PUSH
16733: LD_INT 86
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: LIST
16741: LIST
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: LIST
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: LIST
16753: LIST
16754: LIST
16755: LIST
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: LIST
16772: LIST
16773: LIST
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: LIST
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: ST_TO_ADDR
16791: GO 16794
16793: POP
// if state > - 1 and state < 3 then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 1
16801: NEG
16802: GREATER
16803: PUSH
16804: LD_VAR 0 3
16808: PUSH
16809: LD_INT 3
16811: LESS
16812: AND
16813: IFFALSE 16870
// for i in result do
16815: LD_ADDR_VAR 0 5
16819: PUSH
16820: LD_VAR 0 4
16824: PUSH
16825: FOR_IN
16826: IFFALSE 16868
// if GetTech ( i , side ) <> state then
16828: LD_VAR 0 5
16832: PPUSH
16833: LD_VAR 0 1
16837: PPUSH
16838: CALL_OW 321
16842: PUSH
16843: LD_VAR 0 3
16847: NONEQUAL
16848: IFFALSE 16866
// result := result diff i ;
16850: LD_ADDR_VAR 0 4
16854: PUSH
16855: LD_VAR 0 4
16859: PUSH
16860: LD_VAR 0 5
16864: DIFF
16865: ST_TO_ADDR
16866: GO 16825
16868: POP
16869: POP
// end ;
16870: LD_VAR 0 4
16874: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
16875: LD_INT 0
16877: PPUSH
16878: PPUSH
16879: PPUSH
// result := true ;
16880: LD_ADDR_VAR 0 3
16884: PUSH
16885: LD_INT 1
16887: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
16888: LD_ADDR_VAR 0 5
16892: PUSH
16893: LD_VAR 0 2
16897: PPUSH
16898: CALL_OW 480
16902: ST_TO_ADDR
// if not tmp then
16903: LD_VAR 0 5
16907: NOT
16908: IFFALSE 16912
// exit ;
16910: GO 16961
// for i in tmp do
16912: LD_ADDR_VAR 0 4
16916: PUSH
16917: LD_VAR 0 5
16921: PUSH
16922: FOR_IN
16923: IFFALSE 16959
// if GetTech ( i , side ) <> state_researched then
16925: LD_VAR 0 4
16929: PPUSH
16930: LD_VAR 0 1
16934: PPUSH
16935: CALL_OW 321
16939: PUSH
16940: LD_INT 2
16942: NONEQUAL
16943: IFFALSE 16957
// begin result := false ;
16945: LD_ADDR_VAR 0 3
16949: PUSH
16950: LD_INT 0
16952: ST_TO_ADDR
// exit ;
16953: POP
16954: POP
16955: GO 16961
// end ;
16957: GO 16922
16959: POP
16960: POP
// end ;
16961: LD_VAR 0 3
16965: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
16966: LD_INT 0
16968: PPUSH
16969: PPUSH
16970: PPUSH
16971: PPUSH
16972: PPUSH
16973: PPUSH
16974: PPUSH
16975: PPUSH
16976: PPUSH
16977: PPUSH
16978: PPUSH
16979: PPUSH
16980: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
16981: LD_VAR 0 1
16985: NOT
16986: PUSH
16987: LD_VAR 0 1
16991: PPUSH
16992: CALL_OW 257
16996: PUSH
16997: LD_INT 9
16999: NONEQUAL
17000: OR
17001: IFFALSE 17005
// exit ;
17003: GO 17578
// side := GetSide ( unit ) ;
17005: LD_ADDR_VAR 0 9
17009: PUSH
17010: LD_VAR 0 1
17014: PPUSH
17015: CALL_OW 255
17019: ST_TO_ADDR
// tech_space := tech_spacanom ;
17020: LD_ADDR_VAR 0 12
17024: PUSH
17025: LD_INT 29
17027: ST_TO_ADDR
// tech_time := tech_taurad ;
17028: LD_ADDR_VAR 0 13
17032: PUSH
17033: LD_INT 28
17035: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
17036: LD_ADDR_VAR 0 11
17040: PUSH
17041: LD_VAR 0 1
17045: PPUSH
17046: CALL_OW 310
17050: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
17051: LD_VAR 0 11
17055: PPUSH
17056: CALL_OW 247
17060: PUSH
17061: LD_INT 2
17063: EQUAL
17064: IFFALSE 17068
// exit ;
17066: GO 17578
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17068: LD_ADDR_VAR 0 8
17072: PUSH
17073: LD_INT 81
17075: PUSH
17076: LD_VAR 0 9
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: LD_INT 3
17087: PUSH
17088: LD_INT 21
17090: PUSH
17091: LD_INT 3
17093: PUSH
17094: EMPTY
17095: LIST
17096: LIST
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PPUSH
17106: CALL_OW 69
17110: ST_TO_ADDR
// if not tmp then
17111: LD_VAR 0 8
17115: NOT
17116: IFFALSE 17120
// exit ;
17118: GO 17578
// if in_unit then
17120: LD_VAR 0 11
17124: IFFALSE 17148
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
17126: LD_ADDR_VAR 0 10
17130: PUSH
17131: LD_VAR 0 8
17135: PPUSH
17136: LD_VAR 0 11
17140: PPUSH
17141: CALL_OW 74
17145: ST_TO_ADDR
17146: GO 17168
// enemy := NearestUnitToUnit ( tmp , unit ) ;
17148: LD_ADDR_VAR 0 10
17152: PUSH
17153: LD_VAR 0 8
17157: PPUSH
17158: LD_VAR 0 1
17162: PPUSH
17163: CALL_OW 74
17167: ST_TO_ADDR
// if not enemy then
17168: LD_VAR 0 10
17172: NOT
17173: IFFALSE 17177
// exit ;
17175: GO 17578
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
17177: LD_VAR 0 11
17181: PUSH
17182: LD_VAR 0 11
17186: PPUSH
17187: LD_VAR 0 10
17191: PPUSH
17192: CALL_OW 296
17196: PUSH
17197: LD_INT 13
17199: GREATER
17200: AND
17201: PUSH
17202: LD_VAR 0 1
17206: PPUSH
17207: LD_VAR 0 10
17211: PPUSH
17212: CALL_OW 296
17216: PUSH
17217: LD_INT 12
17219: GREATER
17220: OR
17221: IFFALSE 17225
// exit ;
17223: GO 17578
// missile := [ 1 ] ;
17225: LD_ADDR_VAR 0 14
17229: PUSH
17230: LD_INT 1
17232: PUSH
17233: EMPTY
17234: LIST
17235: ST_TO_ADDR
// if Researched ( side , tech_space ) then
17236: LD_VAR 0 9
17240: PPUSH
17241: LD_VAR 0 12
17245: PPUSH
17246: CALL_OW 325
17250: IFFALSE 17279
// missile := Replace ( missile , missile + 1 , 2 ) ;
17252: LD_ADDR_VAR 0 14
17256: PUSH
17257: LD_VAR 0 14
17261: PPUSH
17262: LD_VAR 0 14
17266: PUSH
17267: LD_INT 1
17269: PLUS
17270: PPUSH
17271: LD_INT 2
17273: PPUSH
17274: CALL_OW 1
17278: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
17279: LD_VAR 0 9
17283: PPUSH
17284: LD_VAR 0 13
17288: PPUSH
17289: CALL_OW 325
17293: PUSH
17294: LD_VAR 0 10
17298: PPUSH
17299: CALL_OW 255
17303: PPUSH
17304: LD_VAR 0 13
17308: PPUSH
17309: CALL_OW 325
17313: NOT
17314: AND
17315: IFFALSE 17344
// missile := Replace ( missile , missile + 1 , 3 ) ;
17317: LD_ADDR_VAR 0 14
17321: PUSH
17322: LD_VAR 0 14
17326: PPUSH
17327: LD_VAR 0 14
17331: PUSH
17332: LD_INT 1
17334: PLUS
17335: PPUSH
17336: LD_INT 3
17338: PPUSH
17339: CALL_OW 1
17343: ST_TO_ADDR
// if missile < 2 then
17344: LD_VAR 0 14
17348: PUSH
17349: LD_INT 2
17351: LESS
17352: IFFALSE 17356
// exit ;
17354: GO 17578
// x := GetX ( enemy ) ;
17356: LD_ADDR_VAR 0 4
17360: PUSH
17361: LD_VAR 0 10
17365: PPUSH
17366: CALL_OW 250
17370: ST_TO_ADDR
// y := GetY ( enemy ) ;
17371: LD_ADDR_VAR 0 5
17375: PUSH
17376: LD_VAR 0 10
17380: PPUSH
17381: CALL_OW 251
17385: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
17386: LD_ADDR_VAR 0 6
17390: PUSH
17391: LD_VAR 0 4
17395: PUSH
17396: LD_INT 1
17398: NEG
17399: PPUSH
17400: LD_INT 1
17402: PPUSH
17403: CALL_OW 12
17407: PLUS
17408: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
17409: LD_ADDR_VAR 0 7
17413: PUSH
17414: LD_VAR 0 5
17418: PUSH
17419: LD_INT 1
17421: NEG
17422: PPUSH
17423: LD_INT 1
17425: PPUSH
17426: CALL_OW 12
17430: PLUS
17431: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17432: LD_VAR 0 6
17436: PPUSH
17437: LD_VAR 0 7
17441: PPUSH
17442: CALL_OW 488
17446: NOT
17447: IFFALSE 17469
// begin _x := x ;
17449: LD_ADDR_VAR 0 6
17453: PUSH
17454: LD_VAR 0 4
17458: ST_TO_ADDR
// _y := y ;
17459: LD_ADDR_VAR 0 7
17463: PUSH
17464: LD_VAR 0 5
17468: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
17469: LD_ADDR_VAR 0 3
17473: PUSH
17474: LD_INT 1
17476: PPUSH
17477: LD_VAR 0 14
17481: PPUSH
17482: CALL_OW 12
17486: ST_TO_ADDR
// case i of 1 :
17487: LD_VAR 0 3
17491: PUSH
17492: LD_INT 1
17494: DOUBLE
17495: EQUAL
17496: IFTRUE 17500
17498: GO 17517
17500: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
17501: LD_VAR 0 1
17505: PPUSH
17506: LD_VAR 0 10
17510: PPUSH
17511: CALL_OW 115
17515: GO 17578
17517: LD_INT 2
17519: DOUBLE
17520: EQUAL
17521: IFTRUE 17525
17523: GO 17547
17525: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17526: LD_VAR 0 1
17530: PPUSH
17531: LD_VAR 0 6
17535: PPUSH
17536: LD_VAR 0 7
17540: PPUSH
17541: CALL_OW 153
17545: GO 17578
17547: LD_INT 3
17549: DOUBLE
17550: EQUAL
17551: IFTRUE 17555
17553: GO 17577
17555: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17556: LD_VAR 0 1
17560: PPUSH
17561: LD_VAR 0 6
17565: PPUSH
17566: LD_VAR 0 7
17570: PPUSH
17571: CALL_OW 154
17575: GO 17578
17577: POP
// end ;
17578: LD_VAR 0 2
17582: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17583: LD_INT 0
17585: PPUSH
17586: PPUSH
17587: PPUSH
17588: PPUSH
17589: PPUSH
17590: PPUSH
// if not unit or not building then
17591: LD_VAR 0 1
17595: NOT
17596: PUSH
17597: LD_VAR 0 2
17601: NOT
17602: OR
17603: IFFALSE 17607
// exit ;
17605: GO 17765
// x := GetX ( building ) ;
17607: LD_ADDR_VAR 0 5
17611: PUSH
17612: LD_VAR 0 2
17616: PPUSH
17617: CALL_OW 250
17621: ST_TO_ADDR
// y := GetY ( building ) ;
17622: LD_ADDR_VAR 0 6
17626: PUSH
17627: LD_VAR 0 2
17631: PPUSH
17632: CALL_OW 251
17636: ST_TO_ADDR
// for i = 0 to 5 do
17637: LD_ADDR_VAR 0 4
17641: PUSH
17642: DOUBLE
17643: LD_INT 0
17645: DEC
17646: ST_TO_ADDR
17647: LD_INT 5
17649: PUSH
17650: FOR_TO
17651: IFFALSE 17763
// begin _x := ShiftX ( x , i , 3 ) ;
17653: LD_ADDR_VAR 0 7
17657: PUSH
17658: LD_VAR 0 5
17662: PPUSH
17663: LD_VAR 0 4
17667: PPUSH
17668: LD_INT 3
17670: PPUSH
17671: CALL_OW 272
17675: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
17676: LD_ADDR_VAR 0 8
17680: PUSH
17681: LD_VAR 0 6
17685: PPUSH
17686: LD_VAR 0 4
17690: PPUSH
17691: LD_INT 3
17693: PPUSH
17694: CALL_OW 273
17698: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17699: LD_VAR 0 7
17703: PPUSH
17704: LD_VAR 0 8
17708: PPUSH
17709: CALL_OW 488
17713: NOT
17714: IFFALSE 17718
// continue ;
17716: GO 17650
// if HexInfo ( _x , _y ) = 0 then
17718: LD_VAR 0 7
17722: PPUSH
17723: LD_VAR 0 8
17727: PPUSH
17728: CALL_OW 428
17732: PUSH
17733: LD_INT 0
17735: EQUAL
17736: IFFALSE 17761
// begin ComMoveXY ( unit , _x , _y ) ;
17738: LD_VAR 0 1
17742: PPUSH
17743: LD_VAR 0 7
17747: PPUSH
17748: LD_VAR 0 8
17752: PPUSH
17753: CALL_OW 111
// exit ;
17757: POP
17758: POP
17759: GO 17765
// end ; end ;
17761: GO 17650
17763: POP
17764: POP
// end ;
17765: LD_VAR 0 3
17769: RET
// export function ScanBase ( side , base_area ) ; begin
17770: LD_INT 0
17772: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_VAR 0 2
17782: PPUSH
17783: LD_INT 81
17785: PUSH
17786: LD_VAR 0 1
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: PPUSH
17795: CALL_OW 70
17799: ST_TO_ADDR
// end ;
17800: LD_VAR 0 3
17804: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17805: LD_INT 0
17807: PPUSH
17808: PPUSH
17809: PPUSH
17810: PPUSH
// result := false ;
17811: LD_ADDR_VAR 0 2
17815: PUSH
17816: LD_INT 0
17818: ST_TO_ADDR
// side := GetSide ( unit ) ;
17819: LD_ADDR_VAR 0 3
17823: PUSH
17824: LD_VAR 0 1
17828: PPUSH
17829: CALL_OW 255
17833: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17834: LD_ADDR_VAR 0 4
17838: PUSH
17839: LD_VAR 0 1
17843: PPUSH
17844: CALL_OW 248
17848: ST_TO_ADDR
// case nat of 1 :
17849: LD_VAR 0 4
17853: PUSH
17854: LD_INT 1
17856: DOUBLE
17857: EQUAL
17858: IFTRUE 17862
17860: GO 17873
17862: POP
// tech := tech_lassight ; 2 :
17863: LD_ADDR_VAR 0 5
17867: PUSH
17868: LD_INT 12
17870: ST_TO_ADDR
17871: GO 17912
17873: LD_INT 2
17875: DOUBLE
17876: EQUAL
17877: IFTRUE 17881
17879: GO 17892
17881: POP
// tech := tech_mortar ; 3 :
17882: LD_ADDR_VAR 0 5
17886: PUSH
17887: LD_INT 41
17889: ST_TO_ADDR
17890: GO 17912
17892: LD_INT 3
17894: DOUBLE
17895: EQUAL
17896: IFTRUE 17900
17898: GO 17911
17900: POP
// tech := tech_bazooka ; end ;
17901: LD_ADDR_VAR 0 5
17905: PUSH
17906: LD_INT 44
17908: ST_TO_ADDR
17909: GO 17912
17911: POP
// if Researched ( side , tech ) then
17912: LD_VAR 0 3
17916: PPUSH
17917: LD_VAR 0 5
17921: PPUSH
17922: CALL_OW 325
17926: IFFALSE 17953
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17928: LD_ADDR_VAR 0 2
17932: PUSH
17933: LD_INT 5
17935: PUSH
17936: LD_INT 8
17938: PUSH
17939: LD_INT 9
17941: PUSH
17942: EMPTY
17943: LIST
17944: LIST
17945: LIST
17946: PUSH
17947: LD_VAR 0 4
17951: ARRAY
17952: ST_TO_ADDR
// end ;
17953: LD_VAR 0 2
17957: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17958: LD_INT 0
17960: PPUSH
17961: PPUSH
17962: PPUSH
// if not mines then
17963: LD_VAR 0 2
17967: NOT
17968: IFFALSE 17972
// exit ;
17970: GO 18116
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17972: LD_ADDR_VAR 0 5
17976: PUSH
17977: LD_INT 81
17979: PUSH
17980: LD_VAR 0 1
17984: PUSH
17985: EMPTY
17986: LIST
17987: LIST
17988: PUSH
17989: LD_INT 3
17991: PUSH
17992: LD_INT 21
17994: PUSH
17995: LD_INT 3
17997: PUSH
17998: EMPTY
17999: LIST
18000: LIST
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PPUSH
18010: CALL_OW 69
18014: ST_TO_ADDR
// for i in mines do
18015: LD_ADDR_VAR 0 4
18019: PUSH
18020: LD_VAR 0 2
18024: PUSH
18025: FOR_IN
18026: IFFALSE 18114
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18028: LD_VAR 0 4
18032: PUSH
18033: LD_INT 1
18035: ARRAY
18036: PPUSH
18037: LD_VAR 0 4
18041: PUSH
18042: LD_INT 2
18044: ARRAY
18045: PPUSH
18046: CALL_OW 458
18050: NOT
18051: IFFALSE 18055
// continue ;
18053: GO 18025
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18055: LD_VAR 0 4
18059: PUSH
18060: LD_INT 1
18062: ARRAY
18063: PPUSH
18064: LD_VAR 0 4
18068: PUSH
18069: LD_INT 2
18071: ARRAY
18072: PPUSH
18073: CALL_OW 428
18077: PUSH
18078: LD_VAR 0 5
18082: IN
18083: IFFALSE 18112
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18085: LD_VAR 0 4
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PPUSH
18094: LD_VAR 0 4
18098: PUSH
18099: LD_INT 2
18101: ARRAY
18102: PPUSH
18103: LD_VAR 0 1
18107: PPUSH
18108: CALL_OW 456
// end ;
18112: GO 18025
18114: POP
18115: POP
// end ;
18116: LD_VAR 0 3
18120: RET
// export function Count ( array ) ; begin
18121: LD_INT 0
18123: PPUSH
// result := array + 0 ;
18124: LD_ADDR_VAR 0 2
18128: PUSH
18129: LD_VAR 0 1
18133: PUSH
18134: LD_INT 0
18136: PLUS
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function IsEmpty ( building ) ; begin
18143: LD_INT 0
18145: PPUSH
// if not building then
18146: LD_VAR 0 1
18150: NOT
18151: IFFALSE 18155
// exit ;
18153: GO 18198
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18155: LD_ADDR_VAR 0 2
18159: PUSH
18160: LD_VAR 0 1
18164: PUSH
18165: LD_INT 22
18167: PUSH
18168: LD_VAR 0 1
18172: PPUSH
18173: CALL_OW 255
18177: PUSH
18178: EMPTY
18179: LIST
18180: LIST
18181: PUSH
18182: LD_INT 58
18184: PUSH
18185: EMPTY
18186: LIST
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PPUSH
18192: CALL_OW 69
18196: IN
18197: ST_TO_ADDR
// end ;
18198: LD_VAR 0 2
18202: RET
// export function IsNotFull ( building ) ; var places ; begin
18203: LD_INT 0
18205: PPUSH
18206: PPUSH
// if not building then
18207: LD_VAR 0 1
18211: NOT
18212: IFFALSE 18216
// exit ;
18214: GO 18244
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
18216: LD_ADDR_VAR 0 2
18220: PUSH
18221: LD_VAR 0 1
18225: PPUSH
18226: LD_INT 3
18228: PUSH
18229: LD_INT 62
18231: PUSH
18232: EMPTY
18233: LIST
18234: PUSH
18235: EMPTY
18236: LIST
18237: LIST
18238: PPUSH
18239: CALL_OW 72
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18249: LD_INT 0
18251: PPUSH
18252: PPUSH
18253: PPUSH
18254: PPUSH
// tmp := [ ] ;
18255: LD_ADDR_VAR 0 3
18259: PUSH
18260: EMPTY
18261: ST_TO_ADDR
// list := [ ] ;
18262: LD_ADDR_VAR 0 5
18266: PUSH
18267: EMPTY
18268: ST_TO_ADDR
// for i = 16 to 25 do
18269: LD_ADDR_VAR 0 4
18273: PUSH
18274: DOUBLE
18275: LD_INT 16
18277: DEC
18278: ST_TO_ADDR
18279: LD_INT 25
18281: PUSH
18282: FOR_TO
18283: IFFALSE 18356
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18285: LD_ADDR_VAR 0 3
18289: PUSH
18290: LD_VAR 0 3
18294: PUSH
18295: LD_INT 22
18297: PUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 255
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: PUSH
18312: LD_INT 91
18314: PUSH
18315: LD_VAR 0 1
18319: PUSH
18320: LD_INT 6
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: PUSH
18328: LD_INT 30
18330: PUSH
18331: LD_VAR 0 4
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: LIST
18344: PUSH
18345: EMPTY
18346: LIST
18347: PPUSH
18348: CALL_OW 69
18352: ADD
18353: ST_TO_ADDR
18354: GO 18282
18356: POP
18357: POP
// for i = 1 to tmp do
18358: LD_ADDR_VAR 0 4
18362: PUSH
18363: DOUBLE
18364: LD_INT 1
18366: DEC
18367: ST_TO_ADDR
18368: LD_VAR 0 3
18372: PUSH
18373: FOR_TO
18374: IFFALSE 18462
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18376: LD_ADDR_VAR 0 5
18380: PUSH
18381: LD_VAR 0 5
18385: PUSH
18386: LD_VAR 0 3
18390: PUSH
18391: LD_VAR 0 4
18395: ARRAY
18396: PPUSH
18397: CALL_OW 266
18401: PUSH
18402: LD_VAR 0 3
18406: PUSH
18407: LD_VAR 0 4
18411: ARRAY
18412: PPUSH
18413: CALL_OW 250
18417: PUSH
18418: LD_VAR 0 3
18422: PUSH
18423: LD_VAR 0 4
18427: ARRAY
18428: PPUSH
18429: CALL_OW 251
18433: PUSH
18434: LD_VAR 0 3
18438: PUSH
18439: LD_VAR 0 4
18443: ARRAY
18444: PPUSH
18445: CALL_OW 254
18449: PUSH
18450: EMPTY
18451: LIST
18452: LIST
18453: LIST
18454: LIST
18455: PUSH
18456: EMPTY
18457: LIST
18458: ADD
18459: ST_TO_ADDR
18460: GO 18373
18462: POP
18463: POP
// result := list ;
18464: LD_ADDR_VAR 0 2
18468: PUSH
18469: LD_VAR 0 5
18473: ST_TO_ADDR
// end ;
18474: LD_VAR 0 2
18478: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18479: LD_INT 0
18481: PPUSH
18482: PPUSH
18483: PPUSH
18484: PPUSH
18485: PPUSH
18486: PPUSH
18487: PPUSH
// if not factory then
18488: LD_VAR 0 1
18492: NOT
18493: IFFALSE 18497
// exit ;
18495: GO 19090
// if control = control_apeman then
18497: LD_VAR 0 4
18501: PUSH
18502: LD_INT 5
18504: EQUAL
18505: IFFALSE 18614
// begin tmp := UnitsInside ( factory ) ;
18507: LD_ADDR_VAR 0 8
18511: PUSH
18512: LD_VAR 0 1
18516: PPUSH
18517: CALL_OW 313
18521: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18522: LD_VAR 0 8
18526: PPUSH
18527: LD_INT 25
18529: PUSH
18530: LD_INT 12
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: PPUSH
18537: CALL_OW 72
18541: NOT
18542: IFFALSE 18552
// control := control_manual ;
18544: LD_ADDR_VAR 0 4
18548: PUSH
18549: LD_INT 1
18551: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18552: LD_ADDR_VAR 0 8
18556: PUSH
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 18249 0 1
18566: ST_TO_ADDR
// if tmp then
18567: LD_VAR 0 8
18571: IFFALSE 18614
// begin for i in tmp do
18573: LD_ADDR_VAR 0 7
18577: PUSH
18578: LD_VAR 0 8
18582: PUSH
18583: FOR_IN
18584: IFFALSE 18612
// if i [ 1 ] = b_ext_radio then
18586: LD_VAR 0 7
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PUSH
18595: LD_INT 22
18597: EQUAL
18598: IFFALSE 18610
// begin control := control_remote ;
18600: LD_ADDR_VAR 0 4
18604: PUSH
18605: LD_INT 2
18607: ST_TO_ADDR
// break ;
18608: GO 18612
// end ;
18610: GO 18583
18612: POP
18613: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18614: LD_VAR 0 1
18618: PPUSH
18619: LD_VAR 0 2
18623: PPUSH
18624: LD_VAR 0 3
18628: PPUSH
18629: LD_VAR 0 4
18633: PPUSH
18634: LD_VAR 0 5
18638: PPUSH
18639: CALL_OW 448
18643: IFFALSE 18678
// begin result := [ chassis , engine , control , weapon ] ;
18645: LD_ADDR_VAR 0 6
18649: PUSH
18650: LD_VAR 0 2
18654: PUSH
18655: LD_VAR 0 3
18659: PUSH
18660: LD_VAR 0 4
18664: PUSH
18665: LD_VAR 0 5
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
// exit ;
18676: GO 19090
// end ; _chassis := AvailableChassisList ( factory ) ;
18678: LD_ADDR_VAR 0 9
18682: PUSH
18683: LD_VAR 0 1
18687: PPUSH
18688: CALL_OW 475
18692: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18693: LD_ADDR_VAR 0 11
18697: PUSH
18698: LD_VAR 0 1
18702: PPUSH
18703: CALL_OW 476
18707: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18708: LD_ADDR_VAR 0 12
18712: PUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: CALL_OW 477
18722: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18723: LD_ADDR_VAR 0 10
18727: PUSH
18728: LD_VAR 0 1
18732: PPUSH
18733: CALL_OW 478
18737: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18738: LD_VAR 0 9
18742: NOT
18743: PUSH
18744: LD_VAR 0 11
18748: NOT
18749: OR
18750: PUSH
18751: LD_VAR 0 12
18755: NOT
18756: OR
18757: PUSH
18758: LD_VAR 0 10
18762: NOT
18763: OR
18764: IFFALSE 18799
// begin result := [ chassis , engine , control , weapon ] ;
18766: LD_ADDR_VAR 0 6
18770: PUSH
18771: LD_VAR 0 2
18775: PUSH
18776: LD_VAR 0 3
18780: PUSH
18781: LD_VAR 0 4
18785: PUSH
18786: LD_VAR 0 5
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: LIST
18795: LIST
18796: ST_TO_ADDR
// exit ;
18797: GO 19090
// end ; if not chassis in _chassis then
18799: LD_VAR 0 2
18803: PUSH
18804: LD_VAR 0 9
18808: IN
18809: NOT
18810: IFFALSE 18836
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18812: LD_ADDR_VAR 0 2
18816: PUSH
18817: LD_VAR 0 9
18821: PUSH
18822: LD_INT 1
18824: PPUSH
18825: LD_VAR 0 9
18829: PPUSH
18830: CALL_OW 12
18834: ARRAY
18835: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18836: LD_VAR 0 2
18840: PPUSH
18841: LD_VAR 0 3
18845: PPUSH
18846: CALL 19095 0 2
18850: NOT
18851: IFFALSE 18910
// repeat engine := _engine [ 1 ] ;
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_VAR 0 11
18862: PUSH
18863: LD_INT 1
18865: ARRAY
18866: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18867: LD_ADDR_VAR 0 11
18871: PUSH
18872: LD_VAR 0 11
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL_OW 3
18884: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18885: LD_VAR 0 2
18889: PPUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: CALL 19095 0 2
18899: PUSH
18900: LD_VAR 0 11
18904: PUSH
18905: EMPTY
18906: EQUAL
18907: OR
18908: IFFALSE 18853
// if not control in _control then
18910: LD_VAR 0 4
18914: PUSH
18915: LD_VAR 0 12
18919: IN
18920: NOT
18921: IFFALSE 18947
// control := _control [ rand ( 1 , _control ) ] ;
18923: LD_ADDR_VAR 0 4
18927: PUSH
18928: LD_VAR 0 12
18932: PUSH
18933: LD_INT 1
18935: PPUSH
18936: LD_VAR 0 12
18940: PPUSH
18941: CALL_OW 12
18945: ARRAY
18946: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18947: LD_VAR 0 2
18951: PPUSH
18952: LD_VAR 0 5
18956: PPUSH
18957: CALL 19315 0 2
18961: NOT
18962: IFFALSE 19021
// repeat weapon := _weapon [ 1 ] ;
18964: LD_ADDR_VAR 0 5
18968: PUSH
18969: LD_VAR 0 10
18973: PUSH
18974: LD_INT 1
18976: ARRAY
18977: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18978: LD_ADDR_VAR 0 10
18982: PUSH
18983: LD_VAR 0 10
18987: PPUSH
18988: LD_INT 1
18990: PPUSH
18991: CALL_OW 3
18995: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18996: LD_VAR 0 2
19000: PPUSH
19001: LD_VAR 0 5
19005: PPUSH
19006: CALL 19315 0 2
19010: PUSH
19011: LD_VAR 0 10
19015: PUSH
19016: EMPTY
19017: EQUAL
19018: OR
19019: IFFALSE 18964
// result := [ ] ;
19021: LD_ADDR_VAR 0 6
19025: PUSH
19026: EMPTY
19027: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19028: LD_VAR 0 1
19032: PPUSH
19033: LD_VAR 0 2
19037: PPUSH
19038: LD_VAR 0 3
19042: PPUSH
19043: LD_VAR 0 4
19047: PPUSH
19048: LD_VAR 0 5
19052: PPUSH
19053: CALL_OW 448
19057: IFFALSE 19090
// result := [ chassis , engine , control , weapon ] ;
19059: LD_ADDR_VAR 0 6
19063: PUSH
19064: LD_VAR 0 2
19068: PUSH
19069: LD_VAR 0 3
19073: PUSH
19074: LD_VAR 0 4
19078: PUSH
19079: LD_VAR 0 5
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: ST_TO_ADDR
// end ;
19090: LD_VAR 0 6
19094: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19095: LD_INT 0
19097: PPUSH
// if not chassis or not engine then
19098: LD_VAR 0 1
19102: NOT
19103: PUSH
19104: LD_VAR 0 2
19108: NOT
19109: OR
19110: IFFALSE 19114
// exit ;
19112: GO 19310
// case engine of engine_solar :
19114: LD_VAR 0 2
19118: PUSH
19119: LD_INT 2
19121: DOUBLE
19122: EQUAL
19123: IFTRUE 19127
19125: GO 19165
19127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19128: LD_ADDR_VAR 0 3
19132: PUSH
19133: LD_INT 11
19135: PUSH
19136: LD_INT 12
19138: PUSH
19139: LD_INT 13
19141: PUSH
19142: LD_INT 14
19144: PUSH
19145: LD_INT 1
19147: PUSH
19148: LD_INT 2
19150: PUSH
19151: LD_INT 3
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: LIST
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: ST_TO_ADDR
19163: GO 19294
19165: LD_INT 1
19167: DOUBLE
19168: EQUAL
19169: IFTRUE 19173
19171: GO 19235
19173: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19174: LD_ADDR_VAR 0 3
19178: PUSH
19179: LD_INT 11
19181: PUSH
19182: LD_INT 12
19184: PUSH
19185: LD_INT 13
19187: PUSH
19188: LD_INT 14
19190: PUSH
19191: LD_INT 1
19193: PUSH
19194: LD_INT 2
19196: PUSH
19197: LD_INT 3
19199: PUSH
19200: LD_INT 4
19202: PUSH
19203: LD_INT 5
19205: PUSH
19206: LD_INT 21
19208: PUSH
19209: LD_INT 23
19211: PUSH
19212: LD_INT 22
19214: PUSH
19215: LD_INT 24
19217: PUSH
19218: EMPTY
19219: LIST
19220: LIST
19221: LIST
19222: LIST
19223: LIST
19224: LIST
19225: LIST
19226: LIST
19227: LIST
19228: LIST
19229: LIST
19230: LIST
19231: LIST
19232: ST_TO_ADDR
19233: GO 19294
19235: LD_INT 3
19237: DOUBLE
19238: EQUAL
19239: IFTRUE 19243
19241: GO 19293
19243: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19244: LD_ADDR_VAR 0 3
19248: PUSH
19249: LD_INT 13
19251: PUSH
19252: LD_INT 14
19254: PUSH
19255: LD_INT 2
19257: PUSH
19258: LD_INT 3
19260: PUSH
19261: LD_INT 4
19263: PUSH
19264: LD_INT 5
19266: PUSH
19267: LD_INT 21
19269: PUSH
19270: LD_INT 22
19272: PUSH
19273: LD_INT 23
19275: PUSH
19276: LD_INT 24
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: LIST
19283: LIST
19284: LIST
19285: LIST
19286: LIST
19287: LIST
19288: LIST
19289: LIST
19290: ST_TO_ADDR
19291: GO 19294
19293: POP
// result := ( chassis in result ) ;
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_VAR 0 1
19303: PUSH
19304: LD_VAR 0 3
19308: IN
19309: ST_TO_ADDR
// end ;
19310: LD_VAR 0 3
19314: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19315: LD_INT 0
19317: PPUSH
// if not chassis or not weapon then
19318: LD_VAR 0 1
19322: NOT
19323: PUSH
19324: LD_VAR 0 2
19328: NOT
19329: OR
19330: IFFALSE 19334
// exit ;
19332: GO 20394
// case weapon of us_machine_gun :
19334: LD_VAR 0 2
19338: PUSH
19339: LD_INT 2
19341: DOUBLE
19342: EQUAL
19343: IFTRUE 19347
19345: GO 19377
19347: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19348: LD_ADDR_VAR 0 3
19352: PUSH
19353: LD_INT 1
19355: PUSH
19356: LD_INT 2
19358: PUSH
19359: LD_INT 3
19361: PUSH
19362: LD_INT 4
19364: PUSH
19365: LD_INT 5
19367: PUSH
19368: EMPTY
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: LIST
19374: ST_TO_ADDR
19375: GO 20378
19377: LD_INT 3
19379: DOUBLE
19380: EQUAL
19381: IFTRUE 19385
19383: GO 19415
19385: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19386: LD_ADDR_VAR 0 3
19390: PUSH
19391: LD_INT 1
19393: PUSH
19394: LD_INT 2
19396: PUSH
19397: LD_INT 3
19399: PUSH
19400: LD_INT 4
19402: PUSH
19403: LD_INT 5
19405: PUSH
19406: EMPTY
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: LIST
19412: ST_TO_ADDR
19413: GO 20378
19415: LD_INT 11
19417: DOUBLE
19418: EQUAL
19419: IFTRUE 19423
19421: GO 19453
19423: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19424: LD_ADDR_VAR 0 3
19428: PUSH
19429: LD_INT 1
19431: PUSH
19432: LD_INT 2
19434: PUSH
19435: LD_INT 3
19437: PUSH
19438: LD_INT 4
19440: PUSH
19441: LD_INT 5
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: ST_TO_ADDR
19451: GO 20378
19453: LD_INT 4
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19487
19461: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19462: LD_ADDR_VAR 0 3
19466: PUSH
19467: LD_INT 2
19469: PUSH
19470: LD_INT 3
19472: PUSH
19473: LD_INT 4
19475: PUSH
19476: LD_INT 5
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: ST_TO_ADDR
19485: GO 20378
19487: LD_INT 5
19489: DOUBLE
19490: EQUAL
19491: IFTRUE 19495
19493: GO 19521
19495: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19496: LD_ADDR_VAR 0 3
19500: PUSH
19501: LD_INT 2
19503: PUSH
19504: LD_INT 3
19506: PUSH
19507: LD_INT 4
19509: PUSH
19510: LD_INT 5
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: ST_TO_ADDR
19519: GO 20378
19521: LD_INT 9
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19555
19529: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_INT 2
19537: PUSH
19538: LD_INT 3
19540: PUSH
19541: LD_INT 4
19543: PUSH
19544: LD_INT 5
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 20378
19555: LD_INT 7
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19589
19563: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 2
19571: PUSH
19572: LD_INT 3
19574: PUSH
19575: LD_INT 4
19577: PUSH
19578: LD_INT 5
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: ST_TO_ADDR
19587: GO 20378
19589: LD_INT 12
19591: DOUBLE
19592: EQUAL
19593: IFTRUE 19597
19595: GO 19623
19597: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19598: LD_ADDR_VAR 0 3
19602: PUSH
19603: LD_INT 2
19605: PUSH
19606: LD_INT 3
19608: PUSH
19609: LD_INT 4
19611: PUSH
19612: LD_INT 5
19614: PUSH
19615: EMPTY
19616: LIST
19617: LIST
19618: LIST
19619: LIST
19620: ST_TO_ADDR
19621: GO 20378
19623: LD_INT 13
19625: DOUBLE
19626: EQUAL
19627: IFTRUE 19631
19629: GO 19657
19631: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19632: LD_ADDR_VAR 0 3
19636: PUSH
19637: LD_INT 2
19639: PUSH
19640: LD_INT 3
19642: PUSH
19643: LD_INT 4
19645: PUSH
19646: LD_INT 5
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: LIST
19653: LIST
19654: ST_TO_ADDR
19655: GO 20378
19657: LD_INT 14
19659: DOUBLE
19660: EQUAL
19661: IFTRUE 19665
19663: GO 19683
19665: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19666: LD_ADDR_VAR 0 3
19670: PUSH
19671: LD_INT 4
19673: PUSH
19674: LD_INT 5
19676: PUSH
19677: EMPTY
19678: LIST
19679: LIST
19680: ST_TO_ADDR
19681: GO 20378
19683: LD_INT 6
19685: DOUBLE
19686: EQUAL
19687: IFTRUE 19691
19689: GO 19709
19691: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19692: LD_ADDR_VAR 0 3
19696: PUSH
19697: LD_INT 4
19699: PUSH
19700: LD_INT 5
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: ST_TO_ADDR
19707: GO 20378
19709: LD_INT 10
19711: DOUBLE
19712: EQUAL
19713: IFTRUE 19717
19715: GO 19735
19717: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19718: LD_ADDR_VAR 0 3
19722: PUSH
19723: LD_INT 4
19725: PUSH
19726: LD_INT 5
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: ST_TO_ADDR
19733: GO 20378
19735: LD_INT 22
19737: DOUBLE
19738: EQUAL
19739: IFTRUE 19743
19741: GO 19769
19743: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19744: LD_ADDR_VAR 0 3
19748: PUSH
19749: LD_INT 11
19751: PUSH
19752: LD_INT 12
19754: PUSH
19755: LD_INT 13
19757: PUSH
19758: LD_INT 14
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: ST_TO_ADDR
19767: GO 20378
19769: LD_INT 23
19771: DOUBLE
19772: EQUAL
19773: IFTRUE 19777
19775: GO 19803
19777: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19778: LD_ADDR_VAR 0 3
19782: PUSH
19783: LD_INT 11
19785: PUSH
19786: LD_INT 12
19788: PUSH
19789: LD_INT 13
19791: PUSH
19792: LD_INT 14
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: ST_TO_ADDR
19801: GO 20378
19803: LD_INT 24
19805: DOUBLE
19806: EQUAL
19807: IFTRUE 19811
19809: GO 19837
19811: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19812: LD_ADDR_VAR 0 3
19816: PUSH
19817: LD_INT 11
19819: PUSH
19820: LD_INT 12
19822: PUSH
19823: LD_INT 13
19825: PUSH
19826: LD_INT 14
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: ST_TO_ADDR
19835: GO 20378
19837: LD_INT 30
19839: DOUBLE
19840: EQUAL
19841: IFTRUE 19845
19843: GO 19871
19845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19846: LD_ADDR_VAR 0 3
19850: PUSH
19851: LD_INT 11
19853: PUSH
19854: LD_INT 12
19856: PUSH
19857: LD_INT 13
19859: PUSH
19860: LD_INT 14
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: ST_TO_ADDR
19869: GO 20378
19871: LD_INT 25
19873: DOUBLE
19874: EQUAL
19875: IFTRUE 19879
19877: GO 19897
19879: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19880: LD_ADDR_VAR 0 3
19884: PUSH
19885: LD_INT 13
19887: PUSH
19888: LD_INT 14
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: ST_TO_ADDR
19895: GO 20378
19897: LD_INT 27
19899: DOUBLE
19900: EQUAL
19901: IFTRUE 19905
19903: GO 19923
19905: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19906: LD_ADDR_VAR 0 3
19910: PUSH
19911: LD_INT 13
19913: PUSH
19914: LD_INT 14
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: ST_TO_ADDR
19921: GO 20378
19923: LD_INT 92
19925: DOUBLE
19926: EQUAL
19927: IFTRUE 19931
19929: GO 19957
19931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19932: LD_ADDR_VAR 0 3
19936: PUSH
19937: LD_INT 11
19939: PUSH
19940: LD_INT 12
19942: PUSH
19943: LD_INT 13
19945: PUSH
19946: LD_INT 14
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: ST_TO_ADDR
19955: GO 20378
19957: LD_INT 28
19959: DOUBLE
19960: EQUAL
19961: IFTRUE 19965
19963: GO 19983
19965: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19966: LD_ADDR_VAR 0 3
19970: PUSH
19971: LD_INT 13
19973: PUSH
19974: LD_INT 14
19976: PUSH
19977: EMPTY
19978: LIST
19979: LIST
19980: ST_TO_ADDR
19981: GO 20378
19983: LD_INT 29
19985: DOUBLE
19986: EQUAL
19987: IFTRUE 19991
19989: GO 20009
19991: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19992: LD_ADDR_VAR 0 3
19996: PUSH
19997: LD_INT 13
19999: PUSH
20000: LD_INT 14
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: ST_TO_ADDR
20007: GO 20378
20009: LD_INT 31
20011: DOUBLE
20012: EQUAL
20013: IFTRUE 20017
20015: GO 20035
20017: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_INT 13
20025: PUSH
20026: LD_INT 14
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20378
20035: LD_INT 26
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20061
20043: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 13
20051: PUSH
20052: LD_INT 14
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20378
20061: LD_INT 42
20063: DOUBLE
20064: EQUAL
20065: IFTRUE 20069
20067: GO 20095
20069: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20070: LD_ADDR_VAR 0 3
20074: PUSH
20075: LD_INT 21
20077: PUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 23
20083: PUSH
20084: LD_INT 24
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: ST_TO_ADDR
20093: GO 20378
20095: LD_INT 43
20097: DOUBLE
20098: EQUAL
20099: IFTRUE 20103
20101: GO 20129
20103: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_INT 21
20111: PUSH
20112: LD_INT 22
20114: PUSH
20115: LD_INT 23
20117: PUSH
20118: LD_INT 24
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: ST_TO_ADDR
20127: GO 20378
20129: LD_INT 44
20131: DOUBLE
20132: EQUAL
20133: IFTRUE 20137
20135: GO 20163
20137: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20138: LD_ADDR_VAR 0 3
20142: PUSH
20143: LD_INT 21
20145: PUSH
20146: LD_INT 22
20148: PUSH
20149: LD_INT 23
20151: PUSH
20152: LD_INT 24
20154: PUSH
20155: EMPTY
20156: LIST
20157: LIST
20158: LIST
20159: LIST
20160: ST_TO_ADDR
20161: GO 20378
20163: LD_INT 45
20165: DOUBLE
20166: EQUAL
20167: IFTRUE 20171
20169: GO 20197
20171: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20172: LD_ADDR_VAR 0 3
20176: PUSH
20177: LD_INT 21
20179: PUSH
20180: LD_INT 22
20182: PUSH
20183: LD_INT 23
20185: PUSH
20186: LD_INT 24
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: ST_TO_ADDR
20195: GO 20378
20197: LD_INT 49
20199: DOUBLE
20200: EQUAL
20201: IFTRUE 20205
20203: GO 20231
20205: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20206: LD_ADDR_VAR 0 3
20210: PUSH
20211: LD_INT 21
20213: PUSH
20214: LD_INT 22
20216: PUSH
20217: LD_INT 23
20219: PUSH
20220: LD_INT 24
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: LIST
20228: ST_TO_ADDR
20229: GO 20378
20231: LD_INT 51
20233: DOUBLE
20234: EQUAL
20235: IFTRUE 20239
20237: GO 20265
20239: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20240: LD_ADDR_VAR 0 3
20244: PUSH
20245: LD_INT 21
20247: PUSH
20248: LD_INT 22
20250: PUSH
20251: LD_INT 23
20253: PUSH
20254: LD_INT 24
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: ST_TO_ADDR
20263: GO 20378
20265: LD_INT 52
20267: DOUBLE
20268: EQUAL
20269: IFTRUE 20273
20271: GO 20299
20273: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20274: LD_ADDR_VAR 0 3
20278: PUSH
20279: LD_INT 21
20281: PUSH
20282: LD_INT 22
20284: PUSH
20285: LD_INT 23
20287: PUSH
20288: LD_INT 24
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: ST_TO_ADDR
20297: GO 20378
20299: LD_INT 53
20301: DOUBLE
20302: EQUAL
20303: IFTRUE 20307
20305: GO 20325
20307: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20308: LD_ADDR_VAR 0 3
20312: PUSH
20313: LD_INT 23
20315: PUSH
20316: LD_INT 24
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: ST_TO_ADDR
20323: GO 20378
20325: LD_INT 46
20327: DOUBLE
20328: EQUAL
20329: IFTRUE 20333
20331: GO 20351
20333: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_INT 23
20341: PUSH
20342: LD_INT 24
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: ST_TO_ADDR
20349: GO 20378
20351: LD_INT 47
20353: DOUBLE
20354: EQUAL
20355: IFTRUE 20359
20357: GO 20377
20359: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_INT 23
20367: PUSH
20368: LD_INT 24
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: ST_TO_ADDR
20375: GO 20378
20377: POP
// result := ( chassis in result ) ;
20378: LD_ADDR_VAR 0 3
20382: PUSH
20383: LD_VAR 0 1
20387: PUSH
20388: LD_VAR 0 3
20392: IN
20393: ST_TO_ADDR
// end ;
20394: LD_VAR 0 3
20398: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20399: LD_INT 0
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
20405: PPUSH
20406: PPUSH
20407: PPUSH
// result := array ;
20408: LD_ADDR_VAR 0 5
20412: PUSH
20413: LD_VAR 0 1
20417: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20418: LD_VAR 0 1
20422: NOT
20423: PUSH
20424: LD_VAR 0 2
20428: NOT
20429: OR
20430: PUSH
20431: LD_VAR 0 3
20435: NOT
20436: OR
20437: PUSH
20438: LD_VAR 0 2
20442: PUSH
20443: LD_VAR 0 1
20447: GREATER
20448: OR
20449: PUSH
20450: LD_VAR 0 3
20454: PUSH
20455: LD_VAR 0 1
20459: GREATER
20460: OR
20461: IFFALSE 20465
// exit ;
20463: GO 20761
// if direction then
20465: LD_VAR 0 4
20469: IFFALSE 20533
// begin d := 1 ;
20471: LD_ADDR_VAR 0 9
20475: PUSH
20476: LD_INT 1
20478: ST_TO_ADDR
// if i_from > i_to then
20479: LD_VAR 0 2
20483: PUSH
20484: LD_VAR 0 3
20488: GREATER
20489: IFFALSE 20515
// length := ( array - i_from ) + i_to else
20491: LD_ADDR_VAR 0 11
20495: PUSH
20496: LD_VAR 0 1
20500: PUSH
20501: LD_VAR 0 2
20505: MINUS
20506: PUSH
20507: LD_VAR 0 3
20511: PLUS
20512: ST_TO_ADDR
20513: GO 20531
// length := i_to - i_from ;
20515: LD_ADDR_VAR 0 11
20519: PUSH
20520: LD_VAR 0 3
20524: PUSH
20525: LD_VAR 0 2
20529: MINUS
20530: ST_TO_ADDR
// end else
20531: GO 20594
// begin d := - 1 ;
20533: LD_ADDR_VAR 0 9
20537: PUSH
20538: LD_INT 1
20540: NEG
20541: ST_TO_ADDR
// if i_from > i_to then
20542: LD_VAR 0 2
20546: PUSH
20547: LD_VAR 0 3
20551: GREATER
20552: IFFALSE 20572
// length := i_from - i_to else
20554: LD_ADDR_VAR 0 11
20558: PUSH
20559: LD_VAR 0 2
20563: PUSH
20564: LD_VAR 0 3
20568: MINUS
20569: ST_TO_ADDR
20570: GO 20594
// length := ( array - i_to ) + i_from ;
20572: LD_ADDR_VAR 0 11
20576: PUSH
20577: LD_VAR 0 1
20581: PUSH
20582: LD_VAR 0 3
20586: MINUS
20587: PUSH
20588: LD_VAR 0 2
20592: PLUS
20593: ST_TO_ADDR
// end ; if not length then
20594: LD_VAR 0 11
20598: NOT
20599: IFFALSE 20603
// exit ;
20601: GO 20761
// tmp := array ;
20603: LD_ADDR_VAR 0 10
20607: PUSH
20608: LD_VAR 0 1
20612: ST_TO_ADDR
// for i = 1 to length do
20613: LD_ADDR_VAR 0 6
20617: PUSH
20618: DOUBLE
20619: LD_INT 1
20621: DEC
20622: ST_TO_ADDR
20623: LD_VAR 0 11
20627: PUSH
20628: FOR_TO
20629: IFFALSE 20749
// begin for j = 1 to array do
20631: LD_ADDR_VAR 0 7
20635: PUSH
20636: DOUBLE
20637: LD_INT 1
20639: DEC
20640: ST_TO_ADDR
20641: LD_VAR 0 1
20645: PUSH
20646: FOR_TO
20647: IFFALSE 20735
// begin k := j + d ;
20649: LD_ADDR_VAR 0 8
20653: PUSH
20654: LD_VAR 0 7
20658: PUSH
20659: LD_VAR 0 9
20663: PLUS
20664: ST_TO_ADDR
// if k > array then
20665: LD_VAR 0 8
20669: PUSH
20670: LD_VAR 0 1
20674: GREATER
20675: IFFALSE 20685
// k := 1 ;
20677: LD_ADDR_VAR 0 8
20681: PUSH
20682: LD_INT 1
20684: ST_TO_ADDR
// if not k then
20685: LD_VAR 0 8
20689: NOT
20690: IFFALSE 20702
// k := array ;
20692: LD_ADDR_VAR 0 8
20696: PUSH
20697: LD_VAR 0 1
20701: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20702: LD_ADDR_VAR 0 10
20706: PUSH
20707: LD_VAR 0 10
20711: PPUSH
20712: LD_VAR 0 8
20716: PPUSH
20717: LD_VAR 0 1
20721: PUSH
20722: LD_VAR 0 7
20726: ARRAY
20727: PPUSH
20728: CALL_OW 1
20732: ST_TO_ADDR
// end ;
20733: GO 20646
20735: POP
20736: POP
// array := tmp ;
20737: LD_ADDR_VAR 0 1
20741: PUSH
20742: LD_VAR 0 10
20746: ST_TO_ADDR
// end ;
20747: GO 20628
20749: POP
20750: POP
// result := array ;
20751: LD_ADDR_VAR 0 5
20755: PUSH
20756: LD_VAR 0 1
20760: ST_TO_ADDR
// end ;
20761: LD_VAR 0 5
20765: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20766: LD_INT 0
20768: PPUSH
20769: PPUSH
// result := 0 ;
20770: LD_ADDR_VAR 0 3
20774: PUSH
20775: LD_INT 0
20777: ST_TO_ADDR
// if not array or not value in array then
20778: LD_VAR 0 1
20782: NOT
20783: PUSH
20784: LD_VAR 0 2
20788: PUSH
20789: LD_VAR 0 1
20793: IN
20794: NOT
20795: OR
20796: IFFALSE 20800
// exit ;
20798: GO 20854
// for i = 1 to array do
20800: LD_ADDR_VAR 0 4
20804: PUSH
20805: DOUBLE
20806: LD_INT 1
20808: DEC
20809: ST_TO_ADDR
20810: LD_VAR 0 1
20814: PUSH
20815: FOR_TO
20816: IFFALSE 20852
// if value = array [ i ] then
20818: LD_VAR 0 2
20822: PUSH
20823: LD_VAR 0 1
20827: PUSH
20828: LD_VAR 0 4
20832: ARRAY
20833: EQUAL
20834: IFFALSE 20850
// begin result := i ;
20836: LD_ADDR_VAR 0 3
20840: PUSH
20841: LD_VAR 0 4
20845: ST_TO_ADDR
// exit ;
20846: POP
20847: POP
20848: GO 20854
// end ;
20850: GO 20815
20852: POP
20853: POP
// end ;
20854: LD_VAR 0 3
20858: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20859: LD_INT 0
20861: PPUSH
// vc_chassis := chassis ;
20862: LD_ADDR_OWVAR 37
20866: PUSH
20867: LD_VAR 0 1
20871: ST_TO_ADDR
// vc_engine := engine ;
20872: LD_ADDR_OWVAR 39
20876: PUSH
20877: LD_VAR 0 2
20881: ST_TO_ADDR
// vc_control := control ;
20882: LD_ADDR_OWVAR 38
20886: PUSH
20887: LD_VAR 0 3
20891: ST_TO_ADDR
// vc_weapon := weapon ;
20892: LD_ADDR_OWVAR 40
20896: PUSH
20897: LD_VAR 0 4
20901: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20902: LD_ADDR_OWVAR 41
20906: PUSH
20907: LD_VAR 0 5
20911: ST_TO_ADDR
// end ;
20912: LD_VAR 0 6
20916: RET
// export function WantPlant ( unit ) ; var task ; begin
20917: LD_INT 0
20919: PPUSH
20920: PPUSH
// result := false ;
20921: LD_ADDR_VAR 0 2
20925: PUSH
20926: LD_INT 0
20928: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20929: LD_ADDR_VAR 0 3
20933: PUSH
20934: LD_VAR 0 1
20938: PPUSH
20939: CALL_OW 437
20943: ST_TO_ADDR
// if task then
20944: LD_VAR 0 3
20948: IFFALSE 20976
// if task [ 1 ] [ 1 ] = p then
20950: LD_VAR 0 3
20954: PUSH
20955: LD_INT 1
20957: ARRAY
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PUSH
20963: LD_STRING p
20965: EQUAL
20966: IFFALSE 20976
// result := true ;
20968: LD_ADDR_VAR 0 2
20972: PUSH
20973: LD_INT 1
20975: ST_TO_ADDR
// end ;
20976: LD_VAR 0 2
20980: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20981: LD_INT 0
20983: PPUSH
20984: PPUSH
20985: PPUSH
20986: PPUSH
// if pos < 1 then
20987: LD_VAR 0 2
20991: PUSH
20992: LD_INT 1
20994: LESS
20995: IFFALSE 20999
// exit ;
20997: GO 21302
// if pos = 1 then
20999: LD_VAR 0 2
21003: PUSH
21004: LD_INT 1
21006: EQUAL
21007: IFFALSE 21040
// result := Replace ( arr , pos [ 1 ] , value ) else
21009: LD_ADDR_VAR 0 4
21013: PUSH
21014: LD_VAR 0 1
21018: PPUSH
21019: LD_VAR 0 2
21023: PUSH
21024: LD_INT 1
21026: ARRAY
21027: PPUSH
21028: LD_VAR 0 3
21032: PPUSH
21033: CALL_OW 1
21037: ST_TO_ADDR
21038: GO 21302
// begin tmp := arr ;
21040: LD_ADDR_VAR 0 6
21044: PUSH
21045: LD_VAR 0 1
21049: ST_TO_ADDR
// s_arr := [ tmp ] ;
21050: LD_ADDR_VAR 0 7
21054: PUSH
21055: LD_VAR 0 6
21059: PUSH
21060: EMPTY
21061: LIST
21062: ST_TO_ADDR
// for i = 1 to pos - 1 do
21063: LD_ADDR_VAR 0 5
21067: PUSH
21068: DOUBLE
21069: LD_INT 1
21071: DEC
21072: ST_TO_ADDR
21073: LD_VAR 0 2
21077: PUSH
21078: LD_INT 1
21080: MINUS
21081: PUSH
21082: FOR_TO
21083: IFFALSE 21128
// begin tmp := tmp [ pos [ i ] ] ;
21085: LD_ADDR_VAR 0 6
21089: PUSH
21090: LD_VAR 0 6
21094: PUSH
21095: LD_VAR 0 2
21099: PUSH
21100: LD_VAR 0 5
21104: ARRAY
21105: ARRAY
21106: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21107: LD_ADDR_VAR 0 7
21111: PUSH
21112: LD_VAR 0 7
21116: PUSH
21117: LD_VAR 0 6
21121: PUSH
21122: EMPTY
21123: LIST
21124: ADD
21125: ST_TO_ADDR
// end ;
21126: GO 21082
21128: POP
21129: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21130: LD_ADDR_VAR 0 6
21134: PUSH
21135: LD_VAR 0 6
21139: PPUSH
21140: LD_VAR 0 2
21144: PUSH
21145: LD_VAR 0 2
21149: ARRAY
21150: PPUSH
21151: LD_VAR 0 3
21155: PPUSH
21156: CALL_OW 1
21160: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21161: LD_ADDR_VAR 0 7
21165: PUSH
21166: LD_VAR 0 7
21170: PPUSH
21171: LD_VAR 0 7
21175: PPUSH
21176: LD_VAR 0 6
21180: PPUSH
21181: CALL_OW 1
21185: ST_TO_ADDR
// for i = s_arr downto 2 do
21186: LD_ADDR_VAR 0 5
21190: PUSH
21191: DOUBLE
21192: LD_VAR 0 7
21196: INC
21197: ST_TO_ADDR
21198: LD_INT 2
21200: PUSH
21201: FOR_DOWNTO
21202: IFFALSE 21286
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21204: LD_ADDR_VAR 0 6
21208: PUSH
21209: LD_VAR 0 7
21213: PUSH
21214: LD_VAR 0 5
21218: PUSH
21219: LD_INT 1
21221: MINUS
21222: ARRAY
21223: PPUSH
21224: LD_VAR 0 2
21228: PUSH
21229: LD_VAR 0 5
21233: PUSH
21234: LD_INT 1
21236: MINUS
21237: ARRAY
21238: PPUSH
21239: LD_VAR 0 7
21243: PUSH
21244: LD_VAR 0 5
21248: ARRAY
21249: PPUSH
21250: CALL_OW 1
21254: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21255: LD_ADDR_VAR 0 7
21259: PUSH
21260: LD_VAR 0 7
21264: PPUSH
21265: LD_VAR 0 5
21269: PUSH
21270: LD_INT 1
21272: MINUS
21273: PPUSH
21274: LD_VAR 0 6
21278: PPUSH
21279: CALL_OW 1
21283: ST_TO_ADDR
// end ;
21284: GO 21201
21286: POP
21287: POP
// result := s_arr [ 1 ] ;
21288: LD_ADDR_VAR 0 4
21292: PUSH
21293: LD_VAR 0 7
21297: PUSH
21298: LD_INT 1
21300: ARRAY
21301: ST_TO_ADDR
// end ; end ;
21302: LD_VAR 0 4
21306: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
// if not list then
21311: LD_VAR 0 1
21315: NOT
21316: IFFALSE 21320
// exit ;
21318: GO 21411
// i := list [ pos1 ] ;
21320: LD_ADDR_VAR 0 5
21324: PUSH
21325: LD_VAR 0 1
21329: PUSH
21330: LD_VAR 0 2
21334: ARRAY
21335: ST_TO_ADDR
// if not i then
21336: LD_VAR 0 5
21340: NOT
21341: IFFALSE 21345
// exit ;
21343: GO 21411
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21345: LD_ADDR_VAR 0 1
21349: PUSH
21350: LD_VAR 0 1
21354: PPUSH
21355: LD_VAR 0 2
21359: PPUSH
21360: LD_VAR 0 1
21364: PUSH
21365: LD_VAR 0 3
21369: ARRAY
21370: PPUSH
21371: CALL_OW 1
21375: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21376: LD_ADDR_VAR 0 1
21380: PUSH
21381: LD_VAR 0 1
21385: PPUSH
21386: LD_VAR 0 3
21390: PPUSH
21391: LD_VAR 0 5
21395: PPUSH
21396: CALL_OW 1
21400: ST_TO_ADDR
// result := list ;
21401: LD_ADDR_VAR 0 4
21405: PUSH
21406: LD_VAR 0 1
21410: ST_TO_ADDR
// end ;
21411: LD_VAR 0 4
21415: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21416: LD_INT 0
21418: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21419: LD_ADDR_VAR 0 5
21423: PUSH
21424: LD_VAR 0 1
21428: PPUSH
21429: CALL_OW 250
21433: PPUSH
21434: LD_VAR 0 1
21438: PPUSH
21439: CALL_OW 251
21443: PPUSH
21444: LD_VAR 0 2
21448: PPUSH
21449: LD_VAR 0 3
21453: PPUSH
21454: LD_VAR 0 4
21458: PPUSH
21459: CALL 21837 0 5
21463: ST_TO_ADDR
// end ;
21464: LD_VAR 0 5
21468: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
21469: LD_INT 0
21471: PPUSH
21472: PPUSH
21473: PPUSH
21474: PPUSH
// if not list or not unit then
21475: LD_VAR 0 2
21479: NOT
21480: PUSH
21481: LD_VAR 0 1
21485: NOT
21486: OR
21487: IFFALSE 21491
// exit ;
21489: GO 21832
// result := [ ] ;
21491: LD_ADDR_VAR 0 5
21495: PUSH
21496: EMPTY
21497: ST_TO_ADDR
// for i in list do
21498: LD_ADDR_VAR 0 6
21502: PUSH
21503: LD_VAR 0 2
21507: PUSH
21508: FOR_IN
21509: IFFALSE 21727
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
21511: LD_ADDR_VAR 0 8
21515: PUSH
21516: LD_VAR 0 1
21520: PPUSH
21521: LD_VAR 0 6
21525: PUSH
21526: LD_INT 1
21528: ARRAY
21529: PPUSH
21530: LD_VAR 0 6
21534: PUSH
21535: LD_INT 2
21537: ARRAY
21538: PPUSH
21539: CALL_OW 297
21543: ST_TO_ADDR
// if not Count ( result ) then
21544: LD_VAR 0 5
21548: PPUSH
21549: CALL 18121 0 1
21553: NOT
21554: IFFALSE 21587
// begin result := Join ( result , [ i , tmp ] ) ;
21556: LD_ADDR_VAR 0 5
21560: PUSH
21561: LD_VAR 0 5
21565: PPUSH
21566: LD_VAR 0 6
21570: PUSH
21571: LD_VAR 0 8
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: PPUSH
21580: CALL 53721 0 2
21584: ST_TO_ADDR
// continue ;
21585: GO 21508
// end ; if result [ result ] [ 2 ] <= tmp then
21587: LD_VAR 0 5
21591: PUSH
21592: LD_VAR 0 5
21596: ARRAY
21597: PUSH
21598: LD_INT 2
21600: ARRAY
21601: PUSH
21602: LD_VAR 0 8
21606: LESSEQUAL
21607: IFFALSE 21640
// result := Join ( result , [ i , tmp ] ) else
21609: LD_ADDR_VAR 0 5
21613: PUSH
21614: LD_VAR 0 5
21618: PPUSH
21619: LD_VAR 0 6
21623: PUSH
21624: LD_VAR 0 8
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PPUSH
21633: CALL 53721 0 2
21637: ST_TO_ADDR
21638: GO 21725
// begin for j := 1 to Count ( result ) do
21640: LD_ADDR_VAR 0 7
21644: PUSH
21645: DOUBLE
21646: LD_INT 1
21648: DEC
21649: ST_TO_ADDR
21650: LD_VAR 0 5
21654: PPUSH
21655: CALL 18121 0 1
21659: PUSH
21660: FOR_TO
21661: IFFALSE 21723
// begin if tmp < result [ j ] [ 2 ] then
21663: LD_VAR 0 8
21667: PUSH
21668: LD_VAR 0 5
21672: PUSH
21673: LD_VAR 0 7
21677: ARRAY
21678: PUSH
21679: LD_INT 2
21681: ARRAY
21682: LESS
21683: IFFALSE 21721
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21685: LD_ADDR_VAR 0 5
21689: PUSH
21690: LD_VAR 0 5
21694: PPUSH
21695: LD_VAR 0 7
21699: PPUSH
21700: LD_VAR 0 6
21704: PUSH
21705: LD_VAR 0 8
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PPUSH
21714: CALL_OW 2
21718: ST_TO_ADDR
// break ;
21719: GO 21723
// end ; end ;
21721: GO 21660
21723: POP
21724: POP
// end ; end ;
21725: GO 21508
21727: POP
21728: POP
// if result and not asc then
21729: LD_VAR 0 5
21733: PUSH
21734: LD_VAR 0 3
21738: NOT
21739: AND
21740: IFFALSE 21757
// result := ReverseArray ( result ) ;
21742: LD_ADDR_VAR 0 5
21746: PUSH
21747: LD_VAR 0 5
21751: PPUSH
21752: CALL 48997 0 1
21756: ST_TO_ADDR
// tmp := [ ] ;
21757: LD_ADDR_VAR 0 8
21761: PUSH
21762: EMPTY
21763: ST_TO_ADDR
// if mode then
21764: LD_VAR 0 4
21768: IFFALSE 21832
// begin for i := 1 to result do
21770: LD_ADDR_VAR 0 6
21774: PUSH
21775: DOUBLE
21776: LD_INT 1
21778: DEC
21779: ST_TO_ADDR
21780: LD_VAR 0 5
21784: PUSH
21785: FOR_TO
21786: IFFALSE 21820
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
21788: LD_ADDR_VAR 0 8
21792: PUSH
21793: LD_VAR 0 8
21797: PPUSH
21798: LD_VAR 0 5
21802: PUSH
21803: LD_VAR 0 6
21807: ARRAY
21808: PUSH
21809: LD_INT 1
21811: ARRAY
21812: PPUSH
21813: CALL 53721 0 2
21817: ST_TO_ADDR
21818: GO 21785
21820: POP
21821: POP
// result := tmp ;
21822: LD_ADDR_VAR 0 5
21826: PUSH
21827: LD_VAR 0 8
21831: ST_TO_ADDR
// end ; end ;
21832: LD_VAR 0 5
21836: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21837: LD_INT 0
21839: PPUSH
21840: PPUSH
21841: PPUSH
21842: PPUSH
// if not list then
21843: LD_VAR 0 3
21847: NOT
21848: IFFALSE 21852
// exit ;
21850: GO 22240
// result := [ ] ;
21852: LD_ADDR_VAR 0 6
21856: PUSH
21857: EMPTY
21858: ST_TO_ADDR
// for i in list do
21859: LD_ADDR_VAR 0 7
21863: PUSH
21864: LD_VAR 0 3
21868: PUSH
21869: FOR_IN
21870: IFFALSE 22072
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21872: LD_ADDR_VAR 0 9
21876: PUSH
21877: LD_VAR 0 7
21881: PPUSH
21882: LD_VAR 0 1
21886: PPUSH
21887: LD_VAR 0 2
21891: PPUSH
21892: CALL_OW 297
21896: ST_TO_ADDR
// if not result then
21897: LD_VAR 0 6
21901: NOT
21902: IFFALSE 21928
// result := [ [ i , tmp ] ] else
21904: LD_ADDR_VAR 0 6
21908: PUSH
21909: LD_VAR 0 7
21913: PUSH
21914: LD_VAR 0 9
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: EMPTY
21924: LIST
21925: ST_TO_ADDR
21926: GO 22070
// begin if result [ result ] [ 2 ] < tmp then
21928: LD_VAR 0 6
21932: PUSH
21933: LD_VAR 0 6
21937: ARRAY
21938: PUSH
21939: LD_INT 2
21941: ARRAY
21942: PUSH
21943: LD_VAR 0 9
21947: LESS
21948: IFFALSE 21990
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21950: LD_ADDR_VAR 0 6
21954: PUSH
21955: LD_VAR 0 6
21959: PPUSH
21960: LD_VAR 0 6
21964: PUSH
21965: LD_INT 1
21967: PLUS
21968: PPUSH
21969: LD_VAR 0 7
21973: PUSH
21974: LD_VAR 0 9
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PPUSH
21983: CALL_OW 2
21987: ST_TO_ADDR
21988: GO 22070
// for j = 1 to result do
21990: LD_ADDR_VAR 0 8
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_VAR 0 6
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22068
// begin if tmp < result [ j ] [ 2 ] then
22008: LD_VAR 0 9
22012: PUSH
22013: LD_VAR 0 6
22017: PUSH
22018: LD_VAR 0 8
22022: ARRAY
22023: PUSH
22024: LD_INT 2
22026: ARRAY
22027: LESS
22028: IFFALSE 22066
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22030: LD_ADDR_VAR 0 6
22034: PUSH
22035: LD_VAR 0 6
22039: PPUSH
22040: LD_VAR 0 8
22044: PPUSH
22045: LD_VAR 0 7
22049: PUSH
22050: LD_VAR 0 9
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: PPUSH
22059: CALL_OW 2
22063: ST_TO_ADDR
// break ;
22064: GO 22068
// end ; end ;
22066: GO 22005
22068: POP
22069: POP
// end ; end ;
22070: GO 21869
22072: POP
22073: POP
// if result and not asc then
22074: LD_VAR 0 6
22078: PUSH
22079: LD_VAR 0 4
22083: NOT
22084: AND
22085: IFFALSE 22160
// begin tmp := result ;
22087: LD_ADDR_VAR 0 9
22091: PUSH
22092: LD_VAR 0 6
22096: ST_TO_ADDR
// for i = tmp downto 1 do
22097: LD_ADDR_VAR 0 7
22101: PUSH
22102: DOUBLE
22103: LD_VAR 0 9
22107: INC
22108: ST_TO_ADDR
22109: LD_INT 1
22111: PUSH
22112: FOR_DOWNTO
22113: IFFALSE 22158
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22115: LD_ADDR_VAR 0 6
22119: PUSH
22120: LD_VAR 0 6
22124: PPUSH
22125: LD_VAR 0 9
22129: PUSH
22130: LD_VAR 0 7
22134: MINUS
22135: PUSH
22136: LD_INT 1
22138: PLUS
22139: PPUSH
22140: LD_VAR 0 9
22144: PUSH
22145: LD_VAR 0 7
22149: ARRAY
22150: PPUSH
22151: CALL_OW 1
22155: ST_TO_ADDR
22156: GO 22112
22158: POP
22159: POP
// end ; tmp := [ ] ;
22160: LD_ADDR_VAR 0 9
22164: PUSH
22165: EMPTY
22166: ST_TO_ADDR
// if mode then
22167: LD_VAR 0 5
22171: IFFALSE 22240
// begin for i = 1 to result do
22173: LD_ADDR_VAR 0 7
22177: PUSH
22178: DOUBLE
22179: LD_INT 1
22181: DEC
22182: ST_TO_ADDR
22183: LD_VAR 0 6
22187: PUSH
22188: FOR_TO
22189: IFFALSE 22228
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22191: LD_ADDR_VAR 0 9
22195: PUSH
22196: LD_VAR 0 9
22200: PPUSH
22201: LD_VAR 0 7
22205: PPUSH
22206: LD_VAR 0 6
22210: PUSH
22211: LD_VAR 0 7
22215: ARRAY
22216: PUSH
22217: LD_INT 1
22219: ARRAY
22220: PPUSH
22221: CALL_OW 1
22225: ST_TO_ADDR
22226: GO 22188
22228: POP
22229: POP
// result := tmp ;
22230: LD_ADDR_VAR 0 6
22234: PUSH
22235: LD_VAR 0 9
22239: ST_TO_ADDR
// end ; end ;
22240: LD_VAR 0 6
22244: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22245: LD_INT 0
22247: PPUSH
22248: PPUSH
22249: PPUSH
22250: PPUSH
22251: PPUSH
22252: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22253: LD_ADDR_VAR 0 5
22257: PUSH
22258: LD_INT 0
22260: PUSH
22261: LD_INT 0
22263: PUSH
22264: LD_INT 0
22266: PUSH
22267: EMPTY
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: LIST
22273: LIST
22274: ST_TO_ADDR
// if not x or not y then
22275: LD_VAR 0 2
22279: NOT
22280: PUSH
22281: LD_VAR 0 3
22285: NOT
22286: OR
22287: IFFALSE 22291
// exit ;
22289: GO 23941
// if not range then
22291: LD_VAR 0 4
22295: NOT
22296: IFFALSE 22306
// range := 10 ;
22298: LD_ADDR_VAR 0 4
22302: PUSH
22303: LD_INT 10
22305: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22306: LD_ADDR_VAR 0 8
22310: PUSH
22311: LD_INT 81
22313: PUSH
22314: LD_VAR 0 1
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: LD_INT 92
22325: PUSH
22326: LD_VAR 0 2
22330: PUSH
22331: LD_VAR 0 3
22335: PUSH
22336: LD_VAR 0 4
22340: PUSH
22341: EMPTY
22342: LIST
22343: LIST
22344: LIST
22345: LIST
22346: PUSH
22347: LD_INT 3
22349: PUSH
22350: LD_INT 21
22352: PUSH
22353: LD_INT 3
22355: PUSH
22356: EMPTY
22357: LIST
22358: LIST
22359: PUSH
22360: EMPTY
22361: LIST
22362: LIST
22363: PUSH
22364: EMPTY
22365: LIST
22366: LIST
22367: LIST
22368: PPUSH
22369: CALL_OW 69
22373: ST_TO_ADDR
// if not tmp then
22374: LD_VAR 0 8
22378: NOT
22379: IFFALSE 22383
// exit ;
22381: GO 23941
// for i in tmp do
22383: LD_ADDR_VAR 0 6
22387: PUSH
22388: LD_VAR 0 8
22392: PUSH
22393: FOR_IN
22394: IFFALSE 23916
// begin points := [ 0 , 0 , 0 ] ;
22396: LD_ADDR_VAR 0 9
22400: PUSH
22401: LD_INT 0
22403: PUSH
22404: LD_INT 0
22406: PUSH
22407: LD_INT 0
22409: PUSH
22410: EMPTY
22411: LIST
22412: LIST
22413: LIST
22414: ST_TO_ADDR
// bpoints := 1 ;
22415: LD_ADDR_VAR 0 10
22419: PUSH
22420: LD_INT 1
22422: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22423: LD_VAR 0 6
22427: PPUSH
22428: CALL_OW 247
22432: PUSH
22433: LD_INT 1
22435: DOUBLE
22436: EQUAL
22437: IFTRUE 22441
22439: GO 23019
22441: POP
// begin if GetClass ( i ) = 1 then
22442: LD_VAR 0 6
22446: PPUSH
22447: CALL_OW 257
22451: PUSH
22452: LD_INT 1
22454: EQUAL
22455: IFFALSE 22476
// points := [ 10 , 5 , 3 ] ;
22457: LD_ADDR_VAR 0 9
22461: PUSH
22462: LD_INT 10
22464: PUSH
22465: LD_INT 5
22467: PUSH
22468: LD_INT 3
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: LIST
22475: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22476: LD_VAR 0 6
22480: PPUSH
22481: CALL_OW 257
22485: PUSH
22486: LD_INT 2
22488: PUSH
22489: LD_INT 3
22491: PUSH
22492: LD_INT 4
22494: PUSH
22495: EMPTY
22496: LIST
22497: LIST
22498: LIST
22499: IN
22500: IFFALSE 22521
// points := [ 3 , 2 , 1 ] ;
22502: LD_ADDR_VAR 0 9
22506: PUSH
22507: LD_INT 3
22509: PUSH
22510: LD_INT 2
22512: PUSH
22513: LD_INT 1
22515: PUSH
22516: EMPTY
22517: LIST
22518: LIST
22519: LIST
22520: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22521: LD_VAR 0 6
22525: PPUSH
22526: CALL_OW 257
22530: PUSH
22531: LD_INT 5
22533: EQUAL
22534: IFFALSE 22555
// points := [ 130 , 5 , 2 ] ;
22536: LD_ADDR_VAR 0 9
22540: PUSH
22541: LD_INT 130
22543: PUSH
22544: LD_INT 5
22546: PUSH
22547: LD_INT 2
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22555: LD_VAR 0 6
22559: PPUSH
22560: CALL_OW 257
22564: PUSH
22565: LD_INT 8
22567: EQUAL
22568: IFFALSE 22589
// points := [ 35 , 35 , 30 ] ;
22570: LD_ADDR_VAR 0 9
22574: PUSH
22575: LD_INT 35
22577: PUSH
22578: LD_INT 35
22580: PUSH
22581: LD_INT 30
22583: PUSH
22584: EMPTY
22585: LIST
22586: LIST
22587: LIST
22588: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22589: LD_VAR 0 6
22593: PPUSH
22594: CALL_OW 257
22598: PUSH
22599: LD_INT 9
22601: EQUAL
22602: IFFALSE 22623
// points := [ 20 , 55 , 40 ] ;
22604: LD_ADDR_VAR 0 9
22608: PUSH
22609: LD_INT 20
22611: PUSH
22612: LD_INT 55
22614: PUSH
22615: LD_INT 40
22617: PUSH
22618: EMPTY
22619: LIST
22620: LIST
22621: LIST
22622: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22623: LD_VAR 0 6
22627: PPUSH
22628: CALL_OW 257
22632: PUSH
22633: LD_INT 12
22635: PUSH
22636: LD_INT 16
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: IN
22643: IFFALSE 22664
// points := [ 5 , 3 , 2 ] ;
22645: LD_ADDR_VAR 0 9
22649: PUSH
22650: LD_INT 5
22652: PUSH
22653: LD_INT 3
22655: PUSH
22656: LD_INT 2
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22664: LD_VAR 0 6
22668: PPUSH
22669: CALL_OW 257
22673: PUSH
22674: LD_INT 17
22676: EQUAL
22677: IFFALSE 22698
// points := [ 100 , 50 , 75 ] ;
22679: LD_ADDR_VAR 0 9
22683: PUSH
22684: LD_INT 100
22686: PUSH
22687: LD_INT 50
22689: PUSH
22690: LD_INT 75
22692: PUSH
22693: EMPTY
22694: LIST
22695: LIST
22696: LIST
22697: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22698: LD_VAR 0 6
22702: PPUSH
22703: CALL_OW 257
22707: PUSH
22708: LD_INT 15
22710: EQUAL
22711: IFFALSE 22732
// points := [ 10 , 5 , 3 ] ;
22713: LD_ADDR_VAR 0 9
22717: PUSH
22718: LD_INT 10
22720: PUSH
22721: LD_INT 5
22723: PUSH
22724: LD_INT 3
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: LIST
22731: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22732: LD_VAR 0 6
22736: PPUSH
22737: CALL_OW 257
22741: PUSH
22742: LD_INT 14
22744: EQUAL
22745: IFFALSE 22766
// points := [ 10 , 0 , 0 ] ;
22747: LD_ADDR_VAR 0 9
22751: PUSH
22752: LD_INT 10
22754: PUSH
22755: LD_INT 0
22757: PUSH
22758: LD_INT 0
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: LIST
22765: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22766: LD_VAR 0 6
22770: PPUSH
22771: CALL_OW 257
22775: PUSH
22776: LD_INT 11
22778: EQUAL
22779: IFFALSE 22800
// points := [ 30 , 10 , 5 ] ;
22781: LD_ADDR_VAR 0 9
22785: PUSH
22786: LD_INT 30
22788: PUSH
22789: LD_INT 10
22791: PUSH
22792: LD_INT 5
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22800: LD_VAR 0 1
22804: PPUSH
22805: LD_INT 5
22807: PPUSH
22808: CALL_OW 321
22812: PUSH
22813: LD_INT 2
22815: EQUAL
22816: IFFALSE 22833
// bpoints := bpoints * 1.8 ;
22818: LD_ADDR_VAR 0 10
22822: PUSH
22823: LD_VAR 0 10
22827: PUSH
22828: LD_REAL  1.80000000000000E+0000
22831: MUL
22832: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22833: LD_VAR 0 6
22837: PPUSH
22838: CALL_OW 257
22842: PUSH
22843: LD_INT 1
22845: PUSH
22846: LD_INT 2
22848: PUSH
22849: LD_INT 3
22851: PUSH
22852: LD_INT 4
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: IN
22861: PUSH
22862: LD_VAR 0 1
22866: PPUSH
22867: LD_INT 51
22869: PPUSH
22870: CALL_OW 321
22874: PUSH
22875: LD_INT 2
22877: EQUAL
22878: AND
22879: IFFALSE 22896
// bpoints := bpoints * 1.2 ;
22881: LD_ADDR_VAR 0 10
22885: PUSH
22886: LD_VAR 0 10
22890: PUSH
22891: LD_REAL  1.20000000000000E+0000
22894: MUL
22895: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22896: LD_VAR 0 6
22900: PPUSH
22901: CALL_OW 257
22905: PUSH
22906: LD_INT 5
22908: PUSH
22909: LD_INT 7
22911: PUSH
22912: LD_INT 9
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: LIST
22919: IN
22920: PUSH
22921: LD_VAR 0 1
22925: PPUSH
22926: LD_INT 52
22928: PPUSH
22929: CALL_OW 321
22933: PUSH
22934: LD_INT 2
22936: EQUAL
22937: AND
22938: IFFALSE 22955
// bpoints := bpoints * 1.5 ;
22940: LD_ADDR_VAR 0 10
22944: PUSH
22945: LD_VAR 0 10
22949: PUSH
22950: LD_REAL  1.50000000000000E+0000
22953: MUL
22954: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22955: LD_VAR 0 1
22959: PPUSH
22960: LD_INT 66
22962: PPUSH
22963: CALL_OW 321
22967: PUSH
22968: LD_INT 2
22970: EQUAL
22971: IFFALSE 22988
// bpoints := bpoints * 1.1 ;
22973: LD_ADDR_VAR 0 10
22977: PUSH
22978: LD_VAR 0 10
22982: PUSH
22983: LD_REAL  1.10000000000000E+0000
22986: MUL
22987: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22988: LD_ADDR_VAR 0 10
22992: PUSH
22993: LD_VAR 0 10
22997: PUSH
22998: LD_VAR 0 6
23002: PPUSH
23003: LD_INT 1
23005: PPUSH
23006: CALL_OW 259
23010: PUSH
23011: LD_REAL  1.15000000000000E+0000
23014: MUL
23015: MUL
23016: ST_TO_ADDR
// end ; unit_vehicle :
23017: GO 23845
23019: LD_INT 2
23021: DOUBLE
23022: EQUAL
23023: IFTRUE 23027
23025: GO 23833
23027: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
23028: LD_VAR 0 6
23032: PPUSH
23033: CALL_OW 264
23037: PUSH
23038: LD_INT 2
23040: PUSH
23041: LD_INT 42
23043: PUSH
23044: LD_INT 24
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: LIST
23051: IN
23052: IFFALSE 23073
// points := [ 25 , 5 , 3 ] ;
23054: LD_ADDR_VAR 0 9
23058: PUSH
23059: LD_INT 25
23061: PUSH
23062: LD_INT 5
23064: PUSH
23065: LD_INT 3
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: LIST
23072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23073: LD_VAR 0 6
23077: PPUSH
23078: CALL_OW 264
23082: PUSH
23083: LD_INT 4
23085: PUSH
23086: LD_INT 43
23088: PUSH
23089: LD_INT 25
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: LIST
23096: IN
23097: IFFALSE 23118
// points := [ 40 , 15 , 5 ] ;
23099: LD_ADDR_VAR 0 9
23103: PUSH
23104: LD_INT 40
23106: PUSH
23107: LD_INT 15
23109: PUSH
23110: LD_INT 5
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: LIST
23117: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23118: LD_VAR 0 6
23122: PPUSH
23123: CALL_OW 264
23127: PUSH
23128: LD_INT 3
23130: PUSH
23131: LD_INT 23
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: IN
23138: IFFALSE 23159
// points := [ 7 , 25 , 8 ] ;
23140: LD_ADDR_VAR 0 9
23144: PUSH
23145: LD_INT 7
23147: PUSH
23148: LD_INT 25
23150: PUSH
23151: LD_INT 8
23153: PUSH
23154: EMPTY
23155: LIST
23156: LIST
23157: LIST
23158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23159: LD_VAR 0 6
23163: PPUSH
23164: CALL_OW 264
23168: PUSH
23169: LD_INT 5
23171: PUSH
23172: LD_INT 27
23174: PUSH
23175: LD_INT 44
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: IN
23183: IFFALSE 23204
// points := [ 14 , 50 , 16 ] ;
23185: LD_ADDR_VAR 0 9
23189: PUSH
23190: LD_INT 14
23192: PUSH
23193: LD_INT 50
23195: PUSH
23196: LD_INT 16
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: LIST
23203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23204: LD_VAR 0 6
23208: PPUSH
23209: CALL_OW 264
23213: PUSH
23214: LD_INT 6
23216: PUSH
23217: LD_INT 46
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: IN
23224: IFFALSE 23245
// points := [ 32 , 120 , 70 ] ;
23226: LD_ADDR_VAR 0 9
23230: PUSH
23231: LD_INT 32
23233: PUSH
23234: LD_INT 120
23236: PUSH
23237: LD_INT 70
23239: PUSH
23240: EMPTY
23241: LIST
23242: LIST
23243: LIST
23244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
23245: LD_VAR 0 6
23249: PPUSH
23250: CALL_OW 264
23254: PUSH
23255: LD_INT 7
23257: PUSH
23258: LD_INT 28
23260: PUSH
23261: LD_INT 45
23263: PUSH
23264: LD_INT 92
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: LIST
23271: LIST
23272: IN
23273: IFFALSE 23294
// points := [ 35 , 20 , 45 ] ;
23275: LD_ADDR_VAR 0 9
23279: PUSH
23280: LD_INT 35
23282: PUSH
23283: LD_INT 20
23285: PUSH
23286: LD_INT 45
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23294: LD_VAR 0 6
23298: PPUSH
23299: CALL_OW 264
23303: PUSH
23304: LD_INT 47
23306: PUSH
23307: EMPTY
23308: LIST
23309: IN
23310: IFFALSE 23331
// points := [ 67 , 45 , 75 ] ;
23312: LD_ADDR_VAR 0 9
23316: PUSH
23317: LD_INT 67
23319: PUSH
23320: LD_INT 45
23322: PUSH
23323: LD_INT 75
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23331: LD_VAR 0 6
23335: PPUSH
23336: CALL_OW 264
23340: PUSH
23341: LD_INT 26
23343: PUSH
23344: EMPTY
23345: LIST
23346: IN
23347: IFFALSE 23368
// points := [ 120 , 30 , 80 ] ;
23349: LD_ADDR_VAR 0 9
23353: PUSH
23354: LD_INT 120
23356: PUSH
23357: LD_INT 30
23359: PUSH
23360: LD_INT 80
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: LIST
23367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23368: LD_VAR 0 6
23372: PPUSH
23373: CALL_OW 264
23377: PUSH
23378: LD_INT 22
23380: PUSH
23381: EMPTY
23382: LIST
23383: IN
23384: IFFALSE 23405
// points := [ 40 , 1 , 1 ] ;
23386: LD_ADDR_VAR 0 9
23390: PUSH
23391: LD_INT 40
23393: PUSH
23394: LD_INT 1
23396: PUSH
23397: LD_INT 1
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: LIST
23404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23405: LD_VAR 0 6
23409: PPUSH
23410: CALL_OW 264
23414: PUSH
23415: LD_INT 29
23417: PUSH
23418: EMPTY
23419: LIST
23420: IN
23421: IFFALSE 23442
// points := [ 70 , 200 , 400 ] ;
23423: LD_ADDR_VAR 0 9
23427: PUSH
23428: LD_INT 70
23430: PUSH
23431: LD_INT 200
23433: PUSH
23434: LD_INT 400
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: LIST
23441: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23442: LD_VAR 0 6
23446: PPUSH
23447: CALL_OW 264
23451: PUSH
23452: LD_INT 14
23454: PUSH
23455: LD_INT 53
23457: PUSH
23458: EMPTY
23459: LIST
23460: LIST
23461: IN
23462: IFFALSE 23483
// points := [ 40 , 10 , 20 ] ;
23464: LD_ADDR_VAR 0 9
23468: PUSH
23469: LD_INT 40
23471: PUSH
23472: LD_INT 10
23474: PUSH
23475: LD_INT 20
23477: PUSH
23478: EMPTY
23479: LIST
23480: LIST
23481: LIST
23482: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23483: LD_VAR 0 6
23487: PPUSH
23488: CALL_OW 264
23492: PUSH
23493: LD_INT 9
23495: PUSH
23496: EMPTY
23497: LIST
23498: IN
23499: IFFALSE 23520
// points := [ 5 , 70 , 20 ] ;
23501: LD_ADDR_VAR 0 9
23505: PUSH
23506: LD_INT 5
23508: PUSH
23509: LD_INT 70
23511: PUSH
23512: LD_INT 20
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: LIST
23519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23520: LD_VAR 0 6
23524: PPUSH
23525: CALL_OW 264
23529: PUSH
23530: LD_INT 10
23532: PUSH
23533: EMPTY
23534: LIST
23535: IN
23536: IFFALSE 23557
// points := [ 35 , 110 , 70 ] ;
23538: LD_ADDR_VAR 0 9
23542: PUSH
23543: LD_INT 35
23545: PUSH
23546: LD_INT 110
23548: PUSH
23549: LD_INT 70
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: LIST
23556: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23557: LD_VAR 0 6
23561: PPUSH
23562: CALL_OW 265
23566: PUSH
23567: LD_INT 25
23569: EQUAL
23570: IFFALSE 23591
// points := [ 80 , 65 , 100 ] ;
23572: LD_ADDR_VAR 0 9
23576: PUSH
23577: LD_INT 80
23579: PUSH
23580: LD_INT 65
23582: PUSH
23583: LD_INT 100
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: LIST
23590: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23591: LD_VAR 0 6
23595: PPUSH
23596: CALL_OW 263
23600: PUSH
23601: LD_INT 1
23603: EQUAL
23604: IFFALSE 23639
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23606: LD_ADDR_VAR 0 10
23610: PUSH
23611: LD_VAR 0 10
23615: PUSH
23616: LD_VAR 0 6
23620: PPUSH
23621: CALL_OW 311
23625: PPUSH
23626: LD_INT 3
23628: PPUSH
23629: CALL_OW 259
23633: PUSH
23634: LD_INT 4
23636: MUL
23637: MUL
23638: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23639: LD_VAR 0 6
23643: PPUSH
23644: CALL_OW 263
23648: PUSH
23649: LD_INT 2
23651: EQUAL
23652: IFFALSE 23703
// begin j := IsControledBy ( i ) ;
23654: LD_ADDR_VAR 0 7
23658: PUSH
23659: LD_VAR 0 6
23663: PPUSH
23664: CALL_OW 312
23668: ST_TO_ADDR
// if j then
23669: LD_VAR 0 7
23673: IFFALSE 23703
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23675: LD_ADDR_VAR 0 10
23679: PUSH
23680: LD_VAR 0 10
23684: PUSH
23685: LD_VAR 0 7
23689: PPUSH
23690: LD_INT 3
23692: PPUSH
23693: CALL_OW 259
23697: PUSH
23698: LD_INT 3
23700: MUL
23701: MUL
23702: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23703: LD_VAR 0 6
23707: PPUSH
23708: CALL_OW 264
23712: PUSH
23713: LD_INT 5
23715: PUSH
23716: LD_INT 6
23718: PUSH
23719: LD_INT 46
23721: PUSH
23722: LD_INT 44
23724: PUSH
23725: LD_INT 47
23727: PUSH
23728: LD_INT 45
23730: PUSH
23731: LD_INT 28
23733: PUSH
23734: LD_INT 7
23736: PUSH
23737: LD_INT 27
23739: PUSH
23740: LD_INT 29
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: LIST
23747: LIST
23748: LIST
23749: LIST
23750: LIST
23751: LIST
23752: LIST
23753: LIST
23754: IN
23755: PUSH
23756: LD_VAR 0 1
23760: PPUSH
23761: LD_INT 52
23763: PPUSH
23764: CALL_OW 321
23768: PUSH
23769: LD_INT 2
23771: EQUAL
23772: AND
23773: IFFALSE 23790
// bpoints := bpoints * 1.2 ;
23775: LD_ADDR_VAR 0 10
23779: PUSH
23780: LD_VAR 0 10
23784: PUSH
23785: LD_REAL  1.20000000000000E+0000
23788: MUL
23789: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23790: LD_VAR 0 6
23794: PPUSH
23795: CALL_OW 264
23799: PUSH
23800: LD_INT 6
23802: PUSH
23803: LD_INT 46
23805: PUSH
23806: LD_INT 47
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: LIST
23813: IN
23814: IFFALSE 23831
// bpoints := bpoints * 1.2 ;
23816: LD_ADDR_VAR 0 10
23820: PUSH
23821: LD_VAR 0 10
23825: PUSH
23826: LD_REAL  1.20000000000000E+0000
23829: MUL
23830: ST_TO_ADDR
// end ; unit_building :
23831: GO 23845
23833: LD_INT 3
23835: DOUBLE
23836: EQUAL
23837: IFTRUE 23841
23839: GO 23844
23841: POP
// ; end ;
23842: GO 23845
23844: POP
// for j = 1 to 3 do
23845: LD_ADDR_VAR 0 7
23849: PUSH
23850: DOUBLE
23851: LD_INT 1
23853: DEC
23854: ST_TO_ADDR
23855: LD_INT 3
23857: PUSH
23858: FOR_TO
23859: IFFALSE 23912
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23861: LD_ADDR_VAR 0 5
23865: PUSH
23866: LD_VAR 0 5
23870: PPUSH
23871: LD_VAR 0 7
23875: PPUSH
23876: LD_VAR 0 5
23880: PUSH
23881: LD_VAR 0 7
23885: ARRAY
23886: PUSH
23887: LD_VAR 0 9
23891: PUSH
23892: LD_VAR 0 7
23896: ARRAY
23897: PUSH
23898: LD_VAR 0 10
23902: MUL
23903: PLUS
23904: PPUSH
23905: CALL_OW 1
23909: ST_TO_ADDR
23910: GO 23858
23912: POP
23913: POP
// end ;
23914: GO 22393
23916: POP
23917: POP
// result := Replace ( result , 4 , tmp ) ;
23918: LD_ADDR_VAR 0 5
23922: PUSH
23923: LD_VAR 0 5
23927: PPUSH
23928: LD_INT 4
23930: PPUSH
23931: LD_VAR 0 8
23935: PPUSH
23936: CALL_OW 1
23940: ST_TO_ADDR
// end ;
23941: LD_VAR 0 5
23945: RET
// export function DangerAtRange ( unit , range ) ; begin
23946: LD_INT 0
23948: PPUSH
// if not unit then
23949: LD_VAR 0 1
23953: NOT
23954: IFFALSE 23958
// exit ;
23956: GO 24003
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23958: LD_ADDR_VAR 0 3
23962: PUSH
23963: LD_VAR 0 1
23967: PPUSH
23968: CALL_OW 255
23972: PPUSH
23973: LD_VAR 0 1
23977: PPUSH
23978: CALL_OW 250
23982: PPUSH
23983: LD_VAR 0 1
23987: PPUSH
23988: CALL_OW 251
23992: PPUSH
23993: LD_VAR 0 2
23997: PPUSH
23998: CALL 22245 0 4
24002: ST_TO_ADDR
// end ;
24003: LD_VAR 0 3
24007: RET
// export function DangerInArea ( side , area ) ; begin
24008: LD_INT 0
24010: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
24011: LD_ADDR_VAR 0 3
24015: PUSH
24016: LD_VAR 0 2
24020: PPUSH
24021: LD_INT 81
24023: PUSH
24024: LD_VAR 0 1
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: PPUSH
24033: CALL_OW 70
24037: ST_TO_ADDR
// end ;
24038: LD_VAR 0 3
24042: RET
// export function IsExtension ( b ) ; begin
24043: LD_INT 0
24045: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
24046: LD_ADDR_VAR 0 2
24050: PUSH
24051: LD_VAR 0 1
24055: PUSH
24056: LD_INT 23
24058: PUSH
24059: LD_INT 20
24061: PUSH
24062: LD_INT 22
24064: PUSH
24065: LD_INT 17
24067: PUSH
24068: LD_INT 24
24070: PUSH
24071: LD_INT 21
24073: PUSH
24074: LD_INT 19
24076: PUSH
24077: LD_INT 16
24079: PUSH
24080: LD_INT 25
24082: PUSH
24083: LD_INT 18
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: IN
24098: ST_TO_ADDR
// end ;
24099: LD_VAR 0 2
24103: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
24104: LD_INT 0
24106: PPUSH
24107: PPUSH
24108: PPUSH
// result := [ ] ;
24109: LD_ADDR_VAR 0 4
24113: PUSH
24114: EMPTY
24115: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24116: LD_ADDR_VAR 0 5
24120: PUSH
24121: LD_VAR 0 2
24125: PPUSH
24126: LD_INT 21
24128: PUSH
24129: LD_INT 3
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: PPUSH
24136: CALL_OW 70
24140: ST_TO_ADDR
// if not tmp then
24141: LD_VAR 0 5
24145: NOT
24146: IFFALSE 24150
// exit ;
24148: GO 24214
// if checkLink then
24150: LD_VAR 0 3
24154: IFFALSE 24204
// begin for i in tmp do
24156: LD_ADDR_VAR 0 6
24160: PUSH
24161: LD_VAR 0 5
24165: PUSH
24166: FOR_IN
24167: IFFALSE 24202
// if GetBase ( i ) <> base then
24169: LD_VAR 0 6
24173: PPUSH
24174: CALL_OW 274
24178: PUSH
24179: LD_VAR 0 1
24183: NONEQUAL
24184: IFFALSE 24200
// ComLinkToBase ( base , i ) ;
24186: LD_VAR 0 1
24190: PPUSH
24191: LD_VAR 0 6
24195: PPUSH
24196: CALL_OW 169
24200: GO 24166
24202: POP
24203: POP
// end ; result := tmp ;
24204: LD_ADDR_VAR 0 4
24208: PUSH
24209: LD_VAR 0 5
24213: ST_TO_ADDR
// end ;
24214: LD_VAR 0 4
24218: RET
// export function ComComplete ( units , b ) ; var i ; begin
24219: LD_INT 0
24221: PPUSH
24222: PPUSH
// if not units then
24223: LD_VAR 0 1
24227: NOT
24228: IFFALSE 24232
// exit ;
24230: GO 24322
// for i in units do
24232: LD_ADDR_VAR 0 4
24236: PUSH
24237: LD_VAR 0 1
24241: PUSH
24242: FOR_IN
24243: IFFALSE 24320
// if BuildingStatus ( b ) = bs_build then
24245: LD_VAR 0 2
24249: PPUSH
24250: CALL_OW 461
24254: PUSH
24255: LD_INT 1
24257: EQUAL
24258: IFFALSE 24318
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24260: LD_VAR 0 4
24264: PPUSH
24265: LD_STRING h
24267: PUSH
24268: LD_VAR 0 2
24272: PPUSH
24273: CALL_OW 250
24277: PUSH
24278: LD_VAR 0 2
24282: PPUSH
24283: CALL_OW 251
24287: PUSH
24288: LD_VAR 0 2
24292: PUSH
24293: LD_INT 0
24295: PUSH
24296: LD_INT 0
24298: PUSH
24299: LD_INT 0
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: PUSH
24311: EMPTY
24312: LIST
24313: PPUSH
24314: CALL_OW 446
24318: GO 24242
24320: POP
24321: POP
// end ;
24322: LD_VAR 0 3
24326: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24327: LD_INT 0
24329: PPUSH
24330: PPUSH
24331: PPUSH
24332: PPUSH
24333: PPUSH
24334: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
24335: LD_VAR 0 1
24339: NOT
24340: PUSH
24341: LD_VAR 0 1
24345: PPUSH
24346: CALL_OW 263
24350: PUSH
24351: LD_INT 2
24353: NONEQUAL
24354: OR
24355: IFFALSE 24359
// exit ;
24357: GO 24675
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24359: LD_ADDR_VAR 0 6
24363: PUSH
24364: LD_INT 22
24366: PUSH
24367: LD_VAR 0 1
24371: PPUSH
24372: CALL_OW 255
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 2
24383: PUSH
24384: LD_INT 30
24386: PUSH
24387: LD_INT 36
24389: PUSH
24390: EMPTY
24391: LIST
24392: LIST
24393: PUSH
24394: LD_INT 34
24396: PUSH
24397: LD_INT 31
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: LIST
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PPUSH
24413: CALL_OW 69
24417: ST_TO_ADDR
// if not tmp then
24418: LD_VAR 0 6
24422: NOT
24423: IFFALSE 24427
// exit ;
24425: GO 24675
// result := [ ] ;
24427: LD_ADDR_VAR 0 2
24431: PUSH
24432: EMPTY
24433: ST_TO_ADDR
// for i in tmp do
24434: LD_ADDR_VAR 0 3
24438: PUSH
24439: LD_VAR 0 6
24443: PUSH
24444: FOR_IN
24445: IFFALSE 24516
// begin t := UnitsInside ( i ) ;
24447: LD_ADDR_VAR 0 4
24451: PUSH
24452: LD_VAR 0 3
24456: PPUSH
24457: CALL_OW 313
24461: ST_TO_ADDR
// if t then
24462: LD_VAR 0 4
24466: IFFALSE 24514
// for j in t do
24468: LD_ADDR_VAR 0 7
24472: PUSH
24473: LD_VAR 0 4
24477: PUSH
24478: FOR_IN
24479: IFFALSE 24512
// result := Replace ( result , result + 1 , j ) ;
24481: LD_ADDR_VAR 0 2
24485: PUSH
24486: LD_VAR 0 2
24490: PPUSH
24491: LD_VAR 0 2
24495: PUSH
24496: LD_INT 1
24498: PLUS
24499: PPUSH
24500: LD_VAR 0 7
24504: PPUSH
24505: CALL_OW 1
24509: ST_TO_ADDR
24510: GO 24478
24512: POP
24513: POP
// end ;
24514: GO 24444
24516: POP
24517: POP
// if not result then
24518: LD_VAR 0 2
24522: NOT
24523: IFFALSE 24527
// exit ;
24525: GO 24675
// mech := result [ 1 ] ;
24527: LD_ADDR_VAR 0 5
24531: PUSH
24532: LD_VAR 0 2
24536: PUSH
24537: LD_INT 1
24539: ARRAY
24540: ST_TO_ADDR
// if result > 1 then
24541: LD_VAR 0 2
24545: PUSH
24546: LD_INT 1
24548: GREATER
24549: IFFALSE 24661
// begin for i = 2 to result do
24551: LD_ADDR_VAR 0 3
24555: PUSH
24556: DOUBLE
24557: LD_INT 2
24559: DEC
24560: ST_TO_ADDR
24561: LD_VAR 0 2
24565: PUSH
24566: FOR_TO
24567: IFFALSE 24659
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24569: LD_ADDR_VAR 0 4
24573: PUSH
24574: LD_VAR 0 2
24578: PUSH
24579: LD_VAR 0 3
24583: ARRAY
24584: PPUSH
24585: LD_INT 3
24587: PPUSH
24588: CALL_OW 259
24592: PUSH
24593: LD_VAR 0 2
24597: PUSH
24598: LD_VAR 0 3
24602: ARRAY
24603: PPUSH
24604: CALL_OW 432
24608: MINUS
24609: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24610: LD_VAR 0 4
24614: PUSH
24615: LD_VAR 0 5
24619: PPUSH
24620: LD_INT 3
24622: PPUSH
24623: CALL_OW 259
24627: PUSH
24628: LD_VAR 0 5
24632: PPUSH
24633: CALL_OW 432
24637: MINUS
24638: GREATEREQUAL
24639: IFFALSE 24657
// mech := result [ i ] ;
24641: LD_ADDR_VAR 0 5
24645: PUSH
24646: LD_VAR 0 2
24650: PUSH
24651: LD_VAR 0 3
24655: ARRAY
24656: ST_TO_ADDR
// end ;
24657: GO 24566
24659: POP
24660: POP
// end ; ComLinkTo ( vehicle , mech ) ;
24661: LD_VAR 0 1
24665: PPUSH
24666: LD_VAR 0 5
24670: PPUSH
24671: CALL_OW 135
// end ;
24675: LD_VAR 0 2
24679: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24680: LD_INT 0
24682: PPUSH
24683: PPUSH
24684: PPUSH
24685: PPUSH
24686: PPUSH
24687: PPUSH
24688: PPUSH
24689: PPUSH
24690: PPUSH
24691: PPUSH
24692: PPUSH
24693: PPUSH
24694: PPUSH
// result := [ ] ;
24695: LD_ADDR_VAR 0 7
24699: PUSH
24700: EMPTY
24701: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24702: LD_VAR 0 1
24706: PPUSH
24707: CALL_OW 266
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 1
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: IN
24722: NOT
24723: IFFALSE 24727
// exit ;
24725: GO 26361
// if name then
24727: LD_VAR 0 3
24731: IFFALSE 24747
// SetBName ( base_dep , name ) ;
24733: LD_VAR 0 1
24737: PPUSH
24738: LD_VAR 0 3
24742: PPUSH
24743: CALL_OW 500
// base := GetBase ( base_dep ) ;
24747: LD_ADDR_VAR 0 15
24751: PUSH
24752: LD_VAR 0 1
24756: PPUSH
24757: CALL_OW 274
24761: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24762: LD_ADDR_VAR 0 16
24766: PUSH
24767: LD_VAR 0 1
24771: PPUSH
24772: CALL_OW 255
24776: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24777: LD_ADDR_VAR 0 17
24781: PUSH
24782: LD_VAR 0 1
24786: PPUSH
24787: CALL_OW 248
24791: ST_TO_ADDR
// if sources then
24792: LD_VAR 0 5
24796: IFFALSE 24843
// for i = 1 to 3 do
24798: LD_ADDR_VAR 0 8
24802: PUSH
24803: DOUBLE
24804: LD_INT 1
24806: DEC
24807: ST_TO_ADDR
24808: LD_INT 3
24810: PUSH
24811: FOR_TO
24812: IFFALSE 24841
// AddResourceType ( base , i , sources [ i ] ) ;
24814: LD_VAR 0 15
24818: PPUSH
24819: LD_VAR 0 8
24823: PPUSH
24824: LD_VAR 0 5
24828: PUSH
24829: LD_VAR 0 8
24833: ARRAY
24834: PPUSH
24835: CALL_OW 276
24839: GO 24811
24841: POP
24842: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
24843: LD_ADDR_VAR 0 18
24847: PUSH
24848: LD_VAR 0 15
24852: PPUSH
24853: LD_VAR 0 2
24857: PPUSH
24858: LD_INT 1
24860: PPUSH
24861: CALL 24104 0 3
24865: ST_TO_ADDR
// InitHc ;
24866: CALL_OW 19
// InitUc ;
24870: CALL_OW 18
// uc_side := side ;
24874: LD_ADDR_OWVAR 20
24878: PUSH
24879: LD_VAR 0 16
24883: ST_TO_ADDR
// uc_nation := nation ;
24884: LD_ADDR_OWVAR 21
24888: PUSH
24889: LD_VAR 0 17
24893: ST_TO_ADDR
// if buildings then
24894: LD_VAR 0 18
24898: IFFALSE 26220
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24900: LD_ADDR_VAR 0 19
24904: PUSH
24905: LD_VAR 0 18
24909: PPUSH
24910: LD_INT 2
24912: PUSH
24913: LD_INT 30
24915: PUSH
24916: LD_INT 29
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 30
24925: PUSH
24926: LD_INT 30
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: LIST
24937: PPUSH
24938: CALL_OW 72
24942: ST_TO_ADDR
// if tmp then
24943: LD_VAR 0 19
24947: IFFALSE 24995
// for i in tmp do
24949: LD_ADDR_VAR 0 8
24953: PUSH
24954: LD_VAR 0 19
24958: PUSH
24959: FOR_IN
24960: IFFALSE 24993
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24962: LD_VAR 0 8
24966: PPUSH
24967: CALL_OW 250
24971: PPUSH
24972: LD_VAR 0 8
24976: PPUSH
24977: CALL_OW 251
24981: PPUSH
24982: LD_VAR 0 16
24986: PPUSH
24987: CALL_OW 441
24991: GO 24959
24993: POP
24994: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24995: LD_VAR 0 18
24999: PPUSH
25000: LD_INT 2
25002: PUSH
25003: LD_INT 30
25005: PUSH
25006: LD_INT 32
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 30
25015: PUSH
25016: LD_INT 33
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: LIST
25027: PPUSH
25028: CALL_OW 72
25032: IFFALSE 25120
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
25034: LD_ADDR_VAR 0 8
25038: PUSH
25039: LD_VAR 0 18
25043: PPUSH
25044: LD_INT 2
25046: PUSH
25047: LD_INT 30
25049: PUSH
25050: LD_INT 32
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: PUSH
25057: LD_INT 30
25059: PUSH
25060: LD_INT 33
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: EMPTY
25068: LIST
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: PUSH
25077: FOR_IN
25078: IFFALSE 25118
// begin if not GetBWeapon ( i ) then
25080: LD_VAR 0 8
25084: PPUSH
25085: CALL_OW 269
25089: NOT
25090: IFFALSE 25116
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
25092: LD_VAR 0 8
25096: PPUSH
25097: LD_VAR 0 8
25101: PPUSH
25102: LD_VAR 0 2
25106: PPUSH
25107: CALL 26366 0 2
25111: PPUSH
25112: CALL_OW 431
// end ;
25116: GO 25077
25118: POP
25119: POP
// end ; for i = 1 to personel do
25120: LD_ADDR_VAR 0 8
25124: PUSH
25125: DOUBLE
25126: LD_INT 1
25128: DEC
25129: ST_TO_ADDR
25130: LD_VAR 0 6
25134: PUSH
25135: FOR_TO
25136: IFFALSE 26200
// begin if i > 4 then
25138: LD_VAR 0 8
25142: PUSH
25143: LD_INT 4
25145: GREATER
25146: IFFALSE 25150
// break ;
25148: GO 26200
// case i of 1 :
25150: LD_VAR 0 8
25154: PUSH
25155: LD_INT 1
25157: DOUBLE
25158: EQUAL
25159: IFTRUE 25163
25161: GO 25243
25163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25164: LD_ADDR_VAR 0 12
25168: PUSH
25169: LD_VAR 0 18
25173: PPUSH
25174: LD_INT 22
25176: PUSH
25177: LD_VAR 0 16
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 58
25188: PUSH
25189: EMPTY
25190: LIST
25191: PUSH
25192: LD_INT 2
25194: PUSH
25195: LD_INT 30
25197: PUSH
25198: LD_INT 32
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: PUSH
25205: LD_INT 30
25207: PUSH
25208: LD_INT 4
25210: PUSH
25211: EMPTY
25212: LIST
25213: LIST
25214: PUSH
25215: LD_INT 30
25217: PUSH
25218: LD_INT 5
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: LIST
25235: PPUSH
25236: CALL_OW 72
25240: ST_TO_ADDR
25241: GO 25465
25243: LD_INT 2
25245: DOUBLE
25246: EQUAL
25247: IFTRUE 25251
25249: GO 25313
25251: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25252: LD_ADDR_VAR 0 12
25256: PUSH
25257: LD_VAR 0 18
25261: PPUSH
25262: LD_INT 22
25264: PUSH
25265: LD_VAR 0 16
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: PUSH
25274: LD_INT 2
25276: PUSH
25277: LD_INT 30
25279: PUSH
25280: LD_INT 0
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: PUSH
25287: LD_INT 30
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: PUSH
25297: EMPTY
25298: LIST
25299: LIST
25300: LIST
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: PPUSH
25306: CALL_OW 72
25310: ST_TO_ADDR
25311: GO 25465
25313: LD_INT 3
25315: DOUBLE
25316: EQUAL
25317: IFTRUE 25321
25319: GO 25383
25321: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25322: LD_ADDR_VAR 0 12
25326: PUSH
25327: LD_VAR 0 18
25331: PPUSH
25332: LD_INT 22
25334: PUSH
25335: LD_VAR 0 16
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PUSH
25344: LD_INT 2
25346: PUSH
25347: LD_INT 30
25349: PUSH
25350: LD_INT 2
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: PUSH
25357: LD_INT 30
25359: PUSH
25360: LD_INT 3
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PPUSH
25376: CALL_OW 72
25380: ST_TO_ADDR
25381: GO 25465
25383: LD_INT 4
25385: DOUBLE
25386: EQUAL
25387: IFTRUE 25391
25389: GO 25464
25391: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25392: LD_ADDR_VAR 0 12
25396: PUSH
25397: LD_VAR 0 18
25401: PPUSH
25402: LD_INT 22
25404: PUSH
25405: LD_VAR 0 16
25409: PUSH
25410: EMPTY
25411: LIST
25412: LIST
25413: PUSH
25414: LD_INT 2
25416: PUSH
25417: LD_INT 30
25419: PUSH
25420: LD_INT 6
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 30
25429: PUSH
25430: LD_INT 7
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PUSH
25437: LD_INT 30
25439: PUSH
25440: LD_INT 8
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PPUSH
25457: CALL_OW 72
25461: ST_TO_ADDR
25462: GO 25465
25464: POP
// if i = 1 then
25465: LD_VAR 0 8
25469: PUSH
25470: LD_INT 1
25472: EQUAL
25473: IFFALSE 25584
// begin tmp := [ ] ;
25475: LD_ADDR_VAR 0 19
25479: PUSH
25480: EMPTY
25481: ST_TO_ADDR
// for j in f do
25482: LD_ADDR_VAR 0 9
25486: PUSH
25487: LD_VAR 0 12
25491: PUSH
25492: FOR_IN
25493: IFFALSE 25566
// if GetBType ( j ) = b_bunker then
25495: LD_VAR 0 9
25499: PPUSH
25500: CALL_OW 266
25504: PUSH
25505: LD_INT 32
25507: EQUAL
25508: IFFALSE 25535
// tmp := Insert ( tmp , 1 , j ) else
25510: LD_ADDR_VAR 0 19
25514: PUSH
25515: LD_VAR 0 19
25519: PPUSH
25520: LD_INT 1
25522: PPUSH
25523: LD_VAR 0 9
25527: PPUSH
25528: CALL_OW 2
25532: ST_TO_ADDR
25533: GO 25564
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25535: LD_ADDR_VAR 0 19
25539: PUSH
25540: LD_VAR 0 19
25544: PPUSH
25545: LD_VAR 0 19
25549: PUSH
25550: LD_INT 1
25552: PLUS
25553: PPUSH
25554: LD_VAR 0 9
25558: PPUSH
25559: CALL_OW 2
25563: ST_TO_ADDR
25564: GO 25492
25566: POP
25567: POP
// if tmp then
25568: LD_VAR 0 19
25572: IFFALSE 25584
// f := tmp ;
25574: LD_ADDR_VAR 0 12
25578: PUSH
25579: LD_VAR 0 19
25583: ST_TO_ADDR
// end ; x := personel [ i ] ;
25584: LD_ADDR_VAR 0 13
25588: PUSH
25589: LD_VAR 0 6
25593: PUSH
25594: LD_VAR 0 8
25598: ARRAY
25599: ST_TO_ADDR
// if x = - 1 then
25600: LD_VAR 0 13
25604: PUSH
25605: LD_INT 1
25607: NEG
25608: EQUAL
25609: IFFALSE 25818
// begin for j in f do
25611: LD_ADDR_VAR 0 9
25615: PUSH
25616: LD_VAR 0 12
25620: PUSH
25621: FOR_IN
25622: IFFALSE 25814
// repeat InitHc ;
25624: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25628: LD_VAR 0 9
25632: PPUSH
25633: CALL_OW 266
25637: PUSH
25638: LD_INT 5
25640: EQUAL
25641: IFFALSE 25711
// begin if UnitsInside ( j ) < 3 then
25643: LD_VAR 0 9
25647: PPUSH
25648: CALL_OW 313
25652: PUSH
25653: LD_INT 3
25655: LESS
25656: IFFALSE 25692
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25658: LD_INT 0
25660: PPUSH
25661: LD_INT 5
25663: PUSH
25664: LD_INT 8
25666: PUSH
25667: LD_INT 9
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: LIST
25674: PUSH
25675: LD_VAR 0 17
25679: ARRAY
25680: PPUSH
25681: LD_VAR 0 4
25685: PPUSH
25686: CALL_OW 380
25690: GO 25709
// PrepareHuman ( false , i , skill ) ;
25692: LD_INT 0
25694: PPUSH
25695: LD_VAR 0 8
25699: PPUSH
25700: LD_VAR 0 4
25704: PPUSH
25705: CALL_OW 380
// end else
25709: GO 25728
// PrepareHuman ( false , i , skill ) ;
25711: LD_INT 0
25713: PPUSH
25714: LD_VAR 0 8
25718: PPUSH
25719: LD_VAR 0 4
25723: PPUSH
25724: CALL_OW 380
// un := CreateHuman ;
25728: LD_ADDR_VAR 0 14
25732: PUSH
25733: CALL_OW 44
25737: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25738: LD_ADDR_VAR 0 7
25742: PUSH
25743: LD_VAR 0 7
25747: PPUSH
25748: LD_INT 1
25750: PPUSH
25751: LD_VAR 0 14
25755: PPUSH
25756: CALL_OW 2
25760: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25761: LD_VAR 0 14
25765: PPUSH
25766: LD_VAR 0 9
25770: PPUSH
25771: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25775: LD_VAR 0 9
25779: PPUSH
25780: CALL_OW 313
25784: PUSH
25785: LD_INT 6
25787: EQUAL
25788: PUSH
25789: LD_VAR 0 9
25793: PPUSH
25794: CALL_OW 266
25798: PUSH
25799: LD_INT 32
25801: PUSH
25802: LD_INT 31
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: IN
25809: OR
25810: IFFALSE 25624
25812: GO 25621
25814: POP
25815: POP
// end else
25816: GO 26198
// for j = 1 to x do
25818: LD_ADDR_VAR 0 9
25822: PUSH
25823: DOUBLE
25824: LD_INT 1
25826: DEC
25827: ST_TO_ADDR
25828: LD_VAR 0 13
25832: PUSH
25833: FOR_TO
25834: IFFALSE 26196
// begin InitHc ;
25836: CALL_OW 19
// if not f then
25840: LD_VAR 0 12
25844: NOT
25845: IFFALSE 25934
// begin PrepareHuman ( false , i , skill ) ;
25847: LD_INT 0
25849: PPUSH
25850: LD_VAR 0 8
25854: PPUSH
25855: LD_VAR 0 4
25859: PPUSH
25860: CALL_OW 380
// un := CreateHuman ;
25864: LD_ADDR_VAR 0 14
25868: PUSH
25869: CALL_OW 44
25873: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25874: LD_ADDR_VAR 0 7
25878: PUSH
25879: LD_VAR 0 7
25883: PPUSH
25884: LD_INT 1
25886: PPUSH
25887: LD_VAR 0 14
25891: PPUSH
25892: CALL_OW 2
25896: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25897: LD_VAR 0 14
25901: PPUSH
25902: LD_VAR 0 1
25906: PPUSH
25907: CALL_OW 250
25911: PPUSH
25912: LD_VAR 0 1
25916: PPUSH
25917: CALL_OW 251
25921: PPUSH
25922: LD_INT 10
25924: PPUSH
25925: LD_INT 0
25927: PPUSH
25928: CALL_OW 50
// continue ;
25932: GO 25833
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25934: LD_VAR 0 12
25938: PUSH
25939: LD_INT 1
25941: ARRAY
25942: PPUSH
25943: CALL_OW 313
25947: PUSH
25948: LD_VAR 0 12
25952: PUSH
25953: LD_INT 1
25955: ARRAY
25956: PPUSH
25957: CALL_OW 266
25961: PUSH
25962: LD_INT 32
25964: PUSH
25965: LD_INT 31
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: IN
25972: AND
25973: PUSH
25974: LD_VAR 0 12
25978: PUSH
25979: LD_INT 1
25981: ARRAY
25982: PPUSH
25983: CALL_OW 313
25987: PUSH
25988: LD_INT 6
25990: EQUAL
25991: OR
25992: IFFALSE 26012
// f := Delete ( f , 1 ) ;
25994: LD_ADDR_VAR 0 12
25998: PUSH
25999: LD_VAR 0 12
26003: PPUSH
26004: LD_INT 1
26006: PPUSH
26007: CALL_OW 3
26011: ST_TO_ADDR
// if not f then
26012: LD_VAR 0 12
26016: NOT
26017: IFFALSE 26035
// begin x := x + 2 ;
26019: LD_ADDR_VAR 0 13
26023: PUSH
26024: LD_VAR 0 13
26028: PUSH
26029: LD_INT 2
26031: PLUS
26032: ST_TO_ADDR
// continue ;
26033: GO 25833
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
26035: LD_VAR 0 12
26039: PUSH
26040: LD_INT 1
26042: ARRAY
26043: PPUSH
26044: CALL_OW 266
26048: PUSH
26049: LD_INT 5
26051: EQUAL
26052: IFFALSE 26126
// begin if UnitsInside ( f [ 1 ] ) < 3 then
26054: LD_VAR 0 12
26058: PUSH
26059: LD_INT 1
26061: ARRAY
26062: PPUSH
26063: CALL_OW 313
26067: PUSH
26068: LD_INT 3
26070: LESS
26071: IFFALSE 26107
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26073: LD_INT 0
26075: PPUSH
26076: LD_INT 5
26078: PUSH
26079: LD_INT 8
26081: PUSH
26082: LD_INT 9
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: LIST
26089: PUSH
26090: LD_VAR 0 17
26094: ARRAY
26095: PPUSH
26096: LD_VAR 0 4
26100: PPUSH
26101: CALL_OW 380
26105: GO 26124
// PrepareHuman ( false , i , skill ) ;
26107: LD_INT 0
26109: PPUSH
26110: LD_VAR 0 8
26114: PPUSH
26115: LD_VAR 0 4
26119: PPUSH
26120: CALL_OW 380
// end else
26124: GO 26143
// PrepareHuman ( false , i , skill ) ;
26126: LD_INT 0
26128: PPUSH
26129: LD_VAR 0 8
26133: PPUSH
26134: LD_VAR 0 4
26138: PPUSH
26139: CALL_OW 380
// un := CreateHuman ;
26143: LD_ADDR_VAR 0 14
26147: PUSH
26148: CALL_OW 44
26152: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26153: LD_ADDR_VAR 0 7
26157: PUSH
26158: LD_VAR 0 7
26162: PPUSH
26163: LD_INT 1
26165: PPUSH
26166: LD_VAR 0 14
26170: PPUSH
26171: CALL_OW 2
26175: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26176: LD_VAR 0 14
26180: PPUSH
26181: LD_VAR 0 12
26185: PUSH
26186: LD_INT 1
26188: ARRAY
26189: PPUSH
26190: CALL_OW 52
// end ;
26194: GO 25833
26196: POP
26197: POP
// end ;
26198: GO 25135
26200: POP
26201: POP
// result := result ^ buildings ;
26202: LD_ADDR_VAR 0 7
26206: PUSH
26207: LD_VAR 0 7
26211: PUSH
26212: LD_VAR 0 18
26216: ADD
26217: ST_TO_ADDR
// end else
26218: GO 26361
// begin for i = 1 to personel do
26220: LD_ADDR_VAR 0 8
26224: PUSH
26225: DOUBLE
26226: LD_INT 1
26228: DEC
26229: ST_TO_ADDR
26230: LD_VAR 0 6
26234: PUSH
26235: FOR_TO
26236: IFFALSE 26359
// begin if i > 4 then
26238: LD_VAR 0 8
26242: PUSH
26243: LD_INT 4
26245: GREATER
26246: IFFALSE 26250
// break ;
26248: GO 26359
// x := personel [ i ] ;
26250: LD_ADDR_VAR 0 13
26254: PUSH
26255: LD_VAR 0 6
26259: PUSH
26260: LD_VAR 0 8
26264: ARRAY
26265: ST_TO_ADDR
// if x = - 1 then
26266: LD_VAR 0 13
26270: PUSH
26271: LD_INT 1
26273: NEG
26274: EQUAL
26275: IFFALSE 26279
// continue ;
26277: GO 26235
// PrepareHuman ( false , i , skill ) ;
26279: LD_INT 0
26281: PPUSH
26282: LD_VAR 0 8
26286: PPUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: CALL_OW 380
// un := CreateHuman ;
26296: LD_ADDR_VAR 0 14
26300: PUSH
26301: CALL_OW 44
26305: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26306: LD_VAR 0 14
26310: PPUSH
26311: LD_VAR 0 1
26315: PPUSH
26316: CALL_OW 250
26320: PPUSH
26321: LD_VAR 0 1
26325: PPUSH
26326: CALL_OW 251
26330: PPUSH
26331: LD_INT 10
26333: PPUSH
26334: LD_INT 0
26336: PPUSH
26337: CALL_OW 50
// result := result ^ un ;
26341: LD_ADDR_VAR 0 7
26345: PUSH
26346: LD_VAR 0 7
26350: PUSH
26351: LD_VAR 0 14
26355: ADD
26356: ST_TO_ADDR
// end ;
26357: GO 26235
26359: POP
26360: POP
// end ; end ;
26361: LD_VAR 0 7
26365: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26366: LD_INT 0
26368: PPUSH
26369: PPUSH
26370: PPUSH
26371: PPUSH
26372: PPUSH
26373: PPUSH
26374: PPUSH
26375: PPUSH
26376: PPUSH
26377: PPUSH
26378: PPUSH
26379: PPUSH
26380: PPUSH
26381: PPUSH
26382: PPUSH
26383: PPUSH
// result := false ;
26384: LD_ADDR_VAR 0 3
26388: PUSH
26389: LD_INT 0
26391: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26392: LD_VAR 0 1
26396: NOT
26397: PUSH
26398: LD_VAR 0 1
26402: PPUSH
26403: CALL_OW 266
26407: PUSH
26408: LD_INT 32
26410: PUSH
26411: LD_INT 33
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: IN
26418: NOT
26419: OR
26420: IFFALSE 26424
// exit ;
26422: GO 27533
// nat := GetNation ( tower ) ;
26424: LD_ADDR_VAR 0 12
26428: PUSH
26429: LD_VAR 0 1
26433: PPUSH
26434: CALL_OW 248
26438: ST_TO_ADDR
// side := GetSide ( tower ) ;
26439: LD_ADDR_VAR 0 16
26443: PUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 255
26453: ST_TO_ADDR
// x := GetX ( tower ) ;
26454: LD_ADDR_VAR 0 10
26458: PUSH
26459: LD_VAR 0 1
26463: PPUSH
26464: CALL_OW 250
26468: ST_TO_ADDR
// y := GetY ( tower ) ;
26469: LD_ADDR_VAR 0 11
26473: PUSH
26474: LD_VAR 0 1
26478: PPUSH
26479: CALL_OW 251
26483: ST_TO_ADDR
// if not x or not y then
26484: LD_VAR 0 10
26488: NOT
26489: PUSH
26490: LD_VAR 0 11
26494: NOT
26495: OR
26496: IFFALSE 26500
// exit ;
26498: GO 27533
// weapon := 0 ;
26500: LD_ADDR_VAR 0 18
26504: PUSH
26505: LD_INT 0
26507: ST_TO_ADDR
// fac_list := [ ] ;
26508: LD_ADDR_VAR 0 17
26512: PUSH
26513: EMPTY
26514: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
26515: LD_ADDR_VAR 0 6
26519: PUSH
26520: LD_VAR 0 1
26524: PPUSH
26525: CALL_OW 274
26529: PPUSH
26530: LD_VAR 0 2
26534: PPUSH
26535: LD_INT 0
26537: PPUSH
26538: CALL 24104 0 3
26542: PPUSH
26543: LD_INT 30
26545: PUSH
26546: LD_INT 3
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PPUSH
26553: CALL_OW 72
26557: ST_TO_ADDR
// if not factories then
26558: LD_VAR 0 6
26562: NOT
26563: IFFALSE 26567
// exit ;
26565: GO 27533
// for i in factories do
26567: LD_ADDR_VAR 0 8
26571: PUSH
26572: LD_VAR 0 6
26576: PUSH
26577: FOR_IN
26578: IFFALSE 26603
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26580: LD_ADDR_VAR 0 17
26584: PUSH
26585: LD_VAR 0 17
26589: PUSH
26590: LD_VAR 0 8
26594: PPUSH
26595: CALL_OW 478
26599: UNION
26600: ST_TO_ADDR
26601: GO 26577
26603: POP
26604: POP
// if not fac_list then
26605: LD_VAR 0 17
26609: NOT
26610: IFFALSE 26614
// exit ;
26612: GO 27533
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26614: LD_ADDR_VAR 0 5
26618: PUSH
26619: LD_INT 4
26621: PUSH
26622: LD_INT 5
26624: PUSH
26625: LD_INT 9
26627: PUSH
26628: LD_INT 10
26630: PUSH
26631: LD_INT 6
26633: PUSH
26634: LD_INT 7
26636: PUSH
26637: LD_INT 11
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 27
26651: PUSH
26652: LD_INT 28
26654: PUSH
26655: LD_INT 26
26657: PUSH
26658: LD_INT 30
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: PUSH
26667: LD_INT 43
26669: PUSH
26670: LD_INT 44
26672: PUSH
26673: LD_INT 46
26675: PUSH
26676: LD_INT 45
26678: PUSH
26679: LD_INT 47
26681: PUSH
26682: LD_INT 49
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: LIST
26689: LIST
26690: LIST
26691: LIST
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: LIST
26697: PUSH
26698: LD_VAR 0 12
26702: ARRAY
26703: ST_TO_ADDR
// list := list isect fac_list ;
26704: LD_ADDR_VAR 0 5
26708: PUSH
26709: LD_VAR 0 5
26713: PUSH
26714: LD_VAR 0 17
26718: ISECT
26719: ST_TO_ADDR
// if not list then
26720: LD_VAR 0 5
26724: NOT
26725: IFFALSE 26729
// exit ;
26727: GO 27533
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26729: LD_VAR 0 12
26733: PUSH
26734: LD_INT 3
26736: EQUAL
26737: PUSH
26738: LD_INT 49
26740: PUSH
26741: LD_VAR 0 5
26745: IN
26746: AND
26747: PUSH
26748: LD_INT 31
26750: PPUSH
26751: LD_VAR 0 16
26755: PPUSH
26756: CALL_OW 321
26760: PUSH
26761: LD_INT 2
26763: EQUAL
26764: AND
26765: IFFALSE 26825
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26767: LD_INT 22
26769: PUSH
26770: LD_VAR 0 16
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: LD_INT 35
26781: PUSH
26782: LD_INT 49
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 91
26791: PUSH
26792: LD_VAR 0 1
26796: PUSH
26797: LD_INT 10
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: LIST
26804: PUSH
26805: EMPTY
26806: LIST
26807: LIST
26808: LIST
26809: PPUSH
26810: CALL_OW 69
26814: NOT
26815: IFFALSE 26825
// weapon := ru_time_lapser ;
26817: LD_ADDR_VAR 0 18
26821: PUSH
26822: LD_INT 49
26824: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26825: LD_VAR 0 12
26829: PUSH
26830: LD_INT 1
26832: PUSH
26833: LD_INT 2
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: IN
26840: PUSH
26841: LD_INT 11
26843: PUSH
26844: LD_VAR 0 5
26848: IN
26849: PUSH
26850: LD_INT 30
26852: PUSH
26853: LD_VAR 0 5
26857: IN
26858: OR
26859: AND
26860: PUSH
26861: LD_INT 6
26863: PPUSH
26864: LD_VAR 0 16
26868: PPUSH
26869: CALL_OW 321
26873: PUSH
26874: LD_INT 2
26876: EQUAL
26877: AND
26878: IFFALSE 27043
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26880: LD_INT 22
26882: PUSH
26883: LD_VAR 0 16
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: LD_INT 2
26894: PUSH
26895: LD_INT 35
26897: PUSH
26898: LD_INT 11
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 35
26907: PUSH
26908: LD_INT 30
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 91
26922: PUSH
26923: LD_VAR 0 1
26927: PUSH
26928: LD_INT 18
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: LIST
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: LIST
26940: PPUSH
26941: CALL_OW 69
26945: NOT
26946: PUSH
26947: LD_INT 22
26949: PUSH
26950: LD_VAR 0 16
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 2
26961: PUSH
26962: LD_INT 30
26964: PUSH
26965: LD_INT 32
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 30
26974: PUSH
26975: LD_INT 33
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: LIST
26986: PUSH
26987: LD_INT 91
26989: PUSH
26990: LD_VAR 0 1
26994: PUSH
26995: LD_INT 12
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: LIST
27007: PUSH
27008: EMPTY
27009: LIST
27010: PPUSH
27011: CALL_OW 69
27015: PUSH
27016: LD_INT 2
27018: GREATER
27019: AND
27020: IFFALSE 27043
// weapon := [ us_radar , ar_radar ] [ nat ] ;
27022: LD_ADDR_VAR 0 18
27026: PUSH
27027: LD_INT 11
27029: PUSH
27030: LD_INT 30
27032: PUSH
27033: EMPTY
27034: LIST
27035: LIST
27036: PUSH
27037: LD_VAR 0 12
27041: ARRAY
27042: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
27043: LD_VAR 0 18
27047: NOT
27048: PUSH
27049: LD_INT 40
27051: PPUSH
27052: LD_VAR 0 16
27056: PPUSH
27057: CALL_OW 321
27061: PUSH
27062: LD_INT 2
27064: EQUAL
27065: AND
27066: PUSH
27067: LD_INT 7
27069: PUSH
27070: LD_VAR 0 5
27074: IN
27075: PUSH
27076: LD_INT 28
27078: PUSH
27079: LD_VAR 0 5
27083: IN
27084: OR
27085: PUSH
27086: LD_INT 45
27088: PUSH
27089: LD_VAR 0 5
27093: IN
27094: OR
27095: AND
27096: IFFALSE 27350
// begin hex := GetHexInfo ( x , y ) ;
27098: LD_ADDR_VAR 0 4
27102: PUSH
27103: LD_VAR 0 10
27107: PPUSH
27108: LD_VAR 0 11
27112: PPUSH
27113: CALL_OW 546
27117: ST_TO_ADDR
// if hex [ 1 ] then
27118: LD_VAR 0 4
27122: PUSH
27123: LD_INT 1
27125: ARRAY
27126: IFFALSE 27130
// exit ;
27128: GO 27533
// height := hex [ 2 ] ;
27130: LD_ADDR_VAR 0 15
27134: PUSH
27135: LD_VAR 0 4
27139: PUSH
27140: LD_INT 2
27142: ARRAY
27143: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27144: LD_ADDR_VAR 0 14
27148: PUSH
27149: LD_INT 0
27151: PUSH
27152: LD_INT 2
27154: PUSH
27155: LD_INT 3
27157: PUSH
27158: LD_INT 5
27160: PUSH
27161: EMPTY
27162: LIST
27163: LIST
27164: LIST
27165: LIST
27166: ST_TO_ADDR
// for i in tmp do
27167: LD_ADDR_VAR 0 8
27171: PUSH
27172: LD_VAR 0 14
27176: PUSH
27177: FOR_IN
27178: IFFALSE 27348
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27180: LD_ADDR_VAR 0 9
27184: PUSH
27185: LD_VAR 0 10
27189: PPUSH
27190: LD_VAR 0 8
27194: PPUSH
27195: LD_INT 5
27197: PPUSH
27198: CALL_OW 272
27202: PUSH
27203: LD_VAR 0 11
27207: PPUSH
27208: LD_VAR 0 8
27212: PPUSH
27213: LD_INT 5
27215: PPUSH
27216: CALL_OW 273
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27225: LD_VAR 0 9
27229: PUSH
27230: LD_INT 1
27232: ARRAY
27233: PPUSH
27234: LD_VAR 0 9
27238: PUSH
27239: LD_INT 2
27241: ARRAY
27242: PPUSH
27243: CALL_OW 488
27247: IFFALSE 27346
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27249: LD_ADDR_VAR 0 4
27253: PUSH
27254: LD_VAR 0 9
27258: PUSH
27259: LD_INT 1
27261: ARRAY
27262: PPUSH
27263: LD_VAR 0 9
27267: PUSH
27268: LD_INT 2
27270: ARRAY
27271: PPUSH
27272: CALL_OW 546
27276: ST_TO_ADDR
// if hex [ 1 ] then
27277: LD_VAR 0 4
27281: PUSH
27282: LD_INT 1
27284: ARRAY
27285: IFFALSE 27289
// continue ;
27287: GO 27177
// h := hex [ 2 ] ;
27289: LD_ADDR_VAR 0 13
27293: PUSH
27294: LD_VAR 0 4
27298: PUSH
27299: LD_INT 2
27301: ARRAY
27302: ST_TO_ADDR
// if h + 7 < height then
27303: LD_VAR 0 13
27307: PUSH
27308: LD_INT 7
27310: PLUS
27311: PUSH
27312: LD_VAR 0 15
27316: LESS
27317: IFFALSE 27346
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27319: LD_ADDR_VAR 0 18
27323: PUSH
27324: LD_INT 7
27326: PUSH
27327: LD_INT 28
27329: PUSH
27330: LD_INT 45
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: LIST
27337: PUSH
27338: LD_VAR 0 12
27342: ARRAY
27343: ST_TO_ADDR
// break ;
27344: GO 27348
// end ; end ; end ;
27346: GO 27177
27348: POP
27349: POP
// end ; if not weapon then
27350: LD_VAR 0 18
27354: NOT
27355: IFFALSE 27415
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27357: LD_ADDR_VAR 0 5
27361: PUSH
27362: LD_VAR 0 5
27366: PUSH
27367: LD_INT 11
27369: PUSH
27370: LD_INT 30
27372: PUSH
27373: LD_INT 49
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: LIST
27380: DIFF
27381: ST_TO_ADDR
// if not list then
27382: LD_VAR 0 5
27386: NOT
27387: IFFALSE 27391
// exit ;
27389: GO 27533
// weapon := list [ rand ( 1 , list ) ] ;
27391: LD_ADDR_VAR 0 18
27395: PUSH
27396: LD_VAR 0 5
27400: PUSH
27401: LD_INT 1
27403: PPUSH
27404: LD_VAR 0 5
27408: PPUSH
27409: CALL_OW 12
27413: ARRAY
27414: ST_TO_ADDR
// end ; if weapon then
27415: LD_VAR 0 18
27419: IFFALSE 27533
// begin tmp := CostOfWeapon ( weapon ) ;
27421: LD_ADDR_VAR 0 14
27425: PUSH
27426: LD_VAR 0 18
27430: PPUSH
27431: CALL_OW 451
27435: ST_TO_ADDR
// j := GetBase ( tower ) ;
27436: LD_ADDR_VAR 0 9
27440: PUSH
27441: LD_VAR 0 1
27445: PPUSH
27446: CALL_OW 274
27450: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27451: LD_VAR 0 9
27455: PPUSH
27456: LD_INT 1
27458: PPUSH
27459: CALL_OW 275
27463: PUSH
27464: LD_VAR 0 14
27468: PUSH
27469: LD_INT 1
27471: ARRAY
27472: GREATEREQUAL
27473: PUSH
27474: LD_VAR 0 9
27478: PPUSH
27479: LD_INT 2
27481: PPUSH
27482: CALL_OW 275
27486: PUSH
27487: LD_VAR 0 14
27491: PUSH
27492: LD_INT 2
27494: ARRAY
27495: GREATEREQUAL
27496: AND
27497: PUSH
27498: LD_VAR 0 9
27502: PPUSH
27503: LD_INT 3
27505: PPUSH
27506: CALL_OW 275
27510: PUSH
27511: LD_VAR 0 14
27515: PUSH
27516: LD_INT 3
27518: ARRAY
27519: GREATEREQUAL
27520: AND
27521: IFFALSE 27533
// result := weapon ;
27523: LD_ADDR_VAR 0 3
27527: PUSH
27528: LD_VAR 0 18
27532: ST_TO_ADDR
// end ; end ;
27533: LD_VAR 0 3
27537: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27538: LD_INT 0
27540: PPUSH
27541: PPUSH
// result := true ;
27542: LD_ADDR_VAR 0 3
27546: PUSH
27547: LD_INT 1
27549: ST_TO_ADDR
// if array1 = array2 then
27550: LD_VAR 0 1
27554: PUSH
27555: LD_VAR 0 2
27559: EQUAL
27560: IFFALSE 27620
// begin for i = 1 to array1 do
27562: LD_ADDR_VAR 0 4
27566: PUSH
27567: DOUBLE
27568: LD_INT 1
27570: DEC
27571: ST_TO_ADDR
27572: LD_VAR 0 1
27576: PUSH
27577: FOR_TO
27578: IFFALSE 27616
// if array1 [ i ] <> array2 [ i ] then
27580: LD_VAR 0 1
27584: PUSH
27585: LD_VAR 0 4
27589: ARRAY
27590: PUSH
27591: LD_VAR 0 2
27595: PUSH
27596: LD_VAR 0 4
27600: ARRAY
27601: NONEQUAL
27602: IFFALSE 27614
// begin result := false ;
27604: LD_ADDR_VAR 0 3
27608: PUSH
27609: LD_INT 0
27611: ST_TO_ADDR
// break ;
27612: GO 27616
// end ;
27614: GO 27577
27616: POP
27617: POP
// end else
27618: GO 27628
// result := false ;
27620: LD_ADDR_VAR 0 3
27624: PUSH
27625: LD_INT 0
27627: ST_TO_ADDR
// end ;
27628: LD_VAR 0 3
27632: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
27633: LD_INT 0
27635: PPUSH
27636: PPUSH
// if not array1 or not array2 then
27637: LD_VAR 0 1
27641: NOT
27642: PUSH
27643: LD_VAR 0 2
27647: NOT
27648: OR
27649: IFFALSE 27653
// exit ;
27651: GO 27717
// result := true ;
27653: LD_ADDR_VAR 0 3
27657: PUSH
27658: LD_INT 1
27660: ST_TO_ADDR
// for i = 1 to array1 do
27661: LD_ADDR_VAR 0 4
27665: PUSH
27666: DOUBLE
27667: LD_INT 1
27669: DEC
27670: ST_TO_ADDR
27671: LD_VAR 0 1
27675: PUSH
27676: FOR_TO
27677: IFFALSE 27715
// if array1 [ i ] <> array2 [ i ] then
27679: LD_VAR 0 1
27683: PUSH
27684: LD_VAR 0 4
27688: ARRAY
27689: PUSH
27690: LD_VAR 0 2
27694: PUSH
27695: LD_VAR 0 4
27699: ARRAY
27700: NONEQUAL
27701: IFFALSE 27713
// begin result := false ;
27703: LD_ADDR_VAR 0 3
27707: PUSH
27708: LD_INT 0
27710: ST_TO_ADDR
// break ;
27711: GO 27715
// end ;
27713: GO 27676
27715: POP
27716: POP
// end ;
27717: LD_VAR 0 3
27721: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27722: LD_INT 0
27724: PPUSH
27725: PPUSH
27726: PPUSH
// pom := GetBase ( fac ) ;
27727: LD_ADDR_VAR 0 5
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 274
27741: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27742: LD_ADDR_VAR 0 4
27746: PUSH
27747: LD_VAR 0 2
27751: PUSH
27752: LD_INT 1
27754: ARRAY
27755: PPUSH
27756: LD_VAR 0 2
27760: PUSH
27761: LD_INT 2
27763: ARRAY
27764: PPUSH
27765: LD_VAR 0 2
27769: PUSH
27770: LD_INT 3
27772: ARRAY
27773: PPUSH
27774: LD_VAR 0 2
27778: PUSH
27779: LD_INT 4
27781: ARRAY
27782: PPUSH
27783: CALL_OW 449
27787: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27788: LD_ADDR_VAR 0 3
27792: PUSH
27793: LD_VAR 0 5
27797: PPUSH
27798: LD_INT 1
27800: PPUSH
27801: CALL_OW 275
27805: PUSH
27806: LD_VAR 0 4
27810: PUSH
27811: LD_INT 1
27813: ARRAY
27814: GREATEREQUAL
27815: PUSH
27816: LD_VAR 0 5
27820: PPUSH
27821: LD_INT 2
27823: PPUSH
27824: CALL_OW 275
27828: PUSH
27829: LD_VAR 0 4
27833: PUSH
27834: LD_INT 2
27836: ARRAY
27837: GREATEREQUAL
27838: AND
27839: PUSH
27840: LD_VAR 0 5
27844: PPUSH
27845: LD_INT 3
27847: PPUSH
27848: CALL_OW 275
27852: PUSH
27853: LD_VAR 0 4
27857: PUSH
27858: LD_INT 3
27860: ARRAY
27861: GREATEREQUAL
27862: AND
27863: ST_TO_ADDR
// end ;
27864: LD_VAR 0 3
27868: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27869: LD_INT 0
27871: PPUSH
27872: PPUSH
27873: PPUSH
27874: PPUSH
// pom := GetBase ( building ) ;
27875: LD_ADDR_VAR 0 3
27879: PUSH
27880: LD_VAR 0 1
27884: PPUSH
27885: CALL_OW 274
27889: ST_TO_ADDR
// if not pom then
27890: LD_VAR 0 3
27894: NOT
27895: IFFALSE 27899
// exit ;
27897: GO 28069
// btype := GetBType ( building ) ;
27899: LD_ADDR_VAR 0 5
27903: PUSH
27904: LD_VAR 0 1
27908: PPUSH
27909: CALL_OW 266
27913: ST_TO_ADDR
// if btype = b_armoury then
27914: LD_VAR 0 5
27918: PUSH
27919: LD_INT 4
27921: EQUAL
27922: IFFALSE 27932
// btype := b_barracks ;
27924: LD_ADDR_VAR 0 5
27928: PUSH
27929: LD_INT 5
27931: ST_TO_ADDR
// if btype = b_depot then
27932: LD_VAR 0 5
27936: PUSH
27937: LD_INT 0
27939: EQUAL
27940: IFFALSE 27950
// btype := b_warehouse ;
27942: LD_ADDR_VAR 0 5
27946: PUSH
27947: LD_INT 1
27949: ST_TO_ADDR
// if btype = b_workshop then
27950: LD_VAR 0 5
27954: PUSH
27955: LD_INT 2
27957: EQUAL
27958: IFFALSE 27968
// btype := b_factory ;
27960: LD_ADDR_VAR 0 5
27964: PUSH
27965: LD_INT 3
27967: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27968: LD_ADDR_VAR 0 4
27972: PUSH
27973: LD_VAR 0 5
27977: PPUSH
27978: LD_VAR 0 1
27982: PPUSH
27983: CALL_OW 248
27987: PPUSH
27988: CALL_OW 450
27992: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27993: LD_ADDR_VAR 0 2
27997: PUSH
27998: LD_VAR 0 3
28002: PPUSH
28003: LD_INT 1
28005: PPUSH
28006: CALL_OW 275
28010: PUSH
28011: LD_VAR 0 4
28015: PUSH
28016: LD_INT 1
28018: ARRAY
28019: GREATEREQUAL
28020: PUSH
28021: LD_VAR 0 3
28025: PPUSH
28026: LD_INT 2
28028: PPUSH
28029: CALL_OW 275
28033: PUSH
28034: LD_VAR 0 4
28038: PUSH
28039: LD_INT 2
28041: ARRAY
28042: GREATEREQUAL
28043: AND
28044: PUSH
28045: LD_VAR 0 3
28049: PPUSH
28050: LD_INT 3
28052: PPUSH
28053: CALL_OW 275
28057: PUSH
28058: LD_VAR 0 4
28062: PUSH
28063: LD_INT 3
28065: ARRAY
28066: GREATEREQUAL
28067: AND
28068: ST_TO_ADDR
// end ;
28069: LD_VAR 0 2
28073: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
28074: LD_INT 0
28076: PPUSH
28077: PPUSH
28078: PPUSH
// pom := GetBase ( building ) ;
28079: LD_ADDR_VAR 0 4
28083: PUSH
28084: LD_VAR 0 1
28088: PPUSH
28089: CALL_OW 274
28093: ST_TO_ADDR
// if not pom then
28094: LD_VAR 0 4
28098: NOT
28099: IFFALSE 28103
// exit ;
28101: GO 28204
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28103: LD_ADDR_VAR 0 5
28107: PUSH
28108: LD_VAR 0 2
28112: PPUSH
28113: LD_VAR 0 1
28117: PPUSH
28118: CALL_OW 248
28122: PPUSH
28123: CALL_OW 450
28127: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28128: LD_ADDR_VAR 0 3
28132: PUSH
28133: LD_VAR 0 4
28137: PPUSH
28138: LD_INT 1
28140: PPUSH
28141: CALL_OW 275
28145: PUSH
28146: LD_VAR 0 5
28150: PUSH
28151: LD_INT 1
28153: ARRAY
28154: GREATEREQUAL
28155: PUSH
28156: LD_VAR 0 4
28160: PPUSH
28161: LD_INT 2
28163: PPUSH
28164: CALL_OW 275
28168: PUSH
28169: LD_VAR 0 5
28173: PUSH
28174: LD_INT 2
28176: ARRAY
28177: GREATEREQUAL
28178: AND
28179: PUSH
28180: LD_VAR 0 4
28184: PPUSH
28185: LD_INT 3
28187: PPUSH
28188: CALL_OW 275
28192: PUSH
28193: LD_VAR 0 5
28197: PUSH
28198: LD_INT 3
28200: ARRAY
28201: GREATEREQUAL
28202: AND
28203: ST_TO_ADDR
// end ;
28204: LD_VAR 0 3
28208: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
28209: LD_INT 0
28211: PPUSH
28212: PPUSH
28213: PPUSH
28214: PPUSH
28215: PPUSH
28216: PPUSH
28217: PPUSH
28218: PPUSH
28219: PPUSH
28220: PPUSH
28221: PPUSH
// result := false ;
28222: LD_ADDR_VAR 0 8
28226: PUSH
28227: LD_INT 0
28229: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
28230: LD_VAR 0 5
28234: NOT
28235: PUSH
28236: LD_VAR 0 1
28240: NOT
28241: OR
28242: PUSH
28243: LD_VAR 0 2
28247: NOT
28248: OR
28249: PUSH
28250: LD_VAR 0 3
28254: NOT
28255: OR
28256: IFFALSE 28260
// exit ;
28258: GO 29074
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
28260: LD_ADDR_VAR 0 14
28264: PUSH
28265: LD_VAR 0 1
28269: PPUSH
28270: LD_VAR 0 2
28274: PPUSH
28275: LD_VAR 0 3
28279: PPUSH
28280: LD_VAR 0 4
28284: PPUSH
28285: LD_VAR 0 5
28289: PUSH
28290: LD_INT 1
28292: ARRAY
28293: PPUSH
28294: CALL_OW 248
28298: PPUSH
28299: LD_INT 0
28301: PPUSH
28302: CALL 30327 0 6
28306: ST_TO_ADDR
// if not hexes then
28307: LD_VAR 0 14
28311: NOT
28312: IFFALSE 28316
// exit ;
28314: GO 29074
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28316: LD_ADDR_VAR 0 17
28320: PUSH
28321: LD_VAR 0 5
28325: PPUSH
28326: LD_INT 22
28328: PUSH
28329: LD_VAR 0 13
28333: PPUSH
28334: CALL_OW 255
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: PUSH
28343: LD_INT 2
28345: PUSH
28346: LD_INT 30
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 30
28358: PUSH
28359: LD_INT 1
28361: PUSH
28362: EMPTY
28363: LIST
28364: LIST
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: LIST
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: PPUSH
28375: CALL_OW 72
28379: ST_TO_ADDR
// for i = 1 to hexes do
28380: LD_ADDR_VAR 0 9
28384: PUSH
28385: DOUBLE
28386: LD_INT 1
28388: DEC
28389: ST_TO_ADDR
28390: LD_VAR 0 14
28394: PUSH
28395: FOR_TO
28396: IFFALSE 29072
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28398: LD_ADDR_VAR 0 13
28402: PUSH
28403: LD_VAR 0 14
28407: PUSH
28408: LD_VAR 0 9
28412: ARRAY
28413: PUSH
28414: LD_INT 1
28416: ARRAY
28417: PPUSH
28418: LD_VAR 0 14
28422: PUSH
28423: LD_VAR 0 9
28427: ARRAY
28428: PUSH
28429: LD_INT 2
28431: ARRAY
28432: PPUSH
28433: CALL_OW 428
28437: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28438: LD_VAR 0 14
28442: PUSH
28443: LD_VAR 0 9
28447: ARRAY
28448: PUSH
28449: LD_INT 1
28451: ARRAY
28452: PPUSH
28453: LD_VAR 0 14
28457: PUSH
28458: LD_VAR 0 9
28462: ARRAY
28463: PUSH
28464: LD_INT 2
28466: ARRAY
28467: PPUSH
28468: CALL_OW 351
28472: PUSH
28473: LD_VAR 0 14
28477: PUSH
28478: LD_VAR 0 9
28482: ARRAY
28483: PUSH
28484: LD_INT 1
28486: ARRAY
28487: PPUSH
28488: LD_VAR 0 14
28492: PUSH
28493: LD_VAR 0 9
28497: ARRAY
28498: PUSH
28499: LD_INT 2
28501: ARRAY
28502: PPUSH
28503: CALL_OW 488
28507: NOT
28508: OR
28509: PUSH
28510: LD_VAR 0 13
28514: PPUSH
28515: CALL_OW 247
28519: PUSH
28520: LD_INT 3
28522: EQUAL
28523: OR
28524: IFFALSE 28530
// exit ;
28526: POP
28527: POP
28528: GO 29074
// if not tmp then
28530: LD_VAR 0 13
28534: NOT
28535: IFFALSE 28539
// continue ;
28537: GO 28395
// result := true ;
28539: LD_ADDR_VAR 0 8
28543: PUSH
28544: LD_INT 1
28546: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
28547: LD_VAR 0 6
28551: PUSH
28552: LD_VAR 0 13
28556: PPUSH
28557: CALL_OW 247
28561: PUSH
28562: LD_INT 2
28564: EQUAL
28565: AND
28566: PUSH
28567: LD_VAR 0 13
28571: PPUSH
28572: CALL_OW 263
28576: PUSH
28577: LD_INT 1
28579: EQUAL
28580: AND
28581: IFFALSE 28745
// begin if IsDrivenBy ( tmp ) then
28583: LD_VAR 0 13
28587: PPUSH
28588: CALL_OW 311
28592: IFFALSE 28596
// continue ;
28594: GO 28395
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
28596: LD_VAR 0 6
28600: PPUSH
28601: LD_INT 3
28603: PUSH
28604: LD_INT 60
28606: PUSH
28607: EMPTY
28608: LIST
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: LD_INT 3
28616: PUSH
28617: LD_INT 55
28619: PUSH
28620: EMPTY
28621: LIST
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: EMPTY
28628: LIST
28629: LIST
28630: PPUSH
28631: CALL_OW 72
28635: IFFALSE 28743
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
28637: LD_ADDR_VAR 0 18
28641: PUSH
28642: LD_VAR 0 6
28646: PPUSH
28647: LD_INT 3
28649: PUSH
28650: LD_INT 60
28652: PUSH
28653: EMPTY
28654: LIST
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 3
28662: PUSH
28663: LD_INT 55
28665: PUSH
28666: EMPTY
28667: LIST
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PPUSH
28677: CALL_OW 72
28681: PUSH
28682: LD_INT 1
28684: ARRAY
28685: ST_TO_ADDR
// if IsInUnit ( driver ) then
28686: LD_VAR 0 18
28690: PPUSH
28691: CALL_OW 310
28695: IFFALSE 28706
// ComExit ( driver ) ;
28697: LD_VAR 0 18
28701: PPUSH
28702: CALL 54119 0 1
// AddComEnterUnit ( driver , tmp ) ;
28706: LD_VAR 0 18
28710: PPUSH
28711: LD_VAR 0 13
28715: PPUSH
28716: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
28720: LD_VAR 0 18
28724: PPUSH
28725: LD_VAR 0 7
28729: PPUSH
28730: CALL_OW 173
// AddComExitVehicle ( driver ) ;
28734: LD_VAR 0 18
28738: PPUSH
28739: CALL_OW 181
// end ; continue ;
28743: GO 28395
// end ; if not cleaners or not tmp in cleaners then
28745: LD_VAR 0 6
28749: NOT
28750: PUSH
28751: LD_VAR 0 13
28755: PUSH
28756: LD_VAR 0 6
28760: IN
28761: NOT
28762: OR
28763: IFFALSE 29070
// begin if dep then
28765: LD_VAR 0 17
28769: IFFALSE 28905
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28771: LD_ADDR_VAR 0 16
28775: PUSH
28776: LD_VAR 0 17
28780: PUSH
28781: LD_INT 1
28783: ARRAY
28784: PPUSH
28785: CALL_OW 250
28789: PPUSH
28790: LD_VAR 0 17
28794: PUSH
28795: LD_INT 1
28797: ARRAY
28798: PPUSH
28799: CALL_OW 254
28803: PPUSH
28804: LD_INT 5
28806: PPUSH
28807: CALL_OW 272
28811: PUSH
28812: LD_VAR 0 17
28816: PUSH
28817: LD_INT 1
28819: ARRAY
28820: PPUSH
28821: CALL_OW 251
28825: PPUSH
28826: LD_VAR 0 17
28830: PUSH
28831: LD_INT 1
28833: ARRAY
28834: PPUSH
28835: CALL_OW 254
28839: PPUSH
28840: LD_INT 5
28842: PPUSH
28843: CALL_OW 273
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28852: LD_VAR 0 16
28856: PUSH
28857: LD_INT 1
28859: ARRAY
28860: PPUSH
28861: LD_VAR 0 16
28865: PUSH
28866: LD_INT 2
28868: ARRAY
28869: PPUSH
28870: CALL_OW 488
28874: IFFALSE 28905
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28876: LD_VAR 0 13
28880: PPUSH
28881: LD_VAR 0 16
28885: PUSH
28886: LD_INT 1
28888: ARRAY
28889: PPUSH
28890: LD_VAR 0 16
28894: PUSH
28895: LD_INT 2
28897: ARRAY
28898: PPUSH
28899: CALL_OW 111
// continue ;
28903: GO 28395
// end ; end ; r := GetDir ( tmp ) ;
28905: LD_ADDR_VAR 0 15
28909: PUSH
28910: LD_VAR 0 13
28914: PPUSH
28915: CALL_OW 254
28919: ST_TO_ADDR
// if r = 5 then
28920: LD_VAR 0 15
28924: PUSH
28925: LD_INT 5
28927: EQUAL
28928: IFFALSE 28938
// r := 0 ;
28930: LD_ADDR_VAR 0 15
28934: PUSH
28935: LD_INT 0
28937: ST_TO_ADDR
// for j = r to 5 do
28938: LD_ADDR_VAR 0 10
28942: PUSH
28943: DOUBLE
28944: LD_VAR 0 15
28948: DEC
28949: ST_TO_ADDR
28950: LD_INT 5
28952: PUSH
28953: FOR_TO
28954: IFFALSE 29068
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28956: LD_ADDR_VAR 0 11
28960: PUSH
28961: LD_VAR 0 13
28965: PPUSH
28966: CALL_OW 250
28970: PPUSH
28971: LD_VAR 0 10
28975: PPUSH
28976: LD_INT 2
28978: PPUSH
28979: CALL_OW 272
28983: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28984: LD_ADDR_VAR 0 12
28988: PUSH
28989: LD_VAR 0 13
28993: PPUSH
28994: CALL_OW 251
28998: PPUSH
28999: LD_VAR 0 10
29003: PPUSH
29004: LD_INT 2
29006: PPUSH
29007: CALL_OW 273
29011: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29012: LD_VAR 0 11
29016: PPUSH
29017: LD_VAR 0 12
29021: PPUSH
29022: CALL_OW 488
29026: PUSH
29027: LD_VAR 0 11
29031: PPUSH
29032: LD_VAR 0 12
29036: PPUSH
29037: CALL_OW 428
29041: NOT
29042: AND
29043: IFFALSE 29066
// begin ComMoveXY ( tmp , _x , _y ) ;
29045: LD_VAR 0 13
29049: PPUSH
29050: LD_VAR 0 11
29054: PPUSH
29055: LD_VAR 0 12
29059: PPUSH
29060: CALL_OW 111
// break ;
29064: GO 29068
// end ; end ;
29066: GO 28953
29068: POP
29069: POP
// end ; end ;
29070: GO 28395
29072: POP
29073: POP
// end ;
29074: LD_VAR 0 8
29078: RET
// export function BuildingTechInvented ( side , btype ) ; begin
29079: LD_INT 0
29081: PPUSH
// result := true ;
29082: LD_ADDR_VAR 0 3
29086: PUSH
29087: LD_INT 1
29089: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
29090: LD_VAR 0 2
29094: PUSH
29095: LD_INT 24
29097: DOUBLE
29098: EQUAL
29099: IFTRUE 29109
29101: LD_INT 33
29103: DOUBLE
29104: EQUAL
29105: IFTRUE 29109
29107: GO 29134
29109: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
29110: LD_ADDR_VAR 0 3
29114: PUSH
29115: LD_INT 32
29117: PPUSH
29118: LD_VAR 0 1
29122: PPUSH
29123: CALL_OW 321
29127: PUSH
29128: LD_INT 2
29130: EQUAL
29131: ST_TO_ADDR
29132: GO 29450
29134: LD_INT 20
29136: DOUBLE
29137: EQUAL
29138: IFTRUE 29142
29140: GO 29167
29142: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
29143: LD_ADDR_VAR 0 3
29147: PUSH
29148: LD_INT 6
29150: PPUSH
29151: LD_VAR 0 1
29155: PPUSH
29156: CALL_OW 321
29160: PUSH
29161: LD_INT 2
29163: EQUAL
29164: ST_TO_ADDR
29165: GO 29450
29167: LD_INT 22
29169: DOUBLE
29170: EQUAL
29171: IFTRUE 29181
29173: LD_INT 36
29175: DOUBLE
29176: EQUAL
29177: IFTRUE 29181
29179: GO 29206
29181: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
29182: LD_ADDR_VAR 0 3
29186: PUSH
29187: LD_INT 15
29189: PPUSH
29190: LD_VAR 0 1
29194: PPUSH
29195: CALL_OW 321
29199: PUSH
29200: LD_INT 2
29202: EQUAL
29203: ST_TO_ADDR
29204: GO 29450
29206: LD_INT 30
29208: DOUBLE
29209: EQUAL
29210: IFTRUE 29214
29212: GO 29239
29214: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
29215: LD_ADDR_VAR 0 3
29219: PUSH
29220: LD_INT 20
29222: PPUSH
29223: LD_VAR 0 1
29227: PPUSH
29228: CALL_OW 321
29232: PUSH
29233: LD_INT 2
29235: EQUAL
29236: ST_TO_ADDR
29237: GO 29450
29239: LD_INT 28
29241: DOUBLE
29242: EQUAL
29243: IFTRUE 29253
29245: LD_INT 21
29247: DOUBLE
29248: EQUAL
29249: IFTRUE 29253
29251: GO 29278
29253: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
29254: LD_ADDR_VAR 0 3
29258: PUSH
29259: LD_INT 21
29261: PPUSH
29262: LD_VAR 0 1
29266: PPUSH
29267: CALL_OW 321
29271: PUSH
29272: LD_INT 2
29274: EQUAL
29275: ST_TO_ADDR
29276: GO 29450
29278: LD_INT 16
29280: DOUBLE
29281: EQUAL
29282: IFTRUE 29286
29284: GO 29311
29286: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
29287: LD_ADDR_VAR 0 3
29291: PUSH
29292: LD_INT 84
29294: PPUSH
29295: LD_VAR 0 1
29299: PPUSH
29300: CALL_OW 321
29304: PUSH
29305: LD_INT 2
29307: EQUAL
29308: ST_TO_ADDR
29309: GO 29450
29311: LD_INT 19
29313: DOUBLE
29314: EQUAL
29315: IFTRUE 29325
29317: LD_INT 23
29319: DOUBLE
29320: EQUAL
29321: IFTRUE 29325
29323: GO 29350
29325: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
29326: LD_ADDR_VAR 0 3
29330: PUSH
29331: LD_INT 83
29333: PPUSH
29334: LD_VAR 0 1
29338: PPUSH
29339: CALL_OW 321
29343: PUSH
29344: LD_INT 2
29346: EQUAL
29347: ST_TO_ADDR
29348: GO 29450
29350: LD_INT 17
29352: DOUBLE
29353: EQUAL
29354: IFTRUE 29358
29356: GO 29383
29358: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
29359: LD_ADDR_VAR 0 3
29363: PUSH
29364: LD_INT 39
29366: PPUSH
29367: LD_VAR 0 1
29371: PPUSH
29372: CALL_OW 321
29376: PUSH
29377: LD_INT 2
29379: EQUAL
29380: ST_TO_ADDR
29381: GO 29450
29383: LD_INT 18
29385: DOUBLE
29386: EQUAL
29387: IFTRUE 29391
29389: GO 29416
29391: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
29392: LD_ADDR_VAR 0 3
29396: PUSH
29397: LD_INT 40
29399: PPUSH
29400: LD_VAR 0 1
29404: PPUSH
29405: CALL_OW 321
29409: PUSH
29410: LD_INT 2
29412: EQUAL
29413: ST_TO_ADDR
29414: GO 29450
29416: LD_INT 27
29418: DOUBLE
29419: EQUAL
29420: IFTRUE 29424
29422: GO 29449
29424: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
29425: LD_ADDR_VAR 0 3
29429: PUSH
29430: LD_INT 35
29432: PPUSH
29433: LD_VAR 0 1
29437: PPUSH
29438: CALL_OW 321
29442: PUSH
29443: LD_INT 2
29445: EQUAL
29446: ST_TO_ADDR
29447: GO 29450
29449: POP
// end ;
29450: LD_VAR 0 3
29454: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
29455: LD_INT 0
29457: PPUSH
29458: PPUSH
29459: PPUSH
29460: PPUSH
29461: PPUSH
29462: PPUSH
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
// result := false ;
29468: LD_ADDR_VAR 0 6
29472: PUSH
29473: LD_INT 0
29475: ST_TO_ADDR
// if btype = b_depot then
29476: LD_VAR 0 2
29480: PUSH
29481: LD_INT 0
29483: EQUAL
29484: IFFALSE 29496
// begin result := true ;
29486: LD_ADDR_VAR 0 6
29490: PUSH
29491: LD_INT 1
29493: ST_TO_ADDR
// exit ;
29494: GO 30322
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29496: LD_VAR 0 1
29500: NOT
29501: PUSH
29502: LD_VAR 0 1
29506: PPUSH
29507: CALL_OW 266
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: LD_INT 1
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: IN
29522: NOT
29523: OR
29524: PUSH
29525: LD_VAR 0 2
29529: NOT
29530: OR
29531: PUSH
29532: LD_VAR 0 5
29536: PUSH
29537: LD_INT 0
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: LD_INT 2
29545: PUSH
29546: LD_INT 3
29548: PUSH
29549: LD_INT 4
29551: PUSH
29552: LD_INT 5
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: IN
29563: NOT
29564: OR
29565: PUSH
29566: LD_VAR 0 3
29570: PPUSH
29571: LD_VAR 0 4
29575: PPUSH
29576: CALL_OW 488
29580: NOT
29581: OR
29582: IFFALSE 29586
// exit ;
29584: GO 30322
// side := GetSide ( depot ) ;
29586: LD_ADDR_VAR 0 9
29590: PUSH
29591: LD_VAR 0 1
29595: PPUSH
29596: CALL_OW 255
29600: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
29601: LD_VAR 0 9
29605: PPUSH
29606: LD_VAR 0 2
29610: PPUSH
29611: CALL 29079 0 2
29615: NOT
29616: IFFALSE 29620
// exit ;
29618: GO 30322
// pom := GetBase ( depot ) ;
29620: LD_ADDR_VAR 0 10
29624: PUSH
29625: LD_VAR 0 1
29629: PPUSH
29630: CALL_OW 274
29634: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29635: LD_ADDR_VAR 0 11
29639: PUSH
29640: LD_VAR 0 2
29644: PPUSH
29645: LD_VAR 0 1
29649: PPUSH
29650: CALL_OW 248
29654: PPUSH
29655: CALL_OW 450
29659: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
29660: LD_VAR 0 10
29664: PPUSH
29665: LD_INT 1
29667: PPUSH
29668: CALL_OW 275
29672: PUSH
29673: LD_VAR 0 11
29677: PUSH
29678: LD_INT 1
29680: ARRAY
29681: GREATEREQUAL
29682: PUSH
29683: LD_VAR 0 10
29687: PPUSH
29688: LD_INT 2
29690: PPUSH
29691: CALL_OW 275
29695: PUSH
29696: LD_VAR 0 11
29700: PUSH
29701: LD_INT 2
29703: ARRAY
29704: GREATEREQUAL
29705: AND
29706: PUSH
29707: LD_VAR 0 10
29711: PPUSH
29712: LD_INT 3
29714: PPUSH
29715: CALL_OW 275
29719: PUSH
29720: LD_VAR 0 11
29724: PUSH
29725: LD_INT 3
29727: ARRAY
29728: GREATEREQUAL
29729: AND
29730: NOT
29731: IFFALSE 29735
// exit ;
29733: GO 30322
// if GetBType ( depot ) = b_depot then
29735: LD_VAR 0 1
29739: PPUSH
29740: CALL_OW 266
29744: PUSH
29745: LD_INT 0
29747: EQUAL
29748: IFFALSE 29760
// dist := 28 else
29750: LD_ADDR_VAR 0 14
29754: PUSH
29755: LD_INT 28
29757: ST_TO_ADDR
29758: GO 29768
// dist := 36 ;
29760: LD_ADDR_VAR 0 14
29764: PUSH
29765: LD_INT 36
29767: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
29768: LD_VAR 0 1
29772: PPUSH
29773: LD_VAR 0 3
29777: PPUSH
29778: LD_VAR 0 4
29782: PPUSH
29783: CALL_OW 297
29787: PUSH
29788: LD_VAR 0 14
29792: GREATER
29793: IFFALSE 29797
// exit ;
29795: GO 30322
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
29797: LD_ADDR_VAR 0 12
29801: PUSH
29802: LD_VAR 0 2
29806: PPUSH
29807: LD_VAR 0 3
29811: PPUSH
29812: LD_VAR 0 4
29816: PPUSH
29817: LD_VAR 0 5
29821: PPUSH
29822: LD_VAR 0 1
29826: PPUSH
29827: CALL_OW 248
29831: PPUSH
29832: LD_INT 0
29834: PPUSH
29835: CALL 30327 0 6
29839: ST_TO_ADDR
// if not hexes then
29840: LD_VAR 0 12
29844: NOT
29845: IFFALSE 29849
// exit ;
29847: GO 30322
// hex := GetHexInfo ( x , y ) ;
29849: LD_ADDR_VAR 0 15
29853: PUSH
29854: LD_VAR 0 3
29858: PPUSH
29859: LD_VAR 0 4
29863: PPUSH
29864: CALL_OW 546
29868: ST_TO_ADDR
// if hex [ 1 ] then
29869: LD_VAR 0 15
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: IFFALSE 29881
// exit ;
29879: GO 30322
// height := hex [ 2 ] ;
29881: LD_ADDR_VAR 0 13
29885: PUSH
29886: LD_VAR 0 15
29890: PUSH
29891: LD_INT 2
29893: ARRAY
29894: ST_TO_ADDR
// for i = 1 to hexes do
29895: LD_ADDR_VAR 0 7
29899: PUSH
29900: DOUBLE
29901: LD_INT 1
29903: DEC
29904: ST_TO_ADDR
29905: LD_VAR 0 12
29909: PUSH
29910: FOR_TO
29911: IFFALSE 30241
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29913: LD_VAR 0 12
29917: PUSH
29918: LD_VAR 0 7
29922: ARRAY
29923: PUSH
29924: LD_INT 1
29926: ARRAY
29927: PPUSH
29928: LD_VAR 0 12
29932: PUSH
29933: LD_VAR 0 7
29937: ARRAY
29938: PUSH
29939: LD_INT 2
29941: ARRAY
29942: PPUSH
29943: CALL_OW 488
29947: NOT
29948: PUSH
29949: LD_VAR 0 12
29953: PUSH
29954: LD_VAR 0 7
29958: ARRAY
29959: PUSH
29960: LD_INT 1
29962: ARRAY
29963: PPUSH
29964: LD_VAR 0 12
29968: PUSH
29969: LD_VAR 0 7
29973: ARRAY
29974: PUSH
29975: LD_INT 2
29977: ARRAY
29978: PPUSH
29979: CALL_OW 428
29983: PUSH
29984: LD_INT 0
29986: GREATER
29987: OR
29988: PUSH
29989: LD_VAR 0 12
29993: PUSH
29994: LD_VAR 0 7
29998: ARRAY
29999: PUSH
30000: LD_INT 1
30002: ARRAY
30003: PPUSH
30004: LD_VAR 0 12
30008: PUSH
30009: LD_VAR 0 7
30013: ARRAY
30014: PUSH
30015: LD_INT 2
30017: ARRAY
30018: PPUSH
30019: CALL_OW 351
30023: OR
30024: IFFALSE 30030
// exit ;
30026: POP
30027: POP
30028: GO 30322
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30030: LD_ADDR_VAR 0 8
30034: PUSH
30035: LD_VAR 0 12
30039: PUSH
30040: LD_VAR 0 7
30044: ARRAY
30045: PUSH
30046: LD_INT 1
30048: ARRAY
30049: PPUSH
30050: LD_VAR 0 12
30054: PUSH
30055: LD_VAR 0 7
30059: ARRAY
30060: PUSH
30061: LD_INT 2
30063: ARRAY
30064: PPUSH
30065: CALL_OW 546
30069: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30070: LD_VAR 0 8
30074: PUSH
30075: LD_INT 1
30077: ARRAY
30078: PUSH
30079: LD_VAR 0 8
30083: PUSH
30084: LD_INT 2
30086: ARRAY
30087: PUSH
30088: LD_VAR 0 13
30092: PUSH
30093: LD_INT 2
30095: PLUS
30096: GREATER
30097: OR
30098: PUSH
30099: LD_VAR 0 8
30103: PUSH
30104: LD_INT 2
30106: ARRAY
30107: PUSH
30108: LD_VAR 0 13
30112: PUSH
30113: LD_INT 2
30115: MINUS
30116: LESS
30117: OR
30118: PUSH
30119: LD_VAR 0 8
30123: PUSH
30124: LD_INT 3
30126: ARRAY
30127: PUSH
30128: LD_INT 0
30130: PUSH
30131: LD_INT 8
30133: PUSH
30134: LD_INT 9
30136: PUSH
30137: LD_INT 10
30139: PUSH
30140: LD_INT 11
30142: PUSH
30143: LD_INT 12
30145: PUSH
30146: LD_INT 13
30148: PUSH
30149: LD_INT 16
30151: PUSH
30152: LD_INT 17
30154: PUSH
30155: LD_INT 18
30157: PUSH
30158: LD_INT 19
30160: PUSH
30161: LD_INT 20
30163: PUSH
30164: LD_INT 21
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: LIST
30179: LIST
30180: LIST
30181: IN
30182: NOT
30183: OR
30184: PUSH
30185: LD_VAR 0 8
30189: PUSH
30190: LD_INT 5
30192: ARRAY
30193: NOT
30194: OR
30195: PUSH
30196: LD_VAR 0 8
30200: PUSH
30201: LD_INT 6
30203: ARRAY
30204: PUSH
30205: LD_INT 1
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: LD_INT 7
30213: PUSH
30214: LD_INT 9
30216: PUSH
30217: LD_INT 10
30219: PUSH
30220: LD_INT 11
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: IN
30231: NOT
30232: OR
30233: IFFALSE 30239
// exit ;
30235: POP
30236: POP
30237: GO 30322
// end ;
30239: GO 29910
30241: POP
30242: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30243: LD_VAR 0 9
30247: PPUSH
30248: LD_VAR 0 3
30252: PPUSH
30253: LD_VAR 0 4
30257: PPUSH
30258: LD_INT 20
30260: PPUSH
30261: CALL 22245 0 4
30265: PUSH
30266: LD_INT 4
30268: ARRAY
30269: IFFALSE 30273
// exit ;
30271: GO 30322
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30273: LD_VAR 0 2
30277: PUSH
30278: LD_INT 29
30280: PUSH
30281: LD_INT 30
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: IN
30288: PUSH
30289: LD_VAR 0 3
30293: PPUSH
30294: LD_VAR 0 4
30298: PPUSH
30299: LD_VAR 0 9
30303: PPUSH
30304: CALL_OW 440
30308: NOT
30309: AND
30310: IFFALSE 30314
// exit ;
30312: GO 30322
// result := true ;
30314: LD_ADDR_VAR 0 6
30318: PUSH
30319: LD_INT 1
30321: ST_TO_ADDR
// end ;
30322: LD_VAR 0 6
30326: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30327: LD_INT 0
30329: PPUSH
30330: PPUSH
30331: PPUSH
30332: PPUSH
30333: PPUSH
30334: PPUSH
30335: PPUSH
30336: PPUSH
30337: PPUSH
30338: PPUSH
30339: PPUSH
30340: PPUSH
30341: PPUSH
30342: PPUSH
30343: PPUSH
30344: PPUSH
30345: PPUSH
30346: PPUSH
30347: PPUSH
30348: PPUSH
30349: PPUSH
30350: PPUSH
30351: PPUSH
30352: PPUSH
30353: PPUSH
30354: PPUSH
30355: PPUSH
30356: PPUSH
30357: PPUSH
30358: PPUSH
30359: PPUSH
30360: PPUSH
30361: PPUSH
30362: PPUSH
30363: PPUSH
30364: PPUSH
30365: PPUSH
30366: PPUSH
30367: PPUSH
30368: PPUSH
30369: PPUSH
30370: PPUSH
30371: PPUSH
30372: PPUSH
30373: PPUSH
30374: PPUSH
30375: PPUSH
30376: PPUSH
30377: PPUSH
30378: PPUSH
30379: PPUSH
30380: PPUSH
30381: PPUSH
30382: PPUSH
30383: PPUSH
30384: PPUSH
30385: PPUSH
30386: PPUSH
// result = [ ] ;
30387: LD_ADDR_VAR 0 7
30391: PUSH
30392: EMPTY
30393: ST_TO_ADDR
// temp_list = [ ] ;
30394: LD_ADDR_VAR 0 9
30398: PUSH
30399: EMPTY
30400: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30401: LD_VAR 0 4
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 2
30414: PUSH
30415: LD_INT 3
30417: PUSH
30418: LD_INT 4
30420: PUSH
30421: LD_INT 5
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: IN
30432: NOT
30433: PUSH
30434: LD_VAR 0 1
30438: PUSH
30439: LD_INT 0
30441: PUSH
30442: LD_INT 1
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: IN
30449: PUSH
30450: LD_VAR 0 5
30454: PUSH
30455: LD_INT 1
30457: PUSH
30458: LD_INT 2
30460: PUSH
30461: LD_INT 3
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: LIST
30468: IN
30469: NOT
30470: AND
30471: OR
30472: IFFALSE 30476
// exit ;
30474: GO 48867
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30476: LD_VAR 0 1
30480: PUSH
30481: LD_INT 6
30483: PUSH
30484: LD_INT 7
30486: PUSH
30487: LD_INT 8
30489: PUSH
30490: LD_INT 13
30492: PUSH
30493: LD_INT 12
30495: PUSH
30496: LD_INT 15
30498: PUSH
30499: LD_INT 11
30501: PUSH
30502: LD_INT 14
30504: PUSH
30505: LD_INT 10
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: IN
30519: IFFALSE 30529
// btype = b_lab ;
30521: LD_ADDR_VAR 0 1
30525: PUSH
30526: LD_INT 6
30528: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30529: LD_VAR 0 6
30533: PUSH
30534: LD_INT 0
30536: PUSH
30537: LD_INT 1
30539: PUSH
30540: LD_INT 2
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: LIST
30547: IN
30548: NOT
30549: PUSH
30550: LD_VAR 0 1
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 1
30560: PUSH
30561: LD_INT 2
30563: PUSH
30564: LD_INT 3
30566: PUSH
30567: LD_INT 6
30569: PUSH
30570: LD_INT 36
30572: PUSH
30573: LD_INT 4
30575: PUSH
30576: LD_INT 5
30578: PUSH
30579: LD_INT 31
30581: PUSH
30582: LD_INT 32
30584: PUSH
30585: LD_INT 33
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: IN
30601: NOT
30602: PUSH
30603: LD_VAR 0 6
30607: PUSH
30608: LD_INT 1
30610: EQUAL
30611: AND
30612: OR
30613: PUSH
30614: LD_VAR 0 1
30618: PUSH
30619: LD_INT 2
30621: PUSH
30622: LD_INT 3
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: IN
30629: NOT
30630: PUSH
30631: LD_VAR 0 6
30635: PUSH
30636: LD_INT 2
30638: EQUAL
30639: AND
30640: OR
30641: IFFALSE 30651
// mode = 0 ;
30643: LD_ADDR_VAR 0 6
30647: PUSH
30648: LD_INT 0
30650: ST_TO_ADDR
// case mode of 0 :
30651: LD_VAR 0 6
30655: PUSH
30656: LD_INT 0
30658: DOUBLE
30659: EQUAL
30660: IFTRUE 30664
30662: GO 42117
30664: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30665: LD_ADDR_VAR 0 11
30669: PUSH
30670: LD_INT 0
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 1
30693: PUSH
30694: LD_INT 0
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 1
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: EMPTY
30718: LIST
30719: LIST
30720: PUSH
30721: LD_INT 1
30723: NEG
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: LD_INT 1
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 1
30746: NEG
30747: PUSH
30748: LD_INT 2
30750: NEG
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 0
30758: PUSH
30759: LD_INT 2
30761: NEG
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 1
30769: PUSH
30770: LD_INT 1
30772: NEG
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 1
30780: PUSH
30781: LD_INT 2
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: LD_INT 2
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: NEG
30801: PUSH
30802: LD_INT 1
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 1
30811: PUSH
30812: LD_INT 3
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: LD_INT 3
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: LD_INT 2
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30858: LD_ADDR_VAR 0 12
30862: PUSH
30863: LD_INT 0
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 0
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: LD_INT 0
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 1
30896: PUSH
30897: LD_INT 1
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 0
30906: PUSH
30907: LD_INT 1
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: LD_INT 1
30916: NEG
30917: PUSH
30918: LD_INT 0
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 1
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 2
30950: PUSH
30951: LD_INT 0
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 2
30960: PUSH
30961: LD_INT 1
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: LD_INT 1
30970: NEG
30971: PUSH
30972: LD_INT 1
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 2
30981: NEG
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: NEG
30993: PUSH
30994: LD_INT 1
30996: NEG
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 2
31004: NEG
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 3
31015: NEG
31016: PUSH
31017: LD_INT 0
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 3
31026: NEG
31027: PUSH
31028: LD_INT 1
31030: NEG
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31054: LD_ADDR_VAR 0 13
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: LD_INT 0
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 0
31071: PUSH
31072: LD_INT 1
31074: NEG
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: LD_INT 0
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: LD_INT 1
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: LD_INT 1
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 1
31135: NEG
31136: PUSH
31137: LD_INT 2
31139: NEG
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 2
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: LD_INT 1
31181: NEG
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 2
31189: NEG
31190: PUSH
31191: LD_INT 2
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 2
31201: NEG
31202: PUSH
31203: LD_INT 3
31205: NEG
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: PUSH
31211: LD_INT 3
31213: NEG
31214: PUSH
31215: LD_INT 2
31217: NEG
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 3
31225: NEG
31226: PUSH
31227: LD_INT 3
31229: NEG
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31253: LD_ADDR_VAR 0 14
31257: PUSH
31258: LD_INT 0
31260: PUSH
31261: LD_INT 0
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 0
31270: PUSH
31271: LD_INT 1
31273: NEG
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: LD_INT 1
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: LD_INT 1
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 1
31311: NEG
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: NEG
31323: PUSH
31324: LD_INT 1
31326: NEG
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: LD_INT 2
31338: NEG
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 2
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 1
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: PUSH
31369: LD_INT 2
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 0
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: NEG
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 1
31399: NEG
31400: PUSH
31401: LD_INT 3
31403: NEG
31404: PUSH
31405: EMPTY
31406: LIST
31407: LIST
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: LD_INT 3
31414: NEG
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 1
31422: PUSH
31423: LD_INT 2
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31449: LD_ADDR_VAR 0 15
31453: PUSH
31454: LD_INT 0
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 0
31466: PUSH
31467: LD_INT 1
31469: NEG
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: PUSH
31488: LD_INT 1
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: LD_INT 1
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: NEG
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 1
31518: NEG
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: LD_INT 1
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 2
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 2
31551: PUSH
31552: LD_INT 1
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 1
31561: NEG
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 2
31572: NEG
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 2
31583: NEG
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: LD_INT 1
31598: NEG
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 3
31606: PUSH
31607: LD_INT 0
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 3
31616: PUSH
31617: LD_INT 1
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31642: LD_ADDR_VAR 0 16
31646: PUSH
31647: LD_INT 0
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: LD_INT 1
31662: NEG
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 1
31670: PUSH
31671: LD_INT 0
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 0
31690: PUSH
31691: LD_INT 1
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: LD_INT 0
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 1
31715: NEG
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: LD_INT 2
31727: NEG
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 2
31735: PUSH
31736: LD_INT 1
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: PUSH
31746: LD_INT 2
31748: PUSH
31749: EMPTY
31750: LIST
31751: LIST
31752: PUSH
31753: LD_INT 1
31755: PUSH
31756: LD_INT 2
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 2
31765: NEG
31766: PUSH
31767: LD_INT 1
31769: NEG
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 2
31777: NEG
31778: PUSH
31779: LD_INT 2
31781: NEG
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 3
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 3
31799: PUSH
31800: LD_INT 3
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: LD_INT 3
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: LIST
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31835: LD_ADDR_VAR 0 17
31839: PUSH
31840: LD_INT 0
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 1
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 0
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: LD_INT 0
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: NEG
31905: PUSH
31906: LD_INT 1
31908: NEG
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 1
31916: NEG
31917: PUSH
31918: LD_INT 2
31920: NEG
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 0
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 1
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 2
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: PUSH
31961: LD_INT 1
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: PUSH
31971: LD_INT 2
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: LD_INT 2
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 0
31990: PUSH
31991: LD_INT 2
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 1
32000: NEG
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: NEG
32012: PUSH
32013: LD_INT 0
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: NEG
32023: PUSH
32024: LD_INT 1
32026: NEG
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 2
32034: NEG
32035: PUSH
32036: LD_INT 2
32038: NEG
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32065: LD_ADDR_VAR 0 18
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 0
32082: PUSH
32083: LD_INT 1
32085: NEG
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: LD_INT 1
32106: PUSH
32107: EMPTY
32108: LIST
32109: LIST
32110: PUSH
32111: LD_INT 0
32113: PUSH
32114: LD_INT 1
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 1
32123: NEG
32124: PUSH
32125: LD_INT 0
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 1
32146: NEG
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 0
32158: PUSH
32159: LD_INT 2
32161: NEG
32162: PUSH
32163: EMPTY
32164: LIST
32165: LIST
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 2
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 2
32190: PUSH
32191: LD_INT 1
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 2
32200: PUSH
32201: LD_INT 2
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PUSH
32208: LD_INT 1
32210: PUSH
32211: LD_INT 2
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 0
32220: PUSH
32221: LD_INT 2
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: NEG
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 2
32241: NEG
32242: PUSH
32243: LD_INT 0
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 2
32252: NEG
32253: PUSH
32254: LD_INT 1
32256: NEG
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 2
32264: NEG
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32295: LD_ADDR_VAR 0 19
32299: PUSH
32300: LD_INT 0
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 1
32315: NEG
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PUSH
32321: LD_INT 1
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 1
32333: PUSH
32334: LD_INT 1
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 0
32343: PUSH
32344: LD_INT 1
32346: PUSH
32347: EMPTY
32348: LIST
32349: LIST
32350: PUSH
32351: LD_INT 1
32353: NEG
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 1
32364: NEG
32365: PUSH
32366: LD_INT 1
32368: NEG
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: NEG
32377: PUSH
32378: LD_INT 2
32380: NEG
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 2
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: LD_INT 2
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: LD_INT 2
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: LD_INT 0
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 2
32482: NEG
32483: PUSH
32484: LD_INT 1
32486: NEG
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: LD_INT 2
32494: NEG
32495: PUSH
32496: LD_INT 2
32498: NEG
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32525: LD_ADDR_VAR 0 20
32529: PUSH
32530: LD_INT 0
32532: PUSH
32533: LD_INT 0
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: LD_INT 1
32545: NEG
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: PUSH
32564: LD_INT 1
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: LD_INT 1
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: NEG
32584: PUSH
32585: LD_INT 0
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 1
32594: NEG
32595: PUSH
32596: LD_INT 1
32598: NEG
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 1
32606: NEG
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: LD_INT 2
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 1
32629: PUSH
32630: LD_INT 1
32632: NEG
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 2
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: PUSH
32651: LD_INT 1
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: LD_INT 2
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: LD_INT 2
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 1
32690: NEG
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 2
32701: NEG
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: NEG
32713: PUSH
32714: LD_INT 1
32716: NEG
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 2
32724: NEG
32725: PUSH
32726: LD_INT 2
32728: NEG
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32755: LD_ADDR_VAR 0 21
32759: PUSH
32760: LD_INT 0
32762: PUSH
32763: LD_INT 0
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 0
32772: PUSH
32773: LD_INT 1
32775: NEG
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 1
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 0
32803: PUSH
32804: LD_INT 1
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 1
32813: NEG
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 1
32824: NEG
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 1
32836: NEG
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 0
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 1
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 2
32870: PUSH
32871: LD_INT 0
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 2
32880: PUSH
32881: LD_INT 1
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 2
32890: PUSH
32891: LD_INT 2
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 1
32900: PUSH
32901: LD_INT 2
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 2
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 1
32920: NEG
32921: PUSH
32922: LD_INT 1
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 2
32931: NEG
32932: PUSH
32933: LD_INT 0
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 2
32942: NEG
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 2
32954: NEG
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32985: LD_ADDR_VAR 0 22
32989: PUSH
32990: LD_INT 0
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 0
33002: PUSH
33003: LD_INT 1
33005: NEG
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 1
33013: PUSH
33014: LD_INT 0
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 1
33023: PUSH
33024: LD_INT 1
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: LD_INT 0
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 1
33054: NEG
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 1
33066: NEG
33067: PUSH
33068: LD_INT 2
33070: NEG
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 0
33078: PUSH
33079: LD_INT 2
33081: NEG
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 1
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 2
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 2
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 2
33120: PUSH
33121: LD_INT 2
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: PUSH
33131: LD_INT 2
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 0
33140: PUSH
33141: LD_INT 2
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 1
33150: NEG
33151: PUSH
33152: LD_INT 1
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 2
33161: NEG
33162: PUSH
33163: LD_INT 0
33165: PUSH
33166: EMPTY
33167: LIST
33168: LIST
33169: PUSH
33170: LD_INT 2
33172: NEG
33173: PUSH
33174: LD_INT 1
33176: NEG
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 2
33184: NEG
33185: PUSH
33186: LD_INT 2
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33215: LD_ADDR_VAR 0 23
33219: PUSH
33220: LD_INT 0
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 0
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 1
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: LD_INT 1
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: LD_INT 1
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: LD_INT 0
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 1
33284: NEG
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 1
33296: NEG
33297: PUSH
33298: LD_INT 2
33300: NEG
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 0
33308: PUSH
33309: LD_INT 2
33311: NEG
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 1
33319: PUSH
33320: LD_INT 1
33322: NEG
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 2
33330: PUSH
33331: LD_INT 0
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 2
33340: PUSH
33341: LD_INT 1
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 2
33350: PUSH
33351: LD_INT 2
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: LD_INT 2
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 0
33370: PUSH
33371: LD_INT 2
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 1
33380: NEG
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 2
33391: NEG
33392: PUSH
33393: LD_INT 0
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: LD_INT 1
33406: NEG
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 2
33414: NEG
33415: PUSH
33416: LD_INT 2
33418: NEG
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 2
33426: NEG
33427: PUSH
33428: LD_INT 3
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: LD_INT 3
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 1
33450: PUSH
33451: LD_INT 2
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 2
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33495: LD_ADDR_VAR 0 24
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: LD_INT 0
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: LD_INT 1
33533: PUSH
33534: LD_INT 1
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: EMPTY
33548: LIST
33549: LIST
33550: PUSH
33551: LD_INT 1
33553: NEG
33554: PUSH
33555: LD_INT 0
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: LD_INT 2
33580: NEG
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 0
33588: PUSH
33589: LD_INT 2
33591: NEG
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: PUSH
33600: LD_INT 1
33602: NEG
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 2
33610: PUSH
33611: LD_INT 0
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 2
33620: PUSH
33621: LD_INT 1
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 2
33630: PUSH
33631: LD_INT 2
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 2
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 0
33650: PUSH
33651: LD_INT 2
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: LD_INT 1
33664: PUSH
33665: EMPTY
33666: LIST
33667: LIST
33668: PUSH
33669: LD_INT 2
33671: NEG
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 2
33682: NEG
33683: PUSH
33684: LD_INT 1
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 2
33694: NEG
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: PUSH
33707: LD_INT 2
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: LD_INT 1
33720: NEG
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 3
33728: PUSH
33729: LD_INT 1
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 3
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
33771: LD_ADDR_VAR 0 25
33775: PUSH
33776: LD_INT 0
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: LD_INT 1
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 0
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: PUSH
33810: LD_INT 1
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 0
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: NEG
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 1
33852: NEG
33853: PUSH
33854: LD_INT 2
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: LD_INT 2
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: PUSH
33876: LD_INT 1
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 2
33886: PUSH
33887: LD_INT 0
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 2
33896: PUSH
33897: LD_INT 1
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 2
33906: PUSH
33907: LD_INT 2
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 1
33916: PUSH
33917: LD_INT 2
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: LD_INT 2
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 1
33936: NEG
33937: PUSH
33938: LD_INT 1
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 2
33947: NEG
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: NEG
33959: PUSH
33960: LD_INT 1
33962: NEG
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 2
33970: NEG
33971: PUSH
33972: LD_INT 2
33974: NEG
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 3
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 3
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: LD_INT 3
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: LD_INT 3
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34045: LD_ADDR_VAR 0 26
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: LD_INT 2
34141: NEG
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: LD_INT 2
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 1
34210: NEG
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: LD_INT 1
34236: NEG
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 2
34244: NEG
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 2
34256: PUSH
34257: LD_INT 3
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 3
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 1
34276: NEG
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 2
34287: NEG
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: EMPTY
34293: LIST
34294: LIST
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34321: LD_ADDR_VAR 0 27
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 1
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 1
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: NEG
34380: PUSH
34381: LD_INT 0
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: NEG
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 1
34402: NEG
34403: PUSH
34404: LD_INT 2
34406: NEG
34407: PUSH
34408: EMPTY
34409: LIST
34410: LIST
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: LD_INT 2
34417: NEG
34418: PUSH
34419: EMPTY
34420: LIST
34421: LIST
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 2
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 2
34446: PUSH
34447: LD_INT 1
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 2
34456: PUSH
34457: LD_INT 2
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: LD_INT 2
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: NEG
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: NEG
34498: PUSH
34499: LD_INT 0
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 2
34508: NEG
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 2
34520: NEG
34521: PUSH
34522: LD_INT 2
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: LD_INT 2
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 3
34554: NEG
34555: PUSH
34556: LD_INT 1
34558: NEG
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 3
34566: NEG
34567: PUSH
34568: LD_INT 2
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34601: LD_ADDR_VAR 0 28
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 1
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: PUSH
34640: LD_INT 1
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 0
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 1
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 1
34682: NEG
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: LD_INT 2
34697: NEG
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 1
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 2
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: PUSH
34737: LD_INT 2
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: LD_INT 2
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: LD_INT 2
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 2
34777: NEG
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 2
34788: NEG
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 2
34800: NEG
34801: PUSH
34802: LD_INT 2
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 2
34812: NEG
34813: PUSH
34814: LD_INT 3
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: LD_INT 3
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 3
34836: NEG
34837: PUSH
34838: LD_INT 1
34840: NEG
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 3
34848: NEG
34849: PUSH
34850: LD_INT 2
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: LIST
34871: LIST
34872: LIST
34873: LIST
34874: LIST
34875: LIST
34876: LIST
34877: LIST
34878: LIST
34879: LIST
34880: LIST
34881: LIST
34882: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34883: LD_ADDR_VAR 0 29
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: LD_INT 0
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: LD_INT 0
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 1
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 0
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: LD_INT 1
34941: NEG
34942: PUSH
34943: LD_INT 0
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 1
34952: NEG
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: LD_INT 2
34968: NEG
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 0
34976: PUSH
34977: LD_INT 2
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 2
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: LD_INT 2
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: LD_INT 2
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: NEG
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: NEG
35050: PUSH
35051: LD_INT 1
35053: NEG
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: LD_INT 2
35065: NEG
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: NEG
35074: PUSH
35075: LD_INT 3
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 2
35085: PUSH
35086: LD_INT 1
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 3
35096: PUSH
35097: LD_INT 1
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: LD_INT 3
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 1
35116: NEG
35117: PUSH
35118: LD_INT 2
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 3
35127: NEG
35128: PUSH
35129: LD_INT 2
35131: NEG
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35162: LD_ADDR_VAR 0 30
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: PUSH
35191: LD_INT 0
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 0
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: LD_INT 1
35235: NEG
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 1
35243: NEG
35244: PUSH
35245: LD_INT 2
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: PUSH
35278: LD_INT 0
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 2
35287: PUSH
35288: LD_INT 1
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 2
35297: PUSH
35298: LD_INT 2
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 1
35307: PUSH
35308: LD_INT 2
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 1
35317: NEG
35318: PUSH
35319: LD_INT 1
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 2
35328: NEG
35329: PUSH
35330: LD_INT 0
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 2
35339: NEG
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: LD_INT 3
35355: NEG
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: PUSH
35364: LD_INT 2
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 3
35374: PUSH
35375: LD_INT 2
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 2
35384: PUSH
35385: LD_INT 3
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 2
35394: NEG
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 3
35405: NEG
35406: PUSH
35407: LD_INT 1
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35440: LD_ADDR_VAR 0 31
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: LD_INT 1
35460: NEG
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: PUSH
35469: LD_INT 0
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 1
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 1
35509: NEG
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: LD_INT 2
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: LD_INT 1
35536: NEG
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 2
35544: PUSH
35545: LD_INT 0
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 2
35554: PUSH
35555: LD_INT 1
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: LD_INT 2
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 1
35574: PUSH
35575: LD_INT 2
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: LD_INT 2
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 1
35594: NEG
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 2
35605: NEG
35606: PUSH
35607: LD_INT 1
35609: NEG
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 2
35617: NEG
35618: PUSH
35619: LD_INT 2
35621: NEG
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: LD_INT 3
35633: NEG
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 2
35641: PUSH
35642: LD_INT 1
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 3
35652: PUSH
35653: LD_INT 1
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: PUSH
35663: LD_INT 3
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: NEG
35673: PUSH
35674: LD_INT 2
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 3
35683: NEG
35684: PUSH
35685: LD_INT 2
35687: NEG
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: LIST
35706: LIST
35707: LIST
35708: LIST
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35718: LD_ADDR_VAR 0 32
35722: PUSH
35723: LD_INT 0
35725: PUSH
35726: LD_INT 0
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 0
35735: PUSH
35736: LD_INT 1
35738: NEG
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 0
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 1
35756: PUSH
35757: LD_INT 1
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 0
35766: PUSH
35767: LD_INT 1
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: NEG
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: NEG
35788: PUSH
35789: LD_INT 1
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: NEG
35800: PUSH
35801: LD_INT 2
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 2
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 2
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 2
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 0
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 1
35907: NEG
35908: PUSH
35909: LD_INT 3
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: PUSH
35920: LD_INT 2
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: PUSH
35931: LD_INT 2
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 2
35940: PUSH
35941: LD_INT 3
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 3
35961: NEG
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35996: LD_ADDR_VAR 0 33
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 1
36016: NEG
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 0
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 1
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 0
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: LD_INT 0
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 1
36065: NEG
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 1
36077: NEG
36078: PUSH
36079: LD_INT 2
36081: NEG
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 1
36089: PUSH
36090: LD_INT 1
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 0
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 2
36162: NEG
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 2
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 2
36186: NEG
36187: PUSH
36188: LD_INT 3
36190: NEG
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 1
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 3
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: PUSH
36220: LD_INT 3
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: NEG
36230: PUSH
36231: LD_INT 2
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 3
36240: NEG
36241: PUSH
36242: LD_INT 2
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36275: LD_ADDR_VAR 0 34
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 1
36295: NEG
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 0
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 1
36344: NEG
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: PUSH
36380: LD_INT 1
36382: NEG
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 2
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 2
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 1
36420: NEG
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 2
36431: NEG
36432: PUSH
36433: LD_INT 0
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 2
36442: NEG
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 2
36454: NEG
36455: PUSH
36456: LD_INT 2
36458: NEG
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 1
36466: NEG
36467: PUSH
36468: LD_INT 3
36470: NEG
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 2
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 3
36489: PUSH
36490: LD_INT 2
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 2
36499: PUSH
36500: LD_INT 3
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: LD_INT 1
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 3
36520: NEG
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36555: LD_ADDR_VAR 0 35
36559: PUSH
36560: LD_INT 0
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 0
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 1
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 0
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: LD_INT 0
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: LD_INT 1
36628: NEG
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: LD_INT 1
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 2
36646: NEG
36647: PUSH
36648: LD_INT 1
36650: NEG
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36667: LD_ADDR_VAR 0 36
36671: PUSH
36672: LD_INT 0
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 0
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 1
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 0
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 1
36725: NEG
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: LD_INT 2
36752: NEG
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36779: LD_ADDR_VAR 0 37
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 0
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 1
36871: NEG
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36891: LD_ADDR_VAR 0 38
36895: PUSH
36896: LD_INT 0
36898: PUSH
36899: LD_INT 0
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 1
36919: PUSH
36920: LD_INT 0
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 0
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 1
36949: NEG
36950: PUSH
36951: LD_INT 0
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 1
36960: NEG
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 2
36982: NEG
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37003: LD_ADDR_VAR 0 39
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 0
37020: PUSH
37021: LD_INT 1
37023: NEG
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 1
37041: PUSH
37042: LD_INT 1
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: NEG
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 1
37084: NEG
37085: PUSH
37086: LD_INT 2
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 1
37096: PUSH
37097: LD_INT 2
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: LIST
37108: LIST
37109: LIST
37110: LIST
37111: LIST
37112: LIST
37113: LIST
37114: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37115: LD_ADDR_VAR 0 40
37119: PUSH
37120: LD_INT 0
37122: PUSH
37123: LD_INT 0
37125: PUSH
37126: EMPTY
37127: LIST
37128: LIST
37129: PUSH
37130: LD_INT 0
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 1
37143: PUSH
37144: LD_INT 0
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 1
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 0
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 1
37184: NEG
37185: PUSH
37186: LD_INT 1
37188: NEG
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: LD_INT 1
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37227: LD_ADDR_VAR 0 41
37231: PUSH
37232: LD_INT 0
37234: PUSH
37235: LD_INT 0
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 0
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: LD_INT 0
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 0
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 1
37285: NEG
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: LD_INT 1
37300: NEG
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 2
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: PUSH
37321: LD_INT 1
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 2
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 2
37341: PUSH
37342: LD_INT 1
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 2
37351: PUSH
37352: LD_INT 2
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: PUSH
37362: LD_INT 2
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 1
37371: NEG
37372: PUSH
37373: LD_INT 1
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 2
37393: NEG
37394: PUSH
37395: LD_INT 1
37397: NEG
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 2
37405: NEG
37406: PUSH
37407: LD_INT 2
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 2
37417: NEG
37418: PUSH
37419: LD_INT 3
37421: NEG
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 2
37429: PUSH
37430: LD_INT 1
37432: NEG
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: PUSH
37441: LD_INT 0
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 3
37450: PUSH
37451: LD_INT 1
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 3
37460: PUSH
37461: LD_INT 2
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 3
37470: PUSH
37471: LD_INT 3
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 3
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: NEG
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 3
37512: NEG
37513: PUSH
37514: LD_INT 1
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 3
37524: NEG
37525: PUSH
37526: LD_INT 2
37528: NEG
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 3
37536: NEG
37537: PUSH
37538: LD_INT 3
37540: NEG
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: LIST
37550: LIST
37551: LIST
37552: LIST
37553: LIST
37554: LIST
37555: LIST
37556: LIST
37557: LIST
37558: LIST
37559: LIST
37560: LIST
37561: LIST
37562: LIST
37563: LIST
37564: LIST
37565: LIST
37566: LIST
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37577: LD_ADDR_VAR 0 42
37581: PUSH
37582: LD_INT 0
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 1
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 1
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: LD_INT 1
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 0
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 1
37635: NEG
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: LD_INT 2
37662: NEG
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: NEG
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 2
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PUSH
37700: LD_INT 2
37702: PUSH
37703: LD_INT 2
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 2
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 0
37722: PUSH
37723: LD_INT 2
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: NEG
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: NEG
37744: PUSH
37745: LD_INT 1
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 2
37755: NEG
37756: PUSH
37757: LD_INT 2
37759: NEG
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 2
37767: NEG
37768: PUSH
37769: LD_INT 3
37771: NEG
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 3
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 3
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 2
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 3
37813: PUSH
37814: LD_INT 2
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 3
37823: PUSH
37824: LD_INT 3
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: PUSH
37834: LD_INT 3
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 3
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 0
37853: PUSH
37854: LD_INT 3
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: NEG
37864: PUSH
37865: LD_INT 2
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 3
37874: NEG
37875: PUSH
37876: LD_INT 2
37878: NEG
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: NEG
37887: PUSH
37888: LD_INT 3
37890: NEG
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: LIST
37903: LIST
37904: LIST
37905: LIST
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37927: LD_ADDR_VAR 0 43
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: LD_INT 0
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 1
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 1
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: LD_INT 1
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 0
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 1
37985: NEG
37986: PUSH
37987: LD_INT 0
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 1
37996: NEG
37997: PUSH
37998: LD_INT 1
38000: NEG
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 1
38008: NEG
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: LD_INT 2
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: LD_INT 1
38034: NEG
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 2
38042: PUSH
38043: LD_INT 0
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 2
38052: PUSH
38053: LD_INT 1
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: LD_INT 2
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 2
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 1
38082: NEG
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 2
38093: NEG
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 2
38104: NEG
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 1
38116: NEG
38117: PUSH
38118: LD_INT 3
38120: NEG
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: LD_INT 3
38131: NEG
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: PUSH
38140: LD_INT 2
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 2
38150: PUSH
38151: LD_INT 1
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 3
38161: PUSH
38162: LD_INT 0
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: LD_INT 3
38171: PUSH
38172: LD_INT 1
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: LD_INT 3
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 3
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 2
38212: NEG
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 3
38223: NEG
38224: PUSH
38225: LD_INT 0
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 3
38234: NEG
38235: PUSH
38236: LD_INT 1
38238: NEG
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38275: LD_ADDR_VAR 0 44
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: LD_INT 2
38360: NEG
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 2
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 2
38389: PUSH
38390: LD_INT 1
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 2
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: PUSH
38410: LD_INT 2
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: NEG
38420: PUSH
38421: LD_INT 1
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 2
38441: NEG
38442: PUSH
38443: LD_INT 1
38445: NEG
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 2
38453: NEG
38454: PUSH
38455: LD_INT 2
38457: NEG
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 2
38465: NEG
38466: PUSH
38467: LD_INT 3
38469: NEG
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 3
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: LD_INT 1
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: LD_INT 3
38508: PUSH
38509: LD_INT 2
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 3
38518: PUSH
38519: LD_INT 3
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: LD_INT 3
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 2
38538: NEG
38539: PUSH
38540: LD_INT 1
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 3
38549: NEG
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: EMPTY
38555: LIST
38556: LIST
38557: PUSH
38558: LD_INT 3
38560: NEG
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 3
38572: NEG
38573: PUSH
38574: LD_INT 2
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 3
38584: NEG
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38625: LD_ADDR_VAR 0 45
38629: PUSH
38630: LD_INT 0
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 0
38642: PUSH
38643: LD_INT 1
38645: NEG
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 0
38673: PUSH
38674: LD_INT 1
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: LD_INT 0
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: NEG
38695: PUSH
38696: LD_INT 1
38698: NEG
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: LD_INT 2
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 1
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 2
38740: PUSH
38741: LD_INT 1
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: LD_INT 2
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 1
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 0
38770: PUSH
38771: LD_INT 2
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 1
38780: NEG
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 2
38803: NEG
38804: PUSH
38805: LD_INT 2
38807: NEG
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: NEG
38816: PUSH
38817: LD_INT 3
38819: NEG
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: NEG
38828: PUSH
38829: LD_INT 3
38831: NEG
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 0
38839: PUSH
38840: LD_INT 3
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: PUSH
38851: LD_INT 2
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 3
38861: PUSH
38862: LD_INT 2
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 3
38871: PUSH
38872: LD_INT 3
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 2
38881: PUSH
38882: LD_INT 3
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: PUSH
38892: LD_INT 3
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: LD_INT 3
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: LD_INT 2
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 3
38922: NEG
38923: PUSH
38924: LD_INT 2
38926: NEG
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 3
38934: NEG
38935: PUSH
38936: LD_INT 3
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: LIST
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38975: LD_ADDR_VAR 0 46
38979: PUSH
38980: LD_INT 0
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: LD_INT 0
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 1
39013: PUSH
39014: LD_INT 1
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 0
39023: PUSH
39024: LD_INT 1
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 1
39033: NEG
39034: PUSH
39035: LD_INT 0
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 1
39044: NEG
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: LD_INT 2
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 0
39068: PUSH
39069: LD_INT 2
39071: NEG
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 2
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 2
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 1
39110: PUSH
39111: LD_INT 2
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 2
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 1
39130: NEG
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 2
39141: NEG
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: LD_INT 1
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 3
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 0
39176: PUSH
39177: LD_INT 3
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: PUSH
39188: LD_INT 2
39190: NEG
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 2
39198: PUSH
39199: LD_INT 1
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 3
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 3
39219: PUSH
39220: LD_INT 1
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 1
39229: PUSH
39230: LD_INT 3
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: LD_INT 3
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 1
39249: NEG
39250: PUSH
39251: LD_INT 2
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 2
39260: NEG
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: LD_INT 3
39271: NEG
39272: PUSH
39273: LD_INT 0
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 3
39282: NEG
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: LIST
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39323: LD_ADDR_VAR 0 47
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 0
39340: PUSH
39341: LD_INT 1
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 1
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 1
39404: NEG
39405: PUSH
39406: LD_INT 2
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: LD_INT 2
39419: NEG
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: LD_INT 1
39430: NEG
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 2
39438: NEG
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 2
39450: NEG
39451: PUSH
39452: LD_INT 2
39454: NEG
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39474: LD_ADDR_VAR 0 48
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 0
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 0
39491: PUSH
39492: LD_INT 1
39494: NEG
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 0
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 1
39532: NEG
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: NEG
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 2
39559: NEG
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: LD_INT 2
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 1
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39621: LD_ADDR_VAR 0 49
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 1
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 1
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 0
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 1
39679: NEG
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 1
39690: NEG
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: LD_INT 1
39705: NEG
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 2
39713: PUSH
39714: LD_INT 0
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 2
39723: PUSH
39724: LD_INT 1
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 2
39733: PUSH
39734: LD_INT 2
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 1
39743: PUSH
39744: LD_INT 2
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39765: LD_ADDR_VAR 0 50
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 0
39813: PUSH
39814: LD_INT 1
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: PUSH
39821: LD_INT 1
39823: NEG
39824: PUSH
39825: LD_INT 0
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: NEG
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 2
39846: PUSH
39847: LD_INT 1
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 2
39856: PUSH
39857: LD_INT 2
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: LD_INT 2
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 0
39876: PUSH
39877: LD_INT 2
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 1
39886: NEG
39887: PUSH
39888: LD_INT 1
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39909: LD_ADDR_VAR 0 51
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: LD_INT 0
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 0
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 0
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 1
39978: NEG
39979: PUSH
39980: LD_INT 1
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: LD_INT 2
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 0
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 2
40021: NEG
40022: PUSH
40023: LD_INT 0
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 2
40032: NEG
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40056: LD_ADDR_VAR 0 52
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: LD_INT 1
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 1
40084: PUSH
40085: LD_INT 0
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: PUSH
40095: LD_INT 1
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 1
40114: NEG
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 1
40125: NEG
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: LD_INT 2
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: NEG
40150: PUSH
40151: LD_INT 1
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 2
40160: NEG
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 2
40171: NEG
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 2
40183: NEG
40184: PUSH
40185: LD_INT 2
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40207: LD_ADDR_VAR 0 53
40211: PUSH
40212: LD_INT 0
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 1
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 1
40245: PUSH
40246: LD_INT 1
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 0
40255: PUSH
40256: LD_INT 1
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 1
40265: NEG
40266: PUSH
40267: LD_INT 0
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 1
40280: NEG
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: LD_INT 2
40292: NEG
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 0
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 2
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 2
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: LD_INT 2
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: LD_INT 2
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 0
40362: PUSH
40363: LD_INT 2
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 1
40372: NEG
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 2
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 2
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 2
40406: NEG
40407: PUSH
40408: LD_INT 2
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40437: LD_ADDR_VAR 0 54
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: LD_INT 0
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 0
40454: PUSH
40455: LD_INT 1
40457: NEG
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 1
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: LD_INT 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 0
40485: PUSH
40486: LD_INT 1
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: LD_INT 1
40510: NEG
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: NEG
40519: PUSH
40520: LD_INT 2
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 2
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 2
40552: PUSH
40553: LD_INT 0
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 2
40562: PUSH
40563: LD_INT 1
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 2
40572: PUSH
40573: LD_INT 2
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: LD_INT 2
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: LD_INT 2
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 1
40602: NEG
40603: PUSH
40604: LD_INT 1
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 2
40613: NEG
40614: PUSH
40615: LD_INT 0
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 2
40624: NEG
40625: PUSH
40626: LD_INT 1
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 2
40636: NEG
40637: PUSH
40638: LD_INT 2
40640: NEG
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40667: LD_ADDR_VAR 0 55
40671: PUSH
40672: LD_INT 0
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 0
40684: PUSH
40685: LD_INT 1
40687: NEG
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 1
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 0
40715: PUSH
40716: LD_INT 1
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 1
40725: NEG
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 1
40736: NEG
40737: PUSH
40738: LD_INT 1
40740: NEG
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 1
40748: NEG
40749: PUSH
40750: LD_INT 2
40752: NEG
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 0
40760: PUSH
40761: LD_INT 2
40763: NEG
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 1
40771: PUSH
40772: LD_INT 1
40774: NEG
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 2
40782: PUSH
40783: LD_INT 0
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 2
40792: PUSH
40793: LD_INT 1
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 2
40802: PUSH
40803: LD_INT 2
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: LD_INT 2
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: LD_INT 2
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 1
40832: NEG
40833: PUSH
40834: LD_INT 1
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 2
40843: NEG
40844: PUSH
40845: LD_INT 0
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 2
40854: NEG
40855: PUSH
40856: LD_INT 1
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 2
40866: NEG
40867: PUSH
40868: LD_INT 2
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40897: LD_ADDR_VAR 0 56
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: LD_INT 0
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 0
40914: PUSH
40915: LD_INT 1
40917: NEG
40918: PUSH
40919: EMPTY
40920: LIST
40921: LIST
40922: PUSH
40923: LD_INT 1
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 1
40935: PUSH
40936: LD_INT 1
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 1
40955: NEG
40956: PUSH
40957: LD_INT 0
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 1
40966: NEG
40967: PUSH
40968: LD_INT 1
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 1
40978: NEG
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 0
40990: PUSH
40991: LD_INT 2
40993: NEG
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 1
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: PUSH
41010: LD_INT 2
41012: PUSH
41013: LD_INT 0
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 2
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 2
41032: PUSH
41033: LD_INT 2
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 1
41042: PUSH
41043: LD_INT 2
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 0
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 1
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 2
41073: NEG
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 2
41084: NEG
41085: PUSH
41086: LD_INT 1
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 2
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: LIST
41124: LIST
41125: LIST
41126: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41127: LD_ADDR_VAR 0 57
41131: PUSH
41132: LD_INT 0
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: LD_INT 1
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 1
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: LD_INT 1
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 0
41175: PUSH
41176: LD_INT 1
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 1
41185: NEG
41186: PUSH
41187: LD_INT 0
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 1
41196: NEG
41197: PUSH
41198: LD_INT 1
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 1
41208: NEG
41209: PUSH
41210: LD_INT 2
41212: NEG
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: LD_INT 2
41223: NEG
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PUSH
41229: LD_INT 1
41231: PUSH
41232: LD_INT 1
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 2
41242: PUSH
41243: LD_INT 0
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 2
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 2
41262: PUSH
41263: LD_INT 2
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 1
41272: PUSH
41273: LD_INT 2
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 0
41282: PUSH
41283: LD_INT 2
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 1
41292: NEG
41293: PUSH
41294: LD_INT 1
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 2
41303: NEG
41304: PUSH
41305: LD_INT 0
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 2
41314: NEG
41315: PUSH
41316: LD_INT 1
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 2
41326: NEG
41327: PUSH
41328: LD_INT 2
41330: NEG
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: LIST
41344: LIST
41345: LIST
41346: LIST
41347: LIST
41348: LIST
41349: LIST
41350: LIST
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41357: LD_ADDR_VAR 0 58
41361: PUSH
41362: LD_INT 0
41364: PUSH
41365: LD_INT 0
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: LD_INT 1
41377: NEG
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 1
41385: PUSH
41386: LD_INT 0
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 1
41395: PUSH
41396: LD_INT 1
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 0
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 1
41415: NEG
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 1
41426: NEG
41427: PUSH
41428: LD_INT 1
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: NEG
41439: PUSH
41440: LD_INT 2
41442: NEG
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: LD_INT 0
41450: PUSH
41451: LD_INT 2
41453: NEG
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 1
41461: PUSH
41462: LD_INT 1
41464: NEG
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 2
41472: PUSH
41473: LD_INT 0
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 2
41482: PUSH
41483: LD_INT 1
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 2
41492: PUSH
41493: LD_INT 2
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 1
41502: PUSH
41503: LD_INT 2
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 0
41512: PUSH
41513: LD_INT 2
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 1
41522: NEG
41523: PUSH
41524: LD_INT 1
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 2
41533: NEG
41534: PUSH
41535: LD_INT 0
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 2
41544: NEG
41545: PUSH
41546: LD_INT 1
41548: NEG
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 2
41556: NEG
41557: PUSH
41558: LD_INT 2
41560: NEG
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: LIST
41570: LIST
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41587: LD_ADDR_VAR 0 59
41591: PUSH
41592: LD_INT 0
41594: PUSH
41595: LD_INT 0
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 0
41604: PUSH
41605: LD_INT 1
41607: NEG
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 1
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 1
41625: PUSH
41626: LD_INT 1
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: LD_INT 0
41635: PUSH
41636: LD_INT 1
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 1
41645: NEG
41646: PUSH
41647: LD_INT 0
41649: PUSH
41650: EMPTY
41651: LIST
41652: LIST
41653: PUSH
41654: LD_INT 1
41656: NEG
41657: PUSH
41658: LD_INT 1
41660: NEG
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41675: LD_ADDR_VAR 0 60
41679: PUSH
41680: LD_INT 0
41682: PUSH
41683: LD_INT 0
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 0
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 1
41703: PUSH
41704: LD_INT 0
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 1
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 0
41723: PUSH
41724: LD_INT 1
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 1
41733: NEG
41734: PUSH
41735: LD_INT 0
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 1
41744: NEG
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41763: LD_ADDR_VAR 0 61
41767: PUSH
41768: LD_INT 0
41770: PUSH
41771: LD_INT 0
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: LD_INT 1
41783: NEG
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 1
41791: PUSH
41792: LD_INT 0
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 1
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 0
41811: PUSH
41812: LD_INT 1
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 1
41821: NEG
41822: PUSH
41823: LD_INT 0
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 1
41832: NEG
41833: PUSH
41834: LD_INT 1
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: LIST
41846: LIST
41847: LIST
41848: LIST
41849: LIST
41850: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41851: LD_ADDR_VAR 0 62
41855: PUSH
41856: LD_INT 0
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 0
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 1
41879: PUSH
41880: LD_INT 0
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 1
41889: PUSH
41890: LD_INT 1
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 0
41899: PUSH
41900: LD_INT 1
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 1
41909: NEG
41910: PUSH
41911: LD_INT 0
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 1
41920: NEG
41921: PUSH
41922: LD_INT 1
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: LIST
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41939: LD_ADDR_VAR 0 63
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 0
41956: PUSH
41957: LD_INT 1
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 1
41967: PUSH
41968: LD_INT 0
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 1
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 0
41987: PUSH
41988: LD_INT 1
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 1
41997: NEG
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 1
42008: NEG
42009: PUSH
42010: LD_INT 1
42012: NEG
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: LIST
42026: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42027: LD_ADDR_VAR 0 64
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: LD_INT 0
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: LD_INT 1
42047: NEG
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 1
42055: PUSH
42056: LD_INT 0
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 1
42065: PUSH
42066: LD_INT 1
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 0
42075: PUSH
42076: LD_INT 1
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 1
42085: NEG
42086: PUSH
42087: LD_INT 0
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PUSH
42094: LD_INT 1
42096: NEG
42097: PUSH
42098: LD_INT 1
42100: NEG
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: ST_TO_ADDR
// end ; 1 :
42115: GO 48012
42117: LD_INT 1
42119: DOUBLE
42120: EQUAL
42121: IFTRUE 42125
42123: GO 44748
42125: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42126: LD_ADDR_VAR 0 11
42130: PUSH
42131: LD_INT 1
42133: NEG
42134: PUSH
42135: LD_INT 3
42137: NEG
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 3
42148: NEG
42149: PUSH
42150: EMPTY
42151: LIST
42152: LIST
42153: PUSH
42154: LD_INT 1
42156: PUSH
42157: LD_INT 2
42159: NEG
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: LIST
42169: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42170: LD_ADDR_VAR 0 12
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 3
42188: PUSH
42189: LD_INT 0
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: LD_INT 1
42201: PUSH
42202: EMPTY
42203: LIST
42204: LIST
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: LIST
42210: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42211: LD_ADDR_VAR 0 13
42215: PUSH
42216: LD_INT 3
42218: PUSH
42219: LD_INT 2
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 3
42228: PUSH
42229: LD_INT 3
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 2
42238: PUSH
42239: LD_INT 3
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: LIST
42250: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42251: LD_ADDR_VAR 0 14
42255: PUSH
42256: LD_INT 1
42258: PUSH
42259: LD_INT 3
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 0
42268: PUSH
42269: LD_INT 3
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PUSH
42276: LD_INT 1
42278: NEG
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42292: LD_ADDR_VAR 0 15
42296: PUSH
42297: LD_INT 2
42299: NEG
42300: PUSH
42301: LD_INT 1
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 3
42310: NEG
42311: PUSH
42312: LD_INT 0
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 3
42321: NEG
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: LIST
42335: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42336: LD_ADDR_VAR 0 16
42340: PUSH
42341: LD_INT 2
42343: NEG
42344: PUSH
42345: LD_INT 3
42347: NEG
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 3
42355: NEG
42356: PUSH
42357: LD_INT 2
42359: NEG
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 3
42367: NEG
42368: PUSH
42369: LD_INT 3
42371: NEG
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: LIST
42381: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42382: LD_ADDR_VAR 0 17
42386: PUSH
42387: LD_INT 1
42389: NEG
42390: PUSH
42391: LD_INT 3
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 0
42401: PUSH
42402: LD_INT 3
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 1
42412: PUSH
42413: LD_INT 2
42415: NEG
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: LIST
42425: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42426: LD_ADDR_VAR 0 18
42430: PUSH
42431: LD_INT 2
42433: PUSH
42434: LD_INT 1
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 3
42444: PUSH
42445: LD_INT 0
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: LD_INT 3
42454: PUSH
42455: LD_INT 1
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42467: LD_ADDR_VAR 0 19
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: LD_INT 2
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 3
42484: PUSH
42485: LD_INT 3
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 2
42494: PUSH
42495: LD_INT 3
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: LIST
42506: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42507: LD_ADDR_VAR 0 20
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: LD_INT 3
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 0
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 2
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: LIST
42547: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42548: LD_ADDR_VAR 0 21
42552: PUSH
42553: LD_INT 2
42555: NEG
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 3
42566: NEG
42567: PUSH
42568: LD_INT 0
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: NEG
42578: PUSH
42579: LD_INT 1
42581: NEG
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: LIST
42591: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42592: LD_ADDR_VAR 0 22
42596: PUSH
42597: LD_INT 2
42599: NEG
42600: PUSH
42601: LD_INT 3
42603: NEG
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 3
42611: NEG
42612: PUSH
42613: LD_INT 2
42615: NEG
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 3
42623: NEG
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: LIST
42637: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
42638: LD_ADDR_VAR 0 23
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: LD_INT 3
42648: NEG
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 1
42656: NEG
42657: PUSH
42658: LD_INT 4
42660: NEG
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 1
42668: PUSH
42669: LD_INT 3
42671: NEG
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: LIST
42681: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
42682: LD_ADDR_VAR 0 24
42686: PUSH
42687: LD_INT 3
42689: PUSH
42690: LD_INT 0
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 3
42699: PUSH
42700: LD_INT 1
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 4
42710: PUSH
42711: LD_INT 1
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: LIST
42722: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
42723: LD_ADDR_VAR 0 25
42727: PUSH
42728: LD_INT 3
42730: PUSH
42731: LD_INT 3
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 4
42740: PUSH
42741: LD_INT 3
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 3
42750: PUSH
42751: LD_INT 4
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: LIST
42762: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
42763: LD_ADDR_VAR 0 26
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 1
42780: PUSH
42781: LD_INT 4
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 1
42790: NEG
42791: PUSH
42792: LD_INT 3
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: LIST
42803: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42804: LD_ADDR_VAR 0 27
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: LD_INT 0
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 3
42822: NEG
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PUSH
42831: LD_INT 4
42833: NEG
42834: PUSH
42835: LD_INT 1
42837: NEG
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: LIST
42847: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42848: LD_ADDR_VAR 0 28
42852: PUSH
42853: LD_INT 3
42855: NEG
42856: PUSH
42857: LD_INT 3
42859: NEG
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 3
42867: NEG
42868: PUSH
42869: LD_INT 4
42871: NEG
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: LD_INT 4
42879: NEG
42880: PUSH
42881: LD_INT 3
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: LIST
42893: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42894: LD_ADDR_VAR 0 29
42898: PUSH
42899: LD_INT 1
42901: NEG
42902: PUSH
42903: LD_INT 3
42905: NEG
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: LD_INT 3
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 1
42924: PUSH
42925: LD_INT 2
42927: NEG
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 1
42935: NEG
42936: PUSH
42937: LD_INT 4
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 0
42947: PUSH
42948: LD_INT 4
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 1
42958: PUSH
42959: LD_INT 3
42961: NEG
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 1
42969: NEG
42970: PUSH
42971: LD_INT 5
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 0
42981: PUSH
42982: LD_INT 5
42984: NEG
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 1
42992: PUSH
42993: LD_INT 4
42995: NEG
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 1
43003: NEG
43004: PUSH
43005: LD_INT 6
43007: NEG
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: LD_INT 0
43015: PUSH
43016: LD_INT 6
43018: NEG
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PUSH
43024: LD_INT 1
43026: PUSH
43027: LD_INT 5
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43049: LD_ADDR_VAR 0 30
43053: PUSH
43054: LD_INT 2
43056: PUSH
43057: LD_INT 1
43059: NEG
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 3
43067: PUSH
43068: LD_INT 0
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 3
43077: PUSH
43078: LD_INT 1
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 3
43087: PUSH
43088: LD_INT 1
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: LD_INT 4
43098: PUSH
43099: LD_INT 0
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 4
43108: PUSH
43109: LD_INT 1
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 4
43118: PUSH
43119: LD_INT 1
43121: NEG
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 5
43129: PUSH
43130: LD_INT 0
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 5
43139: PUSH
43140: LD_INT 1
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 5
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 6
43160: PUSH
43161: LD_INT 0
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 6
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43192: LD_ADDR_VAR 0 31
43196: PUSH
43197: LD_INT 3
43199: PUSH
43200: LD_INT 2
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 3
43209: PUSH
43210: LD_INT 3
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 2
43219: PUSH
43220: LD_INT 3
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 4
43229: PUSH
43230: LD_INT 3
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 4
43239: PUSH
43240: LD_INT 4
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 3
43249: PUSH
43250: LD_INT 4
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 5
43259: PUSH
43260: LD_INT 4
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: LD_INT 5
43269: PUSH
43270: LD_INT 5
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 4
43279: PUSH
43280: LD_INT 5
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: PUSH
43287: LD_INT 6
43289: PUSH
43290: LD_INT 5
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 6
43299: PUSH
43300: LD_INT 6
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 5
43309: PUSH
43310: LD_INT 6
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: LIST
43321: LIST
43322: LIST
43323: LIST
43324: LIST
43325: LIST
43326: LIST
43327: LIST
43328: LIST
43329: LIST
43330: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43331: LD_ADDR_VAR 0 32
43335: PUSH
43336: LD_INT 1
43338: PUSH
43339: LD_INT 3
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 0
43348: PUSH
43349: LD_INT 3
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: PUSH
43356: LD_INT 1
43358: NEG
43359: PUSH
43360: LD_INT 2
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: LD_INT 4
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 4
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 1
43389: NEG
43390: PUSH
43391: LD_INT 3
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 1
43400: PUSH
43401: LD_INT 5
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: LD_INT 5
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 1
43420: NEG
43421: PUSH
43422: LD_INT 4
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 1
43431: PUSH
43432: LD_INT 6
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 0
43441: PUSH
43442: LD_INT 6
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 1
43451: NEG
43452: PUSH
43453: LD_INT 5
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: LIST
43467: LIST
43468: LIST
43469: LIST
43470: LIST
43471: LIST
43472: LIST
43473: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43474: LD_ADDR_VAR 0 33
43478: PUSH
43479: LD_INT 2
43481: NEG
43482: PUSH
43483: LD_INT 1
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 3
43492: NEG
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: NEG
43504: PUSH
43505: LD_INT 1
43507: NEG
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 3
43515: NEG
43516: PUSH
43517: LD_INT 1
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 4
43526: NEG
43527: PUSH
43528: LD_INT 0
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 4
43537: NEG
43538: PUSH
43539: LD_INT 1
43541: NEG
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 4
43549: NEG
43550: PUSH
43551: LD_INT 1
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 5
43560: NEG
43561: PUSH
43562: LD_INT 0
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 5
43571: NEG
43572: PUSH
43573: LD_INT 1
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 5
43583: NEG
43584: PUSH
43585: LD_INT 1
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 6
43594: NEG
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 6
43605: NEG
43606: PUSH
43607: LD_INT 1
43609: NEG
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: LIST
43619: LIST
43620: LIST
43621: LIST
43622: LIST
43623: LIST
43624: LIST
43625: LIST
43626: LIST
43627: LIST
43628: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
43629: LD_ADDR_VAR 0 34
43633: PUSH
43634: LD_INT 2
43636: NEG
43637: PUSH
43638: LD_INT 3
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 3
43648: NEG
43649: PUSH
43650: LD_INT 2
43652: NEG
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 3
43660: NEG
43661: PUSH
43662: LD_INT 3
43664: NEG
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PUSH
43670: LD_INT 3
43672: NEG
43673: PUSH
43674: LD_INT 4
43676: NEG
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: LD_INT 4
43684: NEG
43685: PUSH
43686: LD_INT 3
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 4
43696: NEG
43697: PUSH
43698: LD_INT 4
43700: NEG
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 4
43708: NEG
43709: PUSH
43710: LD_INT 5
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 5
43720: NEG
43721: PUSH
43722: LD_INT 4
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 5
43732: NEG
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 5
43744: NEG
43745: PUSH
43746: LD_INT 6
43748: NEG
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 6
43756: NEG
43757: PUSH
43758: LD_INT 5
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 6
43768: NEG
43769: PUSH
43770: LD_INT 6
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: LIST
43785: LIST
43786: LIST
43787: LIST
43788: LIST
43789: LIST
43790: LIST
43791: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
43792: LD_ADDR_VAR 0 41
43796: PUSH
43797: LD_INT 0
43799: PUSH
43800: LD_INT 2
43802: NEG
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 1
43810: NEG
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 1
43822: PUSH
43823: LD_INT 2
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: LIST
43835: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43836: LD_ADDR_VAR 0 42
43840: PUSH
43841: LD_INT 2
43843: PUSH
43844: LD_INT 0
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: LD_INT 2
43853: PUSH
43854: LD_INT 1
43856: NEG
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: LD_INT 3
43864: PUSH
43865: LD_INT 1
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: LIST
43876: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43877: LD_ADDR_VAR 0 43
43881: PUSH
43882: LD_INT 2
43884: PUSH
43885: LD_INT 2
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 3
43894: PUSH
43895: LD_INT 2
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 2
43904: PUSH
43905: LD_INT 3
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: LIST
43916: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43917: LD_ADDR_VAR 0 44
43921: PUSH
43922: LD_INT 0
43924: PUSH
43925: LD_INT 2
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: PUSH
43942: LD_INT 1
43944: NEG
43945: PUSH
43946: LD_INT 2
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: LIST
43957: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43958: LD_ADDR_VAR 0 45
43962: PUSH
43963: LD_INT 2
43965: NEG
43966: PUSH
43967: LD_INT 0
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 2
43976: NEG
43977: PUSH
43978: LD_INT 1
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 3
43987: NEG
43988: PUSH
43989: LD_INT 1
43991: NEG
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: LIST
44001: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44002: LD_ADDR_VAR 0 46
44006: PUSH
44007: LD_INT 2
44009: NEG
44010: PUSH
44011: LD_INT 2
44013: NEG
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 2
44021: NEG
44022: PUSH
44023: LD_INT 3
44025: NEG
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 3
44033: NEG
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: LIST
44047: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44048: LD_ADDR_VAR 0 47
44052: PUSH
44053: LD_INT 2
44055: NEG
44056: PUSH
44057: LD_INT 3
44059: NEG
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: LD_INT 3
44071: NEG
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44081: LD_ADDR_VAR 0 48
44085: PUSH
44086: LD_INT 1
44088: PUSH
44089: LD_INT 2
44091: NEG
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 2
44099: PUSH
44100: LD_INT 1
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44112: LD_ADDR_VAR 0 49
44116: PUSH
44117: LD_INT 3
44119: PUSH
44120: LD_INT 1
44122: PUSH
44123: EMPTY
44124: LIST
44125: LIST
44126: PUSH
44127: LD_INT 3
44129: PUSH
44130: LD_INT 2
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44141: LD_ADDR_VAR 0 50
44145: PUSH
44146: LD_INT 2
44148: PUSH
44149: LD_INT 3
44151: PUSH
44152: EMPTY
44153: LIST
44154: LIST
44155: PUSH
44156: LD_INT 1
44158: PUSH
44159: LD_INT 3
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44170: LD_ADDR_VAR 0 51
44174: PUSH
44175: LD_INT 1
44177: NEG
44178: PUSH
44179: LD_INT 2
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 2
44188: NEG
44189: PUSH
44190: LD_INT 1
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44201: LD_ADDR_VAR 0 52
44205: PUSH
44206: LD_INT 3
44208: NEG
44209: PUSH
44210: LD_INT 1
44212: NEG
44213: PUSH
44214: EMPTY
44215: LIST
44216: LIST
44217: PUSH
44218: LD_INT 3
44220: NEG
44221: PUSH
44222: LD_INT 2
44224: NEG
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44234: LD_ADDR_VAR 0 53
44238: PUSH
44239: LD_INT 1
44241: NEG
44242: PUSH
44243: LD_INT 3
44245: NEG
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 0
44253: PUSH
44254: LD_INT 3
44256: NEG
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 1
44264: PUSH
44265: LD_INT 2
44267: NEG
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: LIST
44277: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44278: LD_ADDR_VAR 0 54
44282: PUSH
44283: LD_INT 2
44285: PUSH
44286: LD_INT 1
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 3
44296: PUSH
44297: LD_INT 0
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 3
44306: PUSH
44307: LD_INT 1
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: LIST
44318: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44319: LD_ADDR_VAR 0 55
44323: PUSH
44324: LD_INT 3
44326: PUSH
44327: LD_INT 2
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 3
44336: PUSH
44337: LD_INT 3
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 2
44346: PUSH
44347: LD_INT 3
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: LIST
44358: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44359: LD_ADDR_VAR 0 56
44363: PUSH
44364: LD_INT 1
44366: PUSH
44367: LD_INT 3
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 0
44376: PUSH
44377: LD_INT 3
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: LD_INT 2
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: LIST
44399: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44400: LD_ADDR_VAR 0 57
44404: PUSH
44405: LD_INT 2
44407: NEG
44408: PUSH
44409: LD_INT 1
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 3
44418: NEG
44419: PUSH
44420: LD_INT 0
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 3
44429: NEG
44430: PUSH
44431: LD_INT 1
44433: NEG
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: LIST
44443: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44444: LD_ADDR_VAR 0 58
44448: PUSH
44449: LD_INT 2
44451: NEG
44452: PUSH
44453: LD_INT 3
44455: NEG
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 3
44463: NEG
44464: PUSH
44465: LD_INT 2
44467: NEG
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 3
44475: NEG
44476: PUSH
44477: LD_INT 3
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: LIST
44489: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44490: LD_ADDR_VAR 0 59
44494: PUSH
44495: LD_INT 1
44497: NEG
44498: PUSH
44499: LD_INT 2
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 0
44509: PUSH
44510: LD_INT 2
44512: NEG
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 1
44520: PUSH
44521: LD_INT 1
44523: NEG
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: LIST
44533: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44534: LD_ADDR_VAR 0 60
44538: PUSH
44539: LD_INT 1
44541: PUSH
44542: LD_INT 1
44544: NEG
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 2
44552: PUSH
44553: LD_INT 0
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 2
44562: PUSH
44563: LD_INT 1
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: LIST
44574: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44575: LD_ADDR_VAR 0 61
44579: PUSH
44580: LD_INT 2
44582: PUSH
44583: LD_INT 1
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 2
44592: PUSH
44593: LD_INT 2
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 1
44602: PUSH
44603: LD_INT 2
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: LIST
44614: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44615: LD_ADDR_VAR 0 62
44619: PUSH
44620: LD_INT 1
44622: PUSH
44623: LD_INT 2
44625: PUSH
44626: EMPTY
44627: LIST
44628: LIST
44629: PUSH
44630: LD_INT 0
44632: PUSH
44633: LD_INT 2
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 1
44642: NEG
44643: PUSH
44644: LD_INT 1
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: LIST
44655: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
44656: LD_ADDR_VAR 0 63
44660: PUSH
44661: LD_INT 1
44663: NEG
44664: PUSH
44665: LD_INT 1
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 2
44674: NEG
44675: PUSH
44676: LD_INT 0
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 2
44685: NEG
44686: PUSH
44687: LD_INT 1
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: LIST
44699: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44700: LD_ADDR_VAR 0 64
44704: PUSH
44705: LD_INT 1
44707: NEG
44708: PUSH
44709: LD_INT 2
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 2
44719: NEG
44720: PUSH
44721: LD_INT 1
44723: NEG
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 2
44731: NEG
44732: PUSH
44733: LD_INT 2
44735: NEG
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: LIST
44745: ST_TO_ADDR
// end ; 2 :
44746: GO 48012
44748: LD_INT 2
44750: DOUBLE
44751: EQUAL
44752: IFTRUE 44756
44754: GO 48011
44756: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
44757: LD_ADDR_VAR 0 29
44761: PUSH
44762: LD_INT 4
44764: PUSH
44765: LD_INT 0
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 4
44774: PUSH
44775: LD_INT 1
44777: NEG
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 5
44785: PUSH
44786: LD_INT 0
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 5
44795: PUSH
44796: LD_INT 1
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 4
44805: PUSH
44806: LD_INT 1
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 3
44815: PUSH
44816: LD_INT 0
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 3
44825: PUSH
44826: LD_INT 1
44828: NEG
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PUSH
44834: LD_INT 3
44836: PUSH
44837: LD_INT 2
44839: NEG
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 5
44847: PUSH
44848: LD_INT 2
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 3
44857: PUSH
44858: LD_INT 3
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 3
44867: PUSH
44868: LD_INT 2
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 3
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 4
44887: PUSH
44888: LD_INT 4
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: LD_INT 4
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 2
44907: PUSH
44908: LD_INT 3
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 2
44917: PUSH
44918: LD_INT 2
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 4
44927: PUSH
44928: LD_INT 2
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 2
44937: PUSH
44938: LD_INT 4
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 0
44947: PUSH
44948: LD_INT 4
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 0
44957: PUSH
44958: LD_INT 3
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 1
44967: PUSH
44968: LD_INT 4
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 1
44977: PUSH
44978: LD_INT 5
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 0
44987: PUSH
44988: LD_INT 5
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 1
44997: NEG
44998: PUSH
44999: LD_INT 4
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 1
45008: NEG
45009: PUSH
45010: LD_INT 3
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 2
45019: PUSH
45020: LD_INT 5
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 2
45029: NEG
45030: PUSH
45031: LD_INT 3
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: LD_INT 0
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 3
45051: NEG
45052: PUSH
45053: LD_INT 1
45055: NEG
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: PUSH
45061: LD_INT 2
45063: NEG
45064: PUSH
45065: LD_INT 0
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: LD_INT 2
45074: NEG
45075: PUSH
45076: LD_INT 1
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 3
45085: NEG
45086: PUSH
45087: LD_INT 1
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 4
45096: NEG
45097: PUSH
45098: LD_INT 0
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 4
45107: NEG
45108: PUSH
45109: LD_INT 1
45111: NEG
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 4
45119: NEG
45120: PUSH
45121: LD_INT 2
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 2
45131: NEG
45132: PUSH
45133: LD_INT 2
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 4
45142: NEG
45143: PUSH
45144: LD_INT 4
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 4
45154: NEG
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 3
45166: NEG
45167: PUSH
45168: LD_INT 4
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 3
45178: NEG
45179: PUSH
45180: LD_INT 3
45182: NEG
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 4
45190: NEG
45191: PUSH
45192: LD_INT 3
45194: NEG
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 5
45202: NEG
45203: PUSH
45204: LD_INT 4
45206: NEG
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: LD_INT 5
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 3
45226: NEG
45227: PUSH
45228: LD_INT 5
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 5
45238: NEG
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: LIST
45287: LIST
45288: LIST
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45295: LD_ADDR_VAR 0 30
45299: PUSH
45300: LD_INT 4
45302: PUSH
45303: LD_INT 4
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 4
45312: PUSH
45313: LD_INT 3
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PUSH
45320: LD_INT 5
45322: PUSH
45323: LD_INT 4
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 5
45332: PUSH
45333: LD_INT 5
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: LD_INT 4
45342: PUSH
45343: LD_INT 5
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: PUSH
45350: LD_INT 3
45352: PUSH
45353: LD_INT 4
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 3
45362: PUSH
45363: LD_INT 3
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: PUSH
45370: LD_INT 5
45372: PUSH
45373: LD_INT 3
45375: PUSH
45376: EMPTY
45377: LIST
45378: LIST
45379: PUSH
45380: LD_INT 3
45382: PUSH
45383: LD_INT 5
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: PUSH
45390: LD_INT 0
45392: PUSH
45393: LD_INT 3
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PUSH
45400: LD_INT 0
45402: PUSH
45403: LD_INT 2
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: PUSH
45410: LD_INT 1
45412: PUSH
45413: LD_INT 3
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: PUSH
45420: LD_INT 1
45422: PUSH
45423: LD_INT 4
45425: PUSH
45426: EMPTY
45427: LIST
45428: LIST
45429: PUSH
45430: LD_INT 0
45432: PUSH
45433: LD_INT 4
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: PUSH
45440: LD_INT 1
45442: NEG
45443: PUSH
45444: LD_INT 3
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 1
45453: NEG
45454: PUSH
45455: LD_INT 2
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 2
45464: PUSH
45465: LD_INT 4
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: LD_INT 2
45474: NEG
45475: PUSH
45476: LD_INT 2
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 4
45485: NEG
45486: PUSH
45487: LD_INT 0
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 4
45496: NEG
45497: PUSH
45498: LD_INT 1
45500: NEG
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 3
45508: NEG
45509: PUSH
45510: LD_INT 0
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 3
45519: NEG
45520: PUSH
45521: LD_INT 1
45523: PUSH
45524: EMPTY
45525: LIST
45526: LIST
45527: PUSH
45528: LD_INT 4
45530: NEG
45531: PUSH
45532: LD_INT 1
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 5
45541: NEG
45542: PUSH
45543: LD_INT 0
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 5
45552: NEG
45553: PUSH
45554: LD_INT 1
45556: NEG
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 5
45564: NEG
45565: PUSH
45566: LD_INT 2
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 3
45576: NEG
45577: PUSH
45578: LD_INT 2
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 3
45587: NEG
45588: PUSH
45589: LD_INT 3
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 3
45599: NEG
45600: PUSH
45601: LD_INT 4
45603: NEG
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 2
45611: NEG
45612: PUSH
45613: LD_INT 3
45615: NEG
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 2
45623: NEG
45624: PUSH
45625: LD_INT 2
45627: NEG
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: LD_INT 3
45635: NEG
45636: PUSH
45637: LD_INT 2
45639: NEG
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 4
45647: NEG
45648: PUSH
45649: LD_INT 3
45651: NEG
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: LD_INT 4
45663: NEG
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 2
45671: NEG
45672: PUSH
45673: LD_INT 4
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 4
45683: NEG
45684: PUSH
45685: LD_INT 2
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 0
45695: PUSH
45696: LD_INT 4
45698: NEG
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PUSH
45704: LD_INT 0
45706: PUSH
45707: LD_INT 5
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 1
45717: PUSH
45718: LD_INT 4
45720: NEG
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 1
45728: PUSH
45729: LD_INT 3
45731: NEG
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 0
45739: PUSH
45740: LD_INT 3
45742: NEG
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PUSH
45748: LD_INT 1
45750: NEG
45751: PUSH
45752: LD_INT 4
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: NEG
45763: PUSH
45764: LD_INT 5
45766: NEG
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 2
45774: PUSH
45775: LD_INT 3
45777: NEG
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: PUSH
45783: LD_INT 2
45785: NEG
45786: PUSH
45787: LD_INT 5
45789: NEG
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45842: LD_ADDR_VAR 0 31
45846: PUSH
45847: LD_INT 0
45849: PUSH
45850: LD_INT 4
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 0
45859: PUSH
45860: LD_INT 3
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 1
45869: PUSH
45870: LD_INT 4
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: LD_INT 1
45879: PUSH
45880: LD_INT 5
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 0
45889: PUSH
45890: LD_INT 5
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 1
45899: NEG
45900: PUSH
45901: LD_INT 4
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: LD_INT 1
45910: NEG
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 2
45921: PUSH
45922: LD_INT 5
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 2
45931: NEG
45932: PUSH
45933: LD_INT 3
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 3
45942: NEG
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 1
45957: NEG
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: PUSH
45963: LD_INT 2
45965: NEG
45966: PUSH
45967: LD_INT 0
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 2
45976: NEG
45977: PUSH
45978: LD_INT 1
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 3
45987: NEG
45988: PUSH
45989: LD_INT 1
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 4
45998: NEG
45999: PUSH
46000: LD_INT 0
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 4
46009: NEG
46010: PUSH
46011: LD_INT 1
46013: NEG
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 4
46021: NEG
46022: PUSH
46023: LD_INT 2
46025: NEG
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 2
46033: NEG
46034: PUSH
46035: LD_INT 2
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 4
46044: NEG
46045: PUSH
46046: LD_INT 4
46048: NEG
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 4
46056: NEG
46057: PUSH
46058: LD_INT 5
46060: NEG
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: NEG
46069: PUSH
46070: LD_INT 4
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 3
46080: NEG
46081: PUSH
46082: LD_INT 3
46084: NEG
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 4
46092: NEG
46093: PUSH
46094: LD_INT 3
46096: NEG
46097: PUSH
46098: EMPTY
46099: LIST
46100: LIST
46101: PUSH
46102: LD_INT 5
46104: NEG
46105: PUSH
46106: LD_INT 4
46108: NEG
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: LD_INT 5
46116: NEG
46117: PUSH
46118: LD_INT 5
46120: NEG
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 3
46128: NEG
46129: PUSH
46130: LD_INT 5
46132: NEG
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 5
46140: NEG
46141: PUSH
46142: LD_INT 3
46144: NEG
46145: PUSH
46146: EMPTY
46147: LIST
46148: LIST
46149: PUSH
46150: LD_INT 0
46152: PUSH
46153: LD_INT 3
46155: NEG
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: LD_INT 4
46166: NEG
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 1
46174: PUSH
46175: LD_INT 3
46177: NEG
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 1
46185: PUSH
46186: LD_INT 2
46188: NEG
46189: PUSH
46190: EMPTY
46191: LIST
46192: LIST
46193: PUSH
46194: LD_INT 0
46196: PUSH
46197: LD_INT 2
46199: NEG
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: NEG
46208: PUSH
46209: LD_INT 3
46211: NEG
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: PUSH
46217: LD_INT 1
46219: NEG
46220: PUSH
46221: LD_INT 4
46223: NEG
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 2
46231: PUSH
46232: LD_INT 2
46234: NEG
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: PUSH
46240: LD_INT 2
46242: NEG
46243: PUSH
46244: LD_INT 4
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 4
46254: PUSH
46255: LD_INT 0
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 4
46264: PUSH
46265: LD_INT 1
46267: NEG
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 5
46275: PUSH
46276: LD_INT 0
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 5
46285: PUSH
46286: LD_INT 1
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 4
46295: PUSH
46296: LD_INT 1
46298: PUSH
46299: EMPTY
46300: LIST
46301: LIST
46302: PUSH
46303: LD_INT 3
46305: PUSH
46306: LD_INT 0
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 3
46315: PUSH
46316: LD_INT 1
46318: NEG
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: LD_INT 2
46329: NEG
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 5
46337: PUSH
46338: LD_INT 2
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46392: LD_ADDR_VAR 0 32
46396: PUSH
46397: LD_INT 4
46399: NEG
46400: PUSH
46401: LD_INT 0
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 4
46410: NEG
46411: PUSH
46412: LD_INT 1
46414: NEG
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 3
46422: NEG
46423: PUSH
46424: LD_INT 0
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 3
46433: NEG
46434: PUSH
46435: LD_INT 1
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: LD_INT 4
46444: NEG
46445: PUSH
46446: LD_INT 1
46448: PUSH
46449: EMPTY
46450: LIST
46451: LIST
46452: PUSH
46453: LD_INT 5
46455: NEG
46456: PUSH
46457: LD_INT 0
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 5
46466: NEG
46467: PUSH
46468: LD_INT 1
46470: NEG
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 5
46478: NEG
46479: PUSH
46480: LD_INT 2
46482: NEG
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 3
46490: NEG
46491: PUSH
46492: LD_INT 2
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: LD_INT 3
46501: NEG
46502: PUSH
46503: LD_INT 3
46505: NEG
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: PUSH
46511: LD_INT 3
46513: NEG
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 2
46525: NEG
46526: PUSH
46527: LD_INT 3
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 2
46537: NEG
46538: PUSH
46539: LD_INT 2
46541: NEG
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 3
46549: NEG
46550: PUSH
46551: LD_INT 2
46553: NEG
46554: PUSH
46555: EMPTY
46556: LIST
46557: LIST
46558: PUSH
46559: LD_INT 4
46561: NEG
46562: PUSH
46563: LD_INT 3
46565: NEG
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 4
46573: NEG
46574: PUSH
46575: LD_INT 4
46577: NEG
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: LD_INT 2
46585: NEG
46586: PUSH
46587: LD_INT 4
46589: NEG
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 4
46597: NEG
46598: PUSH
46599: LD_INT 2
46601: NEG
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: PUSH
46607: LD_INT 0
46609: PUSH
46610: LD_INT 4
46612: NEG
46613: PUSH
46614: EMPTY
46615: LIST
46616: LIST
46617: PUSH
46618: LD_INT 0
46620: PUSH
46621: LD_INT 5
46623: NEG
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 1
46631: PUSH
46632: LD_INT 4
46634: NEG
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 1
46642: PUSH
46643: LD_INT 3
46645: NEG
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 0
46653: PUSH
46654: LD_INT 3
46656: NEG
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: PUSH
46662: LD_INT 1
46664: NEG
46665: PUSH
46666: LD_INT 4
46668: NEG
46669: PUSH
46670: EMPTY
46671: LIST
46672: LIST
46673: PUSH
46674: LD_INT 1
46676: NEG
46677: PUSH
46678: LD_INT 5
46680: NEG
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 2
46688: PUSH
46689: LD_INT 3
46691: NEG
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: PUSH
46697: LD_INT 2
46699: NEG
46700: PUSH
46701: LD_INT 5
46703: NEG
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 3
46711: PUSH
46712: LD_INT 0
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 1
46724: NEG
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 4
46732: PUSH
46733: LD_INT 0
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 4
46742: PUSH
46743: LD_INT 1
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_INT 3
46752: PUSH
46753: LD_INT 1
46755: PUSH
46756: EMPTY
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 2
46762: PUSH
46763: LD_INT 0
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 2
46772: PUSH
46773: LD_INT 1
46775: NEG
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 2
46783: PUSH
46784: LD_INT 2
46786: NEG
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: LD_INT 4
46794: PUSH
46795: LD_INT 2
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: LD_INT 4
46804: PUSH
46805: LD_INT 4
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 4
46814: PUSH
46815: LD_INT 3
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 5
46824: PUSH
46825: LD_INT 4
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PUSH
46832: LD_INT 5
46834: PUSH
46835: LD_INT 5
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 4
46844: PUSH
46845: LD_INT 5
46847: PUSH
46848: EMPTY
46849: LIST
46850: LIST
46851: PUSH
46852: LD_INT 3
46854: PUSH
46855: LD_INT 4
46857: PUSH
46858: EMPTY
46859: LIST
46860: LIST
46861: PUSH
46862: LD_INT 3
46864: PUSH
46865: LD_INT 3
46867: PUSH
46868: EMPTY
46869: LIST
46870: LIST
46871: PUSH
46872: LD_INT 5
46874: PUSH
46875: LD_INT 3
46877: PUSH
46878: EMPTY
46879: LIST
46880: LIST
46881: PUSH
46882: LD_INT 3
46884: PUSH
46885: LD_INT 5
46887: PUSH
46888: EMPTY
46889: LIST
46890: LIST
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46939: LD_ADDR_VAR 0 33
46943: PUSH
46944: LD_INT 4
46946: NEG
46947: PUSH
46948: LD_INT 4
46950: NEG
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 4
46958: NEG
46959: PUSH
46960: LD_INT 5
46962: NEG
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: LD_INT 3
46970: NEG
46971: PUSH
46972: LD_INT 4
46974: NEG
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: PUSH
46980: LD_INT 3
46982: NEG
46983: PUSH
46984: LD_INT 3
46986: NEG
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 4
46994: NEG
46995: PUSH
46996: LD_INT 3
46998: NEG
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 5
47006: NEG
47007: PUSH
47008: LD_INT 4
47010: NEG
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: LD_INT 5
47018: NEG
47019: PUSH
47020: LD_INT 5
47022: NEG
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PUSH
47028: LD_INT 3
47030: NEG
47031: PUSH
47032: LD_INT 5
47034: NEG
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: PUSH
47040: LD_INT 5
47042: NEG
47043: PUSH
47044: LD_INT 3
47046: NEG
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: PUSH
47052: LD_INT 0
47054: PUSH
47055: LD_INT 3
47057: NEG
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 0
47065: PUSH
47066: LD_INT 4
47068: NEG
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 1
47076: PUSH
47077: LD_INT 3
47079: NEG
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: PUSH
47085: LD_INT 1
47087: PUSH
47088: LD_INT 2
47090: NEG
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: PUSH
47096: LD_INT 0
47098: PUSH
47099: LD_INT 2
47101: NEG
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 1
47109: NEG
47110: PUSH
47111: LD_INT 3
47113: NEG
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: PUSH
47119: LD_INT 1
47121: NEG
47122: PUSH
47123: LD_INT 4
47125: NEG
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: PUSH
47131: LD_INT 2
47133: PUSH
47134: LD_INT 2
47136: NEG
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 2
47144: NEG
47145: PUSH
47146: LD_INT 4
47148: NEG
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PUSH
47154: LD_INT 4
47156: PUSH
47157: LD_INT 0
47159: PUSH
47160: EMPTY
47161: LIST
47162: LIST
47163: PUSH
47164: LD_INT 4
47166: PUSH
47167: LD_INT 1
47169: NEG
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 5
47177: PUSH
47178: LD_INT 0
47180: PUSH
47181: EMPTY
47182: LIST
47183: LIST
47184: PUSH
47185: LD_INT 5
47187: PUSH
47188: LD_INT 1
47190: PUSH
47191: EMPTY
47192: LIST
47193: LIST
47194: PUSH
47195: LD_INT 4
47197: PUSH
47198: LD_INT 1
47200: PUSH
47201: EMPTY
47202: LIST
47203: LIST
47204: PUSH
47205: LD_INT 3
47207: PUSH
47208: LD_INT 0
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: LD_INT 3
47217: PUSH
47218: LD_INT 1
47220: NEG
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: LD_INT 3
47228: PUSH
47229: LD_INT 2
47231: NEG
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: PUSH
47237: LD_INT 5
47239: PUSH
47240: LD_INT 2
47242: PUSH
47243: EMPTY
47244: LIST
47245: LIST
47246: PUSH
47247: LD_INT 3
47249: PUSH
47250: LD_INT 3
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: PUSH
47257: LD_INT 3
47259: PUSH
47260: LD_INT 2
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PUSH
47267: LD_INT 4
47269: PUSH
47270: LD_INT 3
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: LD_INT 4
47279: PUSH
47280: LD_INT 4
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: PUSH
47287: LD_INT 3
47289: PUSH
47290: LD_INT 4
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: LD_INT 2
47299: PUSH
47300: LD_INT 3
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 2
47309: PUSH
47310: LD_INT 2
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 4
47319: PUSH
47320: LD_INT 2
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 2
47329: PUSH
47330: LD_INT 4
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 0
47339: PUSH
47340: LD_INT 4
47342: PUSH
47343: EMPTY
47344: LIST
47345: LIST
47346: PUSH
47347: LD_INT 0
47349: PUSH
47350: LD_INT 3
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 1
47359: PUSH
47360: LD_INT 4
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 1
47369: PUSH
47370: LD_INT 5
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: LD_INT 0
47379: PUSH
47380: LD_INT 5
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: PUSH
47387: LD_INT 1
47389: NEG
47390: PUSH
47391: LD_INT 4
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 1
47400: NEG
47401: PUSH
47402: LD_INT 3
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 2
47411: PUSH
47412: LD_INT 5
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: PUSH
47419: LD_INT 2
47421: NEG
47422: PUSH
47423: LD_INT 3
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47477: LD_ADDR_VAR 0 34
47481: PUSH
47482: LD_INT 0
47484: PUSH
47485: LD_INT 4
47487: NEG
47488: PUSH
47489: EMPTY
47490: LIST
47491: LIST
47492: PUSH
47493: LD_INT 0
47495: PUSH
47496: LD_INT 5
47498: NEG
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 1
47506: PUSH
47507: LD_INT 4
47509: NEG
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PUSH
47515: LD_INT 1
47517: PUSH
47518: LD_INT 3
47520: NEG
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: PUSH
47526: LD_INT 0
47528: PUSH
47529: LD_INT 3
47531: NEG
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PUSH
47537: LD_INT 1
47539: NEG
47540: PUSH
47541: LD_INT 4
47543: NEG
47544: PUSH
47545: EMPTY
47546: LIST
47547: LIST
47548: PUSH
47549: LD_INT 1
47551: NEG
47552: PUSH
47553: LD_INT 5
47555: NEG
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: LD_INT 2
47563: PUSH
47564: LD_INT 3
47566: NEG
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PUSH
47572: LD_INT 2
47574: NEG
47575: PUSH
47576: LD_INT 5
47578: NEG
47579: PUSH
47580: EMPTY
47581: LIST
47582: LIST
47583: PUSH
47584: LD_INT 3
47586: PUSH
47587: LD_INT 0
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: LD_INT 3
47596: PUSH
47597: LD_INT 1
47599: NEG
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: PUSH
47605: LD_INT 4
47607: PUSH
47608: LD_INT 0
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_INT 4
47617: PUSH
47618: LD_INT 1
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: PUSH
47625: LD_INT 3
47627: PUSH
47628: LD_INT 1
47630: PUSH
47631: EMPTY
47632: LIST
47633: LIST
47634: PUSH
47635: LD_INT 2
47637: PUSH
47638: LD_INT 0
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: PUSH
47645: LD_INT 2
47647: PUSH
47648: LD_INT 1
47650: NEG
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: PUSH
47656: LD_INT 2
47658: PUSH
47659: LD_INT 2
47661: NEG
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PUSH
47667: LD_INT 4
47669: PUSH
47670: LD_INT 2
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: LD_INT 4
47679: PUSH
47680: LD_INT 4
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_INT 4
47689: PUSH
47690: LD_INT 3
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: PUSH
47697: LD_INT 5
47699: PUSH
47700: LD_INT 4
47702: PUSH
47703: EMPTY
47704: LIST
47705: LIST
47706: PUSH
47707: LD_INT 5
47709: PUSH
47710: LD_INT 5
47712: PUSH
47713: EMPTY
47714: LIST
47715: LIST
47716: PUSH
47717: LD_INT 4
47719: PUSH
47720: LD_INT 5
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: PUSH
47727: LD_INT 3
47729: PUSH
47730: LD_INT 4
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: LD_INT 3
47739: PUSH
47740: LD_INT 3
47742: PUSH
47743: EMPTY
47744: LIST
47745: LIST
47746: PUSH
47747: LD_INT 5
47749: PUSH
47750: LD_INT 3
47752: PUSH
47753: EMPTY
47754: LIST
47755: LIST
47756: PUSH
47757: LD_INT 3
47759: PUSH
47760: LD_INT 5
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PUSH
47767: LD_INT 0
47769: PUSH
47770: LD_INT 3
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: PUSH
47777: LD_INT 0
47779: PUSH
47780: LD_INT 2
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PUSH
47787: LD_INT 1
47789: PUSH
47790: LD_INT 3
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: LD_INT 1
47799: PUSH
47800: LD_INT 4
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PUSH
47807: LD_INT 0
47809: PUSH
47810: LD_INT 4
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 1
47819: NEG
47820: PUSH
47821: LD_INT 3
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: LD_INT 1
47830: NEG
47831: PUSH
47832: LD_INT 2
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PUSH
47839: LD_INT 2
47841: PUSH
47842: LD_INT 4
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: PUSH
47849: LD_INT 2
47851: NEG
47852: PUSH
47853: LD_INT 2
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: PUSH
47860: LD_INT 4
47862: NEG
47863: PUSH
47864: LD_INT 0
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 4
47873: NEG
47874: PUSH
47875: LD_INT 1
47877: NEG
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: LD_INT 3
47885: NEG
47886: PUSH
47887: LD_INT 0
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 3
47896: NEG
47897: PUSH
47898: LD_INT 1
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: LD_INT 4
47907: NEG
47908: PUSH
47909: LD_INT 1
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_INT 5
47918: NEG
47919: PUSH
47920: LD_INT 0
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_INT 5
47929: NEG
47930: PUSH
47931: LD_INT 1
47933: NEG
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: PUSH
47939: LD_INT 5
47941: NEG
47942: PUSH
47943: LD_INT 2
47945: NEG
47946: PUSH
47947: EMPTY
47948: LIST
47949: LIST
47950: PUSH
47951: LD_INT 3
47953: NEG
47954: PUSH
47955: LD_INT 2
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: ST_TO_ADDR
// end ; end ;
48009: GO 48012
48011: POP
// case btype of b_depot , b_warehouse :
48012: LD_VAR 0 1
48016: PUSH
48017: LD_INT 0
48019: DOUBLE
48020: EQUAL
48021: IFTRUE 48031
48023: LD_INT 1
48025: DOUBLE
48026: EQUAL
48027: IFTRUE 48031
48029: GO 48232
48031: POP
// case nation of nation_american :
48032: LD_VAR 0 5
48036: PUSH
48037: LD_INT 1
48039: DOUBLE
48040: EQUAL
48041: IFTRUE 48045
48043: GO 48101
48045: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48046: LD_ADDR_VAR 0 9
48050: PUSH
48051: LD_VAR 0 11
48055: PUSH
48056: LD_VAR 0 12
48060: PUSH
48061: LD_VAR 0 13
48065: PUSH
48066: LD_VAR 0 14
48070: PUSH
48071: LD_VAR 0 15
48075: PUSH
48076: LD_VAR 0 16
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: LIST
48087: LIST
48088: PUSH
48089: LD_VAR 0 4
48093: PUSH
48094: LD_INT 1
48096: PLUS
48097: ARRAY
48098: ST_TO_ADDR
48099: GO 48230
48101: LD_INT 2
48103: DOUBLE
48104: EQUAL
48105: IFTRUE 48109
48107: GO 48165
48109: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48110: LD_ADDR_VAR 0 9
48114: PUSH
48115: LD_VAR 0 17
48119: PUSH
48120: LD_VAR 0 18
48124: PUSH
48125: LD_VAR 0 19
48129: PUSH
48130: LD_VAR 0 20
48134: PUSH
48135: LD_VAR 0 21
48139: PUSH
48140: LD_VAR 0 22
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: PUSH
48153: LD_VAR 0 4
48157: PUSH
48158: LD_INT 1
48160: PLUS
48161: ARRAY
48162: ST_TO_ADDR
48163: GO 48230
48165: LD_INT 3
48167: DOUBLE
48168: EQUAL
48169: IFTRUE 48173
48171: GO 48229
48173: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48174: LD_ADDR_VAR 0 9
48178: PUSH
48179: LD_VAR 0 23
48183: PUSH
48184: LD_VAR 0 24
48188: PUSH
48189: LD_VAR 0 25
48193: PUSH
48194: LD_VAR 0 26
48198: PUSH
48199: LD_VAR 0 27
48203: PUSH
48204: LD_VAR 0 28
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: PUSH
48217: LD_VAR 0 4
48221: PUSH
48222: LD_INT 1
48224: PLUS
48225: ARRAY
48226: ST_TO_ADDR
48227: GO 48230
48229: POP
48230: GO 48785
48232: LD_INT 2
48234: DOUBLE
48235: EQUAL
48236: IFTRUE 48246
48238: LD_INT 3
48240: DOUBLE
48241: EQUAL
48242: IFTRUE 48246
48244: GO 48302
48246: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48247: LD_ADDR_VAR 0 9
48251: PUSH
48252: LD_VAR 0 29
48256: PUSH
48257: LD_VAR 0 30
48261: PUSH
48262: LD_VAR 0 31
48266: PUSH
48267: LD_VAR 0 32
48271: PUSH
48272: LD_VAR 0 33
48276: PUSH
48277: LD_VAR 0 34
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: PUSH
48290: LD_VAR 0 4
48294: PUSH
48295: LD_INT 1
48297: PLUS
48298: ARRAY
48299: ST_TO_ADDR
48300: GO 48785
48302: LD_INT 16
48304: DOUBLE
48305: EQUAL
48306: IFTRUE 48364
48308: LD_INT 17
48310: DOUBLE
48311: EQUAL
48312: IFTRUE 48364
48314: LD_INT 18
48316: DOUBLE
48317: EQUAL
48318: IFTRUE 48364
48320: LD_INT 19
48322: DOUBLE
48323: EQUAL
48324: IFTRUE 48364
48326: LD_INT 22
48328: DOUBLE
48329: EQUAL
48330: IFTRUE 48364
48332: LD_INT 20
48334: DOUBLE
48335: EQUAL
48336: IFTRUE 48364
48338: LD_INT 21
48340: DOUBLE
48341: EQUAL
48342: IFTRUE 48364
48344: LD_INT 23
48346: DOUBLE
48347: EQUAL
48348: IFTRUE 48364
48350: LD_INT 24
48352: DOUBLE
48353: EQUAL
48354: IFTRUE 48364
48356: LD_INT 25
48358: DOUBLE
48359: EQUAL
48360: IFTRUE 48364
48362: GO 48420
48364: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48365: LD_ADDR_VAR 0 9
48369: PUSH
48370: LD_VAR 0 35
48374: PUSH
48375: LD_VAR 0 36
48379: PUSH
48380: LD_VAR 0 37
48384: PUSH
48385: LD_VAR 0 38
48389: PUSH
48390: LD_VAR 0 39
48394: PUSH
48395: LD_VAR 0 40
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: PUSH
48408: LD_VAR 0 4
48412: PUSH
48413: LD_INT 1
48415: PLUS
48416: ARRAY
48417: ST_TO_ADDR
48418: GO 48785
48420: LD_INT 6
48422: DOUBLE
48423: EQUAL
48424: IFTRUE 48476
48426: LD_INT 7
48428: DOUBLE
48429: EQUAL
48430: IFTRUE 48476
48432: LD_INT 8
48434: DOUBLE
48435: EQUAL
48436: IFTRUE 48476
48438: LD_INT 13
48440: DOUBLE
48441: EQUAL
48442: IFTRUE 48476
48444: LD_INT 12
48446: DOUBLE
48447: EQUAL
48448: IFTRUE 48476
48450: LD_INT 15
48452: DOUBLE
48453: EQUAL
48454: IFTRUE 48476
48456: LD_INT 11
48458: DOUBLE
48459: EQUAL
48460: IFTRUE 48476
48462: LD_INT 14
48464: DOUBLE
48465: EQUAL
48466: IFTRUE 48476
48468: LD_INT 10
48470: DOUBLE
48471: EQUAL
48472: IFTRUE 48476
48474: GO 48532
48476: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48477: LD_ADDR_VAR 0 9
48481: PUSH
48482: LD_VAR 0 41
48486: PUSH
48487: LD_VAR 0 42
48491: PUSH
48492: LD_VAR 0 43
48496: PUSH
48497: LD_VAR 0 44
48501: PUSH
48502: LD_VAR 0 45
48506: PUSH
48507: LD_VAR 0 46
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: LIST
48516: LIST
48517: LIST
48518: LIST
48519: PUSH
48520: LD_VAR 0 4
48524: PUSH
48525: LD_INT 1
48527: PLUS
48528: ARRAY
48529: ST_TO_ADDR
48530: GO 48785
48532: LD_INT 36
48534: DOUBLE
48535: EQUAL
48536: IFTRUE 48540
48538: GO 48596
48540: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48541: LD_ADDR_VAR 0 9
48545: PUSH
48546: LD_VAR 0 47
48550: PUSH
48551: LD_VAR 0 48
48555: PUSH
48556: LD_VAR 0 49
48560: PUSH
48561: LD_VAR 0 50
48565: PUSH
48566: LD_VAR 0 51
48570: PUSH
48571: LD_VAR 0 52
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: LIST
48580: LIST
48581: LIST
48582: LIST
48583: PUSH
48584: LD_VAR 0 4
48588: PUSH
48589: LD_INT 1
48591: PLUS
48592: ARRAY
48593: ST_TO_ADDR
48594: GO 48785
48596: LD_INT 4
48598: DOUBLE
48599: EQUAL
48600: IFTRUE 48622
48602: LD_INT 5
48604: DOUBLE
48605: EQUAL
48606: IFTRUE 48622
48608: LD_INT 34
48610: DOUBLE
48611: EQUAL
48612: IFTRUE 48622
48614: LD_INT 37
48616: DOUBLE
48617: EQUAL
48618: IFTRUE 48622
48620: GO 48678
48622: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
48623: LD_ADDR_VAR 0 9
48627: PUSH
48628: LD_VAR 0 53
48632: PUSH
48633: LD_VAR 0 54
48637: PUSH
48638: LD_VAR 0 55
48642: PUSH
48643: LD_VAR 0 56
48647: PUSH
48648: LD_VAR 0 57
48652: PUSH
48653: LD_VAR 0 58
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: PUSH
48666: LD_VAR 0 4
48670: PUSH
48671: LD_INT 1
48673: PLUS
48674: ARRAY
48675: ST_TO_ADDR
48676: GO 48785
48678: LD_INT 31
48680: DOUBLE
48681: EQUAL
48682: IFTRUE 48728
48684: LD_INT 32
48686: DOUBLE
48687: EQUAL
48688: IFTRUE 48728
48690: LD_INT 33
48692: DOUBLE
48693: EQUAL
48694: IFTRUE 48728
48696: LD_INT 27
48698: DOUBLE
48699: EQUAL
48700: IFTRUE 48728
48702: LD_INT 26
48704: DOUBLE
48705: EQUAL
48706: IFTRUE 48728
48708: LD_INT 28
48710: DOUBLE
48711: EQUAL
48712: IFTRUE 48728
48714: LD_INT 29
48716: DOUBLE
48717: EQUAL
48718: IFTRUE 48728
48720: LD_INT 30
48722: DOUBLE
48723: EQUAL
48724: IFTRUE 48728
48726: GO 48784
48728: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
48729: LD_ADDR_VAR 0 9
48733: PUSH
48734: LD_VAR 0 59
48738: PUSH
48739: LD_VAR 0 60
48743: PUSH
48744: LD_VAR 0 61
48748: PUSH
48749: LD_VAR 0 62
48753: PUSH
48754: LD_VAR 0 63
48758: PUSH
48759: LD_VAR 0 64
48763: PUSH
48764: EMPTY
48765: LIST
48766: LIST
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: PUSH
48772: LD_VAR 0 4
48776: PUSH
48777: LD_INT 1
48779: PLUS
48780: ARRAY
48781: ST_TO_ADDR
48782: GO 48785
48784: POP
// temp_list2 = [ ] ;
48785: LD_ADDR_VAR 0 10
48789: PUSH
48790: EMPTY
48791: ST_TO_ADDR
// for i in temp_list do
48792: LD_ADDR_VAR 0 8
48796: PUSH
48797: LD_VAR 0 9
48801: PUSH
48802: FOR_IN
48803: IFFALSE 48855
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48805: LD_ADDR_VAR 0 10
48809: PUSH
48810: LD_VAR 0 10
48814: PUSH
48815: LD_VAR 0 8
48819: PUSH
48820: LD_INT 1
48822: ARRAY
48823: PUSH
48824: LD_VAR 0 2
48828: PLUS
48829: PUSH
48830: LD_VAR 0 8
48834: PUSH
48835: LD_INT 2
48837: ARRAY
48838: PUSH
48839: LD_VAR 0 3
48843: PLUS
48844: PUSH
48845: EMPTY
48846: LIST
48847: LIST
48848: PUSH
48849: EMPTY
48850: LIST
48851: ADD
48852: ST_TO_ADDR
48853: GO 48802
48855: POP
48856: POP
// result = temp_list2 ;
48857: LD_ADDR_VAR 0 7
48861: PUSH
48862: LD_VAR 0 10
48866: ST_TO_ADDR
// end ;
48867: LD_VAR 0 7
48871: RET
// export function EnemyInRange ( unit , dist ) ; begin
48872: LD_INT 0
48874: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48875: LD_ADDR_VAR 0 3
48879: PUSH
48880: LD_VAR 0 1
48884: PPUSH
48885: CALL_OW 255
48889: PPUSH
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 250
48899: PPUSH
48900: LD_VAR 0 1
48904: PPUSH
48905: CALL_OW 251
48909: PPUSH
48910: LD_VAR 0 2
48914: PPUSH
48915: CALL 22245 0 4
48919: PUSH
48920: LD_INT 4
48922: ARRAY
48923: ST_TO_ADDR
// end ;
48924: LD_VAR 0 3
48928: RET
// export function PlayerSeeMe ( unit ) ; begin
48929: LD_INT 0
48931: PPUSH
// result := See ( your_side , unit ) ;
48932: LD_ADDR_VAR 0 2
48936: PUSH
48937: LD_OWVAR 2
48941: PPUSH
48942: LD_VAR 0 1
48946: PPUSH
48947: CALL_OW 292
48951: ST_TO_ADDR
// end ;
48952: LD_VAR 0 2
48956: RET
// export function ReverseDir ( unit ) ; begin
48957: LD_INT 0
48959: PPUSH
// if not unit then
48960: LD_VAR 0 1
48964: NOT
48965: IFFALSE 48969
// exit ;
48967: GO 48992
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48969: LD_ADDR_VAR 0 2
48973: PUSH
48974: LD_VAR 0 1
48978: PPUSH
48979: CALL_OW 254
48983: PUSH
48984: LD_INT 3
48986: PLUS
48987: PUSH
48988: LD_INT 6
48990: MOD
48991: ST_TO_ADDR
// end ;
48992: LD_VAR 0 2
48996: RET
// export function ReverseArray ( array ) ; var i ; begin
48997: LD_INT 0
48999: PPUSH
49000: PPUSH
// if not array then
49001: LD_VAR 0 1
49005: NOT
49006: IFFALSE 49010
// exit ;
49008: GO 49065
// result := [ ] ;
49010: LD_ADDR_VAR 0 2
49014: PUSH
49015: EMPTY
49016: ST_TO_ADDR
// for i := array downto 1 do
49017: LD_ADDR_VAR 0 3
49021: PUSH
49022: DOUBLE
49023: LD_VAR 0 1
49027: INC
49028: ST_TO_ADDR
49029: LD_INT 1
49031: PUSH
49032: FOR_DOWNTO
49033: IFFALSE 49063
// result := Join ( result , array [ i ] ) ;
49035: LD_ADDR_VAR 0 2
49039: PUSH
49040: LD_VAR 0 2
49044: PPUSH
49045: LD_VAR 0 1
49049: PUSH
49050: LD_VAR 0 3
49054: ARRAY
49055: PPUSH
49056: CALL 53721 0 2
49060: ST_TO_ADDR
49061: GO 49032
49063: POP
49064: POP
// end ;
49065: LD_VAR 0 2
49069: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
49070: LD_INT 0
49072: PPUSH
49073: PPUSH
49074: PPUSH
49075: PPUSH
49076: PPUSH
49077: PPUSH
// if not unit or not hexes then
49078: LD_VAR 0 1
49082: NOT
49083: PUSH
49084: LD_VAR 0 2
49088: NOT
49089: OR
49090: IFFALSE 49094
// exit ;
49092: GO 49217
// dist := 9999 ;
49094: LD_ADDR_VAR 0 5
49098: PUSH
49099: LD_INT 9999
49101: ST_TO_ADDR
// for i = 1 to hexes do
49102: LD_ADDR_VAR 0 4
49106: PUSH
49107: DOUBLE
49108: LD_INT 1
49110: DEC
49111: ST_TO_ADDR
49112: LD_VAR 0 2
49116: PUSH
49117: FOR_TO
49118: IFFALSE 49205
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49120: LD_ADDR_VAR 0 6
49124: PUSH
49125: LD_VAR 0 1
49129: PPUSH
49130: LD_VAR 0 2
49134: PUSH
49135: LD_VAR 0 4
49139: ARRAY
49140: PUSH
49141: LD_INT 1
49143: ARRAY
49144: PPUSH
49145: LD_VAR 0 2
49149: PUSH
49150: LD_VAR 0 4
49154: ARRAY
49155: PUSH
49156: LD_INT 2
49158: ARRAY
49159: PPUSH
49160: CALL_OW 297
49164: ST_TO_ADDR
// if tdist < dist then
49165: LD_VAR 0 6
49169: PUSH
49170: LD_VAR 0 5
49174: LESS
49175: IFFALSE 49203
// begin hex := hexes [ i ] ;
49177: LD_ADDR_VAR 0 8
49181: PUSH
49182: LD_VAR 0 2
49186: PUSH
49187: LD_VAR 0 4
49191: ARRAY
49192: ST_TO_ADDR
// dist := tdist ;
49193: LD_ADDR_VAR 0 5
49197: PUSH
49198: LD_VAR 0 6
49202: ST_TO_ADDR
// end ; end ;
49203: GO 49117
49205: POP
49206: POP
// result := hex ;
49207: LD_ADDR_VAR 0 3
49211: PUSH
49212: LD_VAR 0 8
49216: ST_TO_ADDR
// end ;
49217: LD_VAR 0 3
49221: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49222: LD_INT 0
49224: PPUSH
49225: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49226: LD_VAR 0 1
49230: NOT
49231: PUSH
49232: LD_VAR 0 1
49236: PUSH
49237: LD_INT 21
49239: PUSH
49240: LD_INT 2
49242: PUSH
49243: EMPTY
49244: LIST
49245: LIST
49246: PUSH
49247: LD_INT 23
49249: PUSH
49250: LD_INT 2
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: EMPTY
49258: LIST
49259: LIST
49260: PPUSH
49261: CALL_OW 69
49265: IN
49266: NOT
49267: OR
49268: IFFALSE 49272
// exit ;
49270: GO 49319
// for i = 1 to 3 do
49272: LD_ADDR_VAR 0 3
49276: PUSH
49277: DOUBLE
49278: LD_INT 1
49280: DEC
49281: ST_TO_ADDR
49282: LD_INT 3
49284: PUSH
49285: FOR_TO
49286: IFFALSE 49317
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49288: LD_VAR 0 1
49292: PPUSH
49293: CALL_OW 250
49297: PPUSH
49298: LD_VAR 0 1
49302: PPUSH
49303: CALL_OW 251
49307: PPUSH
49308: LD_INT 1
49310: PPUSH
49311: CALL_OW 453
49315: GO 49285
49317: POP
49318: POP
// end ;
49319: LD_VAR 0 2
49323: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49324: LD_INT 0
49326: PPUSH
49327: PPUSH
49328: PPUSH
49329: PPUSH
49330: PPUSH
49331: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
49332: LD_VAR 0 1
49336: NOT
49337: PUSH
49338: LD_VAR 0 2
49342: NOT
49343: OR
49344: PUSH
49345: LD_VAR 0 1
49349: PPUSH
49350: CALL_OW 314
49354: OR
49355: IFFALSE 49359
// exit ;
49357: GO 49826
// if GetLives ( i ) < 250 then
49359: LD_VAR 0 4
49363: PPUSH
49364: CALL_OW 256
49368: PUSH
49369: LD_INT 250
49371: LESS
49372: IFFALSE 49385
// begin ComAutodestruct ( i ) ;
49374: LD_VAR 0 4
49378: PPUSH
49379: CALL 49222 0 1
// exit ;
49383: GO 49826
// end ; x := GetX ( enemy_unit ) ;
49385: LD_ADDR_VAR 0 7
49389: PUSH
49390: LD_VAR 0 2
49394: PPUSH
49395: CALL_OW 250
49399: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49400: LD_ADDR_VAR 0 8
49404: PUSH
49405: LD_VAR 0 2
49409: PPUSH
49410: CALL_OW 251
49414: ST_TO_ADDR
// if not x or not y then
49415: LD_VAR 0 7
49419: NOT
49420: PUSH
49421: LD_VAR 0 8
49425: NOT
49426: OR
49427: IFFALSE 49431
// exit ;
49429: GO 49826
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49431: LD_ADDR_VAR 0 6
49435: PUSH
49436: LD_VAR 0 7
49440: PPUSH
49441: LD_INT 0
49443: PPUSH
49444: LD_INT 4
49446: PPUSH
49447: CALL_OW 272
49451: PUSH
49452: LD_VAR 0 8
49456: PPUSH
49457: LD_INT 0
49459: PPUSH
49460: LD_INT 4
49462: PPUSH
49463: CALL_OW 273
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PUSH
49472: LD_VAR 0 7
49476: PPUSH
49477: LD_INT 1
49479: PPUSH
49480: LD_INT 4
49482: PPUSH
49483: CALL_OW 272
49487: PUSH
49488: LD_VAR 0 8
49492: PPUSH
49493: LD_INT 1
49495: PPUSH
49496: LD_INT 4
49498: PPUSH
49499: CALL_OW 273
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PUSH
49508: LD_VAR 0 7
49512: PPUSH
49513: LD_INT 2
49515: PPUSH
49516: LD_INT 4
49518: PPUSH
49519: CALL_OW 272
49523: PUSH
49524: LD_VAR 0 8
49528: PPUSH
49529: LD_INT 2
49531: PPUSH
49532: LD_INT 4
49534: PPUSH
49535: CALL_OW 273
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PUSH
49544: LD_VAR 0 7
49548: PPUSH
49549: LD_INT 3
49551: PPUSH
49552: LD_INT 4
49554: PPUSH
49555: CALL_OW 272
49559: PUSH
49560: LD_VAR 0 8
49564: PPUSH
49565: LD_INT 3
49567: PPUSH
49568: LD_INT 4
49570: PPUSH
49571: CALL_OW 273
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_VAR 0 7
49584: PPUSH
49585: LD_INT 4
49587: PPUSH
49588: LD_INT 4
49590: PPUSH
49591: CALL_OW 272
49595: PUSH
49596: LD_VAR 0 8
49600: PPUSH
49601: LD_INT 4
49603: PPUSH
49604: LD_INT 4
49606: PPUSH
49607: CALL_OW 273
49611: PUSH
49612: EMPTY
49613: LIST
49614: LIST
49615: PUSH
49616: LD_VAR 0 7
49620: PPUSH
49621: LD_INT 5
49623: PPUSH
49624: LD_INT 4
49626: PPUSH
49627: CALL_OW 272
49631: PUSH
49632: LD_VAR 0 8
49636: PPUSH
49637: LD_INT 5
49639: PPUSH
49640: LD_INT 4
49642: PPUSH
49643: CALL_OW 273
49647: PUSH
49648: EMPTY
49649: LIST
49650: LIST
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: ST_TO_ADDR
// for i = tmp downto 1 do
49660: LD_ADDR_VAR 0 4
49664: PUSH
49665: DOUBLE
49666: LD_VAR 0 6
49670: INC
49671: ST_TO_ADDR
49672: LD_INT 1
49674: PUSH
49675: FOR_DOWNTO
49676: IFFALSE 49777
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49678: LD_VAR 0 6
49682: PUSH
49683: LD_VAR 0 4
49687: ARRAY
49688: PUSH
49689: LD_INT 1
49691: ARRAY
49692: PPUSH
49693: LD_VAR 0 6
49697: PUSH
49698: LD_VAR 0 4
49702: ARRAY
49703: PUSH
49704: LD_INT 2
49706: ARRAY
49707: PPUSH
49708: CALL_OW 488
49712: NOT
49713: PUSH
49714: LD_VAR 0 6
49718: PUSH
49719: LD_VAR 0 4
49723: ARRAY
49724: PUSH
49725: LD_INT 1
49727: ARRAY
49728: PPUSH
49729: LD_VAR 0 6
49733: PUSH
49734: LD_VAR 0 4
49738: ARRAY
49739: PUSH
49740: LD_INT 2
49742: ARRAY
49743: PPUSH
49744: CALL_OW 428
49748: PUSH
49749: LD_INT 0
49751: NONEQUAL
49752: OR
49753: IFFALSE 49775
// tmp := Delete ( tmp , i ) ;
49755: LD_ADDR_VAR 0 6
49759: PUSH
49760: LD_VAR 0 6
49764: PPUSH
49765: LD_VAR 0 4
49769: PPUSH
49770: CALL_OW 3
49774: ST_TO_ADDR
49775: GO 49675
49777: POP
49778: POP
// j := GetClosestHex ( unit , tmp ) ;
49779: LD_ADDR_VAR 0 5
49783: PUSH
49784: LD_VAR 0 1
49788: PPUSH
49789: LD_VAR 0 6
49793: PPUSH
49794: CALL 49070 0 2
49798: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
49799: LD_VAR 0 1
49803: PPUSH
49804: LD_VAR 0 5
49808: PUSH
49809: LD_INT 1
49811: ARRAY
49812: PPUSH
49813: LD_VAR 0 5
49817: PUSH
49818: LD_INT 2
49820: ARRAY
49821: PPUSH
49822: CALL_OW 111
// end ;
49826: LD_VAR 0 3
49830: RET
// export function PrepareApemanSoldier ( ) ; begin
49831: LD_INT 0
49833: PPUSH
// uc_nation := 0 ;
49834: LD_ADDR_OWVAR 21
49838: PUSH
49839: LD_INT 0
49841: ST_TO_ADDR
// hc_sex := sex_male ;
49842: LD_ADDR_OWVAR 27
49846: PUSH
49847: LD_INT 1
49849: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
49850: LD_ADDR_OWVAR 28
49854: PUSH
49855: LD_INT 15
49857: ST_TO_ADDR
// hc_gallery :=  ;
49858: LD_ADDR_OWVAR 33
49862: PUSH
49863: LD_STRING 
49865: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49866: LD_ADDR_OWVAR 31
49870: PUSH
49871: LD_INT 0
49873: PPUSH
49874: LD_INT 3
49876: PPUSH
49877: CALL_OW 12
49881: PUSH
49882: LD_INT 0
49884: PPUSH
49885: LD_INT 3
49887: PPUSH
49888: CALL_OW 12
49892: PUSH
49893: LD_INT 0
49895: PUSH
49896: LD_INT 0
49898: PUSH
49899: EMPTY
49900: LIST
49901: LIST
49902: LIST
49903: LIST
49904: ST_TO_ADDR
// end ;
49905: LD_VAR 0 1
49909: RET
// export function PrepareApemanEngineer ( ) ; begin
49910: LD_INT 0
49912: PPUSH
// uc_nation := 0 ;
49913: LD_ADDR_OWVAR 21
49917: PUSH
49918: LD_INT 0
49920: ST_TO_ADDR
// hc_sex := sex_male ;
49921: LD_ADDR_OWVAR 27
49925: PUSH
49926: LD_INT 1
49928: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
49929: LD_ADDR_OWVAR 28
49933: PUSH
49934: LD_INT 16
49936: ST_TO_ADDR
// hc_gallery :=  ;
49937: LD_ADDR_OWVAR 33
49941: PUSH
49942: LD_STRING 
49944: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49945: LD_ADDR_OWVAR 31
49949: PUSH
49950: LD_INT 0
49952: PPUSH
49953: LD_INT 3
49955: PPUSH
49956: CALL_OW 12
49960: PUSH
49961: LD_INT 0
49963: PPUSH
49964: LD_INT 3
49966: PPUSH
49967: CALL_OW 12
49971: PUSH
49972: LD_INT 0
49974: PUSH
49975: LD_INT 0
49977: PUSH
49978: EMPTY
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: ST_TO_ADDR
// end ;
49984: LD_VAR 0 1
49988: RET
// export function PrepareApeman ( agressivity ) ; begin
49989: LD_INT 0
49991: PPUSH
// uc_side := 0 ;
49992: LD_ADDR_OWVAR 20
49996: PUSH
49997: LD_INT 0
49999: ST_TO_ADDR
// uc_nation := 0 ;
50000: LD_ADDR_OWVAR 21
50004: PUSH
50005: LD_INT 0
50007: ST_TO_ADDR
// hc_sex := sex_male ;
50008: LD_ADDR_OWVAR 27
50012: PUSH
50013: LD_INT 1
50015: ST_TO_ADDR
// hc_class := class_apeman ;
50016: LD_ADDR_OWVAR 28
50020: PUSH
50021: LD_INT 12
50023: ST_TO_ADDR
// hc_gallery :=  ;
50024: LD_ADDR_OWVAR 33
50028: PUSH
50029: LD_STRING 
50031: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50032: LD_ADDR_OWVAR 35
50036: PUSH
50037: LD_VAR 0 1
50041: NEG
50042: PPUSH
50043: LD_VAR 0 1
50047: PPUSH
50048: CALL_OW 12
50052: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
50053: LD_ADDR_OWVAR 31
50057: PUSH
50058: LD_INT 0
50060: PPUSH
50061: LD_INT 3
50063: PPUSH
50064: CALL_OW 12
50068: PUSH
50069: LD_INT 0
50071: PPUSH
50072: LD_INT 3
50074: PPUSH
50075: CALL_OW 12
50079: PUSH
50080: LD_INT 0
50082: PUSH
50083: LD_INT 0
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: LIST
50090: LIST
50091: ST_TO_ADDR
// end ;
50092: LD_VAR 0 2
50096: RET
// export function PrepareTiger ( agressivity ) ; begin
50097: LD_INT 0
50099: PPUSH
// uc_side := 0 ;
50100: LD_ADDR_OWVAR 20
50104: PUSH
50105: LD_INT 0
50107: ST_TO_ADDR
// uc_nation := 0 ;
50108: LD_ADDR_OWVAR 21
50112: PUSH
50113: LD_INT 0
50115: ST_TO_ADDR
// hc_class := class_tiger ;
50116: LD_ADDR_OWVAR 28
50120: PUSH
50121: LD_INT 14
50123: ST_TO_ADDR
// hc_gallery :=  ;
50124: LD_ADDR_OWVAR 33
50128: PUSH
50129: LD_STRING 
50131: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
50132: LD_ADDR_OWVAR 35
50136: PUSH
50137: LD_VAR 0 1
50141: NEG
50142: PPUSH
50143: LD_VAR 0 1
50147: PPUSH
50148: CALL_OW 12
50152: ST_TO_ADDR
// end ;
50153: LD_VAR 0 2
50157: RET
// export function PrepareEnchidna ( ) ; begin
50158: LD_INT 0
50160: PPUSH
// uc_side := 0 ;
50161: LD_ADDR_OWVAR 20
50165: PUSH
50166: LD_INT 0
50168: ST_TO_ADDR
// uc_nation := 0 ;
50169: LD_ADDR_OWVAR 21
50173: PUSH
50174: LD_INT 0
50176: ST_TO_ADDR
// hc_class := class_baggie ;
50177: LD_ADDR_OWVAR 28
50181: PUSH
50182: LD_INT 13
50184: ST_TO_ADDR
// hc_gallery :=  ;
50185: LD_ADDR_OWVAR 33
50189: PUSH
50190: LD_STRING 
50192: ST_TO_ADDR
// end ;
50193: LD_VAR 0 1
50197: RET
// export function PrepareFrog ( ) ; begin
50198: LD_INT 0
50200: PPUSH
// uc_side := 0 ;
50201: LD_ADDR_OWVAR 20
50205: PUSH
50206: LD_INT 0
50208: ST_TO_ADDR
// uc_nation := 0 ;
50209: LD_ADDR_OWVAR 21
50213: PUSH
50214: LD_INT 0
50216: ST_TO_ADDR
// hc_class := class_frog ;
50217: LD_ADDR_OWVAR 28
50221: PUSH
50222: LD_INT 19
50224: ST_TO_ADDR
// hc_gallery :=  ;
50225: LD_ADDR_OWVAR 33
50229: PUSH
50230: LD_STRING 
50232: ST_TO_ADDR
// end ;
50233: LD_VAR 0 1
50237: RET
// export function PrepareFish ( ) ; begin
50238: LD_INT 0
50240: PPUSH
// uc_side := 0 ;
50241: LD_ADDR_OWVAR 20
50245: PUSH
50246: LD_INT 0
50248: ST_TO_ADDR
// uc_nation := 0 ;
50249: LD_ADDR_OWVAR 21
50253: PUSH
50254: LD_INT 0
50256: ST_TO_ADDR
// hc_class := class_fish ;
50257: LD_ADDR_OWVAR 28
50261: PUSH
50262: LD_INT 20
50264: ST_TO_ADDR
// hc_gallery :=  ;
50265: LD_ADDR_OWVAR 33
50269: PUSH
50270: LD_STRING 
50272: ST_TO_ADDR
// end ;
50273: LD_VAR 0 1
50277: RET
// export function PrepareBird ( ) ; begin
50278: LD_INT 0
50280: PPUSH
// uc_side := 0 ;
50281: LD_ADDR_OWVAR 20
50285: PUSH
50286: LD_INT 0
50288: ST_TO_ADDR
// uc_nation := 0 ;
50289: LD_ADDR_OWVAR 21
50293: PUSH
50294: LD_INT 0
50296: ST_TO_ADDR
// hc_class := class_phororhacos ;
50297: LD_ADDR_OWVAR 28
50301: PUSH
50302: LD_INT 18
50304: ST_TO_ADDR
// hc_gallery :=  ;
50305: LD_ADDR_OWVAR 33
50309: PUSH
50310: LD_STRING 
50312: ST_TO_ADDR
// end ;
50313: LD_VAR 0 1
50317: RET
// export function PrepareHorse ( ) ; begin
50318: LD_INT 0
50320: PPUSH
// uc_side := 0 ;
50321: LD_ADDR_OWVAR 20
50325: PUSH
50326: LD_INT 0
50328: ST_TO_ADDR
// uc_nation := 0 ;
50329: LD_ADDR_OWVAR 21
50333: PUSH
50334: LD_INT 0
50336: ST_TO_ADDR
// hc_class := class_horse ;
50337: LD_ADDR_OWVAR 28
50341: PUSH
50342: LD_INT 21
50344: ST_TO_ADDR
// hc_gallery :=  ;
50345: LD_ADDR_OWVAR 33
50349: PUSH
50350: LD_STRING 
50352: ST_TO_ADDR
// end ;
50353: LD_VAR 0 1
50357: RET
// export function PrepareMastodont ( ) ; begin
50358: LD_INT 0
50360: PPUSH
// uc_side := 0 ;
50361: LD_ADDR_OWVAR 20
50365: PUSH
50366: LD_INT 0
50368: ST_TO_ADDR
// uc_nation := 0 ;
50369: LD_ADDR_OWVAR 21
50373: PUSH
50374: LD_INT 0
50376: ST_TO_ADDR
// vc_chassis := class_mastodont ;
50377: LD_ADDR_OWVAR 37
50381: PUSH
50382: LD_INT 31
50384: ST_TO_ADDR
// vc_control := control_rider ;
50385: LD_ADDR_OWVAR 38
50389: PUSH
50390: LD_INT 4
50392: ST_TO_ADDR
// end ;
50393: LD_VAR 0 1
50397: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50398: LD_INT 0
50400: PPUSH
50401: PPUSH
50402: PPUSH
// uc_side = 0 ;
50403: LD_ADDR_OWVAR 20
50407: PUSH
50408: LD_INT 0
50410: ST_TO_ADDR
// uc_nation = 0 ;
50411: LD_ADDR_OWVAR 21
50415: PUSH
50416: LD_INT 0
50418: ST_TO_ADDR
// InitHc_All ( ) ;
50419: CALL_OW 584
// InitVc ;
50423: CALL_OW 20
// if mastodonts then
50427: LD_VAR 0 6
50431: IFFALSE 50498
// for i = 1 to mastodonts do
50433: LD_ADDR_VAR 0 11
50437: PUSH
50438: DOUBLE
50439: LD_INT 1
50441: DEC
50442: ST_TO_ADDR
50443: LD_VAR 0 6
50447: PUSH
50448: FOR_TO
50449: IFFALSE 50496
// begin vc_chassis := 31 ;
50451: LD_ADDR_OWVAR 37
50455: PUSH
50456: LD_INT 31
50458: ST_TO_ADDR
// vc_control := control_rider ;
50459: LD_ADDR_OWVAR 38
50463: PUSH
50464: LD_INT 4
50466: ST_TO_ADDR
// animal := CreateVehicle ;
50467: LD_ADDR_VAR 0 12
50471: PUSH
50472: CALL_OW 45
50476: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50477: LD_VAR 0 12
50481: PPUSH
50482: LD_VAR 0 8
50486: PPUSH
50487: LD_INT 0
50489: PPUSH
50490: CALL 52626 0 3
// end ;
50494: GO 50448
50496: POP
50497: POP
// if horses then
50498: LD_VAR 0 5
50502: IFFALSE 50569
// for i = 1 to horses do
50504: LD_ADDR_VAR 0 11
50508: PUSH
50509: DOUBLE
50510: LD_INT 1
50512: DEC
50513: ST_TO_ADDR
50514: LD_VAR 0 5
50518: PUSH
50519: FOR_TO
50520: IFFALSE 50567
// begin hc_class := 21 ;
50522: LD_ADDR_OWVAR 28
50526: PUSH
50527: LD_INT 21
50529: ST_TO_ADDR
// hc_gallery :=  ;
50530: LD_ADDR_OWVAR 33
50534: PUSH
50535: LD_STRING 
50537: ST_TO_ADDR
// animal := CreateHuman ;
50538: LD_ADDR_VAR 0 12
50542: PUSH
50543: CALL_OW 44
50547: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50548: LD_VAR 0 12
50552: PPUSH
50553: LD_VAR 0 8
50557: PPUSH
50558: LD_INT 0
50560: PPUSH
50561: CALL 52626 0 3
// end ;
50565: GO 50519
50567: POP
50568: POP
// if birds then
50569: LD_VAR 0 1
50573: IFFALSE 50640
// for i = 1 to birds do
50575: LD_ADDR_VAR 0 11
50579: PUSH
50580: DOUBLE
50581: LD_INT 1
50583: DEC
50584: ST_TO_ADDR
50585: LD_VAR 0 1
50589: PUSH
50590: FOR_TO
50591: IFFALSE 50638
// begin hc_class := 18 ;
50593: LD_ADDR_OWVAR 28
50597: PUSH
50598: LD_INT 18
50600: ST_TO_ADDR
// hc_gallery =  ;
50601: LD_ADDR_OWVAR 33
50605: PUSH
50606: LD_STRING 
50608: ST_TO_ADDR
// animal := CreateHuman ;
50609: LD_ADDR_VAR 0 12
50613: PUSH
50614: CALL_OW 44
50618: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50619: LD_VAR 0 12
50623: PPUSH
50624: LD_VAR 0 8
50628: PPUSH
50629: LD_INT 0
50631: PPUSH
50632: CALL 52626 0 3
// end ;
50636: GO 50590
50638: POP
50639: POP
// if tigers then
50640: LD_VAR 0 2
50644: IFFALSE 50728
// for i = 1 to tigers do
50646: LD_ADDR_VAR 0 11
50650: PUSH
50651: DOUBLE
50652: LD_INT 1
50654: DEC
50655: ST_TO_ADDR
50656: LD_VAR 0 2
50660: PUSH
50661: FOR_TO
50662: IFFALSE 50726
// begin hc_class = class_tiger ;
50664: LD_ADDR_OWVAR 28
50668: PUSH
50669: LD_INT 14
50671: ST_TO_ADDR
// hc_gallery =  ;
50672: LD_ADDR_OWVAR 33
50676: PUSH
50677: LD_STRING 
50679: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
50680: LD_ADDR_OWVAR 35
50684: PUSH
50685: LD_INT 7
50687: NEG
50688: PPUSH
50689: LD_INT 7
50691: PPUSH
50692: CALL_OW 12
50696: ST_TO_ADDR
// animal := CreateHuman ;
50697: LD_ADDR_VAR 0 12
50701: PUSH
50702: CALL_OW 44
50706: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50707: LD_VAR 0 12
50711: PPUSH
50712: LD_VAR 0 8
50716: PPUSH
50717: LD_INT 0
50719: PPUSH
50720: CALL 52626 0 3
// end ;
50724: GO 50661
50726: POP
50727: POP
// if apemans then
50728: LD_VAR 0 3
50732: IFFALSE 50855
// for i = 1 to apemans do
50734: LD_ADDR_VAR 0 11
50738: PUSH
50739: DOUBLE
50740: LD_INT 1
50742: DEC
50743: ST_TO_ADDR
50744: LD_VAR 0 3
50748: PUSH
50749: FOR_TO
50750: IFFALSE 50853
// begin hc_class = class_apeman ;
50752: LD_ADDR_OWVAR 28
50756: PUSH
50757: LD_INT 12
50759: ST_TO_ADDR
// hc_gallery =  ;
50760: LD_ADDR_OWVAR 33
50764: PUSH
50765: LD_STRING 
50767: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
50768: LD_ADDR_OWVAR 35
50772: PUSH
50773: LD_INT 2
50775: NEG
50776: PPUSH
50777: LD_INT 2
50779: PPUSH
50780: CALL_OW 12
50784: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
50785: LD_ADDR_OWVAR 31
50789: PUSH
50790: LD_INT 1
50792: PPUSH
50793: LD_INT 3
50795: PPUSH
50796: CALL_OW 12
50800: PUSH
50801: LD_INT 1
50803: PPUSH
50804: LD_INT 3
50806: PPUSH
50807: CALL_OW 12
50811: PUSH
50812: LD_INT 0
50814: PUSH
50815: LD_INT 0
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: ST_TO_ADDR
// animal := CreateHuman ;
50824: LD_ADDR_VAR 0 12
50828: PUSH
50829: CALL_OW 44
50833: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50834: LD_VAR 0 12
50838: PPUSH
50839: LD_VAR 0 8
50843: PPUSH
50844: LD_INT 0
50846: PPUSH
50847: CALL 52626 0 3
// end ;
50851: GO 50749
50853: POP
50854: POP
// if enchidnas then
50855: LD_VAR 0 4
50859: IFFALSE 50926
// for i = 1 to enchidnas do
50861: LD_ADDR_VAR 0 11
50865: PUSH
50866: DOUBLE
50867: LD_INT 1
50869: DEC
50870: ST_TO_ADDR
50871: LD_VAR 0 4
50875: PUSH
50876: FOR_TO
50877: IFFALSE 50924
// begin hc_class = 13 ;
50879: LD_ADDR_OWVAR 28
50883: PUSH
50884: LD_INT 13
50886: ST_TO_ADDR
// hc_gallery =  ;
50887: LD_ADDR_OWVAR 33
50891: PUSH
50892: LD_STRING 
50894: ST_TO_ADDR
// animal := CreateHuman ;
50895: LD_ADDR_VAR 0 12
50899: PUSH
50900: CALL_OW 44
50904: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50905: LD_VAR 0 12
50909: PPUSH
50910: LD_VAR 0 8
50914: PPUSH
50915: LD_INT 0
50917: PPUSH
50918: CALL 52626 0 3
// end ;
50922: GO 50876
50924: POP
50925: POP
// if fishes then
50926: LD_VAR 0 7
50930: IFFALSE 50997
// for i = 1 to fishes do
50932: LD_ADDR_VAR 0 11
50936: PUSH
50937: DOUBLE
50938: LD_INT 1
50940: DEC
50941: ST_TO_ADDR
50942: LD_VAR 0 7
50946: PUSH
50947: FOR_TO
50948: IFFALSE 50995
// begin hc_class = 20 ;
50950: LD_ADDR_OWVAR 28
50954: PUSH
50955: LD_INT 20
50957: ST_TO_ADDR
// hc_gallery =  ;
50958: LD_ADDR_OWVAR 33
50962: PUSH
50963: LD_STRING 
50965: ST_TO_ADDR
// animal := CreateHuman ;
50966: LD_ADDR_VAR 0 12
50970: PUSH
50971: CALL_OW 44
50975: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50976: LD_VAR 0 12
50980: PPUSH
50981: LD_VAR 0 9
50985: PPUSH
50986: LD_INT 0
50988: PPUSH
50989: CALL 52626 0 3
// end ;
50993: GO 50947
50995: POP
50996: POP
// end ;
50997: LD_VAR 0 10
51001: RET
// export function WantHeal ( sci , unit ) ; begin
51002: LD_INT 0
51004: PPUSH
// if GetTaskList ( sci ) > 0 then
51005: LD_VAR 0 1
51009: PPUSH
51010: CALL_OW 437
51014: PUSH
51015: LD_INT 0
51017: GREATER
51018: IFFALSE 51088
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51020: LD_VAR 0 1
51024: PPUSH
51025: CALL_OW 437
51029: PUSH
51030: LD_INT 1
51032: ARRAY
51033: PUSH
51034: LD_INT 1
51036: ARRAY
51037: PUSH
51038: LD_STRING l
51040: EQUAL
51041: PUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL_OW 437
51051: PUSH
51052: LD_INT 1
51054: ARRAY
51055: PUSH
51056: LD_INT 4
51058: ARRAY
51059: PUSH
51060: LD_VAR 0 2
51064: EQUAL
51065: AND
51066: IFFALSE 51078
// result := true else
51068: LD_ADDR_VAR 0 3
51072: PUSH
51073: LD_INT 1
51075: ST_TO_ADDR
51076: GO 51086
// result := false ;
51078: LD_ADDR_VAR 0 3
51082: PUSH
51083: LD_INT 0
51085: ST_TO_ADDR
// end else
51086: GO 51096
// result := false ;
51088: LD_ADDR_VAR 0 3
51092: PUSH
51093: LD_INT 0
51095: ST_TO_ADDR
// end ;
51096: LD_VAR 0 3
51100: RET
// export function HealTarget ( sci ) ; begin
51101: LD_INT 0
51103: PPUSH
// if not sci then
51104: LD_VAR 0 1
51108: NOT
51109: IFFALSE 51113
// exit ;
51111: GO 51178
// result := 0 ;
51113: LD_ADDR_VAR 0 2
51117: PUSH
51118: LD_INT 0
51120: ST_TO_ADDR
// if GetTaskList ( sci ) then
51121: LD_VAR 0 1
51125: PPUSH
51126: CALL_OW 437
51130: IFFALSE 51178
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51132: LD_VAR 0 1
51136: PPUSH
51137: CALL_OW 437
51141: PUSH
51142: LD_INT 1
51144: ARRAY
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PUSH
51150: LD_STRING l
51152: EQUAL
51153: IFFALSE 51178
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51155: LD_ADDR_VAR 0 2
51159: PUSH
51160: LD_VAR 0 1
51164: PPUSH
51165: CALL_OW 437
51169: PUSH
51170: LD_INT 1
51172: ARRAY
51173: PUSH
51174: LD_INT 4
51176: ARRAY
51177: ST_TO_ADDR
// end ;
51178: LD_VAR 0 2
51182: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51183: LD_INT 0
51185: PPUSH
51186: PPUSH
51187: PPUSH
51188: PPUSH
// if not base_units then
51189: LD_VAR 0 1
51193: NOT
51194: IFFALSE 51198
// exit ;
51196: GO 51285
// result := false ;
51198: LD_ADDR_VAR 0 2
51202: PUSH
51203: LD_INT 0
51205: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51206: LD_ADDR_VAR 0 5
51210: PUSH
51211: LD_VAR 0 1
51215: PPUSH
51216: LD_INT 21
51218: PUSH
51219: LD_INT 3
51221: PUSH
51222: EMPTY
51223: LIST
51224: LIST
51225: PPUSH
51226: CALL_OW 72
51230: ST_TO_ADDR
// if not tmp then
51231: LD_VAR 0 5
51235: NOT
51236: IFFALSE 51240
// exit ;
51238: GO 51285
// for i in tmp do
51240: LD_ADDR_VAR 0 3
51244: PUSH
51245: LD_VAR 0 5
51249: PUSH
51250: FOR_IN
51251: IFFALSE 51283
// begin result := EnemyInRange ( i , 22 ) ;
51253: LD_ADDR_VAR 0 2
51257: PUSH
51258: LD_VAR 0 3
51262: PPUSH
51263: LD_INT 22
51265: PPUSH
51266: CALL 48872 0 2
51270: ST_TO_ADDR
// if result then
51271: LD_VAR 0 2
51275: IFFALSE 51281
// exit ;
51277: POP
51278: POP
51279: GO 51285
// end ;
51281: GO 51250
51283: POP
51284: POP
// end ;
51285: LD_VAR 0 2
51289: RET
// export function FilterByTag ( units , tag ) ; begin
51290: LD_INT 0
51292: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
51293: LD_ADDR_VAR 0 3
51297: PUSH
51298: LD_VAR 0 1
51302: PPUSH
51303: LD_INT 120
51305: PUSH
51306: LD_VAR 0 2
51310: PUSH
51311: EMPTY
51312: LIST
51313: LIST
51314: PPUSH
51315: CALL_OW 72
51319: ST_TO_ADDR
// end ;
51320: LD_VAR 0 3
51324: RET
// export function IsDriver ( un ) ; begin
51325: LD_INT 0
51327: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51328: LD_ADDR_VAR 0 2
51332: PUSH
51333: LD_VAR 0 1
51337: PUSH
51338: LD_INT 55
51340: PUSH
51341: EMPTY
51342: LIST
51343: PPUSH
51344: CALL_OW 69
51348: IN
51349: ST_TO_ADDR
// end ;
51350: LD_VAR 0 2
51354: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51355: LD_INT 0
51357: PPUSH
51358: PPUSH
// list := [ ] ;
51359: LD_ADDR_VAR 0 5
51363: PUSH
51364: EMPTY
51365: ST_TO_ADDR
// case d of 0 :
51366: LD_VAR 0 3
51370: PUSH
51371: LD_INT 0
51373: DOUBLE
51374: EQUAL
51375: IFTRUE 51379
51377: GO 51512
51379: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51380: LD_ADDR_VAR 0 5
51384: PUSH
51385: LD_VAR 0 1
51389: PUSH
51390: LD_INT 4
51392: MINUS
51393: PUSH
51394: LD_VAR 0 2
51398: PUSH
51399: LD_INT 4
51401: MINUS
51402: PUSH
51403: LD_INT 2
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: LIST
51410: PUSH
51411: LD_VAR 0 1
51415: PUSH
51416: LD_INT 3
51418: MINUS
51419: PUSH
51420: LD_VAR 0 2
51424: PUSH
51425: LD_INT 1
51427: PUSH
51428: EMPTY
51429: LIST
51430: LIST
51431: LIST
51432: PUSH
51433: LD_VAR 0 1
51437: PUSH
51438: LD_INT 4
51440: PLUS
51441: PUSH
51442: LD_VAR 0 2
51446: PUSH
51447: LD_INT 4
51449: PUSH
51450: EMPTY
51451: LIST
51452: LIST
51453: LIST
51454: PUSH
51455: LD_VAR 0 1
51459: PUSH
51460: LD_INT 3
51462: PLUS
51463: PUSH
51464: LD_VAR 0 2
51468: PUSH
51469: LD_INT 3
51471: PLUS
51472: PUSH
51473: LD_INT 5
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: LIST
51480: PUSH
51481: LD_VAR 0 1
51485: PUSH
51486: LD_VAR 0 2
51490: PUSH
51491: LD_INT 4
51493: PLUS
51494: PUSH
51495: LD_INT 0
51497: PUSH
51498: EMPTY
51499: LIST
51500: LIST
51501: LIST
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: LIST
51507: LIST
51508: LIST
51509: ST_TO_ADDR
// end ; 1 :
51510: GO 52210
51512: LD_INT 1
51514: DOUBLE
51515: EQUAL
51516: IFTRUE 51520
51518: GO 51653
51520: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51521: LD_ADDR_VAR 0 5
51525: PUSH
51526: LD_VAR 0 1
51530: PUSH
51531: LD_VAR 0 2
51535: PUSH
51536: LD_INT 4
51538: MINUS
51539: PUSH
51540: LD_INT 3
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: LIST
51547: PUSH
51548: LD_VAR 0 1
51552: PUSH
51553: LD_INT 3
51555: MINUS
51556: PUSH
51557: LD_VAR 0 2
51561: PUSH
51562: LD_INT 3
51564: MINUS
51565: PUSH
51566: LD_INT 2
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: LIST
51573: PUSH
51574: LD_VAR 0 1
51578: PUSH
51579: LD_INT 4
51581: MINUS
51582: PUSH
51583: LD_VAR 0 2
51587: PUSH
51588: LD_INT 1
51590: PUSH
51591: EMPTY
51592: LIST
51593: LIST
51594: LIST
51595: PUSH
51596: LD_VAR 0 1
51600: PUSH
51601: LD_VAR 0 2
51605: PUSH
51606: LD_INT 3
51608: PLUS
51609: PUSH
51610: LD_INT 0
51612: PUSH
51613: EMPTY
51614: LIST
51615: LIST
51616: LIST
51617: PUSH
51618: LD_VAR 0 1
51622: PUSH
51623: LD_INT 4
51625: PLUS
51626: PUSH
51627: LD_VAR 0 2
51631: PUSH
51632: LD_INT 4
51634: PLUS
51635: PUSH
51636: LD_INT 5
51638: PUSH
51639: EMPTY
51640: LIST
51641: LIST
51642: LIST
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: ST_TO_ADDR
// end ; 2 :
51651: GO 52210
51653: LD_INT 2
51655: DOUBLE
51656: EQUAL
51657: IFTRUE 51661
51659: GO 51790
51661: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51662: LD_ADDR_VAR 0 5
51666: PUSH
51667: LD_VAR 0 1
51671: PUSH
51672: LD_VAR 0 2
51676: PUSH
51677: LD_INT 3
51679: MINUS
51680: PUSH
51681: LD_INT 3
51683: PUSH
51684: EMPTY
51685: LIST
51686: LIST
51687: LIST
51688: PUSH
51689: LD_VAR 0 1
51693: PUSH
51694: LD_INT 4
51696: PLUS
51697: PUSH
51698: LD_VAR 0 2
51702: PUSH
51703: LD_INT 4
51705: PUSH
51706: EMPTY
51707: LIST
51708: LIST
51709: LIST
51710: PUSH
51711: LD_VAR 0 1
51715: PUSH
51716: LD_VAR 0 2
51720: PUSH
51721: LD_INT 4
51723: PLUS
51724: PUSH
51725: LD_INT 0
51727: PUSH
51728: EMPTY
51729: LIST
51730: LIST
51731: LIST
51732: PUSH
51733: LD_VAR 0 1
51737: PUSH
51738: LD_INT 3
51740: MINUS
51741: PUSH
51742: LD_VAR 0 2
51746: PUSH
51747: LD_INT 1
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: LIST
51754: PUSH
51755: LD_VAR 0 1
51759: PUSH
51760: LD_INT 4
51762: MINUS
51763: PUSH
51764: LD_VAR 0 2
51768: PUSH
51769: LD_INT 4
51771: MINUS
51772: PUSH
51773: LD_INT 2
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: LIST
51780: PUSH
51781: EMPTY
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: ST_TO_ADDR
// end ; 3 :
51788: GO 52210
51790: LD_INT 3
51792: DOUBLE
51793: EQUAL
51794: IFTRUE 51798
51796: GO 51931
51798: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51799: LD_ADDR_VAR 0 5
51803: PUSH
51804: LD_VAR 0 1
51808: PUSH
51809: LD_INT 3
51811: PLUS
51812: PUSH
51813: LD_VAR 0 2
51817: PUSH
51818: LD_INT 4
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: LIST
51825: PUSH
51826: LD_VAR 0 1
51830: PUSH
51831: LD_INT 4
51833: PLUS
51834: PUSH
51835: LD_VAR 0 2
51839: PUSH
51840: LD_INT 4
51842: PLUS
51843: PUSH
51844: LD_INT 5
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: LIST
51851: PUSH
51852: LD_VAR 0 1
51856: PUSH
51857: LD_INT 4
51859: MINUS
51860: PUSH
51861: LD_VAR 0 2
51865: PUSH
51866: LD_INT 1
51868: PUSH
51869: EMPTY
51870: LIST
51871: LIST
51872: LIST
51873: PUSH
51874: LD_VAR 0 1
51878: PUSH
51879: LD_VAR 0 2
51883: PUSH
51884: LD_INT 4
51886: MINUS
51887: PUSH
51888: LD_INT 3
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: LIST
51895: PUSH
51896: LD_VAR 0 1
51900: PUSH
51901: LD_INT 3
51903: MINUS
51904: PUSH
51905: LD_VAR 0 2
51909: PUSH
51910: LD_INT 3
51912: MINUS
51913: PUSH
51914: LD_INT 2
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: LIST
51921: PUSH
51922: EMPTY
51923: LIST
51924: LIST
51925: LIST
51926: LIST
51927: LIST
51928: ST_TO_ADDR
// end ; 4 :
51929: GO 52210
51931: LD_INT 4
51933: DOUBLE
51934: EQUAL
51935: IFTRUE 51939
51937: GO 52072
51939: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51940: LD_ADDR_VAR 0 5
51944: PUSH
51945: LD_VAR 0 1
51949: PUSH
51950: LD_VAR 0 2
51954: PUSH
51955: LD_INT 4
51957: PLUS
51958: PUSH
51959: LD_INT 0
51961: PUSH
51962: EMPTY
51963: LIST
51964: LIST
51965: LIST
51966: PUSH
51967: LD_VAR 0 1
51971: PUSH
51972: LD_INT 3
51974: PLUS
51975: PUSH
51976: LD_VAR 0 2
51980: PUSH
51981: LD_INT 3
51983: PLUS
51984: PUSH
51985: LD_INT 5
51987: PUSH
51988: EMPTY
51989: LIST
51990: LIST
51991: LIST
51992: PUSH
51993: LD_VAR 0 1
51997: PUSH
51998: LD_INT 4
52000: PLUS
52001: PUSH
52002: LD_VAR 0 2
52006: PUSH
52007: LD_INT 4
52009: PUSH
52010: EMPTY
52011: LIST
52012: LIST
52013: LIST
52014: PUSH
52015: LD_VAR 0 1
52019: PUSH
52020: LD_VAR 0 2
52024: PUSH
52025: LD_INT 3
52027: MINUS
52028: PUSH
52029: LD_INT 3
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: LIST
52036: PUSH
52037: LD_VAR 0 1
52041: PUSH
52042: LD_INT 4
52044: MINUS
52045: PUSH
52046: LD_VAR 0 2
52050: PUSH
52051: LD_INT 4
52053: MINUS
52054: PUSH
52055: LD_INT 2
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: LIST
52062: PUSH
52063: EMPTY
52064: LIST
52065: LIST
52066: LIST
52067: LIST
52068: LIST
52069: ST_TO_ADDR
// end ; 5 :
52070: GO 52210
52072: LD_INT 5
52074: DOUBLE
52075: EQUAL
52076: IFTRUE 52080
52078: GO 52209
52080: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52081: LD_ADDR_VAR 0 5
52085: PUSH
52086: LD_VAR 0 1
52090: PUSH
52091: LD_INT 4
52093: MINUS
52094: PUSH
52095: LD_VAR 0 2
52099: PUSH
52100: LD_INT 1
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: LIST
52107: PUSH
52108: LD_VAR 0 1
52112: PUSH
52113: LD_VAR 0 2
52117: PUSH
52118: LD_INT 4
52120: MINUS
52121: PUSH
52122: LD_INT 3
52124: PUSH
52125: EMPTY
52126: LIST
52127: LIST
52128: LIST
52129: PUSH
52130: LD_VAR 0 1
52134: PUSH
52135: LD_INT 4
52137: PLUS
52138: PUSH
52139: LD_VAR 0 2
52143: PUSH
52144: LD_INT 4
52146: PLUS
52147: PUSH
52148: LD_INT 5
52150: PUSH
52151: EMPTY
52152: LIST
52153: LIST
52154: LIST
52155: PUSH
52156: LD_VAR 0 1
52160: PUSH
52161: LD_INT 3
52163: PLUS
52164: PUSH
52165: LD_VAR 0 2
52169: PUSH
52170: LD_INT 4
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: LIST
52177: PUSH
52178: LD_VAR 0 1
52182: PUSH
52183: LD_VAR 0 2
52187: PUSH
52188: LD_INT 3
52190: PLUS
52191: PUSH
52192: LD_INT 0
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: LIST
52199: PUSH
52200: EMPTY
52201: LIST
52202: LIST
52203: LIST
52204: LIST
52205: LIST
52206: ST_TO_ADDR
// end ; end ;
52207: GO 52210
52209: POP
// result := list ;
52210: LD_ADDR_VAR 0 4
52214: PUSH
52215: LD_VAR 0 5
52219: ST_TO_ADDR
// end ;
52220: LD_VAR 0 4
52224: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52225: LD_INT 0
52227: PPUSH
52228: PPUSH
52229: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52230: LD_VAR 0 1
52234: NOT
52235: PUSH
52236: LD_VAR 0 2
52240: PUSH
52241: LD_INT 1
52243: PUSH
52244: LD_INT 2
52246: PUSH
52247: LD_INT 3
52249: PUSH
52250: LD_INT 4
52252: PUSH
52253: EMPTY
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: IN
52259: NOT
52260: OR
52261: IFFALSE 52265
// exit ;
52263: GO 52348
// tmp := [ ] ;
52265: LD_ADDR_VAR 0 5
52269: PUSH
52270: EMPTY
52271: ST_TO_ADDR
// for i in units do
52272: LD_ADDR_VAR 0 4
52276: PUSH
52277: LD_VAR 0 1
52281: PUSH
52282: FOR_IN
52283: IFFALSE 52317
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
52285: LD_ADDR_VAR 0 5
52289: PUSH
52290: LD_VAR 0 5
52294: PPUSH
52295: LD_VAR 0 4
52299: PPUSH
52300: LD_VAR 0 2
52304: PPUSH
52305: CALL_OW 259
52309: PPUSH
52310: CALL 53721 0 2
52314: ST_TO_ADDR
52315: GO 52282
52317: POP
52318: POP
// if not tmp then
52319: LD_VAR 0 5
52323: NOT
52324: IFFALSE 52328
// exit ;
52326: GO 52348
// result := SortListByListDesc ( units , tmp ) ;
52328: LD_ADDR_VAR 0 3
52332: PUSH
52333: LD_VAR 0 1
52337: PPUSH
52338: LD_VAR 0 5
52342: PPUSH
52343: CALL_OW 77
52347: ST_TO_ADDR
// end ;
52348: LD_VAR 0 3
52352: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52353: LD_INT 0
52355: PPUSH
52356: PPUSH
52357: PPUSH
// result := false ;
52358: LD_ADDR_VAR 0 3
52362: PUSH
52363: LD_INT 0
52365: ST_TO_ADDR
// if not building then
52366: LD_VAR 0 2
52370: NOT
52371: IFFALSE 52375
// exit ;
52373: GO 52513
// x := GetX ( building ) ;
52375: LD_ADDR_VAR 0 4
52379: PUSH
52380: LD_VAR 0 2
52384: PPUSH
52385: CALL_OW 250
52389: ST_TO_ADDR
// y := GetY ( building ) ;
52390: LD_ADDR_VAR 0 5
52394: PUSH
52395: LD_VAR 0 2
52399: PPUSH
52400: CALL_OW 251
52404: ST_TO_ADDR
// if not x or not y then
52405: LD_VAR 0 4
52409: NOT
52410: PUSH
52411: LD_VAR 0 5
52415: NOT
52416: OR
52417: IFFALSE 52421
// exit ;
52419: GO 52513
// if GetTaskList ( unit ) then
52421: LD_VAR 0 1
52425: PPUSH
52426: CALL_OW 437
52430: IFFALSE 52513
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52432: LD_STRING e
52434: PUSH
52435: LD_VAR 0 1
52439: PPUSH
52440: CALL_OW 437
52444: PUSH
52445: LD_INT 1
52447: ARRAY
52448: PUSH
52449: LD_INT 1
52451: ARRAY
52452: EQUAL
52453: PUSH
52454: LD_VAR 0 4
52458: PUSH
52459: LD_VAR 0 1
52463: PPUSH
52464: CALL_OW 437
52468: PUSH
52469: LD_INT 1
52471: ARRAY
52472: PUSH
52473: LD_INT 2
52475: ARRAY
52476: EQUAL
52477: AND
52478: PUSH
52479: LD_VAR 0 5
52483: PUSH
52484: LD_VAR 0 1
52488: PPUSH
52489: CALL_OW 437
52493: PUSH
52494: LD_INT 1
52496: ARRAY
52497: PUSH
52498: LD_INT 3
52500: ARRAY
52501: EQUAL
52502: AND
52503: IFFALSE 52513
// result := true end ;
52505: LD_ADDR_VAR 0 3
52509: PUSH
52510: LD_INT 1
52512: ST_TO_ADDR
// end ;
52513: LD_VAR 0 3
52517: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52518: LD_INT 0
52520: PPUSH
// result := false ;
52521: LD_ADDR_VAR 0 4
52525: PUSH
52526: LD_INT 0
52528: ST_TO_ADDR
// if GetTaskList ( unit ) then
52529: LD_VAR 0 1
52533: PPUSH
52534: CALL_OW 437
52538: IFFALSE 52621
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52540: LD_STRING M
52542: PUSH
52543: LD_VAR 0 1
52547: PPUSH
52548: CALL_OW 437
52552: PUSH
52553: LD_INT 1
52555: ARRAY
52556: PUSH
52557: LD_INT 1
52559: ARRAY
52560: EQUAL
52561: PUSH
52562: LD_VAR 0 2
52566: PUSH
52567: LD_VAR 0 1
52571: PPUSH
52572: CALL_OW 437
52576: PUSH
52577: LD_INT 1
52579: ARRAY
52580: PUSH
52581: LD_INT 2
52583: ARRAY
52584: EQUAL
52585: AND
52586: PUSH
52587: LD_VAR 0 3
52591: PUSH
52592: LD_VAR 0 1
52596: PPUSH
52597: CALL_OW 437
52601: PUSH
52602: LD_INT 1
52604: ARRAY
52605: PUSH
52606: LD_INT 3
52608: ARRAY
52609: EQUAL
52610: AND
52611: IFFALSE 52621
// result := true ;
52613: LD_ADDR_VAR 0 4
52617: PUSH
52618: LD_INT 1
52620: ST_TO_ADDR
// end ; end ;
52621: LD_VAR 0 4
52625: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52626: LD_INT 0
52628: PPUSH
52629: PPUSH
52630: PPUSH
52631: PPUSH
// if not unit or not area then
52632: LD_VAR 0 1
52636: NOT
52637: PUSH
52638: LD_VAR 0 2
52642: NOT
52643: OR
52644: IFFALSE 52648
// exit ;
52646: GO 52824
// tmp := AreaToList ( area , i ) ;
52648: LD_ADDR_VAR 0 6
52652: PUSH
52653: LD_VAR 0 2
52657: PPUSH
52658: LD_VAR 0 5
52662: PPUSH
52663: CALL_OW 517
52667: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52668: LD_ADDR_VAR 0 5
52672: PUSH
52673: DOUBLE
52674: LD_INT 1
52676: DEC
52677: ST_TO_ADDR
52678: LD_VAR 0 6
52682: PUSH
52683: LD_INT 1
52685: ARRAY
52686: PUSH
52687: FOR_TO
52688: IFFALSE 52822
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52690: LD_ADDR_VAR 0 7
52694: PUSH
52695: LD_VAR 0 6
52699: PUSH
52700: LD_INT 1
52702: ARRAY
52703: PUSH
52704: LD_VAR 0 5
52708: ARRAY
52709: PUSH
52710: LD_VAR 0 6
52714: PUSH
52715: LD_INT 2
52717: ARRAY
52718: PUSH
52719: LD_VAR 0 5
52723: ARRAY
52724: PUSH
52725: EMPTY
52726: LIST
52727: LIST
52728: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
52729: LD_INT 92
52731: PUSH
52732: LD_VAR 0 7
52736: PUSH
52737: LD_INT 1
52739: ARRAY
52740: PUSH
52741: LD_VAR 0 7
52745: PUSH
52746: LD_INT 2
52748: ARRAY
52749: PUSH
52750: LD_INT 2
52752: PUSH
52753: EMPTY
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: PPUSH
52759: CALL_OW 69
52763: PUSH
52764: LD_INT 0
52766: EQUAL
52767: IFFALSE 52820
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52769: LD_VAR 0 1
52773: PPUSH
52774: LD_VAR 0 7
52778: PUSH
52779: LD_INT 1
52781: ARRAY
52782: PPUSH
52783: LD_VAR 0 7
52787: PUSH
52788: LD_INT 2
52790: ARRAY
52791: PPUSH
52792: LD_VAR 0 3
52796: PPUSH
52797: CALL_OW 48
// result := IsPlaced ( unit ) ;
52801: LD_ADDR_VAR 0 4
52805: PUSH
52806: LD_VAR 0 1
52810: PPUSH
52811: CALL_OW 305
52815: ST_TO_ADDR
// exit ;
52816: POP
52817: POP
52818: GO 52824
// end ; end ;
52820: GO 52687
52822: POP
52823: POP
// end ;
52824: LD_VAR 0 4
52828: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52829: LD_INT 0
52831: PPUSH
52832: PPUSH
52833: PPUSH
// if not side or side > 8 then
52834: LD_VAR 0 1
52838: NOT
52839: PUSH
52840: LD_VAR 0 1
52844: PUSH
52845: LD_INT 8
52847: GREATER
52848: OR
52849: IFFALSE 52853
// exit ;
52851: GO 53040
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52853: LD_ADDR_VAR 0 4
52857: PUSH
52858: LD_INT 22
52860: PUSH
52861: LD_VAR 0 1
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PUSH
52870: LD_INT 21
52872: PUSH
52873: LD_INT 3
52875: PUSH
52876: EMPTY
52877: LIST
52878: LIST
52879: PUSH
52880: EMPTY
52881: LIST
52882: LIST
52883: PPUSH
52884: CALL_OW 69
52888: ST_TO_ADDR
// if not tmp then
52889: LD_VAR 0 4
52893: NOT
52894: IFFALSE 52898
// exit ;
52896: GO 53040
// enable_addtolog := true ;
52898: LD_ADDR_OWVAR 81
52902: PUSH
52903: LD_INT 1
52905: ST_TO_ADDR
// AddToLog ( [ ) ;
52906: LD_STRING [
52908: PPUSH
52909: CALL_OW 561
// for i in tmp do
52913: LD_ADDR_VAR 0 3
52917: PUSH
52918: LD_VAR 0 4
52922: PUSH
52923: FOR_IN
52924: IFFALSE 53031
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52926: LD_STRING [
52928: PUSH
52929: LD_VAR 0 3
52933: PPUSH
52934: CALL_OW 266
52938: STR
52939: PUSH
52940: LD_STRING , 
52942: STR
52943: PUSH
52944: LD_VAR 0 3
52948: PPUSH
52949: CALL_OW 250
52953: STR
52954: PUSH
52955: LD_STRING , 
52957: STR
52958: PUSH
52959: LD_VAR 0 3
52963: PPUSH
52964: CALL_OW 251
52968: STR
52969: PUSH
52970: LD_STRING , 
52972: STR
52973: PUSH
52974: LD_VAR 0 3
52978: PPUSH
52979: CALL_OW 254
52983: STR
52984: PUSH
52985: LD_STRING , 
52987: STR
52988: PUSH
52989: LD_VAR 0 3
52993: PPUSH
52994: LD_INT 1
52996: PPUSH
52997: CALL_OW 268
53001: STR
53002: PUSH
53003: LD_STRING , 
53005: STR
53006: PUSH
53007: LD_VAR 0 3
53011: PPUSH
53012: LD_INT 2
53014: PPUSH
53015: CALL_OW 268
53019: STR
53020: PUSH
53021: LD_STRING ],
53023: STR
53024: PPUSH
53025: CALL_OW 561
// end ;
53029: GO 52923
53031: POP
53032: POP
// AddToLog ( ]; ) ;
53033: LD_STRING ];
53035: PPUSH
53036: CALL_OW 561
// end ;
53040: LD_VAR 0 2
53044: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53045: LD_INT 0
53047: PPUSH
53048: PPUSH
53049: PPUSH
53050: PPUSH
53051: PPUSH
// if not area or not rate or not max then
53052: LD_VAR 0 1
53056: NOT
53057: PUSH
53058: LD_VAR 0 2
53062: NOT
53063: OR
53064: PUSH
53065: LD_VAR 0 4
53069: NOT
53070: OR
53071: IFFALSE 53075
// exit ;
53073: GO 53264
// while 1 do
53075: LD_INT 1
53077: IFFALSE 53264
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53079: LD_ADDR_VAR 0 9
53083: PUSH
53084: LD_VAR 0 1
53088: PPUSH
53089: LD_INT 1
53091: PPUSH
53092: CALL_OW 287
53096: PUSH
53097: LD_INT 10
53099: MUL
53100: ST_TO_ADDR
// r := rate / 10 ;
53101: LD_ADDR_VAR 0 7
53105: PUSH
53106: LD_VAR 0 2
53110: PUSH
53111: LD_INT 10
53113: DIVREAL
53114: ST_TO_ADDR
// time := 1 1$00 ;
53115: LD_ADDR_VAR 0 8
53119: PUSH
53120: LD_INT 2100
53122: ST_TO_ADDR
// if amount < min then
53123: LD_VAR 0 9
53127: PUSH
53128: LD_VAR 0 3
53132: LESS
53133: IFFALSE 53151
// r := r * 2 else
53135: LD_ADDR_VAR 0 7
53139: PUSH
53140: LD_VAR 0 7
53144: PUSH
53145: LD_INT 2
53147: MUL
53148: ST_TO_ADDR
53149: GO 53177
// if amount > max then
53151: LD_VAR 0 9
53155: PUSH
53156: LD_VAR 0 4
53160: GREATER
53161: IFFALSE 53177
// r := r / 2 ;
53163: LD_ADDR_VAR 0 7
53167: PUSH
53168: LD_VAR 0 7
53172: PUSH
53173: LD_INT 2
53175: DIVREAL
53176: ST_TO_ADDR
// time := time / r ;
53177: LD_ADDR_VAR 0 8
53181: PUSH
53182: LD_VAR 0 8
53186: PUSH
53187: LD_VAR 0 7
53191: DIVREAL
53192: ST_TO_ADDR
// if time < 0 then
53193: LD_VAR 0 8
53197: PUSH
53198: LD_INT 0
53200: LESS
53201: IFFALSE 53218
// time := time * - 1 ;
53203: LD_ADDR_VAR 0 8
53207: PUSH
53208: LD_VAR 0 8
53212: PUSH
53213: LD_INT 1
53215: NEG
53216: MUL
53217: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
53218: LD_VAR 0 8
53222: PUSH
53223: LD_INT 35
53225: PPUSH
53226: LD_INT 875
53228: PPUSH
53229: CALL_OW 12
53233: PLUS
53234: PPUSH
53235: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53239: LD_INT 1
53241: PPUSH
53242: LD_INT 5
53244: PPUSH
53245: CALL_OW 12
53249: PPUSH
53250: LD_VAR 0 1
53254: PPUSH
53255: LD_INT 1
53257: PPUSH
53258: CALL_OW 55
// end ;
53262: GO 53075
// end ;
53264: LD_VAR 0 5
53268: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53269: LD_INT 0
53271: PPUSH
53272: PPUSH
53273: PPUSH
53274: PPUSH
53275: PPUSH
53276: PPUSH
53277: PPUSH
53278: PPUSH
// if not turrets or not factories then
53279: LD_VAR 0 1
53283: NOT
53284: PUSH
53285: LD_VAR 0 2
53289: NOT
53290: OR
53291: IFFALSE 53295
// exit ;
53293: GO 53602
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53295: LD_ADDR_VAR 0 10
53299: PUSH
53300: LD_INT 5
53302: PUSH
53303: LD_INT 6
53305: PUSH
53306: EMPTY
53307: LIST
53308: LIST
53309: PUSH
53310: LD_INT 2
53312: PUSH
53313: LD_INT 4
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: PUSH
53320: LD_INT 3
53322: PUSH
53323: LD_INT 5
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PUSH
53330: EMPTY
53331: LIST
53332: LIST
53333: LIST
53334: PUSH
53335: LD_INT 24
53337: PUSH
53338: LD_INT 25
53340: PUSH
53341: EMPTY
53342: LIST
53343: LIST
53344: PUSH
53345: LD_INT 23
53347: PUSH
53348: LD_INT 27
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: PUSH
53355: EMPTY
53356: LIST
53357: LIST
53358: PUSH
53359: LD_INT 42
53361: PUSH
53362: LD_INT 43
53364: PUSH
53365: EMPTY
53366: LIST
53367: LIST
53368: PUSH
53369: LD_INT 44
53371: PUSH
53372: LD_INT 46
53374: PUSH
53375: EMPTY
53376: LIST
53377: LIST
53378: PUSH
53379: LD_INT 45
53381: PUSH
53382: LD_INT 47
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: LIST
53393: PUSH
53394: EMPTY
53395: LIST
53396: LIST
53397: LIST
53398: ST_TO_ADDR
// result := [ ] ;
53399: LD_ADDR_VAR 0 3
53403: PUSH
53404: EMPTY
53405: ST_TO_ADDR
// for i in turrets do
53406: LD_ADDR_VAR 0 4
53410: PUSH
53411: LD_VAR 0 1
53415: PUSH
53416: FOR_IN
53417: IFFALSE 53600
// begin nat := GetNation ( i ) ;
53419: LD_ADDR_VAR 0 7
53423: PUSH
53424: LD_VAR 0 4
53428: PPUSH
53429: CALL_OW 248
53433: ST_TO_ADDR
// weapon := 0 ;
53434: LD_ADDR_VAR 0 8
53438: PUSH
53439: LD_INT 0
53441: ST_TO_ADDR
// if not nat then
53442: LD_VAR 0 7
53446: NOT
53447: IFFALSE 53451
// continue ;
53449: GO 53416
// for j in list [ nat ] do
53451: LD_ADDR_VAR 0 5
53455: PUSH
53456: LD_VAR 0 10
53460: PUSH
53461: LD_VAR 0 7
53465: ARRAY
53466: PUSH
53467: FOR_IN
53468: IFFALSE 53509
// if GetBWeapon ( i ) = j [ 1 ] then
53470: LD_VAR 0 4
53474: PPUSH
53475: CALL_OW 269
53479: PUSH
53480: LD_VAR 0 5
53484: PUSH
53485: LD_INT 1
53487: ARRAY
53488: EQUAL
53489: IFFALSE 53507
// begin weapon := j [ 2 ] ;
53491: LD_ADDR_VAR 0 8
53495: PUSH
53496: LD_VAR 0 5
53500: PUSH
53501: LD_INT 2
53503: ARRAY
53504: ST_TO_ADDR
// break ;
53505: GO 53509
// end ;
53507: GO 53467
53509: POP
53510: POP
// if not weapon then
53511: LD_VAR 0 8
53515: NOT
53516: IFFALSE 53520
// continue ;
53518: GO 53416
// for k in factories do
53520: LD_ADDR_VAR 0 6
53524: PUSH
53525: LD_VAR 0 2
53529: PUSH
53530: FOR_IN
53531: IFFALSE 53596
// begin weapons := AvailableWeaponList ( k ) ;
53533: LD_ADDR_VAR 0 9
53537: PUSH
53538: LD_VAR 0 6
53542: PPUSH
53543: CALL_OW 478
53547: ST_TO_ADDR
// if not weapons then
53548: LD_VAR 0 9
53552: NOT
53553: IFFALSE 53557
// continue ;
53555: GO 53530
// if weapon in weapons then
53557: LD_VAR 0 8
53561: PUSH
53562: LD_VAR 0 9
53566: IN
53567: IFFALSE 53594
// begin result := [ i , weapon ] ;
53569: LD_ADDR_VAR 0 3
53573: PUSH
53574: LD_VAR 0 4
53578: PUSH
53579: LD_VAR 0 8
53583: PUSH
53584: EMPTY
53585: LIST
53586: LIST
53587: ST_TO_ADDR
// exit ;
53588: POP
53589: POP
53590: POP
53591: POP
53592: GO 53602
// end ; end ;
53594: GO 53530
53596: POP
53597: POP
// end ;
53598: GO 53416
53600: POP
53601: POP
// end ;
53602: LD_VAR 0 3
53606: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53607: LD_INT 0
53609: PPUSH
// if not side or side > 8 then
53610: LD_VAR 0 3
53614: NOT
53615: PUSH
53616: LD_VAR 0 3
53620: PUSH
53621: LD_INT 8
53623: GREATER
53624: OR
53625: IFFALSE 53629
// exit ;
53627: GO 53688
// if not range then
53629: LD_VAR 0 4
53633: NOT
53634: IFFALSE 53645
// range := - 12 ;
53636: LD_ADDR_VAR 0 4
53640: PUSH
53641: LD_INT 12
53643: NEG
53644: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53645: LD_VAR 0 1
53649: PPUSH
53650: LD_VAR 0 2
53654: PPUSH
53655: LD_VAR 0 3
53659: PPUSH
53660: LD_VAR 0 4
53664: PPUSH
53665: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53669: LD_VAR 0 1
53673: PPUSH
53674: LD_VAR 0 2
53678: PPUSH
53679: LD_VAR 0 3
53683: PPUSH
53684: CALL_OW 331
// end ;
53688: LD_VAR 0 5
53692: RET
// export function Video ( mode ) ; begin
53693: LD_INT 0
53695: PPUSH
// ingame_video = mode ;
53696: LD_ADDR_OWVAR 52
53700: PUSH
53701: LD_VAR 0 1
53705: ST_TO_ADDR
// interface_hidden = mode ;
53706: LD_ADDR_OWVAR 54
53710: PUSH
53711: LD_VAR 0 1
53715: ST_TO_ADDR
// end ;
53716: LD_VAR 0 2
53720: RET
// export function Join ( array , element ) ; begin
53721: LD_INT 0
53723: PPUSH
// result := Replace ( array , array + 1 , element ) ;
53724: LD_ADDR_VAR 0 3
53728: PUSH
53729: LD_VAR 0 1
53733: PPUSH
53734: LD_VAR 0 1
53738: PUSH
53739: LD_INT 1
53741: PLUS
53742: PPUSH
53743: LD_VAR 0 2
53747: PPUSH
53748: CALL_OW 1
53752: ST_TO_ADDR
// end ;
53753: LD_VAR 0 3
53757: RET
// export function JoinUnion ( array , element ) ; begin
53758: LD_INT 0
53760: PPUSH
// result := array union element ;
53761: LD_ADDR_VAR 0 3
53765: PUSH
53766: LD_VAR 0 1
53770: PUSH
53771: LD_VAR 0 2
53775: UNION
53776: ST_TO_ADDR
// end ;
53777: LD_VAR 0 3
53781: RET
// export function GetBehemoths ( side ) ; begin
53782: LD_INT 0
53784: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
53785: LD_ADDR_VAR 0 2
53789: PUSH
53790: LD_INT 22
53792: PUSH
53793: LD_VAR 0 1
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PUSH
53802: LD_INT 31
53804: PUSH
53805: LD_INT 25
53807: PUSH
53808: EMPTY
53809: LIST
53810: LIST
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PPUSH
53816: CALL_OW 69
53820: ST_TO_ADDR
// end ;
53821: LD_VAR 0 2
53825: RET
// export function Shuffle ( array ) ; var i , index ; begin
53826: LD_INT 0
53828: PPUSH
53829: PPUSH
53830: PPUSH
// result := [ ] ;
53831: LD_ADDR_VAR 0 2
53835: PUSH
53836: EMPTY
53837: ST_TO_ADDR
// if not array then
53838: LD_VAR 0 1
53842: NOT
53843: IFFALSE 53847
// exit ;
53845: GO 53946
// Randomize ;
53847: CALL_OW 10
// for i = array downto 1 do
53851: LD_ADDR_VAR 0 3
53855: PUSH
53856: DOUBLE
53857: LD_VAR 0 1
53861: INC
53862: ST_TO_ADDR
53863: LD_INT 1
53865: PUSH
53866: FOR_DOWNTO
53867: IFFALSE 53944
// begin index := rand ( 1 , array ) ;
53869: LD_ADDR_VAR 0 4
53873: PUSH
53874: LD_INT 1
53876: PPUSH
53877: LD_VAR 0 1
53881: PPUSH
53882: CALL_OW 12
53886: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53887: LD_ADDR_VAR 0 2
53891: PUSH
53892: LD_VAR 0 2
53896: PPUSH
53897: LD_VAR 0 2
53901: PUSH
53902: LD_INT 1
53904: PLUS
53905: PPUSH
53906: LD_VAR 0 1
53910: PUSH
53911: LD_VAR 0 4
53915: ARRAY
53916: PPUSH
53917: CALL_OW 2
53921: ST_TO_ADDR
// array := Delete ( array , index ) ;
53922: LD_ADDR_VAR 0 1
53926: PUSH
53927: LD_VAR 0 1
53931: PPUSH
53932: LD_VAR 0 4
53936: PPUSH
53937: CALL_OW 3
53941: ST_TO_ADDR
// end ;
53942: GO 53866
53944: POP
53945: POP
// end ;
53946: LD_VAR 0 2
53950: RET
// export function GetBaseMaterials ( base ) ; begin
53951: LD_INT 0
53953: PPUSH
// result := [ 0 , 0 , 0 ] ;
53954: LD_ADDR_VAR 0 2
53958: PUSH
53959: LD_INT 0
53961: PUSH
53962: LD_INT 0
53964: PUSH
53965: LD_INT 0
53967: PUSH
53968: EMPTY
53969: LIST
53970: LIST
53971: LIST
53972: ST_TO_ADDR
// if not base then
53973: LD_VAR 0 1
53977: NOT
53978: IFFALSE 53982
// exit ;
53980: GO 54031
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53982: LD_ADDR_VAR 0 2
53986: PUSH
53987: LD_VAR 0 1
53991: PPUSH
53992: LD_INT 1
53994: PPUSH
53995: CALL_OW 275
53999: PUSH
54000: LD_VAR 0 1
54004: PPUSH
54005: LD_INT 2
54007: PPUSH
54008: CALL_OW 275
54012: PUSH
54013: LD_VAR 0 1
54017: PPUSH
54018: LD_INT 3
54020: PPUSH
54021: CALL_OW 275
54025: PUSH
54026: EMPTY
54027: LIST
54028: LIST
54029: LIST
54030: ST_TO_ADDR
// end ;
54031: LD_VAR 0 2
54035: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54036: LD_INT 0
54038: PPUSH
54039: PPUSH
// result := array ;
54040: LD_ADDR_VAR 0 3
54044: PUSH
54045: LD_VAR 0 1
54049: ST_TO_ADDR
// if size >= result then
54050: LD_VAR 0 2
54054: PUSH
54055: LD_VAR 0 3
54059: GREATEREQUAL
54060: IFFALSE 54064
// exit ;
54062: GO 54114
// if size then
54064: LD_VAR 0 2
54068: IFFALSE 54114
// for i := array downto size do
54070: LD_ADDR_VAR 0 4
54074: PUSH
54075: DOUBLE
54076: LD_VAR 0 1
54080: INC
54081: ST_TO_ADDR
54082: LD_VAR 0 2
54086: PUSH
54087: FOR_DOWNTO
54088: IFFALSE 54112
// result := Delete ( result , result ) ;
54090: LD_ADDR_VAR 0 3
54094: PUSH
54095: LD_VAR 0 3
54099: PPUSH
54100: LD_VAR 0 3
54104: PPUSH
54105: CALL_OW 3
54109: ST_TO_ADDR
54110: GO 54087
54112: POP
54113: POP
// end ;
54114: LD_VAR 0 3
54118: RET
// export function ComExit ( unit ) ; var tmp ; begin
54119: LD_INT 0
54121: PPUSH
54122: PPUSH
// if not IsInUnit ( unit ) then
54123: LD_VAR 0 1
54127: PPUSH
54128: CALL_OW 310
54132: NOT
54133: IFFALSE 54137
// exit ;
54135: GO 54197
// tmp := IsInUnit ( unit ) ;
54137: LD_ADDR_VAR 0 3
54141: PUSH
54142: LD_VAR 0 1
54146: PPUSH
54147: CALL_OW 310
54151: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54152: LD_VAR 0 3
54156: PPUSH
54157: CALL_OW 247
54161: PUSH
54162: LD_INT 2
54164: EQUAL
54165: IFFALSE 54178
// ComExitVehicle ( unit ) else
54167: LD_VAR 0 1
54171: PPUSH
54172: CALL_OW 121
54176: GO 54187
// ComExitBuilding ( unit ) ;
54178: LD_VAR 0 1
54182: PPUSH
54183: CALL_OW 122
// result := tmp ;
54187: LD_ADDR_VAR 0 2
54191: PUSH
54192: LD_VAR 0 3
54196: ST_TO_ADDR
// end ;
54197: LD_VAR 0 2
54201: RET
// export function ComExitAll ( units ) ; var i ; begin
54202: LD_INT 0
54204: PPUSH
54205: PPUSH
// if not units then
54206: LD_VAR 0 1
54210: NOT
54211: IFFALSE 54215
// exit ;
54213: GO 54241
// for i in units do
54215: LD_ADDR_VAR 0 3
54219: PUSH
54220: LD_VAR 0 1
54224: PUSH
54225: FOR_IN
54226: IFFALSE 54239
// ComExit ( i ) ;
54228: LD_VAR 0 3
54232: PPUSH
54233: CALL 54119 0 1
54237: GO 54225
54239: POP
54240: POP
// end ;
54241: LD_VAR 0 2
54245: RET
// export function ResetHc ; begin
54246: LD_INT 0
54248: PPUSH
// InitHc ;
54249: CALL_OW 19
// hc_importance := 0 ;
54253: LD_ADDR_OWVAR 32
54257: PUSH
54258: LD_INT 0
54260: ST_TO_ADDR
// end ;
54261: LD_VAR 0 1
54265: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54266: LD_INT 0
54268: PPUSH
54269: PPUSH
54270: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54271: LD_ADDR_VAR 0 6
54275: PUSH
54276: LD_VAR 0 1
54280: PUSH
54281: LD_VAR 0 3
54285: PLUS
54286: PUSH
54287: LD_INT 2
54289: DIV
54290: ST_TO_ADDR
// if _x < 0 then
54291: LD_VAR 0 6
54295: PUSH
54296: LD_INT 0
54298: LESS
54299: IFFALSE 54316
// _x := _x * - 1 ;
54301: LD_ADDR_VAR 0 6
54305: PUSH
54306: LD_VAR 0 6
54310: PUSH
54311: LD_INT 1
54313: NEG
54314: MUL
54315: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54316: LD_ADDR_VAR 0 7
54320: PUSH
54321: LD_VAR 0 2
54325: PUSH
54326: LD_VAR 0 4
54330: PLUS
54331: PUSH
54332: LD_INT 2
54334: DIV
54335: ST_TO_ADDR
// if _y < 0 then
54336: LD_VAR 0 7
54340: PUSH
54341: LD_INT 0
54343: LESS
54344: IFFALSE 54361
// _y := _y * - 1 ;
54346: LD_ADDR_VAR 0 7
54350: PUSH
54351: LD_VAR 0 7
54355: PUSH
54356: LD_INT 1
54358: NEG
54359: MUL
54360: ST_TO_ADDR
// result := [ _x , _y ] ;
54361: LD_ADDR_VAR 0 5
54365: PUSH
54366: LD_VAR 0 6
54370: PUSH
54371: LD_VAR 0 7
54375: PUSH
54376: EMPTY
54377: LIST
54378: LIST
54379: ST_TO_ADDR
// end ;
54380: LD_VAR 0 5
54384: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54385: LD_INT 0
54387: PPUSH
54388: PPUSH
54389: PPUSH
54390: PPUSH
// task := GetTaskList ( unit ) ;
54391: LD_ADDR_VAR 0 7
54395: PUSH
54396: LD_VAR 0 1
54400: PPUSH
54401: CALL_OW 437
54405: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54406: LD_VAR 0 7
54410: NOT
54411: PUSH
54412: LD_VAR 0 1
54416: PPUSH
54417: LD_VAR 0 2
54421: PPUSH
54422: CALL_OW 308
54426: NOT
54427: AND
54428: IFFALSE 54432
// exit ;
54430: GO 54550
// if IsInArea ( unit , area ) then
54432: LD_VAR 0 1
54436: PPUSH
54437: LD_VAR 0 2
54441: PPUSH
54442: CALL_OW 308
54446: IFFALSE 54464
// begin ComMoveToArea ( unit , goAway ) ;
54448: LD_VAR 0 1
54452: PPUSH
54453: LD_VAR 0 3
54457: PPUSH
54458: CALL_OW 113
// exit ;
54462: GO 54550
// end ; if task [ 1 ] [ 1 ] <> M then
54464: LD_VAR 0 7
54468: PUSH
54469: LD_INT 1
54471: ARRAY
54472: PUSH
54473: LD_INT 1
54475: ARRAY
54476: PUSH
54477: LD_STRING M
54479: NONEQUAL
54480: IFFALSE 54484
// exit ;
54482: GO 54550
// x := task [ 1 ] [ 2 ] ;
54484: LD_ADDR_VAR 0 5
54488: PUSH
54489: LD_VAR 0 7
54493: PUSH
54494: LD_INT 1
54496: ARRAY
54497: PUSH
54498: LD_INT 2
54500: ARRAY
54501: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54502: LD_ADDR_VAR 0 6
54506: PUSH
54507: LD_VAR 0 7
54511: PUSH
54512: LD_INT 1
54514: ARRAY
54515: PUSH
54516: LD_INT 3
54518: ARRAY
54519: ST_TO_ADDR
// if InArea ( x , y , area ) then
54520: LD_VAR 0 5
54524: PPUSH
54525: LD_VAR 0 6
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: CALL_OW 309
54539: IFFALSE 54550
// ComStop ( unit ) ;
54541: LD_VAR 0 1
54545: PPUSH
54546: CALL_OW 141
// end ;
54550: LD_VAR 0 4
54554: RET
// export function Abs ( value ) ; begin
54555: LD_INT 0
54557: PPUSH
// result := value ;
54558: LD_ADDR_VAR 0 2
54562: PUSH
54563: LD_VAR 0 1
54567: ST_TO_ADDR
// if value < 0 then
54568: LD_VAR 0 1
54572: PUSH
54573: LD_INT 0
54575: LESS
54576: IFFALSE 54593
// result := value * - 1 ;
54578: LD_ADDR_VAR 0 2
54582: PUSH
54583: LD_VAR 0 1
54587: PUSH
54588: LD_INT 1
54590: NEG
54591: MUL
54592: ST_TO_ADDR
// end ;
54593: LD_VAR 0 2
54597: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
54598: LD_INT 0
54600: PPUSH
54601: PPUSH
54602: PPUSH
54603: PPUSH
54604: PPUSH
54605: PPUSH
54606: PPUSH
54607: PPUSH
// if not unit or not building then
54608: LD_VAR 0 1
54612: NOT
54613: PUSH
54614: LD_VAR 0 2
54618: NOT
54619: OR
54620: IFFALSE 54624
// exit ;
54622: GO 54850
// x := GetX ( building ) ;
54624: LD_ADDR_VAR 0 4
54628: PUSH
54629: LD_VAR 0 2
54633: PPUSH
54634: CALL_OW 250
54638: ST_TO_ADDR
// y := GetY ( building ) ;
54639: LD_ADDR_VAR 0 6
54643: PUSH
54644: LD_VAR 0 2
54648: PPUSH
54649: CALL_OW 251
54653: ST_TO_ADDR
// d := GetDir ( building ) ;
54654: LD_ADDR_VAR 0 8
54658: PUSH
54659: LD_VAR 0 2
54663: PPUSH
54664: CALL_OW 254
54668: ST_TO_ADDR
// r := 4 ;
54669: LD_ADDR_VAR 0 9
54673: PUSH
54674: LD_INT 4
54676: ST_TO_ADDR
// for i := 1 to 5 do
54677: LD_ADDR_VAR 0 10
54681: PUSH
54682: DOUBLE
54683: LD_INT 1
54685: DEC
54686: ST_TO_ADDR
54687: LD_INT 5
54689: PUSH
54690: FOR_TO
54691: IFFALSE 54848
// begin _x := ShiftX ( x , d , r + i ) ;
54693: LD_ADDR_VAR 0 5
54697: PUSH
54698: LD_VAR 0 4
54702: PPUSH
54703: LD_VAR 0 8
54707: PPUSH
54708: LD_VAR 0 9
54712: PUSH
54713: LD_VAR 0 10
54717: PLUS
54718: PPUSH
54719: CALL_OW 272
54723: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
54724: LD_ADDR_VAR 0 7
54728: PUSH
54729: LD_VAR 0 6
54733: PPUSH
54734: LD_VAR 0 8
54738: PPUSH
54739: LD_VAR 0 9
54743: PUSH
54744: LD_VAR 0 10
54748: PLUS
54749: PPUSH
54750: CALL_OW 273
54754: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
54755: LD_VAR 0 5
54759: PPUSH
54760: LD_VAR 0 7
54764: PPUSH
54765: CALL_OW 488
54769: PUSH
54770: LD_VAR 0 5
54774: PPUSH
54775: LD_VAR 0 7
54779: PPUSH
54780: CALL_OW 428
54784: PPUSH
54785: CALL_OW 247
54789: PUSH
54790: LD_INT 3
54792: PUSH
54793: LD_INT 2
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: IN
54800: NOT
54801: AND
54802: IFFALSE 54846
// begin ComMoveXY ( unit , _x , _y ) ;
54804: LD_VAR 0 1
54808: PPUSH
54809: LD_VAR 0 5
54813: PPUSH
54814: LD_VAR 0 7
54818: PPUSH
54819: CALL_OW 111
// result := [ _x , _y ] ;
54823: LD_ADDR_VAR 0 3
54827: PUSH
54828: LD_VAR 0 5
54832: PUSH
54833: LD_VAR 0 7
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: ST_TO_ADDR
// exit ;
54842: POP
54843: POP
54844: GO 54850
// end ; end ;
54846: GO 54690
54848: POP
54849: POP
// end ;
54850: LD_VAR 0 3
54854: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
54855: LD_INT 0
54857: PPUSH
54858: PPUSH
54859: PPUSH
// result := 0 ;
54860: LD_ADDR_VAR 0 3
54864: PUSH
54865: LD_INT 0
54867: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
54868: LD_VAR 0 1
54872: PUSH
54873: LD_INT 0
54875: LESS
54876: PUSH
54877: LD_VAR 0 1
54881: PUSH
54882: LD_INT 8
54884: GREATER
54885: OR
54886: PUSH
54887: LD_VAR 0 2
54891: PUSH
54892: LD_INT 0
54894: LESS
54895: OR
54896: PUSH
54897: LD_VAR 0 2
54901: PUSH
54902: LD_INT 8
54904: GREATER
54905: OR
54906: IFFALSE 54910
// exit ;
54908: GO 54985
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
54910: LD_ADDR_VAR 0 4
54914: PUSH
54915: LD_INT 22
54917: PUSH
54918: LD_VAR 0 2
54922: PUSH
54923: EMPTY
54924: LIST
54925: LIST
54926: PPUSH
54927: CALL_OW 69
54931: PUSH
54932: FOR_IN
54933: IFFALSE 54983
// begin un := UnitShoot ( i ) ;
54935: LD_ADDR_VAR 0 5
54939: PUSH
54940: LD_VAR 0 4
54944: PPUSH
54945: CALL_OW 504
54949: ST_TO_ADDR
// if GetSide ( un ) = side1 then
54950: LD_VAR 0 5
54954: PPUSH
54955: CALL_OW 255
54959: PUSH
54960: LD_VAR 0 1
54964: EQUAL
54965: IFFALSE 54981
// begin result := un ;
54967: LD_ADDR_VAR 0 3
54971: PUSH
54972: LD_VAR 0 5
54976: ST_TO_ADDR
// exit ;
54977: POP
54978: POP
54979: GO 54985
// end ; end ;
54981: GO 54932
54983: POP
54984: POP
// end ;
54985: LD_VAR 0 3
54989: RET
// export function GetCargoBay ( units ) ; begin
54990: LD_INT 0
54992: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
54993: LD_ADDR_VAR 0 2
54997: PUSH
54998: LD_VAR 0 1
55002: PPUSH
55003: LD_INT 2
55005: PUSH
55006: LD_INT 34
55008: PUSH
55009: LD_INT 12
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: PUSH
55016: LD_INT 34
55018: PUSH
55019: LD_INT 51
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: PUSH
55026: LD_INT 34
55028: PUSH
55029: LD_INT 32
55031: PUSH
55032: EMPTY
55033: LIST
55034: LIST
55035: PUSH
55036: LD_INT 34
55038: PUSH
55039: LD_INT 89
55041: PUSH
55042: EMPTY
55043: LIST
55044: LIST
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: PPUSH
55053: CALL_OW 72
55057: ST_TO_ADDR
// end ;
55058: LD_VAR 0 2
55062: RET
// export function Negate ( value ) ; begin
55063: LD_INT 0
55065: PPUSH
// result := not value ;
55066: LD_ADDR_VAR 0 2
55070: PUSH
55071: LD_VAR 0 1
55075: NOT
55076: ST_TO_ADDR
// end ;
55077: LD_VAR 0 2
55081: RET
// export function Inc ( value ) ; begin
55082: LD_INT 0
55084: PPUSH
// result := value + 1 ;
55085: LD_ADDR_VAR 0 2
55089: PUSH
55090: LD_VAR 0 1
55094: PUSH
55095: LD_INT 1
55097: PLUS
55098: ST_TO_ADDR
// end ;
55099: LD_VAR 0 2
55103: RET
// export function Dec ( value ) ; begin
55104: LD_INT 0
55106: PPUSH
// result := value - 1 ;
55107: LD_ADDR_VAR 0 2
55111: PUSH
55112: LD_VAR 0 1
55116: PUSH
55117: LD_INT 1
55119: MINUS
55120: ST_TO_ADDR
// end ;
55121: LD_VAR 0 2
55125: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
55126: LD_INT 0
55128: PPUSH
55129: PPUSH
55130: PPUSH
55131: PPUSH
55132: PPUSH
55133: PPUSH
55134: PPUSH
55135: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
55136: LD_VAR 0 1
55140: PPUSH
55141: LD_VAR 0 2
55145: PPUSH
55146: CALL_OW 488
55150: NOT
55151: PUSH
55152: LD_VAR 0 3
55156: PPUSH
55157: LD_VAR 0 4
55161: PPUSH
55162: CALL_OW 488
55166: NOT
55167: OR
55168: IFFALSE 55181
// begin result := - 1 ;
55170: LD_ADDR_VAR 0 5
55174: PUSH
55175: LD_INT 1
55177: NEG
55178: ST_TO_ADDR
// exit ;
55179: GO 55416
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
55181: LD_ADDR_VAR 0 12
55185: PUSH
55186: LD_VAR 0 1
55190: PPUSH
55191: LD_VAR 0 2
55195: PPUSH
55196: LD_VAR 0 3
55200: PPUSH
55201: LD_VAR 0 4
55205: PPUSH
55206: CALL 54266 0 4
55210: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
55211: LD_ADDR_VAR 0 11
55215: PUSH
55216: LD_VAR 0 1
55220: PPUSH
55221: LD_VAR 0 2
55225: PPUSH
55226: LD_VAR 0 12
55230: PUSH
55231: LD_INT 1
55233: ARRAY
55234: PPUSH
55235: LD_VAR 0 12
55239: PUSH
55240: LD_INT 2
55242: ARRAY
55243: PPUSH
55244: CALL_OW 298
55248: ST_TO_ADDR
// distance := 9999 ;
55249: LD_ADDR_VAR 0 10
55253: PUSH
55254: LD_INT 9999
55256: ST_TO_ADDR
// for i := 0 to 5 do
55257: LD_ADDR_VAR 0 6
55261: PUSH
55262: DOUBLE
55263: LD_INT 0
55265: DEC
55266: ST_TO_ADDR
55267: LD_INT 5
55269: PUSH
55270: FOR_TO
55271: IFFALSE 55414
// begin _x := ShiftX ( x1 , i , centerDist ) ;
55273: LD_ADDR_VAR 0 7
55277: PUSH
55278: LD_VAR 0 1
55282: PPUSH
55283: LD_VAR 0 6
55287: PPUSH
55288: LD_VAR 0 11
55292: PPUSH
55293: CALL_OW 272
55297: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
55298: LD_ADDR_VAR 0 8
55302: PUSH
55303: LD_VAR 0 2
55307: PPUSH
55308: LD_VAR 0 6
55312: PPUSH
55313: LD_VAR 0 11
55317: PPUSH
55318: CALL_OW 273
55322: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55323: LD_VAR 0 7
55327: PPUSH
55328: LD_VAR 0 8
55332: PPUSH
55333: CALL_OW 488
55337: NOT
55338: IFFALSE 55342
// continue ;
55340: GO 55270
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
55342: LD_ADDR_VAR 0 9
55346: PUSH
55347: LD_VAR 0 12
55351: PUSH
55352: LD_INT 1
55354: ARRAY
55355: PPUSH
55356: LD_VAR 0 12
55360: PUSH
55361: LD_INT 2
55363: ARRAY
55364: PPUSH
55365: LD_VAR 0 7
55369: PPUSH
55370: LD_VAR 0 8
55374: PPUSH
55375: CALL_OW 298
55379: ST_TO_ADDR
// if tmp < distance then
55380: LD_VAR 0 9
55384: PUSH
55385: LD_VAR 0 10
55389: LESS
55390: IFFALSE 55412
// begin result := i ;
55392: LD_ADDR_VAR 0 5
55396: PUSH
55397: LD_VAR 0 6
55401: ST_TO_ADDR
// distance := tmp ;
55402: LD_ADDR_VAR 0 10
55406: PUSH
55407: LD_VAR 0 9
55411: ST_TO_ADDR
// end ; end ;
55412: GO 55270
55414: POP
55415: POP
// end ;
55416: LD_VAR 0 5
55420: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55421: LD_INT 0
55423: PPUSH
55424: PPUSH
// if not driver or not IsInUnit ( driver ) then
55425: LD_VAR 0 1
55429: NOT
55430: PUSH
55431: LD_VAR 0 1
55435: PPUSH
55436: CALL_OW 310
55440: NOT
55441: OR
55442: IFFALSE 55446
// exit ;
55444: GO 55536
// vehicle := IsInUnit ( driver ) ;
55446: LD_ADDR_VAR 0 3
55450: PUSH
55451: LD_VAR 0 1
55455: PPUSH
55456: CALL_OW 310
55460: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55461: LD_VAR 0 1
55465: PPUSH
55466: LD_STRING \
55468: PUSH
55469: LD_INT 0
55471: PUSH
55472: LD_INT 0
55474: PUSH
55475: LD_INT 0
55477: PUSH
55478: LD_INT 0
55480: PUSH
55481: LD_INT 0
55483: PUSH
55484: LD_INT 0
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: LIST
55491: LIST
55492: LIST
55493: LIST
55494: LIST
55495: PUSH
55496: LD_STRING E
55498: PUSH
55499: LD_INT 0
55501: PUSH
55502: LD_INT 0
55504: PUSH
55505: LD_VAR 0 3
55509: PUSH
55510: LD_INT 0
55512: PUSH
55513: LD_INT 0
55515: PUSH
55516: LD_INT 0
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: LIST
55523: LIST
55524: LIST
55525: LIST
55526: LIST
55527: PUSH
55528: EMPTY
55529: LIST
55530: LIST
55531: PPUSH
55532: CALL_OW 446
// end ;
55536: LD_VAR 0 2
55540: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
55541: LD_INT 0
55543: PPUSH
55544: PPUSH
// if not driver or not IsInUnit ( driver ) then
55545: LD_VAR 0 1
55549: NOT
55550: PUSH
55551: LD_VAR 0 1
55555: PPUSH
55556: CALL_OW 310
55560: NOT
55561: OR
55562: IFFALSE 55566
// exit ;
55564: GO 55656
// vehicle := IsInUnit ( driver ) ;
55566: LD_ADDR_VAR 0 3
55570: PUSH
55571: LD_VAR 0 1
55575: PPUSH
55576: CALL_OW 310
55580: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
55581: LD_VAR 0 1
55585: PPUSH
55586: LD_STRING \
55588: PUSH
55589: LD_INT 0
55591: PUSH
55592: LD_INT 0
55594: PUSH
55595: LD_INT 0
55597: PUSH
55598: LD_INT 0
55600: PUSH
55601: LD_INT 0
55603: PUSH
55604: LD_INT 0
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: LIST
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: PUSH
55616: LD_STRING E
55618: PUSH
55619: LD_INT 0
55621: PUSH
55622: LD_INT 0
55624: PUSH
55625: LD_VAR 0 3
55629: PUSH
55630: LD_INT 0
55632: PUSH
55633: LD_INT 0
55635: PUSH
55636: LD_INT 0
55638: PUSH
55639: EMPTY
55640: LIST
55641: LIST
55642: LIST
55643: LIST
55644: LIST
55645: LIST
55646: LIST
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: PPUSH
55652: CALL_OW 447
// end ;
55656: LD_VAR 0 2
55660: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
55661: LD_INT 0
55663: PPUSH
55664: PPUSH
55665: PPUSH
// tmp := [ ] ;
55666: LD_ADDR_VAR 0 5
55670: PUSH
55671: EMPTY
55672: ST_TO_ADDR
// for i in units do
55673: LD_ADDR_VAR 0 4
55677: PUSH
55678: LD_VAR 0 1
55682: PUSH
55683: FOR_IN
55684: IFFALSE 55722
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
55686: LD_ADDR_VAR 0 5
55690: PUSH
55691: LD_VAR 0 5
55695: PPUSH
55696: LD_VAR 0 5
55700: PUSH
55701: LD_INT 1
55703: PLUS
55704: PPUSH
55705: LD_VAR 0 4
55709: PPUSH
55710: CALL_OW 256
55714: PPUSH
55715: CALL_OW 2
55719: ST_TO_ADDR
55720: GO 55683
55722: POP
55723: POP
// if not tmp then
55724: LD_VAR 0 5
55728: NOT
55729: IFFALSE 55733
// exit ;
55731: GO 55781
// if asc then
55733: LD_VAR 0 2
55737: IFFALSE 55761
// result := SortListByListAsc ( units , tmp ) else
55739: LD_ADDR_VAR 0 3
55743: PUSH
55744: LD_VAR 0 1
55748: PPUSH
55749: LD_VAR 0 5
55753: PPUSH
55754: CALL_OW 76
55758: ST_TO_ADDR
55759: GO 55781
// result := SortListByListDesc ( units , tmp ) ;
55761: LD_ADDR_VAR 0 3
55765: PUSH
55766: LD_VAR 0 1
55770: PPUSH
55771: LD_VAR 0 5
55775: PPUSH
55776: CALL_OW 77
55780: ST_TO_ADDR
// end ;
55781: LD_VAR 0 3
55785: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
55786: LD_INT 0
55788: PPUSH
55789: PPUSH
// task := GetTaskList ( mech ) ;
55790: LD_ADDR_VAR 0 4
55794: PUSH
55795: LD_VAR 0 1
55799: PPUSH
55800: CALL_OW 437
55804: ST_TO_ADDR
// if not task then
55805: LD_VAR 0 4
55809: NOT
55810: IFFALSE 55814
// exit ;
55812: GO 55856
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
55814: LD_ADDR_VAR 0 3
55818: PUSH
55819: LD_VAR 0 4
55823: PUSH
55824: LD_INT 1
55826: ARRAY
55827: PUSH
55828: LD_INT 1
55830: ARRAY
55831: PUSH
55832: LD_STRING r
55834: EQUAL
55835: PUSH
55836: LD_VAR 0 4
55840: PUSH
55841: LD_INT 1
55843: ARRAY
55844: PUSH
55845: LD_INT 4
55847: ARRAY
55848: PUSH
55849: LD_VAR 0 2
55853: EQUAL
55854: AND
55855: ST_TO_ADDR
// end ;
55856: LD_VAR 0 3
55860: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
55861: LD_INT 0
55863: PPUSH
// SetDir ( unit , d ) ;
55864: LD_VAR 0 1
55868: PPUSH
55869: LD_VAR 0 4
55873: PPUSH
55874: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
55878: LD_VAR 0 1
55882: PPUSH
55883: LD_VAR 0 2
55887: PPUSH
55888: LD_VAR 0 3
55892: PPUSH
55893: LD_VAR 0 5
55897: PPUSH
55898: CALL_OW 48
// end ;
55902: LD_VAR 0 6
55906: RET
// export function ToNaturalNumber ( number ) ; begin
55907: LD_INT 0
55909: PPUSH
// result := number div 1 ;
55910: LD_ADDR_VAR 0 2
55914: PUSH
55915: LD_VAR 0 1
55919: PUSH
55920: LD_INT 1
55922: DIV
55923: ST_TO_ADDR
// if number < 0 then
55924: LD_VAR 0 1
55928: PUSH
55929: LD_INT 0
55931: LESS
55932: IFFALSE 55942
// result := 0 ;
55934: LD_ADDR_VAR 0 2
55938: PUSH
55939: LD_INT 0
55941: ST_TO_ADDR
// end ;
55942: LD_VAR 0 2
55946: RET
// export function SortByClass ( units , class ) ; var un ; begin
55947: LD_INT 0
55949: PPUSH
55950: PPUSH
// if not units or not class then
55951: LD_VAR 0 1
55955: NOT
55956: PUSH
55957: LD_VAR 0 2
55961: NOT
55962: OR
55963: IFFALSE 55967
// exit ;
55965: GO 56062
// result := [ ] ;
55967: LD_ADDR_VAR 0 3
55971: PUSH
55972: EMPTY
55973: ST_TO_ADDR
// for un in units do
55974: LD_ADDR_VAR 0 4
55978: PUSH
55979: LD_VAR 0 1
55983: PUSH
55984: FOR_IN
55985: IFFALSE 56060
// if GetClass ( un ) = class then
55987: LD_VAR 0 4
55991: PPUSH
55992: CALL_OW 257
55996: PUSH
55997: LD_VAR 0 2
56001: EQUAL
56002: IFFALSE 56029
// result := Insert ( result , 1 , un ) else
56004: LD_ADDR_VAR 0 3
56008: PUSH
56009: LD_VAR 0 3
56013: PPUSH
56014: LD_INT 1
56016: PPUSH
56017: LD_VAR 0 4
56021: PPUSH
56022: CALL_OW 2
56026: ST_TO_ADDR
56027: GO 56058
// result := Replace ( result , result + 1 , un ) ;
56029: LD_ADDR_VAR 0 3
56033: PUSH
56034: LD_VAR 0 3
56038: PPUSH
56039: LD_VAR 0 3
56043: PUSH
56044: LD_INT 1
56046: PLUS
56047: PPUSH
56048: LD_VAR 0 4
56052: PPUSH
56053: CALL_OW 1
56057: ST_TO_ADDR
56058: GO 55984
56060: POP
56061: POP
// end ;
56062: LD_VAR 0 3
56066: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
56067: LD_INT 0
56069: PPUSH
56070: PPUSH
56071: PPUSH
56072: PPUSH
56073: PPUSH
56074: PPUSH
56075: PPUSH
// result := [ ] ;
56076: LD_ADDR_VAR 0 4
56080: PUSH
56081: EMPTY
56082: ST_TO_ADDR
// if x - r < 0 then
56083: LD_VAR 0 1
56087: PUSH
56088: LD_VAR 0 3
56092: MINUS
56093: PUSH
56094: LD_INT 0
56096: LESS
56097: IFFALSE 56109
// min_x := 0 else
56099: LD_ADDR_VAR 0 8
56103: PUSH
56104: LD_INT 0
56106: ST_TO_ADDR
56107: GO 56125
// min_x := x - r ;
56109: LD_ADDR_VAR 0 8
56113: PUSH
56114: LD_VAR 0 1
56118: PUSH
56119: LD_VAR 0 3
56123: MINUS
56124: ST_TO_ADDR
// if y - r < 0 then
56125: LD_VAR 0 2
56129: PUSH
56130: LD_VAR 0 3
56134: MINUS
56135: PUSH
56136: LD_INT 0
56138: LESS
56139: IFFALSE 56151
// min_y := 0 else
56141: LD_ADDR_VAR 0 7
56145: PUSH
56146: LD_INT 0
56148: ST_TO_ADDR
56149: GO 56167
// min_y := y - r ;
56151: LD_ADDR_VAR 0 7
56155: PUSH
56156: LD_VAR 0 2
56160: PUSH
56161: LD_VAR 0 3
56165: MINUS
56166: ST_TO_ADDR
// max_x := x + r ;
56167: LD_ADDR_VAR 0 9
56171: PUSH
56172: LD_VAR 0 1
56176: PUSH
56177: LD_VAR 0 3
56181: PLUS
56182: ST_TO_ADDR
// max_y := y + r ;
56183: LD_ADDR_VAR 0 10
56187: PUSH
56188: LD_VAR 0 2
56192: PUSH
56193: LD_VAR 0 3
56197: PLUS
56198: ST_TO_ADDR
// for _x = min_x to max_x do
56199: LD_ADDR_VAR 0 5
56203: PUSH
56204: DOUBLE
56205: LD_VAR 0 8
56209: DEC
56210: ST_TO_ADDR
56211: LD_VAR 0 9
56215: PUSH
56216: FOR_TO
56217: IFFALSE 56318
// for _y = min_y to max_y do
56219: LD_ADDR_VAR 0 6
56223: PUSH
56224: DOUBLE
56225: LD_VAR 0 7
56229: DEC
56230: ST_TO_ADDR
56231: LD_VAR 0 10
56235: PUSH
56236: FOR_TO
56237: IFFALSE 56314
// begin if not ValidHex ( _x , _y ) then
56239: LD_VAR 0 5
56243: PPUSH
56244: LD_VAR 0 6
56248: PPUSH
56249: CALL_OW 488
56253: NOT
56254: IFFALSE 56258
// continue ;
56256: GO 56236
// if GetResourceTypeXY ( _x , _y ) then
56258: LD_VAR 0 5
56262: PPUSH
56263: LD_VAR 0 6
56267: PPUSH
56268: CALL_OW 283
56272: IFFALSE 56312
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
56274: LD_ADDR_VAR 0 4
56278: PUSH
56279: LD_VAR 0 4
56283: PPUSH
56284: LD_VAR 0 4
56288: PUSH
56289: LD_INT 1
56291: PLUS
56292: PPUSH
56293: LD_VAR 0 5
56297: PUSH
56298: LD_VAR 0 6
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PPUSH
56307: CALL_OW 1
56311: ST_TO_ADDR
// end ;
56312: GO 56236
56314: POP
56315: POP
56316: GO 56216
56318: POP
56319: POP
// end ;
56320: LD_VAR 0 4
56324: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
56325: LD_INT 0
56327: PPUSH
56328: PPUSH
56329: PPUSH
56330: PPUSH
56331: PPUSH
56332: PPUSH
56333: PPUSH
56334: PPUSH
// if not units then
56335: LD_VAR 0 1
56339: NOT
56340: IFFALSE 56344
// exit ;
56342: GO 56868
// result := UnitFilter ( units , [ f_ok ] ) ;
56344: LD_ADDR_VAR 0 3
56348: PUSH
56349: LD_VAR 0 1
56353: PPUSH
56354: LD_INT 50
56356: PUSH
56357: EMPTY
56358: LIST
56359: PPUSH
56360: CALL_OW 72
56364: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
56365: LD_ADDR_VAR 0 8
56369: PUSH
56370: LD_VAR 0 1
56374: PUSH
56375: LD_INT 1
56377: ARRAY
56378: PPUSH
56379: CALL_OW 255
56383: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
56384: LD_ADDR_VAR 0 10
56388: PUSH
56389: LD_INT 29
56391: PUSH
56392: LD_INT 91
56394: PUSH
56395: LD_INT 49
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: LIST
56402: ST_TO_ADDR
// if not result then
56403: LD_VAR 0 3
56407: NOT
56408: IFFALSE 56412
// exit ;
56410: GO 56868
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
56412: LD_ADDR_VAR 0 5
56416: PUSH
56417: LD_INT 81
56419: PUSH
56420: LD_VAR 0 8
56424: PUSH
56425: EMPTY
56426: LIST
56427: LIST
56428: PPUSH
56429: CALL_OW 69
56433: ST_TO_ADDR
// for i in result do
56434: LD_ADDR_VAR 0 4
56438: PUSH
56439: LD_VAR 0 3
56443: PUSH
56444: FOR_IN
56445: IFFALSE 56866
// begin tag := GetTag ( i ) + 1 ;
56447: LD_ADDR_VAR 0 9
56451: PUSH
56452: LD_VAR 0 4
56456: PPUSH
56457: CALL_OW 110
56461: PUSH
56462: LD_INT 1
56464: PLUS
56465: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
56466: LD_ADDR_VAR 0 7
56470: PUSH
56471: LD_VAR 0 4
56475: PPUSH
56476: CALL_OW 250
56480: PPUSH
56481: LD_VAR 0 4
56485: PPUSH
56486: CALL_OW 251
56490: PPUSH
56491: LD_INT 6
56493: PPUSH
56494: CALL 56067 0 3
56498: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
56499: LD_VAR 0 4
56503: PPUSH
56504: CALL_OW 247
56508: PUSH
56509: LD_INT 2
56511: EQUAL
56512: PUSH
56513: LD_VAR 0 7
56517: AND
56518: PUSH
56519: LD_VAR 0 4
56523: PPUSH
56524: CALL_OW 264
56528: PUSH
56529: LD_VAR 0 10
56533: IN
56534: NOT
56535: AND
56536: IFFALSE 56575
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
56538: LD_VAR 0 4
56542: PPUSH
56543: LD_VAR 0 7
56547: PUSH
56548: LD_INT 1
56550: ARRAY
56551: PUSH
56552: LD_INT 1
56554: ARRAY
56555: PPUSH
56556: LD_VAR 0 7
56560: PUSH
56561: LD_INT 1
56563: ARRAY
56564: PUSH
56565: LD_INT 2
56567: ARRAY
56568: PPUSH
56569: CALL_OW 116
56573: GO 56864
// if path > tag then
56575: LD_VAR 0 2
56579: PUSH
56580: LD_VAR 0 9
56584: GREATER
56585: IFFALSE 56793
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
56587: LD_ADDR_VAR 0 6
56591: PUSH
56592: LD_VAR 0 5
56596: PPUSH
56597: LD_INT 91
56599: PUSH
56600: LD_VAR 0 4
56604: PUSH
56605: LD_INT 8
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: LIST
56612: PPUSH
56613: CALL_OW 72
56617: ST_TO_ADDR
// if nearEnemy then
56618: LD_VAR 0 6
56622: IFFALSE 56691
// begin if GetWeapon ( i ) = ru_time_lapser then
56624: LD_VAR 0 4
56628: PPUSH
56629: CALL_OW 264
56633: PUSH
56634: LD_INT 49
56636: EQUAL
56637: IFFALSE 56665
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
56639: LD_VAR 0 4
56643: PPUSH
56644: LD_VAR 0 6
56648: PPUSH
56649: LD_VAR 0 4
56653: PPUSH
56654: CALL_OW 74
56658: PPUSH
56659: CALL_OW 112
56663: GO 56689
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
56665: LD_VAR 0 4
56669: PPUSH
56670: LD_VAR 0 6
56674: PPUSH
56675: LD_VAR 0 4
56679: PPUSH
56680: CALL_OW 74
56684: PPUSH
56685: CALL 57793 0 2
// end else
56689: GO 56791
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
56691: LD_VAR 0 4
56695: PPUSH
56696: LD_VAR 0 2
56700: PUSH
56701: LD_VAR 0 9
56705: ARRAY
56706: PUSH
56707: LD_INT 1
56709: ARRAY
56710: PPUSH
56711: LD_VAR 0 2
56715: PUSH
56716: LD_VAR 0 9
56720: ARRAY
56721: PUSH
56722: LD_INT 2
56724: ARRAY
56725: PPUSH
56726: CALL_OW 297
56730: PUSH
56731: LD_INT 6
56733: GREATER
56734: IFFALSE 56777
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
56736: LD_VAR 0 4
56740: PPUSH
56741: LD_VAR 0 2
56745: PUSH
56746: LD_VAR 0 9
56750: ARRAY
56751: PUSH
56752: LD_INT 1
56754: ARRAY
56755: PPUSH
56756: LD_VAR 0 2
56760: PUSH
56761: LD_VAR 0 9
56765: ARRAY
56766: PUSH
56767: LD_INT 2
56769: ARRAY
56770: PPUSH
56771: CALL_OW 114
56775: GO 56791
// SetTag ( i , tag ) ;
56777: LD_VAR 0 4
56781: PPUSH
56782: LD_VAR 0 9
56786: PPUSH
56787: CALL_OW 109
// end else
56791: GO 56864
// if enemy then
56793: LD_VAR 0 5
56797: IFFALSE 56864
// begin if GetWeapon ( i ) = ru_time_lapser then
56799: LD_VAR 0 4
56803: PPUSH
56804: CALL_OW 264
56808: PUSH
56809: LD_INT 49
56811: EQUAL
56812: IFFALSE 56840
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
56814: LD_VAR 0 4
56818: PPUSH
56819: LD_VAR 0 5
56823: PPUSH
56824: LD_VAR 0 4
56828: PPUSH
56829: CALL_OW 74
56833: PPUSH
56834: CALL_OW 112
56838: GO 56864
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
56840: LD_VAR 0 4
56844: PPUSH
56845: LD_VAR 0 5
56849: PPUSH
56850: LD_VAR 0 4
56854: PPUSH
56855: CALL_OW 74
56859: PPUSH
56860: CALL 57793 0 2
// end ; end ;
56864: GO 56444
56866: POP
56867: POP
// end ;
56868: LD_VAR 0 3
56872: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
56873: LD_INT 0
56875: PPUSH
56876: PPUSH
56877: PPUSH
// if not unit or IsInUnit ( unit ) then
56878: LD_VAR 0 1
56882: NOT
56883: PUSH
56884: LD_VAR 0 1
56888: PPUSH
56889: CALL_OW 310
56893: OR
56894: IFFALSE 56898
// exit ;
56896: GO 56989
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
56898: LD_ADDR_VAR 0 4
56902: PUSH
56903: LD_VAR 0 1
56907: PPUSH
56908: CALL_OW 250
56912: PPUSH
56913: LD_VAR 0 2
56917: PPUSH
56918: LD_INT 1
56920: PPUSH
56921: CALL_OW 272
56925: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
56926: LD_ADDR_VAR 0 5
56930: PUSH
56931: LD_VAR 0 1
56935: PPUSH
56936: CALL_OW 251
56940: PPUSH
56941: LD_VAR 0 2
56945: PPUSH
56946: LD_INT 1
56948: PPUSH
56949: CALL_OW 273
56953: ST_TO_ADDR
// if ValidHex ( x , y ) then
56954: LD_VAR 0 4
56958: PPUSH
56959: LD_VAR 0 5
56963: PPUSH
56964: CALL_OW 488
56968: IFFALSE 56989
// ComTurnXY ( unit , x , y ) ;
56970: LD_VAR 0 1
56974: PPUSH
56975: LD_VAR 0 4
56979: PPUSH
56980: LD_VAR 0 5
56984: PPUSH
56985: CALL_OW 118
// end ;
56989: LD_VAR 0 3
56993: RET
// export function SeeUnits ( side , units ) ; var i ; begin
56994: LD_INT 0
56996: PPUSH
56997: PPUSH
// result := false ;
56998: LD_ADDR_VAR 0 3
57002: PUSH
57003: LD_INT 0
57005: ST_TO_ADDR
// if not units then
57006: LD_VAR 0 2
57010: NOT
57011: IFFALSE 57015
// exit ;
57013: GO 57060
// for i in units do
57015: LD_ADDR_VAR 0 4
57019: PUSH
57020: LD_VAR 0 2
57024: PUSH
57025: FOR_IN
57026: IFFALSE 57058
// if See ( side , i ) then
57028: LD_VAR 0 1
57032: PPUSH
57033: LD_VAR 0 4
57037: PPUSH
57038: CALL_OW 292
57042: IFFALSE 57056
// begin result := true ;
57044: LD_ADDR_VAR 0 3
57048: PUSH
57049: LD_INT 1
57051: ST_TO_ADDR
// exit ;
57052: POP
57053: POP
57054: GO 57060
// end ;
57056: GO 57025
57058: POP
57059: POP
// end ;
57060: LD_VAR 0 3
57064: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
57065: LD_INT 0
57067: PPUSH
57068: PPUSH
57069: PPUSH
57070: PPUSH
// if not unit or not points then
57071: LD_VAR 0 1
57075: NOT
57076: PUSH
57077: LD_VAR 0 2
57081: NOT
57082: OR
57083: IFFALSE 57087
// exit ;
57085: GO 57177
// dist := 99999 ;
57087: LD_ADDR_VAR 0 5
57091: PUSH
57092: LD_INT 99999
57094: ST_TO_ADDR
// for i in points do
57095: LD_ADDR_VAR 0 4
57099: PUSH
57100: LD_VAR 0 2
57104: PUSH
57105: FOR_IN
57106: IFFALSE 57175
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
57108: LD_ADDR_VAR 0 6
57112: PUSH
57113: LD_VAR 0 1
57117: PPUSH
57118: LD_VAR 0 4
57122: PUSH
57123: LD_INT 1
57125: ARRAY
57126: PPUSH
57127: LD_VAR 0 4
57131: PUSH
57132: LD_INT 2
57134: ARRAY
57135: PPUSH
57136: CALL_OW 297
57140: ST_TO_ADDR
// if tmpDist < dist then
57141: LD_VAR 0 6
57145: PUSH
57146: LD_VAR 0 5
57150: LESS
57151: IFFALSE 57173
// begin result := i ;
57153: LD_ADDR_VAR 0 3
57157: PUSH
57158: LD_VAR 0 4
57162: ST_TO_ADDR
// dist := tmpDist ;
57163: LD_ADDR_VAR 0 5
57167: PUSH
57168: LD_VAR 0 6
57172: ST_TO_ADDR
// end ; end ;
57173: GO 57105
57175: POP
57176: POP
// end ;
57177: LD_VAR 0 3
57181: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
57182: LD_INT 0
57184: PPUSH
// uc_side := side ;
57185: LD_ADDR_OWVAR 20
57189: PUSH
57190: LD_VAR 0 1
57194: ST_TO_ADDR
// uc_nation := 3 ;
57195: LD_ADDR_OWVAR 21
57199: PUSH
57200: LD_INT 3
57202: ST_TO_ADDR
// vc_chassis := 25 ;
57203: LD_ADDR_OWVAR 37
57207: PUSH
57208: LD_INT 25
57210: ST_TO_ADDR
// vc_engine := engine_siberite ;
57211: LD_ADDR_OWVAR 39
57215: PUSH
57216: LD_INT 3
57218: ST_TO_ADDR
// vc_control := control_computer ;
57219: LD_ADDR_OWVAR 38
57223: PUSH
57224: LD_INT 3
57226: ST_TO_ADDR
// vc_weapon := 59 ;
57227: LD_ADDR_OWVAR 40
57231: PUSH
57232: LD_INT 59
57234: ST_TO_ADDR
// result := CreateVehicle ;
57235: LD_ADDR_VAR 0 5
57239: PUSH
57240: CALL_OW 45
57244: ST_TO_ADDR
// SetDir ( result , d ) ;
57245: LD_VAR 0 5
57249: PPUSH
57250: LD_VAR 0 4
57254: PPUSH
57255: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
57259: LD_VAR 0 5
57263: PPUSH
57264: LD_VAR 0 2
57268: PPUSH
57269: LD_VAR 0 3
57273: PPUSH
57274: LD_INT 0
57276: PPUSH
57277: CALL_OW 48
// end ;
57281: LD_VAR 0 5
57285: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
57286: LD_INT 0
57288: PPUSH
57289: PPUSH
57290: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57291: LD_ADDR_VAR 0 2
57295: PUSH
57296: LD_INT 0
57298: PUSH
57299: LD_INT 0
57301: PUSH
57302: LD_INT 0
57304: PUSH
57305: LD_INT 0
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: LIST
57312: LIST
57313: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
57314: LD_VAR 0 1
57318: NOT
57319: PUSH
57320: LD_VAR 0 1
57324: PPUSH
57325: CALL_OW 264
57329: PUSH
57330: LD_INT 12
57332: PUSH
57333: LD_INT 51
57335: PUSH
57336: LD_INT 32
57338: PUSH
57339: LD_INT 89
57341: PUSH
57342: EMPTY
57343: LIST
57344: LIST
57345: LIST
57346: LIST
57347: IN
57348: NOT
57349: OR
57350: IFFALSE 57354
// exit ;
57352: GO 57452
// for i := 1 to 3 do
57354: LD_ADDR_VAR 0 3
57358: PUSH
57359: DOUBLE
57360: LD_INT 1
57362: DEC
57363: ST_TO_ADDR
57364: LD_INT 3
57366: PUSH
57367: FOR_TO
57368: IFFALSE 57450
// begin tmp := GetCargo ( cargo , i ) ;
57370: LD_ADDR_VAR 0 4
57374: PUSH
57375: LD_VAR 0 1
57379: PPUSH
57380: LD_VAR 0 3
57384: PPUSH
57385: CALL_OW 289
57389: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
57390: LD_ADDR_VAR 0 2
57394: PUSH
57395: LD_VAR 0 2
57399: PPUSH
57400: LD_VAR 0 3
57404: PPUSH
57405: LD_VAR 0 4
57409: PPUSH
57410: CALL_OW 1
57414: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
57415: LD_ADDR_VAR 0 2
57419: PUSH
57420: LD_VAR 0 2
57424: PPUSH
57425: LD_INT 4
57427: PPUSH
57428: LD_VAR 0 2
57432: PUSH
57433: LD_INT 4
57435: ARRAY
57436: PUSH
57437: LD_VAR 0 4
57441: PLUS
57442: PPUSH
57443: CALL_OW 1
57447: ST_TO_ADDR
// end ;
57448: GO 57367
57450: POP
57451: POP
// end ;
57452: LD_VAR 0 2
57456: RET
// export function Length ( array ) ; begin
57457: LD_INT 0
57459: PPUSH
// result := array + 0 ;
57460: LD_ADDR_VAR 0 2
57464: PUSH
57465: LD_VAR 0 1
57469: PUSH
57470: LD_INT 0
57472: PLUS
57473: ST_TO_ADDR
// end ;
57474: LD_VAR 0 2
57478: RET
// export function PrepareArray ( array ) ; begin
57479: LD_INT 0
57481: PPUSH
// result := array diff 0 ;
57482: LD_ADDR_VAR 0 2
57486: PUSH
57487: LD_VAR 0 1
57491: PUSH
57492: LD_INT 0
57494: DIFF
57495: ST_TO_ADDR
// if not result [ 1 ] then
57496: LD_VAR 0 2
57500: PUSH
57501: LD_INT 1
57503: ARRAY
57504: NOT
57505: IFFALSE 57525
// result := Delete ( result , 1 ) ;
57507: LD_ADDR_VAR 0 2
57511: PUSH
57512: LD_VAR 0 2
57516: PPUSH
57517: LD_INT 1
57519: PPUSH
57520: CALL_OW 3
57524: ST_TO_ADDR
// end ;
57525: LD_VAR 0 2
57529: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
57530: LD_INT 0
57532: PPUSH
57533: PPUSH
57534: PPUSH
57535: PPUSH
// sibRocketRange := 25 ;
57536: LD_ADDR_VAR 0 6
57540: PUSH
57541: LD_INT 25
57543: ST_TO_ADDR
// result := false ;
57544: LD_ADDR_VAR 0 4
57548: PUSH
57549: LD_INT 0
57551: ST_TO_ADDR
// for i := 0 to 5 do
57552: LD_ADDR_VAR 0 5
57556: PUSH
57557: DOUBLE
57558: LD_INT 0
57560: DEC
57561: ST_TO_ADDR
57562: LD_INT 5
57564: PUSH
57565: FOR_TO
57566: IFFALSE 57633
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
57568: LD_VAR 0 1
57572: PPUSH
57573: LD_VAR 0 5
57577: PPUSH
57578: LD_VAR 0 6
57582: PPUSH
57583: CALL_OW 272
57587: PPUSH
57588: LD_VAR 0 2
57592: PPUSH
57593: LD_VAR 0 5
57597: PPUSH
57598: LD_VAR 0 6
57602: PPUSH
57603: CALL_OW 273
57607: PPUSH
57608: LD_VAR 0 3
57612: PPUSH
57613: CALL_OW 309
57617: IFFALSE 57631
// begin result := true ;
57619: LD_ADDR_VAR 0 4
57623: PUSH
57624: LD_INT 1
57626: ST_TO_ADDR
// exit ;
57627: POP
57628: POP
57629: GO 57635
// end ;
57631: GO 57565
57633: POP
57634: POP
// end ;
57635: LD_VAR 0 4
57639: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
57640: LD_INT 0
57642: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
57643: LD_VAR 0 1
57647: PPUSH
57648: LD_VAR 0 2
57652: PPUSH
57653: LD_INT 0
57655: PPUSH
57656: LD_INT 0
57658: PPUSH
57659: LD_INT 1
57661: PPUSH
57662: LD_INT 0
57664: PPUSH
57665: CALL_OW 587
// end ;
57669: LD_VAR 0 3
57673: RET
// export function CenterOnNow ( unit ) ; begin
57674: LD_INT 0
57676: PPUSH
// result := IsInUnit ( unit ) ;
57677: LD_ADDR_VAR 0 2
57681: PUSH
57682: LD_VAR 0 1
57686: PPUSH
57687: CALL_OW 310
57691: ST_TO_ADDR
// if not result then
57692: LD_VAR 0 2
57696: NOT
57697: IFFALSE 57709
// result := unit ;
57699: LD_ADDR_VAR 0 2
57703: PUSH
57704: LD_VAR 0 1
57708: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
57709: LD_VAR 0 1
57713: PPUSH
57714: CALL_OW 87
// end ;
57718: LD_VAR 0 2
57722: RET
// export function ComMoveHex ( unit , hex ) ; begin
57723: LD_INT 0
57725: PPUSH
// if not hex then
57726: LD_VAR 0 2
57730: NOT
57731: IFFALSE 57735
// exit ;
57733: GO 57788
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
57735: LD_VAR 0 2
57739: PUSH
57740: LD_INT 1
57742: ARRAY
57743: PPUSH
57744: LD_VAR 0 2
57748: PUSH
57749: LD_INT 2
57751: ARRAY
57752: PPUSH
57753: CALL_OW 428
57757: IFFALSE 57761
// exit ;
57759: GO 57788
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
57761: LD_VAR 0 1
57765: PPUSH
57766: LD_VAR 0 2
57770: PUSH
57771: LD_INT 1
57773: ARRAY
57774: PPUSH
57775: LD_VAR 0 2
57779: PUSH
57780: LD_INT 2
57782: ARRAY
57783: PPUSH
57784: CALL_OW 111
// end ;
57788: LD_VAR 0 3
57792: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
57793: LD_INT 0
57795: PPUSH
57796: PPUSH
57797: PPUSH
// if not unit or not enemy then
57798: LD_VAR 0 1
57802: NOT
57803: PUSH
57804: LD_VAR 0 2
57808: NOT
57809: OR
57810: IFFALSE 57814
// exit ;
57812: GO 57938
// x := GetX ( enemy ) ;
57814: LD_ADDR_VAR 0 4
57818: PUSH
57819: LD_VAR 0 2
57823: PPUSH
57824: CALL_OW 250
57828: ST_TO_ADDR
// y := GetY ( enemy ) ;
57829: LD_ADDR_VAR 0 5
57833: PUSH
57834: LD_VAR 0 2
57838: PPUSH
57839: CALL_OW 251
57843: ST_TO_ADDR
// if ValidHex ( x , y ) then
57844: LD_VAR 0 4
57848: PPUSH
57849: LD_VAR 0 5
57853: PPUSH
57854: CALL_OW 488
57858: IFFALSE 57938
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
57860: LD_VAR 0 2
57864: PPUSH
57865: CALL_OW 247
57869: PUSH
57870: LD_INT 3
57872: PUSH
57873: LD_INT 2
57875: PUSH
57876: EMPTY
57877: LIST
57878: LIST
57879: IN
57880: PUSH
57881: LD_VAR 0 1
57885: PPUSH
57886: CALL_OW 255
57890: PPUSH
57891: LD_VAR 0 2
57895: PPUSH
57896: CALL_OW 292
57900: AND
57901: IFFALSE 57919
// ComAttackUnit ( unit , enemy ) else
57903: LD_VAR 0 1
57907: PPUSH
57908: LD_VAR 0 2
57912: PPUSH
57913: CALL_OW 115
57917: GO 57938
// ComAgressiveMove ( unit , x , y ) ;
57919: LD_VAR 0 1
57923: PPUSH
57924: LD_VAR 0 4
57928: PPUSH
57929: LD_VAR 0 5
57933: PPUSH
57934: CALL_OW 114
// end ;
57938: LD_VAR 0 3
57942: RET
// function GetSourcesFromArea ( area , all ) ; var i , list ; begin
57943: LD_INT 0
57945: PPUSH
57946: PPUSH
57947: PPUSH
// list := AreaToList ( area , 0 ) ;
57948: LD_ADDR_VAR 0 5
57952: PUSH
57953: LD_VAR 0 1
57957: PPUSH
57958: LD_INT 0
57960: PPUSH
57961: CALL_OW 517
57965: ST_TO_ADDR
// if not list then
57966: LD_VAR 0 5
57970: NOT
57971: IFFALSE 57975
// exit ;
57973: GO 58102
// if all then
57975: LD_VAR 0 2
57979: IFFALSE 58067
// begin for i := 1 to list [ 1 ] do
57981: LD_ADDR_VAR 0 4
57985: PUSH
57986: DOUBLE
57987: LD_INT 1
57989: DEC
57990: ST_TO_ADDR
57991: LD_VAR 0 5
57995: PUSH
57996: LD_INT 1
57998: ARRAY
57999: PUSH
58000: FOR_TO
58001: IFFALSE 58063
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
58003: LD_ADDR_VAR 0 3
58007: PUSH
58008: LD_VAR 0 3
58012: PPUSH
58013: LD_VAR 0 3
58017: PUSH
58018: LD_INT 1
58020: PLUS
58021: PPUSH
58022: LD_VAR 0 5
58026: PUSH
58027: LD_INT 1
58029: ARRAY
58030: PUSH
58031: LD_VAR 0 4
58035: ARRAY
58036: PUSH
58037: LD_VAR 0 5
58041: PUSH
58042: LD_INT 2
58044: ARRAY
58045: PUSH
58046: LD_VAR 0 4
58050: ARRAY
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
58061: GO 58000
58063: POP
58064: POP
// exit ;
58065: GO 58102
// end ; result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ;
58067: LD_ADDR_VAR 0 3
58071: PUSH
58072: LD_VAR 0 5
58076: PUSH
58077: LD_INT 1
58079: ARRAY
58080: PUSH
58081: LD_INT 1
58083: ARRAY
58084: PUSH
58085: LD_VAR 0 5
58089: PUSH
58090: LD_INT 2
58092: ARRAY
58093: PUSH
58094: LD_INT 1
58096: ARRAY
58097: PUSH
58098: EMPTY
58099: LIST
58100: LIST
58101: ST_TO_ADDR
// end ;
58102: LD_VAR 0 3
58106: RET
// function GetBuildingFromArea ( area , direction ) ; var list ; begin
58107: LD_INT 0
58109: PPUSH
58110: PPUSH
// list := AreaToList ( area , 0 ) ;
58111: LD_ADDR_VAR 0 4
58115: PUSH
58116: LD_VAR 0 1
58120: PPUSH
58121: LD_INT 0
58123: PPUSH
58124: CALL_OW 517
58128: ST_TO_ADDR
// if not list then
58129: LD_VAR 0 4
58133: NOT
58134: IFFALSE 58138
// exit ;
58136: GO 58179
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
58138: LD_ADDR_VAR 0 3
58142: PUSH
58143: LD_VAR 0 4
58147: PUSH
58148: LD_INT 1
58150: ARRAY
58151: PUSH
58152: LD_INT 1
58154: ARRAY
58155: PUSH
58156: LD_VAR 0 4
58160: PUSH
58161: LD_INT 2
58163: ARRAY
58164: PUSH
58165: LD_INT 1
58167: ARRAY
58168: PUSH
58169: LD_VAR 0 2
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: LIST
58178: ST_TO_ADDR
// end ; end_of_file
58179: LD_VAR 0 3
58183: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
58184: LD_INT 0
58186: PPUSH
58187: PPUSH
// skirmish := false ;
58188: LD_ADDR_EXP 59
58192: PUSH
58193: LD_INT 0
58195: ST_TO_ADDR
// debug_mc := false ;
58196: LD_ADDR_EXP 60
58200: PUSH
58201: LD_INT 0
58203: ST_TO_ADDR
// mc_bases := [ ] ;
58204: LD_ADDR_EXP 61
58208: PUSH
58209: EMPTY
58210: ST_TO_ADDR
// mc_sides := [ ] ;
58211: LD_ADDR_EXP 87
58215: PUSH
58216: EMPTY
58217: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
58218: LD_ADDR_EXP 62
58222: PUSH
58223: EMPTY
58224: ST_TO_ADDR
// mc_building_repairs := [ ] ;
58225: LD_ADDR_EXP 63
58229: PUSH
58230: EMPTY
58231: ST_TO_ADDR
// mc_need_heal := [ ] ;
58232: LD_ADDR_EXP 64
58236: PUSH
58237: EMPTY
58238: ST_TO_ADDR
// mc_healers := [ ] ;
58239: LD_ADDR_EXP 65
58243: PUSH
58244: EMPTY
58245: ST_TO_ADDR
// mc_build_list := [ ] ;
58246: LD_ADDR_EXP 66
58250: PUSH
58251: EMPTY
58252: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
58253: LD_ADDR_EXP 93
58257: PUSH
58258: EMPTY
58259: ST_TO_ADDR
// mc_builders := [ ] ;
58260: LD_ADDR_EXP 67
58264: PUSH
58265: EMPTY
58266: ST_TO_ADDR
// mc_construct_list := [ ] ;
58267: LD_ADDR_EXP 68
58271: PUSH
58272: EMPTY
58273: ST_TO_ADDR
// mc_turret_list := [ ] ;
58274: LD_ADDR_EXP 69
58278: PUSH
58279: EMPTY
58280: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
58281: LD_ADDR_EXP 70
58285: PUSH
58286: EMPTY
58287: ST_TO_ADDR
// mc_miners := [ ] ;
58288: LD_ADDR_EXP 75
58292: PUSH
58293: EMPTY
58294: ST_TO_ADDR
// mc_mines := [ ] ;
58295: LD_ADDR_EXP 74
58299: PUSH
58300: EMPTY
58301: ST_TO_ADDR
// mc_minefields := [ ] ;
58302: LD_ADDR_EXP 76
58306: PUSH
58307: EMPTY
58308: ST_TO_ADDR
// mc_crates := [ ] ;
58309: LD_ADDR_EXP 77
58313: PUSH
58314: EMPTY
58315: ST_TO_ADDR
// mc_crates_collector := [ ] ;
58316: LD_ADDR_EXP 78
58320: PUSH
58321: EMPTY
58322: ST_TO_ADDR
// mc_crates_area := [ ] ;
58323: LD_ADDR_EXP 79
58327: PUSH
58328: EMPTY
58329: ST_TO_ADDR
// mc_vehicles := [ ] ;
58330: LD_ADDR_EXP 80
58334: PUSH
58335: EMPTY
58336: ST_TO_ADDR
// mc_attack := [ ] ;
58337: LD_ADDR_EXP 81
58341: PUSH
58342: EMPTY
58343: ST_TO_ADDR
// mc_produce := [ ] ;
58344: LD_ADDR_EXP 82
58348: PUSH
58349: EMPTY
58350: ST_TO_ADDR
// mc_defender := [ ] ;
58351: LD_ADDR_EXP 83
58355: PUSH
58356: EMPTY
58357: ST_TO_ADDR
// mc_parking := [ ] ;
58358: LD_ADDR_EXP 85
58362: PUSH
58363: EMPTY
58364: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
58365: LD_ADDR_EXP 71
58369: PUSH
58370: EMPTY
58371: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
58372: LD_ADDR_EXP 73
58376: PUSH
58377: EMPTY
58378: ST_TO_ADDR
// mc_scan := [ ] ;
58379: LD_ADDR_EXP 84
58383: PUSH
58384: EMPTY
58385: ST_TO_ADDR
// mc_scan_area := [ ] ;
58386: LD_ADDR_EXP 86
58390: PUSH
58391: EMPTY
58392: ST_TO_ADDR
// mc_tech := [ ] ;
58393: LD_ADDR_EXP 88
58397: PUSH
58398: EMPTY
58399: ST_TO_ADDR
// mc_class := [ ] ;
58400: LD_ADDR_EXP 102
58404: PUSH
58405: EMPTY
58406: ST_TO_ADDR
// mc_class_case_use := [ ] ;
58407: LD_ADDR_EXP 103
58411: PUSH
58412: EMPTY
58413: ST_TO_ADDR
// mc_is_defending := [ ] ;
58414: LD_ADDR_EXP 104
58418: PUSH
58419: EMPTY
58420: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
58421: LD_ADDR_EXP 95
58425: PUSH
58426: EMPTY
58427: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
58428: LD_ADDR_EXP 105
58432: PUSH
58433: LD_INT 0
58435: ST_TO_ADDR
// end ;
58436: LD_VAR 0 1
58440: RET
// export function MC_Kill ( base ) ; begin
58441: LD_INT 0
58443: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
58444: LD_ADDR_EXP 61
58448: PUSH
58449: LD_EXP 61
58453: PPUSH
58454: LD_VAR 0 1
58458: PPUSH
58459: EMPTY
58460: PPUSH
58461: CALL_OW 1
58465: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58466: LD_ADDR_EXP 62
58470: PUSH
58471: LD_EXP 62
58475: PPUSH
58476: LD_VAR 0 1
58480: PPUSH
58481: EMPTY
58482: PPUSH
58483: CALL_OW 1
58487: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58488: LD_ADDR_EXP 63
58492: PUSH
58493: LD_EXP 63
58497: PPUSH
58498: LD_VAR 0 1
58502: PPUSH
58503: EMPTY
58504: PPUSH
58505: CALL_OW 1
58509: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58510: LD_ADDR_EXP 64
58514: PUSH
58515: LD_EXP 64
58519: PPUSH
58520: LD_VAR 0 1
58524: PPUSH
58525: EMPTY
58526: PPUSH
58527: CALL_OW 1
58531: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58532: LD_ADDR_EXP 65
58536: PUSH
58537: LD_EXP 65
58541: PPUSH
58542: LD_VAR 0 1
58546: PPUSH
58547: EMPTY
58548: PPUSH
58549: CALL_OW 1
58553: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58554: LD_ADDR_EXP 66
58558: PUSH
58559: LD_EXP 66
58563: PPUSH
58564: LD_VAR 0 1
58568: PPUSH
58569: EMPTY
58570: PPUSH
58571: CALL_OW 1
58575: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58576: LD_ADDR_EXP 67
58580: PUSH
58581: LD_EXP 67
58585: PPUSH
58586: LD_VAR 0 1
58590: PPUSH
58591: EMPTY
58592: PPUSH
58593: CALL_OW 1
58597: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58598: LD_ADDR_EXP 68
58602: PUSH
58603: LD_EXP 68
58607: PPUSH
58608: LD_VAR 0 1
58612: PPUSH
58613: EMPTY
58614: PPUSH
58615: CALL_OW 1
58619: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58620: LD_ADDR_EXP 69
58624: PUSH
58625: LD_EXP 69
58629: PPUSH
58630: LD_VAR 0 1
58634: PPUSH
58635: EMPTY
58636: PPUSH
58637: CALL_OW 1
58641: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58642: LD_ADDR_EXP 70
58646: PUSH
58647: LD_EXP 70
58651: PPUSH
58652: LD_VAR 0 1
58656: PPUSH
58657: EMPTY
58658: PPUSH
58659: CALL_OW 1
58663: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58664: LD_ADDR_EXP 71
58668: PUSH
58669: LD_EXP 71
58673: PPUSH
58674: LD_VAR 0 1
58678: PPUSH
58679: EMPTY
58680: PPUSH
58681: CALL_OW 1
58685: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58686: LD_ADDR_EXP 72
58690: PUSH
58691: LD_EXP 72
58695: PPUSH
58696: LD_VAR 0 1
58700: PPUSH
58701: LD_INT 0
58703: PPUSH
58704: CALL_OW 1
58708: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58709: LD_ADDR_EXP 73
58713: PUSH
58714: LD_EXP 73
58718: PPUSH
58719: LD_VAR 0 1
58723: PPUSH
58724: EMPTY
58725: PPUSH
58726: CALL_OW 1
58730: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58731: LD_ADDR_EXP 74
58735: PUSH
58736: LD_EXP 74
58740: PPUSH
58741: LD_VAR 0 1
58745: PPUSH
58746: EMPTY
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58753: LD_ADDR_EXP 75
58757: PUSH
58758: LD_EXP 75
58762: PPUSH
58763: LD_VAR 0 1
58767: PPUSH
58768: EMPTY
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58775: LD_ADDR_EXP 76
58779: PUSH
58780: LD_EXP 76
58784: PPUSH
58785: LD_VAR 0 1
58789: PPUSH
58790: EMPTY
58791: PPUSH
58792: CALL_OW 1
58796: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58797: LD_ADDR_EXP 77
58801: PUSH
58802: LD_EXP 77
58806: PPUSH
58807: LD_VAR 0 1
58811: PPUSH
58812: EMPTY
58813: PPUSH
58814: CALL_OW 1
58818: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58819: LD_ADDR_EXP 78
58823: PUSH
58824: LD_EXP 78
58828: PPUSH
58829: LD_VAR 0 1
58833: PPUSH
58834: EMPTY
58835: PPUSH
58836: CALL_OW 1
58840: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58841: LD_ADDR_EXP 79
58845: PUSH
58846: LD_EXP 79
58850: PPUSH
58851: LD_VAR 0 1
58855: PPUSH
58856: EMPTY
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58863: LD_ADDR_EXP 80
58867: PUSH
58868: LD_EXP 80
58872: PPUSH
58873: LD_VAR 0 1
58877: PPUSH
58878: EMPTY
58879: PPUSH
58880: CALL_OW 1
58884: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58885: LD_ADDR_EXP 81
58889: PUSH
58890: LD_EXP 81
58894: PPUSH
58895: LD_VAR 0 1
58899: PPUSH
58900: EMPTY
58901: PPUSH
58902: CALL_OW 1
58906: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58907: LD_ADDR_EXP 82
58911: PUSH
58912: LD_EXP 82
58916: PPUSH
58917: LD_VAR 0 1
58921: PPUSH
58922: EMPTY
58923: PPUSH
58924: CALL_OW 1
58928: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58929: LD_ADDR_EXP 83
58933: PUSH
58934: LD_EXP 83
58938: PPUSH
58939: LD_VAR 0 1
58943: PPUSH
58944: EMPTY
58945: PPUSH
58946: CALL_OW 1
58950: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58951: LD_ADDR_EXP 84
58955: PUSH
58956: LD_EXP 84
58960: PPUSH
58961: LD_VAR 0 1
58965: PPUSH
58966: EMPTY
58967: PPUSH
58968: CALL_OW 1
58972: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58973: LD_ADDR_EXP 85
58977: PUSH
58978: LD_EXP 85
58982: PPUSH
58983: LD_VAR 0 1
58987: PPUSH
58988: EMPTY
58989: PPUSH
58990: CALL_OW 1
58994: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58995: LD_ADDR_EXP 86
58999: PUSH
59000: LD_EXP 86
59004: PPUSH
59005: LD_VAR 0 1
59009: PPUSH
59010: EMPTY
59011: PPUSH
59012: CALL_OW 1
59016: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59017: LD_ADDR_EXP 88
59021: PUSH
59022: LD_EXP 88
59026: PPUSH
59027: LD_VAR 0 1
59031: PPUSH
59032: EMPTY
59033: PPUSH
59034: CALL_OW 1
59038: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
59039: LD_ADDR_EXP 90
59043: PUSH
59044: LD_EXP 90
59048: PPUSH
59049: LD_VAR 0 1
59053: PPUSH
59054: EMPTY
59055: PPUSH
59056: CALL_OW 1
59060: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59061: LD_ADDR_EXP 91
59065: PUSH
59066: LD_EXP 91
59070: PPUSH
59071: LD_VAR 0 1
59075: PPUSH
59076: EMPTY
59077: PPUSH
59078: CALL_OW 1
59082: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59083: LD_ADDR_EXP 92
59087: PUSH
59088: LD_EXP 92
59092: PPUSH
59093: LD_VAR 0 1
59097: PPUSH
59098: EMPTY
59099: PPUSH
59100: CALL_OW 1
59104: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59105: LD_ADDR_EXP 93
59109: PUSH
59110: LD_EXP 93
59114: PPUSH
59115: LD_VAR 0 1
59119: PPUSH
59120: EMPTY
59121: PPUSH
59122: CALL_OW 1
59126: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59127: LD_ADDR_EXP 94
59131: PUSH
59132: LD_EXP 94
59136: PPUSH
59137: LD_VAR 0 1
59141: PPUSH
59142: EMPTY
59143: PPUSH
59144: CALL_OW 1
59148: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59149: LD_ADDR_EXP 95
59153: PUSH
59154: LD_EXP 95
59158: PPUSH
59159: LD_VAR 0 1
59163: PPUSH
59164: EMPTY
59165: PPUSH
59166: CALL_OW 1
59170: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59171: LD_ADDR_EXP 96
59175: PUSH
59176: LD_EXP 96
59180: PPUSH
59181: LD_VAR 0 1
59185: PPUSH
59186: EMPTY
59187: PPUSH
59188: CALL_OW 1
59192: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59193: LD_ADDR_EXP 97
59197: PUSH
59198: LD_EXP 97
59202: PPUSH
59203: LD_VAR 0 1
59207: PPUSH
59208: EMPTY
59209: PPUSH
59210: CALL_OW 1
59214: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59215: LD_ADDR_EXP 98
59219: PUSH
59220: LD_EXP 98
59224: PPUSH
59225: LD_VAR 0 1
59229: PPUSH
59230: EMPTY
59231: PPUSH
59232: CALL_OW 1
59236: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59237: LD_ADDR_EXP 99
59241: PUSH
59242: LD_EXP 99
59246: PPUSH
59247: LD_VAR 0 1
59251: PPUSH
59252: EMPTY
59253: PPUSH
59254: CALL_OW 1
59258: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59259: LD_ADDR_EXP 100
59263: PUSH
59264: LD_EXP 100
59268: PPUSH
59269: LD_VAR 0 1
59273: PPUSH
59274: EMPTY
59275: PPUSH
59276: CALL_OW 1
59280: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59281: LD_ADDR_EXP 101
59285: PUSH
59286: LD_EXP 101
59290: PPUSH
59291: LD_VAR 0 1
59295: PPUSH
59296: EMPTY
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59303: LD_ADDR_EXP 102
59307: PUSH
59308: LD_EXP 102
59312: PPUSH
59313: LD_VAR 0 1
59317: PPUSH
59318: EMPTY
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59325: LD_ADDR_EXP 103
59329: PUSH
59330: LD_EXP 103
59334: PPUSH
59335: LD_VAR 0 1
59339: PPUSH
59340: LD_INT 0
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
59348: LD_ADDR_EXP 104
59352: PUSH
59353: LD_EXP 104
59357: PPUSH
59358: LD_VAR 0 1
59362: PPUSH
59363: LD_INT 0
59365: PPUSH
59366: CALL_OW 1
59370: ST_TO_ADDR
// end ;
59371: LD_VAR 0 2
59375: RET
// export function MC_Add ( side , units ) ; var base ; begin
59376: LD_INT 0
59378: PPUSH
59379: PPUSH
// base := mc_bases + 1 ;
59380: LD_ADDR_VAR 0 4
59384: PUSH
59385: LD_EXP 61
59389: PUSH
59390: LD_INT 1
59392: PLUS
59393: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
59394: LD_ADDR_EXP 87
59398: PUSH
59399: LD_EXP 87
59403: PPUSH
59404: LD_VAR 0 4
59408: PPUSH
59409: LD_VAR 0 1
59413: PPUSH
59414: CALL_OW 1
59418: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
59419: LD_ADDR_EXP 61
59423: PUSH
59424: LD_EXP 61
59428: PPUSH
59429: LD_VAR 0 4
59433: PPUSH
59434: LD_VAR 0 2
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
59444: LD_ADDR_EXP 62
59448: PUSH
59449: LD_EXP 62
59453: PPUSH
59454: LD_VAR 0 4
59458: PPUSH
59459: EMPTY
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
59466: LD_ADDR_EXP 63
59470: PUSH
59471: LD_EXP 63
59475: PPUSH
59476: LD_VAR 0 4
59480: PPUSH
59481: EMPTY
59482: PPUSH
59483: CALL_OW 1
59487: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
59488: LD_ADDR_EXP 64
59492: PUSH
59493: LD_EXP 64
59497: PPUSH
59498: LD_VAR 0 4
59502: PPUSH
59503: EMPTY
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
59510: LD_ADDR_EXP 65
59514: PUSH
59515: LD_EXP 65
59519: PPUSH
59520: LD_VAR 0 4
59524: PPUSH
59525: EMPTY
59526: PPUSH
59527: CALL_OW 1
59531: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
59532: LD_ADDR_EXP 66
59536: PUSH
59537: LD_EXP 66
59541: PPUSH
59542: LD_VAR 0 4
59546: PPUSH
59547: EMPTY
59548: PPUSH
59549: CALL_OW 1
59553: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
59554: LD_ADDR_EXP 67
59558: PUSH
59559: LD_EXP 67
59563: PPUSH
59564: LD_VAR 0 4
59568: PPUSH
59569: EMPTY
59570: PPUSH
59571: CALL_OW 1
59575: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
59576: LD_ADDR_EXP 68
59580: PUSH
59581: LD_EXP 68
59585: PPUSH
59586: LD_VAR 0 4
59590: PPUSH
59591: EMPTY
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
59598: LD_ADDR_EXP 69
59602: PUSH
59603: LD_EXP 69
59607: PPUSH
59608: LD_VAR 0 4
59612: PPUSH
59613: EMPTY
59614: PPUSH
59615: CALL_OW 1
59619: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
59620: LD_ADDR_EXP 70
59624: PUSH
59625: LD_EXP 70
59629: PPUSH
59630: LD_VAR 0 4
59634: PPUSH
59635: EMPTY
59636: PPUSH
59637: CALL_OW 1
59641: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
59642: LD_ADDR_EXP 71
59646: PUSH
59647: LD_EXP 71
59651: PPUSH
59652: LD_VAR 0 4
59656: PPUSH
59657: EMPTY
59658: PPUSH
59659: CALL_OW 1
59663: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
59664: LD_ADDR_EXP 72
59668: PUSH
59669: LD_EXP 72
59673: PPUSH
59674: LD_VAR 0 4
59678: PPUSH
59679: LD_INT 0
59681: PPUSH
59682: CALL_OW 1
59686: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
59687: LD_ADDR_EXP 73
59691: PUSH
59692: LD_EXP 73
59696: PPUSH
59697: LD_VAR 0 4
59701: PPUSH
59702: EMPTY
59703: PPUSH
59704: CALL_OW 1
59708: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
59709: LD_ADDR_EXP 74
59713: PUSH
59714: LD_EXP 74
59718: PPUSH
59719: LD_VAR 0 4
59723: PPUSH
59724: EMPTY
59725: PPUSH
59726: CALL_OW 1
59730: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
59731: LD_ADDR_EXP 75
59735: PUSH
59736: LD_EXP 75
59740: PPUSH
59741: LD_VAR 0 4
59745: PPUSH
59746: EMPTY
59747: PPUSH
59748: CALL_OW 1
59752: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
59753: LD_ADDR_EXP 76
59757: PUSH
59758: LD_EXP 76
59762: PPUSH
59763: LD_VAR 0 4
59767: PPUSH
59768: EMPTY
59769: PPUSH
59770: CALL_OW 1
59774: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
59775: LD_ADDR_EXP 77
59779: PUSH
59780: LD_EXP 77
59784: PPUSH
59785: LD_VAR 0 4
59789: PPUSH
59790: EMPTY
59791: PPUSH
59792: CALL_OW 1
59796: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
59797: LD_ADDR_EXP 78
59801: PUSH
59802: LD_EXP 78
59806: PPUSH
59807: LD_VAR 0 4
59811: PPUSH
59812: EMPTY
59813: PPUSH
59814: CALL_OW 1
59818: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
59819: LD_ADDR_EXP 79
59823: PUSH
59824: LD_EXP 79
59828: PPUSH
59829: LD_VAR 0 4
59833: PPUSH
59834: EMPTY
59835: PPUSH
59836: CALL_OW 1
59840: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
59841: LD_ADDR_EXP 80
59845: PUSH
59846: LD_EXP 80
59850: PPUSH
59851: LD_VAR 0 4
59855: PPUSH
59856: EMPTY
59857: PPUSH
59858: CALL_OW 1
59862: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
59863: LD_ADDR_EXP 81
59867: PUSH
59868: LD_EXP 81
59872: PPUSH
59873: LD_VAR 0 4
59877: PPUSH
59878: EMPTY
59879: PPUSH
59880: CALL_OW 1
59884: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
59885: LD_ADDR_EXP 82
59889: PUSH
59890: LD_EXP 82
59894: PPUSH
59895: LD_VAR 0 4
59899: PPUSH
59900: EMPTY
59901: PPUSH
59902: CALL_OW 1
59906: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
59907: LD_ADDR_EXP 83
59911: PUSH
59912: LD_EXP 83
59916: PPUSH
59917: LD_VAR 0 4
59921: PPUSH
59922: EMPTY
59923: PPUSH
59924: CALL_OW 1
59928: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
59929: LD_ADDR_EXP 84
59933: PUSH
59934: LD_EXP 84
59938: PPUSH
59939: LD_VAR 0 4
59943: PPUSH
59944: EMPTY
59945: PPUSH
59946: CALL_OW 1
59950: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
59951: LD_ADDR_EXP 85
59955: PUSH
59956: LD_EXP 85
59960: PPUSH
59961: LD_VAR 0 4
59965: PPUSH
59966: EMPTY
59967: PPUSH
59968: CALL_OW 1
59972: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
59973: LD_ADDR_EXP 86
59977: PUSH
59978: LD_EXP 86
59982: PPUSH
59983: LD_VAR 0 4
59987: PPUSH
59988: EMPTY
59989: PPUSH
59990: CALL_OW 1
59994: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
59995: LD_ADDR_EXP 88
59999: PUSH
60000: LD_EXP 88
60004: PPUSH
60005: LD_VAR 0 4
60009: PPUSH
60010: EMPTY
60011: PPUSH
60012: CALL_OW 1
60016: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60017: LD_ADDR_EXP 90
60021: PUSH
60022: LD_EXP 90
60026: PPUSH
60027: LD_VAR 0 4
60031: PPUSH
60032: EMPTY
60033: PPUSH
60034: CALL_OW 1
60038: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60039: LD_ADDR_EXP 91
60043: PUSH
60044: LD_EXP 91
60048: PPUSH
60049: LD_VAR 0 4
60053: PPUSH
60054: EMPTY
60055: PPUSH
60056: CALL_OW 1
60060: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60061: LD_ADDR_EXP 92
60065: PUSH
60066: LD_EXP 92
60070: PPUSH
60071: LD_VAR 0 4
60075: PPUSH
60076: EMPTY
60077: PPUSH
60078: CALL_OW 1
60082: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
60083: LD_ADDR_EXP 93
60087: PUSH
60088: LD_EXP 93
60092: PPUSH
60093: LD_VAR 0 4
60097: PPUSH
60098: EMPTY
60099: PPUSH
60100: CALL_OW 1
60104: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
60105: LD_ADDR_EXP 94
60109: PUSH
60110: LD_EXP 94
60114: PPUSH
60115: LD_VAR 0 4
60119: PPUSH
60120: EMPTY
60121: PPUSH
60122: CALL_OW 1
60126: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
60127: LD_ADDR_EXP 95
60131: PUSH
60132: LD_EXP 95
60136: PPUSH
60137: LD_VAR 0 4
60141: PPUSH
60142: EMPTY
60143: PPUSH
60144: CALL_OW 1
60148: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
60149: LD_ADDR_EXP 96
60153: PUSH
60154: LD_EXP 96
60158: PPUSH
60159: LD_VAR 0 4
60163: PPUSH
60164: EMPTY
60165: PPUSH
60166: CALL_OW 1
60170: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
60171: LD_ADDR_EXP 97
60175: PUSH
60176: LD_EXP 97
60180: PPUSH
60181: LD_VAR 0 4
60185: PPUSH
60186: EMPTY
60187: PPUSH
60188: CALL_OW 1
60192: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
60193: LD_ADDR_EXP 98
60197: PUSH
60198: LD_EXP 98
60202: PPUSH
60203: LD_VAR 0 4
60207: PPUSH
60208: EMPTY
60209: PPUSH
60210: CALL_OW 1
60214: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
60215: LD_ADDR_EXP 99
60219: PUSH
60220: LD_EXP 99
60224: PPUSH
60225: LD_VAR 0 4
60229: PPUSH
60230: EMPTY
60231: PPUSH
60232: CALL_OW 1
60236: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
60237: LD_ADDR_EXP 100
60241: PUSH
60242: LD_EXP 100
60246: PPUSH
60247: LD_VAR 0 4
60251: PPUSH
60252: EMPTY
60253: PPUSH
60254: CALL_OW 1
60258: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
60259: LD_ADDR_EXP 101
60263: PUSH
60264: LD_EXP 101
60268: PPUSH
60269: LD_VAR 0 4
60273: PPUSH
60274: EMPTY
60275: PPUSH
60276: CALL_OW 1
60280: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
60281: LD_ADDR_EXP 102
60285: PUSH
60286: LD_EXP 102
60290: PPUSH
60291: LD_VAR 0 4
60295: PPUSH
60296: EMPTY
60297: PPUSH
60298: CALL_OW 1
60302: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
60303: LD_ADDR_EXP 103
60307: PUSH
60308: LD_EXP 103
60312: PPUSH
60313: LD_VAR 0 4
60317: PPUSH
60318: LD_INT 0
60320: PPUSH
60321: CALL_OW 1
60325: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
60326: LD_ADDR_EXP 104
60330: PUSH
60331: LD_EXP 104
60335: PPUSH
60336: LD_VAR 0 4
60340: PPUSH
60341: LD_INT 0
60343: PPUSH
60344: CALL_OW 1
60348: ST_TO_ADDR
// result := base ;
60349: LD_ADDR_VAR 0 3
60353: PUSH
60354: LD_VAR 0 4
60358: ST_TO_ADDR
// end ;
60359: LD_VAR 0 3
60363: RET
// export function MC_Start ( ) ; var i ; begin
60364: LD_INT 0
60366: PPUSH
60367: PPUSH
// for i = 1 to mc_bases do
60368: LD_ADDR_VAR 0 2
60372: PUSH
60373: DOUBLE
60374: LD_INT 1
60376: DEC
60377: ST_TO_ADDR
60378: LD_EXP 61
60382: PUSH
60383: FOR_TO
60384: IFFALSE 61484
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
60386: LD_ADDR_EXP 61
60390: PUSH
60391: LD_EXP 61
60395: PPUSH
60396: LD_VAR 0 2
60400: PPUSH
60401: LD_EXP 61
60405: PUSH
60406: LD_VAR 0 2
60410: ARRAY
60411: PUSH
60412: LD_INT 0
60414: DIFF
60415: PPUSH
60416: CALL_OW 1
60420: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
60421: LD_ADDR_EXP 62
60425: PUSH
60426: LD_EXP 62
60430: PPUSH
60431: LD_VAR 0 2
60435: PPUSH
60436: EMPTY
60437: PPUSH
60438: CALL_OW 1
60442: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60443: LD_ADDR_EXP 63
60447: PUSH
60448: LD_EXP 63
60452: PPUSH
60453: LD_VAR 0 2
60457: PPUSH
60458: EMPTY
60459: PPUSH
60460: CALL_OW 1
60464: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
60465: LD_ADDR_EXP 64
60469: PUSH
60470: LD_EXP 64
60474: PPUSH
60475: LD_VAR 0 2
60479: PPUSH
60480: EMPTY
60481: PPUSH
60482: CALL_OW 1
60486: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
60487: LD_ADDR_EXP 65
60491: PUSH
60492: LD_EXP 65
60496: PPUSH
60497: LD_VAR 0 2
60501: PPUSH
60502: EMPTY
60503: PUSH
60504: EMPTY
60505: PUSH
60506: EMPTY
60507: LIST
60508: LIST
60509: PPUSH
60510: CALL_OW 1
60514: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
60515: LD_ADDR_EXP 66
60519: PUSH
60520: LD_EXP 66
60524: PPUSH
60525: LD_VAR 0 2
60529: PPUSH
60530: EMPTY
60531: PPUSH
60532: CALL_OW 1
60536: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
60537: LD_ADDR_EXP 93
60541: PUSH
60542: LD_EXP 93
60546: PPUSH
60547: LD_VAR 0 2
60551: PPUSH
60552: EMPTY
60553: PPUSH
60554: CALL_OW 1
60558: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
60559: LD_ADDR_EXP 67
60563: PUSH
60564: LD_EXP 67
60568: PPUSH
60569: LD_VAR 0 2
60573: PPUSH
60574: EMPTY
60575: PPUSH
60576: CALL_OW 1
60580: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
60581: LD_ADDR_EXP 68
60585: PUSH
60586: LD_EXP 68
60590: PPUSH
60591: LD_VAR 0 2
60595: PPUSH
60596: EMPTY
60597: PPUSH
60598: CALL_OW 1
60602: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
60603: LD_ADDR_EXP 69
60607: PUSH
60608: LD_EXP 69
60612: PPUSH
60613: LD_VAR 0 2
60617: PPUSH
60618: LD_EXP 61
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PPUSH
60629: LD_INT 2
60631: PUSH
60632: LD_INT 30
60634: PUSH
60635: LD_INT 32
60637: PUSH
60638: EMPTY
60639: LIST
60640: LIST
60641: PUSH
60642: LD_INT 30
60644: PUSH
60645: LD_INT 33
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: LIST
60656: PPUSH
60657: CALL_OW 72
60661: PPUSH
60662: CALL_OW 1
60666: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
60667: LD_ADDR_EXP 70
60671: PUSH
60672: LD_EXP 70
60676: PPUSH
60677: LD_VAR 0 2
60681: PPUSH
60682: LD_EXP 61
60686: PUSH
60687: LD_VAR 0 2
60691: ARRAY
60692: PPUSH
60693: LD_INT 2
60695: PUSH
60696: LD_INT 30
60698: PUSH
60699: LD_INT 32
60701: PUSH
60702: EMPTY
60703: LIST
60704: LIST
60705: PUSH
60706: LD_INT 30
60708: PUSH
60709: LD_INT 31
60711: PUSH
60712: EMPTY
60713: LIST
60714: LIST
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: LIST
60720: PUSH
60721: LD_INT 58
60723: PUSH
60724: EMPTY
60725: LIST
60726: PUSH
60727: EMPTY
60728: LIST
60729: LIST
60730: PPUSH
60731: CALL_OW 72
60735: PPUSH
60736: CALL_OW 1
60740: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
60741: LD_ADDR_EXP 71
60745: PUSH
60746: LD_EXP 71
60750: PPUSH
60751: LD_VAR 0 2
60755: PPUSH
60756: EMPTY
60757: PPUSH
60758: CALL_OW 1
60762: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
60763: LD_ADDR_EXP 75
60767: PUSH
60768: LD_EXP 75
60772: PPUSH
60773: LD_VAR 0 2
60777: PPUSH
60778: EMPTY
60779: PPUSH
60780: CALL_OW 1
60784: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
60785: LD_ADDR_EXP 74
60789: PUSH
60790: LD_EXP 74
60794: PPUSH
60795: LD_VAR 0 2
60799: PPUSH
60800: EMPTY
60801: PPUSH
60802: CALL_OW 1
60806: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
60807: LD_ADDR_EXP 76
60811: PUSH
60812: LD_EXP 76
60816: PPUSH
60817: LD_VAR 0 2
60821: PPUSH
60822: EMPTY
60823: PPUSH
60824: CALL_OW 1
60828: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
60829: LD_ADDR_EXP 77
60833: PUSH
60834: LD_EXP 77
60838: PPUSH
60839: LD_VAR 0 2
60843: PPUSH
60844: EMPTY
60845: PPUSH
60846: CALL_OW 1
60850: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60851: LD_ADDR_EXP 78
60855: PUSH
60856: LD_EXP 78
60860: PPUSH
60861: LD_VAR 0 2
60865: PPUSH
60866: EMPTY
60867: PPUSH
60868: CALL_OW 1
60872: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
60873: LD_ADDR_EXP 79
60877: PUSH
60878: LD_EXP 79
60882: PPUSH
60883: LD_VAR 0 2
60887: PPUSH
60888: EMPTY
60889: PPUSH
60890: CALL_OW 1
60894: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
60895: LD_ADDR_EXP 80
60899: PUSH
60900: LD_EXP 80
60904: PPUSH
60905: LD_VAR 0 2
60909: PPUSH
60910: EMPTY
60911: PPUSH
60912: CALL_OW 1
60916: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
60917: LD_ADDR_EXP 81
60921: PUSH
60922: LD_EXP 81
60926: PPUSH
60927: LD_VAR 0 2
60931: PPUSH
60932: EMPTY
60933: PPUSH
60934: CALL_OW 1
60938: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
60939: LD_ADDR_EXP 82
60943: PUSH
60944: LD_EXP 82
60948: PPUSH
60949: LD_VAR 0 2
60953: PPUSH
60954: EMPTY
60955: PPUSH
60956: CALL_OW 1
60960: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
60961: LD_ADDR_EXP 83
60965: PUSH
60966: LD_EXP 83
60970: PPUSH
60971: LD_VAR 0 2
60975: PPUSH
60976: EMPTY
60977: PPUSH
60978: CALL_OW 1
60982: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
60983: LD_ADDR_EXP 72
60987: PUSH
60988: LD_EXP 72
60992: PPUSH
60993: LD_VAR 0 2
60997: PPUSH
60998: LD_INT 0
61000: PPUSH
61001: CALL_OW 1
61005: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
61006: LD_ADDR_EXP 85
61010: PUSH
61011: LD_EXP 85
61015: PPUSH
61016: LD_VAR 0 2
61020: PPUSH
61021: LD_INT 0
61023: PPUSH
61024: CALL_OW 1
61028: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
61029: LD_ADDR_EXP 73
61033: PUSH
61034: LD_EXP 73
61038: PPUSH
61039: LD_VAR 0 2
61043: PPUSH
61044: EMPTY
61045: PPUSH
61046: CALL_OW 1
61050: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
61051: LD_ADDR_EXP 84
61055: PUSH
61056: LD_EXP 84
61060: PPUSH
61061: LD_VAR 0 2
61065: PPUSH
61066: LD_INT 0
61068: PPUSH
61069: CALL_OW 1
61073: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
61074: LD_ADDR_EXP 86
61078: PUSH
61079: LD_EXP 86
61083: PPUSH
61084: LD_VAR 0 2
61088: PPUSH
61089: EMPTY
61090: PPUSH
61091: CALL_OW 1
61095: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
61096: LD_ADDR_EXP 89
61100: PUSH
61101: LD_EXP 89
61105: PPUSH
61106: LD_VAR 0 2
61110: PPUSH
61111: LD_INT 0
61113: PPUSH
61114: CALL_OW 1
61118: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
61119: LD_ADDR_EXP 90
61123: PUSH
61124: LD_EXP 90
61128: PPUSH
61129: LD_VAR 0 2
61133: PPUSH
61134: EMPTY
61135: PPUSH
61136: CALL_OW 1
61140: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61141: LD_ADDR_EXP 91
61145: PUSH
61146: LD_EXP 91
61150: PPUSH
61151: LD_VAR 0 2
61155: PPUSH
61156: EMPTY
61157: PPUSH
61158: CALL_OW 1
61162: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61163: LD_ADDR_EXP 92
61167: PUSH
61168: LD_EXP 92
61172: PPUSH
61173: LD_VAR 0 2
61177: PPUSH
61178: EMPTY
61179: PPUSH
61180: CALL_OW 1
61184: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
61185: LD_ADDR_EXP 94
61189: PUSH
61190: LD_EXP 94
61194: PPUSH
61195: LD_VAR 0 2
61199: PPUSH
61200: LD_EXP 61
61204: PUSH
61205: LD_VAR 0 2
61209: ARRAY
61210: PPUSH
61211: LD_INT 2
61213: PUSH
61214: LD_INT 30
61216: PUSH
61217: LD_INT 6
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 30
61226: PUSH
61227: LD_INT 7
61229: PUSH
61230: EMPTY
61231: LIST
61232: LIST
61233: PUSH
61234: LD_INT 30
61236: PUSH
61237: LD_INT 8
61239: PUSH
61240: EMPTY
61241: LIST
61242: LIST
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: PPUSH
61250: CALL_OW 72
61254: PPUSH
61255: CALL_OW 1
61259: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
61260: LD_ADDR_EXP 95
61264: PUSH
61265: LD_EXP 95
61269: PPUSH
61270: LD_VAR 0 2
61274: PPUSH
61275: EMPTY
61276: PPUSH
61277: CALL_OW 1
61281: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
61282: LD_ADDR_EXP 96
61286: PUSH
61287: LD_EXP 96
61291: PPUSH
61292: LD_VAR 0 2
61296: PPUSH
61297: EMPTY
61298: PPUSH
61299: CALL_OW 1
61303: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
61304: LD_ADDR_EXP 97
61308: PUSH
61309: LD_EXP 97
61313: PPUSH
61314: LD_VAR 0 2
61318: PPUSH
61319: EMPTY
61320: PPUSH
61321: CALL_OW 1
61325: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
61326: LD_ADDR_EXP 98
61330: PUSH
61331: LD_EXP 98
61335: PPUSH
61336: LD_VAR 0 2
61340: PPUSH
61341: EMPTY
61342: PPUSH
61343: CALL_OW 1
61347: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61348: LD_ADDR_EXP 99
61352: PUSH
61353: LD_EXP 99
61357: PPUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: EMPTY
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
61370: LD_ADDR_EXP 100
61374: PUSH
61375: LD_EXP 100
61379: PPUSH
61380: LD_VAR 0 2
61384: PPUSH
61385: EMPTY
61386: PPUSH
61387: CALL_OW 1
61391: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
61392: LD_ADDR_EXP 101
61396: PUSH
61397: LD_EXP 101
61401: PPUSH
61402: LD_VAR 0 2
61406: PPUSH
61407: EMPTY
61408: PPUSH
61409: CALL_OW 1
61413: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
61414: LD_ADDR_EXP 102
61418: PUSH
61419: LD_EXP 102
61423: PPUSH
61424: LD_VAR 0 2
61428: PPUSH
61429: EMPTY
61430: PPUSH
61431: CALL_OW 1
61435: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
61436: LD_ADDR_EXP 103
61440: PUSH
61441: LD_EXP 103
61445: PPUSH
61446: LD_VAR 0 2
61450: PPUSH
61451: LD_INT 0
61453: PPUSH
61454: CALL_OW 1
61458: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
61459: LD_ADDR_EXP 104
61463: PUSH
61464: LD_EXP 104
61468: PPUSH
61469: LD_VAR 0 2
61473: PPUSH
61474: LD_INT 0
61476: PPUSH
61477: CALL_OW 1
61481: ST_TO_ADDR
// end ;
61482: GO 60383
61484: POP
61485: POP
// MC_InitSides ( ) ;
61486: CALL 61772 0 0
// MC_InitResearch ( ) ;
61490: CALL 61511 0 0
// CustomInitMacro ( ) ;
61494: CALL 219 0 0
// skirmish := true ;
61498: LD_ADDR_EXP 59
61502: PUSH
61503: LD_INT 1
61505: ST_TO_ADDR
// end ;
61506: LD_VAR 0 1
61510: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
61511: LD_INT 0
61513: PPUSH
61514: PPUSH
61515: PPUSH
61516: PPUSH
61517: PPUSH
61518: PPUSH
// if not mc_bases then
61519: LD_EXP 61
61523: NOT
61524: IFFALSE 61528
// exit ;
61526: GO 61767
// for i = 1 to 8 do
61528: LD_ADDR_VAR 0 2
61532: PUSH
61533: DOUBLE
61534: LD_INT 1
61536: DEC
61537: ST_TO_ADDR
61538: LD_INT 8
61540: PUSH
61541: FOR_TO
61542: IFFALSE 61568
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
61544: LD_ADDR_EXP 88
61548: PUSH
61549: LD_EXP 88
61553: PPUSH
61554: LD_VAR 0 2
61558: PPUSH
61559: EMPTY
61560: PPUSH
61561: CALL_OW 1
61565: ST_TO_ADDR
61566: GO 61541
61568: POP
61569: POP
// tmp := [ ] ;
61570: LD_ADDR_VAR 0 5
61574: PUSH
61575: EMPTY
61576: ST_TO_ADDR
// for i = 1 to mc_sides do
61577: LD_ADDR_VAR 0 2
61581: PUSH
61582: DOUBLE
61583: LD_INT 1
61585: DEC
61586: ST_TO_ADDR
61587: LD_EXP 87
61591: PUSH
61592: FOR_TO
61593: IFFALSE 61651
// if not mc_sides [ i ] in tmp then
61595: LD_EXP 87
61599: PUSH
61600: LD_VAR 0 2
61604: ARRAY
61605: PUSH
61606: LD_VAR 0 5
61610: IN
61611: NOT
61612: IFFALSE 61649
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
61614: LD_ADDR_VAR 0 5
61618: PUSH
61619: LD_VAR 0 5
61623: PPUSH
61624: LD_VAR 0 5
61628: PUSH
61629: LD_INT 1
61631: PLUS
61632: PPUSH
61633: LD_EXP 87
61637: PUSH
61638: LD_VAR 0 2
61642: ARRAY
61643: PPUSH
61644: CALL_OW 2
61648: ST_TO_ADDR
61649: GO 61592
61651: POP
61652: POP
// if not tmp then
61653: LD_VAR 0 5
61657: NOT
61658: IFFALSE 61662
// exit ;
61660: GO 61767
// for j in tmp do
61662: LD_ADDR_VAR 0 3
61666: PUSH
61667: LD_VAR 0 5
61671: PUSH
61672: FOR_IN
61673: IFFALSE 61765
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
61675: LD_ADDR_VAR 0 6
61679: PUSH
61680: LD_INT 22
61682: PUSH
61683: LD_VAR 0 3
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: CALL_OW 69
61696: ST_TO_ADDR
// if not un then
61697: LD_VAR 0 6
61701: NOT
61702: IFFALSE 61706
// continue ;
61704: GO 61672
// nation := GetNation ( un [ 1 ] ) ;
61706: LD_ADDR_VAR 0 4
61710: PUSH
61711: LD_VAR 0 6
61715: PUSH
61716: LD_INT 1
61718: ARRAY
61719: PPUSH
61720: CALL_OW 248
61724: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
61725: LD_ADDR_EXP 88
61729: PUSH
61730: LD_EXP 88
61734: PPUSH
61735: LD_VAR 0 3
61739: PPUSH
61740: LD_VAR 0 3
61744: PPUSH
61745: LD_VAR 0 4
61749: PPUSH
61750: LD_INT 1
61752: PPUSH
61753: CALL 16082 0 3
61757: PPUSH
61758: CALL_OW 1
61762: ST_TO_ADDR
// end ;
61763: GO 61672
61765: POP
61766: POP
// end ;
61767: LD_VAR 0 1
61771: RET
// export function MC_InitSides ( ) ; var i ; begin
61772: LD_INT 0
61774: PPUSH
61775: PPUSH
// if not mc_bases then
61776: LD_EXP 61
61780: NOT
61781: IFFALSE 61785
// exit ;
61783: GO 61859
// for i = 1 to mc_bases do
61785: LD_ADDR_VAR 0 2
61789: PUSH
61790: DOUBLE
61791: LD_INT 1
61793: DEC
61794: ST_TO_ADDR
61795: LD_EXP 61
61799: PUSH
61800: FOR_TO
61801: IFFALSE 61857
// if mc_bases [ i ] then
61803: LD_EXP 61
61807: PUSH
61808: LD_VAR 0 2
61812: ARRAY
61813: IFFALSE 61855
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
61815: LD_ADDR_EXP 87
61819: PUSH
61820: LD_EXP 87
61824: PPUSH
61825: LD_VAR 0 2
61829: PPUSH
61830: LD_EXP 61
61834: PUSH
61835: LD_VAR 0 2
61839: ARRAY
61840: PUSH
61841: LD_INT 1
61843: ARRAY
61844: PPUSH
61845: CALL_OW 255
61849: PPUSH
61850: CALL_OW 1
61854: ST_TO_ADDR
61855: GO 61800
61857: POP
61858: POP
// end ;
61859: LD_VAR 0 1
61863: RET
// every 0 0$03 trigger skirmish do
61864: LD_EXP 59
61868: IFFALSE 62022
61870: GO 61872
61872: DISABLE
// begin enable ;
61873: ENABLE
// MC_CheckBuildings ( ) ;
61874: CALL 66534 0 0
// MC_CheckPeopleLife ( ) ;
61878: CALL 66695 0 0
// RaiseSailEvent ( 100 ) ;
61882: LD_INT 100
61884: PPUSH
61885: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
61889: LD_INT 103
61891: PPUSH
61892: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
61896: LD_INT 104
61898: PPUSH
61899: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
61903: LD_INT 105
61905: PPUSH
61906: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
61910: LD_INT 106
61912: PPUSH
61913: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
61917: LD_INT 107
61919: PPUSH
61920: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
61924: LD_INT 108
61926: PPUSH
61927: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
61931: LD_INT 109
61933: PPUSH
61934: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
61938: LD_INT 110
61940: PPUSH
61941: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
61945: LD_INT 111
61947: PPUSH
61948: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
61952: LD_INT 112
61954: PPUSH
61955: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
61959: LD_INT 113
61961: PPUSH
61962: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
61966: LD_INT 120
61968: PPUSH
61969: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
61973: LD_INT 121
61975: PPUSH
61976: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
61980: LD_INT 122
61982: PPUSH
61983: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
61987: LD_INT 123
61989: PPUSH
61990: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
61994: LD_INT 124
61996: PPUSH
61997: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
62001: LD_INT 125
62003: PPUSH
62004: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
62008: LD_INT 126
62010: PPUSH
62011: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
62015: LD_INT 200
62017: PPUSH
62018: CALL_OW 427
// end ;
62022: END
// on SailEvent ( event ) do begin if event < 100 then
62023: LD_VAR 0 1
62027: PUSH
62028: LD_INT 100
62030: LESS
62031: IFFALSE 62042
// CustomEvent ( event ) ;
62033: LD_VAR 0 1
62037: PPUSH
62038: CALL 14697 0 1
// if event = 100 then
62042: LD_VAR 0 1
62046: PUSH
62047: LD_INT 100
62049: EQUAL
62050: IFFALSE 62056
// MC_ClassManager ( ) ;
62052: CALL 62448 0 0
// if event = 101 then
62056: LD_VAR 0 1
62060: PUSH
62061: LD_INT 101
62063: EQUAL
62064: IFFALSE 62070
// MC_RepairBuildings ( ) ;
62066: CALL 67280 0 0
// if event = 102 then
62070: LD_VAR 0 1
62074: PUSH
62075: LD_INT 102
62077: EQUAL
62078: IFFALSE 62084
// MC_Heal ( ) ;
62080: CALL 68215 0 0
// if event = 103 then
62084: LD_VAR 0 1
62088: PUSH
62089: LD_INT 103
62091: EQUAL
62092: IFFALSE 62098
// MC_Build ( ) ;
62094: CALL 68637 0 0
// if event = 104 then
62098: LD_VAR 0 1
62102: PUSH
62103: LD_INT 104
62105: EQUAL
62106: IFFALSE 62112
// MC_TurretWeapon ( ) ;
62108: CALL 70271 0 0
// if event = 105 then
62112: LD_VAR 0 1
62116: PUSH
62117: LD_INT 105
62119: EQUAL
62120: IFFALSE 62126
// MC_BuildUpgrade ( ) ;
62122: CALL 69822 0 0
// if event = 106 then
62126: LD_VAR 0 1
62130: PUSH
62131: LD_INT 106
62133: EQUAL
62134: IFFALSE 62140
// MC_PlantMines ( ) ;
62136: CALL 70701 0 0
// if event = 107 then
62140: LD_VAR 0 1
62144: PUSH
62145: LD_INT 107
62147: EQUAL
62148: IFFALSE 62154
// MC_CollectCrates ( ) ;
62150: CALL 71499 0 0
// if event = 108 then
62154: LD_VAR 0 1
62158: PUSH
62159: LD_INT 108
62161: EQUAL
62162: IFFALSE 62168
// MC_LinkRemoteControl ( ) ;
62164: CALL 73349 0 0
// if event = 109 then
62168: LD_VAR 0 1
62172: PUSH
62173: LD_INT 109
62175: EQUAL
62176: IFFALSE 62182
// MC_ProduceVehicle ( ) ;
62178: CALL 73530 0 0
// if event = 110 then
62182: LD_VAR 0 1
62186: PUSH
62187: LD_INT 110
62189: EQUAL
62190: IFFALSE 62196
// MC_SendAttack ( ) ;
62192: CALL 73996 0 0
// if event = 111 then
62196: LD_VAR 0 1
62200: PUSH
62201: LD_INT 111
62203: EQUAL
62204: IFFALSE 62210
// MC_Defend ( ) ;
62206: CALL 74104 0 0
// if event = 112 then
62210: LD_VAR 0 1
62214: PUSH
62215: LD_INT 112
62217: EQUAL
62218: IFFALSE 62224
// MC_Research ( ) ;
62220: CALL 74984 0 0
// if event = 113 then
62224: LD_VAR 0 1
62228: PUSH
62229: LD_INT 113
62231: EQUAL
62232: IFFALSE 62238
// MC_MinesTrigger ( ) ;
62234: CALL 76098 0 0
// if event = 120 then
62238: LD_VAR 0 1
62242: PUSH
62243: LD_INT 120
62245: EQUAL
62246: IFFALSE 62252
// MC_RepairVehicle ( ) ;
62248: CALL 76197 0 0
// if event = 121 then
62252: LD_VAR 0 1
62256: PUSH
62257: LD_INT 121
62259: EQUAL
62260: IFFALSE 62266
// MC_TameApe ( ) ;
62262: CALL 76966 0 0
// if event = 122 then
62266: LD_VAR 0 1
62270: PUSH
62271: LD_INT 122
62273: EQUAL
62274: IFFALSE 62280
// MC_ChangeApeClass ( ) ;
62276: CALL 77795 0 0
// if event = 123 then
62280: LD_VAR 0 1
62284: PUSH
62285: LD_INT 123
62287: EQUAL
62288: IFFALSE 62294
// MC_Bazooka ( ) ;
62290: CALL 78445 0 0
// if event = 124 then
62294: LD_VAR 0 1
62298: PUSH
62299: LD_INT 124
62301: EQUAL
62302: IFFALSE 62308
// MC_TeleportExit ( ) ;
62304: CALL 78643 0 0
// if event = 125 then
62308: LD_VAR 0 1
62312: PUSH
62313: LD_INT 125
62315: EQUAL
62316: IFFALSE 62322
// MC_Deposits ( ) ;
62318: CALL 79290 0 0
// if event = 126 then
62322: LD_VAR 0 1
62326: PUSH
62327: LD_INT 126
62329: EQUAL
62330: IFFALSE 62336
// MC_RemoteDriver ( ) ;
62332: CALL 79915 0 0
// if event = 200 then
62336: LD_VAR 0 1
62340: PUSH
62341: LD_INT 200
62343: EQUAL
62344: IFFALSE 62350
// MC_Idle ( ) ;
62346: CALL 81822 0 0
// end ;
62350: PPOPN 1
62352: END
// export function MC_Reset ( base , tag ) ; var i ; begin
62353: LD_INT 0
62355: PPUSH
62356: PPUSH
// if not mc_bases [ base ] or not tag then
62357: LD_EXP 61
62361: PUSH
62362: LD_VAR 0 1
62366: ARRAY
62367: NOT
62368: PUSH
62369: LD_VAR 0 2
62373: NOT
62374: OR
62375: IFFALSE 62379
// exit ;
62377: GO 62443
// for i in mc_bases [ base ] union mc_ape [ base ] do
62379: LD_ADDR_VAR 0 4
62383: PUSH
62384: LD_EXP 61
62388: PUSH
62389: LD_VAR 0 1
62393: ARRAY
62394: PUSH
62395: LD_EXP 90
62399: PUSH
62400: LD_VAR 0 1
62404: ARRAY
62405: UNION
62406: PUSH
62407: FOR_IN
62408: IFFALSE 62441
// if GetTag ( i ) = tag then
62410: LD_VAR 0 4
62414: PPUSH
62415: CALL_OW 110
62419: PUSH
62420: LD_VAR 0 2
62424: EQUAL
62425: IFFALSE 62439
// SetTag ( i , 0 ) ;
62427: LD_VAR 0 4
62431: PPUSH
62432: LD_INT 0
62434: PPUSH
62435: CALL_OW 109
62439: GO 62407
62441: POP
62442: POP
// end ;
62443: LD_VAR 0 3
62447: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
62448: LD_INT 0
62450: PPUSH
62451: PPUSH
62452: PPUSH
62453: PPUSH
62454: PPUSH
62455: PPUSH
62456: PPUSH
62457: PPUSH
// if not mc_bases then
62458: LD_EXP 61
62462: NOT
62463: IFFALSE 62467
// exit ;
62465: GO 62916
// for i = 1 to mc_bases do
62467: LD_ADDR_VAR 0 2
62471: PUSH
62472: DOUBLE
62473: LD_INT 1
62475: DEC
62476: ST_TO_ADDR
62477: LD_EXP 61
62481: PUSH
62482: FOR_TO
62483: IFFALSE 62914
// begin tmp := MC_ClassCheckReq ( i ) ;
62485: LD_ADDR_VAR 0 4
62489: PUSH
62490: LD_VAR 0 2
62494: PPUSH
62495: CALL 62921 0 1
62499: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
62500: LD_ADDR_EXP 102
62504: PUSH
62505: LD_EXP 102
62509: PPUSH
62510: LD_VAR 0 2
62514: PPUSH
62515: LD_VAR 0 4
62519: PPUSH
62520: CALL_OW 1
62524: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
62525: LD_ADDR_VAR 0 6
62529: PUSH
62530: LD_EXP 61
62534: PUSH
62535: LD_VAR 0 2
62539: ARRAY
62540: PPUSH
62541: LD_INT 2
62543: PUSH
62544: LD_INT 30
62546: PUSH
62547: LD_INT 4
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: PUSH
62554: LD_INT 30
62556: PUSH
62557: LD_INT 5
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: PUSH
62564: EMPTY
62565: LIST
62566: LIST
62567: LIST
62568: PPUSH
62569: CALL_OW 72
62573: PUSH
62574: LD_EXP 61
62578: PUSH
62579: LD_VAR 0 2
62583: ARRAY
62584: PPUSH
62585: LD_INT 2
62587: PUSH
62588: LD_INT 30
62590: PUSH
62591: LD_INT 0
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 30
62600: PUSH
62601: LD_INT 1
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: LIST
62612: PPUSH
62613: CALL_OW 72
62617: PUSH
62618: LD_EXP 61
62622: PUSH
62623: LD_VAR 0 2
62627: ARRAY
62628: PPUSH
62629: LD_INT 30
62631: PUSH
62632: LD_INT 3
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PPUSH
62639: CALL_OW 72
62643: PUSH
62644: LD_EXP 61
62648: PUSH
62649: LD_VAR 0 2
62653: ARRAY
62654: PPUSH
62655: LD_INT 2
62657: PUSH
62658: LD_INT 30
62660: PUSH
62661: LD_INT 6
62663: PUSH
62664: EMPTY
62665: LIST
62666: LIST
62667: PUSH
62668: LD_INT 30
62670: PUSH
62671: LD_INT 7
62673: PUSH
62674: EMPTY
62675: LIST
62676: LIST
62677: PUSH
62678: LD_INT 30
62680: PUSH
62681: LD_INT 8
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: PUSH
62688: EMPTY
62689: LIST
62690: LIST
62691: LIST
62692: LIST
62693: PPUSH
62694: CALL_OW 72
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: LIST
62703: LIST
62704: ST_TO_ADDR
// for j := 1 to 4 do
62705: LD_ADDR_VAR 0 3
62709: PUSH
62710: DOUBLE
62711: LD_INT 1
62713: DEC
62714: ST_TO_ADDR
62715: LD_INT 4
62717: PUSH
62718: FOR_TO
62719: IFFALSE 62910
// begin if not tmp [ j ] then
62721: LD_VAR 0 4
62725: PUSH
62726: LD_VAR 0 3
62730: ARRAY
62731: NOT
62732: IFFALSE 62736
// continue ;
62734: GO 62718
// for p in tmp [ j ] do
62736: LD_ADDR_VAR 0 5
62740: PUSH
62741: LD_VAR 0 4
62745: PUSH
62746: LD_VAR 0 3
62750: ARRAY
62751: PUSH
62752: FOR_IN
62753: IFFALSE 62906
// begin if not b [ j ] then
62755: LD_VAR 0 6
62759: PUSH
62760: LD_VAR 0 3
62764: ARRAY
62765: NOT
62766: IFFALSE 62770
// break ;
62768: GO 62906
// e := 0 ;
62770: LD_ADDR_VAR 0 7
62774: PUSH
62775: LD_INT 0
62777: ST_TO_ADDR
// for k in b [ j ] do
62778: LD_ADDR_VAR 0 8
62782: PUSH
62783: LD_VAR 0 6
62787: PUSH
62788: LD_VAR 0 3
62792: ARRAY
62793: PUSH
62794: FOR_IN
62795: IFFALSE 62822
// if IsNotFull ( k ) then
62797: LD_VAR 0 8
62801: PPUSH
62802: CALL 18203 0 1
62806: IFFALSE 62820
// begin e := k ;
62808: LD_ADDR_VAR 0 7
62812: PUSH
62813: LD_VAR 0 8
62817: ST_TO_ADDR
// break ;
62818: GO 62822
// end ;
62820: GO 62794
62822: POP
62823: POP
// if e and not UnitGoingToBuilding ( p , e ) then
62824: LD_VAR 0 7
62828: PUSH
62829: LD_VAR 0 5
62833: PPUSH
62834: LD_VAR 0 7
62838: PPUSH
62839: CALL 52353 0 2
62843: NOT
62844: AND
62845: IFFALSE 62904
// begin if IsInUnit ( p ) then
62847: LD_VAR 0 5
62851: PPUSH
62852: CALL_OW 310
62856: IFFALSE 62867
// ComExitBuilding ( p ) ;
62858: LD_VAR 0 5
62862: PPUSH
62863: CALL_OW 122
// ComEnterUnit ( p , e ) ;
62867: LD_VAR 0 5
62871: PPUSH
62872: LD_VAR 0 7
62876: PPUSH
62877: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
62881: LD_VAR 0 5
62885: PPUSH
62886: LD_VAR 0 3
62890: PPUSH
62891: CALL_OW 183
// AddComExitBuilding ( p ) ;
62895: LD_VAR 0 5
62899: PPUSH
62900: CALL_OW 182
// end ; end ;
62904: GO 62752
62906: POP
62907: POP
// end ;
62908: GO 62718
62910: POP
62911: POP
// end ;
62912: GO 62482
62914: POP
62915: POP
// end ;
62916: LD_VAR 0 1
62920: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
62921: LD_INT 0
62923: PPUSH
62924: PPUSH
62925: PPUSH
62926: PPUSH
62927: PPUSH
62928: PPUSH
62929: PPUSH
62930: PPUSH
62931: PPUSH
62932: PPUSH
62933: PPUSH
62934: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
62935: LD_ADDR_VAR 0 2
62939: PUSH
62940: LD_INT 0
62942: PUSH
62943: LD_INT 0
62945: PUSH
62946: LD_INT 0
62948: PUSH
62949: LD_INT 0
62951: PUSH
62952: EMPTY
62953: LIST
62954: LIST
62955: LIST
62956: LIST
62957: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62958: LD_VAR 0 1
62962: NOT
62963: PUSH
62964: LD_EXP 61
62968: PUSH
62969: LD_VAR 0 1
62973: ARRAY
62974: NOT
62975: OR
62976: PUSH
62977: LD_EXP 61
62981: PUSH
62982: LD_VAR 0 1
62986: ARRAY
62987: PPUSH
62988: LD_INT 2
62990: PUSH
62991: LD_INT 30
62993: PUSH
62994: LD_INT 0
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PUSH
63001: LD_INT 30
63003: PUSH
63004: LD_INT 1
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: LIST
63015: PPUSH
63016: CALL_OW 72
63020: NOT
63021: OR
63022: IFFALSE 63026
// exit ;
63024: GO 66529
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63026: LD_ADDR_VAR 0 4
63030: PUSH
63031: LD_EXP 61
63035: PUSH
63036: LD_VAR 0 1
63040: ARRAY
63041: PPUSH
63042: LD_INT 2
63044: PUSH
63045: LD_INT 25
63047: PUSH
63048: LD_INT 1
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: PUSH
63055: LD_INT 25
63057: PUSH
63058: LD_INT 2
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 25
63067: PUSH
63068: LD_INT 3
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 25
63077: PUSH
63078: LD_INT 4
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 25
63087: PUSH
63088: LD_INT 5
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: PUSH
63095: LD_INT 25
63097: PUSH
63098: LD_INT 8
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 25
63107: PUSH
63108: LD_INT 9
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: LIST
63119: LIST
63120: LIST
63121: LIST
63122: LIST
63123: LIST
63124: PPUSH
63125: CALL_OW 72
63129: ST_TO_ADDR
// if not tmp then
63130: LD_VAR 0 4
63134: NOT
63135: IFFALSE 63139
// exit ;
63137: GO 66529
// for i in tmp do
63139: LD_ADDR_VAR 0 3
63143: PUSH
63144: LD_VAR 0 4
63148: PUSH
63149: FOR_IN
63150: IFFALSE 63181
// if GetTag ( i ) then
63152: LD_VAR 0 3
63156: PPUSH
63157: CALL_OW 110
63161: IFFALSE 63179
// tmp := tmp diff i ;
63163: LD_ADDR_VAR 0 4
63167: PUSH
63168: LD_VAR 0 4
63172: PUSH
63173: LD_VAR 0 3
63177: DIFF
63178: ST_TO_ADDR
63179: GO 63149
63181: POP
63182: POP
// if not tmp then
63183: LD_VAR 0 4
63187: NOT
63188: IFFALSE 63192
// exit ;
63190: GO 66529
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63192: LD_ADDR_VAR 0 5
63196: PUSH
63197: LD_EXP 61
63201: PUSH
63202: LD_VAR 0 1
63206: ARRAY
63207: PPUSH
63208: LD_INT 2
63210: PUSH
63211: LD_INT 25
63213: PUSH
63214: LD_INT 1
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 25
63223: PUSH
63224: LD_INT 5
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 25
63233: PUSH
63234: LD_INT 8
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 25
63243: PUSH
63244: LD_INT 9
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: PPUSH
63258: CALL_OW 72
63262: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
63263: LD_ADDR_VAR 0 6
63267: PUSH
63268: LD_EXP 61
63272: PUSH
63273: LD_VAR 0 1
63277: ARRAY
63278: PPUSH
63279: LD_INT 25
63281: PUSH
63282: LD_INT 2
63284: PUSH
63285: EMPTY
63286: LIST
63287: LIST
63288: PPUSH
63289: CALL_OW 72
63293: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
63294: LD_ADDR_VAR 0 7
63298: PUSH
63299: LD_EXP 61
63303: PUSH
63304: LD_VAR 0 1
63308: ARRAY
63309: PPUSH
63310: LD_INT 25
63312: PUSH
63313: LD_INT 3
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PPUSH
63320: CALL_OW 72
63324: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
63325: LD_ADDR_VAR 0 8
63329: PUSH
63330: LD_EXP 61
63334: PUSH
63335: LD_VAR 0 1
63339: ARRAY
63340: PPUSH
63341: LD_INT 25
63343: PUSH
63344: LD_INT 4
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 24
63353: PUSH
63354: LD_INT 251
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PPUSH
63365: CALL_OW 72
63369: ST_TO_ADDR
// if mc_is_defending [ base ] then
63370: LD_EXP 104
63374: PUSH
63375: LD_VAR 0 1
63379: ARRAY
63380: IFFALSE 63841
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
63382: LD_ADDR_EXP 103
63386: PUSH
63387: LD_EXP 103
63391: PPUSH
63392: LD_VAR 0 1
63396: PPUSH
63397: LD_INT 4
63399: PPUSH
63400: CALL_OW 1
63404: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63405: LD_ADDR_VAR 0 12
63409: PUSH
63410: LD_EXP 61
63414: PUSH
63415: LD_VAR 0 1
63419: ARRAY
63420: PPUSH
63421: LD_INT 2
63423: PUSH
63424: LD_INT 30
63426: PUSH
63427: LD_INT 4
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: LD_INT 30
63436: PUSH
63437: LD_INT 5
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: LIST
63448: PPUSH
63449: CALL_OW 72
63453: ST_TO_ADDR
// if not b then
63454: LD_VAR 0 12
63458: NOT
63459: IFFALSE 63463
// exit ;
63461: GO 66529
// p := [ ] ;
63463: LD_ADDR_VAR 0 11
63467: PUSH
63468: EMPTY
63469: ST_TO_ADDR
// if sci >= 2 then
63470: LD_VAR 0 8
63474: PUSH
63475: LD_INT 2
63477: GREATEREQUAL
63478: IFFALSE 63509
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
63480: LD_ADDR_VAR 0 8
63484: PUSH
63485: LD_VAR 0 8
63489: PUSH
63490: LD_INT 1
63492: ARRAY
63493: PUSH
63494: LD_VAR 0 8
63498: PUSH
63499: LD_INT 2
63501: ARRAY
63502: PUSH
63503: EMPTY
63504: LIST
63505: LIST
63506: ST_TO_ADDR
63507: GO 63570
// if sci = 1 then
63509: LD_VAR 0 8
63513: PUSH
63514: LD_INT 1
63516: EQUAL
63517: IFFALSE 63538
// sci := [ sci [ 1 ] ] else
63519: LD_ADDR_VAR 0 8
63523: PUSH
63524: LD_VAR 0 8
63528: PUSH
63529: LD_INT 1
63531: ARRAY
63532: PUSH
63533: EMPTY
63534: LIST
63535: ST_TO_ADDR
63536: GO 63570
// if sci = 0 then
63538: LD_VAR 0 8
63542: PUSH
63543: LD_INT 0
63545: EQUAL
63546: IFFALSE 63570
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
63548: LD_ADDR_VAR 0 11
63552: PUSH
63553: LD_VAR 0 4
63557: PPUSH
63558: LD_INT 4
63560: PPUSH
63561: CALL 52225 0 2
63565: PUSH
63566: LD_INT 1
63568: ARRAY
63569: ST_TO_ADDR
// if eng > 4 then
63570: LD_VAR 0 6
63574: PUSH
63575: LD_INT 4
63577: GREATER
63578: IFFALSE 63624
// for i = eng downto 4 do
63580: LD_ADDR_VAR 0 3
63584: PUSH
63585: DOUBLE
63586: LD_VAR 0 6
63590: INC
63591: ST_TO_ADDR
63592: LD_INT 4
63594: PUSH
63595: FOR_DOWNTO
63596: IFFALSE 63622
// eng := eng diff eng [ i ] ;
63598: LD_ADDR_VAR 0 6
63602: PUSH
63603: LD_VAR 0 6
63607: PUSH
63608: LD_VAR 0 6
63612: PUSH
63613: LD_VAR 0 3
63617: ARRAY
63618: DIFF
63619: ST_TO_ADDR
63620: GO 63595
63622: POP
63623: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
63624: LD_ADDR_VAR 0 4
63628: PUSH
63629: LD_VAR 0 4
63633: PUSH
63634: LD_VAR 0 5
63638: PUSH
63639: LD_VAR 0 6
63643: UNION
63644: PUSH
63645: LD_VAR 0 7
63649: UNION
63650: PUSH
63651: LD_VAR 0 8
63655: UNION
63656: DIFF
63657: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
63658: LD_ADDR_VAR 0 13
63662: PUSH
63663: LD_EXP 61
63667: PUSH
63668: LD_VAR 0 1
63672: ARRAY
63673: PPUSH
63674: LD_INT 2
63676: PUSH
63677: LD_INT 30
63679: PUSH
63680: LD_INT 32
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 30
63689: PUSH
63690: LD_INT 31
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: LIST
63701: PPUSH
63702: CALL_OW 72
63706: PUSH
63707: LD_EXP 61
63711: PUSH
63712: LD_VAR 0 1
63716: ARRAY
63717: PPUSH
63718: LD_INT 2
63720: PUSH
63721: LD_INT 30
63723: PUSH
63724: LD_INT 4
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 30
63733: PUSH
63734: LD_INT 5
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: LIST
63745: PPUSH
63746: CALL_OW 72
63750: PUSH
63751: LD_INT 6
63753: MUL
63754: PLUS
63755: ST_TO_ADDR
// if bcount < tmp then
63756: LD_VAR 0 13
63760: PUSH
63761: LD_VAR 0 4
63765: LESS
63766: IFFALSE 63812
// for i = tmp downto bcount do
63768: LD_ADDR_VAR 0 3
63772: PUSH
63773: DOUBLE
63774: LD_VAR 0 4
63778: INC
63779: ST_TO_ADDR
63780: LD_VAR 0 13
63784: PUSH
63785: FOR_DOWNTO
63786: IFFALSE 63810
// tmp := Delete ( tmp , tmp ) ;
63788: LD_ADDR_VAR 0 4
63792: PUSH
63793: LD_VAR 0 4
63797: PPUSH
63798: LD_VAR 0 4
63802: PPUSH
63803: CALL_OW 3
63807: ST_TO_ADDR
63808: GO 63785
63810: POP
63811: POP
// result := [ tmp , 0 , 0 , p ] ;
63812: LD_ADDR_VAR 0 2
63816: PUSH
63817: LD_VAR 0 4
63821: PUSH
63822: LD_INT 0
63824: PUSH
63825: LD_INT 0
63827: PUSH
63828: LD_VAR 0 11
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: ST_TO_ADDR
// exit ;
63839: GO 66529
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63841: LD_EXP 61
63845: PUSH
63846: LD_VAR 0 1
63850: ARRAY
63851: PPUSH
63852: LD_INT 2
63854: PUSH
63855: LD_INT 30
63857: PUSH
63858: LD_INT 6
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: PUSH
63865: LD_INT 30
63867: PUSH
63868: LD_INT 7
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 30
63877: PUSH
63878: LD_INT 8
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: PPUSH
63891: CALL_OW 72
63895: NOT
63896: PUSH
63897: LD_EXP 61
63901: PUSH
63902: LD_VAR 0 1
63906: ARRAY
63907: PPUSH
63908: LD_INT 30
63910: PUSH
63911: LD_INT 3
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: PPUSH
63918: CALL_OW 72
63922: NOT
63923: AND
63924: IFFALSE 63996
// begin if eng = tmp then
63926: LD_VAR 0 6
63930: PUSH
63931: LD_VAR 0 4
63935: EQUAL
63936: IFFALSE 63940
// exit ;
63938: GO 66529
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
63940: LD_ADDR_EXP 103
63944: PUSH
63945: LD_EXP 103
63949: PPUSH
63950: LD_VAR 0 1
63954: PPUSH
63955: LD_INT 1
63957: PPUSH
63958: CALL_OW 1
63962: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
63963: LD_ADDR_VAR 0 2
63967: PUSH
63968: LD_INT 0
63970: PUSH
63971: LD_VAR 0 4
63975: PUSH
63976: LD_VAR 0 6
63980: DIFF
63981: PUSH
63982: LD_INT 0
63984: PUSH
63985: LD_INT 0
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: ST_TO_ADDR
// exit ;
63994: GO 66529
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63996: LD_EXP 88
64000: PUSH
64001: LD_EXP 87
64005: PUSH
64006: LD_VAR 0 1
64010: ARRAY
64011: ARRAY
64012: PUSH
64013: LD_EXP 61
64017: PUSH
64018: LD_VAR 0 1
64022: ARRAY
64023: PPUSH
64024: LD_INT 2
64026: PUSH
64027: LD_INT 30
64029: PUSH
64030: LD_INT 6
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: LD_INT 30
64039: PUSH
64040: LD_INT 7
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: LD_INT 30
64049: PUSH
64050: LD_INT 8
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PUSH
64057: EMPTY
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: PPUSH
64063: CALL_OW 72
64067: AND
64068: PUSH
64069: LD_EXP 61
64073: PUSH
64074: LD_VAR 0 1
64078: ARRAY
64079: PPUSH
64080: LD_INT 30
64082: PUSH
64083: LD_INT 3
64085: PUSH
64086: EMPTY
64087: LIST
64088: LIST
64089: PPUSH
64090: CALL_OW 72
64094: NOT
64095: AND
64096: IFFALSE 64310
// begin if sci >= 6 then
64098: LD_VAR 0 8
64102: PUSH
64103: LD_INT 6
64105: GREATEREQUAL
64106: IFFALSE 64110
// exit ;
64108: GO 66529
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
64110: LD_ADDR_EXP 103
64114: PUSH
64115: LD_EXP 103
64119: PPUSH
64120: LD_VAR 0 1
64124: PPUSH
64125: LD_INT 2
64127: PPUSH
64128: CALL_OW 1
64132: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
64133: LD_ADDR_VAR 0 9
64137: PUSH
64138: LD_VAR 0 4
64142: PUSH
64143: LD_VAR 0 8
64147: DIFF
64148: PPUSH
64149: LD_INT 4
64151: PPUSH
64152: CALL 52225 0 2
64156: ST_TO_ADDR
// p := [ ] ;
64157: LD_ADDR_VAR 0 11
64161: PUSH
64162: EMPTY
64163: ST_TO_ADDR
// if sci < 6 and sort > 6 then
64164: LD_VAR 0 8
64168: PUSH
64169: LD_INT 6
64171: LESS
64172: PUSH
64173: LD_VAR 0 9
64177: PUSH
64178: LD_INT 6
64180: GREATER
64181: AND
64182: IFFALSE 64263
// begin for i = 1 to 6 - sci do
64184: LD_ADDR_VAR 0 3
64188: PUSH
64189: DOUBLE
64190: LD_INT 1
64192: DEC
64193: ST_TO_ADDR
64194: LD_INT 6
64196: PUSH
64197: LD_VAR 0 8
64201: MINUS
64202: PUSH
64203: FOR_TO
64204: IFFALSE 64259
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
64206: LD_ADDR_VAR 0 11
64210: PUSH
64211: LD_VAR 0 11
64215: PPUSH
64216: LD_VAR 0 11
64220: PUSH
64221: LD_INT 1
64223: PLUS
64224: PPUSH
64225: LD_VAR 0 9
64229: PUSH
64230: LD_INT 1
64232: ARRAY
64233: PPUSH
64234: CALL_OW 2
64238: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
64239: LD_ADDR_VAR 0 9
64243: PUSH
64244: LD_VAR 0 9
64248: PPUSH
64249: LD_INT 1
64251: PPUSH
64252: CALL_OW 3
64256: ST_TO_ADDR
// end ;
64257: GO 64203
64259: POP
64260: POP
// end else
64261: GO 64283
// if sort then
64263: LD_VAR 0 9
64267: IFFALSE 64283
// p := sort [ 1 ] ;
64269: LD_ADDR_VAR 0 11
64273: PUSH
64274: LD_VAR 0 9
64278: PUSH
64279: LD_INT 1
64281: ARRAY
64282: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
64283: LD_ADDR_VAR 0 2
64287: PUSH
64288: LD_INT 0
64290: PUSH
64291: LD_INT 0
64293: PUSH
64294: LD_INT 0
64296: PUSH
64297: LD_VAR 0 11
64301: PUSH
64302: EMPTY
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: ST_TO_ADDR
// exit ;
64308: GO 66529
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
64310: LD_EXP 88
64314: PUSH
64315: LD_EXP 87
64319: PUSH
64320: LD_VAR 0 1
64324: ARRAY
64325: ARRAY
64326: PUSH
64327: LD_EXP 61
64331: PUSH
64332: LD_VAR 0 1
64336: ARRAY
64337: PPUSH
64338: LD_INT 2
64340: PUSH
64341: LD_INT 30
64343: PUSH
64344: LD_INT 6
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 30
64353: PUSH
64354: LD_INT 7
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PUSH
64361: LD_INT 30
64363: PUSH
64364: LD_INT 8
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: LIST
64375: LIST
64376: PPUSH
64377: CALL_OW 72
64381: AND
64382: PUSH
64383: LD_EXP 61
64387: PUSH
64388: LD_VAR 0 1
64392: ARRAY
64393: PPUSH
64394: LD_INT 30
64396: PUSH
64397: LD_INT 3
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: PPUSH
64404: CALL_OW 72
64408: AND
64409: IFFALSE 65143
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
64411: LD_ADDR_EXP 103
64415: PUSH
64416: LD_EXP 103
64420: PPUSH
64421: LD_VAR 0 1
64425: PPUSH
64426: LD_INT 3
64428: PPUSH
64429: CALL_OW 1
64433: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64434: LD_ADDR_VAR 0 2
64438: PUSH
64439: LD_INT 0
64441: PUSH
64442: LD_INT 0
64444: PUSH
64445: LD_INT 0
64447: PUSH
64448: LD_INT 0
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: ST_TO_ADDR
// if not eng then
64457: LD_VAR 0 6
64461: NOT
64462: IFFALSE 64525
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
64464: LD_ADDR_VAR 0 11
64468: PUSH
64469: LD_VAR 0 4
64473: PPUSH
64474: LD_INT 2
64476: PPUSH
64477: CALL 52225 0 2
64481: PUSH
64482: LD_INT 1
64484: ARRAY
64485: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
64486: LD_ADDR_VAR 0 2
64490: PUSH
64491: LD_VAR 0 2
64495: PPUSH
64496: LD_INT 2
64498: PPUSH
64499: LD_VAR 0 11
64503: PPUSH
64504: CALL_OW 1
64508: ST_TO_ADDR
// tmp := tmp diff p ;
64509: LD_ADDR_VAR 0 4
64513: PUSH
64514: LD_VAR 0 4
64518: PUSH
64519: LD_VAR 0 11
64523: DIFF
64524: ST_TO_ADDR
// end ; if tmp and sci < 6 then
64525: LD_VAR 0 4
64529: PUSH
64530: LD_VAR 0 8
64534: PUSH
64535: LD_INT 6
64537: LESS
64538: AND
64539: IFFALSE 64727
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
64541: LD_ADDR_VAR 0 9
64545: PUSH
64546: LD_VAR 0 4
64550: PUSH
64551: LD_VAR 0 8
64555: PUSH
64556: LD_VAR 0 7
64560: UNION
64561: DIFF
64562: PPUSH
64563: LD_INT 4
64565: PPUSH
64566: CALL 52225 0 2
64570: ST_TO_ADDR
// p := [ ] ;
64571: LD_ADDR_VAR 0 11
64575: PUSH
64576: EMPTY
64577: ST_TO_ADDR
// if sort then
64578: LD_VAR 0 9
64582: IFFALSE 64698
// for i = 1 to 6 - sci do
64584: LD_ADDR_VAR 0 3
64588: PUSH
64589: DOUBLE
64590: LD_INT 1
64592: DEC
64593: ST_TO_ADDR
64594: LD_INT 6
64596: PUSH
64597: LD_VAR 0 8
64601: MINUS
64602: PUSH
64603: FOR_TO
64604: IFFALSE 64696
// begin if i = sort then
64606: LD_VAR 0 3
64610: PUSH
64611: LD_VAR 0 9
64615: EQUAL
64616: IFFALSE 64620
// break ;
64618: GO 64696
// if GetClass ( i ) = 4 then
64620: LD_VAR 0 3
64624: PPUSH
64625: CALL_OW 257
64629: PUSH
64630: LD_INT 4
64632: EQUAL
64633: IFFALSE 64637
// continue ;
64635: GO 64603
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64637: LD_ADDR_VAR 0 11
64641: PUSH
64642: LD_VAR 0 11
64646: PPUSH
64647: LD_VAR 0 11
64651: PUSH
64652: LD_INT 1
64654: PLUS
64655: PPUSH
64656: LD_VAR 0 9
64660: PUSH
64661: LD_VAR 0 3
64665: ARRAY
64666: PPUSH
64667: CALL_OW 2
64671: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64672: LD_ADDR_VAR 0 4
64676: PUSH
64677: LD_VAR 0 4
64681: PUSH
64682: LD_VAR 0 9
64686: PUSH
64687: LD_VAR 0 3
64691: ARRAY
64692: DIFF
64693: ST_TO_ADDR
// end ;
64694: GO 64603
64696: POP
64697: POP
// if p then
64698: LD_VAR 0 11
64702: IFFALSE 64727
// result := Replace ( result , 4 , p ) ;
64704: LD_ADDR_VAR 0 2
64708: PUSH
64709: LD_VAR 0 2
64713: PPUSH
64714: LD_INT 4
64716: PPUSH
64717: LD_VAR 0 11
64721: PPUSH
64722: CALL_OW 1
64726: ST_TO_ADDR
// end ; if tmp and mech < 6 then
64727: LD_VAR 0 4
64731: PUSH
64732: LD_VAR 0 7
64736: PUSH
64737: LD_INT 6
64739: LESS
64740: AND
64741: IFFALSE 64929
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64743: LD_ADDR_VAR 0 9
64747: PUSH
64748: LD_VAR 0 4
64752: PUSH
64753: LD_VAR 0 8
64757: PUSH
64758: LD_VAR 0 7
64762: UNION
64763: DIFF
64764: PPUSH
64765: LD_INT 3
64767: PPUSH
64768: CALL 52225 0 2
64772: ST_TO_ADDR
// p := [ ] ;
64773: LD_ADDR_VAR 0 11
64777: PUSH
64778: EMPTY
64779: ST_TO_ADDR
// if sort then
64780: LD_VAR 0 9
64784: IFFALSE 64900
// for i = 1 to 6 - mech do
64786: LD_ADDR_VAR 0 3
64790: PUSH
64791: DOUBLE
64792: LD_INT 1
64794: DEC
64795: ST_TO_ADDR
64796: LD_INT 6
64798: PUSH
64799: LD_VAR 0 7
64803: MINUS
64804: PUSH
64805: FOR_TO
64806: IFFALSE 64898
// begin if i = sort then
64808: LD_VAR 0 3
64812: PUSH
64813: LD_VAR 0 9
64817: EQUAL
64818: IFFALSE 64822
// break ;
64820: GO 64898
// if GetClass ( i ) = 3 then
64822: LD_VAR 0 3
64826: PPUSH
64827: CALL_OW 257
64831: PUSH
64832: LD_INT 3
64834: EQUAL
64835: IFFALSE 64839
// continue ;
64837: GO 64805
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64839: LD_ADDR_VAR 0 11
64843: PUSH
64844: LD_VAR 0 11
64848: PPUSH
64849: LD_VAR 0 11
64853: PUSH
64854: LD_INT 1
64856: PLUS
64857: PPUSH
64858: LD_VAR 0 9
64862: PUSH
64863: LD_VAR 0 3
64867: ARRAY
64868: PPUSH
64869: CALL_OW 2
64873: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64874: LD_ADDR_VAR 0 4
64878: PUSH
64879: LD_VAR 0 4
64883: PUSH
64884: LD_VAR 0 9
64888: PUSH
64889: LD_VAR 0 3
64893: ARRAY
64894: DIFF
64895: ST_TO_ADDR
// end ;
64896: GO 64805
64898: POP
64899: POP
// if p then
64900: LD_VAR 0 11
64904: IFFALSE 64929
// result := Replace ( result , 3 , p ) ;
64906: LD_ADDR_VAR 0 2
64910: PUSH
64911: LD_VAR 0 2
64915: PPUSH
64916: LD_INT 3
64918: PPUSH
64919: LD_VAR 0 11
64923: PPUSH
64924: CALL_OW 1
64928: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
64929: LD_VAR 0 4
64933: PUSH
64934: LD_INT 6
64936: GREATER
64937: PUSH
64938: LD_VAR 0 6
64942: PUSH
64943: LD_INT 6
64945: LESS
64946: AND
64947: IFFALSE 65141
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64949: LD_ADDR_VAR 0 9
64953: PUSH
64954: LD_VAR 0 4
64958: PUSH
64959: LD_VAR 0 8
64963: PUSH
64964: LD_VAR 0 7
64968: UNION
64969: PUSH
64970: LD_VAR 0 6
64974: UNION
64975: DIFF
64976: PPUSH
64977: LD_INT 2
64979: PPUSH
64980: CALL 52225 0 2
64984: ST_TO_ADDR
// p := [ ] ;
64985: LD_ADDR_VAR 0 11
64989: PUSH
64990: EMPTY
64991: ST_TO_ADDR
// if sort then
64992: LD_VAR 0 9
64996: IFFALSE 65112
// for i = 1 to 6 - eng do
64998: LD_ADDR_VAR 0 3
65002: PUSH
65003: DOUBLE
65004: LD_INT 1
65006: DEC
65007: ST_TO_ADDR
65008: LD_INT 6
65010: PUSH
65011: LD_VAR 0 6
65015: MINUS
65016: PUSH
65017: FOR_TO
65018: IFFALSE 65110
// begin if i = sort then
65020: LD_VAR 0 3
65024: PUSH
65025: LD_VAR 0 9
65029: EQUAL
65030: IFFALSE 65034
// break ;
65032: GO 65110
// if GetClass ( i ) = 2 then
65034: LD_VAR 0 3
65038: PPUSH
65039: CALL_OW 257
65043: PUSH
65044: LD_INT 2
65046: EQUAL
65047: IFFALSE 65051
// continue ;
65049: GO 65017
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65051: LD_ADDR_VAR 0 11
65055: PUSH
65056: LD_VAR 0 11
65060: PPUSH
65061: LD_VAR 0 11
65065: PUSH
65066: LD_INT 1
65068: PLUS
65069: PPUSH
65070: LD_VAR 0 9
65074: PUSH
65075: LD_VAR 0 3
65079: ARRAY
65080: PPUSH
65081: CALL_OW 2
65085: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65086: LD_ADDR_VAR 0 4
65090: PUSH
65091: LD_VAR 0 4
65095: PUSH
65096: LD_VAR 0 9
65100: PUSH
65101: LD_VAR 0 3
65105: ARRAY
65106: DIFF
65107: ST_TO_ADDR
// end ;
65108: GO 65017
65110: POP
65111: POP
// if p then
65112: LD_VAR 0 11
65116: IFFALSE 65141
// result := Replace ( result , 2 , p ) ;
65118: LD_ADDR_VAR 0 2
65122: PUSH
65123: LD_VAR 0 2
65127: PPUSH
65128: LD_INT 2
65130: PPUSH
65131: LD_VAR 0 11
65135: PPUSH
65136: CALL_OW 1
65140: ST_TO_ADDR
// end ; exit ;
65141: GO 66529
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
65143: LD_EXP 88
65147: PUSH
65148: LD_EXP 87
65152: PUSH
65153: LD_VAR 0 1
65157: ARRAY
65158: ARRAY
65159: NOT
65160: PUSH
65161: LD_EXP 61
65165: PUSH
65166: LD_VAR 0 1
65170: ARRAY
65171: PPUSH
65172: LD_INT 30
65174: PUSH
65175: LD_INT 3
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: PPUSH
65182: CALL_OW 72
65186: AND
65187: PUSH
65188: LD_EXP 66
65192: PUSH
65193: LD_VAR 0 1
65197: ARRAY
65198: AND
65199: IFFALSE 65807
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
65201: LD_ADDR_EXP 103
65205: PUSH
65206: LD_EXP 103
65210: PPUSH
65211: LD_VAR 0 1
65215: PPUSH
65216: LD_INT 5
65218: PPUSH
65219: CALL_OW 1
65223: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65224: LD_ADDR_VAR 0 2
65228: PUSH
65229: LD_INT 0
65231: PUSH
65232: LD_INT 0
65234: PUSH
65235: LD_INT 0
65237: PUSH
65238: LD_INT 0
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: ST_TO_ADDR
// if sci > 1 then
65247: LD_VAR 0 8
65251: PUSH
65252: LD_INT 1
65254: GREATER
65255: IFFALSE 65283
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
65257: LD_ADDR_VAR 0 4
65261: PUSH
65262: LD_VAR 0 4
65266: PUSH
65267: LD_VAR 0 8
65271: PUSH
65272: LD_VAR 0 8
65276: PUSH
65277: LD_INT 1
65279: ARRAY
65280: DIFF
65281: DIFF
65282: ST_TO_ADDR
// if tmp and not sci then
65283: LD_VAR 0 4
65287: PUSH
65288: LD_VAR 0 8
65292: NOT
65293: AND
65294: IFFALSE 65363
// begin sort := SortBySkill ( tmp , 4 ) ;
65296: LD_ADDR_VAR 0 9
65300: PUSH
65301: LD_VAR 0 4
65305: PPUSH
65306: LD_INT 4
65308: PPUSH
65309: CALL 52225 0 2
65313: ST_TO_ADDR
// if sort then
65314: LD_VAR 0 9
65318: IFFALSE 65334
// p := sort [ 1 ] ;
65320: LD_ADDR_VAR 0 11
65324: PUSH
65325: LD_VAR 0 9
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: ST_TO_ADDR
// if p then
65334: LD_VAR 0 11
65338: IFFALSE 65363
// result := Replace ( result , 4 , p ) ;
65340: LD_ADDR_VAR 0 2
65344: PUSH
65345: LD_VAR 0 2
65349: PPUSH
65350: LD_INT 4
65352: PPUSH
65353: LD_VAR 0 11
65357: PPUSH
65358: CALL_OW 1
65362: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
65363: LD_ADDR_VAR 0 4
65367: PUSH
65368: LD_VAR 0 4
65372: PUSH
65373: LD_VAR 0 7
65377: DIFF
65378: ST_TO_ADDR
// if tmp and mech < 6 then
65379: LD_VAR 0 4
65383: PUSH
65384: LD_VAR 0 7
65388: PUSH
65389: LD_INT 6
65391: LESS
65392: AND
65393: IFFALSE 65581
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
65395: LD_ADDR_VAR 0 9
65399: PUSH
65400: LD_VAR 0 4
65404: PUSH
65405: LD_VAR 0 8
65409: PUSH
65410: LD_VAR 0 7
65414: UNION
65415: DIFF
65416: PPUSH
65417: LD_INT 3
65419: PPUSH
65420: CALL 52225 0 2
65424: ST_TO_ADDR
// p := [ ] ;
65425: LD_ADDR_VAR 0 11
65429: PUSH
65430: EMPTY
65431: ST_TO_ADDR
// if sort then
65432: LD_VAR 0 9
65436: IFFALSE 65552
// for i = 1 to 6 - mech do
65438: LD_ADDR_VAR 0 3
65442: PUSH
65443: DOUBLE
65444: LD_INT 1
65446: DEC
65447: ST_TO_ADDR
65448: LD_INT 6
65450: PUSH
65451: LD_VAR 0 7
65455: MINUS
65456: PUSH
65457: FOR_TO
65458: IFFALSE 65550
// begin if i = sort then
65460: LD_VAR 0 3
65464: PUSH
65465: LD_VAR 0 9
65469: EQUAL
65470: IFFALSE 65474
// break ;
65472: GO 65550
// if GetClass ( i ) = 3 then
65474: LD_VAR 0 3
65478: PPUSH
65479: CALL_OW 257
65483: PUSH
65484: LD_INT 3
65486: EQUAL
65487: IFFALSE 65491
// continue ;
65489: GO 65457
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65491: LD_ADDR_VAR 0 11
65495: PUSH
65496: LD_VAR 0 11
65500: PPUSH
65501: LD_VAR 0 11
65505: PUSH
65506: LD_INT 1
65508: PLUS
65509: PPUSH
65510: LD_VAR 0 9
65514: PUSH
65515: LD_VAR 0 3
65519: ARRAY
65520: PPUSH
65521: CALL_OW 2
65525: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65526: LD_ADDR_VAR 0 4
65530: PUSH
65531: LD_VAR 0 4
65535: PUSH
65536: LD_VAR 0 9
65540: PUSH
65541: LD_VAR 0 3
65545: ARRAY
65546: DIFF
65547: ST_TO_ADDR
// end ;
65548: GO 65457
65550: POP
65551: POP
// if p then
65552: LD_VAR 0 11
65556: IFFALSE 65581
// result := Replace ( result , 3 , p ) ;
65558: LD_ADDR_VAR 0 2
65562: PUSH
65563: LD_VAR 0 2
65567: PPUSH
65568: LD_INT 3
65570: PPUSH
65571: LD_VAR 0 11
65575: PPUSH
65576: CALL_OW 1
65580: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65581: LD_ADDR_VAR 0 4
65585: PUSH
65586: LD_VAR 0 4
65590: PUSH
65591: LD_VAR 0 6
65595: DIFF
65596: ST_TO_ADDR
// if tmp and eng < 6 then
65597: LD_VAR 0 4
65601: PUSH
65602: LD_VAR 0 6
65606: PUSH
65607: LD_INT 6
65609: LESS
65610: AND
65611: IFFALSE 65805
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
65613: LD_ADDR_VAR 0 9
65617: PUSH
65618: LD_VAR 0 4
65622: PUSH
65623: LD_VAR 0 8
65627: PUSH
65628: LD_VAR 0 7
65632: UNION
65633: PUSH
65634: LD_VAR 0 6
65638: UNION
65639: DIFF
65640: PPUSH
65641: LD_INT 2
65643: PPUSH
65644: CALL 52225 0 2
65648: ST_TO_ADDR
// p := [ ] ;
65649: LD_ADDR_VAR 0 11
65653: PUSH
65654: EMPTY
65655: ST_TO_ADDR
// if sort then
65656: LD_VAR 0 9
65660: IFFALSE 65776
// for i = 1 to 6 - eng do
65662: LD_ADDR_VAR 0 3
65666: PUSH
65667: DOUBLE
65668: LD_INT 1
65670: DEC
65671: ST_TO_ADDR
65672: LD_INT 6
65674: PUSH
65675: LD_VAR 0 6
65679: MINUS
65680: PUSH
65681: FOR_TO
65682: IFFALSE 65774
// begin if i = sort then
65684: LD_VAR 0 3
65688: PUSH
65689: LD_VAR 0 9
65693: EQUAL
65694: IFFALSE 65698
// break ;
65696: GO 65774
// if GetClass ( i ) = 2 then
65698: LD_VAR 0 3
65702: PPUSH
65703: CALL_OW 257
65707: PUSH
65708: LD_INT 2
65710: EQUAL
65711: IFFALSE 65715
// continue ;
65713: GO 65681
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65715: LD_ADDR_VAR 0 11
65719: PUSH
65720: LD_VAR 0 11
65724: PPUSH
65725: LD_VAR 0 11
65729: PUSH
65730: LD_INT 1
65732: PLUS
65733: PPUSH
65734: LD_VAR 0 9
65738: PUSH
65739: LD_VAR 0 3
65743: ARRAY
65744: PPUSH
65745: CALL_OW 2
65749: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65750: LD_ADDR_VAR 0 4
65754: PUSH
65755: LD_VAR 0 4
65759: PUSH
65760: LD_VAR 0 9
65764: PUSH
65765: LD_VAR 0 3
65769: ARRAY
65770: DIFF
65771: ST_TO_ADDR
// end ;
65772: GO 65681
65774: POP
65775: POP
// if p then
65776: LD_VAR 0 11
65780: IFFALSE 65805
// result := Replace ( result , 2 , p ) ;
65782: LD_ADDR_VAR 0 2
65786: PUSH
65787: LD_VAR 0 2
65791: PPUSH
65792: LD_INT 2
65794: PPUSH
65795: LD_VAR 0 11
65799: PPUSH
65800: CALL_OW 1
65804: ST_TO_ADDR
// end ; exit ;
65805: GO 66529
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
65807: LD_EXP 88
65811: PUSH
65812: LD_EXP 87
65816: PUSH
65817: LD_VAR 0 1
65821: ARRAY
65822: ARRAY
65823: NOT
65824: PUSH
65825: LD_EXP 61
65829: PUSH
65830: LD_VAR 0 1
65834: ARRAY
65835: PPUSH
65836: LD_INT 30
65838: PUSH
65839: LD_INT 3
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PPUSH
65846: CALL_OW 72
65850: AND
65851: PUSH
65852: LD_EXP 66
65856: PUSH
65857: LD_VAR 0 1
65861: ARRAY
65862: NOT
65863: AND
65864: IFFALSE 66529
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
65866: LD_ADDR_EXP 103
65870: PUSH
65871: LD_EXP 103
65875: PPUSH
65876: LD_VAR 0 1
65880: PPUSH
65881: LD_INT 6
65883: PPUSH
65884: CALL_OW 1
65888: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
65889: LD_ADDR_VAR 0 2
65893: PUSH
65894: LD_INT 0
65896: PUSH
65897: LD_INT 0
65899: PUSH
65900: LD_INT 0
65902: PUSH
65903: LD_INT 0
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: ST_TO_ADDR
// if sci >= 1 then
65912: LD_VAR 0 8
65916: PUSH
65917: LD_INT 1
65919: GREATEREQUAL
65920: IFFALSE 65942
// tmp := tmp diff sci [ 1 ] ;
65922: LD_ADDR_VAR 0 4
65926: PUSH
65927: LD_VAR 0 4
65931: PUSH
65932: LD_VAR 0 8
65936: PUSH
65937: LD_INT 1
65939: ARRAY
65940: DIFF
65941: ST_TO_ADDR
// if tmp and not sci then
65942: LD_VAR 0 4
65946: PUSH
65947: LD_VAR 0 8
65951: NOT
65952: AND
65953: IFFALSE 66022
// begin sort := SortBySkill ( tmp , 4 ) ;
65955: LD_ADDR_VAR 0 9
65959: PUSH
65960: LD_VAR 0 4
65964: PPUSH
65965: LD_INT 4
65967: PPUSH
65968: CALL 52225 0 2
65972: ST_TO_ADDR
// if sort then
65973: LD_VAR 0 9
65977: IFFALSE 65993
// p := sort [ 1 ] ;
65979: LD_ADDR_VAR 0 11
65983: PUSH
65984: LD_VAR 0 9
65988: PUSH
65989: LD_INT 1
65991: ARRAY
65992: ST_TO_ADDR
// if p then
65993: LD_VAR 0 11
65997: IFFALSE 66022
// result := Replace ( result , 4 , p ) ;
65999: LD_ADDR_VAR 0 2
66003: PUSH
66004: LD_VAR 0 2
66008: PPUSH
66009: LD_INT 4
66011: PPUSH
66012: LD_VAR 0 11
66016: PPUSH
66017: CALL_OW 1
66021: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
66022: LD_ADDR_VAR 0 4
66026: PUSH
66027: LD_VAR 0 4
66031: PUSH
66032: LD_VAR 0 7
66036: DIFF
66037: ST_TO_ADDR
// if tmp and mech < 6 then
66038: LD_VAR 0 4
66042: PUSH
66043: LD_VAR 0 7
66047: PUSH
66048: LD_INT 6
66050: LESS
66051: AND
66052: IFFALSE 66234
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
66054: LD_ADDR_VAR 0 9
66058: PUSH
66059: LD_VAR 0 4
66063: PUSH
66064: LD_VAR 0 7
66068: DIFF
66069: PPUSH
66070: LD_INT 3
66072: PPUSH
66073: CALL 52225 0 2
66077: ST_TO_ADDR
// p := [ ] ;
66078: LD_ADDR_VAR 0 11
66082: PUSH
66083: EMPTY
66084: ST_TO_ADDR
// if sort then
66085: LD_VAR 0 9
66089: IFFALSE 66205
// for i = 1 to 6 - mech do
66091: LD_ADDR_VAR 0 3
66095: PUSH
66096: DOUBLE
66097: LD_INT 1
66099: DEC
66100: ST_TO_ADDR
66101: LD_INT 6
66103: PUSH
66104: LD_VAR 0 7
66108: MINUS
66109: PUSH
66110: FOR_TO
66111: IFFALSE 66203
// begin if i = sort then
66113: LD_VAR 0 3
66117: PUSH
66118: LD_VAR 0 9
66122: EQUAL
66123: IFFALSE 66127
// break ;
66125: GO 66203
// if GetClass ( i ) = 3 then
66127: LD_VAR 0 3
66131: PPUSH
66132: CALL_OW 257
66136: PUSH
66137: LD_INT 3
66139: EQUAL
66140: IFFALSE 66144
// continue ;
66142: GO 66110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66144: LD_ADDR_VAR 0 11
66148: PUSH
66149: LD_VAR 0 11
66153: PPUSH
66154: LD_VAR 0 11
66158: PUSH
66159: LD_INT 1
66161: PLUS
66162: PPUSH
66163: LD_VAR 0 9
66167: PUSH
66168: LD_VAR 0 3
66172: ARRAY
66173: PPUSH
66174: CALL_OW 2
66178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66179: LD_ADDR_VAR 0 4
66183: PUSH
66184: LD_VAR 0 4
66188: PUSH
66189: LD_VAR 0 9
66193: PUSH
66194: LD_VAR 0 3
66198: ARRAY
66199: DIFF
66200: ST_TO_ADDR
// end ;
66201: GO 66110
66203: POP
66204: POP
// if p then
66205: LD_VAR 0 11
66209: IFFALSE 66234
// result := Replace ( result , 3 , p ) ;
66211: LD_ADDR_VAR 0 2
66215: PUSH
66216: LD_VAR 0 2
66220: PPUSH
66221: LD_INT 3
66223: PPUSH
66224: LD_VAR 0 11
66228: PPUSH
66229: CALL_OW 1
66233: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
66234: LD_ADDR_VAR 0 4
66238: PUSH
66239: LD_VAR 0 4
66243: PUSH
66244: LD_VAR 0 6
66248: DIFF
66249: ST_TO_ADDR
// if tmp and eng < 4 then
66250: LD_VAR 0 4
66254: PUSH
66255: LD_VAR 0 6
66259: PUSH
66260: LD_INT 4
66262: LESS
66263: AND
66264: IFFALSE 66454
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
66266: LD_ADDR_VAR 0 9
66270: PUSH
66271: LD_VAR 0 4
66275: PUSH
66276: LD_VAR 0 7
66280: PUSH
66281: LD_VAR 0 6
66285: UNION
66286: DIFF
66287: PPUSH
66288: LD_INT 2
66290: PPUSH
66291: CALL 52225 0 2
66295: ST_TO_ADDR
// p := [ ] ;
66296: LD_ADDR_VAR 0 11
66300: PUSH
66301: EMPTY
66302: ST_TO_ADDR
// if sort then
66303: LD_VAR 0 9
66307: IFFALSE 66423
// for i = 1 to 4 - eng do
66309: LD_ADDR_VAR 0 3
66313: PUSH
66314: DOUBLE
66315: LD_INT 1
66317: DEC
66318: ST_TO_ADDR
66319: LD_INT 4
66321: PUSH
66322: LD_VAR 0 6
66326: MINUS
66327: PUSH
66328: FOR_TO
66329: IFFALSE 66421
// begin if i = sort then
66331: LD_VAR 0 3
66335: PUSH
66336: LD_VAR 0 9
66340: EQUAL
66341: IFFALSE 66345
// break ;
66343: GO 66421
// if GetClass ( i ) = 2 then
66345: LD_VAR 0 3
66349: PPUSH
66350: CALL_OW 257
66354: PUSH
66355: LD_INT 2
66357: EQUAL
66358: IFFALSE 66362
// continue ;
66360: GO 66328
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66362: LD_ADDR_VAR 0 11
66366: PUSH
66367: LD_VAR 0 11
66371: PPUSH
66372: LD_VAR 0 11
66376: PUSH
66377: LD_INT 1
66379: PLUS
66380: PPUSH
66381: LD_VAR 0 9
66385: PUSH
66386: LD_VAR 0 3
66390: ARRAY
66391: PPUSH
66392: CALL_OW 2
66396: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66397: LD_ADDR_VAR 0 4
66401: PUSH
66402: LD_VAR 0 4
66406: PUSH
66407: LD_VAR 0 9
66411: PUSH
66412: LD_VAR 0 3
66416: ARRAY
66417: DIFF
66418: ST_TO_ADDR
// end ;
66419: GO 66328
66421: POP
66422: POP
// if p then
66423: LD_VAR 0 11
66427: IFFALSE 66452
// result := Replace ( result , 2 , p ) ;
66429: LD_ADDR_VAR 0 2
66433: PUSH
66434: LD_VAR 0 2
66438: PPUSH
66439: LD_INT 2
66441: PPUSH
66442: LD_VAR 0 11
66446: PPUSH
66447: CALL_OW 1
66451: ST_TO_ADDR
// end else
66452: GO 66498
// for i = eng downto 5 do
66454: LD_ADDR_VAR 0 3
66458: PUSH
66459: DOUBLE
66460: LD_VAR 0 6
66464: INC
66465: ST_TO_ADDR
66466: LD_INT 5
66468: PUSH
66469: FOR_DOWNTO
66470: IFFALSE 66496
// tmp := tmp union eng [ i ] ;
66472: LD_ADDR_VAR 0 4
66476: PUSH
66477: LD_VAR 0 4
66481: PUSH
66482: LD_VAR 0 6
66486: PUSH
66487: LD_VAR 0 3
66491: ARRAY
66492: UNION
66493: ST_TO_ADDR
66494: GO 66469
66496: POP
66497: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
66498: LD_ADDR_VAR 0 2
66502: PUSH
66503: LD_VAR 0 2
66507: PPUSH
66508: LD_INT 1
66510: PPUSH
66511: LD_VAR 0 4
66515: PUSH
66516: LD_VAR 0 5
66520: DIFF
66521: PPUSH
66522: CALL_OW 1
66526: ST_TO_ADDR
// exit ;
66527: GO 66529
// end ; end ;
66529: LD_VAR 0 2
66533: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
66534: LD_INT 0
66536: PPUSH
66537: PPUSH
66538: PPUSH
// if not mc_bases then
66539: LD_EXP 61
66543: NOT
66544: IFFALSE 66548
// exit ;
66546: GO 66690
// for i = 1 to mc_bases do
66548: LD_ADDR_VAR 0 2
66552: PUSH
66553: DOUBLE
66554: LD_INT 1
66556: DEC
66557: ST_TO_ADDR
66558: LD_EXP 61
66562: PUSH
66563: FOR_TO
66564: IFFALSE 66681
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
66566: LD_ADDR_VAR 0 3
66570: PUSH
66571: LD_EXP 61
66575: PUSH
66576: LD_VAR 0 2
66580: ARRAY
66581: PPUSH
66582: LD_INT 21
66584: PUSH
66585: LD_INT 3
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 3
66594: PUSH
66595: LD_INT 2
66597: PUSH
66598: LD_INT 30
66600: PUSH
66601: LD_INT 29
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PUSH
66608: LD_INT 30
66610: PUSH
66611: LD_INT 30
66613: PUSH
66614: EMPTY
66615: LIST
66616: LIST
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: LIST
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 3
66629: PUSH
66630: LD_INT 24
66632: PUSH
66633: LD_INT 1000
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: LIST
66648: PPUSH
66649: CALL_OW 72
66653: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
66654: LD_ADDR_EXP 62
66658: PUSH
66659: LD_EXP 62
66663: PPUSH
66664: LD_VAR 0 2
66668: PPUSH
66669: LD_VAR 0 3
66673: PPUSH
66674: CALL_OW 1
66678: ST_TO_ADDR
// end ;
66679: GO 66563
66681: POP
66682: POP
// RaiseSailEvent ( 101 ) ;
66683: LD_INT 101
66685: PPUSH
66686: CALL_OW 427
// end ;
66690: LD_VAR 0 1
66694: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
66695: LD_INT 0
66697: PPUSH
66698: PPUSH
66699: PPUSH
66700: PPUSH
66701: PPUSH
66702: PPUSH
66703: PPUSH
// if not mc_bases then
66704: LD_EXP 61
66708: NOT
66709: IFFALSE 66713
// exit ;
66711: GO 67275
// for i = 1 to mc_bases do
66713: LD_ADDR_VAR 0 2
66717: PUSH
66718: DOUBLE
66719: LD_INT 1
66721: DEC
66722: ST_TO_ADDR
66723: LD_EXP 61
66727: PUSH
66728: FOR_TO
66729: IFFALSE 67266
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
66731: LD_ADDR_VAR 0 5
66735: PUSH
66736: LD_EXP 61
66740: PUSH
66741: LD_VAR 0 2
66745: ARRAY
66746: PUSH
66747: LD_EXP 90
66751: PUSH
66752: LD_VAR 0 2
66756: ARRAY
66757: UNION
66758: PPUSH
66759: LD_INT 21
66761: PUSH
66762: LD_INT 1
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 1
66771: PUSH
66772: LD_INT 3
66774: PUSH
66775: LD_INT 54
66777: PUSH
66778: EMPTY
66779: LIST
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 3
66787: PUSH
66788: LD_INT 24
66790: PUSH
66791: LD_INT 1000
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: EMPTY
66799: LIST
66800: LIST
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: LIST
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PPUSH
66811: CALL_OW 72
66815: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
66816: LD_ADDR_VAR 0 6
66820: PUSH
66821: LD_EXP 61
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: PPUSH
66832: LD_INT 21
66834: PUSH
66835: LD_INT 1
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: LD_INT 3
66847: PUSH
66848: LD_INT 54
66850: PUSH
66851: EMPTY
66852: LIST
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 3
66860: PUSH
66861: LD_INT 24
66863: PUSH
66864: LD_INT 250
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: LIST
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PPUSH
66884: CALL_OW 72
66888: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
66889: LD_ADDR_VAR 0 7
66893: PUSH
66894: LD_VAR 0 5
66898: PUSH
66899: LD_VAR 0 6
66903: DIFF
66904: ST_TO_ADDR
// if not need_heal_1 then
66905: LD_VAR 0 6
66909: NOT
66910: IFFALSE 66943
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
66912: LD_ADDR_EXP 64
66916: PUSH
66917: LD_EXP 64
66921: PPUSH
66922: LD_VAR 0 2
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PPUSH
66934: EMPTY
66935: PPUSH
66936: CALL 20981 0 3
66940: ST_TO_ADDR
66941: GO 67013
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
66943: LD_ADDR_EXP 64
66947: PUSH
66948: LD_EXP 64
66952: PPUSH
66953: LD_VAR 0 2
66957: PUSH
66958: LD_INT 1
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PPUSH
66965: LD_EXP 64
66969: PUSH
66970: LD_VAR 0 2
66974: ARRAY
66975: PUSH
66976: LD_INT 1
66978: ARRAY
66979: PPUSH
66980: LD_INT 3
66982: PUSH
66983: LD_INT 24
66985: PUSH
66986: LD_INT 1000
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: EMPTY
66994: LIST
66995: LIST
66996: PPUSH
66997: CALL_OW 72
67001: PUSH
67002: LD_VAR 0 6
67006: UNION
67007: PPUSH
67008: CALL 20981 0 3
67012: ST_TO_ADDR
// if not need_heal_2 then
67013: LD_VAR 0 7
67017: NOT
67018: IFFALSE 67051
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
67020: LD_ADDR_EXP 64
67024: PUSH
67025: LD_EXP 64
67029: PPUSH
67030: LD_VAR 0 2
67034: PUSH
67035: LD_INT 2
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PPUSH
67042: EMPTY
67043: PPUSH
67044: CALL 20981 0 3
67048: ST_TO_ADDR
67049: GO 67083
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
67051: LD_ADDR_EXP 64
67055: PUSH
67056: LD_EXP 64
67060: PPUSH
67061: LD_VAR 0 2
67065: PUSH
67066: LD_INT 2
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: PPUSH
67073: LD_VAR 0 7
67077: PPUSH
67078: CALL 20981 0 3
67082: ST_TO_ADDR
// if need_heal_2 then
67083: LD_VAR 0 7
67087: IFFALSE 67248
// for j in need_heal_2 do
67089: LD_ADDR_VAR 0 3
67093: PUSH
67094: LD_VAR 0 7
67098: PUSH
67099: FOR_IN
67100: IFFALSE 67246
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67102: LD_ADDR_VAR 0 5
67106: PUSH
67107: LD_EXP 61
67111: PUSH
67112: LD_VAR 0 2
67116: ARRAY
67117: PPUSH
67118: LD_INT 2
67120: PUSH
67121: LD_INT 30
67123: PUSH
67124: LD_INT 6
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 30
67133: PUSH
67134: LD_INT 7
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 30
67143: PUSH
67144: LD_INT 8
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 30
67153: PUSH
67154: LD_INT 0
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 30
67163: PUSH
67164: LD_INT 1
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: PPUSH
67179: CALL_OW 72
67183: ST_TO_ADDR
// if tmp then
67184: LD_VAR 0 5
67188: IFFALSE 67244
// begin k := NearestUnitToUnit ( tmp , j ) ;
67190: LD_ADDR_VAR 0 4
67194: PUSH
67195: LD_VAR 0 5
67199: PPUSH
67200: LD_VAR 0 3
67204: PPUSH
67205: CALL_OW 74
67209: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
67210: LD_VAR 0 3
67214: PPUSH
67215: LD_VAR 0 4
67219: PPUSH
67220: CALL_OW 296
67224: PUSH
67225: LD_INT 5
67227: GREATER
67228: IFFALSE 67244
// ComMoveToNearbyEntrance ( j , k ) ;
67230: LD_VAR 0 3
67234: PPUSH
67235: LD_VAR 0 4
67239: PPUSH
67240: CALL 54598 0 2
// end ; end ;
67244: GO 67099
67246: POP
67247: POP
// if not need_heal_1 and not need_heal_2 then
67248: LD_VAR 0 6
67252: NOT
67253: PUSH
67254: LD_VAR 0 7
67258: NOT
67259: AND
67260: IFFALSE 67264
// continue ;
67262: GO 66728
// end ;
67264: GO 66728
67266: POP
67267: POP
// RaiseSailEvent ( 102 ) ;
67268: LD_INT 102
67270: PPUSH
67271: CALL_OW 427
// end ;
67275: LD_VAR 0 1
67279: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
67280: LD_INT 0
67282: PPUSH
67283: PPUSH
67284: PPUSH
67285: PPUSH
67286: PPUSH
67287: PPUSH
67288: PPUSH
67289: PPUSH
// if not mc_bases then
67290: LD_EXP 61
67294: NOT
67295: IFFALSE 67299
// exit ;
67297: GO 68210
// for i = 1 to mc_bases do
67299: LD_ADDR_VAR 0 2
67303: PUSH
67304: DOUBLE
67305: LD_INT 1
67307: DEC
67308: ST_TO_ADDR
67309: LD_EXP 61
67313: PUSH
67314: FOR_TO
67315: IFFALSE 68208
// begin if not mc_building_need_repair [ i ] then
67317: LD_EXP 62
67321: PUSH
67322: LD_VAR 0 2
67326: ARRAY
67327: NOT
67328: IFFALSE 67513
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
67330: LD_ADDR_VAR 0 6
67334: PUSH
67335: LD_EXP 80
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PPUSH
67346: LD_INT 3
67348: PUSH
67349: LD_INT 24
67351: PUSH
67352: LD_INT 1000
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PUSH
67363: LD_INT 2
67365: PUSH
67366: LD_INT 34
67368: PUSH
67369: LD_INT 13
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 34
67378: PUSH
67379: LD_INT 52
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 34
67388: PUSH
67389: LD_INT 88
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: LIST
67400: LIST
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PPUSH
67406: CALL_OW 72
67410: ST_TO_ADDR
// if cranes then
67411: LD_VAR 0 6
67415: IFFALSE 67477
// for j in cranes do
67417: LD_ADDR_VAR 0 3
67421: PUSH
67422: LD_VAR 0 6
67426: PUSH
67427: FOR_IN
67428: IFFALSE 67475
// if not IsInArea ( j , mc_parking [ i ] ) then
67430: LD_VAR 0 3
67434: PPUSH
67435: LD_EXP 85
67439: PUSH
67440: LD_VAR 0 2
67444: ARRAY
67445: PPUSH
67446: CALL_OW 308
67450: NOT
67451: IFFALSE 67473
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67453: LD_VAR 0 3
67457: PPUSH
67458: LD_EXP 85
67462: PUSH
67463: LD_VAR 0 2
67467: ARRAY
67468: PPUSH
67469: CALL_OW 113
67473: GO 67427
67475: POP
67476: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
67477: LD_ADDR_EXP 63
67481: PUSH
67482: LD_EXP 63
67486: PPUSH
67487: LD_VAR 0 2
67491: PPUSH
67492: EMPTY
67493: PPUSH
67494: CALL_OW 1
67498: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
67499: LD_VAR 0 2
67503: PPUSH
67504: LD_INT 101
67506: PPUSH
67507: CALL 62353 0 2
// continue ;
67511: GO 67314
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
67513: LD_ADDR_EXP 67
67517: PUSH
67518: LD_EXP 67
67522: PPUSH
67523: LD_VAR 0 2
67527: PPUSH
67528: EMPTY
67529: PPUSH
67530: CALL_OW 1
67534: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67535: LD_VAR 0 2
67539: PPUSH
67540: LD_INT 103
67542: PPUSH
67543: CALL 62353 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
67547: LD_ADDR_VAR 0 5
67551: PUSH
67552: LD_EXP 61
67556: PUSH
67557: LD_VAR 0 2
67561: ARRAY
67562: PUSH
67563: LD_EXP 90
67567: PUSH
67568: LD_VAR 0 2
67572: ARRAY
67573: UNION
67574: PPUSH
67575: LD_INT 2
67577: PUSH
67578: LD_INT 25
67580: PUSH
67581: LD_INT 2
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 25
67590: PUSH
67591: LD_INT 16
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: LIST
67602: PUSH
67603: EMPTY
67604: LIST
67605: PPUSH
67606: CALL_OW 72
67610: ST_TO_ADDR
// if mc_need_heal [ i ] then
67611: LD_EXP 64
67615: PUSH
67616: LD_VAR 0 2
67620: ARRAY
67621: IFFALSE 67665
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
67623: LD_ADDR_VAR 0 5
67627: PUSH
67628: LD_VAR 0 5
67632: PUSH
67633: LD_EXP 64
67637: PUSH
67638: LD_VAR 0 2
67642: ARRAY
67643: PUSH
67644: LD_INT 1
67646: ARRAY
67647: PUSH
67648: LD_EXP 64
67652: PUSH
67653: LD_VAR 0 2
67657: ARRAY
67658: PUSH
67659: LD_INT 2
67661: ARRAY
67662: UNION
67663: DIFF
67664: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
67665: LD_ADDR_VAR 0 6
67669: PUSH
67670: LD_EXP 80
67674: PUSH
67675: LD_VAR 0 2
67679: ARRAY
67680: PPUSH
67681: LD_INT 2
67683: PUSH
67684: LD_INT 34
67686: PUSH
67687: LD_INT 13
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 34
67696: PUSH
67697: LD_INT 52
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 34
67706: PUSH
67707: LD_INT 88
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: PPUSH
67720: CALL_OW 72
67724: ST_TO_ADDR
// if cranes then
67725: LD_VAR 0 6
67729: IFFALSE 67897
// begin for j in cranes do
67731: LD_ADDR_VAR 0 3
67735: PUSH
67736: LD_VAR 0 6
67740: PUSH
67741: FOR_IN
67742: IFFALSE 67895
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
67744: LD_VAR 0 3
67748: PPUSH
67749: CALL_OW 256
67753: PUSH
67754: LD_INT 1000
67756: EQUAL
67757: PUSH
67758: LD_VAR 0 3
67762: PPUSH
67763: CALL_OW 314
67767: NOT
67768: AND
67769: IFFALSE 67835
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
67771: LD_ADDR_VAR 0 8
67775: PUSH
67776: LD_EXP 62
67780: PUSH
67781: LD_VAR 0 2
67785: ARRAY
67786: PPUSH
67787: LD_VAR 0 3
67791: PPUSH
67792: CALL_OW 74
67796: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
67797: LD_VAR 0 8
67801: PPUSH
67802: LD_INT 16
67804: PPUSH
67805: CALL 23946 0 2
67809: PUSH
67810: LD_INT 4
67812: ARRAY
67813: PUSH
67814: LD_INT 10
67816: LESS
67817: IFFALSE 67833
// ComRepairBuilding ( j , to_repair ) ;
67819: LD_VAR 0 3
67823: PPUSH
67824: LD_VAR 0 8
67828: PPUSH
67829: CALL_OW 130
// end else
67833: GO 67893
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
67835: LD_VAR 0 3
67839: PPUSH
67840: CALL_OW 256
67844: PUSH
67845: LD_INT 500
67847: LESS
67848: PUSH
67849: LD_VAR 0 3
67853: PPUSH
67854: LD_EXP 85
67858: PUSH
67859: LD_VAR 0 2
67863: ARRAY
67864: PPUSH
67865: CALL_OW 308
67869: NOT
67870: AND
67871: IFFALSE 67893
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67873: LD_VAR 0 3
67877: PPUSH
67878: LD_EXP 85
67882: PUSH
67883: LD_VAR 0 2
67887: ARRAY
67888: PPUSH
67889: CALL_OW 113
// end ;
67893: GO 67741
67895: POP
67896: POP
// end ; if tmp > 3 then
67897: LD_VAR 0 5
67901: PUSH
67902: LD_INT 3
67904: GREATER
67905: IFFALSE 67925
// tmp := ShrinkArray ( tmp , 4 ) ;
67907: LD_ADDR_VAR 0 5
67911: PUSH
67912: LD_VAR 0 5
67916: PPUSH
67917: LD_INT 4
67919: PPUSH
67920: CALL 54036 0 2
67924: ST_TO_ADDR
// if not tmp then
67925: LD_VAR 0 5
67929: NOT
67930: IFFALSE 67934
// continue ;
67932: GO 67314
// for j in tmp do
67934: LD_ADDR_VAR 0 3
67938: PUSH
67939: LD_VAR 0 5
67943: PUSH
67944: FOR_IN
67945: IFFALSE 68204
// begin if IsInUnit ( j ) then
67947: LD_VAR 0 3
67951: PPUSH
67952: CALL_OW 310
67956: IFFALSE 67967
// ComExitBuilding ( j ) ;
67958: LD_VAR 0 3
67962: PPUSH
67963: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
67967: LD_VAR 0 3
67971: PUSH
67972: LD_EXP 63
67976: PUSH
67977: LD_VAR 0 2
67981: ARRAY
67982: IN
67983: NOT
67984: IFFALSE 68042
// begin SetTag ( j , 101 ) ;
67986: LD_VAR 0 3
67990: PPUSH
67991: LD_INT 101
67993: PPUSH
67994: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
67998: LD_ADDR_EXP 63
68002: PUSH
68003: LD_EXP 63
68007: PPUSH
68008: LD_VAR 0 2
68012: PUSH
68013: LD_EXP 63
68017: PUSH
68018: LD_VAR 0 2
68022: ARRAY
68023: PUSH
68024: LD_INT 1
68026: PLUS
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PPUSH
68032: LD_VAR 0 3
68036: PPUSH
68037: CALL 20981 0 3
68041: ST_TO_ADDR
// end ; wait ( 1 ) ;
68042: LD_INT 1
68044: PPUSH
68045: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
68049: LD_ADDR_VAR 0 7
68053: PUSH
68054: LD_EXP 62
68058: PUSH
68059: LD_VAR 0 2
68063: ARRAY
68064: ST_TO_ADDR
// if mc_scan [ i ] then
68065: LD_EXP 84
68069: PUSH
68070: LD_VAR 0 2
68074: ARRAY
68075: IFFALSE 68137
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
68077: LD_ADDR_VAR 0 7
68081: PUSH
68082: LD_EXP 62
68086: PUSH
68087: LD_VAR 0 2
68091: ARRAY
68092: PPUSH
68093: LD_INT 3
68095: PUSH
68096: LD_INT 30
68098: PUSH
68099: LD_INT 32
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 30
68108: PUSH
68109: LD_INT 33
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 30
68118: PUSH
68119: LD_INT 31
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: PPUSH
68132: CALL_OW 72
68136: ST_TO_ADDR
// if not to_repair_tmp then
68137: LD_VAR 0 7
68141: NOT
68142: IFFALSE 68146
// continue ;
68144: GO 67944
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
68146: LD_ADDR_VAR 0 8
68150: PUSH
68151: LD_VAR 0 7
68155: PPUSH
68156: LD_VAR 0 3
68160: PPUSH
68161: CALL_OW 74
68165: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
68166: LD_VAR 0 8
68170: PPUSH
68171: LD_INT 16
68173: PPUSH
68174: CALL 23946 0 2
68178: PUSH
68179: LD_INT 4
68181: ARRAY
68182: PUSH
68183: LD_INT 14
68185: LESS
68186: IFFALSE 68202
// ComRepairBuilding ( j , to_repair ) ;
68188: LD_VAR 0 3
68192: PPUSH
68193: LD_VAR 0 8
68197: PPUSH
68198: CALL_OW 130
// end ;
68202: GO 67944
68204: POP
68205: POP
// end ;
68206: GO 67314
68208: POP
68209: POP
// end ;
68210: LD_VAR 0 1
68214: RET
// export function MC_Heal ; var i , j , tmp ; begin
68215: LD_INT 0
68217: PPUSH
68218: PPUSH
68219: PPUSH
68220: PPUSH
// if not mc_bases then
68221: LD_EXP 61
68225: NOT
68226: IFFALSE 68230
// exit ;
68228: GO 68632
// for i = 1 to mc_bases do
68230: LD_ADDR_VAR 0 2
68234: PUSH
68235: DOUBLE
68236: LD_INT 1
68238: DEC
68239: ST_TO_ADDR
68240: LD_EXP 61
68244: PUSH
68245: FOR_TO
68246: IFFALSE 68630
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
68248: LD_EXP 64
68252: PUSH
68253: LD_VAR 0 2
68257: ARRAY
68258: PUSH
68259: LD_INT 1
68261: ARRAY
68262: NOT
68263: PUSH
68264: LD_EXP 64
68268: PUSH
68269: LD_VAR 0 2
68273: ARRAY
68274: PUSH
68275: LD_INT 2
68277: ARRAY
68278: NOT
68279: AND
68280: IFFALSE 68318
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
68282: LD_ADDR_EXP 65
68286: PUSH
68287: LD_EXP 65
68291: PPUSH
68292: LD_VAR 0 2
68296: PPUSH
68297: EMPTY
68298: PPUSH
68299: CALL_OW 1
68303: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
68304: LD_VAR 0 2
68308: PPUSH
68309: LD_INT 102
68311: PPUSH
68312: CALL 62353 0 2
// continue ;
68316: GO 68245
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
68318: LD_ADDR_VAR 0 4
68322: PUSH
68323: LD_EXP 61
68327: PUSH
68328: LD_VAR 0 2
68332: ARRAY
68333: PPUSH
68334: LD_INT 25
68336: PUSH
68337: LD_INT 4
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PPUSH
68344: CALL_OW 72
68348: ST_TO_ADDR
// if not tmp then
68349: LD_VAR 0 4
68353: NOT
68354: IFFALSE 68358
// continue ;
68356: GO 68245
// if mc_taming [ i ] then
68358: LD_EXP 92
68362: PUSH
68363: LD_VAR 0 2
68367: ARRAY
68368: IFFALSE 68392
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68370: LD_ADDR_EXP 92
68374: PUSH
68375: LD_EXP 92
68379: PPUSH
68380: LD_VAR 0 2
68384: PPUSH
68385: EMPTY
68386: PPUSH
68387: CALL_OW 1
68391: ST_TO_ADDR
// for j in tmp do
68392: LD_ADDR_VAR 0 3
68396: PUSH
68397: LD_VAR 0 4
68401: PUSH
68402: FOR_IN
68403: IFFALSE 68626
// begin if IsInUnit ( j ) then
68405: LD_VAR 0 3
68409: PPUSH
68410: CALL_OW 310
68414: IFFALSE 68425
// ComExitBuilding ( j ) ;
68416: LD_VAR 0 3
68420: PPUSH
68421: CALL_OW 122
// if not j in mc_healers [ i ] then
68425: LD_VAR 0 3
68429: PUSH
68430: LD_EXP 65
68434: PUSH
68435: LD_VAR 0 2
68439: ARRAY
68440: IN
68441: NOT
68442: IFFALSE 68488
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
68444: LD_ADDR_EXP 65
68448: PUSH
68449: LD_EXP 65
68453: PPUSH
68454: LD_VAR 0 2
68458: PUSH
68459: LD_EXP 65
68463: PUSH
68464: LD_VAR 0 2
68468: ARRAY
68469: PUSH
68470: LD_INT 1
68472: PLUS
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PPUSH
68478: LD_VAR 0 3
68482: PPUSH
68483: CALL 20981 0 3
68487: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
68488: LD_VAR 0 3
68492: PPUSH
68493: CALL_OW 110
68497: PUSH
68498: LD_INT 102
68500: NONEQUAL
68501: IFFALSE 68515
// SetTag ( j , 102 ) ;
68503: LD_VAR 0 3
68507: PPUSH
68508: LD_INT 102
68510: PPUSH
68511: CALL_OW 109
// Wait ( 3 ) ;
68515: LD_INT 3
68517: PPUSH
68518: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
68522: LD_EXP 64
68526: PUSH
68527: LD_VAR 0 2
68531: ARRAY
68532: PUSH
68533: LD_INT 1
68535: ARRAY
68536: IFFALSE 68568
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
68538: LD_VAR 0 3
68542: PPUSH
68543: LD_EXP 64
68547: PUSH
68548: LD_VAR 0 2
68552: ARRAY
68553: PUSH
68554: LD_INT 1
68556: ARRAY
68557: PUSH
68558: LD_INT 1
68560: ARRAY
68561: PPUSH
68562: CALL_OW 128
68566: GO 68624
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
68568: LD_VAR 0 3
68572: PPUSH
68573: CALL_OW 314
68577: NOT
68578: PUSH
68579: LD_EXP 64
68583: PUSH
68584: LD_VAR 0 2
68588: ARRAY
68589: PUSH
68590: LD_INT 2
68592: ARRAY
68593: AND
68594: IFFALSE 68624
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
68596: LD_VAR 0 3
68600: PPUSH
68601: LD_EXP 64
68605: PUSH
68606: LD_VAR 0 2
68610: ARRAY
68611: PUSH
68612: LD_INT 2
68614: ARRAY
68615: PUSH
68616: LD_INT 1
68618: ARRAY
68619: PPUSH
68620: CALL_OW 128
// end ;
68624: GO 68402
68626: POP
68627: POP
// end ;
68628: GO 68245
68630: POP
68631: POP
// end ;
68632: LD_VAR 0 1
68636: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
68637: LD_INT 0
68639: PPUSH
68640: PPUSH
68641: PPUSH
68642: PPUSH
68643: PPUSH
68644: PPUSH
// if not mc_bases then
68645: LD_EXP 61
68649: NOT
68650: IFFALSE 68654
// exit ;
68652: GO 69817
// for i = 1 to mc_bases do
68654: LD_ADDR_VAR 0 2
68658: PUSH
68659: DOUBLE
68660: LD_INT 1
68662: DEC
68663: ST_TO_ADDR
68664: LD_EXP 61
68668: PUSH
68669: FOR_TO
68670: IFFALSE 69815
// begin if mc_scan [ i ] then
68672: LD_EXP 84
68676: PUSH
68677: LD_VAR 0 2
68681: ARRAY
68682: IFFALSE 68686
// continue ;
68684: GO 68669
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
68686: LD_EXP 66
68690: PUSH
68691: LD_VAR 0 2
68695: ARRAY
68696: NOT
68697: PUSH
68698: LD_EXP 68
68702: PUSH
68703: LD_VAR 0 2
68707: ARRAY
68708: NOT
68709: AND
68710: PUSH
68711: LD_EXP 67
68715: PUSH
68716: LD_VAR 0 2
68720: ARRAY
68721: AND
68722: IFFALSE 68760
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
68724: LD_ADDR_EXP 67
68728: PUSH
68729: LD_EXP 67
68733: PPUSH
68734: LD_VAR 0 2
68738: PPUSH
68739: EMPTY
68740: PPUSH
68741: CALL_OW 1
68745: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
68746: LD_VAR 0 2
68750: PPUSH
68751: LD_INT 103
68753: PPUSH
68754: CALL 62353 0 2
// continue ;
68758: GO 68669
// end ; if mc_construct_list [ i ] then
68760: LD_EXP 68
68764: PUSH
68765: LD_VAR 0 2
68769: ARRAY
68770: IFFALSE 68990
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68772: LD_ADDR_VAR 0 5
68776: PUSH
68777: LD_EXP 61
68781: PUSH
68782: LD_VAR 0 2
68786: ARRAY
68787: PPUSH
68788: LD_INT 25
68790: PUSH
68791: LD_INT 2
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PPUSH
68798: CALL_OW 72
68802: PUSH
68803: LD_EXP 63
68807: PUSH
68808: LD_VAR 0 2
68812: ARRAY
68813: DIFF
68814: ST_TO_ADDR
// if not tmp then
68815: LD_VAR 0 5
68819: NOT
68820: IFFALSE 68824
// continue ;
68822: GO 68669
// for j in tmp do
68824: LD_ADDR_VAR 0 3
68828: PUSH
68829: LD_VAR 0 5
68833: PUSH
68834: FOR_IN
68835: IFFALSE 68986
// begin if not mc_builders [ i ] then
68837: LD_EXP 67
68841: PUSH
68842: LD_VAR 0 2
68846: ARRAY
68847: NOT
68848: IFFALSE 68906
// begin SetTag ( j , 103 ) ;
68850: LD_VAR 0 3
68854: PPUSH
68855: LD_INT 103
68857: PPUSH
68858: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68862: LD_ADDR_EXP 67
68866: PUSH
68867: LD_EXP 67
68871: PPUSH
68872: LD_VAR 0 2
68876: PUSH
68877: LD_EXP 67
68881: PUSH
68882: LD_VAR 0 2
68886: ARRAY
68887: PUSH
68888: LD_INT 1
68890: PLUS
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PPUSH
68896: LD_VAR 0 3
68900: PPUSH
68901: CALL 20981 0 3
68905: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68906: LD_VAR 0 3
68910: PPUSH
68911: CALL_OW 310
68915: IFFALSE 68926
// ComExitBuilding ( j ) ;
68917: LD_VAR 0 3
68921: PPUSH
68922: CALL_OW 122
// wait ( 3 ) ;
68926: LD_INT 3
68928: PPUSH
68929: CALL_OW 67
// if not mc_construct_list [ i ] then
68933: LD_EXP 68
68937: PUSH
68938: LD_VAR 0 2
68942: ARRAY
68943: NOT
68944: IFFALSE 68948
// break ;
68946: GO 68986
// if not HasTask ( j ) then
68948: LD_VAR 0 3
68952: PPUSH
68953: CALL_OW 314
68957: NOT
68958: IFFALSE 68984
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
68960: LD_VAR 0 3
68964: PPUSH
68965: LD_EXP 68
68969: PUSH
68970: LD_VAR 0 2
68974: ARRAY
68975: PUSH
68976: LD_INT 1
68978: ARRAY
68979: PPUSH
68980: CALL 24219 0 2
// end ;
68984: GO 68834
68986: POP
68987: POP
// end else
68988: GO 69813
// if mc_build_list [ i ] then
68990: LD_EXP 66
68994: PUSH
68995: LD_VAR 0 2
68999: ARRAY
69000: IFFALSE 69813
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
69002: LD_EXP 66
69006: PUSH
69007: LD_VAR 0 2
69011: ARRAY
69012: PUSH
69013: LD_INT 1
69015: ARRAY
69016: PUSH
69017: LD_INT 1
69019: ARRAY
69020: PPUSH
69021: CALL 24043 0 1
69025: PUSH
69026: LD_EXP 61
69030: PUSH
69031: LD_VAR 0 2
69035: ARRAY
69036: PPUSH
69037: LD_INT 2
69039: PUSH
69040: LD_INT 30
69042: PUSH
69043: LD_INT 2
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 30
69052: PUSH
69053: LD_INT 3
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: LIST
69064: PPUSH
69065: CALL_OW 72
69069: NOT
69070: AND
69071: IFFALSE 69176
// begin for j = 1 to mc_build_list [ i ] do
69073: LD_ADDR_VAR 0 3
69077: PUSH
69078: DOUBLE
69079: LD_INT 1
69081: DEC
69082: ST_TO_ADDR
69083: LD_EXP 66
69087: PUSH
69088: LD_VAR 0 2
69092: ARRAY
69093: PUSH
69094: FOR_TO
69095: IFFALSE 69174
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
69097: LD_EXP 66
69101: PUSH
69102: LD_VAR 0 2
69106: ARRAY
69107: PUSH
69108: LD_VAR 0 3
69112: ARRAY
69113: PUSH
69114: LD_INT 1
69116: ARRAY
69117: PUSH
69118: LD_INT 2
69120: EQUAL
69121: IFFALSE 69172
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
69123: LD_ADDR_EXP 66
69127: PUSH
69128: LD_EXP 66
69132: PPUSH
69133: LD_VAR 0 2
69137: PPUSH
69138: LD_EXP 66
69142: PUSH
69143: LD_VAR 0 2
69147: ARRAY
69148: PPUSH
69149: LD_VAR 0 3
69153: PPUSH
69154: LD_INT 1
69156: PPUSH
69157: LD_INT 0
69159: PPUSH
69160: CALL 20399 0 4
69164: PPUSH
69165: CALL_OW 1
69169: ST_TO_ADDR
// break ;
69170: GO 69174
// end ;
69172: GO 69094
69174: POP
69175: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69176: LD_ADDR_VAR 0 6
69180: PUSH
69181: LD_EXP 61
69185: PUSH
69186: LD_VAR 0 2
69190: ARRAY
69191: PPUSH
69192: LD_INT 2
69194: PUSH
69195: LD_INT 30
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 30
69207: PUSH
69208: LD_INT 1
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: LIST
69219: PPUSH
69220: CALL_OW 72
69224: ST_TO_ADDR
// for k := 1 to depot do
69225: LD_ADDR_VAR 0 4
69229: PUSH
69230: DOUBLE
69231: LD_INT 1
69233: DEC
69234: ST_TO_ADDR
69235: LD_VAR 0 6
69239: PUSH
69240: FOR_TO
69241: IFFALSE 69811
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
69243: LD_EXP 66
69247: PUSH
69248: LD_VAR 0 2
69252: ARRAY
69253: PUSH
69254: LD_INT 1
69256: ARRAY
69257: PUSH
69258: LD_INT 1
69260: ARRAY
69261: PUSH
69262: LD_INT 0
69264: EQUAL
69265: PUSH
69266: LD_VAR 0 6
69270: PUSH
69271: LD_VAR 0 4
69275: ARRAY
69276: PPUSH
69277: LD_EXP 66
69281: PUSH
69282: LD_VAR 0 2
69286: ARRAY
69287: PUSH
69288: LD_INT 1
69290: ARRAY
69291: PUSH
69292: LD_INT 1
69294: ARRAY
69295: PPUSH
69296: LD_EXP 66
69300: PUSH
69301: LD_VAR 0 2
69305: ARRAY
69306: PUSH
69307: LD_INT 1
69309: ARRAY
69310: PUSH
69311: LD_INT 2
69313: ARRAY
69314: PPUSH
69315: LD_EXP 66
69319: PUSH
69320: LD_VAR 0 2
69324: ARRAY
69325: PUSH
69326: LD_INT 1
69328: ARRAY
69329: PUSH
69330: LD_INT 3
69332: ARRAY
69333: PPUSH
69334: LD_EXP 66
69338: PUSH
69339: LD_VAR 0 2
69343: ARRAY
69344: PUSH
69345: LD_INT 1
69347: ARRAY
69348: PUSH
69349: LD_INT 4
69351: ARRAY
69352: PPUSH
69353: CALL 29455 0 5
69357: OR
69358: IFFALSE 69639
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
69360: LD_ADDR_VAR 0 5
69364: PUSH
69365: LD_EXP 61
69369: PUSH
69370: LD_VAR 0 2
69374: ARRAY
69375: PPUSH
69376: LD_INT 25
69378: PUSH
69379: LD_INT 2
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PPUSH
69386: CALL_OW 72
69390: PUSH
69391: LD_EXP 63
69395: PUSH
69396: LD_VAR 0 2
69400: ARRAY
69401: DIFF
69402: ST_TO_ADDR
// if not tmp then
69403: LD_VAR 0 5
69407: NOT
69408: IFFALSE 69412
// continue ;
69410: GO 69240
// for j in tmp do
69412: LD_ADDR_VAR 0 3
69416: PUSH
69417: LD_VAR 0 5
69421: PUSH
69422: FOR_IN
69423: IFFALSE 69635
// begin if not mc_builders [ i ] then
69425: LD_EXP 67
69429: PUSH
69430: LD_VAR 0 2
69434: ARRAY
69435: NOT
69436: IFFALSE 69494
// begin SetTag ( j , 103 ) ;
69438: LD_VAR 0 3
69442: PPUSH
69443: LD_INT 103
69445: PPUSH
69446: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
69450: LD_ADDR_EXP 67
69454: PUSH
69455: LD_EXP 67
69459: PPUSH
69460: LD_VAR 0 2
69464: PUSH
69465: LD_EXP 67
69469: PUSH
69470: LD_VAR 0 2
69474: ARRAY
69475: PUSH
69476: LD_INT 1
69478: PLUS
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PPUSH
69484: LD_VAR 0 3
69488: PPUSH
69489: CALL 20981 0 3
69493: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
69494: LD_VAR 0 3
69498: PPUSH
69499: CALL_OW 310
69503: IFFALSE 69514
// ComExitBuilding ( j ) ;
69505: LD_VAR 0 3
69509: PPUSH
69510: CALL_OW 122
// wait ( 3 ) ;
69514: LD_INT 3
69516: PPUSH
69517: CALL_OW 67
// if not mc_build_list [ i ] then
69521: LD_EXP 66
69525: PUSH
69526: LD_VAR 0 2
69530: ARRAY
69531: NOT
69532: IFFALSE 69536
// break ;
69534: GO 69635
// if not HasTask ( j ) then
69536: LD_VAR 0 3
69540: PPUSH
69541: CALL_OW 314
69545: NOT
69546: IFFALSE 69633
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
69548: LD_VAR 0 3
69552: PPUSH
69553: LD_EXP 66
69557: PUSH
69558: LD_VAR 0 2
69562: ARRAY
69563: PUSH
69564: LD_INT 1
69566: ARRAY
69567: PUSH
69568: LD_INT 1
69570: ARRAY
69571: PPUSH
69572: LD_EXP 66
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: PUSH
69583: LD_INT 1
69585: ARRAY
69586: PUSH
69587: LD_INT 2
69589: ARRAY
69590: PPUSH
69591: LD_EXP 66
69595: PUSH
69596: LD_VAR 0 2
69600: ARRAY
69601: PUSH
69602: LD_INT 1
69604: ARRAY
69605: PUSH
69606: LD_INT 3
69608: ARRAY
69609: PPUSH
69610: LD_EXP 66
69614: PUSH
69615: LD_VAR 0 2
69619: ARRAY
69620: PUSH
69621: LD_INT 1
69623: ARRAY
69624: PUSH
69625: LD_INT 4
69627: ARRAY
69628: PPUSH
69629: CALL_OW 145
// end ;
69633: GO 69422
69635: POP
69636: POP
// end else
69637: GO 69809
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
69639: LD_EXP 61
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: PPUSH
69650: LD_EXP 66
69654: PUSH
69655: LD_VAR 0 2
69659: ARRAY
69660: PUSH
69661: LD_INT 1
69663: ARRAY
69664: PUSH
69665: LD_INT 1
69667: ARRAY
69668: PPUSH
69669: LD_EXP 66
69673: PUSH
69674: LD_VAR 0 2
69678: ARRAY
69679: PUSH
69680: LD_INT 1
69682: ARRAY
69683: PUSH
69684: LD_INT 2
69686: ARRAY
69687: PPUSH
69688: LD_EXP 66
69692: PUSH
69693: LD_VAR 0 2
69697: ARRAY
69698: PUSH
69699: LD_INT 1
69701: ARRAY
69702: PUSH
69703: LD_INT 3
69705: ARRAY
69706: PPUSH
69707: LD_EXP 66
69711: PUSH
69712: LD_VAR 0 2
69716: ARRAY
69717: PUSH
69718: LD_INT 1
69720: ARRAY
69721: PUSH
69722: LD_INT 4
69724: ARRAY
69725: PPUSH
69726: LD_EXP 61
69730: PUSH
69731: LD_VAR 0 2
69735: ARRAY
69736: PPUSH
69737: LD_INT 21
69739: PUSH
69740: LD_INT 3
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PPUSH
69747: CALL_OW 72
69751: PPUSH
69752: EMPTY
69753: PPUSH
69754: CALL 28209 0 7
69758: NOT
69759: IFFALSE 69809
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
69761: LD_ADDR_EXP 66
69765: PUSH
69766: LD_EXP 66
69770: PPUSH
69771: LD_VAR 0 2
69775: PPUSH
69776: LD_EXP 66
69780: PUSH
69781: LD_VAR 0 2
69785: ARRAY
69786: PPUSH
69787: LD_INT 1
69789: PPUSH
69790: LD_INT 1
69792: NEG
69793: PPUSH
69794: LD_INT 0
69796: PPUSH
69797: CALL 20399 0 4
69801: PPUSH
69802: CALL_OW 1
69806: ST_TO_ADDR
// continue ;
69807: GO 69240
// end ; end ;
69809: GO 69240
69811: POP
69812: POP
// end ; end ;
69813: GO 68669
69815: POP
69816: POP
// end ;
69817: LD_VAR 0 1
69821: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
69822: LD_INT 0
69824: PPUSH
69825: PPUSH
69826: PPUSH
69827: PPUSH
69828: PPUSH
69829: PPUSH
// if not mc_bases then
69830: LD_EXP 61
69834: NOT
69835: IFFALSE 69839
// exit ;
69837: GO 70266
// for i = 1 to mc_bases do
69839: LD_ADDR_VAR 0 2
69843: PUSH
69844: DOUBLE
69845: LD_INT 1
69847: DEC
69848: ST_TO_ADDR
69849: LD_EXP 61
69853: PUSH
69854: FOR_TO
69855: IFFALSE 70264
// begin tmp := mc_build_upgrade [ i ] ;
69857: LD_ADDR_VAR 0 4
69861: PUSH
69862: LD_EXP 93
69866: PUSH
69867: LD_VAR 0 2
69871: ARRAY
69872: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
69873: LD_ADDR_VAR 0 6
69877: PUSH
69878: LD_EXP 94
69882: PUSH
69883: LD_VAR 0 2
69887: ARRAY
69888: PPUSH
69889: LD_INT 2
69891: PUSH
69892: LD_INT 30
69894: PUSH
69895: LD_INT 6
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 30
69904: PUSH
69905: LD_INT 7
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: EMPTY
69913: LIST
69914: LIST
69915: LIST
69916: PPUSH
69917: CALL_OW 72
69921: ST_TO_ADDR
// if not tmp and not lab then
69922: LD_VAR 0 4
69926: NOT
69927: PUSH
69928: LD_VAR 0 6
69932: NOT
69933: AND
69934: IFFALSE 69938
// continue ;
69936: GO 69854
// if tmp then
69938: LD_VAR 0 4
69942: IFFALSE 70062
// for j in tmp do
69944: LD_ADDR_VAR 0 3
69948: PUSH
69949: LD_VAR 0 4
69953: PUSH
69954: FOR_IN
69955: IFFALSE 70060
// begin if UpgradeCost ( j ) then
69957: LD_VAR 0 3
69961: PPUSH
69962: CALL 27869 0 1
69966: IFFALSE 70058
// begin ComUpgrade ( j ) ;
69968: LD_VAR 0 3
69972: PPUSH
69973: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
69977: LD_ADDR_EXP 93
69981: PUSH
69982: LD_EXP 93
69986: PPUSH
69987: LD_VAR 0 2
69991: PPUSH
69992: LD_EXP 93
69996: PUSH
69997: LD_VAR 0 2
70001: ARRAY
70002: PUSH
70003: LD_VAR 0 3
70007: DIFF
70008: PPUSH
70009: CALL_OW 1
70013: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
70014: LD_ADDR_EXP 68
70018: PUSH
70019: LD_EXP 68
70023: PPUSH
70024: LD_VAR 0 2
70028: PUSH
70029: LD_EXP 68
70033: PUSH
70034: LD_VAR 0 2
70038: ARRAY
70039: PUSH
70040: LD_INT 1
70042: PLUS
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PPUSH
70048: LD_VAR 0 3
70052: PPUSH
70053: CALL 20981 0 3
70057: ST_TO_ADDR
// end ; end ;
70058: GO 69954
70060: POP
70061: POP
// if not lab or not mc_lab_upgrade [ i ] then
70062: LD_VAR 0 6
70066: NOT
70067: PUSH
70068: LD_EXP 95
70072: PUSH
70073: LD_VAR 0 2
70077: ARRAY
70078: NOT
70079: OR
70080: IFFALSE 70084
// continue ;
70082: GO 69854
// for j in lab do
70084: LD_ADDR_VAR 0 3
70088: PUSH
70089: LD_VAR 0 6
70093: PUSH
70094: FOR_IN
70095: IFFALSE 70260
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
70097: LD_VAR 0 3
70101: PPUSH
70102: CALL_OW 266
70106: PUSH
70107: LD_INT 6
70109: PUSH
70110: LD_INT 7
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: IN
70117: PUSH
70118: LD_VAR 0 3
70122: PPUSH
70123: CALL_OW 461
70127: PUSH
70128: LD_INT 1
70130: NONEQUAL
70131: AND
70132: IFFALSE 70258
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
70134: LD_VAR 0 3
70138: PPUSH
70139: LD_EXP 95
70143: PUSH
70144: LD_VAR 0 2
70148: ARRAY
70149: PUSH
70150: LD_INT 1
70152: ARRAY
70153: PPUSH
70154: CALL 28074 0 2
70158: IFFALSE 70258
// begin ComCancel ( j ) ;
70160: LD_VAR 0 3
70164: PPUSH
70165: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
70169: LD_VAR 0 3
70173: PPUSH
70174: LD_EXP 95
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PUSH
70185: LD_INT 1
70187: ARRAY
70188: PPUSH
70189: CALL_OW 207
// if not j in mc_construct_list [ i ] then
70193: LD_VAR 0 3
70197: PUSH
70198: LD_EXP 68
70202: PUSH
70203: LD_VAR 0 2
70207: ARRAY
70208: IN
70209: NOT
70210: IFFALSE 70256
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
70212: LD_ADDR_EXP 68
70216: PUSH
70217: LD_EXP 68
70221: PPUSH
70222: LD_VAR 0 2
70226: PUSH
70227: LD_EXP 68
70231: PUSH
70232: LD_VAR 0 2
70236: ARRAY
70237: PUSH
70238: LD_INT 1
70240: PLUS
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PPUSH
70246: LD_VAR 0 3
70250: PPUSH
70251: CALL 20981 0 3
70255: ST_TO_ADDR
// break ;
70256: GO 70260
// end ; end ; end ;
70258: GO 70094
70260: POP
70261: POP
// end ;
70262: GO 69854
70264: POP
70265: POP
// end ;
70266: LD_VAR 0 1
70270: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
70271: LD_INT 0
70273: PPUSH
70274: PPUSH
70275: PPUSH
70276: PPUSH
70277: PPUSH
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
// if not mc_bases then
70282: LD_EXP 61
70286: NOT
70287: IFFALSE 70291
// exit ;
70289: GO 70696
// for i = 1 to mc_bases do
70291: LD_ADDR_VAR 0 2
70295: PUSH
70296: DOUBLE
70297: LD_INT 1
70299: DEC
70300: ST_TO_ADDR
70301: LD_EXP 61
70305: PUSH
70306: FOR_TO
70307: IFFALSE 70694
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
70309: LD_EXP 69
70313: PUSH
70314: LD_VAR 0 2
70318: ARRAY
70319: NOT
70320: PUSH
70321: LD_EXP 61
70325: PUSH
70326: LD_VAR 0 2
70330: ARRAY
70331: PPUSH
70332: LD_INT 30
70334: PUSH
70335: LD_INT 3
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PPUSH
70342: CALL_OW 72
70346: NOT
70347: OR
70348: IFFALSE 70352
// continue ;
70350: GO 70306
// busy := false ;
70352: LD_ADDR_VAR 0 8
70356: PUSH
70357: LD_INT 0
70359: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70360: LD_ADDR_VAR 0 4
70364: PUSH
70365: LD_EXP 61
70369: PUSH
70370: LD_VAR 0 2
70374: ARRAY
70375: PPUSH
70376: LD_INT 30
70378: PUSH
70379: LD_INT 3
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PPUSH
70386: CALL_OW 72
70390: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
70391: LD_ADDR_VAR 0 6
70395: PUSH
70396: LD_EXP 69
70400: PUSH
70401: LD_VAR 0 2
70405: ARRAY
70406: PPUSH
70407: LD_INT 2
70409: PUSH
70410: LD_INT 30
70412: PUSH
70413: LD_INT 32
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 30
70422: PUSH
70423: LD_INT 33
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: LIST
70434: PPUSH
70435: CALL_OW 72
70439: ST_TO_ADDR
// if not t then
70440: LD_VAR 0 6
70444: NOT
70445: IFFALSE 70449
// continue ;
70447: GO 70306
// for j in tmp do
70449: LD_ADDR_VAR 0 3
70453: PUSH
70454: LD_VAR 0 4
70458: PUSH
70459: FOR_IN
70460: IFFALSE 70490
// if not BuildingStatus ( j ) = bs_idle then
70462: LD_VAR 0 3
70466: PPUSH
70467: CALL_OW 461
70471: PUSH
70472: LD_INT 2
70474: EQUAL
70475: NOT
70476: IFFALSE 70488
// begin busy := true ;
70478: LD_ADDR_VAR 0 8
70482: PUSH
70483: LD_INT 1
70485: ST_TO_ADDR
// break ;
70486: GO 70490
// end ;
70488: GO 70459
70490: POP
70491: POP
// if busy then
70492: LD_VAR 0 8
70496: IFFALSE 70500
// continue ;
70498: GO 70306
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
70500: LD_ADDR_VAR 0 7
70504: PUSH
70505: LD_VAR 0 6
70509: PPUSH
70510: LD_INT 35
70512: PUSH
70513: LD_INT 0
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PPUSH
70520: CALL_OW 72
70524: ST_TO_ADDR
// if tw then
70525: LD_VAR 0 7
70529: IFFALSE 70606
// begin tw := tw [ 1 ] ;
70531: LD_ADDR_VAR 0 7
70535: PUSH
70536: LD_VAR 0 7
70540: PUSH
70541: LD_INT 1
70543: ARRAY
70544: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
70545: LD_ADDR_VAR 0 9
70549: PUSH
70550: LD_VAR 0 7
70554: PPUSH
70555: LD_EXP 86
70559: PUSH
70560: LD_VAR 0 2
70564: ARRAY
70565: PPUSH
70566: CALL 26366 0 2
70570: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
70571: LD_EXP 100
70575: PUSH
70576: LD_VAR 0 2
70580: ARRAY
70581: IFFALSE 70604
// if not weapon in mc_allowed_tower_weapons [ i ] then
70583: LD_VAR 0 9
70587: PUSH
70588: LD_EXP 100
70592: PUSH
70593: LD_VAR 0 2
70597: ARRAY
70598: IN
70599: NOT
70600: IFFALSE 70604
// continue ;
70602: GO 70306
// end else
70604: GO 70669
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
70606: LD_ADDR_VAR 0 5
70610: PUSH
70611: LD_EXP 69
70615: PUSH
70616: LD_VAR 0 2
70620: ARRAY
70621: PPUSH
70622: LD_VAR 0 4
70626: PPUSH
70627: CALL 53269 0 2
70631: ST_TO_ADDR
// if not tmp2 then
70632: LD_VAR 0 5
70636: NOT
70637: IFFALSE 70641
// continue ;
70639: GO 70306
// tw := tmp2 [ 1 ] ;
70641: LD_ADDR_VAR 0 7
70645: PUSH
70646: LD_VAR 0 5
70650: PUSH
70651: LD_INT 1
70653: ARRAY
70654: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
70655: LD_ADDR_VAR 0 9
70659: PUSH
70660: LD_VAR 0 5
70664: PUSH
70665: LD_INT 2
70667: ARRAY
70668: ST_TO_ADDR
// end ; if not weapon then
70669: LD_VAR 0 9
70673: NOT
70674: IFFALSE 70678
// continue ;
70676: GO 70306
// ComPlaceWeapon ( tw , weapon ) ;
70678: LD_VAR 0 7
70682: PPUSH
70683: LD_VAR 0 9
70687: PPUSH
70688: CALL_OW 148
// end ;
70692: GO 70306
70694: POP
70695: POP
// end ;
70696: LD_VAR 0 1
70700: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
70701: LD_INT 0
70703: PPUSH
70704: PPUSH
70705: PPUSH
70706: PPUSH
70707: PPUSH
70708: PPUSH
70709: PPUSH
// if not mc_bases then
70710: LD_EXP 61
70714: NOT
70715: IFFALSE 70719
// exit ;
70717: GO 71494
// for i = 1 to mc_bases do
70719: LD_ADDR_VAR 0 2
70723: PUSH
70724: DOUBLE
70725: LD_INT 1
70727: DEC
70728: ST_TO_ADDR
70729: LD_EXP 61
70733: PUSH
70734: FOR_TO
70735: IFFALSE 71492
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
70737: LD_EXP 74
70741: PUSH
70742: LD_VAR 0 2
70746: ARRAY
70747: NOT
70748: PUSH
70749: LD_EXP 74
70753: PUSH
70754: LD_VAR 0 2
70758: ARRAY
70759: PUSH
70760: LD_EXP 75
70764: PUSH
70765: LD_VAR 0 2
70769: ARRAY
70770: EQUAL
70771: OR
70772: PUSH
70773: LD_EXP 84
70777: PUSH
70778: LD_VAR 0 2
70782: ARRAY
70783: OR
70784: IFFALSE 70788
// continue ;
70786: GO 70734
// if mc_miners [ i ] then
70788: LD_EXP 75
70792: PUSH
70793: LD_VAR 0 2
70797: ARRAY
70798: IFFALSE 71179
// begin for j = mc_miners [ i ] downto 1 do
70800: LD_ADDR_VAR 0 3
70804: PUSH
70805: DOUBLE
70806: LD_EXP 75
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: INC
70817: ST_TO_ADDR
70818: LD_INT 1
70820: PUSH
70821: FOR_DOWNTO
70822: IFFALSE 71177
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
70824: LD_EXP 75
70828: PUSH
70829: LD_VAR 0 2
70833: ARRAY
70834: PUSH
70835: LD_VAR 0 3
70839: ARRAY
70840: PPUSH
70841: CALL_OW 301
70845: PUSH
70846: LD_EXP 75
70850: PUSH
70851: LD_VAR 0 2
70855: ARRAY
70856: PUSH
70857: LD_VAR 0 3
70861: ARRAY
70862: PPUSH
70863: CALL_OW 257
70867: PUSH
70868: LD_INT 1
70870: NONEQUAL
70871: OR
70872: IFFALSE 70935
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
70874: LD_ADDR_VAR 0 5
70878: PUSH
70879: LD_EXP 75
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: PUSH
70890: LD_EXP 75
70894: PUSH
70895: LD_VAR 0 2
70899: ARRAY
70900: PUSH
70901: LD_VAR 0 3
70905: ARRAY
70906: DIFF
70907: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
70908: LD_ADDR_EXP 75
70912: PUSH
70913: LD_EXP 75
70917: PPUSH
70918: LD_VAR 0 2
70922: PPUSH
70923: LD_VAR 0 5
70927: PPUSH
70928: CALL_OW 1
70932: ST_TO_ADDR
// continue ;
70933: GO 70821
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
70935: LD_EXP 75
70939: PUSH
70940: LD_VAR 0 2
70944: ARRAY
70945: PUSH
70946: LD_VAR 0 3
70950: ARRAY
70951: PPUSH
70952: CALL_OW 257
70956: PUSH
70957: LD_INT 1
70959: EQUAL
70960: PUSH
70961: LD_EXP 75
70965: PUSH
70966: LD_VAR 0 2
70970: ARRAY
70971: PUSH
70972: LD_VAR 0 3
70976: ARRAY
70977: PPUSH
70978: CALL_OW 459
70982: NOT
70983: AND
70984: PUSH
70985: LD_EXP 75
70989: PUSH
70990: LD_VAR 0 2
70994: ARRAY
70995: PUSH
70996: LD_VAR 0 3
71000: ARRAY
71001: PPUSH
71002: CALL_OW 314
71006: NOT
71007: AND
71008: IFFALSE 71175
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
71010: LD_EXP 75
71014: PUSH
71015: LD_VAR 0 2
71019: ARRAY
71020: PUSH
71021: LD_VAR 0 3
71025: ARRAY
71026: PPUSH
71027: CALL_OW 310
71031: IFFALSE 71054
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
71033: LD_EXP 75
71037: PUSH
71038: LD_VAR 0 2
71042: ARRAY
71043: PUSH
71044: LD_VAR 0 3
71048: ARRAY
71049: PPUSH
71050: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
71054: LD_EXP 75
71058: PUSH
71059: LD_VAR 0 2
71063: ARRAY
71064: PUSH
71065: LD_VAR 0 3
71069: ARRAY
71070: PPUSH
71071: CALL_OW 314
71075: NOT
71076: IFFALSE 71175
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
71078: LD_ADDR_VAR 0 7
71082: PUSH
71083: LD_VAR 0 3
71087: PUSH
71088: LD_EXP 74
71092: PUSH
71093: LD_VAR 0 2
71097: ARRAY
71098: PPUSH
71099: CALL 18121 0 1
71103: MOD
71104: PUSH
71105: LD_INT 1
71107: PLUS
71108: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
71109: LD_EXP 75
71113: PUSH
71114: LD_VAR 0 2
71118: ARRAY
71119: PUSH
71120: LD_VAR 0 3
71124: ARRAY
71125: PPUSH
71126: LD_EXP 74
71130: PUSH
71131: LD_VAR 0 2
71135: ARRAY
71136: PUSH
71137: LD_VAR 0 7
71141: ARRAY
71142: PUSH
71143: LD_INT 1
71145: ARRAY
71146: PPUSH
71147: LD_EXP 74
71151: PUSH
71152: LD_VAR 0 2
71156: ARRAY
71157: PUSH
71158: LD_VAR 0 7
71162: ARRAY
71163: PUSH
71164: LD_INT 2
71166: ARRAY
71167: PPUSH
71168: LD_INT 0
71170: PPUSH
71171: CALL_OW 193
// end ; end ; end ;
71175: GO 70821
71177: POP
71178: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
71179: LD_ADDR_VAR 0 5
71183: PUSH
71184: LD_EXP 61
71188: PUSH
71189: LD_VAR 0 2
71193: ARRAY
71194: PPUSH
71195: LD_INT 2
71197: PUSH
71198: LD_INT 30
71200: PUSH
71201: LD_INT 4
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 30
71210: PUSH
71211: LD_INT 5
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 30
71220: PUSH
71221: LD_INT 32
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: LIST
71232: LIST
71233: PPUSH
71234: CALL_OW 72
71238: ST_TO_ADDR
// if not tmp then
71239: LD_VAR 0 5
71243: NOT
71244: IFFALSE 71248
// continue ;
71246: GO 70734
// list := [ ] ;
71248: LD_ADDR_VAR 0 6
71252: PUSH
71253: EMPTY
71254: ST_TO_ADDR
// for j in tmp do
71255: LD_ADDR_VAR 0 3
71259: PUSH
71260: LD_VAR 0 5
71264: PUSH
71265: FOR_IN
71266: IFFALSE 71335
// begin for k in UnitsInside ( j ) do
71268: LD_ADDR_VAR 0 4
71272: PUSH
71273: LD_VAR 0 3
71277: PPUSH
71278: CALL_OW 313
71282: PUSH
71283: FOR_IN
71284: IFFALSE 71331
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
71286: LD_VAR 0 4
71290: PPUSH
71291: CALL_OW 257
71295: PUSH
71296: LD_INT 1
71298: EQUAL
71299: PUSH
71300: LD_VAR 0 4
71304: PPUSH
71305: CALL_OW 459
71309: NOT
71310: AND
71311: IFFALSE 71329
// list := list ^ k ;
71313: LD_ADDR_VAR 0 6
71317: PUSH
71318: LD_VAR 0 6
71322: PUSH
71323: LD_VAR 0 4
71327: ADD
71328: ST_TO_ADDR
71329: GO 71283
71331: POP
71332: POP
// end ;
71333: GO 71265
71335: POP
71336: POP
// list := list diff mc_miners [ i ] ;
71337: LD_ADDR_VAR 0 6
71341: PUSH
71342: LD_VAR 0 6
71346: PUSH
71347: LD_EXP 75
71351: PUSH
71352: LD_VAR 0 2
71356: ARRAY
71357: DIFF
71358: ST_TO_ADDR
// if not list then
71359: LD_VAR 0 6
71363: NOT
71364: IFFALSE 71368
// continue ;
71366: GO 70734
// k := mc_mines [ i ] - mc_miners [ i ] ;
71368: LD_ADDR_VAR 0 4
71372: PUSH
71373: LD_EXP 74
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PUSH
71384: LD_EXP 75
71388: PUSH
71389: LD_VAR 0 2
71393: ARRAY
71394: MINUS
71395: ST_TO_ADDR
// if k > list then
71396: LD_VAR 0 4
71400: PUSH
71401: LD_VAR 0 6
71405: GREATER
71406: IFFALSE 71418
// k := list ;
71408: LD_ADDR_VAR 0 4
71412: PUSH
71413: LD_VAR 0 6
71417: ST_TO_ADDR
// for j = 1 to k do
71418: LD_ADDR_VAR 0 3
71422: PUSH
71423: DOUBLE
71424: LD_INT 1
71426: DEC
71427: ST_TO_ADDR
71428: LD_VAR 0 4
71432: PUSH
71433: FOR_TO
71434: IFFALSE 71488
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
71436: LD_ADDR_EXP 75
71440: PUSH
71441: LD_EXP 75
71445: PPUSH
71446: LD_VAR 0 2
71450: PUSH
71451: LD_EXP 75
71455: PUSH
71456: LD_VAR 0 2
71460: ARRAY
71461: PUSH
71462: LD_INT 1
71464: PLUS
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: PPUSH
71470: LD_VAR 0 6
71474: PUSH
71475: LD_VAR 0 3
71479: ARRAY
71480: PPUSH
71481: CALL 20981 0 3
71485: ST_TO_ADDR
71486: GO 71433
71488: POP
71489: POP
// end ;
71490: GO 70734
71492: POP
71493: POP
// end ;
71494: LD_VAR 0 1
71498: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
71499: LD_INT 0
71501: PPUSH
71502: PPUSH
71503: PPUSH
71504: PPUSH
71505: PPUSH
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
71510: PPUSH
71511: PPUSH
// if not mc_bases then
71512: LD_EXP 61
71516: NOT
71517: IFFALSE 71521
// exit ;
71519: GO 73344
// for i = 1 to mc_bases do
71521: LD_ADDR_VAR 0 2
71525: PUSH
71526: DOUBLE
71527: LD_INT 1
71529: DEC
71530: ST_TO_ADDR
71531: LD_EXP 61
71535: PUSH
71536: FOR_TO
71537: IFFALSE 73342
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
71539: LD_EXP 61
71543: PUSH
71544: LD_VAR 0 2
71548: ARRAY
71549: NOT
71550: PUSH
71551: LD_EXP 68
71555: PUSH
71556: LD_VAR 0 2
71560: ARRAY
71561: OR
71562: IFFALSE 71566
// continue ;
71564: GO 71536
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
71566: LD_EXP 77
71570: PUSH
71571: LD_VAR 0 2
71575: ARRAY
71576: NOT
71577: PUSH
71578: LD_EXP 78
71582: PUSH
71583: LD_VAR 0 2
71587: ARRAY
71588: AND
71589: IFFALSE 71627
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
71591: LD_ADDR_EXP 78
71595: PUSH
71596: LD_EXP 78
71600: PPUSH
71601: LD_VAR 0 2
71605: PPUSH
71606: EMPTY
71607: PPUSH
71608: CALL_OW 1
71612: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
71613: LD_VAR 0 2
71617: PPUSH
71618: LD_INT 107
71620: PPUSH
71621: CALL 62353 0 2
// continue ;
71625: GO 71536
// end ; target := [ ] ;
71627: LD_ADDR_VAR 0 7
71631: PUSH
71632: EMPTY
71633: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71634: LD_ADDR_VAR 0 6
71638: PUSH
71639: LD_EXP 61
71643: PUSH
71644: LD_VAR 0 2
71648: ARRAY
71649: PUSH
71650: LD_INT 1
71652: ARRAY
71653: PPUSH
71654: CALL_OW 255
71658: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71659: LD_ADDR_VAR 0 9
71663: PUSH
71664: LD_EXP 61
71668: PUSH
71669: LD_VAR 0 2
71673: ARRAY
71674: PPUSH
71675: LD_INT 2
71677: PUSH
71678: LD_INT 30
71680: PUSH
71681: LD_INT 0
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 30
71690: PUSH
71691: LD_INT 1
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: LIST
71702: PPUSH
71703: CALL_OW 72
71707: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
71708: LD_ADDR_VAR 0 3
71712: PUSH
71713: DOUBLE
71714: LD_EXP 77
71718: PUSH
71719: LD_VAR 0 2
71723: ARRAY
71724: INC
71725: ST_TO_ADDR
71726: LD_INT 1
71728: PUSH
71729: FOR_DOWNTO
71730: IFFALSE 71975
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
71732: LD_EXP 77
71736: PUSH
71737: LD_VAR 0 2
71741: ARRAY
71742: PUSH
71743: LD_VAR 0 3
71747: ARRAY
71748: PUSH
71749: LD_INT 2
71751: ARRAY
71752: PPUSH
71753: LD_EXP 77
71757: PUSH
71758: LD_VAR 0 2
71762: ARRAY
71763: PUSH
71764: LD_VAR 0 3
71768: ARRAY
71769: PUSH
71770: LD_INT 3
71772: ARRAY
71773: PPUSH
71774: CALL_OW 488
71778: PUSH
71779: LD_EXP 77
71783: PUSH
71784: LD_VAR 0 2
71788: ARRAY
71789: PUSH
71790: LD_VAR 0 3
71794: ARRAY
71795: PUSH
71796: LD_INT 2
71798: ARRAY
71799: PPUSH
71800: LD_EXP 77
71804: PUSH
71805: LD_VAR 0 2
71809: ARRAY
71810: PUSH
71811: LD_VAR 0 3
71815: ARRAY
71816: PUSH
71817: LD_INT 3
71819: ARRAY
71820: PPUSH
71821: CALL_OW 284
71825: PUSH
71826: LD_INT 0
71828: EQUAL
71829: AND
71830: IFFALSE 71885
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
71832: LD_ADDR_VAR 0 5
71836: PUSH
71837: LD_EXP 77
71841: PUSH
71842: LD_VAR 0 2
71846: ARRAY
71847: PPUSH
71848: LD_VAR 0 3
71852: PPUSH
71853: CALL_OW 3
71857: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
71858: LD_ADDR_EXP 77
71862: PUSH
71863: LD_EXP 77
71867: PPUSH
71868: LD_VAR 0 2
71872: PPUSH
71873: LD_VAR 0 5
71877: PPUSH
71878: CALL_OW 1
71882: ST_TO_ADDR
// continue ;
71883: GO 71729
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
71885: LD_VAR 0 6
71889: PPUSH
71890: LD_EXP 77
71894: PUSH
71895: LD_VAR 0 2
71899: ARRAY
71900: PUSH
71901: LD_VAR 0 3
71905: ARRAY
71906: PUSH
71907: LD_INT 2
71909: ARRAY
71910: PPUSH
71911: LD_EXP 77
71915: PUSH
71916: LD_VAR 0 2
71920: ARRAY
71921: PUSH
71922: LD_VAR 0 3
71926: ARRAY
71927: PUSH
71928: LD_INT 3
71930: ARRAY
71931: PPUSH
71932: LD_INT 30
71934: PPUSH
71935: CALL 22245 0 4
71939: PUSH
71940: LD_INT 4
71942: ARRAY
71943: PUSH
71944: LD_INT 0
71946: EQUAL
71947: IFFALSE 71973
// begin target := mc_crates [ i ] [ j ] ;
71949: LD_ADDR_VAR 0 7
71953: PUSH
71954: LD_EXP 77
71958: PUSH
71959: LD_VAR 0 2
71963: ARRAY
71964: PUSH
71965: LD_VAR 0 3
71969: ARRAY
71970: ST_TO_ADDR
// break ;
71971: GO 71975
// end ; end ;
71973: GO 71729
71975: POP
71976: POP
// if not target then
71977: LD_VAR 0 7
71981: NOT
71982: IFFALSE 71986
// continue ;
71984: GO 71536
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
71986: LD_ADDR_VAR 0 8
71990: PUSH
71991: LD_EXP 80
71995: PUSH
71996: LD_VAR 0 2
72000: ARRAY
72001: PPUSH
72002: LD_INT 2
72004: PUSH
72005: LD_INT 3
72007: PUSH
72008: LD_INT 58
72010: PUSH
72011: EMPTY
72012: LIST
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 61
72020: PUSH
72021: EMPTY
72022: LIST
72023: PUSH
72024: LD_INT 33
72026: PUSH
72027: LD_INT 5
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 33
72036: PUSH
72037: LD_INT 3
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 2
72053: PUSH
72054: LD_INT 34
72056: PUSH
72057: LD_INT 32
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 34
72066: PUSH
72067: LD_INT 51
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 34
72076: PUSH
72077: LD_INT 12
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PPUSH
72094: CALL_OW 72
72098: ST_TO_ADDR
// if not cargo then
72099: LD_VAR 0 8
72103: NOT
72104: IFFALSE 72810
// begin if mc_crates_collector [ i ] < 5 then
72106: LD_EXP 78
72110: PUSH
72111: LD_VAR 0 2
72115: ARRAY
72116: PUSH
72117: LD_INT 5
72119: LESS
72120: IFFALSE 72486
// begin if mc_ape [ i ] then
72122: LD_EXP 90
72126: PUSH
72127: LD_VAR 0 2
72131: ARRAY
72132: IFFALSE 72179
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
72134: LD_ADDR_VAR 0 5
72138: PUSH
72139: LD_EXP 90
72143: PUSH
72144: LD_VAR 0 2
72148: ARRAY
72149: PPUSH
72150: LD_INT 25
72152: PUSH
72153: LD_INT 16
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 24
72162: PUSH
72163: LD_INT 750
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PPUSH
72174: CALL_OW 72
72178: ST_TO_ADDR
// if not tmp then
72179: LD_VAR 0 5
72183: NOT
72184: IFFALSE 72231
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
72186: LD_ADDR_VAR 0 5
72190: PUSH
72191: LD_EXP 61
72195: PUSH
72196: LD_VAR 0 2
72200: ARRAY
72201: PPUSH
72202: LD_INT 25
72204: PUSH
72205: LD_INT 2
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 24
72214: PUSH
72215: LD_INT 750
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PPUSH
72226: CALL_OW 72
72230: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
72231: LD_EXP 90
72235: PUSH
72236: LD_VAR 0 2
72240: ARRAY
72241: PUSH
72242: LD_EXP 61
72246: PUSH
72247: LD_VAR 0 2
72251: ARRAY
72252: PPUSH
72253: LD_INT 25
72255: PUSH
72256: LD_INT 2
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 24
72265: PUSH
72266: LD_INT 750
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PPUSH
72277: CALL_OW 72
72281: AND
72282: PUSH
72283: LD_VAR 0 5
72287: PUSH
72288: LD_INT 5
72290: LESS
72291: AND
72292: IFFALSE 72374
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
72294: LD_ADDR_VAR 0 3
72298: PUSH
72299: LD_EXP 61
72303: PUSH
72304: LD_VAR 0 2
72308: ARRAY
72309: PPUSH
72310: LD_INT 25
72312: PUSH
72313: LD_INT 2
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 24
72322: PUSH
72323: LD_INT 750
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PPUSH
72334: CALL_OW 72
72338: PUSH
72339: FOR_IN
72340: IFFALSE 72372
// begin tmp := tmp union j ;
72342: LD_ADDR_VAR 0 5
72346: PUSH
72347: LD_VAR 0 5
72351: PUSH
72352: LD_VAR 0 3
72356: UNION
72357: ST_TO_ADDR
// if tmp >= 5 then
72358: LD_VAR 0 5
72362: PUSH
72363: LD_INT 5
72365: GREATEREQUAL
72366: IFFALSE 72370
// break ;
72368: GO 72372
// end ;
72370: GO 72339
72372: POP
72373: POP
// end ; if not tmp then
72374: LD_VAR 0 5
72378: NOT
72379: IFFALSE 72383
// continue ;
72381: GO 71536
// for j in tmp do
72383: LD_ADDR_VAR 0 3
72387: PUSH
72388: LD_VAR 0 5
72392: PUSH
72393: FOR_IN
72394: IFFALSE 72484
// if not GetTag ( j ) then
72396: LD_VAR 0 3
72400: PPUSH
72401: CALL_OW 110
72405: NOT
72406: IFFALSE 72482
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
72408: LD_ADDR_EXP 78
72412: PUSH
72413: LD_EXP 78
72417: PPUSH
72418: LD_VAR 0 2
72422: PUSH
72423: LD_EXP 78
72427: PUSH
72428: LD_VAR 0 2
72432: ARRAY
72433: PUSH
72434: LD_INT 1
72436: PLUS
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PPUSH
72442: LD_VAR 0 3
72446: PPUSH
72447: CALL 20981 0 3
72451: ST_TO_ADDR
// SetTag ( j , 107 ) ;
72452: LD_VAR 0 3
72456: PPUSH
72457: LD_INT 107
72459: PPUSH
72460: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
72464: LD_EXP 78
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: PUSH
72475: LD_INT 5
72477: GREATEREQUAL
72478: IFFALSE 72482
// break ;
72480: GO 72484
// end ;
72482: GO 72393
72484: POP
72485: POP
// end ; if mc_crates_collector [ i ] and target then
72486: LD_EXP 78
72490: PUSH
72491: LD_VAR 0 2
72495: ARRAY
72496: PUSH
72497: LD_VAR 0 7
72501: AND
72502: IFFALSE 72808
// begin if mc_crates_collector [ i ] < target [ 1 ] then
72504: LD_EXP 78
72508: PUSH
72509: LD_VAR 0 2
72513: ARRAY
72514: PUSH
72515: LD_VAR 0 7
72519: PUSH
72520: LD_INT 1
72522: ARRAY
72523: LESS
72524: IFFALSE 72544
// tmp := mc_crates_collector [ i ] else
72526: LD_ADDR_VAR 0 5
72530: PUSH
72531: LD_EXP 78
72535: PUSH
72536: LD_VAR 0 2
72540: ARRAY
72541: ST_TO_ADDR
72542: GO 72558
// tmp := target [ 1 ] ;
72544: LD_ADDR_VAR 0 5
72548: PUSH
72549: LD_VAR 0 7
72553: PUSH
72554: LD_INT 1
72556: ARRAY
72557: ST_TO_ADDR
// k := 0 ;
72558: LD_ADDR_VAR 0 4
72562: PUSH
72563: LD_INT 0
72565: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
72566: LD_ADDR_VAR 0 3
72570: PUSH
72571: LD_EXP 78
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PUSH
72582: FOR_IN
72583: IFFALSE 72806
// begin k := k + 1 ;
72585: LD_ADDR_VAR 0 4
72589: PUSH
72590: LD_VAR 0 4
72594: PUSH
72595: LD_INT 1
72597: PLUS
72598: ST_TO_ADDR
// if k > tmp then
72599: LD_VAR 0 4
72603: PUSH
72604: LD_VAR 0 5
72608: GREATER
72609: IFFALSE 72613
// break ;
72611: GO 72806
// if not GetClass ( j ) in [ 2 , 16 ] then
72613: LD_VAR 0 3
72617: PPUSH
72618: CALL_OW 257
72622: PUSH
72623: LD_INT 2
72625: PUSH
72626: LD_INT 16
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: IN
72633: NOT
72634: IFFALSE 72687
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
72636: LD_ADDR_EXP 78
72640: PUSH
72641: LD_EXP 78
72645: PPUSH
72646: LD_VAR 0 2
72650: PPUSH
72651: LD_EXP 78
72655: PUSH
72656: LD_VAR 0 2
72660: ARRAY
72661: PUSH
72662: LD_VAR 0 3
72666: DIFF
72667: PPUSH
72668: CALL_OW 1
72672: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72673: LD_VAR 0 3
72677: PPUSH
72678: LD_INT 0
72680: PPUSH
72681: CALL_OW 109
// continue ;
72685: GO 72582
// end ; if IsInUnit ( j ) then
72687: LD_VAR 0 3
72691: PPUSH
72692: CALL_OW 310
72696: IFFALSE 72707
// ComExitBuilding ( j ) ;
72698: LD_VAR 0 3
72702: PPUSH
72703: CALL_OW 122
// wait ( 3 ) ;
72707: LD_INT 3
72709: PPUSH
72710: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
72714: LD_VAR 0 3
72718: PPUSH
72719: CALL_OW 314
72723: PUSH
72724: LD_VAR 0 6
72728: PPUSH
72729: LD_VAR 0 7
72733: PUSH
72734: LD_INT 2
72736: ARRAY
72737: PPUSH
72738: LD_VAR 0 7
72742: PUSH
72743: LD_INT 3
72745: ARRAY
72746: PPUSH
72747: LD_INT 30
72749: PPUSH
72750: CALL 22245 0 4
72754: PUSH
72755: LD_INT 4
72757: ARRAY
72758: AND
72759: IFFALSE 72777
// ComStandNearbyBuilding ( j , depot ) else
72761: LD_VAR 0 3
72765: PPUSH
72766: LD_VAR 0 9
72770: PPUSH
72771: CALL 17583 0 2
72775: GO 72804
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72777: LD_VAR 0 3
72781: PPUSH
72782: LD_VAR 0 7
72786: PUSH
72787: LD_INT 2
72789: ARRAY
72790: PPUSH
72791: LD_VAR 0 7
72795: PUSH
72796: LD_INT 3
72798: ARRAY
72799: PPUSH
72800: CALL_OW 117
// end ;
72804: GO 72582
72806: POP
72807: POP
// end ; end else
72808: GO 73340
// begin for j in cargo do
72810: LD_ADDR_VAR 0 3
72814: PUSH
72815: LD_VAR 0 8
72819: PUSH
72820: FOR_IN
72821: IFFALSE 73338
// begin if GetTag ( j ) <> 0 then
72823: LD_VAR 0 3
72827: PPUSH
72828: CALL_OW 110
72832: PUSH
72833: LD_INT 0
72835: NONEQUAL
72836: IFFALSE 72840
// continue ;
72838: GO 72820
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
72840: LD_VAR 0 3
72844: PPUSH
72845: CALL_OW 256
72849: PUSH
72850: LD_INT 1000
72852: LESS
72853: PUSH
72854: LD_VAR 0 3
72858: PPUSH
72859: LD_EXP 85
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: PPUSH
72870: CALL_OW 308
72874: NOT
72875: AND
72876: IFFALSE 72898
// ComMoveToArea ( j , mc_parking [ i ] ) ;
72878: LD_VAR 0 3
72882: PPUSH
72883: LD_EXP 85
72887: PUSH
72888: LD_VAR 0 2
72892: ARRAY
72893: PPUSH
72894: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
72898: LD_VAR 0 3
72902: PPUSH
72903: CALL_OW 256
72907: PUSH
72908: LD_INT 1000
72910: LESS
72911: PUSH
72912: LD_VAR 0 3
72916: PPUSH
72917: LD_EXP 85
72921: PUSH
72922: LD_VAR 0 2
72926: ARRAY
72927: PPUSH
72928: CALL_OW 308
72932: AND
72933: IFFALSE 72937
// continue ;
72935: GO 72820
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
72937: LD_VAR 0 3
72941: PPUSH
72942: CALL_OW 262
72946: PUSH
72947: LD_INT 2
72949: EQUAL
72950: PUSH
72951: LD_VAR 0 3
72955: PPUSH
72956: CALL_OW 261
72960: PUSH
72961: LD_INT 15
72963: LESS
72964: AND
72965: IFFALSE 72969
// continue ;
72967: GO 72820
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
72969: LD_VAR 0 3
72973: PPUSH
72974: CALL_OW 262
72978: PUSH
72979: LD_INT 1
72981: EQUAL
72982: PUSH
72983: LD_VAR 0 3
72987: PPUSH
72988: CALL_OW 261
72992: PUSH
72993: LD_INT 10
72995: LESS
72996: AND
72997: IFFALSE 73277
// begin if not depot then
72999: LD_VAR 0 9
73003: NOT
73004: IFFALSE 73008
// continue ;
73006: GO 72820
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
73008: LD_VAR 0 3
73012: PPUSH
73013: LD_VAR 0 9
73017: PPUSH
73018: LD_VAR 0 3
73022: PPUSH
73023: CALL_OW 74
73027: PPUSH
73028: CALL_OW 296
73032: PUSH
73033: LD_INT 6
73035: LESS
73036: IFFALSE 73052
// SetFuel ( j , 100 ) else
73038: LD_VAR 0 3
73042: PPUSH
73043: LD_INT 100
73045: PPUSH
73046: CALL_OW 240
73050: GO 73277
// if GetFuel ( j ) = 0 then
73052: LD_VAR 0 3
73056: PPUSH
73057: CALL_OW 261
73061: PUSH
73062: LD_INT 0
73064: EQUAL
73065: IFFALSE 73277
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
73067: LD_ADDR_EXP 80
73071: PUSH
73072: LD_EXP 80
73076: PPUSH
73077: LD_VAR 0 2
73081: PPUSH
73082: LD_EXP 80
73086: PUSH
73087: LD_VAR 0 2
73091: ARRAY
73092: PUSH
73093: LD_VAR 0 3
73097: DIFF
73098: PPUSH
73099: CALL_OW 1
73103: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
73104: LD_VAR 0 3
73108: PPUSH
73109: CALL_OW 263
73113: PUSH
73114: LD_INT 1
73116: EQUAL
73117: IFFALSE 73133
// ComExitVehicle ( IsInUnit ( j ) ) ;
73119: LD_VAR 0 3
73123: PPUSH
73124: CALL_OW 310
73128: PPUSH
73129: CALL_OW 121
// if GetControl ( j ) = control_remote then
73133: LD_VAR 0 3
73137: PPUSH
73138: CALL_OW 263
73142: PUSH
73143: LD_INT 2
73145: EQUAL
73146: IFFALSE 73157
// ComUnlink ( j ) ;
73148: LD_VAR 0 3
73152: PPUSH
73153: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
73157: LD_ADDR_VAR 0 10
73161: PUSH
73162: LD_VAR 0 2
73166: PPUSH
73167: LD_INT 3
73169: PPUSH
73170: CALL 82921 0 2
73174: ST_TO_ADDR
// if fac then
73175: LD_VAR 0 10
73179: IFFALSE 73275
// begin for k in fac do
73181: LD_ADDR_VAR 0 4
73185: PUSH
73186: LD_VAR 0 10
73190: PUSH
73191: FOR_IN
73192: IFFALSE 73273
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
73194: LD_ADDR_VAR 0 11
73198: PUSH
73199: LD_VAR 0 10
73203: PPUSH
73204: LD_VAR 0 3
73208: PPUSH
73209: CALL_OW 265
73213: PPUSH
73214: LD_VAR 0 3
73218: PPUSH
73219: CALL_OW 262
73223: PPUSH
73224: LD_VAR 0 3
73228: PPUSH
73229: CALL_OW 263
73233: PPUSH
73234: LD_VAR 0 3
73238: PPUSH
73239: CALL_OW 264
73243: PPUSH
73244: CALL 18479 0 5
73248: ST_TO_ADDR
// if components then
73249: LD_VAR 0 11
73253: IFFALSE 73271
// begin MC_InsertProduceList ( i , components ) ;
73255: LD_VAR 0 2
73259: PPUSH
73260: LD_VAR 0 11
73264: PPUSH
73265: CALL 82466 0 2
// break ;
73269: GO 73273
// end ; end ;
73271: GO 73191
73273: POP
73274: POP
// end ; continue ;
73275: GO 72820
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
73277: LD_VAR 0 3
73281: PPUSH
73282: LD_INT 1
73284: PPUSH
73285: CALL_OW 289
73289: PUSH
73290: LD_INT 100
73292: LESS
73293: PUSH
73294: LD_VAR 0 3
73298: PPUSH
73299: CALL_OW 314
73303: NOT
73304: AND
73305: IFFALSE 73334
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
73307: LD_VAR 0 3
73311: PPUSH
73312: LD_VAR 0 7
73316: PUSH
73317: LD_INT 2
73319: ARRAY
73320: PPUSH
73321: LD_VAR 0 7
73325: PUSH
73326: LD_INT 3
73328: ARRAY
73329: PPUSH
73330: CALL_OW 117
// break ;
73334: GO 73338
// end ;
73336: GO 72820
73338: POP
73339: POP
// end ; end ;
73340: GO 71536
73342: POP
73343: POP
// end ;
73344: LD_VAR 0 1
73348: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
73349: LD_INT 0
73351: PPUSH
73352: PPUSH
73353: PPUSH
73354: PPUSH
// if not mc_bases then
73355: LD_EXP 61
73359: NOT
73360: IFFALSE 73364
// exit ;
73362: GO 73525
// for i = 1 to mc_bases do
73364: LD_ADDR_VAR 0 2
73368: PUSH
73369: DOUBLE
73370: LD_INT 1
73372: DEC
73373: ST_TO_ADDR
73374: LD_EXP 61
73378: PUSH
73379: FOR_TO
73380: IFFALSE 73523
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
73382: LD_ADDR_VAR 0 4
73386: PUSH
73387: LD_EXP 80
73391: PUSH
73392: LD_VAR 0 2
73396: ARRAY
73397: PUSH
73398: LD_EXP 83
73402: PUSH
73403: LD_VAR 0 2
73407: ARRAY
73408: UNION
73409: PPUSH
73410: LD_INT 33
73412: PUSH
73413: LD_INT 2
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PPUSH
73420: CALL_OW 72
73424: ST_TO_ADDR
// if tmp then
73425: LD_VAR 0 4
73429: IFFALSE 73521
// for j in tmp do
73431: LD_ADDR_VAR 0 3
73435: PUSH
73436: LD_VAR 0 4
73440: PUSH
73441: FOR_IN
73442: IFFALSE 73519
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
73444: LD_VAR 0 3
73448: PPUSH
73449: CALL_OW 312
73453: NOT
73454: PUSH
73455: LD_VAR 0 3
73459: PPUSH
73460: CALL_OW 256
73464: PUSH
73465: LD_INT 250
73467: GREATEREQUAL
73468: AND
73469: IFFALSE 73482
// Connect ( j ) else
73471: LD_VAR 0 3
73475: PPUSH
73476: CALL 24327 0 1
73480: GO 73517
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
73482: LD_VAR 0 3
73486: PPUSH
73487: CALL_OW 256
73491: PUSH
73492: LD_INT 250
73494: LESS
73495: PUSH
73496: LD_VAR 0 3
73500: PPUSH
73501: CALL_OW 312
73505: AND
73506: IFFALSE 73517
// ComUnlink ( j ) ;
73508: LD_VAR 0 3
73512: PPUSH
73513: CALL_OW 136
73517: GO 73441
73519: POP
73520: POP
// end ;
73521: GO 73379
73523: POP
73524: POP
// end ;
73525: LD_VAR 0 1
73529: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
73530: LD_INT 0
73532: PPUSH
73533: PPUSH
73534: PPUSH
73535: PPUSH
73536: PPUSH
// if not mc_bases then
73537: LD_EXP 61
73541: NOT
73542: IFFALSE 73546
// exit ;
73544: GO 73991
// for i = 1 to mc_bases do
73546: LD_ADDR_VAR 0 2
73550: PUSH
73551: DOUBLE
73552: LD_INT 1
73554: DEC
73555: ST_TO_ADDR
73556: LD_EXP 61
73560: PUSH
73561: FOR_TO
73562: IFFALSE 73989
// begin if not mc_produce [ i ] then
73564: LD_EXP 82
73568: PUSH
73569: LD_VAR 0 2
73573: ARRAY
73574: NOT
73575: IFFALSE 73579
// continue ;
73577: GO 73561
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73579: LD_ADDR_VAR 0 5
73583: PUSH
73584: LD_EXP 61
73588: PUSH
73589: LD_VAR 0 2
73593: ARRAY
73594: PPUSH
73595: LD_INT 30
73597: PUSH
73598: LD_INT 3
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PPUSH
73605: CALL_OW 72
73609: ST_TO_ADDR
// if not fac then
73610: LD_VAR 0 5
73614: NOT
73615: IFFALSE 73619
// continue ;
73617: GO 73561
// for j in fac do
73619: LD_ADDR_VAR 0 3
73623: PUSH
73624: LD_VAR 0 5
73628: PUSH
73629: FOR_IN
73630: IFFALSE 73985
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
73632: LD_VAR 0 3
73636: PPUSH
73637: CALL_OW 461
73641: PUSH
73642: LD_INT 2
73644: NONEQUAL
73645: PUSH
73646: LD_VAR 0 3
73650: PPUSH
73651: LD_INT 15
73653: PPUSH
73654: CALL 23946 0 2
73658: PUSH
73659: LD_INT 4
73661: ARRAY
73662: OR
73663: IFFALSE 73667
// continue ;
73665: GO 73629
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
73667: LD_VAR 0 3
73671: PPUSH
73672: LD_EXP 82
73676: PUSH
73677: LD_VAR 0 2
73681: ARRAY
73682: PUSH
73683: LD_INT 1
73685: ARRAY
73686: PUSH
73687: LD_INT 1
73689: ARRAY
73690: PPUSH
73691: LD_EXP 82
73695: PUSH
73696: LD_VAR 0 2
73700: ARRAY
73701: PUSH
73702: LD_INT 1
73704: ARRAY
73705: PUSH
73706: LD_INT 2
73708: ARRAY
73709: PPUSH
73710: LD_EXP 82
73714: PUSH
73715: LD_VAR 0 2
73719: ARRAY
73720: PUSH
73721: LD_INT 1
73723: ARRAY
73724: PUSH
73725: LD_INT 3
73727: ARRAY
73728: PPUSH
73729: LD_EXP 82
73733: PUSH
73734: LD_VAR 0 2
73738: ARRAY
73739: PUSH
73740: LD_INT 1
73742: ARRAY
73743: PUSH
73744: LD_INT 4
73746: ARRAY
73747: PPUSH
73748: CALL_OW 448
73752: PUSH
73753: LD_VAR 0 3
73757: PPUSH
73758: LD_EXP 82
73762: PUSH
73763: LD_VAR 0 2
73767: ARRAY
73768: PUSH
73769: LD_INT 1
73771: ARRAY
73772: PUSH
73773: LD_INT 1
73775: ARRAY
73776: PUSH
73777: LD_EXP 82
73781: PUSH
73782: LD_VAR 0 2
73786: ARRAY
73787: PUSH
73788: LD_INT 1
73790: ARRAY
73791: PUSH
73792: LD_INT 2
73794: ARRAY
73795: PUSH
73796: LD_EXP 82
73800: PUSH
73801: LD_VAR 0 2
73805: ARRAY
73806: PUSH
73807: LD_INT 1
73809: ARRAY
73810: PUSH
73811: LD_INT 3
73813: ARRAY
73814: PUSH
73815: LD_EXP 82
73819: PUSH
73820: LD_VAR 0 2
73824: ARRAY
73825: PUSH
73826: LD_INT 1
73828: ARRAY
73829: PUSH
73830: LD_INT 4
73832: ARRAY
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: PPUSH
73840: CALL 27722 0 2
73844: AND
73845: IFFALSE 73983
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
73847: LD_VAR 0 3
73851: PPUSH
73852: LD_EXP 82
73856: PUSH
73857: LD_VAR 0 2
73861: ARRAY
73862: PUSH
73863: LD_INT 1
73865: ARRAY
73866: PUSH
73867: LD_INT 1
73869: ARRAY
73870: PPUSH
73871: LD_EXP 82
73875: PUSH
73876: LD_VAR 0 2
73880: ARRAY
73881: PUSH
73882: LD_INT 1
73884: ARRAY
73885: PUSH
73886: LD_INT 2
73888: ARRAY
73889: PPUSH
73890: LD_EXP 82
73894: PUSH
73895: LD_VAR 0 2
73899: ARRAY
73900: PUSH
73901: LD_INT 1
73903: ARRAY
73904: PUSH
73905: LD_INT 3
73907: ARRAY
73908: PPUSH
73909: LD_EXP 82
73913: PUSH
73914: LD_VAR 0 2
73918: ARRAY
73919: PUSH
73920: LD_INT 1
73922: ARRAY
73923: PUSH
73924: LD_INT 4
73926: ARRAY
73927: PPUSH
73928: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
73932: LD_ADDR_VAR 0 4
73936: PUSH
73937: LD_EXP 82
73941: PUSH
73942: LD_VAR 0 2
73946: ARRAY
73947: PPUSH
73948: LD_INT 1
73950: PPUSH
73951: CALL_OW 3
73955: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
73956: LD_ADDR_EXP 82
73960: PUSH
73961: LD_EXP 82
73965: PPUSH
73966: LD_VAR 0 2
73970: PPUSH
73971: LD_VAR 0 4
73975: PPUSH
73976: CALL_OW 1
73980: ST_TO_ADDR
// break ;
73981: GO 73985
// end ; end ;
73983: GO 73629
73985: POP
73986: POP
// end ;
73987: GO 73561
73989: POP
73990: POP
// end ;
73991: LD_VAR 0 1
73995: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
73996: LD_INT 0
73998: PPUSH
73999: PPUSH
74000: PPUSH
// if not mc_bases then
74001: LD_EXP 61
74005: NOT
74006: IFFALSE 74010
// exit ;
74008: GO 74099
// for i = 1 to mc_bases do
74010: LD_ADDR_VAR 0 2
74014: PUSH
74015: DOUBLE
74016: LD_INT 1
74018: DEC
74019: ST_TO_ADDR
74020: LD_EXP 61
74024: PUSH
74025: FOR_TO
74026: IFFALSE 74097
// begin if mc_attack [ i ] then
74028: LD_EXP 81
74032: PUSH
74033: LD_VAR 0 2
74037: ARRAY
74038: IFFALSE 74095
// begin tmp := mc_attack [ i ] [ 1 ] ;
74040: LD_ADDR_VAR 0 3
74044: PUSH
74045: LD_EXP 81
74049: PUSH
74050: LD_VAR 0 2
74054: ARRAY
74055: PUSH
74056: LD_INT 1
74058: ARRAY
74059: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
74060: LD_ADDR_EXP 81
74064: PUSH
74065: LD_EXP 81
74069: PPUSH
74070: LD_VAR 0 2
74074: PPUSH
74075: EMPTY
74076: PPUSH
74077: CALL_OW 1
74081: ST_TO_ADDR
// Attack ( tmp ) ;
74082: LD_VAR 0 3
74086: PPUSH
74087: CALL 109422 0 1
// exit ;
74091: POP
74092: POP
74093: GO 74099
// end ; end ;
74095: GO 74025
74097: POP
74098: POP
// end ;
74099: LD_VAR 0 1
74103: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
74104: LD_INT 0
74106: PPUSH
74107: PPUSH
74108: PPUSH
74109: PPUSH
74110: PPUSH
74111: PPUSH
74112: PPUSH
// if not mc_bases then
74113: LD_EXP 61
74117: NOT
74118: IFFALSE 74122
// exit ;
74120: GO 74979
// for i = 1 to mc_bases do
74122: LD_ADDR_VAR 0 2
74126: PUSH
74127: DOUBLE
74128: LD_INT 1
74130: DEC
74131: ST_TO_ADDR
74132: LD_EXP 61
74136: PUSH
74137: FOR_TO
74138: IFFALSE 74977
// begin if not mc_bases [ i ] then
74140: LD_EXP 61
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: NOT
74151: IFFALSE 74155
// continue ;
74153: GO 74137
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
74155: LD_ADDR_VAR 0 7
74159: PUSH
74160: LD_EXP 61
74164: PUSH
74165: LD_VAR 0 2
74169: ARRAY
74170: PUSH
74171: LD_INT 1
74173: ARRAY
74174: PPUSH
74175: CALL 17805 0 1
74179: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
74180: LD_ADDR_EXP 84
74184: PUSH
74185: LD_EXP 84
74189: PPUSH
74190: LD_VAR 0 2
74194: PPUSH
74195: LD_EXP 61
74199: PUSH
74200: LD_VAR 0 2
74204: ARRAY
74205: PUSH
74206: LD_INT 1
74208: ARRAY
74209: PPUSH
74210: CALL_OW 255
74214: PPUSH
74215: LD_EXP 86
74219: PUSH
74220: LD_VAR 0 2
74224: ARRAY
74225: PPUSH
74226: CALL 17770 0 2
74230: PPUSH
74231: CALL_OW 1
74235: ST_TO_ADDR
// if not mc_scan [ i ] then
74236: LD_EXP 84
74240: PUSH
74241: LD_VAR 0 2
74245: ARRAY
74246: NOT
74247: IFFALSE 74425
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
74249: LD_ADDR_EXP 104
74253: PUSH
74254: LD_EXP 104
74258: PPUSH
74259: LD_VAR 0 2
74263: PPUSH
74264: LD_INT 0
74266: PPUSH
74267: CALL_OW 1
74271: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
74272: LD_ADDR_VAR 0 4
74276: PUSH
74277: LD_EXP 61
74281: PUSH
74282: LD_VAR 0 2
74286: ARRAY
74287: PPUSH
74288: LD_INT 2
74290: PUSH
74291: LD_INT 25
74293: PUSH
74294: LD_INT 5
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 25
74303: PUSH
74304: LD_INT 8
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 25
74313: PUSH
74314: LD_INT 9
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: PPUSH
74327: CALL_OW 72
74331: ST_TO_ADDR
// if not tmp then
74332: LD_VAR 0 4
74336: NOT
74337: IFFALSE 74341
// continue ;
74339: GO 74137
// for j in tmp do
74341: LD_ADDR_VAR 0 3
74345: PUSH
74346: LD_VAR 0 4
74350: PUSH
74351: FOR_IN
74352: IFFALSE 74423
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
74354: LD_VAR 0 3
74358: PPUSH
74359: CALL_OW 310
74363: PPUSH
74364: CALL_OW 266
74368: PUSH
74369: LD_INT 5
74371: EQUAL
74372: PUSH
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 257
74382: PUSH
74383: LD_INT 1
74385: EQUAL
74386: AND
74387: PUSH
74388: LD_VAR 0 3
74392: PPUSH
74393: CALL_OW 459
74397: NOT
74398: AND
74399: PUSH
74400: LD_VAR 0 7
74404: AND
74405: IFFALSE 74421
// ComChangeProfession ( j , class ) ;
74407: LD_VAR 0 3
74411: PPUSH
74412: LD_VAR 0 7
74416: PPUSH
74417: CALL_OW 123
74421: GO 74351
74423: POP
74424: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
74425: LD_EXP 84
74429: PUSH
74430: LD_VAR 0 2
74434: ARRAY
74435: PUSH
74436: LD_EXP 104
74440: PUSH
74441: LD_VAR 0 2
74445: ARRAY
74446: NOT
74447: AND
74448: PUSH
74449: LD_EXP 83
74453: PUSH
74454: LD_VAR 0 2
74458: ARRAY
74459: NOT
74460: AND
74461: PUSH
74462: LD_EXP 61
74466: PUSH
74467: LD_VAR 0 2
74471: ARRAY
74472: PPUSH
74473: LD_INT 50
74475: PUSH
74476: EMPTY
74477: LIST
74478: PUSH
74479: LD_INT 2
74481: PUSH
74482: LD_INT 30
74484: PUSH
74485: LD_INT 32
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 30
74494: PUSH
74495: LD_INT 33
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: LD_INT 30
74504: PUSH
74505: LD_INT 4
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PUSH
74512: LD_INT 30
74514: PUSH
74515: LD_INT 5
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: PPUSH
74533: CALL_OW 72
74537: PUSH
74538: LD_INT 4
74540: LESS
74541: PUSH
74542: LD_EXP 61
74546: PUSH
74547: LD_VAR 0 2
74551: ARRAY
74552: PPUSH
74553: LD_INT 3
74555: PUSH
74556: LD_INT 24
74558: PUSH
74559: LD_INT 1000
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 2
74572: PUSH
74573: LD_INT 30
74575: PUSH
74576: LD_INT 0
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 30
74585: PUSH
74586: LD_INT 1
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: LIST
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PPUSH
74602: CALL_OW 72
74606: OR
74607: AND
74608: IFFALSE 74859
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
74610: LD_ADDR_EXP 104
74614: PUSH
74615: LD_EXP 104
74619: PPUSH
74620: LD_VAR 0 2
74624: PPUSH
74625: LD_INT 1
74627: PPUSH
74628: CALL_OW 1
74632: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
74633: LD_ADDR_VAR 0 4
74637: PUSH
74638: LD_EXP 61
74642: PUSH
74643: LD_VAR 0 2
74647: ARRAY
74648: PPUSH
74649: LD_INT 2
74651: PUSH
74652: LD_INT 25
74654: PUSH
74655: LD_INT 1
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: LD_INT 25
74664: PUSH
74665: LD_INT 5
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 25
74674: PUSH
74675: LD_INT 8
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 25
74684: PUSH
74685: LD_INT 9
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: LIST
74696: LIST
74697: LIST
74698: PPUSH
74699: CALL_OW 72
74703: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
74704: LD_ADDR_VAR 0 4
74708: PUSH
74709: LD_VAR 0 4
74713: PUSH
74714: LD_VAR 0 4
74718: PPUSH
74719: LD_INT 18
74721: PPUSH
74722: CALL 51290 0 2
74726: DIFF
74727: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
74728: LD_VAR 0 4
74732: NOT
74733: PUSH
74734: LD_EXP 61
74738: PUSH
74739: LD_VAR 0 2
74743: ARRAY
74744: PPUSH
74745: LD_INT 2
74747: PUSH
74748: LD_INT 30
74750: PUSH
74751: LD_INT 4
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 30
74760: PUSH
74761: LD_INT 5
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: LIST
74772: PPUSH
74773: CALL_OW 72
74777: NOT
74778: AND
74779: IFFALSE 74841
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
74781: LD_ADDR_VAR 0 4
74785: PUSH
74786: LD_EXP 61
74790: PUSH
74791: LD_VAR 0 2
74795: ARRAY
74796: PPUSH
74797: LD_INT 2
74799: PUSH
74800: LD_INT 25
74802: PUSH
74803: LD_INT 2
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 25
74812: PUSH
74813: LD_INT 3
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 25
74822: PUSH
74823: LD_INT 4
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: LIST
74834: LIST
74835: PPUSH
74836: CALL_OW 72
74840: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
74841: LD_VAR 0 2
74845: PPUSH
74846: LD_VAR 0 4
74850: PPUSH
74851: CALL 114131 0 2
// exit ;
74855: POP
74856: POP
74857: GO 74979
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
74859: LD_EXP 84
74863: PUSH
74864: LD_VAR 0 2
74868: ARRAY
74869: PUSH
74870: LD_EXP 104
74874: PUSH
74875: LD_VAR 0 2
74879: ARRAY
74880: NOT
74881: AND
74882: PUSH
74883: LD_EXP 83
74887: PUSH
74888: LD_VAR 0 2
74892: ARRAY
74893: AND
74894: IFFALSE 74975
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
74896: LD_ADDR_EXP 104
74900: PUSH
74901: LD_EXP 104
74905: PPUSH
74906: LD_VAR 0 2
74910: PPUSH
74911: LD_INT 1
74913: PPUSH
74914: CALL_OW 1
74918: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
74919: LD_ADDR_VAR 0 4
74923: PUSH
74924: LD_EXP 83
74928: PUSH
74929: LD_VAR 0 2
74933: ARRAY
74934: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
74935: LD_ADDR_EXP 83
74939: PUSH
74940: LD_EXP 83
74944: PPUSH
74945: LD_VAR 0 2
74949: PPUSH
74950: EMPTY
74951: PPUSH
74952: CALL_OW 1
74956: ST_TO_ADDR
// Defend ( i , tmp ) ;
74957: LD_VAR 0 2
74961: PPUSH
74962: LD_VAR 0 4
74966: PPUSH
74967: CALL 114727 0 2
// exit ;
74971: POP
74972: POP
74973: GO 74979
// end ; end ;
74975: GO 74137
74977: POP
74978: POP
// end ;
74979: LD_VAR 0 1
74983: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
74984: LD_INT 0
74986: PPUSH
74987: PPUSH
74988: PPUSH
74989: PPUSH
74990: PPUSH
74991: PPUSH
74992: PPUSH
74993: PPUSH
74994: PPUSH
74995: PPUSH
74996: PPUSH
// if not mc_bases then
74997: LD_EXP 61
75001: NOT
75002: IFFALSE 75006
// exit ;
75004: GO 76093
// for i = 1 to mc_bases do
75006: LD_ADDR_VAR 0 2
75010: PUSH
75011: DOUBLE
75012: LD_INT 1
75014: DEC
75015: ST_TO_ADDR
75016: LD_EXP 61
75020: PUSH
75021: FOR_TO
75022: IFFALSE 76091
// begin tmp := mc_lab [ i ] ;
75024: LD_ADDR_VAR 0 6
75028: PUSH
75029: LD_EXP 94
75033: PUSH
75034: LD_VAR 0 2
75038: ARRAY
75039: ST_TO_ADDR
// if not tmp then
75040: LD_VAR 0 6
75044: NOT
75045: IFFALSE 75049
// continue ;
75047: GO 75021
// idle_lab := 0 ;
75049: LD_ADDR_VAR 0 11
75053: PUSH
75054: LD_INT 0
75056: ST_TO_ADDR
// for j in tmp do
75057: LD_ADDR_VAR 0 3
75061: PUSH
75062: LD_VAR 0 6
75066: PUSH
75067: FOR_IN
75068: IFFALSE 76087
// begin researching := false ;
75070: LD_ADDR_VAR 0 10
75074: PUSH
75075: LD_INT 0
75077: ST_TO_ADDR
// side := GetSide ( j ) ;
75078: LD_ADDR_VAR 0 4
75082: PUSH
75083: LD_VAR 0 3
75087: PPUSH
75088: CALL_OW 255
75092: ST_TO_ADDR
// if not mc_tech [ side ] then
75093: LD_EXP 88
75097: PUSH
75098: LD_VAR 0 4
75102: ARRAY
75103: NOT
75104: IFFALSE 75108
// continue ;
75106: GO 75067
// if BuildingStatus ( j ) = bs_idle then
75108: LD_VAR 0 3
75112: PPUSH
75113: CALL_OW 461
75117: PUSH
75118: LD_INT 2
75120: EQUAL
75121: IFFALSE 75309
// begin if idle_lab and UnitsInside ( j ) < 6 then
75123: LD_VAR 0 11
75127: PUSH
75128: LD_VAR 0 3
75132: PPUSH
75133: CALL_OW 313
75137: PUSH
75138: LD_INT 6
75140: LESS
75141: AND
75142: IFFALSE 75213
// begin tmp2 := UnitsInside ( idle_lab ) ;
75144: LD_ADDR_VAR 0 9
75148: PUSH
75149: LD_VAR 0 11
75153: PPUSH
75154: CALL_OW 313
75158: ST_TO_ADDR
// if tmp2 then
75159: LD_VAR 0 9
75163: IFFALSE 75205
// for x in tmp2 do
75165: LD_ADDR_VAR 0 7
75169: PUSH
75170: LD_VAR 0 9
75174: PUSH
75175: FOR_IN
75176: IFFALSE 75203
// begin ComExitBuilding ( x ) ;
75178: LD_VAR 0 7
75182: PPUSH
75183: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
75187: LD_VAR 0 7
75191: PPUSH
75192: LD_VAR 0 3
75196: PPUSH
75197: CALL_OW 180
// end ;
75201: GO 75175
75203: POP
75204: POP
// idle_lab := 0 ;
75205: LD_ADDR_VAR 0 11
75209: PUSH
75210: LD_INT 0
75212: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
75213: LD_ADDR_VAR 0 5
75217: PUSH
75218: LD_EXP 88
75222: PUSH
75223: LD_VAR 0 4
75227: ARRAY
75228: PUSH
75229: FOR_IN
75230: IFFALSE 75290
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
75232: LD_VAR 0 3
75236: PPUSH
75237: LD_VAR 0 5
75241: PPUSH
75242: CALL_OW 430
75246: PUSH
75247: LD_VAR 0 4
75251: PPUSH
75252: LD_VAR 0 5
75256: PPUSH
75257: CALL 16875 0 2
75261: AND
75262: IFFALSE 75288
// begin researching := true ;
75264: LD_ADDR_VAR 0 10
75268: PUSH
75269: LD_INT 1
75271: ST_TO_ADDR
// ComResearch ( j , t ) ;
75272: LD_VAR 0 3
75276: PPUSH
75277: LD_VAR 0 5
75281: PPUSH
75282: CALL_OW 124
// break ;
75286: GO 75290
// end ;
75288: GO 75229
75290: POP
75291: POP
// if not researching then
75292: LD_VAR 0 10
75296: NOT
75297: IFFALSE 75309
// idle_lab := j ;
75299: LD_ADDR_VAR 0 11
75303: PUSH
75304: LD_VAR 0 3
75308: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
75309: LD_VAR 0 3
75313: PPUSH
75314: CALL_OW 461
75318: PUSH
75319: LD_INT 10
75321: EQUAL
75322: IFFALSE 75910
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
75324: LD_EXP 90
75328: PUSH
75329: LD_VAR 0 2
75333: ARRAY
75334: NOT
75335: PUSH
75336: LD_EXP 91
75340: PUSH
75341: LD_VAR 0 2
75345: ARRAY
75346: NOT
75347: AND
75348: PUSH
75349: LD_EXP 88
75353: PUSH
75354: LD_VAR 0 4
75358: ARRAY
75359: PUSH
75360: LD_INT 1
75362: GREATER
75363: AND
75364: IFFALSE 75495
// begin ComCancel ( j ) ;
75366: LD_VAR 0 3
75370: PPUSH
75371: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
75375: LD_ADDR_EXP 88
75379: PUSH
75380: LD_EXP 88
75384: PPUSH
75385: LD_VAR 0 4
75389: PPUSH
75390: LD_EXP 88
75394: PUSH
75395: LD_VAR 0 4
75399: ARRAY
75400: PPUSH
75401: LD_EXP 88
75405: PUSH
75406: LD_VAR 0 4
75410: ARRAY
75411: PUSH
75412: LD_INT 1
75414: MINUS
75415: PPUSH
75416: LD_EXP 88
75420: PUSH
75421: LD_VAR 0 4
75425: ARRAY
75426: PPUSH
75427: LD_INT 0
75429: PPUSH
75430: CALL 20399 0 4
75434: PPUSH
75435: CALL_OW 1
75439: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
75440: LD_ADDR_EXP 88
75444: PUSH
75445: LD_EXP 88
75449: PPUSH
75450: LD_VAR 0 4
75454: PPUSH
75455: LD_EXP 88
75459: PUSH
75460: LD_VAR 0 4
75464: ARRAY
75465: PPUSH
75466: LD_EXP 88
75470: PUSH
75471: LD_VAR 0 4
75475: ARRAY
75476: PPUSH
75477: LD_INT 1
75479: PPUSH
75480: LD_INT 0
75482: PPUSH
75483: CALL 20399 0 4
75487: PPUSH
75488: CALL_OW 1
75492: ST_TO_ADDR
// continue ;
75493: GO 75067
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
75495: LD_EXP 90
75499: PUSH
75500: LD_VAR 0 2
75504: ARRAY
75505: PUSH
75506: LD_EXP 91
75510: PUSH
75511: LD_VAR 0 2
75515: ARRAY
75516: NOT
75517: AND
75518: IFFALSE 75645
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
75520: LD_ADDR_EXP 91
75524: PUSH
75525: LD_EXP 91
75529: PPUSH
75530: LD_VAR 0 2
75534: PUSH
75535: LD_EXP 91
75539: PUSH
75540: LD_VAR 0 2
75544: ARRAY
75545: PUSH
75546: LD_INT 1
75548: PLUS
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PPUSH
75554: LD_EXP 90
75558: PUSH
75559: LD_VAR 0 2
75563: ARRAY
75564: PUSH
75565: LD_INT 1
75567: ARRAY
75568: PPUSH
75569: CALL 20981 0 3
75573: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
75574: LD_EXP 90
75578: PUSH
75579: LD_VAR 0 2
75583: ARRAY
75584: PUSH
75585: LD_INT 1
75587: ARRAY
75588: PPUSH
75589: LD_INT 112
75591: PPUSH
75592: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
75596: LD_ADDR_VAR 0 9
75600: PUSH
75601: LD_EXP 90
75605: PUSH
75606: LD_VAR 0 2
75610: ARRAY
75611: PPUSH
75612: LD_INT 1
75614: PPUSH
75615: CALL_OW 3
75619: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
75620: LD_ADDR_EXP 90
75624: PUSH
75625: LD_EXP 90
75629: PPUSH
75630: LD_VAR 0 2
75634: PPUSH
75635: LD_VAR 0 9
75639: PPUSH
75640: CALL_OW 1
75644: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
75645: LD_EXP 90
75649: PUSH
75650: LD_VAR 0 2
75654: ARRAY
75655: PUSH
75656: LD_EXP 91
75660: PUSH
75661: LD_VAR 0 2
75665: ARRAY
75666: AND
75667: PUSH
75668: LD_EXP 91
75672: PUSH
75673: LD_VAR 0 2
75677: ARRAY
75678: PUSH
75679: LD_INT 1
75681: ARRAY
75682: PPUSH
75683: CALL_OW 310
75687: NOT
75688: AND
75689: PUSH
75690: LD_VAR 0 3
75694: PPUSH
75695: CALL_OW 313
75699: PUSH
75700: LD_INT 6
75702: EQUAL
75703: AND
75704: IFFALSE 75760
// begin tmp2 := UnitsInside ( j ) ;
75706: LD_ADDR_VAR 0 9
75710: PUSH
75711: LD_VAR 0 3
75715: PPUSH
75716: CALL_OW 313
75720: ST_TO_ADDR
// if tmp2 = 6 then
75721: LD_VAR 0 9
75725: PUSH
75726: LD_INT 6
75728: EQUAL
75729: IFFALSE 75760
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
75731: LD_VAR 0 9
75735: PUSH
75736: LD_INT 1
75738: ARRAY
75739: PPUSH
75740: LD_INT 112
75742: PPUSH
75743: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
75747: LD_VAR 0 9
75751: PUSH
75752: LD_INT 1
75754: ARRAY
75755: PPUSH
75756: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
75760: LD_EXP 91
75764: PUSH
75765: LD_VAR 0 2
75769: ARRAY
75770: PUSH
75771: LD_EXP 91
75775: PUSH
75776: LD_VAR 0 2
75780: ARRAY
75781: PUSH
75782: LD_INT 1
75784: ARRAY
75785: PPUSH
75786: CALL_OW 314
75790: NOT
75791: AND
75792: PUSH
75793: LD_EXP 91
75797: PUSH
75798: LD_VAR 0 2
75802: ARRAY
75803: PUSH
75804: LD_INT 1
75806: ARRAY
75807: PPUSH
75808: CALL_OW 310
75812: NOT
75813: AND
75814: IFFALSE 75840
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
75816: LD_EXP 91
75820: PUSH
75821: LD_VAR 0 2
75825: ARRAY
75826: PUSH
75827: LD_INT 1
75829: ARRAY
75830: PPUSH
75831: LD_VAR 0 3
75835: PPUSH
75836: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
75840: LD_EXP 91
75844: PUSH
75845: LD_VAR 0 2
75849: ARRAY
75850: PUSH
75851: LD_INT 1
75853: ARRAY
75854: PPUSH
75855: CALL_OW 310
75859: PUSH
75860: LD_EXP 91
75864: PUSH
75865: LD_VAR 0 2
75869: ARRAY
75870: PUSH
75871: LD_INT 1
75873: ARRAY
75874: PPUSH
75875: CALL_OW 310
75879: PPUSH
75880: CALL_OW 461
75884: PUSH
75885: LD_INT 3
75887: NONEQUAL
75888: AND
75889: IFFALSE 75910
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
75891: LD_EXP 91
75895: PUSH
75896: LD_VAR 0 2
75900: ARRAY
75901: PUSH
75902: LD_INT 1
75904: ARRAY
75905: PPUSH
75906: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
75910: LD_VAR 0 3
75914: PPUSH
75915: CALL_OW 461
75919: PUSH
75920: LD_INT 6
75922: EQUAL
75923: PUSH
75924: LD_VAR 0 6
75928: PUSH
75929: LD_INT 1
75931: GREATER
75932: AND
75933: IFFALSE 76085
// begin sci := [ ] ;
75935: LD_ADDR_VAR 0 8
75939: PUSH
75940: EMPTY
75941: ST_TO_ADDR
// for x in ( tmp diff j ) do
75942: LD_ADDR_VAR 0 7
75946: PUSH
75947: LD_VAR 0 6
75951: PUSH
75952: LD_VAR 0 3
75956: DIFF
75957: PUSH
75958: FOR_IN
75959: IFFALSE 76011
// begin if sci = 6 then
75961: LD_VAR 0 8
75965: PUSH
75966: LD_INT 6
75968: EQUAL
75969: IFFALSE 75973
// break ;
75971: GO 76011
// if BuildingStatus ( x ) = bs_idle then
75973: LD_VAR 0 7
75977: PPUSH
75978: CALL_OW 461
75982: PUSH
75983: LD_INT 2
75985: EQUAL
75986: IFFALSE 76009
// sci := sci ^ UnitsInside ( x ) ;
75988: LD_ADDR_VAR 0 8
75992: PUSH
75993: LD_VAR 0 8
75997: PUSH
75998: LD_VAR 0 7
76002: PPUSH
76003: CALL_OW 313
76007: ADD
76008: ST_TO_ADDR
// end ;
76009: GO 75958
76011: POP
76012: POP
// if not sci then
76013: LD_VAR 0 8
76017: NOT
76018: IFFALSE 76022
// continue ;
76020: GO 75067
// for x in sci do
76022: LD_ADDR_VAR 0 7
76026: PUSH
76027: LD_VAR 0 8
76031: PUSH
76032: FOR_IN
76033: IFFALSE 76083
// if IsInUnit ( x ) and not HasTask ( x ) then
76035: LD_VAR 0 7
76039: PPUSH
76040: CALL_OW 310
76044: PUSH
76045: LD_VAR 0 7
76049: PPUSH
76050: CALL_OW 314
76054: NOT
76055: AND
76056: IFFALSE 76081
// begin ComExitBuilding ( x ) ;
76058: LD_VAR 0 7
76062: PPUSH
76063: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
76067: LD_VAR 0 7
76071: PPUSH
76072: LD_VAR 0 3
76076: PPUSH
76077: CALL_OW 180
// end ;
76081: GO 76032
76083: POP
76084: POP
// end ; end ;
76085: GO 75067
76087: POP
76088: POP
// end ;
76089: GO 75021
76091: POP
76092: POP
// end ;
76093: LD_VAR 0 1
76097: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
76098: LD_INT 0
76100: PPUSH
76101: PPUSH
// if not mc_bases then
76102: LD_EXP 61
76106: NOT
76107: IFFALSE 76111
// exit ;
76109: GO 76192
// for i = 1 to mc_bases do
76111: LD_ADDR_VAR 0 2
76115: PUSH
76116: DOUBLE
76117: LD_INT 1
76119: DEC
76120: ST_TO_ADDR
76121: LD_EXP 61
76125: PUSH
76126: FOR_TO
76127: IFFALSE 76190
// if mc_mines [ i ] and mc_miners [ i ] then
76129: LD_EXP 74
76133: PUSH
76134: LD_VAR 0 2
76138: ARRAY
76139: PUSH
76140: LD_EXP 75
76144: PUSH
76145: LD_VAR 0 2
76149: ARRAY
76150: AND
76151: IFFALSE 76188
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
76153: LD_EXP 75
76157: PUSH
76158: LD_VAR 0 2
76162: ARRAY
76163: PUSH
76164: LD_INT 1
76166: ARRAY
76167: PPUSH
76168: CALL_OW 255
76172: PPUSH
76173: LD_EXP 74
76177: PUSH
76178: LD_VAR 0 2
76182: ARRAY
76183: PPUSH
76184: CALL 17958 0 2
76188: GO 76126
76190: POP
76191: POP
// end ;
76192: LD_VAR 0 1
76196: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
76197: LD_INT 0
76199: PPUSH
76200: PPUSH
76201: PPUSH
76202: PPUSH
76203: PPUSH
76204: PPUSH
76205: PPUSH
76206: PPUSH
// if not mc_bases or not mc_parking then
76207: LD_EXP 61
76211: NOT
76212: PUSH
76213: LD_EXP 85
76217: NOT
76218: OR
76219: IFFALSE 76223
// exit ;
76221: GO 76961
// for i = 1 to mc_bases do
76223: LD_ADDR_VAR 0 2
76227: PUSH
76228: DOUBLE
76229: LD_INT 1
76231: DEC
76232: ST_TO_ADDR
76233: LD_EXP 61
76237: PUSH
76238: FOR_TO
76239: IFFALSE 76959
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
76241: LD_EXP 61
76245: PUSH
76246: LD_VAR 0 2
76250: ARRAY
76251: NOT
76252: PUSH
76253: LD_EXP 85
76257: PUSH
76258: LD_VAR 0 2
76262: ARRAY
76263: NOT
76264: OR
76265: IFFALSE 76269
// continue ;
76267: GO 76238
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
76269: LD_ADDR_VAR 0 5
76273: PUSH
76274: LD_EXP 61
76278: PUSH
76279: LD_VAR 0 2
76283: ARRAY
76284: PUSH
76285: LD_INT 1
76287: ARRAY
76288: PPUSH
76289: CALL_OW 255
76293: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76294: LD_ADDR_VAR 0 6
76298: PUSH
76299: LD_EXP 61
76303: PUSH
76304: LD_VAR 0 2
76308: ARRAY
76309: PPUSH
76310: LD_INT 30
76312: PUSH
76313: LD_INT 3
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PPUSH
76320: CALL_OW 72
76324: ST_TO_ADDR
// if not fac then
76325: LD_VAR 0 6
76329: NOT
76330: IFFALSE 76381
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76332: LD_ADDR_VAR 0 6
76336: PUSH
76337: LD_EXP 61
76341: PUSH
76342: LD_VAR 0 2
76346: ARRAY
76347: PPUSH
76348: LD_INT 2
76350: PUSH
76351: LD_INT 30
76353: PUSH
76354: LD_INT 0
76356: PUSH
76357: EMPTY
76358: LIST
76359: LIST
76360: PUSH
76361: LD_INT 30
76363: PUSH
76364: LD_INT 1
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: LIST
76375: PPUSH
76376: CALL_OW 72
76380: ST_TO_ADDR
// if not fac then
76381: LD_VAR 0 6
76385: NOT
76386: IFFALSE 76390
// continue ;
76388: GO 76238
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
76390: LD_ADDR_VAR 0 7
76394: PUSH
76395: LD_EXP 85
76399: PUSH
76400: LD_VAR 0 2
76404: ARRAY
76405: PPUSH
76406: LD_INT 22
76408: PUSH
76409: LD_VAR 0 5
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 21
76420: PUSH
76421: LD_INT 2
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 3
76430: PUSH
76431: LD_INT 60
76433: PUSH
76434: EMPTY
76435: LIST
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 3
76443: PUSH
76444: LD_INT 24
76446: PUSH
76447: LD_INT 1000
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: LIST
76462: LIST
76463: PPUSH
76464: CALL_OW 70
76468: ST_TO_ADDR
// for j in fac do
76469: LD_ADDR_VAR 0 3
76473: PUSH
76474: LD_VAR 0 6
76478: PUSH
76479: FOR_IN
76480: IFFALSE 76575
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
76482: LD_ADDR_VAR 0 7
76486: PUSH
76487: LD_VAR 0 7
76491: PUSH
76492: LD_INT 22
76494: PUSH
76495: LD_VAR 0 5
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 91
76506: PUSH
76507: LD_VAR 0 3
76511: PUSH
76512: LD_INT 15
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 21
76522: PUSH
76523: LD_INT 2
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 3
76532: PUSH
76533: LD_INT 60
76535: PUSH
76536: EMPTY
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 3
76545: PUSH
76546: LD_INT 24
76548: PUSH
76549: LD_INT 1000
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: PPUSH
76567: CALL_OW 69
76571: UNION
76572: ST_TO_ADDR
76573: GO 76479
76575: POP
76576: POP
// if not vehs then
76577: LD_VAR 0 7
76581: NOT
76582: IFFALSE 76608
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
76584: LD_ADDR_EXP 73
76588: PUSH
76589: LD_EXP 73
76593: PPUSH
76594: LD_VAR 0 2
76598: PPUSH
76599: EMPTY
76600: PPUSH
76601: CALL_OW 1
76605: ST_TO_ADDR
// continue ;
76606: GO 76238
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76608: LD_ADDR_VAR 0 8
76612: PUSH
76613: LD_EXP 61
76617: PUSH
76618: LD_VAR 0 2
76622: ARRAY
76623: PPUSH
76624: LD_INT 30
76626: PUSH
76627: LD_INT 3
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PPUSH
76634: CALL_OW 72
76638: ST_TO_ADDR
// if tmp then
76639: LD_VAR 0 8
76643: IFFALSE 76746
// begin for j in tmp do
76645: LD_ADDR_VAR 0 3
76649: PUSH
76650: LD_VAR 0 8
76654: PUSH
76655: FOR_IN
76656: IFFALSE 76744
// for k in UnitsInside ( j ) do
76658: LD_ADDR_VAR 0 4
76662: PUSH
76663: LD_VAR 0 3
76667: PPUSH
76668: CALL_OW 313
76672: PUSH
76673: FOR_IN
76674: IFFALSE 76740
// if k then
76676: LD_VAR 0 4
76680: IFFALSE 76738
// if not k in mc_repair_vehicle [ i ] then
76682: LD_VAR 0 4
76686: PUSH
76687: LD_EXP 73
76691: PUSH
76692: LD_VAR 0 2
76696: ARRAY
76697: IN
76698: NOT
76699: IFFALSE 76738
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
76701: LD_ADDR_EXP 73
76705: PUSH
76706: LD_EXP 73
76710: PPUSH
76711: LD_VAR 0 2
76715: PPUSH
76716: LD_EXP 73
76720: PUSH
76721: LD_VAR 0 2
76725: ARRAY
76726: PUSH
76727: LD_VAR 0 4
76731: UNION
76732: PPUSH
76733: CALL_OW 1
76737: ST_TO_ADDR
76738: GO 76673
76740: POP
76741: POP
76742: GO 76655
76744: POP
76745: POP
// end ; if not mc_repair_vehicle [ i ] then
76746: LD_EXP 73
76750: PUSH
76751: LD_VAR 0 2
76755: ARRAY
76756: NOT
76757: IFFALSE 76761
// continue ;
76759: GO 76238
// for j in mc_repair_vehicle [ i ] do
76761: LD_ADDR_VAR 0 3
76765: PUSH
76766: LD_EXP 73
76770: PUSH
76771: LD_VAR 0 2
76775: ARRAY
76776: PUSH
76777: FOR_IN
76778: IFFALSE 76955
// begin if GetClass ( j ) <> 3 then
76780: LD_VAR 0 3
76784: PPUSH
76785: CALL_OW 257
76789: PUSH
76790: LD_INT 3
76792: NONEQUAL
76793: IFFALSE 76834
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
76795: LD_ADDR_EXP 73
76799: PUSH
76800: LD_EXP 73
76804: PPUSH
76805: LD_VAR 0 2
76809: PPUSH
76810: LD_EXP 73
76814: PUSH
76815: LD_VAR 0 2
76819: ARRAY
76820: PUSH
76821: LD_VAR 0 3
76825: DIFF
76826: PPUSH
76827: CALL_OW 1
76831: ST_TO_ADDR
// continue ;
76832: GO 76777
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76834: LD_VAR 0 3
76838: PPUSH
76839: CALL_OW 311
76843: NOT
76844: PUSH
76845: LD_VAR 0 3
76849: PUSH
76850: LD_EXP 64
76854: PUSH
76855: LD_VAR 0 2
76859: ARRAY
76860: PUSH
76861: LD_INT 1
76863: ARRAY
76864: IN
76865: NOT
76866: AND
76867: PUSH
76868: LD_VAR 0 3
76872: PUSH
76873: LD_EXP 64
76877: PUSH
76878: LD_VAR 0 2
76882: ARRAY
76883: PUSH
76884: LD_INT 2
76886: ARRAY
76887: IN
76888: NOT
76889: AND
76890: IFFALSE 76953
// begin if IsInUnit ( j ) then
76892: LD_VAR 0 3
76896: PPUSH
76897: CALL_OW 310
76901: IFFALSE 76914
// ComExitBuilding ( j ) else
76903: LD_VAR 0 3
76907: PPUSH
76908: CALL_OW 122
76912: GO 76953
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
76914: LD_VAR 0 3
76918: PPUSH
76919: LD_VAR 0 7
76923: PUSH
76924: LD_INT 1
76926: ARRAY
76927: PPUSH
76928: CALL 55786 0 2
76932: NOT
76933: IFFALSE 76953
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
76935: LD_VAR 0 3
76939: PPUSH
76940: LD_VAR 0 7
76944: PUSH
76945: LD_INT 1
76947: ARRAY
76948: PPUSH
76949: CALL_OW 129
// end ; end ;
76953: GO 76777
76955: POP
76956: POP
// end ;
76957: GO 76238
76959: POP
76960: POP
// end ;
76961: LD_VAR 0 1
76965: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
76966: LD_INT 0
76968: PPUSH
76969: PPUSH
76970: PPUSH
76971: PPUSH
76972: PPUSH
76973: PPUSH
76974: PPUSH
76975: PPUSH
76976: PPUSH
76977: PPUSH
76978: PPUSH
// if not mc_bases then
76979: LD_EXP 61
76983: NOT
76984: IFFALSE 76988
// exit ;
76986: GO 77790
// for i = 1 to mc_bases do
76988: LD_ADDR_VAR 0 2
76992: PUSH
76993: DOUBLE
76994: LD_INT 1
76996: DEC
76997: ST_TO_ADDR
76998: LD_EXP 61
77002: PUSH
77003: FOR_TO
77004: IFFALSE 77788
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
77006: LD_EXP 89
77010: PUSH
77011: LD_VAR 0 2
77015: ARRAY
77016: NOT
77017: PUSH
77018: LD_EXP 64
77022: PUSH
77023: LD_VAR 0 2
77027: ARRAY
77028: PUSH
77029: LD_INT 1
77031: ARRAY
77032: OR
77033: PUSH
77034: LD_EXP 64
77038: PUSH
77039: LD_VAR 0 2
77043: ARRAY
77044: PUSH
77045: LD_INT 2
77047: ARRAY
77048: OR
77049: PUSH
77050: LD_EXP 87
77054: PUSH
77055: LD_VAR 0 2
77059: ARRAY
77060: PPUSH
77061: LD_INT 1
77063: PPUSH
77064: CALL_OW 325
77068: NOT
77069: OR
77070: PUSH
77071: LD_EXP 84
77075: PUSH
77076: LD_VAR 0 2
77080: ARRAY
77081: OR
77082: IFFALSE 77086
// continue ;
77084: GO 77003
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
77086: LD_ADDR_VAR 0 8
77090: PUSH
77091: LD_EXP 61
77095: PUSH
77096: LD_VAR 0 2
77100: ARRAY
77101: PPUSH
77102: LD_INT 25
77104: PUSH
77105: LD_INT 4
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: LD_INT 50
77114: PUSH
77115: EMPTY
77116: LIST
77117: PUSH
77118: LD_INT 3
77120: PUSH
77121: LD_INT 60
77123: PUSH
77124: EMPTY
77125: LIST
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: LIST
77135: PPUSH
77136: CALL_OW 72
77140: PUSH
77141: LD_EXP 65
77145: PUSH
77146: LD_VAR 0 2
77150: ARRAY
77151: DIFF
77152: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77153: LD_ADDR_VAR 0 9
77157: PUSH
77158: LD_EXP 61
77162: PUSH
77163: LD_VAR 0 2
77167: ARRAY
77168: PPUSH
77169: LD_INT 2
77171: PUSH
77172: LD_INT 30
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 30
77184: PUSH
77185: LD_INT 1
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: EMPTY
77193: LIST
77194: LIST
77195: LIST
77196: PPUSH
77197: CALL_OW 72
77201: ST_TO_ADDR
// if not tmp or not dep then
77202: LD_VAR 0 8
77206: NOT
77207: PUSH
77208: LD_VAR 0 9
77212: NOT
77213: OR
77214: IFFALSE 77218
// continue ;
77216: GO 77003
// side := GetSide ( tmp [ 1 ] ) ;
77218: LD_ADDR_VAR 0 11
77222: PUSH
77223: LD_VAR 0 8
77227: PUSH
77228: LD_INT 1
77230: ARRAY
77231: PPUSH
77232: CALL_OW 255
77236: ST_TO_ADDR
// dep := dep [ 1 ] ;
77237: LD_ADDR_VAR 0 9
77241: PUSH
77242: LD_VAR 0 9
77246: PUSH
77247: LD_INT 1
77249: ARRAY
77250: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
77251: LD_ADDR_VAR 0 7
77255: PUSH
77256: LD_EXP 89
77260: PUSH
77261: LD_VAR 0 2
77265: ARRAY
77266: PPUSH
77267: LD_INT 22
77269: PUSH
77270: LD_INT 0
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: PUSH
77277: LD_INT 25
77279: PUSH
77280: LD_INT 12
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PPUSH
77291: CALL_OW 70
77295: PUSH
77296: LD_INT 22
77298: PUSH
77299: LD_INT 0
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 25
77308: PUSH
77309: LD_INT 12
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 91
77318: PUSH
77319: LD_VAR 0 9
77323: PUSH
77324: LD_INT 20
77326: PUSH
77327: EMPTY
77328: LIST
77329: LIST
77330: LIST
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: LIST
77336: PPUSH
77337: CALL_OW 69
77341: UNION
77342: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
77343: LD_ADDR_VAR 0 10
77347: PUSH
77348: LD_EXP 89
77352: PUSH
77353: LD_VAR 0 2
77357: ARRAY
77358: PPUSH
77359: LD_INT 81
77361: PUSH
77362: LD_VAR 0 11
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PPUSH
77371: CALL_OW 70
77375: ST_TO_ADDR
// if not apes or danger_at_area then
77376: LD_VAR 0 7
77380: NOT
77381: PUSH
77382: LD_VAR 0 10
77386: OR
77387: IFFALSE 77437
// begin if mc_taming [ i ] then
77389: LD_EXP 92
77393: PUSH
77394: LD_VAR 0 2
77398: ARRAY
77399: IFFALSE 77435
// begin MC_Reset ( i , 121 ) ;
77401: LD_VAR 0 2
77405: PPUSH
77406: LD_INT 121
77408: PPUSH
77409: CALL 62353 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
77413: LD_ADDR_EXP 92
77417: PUSH
77418: LD_EXP 92
77422: PPUSH
77423: LD_VAR 0 2
77427: PPUSH
77428: EMPTY
77429: PPUSH
77430: CALL_OW 1
77434: ST_TO_ADDR
// end ; continue ;
77435: GO 77003
// end ; for j in tmp do
77437: LD_ADDR_VAR 0 3
77441: PUSH
77442: LD_VAR 0 8
77446: PUSH
77447: FOR_IN
77448: IFFALSE 77784
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
77450: LD_VAR 0 3
77454: PUSH
77455: LD_EXP 92
77459: PUSH
77460: LD_VAR 0 2
77464: ARRAY
77465: IN
77466: NOT
77467: PUSH
77468: LD_EXP 92
77472: PUSH
77473: LD_VAR 0 2
77477: ARRAY
77478: PUSH
77479: LD_INT 3
77481: LESS
77482: AND
77483: IFFALSE 77541
// begin SetTag ( j , 121 ) ;
77485: LD_VAR 0 3
77489: PPUSH
77490: LD_INT 121
77492: PPUSH
77493: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
77497: LD_ADDR_EXP 92
77501: PUSH
77502: LD_EXP 92
77506: PPUSH
77507: LD_VAR 0 2
77511: PUSH
77512: LD_EXP 92
77516: PUSH
77517: LD_VAR 0 2
77521: ARRAY
77522: PUSH
77523: LD_INT 1
77525: PLUS
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PPUSH
77531: LD_VAR 0 3
77535: PPUSH
77536: CALL 20981 0 3
77540: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
77541: LD_VAR 0 3
77545: PUSH
77546: LD_EXP 92
77550: PUSH
77551: LD_VAR 0 2
77555: ARRAY
77556: IN
77557: IFFALSE 77782
// begin if GetClass ( j ) <> 4 then
77559: LD_VAR 0 3
77563: PPUSH
77564: CALL_OW 257
77568: PUSH
77569: LD_INT 4
77571: NONEQUAL
77572: IFFALSE 77625
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
77574: LD_ADDR_EXP 92
77578: PUSH
77579: LD_EXP 92
77583: PPUSH
77584: LD_VAR 0 2
77588: PPUSH
77589: LD_EXP 92
77593: PUSH
77594: LD_VAR 0 2
77598: ARRAY
77599: PUSH
77600: LD_VAR 0 3
77604: DIFF
77605: PPUSH
77606: CALL_OW 1
77610: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77611: LD_VAR 0 3
77615: PPUSH
77616: LD_INT 0
77618: PPUSH
77619: CALL_OW 109
// continue ;
77623: GO 77447
// end ; if IsInUnit ( j ) then
77625: LD_VAR 0 3
77629: PPUSH
77630: CALL_OW 310
77634: IFFALSE 77645
// ComExitBuilding ( j ) ;
77636: LD_VAR 0 3
77640: PPUSH
77641: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
77645: LD_ADDR_VAR 0 6
77649: PUSH
77650: LD_VAR 0 7
77654: PPUSH
77655: LD_VAR 0 3
77659: PPUSH
77660: CALL_OW 74
77664: ST_TO_ADDR
// if not ape then
77665: LD_VAR 0 6
77669: NOT
77670: IFFALSE 77674
// break ;
77672: GO 77784
// x := GetX ( ape ) ;
77674: LD_ADDR_VAR 0 4
77678: PUSH
77679: LD_VAR 0 6
77683: PPUSH
77684: CALL_OW 250
77688: ST_TO_ADDR
// y := GetY ( ape ) ;
77689: LD_ADDR_VAR 0 5
77693: PUSH
77694: LD_VAR 0 6
77698: PPUSH
77699: CALL_OW 251
77703: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77704: LD_VAR 0 4
77708: PPUSH
77709: LD_VAR 0 5
77713: PPUSH
77714: CALL_OW 488
77718: NOT
77719: PUSH
77720: LD_VAR 0 11
77724: PPUSH
77725: LD_VAR 0 4
77729: PPUSH
77730: LD_VAR 0 5
77734: PPUSH
77735: LD_INT 20
77737: PPUSH
77738: CALL 22245 0 4
77742: PUSH
77743: LD_INT 4
77745: ARRAY
77746: OR
77747: IFFALSE 77751
// break ;
77749: GO 77784
// if not HasTask ( j ) then
77751: LD_VAR 0 3
77755: PPUSH
77756: CALL_OW 314
77760: NOT
77761: IFFALSE 77782
// ComTameXY ( j , x , y ) ;
77763: LD_VAR 0 3
77767: PPUSH
77768: LD_VAR 0 4
77772: PPUSH
77773: LD_VAR 0 5
77777: PPUSH
77778: CALL_OW 131
// end ; end ;
77782: GO 77447
77784: POP
77785: POP
// end ;
77786: GO 77003
77788: POP
77789: POP
// end ;
77790: LD_VAR 0 1
77794: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
77795: LD_INT 0
77797: PPUSH
77798: PPUSH
77799: PPUSH
77800: PPUSH
77801: PPUSH
77802: PPUSH
77803: PPUSH
77804: PPUSH
// if not mc_bases then
77805: LD_EXP 61
77809: NOT
77810: IFFALSE 77814
// exit ;
77812: GO 78440
// for i = 1 to mc_bases do
77814: LD_ADDR_VAR 0 2
77818: PUSH
77819: DOUBLE
77820: LD_INT 1
77822: DEC
77823: ST_TO_ADDR
77824: LD_EXP 61
77828: PUSH
77829: FOR_TO
77830: IFFALSE 78438
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
77832: LD_EXP 90
77836: PUSH
77837: LD_VAR 0 2
77841: ARRAY
77842: NOT
77843: PUSH
77844: LD_EXP 90
77848: PUSH
77849: LD_VAR 0 2
77853: ARRAY
77854: PPUSH
77855: LD_INT 25
77857: PUSH
77858: LD_INT 12
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PPUSH
77865: CALL_OW 72
77869: NOT
77870: OR
77871: IFFALSE 77875
// continue ;
77873: GO 77829
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
77875: LD_ADDR_VAR 0 5
77879: PUSH
77880: LD_EXP 90
77884: PUSH
77885: LD_VAR 0 2
77889: ARRAY
77890: PUSH
77891: LD_INT 1
77893: ARRAY
77894: PPUSH
77895: CALL_OW 255
77899: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
77900: LD_VAR 0 5
77904: PPUSH
77905: LD_INT 2
77907: PPUSH
77908: CALL_OW 325
77912: IFFALSE 78165
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
77914: LD_ADDR_VAR 0 4
77918: PUSH
77919: LD_EXP 90
77923: PUSH
77924: LD_VAR 0 2
77928: ARRAY
77929: PPUSH
77930: LD_INT 25
77932: PUSH
77933: LD_INT 16
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PPUSH
77940: CALL_OW 72
77944: ST_TO_ADDR
// if tmp < 6 then
77945: LD_VAR 0 4
77949: PUSH
77950: LD_INT 6
77952: LESS
77953: IFFALSE 78165
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77955: LD_ADDR_VAR 0 6
77959: PUSH
77960: LD_EXP 61
77964: PUSH
77965: LD_VAR 0 2
77969: ARRAY
77970: PPUSH
77971: LD_INT 2
77973: PUSH
77974: LD_INT 30
77976: PUSH
77977: LD_INT 0
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 30
77986: PUSH
77987: LD_INT 1
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: LIST
77998: PPUSH
77999: CALL_OW 72
78003: ST_TO_ADDR
// if depot then
78004: LD_VAR 0 6
78008: IFFALSE 78165
// begin selected := 0 ;
78010: LD_ADDR_VAR 0 7
78014: PUSH
78015: LD_INT 0
78017: ST_TO_ADDR
// for j in depot do
78018: LD_ADDR_VAR 0 3
78022: PUSH
78023: LD_VAR 0 6
78027: PUSH
78028: FOR_IN
78029: IFFALSE 78060
// begin if UnitsInside ( j ) < 6 then
78031: LD_VAR 0 3
78035: PPUSH
78036: CALL_OW 313
78040: PUSH
78041: LD_INT 6
78043: LESS
78044: IFFALSE 78058
// begin selected := j ;
78046: LD_ADDR_VAR 0 7
78050: PUSH
78051: LD_VAR 0 3
78055: ST_TO_ADDR
// break ;
78056: GO 78060
// end ; end ;
78058: GO 78028
78060: POP
78061: POP
// if selected then
78062: LD_VAR 0 7
78066: IFFALSE 78165
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
78068: LD_ADDR_VAR 0 3
78072: PUSH
78073: LD_EXP 90
78077: PUSH
78078: LD_VAR 0 2
78082: ARRAY
78083: PPUSH
78084: LD_INT 25
78086: PUSH
78087: LD_INT 12
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PPUSH
78094: CALL_OW 72
78098: PUSH
78099: FOR_IN
78100: IFFALSE 78163
// if not HasTask ( j ) then
78102: LD_VAR 0 3
78106: PPUSH
78107: CALL_OW 314
78111: NOT
78112: IFFALSE 78161
// begin if not IsInUnit ( j ) then
78114: LD_VAR 0 3
78118: PPUSH
78119: CALL_OW 310
78123: NOT
78124: IFFALSE 78140
// ComEnterUnit ( j , selected ) ;
78126: LD_VAR 0 3
78130: PPUSH
78131: LD_VAR 0 7
78135: PPUSH
78136: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
78140: LD_VAR 0 3
78144: PPUSH
78145: LD_INT 16
78147: PPUSH
78148: CALL_OW 183
// AddComExitBuilding ( j ) ;
78152: LD_VAR 0 3
78156: PPUSH
78157: CALL_OW 182
// end ;
78161: GO 78099
78163: POP
78164: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
78165: LD_VAR 0 5
78169: PPUSH
78170: LD_INT 11
78172: PPUSH
78173: CALL_OW 325
78177: IFFALSE 78436
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
78179: LD_ADDR_VAR 0 4
78183: PUSH
78184: LD_EXP 90
78188: PUSH
78189: LD_VAR 0 2
78193: ARRAY
78194: PPUSH
78195: LD_INT 25
78197: PUSH
78198: LD_INT 16
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PPUSH
78205: CALL_OW 72
78209: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
78210: LD_VAR 0 4
78214: PUSH
78215: LD_INT 6
78217: GREATEREQUAL
78218: PUSH
78219: LD_VAR 0 5
78223: PPUSH
78224: LD_INT 2
78226: PPUSH
78227: CALL_OW 325
78231: NOT
78232: OR
78233: IFFALSE 78436
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
78235: LD_ADDR_VAR 0 8
78239: PUSH
78240: LD_EXP 61
78244: PUSH
78245: LD_VAR 0 2
78249: ARRAY
78250: PPUSH
78251: LD_INT 2
78253: PUSH
78254: LD_INT 30
78256: PUSH
78257: LD_INT 4
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 30
78266: PUSH
78267: LD_INT 5
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: LIST
78278: PPUSH
78279: CALL_OW 72
78283: ST_TO_ADDR
// if barracks then
78284: LD_VAR 0 8
78288: IFFALSE 78436
// begin selected := 0 ;
78290: LD_ADDR_VAR 0 7
78294: PUSH
78295: LD_INT 0
78297: ST_TO_ADDR
// for j in barracks do
78298: LD_ADDR_VAR 0 3
78302: PUSH
78303: LD_VAR 0 8
78307: PUSH
78308: FOR_IN
78309: IFFALSE 78340
// begin if UnitsInside ( j ) < 6 then
78311: LD_VAR 0 3
78315: PPUSH
78316: CALL_OW 313
78320: PUSH
78321: LD_INT 6
78323: LESS
78324: IFFALSE 78338
// begin selected := j ;
78326: LD_ADDR_VAR 0 7
78330: PUSH
78331: LD_VAR 0 3
78335: ST_TO_ADDR
// break ;
78336: GO 78340
// end ; end ;
78338: GO 78308
78340: POP
78341: POP
// if selected then
78342: LD_VAR 0 7
78346: IFFALSE 78436
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
78348: LD_ADDR_VAR 0 3
78352: PUSH
78353: LD_EXP 90
78357: PUSH
78358: LD_VAR 0 2
78362: ARRAY
78363: PPUSH
78364: LD_INT 25
78366: PUSH
78367: LD_INT 12
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PPUSH
78374: CALL_OW 72
78378: PUSH
78379: FOR_IN
78380: IFFALSE 78434
// if not IsInUnit ( j ) and not HasTask ( j ) then
78382: LD_VAR 0 3
78386: PPUSH
78387: CALL_OW 310
78391: NOT
78392: PUSH
78393: LD_VAR 0 3
78397: PPUSH
78398: CALL_OW 314
78402: NOT
78403: AND
78404: IFFALSE 78432
// begin ComEnterUnit ( j , selected ) ;
78406: LD_VAR 0 3
78410: PPUSH
78411: LD_VAR 0 7
78415: PPUSH
78416: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
78420: LD_VAR 0 3
78424: PPUSH
78425: LD_INT 15
78427: PPUSH
78428: CALL_OW 183
// end ;
78432: GO 78379
78434: POP
78435: POP
// end ; end ; end ; end ; end ;
78436: GO 77829
78438: POP
78439: POP
// end ;
78440: LD_VAR 0 1
78444: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
78445: LD_INT 0
78447: PPUSH
78448: PPUSH
78449: PPUSH
78450: PPUSH
// if not mc_bases then
78451: LD_EXP 61
78455: NOT
78456: IFFALSE 78460
// exit ;
78458: GO 78638
// for i = 1 to mc_bases do
78460: LD_ADDR_VAR 0 2
78464: PUSH
78465: DOUBLE
78466: LD_INT 1
78468: DEC
78469: ST_TO_ADDR
78470: LD_EXP 61
78474: PUSH
78475: FOR_TO
78476: IFFALSE 78636
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
78478: LD_ADDR_VAR 0 4
78482: PUSH
78483: LD_EXP 61
78487: PUSH
78488: LD_VAR 0 2
78492: ARRAY
78493: PPUSH
78494: LD_INT 25
78496: PUSH
78497: LD_INT 9
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PPUSH
78504: CALL_OW 72
78508: ST_TO_ADDR
// if not tmp then
78509: LD_VAR 0 4
78513: NOT
78514: IFFALSE 78518
// continue ;
78516: GO 78475
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
78518: LD_EXP 87
78522: PUSH
78523: LD_VAR 0 2
78527: ARRAY
78528: PPUSH
78529: LD_INT 29
78531: PPUSH
78532: CALL_OW 325
78536: NOT
78537: PUSH
78538: LD_EXP 87
78542: PUSH
78543: LD_VAR 0 2
78547: ARRAY
78548: PPUSH
78549: LD_INT 28
78551: PPUSH
78552: CALL_OW 325
78556: NOT
78557: AND
78558: IFFALSE 78562
// continue ;
78560: GO 78475
// for j in tmp do
78562: LD_ADDR_VAR 0 3
78566: PUSH
78567: LD_VAR 0 4
78571: PUSH
78572: FOR_IN
78573: IFFALSE 78632
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
78575: LD_VAR 0 3
78579: PUSH
78580: LD_EXP 64
78584: PUSH
78585: LD_VAR 0 2
78589: ARRAY
78590: PUSH
78591: LD_INT 1
78593: ARRAY
78594: IN
78595: NOT
78596: PUSH
78597: LD_VAR 0 3
78601: PUSH
78602: LD_EXP 64
78606: PUSH
78607: LD_VAR 0 2
78611: ARRAY
78612: PUSH
78613: LD_INT 2
78615: ARRAY
78616: IN
78617: NOT
78618: AND
78619: IFFALSE 78630
// ComSpaceTimeShoot ( j ) ;
78621: LD_VAR 0 3
78625: PPUSH
78626: CALL 16966 0 1
78630: GO 78572
78632: POP
78633: POP
// end ;
78634: GO 78475
78636: POP
78637: POP
// end ;
78638: LD_VAR 0 1
78642: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
78643: LD_INT 0
78645: PPUSH
78646: PPUSH
78647: PPUSH
78648: PPUSH
78649: PPUSH
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
// if not mc_bases then
78654: LD_EXP 61
78658: NOT
78659: IFFALSE 78663
// exit ;
78661: GO 79285
// for i = 1 to mc_bases do
78663: LD_ADDR_VAR 0 2
78667: PUSH
78668: DOUBLE
78669: LD_INT 1
78671: DEC
78672: ST_TO_ADDR
78673: LD_EXP 61
78677: PUSH
78678: FOR_TO
78679: IFFALSE 79283
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
78681: LD_EXP 96
78685: PUSH
78686: LD_VAR 0 2
78690: ARRAY
78691: NOT
78692: PUSH
78693: LD_INT 38
78695: PPUSH
78696: LD_EXP 87
78700: PUSH
78701: LD_VAR 0 2
78705: ARRAY
78706: PPUSH
78707: CALL_OW 321
78711: PUSH
78712: LD_INT 2
78714: NONEQUAL
78715: OR
78716: IFFALSE 78720
// continue ;
78718: GO 78678
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
78720: LD_ADDR_VAR 0 8
78724: PUSH
78725: LD_EXP 61
78729: PUSH
78730: LD_VAR 0 2
78734: ARRAY
78735: PPUSH
78736: LD_INT 30
78738: PUSH
78739: LD_INT 34
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PPUSH
78746: CALL_OW 72
78750: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
78751: LD_ADDR_VAR 0 9
78755: PUSH
78756: LD_EXP 61
78760: PUSH
78761: LD_VAR 0 2
78765: ARRAY
78766: PPUSH
78767: LD_INT 25
78769: PUSH
78770: LD_INT 4
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PPUSH
78777: CALL_OW 72
78781: PPUSH
78782: LD_INT 0
78784: PPUSH
78785: CALL 51290 0 2
78789: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
78790: LD_VAR 0 9
78794: NOT
78795: PUSH
78796: LD_VAR 0 8
78800: NOT
78801: OR
78802: PUSH
78803: LD_EXP 61
78807: PUSH
78808: LD_VAR 0 2
78812: ARRAY
78813: PPUSH
78814: LD_INT 124
78816: PPUSH
78817: CALL 51290 0 2
78821: OR
78822: IFFALSE 78826
// continue ;
78824: GO 78678
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
78826: LD_EXP 97
78830: PUSH
78831: LD_VAR 0 2
78835: ARRAY
78836: PUSH
78837: LD_EXP 96
78841: PUSH
78842: LD_VAR 0 2
78846: ARRAY
78847: LESS
78848: PUSH
78849: LD_EXP 97
78853: PUSH
78854: LD_VAR 0 2
78858: ARRAY
78859: PUSH
78860: LD_VAR 0 8
78864: LESS
78865: AND
78866: IFFALSE 79281
// begin tmp := sci [ 1 ] ;
78868: LD_ADDR_VAR 0 7
78872: PUSH
78873: LD_VAR 0 9
78877: PUSH
78878: LD_INT 1
78880: ARRAY
78881: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
78882: LD_VAR 0 7
78886: PPUSH
78887: LD_INT 124
78889: PPUSH
78890: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
78894: LD_ADDR_VAR 0 3
78898: PUSH
78899: DOUBLE
78900: LD_EXP 96
78904: PUSH
78905: LD_VAR 0 2
78909: ARRAY
78910: INC
78911: ST_TO_ADDR
78912: LD_EXP 96
78916: PUSH
78917: LD_VAR 0 2
78921: ARRAY
78922: PUSH
78923: FOR_DOWNTO
78924: IFFALSE 79267
// begin if IsInUnit ( tmp ) then
78926: LD_VAR 0 7
78930: PPUSH
78931: CALL_OW 310
78935: IFFALSE 78946
// ComExitBuilding ( tmp ) ;
78937: LD_VAR 0 7
78941: PPUSH
78942: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
78946: LD_INT 35
78948: PPUSH
78949: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
78953: LD_VAR 0 7
78957: PPUSH
78958: CALL_OW 310
78962: NOT
78963: PUSH
78964: LD_VAR 0 7
78968: PPUSH
78969: CALL_OW 314
78973: NOT
78974: AND
78975: IFFALSE 78946
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
78977: LD_ADDR_VAR 0 6
78981: PUSH
78982: LD_VAR 0 7
78986: PPUSH
78987: CALL_OW 250
78991: PUSH
78992: LD_VAR 0 7
78996: PPUSH
78997: CALL_OW 251
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
79006: LD_INT 35
79008: PPUSH
79009: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
79013: LD_ADDR_VAR 0 4
79017: PUSH
79018: LD_EXP 96
79022: PUSH
79023: LD_VAR 0 2
79027: ARRAY
79028: PUSH
79029: LD_VAR 0 3
79033: ARRAY
79034: PUSH
79035: LD_INT 1
79037: ARRAY
79038: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
79039: LD_ADDR_VAR 0 5
79043: PUSH
79044: LD_EXP 96
79048: PUSH
79049: LD_VAR 0 2
79053: ARRAY
79054: PUSH
79055: LD_VAR 0 3
79059: ARRAY
79060: PUSH
79061: LD_INT 2
79063: ARRAY
79064: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
79065: LD_VAR 0 7
79069: PPUSH
79070: LD_INT 10
79072: PPUSH
79073: CALL 23946 0 2
79077: PUSH
79078: LD_INT 4
79080: ARRAY
79081: IFFALSE 79119
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
79083: LD_VAR 0 7
79087: PPUSH
79088: LD_VAR 0 6
79092: PUSH
79093: LD_INT 1
79095: ARRAY
79096: PPUSH
79097: LD_VAR 0 6
79101: PUSH
79102: LD_INT 2
79104: ARRAY
79105: PPUSH
79106: CALL_OW 111
// wait ( 0 0$10 ) ;
79110: LD_INT 350
79112: PPUSH
79113: CALL_OW 67
// end else
79117: GO 79145
// begin ComMoveXY ( tmp , x , y ) ;
79119: LD_VAR 0 7
79123: PPUSH
79124: LD_VAR 0 4
79128: PPUSH
79129: LD_VAR 0 5
79133: PPUSH
79134: CALL_OW 111
// wait ( 0 0$3 ) ;
79138: LD_INT 105
79140: PPUSH
79141: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
79145: LD_VAR 0 7
79149: PPUSH
79150: LD_VAR 0 4
79154: PPUSH
79155: LD_VAR 0 5
79159: PPUSH
79160: CALL_OW 307
79164: IFFALSE 79006
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
79166: LD_VAR 0 7
79170: PPUSH
79171: LD_VAR 0 4
79175: PPUSH
79176: LD_VAR 0 5
79180: PPUSH
79181: LD_VAR 0 8
79185: PUSH
79186: LD_VAR 0 3
79190: ARRAY
79191: PPUSH
79192: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
79196: LD_INT 35
79198: PPUSH
79199: CALL_OW 67
// until not HasTask ( tmp ) ;
79203: LD_VAR 0 7
79207: PPUSH
79208: CALL_OW 314
79212: NOT
79213: IFFALSE 79196
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
79215: LD_ADDR_EXP 97
79219: PUSH
79220: LD_EXP 97
79224: PPUSH
79225: LD_VAR 0 2
79229: PUSH
79230: LD_EXP 97
79234: PUSH
79235: LD_VAR 0 2
79239: ARRAY
79240: PUSH
79241: LD_INT 1
79243: PLUS
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PPUSH
79249: LD_VAR 0 8
79253: PUSH
79254: LD_VAR 0 3
79258: ARRAY
79259: PPUSH
79260: CALL 20981 0 3
79264: ST_TO_ADDR
// end ;
79265: GO 78923
79267: POP
79268: POP
// MC_Reset ( i , 124 ) ;
79269: LD_VAR 0 2
79273: PPUSH
79274: LD_INT 124
79276: PPUSH
79277: CALL 62353 0 2
// end ; end ;
79281: GO 78678
79283: POP
79284: POP
// end ;
79285: LD_VAR 0 1
79289: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
79290: LD_INT 0
79292: PPUSH
79293: PPUSH
79294: PPUSH
// if not mc_bases then
79295: LD_EXP 61
79299: NOT
79300: IFFALSE 79304
// exit ;
79302: GO 79910
// for i = 1 to mc_bases do
79304: LD_ADDR_VAR 0 2
79308: PUSH
79309: DOUBLE
79310: LD_INT 1
79312: DEC
79313: ST_TO_ADDR
79314: LD_EXP 61
79318: PUSH
79319: FOR_TO
79320: IFFALSE 79908
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
79322: LD_ADDR_VAR 0 3
79326: PUSH
79327: LD_EXP 61
79331: PUSH
79332: LD_VAR 0 2
79336: ARRAY
79337: PPUSH
79338: LD_INT 25
79340: PUSH
79341: LD_INT 4
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PPUSH
79348: CALL_OW 72
79352: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79353: LD_VAR 0 3
79357: NOT
79358: PUSH
79359: LD_EXP 98
79363: PUSH
79364: LD_VAR 0 2
79368: ARRAY
79369: NOT
79370: OR
79371: PUSH
79372: LD_EXP 61
79376: PUSH
79377: LD_VAR 0 2
79381: ARRAY
79382: PPUSH
79383: LD_INT 2
79385: PUSH
79386: LD_INT 30
79388: PUSH
79389: LD_INT 0
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 30
79398: PUSH
79399: LD_INT 1
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: LIST
79410: PPUSH
79411: CALL_OW 72
79415: NOT
79416: OR
79417: IFFALSE 79467
// begin if mc_deposits_finder [ i ] then
79419: LD_EXP 99
79423: PUSH
79424: LD_VAR 0 2
79428: ARRAY
79429: IFFALSE 79465
// begin MC_Reset ( i , 125 ) ;
79431: LD_VAR 0 2
79435: PPUSH
79436: LD_INT 125
79438: PPUSH
79439: CALL 62353 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
79443: LD_ADDR_EXP 99
79447: PUSH
79448: LD_EXP 99
79452: PPUSH
79453: LD_VAR 0 2
79457: PPUSH
79458: EMPTY
79459: PPUSH
79460: CALL_OW 1
79464: ST_TO_ADDR
// end ; continue ;
79465: GO 79319
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
79467: LD_EXP 98
79471: PUSH
79472: LD_VAR 0 2
79476: ARRAY
79477: PUSH
79478: LD_INT 1
79480: ARRAY
79481: PUSH
79482: LD_INT 3
79484: ARRAY
79485: PUSH
79486: LD_INT 1
79488: EQUAL
79489: PUSH
79490: LD_INT 20
79492: PPUSH
79493: LD_EXP 87
79497: PUSH
79498: LD_VAR 0 2
79502: ARRAY
79503: PPUSH
79504: CALL_OW 321
79508: PUSH
79509: LD_INT 2
79511: NONEQUAL
79512: AND
79513: IFFALSE 79563
// begin if mc_deposits_finder [ i ] then
79515: LD_EXP 99
79519: PUSH
79520: LD_VAR 0 2
79524: ARRAY
79525: IFFALSE 79561
// begin MC_Reset ( i , 125 ) ;
79527: LD_VAR 0 2
79531: PPUSH
79532: LD_INT 125
79534: PPUSH
79535: CALL 62353 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
79539: LD_ADDR_EXP 99
79543: PUSH
79544: LD_EXP 99
79548: PPUSH
79549: LD_VAR 0 2
79553: PPUSH
79554: EMPTY
79555: PPUSH
79556: CALL_OW 1
79560: ST_TO_ADDR
// end ; continue ;
79561: GO 79319
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
79563: LD_EXP 98
79567: PUSH
79568: LD_VAR 0 2
79572: ARRAY
79573: PUSH
79574: LD_INT 1
79576: ARRAY
79577: PUSH
79578: LD_INT 1
79580: ARRAY
79581: PPUSH
79582: LD_EXP 98
79586: PUSH
79587: LD_VAR 0 2
79591: ARRAY
79592: PUSH
79593: LD_INT 1
79595: ARRAY
79596: PUSH
79597: LD_INT 2
79599: ARRAY
79600: PPUSH
79601: LD_EXP 87
79605: PUSH
79606: LD_VAR 0 2
79610: ARRAY
79611: PPUSH
79612: CALL_OW 440
79616: IFFALSE 79659
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
79618: LD_ADDR_EXP 98
79622: PUSH
79623: LD_EXP 98
79627: PPUSH
79628: LD_VAR 0 2
79632: PPUSH
79633: LD_EXP 98
79637: PUSH
79638: LD_VAR 0 2
79642: ARRAY
79643: PPUSH
79644: LD_INT 1
79646: PPUSH
79647: CALL_OW 3
79651: PPUSH
79652: CALL_OW 1
79656: ST_TO_ADDR
79657: GO 79906
// begin if not mc_deposits_finder [ i ] then
79659: LD_EXP 99
79663: PUSH
79664: LD_VAR 0 2
79668: ARRAY
79669: NOT
79670: IFFALSE 79722
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
79672: LD_ADDR_EXP 99
79676: PUSH
79677: LD_EXP 99
79681: PPUSH
79682: LD_VAR 0 2
79686: PPUSH
79687: LD_VAR 0 3
79691: PUSH
79692: LD_INT 1
79694: ARRAY
79695: PUSH
79696: EMPTY
79697: LIST
79698: PPUSH
79699: CALL_OW 1
79703: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
79704: LD_VAR 0 3
79708: PUSH
79709: LD_INT 1
79711: ARRAY
79712: PPUSH
79713: LD_INT 125
79715: PPUSH
79716: CALL_OW 109
// end else
79720: GO 79906
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
79722: LD_EXP 99
79726: PUSH
79727: LD_VAR 0 2
79731: ARRAY
79732: PUSH
79733: LD_INT 1
79735: ARRAY
79736: PPUSH
79737: CALL_OW 310
79741: IFFALSE 79764
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
79743: LD_EXP 99
79747: PUSH
79748: LD_VAR 0 2
79752: ARRAY
79753: PUSH
79754: LD_INT 1
79756: ARRAY
79757: PPUSH
79758: CALL_OW 122
79762: GO 79906
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
79764: LD_EXP 99
79768: PUSH
79769: LD_VAR 0 2
79773: ARRAY
79774: PUSH
79775: LD_INT 1
79777: ARRAY
79778: PPUSH
79779: CALL_OW 314
79783: NOT
79784: PUSH
79785: LD_EXP 99
79789: PUSH
79790: LD_VAR 0 2
79794: ARRAY
79795: PUSH
79796: LD_INT 1
79798: ARRAY
79799: PPUSH
79800: LD_EXP 98
79804: PUSH
79805: LD_VAR 0 2
79809: ARRAY
79810: PUSH
79811: LD_INT 1
79813: ARRAY
79814: PUSH
79815: LD_INT 1
79817: ARRAY
79818: PPUSH
79819: LD_EXP 98
79823: PUSH
79824: LD_VAR 0 2
79828: ARRAY
79829: PUSH
79830: LD_INT 1
79832: ARRAY
79833: PUSH
79834: LD_INT 2
79836: ARRAY
79837: PPUSH
79838: CALL_OW 297
79842: PUSH
79843: LD_INT 6
79845: GREATER
79846: AND
79847: IFFALSE 79906
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
79849: LD_EXP 99
79853: PUSH
79854: LD_VAR 0 2
79858: ARRAY
79859: PUSH
79860: LD_INT 1
79862: ARRAY
79863: PPUSH
79864: LD_EXP 98
79868: PUSH
79869: LD_VAR 0 2
79873: ARRAY
79874: PUSH
79875: LD_INT 1
79877: ARRAY
79878: PUSH
79879: LD_INT 1
79881: ARRAY
79882: PPUSH
79883: LD_EXP 98
79887: PUSH
79888: LD_VAR 0 2
79892: ARRAY
79893: PUSH
79894: LD_INT 1
79896: ARRAY
79897: PUSH
79898: LD_INT 2
79900: ARRAY
79901: PPUSH
79902: CALL_OW 111
// end ; end ; end ;
79906: GO 79319
79908: POP
79909: POP
// end ;
79910: LD_VAR 0 1
79914: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
79915: LD_INT 0
79917: PPUSH
79918: PPUSH
79919: PPUSH
79920: PPUSH
79921: PPUSH
79922: PPUSH
79923: PPUSH
79924: PPUSH
79925: PPUSH
79926: PPUSH
79927: PPUSH
// if not mc_bases then
79928: LD_EXP 61
79932: NOT
79933: IFFALSE 79937
// exit ;
79935: GO 80877
// for i = 1 to mc_bases do
79937: LD_ADDR_VAR 0 2
79941: PUSH
79942: DOUBLE
79943: LD_INT 1
79945: DEC
79946: ST_TO_ADDR
79947: LD_EXP 61
79951: PUSH
79952: FOR_TO
79953: IFFALSE 80875
// begin if not mc_bases [ i ] or mc_scan [ i ] then
79955: LD_EXP 61
79959: PUSH
79960: LD_VAR 0 2
79964: ARRAY
79965: NOT
79966: PUSH
79967: LD_EXP 84
79971: PUSH
79972: LD_VAR 0 2
79976: ARRAY
79977: OR
79978: IFFALSE 79982
// continue ;
79980: GO 79952
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
79982: LD_ADDR_VAR 0 7
79986: PUSH
79987: LD_EXP 61
79991: PUSH
79992: LD_VAR 0 2
79996: ARRAY
79997: PUSH
79998: LD_INT 1
80000: ARRAY
80001: PPUSH
80002: CALL_OW 248
80006: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
80007: LD_VAR 0 7
80011: PUSH
80012: LD_INT 3
80014: EQUAL
80015: PUSH
80016: LD_EXP 80
80020: PUSH
80021: LD_VAR 0 2
80025: ARRAY
80026: PUSH
80027: LD_EXP 83
80031: PUSH
80032: LD_VAR 0 2
80036: ARRAY
80037: UNION
80038: PPUSH
80039: LD_INT 33
80041: PUSH
80042: LD_INT 2
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PPUSH
80049: CALL_OW 72
80053: NOT
80054: OR
80055: IFFALSE 80059
// continue ;
80057: GO 79952
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
80059: LD_ADDR_VAR 0 9
80063: PUSH
80064: LD_EXP 61
80068: PUSH
80069: LD_VAR 0 2
80073: ARRAY
80074: PPUSH
80075: LD_INT 30
80077: PUSH
80078: LD_INT 36
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PPUSH
80085: CALL_OW 72
80089: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
80090: LD_ADDR_VAR 0 10
80094: PUSH
80095: LD_EXP 80
80099: PUSH
80100: LD_VAR 0 2
80104: ARRAY
80105: PPUSH
80106: LD_INT 34
80108: PUSH
80109: LD_INT 31
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PPUSH
80116: CALL_OW 72
80120: ST_TO_ADDR
// if not cts and not mcts then
80121: LD_VAR 0 9
80125: NOT
80126: PUSH
80127: LD_VAR 0 10
80131: NOT
80132: AND
80133: IFFALSE 80137
// continue ;
80135: GO 79952
// x := cts ;
80137: LD_ADDR_VAR 0 11
80141: PUSH
80142: LD_VAR 0 9
80146: ST_TO_ADDR
// if not x then
80147: LD_VAR 0 11
80151: NOT
80152: IFFALSE 80164
// x := mcts ;
80154: LD_ADDR_VAR 0 11
80158: PUSH
80159: LD_VAR 0 10
80163: ST_TO_ADDR
// if not x then
80164: LD_VAR 0 11
80168: NOT
80169: IFFALSE 80173
// continue ;
80171: GO 79952
// if mc_remote_driver [ i ] then
80173: LD_EXP 101
80177: PUSH
80178: LD_VAR 0 2
80182: ARRAY
80183: IFFALSE 80570
// for j in mc_remote_driver [ i ] do
80185: LD_ADDR_VAR 0 3
80189: PUSH
80190: LD_EXP 101
80194: PUSH
80195: LD_VAR 0 2
80199: ARRAY
80200: PUSH
80201: FOR_IN
80202: IFFALSE 80568
// begin if GetClass ( j ) <> 3 then
80204: LD_VAR 0 3
80208: PPUSH
80209: CALL_OW 257
80213: PUSH
80214: LD_INT 3
80216: NONEQUAL
80217: IFFALSE 80270
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
80219: LD_ADDR_EXP 101
80223: PUSH
80224: LD_EXP 101
80228: PPUSH
80229: LD_VAR 0 2
80233: PPUSH
80234: LD_EXP 101
80238: PUSH
80239: LD_VAR 0 2
80243: ARRAY
80244: PUSH
80245: LD_VAR 0 3
80249: DIFF
80250: PPUSH
80251: CALL_OW 1
80255: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80256: LD_VAR 0 3
80260: PPUSH
80261: LD_INT 0
80263: PPUSH
80264: CALL_OW 109
// continue ;
80268: GO 80201
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
80270: LD_EXP 80
80274: PUSH
80275: LD_VAR 0 2
80279: ARRAY
80280: PPUSH
80281: LD_INT 34
80283: PUSH
80284: LD_INT 31
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 58
80293: PUSH
80294: EMPTY
80295: LIST
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PPUSH
80301: CALL_OW 72
80305: PUSH
80306: LD_VAR 0 3
80310: PPUSH
80311: CALL 51325 0 1
80315: NOT
80316: AND
80317: IFFALSE 80388
// begin if IsInUnit ( j ) then
80319: LD_VAR 0 3
80323: PPUSH
80324: CALL_OW 310
80328: IFFALSE 80339
// ComExitBuilding ( j ) ;
80330: LD_VAR 0 3
80334: PPUSH
80335: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
80339: LD_VAR 0 3
80343: PPUSH
80344: LD_EXP 80
80348: PUSH
80349: LD_VAR 0 2
80353: ARRAY
80354: PPUSH
80355: LD_INT 34
80357: PUSH
80358: LD_INT 31
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: LD_INT 58
80367: PUSH
80368: EMPTY
80369: LIST
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PPUSH
80375: CALL_OW 72
80379: PUSH
80380: LD_INT 1
80382: ARRAY
80383: PPUSH
80384: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
80388: LD_VAR 0 3
80392: PPUSH
80393: CALL_OW 310
80397: NOT
80398: PUSH
80399: LD_VAR 0 3
80403: PPUSH
80404: CALL_OW 310
80408: PPUSH
80409: CALL_OW 266
80413: PUSH
80414: LD_INT 36
80416: NONEQUAL
80417: PUSH
80418: LD_VAR 0 3
80422: PPUSH
80423: CALL 51325 0 1
80427: NOT
80428: AND
80429: OR
80430: IFFALSE 80566
// begin if IsInUnit ( j ) then
80432: LD_VAR 0 3
80436: PPUSH
80437: CALL_OW 310
80441: IFFALSE 80452
// ComExitBuilding ( j ) ;
80443: LD_VAR 0 3
80447: PPUSH
80448: CALL_OW 122
// ct := 0 ;
80452: LD_ADDR_VAR 0 8
80456: PUSH
80457: LD_INT 0
80459: ST_TO_ADDR
// for k in x do
80460: LD_ADDR_VAR 0 4
80464: PUSH
80465: LD_VAR 0 11
80469: PUSH
80470: FOR_IN
80471: IFFALSE 80544
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
80473: LD_VAR 0 4
80477: PPUSH
80478: CALL_OW 264
80482: PUSH
80483: LD_INT 31
80485: EQUAL
80486: PUSH
80487: LD_VAR 0 4
80491: PPUSH
80492: CALL_OW 311
80496: NOT
80497: AND
80498: PUSH
80499: LD_VAR 0 4
80503: PPUSH
80504: CALL_OW 266
80508: PUSH
80509: LD_INT 36
80511: EQUAL
80512: PUSH
80513: LD_VAR 0 4
80517: PPUSH
80518: CALL_OW 313
80522: PUSH
80523: LD_INT 3
80525: LESS
80526: AND
80527: OR
80528: IFFALSE 80542
// begin ct := k ;
80530: LD_ADDR_VAR 0 8
80534: PUSH
80535: LD_VAR 0 4
80539: ST_TO_ADDR
// break ;
80540: GO 80544
// end ;
80542: GO 80470
80544: POP
80545: POP
// if ct then
80546: LD_VAR 0 8
80550: IFFALSE 80566
// ComEnterUnit ( j , ct ) ;
80552: LD_VAR 0 3
80556: PPUSH
80557: LD_VAR 0 8
80561: PPUSH
80562: CALL_OW 120
// end ; end ;
80566: GO 80201
80568: POP
80569: POP
// places := 0 ;
80570: LD_ADDR_VAR 0 5
80574: PUSH
80575: LD_INT 0
80577: ST_TO_ADDR
// for j = 1 to x do
80578: LD_ADDR_VAR 0 3
80582: PUSH
80583: DOUBLE
80584: LD_INT 1
80586: DEC
80587: ST_TO_ADDR
80588: LD_VAR 0 11
80592: PUSH
80593: FOR_TO
80594: IFFALSE 80670
// if GetWeapon ( x [ j ] ) = ar_control_tower then
80596: LD_VAR 0 11
80600: PUSH
80601: LD_VAR 0 3
80605: ARRAY
80606: PPUSH
80607: CALL_OW 264
80611: PUSH
80612: LD_INT 31
80614: EQUAL
80615: IFFALSE 80633
// places := places + 1 else
80617: LD_ADDR_VAR 0 5
80621: PUSH
80622: LD_VAR 0 5
80626: PUSH
80627: LD_INT 1
80629: PLUS
80630: ST_TO_ADDR
80631: GO 80668
// if GetBType ( x [ j ] ) = b_control_tower then
80633: LD_VAR 0 11
80637: PUSH
80638: LD_VAR 0 3
80642: ARRAY
80643: PPUSH
80644: CALL_OW 266
80648: PUSH
80649: LD_INT 36
80651: EQUAL
80652: IFFALSE 80668
// places := places + 3 ;
80654: LD_ADDR_VAR 0 5
80658: PUSH
80659: LD_VAR 0 5
80663: PUSH
80664: LD_INT 3
80666: PLUS
80667: ST_TO_ADDR
80668: GO 80593
80670: POP
80671: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
80672: LD_VAR 0 5
80676: PUSH
80677: LD_INT 0
80679: EQUAL
80680: PUSH
80681: LD_VAR 0 5
80685: PUSH
80686: LD_EXP 101
80690: PUSH
80691: LD_VAR 0 2
80695: ARRAY
80696: LESSEQUAL
80697: OR
80698: IFFALSE 80702
// continue ;
80700: GO 79952
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
80702: LD_ADDR_VAR 0 6
80706: PUSH
80707: LD_EXP 61
80711: PUSH
80712: LD_VAR 0 2
80716: ARRAY
80717: PPUSH
80718: LD_INT 25
80720: PUSH
80721: LD_INT 3
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PPUSH
80728: CALL_OW 72
80732: PUSH
80733: LD_EXP 101
80737: PUSH
80738: LD_VAR 0 2
80742: ARRAY
80743: DIFF
80744: PPUSH
80745: LD_INT 3
80747: PPUSH
80748: CALL 52225 0 2
80752: ST_TO_ADDR
// for j in tmp do
80753: LD_ADDR_VAR 0 3
80757: PUSH
80758: LD_VAR 0 6
80762: PUSH
80763: FOR_IN
80764: IFFALSE 80799
// if GetTag ( j ) > 0 then
80766: LD_VAR 0 3
80770: PPUSH
80771: CALL_OW 110
80775: PUSH
80776: LD_INT 0
80778: GREATER
80779: IFFALSE 80797
// tmp := tmp diff j ;
80781: LD_ADDR_VAR 0 6
80785: PUSH
80786: LD_VAR 0 6
80790: PUSH
80791: LD_VAR 0 3
80795: DIFF
80796: ST_TO_ADDR
80797: GO 80763
80799: POP
80800: POP
// if not tmp then
80801: LD_VAR 0 6
80805: NOT
80806: IFFALSE 80810
// continue ;
80808: GO 79952
// if places then
80810: LD_VAR 0 5
80814: IFFALSE 80873
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
80816: LD_ADDR_EXP 101
80820: PUSH
80821: LD_EXP 101
80825: PPUSH
80826: LD_VAR 0 2
80830: PPUSH
80831: LD_EXP 101
80835: PUSH
80836: LD_VAR 0 2
80840: ARRAY
80841: PUSH
80842: LD_VAR 0 6
80846: PUSH
80847: LD_INT 1
80849: ARRAY
80850: UNION
80851: PPUSH
80852: CALL_OW 1
80856: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
80857: LD_VAR 0 6
80861: PUSH
80862: LD_INT 1
80864: ARRAY
80865: PPUSH
80866: LD_INT 126
80868: PPUSH
80869: CALL_OW 109
// end ; end ;
80873: GO 79952
80875: POP
80876: POP
// end ;
80877: LD_VAR 0 1
80881: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
80882: LD_INT 0
80884: PPUSH
80885: PPUSH
80886: PPUSH
80887: PPUSH
80888: PPUSH
80889: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
80890: LD_VAR 0 1
80894: NOT
80895: PUSH
80896: LD_VAR 0 2
80900: NOT
80901: OR
80902: PUSH
80903: LD_VAR 0 3
80907: NOT
80908: OR
80909: PUSH
80910: LD_VAR 0 4
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: LD_INT 3
80923: PUSH
80924: LD_INT 4
80926: PUSH
80927: LD_INT 5
80929: PUSH
80930: LD_INT 8
80932: PUSH
80933: LD_INT 9
80935: PUSH
80936: LD_INT 15
80938: PUSH
80939: LD_INT 16
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: IN
80953: NOT
80954: OR
80955: IFFALSE 80959
// exit ;
80957: GO 81817
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
80959: LD_ADDR_VAR 0 2
80963: PUSH
80964: LD_VAR 0 2
80968: PPUSH
80969: LD_INT 21
80971: PUSH
80972: LD_INT 3
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 24
80981: PUSH
80982: LD_INT 250
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PPUSH
80993: CALL_OW 72
80997: ST_TO_ADDR
// case class of 1 , 15 :
80998: LD_VAR 0 4
81002: PUSH
81003: LD_INT 1
81005: DOUBLE
81006: EQUAL
81007: IFTRUE 81017
81009: LD_INT 15
81011: DOUBLE
81012: EQUAL
81013: IFTRUE 81017
81015: GO 81102
81017: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
81018: LD_ADDR_VAR 0 8
81022: PUSH
81023: LD_VAR 0 2
81027: PPUSH
81028: LD_INT 2
81030: PUSH
81031: LD_INT 30
81033: PUSH
81034: LD_INT 32
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 30
81043: PUSH
81044: LD_INT 31
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: LIST
81055: PPUSH
81056: CALL_OW 72
81060: PUSH
81061: LD_VAR 0 2
81065: PPUSH
81066: LD_INT 2
81068: PUSH
81069: LD_INT 30
81071: PUSH
81072: LD_INT 4
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 30
81081: PUSH
81082: LD_INT 5
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: LIST
81093: PPUSH
81094: CALL_OW 72
81098: ADD
81099: ST_TO_ADDR
81100: GO 81348
81102: LD_INT 2
81104: DOUBLE
81105: EQUAL
81106: IFTRUE 81116
81108: LD_INT 16
81110: DOUBLE
81111: EQUAL
81112: IFTRUE 81116
81114: GO 81162
81116: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
81117: LD_ADDR_VAR 0 8
81121: PUSH
81122: LD_VAR 0 2
81126: PPUSH
81127: LD_INT 2
81129: PUSH
81130: LD_INT 30
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 30
81142: PUSH
81143: LD_INT 1
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: LIST
81154: PPUSH
81155: CALL_OW 72
81159: ST_TO_ADDR
81160: GO 81348
81162: LD_INT 3
81164: DOUBLE
81165: EQUAL
81166: IFTRUE 81170
81168: GO 81216
81170: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
81171: LD_ADDR_VAR 0 8
81175: PUSH
81176: LD_VAR 0 2
81180: PPUSH
81181: LD_INT 2
81183: PUSH
81184: LD_INT 30
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 30
81196: PUSH
81197: LD_INT 3
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: LIST
81208: PPUSH
81209: CALL_OW 72
81213: ST_TO_ADDR
81214: GO 81348
81216: LD_INT 4
81218: DOUBLE
81219: EQUAL
81220: IFTRUE 81224
81222: GO 81281
81224: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
81225: LD_ADDR_VAR 0 8
81229: PUSH
81230: LD_VAR 0 2
81234: PPUSH
81235: LD_INT 2
81237: PUSH
81238: LD_INT 30
81240: PUSH
81241: LD_INT 6
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 30
81250: PUSH
81251: LD_INT 7
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 30
81260: PUSH
81261: LD_INT 8
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: PPUSH
81274: CALL_OW 72
81278: ST_TO_ADDR
81279: GO 81348
81281: LD_INT 5
81283: DOUBLE
81284: EQUAL
81285: IFTRUE 81301
81287: LD_INT 8
81289: DOUBLE
81290: EQUAL
81291: IFTRUE 81301
81293: LD_INT 9
81295: DOUBLE
81296: EQUAL
81297: IFTRUE 81301
81299: GO 81347
81301: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
81302: LD_ADDR_VAR 0 8
81306: PUSH
81307: LD_VAR 0 2
81311: PPUSH
81312: LD_INT 2
81314: PUSH
81315: LD_INT 30
81317: PUSH
81318: LD_INT 4
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 30
81327: PUSH
81328: LD_INT 5
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: LIST
81339: PPUSH
81340: CALL_OW 72
81344: ST_TO_ADDR
81345: GO 81348
81347: POP
// if not tmp then
81348: LD_VAR 0 8
81352: NOT
81353: IFFALSE 81357
// exit ;
81355: GO 81817
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
81357: LD_VAR 0 4
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: LD_INT 15
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: IN
81372: PUSH
81373: LD_EXP 70
81377: PUSH
81378: LD_VAR 0 1
81382: ARRAY
81383: AND
81384: IFFALSE 81540
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
81386: LD_ADDR_VAR 0 9
81390: PUSH
81391: LD_EXP 70
81395: PUSH
81396: LD_VAR 0 1
81400: ARRAY
81401: PUSH
81402: LD_INT 1
81404: ARRAY
81405: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
81406: LD_VAR 0 9
81410: PUSH
81411: LD_EXP 71
81415: PUSH
81416: LD_VAR 0 1
81420: ARRAY
81421: IN
81422: NOT
81423: IFFALSE 81538
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
81425: LD_ADDR_EXP 71
81429: PUSH
81430: LD_EXP 71
81434: PPUSH
81435: LD_VAR 0 1
81439: PUSH
81440: LD_EXP 71
81444: PUSH
81445: LD_VAR 0 1
81449: ARRAY
81450: PUSH
81451: LD_INT 1
81453: PLUS
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PPUSH
81459: LD_VAR 0 9
81463: PPUSH
81464: CALL 20981 0 3
81468: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
81469: LD_ADDR_EXP 70
81473: PUSH
81474: LD_EXP 70
81478: PPUSH
81479: LD_VAR 0 1
81483: PPUSH
81484: LD_EXP 70
81488: PUSH
81489: LD_VAR 0 1
81493: ARRAY
81494: PUSH
81495: LD_VAR 0 9
81499: DIFF
81500: PPUSH
81501: CALL_OW 1
81505: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
81506: LD_VAR 0 3
81510: PPUSH
81511: LD_EXP 71
81515: PUSH
81516: LD_VAR 0 1
81520: ARRAY
81521: PUSH
81522: LD_EXP 71
81526: PUSH
81527: LD_VAR 0 1
81531: ARRAY
81532: ARRAY
81533: PPUSH
81534: CALL_OW 120
// end ; exit ;
81538: GO 81817
// end ; if tmp > 1 then
81540: LD_VAR 0 8
81544: PUSH
81545: LD_INT 1
81547: GREATER
81548: IFFALSE 81652
// for i = 2 to tmp do
81550: LD_ADDR_VAR 0 6
81554: PUSH
81555: DOUBLE
81556: LD_INT 2
81558: DEC
81559: ST_TO_ADDR
81560: LD_VAR 0 8
81564: PUSH
81565: FOR_TO
81566: IFFALSE 81650
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
81568: LD_VAR 0 8
81572: PUSH
81573: LD_VAR 0 6
81577: ARRAY
81578: PPUSH
81579: CALL_OW 461
81583: PUSH
81584: LD_INT 6
81586: EQUAL
81587: IFFALSE 81648
// begin x := tmp [ i ] ;
81589: LD_ADDR_VAR 0 9
81593: PUSH
81594: LD_VAR 0 8
81598: PUSH
81599: LD_VAR 0 6
81603: ARRAY
81604: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
81605: LD_ADDR_VAR 0 8
81609: PUSH
81610: LD_VAR 0 8
81614: PPUSH
81615: LD_VAR 0 6
81619: PPUSH
81620: CALL_OW 3
81624: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
81625: LD_ADDR_VAR 0 8
81629: PUSH
81630: LD_VAR 0 8
81634: PPUSH
81635: LD_INT 1
81637: PPUSH
81638: LD_VAR 0 9
81642: PPUSH
81643: CALL_OW 2
81647: ST_TO_ADDR
// end ;
81648: GO 81565
81650: POP
81651: POP
// for i in tmp do
81652: LD_ADDR_VAR 0 6
81656: PUSH
81657: LD_VAR 0 8
81661: PUSH
81662: FOR_IN
81663: IFFALSE 81690
// begin if IsNotFull ( i ) then
81665: LD_VAR 0 6
81669: PPUSH
81670: CALL 18203 0 1
81674: IFFALSE 81688
// begin j := i ;
81676: LD_ADDR_VAR 0 7
81680: PUSH
81681: LD_VAR 0 6
81685: ST_TO_ADDR
// break ;
81686: GO 81690
// end ; end ;
81688: GO 81662
81690: POP
81691: POP
// if j then
81692: LD_VAR 0 7
81696: IFFALSE 81714
// ComEnterUnit ( unit , j ) else
81698: LD_VAR 0 3
81702: PPUSH
81703: LD_VAR 0 7
81707: PPUSH
81708: CALL_OW 120
81712: GO 81817
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81714: LD_ADDR_VAR 0 10
81718: PUSH
81719: LD_VAR 0 2
81723: PPUSH
81724: LD_INT 2
81726: PUSH
81727: LD_INT 30
81729: PUSH
81730: LD_INT 0
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 30
81739: PUSH
81740: LD_INT 1
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: LIST
81751: PPUSH
81752: CALL_OW 72
81756: ST_TO_ADDR
// if depot then
81757: LD_VAR 0 10
81761: IFFALSE 81817
// begin depot := NearestUnitToUnit ( depot , unit ) ;
81763: LD_ADDR_VAR 0 10
81767: PUSH
81768: LD_VAR 0 10
81772: PPUSH
81773: LD_VAR 0 3
81777: PPUSH
81778: CALL_OW 74
81782: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
81783: LD_VAR 0 3
81787: PPUSH
81788: LD_VAR 0 10
81792: PPUSH
81793: CALL_OW 296
81797: PUSH
81798: LD_INT 10
81800: GREATER
81801: IFFALSE 81817
// ComStandNearbyBuilding ( unit , depot ) ;
81803: LD_VAR 0 3
81807: PPUSH
81808: LD_VAR 0 10
81812: PPUSH
81813: CALL 17583 0 2
// end ; end ; end ;
81817: LD_VAR 0 5
81821: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
81822: LD_INT 0
81824: PPUSH
81825: PPUSH
81826: PPUSH
81827: PPUSH
// if not mc_bases then
81828: LD_EXP 61
81832: NOT
81833: IFFALSE 81837
// exit ;
81835: GO 82076
// for i = 1 to mc_bases do
81837: LD_ADDR_VAR 0 2
81841: PUSH
81842: DOUBLE
81843: LD_INT 1
81845: DEC
81846: ST_TO_ADDR
81847: LD_EXP 61
81851: PUSH
81852: FOR_TO
81853: IFFALSE 82074
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
81855: LD_ADDR_VAR 0 4
81859: PUSH
81860: LD_EXP 61
81864: PUSH
81865: LD_VAR 0 2
81869: ARRAY
81870: PPUSH
81871: LD_INT 21
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PPUSH
81881: CALL_OW 72
81885: PUSH
81886: LD_EXP 90
81890: PUSH
81891: LD_VAR 0 2
81895: ARRAY
81896: UNION
81897: ST_TO_ADDR
// if not tmp then
81898: LD_VAR 0 4
81902: NOT
81903: IFFALSE 81907
// continue ;
81905: GO 81852
// for j in tmp do
81907: LD_ADDR_VAR 0 3
81911: PUSH
81912: LD_VAR 0 4
81916: PUSH
81917: FOR_IN
81918: IFFALSE 82070
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
81920: LD_VAR 0 3
81924: PPUSH
81925: CALL_OW 110
81929: NOT
81930: PUSH
81931: LD_VAR 0 3
81935: PPUSH
81936: CALL_OW 314
81940: NOT
81941: AND
81942: PUSH
81943: LD_VAR 0 3
81947: PPUSH
81948: CALL_OW 311
81952: NOT
81953: AND
81954: PUSH
81955: LD_VAR 0 3
81959: PPUSH
81960: CALL_OW 310
81964: NOT
81965: AND
81966: PUSH
81967: LD_VAR 0 3
81971: PUSH
81972: LD_EXP 64
81976: PUSH
81977: LD_VAR 0 2
81981: ARRAY
81982: PUSH
81983: LD_INT 1
81985: ARRAY
81986: IN
81987: NOT
81988: AND
81989: PUSH
81990: LD_VAR 0 3
81994: PUSH
81995: LD_EXP 64
81999: PUSH
82000: LD_VAR 0 2
82004: ARRAY
82005: PUSH
82006: LD_INT 2
82008: ARRAY
82009: IN
82010: NOT
82011: AND
82012: PUSH
82013: LD_VAR 0 3
82017: PUSH
82018: LD_EXP 73
82022: PUSH
82023: LD_VAR 0 2
82027: ARRAY
82028: IN
82029: NOT
82030: AND
82031: IFFALSE 82068
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
82033: LD_VAR 0 2
82037: PPUSH
82038: LD_EXP 61
82042: PUSH
82043: LD_VAR 0 2
82047: ARRAY
82048: PPUSH
82049: LD_VAR 0 3
82053: PPUSH
82054: LD_VAR 0 3
82058: PPUSH
82059: CALL_OW 257
82063: PPUSH
82064: CALL 80882 0 4
// end ;
82068: GO 81917
82070: POP
82071: POP
// end ;
82072: GO 81852
82074: POP
82075: POP
// end ;
82076: LD_VAR 0 1
82080: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
82081: LD_INT 0
82083: PPUSH
82084: PPUSH
82085: PPUSH
82086: PPUSH
82087: PPUSH
82088: PPUSH
// if not mc_bases [ base ] then
82089: LD_EXP 61
82093: PUSH
82094: LD_VAR 0 1
82098: ARRAY
82099: NOT
82100: IFFALSE 82104
// exit ;
82102: GO 82305
// tmp := [ ] ;
82104: LD_ADDR_VAR 0 6
82108: PUSH
82109: EMPTY
82110: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
82111: LD_ADDR_VAR 0 7
82115: PUSH
82116: LD_VAR 0 3
82120: PPUSH
82121: LD_INT 0
82123: PPUSH
82124: CALL_OW 517
82128: ST_TO_ADDR
// if not list then
82129: LD_VAR 0 7
82133: NOT
82134: IFFALSE 82138
// exit ;
82136: GO 82305
// c := Count ( list [ 1 ] ) ;
82138: LD_ADDR_VAR 0 9
82142: PUSH
82143: LD_VAR 0 7
82147: PUSH
82148: LD_INT 1
82150: ARRAY
82151: PPUSH
82152: CALL 18121 0 1
82156: ST_TO_ADDR
// if amount > c then
82157: LD_VAR 0 2
82161: PUSH
82162: LD_VAR 0 9
82166: GREATER
82167: IFFALSE 82179
// amount := c ;
82169: LD_ADDR_VAR 0 2
82173: PUSH
82174: LD_VAR 0 9
82178: ST_TO_ADDR
// for i := 1 to amount do
82179: LD_ADDR_VAR 0 5
82183: PUSH
82184: DOUBLE
82185: LD_INT 1
82187: DEC
82188: ST_TO_ADDR
82189: LD_VAR 0 2
82193: PUSH
82194: FOR_TO
82195: IFFALSE 82253
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
82197: LD_ADDR_VAR 0 6
82201: PUSH
82202: LD_VAR 0 6
82206: PPUSH
82207: LD_VAR 0 5
82211: PPUSH
82212: LD_VAR 0 7
82216: PUSH
82217: LD_INT 1
82219: ARRAY
82220: PUSH
82221: LD_VAR 0 5
82225: ARRAY
82226: PUSH
82227: LD_VAR 0 7
82231: PUSH
82232: LD_INT 2
82234: ARRAY
82235: PUSH
82236: LD_VAR 0 5
82240: ARRAY
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PPUSH
82246: CALL_OW 1
82250: ST_TO_ADDR
82251: GO 82194
82253: POP
82254: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
82255: LD_ADDR_EXP 74
82259: PUSH
82260: LD_EXP 74
82264: PPUSH
82265: LD_VAR 0 1
82269: PPUSH
82270: LD_VAR 0 6
82274: PPUSH
82275: CALL_OW 1
82279: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
82280: LD_ADDR_EXP 76
82284: PUSH
82285: LD_EXP 76
82289: PPUSH
82290: LD_VAR 0 1
82294: PPUSH
82295: LD_VAR 0 3
82299: PPUSH
82300: CALL_OW 1
82304: ST_TO_ADDR
// end ;
82305: LD_VAR 0 4
82309: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
82310: LD_INT 0
82312: PPUSH
// if not mc_bases [ base ] then
82313: LD_EXP 61
82317: PUSH
82318: LD_VAR 0 1
82322: ARRAY
82323: NOT
82324: IFFALSE 82328
// exit ;
82326: GO 82353
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
82328: LD_ADDR_EXP 66
82332: PUSH
82333: LD_EXP 66
82337: PPUSH
82338: LD_VAR 0 1
82342: PPUSH
82343: LD_VAR 0 2
82347: PPUSH
82348: CALL_OW 1
82352: ST_TO_ADDR
// end ;
82353: LD_VAR 0 3
82357: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
82358: LD_INT 0
82360: PPUSH
// if not mc_bases [ base ] then
82361: LD_EXP 61
82365: PUSH
82366: LD_VAR 0 1
82370: ARRAY
82371: NOT
82372: IFFALSE 82376
// exit ;
82374: GO 82413
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
82376: LD_ADDR_EXP 66
82380: PUSH
82381: LD_EXP 66
82385: PPUSH
82386: LD_VAR 0 1
82390: PPUSH
82391: LD_EXP 66
82395: PUSH
82396: LD_VAR 0 1
82400: ARRAY
82401: PUSH
82402: LD_VAR 0 2
82406: UNION
82407: PPUSH
82408: CALL_OW 1
82412: ST_TO_ADDR
// end ;
82413: LD_VAR 0 3
82417: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
82418: LD_INT 0
82420: PPUSH
// if not mc_bases [ base ] then
82421: LD_EXP 61
82425: PUSH
82426: LD_VAR 0 1
82430: ARRAY
82431: NOT
82432: IFFALSE 82436
// exit ;
82434: GO 82461
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
82436: LD_ADDR_EXP 82
82440: PUSH
82441: LD_EXP 82
82445: PPUSH
82446: LD_VAR 0 1
82450: PPUSH
82451: LD_VAR 0 2
82455: PPUSH
82456: CALL_OW 1
82460: ST_TO_ADDR
// end ;
82461: LD_VAR 0 3
82465: RET
// export function MC_InsertProduceList ( base , components ) ; begin
82466: LD_INT 0
82468: PPUSH
// if not mc_bases [ base ] then
82469: LD_EXP 61
82473: PUSH
82474: LD_VAR 0 1
82478: ARRAY
82479: NOT
82480: IFFALSE 82484
// exit ;
82482: GO 82521
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
82484: LD_ADDR_EXP 82
82488: PUSH
82489: LD_EXP 82
82493: PPUSH
82494: LD_VAR 0 1
82498: PPUSH
82499: LD_EXP 82
82503: PUSH
82504: LD_VAR 0 1
82508: ARRAY
82509: PUSH
82510: LD_VAR 0 2
82514: ADD
82515: PPUSH
82516: CALL_OW 1
82520: ST_TO_ADDR
// end ;
82521: LD_VAR 0 3
82525: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
82526: LD_INT 0
82528: PPUSH
// if not mc_bases [ base ] then
82529: LD_EXP 61
82533: PUSH
82534: LD_VAR 0 1
82538: ARRAY
82539: NOT
82540: IFFALSE 82544
// exit ;
82542: GO 82598
// mc_defender := Replace ( mc_defender , base , deflist ) ;
82544: LD_ADDR_EXP 83
82548: PUSH
82549: LD_EXP 83
82553: PPUSH
82554: LD_VAR 0 1
82558: PPUSH
82559: LD_VAR 0 2
82563: PPUSH
82564: CALL_OW 1
82568: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
82569: LD_ADDR_EXP 72
82573: PUSH
82574: LD_EXP 72
82578: PPUSH
82579: LD_VAR 0 1
82583: PPUSH
82584: LD_VAR 0 2
82588: PUSH
82589: LD_INT 0
82591: PLUS
82592: PPUSH
82593: CALL_OW 1
82597: ST_TO_ADDR
// end ;
82598: LD_VAR 0 3
82602: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
82603: LD_INT 0
82605: PPUSH
// if not mc_bases [ base ] then
82606: LD_EXP 61
82610: PUSH
82611: LD_VAR 0 1
82615: ARRAY
82616: NOT
82617: IFFALSE 82621
// exit ;
82619: GO 82646
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
82621: LD_ADDR_EXP 72
82625: PUSH
82626: LD_EXP 72
82630: PPUSH
82631: LD_VAR 0 1
82635: PPUSH
82636: LD_VAR 0 2
82640: PPUSH
82641: CALL_OW 1
82645: ST_TO_ADDR
// end ;
82646: LD_VAR 0 3
82650: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
82651: LD_INT 0
82653: PPUSH
82654: PPUSH
82655: PPUSH
82656: PPUSH
// if not mc_bases [ base ] then
82657: LD_EXP 61
82661: PUSH
82662: LD_VAR 0 1
82666: ARRAY
82667: NOT
82668: IFFALSE 82672
// exit ;
82670: GO 82737
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
82672: LD_ADDR_EXP 81
82676: PUSH
82677: LD_EXP 81
82681: PPUSH
82682: LD_VAR 0 1
82686: PUSH
82687: LD_EXP 81
82691: PUSH
82692: LD_VAR 0 1
82696: ARRAY
82697: PUSH
82698: LD_INT 1
82700: PLUS
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PPUSH
82706: LD_VAR 0 1
82710: PUSH
82711: LD_VAR 0 2
82715: PUSH
82716: LD_VAR 0 3
82720: PUSH
82721: LD_VAR 0 4
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: PPUSH
82732: CALL 20981 0 3
82736: ST_TO_ADDR
// end ;
82737: LD_VAR 0 5
82741: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
82742: LD_INT 0
82744: PPUSH
// if not mc_bases [ base ] then
82745: LD_EXP 61
82749: PUSH
82750: LD_VAR 0 1
82754: ARRAY
82755: NOT
82756: IFFALSE 82760
// exit ;
82758: GO 82785
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
82760: LD_ADDR_EXP 98
82764: PUSH
82765: LD_EXP 98
82769: PPUSH
82770: LD_VAR 0 1
82774: PPUSH
82775: LD_VAR 0 2
82779: PPUSH
82780: CALL_OW 1
82784: ST_TO_ADDR
// end ;
82785: LD_VAR 0 3
82789: RET
// export function MC_GetMinesField ( base ) ; begin
82790: LD_INT 0
82792: PPUSH
// result := mc_mines [ base ] ;
82793: LD_ADDR_VAR 0 2
82797: PUSH
82798: LD_EXP 74
82802: PUSH
82803: LD_VAR 0 1
82807: ARRAY
82808: ST_TO_ADDR
// end ;
82809: LD_VAR 0 2
82813: RET
// export function MC_GetProduceList ( base ) ; begin
82814: LD_INT 0
82816: PPUSH
// result := mc_produce [ base ] ;
82817: LD_ADDR_VAR 0 2
82821: PUSH
82822: LD_EXP 82
82826: PUSH
82827: LD_VAR 0 1
82831: ARRAY
82832: ST_TO_ADDR
// end ;
82833: LD_VAR 0 2
82837: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
82838: LD_INT 0
82840: PPUSH
82841: PPUSH
// if not mc_bases then
82842: LD_EXP 61
82846: NOT
82847: IFFALSE 82851
// exit ;
82849: GO 82916
// if mc_bases [ base ] then
82851: LD_EXP 61
82855: PUSH
82856: LD_VAR 0 1
82860: ARRAY
82861: IFFALSE 82916
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
82863: LD_ADDR_VAR 0 3
82867: PUSH
82868: LD_EXP 61
82872: PUSH
82873: LD_VAR 0 1
82877: ARRAY
82878: PPUSH
82879: LD_INT 30
82881: PUSH
82882: LD_VAR 0 2
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PPUSH
82891: CALL_OW 72
82895: ST_TO_ADDR
// if result then
82896: LD_VAR 0 3
82900: IFFALSE 82916
// result := result [ 1 ] ;
82902: LD_ADDR_VAR 0 3
82906: PUSH
82907: LD_VAR 0 3
82911: PUSH
82912: LD_INT 1
82914: ARRAY
82915: ST_TO_ADDR
// end ; end ;
82916: LD_VAR 0 3
82920: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
82921: LD_INT 0
82923: PPUSH
82924: PPUSH
// if not mc_bases then
82925: LD_EXP 61
82929: NOT
82930: IFFALSE 82934
// exit ;
82932: GO 82979
// if mc_bases [ base ] then
82934: LD_EXP 61
82938: PUSH
82939: LD_VAR 0 1
82943: ARRAY
82944: IFFALSE 82979
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
82946: LD_ADDR_VAR 0 3
82950: PUSH
82951: LD_EXP 61
82955: PUSH
82956: LD_VAR 0 1
82960: ARRAY
82961: PPUSH
82962: LD_INT 30
82964: PUSH
82965: LD_VAR 0 2
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PPUSH
82974: CALL_OW 72
82978: ST_TO_ADDR
// end ;
82979: LD_VAR 0 3
82983: RET
// export function MC_SetTame ( base , area ) ; begin
82984: LD_INT 0
82986: PPUSH
// if not mc_bases or not base then
82987: LD_EXP 61
82991: NOT
82992: PUSH
82993: LD_VAR 0 1
82997: NOT
82998: OR
82999: IFFALSE 83003
// exit ;
83001: GO 83028
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
83003: LD_ADDR_EXP 89
83007: PUSH
83008: LD_EXP 89
83012: PPUSH
83013: LD_VAR 0 1
83017: PPUSH
83018: LD_VAR 0 2
83022: PPUSH
83023: CALL_OW 1
83027: ST_TO_ADDR
// end ;
83028: LD_VAR 0 3
83032: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
83033: LD_INT 0
83035: PPUSH
83036: PPUSH
// if not mc_bases or not base then
83037: LD_EXP 61
83041: NOT
83042: PUSH
83043: LD_VAR 0 1
83047: NOT
83048: OR
83049: IFFALSE 83053
// exit ;
83051: GO 83155
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
83053: LD_ADDR_VAR 0 4
83057: PUSH
83058: LD_EXP 61
83062: PUSH
83063: LD_VAR 0 1
83067: ARRAY
83068: PPUSH
83069: LD_INT 30
83071: PUSH
83072: LD_VAR 0 2
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: PPUSH
83081: CALL_OW 72
83085: ST_TO_ADDR
// if not tmp then
83086: LD_VAR 0 4
83090: NOT
83091: IFFALSE 83095
// exit ;
83093: GO 83155
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
83095: LD_ADDR_EXP 93
83099: PUSH
83100: LD_EXP 93
83104: PPUSH
83105: LD_VAR 0 1
83109: PPUSH
83110: LD_EXP 93
83114: PUSH
83115: LD_VAR 0 1
83119: ARRAY
83120: PPUSH
83121: LD_EXP 93
83125: PUSH
83126: LD_VAR 0 1
83130: ARRAY
83131: PUSH
83132: LD_INT 1
83134: PLUS
83135: PPUSH
83136: LD_VAR 0 4
83140: PUSH
83141: LD_INT 1
83143: ARRAY
83144: PPUSH
83145: CALL_OW 2
83149: PPUSH
83150: CALL_OW 1
83154: ST_TO_ADDR
// end ;
83155: LD_VAR 0 3
83159: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
83160: LD_INT 0
83162: PPUSH
83163: PPUSH
// if not mc_bases or not base or not kinds then
83164: LD_EXP 61
83168: NOT
83169: PUSH
83170: LD_VAR 0 1
83174: NOT
83175: OR
83176: PUSH
83177: LD_VAR 0 2
83181: NOT
83182: OR
83183: IFFALSE 83187
// exit ;
83185: GO 83248
// for i in kinds do
83187: LD_ADDR_VAR 0 4
83191: PUSH
83192: LD_VAR 0 2
83196: PUSH
83197: FOR_IN
83198: IFFALSE 83246
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
83200: LD_ADDR_EXP 95
83204: PUSH
83205: LD_EXP 95
83209: PPUSH
83210: LD_VAR 0 1
83214: PUSH
83215: LD_EXP 95
83219: PUSH
83220: LD_VAR 0 1
83224: ARRAY
83225: PUSH
83226: LD_INT 1
83228: PLUS
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PPUSH
83234: LD_VAR 0 4
83238: PPUSH
83239: CALL 20981 0 3
83243: ST_TO_ADDR
83244: GO 83197
83246: POP
83247: POP
// end ;
83248: LD_VAR 0 3
83252: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
83253: LD_INT 0
83255: PPUSH
// if not mc_bases or not base or not areas then
83256: LD_EXP 61
83260: NOT
83261: PUSH
83262: LD_VAR 0 1
83266: NOT
83267: OR
83268: PUSH
83269: LD_VAR 0 2
83273: NOT
83274: OR
83275: IFFALSE 83279
// exit ;
83277: GO 83304
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
83279: LD_ADDR_EXP 79
83283: PUSH
83284: LD_EXP 79
83288: PPUSH
83289: LD_VAR 0 1
83293: PPUSH
83294: LD_VAR 0 2
83298: PPUSH
83299: CALL_OW 1
83303: ST_TO_ADDR
// end ;
83304: LD_VAR 0 3
83308: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
83309: LD_INT 0
83311: PPUSH
// if not mc_bases or not base or not teleports_exit then
83312: LD_EXP 61
83316: NOT
83317: PUSH
83318: LD_VAR 0 1
83322: NOT
83323: OR
83324: PUSH
83325: LD_VAR 0 2
83329: NOT
83330: OR
83331: IFFALSE 83335
// exit ;
83333: GO 83360
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
83335: LD_ADDR_EXP 96
83339: PUSH
83340: LD_EXP 96
83344: PPUSH
83345: LD_VAR 0 1
83349: PPUSH
83350: LD_VAR 0 2
83354: PPUSH
83355: CALL_OW 1
83359: ST_TO_ADDR
// end ;
83360: LD_VAR 0 3
83364: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
83365: LD_INT 0
83367: PPUSH
83368: PPUSH
83369: PPUSH
// if not mc_bases or not base or not ext_list then
83370: LD_EXP 61
83374: NOT
83375: PUSH
83376: LD_VAR 0 1
83380: NOT
83381: OR
83382: PUSH
83383: LD_VAR 0 5
83387: NOT
83388: OR
83389: IFFALSE 83393
// exit ;
83391: GO 83566
// tmp := GetFacExtXYD ( x , y , d ) ;
83393: LD_ADDR_VAR 0 8
83397: PUSH
83398: LD_VAR 0 2
83402: PPUSH
83403: LD_VAR 0 3
83407: PPUSH
83408: LD_VAR 0 4
83412: PPUSH
83413: CALL 51355 0 3
83417: ST_TO_ADDR
// if not tmp then
83418: LD_VAR 0 8
83422: NOT
83423: IFFALSE 83427
// exit ;
83425: GO 83566
// for i in tmp do
83427: LD_ADDR_VAR 0 7
83431: PUSH
83432: LD_VAR 0 8
83436: PUSH
83437: FOR_IN
83438: IFFALSE 83564
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
83440: LD_ADDR_EXP 66
83444: PUSH
83445: LD_EXP 66
83449: PPUSH
83450: LD_VAR 0 1
83454: PPUSH
83455: LD_EXP 66
83459: PUSH
83460: LD_VAR 0 1
83464: ARRAY
83465: PPUSH
83466: LD_EXP 66
83470: PUSH
83471: LD_VAR 0 1
83475: ARRAY
83476: PUSH
83477: LD_INT 1
83479: PLUS
83480: PPUSH
83481: LD_VAR 0 5
83485: PUSH
83486: LD_INT 1
83488: ARRAY
83489: PUSH
83490: LD_VAR 0 7
83494: PUSH
83495: LD_INT 1
83497: ARRAY
83498: PUSH
83499: LD_VAR 0 7
83503: PUSH
83504: LD_INT 2
83506: ARRAY
83507: PUSH
83508: LD_VAR 0 7
83512: PUSH
83513: LD_INT 3
83515: ARRAY
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: PPUSH
83523: CALL_OW 2
83527: PPUSH
83528: CALL_OW 1
83532: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
83533: LD_ADDR_VAR 0 5
83537: PUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: LD_INT 1
83545: PPUSH
83546: CALL_OW 3
83550: ST_TO_ADDR
// if not ext_list then
83551: LD_VAR 0 5
83555: NOT
83556: IFFALSE 83562
// exit ;
83558: POP
83559: POP
83560: GO 83566
// end ;
83562: GO 83437
83564: POP
83565: POP
// end ;
83566: LD_VAR 0 6
83570: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
83571: LD_INT 0
83573: PPUSH
// if not mc_bases or not base or not weapon_list then
83574: LD_EXP 61
83578: NOT
83579: PUSH
83580: LD_VAR 0 1
83584: NOT
83585: OR
83586: PUSH
83587: LD_VAR 0 2
83591: NOT
83592: OR
83593: IFFALSE 83597
// exit ;
83595: GO 83622
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
83597: LD_ADDR_EXP 100
83601: PUSH
83602: LD_EXP 100
83606: PPUSH
83607: LD_VAR 0 1
83611: PPUSH
83612: LD_VAR 0 2
83616: PPUSH
83617: CALL_OW 1
83621: ST_TO_ADDR
// end ;
83622: LD_VAR 0 3
83626: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
83627: LD_INT 0
83629: PPUSH
// if not mc_bases or not base or not tech_list then
83630: LD_EXP 61
83634: NOT
83635: PUSH
83636: LD_VAR 0 1
83640: NOT
83641: OR
83642: PUSH
83643: LD_VAR 0 2
83647: NOT
83648: OR
83649: IFFALSE 83653
// exit ;
83651: GO 83678
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
83653: LD_ADDR_EXP 88
83657: PUSH
83658: LD_EXP 88
83662: PPUSH
83663: LD_VAR 0 1
83667: PPUSH
83668: LD_VAR 0 2
83672: PPUSH
83673: CALL_OW 1
83677: ST_TO_ADDR
// end ;
83678: LD_VAR 0 3
83682: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
83683: LD_INT 0
83685: PPUSH
// if not mc_bases or not parking_area or not base then
83686: LD_EXP 61
83690: NOT
83691: PUSH
83692: LD_VAR 0 2
83696: NOT
83697: OR
83698: PUSH
83699: LD_VAR 0 1
83703: NOT
83704: OR
83705: IFFALSE 83709
// exit ;
83707: GO 83734
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
83709: LD_ADDR_EXP 85
83713: PUSH
83714: LD_EXP 85
83718: PPUSH
83719: LD_VAR 0 1
83723: PPUSH
83724: LD_VAR 0 2
83728: PPUSH
83729: CALL_OW 1
83733: ST_TO_ADDR
// end ;
83734: LD_VAR 0 3
83738: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
83739: LD_INT 0
83741: PPUSH
// if not mc_bases or not base or not scan_area then
83742: LD_EXP 61
83746: NOT
83747: PUSH
83748: LD_VAR 0 1
83752: NOT
83753: OR
83754: PUSH
83755: LD_VAR 0 2
83759: NOT
83760: OR
83761: IFFALSE 83765
// exit ;
83763: GO 83790
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
83765: LD_ADDR_EXP 86
83769: PUSH
83770: LD_EXP 86
83774: PPUSH
83775: LD_VAR 0 1
83779: PPUSH
83780: LD_VAR 0 2
83784: PPUSH
83785: CALL_OW 1
83789: ST_TO_ADDR
// end ;
83790: LD_VAR 0 3
83794: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
83795: LD_INT 0
83797: PPUSH
83798: PPUSH
// if not mc_bases or not base then
83799: LD_EXP 61
83803: NOT
83804: PUSH
83805: LD_VAR 0 1
83809: NOT
83810: OR
83811: IFFALSE 83815
// exit ;
83813: GO 83879
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
83815: LD_ADDR_VAR 0 3
83819: PUSH
83820: LD_INT 1
83822: PUSH
83823: LD_INT 2
83825: PUSH
83826: LD_INT 3
83828: PUSH
83829: LD_INT 4
83831: PUSH
83832: LD_INT 11
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
83842: LD_ADDR_EXP 88
83846: PUSH
83847: LD_EXP 88
83851: PPUSH
83852: LD_VAR 0 1
83856: PPUSH
83857: LD_EXP 88
83861: PUSH
83862: LD_VAR 0 1
83866: ARRAY
83867: PUSH
83868: LD_VAR 0 3
83872: DIFF
83873: PPUSH
83874: CALL_OW 1
83878: ST_TO_ADDR
// end ;
83879: LD_VAR 0 2
83883: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
83884: LD_INT 0
83886: PPUSH
// result := mc_vehicles [ base ] ;
83887: LD_ADDR_VAR 0 3
83891: PUSH
83892: LD_EXP 80
83896: PUSH
83897: LD_VAR 0 1
83901: ARRAY
83902: ST_TO_ADDR
// if onlyCombat then
83903: LD_VAR 0 2
83907: IFFALSE 84079
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
83909: LD_ADDR_VAR 0 3
83913: PUSH
83914: LD_VAR 0 3
83918: PUSH
83919: LD_VAR 0 3
83923: PPUSH
83924: LD_INT 2
83926: PUSH
83927: LD_INT 34
83929: PUSH
83930: LD_INT 12
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: LD_INT 34
83939: PUSH
83940: LD_INT 51
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 34
83949: PUSH
83950: LD_INT 89
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 34
83959: PUSH
83960: LD_INT 32
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 34
83969: PUSH
83970: LD_INT 13
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: LD_INT 34
83979: PUSH
83980: LD_INT 52
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 34
83989: PUSH
83990: LD_INT 88
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 34
83999: PUSH
84000: LD_INT 14
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 34
84009: PUSH
84010: LD_INT 53
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 34
84019: PUSH
84020: LD_INT 98
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 34
84029: PUSH
84030: LD_INT 31
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 34
84039: PUSH
84040: LD_INT 48
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 34
84049: PUSH
84050: LD_INT 8
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: PPUSH
84073: CALL_OW 72
84077: DIFF
84078: ST_TO_ADDR
// end ; end_of_file
84079: LD_VAR 0 3
84083: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
84084: LD_INT 0
84086: PPUSH
84087: PPUSH
84088: PPUSH
// if not mc_bases or not skirmish then
84089: LD_EXP 61
84093: NOT
84094: PUSH
84095: LD_EXP 59
84099: NOT
84100: OR
84101: IFFALSE 84105
// exit ;
84103: GO 84270
// for i = 1 to mc_bases do
84105: LD_ADDR_VAR 0 4
84109: PUSH
84110: DOUBLE
84111: LD_INT 1
84113: DEC
84114: ST_TO_ADDR
84115: LD_EXP 61
84119: PUSH
84120: FOR_TO
84121: IFFALSE 84268
// begin if sci in mc_bases [ i ] then
84123: LD_VAR 0 2
84127: PUSH
84128: LD_EXP 61
84132: PUSH
84133: LD_VAR 0 4
84137: ARRAY
84138: IN
84139: IFFALSE 84266
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
84141: LD_ADDR_EXP 90
84145: PUSH
84146: LD_EXP 90
84150: PPUSH
84151: LD_VAR 0 4
84155: PUSH
84156: LD_EXP 90
84160: PUSH
84161: LD_VAR 0 4
84165: ARRAY
84166: PUSH
84167: LD_INT 1
84169: PLUS
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PPUSH
84175: LD_VAR 0 1
84179: PPUSH
84180: CALL 20981 0 3
84184: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
84185: LD_ADDR_VAR 0 5
84189: PUSH
84190: LD_EXP 61
84194: PUSH
84195: LD_VAR 0 4
84199: ARRAY
84200: PPUSH
84201: LD_INT 2
84203: PUSH
84204: LD_INT 30
84206: PUSH
84207: LD_INT 0
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 30
84216: PUSH
84217: LD_INT 1
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: LIST
84228: PPUSH
84229: CALL_OW 72
84233: PPUSH
84234: LD_VAR 0 1
84238: PPUSH
84239: CALL_OW 74
84243: ST_TO_ADDR
// if tmp then
84244: LD_VAR 0 5
84248: IFFALSE 84264
// ComStandNearbyBuilding ( ape , tmp ) ;
84250: LD_VAR 0 1
84254: PPUSH
84255: LD_VAR 0 5
84259: PPUSH
84260: CALL 17583 0 2
// break ;
84264: GO 84268
// end ; end ;
84266: GO 84120
84268: POP
84269: POP
// end ;
84270: LD_VAR 0 3
84274: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
84275: LD_INT 0
84277: PPUSH
84278: PPUSH
84279: PPUSH
// if not mc_bases or not skirmish then
84280: LD_EXP 61
84284: NOT
84285: PUSH
84286: LD_EXP 59
84290: NOT
84291: OR
84292: IFFALSE 84296
// exit ;
84294: GO 84385
// for i = 1 to mc_bases do
84296: LD_ADDR_VAR 0 4
84300: PUSH
84301: DOUBLE
84302: LD_INT 1
84304: DEC
84305: ST_TO_ADDR
84306: LD_EXP 61
84310: PUSH
84311: FOR_TO
84312: IFFALSE 84383
// begin if building in mc_busy_turret_list [ i ] then
84314: LD_VAR 0 1
84318: PUSH
84319: LD_EXP 71
84323: PUSH
84324: LD_VAR 0 4
84328: ARRAY
84329: IN
84330: IFFALSE 84381
// begin tmp := mc_busy_turret_list [ i ] diff building ;
84332: LD_ADDR_VAR 0 5
84336: PUSH
84337: LD_EXP 71
84341: PUSH
84342: LD_VAR 0 4
84346: ARRAY
84347: PUSH
84348: LD_VAR 0 1
84352: DIFF
84353: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
84354: LD_ADDR_EXP 71
84358: PUSH
84359: LD_EXP 71
84363: PPUSH
84364: LD_VAR 0 4
84368: PPUSH
84369: LD_VAR 0 5
84373: PPUSH
84374: CALL_OW 1
84378: ST_TO_ADDR
// break ;
84379: GO 84383
// end ; end ;
84381: GO 84311
84383: POP
84384: POP
// end ;
84385: LD_VAR 0 3
84389: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
84390: LD_INT 0
84392: PPUSH
84393: PPUSH
84394: PPUSH
// if not mc_bases or not skirmish then
84395: LD_EXP 61
84399: NOT
84400: PUSH
84401: LD_EXP 59
84405: NOT
84406: OR
84407: IFFALSE 84411
// exit ;
84409: GO 84610
// for i = 1 to mc_bases do
84411: LD_ADDR_VAR 0 5
84415: PUSH
84416: DOUBLE
84417: LD_INT 1
84419: DEC
84420: ST_TO_ADDR
84421: LD_EXP 61
84425: PUSH
84426: FOR_TO
84427: IFFALSE 84608
// if building in mc_bases [ i ] then
84429: LD_VAR 0 1
84433: PUSH
84434: LD_EXP 61
84438: PUSH
84439: LD_VAR 0 5
84443: ARRAY
84444: IN
84445: IFFALSE 84606
// begin tmp := mc_bases [ i ] diff building ;
84447: LD_ADDR_VAR 0 6
84451: PUSH
84452: LD_EXP 61
84456: PUSH
84457: LD_VAR 0 5
84461: ARRAY
84462: PUSH
84463: LD_VAR 0 1
84467: DIFF
84468: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
84469: LD_ADDR_EXP 61
84473: PUSH
84474: LD_EXP 61
84478: PPUSH
84479: LD_VAR 0 5
84483: PPUSH
84484: LD_VAR 0 6
84488: PPUSH
84489: CALL_OW 1
84493: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
84494: LD_VAR 0 1
84498: PUSH
84499: LD_EXP 69
84503: PUSH
84504: LD_VAR 0 5
84508: ARRAY
84509: IN
84510: IFFALSE 84549
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
84512: LD_ADDR_EXP 69
84516: PUSH
84517: LD_EXP 69
84521: PPUSH
84522: LD_VAR 0 5
84526: PPUSH
84527: LD_EXP 69
84531: PUSH
84532: LD_VAR 0 5
84536: ARRAY
84537: PUSH
84538: LD_VAR 0 1
84542: DIFF
84543: PPUSH
84544: CALL_OW 1
84548: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
84549: LD_VAR 0 1
84553: PUSH
84554: LD_EXP 70
84558: PUSH
84559: LD_VAR 0 5
84563: ARRAY
84564: IN
84565: IFFALSE 84604
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
84567: LD_ADDR_EXP 70
84571: PUSH
84572: LD_EXP 70
84576: PPUSH
84577: LD_VAR 0 5
84581: PPUSH
84582: LD_EXP 70
84586: PUSH
84587: LD_VAR 0 5
84591: ARRAY
84592: PUSH
84593: LD_VAR 0 1
84597: DIFF
84598: PPUSH
84599: CALL_OW 1
84603: ST_TO_ADDR
// break ;
84604: GO 84608
// end ;
84606: GO 84426
84608: POP
84609: POP
// end ;
84610: LD_VAR 0 4
84614: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
84615: LD_INT 0
84617: PPUSH
84618: PPUSH
84619: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
84620: LD_EXP 61
84624: NOT
84625: PUSH
84626: LD_EXP 59
84630: NOT
84631: OR
84632: PUSH
84633: LD_VAR 0 3
84637: PUSH
84638: LD_EXP 87
84642: IN
84643: NOT
84644: OR
84645: IFFALSE 84649
// exit ;
84647: GO 84772
// for i = 1 to mc_vehicles do
84649: LD_ADDR_VAR 0 6
84653: PUSH
84654: DOUBLE
84655: LD_INT 1
84657: DEC
84658: ST_TO_ADDR
84659: LD_EXP 80
84663: PUSH
84664: FOR_TO
84665: IFFALSE 84770
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
84667: LD_VAR 0 2
84671: PUSH
84672: LD_EXP 80
84676: PUSH
84677: LD_VAR 0 6
84681: ARRAY
84682: IN
84683: PUSH
84684: LD_VAR 0 1
84688: PUSH
84689: LD_EXP 80
84693: PUSH
84694: LD_VAR 0 6
84698: ARRAY
84699: IN
84700: OR
84701: IFFALSE 84768
// begin tmp := mc_vehicles [ i ] diff old ;
84703: LD_ADDR_VAR 0 7
84707: PUSH
84708: LD_EXP 80
84712: PUSH
84713: LD_VAR 0 6
84717: ARRAY
84718: PUSH
84719: LD_VAR 0 2
84723: DIFF
84724: ST_TO_ADDR
// tmp := tmp diff new ;
84725: LD_ADDR_VAR 0 7
84729: PUSH
84730: LD_VAR 0 7
84734: PUSH
84735: LD_VAR 0 1
84739: DIFF
84740: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
84741: LD_ADDR_EXP 80
84745: PUSH
84746: LD_EXP 80
84750: PPUSH
84751: LD_VAR 0 6
84755: PPUSH
84756: LD_VAR 0 7
84760: PPUSH
84761: CALL_OW 1
84765: ST_TO_ADDR
// break ;
84766: GO 84770
// end ;
84768: GO 84664
84770: POP
84771: POP
// end ;
84772: LD_VAR 0 5
84776: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
84777: LD_INT 0
84779: PPUSH
84780: PPUSH
84781: PPUSH
84782: PPUSH
// if not mc_bases or not skirmish then
84783: LD_EXP 61
84787: NOT
84788: PUSH
84789: LD_EXP 59
84793: NOT
84794: OR
84795: IFFALSE 84799
// exit ;
84797: GO 85219
// repeat wait ( 0 0$1 ) ;
84799: LD_INT 35
84801: PPUSH
84802: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
84806: LD_EXP 105
84810: NOT
84811: IFFALSE 84799
// mc_block_vehicle_constructed_thread := true ;
84813: LD_ADDR_EXP 105
84817: PUSH
84818: LD_INT 1
84820: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
84821: LD_ADDR_VAR 0 5
84825: PUSH
84826: LD_VAR 0 1
84830: PPUSH
84831: CALL_OW 255
84835: ST_TO_ADDR
// for i = 1 to mc_bases do
84836: LD_ADDR_VAR 0 4
84840: PUSH
84841: DOUBLE
84842: LD_INT 1
84844: DEC
84845: ST_TO_ADDR
84846: LD_EXP 61
84850: PUSH
84851: FOR_TO
84852: IFFALSE 85209
// begin if factory in mc_bases [ i ] then
84854: LD_VAR 0 2
84858: PUSH
84859: LD_EXP 61
84863: PUSH
84864: LD_VAR 0 4
84868: ARRAY
84869: IN
84870: IFFALSE 85207
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
84872: LD_EXP 83
84876: PUSH
84877: LD_VAR 0 4
84881: ARRAY
84882: PUSH
84883: LD_EXP 72
84887: PUSH
84888: LD_VAR 0 4
84892: ARRAY
84893: LESS
84894: PUSH
84895: LD_VAR 0 1
84899: PPUSH
84900: CALL_OW 264
84904: PUSH
84905: LD_INT 31
84907: PUSH
84908: LD_INT 32
84910: PUSH
84911: LD_INT 51
84913: PUSH
84914: LD_INT 89
84916: PUSH
84917: LD_INT 12
84919: PUSH
84920: LD_INT 30
84922: PUSH
84923: LD_INT 98
84925: PUSH
84926: LD_INT 11
84928: PUSH
84929: LD_INT 53
84931: PUSH
84932: LD_INT 14
84934: PUSH
84935: LD_INT 91
84937: PUSH
84938: LD_INT 29
84940: PUSH
84941: LD_INT 99
84943: PUSH
84944: LD_INT 13
84946: PUSH
84947: LD_INT 52
84949: PUSH
84950: LD_INT 88
84952: PUSH
84953: LD_INT 48
84955: PUSH
84956: LD_INT 8
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: IN
84979: NOT
84980: AND
84981: IFFALSE 85029
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
84983: LD_ADDR_EXP 83
84987: PUSH
84988: LD_EXP 83
84992: PPUSH
84993: LD_VAR 0 4
84997: PUSH
84998: LD_EXP 83
85002: PUSH
85003: LD_VAR 0 4
85007: ARRAY
85008: PUSH
85009: LD_INT 1
85011: PLUS
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PPUSH
85017: LD_VAR 0 1
85021: PPUSH
85022: CALL 20981 0 3
85026: ST_TO_ADDR
85027: GO 85073
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
85029: LD_ADDR_EXP 80
85033: PUSH
85034: LD_EXP 80
85038: PPUSH
85039: LD_VAR 0 4
85043: PUSH
85044: LD_EXP 80
85048: PUSH
85049: LD_VAR 0 4
85053: ARRAY
85054: PUSH
85055: LD_INT 1
85057: PLUS
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PPUSH
85063: LD_VAR 0 1
85067: PPUSH
85068: CALL 20981 0 3
85072: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
85073: LD_ADDR_EXP 105
85077: PUSH
85078: LD_INT 0
85080: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
85081: LD_VAR 0 1
85085: PPUSH
85086: CALL_OW 263
85090: PUSH
85091: LD_INT 2
85093: EQUAL
85094: IFFALSE 85123
// begin repeat wait ( 0 0$3 ) ;
85096: LD_INT 105
85098: PPUSH
85099: CALL_OW 67
// Connect ( vehicle ) ;
85103: LD_VAR 0 1
85107: PPUSH
85108: CALL 24327 0 1
// until IsControledBy ( vehicle ) ;
85112: LD_VAR 0 1
85116: PPUSH
85117: CALL_OW 312
85121: IFFALSE 85096
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
85123: LD_VAR 0 1
85127: PPUSH
85128: LD_EXP 85
85132: PUSH
85133: LD_VAR 0 4
85137: ARRAY
85138: PPUSH
85139: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
85143: LD_VAR 0 1
85147: PPUSH
85148: CALL_OW 263
85152: PUSH
85153: LD_INT 1
85155: NONEQUAL
85156: IFFALSE 85160
// break ;
85158: GO 85209
// repeat wait ( 0 0$1 ) ;
85160: LD_INT 35
85162: PPUSH
85163: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
85167: LD_VAR 0 1
85171: PPUSH
85172: LD_EXP 85
85176: PUSH
85177: LD_VAR 0 4
85181: ARRAY
85182: PPUSH
85183: CALL_OW 308
85187: IFFALSE 85160
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
85189: LD_VAR 0 1
85193: PPUSH
85194: CALL_OW 311
85198: PPUSH
85199: CALL_OW 121
// exit ;
85203: POP
85204: POP
85205: GO 85219
// end ; end ;
85207: GO 84851
85209: POP
85210: POP
// mc_block_vehicle_constructed_thread := false ;
85211: LD_ADDR_EXP 105
85215: PUSH
85216: LD_INT 0
85218: ST_TO_ADDR
// end ;
85219: LD_VAR 0 3
85223: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
85224: LD_INT 0
85226: PPUSH
85227: PPUSH
85228: PPUSH
85229: PPUSH
// if not mc_bases or not skirmish then
85230: LD_EXP 61
85234: NOT
85235: PUSH
85236: LD_EXP 59
85240: NOT
85241: OR
85242: IFFALSE 85246
// exit ;
85244: GO 85599
// repeat wait ( 0 0$1 ) ;
85246: LD_INT 35
85248: PPUSH
85249: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
85253: LD_VAR 0 2
85257: PPUSH
85258: LD_VAR 0 3
85262: PPUSH
85263: CALL_OW 284
85267: IFFALSE 85246
// if GetResourceTypeXY ( x , y ) = mat_artefact then
85269: LD_VAR 0 2
85273: PPUSH
85274: LD_VAR 0 3
85278: PPUSH
85279: CALL_OW 283
85283: PUSH
85284: LD_INT 4
85286: EQUAL
85287: IFFALSE 85291
// exit ;
85289: GO 85599
// for i = 1 to mc_bases do
85291: LD_ADDR_VAR 0 7
85295: PUSH
85296: DOUBLE
85297: LD_INT 1
85299: DEC
85300: ST_TO_ADDR
85301: LD_EXP 61
85305: PUSH
85306: FOR_TO
85307: IFFALSE 85597
// begin if mc_crates_area [ i ] then
85309: LD_EXP 79
85313: PUSH
85314: LD_VAR 0 7
85318: ARRAY
85319: IFFALSE 85430
// for j in mc_crates_area [ i ] do
85321: LD_ADDR_VAR 0 8
85325: PUSH
85326: LD_EXP 79
85330: PUSH
85331: LD_VAR 0 7
85335: ARRAY
85336: PUSH
85337: FOR_IN
85338: IFFALSE 85428
// if InArea ( x , y , j ) then
85340: LD_VAR 0 2
85344: PPUSH
85345: LD_VAR 0 3
85349: PPUSH
85350: LD_VAR 0 8
85354: PPUSH
85355: CALL_OW 309
85359: IFFALSE 85426
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
85361: LD_ADDR_EXP 77
85365: PUSH
85366: LD_EXP 77
85370: PPUSH
85371: LD_VAR 0 7
85375: PUSH
85376: LD_EXP 77
85380: PUSH
85381: LD_VAR 0 7
85385: ARRAY
85386: PUSH
85387: LD_INT 1
85389: PLUS
85390: PUSH
85391: EMPTY
85392: LIST
85393: LIST
85394: PPUSH
85395: LD_VAR 0 4
85399: PUSH
85400: LD_VAR 0 2
85404: PUSH
85405: LD_VAR 0 3
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: LIST
85414: PPUSH
85415: CALL 20981 0 3
85419: ST_TO_ADDR
// exit ;
85420: POP
85421: POP
85422: POP
85423: POP
85424: GO 85599
// end ;
85426: GO 85337
85428: POP
85429: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85430: LD_ADDR_VAR 0 9
85434: PUSH
85435: LD_EXP 61
85439: PUSH
85440: LD_VAR 0 7
85444: ARRAY
85445: PPUSH
85446: LD_INT 2
85448: PUSH
85449: LD_INT 30
85451: PUSH
85452: LD_INT 0
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 30
85461: PUSH
85462: LD_INT 1
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: LIST
85473: PPUSH
85474: CALL_OW 72
85478: ST_TO_ADDR
// if not depot then
85479: LD_VAR 0 9
85483: NOT
85484: IFFALSE 85488
// continue ;
85486: GO 85306
// for j in depot do
85488: LD_ADDR_VAR 0 8
85492: PUSH
85493: LD_VAR 0 9
85497: PUSH
85498: FOR_IN
85499: IFFALSE 85593
// if GetDistUnitXY ( j , x , y ) < 30 then
85501: LD_VAR 0 8
85505: PPUSH
85506: LD_VAR 0 2
85510: PPUSH
85511: LD_VAR 0 3
85515: PPUSH
85516: CALL_OW 297
85520: PUSH
85521: LD_INT 30
85523: LESS
85524: IFFALSE 85591
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
85526: LD_ADDR_EXP 77
85530: PUSH
85531: LD_EXP 77
85535: PPUSH
85536: LD_VAR 0 7
85540: PUSH
85541: LD_EXP 77
85545: PUSH
85546: LD_VAR 0 7
85550: ARRAY
85551: PUSH
85552: LD_INT 1
85554: PLUS
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PPUSH
85560: LD_VAR 0 4
85564: PUSH
85565: LD_VAR 0 2
85569: PUSH
85570: LD_VAR 0 3
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: LIST
85579: PPUSH
85580: CALL 20981 0 3
85584: ST_TO_ADDR
// exit ;
85585: POP
85586: POP
85587: POP
85588: POP
85589: GO 85599
// end ;
85591: GO 85498
85593: POP
85594: POP
// end ;
85595: GO 85306
85597: POP
85598: POP
// end ;
85599: LD_VAR 0 6
85603: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
85604: LD_INT 0
85606: PPUSH
85607: PPUSH
85608: PPUSH
85609: PPUSH
// if not mc_bases or not skirmish then
85610: LD_EXP 61
85614: NOT
85615: PUSH
85616: LD_EXP 59
85620: NOT
85621: OR
85622: IFFALSE 85626
// exit ;
85624: GO 85903
// side := GetSide ( lab ) ;
85626: LD_ADDR_VAR 0 4
85630: PUSH
85631: LD_VAR 0 2
85635: PPUSH
85636: CALL_OW 255
85640: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
85641: LD_VAR 0 4
85645: PUSH
85646: LD_EXP 87
85650: IN
85651: NOT
85652: PUSH
85653: LD_EXP 88
85657: NOT
85658: OR
85659: PUSH
85660: LD_EXP 61
85664: NOT
85665: OR
85666: IFFALSE 85670
// exit ;
85668: GO 85903
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
85670: LD_ADDR_EXP 88
85674: PUSH
85675: LD_EXP 88
85679: PPUSH
85680: LD_VAR 0 4
85684: PPUSH
85685: LD_EXP 88
85689: PUSH
85690: LD_VAR 0 4
85694: ARRAY
85695: PUSH
85696: LD_VAR 0 1
85700: DIFF
85701: PPUSH
85702: CALL_OW 1
85706: ST_TO_ADDR
// for i = 1 to mc_bases do
85707: LD_ADDR_VAR 0 5
85711: PUSH
85712: DOUBLE
85713: LD_INT 1
85715: DEC
85716: ST_TO_ADDR
85717: LD_EXP 61
85721: PUSH
85722: FOR_TO
85723: IFFALSE 85901
// begin if lab in mc_bases [ i ] then
85725: LD_VAR 0 2
85729: PUSH
85730: LD_EXP 61
85734: PUSH
85735: LD_VAR 0 5
85739: ARRAY
85740: IN
85741: IFFALSE 85899
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
85743: LD_VAR 0 1
85747: PUSH
85748: LD_INT 11
85750: PUSH
85751: LD_INT 4
85753: PUSH
85754: LD_INT 3
85756: PUSH
85757: LD_INT 2
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: IN
85766: PUSH
85767: LD_EXP 91
85771: PUSH
85772: LD_VAR 0 5
85776: ARRAY
85777: AND
85778: IFFALSE 85899
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
85780: LD_ADDR_VAR 0 6
85784: PUSH
85785: LD_EXP 91
85789: PUSH
85790: LD_VAR 0 5
85794: ARRAY
85795: PUSH
85796: LD_INT 1
85798: ARRAY
85799: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
85800: LD_ADDR_EXP 91
85804: PUSH
85805: LD_EXP 91
85809: PPUSH
85810: LD_VAR 0 5
85814: PPUSH
85815: EMPTY
85816: PPUSH
85817: CALL_OW 1
85821: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
85822: LD_VAR 0 6
85826: PPUSH
85827: LD_INT 0
85829: PPUSH
85830: CALL_OW 109
// ComExitBuilding ( tmp ) ;
85834: LD_VAR 0 6
85838: PPUSH
85839: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
85843: LD_ADDR_EXP 90
85847: PUSH
85848: LD_EXP 90
85852: PPUSH
85853: LD_VAR 0 5
85857: PPUSH
85858: LD_EXP 90
85862: PUSH
85863: LD_VAR 0 5
85867: ARRAY
85868: PPUSH
85869: LD_INT 1
85871: PPUSH
85872: LD_VAR 0 6
85876: PPUSH
85877: CALL_OW 2
85881: PPUSH
85882: CALL_OW 1
85886: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
85887: LD_VAR 0 5
85891: PPUSH
85892: LD_INT 112
85894: PPUSH
85895: CALL 62353 0 2
// end ; end ; end ;
85899: GO 85722
85901: POP
85902: POP
// end ;
85903: LD_VAR 0 3
85907: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
85908: LD_INT 0
85910: PPUSH
85911: PPUSH
85912: PPUSH
85913: PPUSH
85914: PPUSH
85915: PPUSH
85916: PPUSH
85917: PPUSH
// if not mc_bases or not skirmish then
85918: LD_EXP 61
85922: NOT
85923: PUSH
85924: LD_EXP 59
85928: NOT
85929: OR
85930: IFFALSE 85934
// exit ;
85932: GO 87303
// for i = 1 to mc_bases do
85934: LD_ADDR_VAR 0 3
85938: PUSH
85939: DOUBLE
85940: LD_INT 1
85942: DEC
85943: ST_TO_ADDR
85944: LD_EXP 61
85948: PUSH
85949: FOR_TO
85950: IFFALSE 87301
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
85952: LD_VAR 0 1
85956: PUSH
85957: LD_EXP 61
85961: PUSH
85962: LD_VAR 0 3
85966: ARRAY
85967: IN
85968: PUSH
85969: LD_VAR 0 1
85973: PUSH
85974: LD_EXP 68
85978: PUSH
85979: LD_VAR 0 3
85983: ARRAY
85984: IN
85985: OR
85986: PUSH
85987: LD_VAR 0 1
85991: PUSH
85992: LD_EXP 83
85996: PUSH
85997: LD_VAR 0 3
86001: ARRAY
86002: IN
86003: OR
86004: PUSH
86005: LD_VAR 0 1
86009: PUSH
86010: LD_EXP 80
86014: PUSH
86015: LD_VAR 0 3
86019: ARRAY
86020: IN
86021: OR
86022: PUSH
86023: LD_VAR 0 1
86027: PUSH
86028: LD_EXP 90
86032: PUSH
86033: LD_VAR 0 3
86037: ARRAY
86038: IN
86039: OR
86040: PUSH
86041: LD_VAR 0 1
86045: PUSH
86046: LD_EXP 91
86050: PUSH
86051: LD_VAR 0 3
86055: ARRAY
86056: IN
86057: OR
86058: IFFALSE 87299
// begin if un in mc_ape [ i ] then
86060: LD_VAR 0 1
86064: PUSH
86065: LD_EXP 90
86069: PUSH
86070: LD_VAR 0 3
86074: ARRAY
86075: IN
86076: IFFALSE 86115
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
86078: LD_ADDR_EXP 90
86082: PUSH
86083: LD_EXP 90
86087: PPUSH
86088: LD_VAR 0 3
86092: PPUSH
86093: LD_EXP 90
86097: PUSH
86098: LD_VAR 0 3
86102: ARRAY
86103: PUSH
86104: LD_VAR 0 1
86108: DIFF
86109: PPUSH
86110: CALL_OW 1
86114: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
86115: LD_VAR 0 1
86119: PUSH
86120: LD_EXP 91
86124: PUSH
86125: LD_VAR 0 3
86129: ARRAY
86130: IN
86131: IFFALSE 86155
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
86133: LD_ADDR_EXP 91
86137: PUSH
86138: LD_EXP 91
86142: PPUSH
86143: LD_VAR 0 3
86147: PPUSH
86148: EMPTY
86149: PPUSH
86150: CALL_OW 1
86154: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
86155: LD_VAR 0 1
86159: PPUSH
86160: CALL_OW 247
86164: PUSH
86165: LD_INT 2
86167: EQUAL
86168: PUSH
86169: LD_VAR 0 1
86173: PPUSH
86174: CALL_OW 110
86178: PUSH
86179: LD_INT 20
86181: EQUAL
86182: PUSH
86183: LD_VAR 0 1
86187: PUSH
86188: LD_EXP 83
86192: PUSH
86193: LD_VAR 0 3
86197: ARRAY
86198: IN
86199: OR
86200: PUSH
86201: LD_VAR 0 1
86205: PPUSH
86206: CALL_OW 264
86210: PUSH
86211: LD_INT 12
86213: PUSH
86214: LD_INT 51
86216: PUSH
86217: LD_INT 89
86219: PUSH
86220: LD_INT 32
86222: PUSH
86223: LD_INT 13
86225: PUSH
86226: LD_INT 52
86228: PUSH
86229: LD_INT 31
86231: PUSH
86232: EMPTY
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: IN
86241: OR
86242: AND
86243: IFFALSE 86551
// begin if un in mc_defender [ i ] then
86245: LD_VAR 0 1
86249: PUSH
86250: LD_EXP 83
86254: PUSH
86255: LD_VAR 0 3
86259: ARRAY
86260: IN
86261: IFFALSE 86300
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
86263: LD_ADDR_EXP 83
86267: PUSH
86268: LD_EXP 83
86272: PPUSH
86273: LD_VAR 0 3
86277: PPUSH
86278: LD_EXP 83
86282: PUSH
86283: LD_VAR 0 3
86287: ARRAY
86288: PUSH
86289: LD_VAR 0 1
86293: DIFF
86294: PPUSH
86295: CALL_OW 1
86299: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
86300: LD_ADDR_VAR 0 8
86304: PUSH
86305: LD_VAR 0 3
86309: PPUSH
86310: LD_INT 3
86312: PPUSH
86313: CALL 82921 0 2
86317: ST_TO_ADDR
// if fac then
86318: LD_VAR 0 8
86322: IFFALSE 86551
// begin for j in fac do
86324: LD_ADDR_VAR 0 4
86328: PUSH
86329: LD_VAR 0 8
86333: PUSH
86334: FOR_IN
86335: IFFALSE 86549
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
86337: LD_ADDR_VAR 0 9
86341: PUSH
86342: LD_VAR 0 8
86346: PPUSH
86347: LD_VAR 0 1
86351: PPUSH
86352: CALL_OW 265
86356: PPUSH
86357: LD_VAR 0 1
86361: PPUSH
86362: CALL_OW 262
86366: PPUSH
86367: LD_VAR 0 1
86371: PPUSH
86372: CALL_OW 263
86376: PPUSH
86377: LD_VAR 0 1
86381: PPUSH
86382: CALL_OW 264
86386: PPUSH
86387: CALL 18479 0 5
86391: ST_TO_ADDR
// if components then
86392: LD_VAR 0 9
86396: IFFALSE 86547
// begin if GetWeapon ( un ) = ar_control_tower then
86398: LD_VAR 0 1
86402: PPUSH
86403: CALL_OW 264
86407: PUSH
86408: LD_INT 31
86410: EQUAL
86411: IFFALSE 86528
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
86413: LD_VAR 0 1
86417: PPUSH
86418: CALL_OW 311
86422: PPUSH
86423: LD_INT 0
86425: PPUSH
86426: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
86430: LD_ADDR_EXP 101
86434: PUSH
86435: LD_EXP 101
86439: PPUSH
86440: LD_VAR 0 3
86444: PPUSH
86445: LD_EXP 101
86449: PUSH
86450: LD_VAR 0 3
86454: ARRAY
86455: PUSH
86456: LD_VAR 0 1
86460: PPUSH
86461: CALL_OW 311
86465: DIFF
86466: PPUSH
86467: CALL_OW 1
86471: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
86472: LD_ADDR_VAR 0 7
86476: PUSH
86477: LD_EXP 82
86481: PUSH
86482: LD_VAR 0 3
86486: ARRAY
86487: PPUSH
86488: LD_INT 1
86490: PPUSH
86491: LD_VAR 0 9
86495: PPUSH
86496: CALL_OW 2
86500: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
86501: LD_ADDR_EXP 82
86505: PUSH
86506: LD_EXP 82
86510: PPUSH
86511: LD_VAR 0 3
86515: PPUSH
86516: LD_VAR 0 7
86520: PPUSH
86521: CALL_OW 1
86525: ST_TO_ADDR
// end else
86526: GO 86545
// MC_InsertProduceList ( i , [ components ] ) ;
86528: LD_VAR 0 3
86532: PPUSH
86533: LD_VAR 0 9
86537: PUSH
86538: EMPTY
86539: LIST
86540: PPUSH
86541: CALL 82466 0 2
// break ;
86545: GO 86549
// end ; end ;
86547: GO 86334
86549: POP
86550: POP
// end ; end ; if GetType ( un ) = unit_building then
86551: LD_VAR 0 1
86555: PPUSH
86556: CALL_OW 247
86560: PUSH
86561: LD_INT 3
86563: EQUAL
86564: IFFALSE 86967
// begin btype := GetBType ( un ) ;
86566: LD_ADDR_VAR 0 5
86570: PUSH
86571: LD_VAR 0 1
86575: PPUSH
86576: CALL_OW 266
86580: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
86581: LD_VAR 0 5
86585: PUSH
86586: LD_INT 29
86588: PUSH
86589: LD_INT 30
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: IN
86596: IFFALSE 86669
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
86598: LD_VAR 0 1
86602: PPUSH
86603: CALL_OW 250
86607: PPUSH
86608: LD_VAR 0 1
86612: PPUSH
86613: CALL_OW 251
86617: PPUSH
86618: LD_VAR 0 1
86622: PPUSH
86623: CALL_OW 255
86627: PPUSH
86628: CALL_OW 440
86632: NOT
86633: IFFALSE 86669
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
86635: LD_VAR 0 1
86639: PPUSH
86640: CALL_OW 250
86644: PPUSH
86645: LD_VAR 0 1
86649: PPUSH
86650: CALL_OW 251
86654: PPUSH
86655: LD_VAR 0 1
86659: PPUSH
86660: CALL_OW 255
86664: PPUSH
86665: CALL_OW 441
// end ; if btype = b_warehouse then
86669: LD_VAR 0 5
86673: PUSH
86674: LD_INT 1
86676: EQUAL
86677: IFFALSE 86695
// begin btype := b_depot ;
86679: LD_ADDR_VAR 0 5
86683: PUSH
86684: LD_INT 0
86686: ST_TO_ADDR
// pos := 1 ;
86687: LD_ADDR_VAR 0 6
86691: PUSH
86692: LD_INT 1
86694: ST_TO_ADDR
// end ; if btype = b_factory then
86695: LD_VAR 0 5
86699: PUSH
86700: LD_INT 3
86702: EQUAL
86703: IFFALSE 86721
// begin btype := b_workshop ;
86705: LD_ADDR_VAR 0 5
86709: PUSH
86710: LD_INT 2
86712: ST_TO_ADDR
// pos := 1 ;
86713: LD_ADDR_VAR 0 6
86717: PUSH
86718: LD_INT 1
86720: ST_TO_ADDR
// end ; if btype = b_barracks then
86721: LD_VAR 0 5
86725: PUSH
86726: LD_INT 5
86728: EQUAL
86729: IFFALSE 86739
// btype := b_armoury ;
86731: LD_ADDR_VAR 0 5
86735: PUSH
86736: LD_INT 4
86738: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
86739: LD_VAR 0 5
86743: PUSH
86744: LD_INT 7
86746: PUSH
86747: LD_INT 8
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: IN
86754: IFFALSE 86764
// btype := b_lab ;
86756: LD_ADDR_VAR 0 5
86760: PUSH
86761: LD_INT 6
86763: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
86764: LD_ADDR_EXP 66
86768: PUSH
86769: LD_EXP 66
86773: PPUSH
86774: LD_VAR 0 3
86778: PUSH
86779: LD_EXP 66
86783: PUSH
86784: LD_VAR 0 3
86788: ARRAY
86789: PUSH
86790: LD_INT 1
86792: PLUS
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PPUSH
86798: LD_VAR 0 5
86802: PUSH
86803: LD_VAR 0 1
86807: PPUSH
86808: CALL_OW 250
86812: PUSH
86813: LD_VAR 0 1
86817: PPUSH
86818: CALL_OW 251
86822: PUSH
86823: LD_VAR 0 1
86827: PPUSH
86828: CALL_OW 254
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: PPUSH
86839: CALL 20981 0 3
86843: ST_TO_ADDR
// if pos = 1 then
86844: LD_VAR 0 6
86848: PUSH
86849: LD_INT 1
86851: EQUAL
86852: IFFALSE 86967
// begin tmp := mc_build_list [ i ] ;
86854: LD_ADDR_VAR 0 7
86858: PUSH
86859: LD_EXP 66
86863: PUSH
86864: LD_VAR 0 3
86868: ARRAY
86869: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
86870: LD_VAR 0 7
86874: PPUSH
86875: LD_INT 2
86877: PUSH
86878: LD_INT 30
86880: PUSH
86881: LD_INT 0
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 30
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: LIST
86902: PPUSH
86903: CALL_OW 72
86907: IFFALSE 86917
// pos := 2 ;
86909: LD_ADDR_VAR 0 6
86913: PUSH
86914: LD_INT 2
86916: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
86917: LD_ADDR_VAR 0 7
86921: PUSH
86922: LD_VAR 0 7
86926: PPUSH
86927: LD_VAR 0 6
86931: PPUSH
86932: LD_VAR 0 7
86936: PPUSH
86937: CALL 21307 0 3
86941: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
86942: LD_ADDR_EXP 66
86946: PUSH
86947: LD_EXP 66
86951: PPUSH
86952: LD_VAR 0 3
86956: PPUSH
86957: LD_VAR 0 7
86961: PPUSH
86962: CALL_OW 1
86966: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
86967: LD_VAR 0 1
86971: PUSH
86972: LD_EXP 61
86976: PUSH
86977: LD_VAR 0 3
86981: ARRAY
86982: IN
86983: IFFALSE 87022
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
86985: LD_ADDR_EXP 61
86989: PUSH
86990: LD_EXP 61
86994: PPUSH
86995: LD_VAR 0 3
86999: PPUSH
87000: LD_EXP 61
87004: PUSH
87005: LD_VAR 0 3
87009: ARRAY
87010: PUSH
87011: LD_VAR 0 1
87015: DIFF
87016: PPUSH
87017: CALL_OW 1
87021: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
87022: LD_VAR 0 1
87026: PUSH
87027: LD_EXP 68
87031: PUSH
87032: LD_VAR 0 3
87036: ARRAY
87037: IN
87038: IFFALSE 87077
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
87040: LD_ADDR_EXP 68
87044: PUSH
87045: LD_EXP 68
87049: PPUSH
87050: LD_VAR 0 3
87054: PPUSH
87055: LD_EXP 68
87059: PUSH
87060: LD_VAR 0 3
87064: ARRAY
87065: PUSH
87066: LD_VAR 0 1
87070: DIFF
87071: PPUSH
87072: CALL_OW 1
87076: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
87077: LD_VAR 0 1
87081: PUSH
87082: LD_EXP 80
87086: PUSH
87087: LD_VAR 0 3
87091: ARRAY
87092: IN
87093: IFFALSE 87132
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
87095: LD_ADDR_EXP 80
87099: PUSH
87100: LD_EXP 80
87104: PPUSH
87105: LD_VAR 0 3
87109: PPUSH
87110: LD_EXP 80
87114: PUSH
87115: LD_VAR 0 3
87119: ARRAY
87120: PUSH
87121: LD_VAR 0 1
87125: DIFF
87126: PPUSH
87127: CALL_OW 1
87131: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
87132: LD_VAR 0 1
87136: PUSH
87137: LD_EXP 83
87141: PUSH
87142: LD_VAR 0 3
87146: ARRAY
87147: IN
87148: IFFALSE 87187
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
87150: LD_ADDR_EXP 83
87154: PUSH
87155: LD_EXP 83
87159: PPUSH
87160: LD_VAR 0 3
87164: PPUSH
87165: LD_EXP 83
87169: PUSH
87170: LD_VAR 0 3
87174: ARRAY
87175: PUSH
87176: LD_VAR 0 1
87180: DIFF
87181: PPUSH
87182: CALL_OW 1
87186: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
87187: LD_VAR 0 1
87191: PUSH
87192: LD_EXP 70
87196: PUSH
87197: LD_VAR 0 3
87201: ARRAY
87202: IN
87203: IFFALSE 87242
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
87205: LD_ADDR_EXP 70
87209: PUSH
87210: LD_EXP 70
87214: PPUSH
87215: LD_VAR 0 3
87219: PPUSH
87220: LD_EXP 70
87224: PUSH
87225: LD_VAR 0 3
87229: ARRAY
87230: PUSH
87231: LD_VAR 0 1
87235: DIFF
87236: PPUSH
87237: CALL_OW 1
87241: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
87242: LD_VAR 0 1
87246: PUSH
87247: LD_EXP 69
87251: PUSH
87252: LD_VAR 0 3
87256: ARRAY
87257: IN
87258: IFFALSE 87297
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
87260: LD_ADDR_EXP 69
87264: PUSH
87265: LD_EXP 69
87269: PPUSH
87270: LD_VAR 0 3
87274: PPUSH
87275: LD_EXP 69
87279: PUSH
87280: LD_VAR 0 3
87284: ARRAY
87285: PUSH
87286: LD_VAR 0 1
87290: DIFF
87291: PPUSH
87292: CALL_OW 1
87296: ST_TO_ADDR
// end ; break ;
87297: GO 87301
// end ;
87299: GO 85949
87301: POP
87302: POP
// end ;
87303: LD_VAR 0 2
87307: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
87308: LD_INT 0
87310: PPUSH
87311: PPUSH
87312: PPUSH
// if not mc_bases or not skirmish then
87313: LD_EXP 61
87317: NOT
87318: PUSH
87319: LD_EXP 59
87323: NOT
87324: OR
87325: IFFALSE 87329
// exit ;
87327: GO 87544
// for i = 1 to mc_bases do
87329: LD_ADDR_VAR 0 3
87333: PUSH
87334: DOUBLE
87335: LD_INT 1
87337: DEC
87338: ST_TO_ADDR
87339: LD_EXP 61
87343: PUSH
87344: FOR_TO
87345: IFFALSE 87542
// begin if building in mc_construct_list [ i ] then
87347: LD_VAR 0 1
87351: PUSH
87352: LD_EXP 68
87356: PUSH
87357: LD_VAR 0 3
87361: ARRAY
87362: IN
87363: IFFALSE 87540
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
87365: LD_ADDR_EXP 68
87369: PUSH
87370: LD_EXP 68
87374: PPUSH
87375: LD_VAR 0 3
87379: PPUSH
87380: LD_EXP 68
87384: PUSH
87385: LD_VAR 0 3
87389: ARRAY
87390: PUSH
87391: LD_VAR 0 1
87395: DIFF
87396: PPUSH
87397: CALL_OW 1
87401: ST_TO_ADDR
// if building in mc_lab [ i ] then
87402: LD_VAR 0 1
87406: PUSH
87407: LD_EXP 94
87411: PUSH
87412: LD_VAR 0 3
87416: ARRAY
87417: IN
87418: IFFALSE 87473
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
87420: LD_ADDR_EXP 95
87424: PUSH
87425: LD_EXP 95
87429: PPUSH
87430: LD_VAR 0 3
87434: PPUSH
87435: LD_EXP 95
87439: PUSH
87440: LD_VAR 0 3
87444: ARRAY
87445: PPUSH
87446: LD_INT 1
87448: PPUSH
87449: LD_EXP 95
87453: PUSH
87454: LD_VAR 0 3
87458: ARRAY
87459: PPUSH
87460: LD_INT 0
87462: PPUSH
87463: CALL 20399 0 4
87467: PPUSH
87468: CALL_OW 1
87472: ST_TO_ADDR
// if not building in mc_bases [ i ] then
87473: LD_VAR 0 1
87477: PUSH
87478: LD_EXP 61
87482: PUSH
87483: LD_VAR 0 3
87487: ARRAY
87488: IN
87489: NOT
87490: IFFALSE 87536
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
87492: LD_ADDR_EXP 61
87496: PUSH
87497: LD_EXP 61
87501: PPUSH
87502: LD_VAR 0 3
87506: PUSH
87507: LD_EXP 61
87511: PUSH
87512: LD_VAR 0 3
87516: ARRAY
87517: PUSH
87518: LD_INT 1
87520: PLUS
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PPUSH
87526: LD_VAR 0 1
87530: PPUSH
87531: CALL 20981 0 3
87535: ST_TO_ADDR
// exit ;
87536: POP
87537: POP
87538: GO 87544
// end ; end ;
87540: GO 87344
87542: POP
87543: POP
// end ;
87544: LD_VAR 0 2
87548: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
87549: LD_INT 0
87551: PPUSH
87552: PPUSH
87553: PPUSH
87554: PPUSH
87555: PPUSH
87556: PPUSH
87557: PPUSH
// if not mc_bases or not skirmish then
87558: LD_EXP 61
87562: NOT
87563: PUSH
87564: LD_EXP 59
87568: NOT
87569: OR
87570: IFFALSE 87574
// exit ;
87572: GO 88235
// for i = 1 to mc_bases do
87574: LD_ADDR_VAR 0 3
87578: PUSH
87579: DOUBLE
87580: LD_INT 1
87582: DEC
87583: ST_TO_ADDR
87584: LD_EXP 61
87588: PUSH
87589: FOR_TO
87590: IFFALSE 88233
// begin if building in mc_construct_list [ i ] then
87592: LD_VAR 0 1
87596: PUSH
87597: LD_EXP 68
87601: PUSH
87602: LD_VAR 0 3
87606: ARRAY
87607: IN
87608: IFFALSE 88231
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
87610: LD_ADDR_EXP 68
87614: PUSH
87615: LD_EXP 68
87619: PPUSH
87620: LD_VAR 0 3
87624: PPUSH
87625: LD_EXP 68
87629: PUSH
87630: LD_VAR 0 3
87634: ARRAY
87635: PUSH
87636: LD_VAR 0 1
87640: DIFF
87641: PPUSH
87642: CALL_OW 1
87646: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
87647: LD_ADDR_EXP 61
87651: PUSH
87652: LD_EXP 61
87656: PPUSH
87657: LD_VAR 0 3
87661: PUSH
87662: LD_EXP 61
87666: PUSH
87667: LD_VAR 0 3
87671: ARRAY
87672: PUSH
87673: LD_INT 1
87675: PLUS
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PPUSH
87681: LD_VAR 0 1
87685: PPUSH
87686: CALL 20981 0 3
87690: ST_TO_ADDR
// btype := GetBType ( building ) ;
87691: LD_ADDR_VAR 0 5
87695: PUSH
87696: LD_VAR 0 1
87700: PPUSH
87701: CALL_OW 266
87705: ST_TO_ADDR
// side := GetSide ( building ) ;
87706: LD_ADDR_VAR 0 8
87710: PUSH
87711: LD_VAR 0 1
87715: PPUSH
87716: CALL_OW 255
87720: ST_TO_ADDR
// if btype = b_lab then
87721: LD_VAR 0 5
87725: PUSH
87726: LD_INT 6
87728: EQUAL
87729: IFFALSE 87779
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
87731: LD_ADDR_EXP 94
87735: PUSH
87736: LD_EXP 94
87740: PPUSH
87741: LD_VAR 0 3
87745: PUSH
87746: LD_EXP 94
87750: PUSH
87751: LD_VAR 0 3
87755: ARRAY
87756: PUSH
87757: LD_INT 1
87759: PLUS
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PPUSH
87765: LD_VAR 0 1
87769: PPUSH
87770: CALL 20981 0 3
87774: ST_TO_ADDR
// exit ;
87775: POP
87776: POP
87777: GO 88235
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
87779: LD_VAR 0 5
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: LD_INT 2
87789: PUSH
87790: LD_INT 4
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: LIST
87797: IN
87798: IFFALSE 87922
// begin if btype = b_armoury then
87800: LD_VAR 0 5
87804: PUSH
87805: LD_INT 4
87807: EQUAL
87808: IFFALSE 87818
// btype := b_barracks ;
87810: LD_ADDR_VAR 0 5
87814: PUSH
87815: LD_INT 5
87817: ST_TO_ADDR
// if btype = b_depot then
87818: LD_VAR 0 5
87822: PUSH
87823: LD_INT 0
87825: EQUAL
87826: IFFALSE 87836
// btype := b_warehouse ;
87828: LD_ADDR_VAR 0 5
87832: PUSH
87833: LD_INT 1
87835: ST_TO_ADDR
// if btype = b_workshop then
87836: LD_VAR 0 5
87840: PUSH
87841: LD_INT 2
87843: EQUAL
87844: IFFALSE 87854
// btype := b_factory ;
87846: LD_ADDR_VAR 0 5
87850: PUSH
87851: LD_INT 3
87853: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
87854: LD_VAR 0 5
87858: PPUSH
87859: LD_VAR 0 8
87863: PPUSH
87864: CALL_OW 323
87868: PUSH
87869: LD_INT 1
87871: EQUAL
87872: IFFALSE 87918
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
87874: LD_ADDR_EXP 93
87878: PUSH
87879: LD_EXP 93
87883: PPUSH
87884: LD_VAR 0 3
87888: PUSH
87889: LD_EXP 93
87893: PUSH
87894: LD_VAR 0 3
87898: ARRAY
87899: PUSH
87900: LD_INT 1
87902: PLUS
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PPUSH
87908: LD_VAR 0 1
87912: PPUSH
87913: CALL 20981 0 3
87917: ST_TO_ADDR
// exit ;
87918: POP
87919: POP
87920: GO 88235
// end ; if btype in [ b_bunker , b_turret ] then
87922: LD_VAR 0 5
87926: PUSH
87927: LD_INT 32
87929: PUSH
87930: LD_INT 33
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: IN
87937: IFFALSE 88227
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
87939: LD_ADDR_EXP 69
87943: PUSH
87944: LD_EXP 69
87948: PPUSH
87949: LD_VAR 0 3
87953: PUSH
87954: LD_EXP 69
87958: PUSH
87959: LD_VAR 0 3
87963: ARRAY
87964: PUSH
87965: LD_INT 1
87967: PLUS
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PPUSH
87973: LD_VAR 0 1
87977: PPUSH
87978: CALL 20981 0 3
87982: ST_TO_ADDR
// if btype = b_bunker then
87983: LD_VAR 0 5
87987: PUSH
87988: LD_INT 32
87990: EQUAL
87991: IFFALSE 88227
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87993: LD_ADDR_EXP 70
87997: PUSH
87998: LD_EXP 70
88002: PPUSH
88003: LD_VAR 0 3
88007: PUSH
88008: LD_EXP 70
88012: PUSH
88013: LD_VAR 0 3
88017: ARRAY
88018: PUSH
88019: LD_INT 1
88021: PLUS
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PPUSH
88027: LD_VAR 0 1
88031: PPUSH
88032: CALL 20981 0 3
88036: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
88037: LD_ADDR_VAR 0 6
88041: PUSH
88042: LD_EXP 61
88046: PUSH
88047: LD_VAR 0 3
88051: ARRAY
88052: PPUSH
88053: LD_INT 25
88055: PUSH
88056: LD_INT 1
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 3
88065: PUSH
88066: LD_INT 54
88068: PUSH
88069: EMPTY
88070: LIST
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PPUSH
88080: CALL_OW 72
88084: ST_TO_ADDR
// if tmp then
88085: LD_VAR 0 6
88089: IFFALSE 88095
// exit ;
88091: POP
88092: POP
88093: GO 88235
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
88095: LD_ADDR_VAR 0 6
88099: PUSH
88100: LD_EXP 61
88104: PUSH
88105: LD_VAR 0 3
88109: ARRAY
88110: PPUSH
88111: LD_INT 2
88113: PUSH
88114: LD_INT 30
88116: PUSH
88117: LD_INT 4
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 30
88126: PUSH
88127: LD_INT 5
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: LIST
88138: PPUSH
88139: CALL_OW 72
88143: ST_TO_ADDR
// if not tmp then
88144: LD_VAR 0 6
88148: NOT
88149: IFFALSE 88155
// exit ;
88151: POP
88152: POP
88153: GO 88235
// for j in tmp do
88155: LD_ADDR_VAR 0 4
88159: PUSH
88160: LD_VAR 0 6
88164: PUSH
88165: FOR_IN
88166: IFFALSE 88225
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
88168: LD_ADDR_VAR 0 7
88172: PUSH
88173: LD_VAR 0 4
88177: PPUSH
88178: CALL_OW 313
88182: PPUSH
88183: LD_INT 25
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PPUSH
88193: CALL_OW 72
88197: ST_TO_ADDR
// if units then
88198: LD_VAR 0 7
88202: IFFALSE 88223
// begin ComExitBuilding ( units [ 1 ] ) ;
88204: LD_VAR 0 7
88208: PUSH
88209: LD_INT 1
88211: ARRAY
88212: PPUSH
88213: CALL_OW 122
// exit ;
88217: POP
88218: POP
88219: POP
88220: POP
88221: GO 88235
// end ; end ;
88223: GO 88165
88225: POP
88226: POP
// end ; end ; exit ;
88227: POP
88228: POP
88229: GO 88235
// end ; end ;
88231: GO 87589
88233: POP
88234: POP
// end ;
88235: LD_VAR 0 2
88239: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
88240: LD_INT 0
88242: PPUSH
88243: PPUSH
88244: PPUSH
88245: PPUSH
88246: PPUSH
88247: PPUSH
88248: PPUSH
// if not mc_bases or not skirmish then
88249: LD_EXP 61
88253: NOT
88254: PUSH
88255: LD_EXP 59
88259: NOT
88260: OR
88261: IFFALSE 88265
// exit ;
88263: GO 88530
// btype := GetBType ( building ) ;
88265: LD_ADDR_VAR 0 6
88269: PUSH
88270: LD_VAR 0 1
88274: PPUSH
88275: CALL_OW 266
88279: ST_TO_ADDR
// x := GetX ( building ) ;
88280: LD_ADDR_VAR 0 7
88284: PUSH
88285: LD_VAR 0 1
88289: PPUSH
88290: CALL_OW 250
88294: ST_TO_ADDR
// y := GetY ( building ) ;
88295: LD_ADDR_VAR 0 8
88299: PUSH
88300: LD_VAR 0 1
88304: PPUSH
88305: CALL_OW 251
88309: ST_TO_ADDR
// d := GetDir ( building ) ;
88310: LD_ADDR_VAR 0 9
88314: PUSH
88315: LD_VAR 0 1
88319: PPUSH
88320: CALL_OW 254
88324: ST_TO_ADDR
// for i = 1 to mc_bases do
88325: LD_ADDR_VAR 0 4
88329: PUSH
88330: DOUBLE
88331: LD_INT 1
88333: DEC
88334: ST_TO_ADDR
88335: LD_EXP 61
88339: PUSH
88340: FOR_TO
88341: IFFALSE 88528
// begin if not mc_build_list [ i ] then
88343: LD_EXP 66
88347: PUSH
88348: LD_VAR 0 4
88352: ARRAY
88353: NOT
88354: IFFALSE 88358
// continue ;
88356: GO 88340
// for j := 1 to mc_build_list [ i ] do
88358: LD_ADDR_VAR 0 5
88362: PUSH
88363: DOUBLE
88364: LD_INT 1
88366: DEC
88367: ST_TO_ADDR
88368: LD_EXP 66
88372: PUSH
88373: LD_VAR 0 4
88377: ARRAY
88378: PUSH
88379: FOR_TO
88380: IFFALSE 88524
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
88382: LD_VAR 0 6
88386: PUSH
88387: LD_VAR 0 7
88391: PUSH
88392: LD_VAR 0 8
88396: PUSH
88397: LD_VAR 0 9
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: PPUSH
88408: LD_EXP 66
88412: PUSH
88413: LD_VAR 0 4
88417: ARRAY
88418: PUSH
88419: LD_VAR 0 5
88423: ARRAY
88424: PPUSH
88425: CALL 27538 0 2
88429: IFFALSE 88522
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
88431: LD_ADDR_EXP 66
88435: PUSH
88436: LD_EXP 66
88440: PPUSH
88441: LD_VAR 0 4
88445: PPUSH
88446: LD_EXP 66
88450: PUSH
88451: LD_VAR 0 4
88455: ARRAY
88456: PPUSH
88457: LD_VAR 0 5
88461: PPUSH
88462: CALL_OW 3
88466: PPUSH
88467: CALL_OW 1
88471: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
88472: LD_ADDR_EXP 68
88476: PUSH
88477: LD_EXP 68
88481: PPUSH
88482: LD_VAR 0 4
88486: PUSH
88487: LD_EXP 68
88491: PUSH
88492: LD_VAR 0 4
88496: ARRAY
88497: PUSH
88498: LD_INT 1
88500: PLUS
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PPUSH
88506: LD_VAR 0 1
88510: PPUSH
88511: CALL 20981 0 3
88515: ST_TO_ADDR
// exit ;
88516: POP
88517: POP
88518: POP
88519: POP
88520: GO 88530
// end ;
88522: GO 88379
88524: POP
88525: POP
// end ;
88526: GO 88340
88528: POP
88529: POP
// end ;
88530: LD_VAR 0 3
88534: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
88535: LD_INT 0
88537: PPUSH
88538: PPUSH
88539: PPUSH
// if not mc_bases or not skirmish then
88540: LD_EXP 61
88544: NOT
88545: PUSH
88546: LD_EXP 59
88550: NOT
88551: OR
88552: IFFALSE 88556
// exit ;
88554: GO 88746
// for i = 1 to mc_bases do
88556: LD_ADDR_VAR 0 4
88560: PUSH
88561: DOUBLE
88562: LD_INT 1
88564: DEC
88565: ST_TO_ADDR
88566: LD_EXP 61
88570: PUSH
88571: FOR_TO
88572: IFFALSE 88659
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
88574: LD_VAR 0 1
88578: PUSH
88579: LD_EXP 69
88583: PUSH
88584: LD_VAR 0 4
88588: ARRAY
88589: IN
88590: PUSH
88591: LD_VAR 0 1
88595: PUSH
88596: LD_EXP 70
88600: PUSH
88601: LD_VAR 0 4
88605: ARRAY
88606: IN
88607: NOT
88608: AND
88609: IFFALSE 88657
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
88611: LD_ADDR_EXP 70
88615: PUSH
88616: LD_EXP 70
88620: PPUSH
88621: LD_VAR 0 4
88625: PUSH
88626: LD_EXP 70
88630: PUSH
88631: LD_VAR 0 4
88635: ARRAY
88636: PUSH
88637: LD_INT 1
88639: PLUS
88640: PUSH
88641: EMPTY
88642: LIST
88643: LIST
88644: PPUSH
88645: LD_VAR 0 1
88649: PPUSH
88650: CALL 20981 0 3
88654: ST_TO_ADDR
// break ;
88655: GO 88659
// end ; end ;
88657: GO 88571
88659: POP
88660: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
88661: LD_VAR 0 1
88665: PPUSH
88666: CALL_OW 257
88670: PUSH
88671: LD_EXP 87
88675: IN
88676: PUSH
88677: LD_VAR 0 1
88681: PPUSH
88682: CALL_OW 266
88686: PUSH
88687: LD_INT 5
88689: EQUAL
88690: AND
88691: PUSH
88692: LD_VAR 0 2
88696: PPUSH
88697: CALL_OW 110
88701: PUSH
88702: LD_INT 18
88704: NONEQUAL
88705: AND
88706: IFFALSE 88746
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
88708: LD_VAR 0 2
88712: PPUSH
88713: CALL_OW 257
88717: PUSH
88718: LD_INT 5
88720: PUSH
88721: LD_INT 8
88723: PUSH
88724: LD_INT 9
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: LIST
88731: IN
88732: IFFALSE 88746
// SetClass ( unit , 1 ) ;
88734: LD_VAR 0 2
88738: PPUSH
88739: LD_INT 1
88741: PPUSH
88742: CALL_OW 336
// end ;
88746: LD_VAR 0 3
88750: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
88751: LD_INT 0
88753: PPUSH
88754: PPUSH
// if not mc_bases or not skirmish then
88755: LD_EXP 61
88759: NOT
88760: PUSH
88761: LD_EXP 59
88765: NOT
88766: OR
88767: IFFALSE 88771
// exit ;
88769: GO 88887
// if GetLives ( abandoned_vehicle ) > 250 then
88771: LD_VAR 0 2
88775: PPUSH
88776: CALL_OW 256
88780: PUSH
88781: LD_INT 250
88783: GREATER
88784: IFFALSE 88788
// exit ;
88786: GO 88887
// for i = 1 to mc_bases do
88788: LD_ADDR_VAR 0 6
88792: PUSH
88793: DOUBLE
88794: LD_INT 1
88796: DEC
88797: ST_TO_ADDR
88798: LD_EXP 61
88802: PUSH
88803: FOR_TO
88804: IFFALSE 88885
// begin if driver in mc_bases [ i ] then
88806: LD_VAR 0 1
88810: PUSH
88811: LD_EXP 61
88815: PUSH
88816: LD_VAR 0 6
88820: ARRAY
88821: IN
88822: IFFALSE 88883
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
88824: LD_VAR 0 1
88828: PPUSH
88829: LD_EXP 61
88833: PUSH
88834: LD_VAR 0 6
88838: ARRAY
88839: PPUSH
88840: LD_INT 2
88842: PUSH
88843: LD_INT 30
88845: PUSH
88846: LD_INT 0
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PUSH
88853: LD_INT 30
88855: PUSH
88856: LD_INT 1
88858: PUSH
88859: EMPTY
88860: LIST
88861: LIST
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: LIST
88867: PPUSH
88868: CALL_OW 72
88872: PUSH
88873: LD_INT 1
88875: ARRAY
88876: PPUSH
88877: CALL 54598 0 2
// break ;
88881: GO 88885
// end ; end ;
88883: GO 88803
88885: POP
88886: POP
// end ; end_of_file end_of_file
88887: LD_VAR 0 5
88891: RET
// export globalGameSaveCounter ; every 0 0$1 do
88892: GO 88894
88894: DISABLE
// begin enable ;
88895: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
88896: LD_STRING updateTimer(
88898: PUSH
88899: LD_OWVAR 1
88903: STR
88904: PUSH
88905: LD_STRING );
88907: STR
88908: PPUSH
88909: CALL_OW 559
// end ;
88913: END
// every 0 0$1 do
88914: GO 88916
88916: DISABLE
// begin globalGameSaveCounter := 0 ;
88917: LD_ADDR_EXP 106
88921: PUSH
88922: LD_INT 0
88924: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
88925: LD_STRING setGameSaveCounter(0)
88927: PPUSH
88928: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
88932: LD_STRING initStreamRollete();
88934: PPUSH
88935: CALL_OW 559
// InitStreamMode ;
88939: CALL 90265 0 0
// DefineStreamItems ( false ) ;
88943: LD_INT 0
88945: PPUSH
88946: CALL 90729 0 1
// end ;
88950: END
// export function SOS_MapStart ( ) ; begin
88951: LD_INT 0
88953: PPUSH
// if streamModeActive then
88954: LD_EXP 107
88958: IFFALSE 88967
// DefineStreamItems ( true ) ;
88960: LD_INT 1
88962: PPUSH
88963: CALL 90729 0 1
// UpdateLuaVariables ( ) ;
88967: CALL 88984 0 0
// UpdateFactoryWaypoints ( ) ;
88971: CALL 103598 0 0
// UpdateWarehouseGatheringPoints ( ) ;
88975: CALL 103855 0 0
// end ;
88979: LD_VAR 0 1
88983: RET
// function UpdateLuaVariables ( ) ; begin
88984: LD_INT 0
88986: PPUSH
// if globalGameSaveCounter then
88987: LD_EXP 106
88991: IFFALSE 89025
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
88993: LD_ADDR_EXP 106
88997: PUSH
88998: LD_EXP 106
89002: PPUSH
89003: CALL 55082 0 1
89007: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89008: LD_STRING setGameSaveCounter(
89010: PUSH
89011: LD_EXP 106
89015: STR
89016: PUSH
89017: LD_STRING )
89019: STR
89020: PPUSH
89021: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
89025: LD_STRING setGameDifficulty(
89027: PUSH
89028: LD_OWVAR 67
89032: STR
89033: PUSH
89034: LD_STRING )
89036: STR
89037: PPUSH
89038: CALL_OW 559
// end ;
89042: LD_VAR 0 1
89046: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89047: LD_INT 0
89049: PPUSH
// if p2 = stream_mode then
89050: LD_VAR 0 2
89054: PUSH
89055: LD_INT 100
89057: EQUAL
89058: IFFALSE 90061
// begin if not StreamModeActive then
89060: LD_EXP 107
89064: NOT
89065: IFFALSE 89075
// StreamModeActive := true ;
89067: LD_ADDR_EXP 107
89071: PUSH
89072: LD_INT 1
89074: ST_TO_ADDR
// if p3 = 0 then
89075: LD_VAR 0 3
89079: PUSH
89080: LD_INT 0
89082: EQUAL
89083: IFFALSE 89089
// InitStreamMode ;
89085: CALL 90265 0 0
// if p3 = 1 then
89089: LD_VAR 0 3
89093: PUSH
89094: LD_INT 1
89096: EQUAL
89097: IFFALSE 89107
// sRocket := true ;
89099: LD_ADDR_EXP 112
89103: PUSH
89104: LD_INT 1
89106: ST_TO_ADDR
// if p3 = 2 then
89107: LD_VAR 0 3
89111: PUSH
89112: LD_INT 2
89114: EQUAL
89115: IFFALSE 89125
// sSpeed := true ;
89117: LD_ADDR_EXP 111
89121: PUSH
89122: LD_INT 1
89124: ST_TO_ADDR
// if p3 = 3 then
89125: LD_VAR 0 3
89129: PUSH
89130: LD_INT 3
89132: EQUAL
89133: IFFALSE 89143
// sEngine := true ;
89135: LD_ADDR_EXP 113
89139: PUSH
89140: LD_INT 1
89142: ST_TO_ADDR
// if p3 = 4 then
89143: LD_VAR 0 3
89147: PUSH
89148: LD_INT 4
89150: EQUAL
89151: IFFALSE 89161
// sSpec := true ;
89153: LD_ADDR_EXP 110
89157: PUSH
89158: LD_INT 1
89160: ST_TO_ADDR
// if p3 = 5 then
89161: LD_VAR 0 3
89165: PUSH
89166: LD_INT 5
89168: EQUAL
89169: IFFALSE 89179
// sLevel := true ;
89171: LD_ADDR_EXP 114
89175: PUSH
89176: LD_INT 1
89178: ST_TO_ADDR
// if p3 = 6 then
89179: LD_VAR 0 3
89183: PUSH
89184: LD_INT 6
89186: EQUAL
89187: IFFALSE 89197
// sArmoury := true ;
89189: LD_ADDR_EXP 115
89193: PUSH
89194: LD_INT 1
89196: ST_TO_ADDR
// if p3 = 7 then
89197: LD_VAR 0 3
89201: PUSH
89202: LD_INT 7
89204: EQUAL
89205: IFFALSE 89215
// sRadar := true ;
89207: LD_ADDR_EXP 116
89211: PUSH
89212: LD_INT 1
89214: ST_TO_ADDR
// if p3 = 8 then
89215: LD_VAR 0 3
89219: PUSH
89220: LD_INT 8
89222: EQUAL
89223: IFFALSE 89233
// sBunker := true ;
89225: LD_ADDR_EXP 117
89229: PUSH
89230: LD_INT 1
89232: ST_TO_ADDR
// if p3 = 9 then
89233: LD_VAR 0 3
89237: PUSH
89238: LD_INT 9
89240: EQUAL
89241: IFFALSE 89251
// sHack := true ;
89243: LD_ADDR_EXP 118
89247: PUSH
89248: LD_INT 1
89250: ST_TO_ADDR
// if p3 = 10 then
89251: LD_VAR 0 3
89255: PUSH
89256: LD_INT 10
89258: EQUAL
89259: IFFALSE 89269
// sFire := true ;
89261: LD_ADDR_EXP 119
89265: PUSH
89266: LD_INT 1
89268: ST_TO_ADDR
// if p3 = 11 then
89269: LD_VAR 0 3
89273: PUSH
89274: LD_INT 11
89276: EQUAL
89277: IFFALSE 89287
// sRefresh := true ;
89279: LD_ADDR_EXP 120
89283: PUSH
89284: LD_INT 1
89286: ST_TO_ADDR
// if p3 = 12 then
89287: LD_VAR 0 3
89291: PUSH
89292: LD_INT 12
89294: EQUAL
89295: IFFALSE 89305
// sExp := true ;
89297: LD_ADDR_EXP 121
89301: PUSH
89302: LD_INT 1
89304: ST_TO_ADDR
// if p3 = 13 then
89305: LD_VAR 0 3
89309: PUSH
89310: LD_INT 13
89312: EQUAL
89313: IFFALSE 89323
// sDepot := true ;
89315: LD_ADDR_EXP 122
89319: PUSH
89320: LD_INT 1
89322: ST_TO_ADDR
// if p3 = 14 then
89323: LD_VAR 0 3
89327: PUSH
89328: LD_INT 14
89330: EQUAL
89331: IFFALSE 89341
// sFlag := true ;
89333: LD_ADDR_EXP 123
89337: PUSH
89338: LD_INT 1
89340: ST_TO_ADDR
// if p3 = 15 then
89341: LD_VAR 0 3
89345: PUSH
89346: LD_INT 15
89348: EQUAL
89349: IFFALSE 89359
// sKamikadze := true ;
89351: LD_ADDR_EXP 131
89355: PUSH
89356: LD_INT 1
89358: ST_TO_ADDR
// if p3 = 16 then
89359: LD_VAR 0 3
89363: PUSH
89364: LD_INT 16
89366: EQUAL
89367: IFFALSE 89377
// sTroll := true ;
89369: LD_ADDR_EXP 132
89373: PUSH
89374: LD_INT 1
89376: ST_TO_ADDR
// if p3 = 17 then
89377: LD_VAR 0 3
89381: PUSH
89382: LD_INT 17
89384: EQUAL
89385: IFFALSE 89395
// sSlow := true ;
89387: LD_ADDR_EXP 133
89391: PUSH
89392: LD_INT 1
89394: ST_TO_ADDR
// if p3 = 18 then
89395: LD_VAR 0 3
89399: PUSH
89400: LD_INT 18
89402: EQUAL
89403: IFFALSE 89413
// sLack := true ;
89405: LD_ADDR_EXP 134
89409: PUSH
89410: LD_INT 1
89412: ST_TO_ADDR
// if p3 = 19 then
89413: LD_VAR 0 3
89417: PUSH
89418: LD_INT 19
89420: EQUAL
89421: IFFALSE 89431
// sTank := true ;
89423: LD_ADDR_EXP 136
89427: PUSH
89428: LD_INT 1
89430: ST_TO_ADDR
// if p3 = 20 then
89431: LD_VAR 0 3
89435: PUSH
89436: LD_INT 20
89438: EQUAL
89439: IFFALSE 89449
// sRemote := true ;
89441: LD_ADDR_EXP 137
89445: PUSH
89446: LD_INT 1
89448: ST_TO_ADDR
// if p3 = 21 then
89449: LD_VAR 0 3
89453: PUSH
89454: LD_INT 21
89456: EQUAL
89457: IFFALSE 89467
// sPowell := true ;
89459: LD_ADDR_EXP 138
89463: PUSH
89464: LD_INT 1
89466: ST_TO_ADDR
// if p3 = 22 then
89467: LD_VAR 0 3
89471: PUSH
89472: LD_INT 22
89474: EQUAL
89475: IFFALSE 89485
// sTeleport := true ;
89477: LD_ADDR_EXP 141
89481: PUSH
89482: LD_INT 1
89484: ST_TO_ADDR
// if p3 = 23 then
89485: LD_VAR 0 3
89489: PUSH
89490: LD_INT 23
89492: EQUAL
89493: IFFALSE 89503
// sOilTower := true ;
89495: LD_ADDR_EXP 143
89499: PUSH
89500: LD_INT 1
89502: ST_TO_ADDR
// if p3 = 24 then
89503: LD_VAR 0 3
89507: PUSH
89508: LD_INT 24
89510: EQUAL
89511: IFFALSE 89521
// sShovel := true ;
89513: LD_ADDR_EXP 144
89517: PUSH
89518: LD_INT 1
89520: ST_TO_ADDR
// if p3 = 25 then
89521: LD_VAR 0 3
89525: PUSH
89526: LD_INT 25
89528: EQUAL
89529: IFFALSE 89539
// sSheik := true ;
89531: LD_ADDR_EXP 145
89535: PUSH
89536: LD_INT 1
89538: ST_TO_ADDR
// if p3 = 26 then
89539: LD_VAR 0 3
89543: PUSH
89544: LD_INT 26
89546: EQUAL
89547: IFFALSE 89557
// sEarthquake := true ;
89549: LD_ADDR_EXP 147
89553: PUSH
89554: LD_INT 1
89556: ST_TO_ADDR
// if p3 = 27 then
89557: LD_VAR 0 3
89561: PUSH
89562: LD_INT 27
89564: EQUAL
89565: IFFALSE 89575
// sAI := true ;
89567: LD_ADDR_EXP 148
89571: PUSH
89572: LD_INT 1
89574: ST_TO_ADDR
// if p3 = 28 then
89575: LD_VAR 0 3
89579: PUSH
89580: LD_INT 28
89582: EQUAL
89583: IFFALSE 89593
// sCargo := true ;
89585: LD_ADDR_EXP 151
89589: PUSH
89590: LD_INT 1
89592: ST_TO_ADDR
// if p3 = 29 then
89593: LD_VAR 0 3
89597: PUSH
89598: LD_INT 29
89600: EQUAL
89601: IFFALSE 89611
// sDLaser := true ;
89603: LD_ADDR_EXP 152
89607: PUSH
89608: LD_INT 1
89610: ST_TO_ADDR
// if p3 = 30 then
89611: LD_VAR 0 3
89615: PUSH
89616: LD_INT 30
89618: EQUAL
89619: IFFALSE 89629
// sExchange := true ;
89621: LD_ADDR_EXP 153
89625: PUSH
89626: LD_INT 1
89628: ST_TO_ADDR
// if p3 = 31 then
89629: LD_VAR 0 3
89633: PUSH
89634: LD_INT 31
89636: EQUAL
89637: IFFALSE 89647
// sFac := true ;
89639: LD_ADDR_EXP 154
89643: PUSH
89644: LD_INT 1
89646: ST_TO_ADDR
// if p3 = 32 then
89647: LD_VAR 0 3
89651: PUSH
89652: LD_INT 32
89654: EQUAL
89655: IFFALSE 89665
// sPower := true ;
89657: LD_ADDR_EXP 155
89661: PUSH
89662: LD_INT 1
89664: ST_TO_ADDR
// if p3 = 33 then
89665: LD_VAR 0 3
89669: PUSH
89670: LD_INT 33
89672: EQUAL
89673: IFFALSE 89683
// sRandom := true ;
89675: LD_ADDR_EXP 156
89679: PUSH
89680: LD_INT 1
89682: ST_TO_ADDR
// if p3 = 34 then
89683: LD_VAR 0 3
89687: PUSH
89688: LD_INT 34
89690: EQUAL
89691: IFFALSE 89701
// sShield := true ;
89693: LD_ADDR_EXP 157
89697: PUSH
89698: LD_INT 1
89700: ST_TO_ADDR
// if p3 = 35 then
89701: LD_VAR 0 3
89705: PUSH
89706: LD_INT 35
89708: EQUAL
89709: IFFALSE 89719
// sTime := true ;
89711: LD_ADDR_EXP 158
89715: PUSH
89716: LD_INT 1
89718: ST_TO_ADDR
// if p3 = 36 then
89719: LD_VAR 0 3
89723: PUSH
89724: LD_INT 36
89726: EQUAL
89727: IFFALSE 89737
// sTools := true ;
89729: LD_ADDR_EXP 159
89733: PUSH
89734: LD_INT 1
89736: ST_TO_ADDR
// if p3 = 101 then
89737: LD_VAR 0 3
89741: PUSH
89742: LD_INT 101
89744: EQUAL
89745: IFFALSE 89755
// sSold := true ;
89747: LD_ADDR_EXP 124
89751: PUSH
89752: LD_INT 1
89754: ST_TO_ADDR
// if p3 = 102 then
89755: LD_VAR 0 3
89759: PUSH
89760: LD_INT 102
89762: EQUAL
89763: IFFALSE 89773
// sDiff := true ;
89765: LD_ADDR_EXP 125
89769: PUSH
89770: LD_INT 1
89772: ST_TO_ADDR
// if p3 = 103 then
89773: LD_VAR 0 3
89777: PUSH
89778: LD_INT 103
89780: EQUAL
89781: IFFALSE 89791
// sFog := true ;
89783: LD_ADDR_EXP 128
89787: PUSH
89788: LD_INT 1
89790: ST_TO_ADDR
// if p3 = 104 then
89791: LD_VAR 0 3
89795: PUSH
89796: LD_INT 104
89798: EQUAL
89799: IFFALSE 89809
// sReset := true ;
89801: LD_ADDR_EXP 129
89805: PUSH
89806: LD_INT 1
89808: ST_TO_ADDR
// if p3 = 105 then
89809: LD_VAR 0 3
89813: PUSH
89814: LD_INT 105
89816: EQUAL
89817: IFFALSE 89827
// sSun := true ;
89819: LD_ADDR_EXP 130
89823: PUSH
89824: LD_INT 1
89826: ST_TO_ADDR
// if p3 = 106 then
89827: LD_VAR 0 3
89831: PUSH
89832: LD_INT 106
89834: EQUAL
89835: IFFALSE 89845
// sTiger := true ;
89837: LD_ADDR_EXP 126
89841: PUSH
89842: LD_INT 1
89844: ST_TO_ADDR
// if p3 = 107 then
89845: LD_VAR 0 3
89849: PUSH
89850: LD_INT 107
89852: EQUAL
89853: IFFALSE 89863
// sBomb := true ;
89855: LD_ADDR_EXP 127
89859: PUSH
89860: LD_INT 1
89862: ST_TO_ADDR
// if p3 = 108 then
89863: LD_VAR 0 3
89867: PUSH
89868: LD_INT 108
89870: EQUAL
89871: IFFALSE 89881
// sWound := true ;
89873: LD_ADDR_EXP 135
89877: PUSH
89878: LD_INT 1
89880: ST_TO_ADDR
// if p3 = 109 then
89881: LD_VAR 0 3
89885: PUSH
89886: LD_INT 109
89888: EQUAL
89889: IFFALSE 89899
// sBetray := true ;
89891: LD_ADDR_EXP 139
89895: PUSH
89896: LD_INT 1
89898: ST_TO_ADDR
// if p3 = 110 then
89899: LD_VAR 0 3
89903: PUSH
89904: LD_INT 110
89906: EQUAL
89907: IFFALSE 89917
// sContamin := true ;
89909: LD_ADDR_EXP 140
89913: PUSH
89914: LD_INT 1
89916: ST_TO_ADDR
// if p3 = 111 then
89917: LD_VAR 0 3
89921: PUSH
89922: LD_INT 111
89924: EQUAL
89925: IFFALSE 89935
// sOil := true ;
89927: LD_ADDR_EXP 142
89931: PUSH
89932: LD_INT 1
89934: ST_TO_ADDR
// if p3 = 112 then
89935: LD_VAR 0 3
89939: PUSH
89940: LD_INT 112
89942: EQUAL
89943: IFFALSE 89953
// sStu := true ;
89945: LD_ADDR_EXP 146
89949: PUSH
89950: LD_INT 1
89952: ST_TO_ADDR
// if p3 = 113 then
89953: LD_VAR 0 3
89957: PUSH
89958: LD_INT 113
89960: EQUAL
89961: IFFALSE 89971
// sBazooka := true ;
89963: LD_ADDR_EXP 149
89967: PUSH
89968: LD_INT 1
89970: ST_TO_ADDR
// if p3 = 114 then
89971: LD_VAR 0 3
89975: PUSH
89976: LD_INT 114
89978: EQUAL
89979: IFFALSE 89989
// sMortar := true ;
89981: LD_ADDR_EXP 150
89985: PUSH
89986: LD_INT 1
89988: ST_TO_ADDR
// if p3 = 115 then
89989: LD_VAR 0 3
89993: PUSH
89994: LD_INT 115
89996: EQUAL
89997: IFFALSE 90007
// sRanger := true ;
89999: LD_ADDR_EXP 160
90003: PUSH
90004: LD_INT 1
90006: ST_TO_ADDR
// if p3 = 116 then
90007: LD_VAR 0 3
90011: PUSH
90012: LD_INT 116
90014: EQUAL
90015: IFFALSE 90025
// sComputer := true ;
90017: LD_ADDR_EXP 161
90021: PUSH
90022: LD_INT 1
90024: ST_TO_ADDR
// if p3 = 117 then
90025: LD_VAR 0 3
90029: PUSH
90030: LD_INT 117
90032: EQUAL
90033: IFFALSE 90043
// s30 := true ;
90035: LD_ADDR_EXP 162
90039: PUSH
90040: LD_INT 1
90042: ST_TO_ADDR
// if p3 = 118 then
90043: LD_VAR 0 3
90047: PUSH
90048: LD_INT 118
90050: EQUAL
90051: IFFALSE 90061
// s60 := true ;
90053: LD_ADDR_EXP 163
90057: PUSH
90058: LD_INT 1
90060: ST_TO_ADDR
// end ; if p2 = hack_mode then
90061: LD_VAR 0 2
90065: PUSH
90066: LD_INT 101
90068: EQUAL
90069: IFFALSE 90197
// begin case p3 of 1 :
90071: LD_VAR 0 3
90075: PUSH
90076: LD_INT 1
90078: DOUBLE
90079: EQUAL
90080: IFTRUE 90084
90082: GO 90091
90084: POP
// hHackUnlimitedResources ; 2 :
90085: CALL 102344 0 0
90089: GO 90197
90091: LD_INT 2
90093: DOUBLE
90094: EQUAL
90095: IFTRUE 90099
90097: GO 90106
90099: POP
// hHackSetLevel10 ; 3 :
90100: CALL 102477 0 0
90104: GO 90197
90106: LD_INT 3
90108: DOUBLE
90109: EQUAL
90110: IFTRUE 90114
90112: GO 90121
90114: POP
// hHackSetLevel10YourUnits ; 4 :
90115: CALL 102562 0 0
90119: GO 90197
90121: LD_INT 4
90123: DOUBLE
90124: EQUAL
90125: IFTRUE 90129
90127: GO 90136
90129: POP
// hHackInvincible ; 5 :
90130: CALL 103010 0 0
90134: GO 90197
90136: LD_INT 5
90138: DOUBLE
90139: EQUAL
90140: IFTRUE 90144
90142: GO 90151
90144: POP
// hHackInvisible ; 6 :
90145: CALL 103121 0 0
90149: GO 90197
90151: LD_INT 6
90153: DOUBLE
90154: EQUAL
90155: IFTRUE 90159
90157: GO 90166
90159: POP
// hHackChangeYourSide ; 7 :
90160: CALL 103178 0 0
90164: GO 90197
90166: LD_INT 7
90168: DOUBLE
90169: EQUAL
90170: IFTRUE 90174
90172: GO 90181
90174: POP
// hHackChangeUnitSide ; 8 :
90175: CALL 103220 0 0
90179: GO 90197
90181: LD_INT 8
90183: DOUBLE
90184: EQUAL
90185: IFTRUE 90189
90187: GO 90196
90189: POP
// hHackFog ; end ;
90190: CALL 103321 0 0
90194: GO 90197
90196: POP
// end ; if p2 = game_save_mode then
90197: LD_VAR 0 2
90201: PUSH
90202: LD_INT 102
90204: EQUAL
90205: IFFALSE 90260
// begin if p3 = 1 then
90207: LD_VAR 0 3
90211: PUSH
90212: LD_INT 1
90214: EQUAL
90215: IFFALSE 90227
// globalGameSaveCounter := p4 ;
90217: LD_ADDR_EXP 106
90221: PUSH
90222: LD_VAR 0 4
90226: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
90227: LD_VAR 0 3
90231: PUSH
90232: LD_INT 2
90234: EQUAL
90235: PUSH
90236: LD_EXP 106
90240: AND
90241: IFFALSE 90260
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90243: LD_STRING setGameSaveCounter(
90245: PUSH
90246: LD_EXP 106
90250: STR
90251: PUSH
90252: LD_STRING )
90254: STR
90255: PPUSH
90256: CALL_OW 559
// end ; end ;
90260: LD_VAR 0 7
90264: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
90265: LD_INT 0
90267: PPUSH
// streamModeActive := false ;
90268: LD_ADDR_EXP 107
90272: PUSH
90273: LD_INT 0
90275: ST_TO_ADDR
// normalCounter := 36 ;
90276: LD_ADDR_EXP 108
90280: PUSH
90281: LD_INT 36
90283: ST_TO_ADDR
// hardcoreCounter := 18 ;
90284: LD_ADDR_EXP 109
90288: PUSH
90289: LD_INT 18
90291: ST_TO_ADDR
// sRocket := false ;
90292: LD_ADDR_EXP 112
90296: PUSH
90297: LD_INT 0
90299: ST_TO_ADDR
// sSpeed := false ;
90300: LD_ADDR_EXP 111
90304: PUSH
90305: LD_INT 0
90307: ST_TO_ADDR
// sEngine := false ;
90308: LD_ADDR_EXP 113
90312: PUSH
90313: LD_INT 0
90315: ST_TO_ADDR
// sSpec := false ;
90316: LD_ADDR_EXP 110
90320: PUSH
90321: LD_INT 0
90323: ST_TO_ADDR
// sLevel := false ;
90324: LD_ADDR_EXP 114
90328: PUSH
90329: LD_INT 0
90331: ST_TO_ADDR
// sArmoury := false ;
90332: LD_ADDR_EXP 115
90336: PUSH
90337: LD_INT 0
90339: ST_TO_ADDR
// sRadar := false ;
90340: LD_ADDR_EXP 116
90344: PUSH
90345: LD_INT 0
90347: ST_TO_ADDR
// sBunker := false ;
90348: LD_ADDR_EXP 117
90352: PUSH
90353: LD_INT 0
90355: ST_TO_ADDR
// sHack := false ;
90356: LD_ADDR_EXP 118
90360: PUSH
90361: LD_INT 0
90363: ST_TO_ADDR
// sFire := false ;
90364: LD_ADDR_EXP 119
90368: PUSH
90369: LD_INT 0
90371: ST_TO_ADDR
// sRefresh := false ;
90372: LD_ADDR_EXP 120
90376: PUSH
90377: LD_INT 0
90379: ST_TO_ADDR
// sExp := false ;
90380: LD_ADDR_EXP 121
90384: PUSH
90385: LD_INT 0
90387: ST_TO_ADDR
// sDepot := false ;
90388: LD_ADDR_EXP 122
90392: PUSH
90393: LD_INT 0
90395: ST_TO_ADDR
// sFlag := false ;
90396: LD_ADDR_EXP 123
90400: PUSH
90401: LD_INT 0
90403: ST_TO_ADDR
// sKamikadze := false ;
90404: LD_ADDR_EXP 131
90408: PUSH
90409: LD_INT 0
90411: ST_TO_ADDR
// sTroll := false ;
90412: LD_ADDR_EXP 132
90416: PUSH
90417: LD_INT 0
90419: ST_TO_ADDR
// sSlow := false ;
90420: LD_ADDR_EXP 133
90424: PUSH
90425: LD_INT 0
90427: ST_TO_ADDR
// sLack := false ;
90428: LD_ADDR_EXP 134
90432: PUSH
90433: LD_INT 0
90435: ST_TO_ADDR
// sTank := false ;
90436: LD_ADDR_EXP 136
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
// sRemote := false ;
90444: LD_ADDR_EXP 137
90448: PUSH
90449: LD_INT 0
90451: ST_TO_ADDR
// sPowell := false ;
90452: LD_ADDR_EXP 138
90456: PUSH
90457: LD_INT 0
90459: ST_TO_ADDR
// sTeleport := false ;
90460: LD_ADDR_EXP 141
90464: PUSH
90465: LD_INT 0
90467: ST_TO_ADDR
// sOilTower := false ;
90468: LD_ADDR_EXP 143
90472: PUSH
90473: LD_INT 0
90475: ST_TO_ADDR
// sShovel := false ;
90476: LD_ADDR_EXP 144
90480: PUSH
90481: LD_INT 0
90483: ST_TO_ADDR
// sSheik := false ;
90484: LD_ADDR_EXP 145
90488: PUSH
90489: LD_INT 0
90491: ST_TO_ADDR
// sEarthquake := false ;
90492: LD_ADDR_EXP 147
90496: PUSH
90497: LD_INT 0
90499: ST_TO_ADDR
// sAI := false ;
90500: LD_ADDR_EXP 148
90504: PUSH
90505: LD_INT 0
90507: ST_TO_ADDR
// sCargo := false ;
90508: LD_ADDR_EXP 151
90512: PUSH
90513: LD_INT 0
90515: ST_TO_ADDR
// sDLaser := false ;
90516: LD_ADDR_EXP 152
90520: PUSH
90521: LD_INT 0
90523: ST_TO_ADDR
// sExchange := false ;
90524: LD_ADDR_EXP 153
90528: PUSH
90529: LD_INT 0
90531: ST_TO_ADDR
// sFac := false ;
90532: LD_ADDR_EXP 154
90536: PUSH
90537: LD_INT 0
90539: ST_TO_ADDR
// sPower := false ;
90540: LD_ADDR_EXP 155
90544: PUSH
90545: LD_INT 0
90547: ST_TO_ADDR
// sRandom := false ;
90548: LD_ADDR_EXP 156
90552: PUSH
90553: LD_INT 0
90555: ST_TO_ADDR
// sShield := false ;
90556: LD_ADDR_EXP 157
90560: PUSH
90561: LD_INT 0
90563: ST_TO_ADDR
// sTime := false ;
90564: LD_ADDR_EXP 158
90568: PUSH
90569: LD_INT 0
90571: ST_TO_ADDR
// sTools := false ;
90572: LD_ADDR_EXP 159
90576: PUSH
90577: LD_INT 0
90579: ST_TO_ADDR
// sSold := false ;
90580: LD_ADDR_EXP 124
90584: PUSH
90585: LD_INT 0
90587: ST_TO_ADDR
// sDiff := false ;
90588: LD_ADDR_EXP 125
90592: PUSH
90593: LD_INT 0
90595: ST_TO_ADDR
// sFog := false ;
90596: LD_ADDR_EXP 128
90600: PUSH
90601: LD_INT 0
90603: ST_TO_ADDR
// sReset := false ;
90604: LD_ADDR_EXP 129
90608: PUSH
90609: LD_INT 0
90611: ST_TO_ADDR
// sSun := false ;
90612: LD_ADDR_EXP 130
90616: PUSH
90617: LD_INT 0
90619: ST_TO_ADDR
// sTiger := false ;
90620: LD_ADDR_EXP 126
90624: PUSH
90625: LD_INT 0
90627: ST_TO_ADDR
// sBomb := false ;
90628: LD_ADDR_EXP 127
90632: PUSH
90633: LD_INT 0
90635: ST_TO_ADDR
// sWound := false ;
90636: LD_ADDR_EXP 135
90640: PUSH
90641: LD_INT 0
90643: ST_TO_ADDR
// sBetray := false ;
90644: LD_ADDR_EXP 139
90648: PUSH
90649: LD_INT 0
90651: ST_TO_ADDR
// sContamin := false ;
90652: LD_ADDR_EXP 140
90656: PUSH
90657: LD_INT 0
90659: ST_TO_ADDR
// sOil := false ;
90660: LD_ADDR_EXP 142
90664: PUSH
90665: LD_INT 0
90667: ST_TO_ADDR
// sStu := false ;
90668: LD_ADDR_EXP 146
90672: PUSH
90673: LD_INT 0
90675: ST_TO_ADDR
// sBazooka := false ;
90676: LD_ADDR_EXP 149
90680: PUSH
90681: LD_INT 0
90683: ST_TO_ADDR
// sMortar := false ;
90684: LD_ADDR_EXP 150
90688: PUSH
90689: LD_INT 0
90691: ST_TO_ADDR
// sRanger := false ;
90692: LD_ADDR_EXP 160
90696: PUSH
90697: LD_INT 0
90699: ST_TO_ADDR
// sComputer := false ;
90700: LD_ADDR_EXP 161
90704: PUSH
90705: LD_INT 0
90707: ST_TO_ADDR
// s30 := false ;
90708: LD_ADDR_EXP 162
90712: PUSH
90713: LD_INT 0
90715: ST_TO_ADDR
// s60 := false ;
90716: LD_ADDR_EXP 163
90720: PUSH
90721: LD_INT 0
90723: ST_TO_ADDR
// end ;
90724: LD_VAR 0 1
90728: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
90729: LD_INT 0
90731: PPUSH
90732: PPUSH
90733: PPUSH
90734: PPUSH
90735: PPUSH
90736: PPUSH
90737: PPUSH
// result := [ ] ;
90738: LD_ADDR_VAR 0 2
90742: PUSH
90743: EMPTY
90744: ST_TO_ADDR
// if campaign_id = 1 then
90745: LD_OWVAR 69
90749: PUSH
90750: LD_INT 1
90752: EQUAL
90753: IFFALSE 93919
// begin case mission_number of 1 :
90755: LD_OWVAR 70
90759: PUSH
90760: LD_INT 1
90762: DOUBLE
90763: EQUAL
90764: IFTRUE 90768
90766: GO 90844
90768: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
90769: LD_ADDR_VAR 0 2
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: LD_INT 4
90779: PUSH
90780: LD_INT 11
90782: PUSH
90783: LD_INT 12
90785: PUSH
90786: LD_INT 15
90788: PUSH
90789: LD_INT 16
90791: PUSH
90792: LD_INT 22
90794: PUSH
90795: LD_INT 23
90797: PUSH
90798: LD_INT 26
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 101
90814: PUSH
90815: LD_INT 102
90817: PUSH
90818: LD_INT 106
90820: PUSH
90821: LD_INT 116
90823: PUSH
90824: LD_INT 117
90826: PUSH
90827: LD_INT 118
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: ST_TO_ADDR
90842: GO 93917
90844: LD_INT 2
90846: DOUBLE
90847: EQUAL
90848: IFTRUE 90852
90850: GO 90936
90852: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
90853: LD_ADDR_VAR 0 2
90857: PUSH
90858: LD_INT 2
90860: PUSH
90861: LD_INT 4
90863: PUSH
90864: LD_INT 11
90866: PUSH
90867: LD_INT 12
90869: PUSH
90870: LD_INT 15
90872: PUSH
90873: LD_INT 16
90875: PUSH
90876: LD_INT 22
90878: PUSH
90879: LD_INT 23
90881: PUSH
90882: LD_INT 26
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 101
90898: PUSH
90899: LD_INT 102
90901: PUSH
90902: LD_INT 105
90904: PUSH
90905: LD_INT 106
90907: PUSH
90908: LD_INT 108
90910: PUSH
90911: LD_INT 116
90913: PUSH
90914: LD_INT 117
90916: PUSH
90917: LD_INT 118
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: ST_TO_ADDR
90934: GO 93917
90936: LD_INT 3
90938: DOUBLE
90939: EQUAL
90940: IFTRUE 90944
90942: GO 91032
90944: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
90945: LD_ADDR_VAR 0 2
90949: PUSH
90950: LD_INT 2
90952: PUSH
90953: LD_INT 4
90955: PUSH
90956: LD_INT 5
90958: PUSH
90959: LD_INT 11
90961: PUSH
90962: LD_INT 12
90964: PUSH
90965: LD_INT 15
90967: PUSH
90968: LD_INT 16
90970: PUSH
90971: LD_INT 22
90973: PUSH
90974: LD_INT 26
90976: PUSH
90977: LD_INT 36
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 101
90994: PUSH
90995: LD_INT 102
90997: PUSH
90998: LD_INT 105
91000: PUSH
91001: LD_INT 106
91003: PUSH
91004: LD_INT 108
91006: PUSH
91007: LD_INT 116
91009: PUSH
91010: LD_INT 117
91012: PUSH
91013: LD_INT 118
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: ST_TO_ADDR
91030: GO 93917
91032: LD_INT 4
91034: DOUBLE
91035: EQUAL
91036: IFTRUE 91040
91038: GO 91136
91040: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
91041: LD_ADDR_VAR 0 2
91045: PUSH
91046: LD_INT 2
91048: PUSH
91049: LD_INT 4
91051: PUSH
91052: LD_INT 5
91054: PUSH
91055: LD_INT 8
91057: PUSH
91058: LD_INT 11
91060: PUSH
91061: LD_INT 12
91063: PUSH
91064: LD_INT 15
91066: PUSH
91067: LD_INT 16
91069: PUSH
91070: LD_INT 22
91072: PUSH
91073: LD_INT 23
91075: PUSH
91076: LD_INT 26
91078: PUSH
91079: LD_INT 36
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 101
91098: PUSH
91099: LD_INT 102
91101: PUSH
91102: LD_INT 105
91104: PUSH
91105: LD_INT 106
91107: PUSH
91108: LD_INT 108
91110: PUSH
91111: LD_INT 116
91113: PUSH
91114: LD_INT 117
91116: PUSH
91117: LD_INT 118
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: ST_TO_ADDR
91134: GO 93917
91136: LD_INT 5
91138: DOUBLE
91139: EQUAL
91140: IFTRUE 91144
91142: GO 91256
91144: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
91145: LD_ADDR_VAR 0 2
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: LD_INT 4
91155: PUSH
91156: LD_INT 5
91158: PUSH
91159: LD_INT 6
91161: PUSH
91162: LD_INT 8
91164: PUSH
91165: LD_INT 11
91167: PUSH
91168: LD_INT 12
91170: PUSH
91171: LD_INT 15
91173: PUSH
91174: LD_INT 16
91176: PUSH
91177: LD_INT 22
91179: PUSH
91180: LD_INT 23
91182: PUSH
91183: LD_INT 25
91185: PUSH
91186: LD_INT 26
91188: PUSH
91189: LD_INT 36
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 101
91210: PUSH
91211: LD_INT 102
91213: PUSH
91214: LD_INT 105
91216: PUSH
91217: LD_INT 106
91219: PUSH
91220: LD_INT 108
91222: PUSH
91223: LD_INT 109
91225: PUSH
91226: LD_INT 112
91228: PUSH
91229: LD_INT 116
91231: PUSH
91232: LD_INT 117
91234: PUSH
91235: LD_INT 118
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: ST_TO_ADDR
91254: GO 93917
91256: LD_INT 6
91258: DOUBLE
91259: EQUAL
91260: IFTRUE 91264
91262: GO 91396
91264: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
91265: LD_ADDR_VAR 0 2
91269: PUSH
91270: LD_INT 2
91272: PUSH
91273: LD_INT 4
91275: PUSH
91276: LD_INT 5
91278: PUSH
91279: LD_INT 6
91281: PUSH
91282: LD_INT 8
91284: PUSH
91285: LD_INT 11
91287: PUSH
91288: LD_INT 12
91290: PUSH
91291: LD_INT 15
91293: PUSH
91294: LD_INT 16
91296: PUSH
91297: LD_INT 20
91299: PUSH
91300: LD_INT 21
91302: PUSH
91303: LD_INT 22
91305: PUSH
91306: LD_INT 23
91308: PUSH
91309: LD_INT 25
91311: PUSH
91312: LD_INT 26
91314: PUSH
91315: LD_INT 30
91317: PUSH
91318: LD_INT 31
91320: PUSH
91321: LD_INT 32
91323: PUSH
91324: LD_INT 36
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 101
91350: PUSH
91351: LD_INT 102
91353: PUSH
91354: LD_INT 105
91356: PUSH
91357: LD_INT 106
91359: PUSH
91360: LD_INT 108
91362: PUSH
91363: LD_INT 109
91365: PUSH
91366: LD_INT 112
91368: PUSH
91369: LD_INT 116
91371: PUSH
91372: LD_INT 117
91374: PUSH
91375: LD_INT 118
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: ST_TO_ADDR
91394: GO 93917
91396: LD_INT 7
91398: DOUBLE
91399: EQUAL
91400: IFTRUE 91404
91402: GO 91516
91404: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
91405: LD_ADDR_VAR 0 2
91409: PUSH
91410: LD_INT 2
91412: PUSH
91413: LD_INT 4
91415: PUSH
91416: LD_INT 5
91418: PUSH
91419: LD_INT 7
91421: PUSH
91422: LD_INT 11
91424: PUSH
91425: LD_INT 12
91427: PUSH
91428: LD_INT 15
91430: PUSH
91431: LD_INT 16
91433: PUSH
91434: LD_INT 20
91436: PUSH
91437: LD_INT 21
91439: PUSH
91440: LD_INT 22
91442: PUSH
91443: LD_INT 23
91445: PUSH
91446: LD_INT 25
91448: PUSH
91449: LD_INT 26
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 101
91470: PUSH
91471: LD_INT 102
91473: PUSH
91474: LD_INT 103
91476: PUSH
91477: LD_INT 105
91479: PUSH
91480: LD_INT 106
91482: PUSH
91483: LD_INT 108
91485: PUSH
91486: LD_INT 112
91488: PUSH
91489: LD_INT 116
91491: PUSH
91492: LD_INT 117
91494: PUSH
91495: LD_INT 118
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: ST_TO_ADDR
91514: GO 93917
91516: LD_INT 8
91518: DOUBLE
91519: EQUAL
91520: IFTRUE 91524
91522: GO 91664
91524: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
91525: LD_ADDR_VAR 0 2
91529: PUSH
91530: LD_INT 2
91532: PUSH
91533: LD_INT 4
91535: PUSH
91536: LD_INT 5
91538: PUSH
91539: LD_INT 6
91541: PUSH
91542: LD_INT 7
91544: PUSH
91545: LD_INT 8
91547: PUSH
91548: LD_INT 11
91550: PUSH
91551: LD_INT 12
91553: PUSH
91554: LD_INT 15
91556: PUSH
91557: LD_INT 16
91559: PUSH
91560: LD_INT 20
91562: PUSH
91563: LD_INT 21
91565: PUSH
91566: LD_INT 22
91568: PUSH
91569: LD_INT 23
91571: PUSH
91572: LD_INT 25
91574: PUSH
91575: LD_INT 26
91577: PUSH
91578: LD_INT 30
91580: PUSH
91581: LD_INT 31
91583: PUSH
91584: LD_INT 32
91586: PUSH
91587: LD_INT 36
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: PUSH
91612: LD_INT 101
91614: PUSH
91615: LD_INT 102
91617: PUSH
91618: LD_INT 103
91620: PUSH
91621: LD_INT 105
91623: PUSH
91624: LD_INT 106
91626: PUSH
91627: LD_INT 108
91629: PUSH
91630: LD_INT 109
91632: PUSH
91633: LD_INT 112
91635: PUSH
91636: LD_INT 116
91638: PUSH
91639: LD_INT 117
91641: PUSH
91642: LD_INT 118
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: ST_TO_ADDR
91662: GO 93917
91664: LD_INT 9
91666: DOUBLE
91667: EQUAL
91668: IFTRUE 91672
91670: GO 91820
91672: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
91673: LD_ADDR_VAR 0 2
91677: PUSH
91678: LD_INT 2
91680: PUSH
91681: LD_INT 4
91683: PUSH
91684: LD_INT 5
91686: PUSH
91687: LD_INT 6
91689: PUSH
91690: LD_INT 7
91692: PUSH
91693: LD_INT 8
91695: PUSH
91696: LD_INT 11
91698: PUSH
91699: LD_INT 12
91701: PUSH
91702: LD_INT 15
91704: PUSH
91705: LD_INT 16
91707: PUSH
91708: LD_INT 20
91710: PUSH
91711: LD_INT 21
91713: PUSH
91714: LD_INT 22
91716: PUSH
91717: LD_INT 23
91719: PUSH
91720: LD_INT 25
91722: PUSH
91723: LD_INT 26
91725: PUSH
91726: LD_INT 28
91728: PUSH
91729: LD_INT 30
91731: PUSH
91732: LD_INT 31
91734: PUSH
91735: LD_INT 32
91737: PUSH
91738: LD_INT 36
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 101
91766: PUSH
91767: LD_INT 102
91769: PUSH
91770: LD_INT 103
91772: PUSH
91773: LD_INT 105
91775: PUSH
91776: LD_INT 106
91778: PUSH
91779: LD_INT 108
91781: PUSH
91782: LD_INT 109
91784: PUSH
91785: LD_INT 112
91787: PUSH
91788: LD_INT 114
91790: PUSH
91791: LD_INT 116
91793: PUSH
91794: LD_INT 117
91796: PUSH
91797: LD_INT 118
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: ST_TO_ADDR
91818: GO 93917
91820: LD_INT 10
91822: DOUBLE
91823: EQUAL
91824: IFTRUE 91828
91826: GO 92024
91828: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
91829: LD_ADDR_VAR 0 2
91833: PUSH
91834: LD_INT 2
91836: PUSH
91837: LD_INT 4
91839: PUSH
91840: LD_INT 5
91842: PUSH
91843: LD_INT 6
91845: PUSH
91846: LD_INT 7
91848: PUSH
91849: LD_INT 8
91851: PUSH
91852: LD_INT 9
91854: PUSH
91855: LD_INT 10
91857: PUSH
91858: LD_INT 11
91860: PUSH
91861: LD_INT 12
91863: PUSH
91864: LD_INT 13
91866: PUSH
91867: LD_INT 14
91869: PUSH
91870: LD_INT 15
91872: PUSH
91873: LD_INT 16
91875: PUSH
91876: LD_INT 17
91878: PUSH
91879: LD_INT 18
91881: PUSH
91882: LD_INT 19
91884: PUSH
91885: LD_INT 20
91887: PUSH
91888: LD_INT 21
91890: PUSH
91891: LD_INT 22
91893: PUSH
91894: LD_INT 23
91896: PUSH
91897: LD_INT 24
91899: PUSH
91900: LD_INT 25
91902: PUSH
91903: LD_INT 26
91905: PUSH
91906: LD_INT 28
91908: PUSH
91909: LD_INT 30
91911: PUSH
91912: LD_INT 31
91914: PUSH
91915: LD_INT 32
91917: PUSH
91918: LD_INT 36
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 101
91954: PUSH
91955: LD_INT 102
91957: PUSH
91958: LD_INT 103
91960: PUSH
91961: LD_INT 104
91963: PUSH
91964: LD_INT 105
91966: PUSH
91967: LD_INT 106
91969: PUSH
91970: LD_INT 107
91972: PUSH
91973: LD_INT 108
91975: PUSH
91976: LD_INT 109
91978: PUSH
91979: LD_INT 110
91981: PUSH
91982: LD_INT 111
91984: PUSH
91985: LD_INT 112
91987: PUSH
91988: LD_INT 114
91990: PUSH
91991: LD_INT 116
91993: PUSH
91994: LD_INT 117
91996: PUSH
91997: LD_INT 118
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: ST_TO_ADDR
92022: GO 93917
92024: LD_INT 11
92026: DOUBLE
92027: EQUAL
92028: IFTRUE 92032
92030: GO 92236
92032: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
92033: LD_ADDR_VAR 0 2
92037: PUSH
92038: LD_INT 2
92040: PUSH
92041: LD_INT 3
92043: PUSH
92044: LD_INT 4
92046: PUSH
92047: LD_INT 5
92049: PUSH
92050: LD_INT 6
92052: PUSH
92053: LD_INT 7
92055: PUSH
92056: LD_INT 8
92058: PUSH
92059: LD_INT 9
92061: PUSH
92062: LD_INT 10
92064: PUSH
92065: LD_INT 11
92067: PUSH
92068: LD_INT 12
92070: PUSH
92071: LD_INT 13
92073: PUSH
92074: LD_INT 14
92076: PUSH
92077: LD_INT 15
92079: PUSH
92080: LD_INT 16
92082: PUSH
92083: LD_INT 17
92085: PUSH
92086: LD_INT 18
92088: PUSH
92089: LD_INT 19
92091: PUSH
92092: LD_INT 20
92094: PUSH
92095: LD_INT 21
92097: PUSH
92098: LD_INT 22
92100: PUSH
92101: LD_INT 23
92103: PUSH
92104: LD_INT 24
92106: PUSH
92107: LD_INT 25
92109: PUSH
92110: LD_INT 26
92112: PUSH
92113: LD_INT 28
92115: PUSH
92116: LD_INT 30
92118: PUSH
92119: LD_INT 31
92121: PUSH
92122: LD_INT 32
92124: PUSH
92125: LD_INT 34
92127: PUSH
92128: LD_INT 36
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 101
92166: PUSH
92167: LD_INT 102
92169: PUSH
92170: LD_INT 103
92172: PUSH
92173: LD_INT 104
92175: PUSH
92176: LD_INT 105
92178: PUSH
92179: LD_INT 106
92181: PUSH
92182: LD_INT 107
92184: PUSH
92185: LD_INT 108
92187: PUSH
92188: LD_INT 109
92190: PUSH
92191: LD_INT 110
92193: PUSH
92194: LD_INT 111
92196: PUSH
92197: LD_INT 112
92199: PUSH
92200: LD_INT 114
92202: PUSH
92203: LD_INT 116
92205: PUSH
92206: LD_INT 117
92208: PUSH
92209: LD_INT 118
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: ST_TO_ADDR
92234: GO 93917
92236: LD_INT 12
92238: DOUBLE
92239: EQUAL
92240: IFTRUE 92244
92242: GO 92464
92244: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
92245: LD_ADDR_VAR 0 2
92249: PUSH
92250: LD_INT 1
92252: PUSH
92253: LD_INT 2
92255: PUSH
92256: LD_INT 3
92258: PUSH
92259: LD_INT 4
92261: PUSH
92262: LD_INT 5
92264: PUSH
92265: LD_INT 6
92267: PUSH
92268: LD_INT 7
92270: PUSH
92271: LD_INT 8
92273: PUSH
92274: LD_INT 9
92276: PUSH
92277: LD_INT 10
92279: PUSH
92280: LD_INT 11
92282: PUSH
92283: LD_INT 12
92285: PUSH
92286: LD_INT 13
92288: PUSH
92289: LD_INT 14
92291: PUSH
92292: LD_INT 15
92294: PUSH
92295: LD_INT 16
92297: PUSH
92298: LD_INT 17
92300: PUSH
92301: LD_INT 18
92303: PUSH
92304: LD_INT 19
92306: PUSH
92307: LD_INT 20
92309: PUSH
92310: LD_INT 21
92312: PUSH
92313: LD_INT 22
92315: PUSH
92316: LD_INT 23
92318: PUSH
92319: LD_INT 24
92321: PUSH
92322: LD_INT 25
92324: PUSH
92325: LD_INT 26
92327: PUSH
92328: LD_INT 27
92330: PUSH
92331: LD_INT 28
92333: PUSH
92334: LD_INT 30
92336: PUSH
92337: LD_INT 31
92339: PUSH
92340: LD_INT 32
92342: PUSH
92343: LD_INT 33
92345: PUSH
92346: LD_INT 34
92348: PUSH
92349: LD_INT 36
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 101
92390: PUSH
92391: LD_INT 102
92393: PUSH
92394: LD_INT 103
92396: PUSH
92397: LD_INT 104
92399: PUSH
92400: LD_INT 105
92402: PUSH
92403: LD_INT 106
92405: PUSH
92406: LD_INT 107
92408: PUSH
92409: LD_INT 108
92411: PUSH
92412: LD_INT 109
92414: PUSH
92415: LD_INT 110
92417: PUSH
92418: LD_INT 111
92420: PUSH
92421: LD_INT 112
92423: PUSH
92424: LD_INT 113
92426: PUSH
92427: LD_INT 114
92429: PUSH
92430: LD_INT 116
92432: PUSH
92433: LD_INT 117
92435: PUSH
92436: LD_INT 118
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: ST_TO_ADDR
92462: GO 93917
92464: LD_INT 13
92466: DOUBLE
92467: EQUAL
92468: IFTRUE 92472
92470: GO 92680
92472: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
92473: LD_ADDR_VAR 0 2
92477: PUSH
92478: LD_INT 1
92480: PUSH
92481: LD_INT 2
92483: PUSH
92484: LD_INT 3
92486: PUSH
92487: LD_INT 4
92489: PUSH
92490: LD_INT 5
92492: PUSH
92493: LD_INT 8
92495: PUSH
92496: LD_INT 9
92498: PUSH
92499: LD_INT 10
92501: PUSH
92502: LD_INT 11
92504: PUSH
92505: LD_INT 12
92507: PUSH
92508: LD_INT 14
92510: PUSH
92511: LD_INT 15
92513: PUSH
92514: LD_INT 16
92516: PUSH
92517: LD_INT 17
92519: PUSH
92520: LD_INT 18
92522: PUSH
92523: LD_INT 19
92525: PUSH
92526: LD_INT 20
92528: PUSH
92529: LD_INT 21
92531: PUSH
92532: LD_INT 22
92534: PUSH
92535: LD_INT 23
92537: PUSH
92538: LD_INT 24
92540: PUSH
92541: LD_INT 25
92543: PUSH
92544: LD_INT 26
92546: PUSH
92547: LD_INT 27
92549: PUSH
92550: LD_INT 28
92552: PUSH
92553: LD_INT 30
92555: PUSH
92556: LD_INT 31
92558: PUSH
92559: LD_INT 32
92561: PUSH
92562: LD_INT 33
92564: PUSH
92565: LD_INT 34
92567: PUSH
92568: LD_INT 36
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 101
92606: PUSH
92607: LD_INT 102
92609: PUSH
92610: LD_INT 103
92612: PUSH
92613: LD_INT 104
92615: PUSH
92616: LD_INT 105
92618: PUSH
92619: LD_INT 106
92621: PUSH
92622: LD_INT 107
92624: PUSH
92625: LD_INT 108
92627: PUSH
92628: LD_INT 109
92630: PUSH
92631: LD_INT 110
92633: PUSH
92634: LD_INT 111
92636: PUSH
92637: LD_INT 112
92639: PUSH
92640: LD_INT 113
92642: PUSH
92643: LD_INT 114
92645: PUSH
92646: LD_INT 116
92648: PUSH
92649: LD_INT 117
92651: PUSH
92652: LD_INT 118
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: ST_TO_ADDR
92678: GO 93917
92680: LD_INT 14
92682: DOUBLE
92683: EQUAL
92684: IFTRUE 92688
92686: GO 92912
92688: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
92689: LD_ADDR_VAR 0 2
92693: PUSH
92694: LD_INT 1
92696: PUSH
92697: LD_INT 2
92699: PUSH
92700: LD_INT 3
92702: PUSH
92703: LD_INT 4
92705: PUSH
92706: LD_INT 5
92708: PUSH
92709: LD_INT 6
92711: PUSH
92712: LD_INT 7
92714: PUSH
92715: LD_INT 8
92717: PUSH
92718: LD_INT 9
92720: PUSH
92721: LD_INT 10
92723: PUSH
92724: LD_INT 11
92726: PUSH
92727: LD_INT 12
92729: PUSH
92730: LD_INT 13
92732: PUSH
92733: LD_INT 14
92735: PUSH
92736: LD_INT 15
92738: PUSH
92739: LD_INT 16
92741: PUSH
92742: LD_INT 17
92744: PUSH
92745: LD_INT 18
92747: PUSH
92748: LD_INT 19
92750: PUSH
92751: LD_INT 20
92753: PUSH
92754: LD_INT 21
92756: PUSH
92757: LD_INT 22
92759: PUSH
92760: LD_INT 23
92762: PUSH
92763: LD_INT 24
92765: PUSH
92766: LD_INT 25
92768: PUSH
92769: LD_INT 26
92771: PUSH
92772: LD_INT 27
92774: PUSH
92775: LD_INT 28
92777: PUSH
92778: LD_INT 29
92780: PUSH
92781: LD_INT 30
92783: PUSH
92784: LD_INT 31
92786: PUSH
92787: LD_INT 32
92789: PUSH
92790: LD_INT 33
92792: PUSH
92793: LD_INT 34
92795: PUSH
92796: LD_INT 36
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 101
92838: PUSH
92839: LD_INT 102
92841: PUSH
92842: LD_INT 103
92844: PUSH
92845: LD_INT 104
92847: PUSH
92848: LD_INT 105
92850: PUSH
92851: LD_INT 106
92853: PUSH
92854: LD_INT 107
92856: PUSH
92857: LD_INT 108
92859: PUSH
92860: LD_INT 109
92862: PUSH
92863: LD_INT 110
92865: PUSH
92866: LD_INT 111
92868: PUSH
92869: LD_INT 112
92871: PUSH
92872: LD_INT 113
92874: PUSH
92875: LD_INT 114
92877: PUSH
92878: LD_INT 116
92880: PUSH
92881: LD_INT 117
92883: PUSH
92884: LD_INT 118
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: ST_TO_ADDR
92910: GO 93917
92912: LD_INT 15
92914: DOUBLE
92915: EQUAL
92916: IFTRUE 92920
92918: GO 93144
92920: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
92921: LD_ADDR_VAR 0 2
92925: PUSH
92926: LD_INT 1
92928: PUSH
92929: LD_INT 2
92931: PUSH
92932: LD_INT 3
92934: PUSH
92935: LD_INT 4
92937: PUSH
92938: LD_INT 5
92940: PUSH
92941: LD_INT 6
92943: PUSH
92944: LD_INT 7
92946: PUSH
92947: LD_INT 8
92949: PUSH
92950: LD_INT 9
92952: PUSH
92953: LD_INT 10
92955: PUSH
92956: LD_INT 11
92958: PUSH
92959: LD_INT 12
92961: PUSH
92962: LD_INT 13
92964: PUSH
92965: LD_INT 14
92967: PUSH
92968: LD_INT 15
92970: PUSH
92971: LD_INT 16
92973: PUSH
92974: LD_INT 17
92976: PUSH
92977: LD_INT 18
92979: PUSH
92980: LD_INT 19
92982: PUSH
92983: LD_INT 20
92985: PUSH
92986: LD_INT 21
92988: PUSH
92989: LD_INT 22
92991: PUSH
92992: LD_INT 23
92994: PUSH
92995: LD_INT 24
92997: PUSH
92998: LD_INT 25
93000: PUSH
93001: LD_INT 26
93003: PUSH
93004: LD_INT 27
93006: PUSH
93007: LD_INT 28
93009: PUSH
93010: LD_INT 29
93012: PUSH
93013: LD_INT 30
93015: PUSH
93016: LD_INT 31
93018: PUSH
93019: LD_INT 32
93021: PUSH
93022: LD_INT 33
93024: PUSH
93025: LD_INT 34
93027: PUSH
93028: LD_INT 36
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 101
93070: PUSH
93071: LD_INT 102
93073: PUSH
93074: LD_INT 103
93076: PUSH
93077: LD_INT 104
93079: PUSH
93080: LD_INT 105
93082: PUSH
93083: LD_INT 106
93085: PUSH
93086: LD_INT 107
93088: PUSH
93089: LD_INT 108
93091: PUSH
93092: LD_INT 109
93094: PUSH
93095: LD_INT 110
93097: PUSH
93098: LD_INT 111
93100: PUSH
93101: LD_INT 112
93103: PUSH
93104: LD_INT 113
93106: PUSH
93107: LD_INT 114
93109: PUSH
93110: LD_INT 116
93112: PUSH
93113: LD_INT 117
93115: PUSH
93116: LD_INT 118
93118: PUSH
93119: EMPTY
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: ST_TO_ADDR
93142: GO 93917
93144: LD_INT 16
93146: DOUBLE
93147: EQUAL
93148: IFTRUE 93152
93150: GO 93288
93152: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
93153: LD_ADDR_VAR 0 2
93157: PUSH
93158: LD_INT 2
93160: PUSH
93161: LD_INT 4
93163: PUSH
93164: LD_INT 5
93166: PUSH
93167: LD_INT 7
93169: PUSH
93170: LD_INT 11
93172: PUSH
93173: LD_INT 12
93175: PUSH
93176: LD_INT 15
93178: PUSH
93179: LD_INT 16
93181: PUSH
93182: LD_INT 20
93184: PUSH
93185: LD_INT 21
93187: PUSH
93188: LD_INT 22
93190: PUSH
93191: LD_INT 23
93193: PUSH
93194: LD_INT 25
93196: PUSH
93197: LD_INT 26
93199: PUSH
93200: LD_INT 30
93202: PUSH
93203: LD_INT 31
93205: PUSH
93206: LD_INT 32
93208: PUSH
93209: LD_INT 33
93211: PUSH
93212: LD_INT 34
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 101
93238: PUSH
93239: LD_INT 102
93241: PUSH
93242: LD_INT 103
93244: PUSH
93245: LD_INT 106
93247: PUSH
93248: LD_INT 108
93250: PUSH
93251: LD_INT 112
93253: PUSH
93254: LD_INT 113
93256: PUSH
93257: LD_INT 114
93259: PUSH
93260: LD_INT 116
93262: PUSH
93263: LD_INT 117
93265: PUSH
93266: LD_INT 118
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: ST_TO_ADDR
93286: GO 93917
93288: LD_INT 17
93290: DOUBLE
93291: EQUAL
93292: IFTRUE 93296
93294: GO 93520
93296: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
93297: LD_ADDR_VAR 0 2
93301: PUSH
93302: LD_INT 1
93304: PUSH
93305: LD_INT 2
93307: PUSH
93308: LD_INT 3
93310: PUSH
93311: LD_INT 4
93313: PUSH
93314: LD_INT 5
93316: PUSH
93317: LD_INT 6
93319: PUSH
93320: LD_INT 7
93322: PUSH
93323: LD_INT 8
93325: PUSH
93326: LD_INT 9
93328: PUSH
93329: LD_INT 10
93331: PUSH
93332: LD_INT 11
93334: PUSH
93335: LD_INT 12
93337: PUSH
93338: LD_INT 13
93340: PUSH
93341: LD_INT 14
93343: PUSH
93344: LD_INT 15
93346: PUSH
93347: LD_INT 16
93349: PUSH
93350: LD_INT 17
93352: PUSH
93353: LD_INT 18
93355: PUSH
93356: LD_INT 19
93358: PUSH
93359: LD_INT 20
93361: PUSH
93362: LD_INT 21
93364: PUSH
93365: LD_INT 22
93367: PUSH
93368: LD_INT 23
93370: PUSH
93371: LD_INT 24
93373: PUSH
93374: LD_INT 25
93376: PUSH
93377: LD_INT 26
93379: PUSH
93380: LD_INT 27
93382: PUSH
93383: LD_INT 28
93385: PUSH
93386: LD_INT 29
93388: PUSH
93389: LD_INT 30
93391: PUSH
93392: LD_INT 31
93394: PUSH
93395: LD_INT 32
93397: PUSH
93398: LD_INT 33
93400: PUSH
93401: LD_INT 34
93403: PUSH
93404: LD_INT 36
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 101
93446: PUSH
93447: LD_INT 102
93449: PUSH
93450: LD_INT 103
93452: PUSH
93453: LD_INT 104
93455: PUSH
93456: LD_INT 105
93458: PUSH
93459: LD_INT 106
93461: PUSH
93462: LD_INT 107
93464: PUSH
93465: LD_INT 108
93467: PUSH
93468: LD_INT 109
93470: PUSH
93471: LD_INT 110
93473: PUSH
93474: LD_INT 111
93476: PUSH
93477: LD_INT 112
93479: PUSH
93480: LD_INT 113
93482: PUSH
93483: LD_INT 114
93485: PUSH
93486: LD_INT 116
93488: PUSH
93489: LD_INT 117
93491: PUSH
93492: LD_INT 118
93494: PUSH
93495: EMPTY
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: ST_TO_ADDR
93518: GO 93917
93520: LD_INT 18
93522: DOUBLE
93523: EQUAL
93524: IFTRUE 93528
93526: GO 93676
93528: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
93529: LD_ADDR_VAR 0 2
93533: PUSH
93534: LD_INT 2
93536: PUSH
93537: LD_INT 4
93539: PUSH
93540: LD_INT 5
93542: PUSH
93543: LD_INT 7
93545: PUSH
93546: LD_INT 11
93548: PUSH
93549: LD_INT 12
93551: PUSH
93552: LD_INT 15
93554: PUSH
93555: LD_INT 16
93557: PUSH
93558: LD_INT 20
93560: PUSH
93561: LD_INT 21
93563: PUSH
93564: LD_INT 22
93566: PUSH
93567: LD_INT 23
93569: PUSH
93570: LD_INT 25
93572: PUSH
93573: LD_INT 26
93575: PUSH
93576: LD_INT 30
93578: PUSH
93579: LD_INT 31
93581: PUSH
93582: LD_INT 32
93584: PUSH
93585: LD_INT 33
93587: PUSH
93588: LD_INT 34
93590: PUSH
93591: LD_INT 35
93593: PUSH
93594: LD_INT 36
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 101
93622: PUSH
93623: LD_INT 102
93625: PUSH
93626: LD_INT 103
93628: PUSH
93629: LD_INT 106
93631: PUSH
93632: LD_INT 108
93634: PUSH
93635: LD_INT 112
93637: PUSH
93638: LD_INT 113
93640: PUSH
93641: LD_INT 114
93643: PUSH
93644: LD_INT 115
93646: PUSH
93647: LD_INT 116
93649: PUSH
93650: LD_INT 117
93652: PUSH
93653: LD_INT 118
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: ST_TO_ADDR
93674: GO 93917
93676: LD_INT 19
93678: DOUBLE
93679: EQUAL
93680: IFTRUE 93684
93682: GO 93916
93684: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
93685: LD_ADDR_VAR 0 2
93689: PUSH
93690: LD_INT 1
93692: PUSH
93693: LD_INT 2
93695: PUSH
93696: LD_INT 3
93698: PUSH
93699: LD_INT 4
93701: PUSH
93702: LD_INT 5
93704: PUSH
93705: LD_INT 6
93707: PUSH
93708: LD_INT 7
93710: PUSH
93711: LD_INT 8
93713: PUSH
93714: LD_INT 9
93716: PUSH
93717: LD_INT 10
93719: PUSH
93720: LD_INT 11
93722: PUSH
93723: LD_INT 12
93725: PUSH
93726: LD_INT 13
93728: PUSH
93729: LD_INT 14
93731: PUSH
93732: LD_INT 15
93734: PUSH
93735: LD_INT 16
93737: PUSH
93738: LD_INT 17
93740: PUSH
93741: LD_INT 18
93743: PUSH
93744: LD_INT 19
93746: PUSH
93747: LD_INT 20
93749: PUSH
93750: LD_INT 21
93752: PUSH
93753: LD_INT 22
93755: PUSH
93756: LD_INT 23
93758: PUSH
93759: LD_INT 24
93761: PUSH
93762: LD_INT 25
93764: PUSH
93765: LD_INT 26
93767: PUSH
93768: LD_INT 27
93770: PUSH
93771: LD_INT 28
93773: PUSH
93774: LD_INT 29
93776: PUSH
93777: LD_INT 30
93779: PUSH
93780: LD_INT 31
93782: PUSH
93783: LD_INT 32
93785: PUSH
93786: LD_INT 33
93788: PUSH
93789: LD_INT 34
93791: PUSH
93792: LD_INT 35
93794: PUSH
93795: LD_INT 36
93797: PUSH
93798: EMPTY
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 101
93838: PUSH
93839: LD_INT 102
93841: PUSH
93842: LD_INT 103
93844: PUSH
93845: LD_INT 104
93847: PUSH
93848: LD_INT 105
93850: PUSH
93851: LD_INT 106
93853: PUSH
93854: LD_INT 107
93856: PUSH
93857: LD_INT 108
93859: PUSH
93860: LD_INT 109
93862: PUSH
93863: LD_INT 110
93865: PUSH
93866: LD_INT 111
93868: PUSH
93869: LD_INT 112
93871: PUSH
93872: LD_INT 113
93874: PUSH
93875: LD_INT 114
93877: PUSH
93878: LD_INT 115
93880: PUSH
93881: LD_INT 116
93883: PUSH
93884: LD_INT 117
93886: PUSH
93887: LD_INT 118
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: ST_TO_ADDR
93914: GO 93917
93916: POP
// end else
93917: GO 94148
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
93919: LD_ADDR_VAR 0 2
93923: PUSH
93924: LD_INT 1
93926: PUSH
93927: LD_INT 2
93929: PUSH
93930: LD_INT 3
93932: PUSH
93933: LD_INT 4
93935: PUSH
93936: LD_INT 5
93938: PUSH
93939: LD_INT 6
93941: PUSH
93942: LD_INT 7
93944: PUSH
93945: LD_INT 8
93947: PUSH
93948: LD_INT 9
93950: PUSH
93951: LD_INT 10
93953: PUSH
93954: LD_INT 11
93956: PUSH
93957: LD_INT 12
93959: PUSH
93960: LD_INT 13
93962: PUSH
93963: LD_INT 14
93965: PUSH
93966: LD_INT 15
93968: PUSH
93969: LD_INT 16
93971: PUSH
93972: LD_INT 17
93974: PUSH
93975: LD_INT 18
93977: PUSH
93978: LD_INT 19
93980: PUSH
93981: LD_INT 20
93983: PUSH
93984: LD_INT 21
93986: PUSH
93987: LD_INT 22
93989: PUSH
93990: LD_INT 23
93992: PUSH
93993: LD_INT 24
93995: PUSH
93996: LD_INT 25
93998: PUSH
93999: LD_INT 26
94001: PUSH
94002: LD_INT 27
94004: PUSH
94005: LD_INT 28
94007: PUSH
94008: LD_INT 29
94010: PUSH
94011: LD_INT 30
94013: PUSH
94014: LD_INT 31
94016: PUSH
94017: LD_INT 32
94019: PUSH
94020: LD_INT 33
94022: PUSH
94023: LD_INT 34
94025: PUSH
94026: LD_INT 35
94028: PUSH
94029: LD_INT 36
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 101
94072: PUSH
94073: LD_INT 102
94075: PUSH
94076: LD_INT 103
94078: PUSH
94079: LD_INT 104
94081: PUSH
94082: LD_INT 105
94084: PUSH
94085: LD_INT 106
94087: PUSH
94088: LD_INT 107
94090: PUSH
94091: LD_INT 108
94093: PUSH
94094: LD_INT 109
94096: PUSH
94097: LD_INT 110
94099: PUSH
94100: LD_INT 111
94102: PUSH
94103: LD_INT 112
94105: PUSH
94106: LD_INT 113
94108: PUSH
94109: LD_INT 114
94111: PUSH
94112: LD_INT 115
94114: PUSH
94115: LD_INT 116
94117: PUSH
94118: LD_INT 117
94120: PUSH
94121: LD_INT 118
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: ST_TO_ADDR
// if result then
94148: LD_VAR 0 2
94152: IFFALSE 94938
// begin normal :=  ;
94154: LD_ADDR_VAR 0 5
94158: PUSH
94159: LD_STRING 
94161: ST_TO_ADDR
// hardcore :=  ;
94162: LD_ADDR_VAR 0 6
94166: PUSH
94167: LD_STRING 
94169: ST_TO_ADDR
// active :=  ;
94170: LD_ADDR_VAR 0 7
94174: PUSH
94175: LD_STRING 
94177: ST_TO_ADDR
// for i = 1 to normalCounter do
94178: LD_ADDR_VAR 0 8
94182: PUSH
94183: DOUBLE
94184: LD_INT 1
94186: DEC
94187: ST_TO_ADDR
94188: LD_EXP 108
94192: PUSH
94193: FOR_TO
94194: IFFALSE 94295
// begin tmp := 0 ;
94196: LD_ADDR_VAR 0 3
94200: PUSH
94201: LD_STRING 0
94203: ST_TO_ADDR
// if result [ 1 ] then
94204: LD_VAR 0 2
94208: PUSH
94209: LD_INT 1
94211: ARRAY
94212: IFFALSE 94277
// if result [ 1 ] [ 1 ] = i then
94214: LD_VAR 0 2
94218: PUSH
94219: LD_INT 1
94221: ARRAY
94222: PUSH
94223: LD_INT 1
94225: ARRAY
94226: PUSH
94227: LD_VAR 0 8
94231: EQUAL
94232: IFFALSE 94277
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94234: LD_ADDR_VAR 0 2
94238: PUSH
94239: LD_VAR 0 2
94243: PPUSH
94244: LD_INT 1
94246: PPUSH
94247: LD_VAR 0 2
94251: PUSH
94252: LD_INT 1
94254: ARRAY
94255: PPUSH
94256: LD_INT 1
94258: PPUSH
94259: CALL_OW 3
94263: PPUSH
94264: CALL_OW 1
94268: ST_TO_ADDR
// tmp := 1 ;
94269: LD_ADDR_VAR 0 3
94273: PUSH
94274: LD_STRING 1
94276: ST_TO_ADDR
// end ; normal := normal & tmp ;
94277: LD_ADDR_VAR 0 5
94281: PUSH
94282: LD_VAR 0 5
94286: PUSH
94287: LD_VAR 0 3
94291: STR
94292: ST_TO_ADDR
// end ;
94293: GO 94193
94295: POP
94296: POP
// for i = 1 to hardcoreCounter do
94297: LD_ADDR_VAR 0 8
94301: PUSH
94302: DOUBLE
94303: LD_INT 1
94305: DEC
94306: ST_TO_ADDR
94307: LD_EXP 109
94311: PUSH
94312: FOR_TO
94313: IFFALSE 94418
// begin tmp := 0 ;
94315: LD_ADDR_VAR 0 3
94319: PUSH
94320: LD_STRING 0
94322: ST_TO_ADDR
// if result [ 2 ] then
94323: LD_VAR 0 2
94327: PUSH
94328: LD_INT 2
94330: ARRAY
94331: IFFALSE 94400
// if result [ 2 ] [ 1 ] = 100 + i then
94333: LD_VAR 0 2
94337: PUSH
94338: LD_INT 2
94340: ARRAY
94341: PUSH
94342: LD_INT 1
94344: ARRAY
94345: PUSH
94346: LD_INT 100
94348: PUSH
94349: LD_VAR 0 8
94353: PLUS
94354: EQUAL
94355: IFFALSE 94400
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94357: LD_ADDR_VAR 0 2
94361: PUSH
94362: LD_VAR 0 2
94366: PPUSH
94367: LD_INT 2
94369: PPUSH
94370: LD_VAR 0 2
94374: PUSH
94375: LD_INT 2
94377: ARRAY
94378: PPUSH
94379: LD_INT 1
94381: PPUSH
94382: CALL_OW 3
94386: PPUSH
94387: CALL_OW 1
94391: ST_TO_ADDR
// tmp := 1 ;
94392: LD_ADDR_VAR 0 3
94396: PUSH
94397: LD_STRING 1
94399: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94400: LD_ADDR_VAR 0 6
94404: PUSH
94405: LD_VAR 0 6
94409: PUSH
94410: LD_VAR 0 3
94414: STR
94415: ST_TO_ADDR
// end ;
94416: GO 94312
94418: POP
94419: POP
// if isGameLoad then
94420: LD_VAR 0 1
94424: IFFALSE 94899
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
94426: LD_ADDR_VAR 0 4
94430: PUSH
94431: LD_EXP 112
94435: PUSH
94436: LD_EXP 111
94440: PUSH
94441: LD_EXP 113
94445: PUSH
94446: LD_EXP 110
94450: PUSH
94451: LD_EXP 114
94455: PUSH
94456: LD_EXP 115
94460: PUSH
94461: LD_EXP 116
94465: PUSH
94466: LD_EXP 117
94470: PUSH
94471: LD_EXP 118
94475: PUSH
94476: LD_EXP 119
94480: PUSH
94481: LD_EXP 120
94485: PUSH
94486: LD_EXP 121
94490: PUSH
94491: LD_EXP 122
94495: PUSH
94496: LD_EXP 123
94500: PUSH
94501: LD_EXP 131
94505: PUSH
94506: LD_EXP 132
94510: PUSH
94511: LD_EXP 133
94515: PUSH
94516: LD_EXP 134
94520: PUSH
94521: LD_EXP 136
94525: PUSH
94526: LD_EXP 137
94530: PUSH
94531: LD_EXP 138
94535: PUSH
94536: LD_EXP 141
94540: PUSH
94541: LD_EXP 143
94545: PUSH
94546: LD_EXP 144
94550: PUSH
94551: LD_EXP 145
94555: PUSH
94556: LD_EXP 147
94560: PUSH
94561: LD_EXP 148
94565: PUSH
94566: LD_EXP 151
94570: PUSH
94571: LD_EXP 152
94575: PUSH
94576: LD_EXP 153
94580: PUSH
94581: LD_EXP 154
94585: PUSH
94586: LD_EXP 155
94590: PUSH
94591: LD_EXP 156
94595: PUSH
94596: LD_EXP 157
94600: PUSH
94601: LD_EXP 158
94605: PUSH
94606: LD_EXP 159
94610: PUSH
94611: LD_EXP 124
94615: PUSH
94616: LD_EXP 125
94620: PUSH
94621: LD_EXP 128
94625: PUSH
94626: LD_EXP 129
94630: PUSH
94631: LD_EXP 130
94635: PUSH
94636: LD_EXP 126
94640: PUSH
94641: LD_EXP 127
94645: PUSH
94646: LD_EXP 135
94650: PUSH
94651: LD_EXP 139
94655: PUSH
94656: LD_EXP 140
94660: PUSH
94661: LD_EXP 142
94665: PUSH
94666: LD_EXP 146
94670: PUSH
94671: LD_EXP 149
94675: PUSH
94676: LD_EXP 150
94680: PUSH
94681: LD_EXP 160
94685: PUSH
94686: LD_EXP 161
94690: PUSH
94691: LD_EXP 162
94695: PUSH
94696: LD_EXP 163
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: ST_TO_ADDR
// tmp :=  ;
94757: LD_ADDR_VAR 0 3
94761: PUSH
94762: LD_STRING 
94764: ST_TO_ADDR
// for i = 1 to normalCounter do
94765: LD_ADDR_VAR 0 8
94769: PUSH
94770: DOUBLE
94771: LD_INT 1
94773: DEC
94774: ST_TO_ADDR
94775: LD_EXP 108
94779: PUSH
94780: FOR_TO
94781: IFFALSE 94817
// begin if flags [ i ] then
94783: LD_VAR 0 4
94787: PUSH
94788: LD_VAR 0 8
94792: ARRAY
94793: IFFALSE 94815
// tmp := tmp & i & ; ;
94795: LD_ADDR_VAR 0 3
94799: PUSH
94800: LD_VAR 0 3
94804: PUSH
94805: LD_VAR 0 8
94809: STR
94810: PUSH
94811: LD_STRING ;
94813: STR
94814: ST_TO_ADDR
// end ;
94815: GO 94780
94817: POP
94818: POP
// for i = 1 to hardcoreCounter do
94819: LD_ADDR_VAR 0 8
94823: PUSH
94824: DOUBLE
94825: LD_INT 1
94827: DEC
94828: ST_TO_ADDR
94829: LD_EXP 109
94833: PUSH
94834: FOR_TO
94835: IFFALSE 94881
// begin if flags [ normalCounter + i ] then
94837: LD_VAR 0 4
94841: PUSH
94842: LD_EXP 108
94846: PUSH
94847: LD_VAR 0 8
94851: PLUS
94852: ARRAY
94853: IFFALSE 94879
// tmp := tmp & ( 100 + i ) & ; ;
94855: LD_ADDR_VAR 0 3
94859: PUSH
94860: LD_VAR 0 3
94864: PUSH
94865: LD_INT 100
94867: PUSH
94868: LD_VAR 0 8
94872: PLUS
94873: STR
94874: PUSH
94875: LD_STRING ;
94877: STR
94878: ST_TO_ADDR
// end ;
94879: GO 94834
94881: POP
94882: POP
// if tmp then
94883: LD_VAR 0 3
94887: IFFALSE 94899
// active := tmp ;
94889: LD_ADDR_VAR 0 7
94893: PUSH
94894: LD_VAR 0 3
94898: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
94899: LD_STRING getStreamItemsFromMission("
94901: PUSH
94902: LD_VAR 0 5
94906: STR
94907: PUSH
94908: LD_STRING ","
94910: STR
94911: PUSH
94912: LD_VAR 0 6
94916: STR
94917: PUSH
94918: LD_STRING ","
94920: STR
94921: PUSH
94922: LD_VAR 0 7
94926: STR
94927: PUSH
94928: LD_STRING ")
94930: STR
94931: PPUSH
94932: CALL_OW 559
// end else
94936: GO 94945
// ToLua ( getStreamItemsFromMission("","","") ) ;
94938: LD_STRING getStreamItemsFromMission("","","")
94940: PPUSH
94941: CALL_OW 559
// end ;
94945: LD_VAR 0 2
94949: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94950: LD_EXP 107
94954: PUSH
94955: LD_EXP 112
94959: AND
94960: IFFALSE 95084
94962: GO 94964
94964: DISABLE
94965: LD_INT 0
94967: PPUSH
94968: PPUSH
// begin enable ;
94969: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94970: LD_ADDR_VAR 0 2
94974: PUSH
94975: LD_INT 22
94977: PUSH
94978: LD_OWVAR 2
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 2
94989: PUSH
94990: LD_INT 34
94992: PUSH
94993: LD_INT 7
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 34
95002: PUSH
95003: LD_INT 45
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PUSH
95010: LD_INT 34
95012: PUSH
95013: LD_INT 28
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 34
95022: PUSH
95023: LD_INT 47
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PPUSH
95041: CALL_OW 69
95045: ST_TO_ADDR
// if not tmp then
95046: LD_VAR 0 2
95050: NOT
95051: IFFALSE 95055
// exit ;
95053: GO 95084
// for i in tmp do
95055: LD_ADDR_VAR 0 1
95059: PUSH
95060: LD_VAR 0 2
95064: PUSH
95065: FOR_IN
95066: IFFALSE 95082
// begin SetLives ( i , 0 ) ;
95068: LD_VAR 0 1
95072: PPUSH
95073: LD_INT 0
95075: PPUSH
95076: CALL_OW 234
// end ;
95080: GO 95065
95082: POP
95083: POP
// end ;
95084: PPOPN 2
95086: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95087: LD_EXP 107
95091: PUSH
95092: LD_EXP 113
95096: AND
95097: IFFALSE 95181
95099: GO 95101
95101: DISABLE
95102: LD_INT 0
95104: PPUSH
95105: PPUSH
// begin enable ;
95106: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95107: LD_ADDR_VAR 0 2
95111: PUSH
95112: LD_INT 22
95114: PUSH
95115: LD_OWVAR 2
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 32
95126: PUSH
95127: LD_INT 3
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PPUSH
95138: CALL_OW 69
95142: ST_TO_ADDR
// if not tmp then
95143: LD_VAR 0 2
95147: NOT
95148: IFFALSE 95152
// exit ;
95150: GO 95181
// for i in tmp do
95152: LD_ADDR_VAR 0 1
95156: PUSH
95157: LD_VAR 0 2
95161: PUSH
95162: FOR_IN
95163: IFFALSE 95179
// begin SetLives ( i , 0 ) ;
95165: LD_VAR 0 1
95169: PPUSH
95170: LD_INT 0
95172: PPUSH
95173: CALL_OW 234
// end ;
95177: GO 95162
95179: POP
95180: POP
// end ;
95181: PPOPN 2
95183: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95184: LD_EXP 107
95188: PUSH
95189: LD_EXP 110
95193: AND
95194: IFFALSE 95287
95196: GO 95198
95198: DISABLE
95199: LD_INT 0
95201: PPUSH
// begin enable ;
95202: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95203: LD_ADDR_VAR 0 1
95207: PUSH
95208: LD_INT 22
95210: PUSH
95211: LD_OWVAR 2
95215: PUSH
95216: EMPTY
95217: LIST
95218: LIST
95219: PUSH
95220: LD_INT 2
95222: PUSH
95223: LD_INT 25
95225: PUSH
95226: LD_INT 5
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 25
95235: PUSH
95236: LD_INT 9
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 25
95245: PUSH
95246: LD_INT 8
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PPUSH
95263: CALL_OW 69
95267: PUSH
95268: FOR_IN
95269: IFFALSE 95285
// begin SetClass ( i , 1 ) ;
95271: LD_VAR 0 1
95275: PPUSH
95276: LD_INT 1
95278: PPUSH
95279: CALL_OW 336
// end ;
95283: GO 95268
95285: POP
95286: POP
// end ;
95287: PPOPN 1
95289: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95290: LD_EXP 107
95294: PUSH
95295: LD_EXP 111
95299: AND
95300: PUSH
95301: LD_OWVAR 65
95305: PUSH
95306: LD_INT 7
95308: LESS
95309: AND
95310: IFFALSE 95324
95312: GO 95314
95314: DISABLE
// begin enable ;
95315: ENABLE
// game_speed := 7 ;
95316: LD_ADDR_OWVAR 65
95320: PUSH
95321: LD_INT 7
95323: ST_TO_ADDR
// end ;
95324: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95325: LD_EXP 107
95329: PUSH
95330: LD_EXP 114
95334: AND
95335: IFFALSE 95537
95337: GO 95339
95339: DISABLE
95340: LD_INT 0
95342: PPUSH
95343: PPUSH
95344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95345: LD_ADDR_VAR 0 3
95349: PUSH
95350: LD_INT 81
95352: PUSH
95353: LD_OWVAR 2
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 21
95364: PUSH
95365: LD_INT 1
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PPUSH
95376: CALL_OW 69
95380: ST_TO_ADDR
// if not tmp then
95381: LD_VAR 0 3
95385: NOT
95386: IFFALSE 95390
// exit ;
95388: GO 95537
// if tmp > 5 then
95390: LD_VAR 0 3
95394: PUSH
95395: LD_INT 5
95397: GREATER
95398: IFFALSE 95410
// k := 5 else
95400: LD_ADDR_VAR 0 2
95404: PUSH
95405: LD_INT 5
95407: ST_TO_ADDR
95408: GO 95420
// k := tmp ;
95410: LD_ADDR_VAR 0 2
95414: PUSH
95415: LD_VAR 0 3
95419: ST_TO_ADDR
// for i := 1 to k do
95420: LD_ADDR_VAR 0 1
95424: PUSH
95425: DOUBLE
95426: LD_INT 1
95428: DEC
95429: ST_TO_ADDR
95430: LD_VAR 0 2
95434: PUSH
95435: FOR_TO
95436: IFFALSE 95535
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95438: LD_VAR 0 3
95442: PUSH
95443: LD_VAR 0 1
95447: ARRAY
95448: PPUSH
95449: LD_VAR 0 1
95453: PUSH
95454: LD_INT 4
95456: MOD
95457: PUSH
95458: LD_INT 1
95460: PLUS
95461: PPUSH
95462: CALL_OW 259
95466: PUSH
95467: LD_INT 10
95469: LESS
95470: IFFALSE 95533
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95472: LD_VAR 0 3
95476: PUSH
95477: LD_VAR 0 1
95481: ARRAY
95482: PPUSH
95483: LD_VAR 0 1
95487: PUSH
95488: LD_INT 4
95490: MOD
95491: PUSH
95492: LD_INT 1
95494: PLUS
95495: PPUSH
95496: LD_VAR 0 3
95500: PUSH
95501: LD_VAR 0 1
95505: ARRAY
95506: PPUSH
95507: LD_VAR 0 1
95511: PUSH
95512: LD_INT 4
95514: MOD
95515: PUSH
95516: LD_INT 1
95518: PLUS
95519: PPUSH
95520: CALL_OW 259
95524: PUSH
95525: LD_INT 1
95527: PLUS
95528: PPUSH
95529: CALL_OW 237
95533: GO 95435
95535: POP
95536: POP
// end ;
95537: PPOPN 3
95539: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95540: LD_EXP 107
95544: PUSH
95545: LD_EXP 115
95549: AND
95550: IFFALSE 95570
95552: GO 95554
95554: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95555: LD_INT 4
95557: PPUSH
95558: LD_OWVAR 2
95562: PPUSH
95563: LD_INT 0
95565: PPUSH
95566: CALL_OW 324
95570: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95571: LD_EXP 107
95575: PUSH
95576: LD_EXP 144
95580: AND
95581: IFFALSE 95601
95583: GO 95585
95585: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95586: LD_INT 19
95588: PPUSH
95589: LD_OWVAR 2
95593: PPUSH
95594: LD_INT 0
95596: PPUSH
95597: CALL_OW 324
95601: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95602: LD_EXP 107
95606: PUSH
95607: LD_EXP 116
95611: AND
95612: IFFALSE 95714
95614: GO 95616
95616: DISABLE
95617: LD_INT 0
95619: PPUSH
95620: PPUSH
// begin enable ;
95621: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95622: LD_ADDR_VAR 0 2
95626: PUSH
95627: LD_INT 22
95629: PUSH
95630: LD_OWVAR 2
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 2
95641: PUSH
95642: LD_INT 34
95644: PUSH
95645: LD_INT 11
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 34
95654: PUSH
95655: LD_INT 30
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: LIST
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PPUSH
95671: CALL_OW 69
95675: ST_TO_ADDR
// if not tmp then
95676: LD_VAR 0 2
95680: NOT
95681: IFFALSE 95685
// exit ;
95683: GO 95714
// for i in tmp do
95685: LD_ADDR_VAR 0 1
95689: PUSH
95690: LD_VAR 0 2
95694: PUSH
95695: FOR_IN
95696: IFFALSE 95712
// begin SetLives ( i , 0 ) ;
95698: LD_VAR 0 1
95702: PPUSH
95703: LD_INT 0
95705: PPUSH
95706: CALL_OW 234
// end ;
95710: GO 95695
95712: POP
95713: POP
// end ;
95714: PPOPN 2
95716: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95717: LD_EXP 107
95721: PUSH
95722: LD_EXP 117
95726: AND
95727: IFFALSE 95747
95729: GO 95731
95731: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95732: LD_INT 32
95734: PPUSH
95735: LD_OWVAR 2
95739: PPUSH
95740: LD_INT 0
95742: PPUSH
95743: CALL_OW 324
95747: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95748: LD_EXP 107
95752: PUSH
95753: LD_EXP 118
95757: AND
95758: IFFALSE 95939
95760: GO 95762
95762: DISABLE
95763: LD_INT 0
95765: PPUSH
95766: PPUSH
95767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95768: LD_ADDR_VAR 0 2
95772: PUSH
95773: LD_INT 22
95775: PUSH
95776: LD_OWVAR 2
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 33
95787: PUSH
95788: LD_INT 3
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PPUSH
95799: CALL_OW 69
95803: ST_TO_ADDR
// if not tmp then
95804: LD_VAR 0 2
95808: NOT
95809: IFFALSE 95813
// exit ;
95811: GO 95939
// side := 0 ;
95813: LD_ADDR_VAR 0 3
95817: PUSH
95818: LD_INT 0
95820: ST_TO_ADDR
// for i := 1 to 8 do
95821: LD_ADDR_VAR 0 1
95825: PUSH
95826: DOUBLE
95827: LD_INT 1
95829: DEC
95830: ST_TO_ADDR
95831: LD_INT 8
95833: PUSH
95834: FOR_TO
95835: IFFALSE 95883
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95837: LD_OWVAR 2
95841: PUSH
95842: LD_VAR 0 1
95846: NONEQUAL
95847: PUSH
95848: LD_OWVAR 2
95852: PPUSH
95853: LD_VAR 0 1
95857: PPUSH
95858: CALL_OW 81
95862: PUSH
95863: LD_INT 2
95865: EQUAL
95866: AND
95867: IFFALSE 95881
// begin side := i ;
95869: LD_ADDR_VAR 0 3
95873: PUSH
95874: LD_VAR 0 1
95878: ST_TO_ADDR
// break ;
95879: GO 95883
// end ;
95881: GO 95834
95883: POP
95884: POP
// if not side then
95885: LD_VAR 0 3
95889: NOT
95890: IFFALSE 95894
// exit ;
95892: GO 95939
// for i := 1 to tmp do
95894: LD_ADDR_VAR 0 1
95898: PUSH
95899: DOUBLE
95900: LD_INT 1
95902: DEC
95903: ST_TO_ADDR
95904: LD_VAR 0 2
95908: PUSH
95909: FOR_TO
95910: IFFALSE 95937
// if Prob ( 60 ) then
95912: LD_INT 60
95914: PPUSH
95915: CALL_OW 13
95919: IFFALSE 95935
// SetSide ( i , side ) ;
95921: LD_VAR 0 1
95925: PPUSH
95926: LD_VAR 0 3
95930: PPUSH
95931: CALL_OW 235
95935: GO 95909
95937: POP
95938: POP
// end ;
95939: PPOPN 3
95941: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95942: LD_EXP 107
95946: PUSH
95947: LD_EXP 120
95951: AND
95952: IFFALSE 96071
95954: GO 95956
95956: DISABLE
95957: LD_INT 0
95959: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95960: LD_ADDR_VAR 0 1
95964: PUSH
95965: LD_INT 22
95967: PUSH
95968: LD_OWVAR 2
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PUSH
95977: LD_INT 21
95979: PUSH
95980: LD_INT 1
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 3
95989: PUSH
95990: LD_INT 23
95992: PUSH
95993: LD_INT 0
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: LIST
96008: PPUSH
96009: CALL_OW 69
96013: PUSH
96014: FOR_IN
96015: IFFALSE 96069
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96017: LD_VAR 0 1
96021: PPUSH
96022: CALL_OW 257
96026: PUSH
96027: LD_INT 1
96029: PUSH
96030: LD_INT 2
96032: PUSH
96033: LD_INT 3
96035: PUSH
96036: LD_INT 4
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: IN
96045: IFFALSE 96067
// SetClass ( un , rand ( 1 , 4 ) ) ;
96047: LD_VAR 0 1
96051: PPUSH
96052: LD_INT 1
96054: PPUSH
96055: LD_INT 4
96057: PPUSH
96058: CALL_OW 12
96062: PPUSH
96063: CALL_OW 336
96067: GO 96014
96069: POP
96070: POP
// end ;
96071: PPOPN 1
96073: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96074: LD_EXP 107
96078: PUSH
96079: LD_EXP 119
96083: AND
96084: IFFALSE 96163
96086: GO 96088
96088: DISABLE
96089: LD_INT 0
96091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96092: LD_ADDR_VAR 0 1
96096: PUSH
96097: LD_INT 22
96099: PUSH
96100: LD_OWVAR 2
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 21
96111: PUSH
96112: LD_INT 3
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: PUSH
96119: EMPTY
96120: LIST
96121: LIST
96122: PPUSH
96123: CALL_OW 69
96127: ST_TO_ADDR
// if not tmp then
96128: LD_VAR 0 1
96132: NOT
96133: IFFALSE 96137
// exit ;
96135: GO 96163
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96137: LD_VAR 0 1
96141: PUSH
96142: LD_INT 1
96144: PPUSH
96145: LD_VAR 0 1
96149: PPUSH
96150: CALL_OW 12
96154: ARRAY
96155: PPUSH
96156: LD_INT 100
96158: PPUSH
96159: CALL_OW 234
// end ;
96163: PPOPN 1
96165: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96166: LD_EXP 107
96170: PUSH
96171: LD_EXP 121
96175: AND
96176: IFFALSE 96274
96178: GO 96180
96180: DISABLE
96181: LD_INT 0
96183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96184: LD_ADDR_VAR 0 1
96188: PUSH
96189: LD_INT 22
96191: PUSH
96192: LD_OWVAR 2
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 21
96203: PUSH
96204: LD_INT 1
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PPUSH
96215: CALL_OW 69
96219: ST_TO_ADDR
// if not tmp then
96220: LD_VAR 0 1
96224: NOT
96225: IFFALSE 96229
// exit ;
96227: GO 96274
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96229: LD_VAR 0 1
96233: PUSH
96234: LD_INT 1
96236: PPUSH
96237: LD_VAR 0 1
96241: PPUSH
96242: CALL_OW 12
96246: ARRAY
96247: PPUSH
96248: LD_INT 1
96250: PPUSH
96251: LD_INT 4
96253: PPUSH
96254: CALL_OW 12
96258: PPUSH
96259: LD_INT 3000
96261: PPUSH
96262: LD_INT 9000
96264: PPUSH
96265: CALL_OW 12
96269: PPUSH
96270: CALL_OW 492
// end ;
96274: PPOPN 1
96276: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96277: LD_EXP 107
96281: PUSH
96282: LD_EXP 122
96286: AND
96287: IFFALSE 96307
96289: GO 96291
96291: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96292: LD_INT 1
96294: PPUSH
96295: LD_OWVAR 2
96299: PPUSH
96300: LD_INT 0
96302: PPUSH
96303: CALL_OW 324
96307: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96308: LD_EXP 107
96312: PUSH
96313: LD_EXP 123
96317: AND
96318: IFFALSE 96401
96320: GO 96322
96322: DISABLE
96323: LD_INT 0
96325: PPUSH
96326: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96327: LD_ADDR_VAR 0 2
96331: PUSH
96332: LD_INT 22
96334: PUSH
96335: LD_OWVAR 2
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 21
96346: PUSH
96347: LD_INT 3
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PPUSH
96358: CALL_OW 69
96362: ST_TO_ADDR
// if not tmp then
96363: LD_VAR 0 2
96367: NOT
96368: IFFALSE 96372
// exit ;
96370: GO 96401
// for i in tmp do
96372: LD_ADDR_VAR 0 1
96376: PUSH
96377: LD_VAR 0 2
96381: PUSH
96382: FOR_IN
96383: IFFALSE 96399
// SetBLevel ( i , 10 ) ;
96385: LD_VAR 0 1
96389: PPUSH
96390: LD_INT 10
96392: PPUSH
96393: CALL_OW 241
96397: GO 96382
96399: POP
96400: POP
// end ;
96401: PPOPN 2
96403: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96404: LD_EXP 107
96408: PUSH
96409: LD_EXP 124
96413: AND
96414: IFFALSE 96525
96416: GO 96418
96418: DISABLE
96419: LD_INT 0
96421: PPUSH
96422: PPUSH
96423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96424: LD_ADDR_VAR 0 3
96428: PUSH
96429: LD_INT 22
96431: PUSH
96432: LD_OWVAR 2
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: PUSH
96441: LD_INT 25
96443: PUSH
96444: LD_INT 1
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PPUSH
96455: CALL_OW 69
96459: ST_TO_ADDR
// if not tmp then
96460: LD_VAR 0 3
96464: NOT
96465: IFFALSE 96469
// exit ;
96467: GO 96525
// un := tmp [ rand ( 1 , tmp ) ] ;
96469: LD_ADDR_VAR 0 2
96473: PUSH
96474: LD_VAR 0 3
96478: PUSH
96479: LD_INT 1
96481: PPUSH
96482: LD_VAR 0 3
96486: PPUSH
96487: CALL_OW 12
96491: ARRAY
96492: ST_TO_ADDR
// if Crawls ( un ) then
96493: LD_VAR 0 2
96497: PPUSH
96498: CALL_OW 318
96502: IFFALSE 96513
// ComWalk ( un ) ;
96504: LD_VAR 0 2
96508: PPUSH
96509: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96513: LD_VAR 0 2
96517: PPUSH
96518: LD_INT 5
96520: PPUSH
96521: CALL_OW 336
// end ;
96525: PPOPN 3
96527: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
96528: LD_EXP 107
96532: PUSH
96533: LD_EXP 125
96537: AND
96538: PUSH
96539: LD_OWVAR 67
96543: PUSH
96544: LD_INT 4
96546: LESS
96547: AND
96548: IFFALSE 96567
96550: GO 96552
96552: DISABLE
// begin Difficulty := Difficulty + 1 ;
96553: LD_ADDR_OWVAR 67
96557: PUSH
96558: LD_OWVAR 67
96562: PUSH
96563: LD_INT 1
96565: PLUS
96566: ST_TO_ADDR
// end ;
96567: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96568: LD_EXP 107
96572: PUSH
96573: LD_EXP 126
96577: AND
96578: IFFALSE 96681
96580: GO 96582
96582: DISABLE
96583: LD_INT 0
96585: PPUSH
// begin for i := 1 to 5 do
96586: LD_ADDR_VAR 0 1
96590: PUSH
96591: DOUBLE
96592: LD_INT 1
96594: DEC
96595: ST_TO_ADDR
96596: LD_INT 5
96598: PUSH
96599: FOR_TO
96600: IFFALSE 96679
// begin uc_nation := nation_nature ;
96602: LD_ADDR_OWVAR 21
96606: PUSH
96607: LD_INT 0
96609: ST_TO_ADDR
// uc_side := 0 ;
96610: LD_ADDR_OWVAR 20
96614: PUSH
96615: LD_INT 0
96617: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96618: LD_ADDR_OWVAR 29
96622: PUSH
96623: LD_INT 12
96625: PUSH
96626: LD_INT 12
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: ST_TO_ADDR
// hc_agressivity := 20 ;
96633: LD_ADDR_OWVAR 35
96637: PUSH
96638: LD_INT 20
96640: ST_TO_ADDR
// hc_class := class_tiger ;
96641: LD_ADDR_OWVAR 28
96645: PUSH
96646: LD_INT 14
96648: ST_TO_ADDR
// hc_gallery :=  ;
96649: LD_ADDR_OWVAR 33
96653: PUSH
96654: LD_STRING 
96656: ST_TO_ADDR
// hc_name :=  ;
96657: LD_ADDR_OWVAR 26
96661: PUSH
96662: LD_STRING 
96664: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96665: CALL_OW 44
96669: PPUSH
96670: LD_INT 0
96672: PPUSH
96673: CALL_OW 51
// end ;
96677: GO 96599
96679: POP
96680: POP
// end ;
96681: PPOPN 1
96683: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96684: LD_EXP 107
96688: PUSH
96689: LD_EXP 127
96693: AND
96694: IFFALSE 96703
96696: GO 96698
96698: DISABLE
// StreamSibBomb ;
96699: CALL 96704 0 0
96703: END
// export function StreamSibBomb ; var i , x , y ; begin
96704: LD_INT 0
96706: PPUSH
96707: PPUSH
96708: PPUSH
96709: PPUSH
// result := false ;
96710: LD_ADDR_VAR 0 1
96714: PUSH
96715: LD_INT 0
96717: ST_TO_ADDR
// for i := 1 to 16 do
96718: LD_ADDR_VAR 0 2
96722: PUSH
96723: DOUBLE
96724: LD_INT 1
96726: DEC
96727: ST_TO_ADDR
96728: LD_INT 16
96730: PUSH
96731: FOR_TO
96732: IFFALSE 96931
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96734: LD_ADDR_VAR 0 3
96738: PUSH
96739: LD_INT 10
96741: PUSH
96742: LD_INT 20
96744: PUSH
96745: LD_INT 30
96747: PUSH
96748: LD_INT 40
96750: PUSH
96751: LD_INT 50
96753: PUSH
96754: LD_INT 60
96756: PUSH
96757: LD_INT 70
96759: PUSH
96760: LD_INT 80
96762: PUSH
96763: LD_INT 90
96765: PUSH
96766: LD_INT 100
96768: PUSH
96769: LD_INT 110
96771: PUSH
96772: LD_INT 120
96774: PUSH
96775: LD_INT 130
96777: PUSH
96778: LD_INT 140
96780: PUSH
96781: LD_INT 150
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 1
96803: PPUSH
96804: LD_INT 15
96806: PPUSH
96807: CALL_OW 12
96811: ARRAY
96812: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96813: LD_ADDR_VAR 0 4
96817: PUSH
96818: LD_INT 10
96820: PUSH
96821: LD_INT 20
96823: PUSH
96824: LD_INT 30
96826: PUSH
96827: LD_INT 40
96829: PUSH
96830: LD_INT 50
96832: PUSH
96833: LD_INT 60
96835: PUSH
96836: LD_INT 70
96838: PUSH
96839: LD_INT 80
96841: PUSH
96842: LD_INT 90
96844: PUSH
96845: LD_INT 100
96847: PUSH
96848: LD_INT 110
96850: PUSH
96851: LD_INT 120
96853: PUSH
96854: LD_INT 130
96856: PUSH
96857: LD_INT 140
96859: PUSH
96860: LD_INT 150
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 1
96882: PPUSH
96883: LD_INT 15
96885: PPUSH
96886: CALL_OW 12
96890: ARRAY
96891: ST_TO_ADDR
// if ValidHex ( x , y ) then
96892: LD_VAR 0 3
96896: PPUSH
96897: LD_VAR 0 4
96901: PPUSH
96902: CALL_OW 488
96906: IFFALSE 96929
// begin result := [ x , y ] ;
96908: LD_ADDR_VAR 0 1
96912: PUSH
96913: LD_VAR 0 3
96917: PUSH
96918: LD_VAR 0 4
96922: PUSH
96923: EMPTY
96924: LIST
96925: LIST
96926: ST_TO_ADDR
// break ;
96927: GO 96931
// end ; end ;
96929: GO 96731
96931: POP
96932: POP
// if result then
96933: LD_VAR 0 1
96937: IFFALSE 96997
// begin ToLua ( playSibBomb() ) ;
96939: LD_STRING playSibBomb()
96941: PPUSH
96942: CALL_OW 559
// wait ( 0 0$14 ) ;
96946: LD_INT 490
96948: PPUSH
96949: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96953: LD_VAR 0 1
96957: PUSH
96958: LD_INT 1
96960: ARRAY
96961: PPUSH
96962: LD_VAR 0 1
96966: PUSH
96967: LD_INT 2
96969: ARRAY
96970: PPUSH
96971: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96975: LD_VAR 0 1
96979: PUSH
96980: LD_INT 1
96982: ARRAY
96983: PPUSH
96984: LD_VAR 0 1
96988: PUSH
96989: LD_INT 2
96991: ARRAY
96992: PPUSH
96993: CALL_OW 429
// end ; end ;
96997: LD_VAR 0 1
97001: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97002: LD_EXP 107
97006: PUSH
97007: LD_EXP 129
97011: AND
97012: IFFALSE 97024
97014: GO 97016
97016: DISABLE
// YouLost (  ) ;
97017: LD_STRING 
97019: PPUSH
97020: CALL_OW 104
97024: END
// every 0 0$1 trigger StreamModeActive and sFog do
97025: LD_EXP 107
97029: PUSH
97030: LD_EXP 128
97034: AND
97035: IFFALSE 97049
97037: GO 97039
97039: DISABLE
// FogOff ( your_side ) ;
97040: LD_OWVAR 2
97044: PPUSH
97045: CALL_OW 344
97049: END
// every 0 0$1 trigger StreamModeActive and sSun do
97050: LD_EXP 107
97054: PUSH
97055: LD_EXP 130
97059: AND
97060: IFFALSE 97088
97062: GO 97064
97064: DISABLE
// begin solar_recharge_percent := 0 ;
97065: LD_ADDR_OWVAR 79
97069: PUSH
97070: LD_INT 0
97072: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97073: LD_INT 10500
97075: PPUSH
97076: CALL_OW 67
// solar_recharge_percent := 100 ;
97080: LD_ADDR_OWVAR 79
97084: PUSH
97085: LD_INT 100
97087: ST_TO_ADDR
// end ;
97088: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97089: LD_EXP 107
97093: PUSH
97094: LD_EXP 131
97098: AND
97099: IFFALSE 97338
97101: GO 97103
97103: DISABLE
97104: LD_INT 0
97106: PPUSH
97107: PPUSH
97108: PPUSH
// begin tmp := [ ] ;
97109: LD_ADDR_VAR 0 3
97113: PUSH
97114: EMPTY
97115: ST_TO_ADDR
// for i := 1 to 6 do
97116: LD_ADDR_VAR 0 1
97120: PUSH
97121: DOUBLE
97122: LD_INT 1
97124: DEC
97125: ST_TO_ADDR
97126: LD_INT 6
97128: PUSH
97129: FOR_TO
97130: IFFALSE 97235
// begin uc_nation := nation_nature ;
97132: LD_ADDR_OWVAR 21
97136: PUSH
97137: LD_INT 0
97139: ST_TO_ADDR
// uc_side := 0 ;
97140: LD_ADDR_OWVAR 20
97144: PUSH
97145: LD_INT 0
97147: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97148: LD_ADDR_OWVAR 29
97152: PUSH
97153: LD_INT 12
97155: PUSH
97156: LD_INT 12
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: ST_TO_ADDR
// hc_agressivity := 20 ;
97163: LD_ADDR_OWVAR 35
97167: PUSH
97168: LD_INT 20
97170: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97171: LD_ADDR_OWVAR 28
97175: PUSH
97176: LD_INT 17
97178: ST_TO_ADDR
// hc_gallery :=  ;
97179: LD_ADDR_OWVAR 33
97183: PUSH
97184: LD_STRING 
97186: ST_TO_ADDR
// hc_name :=  ;
97187: LD_ADDR_OWVAR 26
97191: PUSH
97192: LD_STRING 
97194: ST_TO_ADDR
// un := CreateHuman ;
97195: LD_ADDR_VAR 0 2
97199: PUSH
97200: CALL_OW 44
97204: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97205: LD_VAR 0 2
97209: PPUSH
97210: LD_INT 1
97212: PPUSH
97213: CALL_OW 51
// tmp := tmp ^ un ;
97217: LD_ADDR_VAR 0 3
97221: PUSH
97222: LD_VAR 0 3
97226: PUSH
97227: LD_VAR 0 2
97231: ADD
97232: ST_TO_ADDR
// end ;
97233: GO 97129
97235: POP
97236: POP
// repeat wait ( 0 0$1 ) ;
97237: LD_INT 35
97239: PPUSH
97240: CALL_OW 67
// for un in tmp do
97244: LD_ADDR_VAR 0 2
97248: PUSH
97249: LD_VAR 0 3
97253: PUSH
97254: FOR_IN
97255: IFFALSE 97329
// begin if IsDead ( un ) then
97257: LD_VAR 0 2
97261: PPUSH
97262: CALL_OW 301
97266: IFFALSE 97286
// begin tmp := tmp diff un ;
97268: LD_ADDR_VAR 0 3
97272: PUSH
97273: LD_VAR 0 3
97277: PUSH
97278: LD_VAR 0 2
97282: DIFF
97283: ST_TO_ADDR
// continue ;
97284: GO 97254
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97286: LD_VAR 0 2
97290: PPUSH
97291: LD_INT 3
97293: PUSH
97294: LD_INT 22
97296: PUSH
97297: LD_INT 0
97299: PUSH
97300: EMPTY
97301: LIST
97302: LIST
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PPUSH
97308: CALL_OW 69
97312: PPUSH
97313: LD_VAR 0 2
97317: PPUSH
97318: CALL_OW 74
97322: PPUSH
97323: CALL_OW 115
// end ;
97327: GO 97254
97329: POP
97330: POP
// until not tmp ;
97331: LD_VAR 0 3
97335: NOT
97336: IFFALSE 97237
// end ;
97338: PPOPN 3
97340: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97341: LD_EXP 107
97345: PUSH
97346: LD_EXP 132
97350: AND
97351: IFFALSE 97405
97353: GO 97355
97355: DISABLE
// begin ToLua ( displayTroll(); ) ;
97356: LD_STRING displayTroll();
97358: PPUSH
97359: CALL_OW 559
// wait ( 3 3$00 ) ;
97363: LD_INT 6300
97365: PPUSH
97366: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97370: LD_STRING hideTroll();
97372: PPUSH
97373: CALL_OW 559
// wait ( 1 1$00 ) ;
97377: LD_INT 2100
97379: PPUSH
97380: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97384: LD_STRING displayTroll();
97386: PPUSH
97387: CALL_OW 559
// wait ( 1 1$00 ) ;
97391: LD_INT 2100
97393: PPUSH
97394: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97398: LD_STRING hideTroll();
97400: PPUSH
97401: CALL_OW 559
// end ;
97405: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97406: LD_EXP 107
97410: PUSH
97411: LD_EXP 133
97415: AND
97416: IFFALSE 97479
97418: GO 97420
97420: DISABLE
97421: LD_INT 0
97423: PPUSH
// begin p := 0 ;
97424: LD_ADDR_VAR 0 1
97428: PUSH
97429: LD_INT 0
97431: ST_TO_ADDR
// repeat game_speed := 1 ;
97432: LD_ADDR_OWVAR 65
97436: PUSH
97437: LD_INT 1
97439: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97440: LD_INT 35
97442: PPUSH
97443: CALL_OW 67
// p := p + 1 ;
97447: LD_ADDR_VAR 0 1
97451: PUSH
97452: LD_VAR 0 1
97456: PUSH
97457: LD_INT 1
97459: PLUS
97460: ST_TO_ADDR
// until p >= 60 ;
97461: LD_VAR 0 1
97465: PUSH
97466: LD_INT 60
97468: GREATEREQUAL
97469: IFFALSE 97432
// game_speed := 4 ;
97471: LD_ADDR_OWVAR 65
97475: PUSH
97476: LD_INT 4
97478: ST_TO_ADDR
// end ;
97479: PPOPN 1
97481: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97482: LD_EXP 107
97486: PUSH
97487: LD_EXP 134
97491: AND
97492: IFFALSE 97638
97494: GO 97496
97496: DISABLE
97497: LD_INT 0
97499: PPUSH
97500: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97501: LD_ADDR_VAR 0 1
97505: PUSH
97506: LD_INT 22
97508: PUSH
97509: LD_OWVAR 2
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: PUSH
97518: LD_INT 2
97520: PUSH
97521: LD_INT 30
97523: PUSH
97524: LD_INT 0
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 30
97533: PUSH
97534: LD_INT 1
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: LIST
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PPUSH
97550: CALL_OW 69
97554: ST_TO_ADDR
// if not depot then
97555: LD_VAR 0 1
97559: NOT
97560: IFFALSE 97564
// exit ;
97562: GO 97638
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97564: LD_ADDR_VAR 0 2
97568: PUSH
97569: LD_VAR 0 1
97573: PUSH
97574: LD_INT 1
97576: PPUSH
97577: LD_VAR 0 1
97581: PPUSH
97582: CALL_OW 12
97586: ARRAY
97587: PPUSH
97588: CALL_OW 274
97592: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97593: LD_VAR 0 2
97597: PPUSH
97598: LD_INT 1
97600: PPUSH
97601: LD_INT 0
97603: PPUSH
97604: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97608: LD_VAR 0 2
97612: PPUSH
97613: LD_INT 2
97615: PPUSH
97616: LD_INT 0
97618: PPUSH
97619: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97623: LD_VAR 0 2
97627: PPUSH
97628: LD_INT 3
97630: PPUSH
97631: LD_INT 0
97633: PPUSH
97634: CALL_OW 277
// end ;
97638: PPOPN 2
97640: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97641: LD_EXP 107
97645: PUSH
97646: LD_EXP 135
97650: AND
97651: IFFALSE 97748
97653: GO 97655
97655: DISABLE
97656: LD_INT 0
97658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97659: LD_ADDR_VAR 0 1
97663: PUSH
97664: LD_INT 22
97666: PUSH
97667: LD_OWVAR 2
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 21
97678: PUSH
97679: LD_INT 1
97681: PUSH
97682: EMPTY
97683: LIST
97684: LIST
97685: PUSH
97686: LD_INT 3
97688: PUSH
97689: LD_INT 23
97691: PUSH
97692: LD_INT 0
97694: PUSH
97695: EMPTY
97696: LIST
97697: LIST
97698: PUSH
97699: EMPTY
97700: LIST
97701: LIST
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: LIST
97707: PPUSH
97708: CALL_OW 69
97712: ST_TO_ADDR
// if not tmp then
97713: LD_VAR 0 1
97717: NOT
97718: IFFALSE 97722
// exit ;
97720: GO 97748
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97722: LD_VAR 0 1
97726: PUSH
97727: LD_INT 1
97729: PPUSH
97730: LD_VAR 0 1
97734: PPUSH
97735: CALL_OW 12
97739: ARRAY
97740: PPUSH
97741: LD_INT 200
97743: PPUSH
97744: CALL_OW 234
// end ;
97748: PPOPN 1
97750: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97751: LD_EXP 107
97755: PUSH
97756: LD_EXP 136
97760: AND
97761: IFFALSE 97840
97763: GO 97765
97765: DISABLE
97766: LD_INT 0
97768: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97769: LD_ADDR_VAR 0 1
97773: PUSH
97774: LD_INT 22
97776: PUSH
97777: LD_OWVAR 2
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: PUSH
97786: LD_INT 21
97788: PUSH
97789: LD_INT 2
97791: PUSH
97792: EMPTY
97793: LIST
97794: LIST
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PPUSH
97800: CALL_OW 69
97804: ST_TO_ADDR
// if not tmp then
97805: LD_VAR 0 1
97809: NOT
97810: IFFALSE 97814
// exit ;
97812: GO 97840
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97814: LD_VAR 0 1
97818: PUSH
97819: LD_INT 1
97821: PPUSH
97822: LD_VAR 0 1
97826: PPUSH
97827: CALL_OW 12
97831: ARRAY
97832: PPUSH
97833: LD_INT 60
97835: PPUSH
97836: CALL_OW 234
// end ;
97840: PPOPN 1
97842: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97843: LD_EXP 107
97847: PUSH
97848: LD_EXP 137
97852: AND
97853: IFFALSE 97952
97855: GO 97857
97857: DISABLE
97858: LD_INT 0
97860: PPUSH
97861: PPUSH
// begin enable ;
97862: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97863: LD_ADDR_VAR 0 1
97867: PUSH
97868: LD_INT 22
97870: PUSH
97871: LD_OWVAR 2
97875: PUSH
97876: EMPTY
97877: LIST
97878: LIST
97879: PUSH
97880: LD_INT 61
97882: PUSH
97883: EMPTY
97884: LIST
97885: PUSH
97886: LD_INT 33
97888: PUSH
97889: LD_INT 2
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: LIST
97900: PPUSH
97901: CALL_OW 69
97905: ST_TO_ADDR
// if not tmp then
97906: LD_VAR 0 1
97910: NOT
97911: IFFALSE 97915
// exit ;
97913: GO 97952
// for i in tmp do
97915: LD_ADDR_VAR 0 2
97919: PUSH
97920: LD_VAR 0 1
97924: PUSH
97925: FOR_IN
97926: IFFALSE 97950
// if IsControledBy ( i ) then
97928: LD_VAR 0 2
97932: PPUSH
97933: CALL_OW 312
97937: IFFALSE 97948
// ComUnlink ( i ) ;
97939: LD_VAR 0 2
97943: PPUSH
97944: CALL_OW 136
97948: GO 97925
97950: POP
97951: POP
// end ;
97952: PPOPN 2
97954: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97955: LD_EXP 107
97959: PUSH
97960: LD_EXP 138
97964: AND
97965: IFFALSE 98105
97967: GO 97969
97969: DISABLE
97970: LD_INT 0
97972: PPUSH
97973: PPUSH
// begin ToLua ( displayPowell(); ) ;
97974: LD_STRING displayPowell();
97976: PPUSH
97977: CALL_OW 559
// uc_side := 0 ;
97981: LD_ADDR_OWVAR 20
97985: PUSH
97986: LD_INT 0
97988: ST_TO_ADDR
// uc_nation := 2 ;
97989: LD_ADDR_OWVAR 21
97993: PUSH
97994: LD_INT 2
97996: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97997: LD_ADDR_OWVAR 37
98001: PUSH
98002: LD_INT 14
98004: ST_TO_ADDR
// vc_engine := engine_siberite ;
98005: LD_ADDR_OWVAR 39
98009: PUSH
98010: LD_INT 3
98012: ST_TO_ADDR
// vc_control := control_apeman ;
98013: LD_ADDR_OWVAR 38
98017: PUSH
98018: LD_INT 5
98020: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98021: LD_ADDR_OWVAR 40
98025: PUSH
98026: LD_INT 29
98028: ST_TO_ADDR
// un := CreateVehicle ;
98029: LD_ADDR_VAR 0 2
98033: PUSH
98034: CALL_OW 45
98038: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98039: LD_VAR 0 2
98043: PPUSH
98044: LD_INT 1
98046: PPUSH
98047: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98051: LD_INT 35
98053: PPUSH
98054: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98058: LD_VAR 0 2
98062: PPUSH
98063: LD_INT 22
98065: PUSH
98066: LD_OWVAR 2
98070: PUSH
98071: EMPTY
98072: LIST
98073: LIST
98074: PPUSH
98075: CALL_OW 69
98079: PPUSH
98080: LD_VAR 0 2
98084: PPUSH
98085: CALL_OW 74
98089: PPUSH
98090: CALL_OW 115
// until IsDead ( un ) ;
98094: LD_VAR 0 2
98098: PPUSH
98099: CALL_OW 301
98103: IFFALSE 98051
// end ;
98105: PPOPN 2
98107: END
// every 0 0$1 trigger StreamModeActive and sStu do
98108: LD_EXP 107
98112: PUSH
98113: LD_EXP 146
98117: AND
98118: IFFALSE 98134
98120: GO 98122
98122: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98123: LD_STRING displayStucuk();
98125: PPUSH
98126: CALL_OW 559
// ResetFog ;
98130: CALL_OW 335
// end ;
98134: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98135: LD_EXP 107
98139: PUSH
98140: LD_EXP 139
98144: AND
98145: IFFALSE 98286
98147: GO 98149
98149: DISABLE
98150: LD_INT 0
98152: PPUSH
98153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98154: LD_ADDR_VAR 0 2
98158: PUSH
98159: LD_INT 22
98161: PUSH
98162: LD_OWVAR 2
98166: PUSH
98167: EMPTY
98168: LIST
98169: LIST
98170: PUSH
98171: LD_INT 21
98173: PUSH
98174: LD_INT 1
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: PUSH
98181: EMPTY
98182: LIST
98183: LIST
98184: PPUSH
98185: CALL_OW 69
98189: ST_TO_ADDR
// if not tmp then
98190: LD_VAR 0 2
98194: NOT
98195: IFFALSE 98199
// exit ;
98197: GO 98286
// un := tmp [ rand ( 1 , tmp ) ] ;
98199: LD_ADDR_VAR 0 1
98203: PUSH
98204: LD_VAR 0 2
98208: PUSH
98209: LD_INT 1
98211: PPUSH
98212: LD_VAR 0 2
98216: PPUSH
98217: CALL_OW 12
98221: ARRAY
98222: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98223: LD_VAR 0 1
98227: PPUSH
98228: LD_INT 0
98230: PPUSH
98231: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98235: LD_VAR 0 1
98239: PPUSH
98240: LD_OWVAR 3
98244: PUSH
98245: LD_VAR 0 1
98249: DIFF
98250: PPUSH
98251: LD_VAR 0 1
98255: PPUSH
98256: CALL_OW 74
98260: PPUSH
98261: CALL_OW 115
// wait ( 0 0$20 ) ;
98265: LD_INT 700
98267: PPUSH
98268: CALL_OW 67
// SetSide ( un , your_side ) ;
98272: LD_VAR 0 1
98276: PPUSH
98277: LD_OWVAR 2
98281: PPUSH
98282: CALL_OW 235
// end ;
98286: PPOPN 2
98288: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98289: LD_EXP 107
98293: PUSH
98294: LD_EXP 140
98298: AND
98299: IFFALSE 98405
98301: GO 98303
98303: DISABLE
98304: LD_INT 0
98306: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98307: LD_ADDR_VAR 0 1
98311: PUSH
98312: LD_INT 22
98314: PUSH
98315: LD_OWVAR 2
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: PUSH
98324: LD_INT 2
98326: PUSH
98327: LD_INT 30
98329: PUSH
98330: LD_INT 0
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PUSH
98337: LD_INT 30
98339: PUSH
98340: LD_INT 1
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: LIST
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PPUSH
98356: CALL_OW 69
98360: ST_TO_ADDR
// if not depot then
98361: LD_VAR 0 1
98365: NOT
98366: IFFALSE 98370
// exit ;
98368: GO 98405
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98370: LD_VAR 0 1
98374: PUSH
98375: LD_INT 1
98377: ARRAY
98378: PPUSH
98379: CALL_OW 250
98383: PPUSH
98384: LD_VAR 0 1
98388: PUSH
98389: LD_INT 1
98391: ARRAY
98392: PPUSH
98393: CALL_OW 251
98397: PPUSH
98398: LD_INT 70
98400: PPUSH
98401: CALL_OW 495
// end ;
98405: PPOPN 1
98407: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98408: LD_EXP 107
98412: PUSH
98413: LD_EXP 141
98417: AND
98418: IFFALSE 98629
98420: GO 98422
98422: DISABLE
98423: LD_INT 0
98425: PPUSH
98426: PPUSH
98427: PPUSH
98428: PPUSH
98429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98430: LD_ADDR_VAR 0 5
98434: PUSH
98435: LD_INT 22
98437: PUSH
98438: LD_OWVAR 2
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PUSH
98447: LD_INT 21
98449: PUSH
98450: LD_INT 1
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PPUSH
98461: CALL_OW 69
98465: ST_TO_ADDR
// if not tmp then
98466: LD_VAR 0 5
98470: NOT
98471: IFFALSE 98475
// exit ;
98473: GO 98629
// for i in tmp do
98475: LD_ADDR_VAR 0 1
98479: PUSH
98480: LD_VAR 0 5
98484: PUSH
98485: FOR_IN
98486: IFFALSE 98627
// begin d := rand ( 0 , 5 ) ;
98488: LD_ADDR_VAR 0 4
98492: PUSH
98493: LD_INT 0
98495: PPUSH
98496: LD_INT 5
98498: PPUSH
98499: CALL_OW 12
98503: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98504: LD_ADDR_VAR 0 2
98508: PUSH
98509: LD_VAR 0 1
98513: PPUSH
98514: CALL_OW 250
98518: PPUSH
98519: LD_VAR 0 4
98523: PPUSH
98524: LD_INT 3
98526: PPUSH
98527: LD_INT 12
98529: PPUSH
98530: CALL_OW 12
98534: PPUSH
98535: CALL_OW 272
98539: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98540: LD_ADDR_VAR 0 3
98544: PUSH
98545: LD_VAR 0 1
98549: PPUSH
98550: CALL_OW 251
98554: PPUSH
98555: LD_VAR 0 4
98559: PPUSH
98560: LD_INT 3
98562: PPUSH
98563: LD_INT 12
98565: PPUSH
98566: CALL_OW 12
98570: PPUSH
98571: CALL_OW 273
98575: ST_TO_ADDR
// if ValidHex ( x , y ) then
98576: LD_VAR 0 2
98580: PPUSH
98581: LD_VAR 0 3
98585: PPUSH
98586: CALL_OW 488
98590: IFFALSE 98625
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98592: LD_VAR 0 1
98596: PPUSH
98597: LD_VAR 0 2
98601: PPUSH
98602: LD_VAR 0 3
98606: PPUSH
98607: LD_INT 3
98609: PPUSH
98610: LD_INT 6
98612: PPUSH
98613: CALL_OW 12
98617: PPUSH
98618: LD_INT 1
98620: PPUSH
98621: CALL_OW 483
// end ;
98625: GO 98485
98627: POP
98628: POP
// end ;
98629: PPOPN 5
98631: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98632: LD_EXP 107
98636: PUSH
98637: LD_EXP 142
98641: AND
98642: IFFALSE 98736
98644: GO 98646
98646: DISABLE
98647: LD_INT 0
98649: PPUSH
98650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98651: LD_ADDR_VAR 0 2
98655: PUSH
98656: LD_INT 22
98658: PUSH
98659: LD_OWVAR 2
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PUSH
98668: LD_INT 32
98670: PUSH
98671: LD_INT 1
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 21
98680: PUSH
98681: LD_INT 2
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: LIST
98692: PPUSH
98693: CALL_OW 69
98697: ST_TO_ADDR
// if not tmp then
98698: LD_VAR 0 2
98702: NOT
98703: IFFALSE 98707
// exit ;
98705: GO 98736
// for i in tmp do
98707: LD_ADDR_VAR 0 1
98711: PUSH
98712: LD_VAR 0 2
98716: PUSH
98717: FOR_IN
98718: IFFALSE 98734
// SetFuel ( i , 0 ) ;
98720: LD_VAR 0 1
98724: PPUSH
98725: LD_INT 0
98727: PPUSH
98728: CALL_OW 240
98732: GO 98717
98734: POP
98735: POP
// end ;
98736: PPOPN 2
98738: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98739: LD_EXP 107
98743: PUSH
98744: LD_EXP 143
98748: AND
98749: IFFALSE 98815
98751: GO 98753
98753: DISABLE
98754: LD_INT 0
98756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98757: LD_ADDR_VAR 0 1
98761: PUSH
98762: LD_INT 22
98764: PUSH
98765: LD_OWVAR 2
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PUSH
98774: LD_INT 30
98776: PUSH
98777: LD_INT 29
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PPUSH
98788: CALL_OW 69
98792: ST_TO_ADDR
// if not tmp then
98793: LD_VAR 0 1
98797: NOT
98798: IFFALSE 98802
// exit ;
98800: GO 98815
// DestroyUnit ( tmp [ 1 ] ) ;
98802: LD_VAR 0 1
98806: PUSH
98807: LD_INT 1
98809: ARRAY
98810: PPUSH
98811: CALL_OW 65
// end ;
98815: PPOPN 1
98817: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98818: LD_EXP 107
98822: PUSH
98823: LD_EXP 145
98827: AND
98828: IFFALSE 98957
98830: GO 98832
98832: DISABLE
98833: LD_INT 0
98835: PPUSH
// begin uc_side := 0 ;
98836: LD_ADDR_OWVAR 20
98840: PUSH
98841: LD_INT 0
98843: ST_TO_ADDR
// uc_nation := nation_arabian ;
98844: LD_ADDR_OWVAR 21
98848: PUSH
98849: LD_INT 2
98851: ST_TO_ADDR
// hc_gallery :=  ;
98852: LD_ADDR_OWVAR 33
98856: PUSH
98857: LD_STRING 
98859: ST_TO_ADDR
// hc_name :=  ;
98860: LD_ADDR_OWVAR 26
98864: PUSH
98865: LD_STRING 
98867: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98868: LD_INT 1
98870: PPUSH
98871: LD_INT 11
98873: PPUSH
98874: LD_INT 10
98876: PPUSH
98877: CALL_OW 380
// un := CreateHuman ;
98881: LD_ADDR_VAR 0 1
98885: PUSH
98886: CALL_OW 44
98890: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98891: LD_VAR 0 1
98895: PPUSH
98896: LD_INT 1
98898: PPUSH
98899: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98903: LD_INT 35
98905: PPUSH
98906: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98910: LD_VAR 0 1
98914: PPUSH
98915: LD_INT 22
98917: PUSH
98918: LD_OWVAR 2
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: PPUSH
98927: CALL_OW 69
98931: PPUSH
98932: LD_VAR 0 1
98936: PPUSH
98937: CALL_OW 74
98941: PPUSH
98942: CALL_OW 115
// until IsDead ( un ) ;
98946: LD_VAR 0 1
98950: PPUSH
98951: CALL_OW 301
98955: IFFALSE 98903
// end ;
98957: PPOPN 1
98959: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98960: LD_EXP 107
98964: PUSH
98965: LD_EXP 147
98969: AND
98970: IFFALSE 98982
98972: GO 98974
98974: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98975: LD_STRING earthquake(getX(game), 0, 32)
98977: PPUSH
98978: CALL_OW 559
98982: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98983: LD_EXP 107
98987: PUSH
98988: LD_EXP 148
98992: AND
98993: IFFALSE 99084
98995: GO 98997
98997: DISABLE
98998: LD_INT 0
99000: PPUSH
// begin enable ;
99001: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99002: LD_ADDR_VAR 0 1
99006: PUSH
99007: LD_INT 22
99009: PUSH
99010: LD_OWVAR 2
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: PUSH
99019: LD_INT 21
99021: PUSH
99022: LD_INT 2
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: PUSH
99029: LD_INT 33
99031: PUSH
99032: LD_INT 3
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: LIST
99043: PPUSH
99044: CALL_OW 69
99048: ST_TO_ADDR
// if not tmp then
99049: LD_VAR 0 1
99053: NOT
99054: IFFALSE 99058
// exit ;
99056: GO 99084
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99058: LD_VAR 0 1
99062: PUSH
99063: LD_INT 1
99065: PPUSH
99066: LD_VAR 0 1
99070: PPUSH
99071: CALL_OW 12
99075: ARRAY
99076: PPUSH
99077: LD_INT 1
99079: PPUSH
99080: CALL_OW 234
// end ;
99084: PPOPN 1
99086: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99087: LD_EXP 107
99091: PUSH
99092: LD_EXP 149
99096: AND
99097: IFFALSE 99238
99099: GO 99101
99101: DISABLE
99102: LD_INT 0
99104: PPUSH
99105: PPUSH
99106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99107: LD_ADDR_VAR 0 3
99111: PUSH
99112: LD_INT 22
99114: PUSH
99115: LD_OWVAR 2
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: PUSH
99124: LD_INT 25
99126: PUSH
99127: LD_INT 1
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PPUSH
99138: CALL_OW 69
99142: ST_TO_ADDR
// if not tmp then
99143: LD_VAR 0 3
99147: NOT
99148: IFFALSE 99152
// exit ;
99150: GO 99238
// un := tmp [ rand ( 1 , tmp ) ] ;
99152: LD_ADDR_VAR 0 2
99156: PUSH
99157: LD_VAR 0 3
99161: PUSH
99162: LD_INT 1
99164: PPUSH
99165: LD_VAR 0 3
99169: PPUSH
99170: CALL_OW 12
99174: ARRAY
99175: ST_TO_ADDR
// if Crawls ( un ) then
99176: LD_VAR 0 2
99180: PPUSH
99181: CALL_OW 318
99185: IFFALSE 99196
// ComWalk ( un ) ;
99187: LD_VAR 0 2
99191: PPUSH
99192: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99196: LD_VAR 0 2
99200: PPUSH
99201: LD_INT 9
99203: PPUSH
99204: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99208: LD_INT 28
99210: PPUSH
99211: LD_OWVAR 2
99215: PPUSH
99216: LD_INT 2
99218: PPUSH
99219: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99223: LD_INT 29
99225: PPUSH
99226: LD_OWVAR 2
99230: PPUSH
99231: LD_INT 2
99233: PPUSH
99234: CALL_OW 322
// end ;
99238: PPOPN 3
99240: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99241: LD_EXP 107
99245: PUSH
99246: LD_EXP 150
99250: AND
99251: IFFALSE 99362
99253: GO 99255
99255: DISABLE
99256: LD_INT 0
99258: PPUSH
99259: PPUSH
99260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99261: LD_ADDR_VAR 0 3
99265: PUSH
99266: LD_INT 22
99268: PUSH
99269: LD_OWVAR 2
99273: PUSH
99274: EMPTY
99275: LIST
99276: LIST
99277: PUSH
99278: LD_INT 25
99280: PUSH
99281: LD_INT 1
99283: PUSH
99284: EMPTY
99285: LIST
99286: LIST
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PPUSH
99292: CALL_OW 69
99296: ST_TO_ADDR
// if not tmp then
99297: LD_VAR 0 3
99301: NOT
99302: IFFALSE 99306
// exit ;
99304: GO 99362
// un := tmp [ rand ( 1 , tmp ) ] ;
99306: LD_ADDR_VAR 0 2
99310: PUSH
99311: LD_VAR 0 3
99315: PUSH
99316: LD_INT 1
99318: PPUSH
99319: LD_VAR 0 3
99323: PPUSH
99324: CALL_OW 12
99328: ARRAY
99329: ST_TO_ADDR
// if Crawls ( un ) then
99330: LD_VAR 0 2
99334: PPUSH
99335: CALL_OW 318
99339: IFFALSE 99350
// ComWalk ( un ) ;
99341: LD_VAR 0 2
99345: PPUSH
99346: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99350: LD_VAR 0 2
99354: PPUSH
99355: LD_INT 8
99357: PPUSH
99358: CALL_OW 336
// end ;
99362: PPOPN 3
99364: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99365: LD_EXP 107
99369: PUSH
99370: LD_EXP 151
99374: AND
99375: IFFALSE 99519
99377: GO 99379
99379: DISABLE
99380: LD_INT 0
99382: PPUSH
99383: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99384: LD_ADDR_VAR 0 2
99388: PUSH
99389: LD_INT 22
99391: PUSH
99392: LD_OWVAR 2
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: PUSH
99401: LD_INT 21
99403: PUSH
99404: LD_INT 2
99406: PUSH
99407: EMPTY
99408: LIST
99409: LIST
99410: PUSH
99411: LD_INT 2
99413: PUSH
99414: LD_INT 34
99416: PUSH
99417: LD_INT 12
99419: PUSH
99420: EMPTY
99421: LIST
99422: LIST
99423: PUSH
99424: LD_INT 34
99426: PUSH
99427: LD_INT 51
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 34
99436: PUSH
99437: LD_INT 32
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: LIST
99454: PPUSH
99455: CALL_OW 69
99459: ST_TO_ADDR
// if not tmp then
99460: LD_VAR 0 2
99464: NOT
99465: IFFALSE 99469
// exit ;
99467: GO 99519
// for i in tmp do
99469: LD_ADDR_VAR 0 1
99473: PUSH
99474: LD_VAR 0 2
99478: PUSH
99479: FOR_IN
99480: IFFALSE 99517
// if GetCargo ( i , mat_artifact ) = 0 then
99482: LD_VAR 0 1
99486: PPUSH
99487: LD_INT 4
99489: PPUSH
99490: CALL_OW 289
99494: PUSH
99495: LD_INT 0
99497: EQUAL
99498: IFFALSE 99515
// SetCargo ( i , mat_siberit , 100 ) ;
99500: LD_VAR 0 1
99504: PPUSH
99505: LD_INT 3
99507: PPUSH
99508: LD_INT 100
99510: PPUSH
99511: CALL_OW 290
99515: GO 99479
99517: POP
99518: POP
// end ;
99519: PPOPN 2
99521: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99522: LD_EXP 107
99526: PUSH
99527: LD_EXP 152
99531: AND
99532: IFFALSE 99715
99534: GO 99536
99536: DISABLE
99537: LD_INT 0
99539: PPUSH
99540: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99541: LD_ADDR_VAR 0 2
99545: PUSH
99546: LD_INT 22
99548: PUSH
99549: LD_OWVAR 2
99553: PUSH
99554: EMPTY
99555: LIST
99556: LIST
99557: PPUSH
99558: CALL_OW 69
99562: ST_TO_ADDR
// if not tmp then
99563: LD_VAR 0 2
99567: NOT
99568: IFFALSE 99572
// exit ;
99570: GO 99715
// for i := 1 to 2 do
99572: LD_ADDR_VAR 0 1
99576: PUSH
99577: DOUBLE
99578: LD_INT 1
99580: DEC
99581: ST_TO_ADDR
99582: LD_INT 2
99584: PUSH
99585: FOR_TO
99586: IFFALSE 99713
// begin uc_side := your_side ;
99588: LD_ADDR_OWVAR 20
99592: PUSH
99593: LD_OWVAR 2
99597: ST_TO_ADDR
// uc_nation := nation_american ;
99598: LD_ADDR_OWVAR 21
99602: PUSH
99603: LD_INT 1
99605: ST_TO_ADDR
// vc_chassis := us_morphling ;
99606: LD_ADDR_OWVAR 37
99610: PUSH
99611: LD_INT 5
99613: ST_TO_ADDR
// vc_engine := engine_siberite ;
99614: LD_ADDR_OWVAR 39
99618: PUSH
99619: LD_INT 3
99621: ST_TO_ADDR
// vc_control := control_computer ;
99622: LD_ADDR_OWVAR 38
99626: PUSH
99627: LD_INT 3
99629: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99630: LD_ADDR_OWVAR 40
99634: PUSH
99635: LD_INT 10
99637: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99638: LD_VAR 0 2
99642: PUSH
99643: LD_INT 1
99645: ARRAY
99646: PPUSH
99647: CALL_OW 310
99651: NOT
99652: IFFALSE 99699
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99654: CALL_OW 45
99658: PPUSH
99659: LD_VAR 0 2
99663: PUSH
99664: LD_INT 1
99666: ARRAY
99667: PPUSH
99668: CALL_OW 250
99672: PPUSH
99673: LD_VAR 0 2
99677: PUSH
99678: LD_INT 1
99680: ARRAY
99681: PPUSH
99682: CALL_OW 251
99686: PPUSH
99687: LD_INT 12
99689: PPUSH
99690: LD_INT 1
99692: PPUSH
99693: CALL_OW 50
99697: GO 99711
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99699: CALL_OW 45
99703: PPUSH
99704: LD_INT 1
99706: PPUSH
99707: CALL_OW 51
// end ;
99711: GO 99585
99713: POP
99714: POP
// end ;
99715: PPOPN 2
99717: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99718: LD_EXP 107
99722: PUSH
99723: LD_EXP 153
99727: AND
99728: IFFALSE 99950
99730: GO 99732
99732: DISABLE
99733: LD_INT 0
99735: PPUSH
99736: PPUSH
99737: PPUSH
99738: PPUSH
99739: PPUSH
99740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99741: LD_ADDR_VAR 0 6
99745: PUSH
99746: LD_INT 22
99748: PUSH
99749: LD_OWVAR 2
99753: PUSH
99754: EMPTY
99755: LIST
99756: LIST
99757: PUSH
99758: LD_INT 21
99760: PUSH
99761: LD_INT 1
99763: PUSH
99764: EMPTY
99765: LIST
99766: LIST
99767: PUSH
99768: LD_INT 3
99770: PUSH
99771: LD_INT 23
99773: PUSH
99774: LD_INT 0
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PUSH
99781: EMPTY
99782: LIST
99783: LIST
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: LIST
99789: PPUSH
99790: CALL_OW 69
99794: ST_TO_ADDR
// if not tmp then
99795: LD_VAR 0 6
99799: NOT
99800: IFFALSE 99804
// exit ;
99802: GO 99950
// s1 := rand ( 1 , 4 ) ;
99804: LD_ADDR_VAR 0 2
99808: PUSH
99809: LD_INT 1
99811: PPUSH
99812: LD_INT 4
99814: PPUSH
99815: CALL_OW 12
99819: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99820: LD_ADDR_VAR 0 4
99824: PUSH
99825: LD_VAR 0 6
99829: PUSH
99830: LD_INT 1
99832: ARRAY
99833: PPUSH
99834: LD_VAR 0 2
99838: PPUSH
99839: CALL_OW 259
99843: ST_TO_ADDR
// if s1 = 1 then
99844: LD_VAR 0 2
99848: PUSH
99849: LD_INT 1
99851: EQUAL
99852: IFFALSE 99872
// s2 := rand ( 2 , 4 ) else
99854: LD_ADDR_VAR 0 3
99858: PUSH
99859: LD_INT 2
99861: PPUSH
99862: LD_INT 4
99864: PPUSH
99865: CALL_OW 12
99869: ST_TO_ADDR
99870: GO 99880
// s2 := 1 ;
99872: LD_ADDR_VAR 0 3
99876: PUSH
99877: LD_INT 1
99879: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99880: LD_ADDR_VAR 0 5
99884: PUSH
99885: LD_VAR 0 6
99889: PUSH
99890: LD_INT 1
99892: ARRAY
99893: PPUSH
99894: LD_VAR 0 3
99898: PPUSH
99899: CALL_OW 259
99903: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99904: LD_VAR 0 6
99908: PUSH
99909: LD_INT 1
99911: ARRAY
99912: PPUSH
99913: LD_VAR 0 2
99917: PPUSH
99918: LD_VAR 0 5
99922: PPUSH
99923: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99927: LD_VAR 0 6
99931: PUSH
99932: LD_INT 1
99934: ARRAY
99935: PPUSH
99936: LD_VAR 0 3
99940: PPUSH
99941: LD_VAR 0 4
99945: PPUSH
99946: CALL_OW 237
// end ;
99950: PPOPN 6
99952: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99953: LD_EXP 107
99957: PUSH
99958: LD_EXP 154
99962: AND
99963: IFFALSE 100042
99965: GO 99967
99967: DISABLE
99968: LD_INT 0
99970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99971: LD_ADDR_VAR 0 1
99975: PUSH
99976: LD_INT 22
99978: PUSH
99979: LD_OWVAR 2
99983: PUSH
99984: EMPTY
99985: LIST
99986: LIST
99987: PUSH
99988: LD_INT 30
99990: PUSH
99991: LD_INT 3
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PPUSH
100002: CALL_OW 69
100006: ST_TO_ADDR
// if not tmp then
100007: LD_VAR 0 1
100011: NOT
100012: IFFALSE 100016
// exit ;
100014: GO 100042
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100016: LD_VAR 0 1
100020: PUSH
100021: LD_INT 1
100023: PPUSH
100024: LD_VAR 0 1
100028: PPUSH
100029: CALL_OW 12
100033: ARRAY
100034: PPUSH
100035: LD_INT 1
100037: PPUSH
100038: CALL_OW 234
// end ;
100042: PPOPN 1
100044: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100045: LD_EXP 107
100049: PUSH
100050: LD_EXP 155
100054: AND
100055: IFFALSE 100167
100057: GO 100059
100059: DISABLE
100060: LD_INT 0
100062: PPUSH
100063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100064: LD_ADDR_VAR 0 2
100068: PUSH
100069: LD_INT 22
100071: PUSH
100072: LD_OWVAR 2
100076: PUSH
100077: EMPTY
100078: LIST
100079: LIST
100080: PUSH
100081: LD_INT 2
100083: PUSH
100084: LD_INT 30
100086: PUSH
100087: LD_INT 27
100089: PUSH
100090: EMPTY
100091: LIST
100092: LIST
100093: PUSH
100094: LD_INT 30
100096: PUSH
100097: LD_INT 26
100099: PUSH
100100: EMPTY
100101: LIST
100102: LIST
100103: PUSH
100104: LD_INT 30
100106: PUSH
100107: LD_INT 28
100109: PUSH
100110: EMPTY
100111: LIST
100112: LIST
100113: PUSH
100114: EMPTY
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: PUSH
100120: EMPTY
100121: LIST
100122: LIST
100123: PPUSH
100124: CALL_OW 69
100128: ST_TO_ADDR
// if not tmp then
100129: LD_VAR 0 2
100133: NOT
100134: IFFALSE 100138
// exit ;
100136: GO 100167
// for i in tmp do
100138: LD_ADDR_VAR 0 1
100142: PUSH
100143: LD_VAR 0 2
100147: PUSH
100148: FOR_IN
100149: IFFALSE 100165
// SetLives ( i , 1 ) ;
100151: LD_VAR 0 1
100155: PPUSH
100156: LD_INT 1
100158: PPUSH
100159: CALL_OW 234
100163: GO 100148
100165: POP
100166: POP
// end ;
100167: PPOPN 2
100169: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100170: LD_EXP 107
100174: PUSH
100175: LD_EXP 156
100179: AND
100180: IFFALSE 100467
100182: GO 100184
100184: DISABLE
100185: LD_INT 0
100187: PPUSH
100188: PPUSH
100189: PPUSH
// begin i := rand ( 1 , 7 ) ;
100190: LD_ADDR_VAR 0 1
100194: PUSH
100195: LD_INT 1
100197: PPUSH
100198: LD_INT 7
100200: PPUSH
100201: CALL_OW 12
100205: ST_TO_ADDR
// case i of 1 :
100206: LD_VAR 0 1
100210: PUSH
100211: LD_INT 1
100213: DOUBLE
100214: EQUAL
100215: IFTRUE 100219
100217: GO 100229
100219: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100220: LD_STRING earthquake(getX(game), 0, 32)
100222: PPUSH
100223: CALL_OW 559
100227: GO 100467
100229: LD_INT 2
100231: DOUBLE
100232: EQUAL
100233: IFTRUE 100237
100235: GO 100251
100237: POP
// begin ToLua ( displayStucuk(); ) ;
100238: LD_STRING displayStucuk();
100240: PPUSH
100241: CALL_OW 559
// ResetFog ;
100245: CALL_OW 335
// end ; 3 :
100249: GO 100467
100251: LD_INT 3
100253: DOUBLE
100254: EQUAL
100255: IFTRUE 100259
100257: GO 100363
100259: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100260: LD_ADDR_VAR 0 2
100264: PUSH
100265: LD_INT 22
100267: PUSH
100268: LD_OWVAR 2
100272: PUSH
100273: EMPTY
100274: LIST
100275: LIST
100276: PUSH
100277: LD_INT 25
100279: PUSH
100280: LD_INT 1
100282: PUSH
100283: EMPTY
100284: LIST
100285: LIST
100286: PUSH
100287: EMPTY
100288: LIST
100289: LIST
100290: PPUSH
100291: CALL_OW 69
100295: ST_TO_ADDR
// if not tmp then
100296: LD_VAR 0 2
100300: NOT
100301: IFFALSE 100305
// exit ;
100303: GO 100467
// un := tmp [ rand ( 1 , tmp ) ] ;
100305: LD_ADDR_VAR 0 3
100309: PUSH
100310: LD_VAR 0 2
100314: PUSH
100315: LD_INT 1
100317: PPUSH
100318: LD_VAR 0 2
100322: PPUSH
100323: CALL_OW 12
100327: ARRAY
100328: ST_TO_ADDR
// if Crawls ( un ) then
100329: LD_VAR 0 3
100333: PPUSH
100334: CALL_OW 318
100338: IFFALSE 100349
// ComWalk ( un ) ;
100340: LD_VAR 0 3
100344: PPUSH
100345: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100349: LD_VAR 0 3
100353: PPUSH
100354: LD_INT 8
100356: PPUSH
100357: CALL_OW 336
// end ; 4 :
100361: GO 100467
100363: LD_INT 4
100365: DOUBLE
100366: EQUAL
100367: IFTRUE 100371
100369: GO 100445
100371: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100372: LD_ADDR_VAR 0 2
100376: PUSH
100377: LD_INT 22
100379: PUSH
100380: LD_OWVAR 2
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 30
100391: PUSH
100392: LD_INT 29
100394: PUSH
100395: EMPTY
100396: LIST
100397: LIST
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: PPUSH
100403: CALL_OW 69
100407: ST_TO_ADDR
// if not tmp then
100408: LD_VAR 0 2
100412: NOT
100413: IFFALSE 100417
// exit ;
100415: GO 100467
// CenterNowOnUnits ( tmp [ 1 ] ) ;
100417: LD_VAR 0 2
100421: PUSH
100422: LD_INT 1
100424: ARRAY
100425: PPUSH
100426: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
100430: LD_VAR 0 2
100434: PUSH
100435: LD_INT 1
100437: ARRAY
100438: PPUSH
100439: CALL_OW 65
// end ; 5 .. 7 :
100443: GO 100467
100445: LD_INT 5
100447: DOUBLE
100448: GREATEREQUAL
100449: IFFALSE 100457
100451: LD_INT 7
100453: DOUBLE
100454: LESSEQUAL
100455: IFTRUE 100459
100457: GO 100466
100459: POP
// StreamSibBomb ; end ;
100460: CALL 96704 0 0
100464: GO 100467
100466: POP
// end ;
100467: PPOPN 3
100469: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100470: LD_EXP 107
100474: PUSH
100475: LD_EXP 157
100479: AND
100480: IFFALSE 100636
100482: GO 100484
100484: DISABLE
100485: LD_INT 0
100487: PPUSH
100488: PPUSH
100489: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100490: LD_ADDR_VAR 0 2
100494: PUSH
100495: LD_INT 81
100497: PUSH
100498: LD_OWVAR 2
100502: PUSH
100503: EMPTY
100504: LIST
100505: LIST
100506: PUSH
100507: LD_INT 2
100509: PUSH
100510: LD_INT 21
100512: PUSH
100513: LD_INT 1
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: PUSH
100520: LD_INT 21
100522: PUSH
100523: LD_INT 2
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: LIST
100534: PUSH
100535: EMPTY
100536: LIST
100537: LIST
100538: PPUSH
100539: CALL_OW 69
100543: ST_TO_ADDR
// if not tmp then
100544: LD_VAR 0 2
100548: NOT
100549: IFFALSE 100553
// exit ;
100551: GO 100636
// p := 0 ;
100553: LD_ADDR_VAR 0 3
100557: PUSH
100558: LD_INT 0
100560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100561: LD_INT 35
100563: PPUSH
100564: CALL_OW 67
// p := p + 1 ;
100568: LD_ADDR_VAR 0 3
100572: PUSH
100573: LD_VAR 0 3
100577: PUSH
100578: LD_INT 1
100580: PLUS
100581: ST_TO_ADDR
// for i in tmp do
100582: LD_ADDR_VAR 0 1
100586: PUSH
100587: LD_VAR 0 2
100591: PUSH
100592: FOR_IN
100593: IFFALSE 100624
// if GetLives ( i ) < 1000 then
100595: LD_VAR 0 1
100599: PPUSH
100600: CALL_OW 256
100604: PUSH
100605: LD_INT 1000
100607: LESS
100608: IFFALSE 100622
// SetLives ( i , 1000 ) ;
100610: LD_VAR 0 1
100614: PPUSH
100615: LD_INT 1000
100617: PPUSH
100618: CALL_OW 234
100622: GO 100592
100624: POP
100625: POP
// until p > 20 ;
100626: LD_VAR 0 3
100630: PUSH
100631: LD_INT 20
100633: GREATER
100634: IFFALSE 100561
// end ;
100636: PPOPN 3
100638: END
// every 0 0$1 trigger StreamModeActive and sTime do
100639: LD_EXP 107
100643: PUSH
100644: LD_EXP 158
100648: AND
100649: IFFALSE 100684
100651: GO 100653
100653: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100654: LD_INT 28
100656: PPUSH
100657: LD_OWVAR 2
100661: PPUSH
100662: LD_INT 2
100664: PPUSH
100665: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100669: LD_INT 30
100671: PPUSH
100672: LD_OWVAR 2
100676: PPUSH
100677: LD_INT 2
100679: PPUSH
100680: CALL_OW 322
// end ;
100684: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100685: LD_EXP 107
100689: PUSH
100690: LD_EXP 159
100694: AND
100695: IFFALSE 100816
100697: GO 100699
100699: DISABLE
100700: LD_INT 0
100702: PPUSH
100703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100704: LD_ADDR_VAR 0 2
100708: PUSH
100709: LD_INT 22
100711: PUSH
100712: LD_OWVAR 2
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: PUSH
100721: LD_INT 21
100723: PUSH
100724: LD_INT 1
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 3
100733: PUSH
100734: LD_INT 23
100736: PUSH
100737: LD_INT 0
100739: PUSH
100740: EMPTY
100741: LIST
100742: LIST
100743: PUSH
100744: EMPTY
100745: LIST
100746: LIST
100747: PUSH
100748: EMPTY
100749: LIST
100750: LIST
100751: LIST
100752: PPUSH
100753: CALL_OW 69
100757: ST_TO_ADDR
// if not tmp then
100758: LD_VAR 0 2
100762: NOT
100763: IFFALSE 100767
// exit ;
100765: GO 100816
// for i in tmp do
100767: LD_ADDR_VAR 0 1
100771: PUSH
100772: LD_VAR 0 2
100776: PUSH
100777: FOR_IN
100778: IFFALSE 100814
// begin if Crawls ( i ) then
100780: LD_VAR 0 1
100784: PPUSH
100785: CALL_OW 318
100789: IFFALSE 100800
// ComWalk ( i ) ;
100791: LD_VAR 0 1
100795: PPUSH
100796: CALL_OW 138
// SetClass ( i , 2 ) ;
100800: LD_VAR 0 1
100804: PPUSH
100805: LD_INT 2
100807: PPUSH
100808: CALL_OW 336
// end ;
100812: GO 100777
100814: POP
100815: POP
// end ;
100816: PPOPN 2
100818: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100819: LD_EXP 107
100823: PUSH
100824: LD_EXP 160
100828: AND
100829: IFFALSE 101117
100831: GO 100833
100833: DISABLE
100834: LD_INT 0
100836: PPUSH
100837: PPUSH
100838: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100839: LD_OWVAR 2
100843: PPUSH
100844: LD_INT 9
100846: PPUSH
100847: LD_INT 1
100849: PPUSH
100850: LD_INT 1
100852: PPUSH
100853: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100857: LD_INT 9
100859: PPUSH
100860: LD_OWVAR 2
100864: PPUSH
100865: CALL_OW 343
// uc_side := 9 ;
100869: LD_ADDR_OWVAR 20
100873: PUSH
100874: LD_INT 9
100876: ST_TO_ADDR
// uc_nation := 2 ;
100877: LD_ADDR_OWVAR 21
100881: PUSH
100882: LD_INT 2
100884: ST_TO_ADDR
// hc_name := Dark Warrior ;
100885: LD_ADDR_OWVAR 26
100889: PUSH
100890: LD_STRING Dark Warrior
100892: ST_TO_ADDR
// hc_gallery :=  ;
100893: LD_ADDR_OWVAR 33
100897: PUSH
100898: LD_STRING 
100900: ST_TO_ADDR
// hc_noskilllimit := true ;
100901: LD_ADDR_OWVAR 76
100905: PUSH
100906: LD_INT 1
100908: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100909: LD_ADDR_OWVAR 31
100913: PUSH
100914: LD_INT 30
100916: PUSH
100917: LD_INT 30
100919: PUSH
100920: LD_INT 30
100922: PUSH
100923: LD_INT 30
100925: PUSH
100926: EMPTY
100927: LIST
100928: LIST
100929: LIST
100930: LIST
100931: ST_TO_ADDR
// un := CreateHuman ;
100932: LD_ADDR_VAR 0 3
100936: PUSH
100937: CALL_OW 44
100941: ST_TO_ADDR
// hc_noskilllimit := false ;
100942: LD_ADDR_OWVAR 76
100946: PUSH
100947: LD_INT 0
100949: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100950: LD_VAR 0 3
100954: PPUSH
100955: LD_INT 1
100957: PPUSH
100958: CALL_OW 51
// ToLua ( playRanger() ) ;
100962: LD_STRING playRanger()
100964: PPUSH
100965: CALL_OW 559
// p := 0 ;
100969: LD_ADDR_VAR 0 2
100973: PUSH
100974: LD_INT 0
100976: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100977: LD_INT 35
100979: PPUSH
100980: CALL_OW 67
// p := p + 1 ;
100984: LD_ADDR_VAR 0 2
100988: PUSH
100989: LD_VAR 0 2
100993: PUSH
100994: LD_INT 1
100996: PLUS
100997: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100998: LD_VAR 0 3
101002: PPUSH
101003: CALL_OW 256
101007: PUSH
101008: LD_INT 1000
101010: LESS
101011: IFFALSE 101025
// SetLives ( un , 1000 ) ;
101013: LD_VAR 0 3
101017: PPUSH
101018: LD_INT 1000
101020: PPUSH
101021: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101025: LD_VAR 0 3
101029: PPUSH
101030: LD_INT 81
101032: PUSH
101033: LD_OWVAR 2
101037: PUSH
101038: EMPTY
101039: LIST
101040: LIST
101041: PUSH
101042: LD_INT 91
101044: PUSH
101045: LD_VAR 0 3
101049: PUSH
101050: LD_INT 30
101052: PUSH
101053: EMPTY
101054: LIST
101055: LIST
101056: LIST
101057: PUSH
101058: EMPTY
101059: LIST
101060: LIST
101061: PPUSH
101062: CALL_OW 69
101066: PPUSH
101067: LD_VAR 0 3
101071: PPUSH
101072: CALL_OW 74
101076: PPUSH
101077: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
101081: LD_VAR 0 2
101085: PUSH
101086: LD_INT 80
101088: GREATER
101089: PUSH
101090: LD_VAR 0 3
101094: PPUSH
101095: CALL_OW 301
101099: OR
101100: IFFALSE 100977
// if un then
101102: LD_VAR 0 3
101106: IFFALSE 101117
// RemoveUnit ( un ) ;
101108: LD_VAR 0 3
101112: PPUSH
101113: CALL_OW 64
// end ;
101117: PPOPN 3
101119: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
101120: LD_EXP 161
101124: IFFALSE 101240
101126: GO 101128
101128: DISABLE
101129: LD_INT 0
101131: PPUSH
101132: PPUSH
101133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101134: LD_ADDR_VAR 0 2
101138: PUSH
101139: LD_INT 81
101141: PUSH
101142: LD_OWVAR 2
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PUSH
101151: LD_INT 21
101153: PUSH
101154: LD_INT 1
101156: PUSH
101157: EMPTY
101158: LIST
101159: LIST
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: PPUSH
101165: CALL_OW 69
101169: ST_TO_ADDR
// ToLua ( playComputer() ) ;
101170: LD_STRING playComputer()
101172: PPUSH
101173: CALL_OW 559
// if not tmp then
101177: LD_VAR 0 2
101181: NOT
101182: IFFALSE 101186
// exit ;
101184: GO 101240
// for i in tmp do
101186: LD_ADDR_VAR 0 1
101190: PUSH
101191: LD_VAR 0 2
101195: PUSH
101196: FOR_IN
101197: IFFALSE 101238
// for j := 1 to 4 do
101199: LD_ADDR_VAR 0 3
101203: PUSH
101204: DOUBLE
101205: LD_INT 1
101207: DEC
101208: ST_TO_ADDR
101209: LD_INT 4
101211: PUSH
101212: FOR_TO
101213: IFFALSE 101234
// SetSkill ( i , j , 10 ) ;
101215: LD_VAR 0 1
101219: PPUSH
101220: LD_VAR 0 3
101224: PPUSH
101225: LD_INT 10
101227: PPUSH
101228: CALL_OW 237
101232: GO 101212
101234: POP
101235: POP
101236: GO 101196
101238: POP
101239: POP
// end ;
101240: PPOPN 3
101242: END
// every 0 0$1 trigger s30 do var i , tmp ;
101243: LD_EXP 162
101247: IFFALSE 101316
101249: GO 101251
101251: DISABLE
101252: LD_INT 0
101254: PPUSH
101255: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101256: LD_ADDR_VAR 0 2
101260: PUSH
101261: LD_INT 22
101263: PUSH
101264: LD_OWVAR 2
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PPUSH
101273: CALL_OW 69
101277: ST_TO_ADDR
// if not tmp then
101278: LD_VAR 0 2
101282: NOT
101283: IFFALSE 101287
// exit ;
101285: GO 101316
// for i in tmp do
101287: LD_ADDR_VAR 0 1
101291: PUSH
101292: LD_VAR 0 2
101296: PUSH
101297: FOR_IN
101298: IFFALSE 101314
// SetLives ( i , 300 ) ;
101300: LD_VAR 0 1
101304: PPUSH
101305: LD_INT 300
101307: PPUSH
101308: CALL_OW 234
101312: GO 101297
101314: POP
101315: POP
// end ;
101316: PPOPN 2
101318: END
// every 0 0$1 trigger s60 do var i , tmp ;
101319: LD_EXP 163
101323: IFFALSE 101392
101325: GO 101327
101327: DISABLE
101328: LD_INT 0
101330: PPUSH
101331: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101332: LD_ADDR_VAR 0 2
101336: PUSH
101337: LD_INT 22
101339: PUSH
101340: LD_OWVAR 2
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PPUSH
101349: CALL_OW 69
101353: ST_TO_ADDR
// if not tmp then
101354: LD_VAR 0 2
101358: NOT
101359: IFFALSE 101363
// exit ;
101361: GO 101392
// for i in tmp do
101363: LD_ADDR_VAR 0 1
101367: PUSH
101368: LD_VAR 0 2
101372: PUSH
101373: FOR_IN
101374: IFFALSE 101390
// SetLives ( i , 600 ) ;
101376: LD_VAR 0 1
101380: PPUSH
101381: LD_INT 600
101383: PPUSH
101384: CALL_OW 234
101388: GO 101373
101390: POP
101391: POP
// end ;
101392: PPOPN 2
101394: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101395: LD_INT 0
101397: PPUSH
// case cmd of 301 :
101398: LD_VAR 0 1
101402: PUSH
101403: LD_INT 301
101405: DOUBLE
101406: EQUAL
101407: IFTRUE 101411
101409: GO 101443
101411: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101412: LD_VAR 0 6
101416: PPUSH
101417: LD_VAR 0 7
101421: PPUSH
101422: LD_VAR 0 8
101426: PPUSH
101427: LD_VAR 0 4
101431: PPUSH
101432: LD_VAR 0 5
101436: PPUSH
101437: CALL 102652 0 5
101441: GO 101564
101443: LD_INT 302
101445: DOUBLE
101446: EQUAL
101447: IFTRUE 101451
101449: GO 101488
101451: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101452: LD_VAR 0 6
101456: PPUSH
101457: LD_VAR 0 7
101461: PPUSH
101462: LD_VAR 0 8
101466: PPUSH
101467: LD_VAR 0 9
101471: PPUSH
101472: LD_VAR 0 4
101476: PPUSH
101477: LD_VAR 0 5
101481: PPUSH
101482: CALL 102743 0 6
101486: GO 101564
101488: LD_INT 303
101490: DOUBLE
101491: EQUAL
101492: IFTRUE 101496
101494: GO 101533
101496: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101497: LD_VAR 0 6
101501: PPUSH
101502: LD_VAR 0 7
101506: PPUSH
101507: LD_VAR 0 8
101511: PPUSH
101512: LD_VAR 0 9
101516: PPUSH
101517: LD_VAR 0 4
101521: PPUSH
101522: LD_VAR 0 5
101526: PPUSH
101527: CALL 101569 0 6
101531: GO 101564
101533: LD_INT 304
101535: DOUBLE
101536: EQUAL
101537: IFTRUE 101541
101539: GO 101563
101541: POP
// hHackTeleport ( unit , x , y ) ; end ;
101542: LD_VAR 0 2
101546: PPUSH
101547: LD_VAR 0 4
101551: PPUSH
101552: LD_VAR 0 5
101556: PPUSH
101557: CALL 103336 0 3
101561: GO 101564
101563: POP
// end ;
101564: LD_VAR 0 12
101568: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101569: LD_INT 0
101571: PPUSH
101572: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101573: LD_VAR 0 1
101577: PUSH
101578: LD_INT 1
101580: LESS
101581: PUSH
101582: LD_VAR 0 1
101586: PUSH
101587: LD_INT 3
101589: GREATER
101590: OR
101591: PUSH
101592: LD_VAR 0 5
101596: PPUSH
101597: LD_VAR 0 6
101601: PPUSH
101602: CALL_OW 428
101606: OR
101607: IFFALSE 101611
// exit ;
101609: GO 102339
// uc_side := your_side ;
101611: LD_ADDR_OWVAR 20
101615: PUSH
101616: LD_OWVAR 2
101620: ST_TO_ADDR
// uc_nation := nation ;
101621: LD_ADDR_OWVAR 21
101625: PUSH
101626: LD_VAR 0 1
101630: ST_TO_ADDR
// bc_level = 1 ;
101631: LD_ADDR_OWVAR 43
101635: PUSH
101636: LD_INT 1
101638: ST_TO_ADDR
// case btype of 1 :
101639: LD_VAR 0 2
101643: PUSH
101644: LD_INT 1
101646: DOUBLE
101647: EQUAL
101648: IFTRUE 101652
101650: GO 101663
101652: POP
// bc_type := b_depot ; 2 :
101653: LD_ADDR_OWVAR 42
101657: PUSH
101658: LD_INT 0
101660: ST_TO_ADDR
101661: GO 102283
101663: LD_INT 2
101665: DOUBLE
101666: EQUAL
101667: IFTRUE 101671
101669: GO 101682
101671: POP
// bc_type := b_warehouse ; 3 :
101672: LD_ADDR_OWVAR 42
101676: PUSH
101677: LD_INT 1
101679: ST_TO_ADDR
101680: GO 102283
101682: LD_INT 3
101684: DOUBLE
101685: EQUAL
101686: IFTRUE 101690
101688: GO 101701
101690: POP
// bc_type := b_lab ; 4 .. 9 :
101691: LD_ADDR_OWVAR 42
101695: PUSH
101696: LD_INT 6
101698: ST_TO_ADDR
101699: GO 102283
101701: LD_INT 4
101703: DOUBLE
101704: GREATEREQUAL
101705: IFFALSE 101713
101707: LD_INT 9
101709: DOUBLE
101710: LESSEQUAL
101711: IFTRUE 101715
101713: GO 101775
101715: POP
// begin bc_type := b_lab_half ;
101716: LD_ADDR_OWVAR 42
101720: PUSH
101721: LD_INT 7
101723: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101724: LD_ADDR_OWVAR 44
101728: PUSH
101729: LD_INT 10
101731: PUSH
101732: LD_INT 11
101734: PUSH
101735: LD_INT 12
101737: PUSH
101738: LD_INT 15
101740: PUSH
101741: LD_INT 14
101743: PUSH
101744: LD_INT 13
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: PUSH
101755: LD_VAR 0 2
101759: PUSH
101760: LD_INT 3
101762: MINUS
101763: ARRAY
101764: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
101765: LD_ADDR_OWVAR 45
101769: PUSH
101770: LD_INT 9
101772: ST_TO_ADDR
// end ; 10 .. 13 :
101773: GO 102283
101775: LD_INT 10
101777: DOUBLE
101778: GREATEREQUAL
101779: IFFALSE 101787
101781: LD_INT 13
101783: DOUBLE
101784: LESSEQUAL
101785: IFTRUE 101789
101787: GO 101866
101789: POP
// begin bc_type := b_lab_full ;
101790: LD_ADDR_OWVAR 42
101794: PUSH
101795: LD_INT 8
101797: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101798: LD_ADDR_OWVAR 44
101802: PUSH
101803: LD_INT 10
101805: PUSH
101806: LD_INT 12
101808: PUSH
101809: LD_INT 14
101811: PUSH
101812: LD_INT 13
101814: PUSH
101815: EMPTY
101816: LIST
101817: LIST
101818: LIST
101819: LIST
101820: PUSH
101821: LD_VAR 0 2
101825: PUSH
101826: LD_INT 9
101828: MINUS
101829: ARRAY
101830: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101831: LD_ADDR_OWVAR 45
101835: PUSH
101836: LD_INT 11
101838: PUSH
101839: LD_INT 15
101841: PUSH
101842: LD_INT 12
101844: PUSH
101845: LD_INT 15
101847: PUSH
101848: EMPTY
101849: LIST
101850: LIST
101851: LIST
101852: LIST
101853: PUSH
101854: LD_VAR 0 2
101858: PUSH
101859: LD_INT 9
101861: MINUS
101862: ARRAY
101863: ST_TO_ADDR
// end ; 14 :
101864: GO 102283
101866: LD_INT 14
101868: DOUBLE
101869: EQUAL
101870: IFTRUE 101874
101872: GO 101885
101874: POP
// bc_type := b_workshop ; 15 :
101875: LD_ADDR_OWVAR 42
101879: PUSH
101880: LD_INT 2
101882: ST_TO_ADDR
101883: GO 102283
101885: LD_INT 15
101887: DOUBLE
101888: EQUAL
101889: IFTRUE 101893
101891: GO 101904
101893: POP
// bc_type := b_factory ; 16 :
101894: LD_ADDR_OWVAR 42
101898: PUSH
101899: LD_INT 3
101901: ST_TO_ADDR
101902: GO 102283
101904: LD_INT 16
101906: DOUBLE
101907: EQUAL
101908: IFTRUE 101912
101910: GO 101923
101912: POP
// bc_type := b_ext_gun ; 17 :
101913: LD_ADDR_OWVAR 42
101917: PUSH
101918: LD_INT 17
101920: ST_TO_ADDR
101921: GO 102283
101923: LD_INT 17
101925: DOUBLE
101926: EQUAL
101927: IFTRUE 101931
101929: GO 101959
101931: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101932: LD_ADDR_OWVAR 42
101936: PUSH
101937: LD_INT 19
101939: PUSH
101940: LD_INT 23
101942: PUSH
101943: LD_INT 19
101945: PUSH
101946: EMPTY
101947: LIST
101948: LIST
101949: LIST
101950: PUSH
101951: LD_VAR 0 1
101955: ARRAY
101956: ST_TO_ADDR
101957: GO 102283
101959: LD_INT 18
101961: DOUBLE
101962: EQUAL
101963: IFTRUE 101967
101965: GO 101978
101967: POP
// bc_type := b_ext_radar ; 19 :
101968: LD_ADDR_OWVAR 42
101972: PUSH
101973: LD_INT 20
101975: ST_TO_ADDR
101976: GO 102283
101978: LD_INT 19
101980: DOUBLE
101981: EQUAL
101982: IFTRUE 101986
101984: GO 101997
101986: POP
// bc_type := b_ext_radio ; 20 :
101987: LD_ADDR_OWVAR 42
101991: PUSH
101992: LD_INT 22
101994: ST_TO_ADDR
101995: GO 102283
101997: LD_INT 20
101999: DOUBLE
102000: EQUAL
102001: IFTRUE 102005
102003: GO 102016
102005: POP
// bc_type := b_ext_siberium ; 21 :
102006: LD_ADDR_OWVAR 42
102010: PUSH
102011: LD_INT 21
102013: ST_TO_ADDR
102014: GO 102283
102016: LD_INT 21
102018: DOUBLE
102019: EQUAL
102020: IFTRUE 102024
102022: GO 102035
102024: POP
// bc_type := b_ext_computer ; 22 :
102025: LD_ADDR_OWVAR 42
102029: PUSH
102030: LD_INT 24
102032: ST_TO_ADDR
102033: GO 102283
102035: LD_INT 22
102037: DOUBLE
102038: EQUAL
102039: IFTRUE 102043
102041: GO 102054
102043: POP
// bc_type := b_ext_track ; 23 :
102044: LD_ADDR_OWVAR 42
102048: PUSH
102049: LD_INT 16
102051: ST_TO_ADDR
102052: GO 102283
102054: LD_INT 23
102056: DOUBLE
102057: EQUAL
102058: IFTRUE 102062
102060: GO 102073
102062: POP
// bc_type := b_ext_laser ; 24 :
102063: LD_ADDR_OWVAR 42
102067: PUSH
102068: LD_INT 25
102070: ST_TO_ADDR
102071: GO 102283
102073: LD_INT 24
102075: DOUBLE
102076: EQUAL
102077: IFTRUE 102081
102079: GO 102092
102081: POP
// bc_type := b_control_tower ; 25 :
102082: LD_ADDR_OWVAR 42
102086: PUSH
102087: LD_INT 36
102089: ST_TO_ADDR
102090: GO 102283
102092: LD_INT 25
102094: DOUBLE
102095: EQUAL
102096: IFTRUE 102100
102098: GO 102111
102100: POP
// bc_type := b_breastwork ; 26 :
102101: LD_ADDR_OWVAR 42
102105: PUSH
102106: LD_INT 31
102108: ST_TO_ADDR
102109: GO 102283
102111: LD_INT 26
102113: DOUBLE
102114: EQUAL
102115: IFTRUE 102119
102117: GO 102130
102119: POP
// bc_type := b_bunker ; 27 :
102120: LD_ADDR_OWVAR 42
102124: PUSH
102125: LD_INT 32
102127: ST_TO_ADDR
102128: GO 102283
102130: LD_INT 27
102132: DOUBLE
102133: EQUAL
102134: IFTRUE 102138
102136: GO 102149
102138: POP
// bc_type := b_turret ; 28 :
102139: LD_ADDR_OWVAR 42
102143: PUSH
102144: LD_INT 33
102146: ST_TO_ADDR
102147: GO 102283
102149: LD_INT 28
102151: DOUBLE
102152: EQUAL
102153: IFTRUE 102157
102155: GO 102168
102157: POP
// bc_type := b_armoury ; 29 :
102158: LD_ADDR_OWVAR 42
102162: PUSH
102163: LD_INT 4
102165: ST_TO_ADDR
102166: GO 102283
102168: LD_INT 29
102170: DOUBLE
102171: EQUAL
102172: IFTRUE 102176
102174: GO 102187
102176: POP
// bc_type := b_barracks ; 30 :
102177: LD_ADDR_OWVAR 42
102181: PUSH
102182: LD_INT 5
102184: ST_TO_ADDR
102185: GO 102283
102187: LD_INT 30
102189: DOUBLE
102190: EQUAL
102191: IFTRUE 102195
102193: GO 102206
102195: POP
// bc_type := b_solar_power ; 31 :
102196: LD_ADDR_OWVAR 42
102200: PUSH
102201: LD_INT 27
102203: ST_TO_ADDR
102204: GO 102283
102206: LD_INT 31
102208: DOUBLE
102209: EQUAL
102210: IFTRUE 102214
102212: GO 102225
102214: POP
// bc_type := b_oil_power ; 32 :
102215: LD_ADDR_OWVAR 42
102219: PUSH
102220: LD_INT 26
102222: ST_TO_ADDR
102223: GO 102283
102225: LD_INT 32
102227: DOUBLE
102228: EQUAL
102229: IFTRUE 102233
102231: GO 102244
102233: POP
// bc_type := b_siberite_power ; 33 :
102234: LD_ADDR_OWVAR 42
102238: PUSH
102239: LD_INT 28
102241: ST_TO_ADDR
102242: GO 102283
102244: LD_INT 33
102246: DOUBLE
102247: EQUAL
102248: IFTRUE 102252
102250: GO 102263
102252: POP
// bc_type := b_oil_mine ; 34 :
102253: LD_ADDR_OWVAR 42
102257: PUSH
102258: LD_INT 29
102260: ST_TO_ADDR
102261: GO 102283
102263: LD_INT 34
102265: DOUBLE
102266: EQUAL
102267: IFTRUE 102271
102269: GO 102282
102271: POP
// bc_type := b_siberite_mine ; end ;
102272: LD_ADDR_OWVAR 42
102276: PUSH
102277: LD_INT 30
102279: ST_TO_ADDR
102280: GO 102283
102282: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102283: LD_ADDR_VAR 0 8
102287: PUSH
102288: LD_VAR 0 5
102292: PPUSH
102293: LD_VAR 0 6
102297: PPUSH
102298: LD_VAR 0 3
102302: PPUSH
102303: CALL_OW 47
102307: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102308: LD_OWVAR 42
102312: PUSH
102313: LD_INT 32
102315: PUSH
102316: LD_INT 33
102318: PUSH
102319: EMPTY
102320: LIST
102321: LIST
102322: IN
102323: IFFALSE 102339
// PlaceWeaponTurret ( b , weapon ) ;
102325: LD_VAR 0 8
102329: PPUSH
102330: LD_VAR 0 4
102334: PPUSH
102335: CALL_OW 431
// end ;
102339: LD_VAR 0 7
102343: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102344: LD_INT 0
102346: PPUSH
102347: PPUSH
102348: PPUSH
102349: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102350: LD_ADDR_VAR 0 4
102354: PUSH
102355: LD_INT 22
102357: PUSH
102358: LD_OWVAR 2
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: PUSH
102367: LD_INT 2
102369: PUSH
102370: LD_INT 30
102372: PUSH
102373: LD_INT 0
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: PUSH
102380: LD_INT 30
102382: PUSH
102383: LD_INT 1
102385: PUSH
102386: EMPTY
102387: LIST
102388: LIST
102389: PUSH
102390: EMPTY
102391: LIST
102392: LIST
102393: LIST
102394: PUSH
102395: EMPTY
102396: LIST
102397: LIST
102398: PPUSH
102399: CALL_OW 69
102403: ST_TO_ADDR
// if not tmp then
102404: LD_VAR 0 4
102408: NOT
102409: IFFALSE 102413
// exit ;
102411: GO 102472
// for i in tmp do
102413: LD_ADDR_VAR 0 2
102417: PUSH
102418: LD_VAR 0 4
102422: PUSH
102423: FOR_IN
102424: IFFALSE 102470
// for j = 1 to 3 do
102426: LD_ADDR_VAR 0 3
102430: PUSH
102431: DOUBLE
102432: LD_INT 1
102434: DEC
102435: ST_TO_ADDR
102436: LD_INT 3
102438: PUSH
102439: FOR_TO
102440: IFFALSE 102466
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102442: LD_VAR 0 2
102446: PPUSH
102447: CALL_OW 274
102451: PPUSH
102452: LD_VAR 0 3
102456: PPUSH
102457: LD_INT 99999
102459: PPUSH
102460: CALL_OW 277
102464: GO 102439
102466: POP
102467: POP
102468: GO 102423
102470: POP
102471: POP
// end ;
102472: LD_VAR 0 1
102476: RET
// export function hHackSetLevel10 ; var i , j ; begin
102477: LD_INT 0
102479: PPUSH
102480: PPUSH
102481: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102482: LD_ADDR_VAR 0 2
102486: PUSH
102487: LD_INT 21
102489: PUSH
102490: LD_INT 1
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PPUSH
102497: CALL_OW 69
102501: PUSH
102502: FOR_IN
102503: IFFALSE 102555
// if IsSelected ( i ) then
102505: LD_VAR 0 2
102509: PPUSH
102510: CALL_OW 306
102514: IFFALSE 102553
// begin for j := 1 to 4 do
102516: LD_ADDR_VAR 0 3
102520: PUSH
102521: DOUBLE
102522: LD_INT 1
102524: DEC
102525: ST_TO_ADDR
102526: LD_INT 4
102528: PUSH
102529: FOR_TO
102530: IFFALSE 102551
// SetSkill ( i , j , 10 ) ;
102532: LD_VAR 0 2
102536: PPUSH
102537: LD_VAR 0 3
102541: PPUSH
102542: LD_INT 10
102544: PPUSH
102545: CALL_OW 237
102549: GO 102529
102551: POP
102552: POP
// end ;
102553: GO 102502
102555: POP
102556: POP
// end ;
102557: LD_VAR 0 1
102561: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102562: LD_INT 0
102564: PPUSH
102565: PPUSH
102566: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102567: LD_ADDR_VAR 0 2
102571: PUSH
102572: LD_INT 22
102574: PUSH
102575: LD_OWVAR 2
102579: PUSH
102580: EMPTY
102581: LIST
102582: LIST
102583: PUSH
102584: LD_INT 21
102586: PUSH
102587: LD_INT 1
102589: PUSH
102590: EMPTY
102591: LIST
102592: LIST
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: PPUSH
102598: CALL_OW 69
102602: PUSH
102603: FOR_IN
102604: IFFALSE 102645
// begin for j := 1 to 4 do
102606: LD_ADDR_VAR 0 3
102610: PUSH
102611: DOUBLE
102612: LD_INT 1
102614: DEC
102615: ST_TO_ADDR
102616: LD_INT 4
102618: PUSH
102619: FOR_TO
102620: IFFALSE 102641
// SetSkill ( i , j , 10 ) ;
102622: LD_VAR 0 2
102626: PPUSH
102627: LD_VAR 0 3
102631: PPUSH
102632: LD_INT 10
102634: PPUSH
102635: CALL_OW 237
102639: GO 102619
102641: POP
102642: POP
// end ;
102643: GO 102603
102645: POP
102646: POP
// end ;
102647: LD_VAR 0 1
102651: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102652: LD_INT 0
102654: PPUSH
// uc_side := your_side ;
102655: LD_ADDR_OWVAR 20
102659: PUSH
102660: LD_OWVAR 2
102664: ST_TO_ADDR
// uc_nation := nation ;
102665: LD_ADDR_OWVAR 21
102669: PUSH
102670: LD_VAR 0 1
102674: ST_TO_ADDR
// InitHc ;
102675: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102679: LD_INT 0
102681: PPUSH
102682: LD_VAR 0 2
102686: PPUSH
102687: LD_VAR 0 3
102691: PPUSH
102692: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102696: LD_VAR 0 4
102700: PPUSH
102701: LD_VAR 0 5
102705: PPUSH
102706: CALL_OW 428
102710: PUSH
102711: LD_INT 0
102713: EQUAL
102714: IFFALSE 102738
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102716: CALL_OW 44
102720: PPUSH
102721: LD_VAR 0 4
102725: PPUSH
102726: LD_VAR 0 5
102730: PPUSH
102731: LD_INT 1
102733: PPUSH
102734: CALL_OW 48
// end ;
102738: LD_VAR 0 6
102742: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102743: LD_INT 0
102745: PPUSH
102746: PPUSH
// uc_side := your_side ;
102747: LD_ADDR_OWVAR 20
102751: PUSH
102752: LD_OWVAR 2
102756: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102757: LD_VAR 0 1
102761: PUSH
102762: LD_INT 1
102764: PUSH
102765: LD_INT 2
102767: PUSH
102768: LD_INT 3
102770: PUSH
102771: LD_INT 4
102773: PUSH
102774: LD_INT 5
102776: PUSH
102777: EMPTY
102778: LIST
102779: LIST
102780: LIST
102781: LIST
102782: LIST
102783: IN
102784: IFFALSE 102796
// uc_nation := nation_american else
102786: LD_ADDR_OWVAR 21
102790: PUSH
102791: LD_INT 1
102793: ST_TO_ADDR
102794: GO 102839
// if chassis in [ 11 , 12 , 13 , 14 ] then
102796: LD_VAR 0 1
102800: PUSH
102801: LD_INT 11
102803: PUSH
102804: LD_INT 12
102806: PUSH
102807: LD_INT 13
102809: PUSH
102810: LD_INT 14
102812: PUSH
102813: EMPTY
102814: LIST
102815: LIST
102816: LIST
102817: LIST
102818: IN
102819: IFFALSE 102831
// uc_nation := nation_arabian else
102821: LD_ADDR_OWVAR 21
102825: PUSH
102826: LD_INT 2
102828: ST_TO_ADDR
102829: GO 102839
// uc_nation := nation_russian ;
102831: LD_ADDR_OWVAR 21
102835: PUSH
102836: LD_INT 3
102838: ST_TO_ADDR
// vc_chassis := chassis ;
102839: LD_ADDR_OWVAR 37
102843: PUSH
102844: LD_VAR 0 1
102848: ST_TO_ADDR
// vc_engine := engine ;
102849: LD_ADDR_OWVAR 39
102853: PUSH
102854: LD_VAR 0 2
102858: ST_TO_ADDR
// vc_control := control ;
102859: LD_ADDR_OWVAR 38
102863: PUSH
102864: LD_VAR 0 3
102868: ST_TO_ADDR
// vc_weapon := weapon ;
102869: LD_ADDR_OWVAR 40
102873: PUSH
102874: LD_VAR 0 4
102878: ST_TO_ADDR
// un := CreateVehicle ;
102879: LD_ADDR_VAR 0 8
102883: PUSH
102884: CALL_OW 45
102888: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102889: LD_VAR 0 8
102893: PPUSH
102894: LD_INT 0
102896: PPUSH
102897: LD_INT 5
102899: PPUSH
102900: CALL_OW 12
102904: PPUSH
102905: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102909: LD_VAR 0 8
102913: PPUSH
102914: LD_VAR 0 5
102918: PPUSH
102919: LD_VAR 0 6
102923: PPUSH
102924: LD_INT 1
102926: PPUSH
102927: CALL_OW 48
// end ;
102931: LD_VAR 0 7
102935: RET
// export hInvincible ; every 1 do
102936: GO 102938
102938: DISABLE
// hInvincible := [ ] ;
102939: LD_ADDR_EXP 164
102943: PUSH
102944: EMPTY
102945: ST_TO_ADDR
102946: END
// every 10 do var i ;
102947: GO 102949
102949: DISABLE
102950: LD_INT 0
102952: PPUSH
// begin enable ;
102953: ENABLE
// if not hInvincible then
102954: LD_EXP 164
102958: NOT
102959: IFFALSE 102963
// exit ;
102961: GO 103007
// for i in hInvincible do
102963: LD_ADDR_VAR 0 1
102967: PUSH
102968: LD_EXP 164
102972: PUSH
102973: FOR_IN
102974: IFFALSE 103005
// if GetLives ( i ) < 1000 then
102976: LD_VAR 0 1
102980: PPUSH
102981: CALL_OW 256
102985: PUSH
102986: LD_INT 1000
102988: LESS
102989: IFFALSE 103003
// SetLives ( i , 1000 ) ;
102991: LD_VAR 0 1
102995: PPUSH
102996: LD_INT 1000
102998: PPUSH
102999: CALL_OW 234
103003: GO 102973
103005: POP
103006: POP
// end ;
103007: PPOPN 1
103009: END
// export function hHackInvincible ; var i ; begin
103010: LD_INT 0
103012: PPUSH
103013: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103014: LD_ADDR_VAR 0 2
103018: PUSH
103019: LD_INT 2
103021: PUSH
103022: LD_INT 21
103024: PUSH
103025: LD_INT 1
103027: PUSH
103028: EMPTY
103029: LIST
103030: LIST
103031: PUSH
103032: LD_INT 21
103034: PUSH
103035: LD_INT 2
103037: PUSH
103038: EMPTY
103039: LIST
103040: LIST
103041: PUSH
103042: EMPTY
103043: LIST
103044: LIST
103045: LIST
103046: PPUSH
103047: CALL_OW 69
103051: PUSH
103052: FOR_IN
103053: IFFALSE 103114
// if IsSelected ( i ) then
103055: LD_VAR 0 2
103059: PPUSH
103060: CALL_OW 306
103064: IFFALSE 103112
// begin if i in hInvincible then
103066: LD_VAR 0 2
103070: PUSH
103071: LD_EXP 164
103075: IN
103076: IFFALSE 103096
// hInvincible := hInvincible diff i else
103078: LD_ADDR_EXP 164
103082: PUSH
103083: LD_EXP 164
103087: PUSH
103088: LD_VAR 0 2
103092: DIFF
103093: ST_TO_ADDR
103094: GO 103112
// hInvincible := hInvincible union i ;
103096: LD_ADDR_EXP 164
103100: PUSH
103101: LD_EXP 164
103105: PUSH
103106: LD_VAR 0 2
103110: UNION
103111: ST_TO_ADDR
// end ;
103112: GO 103052
103114: POP
103115: POP
// end ;
103116: LD_VAR 0 1
103120: RET
// export function hHackInvisible ; var i , j ; begin
103121: LD_INT 0
103123: PPUSH
103124: PPUSH
103125: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103126: LD_ADDR_VAR 0 2
103130: PUSH
103131: LD_INT 21
103133: PUSH
103134: LD_INT 1
103136: PUSH
103137: EMPTY
103138: LIST
103139: LIST
103140: PPUSH
103141: CALL_OW 69
103145: PUSH
103146: FOR_IN
103147: IFFALSE 103171
// if IsSelected ( i ) then
103149: LD_VAR 0 2
103153: PPUSH
103154: CALL_OW 306
103158: IFFALSE 103169
// ComForceInvisible ( i ) ;
103160: LD_VAR 0 2
103164: PPUSH
103165: CALL_OW 496
103169: GO 103146
103171: POP
103172: POP
// end ;
103173: LD_VAR 0 1
103177: RET
// export function hHackChangeYourSide ; begin
103178: LD_INT 0
103180: PPUSH
// if your_side = 8 then
103181: LD_OWVAR 2
103185: PUSH
103186: LD_INT 8
103188: EQUAL
103189: IFFALSE 103201
// your_side := 0 else
103191: LD_ADDR_OWVAR 2
103195: PUSH
103196: LD_INT 0
103198: ST_TO_ADDR
103199: GO 103215
// your_side := your_side + 1 ;
103201: LD_ADDR_OWVAR 2
103205: PUSH
103206: LD_OWVAR 2
103210: PUSH
103211: LD_INT 1
103213: PLUS
103214: ST_TO_ADDR
// end ;
103215: LD_VAR 0 1
103219: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103220: LD_INT 0
103222: PPUSH
103223: PPUSH
103224: PPUSH
// for i in all_units do
103225: LD_ADDR_VAR 0 2
103229: PUSH
103230: LD_OWVAR 3
103234: PUSH
103235: FOR_IN
103236: IFFALSE 103314
// if IsSelected ( i ) then
103238: LD_VAR 0 2
103242: PPUSH
103243: CALL_OW 306
103247: IFFALSE 103312
// begin j := GetSide ( i ) ;
103249: LD_ADDR_VAR 0 3
103253: PUSH
103254: LD_VAR 0 2
103258: PPUSH
103259: CALL_OW 255
103263: ST_TO_ADDR
// if j = 8 then
103264: LD_VAR 0 3
103268: PUSH
103269: LD_INT 8
103271: EQUAL
103272: IFFALSE 103284
// j := 0 else
103274: LD_ADDR_VAR 0 3
103278: PUSH
103279: LD_INT 0
103281: ST_TO_ADDR
103282: GO 103298
// j := j + 1 ;
103284: LD_ADDR_VAR 0 3
103288: PUSH
103289: LD_VAR 0 3
103293: PUSH
103294: LD_INT 1
103296: PLUS
103297: ST_TO_ADDR
// SetSide ( i , j ) ;
103298: LD_VAR 0 2
103302: PPUSH
103303: LD_VAR 0 3
103307: PPUSH
103308: CALL_OW 235
// end ;
103312: GO 103235
103314: POP
103315: POP
// end ;
103316: LD_VAR 0 1
103320: RET
// export function hHackFog ; begin
103321: LD_INT 0
103323: PPUSH
// FogOff ( true ) ;
103324: LD_INT 1
103326: PPUSH
103327: CALL_OW 344
// end ;
103331: LD_VAR 0 1
103335: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103336: LD_INT 0
103338: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103339: LD_VAR 0 1
103343: PPUSH
103344: LD_VAR 0 2
103348: PPUSH
103349: LD_VAR 0 3
103353: PPUSH
103354: LD_INT 1
103356: PPUSH
103357: LD_INT 1
103359: PPUSH
103360: CALL_OW 483
// CenterOnXY ( x , y ) ;
103364: LD_VAR 0 2
103368: PPUSH
103369: LD_VAR 0 3
103373: PPUSH
103374: CALL_OW 84
// end ;
103378: LD_VAR 0 4
103382: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
103383: LD_INT 0
103385: PPUSH
103386: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
103387: LD_VAR 0 1
103391: NOT
103392: PUSH
103393: LD_VAR 0 2
103397: PPUSH
103398: LD_VAR 0 3
103402: PPUSH
103403: CALL_OW 488
103407: NOT
103408: OR
103409: PUSH
103410: LD_VAR 0 1
103414: PPUSH
103415: CALL_OW 266
103419: PUSH
103420: LD_INT 3
103422: NONEQUAL
103423: PUSH
103424: LD_VAR 0 1
103428: PPUSH
103429: CALL_OW 247
103433: PUSH
103434: LD_INT 1
103436: EQUAL
103437: NOT
103438: AND
103439: OR
103440: IFFALSE 103444
// exit ;
103442: GO 103593
// if GetType ( factory ) = unit_human then
103444: LD_VAR 0 1
103448: PPUSH
103449: CALL_OW 247
103453: PUSH
103454: LD_INT 1
103456: EQUAL
103457: IFFALSE 103474
// factory := IsInUnit ( factory ) ;
103459: LD_ADDR_VAR 0 1
103463: PUSH
103464: LD_VAR 0 1
103468: PPUSH
103469: CALL_OW 310
103473: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
103474: LD_VAR 0 1
103478: PPUSH
103479: CALL_OW 266
103483: PUSH
103484: LD_INT 3
103486: NONEQUAL
103487: IFFALSE 103491
// exit ;
103489: GO 103593
// if HexInfo ( x , y ) = factory then
103491: LD_VAR 0 2
103495: PPUSH
103496: LD_VAR 0 3
103500: PPUSH
103501: CALL_OW 428
103505: PUSH
103506: LD_VAR 0 1
103510: EQUAL
103511: IFFALSE 103538
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
103513: LD_ADDR_EXP 165
103517: PUSH
103518: LD_EXP 165
103522: PPUSH
103523: LD_VAR 0 1
103527: PPUSH
103528: LD_INT 0
103530: PPUSH
103531: CALL_OW 1
103535: ST_TO_ADDR
103536: GO 103589
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
103538: LD_ADDR_EXP 165
103542: PUSH
103543: LD_EXP 165
103547: PPUSH
103548: LD_VAR 0 1
103552: PPUSH
103553: LD_VAR 0 1
103557: PPUSH
103558: CALL_OW 255
103562: PUSH
103563: LD_VAR 0 1
103567: PUSH
103568: LD_VAR 0 2
103572: PUSH
103573: LD_VAR 0 3
103577: PUSH
103578: EMPTY
103579: LIST
103580: LIST
103581: LIST
103582: LIST
103583: PPUSH
103584: CALL_OW 1
103588: ST_TO_ADDR
// UpdateFactoryWaypoints ;
103589: CALL 103598 0 0
// end ;
103593: LD_VAR 0 4
103597: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
103598: LD_INT 0
103600: PPUSH
103601: PPUSH
103602: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
103603: LD_STRING resetFactoryWaypoint();
103605: PPUSH
103606: CALL_OW 559
// if factoryWaypoints then
103610: LD_EXP 165
103614: IFFALSE 103740
// begin list := PrepareArray ( factoryWaypoints ) ;
103616: LD_ADDR_VAR 0 3
103620: PUSH
103621: LD_EXP 165
103625: PPUSH
103626: CALL 57479 0 1
103630: ST_TO_ADDR
// for i := 1 to list do
103631: LD_ADDR_VAR 0 2
103635: PUSH
103636: DOUBLE
103637: LD_INT 1
103639: DEC
103640: ST_TO_ADDR
103641: LD_VAR 0 3
103645: PUSH
103646: FOR_TO
103647: IFFALSE 103738
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
103649: LD_STRING setFactoryWaypointXY(
103651: PUSH
103652: LD_VAR 0 3
103656: PUSH
103657: LD_VAR 0 2
103661: ARRAY
103662: PUSH
103663: LD_INT 1
103665: ARRAY
103666: STR
103667: PUSH
103668: LD_STRING ,
103670: STR
103671: PUSH
103672: LD_VAR 0 3
103676: PUSH
103677: LD_VAR 0 2
103681: ARRAY
103682: PUSH
103683: LD_INT 2
103685: ARRAY
103686: STR
103687: PUSH
103688: LD_STRING ,
103690: STR
103691: PUSH
103692: LD_VAR 0 3
103696: PUSH
103697: LD_VAR 0 2
103701: ARRAY
103702: PUSH
103703: LD_INT 3
103705: ARRAY
103706: STR
103707: PUSH
103708: LD_STRING ,
103710: STR
103711: PUSH
103712: LD_VAR 0 3
103716: PUSH
103717: LD_VAR 0 2
103721: ARRAY
103722: PUSH
103723: LD_INT 4
103725: ARRAY
103726: STR
103727: PUSH
103728: LD_STRING )
103730: STR
103731: PPUSH
103732: CALL_OW 559
103736: GO 103646
103738: POP
103739: POP
// end ; end ;
103740: LD_VAR 0 1
103744: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
103745: LD_INT 0
103747: PPUSH
// if HexInfo ( x , y ) = warehouse then
103748: LD_VAR 0 2
103752: PPUSH
103753: LD_VAR 0 3
103757: PPUSH
103758: CALL_OW 428
103762: PUSH
103763: LD_VAR 0 1
103767: EQUAL
103768: IFFALSE 103795
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
103770: LD_ADDR_EXP 166
103774: PUSH
103775: LD_EXP 166
103779: PPUSH
103780: LD_VAR 0 1
103784: PPUSH
103785: LD_INT 0
103787: PPUSH
103788: CALL_OW 1
103792: ST_TO_ADDR
103793: GO 103846
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
103795: LD_ADDR_EXP 166
103799: PUSH
103800: LD_EXP 166
103804: PPUSH
103805: LD_VAR 0 1
103809: PPUSH
103810: LD_VAR 0 1
103814: PPUSH
103815: CALL_OW 255
103819: PUSH
103820: LD_VAR 0 1
103824: PUSH
103825: LD_VAR 0 2
103829: PUSH
103830: LD_VAR 0 3
103834: PUSH
103835: EMPTY
103836: LIST
103837: LIST
103838: LIST
103839: LIST
103840: PPUSH
103841: CALL_OW 1
103845: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
103846: CALL 103855 0 0
// end ;
103850: LD_VAR 0 4
103854: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
103855: LD_INT 0
103857: PPUSH
103858: PPUSH
103859: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
103860: LD_STRING resetWarehouseGatheringPoints();
103862: PPUSH
103863: CALL_OW 559
// if warehouseGatheringPoints then
103867: LD_EXP 166
103871: IFFALSE 103997
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
103873: LD_ADDR_VAR 0 3
103877: PUSH
103878: LD_EXP 166
103882: PPUSH
103883: CALL 57479 0 1
103887: ST_TO_ADDR
// for i := 1 to list do
103888: LD_ADDR_VAR 0 2
103892: PUSH
103893: DOUBLE
103894: LD_INT 1
103896: DEC
103897: ST_TO_ADDR
103898: LD_VAR 0 3
103902: PUSH
103903: FOR_TO
103904: IFFALSE 103995
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
103906: LD_STRING setWarehouseGatheringPointXY(
103908: PUSH
103909: LD_VAR 0 3
103913: PUSH
103914: LD_VAR 0 2
103918: ARRAY
103919: PUSH
103920: LD_INT 1
103922: ARRAY
103923: STR
103924: PUSH
103925: LD_STRING ,
103927: STR
103928: PUSH
103929: LD_VAR 0 3
103933: PUSH
103934: LD_VAR 0 2
103938: ARRAY
103939: PUSH
103940: LD_INT 2
103942: ARRAY
103943: STR
103944: PUSH
103945: LD_STRING ,
103947: STR
103948: PUSH
103949: LD_VAR 0 3
103953: PUSH
103954: LD_VAR 0 2
103958: ARRAY
103959: PUSH
103960: LD_INT 3
103962: ARRAY
103963: STR
103964: PUSH
103965: LD_STRING ,
103967: STR
103968: PUSH
103969: LD_VAR 0 3
103973: PUSH
103974: LD_VAR 0 2
103978: ARRAY
103979: PUSH
103980: LD_INT 4
103982: ARRAY
103983: STR
103984: PUSH
103985: LD_STRING )
103987: STR
103988: PPUSH
103989: CALL_OW 559
103993: GO 103903
103995: POP
103996: POP
// end ; end ;
103997: LD_VAR 0 1
104001: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104002: LD_EXP 166
104006: IFFALSE 104691
104008: GO 104010
104010: DISABLE
104011: LD_INT 0
104013: PPUSH
104014: PPUSH
104015: PPUSH
104016: PPUSH
104017: PPUSH
104018: PPUSH
104019: PPUSH
104020: PPUSH
104021: PPUSH
// begin enable ;
104022: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104023: LD_ADDR_VAR 0 3
104027: PUSH
104028: LD_EXP 166
104032: PPUSH
104033: CALL 57479 0 1
104037: ST_TO_ADDR
// if not list then
104038: LD_VAR 0 3
104042: NOT
104043: IFFALSE 104047
// exit ;
104045: GO 104691
// for i := 1 to list do
104047: LD_ADDR_VAR 0 1
104051: PUSH
104052: DOUBLE
104053: LD_INT 1
104055: DEC
104056: ST_TO_ADDR
104057: LD_VAR 0 3
104061: PUSH
104062: FOR_TO
104063: IFFALSE 104689
// begin depot := list [ i ] [ 2 ] ;
104065: LD_ADDR_VAR 0 8
104069: PUSH
104070: LD_VAR 0 3
104074: PUSH
104075: LD_VAR 0 1
104079: ARRAY
104080: PUSH
104081: LD_INT 2
104083: ARRAY
104084: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
104085: LD_ADDR_VAR 0 5
104089: PUSH
104090: LD_VAR 0 3
104094: PUSH
104095: LD_VAR 0 1
104099: ARRAY
104100: PUSH
104101: LD_INT 1
104103: ARRAY
104104: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
104105: LD_VAR 0 8
104109: PPUSH
104110: CALL_OW 301
104114: PUSH
104115: LD_VAR 0 5
104119: PUSH
104120: LD_VAR 0 8
104124: PPUSH
104125: CALL_OW 255
104129: NONEQUAL
104130: OR
104131: IFFALSE 104160
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
104133: LD_ADDR_EXP 166
104137: PUSH
104138: LD_EXP 166
104142: PPUSH
104143: LD_VAR 0 8
104147: PPUSH
104148: LD_INT 0
104150: PPUSH
104151: CALL_OW 1
104155: ST_TO_ADDR
// exit ;
104156: POP
104157: POP
104158: GO 104691
// end ; x := list [ i ] [ 3 ] ;
104160: LD_ADDR_VAR 0 6
104164: PUSH
104165: LD_VAR 0 3
104169: PUSH
104170: LD_VAR 0 1
104174: ARRAY
104175: PUSH
104176: LD_INT 3
104178: ARRAY
104179: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
104180: LD_ADDR_VAR 0 7
104184: PUSH
104185: LD_VAR 0 3
104189: PUSH
104190: LD_VAR 0 1
104194: ARRAY
104195: PUSH
104196: LD_INT 4
104198: ARRAY
104199: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
104200: LD_ADDR_VAR 0 9
104204: PUSH
104205: LD_VAR 0 6
104209: PPUSH
104210: LD_VAR 0 7
104214: PPUSH
104215: LD_INT 16
104217: PPUSH
104218: CALL 56067 0 3
104222: ST_TO_ADDR
// if not cratesNearbyPoint then
104223: LD_VAR 0 9
104227: NOT
104228: IFFALSE 104234
// exit ;
104230: POP
104231: POP
104232: GO 104691
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
104234: LD_ADDR_VAR 0 4
104238: PUSH
104239: LD_INT 22
104241: PUSH
104242: LD_VAR 0 5
104246: PUSH
104247: EMPTY
104248: LIST
104249: LIST
104250: PUSH
104251: LD_INT 3
104253: PUSH
104254: LD_INT 60
104256: PUSH
104257: EMPTY
104258: LIST
104259: PUSH
104260: EMPTY
104261: LIST
104262: LIST
104263: PUSH
104264: LD_INT 91
104266: PUSH
104267: LD_VAR 0 8
104271: PUSH
104272: LD_INT 6
104274: PUSH
104275: EMPTY
104276: LIST
104277: LIST
104278: LIST
104279: PUSH
104280: LD_INT 2
104282: PUSH
104283: LD_INT 25
104285: PUSH
104286: LD_INT 2
104288: PUSH
104289: EMPTY
104290: LIST
104291: LIST
104292: PUSH
104293: LD_INT 25
104295: PUSH
104296: LD_INT 16
104298: PUSH
104299: EMPTY
104300: LIST
104301: LIST
104302: PUSH
104303: EMPTY
104304: LIST
104305: LIST
104306: LIST
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: LIST
104312: LIST
104313: PPUSH
104314: CALL_OW 69
104318: PUSH
104319: LD_VAR 0 8
104323: PPUSH
104324: CALL_OW 313
104328: PPUSH
104329: LD_INT 3
104331: PUSH
104332: LD_INT 60
104334: PUSH
104335: EMPTY
104336: LIST
104337: PUSH
104338: EMPTY
104339: LIST
104340: LIST
104341: PUSH
104342: LD_INT 2
104344: PUSH
104345: LD_INT 25
104347: PUSH
104348: LD_INT 2
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: PUSH
104355: LD_INT 25
104357: PUSH
104358: LD_INT 16
104360: PUSH
104361: EMPTY
104362: LIST
104363: LIST
104364: PUSH
104365: EMPTY
104366: LIST
104367: LIST
104368: LIST
104369: PUSH
104370: EMPTY
104371: LIST
104372: LIST
104373: PPUSH
104374: CALL_OW 72
104378: UNION
104379: ST_TO_ADDR
// if tmp then
104380: LD_VAR 0 4
104384: IFFALSE 104464
// begin tmp := ShrinkArray ( tmp , 3 ) ;
104386: LD_ADDR_VAR 0 4
104390: PUSH
104391: LD_VAR 0 4
104395: PPUSH
104396: LD_INT 3
104398: PPUSH
104399: CALL 54036 0 2
104403: ST_TO_ADDR
// for j in tmp do
104404: LD_ADDR_VAR 0 2
104408: PUSH
104409: LD_VAR 0 4
104413: PUSH
104414: FOR_IN
104415: IFFALSE 104458
// begin if IsInUnit ( j ) then
104417: LD_VAR 0 2
104421: PPUSH
104422: CALL_OW 310
104426: IFFALSE 104437
// ComExit ( j ) ;
104428: LD_VAR 0 2
104432: PPUSH
104433: CALL 54119 0 1
// AddComCollect ( j , x , y ) ;
104437: LD_VAR 0 2
104441: PPUSH
104442: LD_VAR 0 6
104446: PPUSH
104447: LD_VAR 0 7
104451: PPUSH
104452: CALL_OW 177
// end ;
104456: GO 104414
104458: POP
104459: POP
// exit ;
104460: POP
104461: POP
104462: GO 104691
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
104464: LD_ADDR_VAR 0 4
104468: PUSH
104469: LD_INT 22
104471: PUSH
104472: LD_VAR 0 5
104476: PUSH
104477: EMPTY
104478: LIST
104479: LIST
104480: PUSH
104481: LD_INT 91
104483: PUSH
104484: LD_VAR 0 8
104488: PUSH
104489: LD_INT 8
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: LIST
104496: PUSH
104497: LD_INT 2
104499: PUSH
104500: LD_INT 34
104502: PUSH
104503: LD_INT 12
104505: PUSH
104506: EMPTY
104507: LIST
104508: LIST
104509: PUSH
104510: LD_INT 34
104512: PUSH
104513: LD_INT 51
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: PUSH
104520: LD_INT 34
104522: PUSH
104523: LD_INT 32
104525: PUSH
104526: EMPTY
104527: LIST
104528: LIST
104529: PUSH
104530: LD_INT 34
104532: PUSH
104533: LD_INT 89
104535: PUSH
104536: EMPTY
104537: LIST
104538: LIST
104539: PUSH
104540: EMPTY
104541: LIST
104542: LIST
104543: LIST
104544: LIST
104545: LIST
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: LIST
104551: PPUSH
104552: CALL_OW 69
104556: ST_TO_ADDR
// if tmp then
104557: LD_VAR 0 4
104561: IFFALSE 104687
// begin for j in tmp do
104563: LD_ADDR_VAR 0 2
104567: PUSH
104568: LD_VAR 0 4
104572: PUSH
104573: FOR_IN
104574: IFFALSE 104685
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
104576: LD_VAR 0 2
104580: PPUSH
104581: CALL_OW 262
104585: PUSH
104586: LD_INT 3
104588: EQUAL
104589: PUSH
104590: LD_VAR 0 2
104594: PPUSH
104595: CALL_OW 261
104599: PUSH
104600: LD_INT 20
104602: GREATER
104603: OR
104604: PUSH
104605: LD_VAR 0 2
104609: PPUSH
104610: CALL_OW 314
104614: NOT
104615: AND
104616: PUSH
104617: LD_VAR 0 2
104621: PPUSH
104622: CALL_OW 263
104626: PUSH
104627: LD_INT 1
104629: NONEQUAL
104630: PUSH
104631: LD_VAR 0 2
104635: PPUSH
104636: CALL_OW 311
104640: OR
104641: AND
104642: IFFALSE 104683
// begin ComCollect ( j , x , y ) ;
104644: LD_VAR 0 2
104648: PPUSH
104649: LD_VAR 0 6
104653: PPUSH
104654: LD_VAR 0 7
104658: PPUSH
104659: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
104663: LD_VAR 0 2
104667: PPUSH
104668: LD_VAR 0 8
104672: PPUSH
104673: CALL_OW 172
// exit ;
104677: POP
104678: POP
104679: POP
104680: POP
104681: GO 104691
// end ;
104683: GO 104573
104685: POP
104686: POP
// end ; end ;
104687: GO 104062
104689: POP
104690: POP
// end ; end_of_file
104691: PPOPN 9
104693: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
104694: LD_INT 0
104696: PPUSH
104697: PPUSH
104698: PPUSH
104699: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104700: LD_VAR 0 1
104704: PPUSH
104705: CALL_OW 264
104709: PUSH
104710: LD_INT 91
104712: EQUAL
104713: IFFALSE 104785
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104715: LD_INT 68
104717: PPUSH
104718: LD_VAR 0 1
104722: PPUSH
104723: CALL_OW 255
104727: PPUSH
104728: CALL_OW 321
104732: PUSH
104733: LD_INT 2
104735: EQUAL
104736: IFFALSE 104748
// eff := 70 else
104738: LD_ADDR_VAR 0 4
104742: PUSH
104743: LD_INT 70
104745: ST_TO_ADDR
104746: GO 104756
// eff := 30 ;
104748: LD_ADDR_VAR 0 4
104752: PUSH
104753: LD_INT 30
104755: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104756: LD_VAR 0 1
104760: PPUSH
104761: CALL_OW 250
104765: PPUSH
104766: LD_VAR 0 1
104770: PPUSH
104771: CALL_OW 251
104775: PPUSH
104776: LD_VAR 0 4
104780: PPUSH
104781: CALL_OW 495
// end ; end ;
104785: LD_VAR 0 2
104789: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
104790: LD_INT 0
104792: PPUSH
// end ;
104793: LD_VAR 0 4
104797: RET
// export function SOS_Command ( cmd ) ; begin
104798: LD_INT 0
104800: PPUSH
// end ;
104801: LD_VAR 0 2
104805: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
104806: LD_INT 0
104808: PPUSH
// end ;
104809: LD_VAR 0 6
104813: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
104814: LD_INT 0
104816: PPUSH
104817: PPUSH
// if not vehicle or not factory then
104818: LD_VAR 0 1
104822: NOT
104823: PUSH
104824: LD_VAR 0 2
104828: NOT
104829: OR
104830: IFFALSE 104834
// exit ;
104832: GO 105065
// if factoryWaypoints >= factory then
104834: LD_EXP 165
104838: PUSH
104839: LD_VAR 0 2
104843: GREATEREQUAL
104844: IFFALSE 105065
// if factoryWaypoints [ factory ] then
104846: LD_EXP 165
104850: PUSH
104851: LD_VAR 0 2
104855: ARRAY
104856: IFFALSE 105065
// begin if GetControl ( vehicle ) = control_manual then
104858: LD_VAR 0 1
104862: PPUSH
104863: CALL_OW 263
104867: PUSH
104868: LD_INT 1
104870: EQUAL
104871: IFFALSE 104952
// begin driver := IsDrivenBy ( vehicle ) ;
104873: LD_ADDR_VAR 0 4
104877: PUSH
104878: LD_VAR 0 1
104882: PPUSH
104883: CALL_OW 311
104887: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
104888: LD_VAR 0 4
104892: PPUSH
104893: LD_EXP 165
104897: PUSH
104898: LD_VAR 0 2
104902: ARRAY
104903: PUSH
104904: LD_INT 3
104906: ARRAY
104907: PPUSH
104908: LD_EXP 165
104912: PUSH
104913: LD_VAR 0 2
104917: ARRAY
104918: PUSH
104919: LD_INT 4
104921: ARRAY
104922: PPUSH
104923: CALL_OW 171
// AddComExitVehicle ( driver ) ;
104927: LD_VAR 0 4
104931: PPUSH
104932: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
104936: LD_VAR 0 4
104940: PPUSH
104941: LD_VAR 0 2
104945: PPUSH
104946: CALL_OW 180
// end else
104950: GO 105065
// if GetControl ( vehicle ) = control_remote then
104952: LD_VAR 0 1
104956: PPUSH
104957: CALL_OW 263
104961: PUSH
104962: LD_INT 2
104964: EQUAL
104965: IFFALSE 105026
// begin wait ( 0 0$2 ) ;
104967: LD_INT 70
104969: PPUSH
104970: CALL_OW 67
// if Connect ( vehicle ) then
104974: LD_VAR 0 1
104978: PPUSH
104979: CALL 24327 0 1
104983: IFFALSE 105024
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
104985: LD_VAR 0 1
104989: PPUSH
104990: LD_EXP 165
104994: PUSH
104995: LD_VAR 0 2
104999: ARRAY
105000: PUSH
105001: LD_INT 3
105003: ARRAY
105004: PPUSH
105005: LD_EXP 165
105009: PUSH
105010: LD_VAR 0 2
105014: ARRAY
105015: PUSH
105016: LD_INT 4
105018: ARRAY
105019: PPUSH
105020: CALL_OW 171
// end else
105024: GO 105065
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105026: LD_VAR 0 1
105030: PPUSH
105031: LD_EXP 165
105035: PUSH
105036: LD_VAR 0 2
105040: ARRAY
105041: PUSH
105042: LD_INT 3
105044: ARRAY
105045: PPUSH
105046: LD_EXP 165
105050: PUSH
105051: LD_VAR 0 2
105055: ARRAY
105056: PUSH
105057: LD_INT 4
105059: ARRAY
105060: PPUSH
105061: CALL_OW 171
// end ; end ;
105065: LD_VAR 0 3
105069: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105070: LD_INT 0
105072: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105073: LD_VAR 0 1
105077: PUSH
105078: LD_INT 250
105080: EQUAL
105081: PUSH
105082: LD_VAR 0 2
105086: PPUSH
105087: CALL_OW 264
105091: PUSH
105092: LD_INT 81
105094: EQUAL
105095: AND
105096: IFFALSE 105117
// MinerPlaceMine ( unit , x , y ) ;
105098: LD_VAR 0 2
105102: PPUSH
105103: LD_VAR 0 4
105107: PPUSH
105108: LD_VAR 0 5
105112: PPUSH
105113: CALL 107941 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105117: LD_VAR 0 1
105121: PUSH
105122: LD_INT 251
105124: EQUAL
105125: PUSH
105126: LD_VAR 0 2
105130: PPUSH
105131: CALL_OW 264
105135: PUSH
105136: LD_INT 81
105138: EQUAL
105139: AND
105140: IFFALSE 105161
// MinerDetonateMine ( unit , x , y ) ;
105142: LD_VAR 0 2
105146: PPUSH
105147: LD_VAR 0 4
105151: PPUSH
105152: LD_VAR 0 5
105156: PPUSH
105157: CALL 108216 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105161: LD_VAR 0 1
105165: PUSH
105166: LD_INT 252
105168: EQUAL
105169: PUSH
105170: LD_VAR 0 2
105174: PPUSH
105175: CALL_OW 264
105179: PUSH
105180: LD_INT 81
105182: EQUAL
105183: AND
105184: IFFALSE 105205
// MinerCreateMinefield ( unit , x , y ) ;
105186: LD_VAR 0 2
105190: PPUSH
105191: LD_VAR 0 4
105195: PPUSH
105196: LD_VAR 0 5
105200: PPUSH
105201: CALL 108633 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105205: LD_VAR 0 1
105209: PUSH
105210: LD_INT 253
105212: EQUAL
105213: PUSH
105214: LD_VAR 0 2
105218: PPUSH
105219: CALL_OW 257
105223: PUSH
105224: LD_INT 5
105226: EQUAL
105227: AND
105228: IFFALSE 105249
// ComBinocular ( unit , x , y ) ;
105230: LD_VAR 0 2
105234: PPUSH
105235: LD_VAR 0 4
105239: PPUSH
105240: LD_VAR 0 5
105244: PPUSH
105245: CALL 109002 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105249: LD_VAR 0 1
105253: PUSH
105254: LD_INT 254
105256: EQUAL
105257: PUSH
105258: LD_VAR 0 2
105262: PPUSH
105263: CALL_OW 264
105267: PUSH
105268: LD_INT 99
105270: EQUAL
105271: AND
105272: PUSH
105273: LD_VAR 0 3
105277: PPUSH
105278: CALL_OW 263
105282: PUSH
105283: LD_INT 3
105285: EQUAL
105286: AND
105287: IFFALSE 105303
// HackDestroyVehicle ( unit , selectedUnit ) ;
105289: LD_VAR 0 2
105293: PPUSH
105294: LD_VAR 0 3
105298: PPUSH
105299: CALL 107305 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105303: LD_VAR 0 1
105307: PUSH
105308: LD_INT 255
105310: EQUAL
105311: PUSH
105312: LD_VAR 0 2
105316: PPUSH
105317: CALL_OW 264
105321: PUSH
105322: LD_INT 14
105324: PUSH
105325: LD_INT 53
105327: PUSH
105328: EMPTY
105329: LIST
105330: LIST
105331: IN
105332: AND
105333: PUSH
105334: LD_VAR 0 4
105338: PPUSH
105339: LD_VAR 0 5
105343: PPUSH
105344: CALL_OW 488
105348: AND
105349: IFFALSE 105373
// CutTreeXYR ( unit , x , y , 12 ) ;
105351: LD_VAR 0 2
105355: PPUSH
105356: LD_VAR 0 4
105360: PPUSH
105361: LD_VAR 0 5
105365: PPUSH
105366: LD_INT 12
105368: PPUSH
105369: CALL 105468 0 4
// if cmd = 256 then
105373: LD_VAR 0 1
105377: PUSH
105378: LD_INT 256
105380: EQUAL
105381: IFFALSE 105402
// SetFactoryWaypoint ( unit , x , y ) ;
105383: LD_VAR 0 2
105387: PPUSH
105388: LD_VAR 0 4
105392: PPUSH
105393: LD_VAR 0 5
105397: PPUSH
105398: CALL 103383 0 3
// if cmd = 257 then
105402: LD_VAR 0 1
105406: PUSH
105407: LD_INT 257
105409: EQUAL
105410: IFFALSE 105431
// SetWarehouseGatheringPoint ( unit , x , y ) ;
105412: LD_VAR 0 2
105416: PPUSH
105417: LD_VAR 0 4
105421: PPUSH
105422: LD_VAR 0 5
105426: PPUSH
105427: CALL 103745 0 3
// if cmd = 258 then
105431: LD_VAR 0 1
105435: PUSH
105436: LD_INT 258
105438: EQUAL
105439: IFFALSE 105463
// BurnTreeXYR ( unit , x , y , 8 ) ;
105441: LD_VAR 0 2
105445: PPUSH
105446: LD_VAR 0 4
105450: PPUSH
105451: LD_VAR 0 5
105455: PPUSH
105456: LD_INT 8
105458: PPUSH
105459: CALL 105862 0 4
// end ;
105463: LD_VAR 0 6
105467: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105468: LD_INT 0
105470: PPUSH
105471: PPUSH
105472: PPUSH
105473: PPUSH
105474: PPUSH
105475: PPUSH
105476: PPUSH
105477: PPUSH
105478: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
105479: LD_VAR 0 1
105483: PPUSH
105484: CALL_OW 302
105488: NOT
105489: PUSH
105490: LD_VAR 0 2
105494: PPUSH
105495: LD_VAR 0 3
105499: PPUSH
105500: CALL_OW 488
105504: NOT
105505: OR
105506: PUSH
105507: LD_VAR 0 4
105511: NOT
105512: OR
105513: IFFALSE 105517
// exit ;
105515: GO 105857
// list := [ ] ;
105517: LD_ADDR_VAR 0 13
105521: PUSH
105522: EMPTY
105523: ST_TO_ADDR
// if x - r < 0 then
105524: LD_VAR 0 2
105528: PUSH
105529: LD_VAR 0 4
105533: MINUS
105534: PUSH
105535: LD_INT 0
105537: LESS
105538: IFFALSE 105550
// min_x := 0 else
105540: LD_ADDR_VAR 0 7
105544: PUSH
105545: LD_INT 0
105547: ST_TO_ADDR
105548: GO 105566
// min_x := x - r ;
105550: LD_ADDR_VAR 0 7
105554: PUSH
105555: LD_VAR 0 2
105559: PUSH
105560: LD_VAR 0 4
105564: MINUS
105565: ST_TO_ADDR
// if y - r < 0 then
105566: LD_VAR 0 3
105570: PUSH
105571: LD_VAR 0 4
105575: MINUS
105576: PUSH
105577: LD_INT 0
105579: LESS
105580: IFFALSE 105592
// min_y := 0 else
105582: LD_ADDR_VAR 0 8
105586: PUSH
105587: LD_INT 0
105589: ST_TO_ADDR
105590: GO 105608
// min_y := y - r ;
105592: LD_ADDR_VAR 0 8
105596: PUSH
105597: LD_VAR 0 3
105601: PUSH
105602: LD_VAR 0 4
105606: MINUS
105607: ST_TO_ADDR
// max_x := x + r ;
105608: LD_ADDR_VAR 0 9
105612: PUSH
105613: LD_VAR 0 2
105617: PUSH
105618: LD_VAR 0 4
105622: PLUS
105623: ST_TO_ADDR
// max_y := y + r ;
105624: LD_ADDR_VAR 0 10
105628: PUSH
105629: LD_VAR 0 3
105633: PUSH
105634: LD_VAR 0 4
105638: PLUS
105639: ST_TO_ADDR
// for _x = min_x to max_x do
105640: LD_ADDR_VAR 0 11
105644: PUSH
105645: DOUBLE
105646: LD_VAR 0 7
105650: DEC
105651: ST_TO_ADDR
105652: LD_VAR 0 9
105656: PUSH
105657: FOR_TO
105658: IFFALSE 105775
// for _y = min_y to max_y do
105660: LD_ADDR_VAR 0 12
105664: PUSH
105665: DOUBLE
105666: LD_VAR 0 8
105670: DEC
105671: ST_TO_ADDR
105672: LD_VAR 0 10
105676: PUSH
105677: FOR_TO
105678: IFFALSE 105771
// begin if not ValidHex ( _x , _y ) then
105680: LD_VAR 0 11
105684: PPUSH
105685: LD_VAR 0 12
105689: PPUSH
105690: CALL_OW 488
105694: NOT
105695: IFFALSE 105699
// continue ;
105697: GO 105677
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
105699: LD_VAR 0 11
105703: PPUSH
105704: LD_VAR 0 12
105708: PPUSH
105709: CALL_OW 351
105713: PUSH
105714: LD_VAR 0 11
105718: PPUSH
105719: LD_VAR 0 12
105723: PPUSH
105724: CALL_OW 554
105728: AND
105729: IFFALSE 105769
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
105731: LD_ADDR_VAR 0 13
105735: PUSH
105736: LD_VAR 0 13
105740: PPUSH
105741: LD_VAR 0 13
105745: PUSH
105746: LD_INT 1
105748: PLUS
105749: PPUSH
105750: LD_VAR 0 11
105754: PUSH
105755: LD_VAR 0 12
105759: PUSH
105760: EMPTY
105761: LIST
105762: LIST
105763: PPUSH
105764: CALL_OW 2
105768: ST_TO_ADDR
// end ;
105769: GO 105677
105771: POP
105772: POP
105773: GO 105657
105775: POP
105776: POP
// if not list then
105777: LD_VAR 0 13
105781: NOT
105782: IFFALSE 105786
// exit ;
105784: GO 105857
// for i in list do
105786: LD_ADDR_VAR 0 6
105790: PUSH
105791: LD_VAR 0 13
105795: PUSH
105796: FOR_IN
105797: IFFALSE 105855
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
105799: LD_VAR 0 1
105803: PPUSH
105804: LD_STRING M
105806: PUSH
105807: LD_VAR 0 6
105811: PUSH
105812: LD_INT 1
105814: ARRAY
105815: PUSH
105816: LD_VAR 0 6
105820: PUSH
105821: LD_INT 2
105823: ARRAY
105824: PUSH
105825: LD_INT 0
105827: PUSH
105828: LD_INT 0
105830: PUSH
105831: LD_INT 0
105833: PUSH
105834: LD_INT 0
105836: PUSH
105837: EMPTY
105838: LIST
105839: LIST
105840: LIST
105841: LIST
105842: LIST
105843: LIST
105844: LIST
105845: PUSH
105846: EMPTY
105847: LIST
105848: PPUSH
105849: CALL_OW 447
105853: GO 105796
105855: POP
105856: POP
// end ;
105857: LD_VAR 0 5
105861: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105862: LD_INT 0
105864: PPUSH
105865: PPUSH
105866: PPUSH
105867: PPUSH
105868: PPUSH
105869: PPUSH
105870: PPUSH
105871: PPUSH
105872: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
105873: LD_VAR 0 1
105877: PPUSH
105878: CALL_OW 302
105882: NOT
105883: PUSH
105884: LD_VAR 0 2
105888: PPUSH
105889: LD_VAR 0 3
105893: PPUSH
105894: CALL_OW 488
105898: NOT
105899: OR
105900: PUSH
105901: LD_VAR 0 4
105905: NOT
105906: OR
105907: IFFALSE 105911
// exit ;
105909: GO 106259
// list := [ ] ;
105911: LD_ADDR_VAR 0 13
105915: PUSH
105916: EMPTY
105917: ST_TO_ADDR
// if x - r < 0 then
105918: LD_VAR 0 2
105922: PUSH
105923: LD_VAR 0 4
105927: MINUS
105928: PUSH
105929: LD_INT 0
105931: LESS
105932: IFFALSE 105944
// min_x := 0 else
105934: LD_ADDR_VAR 0 7
105938: PUSH
105939: LD_INT 0
105941: ST_TO_ADDR
105942: GO 105960
// min_x := x - r ;
105944: LD_ADDR_VAR 0 7
105948: PUSH
105949: LD_VAR 0 2
105953: PUSH
105954: LD_VAR 0 4
105958: MINUS
105959: ST_TO_ADDR
// if y - r < 0 then
105960: LD_VAR 0 3
105964: PUSH
105965: LD_VAR 0 4
105969: MINUS
105970: PUSH
105971: LD_INT 0
105973: LESS
105974: IFFALSE 105986
// min_y := 0 else
105976: LD_ADDR_VAR 0 8
105980: PUSH
105981: LD_INT 0
105983: ST_TO_ADDR
105984: GO 106002
// min_y := y - r ;
105986: LD_ADDR_VAR 0 8
105990: PUSH
105991: LD_VAR 0 3
105995: PUSH
105996: LD_VAR 0 4
106000: MINUS
106001: ST_TO_ADDR
// max_x := x + r ;
106002: LD_ADDR_VAR 0 9
106006: PUSH
106007: LD_VAR 0 2
106011: PUSH
106012: LD_VAR 0 4
106016: PLUS
106017: ST_TO_ADDR
// max_y := y + r ;
106018: LD_ADDR_VAR 0 10
106022: PUSH
106023: LD_VAR 0 3
106027: PUSH
106028: LD_VAR 0 4
106032: PLUS
106033: ST_TO_ADDR
// for _x = min_x to max_x do
106034: LD_ADDR_VAR 0 11
106038: PUSH
106039: DOUBLE
106040: LD_VAR 0 7
106044: DEC
106045: ST_TO_ADDR
106046: LD_VAR 0 9
106050: PUSH
106051: FOR_TO
106052: IFFALSE 106169
// for _y = min_y to max_y do
106054: LD_ADDR_VAR 0 12
106058: PUSH
106059: DOUBLE
106060: LD_VAR 0 8
106064: DEC
106065: ST_TO_ADDR
106066: LD_VAR 0 10
106070: PUSH
106071: FOR_TO
106072: IFFALSE 106165
// begin if not ValidHex ( _x , _y ) then
106074: LD_VAR 0 11
106078: PPUSH
106079: LD_VAR 0 12
106083: PPUSH
106084: CALL_OW 488
106088: NOT
106089: IFFALSE 106093
// continue ;
106091: GO 106071
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106093: LD_VAR 0 11
106097: PPUSH
106098: LD_VAR 0 12
106102: PPUSH
106103: CALL_OW 351
106107: PUSH
106108: LD_VAR 0 11
106112: PPUSH
106113: LD_VAR 0 12
106117: PPUSH
106118: CALL_OW 554
106122: AND
106123: IFFALSE 106163
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106125: LD_ADDR_VAR 0 13
106129: PUSH
106130: LD_VAR 0 13
106134: PPUSH
106135: LD_VAR 0 13
106139: PUSH
106140: LD_INT 1
106142: PLUS
106143: PPUSH
106144: LD_VAR 0 11
106148: PUSH
106149: LD_VAR 0 12
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: PPUSH
106158: CALL_OW 2
106162: ST_TO_ADDR
// end ;
106163: GO 106071
106165: POP
106166: POP
106167: GO 106051
106169: POP
106170: POP
// if not list then
106171: LD_VAR 0 13
106175: NOT
106176: IFFALSE 106180
// exit ;
106178: GO 106259
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
106180: LD_ADDR_VAR 0 13
106184: PUSH
106185: LD_VAR 0 1
106189: PPUSH
106190: LD_VAR 0 13
106194: PPUSH
106195: LD_INT 1
106197: PPUSH
106198: LD_INT 1
106200: PPUSH
106201: CALL 21469 0 4
106205: ST_TO_ADDR
// ComStop ( flame ) ;
106206: LD_VAR 0 1
106210: PPUSH
106211: CALL_OW 141
// for i in list do
106215: LD_ADDR_VAR 0 6
106219: PUSH
106220: LD_VAR 0 13
106224: PUSH
106225: FOR_IN
106226: IFFALSE 106257
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
106228: LD_VAR 0 1
106232: PPUSH
106233: LD_VAR 0 6
106237: PUSH
106238: LD_INT 1
106240: ARRAY
106241: PPUSH
106242: LD_VAR 0 6
106246: PUSH
106247: LD_INT 2
106249: ARRAY
106250: PPUSH
106251: CALL_OW 176
106255: GO 106225
106257: POP
106258: POP
// end ;
106259: LD_VAR 0 5
106263: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106264: LD_EXP 168
106268: NOT
106269: IFFALSE 106319
106271: GO 106273
106273: DISABLE
// begin initHack := true ;
106274: LD_ADDR_EXP 168
106278: PUSH
106279: LD_INT 1
106281: ST_TO_ADDR
// hackTanks := [ ] ;
106282: LD_ADDR_EXP 169
106286: PUSH
106287: EMPTY
106288: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106289: LD_ADDR_EXP 170
106293: PUSH
106294: EMPTY
106295: ST_TO_ADDR
// hackLimit := 3 ;
106296: LD_ADDR_EXP 171
106300: PUSH
106301: LD_INT 3
106303: ST_TO_ADDR
// hackDist := 12 ;
106304: LD_ADDR_EXP 172
106308: PUSH
106309: LD_INT 12
106311: ST_TO_ADDR
// hackCounter := [ ] ;
106312: LD_ADDR_EXP 173
106316: PUSH
106317: EMPTY
106318: ST_TO_ADDR
// end ;
106319: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106320: LD_EXP 168
106324: PUSH
106325: LD_INT 34
106327: PUSH
106328: LD_INT 99
106330: PUSH
106331: EMPTY
106332: LIST
106333: LIST
106334: PPUSH
106335: CALL_OW 69
106339: AND
106340: IFFALSE 106593
106342: GO 106344
106344: DISABLE
106345: LD_INT 0
106347: PPUSH
106348: PPUSH
// begin enable ;
106349: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106350: LD_ADDR_VAR 0 1
106354: PUSH
106355: LD_INT 34
106357: PUSH
106358: LD_INT 99
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: PPUSH
106365: CALL_OW 69
106369: PUSH
106370: FOR_IN
106371: IFFALSE 106591
// begin if not i in hackTanks then
106373: LD_VAR 0 1
106377: PUSH
106378: LD_EXP 169
106382: IN
106383: NOT
106384: IFFALSE 106467
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106386: LD_ADDR_EXP 169
106390: PUSH
106391: LD_EXP 169
106395: PPUSH
106396: LD_EXP 169
106400: PUSH
106401: LD_INT 1
106403: PLUS
106404: PPUSH
106405: LD_VAR 0 1
106409: PPUSH
106410: CALL_OW 1
106414: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106415: LD_ADDR_EXP 170
106419: PUSH
106420: LD_EXP 170
106424: PPUSH
106425: LD_EXP 170
106429: PUSH
106430: LD_INT 1
106432: PLUS
106433: PPUSH
106434: EMPTY
106435: PPUSH
106436: CALL_OW 1
106440: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106441: LD_ADDR_EXP 173
106445: PUSH
106446: LD_EXP 173
106450: PPUSH
106451: LD_EXP 173
106455: PUSH
106456: LD_INT 1
106458: PLUS
106459: PPUSH
106460: EMPTY
106461: PPUSH
106462: CALL_OW 1
106466: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106467: LD_VAR 0 1
106471: PPUSH
106472: CALL_OW 302
106476: NOT
106477: IFFALSE 106490
// begin HackUnlinkAll ( i ) ;
106479: LD_VAR 0 1
106483: PPUSH
106484: CALL 106596 0 1
// continue ;
106488: GO 106370
// end ; HackCheckCapturedStatus ( i ) ;
106490: LD_VAR 0 1
106494: PPUSH
106495: CALL 107039 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106499: LD_ADDR_VAR 0 2
106503: PUSH
106504: LD_INT 81
106506: PUSH
106507: LD_VAR 0 1
106511: PPUSH
106512: CALL_OW 255
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: PUSH
106521: LD_INT 33
106523: PUSH
106524: LD_INT 3
106526: PUSH
106527: EMPTY
106528: LIST
106529: LIST
106530: PUSH
106531: LD_INT 91
106533: PUSH
106534: LD_VAR 0 1
106538: PUSH
106539: LD_EXP 172
106543: PUSH
106544: EMPTY
106545: LIST
106546: LIST
106547: LIST
106548: PUSH
106549: LD_INT 50
106551: PUSH
106552: EMPTY
106553: LIST
106554: PUSH
106555: EMPTY
106556: LIST
106557: LIST
106558: LIST
106559: LIST
106560: PPUSH
106561: CALL_OW 69
106565: ST_TO_ADDR
// if not tmp then
106566: LD_VAR 0 2
106570: NOT
106571: IFFALSE 106575
// continue ;
106573: GO 106370
// HackLink ( i , tmp ) ;
106575: LD_VAR 0 1
106579: PPUSH
106580: LD_VAR 0 2
106584: PPUSH
106585: CALL 106732 0 2
// end ;
106589: GO 106370
106591: POP
106592: POP
// end ;
106593: PPOPN 2
106595: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
106596: LD_INT 0
106598: PPUSH
106599: PPUSH
106600: PPUSH
// if not hack in hackTanks then
106601: LD_VAR 0 1
106605: PUSH
106606: LD_EXP 169
106610: IN
106611: NOT
106612: IFFALSE 106616
// exit ;
106614: GO 106727
// index := GetElementIndex ( hackTanks , hack ) ;
106616: LD_ADDR_VAR 0 4
106620: PUSH
106621: LD_EXP 169
106625: PPUSH
106626: LD_VAR 0 1
106630: PPUSH
106631: CALL 20766 0 2
106635: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106636: LD_EXP 170
106640: PUSH
106641: LD_VAR 0 4
106645: ARRAY
106646: IFFALSE 106727
// begin for i in hackTanksCaptured [ index ] do
106648: LD_ADDR_VAR 0 3
106652: PUSH
106653: LD_EXP 170
106657: PUSH
106658: LD_VAR 0 4
106662: ARRAY
106663: PUSH
106664: FOR_IN
106665: IFFALSE 106691
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106667: LD_VAR 0 3
106671: PUSH
106672: LD_INT 1
106674: ARRAY
106675: PPUSH
106676: LD_VAR 0 3
106680: PUSH
106681: LD_INT 2
106683: ARRAY
106684: PPUSH
106685: CALL_OW 235
106689: GO 106664
106691: POP
106692: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106693: LD_ADDR_EXP 170
106697: PUSH
106698: LD_EXP 170
106702: PPUSH
106703: LD_VAR 0 4
106707: PPUSH
106708: EMPTY
106709: PPUSH
106710: CALL_OW 1
106714: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
106715: LD_VAR 0 1
106719: PPUSH
106720: LD_INT 0
106722: PPUSH
106723: CALL_OW 505
// end ; end ;
106727: LD_VAR 0 2
106731: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
106732: LD_INT 0
106734: PPUSH
106735: PPUSH
106736: PPUSH
// if not hack in hackTanks or not vehicles then
106737: LD_VAR 0 1
106741: PUSH
106742: LD_EXP 169
106746: IN
106747: NOT
106748: PUSH
106749: LD_VAR 0 2
106753: NOT
106754: OR
106755: IFFALSE 106759
// exit ;
106757: GO 107034
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
106759: LD_ADDR_VAR 0 2
106763: PUSH
106764: LD_VAR 0 1
106768: PPUSH
106769: LD_VAR 0 2
106773: PPUSH
106774: LD_INT 1
106776: PPUSH
106777: LD_INT 1
106779: PPUSH
106780: CALL 21416 0 4
106784: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
106785: LD_ADDR_VAR 0 5
106789: PUSH
106790: LD_EXP 169
106794: PPUSH
106795: LD_VAR 0 1
106799: PPUSH
106800: CALL 20766 0 2
106804: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
106805: LD_EXP 170
106809: PUSH
106810: LD_VAR 0 5
106814: ARRAY
106815: PUSH
106816: LD_EXP 171
106820: LESS
106821: IFFALSE 107010
// begin for i := 1 to vehicles do
106823: LD_ADDR_VAR 0 4
106827: PUSH
106828: DOUBLE
106829: LD_INT 1
106831: DEC
106832: ST_TO_ADDR
106833: LD_VAR 0 2
106837: PUSH
106838: FOR_TO
106839: IFFALSE 107008
// begin if hackTanksCaptured [ index ] = hackLimit then
106841: LD_EXP 170
106845: PUSH
106846: LD_VAR 0 5
106850: ARRAY
106851: PUSH
106852: LD_EXP 171
106856: EQUAL
106857: IFFALSE 106861
// break ;
106859: GO 107008
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
106861: LD_ADDR_EXP 173
106865: PUSH
106866: LD_EXP 173
106870: PPUSH
106871: LD_VAR 0 5
106875: PPUSH
106876: LD_EXP 173
106880: PUSH
106881: LD_VAR 0 5
106885: ARRAY
106886: PUSH
106887: LD_INT 1
106889: PLUS
106890: PPUSH
106891: CALL_OW 1
106895: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
106896: LD_ADDR_EXP 170
106900: PUSH
106901: LD_EXP 170
106905: PPUSH
106906: LD_VAR 0 5
106910: PUSH
106911: LD_EXP 170
106915: PUSH
106916: LD_VAR 0 5
106920: ARRAY
106921: PUSH
106922: LD_INT 1
106924: PLUS
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: PPUSH
106930: LD_VAR 0 2
106934: PUSH
106935: LD_VAR 0 4
106939: ARRAY
106940: PUSH
106941: LD_VAR 0 2
106945: PUSH
106946: LD_VAR 0 4
106950: ARRAY
106951: PPUSH
106952: CALL_OW 255
106956: PUSH
106957: EMPTY
106958: LIST
106959: LIST
106960: PPUSH
106961: CALL 20981 0 3
106965: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
106966: LD_VAR 0 2
106970: PUSH
106971: LD_VAR 0 4
106975: ARRAY
106976: PPUSH
106977: LD_VAR 0 1
106981: PPUSH
106982: CALL_OW 255
106986: PPUSH
106987: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
106991: LD_VAR 0 2
106995: PUSH
106996: LD_VAR 0 4
107000: ARRAY
107001: PPUSH
107002: CALL_OW 141
// end ;
107006: GO 106838
107008: POP
107009: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107010: LD_VAR 0 1
107014: PPUSH
107015: LD_EXP 170
107019: PUSH
107020: LD_VAR 0 5
107024: ARRAY
107025: PUSH
107026: LD_INT 0
107028: PLUS
107029: PPUSH
107030: CALL_OW 505
// end ;
107034: LD_VAR 0 3
107038: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107039: LD_INT 0
107041: PPUSH
107042: PPUSH
107043: PPUSH
107044: PPUSH
// if not hack in hackTanks then
107045: LD_VAR 0 1
107049: PUSH
107050: LD_EXP 169
107054: IN
107055: NOT
107056: IFFALSE 107060
// exit ;
107058: GO 107300
// index := GetElementIndex ( hackTanks , hack ) ;
107060: LD_ADDR_VAR 0 4
107064: PUSH
107065: LD_EXP 169
107069: PPUSH
107070: LD_VAR 0 1
107074: PPUSH
107075: CALL 20766 0 2
107079: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107080: LD_ADDR_VAR 0 3
107084: PUSH
107085: DOUBLE
107086: LD_EXP 170
107090: PUSH
107091: LD_VAR 0 4
107095: ARRAY
107096: INC
107097: ST_TO_ADDR
107098: LD_INT 1
107100: PUSH
107101: FOR_DOWNTO
107102: IFFALSE 107274
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107104: LD_ADDR_VAR 0 5
107108: PUSH
107109: LD_EXP 170
107113: PUSH
107114: LD_VAR 0 4
107118: ARRAY
107119: PUSH
107120: LD_VAR 0 3
107124: ARRAY
107125: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107126: LD_VAR 0 5
107130: PUSH
107131: LD_INT 1
107133: ARRAY
107134: PPUSH
107135: CALL_OW 302
107139: NOT
107140: PUSH
107141: LD_VAR 0 5
107145: PUSH
107146: LD_INT 1
107148: ARRAY
107149: PPUSH
107150: CALL_OW 255
107154: PUSH
107155: LD_VAR 0 1
107159: PPUSH
107160: CALL_OW 255
107164: NONEQUAL
107165: OR
107166: IFFALSE 107272
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107168: LD_VAR 0 5
107172: PUSH
107173: LD_INT 1
107175: ARRAY
107176: PPUSH
107177: CALL_OW 305
107181: PUSH
107182: LD_VAR 0 5
107186: PUSH
107187: LD_INT 1
107189: ARRAY
107190: PPUSH
107191: CALL_OW 255
107195: PUSH
107196: LD_VAR 0 1
107200: PPUSH
107201: CALL_OW 255
107205: EQUAL
107206: AND
107207: IFFALSE 107231
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107209: LD_VAR 0 5
107213: PUSH
107214: LD_INT 1
107216: ARRAY
107217: PPUSH
107218: LD_VAR 0 5
107222: PUSH
107223: LD_INT 2
107225: ARRAY
107226: PPUSH
107227: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107231: LD_ADDR_EXP 170
107235: PUSH
107236: LD_EXP 170
107240: PPUSH
107241: LD_VAR 0 4
107245: PPUSH
107246: LD_EXP 170
107250: PUSH
107251: LD_VAR 0 4
107255: ARRAY
107256: PPUSH
107257: LD_VAR 0 3
107261: PPUSH
107262: CALL_OW 3
107266: PPUSH
107267: CALL_OW 1
107271: ST_TO_ADDR
// end ; end ;
107272: GO 107101
107274: POP
107275: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107276: LD_VAR 0 1
107280: PPUSH
107281: LD_EXP 170
107285: PUSH
107286: LD_VAR 0 4
107290: ARRAY
107291: PUSH
107292: LD_INT 0
107294: PLUS
107295: PPUSH
107296: CALL_OW 505
// end ;
107300: LD_VAR 0 2
107304: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107305: LD_INT 0
107307: PPUSH
107308: PPUSH
107309: PPUSH
107310: PPUSH
// if not hack in hackTanks then
107311: LD_VAR 0 1
107315: PUSH
107316: LD_EXP 169
107320: IN
107321: NOT
107322: IFFALSE 107326
// exit ;
107324: GO 107411
// index := GetElementIndex ( hackTanks , hack ) ;
107326: LD_ADDR_VAR 0 5
107330: PUSH
107331: LD_EXP 169
107335: PPUSH
107336: LD_VAR 0 1
107340: PPUSH
107341: CALL 20766 0 2
107345: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107346: LD_ADDR_VAR 0 4
107350: PUSH
107351: DOUBLE
107352: LD_INT 1
107354: DEC
107355: ST_TO_ADDR
107356: LD_EXP 170
107360: PUSH
107361: LD_VAR 0 5
107365: ARRAY
107366: PUSH
107367: FOR_TO
107368: IFFALSE 107409
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107370: LD_EXP 170
107374: PUSH
107375: LD_VAR 0 5
107379: ARRAY
107380: PUSH
107381: LD_VAR 0 4
107385: ARRAY
107386: PUSH
107387: LD_INT 1
107389: ARRAY
107390: PUSH
107391: LD_VAR 0 2
107395: EQUAL
107396: IFFALSE 107407
// KillUnit ( vehicle ) ;
107398: LD_VAR 0 2
107402: PPUSH
107403: CALL_OW 66
107407: GO 107367
107409: POP
107410: POP
// end ;
107411: LD_VAR 0 3
107415: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107416: LD_EXP 174
107420: NOT
107421: IFFALSE 107456
107423: GO 107425
107425: DISABLE
// begin initMiner := true ;
107426: LD_ADDR_EXP 174
107430: PUSH
107431: LD_INT 1
107433: ST_TO_ADDR
// minersList := [ ] ;
107434: LD_ADDR_EXP 175
107438: PUSH
107439: EMPTY
107440: ST_TO_ADDR
// minerMinesList := [ ] ;
107441: LD_ADDR_EXP 176
107445: PUSH
107446: EMPTY
107447: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107448: LD_ADDR_EXP 177
107452: PUSH
107453: LD_INT 5
107455: ST_TO_ADDR
// end ;
107456: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107457: LD_EXP 174
107461: PUSH
107462: LD_INT 34
107464: PUSH
107465: LD_INT 81
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: PPUSH
107472: CALL_OW 69
107476: AND
107477: IFFALSE 107938
107479: GO 107481
107481: DISABLE
107482: LD_INT 0
107484: PPUSH
107485: PPUSH
107486: PPUSH
107487: PPUSH
// begin enable ;
107488: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107489: LD_ADDR_VAR 0 1
107493: PUSH
107494: LD_INT 34
107496: PUSH
107497: LD_INT 81
107499: PUSH
107500: EMPTY
107501: LIST
107502: LIST
107503: PPUSH
107504: CALL_OW 69
107508: PUSH
107509: FOR_IN
107510: IFFALSE 107582
// begin if not i in minersList then
107512: LD_VAR 0 1
107516: PUSH
107517: LD_EXP 175
107521: IN
107522: NOT
107523: IFFALSE 107580
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
107525: LD_ADDR_EXP 175
107529: PUSH
107530: LD_EXP 175
107534: PPUSH
107535: LD_EXP 175
107539: PUSH
107540: LD_INT 1
107542: PLUS
107543: PPUSH
107544: LD_VAR 0 1
107548: PPUSH
107549: CALL_OW 1
107553: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
107554: LD_ADDR_EXP 176
107558: PUSH
107559: LD_EXP 176
107563: PPUSH
107564: LD_EXP 176
107568: PUSH
107569: LD_INT 1
107571: PLUS
107572: PPUSH
107573: EMPTY
107574: PPUSH
107575: CALL_OW 1
107579: ST_TO_ADDR
// end end ;
107580: GO 107509
107582: POP
107583: POP
// for i := minerMinesList downto 1 do
107584: LD_ADDR_VAR 0 1
107588: PUSH
107589: DOUBLE
107590: LD_EXP 176
107594: INC
107595: ST_TO_ADDR
107596: LD_INT 1
107598: PUSH
107599: FOR_DOWNTO
107600: IFFALSE 107936
// begin if IsLive ( minersList [ i ] ) then
107602: LD_EXP 175
107606: PUSH
107607: LD_VAR 0 1
107611: ARRAY
107612: PPUSH
107613: CALL_OW 300
107617: IFFALSE 107645
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107619: LD_EXP 175
107623: PUSH
107624: LD_VAR 0 1
107628: ARRAY
107629: PPUSH
107630: LD_EXP 176
107634: PUSH
107635: LD_VAR 0 1
107639: ARRAY
107640: PPUSH
107641: CALL_OW 505
// if not minerMinesList [ i ] then
107645: LD_EXP 176
107649: PUSH
107650: LD_VAR 0 1
107654: ARRAY
107655: NOT
107656: IFFALSE 107660
// continue ;
107658: GO 107599
// for j := minerMinesList [ i ] downto 1 do
107660: LD_ADDR_VAR 0 2
107664: PUSH
107665: DOUBLE
107666: LD_EXP 176
107670: PUSH
107671: LD_VAR 0 1
107675: ARRAY
107676: INC
107677: ST_TO_ADDR
107678: LD_INT 1
107680: PUSH
107681: FOR_DOWNTO
107682: IFFALSE 107932
// begin side := GetSide ( minersList [ i ] ) ;
107684: LD_ADDR_VAR 0 3
107688: PUSH
107689: LD_EXP 175
107693: PUSH
107694: LD_VAR 0 1
107698: ARRAY
107699: PPUSH
107700: CALL_OW 255
107704: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
107705: LD_ADDR_VAR 0 4
107709: PUSH
107710: LD_EXP 176
107714: PUSH
107715: LD_VAR 0 1
107719: ARRAY
107720: PUSH
107721: LD_VAR 0 2
107725: ARRAY
107726: PUSH
107727: LD_INT 1
107729: ARRAY
107730: PPUSH
107731: LD_EXP 176
107735: PUSH
107736: LD_VAR 0 1
107740: ARRAY
107741: PUSH
107742: LD_VAR 0 2
107746: ARRAY
107747: PUSH
107748: LD_INT 2
107750: ARRAY
107751: PPUSH
107752: CALL_OW 428
107756: ST_TO_ADDR
// if not tmp then
107757: LD_VAR 0 4
107761: NOT
107762: IFFALSE 107766
// continue ;
107764: GO 107681
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
107766: LD_VAR 0 4
107770: PUSH
107771: LD_INT 81
107773: PUSH
107774: LD_VAR 0 3
107778: PUSH
107779: EMPTY
107780: LIST
107781: LIST
107782: PPUSH
107783: CALL_OW 69
107787: IN
107788: PUSH
107789: LD_EXP 176
107793: PUSH
107794: LD_VAR 0 1
107798: ARRAY
107799: PUSH
107800: LD_VAR 0 2
107804: ARRAY
107805: PUSH
107806: LD_INT 1
107808: ARRAY
107809: PPUSH
107810: LD_EXP 176
107814: PUSH
107815: LD_VAR 0 1
107819: ARRAY
107820: PUSH
107821: LD_VAR 0 2
107825: ARRAY
107826: PUSH
107827: LD_INT 2
107829: ARRAY
107830: PPUSH
107831: CALL_OW 458
107835: AND
107836: IFFALSE 107930
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
107838: LD_EXP 176
107842: PUSH
107843: LD_VAR 0 1
107847: ARRAY
107848: PUSH
107849: LD_VAR 0 2
107853: ARRAY
107854: PUSH
107855: LD_INT 1
107857: ARRAY
107858: PPUSH
107859: LD_EXP 176
107863: PUSH
107864: LD_VAR 0 1
107868: ARRAY
107869: PUSH
107870: LD_VAR 0 2
107874: ARRAY
107875: PUSH
107876: LD_INT 2
107878: ARRAY
107879: PPUSH
107880: LD_VAR 0 3
107884: PPUSH
107885: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
107889: LD_ADDR_EXP 176
107893: PUSH
107894: LD_EXP 176
107898: PPUSH
107899: LD_VAR 0 1
107903: PPUSH
107904: LD_EXP 176
107908: PUSH
107909: LD_VAR 0 1
107913: ARRAY
107914: PPUSH
107915: LD_VAR 0 2
107919: PPUSH
107920: CALL_OW 3
107924: PPUSH
107925: CALL_OW 1
107929: ST_TO_ADDR
// end ; end ;
107930: GO 107681
107932: POP
107933: POP
// end ;
107934: GO 107599
107936: POP
107937: POP
// end ;
107938: PPOPN 4
107940: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
107941: LD_INT 0
107943: PPUSH
107944: PPUSH
// result := false ;
107945: LD_ADDR_VAR 0 4
107949: PUSH
107950: LD_INT 0
107952: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
107953: LD_VAR 0 1
107957: PPUSH
107958: CALL_OW 264
107962: PUSH
107963: LD_INT 81
107965: EQUAL
107966: NOT
107967: IFFALSE 107971
// exit ;
107969: GO 108211
// index := GetElementIndex ( minersList , unit ) ;
107971: LD_ADDR_VAR 0 5
107975: PUSH
107976: LD_EXP 175
107980: PPUSH
107981: LD_VAR 0 1
107985: PPUSH
107986: CALL 20766 0 2
107990: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
107991: LD_EXP 176
107995: PUSH
107996: LD_VAR 0 5
108000: ARRAY
108001: PUSH
108002: LD_EXP 177
108006: GREATEREQUAL
108007: IFFALSE 108011
// exit ;
108009: GO 108211
// ComMoveXY ( unit , x , y ) ;
108011: LD_VAR 0 1
108015: PPUSH
108016: LD_VAR 0 2
108020: PPUSH
108021: LD_VAR 0 3
108025: PPUSH
108026: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108030: LD_INT 35
108032: PPUSH
108033: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108037: LD_VAR 0 1
108041: PPUSH
108042: LD_VAR 0 2
108046: PPUSH
108047: LD_VAR 0 3
108051: PPUSH
108052: CALL 52518 0 3
108056: NOT
108057: PUSH
108058: LD_VAR 0 1
108062: PPUSH
108063: CALL_OW 314
108067: AND
108068: IFFALSE 108072
// exit ;
108070: GO 108211
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108072: LD_VAR 0 2
108076: PPUSH
108077: LD_VAR 0 3
108081: PPUSH
108082: CALL_OW 428
108086: PUSH
108087: LD_VAR 0 1
108091: EQUAL
108092: PUSH
108093: LD_VAR 0 1
108097: PPUSH
108098: CALL_OW 314
108102: NOT
108103: AND
108104: IFFALSE 108030
// PlaySoundXY ( x , y , PlantMine ) ;
108106: LD_VAR 0 2
108110: PPUSH
108111: LD_VAR 0 3
108115: PPUSH
108116: LD_STRING PlantMine
108118: PPUSH
108119: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108123: LD_VAR 0 2
108127: PPUSH
108128: LD_VAR 0 3
108132: PPUSH
108133: LD_VAR 0 1
108137: PPUSH
108138: CALL_OW 255
108142: PPUSH
108143: LD_INT 0
108145: PPUSH
108146: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108150: LD_ADDR_EXP 176
108154: PUSH
108155: LD_EXP 176
108159: PPUSH
108160: LD_VAR 0 5
108164: PUSH
108165: LD_EXP 176
108169: PUSH
108170: LD_VAR 0 5
108174: ARRAY
108175: PUSH
108176: LD_INT 1
108178: PLUS
108179: PUSH
108180: EMPTY
108181: LIST
108182: LIST
108183: PPUSH
108184: LD_VAR 0 2
108188: PUSH
108189: LD_VAR 0 3
108193: PUSH
108194: EMPTY
108195: LIST
108196: LIST
108197: PPUSH
108198: CALL 20981 0 3
108202: ST_TO_ADDR
// result := true ;
108203: LD_ADDR_VAR 0 4
108207: PUSH
108208: LD_INT 1
108210: ST_TO_ADDR
// end ;
108211: LD_VAR 0 4
108215: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108216: LD_INT 0
108218: PPUSH
108219: PPUSH
108220: PPUSH
// if not unit in minersList then
108221: LD_VAR 0 1
108225: PUSH
108226: LD_EXP 175
108230: IN
108231: NOT
108232: IFFALSE 108236
// exit ;
108234: GO 108628
// index := GetElementIndex ( minersList , unit ) ;
108236: LD_ADDR_VAR 0 6
108240: PUSH
108241: LD_EXP 175
108245: PPUSH
108246: LD_VAR 0 1
108250: PPUSH
108251: CALL 20766 0 2
108255: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108256: LD_ADDR_VAR 0 5
108260: PUSH
108261: DOUBLE
108262: LD_EXP 176
108266: PUSH
108267: LD_VAR 0 6
108271: ARRAY
108272: INC
108273: ST_TO_ADDR
108274: LD_INT 1
108276: PUSH
108277: FOR_DOWNTO
108278: IFFALSE 108439
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108280: LD_EXP 176
108284: PUSH
108285: LD_VAR 0 6
108289: ARRAY
108290: PUSH
108291: LD_VAR 0 5
108295: ARRAY
108296: PUSH
108297: LD_INT 1
108299: ARRAY
108300: PUSH
108301: LD_VAR 0 2
108305: EQUAL
108306: PUSH
108307: LD_EXP 176
108311: PUSH
108312: LD_VAR 0 6
108316: ARRAY
108317: PUSH
108318: LD_VAR 0 5
108322: ARRAY
108323: PUSH
108324: LD_INT 2
108326: ARRAY
108327: PUSH
108328: LD_VAR 0 3
108332: EQUAL
108333: AND
108334: IFFALSE 108437
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108336: LD_EXP 176
108340: PUSH
108341: LD_VAR 0 6
108345: ARRAY
108346: PUSH
108347: LD_VAR 0 5
108351: ARRAY
108352: PUSH
108353: LD_INT 1
108355: ARRAY
108356: PPUSH
108357: LD_EXP 176
108361: PUSH
108362: LD_VAR 0 6
108366: ARRAY
108367: PUSH
108368: LD_VAR 0 5
108372: ARRAY
108373: PUSH
108374: LD_INT 2
108376: ARRAY
108377: PPUSH
108378: LD_VAR 0 1
108382: PPUSH
108383: CALL_OW 255
108387: PPUSH
108388: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108392: LD_ADDR_EXP 176
108396: PUSH
108397: LD_EXP 176
108401: PPUSH
108402: LD_VAR 0 6
108406: PPUSH
108407: LD_EXP 176
108411: PUSH
108412: LD_VAR 0 6
108416: ARRAY
108417: PPUSH
108418: LD_VAR 0 5
108422: PPUSH
108423: CALL_OW 3
108427: PPUSH
108428: CALL_OW 1
108432: ST_TO_ADDR
// exit ;
108433: POP
108434: POP
108435: GO 108628
// end ; end ;
108437: GO 108277
108439: POP
108440: POP
// for i := minerMinesList [ index ] downto 1 do
108441: LD_ADDR_VAR 0 5
108445: PUSH
108446: DOUBLE
108447: LD_EXP 176
108451: PUSH
108452: LD_VAR 0 6
108456: ARRAY
108457: INC
108458: ST_TO_ADDR
108459: LD_INT 1
108461: PUSH
108462: FOR_DOWNTO
108463: IFFALSE 108626
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108465: LD_EXP 176
108469: PUSH
108470: LD_VAR 0 6
108474: ARRAY
108475: PUSH
108476: LD_VAR 0 5
108480: ARRAY
108481: PUSH
108482: LD_INT 1
108484: ARRAY
108485: PPUSH
108486: LD_EXP 176
108490: PUSH
108491: LD_VAR 0 6
108495: ARRAY
108496: PUSH
108497: LD_VAR 0 5
108501: ARRAY
108502: PUSH
108503: LD_INT 2
108505: ARRAY
108506: PPUSH
108507: LD_VAR 0 2
108511: PPUSH
108512: LD_VAR 0 3
108516: PPUSH
108517: CALL_OW 298
108521: PUSH
108522: LD_INT 6
108524: LESS
108525: IFFALSE 108624
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108527: LD_EXP 176
108531: PUSH
108532: LD_VAR 0 6
108536: ARRAY
108537: PUSH
108538: LD_VAR 0 5
108542: ARRAY
108543: PUSH
108544: LD_INT 1
108546: ARRAY
108547: PPUSH
108548: LD_EXP 176
108552: PUSH
108553: LD_VAR 0 6
108557: ARRAY
108558: PUSH
108559: LD_VAR 0 5
108563: ARRAY
108564: PUSH
108565: LD_INT 2
108567: ARRAY
108568: PPUSH
108569: LD_VAR 0 1
108573: PPUSH
108574: CALL_OW 255
108578: PPUSH
108579: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108583: LD_ADDR_EXP 176
108587: PUSH
108588: LD_EXP 176
108592: PPUSH
108593: LD_VAR 0 6
108597: PPUSH
108598: LD_EXP 176
108602: PUSH
108603: LD_VAR 0 6
108607: ARRAY
108608: PPUSH
108609: LD_VAR 0 5
108613: PPUSH
108614: CALL_OW 3
108618: PPUSH
108619: CALL_OW 1
108623: ST_TO_ADDR
// end ; end ;
108624: GO 108462
108626: POP
108627: POP
// end ;
108628: LD_VAR 0 4
108632: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108633: LD_INT 0
108635: PPUSH
108636: PPUSH
108637: PPUSH
108638: PPUSH
108639: PPUSH
108640: PPUSH
108641: PPUSH
108642: PPUSH
108643: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108644: LD_VAR 0 1
108648: PPUSH
108649: CALL_OW 264
108653: PUSH
108654: LD_INT 81
108656: EQUAL
108657: NOT
108658: PUSH
108659: LD_VAR 0 1
108663: PUSH
108664: LD_EXP 175
108668: IN
108669: NOT
108670: OR
108671: IFFALSE 108675
// exit ;
108673: GO 108997
// index := GetElementIndex ( minersList , unit ) ;
108675: LD_ADDR_VAR 0 6
108679: PUSH
108680: LD_EXP 175
108684: PPUSH
108685: LD_VAR 0 1
108689: PPUSH
108690: CALL 20766 0 2
108694: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108695: LD_ADDR_VAR 0 8
108699: PUSH
108700: LD_EXP 177
108704: PUSH
108705: LD_EXP 176
108709: PUSH
108710: LD_VAR 0 6
108714: ARRAY
108715: MINUS
108716: ST_TO_ADDR
// if not minesFreeAmount then
108717: LD_VAR 0 8
108721: NOT
108722: IFFALSE 108726
// exit ;
108724: GO 108997
// tmp := [ ] ;
108726: LD_ADDR_VAR 0 7
108730: PUSH
108731: EMPTY
108732: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
108733: LD_ADDR_VAR 0 5
108737: PUSH
108738: DOUBLE
108739: LD_INT 1
108741: DEC
108742: ST_TO_ADDR
108743: LD_VAR 0 8
108747: PUSH
108748: FOR_TO
108749: IFFALSE 108944
// begin _d := rand ( 0 , 5 ) ;
108751: LD_ADDR_VAR 0 11
108755: PUSH
108756: LD_INT 0
108758: PPUSH
108759: LD_INT 5
108761: PPUSH
108762: CALL_OW 12
108766: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
108767: LD_ADDR_VAR 0 12
108771: PUSH
108772: LD_INT 2
108774: PPUSH
108775: LD_INT 6
108777: PPUSH
108778: CALL_OW 12
108782: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
108783: LD_ADDR_VAR 0 9
108787: PUSH
108788: LD_VAR 0 2
108792: PPUSH
108793: LD_VAR 0 11
108797: PPUSH
108798: LD_VAR 0 12
108802: PPUSH
108803: CALL_OW 272
108807: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
108808: LD_ADDR_VAR 0 10
108812: PUSH
108813: LD_VAR 0 3
108817: PPUSH
108818: LD_VAR 0 11
108822: PPUSH
108823: LD_VAR 0 12
108827: PPUSH
108828: CALL_OW 273
108832: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
108833: LD_VAR 0 9
108837: PPUSH
108838: LD_VAR 0 10
108842: PPUSH
108843: CALL_OW 488
108847: PUSH
108848: LD_VAR 0 9
108852: PUSH
108853: LD_VAR 0 10
108857: PUSH
108858: EMPTY
108859: LIST
108860: LIST
108861: PUSH
108862: LD_VAR 0 7
108866: IN
108867: NOT
108868: AND
108869: PUSH
108870: LD_VAR 0 9
108874: PPUSH
108875: LD_VAR 0 10
108879: PPUSH
108880: CALL_OW 458
108884: NOT
108885: AND
108886: IFFALSE 108928
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
108888: LD_ADDR_VAR 0 7
108892: PUSH
108893: LD_VAR 0 7
108897: PPUSH
108898: LD_VAR 0 7
108902: PUSH
108903: LD_INT 1
108905: PLUS
108906: PPUSH
108907: LD_VAR 0 9
108911: PUSH
108912: LD_VAR 0 10
108916: PUSH
108917: EMPTY
108918: LIST
108919: LIST
108920: PPUSH
108921: CALL_OW 1
108925: ST_TO_ADDR
108926: GO 108942
// i := i - 1 ;
108928: LD_ADDR_VAR 0 5
108932: PUSH
108933: LD_VAR 0 5
108937: PUSH
108938: LD_INT 1
108940: MINUS
108941: ST_TO_ADDR
// end ;
108942: GO 108748
108944: POP
108945: POP
// for i in tmp do
108946: LD_ADDR_VAR 0 5
108950: PUSH
108951: LD_VAR 0 7
108955: PUSH
108956: FOR_IN
108957: IFFALSE 108995
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
108959: LD_VAR 0 1
108963: PPUSH
108964: LD_VAR 0 5
108968: PUSH
108969: LD_INT 1
108971: ARRAY
108972: PPUSH
108973: LD_VAR 0 5
108977: PUSH
108978: LD_INT 2
108980: ARRAY
108981: PPUSH
108982: CALL 107941 0 3
108986: NOT
108987: IFFALSE 108993
// exit ;
108989: POP
108990: POP
108991: GO 108997
108993: GO 108956
108995: POP
108996: POP
// end ;
108997: LD_VAR 0 4
109001: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109002: LD_INT 0
109004: PPUSH
109005: PPUSH
109006: PPUSH
109007: PPUSH
109008: PPUSH
109009: PPUSH
109010: PPUSH
// if not GetClass ( unit ) = class_sniper then
109011: LD_VAR 0 1
109015: PPUSH
109016: CALL_OW 257
109020: PUSH
109021: LD_INT 5
109023: EQUAL
109024: NOT
109025: IFFALSE 109029
// exit ;
109027: GO 109417
// dist := 8 ;
109029: LD_ADDR_VAR 0 5
109033: PUSH
109034: LD_INT 8
109036: ST_TO_ADDR
// viewRange := 12 ;
109037: LD_ADDR_VAR 0 7
109041: PUSH
109042: LD_INT 12
109044: ST_TO_ADDR
// side := GetSide ( unit ) ;
109045: LD_ADDR_VAR 0 6
109049: PUSH
109050: LD_VAR 0 1
109054: PPUSH
109055: CALL_OW 255
109059: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109060: LD_INT 61
109062: PPUSH
109063: LD_VAR 0 6
109067: PPUSH
109068: CALL_OW 321
109072: PUSH
109073: LD_INT 2
109075: EQUAL
109076: IFFALSE 109086
// viewRange := 16 ;
109078: LD_ADDR_VAR 0 7
109082: PUSH
109083: LD_INT 16
109085: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109086: LD_VAR 0 1
109090: PPUSH
109091: LD_VAR 0 2
109095: PPUSH
109096: LD_VAR 0 3
109100: PPUSH
109101: CALL_OW 297
109105: PUSH
109106: LD_VAR 0 5
109110: GREATER
109111: IFFALSE 109190
// begin ComMoveXY ( unit , x , y ) ;
109113: LD_VAR 0 1
109117: PPUSH
109118: LD_VAR 0 2
109122: PPUSH
109123: LD_VAR 0 3
109127: PPUSH
109128: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109132: LD_INT 35
109134: PPUSH
109135: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109139: LD_VAR 0 1
109143: PPUSH
109144: LD_VAR 0 2
109148: PPUSH
109149: LD_VAR 0 3
109153: PPUSH
109154: CALL 52518 0 3
109158: NOT
109159: IFFALSE 109163
// exit ;
109161: GO 109417
// until GetDistUnitXY ( unit , x , y ) < dist ;
109163: LD_VAR 0 1
109167: PPUSH
109168: LD_VAR 0 2
109172: PPUSH
109173: LD_VAR 0 3
109177: PPUSH
109178: CALL_OW 297
109182: PUSH
109183: LD_VAR 0 5
109187: LESS
109188: IFFALSE 109132
// end ; ComTurnXY ( unit , x , y ) ;
109190: LD_VAR 0 1
109194: PPUSH
109195: LD_VAR 0 2
109199: PPUSH
109200: LD_VAR 0 3
109204: PPUSH
109205: CALL_OW 118
// wait ( 5 ) ;
109209: LD_INT 5
109211: PPUSH
109212: CALL_OW 67
// _d := GetDir ( unit ) ;
109216: LD_ADDR_VAR 0 10
109220: PUSH
109221: LD_VAR 0 1
109225: PPUSH
109226: CALL_OW 254
109230: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109231: LD_ADDR_VAR 0 8
109235: PUSH
109236: LD_VAR 0 1
109240: PPUSH
109241: CALL_OW 250
109245: PPUSH
109246: LD_VAR 0 10
109250: PPUSH
109251: LD_VAR 0 5
109255: PPUSH
109256: CALL_OW 272
109260: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109261: LD_ADDR_VAR 0 9
109265: PUSH
109266: LD_VAR 0 1
109270: PPUSH
109271: CALL_OW 251
109275: PPUSH
109276: LD_VAR 0 10
109280: PPUSH
109281: LD_VAR 0 5
109285: PPUSH
109286: CALL_OW 273
109290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109291: LD_VAR 0 8
109295: PPUSH
109296: LD_VAR 0 9
109300: PPUSH
109301: CALL_OW 488
109305: NOT
109306: IFFALSE 109310
// exit ;
109308: GO 109417
// ComAnimCustom ( unit , 1 ) ;
109310: LD_VAR 0 1
109314: PPUSH
109315: LD_INT 1
109317: PPUSH
109318: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109322: LD_VAR 0 8
109326: PPUSH
109327: LD_VAR 0 9
109331: PPUSH
109332: LD_VAR 0 6
109336: PPUSH
109337: LD_VAR 0 7
109341: PPUSH
109342: CALL_OW 330
// repeat wait ( 1 ) ;
109346: LD_INT 1
109348: PPUSH
109349: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109353: LD_VAR 0 1
109357: PPUSH
109358: CALL_OW 316
109362: PUSH
109363: LD_VAR 0 1
109367: PPUSH
109368: CALL_OW 314
109372: OR
109373: PUSH
109374: LD_VAR 0 1
109378: PPUSH
109379: CALL_OW 302
109383: NOT
109384: OR
109385: PUSH
109386: LD_VAR 0 1
109390: PPUSH
109391: CALL_OW 301
109395: OR
109396: IFFALSE 109346
// RemoveSeeing ( _x , _y , side ) ;
109398: LD_VAR 0 8
109402: PPUSH
109403: LD_VAR 0 9
109407: PPUSH
109408: LD_VAR 0 6
109412: PPUSH
109413: CALL_OW 331
// end ; end_of_file
109417: LD_VAR 0 4
109421: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109422: LD_INT 0
109424: PPUSH
109425: PPUSH
109426: PPUSH
109427: PPUSH
109428: PPUSH
109429: PPUSH
109430: PPUSH
109431: PPUSH
109432: PPUSH
109433: PPUSH
109434: PPUSH
109435: PPUSH
109436: PPUSH
109437: PPUSH
109438: PPUSH
109439: PPUSH
109440: PPUSH
109441: PPUSH
109442: PPUSH
109443: PPUSH
109444: PPUSH
109445: PPUSH
109446: PPUSH
109447: PPUSH
109448: PPUSH
109449: PPUSH
109450: PPUSH
109451: PPUSH
109452: PPUSH
109453: PPUSH
109454: PPUSH
109455: PPUSH
109456: PPUSH
109457: PPUSH
// if not list then
109458: LD_VAR 0 1
109462: NOT
109463: IFFALSE 109467
// exit ;
109465: GO 114126
// base := list [ 1 ] ;
109467: LD_ADDR_VAR 0 3
109471: PUSH
109472: LD_VAR 0 1
109476: PUSH
109477: LD_INT 1
109479: ARRAY
109480: ST_TO_ADDR
// group := list [ 2 ] ;
109481: LD_ADDR_VAR 0 4
109485: PUSH
109486: LD_VAR 0 1
109490: PUSH
109491: LD_INT 2
109493: ARRAY
109494: ST_TO_ADDR
// path := list [ 3 ] ;
109495: LD_ADDR_VAR 0 5
109499: PUSH
109500: LD_VAR 0 1
109504: PUSH
109505: LD_INT 3
109507: ARRAY
109508: ST_TO_ADDR
// flags := list [ 4 ] ;
109509: LD_ADDR_VAR 0 6
109513: PUSH
109514: LD_VAR 0 1
109518: PUSH
109519: LD_INT 4
109521: ARRAY
109522: ST_TO_ADDR
// mined := [ ] ;
109523: LD_ADDR_VAR 0 27
109527: PUSH
109528: EMPTY
109529: ST_TO_ADDR
// bombed := [ ] ;
109530: LD_ADDR_VAR 0 28
109534: PUSH
109535: EMPTY
109536: ST_TO_ADDR
// healers := [ ] ;
109537: LD_ADDR_VAR 0 31
109541: PUSH
109542: EMPTY
109543: ST_TO_ADDR
// to_heal := [ ] ;
109544: LD_ADDR_VAR 0 30
109548: PUSH
109549: EMPTY
109550: ST_TO_ADDR
// repairs := [ ] ;
109551: LD_ADDR_VAR 0 33
109555: PUSH
109556: EMPTY
109557: ST_TO_ADDR
// to_repair := [ ] ;
109558: LD_ADDR_VAR 0 32
109562: PUSH
109563: EMPTY
109564: ST_TO_ADDR
// if not group or not path then
109565: LD_VAR 0 4
109569: NOT
109570: PUSH
109571: LD_VAR 0 5
109575: NOT
109576: OR
109577: IFFALSE 109581
// exit ;
109579: GO 114126
// side := GetSide ( group [ 1 ] ) ;
109581: LD_ADDR_VAR 0 35
109585: PUSH
109586: LD_VAR 0 4
109590: PUSH
109591: LD_INT 1
109593: ARRAY
109594: PPUSH
109595: CALL_OW 255
109599: ST_TO_ADDR
// if flags then
109600: LD_VAR 0 6
109604: IFFALSE 109748
// begin f_ignore_area := flags [ 1 ] ;
109606: LD_ADDR_VAR 0 17
109610: PUSH
109611: LD_VAR 0 6
109615: PUSH
109616: LD_INT 1
109618: ARRAY
109619: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109620: LD_ADDR_VAR 0 18
109624: PUSH
109625: LD_VAR 0 6
109629: PUSH
109630: LD_INT 2
109632: ARRAY
109633: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109634: LD_ADDR_VAR 0 19
109638: PUSH
109639: LD_VAR 0 6
109643: PUSH
109644: LD_INT 3
109646: ARRAY
109647: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109648: LD_ADDR_VAR 0 20
109652: PUSH
109653: LD_VAR 0 6
109657: PUSH
109658: LD_INT 4
109660: ARRAY
109661: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109662: LD_ADDR_VAR 0 21
109666: PUSH
109667: LD_VAR 0 6
109671: PUSH
109672: LD_INT 5
109674: ARRAY
109675: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109676: LD_ADDR_VAR 0 22
109680: PUSH
109681: LD_VAR 0 6
109685: PUSH
109686: LD_INT 6
109688: ARRAY
109689: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109690: LD_ADDR_VAR 0 23
109694: PUSH
109695: LD_VAR 0 6
109699: PUSH
109700: LD_INT 7
109702: ARRAY
109703: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
109704: LD_ADDR_VAR 0 24
109708: PUSH
109709: LD_VAR 0 6
109713: PUSH
109714: LD_INT 8
109716: ARRAY
109717: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
109718: LD_ADDR_VAR 0 25
109722: PUSH
109723: LD_VAR 0 6
109727: PUSH
109728: LD_INT 9
109730: ARRAY
109731: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
109732: LD_ADDR_VAR 0 26
109736: PUSH
109737: LD_VAR 0 6
109741: PUSH
109742: LD_INT 10
109744: ARRAY
109745: ST_TO_ADDR
// end else
109746: GO 109828
// begin f_ignore_area := false ;
109748: LD_ADDR_VAR 0 17
109752: PUSH
109753: LD_INT 0
109755: ST_TO_ADDR
// f_capture := false ;
109756: LD_ADDR_VAR 0 18
109760: PUSH
109761: LD_INT 0
109763: ST_TO_ADDR
// f_ignore_civ := false ;
109764: LD_ADDR_VAR 0 19
109768: PUSH
109769: LD_INT 0
109771: ST_TO_ADDR
// f_murder := false ;
109772: LD_ADDR_VAR 0 20
109776: PUSH
109777: LD_INT 0
109779: ST_TO_ADDR
// f_mines := false ;
109780: LD_ADDR_VAR 0 21
109784: PUSH
109785: LD_INT 0
109787: ST_TO_ADDR
// f_repair := false ;
109788: LD_ADDR_VAR 0 22
109792: PUSH
109793: LD_INT 0
109795: ST_TO_ADDR
// f_heal := false ;
109796: LD_ADDR_VAR 0 23
109800: PUSH
109801: LD_INT 0
109803: ST_TO_ADDR
// f_spacetime := false ;
109804: LD_ADDR_VAR 0 24
109808: PUSH
109809: LD_INT 0
109811: ST_TO_ADDR
// f_attack_depot := false ;
109812: LD_ADDR_VAR 0 25
109816: PUSH
109817: LD_INT 0
109819: ST_TO_ADDR
// f_crawl := false ;
109820: LD_ADDR_VAR 0 26
109824: PUSH
109825: LD_INT 0
109827: ST_TO_ADDR
// end ; if f_heal then
109828: LD_VAR 0 23
109832: IFFALSE 109859
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
109834: LD_ADDR_VAR 0 31
109838: PUSH
109839: LD_VAR 0 4
109843: PPUSH
109844: LD_INT 25
109846: PUSH
109847: LD_INT 4
109849: PUSH
109850: EMPTY
109851: LIST
109852: LIST
109853: PPUSH
109854: CALL_OW 72
109858: ST_TO_ADDR
// if f_repair then
109859: LD_VAR 0 22
109863: IFFALSE 109890
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
109865: LD_ADDR_VAR 0 33
109869: PUSH
109870: LD_VAR 0 4
109874: PPUSH
109875: LD_INT 25
109877: PUSH
109878: LD_INT 3
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: PPUSH
109885: CALL_OW 72
109889: ST_TO_ADDR
// units_path := [ ] ;
109890: LD_ADDR_VAR 0 16
109894: PUSH
109895: EMPTY
109896: ST_TO_ADDR
// for i = 1 to group do
109897: LD_ADDR_VAR 0 7
109901: PUSH
109902: DOUBLE
109903: LD_INT 1
109905: DEC
109906: ST_TO_ADDR
109907: LD_VAR 0 4
109911: PUSH
109912: FOR_TO
109913: IFFALSE 109942
// units_path := Replace ( units_path , i , path ) ;
109915: LD_ADDR_VAR 0 16
109919: PUSH
109920: LD_VAR 0 16
109924: PPUSH
109925: LD_VAR 0 7
109929: PPUSH
109930: LD_VAR 0 5
109934: PPUSH
109935: CALL_OW 1
109939: ST_TO_ADDR
109940: GO 109912
109942: POP
109943: POP
// repeat for i = group downto 1 do
109944: LD_ADDR_VAR 0 7
109948: PUSH
109949: DOUBLE
109950: LD_VAR 0 4
109954: INC
109955: ST_TO_ADDR
109956: LD_INT 1
109958: PUSH
109959: FOR_DOWNTO
109960: IFFALSE 114082
// begin wait ( 5 ) ;
109962: LD_INT 5
109964: PPUSH
109965: CALL_OW 67
// tmp := [ ] ;
109969: LD_ADDR_VAR 0 14
109973: PUSH
109974: EMPTY
109975: ST_TO_ADDR
// attacking := false ;
109976: LD_ADDR_VAR 0 29
109980: PUSH
109981: LD_INT 0
109983: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
109984: LD_VAR 0 4
109988: PUSH
109989: LD_VAR 0 7
109993: ARRAY
109994: PPUSH
109995: CALL_OW 301
109999: PUSH
110000: LD_VAR 0 4
110004: PUSH
110005: LD_VAR 0 7
110009: ARRAY
110010: NOT
110011: OR
110012: IFFALSE 110121
// begin if GetType ( group [ i ] ) = unit_human then
110014: LD_VAR 0 4
110018: PUSH
110019: LD_VAR 0 7
110023: ARRAY
110024: PPUSH
110025: CALL_OW 247
110029: PUSH
110030: LD_INT 1
110032: EQUAL
110033: IFFALSE 110079
// begin to_heal := to_heal diff group [ i ] ;
110035: LD_ADDR_VAR 0 30
110039: PUSH
110040: LD_VAR 0 30
110044: PUSH
110045: LD_VAR 0 4
110049: PUSH
110050: LD_VAR 0 7
110054: ARRAY
110055: DIFF
110056: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110057: LD_ADDR_VAR 0 31
110061: PUSH
110062: LD_VAR 0 31
110066: PUSH
110067: LD_VAR 0 4
110071: PUSH
110072: LD_VAR 0 7
110076: ARRAY
110077: DIFF
110078: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110079: LD_ADDR_VAR 0 4
110083: PUSH
110084: LD_VAR 0 4
110088: PPUSH
110089: LD_VAR 0 7
110093: PPUSH
110094: CALL_OW 3
110098: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110099: LD_ADDR_VAR 0 16
110103: PUSH
110104: LD_VAR 0 16
110108: PPUSH
110109: LD_VAR 0 7
110113: PPUSH
110114: CALL_OW 3
110118: ST_TO_ADDR
// continue ;
110119: GO 109959
// end ; if f_repair then
110121: LD_VAR 0 22
110125: IFFALSE 110614
// begin if GetType ( group [ i ] ) = unit_vehicle then
110127: LD_VAR 0 4
110131: PUSH
110132: LD_VAR 0 7
110136: ARRAY
110137: PPUSH
110138: CALL_OW 247
110142: PUSH
110143: LD_INT 2
110145: EQUAL
110146: IFFALSE 110336
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110148: LD_VAR 0 4
110152: PUSH
110153: LD_VAR 0 7
110157: ARRAY
110158: PPUSH
110159: CALL_OW 256
110163: PUSH
110164: LD_INT 700
110166: LESS
110167: PUSH
110168: LD_VAR 0 4
110172: PUSH
110173: LD_VAR 0 7
110177: ARRAY
110178: PUSH
110179: LD_VAR 0 32
110183: IN
110184: NOT
110185: AND
110186: IFFALSE 110210
// to_repair := to_repair union group [ i ] ;
110188: LD_ADDR_VAR 0 32
110192: PUSH
110193: LD_VAR 0 32
110197: PUSH
110198: LD_VAR 0 4
110202: PUSH
110203: LD_VAR 0 7
110207: ARRAY
110208: UNION
110209: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110210: LD_VAR 0 4
110214: PUSH
110215: LD_VAR 0 7
110219: ARRAY
110220: PPUSH
110221: CALL_OW 256
110225: PUSH
110226: LD_INT 1000
110228: EQUAL
110229: PUSH
110230: LD_VAR 0 4
110234: PUSH
110235: LD_VAR 0 7
110239: ARRAY
110240: PUSH
110241: LD_VAR 0 32
110245: IN
110246: AND
110247: IFFALSE 110271
// to_repair := to_repair diff group [ i ] ;
110249: LD_ADDR_VAR 0 32
110253: PUSH
110254: LD_VAR 0 32
110258: PUSH
110259: LD_VAR 0 4
110263: PUSH
110264: LD_VAR 0 7
110268: ARRAY
110269: DIFF
110270: ST_TO_ADDR
// if group [ i ] in to_repair then
110271: LD_VAR 0 4
110275: PUSH
110276: LD_VAR 0 7
110280: ARRAY
110281: PUSH
110282: LD_VAR 0 32
110286: IN
110287: IFFALSE 110334
// begin if not IsInArea ( group [ i ] , f_repair ) then
110289: LD_VAR 0 4
110293: PUSH
110294: LD_VAR 0 7
110298: ARRAY
110299: PPUSH
110300: LD_VAR 0 22
110304: PPUSH
110305: CALL_OW 308
110309: NOT
110310: IFFALSE 110332
// ComMoveToArea ( group [ i ] , f_repair ) ;
110312: LD_VAR 0 4
110316: PUSH
110317: LD_VAR 0 7
110321: ARRAY
110322: PPUSH
110323: LD_VAR 0 22
110327: PPUSH
110328: CALL_OW 113
// continue ;
110332: GO 109959
// end ; end else
110334: GO 110614
// if group [ i ] in repairs then
110336: LD_VAR 0 4
110340: PUSH
110341: LD_VAR 0 7
110345: ARRAY
110346: PUSH
110347: LD_VAR 0 33
110351: IN
110352: IFFALSE 110614
// begin if IsInUnit ( group [ i ] ) then
110354: LD_VAR 0 4
110358: PUSH
110359: LD_VAR 0 7
110363: ARRAY
110364: PPUSH
110365: CALL_OW 310
110369: IFFALSE 110437
// begin z := IsInUnit ( group [ i ] ) ;
110371: LD_ADDR_VAR 0 13
110375: PUSH
110376: LD_VAR 0 4
110380: PUSH
110381: LD_VAR 0 7
110385: ARRAY
110386: PPUSH
110387: CALL_OW 310
110391: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110392: LD_VAR 0 13
110396: PUSH
110397: LD_VAR 0 32
110401: IN
110402: PUSH
110403: LD_VAR 0 13
110407: PPUSH
110408: LD_VAR 0 22
110412: PPUSH
110413: CALL_OW 308
110417: AND
110418: IFFALSE 110435
// ComExitVehicle ( group [ i ] ) ;
110420: LD_VAR 0 4
110424: PUSH
110425: LD_VAR 0 7
110429: ARRAY
110430: PPUSH
110431: CALL_OW 121
// end else
110435: GO 110614
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110437: LD_ADDR_VAR 0 13
110441: PUSH
110442: LD_VAR 0 4
110446: PPUSH
110447: LD_INT 95
110449: PUSH
110450: LD_VAR 0 22
110454: PUSH
110455: EMPTY
110456: LIST
110457: LIST
110458: PUSH
110459: LD_INT 58
110461: PUSH
110462: EMPTY
110463: LIST
110464: PUSH
110465: EMPTY
110466: LIST
110467: LIST
110468: PPUSH
110469: CALL_OW 72
110473: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110474: LD_VAR 0 4
110478: PUSH
110479: LD_VAR 0 7
110483: ARRAY
110484: PPUSH
110485: CALL_OW 314
110489: NOT
110490: IFFALSE 110612
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110492: LD_ADDR_VAR 0 10
110496: PUSH
110497: LD_VAR 0 13
110501: PPUSH
110502: LD_VAR 0 4
110506: PUSH
110507: LD_VAR 0 7
110511: ARRAY
110512: PPUSH
110513: CALL_OW 74
110517: ST_TO_ADDR
// if not x then
110518: LD_VAR 0 10
110522: NOT
110523: IFFALSE 110527
// continue ;
110525: GO 109959
// if GetLives ( x ) < 1000 then
110527: LD_VAR 0 10
110531: PPUSH
110532: CALL_OW 256
110536: PUSH
110537: LD_INT 1000
110539: LESS
110540: IFFALSE 110564
// ComRepairVehicle ( group [ i ] , x ) else
110542: LD_VAR 0 4
110546: PUSH
110547: LD_VAR 0 7
110551: ARRAY
110552: PPUSH
110553: LD_VAR 0 10
110557: PPUSH
110558: CALL_OW 129
110562: GO 110612
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
110564: LD_VAR 0 23
110568: PUSH
110569: LD_VAR 0 4
110573: PUSH
110574: LD_VAR 0 7
110578: ARRAY
110579: PPUSH
110580: CALL_OW 256
110584: PUSH
110585: LD_INT 1000
110587: LESS
110588: AND
110589: NOT
110590: IFFALSE 110612
// ComEnterUnit ( group [ i ] , x ) ;
110592: LD_VAR 0 4
110596: PUSH
110597: LD_VAR 0 7
110601: ARRAY
110602: PPUSH
110603: LD_VAR 0 10
110607: PPUSH
110608: CALL_OW 120
// end ; continue ;
110612: GO 109959
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110614: LD_VAR 0 23
110618: PUSH
110619: LD_VAR 0 4
110623: PUSH
110624: LD_VAR 0 7
110628: ARRAY
110629: PPUSH
110630: CALL_OW 247
110634: PUSH
110635: LD_INT 1
110637: EQUAL
110638: AND
110639: IFFALSE 111117
// begin if group [ i ] in healers then
110641: LD_VAR 0 4
110645: PUSH
110646: LD_VAR 0 7
110650: ARRAY
110651: PUSH
110652: LD_VAR 0 31
110656: IN
110657: IFFALSE 110930
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110659: LD_VAR 0 4
110663: PUSH
110664: LD_VAR 0 7
110668: ARRAY
110669: PPUSH
110670: LD_VAR 0 23
110674: PPUSH
110675: CALL_OW 308
110679: NOT
110680: PUSH
110681: LD_VAR 0 4
110685: PUSH
110686: LD_VAR 0 7
110690: ARRAY
110691: PPUSH
110692: CALL_OW 314
110696: NOT
110697: AND
110698: IFFALSE 110722
// ComMoveToArea ( group [ i ] , f_heal ) else
110700: LD_VAR 0 4
110704: PUSH
110705: LD_VAR 0 7
110709: ARRAY
110710: PPUSH
110711: LD_VAR 0 23
110715: PPUSH
110716: CALL_OW 113
110720: GO 110928
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
110722: LD_VAR 0 4
110726: PUSH
110727: LD_VAR 0 7
110731: ARRAY
110732: PPUSH
110733: CALL 51101 0 1
110737: PPUSH
110738: CALL_OW 256
110742: PUSH
110743: LD_INT 1000
110745: EQUAL
110746: IFFALSE 110765
// ComStop ( group [ i ] ) else
110748: LD_VAR 0 4
110752: PUSH
110753: LD_VAR 0 7
110757: ARRAY
110758: PPUSH
110759: CALL_OW 141
110763: GO 110928
// if not HasTask ( group [ i ] ) and to_heal then
110765: LD_VAR 0 4
110769: PUSH
110770: LD_VAR 0 7
110774: ARRAY
110775: PPUSH
110776: CALL_OW 314
110780: NOT
110781: PUSH
110782: LD_VAR 0 30
110786: AND
110787: IFFALSE 110928
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
110789: LD_ADDR_VAR 0 13
110793: PUSH
110794: LD_VAR 0 30
110798: PPUSH
110799: LD_INT 3
110801: PUSH
110802: LD_INT 54
110804: PUSH
110805: EMPTY
110806: LIST
110807: PUSH
110808: EMPTY
110809: LIST
110810: LIST
110811: PPUSH
110812: CALL_OW 72
110816: PPUSH
110817: LD_VAR 0 4
110821: PUSH
110822: LD_VAR 0 7
110826: ARRAY
110827: PPUSH
110828: CALL_OW 74
110832: ST_TO_ADDR
// if z then
110833: LD_VAR 0 13
110837: IFFALSE 110928
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
110839: LD_INT 91
110841: PUSH
110842: LD_VAR 0 13
110846: PUSH
110847: LD_INT 10
110849: PUSH
110850: EMPTY
110851: LIST
110852: LIST
110853: LIST
110854: PUSH
110855: LD_INT 81
110857: PUSH
110858: LD_VAR 0 13
110862: PPUSH
110863: CALL_OW 255
110867: PUSH
110868: EMPTY
110869: LIST
110870: LIST
110871: PUSH
110872: EMPTY
110873: LIST
110874: LIST
110875: PPUSH
110876: CALL_OW 69
110880: PUSH
110881: LD_INT 0
110883: EQUAL
110884: IFFALSE 110908
// ComHeal ( group [ i ] , z ) else
110886: LD_VAR 0 4
110890: PUSH
110891: LD_VAR 0 7
110895: ARRAY
110896: PPUSH
110897: LD_VAR 0 13
110901: PPUSH
110902: CALL_OW 128
110906: GO 110928
// ComMoveToArea ( group [ i ] , f_heal ) ;
110908: LD_VAR 0 4
110912: PUSH
110913: LD_VAR 0 7
110917: ARRAY
110918: PPUSH
110919: LD_VAR 0 23
110923: PPUSH
110924: CALL_OW 113
// end ; continue ;
110928: GO 109959
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
110930: LD_VAR 0 4
110934: PUSH
110935: LD_VAR 0 7
110939: ARRAY
110940: PPUSH
110941: CALL_OW 256
110945: PUSH
110946: LD_INT 700
110948: LESS
110949: PUSH
110950: LD_VAR 0 4
110954: PUSH
110955: LD_VAR 0 7
110959: ARRAY
110960: PUSH
110961: LD_VAR 0 30
110965: IN
110966: NOT
110967: AND
110968: IFFALSE 110992
// to_heal := to_heal union group [ i ] ;
110970: LD_ADDR_VAR 0 30
110974: PUSH
110975: LD_VAR 0 30
110979: PUSH
110980: LD_VAR 0 4
110984: PUSH
110985: LD_VAR 0 7
110989: ARRAY
110990: UNION
110991: ST_TO_ADDR
// if group [ i ] in to_heal then
110992: LD_VAR 0 4
110996: PUSH
110997: LD_VAR 0 7
111001: ARRAY
111002: PUSH
111003: LD_VAR 0 30
111007: IN
111008: IFFALSE 111117
// begin if GetLives ( group [ i ] ) = 1000 then
111010: LD_VAR 0 4
111014: PUSH
111015: LD_VAR 0 7
111019: ARRAY
111020: PPUSH
111021: CALL_OW 256
111025: PUSH
111026: LD_INT 1000
111028: EQUAL
111029: IFFALSE 111055
// to_heal := to_heal diff group [ i ] else
111031: LD_ADDR_VAR 0 30
111035: PUSH
111036: LD_VAR 0 30
111040: PUSH
111041: LD_VAR 0 4
111045: PUSH
111046: LD_VAR 0 7
111050: ARRAY
111051: DIFF
111052: ST_TO_ADDR
111053: GO 111117
// begin if not IsInArea ( group [ i ] , to_heal ) then
111055: LD_VAR 0 4
111059: PUSH
111060: LD_VAR 0 7
111064: ARRAY
111065: PPUSH
111066: LD_VAR 0 30
111070: PPUSH
111071: CALL_OW 308
111075: NOT
111076: IFFALSE 111100
// ComMoveToArea ( group [ i ] , f_heal ) else
111078: LD_VAR 0 4
111082: PUSH
111083: LD_VAR 0 7
111087: ARRAY
111088: PPUSH
111089: LD_VAR 0 23
111093: PPUSH
111094: CALL_OW 113
111098: GO 111115
// ComHold ( group [ i ] ) ;
111100: LD_VAR 0 4
111104: PUSH
111105: LD_VAR 0 7
111109: ARRAY
111110: PPUSH
111111: CALL_OW 140
// continue ;
111115: GO 109959
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111117: LD_VAR 0 4
111121: PUSH
111122: LD_VAR 0 7
111126: ARRAY
111127: PPUSH
111128: LD_INT 10
111130: PPUSH
111131: CALL 48872 0 2
111135: NOT
111136: PUSH
111137: LD_VAR 0 16
111141: PUSH
111142: LD_VAR 0 7
111146: ARRAY
111147: PUSH
111148: EMPTY
111149: EQUAL
111150: NOT
111151: AND
111152: IFFALSE 111418
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111154: LD_VAR 0 4
111158: PUSH
111159: LD_VAR 0 7
111163: ARRAY
111164: PPUSH
111165: CALL_OW 262
111169: PUSH
111170: LD_INT 1
111172: PUSH
111173: LD_INT 2
111175: PUSH
111176: EMPTY
111177: LIST
111178: LIST
111179: IN
111180: IFFALSE 111221
// if GetFuel ( group [ i ] ) < 10 then
111182: LD_VAR 0 4
111186: PUSH
111187: LD_VAR 0 7
111191: ARRAY
111192: PPUSH
111193: CALL_OW 261
111197: PUSH
111198: LD_INT 10
111200: LESS
111201: IFFALSE 111221
// SetFuel ( group [ i ] , 12 ) ;
111203: LD_VAR 0 4
111207: PUSH
111208: LD_VAR 0 7
111212: ARRAY
111213: PPUSH
111214: LD_INT 12
111216: PPUSH
111217: CALL_OW 240
// if units_path [ i ] then
111221: LD_VAR 0 16
111225: PUSH
111226: LD_VAR 0 7
111230: ARRAY
111231: IFFALSE 111416
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111233: LD_VAR 0 4
111237: PUSH
111238: LD_VAR 0 7
111242: ARRAY
111243: PPUSH
111244: LD_VAR 0 16
111248: PUSH
111249: LD_VAR 0 7
111253: ARRAY
111254: PUSH
111255: LD_INT 1
111257: ARRAY
111258: PUSH
111259: LD_INT 1
111261: ARRAY
111262: PPUSH
111263: LD_VAR 0 16
111267: PUSH
111268: LD_VAR 0 7
111272: ARRAY
111273: PUSH
111274: LD_INT 1
111276: ARRAY
111277: PUSH
111278: LD_INT 2
111280: ARRAY
111281: PPUSH
111282: CALL_OW 297
111286: PUSH
111287: LD_INT 6
111289: GREATER
111290: IFFALSE 111365
// begin if not HasTask ( group [ i ] ) then
111292: LD_VAR 0 4
111296: PUSH
111297: LD_VAR 0 7
111301: ARRAY
111302: PPUSH
111303: CALL_OW 314
111307: NOT
111308: IFFALSE 111363
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111310: LD_VAR 0 4
111314: PUSH
111315: LD_VAR 0 7
111319: ARRAY
111320: PPUSH
111321: LD_VAR 0 16
111325: PUSH
111326: LD_VAR 0 7
111330: ARRAY
111331: PUSH
111332: LD_INT 1
111334: ARRAY
111335: PUSH
111336: LD_INT 1
111338: ARRAY
111339: PPUSH
111340: LD_VAR 0 16
111344: PUSH
111345: LD_VAR 0 7
111349: ARRAY
111350: PUSH
111351: LD_INT 1
111353: ARRAY
111354: PUSH
111355: LD_INT 2
111357: ARRAY
111358: PPUSH
111359: CALL_OW 114
// end else
111363: GO 111416
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111365: LD_ADDR_VAR 0 15
111369: PUSH
111370: LD_VAR 0 16
111374: PUSH
111375: LD_VAR 0 7
111379: ARRAY
111380: PPUSH
111381: LD_INT 1
111383: PPUSH
111384: CALL_OW 3
111388: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111389: LD_ADDR_VAR 0 16
111393: PUSH
111394: LD_VAR 0 16
111398: PPUSH
111399: LD_VAR 0 7
111403: PPUSH
111404: LD_VAR 0 15
111408: PPUSH
111409: CALL_OW 1
111413: ST_TO_ADDR
// continue ;
111414: GO 109959
// end ; end ; end else
111416: GO 114080
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111418: LD_ADDR_VAR 0 14
111422: PUSH
111423: LD_INT 81
111425: PUSH
111426: LD_VAR 0 4
111430: PUSH
111431: LD_VAR 0 7
111435: ARRAY
111436: PPUSH
111437: CALL_OW 255
111441: PUSH
111442: EMPTY
111443: LIST
111444: LIST
111445: PPUSH
111446: CALL_OW 69
111450: ST_TO_ADDR
// if not tmp then
111451: LD_VAR 0 14
111455: NOT
111456: IFFALSE 111460
// continue ;
111458: GO 109959
// if f_ignore_area then
111460: LD_VAR 0 17
111464: IFFALSE 111552
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111466: LD_ADDR_VAR 0 15
111470: PUSH
111471: LD_VAR 0 14
111475: PPUSH
111476: LD_INT 3
111478: PUSH
111479: LD_INT 92
111481: PUSH
111482: LD_VAR 0 17
111486: PUSH
111487: LD_INT 1
111489: ARRAY
111490: PUSH
111491: LD_VAR 0 17
111495: PUSH
111496: LD_INT 2
111498: ARRAY
111499: PUSH
111500: LD_VAR 0 17
111504: PUSH
111505: LD_INT 3
111507: ARRAY
111508: PUSH
111509: EMPTY
111510: LIST
111511: LIST
111512: LIST
111513: LIST
111514: PUSH
111515: EMPTY
111516: LIST
111517: LIST
111518: PPUSH
111519: CALL_OW 72
111523: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111524: LD_VAR 0 14
111528: PUSH
111529: LD_VAR 0 15
111533: DIFF
111534: IFFALSE 111552
// tmp := tmp diff tmp2 ;
111536: LD_ADDR_VAR 0 14
111540: PUSH
111541: LD_VAR 0 14
111545: PUSH
111546: LD_VAR 0 15
111550: DIFF
111551: ST_TO_ADDR
// end ; if not f_murder then
111552: LD_VAR 0 20
111556: NOT
111557: IFFALSE 111615
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
111559: LD_ADDR_VAR 0 15
111563: PUSH
111564: LD_VAR 0 14
111568: PPUSH
111569: LD_INT 3
111571: PUSH
111572: LD_INT 50
111574: PUSH
111575: EMPTY
111576: LIST
111577: PUSH
111578: EMPTY
111579: LIST
111580: LIST
111581: PPUSH
111582: CALL_OW 72
111586: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111587: LD_VAR 0 14
111591: PUSH
111592: LD_VAR 0 15
111596: DIFF
111597: IFFALSE 111615
// tmp := tmp diff tmp2 ;
111599: LD_ADDR_VAR 0 14
111603: PUSH
111604: LD_VAR 0 14
111608: PUSH
111609: LD_VAR 0 15
111613: DIFF
111614: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111615: LD_ADDR_VAR 0 14
111619: PUSH
111620: LD_VAR 0 4
111624: PUSH
111625: LD_VAR 0 7
111629: ARRAY
111630: PPUSH
111631: LD_VAR 0 14
111635: PPUSH
111636: LD_INT 1
111638: PPUSH
111639: LD_INT 1
111641: PPUSH
111642: CALL 21416 0 4
111646: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111647: LD_VAR 0 4
111651: PUSH
111652: LD_VAR 0 7
111656: ARRAY
111657: PPUSH
111658: CALL_OW 257
111662: PUSH
111663: LD_INT 1
111665: EQUAL
111666: IFFALSE 112114
// begin if WantPlant ( group [ i ] ) then
111668: LD_VAR 0 4
111672: PUSH
111673: LD_VAR 0 7
111677: ARRAY
111678: PPUSH
111679: CALL 20917 0 1
111683: IFFALSE 111687
// continue ;
111685: GO 109959
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111687: LD_VAR 0 18
111691: PUSH
111692: LD_VAR 0 4
111696: PUSH
111697: LD_VAR 0 7
111701: ARRAY
111702: PPUSH
111703: CALL_OW 310
111707: NOT
111708: AND
111709: PUSH
111710: LD_VAR 0 14
111714: PUSH
111715: LD_INT 1
111717: ARRAY
111718: PUSH
111719: LD_VAR 0 14
111723: PPUSH
111724: LD_INT 21
111726: PUSH
111727: LD_INT 2
111729: PUSH
111730: EMPTY
111731: LIST
111732: LIST
111733: PUSH
111734: LD_INT 58
111736: PUSH
111737: EMPTY
111738: LIST
111739: PUSH
111740: EMPTY
111741: LIST
111742: LIST
111743: PPUSH
111744: CALL_OW 72
111748: IN
111749: AND
111750: IFFALSE 111786
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
111752: LD_VAR 0 4
111756: PUSH
111757: LD_VAR 0 7
111761: ARRAY
111762: PPUSH
111763: LD_VAR 0 14
111767: PUSH
111768: LD_INT 1
111770: ARRAY
111771: PPUSH
111772: CALL_OW 120
// attacking := true ;
111776: LD_ADDR_VAR 0 29
111780: PUSH
111781: LD_INT 1
111783: ST_TO_ADDR
// continue ;
111784: GO 109959
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
111786: LD_VAR 0 26
111790: PUSH
111791: LD_VAR 0 4
111795: PUSH
111796: LD_VAR 0 7
111800: ARRAY
111801: PPUSH
111802: CALL_OW 257
111806: PUSH
111807: LD_INT 1
111809: EQUAL
111810: AND
111811: PUSH
111812: LD_VAR 0 4
111816: PUSH
111817: LD_VAR 0 7
111821: ARRAY
111822: PPUSH
111823: CALL_OW 256
111827: PUSH
111828: LD_INT 800
111830: LESS
111831: AND
111832: PUSH
111833: LD_VAR 0 4
111837: PUSH
111838: LD_VAR 0 7
111842: ARRAY
111843: PPUSH
111844: CALL_OW 318
111848: NOT
111849: AND
111850: IFFALSE 111867
// ComCrawl ( group [ i ] ) ;
111852: LD_VAR 0 4
111856: PUSH
111857: LD_VAR 0 7
111861: ARRAY
111862: PPUSH
111863: CALL_OW 137
// if f_mines then
111867: LD_VAR 0 21
111871: IFFALSE 112114
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
111873: LD_VAR 0 14
111877: PUSH
111878: LD_INT 1
111880: ARRAY
111881: PPUSH
111882: CALL_OW 247
111886: PUSH
111887: LD_INT 3
111889: EQUAL
111890: PUSH
111891: LD_VAR 0 14
111895: PUSH
111896: LD_INT 1
111898: ARRAY
111899: PUSH
111900: LD_VAR 0 27
111904: IN
111905: NOT
111906: AND
111907: IFFALSE 112114
// begin x := GetX ( tmp [ 1 ] ) ;
111909: LD_ADDR_VAR 0 10
111913: PUSH
111914: LD_VAR 0 14
111918: PUSH
111919: LD_INT 1
111921: ARRAY
111922: PPUSH
111923: CALL_OW 250
111927: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
111928: LD_ADDR_VAR 0 11
111932: PUSH
111933: LD_VAR 0 14
111937: PUSH
111938: LD_INT 1
111940: ARRAY
111941: PPUSH
111942: CALL_OW 251
111946: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
111947: LD_ADDR_VAR 0 12
111951: PUSH
111952: LD_VAR 0 4
111956: PUSH
111957: LD_VAR 0 7
111961: ARRAY
111962: PPUSH
111963: CALL 48957 0 1
111967: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
111968: LD_VAR 0 4
111972: PUSH
111973: LD_VAR 0 7
111977: ARRAY
111978: PPUSH
111979: LD_VAR 0 10
111983: PPUSH
111984: LD_VAR 0 11
111988: PPUSH
111989: LD_VAR 0 14
111993: PUSH
111994: LD_INT 1
111996: ARRAY
111997: PPUSH
111998: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112002: LD_VAR 0 4
112006: PUSH
112007: LD_VAR 0 7
112011: ARRAY
112012: PPUSH
112013: LD_VAR 0 10
112017: PPUSH
112018: LD_VAR 0 12
112022: PPUSH
112023: LD_INT 7
112025: PPUSH
112026: CALL_OW 272
112030: PPUSH
112031: LD_VAR 0 11
112035: PPUSH
112036: LD_VAR 0 12
112040: PPUSH
112041: LD_INT 7
112043: PPUSH
112044: CALL_OW 273
112048: PPUSH
112049: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112053: LD_VAR 0 4
112057: PUSH
112058: LD_VAR 0 7
112062: ARRAY
112063: PPUSH
112064: LD_INT 71
112066: PPUSH
112067: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112071: LD_ADDR_VAR 0 27
112075: PUSH
112076: LD_VAR 0 27
112080: PPUSH
112081: LD_VAR 0 27
112085: PUSH
112086: LD_INT 1
112088: PLUS
112089: PPUSH
112090: LD_VAR 0 14
112094: PUSH
112095: LD_INT 1
112097: ARRAY
112098: PPUSH
112099: CALL_OW 1
112103: ST_TO_ADDR
// attacking := true ;
112104: LD_ADDR_VAR 0 29
112108: PUSH
112109: LD_INT 1
112111: ST_TO_ADDR
// continue ;
112112: GO 109959
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112114: LD_VAR 0 4
112118: PUSH
112119: LD_VAR 0 7
112123: ARRAY
112124: PPUSH
112125: CALL_OW 257
112129: PUSH
112130: LD_INT 17
112132: EQUAL
112133: PUSH
112134: LD_VAR 0 4
112138: PUSH
112139: LD_VAR 0 7
112143: ARRAY
112144: PPUSH
112145: CALL_OW 110
112149: PUSH
112150: LD_INT 71
112152: EQUAL
112153: NOT
112154: AND
112155: IFFALSE 112301
// begin attacking := false ;
112157: LD_ADDR_VAR 0 29
112161: PUSH
112162: LD_INT 0
112164: ST_TO_ADDR
// k := 5 ;
112165: LD_ADDR_VAR 0 9
112169: PUSH
112170: LD_INT 5
112172: ST_TO_ADDR
// if tmp < k then
112173: LD_VAR 0 14
112177: PUSH
112178: LD_VAR 0 9
112182: LESS
112183: IFFALSE 112195
// k := tmp ;
112185: LD_ADDR_VAR 0 9
112189: PUSH
112190: LD_VAR 0 14
112194: ST_TO_ADDR
// for j = 1 to k do
112195: LD_ADDR_VAR 0 8
112199: PUSH
112200: DOUBLE
112201: LD_INT 1
112203: DEC
112204: ST_TO_ADDR
112205: LD_VAR 0 9
112209: PUSH
112210: FOR_TO
112211: IFFALSE 112299
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112213: LD_VAR 0 14
112217: PUSH
112218: LD_VAR 0 8
112222: ARRAY
112223: PUSH
112224: LD_VAR 0 14
112228: PPUSH
112229: LD_INT 58
112231: PUSH
112232: EMPTY
112233: LIST
112234: PPUSH
112235: CALL_OW 72
112239: IN
112240: NOT
112241: IFFALSE 112297
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112243: LD_VAR 0 4
112247: PUSH
112248: LD_VAR 0 7
112252: ARRAY
112253: PPUSH
112254: LD_VAR 0 14
112258: PUSH
112259: LD_VAR 0 8
112263: ARRAY
112264: PPUSH
112265: CALL_OW 115
// attacking := true ;
112269: LD_ADDR_VAR 0 29
112273: PUSH
112274: LD_INT 1
112276: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112277: LD_VAR 0 4
112281: PUSH
112282: LD_VAR 0 7
112286: ARRAY
112287: PPUSH
112288: LD_INT 71
112290: PPUSH
112291: CALL_OW 109
// continue ;
112295: GO 112210
// end ; end ;
112297: GO 112210
112299: POP
112300: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112301: LD_VAR 0 4
112305: PUSH
112306: LD_VAR 0 7
112310: ARRAY
112311: PPUSH
112312: CALL_OW 257
112316: PUSH
112317: LD_INT 8
112319: EQUAL
112320: PUSH
112321: LD_VAR 0 4
112325: PUSH
112326: LD_VAR 0 7
112330: ARRAY
112331: PPUSH
112332: CALL_OW 264
112336: PUSH
112337: LD_INT 28
112339: PUSH
112340: LD_INT 45
112342: PUSH
112343: LD_INT 7
112345: PUSH
112346: LD_INT 47
112348: PUSH
112349: EMPTY
112350: LIST
112351: LIST
112352: LIST
112353: LIST
112354: IN
112355: OR
112356: IFFALSE 112612
// begin attacking := false ;
112358: LD_ADDR_VAR 0 29
112362: PUSH
112363: LD_INT 0
112365: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112366: LD_VAR 0 14
112370: PUSH
112371: LD_INT 1
112373: ARRAY
112374: PPUSH
112375: CALL_OW 266
112379: PUSH
112380: LD_INT 32
112382: PUSH
112383: LD_INT 31
112385: PUSH
112386: LD_INT 33
112388: PUSH
112389: LD_INT 4
112391: PUSH
112392: LD_INT 5
112394: PUSH
112395: EMPTY
112396: LIST
112397: LIST
112398: LIST
112399: LIST
112400: LIST
112401: IN
112402: IFFALSE 112588
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112404: LD_ADDR_VAR 0 9
112408: PUSH
112409: LD_VAR 0 14
112413: PUSH
112414: LD_INT 1
112416: ARRAY
112417: PPUSH
112418: CALL_OW 266
112422: PPUSH
112423: LD_VAR 0 14
112427: PUSH
112428: LD_INT 1
112430: ARRAY
112431: PPUSH
112432: CALL_OW 250
112436: PPUSH
112437: LD_VAR 0 14
112441: PUSH
112442: LD_INT 1
112444: ARRAY
112445: PPUSH
112446: CALL_OW 251
112450: PPUSH
112451: LD_VAR 0 14
112455: PUSH
112456: LD_INT 1
112458: ARRAY
112459: PPUSH
112460: CALL_OW 254
112464: PPUSH
112465: LD_VAR 0 14
112469: PUSH
112470: LD_INT 1
112472: ARRAY
112473: PPUSH
112474: CALL_OW 248
112478: PPUSH
112479: LD_INT 0
112481: PPUSH
112482: CALL 30327 0 6
112486: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112487: LD_ADDR_VAR 0 8
112491: PUSH
112492: LD_VAR 0 4
112496: PUSH
112497: LD_VAR 0 7
112501: ARRAY
112502: PPUSH
112503: LD_VAR 0 9
112507: PPUSH
112508: CALL 49070 0 2
112512: ST_TO_ADDR
// if j then
112513: LD_VAR 0 8
112517: IFFALSE 112586
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
112519: LD_VAR 0 8
112523: PUSH
112524: LD_INT 1
112526: ARRAY
112527: PPUSH
112528: LD_VAR 0 8
112532: PUSH
112533: LD_INT 2
112535: ARRAY
112536: PPUSH
112537: CALL_OW 488
112541: IFFALSE 112586
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
112543: LD_VAR 0 4
112547: PUSH
112548: LD_VAR 0 7
112552: ARRAY
112553: PPUSH
112554: LD_VAR 0 8
112558: PUSH
112559: LD_INT 1
112561: ARRAY
112562: PPUSH
112563: LD_VAR 0 8
112567: PUSH
112568: LD_INT 2
112570: ARRAY
112571: PPUSH
112572: CALL_OW 116
// attacking := true ;
112576: LD_ADDR_VAR 0 29
112580: PUSH
112581: LD_INT 1
112583: ST_TO_ADDR
// continue ;
112584: GO 109959
// end ; end else
112586: GO 112612
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112588: LD_VAR 0 4
112592: PUSH
112593: LD_VAR 0 7
112597: ARRAY
112598: PPUSH
112599: LD_VAR 0 14
112603: PUSH
112604: LD_INT 1
112606: ARRAY
112607: PPUSH
112608: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112612: LD_VAR 0 4
112616: PUSH
112617: LD_VAR 0 7
112621: ARRAY
112622: PPUSH
112623: CALL_OW 265
112627: PUSH
112628: LD_INT 11
112630: EQUAL
112631: IFFALSE 112909
// begin k := 10 ;
112633: LD_ADDR_VAR 0 9
112637: PUSH
112638: LD_INT 10
112640: ST_TO_ADDR
// x := 0 ;
112641: LD_ADDR_VAR 0 10
112645: PUSH
112646: LD_INT 0
112648: ST_TO_ADDR
// if tmp < k then
112649: LD_VAR 0 14
112653: PUSH
112654: LD_VAR 0 9
112658: LESS
112659: IFFALSE 112671
// k := tmp ;
112661: LD_ADDR_VAR 0 9
112665: PUSH
112666: LD_VAR 0 14
112670: ST_TO_ADDR
// for j = k downto 1 do
112671: LD_ADDR_VAR 0 8
112675: PUSH
112676: DOUBLE
112677: LD_VAR 0 9
112681: INC
112682: ST_TO_ADDR
112683: LD_INT 1
112685: PUSH
112686: FOR_DOWNTO
112687: IFFALSE 112762
// begin if GetType ( tmp [ j ] ) = unit_human then
112689: LD_VAR 0 14
112693: PUSH
112694: LD_VAR 0 8
112698: ARRAY
112699: PPUSH
112700: CALL_OW 247
112704: PUSH
112705: LD_INT 1
112707: EQUAL
112708: IFFALSE 112760
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
112710: LD_VAR 0 4
112714: PUSH
112715: LD_VAR 0 7
112719: ARRAY
112720: PPUSH
112721: LD_VAR 0 14
112725: PUSH
112726: LD_VAR 0 8
112730: ARRAY
112731: PPUSH
112732: CALL 49324 0 2
// x := tmp [ j ] ;
112736: LD_ADDR_VAR 0 10
112740: PUSH
112741: LD_VAR 0 14
112745: PUSH
112746: LD_VAR 0 8
112750: ARRAY
112751: ST_TO_ADDR
// attacking := true ;
112752: LD_ADDR_VAR 0 29
112756: PUSH
112757: LD_INT 1
112759: ST_TO_ADDR
// end ; end ;
112760: GO 112686
112762: POP
112763: POP
// if not x then
112764: LD_VAR 0 10
112768: NOT
112769: IFFALSE 112909
// begin attacking := true ;
112771: LD_ADDR_VAR 0 29
112775: PUSH
112776: LD_INT 1
112778: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
112779: LD_VAR 0 4
112783: PUSH
112784: LD_VAR 0 7
112788: ARRAY
112789: PPUSH
112790: CALL_OW 250
112794: PPUSH
112795: LD_VAR 0 4
112799: PUSH
112800: LD_VAR 0 7
112804: ARRAY
112805: PPUSH
112806: CALL_OW 251
112810: PPUSH
112811: CALL_OW 546
112815: PUSH
112816: LD_INT 2
112818: ARRAY
112819: PUSH
112820: LD_VAR 0 14
112824: PUSH
112825: LD_INT 1
112827: ARRAY
112828: PPUSH
112829: CALL_OW 250
112833: PPUSH
112834: LD_VAR 0 14
112838: PUSH
112839: LD_INT 1
112841: ARRAY
112842: PPUSH
112843: CALL_OW 251
112847: PPUSH
112848: CALL_OW 546
112852: PUSH
112853: LD_INT 2
112855: ARRAY
112856: EQUAL
112857: IFFALSE 112885
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
112859: LD_VAR 0 4
112863: PUSH
112864: LD_VAR 0 7
112868: ARRAY
112869: PPUSH
112870: LD_VAR 0 14
112874: PUSH
112875: LD_INT 1
112877: ARRAY
112878: PPUSH
112879: CALL 49324 0 2
112883: GO 112909
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112885: LD_VAR 0 4
112889: PUSH
112890: LD_VAR 0 7
112894: ARRAY
112895: PPUSH
112896: LD_VAR 0 14
112900: PUSH
112901: LD_INT 1
112903: ARRAY
112904: PPUSH
112905: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
112909: LD_VAR 0 4
112913: PUSH
112914: LD_VAR 0 7
112918: ARRAY
112919: PPUSH
112920: CALL_OW 264
112924: PUSH
112925: LD_INT 29
112927: EQUAL
112928: IFFALSE 113294
// begin if WantsToAttack ( group [ i ] ) in bombed then
112930: LD_VAR 0 4
112934: PUSH
112935: LD_VAR 0 7
112939: ARRAY
112940: PPUSH
112941: CALL_OW 319
112945: PUSH
112946: LD_VAR 0 28
112950: IN
112951: IFFALSE 112955
// continue ;
112953: GO 109959
// k := 8 ;
112955: LD_ADDR_VAR 0 9
112959: PUSH
112960: LD_INT 8
112962: ST_TO_ADDR
// x := 0 ;
112963: LD_ADDR_VAR 0 10
112967: PUSH
112968: LD_INT 0
112970: ST_TO_ADDR
// if tmp < k then
112971: LD_VAR 0 14
112975: PUSH
112976: LD_VAR 0 9
112980: LESS
112981: IFFALSE 112993
// k := tmp ;
112983: LD_ADDR_VAR 0 9
112987: PUSH
112988: LD_VAR 0 14
112992: ST_TO_ADDR
// for j = 1 to k do
112993: LD_ADDR_VAR 0 8
112997: PUSH
112998: DOUBLE
112999: LD_INT 1
113001: DEC
113002: ST_TO_ADDR
113003: LD_VAR 0 9
113007: PUSH
113008: FOR_TO
113009: IFFALSE 113141
// begin if GetType ( tmp [ j ] ) = unit_building then
113011: LD_VAR 0 14
113015: PUSH
113016: LD_VAR 0 8
113020: ARRAY
113021: PPUSH
113022: CALL_OW 247
113026: PUSH
113027: LD_INT 3
113029: EQUAL
113030: IFFALSE 113139
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113032: LD_VAR 0 14
113036: PUSH
113037: LD_VAR 0 8
113041: ARRAY
113042: PUSH
113043: LD_VAR 0 28
113047: IN
113048: NOT
113049: PUSH
113050: LD_VAR 0 14
113054: PUSH
113055: LD_VAR 0 8
113059: ARRAY
113060: PPUSH
113061: CALL_OW 313
113065: AND
113066: IFFALSE 113139
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113068: LD_VAR 0 4
113072: PUSH
113073: LD_VAR 0 7
113077: ARRAY
113078: PPUSH
113079: LD_VAR 0 14
113083: PUSH
113084: LD_VAR 0 8
113088: ARRAY
113089: PPUSH
113090: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113094: LD_ADDR_VAR 0 28
113098: PUSH
113099: LD_VAR 0 28
113103: PPUSH
113104: LD_VAR 0 28
113108: PUSH
113109: LD_INT 1
113111: PLUS
113112: PPUSH
113113: LD_VAR 0 14
113117: PUSH
113118: LD_VAR 0 8
113122: ARRAY
113123: PPUSH
113124: CALL_OW 1
113128: ST_TO_ADDR
// attacking := true ;
113129: LD_ADDR_VAR 0 29
113133: PUSH
113134: LD_INT 1
113136: ST_TO_ADDR
// break ;
113137: GO 113141
// end ; end ;
113139: GO 113008
113141: POP
113142: POP
// if not attacking and f_attack_depot then
113143: LD_VAR 0 29
113147: NOT
113148: PUSH
113149: LD_VAR 0 25
113153: AND
113154: IFFALSE 113249
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113156: LD_ADDR_VAR 0 13
113160: PUSH
113161: LD_VAR 0 14
113165: PPUSH
113166: LD_INT 2
113168: PUSH
113169: LD_INT 30
113171: PUSH
113172: LD_INT 0
113174: PUSH
113175: EMPTY
113176: LIST
113177: LIST
113178: PUSH
113179: LD_INT 30
113181: PUSH
113182: LD_INT 1
113184: PUSH
113185: EMPTY
113186: LIST
113187: LIST
113188: PUSH
113189: EMPTY
113190: LIST
113191: LIST
113192: LIST
113193: PPUSH
113194: CALL_OW 72
113198: ST_TO_ADDR
// if z then
113199: LD_VAR 0 13
113203: IFFALSE 113249
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113205: LD_VAR 0 4
113209: PUSH
113210: LD_VAR 0 7
113214: ARRAY
113215: PPUSH
113216: LD_VAR 0 13
113220: PPUSH
113221: LD_VAR 0 4
113225: PUSH
113226: LD_VAR 0 7
113230: ARRAY
113231: PPUSH
113232: CALL_OW 74
113236: PPUSH
113237: CALL_OW 115
// attacking := true ;
113241: LD_ADDR_VAR 0 29
113245: PUSH
113246: LD_INT 1
113248: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113249: LD_VAR 0 4
113253: PUSH
113254: LD_VAR 0 7
113258: ARRAY
113259: PPUSH
113260: CALL_OW 256
113264: PUSH
113265: LD_INT 500
113267: LESS
113268: IFFALSE 113294
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113270: LD_VAR 0 4
113274: PUSH
113275: LD_VAR 0 7
113279: ARRAY
113280: PPUSH
113281: LD_VAR 0 14
113285: PUSH
113286: LD_INT 1
113288: ARRAY
113289: PPUSH
113290: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113294: LD_VAR 0 4
113298: PUSH
113299: LD_VAR 0 7
113303: ARRAY
113304: PPUSH
113305: CALL_OW 264
113309: PUSH
113310: LD_INT 49
113312: EQUAL
113313: IFFALSE 113434
// begin if not HasTask ( group [ i ] ) then
113315: LD_VAR 0 4
113319: PUSH
113320: LD_VAR 0 7
113324: ARRAY
113325: PPUSH
113326: CALL_OW 314
113330: NOT
113331: IFFALSE 113434
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113333: LD_ADDR_VAR 0 9
113337: PUSH
113338: LD_INT 81
113340: PUSH
113341: LD_VAR 0 4
113345: PUSH
113346: LD_VAR 0 7
113350: ARRAY
113351: PPUSH
113352: CALL_OW 255
113356: PUSH
113357: EMPTY
113358: LIST
113359: LIST
113360: PPUSH
113361: CALL_OW 69
113365: PPUSH
113366: LD_VAR 0 4
113370: PUSH
113371: LD_VAR 0 7
113375: ARRAY
113376: PPUSH
113377: CALL_OW 74
113381: ST_TO_ADDR
// if k then
113382: LD_VAR 0 9
113386: IFFALSE 113434
// if GetDistUnits ( group [ i ] , k ) > 10 then
113388: LD_VAR 0 4
113392: PUSH
113393: LD_VAR 0 7
113397: ARRAY
113398: PPUSH
113399: LD_VAR 0 9
113403: PPUSH
113404: CALL_OW 296
113408: PUSH
113409: LD_INT 10
113411: GREATER
113412: IFFALSE 113434
// ComMoveUnit ( group [ i ] , k ) ;
113414: LD_VAR 0 4
113418: PUSH
113419: LD_VAR 0 7
113423: ARRAY
113424: PPUSH
113425: LD_VAR 0 9
113429: PPUSH
113430: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113434: LD_VAR 0 4
113438: PUSH
113439: LD_VAR 0 7
113443: ARRAY
113444: PPUSH
113445: CALL_OW 256
113449: PUSH
113450: LD_INT 250
113452: LESS
113453: PUSH
113454: LD_VAR 0 4
113458: PUSH
113459: LD_VAR 0 7
113463: ARRAY
113464: PUSH
113465: LD_INT 21
113467: PUSH
113468: LD_INT 2
113470: PUSH
113471: EMPTY
113472: LIST
113473: LIST
113474: PUSH
113475: LD_INT 23
113477: PUSH
113478: LD_INT 2
113480: PUSH
113481: EMPTY
113482: LIST
113483: LIST
113484: PUSH
113485: EMPTY
113486: LIST
113487: LIST
113488: PPUSH
113489: CALL_OW 69
113493: IN
113494: AND
113495: IFFALSE 113620
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113497: LD_ADDR_VAR 0 9
113501: PUSH
113502: LD_OWVAR 3
113506: PUSH
113507: LD_VAR 0 4
113511: PUSH
113512: LD_VAR 0 7
113516: ARRAY
113517: DIFF
113518: PPUSH
113519: LD_VAR 0 4
113523: PUSH
113524: LD_VAR 0 7
113528: ARRAY
113529: PPUSH
113530: CALL_OW 74
113534: ST_TO_ADDR
// if not k then
113535: LD_VAR 0 9
113539: NOT
113540: IFFALSE 113544
// continue ;
113542: GO 109959
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
113544: LD_VAR 0 9
113548: PUSH
113549: LD_INT 81
113551: PUSH
113552: LD_VAR 0 4
113556: PUSH
113557: LD_VAR 0 7
113561: ARRAY
113562: PPUSH
113563: CALL_OW 255
113567: PUSH
113568: EMPTY
113569: LIST
113570: LIST
113571: PPUSH
113572: CALL_OW 69
113576: IN
113577: PUSH
113578: LD_VAR 0 9
113582: PPUSH
113583: LD_VAR 0 4
113587: PUSH
113588: LD_VAR 0 7
113592: ARRAY
113593: PPUSH
113594: CALL_OW 296
113598: PUSH
113599: LD_INT 5
113601: LESS
113602: AND
113603: IFFALSE 113620
// ComAutodestruct ( group [ i ] ) ;
113605: LD_VAR 0 4
113609: PUSH
113610: LD_VAR 0 7
113614: ARRAY
113615: PPUSH
113616: CALL 49222 0 1
// end ; if f_attack_depot then
113620: LD_VAR 0 25
113624: IFFALSE 113736
// begin k := 6 ;
113626: LD_ADDR_VAR 0 9
113630: PUSH
113631: LD_INT 6
113633: ST_TO_ADDR
// if tmp < k then
113634: LD_VAR 0 14
113638: PUSH
113639: LD_VAR 0 9
113643: LESS
113644: IFFALSE 113656
// k := tmp ;
113646: LD_ADDR_VAR 0 9
113650: PUSH
113651: LD_VAR 0 14
113655: ST_TO_ADDR
// for j = 1 to k do
113656: LD_ADDR_VAR 0 8
113660: PUSH
113661: DOUBLE
113662: LD_INT 1
113664: DEC
113665: ST_TO_ADDR
113666: LD_VAR 0 9
113670: PUSH
113671: FOR_TO
113672: IFFALSE 113734
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113674: LD_VAR 0 8
113678: PPUSH
113679: CALL_OW 266
113683: PUSH
113684: LD_INT 0
113686: PUSH
113687: LD_INT 1
113689: PUSH
113690: EMPTY
113691: LIST
113692: LIST
113693: IN
113694: IFFALSE 113732
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113696: LD_VAR 0 4
113700: PUSH
113701: LD_VAR 0 7
113705: ARRAY
113706: PPUSH
113707: LD_VAR 0 14
113711: PUSH
113712: LD_VAR 0 8
113716: ARRAY
113717: PPUSH
113718: CALL_OW 115
// attacking := true ;
113722: LD_ADDR_VAR 0 29
113726: PUSH
113727: LD_INT 1
113729: ST_TO_ADDR
// break ;
113730: GO 113734
// end ;
113732: GO 113671
113734: POP
113735: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
113736: LD_VAR 0 4
113740: PUSH
113741: LD_VAR 0 7
113745: ARRAY
113746: PPUSH
113747: CALL_OW 302
113751: PUSH
113752: LD_VAR 0 29
113756: NOT
113757: AND
113758: IFFALSE 114080
// begin if GetTag ( group [ i ] ) = 71 then
113760: LD_VAR 0 4
113764: PUSH
113765: LD_VAR 0 7
113769: ARRAY
113770: PPUSH
113771: CALL_OW 110
113775: PUSH
113776: LD_INT 71
113778: EQUAL
113779: IFFALSE 113820
// begin if HasTask ( group [ i ] ) then
113781: LD_VAR 0 4
113785: PUSH
113786: LD_VAR 0 7
113790: ARRAY
113791: PPUSH
113792: CALL_OW 314
113796: IFFALSE 113802
// continue else
113798: GO 109959
113800: GO 113820
// SetTag ( group [ i ] , 0 ) ;
113802: LD_VAR 0 4
113806: PUSH
113807: LD_VAR 0 7
113811: ARRAY
113812: PPUSH
113813: LD_INT 0
113815: PPUSH
113816: CALL_OW 109
// end ; k := 8 ;
113820: LD_ADDR_VAR 0 9
113824: PUSH
113825: LD_INT 8
113827: ST_TO_ADDR
// x := 0 ;
113828: LD_ADDR_VAR 0 10
113832: PUSH
113833: LD_INT 0
113835: ST_TO_ADDR
// if tmp < k then
113836: LD_VAR 0 14
113840: PUSH
113841: LD_VAR 0 9
113845: LESS
113846: IFFALSE 113858
// k := tmp ;
113848: LD_ADDR_VAR 0 9
113852: PUSH
113853: LD_VAR 0 14
113857: ST_TO_ADDR
// for j = 1 to k do
113858: LD_ADDR_VAR 0 8
113862: PUSH
113863: DOUBLE
113864: LD_INT 1
113866: DEC
113867: ST_TO_ADDR
113868: LD_VAR 0 9
113872: PUSH
113873: FOR_TO
113874: IFFALSE 113972
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
113876: LD_VAR 0 14
113880: PUSH
113881: LD_VAR 0 8
113885: ARRAY
113886: PPUSH
113887: CALL_OW 247
113891: PUSH
113892: LD_INT 1
113894: EQUAL
113895: PUSH
113896: LD_VAR 0 14
113900: PUSH
113901: LD_VAR 0 8
113905: ARRAY
113906: PPUSH
113907: CALL_OW 256
113911: PUSH
113912: LD_INT 250
113914: LESS
113915: PUSH
113916: LD_VAR 0 20
113920: AND
113921: PUSH
113922: LD_VAR 0 20
113926: NOT
113927: PUSH
113928: LD_VAR 0 14
113932: PUSH
113933: LD_VAR 0 8
113937: ARRAY
113938: PPUSH
113939: CALL_OW 256
113943: PUSH
113944: LD_INT 250
113946: GREATEREQUAL
113947: AND
113948: OR
113949: AND
113950: IFFALSE 113970
// begin x := tmp [ j ] ;
113952: LD_ADDR_VAR 0 10
113956: PUSH
113957: LD_VAR 0 14
113961: PUSH
113962: LD_VAR 0 8
113966: ARRAY
113967: ST_TO_ADDR
// break ;
113968: GO 113972
// end ;
113970: GO 113873
113972: POP
113973: POP
// if x then
113974: LD_VAR 0 10
113978: IFFALSE 114002
// ComAttackUnit ( group [ i ] , x ) else
113980: LD_VAR 0 4
113984: PUSH
113985: LD_VAR 0 7
113989: ARRAY
113990: PPUSH
113991: LD_VAR 0 10
113995: PPUSH
113996: CALL_OW 115
114000: GO 114026
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114002: LD_VAR 0 4
114006: PUSH
114007: LD_VAR 0 7
114011: ARRAY
114012: PPUSH
114013: LD_VAR 0 14
114017: PUSH
114018: LD_INT 1
114020: ARRAY
114021: PPUSH
114022: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114026: LD_VAR 0 4
114030: PUSH
114031: LD_VAR 0 7
114035: ARRAY
114036: PPUSH
114037: CALL_OW 314
114041: NOT
114042: IFFALSE 114080
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114044: LD_VAR 0 4
114048: PUSH
114049: LD_VAR 0 7
114053: ARRAY
114054: PPUSH
114055: LD_VAR 0 14
114059: PPUSH
114060: LD_VAR 0 4
114064: PUSH
114065: LD_VAR 0 7
114069: ARRAY
114070: PPUSH
114071: CALL_OW 74
114075: PPUSH
114076: CALL_OW 115
// end ; end ; end ;
114080: GO 109959
114082: POP
114083: POP
// wait ( 0 0$2 ) ;
114084: LD_INT 70
114086: PPUSH
114087: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114091: LD_VAR 0 4
114095: NOT
114096: PUSH
114097: LD_VAR 0 4
114101: PUSH
114102: EMPTY
114103: EQUAL
114104: OR
114105: PUSH
114106: LD_INT 81
114108: PUSH
114109: LD_VAR 0 35
114113: PUSH
114114: EMPTY
114115: LIST
114116: LIST
114117: PPUSH
114118: CALL_OW 69
114122: NOT
114123: OR
114124: IFFALSE 109944
// end ;
114126: LD_VAR 0 2
114130: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114131: LD_INT 0
114133: PPUSH
114134: PPUSH
114135: PPUSH
114136: PPUSH
114137: PPUSH
114138: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114139: LD_VAR 0 1
114143: NOT
114144: PUSH
114145: LD_EXP 61
114149: PUSH
114150: LD_VAR 0 1
114154: ARRAY
114155: NOT
114156: OR
114157: PUSH
114158: LD_VAR 0 2
114162: NOT
114163: OR
114164: IFFALSE 114168
// exit ;
114166: GO 114722
// side := mc_sides [ base ] ;
114168: LD_ADDR_VAR 0 6
114172: PUSH
114173: LD_EXP 87
114177: PUSH
114178: LD_VAR 0 1
114182: ARRAY
114183: ST_TO_ADDR
// if not side then
114184: LD_VAR 0 6
114188: NOT
114189: IFFALSE 114193
// exit ;
114191: GO 114722
// for i in solds do
114193: LD_ADDR_VAR 0 7
114197: PUSH
114198: LD_VAR 0 2
114202: PUSH
114203: FOR_IN
114204: IFFALSE 114265
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114206: LD_VAR 0 7
114210: PPUSH
114211: CALL_OW 310
114215: PPUSH
114216: CALL_OW 266
114220: PUSH
114221: LD_INT 32
114223: PUSH
114224: LD_INT 31
114226: PUSH
114227: EMPTY
114228: LIST
114229: LIST
114230: IN
114231: IFFALSE 114251
// solds := solds diff i else
114233: LD_ADDR_VAR 0 2
114237: PUSH
114238: LD_VAR 0 2
114242: PUSH
114243: LD_VAR 0 7
114247: DIFF
114248: ST_TO_ADDR
114249: GO 114263
// SetTag ( i , 18 ) ;
114251: LD_VAR 0 7
114255: PPUSH
114256: LD_INT 18
114258: PPUSH
114259: CALL_OW 109
114263: GO 114203
114265: POP
114266: POP
// if not solds then
114267: LD_VAR 0 2
114271: NOT
114272: IFFALSE 114276
// exit ;
114274: GO 114722
// repeat wait ( 0 0$2 ) ;
114276: LD_INT 70
114278: PPUSH
114279: CALL_OW 67
// enemy := mc_scan [ base ] ;
114283: LD_ADDR_VAR 0 4
114287: PUSH
114288: LD_EXP 84
114292: PUSH
114293: LD_VAR 0 1
114297: ARRAY
114298: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114299: LD_EXP 61
114303: PUSH
114304: LD_VAR 0 1
114308: ARRAY
114309: NOT
114310: PUSH
114311: LD_EXP 61
114315: PUSH
114316: LD_VAR 0 1
114320: ARRAY
114321: PUSH
114322: EMPTY
114323: EQUAL
114324: OR
114325: IFFALSE 114362
// begin for i in solds do
114327: LD_ADDR_VAR 0 7
114331: PUSH
114332: LD_VAR 0 2
114336: PUSH
114337: FOR_IN
114338: IFFALSE 114351
// ComStop ( i ) ;
114340: LD_VAR 0 7
114344: PPUSH
114345: CALL_OW 141
114349: GO 114337
114351: POP
114352: POP
// solds := [ ] ;
114353: LD_ADDR_VAR 0 2
114357: PUSH
114358: EMPTY
114359: ST_TO_ADDR
// exit ;
114360: GO 114722
// end ; for i in solds do
114362: LD_ADDR_VAR 0 7
114366: PUSH
114367: LD_VAR 0 2
114371: PUSH
114372: FOR_IN
114373: IFFALSE 114694
// begin if IsInUnit ( i ) then
114375: LD_VAR 0 7
114379: PPUSH
114380: CALL_OW 310
114384: IFFALSE 114395
// ComExitBuilding ( i ) ;
114386: LD_VAR 0 7
114390: PPUSH
114391: CALL_OW 122
// if GetLives ( i ) > 500 then
114395: LD_VAR 0 7
114399: PPUSH
114400: CALL_OW 256
114404: PUSH
114405: LD_INT 500
114407: GREATER
114408: IFFALSE 114461
// begin e := NearestUnitToUnit ( enemy , i ) ;
114410: LD_ADDR_VAR 0 5
114414: PUSH
114415: LD_VAR 0 4
114419: PPUSH
114420: LD_VAR 0 7
114424: PPUSH
114425: CALL_OW 74
114429: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114430: LD_VAR 0 7
114434: PPUSH
114435: LD_VAR 0 5
114439: PPUSH
114440: CALL_OW 250
114444: PPUSH
114445: LD_VAR 0 5
114449: PPUSH
114450: CALL_OW 251
114454: PPUSH
114455: CALL_OW 114
// end else
114459: GO 114692
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114461: LD_VAR 0 7
114465: PPUSH
114466: LD_EXP 61
114470: PUSH
114471: LD_VAR 0 1
114475: ARRAY
114476: PPUSH
114477: LD_INT 2
114479: PUSH
114480: LD_INT 30
114482: PUSH
114483: LD_INT 0
114485: PUSH
114486: EMPTY
114487: LIST
114488: LIST
114489: PUSH
114490: LD_INT 30
114492: PUSH
114493: LD_INT 1
114495: PUSH
114496: EMPTY
114497: LIST
114498: LIST
114499: PUSH
114500: LD_INT 30
114502: PUSH
114503: LD_INT 6
114505: PUSH
114506: EMPTY
114507: LIST
114508: LIST
114509: PUSH
114510: EMPTY
114511: LIST
114512: LIST
114513: LIST
114514: LIST
114515: PPUSH
114516: CALL_OW 72
114520: PPUSH
114521: LD_VAR 0 7
114525: PPUSH
114526: CALL_OW 74
114530: PPUSH
114531: CALL_OW 296
114535: PUSH
114536: LD_INT 10
114538: GREATER
114539: IFFALSE 114692
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
114541: LD_ADDR_VAR 0 8
114545: PUSH
114546: LD_EXP 61
114550: PUSH
114551: LD_VAR 0 1
114555: ARRAY
114556: PPUSH
114557: LD_INT 2
114559: PUSH
114560: LD_INT 30
114562: PUSH
114563: LD_INT 0
114565: PUSH
114566: EMPTY
114567: LIST
114568: LIST
114569: PUSH
114570: LD_INT 30
114572: PUSH
114573: LD_INT 1
114575: PUSH
114576: EMPTY
114577: LIST
114578: LIST
114579: PUSH
114580: LD_INT 30
114582: PUSH
114583: LD_INT 6
114585: PUSH
114586: EMPTY
114587: LIST
114588: LIST
114589: PUSH
114590: EMPTY
114591: LIST
114592: LIST
114593: LIST
114594: LIST
114595: PPUSH
114596: CALL_OW 72
114600: PPUSH
114601: LD_VAR 0 7
114605: PPUSH
114606: CALL_OW 74
114610: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114611: LD_VAR 0 7
114615: PPUSH
114616: LD_VAR 0 8
114620: PPUSH
114621: CALL_OW 250
114625: PPUSH
114626: LD_INT 3
114628: PPUSH
114629: LD_INT 5
114631: PPUSH
114632: CALL_OW 272
114636: PPUSH
114637: LD_VAR 0 8
114641: PPUSH
114642: CALL_OW 251
114646: PPUSH
114647: LD_INT 3
114649: PPUSH
114650: LD_INT 5
114652: PPUSH
114653: CALL_OW 273
114657: PPUSH
114658: CALL_OW 111
// SetTag ( i , 0 ) ;
114662: LD_VAR 0 7
114666: PPUSH
114667: LD_INT 0
114669: PPUSH
114670: CALL_OW 109
// solds := solds diff i ;
114674: LD_ADDR_VAR 0 2
114678: PUSH
114679: LD_VAR 0 2
114683: PUSH
114684: LD_VAR 0 7
114688: DIFF
114689: ST_TO_ADDR
// continue ;
114690: GO 114372
// end ; end ;
114692: GO 114372
114694: POP
114695: POP
// until not solds or not enemy ;
114696: LD_VAR 0 2
114700: NOT
114701: PUSH
114702: LD_VAR 0 4
114706: NOT
114707: OR
114708: IFFALSE 114276
// MC_Reset ( base , 18 ) ;
114710: LD_VAR 0 1
114714: PPUSH
114715: LD_INT 18
114717: PPUSH
114718: CALL 62353 0 2
// end ;
114722: LD_VAR 0 3
114726: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
114727: LD_INT 0
114729: PPUSH
114730: PPUSH
114731: PPUSH
114732: PPUSH
114733: PPUSH
114734: PPUSH
114735: PPUSH
114736: PPUSH
114737: PPUSH
114738: PPUSH
114739: PPUSH
114740: PPUSH
114741: PPUSH
114742: PPUSH
114743: PPUSH
114744: PPUSH
114745: PPUSH
114746: PPUSH
114747: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
114748: LD_ADDR_VAR 0 12
114752: PUSH
114753: LD_EXP 61
114757: PUSH
114758: LD_VAR 0 1
114762: ARRAY
114763: PPUSH
114764: LD_INT 25
114766: PUSH
114767: LD_INT 3
114769: PUSH
114770: EMPTY
114771: LIST
114772: LIST
114773: PPUSH
114774: CALL_OW 72
114778: ST_TO_ADDR
// if mc_remote_driver [ base ] then
114779: LD_EXP 101
114783: PUSH
114784: LD_VAR 0 1
114788: ARRAY
114789: IFFALSE 114813
// mechs := mechs diff mc_remote_driver [ base ] ;
114791: LD_ADDR_VAR 0 12
114795: PUSH
114796: LD_VAR 0 12
114800: PUSH
114801: LD_EXP 101
114805: PUSH
114806: LD_VAR 0 1
114810: ARRAY
114811: DIFF
114812: ST_TO_ADDR
// for i in mechs do
114813: LD_ADDR_VAR 0 4
114817: PUSH
114818: LD_VAR 0 12
114822: PUSH
114823: FOR_IN
114824: IFFALSE 114859
// if GetTag ( i ) > 0 then
114826: LD_VAR 0 4
114830: PPUSH
114831: CALL_OW 110
114835: PUSH
114836: LD_INT 0
114838: GREATER
114839: IFFALSE 114857
// mechs := mechs diff i ;
114841: LD_ADDR_VAR 0 12
114845: PUSH
114846: LD_VAR 0 12
114850: PUSH
114851: LD_VAR 0 4
114855: DIFF
114856: ST_TO_ADDR
114857: GO 114823
114859: POP
114860: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114861: LD_ADDR_VAR 0 8
114865: PUSH
114866: LD_EXP 61
114870: PUSH
114871: LD_VAR 0 1
114875: ARRAY
114876: PPUSH
114877: LD_INT 2
114879: PUSH
114880: LD_INT 25
114882: PUSH
114883: LD_INT 1
114885: PUSH
114886: EMPTY
114887: LIST
114888: LIST
114889: PUSH
114890: LD_INT 25
114892: PUSH
114893: LD_INT 5
114895: PUSH
114896: EMPTY
114897: LIST
114898: LIST
114899: PUSH
114900: LD_INT 25
114902: PUSH
114903: LD_INT 8
114905: PUSH
114906: EMPTY
114907: LIST
114908: LIST
114909: PUSH
114910: LD_INT 25
114912: PUSH
114913: LD_INT 9
114915: PUSH
114916: EMPTY
114917: LIST
114918: LIST
114919: PUSH
114920: EMPTY
114921: LIST
114922: LIST
114923: LIST
114924: LIST
114925: LIST
114926: PPUSH
114927: CALL_OW 72
114931: ST_TO_ADDR
// if not defenders and not solds then
114932: LD_VAR 0 2
114936: NOT
114937: PUSH
114938: LD_VAR 0 8
114942: NOT
114943: AND
114944: IFFALSE 114948
// exit ;
114946: GO 116718
// depot_under_attack := false ;
114948: LD_ADDR_VAR 0 16
114952: PUSH
114953: LD_INT 0
114955: ST_TO_ADDR
// sold_defenders := [ ] ;
114956: LD_ADDR_VAR 0 17
114960: PUSH
114961: EMPTY
114962: ST_TO_ADDR
// if mechs then
114963: LD_VAR 0 12
114967: IFFALSE 115120
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
114969: LD_ADDR_VAR 0 4
114973: PUSH
114974: LD_VAR 0 2
114978: PPUSH
114979: LD_INT 21
114981: PUSH
114982: LD_INT 2
114984: PUSH
114985: EMPTY
114986: LIST
114987: LIST
114988: PPUSH
114989: CALL_OW 72
114993: PUSH
114994: FOR_IN
114995: IFFALSE 115118
// begin if GetTag ( i ) <> 20 then
114997: LD_VAR 0 4
115001: PPUSH
115002: CALL_OW 110
115006: PUSH
115007: LD_INT 20
115009: NONEQUAL
115010: IFFALSE 115024
// SetTag ( i , 20 ) ;
115012: LD_VAR 0 4
115016: PPUSH
115017: LD_INT 20
115019: PPUSH
115020: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115024: LD_VAR 0 4
115028: PPUSH
115029: CALL_OW 263
115033: PUSH
115034: LD_INT 1
115036: EQUAL
115037: PUSH
115038: LD_VAR 0 4
115042: PPUSH
115043: CALL_OW 311
115047: NOT
115048: AND
115049: IFFALSE 115116
// begin un := mechs [ 1 ] ;
115051: LD_ADDR_VAR 0 10
115055: PUSH
115056: LD_VAR 0 12
115060: PUSH
115061: LD_INT 1
115063: ARRAY
115064: ST_TO_ADDR
// ComExit ( un ) ;
115065: LD_VAR 0 10
115069: PPUSH
115070: CALL 54119 0 1
// AddComEnterUnit ( un , i ) ;
115074: LD_VAR 0 10
115078: PPUSH
115079: LD_VAR 0 4
115083: PPUSH
115084: CALL_OW 180
// SetTag ( un , 19 ) ;
115088: LD_VAR 0 10
115092: PPUSH
115093: LD_INT 19
115095: PPUSH
115096: CALL_OW 109
// mechs := mechs diff un ;
115100: LD_ADDR_VAR 0 12
115104: PUSH
115105: LD_VAR 0 12
115109: PUSH
115110: LD_VAR 0 10
115114: DIFF
115115: ST_TO_ADDR
// end ; end ;
115116: GO 114994
115118: POP
115119: POP
// if solds then
115120: LD_VAR 0 8
115124: IFFALSE 115183
// for i in solds do
115126: LD_ADDR_VAR 0 4
115130: PUSH
115131: LD_VAR 0 8
115135: PUSH
115136: FOR_IN
115137: IFFALSE 115181
// if not GetTag ( i ) then
115139: LD_VAR 0 4
115143: PPUSH
115144: CALL_OW 110
115148: NOT
115149: IFFALSE 115179
// begin defenders := defenders union i ;
115151: LD_ADDR_VAR 0 2
115155: PUSH
115156: LD_VAR 0 2
115160: PUSH
115161: LD_VAR 0 4
115165: UNION
115166: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115167: LD_VAR 0 4
115171: PPUSH
115172: LD_INT 18
115174: PPUSH
115175: CALL_OW 109
// end ;
115179: GO 115136
115181: POP
115182: POP
// repeat wait ( 0 0$2 ) ;
115183: LD_INT 70
115185: PPUSH
115186: CALL_OW 67
// enemy := mc_scan [ base ] ;
115190: LD_ADDR_VAR 0 21
115194: PUSH
115195: LD_EXP 84
115199: PUSH
115200: LD_VAR 0 1
115204: ARRAY
115205: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115206: LD_EXP 61
115210: PUSH
115211: LD_VAR 0 1
115215: ARRAY
115216: NOT
115217: PUSH
115218: LD_EXP 61
115222: PUSH
115223: LD_VAR 0 1
115227: ARRAY
115228: PUSH
115229: EMPTY
115230: EQUAL
115231: OR
115232: IFFALSE 115269
// begin for i in defenders do
115234: LD_ADDR_VAR 0 4
115238: PUSH
115239: LD_VAR 0 2
115243: PUSH
115244: FOR_IN
115245: IFFALSE 115258
// ComStop ( i ) ;
115247: LD_VAR 0 4
115251: PPUSH
115252: CALL_OW 141
115256: GO 115244
115258: POP
115259: POP
// defenders := [ ] ;
115260: LD_ADDR_VAR 0 2
115264: PUSH
115265: EMPTY
115266: ST_TO_ADDR
// exit ;
115267: GO 116718
// end ; for i in defenders do
115269: LD_ADDR_VAR 0 4
115273: PUSH
115274: LD_VAR 0 2
115278: PUSH
115279: FOR_IN
115280: IFFALSE 116178
// begin e := NearestUnitToUnit ( enemy , i ) ;
115282: LD_ADDR_VAR 0 13
115286: PUSH
115287: LD_VAR 0 21
115291: PPUSH
115292: LD_VAR 0 4
115296: PPUSH
115297: CALL_OW 74
115301: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115302: LD_ADDR_VAR 0 7
115306: PUSH
115307: LD_EXP 61
115311: PUSH
115312: LD_VAR 0 1
115316: ARRAY
115317: PPUSH
115318: LD_INT 2
115320: PUSH
115321: LD_INT 30
115323: PUSH
115324: LD_INT 0
115326: PUSH
115327: EMPTY
115328: LIST
115329: LIST
115330: PUSH
115331: LD_INT 30
115333: PUSH
115334: LD_INT 1
115336: PUSH
115337: EMPTY
115338: LIST
115339: LIST
115340: PUSH
115341: EMPTY
115342: LIST
115343: LIST
115344: LIST
115345: PPUSH
115346: CALL_OW 72
115350: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115351: LD_ADDR_VAR 0 16
115355: PUSH
115356: LD_VAR 0 7
115360: NOT
115361: PUSH
115362: LD_VAR 0 7
115366: PPUSH
115367: LD_INT 3
115369: PUSH
115370: LD_INT 24
115372: PUSH
115373: LD_INT 600
115375: PUSH
115376: EMPTY
115377: LIST
115378: LIST
115379: PUSH
115380: EMPTY
115381: LIST
115382: LIST
115383: PPUSH
115384: CALL_OW 72
115388: OR
115389: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115390: LD_VAR 0 4
115394: PPUSH
115395: CALL_OW 247
115399: PUSH
115400: LD_INT 2
115402: DOUBLE
115403: EQUAL
115404: IFTRUE 115408
115406: GO 115804
115408: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115409: LD_VAR 0 4
115413: PPUSH
115414: CALL_OW 256
115418: PUSH
115419: LD_INT 1000
115421: EQUAL
115422: PUSH
115423: LD_VAR 0 4
115427: PPUSH
115428: LD_VAR 0 13
115432: PPUSH
115433: CALL_OW 296
115437: PUSH
115438: LD_INT 40
115440: LESS
115441: PUSH
115442: LD_VAR 0 13
115446: PPUSH
115447: LD_EXP 86
115451: PUSH
115452: LD_VAR 0 1
115456: ARRAY
115457: PPUSH
115458: CALL_OW 308
115462: OR
115463: AND
115464: IFFALSE 115586
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115466: LD_VAR 0 4
115470: PPUSH
115471: CALL_OW 262
115475: PUSH
115476: LD_INT 1
115478: EQUAL
115479: PUSH
115480: LD_VAR 0 4
115484: PPUSH
115485: CALL_OW 261
115489: PUSH
115490: LD_INT 30
115492: LESS
115493: AND
115494: PUSH
115495: LD_VAR 0 7
115499: AND
115500: IFFALSE 115570
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115502: LD_VAR 0 4
115506: PPUSH
115507: LD_VAR 0 7
115511: PPUSH
115512: LD_VAR 0 4
115516: PPUSH
115517: CALL_OW 74
115521: PPUSH
115522: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
115526: LD_VAR 0 4
115530: PPUSH
115531: LD_VAR 0 7
115535: PPUSH
115536: LD_VAR 0 4
115540: PPUSH
115541: CALL_OW 74
115545: PPUSH
115546: CALL_OW 296
115550: PUSH
115551: LD_INT 6
115553: LESS
115554: IFFALSE 115568
// SetFuel ( i , 100 ) ;
115556: LD_VAR 0 4
115560: PPUSH
115561: LD_INT 100
115563: PPUSH
115564: CALL_OW 240
// end else
115568: GO 115584
// ComAttackUnit ( i , e ) ;
115570: LD_VAR 0 4
115574: PPUSH
115575: LD_VAR 0 13
115579: PPUSH
115580: CALL_OW 115
// end else
115584: GO 115687
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
115586: LD_VAR 0 13
115590: PPUSH
115591: LD_EXP 86
115595: PUSH
115596: LD_VAR 0 1
115600: ARRAY
115601: PPUSH
115602: CALL_OW 308
115606: NOT
115607: PUSH
115608: LD_VAR 0 4
115612: PPUSH
115613: LD_VAR 0 13
115617: PPUSH
115618: CALL_OW 296
115622: PUSH
115623: LD_INT 40
115625: GREATEREQUAL
115626: AND
115627: PUSH
115628: LD_VAR 0 4
115632: PPUSH
115633: CALL_OW 256
115637: PUSH
115638: LD_INT 650
115640: LESSEQUAL
115641: OR
115642: PUSH
115643: LD_VAR 0 4
115647: PPUSH
115648: LD_EXP 85
115652: PUSH
115653: LD_VAR 0 1
115657: ARRAY
115658: PPUSH
115659: CALL_OW 308
115663: NOT
115664: AND
115665: IFFALSE 115687
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115667: LD_VAR 0 4
115671: PPUSH
115672: LD_EXP 85
115676: PUSH
115677: LD_VAR 0 1
115681: ARRAY
115682: PPUSH
115683: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115687: LD_VAR 0 4
115691: PPUSH
115692: CALL_OW 256
115696: PUSH
115697: LD_INT 1000
115699: LESS
115700: PUSH
115701: LD_VAR 0 4
115705: PPUSH
115706: CALL_OW 263
115710: PUSH
115711: LD_INT 1
115713: EQUAL
115714: AND
115715: PUSH
115716: LD_VAR 0 4
115720: PPUSH
115721: CALL_OW 311
115725: AND
115726: PUSH
115727: LD_VAR 0 4
115731: PPUSH
115732: LD_EXP 85
115736: PUSH
115737: LD_VAR 0 1
115741: ARRAY
115742: PPUSH
115743: CALL_OW 308
115747: AND
115748: IFFALSE 115802
// begin mech := IsDrivenBy ( i ) ;
115750: LD_ADDR_VAR 0 9
115754: PUSH
115755: LD_VAR 0 4
115759: PPUSH
115760: CALL_OW 311
115764: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
115765: LD_VAR 0 9
115769: PPUSH
115770: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
115774: LD_VAR 0 9
115778: PPUSH
115779: LD_VAR 0 4
115783: PPUSH
115784: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
115788: LD_VAR 0 9
115792: PPUSH
115793: LD_VAR 0 4
115797: PPUSH
115798: CALL_OW 180
// end ; end ; unit_human :
115802: GO 116149
115804: LD_INT 1
115806: DOUBLE
115807: EQUAL
115808: IFTRUE 115812
115810: GO 116148
115812: POP
// begin b := IsInUnit ( i ) ;
115813: LD_ADDR_VAR 0 18
115817: PUSH
115818: LD_VAR 0 4
115822: PPUSH
115823: CALL_OW 310
115827: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
115828: LD_ADDR_VAR 0 19
115832: PUSH
115833: LD_VAR 0 18
115837: NOT
115838: PUSH
115839: LD_VAR 0 18
115843: PPUSH
115844: CALL_OW 266
115848: PUSH
115849: LD_INT 32
115851: PUSH
115852: LD_INT 31
115854: PUSH
115855: EMPTY
115856: LIST
115857: LIST
115858: IN
115859: OR
115860: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
115861: LD_VAR 0 18
115865: PPUSH
115866: CALL_OW 266
115870: PUSH
115871: LD_INT 5
115873: EQUAL
115874: PUSH
115875: LD_VAR 0 4
115879: PPUSH
115880: CALL_OW 257
115884: PUSH
115885: LD_INT 1
115887: PUSH
115888: LD_INT 2
115890: PUSH
115891: LD_INT 3
115893: PUSH
115894: LD_INT 4
115896: PUSH
115897: EMPTY
115898: LIST
115899: LIST
115900: LIST
115901: LIST
115902: IN
115903: AND
115904: IFFALSE 115941
// begin class := AllowSpecClass ( i ) ;
115906: LD_ADDR_VAR 0 20
115910: PUSH
115911: LD_VAR 0 4
115915: PPUSH
115916: CALL 17805 0 1
115920: ST_TO_ADDR
// if class then
115921: LD_VAR 0 20
115925: IFFALSE 115941
// ComChangeProfession ( i , class ) ;
115927: LD_VAR 0 4
115931: PPUSH
115932: LD_VAR 0 20
115936: PPUSH
115937: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
115941: LD_VAR 0 16
115945: PUSH
115946: LD_VAR 0 2
115950: PPUSH
115951: LD_INT 21
115953: PUSH
115954: LD_INT 2
115956: PUSH
115957: EMPTY
115958: LIST
115959: LIST
115960: PPUSH
115961: CALL_OW 72
115965: PUSH
115966: LD_INT 1
115968: LESSEQUAL
115969: OR
115970: PUSH
115971: LD_VAR 0 19
115975: AND
115976: PUSH
115977: LD_VAR 0 4
115981: PUSH
115982: LD_VAR 0 17
115986: IN
115987: NOT
115988: AND
115989: IFFALSE 116082
// begin if b then
115991: LD_VAR 0 18
115995: IFFALSE 116044
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
115997: LD_VAR 0 18
116001: PPUSH
116002: LD_VAR 0 21
116006: PPUSH
116007: LD_VAR 0 18
116011: PPUSH
116012: CALL_OW 74
116016: PPUSH
116017: CALL_OW 296
116021: PUSH
116022: LD_INT 10
116024: LESS
116025: PUSH
116026: LD_VAR 0 18
116030: PPUSH
116031: CALL_OW 461
116035: PUSH
116036: LD_INT 7
116038: NONEQUAL
116039: AND
116040: IFFALSE 116044
// continue ;
116042: GO 115279
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116044: LD_ADDR_VAR 0 17
116048: PUSH
116049: LD_VAR 0 17
116053: PPUSH
116054: LD_VAR 0 17
116058: PUSH
116059: LD_INT 1
116061: PLUS
116062: PPUSH
116063: LD_VAR 0 4
116067: PPUSH
116068: CALL_OW 1
116072: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116073: LD_VAR 0 4
116077: PPUSH
116078: CALL_OW 122
// end ; if sold_defenders then
116082: LD_VAR 0 17
116086: IFFALSE 116146
// if i in sold_defenders then
116088: LD_VAR 0 4
116092: PUSH
116093: LD_VAR 0 17
116097: IN
116098: IFFALSE 116146
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116100: LD_VAR 0 4
116104: PPUSH
116105: CALL_OW 314
116109: NOT
116110: PUSH
116111: LD_VAR 0 4
116115: PPUSH
116116: LD_VAR 0 13
116120: PPUSH
116121: CALL_OW 296
116125: PUSH
116126: LD_INT 30
116128: LESS
116129: AND
116130: IFFALSE 116146
// ComAttackUnit ( i , e ) ;
116132: LD_VAR 0 4
116136: PPUSH
116137: LD_VAR 0 13
116141: PPUSH
116142: CALL_OW 115
// end ; end ; end ;
116146: GO 116149
116148: POP
// if IsDead ( i ) then
116149: LD_VAR 0 4
116153: PPUSH
116154: CALL_OW 301
116158: IFFALSE 116176
// defenders := defenders diff i ;
116160: LD_ADDR_VAR 0 2
116164: PUSH
116165: LD_VAR 0 2
116169: PUSH
116170: LD_VAR 0 4
116174: DIFF
116175: ST_TO_ADDR
// end ;
116176: GO 115279
116178: POP
116179: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116180: LD_VAR 0 21
116184: NOT
116185: PUSH
116186: LD_VAR 0 2
116190: NOT
116191: OR
116192: PUSH
116193: LD_EXP 61
116197: PUSH
116198: LD_VAR 0 1
116202: ARRAY
116203: NOT
116204: OR
116205: IFFALSE 115183
// MC_Reset ( base , 18 ) ;
116207: LD_VAR 0 1
116211: PPUSH
116212: LD_INT 18
116214: PPUSH
116215: CALL 62353 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116219: LD_ADDR_VAR 0 2
116223: PUSH
116224: LD_VAR 0 2
116228: PUSH
116229: LD_VAR 0 2
116233: PPUSH
116234: LD_INT 2
116236: PUSH
116237: LD_INT 25
116239: PUSH
116240: LD_INT 1
116242: PUSH
116243: EMPTY
116244: LIST
116245: LIST
116246: PUSH
116247: LD_INT 25
116249: PUSH
116250: LD_INT 5
116252: PUSH
116253: EMPTY
116254: LIST
116255: LIST
116256: PUSH
116257: LD_INT 25
116259: PUSH
116260: LD_INT 8
116262: PUSH
116263: EMPTY
116264: LIST
116265: LIST
116266: PUSH
116267: LD_INT 25
116269: PUSH
116270: LD_INT 9
116272: PUSH
116273: EMPTY
116274: LIST
116275: LIST
116276: PUSH
116277: EMPTY
116278: LIST
116279: LIST
116280: LIST
116281: LIST
116282: LIST
116283: PPUSH
116284: CALL_OW 72
116288: DIFF
116289: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116290: LD_VAR 0 21
116294: NOT
116295: PUSH
116296: LD_VAR 0 2
116300: PPUSH
116301: LD_INT 21
116303: PUSH
116304: LD_INT 2
116306: PUSH
116307: EMPTY
116308: LIST
116309: LIST
116310: PPUSH
116311: CALL_OW 72
116315: AND
116316: IFFALSE 116654
// begin tmp := FilterByTag ( defenders , 19 ) ;
116318: LD_ADDR_VAR 0 11
116322: PUSH
116323: LD_VAR 0 2
116327: PPUSH
116328: LD_INT 19
116330: PPUSH
116331: CALL 51290 0 2
116335: ST_TO_ADDR
// if tmp then
116336: LD_VAR 0 11
116340: IFFALSE 116410
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116342: LD_ADDR_VAR 0 11
116346: PUSH
116347: LD_VAR 0 11
116351: PPUSH
116352: LD_INT 25
116354: PUSH
116355: LD_INT 3
116357: PUSH
116358: EMPTY
116359: LIST
116360: LIST
116361: PPUSH
116362: CALL_OW 72
116366: ST_TO_ADDR
// if tmp then
116367: LD_VAR 0 11
116371: IFFALSE 116410
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116373: LD_ADDR_EXP 73
116377: PUSH
116378: LD_EXP 73
116382: PPUSH
116383: LD_VAR 0 1
116387: PPUSH
116388: LD_EXP 73
116392: PUSH
116393: LD_VAR 0 1
116397: ARRAY
116398: PUSH
116399: LD_VAR 0 11
116403: UNION
116404: PPUSH
116405: CALL_OW 1
116409: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116410: LD_VAR 0 1
116414: PPUSH
116415: LD_INT 19
116417: PPUSH
116418: CALL 62353 0 2
// repeat wait ( 0 0$1 ) ;
116422: LD_INT 35
116424: PPUSH
116425: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116429: LD_EXP 61
116433: PUSH
116434: LD_VAR 0 1
116438: ARRAY
116439: NOT
116440: PUSH
116441: LD_EXP 61
116445: PUSH
116446: LD_VAR 0 1
116450: ARRAY
116451: PUSH
116452: EMPTY
116453: EQUAL
116454: OR
116455: IFFALSE 116492
// begin for i in defenders do
116457: LD_ADDR_VAR 0 4
116461: PUSH
116462: LD_VAR 0 2
116466: PUSH
116467: FOR_IN
116468: IFFALSE 116481
// ComStop ( i ) ;
116470: LD_VAR 0 4
116474: PPUSH
116475: CALL_OW 141
116479: GO 116467
116481: POP
116482: POP
// defenders := [ ] ;
116483: LD_ADDR_VAR 0 2
116487: PUSH
116488: EMPTY
116489: ST_TO_ADDR
// exit ;
116490: GO 116718
// end ; for i in defenders do
116492: LD_ADDR_VAR 0 4
116496: PUSH
116497: LD_VAR 0 2
116501: PUSH
116502: FOR_IN
116503: IFFALSE 116592
// begin if not IsInArea ( i , mc_parking [ base ] ) then
116505: LD_VAR 0 4
116509: PPUSH
116510: LD_EXP 85
116514: PUSH
116515: LD_VAR 0 1
116519: ARRAY
116520: PPUSH
116521: CALL_OW 308
116525: NOT
116526: IFFALSE 116550
// ComMoveToArea ( i , mc_parking [ base ] ) else
116528: LD_VAR 0 4
116532: PPUSH
116533: LD_EXP 85
116537: PUSH
116538: LD_VAR 0 1
116542: ARRAY
116543: PPUSH
116544: CALL_OW 113
116548: GO 116590
// if GetControl ( i ) = control_manual then
116550: LD_VAR 0 4
116554: PPUSH
116555: CALL_OW 263
116559: PUSH
116560: LD_INT 1
116562: EQUAL
116563: IFFALSE 116590
// if IsDrivenBy ( i ) then
116565: LD_VAR 0 4
116569: PPUSH
116570: CALL_OW 311
116574: IFFALSE 116590
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
116576: LD_VAR 0 4
116580: PPUSH
116581: CALL_OW 311
116585: PPUSH
116586: CALL_OW 121
// end ;
116590: GO 116502
116592: POP
116593: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116594: LD_VAR 0 2
116598: PPUSH
116599: LD_INT 95
116601: PUSH
116602: LD_EXP 85
116606: PUSH
116607: LD_VAR 0 1
116611: ARRAY
116612: PUSH
116613: EMPTY
116614: LIST
116615: LIST
116616: PPUSH
116617: CALL_OW 72
116621: PUSH
116622: LD_VAR 0 2
116626: EQUAL
116627: PUSH
116628: LD_EXP 84
116632: PUSH
116633: LD_VAR 0 1
116637: ARRAY
116638: OR
116639: PUSH
116640: LD_EXP 61
116644: PUSH
116645: LD_VAR 0 1
116649: ARRAY
116650: NOT
116651: OR
116652: IFFALSE 116422
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116654: LD_ADDR_EXP 83
116658: PUSH
116659: LD_EXP 83
116663: PPUSH
116664: LD_VAR 0 1
116668: PPUSH
116669: LD_VAR 0 2
116673: PPUSH
116674: LD_INT 21
116676: PUSH
116677: LD_INT 2
116679: PUSH
116680: EMPTY
116681: LIST
116682: LIST
116683: PPUSH
116684: CALL_OW 72
116688: PPUSH
116689: CALL_OW 1
116693: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116694: LD_VAR 0 1
116698: PPUSH
116699: LD_INT 19
116701: PPUSH
116702: CALL 62353 0 2
// MC_Reset ( base , 20 ) ;
116706: LD_VAR 0 1
116710: PPUSH
116711: LD_INT 20
116713: PPUSH
116714: CALL 62353 0 2
// end ; end_of_file
116718: LD_VAR 0 3
116722: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
116723: LD_VAR 0 1
116727: PUSH
116728: LD_INT 200
116730: DOUBLE
116731: GREATEREQUAL
116732: IFFALSE 116740
116734: LD_INT 299
116736: DOUBLE
116737: LESSEQUAL
116738: IFTRUE 116742
116740: GO 116774
116742: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
116743: LD_VAR 0 1
116747: PPUSH
116748: LD_VAR 0 2
116752: PPUSH
116753: LD_VAR 0 3
116757: PPUSH
116758: LD_VAR 0 4
116762: PPUSH
116763: LD_VAR 0 5
116767: PPUSH
116768: CALL 105070 0 5
116772: GO 116851
116774: LD_INT 300
116776: DOUBLE
116777: GREATEREQUAL
116778: IFFALSE 116786
116780: LD_INT 399
116782: DOUBLE
116783: LESSEQUAL
116784: IFTRUE 116788
116786: GO 116850
116788: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
116789: LD_VAR 0 1
116793: PPUSH
116794: LD_VAR 0 2
116798: PPUSH
116799: LD_VAR 0 3
116803: PPUSH
116804: LD_VAR 0 4
116808: PPUSH
116809: LD_VAR 0 5
116813: PPUSH
116814: LD_VAR 0 6
116818: PPUSH
116819: LD_VAR 0 7
116823: PPUSH
116824: LD_VAR 0 8
116828: PPUSH
116829: LD_VAR 0 9
116833: PPUSH
116834: LD_VAR 0 10
116838: PPUSH
116839: LD_VAR 0 11
116843: PPUSH
116844: CALL 101395 0 11
116848: GO 116851
116850: POP
// end ;
116851: PPOPN 11
116853: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
116854: LD_VAR 0 1
116858: PPUSH
116859: LD_VAR 0 2
116863: PPUSH
116864: LD_VAR 0 3
116868: PPUSH
116869: LD_VAR 0 4
116873: PPUSH
116874: LD_VAR 0 5
116878: PPUSH
116879: CALL 104806 0 5
// end ; end_of_file
116883: PPOPN 5
116885: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
116886: LD_VAR 0 1
116890: PPUSH
116891: LD_VAR 0 2
116895: PPUSH
116896: LD_VAR 0 3
116900: PPUSH
116901: LD_VAR 0 4
116905: PPUSH
116906: LD_VAR 0 5
116910: PPUSH
116911: LD_VAR 0 6
116915: PPUSH
116916: CALL 89047 0 6
// end ;
116920: PPOPN 6
116922: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
116923: LD_INT 0
116925: PPUSH
// begin if not units then
116926: LD_VAR 0 1
116930: NOT
116931: IFFALSE 116935
// exit ;
116933: GO 116935
// end ;
116935: PPOPN 7
116937: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
116938: CALL 88951 0 0
// end ;
116942: PPOPN 1
116944: END
