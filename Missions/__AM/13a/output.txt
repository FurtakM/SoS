// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60092 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 51685 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 51685 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 51685 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 51685 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4572 0 0
// PrepareRussian ;
 189: CALL 2997 0 0
// PrepareAlliance ;
 193: CALL 919 0 0
// MC_Start ( ) ;
 197: CALL 62272 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9322 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 83989 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 84434 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84892 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 85161 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 84374 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 85068 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 84434 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84892 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 85161 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 84218 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 85479 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 84374 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: PUSH
 849: LD_EXP 50
 853: PPUSH
 854: CALL_OW 255
 858: PUSH
 859: LD_INT 7
 861: EQUAL
 862: AND
 863: PUSH
 864: LD_EXP 51
 868: PPUSH
 869: CALL_OW 302
 873: AND
 874: PUSH
 875: LD_EXP 50
 879: PPUSH
 880: CALL_OW 302
 884: AND
 885: IFFALSE 897
 887: GO 889
 889: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 890: LD_STRING ACH_COMRADE
 892: PPUSH
 893: CALL_OW 543
 897: END
// every 0 0$1 trigger hack_counter >= 10 do
 898: LD_EXP 16
 902: PUSH
 903: LD_INT 10
 905: GREATEREQUAL
 906: IFFALSE 918
 908: GO 910
 910: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 911: LD_STRING ACH_HACK
 913: PPUSH
 914: CALL_OW 543
 918: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 919: LD_INT 0
 921: PPUSH
 922: PPUSH
 923: PPUSH
 924: PPUSH
// uc_side := 7 ;
 925: LD_ADDR_OWVAR 20
 929: PUSH
 930: LD_INT 7
 932: ST_TO_ADDR
// uc_nation := 1 ;
 933: LD_ADDR_OWVAR 21
 937: PUSH
 938: LD_INT 1
 940: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING JMM
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 17276 0 3
 962: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 963: LD_EXP 17
 967: PPUSH
 968: LD_INT 71
 970: PPUSH
 971: LD_INT 23
 973: PPUSH
 974: LD_INT 0
 976: PPUSH
 977: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 2
 988: PPUSH
 989: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 993: LD_ADDR_EXP 18
 997: PUSH
 998: LD_STRING Roth
1000: PPUSH
1001: LD_EXP 1
1005: NOT
1006: PPUSH
1007: LD_STRING 12a_
1009: PPUSH
1010: CALL 17276 0 3
1014: ST_TO_ADDR
// if Roth then
1015: LD_EXP 18
1019: IFFALSE 1039
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1021: LD_EXP 18
1025: PPUSH
1026: LD_INT 71
1028: PPUSH
1029: LD_INT 21
1031: PPUSH
1032: LD_INT 0
1034: PPUSH
1035: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1039: LD_ADDR_EXP 34
1043: PUSH
1044: LD_STRING Mike
1046: PPUSH
1047: LD_EXP 1
1051: NOT
1052: PPUSH
1053: LD_STRING 12a_
1055: PPUSH
1056: CALL 17276 0 3
1060: ST_TO_ADDR
// if Mike then
1061: LD_EXP 34
1065: IFFALSE 1082
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1067: LD_EXP 34
1071: PPUSH
1072: LD_INT 13
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1082: LD_ADDR_EXP 19
1086: PUSH
1087: LD_STRING Lisa
1089: PPUSH
1090: LD_EXP 1
1094: NOT
1095: PPUSH
1096: LD_STRING 12a_
1098: PPUSH
1099: CALL 17276 0 3
1103: ST_TO_ADDR
// if Lisa then
1104: LD_EXP 19
1108: IFFALSE 1125
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1110: LD_EXP 19
1114: PPUSH
1115: LD_INT 13
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1125: LD_ADDR_EXP 20
1129: PUSH
1130: LD_STRING Donaldson
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_STRING 12a_
1141: PPUSH
1142: CALL 17276 0 3
1146: ST_TO_ADDR
// if Donaldson then
1147: LD_EXP 20
1151: IFFALSE 1168
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1153: LD_EXP 20
1157: PPUSH
1158: LD_INT 13
1160: PPUSH
1161: LD_INT 0
1163: PPUSH
1164: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1168: LD_ADDR_EXP 21
1172: PUSH
1173: LD_STRING Bobby
1175: PPUSH
1176: LD_EXP 1
1180: NOT
1181: PPUSH
1182: LD_STRING 12a_
1184: PPUSH
1185: CALL 17276 0 3
1189: ST_TO_ADDR
// if Bobby then
1190: LD_EXP 21
1194: IFFALSE 1211
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1196: LD_EXP 21
1200: PPUSH
1201: LD_INT 13
1203: PPUSH
1204: LD_INT 0
1206: PPUSH
1207: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1211: LD_ADDR_EXP 22
1215: PUSH
1216: LD_STRING Cyrus
1218: PPUSH
1219: LD_EXP 1
1223: NOT
1224: PPUSH
1225: LD_STRING 12a_
1227: PPUSH
1228: CALL 17276 0 3
1232: ST_TO_ADDR
// if Cyrus then
1233: LD_EXP 22
1237: IFFALSE 1254
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1239: LD_EXP 22
1243: PPUSH
1244: LD_INT 13
1246: PPUSH
1247: LD_INT 0
1249: PPUSH
1250: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1254: LD_ADDR_EXP 23
1258: PUSH
1259: LD_STRING Denis
1261: PPUSH
1262: LD_EXP 1
1266: NOT
1267: PPUSH
1268: LD_STRING 12a_
1270: PPUSH
1271: CALL 17276 0 3
1275: ST_TO_ADDR
// if Denis then
1276: LD_EXP 23
1280: IFFALSE 1297
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1282: LD_EXP 23
1286: PPUSH
1287: LD_INT 13
1289: PPUSH
1290: LD_INT 0
1292: PPUSH
1293: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1297: LD_ADDR_EXP 24
1301: PUSH
1302: LD_STRING Brown
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 12a_
1313: PPUSH
1314: CALL 17276 0 3
1318: ST_TO_ADDR
// if Brown then
1319: LD_EXP 24
1323: IFFALSE 1340
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1325: LD_EXP 24
1329: PPUSH
1330: LD_INT 13
1332: PPUSH
1333: LD_INT 0
1335: PPUSH
1336: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1340: LD_ADDR_EXP 25
1344: PUSH
1345: LD_STRING Gladstone
1347: PPUSH
1348: LD_EXP 1
1352: NOT
1353: PPUSH
1354: LD_STRING 12a_
1356: PPUSH
1357: CALL 17276 0 3
1361: ST_TO_ADDR
// if Gladstone then
1362: LD_EXP 25
1366: IFFALSE 1383
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1368: LD_EXP 25
1372: PPUSH
1373: LD_INT 13
1375: PPUSH
1376: LD_INT 0
1378: PPUSH
1379: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1383: LD_ADDR_EXP 26
1387: PUSH
1388: LD_STRING Houten
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: LD_STRING 12a_
1399: PPUSH
1400: CALL 17276 0 3
1404: ST_TO_ADDR
// if Houten then
1405: LD_EXP 26
1409: IFFALSE 1426
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1411: LD_EXP 26
1415: PPUSH
1416: LD_INT 13
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1426: LD_ADDR_EXP 27
1430: PUSH
1431: LD_STRING Cornell
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: LD_STRING 12a_
1442: PPUSH
1443: CALL 17276 0 3
1447: ST_TO_ADDR
// if Cornel then
1448: LD_EXP 27
1452: IFFALSE 1469
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1454: LD_EXP 27
1458: PPUSH
1459: LD_INT 13
1461: PPUSH
1462: LD_INT 0
1464: PPUSH
1465: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1469: LD_ADDR_EXP 28
1473: PUSH
1474: LD_STRING Gary
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: LD_STRING 12a_
1485: PPUSH
1486: CALL 17276 0 3
1490: ST_TO_ADDR
// if Gary then
1491: LD_EXP 28
1495: IFFALSE 1512
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1497: LD_EXP 28
1501: PPUSH
1502: LD_INT 13
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1512: LD_ADDR_EXP 29
1516: PUSH
1517: LD_STRING Frank
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 12a_
1528: PPUSH
1529: CALL 17276 0 3
1533: ST_TO_ADDR
// if Frank then
1534: LD_EXP 29
1538: IFFALSE 1555
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1540: LD_EXP 29
1544: PPUSH
1545: LD_INT 13
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1555: LD_ADDR_EXP 30
1559: PUSH
1560: LD_STRING Kikuchi
1562: PPUSH
1563: LD_EXP 1
1567: NOT
1568: PPUSH
1569: LD_STRING 12a_
1571: PPUSH
1572: CALL 17276 0 3
1576: ST_TO_ADDR
// if Kikuchi then
1577: LD_EXP 30
1581: IFFALSE 1598
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1583: LD_EXP 30
1587: PPUSH
1588: LD_INT 13
1590: PPUSH
1591: LD_INT 0
1593: PPUSH
1594: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1598: LD_ADDR_EXP 31
1602: PUSH
1603: LD_STRING Simms
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 12a_
1614: PPUSH
1615: CALL 17276 0 3
1619: ST_TO_ADDR
// if Simms then
1620: LD_EXP 31
1624: IFFALSE 1641
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1626: LD_EXP 31
1630: PPUSH
1631: LD_INT 13
1633: PPUSH
1634: LD_INT 0
1636: PPUSH
1637: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1641: LD_ADDR_EXP 32
1645: PUSH
1646: LD_STRING Joan
1648: PPUSH
1649: LD_EXP 1
1653: NOT
1654: PPUSH
1655: LD_STRING 12a_
1657: PPUSH
1658: CALL 17276 0 3
1662: ST_TO_ADDR
// if Joan then
1663: LD_EXP 32
1667: IFFALSE 1684
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1669: LD_EXP 32
1673: PPUSH
1674: LD_INT 13
1676: PPUSH
1677: LD_INT 0
1679: PPUSH
1680: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1684: LD_ADDR_EXP 33
1688: PUSH
1689: LD_STRING DeltaDoctor
1691: PPUSH
1692: LD_EXP 1
1696: NOT
1697: PPUSH
1698: LD_STRING 12a_
1700: PPUSH
1701: CALL 17276 0 3
1705: ST_TO_ADDR
// if DeltaDoctor then
1706: LD_EXP 33
1710: IFFALSE 1727
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1712: LD_EXP 33
1716: PPUSH
1717: LD_INT 13
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1727: LD_ADDR_VAR 0 4
1731: PUSH
1732: LD_STRING 12a_others
1734: PPUSH
1735: CALL_OW 31
1739: ST_TO_ADDR
// if tmp then
1740: LD_VAR 0 4
1744: IFFALSE 1778
// for i in tmp do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: LD_VAR 0 4
1755: PUSH
1756: FOR_IN
1757: IFFALSE 1776
// PlaceUnitArea ( i , alliance_start , false ) ;
1759: LD_VAR 0 3
1763: PPUSH
1764: LD_INT 13
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 49
1774: GO 1756
1776: POP
1777: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1778: LD_INT 3
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 12
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 22137 0 5
// veh := CreateVehicle ;
1797: LD_ADDR_VAR 0 2
1801: PUSH
1802: CALL_OW 45
1806: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 2
1814: PPUSH
1815: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_INT 60
1826: PPUSH
1827: LD_INT 6
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1837: LD_VAR 0 2
1841: PPUSH
1842: LD_INT 4
1844: PPUSH
1845: LD_INT 30
1847: PPUSH
1848: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1852: LD_STRING 11_artifact_captured
1854: PPUSH
1855: LD_INT 0
1857: PPUSH
1858: CALL_OW 30
1862: IFFALSE 1938
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1864: LD_INT 3
1866: PPUSH
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 12
1875: PPUSH
1876: LD_INT 100
1878: PPUSH
1879: CALL 22137 0 5
// veh := CreateVehicle ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: CALL_OW 45
1892: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1893: LD_VAR 0 2
1897: PPUSH
1898: LD_INT 3
1900: PPUSH
1901: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1905: LD_VAR 0 2
1909: PPUSH
1910: LD_INT 75
1912: PPUSH
1913: LD_INT 6
1915: PPUSH
1916: LD_INT 0
1918: PPUSH
1919: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1923: LD_VAR 0 2
1927: PPUSH
1928: LD_INT 4
1930: PPUSH
1931: LD_INT 50
1933: PPUSH
1934: CALL_OW 290
// end ; end ;
1938: LD_VAR 0 1
1942: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1943: LD_INT 0
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
// uc_side := 6 ;
1949: LD_ADDR_OWVAR 20
1953: PUSH
1954: LD_INT 6
1956: ST_TO_ADDR
// uc_nation := 3 ;
1957: LD_ADDR_OWVAR 21
1961: PUSH
1962: LD_INT 3
1964: ST_TO_ADDR
// InitHc ;
1965: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1969: LD_ADDR_EXP 35
1973: PUSH
1974: LD_STRING Gossudarov
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1982: LD_ADDR_EXP 36
1986: PUSH
1987: LD_STRING Kirilenkova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1995: LD_ADDR_EXP 37
1999: PUSH
2000: LD_STRING Titov
2002: PPUSH
2003: CALL_OW 25
2007: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2008: LD_ADDR_EXP 42
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: CALL_OW 25
2020: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2021: LD_ADDR_EXP 39
2025: PUSH
2026: LD_STRING Dolgov
2028: PPUSH
2029: CALL_OW 25
2033: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2034: LD_ADDR_EXP 40
2038: PUSH
2039: LD_STRING Petrosyan
2041: PPUSH
2042: CALL_OW 25
2046: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2047: LD_ADDR_EXP 41
2051: PUSH
2052: LD_STRING Scholtze
2054: PPUSH
2055: CALL_OW 25
2059: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2060: LD_ADDR_EXP 43
2064: PUSH
2065: LD_STRING Kapitsova
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_EXP 35
2082: PUSH
2083: LD_EXP 36
2087: PUSH
2088: LD_EXP 37
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_EXP 39
2102: PUSH
2103: LD_EXP 40
2107: PUSH
2108: LD_EXP 41
2112: PUSH
2113: LD_EXP 43
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 4
2133: PPUSH
2134: LD_INT 8
2136: PPUSH
2137: CALL_OW 380
// un := CreateHuman ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: CALL_OW 44
2150: ST_TO_ADDR
// tmp := tmp ^ un ;
2151: LD_ADDR_VAR 0 2
2155: PUSH
2156: LD_VAR 0 2
2160: PUSH
2161: LD_VAR 0 4
2165: ADD
2166: ST_TO_ADDR
// for i in tmp do
2167: LD_ADDR_VAR 0 3
2171: PUSH
2172: LD_VAR 0 2
2176: PUSH
2177: FOR_IN
2178: IFFALSE 2197
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2180: LD_VAR 0 3
2184: PPUSH
2185: LD_INT 14
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
2195: GO 2177
2197: POP
2198: POP
// if freedom then
2199: LD_EXP 3
2203: IFFALSE 2236
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2205: LD_VAR 0 2
2209: PPUSH
2210: LD_EXP 3
2214: PPUSH
2215: CALL_OW 250
2219: PPUSH
2220: LD_EXP 3
2224: PPUSH
2225: CALL_OW 251
2229: PPUSH
2230: CALL_OW 111
2234: GO 2251
// ComMoveXY ( tmp , 70 , 48 ) ;
2236: LD_VAR 0 2
2240: PPUSH
2241: LD_INT 70
2243: PPUSH
2244: LD_INT 48
2246: PPUSH
2247: CALL_OW 111
// end ;
2251: LD_VAR 0 1
2255: RET
// export function PrepareBelkov ; begin
2256: LD_INT 0
2258: PPUSH
// uc_side := 4 ;
2259: LD_ADDR_OWVAR 20
2263: PUSH
2264: LD_INT 4
2266: ST_TO_ADDR
// uc_nation := 3 ;
2267: LD_ADDR_OWVAR 21
2271: PUSH
2272: LD_INT 3
2274: ST_TO_ADDR
// InitHc ;
2275: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: CALL_OW 25
2291: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2292: LD_EXP 50
2296: PPUSH
2297: LD_INT 14
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// end ;
2307: LD_VAR 0 1
2311: RET
// export function PrepareGnyevko ; begin
2312: LD_INT 0
2314: PPUSH
// uc_side := 4 ;
2315: LD_ADDR_OWVAR 20
2319: PUSH
2320: LD_INT 4
2322: ST_TO_ADDR
// uc_nation := 3 ;
2323: LD_ADDR_OWVAR 21
2327: PUSH
2328: LD_INT 3
2330: ST_TO_ADDR
// InitHc ;
2331: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2335: LD_ADDR_EXP 51
2339: PUSH
2340: LD_STRING Gnyevko
2342: PPUSH
2343: CALL_OW 25
2347: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2348: LD_EXP 51
2352: PPUSH
2353: LD_INT 14
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 49
// end ;
2363: LD_VAR 0 1
2367: RET
// export function PrepareBurlak ; var i , tmp ; begin
2368: LD_INT 0
2370: PPUSH
2371: PPUSH
2372: PPUSH
// uc_side := 4 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 4
2380: ST_TO_ADDR
// uc_nation := 3 ;
2381: LD_ADDR_OWVAR 21
2385: PUSH
2386: LD_INT 3
2388: ST_TO_ADDR
// InitHc ;
2389: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2393: LD_ADDR_EXP 49
2397: PUSH
2398: LD_STRING Burlak
2400: PPUSH
2401: CALL_OW 25
2405: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2406: LD_INT 24
2408: PUSH
2409: LD_INT 23
2411: PUSH
2412: LD_INT 22
2414: PUSH
2415: LD_INT 22
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_OWVAR 67
2428: ARRAY
2429: PPUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 1
2435: PPUSH
2436: LD_INT 45
2438: PUSH
2439: LD_INT 44
2441: PUSH
2442: LD_INT 43
2444: PUSH
2445: LD_INT 42
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: LD_OWVAR 67
2458: ARRAY
2459: PPUSH
2460: LD_INT 0
2462: PPUSH
2463: CALL 22137 0 5
// Masha := CreateVehicle ;
2467: LD_ADDR_EXP 52
2471: PUSH
2472: CALL_OW 45
2476: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2477: LD_EXP 52
2481: PUSH
2482: LD_EXP 49
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: LD_INT 499
2493: PPUSH
2494: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2498: LD_EXP 52
2502: PPUSH
2503: LD_INT 3
2505: PPUSH
2506: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2510: LD_EXP 52
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2522: LD_INT 1
2524: PPUSH
2525: LD_INT 18
2527: PPUSH
2528: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2532: LD_INT 35
2534: PPUSH
2535: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_INT 18
2546: PPUSH
2547: EMPTY
2548: PPUSH
2549: CALL_OW 70
2553: ST_TO_ADDR
// if tmp then
2554: LD_VAR 0 3
2558: IFFALSE 2592
// for i in tmp do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2590
// ComMoveXY ( i , 114 , 9 ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 114
2580: PPUSH
2581: LD_INT 9
2583: PPUSH
2584: CALL_OW 111
2588: GO 2570
2590: POP
2591: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2592: LD_INT 18
2594: PPUSH
2595: EMPTY
2596: PPUSH
2597: CALL_OW 70
2601: NOT
2602: PUSH
2603: LD_INT 123
2605: PPUSH
2606: LD_INT 3
2608: PPUSH
2609: CALL_OW 428
2613: PUSH
2614: LD_INT 0
2616: EQUAL
2617: AND
2618: IFFALSE 2532
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2620: LD_EXP 52
2624: PPUSH
2625: LD_INT 123
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 0
2633: PPUSH
2634: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2638: LD_EXP 49
2642: PPUSH
2643: LD_INT 125
2645: PPUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 0
2651: PPUSH
2652: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2656: LD_EXP 49
2660: PPUSH
2661: LD_EXP 52
2665: PPUSH
2666: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2677: LD_EXP 52
2681: PPUSH
2682: LD_INT 110
2684: PPUSH
2685: LD_INT 10
2687: PPUSH
2688: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2692: LD_ADDR_EXP 45
2696: PUSH
2697: LD_STRING Petrovova
2699: PPUSH
2700: CALL_OW 25
2704: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2705: LD_ADDR_EXP 47
2709: PUSH
2710: LD_STRING Kuzmov
2712: PPUSH
2713: CALL_OW 25
2717: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2718: LD_ADDR_EXP 46
2722: PUSH
2723: LD_STRING Kovalyuk
2725: PPUSH
2726: CALL_OW 25
2730: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2731: LD_ADDR_EXP 44
2735: PUSH
2736: LD_STRING Lipshchin
2738: PPUSH
2739: CALL_OW 25
2743: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2744: LD_ADDR_EXP 48
2748: PUSH
2749: LD_STRING Karamazov
2751: PPUSH
2752: CALL_OW 25
2756: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: LD_EXP 45
2766: PUSH
2767: LD_EXP 47
2771: PUSH
2772: LD_EXP 46
2776: PUSH
2777: LD_EXP 44
2781: PUSH
2782: LD_EXP 48
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: LIST
2793: ST_TO_ADDR
// for i in tmp do
2794: LD_ADDR_VAR 0 2
2798: PUSH
2799: LD_VAR 0 3
2803: PUSH
2804: FOR_IN
2805: IFFALSE 2844
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2807: LD_VAR 0 2
2811: PPUSH
2812: LD_INT 399
2814: PPUSH
2815: LD_INT 799
2817: PPUSH
2818: CALL_OW 12
2822: PPUSH
2823: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2827: LD_VAR 0 2
2831: PPUSH
2832: LD_INT 19
2834: PPUSH
2835: LD_INT 0
2837: PPUSH
2838: CALL_OW 49
// end ;
2842: GO 2804
2844: POP
2845: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2846: LD_VAR 0 3
2850: PPUSH
2851: LD_INT 112
2853: PPUSH
2854: LD_INT 5
2856: PPUSH
2857: CALL_OW 111
// AddComHold ( tmp ) ;
2861: LD_VAR 0 3
2865: PPUSH
2866: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_VAR 0 3
2879: PPUSH
2880: LD_INT 25
2882: PUSH
2883: LD_INT 1
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 72
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2936
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2898: LD_VAR 0 2
2902: PPUSH
2903: LD_INT 20
2905: PPUSH
2906: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2910: LD_VAR 0 2
2914: PPUSH
2915: LD_INT 147
2917: PPUSH
2918: LD_INT 45
2920: PPUSH
2921: CALL_OW 178
// AddComCrawl ( i ) ;
2925: LD_VAR 0 2
2929: PPUSH
2930: CALL_OW 197
// end ;
2934: GO 2895
2936: POP
2937: POP
// repeat wait ( 0 0$1 ) ;
2938: LD_INT 35
2940: PPUSH
2941: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2945: LD_EXP 52
2949: PPUSH
2950: LD_INT 110
2952: PPUSH
2953: LD_INT 10
2955: PPUSH
2956: CALL_OW 307
2960: PUSH
2961: LD_EXP 52
2965: PPUSH
2966: CALL_OW 305
2970: NOT
2971: OR
2972: IFFALSE 2938
// ComStop ( Burlak ) ;
2974: LD_EXP 49
2978: PPUSH
2979: CALL_OW 141
// AddComHold ( Burlak ) ;
2983: LD_EXP 49
2987: PPUSH
2988: CALL_OW 200
// end ; end_of_file
2992: LD_VAR 0 1
2996: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2997: LD_INT 0
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
3003: PPUSH
// uc_side := 3 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// uc_nation := 3 ;
3012: LD_ADDR_OWVAR 21
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3020: LD_ADDR_EXP 53
3024: PUSH
3025: LD_INT 47
3027: PPUSH
3028: LD_INT 4
3030: PPUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 7
3036: PUSH
3037: LD_INT 8
3039: PUSH
3040: LD_INT 9
3042: PUSH
3043: LD_INT 10
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_OWVAR 67
3056: ARRAY
3057: PPUSH
3058: LD_INT 10000
3060: PUSH
3061: LD_INT 3000
3063: PUSH
3064: LD_INT 300
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: PPUSH
3072: LD_INT 9
3074: PUSH
3075: LD_INT 5
3077: PUSH
3078: LD_INT 6
3080: PUSH
3081: LD_INT 6
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL 25958 0 6
3094: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3095: LD_ADDR_EXP 63
3099: PUSH
3100: LD_EXP 63
3104: PPUSH
3105: LD_INT 2
3107: PPUSH
3108: LD_EXP 53
3112: PPUSH
3113: CALL_OW 1
3117: ST_TO_ADDR
// tmp := [ ] ;
3118: LD_ADDR_VAR 0 4
3122: PUSH
3123: EMPTY
3124: ST_TO_ADDR
// for i = 1 to 4 do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: DOUBLE
3131: LD_INT 1
3133: DEC
3134: ST_TO_ADDR
3135: LD_INT 4
3137: PUSH
3138: FOR_TO
3139: IFFALSE 3232
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3141: LD_INT 22
3143: PPUSH
3144: LD_INT 3
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 43
3152: PUSH
3153: LD_INT 45
3155: PUSH
3156: LD_INT 45
3158: PUSH
3159: LD_INT 44
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: PUSH
3168: LD_VAR 0 2
3172: PUSH
3173: LD_INT 4
3175: MOD
3176: PUSH
3177: LD_INT 1
3179: PLUS
3180: ARRAY
3181: PPUSH
3182: LD_INT 100
3184: PPUSH
3185: CALL 22137 0 5
// veh := CreateVehicle ;
3189: LD_ADDR_VAR 0 3
3193: PUSH
3194: CALL_OW 45
3198: ST_TO_ADDR
// tmp := tmp ^ veh ;
3199: LD_ADDR_VAR 0 4
3203: PUSH
3204: LD_VAR 0 4
3208: PUSH
3209: LD_VAR 0 3
3213: ADD
3214: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3215: LD_VAR 0 3
3219: PPUSH
3220: LD_INT 2
3222: PPUSH
3223: LD_INT 0
3225: PPUSH
3226: CALL_OW 49
// end ;
3230: GO 3138
3232: POP
3233: POP
// russian_guard := tmp ;
3234: LD_ADDR_EXP 54
3238: PUSH
3239: LD_VAR 0 4
3243: ST_TO_ADDR
// if Difficulty >= 3 then
3244: LD_OWVAR 67
3248: PUSH
3249: LD_INT 3
3251: GREATEREQUAL
3252: IFFALSE 3316
// begin bc_type := b_breastwork ;
3254: LD_ADDR_OWVAR 42
3258: PUSH
3259: LD_INT 31
3261: ST_TO_ADDR
// bc_level := 10 ;
3262: LD_ADDR_OWVAR 43
3266: PUSH
3267: LD_INT 10
3269: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3270: LD_ADDR_VAR 0 5
3274: PUSH
3275: LD_INT 96
3277: PPUSH
3278: LD_INT 105
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: CALL_OW 47
3288: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3289: LD_INT 0
3291: PPUSH
3292: LD_INT 9
3294: PPUSH
3295: LD_INT 10
3297: PPUSH
3298: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3302: CALL_OW 44
3306: PPUSH
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 52
// end ; end ;
3316: LD_VAR 0 1
3320: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3321: LD_INT 47
3323: PPUSH
3324: CALL_OW 302
3328: PUSH
3329: LD_EXP 7
3333: AND
3334: IFFALSE 4088
3336: GO 3338
3338: DISABLE
3339: LD_INT 0
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
// begin enable ;
3348: ENABLE
// base := 2 ;
3349: LD_ADDR_VAR 0 3
3353: PUSH
3354: LD_INT 2
3356: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3357: LD_ADDR_VAR 0 4
3361: PUSH
3362: LD_INT 22
3364: PUSH
3365: LD_INT 1
3367: PUSH
3368: LD_INT 3
3370: PUSH
3371: LD_INT 45
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 21
3382: PUSH
3383: LD_INT 1
3385: PUSH
3386: LD_INT 3
3388: PUSH
3389: LD_INT 45
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: LD_INT 22
3400: PUSH
3401: LD_INT 1
3403: PUSH
3404: LD_INT 3
3406: PUSH
3407: LD_INT 45
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 23
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 46
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: ST_TO_ADDR
// amount := Difficulty ;
3440: LD_ADDR_VAR 0 7
3444: PUSH
3445: LD_OWVAR 67
3449: ST_TO_ADDR
// if tick > 30 30$00 then
3450: LD_OWVAR 1
3454: PUSH
3455: LD_INT 63000
3457: GREATER
3458: IFFALSE 3495
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3460: LD_ADDR_VAR 0 7
3464: PUSH
3465: LD_VAR 0 7
3469: PUSH
3470: LD_INT 2
3472: PUSH
3473: LD_INT 3
3475: PUSH
3476: LD_INT 4
3478: PUSH
3479: LD_INT 4
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_OWVAR 67
3492: ARRAY
3493: PLUS
3494: ST_TO_ADDR
// for i = 1 to amount do
3495: LD_ADDR_VAR 0 1
3499: PUSH
3500: DOUBLE
3501: LD_INT 1
3503: DEC
3504: ST_TO_ADDR
3505: LD_VAR 0 7
3509: PUSH
3510: FOR_TO
3511: IFFALSE 3599
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3513: LD_ADDR_VAR 0 4
3517: PUSH
3518: LD_VAR 0 4
3522: PPUSH
3523: LD_VAR 0 4
3527: PUSH
3528: LD_INT 1
3530: PLUS
3531: PPUSH
3532: LD_INT 23
3534: PUSH
3535: LD_INT 24
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: PUSH
3542: LD_INT 1
3544: PPUSH
3545: LD_INT 2
3547: PPUSH
3548: CALL_OW 12
3552: ARRAY
3553: PUSH
3554: LD_INT 1
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: LD_INT 46
3562: PUSH
3563: LD_INT 47
3565: PUSH
3566: LD_INT 45
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: PUSH
3574: LD_INT 1
3576: PPUSH
3577: LD_INT 3
3579: PPUSH
3580: CALL_OW 12
3584: ARRAY
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 2
3596: ST_TO_ADDR
3597: GO 3510
3599: POP
3600: POP
// p := 1 ;
3601: LD_ADDR_VAR 0 2
3605: PUSH
3606: LD_INT 1
3608: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3609: LD_VAR 0 3
3613: PPUSH
3614: LD_VAR 0 4
3618: PPUSH
3619: CALL 84374 0 2
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// p := Inc ( p ) ;
3630: LD_ADDR_VAR 0 2
3634: PUSH
3635: LD_VAR 0 2
3639: PPUSH
3640: CALL 56369 0 1
3644: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3645: LD_VAR 0 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL 85792 0 2
3657: PUSH
3658: LD_VAR 0 7
3662: GREATEREQUAL
3663: PUSH
3664: LD_VAR 0 2
3668: PUSH
3669: LD_INT 60
3671: GREATEREQUAL
3672: OR
3673: IFFALSE 3623
// wait ( 0 0$30 ) ;
3675: LD_INT 1050
3677: PPUSH
3678: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3682: LD_ADDR_VAR 0 5
3686: PUSH
3687: LD_INT 71
3689: PUSH
3690: LD_INT 19
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 91
3699: PUSH
3700: LD_INT 67
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 52
3709: PUSH
3710: LD_INT 44
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 68
3719: PUSH
3720: LD_INT 48
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3733: LD_ADDR_VAR 0 6
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 3
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: LD_INT 21
3750: PUSH
3751: LD_INT 2
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 2
3763: PUSH
3764: LD_INT 34
3766: PUSH
3767: LD_INT 52
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 34
3776: PUSH
3777: LD_INT 51
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_EXP 85
3807: PUSH
3808: LD_VAR 0 3
3812: ARRAY
3813: DIFF
3814: ST_TO_ADDR
// if not attackers then
3815: LD_VAR 0 6
3819: NOT
3820: IFFALSE 3824
// exit ;
3822: GO 4088
// ru_attackers := attackers ;
3824: LD_ADDR_EXP 55
3828: PUSH
3829: LD_VAR 0 6
3833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3834: LD_ADDR_EXP 82
3838: PUSH
3839: LD_EXP 82
3843: PPUSH
3844: LD_VAR 0 3
3848: PPUSH
3849: LD_EXP 82
3853: PUSH
3854: LD_VAR 0 3
3858: ARRAY
3859: PUSH
3860: LD_VAR 0 6
3864: DIFF
3865: PPUSH
3866: CALL_OW 1
3870: ST_TO_ADDR
// for i = 1 to attackers do
3871: LD_ADDR_VAR 0 1
3875: PUSH
3876: DOUBLE
3877: LD_INT 1
3879: DEC
3880: ST_TO_ADDR
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_TO
3887: IFFALSE 3964
// begin case i mod 3 of 0 :
3889: LD_VAR 0 1
3893: PUSH
3894: LD_INT 3
3896: MOD
3897: PUSH
3898: LD_INT 0
3900: DOUBLE
3901: EQUAL
3902: IFTRUE 3906
3904: GO 3909
3906: POP
// ; 1 :
3907: GO 3962
3909: LD_INT 1
3911: DOUBLE
3912: EQUAL
3913: IFTRUE 3917
3915: GO 3935
3917: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3918: LD_VAR 0 1
3922: PPUSH
3923: LD_INT 32
3925: PPUSH
3926: LD_INT 49
3928: PPUSH
3929: CALL_OW 114
3933: GO 3962
3935: LD_INT 2
3937: DOUBLE
3938: EQUAL
3939: IFTRUE 3943
3941: GO 3961
3943: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3944: LD_VAR 0 1
3948: PPUSH
3949: LD_INT 117
3951: PPUSH
3952: LD_INT 107
3954: PPUSH
3955: CALL_OW 114
3959: GO 3962
3961: POP
// end ;
3962: GO 3886
3964: POP
3965: POP
// p := 0 ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_INT 0
3973: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3974: LD_INT 35
3976: PPUSH
3977: CALL_OW 67
// p := Inc ( p ) ;
3981: LD_ADDR_VAR 0 2
3985: PUSH
3986: LD_VAR 0 2
3990: PPUSH
3991: CALL 56369 0 1
3995: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3996: LD_VAR 0 6
4000: PPUSH
4001: LD_INT 60
4003: PUSH
4004: EMPTY
4005: LIST
4006: PPUSH
4007: CALL_OW 72
4011: NOT
4012: PUSH
4013: LD_VAR 0 2
4017: PUSH
4018: LD_INT 30
4020: GREATER
4021: OR
4022: IFFALSE 3974
// if not first_attack then
4024: LD_EXP 8
4028: NOT
4029: IFFALSE 4039
// first_attack := true ;
4031: LD_ADDR_EXP 8
4035: PUSH
4036: LD_INT 1
4038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4039: LD_INT 35
4041: PPUSH
4042: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4046: LD_ADDR_VAR 0 6
4050: PUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: LD_INT 50
4058: PUSH
4059: EMPTY
4060: LIST
4061: PPUSH
4062: CALL_OW 72
4066: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_VAR 0 5
4076: PPUSH
4077: CALL 57612 0 2
// until not attackers ;
4081: LD_VAR 0 6
4085: NOT
4086: IFFALSE 4039
// end ;
4088: PPOPN 7
4090: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4091: LD_INT 0
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
// uc_side := 6 ;
4099: LD_ADDR_OWVAR 20
4103: PUSH
4104: LD_INT 6
4106: ST_TO_ADDR
// uc_nation := 3 ;
4107: LD_ADDR_OWVAR 21
4111: PUSH
4112: LD_INT 3
4114: ST_TO_ADDR
// InitHc ;
4115: CALL_OW 19
// InitVc ;
4119: CALL_OW 20
// tmp := [ ] ;
4123: LD_ADDR_VAR 0 3
4127: PUSH
4128: EMPTY
4129: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4130: LD_ADDR_VAR 0 2
4134: PUSH
4135: DOUBLE
4136: LD_INT 1
4138: DEC
4139: ST_TO_ADDR
4140: LD_INT 4
4142: PUSH
4143: LD_INT 5
4145: PUSH
4146: LD_INT 6
4148: PUSH
4149: LD_INT 7
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: PUSH
4158: LD_OWVAR 67
4162: ARRAY
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4419
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4167: LD_ADDR_VAR 0 5
4171: PUSH
4172: LD_INT 21
4174: PUSH
4175: LD_INT 22
4177: PUSH
4178: LD_INT 24
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 1
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: CALL_OW 12
4196: ARRAY
4197: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4198: LD_VAR 0 5
4202: PUSH
4203: LD_INT 21
4205: DOUBLE
4206: EQUAL
4207: IFTRUE 4217
4209: LD_INT 22
4211: DOUBLE
4212: EQUAL
4213: IFTRUE 4217
4215: GO 4251
4217: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4218: LD_ADDR_VAR 0 6
4222: PUSH
4223: LD_INT 45
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: LD_INT 43
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 1
4239: PPUSH
4240: LD_INT 3
4242: PPUSH
4243: CALL_OW 12
4247: ARRAY
4248: ST_TO_ADDR
4249: GO 4298
4251: LD_INT 24
4253: DOUBLE
4254: EQUAL
4255: IFTRUE 4259
4257: GO 4297
4259: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4260: LD_ADDR_VAR 0 6
4264: PUSH
4265: LD_INT 46
4267: PUSH
4268: LD_INT 47
4270: PUSH
4271: LD_INT 45
4273: PUSH
4274: LD_INT 46
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 1
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 12
4293: ARRAY
4294: ST_TO_ADDR
4295: GO 4298
4297: POP
// uc_side := 6 ;
4298: LD_ADDR_OWVAR 20
4302: PUSH
4303: LD_INT 6
4305: ST_TO_ADDR
// uc_nation := 3 ;
4306: LD_ADDR_OWVAR 21
4310: PUSH
4311: LD_INT 3
4313: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4314: LD_VAR 0 5
4318: PPUSH
4319: LD_INT 1
4321: PUSH
4322: LD_INT 3
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 2
4334: PPUSH
4335: CALL_OW 12
4339: ARRAY
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_VAR 0 6
4348: PPUSH
4349: LD_INT 70
4351: PPUSH
4352: LD_INT 90
4354: PPUSH
4355: CALL_OW 12
4359: PPUSH
4360: CALL 22137 0 5
// veh := CreateVehicle ;
4364: LD_ADDR_VAR 0 4
4368: PUSH
4369: CALL_OW 45
4373: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_INT 5
4381: PPUSH
4382: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_INT 16
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: CALL_OW 49
// tmp := tmp ^ veh ;
4401: LD_ADDR_VAR 0 3
4405: PUSH
4406: LD_VAR 0 3
4410: PUSH
4411: LD_VAR 0 4
4415: ADD
4416: ST_TO_ADDR
// end ;
4417: GO 4164
4419: POP
4420: POP
// if not tmp then
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4430
// exit ;
4428: GO 4524
// repeat wait ( 0 0$2 ) ;
4430: LD_INT 70
4432: PPUSH
4433: CALL_OW 67
// for i in tmp do
4437: LD_ADDR_VAR 0 2
4441: PUSH
4442: LD_VAR 0 3
4446: PUSH
4447: FOR_IN
4448: IFFALSE 4515
// if IsOk ( i ) then
4450: LD_VAR 0 2
4454: PPUSH
4455: CALL_OW 302
4459: IFFALSE 4497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4461: LD_VAR 0 2
4465: PPUSH
4466: LD_INT 22
4468: PUSH
4469: LD_INT 7
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PPUSH
4476: CALL_OW 69
4480: PPUSH
4481: LD_VAR 0 2
4485: PPUSH
4486: CALL_OW 74
4490: PPUSH
4491: CALL_OW 115
4495: GO 4513
// tmp := tmp diff i ;
4497: LD_ADDR_VAR 0 3
4501: PUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_VAR 0 2
4511: DIFF
4512: ST_TO_ADDR
4513: GO 4447
4515: POP
4516: POP
// until not tmp ;
4517: LD_VAR 0 3
4521: NOT
4522: IFFALSE 4430
// end ;
4524: LD_VAR 0 1
4528: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4529: LD_EXP 8
4533: PUSH
4534: LD_INT 47
4536: PPUSH
4537: CALL_OW 302
4541: AND
4542: PUSH
4543: LD_INT 47
4545: PPUSH
4546: CALL_OW 255
4550: PUSH
4551: LD_INT 3
4553: EQUAL
4554: AND
4555: PUSH
4556: LD_EXP 6
4560: AND
4561: IFFALSE 4571
4563: GO 4565
4565: DISABLE
// begin enable ;
4566: ENABLE
// PrepareRussianAttack ;
4567: CALL 4091 0 0
// end ; end_of_file
4571: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4572: LD_INT 0
4574: PPUSH
4575: PPUSH
4576: PPUSH
4577: PPUSH
4578: PPUSH
4579: PPUSH
4580: PPUSH
4581: PPUSH
4582: PPUSH
// uc_side := 2 ;
4583: LD_ADDR_OWVAR 20
4587: PUSH
4588: LD_INT 2
4590: ST_TO_ADDR
// uc_nation := 2 ;
4591: LD_ADDR_OWVAR 21
4595: PUSH
4596: LD_INT 2
4598: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4599: LD_INT 2
4601: PPUSH
4602: LD_INT 28
4604: PPUSH
4605: CALL 59947 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4609: LD_INT 25
4611: PPUSH
4612: LD_INT 0
4614: PUSH
4615: LD_INT 0
4617: PUSH
4618: LD_INT 6
4620: PUSH
4621: LD_INT 8
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: PUSH
4630: LD_OWVAR 67
4634: ARRAY
4635: PPUSH
4636: CALL 8103 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4640: LD_INT 26
4642: PPUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 4
4648: PUSH
4649: LD_INT 8
4651: PUSH
4652: LD_INT 12
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: PUSH
4661: LD_OWVAR 67
4665: ARRAY
4666: PPUSH
4667: CALL 8103 0 2
// if Difficulty > 2 then
4671: LD_OWVAR 67
4675: PUSH
4676: LD_INT 2
4678: GREATER
4679: IFFALSE 4849
// begin bc_type := b_breastwork ;
4681: LD_ADDR_OWVAR 42
4685: PUSH
4686: LD_INT 31
4688: ST_TO_ADDR
// bc_level := 8 ;
4689: LD_ADDR_OWVAR 43
4693: PUSH
4694: LD_INT 8
4696: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4697: LD_ADDR_VAR 0 5
4701: PUSH
4702: LD_INT 27
4704: PUSH
4705: LD_INT 29
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4847
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4715: LD_ADDR_VAR 0 6
4719: PUSH
4720: LD_VAR 0 5
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: CALL 59547 0 2
4732: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4733: LD_ADDR_VAR 0 3
4737: PUSH
4738: LD_VAR 0 6
4742: PUSH
4743: LD_INT 1
4745: ARRAY
4746: PPUSH
4747: LD_VAR 0 6
4751: PUSH
4752: LD_INT 2
4754: ARRAY
4755: PPUSH
4756: LD_VAR 0 6
4760: PUSH
4761: LD_INT 3
4763: ARRAY
4764: PPUSH
4765: CALL_OW 47
4769: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_INT 5
4775: PUSH
4776: LD_OWVAR 67
4780: PLUS
4781: PPUSH
4782: CALL_OW 381
// un := CreateHuman ;
4786: LD_ADDR_VAR 0 8
4790: PUSH
4791: CALL_OW 44
4795: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4796: LD_VAR 0 8
4800: PPUSH
4801: LD_VAR 0 3
4805: PPUSH
4806: CALL_OW 254
4810: PUSH
4811: LD_INT 3
4813: MINUS
4814: PPUSH
4815: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4819: LD_VAR 0 8
4823: PPUSH
4824: LD_INT 5
4826: PPUSH
4827: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4831: LD_VAR 0 8
4835: PPUSH
4836: LD_VAR 0 3
4840: PPUSH
4841: CALL_OW 52
// end ;
4845: GO 4712
4847: POP
4848: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4849: LD_ADDR_EXP 58
4853: PUSH
4854: LD_STRING Abdul
4856: PPUSH
4857: CALL_OW 25
4861: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4862: LD_EXP 58
4866: PPUSH
4867: LD_INT 11
4869: PPUSH
4870: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4874: LD_EXP 58
4878: PPUSH
4879: LD_INT 1
4881: PPUSH
4882: CALL_OW 52
// vc_chassis := 31 ;
4886: LD_ADDR_OWVAR 37
4890: PUSH
4891: LD_INT 31
4893: ST_TO_ADDR
// vc_control := control_rider ;
4894: LD_ADDR_OWVAR 38
4898: PUSH
4899: LD_INT 4
4901: ST_TO_ADDR
// mastodont := CreateVehicle ;
4902: LD_ADDR_EXP 59
4906: PUSH
4907: CALL_OW 45
4911: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4912: LD_EXP 59
4916: PPUSH
4917: LD_INT 153
4919: PPUSH
4920: LD_INT 71
4922: PPUSH
4923: LD_INT 0
4925: PPUSH
4926: CALL_OW 48
// InitVc ;
4930: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4934: LD_ADDR_EXP 56
4938: PUSH
4939: LD_INT 1
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_STRING kaba
4947: PPUSH
4948: LD_INT 7
4950: PUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_OWVAR 67
4970: ARRAY
4971: PPUSH
4972: LD_INT 5000
4974: PUSH
4975: LD_INT 1000
4977: PUSH
4978: LD_INT 300
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: PPUSH
4986: LD_INT 11
4988: PUSH
4989: LD_INT 5
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 7
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL 25958 0 6
5008: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5009: LD_ADDR_EXP 63
5013: PUSH
5014: LD_EXP 63
5018: PPUSH
5019: LD_INT 1
5021: PPUSH
5022: LD_EXP 56
5026: PPUSH
5027: CALL_OW 1
5031: ST_TO_ADDR
// tmp := [ ] ;
5032: LD_ADDR_VAR 0 6
5036: PUSH
5037: EMPTY
5038: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5039: LD_ADDR_OWVAR 37
5043: PUSH
5044: LD_INT 13
5046: ST_TO_ADDR
// vc_engine := engine_siberite ;
5047: LD_ADDR_OWVAR 39
5051: PUSH
5052: LD_INT 3
5054: ST_TO_ADDR
// vc_control := control_manual ;
5055: LD_ADDR_OWVAR 38
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5063: LD_ADDR_OWVAR 40
5067: PUSH
5068: LD_INT 31
5070: ST_TO_ADDR
// for i = 1 to 3 do
5071: LD_ADDR_VAR 0 2
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 3
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5333
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5087: LD_ADDR_VAR 0 7
5091: PUSH
5092: LD_INT 153
5094: PUSH
5095: LD_INT 71
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: PUSH
5102: LD_INT 155
5104: PUSH
5105: LD_INT 81
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_VAR 0 2
5120: PUSH
5121: LD_INT 2
5123: MOD
5124: PUSH
5125: LD_INT 1
5127: PLUS
5128: ARRAY
5129: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5130: LD_INT 0
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: LD_INT 7
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: LD_INT 10
5144: PUSH
5145: LD_INT 10
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: PUSH
5154: LD_OWVAR 67
5158: ARRAY
5159: PPUSH
5160: CALL_OW 380
// un := CreateVehicle ;
5164: LD_ADDR_VAR 0 8
5168: PUSH
5169: CALL_OW 45
5173: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5174: LD_VAR 0 8
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: LD_INT 5
5184: PPUSH
5185: CALL_OW 12
5189: PPUSH
5190: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5194: LD_VAR 0 8
5198: PPUSH
5199: LD_VAR 0 7
5203: PUSH
5204: LD_INT 1
5206: ARRAY
5207: PPUSH
5208: LD_VAR 0 7
5212: PUSH
5213: LD_INT 2
5215: ARRAY
5216: PPUSH
5217: LD_INT 6
5219: PPUSH
5220: LD_INT 0
5222: PPUSH
5223: CALL_OW 50
// un2 := CreateHuman ;
5227: LD_ADDR_VAR 0 9
5231: PUSH
5232: CALL_OW 44
5236: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5237: LD_VAR 0 9
5241: PPUSH
5242: LD_VAR 0 8
5246: PPUSH
5247: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5251: LD_ADDR_EXP 63
5255: PUSH
5256: LD_EXP 63
5260: PPUSH
5261: LD_INT 1
5263: PUSH
5264: LD_EXP 63
5268: PUSH
5269: LD_INT 1
5271: ARRAY
5272: PUSH
5273: LD_INT 1
5275: PLUS
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PPUSH
5281: LD_VAR 0 8
5285: PPUSH
5286: CALL 22259 0 3
5290: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5291: LD_ADDR_EXP 63
5295: PUSH
5296: LD_EXP 63
5300: PPUSH
5301: LD_INT 1
5303: PUSH
5304: LD_EXP 63
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PUSH
5313: LD_INT 1
5315: PLUS
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PPUSH
5321: LD_VAR 0 9
5325: PPUSH
5326: CALL 22259 0 3
5330: ST_TO_ADDR
// end ;
5331: GO 5084
5333: POP
5334: POP
// for i = 1 to 5 do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 5
5347: PUSH
5348: FOR_TO
5349: IFFALSE 5442
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5351: LD_INT 13
5353: PPUSH
5354: LD_INT 3
5356: PPUSH
5357: LD_INT 1
5359: PPUSH
5360: LD_INT 25
5362: PUSH
5363: LD_INT 28
5365: PUSH
5366: LD_INT 28
5368: PUSH
5369: LD_INT 26
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PUSH
5378: LD_VAR 0 2
5382: PUSH
5383: LD_INT 4
5385: MOD
5386: PUSH
5387: LD_INT 1
5389: PLUS
5390: ARRAY
5391: PPUSH
5392: LD_INT 100
5394: PPUSH
5395: CALL 22137 0 5
// veh := CreateVehicle ;
5399: LD_ADDR_VAR 0 4
5403: PUSH
5404: CALL_OW 45
5408: ST_TO_ADDR
// tmp := tmp ^ veh ;
5409: LD_ADDR_VAR 0 6
5413: PUSH
5414: LD_VAR 0 6
5418: PUSH
5419: LD_VAR 0 4
5423: ADD
5424: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5425: LD_VAR 0 4
5429: PPUSH
5430: LD_INT 1
5432: PPUSH
5433: LD_INT 0
5435: PPUSH
5436: CALL_OW 49
// end ;
5440: GO 5348
5442: POP
5443: POP
// arabian_guard := tmp ;
5444: LD_ADDR_EXP 57
5448: PUSH
5449: LD_VAR 0 6
5453: ST_TO_ADDR
// end ;
5454: LD_VAR 0 1
5458: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5459: LD_INT 22
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 91
5471: PUSH
5472: LD_INT 1
5474: PUSH
5475: LD_INT 12
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PPUSH
5487: CALL_OW 69
5491: PUSH
5492: LD_EXP 59
5496: PPUSH
5497: CALL_OW 256
5501: PUSH
5502: LD_INT 990
5504: LESS
5505: OR
5506: PUSH
5507: LD_EXP 58
5511: PPUSH
5512: CALL_OW 256
5516: PUSH
5517: LD_INT 990
5519: LESS
5520: OR
5521: IFFALSE 5664
5523: GO 5525
5525: DISABLE
// begin if IsInUnit ( Abdul ) then
5526: LD_EXP 58
5530: PPUSH
5531: CALL_OW 310
5535: IFFALSE 5546
// ComExitBuilding ( Abdul ) ;
5537: LD_EXP 58
5541: PPUSH
5542: CALL_OW 122
// if Mastodont then
5546: LD_EXP 59
5550: IFFALSE 5567
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5552: LD_EXP 59
5556: PPUSH
5557: LD_INT 205
5559: PPUSH
5560: LD_INT 132
5562: PPUSH
5563: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5567: LD_EXP 58
5571: PPUSH
5572: LD_INT 205
5574: PPUSH
5575: LD_INT 132
5577: PPUSH
5578: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5582: LD_INT 35
5584: PPUSH
5585: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5589: LD_EXP 58
5593: PPUSH
5594: LD_INT 21
5596: PPUSH
5597: CALL_OW 308
5601: IFFALSE 5582
// RemoveUnit ( Abdul ) ;
5603: LD_EXP 58
5607: PPUSH
5608: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5612: LD_INT 35
5614: PPUSH
5615: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5619: LD_EXP 59
5623: PPUSH
5624: LD_INT 21
5626: PPUSH
5627: CALL_OW 308
5631: PUSH
5632: LD_EXP 59
5636: PPUSH
5637: CALL_OW 301
5641: OR
5642: IFFALSE 5612
// if IsOk ( Mastodont ) then
5644: LD_EXP 59
5648: PPUSH
5649: CALL_OW 302
5653: IFFALSE 5664
// RemoveUnit ( Mastodont ) ;
5655: LD_EXP 59
5659: PPUSH
5660: CALL_OW 64
// end ;
5664: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5665: LD_EXP 58
5669: PPUSH
5670: CALL_OW 301
5674: PUSH
5675: LD_INT 22
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 2
5687: PUSH
5688: LD_INT 25
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 25
5700: PUSH
5701: LD_INT 2
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 25
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 4
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 8
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: PPUSH
5750: CALL_OW 69
5754: PUSH
5755: LD_INT 16
5757: PUSH
5758: LD_INT 19
5760: PUSH
5761: LD_INT 22
5763: PUSH
5764: LD_INT 22
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_OWVAR 67
5777: ARRAY
5778: LESS
5779: OR
5780: IFFALSE 6453
5782: GO 5784
5784: DISABLE
5785: LD_INT 0
5787: PPUSH
5788: PPUSH
5789: PPUSH
5790: PPUSH
5791: PPUSH
5792: PPUSH
// begin MC_Kill ( 1 ) ;
5793: LD_INT 1
5795: PPUSH
5796: CALL 60349 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 22
5807: PUSH
5808: LD_INT 2
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 25
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: LD_INT 25
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: PUSH
5838: LD_INT 25
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 4
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 8
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: ST_TO_ADDR
// for i in tmp do
5885: LD_ADDR_VAR 0 5
5889: PUSH
5890: LD_VAR 0 2
5894: PUSH
5895: FOR_IN
5896: IFFALSE 5912
// SetTag ( i , 10 ) ;
5898: LD_VAR 0 5
5902: PPUSH
5903: LD_INT 10
5905: PPUSH
5906: CALL_OW 109
5910: GO 5895
5912: POP
5913: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_INT 22
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 21
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PUSH
5939: EMPTY
5940: LIST
5941: LIST
5942: PPUSH
5943: CALL_OW 69
5947: PUSH
5948: LD_VAR 0 2
5952: DIFF
5953: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_INT 22
5961: PUSH
5962: LD_INT 2
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: LD_INT 21
5971: PUSH
5972: LD_INT 2
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 24
5981: PUSH
5982: LD_INT 300
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 69
5998: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5999: LD_ADDR_VAR 0 4
6003: PUSH
6004: LD_VAR 0 1
6008: PPUSH
6009: LD_INT 33
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 58
6021: PUSH
6022: EMPTY
6023: LIST
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: PPUSH
6029: CALL_OW 72
6033: ST_TO_ADDR
// for i in tmp do
6034: LD_ADDR_VAR 0 5
6038: PUSH
6039: LD_VAR 0 2
6043: PUSH
6044: FOR_IN
6045: IFFALSE 6229
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6047: LD_VAR 0 5
6051: PUSH
6052: LD_INT 55
6054: PUSH
6055: EMPTY
6056: LIST
6057: PPUSH
6058: CALL_OW 69
6062: IN
6063: IFFALSE 6082
// begin AddComMoveXY ( i , 209 , 132 ) ;
6065: LD_VAR 0 5
6069: PPUSH
6070: LD_INT 209
6072: PPUSH
6073: LD_INT 132
6075: PPUSH
6076: CALL_OW 171
// continue ;
6080: GO 6044
// end ; if IsInUnit ( i ) then
6082: LD_VAR 0 5
6086: PPUSH
6087: CALL_OW 310
6091: IFFALSE 6109
// begin ComExitBuilding ( i ) ;
6093: LD_VAR 0 5
6097: PPUSH
6098: CALL_OW 122
// wait ( 3 ) ;
6102: LD_INT 3
6104: PPUSH
6105: CALL_OW 67
// end ; if tmp_empty then
6109: LD_VAR 0 4
6113: IFFALSE 6212
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6115: LD_VAR 0 5
6119: PPUSH
6120: LD_VAR 0 4
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL_OW 74
6134: PPUSH
6135: CALL_OW 296
6139: PUSH
6140: LD_INT 25
6142: LESS
6143: IFFALSE 6212
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6145: LD_ADDR_VAR 0 6
6149: PUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6179: LD_VAR 0 5
6183: PPUSH
6184: LD_INT 209
6186: PPUSH
6187: LD_INT 132
6189: PPUSH
6190: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6194: LD_ADDR_VAR 0 4
6198: PUSH
6199: LD_VAR 0 4
6203: PUSH
6204: LD_VAR 0 6
6208: DIFF
6209: ST_TO_ADDR
// continue ;
6210: GO 6044
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6212: LD_VAR 0 5
6216: PPUSH
6217: LD_INT 201
6219: PPUSH
6220: LD_INT 132
6222: PPUSH
6223: CALL_OW 171
// end ;
6227: GO 6044
6229: POP
6230: POP
// for i in tmp_ape do
6231: LD_ADDR_VAR 0 5
6235: PUSH
6236: LD_VAR 0 3
6240: PUSH
6241: FOR_IN
6242: IFFALSE 6281
// begin if IsInUnit ( i ) then
6244: LD_VAR 0 5
6248: PPUSH
6249: CALL_OW 310
6253: IFFALSE 6264
// ComExitBuilding ( i ) ;
6255: LD_VAR 0 5
6259: PPUSH
6260: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6264: LD_VAR 0 5
6268: PPUSH
6269: LD_INT 201
6271: PPUSH
6272: LD_INT 132
6274: PPUSH
6275: CALL_OW 171
// end ;
6279: GO 6241
6281: POP
6282: POP
// repeat wait ( 0 0$1 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6290: LD_ADDR_VAR 0 5
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: LD_VAR 0 3
6304: UNION
6305: PUSH
6306: LD_VAR 0 1
6310: UNION
6311: PUSH
6312: FOR_IN
6313: IFFALSE 6344
// if not HasTask ( i ) then
6315: LD_VAR 0 5
6319: PPUSH
6320: CALL_OW 314
6324: NOT
6325: IFFALSE 6342
// ComMoveXY ( i , 201 , 132 ) ;
6327: LD_VAR 0 5
6331: PPUSH
6332: LD_INT 201
6334: PPUSH
6335: LD_INT 132
6337: PPUSH
6338: CALL_OW 111
6342: GO 6312
6344: POP
6345: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6346: LD_INT 21
6348: PPUSH
6349: LD_INT 22
6351: PUSH
6352: LD_INT 2
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PPUSH
6359: CALL_OW 70
6363: IFFALSE 6404
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6365: LD_ADDR_VAR 0 5
6369: PUSH
6370: LD_INT 21
6372: PPUSH
6373: LD_INT 22
6375: PUSH
6376: LD_INT 2
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PPUSH
6383: CALL_OW 70
6387: PUSH
6388: FOR_IN
6389: IFFALSE 6402
// RemoveUnit ( i ) ;
6391: LD_VAR 0 5
6395: PPUSH
6396: CALL_OW 64
6400: GO 6388
6402: POP
6403: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6404: LD_INT 22
6406: PUSH
6407: LD_INT 2
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: LD_INT 2
6416: PUSH
6417: LD_INT 21
6419: PUSH
6420: LD_INT 1
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 21
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PPUSH
6446: CALL_OW 69
6450: NOT
6451: IFFALSE 6283
// end ;
6453: PPOPN 6
6455: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6456: LD_EXP 10
6460: PUSH
6461: LD_INT 92
6463: PPUSH
6464: LD_INT 40
6466: PPUSH
6467: CALL_OW 428
6471: PPUSH
6472: CALL_OW 266
6476: PUSH
6477: LD_INT 30
6479: EQUAL
6480: AND
6481: IFFALSE 6677
6483: GO 6485
6485: DISABLE
6486: LD_INT 0
6488: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6489: LD_ADDR_VAR 0 1
6493: PUSH
6494: LD_EXP 63
6498: PUSH
6499: LD_INT 1
6501: ARRAY
6502: PPUSH
6503: LD_INT 25
6505: PUSH
6506: LD_INT 4
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PPUSH
6513: CALL_OW 72
6517: ST_TO_ADDR
// if not sci then
6518: LD_VAR 0 1
6522: NOT
6523: IFFALSE 6527
// exit ;
6525: GO 6677
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6527: LD_ADDR_EXP 63
6531: PUSH
6532: LD_EXP 63
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_EXP 63
6544: PUSH
6545: LD_INT 1
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 1
6553: PUSH
6554: LD_INT 1
6556: ARRAY
6557: DIFF
6558: PPUSH
6559: CALL_OW 1
6563: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6564: LD_VAR 0 1
6568: PUSH
6569: LD_INT 1
6571: ARRAY
6572: PPUSH
6573: CALL_OW 310
6577: IFFALSE 6592
// ComExitBuilding ( sci [ 1 ] ) ;
6579: LD_VAR 0 1
6583: PUSH
6584: LD_INT 1
6586: ARRAY
6587: PPUSH
6588: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6592: LD_INT 2
6594: PPUSH
6595: LD_INT 105
6597: PPUSH
6598: LD_INT 14
6600: PPUSH
6601: LD_INT 20
6603: PPUSH
6604: CALL 23523 0 4
6608: PUSH
6609: LD_INT 4
6611: ARRAY
6612: PUSH
6613: LD_INT 10
6615: LESS
6616: IFFALSE 6639
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6618: LD_VAR 0 1
6622: PUSH
6623: LD_INT 1
6625: ARRAY
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: CALL_OW 171
6637: GO 6658
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6639: LD_VAR 0 1
6643: PUSH
6644: LD_INT 1
6646: ARRAY
6647: PPUSH
6648: LD_INT 118
6650: PPUSH
6651: LD_INT 77
6653: PPUSH
6654: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6658: LD_VAR 0 1
6662: PUSH
6663: LD_INT 1
6665: ARRAY
6666: PPUSH
6667: LD_INT 92
6669: PPUSH
6670: LD_INT 40
6672: PPUSH
6673: CALL_OW 218
// end ;
6677: PPOPN 1
6679: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6680: LD_INT 1
6682: PPUSH
6683: CALL_OW 302
6687: PUSH
6688: LD_EXP 10
6692: AND
6693: IFFALSE 7582
6695: GO 6697
6697: DISABLE
6698: LD_INT 0
6700: PPUSH
6701: PPUSH
6702: PPUSH
6703: PPUSH
6704: PPUSH
6705: PPUSH
6706: PPUSH
6707: PPUSH
// begin enable ;
6708: ENABLE
// base := 1 ;
6709: LD_ADDR_VAR 0 3
6713: PUSH
6714: LD_INT 1
6716: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6717: LD_ADDR_VAR 0 5
6721: PUSH
6722: LD_INT 0
6724: PUSH
6725: LD_INT 0
6727: PUSH
6728: LD_INT 0
6730: PUSH
6731: LD_INT 0
6733: PUSH
6734: LD_INT 0
6736: PUSH
6737: LD_INT 0
6739: PUSH
6740: LD_INT 0
6742: PUSH
6743: LD_INT 0
6745: PUSH
6746: LD_INT 1
6748: PUSH
6749: LD_INT 0
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6764: LD_ADDR_VAR 0 4
6768: PUSH
6769: LD_INT 13
6771: PUSH
6772: LD_INT 1
6774: PUSH
6775: LD_INT 2
6777: PUSH
6778: LD_INT 26
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 13
6789: PUSH
6790: LD_INT 1
6792: PUSH
6793: LD_INT 2
6795: PUSH
6796: LD_INT 28
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: PUSH
6805: LD_INT 13
6807: PUSH
6808: LD_INT 1
6810: PUSH
6811: LD_INT 2
6813: PUSH
6814: LD_INT 29
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: DOUBLE
6834: LD_INT 1
6836: DEC
6837: ST_TO_ADDR
6838: LD_OWVAR 67
6842: PUSH
6843: LD_OWVAR 1
6847: PUSH
6848: LD_INT 21000
6850: DIV
6851: PLUS
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6927
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6856: LD_ADDR_VAR 0 4
6860: PUSH
6861: LD_VAR 0 4
6865: PPUSH
6866: LD_VAR 0 4
6870: PUSH
6871: LD_INT 1
6873: PLUS
6874: PPUSH
6875: LD_INT 13
6877: PUSH
6878: LD_INT 1
6880: PUSH
6881: LD_INT 2
6883: PUSH
6884: LD_INT 28
6886: PUSH
6887: LD_INT 29
6889: PUSH
6890: LD_INT 25
6892: PUSH
6893: LD_INT 26
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: LIST
6900: LIST
6901: PUSH
6902: LD_INT 1
6904: PPUSH
6905: LD_INT 4
6907: PPUSH
6908: CALL_OW 12
6912: ARRAY
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 2
6924: ST_TO_ADDR
6925: GO 6853
6927: POP
6928: POP
// MC_InsertProduceList ( base , tmp ) ;
6929: LD_VAR 0 3
6933: PPUSH
6934: LD_VAR 0 4
6938: PPUSH
6939: CALL 84374 0 2
// wait ( 3 3$20 ) ;
6943: LD_INT 7000
6945: PPUSH
6946: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6950: LD_ADDR_VAR 0 6
6954: PUSH
6955: LD_INT 124
6957: PUSH
6958: LD_INT 85
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PUSH
6965: LD_INT 90
6967: PUSH
6968: LD_INT 61
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PUSH
6975: LD_INT 69
6977: PUSH
6978: LD_INT 48
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 68
6987: PUSH
6988: LD_INT 48
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: LIST
6999: LIST
7000: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7001: LD_ADDR_VAR 0 7
7005: PUSH
7006: LD_INT 22
7008: PUSH
7009: LD_INT 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: LD_INT 23
7018: PUSH
7019: LD_INT 2
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 21
7028: PUSH
7029: LD_INT 2
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: LD_INT 2
7041: PUSH
7042: LD_INT 34
7044: PUSH
7045: LD_INT 31
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 34
7054: PUSH
7055: LD_INT 88
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 34
7064: PUSH
7065: LD_INT 32
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PPUSH
7088: CALL_OW 69
7092: PUSH
7093: LD_EXP 82
7097: PUSH
7098: LD_VAR 0 3
7102: ARRAY
7103: PPUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 34
7109: PUSH
7110: LD_INT 32
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 34
7119: PUSH
7120: LD_INT 88
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: PPUSH
7132: CALL_OW 72
7136: DIFF
7137: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7138: LD_INT 0
7140: PPUSH
7141: LD_INT 1
7143: PPUSH
7144: CALL_OW 12
7148: IFFALSE 7298
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7150: LD_ADDR_VAR 0 1
7154: PUSH
7155: DOUBLE
7156: LD_INT 1
7158: DEC
7159: ST_TO_ADDR
7160: LD_INT 3
7162: PUSH
7163: LD_INT 4
7165: PUSH
7166: LD_INT 5
7168: PUSH
7169: LD_INT 6
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: PUSH
7178: LD_OWVAR 67
7182: ARRAY
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7294
// begin uc_side := 2 ;
7187: LD_ADDR_OWVAR 20
7191: PUSH
7192: LD_INT 2
7194: ST_TO_ADDR
// uc_nation := 2 ;
7195: LD_ADDR_OWVAR 21
7199: PUSH
7200: LD_INT 2
7202: ST_TO_ADDR
// InitHc ;
7203: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7207: LD_INT 0
7209: PPUSH
7210: LD_INT 15
7212: PUSH
7213: LD_INT 17
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 1
7222: PPUSH
7223: LD_INT 2
7225: PPUSH
7226: CALL_OW 12
7230: ARRAY
7231: PPUSH
7232: LD_INT 8
7234: PPUSH
7235: CALL_OW 380
// un := CreateHuman ;
7239: LD_ADDR_VAR 0 2
7243: PUSH
7244: CALL_OW 44
7248: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7249: LD_VAR 0 2
7253: PPUSH
7254: LD_INT 4
7256: PPUSH
7257: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_INT 23
7268: PPUSH
7269: LD_INT 0
7271: PPUSH
7272: CALL_OW 49
// attackers := attackers union un ;
7276: LD_ADDR_VAR 0 7
7280: PUSH
7281: LD_VAR 0 7
7285: PUSH
7286: LD_VAR 0 2
7290: UNION
7291: ST_TO_ADDR
// end ;
7292: GO 7184
7294: POP
7295: POP
// end else
7296: GO 7456
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7298: LD_ADDR_VAR 0 1
7302: PUSH
7303: DOUBLE
7304: LD_INT 1
7306: DEC
7307: ST_TO_ADDR
7308: LD_INT 2
7310: PUSH
7311: LD_INT 3
7313: PUSH
7314: LD_INT 4
7316: PUSH
7317: LD_INT 5
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PUSH
7326: LD_OWVAR 67
7330: ARRAY
7331: PUSH
7332: FOR_TO
7333: IFFALSE 7454
// begin uc_side := 2 ;
7335: LD_ADDR_OWVAR 20
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// uc_nation := 2 ;
7343: LD_ADDR_OWVAR 21
7347: PUSH
7348: LD_INT 2
7350: ST_TO_ADDR
// InitHc ;
7351: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7355: LD_INT 14
7357: PPUSH
7358: LD_INT 3
7360: PPUSH
7361: LD_INT 5
7363: PPUSH
7364: LD_INT 29
7366: PUSH
7367: LD_INT 29
7369: PUSH
7370: LD_INT 26
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_VAR 0 1
7382: PUSH
7383: LD_INT 3
7385: MOD
7386: PUSH
7387: LD_INT 1
7389: PLUS
7390: ARRAY
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL 22137 0 5
// un := CreateVehicle ;
7399: LD_ADDR_VAR 0 2
7403: PUSH
7404: CALL_OW 45
7408: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7409: LD_VAR 0 2
7413: PPUSH
7414: LD_INT 4
7416: PPUSH
7417: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7421: LD_VAR 0 2
7425: PPUSH
7426: LD_INT 23
7428: PPUSH
7429: LD_INT 0
7431: PPUSH
7432: CALL_OW 49
// attackers := attackers union un ;
7436: LD_ADDR_VAR 0 7
7440: PUSH
7441: LD_VAR 0 7
7445: PUSH
7446: LD_VAR 0 2
7450: UNION
7451: ST_TO_ADDR
// end ;
7452: GO 7332
7454: POP
7455: POP
// end ; if not attackers then
7456: LD_VAR 0 7
7460: NOT
7461: IFFALSE 7465
// exit ;
7463: GO 7582
// ar_attackers := attackers ;
7465: LD_ADDR_EXP 12
7469: PUSH
7470: LD_VAR 0 7
7474: ST_TO_ADDR
// p := 0 ;
7475: LD_ADDR_VAR 0 8
7479: PUSH
7480: LD_INT 0
7482: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7483: LD_INT 35
7485: PPUSH
7486: CALL_OW 67
// p := Inc ( p ) ;
7490: LD_ADDR_VAR 0 8
7494: PUSH
7495: LD_VAR 0 8
7499: PPUSH
7500: CALL 56369 0 1
7504: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7505: LD_VAR 0 7
7509: PPUSH
7510: LD_INT 60
7512: PUSH
7513: EMPTY
7514: LIST
7515: PPUSH
7516: CALL_OW 72
7520: NOT
7521: PUSH
7522: LD_VAR 0 8
7526: PUSH
7527: LD_INT 30
7529: GREATER
7530: OR
7531: IFFALSE 7483
// repeat wait ( 0 0$1 ) ;
7533: LD_INT 35
7535: PPUSH
7536: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7540: LD_ADDR_VAR 0 7
7544: PUSH
7545: LD_VAR 0 7
7549: PPUSH
7550: LD_INT 50
7552: PUSH
7553: EMPTY
7554: LIST
7555: PPUSH
7556: CALL_OW 72
7560: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7561: LD_VAR 0 7
7565: PPUSH
7566: LD_VAR 0 6
7570: PPUSH
7571: CALL 57612 0 2
// until not attackers ;
7575: LD_VAR 0 7
7579: NOT
7580: IFFALSE 7533
// end ;
7582: PPOPN 8
7584: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7585: LD_INT 1
7587: PPUSH
7588: CALL_OW 302
7592: PUSH
7593: LD_EXP 10
7597: AND
7598: PUSH
7599: LD_EXP 52
7603: PPUSH
7604: LD_INT 22
7606: PPUSH
7607: CALL_OW 308
7611: AND
7612: IFFALSE 8100
7614: GO 7616
7616: DISABLE
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// begin base := 1 ;
7627: LD_ADDR_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7635: LD_ADDR_VAR 0 4
7639: PUSH
7640: LD_INT 0
7642: PUSH
7643: LD_INT 0
7645: PUSH
7646: LD_INT 0
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: LD_INT 0
7654: PUSH
7655: LD_INT 0
7657: PUSH
7658: LD_INT 0
7660: PUSH
7661: LD_INT 0
7663: PUSH
7664: LD_INT 1
7666: PUSH
7667: LD_INT 0
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 13
7689: PUSH
7690: LD_INT 1
7692: PUSH
7693: LD_INT 2
7695: PUSH
7696: LD_INT 28
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: PUSH
7705: LD_INT 13
7707: PUSH
7708: LD_INT 1
7710: PUSH
7711: LD_INT 2
7713: PUSH
7714: LD_INT 27
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 13
7725: PUSH
7726: LD_INT 1
7728: PUSH
7729: LD_INT 2
7731: PUSH
7732: LD_INT 25
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 11
7743: PUSH
7744: LD_INT 2
7746: PUSH
7747: LD_INT 2
7749: PUSH
7750: LD_INT 24
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 11
7761: PUSH
7762: LD_INT 2
7764: PUSH
7765: LD_INT 2
7767: PUSH
7768: LD_INT 24
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7784: LD_VAR 0 2
7788: PPUSH
7789: LD_VAR 0 3
7793: PPUSH
7794: CALL 84374 0 2
// wait ( 4 4$20 ) ;
7798: LD_INT 9100
7800: PPUSH
7801: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7805: LD_ADDR_VAR 0 5
7809: PUSH
7810: LD_INT 119
7812: PUSH
7813: LD_INT 9
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: EMPTY
7821: LIST
7822: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7823: LD_ADDR_VAR 0 6
7827: PUSH
7828: LD_EXP 82
7832: PUSH
7833: LD_VAR 0 2
7837: ARRAY
7838: PUSH
7839: LD_EXP 82
7843: PUSH
7844: LD_VAR 0 2
7848: ARRAY
7849: PPUSH
7850: LD_INT 2
7852: PUSH
7853: LD_INT 34
7855: PUSH
7856: LD_INT 32
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 34
7865: PUSH
7866: LD_INT 88
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: DIFF
7883: ST_TO_ADDR
// uc_side := 2 ;
7884: LD_ADDR_OWVAR 20
7888: PUSH
7889: LD_INT 2
7891: ST_TO_ADDR
// uc_nation := 2 ;
7892: LD_ADDR_OWVAR 21
7896: PUSH
7897: LD_INT 2
7899: ST_TO_ADDR
// InitHc ;
7900: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: DOUBLE
7910: LD_INT 1
7912: DEC
7913: ST_TO_ADDR
7914: LD_INT 4
7916: PUSH
7917: LD_INT 5
7919: PUSH
7920: LD_INT 6
7922: PUSH
7923: LD_INT 6
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: PUSH
7932: LD_OWVAR 67
7936: ARRAY
7937: PUSH
7938: FOR_TO
7939: IFFALSE 8016
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7941: LD_INT 0
7943: PPUSH
7944: LD_INT 15
7946: PUSH
7947: LD_INT 17
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: LD_INT 1
7956: PPUSH
7957: LD_INT 2
7959: PPUSH
7960: CALL_OW 12
7964: ARRAY
7965: PPUSH
7966: LD_INT 8
7968: PPUSH
7969: CALL_OW 380
// un := CreateHuman ;
7973: LD_ADDR_VAR 0 7
7977: PUSH
7978: CALL_OW 44
7982: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7983: LD_VAR 0 7
7987: PPUSH
7988: LD_INT 23
7990: PPUSH
7991: LD_INT 0
7993: PPUSH
7994: CALL_OW 49
// attackers := attackers union un ;
7998: LD_ADDR_VAR 0 6
8002: PUSH
8003: LD_VAR 0 6
8007: PUSH
8008: LD_VAR 0 7
8012: UNION
8013: ST_TO_ADDR
// end ;
8014: GO 7938
8016: POP
8017: POP
// p := 0 ;
8018: LD_ADDR_VAR 0 8
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// p := Inc ( p ) ;
8033: LD_ADDR_VAR 0 8
8037: PUSH
8038: LD_VAR 0 8
8042: PPUSH
8043: CALL 56369 0 1
8047: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8048: LD_VAR 0 6
8052: PPUSH
8053: LD_INT 60
8055: PUSH
8056: EMPTY
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: NOT
8064: PUSH
8065: LD_VAR 0 8
8069: PUSH
8070: LD_INT 30
8072: GREATER
8073: OR
8074: IFFALSE 8026
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8076: LD_VAR 0 2
8080: PPUSH
8081: LD_VAR 0 6
8085: PPUSH
8086: LD_VAR 0 5
8090: PPUSH
8091: LD_VAR 0 4
8095: PPUSH
8096: CALL 84559 0 4
// end ;
8100: PPOPN 8
8102: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8103: LD_INT 0
8105: PPUSH
8106: PPUSH
8107: PPUSH
8108: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8109: LD_ADDR_VAR 0 5
8113: PUSH
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_INT 0
8121: PPUSH
8122: CALL_OW 517
8126: ST_TO_ADDR
// if not tmp then
8127: LD_VAR 0 5
8131: NOT
8132: IFFALSE 8136
// exit ;
8134: GO 8386
// arMinesList := arMinesList diff 0 ;
8136: LD_ADDR_EXP 60
8140: PUSH
8141: LD_EXP 60
8145: PUSH
8146: LD_INT 0
8148: DIFF
8149: ST_TO_ADDR
// for i := 1 to n do
8150: LD_ADDR_VAR 0 4
8154: PUSH
8155: DOUBLE
8156: LD_INT 1
8158: DEC
8159: ST_TO_ADDR
8160: LD_VAR 0 2
8164: PUSH
8165: FOR_TO
8166: IFFALSE 8384
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8168: LD_ADDR_VAR 0 6
8172: PUSH
8173: LD_INT 1
8175: PPUSH
8176: LD_VAR 0 5
8180: PUSH
8181: LD_INT 1
8183: ARRAY
8184: PPUSH
8185: CALL_OW 12
8189: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8190: LD_VAR 0 5
8194: PUSH
8195: LD_INT 1
8197: ARRAY
8198: PUSH
8199: LD_VAR 0 6
8203: ARRAY
8204: PPUSH
8205: LD_VAR 0 5
8209: PUSH
8210: LD_INT 2
8212: ARRAY
8213: PUSH
8214: LD_VAR 0 6
8218: ARRAY
8219: PPUSH
8220: LD_INT 2
8222: PPUSH
8223: LD_INT 0
8225: PPUSH
8226: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8230: LD_ADDR_EXP 60
8234: PUSH
8235: LD_EXP 60
8239: PPUSH
8240: LD_EXP 60
8244: PUSH
8245: LD_INT 1
8247: PLUS
8248: PPUSH
8249: LD_VAR 0 5
8253: PUSH
8254: LD_INT 1
8256: ARRAY
8257: PUSH
8258: LD_VAR 0 6
8262: ARRAY
8263: PPUSH
8264: CALL_OW 2
8268: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8269: LD_ADDR_EXP 60
8273: PUSH
8274: LD_EXP 60
8278: PPUSH
8279: LD_EXP 60
8283: PUSH
8284: LD_INT 1
8286: PLUS
8287: PPUSH
8288: LD_VAR 0 5
8292: PUSH
8293: LD_INT 2
8295: ARRAY
8296: PUSH
8297: LD_VAR 0 6
8301: ARRAY
8302: PPUSH
8303: CALL_OW 2
8307: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8308: LD_ADDR_VAR 0 5
8312: PUSH
8313: LD_VAR 0 5
8317: PPUSH
8318: LD_INT 1
8320: PPUSH
8321: LD_VAR 0 5
8325: PUSH
8326: LD_INT 1
8328: ARRAY
8329: PPUSH
8330: LD_VAR 0 6
8334: PPUSH
8335: CALL_OW 3
8339: PPUSH
8340: CALL_OW 1
8344: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8345: LD_ADDR_VAR 0 5
8349: PUSH
8350: LD_VAR 0 5
8354: PPUSH
8355: LD_INT 2
8357: PPUSH
8358: LD_VAR 0 5
8362: PUSH
8363: LD_INT 2
8365: ARRAY
8366: PPUSH
8367: LD_VAR 0 6
8371: PPUSH
8372: CALL_OW 3
8376: PPUSH
8377: CALL_OW 1
8381: ST_TO_ADDR
// end ;
8382: GO 8165
8384: POP
8385: POP
// end ;
8386: LD_VAR 0 3
8390: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8391: LD_EXP 60
8395: IFFALSE 8624
8397: GO 8399
8399: DISABLE
8400: LD_INT 0
8402: PPUSH
8403: PPUSH
8404: PPUSH
8405: PPUSH
// begin enable ;
8406: ENABLE
// p := 1 ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_INT 1
8414: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8415: LD_ADDR_VAR 0 1
8419: PUSH
8420: DOUBLE
8421: LD_INT 1
8423: DEC
8424: ST_TO_ADDR
8425: LD_EXP 60
8429: PPUSH
8430: CALL 19399 0 1
8434: PUSH
8435: LD_INT 2
8437: DIV
8438: PUSH
8439: FOR_TO
8440: IFFALSE 8622
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8442: LD_ADDR_VAR 0 3
8446: PUSH
8447: LD_EXP 60
8451: PUSH
8452: LD_VAR 0 2
8456: ARRAY
8457: PPUSH
8458: LD_EXP 60
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: LD_INT 1
8470: PLUS
8471: ARRAY
8472: PPUSH
8473: CALL_OW 428
8477: ST_TO_ADDR
// if tmp then
8478: LD_VAR 0 3
8482: IFFALSE 8606
// begin side := GetSide ( tmp ) ;
8484: LD_ADDR_VAR 0 4
8488: PUSH
8489: LD_VAR 0 3
8493: PPUSH
8494: CALL_OW 255
8498: ST_TO_ADDR
// if side <> 2 and side > 0 then
8499: LD_VAR 0 4
8503: PUSH
8504: LD_INT 2
8506: NONEQUAL
8507: PUSH
8508: LD_VAR 0 4
8512: PUSH
8513: LD_INT 0
8515: GREATER
8516: AND
8517: IFFALSE 8606
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8519: LD_EXP 60
8523: PUSH
8524: LD_VAR 0 2
8528: ARRAY
8529: PPUSH
8530: LD_EXP 60
8534: PUSH
8535: LD_VAR 0 2
8539: PUSH
8540: LD_INT 1
8542: PLUS
8543: ARRAY
8544: PPUSH
8545: LD_INT 2
8547: PPUSH
8548: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8552: LD_ADDR_EXP 60
8556: PUSH
8557: LD_EXP 60
8561: PPUSH
8562: LD_VAR 0 2
8566: PPUSH
8567: CALL_OW 3
8571: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8572: LD_ADDR_EXP 60
8576: PUSH
8577: LD_EXP 60
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 3
8591: ST_TO_ADDR
// p := p - 2 ;
8592: LD_ADDR_VAR 0 2
8596: PUSH
8597: LD_VAR 0 2
8601: PUSH
8602: LD_INT 2
8604: MINUS
8605: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8606: LD_ADDR_VAR 0 2
8610: PUSH
8611: LD_VAR 0 2
8615: PUSH
8616: LD_INT 2
8618: PLUS
8619: ST_TO_ADDR
// end ;
8620: GO 8439
8622: POP
8623: POP
// end ; end_of_file
8624: PPOPN 4
8626: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8627: LD_INT 0
8629: PPUSH
8630: PPUSH
8631: PPUSH
8632: PPUSH
8633: PPUSH
8634: PPUSH
// uc_side := 1 ;
8635: LD_ADDR_OWVAR 20
8639: PUSH
8640: LD_INT 1
8642: ST_TO_ADDR
// uc_nation := 1 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 1
8650: ST_TO_ADDR
// InitHc ;
8651: CALL_OW 19
// InitVc ;
8655: CALL_OW 20
// tmp := [ ] ;
8659: LD_ADDR_VAR 0 3
8663: PUSH
8664: EMPTY
8665: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: DOUBLE
8672: LD_INT 1
8674: DEC
8675: ST_TO_ADDR
8676: LD_INT 6
8678: PUSH
8679: LD_INT 8
8681: PUSH
8682: LD_INT 10
8684: PUSH
8685: LD_INT 10
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: LIST
8693: PUSH
8694: LD_OWVAR 67
8698: ARRAY
8699: PUSH
8700: FOR_TO
8701: IFFALSE 8991
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8703: LD_ADDR_VAR 0 5
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 4
8713: PUSH
8714: LD_INT 5
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 3
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8734: LD_VAR 0 5
8738: PUSH
8739: LD_INT 2
8741: DOUBLE
8742: EQUAL
8743: IFTRUE 8747
8745: GO 8781
8747: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8748: LD_ADDR_VAR 0 6
8752: PUSH
8753: LD_INT 9
8755: PUSH
8756: LD_INT 5
8758: PUSH
8759: LD_INT 7
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_INT 1
8769: PPUSH
8770: LD_INT 3
8772: PPUSH
8773: CALL_OW 12
8777: ARRAY
8778: ST_TO_ADDR
8779: GO 8870
8781: LD_INT 4
8783: DOUBLE
8784: EQUAL
8785: IFTRUE 8789
8787: GO 8827
8789: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8790: LD_ADDR_VAR 0 6
8794: PUSH
8795: LD_INT 9
8797: PUSH
8798: LD_INT 6
8800: PUSH
8801: LD_INT 6
8803: PUSH
8804: LD_INT 7
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 4
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: ST_TO_ADDR
8825: GO 8870
8827: LD_INT 5
8829: DOUBLE
8830: EQUAL
8831: IFTRUE 8835
8833: GO 8869
8835: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8836: LD_ADDR_VAR 0 6
8840: PUSH
8841: LD_INT 9
8843: PUSH
8844: LD_INT 6
8846: PUSH
8847: LD_INT 7
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 1
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: CALL_OW 12
8865: ARRAY
8866: ST_TO_ADDR
8867: GO 8870
8869: POP
// uc_side := 1 ;
8870: LD_ADDR_OWVAR 20
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// uc_nation := 1 ;
8878: LD_ADDR_OWVAR 21
8882: PUSH
8883: LD_INT 1
8885: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8886: LD_VAR 0 5
8890: PPUSH
8891: LD_INT 1
8893: PUSH
8894: LD_INT 3
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 2
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 3
8915: PPUSH
8916: LD_VAR 0 6
8920: PPUSH
8921: LD_INT 70
8923: PPUSH
8924: LD_INT 90
8926: PPUSH
8927: CALL_OW 12
8931: PPUSH
8932: CALL 22137 0 5
// veh := CreateVehicle ;
8936: LD_ADDR_VAR 0 4
8940: PUSH
8941: CALL_OW 45
8945: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8946: LD_VAR 0 4
8950: PPUSH
8951: LD_INT 2
8953: PPUSH
8954: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8958: LD_VAR 0 4
8962: PPUSH
8963: LD_INT 17
8965: PPUSH
8966: LD_INT 0
8968: PPUSH
8969: CALL_OW 49
// tmp := tmp ^ veh ;
8973: LD_ADDR_VAR 0 3
8977: PUSH
8978: LD_VAR 0 3
8982: PUSH
8983: LD_VAR 0 4
8987: ADD
8988: ST_TO_ADDR
// end ;
8989: GO 8700
8991: POP
8992: POP
// if not tmp then
8993: LD_VAR 0 3
8997: NOT
8998: IFFALSE 9002
// exit ;
9000: GO 9111
// if not first_powell_attack then
9002: LD_EXP 13
9006: NOT
9007: IFFALSE 9017
// first_powell_attack := true ;
9009: LD_ADDR_EXP 13
9013: PUSH
9014: LD_INT 1
9016: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9017: LD_INT 70
9019: PPUSH
9020: CALL_OW 67
// for i in tmp do
9024: LD_ADDR_VAR 0 2
9028: PUSH
9029: LD_VAR 0 3
9033: PUSH
9034: FOR_IN
9035: IFFALSE 9102
// if IsOk ( i ) then
9037: LD_VAR 0 2
9041: PPUSH
9042: CALL_OW 302
9046: IFFALSE 9084
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9048: LD_VAR 0 2
9052: PPUSH
9053: LD_INT 81
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PPUSH
9063: CALL_OW 69
9067: PPUSH
9068: LD_VAR 0 2
9072: PPUSH
9073: CALL_OW 74
9077: PPUSH
9078: CALL_OW 115
9082: GO 9100
// tmp := tmp diff i ;
9084: LD_ADDR_VAR 0 3
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: LD_VAR 0 2
9098: DIFF
9099: ST_TO_ADDR
9100: GO 9034
9102: POP
9103: POP
// until not tmp ;
9104: LD_VAR 0 3
9108: NOT
9109: IFFALSE 9017
// end ;
9111: LD_VAR 0 1
9115: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9116: LD_INT 0
9118: PPUSH
9119: PPUSH
// uc_side := 1 ;
9120: LD_ADDR_OWVAR 20
9124: PUSH
9125: LD_INT 1
9127: ST_TO_ADDR
// uc_nation := 1 ;
9128: LD_ADDR_OWVAR 21
9132: PUSH
9133: LD_INT 1
9135: ST_TO_ADDR
// InitHc ;
9136: CALL_OW 19
// InitVc ;
9140: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9144: LD_INT 5
9146: PPUSH
9147: LD_INT 3
9149: PPUSH
9150: LD_INT 3
9152: PPUSH
9153: LD_INT 12
9155: PPUSH
9156: LD_INT 100
9158: PPUSH
9159: CALL 22137 0 5
// veh := CreateVehicle ;
9163: LD_ADDR_VAR 0 3
9167: PUSH
9168: CALL_OW 45
9172: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9173: LD_VAR 0 3
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9185: LD_VAR 0 3
9189: PPUSH
9190: LD_INT 17
9192: PPUSH
9193: LD_INT 0
9195: PPUSH
9196: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9200: LD_VAR 0 3
9204: PPUSH
9205: LD_VAR 0 1
9209: PUSH
9210: LD_INT 1
9212: ARRAY
9213: PPUSH
9214: LD_VAR 0 1
9218: PUSH
9219: LD_INT 2
9221: ARRAY
9222: PPUSH
9223: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9227: LD_VAR 0 3
9231: PPUSH
9232: LD_INT 59
9234: PPUSH
9235: LD_INT 2
9237: PPUSH
9238: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9242: LD_INT 35
9244: PPUSH
9245: CALL_OW 67
// if not IsOk ( veh ) then
9249: LD_VAR 0 3
9253: PPUSH
9254: CALL_OW 302
9258: NOT
9259: IFFALSE 9263
// exit ;
9261: GO 9317
// until IsAt ( veh , 59 , 2 ) ;
9263: LD_VAR 0 3
9267: PPUSH
9268: LD_INT 59
9270: PPUSH
9271: LD_INT 2
9273: PPUSH
9274: CALL_OW 307
9278: IFFALSE 9242
// RemoveUnit ( veh ) ;
9280: LD_VAR 0 3
9284: PPUSH
9285: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9289: LD_VAR 0 3
9293: PPUSH
9294: LD_INT 4
9296: PPUSH
9297: CALL_OW 289
9301: IFFALSE 9317
// begin wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// YouLost ( Artifact ) ;
9310: LD_STRING Artifact
9312: PPUSH
9313: CALL_OW 104
// end ; end ; end_of_file
9317: LD_VAR 0 2
9321: RET
// export function Action ; var tmp , i , un ; begin
9322: LD_INT 0
9324: PPUSH
9325: PPUSH
9326: PPUSH
9327: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9328: LD_INT 68
9330: PPUSH
9331: LD_INT 39
9333: PPUSH
9334: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9338: LD_ADDR_VAR 0 2
9342: PUSH
9343: LD_INT 22
9345: PUSH
9346: LD_INT 7
9348: PUSH
9349: EMPTY
9350: LIST
9351: LIST
9352: PPUSH
9353: CALL_OW 69
9357: ST_TO_ADDR
// InGameOn ;
9358: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_INT 71
9369: PPUSH
9370: LD_INT 49
9372: PPUSH
9373: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9377: LD_INT 35
9379: PPUSH
9380: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9384: LD_INT 7
9386: PPUSH
9387: LD_INT 71
9389: PPUSH
9390: LD_INT 51
9392: PPUSH
9393: CALL_OW 293
9397: IFFALSE 9377
// DialogueOn ;
9399: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9403: LD_EXP 17
9407: PPUSH
9408: LD_STRING D1-JMM-1
9410: PPUSH
9411: CALL_OW 88
// if Joan then
9415: LD_EXP 32
9419: IFFALSE 9433
// Say ( Joan , D1-Joan-1 ) ;
9421: LD_EXP 32
9425: PPUSH
9426: LD_STRING D1-Joan-1
9428: PPUSH
9429: CALL_OW 88
// if Lisa then
9433: LD_EXP 19
9437: IFFALSE 9451
// Say ( Lisa , D1-Lisa-1 ) ;
9439: LD_EXP 19
9443: PPUSH
9444: LD_STRING D1-Lisa-1
9446: PPUSH
9447: CALL_OW 88
// if Joan or Lisa then
9451: LD_EXP 32
9455: PUSH
9456: LD_EXP 19
9460: OR
9461: IFFALSE 9475
// Say ( JMM , D1-JMM-2 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-2
9470: PPUSH
9471: CALL_OW 88
// DialogueOff ;
9475: CALL_OW 7
// InGameOff ;
9479: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9483: LD_INT 71
9485: PPUSH
9486: LD_INT 50
9488: PPUSH
9489: LD_INT 7
9491: PPUSH
9492: LD_INT 30
9494: NEG
9495: PPUSH
9496: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9500: LD_INT 71
9502: PPUSH
9503: LD_INT 50
9505: PPUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9513: LD_STRING M1
9515: PPUSH
9516: CALL_OW 337
// SaveForQuickRestart ;
9520: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9524: LD_INT 35
9526: PPUSH
9527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9531: LD_EXP 3
9535: PUSH
9536: LD_OWVAR 1
9540: PUSH
9541: LD_INT 2100
9543: GREATER
9544: OR
9545: IFFALSE 9524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9547: LD_INT 350
9549: PPUSH
9550: LD_INT 700
9552: PPUSH
9553: CALL_OW 12
9557: PPUSH
9558: CALL_OW 67
// PrepareGossudarov ;
9562: CALL 1943 0 0
// repeat wait ( 0 0$1 ) ;
9566: LD_INT 35
9568: PPUSH
9569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9573: LD_INT 22
9575: PUSH
9576: LD_INT 6
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 1000
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PPUSH
9604: CALL_OW 69
9608: PUSH
9609: LD_INT 7
9611: PPUSH
9612: LD_EXP 35
9616: PPUSH
9617: CALL_OW 292
9621: OR
9622: IFFALSE 9566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9624: LD_ADDR_VAR 0 2
9628: PUSH
9629: LD_INT 22
9631: PUSH
9632: LD_INT 6
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PPUSH
9639: CALL_OW 69
9643: ST_TO_ADDR
// for i in tmp do
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 2
9653: PUSH
9654: FOR_IN
9655: IFFALSE 9671
// SetSide ( i , 7 ) ;
9657: LD_VAR 0 3
9661: PPUSH
9662: LD_INT 7
9664: PPUSH
9665: CALL_OW 235
9669: GO 9654
9671: POP
9672: POP
// DialogueOn ;
9673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9677: LD_EXP 17
9681: PUSH
9682: LD_EXP 18
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: LD_EXP 35
9695: PPUSH
9696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9700: LD_EXP 35
9704: PPUSH
9705: CALL_OW 87
// if not Roth then
9709: LD_EXP 18
9713: NOT
9714: IFFALSE 9806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9716: LD_VAR 0 2
9720: PPUSH
9721: LD_INT 3
9723: PUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 1000
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 72
9742: IFFALSE 9756
// Say ( JMM , D2-JMM-1 ) ;
9744: LD_EXP 17
9748: PPUSH
9749: LD_STRING D2-JMM-1
9751: PPUSH
9752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9756: LD_EXP 17
9760: PPUSH
9761: LD_STRING D2-JMM-1b
9763: PPUSH
9764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9768: LD_EXP 35
9772: PPUSH
9773: LD_STRING D2-Gos-1
9775: PPUSH
9776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9780: LD_EXP 17
9784: PPUSH
9785: LD_STRING D2-JMM-2
9787: PPUSH
9788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9792: LD_EXP 35
9796: PPUSH
9797: LD_STRING D2-Gos-2
9799: PPUSH
9800: CALL_OW 88
// end else
9804: GO 9958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9806: LD_VAR 0 2
9810: PPUSH
9811: LD_INT 3
9813: PUSH
9814: LD_INT 24
9816: PUSH
9817: LD_INT 1000
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PPUSH
9828: CALL_OW 72
9832: IFFALSE 9858
// begin Say ( Roth , D2-Roth-2 ) ;
9834: LD_EXP 18
9838: PPUSH
9839: LD_STRING D2-Roth-2
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-1a
9853: PPUSH
9854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9858: LD_EXP 18
9862: PPUSH
9863: LD_STRING D2-Roth-2a
9865: PPUSH
9866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9870: LD_EXP 18
9874: PPUSH
9875: LD_STRING D2-Roth-2b
9877: PPUSH
9878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9882: LD_EXP 17
9886: PPUSH
9887: LD_STRING D2-JMM-3
9889: PPUSH
9890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9894: LD_VAR 0 2
9898: PPUSH
9899: LD_INT 3
9901: PUSH
9902: LD_INT 24
9904: PUSH
9905: LD_INT 1000
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PPUSH
9916: CALL_OW 72
9920: IFFALSE 9958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9922: LD_EXP 35
9926: PPUSH
9927: LD_STRING D2-Gos-3
9929: PPUSH
9930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9934: LD_EXP 17
9938: PPUSH
9939: LD_STRING D2-JMM-4
9941: PPUSH
9942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9946: LD_EXP 35
9950: PPUSH
9951: LD_STRING D2-Gos-4
9953: PPUSH
9954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9958: LD_EXP 17
9962: PPUSH
9963: LD_STRING D2-JMM-5
9965: PPUSH
9966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9970: LD_EXP 35
9974: PPUSH
9975: LD_STRING D2-Gos-5
9977: PPUSH
9978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9982: LD_EXP 17
9986: PPUSH
9987: LD_STRING D2-JMM-6
9989: PPUSH
9990: CALL_OW 88
// DialogueOff ;
9994: CALL_OW 7
// wait ( 0 0$2 ) ;
9998: LD_INT 70
10000: PPUSH
10001: CALL_OW 67
// if Kirilenkova then
10005: LD_EXP 36
10009: IFFALSE 10023
// Say ( Kirilenkova , D3-Kir-1 ) ;
10011: LD_EXP 36
10015: PPUSH
10016: LD_STRING D3-Kir-1
10018: PPUSH
10019: CALL_OW 88
// gossudarov_arrive := true ;
10023: LD_ADDR_EXP 4
10027: PUSH
10028: LD_INT 1
10030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10031: LD_INT 35
10033: PPUSH
10034: CALL_OW 67
// until ru_lab_builded ;
10038: LD_EXP 5
10042: IFFALSE 10031
// DialogueOn ;
10044: CALL_OW 6
// if Kirilenkova then
10048: LD_EXP 36
10052: IFFALSE 10068
// Say ( Kirilenkova , D3a-Kir-1 ) else
10054: LD_EXP 36
10058: PPUSH
10059: LD_STRING D3a-Kir-1
10061: PPUSH
10062: CALL_OW 88
10066: GO 10090
// begin un := SciRu ;
10068: LD_ADDR_VAR 0 4
10072: PUSH
10073: CALL 15630 0 0
10077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10078: LD_VAR 0 4
10082: PPUSH
10083: LD_STRING D3a-Sci1-1
10085: PPUSH
10086: CALL_OW 88
// end ; if Kirilenkova or un then
10090: LD_EXP 36
10094: PUSH
10095: LD_VAR 0 4
10099: OR
10100: IFFALSE 10114
// Say ( JMM , D3a-JMM-1 ) ;
10102: LD_EXP 17
10106: PPUSH
10107: LD_STRING D3a-JMM-1
10109: PPUSH
10110: CALL_OW 88
// DialogueOff ;
10114: CALL_OW 7
// end ;
10118: LD_VAR 0 1
10122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10123: LD_EXP 4
10127: PUSH
10128: LD_INT 22
10130: PUSH
10131: LD_INT 7
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 2
10140: PUSH
10141: LD_INT 25
10143: PUSH
10144: LD_INT 1
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 25
10153: PUSH
10154: LD_INT 2
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: LD_INT 25
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 25
10173: PUSH
10174: LD_INT 4
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PUSH
10181: LD_INT 25
10183: PUSH
10184: LD_INT 5
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 25
10193: PUSH
10194: LD_INT 8
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: LD_INT 25
10203: PUSH
10204: LD_INT 9
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PPUSH
10225: CALL_OW 69
10229: PUSH
10230: LD_INT 7
10232: LESS
10233: AND
10234: IFFALSE 10246
10236: GO 10238
10238: DISABLE
// YouLost ( TooMany ) ;
10239: LD_STRING TooMany
10241: PPUSH
10242: CALL_OW 104
10246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10247: LD_EXP 35
10251: PPUSH
10252: CALL_OW 255
10256: PUSH
10257: LD_INT 7
10259: EQUAL
10260: IFFALSE 10477
10262: GO 10264
10264: DISABLE
10265: LD_INT 0
10267: PPUSH
10268: PPUSH
10269: PPUSH
// begin uc_side := 3 ;
10270: LD_ADDR_OWVAR 20
10274: PUSH
10275: LD_INT 3
10277: ST_TO_ADDR
// uc_nation := 3 ;
10278: LD_ADDR_OWVAR 21
10282: PUSH
10283: LD_INT 3
10285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10286: LD_INT 21
10288: PPUSH
10289: LD_INT 3
10291: PPUSH
10292: LD_INT 3
10294: PPUSH
10295: LD_INT 42
10297: PPUSH
10298: LD_INT 100
10300: PPUSH
10301: CALL 22137 0 5
// un := CreateVehicle ;
10305: LD_ADDR_VAR 0 3
10309: PUSH
10310: CALL_OW 45
10314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_INT 15
10322: PPUSH
10323: LD_INT 0
10325: PPUSH
10326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10330: LD_VAR 0 3
10334: PPUSH
10335: LD_INT 67
10337: PPUSH
10338: LD_INT 45
10340: PPUSH
10341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10345: LD_VAR 0 3
10349: PPUSH
10350: LD_INT 70
10352: PPUSH
10353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 69
10364: PPUSH
10365: LD_INT 18
10367: PPUSH
10368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10372: LD_VAR 0 3
10376: PPUSH
10377: LD_INT 60
10379: PPUSH
10380: LD_INT 3
10382: PPUSH
10383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10387: LD_INT 35
10389: PPUSH
10390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10394: LD_VAR 0 3
10398: PPUSH
10399: CALL_OW 302
10403: NOT
10404: PUSH
10405: LD_VAR 0 3
10409: PPUSH
10410: LD_INT 17
10412: PPUSH
10413: CALL_OW 308
10417: OR
10418: PUSH
10419: LD_VAR 0 3
10423: PPUSH
10424: LD_INT 60
10426: PPUSH
10427: LD_INT 3
10429: PPUSH
10430: CALL_OW 307
10434: OR
10435: IFFALSE 10387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10437: LD_VAR 0 3
10441: PPUSH
10442: LD_INT 17
10444: PPUSH
10445: CALL_OW 308
10449: PUSH
10450: LD_VAR 0 3
10454: PPUSH
10455: LD_INT 60
10457: PPUSH
10458: LD_INT 3
10460: PPUSH
10461: CALL_OW 307
10465: OR
10466: IFFALSE 10477
// RemoveUnit ( un ) ;
10468: LD_VAR 0 3
10472: PPUSH
10473: CALL_OW 64
// end ;
10477: PPOPN 3
10479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10480: LD_EXP 4
10484: IFFALSE 10726
10486: GO 10488
10488: DISABLE
10489: LD_INT 0
10491: PPUSH
10492: PPUSH
10493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10494: LD_INT 70
10496: PPUSH
10497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10501: LD_ADDR_VAR 0 3
10505: PUSH
10506: LD_INT 22
10508: PUSH
10509: LD_INT 7
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PUSH
10516: LD_INT 101
10518: PUSH
10519: LD_INT 3
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PPUSH
10530: CALL_OW 69
10534: ST_TO_ADDR
// until tmp ;
10535: LD_VAR 0 3
10539: IFFALSE 10494
// un := NearestUnitToUnit ( tmp , JMM ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_VAR 0 3
10550: PPUSH
10551: LD_EXP 17
10555: PPUSH
10556: CALL_OW 74
10560: ST_TO_ADDR
// player_spotted := true ;
10561: LD_ADDR_EXP 7
10565: PUSH
10566: LD_INT 1
10568: ST_TO_ADDR
// tmp := SciRu ;
10569: LD_ADDR_VAR 0 3
10573: PUSH
10574: CALL 15630 0 0
10578: ST_TO_ADDR
// if not tmp then
10579: LD_VAR 0 3
10583: NOT
10584: IFFALSE 10596
// tmp := SolRu ;
10586: LD_ADDR_VAR 0 3
10590: PUSH
10591: CALL 15777 0 0
10595: ST_TO_ADDR
// DialogueOn ;
10596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 250
10609: PPUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: CALL_OW 251
10619: PPUSH
10620: LD_INT 7
10622: PPUSH
10623: LD_INT 8
10625: NEG
10626: PPUSH
10627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10631: LD_VAR 0 2
10635: PPUSH
10636: CALL_OW 87
// if tmp then
10640: LD_VAR 0 3
10644: IFFALSE 10658
// Say ( tmp , D4-RSci1-1 ) ;
10646: LD_VAR 0 3
10650: PPUSH
10651: LD_STRING D4-RSci1-1
10653: PPUSH
10654: CALL_OW 88
// if Gossudarov then
10658: LD_EXP 35
10662: IFFALSE 10688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10664: LD_EXP 35
10668: PPUSH
10669: LD_STRING D4-Gos-1
10671: PPUSH
10672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10676: LD_EXP 17
10680: PPUSH
10681: LD_STRING D4-JMM-1
10683: PPUSH
10684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10719: LD_STRING M5
10721: PPUSH
10722: CALL_OW 337
// end ;
10726: PPOPN 3
10728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10729: LD_EXP 7
10733: IFFALSE 11326
10735: GO 10737
10737: DISABLE
10738: LD_INT 0
10740: PPUSH
10741: PPUSH
10742: PPUSH
// begin PrepareBelkov ;
10743: CALL 2256 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10747: LD_EXP 50
10751: PPUSH
10752: LD_INT 118
10754: PPUSH
10755: LD_INT 106
10757: PPUSH
10758: CALL_OW 111
// AddComHold ( Belkov ) ;
10762: LD_EXP 50
10766: PPUSH
10767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10771: LD_INT 35
10773: PPUSH
10774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10778: LD_EXP 50
10782: PPUSH
10783: LD_INT 118
10785: PPUSH
10786: LD_INT 106
10788: PPUSH
10789: CALL_OW 307
10793: IFFALSE 10771
// ChangeSideFog ( 4 , 7 ) ;
10795: LD_INT 4
10797: PPUSH
10798: LD_INT 7
10800: PPUSH
10801: CALL_OW 343
// if IsOk ( Belkov ) then
10805: LD_EXP 50
10809: PPUSH
10810: CALL_OW 302
10814: IFFALSE 10898
// begin InGameOn ;
10816: CALL_OW 8
// DialogueOn ;
10820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10824: LD_EXP 50
10828: PPUSH
10829: LD_STRING D5-Bel-1
10831: PPUSH
10832: CALL_OW 94
// if Gossudarov then
10836: LD_EXP 35
10840: IFFALSE 10890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10842: LD_EXP 35
10846: PPUSH
10847: LD_STRING D5-Gos-1
10849: PPUSH
10850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10854: LD_EXP 17
10858: PPUSH
10859: LD_STRING D5-JMM-1
10861: PPUSH
10862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10866: LD_EXP 35
10870: PPUSH
10871: LD_STRING D5-Gos-2
10873: PPUSH
10874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10878: LD_EXP 17
10882: PPUSH
10883: LD_STRING D5-JMM-2
10885: PPUSH
10886: CALL_OW 88
// end ; DialogueOff ;
10890: CALL_OW 7
// InGameOff ;
10894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10898: LD_STRING QSaveBelkov
10900: PPUSH
10901: CALL_OW 97
10905: PUSH
10906: LD_INT 1
10908: DOUBLE
10909: EQUAL
10910: IFTRUE 10914
10912: GO 10964
10914: POP
// begin DialogueOn ;
10915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10919: LD_EXP 17
10923: PPUSH
10924: LD_STRING D5a-JMM-1
10926: PPUSH
10927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10931: LD_EXP 50
10935: PPUSH
10936: LD_STRING D5a-Bel-1
10938: PPUSH
10939: CALL_OW 94
// DialogueOff ;
10943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10947: LD_EXP 50
10951: PPUSH
10952: LD_INT 83
10954: PPUSH
10955: LD_INT 49
10957: PPUSH
10958: CALL_OW 111
// end ; 2 :
10962: GO 10997
10964: LD_INT 2
10966: DOUBLE
10967: EQUAL
10968: IFTRUE 10972
10970: GO 10996
10972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10973: LD_EXP 17
10977: PPUSH
10978: LD_STRING D5a-JMM-2
10980: PPUSH
10981: CALL_OW 88
// ComHold ( Belkov ) ;
10985: LD_EXP 50
10989: PPUSH
10990: CALL_OW 140
// end ; end ;
10994: GO 10997
10996: POP
// time := 0 0$00 ;
10997: LD_ADDR_VAR 0 1
11001: PUSH
11002: LD_INT 0
11004: ST_TO_ADDR
// vehSpawned := false ;
11005: LD_ADDR_VAR 0 3
11009: PUSH
11010: LD_INT 0
11012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11013: LD_INT 35
11015: PPUSH
11016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11020: LD_VAR 0 1
11024: PUSH
11025: LD_INT 350
11027: PUSH
11028: LD_INT 175
11030: PUSH
11031: LD_INT 105
11033: PUSH
11034: LD_INT 70
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: PUSH
11043: LD_OWVAR 67
11047: ARRAY
11048: GREATEREQUAL
11049: PUSH
11050: LD_VAR 0 3
11054: NOT
11055: AND
11056: IFFALSE 11146
// begin vehSpawned := true ;
11058: LD_ADDR_VAR 0 3
11062: PUSH
11063: LD_INT 1
11065: ST_TO_ADDR
// uc_side := 3 ;
11066: LD_ADDR_OWVAR 20
11070: PUSH
11071: LD_INT 3
11073: ST_TO_ADDR
// uc_nation := 3 ;
11074: LD_ADDR_OWVAR 21
11078: PUSH
11079: LD_INT 3
11081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11082: LD_INT 22
11084: PPUSH
11085: LD_INT 3
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 43
11093: PPUSH
11094: LD_INT 100
11096: PPUSH
11097: CALL 22137 0 5
// veh := CreateVehicle ;
11101: LD_ADDR_VAR 0 2
11105: PUSH
11106: CALL_OW 45
11110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11111: LD_VAR 0 2
11115: PPUSH
11116: LD_INT 130
11118: PPUSH
11119: LD_INT 131
11121: PPUSH
11122: LD_INT 0
11124: PPUSH
11125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11129: LD_VAR 0 2
11133: PPUSH
11134: LD_INT 100
11136: PPUSH
11137: LD_INT 82
11139: PPUSH
11140: CALL_OW 114
// end else
11144: GO 11160
// time := time + 0 0$1 ;
11146: LD_ADDR_VAR 0 1
11150: PUSH
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 35
11158: PLUS
11159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11160: LD_EXP 50
11164: PPUSH
11165: CALL_OW 301
11169: PUSH
11170: LD_EXP 50
11174: PPUSH
11175: CALL_OW 255
11179: PUSH
11180: LD_INT 4
11182: EQUAL
11183: AND
11184: PUSH
11185: LD_INT 22
11187: PUSH
11188: LD_INT 7
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PPUSH
11195: CALL_OW 69
11199: PPUSH
11200: LD_EXP 50
11204: PPUSH
11205: CALL_OW 74
11209: PPUSH
11210: LD_EXP 50
11214: PPUSH
11215: CALL_OW 296
11219: PUSH
11220: LD_INT 10
11222: LESS
11223: OR
11224: IFFALSE 11013
// if IsDead ( Belkov ) then
11226: LD_EXP 50
11230: PPUSH
11231: CALL_OW 301
11235: IFFALSE 11260
// begin CenterNowOnUnits ( Belkov ) ;
11237: LD_EXP 50
11241: PPUSH
11242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11246: LD_EXP 17
11250: PPUSH
11251: LD_STRING D5a-JMM-2a
11253: PPUSH
11254: CALL_OW 88
// exit ;
11258: GO 11326
// end ; if See ( 7 , Belkov ) then
11260: LD_INT 7
11262: PPUSH
11263: LD_EXP 50
11267: PPUSH
11268: CALL_OW 292
11272: IFFALSE 11286
// SetSide ( Belkov , 7 ) ;
11274: LD_EXP 50
11278: PPUSH
11279: LD_INT 7
11281: PPUSH
11282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11293: LD_EXP 50
11297: PPUSH
11298: LD_INT 66
11300: PPUSH
11301: LD_INT 45
11303: PPUSH
11304: CALL_OW 297
11308: PUSH
11309: LD_INT 30
11311: LESS
11312: IFFALSE 11286
// Say ( Belkov , D6-Bel-1 ) ;
11314: LD_EXP 50
11318: PPUSH
11319: LD_STRING D6-Bel-1
11321: PPUSH
11322: CALL_OW 88
// end ;
11326: PPOPN 3
11328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11329: LD_EXP 50
11333: PPUSH
11334: CALL_OW 302
11338: PUSH
11339: LD_EXP 50
11343: PPUSH
11344: CALL_OW 504
11348: PUSH
11349: LD_INT 2
11351: PUSH
11352: LD_INT 34
11354: PUSH
11355: LD_INT 47
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: PUSH
11362: LD_INT 34
11364: PUSH
11365: LD_INT 45
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: PPUSH
11377: CALL_OW 69
11381: IN
11382: AND
11383: IFFALSE 11400
11385: GO 11387
11387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11388: LD_EXP 50
11392: PPUSH
11393: LD_STRING D7-Bel-1
11395: PPUSH
11396: CALL_OW 88
11400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11401: LD_INT 22
11403: PUSH
11404: LD_INT 7
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 101
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PPUSH
11425: CALL_OW 69
11429: PUSH
11430: LD_EXP 9
11434: NOT
11435: AND
11436: PUSH
11437: LD_EXP 49
11441: PPUSH
11442: CALL_OW 305
11446: NOT
11447: AND
11448: IFFALSE 11933
11450: GO 11452
11452: DISABLE
11453: LD_INT 0
11455: PPUSH
// begin ar_base_spotted := true ;
11456: LD_ADDR_EXP 9
11460: PUSH
11461: LD_INT 1
11463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11464: LD_ADDR_VAR 0 1
11468: PUSH
11469: LD_INT 22
11471: PUSH
11472: LD_INT 2
11474: PUSH
11475: EMPTY
11476: LIST
11477: LIST
11478: PUSH
11479: LD_INT 21
11481: PUSH
11482: LD_INT 3
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PPUSH
11493: CALL_OW 69
11497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11498: LD_ADDR_VAR 0 1
11502: PUSH
11503: LD_VAR 0 1
11507: PPUSH
11508: LD_EXP 17
11512: PPUSH
11513: CALL_OW 74
11517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11518: LD_INT 7
11520: PPUSH
11521: LD_INT 3
11523: PPUSH
11524: CALL_OW 332
// DialogueOn ;
11528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 250
11541: PPUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 251
11551: PPUSH
11552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11556: LD_ADDR_VAR 0 1
11560: PUSH
11561: LD_INT 22
11563: PUSH
11564: LD_INT 7
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 23
11573: PUSH
11574: LD_INT 1
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: LD_INT 26
11583: PUSH
11584: LD_INT 1
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: PPUSH
11596: CALL_OW 69
11600: PUSH
11601: LD_EXP 17
11605: PUSH
11606: LD_EXP 21
11610: PUSH
11611: LD_EXP 22
11615: PUSH
11616: LD_EXP 29
11620: PUSH
11621: LD_EXP 18
11625: PUSH
11626: LD_EXP 27
11630: PUSH
11631: LD_EXP 23
11635: PUSH
11636: LD_EXP 25
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: DIFF
11651: ST_TO_ADDR
// if not tmp then
11652: LD_VAR 0 1
11656: NOT
11657: IFFALSE 11731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 7
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 23
11676: PUSH
11677: LD_INT 1
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: LD_INT 26
11686: PUSH
11687: LD_INT 2
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PUSH
11694: EMPTY
11695: LIST
11696: LIST
11697: LIST
11698: PPUSH
11699: CALL_OW 69
11703: PUSH
11704: LD_EXP 32
11708: PUSH
11709: LD_EXP 19
11713: PUSH
11714: LD_EXP 30
11718: PUSH
11719: LD_EXP 31
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: DIFF
11730: ST_TO_ADDR
// if tmp then
11731: LD_VAR 0 1
11735: IFFALSE 11806
// case GetSex ( tmp [ 1 ] ) of sex_male :
11737: LD_VAR 0 1
11741: PUSH
11742: LD_INT 1
11744: ARRAY
11745: PPUSH
11746: CALL_OW 258
11750: PUSH
11751: LD_INT 1
11753: DOUBLE
11754: EQUAL
11755: IFTRUE 11759
11757: GO 11778
11759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11760: LD_VAR 0 1
11764: PUSH
11765: LD_INT 1
11767: ARRAY
11768: PPUSH
11769: LD_STRING D9-Sol1-1
11771: PPUSH
11772: CALL_OW 88
11776: GO 11806
11778: LD_INT 2
11780: DOUBLE
11781: EQUAL
11782: IFTRUE 11786
11784: GO 11805
11786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11787: LD_VAR 0 1
11791: PUSH
11792: LD_INT 1
11794: ARRAY
11795: PPUSH
11796: LD_STRING D9-FSol1-1
11798: PPUSH
11799: CALL_OW 88
11803: GO 11806
11805: POP
// if Frank then
11806: LD_EXP 29
11810: IFFALSE 11914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11812: LD_EXP 59
11816: PPUSH
11817: CALL_OW 250
11821: PPUSH
11822: LD_EXP 59
11826: PPUSH
11827: CALL_OW 251
11831: PPUSH
11832: LD_INT 7
11834: PPUSH
11835: LD_INT 8
11837: PPUSH
11838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11842: LD_EXP 59
11846: PPUSH
11847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11851: LD_EXP 29
11855: PPUSH
11856: LD_STRING D9-Frank-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11863: LD_EXP 17
11867: PPUSH
11868: LD_STRING D9-JMM-1
11870: PPUSH
11871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11875: LD_EXP 29
11879: PPUSH
11880: LD_STRING D9-Frank-2
11882: PPUSH
11883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11887: LD_EXP 59
11891: PPUSH
11892: CALL_OW 250
11896: PPUSH
11897: LD_EXP 59
11901: PPUSH
11902: CALL_OW 251
11906: PPUSH
11907: LD_INT 7
11909: PPUSH
11910: CALL_OW 331
// end ; DialogueOff ;
11914: CALL_OW 7
// wait ( 1 1$00 ) ;
11918: LD_INT 2100
11920: PPUSH
11921: CALL_OW 67
// ar_active_attack := true ;
11925: LD_ADDR_EXP 10
11929: PUSH
11930: LD_INT 1
11932: ST_TO_ADDR
// end ;
11933: PPOPN 1
11935: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11936: LD_EXP 8
11940: PUSH
11941: LD_OWVAR 1
11945: PUSH
11946: LD_INT 42000
11948: GREATEREQUAL
11949: OR
11950: IFFALSE 13012
11952: GO 11954
11954: DISABLE
11955: LD_INT 0
11957: PPUSH
11958: PPUSH
// begin selected_option := 1 ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: LD_INT 1
11966: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11967: LD_INT 10500
11969: PPUSH
11970: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11974: LD_INT 35
11976: PPUSH
11977: CALL_OW 67
// until not ru_attackers ;
11981: LD_EXP 55
11985: NOT
11986: IFFALSE 11974
// PrepareBurlak ;
11988: CALL 2368 0 0
// repeat wait ( 0 0$2 ) ;
11992: LD_INT 70
11994: PPUSH
11995: CALL_OW 67
// until not HasTask ( Burlak ) ;
11999: LD_EXP 49
12003: PPUSH
12004: CALL_OW 314
12008: NOT
12009: IFFALSE 11992
// InGameOn ;
12011: CALL_OW 8
// DialogueOn ;
12015: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12019: LD_EXP 52
12023: PPUSH
12024: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12028: LD_EXP 49
12032: PPUSH
12033: LD_STRING D10-Bur-1
12035: PPUSH
12036: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12040: LD_EXP 50
12044: PUSH
12045: LD_EXP 50
12049: PPUSH
12050: CALL_OW 255
12054: PUSH
12055: LD_INT 7
12057: EQUAL
12058: AND
12059: IFFALSE 12073
// Say ( Belkov , D10-Bel-1 ) ;
12061: LD_EXP 50
12065: PPUSH
12066: LD_STRING D10-Bel-1
12068: PPUSH
12069: CALL_OW 88
// if Gossudarov then
12073: LD_EXP 35
12077: IFFALSE 12091
// Say ( Gossudarov , D10-Gos-1 ) ;
12079: LD_EXP 35
12083: PPUSH
12084: LD_STRING D10-Gos-1
12086: PPUSH
12087: CALL_OW 88
// if Kirilenkova then
12091: LD_EXP 36
12095: IFFALSE 12109
// Say ( Kirilenkova , D10-Kir-1 ) ;
12097: LD_EXP 36
12101: PPUSH
12102: LD_STRING D10-Kir-1
12104: PPUSH
12105: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12109: CALL 15777 0 0
12113: PPUSH
12114: LD_STRING D10-RSol1-1
12116: PPUSH
12117: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12121: LD_EXP 49
12125: PPUSH
12126: LD_STRING D10-Bur-2
12128: PPUSH
12129: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12133: LD_EXP 17
12137: PPUSH
12138: LD_STRING D10-JMM-2
12140: PPUSH
12141: CALL_OW 88
// if Kirilenkova then
12145: LD_EXP 36
12149: IFFALSE 12165
// Say ( Kirilenkova , D10-Kir-2 ) else
12151: LD_EXP 36
12155: PPUSH
12156: LD_STRING D10-Kir-2
12158: PPUSH
12159: CALL_OW 88
12163: GO 12177
// Say ( SolRu , D10-RSol1-2 ) ;
12165: CALL 15777 0 0
12169: PPUSH
12170: LD_STRING D10-RSol1-2
12172: PPUSH
12173: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12177: LD_EXP 17
12181: PPUSH
12182: LD_STRING D10-JMM-3
12184: PPUSH
12185: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12189: LD_EXP 49
12193: PPUSH
12194: LD_STRING D10-Bur-3
12196: PPUSH
12197: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12201: LD_EXP 17
12205: PPUSH
12206: LD_STRING D10-JMM-4
12208: PPUSH
12209: CALL_OW 88
// DialogueOff ;
12213: CALL_OW 7
// InGameOff ;
12217: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12221: LD_STRING M2
12223: PPUSH
12224: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12228: LD_INT 35
12230: PPUSH
12231: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12235: LD_INT 22
12237: PUSH
12238: LD_INT 7
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 91
12247: PUSH
12248: LD_EXP 49
12252: PUSH
12253: LD_INT 8
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PPUSH
12265: CALL_OW 69
12269: IFFALSE 12228
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12271: LD_ADDR_VAR 0 1
12275: PUSH
12276: LD_INT 22
12278: PUSH
12279: LD_INT 4
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PPUSH
12286: CALL_OW 69
12290: PUSH
12291: FOR_IN
12292: IFFALSE 12308
// SetSide ( i , 7 ) ;
12294: LD_VAR 0 1
12298: PPUSH
12299: LD_INT 7
12301: PPUSH
12302: CALL_OW 235
12306: GO 12291
12308: POP
12309: POP
// ChangeMissionObjectives ( M3 ) ;
12310: LD_STRING M3
12312: PPUSH
12313: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12317: LD_INT 35
12319: PPUSH
12320: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12324: LD_EXP 17
12328: PPUSH
12329: LD_EXP 49
12333: PPUSH
12334: CALL_OW 296
12338: PUSH
12339: LD_INT 8
12341: LESS
12342: IFFALSE 12317
// ComTurnUnit ( JMM , Burlak ) ;
12344: LD_EXP 17
12348: PPUSH
12349: LD_EXP 49
12353: PPUSH
12354: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12358: LD_EXP 49
12362: PPUSH
12363: LD_EXP 17
12367: PPUSH
12368: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12372: LD_INT 10
12374: PPUSH
12375: CALL_OW 67
// DialogueOn ;
12379: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12383: LD_EXP 17
12387: PPUSH
12388: LD_STRING D11-JMM-1
12390: PPUSH
12391: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12395: LD_EXP 49
12399: PPUSH
12400: LD_STRING D11-Bur-1
12402: PPUSH
12403: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12407: LD_EXP 17
12411: PPUSH
12412: LD_STRING D11-JMM-2
12414: PPUSH
12415: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12419: LD_EXP 49
12423: PPUSH
12424: LD_STRING D11-Bur-2
12426: PPUSH
12427: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12431: LD_EXP 17
12435: PPUSH
12436: LD_STRING D11-JMM-3
12438: PPUSH
12439: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12443: LD_EXP 49
12447: PPUSH
12448: LD_STRING D11-Bur-3
12450: PPUSH
12451: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12455: LD_EXP 17
12459: PPUSH
12460: LD_STRING D11-JMM-4
12462: PPUSH
12463: CALL_OW 88
// if ar_base_spotted then
12467: LD_EXP 9
12471: IFFALSE 12487
// Say ( Burlak , D12-Bur-1 ) else
12473: LD_EXP 49
12477: PPUSH
12478: LD_STRING D12-Bur-1
12480: PPUSH
12481: CALL_OW 88
12485: GO 12526
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12487: LD_INT 7
12489: PPUSH
12490: LD_INT 3
12492: PPUSH
12493: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12497: LD_INT 127
12499: PPUSH
12500: LD_INT 45
12502: PPUSH
12503: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12507: LD_EXP 49
12511: PPUSH
12512: LD_STRING D12-Bur-1a
12514: PPUSH
12515: CALL_OW 88
// dwait ( 0 0$2 ) ;
12519: LD_INT 70
12521: PPUSH
12522: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12526: LD_EXP 58
12530: PPUSH
12531: CALL_OW 302
12535: NOT
12536: IFFALSE 12544
// begin DialogueOff ;
12538: CALL_OW 7
// exit ;
12542: GO 13012
// end ; Say ( Burlak , D12-Bur-1b ) ;
12544: LD_EXP 49
12548: PPUSH
12549: LD_STRING D12-Bur-1b
12551: PPUSH
12552: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12556: LD_EXP 17
12560: PPUSH
12561: LD_STRING D12-JMM-1
12563: PPUSH
12564: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12568: LD_EXP 49
12572: PPUSH
12573: LD_STRING D12-Bur-2
12575: PPUSH
12576: CALL_OW 88
// if Roth then
12580: LD_EXP 18
12584: IFFALSE 12600
// Say ( Roth , D12-Roth-2 ) else
12586: LD_EXP 18
12590: PPUSH
12591: LD_STRING D12-Roth-2
12593: PPUSH
12594: CALL_OW 88
12598: GO 12612
// Say ( SciRu , D12-RSci1-2 ) ;
12600: CALL 15630 0 0
12604: PPUSH
12605: LD_STRING D12-RSci1-2
12607: PPUSH
12608: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12612: LD_EXP 17
12616: PPUSH
12617: LD_STRING D12-JMM-2
12619: PPUSH
12620: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12624: LD_EXP 49
12628: PPUSH
12629: LD_STRING D12-Bur-3
12631: PPUSH
12632: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12636: LD_EXP 17
12640: PPUSH
12641: LD_STRING D12-JMM-3
12643: PPUSH
12644: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12648: LD_EXP 49
12652: PPUSH
12653: LD_STRING D12-Bur-4
12655: PPUSH
12656: CALL_OW 88
// case Query ( QBase ) of 1 :
12660: LD_STRING QBase
12662: PPUSH
12663: CALL_OW 97
12667: PUSH
12668: LD_INT 1
12670: DOUBLE
12671: EQUAL
12672: IFTRUE 12676
12674: GO 12794
12676: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12677: LD_EXP 17
12681: PPUSH
12682: LD_STRING D13a-JMM-1
12684: PPUSH
12685: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12689: LD_EXP 49
12693: PPUSH
12694: LD_STRING D13a-Bur-1
12696: PPUSH
12697: CALL_OW 88
// if Roth then
12701: LD_EXP 18
12705: IFFALSE 12721
// Say ( Roth , D13a-Roth-1 ) else
12707: LD_EXP 18
12711: PPUSH
12712: LD_STRING D13a-Roth-1
12714: PPUSH
12715: CALL_OW 88
12719: GO 12733
// Say ( SciRu , D13a-RSci1-1 ) ;
12721: CALL 15630 0 0
12725: PPUSH
12726: LD_STRING D13a-RSci1-1
12728: PPUSH
12729: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12733: LD_EXP 17
12737: PPUSH
12738: LD_STRING D13a-JMM-2
12740: PPUSH
12741: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12745: LD_STRING QBaseAgain
12747: PPUSH
12748: CALL_OW 97
12752: PUSH
12753: LD_INT 1
12755: DOUBLE
12756: EQUAL
12757: IFTRUE 12761
12759: GO 12772
12761: POP
// selected_option := 2 ; 2 :
12762: LD_ADDR_VAR 0 2
12766: PUSH
12767: LD_INT 2
12769: ST_TO_ADDR
12770: GO 12792
12772: LD_INT 2
12774: DOUBLE
12775: EQUAL
12776: IFTRUE 12780
12778: GO 12791
12780: POP
// selected_option := 3 ; end ;
12781: LD_ADDR_VAR 0 2
12785: PUSH
12786: LD_INT 3
12788: ST_TO_ADDR
12789: GO 12792
12791: POP
// end ; 2 :
12792: GO 12833
12794: LD_INT 2
12796: DOUBLE
12797: EQUAL
12798: IFTRUE 12802
12800: GO 12813
12802: POP
// selected_option := 2 ; 3 :
12803: LD_ADDR_VAR 0 2
12807: PUSH
12808: LD_INT 2
12810: ST_TO_ADDR
12811: GO 12833
12813: LD_INT 3
12815: DOUBLE
12816: EQUAL
12817: IFTRUE 12821
12819: GO 12832
12821: POP
// selected_option := 3 ; end ;
12822: LD_ADDR_VAR 0 2
12826: PUSH
12827: LD_INT 3
12829: ST_TO_ADDR
12830: GO 12833
12832: POP
// if selected_option = 2 then
12833: LD_VAR 0 2
12837: PUSH
12838: LD_INT 2
12840: EQUAL
12841: IFFALSE 12945
// begin Say ( JMM , D13b-JMM-1 ) ;
12843: LD_EXP 17
12847: PPUSH
12848: LD_STRING D13b-JMM-1
12850: PPUSH
12851: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12855: LD_EXP 49
12859: PPUSH
12860: LD_STRING D13b-Bur-1
12862: PPUSH
12863: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12867: LD_EXP 17
12871: PPUSH
12872: LD_STRING D13b-JMM-2
12874: PPUSH
12875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12879: LD_EXP 58
12883: PPUSH
12884: LD_STRING D13b-Abd-2
12886: PPUSH
12887: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12891: LD_EXP 17
12895: PPUSH
12896: LD_STRING D13b-JMM-3
12898: PPUSH
12899: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12903: LD_EXP 58
12907: PPUSH
12908: LD_STRING D13b-Abd-3
12910: PPUSH
12911: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12915: LD_EXP 17
12919: PPUSH
12920: LD_STRING D13b-JMM-4
12922: PPUSH
12923: CALL_OW 88
// ar_active_attack := true ;
12927: LD_ADDR_EXP 10
12931: PUSH
12932: LD_INT 1
12934: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
12935: LD_INT 1
12937: PPUSH
12938: LD_STRING 13a_negotiationWithArabs
12940: PPUSH
12941: CALL_OW 39
// end ; if selected_option = 3 then
12945: LD_VAR 0 2
12949: PUSH
12950: LD_INT 3
12952: EQUAL
12953: IFFALSE 12979
// begin Say ( JMM , D13c-JMM-1 ) ;
12955: LD_EXP 17
12959: PPUSH
12960: LD_STRING D13c-JMM-1
12962: PPUSH
12963: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12967: LD_EXP 49
12971: PPUSH
12972: LD_STRING D13c-Bur-1
12974: PPUSH
12975: CALL_OW 88
// end ; DialogueOff ;
12979: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12983: LD_STRING M4
12985: PPUSH
12986: CALL_OW 337
// if not ar_active_attack then
12990: LD_EXP 10
12994: NOT
12995: IFFALSE 13012
// begin wait ( 6 6$00 ) ;
12997: LD_INT 12600
12999: PPUSH
13000: CALL_OW 67
// ar_active_attack := true ;
13004: LD_ADDR_EXP 10
13008: PUSH
13009: LD_INT 1
13011: ST_TO_ADDR
// end ; end ;
13012: PPOPN 2
13014: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13015: LD_EXP 49
13019: PPUSH
13020: CALL_OW 305
13024: PUSH
13025: LD_EXP 49
13029: PPUSH
13030: CALL_OW 255
13034: PUSH
13035: LD_INT 7
13037: EQUAL
13038: AND
13039: IFFALSE 13262
13041: GO 13043
13043: DISABLE
13044: LD_INT 0
13046: PPUSH
// begin wait ( 4 4$40 ) ;
13047: LD_INT 9800
13049: PPUSH
13050: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13054: LD_INT 35
13056: PPUSH
13057: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13061: LD_EXP 55
13065: NOT
13066: PUSH
13067: LD_INT 22
13069: PUSH
13070: LD_INT 6
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 50
13079: PUSH
13080: EMPTY
13081: LIST
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PPUSH
13087: CALL_OW 69
13091: NOT
13092: AND
13093: IFFALSE 13054
// PrepareGnyevko ;
13095: CALL 2312 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13099: LD_EXP 51
13103: PPUSH
13104: LD_INT 124
13106: PPUSH
13107: LD_INT 118
13109: PPUSH
13110: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13114: LD_EXP 51
13118: PPUSH
13119: CALL_OW 200
// time := 0 0$00 ;
13123: LD_ADDR_VAR 0 1
13127: PUSH
13128: LD_INT 0
13130: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13131: LD_INT 35
13133: PPUSH
13134: CALL_OW 67
// time := time + 0 0$1 ;
13138: LD_ADDR_VAR 0 1
13142: PUSH
13143: LD_VAR 0 1
13147: PUSH
13148: LD_INT 35
13150: PLUS
13151: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13152: LD_EXP 51
13156: PPUSH
13157: LD_INT 124
13159: PPUSH
13160: LD_INT 118
13162: PPUSH
13163: CALL_OW 307
13167: PUSH
13168: LD_VAR 0 1
13172: PUSH
13173: LD_INT 1050
13175: GREATEREQUAL
13176: OR
13177: IFFALSE 13131
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13179: LD_EXP 51
13183: PPUSH
13184: LD_STRING DBelkov-Gny-1
13186: PPUSH
13187: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13191: LD_EXP 49
13195: PPUSH
13196: LD_STRING DBelkov-Bur-1a
13198: PPUSH
13199: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13203: LD_INT 35
13205: PPUSH
13206: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13210: LD_EXP 51
13214: PPUSH
13215: LD_INT 22
13217: PUSH
13218: LD_INT 7
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: PPUSH
13230: LD_EXP 51
13234: PPUSH
13235: CALL_OW 74
13239: PPUSH
13240: CALL_OW 296
13244: PUSH
13245: LD_INT 8
13247: LESS
13248: IFFALSE 13203
// SetSide ( Gnyevko , 7 ) ;
13250: LD_EXP 51
13254: PPUSH
13255: LD_INT 7
13257: PPUSH
13258: CALL_OW 235
// end ;
13262: PPOPN 1
13264: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13265: LD_EXP 49
13269: PPUSH
13270: CALL_OW 255
13274: PUSH
13275: LD_INT 7
13277: EQUAL
13278: IFFALSE 13288
13280: GO 13282
13282: DISABLE
// begin enable ;
13283: ENABLE
// PrepareAmericanAttack ;
13284: CALL 8627 0 0
// end ;
13288: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13289: LD_INT 22
13291: PUSH
13292: LD_INT 1
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: IFFALSE 13487
13305: GO 13307
13307: DISABLE
13308: LD_INT 0
13310: PPUSH
13311: PPUSH
// begin while true do
13312: LD_INT 1
13314: IFFALSE 13371
// begin wait ( 0 0$1 ) ;
13316: LD_INT 35
13318: PPUSH
13319: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13323: LD_ADDR_VAR 0 2
13327: PUSH
13328: LD_INT 22
13330: PUSH
13331: LD_INT 1
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: PPUSH
13343: LD_EXP 17
13347: PPUSH
13348: CALL_OW 74
13352: ST_TO_ADDR
// if See ( 7 , tmp ) then
13353: LD_INT 7
13355: PPUSH
13356: LD_VAR 0 2
13360: PPUSH
13361: CALL_OW 292
13365: IFFALSE 13369
// break ;
13367: GO 13371
// end ;
13369: GO 13312
// DialogueOn ;
13371: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13375: LD_VAR 0 2
13379: PPUSH
13380: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13384: LD_VAR 0 2
13388: PPUSH
13389: CALL_OW 250
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: CALL_OW 251
13403: PPUSH
13404: LD_INT 7
13406: PPUSH
13407: LD_INT 8
13409: PPUSH
13410: CALL_OW 330
// if Denis then
13414: LD_EXP 23
13418: IFFALSE 13432
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13420: LD_EXP 23
13424: PPUSH
13425: LD_STRING DAmerAttack-Pet-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DAmerAttack-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13444: LD_EXP 49
13448: PPUSH
13449: LD_STRING DStop-Bur-1
13451: PPUSH
13452: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13456: LD_VAR 0 2
13460: PPUSH
13461: CALL_OW 250
13465: PPUSH
13466: LD_VAR 0 2
13470: PPUSH
13471: CALL_OW 251
13475: PPUSH
13476: LD_INT 7
13478: PPUSH
13479: CALL_OW 331
// DialogueOff ;
13483: CALL_OW 7
// end ;
13487: PPOPN 2
13489: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13490: LD_INT 22
13492: PUSH
13493: LD_INT 3
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 21
13502: PUSH
13503: LD_INT 1
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PPUSH
13514: CALL_OW 69
13518: PUSH
13519: LD_INT 0
13521: EQUAL
13522: IFFALSE 13572
13524: GO 13526
13526: DISABLE
// begin ru_active_attack := false ;
13527: LD_ADDR_EXP 6
13531: PUSH
13532: LD_INT 0
13534: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13535: LD_STRING M5a
13537: PPUSH
13538: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13542: LD_EXP 17
13546: PPUSH
13547: LD_STRING D8-JMM-1
13549: PPUSH
13550: CALL_OW 88
// if Gossudarov then
13554: LD_EXP 35
13558: IFFALSE 13572
// Say ( Gossudarov , D8-Gos-1 ) ;
13560: LD_EXP 35
13564: PPUSH
13565: LD_STRING D8-Gos-1
13567: PPUSH
13568: CALL_OW 88
// end ;
13572: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13573: LD_INT 22
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 21
13585: PUSH
13586: LD_INT 1
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 69
13601: PUSH
13602: LD_INT 0
13604: EQUAL
13605: IFFALSE 13663
13607: GO 13609
13609: DISABLE
// begin ar_active_attack := false ;
13610: LD_ADDR_EXP 10
13614: PUSH
13615: LD_INT 0
13617: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13618: LD_STRING M4c
13620: PPUSH
13621: CALL_OW 337
// if Roth then
13625: LD_EXP 18
13629: IFFALSE 13645
// Say ( Roth , DStop-Roth-1 ) else
13631: LD_EXP 18
13635: PPUSH
13636: LD_STRING DStop-Roth-1
13638: PPUSH
13639: CALL_OW 88
13643: GO 13663
// if Gossudarov then
13645: LD_EXP 35
13649: IFFALSE 13663
// Say ( Gossudarov , D8-Gos-1a ) ;
13651: LD_EXP 35
13655: PPUSH
13656: LD_STRING D8-Gos-1a
13658: PPUSH
13659: CALL_OW 88
// end ;
13663: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13664: LD_INT 3
13666: PPUSH
13667: CALL_OW 469
13671: PUSH
13672: LD_EXP 13
13676: AND
13677: IFFALSE 13732
13679: GO 13681
13681: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13682: LD_INT 3
13684: PPUSH
13685: CALL_OW 469
13689: PPUSH
13690: CALL 9116 0 1
// if Difficulty > 2 then
13694: LD_OWVAR 67
13698: PUSH
13699: LD_INT 2
13701: GREATER
13702: IFFALSE 13732
// begin wait ( 5 5$00 ) ;
13704: LD_INT 10500
13706: PPUSH
13707: CALL_OW 67
// if FindArtifact ( 3 ) then
13711: LD_INT 3
13713: PPUSH
13714: CALL_OW 469
13718: IFFALSE 13732
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13720: LD_INT 3
13722: PPUSH
13723: CALL_OW 469
13727: PPUSH
13728: CALL 9116 0 1
// end ; end ;
13732: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13733: LD_INT 7
13735: PPUSH
13736: LD_INT 1
13738: PPUSH
13739: LD_INT 1
13741: PPUSH
13742: CALL 17360 0 3
13746: PUSH
13747: LD_INT 0
13749: EQUAL
13750: PUSH
13751: LD_INT 7
13753: PPUSH
13754: LD_INT 3
13756: PPUSH
13757: LD_INT 1
13759: PPUSH
13760: CALL 17360 0 3
13764: PUSH
13765: LD_INT 0
13767: EQUAL
13768: AND
13769: IFFALSE 13781
13771: GO 13773
13773: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13774: LD_STRING M1a
13776: PPUSH
13777: CALL_OW 337
// end ;
13781: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13782: LD_INT 22
13784: PUSH
13785: LD_INT 2
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 23
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 21
13804: PUSH
13805: LD_INT 1
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: PPUSH
13817: CALL_OW 69
13821: PUSH
13822: LD_INT 0
13824: EQUAL
13825: PUSH
13826: LD_INT 22
13828: PUSH
13829: LD_INT 3
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 23
13838: PUSH
13839: LD_INT 3
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: LIST
13860: PPUSH
13861: CALL_OW 69
13865: PUSH
13866: LD_INT 0
13868: EQUAL
13869: AND
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PPUSH
13881: CALL_OW 69
13885: PUSH
13886: LD_INT 0
13888: EQUAL
13889: AND
13890: PUSH
13891: LD_INT 7
13893: PPUSH
13894: LD_INT 1
13896: PPUSH
13897: LD_INT 1
13899: PPUSH
13900: CALL 17360 0 3
13904: PUSH
13905: LD_INT 0
13907: EQUAL
13908: AND
13909: PUSH
13910: LD_INT 7
13912: PPUSH
13913: LD_INT 3
13915: PPUSH
13916: LD_INT 1
13918: PPUSH
13919: CALL 17360 0 3
13923: PUSH
13924: LD_INT 0
13926: EQUAL
13927: AND
13928: PUSH
13929: LD_EXP 49
13933: PPUSH
13934: CALL_OW 255
13938: PUSH
13939: LD_INT 7
13941: EQUAL
13942: AND
13943: PUSH
13944: LD_EXP 49
13948: PPUSH
13949: CALL_OW 302
13953: AND
13954: IFFALSE 15627
13956: GO 13958
13958: DISABLE
13959: LD_INT 0
13961: PPUSH
13962: PPUSH
13963: PPUSH
13964: PPUSH
13965: PPUSH
13966: PPUSH
// begin m1 := false ;
13967: LD_ADDR_VAR 0 4
13971: PUSH
13972: LD_INT 0
13974: ST_TO_ADDR
// m2 := false ;
13975: LD_ADDR_VAR 0 5
13979: PUSH
13980: LD_INT 0
13982: ST_TO_ADDR
// m3 := false ;
13983: LD_ADDR_VAR 0 6
13987: PUSH
13988: LD_INT 0
13990: ST_TO_ADDR
// if tick < 40 40$00 then
13991: LD_OWVAR 1
13995: PUSH
13996: LD_INT 84000
13998: LESS
13999: IFFALSE 14008
// SetAchievement ( ACH_ASPEED_17 ) ;
14001: LD_STRING ACH_ASPEED_17
14003: PPUSH
14004: CALL_OW 543
// wait ( 0 0$5 ) ;
14008: LD_INT 175
14010: PPUSH
14011: CALL_OW 67
// if not masha_killed then
14015: LD_EXP 11
14019: NOT
14020: IFFALSE 14042
// begin m1 := true ;
14022: LD_ADDR_VAR 0 4
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14030: LD_STRING Masha
14032: PPUSH
14033: LD_INT 1
14035: PPUSH
14036: CALL_OW 101
// end else
14040: GO 14053
// AddMedal ( Masha , - 1 ) ;
14042: LD_STRING Masha
14044: PPUSH
14045: LD_INT 1
14047: NEG
14048: PPUSH
14049: CALL_OW 101
// if abdul_escaped then
14053: LD_EXP 14
14057: IFFALSE 14072
// AddMedal ( Abdul , - 1 ) else
14059: LD_STRING Abdul
14061: PPUSH
14062: LD_INT 1
14064: NEG
14065: PPUSH
14066: CALL_OW 101
14070: GO 14090
// begin m2 := true ;
14072: LD_ADDR_VAR 0 5
14076: PUSH
14077: LD_INT 1
14079: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14080: LD_STRING Abdul
14082: PPUSH
14083: LD_INT 1
14085: PPUSH
14086: CALL_OW 101
// end ; if loss_counter = 0 then
14090: LD_EXP 15
14094: PUSH
14095: LD_INT 0
14097: EQUAL
14098: IFFALSE 14120
// begin m3 := true ;
14100: LD_ADDR_VAR 0 6
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14108: LD_STRING People
14110: PPUSH
14111: LD_INT 2
14113: PPUSH
14114: CALL_OW 101
// end else
14118: GO 14182
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14120: LD_EXP 15
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 2
14130: PUSH
14131: LD_INT 2
14133: PUSH
14134: LD_INT 1
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PUSH
14143: LD_OWVAR 67
14147: ARRAY
14148: LESSEQUAL
14149: IFFALSE 14171
// begin AddMedal ( People , 1 ) ;
14151: LD_STRING People
14153: PPUSH
14154: LD_INT 1
14156: PPUSH
14157: CALL_OW 101
// m3 := true ;
14161: LD_ADDR_VAR 0 6
14165: PUSH
14166: LD_INT 1
14168: ST_TO_ADDR
// end else
14169: GO 14182
// AddMedal ( People , - 1 ) ;
14171: LD_STRING People
14173: PPUSH
14174: LD_INT 1
14176: NEG
14177: PPUSH
14178: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14182: LD_OWVAR 67
14186: PUSH
14187: LD_INT 3
14189: GREATEREQUAL
14190: PUSH
14191: LD_VAR 0 4
14195: AND
14196: PUSH
14197: LD_VAR 0 5
14201: AND
14202: PUSH
14203: LD_VAR 0 6
14207: AND
14208: IFFALSE 14220
// SetAchievementEX ( ACH_AMER , 17 ) ;
14210: LD_STRING ACH_AMER
14212: PPUSH
14213: LD_INT 17
14215: PPUSH
14216: CALL_OW 564
// GiveMedals ( MAIN ) ;
14220: LD_STRING MAIN
14222: PPUSH
14223: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14227: LD_ADDR_VAR 0 2
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 7
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: LD_INT 50
14244: PUSH
14245: EMPTY
14246: LIST
14247: PUSH
14248: LD_INT 2
14250: PUSH
14251: LD_INT 25
14253: PUSH
14254: LD_INT 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: LD_INT 25
14263: PUSH
14264: LD_INT 2
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 25
14273: PUSH
14274: LD_INT 3
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 25
14283: PUSH
14284: LD_INT 4
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PUSH
14291: LD_INT 25
14293: PUSH
14294: LD_INT 5
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PUSH
14301: LD_INT 25
14303: PUSH
14304: LD_INT 8
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PUSH
14311: LD_INT 25
14313: PUSH
14314: LD_INT 9
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: LIST
14335: PPUSH
14336: CALL_OW 69
14340: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14341: LD_VAR 0 2
14345: PPUSH
14346: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14350: LD_ADDR_VAR 0 3
14354: PUSH
14355: LD_EXP 17
14359: PUSH
14360: LD_EXP 18
14364: PUSH
14365: LD_EXP 19
14369: PUSH
14370: LD_EXP 20
14374: PUSH
14375: LD_EXP 21
14379: PUSH
14380: LD_EXP 22
14384: PUSH
14385: LD_EXP 23
14389: PUSH
14390: LD_EXP 24
14394: PUSH
14395: LD_EXP 25
14399: PUSH
14400: LD_EXP 26
14404: PUSH
14405: LD_EXP 27
14409: PUSH
14410: LD_EXP 28
14414: PUSH
14415: LD_EXP 29
14419: PUSH
14420: LD_EXP 30
14424: PUSH
14425: LD_EXP 31
14429: PUSH
14430: LD_EXP 32
14434: PUSH
14435: LD_EXP 33
14439: PUSH
14440: LD_EXP 35
14444: PUSH
14445: LD_EXP 36
14449: PUSH
14450: LD_EXP 37
14454: PUSH
14455: LD_EXP 39
14459: PUSH
14460: LD_EXP 40
14464: PUSH
14465: LD_EXP 41
14469: PUSH
14470: LD_EXP 42
14474: PUSH
14475: LD_EXP 43
14479: PUSH
14480: LD_EXP 44
14484: PUSH
14485: LD_EXP 45
14489: PUSH
14490: LD_EXP 46
14494: PUSH
14495: LD_EXP 47
14499: PUSH
14500: LD_EXP 48
14504: PUSH
14505: LD_EXP 49
14509: PUSH
14510: LD_EXP 50
14514: PUSH
14515: LD_EXP 51
14519: PUSH
14520: LD_EXP 34
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: ST_TO_ADDR
// if tmp diff tmp2 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_VAR 0 3
14570: DIFF
14571: IFFALSE 14591
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14573: LD_VAR 0 2
14577: PUSH
14578: LD_VAR 0 3
14582: DIFF
14583: PPUSH
14584: LD_STRING 13a_others
14586: PPUSH
14587: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14591: LD_EXP 17
14595: PPUSH
14596: LD_STRING 13a_JMM
14598: PPUSH
14599: CALL_OW 38
// if IsOk ( Mike ) then
14603: LD_EXP 34
14607: PPUSH
14608: CALL_OW 302
14612: IFFALSE 14626
// SaveCharacters ( Mike , 13a_Mike ) ;
14614: LD_EXP 34
14618: PPUSH
14619: LD_STRING 13a_Mike
14621: PPUSH
14622: CALL_OW 38
// if IsOk ( Titov ) then
14626: LD_EXP 37
14630: PPUSH
14631: CALL_OW 302
14635: IFFALSE 14649
// SaveCharacters ( Titov , 13a_Titov ) ;
14637: LD_EXP 37
14641: PPUSH
14642: LD_STRING 13a_Titov
14644: PPUSH
14645: CALL_OW 38
// if IsOk ( Dolgov ) then
14649: LD_EXP 39
14653: PPUSH
14654: CALL_OW 302
14658: IFFALSE 14672
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14660: LD_EXP 39
14664: PPUSH
14665: LD_STRING 13a_Dolgov
14667: PPUSH
14668: CALL_OW 38
// if IsOk ( Petrosyan ) then
14672: LD_EXP 40
14676: PPUSH
14677: CALL_OW 302
14681: IFFALSE 14695
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14683: LD_EXP 40
14687: PPUSH
14688: LD_STRING 13a_Petrosyan
14690: PPUSH
14691: CALL_OW 38
// if IsOk ( Scholtze ) then
14695: LD_EXP 41
14699: PPUSH
14700: CALL_OW 302
14704: IFFALSE 14718
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14706: LD_EXP 41
14710: PPUSH
14711: LD_STRING 13a_Scholtze
14713: PPUSH
14714: CALL_OW 38
// if IsOk ( Oblukov ) then
14718: LD_EXP 42
14722: PPUSH
14723: CALL_OW 302
14727: IFFALSE 14741
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14729: LD_EXP 42
14733: PPUSH
14734: LD_STRING 13a_Oblukov
14736: PPUSH
14737: CALL_OW 38
// if IsOk ( Kapitsova ) then
14741: LD_EXP 43
14745: PPUSH
14746: CALL_OW 302
14750: IFFALSE 14764
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14752: LD_EXP 43
14756: PPUSH
14757: LD_STRING 13a_Kapitsova
14759: PPUSH
14760: CALL_OW 38
// if IsOk ( Lipshchin ) then
14764: LD_EXP 44
14768: PPUSH
14769: CALL_OW 302
14773: IFFALSE 14787
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14775: LD_EXP 44
14779: PPUSH
14780: LD_STRING 13a_Lipshchin
14782: PPUSH
14783: CALL_OW 38
// if IsOk ( Petrovova ) then
14787: LD_EXP 45
14791: PPUSH
14792: CALL_OW 302
14796: IFFALSE 14810
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14798: LD_EXP 45
14802: PPUSH
14803: LD_STRING 13a_Petrovova
14805: PPUSH
14806: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14810: LD_EXP 46
14814: PPUSH
14815: CALL_OW 302
14819: IFFALSE 14833
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14821: LD_EXP 46
14825: PPUSH
14826: LD_STRING 13a_Kovalyuk
14828: PPUSH
14829: CALL_OW 38
// if IsOk ( Kuzmov ) then
14833: LD_EXP 47
14837: PPUSH
14838: CALL_OW 302
14842: IFFALSE 14856
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14844: LD_EXP 47
14848: PPUSH
14849: LD_STRING 13a_Kuzmov
14851: PPUSH
14852: CALL_OW 38
// if IsOk ( Karamazov ) then
14856: LD_EXP 48
14860: PPUSH
14861: CALL_OW 302
14865: IFFALSE 14879
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14867: LD_EXP 48
14871: PPUSH
14872: LD_STRING 13a_Karamazov
14874: PPUSH
14875: CALL_OW 38
// if Burlak then
14879: LD_EXP 49
14883: IFFALSE 14904
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14885: LD_STRING enableBioCharacter(BIO_GORKI)
14887: PPUSH
14888: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14892: LD_EXP 49
14896: PPUSH
14897: LD_STRING 13a_Burlak
14899: PPUSH
14900: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14904: LD_EXP 50
14908: PPUSH
14909: CALL_OW 302
14913: IFFALSE 14927
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14915: LD_EXP 50
14919: PPUSH
14920: LD_STRING 13a_Belkov
14922: PPUSH
14923: CALL_OW 38
// if IsOk ( Gnyevko ) then
14927: LD_EXP 51
14931: PPUSH
14932: CALL_OW 302
14936: IFFALSE 14950
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14938: LD_EXP 51
14942: PPUSH
14943: LD_STRING 13a_Gnyevko
14945: PPUSH
14946: CALL_OW 38
// if IsOk ( Lisa ) then
14950: LD_EXP 19
14954: PPUSH
14955: CALL_OW 302
14959: IFFALSE 14973
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14961: LD_EXP 19
14965: PPUSH
14966: LD_STRING 13a_Lisa
14968: PPUSH
14969: CALL_OW 38
// if IsOk ( Donaldson ) then
14973: LD_EXP 20
14977: PPUSH
14978: CALL_OW 302
14982: IFFALSE 14996
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14984: LD_EXP 20
14988: PPUSH
14989: LD_STRING 13a_Donaldson
14991: PPUSH
14992: CALL_OW 38
// if IsOk ( Bobby ) then
14996: LD_EXP 21
15000: PPUSH
15001: CALL_OW 302
15005: IFFALSE 15019
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15007: LD_EXP 21
15011: PPUSH
15012: LD_STRING 13a_Bobby
15014: PPUSH
15015: CALL_OW 38
// if IsOk ( Cyrus ) then
15019: LD_EXP 22
15023: PPUSH
15024: CALL_OW 302
15028: IFFALSE 15042
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15030: LD_EXP 22
15034: PPUSH
15035: LD_STRING 13a_Cyrus
15037: PPUSH
15038: CALL_OW 38
// if IsOk ( Denis ) then
15042: LD_EXP 23
15046: PPUSH
15047: CALL_OW 302
15051: IFFALSE 15065
// SaveCharacters ( Denis , 13a_Denis ) ;
15053: LD_EXP 23
15057: PPUSH
15058: LD_STRING 13a_Denis
15060: PPUSH
15061: CALL_OW 38
// if IsOk ( Brown ) then
15065: LD_EXP 24
15069: PPUSH
15070: CALL_OW 302
15074: IFFALSE 15088
// SaveCharacters ( Brown , 13a_Brown ) ;
15076: LD_EXP 24
15080: PPUSH
15081: LD_STRING 13a_Brown
15083: PPUSH
15084: CALL_OW 38
// if IsOk ( Gladstone ) then
15088: LD_EXP 25
15092: PPUSH
15093: CALL_OW 302
15097: IFFALSE 15111
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15099: LD_EXP 25
15103: PPUSH
15104: LD_STRING 13a_Gladstone
15106: PPUSH
15107: CALL_OW 38
// if IsOk ( Houten ) then
15111: LD_EXP 26
15115: PPUSH
15116: CALL_OW 302
15120: IFFALSE 15134
// SaveCharacters ( Houten , 13a_Houten ) ;
15122: LD_EXP 26
15126: PPUSH
15127: LD_STRING 13a_Houten
15129: PPUSH
15130: CALL_OW 38
// if IsOk ( Cornel ) then
15134: LD_EXP 27
15138: PPUSH
15139: CALL_OW 302
15143: IFFALSE 15157
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15145: LD_EXP 27
15149: PPUSH
15150: LD_STRING 13a_Cornel
15152: PPUSH
15153: CALL_OW 38
// if IsOk ( Gary ) then
15157: LD_EXP 28
15161: PPUSH
15162: CALL_OW 302
15166: IFFALSE 15180
// SaveCharacters ( Gary , 13a_Gary ) ;
15168: LD_EXP 28
15172: PPUSH
15173: LD_STRING 13a_Gary
15175: PPUSH
15176: CALL_OW 38
// if IsOk ( Frank ) then
15180: LD_EXP 29
15184: PPUSH
15185: CALL_OW 302
15189: IFFALSE 15203
// SaveCharacters ( Frank , 13a_Frank ) ;
15191: LD_EXP 29
15195: PPUSH
15196: LD_STRING 13a_Frank
15198: PPUSH
15199: CALL_OW 38
// if IsOk ( Kikuchi ) then
15203: LD_EXP 30
15207: PPUSH
15208: CALL_OW 302
15212: IFFALSE 15226
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15214: LD_EXP 30
15218: PPUSH
15219: LD_STRING 13a_Kikuchi
15221: PPUSH
15222: CALL_OW 38
// if IsOk ( Simms ) then
15226: LD_EXP 31
15230: PPUSH
15231: CALL_OW 302
15235: IFFALSE 15249
// SaveCharacters ( Simms , 13a_Simms ) ;
15237: LD_EXP 31
15241: PPUSH
15242: LD_STRING 13a_Simms
15244: PPUSH
15245: CALL_OW 38
// if IsOk ( Joan ) then
15249: LD_EXP 32
15253: PPUSH
15254: CALL_OW 302
15258: IFFALSE 15272
// SaveCharacters ( Joan , 13a_Joan ) ;
15260: LD_EXP 32
15264: PPUSH
15265: LD_STRING 13a_Joan
15267: PPUSH
15268: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15272: LD_EXP 33
15276: PPUSH
15277: CALL_OW 302
15281: IFFALSE 15295
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15283: LD_EXP 33
15287: PPUSH
15288: LD_STRING 13a_DeltaDoctor
15290: PPUSH
15291: CALL_OW 38
// if IsOk ( Gossudarov ) then
15295: LD_EXP 35
15299: PPUSH
15300: CALL_OW 302
15304: IFFALSE 15318
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15306: LD_EXP 35
15310: PPUSH
15311: LD_STRING 13a_Gossudarov
15313: PPUSH
15314: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15318: LD_EXP 36
15322: PPUSH
15323: CALL_OW 302
15327: IFFALSE 15341
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15329: LD_EXP 36
15333: PPUSH
15334: LD_STRING 13a_Kirilenkova
15336: PPUSH
15337: CALL_OW 38
// if IsOk ( Roth ) then
15341: LD_EXP 18
15345: PPUSH
15346: CALL_OW 302
15350: IFFALSE 15364
// SaveCharacters ( Roth , 13a_Roth ) ;
15352: LD_EXP 18
15356: PPUSH
15357: LD_STRING 13a_Roth
15359: PPUSH
15360: CALL_OW 38
// if Masha then
15364: LD_EXP 52
15368: IFFALSE 15423
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15370: LD_EXP 52
15374: PPUSH
15375: CALL_OW 265
15379: PUSH
15380: LD_EXP 52
15384: PPUSH
15385: CALL_OW 262
15389: PUSH
15390: LD_EXP 52
15394: PPUSH
15395: CALL_OW 263
15399: PUSH
15400: LD_EXP 52
15404: PPUSH
15405: CALL_OW 264
15409: PUSH
15410: EMPTY
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: PPUSH
15416: LD_STRING 13a_Masha
15418: PPUSH
15419: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 21
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PPUSH
15438: CALL_OW 69
15442: ST_TO_ADDR
// tmp2 := [ ] ;
15443: LD_ADDR_VAR 0 3
15447: PUSH
15448: EMPTY
15449: ST_TO_ADDR
// if tmp then
15450: LD_VAR 0 2
15454: IFFALSE 15605
// for i in tmp do
15456: LD_ADDR_VAR 0 1
15460: PUSH
15461: LD_VAR 0 2
15465: PUSH
15466: FOR_IN
15467: IFFALSE 15603
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15469: LD_ADDR_VAR 0 3
15473: PUSH
15474: LD_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PPUSH
15484: CALL_OW 255
15488: PUSH
15489: LD_VAR 0 1
15493: PPUSH
15494: CALL_OW 248
15498: PUSH
15499: LD_VAR 0 1
15503: PPUSH
15504: CALL_OW 266
15508: PUSH
15509: LD_VAR 0 1
15513: PPUSH
15514: CALL_OW 250
15518: PUSH
15519: LD_VAR 0 1
15523: PPUSH
15524: CALL_OW 251
15528: PUSH
15529: LD_VAR 0 1
15533: PPUSH
15534: CALL_OW 254
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 267
15548: PUSH
15549: LD_VAR 0 1
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: CALL_OW 268
15561: PUSH
15562: LD_VAR 0 1
15566: PPUSH
15567: LD_INT 2
15569: PPUSH
15570: CALL_OW 268
15574: PUSH
15575: LD_VAR 0 1
15579: PPUSH
15580: CALL_OW 269
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: PUSH
15597: EMPTY
15598: LIST
15599: ADD
15600: ST_TO_ADDR
15601: GO 15466
15603: POP
15604: POP
// if tmp2 then
15605: LD_VAR 0 3
15609: IFFALSE 15623
// SaveVariable ( tmp2 , 13a_buildings ) ;
15611: LD_VAR 0 3
15615: PPUSH
15616: LD_STRING 13a_buildings
15618: PPUSH
15619: CALL_OW 39
// YouWin ;
15623: CALL_OW 103
// end ;
15627: PPOPN 6
15629: END
// export function SciRu ; var tmp , t ; begin
15630: LD_INT 0
15632: PPUSH
15633: PPUSH
15634: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15635: LD_ADDR_VAR 0 3
15639: PUSH
15640: LD_EXP 35
15644: PUSH
15645: LD_EXP 49
15649: PUSH
15650: LD_EXP 37
15654: PUSH
15655: LD_EXP 50
15659: PUSH
15660: LD_EXP 51
15664: PUSH
15665: LD_EXP 40
15669: PUSH
15670: LD_EXP 41
15674: PUSH
15675: LD_EXP 39
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15690: LD_ADDR_VAR 0 2
15694: PUSH
15695: LD_INT 22
15697: PUSH
15698: LD_INT 7
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PUSH
15705: LD_INT 23
15707: PUSH
15708: LD_INT 3
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: LD_INT 25
15717: PUSH
15718: LD_INT 4
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 26
15727: PUSH
15728: LD_INT 1
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: PPUSH
15741: CALL_OW 69
15745: PUSH
15746: LD_VAR 0 3
15750: DIFF
15751: ST_TO_ADDR
// if tmp then
15752: LD_VAR 0 2
15756: IFFALSE 15772
// result := tmp [ 1 ] ;
15758: LD_ADDR_VAR 0 1
15762: PUSH
15763: LD_VAR 0 2
15767: PUSH
15768: LD_INT 1
15770: ARRAY
15771: ST_TO_ADDR
// end ;
15772: LD_VAR 0 1
15776: RET
// export function SolRu ; var tmp , t ; begin
15777: LD_INT 0
15779: PPUSH
15780: PPUSH
15781: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15782: LD_ADDR_VAR 0 3
15786: PUSH
15787: LD_EXP 35
15791: PUSH
15792: LD_EXP 49
15796: PUSH
15797: LD_EXP 37
15801: PUSH
15802: LD_EXP 50
15806: PUSH
15807: LD_EXP 51
15811: PUSH
15812: LD_EXP 40
15816: PUSH
15817: LD_EXP 41
15821: PUSH
15822: LD_EXP 39
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15837: LD_ADDR_VAR 0 2
15841: PUSH
15842: LD_INT 22
15844: PUSH
15845: LD_INT 7
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 23
15854: PUSH
15855: LD_INT 3
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 25
15864: PUSH
15865: LD_INT 1
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 26
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: LIST
15886: LIST
15887: PPUSH
15888: CALL_OW 69
15892: PUSH
15893: LD_VAR 0 3
15897: DIFF
15898: ST_TO_ADDR
// if tmp then
15899: LD_VAR 0 2
15903: IFFALSE 15919
// result := tmp [ 1 ] ;
15905: LD_ADDR_VAR 0 1
15909: PUSH
15910: LD_VAR 0 2
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: ST_TO_ADDR
// end ; end_of_file
15919: LD_VAR 0 1
15923: RET
// export function CustomEvent ( event ) ; begin
15924: LD_INT 0
15926: PPUSH
// end ;
15927: LD_VAR 0 2
15931: RET
// on UnitDestroyed ( un ) do var i , side ;
15932: LD_INT 0
15934: PPUSH
15935: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15936: LD_VAR 0 1
15940: PPUSH
15941: CALL 106747 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15945: LD_VAR 0 1
15949: PUSH
15950: LD_INT 22
15952: PUSH
15953: LD_INT 7
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PUSH
15960: LD_INT 2
15962: PUSH
15963: LD_INT 25
15965: PUSH
15966: LD_INT 1
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: LD_INT 25
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PUSH
15983: LD_INT 25
15985: PUSH
15986: LD_INT 3
15988: PUSH
15989: EMPTY
15990: LIST
15991: LIST
15992: PUSH
15993: LD_INT 25
15995: PUSH
15996: LD_INT 4
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PUSH
16003: LD_INT 25
16005: PUSH
16006: LD_INT 5
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PUSH
16013: LD_INT 25
16015: PUSH
16016: LD_INT 8
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 25
16025: PUSH
16026: LD_INT 9
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: PUSH
16043: EMPTY
16044: LIST
16045: LIST
16046: PPUSH
16047: CALL_OW 69
16051: IN
16052: IFFALSE 16068
// loss_counter := loss_counter + 1 ;
16054: LD_ADDR_EXP 15
16058: PUSH
16059: LD_EXP 15
16063: PUSH
16064: LD_INT 1
16066: PLUS
16067: ST_TO_ADDR
// if un = Abdul then
16068: LD_VAR 0 1
16072: PUSH
16073: LD_EXP 58
16077: EQUAL
16078: IFFALSE 16088
// abdul_escaped := false ;
16080: LD_ADDR_EXP 14
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// if un in ru_attackers then
16088: LD_VAR 0 1
16092: PUSH
16093: LD_EXP 55
16097: IN
16098: IFFALSE 16116
// ru_attackers := ru_attackers diff un ;
16100: LD_ADDR_EXP 55
16104: PUSH
16105: LD_EXP 55
16109: PUSH
16110: LD_VAR 0 1
16114: DIFF
16115: ST_TO_ADDR
// if un in ar_attackers then
16116: LD_VAR 0 1
16120: PUSH
16121: LD_EXP 12
16125: IN
16126: IFFALSE 16144
// ar_attackers := ar_attackers diff un ;
16128: LD_ADDR_EXP 12
16132: PUSH
16133: LD_EXP 12
16137: PUSH
16138: LD_VAR 0 1
16142: DIFF
16143: ST_TO_ADDR
// if un = JMM then
16144: LD_VAR 0 1
16148: PUSH
16149: LD_EXP 17
16153: EQUAL
16154: IFFALSE 16165
// begin YouLost ( JMM ) ;
16156: LD_STRING JMM
16158: PPUSH
16159: CALL_OW 104
// exit ;
16163: GO 16262
// end ; if un = Burlak then
16165: LD_VAR 0 1
16169: PUSH
16170: LD_EXP 49
16174: EQUAL
16175: IFFALSE 16186
// begin YouLost ( Burlak ) ;
16177: LD_STRING Burlak
16179: PPUSH
16180: CALL_OW 104
// exit ;
16184: GO 16262
// end ; if un = freedom then
16186: LD_VAR 0 1
16190: PUSH
16191: LD_EXP 3
16195: EQUAL
16196: IFFALSE 16207
// begin YouLost ( Destroyed ) ;
16198: LD_STRING Destroyed
16200: PPUSH
16201: CALL_OW 104
// exit ;
16205: GO 16262
// end ; if un = Masha then
16207: LD_VAR 0 1
16211: PUSH
16212: LD_EXP 52
16216: EQUAL
16217: IFFALSE 16234
// begin ChangeMissionObjectives ( M4b ) ;
16219: LD_STRING M4b
16221: PPUSH
16222: CALL_OW 337
// masha_killed := true ;
16226: LD_ADDR_EXP 11
16230: PUSH
16231: LD_INT 1
16233: ST_TO_ADDR
// end ; if un = Mastodont then
16234: LD_VAR 0 1
16238: PUSH
16239: LD_EXP 59
16243: EQUAL
16244: IFFALSE 16253
// ChangeMissionObjectives ( M4a ) ;
16246: LD_STRING M4a
16248: PPUSH
16249: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16253: LD_VAR 0 1
16257: PPUSH
16258: CALL 87816 0 1
// end ;
16262: PPOPN 3
16264: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16265: LD_VAR 0 1
16269: PPUSH
16270: LD_VAR 0 2
16274: PPUSH
16275: CALL 90148 0 2
// end ;
16279: PPOPN 2
16281: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16282: LD_VAR 0 1
16286: PPUSH
16287: CALL 89216 0 1
// end ;
16291: PPOPN 1
16293: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16294: LD_VAR 0 1
16298: PUSH
16299: LD_INT 22
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PUSH
16309: LD_INT 30
16311: PUSH
16312: LD_INT 0
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PPUSH
16323: CALL_OW 69
16327: IN
16328: IFFALSE 16367
// begin SetBName ( building , freedom ) ;
16330: LD_VAR 0 1
16334: PPUSH
16335: LD_STRING freedom
16337: PPUSH
16338: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16342: LD_INT 0
16344: PPUSH
16345: LD_INT 7
16347: PPUSH
16348: LD_INT 0
16350: PPUSH
16351: CALL_OW 324
// freedom := building ;
16355: LD_ADDR_EXP 3
16359: PUSH
16360: LD_VAR 0 1
16364: ST_TO_ADDR
// exit ;
16365: GO 16433
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16367: LD_VAR 0 1
16371: PUSH
16372: LD_INT 22
16374: PUSH
16375: LD_INT 7
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 23
16384: PUSH
16385: LD_INT 3
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: LD_INT 30
16394: PUSH
16395: LD_INT 6
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: IN
16412: IFFALSE 16424
// begin ru_lab_builded := true ;
16414: LD_ADDR_EXP 5
16418: PUSH
16419: LD_INT 1
16421: ST_TO_ADDR
// exit ;
16422: GO 16433
// end ; MCE_BuildingComplete ( building ) ;
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL 89457 0 1
// end ;
16433: PPOPN 1
16435: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16436: LD_VAR 0 1
16440: PPUSH
16441: LD_VAR 0 2
16445: PPUSH
16446: CALL 87512 0 2
// end ;
16450: PPOPN 2
16452: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16453: LD_VAR 0 1
16457: PPUSH
16458: LD_VAR 0 2
16462: PPUSH
16463: LD_VAR 0 3
16467: PPUSH
16468: LD_VAR 0 4
16472: PPUSH
16473: LD_VAR 0 5
16477: PPUSH
16478: CALL 87132 0 5
// end ;
16482: PPOPN 5
16484: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16485: LD_VAR 0 1
16489: PPUSH
16490: LD_VAR 0 2
16494: PPUSH
16495: CALL 106805 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16499: LD_VAR 0 1
16503: PPUSH
16504: LD_VAR 0 2
16508: PPUSH
16509: CALL 86685 0 2
// end ;
16513: PPOPN 2
16515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16516: LD_VAR 0 1
16520: PPUSH
16521: CALL_OW 263
16525: PUSH
16526: LD_INT 3
16528: EQUAL
16529: PUSH
16530: LD_VAR 0 2
16534: PPUSH
16535: CALL_OW 263
16539: PUSH
16540: LD_INT 3
16542: EQUAL
16543: OR
16544: IFFALSE 16560
// hack_counter := hack_counter + 1 ;
16546: LD_ADDR_EXP 16
16550: PUSH
16551: LD_EXP 16
16555: PUSH
16556: LD_INT 1
16558: PLUS
16559: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16560: LD_VAR 0 1
16564: PPUSH
16565: LD_VAR 0 2
16569: PPUSH
16570: LD_VAR 0 3
16574: PPUSH
16575: LD_VAR 0 4
16579: PPUSH
16580: CALL 86523 0 4
// end ;
16584: PPOPN 4
16586: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16587: LD_VAR 0 1
16591: PUSH
16592: LD_INT 47
16594: EQUAL
16595: IFFALSE 16617
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16597: LD_VAR 0 1
16601: PPUSH
16602: CALL_OW 274
16606: PPUSH
16607: LD_INT 1
16609: PPUSH
16610: LD_INT 600
16612: PPUSH
16613: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16617: LD_VAR 0 1
16621: PPUSH
16622: LD_VAR 0 2
16626: PPUSH
16627: LD_VAR 0 3
16631: PPUSH
16632: CALL 86298 0 3
// end ;
16636: PPOPN 3
16638: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16639: LD_VAR 0 1
16643: PPUSH
16644: LD_VAR 0 2
16648: PPUSH
16649: CALL 86183 0 2
// end ;
16653: PPOPN 2
16655: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_VAR 0 2
16665: PPUSH
16666: CALL 90443 0 2
// end ;
16670: PPOPN 2
16672: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16673: LD_VAR 0 1
16677: PPUSH
16678: LD_VAR 0 2
16682: PPUSH
16683: LD_VAR 0 3
16687: PPUSH
16688: LD_VAR 0 4
16692: PPUSH
16693: CALL 90659 0 4
// end ;
16697: PPOPN 4
16699: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16700: LD_VAR 0 1
16704: PPUSH
16705: LD_VAR 0 2
16709: PPUSH
16710: CALL 85992 0 2
// end ;
16714: PPOPN 2
16716: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: CALL 106789 0 1
// end ; end_of_file
16726: PPOPN 1
16728: END
// every 0 0$30 do var cr , time ;
16729: GO 16731
16731: DISABLE
16732: LD_INT 0
16734: PPUSH
16735: PPUSH
// begin time := 0 0$20 ;
16736: LD_ADDR_VAR 0 2
16740: PUSH
16741: LD_INT 700
16743: ST_TO_ADDR
// while game do
16744: LD_EXP 2
16748: IFFALSE 16851
// begin wait ( time ) ;
16750: LD_VAR 0 2
16754: PPUSH
16755: CALL_OW 67
// if tick > 2 2$00 then
16759: LD_OWVAR 1
16763: PUSH
16764: LD_INT 4200
16766: GREATER
16767: IFFALSE 16804
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16769: LD_ADDR_VAR 0 2
16773: PUSH
16774: LD_VAR 0 2
16778: PUSH
16779: LD_INT 140
16781: PUSH
16782: LD_INT 140
16784: PUSH
16785: LD_INT 210
16787: PUSH
16788: LD_INT 280
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: LD_OWVAR 67
16801: ARRAY
16802: PLUS
16803: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16804: LD_INT 1
16806: PPUSH
16807: LD_INT 5
16809: PPUSH
16810: CALL_OW 12
16814: PPUSH
16815: LD_INT 70
16817: PPUSH
16818: LD_INT 49
16820: PPUSH
16821: LD_INT 25
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: CALL_OW 56
// if time > 3 3$00 then
16831: LD_VAR 0 2
16835: PUSH
16836: LD_INT 6300
16838: GREATER
16839: IFFALSE 16849
// time := 0 0$30 ;
16841: LD_ADDR_VAR 0 2
16845: PUSH
16846: LD_INT 1050
16848: ST_TO_ADDR
// end ;
16849: GO 16744
// end ;
16851: PPOPN 2
16853: END
// every 0 0$30 do var cr , time ;
16854: GO 16856
16856: DISABLE
16857: LD_INT 0
16859: PPUSH
16860: PPUSH
// begin time := 0 0$20 ;
16861: LD_ADDR_VAR 0 2
16865: PUSH
16866: LD_INT 700
16868: ST_TO_ADDR
// while game do
16869: LD_EXP 2
16873: IFFALSE 16966
// begin wait ( time ) ;
16875: LD_VAR 0 2
16879: PPUSH
16880: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16884: LD_ADDR_VAR 0 2
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: LD_INT 140
16896: PUSH
16897: LD_INT 175
16899: PUSH
16900: LD_INT 210
16902: PUSH
16903: LD_INT 280
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: PUSH
16912: LD_OWVAR 67
16916: ARRAY
16917: PLUS
16918: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16919: LD_INT 3
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: CALL_OW 12
16929: PPUSH
16930: LD_INT 26
16932: PPUSH
16933: LD_INT 9
16935: PPUSH
16936: LD_INT 30
16938: PPUSH
16939: LD_INT 1
16941: PPUSH
16942: CALL_OW 56
// if time > 3 3$00 then
16946: LD_VAR 0 2
16950: PUSH
16951: LD_INT 6300
16953: GREATER
16954: IFFALSE 16964
// time := 0 0$20 ;
16956: LD_ADDR_VAR 0 2
16960: PUSH
16961: LD_INT 700
16963: ST_TO_ADDR
// end ;
16964: GO 16869
// end ;
16966: PPOPN 2
16968: END
// every 0 0$30 do var cr , time ;
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
// begin time := 0 0$20 ;
16976: LD_ADDR_VAR 0 2
16980: PUSH
16981: LD_INT 700
16983: ST_TO_ADDR
// while game do
16984: LD_EXP 2
16988: IFFALSE 17117
// begin wait ( time ) ;
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16999: LD_ADDR_VAR 0 2
17003: PUSH
17004: LD_VAR 0 2
17008: PUSH
17009: LD_INT 175
17011: PUSH
17012: LD_INT 210
17014: PUSH
17015: LD_INT 280
17017: PUSH
17018: LD_INT 350
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: LIST
17025: LIST
17026: PUSH
17027: LD_OWVAR 67
17031: ARRAY
17032: PLUS
17033: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17034: LD_INT 1
17036: PPUSH
17037: LD_INT 5
17039: PPUSH
17040: CALL_OW 12
17044: PPUSH
17045: LD_INT 179
17047: PPUSH
17048: LD_INT 101
17050: PPUSH
17051: LD_INT 20
17053: PPUSH
17054: LD_INT 1
17056: PPUSH
17057: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17061: LD_INT 350
17063: PPUSH
17064: LD_INT 525
17066: PPUSH
17067: CALL_OW 12
17071: PPUSH
17072: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 5
17081: PPUSH
17082: CALL_OW 12
17086: PPUSH
17087: LD_INT 9
17089: PPUSH
17090: LD_INT 1
17092: PPUSH
17093: CALL_OW 55
// if time > 4 4$00 then
17097: LD_VAR 0 2
17101: PUSH
17102: LD_INT 8400
17104: GREATER
17105: IFFALSE 17115
// time := 0 0$30 ;
17107: LD_ADDR_VAR 0 2
17111: PUSH
17112: LD_INT 1050
17114: ST_TO_ADDR
// end ;
17115: GO 16984
// end ;
17117: PPOPN 2
17119: END
// every 0 0$30 do var cr , time ;
17120: GO 17122
17122: DISABLE
17123: LD_INT 0
17125: PPUSH
17126: PPUSH
// begin time := 0 0$10 ;
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 350
17134: ST_TO_ADDR
// while game do
17135: LD_EXP 2
17139: IFFALSE 17273
// begin wait ( time ) ;
17141: LD_VAR 0 2
17145: PPUSH
17146: CALL_OW 67
// time := time + 0 0$10 ;
17150: LD_ADDR_VAR 0 2
17154: PUSH
17155: LD_VAR 0 2
17159: PUSH
17160: LD_INT 350
17162: PLUS
17163: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17164: LD_INT 1
17166: PPUSH
17167: LD_INT 5
17169: PPUSH
17170: CALL_OW 12
17174: PPUSH
17175: LD_INT 11
17177: PPUSH
17178: LD_INT 1
17180: PPUSH
17181: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17185: LD_ADDR_VAR 0 1
17189: PUSH
17190: LD_INT 1
17192: PPUSH
17193: LD_INT 3
17195: PPUSH
17196: CALL_OW 12
17200: ST_TO_ADDR
// if cr = 1 then
17201: LD_VAR 0 1
17205: PUSH
17206: LD_INT 1
17208: EQUAL
17209: IFFALSE 17253
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17211: LD_INT 700
17213: PPUSH
17214: LD_INT 1575
17216: PPUSH
17217: CALL_OW 12
17221: PPUSH
17222: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17226: LD_INT 1
17228: PPUSH
17229: LD_INT 5
17231: PPUSH
17232: CALL_OW 12
17236: PPUSH
17237: LD_INT 34
17239: PPUSH
17240: LD_INT 50
17242: PPUSH
17243: LD_INT 7
17245: PPUSH
17246: LD_INT 1
17248: PPUSH
17249: CALL_OW 56
// end ; if time > 4 4$00 then
17253: LD_VAR 0 2
17257: PUSH
17258: LD_INT 8400
17260: GREATER
17261: IFFALSE 17271
// time := 0 0$40 ;
17263: LD_ADDR_VAR 0 2
17267: PUSH
17268: LD_INT 1400
17270: ST_TO_ADDR
// end ;
17271: GO 17135
// end ; end_of_file
17273: PPOPN 2
17275: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17276: LD_INT 0
17278: PPUSH
17279: PPUSH
// if exist_mode then
17280: LD_VAR 0 2
17284: IFFALSE 17330
// begin unit := CreateCharacter ( prefix & ident ) ;
17286: LD_ADDR_VAR 0 5
17290: PUSH
17291: LD_VAR 0 3
17295: PUSH
17296: LD_VAR 0 1
17300: STR
17301: PPUSH
17302: CALL_OW 34
17306: ST_TO_ADDR
// if unit then
17307: LD_VAR 0 5
17311: IFFALSE 17328
// DeleteCharacters ( prefix & ident ) ;
17313: LD_VAR 0 3
17317: PUSH
17318: LD_VAR 0 1
17322: STR
17323: PPUSH
17324: CALL_OW 40
// end else
17328: GO 17345
// unit := NewCharacter ( ident ) ;
17330: LD_ADDR_VAR 0 5
17334: PUSH
17335: LD_VAR 0 1
17339: PPUSH
17340: CALL_OW 25
17344: ST_TO_ADDR
// result := unit ;
17345: LD_ADDR_VAR 0 4
17349: PUSH
17350: LD_VAR 0 5
17354: ST_TO_ADDR
// end ;
17355: LD_VAR 0 4
17359: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17360: LD_INT 0
17362: PPUSH
17363: PPUSH
// if not side or not nation then
17364: LD_VAR 0 1
17368: NOT
17369: PUSH
17370: LD_VAR 0 2
17374: NOT
17375: OR
17376: IFFALSE 17380
// exit ;
17378: GO 18148
// case nation of nation_american :
17380: LD_VAR 0 2
17384: PUSH
17385: LD_INT 1
17387: DOUBLE
17388: EQUAL
17389: IFTRUE 17393
17391: GO 17607
17393: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17394: LD_ADDR_VAR 0 4
17398: PUSH
17399: LD_INT 35
17401: PUSH
17402: LD_INT 45
17404: PUSH
17405: LD_INT 46
17407: PUSH
17408: LD_INT 47
17410: PUSH
17411: LD_INT 82
17413: PUSH
17414: LD_INT 83
17416: PUSH
17417: LD_INT 84
17419: PUSH
17420: LD_INT 85
17422: PUSH
17423: LD_INT 86
17425: PUSH
17426: LD_INT 1
17428: PUSH
17429: LD_INT 2
17431: PUSH
17432: LD_INT 6
17434: PUSH
17435: LD_INT 15
17437: PUSH
17438: LD_INT 16
17440: PUSH
17441: LD_INT 7
17443: PUSH
17444: LD_INT 12
17446: PUSH
17447: LD_INT 13
17449: PUSH
17450: LD_INT 10
17452: PUSH
17453: LD_INT 14
17455: PUSH
17456: LD_INT 20
17458: PUSH
17459: LD_INT 21
17461: PUSH
17462: LD_INT 22
17464: PUSH
17465: LD_INT 25
17467: PUSH
17468: LD_INT 32
17470: PUSH
17471: LD_INT 27
17473: PUSH
17474: LD_INT 36
17476: PUSH
17477: LD_INT 69
17479: PUSH
17480: LD_INT 39
17482: PUSH
17483: LD_INT 34
17485: PUSH
17486: LD_INT 40
17488: PUSH
17489: LD_INT 48
17491: PUSH
17492: LD_INT 49
17494: PUSH
17495: LD_INT 50
17497: PUSH
17498: LD_INT 51
17500: PUSH
17501: LD_INT 52
17503: PUSH
17504: LD_INT 53
17506: PUSH
17507: LD_INT 54
17509: PUSH
17510: LD_INT 55
17512: PUSH
17513: LD_INT 56
17515: PUSH
17516: LD_INT 57
17518: PUSH
17519: LD_INT 58
17521: PUSH
17522: LD_INT 59
17524: PUSH
17525: LD_INT 60
17527: PUSH
17528: LD_INT 61
17530: PUSH
17531: LD_INT 62
17533: PUSH
17534: LD_INT 80
17536: PUSH
17537: LD_INT 82
17539: PUSH
17540: LD_INT 83
17542: PUSH
17543: LD_INT 84
17545: PUSH
17546: LD_INT 85
17548: PUSH
17549: LD_INT 86
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: LIST
17556: LIST
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: LIST
17593: LIST
17594: LIST
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: ST_TO_ADDR
17605: GO 18072
17607: LD_INT 2
17609: DOUBLE
17610: EQUAL
17611: IFTRUE 17615
17613: GO 17841
17615: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
17616: LD_ADDR_VAR 0 4
17620: PUSH
17621: LD_INT 35
17623: PUSH
17624: LD_INT 45
17626: PUSH
17627: LD_INT 46
17629: PUSH
17630: LD_INT 47
17632: PUSH
17633: LD_INT 82
17635: PUSH
17636: LD_INT 83
17638: PUSH
17639: LD_INT 84
17641: PUSH
17642: LD_INT 85
17644: PUSH
17645: LD_INT 87
17647: PUSH
17648: LD_INT 70
17650: PUSH
17651: LD_INT 1
17653: PUSH
17654: LD_INT 11
17656: PUSH
17657: LD_INT 3
17659: PUSH
17660: LD_INT 4
17662: PUSH
17663: LD_INT 5
17665: PUSH
17666: LD_INT 6
17668: PUSH
17669: LD_INT 15
17671: PUSH
17672: LD_INT 18
17674: PUSH
17675: LD_INT 7
17677: PUSH
17678: LD_INT 17
17680: PUSH
17681: LD_INT 8
17683: PUSH
17684: LD_INT 20
17686: PUSH
17687: LD_INT 21
17689: PUSH
17690: LD_INT 22
17692: PUSH
17693: LD_INT 72
17695: PUSH
17696: LD_INT 26
17698: PUSH
17699: LD_INT 69
17701: PUSH
17702: LD_INT 39
17704: PUSH
17705: LD_INT 40
17707: PUSH
17708: LD_INT 41
17710: PUSH
17711: LD_INT 42
17713: PUSH
17714: LD_INT 43
17716: PUSH
17717: LD_INT 48
17719: PUSH
17720: LD_INT 49
17722: PUSH
17723: LD_INT 50
17725: PUSH
17726: LD_INT 51
17728: PUSH
17729: LD_INT 52
17731: PUSH
17732: LD_INT 53
17734: PUSH
17735: LD_INT 54
17737: PUSH
17738: LD_INT 55
17740: PUSH
17741: LD_INT 56
17743: PUSH
17744: LD_INT 60
17746: PUSH
17747: LD_INT 61
17749: PUSH
17750: LD_INT 62
17752: PUSH
17753: LD_INT 66
17755: PUSH
17756: LD_INT 67
17758: PUSH
17759: LD_INT 68
17761: PUSH
17762: LD_INT 81
17764: PUSH
17765: LD_INT 82
17767: PUSH
17768: LD_INT 83
17770: PUSH
17771: LD_INT 84
17773: PUSH
17774: LD_INT 85
17776: PUSH
17777: LD_INT 87
17779: PUSH
17780: LD_INT 88
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: LIST
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: ST_TO_ADDR
17839: GO 18072
17841: LD_INT 3
17843: DOUBLE
17844: EQUAL
17845: IFTRUE 17849
17847: GO 18071
17849: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
17850: LD_ADDR_VAR 0 4
17854: PUSH
17855: LD_INT 46
17857: PUSH
17858: LD_INT 47
17860: PUSH
17861: LD_INT 1
17863: PUSH
17864: LD_INT 2
17866: PUSH
17867: LD_INT 82
17869: PUSH
17870: LD_INT 83
17872: PUSH
17873: LD_INT 84
17875: PUSH
17876: LD_INT 85
17878: PUSH
17879: LD_INT 86
17881: PUSH
17882: LD_INT 11
17884: PUSH
17885: LD_INT 9
17887: PUSH
17888: LD_INT 20
17890: PUSH
17891: LD_INT 19
17893: PUSH
17894: LD_INT 21
17896: PUSH
17897: LD_INT 24
17899: PUSH
17900: LD_INT 22
17902: PUSH
17903: LD_INT 25
17905: PUSH
17906: LD_INT 28
17908: PUSH
17909: LD_INT 29
17911: PUSH
17912: LD_INT 30
17914: PUSH
17915: LD_INT 31
17917: PUSH
17918: LD_INT 37
17920: PUSH
17921: LD_INT 38
17923: PUSH
17924: LD_INT 32
17926: PUSH
17927: LD_INT 27
17929: PUSH
17930: LD_INT 33
17932: PUSH
17933: LD_INT 69
17935: PUSH
17936: LD_INT 39
17938: PUSH
17939: LD_INT 34
17941: PUSH
17942: LD_INT 40
17944: PUSH
17945: LD_INT 71
17947: PUSH
17948: LD_INT 23
17950: PUSH
17951: LD_INT 44
17953: PUSH
17954: LD_INT 48
17956: PUSH
17957: LD_INT 49
17959: PUSH
17960: LD_INT 50
17962: PUSH
17963: LD_INT 51
17965: PUSH
17966: LD_INT 52
17968: PUSH
17969: LD_INT 53
17971: PUSH
17972: LD_INT 54
17974: PUSH
17975: LD_INT 55
17977: PUSH
17978: LD_INT 56
17980: PUSH
17981: LD_INT 57
17983: PUSH
17984: LD_INT 58
17986: PUSH
17987: LD_INT 59
17989: PUSH
17990: LD_INT 63
17992: PUSH
17993: LD_INT 64
17995: PUSH
17996: LD_INT 65
17998: PUSH
17999: LD_INT 82
18001: PUSH
18002: LD_INT 83
18004: PUSH
18005: LD_INT 84
18007: PUSH
18008: LD_INT 85
18010: PUSH
18011: LD_INT 86
18013: PUSH
18014: EMPTY
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: LIST
18058: LIST
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: LIST
18067: LIST
18068: ST_TO_ADDR
18069: GO 18072
18071: POP
// if state > - 1 and state < 3 then
18072: LD_VAR 0 3
18076: PUSH
18077: LD_INT 1
18079: NEG
18080: GREATER
18081: PUSH
18082: LD_VAR 0 3
18086: PUSH
18087: LD_INT 3
18089: LESS
18090: AND
18091: IFFALSE 18148
// for i in result do
18093: LD_ADDR_VAR 0 5
18097: PUSH
18098: LD_VAR 0 4
18102: PUSH
18103: FOR_IN
18104: IFFALSE 18146
// if GetTech ( i , side ) <> state then
18106: LD_VAR 0 5
18110: PPUSH
18111: LD_VAR 0 1
18115: PPUSH
18116: CALL_OW 321
18120: PUSH
18121: LD_VAR 0 3
18125: NONEQUAL
18126: IFFALSE 18144
// result := result diff i ;
18128: LD_ADDR_VAR 0 4
18132: PUSH
18133: LD_VAR 0 4
18137: PUSH
18138: LD_VAR 0 5
18142: DIFF
18143: ST_TO_ADDR
18144: GO 18103
18146: POP
18147: POP
// end ;
18148: LD_VAR 0 4
18152: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18153: LD_INT 0
18155: PPUSH
18156: PPUSH
18157: PPUSH
// result := true ;
18158: LD_ADDR_VAR 0 3
18162: PUSH
18163: LD_INT 1
18165: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18166: LD_ADDR_VAR 0 5
18170: PUSH
18171: LD_VAR 0 2
18175: PPUSH
18176: CALL_OW 480
18180: ST_TO_ADDR
// if not tmp then
18181: LD_VAR 0 5
18185: NOT
18186: IFFALSE 18190
// exit ;
18188: GO 18239
// for i in tmp do
18190: LD_ADDR_VAR 0 4
18194: PUSH
18195: LD_VAR 0 5
18199: PUSH
18200: FOR_IN
18201: IFFALSE 18237
// if GetTech ( i , side ) <> state_researched then
18203: LD_VAR 0 4
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: CALL_OW 321
18217: PUSH
18218: LD_INT 2
18220: NONEQUAL
18221: IFFALSE 18235
// begin result := false ;
18223: LD_ADDR_VAR 0 3
18227: PUSH
18228: LD_INT 0
18230: ST_TO_ADDR
// exit ;
18231: POP
18232: POP
18233: GO 18239
// end ;
18235: GO 18200
18237: POP
18238: POP
// end ;
18239: LD_VAR 0 3
18243: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18244: LD_INT 0
18246: PPUSH
18247: PPUSH
18248: PPUSH
18249: PPUSH
18250: PPUSH
18251: PPUSH
18252: PPUSH
18253: PPUSH
18254: PPUSH
18255: PPUSH
18256: PPUSH
18257: PPUSH
18258: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18259: LD_VAR 0 1
18263: NOT
18264: PUSH
18265: LD_VAR 0 1
18269: PPUSH
18270: CALL_OW 257
18274: PUSH
18275: LD_INT 9
18277: NONEQUAL
18278: OR
18279: IFFALSE 18283
// exit ;
18281: GO 18856
// side := GetSide ( unit ) ;
18283: LD_ADDR_VAR 0 9
18287: PUSH
18288: LD_VAR 0 1
18292: PPUSH
18293: CALL_OW 255
18297: ST_TO_ADDR
// tech_space := tech_spacanom ;
18298: LD_ADDR_VAR 0 12
18302: PUSH
18303: LD_INT 29
18305: ST_TO_ADDR
// tech_time := tech_taurad ;
18306: LD_ADDR_VAR 0 13
18310: PUSH
18311: LD_INT 28
18313: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18314: LD_ADDR_VAR 0 11
18318: PUSH
18319: LD_VAR 0 1
18323: PPUSH
18324: CALL_OW 310
18328: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18329: LD_VAR 0 11
18333: PPUSH
18334: CALL_OW 247
18338: PUSH
18339: LD_INT 2
18341: EQUAL
18342: IFFALSE 18346
// exit ;
18344: GO 18856
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18346: LD_ADDR_VAR 0 8
18350: PUSH
18351: LD_INT 81
18353: PUSH
18354: LD_VAR 0 9
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PUSH
18363: LD_INT 3
18365: PUSH
18366: LD_INT 21
18368: PUSH
18369: LD_INT 3
18371: PUSH
18372: EMPTY
18373: LIST
18374: LIST
18375: PUSH
18376: EMPTY
18377: LIST
18378: LIST
18379: PUSH
18380: EMPTY
18381: LIST
18382: LIST
18383: PPUSH
18384: CALL_OW 69
18388: ST_TO_ADDR
// if not tmp then
18389: LD_VAR 0 8
18393: NOT
18394: IFFALSE 18398
// exit ;
18396: GO 18856
// if in_unit then
18398: LD_VAR 0 11
18402: IFFALSE 18426
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18404: LD_ADDR_VAR 0 10
18408: PUSH
18409: LD_VAR 0 8
18413: PPUSH
18414: LD_VAR 0 11
18418: PPUSH
18419: CALL_OW 74
18423: ST_TO_ADDR
18424: GO 18446
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18426: LD_ADDR_VAR 0 10
18430: PUSH
18431: LD_VAR 0 8
18435: PPUSH
18436: LD_VAR 0 1
18440: PPUSH
18441: CALL_OW 74
18445: ST_TO_ADDR
// if not enemy then
18446: LD_VAR 0 10
18450: NOT
18451: IFFALSE 18455
// exit ;
18453: GO 18856
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18455: LD_VAR 0 11
18459: PUSH
18460: LD_VAR 0 11
18464: PPUSH
18465: LD_VAR 0 10
18469: PPUSH
18470: CALL_OW 296
18474: PUSH
18475: LD_INT 13
18477: GREATER
18478: AND
18479: PUSH
18480: LD_VAR 0 1
18484: PPUSH
18485: LD_VAR 0 10
18489: PPUSH
18490: CALL_OW 296
18494: PUSH
18495: LD_INT 12
18497: GREATER
18498: OR
18499: IFFALSE 18503
// exit ;
18501: GO 18856
// missile := [ 1 ] ;
18503: LD_ADDR_VAR 0 14
18507: PUSH
18508: LD_INT 1
18510: PUSH
18511: EMPTY
18512: LIST
18513: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18514: LD_VAR 0 9
18518: PPUSH
18519: LD_VAR 0 12
18523: PPUSH
18524: CALL_OW 325
18528: IFFALSE 18557
// missile := Replace ( missile , missile + 1 , 2 ) ;
18530: LD_ADDR_VAR 0 14
18534: PUSH
18535: LD_VAR 0 14
18539: PPUSH
18540: LD_VAR 0 14
18544: PUSH
18545: LD_INT 1
18547: PLUS
18548: PPUSH
18549: LD_INT 2
18551: PPUSH
18552: CALL_OW 1
18556: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18557: LD_VAR 0 9
18561: PPUSH
18562: LD_VAR 0 13
18566: PPUSH
18567: CALL_OW 325
18571: PUSH
18572: LD_VAR 0 10
18576: PPUSH
18577: CALL_OW 255
18581: PPUSH
18582: LD_VAR 0 13
18586: PPUSH
18587: CALL_OW 325
18591: NOT
18592: AND
18593: IFFALSE 18622
// missile := Replace ( missile , missile + 1 , 3 ) ;
18595: LD_ADDR_VAR 0 14
18599: PUSH
18600: LD_VAR 0 14
18604: PPUSH
18605: LD_VAR 0 14
18609: PUSH
18610: LD_INT 1
18612: PLUS
18613: PPUSH
18614: LD_INT 3
18616: PPUSH
18617: CALL_OW 1
18621: ST_TO_ADDR
// if missile < 2 then
18622: LD_VAR 0 14
18626: PUSH
18627: LD_INT 2
18629: LESS
18630: IFFALSE 18634
// exit ;
18632: GO 18856
// x := GetX ( enemy ) ;
18634: LD_ADDR_VAR 0 4
18638: PUSH
18639: LD_VAR 0 10
18643: PPUSH
18644: CALL_OW 250
18648: ST_TO_ADDR
// y := GetY ( enemy ) ;
18649: LD_ADDR_VAR 0 5
18653: PUSH
18654: LD_VAR 0 10
18658: PPUSH
18659: CALL_OW 251
18663: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18664: LD_ADDR_VAR 0 6
18668: PUSH
18669: LD_VAR 0 4
18673: PUSH
18674: LD_INT 1
18676: NEG
18677: PPUSH
18678: LD_INT 1
18680: PPUSH
18681: CALL_OW 12
18685: PLUS
18686: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18687: LD_ADDR_VAR 0 7
18691: PUSH
18692: LD_VAR 0 5
18696: PUSH
18697: LD_INT 1
18699: NEG
18700: PPUSH
18701: LD_INT 1
18703: PPUSH
18704: CALL_OW 12
18708: PLUS
18709: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18710: LD_VAR 0 6
18714: PPUSH
18715: LD_VAR 0 7
18719: PPUSH
18720: CALL_OW 488
18724: NOT
18725: IFFALSE 18747
// begin _x := x ;
18727: LD_ADDR_VAR 0 6
18731: PUSH
18732: LD_VAR 0 4
18736: ST_TO_ADDR
// _y := y ;
18737: LD_ADDR_VAR 0 7
18741: PUSH
18742: LD_VAR 0 5
18746: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18747: LD_ADDR_VAR 0 3
18751: PUSH
18752: LD_INT 1
18754: PPUSH
18755: LD_VAR 0 14
18759: PPUSH
18760: CALL_OW 12
18764: ST_TO_ADDR
// case i of 1 :
18765: LD_VAR 0 3
18769: PUSH
18770: LD_INT 1
18772: DOUBLE
18773: EQUAL
18774: IFTRUE 18778
18776: GO 18795
18778: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18779: LD_VAR 0 1
18783: PPUSH
18784: LD_VAR 0 10
18788: PPUSH
18789: CALL_OW 115
18793: GO 18856
18795: LD_INT 2
18797: DOUBLE
18798: EQUAL
18799: IFTRUE 18803
18801: GO 18825
18803: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
18804: LD_VAR 0 1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: LD_VAR 0 7
18818: PPUSH
18819: CALL_OW 153
18823: GO 18856
18825: LD_INT 3
18827: DOUBLE
18828: EQUAL
18829: IFTRUE 18833
18831: GO 18855
18833: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
18834: LD_VAR 0 1
18838: PPUSH
18839: LD_VAR 0 6
18843: PPUSH
18844: LD_VAR 0 7
18848: PPUSH
18849: CALL_OW 154
18853: GO 18856
18855: POP
// end ;
18856: LD_VAR 0 2
18860: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
18861: LD_INT 0
18863: PPUSH
18864: PPUSH
18865: PPUSH
18866: PPUSH
18867: PPUSH
18868: PPUSH
// if not unit or not building then
18869: LD_VAR 0 1
18873: NOT
18874: PUSH
18875: LD_VAR 0 2
18879: NOT
18880: OR
18881: IFFALSE 18885
// exit ;
18883: GO 19043
// x := GetX ( building ) ;
18885: LD_ADDR_VAR 0 5
18889: PUSH
18890: LD_VAR 0 2
18894: PPUSH
18895: CALL_OW 250
18899: ST_TO_ADDR
// y := GetY ( building ) ;
18900: LD_ADDR_VAR 0 6
18904: PUSH
18905: LD_VAR 0 2
18909: PPUSH
18910: CALL_OW 251
18914: ST_TO_ADDR
// for i = 0 to 5 do
18915: LD_ADDR_VAR 0 4
18919: PUSH
18920: DOUBLE
18921: LD_INT 0
18923: DEC
18924: ST_TO_ADDR
18925: LD_INT 5
18927: PUSH
18928: FOR_TO
18929: IFFALSE 19041
// begin _x := ShiftX ( x , i , 3 ) ;
18931: LD_ADDR_VAR 0 7
18935: PUSH
18936: LD_VAR 0 5
18940: PPUSH
18941: LD_VAR 0 4
18945: PPUSH
18946: LD_INT 3
18948: PPUSH
18949: CALL_OW 272
18953: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
18954: LD_ADDR_VAR 0 8
18958: PUSH
18959: LD_VAR 0 6
18963: PPUSH
18964: LD_VAR 0 4
18968: PPUSH
18969: LD_INT 3
18971: PPUSH
18972: CALL_OW 273
18976: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18977: LD_VAR 0 7
18981: PPUSH
18982: LD_VAR 0 8
18986: PPUSH
18987: CALL_OW 488
18991: NOT
18992: IFFALSE 18996
// continue ;
18994: GO 18928
// if HexInfo ( _x , _y ) = 0 then
18996: LD_VAR 0 7
19000: PPUSH
19001: LD_VAR 0 8
19005: PPUSH
19006: CALL_OW 428
19010: PUSH
19011: LD_INT 0
19013: EQUAL
19014: IFFALSE 19039
// begin ComMoveXY ( unit , _x , _y ) ;
19016: LD_VAR 0 1
19020: PPUSH
19021: LD_VAR 0 7
19025: PPUSH
19026: LD_VAR 0 8
19030: PPUSH
19031: CALL_OW 111
// exit ;
19035: POP
19036: POP
19037: GO 19043
// end ; end ;
19039: GO 18928
19041: POP
19042: POP
// end ;
19043: LD_VAR 0 3
19047: RET
// export function ScanBase ( side , base_area ) ; begin
19048: LD_INT 0
19050: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19051: LD_ADDR_VAR 0 3
19055: PUSH
19056: LD_VAR 0 2
19060: PPUSH
19061: LD_INT 81
19063: PUSH
19064: LD_VAR 0 1
19068: PUSH
19069: EMPTY
19070: LIST
19071: LIST
19072: PPUSH
19073: CALL_OW 70
19077: ST_TO_ADDR
// end ;
19078: LD_VAR 0 3
19082: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19083: LD_INT 0
19085: PPUSH
19086: PPUSH
19087: PPUSH
19088: PPUSH
// result := false ;
19089: LD_ADDR_VAR 0 2
19093: PUSH
19094: LD_INT 0
19096: ST_TO_ADDR
// side := GetSide ( unit ) ;
19097: LD_ADDR_VAR 0 3
19101: PUSH
19102: LD_VAR 0 1
19106: PPUSH
19107: CALL_OW 255
19111: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19112: LD_ADDR_VAR 0 4
19116: PUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: CALL_OW 248
19126: ST_TO_ADDR
// case nat of 1 :
19127: LD_VAR 0 4
19131: PUSH
19132: LD_INT 1
19134: DOUBLE
19135: EQUAL
19136: IFTRUE 19140
19138: GO 19151
19140: POP
// tech := tech_lassight ; 2 :
19141: LD_ADDR_VAR 0 5
19145: PUSH
19146: LD_INT 12
19148: ST_TO_ADDR
19149: GO 19190
19151: LD_INT 2
19153: DOUBLE
19154: EQUAL
19155: IFTRUE 19159
19157: GO 19170
19159: POP
// tech := tech_mortar ; 3 :
19160: LD_ADDR_VAR 0 5
19164: PUSH
19165: LD_INT 41
19167: ST_TO_ADDR
19168: GO 19190
19170: LD_INT 3
19172: DOUBLE
19173: EQUAL
19174: IFTRUE 19178
19176: GO 19189
19178: POP
// tech := tech_bazooka ; end ;
19179: LD_ADDR_VAR 0 5
19183: PUSH
19184: LD_INT 44
19186: ST_TO_ADDR
19187: GO 19190
19189: POP
// if Researched ( side , tech ) then
19190: LD_VAR 0 3
19194: PPUSH
19195: LD_VAR 0 5
19199: PPUSH
19200: CALL_OW 325
19204: IFFALSE 19231
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19206: LD_ADDR_VAR 0 2
19210: PUSH
19211: LD_INT 5
19213: PUSH
19214: LD_INT 8
19216: PUSH
19217: LD_INT 9
19219: PUSH
19220: EMPTY
19221: LIST
19222: LIST
19223: LIST
19224: PUSH
19225: LD_VAR 0 4
19229: ARRAY
19230: ST_TO_ADDR
// end ;
19231: LD_VAR 0 2
19235: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19236: LD_INT 0
19238: PPUSH
19239: PPUSH
19240: PPUSH
// if not mines then
19241: LD_VAR 0 2
19245: NOT
19246: IFFALSE 19250
// exit ;
19248: GO 19394
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19250: LD_ADDR_VAR 0 5
19254: PUSH
19255: LD_INT 81
19257: PUSH
19258: LD_VAR 0 1
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: PUSH
19267: LD_INT 3
19269: PUSH
19270: LD_INT 21
19272: PUSH
19273: LD_INT 3
19275: PUSH
19276: EMPTY
19277: LIST
19278: LIST
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: EMPTY
19285: LIST
19286: LIST
19287: PPUSH
19288: CALL_OW 69
19292: ST_TO_ADDR
// for i in mines do
19293: LD_ADDR_VAR 0 4
19297: PUSH
19298: LD_VAR 0 2
19302: PUSH
19303: FOR_IN
19304: IFFALSE 19392
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19306: LD_VAR 0 4
19310: PUSH
19311: LD_INT 1
19313: ARRAY
19314: PPUSH
19315: LD_VAR 0 4
19319: PUSH
19320: LD_INT 2
19322: ARRAY
19323: PPUSH
19324: CALL_OW 458
19328: NOT
19329: IFFALSE 19333
// continue ;
19331: GO 19303
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19333: LD_VAR 0 4
19337: PUSH
19338: LD_INT 1
19340: ARRAY
19341: PPUSH
19342: LD_VAR 0 4
19346: PUSH
19347: LD_INT 2
19349: ARRAY
19350: PPUSH
19351: CALL_OW 428
19355: PUSH
19356: LD_VAR 0 5
19360: IN
19361: IFFALSE 19390
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19363: LD_VAR 0 4
19367: PUSH
19368: LD_INT 1
19370: ARRAY
19371: PPUSH
19372: LD_VAR 0 4
19376: PUSH
19377: LD_INT 2
19379: ARRAY
19380: PPUSH
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 456
// end ;
19390: GO 19303
19392: POP
19393: POP
// end ;
19394: LD_VAR 0 3
19398: RET
// export function Count ( array ) ; begin
19399: LD_INT 0
19401: PPUSH
// result := array + 0 ;
19402: LD_ADDR_VAR 0 2
19406: PUSH
19407: LD_VAR 0 1
19411: PUSH
19412: LD_INT 0
19414: PLUS
19415: ST_TO_ADDR
// end ;
19416: LD_VAR 0 2
19420: RET
// export function IsEmpty ( building ) ; begin
19421: LD_INT 0
19423: PPUSH
// if not building then
19424: LD_VAR 0 1
19428: NOT
19429: IFFALSE 19433
// exit ;
19431: GO 19476
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19433: LD_ADDR_VAR 0 2
19437: PUSH
19438: LD_VAR 0 1
19442: PUSH
19443: LD_INT 22
19445: PUSH
19446: LD_VAR 0 1
19450: PPUSH
19451: CALL_OW 255
19455: PUSH
19456: EMPTY
19457: LIST
19458: LIST
19459: PUSH
19460: LD_INT 58
19462: PUSH
19463: EMPTY
19464: LIST
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: PPUSH
19470: CALL_OW 69
19474: IN
19475: ST_TO_ADDR
// end ;
19476: LD_VAR 0 2
19480: RET
// export function IsNotFull ( building ) ; var places ; begin
19481: LD_INT 0
19483: PPUSH
19484: PPUSH
// if not building then
19485: LD_VAR 0 1
19489: NOT
19490: IFFALSE 19494
// exit ;
19492: GO 19522
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19494: LD_ADDR_VAR 0 2
19498: PUSH
19499: LD_VAR 0 1
19503: PPUSH
19504: LD_INT 3
19506: PUSH
19507: LD_INT 62
19509: PUSH
19510: EMPTY
19511: LIST
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: PPUSH
19517: CALL_OW 72
19521: ST_TO_ADDR
// end ;
19522: LD_VAR 0 2
19526: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19527: LD_INT 0
19529: PPUSH
19530: PPUSH
19531: PPUSH
19532: PPUSH
// tmp := [ ] ;
19533: LD_ADDR_VAR 0 3
19537: PUSH
19538: EMPTY
19539: ST_TO_ADDR
// list := [ ] ;
19540: LD_ADDR_VAR 0 5
19544: PUSH
19545: EMPTY
19546: ST_TO_ADDR
// for i = 16 to 25 do
19547: LD_ADDR_VAR 0 4
19551: PUSH
19552: DOUBLE
19553: LD_INT 16
19555: DEC
19556: ST_TO_ADDR
19557: LD_INT 25
19559: PUSH
19560: FOR_TO
19561: IFFALSE 19634
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19563: LD_ADDR_VAR 0 3
19567: PUSH
19568: LD_VAR 0 3
19572: PUSH
19573: LD_INT 22
19575: PUSH
19576: LD_VAR 0 1
19580: PPUSH
19581: CALL_OW 255
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: PUSH
19590: LD_INT 91
19592: PUSH
19593: LD_VAR 0 1
19597: PUSH
19598: LD_INT 6
19600: PUSH
19601: EMPTY
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: LD_INT 30
19608: PUSH
19609: LD_VAR 0 4
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: LIST
19622: PUSH
19623: EMPTY
19624: LIST
19625: PPUSH
19626: CALL_OW 69
19630: ADD
19631: ST_TO_ADDR
19632: GO 19560
19634: POP
19635: POP
// for i = 1 to tmp do
19636: LD_ADDR_VAR 0 4
19640: PUSH
19641: DOUBLE
19642: LD_INT 1
19644: DEC
19645: ST_TO_ADDR
19646: LD_VAR 0 3
19650: PUSH
19651: FOR_TO
19652: IFFALSE 19740
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19654: LD_ADDR_VAR 0 5
19658: PUSH
19659: LD_VAR 0 5
19663: PUSH
19664: LD_VAR 0 3
19668: PUSH
19669: LD_VAR 0 4
19673: ARRAY
19674: PPUSH
19675: CALL_OW 266
19679: PUSH
19680: LD_VAR 0 3
19684: PUSH
19685: LD_VAR 0 4
19689: ARRAY
19690: PPUSH
19691: CALL_OW 250
19695: PUSH
19696: LD_VAR 0 3
19700: PUSH
19701: LD_VAR 0 4
19705: ARRAY
19706: PPUSH
19707: CALL_OW 251
19711: PUSH
19712: LD_VAR 0 3
19716: PUSH
19717: LD_VAR 0 4
19721: ARRAY
19722: PPUSH
19723: CALL_OW 254
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: PUSH
19734: EMPTY
19735: LIST
19736: ADD
19737: ST_TO_ADDR
19738: GO 19651
19740: POP
19741: POP
// result := list ;
19742: LD_ADDR_VAR 0 2
19746: PUSH
19747: LD_VAR 0 5
19751: ST_TO_ADDR
// end ;
19752: LD_VAR 0 2
19756: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19757: LD_INT 0
19759: PPUSH
19760: PPUSH
19761: PPUSH
19762: PPUSH
19763: PPUSH
19764: PPUSH
19765: PPUSH
// if not factory then
19766: LD_VAR 0 1
19770: NOT
19771: IFFALSE 19775
// exit ;
19773: GO 20368
// if control = control_apeman then
19775: LD_VAR 0 4
19779: PUSH
19780: LD_INT 5
19782: EQUAL
19783: IFFALSE 19892
// begin tmp := UnitsInside ( factory ) ;
19785: LD_ADDR_VAR 0 8
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 313
19799: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19800: LD_VAR 0 8
19804: PPUSH
19805: LD_INT 25
19807: PUSH
19808: LD_INT 12
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: PPUSH
19815: CALL_OW 72
19819: NOT
19820: IFFALSE 19830
// control := control_manual ;
19822: LD_ADDR_VAR 0 4
19826: PUSH
19827: LD_INT 1
19829: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19830: LD_ADDR_VAR 0 8
19834: PUSH
19835: LD_VAR 0 1
19839: PPUSH
19840: CALL 19527 0 1
19844: ST_TO_ADDR
// if tmp then
19845: LD_VAR 0 8
19849: IFFALSE 19892
// begin for i in tmp do
19851: LD_ADDR_VAR 0 7
19855: PUSH
19856: LD_VAR 0 8
19860: PUSH
19861: FOR_IN
19862: IFFALSE 19890
// if i [ 1 ] = b_ext_radio then
19864: LD_VAR 0 7
19868: PUSH
19869: LD_INT 1
19871: ARRAY
19872: PUSH
19873: LD_INT 22
19875: EQUAL
19876: IFFALSE 19888
// begin control := control_remote ;
19878: LD_ADDR_VAR 0 4
19882: PUSH
19883: LD_INT 2
19885: ST_TO_ADDR
// break ;
19886: GO 19890
// end ;
19888: GO 19861
19890: POP
19891: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19892: LD_VAR 0 1
19896: PPUSH
19897: LD_VAR 0 2
19901: PPUSH
19902: LD_VAR 0 3
19906: PPUSH
19907: LD_VAR 0 4
19911: PPUSH
19912: LD_VAR 0 5
19916: PPUSH
19917: CALL_OW 448
19921: IFFALSE 19956
// begin result := [ chassis , engine , control , weapon ] ;
19923: LD_ADDR_VAR 0 6
19927: PUSH
19928: LD_VAR 0 2
19932: PUSH
19933: LD_VAR 0 3
19937: PUSH
19938: LD_VAR 0 4
19942: PUSH
19943: LD_VAR 0 5
19947: PUSH
19948: EMPTY
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: ST_TO_ADDR
// exit ;
19954: GO 20368
// end ; _chassis := AvailableChassisList ( factory ) ;
19956: LD_ADDR_VAR 0 9
19960: PUSH
19961: LD_VAR 0 1
19965: PPUSH
19966: CALL_OW 475
19970: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19971: LD_ADDR_VAR 0 11
19975: PUSH
19976: LD_VAR 0 1
19980: PPUSH
19981: CALL_OW 476
19985: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19986: LD_ADDR_VAR 0 12
19990: PUSH
19991: LD_VAR 0 1
19995: PPUSH
19996: CALL_OW 477
20000: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20001: LD_ADDR_VAR 0 10
20005: PUSH
20006: LD_VAR 0 1
20010: PPUSH
20011: CALL_OW 478
20015: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20016: LD_VAR 0 9
20020: NOT
20021: PUSH
20022: LD_VAR 0 11
20026: NOT
20027: OR
20028: PUSH
20029: LD_VAR 0 12
20033: NOT
20034: OR
20035: PUSH
20036: LD_VAR 0 10
20040: NOT
20041: OR
20042: IFFALSE 20077
// begin result := [ chassis , engine , control , weapon ] ;
20044: LD_ADDR_VAR 0 6
20048: PUSH
20049: LD_VAR 0 2
20053: PUSH
20054: LD_VAR 0 3
20058: PUSH
20059: LD_VAR 0 4
20063: PUSH
20064: LD_VAR 0 5
20068: PUSH
20069: EMPTY
20070: LIST
20071: LIST
20072: LIST
20073: LIST
20074: ST_TO_ADDR
// exit ;
20075: GO 20368
// end ; if not chassis in _chassis then
20077: LD_VAR 0 2
20081: PUSH
20082: LD_VAR 0 9
20086: IN
20087: NOT
20088: IFFALSE 20114
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 9
20099: PUSH
20100: LD_INT 1
20102: PPUSH
20103: LD_VAR 0 9
20107: PPUSH
20108: CALL_OW 12
20112: ARRAY
20113: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20114: LD_VAR 0 2
20118: PPUSH
20119: LD_VAR 0 3
20123: PPUSH
20124: CALL 20373 0 2
20128: NOT
20129: IFFALSE 20188
// repeat engine := _engine [ 1 ] ;
20131: LD_ADDR_VAR 0 3
20135: PUSH
20136: LD_VAR 0 11
20140: PUSH
20141: LD_INT 1
20143: ARRAY
20144: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20145: LD_ADDR_VAR 0 11
20149: PUSH
20150: LD_VAR 0 11
20154: PPUSH
20155: LD_INT 1
20157: PPUSH
20158: CALL_OW 3
20162: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20163: LD_VAR 0 2
20167: PPUSH
20168: LD_VAR 0 3
20172: PPUSH
20173: CALL 20373 0 2
20177: PUSH
20178: LD_VAR 0 11
20182: PUSH
20183: EMPTY
20184: EQUAL
20185: OR
20186: IFFALSE 20131
// if not control in _control then
20188: LD_VAR 0 4
20192: PUSH
20193: LD_VAR 0 12
20197: IN
20198: NOT
20199: IFFALSE 20225
// control := _control [ rand ( 1 , _control ) ] ;
20201: LD_ADDR_VAR 0 4
20205: PUSH
20206: LD_VAR 0 12
20210: PUSH
20211: LD_INT 1
20213: PPUSH
20214: LD_VAR 0 12
20218: PPUSH
20219: CALL_OW 12
20223: ARRAY
20224: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20225: LD_VAR 0 2
20229: PPUSH
20230: LD_VAR 0 5
20234: PPUSH
20235: CALL 20593 0 2
20239: NOT
20240: IFFALSE 20299
// repeat weapon := _weapon [ 1 ] ;
20242: LD_ADDR_VAR 0 5
20246: PUSH
20247: LD_VAR 0 10
20251: PUSH
20252: LD_INT 1
20254: ARRAY
20255: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20256: LD_ADDR_VAR 0 10
20260: PUSH
20261: LD_VAR 0 10
20265: PPUSH
20266: LD_INT 1
20268: PPUSH
20269: CALL_OW 3
20273: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20274: LD_VAR 0 2
20278: PPUSH
20279: LD_VAR 0 5
20283: PPUSH
20284: CALL 20593 0 2
20288: PUSH
20289: LD_VAR 0 10
20293: PUSH
20294: EMPTY
20295: EQUAL
20296: OR
20297: IFFALSE 20242
// result := [ ] ;
20299: LD_ADDR_VAR 0 6
20303: PUSH
20304: EMPTY
20305: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20306: LD_VAR 0 1
20310: PPUSH
20311: LD_VAR 0 2
20315: PPUSH
20316: LD_VAR 0 3
20320: PPUSH
20321: LD_VAR 0 4
20325: PPUSH
20326: LD_VAR 0 5
20330: PPUSH
20331: CALL_OW 448
20335: IFFALSE 20368
// result := [ chassis , engine , control , weapon ] ;
20337: LD_ADDR_VAR 0 6
20341: PUSH
20342: LD_VAR 0 2
20346: PUSH
20347: LD_VAR 0 3
20351: PUSH
20352: LD_VAR 0 4
20356: PUSH
20357: LD_VAR 0 5
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: ST_TO_ADDR
// end ;
20368: LD_VAR 0 6
20372: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20373: LD_INT 0
20375: PPUSH
// if not chassis or not engine then
20376: LD_VAR 0 1
20380: NOT
20381: PUSH
20382: LD_VAR 0 2
20386: NOT
20387: OR
20388: IFFALSE 20392
// exit ;
20390: GO 20588
// case engine of engine_solar :
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: DOUBLE
20400: EQUAL
20401: IFTRUE 20405
20403: GO 20443
20405: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20406: LD_ADDR_VAR 0 3
20410: PUSH
20411: LD_INT 11
20413: PUSH
20414: LD_INT 12
20416: PUSH
20417: LD_INT 13
20419: PUSH
20420: LD_INT 14
20422: PUSH
20423: LD_INT 1
20425: PUSH
20426: LD_INT 2
20428: PUSH
20429: LD_INT 3
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: ST_TO_ADDR
20441: GO 20572
20443: LD_INT 1
20445: DOUBLE
20446: EQUAL
20447: IFTRUE 20451
20449: GO 20513
20451: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20452: LD_ADDR_VAR 0 3
20456: PUSH
20457: LD_INT 11
20459: PUSH
20460: LD_INT 12
20462: PUSH
20463: LD_INT 13
20465: PUSH
20466: LD_INT 14
20468: PUSH
20469: LD_INT 1
20471: PUSH
20472: LD_INT 2
20474: PUSH
20475: LD_INT 3
20477: PUSH
20478: LD_INT 4
20480: PUSH
20481: LD_INT 5
20483: PUSH
20484: LD_INT 21
20486: PUSH
20487: LD_INT 23
20489: PUSH
20490: LD_INT 22
20492: PUSH
20493: LD_INT 24
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: LIST
20503: LIST
20504: LIST
20505: LIST
20506: LIST
20507: LIST
20508: LIST
20509: LIST
20510: ST_TO_ADDR
20511: GO 20572
20513: LD_INT 3
20515: DOUBLE
20516: EQUAL
20517: IFTRUE 20521
20519: GO 20571
20521: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20522: LD_ADDR_VAR 0 3
20526: PUSH
20527: LD_INT 13
20529: PUSH
20530: LD_INT 14
20532: PUSH
20533: LD_INT 2
20535: PUSH
20536: LD_INT 3
20538: PUSH
20539: LD_INT 4
20541: PUSH
20542: LD_INT 5
20544: PUSH
20545: LD_INT 21
20547: PUSH
20548: LD_INT 22
20550: PUSH
20551: LD_INT 23
20553: PUSH
20554: LD_INT 24
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: ST_TO_ADDR
20569: GO 20572
20571: POP
// result := ( chassis in result ) ;
20572: LD_ADDR_VAR 0 3
20576: PUSH
20577: LD_VAR 0 1
20581: PUSH
20582: LD_VAR 0 3
20586: IN
20587: ST_TO_ADDR
// end ;
20588: LD_VAR 0 3
20592: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20593: LD_INT 0
20595: PPUSH
// if not chassis or not weapon then
20596: LD_VAR 0 1
20600: NOT
20601: PUSH
20602: LD_VAR 0 2
20606: NOT
20607: OR
20608: IFFALSE 20612
// exit ;
20610: GO 21672
// case weapon of us_machine_gun :
20612: LD_VAR 0 2
20616: PUSH
20617: LD_INT 2
20619: DOUBLE
20620: EQUAL
20621: IFTRUE 20625
20623: GO 20655
20625: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20626: LD_ADDR_VAR 0 3
20630: PUSH
20631: LD_INT 1
20633: PUSH
20634: LD_INT 2
20636: PUSH
20637: LD_INT 3
20639: PUSH
20640: LD_INT 4
20642: PUSH
20643: LD_INT 5
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: ST_TO_ADDR
20653: GO 21656
20655: LD_INT 3
20657: DOUBLE
20658: EQUAL
20659: IFTRUE 20663
20661: GO 20693
20663: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20664: LD_ADDR_VAR 0 3
20668: PUSH
20669: LD_INT 1
20671: PUSH
20672: LD_INT 2
20674: PUSH
20675: LD_INT 3
20677: PUSH
20678: LD_INT 4
20680: PUSH
20681: LD_INT 5
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: LIST
20690: ST_TO_ADDR
20691: GO 21656
20693: LD_INT 11
20695: DOUBLE
20696: EQUAL
20697: IFTRUE 20701
20699: GO 20731
20701: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20702: LD_ADDR_VAR 0 3
20706: PUSH
20707: LD_INT 1
20709: PUSH
20710: LD_INT 2
20712: PUSH
20713: LD_INT 3
20715: PUSH
20716: LD_INT 4
20718: PUSH
20719: LD_INT 5
20721: PUSH
20722: EMPTY
20723: LIST
20724: LIST
20725: LIST
20726: LIST
20727: LIST
20728: ST_TO_ADDR
20729: GO 21656
20731: LD_INT 4
20733: DOUBLE
20734: EQUAL
20735: IFTRUE 20739
20737: GO 20765
20739: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20740: LD_ADDR_VAR 0 3
20744: PUSH
20745: LD_INT 2
20747: PUSH
20748: LD_INT 3
20750: PUSH
20751: LD_INT 4
20753: PUSH
20754: LD_INT 5
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: LIST
20761: LIST
20762: ST_TO_ADDR
20763: GO 21656
20765: LD_INT 5
20767: DOUBLE
20768: EQUAL
20769: IFTRUE 20773
20771: GO 20799
20773: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20774: LD_ADDR_VAR 0 3
20778: PUSH
20779: LD_INT 2
20781: PUSH
20782: LD_INT 3
20784: PUSH
20785: LD_INT 4
20787: PUSH
20788: LD_INT 5
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: ST_TO_ADDR
20797: GO 21656
20799: LD_INT 9
20801: DOUBLE
20802: EQUAL
20803: IFTRUE 20807
20805: GO 20833
20807: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20808: LD_ADDR_VAR 0 3
20812: PUSH
20813: LD_INT 2
20815: PUSH
20816: LD_INT 3
20818: PUSH
20819: LD_INT 4
20821: PUSH
20822: LD_INT 5
20824: PUSH
20825: EMPTY
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: ST_TO_ADDR
20831: GO 21656
20833: LD_INT 7
20835: DOUBLE
20836: EQUAL
20837: IFTRUE 20841
20839: GO 20867
20841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20842: LD_ADDR_VAR 0 3
20846: PUSH
20847: LD_INT 2
20849: PUSH
20850: LD_INT 3
20852: PUSH
20853: LD_INT 4
20855: PUSH
20856: LD_INT 5
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: LIST
20863: LIST
20864: ST_TO_ADDR
20865: GO 21656
20867: LD_INT 12
20869: DOUBLE
20870: EQUAL
20871: IFTRUE 20875
20873: GO 20901
20875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20876: LD_ADDR_VAR 0 3
20880: PUSH
20881: LD_INT 2
20883: PUSH
20884: LD_INT 3
20886: PUSH
20887: LD_INT 4
20889: PUSH
20890: LD_INT 5
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: ST_TO_ADDR
20899: GO 21656
20901: LD_INT 13
20903: DOUBLE
20904: EQUAL
20905: IFTRUE 20909
20907: GO 20935
20909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20910: LD_ADDR_VAR 0 3
20914: PUSH
20915: LD_INT 2
20917: PUSH
20918: LD_INT 3
20920: PUSH
20921: LD_INT 4
20923: PUSH
20924: LD_INT 5
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: LIST
20931: LIST
20932: ST_TO_ADDR
20933: GO 21656
20935: LD_INT 14
20937: DOUBLE
20938: EQUAL
20939: IFTRUE 20943
20941: GO 20961
20943: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
20944: LD_ADDR_VAR 0 3
20948: PUSH
20949: LD_INT 4
20951: PUSH
20952: LD_INT 5
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: ST_TO_ADDR
20959: GO 21656
20961: LD_INT 6
20963: DOUBLE
20964: EQUAL
20965: IFTRUE 20969
20967: GO 20987
20969: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20970: LD_ADDR_VAR 0 3
20974: PUSH
20975: LD_INT 4
20977: PUSH
20978: LD_INT 5
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: ST_TO_ADDR
20985: GO 21656
20987: LD_INT 10
20989: DOUBLE
20990: EQUAL
20991: IFTRUE 20995
20993: GO 21013
20995: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20996: LD_ADDR_VAR 0 3
21000: PUSH
21001: LD_INT 4
21003: PUSH
21004: LD_INT 5
21006: PUSH
21007: EMPTY
21008: LIST
21009: LIST
21010: ST_TO_ADDR
21011: GO 21656
21013: LD_INT 22
21015: DOUBLE
21016: EQUAL
21017: IFTRUE 21021
21019: GO 21047
21021: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_INT 11
21029: PUSH
21030: LD_INT 12
21032: PUSH
21033: LD_INT 13
21035: PUSH
21036: LD_INT 14
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: LIST
21043: LIST
21044: ST_TO_ADDR
21045: GO 21656
21047: LD_INT 23
21049: DOUBLE
21050: EQUAL
21051: IFTRUE 21055
21053: GO 21081
21055: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21056: LD_ADDR_VAR 0 3
21060: PUSH
21061: LD_INT 11
21063: PUSH
21064: LD_INT 12
21066: PUSH
21067: LD_INT 13
21069: PUSH
21070: LD_INT 14
21072: PUSH
21073: EMPTY
21074: LIST
21075: LIST
21076: LIST
21077: LIST
21078: ST_TO_ADDR
21079: GO 21656
21081: LD_INT 24
21083: DOUBLE
21084: EQUAL
21085: IFTRUE 21089
21087: GO 21115
21089: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21090: LD_ADDR_VAR 0 3
21094: PUSH
21095: LD_INT 11
21097: PUSH
21098: LD_INT 12
21100: PUSH
21101: LD_INT 13
21103: PUSH
21104: LD_INT 14
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: ST_TO_ADDR
21113: GO 21656
21115: LD_INT 30
21117: DOUBLE
21118: EQUAL
21119: IFTRUE 21123
21121: GO 21149
21123: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21124: LD_ADDR_VAR 0 3
21128: PUSH
21129: LD_INT 11
21131: PUSH
21132: LD_INT 12
21134: PUSH
21135: LD_INT 13
21137: PUSH
21138: LD_INT 14
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: LIST
21145: LIST
21146: ST_TO_ADDR
21147: GO 21656
21149: LD_INT 25
21151: DOUBLE
21152: EQUAL
21153: IFTRUE 21157
21155: GO 21175
21157: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21158: LD_ADDR_VAR 0 3
21162: PUSH
21163: LD_INT 13
21165: PUSH
21166: LD_INT 14
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: ST_TO_ADDR
21173: GO 21656
21175: LD_INT 27
21177: DOUBLE
21178: EQUAL
21179: IFTRUE 21183
21181: GO 21201
21183: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21184: LD_ADDR_VAR 0 3
21188: PUSH
21189: LD_INT 13
21191: PUSH
21192: LD_INT 14
21194: PUSH
21195: EMPTY
21196: LIST
21197: LIST
21198: ST_TO_ADDR
21199: GO 21656
21201: LD_INT 92
21203: DOUBLE
21204: EQUAL
21205: IFTRUE 21209
21207: GO 21235
21209: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21210: LD_ADDR_VAR 0 3
21214: PUSH
21215: LD_INT 11
21217: PUSH
21218: LD_INT 12
21220: PUSH
21221: LD_INT 13
21223: PUSH
21224: LD_INT 14
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: ST_TO_ADDR
21233: GO 21656
21235: LD_INT 28
21237: DOUBLE
21238: EQUAL
21239: IFTRUE 21243
21241: GO 21261
21243: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21244: LD_ADDR_VAR 0 3
21248: PUSH
21249: LD_INT 13
21251: PUSH
21252: LD_INT 14
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: ST_TO_ADDR
21259: GO 21656
21261: LD_INT 29
21263: DOUBLE
21264: EQUAL
21265: IFTRUE 21269
21267: GO 21287
21269: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21270: LD_ADDR_VAR 0 3
21274: PUSH
21275: LD_INT 13
21277: PUSH
21278: LD_INT 14
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: ST_TO_ADDR
21285: GO 21656
21287: LD_INT 31
21289: DOUBLE
21290: EQUAL
21291: IFTRUE 21295
21293: GO 21313
21295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21296: LD_ADDR_VAR 0 3
21300: PUSH
21301: LD_INT 13
21303: PUSH
21304: LD_INT 14
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: ST_TO_ADDR
21311: GO 21656
21313: LD_INT 26
21315: DOUBLE
21316: EQUAL
21317: IFTRUE 21321
21319: GO 21339
21321: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21322: LD_ADDR_VAR 0 3
21326: PUSH
21327: LD_INT 13
21329: PUSH
21330: LD_INT 14
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: ST_TO_ADDR
21337: GO 21656
21339: LD_INT 42
21341: DOUBLE
21342: EQUAL
21343: IFTRUE 21347
21345: GO 21373
21347: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21348: LD_ADDR_VAR 0 3
21352: PUSH
21353: LD_INT 21
21355: PUSH
21356: LD_INT 22
21358: PUSH
21359: LD_INT 23
21361: PUSH
21362: LD_INT 24
21364: PUSH
21365: EMPTY
21366: LIST
21367: LIST
21368: LIST
21369: LIST
21370: ST_TO_ADDR
21371: GO 21656
21373: LD_INT 43
21375: DOUBLE
21376: EQUAL
21377: IFTRUE 21381
21379: GO 21407
21381: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21382: LD_ADDR_VAR 0 3
21386: PUSH
21387: LD_INT 21
21389: PUSH
21390: LD_INT 22
21392: PUSH
21393: LD_INT 23
21395: PUSH
21396: LD_INT 24
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: LIST
21403: LIST
21404: ST_TO_ADDR
21405: GO 21656
21407: LD_INT 44
21409: DOUBLE
21410: EQUAL
21411: IFTRUE 21415
21413: GO 21441
21415: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21416: LD_ADDR_VAR 0 3
21420: PUSH
21421: LD_INT 21
21423: PUSH
21424: LD_INT 22
21426: PUSH
21427: LD_INT 23
21429: PUSH
21430: LD_INT 24
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: ST_TO_ADDR
21439: GO 21656
21441: LD_INT 45
21443: DOUBLE
21444: EQUAL
21445: IFTRUE 21449
21447: GO 21475
21449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21450: LD_ADDR_VAR 0 3
21454: PUSH
21455: LD_INT 21
21457: PUSH
21458: LD_INT 22
21460: PUSH
21461: LD_INT 23
21463: PUSH
21464: LD_INT 24
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: LIST
21471: LIST
21472: ST_TO_ADDR
21473: GO 21656
21475: LD_INT 49
21477: DOUBLE
21478: EQUAL
21479: IFTRUE 21483
21481: GO 21509
21483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21484: LD_ADDR_VAR 0 3
21488: PUSH
21489: LD_INT 21
21491: PUSH
21492: LD_INT 22
21494: PUSH
21495: LD_INT 23
21497: PUSH
21498: LD_INT 24
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: LIST
21505: LIST
21506: ST_TO_ADDR
21507: GO 21656
21509: LD_INT 51
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21517
21515: GO 21543
21517: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21518: LD_ADDR_VAR 0 3
21522: PUSH
21523: LD_INT 21
21525: PUSH
21526: LD_INT 22
21528: PUSH
21529: LD_INT 23
21531: PUSH
21532: LD_INT 24
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: ST_TO_ADDR
21541: GO 21656
21543: LD_INT 52
21545: DOUBLE
21546: EQUAL
21547: IFTRUE 21551
21549: GO 21577
21551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21552: LD_ADDR_VAR 0 3
21556: PUSH
21557: LD_INT 21
21559: PUSH
21560: LD_INT 22
21562: PUSH
21563: LD_INT 23
21565: PUSH
21566: LD_INT 24
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: LIST
21574: ST_TO_ADDR
21575: GO 21656
21577: LD_INT 53
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21585
21583: GO 21603
21585: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21586: LD_ADDR_VAR 0 3
21590: PUSH
21591: LD_INT 23
21593: PUSH
21594: LD_INT 24
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: ST_TO_ADDR
21601: GO 21656
21603: LD_INT 46
21605: DOUBLE
21606: EQUAL
21607: IFTRUE 21611
21609: GO 21629
21611: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21612: LD_ADDR_VAR 0 3
21616: PUSH
21617: LD_INT 23
21619: PUSH
21620: LD_INT 24
21622: PUSH
21623: EMPTY
21624: LIST
21625: LIST
21626: ST_TO_ADDR
21627: GO 21656
21629: LD_INT 47
21631: DOUBLE
21632: EQUAL
21633: IFTRUE 21637
21635: GO 21655
21637: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21638: LD_ADDR_VAR 0 3
21642: PUSH
21643: LD_INT 23
21645: PUSH
21646: LD_INT 24
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: ST_TO_ADDR
21653: GO 21656
21655: POP
// result := ( chassis in result ) ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_VAR 0 1
21665: PUSH
21666: LD_VAR 0 3
21670: IN
21671: ST_TO_ADDR
// end ;
21672: LD_VAR 0 3
21676: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21677: LD_INT 0
21679: PPUSH
21680: PPUSH
21681: PPUSH
21682: PPUSH
21683: PPUSH
21684: PPUSH
21685: PPUSH
// result := array ;
21686: LD_ADDR_VAR 0 5
21690: PUSH
21691: LD_VAR 0 1
21695: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21696: LD_VAR 0 1
21700: NOT
21701: PUSH
21702: LD_VAR 0 2
21706: NOT
21707: OR
21708: PUSH
21709: LD_VAR 0 3
21713: NOT
21714: OR
21715: PUSH
21716: LD_VAR 0 2
21720: PUSH
21721: LD_VAR 0 1
21725: GREATER
21726: OR
21727: PUSH
21728: LD_VAR 0 3
21732: PUSH
21733: LD_VAR 0 1
21737: GREATER
21738: OR
21739: IFFALSE 21743
// exit ;
21741: GO 22039
// if direction then
21743: LD_VAR 0 4
21747: IFFALSE 21811
// begin d := 1 ;
21749: LD_ADDR_VAR 0 9
21753: PUSH
21754: LD_INT 1
21756: ST_TO_ADDR
// if i_from > i_to then
21757: LD_VAR 0 2
21761: PUSH
21762: LD_VAR 0 3
21766: GREATER
21767: IFFALSE 21793
// length := ( array - i_from ) + i_to else
21769: LD_ADDR_VAR 0 11
21773: PUSH
21774: LD_VAR 0 1
21778: PUSH
21779: LD_VAR 0 2
21783: MINUS
21784: PUSH
21785: LD_VAR 0 3
21789: PLUS
21790: ST_TO_ADDR
21791: GO 21809
// length := i_to - i_from ;
21793: LD_ADDR_VAR 0 11
21797: PUSH
21798: LD_VAR 0 3
21802: PUSH
21803: LD_VAR 0 2
21807: MINUS
21808: ST_TO_ADDR
// end else
21809: GO 21872
// begin d := - 1 ;
21811: LD_ADDR_VAR 0 9
21815: PUSH
21816: LD_INT 1
21818: NEG
21819: ST_TO_ADDR
// if i_from > i_to then
21820: LD_VAR 0 2
21824: PUSH
21825: LD_VAR 0 3
21829: GREATER
21830: IFFALSE 21850
// length := i_from - i_to else
21832: LD_ADDR_VAR 0 11
21836: PUSH
21837: LD_VAR 0 2
21841: PUSH
21842: LD_VAR 0 3
21846: MINUS
21847: ST_TO_ADDR
21848: GO 21872
// length := ( array - i_to ) + i_from ;
21850: LD_ADDR_VAR 0 11
21854: PUSH
21855: LD_VAR 0 1
21859: PUSH
21860: LD_VAR 0 3
21864: MINUS
21865: PUSH
21866: LD_VAR 0 2
21870: PLUS
21871: ST_TO_ADDR
// end ; if not length then
21872: LD_VAR 0 11
21876: NOT
21877: IFFALSE 21881
// exit ;
21879: GO 22039
// tmp := array ;
21881: LD_ADDR_VAR 0 10
21885: PUSH
21886: LD_VAR 0 1
21890: ST_TO_ADDR
// for i = 1 to length do
21891: LD_ADDR_VAR 0 6
21895: PUSH
21896: DOUBLE
21897: LD_INT 1
21899: DEC
21900: ST_TO_ADDR
21901: LD_VAR 0 11
21905: PUSH
21906: FOR_TO
21907: IFFALSE 22027
// begin for j = 1 to array do
21909: LD_ADDR_VAR 0 7
21913: PUSH
21914: DOUBLE
21915: LD_INT 1
21917: DEC
21918: ST_TO_ADDR
21919: LD_VAR 0 1
21923: PUSH
21924: FOR_TO
21925: IFFALSE 22013
// begin k := j + d ;
21927: LD_ADDR_VAR 0 8
21931: PUSH
21932: LD_VAR 0 7
21936: PUSH
21937: LD_VAR 0 9
21941: PLUS
21942: ST_TO_ADDR
// if k > array then
21943: LD_VAR 0 8
21947: PUSH
21948: LD_VAR 0 1
21952: GREATER
21953: IFFALSE 21963
// k := 1 ;
21955: LD_ADDR_VAR 0 8
21959: PUSH
21960: LD_INT 1
21962: ST_TO_ADDR
// if not k then
21963: LD_VAR 0 8
21967: NOT
21968: IFFALSE 21980
// k := array ;
21970: LD_ADDR_VAR 0 8
21974: PUSH
21975: LD_VAR 0 1
21979: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
21980: LD_ADDR_VAR 0 10
21984: PUSH
21985: LD_VAR 0 10
21989: PPUSH
21990: LD_VAR 0 8
21994: PPUSH
21995: LD_VAR 0 1
21999: PUSH
22000: LD_VAR 0 7
22004: ARRAY
22005: PPUSH
22006: CALL_OW 1
22010: ST_TO_ADDR
// end ;
22011: GO 21924
22013: POP
22014: POP
// array := tmp ;
22015: LD_ADDR_VAR 0 1
22019: PUSH
22020: LD_VAR 0 10
22024: ST_TO_ADDR
// end ;
22025: GO 21906
22027: POP
22028: POP
// result := array ;
22029: LD_ADDR_VAR 0 5
22033: PUSH
22034: LD_VAR 0 1
22038: ST_TO_ADDR
// end ;
22039: LD_VAR 0 5
22043: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22044: LD_INT 0
22046: PPUSH
22047: PPUSH
// result := 0 ;
22048: LD_ADDR_VAR 0 3
22052: PUSH
22053: LD_INT 0
22055: ST_TO_ADDR
// if not array or not value in array then
22056: LD_VAR 0 1
22060: NOT
22061: PUSH
22062: LD_VAR 0 2
22066: PUSH
22067: LD_VAR 0 1
22071: IN
22072: NOT
22073: OR
22074: IFFALSE 22078
// exit ;
22076: GO 22132
// for i = 1 to array do
22078: LD_ADDR_VAR 0 4
22082: PUSH
22083: DOUBLE
22084: LD_INT 1
22086: DEC
22087: ST_TO_ADDR
22088: LD_VAR 0 1
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22130
// if value = array [ i ] then
22096: LD_VAR 0 2
22100: PUSH
22101: LD_VAR 0 1
22105: PUSH
22106: LD_VAR 0 4
22110: ARRAY
22111: EQUAL
22112: IFFALSE 22128
// begin result := i ;
22114: LD_ADDR_VAR 0 3
22118: PUSH
22119: LD_VAR 0 4
22123: ST_TO_ADDR
// exit ;
22124: POP
22125: POP
22126: GO 22132
// end ;
22128: GO 22093
22130: POP
22131: POP
// end ;
22132: LD_VAR 0 3
22136: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22137: LD_INT 0
22139: PPUSH
// vc_chassis := chassis ;
22140: LD_ADDR_OWVAR 37
22144: PUSH
22145: LD_VAR 0 1
22149: ST_TO_ADDR
// vc_engine := engine ;
22150: LD_ADDR_OWVAR 39
22154: PUSH
22155: LD_VAR 0 2
22159: ST_TO_ADDR
// vc_control := control ;
22160: LD_ADDR_OWVAR 38
22164: PUSH
22165: LD_VAR 0 3
22169: ST_TO_ADDR
// vc_weapon := weapon ;
22170: LD_ADDR_OWVAR 40
22174: PUSH
22175: LD_VAR 0 4
22179: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22180: LD_ADDR_OWVAR 41
22184: PUSH
22185: LD_VAR 0 5
22189: ST_TO_ADDR
// end ;
22190: LD_VAR 0 6
22194: RET
// export function WantPlant ( unit ) ; var task ; begin
22195: LD_INT 0
22197: PPUSH
22198: PPUSH
// result := false ;
22199: LD_ADDR_VAR 0 2
22203: PUSH
22204: LD_INT 0
22206: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 437
22221: ST_TO_ADDR
// if task then
22222: LD_VAR 0 3
22226: IFFALSE 22254
// if task [ 1 ] [ 1 ] = p then
22228: LD_VAR 0 3
22232: PUSH
22233: LD_INT 1
22235: ARRAY
22236: PUSH
22237: LD_INT 1
22239: ARRAY
22240: PUSH
22241: LD_STRING p
22243: EQUAL
22244: IFFALSE 22254
// result := true ;
22246: LD_ADDR_VAR 0 2
22250: PUSH
22251: LD_INT 1
22253: ST_TO_ADDR
// end ;
22254: LD_VAR 0 2
22258: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22259: LD_INT 0
22261: PPUSH
22262: PPUSH
22263: PPUSH
22264: PPUSH
// if pos < 1 then
22265: LD_VAR 0 2
22269: PUSH
22270: LD_INT 1
22272: LESS
22273: IFFALSE 22277
// exit ;
22275: GO 22580
// if pos = 1 then
22277: LD_VAR 0 2
22281: PUSH
22282: LD_INT 1
22284: EQUAL
22285: IFFALSE 22318
// result := Replace ( arr , pos [ 1 ] , value ) else
22287: LD_ADDR_VAR 0 4
22291: PUSH
22292: LD_VAR 0 1
22296: PPUSH
22297: LD_VAR 0 2
22301: PUSH
22302: LD_INT 1
22304: ARRAY
22305: PPUSH
22306: LD_VAR 0 3
22310: PPUSH
22311: CALL_OW 1
22315: ST_TO_ADDR
22316: GO 22580
// begin tmp := arr ;
22318: LD_ADDR_VAR 0 6
22322: PUSH
22323: LD_VAR 0 1
22327: ST_TO_ADDR
// s_arr := [ tmp ] ;
22328: LD_ADDR_VAR 0 7
22332: PUSH
22333: LD_VAR 0 6
22337: PUSH
22338: EMPTY
22339: LIST
22340: ST_TO_ADDR
// for i = 1 to pos - 1 do
22341: LD_ADDR_VAR 0 5
22345: PUSH
22346: DOUBLE
22347: LD_INT 1
22349: DEC
22350: ST_TO_ADDR
22351: LD_VAR 0 2
22355: PUSH
22356: LD_INT 1
22358: MINUS
22359: PUSH
22360: FOR_TO
22361: IFFALSE 22406
// begin tmp := tmp [ pos [ i ] ] ;
22363: LD_ADDR_VAR 0 6
22367: PUSH
22368: LD_VAR 0 6
22372: PUSH
22373: LD_VAR 0 2
22377: PUSH
22378: LD_VAR 0 5
22382: ARRAY
22383: ARRAY
22384: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22385: LD_ADDR_VAR 0 7
22389: PUSH
22390: LD_VAR 0 7
22394: PUSH
22395: LD_VAR 0 6
22399: PUSH
22400: EMPTY
22401: LIST
22402: ADD
22403: ST_TO_ADDR
// end ;
22404: GO 22360
22406: POP
22407: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22408: LD_ADDR_VAR 0 6
22412: PUSH
22413: LD_VAR 0 6
22417: PPUSH
22418: LD_VAR 0 2
22422: PUSH
22423: LD_VAR 0 2
22427: ARRAY
22428: PPUSH
22429: LD_VAR 0 3
22433: PPUSH
22434: CALL_OW 1
22438: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22439: LD_ADDR_VAR 0 7
22443: PUSH
22444: LD_VAR 0 7
22448: PPUSH
22449: LD_VAR 0 7
22453: PPUSH
22454: LD_VAR 0 6
22458: PPUSH
22459: CALL_OW 1
22463: ST_TO_ADDR
// for i = s_arr downto 2 do
22464: LD_ADDR_VAR 0 5
22468: PUSH
22469: DOUBLE
22470: LD_VAR 0 7
22474: INC
22475: ST_TO_ADDR
22476: LD_INT 2
22478: PUSH
22479: FOR_DOWNTO
22480: IFFALSE 22564
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22482: LD_ADDR_VAR 0 6
22486: PUSH
22487: LD_VAR 0 7
22491: PUSH
22492: LD_VAR 0 5
22496: PUSH
22497: LD_INT 1
22499: MINUS
22500: ARRAY
22501: PPUSH
22502: LD_VAR 0 2
22506: PUSH
22507: LD_VAR 0 5
22511: PUSH
22512: LD_INT 1
22514: MINUS
22515: ARRAY
22516: PPUSH
22517: LD_VAR 0 7
22521: PUSH
22522: LD_VAR 0 5
22526: ARRAY
22527: PPUSH
22528: CALL_OW 1
22532: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22533: LD_ADDR_VAR 0 7
22537: PUSH
22538: LD_VAR 0 7
22542: PPUSH
22543: LD_VAR 0 5
22547: PUSH
22548: LD_INT 1
22550: MINUS
22551: PPUSH
22552: LD_VAR 0 6
22556: PPUSH
22557: CALL_OW 1
22561: ST_TO_ADDR
// end ;
22562: GO 22479
22564: POP
22565: POP
// result := s_arr [ 1 ] ;
22566: LD_ADDR_VAR 0 4
22570: PUSH
22571: LD_VAR 0 7
22575: PUSH
22576: LD_INT 1
22578: ARRAY
22579: ST_TO_ADDR
// end ; end ;
22580: LD_VAR 0 4
22584: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22585: LD_INT 0
22587: PPUSH
22588: PPUSH
// if not list then
22589: LD_VAR 0 1
22593: NOT
22594: IFFALSE 22598
// exit ;
22596: GO 22689
// i := list [ pos1 ] ;
22598: LD_ADDR_VAR 0 5
22602: PUSH
22603: LD_VAR 0 1
22607: PUSH
22608: LD_VAR 0 2
22612: ARRAY
22613: ST_TO_ADDR
// if not i then
22614: LD_VAR 0 5
22618: NOT
22619: IFFALSE 22623
// exit ;
22621: GO 22689
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22623: LD_ADDR_VAR 0 1
22627: PUSH
22628: LD_VAR 0 1
22632: PPUSH
22633: LD_VAR 0 2
22637: PPUSH
22638: LD_VAR 0 1
22642: PUSH
22643: LD_VAR 0 3
22647: ARRAY
22648: PPUSH
22649: CALL_OW 1
22653: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22654: LD_ADDR_VAR 0 1
22658: PUSH
22659: LD_VAR 0 1
22663: PPUSH
22664: LD_VAR 0 3
22668: PPUSH
22669: LD_VAR 0 5
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// result := list ;
22679: LD_ADDR_VAR 0 4
22683: PUSH
22684: LD_VAR 0 1
22688: ST_TO_ADDR
// end ;
22689: LD_VAR 0 4
22693: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22694: LD_INT 0
22696: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22697: LD_ADDR_VAR 0 5
22701: PUSH
22702: LD_VAR 0 1
22706: PPUSH
22707: CALL_OW 250
22711: PPUSH
22712: LD_VAR 0 1
22716: PPUSH
22717: CALL_OW 251
22721: PPUSH
22722: LD_VAR 0 2
22726: PPUSH
22727: LD_VAR 0 3
22731: PPUSH
22732: LD_VAR 0 4
22736: PPUSH
22737: CALL 23115 0 5
22741: ST_TO_ADDR
// end ;
22742: LD_VAR 0 5
22746: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
22747: LD_INT 0
22749: PPUSH
22750: PPUSH
22751: PPUSH
22752: PPUSH
// if not list or not unit then
22753: LD_VAR 0 2
22757: NOT
22758: PUSH
22759: LD_VAR 0 1
22763: NOT
22764: OR
22765: IFFALSE 22769
// exit ;
22767: GO 23110
// result := [ ] ;
22769: LD_ADDR_VAR 0 5
22773: PUSH
22774: EMPTY
22775: ST_TO_ADDR
// for i in list do
22776: LD_ADDR_VAR 0 6
22780: PUSH
22781: LD_VAR 0 2
22785: PUSH
22786: FOR_IN
22787: IFFALSE 23005
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
22789: LD_ADDR_VAR 0 8
22793: PUSH
22794: LD_VAR 0 1
22798: PPUSH
22799: LD_VAR 0 6
22803: PUSH
22804: LD_INT 1
22806: ARRAY
22807: PPUSH
22808: LD_VAR 0 6
22812: PUSH
22813: LD_INT 2
22815: ARRAY
22816: PPUSH
22817: CALL_OW 297
22821: ST_TO_ADDR
// if not Count ( result ) then
22822: LD_VAR 0 5
22826: PPUSH
22827: CALL 19399 0 1
22831: NOT
22832: IFFALSE 22865
// begin result := Join ( result , [ i , tmp ] ) ;
22834: LD_ADDR_VAR 0 5
22838: PUSH
22839: LD_VAR 0 5
22843: PPUSH
22844: LD_VAR 0 6
22848: PUSH
22849: LD_VAR 0 8
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: PPUSH
22858: CALL 55008 0 2
22862: ST_TO_ADDR
// continue ;
22863: GO 22786
// end ; if result [ result ] [ 2 ] <= tmp then
22865: LD_VAR 0 5
22869: PUSH
22870: LD_VAR 0 5
22874: ARRAY
22875: PUSH
22876: LD_INT 2
22878: ARRAY
22879: PUSH
22880: LD_VAR 0 8
22884: LESSEQUAL
22885: IFFALSE 22918
// result := Join ( result , [ i , tmp ] ) else
22887: LD_ADDR_VAR 0 5
22891: PUSH
22892: LD_VAR 0 5
22896: PPUSH
22897: LD_VAR 0 6
22901: PUSH
22902: LD_VAR 0 8
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: PPUSH
22911: CALL 55008 0 2
22915: ST_TO_ADDR
22916: GO 23003
// begin for j := 1 to Count ( result ) do
22918: LD_ADDR_VAR 0 7
22922: PUSH
22923: DOUBLE
22924: LD_INT 1
22926: DEC
22927: ST_TO_ADDR
22928: LD_VAR 0 5
22932: PPUSH
22933: CALL 19399 0 1
22937: PUSH
22938: FOR_TO
22939: IFFALSE 23001
// begin if tmp < result [ j ] [ 2 ] then
22941: LD_VAR 0 8
22945: PUSH
22946: LD_VAR 0 5
22950: PUSH
22951: LD_VAR 0 7
22955: ARRAY
22956: PUSH
22957: LD_INT 2
22959: ARRAY
22960: LESS
22961: IFFALSE 22999
// begin result := Insert ( result , j , [ i , tmp ] ) ;
22963: LD_ADDR_VAR 0 5
22967: PUSH
22968: LD_VAR 0 5
22972: PPUSH
22973: LD_VAR 0 7
22977: PPUSH
22978: LD_VAR 0 6
22982: PUSH
22983: LD_VAR 0 8
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: PPUSH
22992: CALL_OW 2
22996: ST_TO_ADDR
// break ;
22997: GO 23001
// end ; end ;
22999: GO 22938
23001: POP
23002: POP
// end ; end ;
23003: GO 22786
23005: POP
23006: POP
// if result and not asc then
23007: LD_VAR 0 5
23011: PUSH
23012: LD_VAR 0 3
23016: NOT
23017: AND
23018: IFFALSE 23035
// result := ReverseArray ( result ) ;
23020: LD_ADDR_VAR 0 5
23024: PUSH
23025: LD_VAR 0 5
23029: PPUSH
23030: CALL 50275 0 1
23034: ST_TO_ADDR
// tmp := [ ] ;
23035: LD_ADDR_VAR 0 8
23039: PUSH
23040: EMPTY
23041: ST_TO_ADDR
// if mode then
23042: LD_VAR 0 4
23046: IFFALSE 23110
// begin for i := 1 to result do
23048: LD_ADDR_VAR 0 6
23052: PUSH
23053: DOUBLE
23054: LD_INT 1
23056: DEC
23057: ST_TO_ADDR
23058: LD_VAR 0 5
23062: PUSH
23063: FOR_TO
23064: IFFALSE 23098
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23066: LD_ADDR_VAR 0 8
23070: PUSH
23071: LD_VAR 0 8
23075: PPUSH
23076: LD_VAR 0 5
23080: PUSH
23081: LD_VAR 0 6
23085: ARRAY
23086: PUSH
23087: LD_INT 1
23089: ARRAY
23090: PPUSH
23091: CALL 55008 0 2
23095: ST_TO_ADDR
23096: GO 23063
23098: POP
23099: POP
// result := tmp ;
23100: LD_ADDR_VAR 0 5
23104: PUSH
23105: LD_VAR 0 8
23109: ST_TO_ADDR
// end ; end ;
23110: LD_VAR 0 5
23114: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23115: LD_INT 0
23117: PPUSH
23118: PPUSH
23119: PPUSH
23120: PPUSH
// if not list then
23121: LD_VAR 0 3
23125: NOT
23126: IFFALSE 23130
// exit ;
23128: GO 23518
// result := [ ] ;
23130: LD_ADDR_VAR 0 6
23134: PUSH
23135: EMPTY
23136: ST_TO_ADDR
// for i in list do
23137: LD_ADDR_VAR 0 7
23141: PUSH
23142: LD_VAR 0 3
23146: PUSH
23147: FOR_IN
23148: IFFALSE 23350
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23150: LD_ADDR_VAR 0 9
23154: PUSH
23155: LD_VAR 0 7
23159: PPUSH
23160: LD_VAR 0 1
23164: PPUSH
23165: LD_VAR 0 2
23169: PPUSH
23170: CALL_OW 297
23174: ST_TO_ADDR
// if not result then
23175: LD_VAR 0 6
23179: NOT
23180: IFFALSE 23206
// result := [ [ i , tmp ] ] else
23182: LD_ADDR_VAR 0 6
23186: PUSH
23187: LD_VAR 0 7
23191: PUSH
23192: LD_VAR 0 9
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: PUSH
23201: EMPTY
23202: LIST
23203: ST_TO_ADDR
23204: GO 23348
// begin if result [ result ] [ 2 ] <= tmp then
23206: LD_VAR 0 6
23210: PUSH
23211: LD_VAR 0 6
23215: ARRAY
23216: PUSH
23217: LD_INT 2
23219: ARRAY
23220: PUSH
23221: LD_VAR 0 9
23225: LESSEQUAL
23226: IFFALSE 23268
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23228: LD_ADDR_VAR 0 6
23232: PUSH
23233: LD_VAR 0 6
23237: PPUSH
23238: LD_VAR 0 6
23242: PUSH
23243: LD_INT 1
23245: PLUS
23246: PPUSH
23247: LD_VAR 0 7
23251: PUSH
23252: LD_VAR 0 9
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PPUSH
23261: CALL_OW 2
23265: ST_TO_ADDR
23266: GO 23348
// for j := 1 to result do
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: DOUBLE
23274: LD_INT 1
23276: DEC
23277: ST_TO_ADDR
23278: LD_VAR 0 6
23282: PUSH
23283: FOR_TO
23284: IFFALSE 23346
// begin if tmp < result [ j ] [ 2 ] then
23286: LD_VAR 0 9
23290: PUSH
23291: LD_VAR 0 6
23295: PUSH
23296: LD_VAR 0 8
23300: ARRAY
23301: PUSH
23302: LD_INT 2
23304: ARRAY
23305: LESS
23306: IFFALSE 23344
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23308: LD_ADDR_VAR 0 6
23312: PUSH
23313: LD_VAR 0 6
23317: PPUSH
23318: LD_VAR 0 8
23322: PPUSH
23323: LD_VAR 0 7
23327: PUSH
23328: LD_VAR 0 9
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: PPUSH
23337: CALL_OW 2
23341: ST_TO_ADDR
// break ;
23342: GO 23346
// end ; end ;
23344: GO 23283
23346: POP
23347: POP
// end ; end ;
23348: GO 23147
23350: POP
23351: POP
// if result and not asc then
23352: LD_VAR 0 6
23356: PUSH
23357: LD_VAR 0 4
23361: NOT
23362: AND
23363: IFFALSE 23438
// begin tmp := result ;
23365: LD_ADDR_VAR 0 9
23369: PUSH
23370: LD_VAR 0 6
23374: ST_TO_ADDR
// for i = tmp downto 1 do
23375: LD_ADDR_VAR 0 7
23379: PUSH
23380: DOUBLE
23381: LD_VAR 0 9
23385: INC
23386: ST_TO_ADDR
23387: LD_INT 1
23389: PUSH
23390: FOR_DOWNTO
23391: IFFALSE 23436
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23393: LD_ADDR_VAR 0 6
23397: PUSH
23398: LD_VAR 0 6
23402: PPUSH
23403: LD_VAR 0 9
23407: PUSH
23408: LD_VAR 0 7
23412: MINUS
23413: PUSH
23414: LD_INT 1
23416: PLUS
23417: PPUSH
23418: LD_VAR 0 9
23422: PUSH
23423: LD_VAR 0 7
23427: ARRAY
23428: PPUSH
23429: CALL_OW 1
23433: ST_TO_ADDR
23434: GO 23390
23436: POP
23437: POP
// end ; tmp := [ ] ;
23438: LD_ADDR_VAR 0 9
23442: PUSH
23443: EMPTY
23444: ST_TO_ADDR
// if mode then
23445: LD_VAR 0 5
23449: IFFALSE 23518
// begin for i = 1 to result do
23451: LD_ADDR_VAR 0 7
23455: PUSH
23456: DOUBLE
23457: LD_INT 1
23459: DEC
23460: ST_TO_ADDR
23461: LD_VAR 0 6
23465: PUSH
23466: FOR_TO
23467: IFFALSE 23506
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23469: LD_ADDR_VAR 0 9
23473: PUSH
23474: LD_VAR 0 9
23478: PPUSH
23479: LD_VAR 0 7
23483: PPUSH
23484: LD_VAR 0 6
23488: PUSH
23489: LD_VAR 0 7
23493: ARRAY
23494: PUSH
23495: LD_INT 1
23497: ARRAY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
23504: GO 23466
23506: POP
23507: POP
// result := tmp ;
23508: LD_ADDR_VAR 0 6
23512: PUSH
23513: LD_VAR 0 9
23517: ST_TO_ADDR
// end ; end ;
23518: LD_VAR 0 6
23522: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23523: LD_INT 0
23525: PPUSH
23526: PPUSH
23527: PPUSH
23528: PPUSH
23529: PPUSH
23530: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23531: LD_ADDR_VAR 0 5
23535: PUSH
23536: LD_INT 0
23538: PUSH
23539: LD_INT 0
23541: PUSH
23542: LD_INT 0
23544: PUSH
23545: EMPTY
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: LIST
23551: LIST
23552: ST_TO_ADDR
// if not x or not y then
23553: LD_VAR 0 2
23557: NOT
23558: PUSH
23559: LD_VAR 0 3
23563: NOT
23564: OR
23565: IFFALSE 23569
// exit ;
23567: GO 25219
// if not range then
23569: LD_VAR 0 4
23573: NOT
23574: IFFALSE 23584
// range := 10 ;
23576: LD_ADDR_VAR 0 4
23580: PUSH
23581: LD_INT 10
23583: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23584: LD_ADDR_VAR 0 8
23588: PUSH
23589: LD_INT 81
23591: PUSH
23592: LD_VAR 0 1
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 92
23603: PUSH
23604: LD_VAR 0 2
23608: PUSH
23609: LD_VAR 0 3
23613: PUSH
23614: LD_VAR 0 4
23618: PUSH
23619: EMPTY
23620: LIST
23621: LIST
23622: LIST
23623: LIST
23624: PUSH
23625: LD_INT 3
23627: PUSH
23628: LD_INT 21
23630: PUSH
23631: LD_INT 3
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: LIST
23646: PPUSH
23647: CALL_OW 69
23651: ST_TO_ADDR
// if not tmp then
23652: LD_VAR 0 8
23656: NOT
23657: IFFALSE 23661
// exit ;
23659: GO 25219
// for i in tmp do
23661: LD_ADDR_VAR 0 6
23665: PUSH
23666: LD_VAR 0 8
23670: PUSH
23671: FOR_IN
23672: IFFALSE 25194
// begin points := [ 0 , 0 , 0 ] ;
23674: LD_ADDR_VAR 0 9
23678: PUSH
23679: LD_INT 0
23681: PUSH
23682: LD_INT 0
23684: PUSH
23685: LD_INT 0
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: LIST
23692: ST_TO_ADDR
// bpoints := 1 ;
23693: LD_ADDR_VAR 0 10
23697: PUSH
23698: LD_INT 1
23700: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23701: LD_VAR 0 6
23705: PPUSH
23706: CALL_OW 247
23710: PUSH
23711: LD_INT 1
23713: DOUBLE
23714: EQUAL
23715: IFTRUE 23719
23717: GO 24297
23719: POP
// begin if GetClass ( i ) = 1 then
23720: LD_VAR 0 6
23724: PPUSH
23725: CALL_OW 257
23729: PUSH
23730: LD_INT 1
23732: EQUAL
23733: IFFALSE 23754
// points := [ 10 , 5 , 3 ] ;
23735: LD_ADDR_VAR 0 9
23739: PUSH
23740: LD_INT 10
23742: PUSH
23743: LD_INT 5
23745: PUSH
23746: LD_INT 3
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: LIST
23753: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23754: LD_VAR 0 6
23758: PPUSH
23759: CALL_OW 257
23763: PUSH
23764: LD_INT 2
23766: PUSH
23767: LD_INT 3
23769: PUSH
23770: LD_INT 4
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: LIST
23777: IN
23778: IFFALSE 23799
// points := [ 3 , 2 , 1 ] ;
23780: LD_ADDR_VAR 0 9
23784: PUSH
23785: LD_INT 3
23787: PUSH
23788: LD_INT 2
23790: PUSH
23791: LD_INT 1
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: LIST
23798: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23799: LD_VAR 0 6
23803: PPUSH
23804: CALL_OW 257
23808: PUSH
23809: LD_INT 5
23811: EQUAL
23812: IFFALSE 23833
// points := [ 130 , 5 , 2 ] ;
23814: LD_ADDR_VAR 0 9
23818: PUSH
23819: LD_INT 130
23821: PUSH
23822: LD_INT 5
23824: PUSH
23825: LD_INT 2
23827: PUSH
23828: EMPTY
23829: LIST
23830: LIST
23831: LIST
23832: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23833: LD_VAR 0 6
23837: PPUSH
23838: CALL_OW 257
23842: PUSH
23843: LD_INT 8
23845: EQUAL
23846: IFFALSE 23867
// points := [ 35 , 35 , 30 ] ;
23848: LD_ADDR_VAR 0 9
23852: PUSH
23853: LD_INT 35
23855: PUSH
23856: LD_INT 35
23858: PUSH
23859: LD_INT 30
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: LIST
23866: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23867: LD_VAR 0 6
23871: PPUSH
23872: CALL_OW 257
23876: PUSH
23877: LD_INT 9
23879: EQUAL
23880: IFFALSE 23901
// points := [ 20 , 55 , 40 ] ;
23882: LD_ADDR_VAR 0 9
23886: PUSH
23887: LD_INT 20
23889: PUSH
23890: LD_INT 55
23892: PUSH
23893: LD_INT 40
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: LIST
23900: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23901: LD_VAR 0 6
23905: PPUSH
23906: CALL_OW 257
23910: PUSH
23911: LD_INT 12
23913: PUSH
23914: LD_INT 16
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: IN
23921: IFFALSE 23942
// points := [ 5 , 3 , 2 ] ;
23923: LD_ADDR_VAR 0 9
23927: PUSH
23928: LD_INT 5
23930: PUSH
23931: LD_INT 3
23933: PUSH
23934: LD_INT 2
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: LIST
23941: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23942: LD_VAR 0 6
23946: PPUSH
23947: CALL_OW 257
23951: PUSH
23952: LD_INT 17
23954: EQUAL
23955: IFFALSE 23976
// points := [ 100 , 50 , 75 ] ;
23957: LD_ADDR_VAR 0 9
23961: PUSH
23962: LD_INT 100
23964: PUSH
23965: LD_INT 50
23967: PUSH
23968: LD_INT 75
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: LIST
23975: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23976: LD_VAR 0 6
23980: PPUSH
23981: CALL_OW 257
23985: PUSH
23986: LD_INT 15
23988: EQUAL
23989: IFFALSE 24010
// points := [ 10 , 5 , 3 ] ;
23991: LD_ADDR_VAR 0 9
23995: PUSH
23996: LD_INT 10
23998: PUSH
23999: LD_INT 5
24001: PUSH
24002: LD_INT 3
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: LIST
24009: ST_TO_ADDR
// if GetClass ( i ) = 14 then
24010: LD_VAR 0 6
24014: PPUSH
24015: CALL_OW 257
24019: PUSH
24020: LD_INT 14
24022: EQUAL
24023: IFFALSE 24044
// points := [ 10 , 0 , 0 ] ;
24025: LD_ADDR_VAR 0 9
24029: PUSH
24030: LD_INT 10
24032: PUSH
24033: LD_INT 0
24035: PUSH
24036: LD_INT 0
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: LIST
24043: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24044: LD_VAR 0 6
24048: PPUSH
24049: CALL_OW 257
24053: PUSH
24054: LD_INT 11
24056: EQUAL
24057: IFFALSE 24078
// points := [ 30 , 10 , 5 ] ;
24059: LD_ADDR_VAR 0 9
24063: PUSH
24064: LD_INT 30
24066: PUSH
24067: LD_INT 10
24069: PUSH
24070: LD_INT 5
24072: PUSH
24073: EMPTY
24074: LIST
24075: LIST
24076: LIST
24077: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24078: LD_VAR 0 1
24082: PPUSH
24083: LD_INT 5
24085: PPUSH
24086: CALL_OW 321
24090: PUSH
24091: LD_INT 2
24093: EQUAL
24094: IFFALSE 24111
// bpoints := bpoints * 1.8 ;
24096: LD_ADDR_VAR 0 10
24100: PUSH
24101: LD_VAR 0 10
24105: PUSH
24106: LD_REAL  1.80000000000000E+0000
24109: MUL
24110: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24111: LD_VAR 0 6
24115: PPUSH
24116: CALL_OW 257
24120: PUSH
24121: LD_INT 1
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: LD_INT 3
24129: PUSH
24130: LD_INT 4
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: IN
24139: PUSH
24140: LD_VAR 0 1
24144: PPUSH
24145: LD_INT 51
24147: PPUSH
24148: CALL_OW 321
24152: PUSH
24153: LD_INT 2
24155: EQUAL
24156: AND
24157: IFFALSE 24174
// bpoints := bpoints * 1.2 ;
24159: LD_ADDR_VAR 0 10
24163: PUSH
24164: LD_VAR 0 10
24168: PUSH
24169: LD_REAL  1.20000000000000E+0000
24172: MUL
24173: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24174: LD_VAR 0 6
24178: PPUSH
24179: CALL_OW 257
24183: PUSH
24184: LD_INT 5
24186: PUSH
24187: LD_INT 7
24189: PUSH
24190: LD_INT 9
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: LIST
24197: IN
24198: PUSH
24199: LD_VAR 0 1
24203: PPUSH
24204: LD_INT 52
24206: PPUSH
24207: CALL_OW 321
24211: PUSH
24212: LD_INT 2
24214: EQUAL
24215: AND
24216: IFFALSE 24233
// bpoints := bpoints * 1.5 ;
24218: LD_ADDR_VAR 0 10
24222: PUSH
24223: LD_VAR 0 10
24227: PUSH
24228: LD_REAL  1.50000000000000E+0000
24231: MUL
24232: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24233: LD_VAR 0 1
24237: PPUSH
24238: LD_INT 66
24240: PPUSH
24241: CALL_OW 321
24245: PUSH
24246: LD_INT 2
24248: EQUAL
24249: IFFALSE 24266
// bpoints := bpoints * 1.1 ;
24251: LD_ADDR_VAR 0 10
24255: PUSH
24256: LD_VAR 0 10
24260: PUSH
24261: LD_REAL  1.10000000000000E+0000
24264: MUL
24265: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24266: LD_ADDR_VAR 0 10
24270: PUSH
24271: LD_VAR 0 10
24275: PUSH
24276: LD_VAR 0 6
24280: PPUSH
24281: LD_INT 1
24283: PPUSH
24284: CALL_OW 259
24288: PUSH
24289: LD_REAL  1.15000000000000E+0000
24292: MUL
24293: MUL
24294: ST_TO_ADDR
// end ; unit_vehicle :
24295: GO 25123
24297: LD_INT 2
24299: DOUBLE
24300: EQUAL
24301: IFTRUE 24305
24303: GO 25111
24305: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24306: LD_VAR 0 6
24310: PPUSH
24311: CALL_OW 264
24315: PUSH
24316: LD_INT 2
24318: PUSH
24319: LD_INT 42
24321: PUSH
24322: LD_INT 24
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: LIST
24329: IN
24330: IFFALSE 24351
// points := [ 25 , 5 , 3 ] ;
24332: LD_ADDR_VAR 0 9
24336: PUSH
24337: LD_INT 25
24339: PUSH
24340: LD_INT 5
24342: PUSH
24343: LD_INT 3
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: LIST
24350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24351: LD_VAR 0 6
24355: PPUSH
24356: CALL_OW 264
24360: PUSH
24361: LD_INT 4
24363: PUSH
24364: LD_INT 43
24366: PUSH
24367: LD_INT 25
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: LIST
24374: IN
24375: IFFALSE 24396
// points := [ 40 , 15 , 5 ] ;
24377: LD_ADDR_VAR 0 9
24381: PUSH
24382: LD_INT 40
24384: PUSH
24385: LD_INT 15
24387: PUSH
24388: LD_INT 5
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: LIST
24395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24396: LD_VAR 0 6
24400: PPUSH
24401: CALL_OW 264
24405: PUSH
24406: LD_INT 3
24408: PUSH
24409: LD_INT 23
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: IN
24416: IFFALSE 24437
// points := [ 7 , 25 , 8 ] ;
24418: LD_ADDR_VAR 0 9
24422: PUSH
24423: LD_INT 7
24425: PUSH
24426: LD_INT 25
24428: PUSH
24429: LD_INT 8
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: LIST
24436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24437: LD_VAR 0 6
24441: PPUSH
24442: CALL_OW 264
24446: PUSH
24447: LD_INT 5
24449: PUSH
24450: LD_INT 27
24452: PUSH
24453: LD_INT 44
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: LIST
24460: IN
24461: IFFALSE 24482
// points := [ 14 , 50 , 16 ] ;
24463: LD_ADDR_VAR 0 9
24467: PUSH
24468: LD_INT 14
24470: PUSH
24471: LD_INT 50
24473: PUSH
24474: LD_INT 16
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: LIST
24481: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24482: LD_VAR 0 6
24486: PPUSH
24487: CALL_OW 264
24491: PUSH
24492: LD_INT 6
24494: PUSH
24495: LD_INT 46
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: IN
24502: IFFALSE 24523
// points := [ 32 , 120 , 70 ] ;
24504: LD_ADDR_VAR 0 9
24508: PUSH
24509: LD_INT 32
24511: PUSH
24512: LD_INT 120
24514: PUSH
24515: LD_INT 70
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: LIST
24522: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24523: LD_VAR 0 6
24527: PPUSH
24528: CALL_OW 264
24532: PUSH
24533: LD_INT 7
24535: PUSH
24536: LD_INT 28
24538: PUSH
24539: LD_INT 45
24541: PUSH
24542: LD_INT 92
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: IN
24551: IFFALSE 24572
// points := [ 35 , 20 , 45 ] ;
24553: LD_ADDR_VAR 0 9
24557: PUSH
24558: LD_INT 35
24560: PUSH
24561: LD_INT 20
24563: PUSH
24564: LD_INT 45
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: LIST
24571: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24572: LD_VAR 0 6
24576: PPUSH
24577: CALL_OW 264
24581: PUSH
24582: LD_INT 47
24584: PUSH
24585: EMPTY
24586: LIST
24587: IN
24588: IFFALSE 24609
// points := [ 67 , 45 , 75 ] ;
24590: LD_ADDR_VAR 0 9
24594: PUSH
24595: LD_INT 67
24597: PUSH
24598: LD_INT 45
24600: PUSH
24601: LD_INT 75
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: LIST
24608: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24609: LD_VAR 0 6
24613: PPUSH
24614: CALL_OW 264
24618: PUSH
24619: LD_INT 26
24621: PUSH
24622: EMPTY
24623: LIST
24624: IN
24625: IFFALSE 24646
// points := [ 120 , 30 , 80 ] ;
24627: LD_ADDR_VAR 0 9
24631: PUSH
24632: LD_INT 120
24634: PUSH
24635: LD_INT 30
24637: PUSH
24638: LD_INT 80
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: LIST
24645: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24646: LD_VAR 0 6
24650: PPUSH
24651: CALL_OW 264
24655: PUSH
24656: LD_INT 22
24658: PUSH
24659: EMPTY
24660: LIST
24661: IN
24662: IFFALSE 24683
// points := [ 40 , 1 , 1 ] ;
24664: LD_ADDR_VAR 0 9
24668: PUSH
24669: LD_INT 40
24671: PUSH
24672: LD_INT 1
24674: PUSH
24675: LD_INT 1
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: LIST
24682: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24683: LD_VAR 0 6
24687: PPUSH
24688: CALL_OW 264
24692: PUSH
24693: LD_INT 29
24695: PUSH
24696: EMPTY
24697: LIST
24698: IN
24699: IFFALSE 24720
// points := [ 70 , 200 , 400 ] ;
24701: LD_ADDR_VAR 0 9
24705: PUSH
24706: LD_INT 70
24708: PUSH
24709: LD_INT 200
24711: PUSH
24712: LD_INT 400
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: LIST
24719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24720: LD_VAR 0 6
24724: PPUSH
24725: CALL_OW 264
24729: PUSH
24730: LD_INT 14
24732: PUSH
24733: LD_INT 53
24735: PUSH
24736: EMPTY
24737: LIST
24738: LIST
24739: IN
24740: IFFALSE 24761
// points := [ 40 , 10 , 20 ] ;
24742: LD_ADDR_VAR 0 9
24746: PUSH
24747: LD_INT 40
24749: PUSH
24750: LD_INT 10
24752: PUSH
24753: LD_INT 20
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: LIST
24760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24761: LD_VAR 0 6
24765: PPUSH
24766: CALL_OW 264
24770: PUSH
24771: LD_INT 9
24773: PUSH
24774: EMPTY
24775: LIST
24776: IN
24777: IFFALSE 24798
// points := [ 5 , 70 , 20 ] ;
24779: LD_ADDR_VAR 0 9
24783: PUSH
24784: LD_INT 5
24786: PUSH
24787: LD_INT 70
24789: PUSH
24790: LD_INT 20
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: LIST
24797: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24798: LD_VAR 0 6
24802: PPUSH
24803: CALL_OW 264
24807: PUSH
24808: LD_INT 10
24810: PUSH
24811: EMPTY
24812: LIST
24813: IN
24814: IFFALSE 24835
// points := [ 35 , 110 , 70 ] ;
24816: LD_ADDR_VAR 0 9
24820: PUSH
24821: LD_INT 35
24823: PUSH
24824: LD_INT 110
24826: PUSH
24827: LD_INT 70
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: LIST
24834: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24835: LD_VAR 0 6
24839: PPUSH
24840: CALL_OW 265
24844: PUSH
24845: LD_INT 25
24847: EQUAL
24848: IFFALSE 24869
// points := [ 80 , 65 , 100 ] ;
24850: LD_ADDR_VAR 0 9
24854: PUSH
24855: LD_INT 80
24857: PUSH
24858: LD_INT 65
24860: PUSH
24861: LD_INT 100
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: LIST
24868: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24869: LD_VAR 0 6
24873: PPUSH
24874: CALL_OW 263
24878: PUSH
24879: LD_INT 1
24881: EQUAL
24882: IFFALSE 24917
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24884: LD_ADDR_VAR 0 10
24888: PUSH
24889: LD_VAR 0 10
24893: PUSH
24894: LD_VAR 0 6
24898: PPUSH
24899: CALL_OW 311
24903: PPUSH
24904: LD_INT 3
24906: PPUSH
24907: CALL_OW 259
24911: PUSH
24912: LD_INT 4
24914: MUL
24915: MUL
24916: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24917: LD_VAR 0 6
24921: PPUSH
24922: CALL_OW 263
24926: PUSH
24927: LD_INT 2
24929: EQUAL
24930: IFFALSE 24981
// begin j := IsControledBy ( i ) ;
24932: LD_ADDR_VAR 0 7
24936: PUSH
24937: LD_VAR 0 6
24941: PPUSH
24942: CALL_OW 312
24946: ST_TO_ADDR
// if j then
24947: LD_VAR 0 7
24951: IFFALSE 24981
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24953: LD_ADDR_VAR 0 10
24957: PUSH
24958: LD_VAR 0 10
24962: PUSH
24963: LD_VAR 0 7
24967: PPUSH
24968: LD_INT 3
24970: PPUSH
24971: CALL_OW 259
24975: PUSH
24976: LD_INT 3
24978: MUL
24979: MUL
24980: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24981: LD_VAR 0 6
24985: PPUSH
24986: CALL_OW 264
24990: PUSH
24991: LD_INT 5
24993: PUSH
24994: LD_INT 6
24996: PUSH
24997: LD_INT 46
24999: PUSH
25000: LD_INT 44
25002: PUSH
25003: LD_INT 47
25005: PUSH
25006: LD_INT 45
25008: PUSH
25009: LD_INT 28
25011: PUSH
25012: LD_INT 7
25014: PUSH
25015: LD_INT 27
25017: PUSH
25018: LD_INT 29
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: LIST
25029: LIST
25030: LIST
25031: LIST
25032: IN
25033: PUSH
25034: LD_VAR 0 1
25038: PPUSH
25039: LD_INT 52
25041: PPUSH
25042: CALL_OW 321
25046: PUSH
25047: LD_INT 2
25049: EQUAL
25050: AND
25051: IFFALSE 25068
// bpoints := bpoints * 1.2 ;
25053: LD_ADDR_VAR 0 10
25057: PUSH
25058: LD_VAR 0 10
25062: PUSH
25063: LD_REAL  1.20000000000000E+0000
25066: MUL
25067: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25068: LD_VAR 0 6
25072: PPUSH
25073: CALL_OW 264
25077: PUSH
25078: LD_INT 6
25080: PUSH
25081: LD_INT 46
25083: PUSH
25084: LD_INT 47
25086: PUSH
25087: EMPTY
25088: LIST
25089: LIST
25090: LIST
25091: IN
25092: IFFALSE 25109
// bpoints := bpoints * 1.2 ;
25094: LD_ADDR_VAR 0 10
25098: PUSH
25099: LD_VAR 0 10
25103: PUSH
25104: LD_REAL  1.20000000000000E+0000
25107: MUL
25108: ST_TO_ADDR
// end ; unit_building :
25109: GO 25123
25111: LD_INT 3
25113: DOUBLE
25114: EQUAL
25115: IFTRUE 25119
25117: GO 25122
25119: POP
// ; end ;
25120: GO 25123
25122: POP
// for j = 1 to 3 do
25123: LD_ADDR_VAR 0 7
25127: PUSH
25128: DOUBLE
25129: LD_INT 1
25131: DEC
25132: ST_TO_ADDR
25133: LD_INT 3
25135: PUSH
25136: FOR_TO
25137: IFFALSE 25190
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25139: LD_ADDR_VAR 0 5
25143: PUSH
25144: LD_VAR 0 5
25148: PPUSH
25149: LD_VAR 0 7
25153: PPUSH
25154: LD_VAR 0 5
25158: PUSH
25159: LD_VAR 0 7
25163: ARRAY
25164: PUSH
25165: LD_VAR 0 9
25169: PUSH
25170: LD_VAR 0 7
25174: ARRAY
25175: PUSH
25176: LD_VAR 0 10
25180: MUL
25181: PLUS
25182: PPUSH
25183: CALL_OW 1
25187: ST_TO_ADDR
25188: GO 25136
25190: POP
25191: POP
// end ;
25192: GO 23671
25194: POP
25195: POP
// result := Replace ( result , 4 , tmp ) ;
25196: LD_ADDR_VAR 0 5
25200: PUSH
25201: LD_VAR 0 5
25205: PPUSH
25206: LD_INT 4
25208: PPUSH
25209: LD_VAR 0 8
25213: PPUSH
25214: CALL_OW 1
25218: ST_TO_ADDR
// end ;
25219: LD_VAR 0 5
25223: RET
// export function DangerAtRange ( unit , range ) ; begin
25224: LD_INT 0
25226: PPUSH
// if not unit then
25227: LD_VAR 0 1
25231: NOT
25232: IFFALSE 25236
// exit ;
25234: GO 25281
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25236: LD_ADDR_VAR 0 3
25240: PUSH
25241: LD_VAR 0 1
25245: PPUSH
25246: CALL_OW 255
25250: PPUSH
25251: LD_VAR 0 1
25255: PPUSH
25256: CALL_OW 250
25260: PPUSH
25261: LD_VAR 0 1
25265: PPUSH
25266: CALL_OW 251
25270: PPUSH
25271: LD_VAR 0 2
25275: PPUSH
25276: CALL 23523 0 4
25280: ST_TO_ADDR
// end ;
25281: LD_VAR 0 3
25285: RET
// export function DangerInArea ( side , area ) ; begin
25286: LD_INT 0
25288: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25289: LD_ADDR_VAR 0 3
25293: PUSH
25294: LD_VAR 0 2
25298: PPUSH
25299: LD_INT 81
25301: PUSH
25302: LD_VAR 0 1
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PPUSH
25311: CALL_OW 70
25315: ST_TO_ADDR
// end ;
25316: LD_VAR 0 3
25320: RET
// export function IsExtension ( b ) ; begin
25321: LD_INT 0
25323: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25324: LD_ADDR_VAR 0 2
25328: PUSH
25329: LD_VAR 0 1
25333: PUSH
25334: LD_INT 23
25336: PUSH
25337: LD_INT 20
25339: PUSH
25340: LD_INT 22
25342: PUSH
25343: LD_INT 17
25345: PUSH
25346: LD_INT 24
25348: PUSH
25349: LD_INT 21
25351: PUSH
25352: LD_INT 19
25354: PUSH
25355: LD_INT 16
25357: PUSH
25358: LD_INT 25
25360: PUSH
25361: LD_INT 18
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: IN
25376: ST_TO_ADDR
// end ;
25377: LD_VAR 0 2
25381: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25382: LD_INT 0
25384: PPUSH
25385: PPUSH
25386: PPUSH
// result := [ ] ;
25387: LD_ADDR_VAR 0 4
25391: PUSH
25392: EMPTY
25393: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25394: LD_ADDR_VAR 0 5
25398: PUSH
25399: LD_VAR 0 2
25403: PPUSH
25404: LD_INT 21
25406: PUSH
25407: LD_INT 3
25409: PUSH
25410: EMPTY
25411: LIST
25412: LIST
25413: PPUSH
25414: CALL_OW 70
25418: ST_TO_ADDR
// if not tmp then
25419: LD_VAR 0 5
25423: NOT
25424: IFFALSE 25428
// exit ;
25426: GO 25492
// if checkLink then
25428: LD_VAR 0 3
25432: IFFALSE 25482
// begin for i in tmp do
25434: LD_ADDR_VAR 0 6
25438: PUSH
25439: LD_VAR 0 5
25443: PUSH
25444: FOR_IN
25445: IFFALSE 25480
// if GetBase ( i ) <> base then
25447: LD_VAR 0 6
25451: PPUSH
25452: CALL_OW 274
25456: PUSH
25457: LD_VAR 0 1
25461: NONEQUAL
25462: IFFALSE 25478
// ComLinkToBase ( base , i ) ;
25464: LD_VAR 0 1
25468: PPUSH
25469: LD_VAR 0 6
25473: PPUSH
25474: CALL_OW 169
25478: GO 25444
25480: POP
25481: POP
// end ; result := tmp ;
25482: LD_ADDR_VAR 0 4
25486: PUSH
25487: LD_VAR 0 5
25491: ST_TO_ADDR
// end ;
25492: LD_VAR 0 4
25496: RET
// export function ComComplete ( units , b ) ; var i ; begin
25497: LD_INT 0
25499: PPUSH
25500: PPUSH
// if not units then
25501: LD_VAR 0 1
25505: NOT
25506: IFFALSE 25510
// exit ;
25508: GO 25600
// for i in units do
25510: LD_ADDR_VAR 0 4
25514: PUSH
25515: LD_VAR 0 1
25519: PUSH
25520: FOR_IN
25521: IFFALSE 25598
// if BuildingStatus ( b ) = bs_build then
25523: LD_VAR 0 2
25527: PPUSH
25528: CALL_OW 461
25532: PUSH
25533: LD_INT 1
25535: EQUAL
25536: IFFALSE 25596
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25538: LD_VAR 0 4
25542: PPUSH
25543: LD_STRING h
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 250
25555: PUSH
25556: LD_VAR 0 2
25560: PPUSH
25561: CALL_OW 251
25565: PUSH
25566: LD_VAR 0 2
25570: PUSH
25571: LD_INT 0
25573: PUSH
25574: LD_INT 0
25576: PUSH
25577: LD_INT 0
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: PUSH
25589: EMPTY
25590: LIST
25591: PPUSH
25592: CALL_OW 446
25596: GO 25520
25598: POP
25599: POP
// end ;
25600: LD_VAR 0 3
25604: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25605: LD_INT 0
25607: PPUSH
25608: PPUSH
25609: PPUSH
25610: PPUSH
25611: PPUSH
25612: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25613: LD_VAR 0 1
25617: NOT
25618: PUSH
25619: LD_VAR 0 1
25623: PPUSH
25624: CALL_OW 263
25628: PUSH
25629: LD_INT 2
25631: NONEQUAL
25632: OR
25633: IFFALSE 25637
// exit ;
25635: GO 25953
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25637: LD_ADDR_VAR 0 6
25641: PUSH
25642: LD_INT 22
25644: PUSH
25645: LD_VAR 0 1
25649: PPUSH
25650: CALL_OW 255
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PUSH
25659: LD_INT 2
25661: PUSH
25662: LD_INT 30
25664: PUSH
25665: LD_INT 36
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 34
25674: PUSH
25675: LD_INT 31
25677: PUSH
25678: EMPTY
25679: LIST
25680: LIST
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: LIST
25686: PUSH
25687: EMPTY
25688: LIST
25689: LIST
25690: PPUSH
25691: CALL_OW 69
25695: ST_TO_ADDR
// if not tmp then
25696: LD_VAR 0 6
25700: NOT
25701: IFFALSE 25705
// exit ;
25703: GO 25953
// result := [ ] ;
25705: LD_ADDR_VAR 0 2
25709: PUSH
25710: EMPTY
25711: ST_TO_ADDR
// for i in tmp do
25712: LD_ADDR_VAR 0 3
25716: PUSH
25717: LD_VAR 0 6
25721: PUSH
25722: FOR_IN
25723: IFFALSE 25794
// begin t := UnitsInside ( i ) ;
25725: LD_ADDR_VAR 0 4
25729: PUSH
25730: LD_VAR 0 3
25734: PPUSH
25735: CALL_OW 313
25739: ST_TO_ADDR
// if t then
25740: LD_VAR 0 4
25744: IFFALSE 25792
// for j in t do
25746: LD_ADDR_VAR 0 7
25750: PUSH
25751: LD_VAR 0 4
25755: PUSH
25756: FOR_IN
25757: IFFALSE 25790
// result := Replace ( result , result + 1 , j ) ;
25759: LD_ADDR_VAR 0 2
25763: PUSH
25764: LD_VAR 0 2
25768: PPUSH
25769: LD_VAR 0 2
25773: PUSH
25774: LD_INT 1
25776: PLUS
25777: PPUSH
25778: LD_VAR 0 7
25782: PPUSH
25783: CALL_OW 1
25787: ST_TO_ADDR
25788: GO 25756
25790: POP
25791: POP
// end ;
25792: GO 25722
25794: POP
25795: POP
// if not result then
25796: LD_VAR 0 2
25800: NOT
25801: IFFALSE 25805
// exit ;
25803: GO 25953
// mech := result [ 1 ] ;
25805: LD_ADDR_VAR 0 5
25809: PUSH
25810: LD_VAR 0 2
25814: PUSH
25815: LD_INT 1
25817: ARRAY
25818: ST_TO_ADDR
// if result > 1 then
25819: LD_VAR 0 2
25823: PUSH
25824: LD_INT 1
25826: GREATER
25827: IFFALSE 25939
// begin for i = 2 to result do
25829: LD_ADDR_VAR 0 3
25833: PUSH
25834: DOUBLE
25835: LD_INT 2
25837: DEC
25838: ST_TO_ADDR
25839: LD_VAR 0 2
25843: PUSH
25844: FOR_TO
25845: IFFALSE 25937
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25847: LD_ADDR_VAR 0 4
25851: PUSH
25852: LD_VAR 0 2
25856: PUSH
25857: LD_VAR 0 3
25861: ARRAY
25862: PPUSH
25863: LD_INT 3
25865: PPUSH
25866: CALL_OW 259
25870: PUSH
25871: LD_VAR 0 2
25875: PUSH
25876: LD_VAR 0 3
25880: ARRAY
25881: PPUSH
25882: CALL_OW 432
25886: MINUS
25887: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25888: LD_VAR 0 4
25892: PUSH
25893: LD_VAR 0 5
25897: PPUSH
25898: LD_INT 3
25900: PPUSH
25901: CALL_OW 259
25905: PUSH
25906: LD_VAR 0 5
25910: PPUSH
25911: CALL_OW 432
25915: MINUS
25916: GREATEREQUAL
25917: IFFALSE 25935
// mech := result [ i ] ;
25919: LD_ADDR_VAR 0 5
25923: PUSH
25924: LD_VAR 0 2
25928: PUSH
25929: LD_VAR 0 3
25933: ARRAY
25934: ST_TO_ADDR
// end ;
25935: GO 25844
25937: POP
25938: POP
// end ; ComLinkTo ( vehicle , mech ) ;
25939: LD_VAR 0 1
25943: PPUSH
25944: LD_VAR 0 5
25948: PPUSH
25949: CALL_OW 135
// end ;
25953: LD_VAR 0 2
25957: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25958: LD_INT 0
25960: PPUSH
25961: PPUSH
25962: PPUSH
25963: PPUSH
25964: PPUSH
25965: PPUSH
25966: PPUSH
25967: PPUSH
25968: PPUSH
25969: PPUSH
25970: PPUSH
25971: PPUSH
25972: PPUSH
// result := [ ] ;
25973: LD_ADDR_VAR 0 7
25977: PUSH
25978: EMPTY
25979: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25980: LD_VAR 0 1
25984: PPUSH
25985: CALL_OW 266
25989: PUSH
25990: LD_INT 0
25992: PUSH
25993: LD_INT 1
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: IN
26000: NOT
26001: IFFALSE 26005
// exit ;
26003: GO 27639
// if name then
26005: LD_VAR 0 3
26009: IFFALSE 26025
// SetBName ( base_dep , name ) ;
26011: LD_VAR 0 1
26015: PPUSH
26016: LD_VAR 0 3
26020: PPUSH
26021: CALL_OW 500
// base := GetBase ( base_dep ) ;
26025: LD_ADDR_VAR 0 15
26029: PUSH
26030: LD_VAR 0 1
26034: PPUSH
26035: CALL_OW 274
26039: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26040: LD_ADDR_VAR 0 16
26044: PUSH
26045: LD_VAR 0 1
26049: PPUSH
26050: CALL_OW 255
26054: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26055: LD_ADDR_VAR 0 17
26059: PUSH
26060: LD_VAR 0 1
26064: PPUSH
26065: CALL_OW 248
26069: ST_TO_ADDR
// if sources then
26070: LD_VAR 0 5
26074: IFFALSE 26121
// for i = 1 to 3 do
26076: LD_ADDR_VAR 0 8
26080: PUSH
26081: DOUBLE
26082: LD_INT 1
26084: DEC
26085: ST_TO_ADDR
26086: LD_INT 3
26088: PUSH
26089: FOR_TO
26090: IFFALSE 26119
// AddResourceType ( base , i , sources [ i ] ) ;
26092: LD_VAR 0 15
26096: PPUSH
26097: LD_VAR 0 8
26101: PPUSH
26102: LD_VAR 0 5
26106: PUSH
26107: LD_VAR 0 8
26111: ARRAY
26112: PPUSH
26113: CALL_OW 276
26117: GO 26089
26119: POP
26120: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26121: LD_ADDR_VAR 0 18
26125: PUSH
26126: LD_VAR 0 15
26130: PPUSH
26131: LD_VAR 0 2
26135: PPUSH
26136: LD_INT 1
26138: PPUSH
26139: CALL 25382 0 3
26143: ST_TO_ADDR
// InitHc ;
26144: CALL_OW 19
// InitUc ;
26148: CALL_OW 18
// uc_side := side ;
26152: LD_ADDR_OWVAR 20
26156: PUSH
26157: LD_VAR 0 16
26161: ST_TO_ADDR
// uc_nation := nation ;
26162: LD_ADDR_OWVAR 21
26166: PUSH
26167: LD_VAR 0 17
26171: ST_TO_ADDR
// if buildings then
26172: LD_VAR 0 18
26176: IFFALSE 27498
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26178: LD_ADDR_VAR 0 19
26182: PUSH
26183: LD_VAR 0 18
26187: PPUSH
26188: LD_INT 2
26190: PUSH
26191: LD_INT 30
26193: PUSH
26194: LD_INT 29
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 30
26203: PUSH
26204: LD_INT 30
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: PPUSH
26216: CALL_OW 72
26220: ST_TO_ADDR
// if tmp then
26221: LD_VAR 0 19
26225: IFFALSE 26273
// for i in tmp do
26227: LD_ADDR_VAR 0 8
26231: PUSH
26232: LD_VAR 0 19
26236: PUSH
26237: FOR_IN
26238: IFFALSE 26271
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26240: LD_VAR 0 8
26244: PPUSH
26245: CALL_OW 250
26249: PPUSH
26250: LD_VAR 0 8
26254: PPUSH
26255: CALL_OW 251
26259: PPUSH
26260: LD_VAR 0 16
26264: PPUSH
26265: CALL_OW 441
26269: GO 26237
26271: POP
26272: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26273: LD_VAR 0 18
26277: PPUSH
26278: LD_INT 2
26280: PUSH
26281: LD_INT 30
26283: PUSH
26284: LD_INT 32
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 30
26293: PUSH
26294: LD_INT 33
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: LIST
26305: PPUSH
26306: CALL_OW 72
26310: IFFALSE 26398
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26312: LD_ADDR_VAR 0 8
26316: PUSH
26317: LD_VAR 0 18
26321: PPUSH
26322: LD_INT 2
26324: PUSH
26325: LD_INT 30
26327: PUSH
26328: LD_INT 32
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: LD_INT 30
26337: PUSH
26338: LD_INT 33
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: LIST
26349: PPUSH
26350: CALL_OW 72
26354: PUSH
26355: FOR_IN
26356: IFFALSE 26396
// begin if not GetBWeapon ( i ) then
26358: LD_VAR 0 8
26362: PPUSH
26363: CALL_OW 269
26367: NOT
26368: IFFALSE 26394
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26370: LD_VAR 0 8
26374: PPUSH
26375: LD_VAR 0 8
26379: PPUSH
26380: LD_VAR 0 2
26384: PPUSH
26385: CALL 27644 0 2
26389: PPUSH
26390: CALL_OW 431
// end ;
26394: GO 26355
26396: POP
26397: POP
// end ; for i = 1 to personel do
26398: LD_ADDR_VAR 0 8
26402: PUSH
26403: DOUBLE
26404: LD_INT 1
26406: DEC
26407: ST_TO_ADDR
26408: LD_VAR 0 6
26412: PUSH
26413: FOR_TO
26414: IFFALSE 27478
// begin if i > 4 then
26416: LD_VAR 0 8
26420: PUSH
26421: LD_INT 4
26423: GREATER
26424: IFFALSE 26428
// break ;
26426: GO 27478
// case i of 1 :
26428: LD_VAR 0 8
26432: PUSH
26433: LD_INT 1
26435: DOUBLE
26436: EQUAL
26437: IFTRUE 26441
26439: GO 26521
26441: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26442: LD_ADDR_VAR 0 12
26446: PUSH
26447: LD_VAR 0 18
26451: PPUSH
26452: LD_INT 22
26454: PUSH
26455: LD_VAR 0 16
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 58
26466: PUSH
26467: EMPTY
26468: LIST
26469: PUSH
26470: LD_INT 2
26472: PUSH
26473: LD_INT 30
26475: PUSH
26476: LD_INT 32
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PUSH
26483: LD_INT 30
26485: PUSH
26486: LD_INT 4
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 30
26495: PUSH
26496: LD_INT 5
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: LIST
26507: LIST
26508: PUSH
26509: EMPTY
26510: LIST
26511: LIST
26512: LIST
26513: PPUSH
26514: CALL_OW 72
26518: ST_TO_ADDR
26519: GO 26743
26521: LD_INT 2
26523: DOUBLE
26524: EQUAL
26525: IFTRUE 26529
26527: GO 26591
26529: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26530: LD_ADDR_VAR 0 12
26534: PUSH
26535: LD_VAR 0 18
26539: PPUSH
26540: LD_INT 22
26542: PUSH
26543: LD_VAR 0 16
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 2
26554: PUSH
26555: LD_INT 30
26557: PUSH
26558: LD_INT 0
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PUSH
26565: LD_INT 30
26567: PUSH
26568: LD_INT 1
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PPUSH
26584: CALL_OW 72
26588: ST_TO_ADDR
26589: GO 26743
26591: LD_INT 3
26593: DOUBLE
26594: EQUAL
26595: IFTRUE 26599
26597: GO 26661
26599: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26600: LD_ADDR_VAR 0 12
26604: PUSH
26605: LD_VAR 0 18
26609: PPUSH
26610: LD_INT 22
26612: PUSH
26613: LD_VAR 0 16
26617: PUSH
26618: EMPTY
26619: LIST
26620: LIST
26621: PUSH
26622: LD_INT 2
26624: PUSH
26625: LD_INT 30
26627: PUSH
26628: LD_INT 2
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 30
26637: PUSH
26638: LD_INT 3
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: LIST
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: PPUSH
26654: CALL_OW 72
26658: ST_TO_ADDR
26659: GO 26743
26661: LD_INT 4
26663: DOUBLE
26664: EQUAL
26665: IFTRUE 26669
26667: GO 26742
26669: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26670: LD_ADDR_VAR 0 12
26674: PUSH
26675: LD_VAR 0 18
26679: PPUSH
26680: LD_INT 22
26682: PUSH
26683: LD_VAR 0 16
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 2
26694: PUSH
26695: LD_INT 30
26697: PUSH
26698: LD_INT 6
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 30
26707: PUSH
26708: LD_INT 7
26710: PUSH
26711: EMPTY
26712: LIST
26713: LIST
26714: PUSH
26715: LD_INT 30
26717: PUSH
26718: LD_INT 8
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PPUSH
26735: CALL_OW 72
26739: ST_TO_ADDR
26740: GO 26743
26742: POP
// if i = 1 then
26743: LD_VAR 0 8
26747: PUSH
26748: LD_INT 1
26750: EQUAL
26751: IFFALSE 26862
// begin tmp := [ ] ;
26753: LD_ADDR_VAR 0 19
26757: PUSH
26758: EMPTY
26759: ST_TO_ADDR
// for j in f do
26760: LD_ADDR_VAR 0 9
26764: PUSH
26765: LD_VAR 0 12
26769: PUSH
26770: FOR_IN
26771: IFFALSE 26844
// if GetBType ( j ) = b_bunker then
26773: LD_VAR 0 9
26777: PPUSH
26778: CALL_OW 266
26782: PUSH
26783: LD_INT 32
26785: EQUAL
26786: IFFALSE 26813
// tmp := Insert ( tmp , 1 , j ) else
26788: LD_ADDR_VAR 0 19
26792: PUSH
26793: LD_VAR 0 19
26797: PPUSH
26798: LD_INT 1
26800: PPUSH
26801: LD_VAR 0 9
26805: PPUSH
26806: CALL_OW 2
26810: ST_TO_ADDR
26811: GO 26842
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26813: LD_ADDR_VAR 0 19
26817: PUSH
26818: LD_VAR 0 19
26822: PPUSH
26823: LD_VAR 0 19
26827: PUSH
26828: LD_INT 1
26830: PLUS
26831: PPUSH
26832: LD_VAR 0 9
26836: PPUSH
26837: CALL_OW 2
26841: ST_TO_ADDR
26842: GO 26770
26844: POP
26845: POP
// if tmp then
26846: LD_VAR 0 19
26850: IFFALSE 26862
// f := tmp ;
26852: LD_ADDR_VAR 0 12
26856: PUSH
26857: LD_VAR 0 19
26861: ST_TO_ADDR
// end ; x := personel [ i ] ;
26862: LD_ADDR_VAR 0 13
26866: PUSH
26867: LD_VAR 0 6
26871: PUSH
26872: LD_VAR 0 8
26876: ARRAY
26877: ST_TO_ADDR
// if x = - 1 then
26878: LD_VAR 0 13
26882: PUSH
26883: LD_INT 1
26885: NEG
26886: EQUAL
26887: IFFALSE 27096
// begin for j in f do
26889: LD_ADDR_VAR 0 9
26893: PUSH
26894: LD_VAR 0 12
26898: PUSH
26899: FOR_IN
26900: IFFALSE 27092
// repeat InitHc ;
26902: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26906: LD_VAR 0 9
26910: PPUSH
26911: CALL_OW 266
26915: PUSH
26916: LD_INT 5
26918: EQUAL
26919: IFFALSE 26989
// begin if UnitsInside ( j ) < 3 then
26921: LD_VAR 0 9
26925: PPUSH
26926: CALL_OW 313
26930: PUSH
26931: LD_INT 3
26933: LESS
26934: IFFALSE 26970
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26936: LD_INT 0
26938: PPUSH
26939: LD_INT 5
26941: PUSH
26942: LD_INT 8
26944: PUSH
26945: LD_INT 9
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: LIST
26952: PUSH
26953: LD_VAR 0 17
26957: ARRAY
26958: PPUSH
26959: LD_VAR 0 4
26963: PPUSH
26964: CALL_OW 380
26968: GO 26987
// PrepareHuman ( false , i , skill ) ;
26970: LD_INT 0
26972: PPUSH
26973: LD_VAR 0 8
26977: PPUSH
26978: LD_VAR 0 4
26982: PPUSH
26983: CALL_OW 380
// end else
26987: GO 27006
// PrepareHuman ( false , i , skill ) ;
26989: LD_INT 0
26991: PPUSH
26992: LD_VAR 0 8
26996: PPUSH
26997: LD_VAR 0 4
27001: PPUSH
27002: CALL_OW 380
// un := CreateHuman ;
27006: LD_ADDR_VAR 0 14
27010: PUSH
27011: CALL_OW 44
27015: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27016: LD_ADDR_VAR 0 7
27020: PUSH
27021: LD_VAR 0 7
27025: PPUSH
27026: LD_INT 1
27028: PPUSH
27029: LD_VAR 0 14
27033: PPUSH
27034: CALL_OW 2
27038: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27039: LD_VAR 0 14
27043: PPUSH
27044: LD_VAR 0 9
27048: PPUSH
27049: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27053: LD_VAR 0 9
27057: PPUSH
27058: CALL_OW 313
27062: PUSH
27063: LD_INT 6
27065: EQUAL
27066: PUSH
27067: LD_VAR 0 9
27071: PPUSH
27072: CALL_OW 266
27076: PUSH
27077: LD_INT 32
27079: PUSH
27080: LD_INT 31
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: IN
27087: OR
27088: IFFALSE 26902
27090: GO 26899
27092: POP
27093: POP
// end else
27094: GO 27476
// for j = 1 to x do
27096: LD_ADDR_VAR 0 9
27100: PUSH
27101: DOUBLE
27102: LD_INT 1
27104: DEC
27105: ST_TO_ADDR
27106: LD_VAR 0 13
27110: PUSH
27111: FOR_TO
27112: IFFALSE 27474
// begin InitHc ;
27114: CALL_OW 19
// if not f then
27118: LD_VAR 0 12
27122: NOT
27123: IFFALSE 27212
// begin PrepareHuman ( false , i , skill ) ;
27125: LD_INT 0
27127: PPUSH
27128: LD_VAR 0 8
27132: PPUSH
27133: LD_VAR 0 4
27137: PPUSH
27138: CALL_OW 380
// un := CreateHuman ;
27142: LD_ADDR_VAR 0 14
27146: PUSH
27147: CALL_OW 44
27151: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27152: LD_ADDR_VAR 0 7
27156: PUSH
27157: LD_VAR 0 7
27161: PPUSH
27162: LD_INT 1
27164: PPUSH
27165: LD_VAR 0 14
27169: PPUSH
27170: CALL_OW 2
27174: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27175: LD_VAR 0 14
27179: PPUSH
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 250
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL_OW 251
27199: PPUSH
27200: LD_INT 10
27202: PPUSH
27203: LD_INT 0
27205: PPUSH
27206: CALL_OW 50
// continue ;
27210: GO 27111
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27212: LD_VAR 0 12
27216: PUSH
27217: LD_INT 1
27219: ARRAY
27220: PPUSH
27221: CALL_OW 313
27225: PUSH
27226: LD_VAR 0 12
27230: PUSH
27231: LD_INT 1
27233: ARRAY
27234: PPUSH
27235: CALL_OW 266
27239: PUSH
27240: LD_INT 32
27242: PUSH
27243: LD_INT 31
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: IN
27250: AND
27251: PUSH
27252: LD_VAR 0 12
27256: PUSH
27257: LD_INT 1
27259: ARRAY
27260: PPUSH
27261: CALL_OW 313
27265: PUSH
27266: LD_INT 6
27268: EQUAL
27269: OR
27270: IFFALSE 27290
// f := Delete ( f , 1 ) ;
27272: LD_ADDR_VAR 0 12
27276: PUSH
27277: LD_VAR 0 12
27281: PPUSH
27282: LD_INT 1
27284: PPUSH
27285: CALL_OW 3
27289: ST_TO_ADDR
// if not f then
27290: LD_VAR 0 12
27294: NOT
27295: IFFALSE 27313
// begin x := x + 2 ;
27297: LD_ADDR_VAR 0 13
27301: PUSH
27302: LD_VAR 0 13
27306: PUSH
27307: LD_INT 2
27309: PLUS
27310: ST_TO_ADDR
// continue ;
27311: GO 27111
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27313: LD_VAR 0 12
27317: PUSH
27318: LD_INT 1
27320: ARRAY
27321: PPUSH
27322: CALL_OW 266
27326: PUSH
27327: LD_INT 5
27329: EQUAL
27330: IFFALSE 27404
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27332: LD_VAR 0 12
27336: PUSH
27337: LD_INT 1
27339: ARRAY
27340: PPUSH
27341: CALL_OW 313
27345: PUSH
27346: LD_INT 3
27348: LESS
27349: IFFALSE 27385
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27351: LD_INT 0
27353: PPUSH
27354: LD_INT 5
27356: PUSH
27357: LD_INT 8
27359: PUSH
27360: LD_INT 9
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: LIST
27367: PUSH
27368: LD_VAR 0 17
27372: ARRAY
27373: PPUSH
27374: LD_VAR 0 4
27378: PPUSH
27379: CALL_OW 380
27383: GO 27402
// PrepareHuman ( false , i , skill ) ;
27385: LD_INT 0
27387: PPUSH
27388: LD_VAR 0 8
27392: PPUSH
27393: LD_VAR 0 4
27397: PPUSH
27398: CALL_OW 380
// end else
27402: GO 27421
// PrepareHuman ( false , i , skill ) ;
27404: LD_INT 0
27406: PPUSH
27407: LD_VAR 0 8
27411: PPUSH
27412: LD_VAR 0 4
27416: PPUSH
27417: CALL_OW 380
// un := CreateHuman ;
27421: LD_ADDR_VAR 0 14
27425: PUSH
27426: CALL_OW 44
27430: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27431: LD_ADDR_VAR 0 7
27435: PUSH
27436: LD_VAR 0 7
27440: PPUSH
27441: LD_INT 1
27443: PPUSH
27444: LD_VAR 0 14
27448: PPUSH
27449: CALL_OW 2
27453: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27454: LD_VAR 0 14
27458: PPUSH
27459: LD_VAR 0 12
27463: PUSH
27464: LD_INT 1
27466: ARRAY
27467: PPUSH
27468: CALL_OW 52
// end ;
27472: GO 27111
27474: POP
27475: POP
// end ;
27476: GO 26413
27478: POP
27479: POP
// result := result ^ buildings ;
27480: LD_ADDR_VAR 0 7
27484: PUSH
27485: LD_VAR 0 7
27489: PUSH
27490: LD_VAR 0 18
27494: ADD
27495: ST_TO_ADDR
// end else
27496: GO 27639
// begin for i = 1 to personel do
27498: LD_ADDR_VAR 0 8
27502: PUSH
27503: DOUBLE
27504: LD_INT 1
27506: DEC
27507: ST_TO_ADDR
27508: LD_VAR 0 6
27512: PUSH
27513: FOR_TO
27514: IFFALSE 27637
// begin if i > 4 then
27516: LD_VAR 0 8
27520: PUSH
27521: LD_INT 4
27523: GREATER
27524: IFFALSE 27528
// break ;
27526: GO 27637
// x := personel [ i ] ;
27528: LD_ADDR_VAR 0 13
27532: PUSH
27533: LD_VAR 0 6
27537: PUSH
27538: LD_VAR 0 8
27542: ARRAY
27543: ST_TO_ADDR
// if x = - 1 then
27544: LD_VAR 0 13
27548: PUSH
27549: LD_INT 1
27551: NEG
27552: EQUAL
27553: IFFALSE 27557
// continue ;
27555: GO 27513
// PrepareHuman ( false , i , skill ) ;
27557: LD_INT 0
27559: PPUSH
27560: LD_VAR 0 8
27564: PPUSH
27565: LD_VAR 0 4
27569: PPUSH
27570: CALL_OW 380
// un := CreateHuman ;
27574: LD_ADDR_VAR 0 14
27578: PUSH
27579: CALL_OW 44
27583: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27584: LD_VAR 0 14
27588: PPUSH
27589: LD_VAR 0 1
27593: PPUSH
27594: CALL_OW 250
27598: PPUSH
27599: LD_VAR 0 1
27603: PPUSH
27604: CALL_OW 251
27608: PPUSH
27609: LD_INT 10
27611: PPUSH
27612: LD_INT 0
27614: PPUSH
27615: CALL_OW 50
// result := result ^ un ;
27619: LD_ADDR_VAR 0 7
27623: PUSH
27624: LD_VAR 0 7
27628: PUSH
27629: LD_VAR 0 14
27633: ADD
27634: ST_TO_ADDR
// end ;
27635: GO 27513
27637: POP
27638: POP
// end ; end ;
27639: LD_VAR 0 7
27643: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27644: LD_INT 0
27646: PPUSH
27647: PPUSH
27648: PPUSH
27649: PPUSH
27650: PPUSH
27651: PPUSH
27652: PPUSH
27653: PPUSH
27654: PPUSH
27655: PPUSH
27656: PPUSH
27657: PPUSH
27658: PPUSH
27659: PPUSH
27660: PPUSH
27661: PPUSH
// result := false ;
27662: LD_ADDR_VAR 0 3
27666: PUSH
27667: LD_INT 0
27669: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27670: LD_VAR 0 1
27674: NOT
27675: PUSH
27676: LD_VAR 0 1
27680: PPUSH
27681: CALL_OW 266
27685: PUSH
27686: LD_INT 32
27688: PUSH
27689: LD_INT 33
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: IN
27696: NOT
27697: OR
27698: IFFALSE 27702
// exit ;
27700: GO 28811
// nat := GetNation ( tower ) ;
27702: LD_ADDR_VAR 0 12
27706: PUSH
27707: LD_VAR 0 1
27711: PPUSH
27712: CALL_OW 248
27716: ST_TO_ADDR
// side := GetSide ( tower ) ;
27717: LD_ADDR_VAR 0 16
27721: PUSH
27722: LD_VAR 0 1
27726: PPUSH
27727: CALL_OW 255
27731: ST_TO_ADDR
// x := GetX ( tower ) ;
27732: LD_ADDR_VAR 0 10
27736: PUSH
27737: LD_VAR 0 1
27741: PPUSH
27742: CALL_OW 250
27746: ST_TO_ADDR
// y := GetY ( tower ) ;
27747: LD_ADDR_VAR 0 11
27751: PUSH
27752: LD_VAR 0 1
27756: PPUSH
27757: CALL_OW 251
27761: ST_TO_ADDR
// if not x or not y then
27762: LD_VAR 0 10
27766: NOT
27767: PUSH
27768: LD_VAR 0 11
27772: NOT
27773: OR
27774: IFFALSE 27778
// exit ;
27776: GO 28811
// weapon := 0 ;
27778: LD_ADDR_VAR 0 18
27782: PUSH
27783: LD_INT 0
27785: ST_TO_ADDR
// fac_list := [ ] ;
27786: LD_ADDR_VAR 0 17
27790: PUSH
27791: EMPTY
27792: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
27793: LD_ADDR_VAR 0 6
27797: PUSH
27798: LD_VAR 0 1
27802: PPUSH
27803: CALL_OW 274
27807: PPUSH
27808: LD_VAR 0 2
27812: PPUSH
27813: LD_INT 0
27815: PPUSH
27816: CALL 25382 0 3
27820: PPUSH
27821: LD_INT 30
27823: PUSH
27824: LD_INT 3
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 72
27835: ST_TO_ADDR
// if not factories then
27836: LD_VAR 0 6
27840: NOT
27841: IFFALSE 27845
// exit ;
27843: GO 28811
// for i in factories do
27845: LD_ADDR_VAR 0 8
27849: PUSH
27850: LD_VAR 0 6
27854: PUSH
27855: FOR_IN
27856: IFFALSE 27881
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27858: LD_ADDR_VAR 0 17
27862: PUSH
27863: LD_VAR 0 17
27867: PUSH
27868: LD_VAR 0 8
27872: PPUSH
27873: CALL_OW 478
27877: UNION
27878: ST_TO_ADDR
27879: GO 27855
27881: POP
27882: POP
// if not fac_list then
27883: LD_VAR 0 17
27887: NOT
27888: IFFALSE 27892
// exit ;
27890: GO 28811
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27892: LD_ADDR_VAR 0 5
27896: PUSH
27897: LD_INT 4
27899: PUSH
27900: LD_INT 5
27902: PUSH
27903: LD_INT 9
27905: PUSH
27906: LD_INT 10
27908: PUSH
27909: LD_INT 6
27911: PUSH
27912: LD_INT 7
27914: PUSH
27915: LD_INT 11
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 27
27929: PUSH
27930: LD_INT 28
27932: PUSH
27933: LD_INT 26
27935: PUSH
27936: LD_INT 30
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: LIST
27943: LIST
27944: PUSH
27945: LD_INT 43
27947: PUSH
27948: LD_INT 44
27950: PUSH
27951: LD_INT 46
27953: PUSH
27954: LD_INT 45
27956: PUSH
27957: LD_INT 47
27959: PUSH
27960: LD_INT 49
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: LIST
27975: PUSH
27976: LD_VAR 0 12
27980: ARRAY
27981: ST_TO_ADDR
// list := list isect fac_list ;
27982: LD_ADDR_VAR 0 5
27986: PUSH
27987: LD_VAR 0 5
27991: PUSH
27992: LD_VAR 0 17
27996: ISECT
27997: ST_TO_ADDR
// if not list then
27998: LD_VAR 0 5
28002: NOT
28003: IFFALSE 28007
// exit ;
28005: GO 28811
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
28007: LD_VAR 0 12
28011: PUSH
28012: LD_INT 3
28014: EQUAL
28015: PUSH
28016: LD_INT 49
28018: PUSH
28019: LD_VAR 0 5
28023: IN
28024: AND
28025: PUSH
28026: LD_INT 31
28028: PPUSH
28029: LD_VAR 0 16
28033: PPUSH
28034: CALL_OW 321
28038: PUSH
28039: LD_INT 2
28041: EQUAL
28042: AND
28043: IFFALSE 28103
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28045: LD_INT 22
28047: PUSH
28048: LD_VAR 0 16
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 35
28059: PUSH
28060: LD_INT 49
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 91
28069: PUSH
28070: LD_VAR 0 1
28074: PUSH
28075: LD_INT 10
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: LIST
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: LIST
28087: PPUSH
28088: CALL_OW 69
28092: NOT
28093: IFFALSE 28103
// weapon := ru_time_lapser ;
28095: LD_ADDR_VAR 0 18
28099: PUSH
28100: LD_INT 49
28102: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28103: LD_VAR 0 12
28107: PUSH
28108: LD_INT 1
28110: PUSH
28111: LD_INT 2
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: IN
28118: PUSH
28119: LD_INT 11
28121: PUSH
28122: LD_VAR 0 5
28126: IN
28127: PUSH
28128: LD_INT 30
28130: PUSH
28131: LD_VAR 0 5
28135: IN
28136: OR
28137: AND
28138: PUSH
28139: LD_INT 6
28141: PPUSH
28142: LD_VAR 0 16
28146: PPUSH
28147: CALL_OW 321
28151: PUSH
28152: LD_INT 2
28154: EQUAL
28155: AND
28156: IFFALSE 28321
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28158: LD_INT 22
28160: PUSH
28161: LD_VAR 0 16
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: LD_INT 35
28175: PUSH
28176: LD_INT 11
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 35
28185: PUSH
28186: LD_INT 30
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 91
28200: PUSH
28201: LD_VAR 0 1
28205: PUSH
28206: LD_INT 18
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: LIST
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: LIST
28218: PPUSH
28219: CALL_OW 69
28223: NOT
28224: PUSH
28225: LD_INT 22
28227: PUSH
28228: LD_VAR 0 16
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 2
28239: PUSH
28240: LD_INT 30
28242: PUSH
28243: LD_INT 32
28245: PUSH
28246: EMPTY
28247: LIST
28248: LIST
28249: PUSH
28250: LD_INT 30
28252: PUSH
28253: LD_INT 33
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 91
28267: PUSH
28268: LD_VAR 0 1
28272: PUSH
28273: LD_INT 12
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: LIST
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: LIST
28285: PUSH
28286: EMPTY
28287: LIST
28288: PPUSH
28289: CALL_OW 69
28293: PUSH
28294: LD_INT 2
28296: GREATER
28297: AND
28298: IFFALSE 28321
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28300: LD_ADDR_VAR 0 18
28304: PUSH
28305: LD_INT 11
28307: PUSH
28308: LD_INT 30
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_VAR 0 12
28319: ARRAY
28320: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28321: LD_VAR 0 18
28325: NOT
28326: PUSH
28327: LD_INT 40
28329: PPUSH
28330: LD_VAR 0 16
28334: PPUSH
28335: CALL_OW 321
28339: PUSH
28340: LD_INT 2
28342: EQUAL
28343: AND
28344: PUSH
28345: LD_INT 7
28347: PUSH
28348: LD_VAR 0 5
28352: IN
28353: PUSH
28354: LD_INT 28
28356: PUSH
28357: LD_VAR 0 5
28361: IN
28362: OR
28363: PUSH
28364: LD_INT 45
28366: PUSH
28367: LD_VAR 0 5
28371: IN
28372: OR
28373: AND
28374: IFFALSE 28628
// begin hex := GetHexInfo ( x , y ) ;
28376: LD_ADDR_VAR 0 4
28380: PUSH
28381: LD_VAR 0 10
28385: PPUSH
28386: LD_VAR 0 11
28390: PPUSH
28391: CALL_OW 546
28395: ST_TO_ADDR
// if hex [ 1 ] then
28396: LD_VAR 0 4
28400: PUSH
28401: LD_INT 1
28403: ARRAY
28404: IFFALSE 28408
// exit ;
28406: GO 28811
// height := hex [ 2 ] ;
28408: LD_ADDR_VAR 0 15
28412: PUSH
28413: LD_VAR 0 4
28417: PUSH
28418: LD_INT 2
28420: ARRAY
28421: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28422: LD_ADDR_VAR 0 14
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: LD_INT 2
28432: PUSH
28433: LD_INT 3
28435: PUSH
28436: LD_INT 5
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: LIST
28443: LIST
28444: ST_TO_ADDR
// for i in tmp do
28445: LD_ADDR_VAR 0 8
28449: PUSH
28450: LD_VAR 0 14
28454: PUSH
28455: FOR_IN
28456: IFFALSE 28626
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28458: LD_ADDR_VAR 0 9
28462: PUSH
28463: LD_VAR 0 10
28467: PPUSH
28468: LD_VAR 0 8
28472: PPUSH
28473: LD_INT 5
28475: PPUSH
28476: CALL_OW 272
28480: PUSH
28481: LD_VAR 0 11
28485: PPUSH
28486: LD_VAR 0 8
28490: PPUSH
28491: LD_INT 5
28493: PPUSH
28494: CALL_OW 273
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28503: LD_VAR 0 9
28507: PUSH
28508: LD_INT 1
28510: ARRAY
28511: PPUSH
28512: LD_VAR 0 9
28516: PUSH
28517: LD_INT 2
28519: ARRAY
28520: PPUSH
28521: CALL_OW 488
28525: IFFALSE 28624
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28527: LD_ADDR_VAR 0 4
28531: PUSH
28532: LD_VAR 0 9
28536: PUSH
28537: LD_INT 1
28539: ARRAY
28540: PPUSH
28541: LD_VAR 0 9
28545: PUSH
28546: LD_INT 2
28548: ARRAY
28549: PPUSH
28550: CALL_OW 546
28554: ST_TO_ADDR
// if hex [ 1 ] then
28555: LD_VAR 0 4
28559: PUSH
28560: LD_INT 1
28562: ARRAY
28563: IFFALSE 28567
// continue ;
28565: GO 28455
// h := hex [ 2 ] ;
28567: LD_ADDR_VAR 0 13
28571: PUSH
28572: LD_VAR 0 4
28576: PUSH
28577: LD_INT 2
28579: ARRAY
28580: ST_TO_ADDR
// if h + 7 < height then
28581: LD_VAR 0 13
28585: PUSH
28586: LD_INT 7
28588: PLUS
28589: PUSH
28590: LD_VAR 0 15
28594: LESS
28595: IFFALSE 28624
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28597: LD_ADDR_VAR 0 18
28601: PUSH
28602: LD_INT 7
28604: PUSH
28605: LD_INT 28
28607: PUSH
28608: LD_INT 45
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: LIST
28615: PUSH
28616: LD_VAR 0 12
28620: ARRAY
28621: ST_TO_ADDR
// break ;
28622: GO 28626
// end ; end ; end ;
28624: GO 28455
28626: POP
28627: POP
// end ; if not weapon then
28628: LD_VAR 0 18
28632: NOT
28633: IFFALSE 28693
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28635: LD_ADDR_VAR 0 5
28639: PUSH
28640: LD_VAR 0 5
28644: PUSH
28645: LD_INT 11
28647: PUSH
28648: LD_INT 30
28650: PUSH
28651: LD_INT 49
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: LIST
28658: DIFF
28659: ST_TO_ADDR
// if not list then
28660: LD_VAR 0 5
28664: NOT
28665: IFFALSE 28669
// exit ;
28667: GO 28811
// weapon := list [ rand ( 1 , list ) ] ;
28669: LD_ADDR_VAR 0 18
28673: PUSH
28674: LD_VAR 0 5
28678: PUSH
28679: LD_INT 1
28681: PPUSH
28682: LD_VAR 0 5
28686: PPUSH
28687: CALL_OW 12
28691: ARRAY
28692: ST_TO_ADDR
// end ; if weapon then
28693: LD_VAR 0 18
28697: IFFALSE 28811
// begin tmp := CostOfWeapon ( weapon ) ;
28699: LD_ADDR_VAR 0 14
28703: PUSH
28704: LD_VAR 0 18
28708: PPUSH
28709: CALL_OW 451
28713: ST_TO_ADDR
// j := GetBase ( tower ) ;
28714: LD_ADDR_VAR 0 9
28718: PUSH
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 274
28728: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28729: LD_VAR 0 9
28733: PPUSH
28734: LD_INT 1
28736: PPUSH
28737: CALL_OW 275
28741: PUSH
28742: LD_VAR 0 14
28746: PUSH
28747: LD_INT 1
28749: ARRAY
28750: GREATEREQUAL
28751: PUSH
28752: LD_VAR 0 9
28756: PPUSH
28757: LD_INT 2
28759: PPUSH
28760: CALL_OW 275
28764: PUSH
28765: LD_VAR 0 14
28769: PUSH
28770: LD_INT 2
28772: ARRAY
28773: GREATEREQUAL
28774: AND
28775: PUSH
28776: LD_VAR 0 9
28780: PPUSH
28781: LD_INT 3
28783: PPUSH
28784: CALL_OW 275
28788: PUSH
28789: LD_VAR 0 14
28793: PUSH
28794: LD_INT 3
28796: ARRAY
28797: GREATEREQUAL
28798: AND
28799: IFFALSE 28811
// result := weapon ;
28801: LD_ADDR_VAR 0 3
28805: PUSH
28806: LD_VAR 0 18
28810: ST_TO_ADDR
// end ; end ;
28811: LD_VAR 0 3
28815: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28816: LD_INT 0
28818: PPUSH
28819: PPUSH
// result := true ;
28820: LD_ADDR_VAR 0 3
28824: PUSH
28825: LD_INT 1
28827: ST_TO_ADDR
// if array1 = array2 then
28828: LD_VAR 0 1
28832: PUSH
28833: LD_VAR 0 2
28837: EQUAL
28838: IFFALSE 28898
// begin for i = 1 to array1 do
28840: LD_ADDR_VAR 0 4
28844: PUSH
28845: DOUBLE
28846: LD_INT 1
28848: DEC
28849: ST_TO_ADDR
28850: LD_VAR 0 1
28854: PUSH
28855: FOR_TO
28856: IFFALSE 28894
// if array1 [ i ] <> array2 [ i ] then
28858: LD_VAR 0 1
28862: PUSH
28863: LD_VAR 0 4
28867: ARRAY
28868: PUSH
28869: LD_VAR 0 2
28873: PUSH
28874: LD_VAR 0 4
28878: ARRAY
28879: NONEQUAL
28880: IFFALSE 28892
// begin result := false ;
28882: LD_ADDR_VAR 0 3
28886: PUSH
28887: LD_INT 0
28889: ST_TO_ADDR
// break ;
28890: GO 28894
// end ;
28892: GO 28855
28894: POP
28895: POP
// end else
28896: GO 28906
// result := false ;
28898: LD_ADDR_VAR 0 3
28902: PUSH
28903: LD_INT 0
28905: ST_TO_ADDR
// end ;
28906: LD_VAR 0 3
28910: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28911: LD_INT 0
28913: PPUSH
28914: PPUSH
// if not array1 or not array2 then
28915: LD_VAR 0 1
28919: NOT
28920: PUSH
28921: LD_VAR 0 2
28925: NOT
28926: OR
28927: IFFALSE 28931
// exit ;
28929: GO 28995
// result := true ;
28931: LD_ADDR_VAR 0 3
28935: PUSH
28936: LD_INT 1
28938: ST_TO_ADDR
// for i = 1 to array1 do
28939: LD_ADDR_VAR 0 4
28943: PUSH
28944: DOUBLE
28945: LD_INT 1
28947: DEC
28948: ST_TO_ADDR
28949: LD_VAR 0 1
28953: PUSH
28954: FOR_TO
28955: IFFALSE 28993
// if array1 [ i ] <> array2 [ i ] then
28957: LD_VAR 0 1
28961: PUSH
28962: LD_VAR 0 4
28966: ARRAY
28967: PUSH
28968: LD_VAR 0 2
28972: PUSH
28973: LD_VAR 0 4
28977: ARRAY
28978: NONEQUAL
28979: IFFALSE 28991
// begin result := false ;
28981: LD_ADDR_VAR 0 3
28985: PUSH
28986: LD_INT 0
28988: ST_TO_ADDR
// break ;
28989: GO 28993
// end ;
28991: GO 28954
28993: POP
28994: POP
// end ;
28995: LD_VAR 0 3
28999: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
29000: LD_INT 0
29002: PPUSH
29003: PPUSH
29004: PPUSH
// pom := GetBase ( fac ) ;
29005: LD_ADDR_VAR 0 5
29009: PUSH
29010: LD_VAR 0 1
29014: PPUSH
29015: CALL_OW 274
29019: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
29020: LD_ADDR_VAR 0 4
29024: PUSH
29025: LD_VAR 0 2
29029: PUSH
29030: LD_INT 1
29032: ARRAY
29033: PPUSH
29034: LD_VAR 0 2
29038: PUSH
29039: LD_INT 2
29041: ARRAY
29042: PPUSH
29043: LD_VAR 0 2
29047: PUSH
29048: LD_INT 3
29050: ARRAY
29051: PPUSH
29052: LD_VAR 0 2
29056: PUSH
29057: LD_INT 4
29059: ARRAY
29060: PPUSH
29061: CALL_OW 449
29065: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29066: LD_ADDR_VAR 0 3
29070: PUSH
29071: LD_VAR 0 5
29075: PPUSH
29076: LD_INT 1
29078: PPUSH
29079: CALL_OW 275
29083: PUSH
29084: LD_VAR 0 4
29088: PUSH
29089: LD_INT 1
29091: ARRAY
29092: GREATEREQUAL
29093: PUSH
29094: LD_VAR 0 5
29098: PPUSH
29099: LD_INT 2
29101: PPUSH
29102: CALL_OW 275
29106: PUSH
29107: LD_VAR 0 4
29111: PUSH
29112: LD_INT 2
29114: ARRAY
29115: GREATEREQUAL
29116: AND
29117: PUSH
29118: LD_VAR 0 5
29122: PPUSH
29123: LD_INT 3
29125: PPUSH
29126: CALL_OW 275
29130: PUSH
29131: LD_VAR 0 4
29135: PUSH
29136: LD_INT 3
29138: ARRAY
29139: GREATEREQUAL
29140: AND
29141: ST_TO_ADDR
// end ;
29142: LD_VAR 0 3
29146: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29147: LD_INT 0
29149: PPUSH
29150: PPUSH
29151: PPUSH
29152: PPUSH
// pom := GetBase ( building ) ;
29153: LD_ADDR_VAR 0 3
29157: PUSH
29158: LD_VAR 0 1
29162: PPUSH
29163: CALL_OW 274
29167: ST_TO_ADDR
// if not pom then
29168: LD_VAR 0 3
29172: NOT
29173: IFFALSE 29177
// exit ;
29175: GO 29347
// btype := GetBType ( building ) ;
29177: LD_ADDR_VAR 0 5
29181: PUSH
29182: LD_VAR 0 1
29186: PPUSH
29187: CALL_OW 266
29191: ST_TO_ADDR
// if btype = b_armoury then
29192: LD_VAR 0 5
29196: PUSH
29197: LD_INT 4
29199: EQUAL
29200: IFFALSE 29210
// btype := b_barracks ;
29202: LD_ADDR_VAR 0 5
29206: PUSH
29207: LD_INT 5
29209: ST_TO_ADDR
// if btype = b_depot then
29210: LD_VAR 0 5
29214: PUSH
29215: LD_INT 0
29217: EQUAL
29218: IFFALSE 29228
// btype := b_warehouse ;
29220: LD_ADDR_VAR 0 5
29224: PUSH
29225: LD_INT 1
29227: ST_TO_ADDR
// if btype = b_workshop then
29228: LD_VAR 0 5
29232: PUSH
29233: LD_INT 2
29235: EQUAL
29236: IFFALSE 29246
// btype := b_factory ;
29238: LD_ADDR_VAR 0 5
29242: PUSH
29243: LD_INT 3
29245: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29246: LD_ADDR_VAR 0 4
29250: PUSH
29251: LD_VAR 0 5
29255: PPUSH
29256: LD_VAR 0 1
29260: PPUSH
29261: CALL_OW 248
29265: PPUSH
29266: CALL_OW 450
29270: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29271: LD_ADDR_VAR 0 2
29275: PUSH
29276: LD_VAR 0 3
29280: PPUSH
29281: LD_INT 1
29283: PPUSH
29284: CALL_OW 275
29288: PUSH
29289: LD_VAR 0 4
29293: PUSH
29294: LD_INT 1
29296: ARRAY
29297: GREATEREQUAL
29298: PUSH
29299: LD_VAR 0 3
29303: PPUSH
29304: LD_INT 2
29306: PPUSH
29307: CALL_OW 275
29311: PUSH
29312: LD_VAR 0 4
29316: PUSH
29317: LD_INT 2
29319: ARRAY
29320: GREATEREQUAL
29321: AND
29322: PUSH
29323: LD_VAR 0 3
29327: PPUSH
29328: LD_INT 3
29330: PPUSH
29331: CALL_OW 275
29335: PUSH
29336: LD_VAR 0 4
29340: PUSH
29341: LD_INT 3
29343: ARRAY
29344: GREATEREQUAL
29345: AND
29346: ST_TO_ADDR
// end ;
29347: LD_VAR 0 2
29351: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29352: LD_INT 0
29354: PPUSH
29355: PPUSH
29356: PPUSH
// pom := GetBase ( building ) ;
29357: LD_ADDR_VAR 0 4
29361: PUSH
29362: LD_VAR 0 1
29366: PPUSH
29367: CALL_OW 274
29371: ST_TO_ADDR
// if not pom then
29372: LD_VAR 0 4
29376: NOT
29377: IFFALSE 29381
// exit ;
29379: GO 29482
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29381: LD_ADDR_VAR 0 5
29385: PUSH
29386: LD_VAR 0 2
29390: PPUSH
29391: LD_VAR 0 1
29395: PPUSH
29396: CALL_OW 248
29400: PPUSH
29401: CALL_OW 450
29405: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29406: LD_ADDR_VAR 0 3
29410: PUSH
29411: LD_VAR 0 4
29415: PPUSH
29416: LD_INT 1
29418: PPUSH
29419: CALL_OW 275
29423: PUSH
29424: LD_VAR 0 5
29428: PUSH
29429: LD_INT 1
29431: ARRAY
29432: GREATEREQUAL
29433: PUSH
29434: LD_VAR 0 4
29438: PPUSH
29439: LD_INT 2
29441: PPUSH
29442: CALL_OW 275
29446: PUSH
29447: LD_VAR 0 5
29451: PUSH
29452: LD_INT 2
29454: ARRAY
29455: GREATEREQUAL
29456: AND
29457: PUSH
29458: LD_VAR 0 4
29462: PPUSH
29463: LD_INT 3
29465: PPUSH
29466: CALL_OW 275
29470: PUSH
29471: LD_VAR 0 5
29475: PUSH
29476: LD_INT 3
29478: ARRAY
29479: GREATEREQUAL
29480: AND
29481: ST_TO_ADDR
// end ;
29482: LD_VAR 0 3
29486: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29487: LD_INT 0
29489: PPUSH
29490: PPUSH
29491: PPUSH
29492: PPUSH
29493: PPUSH
29494: PPUSH
29495: PPUSH
29496: PPUSH
29497: PPUSH
29498: PPUSH
29499: PPUSH
// result := false ;
29500: LD_ADDR_VAR 0 8
29504: PUSH
29505: LD_INT 0
29507: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29508: LD_VAR 0 5
29512: NOT
29513: PUSH
29514: LD_VAR 0 1
29518: NOT
29519: OR
29520: PUSH
29521: LD_VAR 0 2
29525: NOT
29526: OR
29527: PUSH
29528: LD_VAR 0 3
29532: NOT
29533: OR
29534: IFFALSE 29538
// exit ;
29536: GO 30352
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29538: LD_ADDR_VAR 0 14
29542: PUSH
29543: LD_VAR 0 1
29547: PPUSH
29548: LD_VAR 0 2
29552: PPUSH
29553: LD_VAR 0 3
29557: PPUSH
29558: LD_VAR 0 4
29562: PPUSH
29563: LD_VAR 0 5
29567: PUSH
29568: LD_INT 1
29570: ARRAY
29571: PPUSH
29572: CALL_OW 248
29576: PPUSH
29577: LD_INT 0
29579: PPUSH
29580: CALL 31605 0 6
29584: ST_TO_ADDR
// if not hexes then
29585: LD_VAR 0 14
29589: NOT
29590: IFFALSE 29594
// exit ;
29592: GO 30352
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29594: LD_ADDR_VAR 0 17
29598: PUSH
29599: LD_VAR 0 5
29603: PPUSH
29604: LD_INT 22
29606: PUSH
29607: LD_VAR 0 13
29611: PPUSH
29612: CALL_OW 255
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 2
29623: PUSH
29624: LD_INT 30
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 30
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: LIST
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PPUSH
29653: CALL_OW 72
29657: ST_TO_ADDR
// for i = 1 to hexes do
29658: LD_ADDR_VAR 0 9
29662: PUSH
29663: DOUBLE
29664: LD_INT 1
29666: DEC
29667: ST_TO_ADDR
29668: LD_VAR 0 14
29672: PUSH
29673: FOR_TO
29674: IFFALSE 30350
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29676: LD_ADDR_VAR 0 13
29680: PUSH
29681: LD_VAR 0 14
29685: PUSH
29686: LD_VAR 0 9
29690: ARRAY
29691: PUSH
29692: LD_INT 1
29694: ARRAY
29695: PPUSH
29696: LD_VAR 0 14
29700: PUSH
29701: LD_VAR 0 9
29705: ARRAY
29706: PUSH
29707: LD_INT 2
29709: ARRAY
29710: PPUSH
29711: CALL_OW 428
29715: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29716: LD_VAR 0 14
29720: PUSH
29721: LD_VAR 0 9
29725: ARRAY
29726: PUSH
29727: LD_INT 1
29729: ARRAY
29730: PPUSH
29731: LD_VAR 0 14
29735: PUSH
29736: LD_VAR 0 9
29740: ARRAY
29741: PUSH
29742: LD_INT 2
29744: ARRAY
29745: PPUSH
29746: CALL_OW 351
29750: PUSH
29751: LD_VAR 0 14
29755: PUSH
29756: LD_VAR 0 9
29760: ARRAY
29761: PUSH
29762: LD_INT 1
29764: ARRAY
29765: PPUSH
29766: LD_VAR 0 14
29770: PUSH
29771: LD_VAR 0 9
29775: ARRAY
29776: PUSH
29777: LD_INT 2
29779: ARRAY
29780: PPUSH
29781: CALL_OW 488
29785: NOT
29786: OR
29787: PUSH
29788: LD_VAR 0 13
29792: PPUSH
29793: CALL_OW 247
29797: PUSH
29798: LD_INT 3
29800: EQUAL
29801: OR
29802: IFFALSE 29808
// exit ;
29804: POP
29805: POP
29806: GO 30352
// if not tmp then
29808: LD_VAR 0 13
29812: NOT
29813: IFFALSE 29817
// continue ;
29815: GO 29673
// result := true ;
29817: LD_ADDR_VAR 0 8
29821: PUSH
29822: LD_INT 1
29824: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
29825: LD_VAR 0 6
29829: PUSH
29830: LD_VAR 0 13
29834: PPUSH
29835: CALL_OW 247
29839: PUSH
29840: LD_INT 2
29842: EQUAL
29843: AND
29844: PUSH
29845: LD_VAR 0 13
29849: PPUSH
29850: CALL_OW 263
29854: PUSH
29855: LD_INT 1
29857: EQUAL
29858: AND
29859: IFFALSE 30023
// begin if IsDrivenBy ( tmp ) then
29861: LD_VAR 0 13
29865: PPUSH
29866: CALL_OW 311
29870: IFFALSE 29874
// continue ;
29872: GO 29673
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29874: LD_VAR 0 6
29878: PPUSH
29879: LD_INT 3
29881: PUSH
29882: LD_INT 60
29884: PUSH
29885: EMPTY
29886: LIST
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 3
29894: PUSH
29895: LD_INT 55
29897: PUSH
29898: EMPTY
29899: LIST
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PPUSH
29909: CALL_OW 72
29913: IFFALSE 30021
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29915: LD_ADDR_VAR 0 18
29919: PUSH
29920: LD_VAR 0 6
29924: PPUSH
29925: LD_INT 3
29927: PUSH
29928: LD_INT 60
29930: PUSH
29931: EMPTY
29932: LIST
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 3
29940: PUSH
29941: LD_INT 55
29943: PUSH
29944: EMPTY
29945: LIST
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PPUSH
29955: CALL_OW 72
29959: PUSH
29960: LD_INT 1
29962: ARRAY
29963: ST_TO_ADDR
// if IsInUnit ( driver ) then
29964: LD_VAR 0 18
29968: PPUSH
29969: CALL_OW 310
29973: IFFALSE 29984
// ComExit ( driver ) ;
29975: LD_VAR 0 18
29979: PPUSH
29980: CALL 55406 0 1
// AddComEnterUnit ( driver , tmp ) ;
29984: LD_VAR 0 18
29988: PPUSH
29989: LD_VAR 0 13
29993: PPUSH
29994: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29998: LD_VAR 0 18
30002: PPUSH
30003: LD_VAR 0 7
30007: PPUSH
30008: CALL_OW 173
// AddComExitVehicle ( driver ) ;
30012: LD_VAR 0 18
30016: PPUSH
30017: CALL_OW 181
// end ; continue ;
30021: GO 29673
// end ; if not cleaners or not tmp in cleaners then
30023: LD_VAR 0 6
30027: NOT
30028: PUSH
30029: LD_VAR 0 13
30033: PUSH
30034: LD_VAR 0 6
30038: IN
30039: NOT
30040: OR
30041: IFFALSE 30348
// begin if dep then
30043: LD_VAR 0 17
30047: IFFALSE 30183
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30049: LD_ADDR_VAR 0 16
30053: PUSH
30054: LD_VAR 0 17
30058: PUSH
30059: LD_INT 1
30061: ARRAY
30062: PPUSH
30063: CALL_OW 250
30067: PPUSH
30068: LD_VAR 0 17
30072: PUSH
30073: LD_INT 1
30075: ARRAY
30076: PPUSH
30077: CALL_OW 254
30081: PPUSH
30082: LD_INT 5
30084: PPUSH
30085: CALL_OW 272
30089: PUSH
30090: LD_VAR 0 17
30094: PUSH
30095: LD_INT 1
30097: ARRAY
30098: PPUSH
30099: CALL_OW 251
30103: PPUSH
30104: LD_VAR 0 17
30108: PUSH
30109: LD_INT 1
30111: ARRAY
30112: PPUSH
30113: CALL_OW 254
30117: PPUSH
30118: LD_INT 5
30120: PPUSH
30121: CALL_OW 273
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30130: LD_VAR 0 16
30134: PUSH
30135: LD_INT 1
30137: ARRAY
30138: PPUSH
30139: LD_VAR 0 16
30143: PUSH
30144: LD_INT 2
30146: ARRAY
30147: PPUSH
30148: CALL_OW 488
30152: IFFALSE 30183
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30154: LD_VAR 0 13
30158: PPUSH
30159: LD_VAR 0 16
30163: PUSH
30164: LD_INT 1
30166: ARRAY
30167: PPUSH
30168: LD_VAR 0 16
30172: PUSH
30173: LD_INT 2
30175: ARRAY
30176: PPUSH
30177: CALL_OW 111
// continue ;
30181: GO 29673
// end ; end ; r := GetDir ( tmp ) ;
30183: LD_ADDR_VAR 0 15
30187: PUSH
30188: LD_VAR 0 13
30192: PPUSH
30193: CALL_OW 254
30197: ST_TO_ADDR
// if r = 5 then
30198: LD_VAR 0 15
30202: PUSH
30203: LD_INT 5
30205: EQUAL
30206: IFFALSE 30216
// r := 0 ;
30208: LD_ADDR_VAR 0 15
30212: PUSH
30213: LD_INT 0
30215: ST_TO_ADDR
// for j = r to 5 do
30216: LD_ADDR_VAR 0 10
30220: PUSH
30221: DOUBLE
30222: LD_VAR 0 15
30226: DEC
30227: ST_TO_ADDR
30228: LD_INT 5
30230: PUSH
30231: FOR_TO
30232: IFFALSE 30346
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30234: LD_ADDR_VAR 0 11
30238: PUSH
30239: LD_VAR 0 13
30243: PPUSH
30244: CALL_OW 250
30248: PPUSH
30249: LD_VAR 0 10
30253: PPUSH
30254: LD_INT 2
30256: PPUSH
30257: CALL_OW 272
30261: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30262: LD_ADDR_VAR 0 12
30266: PUSH
30267: LD_VAR 0 13
30271: PPUSH
30272: CALL_OW 251
30276: PPUSH
30277: LD_VAR 0 10
30281: PPUSH
30282: LD_INT 2
30284: PPUSH
30285: CALL_OW 273
30289: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30290: LD_VAR 0 11
30294: PPUSH
30295: LD_VAR 0 12
30299: PPUSH
30300: CALL_OW 488
30304: PUSH
30305: LD_VAR 0 11
30309: PPUSH
30310: LD_VAR 0 12
30314: PPUSH
30315: CALL_OW 428
30319: NOT
30320: AND
30321: IFFALSE 30344
// begin ComMoveXY ( tmp , _x , _y ) ;
30323: LD_VAR 0 13
30327: PPUSH
30328: LD_VAR 0 11
30332: PPUSH
30333: LD_VAR 0 12
30337: PPUSH
30338: CALL_OW 111
// break ;
30342: GO 30346
// end ; end ;
30344: GO 30231
30346: POP
30347: POP
// end ; end ;
30348: GO 29673
30350: POP
30351: POP
// end ;
30352: LD_VAR 0 8
30356: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30357: LD_INT 0
30359: PPUSH
// result := true ;
30360: LD_ADDR_VAR 0 3
30364: PUSH
30365: LD_INT 1
30367: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30368: LD_VAR 0 2
30372: PUSH
30373: LD_INT 24
30375: DOUBLE
30376: EQUAL
30377: IFTRUE 30387
30379: LD_INT 33
30381: DOUBLE
30382: EQUAL
30383: IFTRUE 30387
30385: GO 30412
30387: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30388: LD_ADDR_VAR 0 3
30392: PUSH
30393: LD_INT 32
30395: PPUSH
30396: LD_VAR 0 1
30400: PPUSH
30401: CALL_OW 321
30405: PUSH
30406: LD_INT 2
30408: EQUAL
30409: ST_TO_ADDR
30410: GO 30728
30412: LD_INT 20
30414: DOUBLE
30415: EQUAL
30416: IFTRUE 30420
30418: GO 30445
30420: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30421: LD_ADDR_VAR 0 3
30425: PUSH
30426: LD_INT 6
30428: PPUSH
30429: LD_VAR 0 1
30433: PPUSH
30434: CALL_OW 321
30438: PUSH
30439: LD_INT 2
30441: EQUAL
30442: ST_TO_ADDR
30443: GO 30728
30445: LD_INT 22
30447: DOUBLE
30448: EQUAL
30449: IFTRUE 30459
30451: LD_INT 36
30453: DOUBLE
30454: EQUAL
30455: IFTRUE 30459
30457: GO 30484
30459: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30460: LD_ADDR_VAR 0 3
30464: PUSH
30465: LD_INT 15
30467: PPUSH
30468: LD_VAR 0 1
30472: PPUSH
30473: CALL_OW 321
30477: PUSH
30478: LD_INT 2
30480: EQUAL
30481: ST_TO_ADDR
30482: GO 30728
30484: LD_INT 30
30486: DOUBLE
30487: EQUAL
30488: IFTRUE 30492
30490: GO 30517
30492: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30493: LD_ADDR_VAR 0 3
30497: PUSH
30498: LD_INT 20
30500: PPUSH
30501: LD_VAR 0 1
30505: PPUSH
30506: CALL_OW 321
30510: PUSH
30511: LD_INT 2
30513: EQUAL
30514: ST_TO_ADDR
30515: GO 30728
30517: LD_INT 28
30519: DOUBLE
30520: EQUAL
30521: IFTRUE 30531
30523: LD_INT 21
30525: DOUBLE
30526: EQUAL
30527: IFTRUE 30531
30529: GO 30556
30531: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30532: LD_ADDR_VAR 0 3
30536: PUSH
30537: LD_INT 21
30539: PPUSH
30540: LD_VAR 0 1
30544: PPUSH
30545: CALL_OW 321
30549: PUSH
30550: LD_INT 2
30552: EQUAL
30553: ST_TO_ADDR
30554: GO 30728
30556: LD_INT 16
30558: DOUBLE
30559: EQUAL
30560: IFTRUE 30564
30562: GO 30589
30564: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30565: LD_ADDR_VAR 0 3
30569: PUSH
30570: LD_INT 84
30572: PPUSH
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 321
30582: PUSH
30583: LD_INT 2
30585: EQUAL
30586: ST_TO_ADDR
30587: GO 30728
30589: LD_INT 19
30591: DOUBLE
30592: EQUAL
30593: IFTRUE 30603
30595: LD_INT 23
30597: DOUBLE
30598: EQUAL
30599: IFTRUE 30603
30601: GO 30628
30603: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30604: LD_ADDR_VAR 0 3
30608: PUSH
30609: LD_INT 83
30611: PPUSH
30612: LD_VAR 0 1
30616: PPUSH
30617: CALL_OW 321
30621: PUSH
30622: LD_INT 2
30624: EQUAL
30625: ST_TO_ADDR
30626: GO 30728
30628: LD_INT 17
30630: DOUBLE
30631: EQUAL
30632: IFTRUE 30636
30634: GO 30661
30636: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
30637: LD_ADDR_VAR 0 3
30641: PUSH
30642: LD_INT 39
30644: PPUSH
30645: LD_VAR 0 1
30649: PPUSH
30650: CALL_OW 321
30654: PUSH
30655: LD_INT 2
30657: EQUAL
30658: ST_TO_ADDR
30659: GO 30728
30661: LD_INT 18
30663: DOUBLE
30664: EQUAL
30665: IFTRUE 30669
30667: GO 30694
30669: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
30670: LD_ADDR_VAR 0 3
30674: PUSH
30675: LD_INT 40
30677: PPUSH
30678: LD_VAR 0 1
30682: PPUSH
30683: CALL_OW 321
30687: PUSH
30688: LD_INT 2
30690: EQUAL
30691: ST_TO_ADDR
30692: GO 30728
30694: LD_INT 27
30696: DOUBLE
30697: EQUAL
30698: IFTRUE 30702
30700: GO 30727
30702: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
30703: LD_ADDR_VAR 0 3
30707: PUSH
30708: LD_INT 35
30710: PPUSH
30711: LD_VAR 0 1
30715: PPUSH
30716: CALL_OW 321
30720: PUSH
30721: LD_INT 2
30723: EQUAL
30724: ST_TO_ADDR
30725: GO 30728
30727: POP
// end ;
30728: LD_VAR 0 3
30732: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
30733: LD_INT 0
30735: PPUSH
30736: PPUSH
30737: PPUSH
30738: PPUSH
30739: PPUSH
30740: PPUSH
30741: PPUSH
30742: PPUSH
30743: PPUSH
30744: PPUSH
30745: PPUSH
// result := false ;
30746: LD_ADDR_VAR 0 6
30750: PUSH
30751: LD_INT 0
30753: ST_TO_ADDR
// if btype = b_depot then
30754: LD_VAR 0 2
30758: PUSH
30759: LD_INT 0
30761: EQUAL
30762: IFFALSE 30774
// begin result := true ;
30764: LD_ADDR_VAR 0 6
30768: PUSH
30769: LD_INT 1
30771: ST_TO_ADDR
// exit ;
30772: GO 31600
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
30774: LD_VAR 0 1
30778: NOT
30779: PUSH
30780: LD_VAR 0 1
30784: PPUSH
30785: CALL_OW 266
30789: PUSH
30790: LD_INT 0
30792: PUSH
30793: LD_INT 1
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: IN
30800: NOT
30801: OR
30802: PUSH
30803: LD_VAR 0 2
30807: NOT
30808: OR
30809: PUSH
30810: LD_VAR 0 5
30814: PUSH
30815: LD_INT 0
30817: PUSH
30818: LD_INT 1
30820: PUSH
30821: LD_INT 2
30823: PUSH
30824: LD_INT 3
30826: PUSH
30827: LD_INT 4
30829: PUSH
30830: LD_INT 5
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: IN
30841: NOT
30842: OR
30843: PUSH
30844: LD_VAR 0 3
30848: PPUSH
30849: LD_VAR 0 4
30853: PPUSH
30854: CALL_OW 488
30858: NOT
30859: OR
30860: IFFALSE 30864
// exit ;
30862: GO 31600
// side := GetSide ( depot ) ;
30864: LD_ADDR_VAR 0 9
30868: PUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 255
30878: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30879: LD_VAR 0 9
30883: PPUSH
30884: LD_VAR 0 2
30888: PPUSH
30889: CALL 30357 0 2
30893: NOT
30894: IFFALSE 30898
// exit ;
30896: GO 31600
// pom := GetBase ( depot ) ;
30898: LD_ADDR_VAR 0 10
30902: PUSH
30903: LD_VAR 0 1
30907: PPUSH
30908: CALL_OW 274
30912: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30913: LD_ADDR_VAR 0 11
30917: PUSH
30918: LD_VAR 0 2
30922: PPUSH
30923: LD_VAR 0 1
30927: PPUSH
30928: CALL_OW 248
30932: PPUSH
30933: CALL_OW 450
30937: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30938: LD_VAR 0 10
30942: PPUSH
30943: LD_INT 1
30945: PPUSH
30946: CALL_OW 275
30950: PUSH
30951: LD_VAR 0 11
30955: PUSH
30956: LD_INT 1
30958: ARRAY
30959: GREATEREQUAL
30960: PUSH
30961: LD_VAR 0 10
30965: PPUSH
30966: LD_INT 2
30968: PPUSH
30969: CALL_OW 275
30973: PUSH
30974: LD_VAR 0 11
30978: PUSH
30979: LD_INT 2
30981: ARRAY
30982: GREATEREQUAL
30983: AND
30984: PUSH
30985: LD_VAR 0 10
30989: PPUSH
30990: LD_INT 3
30992: PPUSH
30993: CALL_OW 275
30997: PUSH
30998: LD_VAR 0 11
31002: PUSH
31003: LD_INT 3
31005: ARRAY
31006: GREATEREQUAL
31007: AND
31008: NOT
31009: IFFALSE 31013
// exit ;
31011: GO 31600
// if GetBType ( depot ) = b_depot then
31013: LD_VAR 0 1
31017: PPUSH
31018: CALL_OW 266
31022: PUSH
31023: LD_INT 0
31025: EQUAL
31026: IFFALSE 31038
// dist := 28 else
31028: LD_ADDR_VAR 0 14
31032: PUSH
31033: LD_INT 28
31035: ST_TO_ADDR
31036: GO 31046
// dist := 36 ;
31038: LD_ADDR_VAR 0 14
31042: PUSH
31043: LD_INT 36
31045: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31046: LD_VAR 0 1
31050: PPUSH
31051: LD_VAR 0 3
31055: PPUSH
31056: LD_VAR 0 4
31060: PPUSH
31061: CALL_OW 297
31065: PUSH
31066: LD_VAR 0 14
31070: GREATER
31071: IFFALSE 31075
// exit ;
31073: GO 31600
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31075: LD_ADDR_VAR 0 12
31079: PUSH
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_VAR 0 3
31089: PPUSH
31090: LD_VAR 0 4
31094: PPUSH
31095: LD_VAR 0 5
31099: PPUSH
31100: LD_VAR 0 1
31104: PPUSH
31105: CALL_OW 248
31109: PPUSH
31110: LD_INT 0
31112: PPUSH
31113: CALL 31605 0 6
31117: ST_TO_ADDR
// if not hexes then
31118: LD_VAR 0 12
31122: NOT
31123: IFFALSE 31127
// exit ;
31125: GO 31600
// hex := GetHexInfo ( x , y ) ;
31127: LD_ADDR_VAR 0 15
31131: PUSH
31132: LD_VAR 0 3
31136: PPUSH
31137: LD_VAR 0 4
31141: PPUSH
31142: CALL_OW 546
31146: ST_TO_ADDR
// if hex [ 1 ] then
31147: LD_VAR 0 15
31151: PUSH
31152: LD_INT 1
31154: ARRAY
31155: IFFALSE 31159
// exit ;
31157: GO 31600
// height := hex [ 2 ] ;
31159: LD_ADDR_VAR 0 13
31163: PUSH
31164: LD_VAR 0 15
31168: PUSH
31169: LD_INT 2
31171: ARRAY
31172: ST_TO_ADDR
// for i = 1 to hexes do
31173: LD_ADDR_VAR 0 7
31177: PUSH
31178: DOUBLE
31179: LD_INT 1
31181: DEC
31182: ST_TO_ADDR
31183: LD_VAR 0 12
31187: PUSH
31188: FOR_TO
31189: IFFALSE 31519
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31191: LD_VAR 0 12
31195: PUSH
31196: LD_VAR 0 7
31200: ARRAY
31201: PUSH
31202: LD_INT 1
31204: ARRAY
31205: PPUSH
31206: LD_VAR 0 12
31210: PUSH
31211: LD_VAR 0 7
31215: ARRAY
31216: PUSH
31217: LD_INT 2
31219: ARRAY
31220: PPUSH
31221: CALL_OW 488
31225: NOT
31226: PUSH
31227: LD_VAR 0 12
31231: PUSH
31232: LD_VAR 0 7
31236: ARRAY
31237: PUSH
31238: LD_INT 1
31240: ARRAY
31241: PPUSH
31242: LD_VAR 0 12
31246: PUSH
31247: LD_VAR 0 7
31251: ARRAY
31252: PUSH
31253: LD_INT 2
31255: ARRAY
31256: PPUSH
31257: CALL_OW 428
31261: PUSH
31262: LD_INT 0
31264: GREATER
31265: OR
31266: PUSH
31267: LD_VAR 0 12
31271: PUSH
31272: LD_VAR 0 7
31276: ARRAY
31277: PUSH
31278: LD_INT 1
31280: ARRAY
31281: PPUSH
31282: LD_VAR 0 12
31286: PUSH
31287: LD_VAR 0 7
31291: ARRAY
31292: PUSH
31293: LD_INT 2
31295: ARRAY
31296: PPUSH
31297: CALL_OW 351
31301: OR
31302: IFFALSE 31308
// exit ;
31304: POP
31305: POP
31306: GO 31600
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31308: LD_ADDR_VAR 0 8
31312: PUSH
31313: LD_VAR 0 12
31317: PUSH
31318: LD_VAR 0 7
31322: ARRAY
31323: PUSH
31324: LD_INT 1
31326: ARRAY
31327: PPUSH
31328: LD_VAR 0 12
31332: PUSH
31333: LD_VAR 0 7
31337: ARRAY
31338: PUSH
31339: LD_INT 2
31341: ARRAY
31342: PPUSH
31343: CALL_OW 546
31347: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31348: LD_VAR 0 8
31352: PUSH
31353: LD_INT 1
31355: ARRAY
31356: PUSH
31357: LD_VAR 0 8
31361: PUSH
31362: LD_INT 2
31364: ARRAY
31365: PUSH
31366: LD_VAR 0 13
31370: PUSH
31371: LD_INT 2
31373: PLUS
31374: GREATER
31375: OR
31376: PUSH
31377: LD_VAR 0 8
31381: PUSH
31382: LD_INT 2
31384: ARRAY
31385: PUSH
31386: LD_VAR 0 13
31390: PUSH
31391: LD_INT 2
31393: MINUS
31394: LESS
31395: OR
31396: PUSH
31397: LD_VAR 0 8
31401: PUSH
31402: LD_INT 3
31404: ARRAY
31405: PUSH
31406: LD_INT 0
31408: PUSH
31409: LD_INT 8
31411: PUSH
31412: LD_INT 9
31414: PUSH
31415: LD_INT 10
31417: PUSH
31418: LD_INT 11
31420: PUSH
31421: LD_INT 12
31423: PUSH
31424: LD_INT 13
31426: PUSH
31427: LD_INT 16
31429: PUSH
31430: LD_INT 17
31432: PUSH
31433: LD_INT 18
31435: PUSH
31436: LD_INT 19
31438: PUSH
31439: LD_INT 20
31441: PUSH
31442: LD_INT 21
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: IN
31460: NOT
31461: OR
31462: PUSH
31463: LD_VAR 0 8
31467: PUSH
31468: LD_INT 5
31470: ARRAY
31471: NOT
31472: OR
31473: PUSH
31474: LD_VAR 0 8
31478: PUSH
31479: LD_INT 6
31481: ARRAY
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 2
31488: PUSH
31489: LD_INT 7
31491: PUSH
31492: LD_INT 9
31494: PUSH
31495: LD_INT 10
31497: PUSH
31498: LD_INT 11
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: IN
31509: NOT
31510: OR
31511: IFFALSE 31517
// exit ;
31513: POP
31514: POP
31515: GO 31600
// end ;
31517: GO 31188
31519: POP
31520: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31521: LD_VAR 0 9
31525: PPUSH
31526: LD_VAR 0 3
31530: PPUSH
31531: LD_VAR 0 4
31535: PPUSH
31536: LD_INT 20
31538: PPUSH
31539: CALL 23523 0 4
31543: PUSH
31544: LD_INT 4
31546: ARRAY
31547: IFFALSE 31551
// exit ;
31549: GO 31600
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31551: LD_VAR 0 2
31555: PUSH
31556: LD_INT 29
31558: PUSH
31559: LD_INT 30
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: IN
31566: PUSH
31567: LD_VAR 0 3
31571: PPUSH
31572: LD_VAR 0 4
31576: PPUSH
31577: LD_VAR 0 9
31581: PPUSH
31582: CALL_OW 440
31586: NOT
31587: AND
31588: IFFALSE 31592
// exit ;
31590: GO 31600
// result := true ;
31592: LD_ADDR_VAR 0 6
31596: PUSH
31597: LD_INT 1
31599: ST_TO_ADDR
// end ;
31600: LD_VAR 0 6
31604: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31605: LD_INT 0
31607: PPUSH
31608: PPUSH
31609: PPUSH
31610: PPUSH
31611: PPUSH
31612: PPUSH
31613: PPUSH
31614: PPUSH
31615: PPUSH
31616: PPUSH
31617: PPUSH
31618: PPUSH
31619: PPUSH
31620: PPUSH
31621: PPUSH
31622: PPUSH
31623: PPUSH
31624: PPUSH
31625: PPUSH
31626: PPUSH
31627: PPUSH
31628: PPUSH
31629: PPUSH
31630: PPUSH
31631: PPUSH
31632: PPUSH
31633: PPUSH
31634: PPUSH
31635: PPUSH
31636: PPUSH
31637: PPUSH
31638: PPUSH
31639: PPUSH
31640: PPUSH
31641: PPUSH
31642: PPUSH
31643: PPUSH
31644: PPUSH
31645: PPUSH
31646: PPUSH
31647: PPUSH
31648: PPUSH
31649: PPUSH
31650: PPUSH
31651: PPUSH
31652: PPUSH
31653: PPUSH
31654: PPUSH
31655: PPUSH
31656: PPUSH
31657: PPUSH
31658: PPUSH
31659: PPUSH
31660: PPUSH
31661: PPUSH
31662: PPUSH
31663: PPUSH
31664: PPUSH
// result = [ ] ;
31665: LD_ADDR_VAR 0 7
31669: PUSH
31670: EMPTY
31671: ST_TO_ADDR
// temp_list = [ ] ;
31672: LD_ADDR_VAR 0 9
31676: PUSH
31677: EMPTY
31678: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
31679: LD_VAR 0 4
31683: PUSH
31684: LD_INT 0
31686: PUSH
31687: LD_INT 1
31689: PUSH
31690: LD_INT 2
31692: PUSH
31693: LD_INT 3
31695: PUSH
31696: LD_INT 4
31698: PUSH
31699: LD_INT 5
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: LIST
31706: LIST
31707: LIST
31708: LIST
31709: IN
31710: NOT
31711: PUSH
31712: LD_VAR 0 1
31716: PUSH
31717: LD_INT 0
31719: PUSH
31720: LD_INT 1
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: IN
31727: PUSH
31728: LD_VAR 0 5
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: LD_INT 2
31738: PUSH
31739: LD_INT 3
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: LIST
31746: IN
31747: NOT
31748: AND
31749: OR
31750: IFFALSE 31754
// exit ;
31752: GO 50145
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
31754: LD_VAR 0 1
31758: PUSH
31759: LD_INT 6
31761: PUSH
31762: LD_INT 7
31764: PUSH
31765: LD_INT 8
31767: PUSH
31768: LD_INT 13
31770: PUSH
31771: LD_INT 12
31773: PUSH
31774: LD_INT 15
31776: PUSH
31777: LD_INT 11
31779: PUSH
31780: LD_INT 14
31782: PUSH
31783: LD_INT 10
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: IN
31797: IFFALSE 31807
// btype = b_lab ;
31799: LD_ADDR_VAR 0 1
31803: PUSH
31804: LD_INT 6
31806: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
31807: LD_VAR 0 6
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: LD_INT 2
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: LIST
31825: IN
31826: NOT
31827: PUSH
31828: LD_VAR 0 1
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 2
31841: PUSH
31842: LD_INT 3
31844: PUSH
31845: LD_INT 6
31847: PUSH
31848: LD_INT 36
31850: PUSH
31851: LD_INT 4
31853: PUSH
31854: LD_INT 5
31856: PUSH
31857: LD_INT 31
31859: PUSH
31860: LD_INT 32
31862: PUSH
31863: LD_INT 33
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: IN
31879: NOT
31880: PUSH
31881: LD_VAR 0 6
31885: PUSH
31886: LD_INT 1
31888: EQUAL
31889: AND
31890: OR
31891: PUSH
31892: LD_VAR 0 1
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: LD_INT 3
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: IN
31907: NOT
31908: PUSH
31909: LD_VAR 0 6
31913: PUSH
31914: LD_INT 2
31916: EQUAL
31917: AND
31918: OR
31919: IFFALSE 31929
// mode = 0 ;
31921: LD_ADDR_VAR 0 6
31925: PUSH
31926: LD_INT 0
31928: ST_TO_ADDR
// case mode of 0 :
31929: LD_VAR 0 6
31933: PUSH
31934: LD_INT 0
31936: DOUBLE
31937: EQUAL
31938: IFTRUE 31942
31940: GO 43395
31942: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31943: LD_ADDR_VAR 0 11
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 1
32058: PUSH
32059: LD_INT 2
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: LD_INT 2
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 1
32089: PUSH
32090: LD_INT 3
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 0
32099: PUSH
32100: LD_INT 3
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 1
32109: NEG
32110: PUSH
32111: LD_INT 2
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: LIST
32126: LIST
32127: LIST
32128: LIST
32129: LIST
32130: LIST
32131: LIST
32132: LIST
32133: LIST
32134: LIST
32135: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32136: LD_ADDR_VAR 0 12
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 1
32156: NEG
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 0
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 1
32174: PUSH
32175: LD_INT 1
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: LD_INT 1
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: NEG
32195: PUSH
32196: LD_INT 0
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 1
32205: NEG
32206: PUSH
32207: LD_INT 1
32209: NEG
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 1
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: LD_INT 0
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 2
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 1
32248: NEG
32249: PUSH
32250: LD_INT 1
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 2
32259: NEG
32260: PUSH
32261: LD_INT 0
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 2
32270: NEG
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 2
32282: NEG
32283: PUSH
32284: LD_INT 1
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 3
32293: NEG
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 3
32304: NEG
32305: PUSH
32306: LD_INT 1
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32332: LD_ADDR_VAR 0 13
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: LD_INT 0
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 0
32349: PUSH
32350: LD_INT 1
32352: NEG
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: LD_INT 0
32363: PUSH
32364: EMPTY
32365: LIST
32366: LIST
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 0
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 1
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: NEG
32414: PUSH
32415: LD_INT 2
32417: NEG
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 2
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 1
32445: PUSH
32446: LD_INT 2
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: NEG
32456: PUSH
32457: LD_INT 1
32459: NEG
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 2
32467: NEG
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 2
32479: NEG
32480: PUSH
32481: LD_INT 3
32483: NEG
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 3
32491: NEG
32492: PUSH
32493: LD_INT 2
32495: NEG
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 3
32503: NEG
32504: PUSH
32505: LD_INT 3
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32531: LD_ADDR_VAR 0 14
32535: PUSH
32536: LD_INT 0
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 1
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 1
32569: PUSH
32570: LD_INT 1
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 0
32579: PUSH
32580: LD_INT 1
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 1
32589: NEG
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: LD_INT 1
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 1
32612: NEG
32613: PUSH
32614: LD_INT 2
32616: NEG
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: LD_INT 2
32627: NEG
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: PUSH
32636: LD_INT 1
32638: NEG
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 1
32646: PUSH
32647: LD_INT 2
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 0
32656: PUSH
32657: LD_INT 2
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 3
32681: NEG
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: LD_INT 3
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: PUSH
32701: LD_INT 2
32703: NEG
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
32727: LD_ADDR_VAR 0 15
32731: PUSH
32732: LD_INT 0
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 0
32744: PUSH
32745: LD_INT 1
32747: NEG
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: LD_INT 1
32755: PUSH
32756: LD_INT 0
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 1
32765: PUSH
32766: LD_INT 1
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 0
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 1
32785: NEG
32786: PUSH
32787: LD_INT 0
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 1
32796: NEG
32797: PUSH
32798: LD_INT 1
32800: NEG
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: LD_INT 1
32811: NEG
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 2
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 2
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 1
32839: NEG
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 2
32850: NEG
32851: PUSH
32852: LD_INT 0
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: LD_INT 1
32865: NEG
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 2
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 3
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 3
32894: PUSH
32895: LD_INT 1
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32920: LD_ADDR_VAR 0 16
32924: PUSH
32925: LD_INT 0
32927: PUSH
32928: LD_INT 0
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 0
32937: PUSH
32938: LD_INT 1
32940: NEG
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 1
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 1
32958: PUSH
32959: LD_INT 1
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 0
32968: PUSH
32969: LD_INT 1
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: LD_INT 1
32978: NEG
32979: PUSH
32980: LD_INT 0
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: LD_INT 1
32993: NEG
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 1
33001: NEG
33002: PUSH
33003: LD_INT 2
33005: NEG
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: LD_INT 1
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: LD_INT 2
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 2
33043: NEG
33044: PUSH
33045: LD_INT 1
33047: NEG
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 2
33055: NEG
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 3
33067: PUSH
33068: LD_INT 2
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 3
33077: PUSH
33078: LD_INT 3
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: PUSH
33088: LD_INT 3
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: LIST
33106: LIST
33107: LIST
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33113: LD_ADDR_VAR 0 17
33117: PUSH
33118: LD_INT 0
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 0
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: LD_INT 0
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: LD_INT 1
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 1
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 1
33171: NEG
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: NEG
33183: PUSH
33184: LD_INT 1
33186: NEG
33187: PUSH
33188: EMPTY
33189: LIST
33190: LIST
33191: PUSH
33192: LD_INT 1
33194: NEG
33195: PUSH
33196: LD_INT 2
33198: NEG
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: LD_INT 2
33209: NEG
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: LD_INT 1
33220: NEG
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 2
33228: PUSH
33229: LD_INT 0
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 2
33238: PUSH
33239: LD_INT 1
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 2
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 2
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 2
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 2
33289: NEG
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 2
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: LD_INT 2
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33343: LD_ADDR_VAR 0 18
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: LD_INT 0
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 1
33363: NEG
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 1
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 1
33401: NEG
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: NEG
33413: PUSH
33414: LD_INT 1
33416: NEG
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 1
33424: NEG
33425: PUSH
33426: LD_INT 2
33428: NEG
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: LD_INT 2
33439: NEG
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: LD_INT 1
33450: NEG
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: LD_INT 0
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: LD_INT 2
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 2
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 2
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 2
33519: NEG
33520: PUSH
33521: LD_INT 0
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 2
33530: NEG
33531: PUSH
33532: LD_INT 1
33534: NEG
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 2
33542: NEG
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33573: LD_ADDR_VAR 0 19
33577: PUSH
33578: LD_INT 0
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: LD_INT 1
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 1
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: PUSH
33612: LD_INT 1
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: NEG
33632: PUSH
33633: LD_INT 0
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: NEG
33643: PUSH
33644: LD_INT 1
33646: NEG
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 1
33654: NEG
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 0
33666: PUSH
33667: LD_INT 2
33669: NEG
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PUSH
33675: LD_INT 1
33677: PUSH
33678: LD_INT 1
33680: NEG
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PUSH
33686: LD_INT 2
33688: PUSH
33689: LD_INT 0
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: LD_INT 2
33698: PUSH
33699: LD_INT 1
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: LD_INT 2
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 1
33718: PUSH
33719: LD_INT 2
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 0
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 1
33738: NEG
33739: PUSH
33740: LD_INT 1
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 2
33749: NEG
33750: PUSH
33751: LD_INT 0
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 2
33760: NEG
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 2
33772: NEG
33773: PUSH
33774: LD_INT 2
33776: NEG
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33803: LD_ADDR_VAR 0 20
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 0
33820: PUSH
33821: LD_INT 1
33823: NEG
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: LD_INT 0
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 0
33851: PUSH
33852: LD_INT 1
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 1
33861: NEG
33862: PUSH
33863: LD_INT 0
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 1
33872: NEG
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 0
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 2
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 2
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 1
33968: NEG
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: NEG
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 2
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: NEG
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34033: LD_ADDR_VAR 0 21
34037: PUSH
34038: LD_INT 0
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 0
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 1
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 1
34071: PUSH
34072: LD_INT 1
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: NEG
34092: PUSH
34093: LD_INT 0
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: LD_INT 1
34106: NEG
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 2
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 0
34126: PUSH
34127: LD_INT 2
34129: NEG
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: LD_INT 1
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: LD_INT 0
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 2
34158: PUSH
34159: LD_INT 1
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 2
34168: PUSH
34169: LD_INT 2
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 1
34178: PUSH
34179: LD_INT 2
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 0
34188: PUSH
34189: LD_INT 2
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 2
34209: NEG
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 2
34220: NEG
34221: PUSH
34222: LD_INT 1
34224: NEG
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: LD_INT 2
34236: NEG
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34263: LD_ADDR_VAR 0 22
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 1
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 1
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 0
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 1
34332: NEG
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: LD_INT 2
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 2
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: LD_INT 1
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 2
34378: PUSH
34379: LD_INT 0
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 2
34398: PUSH
34399: LD_INT 2
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 1
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 0
34418: PUSH
34419: LD_INT 2
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 2
34439: NEG
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 2
34450: NEG
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 2
34462: NEG
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: LIST
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34493: LD_ADDR_VAR 0 23
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 1
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: NEG
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: NEG
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: LD_INT 2
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 0
34586: PUSH
34587: LD_INT 2
34589: NEG
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 2
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 2
34628: PUSH
34629: LD_INT 2
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: PUSH
34639: LD_INT 2
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 0
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 1
34658: NEG
34659: PUSH
34660: LD_INT 1
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 2
34669: NEG
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 2
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 2
34692: NEG
34693: PUSH
34694: LD_INT 2
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 2
34704: NEG
34705: PUSH
34706: LD_INT 3
34708: NEG
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: NEG
34717: PUSH
34718: LD_INT 3
34720: NEG
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 1
34728: PUSH
34729: LD_INT 2
34731: NEG
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PUSH
34737: LD_INT 2
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
34773: LD_ADDR_VAR 0 24
34777: PUSH
34778: LD_INT 0
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: EMPTY
34785: LIST
34786: LIST
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: LD_INT 0
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: LD_INT 1
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: LD_INT 1
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 1
34831: NEG
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 1
34854: NEG
34855: PUSH
34856: LD_INT 2
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 2
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 2
34888: PUSH
34889: LD_INT 0
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: LD_INT 1
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: LD_INT 2
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 0
34928: PUSH
34929: LD_INT 2
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 1
34938: NEG
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 2
34949: NEG
34950: PUSH
34951: LD_INT 0
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: NEG
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 2
34972: NEG
34973: PUSH
34974: LD_INT 2
34976: NEG
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 2
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 1
34998: NEG
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: LD_INT 1
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 3
35016: PUSH
35017: LD_INT 2
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: LIST
35028: LIST
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35049: LD_ADDR_VAR 0 25
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: LD_INT 1
35069: NEG
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 1
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 0
35097: PUSH
35098: LD_INT 1
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 1
35107: NEG
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 1
35118: NEG
35119: PUSH
35120: LD_INT 1
35122: NEG
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: LD_INT 2
35134: NEG
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 0
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: LD_INT 1
35156: NEG
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 2
35164: PUSH
35165: LD_INT 0
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: PUSH
35175: LD_INT 1
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: LD_INT 2
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 1
35194: PUSH
35195: LD_INT 2
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: LD_INT 2
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: NEG
35215: PUSH
35216: LD_INT 1
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 2
35225: NEG
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 2
35236: NEG
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 2
35248: NEG
35249: PUSH
35250: LD_INT 2
35252: NEG
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PUSH
35258: LD_INT 3
35260: PUSH
35261: LD_INT 1
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: PUSH
35268: LD_INT 3
35270: PUSH
35271: LD_INT 2
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 2
35280: PUSH
35281: LD_INT 3
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 1
35290: PUSH
35291: LD_INT 3
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35323: LD_ADDR_VAR 0 26
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: PUSH
35352: LD_INT 0
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 2
35408: NEG
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 2
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 2
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 2
35448: PUSH
35449: LD_INT 1
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 2
35458: PUSH
35459: LD_INT 2
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: PUSH
35469: LD_INT 2
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 2
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 1
35488: NEG
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 2
35499: NEG
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 2
35510: NEG
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 2
35522: NEG
35523: PUSH
35524: LD_INT 2
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: LD_INT 3
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: LD_INT 3
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: LD_INT 2
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: LIST
35587: LIST
35588: LIST
35589: LIST
35590: LIST
35591: LIST
35592: LIST
35593: LIST
35594: LIST
35595: LIST
35596: LIST
35597: LIST
35598: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35599: LD_ADDR_VAR 0 27
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 0
35616: PUSH
35617: LD_INT 1
35619: NEG
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 1
35627: PUSH
35628: LD_INT 0
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: PUSH
35638: LD_INT 1
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 0
35647: PUSH
35648: LD_INT 1
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: LD_INT 0
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: LD_INT 1
35672: NEG
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 1
35680: NEG
35681: PUSH
35682: LD_INT 2
35684: NEG
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: LD_INT 2
35695: NEG
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: PUSH
35722: LD_INT 2
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 2
35734: PUSH
35735: LD_INT 2
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: PUSH
35745: LD_INT 2
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 0
35754: PUSH
35755: LD_INT 2
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 2
35775: NEG
35776: PUSH
35777: LD_INT 0
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 2
35786: NEG
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 2
35798: NEG
35799: PUSH
35800: LD_INT 2
35802: NEG
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 1
35810: NEG
35811: PUSH
35812: LD_INT 2
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 2
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 3
35832: NEG
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 3
35844: NEG
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35879: LD_ADDR_VAR 0 28
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 0
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: LD_INT 0
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 1
35917: PUSH
35918: LD_INT 1
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 0
35927: PUSH
35928: LD_INT 1
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: LD_INT 1
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 1
35960: NEG
35961: PUSH
35962: LD_INT 2
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 0
35972: PUSH
35973: LD_INT 2
35975: NEG
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: LD_INT 1
35986: NEG
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 2
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 2
36004: PUSH
36005: LD_INT 1
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 2
36014: PUSH
36015: LD_INT 2
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 2
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 0
36034: PUSH
36035: LD_INT 2
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 1
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 2
36055: NEG
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 2
36066: NEG
36067: PUSH
36068: LD_INT 1
36070: NEG
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: LD_INT 2
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: NEG
36091: PUSH
36092: LD_INT 3
36094: NEG
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 1
36102: NEG
36103: PUSH
36104: LD_INT 3
36106: NEG
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 3
36126: NEG
36127: PUSH
36128: LD_INT 2
36130: NEG
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36161: LD_ADDR_VAR 0 29
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 1
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 1
36219: NEG
36220: PUSH
36221: LD_INT 0
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 1
36230: NEG
36231: PUSH
36232: LD_INT 1
36234: NEG
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: NEG
36243: PUSH
36244: LD_INT 2
36246: NEG
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: LD_INT 2
36257: NEG
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 2
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: LD_INT 2
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: NEG
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 2
36327: NEG
36328: PUSH
36329: LD_INT 1
36331: NEG
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 2
36339: NEG
36340: PUSH
36341: LD_INT 2
36343: NEG
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 2
36351: NEG
36352: PUSH
36353: LD_INT 3
36355: NEG
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 2
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 3
36374: PUSH
36375: LD_INT 1
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: LD_INT 3
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: LD_INT 2
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 3
36405: NEG
36406: PUSH
36407: LD_INT 2
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: LIST
36422: LIST
36423: LIST
36424: LIST
36425: LIST
36426: LIST
36427: LIST
36428: LIST
36429: LIST
36430: LIST
36431: LIST
36432: LIST
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36440: LD_ADDR_VAR 0 30
36444: PUSH
36445: LD_INT 0
36447: PUSH
36448: LD_INT 0
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 1
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 1
36498: NEG
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: NEG
36510: PUSH
36511: LD_INT 1
36513: NEG
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: LD_INT 2
36525: NEG
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 0
36533: PUSH
36534: LD_INT 2
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 1
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 2
36555: PUSH
36556: LD_INT 0
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 2
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 2
36575: PUSH
36576: LD_INT 2
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 2
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: NEG
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 2
36606: NEG
36607: PUSH
36608: LD_INT 0
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 2
36617: NEG
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: LD_INT 3
36633: NEG
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: PUSH
36642: LD_INT 2
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 3
36652: PUSH
36653: LD_INT 2
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 2
36662: PUSH
36663: LD_INT 3
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 2
36672: NEG
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 3
36683: NEG
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: LIST
36712: LIST
36713: LIST
36714: LIST
36715: LIST
36716: LIST
36717: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36718: LD_ADDR_VAR 0 31
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 0
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 0
36735: PUSH
36736: LD_INT 1
36738: NEG
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 1
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: LD_INT 1
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: LD_INT 1
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 1
36776: NEG
36777: PUSH
36778: LD_INT 0
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: NEG
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: LD_INT 2
36803: NEG
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: PUSH
36812: LD_INT 1
36814: NEG
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 2
36822: PUSH
36823: LD_INT 0
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 2
36832: PUSH
36833: LD_INT 1
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 2
36842: PUSH
36843: LD_INT 2
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: LD_INT 2
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 0
36862: PUSH
36863: LD_INT 2
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 1
36872: NEG
36873: PUSH
36874: LD_INT 1
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 2
36883: NEG
36884: PUSH
36885: LD_INT 1
36887: NEG
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 2
36895: NEG
36896: PUSH
36897: LD_INT 2
36899: NEG
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 2
36907: NEG
36908: PUSH
36909: LD_INT 3
36911: NEG
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 2
36919: PUSH
36920: LD_INT 1
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: PUSH
36941: LD_INT 3
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: LD_INT 2
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 3
36961: NEG
36962: PUSH
36963: LD_INT 2
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36996: LD_ADDR_VAR 0 32
37000: PUSH
37001: LD_INT 0
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: LD_INT 1
37016: NEG
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 1
37034: PUSH
37035: LD_INT 1
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: LD_INT 1
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 1
37065: NEG
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 1
37077: NEG
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 0
37089: PUSH
37090: LD_INT 2
37092: NEG
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 1
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 2
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 2
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: LD_INT 2
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 2
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: LD_INT 1
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 1
37185: NEG
37186: PUSH
37187: LD_INT 3
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 3
37208: PUSH
37209: LD_INT 2
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: LD_INT 3
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 2
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 3
37239: NEG
37240: PUSH
37241: LD_INT 1
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: LIST
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37274: LD_ADDR_VAR 0 33
37278: PUSH
37279: LD_INT 0
37281: PUSH
37282: LD_INT 0
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: LD_INT 1
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 1
37302: PUSH
37303: LD_INT 0
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 1
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: LD_INT 0
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 1
37343: NEG
37344: PUSH
37345: LD_INT 1
37347: NEG
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 1
37355: NEG
37356: PUSH
37357: LD_INT 2
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 1
37367: PUSH
37368: LD_INT 1
37370: NEG
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 2
37378: PUSH
37379: LD_INT 0
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 2
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 0
37408: PUSH
37409: LD_INT 2
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: NEG
37419: PUSH
37420: LD_INT 1
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 2
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 2
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: NEG
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 2
37452: NEG
37453: PUSH
37454: LD_INT 2
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 2
37464: NEG
37465: PUSH
37466: LD_INT 3
37468: NEG
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: PUSH
37474: LD_INT 2
37476: PUSH
37477: LD_INT 1
37479: NEG
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: LD_INT 3
37487: PUSH
37488: LD_INT 1
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: PUSH
37498: LD_INT 3
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: LD_INT 2
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 3
37518: NEG
37519: PUSH
37520: LD_INT 2
37522: NEG
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: LIST
37549: LIST
37550: LIST
37551: LIST
37552: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37553: LD_ADDR_VAR 0 34
37557: PUSH
37558: LD_INT 0
37560: PUSH
37561: LD_INT 0
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 0
37570: PUSH
37571: LD_INT 1
37573: NEG
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 1
37581: PUSH
37582: LD_INT 0
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 1
37591: PUSH
37592: LD_INT 1
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 0
37601: PUSH
37602: LD_INT 1
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 0
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 1
37622: NEG
37623: PUSH
37624: LD_INT 1
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 1
37634: NEG
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: LD_INT 2
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 2
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 2
37678: PUSH
37679: LD_INT 2
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: LD_INT 2
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 1
37698: NEG
37699: PUSH
37700: LD_INT 1
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 2
37709: NEG
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: NEG
37721: PUSH
37722: LD_INT 1
37724: NEG
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: LD_INT 2
37736: NEG
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: LD_INT 3
37748: NEG
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 1
37756: PUSH
37757: LD_INT 2
37759: NEG
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 3
37767: PUSH
37768: LD_INT 2
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 2
37777: PUSH
37778: LD_INT 3
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 2
37787: NEG
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 3
37798: NEG
37799: PUSH
37800: LD_INT 1
37802: NEG
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: LIST
37825: LIST
37826: LIST
37827: LIST
37828: LIST
37829: LIST
37830: LIST
37831: LIST
37832: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37833: LD_ADDR_VAR 0 35
37837: PUSH
37838: LD_INT 0
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 0
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 1
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 1
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: LD_INT 1
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: LD_INT 0
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 1
37902: NEG
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 2
37914: PUSH
37915: LD_INT 1
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 2
37924: NEG
37925: PUSH
37926: LD_INT 1
37928: NEG
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37945: LD_ADDR_VAR 0 36
37949: PUSH
37950: LD_INT 0
37952: PUSH
37953: LD_INT 0
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 0
37962: PUSH
37963: LD_INT 1
37965: NEG
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 1
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 1
37983: PUSH
37984: LD_INT 1
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 0
37993: PUSH
37994: LD_INT 1
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 1
38003: NEG
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 1
38014: NEG
38015: PUSH
38016: LD_INT 1
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 1
38026: NEG
38027: PUSH
38028: LD_INT 2
38030: NEG
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38057: LD_ADDR_VAR 0 37
38061: PUSH
38062: LD_INT 0
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 0
38074: PUSH
38075: LD_INT 1
38077: NEG
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: LD_INT 1
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 1
38095: PUSH
38096: LD_INT 1
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 0
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 1
38126: NEG
38127: PUSH
38128: LD_INT 1
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: NEG
38150: PUSH
38151: LD_INT 1
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: LIST
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38169: LD_ADDR_VAR 0 38
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: LD_INT 0
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 0
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 1
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: LD_INT 1
38207: PUSH
38208: LD_INT 1
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: PUSH
38236: LD_INT 1
38238: NEG
38239: PUSH
38240: LD_INT 1
38242: NEG
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 2
38250: PUSH
38251: LD_INT 1
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 2
38260: NEG
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38281: LD_ADDR_VAR 0 39
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: LD_INT 0
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 0
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: PUSH
38310: LD_INT 0
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: LD_INT 1
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 1
38339: NEG
38340: PUSH
38341: LD_INT 0
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 1
38350: NEG
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 1
38362: NEG
38363: PUSH
38364: LD_INT 2
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 1
38374: PUSH
38375: LD_INT 2
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38393: LD_ADDR_VAR 0 40
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: LD_INT 1
38413: NEG
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: LD_INT 1
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 1
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: LD_INT 1
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: LD_INT 1
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 1
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: LD_INT 1
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38505: LD_ADDR_VAR 0 41
38509: PUSH
38510: LD_INT 0
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 1
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 1
38563: NEG
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 1
38574: NEG
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 1
38586: NEG
38587: PUSH
38588: LD_INT 2
38590: NEG
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 2
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 2
38619: PUSH
38620: LD_INT 1
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 2
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: PUSH
38640: LD_INT 2
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 1
38649: NEG
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 2
38660: NEG
38661: PUSH
38662: LD_INT 0
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 2
38671: NEG
38672: PUSH
38673: LD_INT 1
38675: NEG
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 2
38683: NEG
38684: PUSH
38685: LD_INT 2
38687: NEG
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 2
38695: NEG
38696: PUSH
38697: LD_INT 3
38699: NEG
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 3
38718: PUSH
38719: LD_INT 0
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 3
38728: PUSH
38729: LD_INT 1
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 3
38738: PUSH
38739: LD_INT 2
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: LD_INT 3
38748: PUSH
38749: LD_INT 3
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 2
38758: PUSH
38759: LD_INT 3
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 2
38768: NEG
38769: PUSH
38770: LD_INT 1
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 3
38779: NEG
38780: PUSH
38781: LD_INT 0
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 3
38790: NEG
38791: PUSH
38792: LD_INT 1
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 3
38802: NEG
38803: PUSH
38804: LD_INT 2
38806: NEG
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 3
38814: NEG
38815: PUSH
38816: LD_INT 3
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: LIST
38839: LIST
38840: LIST
38841: LIST
38842: LIST
38843: LIST
38844: LIST
38845: LIST
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38855: LD_ADDR_VAR 0 42
38859: PUSH
38860: LD_INT 0
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 0
38872: PUSH
38873: LD_INT 1
38875: NEG
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 1
38883: PUSH
38884: LD_INT 0
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 1
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 0
38903: PUSH
38904: LD_INT 1
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 1
38913: NEG
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 1
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 2
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: NEG
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 2
38970: PUSH
38971: LD_INT 1
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 2
38980: PUSH
38981: LD_INT 2
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 0
39000: PUSH
39001: LD_INT 2
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 1
39010: NEG
39011: PUSH
39012: LD_INT 1
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 2
39021: NEG
39022: PUSH
39023: LD_INT 1
39025: NEG
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 2
39033: NEG
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 2
39045: NEG
39046: PUSH
39047: LD_INT 3
39049: NEG
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: LD_INT 3
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 3
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 3
39091: PUSH
39092: LD_INT 2
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 3
39101: PUSH
39102: LD_INT 3
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 2
39111: PUSH
39112: LD_INT 3
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 1
39121: PUSH
39122: LD_INT 3
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 3
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: LD_INT 2
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 3
39152: NEG
39153: PUSH
39154: LD_INT 2
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 3
39164: NEG
39165: PUSH
39166: LD_INT 3
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39205: LD_ADDR_VAR 0 43
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 0
39222: PUSH
39223: LD_INT 1
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: PUSH
39234: LD_INT 0
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: PUSH
39244: LD_INT 1
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 0
39253: PUSH
39254: LD_INT 1
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: LD_INT 0
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 1
39274: NEG
39275: PUSH
39276: LD_INT 1
39278: NEG
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: LD_INT 2
39290: NEG
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 0
39298: PUSH
39299: LD_INT 2
39301: NEG
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: LD_INT 1
39312: NEG
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 2
39320: PUSH
39321: LD_INT 0
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 1
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: LD_INT 2
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 0
39350: PUSH
39351: LD_INT 2
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: NEG
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 2
39371: NEG
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 2
39382: NEG
39383: PUSH
39384: LD_INT 1
39386: NEG
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: NEG
39395: PUSH
39396: LD_INT 3
39398: NEG
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 3
39409: NEG
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 1
39417: PUSH
39418: LD_INT 2
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 3
39439: PUSH
39440: LD_INT 0
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 3
39449: PUSH
39450: LD_INT 1
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: LD_INT 3
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 1
39479: NEG
39480: PUSH
39481: LD_INT 2
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: LD_INT 2
39490: NEG
39491: PUSH
39492: LD_INT 1
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 3
39501: NEG
39502: PUSH
39503: LD_INT 0
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 3
39512: NEG
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39553: LD_ADDR_VAR 0 44
39557: PUSH
39558: LD_INT 0
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 0
39570: PUSH
39571: LD_INT 1
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 1
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 0
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 1
39611: NEG
39612: PUSH
39613: LD_INT 0
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 1
39622: NEG
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 1
39634: NEG
39635: PUSH
39636: LD_INT 2
39638: NEG
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 1
39646: PUSH
39647: LD_INT 1
39649: NEG
39650: PUSH
39651: EMPTY
39652: LIST
39653: LIST
39654: PUSH
39655: LD_INT 2
39657: PUSH
39658: LD_INT 0
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 2
39667: PUSH
39668: LD_INT 1
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: LD_INT 2
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 1
39687: PUSH
39688: LD_INT 2
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 2
39708: NEG
39709: PUSH
39710: LD_INT 0
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 2
39719: NEG
39720: PUSH
39721: LD_INT 1
39723: NEG
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 2
39731: NEG
39732: PUSH
39733: LD_INT 2
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: LD_INT 3
39747: NEG
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 2
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 3
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 3
39776: PUSH
39777: LD_INT 1
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 3
39786: PUSH
39787: LD_INT 2
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 3
39796: PUSH
39797: LD_INT 3
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 2
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 2
39816: NEG
39817: PUSH
39818: LD_INT 1
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 3
39827: NEG
39828: PUSH
39829: LD_INT 0
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 3
39838: NEG
39839: PUSH
39840: LD_INT 1
39842: NEG
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 3
39850: NEG
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 3
39862: NEG
39863: PUSH
39864: LD_INT 3
39866: NEG
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39903: LD_ADDR_VAR 0 45
39907: PUSH
39908: LD_INT 0
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: LD_INT 1
39923: NEG
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 1
39941: PUSH
39942: LD_INT 1
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 0
39951: PUSH
39952: LD_INT 1
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 1
39961: NEG
39962: PUSH
39963: LD_INT 0
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 1
39972: NEG
39973: PUSH
39974: LD_INT 1
39976: NEG
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: NEG
39985: PUSH
39986: LD_INT 2
39988: NEG
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: LD_INT 2
39999: NEG
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 1
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 2
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 2
40028: PUSH
40029: LD_INT 2
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 1
40038: PUSH
40039: LD_INT 2
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: LD_INT 2
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 1
40058: NEG
40059: PUSH
40060: LD_INT 1
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 2
40069: NEG
40070: PUSH
40071: LD_INT 1
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 2
40093: NEG
40094: PUSH
40095: LD_INT 3
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 1
40105: NEG
40106: PUSH
40107: LD_INT 3
40109: NEG
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: LD_INT 0
40117: PUSH
40118: LD_INT 3
40120: NEG
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 1
40128: PUSH
40129: LD_INT 2
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 3
40139: PUSH
40140: LD_INT 2
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 3
40149: PUSH
40150: LD_INT 3
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 2
40159: PUSH
40160: LD_INT 3
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 1
40169: PUSH
40170: LD_INT 3
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: LD_INT 3
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: LD_INT 2
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 3
40200: NEG
40201: PUSH
40202: LD_INT 2
40204: NEG
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 3
40212: NEG
40213: PUSH
40214: LD_INT 3
40216: NEG
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40253: LD_ADDR_VAR 0 46
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 0
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 1
40281: PUSH
40282: LD_INT 0
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 0
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: LD_INT 0
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 1
40322: NEG
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: LD_INT 2
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 0
40346: PUSH
40347: LD_INT 2
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: LD_INT 1
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 2
40368: PUSH
40369: LD_INT 0
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 2
40378: PUSH
40379: LD_INT 1
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 1
40388: PUSH
40389: LD_INT 2
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: LD_INT 2
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 1
40408: NEG
40409: PUSH
40410: LD_INT 1
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 2
40419: NEG
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 2
40430: NEG
40431: PUSH
40432: LD_INT 1
40434: NEG
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: LD_INT 3
40446: NEG
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 0
40454: PUSH
40455: LD_INT 3
40457: NEG
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 1
40465: PUSH
40466: LD_INT 2
40468: NEG
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 2
40476: PUSH
40477: LD_INT 1
40479: NEG
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 3
40487: PUSH
40488: LD_INT 0
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 3
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: LD_INT 3
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 3
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: NEG
40528: PUSH
40529: LD_INT 2
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 2
40538: NEG
40539: PUSH
40540: LD_INT 1
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 3
40549: NEG
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40601: LD_ADDR_VAR 0 47
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: LD_INT 1
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 1
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: NEG
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 1
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: NEG
40683: PUSH
40684: LD_INT 2
40686: NEG
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 0
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: LD_INT 1
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 2
40716: NEG
40717: PUSH
40718: LD_INT 1
40720: NEG
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 2
40728: NEG
40729: PUSH
40730: LD_INT 2
40732: NEG
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40752: LD_ADDR_VAR 0 48
40756: PUSH
40757: LD_INT 0
40759: PUSH
40760: LD_INT 0
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: LD_INT 1
40772: NEG
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: LD_INT 1
40780: PUSH
40781: LD_INT 0
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 1
40790: PUSH
40791: LD_INT 1
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 1
40810: NEG
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 1
40821: NEG
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 1
40833: NEG
40834: PUSH
40835: LD_INT 2
40837: NEG
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 0
40845: PUSH
40846: LD_INT 2
40848: NEG
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 1
40856: PUSH
40857: LD_INT 1
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 2
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 2
40877: PUSH
40878: LD_INT 1
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40899: LD_ADDR_VAR 0 49
40903: PUSH
40904: LD_INT 0
40906: PUSH
40907: LD_INT 0
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: LD_INT 1
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 1
40927: PUSH
40928: LD_INT 0
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 1
40937: PUSH
40938: LD_INT 1
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 0
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 1
40957: NEG
40958: PUSH
40959: LD_INT 0
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 1
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 2
40991: PUSH
40992: LD_INT 0
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 1
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: LD_INT 2
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: LD_INT 2
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41043: LD_ADDR_VAR 0 50
41047: PUSH
41048: LD_INT 0
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 0
41060: PUSH
41061: LD_INT 1
41063: NEG
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 1
41071: PUSH
41072: LD_INT 0
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: LD_INT 1
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 1
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 1
41112: NEG
41113: PUSH
41114: LD_INT 1
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 2
41124: PUSH
41125: LD_INT 1
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: PUSH
41135: LD_INT 2
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: LD_INT 2
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: LD_INT 2
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 1
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: LIST
41177: LIST
41178: LIST
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: LIST
41184: LIST
41185: LIST
41186: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41187: LD_ADDR_VAR 0 51
41191: PUSH
41192: LD_INT 0
41194: PUSH
41195: LD_INT 0
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 0
41204: PUSH
41205: LD_INT 1
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 1
41215: PUSH
41216: LD_INT 0
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: PUSH
41226: LD_INT 1
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 0
41235: PUSH
41236: LD_INT 1
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 1
41245: NEG
41246: PUSH
41247: LD_INT 0
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 1
41256: NEG
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 1
41268: PUSH
41269: LD_INT 2
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 0
41278: PUSH
41279: LD_INT 2
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 1
41288: NEG
41289: PUSH
41290: LD_INT 1
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 2
41299: NEG
41300: PUSH
41301: LD_INT 0
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 2
41310: NEG
41311: PUSH
41312: LD_INT 1
41314: NEG
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: LIST
41324: LIST
41325: LIST
41326: LIST
41327: LIST
41328: LIST
41329: LIST
41330: LIST
41331: LIST
41332: LIST
41333: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41334: LD_ADDR_VAR 0 52
41338: PUSH
41339: LD_INT 0
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 0
41351: PUSH
41352: LD_INT 1
41354: NEG
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 1
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 1
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: LD_INT 1
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: LD_INT 0
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 1
41403: NEG
41404: PUSH
41405: LD_INT 1
41407: NEG
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 1
41415: NEG
41416: PUSH
41417: LD_INT 2
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 1
41427: NEG
41428: PUSH
41429: LD_INT 1
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 2
41438: NEG
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 2
41449: NEG
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: LD_INT 2
41465: NEG
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: LIST
41483: LIST
41484: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41485: LD_ADDR_VAR 0 53
41489: PUSH
41490: LD_INT 0
41492: PUSH
41493: LD_INT 0
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 0
41502: PUSH
41503: LD_INT 1
41505: NEG
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: LD_INT 0
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: LD_INT 1
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 0
41533: PUSH
41534: LD_INT 1
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: LD_INT 0
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: PUSH
41552: LD_INT 1
41554: NEG
41555: PUSH
41556: LD_INT 1
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: LD_INT 2
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 0
41578: PUSH
41579: LD_INT 2
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 1
41589: PUSH
41590: LD_INT 1
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 2
41600: PUSH
41601: LD_INT 0
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: LD_INT 2
41610: PUSH
41611: LD_INT 1
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 2
41620: PUSH
41621: LD_INT 2
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: LD_INT 1
41630: PUSH
41631: LD_INT 2
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: LD_INT 0
41640: PUSH
41641: LD_INT 2
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: LD_INT 1
41650: NEG
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 2
41661: NEG
41662: PUSH
41663: LD_INT 0
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 2
41672: NEG
41673: PUSH
41674: LD_INT 1
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 2
41684: NEG
41685: PUSH
41686: LD_INT 2
41688: NEG
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41715: LD_ADDR_VAR 0 54
41719: PUSH
41720: LD_INT 0
41722: PUSH
41723: LD_INT 0
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 0
41732: PUSH
41733: LD_INT 1
41735: NEG
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: LD_INT 0
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 1
41753: PUSH
41754: LD_INT 1
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: LD_INT 1
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: LD_INT 1
41773: NEG
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 1
41784: NEG
41785: PUSH
41786: LD_INT 1
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: LD_INT 2
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 0
41808: PUSH
41809: LD_INT 2
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: LD_INT 1
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 2
41830: PUSH
41831: LD_INT 0
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 2
41840: PUSH
41841: LD_INT 1
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 2
41850: PUSH
41851: LD_INT 2
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 1
41860: PUSH
41861: LD_INT 2
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: LD_INT 2
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: LD_INT 1
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 2
41891: NEG
41892: PUSH
41893: LD_INT 0
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 2
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: NEG
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 2
41914: NEG
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: LIST
41928: LIST
41929: LIST
41930: LIST
41931: LIST
41932: LIST
41933: LIST
41934: LIST
41935: LIST
41936: LIST
41937: LIST
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41945: LD_ADDR_VAR 0 55
41949: PUSH
41950: LD_INT 0
41952: PUSH
41953: LD_INT 0
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 0
41962: PUSH
41963: LD_INT 1
41965: NEG
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 1
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: PUSH
41984: LD_INT 1
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: LD_INT 1
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 1
42003: NEG
42004: PUSH
42005: LD_INT 0
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 1
42026: NEG
42027: PUSH
42028: LD_INT 2
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 0
42038: PUSH
42039: LD_INT 2
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 1
42049: PUSH
42050: LD_INT 1
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 2
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 2
42070: PUSH
42071: LD_INT 1
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 2
42080: PUSH
42081: LD_INT 2
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 1
42090: PUSH
42091: LD_INT 2
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 0
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 1
42110: NEG
42111: PUSH
42112: LD_INT 1
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 2
42121: NEG
42122: PUSH
42123: LD_INT 0
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 2
42132: NEG
42133: PUSH
42134: LD_INT 1
42136: NEG
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 2
42144: NEG
42145: PUSH
42146: LD_INT 2
42148: NEG
42149: PUSH
42150: EMPTY
42151: LIST
42152: LIST
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: LIST
42166: LIST
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42175: LD_ADDR_VAR 0 56
42179: PUSH
42180: LD_INT 0
42182: PUSH
42183: LD_INT 0
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: LD_INT 1
42195: NEG
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 1
42203: PUSH
42204: LD_INT 0
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: LD_INT 1
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: LD_INT 1
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: LD_INT 0
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 1
42244: NEG
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 1
42256: NEG
42257: PUSH
42258: LD_INT 2
42260: NEG
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 0
42268: PUSH
42269: LD_INT 2
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: LD_INT 1
42282: NEG
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: LD_INT 0
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 2
42300: PUSH
42301: LD_INT 1
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 2
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 1
42320: PUSH
42321: LD_INT 2
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 0
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 1
42340: NEG
42341: PUSH
42342: LD_INT 1
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: PUSH
42349: LD_INT 2
42351: NEG
42352: PUSH
42353: LD_INT 0
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 2
42362: NEG
42363: PUSH
42364: LD_INT 1
42366: NEG
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 2
42374: NEG
42375: PUSH
42376: LD_INT 2
42378: NEG
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: LIST
42388: LIST
42389: LIST
42390: LIST
42391: LIST
42392: LIST
42393: LIST
42394: LIST
42395: LIST
42396: LIST
42397: LIST
42398: LIST
42399: LIST
42400: LIST
42401: LIST
42402: LIST
42403: LIST
42404: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42405: LD_ADDR_VAR 0 57
42409: PUSH
42410: LD_INT 0
42412: PUSH
42413: LD_INT 0
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 1
42433: PUSH
42434: LD_INT 0
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 1
42443: PUSH
42444: LD_INT 1
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 0
42453: PUSH
42454: LD_INT 1
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 1
42463: NEG
42464: PUSH
42465: LD_INT 0
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 1
42474: NEG
42475: PUSH
42476: LD_INT 1
42478: NEG
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: LD_INT 1
42486: NEG
42487: PUSH
42488: LD_INT 2
42490: NEG
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 0
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 1
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 2
42520: PUSH
42521: LD_INT 0
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 2
42530: PUSH
42531: LD_INT 1
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 2
42540: PUSH
42541: LD_INT 2
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 1
42550: PUSH
42551: LD_INT 2
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 0
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 1
42570: NEG
42571: PUSH
42572: LD_INT 1
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 2
42581: NEG
42582: PUSH
42583: LD_INT 0
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: LD_INT 2
42592: NEG
42593: PUSH
42594: LD_INT 1
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 2
42604: NEG
42605: PUSH
42606: LD_INT 2
42608: NEG
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42635: LD_ADDR_VAR 0 58
42639: PUSH
42640: LD_INT 0
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: LD_INT 1
42655: NEG
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: PUSH
42674: LD_INT 1
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: LD_INT 1
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: NEG
42694: PUSH
42695: LD_INT 0
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: NEG
42705: PUSH
42706: LD_INT 1
42708: NEG
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: LD_INT 2
42720: NEG
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: LD_INT 2
42731: NEG
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: LD_INT 1
42742: NEG
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 2
42750: PUSH
42751: LD_INT 0
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: LD_INT 2
42760: PUSH
42761: LD_INT 1
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 2
42770: PUSH
42771: LD_INT 2
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 1
42780: PUSH
42781: LD_INT 2
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: LD_INT 2
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: LD_INT 1
42800: NEG
42801: PUSH
42802: LD_INT 1
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: LD_INT 2
42811: NEG
42812: PUSH
42813: LD_INT 0
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 2
42822: NEG
42823: PUSH
42824: LD_INT 1
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: LD_INT 2
42838: NEG
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42865: LD_ADDR_VAR 0 59
42869: PUSH
42870: LD_INT 0
42872: PUSH
42873: LD_INT 0
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: LD_INT 1
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 1
42893: PUSH
42894: LD_INT 0
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 1
42903: PUSH
42904: LD_INT 1
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: LD_INT 1
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 1
42923: NEG
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: PUSH
42932: LD_INT 1
42934: NEG
42935: PUSH
42936: LD_INT 1
42938: NEG
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42953: LD_ADDR_VAR 0 60
42957: PUSH
42958: LD_INT 0
42960: PUSH
42961: LD_INT 0
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 0
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: LD_INT 0
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 0
43001: PUSH
43002: LD_INT 1
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PUSH
43009: LD_INT 1
43011: NEG
43012: PUSH
43013: LD_INT 0
43015: PUSH
43016: EMPTY
43017: LIST
43018: LIST
43019: PUSH
43020: LD_INT 1
43022: NEG
43023: PUSH
43024: LD_INT 1
43026: NEG
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43041: LD_ADDR_VAR 0 61
43045: PUSH
43046: LD_INT 0
43048: PUSH
43049: LD_INT 0
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 0
43058: PUSH
43059: LD_INT 1
43061: NEG
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 1
43069: PUSH
43070: LD_INT 0
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 1
43079: PUSH
43080: LD_INT 1
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 0
43089: PUSH
43090: LD_INT 1
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 1
43099: NEG
43100: PUSH
43101: LD_INT 0
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 1
43110: NEG
43111: PUSH
43112: LD_INT 1
43114: NEG
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: LIST
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43129: LD_ADDR_VAR 0 62
43133: PUSH
43134: LD_INT 0
43136: PUSH
43137: LD_INT 0
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: LD_INT 0
43146: PUSH
43147: LD_INT 1
43149: NEG
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 1
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 1
43167: PUSH
43168: LD_INT 1
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 0
43177: PUSH
43178: LD_INT 1
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 1
43187: NEG
43188: PUSH
43189: LD_INT 0
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 1
43198: NEG
43199: PUSH
43200: LD_INT 1
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: LIST
43212: LIST
43213: LIST
43214: LIST
43215: LIST
43216: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43217: LD_ADDR_VAR 0 63
43221: PUSH
43222: LD_INT 0
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 0
43234: PUSH
43235: LD_INT 1
43237: NEG
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 1
43245: PUSH
43246: LD_INT 0
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 1
43255: PUSH
43256: LD_INT 1
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 0
43265: PUSH
43266: LD_INT 1
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 1
43275: NEG
43276: PUSH
43277: LD_INT 0
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 1
43286: NEG
43287: PUSH
43288: LD_INT 1
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: LIST
43300: LIST
43301: LIST
43302: LIST
43303: LIST
43304: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43305: LD_ADDR_VAR 0 64
43309: PUSH
43310: LD_INT 0
43312: PUSH
43313: LD_INT 0
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 0
43322: PUSH
43323: LD_INT 1
43325: NEG
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 1
43333: PUSH
43334: LD_INT 0
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 1
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 0
43353: PUSH
43354: LD_INT 1
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: LD_INT 0
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: NEG
43375: PUSH
43376: LD_INT 1
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: ST_TO_ADDR
// end ; 1 :
43393: GO 49290
43395: LD_INT 1
43397: DOUBLE
43398: EQUAL
43399: IFTRUE 43403
43401: GO 46026
43403: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43404: LD_ADDR_VAR 0 11
43408: PUSH
43409: LD_INT 1
43411: NEG
43412: PUSH
43413: LD_INT 3
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 0
43423: PUSH
43424: LD_INT 3
43426: NEG
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 1
43434: PUSH
43435: LD_INT 2
43437: NEG
43438: PUSH
43439: EMPTY
43440: LIST
43441: LIST
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: LIST
43447: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43448: LD_ADDR_VAR 0 12
43452: PUSH
43453: LD_INT 2
43455: PUSH
43456: LD_INT 1
43458: NEG
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 3
43466: PUSH
43467: LD_INT 0
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 3
43476: PUSH
43477: LD_INT 1
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: LIST
43488: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43489: LD_ADDR_VAR 0 13
43493: PUSH
43494: LD_INT 3
43496: PUSH
43497: LD_INT 2
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: PUSH
43507: LD_INT 3
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 2
43516: PUSH
43517: LD_INT 3
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: LIST
43528: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43529: LD_ADDR_VAR 0 14
43533: PUSH
43534: LD_INT 1
43536: PUSH
43537: LD_INT 3
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 0
43546: PUSH
43547: LD_INT 3
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 1
43556: NEG
43557: PUSH
43558: LD_INT 2
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: LIST
43569: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43570: LD_ADDR_VAR 0 15
43574: PUSH
43575: LD_INT 2
43577: NEG
43578: PUSH
43579: LD_INT 1
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 3
43588: NEG
43589: PUSH
43590: LD_INT 0
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 3
43599: NEG
43600: PUSH
43601: LD_INT 1
43603: NEG
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: LIST
43613: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43614: LD_ADDR_VAR 0 16
43618: PUSH
43619: LD_INT 2
43621: NEG
43622: PUSH
43623: LD_INT 3
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 3
43633: NEG
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 3
43645: NEG
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: LIST
43659: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43660: LD_ADDR_VAR 0 17
43664: PUSH
43665: LD_INT 1
43667: NEG
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: LD_INT 0
43679: PUSH
43680: LD_INT 3
43682: NEG
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: PUSH
43688: LD_INT 1
43690: PUSH
43691: LD_INT 2
43693: NEG
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: LIST
43703: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43704: LD_ADDR_VAR 0 18
43708: PUSH
43709: LD_INT 2
43711: PUSH
43712: LD_INT 1
43714: NEG
43715: PUSH
43716: EMPTY
43717: LIST
43718: LIST
43719: PUSH
43720: LD_INT 3
43722: PUSH
43723: LD_INT 0
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 3
43732: PUSH
43733: LD_INT 1
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: LIST
43744: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43745: LD_ADDR_VAR 0 19
43749: PUSH
43750: LD_INT 3
43752: PUSH
43753: LD_INT 2
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 3
43762: PUSH
43763: LD_INT 3
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: LD_INT 2
43772: PUSH
43773: LD_INT 3
43775: PUSH
43776: EMPTY
43777: LIST
43778: LIST
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: LIST
43784: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43785: LD_ADDR_VAR 0 20
43789: PUSH
43790: LD_INT 1
43792: PUSH
43793: LD_INT 3
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 0
43802: PUSH
43803: LD_INT 3
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 1
43812: NEG
43813: PUSH
43814: LD_INT 2
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: LIST
43825: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43826: LD_ADDR_VAR 0 21
43830: PUSH
43831: LD_INT 2
43833: NEG
43834: PUSH
43835: LD_INT 1
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 3
43844: NEG
43845: PUSH
43846: LD_INT 0
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 3
43855: NEG
43856: PUSH
43857: LD_INT 1
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: LIST
43869: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43870: LD_ADDR_VAR 0 22
43874: PUSH
43875: LD_INT 2
43877: NEG
43878: PUSH
43879: LD_INT 3
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 3
43889: NEG
43890: PUSH
43891: LD_INT 2
43893: NEG
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 3
43901: NEG
43902: PUSH
43903: LD_INT 3
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: LIST
43915: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43916: LD_ADDR_VAR 0 23
43920: PUSH
43921: LD_INT 0
43923: PUSH
43924: LD_INT 3
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: NEG
43935: PUSH
43936: LD_INT 4
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 1
43946: PUSH
43947: LD_INT 3
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: LIST
43959: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43960: LD_ADDR_VAR 0 24
43964: PUSH
43965: LD_INT 3
43967: PUSH
43968: LD_INT 0
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 3
43977: PUSH
43978: LD_INT 1
43980: NEG
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 4
43988: PUSH
43989: LD_INT 1
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: LIST
44000: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44001: LD_ADDR_VAR 0 25
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: LD_INT 3
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 4
44018: PUSH
44019: LD_INT 3
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 3
44028: PUSH
44029: LD_INT 4
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: LIST
44040: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44041: LD_ADDR_VAR 0 26
44045: PUSH
44046: LD_INT 0
44048: PUSH
44049: LD_INT 3
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 1
44058: PUSH
44059: LD_INT 4
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 1
44068: NEG
44069: PUSH
44070: LD_INT 3
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: LIST
44081: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44082: LD_ADDR_VAR 0 27
44086: PUSH
44087: LD_INT 3
44089: NEG
44090: PUSH
44091: LD_INT 0
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 3
44100: NEG
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 4
44111: NEG
44112: PUSH
44113: LD_INT 1
44115: NEG
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: LIST
44125: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44126: LD_ADDR_VAR 0 28
44130: PUSH
44131: LD_INT 3
44133: NEG
44134: PUSH
44135: LD_INT 3
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 3
44145: NEG
44146: PUSH
44147: LD_INT 4
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 4
44157: NEG
44158: PUSH
44159: LD_INT 3
44161: NEG
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: LIST
44171: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44172: LD_ADDR_VAR 0 29
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: LD_INT 3
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 0
44191: PUSH
44192: LD_INT 3
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 1
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 1
44213: NEG
44214: PUSH
44215: LD_INT 4
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 0
44225: PUSH
44226: LD_INT 4
44228: NEG
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 1
44236: PUSH
44237: LD_INT 3
44239: NEG
44240: PUSH
44241: EMPTY
44242: LIST
44243: LIST
44244: PUSH
44245: LD_INT 1
44247: NEG
44248: PUSH
44249: LD_INT 5
44251: NEG
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 0
44259: PUSH
44260: LD_INT 5
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 1
44270: PUSH
44271: LD_INT 4
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 1
44281: NEG
44282: PUSH
44283: LD_INT 6
44285: NEG
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: PUSH
44291: LD_INT 0
44293: PUSH
44294: LD_INT 6
44296: NEG
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 1
44304: PUSH
44305: LD_INT 5
44307: NEG
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: EMPTY
44314: LIST
44315: LIST
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44327: LD_ADDR_VAR 0 30
44331: PUSH
44332: LD_INT 2
44334: PUSH
44335: LD_INT 1
44337: NEG
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 3
44345: PUSH
44346: LD_INT 0
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 3
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 3
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 4
44376: PUSH
44377: LD_INT 0
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 4
44386: PUSH
44387: LD_INT 1
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 4
44396: PUSH
44397: LD_INT 1
44399: NEG
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 5
44407: PUSH
44408: LD_INT 0
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 5
44417: PUSH
44418: LD_INT 1
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 5
44427: PUSH
44428: LD_INT 1
44430: NEG
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 6
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 6
44448: PUSH
44449: LD_INT 1
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44470: LD_ADDR_VAR 0 31
44474: PUSH
44475: LD_INT 3
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 3
44487: PUSH
44488: LD_INT 3
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 2
44497: PUSH
44498: LD_INT 3
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 4
44507: PUSH
44508: LD_INT 3
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 4
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 3
44527: PUSH
44528: LD_INT 4
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 5
44537: PUSH
44538: LD_INT 4
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 5
44547: PUSH
44548: LD_INT 5
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 4
44557: PUSH
44558: LD_INT 5
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 6
44567: PUSH
44568: LD_INT 5
44570: PUSH
44571: EMPTY
44572: LIST
44573: LIST
44574: PUSH
44575: LD_INT 6
44577: PUSH
44578: LD_INT 6
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 5
44587: PUSH
44588: LD_INT 6
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44609: LD_ADDR_VAR 0 32
44613: PUSH
44614: LD_INT 1
44616: PUSH
44617: LD_INT 3
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: LD_INT 3
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: LD_INT 2
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 1
44647: PUSH
44648: LD_INT 4
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 0
44657: PUSH
44658: LD_INT 4
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 1
44667: NEG
44668: PUSH
44669: LD_INT 3
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 1
44678: PUSH
44679: LD_INT 5
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: PUSH
44686: LD_INT 0
44688: PUSH
44689: LD_INT 5
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 1
44698: NEG
44699: PUSH
44700: LD_INT 4
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 1
44709: PUSH
44710: LD_INT 6
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 6
44722: PUSH
44723: EMPTY
44724: LIST
44725: LIST
44726: PUSH
44727: LD_INT 1
44729: NEG
44730: PUSH
44731: LD_INT 5
44733: PUSH
44734: EMPTY
44735: LIST
44736: LIST
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
44752: LD_ADDR_VAR 0 33
44756: PUSH
44757: LD_INT 2
44759: NEG
44760: PUSH
44761: LD_INT 1
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 3
44770: NEG
44771: PUSH
44772: LD_INT 0
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 3
44781: NEG
44782: PUSH
44783: LD_INT 1
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 3
44793: NEG
44794: PUSH
44795: LD_INT 1
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 4
44804: NEG
44805: PUSH
44806: LD_INT 0
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 4
44815: NEG
44816: PUSH
44817: LD_INT 1
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 4
44827: NEG
44828: PUSH
44829: LD_INT 1
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 5
44838: NEG
44839: PUSH
44840: LD_INT 0
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 5
44849: NEG
44850: PUSH
44851: LD_INT 1
44853: NEG
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 5
44861: NEG
44862: PUSH
44863: LD_INT 1
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 6
44872: NEG
44873: PUSH
44874: LD_INT 0
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 6
44883: NEG
44884: PUSH
44885: LD_INT 1
44887: NEG
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44907: LD_ADDR_VAR 0 34
44911: PUSH
44912: LD_INT 2
44914: NEG
44915: PUSH
44916: LD_INT 3
44918: NEG
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 3
44926: NEG
44927: PUSH
44928: LD_INT 2
44930: NEG
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: PUSH
44936: LD_INT 3
44938: NEG
44939: PUSH
44940: LD_INT 3
44942: NEG
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 3
44950: NEG
44951: PUSH
44952: LD_INT 4
44954: NEG
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 4
44962: NEG
44963: PUSH
44964: LD_INT 3
44966: NEG
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 4
44974: NEG
44975: PUSH
44976: LD_INT 4
44978: NEG
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 4
44986: NEG
44987: PUSH
44988: LD_INT 5
44990: NEG
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: PUSH
44996: LD_INT 5
44998: NEG
44999: PUSH
45000: LD_INT 4
45002: NEG
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: LD_INT 5
45010: NEG
45011: PUSH
45012: LD_INT 5
45014: NEG
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: LD_INT 5
45022: NEG
45023: PUSH
45024: LD_INT 6
45026: NEG
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 6
45034: NEG
45035: PUSH
45036: LD_INT 5
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 6
45046: NEG
45047: PUSH
45048: LD_INT 6
45050: NEG
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45070: LD_ADDR_VAR 0 41
45074: PUSH
45075: LD_INT 0
45077: PUSH
45078: LD_INT 2
45080: NEG
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 1
45088: NEG
45089: PUSH
45090: LD_INT 3
45092: NEG
45093: PUSH
45094: EMPTY
45095: LIST
45096: LIST
45097: PUSH
45098: LD_INT 1
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: LIST
45113: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45114: LD_ADDR_VAR 0 42
45118: PUSH
45119: LD_INT 2
45121: PUSH
45122: LD_INT 0
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 2
45131: PUSH
45132: LD_INT 1
45134: NEG
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 3
45142: PUSH
45143: LD_INT 1
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: LIST
45154: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45155: LD_ADDR_VAR 0 43
45159: PUSH
45160: LD_INT 2
45162: PUSH
45163: LD_INT 2
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: PUSH
45170: LD_INT 3
45172: PUSH
45173: LD_INT 2
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 2
45182: PUSH
45183: LD_INT 3
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: LIST
45194: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45195: LD_ADDR_VAR 0 44
45199: PUSH
45200: LD_INT 0
45202: PUSH
45203: LD_INT 2
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 1
45212: PUSH
45213: LD_INT 3
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 1
45222: NEG
45223: PUSH
45224: LD_INT 2
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: LIST
45235: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45236: LD_ADDR_VAR 0 45
45240: PUSH
45241: LD_INT 2
45243: NEG
45244: PUSH
45245: LD_INT 0
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: PUSH
45252: LD_INT 2
45254: NEG
45255: PUSH
45256: LD_INT 1
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 3
45265: NEG
45266: PUSH
45267: LD_INT 1
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: LIST
45279: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45280: LD_ADDR_VAR 0 46
45284: PUSH
45285: LD_INT 2
45287: NEG
45288: PUSH
45289: LD_INT 2
45291: NEG
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 2
45299: NEG
45300: PUSH
45301: LD_INT 3
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: LD_INT 3
45311: NEG
45312: PUSH
45313: LD_INT 2
45315: NEG
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: LIST
45325: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45326: LD_ADDR_VAR 0 47
45330: PUSH
45331: LD_INT 2
45333: NEG
45334: PUSH
45335: LD_INT 3
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 1
45345: NEG
45346: PUSH
45347: LD_INT 3
45349: NEG
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45359: LD_ADDR_VAR 0 48
45363: PUSH
45364: LD_INT 1
45366: PUSH
45367: LD_INT 2
45369: NEG
45370: PUSH
45371: EMPTY
45372: LIST
45373: LIST
45374: PUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 1
45380: NEG
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45390: LD_ADDR_VAR 0 49
45394: PUSH
45395: LD_INT 3
45397: PUSH
45398: LD_INT 1
45400: PUSH
45401: EMPTY
45402: LIST
45403: LIST
45404: PUSH
45405: LD_INT 3
45407: PUSH
45408: LD_INT 2
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45419: LD_ADDR_VAR 0 50
45423: PUSH
45424: LD_INT 2
45426: PUSH
45427: LD_INT 3
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 1
45436: PUSH
45437: LD_INT 3
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: EMPTY
45445: LIST
45446: LIST
45447: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45448: LD_ADDR_VAR 0 51
45452: PUSH
45453: LD_INT 1
45455: NEG
45456: PUSH
45457: LD_INT 2
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 2
45466: NEG
45467: PUSH
45468: LD_INT 1
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45479: LD_ADDR_VAR 0 52
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: LD_INT 1
45490: NEG
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: LD_INT 3
45498: NEG
45499: PUSH
45500: LD_INT 2
45502: NEG
45503: PUSH
45504: EMPTY
45505: LIST
45506: LIST
45507: PUSH
45508: EMPTY
45509: LIST
45510: LIST
45511: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45512: LD_ADDR_VAR 0 53
45516: PUSH
45517: LD_INT 1
45519: NEG
45520: PUSH
45521: LD_INT 3
45523: NEG
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 0
45531: PUSH
45532: LD_INT 3
45534: NEG
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: LD_INT 2
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: LIST
45555: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45556: LD_ADDR_VAR 0 54
45560: PUSH
45561: LD_INT 2
45563: PUSH
45564: LD_INT 1
45566: NEG
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: PUSH
45572: LD_INT 3
45574: PUSH
45575: LD_INT 0
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: LD_INT 3
45584: PUSH
45585: LD_INT 1
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: LIST
45596: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45597: LD_ADDR_VAR 0 55
45601: PUSH
45602: LD_INT 3
45604: PUSH
45605: LD_INT 2
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: PUSH
45612: LD_INT 3
45614: PUSH
45615: LD_INT 3
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: PUSH
45622: LD_INT 2
45624: PUSH
45625: LD_INT 3
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: LIST
45636: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45637: LD_ADDR_VAR 0 56
45641: PUSH
45642: LD_INT 1
45644: PUSH
45645: LD_INT 3
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 0
45654: PUSH
45655: LD_INT 3
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: LD_INT 1
45664: NEG
45665: PUSH
45666: LD_INT 2
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: LIST
45677: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45678: LD_ADDR_VAR 0 57
45682: PUSH
45683: LD_INT 2
45685: NEG
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 3
45696: NEG
45697: PUSH
45698: LD_INT 0
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 3
45707: NEG
45708: PUSH
45709: LD_INT 1
45711: NEG
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: LIST
45721: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45722: LD_ADDR_VAR 0 58
45726: PUSH
45727: LD_INT 2
45729: NEG
45730: PUSH
45731: LD_INT 3
45733: NEG
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: NEG
45742: PUSH
45743: LD_INT 2
45745: NEG
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: LD_INT 3
45753: NEG
45754: PUSH
45755: LD_INT 3
45757: NEG
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: LIST
45767: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
45768: LD_ADDR_VAR 0 59
45772: PUSH
45773: LD_INT 1
45775: NEG
45776: PUSH
45777: LD_INT 2
45779: NEG
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 0
45787: PUSH
45788: LD_INT 2
45790: NEG
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 1
45798: PUSH
45799: LD_INT 1
45801: NEG
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: LIST
45811: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
45812: LD_ADDR_VAR 0 60
45816: PUSH
45817: LD_INT 1
45819: PUSH
45820: LD_INT 1
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 0
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 2
45840: PUSH
45841: LD_INT 1
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: LIST
45852: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45853: LD_ADDR_VAR 0 61
45857: PUSH
45858: LD_INT 2
45860: PUSH
45861: LD_INT 1
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 2
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 1
45880: PUSH
45881: LD_INT 2
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: LIST
45892: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45893: LD_ADDR_VAR 0 62
45897: PUSH
45898: LD_INT 1
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: LD_INT 0
45910: PUSH
45911: LD_INT 2
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 1
45920: NEG
45921: PUSH
45922: LD_INT 1
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: LIST
45933: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45934: LD_ADDR_VAR 0 63
45938: PUSH
45939: LD_INT 1
45941: NEG
45942: PUSH
45943: LD_INT 1
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: PUSH
45950: LD_INT 2
45952: NEG
45953: PUSH
45954: LD_INT 0
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_INT 2
45963: NEG
45964: PUSH
45965: LD_INT 1
45967: NEG
45968: PUSH
45969: EMPTY
45970: LIST
45971: LIST
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45978: LD_ADDR_VAR 0 64
45982: PUSH
45983: LD_INT 1
45985: NEG
45986: PUSH
45987: LD_INT 2
45989: NEG
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: PUSH
45995: LD_INT 2
45997: NEG
45998: PUSH
45999: LD_INT 1
46001: NEG
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 2
46009: NEG
46010: PUSH
46011: LD_INT 2
46013: NEG
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: LIST
46023: ST_TO_ADDR
// end ; 2 :
46024: GO 49290
46026: LD_INT 2
46028: DOUBLE
46029: EQUAL
46030: IFTRUE 46034
46032: GO 49289
46034: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46035: LD_ADDR_VAR 0 29
46039: PUSH
46040: LD_INT 4
46042: PUSH
46043: LD_INT 0
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 4
46052: PUSH
46053: LD_INT 1
46055: NEG
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 5
46063: PUSH
46064: LD_INT 0
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 5
46073: PUSH
46074: LD_INT 1
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 4
46083: PUSH
46084: LD_INT 1
46086: PUSH
46087: EMPTY
46088: LIST
46089: LIST
46090: PUSH
46091: LD_INT 3
46093: PUSH
46094: LD_INT 0
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 3
46103: PUSH
46104: LD_INT 1
46106: NEG
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: PUSH
46112: LD_INT 3
46114: PUSH
46115: LD_INT 2
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 5
46125: PUSH
46126: LD_INT 2
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: PUSH
46133: LD_INT 3
46135: PUSH
46136: LD_INT 3
46138: PUSH
46139: EMPTY
46140: LIST
46141: LIST
46142: PUSH
46143: LD_INT 3
46145: PUSH
46146: LD_INT 2
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 4
46155: PUSH
46156: LD_INT 3
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: PUSH
46163: LD_INT 4
46165: PUSH
46166: LD_INT 4
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PUSH
46173: LD_INT 3
46175: PUSH
46176: LD_INT 4
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: PUSH
46183: LD_INT 2
46185: PUSH
46186: LD_INT 3
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: PUSH
46193: LD_INT 2
46195: PUSH
46196: LD_INT 2
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 4
46205: PUSH
46206: LD_INT 2
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 2
46215: PUSH
46216: LD_INT 4
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 0
46225: PUSH
46226: LD_INT 4
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 0
46235: PUSH
46236: LD_INT 3
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 1
46245: PUSH
46246: LD_INT 4
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 1
46255: PUSH
46256: LD_INT 5
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 0
46265: PUSH
46266: LD_INT 5
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 1
46275: NEG
46276: PUSH
46277: LD_INT 4
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 1
46286: NEG
46287: PUSH
46288: LD_INT 3
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PUSH
46295: LD_INT 2
46297: PUSH
46298: LD_INT 5
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: LD_INT 2
46307: NEG
46308: PUSH
46309: LD_INT 3
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 3
46318: NEG
46319: PUSH
46320: LD_INT 0
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 3
46329: NEG
46330: PUSH
46331: LD_INT 1
46333: NEG
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 2
46341: NEG
46342: PUSH
46343: LD_INT 0
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 2
46352: NEG
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 3
46363: NEG
46364: PUSH
46365: LD_INT 1
46367: PUSH
46368: EMPTY
46369: LIST
46370: LIST
46371: PUSH
46372: LD_INT 4
46374: NEG
46375: PUSH
46376: LD_INT 0
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 4
46385: NEG
46386: PUSH
46387: LD_INT 1
46389: NEG
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 4
46397: NEG
46398: PUSH
46399: LD_INT 2
46401: NEG
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 2
46409: NEG
46410: PUSH
46411: LD_INT 2
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 4
46420: NEG
46421: PUSH
46422: LD_INT 4
46424: NEG
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 4
46432: NEG
46433: PUSH
46434: LD_INT 5
46436: NEG
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: LD_INT 3
46444: NEG
46445: PUSH
46446: LD_INT 4
46448: NEG
46449: PUSH
46450: EMPTY
46451: LIST
46452: LIST
46453: PUSH
46454: LD_INT 3
46456: NEG
46457: PUSH
46458: LD_INT 3
46460: NEG
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 4
46468: NEG
46469: PUSH
46470: LD_INT 3
46472: NEG
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 5
46480: NEG
46481: PUSH
46482: LD_INT 4
46484: NEG
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: LD_INT 5
46492: NEG
46493: PUSH
46494: LD_INT 5
46496: NEG
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 3
46504: NEG
46505: PUSH
46506: LD_INT 5
46508: NEG
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: PUSH
46514: LD_INT 5
46516: NEG
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: EMPTY
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46573: LD_ADDR_VAR 0 30
46577: PUSH
46578: LD_INT 4
46580: PUSH
46581: LD_INT 4
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: PUSH
46588: LD_INT 4
46590: PUSH
46591: LD_INT 3
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 5
46600: PUSH
46601: LD_INT 4
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 5
46610: PUSH
46611: LD_INT 5
46613: PUSH
46614: EMPTY
46615: LIST
46616: LIST
46617: PUSH
46618: LD_INT 4
46620: PUSH
46621: LD_INT 5
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: PUSH
46628: LD_INT 3
46630: PUSH
46631: LD_INT 4
46633: PUSH
46634: EMPTY
46635: LIST
46636: LIST
46637: PUSH
46638: LD_INT 3
46640: PUSH
46641: LD_INT 3
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: LD_INT 5
46650: PUSH
46651: LD_INT 3
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: LD_INT 3
46660: PUSH
46661: LD_INT 5
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 0
46670: PUSH
46671: LD_INT 3
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 0
46680: PUSH
46681: LD_INT 2
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 1
46690: PUSH
46691: LD_INT 3
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 1
46700: PUSH
46701: LD_INT 4
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 0
46710: PUSH
46711: LD_INT 4
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: PUSH
46718: LD_INT 1
46720: NEG
46721: PUSH
46722: LD_INT 3
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 1
46731: NEG
46732: PUSH
46733: LD_INT 2
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: PUSH
46743: LD_INT 4
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_INT 2
46752: NEG
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 4
46763: NEG
46764: PUSH
46765: LD_INT 0
46767: PUSH
46768: EMPTY
46769: LIST
46770: LIST
46771: PUSH
46772: LD_INT 4
46774: NEG
46775: PUSH
46776: LD_INT 1
46778: NEG
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: LD_INT 3
46786: NEG
46787: PUSH
46788: LD_INT 0
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: PUSH
46795: LD_INT 3
46797: NEG
46798: PUSH
46799: LD_INT 1
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 4
46808: NEG
46809: PUSH
46810: LD_INT 1
46812: PUSH
46813: EMPTY
46814: LIST
46815: LIST
46816: PUSH
46817: LD_INT 5
46819: NEG
46820: PUSH
46821: LD_INT 0
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PUSH
46828: LD_INT 5
46830: NEG
46831: PUSH
46832: LD_INT 1
46834: NEG
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: PUSH
46840: LD_INT 5
46842: NEG
46843: PUSH
46844: LD_INT 2
46846: NEG
46847: PUSH
46848: EMPTY
46849: LIST
46850: LIST
46851: PUSH
46852: LD_INT 3
46854: NEG
46855: PUSH
46856: LD_INT 2
46858: PUSH
46859: EMPTY
46860: LIST
46861: LIST
46862: PUSH
46863: LD_INT 3
46865: NEG
46866: PUSH
46867: LD_INT 3
46869: NEG
46870: PUSH
46871: EMPTY
46872: LIST
46873: LIST
46874: PUSH
46875: LD_INT 3
46877: NEG
46878: PUSH
46879: LD_INT 4
46881: NEG
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 2
46889: NEG
46890: PUSH
46891: LD_INT 3
46893: NEG
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: PUSH
46899: LD_INT 2
46901: NEG
46902: PUSH
46903: LD_INT 2
46905: NEG
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: PUSH
46911: LD_INT 3
46913: NEG
46914: PUSH
46915: LD_INT 2
46917: NEG
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: PUSH
46923: LD_INT 4
46925: NEG
46926: PUSH
46927: LD_INT 3
46929: NEG
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 4
46937: NEG
46938: PUSH
46939: LD_INT 4
46941: NEG
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: PUSH
46947: LD_INT 2
46949: NEG
46950: PUSH
46951: LD_INT 4
46953: NEG
46954: PUSH
46955: EMPTY
46956: LIST
46957: LIST
46958: PUSH
46959: LD_INT 4
46961: NEG
46962: PUSH
46963: LD_INT 2
46965: NEG
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: LD_INT 0
46973: PUSH
46974: LD_INT 4
46976: NEG
46977: PUSH
46978: EMPTY
46979: LIST
46980: LIST
46981: PUSH
46982: LD_INT 0
46984: PUSH
46985: LD_INT 5
46987: NEG
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: PUSH
46993: LD_INT 1
46995: PUSH
46996: LD_INT 4
46998: NEG
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 1
47006: PUSH
47007: LD_INT 3
47009: NEG
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: LD_INT 0
47017: PUSH
47018: LD_INT 3
47020: NEG
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 1
47028: NEG
47029: PUSH
47030: LD_INT 4
47032: NEG
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: PUSH
47038: LD_INT 1
47040: NEG
47041: PUSH
47042: LD_INT 5
47044: NEG
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: PUSH
47050: LD_INT 2
47052: PUSH
47053: LD_INT 3
47055: NEG
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 2
47063: NEG
47064: PUSH
47065: LD_INT 5
47067: NEG
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47120: LD_ADDR_VAR 0 31
47124: PUSH
47125: LD_INT 0
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 0
47137: PUSH
47138: LD_INT 3
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 1
47147: PUSH
47148: LD_INT 4
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 1
47157: PUSH
47158: LD_INT 5
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 0
47167: PUSH
47168: LD_INT 5
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 1
47177: NEG
47178: PUSH
47179: LD_INT 4
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 1
47188: NEG
47189: PUSH
47190: LD_INT 3
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: LD_INT 5
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 2
47209: NEG
47210: PUSH
47211: LD_INT 3
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 3
47220: NEG
47221: PUSH
47222: LD_INT 0
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: LD_INT 3
47231: NEG
47232: PUSH
47233: LD_INT 1
47235: NEG
47236: PUSH
47237: EMPTY
47238: LIST
47239: LIST
47240: PUSH
47241: LD_INT 2
47243: NEG
47244: PUSH
47245: LD_INT 0
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 2
47254: NEG
47255: PUSH
47256: LD_INT 1
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: LD_INT 3
47265: NEG
47266: PUSH
47267: LD_INT 1
47269: PUSH
47270: EMPTY
47271: LIST
47272: LIST
47273: PUSH
47274: LD_INT 4
47276: NEG
47277: PUSH
47278: LD_INT 0
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: PUSH
47285: LD_INT 4
47287: NEG
47288: PUSH
47289: LD_INT 1
47291: NEG
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: LD_INT 4
47299: NEG
47300: PUSH
47301: LD_INT 2
47303: NEG
47304: PUSH
47305: EMPTY
47306: LIST
47307: LIST
47308: PUSH
47309: LD_INT 2
47311: NEG
47312: PUSH
47313: LD_INT 2
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: LD_INT 4
47322: NEG
47323: PUSH
47324: LD_INT 4
47326: NEG
47327: PUSH
47328: EMPTY
47329: LIST
47330: LIST
47331: PUSH
47332: LD_INT 4
47334: NEG
47335: PUSH
47336: LD_INT 5
47338: NEG
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 3
47346: NEG
47347: PUSH
47348: LD_INT 4
47350: NEG
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: PUSH
47356: LD_INT 3
47358: NEG
47359: PUSH
47360: LD_INT 3
47362: NEG
47363: PUSH
47364: EMPTY
47365: LIST
47366: LIST
47367: PUSH
47368: LD_INT 4
47370: NEG
47371: PUSH
47372: LD_INT 3
47374: NEG
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 5
47382: NEG
47383: PUSH
47384: LD_INT 4
47386: NEG
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 5
47394: NEG
47395: PUSH
47396: LD_INT 5
47398: NEG
47399: PUSH
47400: EMPTY
47401: LIST
47402: LIST
47403: PUSH
47404: LD_INT 3
47406: NEG
47407: PUSH
47408: LD_INT 5
47410: NEG
47411: PUSH
47412: EMPTY
47413: LIST
47414: LIST
47415: PUSH
47416: LD_INT 5
47418: NEG
47419: PUSH
47420: LD_INT 3
47422: NEG
47423: PUSH
47424: EMPTY
47425: LIST
47426: LIST
47427: PUSH
47428: LD_INT 0
47430: PUSH
47431: LD_INT 3
47433: NEG
47434: PUSH
47435: EMPTY
47436: LIST
47437: LIST
47438: PUSH
47439: LD_INT 0
47441: PUSH
47442: LD_INT 4
47444: NEG
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: PUSH
47450: LD_INT 1
47452: PUSH
47453: LD_INT 3
47455: NEG
47456: PUSH
47457: EMPTY
47458: LIST
47459: LIST
47460: PUSH
47461: LD_INT 1
47463: PUSH
47464: LD_INT 2
47466: NEG
47467: PUSH
47468: EMPTY
47469: LIST
47470: LIST
47471: PUSH
47472: LD_INT 0
47474: PUSH
47475: LD_INT 2
47477: NEG
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: PUSH
47483: LD_INT 1
47485: NEG
47486: PUSH
47487: LD_INT 3
47489: NEG
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PUSH
47495: LD_INT 1
47497: NEG
47498: PUSH
47499: LD_INT 4
47501: NEG
47502: PUSH
47503: EMPTY
47504: LIST
47505: LIST
47506: PUSH
47507: LD_INT 2
47509: PUSH
47510: LD_INT 2
47512: NEG
47513: PUSH
47514: EMPTY
47515: LIST
47516: LIST
47517: PUSH
47518: LD_INT 2
47520: NEG
47521: PUSH
47522: LD_INT 4
47524: NEG
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: PUSH
47530: LD_INT 4
47532: PUSH
47533: LD_INT 0
47535: PUSH
47536: EMPTY
47537: LIST
47538: LIST
47539: PUSH
47540: LD_INT 4
47542: PUSH
47543: LD_INT 1
47545: NEG
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: PUSH
47551: LD_INT 5
47553: PUSH
47554: LD_INT 0
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: LD_INT 5
47563: PUSH
47564: LD_INT 1
47566: PUSH
47567: EMPTY
47568: LIST
47569: LIST
47570: PUSH
47571: LD_INT 4
47573: PUSH
47574: LD_INT 1
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 3
47583: PUSH
47584: LD_INT 0
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: LD_INT 3
47593: PUSH
47594: LD_INT 1
47596: NEG
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: PUSH
47602: LD_INT 3
47604: PUSH
47605: LD_INT 2
47607: NEG
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 5
47615: PUSH
47616: LD_INT 2
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
47670: LD_ADDR_VAR 0 32
47674: PUSH
47675: LD_INT 4
47677: NEG
47678: PUSH
47679: LD_INT 0
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: LD_INT 4
47688: NEG
47689: PUSH
47690: LD_INT 1
47692: NEG
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PUSH
47698: LD_INT 3
47700: NEG
47701: PUSH
47702: LD_INT 0
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: PUSH
47709: LD_INT 3
47711: NEG
47712: PUSH
47713: LD_INT 1
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: LD_INT 4
47722: NEG
47723: PUSH
47724: LD_INT 1
47726: PUSH
47727: EMPTY
47728: LIST
47729: LIST
47730: PUSH
47731: LD_INT 5
47733: NEG
47734: PUSH
47735: LD_INT 0
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: LD_INT 5
47744: NEG
47745: PUSH
47746: LD_INT 1
47748: NEG
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PUSH
47754: LD_INT 5
47756: NEG
47757: PUSH
47758: LD_INT 2
47760: NEG
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PUSH
47766: LD_INT 3
47768: NEG
47769: PUSH
47770: LD_INT 2
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: PUSH
47777: LD_INT 3
47779: NEG
47780: PUSH
47781: LD_INT 3
47783: NEG
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PUSH
47789: LD_INT 3
47791: NEG
47792: PUSH
47793: LD_INT 4
47795: NEG
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: PUSH
47801: LD_INT 2
47803: NEG
47804: PUSH
47805: LD_INT 3
47807: NEG
47808: PUSH
47809: EMPTY
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 2
47815: NEG
47816: PUSH
47817: LD_INT 2
47819: NEG
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 3
47827: NEG
47828: PUSH
47829: LD_INT 2
47831: NEG
47832: PUSH
47833: EMPTY
47834: LIST
47835: LIST
47836: PUSH
47837: LD_INT 4
47839: NEG
47840: PUSH
47841: LD_INT 3
47843: NEG
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: PUSH
47849: LD_INT 4
47851: NEG
47852: PUSH
47853: LD_INT 4
47855: NEG
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: PUSH
47861: LD_INT 2
47863: NEG
47864: PUSH
47865: LD_INT 4
47867: NEG
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: LD_INT 4
47875: NEG
47876: PUSH
47877: LD_INT 2
47879: NEG
47880: PUSH
47881: EMPTY
47882: LIST
47883: LIST
47884: PUSH
47885: LD_INT 0
47887: PUSH
47888: LD_INT 4
47890: NEG
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PUSH
47896: LD_INT 0
47898: PUSH
47899: LD_INT 5
47901: NEG
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: PUSH
47907: LD_INT 1
47909: PUSH
47910: LD_INT 4
47912: NEG
47913: PUSH
47914: EMPTY
47915: LIST
47916: LIST
47917: PUSH
47918: LD_INT 1
47920: PUSH
47921: LD_INT 3
47923: NEG
47924: PUSH
47925: EMPTY
47926: LIST
47927: LIST
47928: PUSH
47929: LD_INT 0
47931: PUSH
47932: LD_INT 3
47934: NEG
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: PUSH
47940: LD_INT 1
47942: NEG
47943: PUSH
47944: LD_INT 4
47946: NEG
47947: PUSH
47948: EMPTY
47949: LIST
47950: LIST
47951: PUSH
47952: LD_INT 1
47954: NEG
47955: PUSH
47956: LD_INT 5
47958: NEG
47959: PUSH
47960: EMPTY
47961: LIST
47962: LIST
47963: PUSH
47964: LD_INT 2
47966: PUSH
47967: LD_INT 3
47969: NEG
47970: PUSH
47971: EMPTY
47972: LIST
47973: LIST
47974: PUSH
47975: LD_INT 2
47977: NEG
47978: PUSH
47979: LD_INT 5
47981: NEG
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 3
47989: PUSH
47990: LD_INT 0
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 3
47999: PUSH
48000: LD_INT 1
48002: NEG
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 4
48010: PUSH
48011: LD_INT 0
48013: PUSH
48014: EMPTY
48015: LIST
48016: LIST
48017: PUSH
48018: LD_INT 4
48020: PUSH
48021: LD_INT 1
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: PUSH
48028: LD_INT 3
48030: PUSH
48031: LD_INT 1
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 2
48040: PUSH
48041: LD_INT 0
48043: PUSH
48044: EMPTY
48045: LIST
48046: LIST
48047: PUSH
48048: LD_INT 2
48050: PUSH
48051: LD_INT 1
48053: NEG
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PUSH
48059: LD_INT 2
48061: PUSH
48062: LD_INT 2
48064: NEG
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: LD_INT 4
48072: PUSH
48073: LD_INT 2
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: PUSH
48080: LD_INT 4
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: PUSH
48090: LD_INT 4
48092: PUSH
48093: LD_INT 3
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PUSH
48100: LD_INT 5
48102: PUSH
48103: LD_INT 4
48105: PUSH
48106: EMPTY
48107: LIST
48108: LIST
48109: PUSH
48110: LD_INT 5
48112: PUSH
48113: LD_INT 5
48115: PUSH
48116: EMPTY
48117: LIST
48118: LIST
48119: PUSH
48120: LD_INT 4
48122: PUSH
48123: LD_INT 5
48125: PUSH
48126: EMPTY
48127: LIST
48128: LIST
48129: PUSH
48130: LD_INT 3
48132: PUSH
48133: LD_INT 4
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: PUSH
48140: LD_INT 3
48142: PUSH
48143: LD_INT 3
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: PUSH
48150: LD_INT 5
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: PUSH
48160: LD_INT 3
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48217: LD_ADDR_VAR 0 33
48221: PUSH
48222: LD_INT 4
48224: NEG
48225: PUSH
48226: LD_INT 4
48228: NEG
48229: PUSH
48230: EMPTY
48231: LIST
48232: LIST
48233: PUSH
48234: LD_INT 4
48236: NEG
48237: PUSH
48238: LD_INT 5
48240: NEG
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_INT 3
48248: NEG
48249: PUSH
48250: LD_INT 4
48252: NEG
48253: PUSH
48254: EMPTY
48255: LIST
48256: LIST
48257: PUSH
48258: LD_INT 3
48260: NEG
48261: PUSH
48262: LD_INT 3
48264: NEG
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: PUSH
48270: LD_INT 4
48272: NEG
48273: PUSH
48274: LD_INT 3
48276: NEG
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: PUSH
48282: LD_INT 5
48284: NEG
48285: PUSH
48286: LD_INT 4
48288: NEG
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: PUSH
48294: LD_INT 5
48296: NEG
48297: PUSH
48298: LD_INT 5
48300: NEG
48301: PUSH
48302: EMPTY
48303: LIST
48304: LIST
48305: PUSH
48306: LD_INT 3
48308: NEG
48309: PUSH
48310: LD_INT 5
48312: NEG
48313: PUSH
48314: EMPTY
48315: LIST
48316: LIST
48317: PUSH
48318: LD_INT 5
48320: NEG
48321: PUSH
48322: LD_INT 3
48324: NEG
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: PUSH
48330: LD_INT 0
48332: PUSH
48333: LD_INT 3
48335: NEG
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 0
48343: PUSH
48344: LD_INT 4
48346: NEG
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: LD_INT 1
48354: PUSH
48355: LD_INT 3
48357: NEG
48358: PUSH
48359: EMPTY
48360: LIST
48361: LIST
48362: PUSH
48363: LD_INT 1
48365: PUSH
48366: LD_INT 2
48368: NEG
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: PUSH
48374: LD_INT 0
48376: PUSH
48377: LD_INT 2
48379: NEG
48380: PUSH
48381: EMPTY
48382: LIST
48383: LIST
48384: PUSH
48385: LD_INT 1
48387: NEG
48388: PUSH
48389: LD_INT 3
48391: NEG
48392: PUSH
48393: EMPTY
48394: LIST
48395: LIST
48396: PUSH
48397: LD_INT 1
48399: NEG
48400: PUSH
48401: LD_INT 4
48403: NEG
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: PUSH
48409: LD_INT 2
48411: PUSH
48412: LD_INT 2
48414: NEG
48415: PUSH
48416: EMPTY
48417: LIST
48418: LIST
48419: PUSH
48420: LD_INT 2
48422: NEG
48423: PUSH
48424: LD_INT 4
48426: NEG
48427: PUSH
48428: EMPTY
48429: LIST
48430: LIST
48431: PUSH
48432: LD_INT 4
48434: PUSH
48435: LD_INT 0
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 4
48444: PUSH
48445: LD_INT 1
48447: NEG
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 5
48455: PUSH
48456: LD_INT 0
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 5
48465: PUSH
48466: LD_INT 1
48468: PUSH
48469: EMPTY
48470: LIST
48471: LIST
48472: PUSH
48473: LD_INT 4
48475: PUSH
48476: LD_INT 1
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 3
48485: PUSH
48486: LD_INT 0
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: PUSH
48493: LD_INT 3
48495: PUSH
48496: LD_INT 1
48498: NEG
48499: PUSH
48500: EMPTY
48501: LIST
48502: LIST
48503: PUSH
48504: LD_INT 3
48506: PUSH
48507: LD_INT 2
48509: NEG
48510: PUSH
48511: EMPTY
48512: LIST
48513: LIST
48514: PUSH
48515: LD_INT 5
48517: PUSH
48518: LD_INT 2
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: PUSH
48525: LD_INT 3
48527: PUSH
48528: LD_INT 3
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: PUSH
48535: LD_INT 3
48537: PUSH
48538: LD_INT 2
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 4
48547: PUSH
48548: LD_INT 3
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PUSH
48555: LD_INT 4
48557: PUSH
48558: LD_INT 4
48560: PUSH
48561: EMPTY
48562: LIST
48563: LIST
48564: PUSH
48565: LD_INT 3
48567: PUSH
48568: LD_INT 4
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 2
48577: PUSH
48578: LD_INT 3
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PUSH
48585: LD_INT 2
48587: PUSH
48588: LD_INT 2
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: PUSH
48595: LD_INT 4
48597: PUSH
48598: LD_INT 2
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: PUSH
48605: LD_INT 2
48607: PUSH
48608: LD_INT 4
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PUSH
48615: LD_INT 0
48617: PUSH
48618: LD_INT 4
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: PUSH
48625: LD_INT 0
48627: PUSH
48628: LD_INT 3
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: PUSH
48635: LD_INT 1
48637: PUSH
48638: LD_INT 4
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PUSH
48645: LD_INT 1
48647: PUSH
48648: LD_INT 5
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: LD_INT 0
48657: PUSH
48658: LD_INT 5
48660: PUSH
48661: EMPTY
48662: LIST
48663: LIST
48664: PUSH
48665: LD_INT 1
48667: NEG
48668: PUSH
48669: LD_INT 4
48671: PUSH
48672: EMPTY
48673: LIST
48674: LIST
48675: PUSH
48676: LD_INT 1
48678: NEG
48679: PUSH
48680: LD_INT 3
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 2
48689: PUSH
48690: LD_INT 5
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: LD_INT 2
48699: NEG
48700: PUSH
48701: LD_INT 3
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: LIST
48712: LIST
48713: LIST
48714: LIST
48715: LIST
48716: LIST
48717: LIST
48718: LIST
48719: LIST
48720: LIST
48721: LIST
48722: LIST
48723: LIST
48724: LIST
48725: LIST
48726: LIST
48727: LIST
48728: LIST
48729: LIST
48730: LIST
48731: LIST
48732: LIST
48733: LIST
48734: LIST
48735: LIST
48736: LIST
48737: LIST
48738: LIST
48739: LIST
48740: LIST
48741: LIST
48742: LIST
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
48755: LD_ADDR_VAR 0 34
48759: PUSH
48760: LD_INT 0
48762: PUSH
48763: LD_INT 4
48765: NEG
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: PUSH
48771: LD_INT 0
48773: PUSH
48774: LD_INT 5
48776: NEG
48777: PUSH
48778: EMPTY
48779: LIST
48780: LIST
48781: PUSH
48782: LD_INT 1
48784: PUSH
48785: LD_INT 4
48787: NEG
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PUSH
48793: LD_INT 1
48795: PUSH
48796: LD_INT 3
48798: NEG
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: PUSH
48804: LD_INT 0
48806: PUSH
48807: LD_INT 3
48809: NEG
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PUSH
48815: LD_INT 1
48817: NEG
48818: PUSH
48819: LD_INT 4
48821: NEG
48822: PUSH
48823: EMPTY
48824: LIST
48825: LIST
48826: PUSH
48827: LD_INT 1
48829: NEG
48830: PUSH
48831: LD_INT 5
48833: NEG
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: PUSH
48839: LD_INT 2
48841: PUSH
48842: LD_INT 3
48844: NEG
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: PUSH
48850: LD_INT 2
48852: NEG
48853: PUSH
48854: LD_INT 5
48856: NEG
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 3
48864: PUSH
48865: LD_INT 0
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: LD_INT 3
48874: PUSH
48875: LD_INT 1
48877: NEG
48878: PUSH
48879: EMPTY
48880: LIST
48881: LIST
48882: PUSH
48883: LD_INT 4
48885: PUSH
48886: LD_INT 0
48888: PUSH
48889: EMPTY
48890: LIST
48891: LIST
48892: PUSH
48893: LD_INT 4
48895: PUSH
48896: LD_INT 1
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: PUSH
48903: LD_INT 3
48905: PUSH
48906: LD_INT 1
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: PUSH
48913: LD_INT 2
48915: PUSH
48916: LD_INT 0
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: PUSH
48923: LD_INT 2
48925: PUSH
48926: LD_INT 1
48928: NEG
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 2
48936: PUSH
48937: LD_INT 2
48939: NEG
48940: PUSH
48941: EMPTY
48942: LIST
48943: LIST
48944: PUSH
48945: LD_INT 4
48947: PUSH
48948: LD_INT 2
48950: PUSH
48951: EMPTY
48952: LIST
48953: LIST
48954: PUSH
48955: LD_INT 4
48957: PUSH
48958: LD_INT 4
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: PUSH
48965: LD_INT 4
48967: PUSH
48968: LD_INT 3
48970: PUSH
48971: EMPTY
48972: LIST
48973: LIST
48974: PUSH
48975: LD_INT 5
48977: PUSH
48978: LD_INT 4
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PUSH
48985: LD_INT 5
48987: PUSH
48988: LD_INT 5
48990: PUSH
48991: EMPTY
48992: LIST
48993: LIST
48994: PUSH
48995: LD_INT 4
48997: PUSH
48998: LD_INT 5
49000: PUSH
49001: EMPTY
49002: LIST
49003: LIST
49004: PUSH
49005: LD_INT 3
49007: PUSH
49008: LD_INT 4
49010: PUSH
49011: EMPTY
49012: LIST
49013: LIST
49014: PUSH
49015: LD_INT 3
49017: PUSH
49018: LD_INT 3
49020: PUSH
49021: EMPTY
49022: LIST
49023: LIST
49024: PUSH
49025: LD_INT 5
49027: PUSH
49028: LD_INT 3
49030: PUSH
49031: EMPTY
49032: LIST
49033: LIST
49034: PUSH
49035: LD_INT 3
49037: PUSH
49038: LD_INT 5
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 0
49047: PUSH
49048: LD_INT 3
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: PUSH
49055: LD_INT 0
49057: PUSH
49058: LD_INT 2
49060: PUSH
49061: EMPTY
49062: LIST
49063: LIST
49064: PUSH
49065: LD_INT 1
49067: PUSH
49068: LD_INT 3
49070: PUSH
49071: EMPTY
49072: LIST
49073: LIST
49074: PUSH
49075: LD_INT 1
49077: PUSH
49078: LD_INT 4
49080: PUSH
49081: EMPTY
49082: LIST
49083: LIST
49084: PUSH
49085: LD_INT 0
49087: PUSH
49088: LD_INT 4
49090: PUSH
49091: EMPTY
49092: LIST
49093: LIST
49094: PUSH
49095: LD_INT 1
49097: NEG
49098: PUSH
49099: LD_INT 3
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: PUSH
49106: LD_INT 1
49108: NEG
49109: PUSH
49110: LD_INT 2
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 2
49119: PUSH
49120: LD_INT 4
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 2
49129: NEG
49130: PUSH
49131: LD_INT 2
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: PUSH
49138: LD_INT 4
49140: NEG
49141: PUSH
49142: LD_INT 0
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PUSH
49149: LD_INT 4
49151: NEG
49152: PUSH
49153: LD_INT 1
49155: NEG
49156: PUSH
49157: EMPTY
49158: LIST
49159: LIST
49160: PUSH
49161: LD_INT 3
49163: NEG
49164: PUSH
49165: LD_INT 0
49167: PUSH
49168: EMPTY
49169: LIST
49170: LIST
49171: PUSH
49172: LD_INT 3
49174: NEG
49175: PUSH
49176: LD_INT 1
49178: PUSH
49179: EMPTY
49180: LIST
49181: LIST
49182: PUSH
49183: LD_INT 4
49185: NEG
49186: PUSH
49187: LD_INT 1
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: PUSH
49194: LD_INT 5
49196: NEG
49197: PUSH
49198: LD_INT 0
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: PUSH
49205: LD_INT 5
49207: NEG
49208: PUSH
49209: LD_INT 1
49211: NEG
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PUSH
49217: LD_INT 5
49219: NEG
49220: PUSH
49221: LD_INT 2
49223: NEG
49224: PUSH
49225: EMPTY
49226: LIST
49227: LIST
49228: PUSH
49229: LD_INT 3
49231: NEG
49232: PUSH
49233: LD_INT 2
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: LIST
49244: LIST
49245: LIST
49246: LIST
49247: LIST
49248: LIST
49249: LIST
49250: LIST
49251: LIST
49252: LIST
49253: LIST
49254: LIST
49255: LIST
49256: LIST
49257: LIST
49258: LIST
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: LIST
49264: LIST
49265: LIST
49266: LIST
49267: LIST
49268: LIST
49269: LIST
49270: LIST
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: LIST
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: ST_TO_ADDR
// end ; end ;
49287: GO 49290
49289: POP
// case btype of b_depot , b_warehouse :
49290: LD_VAR 0 1
49294: PUSH
49295: LD_INT 0
49297: DOUBLE
49298: EQUAL
49299: IFTRUE 49309
49301: LD_INT 1
49303: DOUBLE
49304: EQUAL
49305: IFTRUE 49309
49307: GO 49510
49309: POP
// case nation of nation_american :
49310: LD_VAR 0 5
49314: PUSH
49315: LD_INT 1
49317: DOUBLE
49318: EQUAL
49319: IFTRUE 49323
49321: GO 49379
49323: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49324: LD_ADDR_VAR 0 9
49328: PUSH
49329: LD_VAR 0 11
49333: PUSH
49334: LD_VAR 0 12
49338: PUSH
49339: LD_VAR 0 13
49343: PUSH
49344: LD_VAR 0 14
49348: PUSH
49349: LD_VAR 0 15
49353: PUSH
49354: LD_VAR 0 16
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: PUSH
49367: LD_VAR 0 4
49371: PUSH
49372: LD_INT 1
49374: PLUS
49375: ARRAY
49376: ST_TO_ADDR
49377: GO 49508
49379: LD_INT 2
49381: DOUBLE
49382: EQUAL
49383: IFTRUE 49387
49385: GO 49443
49387: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49388: LD_ADDR_VAR 0 9
49392: PUSH
49393: LD_VAR 0 17
49397: PUSH
49398: LD_VAR 0 18
49402: PUSH
49403: LD_VAR 0 19
49407: PUSH
49408: LD_VAR 0 20
49412: PUSH
49413: LD_VAR 0 21
49417: PUSH
49418: LD_VAR 0 22
49422: PUSH
49423: EMPTY
49424: LIST
49425: LIST
49426: LIST
49427: LIST
49428: LIST
49429: LIST
49430: PUSH
49431: LD_VAR 0 4
49435: PUSH
49436: LD_INT 1
49438: PLUS
49439: ARRAY
49440: ST_TO_ADDR
49441: GO 49508
49443: LD_INT 3
49445: DOUBLE
49446: EQUAL
49447: IFTRUE 49451
49449: GO 49507
49451: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49452: LD_ADDR_VAR 0 9
49456: PUSH
49457: LD_VAR 0 23
49461: PUSH
49462: LD_VAR 0 24
49466: PUSH
49467: LD_VAR 0 25
49471: PUSH
49472: LD_VAR 0 26
49476: PUSH
49477: LD_VAR 0 27
49481: PUSH
49482: LD_VAR 0 28
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: PUSH
49495: LD_VAR 0 4
49499: PUSH
49500: LD_INT 1
49502: PLUS
49503: ARRAY
49504: ST_TO_ADDR
49505: GO 49508
49507: POP
49508: GO 50063
49510: LD_INT 2
49512: DOUBLE
49513: EQUAL
49514: IFTRUE 49524
49516: LD_INT 3
49518: DOUBLE
49519: EQUAL
49520: IFTRUE 49524
49522: GO 49580
49524: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49525: LD_ADDR_VAR 0 9
49529: PUSH
49530: LD_VAR 0 29
49534: PUSH
49535: LD_VAR 0 30
49539: PUSH
49540: LD_VAR 0 31
49544: PUSH
49545: LD_VAR 0 32
49549: PUSH
49550: LD_VAR 0 33
49554: PUSH
49555: LD_VAR 0 34
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: LIST
49564: LIST
49565: LIST
49566: LIST
49567: PUSH
49568: LD_VAR 0 4
49572: PUSH
49573: LD_INT 1
49575: PLUS
49576: ARRAY
49577: ST_TO_ADDR
49578: GO 50063
49580: LD_INT 16
49582: DOUBLE
49583: EQUAL
49584: IFTRUE 49642
49586: LD_INT 17
49588: DOUBLE
49589: EQUAL
49590: IFTRUE 49642
49592: LD_INT 18
49594: DOUBLE
49595: EQUAL
49596: IFTRUE 49642
49598: LD_INT 19
49600: DOUBLE
49601: EQUAL
49602: IFTRUE 49642
49604: LD_INT 22
49606: DOUBLE
49607: EQUAL
49608: IFTRUE 49642
49610: LD_INT 20
49612: DOUBLE
49613: EQUAL
49614: IFTRUE 49642
49616: LD_INT 21
49618: DOUBLE
49619: EQUAL
49620: IFTRUE 49642
49622: LD_INT 23
49624: DOUBLE
49625: EQUAL
49626: IFTRUE 49642
49628: LD_INT 24
49630: DOUBLE
49631: EQUAL
49632: IFTRUE 49642
49634: LD_INT 25
49636: DOUBLE
49637: EQUAL
49638: IFTRUE 49642
49640: GO 49698
49642: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
49643: LD_ADDR_VAR 0 9
49647: PUSH
49648: LD_VAR 0 35
49652: PUSH
49653: LD_VAR 0 36
49657: PUSH
49658: LD_VAR 0 37
49662: PUSH
49663: LD_VAR 0 38
49667: PUSH
49668: LD_VAR 0 39
49672: PUSH
49673: LD_VAR 0 40
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: PUSH
49686: LD_VAR 0 4
49690: PUSH
49691: LD_INT 1
49693: PLUS
49694: ARRAY
49695: ST_TO_ADDR
49696: GO 50063
49698: LD_INT 6
49700: DOUBLE
49701: EQUAL
49702: IFTRUE 49754
49704: LD_INT 7
49706: DOUBLE
49707: EQUAL
49708: IFTRUE 49754
49710: LD_INT 8
49712: DOUBLE
49713: EQUAL
49714: IFTRUE 49754
49716: LD_INT 13
49718: DOUBLE
49719: EQUAL
49720: IFTRUE 49754
49722: LD_INT 12
49724: DOUBLE
49725: EQUAL
49726: IFTRUE 49754
49728: LD_INT 15
49730: DOUBLE
49731: EQUAL
49732: IFTRUE 49754
49734: LD_INT 11
49736: DOUBLE
49737: EQUAL
49738: IFTRUE 49754
49740: LD_INT 14
49742: DOUBLE
49743: EQUAL
49744: IFTRUE 49754
49746: LD_INT 10
49748: DOUBLE
49749: EQUAL
49750: IFTRUE 49754
49752: GO 49810
49754: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
49755: LD_ADDR_VAR 0 9
49759: PUSH
49760: LD_VAR 0 41
49764: PUSH
49765: LD_VAR 0 42
49769: PUSH
49770: LD_VAR 0 43
49774: PUSH
49775: LD_VAR 0 44
49779: PUSH
49780: LD_VAR 0 45
49784: PUSH
49785: LD_VAR 0 46
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: PUSH
49798: LD_VAR 0 4
49802: PUSH
49803: LD_INT 1
49805: PLUS
49806: ARRAY
49807: ST_TO_ADDR
49808: GO 50063
49810: LD_INT 36
49812: DOUBLE
49813: EQUAL
49814: IFTRUE 49818
49816: GO 49874
49818: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
49819: LD_ADDR_VAR 0 9
49823: PUSH
49824: LD_VAR 0 47
49828: PUSH
49829: LD_VAR 0 48
49833: PUSH
49834: LD_VAR 0 49
49838: PUSH
49839: LD_VAR 0 50
49843: PUSH
49844: LD_VAR 0 51
49848: PUSH
49849: LD_VAR 0 52
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: PUSH
49862: LD_VAR 0 4
49866: PUSH
49867: LD_INT 1
49869: PLUS
49870: ARRAY
49871: ST_TO_ADDR
49872: GO 50063
49874: LD_INT 4
49876: DOUBLE
49877: EQUAL
49878: IFTRUE 49900
49880: LD_INT 5
49882: DOUBLE
49883: EQUAL
49884: IFTRUE 49900
49886: LD_INT 34
49888: DOUBLE
49889: EQUAL
49890: IFTRUE 49900
49892: LD_INT 37
49894: DOUBLE
49895: EQUAL
49896: IFTRUE 49900
49898: GO 49956
49900: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49901: LD_ADDR_VAR 0 9
49905: PUSH
49906: LD_VAR 0 53
49910: PUSH
49911: LD_VAR 0 54
49915: PUSH
49916: LD_VAR 0 55
49920: PUSH
49921: LD_VAR 0 56
49925: PUSH
49926: LD_VAR 0 57
49930: PUSH
49931: LD_VAR 0 58
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: LIST
49940: LIST
49941: LIST
49942: LIST
49943: PUSH
49944: LD_VAR 0 4
49948: PUSH
49949: LD_INT 1
49951: PLUS
49952: ARRAY
49953: ST_TO_ADDR
49954: GO 50063
49956: LD_INT 31
49958: DOUBLE
49959: EQUAL
49960: IFTRUE 50006
49962: LD_INT 32
49964: DOUBLE
49965: EQUAL
49966: IFTRUE 50006
49968: LD_INT 33
49970: DOUBLE
49971: EQUAL
49972: IFTRUE 50006
49974: LD_INT 27
49976: DOUBLE
49977: EQUAL
49978: IFTRUE 50006
49980: LD_INT 26
49982: DOUBLE
49983: EQUAL
49984: IFTRUE 50006
49986: LD_INT 28
49988: DOUBLE
49989: EQUAL
49990: IFTRUE 50006
49992: LD_INT 29
49994: DOUBLE
49995: EQUAL
49996: IFTRUE 50006
49998: LD_INT 30
50000: DOUBLE
50001: EQUAL
50002: IFTRUE 50006
50004: GO 50062
50006: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50007: LD_ADDR_VAR 0 9
50011: PUSH
50012: LD_VAR 0 59
50016: PUSH
50017: LD_VAR 0 60
50021: PUSH
50022: LD_VAR 0 61
50026: PUSH
50027: LD_VAR 0 62
50031: PUSH
50032: LD_VAR 0 63
50036: PUSH
50037: LD_VAR 0 64
50041: PUSH
50042: EMPTY
50043: LIST
50044: LIST
50045: LIST
50046: LIST
50047: LIST
50048: LIST
50049: PUSH
50050: LD_VAR 0 4
50054: PUSH
50055: LD_INT 1
50057: PLUS
50058: ARRAY
50059: ST_TO_ADDR
50060: GO 50063
50062: POP
// temp_list2 = [ ] ;
50063: LD_ADDR_VAR 0 10
50067: PUSH
50068: EMPTY
50069: ST_TO_ADDR
// for i in temp_list do
50070: LD_ADDR_VAR 0 8
50074: PUSH
50075: LD_VAR 0 9
50079: PUSH
50080: FOR_IN
50081: IFFALSE 50133
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50083: LD_ADDR_VAR 0 10
50087: PUSH
50088: LD_VAR 0 10
50092: PUSH
50093: LD_VAR 0 8
50097: PUSH
50098: LD_INT 1
50100: ARRAY
50101: PUSH
50102: LD_VAR 0 2
50106: PLUS
50107: PUSH
50108: LD_VAR 0 8
50112: PUSH
50113: LD_INT 2
50115: ARRAY
50116: PUSH
50117: LD_VAR 0 3
50121: PLUS
50122: PUSH
50123: EMPTY
50124: LIST
50125: LIST
50126: PUSH
50127: EMPTY
50128: LIST
50129: ADD
50130: ST_TO_ADDR
50131: GO 50080
50133: POP
50134: POP
// result = temp_list2 ;
50135: LD_ADDR_VAR 0 7
50139: PUSH
50140: LD_VAR 0 10
50144: ST_TO_ADDR
// end ;
50145: LD_VAR 0 7
50149: RET
// export function EnemyInRange ( unit , dist ) ; begin
50150: LD_INT 0
50152: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50153: LD_ADDR_VAR 0 3
50157: PUSH
50158: LD_VAR 0 1
50162: PPUSH
50163: CALL_OW 255
50167: PPUSH
50168: LD_VAR 0 1
50172: PPUSH
50173: CALL_OW 250
50177: PPUSH
50178: LD_VAR 0 1
50182: PPUSH
50183: CALL_OW 251
50187: PPUSH
50188: LD_VAR 0 2
50192: PPUSH
50193: CALL 23523 0 4
50197: PUSH
50198: LD_INT 4
50200: ARRAY
50201: ST_TO_ADDR
// end ;
50202: LD_VAR 0 3
50206: RET
// export function PlayerSeeMe ( unit ) ; begin
50207: LD_INT 0
50209: PPUSH
// result := See ( your_side , unit ) ;
50210: LD_ADDR_VAR 0 2
50214: PUSH
50215: LD_OWVAR 2
50219: PPUSH
50220: LD_VAR 0 1
50224: PPUSH
50225: CALL_OW 292
50229: ST_TO_ADDR
// end ;
50230: LD_VAR 0 2
50234: RET
// export function ReverseDir ( unit ) ; begin
50235: LD_INT 0
50237: PPUSH
// if not unit then
50238: LD_VAR 0 1
50242: NOT
50243: IFFALSE 50247
// exit ;
50245: GO 50270
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50247: LD_ADDR_VAR 0 2
50251: PUSH
50252: LD_VAR 0 1
50256: PPUSH
50257: CALL_OW 254
50261: PUSH
50262: LD_INT 3
50264: PLUS
50265: PUSH
50266: LD_INT 6
50268: MOD
50269: ST_TO_ADDR
// end ;
50270: LD_VAR 0 2
50274: RET
// export function ReverseArray ( array ) ; var i ; begin
50275: LD_INT 0
50277: PPUSH
50278: PPUSH
// if not array then
50279: LD_VAR 0 1
50283: NOT
50284: IFFALSE 50288
// exit ;
50286: GO 50343
// result := [ ] ;
50288: LD_ADDR_VAR 0 2
50292: PUSH
50293: EMPTY
50294: ST_TO_ADDR
// for i := array downto 1 do
50295: LD_ADDR_VAR 0 3
50299: PUSH
50300: DOUBLE
50301: LD_VAR 0 1
50305: INC
50306: ST_TO_ADDR
50307: LD_INT 1
50309: PUSH
50310: FOR_DOWNTO
50311: IFFALSE 50341
// result := Join ( result , array [ i ] ) ;
50313: LD_ADDR_VAR 0 2
50317: PUSH
50318: LD_VAR 0 2
50322: PPUSH
50323: LD_VAR 0 1
50327: PUSH
50328: LD_VAR 0 3
50332: ARRAY
50333: PPUSH
50334: CALL 55008 0 2
50338: ST_TO_ADDR
50339: GO 50310
50341: POP
50342: POP
// end ;
50343: LD_VAR 0 2
50347: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50348: LD_INT 0
50350: PPUSH
50351: PPUSH
50352: PPUSH
50353: PPUSH
50354: PPUSH
50355: PPUSH
// if not unit or not hexes then
50356: LD_VAR 0 1
50360: NOT
50361: PUSH
50362: LD_VAR 0 2
50366: NOT
50367: OR
50368: IFFALSE 50372
// exit ;
50370: GO 50495
// dist := 9999 ;
50372: LD_ADDR_VAR 0 5
50376: PUSH
50377: LD_INT 9999
50379: ST_TO_ADDR
// for i = 1 to hexes do
50380: LD_ADDR_VAR 0 4
50384: PUSH
50385: DOUBLE
50386: LD_INT 1
50388: DEC
50389: ST_TO_ADDR
50390: LD_VAR 0 2
50394: PUSH
50395: FOR_TO
50396: IFFALSE 50483
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50398: LD_ADDR_VAR 0 6
50402: PUSH
50403: LD_VAR 0 1
50407: PPUSH
50408: LD_VAR 0 2
50412: PUSH
50413: LD_VAR 0 4
50417: ARRAY
50418: PUSH
50419: LD_INT 1
50421: ARRAY
50422: PPUSH
50423: LD_VAR 0 2
50427: PUSH
50428: LD_VAR 0 4
50432: ARRAY
50433: PUSH
50434: LD_INT 2
50436: ARRAY
50437: PPUSH
50438: CALL_OW 297
50442: ST_TO_ADDR
// if tdist < dist then
50443: LD_VAR 0 6
50447: PUSH
50448: LD_VAR 0 5
50452: LESS
50453: IFFALSE 50481
// begin hex := hexes [ i ] ;
50455: LD_ADDR_VAR 0 8
50459: PUSH
50460: LD_VAR 0 2
50464: PUSH
50465: LD_VAR 0 4
50469: ARRAY
50470: ST_TO_ADDR
// dist := tdist ;
50471: LD_ADDR_VAR 0 5
50475: PUSH
50476: LD_VAR 0 6
50480: ST_TO_ADDR
// end ; end ;
50481: GO 50395
50483: POP
50484: POP
// result := hex ;
50485: LD_ADDR_VAR 0 3
50489: PUSH
50490: LD_VAR 0 8
50494: ST_TO_ADDR
// end ;
50495: LD_VAR 0 3
50499: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50500: LD_INT 0
50502: PPUSH
50503: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50504: LD_VAR 0 1
50508: NOT
50509: PUSH
50510: LD_VAR 0 1
50514: PUSH
50515: LD_INT 21
50517: PUSH
50518: LD_INT 2
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PUSH
50525: LD_INT 23
50527: PUSH
50528: LD_INT 2
50530: PUSH
50531: EMPTY
50532: LIST
50533: LIST
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PPUSH
50539: CALL_OW 69
50543: IN
50544: NOT
50545: OR
50546: IFFALSE 50550
// exit ;
50548: GO 50597
// for i = 1 to 3 do
50550: LD_ADDR_VAR 0 3
50554: PUSH
50555: DOUBLE
50556: LD_INT 1
50558: DEC
50559: ST_TO_ADDR
50560: LD_INT 3
50562: PUSH
50563: FOR_TO
50564: IFFALSE 50595
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50566: LD_VAR 0 1
50570: PPUSH
50571: CALL_OW 250
50575: PPUSH
50576: LD_VAR 0 1
50580: PPUSH
50581: CALL_OW 251
50585: PPUSH
50586: LD_INT 1
50588: PPUSH
50589: CALL_OW 453
50593: GO 50563
50595: POP
50596: POP
// end ;
50597: LD_VAR 0 2
50601: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
50602: LD_INT 0
50604: PPUSH
50605: PPUSH
50606: PPUSH
50607: PPUSH
50608: PPUSH
50609: PPUSH
// if not unit or not enemy_unit then
50610: LD_VAR 0 1
50614: NOT
50615: PUSH
50616: LD_VAR 0 2
50620: NOT
50621: OR
50622: IFFALSE 50626
// exit ;
50624: GO 51093
// if GetLives ( i ) < 250 then
50626: LD_VAR 0 4
50630: PPUSH
50631: CALL_OW 256
50635: PUSH
50636: LD_INT 250
50638: LESS
50639: IFFALSE 50652
// begin ComAutodestruct ( i ) ;
50641: LD_VAR 0 4
50645: PPUSH
50646: CALL 50500 0 1
// exit ;
50650: GO 51093
// end ; x := GetX ( enemy_unit ) ;
50652: LD_ADDR_VAR 0 7
50656: PUSH
50657: LD_VAR 0 2
50661: PPUSH
50662: CALL_OW 250
50666: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
50667: LD_ADDR_VAR 0 8
50671: PUSH
50672: LD_VAR 0 2
50676: PPUSH
50677: CALL_OW 251
50681: ST_TO_ADDR
// if not x or not y then
50682: LD_VAR 0 7
50686: NOT
50687: PUSH
50688: LD_VAR 0 8
50692: NOT
50693: OR
50694: IFFALSE 50698
// exit ;
50696: GO 51093
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
50698: LD_ADDR_VAR 0 6
50702: PUSH
50703: LD_VAR 0 7
50707: PPUSH
50708: LD_INT 0
50710: PPUSH
50711: LD_INT 4
50713: PPUSH
50714: CALL_OW 272
50718: PUSH
50719: LD_VAR 0 8
50723: PPUSH
50724: LD_INT 0
50726: PPUSH
50727: LD_INT 4
50729: PPUSH
50730: CALL_OW 273
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_VAR 0 7
50743: PPUSH
50744: LD_INT 1
50746: PPUSH
50747: LD_INT 4
50749: PPUSH
50750: CALL_OW 272
50754: PUSH
50755: LD_VAR 0 8
50759: PPUSH
50760: LD_INT 1
50762: PPUSH
50763: LD_INT 4
50765: PPUSH
50766: CALL_OW 273
50770: PUSH
50771: EMPTY
50772: LIST
50773: LIST
50774: PUSH
50775: LD_VAR 0 7
50779: PPUSH
50780: LD_INT 2
50782: PPUSH
50783: LD_INT 4
50785: PPUSH
50786: CALL_OW 272
50790: PUSH
50791: LD_VAR 0 8
50795: PPUSH
50796: LD_INT 2
50798: PPUSH
50799: LD_INT 4
50801: PPUSH
50802: CALL_OW 273
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PUSH
50811: LD_VAR 0 7
50815: PPUSH
50816: LD_INT 3
50818: PPUSH
50819: LD_INT 4
50821: PPUSH
50822: CALL_OW 272
50826: PUSH
50827: LD_VAR 0 8
50831: PPUSH
50832: LD_INT 3
50834: PPUSH
50835: LD_INT 4
50837: PPUSH
50838: CALL_OW 273
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: PUSH
50847: LD_VAR 0 7
50851: PPUSH
50852: LD_INT 4
50854: PPUSH
50855: LD_INT 4
50857: PPUSH
50858: CALL_OW 272
50862: PUSH
50863: LD_VAR 0 8
50867: PPUSH
50868: LD_INT 4
50870: PPUSH
50871: LD_INT 4
50873: PPUSH
50874: CALL_OW 273
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: PUSH
50883: LD_VAR 0 7
50887: PPUSH
50888: LD_INT 5
50890: PPUSH
50891: LD_INT 4
50893: PPUSH
50894: CALL_OW 272
50898: PUSH
50899: LD_VAR 0 8
50903: PPUSH
50904: LD_INT 5
50906: PPUSH
50907: LD_INT 4
50909: PPUSH
50910: CALL_OW 273
50914: PUSH
50915: EMPTY
50916: LIST
50917: LIST
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: ST_TO_ADDR
// for i = tmp downto 1 do
50927: LD_ADDR_VAR 0 4
50931: PUSH
50932: DOUBLE
50933: LD_VAR 0 6
50937: INC
50938: ST_TO_ADDR
50939: LD_INT 1
50941: PUSH
50942: FOR_DOWNTO
50943: IFFALSE 51044
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50945: LD_VAR 0 6
50949: PUSH
50950: LD_VAR 0 4
50954: ARRAY
50955: PUSH
50956: LD_INT 1
50958: ARRAY
50959: PPUSH
50960: LD_VAR 0 6
50964: PUSH
50965: LD_VAR 0 4
50969: ARRAY
50970: PUSH
50971: LD_INT 2
50973: ARRAY
50974: PPUSH
50975: CALL_OW 488
50979: NOT
50980: PUSH
50981: LD_VAR 0 6
50985: PUSH
50986: LD_VAR 0 4
50990: ARRAY
50991: PUSH
50992: LD_INT 1
50994: ARRAY
50995: PPUSH
50996: LD_VAR 0 6
51000: PUSH
51001: LD_VAR 0 4
51005: ARRAY
51006: PUSH
51007: LD_INT 2
51009: ARRAY
51010: PPUSH
51011: CALL_OW 428
51015: PUSH
51016: LD_INT 0
51018: NONEQUAL
51019: OR
51020: IFFALSE 51042
// tmp := Delete ( tmp , i ) ;
51022: LD_ADDR_VAR 0 6
51026: PUSH
51027: LD_VAR 0 6
51031: PPUSH
51032: LD_VAR 0 4
51036: PPUSH
51037: CALL_OW 3
51041: ST_TO_ADDR
51042: GO 50942
51044: POP
51045: POP
// j := GetClosestHex ( unit , tmp ) ;
51046: LD_ADDR_VAR 0 5
51050: PUSH
51051: LD_VAR 0 1
51055: PPUSH
51056: LD_VAR 0 6
51060: PPUSH
51061: CALL 50348 0 2
51065: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51066: LD_VAR 0 1
51070: PPUSH
51071: LD_VAR 0 5
51075: PUSH
51076: LD_INT 1
51078: ARRAY
51079: PPUSH
51080: LD_VAR 0 5
51084: PUSH
51085: LD_INT 2
51087: ARRAY
51088: PPUSH
51089: CALL_OW 111
// end ;
51093: LD_VAR 0 3
51097: RET
// export function PrepareApemanSoldier ( ) ; begin
51098: LD_INT 0
51100: PPUSH
// uc_nation := 0 ;
51101: LD_ADDR_OWVAR 21
51105: PUSH
51106: LD_INT 0
51108: ST_TO_ADDR
// hc_sex := sex_male ;
51109: LD_ADDR_OWVAR 27
51113: PUSH
51114: LD_INT 1
51116: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51117: LD_ADDR_OWVAR 28
51121: PUSH
51122: LD_INT 15
51124: ST_TO_ADDR
// hc_gallery :=  ;
51125: LD_ADDR_OWVAR 33
51129: PUSH
51130: LD_STRING 
51132: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51133: LD_ADDR_OWVAR 31
51137: PUSH
51138: LD_INT 0
51140: PPUSH
51141: LD_INT 3
51143: PPUSH
51144: CALL_OW 12
51148: PUSH
51149: LD_INT 0
51151: PPUSH
51152: LD_INT 3
51154: PPUSH
51155: CALL_OW 12
51159: PUSH
51160: LD_INT 0
51162: PUSH
51163: LD_INT 0
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: ST_TO_ADDR
// end ;
51172: LD_VAR 0 1
51176: RET
// export function PrepareApemanEngineer ( ) ; begin
51177: LD_INT 0
51179: PPUSH
// uc_nation := 0 ;
51180: LD_ADDR_OWVAR 21
51184: PUSH
51185: LD_INT 0
51187: ST_TO_ADDR
// hc_sex := sex_male ;
51188: LD_ADDR_OWVAR 27
51192: PUSH
51193: LD_INT 1
51195: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51196: LD_ADDR_OWVAR 28
51200: PUSH
51201: LD_INT 16
51203: ST_TO_ADDR
// hc_gallery :=  ;
51204: LD_ADDR_OWVAR 33
51208: PUSH
51209: LD_STRING 
51211: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51212: LD_ADDR_OWVAR 31
51216: PUSH
51217: LD_INT 0
51219: PPUSH
51220: LD_INT 3
51222: PPUSH
51223: CALL_OW 12
51227: PUSH
51228: LD_INT 0
51230: PPUSH
51231: LD_INT 3
51233: PPUSH
51234: CALL_OW 12
51238: PUSH
51239: LD_INT 0
51241: PUSH
51242: LD_INT 0
51244: PUSH
51245: EMPTY
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: ST_TO_ADDR
// end ;
51251: LD_VAR 0 1
51255: RET
// export function PrepareApeman ( agressivity ) ; begin
51256: LD_INT 0
51258: PPUSH
// uc_side := 0 ;
51259: LD_ADDR_OWVAR 20
51263: PUSH
51264: LD_INT 0
51266: ST_TO_ADDR
// uc_nation := 0 ;
51267: LD_ADDR_OWVAR 21
51271: PUSH
51272: LD_INT 0
51274: ST_TO_ADDR
// hc_sex := sex_male ;
51275: LD_ADDR_OWVAR 27
51279: PUSH
51280: LD_INT 1
51282: ST_TO_ADDR
// hc_class := class_apeman ;
51283: LD_ADDR_OWVAR 28
51287: PUSH
51288: LD_INT 12
51290: ST_TO_ADDR
// hc_gallery :=  ;
51291: LD_ADDR_OWVAR 33
51295: PUSH
51296: LD_STRING 
51298: ST_TO_ADDR
// if agressivity = 0 then
51299: LD_VAR 0 1
51303: PUSH
51304: LD_INT 0
51306: EQUAL
51307: IFFALSE 51319
// hc_agressivity := 0 else
51309: LD_ADDR_OWVAR 35
51313: PUSH
51314: LD_INT 0
51316: ST_TO_ADDR
51317: GO 51340
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51319: LD_ADDR_OWVAR 35
51323: PUSH
51324: LD_VAR 0 1
51328: NEG
51329: PPUSH
51330: LD_VAR 0 1
51334: PPUSH
51335: CALL_OW 12
51339: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51340: LD_ADDR_OWVAR 31
51344: PUSH
51345: LD_INT 0
51347: PPUSH
51348: LD_INT 3
51350: PPUSH
51351: CALL_OW 12
51355: PUSH
51356: LD_INT 0
51358: PPUSH
51359: LD_INT 3
51361: PPUSH
51362: CALL_OW 12
51366: PUSH
51367: LD_INT 0
51369: PUSH
51370: LD_INT 0
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: ST_TO_ADDR
// end ;
51379: LD_VAR 0 2
51383: RET
// export function PrepareTiger ( agressivity ) ; begin
51384: LD_INT 0
51386: PPUSH
// uc_side := 0 ;
51387: LD_ADDR_OWVAR 20
51391: PUSH
51392: LD_INT 0
51394: ST_TO_ADDR
// uc_nation := 0 ;
51395: LD_ADDR_OWVAR 21
51399: PUSH
51400: LD_INT 0
51402: ST_TO_ADDR
// hc_class := class_tiger ;
51403: LD_ADDR_OWVAR 28
51407: PUSH
51408: LD_INT 14
51410: ST_TO_ADDR
// hc_gallery :=  ;
51411: LD_ADDR_OWVAR 33
51415: PUSH
51416: LD_STRING 
51418: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51419: LD_ADDR_OWVAR 35
51423: PUSH
51424: LD_VAR 0 1
51428: NEG
51429: PPUSH
51430: LD_VAR 0 1
51434: PPUSH
51435: CALL_OW 12
51439: ST_TO_ADDR
// end ;
51440: LD_VAR 0 2
51444: RET
// export function PrepareEnchidna ( ) ; begin
51445: LD_INT 0
51447: PPUSH
// uc_side := 0 ;
51448: LD_ADDR_OWVAR 20
51452: PUSH
51453: LD_INT 0
51455: ST_TO_ADDR
// uc_nation := 0 ;
51456: LD_ADDR_OWVAR 21
51460: PUSH
51461: LD_INT 0
51463: ST_TO_ADDR
// hc_class := class_baggie ;
51464: LD_ADDR_OWVAR 28
51468: PUSH
51469: LD_INT 13
51471: ST_TO_ADDR
// hc_gallery :=  ;
51472: LD_ADDR_OWVAR 33
51476: PUSH
51477: LD_STRING 
51479: ST_TO_ADDR
// end ;
51480: LD_VAR 0 1
51484: RET
// export function PrepareFrog ( ) ; begin
51485: LD_INT 0
51487: PPUSH
// uc_side := 0 ;
51488: LD_ADDR_OWVAR 20
51492: PUSH
51493: LD_INT 0
51495: ST_TO_ADDR
// uc_nation := 0 ;
51496: LD_ADDR_OWVAR 21
51500: PUSH
51501: LD_INT 0
51503: ST_TO_ADDR
// hc_class := class_frog ;
51504: LD_ADDR_OWVAR 28
51508: PUSH
51509: LD_INT 19
51511: ST_TO_ADDR
// hc_gallery :=  ;
51512: LD_ADDR_OWVAR 33
51516: PUSH
51517: LD_STRING 
51519: ST_TO_ADDR
// end ;
51520: LD_VAR 0 1
51524: RET
// export function PrepareFish ( ) ; begin
51525: LD_INT 0
51527: PPUSH
// uc_side := 0 ;
51528: LD_ADDR_OWVAR 20
51532: PUSH
51533: LD_INT 0
51535: ST_TO_ADDR
// uc_nation := 0 ;
51536: LD_ADDR_OWVAR 21
51540: PUSH
51541: LD_INT 0
51543: ST_TO_ADDR
// hc_class := class_fish ;
51544: LD_ADDR_OWVAR 28
51548: PUSH
51549: LD_INT 20
51551: ST_TO_ADDR
// hc_gallery :=  ;
51552: LD_ADDR_OWVAR 33
51556: PUSH
51557: LD_STRING 
51559: ST_TO_ADDR
// end ;
51560: LD_VAR 0 1
51564: RET
// export function PrepareBird ( ) ; begin
51565: LD_INT 0
51567: PPUSH
// uc_side := 0 ;
51568: LD_ADDR_OWVAR 20
51572: PUSH
51573: LD_INT 0
51575: ST_TO_ADDR
// uc_nation := 0 ;
51576: LD_ADDR_OWVAR 21
51580: PUSH
51581: LD_INT 0
51583: ST_TO_ADDR
// hc_class := class_phororhacos ;
51584: LD_ADDR_OWVAR 28
51588: PUSH
51589: LD_INT 18
51591: ST_TO_ADDR
// hc_gallery :=  ;
51592: LD_ADDR_OWVAR 33
51596: PUSH
51597: LD_STRING 
51599: ST_TO_ADDR
// end ;
51600: LD_VAR 0 1
51604: RET
// export function PrepareHorse ( ) ; begin
51605: LD_INT 0
51607: PPUSH
// uc_side := 0 ;
51608: LD_ADDR_OWVAR 20
51612: PUSH
51613: LD_INT 0
51615: ST_TO_ADDR
// uc_nation := 0 ;
51616: LD_ADDR_OWVAR 21
51620: PUSH
51621: LD_INT 0
51623: ST_TO_ADDR
// hc_class := class_horse ;
51624: LD_ADDR_OWVAR 28
51628: PUSH
51629: LD_INT 21
51631: ST_TO_ADDR
// hc_gallery :=  ;
51632: LD_ADDR_OWVAR 33
51636: PUSH
51637: LD_STRING 
51639: ST_TO_ADDR
// end ;
51640: LD_VAR 0 1
51644: RET
// export function PrepareMastodont ( ) ; begin
51645: LD_INT 0
51647: PPUSH
// uc_side := 0 ;
51648: LD_ADDR_OWVAR 20
51652: PUSH
51653: LD_INT 0
51655: ST_TO_ADDR
// uc_nation := 0 ;
51656: LD_ADDR_OWVAR 21
51660: PUSH
51661: LD_INT 0
51663: ST_TO_ADDR
// vc_chassis := class_mastodont ;
51664: LD_ADDR_OWVAR 37
51668: PUSH
51669: LD_INT 31
51671: ST_TO_ADDR
// vc_control := control_rider ;
51672: LD_ADDR_OWVAR 38
51676: PUSH
51677: LD_INT 4
51679: ST_TO_ADDR
// end ;
51680: LD_VAR 0 1
51684: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
51685: LD_INT 0
51687: PPUSH
51688: PPUSH
51689: PPUSH
// uc_side = 0 ;
51690: LD_ADDR_OWVAR 20
51694: PUSH
51695: LD_INT 0
51697: ST_TO_ADDR
// uc_nation = 0 ;
51698: LD_ADDR_OWVAR 21
51702: PUSH
51703: LD_INT 0
51705: ST_TO_ADDR
// InitHc_All ( ) ;
51706: CALL_OW 584
// InitVc ;
51710: CALL_OW 20
// if mastodonts then
51714: LD_VAR 0 6
51718: IFFALSE 51785
// for i = 1 to mastodonts do
51720: LD_ADDR_VAR 0 11
51724: PUSH
51725: DOUBLE
51726: LD_INT 1
51728: DEC
51729: ST_TO_ADDR
51730: LD_VAR 0 6
51734: PUSH
51735: FOR_TO
51736: IFFALSE 51783
// begin vc_chassis := 31 ;
51738: LD_ADDR_OWVAR 37
51742: PUSH
51743: LD_INT 31
51745: ST_TO_ADDR
// vc_control := control_rider ;
51746: LD_ADDR_OWVAR 38
51750: PUSH
51751: LD_INT 4
51753: ST_TO_ADDR
// animal := CreateVehicle ;
51754: LD_ADDR_VAR 0 12
51758: PUSH
51759: CALL_OW 45
51763: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51764: LD_VAR 0 12
51768: PPUSH
51769: LD_VAR 0 8
51773: PPUSH
51774: LD_INT 0
51776: PPUSH
51777: CALL 53913 0 3
// end ;
51781: GO 51735
51783: POP
51784: POP
// if horses then
51785: LD_VAR 0 5
51789: IFFALSE 51856
// for i = 1 to horses do
51791: LD_ADDR_VAR 0 11
51795: PUSH
51796: DOUBLE
51797: LD_INT 1
51799: DEC
51800: ST_TO_ADDR
51801: LD_VAR 0 5
51805: PUSH
51806: FOR_TO
51807: IFFALSE 51854
// begin hc_class := 21 ;
51809: LD_ADDR_OWVAR 28
51813: PUSH
51814: LD_INT 21
51816: ST_TO_ADDR
// hc_gallery :=  ;
51817: LD_ADDR_OWVAR 33
51821: PUSH
51822: LD_STRING 
51824: ST_TO_ADDR
// animal := CreateHuman ;
51825: LD_ADDR_VAR 0 12
51829: PUSH
51830: CALL_OW 44
51834: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51835: LD_VAR 0 12
51839: PPUSH
51840: LD_VAR 0 8
51844: PPUSH
51845: LD_INT 0
51847: PPUSH
51848: CALL 53913 0 3
// end ;
51852: GO 51806
51854: POP
51855: POP
// if birds then
51856: LD_VAR 0 1
51860: IFFALSE 51927
// for i = 1 to birds do
51862: LD_ADDR_VAR 0 11
51866: PUSH
51867: DOUBLE
51868: LD_INT 1
51870: DEC
51871: ST_TO_ADDR
51872: LD_VAR 0 1
51876: PUSH
51877: FOR_TO
51878: IFFALSE 51925
// begin hc_class := 18 ;
51880: LD_ADDR_OWVAR 28
51884: PUSH
51885: LD_INT 18
51887: ST_TO_ADDR
// hc_gallery =  ;
51888: LD_ADDR_OWVAR 33
51892: PUSH
51893: LD_STRING 
51895: ST_TO_ADDR
// animal := CreateHuman ;
51896: LD_ADDR_VAR 0 12
51900: PUSH
51901: CALL_OW 44
51905: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51906: LD_VAR 0 12
51910: PPUSH
51911: LD_VAR 0 8
51915: PPUSH
51916: LD_INT 0
51918: PPUSH
51919: CALL 53913 0 3
// end ;
51923: GO 51877
51925: POP
51926: POP
// if tigers then
51927: LD_VAR 0 2
51931: IFFALSE 52015
// for i = 1 to tigers do
51933: LD_ADDR_VAR 0 11
51937: PUSH
51938: DOUBLE
51939: LD_INT 1
51941: DEC
51942: ST_TO_ADDR
51943: LD_VAR 0 2
51947: PUSH
51948: FOR_TO
51949: IFFALSE 52013
// begin hc_class = class_tiger ;
51951: LD_ADDR_OWVAR 28
51955: PUSH
51956: LD_INT 14
51958: ST_TO_ADDR
// hc_gallery =  ;
51959: LD_ADDR_OWVAR 33
51963: PUSH
51964: LD_STRING 
51966: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
51967: LD_ADDR_OWVAR 35
51971: PUSH
51972: LD_INT 7
51974: NEG
51975: PPUSH
51976: LD_INT 7
51978: PPUSH
51979: CALL_OW 12
51983: ST_TO_ADDR
// animal := CreateHuman ;
51984: LD_ADDR_VAR 0 12
51988: PUSH
51989: CALL_OW 44
51993: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51994: LD_VAR 0 12
51998: PPUSH
51999: LD_VAR 0 8
52003: PPUSH
52004: LD_INT 0
52006: PPUSH
52007: CALL 53913 0 3
// end ;
52011: GO 51948
52013: POP
52014: POP
// if apemans then
52015: LD_VAR 0 3
52019: IFFALSE 52142
// for i = 1 to apemans do
52021: LD_ADDR_VAR 0 11
52025: PUSH
52026: DOUBLE
52027: LD_INT 1
52029: DEC
52030: ST_TO_ADDR
52031: LD_VAR 0 3
52035: PUSH
52036: FOR_TO
52037: IFFALSE 52140
// begin hc_class = class_apeman ;
52039: LD_ADDR_OWVAR 28
52043: PUSH
52044: LD_INT 12
52046: ST_TO_ADDR
// hc_gallery =  ;
52047: LD_ADDR_OWVAR 33
52051: PUSH
52052: LD_STRING 
52054: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52055: LD_ADDR_OWVAR 35
52059: PUSH
52060: LD_INT 2
52062: NEG
52063: PPUSH
52064: LD_INT 2
52066: PPUSH
52067: CALL_OW 12
52071: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52072: LD_ADDR_OWVAR 31
52076: PUSH
52077: LD_INT 1
52079: PPUSH
52080: LD_INT 3
52082: PPUSH
52083: CALL_OW 12
52087: PUSH
52088: LD_INT 1
52090: PPUSH
52091: LD_INT 3
52093: PPUSH
52094: CALL_OW 12
52098: PUSH
52099: LD_INT 0
52101: PUSH
52102: LD_INT 0
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: LIST
52110: ST_TO_ADDR
// animal := CreateHuman ;
52111: LD_ADDR_VAR 0 12
52115: PUSH
52116: CALL_OW 44
52120: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52121: LD_VAR 0 12
52125: PPUSH
52126: LD_VAR 0 8
52130: PPUSH
52131: LD_INT 0
52133: PPUSH
52134: CALL 53913 0 3
// end ;
52138: GO 52036
52140: POP
52141: POP
// if enchidnas then
52142: LD_VAR 0 4
52146: IFFALSE 52213
// for i = 1 to enchidnas do
52148: LD_ADDR_VAR 0 11
52152: PUSH
52153: DOUBLE
52154: LD_INT 1
52156: DEC
52157: ST_TO_ADDR
52158: LD_VAR 0 4
52162: PUSH
52163: FOR_TO
52164: IFFALSE 52211
// begin hc_class = 13 ;
52166: LD_ADDR_OWVAR 28
52170: PUSH
52171: LD_INT 13
52173: ST_TO_ADDR
// hc_gallery =  ;
52174: LD_ADDR_OWVAR 33
52178: PUSH
52179: LD_STRING 
52181: ST_TO_ADDR
// animal := CreateHuman ;
52182: LD_ADDR_VAR 0 12
52186: PUSH
52187: CALL_OW 44
52191: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52192: LD_VAR 0 12
52196: PPUSH
52197: LD_VAR 0 8
52201: PPUSH
52202: LD_INT 0
52204: PPUSH
52205: CALL 53913 0 3
// end ;
52209: GO 52163
52211: POP
52212: POP
// if fishes then
52213: LD_VAR 0 7
52217: IFFALSE 52284
// for i = 1 to fishes do
52219: LD_ADDR_VAR 0 11
52223: PUSH
52224: DOUBLE
52225: LD_INT 1
52227: DEC
52228: ST_TO_ADDR
52229: LD_VAR 0 7
52233: PUSH
52234: FOR_TO
52235: IFFALSE 52282
// begin hc_class = 20 ;
52237: LD_ADDR_OWVAR 28
52241: PUSH
52242: LD_INT 20
52244: ST_TO_ADDR
// hc_gallery =  ;
52245: LD_ADDR_OWVAR 33
52249: PUSH
52250: LD_STRING 
52252: ST_TO_ADDR
// animal := CreateHuman ;
52253: LD_ADDR_VAR 0 12
52257: PUSH
52258: CALL_OW 44
52262: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52263: LD_VAR 0 12
52267: PPUSH
52268: LD_VAR 0 9
52272: PPUSH
52273: LD_INT 0
52275: PPUSH
52276: CALL 53913 0 3
// end ;
52280: GO 52234
52282: POP
52283: POP
// end ;
52284: LD_VAR 0 10
52288: RET
// export function WantHeal ( sci , unit ) ; begin
52289: LD_INT 0
52291: PPUSH
// if GetTaskList ( sci ) > 0 then
52292: LD_VAR 0 1
52296: PPUSH
52297: CALL_OW 437
52301: PUSH
52302: LD_INT 0
52304: GREATER
52305: IFFALSE 52375
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52307: LD_VAR 0 1
52311: PPUSH
52312: CALL_OW 437
52316: PUSH
52317: LD_INT 1
52319: ARRAY
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PUSH
52325: LD_STRING l
52327: EQUAL
52328: PUSH
52329: LD_VAR 0 1
52333: PPUSH
52334: CALL_OW 437
52338: PUSH
52339: LD_INT 1
52341: ARRAY
52342: PUSH
52343: LD_INT 4
52345: ARRAY
52346: PUSH
52347: LD_VAR 0 2
52351: EQUAL
52352: AND
52353: IFFALSE 52365
// result := true else
52355: LD_ADDR_VAR 0 3
52359: PUSH
52360: LD_INT 1
52362: ST_TO_ADDR
52363: GO 52373
// result := false ;
52365: LD_ADDR_VAR 0 3
52369: PUSH
52370: LD_INT 0
52372: ST_TO_ADDR
// end else
52373: GO 52383
// result := false ;
52375: LD_ADDR_VAR 0 3
52379: PUSH
52380: LD_INT 0
52382: ST_TO_ADDR
// end ;
52383: LD_VAR 0 3
52387: RET
// export function HealTarget ( sci ) ; begin
52388: LD_INT 0
52390: PPUSH
// if not sci then
52391: LD_VAR 0 1
52395: NOT
52396: IFFALSE 52400
// exit ;
52398: GO 52465
// result := 0 ;
52400: LD_ADDR_VAR 0 2
52404: PUSH
52405: LD_INT 0
52407: ST_TO_ADDR
// if GetTaskList ( sci ) then
52408: LD_VAR 0 1
52412: PPUSH
52413: CALL_OW 437
52417: IFFALSE 52465
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52419: LD_VAR 0 1
52423: PPUSH
52424: CALL_OW 437
52428: PUSH
52429: LD_INT 1
52431: ARRAY
52432: PUSH
52433: LD_INT 1
52435: ARRAY
52436: PUSH
52437: LD_STRING l
52439: EQUAL
52440: IFFALSE 52465
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52442: LD_ADDR_VAR 0 2
52446: PUSH
52447: LD_VAR 0 1
52451: PPUSH
52452: CALL_OW 437
52456: PUSH
52457: LD_INT 1
52459: ARRAY
52460: PUSH
52461: LD_INT 4
52463: ARRAY
52464: ST_TO_ADDR
// end ;
52465: LD_VAR 0 2
52469: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52470: LD_INT 0
52472: PPUSH
52473: PPUSH
52474: PPUSH
52475: PPUSH
// if not base_units then
52476: LD_VAR 0 1
52480: NOT
52481: IFFALSE 52485
// exit ;
52483: GO 52572
// result := false ;
52485: LD_ADDR_VAR 0 2
52489: PUSH
52490: LD_INT 0
52492: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52493: LD_ADDR_VAR 0 5
52497: PUSH
52498: LD_VAR 0 1
52502: PPUSH
52503: LD_INT 21
52505: PUSH
52506: LD_INT 3
52508: PUSH
52509: EMPTY
52510: LIST
52511: LIST
52512: PPUSH
52513: CALL_OW 72
52517: ST_TO_ADDR
// if not tmp then
52518: LD_VAR 0 5
52522: NOT
52523: IFFALSE 52527
// exit ;
52525: GO 52572
// for i in tmp do
52527: LD_ADDR_VAR 0 3
52531: PUSH
52532: LD_VAR 0 5
52536: PUSH
52537: FOR_IN
52538: IFFALSE 52570
// begin result := EnemyInRange ( i , 22 ) ;
52540: LD_ADDR_VAR 0 2
52544: PUSH
52545: LD_VAR 0 3
52549: PPUSH
52550: LD_INT 22
52552: PPUSH
52553: CALL 50150 0 2
52557: ST_TO_ADDR
// if result then
52558: LD_VAR 0 2
52562: IFFALSE 52568
// exit ;
52564: POP
52565: POP
52566: GO 52572
// end ;
52568: GO 52537
52570: POP
52571: POP
// end ;
52572: LD_VAR 0 2
52576: RET
// export function FilterByTag ( units , tag ) ; begin
52577: LD_INT 0
52579: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
52580: LD_ADDR_VAR 0 3
52584: PUSH
52585: LD_VAR 0 1
52589: PPUSH
52590: LD_INT 120
52592: PUSH
52593: LD_VAR 0 2
52597: PUSH
52598: EMPTY
52599: LIST
52600: LIST
52601: PPUSH
52602: CALL_OW 72
52606: ST_TO_ADDR
// end ;
52607: LD_VAR 0 3
52611: RET
// export function IsDriver ( un ) ; begin
52612: LD_INT 0
52614: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
52615: LD_ADDR_VAR 0 2
52619: PUSH
52620: LD_VAR 0 1
52624: PUSH
52625: LD_INT 55
52627: PUSH
52628: EMPTY
52629: LIST
52630: PPUSH
52631: CALL_OW 69
52635: IN
52636: ST_TO_ADDR
// end ;
52637: LD_VAR 0 2
52641: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
52642: LD_INT 0
52644: PPUSH
52645: PPUSH
// list := [ ] ;
52646: LD_ADDR_VAR 0 5
52650: PUSH
52651: EMPTY
52652: ST_TO_ADDR
// case d of 0 :
52653: LD_VAR 0 3
52657: PUSH
52658: LD_INT 0
52660: DOUBLE
52661: EQUAL
52662: IFTRUE 52666
52664: GO 52799
52666: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
52667: LD_ADDR_VAR 0 5
52671: PUSH
52672: LD_VAR 0 1
52676: PUSH
52677: LD_INT 4
52679: MINUS
52680: PUSH
52681: LD_VAR 0 2
52685: PUSH
52686: LD_INT 4
52688: MINUS
52689: PUSH
52690: LD_INT 2
52692: PUSH
52693: EMPTY
52694: LIST
52695: LIST
52696: LIST
52697: PUSH
52698: LD_VAR 0 1
52702: PUSH
52703: LD_INT 3
52705: MINUS
52706: PUSH
52707: LD_VAR 0 2
52711: PUSH
52712: LD_INT 1
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: LIST
52719: PUSH
52720: LD_VAR 0 1
52724: PUSH
52725: LD_INT 4
52727: PLUS
52728: PUSH
52729: LD_VAR 0 2
52733: PUSH
52734: LD_INT 4
52736: PUSH
52737: EMPTY
52738: LIST
52739: LIST
52740: LIST
52741: PUSH
52742: LD_VAR 0 1
52746: PUSH
52747: LD_INT 3
52749: PLUS
52750: PUSH
52751: LD_VAR 0 2
52755: PUSH
52756: LD_INT 3
52758: PLUS
52759: PUSH
52760: LD_INT 5
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: LIST
52767: PUSH
52768: LD_VAR 0 1
52772: PUSH
52773: LD_VAR 0 2
52777: PUSH
52778: LD_INT 4
52780: PLUS
52781: PUSH
52782: LD_INT 0
52784: PUSH
52785: EMPTY
52786: LIST
52787: LIST
52788: LIST
52789: PUSH
52790: EMPTY
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: ST_TO_ADDR
// end ; 1 :
52797: GO 53497
52799: LD_INT 1
52801: DOUBLE
52802: EQUAL
52803: IFTRUE 52807
52805: GO 52940
52807: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
52808: LD_ADDR_VAR 0 5
52812: PUSH
52813: LD_VAR 0 1
52817: PUSH
52818: LD_VAR 0 2
52822: PUSH
52823: LD_INT 4
52825: MINUS
52826: PUSH
52827: LD_INT 3
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: LIST
52834: PUSH
52835: LD_VAR 0 1
52839: PUSH
52840: LD_INT 3
52842: MINUS
52843: PUSH
52844: LD_VAR 0 2
52848: PUSH
52849: LD_INT 3
52851: MINUS
52852: PUSH
52853: LD_INT 2
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: LIST
52860: PUSH
52861: LD_VAR 0 1
52865: PUSH
52866: LD_INT 4
52868: MINUS
52869: PUSH
52870: LD_VAR 0 2
52874: PUSH
52875: LD_INT 1
52877: PUSH
52878: EMPTY
52879: LIST
52880: LIST
52881: LIST
52882: PUSH
52883: LD_VAR 0 1
52887: PUSH
52888: LD_VAR 0 2
52892: PUSH
52893: LD_INT 3
52895: PLUS
52896: PUSH
52897: LD_INT 0
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: LIST
52904: PUSH
52905: LD_VAR 0 1
52909: PUSH
52910: LD_INT 4
52912: PLUS
52913: PUSH
52914: LD_VAR 0 2
52918: PUSH
52919: LD_INT 4
52921: PLUS
52922: PUSH
52923: LD_INT 5
52925: PUSH
52926: EMPTY
52927: LIST
52928: LIST
52929: LIST
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: LIST
52935: LIST
52936: LIST
52937: ST_TO_ADDR
// end ; 2 :
52938: GO 53497
52940: LD_INT 2
52942: DOUBLE
52943: EQUAL
52944: IFTRUE 52948
52946: GO 53077
52948: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
52949: LD_ADDR_VAR 0 5
52953: PUSH
52954: LD_VAR 0 1
52958: PUSH
52959: LD_VAR 0 2
52963: PUSH
52964: LD_INT 3
52966: MINUS
52967: PUSH
52968: LD_INT 3
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: LIST
52975: PUSH
52976: LD_VAR 0 1
52980: PUSH
52981: LD_INT 4
52983: PLUS
52984: PUSH
52985: LD_VAR 0 2
52989: PUSH
52990: LD_INT 4
52992: PUSH
52993: EMPTY
52994: LIST
52995: LIST
52996: LIST
52997: PUSH
52998: LD_VAR 0 1
53002: PUSH
53003: LD_VAR 0 2
53007: PUSH
53008: LD_INT 4
53010: PLUS
53011: PUSH
53012: LD_INT 0
53014: PUSH
53015: EMPTY
53016: LIST
53017: LIST
53018: LIST
53019: PUSH
53020: LD_VAR 0 1
53024: PUSH
53025: LD_INT 3
53027: MINUS
53028: PUSH
53029: LD_VAR 0 2
53033: PUSH
53034: LD_INT 1
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: LIST
53041: PUSH
53042: LD_VAR 0 1
53046: PUSH
53047: LD_INT 4
53049: MINUS
53050: PUSH
53051: LD_VAR 0 2
53055: PUSH
53056: LD_INT 4
53058: MINUS
53059: PUSH
53060: LD_INT 2
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: LIST
53067: PUSH
53068: EMPTY
53069: LIST
53070: LIST
53071: LIST
53072: LIST
53073: LIST
53074: ST_TO_ADDR
// end ; 3 :
53075: GO 53497
53077: LD_INT 3
53079: DOUBLE
53080: EQUAL
53081: IFTRUE 53085
53083: GO 53218
53085: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53086: LD_ADDR_VAR 0 5
53090: PUSH
53091: LD_VAR 0 1
53095: PUSH
53096: LD_INT 3
53098: PLUS
53099: PUSH
53100: LD_VAR 0 2
53104: PUSH
53105: LD_INT 4
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: LIST
53112: PUSH
53113: LD_VAR 0 1
53117: PUSH
53118: LD_INT 4
53120: PLUS
53121: PUSH
53122: LD_VAR 0 2
53126: PUSH
53127: LD_INT 4
53129: PLUS
53130: PUSH
53131: LD_INT 5
53133: PUSH
53134: EMPTY
53135: LIST
53136: LIST
53137: LIST
53138: PUSH
53139: LD_VAR 0 1
53143: PUSH
53144: LD_INT 4
53146: MINUS
53147: PUSH
53148: LD_VAR 0 2
53152: PUSH
53153: LD_INT 1
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: LIST
53160: PUSH
53161: LD_VAR 0 1
53165: PUSH
53166: LD_VAR 0 2
53170: PUSH
53171: LD_INT 4
53173: MINUS
53174: PUSH
53175: LD_INT 3
53177: PUSH
53178: EMPTY
53179: LIST
53180: LIST
53181: LIST
53182: PUSH
53183: LD_VAR 0 1
53187: PUSH
53188: LD_INT 3
53190: MINUS
53191: PUSH
53192: LD_VAR 0 2
53196: PUSH
53197: LD_INT 3
53199: MINUS
53200: PUSH
53201: LD_INT 2
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: LIST
53208: PUSH
53209: EMPTY
53210: LIST
53211: LIST
53212: LIST
53213: LIST
53214: LIST
53215: ST_TO_ADDR
// end ; 4 :
53216: GO 53497
53218: LD_INT 4
53220: DOUBLE
53221: EQUAL
53222: IFTRUE 53226
53224: GO 53359
53226: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53227: LD_ADDR_VAR 0 5
53231: PUSH
53232: LD_VAR 0 1
53236: PUSH
53237: LD_VAR 0 2
53241: PUSH
53242: LD_INT 4
53244: PLUS
53245: PUSH
53246: LD_INT 0
53248: PUSH
53249: EMPTY
53250: LIST
53251: LIST
53252: LIST
53253: PUSH
53254: LD_VAR 0 1
53258: PUSH
53259: LD_INT 3
53261: PLUS
53262: PUSH
53263: LD_VAR 0 2
53267: PUSH
53268: LD_INT 3
53270: PLUS
53271: PUSH
53272: LD_INT 5
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: PUSH
53280: LD_VAR 0 1
53284: PUSH
53285: LD_INT 4
53287: PLUS
53288: PUSH
53289: LD_VAR 0 2
53293: PUSH
53294: LD_INT 4
53296: PUSH
53297: EMPTY
53298: LIST
53299: LIST
53300: LIST
53301: PUSH
53302: LD_VAR 0 1
53306: PUSH
53307: LD_VAR 0 2
53311: PUSH
53312: LD_INT 3
53314: MINUS
53315: PUSH
53316: LD_INT 3
53318: PUSH
53319: EMPTY
53320: LIST
53321: LIST
53322: LIST
53323: PUSH
53324: LD_VAR 0 1
53328: PUSH
53329: LD_INT 4
53331: MINUS
53332: PUSH
53333: LD_VAR 0 2
53337: PUSH
53338: LD_INT 4
53340: MINUS
53341: PUSH
53342: LD_INT 2
53344: PUSH
53345: EMPTY
53346: LIST
53347: LIST
53348: LIST
53349: PUSH
53350: EMPTY
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: ST_TO_ADDR
// end ; 5 :
53357: GO 53497
53359: LD_INT 5
53361: DOUBLE
53362: EQUAL
53363: IFTRUE 53367
53365: GO 53496
53367: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53368: LD_ADDR_VAR 0 5
53372: PUSH
53373: LD_VAR 0 1
53377: PUSH
53378: LD_INT 4
53380: MINUS
53381: PUSH
53382: LD_VAR 0 2
53386: PUSH
53387: LD_INT 1
53389: PUSH
53390: EMPTY
53391: LIST
53392: LIST
53393: LIST
53394: PUSH
53395: LD_VAR 0 1
53399: PUSH
53400: LD_VAR 0 2
53404: PUSH
53405: LD_INT 4
53407: MINUS
53408: PUSH
53409: LD_INT 3
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: LIST
53416: PUSH
53417: LD_VAR 0 1
53421: PUSH
53422: LD_INT 4
53424: PLUS
53425: PUSH
53426: LD_VAR 0 2
53430: PUSH
53431: LD_INT 4
53433: PLUS
53434: PUSH
53435: LD_INT 5
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: LIST
53442: PUSH
53443: LD_VAR 0 1
53447: PUSH
53448: LD_INT 3
53450: PLUS
53451: PUSH
53452: LD_VAR 0 2
53456: PUSH
53457: LD_INT 4
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: LIST
53464: PUSH
53465: LD_VAR 0 1
53469: PUSH
53470: LD_VAR 0 2
53474: PUSH
53475: LD_INT 3
53477: PLUS
53478: PUSH
53479: LD_INT 0
53481: PUSH
53482: EMPTY
53483: LIST
53484: LIST
53485: LIST
53486: PUSH
53487: EMPTY
53488: LIST
53489: LIST
53490: LIST
53491: LIST
53492: LIST
53493: ST_TO_ADDR
// end ; end ;
53494: GO 53497
53496: POP
// result := list ;
53497: LD_ADDR_VAR 0 4
53501: PUSH
53502: LD_VAR 0 5
53506: ST_TO_ADDR
// end ;
53507: LD_VAR 0 4
53511: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
53512: LD_INT 0
53514: PPUSH
53515: PPUSH
53516: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
53517: LD_VAR 0 1
53521: NOT
53522: PUSH
53523: LD_VAR 0 2
53527: PUSH
53528: LD_INT 1
53530: PUSH
53531: LD_INT 2
53533: PUSH
53534: LD_INT 3
53536: PUSH
53537: LD_INT 4
53539: PUSH
53540: EMPTY
53541: LIST
53542: LIST
53543: LIST
53544: LIST
53545: IN
53546: NOT
53547: OR
53548: IFFALSE 53552
// exit ;
53550: GO 53635
// tmp := [ ] ;
53552: LD_ADDR_VAR 0 5
53556: PUSH
53557: EMPTY
53558: ST_TO_ADDR
// for i in units do
53559: LD_ADDR_VAR 0 4
53563: PUSH
53564: LD_VAR 0 1
53568: PUSH
53569: FOR_IN
53570: IFFALSE 53604
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
53572: LD_ADDR_VAR 0 5
53576: PUSH
53577: LD_VAR 0 5
53581: PPUSH
53582: LD_VAR 0 4
53586: PPUSH
53587: LD_VAR 0 2
53591: PPUSH
53592: CALL_OW 259
53596: PPUSH
53597: CALL 55008 0 2
53601: ST_TO_ADDR
53602: GO 53569
53604: POP
53605: POP
// if not tmp then
53606: LD_VAR 0 5
53610: NOT
53611: IFFALSE 53615
// exit ;
53613: GO 53635
// result := SortListByListDesc ( units , tmp ) ;
53615: LD_ADDR_VAR 0 3
53619: PUSH
53620: LD_VAR 0 1
53624: PPUSH
53625: LD_VAR 0 5
53629: PPUSH
53630: CALL_OW 77
53634: ST_TO_ADDR
// end ;
53635: LD_VAR 0 3
53639: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
53640: LD_INT 0
53642: PPUSH
53643: PPUSH
53644: PPUSH
// result := false ;
53645: LD_ADDR_VAR 0 3
53649: PUSH
53650: LD_INT 0
53652: ST_TO_ADDR
// if not building then
53653: LD_VAR 0 2
53657: NOT
53658: IFFALSE 53662
// exit ;
53660: GO 53800
// x := GetX ( building ) ;
53662: LD_ADDR_VAR 0 4
53666: PUSH
53667: LD_VAR 0 2
53671: PPUSH
53672: CALL_OW 250
53676: ST_TO_ADDR
// y := GetY ( building ) ;
53677: LD_ADDR_VAR 0 5
53681: PUSH
53682: LD_VAR 0 2
53686: PPUSH
53687: CALL_OW 251
53691: ST_TO_ADDR
// if not x or not y then
53692: LD_VAR 0 4
53696: NOT
53697: PUSH
53698: LD_VAR 0 5
53702: NOT
53703: OR
53704: IFFALSE 53708
// exit ;
53706: GO 53800
// if GetTaskList ( unit ) then
53708: LD_VAR 0 1
53712: PPUSH
53713: CALL_OW 437
53717: IFFALSE 53800
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53719: LD_STRING e
53721: PUSH
53722: LD_VAR 0 1
53726: PPUSH
53727: CALL_OW 437
53731: PUSH
53732: LD_INT 1
53734: ARRAY
53735: PUSH
53736: LD_INT 1
53738: ARRAY
53739: EQUAL
53740: PUSH
53741: LD_VAR 0 4
53745: PUSH
53746: LD_VAR 0 1
53750: PPUSH
53751: CALL_OW 437
53755: PUSH
53756: LD_INT 1
53758: ARRAY
53759: PUSH
53760: LD_INT 2
53762: ARRAY
53763: EQUAL
53764: AND
53765: PUSH
53766: LD_VAR 0 5
53770: PUSH
53771: LD_VAR 0 1
53775: PPUSH
53776: CALL_OW 437
53780: PUSH
53781: LD_INT 1
53783: ARRAY
53784: PUSH
53785: LD_INT 3
53787: ARRAY
53788: EQUAL
53789: AND
53790: IFFALSE 53800
// result := true end ;
53792: LD_ADDR_VAR 0 3
53796: PUSH
53797: LD_INT 1
53799: ST_TO_ADDR
// end ;
53800: LD_VAR 0 3
53804: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
53805: LD_INT 0
53807: PPUSH
// result := false ;
53808: LD_ADDR_VAR 0 4
53812: PUSH
53813: LD_INT 0
53815: ST_TO_ADDR
// if GetTaskList ( unit ) then
53816: LD_VAR 0 1
53820: PPUSH
53821: CALL_OW 437
53825: IFFALSE 53908
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53827: LD_STRING M
53829: PUSH
53830: LD_VAR 0 1
53834: PPUSH
53835: CALL_OW 437
53839: PUSH
53840: LD_INT 1
53842: ARRAY
53843: PUSH
53844: LD_INT 1
53846: ARRAY
53847: EQUAL
53848: PUSH
53849: LD_VAR 0 2
53853: PUSH
53854: LD_VAR 0 1
53858: PPUSH
53859: CALL_OW 437
53863: PUSH
53864: LD_INT 1
53866: ARRAY
53867: PUSH
53868: LD_INT 2
53870: ARRAY
53871: EQUAL
53872: AND
53873: PUSH
53874: LD_VAR 0 3
53878: PUSH
53879: LD_VAR 0 1
53883: PPUSH
53884: CALL_OW 437
53888: PUSH
53889: LD_INT 1
53891: ARRAY
53892: PUSH
53893: LD_INT 3
53895: ARRAY
53896: EQUAL
53897: AND
53898: IFFALSE 53908
// result := true ;
53900: LD_ADDR_VAR 0 4
53904: PUSH
53905: LD_INT 1
53907: ST_TO_ADDR
// end ; end ;
53908: LD_VAR 0 4
53912: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53913: LD_INT 0
53915: PPUSH
53916: PPUSH
53917: PPUSH
53918: PPUSH
// if not unit or not area then
53919: LD_VAR 0 1
53923: NOT
53924: PUSH
53925: LD_VAR 0 2
53929: NOT
53930: OR
53931: IFFALSE 53935
// exit ;
53933: GO 54111
// tmp := AreaToList ( area , i ) ;
53935: LD_ADDR_VAR 0 6
53939: PUSH
53940: LD_VAR 0 2
53944: PPUSH
53945: LD_VAR 0 5
53949: PPUSH
53950: CALL_OW 517
53954: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
53955: LD_ADDR_VAR 0 5
53959: PUSH
53960: DOUBLE
53961: LD_INT 1
53963: DEC
53964: ST_TO_ADDR
53965: LD_VAR 0 6
53969: PUSH
53970: LD_INT 1
53972: ARRAY
53973: PUSH
53974: FOR_TO
53975: IFFALSE 54109
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
53977: LD_ADDR_VAR 0 7
53981: PUSH
53982: LD_VAR 0 6
53986: PUSH
53987: LD_INT 1
53989: ARRAY
53990: PUSH
53991: LD_VAR 0 5
53995: ARRAY
53996: PUSH
53997: LD_VAR 0 6
54001: PUSH
54002: LD_INT 2
54004: ARRAY
54005: PUSH
54006: LD_VAR 0 5
54010: ARRAY
54011: PUSH
54012: EMPTY
54013: LIST
54014: LIST
54015: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
54016: LD_INT 92
54018: PUSH
54019: LD_VAR 0 7
54023: PUSH
54024: LD_INT 1
54026: ARRAY
54027: PUSH
54028: LD_VAR 0 7
54032: PUSH
54033: LD_INT 2
54035: ARRAY
54036: PUSH
54037: LD_INT 2
54039: PUSH
54040: EMPTY
54041: LIST
54042: LIST
54043: LIST
54044: LIST
54045: PPUSH
54046: CALL_OW 69
54050: PUSH
54051: LD_INT 0
54053: EQUAL
54054: IFFALSE 54107
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54056: LD_VAR 0 1
54060: PPUSH
54061: LD_VAR 0 7
54065: PUSH
54066: LD_INT 1
54068: ARRAY
54069: PPUSH
54070: LD_VAR 0 7
54074: PUSH
54075: LD_INT 2
54077: ARRAY
54078: PPUSH
54079: LD_VAR 0 3
54083: PPUSH
54084: CALL_OW 48
// result := IsPlaced ( unit ) ;
54088: LD_ADDR_VAR 0 4
54092: PUSH
54093: LD_VAR 0 1
54097: PPUSH
54098: CALL_OW 305
54102: ST_TO_ADDR
// exit ;
54103: POP
54104: POP
54105: GO 54111
// end ; end ;
54107: GO 53974
54109: POP
54110: POP
// end ;
54111: LD_VAR 0 4
54115: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54116: LD_INT 0
54118: PPUSH
54119: PPUSH
54120: PPUSH
// if not side or side > 8 then
54121: LD_VAR 0 1
54125: NOT
54126: PUSH
54127: LD_VAR 0 1
54131: PUSH
54132: LD_INT 8
54134: GREATER
54135: OR
54136: IFFALSE 54140
// exit ;
54138: GO 54327
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54140: LD_ADDR_VAR 0 4
54144: PUSH
54145: LD_INT 22
54147: PUSH
54148: LD_VAR 0 1
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: LD_INT 21
54159: PUSH
54160: LD_INT 3
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: PPUSH
54171: CALL_OW 69
54175: ST_TO_ADDR
// if not tmp then
54176: LD_VAR 0 4
54180: NOT
54181: IFFALSE 54185
// exit ;
54183: GO 54327
// enable_addtolog := true ;
54185: LD_ADDR_OWVAR 81
54189: PUSH
54190: LD_INT 1
54192: ST_TO_ADDR
// AddToLog ( [ ) ;
54193: LD_STRING [
54195: PPUSH
54196: CALL_OW 561
// for i in tmp do
54200: LD_ADDR_VAR 0 3
54204: PUSH
54205: LD_VAR 0 4
54209: PUSH
54210: FOR_IN
54211: IFFALSE 54318
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54213: LD_STRING [
54215: PUSH
54216: LD_VAR 0 3
54220: PPUSH
54221: CALL_OW 266
54225: STR
54226: PUSH
54227: LD_STRING , 
54229: STR
54230: PUSH
54231: LD_VAR 0 3
54235: PPUSH
54236: CALL_OW 250
54240: STR
54241: PUSH
54242: LD_STRING , 
54244: STR
54245: PUSH
54246: LD_VAR 0 3
54250: PPUSH
54251: CALL_OW 251
54255: STR
54256: PUSH
54257: LD_STRING , 
54259: STR
54260: PUSH
54261: LD_VAR 0 3
54265: PPUSH
54266: CALL_OW 254
54270: STR
54271: PUSH
54272: LD_STRING , 
54274: STR
54275: PUSH
54276: LD_VAR 0 3
54280: PPUSH
54281: LD_INT 1
54283: PPUSH
54284: CALL_OW 268
54288: STR
54289: PUSH
54290: LD_STRING , 
54292: STR
54293: PUSH
54294: LD_VAR 0 3
54298: PPUSH
54299: LD_INT 2
54301: PPUSH
54302: CALL_OW 268
54306: STR
54307: PUSH
54308: LD_STRING ],
54310: STR
54311: PPUSH
54312: CALL_OW 561
// end ;
54316: GO 54210
54318: POP
54319: POP
// AddToLog ( ]; ) ;
54320: LD_STRING ];
54322: PPUSH
54323: CALL_OW 561
// end ;
54327: LD_VAR 0 2
54331: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54332: LD_INT 0
54334: PPUSH
54335: PPUSH
54336: PPUSH
54337: PPUSH
54338: PPUSH
// if not area or not rate or not max then
54339: LD_VAR 0 1
54343: NOT
54344: PUSH
54345: LD_VAR 0 2
54349: NOT
54350: OR
54351: PUSH
54352: LD_VAR 0 4
54356: NOT
54357: OR
54358: IFFALSE 54362
// exit ;
54360: GO 54551
// while 1 do
54362: LD_INT 1
54364: IFFALSE 54551
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54366: LD_ADDR_VAR 0 9
54370: PUSH
54371: LD_VAR 0 1
54375: PPUSH
54376: LD_INT 1
54378: PPUSH
54379: CALL_OW 287
54383: PUSH
54384: LD_INT 10
54386: MUL
54387: ST_TO_ADDR
// r := rate / 10 ;
54388: LD_ADDR_VAR 0 7
54392: PUSH
54393: LD_VAR 0 2
54397: PUSH
54398: LD_INT 10
54400: DIVREAL
54401: ST_TO_ADDR
// time := 1 1$00 ;
54402: LD_ADDR_VAR 0 8
54406: PUSH
54407: LD_INT 2100
54409: ST_TO_ADDR
// if amount < min then
54410: LD_VAR 0 9
54414: PUSH
54415: LD_VAR 0 3
54419: LESS
54420: IFFALSE 54438
// r := r * 2 else
54422: LD_ADDR_VAR 0 7
54426: PUSH
54427: LD_VAR 0 7
54431: PUSH
54432: LD_INT 2
54434: MUL
54435: ST_TO_ADDR
54436: GO 54464
// if amount > max then
54438: LD_VAR 0 9
54442: PUSH
54443: LD_VAR 0 4
54447: GREATER
54448: IFFALSE 54464
// r := r / 2 ;
54450: LD_ADDR_VAR 0 7
54454: PUSH
54455: LD_VAR 0 7
54459: PUSH
54460: LD_INT 2
54462: DIVREAL
54463: ST_TO_ADDR
// time := time / r ;
54464: LD_ADDR_VAR 0 8
54468: PUSH
54469: LD_VAR 0 8
54473: PUSH
54474: LD_VAR 0 7
54478: DIVREAL
54479: ST_TO_ADDR
// if time < 0 then
54480: LD_VAR 0 8
54484: PUSH
54485: LD_INT 0
54487: LESS
54488: IFFALSE 54505
// time := time * - 1 ;
54490: LD_ADDR_VAR 0 8
54494: PUSH
54495: LD_VAR 0 8
54499: PUSH
54500: LD_INT 1
54502: NEG
54503: MUL
54504: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
54505: LD_VAR 0 8
54509: PUSH
54510: LD_INT 35
54512: PPUSH
54513: LD_INT 875
54515: PPUSH
54516: CALL_OW 12
54520: PLUS
54521: PPUSH
54522: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
54526: LD_INT 1
54528: PPUSH
54529: LD_INT 5
54531: PPUSH
54532: CALL_OW 12
54536: PPUSH
54537: LD_VAR 0 1
54541: PPUSH
54542: LD_INT 1
54544: PPUSH
54545: CALL_OW 55
// end ;
54549: GO 54362
// end ;
54551: LD_VAR 0 5
54555: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
54556: LD_INT 0
54558: PPUSH
54559: PPUSH
54560: PPUSH
54561: PPUSH
54562: PPUSH
54563: PPUSH
54564: PPUSH
54565: PPUSH
// if not turrets or not factories then
54566: LD_VAR 0 1
54570: NOT
54571: PUSH
54572: LD_VAR 0 2
54576: NOT
54577: OR
54578: IFFALSE 54582
// exit ;
54580: GO 54889
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
54582: LD_ADDR_VAR 0 10
54586: PUSH
54587: LD_INT 5
54589: PUSH
54590: LD_INT 6
54592: PUSH
54593: EMPTY
54594: LIST
54595: LIST
54596: PUSH
54597: LD_INT 2
54599: PUSH
54600: LD_INT 4
54602: PUSH
54603: EMPTY
54604: LIST
54605: LIST
54606: PUSH
54607: LD_INT 3
54609: PUSH
54610: LD_INT 5
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: PUSH
54617: EMPTY
54618: LIST
54619: LIST
54620: LIST
54621: PUSH
54622: LD_INT 24
54624: PUSH
54625: LD_INT 25
54627: PUSH
54628: EMPTY
54629: LIST
54630: LIST
54631: PUSH
54632: LD_INT 23
54634: PUSH
54635: LD_INT 27
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: PUSH
54642: EMPTY
54643: LIST
54644: LIST
54645: PUSH
54646: LD_INT 42
54648: PUSH
54649: LD_INT 43
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: PUSH
54656: LD_INT 44
54658: PUSH
54659: LD_INT 46
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: PUSH
54666: LD_INT 45
54668: PUSH
54669: LD_INT 47
54671: PUSH
54672: EMPTY
54673: LIST
54674: LIST
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: LIST
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: LIST
54685: ST_TO_ADDR
// result := [ ] ;
54686: LD_ADDR_VAR 0 3
54690: PUSH
54691: EMPTY
54692: ST_TO_ADDR
// for i in turrets do
54693: LD_ADDR_VAR 0 4
54697: PUSH
54698: LD_VAR 0 1
54702: PUSH
54703: FOR_IN
54704: IFFALSE 54887
// begin nat := GetNation ( i ) ;
54706: LD_ADDR_VAR 0 7
54710: PUSH
54711: LD_VAR 0 4
54715: PPUSH
54716: CALL_OW 248
54720: ST_TO_ADDR
// weapon := 0 ;
54721: LD_ADDR_VAR 0 8
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// if not nat then
54729: LD_VAR 0 7
54733: NOT
54734: IFFALSE 54738
// continue ;
54736: GO 54703
// for j in list [ nat ] do
54738: LD_ADDR_VAR 0 5
54742: PUSH
54743: LD_VAR 0 10
54747: PUSH
54748: LD_VAR 0 7
54752: ARRAY
54753: PUSH
54754: FOR_IN
54755: IFFALSE 54796
// if GetBWeapon ( i ) = j [ 1 ] then
54757: LD_VAR 0 4
54761: PPUSH
54762: CALL_OW 269
54766: PUSH
54767: LD_VAR 0 5
54771: PUSH
54772: LD_INT 1
54774: ARRAY
54775: EQUAL
54776: IFFALSE 54794
// begin weapon := j [ 2 ] ;
54778: LD_ADDR_VAR 0 8
54782: PUSH
54783: LD_VAR 0 5
54787: PUSH
54788: LD_INT 2
54790: ARRAY
54791: ST_TO_ADDR
// break ;
54792: GO 54796
// end ;
54794: GO 54754
54796: POP
54797: POP
// if not weapon then
54798: LD_VAR 0 8
54802: NOT
54803: IFFALSE 54807
// continue ;
54805: GO 54703
// for k in factories do
54807: LD_ADDR_VAR 0 6
54811: PUSH
54812: LD_VAR 0 2
54816: PUSH
54817: FOR_IN
54818: IFFALSE 54883
// begin weapons := AvailableWeaponList ( k ) ;
54820: LD_ADDR_VAR 0 9
54824: PUSH
54825: LD_VAR 0 6
54829: PPUSH
54830: CALL_OW 478
54834: ST_TO_ADDR
// if not weapons then
54835: LD_VAR 0 9
54839: NOT
54840: IFFALSE 54844
// continue ;
54842: GO 54817
// if weapon in weapons then
54844: LD_VAR 0 8
54848: PUSH
54849: LD_VAR 0 9
54853: IN
54854: IFFALSE 54881
// begin result := [ i , weapon ] ;
54856: LD_ADDR_VAR 0 3
54860: PUSH
54861: LD_VAR 0 4
54865: PUSH
54866: LD_VAR 0 8
54870: PUSH
54871: EMPTY
54872: LIST
54873: LIST
54874: ST_TO_ADDR
// exit ;
54875: POP
54876: POP
54877: POP
54878: POP
54879: GO 54889
// end ; end ;
54881: GO 54817
54883: POP
54884: POP
// end ;
54885: GO 54703
54887: POP
54888: POP
// end ;
54889: LD_VAR 0 3
54893: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54894: LD_INT 0
54896: PPUSH
// if not side or side > 8 then
54897: LD_VAR 0 3
54901: NOT
54902: PUSH
54903: LD_VAR 0 3
54907: PUSH
54908: LD_INT 8
54910: GREATER
54911: OR
54912: IFFALSE 54916
// exit ;
54914: GO 54975
// if not range then
54916: LD_VAR 0 4
54920: NOT
54921: IFFALSE 54932
// range := - 12 ;
54923: LD_ADDR_VAR 0 4
54927: PUSH
54928: LD_INT 12
54930: NEG
54931: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54932: LD_VAR 0 1
54936: PPUSH
54937: LD_VAR 0 2
54941: PPUSH
54942: LD_VAR 0 3
54946: PPUSH
54947: LD_VAR 0 4
54951: PPUSH
54952: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
54956: LD_VAR 0 1
54960: PPUSH
54961: LD_VAR 0 2
54965: PPUSH
54966: LD_VAR 0 3
54970: PPUSH
54971: CALL_OW 331
// end ;
54975: LD_VAR 0 5
54979: RET
// export function Video ( mode ) ; begin
54980: LD_INT 0
54982: PPUSH
// ingame_video = mode ;
54983: LD_ADDR_OWVAR 52
54987: PUSH
54988: LD_VAR 0 1
54992: ST_TO_ADDR
// interface_hidden = mode ;
54993: LD_ADDR_OWVAR 54
54997: PUSH
54998: LD_VAR 0 1
55002: ST_TO_ADDR
// end ;
55003: LD_VAR 0 2
55007: RET
// export function Join ( array , element ) ; begin
55008: LD_INT 0
55010: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55011: LD_ADDR_VAR 0 3
55015: PUSH
55016: LD_VAR 0 1
55020: PPUSH
55021: LD_VAR 0 1
55025: PUSH
55026: LD_INT 1
55028: PLUS
55029: PPUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: CALL_OW 1
55039: ST_TO_ADDR
// end ;
55040: LD_VAR 0 3
55044: RET
// export function JoinUnion ( array , element ) ; begin
55045: LD_INT 0
55047: PPUSH
// result := array union element ;
55048: LD_ADDR_VAR 0 3
55052: PUSH
55053: LD_VAR 0 1
55057: PUSH
55058: LD_VAR 0 2
55062: UNION
55063: ST_TO_ADDR
// end ;
55064: LD_VAR 0 3
55068: RET
// export function GetBehemoths ( side ) ; begin
55069: LD_INT 0
55071: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55072: LD_ADDR_VAR 0 2
55076: PUSH
55077: LD_INT 22
55079: PUSH
55080: LD_VAR 0 1
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: PUSH
55089: LD_INT 31
55091: PUSH
55092: LD_INT 25
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: PPUSH
55103: CALL_OW 69
55107: ST_TO_ADDR
// end ;
55108: LD_VAR 0 2
55112: RET
// export function Shuffle ( array ) ; var i , index ; begin
55113: LD_INT 0
55115: PPUSH
55116: PPUSH
55117: PPUSH
// result := [ ] ;
55118: LD_ADDR_VAR 0 2
55122: PUSH
55123: EMPTY
55124: ST_TO_ADDR
// if not array then
55125: LD_VAR 0 1
55129: NOT
55130: IFFALSE 55134
// exit ;
55132: GO 55233
// Randomize ;
55134: CALL_OW 10
// for i = array downto 1 do
55138: LD_ADDR_VAR 0 3
55142: PUSH
55143: DOUBLE
55144: LD_VAR 0 1
55148: INC
55149: ST_TO_ADDR
55150: LD_INT 1
55152: PUSH
55153: FOR_DOWNTO
55154: IFFALSE 55231
// begin index := rand ( 1 , array ) ;
55156: LD_ADDR_VAR 0 4
55160: PUSH
55161: LD_INT 1
55163: PPUSH
55164: LD_VAR 0 1
55168: PPUSH
55169: CALL_OW 12
55173: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55174: LD_ADDR_VAR 0 2
55178: PUSH
55179: LD_VAR 0 2
55183: PPUSH
55184: LD_VAR 0 2
55188: PUSH
55189: LD_INT 1
55191: PLUS
55192: PPUSH
55193: LD_VAR 0 1
55197: PUSH
55198: LD_VAR 0 4
55202: ARRAY
55203: PPUSH
55204: CALL_OW 2
55208: ST_TO_ADDR
// array := Delete ( array , index ) ;
55209: LD_ADDR_VAR 0 1
55213: PUSH
55214: LD_VAR 0 1
55218: PPUSH
55219: LD_VAR 0 4
55223: PPUSH
55224: CALL_OW 3
55228: ST_TO_ADDR
// end ;
55229: GO 55153
55231: POP
55232: POP
// end ;
55233: LD_VAR 0 2
55237: RET
// export function GetBaseMaterials ( base ) ; begin
55238: LD_INT 0
55240: PPUSH
// result := [ 0 , 0 , 0 ] ;
55241: LD_ADDR_VAR 0 2
55245: PUSH
55246: LD_INT 0
55248: PUSH
55249: LD_INT 0
55251: PUSH
55252: LD_INT 0
55254: PUSH
55255: EMPTY
55256: LIST
55257: LIST
55258: LIST
55259: ST_TO_ADDR
// if not base then
55260: LD_VAR 0 1
55264: NOT
55265: IFFALSE 55269
// exit ;
55267: GO 55318
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55269: LD_ADDR_VAR 0 2
55273: PUSH
55274: LD_VAR 0 1
55278: PPUSH
55279: LD_INT 1
55281: PPUSH
55282: CALL_OW 275
55286: PUSH
55287: LD_VAR 0 1
55291: PPUSH
55292: LD_INT 2
55294: PPUSH
55295: CALL_OW 275
55299: PUSH
55300: LD_VAR 0 1
55304: PPUSH
55305: LD_INT 3
55307: PPUSH
55308: CALL_OW 275
55312: PUSH
55313: EMPTY
55314: LIST
55315: LIST
55316: LIST
55317: ST_TO_ADDR
// end ;
55318: LD_VAR 0 2
55322: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55323: LD_INT 0
55325: PPUSH
55326: PPUSH
// result := array ;
55327: LD_ADDR_VAR 0 3
55331: PUSH
55332: LD_VAR 0 1
55336: ST_TO_ADDR
// if size >= result then
55337: LD_VAR 0 2
55341: PUSH
55342: LD_VAR 0 3
55346: GREATEREQUAL
55347: IFFALSE 55351
// exit ;
55349: GO 55401
// if size then
55351: LD_VAR 0 2
55355: IFFALSE 55401
// for i := array downto size do
55357: LD_ADDR_VAR 0 4
55361: PUSH
55362: DOUBLE
55363: LD_VAR 0 1
55367: INC
55368: ST_TO_ADDR
55369: LD_VAR 0 2
55373: PUSH
55374: FOR_DOWNTO
55375: IFFALSE 55399
// result := Delete ( result , result ) ;
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_VAR 0 3
55386: PPUSH
55387: LD_VAR 0 3
55391: PPUSH
55392: CALL_OW 3
55396: ST_TO_ADDR
55397: GO 55374
55399: POP
55400: POP
// end ;
55401: LD_VAR 0 3
55405: RET
// export function ComExit ( unit ) ; var tmp ; begin
55406: LD_INT 0
55408: PPUSH
55409: PPUSH
// if not IsInUnit ( unit ) then
55410: LD_VAR 0 1
55414: PPUSH
55415: CALL_OW 310
55419: NOT
55420: IFFALSE 55424
// exit ;
55422: GO 55484
// tmp := IsInUnit ( unit ) ;
55424: LD_ADDR_VAR 0 3
55428: PUSH
55429: LD_VAR 0 1
55433: PPUSH
55434: CALL_OW 310
55438: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 247
55448: PUSH
55449: LD_INT 2
55451: EQUAL
55452: IFFALSE 55465
// ComExitVehicle ( unit ) else
55454: LD_VAR 0 1
55458: PPUSH
55459: CALL_OW 121
55463: GO 55474
// ComExitBuilding ( unit ) ;
55465: LD_VAR 0 1
55469: PPUSH
55470: CALL_OW 122
// result := tmp ;
55474: LD_ADDR_VAR 0 2
55478: PUSH
55479: LD_VAR 0 3
55483: ST_TO_ADDR
// end ;
55484: LD_VAR 0 2
55488: RET
// export function ComExitAll ( units ) ; var i ; begin
55489: LD_INT 0
55491: PPUSH
55492: PPUSH
// if not units then
55493: LD_VAR 0 1
55497: NOT
55498: IFFALSE 55502
// exit ;
55500: GO 55528
// for i in units do
55502: LD_ADDR_VAR 0 3
55506: PUSH
55507: LD_VAR 0 1
55511: PUSH
55512: FOR_IN
55513: IFFALSE 55526
// ComExit ( i ) ;
55515: LD_VAR 0 3
55519: PPUSH
55520: CALL 55406 0 1
55524: GO 55512
55526: POP
55527: POP
// end ;
55528: LD_VAR 0 2
55532: RET
// export function ResetHc ; begin
55533: LD_INT 0
55535: PPUSH
// InitHc ;
55536: CALL_OW 19
// hc_importance := 0 ;
55540: LD_ADDR_OWVAR 32
55544: PUSH
55545: LD_INT 0
55547: ST_TO_ADDR
// end ;
55548: LD_VAR 0 1
55552: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
55553: LD_INT 0
55555: PPUSH
55556: PPUSH
55557: PPUSH
// _x := ( x1 + x2 ) div 2 ;
55558: LD_ADDR_VAR 0 6
55562: PUSH
55563: LD_VAR 0 1
55567: PUSH
55568: LD_VAR 0 3
55572: PLUS
55573: PUSH
55574: LD_INT 2
55576: DIV
55577: ST_TO_ADDR
// if _x < 0 then
55578: LD_VAR 0 6
55582: PUSH
55583: LD_INT 0
55585: LESS
55586: IFFALSE 55603
// _x := _x * - 1 ;
55588: LD_ADDR_VAR 0 6
55592: PUSH
55593: LD_VAR 0 6
55597: PUSH
55598: LD_INT 1
55600: NEG
55601: MUL
55602: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
55603: LD_ADDR_VAR 0 7
55607: PUSH
55608: LD_VAR 0 2
55612: PUSH
55613: LD_VAR 0 4
55617: PLUS
55618: PUSH
55619: LD_INT 2
55621: DIV
55622: ST_TO_ADDR
// if _y < 0 then
55623: LD_VAR 0 7
55627: PUSH
55628: LD_INT 0
55630: LESS
55631: IFFALSE 55648
// _y := _y * - 1 ;
55633: LD_ADDR_VAR 0 7
55637: PUSH
55638: LD_VAR 0 7
55642: PUSH
55643: LD_INT 1
55645: NEG
55646: MUL
55647: ST_TO_ADDR
// result := [ _x , _y ] ;
55648: LD_ADDR_VAR 0 5
55652: PUSH
55653: LD_VAR 0 6
55657: PUSH
55658: LD_VAR 0 7
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: ST_TO_ADDR
// end ;
55667: LD_VAR 0 5
55671: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
55672: LD_INT 0
55674: PPUSH
55675: PPUSH
55676: PPUSH
55677: PPUSH
// task := GetTaskList ( unit ) ;
55678: LD_ADDR_VAR 0 7
55682: PUSH
55683: LD_VAR 0 1
55687: PPUSH
55688: CALL_OW 437
55692: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
55693: LD_VAR 0 7
55697: NOT
55698: PUSH
55699: LD_VAR 0 1
55703: PPUSH
55704: LD_VAR 0 2
55708: PPUSH
55709: CALL_OW 308
55713: NOT
55714: AND
55715: IFFALSE 55719
// exit ;
55717: GO 55837
// if IsInArea ( unit , area ) then
55719: LD_VAR 0 1
55723: PPUSH
55724: LD_VAR 0 2
55728: PPUSH
55729: CALL_OW 308
55733: IFFALSE 55751
// begin ComMoveToArea ( unit , goAway ) ;
55735: LD_VAR 0 1
55739: PPUSH
55740: LD_VAR 0 3
55744: PPUSH
55745: CALL_OW 113
// exit ;
55749: GO 55837
// end ; if task [ 1 ] [ 1 ] <> M then
55751: LD_VAR 0 7
55755: PUSH
55756: LD_INT 1
55758: ARRAY
55759: PUSH
55760: LD_INT 1
55762: ARRAY
55763: PUSH
55764: LD_STRING M
55766: NONEQUAL
55767: IFFALSE 55771
// exit ;
55769: GO 55837
// x := task [ 1 ] [ 2 ] ;
55771: LD_ADDR_VAR 0 5
55775: PUSH
55776: LD_VAR 0 7
55780: PUSH
55781: LD_INT 1
55783: ARRAY
55784: PUSH
55785: LD_INT 2
55787: ARRAY
55788: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
55789: LD_ADDR_VAR 0 6
55793: PUSH
55794: LD_VAR 0 7
55798: PUSH
55799: LD_INT 1
55801: ARRAY
55802: PUSH
55803: LD_INT 3
55805: ARRAY
55806: ST_TO_ADDR
// if InArea ( x , y , area ) then
55807: LD_VAR 0 5
55811: PPUSH
55812: LD_VAR 0 6
55816: PPUSH
55817: LD_VAR 0 2
55821: PPUSH
55822: CALL_OW 309
55826: IFFALSE 55837
// ComStop ( unit ) ;
55828: LD_VAR 0 1
55832: PPUSH
55833: CALL_OW 141
// end ;
55837: LD_VAR 0 4
55841: RET
// export function Abs ( value ) ; begin
55842: LD_INT 0
55844: PPUSH
// result := value ;
55845: LD_ADDR_VAR 0 2
55849: PUSH
55850: LD_VAR 0 1
55854: ST_TO_ADDR
// if value < 0 then
55855: LD_VAR 0 1
55859: PUSH
55860: LD_INT 0
55862: LESS
55863: IFFALSE 55880
// result := value * - 1 ;
55865: LD_ADDR_VAR 0 2
55869: PUSH
55870: LD_VAR 0 1
55874: PUSH
55875: LD_INT 1
55877: NEG
55878: MUL
55879: ST_TO_ADDR
// end ;
55880: LD_VAR 0 2
55884: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55885: LD_INT 0
55887: PPUSH
55888: PPUSH
55889: PPUSH
55890: PPUSH
55891: PPUSH
55892: PPUSH
55893: PPUSH
55894: PPUSH
// if not unit or not building then
55895: LD_VAR 0 1
55899: NOT
55900: PUSH
55901: LD_VAR 0 2
55905: NOT
55906: OR
55907: IFFALSE 55911
// exit ;
55909: GO 56137
// x := GetX ( building ) ;
55911: LD_ADDR_VAR 0 4
55915: PUSH
55916: LD_VAR 0 2
55920: PPUSH
55921: CALL_OW 250
55925: ST_TO_ADDR
// y := GetY ( building ) ;
55926: LD_ADDR_VAR 0 6
55930: PUSH
55931: LD_VAR 0 2
55935: PPUSH
55936: CALL_OW 251
55940: ST_TO_ADDR
// d := GetDir ( building ) ;
55941: LD_ADDR_VAR 0 8
55945: PUSH
55946: LD_VAR 0 2
55950: PPUSH
55951: CALL_OW 254
55955: ST_TO_ADDR
// r := 4 ;
55956: LD_ADDR_VAR 0 9
55960: PUSH
55961: LD_INT 4
55963: ST_TO_ADDR
// for i := 1 to 5 do
55964: LD_ADDR_VAR 0 10
55968: PUSH
55969: DOUBLE
55970: LD_INT 1
55972: DEC
55973: ST_TO_ADDR
55974: LD_INT 5
55976: PUSH
55977: FOR_TO
55978: IFFALSE 56135
// begin _x := ShiftX ( x , d , r + i ) ;
55980: LD_ADDR_VAR 0 5
55984: PUSH
55985: LD_VAR 0 4
55989: PPUSH
55990: LD_VAR 0 8
55994: PPUSH
55995: LD_VAR 0 9
55999: PUSH
56000: LD_VAR 0 10
56004: PLUS
56005: PPUSH
56006: CALL_OW 272
56010: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56011: LD_ADDR_VAR 0 7
56015: PUSH
56016: LD_VAR 0 6
56020: PPUSH
56021: LD_VAR 0 8
56025: PPUSH
56026: LD_VAR 0 9
56030: PUSH
56031: LD_VAR 0 10
56035: PLUS
56036: PPUSH
56037: CALL_OW 273
56041: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56042: LD_VAR 0 5
56046: PPUSH
56047: LD_VAR 0 7
56051: PPUSH
56052: CALL_OW 488
56056: PUSH
56057: LD_VAR 0 5
56061: PPUSH
56062: LD_VAR 0 7
56066: PPUSH
56067: CALL_OW 428
56071: PPUSH
56072: CALL_OW 247
56076: PUSH
56077: LD_INT 3
56079: PUSH
56080: LD_INT 2
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: IN
56087: NOT
56088: AND
56089: IFFALSE 56133
// begin ComMoveXY ( unit , _x , _y ) ;
56091: LD_VAR 0 1
56095: PPUSH
56096: LD_VAR 0 5
56100: PPUSH
56101: LD_VAR 0 7
56105: PPUSH
56106: CALL_OW 111
// result := [ _x , _y ] ;
56110: LD_ADDR_VAR 0 3
56114: PUSH
56115: LD_VAR 0 5
56119: PUSH
56120: LD_VAR 0 7
56124: PUSH
56125: EMPTY
56126: LIST
56127: LIST
56128: ST_TO_ADDR
// exit ;
56129: POP
56130: POP
56131: GO 56137
// end ; end ;
56133: GO 55977
56135: POP
56136: POP
// end ;
56137: LD_VAR 0 3
56141: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56142: LD_INT 0
56144: PPUSH
56145: PPUSH
56146: PPUSH
// result := 0 ;
56147: LD_ADDR_VAR 0 3
56151: PUSH
56152: LD_INT 0
56154: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56155: LD_VAR 0 1
56159: PUSH
56160: LD_INT 0
56162: LESS
56163: PUSH
56164: LD_VAR 0 1
56168: PUSH
56169: LD_INT 8
56171: GREATER
56172: OR
56173: PUSH
56174: LD_VAR 0 2
56178: PUSH
56179: LD_INT 0
56181: LESS
56182: OR
56183: PUSH
56184: LD_VAR 0 2
56188: PUSH
56189: LD_INT 8
56191: GREATER
56192: OR
56193: IFFALSE 56197
// exit ;
56195: GO 56272
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56197: LD_ADDR_VAR 0 4
56201: PUSH
56202: LD_INT 22
56204: PUSH
56205: LD_VAR 0 2
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PPUSH
56214: CALL_OW 69
56218: PUSH
56219: FOR_IN
56220: IFFALSE 56270
// begin un := UnitShoot ( i ) ;
56222: LD_ADDR_VAR 0 5
56226: PUSH
56227: LD_VAR 0 4
56231: PPUSH
56232: CALL_OW 504
56236: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56237: LD_VAR 0 5
56241: PPUSH
56242: CALL_OW 255
56246: PUSH
56247: LD_VAR 0 1
56251: EQUAL
56252: IFFALSE 56268
// begin result := un ;
56254: LD_ADDR_VAR 0 3
56258: PUSH
56259: LD_VAR 0 5
56263: ST_TO_ADDR
// exit ;
56264: POP
56265: POP
56266: GO 56272
// end ; end ;
56268: GO 56219
56270: POP
56271: POP
// end ;
56272: LD_VAR 0 3
56276: RET
// export function GetCargoBay ( units ) ; begin
56277: LD_INT 0
56279: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56280: LD_ADDR_VAR 0 2
56284: PUSH
56285: LD_VAR 0 1
56289: PPUSH
56290: LD_INT 2
56292: PUSH
56293: LD_INT 34
56295: PUSH
56296: LD_INT 12
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: PUSH
56303: LD_INT 34
56305: PUSH
56306: LD_INT 51
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 34
56315: PUSH
56316: LD_INT 32
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 34
56325: PUSH
56326: LD_INT 89
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: LIST
56337: LIST
56338: LIST
56339: PPUSH
56340: CALL_OW 72
56344: ST_TO_ADDR
// end ;
56345: LD_VAR 0 2
56349: RET
// export function Negate ( value ) ; begin
56350: LD_INT 0
56352: PPUSH
// result := not value ;
56353: LD_ADDR_VAR 0 2
56357: PUSH
56358: LD_VAR 0 1
56362: NOT
56363: ST_TO_ADDR
// end ;
56364: LD_VAR 0 2
56368: RET
// export function Inc ( value ) ; begin
56369: LD_INT 0
56371: PPUSH
// result := value + 1 ;
56372: LD_ADDR_VAR 0 2
56376: PUSH
56377: LD_VAR 0 1
56381: PUSH
56382: LD_INT 1
56384: PLUS
56385: ST_TO_ADDR
// end ;
56386: LD_VAR 0 2
56390: RET
// export function Dec ( value ) ; begin
56391: LD_INT 0
56393: PPUSH
// result := value - 1 ;
56394: LD_ADDR_VAR 0 2
56398: PUSH
56399: LD_VAR 0 1
56403: PUSH
56404: LD_INT 1
56406: MINUS
56407: ST_TO_ADDR
// end ;
56408: LD_VAR 0 2
56412: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
56413: LD_INT 0
56415: PPUSH
56416: PPUSH
56417: PPUSH
56418: PPUSH
56419: PPUSH
56420: PPUSH
56421: PPUSH
56422: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
56423: LD_VAR 0 1
56427: PPUSH
56428: LD_VAR 0 2
56432: PPUSH
56433: CALL_OW 488
56437: NOT
56438: PUSH
56439: LD_VAR 0 3
56443: PPUSH
56444: LD_VAR 0 4
56448: PPUSH
56449: CALL_OW 488
56453: NOT
56454: OR
56455: IFFALSE 56468
// begin result := - 1 ;
56457: LD_ADDR_VAR 0 5
56461: PUSH
56462: LD_INT 1
56464: NEG
56465: ST_TO_ADDR
// exit ;
56466: GO 56703
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
56468: LD_ADDR_VAR 0 12
56472: PUSH
56473: LD_VAR 0 1
56477: PPUSH
56478: LD_VAR 0 2
56482: PPUSH
56483: LD_VAR 0 3
56487: PPUSH
56488: LD_VAR 0 4
56492: PPUSH
56493: CALL 55553 0 4
56497: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
56498: LD_ADDR_VAR 0 11
56502: PUSH
56503: LD_VAR 0 1
56507: PPUSH
56508: LD_VAR 0 2
56512: PPUSH
56513: LD_VAR 0 12
56517: PUSH
56518: LD_INT 1
56520: ARRAY
56521: PPUSH
56522: LD_VAR 0 12
56526: PUSH
56527: LD_INT 2
56529: ARRAY
56530: PPUSH
56531: CALL_OW 298
56535: ST_TO_ADDR
// distance := 9999 ;
56536: LD_ADDR_VAR 0 10
56540: PUSH
56541: LD_INT 9999
56543: ST_TO_ADDR
// for i := 0 to 5 do
56544: LD_ADDR_VAR 0 6
56548: PUSH
56549: DOUBLE
56550: LD_INT 0
56552: DEC
56553: ST_TO_ADDR
56554: LD_INT 5
56556: PUSH
56557: FOR_TO
56558: IFFALSE 56701
// begin _x := ShiftX ( x1 , i , centerDist ) ;
56560: LD_ADDR_VAR 0 7
56564: PUSH
56565: LD_VAR 0 1
56569: PPUSH
56570: LD_VAR 0 6
56574: PPUSH
56575: LD_VAR 0 11
56579: PPUSH
56580: CALL_OW 272
56584: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
56585: LD_ADDR_VAR 0 8
56589: PUSH
56590: LD_VAR 0 2
56594: PPUSH
56595: LD_VAR 0 6
56599: PPUSH
56600: LD_VAR 0 11
56604: PPUSH
56605: CALL_OW 273
56609: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56610: LD_VAR 0 7
56614: PPUSH
56615: LD_VAR 0 8
56619: PPUSH
56620: CALL_OW 488
56624: NOT
56625: IFFALSE 56629
// continue ;
56627: GO 56557
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
56629: LD_ADDR_VAR 0 9
56633: PUSH
56634: LD_VAR 0 12
56638: PUSH
56639: LD_INT 1
56641: ARRAY
56642: PPUSH
56643: LD_VAR 0 12
56647: PUSH
56648: LD_INT 2
56650: ARRAY
56651: PPUSH
56652: LD_VAR 0 7
56656: PPUSH
56657: LD_VAR 0 8
56661: PPUSH
56662: CALL_OW 298
56666: ST_TO_ADDR
// if tmp < distance then
56667: LD_VAR 0 9
56671: PUSH
56672: LD_VAR 0 10
56676: LESS
56677: IFFALSE 56699
// begin result := i ;
56679: LD_ADDR_VAR 0 5
56683: PUSH
56684: LD_VAR 0 6
56688: ST_TO_ADDR
// distance := tmp ;
56689: LD_ADDR_VAR 0 10
56693: PUSH
56694: LD_VAR 0 9
56698: ST_TO_ADDR
// end ; end ;
56699: GO 56557
56701: POP
56702: POP
// end ;
56703: LD_VAR 0 5
56707: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56708: LD_INT 0
56710: PPUSH
56711: PPUSH
// if not driver or not IsInUnit ( driver ) then
56712: LD_VAR 0 1
56716: NOT
56717: PUSH
56718: LD_VAR 0 1
56722: PPUSH
56723: CALL_OW 310
56727: NOT
56728: OR
56729: IFFALSE 56733
// exit ;
56731: GO 56823
// vehicle := IsInUnit ( driver ) ;
56733: LD_ADDR_VAR 0 3
56737: PUSH
56738: LD_VAR 0 1
56742: PPUSH
56743: CALL_OW 310
56747: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56748: LD_VAR 0 1
56752: PPUSH
56753: LD_STRING \
56755: PUSH
56756: LD_INT 0
56758: PUSH
56759: LD_INT 0
56761: PUSH
56762: LD_INT 0
56764: PUSH
56765: LD_INT 0
56767: PUSH
56768: LD_INT 0
56770: PUSH
56771: LD_INT 0
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: LIST
56778: LIST
56779: LIST
56780: LIST
56781: LIST
56782: PUSH
56783: LD_STRING E
56785: PUSH
56786: LD_INT 0
56788: PUSH
56789: LD_INT 0
56791: PUSH
56792: LD_VAR 0 3
56796: PUSH
56797: LD_INT 0
56799: PUSH
56800: LD_INT 0
56802: PUSH
56803: LD_INT 0
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: LIST
56812: LIST
56813: LIST
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PPUSH
56819: CALL_OW 446
// end ;
56823: LD_VAR 0 2
56827: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56828: LD_INT 0
56830: PPUSH
56831: PPUSH
// if not driver or not IsInUnit ( driver ) then
56832: LD_VAR 0 1
56836: NOT
56837: PUSH
56838: LD_VAR 0 1
56842: PPUSH
56843: CALL_OW 310
56847: NOT
56848: OR
56849: IFFALSE 56853
// exit ;
56851: GO 56943
// vehicle := IsInUnit ( driver ) ;
56853: LD_ADDR_VAR 0 3
56857: PUSH
56858: LD_VAR 0 1
56862: PPUSH
56863: CALL_OW 310
56867: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56868: LD_VAR 0 1
56872: PPUSH
56873: LD_STRING \
56875: PUSH
56876: LD_INT 0
56878: PUSH
56879: LD_INT 0
56881: PUSH
56882: LD_INT 0
56884: PUSH
56885: LD_INT 0
56887: PUSH
56888: LD_INT 0
56890: PUSH
56891: LD_INT 0
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: LIST
56902: PUSH
56903: LD_STRING E
56905: PUSH
56906: LD_INT 0
56908: PUSH
56909: LD_INT 0
56911: PUSH
56912: LD_VAR 0 3
56916: PUSH
56917: LD_INT 0
56919: PUSH
56920: LD_INT 0
56922: PUSH
56923: LD_INT 0
56925: PUSH
56926: EMPTY
56927: LIST
56928: LIST
56929: LIST
56930: LIST
56931: LIST
56932: LIST
56933: LIST
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PPUSH
56939: CALL_OW 447
// end ;
56943: LD_VAR 0 2
56947: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
56948: LD_INT 0
56950: PPUSH
56951: PPUSH
56952: PPUSH
// tmp := [ ] ;
56953: LD_ADDR_VAR 0 5
56957: PUSH
56958: EMPTY
56959: ST_TO_ADDR
// for i in units do
56960: LD_ADDR_VAR 0 4
56964: PUSH
56965: LD_VAR 0 1
56969: PUSH
56970: FOR_IN
56971: IFFALSE 57009
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
56973: LD_ADDR_VAR 0 5
56977: PUSH
56978: LD_VAR 0 5
56982: PPUSH
56983: LD_VAR 0 5
56987: PUSH
56988: LD_INT 1
56990: PLUS
56991: PPUSH
56992: LD_VAR 0 4
56996: PPUSH
56997: CALL_OW 256
57001: PPUSH
57002: CALL_OW 2
57006: ST_TO_ADDR
57007: GO 56970
57009: POP
57010: POP
// if not tmp then
57011: LD_VAR 0 5
57015: NOT
57016: IFFALSE 57020
// exit ;
57018: GO 57068
// if asc then
57020: LD_VAR 0 2
57024: IFFALSE 57048
// result := SortListByListAsc ( units , tmp ) else
57026: LD_ADDR_VAR 0 3
57030: PUSH
57031: LD_VAR 0 1
57035: PPUSH
57036: LD_VAR 0 5
57040: PPUSH
57041: CALL_OW 76
57045: ST_TO_ADDR
57046: GO 57068
// result := SortListByListDesc ( units , tmp ) ;
57048: LD_ADDR_VAR 0 3
57052: PUSH
57053: LD_VAR 0 1
57057: PPUSH
57058: LD_VAR 0 5
57062: PPUSH
57063: CALL_OW 77
57067: ST_TO_ADDR
// end ;
57068: LD_VAR 0 3
57072: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57073: LD_INT 0
57075: PPUSH
57076: PPUSH
// task := GetTaskList ( mech ) ;
57077: LD_ADDR_VAR 0 4
57081: PUSH
57082: LD_VAR 0 1
57086: PPUSH
57087: CALL_OW 437
57091: ST_TO_ADDR
// if not task then
57092: LD_VAR 0 4
57096: NOT
57097: IFFALSE 57101
// exit ;
57099: GO 57143
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57101: LD_ADDR_VAR 0 3
57105: PUSH
57106: LD_VAR 0 4
57110: PUSH
57111: LD_INT 1
57113: ARRAY
57114: PUSH
57115: LD_INT 1
57117: ARRAY
57118: PUSH
57119: LD_STRING r
57121: EQUAL
57122: PUSH
57123: LD_VAR 0 4
57127: PUSH
57128: LD_INT 1
57130: ARRAY
57131: PUSH
57132: LD_INT 4
57134: ARRAY
57135: PUSH
57136: LD_VAR 0 2
57140: EQUAL
57141: AND
57142: ST_TO_ADDR
// end ;
57143: LD_VAR 0 3
57147: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57148: LD_INT 0
57150: PPUSH
// SetDir ( unit , d ) ;
57151: LD_VAR 0 1
57155: PPUSH
57156: LD_VAR 0 4
57160: PPUSH
57161: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
57165: LD_VAR 0 1
57169: PPUSH
57170: LD_VAR 0 2
57174: PPUSH
57175: LD_VAR 0 3
57179: PPUSH
57180: LD_VAR 0 5
57184: PPUSH
57185: CALL_OW 48
// end ;
57189: LD_VAR 0 6
57193: RET
// export function ToNaturalNumber ( number ) ; begin
57194: LD_INT 0
57196: PPUSH
// result := number div 1 ;
57197: LD_ADDR_VAR 0 2
57201: PUSH
57202: LD_VAR 0 1
57206: PUSH
57207: LD_INT 1
57209: DIV
57210: ST_TO_ADDR
// if number < 0 then
57211: LD_VAR 0 1
57215: PUSH
57216: LD_INT 0
57218: LESS
57219: IFFALSE 57229
// result := 0 ;
57221: LD_ADDR_VAR 0 2
57225: PUSH
57226: LD_INT 0
57228: ST_TO_ADDR
// end ;
57229: LD_VAR 0 2
57233: RET
// export function SortByClass ( units , class ) ; var un ; begin
57234: LD_INT 0
57236: PPUSH
57237: PPUSH
// if not units or not class then
57238: LD_VAR 0 1
57242: NOT
57243: PUSH
57244: LD_VAR 0 2
57248: NOT
57249: OR
57250: IFFALSE 57254
// exit ;
57252: GO 57349
// result := [ ] ;
57254: LD_ADDR_VAR 0 3
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// for un in units do
57261: LD_ADDR_VAR 0 4
57265: PUSH
57266: LD_VAR 0 1
57270: PUSH
57271: FOR_IN
57272: IFFALSE 57347
// if GetClass ( un ) = class then
57274: LD_VAR 0 4
57278: PPUSH
57279: CALL_OW 257
57283: PUSH
57284: LD_VAR 0 2
57288: EQUAL
57289: IFFALSE 57316
// result := Insert ( result , 1 , un ) else
57291: LD_ADDR_VAR 0 3
57295: PUSH
57296: LD_VAR 0 3
57300: PPUSH
57301: LD_INT 1
57303: PPUSH
57304: LD_VAR 0 4
57308: PPUSH
57309: CALL_OW 2
57313: ST_TO_ADDR
57314: GO 57345
// result := Replace ( result , result + 1 , un ) ;
57316: LD_ADDR_VAR 0 3
57320: PUSH
57321: LD_VAR 0 3
57325: PPUSH
57326: LD_VAR 0 3
57330: PUSH
57331: LD_INT 1
57333: PLUS
57334: PPUSH
57335: LD_VAR 0 4
57339: PPUSH
57340: CALL_OW 1
57344: ST_TO_ADDR
57345: GO 57271
57347: POP
57348: POP
// end ;
57349: LD_VAR 0 3
57353: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
57354: LD_INT 0
57356: PPUSH
57357: PPUSH
57358: PPUSH
57359: PPUSH
57360: PPUSH
57361: PPUSH
57362: PPUSH
// result := [ ] ;
57363: LD_ADDR_VAR 0 4
57367: PUSH
57368: EMPTY
57369: ST_TO_ADDR
// if x - r < 0 then
57370: LD_VAR 0 1
57374: PUSH
57375: LD_VAR 0 3
57379: MINUS
57380: PUSH
57381: LD_INT 0
57383: LESS
57384: IFFALSE 57396
// min_x := 0 else
57386: LD_ADDR_VAR 0 8
57390: PUSH
57391: LD_INT 0
57393: ST_TO_ADDR
57394: GO 57412
// min_x := x - r ;
57396: LD_ADDR_VAR 0 8
57400: PUSH
57401: LD_VAR 0 1
57405: PUSH
57406: LD_VAR 0 3
57410: MINUS
57411: ST_TO_ADDR
// if y - r < 0 then
57412: LD_VAR 0 2
57416: PUSH
57417: LD_VAR 0 3
57421: MINUS
57422: PUSH
57423: LD_INT 0
57425: LESS
57426: IFFALSE 57438
// min_y := 0 else
57428: LD_ADDR_VAR 0 7
57432: PUSH
57433: LD_INT 0
57435: ST_TO_ADDR
57436: GO 57454
// min_y := y - r ;
57438: LD_ADDR_VAR 0 7
57442: PUSH
57443: LD_VAR 0 2
57447: PUSH
57448: LD_VAR 0 3
57452: MINUS
57453: ST_TO_ADDR
// max_x := x + r ;
57454: LD_ADDR_VAR 0 9
57458: PUSH
57459: LD_VAR 0 1
57463: PUSH
57464: LD_VAR 0 3
57468: PLUS
57469: ST_TO_ADDR
// max_y := y + r ;
57470: LD_ADDR_VAR 0 10
57474: PUSH
57475: LD_VAR 0 2
57479: PUSH
57480: LD_VAR 0 3
57484: PLUS
57485: ST_TO_ADDR
// for _x = min_x to max_x do
57486: LD_ADDR_VAR 0 5
57490: PUSH
57491: DOUBLE
57492: LD_VAR 0 8
57496: DEC
57497: ST_TO_ADDR
57498: LD_VAR 0 9
57502: PUSH
57503: FOR_TO
57504: IFFALSE 57605
// for _y = min_y to max_y do
57506: LD_ADDR_VAR 0 6
57510: PUSH
57511: DOUBLE
57512: LD_VAR 0 7
57516: DEC
57517: ST_TO_ADDR
57518: LD_VAR 0 10
57522: PUSH
57523: FOR_TO
57524: IFFALSE 57601
// begin if not ValidHex ( _x , _y ) then
57526: LD_VAR 0 5
57530: PPUSH
57531: LD_VAR 0 6
57535: PPUSH
57536: CALL_OW 488
57540: NOT
57541: IFFALSE 57545
// continue ;
57543: GO 57523
// if GetResourceTypeXY ( _x , _y ) then
57545: LD_VAR 0 5
57549: PPUSH
57550: LD_VAR 0 6
57554: PPUSH
57555: CALL_OW 283
57559: IFFALSE 57599
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
57561: LD_ADDR_VAR 0 4
57565: PUSH
57566: LD_VAR 0 4
57570: PPUSH
57571: LD_VAR 0 4
57575: PUSH
57576: LD_INT 1
57578: PLUS
57579: PPUSH
57580: LD_VAR 0 5
57584: PUSH
57585: LD_VAR 0 6
57589: PUSH
57590: EMPTY
57591: LIST
57592: LIST
57593: PPUSH
57594: CALL_OW 1
57598: ST_TO_ADDR
// end ;
57599: GO 57523
57601: POP
57602: POP
57603: GO 57503
57605: POP
57606: POP
// end ;
57607: LD_VAR 0 4
57611: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
57612: LD_INT 0
57614: PPUSH
57615: PPUSH
57616: PPUSH
57617: PPUSH
57618: PPUSH
57619: PPUSH
57620: PPUSH
57621: PPUSH
// if not units then
57622: LD_VAR 0 1
57626: NOT
57627: IFFALSE 57631
// exit ;
57629: GO 58159
// result := UnitFilter ( units , [ f_ok ] ) ;
57631: LD_ADDR_VAR 0 3
57635: PUSH
57636: LD_VAR 0 1
57640: PPUSH
57641: LD_INT 50
57643: PUSH
57644: EMPTY
57645: LIST
57646: PPUSH
57647: CALL_OW 72
57651: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
57652: LD_ADDR_VAR 0 8
57656: PUSH
57657: LD_VAR 0 1
57661: PUSH
57662: LD_INT 1
57664: ARRAY
57665: PPUSH
57666: CALL_OW 255
57670: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
57671: LD_ADDR_VAR 0 10
57675: PUSH
57676: LD_INT 29
57678: PUSH
57679: LD_INT 91
57681: PUSH
57682: LD_INT 49
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: LIST
57689: ST_TO_ADDR
// if not result then
57690: LD_VAR 0 3
57694: NOT
57695: IFFALSE 57699
// exit ;
57697: GO 58159
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
57699: LD_ADDR_VAR 0 5
57703: PUSH
57704: LD_INT 81
57706: PUSH
57707: LD_VAR 0 8
57711: PUSH
57712: EMPTY
57713: LIST
57714: LIST
57715: PPUSH
57716: CALL_OW 69
57720: ST_TO_ADDR
// for i in result do
57721: LD_ADDR_VAR 0 4
57725: PUSH
57726: LD_VAR 0 3
57730: PUSH
57731: FOR_IN
57732: IFFALSE 58157
// begin tag := GetTag ( i ) + 1 ;
57734: LD_ADDR_VAR 0 9
57738: PUSH
57739: LD_VAR 0 4
57743: PPUSH
57744: CALL_OW 110
57748: PUSH
57749: LD_INT 1
57751: PLUS
57752: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
57753: LD_ADDR_VAR 0 7
57757: PUSH
57758: LD_VAR 0 4
57762: PPUSH
57763: CALL_OW 250
57767: PPUSH
57768: LD_VAR 0 4
57772: PPUSH
57773: CALL_OW 251
57777: PPUSH
57778: LD_INT 4
57780: PPUSH
57781: CALL 57354 0 3
57785: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
57786: LD_VAR 0 4
57790: PPUSH
57791: CALL_OW 247
57795: PUSH
57796: LD_INT 2
57798: EQUAL
57799: PUSH
57800: LD_VAR 0 7
57804: PUSH
57805: LD_INT 2
57807: GREATER
57808: AND
57809: PUSH
57810: LD_VAR 0 4
57814: PPUSH
57815: CALL_OW 264
57819: PUSH
57820: LD_VAR 0 10
57824: IN
57825: NOT
57826: AND
57827: IFFALSE 57866
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
57829: LD_VAR 0 4
57833: PPUSH
57834: LD_VAR 0 7
57838: PUSH
57839: LD_INT 1
57841: ARRAY
57842: PUSH
57843: LD_INT 1
57845: ARRAY
57846: PPUSH
57847: LD_VAR 0 7
57851: PUSH
57852: LD_INT 1
57854: ARRAY
57855: PUSH
57856: LD_INT 2
57858: ARRAY
57859: PPUSH
57860: CALL_OW 116
57864: GO 58155
// if path > tag then
57866: LD_VAR 0 2
57870: PUSH
57871: LD_VAR 0 9
57875: GREATER
57876: IFFALSE 58084
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57878: LD_ADDR_VAR 0 6
57882: PUSH
57883: LD_VAR 0 5
57887: PPUSH
57888: LD_INT 91
57890: PUSH
57891: LD_VAR 0 4
57895: PUSH
57896: LD_INT 8
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: LIST
57903: PPUSH
57904: CALL_OW 72
57908: ST_TO_ADDR
// if nearEnemy then
57909: LD_VAR 0 6
57913: IFFALSE 57982
// begin if GetWeapon ( i ) = ru_time_lapser then
57915: LD_VAR 0 4
57919: PPUSH
57920: CALL_OW 264
57924: PUSH
57925: LD_INT 49
57927: EQUAL
57928: IFFALSE 57956
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57930: LD_VAR 0 4
57934: PPUSH
57935: LD_VAR 0 6
57939: PPUSH
57940: LD_VAR 0 4
57944: PPUSH
57945: CALL_OW 74
57949: PPUSH
57950: CALL_OW 112
57954: GO 57980
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
57956: LD_VAR 0 4
57960: PPUSH
57961: LD_VAR 0 6
57965: PPUSH
57966: LD_VAR 0 4
57970: PPUSH
57971: CALL_OW 74
57975: PPUSH
57976: CALL 59230 0 2
// end else
57980: GO 58082
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
57982: LD_VAR 0 4
57986: PPUSH
57987: LD_VAR 0 2
57991: PUSH
57992: LD_VAR 0 9
57996: ARRAY
57997: PUSH
57998: LD_INT 1
58000: ARRAY
58001: PPUSH
58002: LD_VAR 0 2
58006: PUSH
58007: LD_VAR 0 9
58011: ARRAY
58012: PUSH
58013: LD_INT 2
58015: ARRAY
58016: PPUSH
58017: CALL_OW 297
58021: PUSH
58022: LD_INT 6
58024: GREATER
58025: IFFALSE 58068
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58027: LD_VAR 0 4
58031: PPUSH
58032: LD_VAR 0 2
58036: PUSH
58037: LD_VAR 0 9
58041: ARRAY
58042: PUSH
58043: LD_INT 1
58045: ARRAY
58046: PPUSH
58047: LD_VAR 0 2
58051: PUSH
58052: LD_VAR 0 9
58056: ARRAY
58057: PUSH
58058: LD_INT 2
58060: ARRAY
58061: PPUSH
58062: CALL_OW 114
58066: GO 58082
// SetTag ( i , tag ) ;
58068: LD_VAR 0 4
58072: PPUSH
58073: LD_VAR 0 9
58077: PPUSH
58078: CALL_OW 109
// end else
58082: GO 58155
// if enemy then
58084: LD_VAR 0 5
58088: IFFALSE 58155
// begin if GetWeapon ( i ) = ru_time_lapser then
58090: LD_VAR 0 4
58094: PPUSH
58095: CALL_OW 264
58099: PUSH
58100: LD_INT 49
58102: EQUAL
58103: IFFALSE 58131
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58105: LD_VAR 0 4
58109: PPUSH
58110: LD_VAR 0 5
58114: PPUSH
58115: LD_VAR 0 4
58119: PPUSH
58120: CALL_OW 74
58124: PPUSH
58125: CALL_OW 112
58129: GO 58155
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58131: LD_VAR 0 4
58135: PPUSH
58136: LD_VAR 0 5
58140: PPUSH
58141: LD_VAR 0 4
58145: PPUSH
58146: CALL_OW 74
58150: PPUSH
58151: CALL 59230 0 2
// end ; end ;
58155: GO 57731
58157: POP
58158: POP
// end ;
58159: LD_VAR 0 3
58163: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58164: LD_INT 0
58166: PPUSH
58167: PPUSH
58168: PPUSH
// if not unit or IsInUnit ( unit ) then
58169: LD_VAR 0 1
58173: NOT
58174: PUSH
58175: LD_VAR 0 1
58179: PPUSH
58180: CALL_OW 310
58184: OR
58185: IFFALSE 58189
// exit ;
58187: GO 58280
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58189: LD_ADDR_VAR 0 4
58193: PUSH
58194: LD_VAR 0 1
58198: PPUSH
58199: CALL_OW 250
58203: PPUSH
58204: LD_VAR 0 2
58208: PPUSH
58209: LD_INT 1
58211: PPUSH
58212: CALL_OW 272
58216: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58217: LD_ADDR_VAR 0 5
58221: PUSH
58222: LD_VAR 0 1
58226: PPUSH
58227: CALL_OW 251
58231: PPUSH
58232: LD_VAR 0 2
58236: PPUSH
58237: LD_INT 1
58239: PPUSH
58240: CALL_OW 273
58244: ST_TO_ADDR
// if ValidHex ( x , y ) then
58245: LD_VAR 0 4
58249: PPUSH
58250: LD_VAR 0 5
58254: PPUSH
58255: CALL_OW 488
58259: IFFALSE 58280
// ComTurnXY ( unit , x , y ) ;
58261: LD_VAR 0 1
58265: PPUSH
58266: LD_VAR 0 4
58270: PPUSH
58271: LD_VAR 0 5
58275: PPUSH
58276: CALL_OW 118
// end ;
58280: LD_VAR 0 3
58284: RET
// export function SeeUnits ( side , units ) ; var i ; begin
58285: LD_INT 0
58287: PPUSH
58288: PPUSH
// result := false ;
58289: LD_ADDR_VAR 0 3
58293: PUSH
58294: LD_INT 0
58296: ST_TO_ADDR
// if not units then
58297: LD_VAR 0 2
58301: NOT
58302: IFFALSE 58306
// exit ;
58304: GO 58351
// for i in units do
58306: LD_ADDR_VAR 0 4
58310: PUSH
58311: LD_VAR 0 2
58315: PUSH
58316: FOR_IN
58317: IFFALSE 58349
// if See ( side , i ) then
58319: LD_VAR 0 1
58323: PPUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: CALL_OW 292
58333: IFFALSE 58347
// begin result := true ;
58335: LD_ADDR_VAR 0 3
58339: PUSH
58340: LD_INT 1
58342: ST_TO_ADDR
// exit ;
58343: POP
58344: POP
58345: GO 58351
// end ;
58347: GO 58316
58349: POP
58350: POP
// end ;
58351: LD_VAR 0 3
58355: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
58356: LD_INT 0
58358: PPUSH
58359: PPUSH
58360: PPUSH
58361: PPUSH
// if not unit or not points then
58362: LD_VAR 0 1
58366: NOT
58367: PUSH
58368: LD_VAR 0 2
58372: NOT
58373: OR
58374: IFFALSE 58378
// exit ;
58376: GO 58468
// dist := 99999 ;
58378: LD_ADDR_VAR 0 5
58382: PUSH
58383: LD_INT 99999
58385: ST_TO_ADDR
// for i in points do
58386: LD_ADDR_VAR 0 4
58390: PUSH
58391: LD_VAR 0 2
58395: PUSH
58396: FOR_IN
58397: IFFALSE 58466
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58399: LD_ADDR_VAR 0 6
58403: PUSH
58404: LD_VAR 0 1
58408: PPUSH
58409: LD_VAR 0 4
58413: PUSH
58414: LD_INT 1
58416: ARRAY
58417: PPUSH
58418: LD_VAR 0 4
58422: PUSH
58423: LD_INT 2
58425: ARRAY
58426: PPUSH
58427: CALL_OW 297
58431: ST_TO_ADDR
// if tmpDist < dist then
58432: LD_VAR 0 6
58436: PUSH
58437: LD_VAR 0 5
58441: LESS
58442: IFFALSE 58464
// begin result := i ;
58444: LD_ADDR_VAR 0 3
58448: PUSH
58449: LD_VAR 0 4
58453: ST_TO_ADDR
// dist := tmpDist ;
58454: LD_ADDR_VAR 0 5
58458: PUSH
58459: LD_VAR 0 6
58463: ST_TO_ADDR
// end ; end ;
58464: GO 58396
58466: POP
58467: POP
// end ;
58468: LD_VAR 0 3
58472: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
58473: LD_INT 0
58475: PPUSH
// uc_side := side ;
58476: LD_ADDR_OWVAR 20
58480: PUSH
58481: LD_VAR 0 1
58485: ST_TO_ADDR
// uc_nation := 3 ;
58486: LD_ADDR_OWVAR 21
58490: PUSH
58491: LD_INT 3
58493: ST_TO_ADDR
// vc_chassis := 25 ;
58494: LD_ADDR_OWVAR 37
58498: PUSH
58499: LD_INT 25
58501: ST_TO_ADDR
// vc_engine := engine_siberite ;
58502: LD_ADDR_OWVAR 39
58506: PUSH
58507: LD_INT 3
58509: ST_TO_ADDR
// vc_control := control_computer ;
58510: LD_ADDR_OWVAR 38
58514: PUSH
58515: LD_INT 3
58517: ST_TO_ADDR
// vc_weapon := 59 ;
58518: LD_ADDR_OWVAR 40
58522: PUSH
58523: LD_INT 59
58525: ST_TO_ADDR
// result := CreateVehicle ;
58526: LD_ADDR_VAR 0 5
58530: PUSH
58531: CALL_OW 45
58535: ST_TO_ADDR
// SetDir ( result , d ) ;
58536: LD_VAR 0 5
58540: PPUSH
58541: LD_VAR 0 4
58545: PPUSH
58546: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
58550: LD_VAR 0 5
58554: PPUSH
58555: LD_VAR 0 2
58559: PPUSH
58560: LD_VAR 0 3
58564: PPUSH
58565: LD_INT 0
58567: PPUSH
58568: CALL_OW 48
// end ;
58572: LD_VAR 0 5
58576: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
58577: LD_INT 0
58579: PPUSH
58580: PPUSH
58581: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
58582: LD_ADDR_VAR 0 2
58586: PUSH
58587: LD_INT 0
58589: PUSH
58590: LD_INT 0
58592: PUSH
58593: LD_INT 0
58595: PUSH
58596: LD_INT 0
58598: PUSH
58599: EMPTY
58600: LIST
58601: LIST
58602: LIST
58603: LIST
58604: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
58605: LD_VAR 0 1
58609: NOT
58610: PUSH
58611: LD_VAR 0 1
58615: PPUSH
58616: CALL_OW 264
58620: PUSH
58621: LD_INT 12
58623: PUSH
58624: LD_INT 51
58626: PUSH
58627: LD_INT 32
58629: PUSH
58630: LD_INT 89
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: LIST
58637: LIST
58638: IN
58639: NOT
58640: OR
58641: IFFALSE 58645
// exit ;
58643: GO 58743
// for i := 1 to 3 do
58645: LD_ADDR_VAR 0 3
58649: PUSH
58650: DOUBLE
58651: LD_INT 1
58653: DEC
58654: ST_TO_ADDR
58655: LD_INT 3
58657: PUSH
58658: FOR_TO
58659: IFFALSE 58741
// begin tmp := GetCargo ( cargo , i ) ;
58661: LD_ADDR_VAR 0 4
58665: PUSH
58666: LD_VAR 0 1
58670: PPUSH
58671: LD_VAR 0 3
58675: PPUSH
58676: CALL_OW 289
58680: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
58681: LD_ADDR_VAR 0 2
58685: PUSH
58686: LD_VAR 0 2
58690: PPUSH
58691: LD_VAR 0 3
58695: PPUSH
58696: LD_VAR 0 4
58700: PPUSH
58701: CALL_OW 1
58705: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
58706: LD_ADDR_VAR 0 2
58710: PUSH
58711: LD_VAR 0 2
58715: PPUSH
58716: LD_INT 4
58718: PPUSH
58719: LD_VAR 0 2
58723: PUSH
58724: LD_INT 4
58726: ARRAY
58727: PUSH
58728: LD_VAR 0 4
58732: PLUS
58733: PPUSH
58734: CALL_OW 1
58738: ST_TO_ADDR
// end ;
58739: GO 58658
58741: POP
58742: POP
// end ;
58743: LD_VAR 0 2
58747: RET
// export function Length ( array ) ; begin
58748: LD_INT 0
58750: PPUSH
// result := array + 0 ;
58751: LD_ADDR_VAR 0 2
58755: PUSH
58756: LD_VAR 0 1
58760: PUSH
58761: LD_INT 0
58763: PLUS
58764: ST_TO_ADDR
// end ;
58765: LD_VAR 0 2
58769: RET
// export function PrepareArray ( array ) ; begin
58770: LD_INT 0
58772: PPUSH
// result := array diff 0 ;
58773: LD_ADDR_VAR 0 2
58777: PUSH
58778: LD_VAR 0 1
58782: PUSH
58783: LD_INT 0
58785: DIFF
58786: ST_TO_ADDR
// if not result [ 1 ] then
58787: LD_VAR 0 2
58791: PUSH
58792: LD_INT 1
58794: ARRAY
58795: NOT
58796: IFFALSE 58816
// result := Delete ( result , 1 ) ;
58798: LD_ADDR_VAR 0 2
58802: PUSH
58803: LD_VAR 0 2
58807: PPUSH
58808: LD_INT 1
58810: PPUSH
58811: CALL_OW 3
58815: ST_TO_ADDR
// end ;
58816: LD_VAR 0 2
58820: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
58821: LD_INT 0
58823: PPUSH
58824: PPUSH
58825: PPUSH
58826: PPUSH
// sibRocketRange := 25 ;
58827: LD_ADDR_VAR 0 6
58831: PUSH
58832: LD_INT 25
58834: ST_TO_ADDR
// result := false ;
58835: LD_ADDR_VAR 0 4
58839: PUSH
58840: LD_INT 0
58842: ST_TO_ADDR
// for i := 0 to 5 do
58843: LD_ADDR_VAR 0 5
58847: PUSH
58848: DOUBLE
58849: LD_INT 0
58851: DEC
58852: ST_TO_ADDR
58853: LD_INT 5
58855: PUSH
58856: FOR_TO
58857: IFFALSE 58924
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
58859: LD_VAR 0 1
58863: PPUSH
58864: LD_VAR 0 5
58868: PPUSH
58869: LD_VAR 0 6
58873: PPUSH
58874: CALL_OW 272
58878: PPUSH
58879: LD_VAR 0 2
58883: PPUSH
58884: LD_VAR 0 5
58888: PPUSH
58889: LD_VAR 0 6
58893: PPUSH
58894: CALL_OW 273
58898: PPUSH
58899: LD_VAR 0 3
58903: PPUSH
58904: CALL_OW 309
58908: IFFALSE 58922
// begin result := true ;
58910: LD_ADDR_VAR 0 4
58914: PUSH
58915: LD_INT 1
58917: ST_TO_ADDR
// exit ;
58918: POP
58919: POP
58920: GO 58926
// end ;
58922: GO 58856
58924: POP
58925: POP
// end ;
58926: LD_VAR 0 4
58930: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
58931: LD_INT 0
58933: PPUSH
58934: PPUSH
58935: PPUSH
// if btype = b_depot then
58936: LD_VAR 0 2
58940: PUSH
58941: LD_INT 0
58943: EQUAL
58944: IFFALSE 58956
// begin result := true ;
58946: LD_ADDR_VAR 0 3
58950: PUSH
58951: LD_INT 1
58953: ST_TO_ADDR
// exit ;
58954: GO 59072
// end ; pom := GetBase ( depot ) ;
58956: LD_ADDR_VAR 0 4
58960: PUSH
58961: LD_VAR 0 1
58965: PPUSH
58966: CALL_OW 274
58970: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
58971: LD_ADDR_VAR 0 5
58975: PUSH
58976: LD_VAR 0 2
58980: PPUSH
58981: LD_VAR 0 1
58985: PPUSH
58986: CALL_OW 248
58990: PPUSH
58991: CALL_OW 450
58995: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
58996: LD_ADDR_VAR 0 3
59000: PUSH
59001: LD_VAR 0 4
59005: PPUSH
59006: LD_INT 1
59008: PPUSH
59009: CALL_OW 275
59013: PUSH
59014: LD_VAR 0 5
59018: PUSH
59019: LD_INT 1
59021: ARRAY
59022: GREATEREQUAL
59023: PUSH
59024: LD_VAR 0 4
59028: PPUSH
59029: LD_INT 2
59031: PPUSH
59032: CALL_OW 275
59036: PUSH
59037: LD_VAR 0 5
59041: PUSH
59042: LD_INT 2
59044: ARRAY
59045: GREATEREQUAL
59046: AND
59047: PUSH
59048: LD_VAR 0 4
59052: PPUSH
59053: LD_INT 3
59055: PPUSH
59056: CALL_OW 275
59060: PUSH
59061: LD_VAR 0 5
59065: PUSH
59066: LD_INT 3
59068: ARRAY
59069: GREATEREQUAL
59070: AND
59071: ST_TO_ADDR
// end ;
59072: LD_VAR 0 3
59076: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59077: LD_INT 0
59079: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59080: LD_VAR 0 1
59084: PPUSH
59085: LD_VAR 0 2
59089: PPUSH
59090: LD_INT 0
59092: PPUSH
59093: LD_INT 0
59095: PPUSH
59096: LD_INT 1
59098: PPUSH
59099: LD_INT 0
59101: PPUSH
59102: CALL_OW 587
// end ;
59106: LD_VAR 0 3
59110: RET
// export function CenterOnNow ( unit ) ; begin
59111: LD_INT 0
59113: PPUSH
// result := IsInUnit ( unit ) ;
59114: LD_ADDR_VAR 0 2
59118: PUSH
59119: LD_VAR 0 1
59123: PPUSH
59124: CALL_OW 310
59128: ST_TO_ADDR
// if not result then
59129: LD_VAR 0 2
59133: NOT
59134: IFFALSE 59146
// result := unit ;
59136: LD_ADDR_VAR 0 2
59140: PUSH
59141: LD_VAR 0 1
59145: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59146: LD_VAR 0 1
59150: PPUSH
59151: CALL_OW 87
// end ;
59155: LD_VAR 0 2
59159: RET
// export function ComMoveHex ( unit , hex ) ; begin
59160: LD_INT 0
59162: PPUSH
// if not hex then
59163: LD_VAR 0 2
59167: NOT
59168: IFFALSE 59172
// exit ;
59170: GO 59225
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59172: LD_VAR 0 2
59176: PUSH
59177: LD_INT 1
59179: ARRAY
59180: PPUSH
59181: LD_VAR 0 2
59185: PUSH
59186: LD_INT 2
59188: ARRAY
59189: PPUSH
59190: CALL_OW 428
59194: IFFALSE 59198
// exit ;
59196: GO 59225
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59198: LD_VAR 0 1
59202: PPUSH
59203: LD_VAR 0 2
59207: PUSH
59208: LD_INT 1
59210: ARRAY
59211: PPUSH
59212: LD_VAR 0 2
59216: PUSH
59217: LD_INT 2
59219: ARRAY
59220: PPUSH
59221: CALL_OW 111
// end ;
59225: LD_VAR 0 3
59229: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
59230: LD_INT 0
59232: PPUSH
59233: PPUSH
59234: PPUSH
// if not unit or not enemy then
59235: LD_VAR 0 1
59239: NOT
59240: PUSH
59241: LD_VAR 0 2
59245: NOT
59246: OR
59247: IFFALSE 59251
// exit ;
59249: GO 59375
// x := GetX ( enemy ) ;
59251: LD_ADDR_VAR 0 4
59255: PUSH
59256: LD_VAR 0 2
59260: PPUSH
59261: CALL_OW 250
59265: ST_TO_ADDR
// y := GetY ( enemy ) ;
59266: LD_ADDR_VAR 0 5
59270: PUSH
59271: LD_VAR 0 2
59275: PPUSH
59276: CALL_OW 251
59280: ST_TO_ADDR
// if ValidHex ( x , y ) then
59281: LD_VAR 0 4
59285: PPUSH
59286: LD_VAR 0 5
59290: PPUSH
59291: CALL_OW 488
59295: IFFALSE 59375
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
59297: LD_VAR 0 2
59301: PPUSH
59302: CALL_OW 247
59306: PUSH
59307: LD_INT 3
59309: PUSH
59310: LD_INT 2
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: IN
59317: PUSH
59318: LD_VAR 0 1
59322: PPUSH
59323: CALL_OW 255
59327: PPUSH
59328: LD_VAR 0 2
59332: PPUSH
59333: CALL_OW 292
59337: OR
59338: IFFALSE 59356
// ComAttackUnit ( unit , enemy ) else
59340: LD_VAR 0 1
59344: PPUSH
59345: LD_VAR 0 2
59349: PPUSH
59350: CALL_OW 115
59354: GO 59375
// ComAgressiveMove ( unit , x , y ) ;
59356: LD_VAR 0 1
59360: PPUSH
59361: LD_VAR 0 4
59365: PPUSH
59366: LD_VAR 0 5
59370: PPUSH
59371: CALL_OW 114
// end ;
59375: LD_VAR 0 3
59379: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
59380: LD_INT 0
59382: PPUSH
59383: PPUSH
59384: PPUSH
// list := AreaToList ( area , 0 ) ;
59385: LD_ADDR_VAR 0 5
59389: PUSH
59390: LD_VAR 0 1
59394: PPUSH
59395: LD_INT 0
59397: PPUSH
59398: CALL_OW 517
59402: ST_TO_ADDR
// if not list then
59403: LD_VAR 0 5
59407: NOT
59408: IFFALSE 59412
// exit ;
59410: GO 59542
// if all then
59412: LD_VAR 0 2
59416: IFFALSE 59504
// begin for i := 1 to list [ 1 ] do
59418: LD_ADDR_VAR 0 4
59422: PUSH
59423: DOUBLE
59424: LD_INT 1
59426: DEC
59427: ST_TO_ADDR
59428: LD_VAR 0 5
59432: PUSH
59433: LD_INT 1
59435: ARRAY
59436: PUSH
59437: FOR_TO
59438: IFFALSE 59500
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
59440: LD_ADDR_VAR 0 3
59444: PUSH
59445: LD_VAR 0 3
59449: PPUSH
59450: LD_VAR 0 3
59454: PUSH
59455: LD_INT 1
59457: PLUS
59458: PPUSH
59459: LD_VAR 0 5
59463: PUSH
59464: LD_INT 1
59466: ARRAY
59467: PUSH
59468: LD_VAR 0 4
59472: ARRAY
59473: PUSH
59474: LD_VAR 0 5
59478: PUSH
59479: LD_INT 2
59481: ARRAY
59482: PUSH
59483: LD_VAR 0 4
59487: ARRAY
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: PPUSH
59493: CALL_OW 1
59497: ST_TO_ADDR
59498: GO 59437
59500: POP
59501: POP
// exit ;
59502: GO 59542
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
59504: LD_ADDR_VAR 0 3
59508: PUSH
59509: LD_VAR 0 5
59513: PUSH
59514: LD_INT 1
59516: ARRAY
59517: PUSH
59518: LD_INT 1
59520: ARRAY
59521: PUSH
59522: LD_VAR 0 5
59526: PUSH
59527: LD_INT 2
59529: ARRAY
59530: PUSH
59531: LD_INT 1
59533: ARRAY
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: PUSH
59539: EMPTY
59540: LIST
59541: ST_TO_ADDR
// end ;
59542: LD_VAR 0 3
59546: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
59547: LD_INT 0
59549: PPUSH
59550: PPUSH
// list := AreaToList ( area , 0 ) ;
59551: LD_ADDR_VAR 0 4
59555: PUSH
59556: LD_VAR 0 1
59560: PPUSH
59561: LD_INT 0
59563: PPUSH
59564: CALL_OW 517
59568: ST_TO_ADDR
// if not list then
59569: LD_VAR 0 4
59573: NOT
59574: IFFALSE 59578
// exit ;
59576: GO 59619
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
59578: LD_ADDR_VAR 0 3
59582: PUSH
59583: LD_VAR 0 4
59587: PUSH
59588: LD_INT 1
59590: ARRAY
59591: PUSH
59592: LD_INT 1
59594: ARRAY
59595: PUSH
59596: LD_VAR 0 4
59600: PUSH
59601: LD_INT 2
59603: ARRAY
59604: PUSH
59605: LD_INT 1
59607: ARRAY
59608: PUSH
59609: LD_VAR 0 2
59613: PUSH
59614: EMPTY
59615: LIST
59616: LIST
59617: LIST
59618: ST_TO_ADDR
// end ;
59619: LD_VAR 0 3
59623: RET
// export function First ( array ) ; begin
59624: LD_INT 0
59626: PPUSH
// if not array then
59627: LD_VAR 0 1
59631: NOT
59632: IFFALSE 59636
// exit ;
59634: GO 59650
// result := array [ 1 ] ;
59636: LD_ADDR_VAR 0 2
59640: PUSH
59641: LD_VAR 0 1
59645: PUSH
59646: LD_INT 1
59648: ARRAY
59649: ST_TO_ADDR
// end ;
59650: LD_VAR 0 2
59654: RET
// export function Last ( array ) ; begin
59655: LD_INT 0
59657: PPUSH
// if not array then
59658: LD_VAR 0 1
59662: NOT
59663: IFFALSE 59667
// exit ;
59665: GO 59683
// result := array [ array ] ;
59667: LD_ADDR_VAR 0 2
59671: PUSH
59672: LD_VAR 0 1
59676: PUSH
59677: LD_VAR 0 1
59681: ARRAY
59682: ST_TO_ADDR
// end ;
59683: LD_VAR 0 2
59687: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
59688: LD_INT 0
59690: PPUSH
59691: PPUSH
// result := [ ] ;
59692: LD_ADDR_VAR 0 5
59696: PUSH
59697: EMPTY
59698: ST_TO_ADDR
// if not array then
59699: LD_VAR 0 1
59703: NOT
59704: IFFALSE 59708
// exit ;
59706: GO 59820
// for i := 1 to array do
59708: LD_ADDR_VAR 0 6
59712: PUSH
59713: DOUBLE
59714: LD_INT 1
59716: DEC
59717: ST_TO_ADDR
59718: LD_VAR 0 1
59722: PUSH
59723: FOR_TO
59724: IFFALSE 59818
// if array [ i ] [ index ] = value then
59726: LD_VAR 0 1
59730: PUSH
59731: LD_VAR 0 6
59735: ARRAY
59736: PUSH
59737: LD_VAR 0 2
59741: ARRAY
59742: PUSH
59743: LD_VAR 0 3
59747: EQUAL
59748: IFFALSE 59816
// begin if indexColumn then
59750: LD_VAR 0 4
59754: IFFALSE 59790
// result := Join ( result , array [ i ] [ indexColumn ] ) else
59756: LD_ADDR_VAR 0 5
59760: PUSH
59761: LD_VAR 0 5
59765: PPUSH
59766: LD_VAR 0 1
59770: PUSH
59771: LD_VAR 0 6
59775: ARRAY
59776: PUSH
59777: LD_VAR 0 4
59781: ARRAY
59782: PPUSH
59783: CALL 55008 0 2
59787: ST_TO_ADDR
59788: GO 59816
// result := Join ( result , array [ i ] ) ;
59790: LD_ADDR_VAR 0 5
59794: PUSH
59795: LD_VAR 0 5
59799: PPUSH
59800: LD_VAR 0 1
59804: PUSH
59805: LD_VAR 0 6
59809: ARRAY
59810: PPUSH
59811: CALL 55008 0 2
59815: ST_TO_ADDR
// end ;
59816: GO 59723
59818: POP
59819: POP
// end ;
59820: LD_VAR 0 5
59824: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
59825: LD_INT 0
59827: PPUSH
// if not vehicles or not parkingPoint then
59828: LD_VAR 0 1
59832: NOT
59833: PUSH
59834: LD_VAR 0 2
59838: NOT
59839: OR
59840: IFFALSE 59844
// exit ;
59842: GO 59942
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
59844: LD_ADDR_VAR 0 1
59848: PUSH
59849: LD_VAR 0 1
59853: PPUSH
59854: LD_INT 50
59856: PUSH
59857: EMPTY
59858: LIST
59859: PUSH
59860: LD_INT 3
59862: PUSH
59863: LD_INT 92
59865: PUSH
59866: LD_VAR 0 2
59870: PUSH
59871: LD_INT 1
59873: ARRAY
59874: PUSH
59875: LD_VAR 0 2
59879: PUSH
59880: LD_INT 2
59882: ARRAY
59883: PUSH
59884: LD_INT 8
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: LIST
59891: LIST
59892: PUSH
59893: EMPTY
59894: LIST
59895: LIST
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PPUSH
59901: CALL_OW 72
59905: ST_TO_ADDR
// if not vehicles then
59906: LD_VAR 0 1
59910: NOT
59911: IFFALSE 59915
// exit ;
59913: GO 59942
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59915: LD_VAR 0 1
59919: PPUSH
59920: LD_VAR 0 2
59924: PUSH
59925: LD_INT 1
59927: ARRAY
59928: PPUSH
59929: LD_VAR 0 2
59933: PUSH
59934: LD_INT 2
59936: ARRAY
59937: PPUSH
59938: CALL_OW 111
// end ;
59942: LD_VAR 0 3
59946: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
59947: LD_INT 0
59949: PPUSH
59950: PPUSH
59951: PPUSH
// if not side or not area then
59952: LD_VAR 0 1
59956: NOT
59957: PUSH
59958: LD_VAR 0 2
59962: NOT
59963: OR
59964: IFFALSE 59968
// exit ;
59966: GO 60087
// tmp := AreaToList ( area , 0 ) ;
59968: LD_ADDR_VAR 0 5
59972: PUSH
59973: LD_VAR 0 2
59977: PPUSH
59978: LD_INT 0
59980: PPUSH
59981: CALL_OW 517
59985: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
59986: LD_ADDR_VAR 0 4
59990: PUSH
59991: DOUBLE
59992: LD_INT 1
59994: DEC
59995: ST_TO_ADDR
59996: LD_VAR 0 5
60000: PUSH
60001: LD_INT 1
60003: ARRAY
60004: PUSH
60005: FOR_TO
60006: IFFALSE 60085
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
60008: LD_VAR 0 5
60012: PUSH
60013: LD_INT 1
60015: ARRAY
60016: PUSH
60017: LD_VAR 0 4
60021: ARRAY
60022: PPUSH
60023: LD_VAR 0 5
60027: PUSH
60028: LD_INT 2
60030: ARRAY
60031: PUSH
60032: LD_VAR 0 4
60036: ARRAY
60037: PPUSH
60038: CALL_OW 351
60042: IFFALSE 60083
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60044: LD_VAR 0 5
60048: PUSH
60049: LD_INT 1
60051: ARRAY
60052: PUSH
60053: LD_VAR 0 4
60057: ARRAY
60058: PPUSH
60059: LD_VAR 0 5
60063: PUSH
60064: LD_INT 2
60066: ARRAY
60067: PUSH
60068: LD_VAR 0 4
60072: ARRAY
60073: PPUSH
60074: LD_VAR 0 1
60078: PPUSH
60079: CALL_OW 244
// end ;
60083: GO 60005
60085: POP
60086: POP
// end ; end_of_file
60087: LD_VAR 0 3
60091: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60092: LD_INT 0
60094: PPUSH
60095: PPUSH
// skirmish := false ;
60096: LD_ADDR_EXP 61
60100: PUSH
60101: LD_INT 0
60103: ST_TO_ADDR
// debug_mc := false ;
60104: LD_ADDR_EXP 62
60108: PUSH
60109: LD_INT 0
60111: ST_TO_ADDR
// mc_bases := [ ] ;
60112: LD_ADDR_EXP 63
60116: PUSH
60117: EMPTY
60118: ST_TO_ADDR
// mc_sides := [ ] ;
60119: LD_ADDR_EXP 89
60123: PUSH
60124: EMPTY
60125: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60126: LD_ADDR_EXP 64
60130: PUSH
60131: EMPTY
60132: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60133: LD_ADDR_EXP 65
60137: PUSH
60138: EMPTY
60139: ST_TO_ADDR
// mc_need_heal := [ ] ;
60140: LD_ADDR_EXP 66
60144: PUSH
60145: EMPTY
60146: ST_TO_ADDR
// mc_healers := [ ] ;
60147: LD_ADDR_EXP 67
60151: PUSH
60152: EMPTY
60153: ST_TO_ADDR
// mc_build_list := [ ] ;
60154: LD_ADDR_EXP 68
60158: PUSH
60159: EMPTY
60160: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60161: LD_ADDR_EXP 95
60165: PUSH
60166: EMPTY
60167: ST_TO_ADDR
// mc_builders := [ ] ;
60168: LD_ADDR_EXP 69
60172: PUSH
60173: EMPTY
60174: ST_TO_ADDR
// mc_construct_list := [ ] ;
60175: LD_ADDR_EXP 70
60179: PUSH
60180: EMPTY
60181: ST_TO_ADDR
// mc_turret_list := [ ] ;
60182: LD_ADDR_EXP 71
60186: PUSH
60187: EMPTY
60188: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
60189: LD_ADDR_EXP 72
60193: PUSH
60194: EMPTY
60195: ST_TO_ADDR
// mc_miners := [ ] ;
60196: LD_ADDR_EXP 77
60200: PUSH
60201: EMPTY
60202: ST_TO_ADDR
// mc_mines := [ ] ;
60203: LD_ADDR_EXP 76
60207: PUSH
60208: EMPTY
60209: ST_TO_ADDR
// mc_minefields := [ ] ;
60210: LD_ADDR_EXP 78
60214: PUSH
60215: EMPTY
60216: ST_TO_ADDR
// mc_crates := [ ] ;
60217: LD_ADDR_EXP 79
60221: PUSH
60222: EMPTY
60223: ST_TO_ADDR
// mc_crates_collector := [ ] ;
60224: LD_ADDR_EXP 80
60228: PUSH
60229: EMPTY
60230: ST_TO_ADDR
// mc_crates_area := [ ] ;
60231: LD_ADDR_EXP 81
60235: PUSH
60236: EMPTY
60237: ST_TO_ADDR
// mc_vehicles := [ ] ;
60238: LD_ADDR_EXP 82
60242: PUSH
60243: EMPTY
60244: ST_TO_ADDR
// mc_attack := [ ] ;
60245: LD_ADDR_EXP 83
60249: PUSH
60250: EMPTY
60251: ST_TO_ADDR
// mc_produce := [ ] ;
60252: LD_ADDR_EXP 84
60256: PUSH
60257: EMPTY
60258: ST_TO_ADDR
// mc_defender := [ ] ;
60259: LD_ADDR_EXP 85
60263: PUSH
60264: EMPTY
60265: ST_TO_ADDR
// mc_parking := [ ] ;
60266: LD_ADDR_EXP 87
60270: PUSH
60271: EMPTY
60272: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
60273: LD_ADDR_EXP 73
60277: PUSH
60278: EMPTY
60279: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
60280: LD_ADDR_EXP 75
60284: PUSH
60285: EMPTY
60286: ST_TO_ADDR
// mc_scan := [ ] ;
60287: LD_ADDR_EXP 86
60291: PUSH
60292: EMPTY
60293: ST_TO_ADDR
// mc_scan_area := [ ] ;
60294: LD_ADDR_EXP 88
60298: PUSH
60299: EMPTY
60300: ST_TO_ADDR
// mc_tech := [ ] ;
60301: LD_ADDR_EXP 90
60305: PUSH
60306: EMPTY
60307: ST_TO_ADDR
// mc_class := [ ] ;
60308: LD_ADDR_EXP 104
60312: PUSH
60313: EMPTY
60314: ST_TO_ADDR
// mc_class_case_use := [ ] ;
60315: LD_ADDR_EXP 105
60319: PUSH
60320: EMPTY
60321: ST_TO_ADDR
// mc_is_defending := [ ] ;
60322: LD_ADDR_EXP 106
60326: PUSH
60327: EMPTY
60328: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
60329: LD_ADDR_EXP 97
60333: PUSH
60334: EMPTY
60335: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
60336: LD_ADDR_EXP 107
60340: PUSH
60341: LD_INT 0
60343: ST_TO_ADDR
// end ;
60344: LD_VAR 0 1
60348: RET
// export function MC_Kill ( base ) ; begin
60349: LD_INT 0
60351: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
60352: LD_ADDR_EXP 63
60356: PUSH
60357: LD_EXP 63
60361: PPUSH
60362: LD_VAR 0 1
60366: PPUSH
60367: EMPTY
60368: PPUSH
60369: CALL_OW 1
60373: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60374: LD_ADDR_EXP 64
60378: PUSH
60379: LD_EXP 64
60383: PPUSH
60384: LD_VAR 0 1
60388: PPUSH
60389: EMPTY
60390: PPUSH
60391: CALL_OW 1
60395: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60396: LD_ADDR_EXP 65
60400: PUSH
60401: LD_EXP 65
60405: PPUSH
60406: LD_VAR 0 1
60410: PPUSH
60411: EMPTY
60412: PPUSH
60413: CALL_OW 1
60417: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60418: LD_ADDR_EXP 66
60422: PUSH
60423: LD_EXP 66
60427: PPUSH
60428: LD_VAR 0 1
60432: PPUSH
60433: EMPTY
60434: PPUSH
60435: CALL_OW 1
60439: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60440: LD_ADDR_EXP 67
60444: PUSH
60445: LD_EXP 67
60449: PPUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: EMPTY
60456: PPUSH
60457: CALL_OW 1
60461: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60462: LD_ADDR_EXP 68
60466: PUSH
60467: LD_EXP 68
60471: PPUSH
60472: LD_VAR 0 1
60476: PPUSH
60477: EMPTY
60478: PPUSH
60479: CALL_OW 1
60483: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60484: LD_ADDR_EXP 69
60488: PUSH
60489: LD_EXP 69
60493: PPUSH
60494: LD_VAR 0 1
60498: PPUSH
60499: EMPTY
60500: PPUSH
60501: CALL_OW 1
60505: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60506: LD_ADDR_EXP 70
60510: PUSH
60511: LD_EXP 70
60515: PPUSH
60516: LD_VAR 0 1
60520: PPUSH
60521: EMPTY
60522: PPUSH
60523: CALL_OW 1
60527: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60528: LD_ADDR_EXP 71
60532: PUSH
60533: LD_EXP 71
60537: PPUSH
60538: LD_VAR 0 1
60542: PPUSH
60543: EMPTY
60544: PPUSH
60545: CALL_OW 1
60549: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60550: LD_ADDR_EXP 72
60554: PUSH
60555: LD_EXP 72
60559: PPUSH
60560: LD_VAR 0 1
60564: PPUSH
60565: EMPTY
60566: PPUSH
60567: CALL_OW 1
60571: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60572: LD_ADDR_EXP 73
60576: PUSH
60577: LD_EXP 73
60581: PPUSH
60582: LD_VAR 0 1
60586: PPUSH
60587: EMPTY
60588: PPUSH
60589: CALL_OW 1
60593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60594: LD_ADDR_EXP 74
60598: PUSH
60599: LD_EXP 74
60603: PPUSH
60604: LD_VAR 0 1
60608: PPUSH
60609: LD_INT 0
60611: PPUSH
60612: CALL_OW 1
60616: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60617: LD_ADDR_EXP 75
60621: PUSH
60622: LD_EXP 75
60626: PPUSH
60627: LD_VAR 0 1
60631: PPUSH
60632: EMPTY
60633: PPUSH
60634: CALL_OW 1
60638: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60639: LD_ADDR_EXP 76
60643: PUSH
60644: LD_EXP 76
60648: PPUSH
60649: LD_VAR 0 1
60653: PPUSH
60654: EMPTY
60655: PPUSH
60656: CALL_OW 1
60660: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60661: LD_ADDR_EXP 77
60665: PUSH
60666: LD_EXP 77
60670: PPUSH
60671: LD_VAR 0 1
60675: PPUSH
60676: EMPTY
60677: PPUSH
60678: CALL_OW 1
60682: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60683: LD_ADDR_EXP 78
60687: PUSH
60688: LD_EXP 78
60692: PPUSH
60693: LD_VAR 0 1
60697: PPUSH
60698: EMPTY
60699: PPUSH
60700: CALL_OW 1
60704: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60705: LD_ADDR_EXP 79
60709: PUSH
60710: LD_EXP 79
60714: PPUSH
60715: LD_VAR 0 1
60719: PPUSH
60720: EMPTY
60721: PPUSH
60722: CALL_OW 1
60726: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60727: LD_ADDR_EXP 80
60731: PUSH
60732: LD_EXP 80
60736: PPUSH
60737: LD_VAR 0 1
60741: PPUSH
60742: EMPTY
60743: PPUSH
60744: CALL_OW 1
60748: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60749: LD_ADDR_EXP 81
60753: PUSH
60754: LD_EXP 81
60758: PPUSH
60759: LD_VAR 0 1
60763: PPUSH
60764: EMPTY
60765: PPUSH
60766: CALL_OW 1
60770: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60771: LD_ADDR_EXP 82
60775: PUSH
60776: LD_EXP 82
60780: PPUSH
60781: LD_VAR 0 1
60785: PPUSH
60786: EMPTY
60787: PPUSH
60788: CALL_OW 1
60792: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60793: LD_ADDR_EXP 83
60797: PUSH
60798: LD_EXP 83
60802: PPUSH
60803: LD_VAR 0 1
60807: PPUSH
60808: EMPTY
60809: PPUSH
60810: CALL_OW 1
60814: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60815: LD_ADDR_EXP 84
60819: PUSH
60820: LD_EXP 84
60824: PPUSH
60825: LD_VAR 0 1
60829: PPUSH
60830: EMPTY
60831: PPUSH
60832: CALL_OW 1
60836: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60837: LD_ADDR_EXP 85
60841: PUSH
60842: LD_EXP 85
60846: PPUSH
60847: LD_VAR 0 1
60851: PPUSH
60852: EMPTY
60853: PPUSH
60854: CALL_OW 1
60858: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60859: LD_ADDR_EXP 86
60863: PUSH
60864: LD_EXP 86
60868: PPUSH
60869: LD_VAR 0 1
60873: PPUSH
60874: EMPTY
60875: PPUSH
60876: CALL_OW 1
60880: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60881: LD_ADDR_EXP 87
60885: PUSH
60886: LD_EXP 87
60890: PPUSH
60891: LD_VAR 0 1
60895: PPUSH
60896: EMPTY
60897: PPUSH
60898: CALL_OW 1
60902: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60903: LD_ADDR_EXP 88
60907: PUSH
60908: LD_EXP 88
60912: PPUSH
60913: LD_VAR 0 1
60917: PPUSH
60918: EMPTY
60919: PPUSH
60920: CALL_OW 1
60924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60925: LD_ADDR_EXP 90
60929: PUSH
60930: LD_EXP 90
60934: PPUSH
60935: LD_VAR 0 1
60939: PPUSH
60940: EMPTY
60941: PPUSH
60942: CALL_OW 1
60946: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
60947: LD_ADDR_EXP 92
60951: PUSH
60952: LD_EXP 92
60956: PPUSH
60957: LD_VAR 0 1
60961: PPUSH
60962: EMPTY
60963: PPUSH
60964: CALL_OW 1
60968: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
60969: LD_ADDR_EXP 93
60973: PUSH
60974: LD_EXP 93
60978: PPUSH
60979: LD_VAR 0 1
60983: PPUSH
60984: EMPTY
60985: PPUSH
60986: CALL_OW 1
60990: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
60991: LD_ADDR_EXP 94
60995: PUSH
60996: LD_EXP 94
61000: PPUSH
61001: LD_VAR 0 1
61005: PPUSH
61006: EMPTY
61007: PPUSH
61008: CALL_OW 1
61012: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61013: LD_ADDR_EXP 95
61017: PUSH
61018: LD_EXP 95
61022: PPUSH
61023: LD_VAR 0 1
61027: PPUSH
61028: EMPTY
61029: PPUSH
61030: CALL_OW 1
61034: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61035: LD_ADDR_EXP 96
61039: PUSH
61040: LD_EXP 96
61044: PPUSH
61045: LD_VAR 0 1
61049: PPUSH
61050: EMPTY
61051: PPUSH
61052: CALL_OW 1
61056: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61057: LD_ADDR_EXP 97
61061: PUSH
61062: LD_EXP 97
61066: PPUSH
61067: LD_VAR 0 1
61071: PPUSH
61072: EMPTY
61073: PPUSH
61074: CALL_OW 1
61078: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61079: LD_ADDR_EXP 98
61083: PUSH
61084: LD_EXP 98
61088: PPUSH
61089: LD_VAR 0 1
61093: PPUSH
61094: EMPTY
61095: PPUSH
61096: CALL_OW 1
61100: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61101: LD_ADDR_EXP 99
61105: PUSH
61106: LD_EXP 99
61110: PPUSH
61111: LD_VAR 0 1
61115: PPUSH
61116: EMPTY
61117: PPUSH
61118: CALL_OW 1
61122: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61123: LD_ADDR_EXP 100
61127: PUSH
61128: LD_EXP 100
61132: PPUSH
61133: LD_VAR 0 1
61137: PPUSH
61138: EMPTY
61139: PPUSH
61140: CALL_OW 1
61144: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61145: LD_ADDR_EXP 101
61149: PUSH
61150: LD_EXP 101
61154: PPUSH
61155: LD_VAR 0 1
61159: PPUSH
61160: EMPTY
61161: PPUSH
61162: CALL_OW 1
61166: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61167: LD_ADDR_EXP 102
61171: PUSH
61172: LD_EXP 102
61176: PPUSH
61177: LD_VAR 0 1
61181: PPUSH
61182: EMPTY
61183: PPUSH
61184: CALL_OW 1
61188: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61189: LD_ADDR_EXP 103
61193: PUSH
61194: LD_EXP 103
61198: PPUSH
61199: LD_VAR 0 1
61203: PPUSH
61204: EMPTY
61205: PPUSH
61206: CALL_OW 1
61210: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61211: LD_ADDR_EXP 104
61215: PUSH
61216: LD_EXP 104
61220: PPUSH
61221: LD_VAR 0 1
61225: PPUSH
61226: EMPTY
61227: PPUSH
61228: CALL_OW 1
61232: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61233: LD_ADDR_EXP 105
61237: PUSH
61238: LD_EXP 105
61242: PPUSH
61243: LD_VAR 0 1
61247: PPUSH
61248: LD_INT 0
61250: PPUSH
61251: CALL_OW 1
61255: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61256: LD_ADDR_EXP 106
61260: PUSH
61261: LD_EXP 106
61265: PPUSH
61266: LD_VAR 0 1
61270: PPUSH
61271: LD_INT 0
61273: PPUSH
61274: CALL_OW 1
61278: ST_TO_ADDR
// end ;
61279: LD_VAR 0 2
61283: RET
// export function MC_Add ( side , units ) ; var base ; begin
61284: LD_INT 0
61286: PPUSH
61287: PPUSH
// base := mc_bases + 1 ;
61288: LD_ADDR_VAR 0 4
61292: PUSH
61293: LD_EXP 63
61297: PUSH
61298: LD_INT 1
61300: PLUS
61301: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
61302: LD_ADDR_EXP 89
61306: PUSH
61307: LD_EXP 89
61311: PPUSH
61312: LD_VAR 0 4
61316: PPUSH
61317: LD_VAR 0 1
61321: PPUSH
61322: CALL_OW 1
61326: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
61327: LD_ADDR_EXP 63
61331: PUSH
61332: LD_EXP 63
61336: PPUSH
61337: LD_VAR 0 4
61341: PPUSH
61342: LD_VAR 0 2
61346: PPUSH
61347: CALL_OW 1
61351: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61352: LD_ADDR_EXP 64
61356: PUSH
61357: LD_EXP 64
61361: PPUSH
61362: LD_VAR 0 4
61366: PPUSH
61367: EMPTY
61368: PPUSH
61369: CALL_OW 1
61373: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61374: LD_ADDR_EXP 65
61378: PUSH
61379: LD_EXP 65
61383: PPUSH
61384: LD_VAR 0 4
61388: PPUSH
61389: EMPTY
61390: PPUSH
61391: CALL_OW 1
61395: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61396: LD_ADDR_EXP 66
61400: PUSH
61401: LD_EXP 66
61405: PPUSH
61406: LD_VAR 0 4
61410: PPUSH
61411: EMPTY
61412: PPUSH
61413: CALL_OW 1
61417: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61418: LD_ADDR_EXP 67
61422: PUSH
61423: LD_EXP 67
61427: PPUSH
61428: LD_VAR 0 4
61432: PPUSH
61433: EMPTY
61434: PPUSH
61435: CALL_OW 1
61439: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61440: LD_ADDR_EXP 68
61444: PUSH
61445: LD_EXP 68
61449: PPUSH
61450: LD_VAR 0 4
61454: PPUSH
61455: EMPTY
61456: PPUSH
61457: CALL_OW 1
61461: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61462: LD_ADDR_EXP 69
61466: PUSH
61467: LD_EXP 69
61471: PPUSH
61472: LD_VAR 0 4
61476: PPUSH
61477: EMPTY
61478: PPUSH
61479: CALL_OW 1
61483: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61484: LD_ADDR_EXP 70
61488: PUSH
61489: LD_EXP 70
61493: PPUSH
61494: LD_VAR 0 4
61498: PPUSH
61499: EMPTY
61500: PPUSH
61501: CALL_OW 1
61505: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61506: LD_ADDR_EXP 71
61510: PUSH
61511: LD_EXP 71
61515: PPUSH
61516: LD_VAR 0 4
61520: PPUSH
61521: EMPTY
61522: PPUSH
61523: CALL_OW 1
61527: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61528: LD_ADDR_EXP 72
61532: PUSH
61533: LD_EXP 72
61537: PPUSH
61538: LD_VAR 0 4
61542: PPUSH
61543: EMPTY
61544: PPUSH
61545: CALL_OW 1
61549: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61550: LD_ADDR_EXP 73
61554: PUSH
61555: LD_EXP 73
61559: PPUSH
61560: LD_VAR 0 4
61564: PPUSH
61565: EMPTY
61566: PPUSH
61567: CALL_OW 1
61571: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61572: LD_ADDR_EXP 74
61576: PUSH
61577: LD_EXP 74
61581: PPUSH
61582: LD_VAR 0 4
61586: PPUSH
61587: LD_INT 0
61589: PPUSH
61590: CALL_OW 1
61594: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61595: LD_ADDR_EXP 75
61599: PUSH
61600: LD_EXP 75
61604: PPUSH
61605: LD_VAR 0 4
61609: PPUSH
61610: EMPTY
61611: PPUSH
61612: CALL_OW 1
61616: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61617: LD_ADDR_EXP 76
61621: PUSH
61622: LD_EXP 76
61626: PPUSH
61627: LD_VAR 0 4
61631: PPUSH
61632: EMPTY
61633: PPUSH
61634: CALL_OW 1
61638: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61639: LD_ADDR_EXP 77
61643: PUSH
61644: LD_EXP 77
61648: PPUSH
61649: LD_VAR 0 4
61653: PPUSH
61654: EMPTY
61655: PPUSH
61656: CALL_OW 1
61660: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61661: LD_ADDR_EXP 78
61665: PUSH
61666: LD_EXP 78
61670: PPUSH
61671: LD_VAR 0 4
61675: PPUSH
61676: EMPTY
61677: PPUSH
61678: CALL_OW 1
61682: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61683: LD_ADDR_EXP 79
61687: PUSH
61688: LD_EXP 79
61692: PPUSH
61693: LD_VAR 0 4
61697: PPUSH
61698: EMPTY
61699: PPUSH
61700: CALL_OW 1
61704: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61705: LD_ADDR_EXP 80
61709: PUSH
61710: LD_EXP 80
61714: PPUSH
61715: LD_VAR 0 4
61719: PPUSH
61720: EMPTY
61721: PPUSH
61722: CALL_OW 1
61726: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61727: LD_ADDR_EXP 81
61731: PUSH
61732: LD_EXP 81
61736: PPUSH
61737: LD_VAR 0 4
61741: PPUSH
61742: EMPTY
61743: PPUSH
61744: CALL_OW 1
61748: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61749: LD_ADDR_EXP 82
61753: PUSH
61754: LD_EXP 82
61758: PPUSH
61759: LD_VAR 0 4
61763: PPUSH
61764: EMPTY
61765: PPUSH
61766: CALL_OW 1
61770: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61771: LD_ADDR_EXP 83
61775: PUSH
61776: LD_EXP 83
61780: PPUSH
61781: LD_VAR 0 4
61785: PPUSH
61786: EMPTY
61787: PPUSH
61788: CALL_OW 1
61792: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61793: LD_ADDR_EXP 84
61797: PUSH
61798: LD_EXP 84
61802: PPUSH
61803: LD_VAR 0 4
61807: PPUSH
61808: EMPTY
61809: PPUSH
61810: CALL_OW 1
61814: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61815: LD_ADDR_EXP 85
61819: PUSH
61820: LD_EXP 85
61824: PPUSH
61825: LD_VAR 0 4
61829: PPUSH
61830: EMPTY
61831: PPUSH
61832: CALL_OW 1
61836: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61837: LD_ADDR_EXP 86
61841: PUSH
61842: LD_EXP 86
61846: PPUSH
61847: LD_VAR 0 4
61851: PPUSH
61852: EMPTY
61853: PPUSH
61854: CALL_OW 1
61858: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61859: LD_ADDR_EXP 87
61863: PUSH
61864: LD_EXP 87
61868: PPUSH
61869: LD_VAR 0 4
61873: PPUSH
61874: EMPTY
61875: PPUSH
61876: CALL_OW 1
61880: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61881: LD_ADDR_EXP 88
61885: PUSH
61886: LD_EXP 88
61890: PPUSH
61891: LD_VAR 0 4
61895: PPUSH
61896: EMPTY
61897: PPUSH
61898: CALL_OW 1
61902: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61903: LD_ADDR_EXP 90
61907: PUSH
61908: LD_EXP 90
61912: PPUSH
61913: LD_VAR 0 4
61917: PPUSH
61918: EMPTY
61919: PPUSH
61920: CALL_OW 1
61924: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61925: LD_ADDR_EXP 92
61929: PUSH
61930: LD_EXP 92
61934: PPUSH
61935: LD_VAR 0 4
61939: PPUSH
61940: EMPTY
61941: PPUSH
61942: CALL_OW 1
61946: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61947: LD_ADDR_EXP 93
61951: PUSH
61952: LD_EXP 93
61956: PPUSH
61957: LD_VAR 0 4
61961: PPUSH
61962: EMPTY
61963: PPUSH
61964: CALL_OW 1
61968: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61969: LD_ADDR_EXP 94
61973: PUSH
61974: LD_EXP 94
61978: PPUSH
61979: LD_VAR 0 4
61983: PPUSH
61984: EMPTY
61985: PPUSH
61986: CALL_OW 1
61990: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61991: LD_ADDR_EXP 95
61995: PUSH
61996: LD_EXP 95
62000: PPUSH
62001: LD_VAR 0 4
62005: PPUSH
62006: EMPTY
62007: PPUSH
62008: CALL_OW 1
62012: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62013: LD_ADDR_EXP 96
62017: PUSH
62018: LD_EXP 96
62022: PPUSH
62023: LD_VAR 0 4
62027: PPUSH
62028: EMPTY
62029: PPUSH
62030: CALL_OW 1
62034: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62035: LD_ADDR_EXP 97
62039: PUSH
62040: LD_EXP 97
62044: PPUSH
62045: LD_VAR 0 4
62049: PPUSH
62050: EMPTY
62051: PPUSH
62052: CALL_OW 1
62056: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62057: LD_ADDR_EXP 98
62061: PUSH
62062: LD_EXP 98
62066: PPUSH
62067: LD_VAR 0 4
62071: PPUSH
62072: EMPTY
62073: PPUSH
62074: CALL_OW 1
62078: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62079: LD_ADDR_EXP 99
62083: PUSH
62084: LD_EXP 99
62088: PPUSH
62089: LD_VAR 0 4
62093: PPUSH
62094: EMPTY
62095: PPUSH
62096: CALL_OW 1
62100: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62101: LD_ADDR_EXP 100
62105: PUSH
62106: LD_EXP 100
62110: PPUSH
62111: LD_VAR 0 4
62115: PPUSH
62116: EMPTY
62117: PPUSH
62118: CALL_OW 1
62122: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62123: LD_ADDR_EXP 101
62127: PUSH
62128: LD_EXP 101
62132: PPUSH
62133: LD_VAR 0 4
62137: PPUSH
62138: EMPTY
62139: PPUSH
62140: CALL_OW 1
62144: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62145: LD_ADDR_EXP 102
62149: PUSH
62150: LD_EXP 102
62154: PPUSH
62155: LD_VAR 0 4
62159: PPUSH
62160: EMPTY
62161: PPUSH
62162: CALL_OW 1
62166: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62167: LD_ADDR_EXP 103
62171: PUSH
62172: LD_EXP 103
62176: PPUSH
62177: LD_VAR 0 4
62181: PPUSH
62182: EMPTY
62183: PPUSH
62184: CALL_OW 1
62188: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62189: LD_ADDR_EXP 104
62193: PUSH
62194: LD_EXP 104
62198: PPUSH
62199: LD_VAR 0 4
62203: PPUSH
62204: EMPTY
62205: PPUSH
62206: CALL_OW 1
62210: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62211: LD_ADDR_EXP 105
62215: PUSH
62216: LD_EXP 105
62220: PPUSH
62221: LD_VAR 0 4
62225: PPUSH
62226: LD_INT 0
62228: PPUSH
62229: CALL_OW 1
62233: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62234: LD_ADDR_EXP 106
62238: PUSH
62239: LD_EXP 106
62243: PPUSH
62244: LD_VAR 0 4
62248: PPUSH
62249: LD_INT 0
62251: PPUSH
62252: CALL_OW 1
62256: ST_TO_ADDR
// result := base ;
62257: LD_ADDR_VAR 0 3
62261: PUSH
62262: LD_VAR 0 4
62266: ST_TO_ADDR
// end ;
62267: LD_VAR 0 3
62271: RET
// export function MC_Start ( ) ; var i ; begin
62272: LD_INT 0
62274: PPUSH
62275: PPUSH
// for i = 1 to mc_bases do
62276: LD_ADDR_VAR 0 2
62280: PUSH
62281: DOUBLE
62282: LD_INT 1
62284: DEC
62285: ST_TO_ADDR
62286: LD_EXP 63
62290: PUSH
62291: FOR_TO
62292: IFFALSE 63392
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
62294: LD_ADDR_EXP 63
62298: PUSH
62299: LD_EXP 63
62303: PPUSH
62304: LD_VAR 0 2
62308: PPUSH
62309: LD_EXP 63
62313: PUSH
62314: LD_VAR 0 2
62318: ARRAY
62319: PUSH
62320: LD_INT 0
62322: DIFF
62323: PPUSH
62324: CALL_OW 1
62328: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
62329: LD_ADDR_EXP 64
62333: PUSH
62334: LD_EXP 64
62338: PPUSH
62339: LD_VAR 0 2
62343: PPUSH
62344: EMPTY
62345: PPUSH
62346: CALL_OW 1
62350: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62351: LD_ADDR_EXP 65
62355: PUSH
62356: LD_EXP 65
62360: PPUSH
62361: LD_VAR 0 2
62365: PPUSH
62366: EMPTY
62367: PPUSH
62368: CALL_OW 1
62372: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
62373: LD_ADDR_EXP 66
62377: PUSH
62378: LD_EXP 66
62382: PPUSH
62383: LD_VAR 0 2
62387: PPUSH
62388: EMPTY
62389: PPUSH
62390: CALL_OW 1
62394: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
62395: LD_ADDR_EXP 67
62399: PUSH
62400: LD_EXP 67
62404: PPUSH
62405: LD_VAR 0 2
62409: PPUSH
62410: EMPTY
62411: PUSH
62412: EMPTY
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PPUSH
62418: CALL_OW 1
62422: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
62423: LD_ADDR_EXP 68
62427: PUSH
62428: LD_EXP 68
62432: PPUSH
62433: LD_VAR 0 2
62437: PPUSH
62438: EMPTY
62439: PPUSH
62440: CALL_OW 1
62444: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
62445: LD_ADDR_EXP 95
62449: PUSH
62450: LD_EXP 95
62454: PPUSH
62455: LD_VAR 0 2
62459: PPUSH
62460: EMPTY
62461: PPUSH
62462: CALL_OW 1
62466: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
62467: LD_ADDR_EXP 69
62471: PUSH
62472: LD_EXP 69
62476: PPUSH
62477: LD_VAR 0 2
62481: PPUSH
62482: EMPTY
62483: PPUSH
62484: CALL_OW 1
62488: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
62489: LD_ADDR_EXP 70
62493: PUSH
62494: LD_EXP 70
62498: PPUSH
62499: LD_VAR 0 2
62503: PPUSH
62504: EMPTY
62505: PPUSH
62506: CALL_OW 1
62510: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
62511: LD_ADDR_EXP 71
62515: PUSH
62516: LD_EXP 71
62520: PPUSH
62521: LD_VAR 0 2
62525: PPUSH
62526: LD_EXP 63
62530: PUSH
62531: LD_VAR 0 2
62535: ARRAY
62536: PPUSH
62537: LD_INT 2
62539: PUSH
62540: LD_INT 30
62542: PUSH
62543: LD_INT 32
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: PUSH
62550: LD_INT 30
62552: PUSH
62553: LD_INT 33
62555: PUSH
62556: EMPTY
62557: LIST
62558: LIST
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: LIST
62564: PPUSH
62565: CALL_OW 72
62569: PPUSH
62570: CALL_OW 1
62574: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
62575: LD_ADDR_EXP 72
62579: PUSH
62580: LD_EXP 72
62584: PPUSH
62585: LD_VAR 0 2
62589: PPUSH
62590: LD_EXP 63
62594: PUSH
62595: LD_VAR 0 2
62599: ARRAY
62600: PPUSH
62601: LD_INT 2
62603: PUSH
62604: LD_INT 30
62606: PUSH
62607: LD_INT 32
62609: PUSH
62610: EMPTY
62611: LIST
62612: LIST
62613: PUSH
62614: LD_INT 30
62616: PUSH
62617: LD_INT 31
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: LIST
62628: PUSH
62629: LD_INT 58
62631: PUSH
62632: EMPTY
62633: LIST
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PPUSH
62639: CALL_OW 72
62643: PPUSH
62644: CALL_OW 1
62648: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
62649: LD_ADDR_EXP 73
62653: PUSH
62654: LD_EXP 73
62658: PPUSH
62659: LD_VAR 0 2
62663: PPUSH
62664: EMPTY
62665: PPUSH
62666: CALL_OW 1
62670: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
62671: LD_ADDR_EXP 77
62675: PUSH
62676: LD_EXP 77
62680: PPUSH
62681: LD_VAR 0 2
62685: PPUSH
62686: EMPTY
62687: PPUSH
62688: CALL_OW 1
62692: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
62693: LD_ADDR_EXP 76
62697: PUSH
62698: LD_EXP 76
62702: PPUSH
62703: LD_VAR 0 2
62707: PPUSH
62708: EMPTY
62709: PPUSH
62710: CALL_OW 1
62714: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
62715: LD_ADDR_EXP 78
62719: PUSH
62720: LD_EXP 78
62724: PPUSH
62725: LD_VAR 0 2
62729: PPUSH
62730: EMPTY
62731: PPUSH
62732: CALL_OW 1
62736: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
62737: LD_ADDR_EXP 79
62741: PUSH
62742: LD_EXP 79
62746: PPUSH
62747: LD_VAR 0 2
62751: PPUSH
62752: EMPTY
62753: PPUSH
62754: CALL_OW 1
62758: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62759: LD_ADDR_EXP 80
62763: PUSH
62764: LD_EXP 80
62768: PPUSH
62769: LD_VAR 0 2
62773: PPUSH
62774: EMPTY
62775: PPUSH
62776: CALL_OW 1
62780: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
62781: LD_ADDR_EXP 81
62785: PUSH
62786: LD_EXP 81
62790: PPUSH
62791: LD_VAR 0 2
62795: PPUSH
62796: EMPTY
62797: PPUSH
62798: CALL_OW 1
62802: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
62803: LD_ADDR_EXP 82
62807: PUSH
62808: LD_EXP 82
62812: PPUSH
62813: LD_VAR 0 2
62817: PPUSH
62818: EMPTY
62819: PPUSH
62820: CALL_OW 1
62824: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62825: LD_ADDR_EXP 83
62829: PUSH
62830: LD_EXP 83
62834: PPUSH
62835: LD_VAR 0 2
62839: PPUSH
62840: EMPTY
62841: PPUSH
62842: CALL_OW 1
62846: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
62847: LD_ADDR_EXP 84
62851: PUSH
62852: LD_EXP 84
62856: PPUSH
62857: LD_VAR 0 2
62861: PPUSH
62862: EMPTY
62863: PPUSH
62864: CALL_OW 1
62868: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62869: LD_ADDR_EXP 85
62873: PUSH
62874: LD_EXP 85
62878: PPUSH
62879: LD_VAR 0 2
62883: PPUSH
62884: EMPTY
62885: PPUSH
62886: CALL_OW 1
62890: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62891: LD_ADDR_EXP 74
62895: PUSH
62896: LD_EXP 74
62900: PPUSH
62901: LD_VAR 0 2
62905: PPUSH
62906: LD_INT 0
62908: PPUSH
62909: CALL_OW 1
62913: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62914: LD_ADDR_EXP 87
62918: PUSH
62919: LD_EXP 87
62923: PPUSH
62924: LD_VAR 0 2
62928: PPUSH
62929: LD_INT 0
62931: PPUSH
62932: CALL_OW 1
62936: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
62937: LD_ADDR_EXP 75
62941: PUSH
62942: LD_EXP 75
62946: PPUSH
62947: LD_VAR 0 2
62951: PPUSH
62952: EMPTY
62953: PPUSH
62954: CALL_OW 1
62958: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
62959: LD_ADDR_EXP 86
62963: PUSH
62964: LD_EXP 86
62968: PPUSH
62969: LD_VAR 0 2
62973: PPUSH
62974: LD_INT 0
62976: PPUSH
62977: CALL_OW 1
62981: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
62982: LD_ADDR_EXP 88
62986: PUSH
62987: LD_EXP 88
62991: PPUSH
62992: LD_VAR 0 2
62996: PPUSH
62997: EMPTY
62998: PPUSH
62999: CALL_OW 1
63003: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63004: LD_ADDR_EXP 91
63008: PUSH
63009: LD_EXP 91
63013: PPUSH
63014: LD_VAR 0 2
63018: PPUSH
63019: LD_INT 0
63021: PPUSH
63022: CALL_OW 1
63026: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63027: LD_ADDR_EXP 92
63031: PUSH
63032: LD_EXP 92
63036: PPUSH
63037: LD_VAR 0 2
63041: PPUSH
63042: EMPTY
63043: PPUSH
63044: CALL_OW 1
63048: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63049: LD_ADDR_EXP 93
63053: PUSH
63054: LD_EXP 93
63058: PPUSH
63059: LD_VAR 0 2
63063: PPUSH
63064: EMPTY
63065: PPUSH
63066: CALL_OW 1
63070: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63071: LD_ADDR_EXP 94
63075: PUSH
63076: LD_EXP 94
63080: PPUSH
63081: LD_VAR 0 2
63085: PPUSH
63086: EMPTY
63087: PPUSH
63088: CALL_OW 1
63092: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63093: LD_ADDR_EXP 96
63097: PUSH
63098: LD_EXP 96
63102: PPUSH
63103: LD_VAR 0 2
63107: PPUSH
63108: LD_EXP 63
63112: PUSH
63113: LD_VAR 0 2
63117: ARRAY
63118: PPUSH
63119: LD_INT 2
63121: PUSH
63122: LD_INT 30
63124: PUSH
63125: LD_INT 6
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: PUSH
63132: LD_INT 30
63134: PUSH
63135: LD_INT 7
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 30
63144: PUSH
63145: LD_INT 8
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: PUSH
63152: EMPTY
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: PPUSH
63158: CALL_OW 72
63162: PPUSH
63163: CALL_OW 1
63167: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63168: LD_ADDR_EXP 97
63172: PUSH
63173: LD_EXP 97
63177: PPUSH
63178: LD_VAR 0 2
63182: PPUSH
63183: EMPTY
63184: PPUSH
63185: CALL_OW 1
63189: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
63190: LD_ADDR_EXP 98
63194: PUSH
63195: LD_EXP 98
63199: PPUSH
63200: LD_VAR 0 2
63204: PPUSH
63205: EMPTY
63206: PPUSH
63207: CALL_OW 1
63211: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
63212: LD_ADDR_EXP 99
63216: PUSH
63217: LD_EXP 99
63221: PPUSH
63222: LD_VAR 0 2
63226: PPUSH
63227: EMPTY
63228: PPUSH
63229: CALL_OW 1
63233: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
63234: LD_ADDR_EXP 100
63238: PUSH
63239: LD_EXP 100
63243: PPUSH
63244: LD_VAR 0 2
63248: PPUSH
63249: EMPTY
63250: PPUSH
63251: CALL_OW 1
63255: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
63256: LD_ADDR_EXP 101
63260: PUSH
63261: LD_EXP 101
63265: PPUSH
63266: LD_VAR 0 2
63270: PPUSH
63271: EMPTY
63272: PPUSH
63273: CALL_OW 1
63277: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
63278: LD_ADDR_EXP 102
63282: PUSH
63283: LD_EXP 102
63287: PPUSH
63288: LD_VAR 0 2
63292: PPUSH
63293: EMPTY
63294: PPUSH
63295: CALL_OW 1
63299: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
63300: LD_ADDR_EXP 103
63304: PUSH
63305: LD_EXP 103
63309: PPUSH
63310: LD_VAR 0 2
63314: PPUSH
63315: EMPTY
63316: PPUSH
63317: CALL_OW 1
63321: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
63322: LD_ADDR_EXP 104
63326: PUSH
63327: LD_EXP 104
63331: PPUSH
63332: LD_VAR 0 2
63336: PPUSH
63337: EMPTY
63338: PPUSH
63339: CALL_OW 1
63343: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
63344: LD_ADDR_EXP 105
63348: PUSH
63349: LD_EXP 105
63353: PPUSH
63354: LD_VAR 0 2
63358: PPUSH
63359: LD_INT 0
63361: PPUSH
63362: CALL_OW 1
63366: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63367: LD_ADDR_EXP 106
63371: PUSH
63372: LD_EXP 106
63376: PPUSH
63377: LD_VAR 0 2
63381: PPUSH
63382: LD_INT 0
63384: PPUSH
63385: CALL_OW 1
63389: ST_TO_ADDR
// end ;
63390: GO 62291
63392: POP
63393: POP
// MC_InitSides ( ) ;
63394: CALL 63680 0 0
// MC_InitResearch ( ) ;
63398: CALL 63419 0 0
// CustomInitMacro ( ) ;
63402: CALL 219 0 0
// skirmish := true ;
63406: LD_ADDR_EXP 61
63410: PUSH
63411: LD_INT 1
63413: ST_TO_ADDR
// end ;
63414: LD_VAR 0 1
63418: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
63419: LD_INT 0
63421: PPUSH
63422: PPUSH
63423: PPUSH
63424: PPUSH
63425: PPUSH
63426: PPUSH
// if not mc_bases then
63427: LD_EXP 63
63431: NOT
63432: IFFALSE 63436
// exit ;
63434: GO 63675
// for i = 1 to 8 do
63436: LD_ADDR_VAR 0 2
63440: PUSH
63441: DOUBLE
63442: LD_INT 1
63444: DEC
63445: ST_TO_ADDR
63446: LD_INT 8
63448: PUSH
63449: FOR_TO
63450: IFFALSE 63476
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
63452: LD_ADDR_EXP 90
63456: PUSH
63457: LD_EXP 90
63461: PPUSH
63462: LD_VAR 0 2
63466: PPUSH
63467: EMPTY
63468: PPUSH
63469: CALL_OW 1
63473: ST_TO_ADDR
63474: GO 63449
63476: POP
63477: POP
// tmp := [ ] ;
63478: LD_ADDR_VAR 0 5
63482: PUSH
63483: EMPTY
63484: ST_TO_ADDR
// for i = 1 to mc_sides do
63485: LD_ADDR_VAR 0 2
63489: PUSH
63490: DOUBLE
63491: LD_INT 1
63493: DEC
63494: ST_TO_ADDR
63495: LD_EXP 89
63499: PUSH
63500: FOR_TO
63501: IFFALSE 63559
// if not mc_sides [ i ] in tmp then
63503: LD_EXP 89
63507: PUSH
63508: LD_VAR 0 2
63512: ARRAY
63513: PUSH
63514: LD_VAR 0 5
63518: IN
63519: NOT
63520: IFFALSE 63557
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
63522: LD_ADDR_VAR 0 5
63526: PUSH
63527: LD_VAR 0 5
63531: PPUSH
63532: LD_VAR 0 5
63536: PUSH
63537: LD_INT 1
63539: PLUS
63540: PPUSH
63541: LD_EXP 89
63545: PUSH
63546: LD_VAR 0 2
63550: ARRAY
63551: PPUSH
63552: CALL_OW 2
63556: ST_TO_ADDR
63557: GO 63500
63559: POP
63560: POP
// if not tmp then
63561: LD_VAR 0 5
63565: NOT
63566: IFFALSE 63570
// exit ;
63568: GO 63675
// for j in tmp do
63570: LD_ADDR_VAR 0 3
63574: PUSH
63575: LD_VAR 0 5
63579: PUSH
63580: FOR_IN
63581: IFFALSE 63673
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
63583: LD_ADDR_VAR 0 6
63587: PUSH
63588: LD_INT 22
63590: PUSH
63591: LD_VAR 0 3
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PPUSH
63600: CALL_OW 69
63604: ST_TO_ADDR
// if not un then
63605: LD_VAR 0 6
63609: NOT
63610: IFFALSE 63614
// continue ;
63612: GO 63580
// nation := GetNation ( un [ 1 ] ) ;
63614: LD_ADDR_VAR 0 4
63618: PUSH
63619: LD_VAR 0 6
63623: PUSH
63624: LD_INT 1
63626: ARRAY
63627: PPUSH
63628: CALL_OW 248
63632: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
63633: LD_ADDR_EXP 90
63637: PUSH
63638: LD_EXP 90
63642: PPUSH
63643: LD_VAR 0 3
63647: PPUSH
63648: LD_VAR 0 3
63652: PPUSH
63653: LD_VAR 0 4
63657: PPUSH
63658: LD_INT 1
63660: PPUSH
63661: CALL 17360 0 3
63665: PPUSH
63666: CALL_OW 1
63670: ST_TO_ADDR
// end ;
63671: GO 63580
63673: POP
63674: POP
// end ;
63675: LD_VAR 0 1
63679: RET
// export function MC_InitSides ( ) ; var i ; begin
63680: LD_INT 0
63682: PPUSH
63683: PPUSH
// if not mc_bases then
63684: LD_EXP 63
63688: NOT
63689: IFFALSE 63693
// exit ;
63691: GO 63767
// for i = 1 to mc_bases do
63693: LD_ADDR_VAR 0 2
63697: PUSH
63698: DOUBLE
63699: LD_INT 1
63701: DEC
63702: ST_TO_ADDR
63703: LD_EXP 63
63707: PUSH
63708: FOR_TO
63709: IFFALSE 63765
// if mc_bases [ i ] then
63711: LD_EXP 63
63715: PUSH
63716: LD_VAR 0 2
63720: ARRAY
63721: IFFALSE 63763
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
63723: LD_ADDR_EXP 89
63727: PUSH
63728: LD_EXP 89
63732: PPUSH
63733: LD_VAR 0 2
63737: PPUSH
63738: LD_EXP 63
63742: PUSH
63743: LD_VAR 0 2
63747: ARRAY
63748: PUSH
63749: LD_INT 1
63751: ARRAY
63752: PPUSH
63753: CALL_OW 255
63757: PPUSH
63758: CALL_OW 1
63762: ST_TO_ADDR
63763: GO 63708
63765: POP
63766: POP
// end ;
63767: LD_VAR 0 1
63771: RET
// every 0 0$03 trigger skirmish do
63772: LD_EXP 61
63776: IFFALSE 63930
63778: GO 63780
63780: DISABLE
// begin enable ;
63781: ENABLE
// MC_CheckBuildings ( ) ;
63782: CALL 68442 0 0
// MC_CheckPeopleLife ( ) ;
63786: CALL 68603 0 0
// RaiseSailEvent ( 100 ) ;
63790: LD_INT 100
63792: PPUSH
63793: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
63797: LD_INT 103
63799: PPUSH
63800: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
63804: LD_INT 104
63806: PPUSH
63807: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
63811: LD_INT 105
63813: PPUSH
63814: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
63818: LD_INT 106
63820: PPUSH
63821: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
63825: LD_INT 107
63827: PPUSH
63828: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
63832: LD_INT 108
63834: PPUSH
63835: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
63839: LD_INT 109
63841: PPUSH
63842: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
63846: LD_INT 110
63848: PPUSH
63849: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
63853: LD_INT 111
63855: PPUSH
63856: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
63860: LD_INT 112
63862: PPUSH
63863: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
63867: LD_INT 113
63869: PPUSH
63870: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
63874: LD_INT 120
63876: PPUSH
63877: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63881: LD_INT 121
63883: PPUSH
63884: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63888: LD_INT 122
63890: PPUSH
63891: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63895: LD_INT 123
63897: PPUSH
63898: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63902: LD_INT 124
63904: PPUSH
63905: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63909: LD_INT 125
63911: PPUSH
63912: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63916: LD_INT 126
63918: PPUSH
63919: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63923: LD_INT 200
63925: PPUSH
63926: CALL_OW 427
// end ;
63930: END
// on SailEvent ( event ) do begin if event < 100 then
63931: LD_VAR 0 1
63935: PUSH
63936: LD_INT 100
63938: LESS
63939: IFFALSE 63950
// CustomEvent ( event ) ;
63941: LD_VAR 0 1
63945: PPUSH
63946: CALL 15924 0 1
// if event = 100 then
63950: LD_VAR 0 1
63954: PUSH
63955: LD_INT 100
63957: EQUAL
63958: IFFALSE 63964
// MC_ClassManager ( ) ;
63960: CALL 64356 0 0
// if event = 101 then
63964: LD_VAR 0 1
63968: PUSH
63969: LD_INT 101
63971: EQUAL
63972: IFFALSE 63978
// MC_RepairBuildings ( ) ;
63974: CALL 69188 0 0
// if event = 102 then
63978: LD_VAR 0 1
63982: PUSH
63983: LD_INT 102
63985: EQUAL
63986: IFFALSE 63992
// MC_Heal ( ) ;
63988: CALL 70123 0 0
// if event = 103 then
63992: LD_VAR 0 1
63996: PUSH
63997: LD_INT 103
63999: EQUAL
64000: IFFALSE 64006
// MC_Build ( ) ;
64002: CALL 70545 0 0
// if event = 104 then
64006: LD_VAR 0 1
64010: PUSH
64011: LD_INT 104
64013: EQUAL
64014: IFFALSE 64020
// MC_TurretWeapon ( ) ;
64016: CALL 72179 0 0
// if event = 105 then
64020: LD_VAR 0 1
64024: PUSH
64025: LD_INT 105
64027: EQUAL
64028: IFFALSE 64034
// MC_BuildUpgrade ( ) ;
64030: CALL 71730 0 0
// if event = 106 then
64034: LD_VAR 0 1
64038: PUSH
64039: LD_INT 106
64041: EQUAL
64042: IFFALSE 64048
// MC_PlantMines ( ) ;
64044: CALL 72609 0 0
// if event = 107 then
64048: LD_VAR 0 1
64052: PUSH
64053: LD_INT 107
64055: EQUAL
64056: IFFALSE 64062
// MC_CollectCrates ( ) ;
64058: CALL 73407 0 0
// if event = 108 then
64062: LD_VAR 0 1
64066: PUSH
64067: LD_INT 108
64069: EQUAL
64070: IFFALSE 64076
// MC_LinkRemoteControl ( ) ;
64072: CALL 75257 0 0
// if event = 109 then
64076: LD_VAR 0 1
64080: PUSH
64081: LD_INT 109
64083: EQUAL
64084: IFFALSE 64090
// MC_ProduceVehicle ( ) ;
64086: CALL 75438 0 0
// if event = 110 then
64090: LD_VAR 0 1
64094: PUSH
64095: LD_INT 110
64097: EQUAL
64098: IFFALSE 64104
// MC_SendAttack ( ) ;
64100: CALL 75904 0 0
// if event = 111 then
64104: LD_VAR 0 1
64108: PUSH
64109: LD_INT 111
64111: EQUAL
64112: IFFALSE 64118
// MC_Defend ( ) ;
64114: CALL 76012 0 0
// if event = 112 then
64118: LD_VAR 0 1
64122: PUSH
64123: LD_INT 112
64125: EQUAL
64126: IFFALSE 64132
// MC_Research ( ) ;
64128: CALL 76892 0 0
// if event = 113 then
64132: LD_VAR 0 1
64136: PUSH
64137: LD_INT 113
64139: EQUAL
64140: IFFALSE 64146
// MC_MinesTrigger ( ) ;
64142: CALL 78006 0 0
// if event = 120 then
64146: LD_VAR 0 1
64150: PUSH
64151: LD_INT 120
64153: EQUAL
64154: IFFALSE 64160
// MC_RepairVehicle ( ) ;
64156: CALL 78105 0 0
// if event = 121 then
64160: LD_VAR 0 1
64164: PUSH
64165: LD_INT 121
64167: EQUAL
64168: IFFALSE 64174
// MC_TameApe ( ) ;
64170: CALL 78874 0 0
// if event = 122 then
64174: LD_VAR 0 1
64178: PUSH
64179: LD_INT 122
64181: EQUAL
64182: IFFALSE 64188
// MC_ChangeApeClass ( ) ;
64184: CALL 79703 0 0
// if event = 123 then
64188: LD_VAR 0 1
64192: PUSH
64193: LD_INT 123
64195: EQUAL
64196: IFFALSE 64202
// MC_Bazooka ( ) ;
64198: CALL 80353 0 0
// if event = 124 then
64202: LD_VAR 0 1
64206: PUSH
64207: LD_INT 124
64209: EQUAL
64210: IFFALSE 64216
// MC_TeleportExit ( ) ;
64212: CALL 80551 0 0
// if event = 125 then
64216: LD_VAR 0 1
64220: PUSH
64221: LD_INT 125
64223: EQUAL
64224: IFFALSE 64230
// MC_Deposits ( ) ;
64226: CALL 81198 0 0
// if event = 126 then
64230: LD_VAR 0 1
64234: PUSH
64235: LD_INT 126
64237: EQUAL
64238: IFFALSE 64244
// MC_RemoteDriver ( ) ;
64240: CALL 81823 0 0
// if event = 200 then
64244: LD_VAR 0 1
64248: PUSH
64249: LD_INT 200
64251: EQUAL
64252: IFFALSE 64258
// MC_Idle ( ) ;
64254: CALL 83730 0 0
// end ;
64258: PPOPN 1
64260: END
// export function MC_Reset ( base , tag ) ; var i ; begin
64261: LD_INT 0
64263: PPUSH
64264: PPUSH
// if not mc_bases [ base ] or not tag then
64265: LD_EXP 63
64269: PUSH
64270: LD_VAR 0 1
64274: ARRAY
64275: NOT
64276: PUSH
64277: LD_VAR 0 2
64281: NOT
64282: OR
64283: IFFALSE 64287
// exit ;
64285: GO 64351
// for i in mc_bases [ base ] union mc_ape [ base ] do
64287: LD_ADDR_VAR 0 4
64291: PUSH
64292: LD_EXP 63
64296: PUSH
64297: LD_VAR 0 1
64301: ARRAY
64302: PUSH
64303: LD_EXP 92
64307: PUSH
64308: LD_VAR 0 1
64312: ARRAY
64313: UNION
64314: PUSH
64315: FOR_IN
64316: IFFALSE 64349
// if GetTag ( i ) = tag then
64318: LD_VAR 0 4
64322: PPUSH
64323: CALL_OW 110
64327: PUSH
64328: LD_VAR 0 2
64332: EQUAL
64333: IFFALSE 64347
// SetTag ( i , 0 ) ;
64335: LD_VAR 0 4
64339: PPUSH
64340: LD_INT 0
64342: PPUSH
64343: CALL_OW 109
64347: GO 64315
64349: POP
64350: POP
// end ;
64351: LD_VAR 0 3
64355: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
64356: LD_INT 0
64358: PPUSH
64359: PPUSH
64360: PPUSH
64361: PPUSH
64362: PPUSH
64363: PPUSH
64364: PPUSH
64365: PPUSH
// if not mc_bases then
64366: LD_EXP 63
64370: NOT
64371: IFFALSE 64375
// exit ;
64373: GO 64824
// for i = 1 to mc_bases do
64375: LD_ADDR_VAR 0 2
64379: PUSH
64380: DOUBLE
64381: LD_INT 1
64383: DEC
64384: ST_TO_ADDR
64385: LD_EXP 63
64389: PUSH
64390: FOR_TO
64391: IFFALSE 64822
// begin tmp := MC_ClassCheckReq ( i ) ;
64393: LD_ADDR_VAR 0 4
64397: PUSH
64398: LD_VAR 0 2
64402: PPUSH
64403: CALL 64829 0 1
64407: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
64408: LD_ADDR_EXP 104
64412: PUSH
64413: LD_EXP 104
64417: PPUSH
64418: LD_VAR 0 2
64422: PPUSH
64423: LD_VAR 0 4
64427: PPUSH
64428: CALL_OW 1
64432: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
64433: LD_ADDR_VAR 0 6
64437: PUSH
64438: LD_EXP 63
64442: PUSH
64443: LD_VAR 0 2
64447: ARRAY
64448: PPUSH
64449: LD_INT 2
64451: PUSH
64452: LD_INT 30
64454: PUSH
64455: LD_INT 4
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 30
64464: PUSH
64465: LD_INT 5
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: LIST
64476: PPUSH
64477: CALL_OW 72
64481: PUSH
64482: LD_EXP 63
64486: PUSH
64487: LD_VAR 0 2
64491: ARRAY
64492: PPUSH
64493: LD_INT 2
64495: PUSH
64496: LD_INT 30
64498: PUSH
64499: LD_INT 0
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PUSH
64506: LD_INT 30
64508: PUSH
64509: LD_INT 1
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: LIST
64520: PPUSH
64521: CALL_OW 72
64525: PUSH
64526: LD_EXP 63
64530: PUSH
64531: LD_VAR 0 2
64535: ARRAY
64536: PPUSH
64537: LD_INT 30
64539: PUSH
64540: LD_INT 3
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PPUSH
64547: CALL_OW 72
64551: PUSH
64552: LD_EXP 63
64556: PUSH
64557: LD_VAR 0 2
64561: ARRAY
64562: PPUSH
64563: LD_INT 2
64565: PUSH
64566: LD_INT 30
64568: PUSH
64569: LD_INT 6
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: PUSH
64576: LD_INT 30
64578: PUSH
64579: LD_INT 7
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 30
64588: PUSH
64589: LD_INT 8
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: PPUSH
64602: CALL_OW 72
64606: PUSH
64607: EMPTY
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: ST_TO_ADDR
// for j := 1 to 4 do
64613: LD_ADDR_VAR 0 3
64617: PUSH
64618: DOUBLE
64619: LD_INT 1
64621: DEC
64622: ST_TO_ADDR
64623: LD_INT 4
64625: PUSH
64626: FOR_TO
64627: IFFALSE 64818
// begin if not tmp [ j ] then
64629: LD_VAR 0 4
64633: PUSH
64634: LD_VAR 0 3
64638: ARRAY
64639: NOT
64640: IFFALSE 64644
// continue ;
64642: GO 64626
// for p in tmp [ j ] do
64644: LD_ADDR_VAR 0 5
64648: PUSH
64649: LD_VAR 0 4
64653: PUSH
64654: LD_VAR 0 3
64658: ARRAY
64659: PUSH
64660: FOR_IN
64661: IFFALSE 64814
// begin if not b [ j ] then
64663: LD_VAR 0 6
64667: PUSH
64668: LD_VAR 0 3
64672: ARRAY
64673: NOT
64674: IFFALSE 64678
// break ;
64676: GO 64814
// e := 0 ;
64678: LD_ADDR_VAR 0 7
64682: PUSH
64683: LD_INT 0
64685: ST_TO_ADDR
// for k in b [ j ] do
64686: LD_ADDR_VAR 0 8
64690: PUSH
64691: LD_VAR 0 6
64695: PUSH
64696: LD_VAR 0 3
64700: ARRAY
64701: PUSH
64702: FOR_IN
64703: IFFALSE 64730
// if IsNotFull ( k ) then
64705: LD_VAR 0 8
64709: PPUSH
64710: CALL 19481 0 1
64714: IFFALSE 64728
// begin e := k ;
64716: LD_ADDR_VAR 0 7
64720: PUSH
64721: LD_VAR 0 8
64725: ST_TO_ADDR
// break ;
64726: GO 64730
// end ;
64728: GO 64702
64730: POP
64731: POP
// if e and not UnitGoingToBuilding ( p , e ) then
64732: LD_VAR 0 7
64736: PUSH
64737: LD_VAR 0 5
64741: PPUSH
64742: LD_VAR 0 7
64746: PPUSH
64747: CALL 53640 0 2
64751: NOT
64752: AND
64753: IFFALSE 64812
// begin if IsInUnit ( p ) then
64755: LD_VAR 0 5
64759: PPUSH
64760: CALL_OW 310
64764: IFFALSE 64775
// ComExitBuilding ( p ) ;
64766: LD_VAR 0 5
64770: PPUSH
64771: CALL_OW 122
// ComEnterUnit ( p , e ) ;
64775: LD_VAR 0 5
64779: PPUSH
64780: LD_VAR 0 7
64784: PPUSH
64785: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
64789: LD_VAR 0 5
64793: PPUSH
64794: LD_VAR 0 3
64798: PPUSH
64799: CALL_OW 183
// AddComExitBuilding ( p ) ;
64803: LD_VAR 0 5
64807: PPUSH
64808: CALL_OW 182
// end ; end ;
64812: GO 64660
64814: POP
64815: POP
// end ;
64816: GO 64626
64818: POP
64819: POP
// end ;
64820: GO 64390
64822: POP
64823: POP
// end ;
64824: LD_VAR 0 1
64828: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
64829: LD_INT 0
64831: PPUSH
64832: PPUSH
64833: PPUSH
64834: PPUSH
64835: PPUSH
64836: PPUSH
64837: PPUSH
64838: PPUSH
64839: PPUSH
64840: PPUSH
64841: PPUSH
64842: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
64843: LD_ADDR_VAR 0 2
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: LD_INT 0
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 0
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: LIST
64864: LIST
64865: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64866: LD_VAR 0 1
64870: NOT
64871: PUSH
64872: LD_EXP 63
64876: PUSH
64877: LD_VAR 0 1
64881: ARRAY
64882: NOT
64883: OR
64884: PUSH
64885: LD_EXP 63
64889: PUSH
64890: LD_VAR 0 1
64894: ARRAY
64895: PPUSH
64896: LD_INT 2
64898: PUSH
64899: LD_INT 30
64901: PUSH
64902: LD_INT 0
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: PUSH
64909: LD_INT 30
64911: PUSH
64912: LD_INT 1
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: LIST
64923: PPUSH
64924: CALL_OW 72
64928: NOT
64929: OR
64930: IFFALSE 64934
// exit ;
64932: GO 68437
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
64934: LD_ADDR_VAR 0 4
64938: PUSH
64939: LD_EXP 63
64943: PUSH
64944: LD_VAR 0 1
64948: ARRAY
64949: PPUSH
64950: LD_INT 2
64952: PUSH
64953: LD_INT 25
64955: PUSH
64956: LD_INT 1
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 25
64965: PUSH
64966: LD_INT 2
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 25
64975: PUSH
64976: LD_INT 3
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: LD_INT 25
64985: PUSH
64986: LD_INT 4
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 25
64995: PUSH
64996: LD_INT 5
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 25
65005: PUSH
65006: LD_INT 8
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PUSH
65013: LD_INT 25
65015: PUSH
65016: LD_INT 9
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: PPUSH
65033: CALL_OW 72
65037: ST_TO_ADDR
// if not tmp then
65038: LD_VAR 0 4
65042: NOT
65043: IFFALSE 65047
// exit ;
65045: GO 68437
// for i in tmp do
65047: LD_ADDR_VAR 0 3
65051: PUSH
65052: LD_VAR 0 4
65056: PUSH
65057: FOR_IN
65058: IFFALSE 65089
// if GetTag ( i ) then
65060: LD_VAR 0 3
65064: PPUSH
65065: CALL_OW 110
65069: IFFALSE 65087
// tmp := tmp diff i ;
65071: LD_ADDR_VAR 0 4
65075: PUSH
65076: LD_VAR 0 4
65080: PUSH
65081: LD_VAR 0 3
65085: DIFF
65086: ST_TO_ADDR
65087: GO 65057
65089: POP
65090: POP
// if not tmp then
65091: LD_VAR 0 4
65095: NOT
65096: IFFALSE 65100
// exit ;
65098: GO 68437
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65100: LD_ADDR_VAR 0 5
65104: PUSH
65105: LD_EXP 63
65109: PUSH
65110: LD_VAR 0 1
65114: ARRAY
65115: PPUSH
65116: LD_INT 2
65118: PUSH
65119: LD_INT 25
65121: PUSH
65122: LD_INT 1
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 25
65131: PUSH
65132: LD_INT 5
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 25
65141: PUSH
65142: LD_INT 8
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PUSH
65149: LD_INT 25
65151: PUSH
65152: LD_INT 9
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: PPUSH
65166: CALL_OW 72
65170: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65171: LD_ADDR_VAR 0 6
65175: PUSH
65176: LD_EXP 63
65180: PUSH
65181: LD_VAR 0 1
65185: ARRAY
65186: PPUSH
65187: LD_INT 25
65189: PUSH
65190: LD_INT 2
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PPUSH
65197: CALL_OW 72
65201: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65202: LD_ADDR_VAR 0 7
65206: PUSH
65207: LD_EXP 63
65211: PUSH
65212: LD_VAR 0 1
65216: ARRAY
65217: PPUSH
65218: LD_INT 25
65220: PUSH
65221: LD_INT 3
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PPUSH
65228: CALL_OW 72
65232: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
65233: LD_ADDR_VAR 0 8
65237: PUSH
65238: LD_EXP 63
65242: PUSH
65243: LD_VAR 0 1
65247: ARRAY
65248: PPUSH
65249: LD_INT 25
65251: PUSH
65252: LD_INT 4
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PUSH
65259: LD_INT 24
65261: PUSH
65262: LD_INT 251
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PPUSH
65273: CALL_OW 72
65277: ST_TO_ADDR
// if mc_is_defending [ base ] then
65278: LD_EXP 106
65282: PUSH
65283: LD_VAR 0 1
65287: ARRAY
65288: IFFALSE 65749
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
65290: LD_ADDR_EXP 105
65294: PUSH
65295: LD_EXP 105
65299: PPUSH
65300: LD_VAR 0 1
65304: PPUSH
65305: LD_INT 4
65307: PPUSH
65308: CALL_OW 1
65312: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65313: LD_ADDR_VAR 0 12
65317: PUSH
65318: LD_EXP 63
65322: PUSH
65323: LD_VAR 0 1
65327: ARRAY
65328: PPUSH
65329: LD_INT 2
65331: PUSH
65332: LD_INT 30
65334: PUSH
65335: LD_INT 4
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 30
65344: PUSH
65345: LD_INT 5
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: LIST
65356: PPUSH
65357: CALL_OW 72
65361: ST_TO_ADDR
// if not b then
65362: LD_VAR 0 12
65366: NOT
65367: IFFALSE 65371
// exit ;
65369: GO 68437
// p := [ ] ;
65371: LD_ADDR_VAR 0 11
65375: PUSH
65376: EMPTY
65377: ST_TO_ADDR
// if sci >= 2 then
65378: LD_VAR 0 8
65382: PUSH
65383: LD_INT 2
65385: GREATEREQUAL
65386: IFFALSE 65417
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
65388: LD_ADDR_VAR 0 8
65392: PUSH
65393: LD_VAR 0 8
65397: PUSH
65398: LD_INT 1
65400: ARRAY
65401: PUSH
65402: LD_VAR 0 8
65406: PUSH
65407: LD_INT 2
65409: ARRAY
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: ST_TO_ADDR
65415: GO 65478
// if sci = 1 then
65417: LD_VAR 0 8
65421: PUSH
65422: LD_INT 1
65424: EQUAL
65425: IFFALSE 65446
// sci := [ sci [ 1 ] ] else
65427: LD_ADDR_VAR 0 8
65431: PUSH
65432: LD_VAR 0 8
65436: PUSH
65437: LD_INT 1
65439: ARRAY
65440: PUSH
65441: EMPTY
65442: LIST
65443: ST_TO_ADDR
65444: GO 65478
// if sci = 0 then
65446: LD_VAR 0 8
65450: PUSH
65451: LD_INT 0
65453: EQUAL
65454: IFFALSE 65478
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
65456: LD_ADDR_VAR 0 11
65460: PUSH
65461: LD_VAR 0 4
65465: PPUSH
65466: LD_INT 4
65468: PPUSH
65469: CALL 53512 0 2
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: ST_TO_ADDR
// if eng > 4 then
65478: LD_VAR 0 6
65482: PUSH
65483: LD_INT 4
65485: GREATER
65486: IFFALSE 65532
// for i = eng downto 4 do
65488: LD_ADDR_VAR 0 3
65492: PUSH
65493: DOUBLE
65494: LD_VAR 0 6
65498: INC
65499: ST_TO_ADDR
65500: LD_INT 4
65502: PUSH
65503: FOR_DOWNTO
65504: IFFALSE 65530
// eng := eng diff eng [ i ] ;
65506: LD_ADDR_VAR 0 6
65510: PUSH
65511: LD_VAR 0 6
65515: PUSH
65516: LD_VAR 0 6
65520: PUSH
65521: LD_VAR 0 3
65525: ARRAY
65526: DIFF
65527: ST_TO_ADDR
65528: GO 65503
65530: POP
65531: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
65532: LD_ADDR_VAR 0 4
65536: PUSH
65537: LD_VAR 0 4
65541: PUSH
65542: LD_VAR 0 5
65546: PUSH
65547: LD_VAR 0 6
65551: UNION
65552: PUSH
65553: LD_VAR 0 7
65557: UNION
65558: PUSH
65559: LD_VAR 0 8
65563: UNION
65564: DIFF
65565: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
65566: LD_ADDR_VAR 0 13
65570: PUSH
65571: LD_EXP 63
65575: PUSH
65576: LD_VAR 0 1
65580: ARRAY
65581: PPUSH
65582: LD_INT 2
65584: PUSH
65585: LD_INT 30
65587: PUSH
65588: LD_INT 32
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: LD_INT 30
65597: PUSH
65598: LD_INT 31
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: LIST
65609: PPUSH
65610: CALL_OW 72
65614: PUSH
65615: LD_EXP 63
65619: PUSH
65620: LD_VAR 0 1
65624: ARRAY
65625: PPUSH
65626: LD_INT 2
65628: PUSH
65629: LD_INT 30
65631: PUSH
65632: LD_INT 4
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: LD_INT 30
65641: PUSH
65642: LD_INT 5
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: LIST
65653: PPUSH
65654: CALL_OW 72
65658: PUSH
65659: LD_INT 6
65661: MUL
65662: PLUS
65663: ST_TO_ADDR
// if bcount < tmp then
65664: LD_VAR 0 13
65668: PUSH
65669: LD_VAR 0 4
65673: LESS
65674: IFFALSE 65720
// for i = tmp downto bcount do
65676: LD_ADDR_VAR 0 3
65680: PUSH
65681: DOUBLE
65682: LD_VAR 0 4
65686: INC
65687: ST_TO_ADDR
65688: LD_VAR 0 13
65692: PUSH
65693: FOR_DOWNTO
65694: IFFALSE 65718
// tmp := Delete ( tmp , tmp ) ;
65696: LD_ADDR_VAR 0 4
65700: PUSH
65701: LD_VAR 0 4
65705: PPUSH
65706: LD_VAR 0 4
65710: PPUSH
65711: CALL_OW 3
65715: ST_TO_ADDR
65716: GO 65693
65718: POP
65719: POP
// result := [ tmp , 0 , 0 , p ] ;
65720: LD_ADDR_VAR 0 2
65724: PUSH
65725: LD_VAR 0 4
65729: PUSH
65730: LD_INT 0
65732: PUSH
65733: LD_INT 0
65735: PUSH
65736: LD_VAR 0 11
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: ST_TO_ADDR
// exit ;
65747: GO 68437
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65749: LD_EXP 63
65753: PUSH
65754: LD_VAR 0 1
65758: ARRAY
65759: PPUSH
65760: LD_INT 2
65762: PUSH
65763: LD_INT 30
65765: PUSH
65766: LD_INT 6
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: PUSH
65773: LD_INT 30
65775: PUSH
65776: LD_INT 7
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: PUSH
65783: LD_INT 30
65785: PUSH
65786: LD_INT 8
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: PPUSH
65799: CALL_OW 72
65803: NOT
65804: PUSH
65805: LD_EXP 63
65809: PUSH
65810: LD_VAR 0 1
65814: ARRAY
65815: PPUSH
65816: LD_INT 30
65818: PUSH
65819: LD_INT 3
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PPUSH
65826: CALL_OW 72
65830: NOT
65831: AND
65832: IFFALSE 65904
// begin if eng = tmp then
65834: LD_VAR 0 6
65838: PUSH
65839: LD_VAR 0 4
65843: EQUAL
65844: IFFALSE 65848
// exit ;
65846: GO 68437
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
65848: LD_ADDR_EXP 105
65852: PUSH
65853: LD_EXP 105
65857: PPUSH
65858: LD_VAR 0 1
65862: PPUSH
65863: LD_INT 1
65865: PPUSH
65866: CALL_OW 1
65870: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
65871: LD_ADDR_VAR 0 2
65875: PUSH
65876: LD_INT 0
65878: PUSH
65879: LD_VAR 0 4
65883: PUSH
65884: LD_VAR 0 6
65888: DIFF
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: ST_TO_ADDR
// exit ;
65902: GO 68437
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65904: LD_EXP 90
65908: PUSH
65909: LD_EXP 89
65913: PUSH
65914: LD_VAR 0 1
65918: ARRAY
65919: ARRAY
65920: PUSH
65921: LD_EXP 63
65925: PUSH
65926: LD_VAR 0 1
65930: ARRAY
65931: PPUSH
65932: LD_INT 2
65934: PUSH
65935: LD_INT 30
65937: PUSH
65938: LD_INT 6
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 30
65947: PUSH
65948: LD_INT 7
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 30
65957: PUSH
65958: LD_INT 8
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: PPUSH
65971: CALL_OW 72
65975: AND
65976: PUSH
65977: LD_EXP 63
65981: PUSH
65982: LD_VAR 0 1
65986: ARRAY
65987: PPUSH
65988: LD_INT 30
65990: PUSH
65991: LD_INT 3
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PPUSH
65998: CALL_OW 72
66002: NOT
66003: AND
66004: IFFALSE 66218
// begin if sci >= 6 then
66006: LD_VAR 0 8
66010: PUSH
66011: LD_INT 6
66013: GREATEREQUAL
66014: IFFALSE 66018
// exit ;
66016: GO 68437
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66018: LD_ADDR_EXP 105
66022: PUSH
66023: LD_EXP 105
66027: PPUSH
66028: LD_VAR 0 1
66032: PPUSH
66033: LD_INT 2
66035: PPUSH
66036: CALL_OW 1
66040: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66041: LD_ADDR_VAR 0 9
66045: PUSH
66046: LD_VAR 0 4
66050: PUSH
66051: LD_VAR 0 8
66055: DIFF
66056: PPUSH
66057: LD_INT 4
66059: PPUSH
66060: CALL 53512 0 2
66064: ST_TO_ADDR
// p := [ ] ;
66065: LD_ADDR_VAR 0 11
66069: PUSH
66070: EMPTY
66071: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66072: LD_VAR 0 8
66076: PUSH
66077: LD_INT 6
66079: LESS
66080: PUSH
66081: LD_VAR 0 9
66085: PUSH
66086: LD_INT 6
66088: GREATER
66089: AND
66090: IFFALSE 66171
// begin for i = 1 to 6 - sci do
66092: LD_ADDR_VAR 0 3
66096: PUSH
66097: DOUBLE
66098: LD_INT 1
66100: DEC
66101: ST_TO_ADDR
66102: LD_INT 6
66104: PUSH
66105: LD_VAR 0 8
66109: MINUS
66110: PUSH
66111: FOR_TO
66112: IFFALSE 66167
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66114: LD_ADDR_VAR 0 11
66118: PUSH
66119: LD_VAR 0 11
66123: PPUSH
66124: LD_VAR 0 11
66128: PUSH
66129: LD_INT 1
66131: PLUS
66132: PPUSH
66133: LD_VAR 0 9
66137: PUSH
66138: LD_INT 1
66140: ARRAY
66141: PPUSH
66142: CALL_OW 2
66146: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66147: LD_ADDR_VAR 0 9
66151: PUSH
66152: LD_VAR 0 9
66156: PPUSH
66157: LD_INT 1
66159: PPUSH
66160: CALL_OW 3
66164: ST_TO_ADDR
// end ;
66165: GO 66111
66167: POP
66168: POP
// end else
66169: GO 66191
// if sort then
66171: LD_VAR 0 9
66175: IFFALSE 66191
// p := sort [ 1 ] ;
66177: LD_ADDR_VAR 0 11
66181: PUSH
66182: LD_VAR 0 9
66186: PUSH
66187: LD_INT 1
66189: ARRAY
66190: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
66191: LD_ADDR_VAR 0 2
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: LD_INT 0
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: LD_VAR 0 11
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: ST_TO_ADDR
// exit ;
66216: GO 68437
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66218: LD_EXP 90
66222: PUSH
66223: LD_EXP 89
66227: PUSH
66228: LD_VAR 0 1
66232: ARRAY
66233: ARRAY
66234: PUSH
66235: LD_EXP 63
66239: PUSH
66240: LD_VAR 0 1
66244: ARRAY
66245: PPUSH
66246: LD_INT 2
66248: PUSH
66249: LD_INT 30
66251: PUSH
66252: LD_INT 6
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 30
66261: PUSH
66262: LD_INT 7
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 30
66271: PUSH
66272: LD_INT 8
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: PPUSH
66285: CALL_OW 72
66289: AND
66290: PUSH
66291: LD_EXP 63
66295: PUSH
66296: LD_VAR 0 1
66300: ARRAY
66301: PPUSH
66302: LD_INT 30
66304: PUSH
66305: LD_INT 3
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PPUSH
66312: CALL_OW 72
66316: AND
66317: IFFALSE 67051
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
66319: LD_ADDR_EXP 105
66323: PUSH
66324: LD_EXP 105
66328: PPUSH
66329: LD_VAR 0 1
66333: PPUSH
66334: LD_INT 3
66336: PPUSH
66337: CALL_OW 1
66341: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66342: LD_ADDR_VAR 0 2
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: LD_INT 0
66352: PUSH
66353: LD_INT 0
66355: PUSH
66356: LD_INT 0
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: ST_TO_ADDR
// if not eng then
66365: LD_VAR 0 6
66369: NOT
66370: IFFALSE 66433
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
66372: LD_ADDR_VAR 0 11
66376: PUSH
66377: LD_VAR 0 4
66381: PPUSH
66382: LD_INT 2
66384: PPUSH
66385: CALL 53512 0 2
66389: PUSH
66390: LD_INT 1
66392: ARRAY
66393: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
66394: LD_ADDR_VAR 0 2
66398: PUSH
66399: LD_VAR 0 2
66403: PPUSH
66404: LD_INT 2
66406: PPUSH
66407: LD_VAR 0 11
66411: PPUSH
66412: CALL_OW 1
66416: ST_TO_ADDR
// tmp := tmp diff p ;
66417: LD_ADDR_VAR 0 4
66421: PUSH
66422: LD_VAR 0 4
66426: PUSH
66427: LD_VAR 0 11
66431: DIFF
66432: ST_TO_ADDR
// end ; if tmp and sci < 6 then
66433: LD_VAR 0 4
66437: PUSH
66438: LD_VAR 0 8
66442: PUSH
66443: LD_INT 6
66445: LESS
66446: AND
66447: IFFALSE 66635
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
66449: LD_ADDR_VAR 0 9
66453: PUSH
66454: LD_VAR 0 4
66458: PUSH
66459: LD_VAR 0 8
66463: PUSH
66464: LD_VAR 0 7
66468: UNION
66469: DIFF
66470: PPUSH
66471: LD_INT 4
66473: PPUSH
66474: CALL 53512 0 2
66478: ST_TO_ADDR
// p := [ ] ;
66479: LD_ADDR_VAR 0 11
66483: PUSH
66484: EMPTY
66485: ST_TO_ADDR
// if sort then
66486: LD_VAR 0 9
66490: IFFALSE 66606
// for i = 1 to 6 - sci do
66492: LD_ADDR_VAR 0 3
66496: PUSH
66497: DOUBLE
66498: LD_INT 1
66500: DEC
66501: ST_TO_ADDR
66502: LD_INT 6
66504: PUSH
66505: LD_VAR 0 8
66509: MINUS
66510: PUSH
66511: FOR_TO
66512: IFFALSE 66604
// begin if i = sort then
66514: LD_VAR 0 3
66518: PUSH
66519: LD_VAR 0 9
66523: EQUAL
66524: IFFALSE 66528
// break ;
66526: GO 66604
// if GetClass ( i ) = 4 then
66528: LD_VAR 0 3
66532: PPUSH
66533: CALL_OW 257
66537: PUSH
66538: LD_INT 4
66540: EQUAL
66541: IFFALSE 66545
// continue ;
66543: GO 66511
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66545: LD_ADDR_VAR 0 11
66549: PUSH
66550: LD_VAR 0 11
66554: PPUSH
66555: LD_VAR 0 11
66559: PUSH
66560: LD_INT 1
66562: PLUS
66563: PPUSH
66564: LD_VAR 0 9
66568: PUSH
66569: LD_VAR 0 3
66573: ARRAY
66574: PPUSH
66575: CALL_OW 2
66579: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66580: LD_ADDR_VAR 0 4
66584: PUSH
66585: LD_VAR 0 4
66589: PUSH
66590: LD_VAR 0 9
66594: PUSH
66595: LD_VAR 0 3
66599: ARRAY
66600: DIFF
66601: ST_TO_ADDR
// end ;
66602: GO 66511
66604: POP
66605: POP
// if p then
66606: LD_VAR 0 11
66610: IFFALSE 66635
// result := Replace ( result , 4 , p ) ;
66612: LD_ADDR_VAR 0 2
66616: PUSH
66617: LD_VAR 0 2
66621: PPUSH
66622: LD_INT 4
66624: PPUSH
66625: LD_VAR 0 11
66629: PPUSH
66630: CALL_OW 1
66634: ST_TO_ADDR
// end ; if tmp and mech < 6 then
66635: LD_VAR 0 4
66639: PUSH
66640: LD_VAR 0 7
66644: PUSH
66645: LD_INT 6
66647: LESS
66648: AND
66649: IFFALSE 66837
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66651: LD_ADDR_VAR 0 9
66655: PUSH
66656: LD_VAR 0 4
66660: PUSH
66661: LD_VAR 0 8
66665: PUSH
66666: LD_VAR 0 7
66670: UNION
66671: DIFF
66672: PPUSH
66673: LD_INT 3
66675: PPUSH
66676: CALL 53512 0 2
66680: ST_TO_ADDR
// p := [ ] ;
66681: LD_ADDR_VAR 0 11
66685: PUSH
66686: EMPTY
66687: ST_TO_ADDR
// if sort then
66688: LD_VAR 0 9
66692: IFFALSE 66808
// for i = 1 to 6 - mech do
66694: LD_ADDR_VAR 0 3
66698: PUSH
66699: DOUBLE
66700: LD_INT 1
66702: DEC
66703: ST_TO_ADDR
66704: LD_INT 6
66706: PUSH
66707: LD_VAR 0 7
66711: MINUS
66712: PUSH
66713: FOR_TO
66714: IFFALSE 66806
// begin if i = sort then
66716: LD_VAR 0 3
66720: PUSH
66721: LD_VAR 0 9
66725: EQUAL
66726: IFFALSE 66730
// break ;
66728: GO 66806
// if GetClass ( i ) = 3 then
66730: LD_VAR 0 3
66734: PPUSH
66735: CALL_OW 257
66739: PUSH
66740: LD_INT 3
66742: EQUAL
66743: IFFALSE 66747
// continue ;
66745: GO 66713
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66747: LD_ADDR_VAR 0 11
66751: PUSH
66752: LD_VAR 0 11
66756: PPUSH
66757: LD_VAR 0 11
66761: PUSH
66762: LD_INT 1
66764: PLUS
66765: PPUSH
66766: LD_VAR 0 9
66770: PUSH
66771: LD_VAR 0 3
66775: ARRAY
66776: PPUSH
66777: CALL_OW 2
66781: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66782: LD_ADDR_VAR 0 4
66786: PUSH
66787: LD_VAR 0 4
66791: PUSH
66792: LD_VAR 0 9
66796: PUSH
66797: LD_VAR 0 3
66801: ARRAY
66802: DIFF
66803: ST_TO_ADDR
// end ;
66804: GO 66713
66806: POP
66807: POP
// if p then
66808: LD_VAR 0 11
66812: IFFALSE 66837
// result := Replace ( result , 3 , p ) ;
66814: LD_ADDR_VAR 0 2
66818: PUSH
66819: LD_VAR 0 2
66823: PPUSH
66824: LD_INT 3
66826: PPUSH
66827: LD_VAR 0 11
66831: PPUSH
66832: CALL_OW 1
66836: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
66837: LD_VAR 0 4
66841: PUSH
66842: LD_INT 6
66844: GREATER
66845: PUSH
66846: LD_VAR 0 6
66850: PUSH
66851: LD_INT 6
66853: LESS
66854: AND
66855: IFFALSE 67049
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66857: LD_ADDR_VAR 0 9
66861: PUSH
66862: LD_VAR 0 4
66866: PUSH
66867: LD_VAR 0 8
66871: PUSH
66872: LD_VAR 0 7
66876: UNION
66877: PUSH
66878: LD_VAR 0 6
66882: UNION
66883: DIFF
66884: PPUSH
66885: LD_INT 2
66887: PPUSH
66888: CALL 53512 0 2
66892: ST_TO_ADDR
// p := [ ] ;
66893: LD_ADDR_VAR 0 11
66897: PUSH
66898: EMPTY
66899: ST_TO_ADDR
// if sort then
66900: LD_VAR 0 9
66904: IFFALSE 67020
// for i = 1 to 6 - eng do
66906: LD_ADDR_VAR 0 3
66910: PUSH
66911: DOUBLE
66912: LD_INT 1
66914: DEC
66915: ST_TO_ADDR
66916: LD_INT 6
66918: PUSH
66919: LD_VAR 0 6
66923: MINUS
66924: PUSH
66925: FOR_TO
66926: IFFALSE 67018
// begin if i = sort then
66928: LD_VAR 0 3
66932: PUSH
66933: LD_VAR 0 9
66937: EQUAL
66938: IFFALSE 66942
// break ;
66940: GO 67018
// if GetClass ( i ) = 2 then
66942: LD_VAR 0 3
66946: PPUSH
66947: CALL_OW 257
66951: PUSH
66952: LD_INT 2
66954: EQUAL
66955: IFFALSE 66959
// continue ;
66957: GO 66925
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66959: LD_ADDR_VAR 0 11
66963: PUSH
66964: LD_VAR 0 11
66968: PPUSH
66969: LD_VAR 0 11
66973: PUSH
66974: LD_INT 1
66976: PLUS
66977: PPUSH
66978: LD_VAR 0 9
66982: PUSH
66983: LD_VAR 0 3
66987: ARRAY
66988: PPUSH
66989: CALL_OW 2
66993: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66994: LD_ADDR_VAR 0 4
66998: PUSH
66999: LD_VAR 0 4
67003: PUSH
67004: LD_VAR 0 9
67008: PUSH
67009: LD_VAR 0 3
67013: ARRAY
67014: DIFF
67015: ST_TO_ADDR
// end ;
67016: GO 66925
67018: POP
67019: POP
// if p then
67020: LD_VAR 0 11
67024: IFFALSE 67049
// result := Replace ( result , 2 , p ) ;
67026: LD_ADDR_VAR 0 2
67030: PUSH
67031: LD_VAR 0 2
67035: PPUSH
67036: LD_INT 2
67038: PPUSH
67039: LD_VAR 0 11
67043: PPUSH
67044: CALL_OW 1
67048: ST_TO_ADDR
// end ; exit ;
67049: GO 68437
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67051: LD_EXP 90
67055: PUSH
67056: LD_EXP 89
67060: PUSH
67061: LD_VAR 0 1
67065: ARRAY
67066: ARRAY
67067: NOT
67068: PUSH
67069: LD_EXP 63
67073: PUSH
67074: LD_VAR 0 1
67078: ARRAY
67079: PPUSH
67080: LD_INT 30
67082: PUSH
67083: LD_INT 3
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PPUSH
67090: CALL_OW 72
67094: AND
67095: PUSH
67096: LD_EXP 68
67100: PUSH
67101: LD_VAR 0 1
67105: ARRAY
67106: AND
67107: IFFALSE 67715
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67109: LD_ADDR_EXP 105
67113: PUSH
67114: LD_EXP 105
67118: PPUSH
67119: LD_VAR 0 1
67123: PPUSH
67124: LD_INT 5
67126: PPUSH
67127: CALL_OW 1
67131: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67132: LD_ADDR_VAR 0 2
67136: PUSH
67137: LD_INT 0
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: LD_INT 0
67145: PUSH
67146: LD_INT 0
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: ST_TO_ADDR
// if sci > 1 then
67155: LD_VAR 0 8
67159: PUSH
67160: LD_INT 1
67162: GREATER
67163: IFFALSE 67191
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
67165: LD_ADDR_VAR 0 4
67169: PUSH
67170: LD_VAR 0 4
67174: PUSH
67175: LD_VAR 0 8
67179: PUSH
67180: LD_VAR 0 8
67184: PUSH
67185: LD_INT 1
67187: ARRAY
67188: DIFF
67189: DIFF
67190: ST_TO_ADDR
// if tmp and not sci then
67191: LD_VAR 0 4
67195: PUSH
67196: LD_VAR 0 8
67200: NOT
67201: AND
67202: IFFALSE 67271
// begin sort := SortBySkill ( tmp , 4 ) ;
67204: LD_ADDR_VAR 0 9
67208: PUSH
67209: LD_VAR 0 4
67213: PPUSH
67214: LD_INT 4
67216: PPUSH
67217: CALL 53512 0 2
67221: ST_TO_ADDR
// if sort then
67222: LD_VAR 0 9
67226: IFFALSE 67242
// p := sort [ 1 ] ;
67228: LD_ADDR_VAR 0 11
67232: PUSH
67233: LD_VAR 0 9
67237: PUSH
67238: LD_INT 1
67240: ARRAY
67241: ST_TO_ADDR
// if p then
67242: LD_VAR 0 11
67246: IFFALSE 67271
// result := Replace ( result , 4 , p ) ;
67248: LD_ADDR_VAR 0 2
67252: PUSH
67253: LD_VAR 0 2
67257: PPUSH
67258: LD_INT 4
67260: PPUSH
67261: LD_VAR 0 11
67265: PPUSH
67266: CALL_OW 1
67270: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67271: LD_ADDR_VAR 0 4
67275: PUSH
67276: LD_VAR 0 4
67280: PUSH
67281: LD_VAR 0 7
67285: DIFF
67286: ST_TO_ADDR
// if tmp and mech < 6 then
67287: LD_VAR 0 4
67291: PUSH
67292: LD_VAR 0 7
67296: PUSH
67297: LD_INT 6
67299: LESS
67300: AND
67301: IFFALSE 67489
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67303: LD_ADDR_VAR 0 9
67307: PUSH
67308: LD_VAR 0 4
67312: PUSH
67313: LD_VAR 0 8
67317: PUSH
67318: LD_VAR 0 7
67322: UNION
67323: DIFF
67324: PPUSH
67325: LD_INT 3
67327: PPUSH
67328: CALL 53512 0 2
67332: ST_TO_ADDR
// p := [ ] ;
67333: LD_ADDR_VAR 0 11
67337: PUSH
67338: EMPTY
67339: ST_TO_ADDR
// if sort then
67340: LD_VAR 0 9
67344: IFFALSE 67460
// for i = 1 to 6 - mech do
67346: LD_ADDR_VAR 0 3
67350: PUSH
67351: DOUBLE
67352: LD_INT 1
67354: DEC
67355: ST_TO_ADDR
67356: LD_INT 6
67358: PUSH
67359: LD_VAR 0 7
67363: MINUS
67364: PUSH
67365: FOR_TO
67366: IFFALSE 67458
// begin if i = sort then
67368: LD_VAR 0 3
67372: PUSH
67373: LD_VAR 0 9
67377: EQUAL
67378: IFFALSE 67382
// break ;
67380: GO 67458
// if GetClass ( i ) = 3 then
67382: LD_VAR 0 3
67386: PPUSH
67387: CALL_OW 257
67391: PUSH
67392: LD_INT 3
67394: EQUAL
67395: IFFALSE 67399
// continue ;
67397: GO 67365
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67399: LD_ADDR_VAR 0 11
67403: PUSH
67404: LD_VAR 0 11
67408: PPUSH
67409: LD_VAR 0 11
67413: PUSH
67414: LD_INT 1
67416: PLUS
67417: PPUSH
67418: LD_VAR 0 9
67422: PUSH
67423: LD_VAR 0 3
67427: ARRAY
67428: PPUSH
67429: CALL_OW 2
67433: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67434: LD_ADDR_VAR 0 4
67438: PUSH
67439: LD_VAR 0 4
67443: PUSH
67444: LD_VAR 0 9
67448: PUSH
67449: LD_VAR 0 3
67453: ARRAY
67454: DIFF
67455: ST_TO_ADDR
// end ;
67456: GO 67365
67458: POP
67459: POP
// if p then
67460: LD_VAR 0 11
67464: IFFALSE 67489
// result := Replace ( result , 3 , p ) ;
67466: LD_ADDR_VAR 0 2
67470: PUSH
67471: LD_VAR 0 2
67475: PPUSH
67476: LD_INT 3
67478: PPUSH
67479: LD_VAR 0 11
67483: PPUSH
67484: CALL_OW 1
67488: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67489: LD_ADDR_VAR 0 4
67493: PUSH
67494: LD_VAR 0 4
67498: PUSH
67499: LD_VAR 0 6
67503: DIFF
67504: ST_TO_ADDR
// if tmp and eng < 6 then
67505: LD_VAR 0 4
67509: PUSH
67510: LD_VAR 0 6
67514: PUSH
67515: LD_INT 6
67517: LESS
67518: AND
67519: IFFALSE 67713
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67521: LD_ADDR_VAR 0 9
67525: PUSH
67526: LD_VAR 0 4
67530: PUSH
67531: LD_VAR 0 8
67535: PUSH
67536: LD_VAR 0 7
67540: UNION
67541: PUSH
67542: LD_VAR 0 6
67546: UNION
67547: DIFF
67548: PPUSH
67549: LD_INT 2
67551: PPUSH
67552: CALL 53512 0 2
67556: ST_TO_ADDR
// p := [ ] ;
67557: LD_ADDR_VAR 0 11
67561: PUSH
67562: EMPTY
67563: ST_TO_ADDR
// if sort then
67564: LD_VAR 0 9
67568: IFFALSE 67684
// for i = 1 to 6 - eng do
67570: LD_ADDR_VAR 0 3
67574: PUSH
67575: DOUBLE
67576: LD_INT 1
67578: DEC
67579: ST_TO_ADDR
67580: LD_INT 6
67582: PUSH
67583: LD_VAR 0 6
67587: MINUS
67588: PUSH
67589: FOR_TO
67590: IFFALSE 67682
// begin if i = sort then
67592: LD_VAR 0 3
67596: PUSH
67597: LD_VAR 0 9
67601: EQUAL
67602: IFFALSE 67606
// break ;
67604: GO 67682
// if GetClass ( i ) = 2 then
67606: LD_VAR 0 3
67610: PPUSH
67611: CALL_OW 257
67615: PUSH
67616: LD_INT 2
67618: EQUAL
67619: IFFALSE 67623
// continue ;
67621: GO 67589
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67623: LD_ADDR_VAR 0 11
67627: PUSH
67628: LD_VAR 0 11
67632: PPUSH
67633: LD_VAR 0 11
67637: PUSH
67638: LD_INT 1
67640: PLUS
67641: PPUSH
67642: LD_VAR 0 9
67646: PUSH
67647: LD_VAR 0 3
67651: ARRAY
67652: PPUSH
67653: CALL_OW 2
67657: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67658: LD_ADDR_VAR 0 4
67662: PUSH
67663: LD_VAR 0 4
67667: PUSH
67668: LD_VAR 0 9
67672: PUSH
67673: LD_VAR 0 3
67677: ARRAY
67678: DIFF
67679: ST_TO_ADDR
// end ;
67680: GO 67589
67682: POP
67683: POP
// if p then
67684: LD_VAR 0 11
67688: IFFALSE 67713
// result := Replace ( result , 2 , p ) ;
67690: LD_ADDR_VAR 0 2
67694: PUSH
67695: LD_VAR 0 2
67699: PPUSH
67700: LD_INT 2
67702: PPUSH
67703: LD_VAR 0 11
67707: PPUSH
67708: CALL_OW 1
67712: ST_TO_ADDR
// end ; exit ;
67713: GO 68437
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
67715: LD_EXP 90
67719: PUSH
67720: LD_EXP 89
67724: PUSH
67725: LD_VAR 0 1
67729: ARRAY
67730: ARRAY
67731: NOT
67732: PUSH
67733: LD_EXP 63
67737: PUSH
67738: LD_VAR 0 1
67742: ARRAY
67743: PPUSH
67744: LD_INT 30
67746: PUSH
67747: LD_INT 3
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PPUSH
67754: CALL_OW 72
67758: AND
67759: PUSH
67760: LD_EXP 68
67764: PUSH
67765: LD_VAR 0 1
67769: ARRAY
67770: NOT
67771: AND
67772: IFFALSE 68437
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
67774: LD_ADDR_EXP 105
67778: PUSH
67779: LD_EXP 105
67783: PPUSH
67784: LD_VAR 0 1
67788: PPUSH
67789: LD_INT 6
67791: PPUSH
67792: CALL_OW 1
67796: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67797: LD_ADDR_VAR 0 2
67801: PUSH
67802: LD_INT 0
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: LD_INT 0
67810: PUSH
67811: LD_INT 0
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: LIST
67818: LIST
67819: ST_TO_ADDR
// if sci >= 1 then
67820: LD_VAR 0 8
67824: PUSH
67825: LD_INT 1
67827: GREATEREQUAL
67828: IFFALSE 67850
// tmp := tmp diff sci [ 1 ] ;
67830: LD_ADDR_VAR 0 4
67834: PUSH
67835: LD_VAR 0 4
67839: PUSH
67840: LD_VAR 0 8
67844: PUSH
67845: LD_INT 1
67847: ARRAY
67848: DIFF
67849: ST_TO_ADDR
// if tmp and not sci then
67850: LD_VAR 0 4
67854: PUSH
67855: LD_VAR 0 8
67859: NOT
67860: AND
67861: IFFALSE 67930
// begin sort := SortBySkill ( tmp , 4 ) ;
67863: LD_ADDR_VAR 0 9
67867: PUSH
67868: LD_VAR 0 4
67872: PPUSH
67873: LD_INT 4
67875: PPUSH
67876: CALL 53512 0 2
67880: ST_TO_ADDR
// if sort then
67881: LD_VAR 0 9
67885: IFFALSE 67901
// p := sort [ 1 ] ;
67887: LD_ADDR_VAR 0 11
67891: PUSH
67892: LD_VAR 0 9
67896: PUSH
67897: LD_INT 1
67899: ARRAY
67900: ST_TO_ADDR
// if p then
67901: LD_VAR 0 11
67905: IFFALSE 67930
// result := Replace ( result , 4 , p ) ;
67907: LD_ADDR_VAR 0 2
67911: PUSH
67912: LD_VAR 0 2
67916: PPUSH
67917: LD_INT 4
67919: PPUSH
67920: LD_VAR 0 11
67924: PPUSH
67925: CALL_OW 1
67929: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67930: LD_ADDR_VAR 0 4
67934: PUSH
67935: LD_VAR 0 4
67939: PUSH
67940: LD_VAR 0 7
67944: DIFF
67945: ST_TO_ADDR
// if tmp and mech < 6 then
67946: LD_VAR 0 4
67950: PUSH
67951: LD_VAR 0 7
67955: PUSH
67956: LD_INT 6
67958: LESS
67959: AND
67960: IFFALSE 68142
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
67962: LD_ADDR_VAR 0 9
67966: PUSH
67967: LD_VAR 0 4
67971: PUSH
67972: LD_VAR 0 7
67976: DIFF
67977: PPUSH
67978: LD_INT 3
67980: PPUSH
67981: CALL 53512 0 2
67985: ST_TO_ADDR
// p := [ ] ;
67986: LD_ADDR_VAR 0 11
67990: PUSH
67991: EMPTY
67992: ST_TO_ADDR
// if sort then
67993: LD_VAR 0 9
67997: IFFALSE 68113
// for i = 1 to 6 - mech do
67999: LD_ADDR_VAR 0 3
68003: PUSH
68004: DOUBLE
68005: LD_INT 1
68007: DEC
68008: ST_TO_ADDR
68009: LD_INT 6
68011: PUSH
68012: LD_VAR 0 7
68016: MINUS
68017: PUSH
68018: FOR_TO
68019: IFFALSE 68111
// begin if i = sort then
68021: LD_VAR 0 3
68025: PUSH
68026: LD_VAR 0 9
68030: EQUAL
68031: IFFALSE 68035
// break ;
68033: GO 68111
// if GetClass ( i ) = 3 then
68035: LD_VAR 0 3
68039: PPUSH
68040: CALL_OW 257
68044: PUSH
68045: LD_INT 3
68047: EQUAL
68048: IFFALSE 68052
// continue ;
68050: GO 68018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68052: LD_ADDR_VAR 0 11
68056: PUSH
68057: LD_VAR 0 11
68061: PPUSH
68062: LD_VAR 0 11
68066: PUSH
68067: LD_INT 1
68069: PLUS
68070: PPUSH
68071: LD_VAR 0 9
68075: PUSH
68076: LD_VAR 0 3
68080: ARRAY
68081: PPUSH
68082: CALL_OW 2
68086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68087: LD_ADDR_VAR 0 4
68091: PUSH
68092: LD_VAR 0 4
68096: PUSH
68097: LD_VAR 0 9
68101: PUSH
68102: LD_VAR 0 3
68106: ARRAY
68107: DIFF
68108: ST_TO_ADDR
// end ;
68109: GO 68018
68111: POP
68112: POP
// if p then
68113: LD_VAR 0 11
68117: IFFALSE 68142
// result := Replace ( result , 3 , p ) ;
68119: LD_ADDR_VAR 0 2
68123: PUSH
68124: LD_VAR 0 2
68128: PPUSH
68129: LD_INT 3
68131: PPUSH
68132: LD_VAR 0 11
68136: PPUSH
68137: CALL_OW 1
68141: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68142: LD_ADDR_VAR 0 4
68146: PUSH
68147: LD_VAR 0 4
68151: PUSH
68152: LD_VAR 0 6
68156: DIFF
68157: ST_TO_ADDR
// if tmp and eng < 4 then
68158: LD_VAR 0 4
68162: PUSH
68163: LD_VAR 0 6
68167: PUSH
68168: LD_INT 4
68170: LESS
68171: AND
68172: IFFALSE 68362
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
68174: LD_ADDR_VAR 0 9
68178: PUSH
68179: LD_VAR 0 4
68183: PUSH
68184: LD_VAR 0 7
68188: PUSH
68189: LD_VAR 0 6
68193: UNION
68194: DIFF
68195: PPUSH
68196: LD_INT 2
68198: PPUSH
68199: CALL 53512 0 2
68203: ST_TO_ADDR
// p := [ ] ;
68204: LD_ADDR_VAR 0 11
68208: PUSH
68209: EMPTY
68210: ST_TO_ADDR
// if sort then
68211: LD_VAR 0 9
68215: IFFALSE 68331
// for i = 1 to 4 - eng do
68217: LD_ADDR_VAR 0 3
68221: PUSH
68222: DOUBLE
68223: LD_INT 1
68225: DEC
68226: ST_TO_ADDR
68227: LD_INT 4
68229: PUSH
68230: LD_VAR 0 6
68234: MINUS
68235: PUSH
68236: FOR_TO
68237: IFFALSE 68329
// begin if i = sort then
68239: LD_VAR 0 3
68243: PUSH
68244: LD_VAR 0 9
68248: EQUAL
68249: IFFALSE 68253
// break ;
68251: GO 68329
// if GetClass ( i ) = 2 then
68253: LD_VAR 0 3
68257: PPUSH
68258: CALL_OW 257
68262: PUSH
68263: LD_INT 2
68265: EQUAL
68266: IFFALSE 68270
// continue ;
68268: GO 68236
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68270: LD_ADDR_VAR 0 11
68274: PUSH
68275: LD_VAR 0 11
68279: PPUSH
68280: LD_VAR 0 11
68284: PUSH
68285: LD_INT 1
68287: PLUS
68288: PPUSH
68289: LD_VAR 0 9
68293: PUSH
68294: LD_VAR 0 3
68298: ARRAY
68299: PPUSH
68300: CALL_OW 2
68304: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68305: LD_ADDR_VAR 0 4
68309: PUSH
68310: LD_VAR 0 4
68314: PUSH
68315: LD_VAR 0 9
68319: PUSH
68320: LD_VAR 0 3
68324: ARRAY
68325: DIFF
68326: ST_TO_ADDR
// end ;
68327: GO 68236
68329: POP
68330: POP
// if p then
68331: LD_VAR 0 11
68335: IFFALSE 68360
// result := Replace ( result , 2 , p ) ;
68337: LD_ADDR_VAR 0 2
68341: PUSH
68342: LD_VAR 0 2
68346: PPUSH
68347: LD_INT 2
68349: PPUSH
68350: LD_VAR 0 11
68354: PPUSH
68355: CALL_OW 1
68359: ST_TO_ADDR
// end else
68360: GO 68406
// for i = eng downto 5 do
68362: LD_ADDR_VAR 0 3
68366: PUSH
68367: DOUBLE
68368: LD_VAR 0 6
68372: INC
68373: ST_TO_ADDR
68374: LD_INT 5
68376: PUSH
68377: FOR_DOWNTO
68378: IFFALSE 68404
// tmp := tmp union eng [ i ] ;
68380: LD_ADDR_VAR 0 4
68384: PUSH
68385: LD_VAR 0 4
68389: PUSH
68390: LD_VAR 0 6
68394: PUSH
68395: LD_VAR 0 3
68399: ARRAY
68400: UNION
68401: ST_TO_ADDR
68402: GO 68377
68404: POP
68405: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
68406: LD_ADDR_VAR 0 2
68410: PUSH
68411: LD_VAR 0 2
68415: PPUSH
68416: LD_INT 1
68418: PPUSH
68419: LD_VAR 0 4
68423: PUSH
68424: LD_VAR 0 5
68428: DIFF
68429: PPUSH
68430: CALL_OW 1
68434: ST_TO_ADDR
// exit ;
68435: GO 68437
// end ; end ;
68437: LD_VAR 0 2
68441: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
68442: LD_INT 0
68444: PPUSH
68445: PPUSH
68446: PPUSH
// if not mc_bases then
68447: LD_EXP 63
68451: NOT
68452: IFFALSE 68456
// exit ;
68454: GO 68598
// for i = 1 to mc_bases do
68456: LD_ADDR_VAR 0 2
68460: PUSH
68461: DOUBLE
68462: LD_INT 1
68464: DEC
68465: ST_TO_ADDR
68466: LD_EXP 63
68470: PUSH
68471: FOR_TO
68472: IFFALSE 68589
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68474: LD_ADDR_VAR 0 3
68478: PUSH
68479: LD_EXP 63
68483: PUSH
68484: LD_VAR 0 2
68488: ARRAY
68489: PPUSH
68490: LD_INT 21
68492: PUSH
68493: LD_INT 3
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 3
68502: PUSH
68503: LD_INT 2
68505: PUSH
68506: LD_INT 30
68508: PUSH
68509: LD_INT 29
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 30
68518: PUSH
68519: LD_INT 30
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: LIST
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 3
68537: PUSH
68538: LD_INT 24
68540: PUSH
68541: LD_INT 1000
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: LIST
68556: PPUSH
68557: CALL_OW 72
68561: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
68562: LD_ADDR_EXP 64
68566: PUSH
68567: LD_EXP 64
68571: PPUSH
68572: LD_VAR 0 2
68576: PPUSH
68577: LD_VAR 0 3
68581: PPUSH
68582: CALL_OW 1
68586: ST_TO_ADDR
// end ;
68587: GO 68471
68589: POP
68590: POP
// RaiseSailEvent ( 101 ) ;
68591: LD_INT 101
68593: PPUSH
68594: CALL_OW 427
// end ;
68598: LD_VAR 0 1
68602: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
68603: LD_INT 0
68605: PPUSH
68606: PPUSH
68607: PPUSH
68608: PPUSH
68609: PPUSH
68610: PPUSH
68611: PPUSH
// if not mc_bases then
68612: LD_EXP 63
68616: NOT
68617: IFFALSE 68621
// exit ;
68619: GO 69183
// for i = 1 to mc_bases do
68621: LD_ADDR_VAR 0 2
68625: PUSH
68626: DOUBLE
68627: LD_INT 1
68629: DEC
68630: ST_TO_ADDR
68631: LD_EXP 63
68635: PUSH
68636: FOR_TO
68637: IFFALSE 69174
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
68639: LD_ADDR_VAR 0 5
68643: PUSH
68644: LD_EXP 63
68648: PUSH
68649: LD_VAR 0 2
68653: ARRAY
68654: PUSH
68655: LD_EXP 92
68659: PUSH
68660: LD_VAR 0 2
68664: ARRAY
68665: UNION
68666: PPUSH
68667: LD_INT 21
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: PUSH
68680: LD_INT 3
68682: PUSH
68683: LD_INT 54
68685: PUSH
68686: EMPTY
68687: LIST
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 3
68695: PUSH
68696: LD_INT 24
68698: PUSH
68699: LD_INT 1000
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: LIST
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PPUSH
68719: CALL_OW 72
68723: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
68724: LD_ADDR_VAR 0 6
68728: PUSH
68729: LD_EXP 63
68733: PUSH
68734: LD_VAR 0 2
68738: ARRAY
68739: PPUSH
68740: LD_INT 21
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 3
68755: PUSH
68756: LD_INT 54
68758: PUSH
68759: EMPTY
68760: LIST
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: LD_INT 3
68768: PUSH
68769: LD_INT 24
68771: PUSH
68772: LD_INT 250
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: LIST
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: PPUSH
68792: CALL_OW 72
68796: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
68797: LD_ADDR_VAR 0 7
68801: PUSH
68802: LD_VAR 0 5
68806: PUSH
68807: LD_VAR 0 6
68811: DIFF
68812: ST_TO_ADDR
// if not need_heal_1 then
68813: LD_VAR 0 6
68817: NOT
68818: IFFALSE 68851
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
68820: LD_ADDR_EXP 66
68824: PUSH
68825: LD_EXP 66
68829: PPUSH
68830: LD_VAR 0 2
68834: PUSH
68835: LD_INT 1
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PPUSH
68842: EMPTY
68843: PPUSH
68844: CALL 22259 0 3
68848: ST_TO_ADDR
68849: GO 68921
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
68851: LD_ADDR_EXP 66
68855: PUSH
68856: LD_EXP 66
68860: PPUSH
68861: LD_VAR 0 2
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PPUSH
68873: LD_EXP 66
68877: PUSH
68878: LD_VAR 0 2
68882: ARRAY
68883: PUSH
68884: LD_INT 1
68886: ARRAY
68887: PPUSH
68888: LD_INT 3
68890: PUSH
68891: LD_INT 24
68893: PUSH
68894: LD_INT 1000
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PPUSH
68905: CALL_OW 72
68909: PUSH
68910: LD_VAR 0 6
68914: UNION
68915: PPUSH
68916: CALL 22259 0 3
68920: ST_TO_ADDR
// if not need_heal_2 then
68921: LD_VAR 0 7
68925: NOT
68926: IFFALSE 68959
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68928: LD_ADDR_EXP 66
68932: PUSH
68933: LD_EXP 66
68937: PPUSH
68938: LD_VAR 0 2
68942: PUSH
68943: LD_INT 2
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PPUSH
68950: EMPTY
68951: PPUSH
68952: CALL 22259 0 3
68956: ST_TO_ADDR
68957: GO 68991
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
68959: LD_ADDR_EXP 66
68963: PUSH
68964: LD_EXP 66
68968: PPUSH
68969: LD_VAR 0 2
68973: PUSH
68974: LD_INT 2
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PPUSH
68981: LD_VAR 0 7
68985: PPUSH
68986: CALL 22259 0 3
68990: ST_TO_ADDR
// if need_heal_2 then
68991: LD_VAR 0 7
68995: IFFALSE 69156
// for j in need_heal_2 do
68997: LD_ADDR_VAR 0 3
69001: PUSH
69002: LD_VAR 0 7
69006: PUSH
69007: FOR_IN
69008: IFFALSE 69154
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69010: LD_ADDR_VAR 0 5
69014: PUSH
69015: LD_EXP 63
69019: PUSH
69020: LD_VAR 0 2
69024: ARRAY
69025: PPUSH
69026: LD_INT 2
69028: PUSH
69029: LD_INT 30
69031: PUSH
69032: LD_INT 6
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 30
69041: PUSH
69042: LD_INT 7
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 30
69051: PUSH
69052: LD_INT 8
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 30
69061: PUSH
69062: LD_INT 0
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 30
69071: PUSH
69072: LD_INT 1
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: PPUSH
69087: CALL_OW 72
69091: ST_TO_ADDR
// if tmp then
69092: LD_VAR 0 5
69096: IFFALSE 69152
// begin k := NearestUnitToUnit ( tmp , j ) ;
69098: LD_ADDR_VAR 0 4
69102: PUSH
69103: LD_VAR 0 5
69107: PPUSH
69108: LD_VAR 0 3
69112: PPUSH
69113: CALL_OW 74
69117: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69118: LD_VAR 0 3
69122: PPUSH
69123: LD_VAR 0 4
69127: PPUSH
69128: CALL_OW 296
69132: PUSH
69133: LD_INT 5
69135: GREATER
69136: IFFALSE 69152
// ComMoveToNearbyEntrance ( j , k ) ;
69138: LD_VAR 0 3
69142: PPUSH
69143: LD_VAR 0 4
69147: PPUSH
69148: CALL 55885 0 2
// end ; end ;
69152: GO 69007
69154: POP
69155: POP
// if not need_heal_1 and not need_heal_2 then
69156: LD_VAR 0 6
69160: NOT
69161: PUSH
69162: LD_VAR 0 7
69166: NOT
69167: AND
69168: IFFALSE 69172
// continue ;
69170: GO 68636
// end ;
69172: GO 68636
69174: POP
69175: POP
// RaiseSailEvent ( 102 ) ;
69176: LD_INT 102
69178: PPUSH
69179: CALL_OW 427
// end ;
69183: LD_VAR 0 1
69187: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
69188: LD_INT 0
69190: PPUSH
69191: PPUSH
69192: PPUSH
69193: PPUSH
69194: PPUSH
69195: PPUSH
69196: PPUSH
69197: PPUSH
// if not mc_bases then
69198: LD_EXP 63
69202: NOT
69203: IFFALSE 69207
// exit ;
69205: GO 70118
// for i = 1 to mc_bases do
69207: LD_ADDR_VAR 0 2
69211: PUSH
69212: DOUBLE
69213: LD_INT 1
69215: DEC
69216: ST_TO_ADDR
69217: LD_EXP 63
69221: PUSH
69222: FOR_TO
69223: IFFALSE 70116
// begin if not mc_building_need_repair [ i ] then
69225: LD_EXP 64
69229: PUSH
69230: LD_VAR 0 2
69234: ARRAY
69235: NOT
69236: IFFALSE 69421
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
69238: LD_ADDR_VAR 0 6
69242: PUSH
69243: LD_EXP 82
69247: PUSH
69248: LD_VAR 0 2
69252: ARRAY
69253: PPUSH
69254: LD_INT 3
69256: PUSH
69257: LD_INT 24
69259: PUSH
69260: LD_INT 1000
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 34
69276: PUSH
69277: LD_INT 13
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 34
69286: PUSH
69287: LD_INT 52
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 34
69296: PUSH
69297: LD_INT 88
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PPUSH
69314: CALL_OW 72
69318: ST_TO_ADDR
// if cranes then
69319: LD_VAR 0 6
69323: IFFALSE 69385
// for j in cranes do
69325: LD_ADDR_VAR 0 3
69329: PUSH
69330: LD_VAR 0 6
69334: PUSH
69335: FOR_IN
69336: IFFALSE 69383
// if not IsInArea ( j , mc_parking [ i ] ) then
69338: LD_VAR 0 3
69342: PPUSH
69343: LD_EXP 87
69347: PUSH
69348: LD_VAR 0 2
69352: ARRAY
69353: PPUSH
69354: CALL_OW 308
69358: NOT
69359: IFFALSE 69381
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69361: LD_VAR 0 3
69365: PPUSH
69366: LD_EXP 87
69370: PUSH
69371: LD_VAR 0 2
69375: ARRAY
69376: PPUSH
69377: CALL_OW 113
69381: GO 69335
69383: POP
69384: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
69385: LD_ADDR_EXP 65
69389: PUSH
69390: LD_EXP 65
69394: PPUSH
69395: LD_VAR 0 2
69399: PPUSH
69400: EMPTY
69401: PPUSH
69402: CALL_OW 1
69406: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
69407: LD_VAR 0 2
69411: PPUSH
69412: LD_INT 101
69414: PPUSH
69415: CALL 64261 0 2
// continue ;
69419: GO 69222
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
69421: LD_ADDR_EXP 69
69425: PUSH
69426: LD_EXP 69
69430: PPUSH
69431: LD_VAR 0 2
69435: PPUSH
69436: EMPTY
69437: PPUSH
69438: CALL_OW 1
69442: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69443: LD_VAR 0 2
69447: PPUSH
69448: LD_INT 103
69450: PPUSH
69451: CALL 64261 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
69455: LD_ADDR_VAR 0 5
69459: PUSH
69460: LD_EXP 63
69464: PUSH
69465: LD_VAR 0 2
69469: ARRAY
69470: PUSH
69471: LD_EXP 92
69475: PUSH
69476: LD_VAR 0 2
69480: ARRAY
69481: UNION
69482: PPUSH
69483: LD_INT 2
69485: PUSH
69486: LD_INT 25
69488: PUSH
69489: LD_INT 2
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 25
69498: PUSH
69499: LD_INT 16
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: LIST
69510: PUSH
69511: EMPTY
69512: LIST
69513: PPUSH
69514: CALL_OW 72
69518: ST_TO_ADDR
// if mc_need_heal [ i ] then
69519: LD_EXP 66
69523: PUSH
69524: LD_VAR 0 2
69528: ARRAY
69529: IFFALSE 69573
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
69531: LD_ADDR_VAR 0 5
69535: PUSH
69536: LD_VAR 0 5
69540: PUSH
69541: LD_EXP 66
69545: PUSH
69546: LD_VAR 0 2
69550: ARRAY
69551: PUSH
69552: LD_INT 1
69554: ARRAY
69555: PUSH
69556: LD_EXP 66
69560: PUSH
69561: LD_VAR 0 2
69565: ARRAY
69566: PUSH
69567: LD_INT 2
69569: ARRAY
69570: UNION
69571: DIFF
69572: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
69573: LD_ADDR_VAR 0 6
69577: PUSH
69578: LD_EXP 82
69582: PUSH
69583: LD_VAR 0 2
69587: ARRAY
69588: PPUSH
69589: LD_INT 2
69591: PUSH
69592: LD_INT 34
69594: PUSH
69595: LD_INT 13
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 34
69604: PUSH
69605: LD_INT 52
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 34
69614: PUSH
69615: LD_INT 88
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: PPUSH
69628: CALL_OW 72
69632: ST_TO_ADDR
// if cranes then
69633: LD_VAR 0 6
69637: IFFALSE 69805
// begin for j in cranes do
69639: LD_ADDR_VAR 0 3
69643: PUSH
69644: LD_VAR 0 6
69648: PUSH
69649: FOR_IN
69650: IFFALSE 69803
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
69652: LD_VAR 0 3
69656: PPUSH
69657: CALL_OW 256
69661: PUSH
69662: LD_INT 1000
69664: EQUAL
69665: PUSH
69666: LD_VAR 0 3
69670: PPUSH
69671: CALL_OW 314
69675: NOT
69676: AND
69677: IFFALSE 69743
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
69679: LD_ADDR_VAR 0 8
69683: PUSH
69684: LD_EXP 64
69688: PUSH
69689: LD_VAR 0 2
69693: ARRAY
69694: PPUSH
69695: LD_VAR 0 3
69699: PPUSH
69700: CALL_OW 74
69704: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
69705: LD_VAR 0 8
69709: PPUSH
69710: LD_INT 16
69712: PPUSH
69713: CALL 25224 0 2
69717: PUSH
69718: LD_INT 4
69720: ARRAY
69721: PUSH
69722: LD_INT 10
69724: LESS
69725: IFFALSE 69741
// ComRepairBuilding ( j , to_repair ) ;
69727: LD_VAR 0 3
69731: PPUSH
69732: LD_VAR 0 8
69736: PPUSH
69737: CALL_OW 130
// end else
69741: GO 69801
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
69743: LD_VAR 0 3
69747: PPUSH
69748: CALL_OW 256
69752: PUSH
69753: LD_INT 500
69755: LESS
69756: PUSH
69757: LD_VAR 0 3
69761: PPUSH
69762: LD_EXP 87
69766: PUSH
69767: LD_VAR 0 2
69771: ARRAY
69772: PPUSH
69773: CALL_OW 308
69777: NOT
69778: AND
69779: IFFALSE 69801
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69781: LD_VAR 0 3
69785: PPUSH
69786: LD_EXP 87
69790: PUSH
69791: LD_VAR 0 2
69795: ARRAY
69796: PPUSH
69797: CALL_OW 113
// end ;
69801: GO 69649
69803: POP
69804: POP
// end ; if tmp > 3 then
69805: LD_VAR 0 5
69809: PUSH
69810: LD_INT 3
69812: GREATER
69813: IFFALSE 69833
// tmp := ShrinkArray ( tmp , 4 ) ;
69815: LD_ADDR_VAR 0 5
69819: PUSH
69820: LD_VAR 0 5
69824: PPUSH
69825: LD_INT 4
69827: PPUSH
69828: CALL 55323 0 2
69832: ST_TO_ADDR
// if not tmp then
69833: LD_VAR 0 5
69837: NOT
69838: IFFALSE 69842
// continue ;
69840: GO 69222
// for j in tmp do
69842: LD_ADDR_VAR 0 3
69846: PUSH
69847: LD_VAR 0 5
69851: PUSH
69852: FOR_IN
69853: IFFALSE 70112
// begin if IsInUnit ( j ) then
69855: LD_VAR 0 3
69859: PPUSH
69860: CALL_OW 310
69864: IFFALSE 69875
// ComExitBuilding ( j ) ;
69866: LD_VAR 0 3
69870: PPUSH
69871: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
69875: LD_VAR 0 3
69879: PUSH
69880: LD_EXP 65
69884: PUSH
69885: LD_VAR 0 2
69889: ARRAY
69890: IN
69891: NOT
69892: IFFALSE 69950
// begin SetTag ( j , 101 ) ;
69894: LD_VAR 0 3
69898: PPUSH
69899: LD_INT 101
69901: PPUSH
69902: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69906: LD_ADDR_EXP 65
69910: PUSH
69911: LD_EXP 65
69915: PPUSH
69916: LD_VAR 0 2
69920: PUSH
69921: LD_EXP 65
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: PUSH
69932: LD_INT 1
69934: PLUS
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PPUSH
69940: LD_VAR 0 3
69944: PPUSH
69945: CALL 22259 0 3
69949: ST_TO_ADDR
// end ; wait ( 1 ) ;
69950: LD_INT 1
69952: PPUSH
69953: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
69957: LD_ADDR_VAR 0 7
69961: PUSH
69962: LD_EXP 64
69966: PUSH
69967: LD_VAR 0 2
69971: ARRAY
69972: ST_TO_ADDR
// if mc_scan [ i ] then
69973: LD_EXP 86
69977: PUSH
69978: LD_VAR 0 2
69982: ARRAY
69983: IFFALSE 70045
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
69985: LD_ADDR_VAR 0 7
69989: PUSH
69990: LD_EXP 64
69994: PUSH
69995: LD_VAR 0 2
69999: ARRAY
70000: PPUSH
70001: LD_INT 3
70003: PUSH
70004: LD_INT 30
70006: PUSH
70007: LD_INT 32
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 30
70016: PUSH
70017: LD_INT 33
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 30
70026: PUSH
70027: LD_INT 31
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: PPUSH
70040: CALL_OW 72
70044: ST_TO_ADDR
// if not to_repair_tmp then
70045: LD_VAR 0 7
70049: NOT
70050: IFFALSE 70054
// continue ;
70052: GO 69852
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70054: LD_ADDR_VAR 0 8
70058: PUSH
70059: LD_VAR 0 7
70063: PPUSH
70064: LD_VAR 0 3
70068: PPUSH
70069: CALL_OW 74
70073: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
70074: LD_VAR 0 8
70078: PPUSH
70079: LD_INT 16
70081: PPUSH
70082: CALL 25224 0 2
70086: PUSH
70087: LD_INT 4
70089: ARRAY
70090: PUSH
70091: LD_INT 14
70093: LESS
70094: IFFALSE 70110
// ComRepairBuilding ( j , to_repair ) ;
70096: LD_VAR 0 3
70100: PPUSH
70101: LD_VAR 0 8
70105: PPUSH
70106: CALL_OW 130
// end ;
70110: GO 69852
70112: POP
70113: POP
// end ;
70114: GO 69222
70116: POP
70117: POP
// end ;
70118: LD_VAR 0 1
70122: RET
// export function MC_Heal ; var i , j , tmp ; begin
70123: LD_INT 0
70125: PPUSH
70126: PPUSH
70127: PPUSH
70128: PPUSH
// if not mc_bases then
70129: LD_EXP 63
70133: NOT
70134: IFFALSE 70138
// exit ;
70136: GO 70540
// for i = 1 to mc_bases do
70138: LD_ADDR_VAR 0 2
70142: PUSH
70143: DOUBLE
70144: LD_INT 1
70146: DEC
70147: ST_TO_ADDR
70148: LD_EXP 63
70152: PUSH
70153: FOR_TO
70154: IFFALSE 70538
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
70156: LD_EXP 66
70160: PUSH
70161: LD_VAR 0 2
70165: ARRAY
70166: PUSH
70167: LD_INT 1
70169: ARRAY
70170: NOT
70171: PUSH
70172: LD_EXP 66
70176: PUSH
70177: LD_VAR 0 2
70181: ARRAY
70182: PUSH
70183: LD_INT 2
70185: ARRAY
70186: NOT
70187: AND
70188: IFFALSE 70226
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
70190: LD_ADDR_EXP 67
70194: PUSH
70195: LD_EXP 67
70199: PPUSH
70200: LD_VAR 0 2
70204: PPUSH
70205: EMPTY
70206: PPUSH
70207: CALL_OW 1
70211: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
70212: LD_VAR 0 2
70216: PPUSH
70217: LD_INT 102
70219: PPUSH
70220: CALL 64261 0 2
// continue ;
70224: GO 70153
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70226: LD_ADDR_VAR 0 4
70230: PUSH
70231: LD_EXP 63
70235: PUSH
70236: LD_VAR 0 2
70240: ARRAY
70241: PPUSH
70242: LD_INT 25
70244: PUSH
70245: LD_INT 4
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PPUSH
70252: CALL_OW 72
70256: ST_TO_ADDR
// if not tmp then
70257: LD_VAR 0 4
70261: NOT
70262: IFFALSE 70266
// continue ;
70264: GO 70153
// if mc_taming [ i ] then
70266: LD_EXP 94
70270: PUSH
70271: LD_VAR 0 2
70275: ARRAY
70276: IFFALSE 70300
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70278: LD_ADDR_EXP 94
70282: PUSH
70283: LD_EXP 94
70287: PPUSH
70288: LD_VAR 0 2
70292: PPUSH
70293: EMPTY
70294: PPUSH
70295: CALL_OW 1
70299: ST_TO_ADDR
// for j in tmp do
70300: LD_ADDR_VAR 0 3
70304: PUSH
70305: LD_VAR 0 4
70309: PUSH
70310: FOR_IN
70311: IFFALSE 70534
// begin if IsInUnit ( j ) then
70313: LD_VAR 0 3
70317: PPUSH
70318: CALL_OW 310
70322: IFFALSE 70333
// ComExitBuilding ( j ) ;
70324: LD_VAR 0 3
70328: PPUSH
70329: CALL_OW 122
// if not j in mc_healers [ i ] then
70333: LD_VAR 0 3
70337: PUSH
70338: LD_EXP 67
70342: PUSH
70343: LD_VAR 0 2
70347: ARRAY
70348: IN
70349: NOT
70350: IFFALSE 70396
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
70352: LD_ADDR_EXP 67
70356: PUSH
70357: LD_EXP 67
70361: PPUSH
70362: LD_VAR 0 2
70366: PUSH
70367: LD_EXP 67
70371: PUSH
70372: LD_VAR 0 2
70376: ARRAY
70377: PUSH
70378: LD_INT 1
70380: PLUS
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PPUSH
70386: LD_VAR 0 3
70390: PPUSH
70391: CALL 22259 0 3
70395: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
70396: LD_VAR 0 3
70400: PPUSH
70401: CALL_OW 110
70405: PUSH
70406: LD_INT 102
70408: NONEQUAL
70409: IFFALSE 70423
// SetTag ( j , 102 ) ;
70411: LD_VAR 0 3
70415: PPUSH
70416: LD_INT 102
70418: PPUSH
70419: CALL_OW 109
// Wait ( 3 ) ;
70423: LD_INT 3
70425: PPUSH
70426: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
70430: LD_EXP 66
70434: PUSH
70435: LD_VAR 0 2
70439: ARRAY
70440: PUSH
70441: LD_INT 1
70443: ARRAY
70444: IFFALSE 70476
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
70446: LD_VAR 0 3
70450: PPUSH
70451: LD_EXP 66
70455: PUSH
70456: LD_VAR 0 2
70460: ARRAY
70461: PUSH
70462: LD_INT 1
70464: ARRAY
70465: PUSH
70466: LD_INT 1
70468: ARRAY
70469: PPUSH
70470: CALL_OW 128
70474: GO 70532
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
70476: LD_VAR 0 3
70480: PPUSH
70481: CALL_OW 314
70485: NOT
70486: PUSH
70487: LD_EXP 66
70491: PUSH
70492: LD_VAR 0 2
70496: ARRAY
70497: PUSH
70498: LD_INT 2
70500: ARRAY
70501: AND
70502: IFFALSE 70532
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
70504: LD_VAR 0 3
70508: PPUSH
70509: LD_EXP 66
70513: PUSH
70514: LD_VAR 0 2
70518: ARRAY
70519: PUSH
70520: LD_INT 2
70522: ARRAY
70523: PUSH
70524: LD_INT 1
70526: ARRAY
70527: PPUSH
70528: CALL_OW 128
// end ;
70532: GO 70310
70534: POP
70535: POP
// end ;
70536: GO 70153
70538: POP
70539: POP
// end ;
70540: LD_VAR 0 1
70544: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
70545: LD_INT 0
70547: PPUSH
70548: PPUSH
70549: PPUSH
70550: PPUSH
70551: PPUSH
70552: PPUSH
// if not mc_bases then
70553: LD_EXP 63
70557: NOT
70558: IFFALSE 70562
// exit ;
70560: GO 71725
// for i = 1 to mc_bases do
70562: LD_ADDR_VAR 0 2
70566: PUSH
70567: DOUBLE
70568: LD_INT 1
70570: DEC
70571: ST_TO_ADDR
70572: LD_EXP 63
70576: PUSH
70577: FOR_TO
70578: IFFALSE 71723
// begin if mc_scan [ i ] then
70580: LD_EXP 86
70584: PUSH
70585: LD_VAR 0 2
70589: ARRAY
70590: IFFALSE 70594
// continue ;
70592: GO 70577
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
70594: LD_EXP 68
70598: PUSH
70599: LD_VAR 0 2
70603: ARRAY
70604: NOT
70605: PUSH
70606: LD_EXP 70
70610: PUSH
70611: LD_VAR 0 2
70615: ARRAY
70616: NOT
70617: AND
70618: PUSH
70619: LD_EXP 69
70623: PUSH
70624: LD_VAR 0 2
70628: ARRAY
70629: AND
70630: IFFALSE 70668
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
70632: LD_ADDR_EXP 69
70636: PUSH
70637: LD_EXP 69
70641: PPUSH
70642: LD_VAR 0 2
70646: PPUSH
70647: EMPTY
70648: PPUSH
70649: CALL_OW 1
70653: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70654: LD_VAR 0 2
70658: PPUSH
70659: LD_INT 103
70661: PPUSH
70662: CALL 64261 0 2
// continue ;
70666: GO 70577
// end ; if mc_construct_list [ i ] then
70668: LD_EXP 70
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: IFFALSE 70898
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70680: LD_ADDR_VAR 0 5
70684: PUSH
70685: LD_EXP 63
70689: PUSH
70690: LD_VAR 0 2
70694: ARRAY
70695: PPUSH
70696: LD_INT 25
70698: PUSH
70699: LD_INT 2
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PPUSH
70706: CALL_OW 72
70710: PUSH
70711: LD_EXP 65
70715: PUSH
70716: LD_VAR 0 2
70720: ARRAY
70721: DIFF
70722: ST_TO_ADDR
// if not tmp then
70723: LD_VAR 0 5
70727: NOT
70728: IFFALSE 70732
// continue ;
70730: GO 70577
// for j in tmp do
70732: LD_ADDR_VAR 0 3
70736: PUSH
70737: LD_VAR 0 5
70741: PUSH
70742: FOR_IN
70743: IFFALSE 70894
// begin if not mc_builders [ i ] then
70745: LD_EXP 69
70749: PUSH
70750: LD_VAR 0 2
70754: ARRAY
70755: NOT
70756: IFFALSE 70814
// begin SetTag ( j , 103 ) ;
70758: LD_VAR 0 3
70762: PPUSH
70763: LD_INT 103
70765: PPUSH
70766: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70770: LD_ADDR_EXP 69
70774: PUSH
70775: LD_EXP 69
70779: PPUSH
70780: LD_VAR 0 2
70784: PUSH
70785: LD_EXP 69
70789: PUSH
70790: LD_VAR 0 2
70794: ARRAY
70795: PUSH
70796: LD_INT 1
70798: PLUS
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PPUSH
70804: LD_VAR 0 3
70808: PPUSH
70809: CALL 22259 0 3
70813: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70814: LD_VAR 0 3
70818: PPUSH
70819: CALL_OW 310
70823: IFFALSE 70834
// ComExitBuilding ( j ) ;
70825: LD_VAR 0 3
70829: PPUSH
70830: CALL_OW 122
// wait ( 3 ) ;
70834: LD_INT 3
70836: PPUSH
70837: CALL_OW 67
// if not mc_construct_list [ i ] then
70841: LD_EXP 70
70845: PUSH
70846: LD_VAR 0 2
70850: ARRAY
70851: NOT
70852: IFFALSE 70856
// break ;
70854: GO 70894
// if not HasTask ( j ) then
70856: LD_VAR 0 3
70860: PPUSH
70861: CALL_OW 314
70865: NOT
70866: IFFALSE 70892
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
70868: LD_VAR 0 3
70872: PPUSH
70873: LD_EXP 70
70877: PUSH
70878: LD_VAR 0 2
70882: ARRAY
70883: PUSH
70884: LD_INT 1
70886: ARRAY
70887: PPUSH
70888: CALL 25497 0 2
// end ;
70892: GO 70742
70894: POP
70895: POP
// end else
70896: GO 71721
// if mc_build_list [ i ] then
70898: LD_EXP 68
70902: PUSH
70903: LD_VAR 0 2
70907: ARRAY
70908: IFFALSE 71721
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70910: LD_EXP 68
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: PUSH
70921: LD_INT 1
70923: ARRAY
70924: PUSH
70925: LD_INT 1
70927: ARRAY
70928: PPUSH
70929: CALL 25321 0 1
70933: PUSH
70934: LD_EXP 63
70938: PUSH
70939: LD_VAR 0 2
70943: ARRAY
70944: PPUSH
70945: LD_INT 2
70947: PUSH
70948: LD_INT 30
70950: PUSH
70951: LD_INT 2
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 30
70960: PUSH
70961: LD_INT 3
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: LIST
70972: PPUSH
70973: CALL_OW 72
70977: NOT
70978: AND
70979: IFFALSE 71084
// begin for j = 1 to mc_build_list [ i ] do
70981: LD_ADDR_VAR 0 3
70985: PUSH
70986: DOUBLE
70987: LD_INT 1
70989: DEC
70990: ST_TO_ADDR
70991: LD_EXP 68
70995: PUSH
70996: LD_VAR 0 2
71000: ARRAY
71001: PUSH
71002: FOR_TO
71003: IFFALSE 71082
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71005: LD_EXP 68
71009: PUSH
71010: LD_VAR 0 2
71014: ARRAY
71015: PUSH
71016: LD_VAR 0 3
71020: ARRAY
71021: PUSH
71022: LD_INT 1
71024: ARRAY
71025: PUSH
71026: LD_INT 2
71028: EQUAL
71029: IFFALSE 71080
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71031: LD_ADDR_EXP 68
71035: PUSH
71036: LD_EXP 68
71040: PPUSH
71041: LD_VAR 0 2
71045: PPUSH
71046: LD_EXP 68
71050: PUSH
71051: LD_VAR 0 2
71055: ARRAY
71056: PPUSH
71057: LD_VAR 0 3
71061: PPUSH
71062: LD_INT 1
71064: PPUSH
71065: LD_INT 0
71067: PPUSH
71068: CALL 21677 0 4
71072: PPUSH
71073: CALL_OW 1
71077: ST_TO_ADDR
// break ;
71078: GO 71082
// end ;
71080: GO 71002
71082: POP
71083: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71084: LD_ADDR_VAR 0 6
71088: PUSH
71089: LD_EXP 63
71093: PUSH
71094: LD_VAR 0 2
71098: ARRAY
71099: PPUSH
71100: LD_INT 2
71102: PUSH
71103: LD_INT 30
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 30
71115: PUSH
71116: LD_INT 1
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: PPUSH
71128: CALL_OW 72
71132: ST_TO_ADDR
// for k := 1 to depot do
71133: LD_ADDR_VAR 0 4
71137: PUSH
71138: DOUBLE
71139: LD_INT 1
71141: DEC
71142: ST_TO_ADDR
71143: LD_VAR 0 6
71147: PUSH
71148: FOR_TO
71149: IFFALSE 71719
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
71151: LD_EXP 68
71155: PUSH
71156: LD_VAR 0 2
71160: ARRAY
71161: PUSH
71162: LD_INT 1
71164: ARRAY
71165: PUSH
71166: LD_INT 1
71168: ARRAY
71169: PUSH
71170: LD_INT 0
71172: EQUAL
71173: PUSH
71174: LD_VAR 0 6
71178: PUSH
71179: LD_VAR 0 4
71183: ARRAY
71184: PPUSH
71185: LD_EXP 68
71189: PUSH
71190: LD_VAR 0 2
71194: ARRAY
71195: PUSH
71196: LD_INT 1
71198: ARRAY
71199: PUSH
71200: LD_INT 1
71202: ARRAY
71203: PPUSH
71204: LD_EXP 68
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_INT 1
71217: ARRAY
71218: PUSH
71219: LD_INT 2
71221: ARRAY
71222: PPUSH
71223: LD_EXP 68
71227: PUSH
71228: LD_VAR 0 2
71232: ARRAY
71233: PUSH
71234: LD_INT 1
71236: ARRAY
71237: PUSH
71238: LD_INT 3
71240: ARRAY
71241: PPUSH
71242: LD_EXP 68
71246: PUSH
71247: LD_VAR 0 2
71251: ARRAY
71252: PUSH
71253: LD_INT 1
71255: ARRAY
71256: PUSH
71257: LD_INT 4
71259: ARRAY
71260: PPUSH
71261: CALL 30733 0 5
71265: OR
71266: IFFALSE 71547
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71268: LD_ADDR_VAR 0 5
71272: PUSH
71273: LD_EXP 63
71277: PUSH
71278: LD_VAR 0 2
71282: ARRAY
71283: PPUSH
71284: LD_INT 25
71286: PUSH
71287: LD_INT 2
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PPUSH
71294: CALL_OW 72
71298: PUSH
71299: LD_EXP 65
71303: PUSH
71304: LD_VAR 0 2
71308: ARRAY
71309: DIFF
71310: ST_TO_ADDR
// if not tmp then
71311: LD_VAR 0 5
71315: NOT
71316: IFFALSE 71320
// continue ;
71318: GO 71148
// for j in tmp do
71320: LD_ADDR_VAR 0 3
71324: PUSH
71325: LD_VAR 0 5
71329: PUSH
71330: FOR_IN
71331: IFFALSE 71543
// begin if not mc_builders [ i ] then
71333: LD_EXP 69
71337: PUSH
71338: LD_VAR 0 2
71342: ARRAY
71343: NOT
71344: IFFALSE 71402
// begin SetTag ( j , 103 ) ;
71346: LD_VAR 0 3
71350: PPUSH
71351: LD_INT 103
71353: PPUSH
71354: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71358: LD_ADDR_EXP 69
71362: PUSH
71363: LD_EXP 69
71367: PPUSH
71368: LD_VAR 0 2
71372: PUSH
71373: LD_EXP 69
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PUSH
71384: LD_INT 1
71386: PLUS
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PPUSH
71392: LD_VAR 0 3
71396: PPUSH
71397: CALL 22259 0 3
71401: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71402: LD_VAR 0 3
71406: PPUSH
71407: CALL_OW 310
71411: IFFALSE 71422
// ComExitBuilding ( j ) ;
71413: LD_VAR 0 3
71417: PPUSH
71418: CALL_OW 122
// wait ( 3 ) ;
71422: LD_INT 3
71424: PPUSH
71425: CALL_OW 67
// if not mc_build_list [ i ] then
71429: LD_EXP 68
71433: PUSH
71434: LD_VAR 0 2
71438: ARRAY
71439: NOT
71440: IFFALSE 71444
// break ;
71442: GO 71543
// if not HasTask ( j ) then
71444: LD_VAR 0 3
71448: PPUSH
71449: CALL_OW 314
71453: NOT
71454: IFFALSE 71541
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
71456: LD_VAR 0 3
71460: PPUSH
71461: LD_EXP 68
71465: PUSH
71466: LD_VAR 0 2
71470: ARRAY
71471: PUSH
71472: LD_INT 1
71474: ARRAY
71475: PUSH
71476: LD_INT 1
71478: ARRAY
71479: PPUSH
71480: LD_EXP 68
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: PUSH
71491: LD_INT 1
71493: ARRAY
71494: PUSH
71495: LD_INT 2
71497: ARRAY
71498: PPUSH
71499: LD_EXP 68
71503: PUSH
71504: LD_VAR 0 2
71508: ARRAY
71509: PUSH
71510: LD_INT 1
71512: ARRAY
71513: PUSH
71514: LD_INT 3
71516: ARRAY
71517: PPUSH
71518: LD_EXP 68
71522: PUSH
71523: LD_VAR 0 2
71527: ARRAY
71528: PUSH
71529: LD_INT 1
71531: ARRAY
71532: PUSH
71533: LD_INT 4
71535: ARRAY
71536: PPUSH
71537: CALL_OW 145
// end ;
71541: GO 71330
71543: POP
71544: POP
// end else
71545: GO 71717
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
71547: LD_EXP 63
71551: PUSH
71552: LD_VAR 0 2
71556: ARRAY
71557: PPUSH
71558: LD_EXP 68
71562: PUSH
71563: LD_VAR 0 2
71567: ARRAY
71568: PUSH
71569: LD_INT 1
71571: ARRAY
71572: PUSH
71573: LD_INT 1
71575: ARRAY
71576: PPUSH
71577: LD_EXP 68
71581: PUSH
71582: LD_VAR 0 2
71586: ARRAY
71587: PUSH
71588: LD_INT 1
71590: ARRAY
71591: PUSH
71592: LD_INT 2
71594: ARRAY
71595: PPUSH
71596: LD_EXP 68
71600: PUSH
71601: LD_VAR 0 2
71605: ARRAY
71606: PUSH
71607: LD_INT 1
71609: ARRAY
71610: PUSH
71611: LD_INT 3
71613: ARRAY
71614: PPUSH
71615: LD_EXP 68
71619: PUSH
71620: LD_VAR 0 2
71624: ARRAY
71625: PUSH
71626: LD_INT 1
71628: ARRAY
71629: PUSH
71630: LD_INT 4
71632: ARRAY
71633: PPUSH
71634: LD_EXP 63
71638: PUSH
71639: LD_VAR 0 2
71643: ARRAY
71644: PPUSH
71645: LD_INT 21
71647: PUSH
71648: LD_INT 3
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PPUSH
71655: CALL_OW 72
71659: PPUSH
71660: EMPTY
71661: PPUSH
71662: CALL 29487 0 7
71666: NOT
71667: IFFALSE 71717
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
71669: LD_ADDR_EXP 68
71673: PUSH
71674: LD_EXP 68
71678: PPUSH
71679: LD_VAR 0 2
71683: PPUSH
71684: LD_EXP 68
71688: PUSH
71689: LD_VAR 0 2
71693: ARRAY
71694: PPUSH
71695: LD_INT 1
71697: PPUSH
71698: LD_INT 1
71700: NEG
71701: PPUSH
71702: LD_INT 0
71704: PPUSH
71705: CALL 21677 0 4
71709: PPUSH
71710: CALL_OW 1
71714: ST_TO_ADDR
// continue ;
71715: GO 71148
// end ; end ;
71717: GO 71148
71719: POP
71720: POP
// end ; end ;
71721: GO 70577
71723: POP
71724: POP
// end ;
71725: LD_VAR 0 1
71729: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
71730: LD_INT 0
71732: PPUSH
71733: PPUSH
71734: PPUSH
71735: PPUSH
71736: PPUSH
71737: PPUSH
// if not mc_bases then
71738: LD_EXP 63
71742: NOT
71743: IFFALSE 71747
// exit ;
71745: GO 72174
// for i = 1 to mc_bases do
71747: LD_ADDR_VAR 0 2
71751: PUSH
71752: DOUBLE
71753: LD_INT 1
71755: DEC
71756: ST_TO_ADDR
71757: LD_EXP 63
71761: PUSH
71762: FOR_TO
71763: IFFALSE 72172
// begin tmp := mc_build_upgrade [ i ] ;
71765: LD_ADDR_VAR 0 4
71769: PUSH
71770: LD_EXP 95
71774: PUSH
71775: LD_VAR 0 2
71779: ARRAY
71780: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
71781: LD_ADDR_VAR 0 6
71785: PUSH
71786: LD_EXP 96
71790: PUSH
71791: LD_VAR 0 2
71795: ARRAY
71796: PPUSH
71797: LD_INT 2
71799: PUSH
71800: LD_INT 30
71802: PUSH
71803: LD_INT 6
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 30
71812: PUSH
71813: LD_INT 7
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: LIST
71824: PPUSH
71825: CALL_OW 72
71829: ST_TO_ADDR
// if not tmp and not lab then
71830: LD_VAR 0 4
71834: NOT
71835: PUSH
71836: LD_VAR 0 6
71840: NOT
71841: AND
71842: IFFALSE 71846
// continue ;
71844: GO 71762
// if tmp then
71846: LD_VAR 0 4
71850: IFFALSE 71970
// for j in tmp do
71852: LD_ADDR_VAR 0 3
71856: PUSH
71857: LD_VAR 0 4
71861: PUSH
71862: FOR_IN
71863: IFFALSE 71968
// begin if UpgradeCost ( j ) then
71865: LD_VAR 0 3
71869: PPUSH
71870: CALL 29147 0 1
71874: IFFALSE 71966
// begin ComUpgrade ( j ) ;
71876: LD_VAR 0 3
71880: PPUSH
71881: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71885: LD_ADDR_EXP 95
71889: PUSH
71890: LD_EXP 95
71894: PPUSH
71895: LD_VAR 0 2
71899: PPUSH
71900: LD_EXP 95
71904: PUSH
71905: LD_VAR 0 2
71909: ARRAY
71910: PUSH
71911: LD_VAR 0 3
71915: DIFF
71916: PPUSH
71917: CALL_OW 1
71921: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71922: LD_ADDR_EXP 70
71926: PUSH
71927: LD_EXP 70
71931: PPUSH
71932: LD_VAR 0 2
71936: PUSH
71937: LD_EXP 70
71941: PUSH
71942: LD_VAR 0 2
71946: ARRAY
71947: PUSH
71948: LD_INT 1
71950: PLUS
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PPUSH
71956: LD_VAR 0 3
71960: PPUSH
71961: CALL 22259 0 3
71965: ST_TO_ADDR
// end ; end ;
71966: GO 71862
71968: POP
71969: POP
// if not lab or not mc_lab_upgrade [ i ] then
71970: LD_VAR 0 6
71974: NOT
71975: PUSH
71976: LD_EXP 97
71980: PUSH
71981: LD_VAR 0 2
71985: ARRAY
71986: NOT
71987: OR
71988: IFFALSE 71992
// continue ;
71990: GO 71762
// for j in lab do
71992: LD_ADDR_VAR 0 3
71996: PUSH
71997: LD_VAR 0 6
72001: PUSH
72002: FOR_IN
72003: IFFALSE 72168
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72005: LD_VAR 0 3
72009: PPUSH
72010: CALL_OW 266
72014: PUSH
72015: LD_INT 6
72017: PUSH
72018: LD_INT 7
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: IN
72025: PUSH
72026: LD_VAR 0 3
72030: PPUSH
72031: CALL_OW 461
72035: PUSH
72036: LD_INT 1
72038: NONEQUAL
72039: AND
72040: IFFALSE 72166
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72042: LD_VAR 0 3
72046: PPUSH
72047: LD_EXP 97
72051: PUSH
72052: LD_VAR 0 2
72056: ARRAY
72057: PUSH
72058: LD_INT 1
72060: ARRAY
72061: PPUSH
72062: CALL 29352 0 2
72066: IFFALSE 72166
// begin ComCancel ( j ) ;
72068: LD_VAR 0 3
72072: PPUSH
72073: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72077: LD_VAR 0 3
72081: PPUSH
72082: LD_EXP 97
72086: PUSH
72087: LD_VAR 0 2
72091: ARRAY
72092: PUSH
72093: LD_INT 1
72095: ARRAY
72096: PPUSH
72097: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72101: LD_VAR 0 3
72105: PUSH
72106: LD_EXP 70
72110: PUSH
72111: LD_VAR 0 2
72115: ARRAY
72116: IN
72117: NOT
72118: IFFALSE 72164
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72120: LD_ADDR_EXP 70
72124: PUSH
72125: LD_EXP 70
72129: PPUSH
72130: LD_VAR 0 2
72134: PUSH
72135: LD_EXP 70
72139: PUSH
72140: LD_VAR 0 2
72144: ARRAY
72145: PUSH
72146: LD_INT 1
72148: PLUS
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PPUSH
72154: LD_VAR 0 3
72158: PPUSH
72159: CALL 22259 0 3
72163: ST_TO_ADDR
// break ;
72164: GO 72168
// end ; end ; end ;
72166: GO 72002
72168: POP
72169: POP
// end ;
72170: GO 71762
72172: POP
72173: POP
// end ;
72174: LD_VAR 0 1
72178: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
72179: LD_INT 0
72181: PPUSH
72182: PPUSH
72183: PPUSH
72184: PPUSH
72185: PPUSH
72186: PPUSH
72187: PPUSH
72188: PPUSH
72189: PPUSH
// if not mc_bases then
72190: LD_EXP 63
72194: NOT
72195: IFFALSE 72199
// exit ;
72197: GO 72604
// for i = 1 to mc_bases do
72199: LD_ADDR_VAR 0 2
72203: PUSH
72204: DOUBLE
72205: LD_INT 1
72207: DEC
72208: ST_TO_ADDR
72209: LD_EXP 63
72213: PUSH
72214: FOR_TO
72215: IFFALSE 72602
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
72217: LD_EXP 71
72221: PUSH
72222: LD_VAR 0 2
72226: ARRAY
72227: NOT
72228: PUSH
72229: LD_EXP 63
72233: PUSH
72234: LD_VAR 0 2
72238: ARRAY
72239: PPUSH
72240: LD_INT 30
72242: PUSH
72243: LD_INT 3
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PPUSH
72250: CALL_OW 72
72254: NOT
72255: OR
72256: IFFALSE 72260
// continue ;
72258: GO 72214
// busy := false ;
72260: LD_ADDR_VAR 0 8
72264: PUSH
72265: LD_INT 0
72267: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72268: LD_ADDR_VAR 0 4
72272: PUSH
72273: LD_EXP 63
72277: PUSH
72278: LD_VAR 0 2
72282: ARRAY
72283: PPUSH
72284: LD_INT 30
72286: PUSH
72287: LD_INT 3
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PPUSH
72294: CALL_OW 72
72298: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
72299: LD_ADDR_VAR 0 6
72303: PUSH
72304: LD_EXP 71
72308: PUSH
72309: LD_VAR 0 2
72313: ARRAY
72314: PPUSH
72315: LD_INT 2
72317: PUSH
72318: LD_INT 30
72320: PUSH
72321: LD_INT 32
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 30
72330: PUSH
72331: LD_INT 33
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: LIST
72342: PPUSH
72343: CALL_OW 72
72347: ST_TO_ADDR
// if not t then
72348: LD_VAR 0 6
72352: NOT
72353: IFFALSE 72357
// continue ;
72355: GO 72214
// for j in tmp do
72357: LD_ADDR_VAR 0 3
72361: PUSH
72362: LD_VAR 0 4
72366: PUSH
72367: FOR_IN
72368: IFFALSE 72398
// if not BuildingStatus ( j ) = bs_idle then
72370: LD_VAR 0 3
72374: PPUSH
72375: CALL_OW 461
72379: PUSH
72380: LD_INT 2
72382: EQUAL
72383: NOT
72384: IFFALSE 72396
// begin busy := true ;
72386: LD_ADDR_VAR 0 8
72390: PUSH
72391: LD_INT 1
72393: ST_TO_ADDR
// break ;
72394: GO 72398
// end ;
72396: GO 72367
72398: POP
72399: POP
// if busy then
72400: LD_VAR 0 8
72404: IFFALSE 72408
// continue ;
72406: GO 72214
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
72408: LD_ADDR_VAR 0 7
72412: PUSH
72413: LD_VAR 0 6
72417: PPUSH
72418: LD_INT 35
72420: PUSH
72421: LD_INT 0
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PPUSH
72428: CALL_OW 72
72432: ST_TO_ADDR
// if tw then
72433: LD_VAR 0 7
72437: IFFALSE 72514
// begin tw := tw [ 1 ] ;
72439: LD_ADDR_VAR 0 7
72443: PUSH
72444: LD_VAR 0 7
72448: PUSH
72449: LD_INT 1
72451: ARRAY
72452: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
72453: LD_ADDR_VAR 0 9
72457: PUSH
72458: LD_VAR 0 7
72462: PPUSH
72463: LD_EXP 88
72467: PUSH
72468: LD_VAR 0 2
72472: ARRAY
72473: PPUSH
72474: CALL 27644 0 2
72478: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
72479: LD_EXP 102
72483: PUSH
72484: LD_VAR 0 2
72488: ARRAY
72489: IFFALSE 72512
// if not weapon in mc_allowed_tower_weapons [ i ] then
72491: LD_VAR 0 9
72495: PUSH
72496: LD_EXP 102
72500: PUSH
72501: LD_VAR 0 2
72505: ARRAY
72506: IN
72507: NOT
72508: IFFALSE 72512
// continue ;
72510: GO 72214
// end else
72512: GO 72577
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
72514: LD_ADDR_VAR 0 5
72518: PUSH
72519: LD_EXP 71
72523: PUSH
72524: LD_VAR 0 2
72528: ARRAY
72529: PPUSH
72530: LD_VAR 0 4
72534: PPUSH
72535: CALL 54556 0 2
72539: ST_TO_ADDR
// if not tmp2 then
72540: LD_VAR 0 5
72544: NOT
72545: IFFALSE 72549
// continue ;
72547: GO 72214
// tw := tmp2 [ 1 ] ;
72549: LD_ADDR_VAR 0 7
72553: PUSH
72554: LD_VAR 0 5
72558: PUSH
72559: LD_INT 1
72561: ARRAY
72562: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
72563: LD_ADDR_VAR 0 9
72567: PUSH
72568: LD_VAR 0 5
72572: PUSH
72573: LD_INT 2
72575: ARRAY
72576: ST_TO_ADDR
// end ; if not weapon then
72577: LD_VAR 0 9
72581: NOT
72582: IFFALSE 72586
// continue ;
72584: GO 72214
// ComPlaceWeapon ( tw , weapon ) ;
72586: LD_VAR 0 7
72590: PPUSH
72591: LD_VAR 0 9
72595: PPUSH
72596: CALL_OW 148
// end ;
72600: GO 72214
72602: POP
72603: POP
// end ;
72604: LD_VAR 0 1
72608: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
72609: LD_INT 0
72611: PPUSH
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
72616: PPUSH
72617: PPUSH
// if not mc_bases then
72618: LD_EXP 63
72622: NOT
72623: IFFALSE 72627
// exit ;
72625: GO 73402
// for i = 1 to mc_bases do
72627: LD_ADDR_VAR 0 2
72631: PUSH
72632: DOUBLE
72633: LD_INT 1
72635: DEC
72636: ST_TO_ADDR
72637: LD_EXP 63
72641: PUSH
72642: FOR_TO
72643: IFFALSE 73400
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
72645: LD_EXP 76
72649: PUSH
72650: LD_VAR 0 2
72654: ARRAY
72655: NOT
72656: PUSH
72657: LD_EXP 76
72661: PUSH
72662: LD_VAR 0 2
72666: ARRAY
72667: PUSH
72668: LD_EXP 77
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: EQUAL
72679: OR
72680: PUSH
72681: LD_EXP 86
72685: PUSH
72686: LD_VAR 0 2
72690: ARRAY
72691: OR
72692: IFFALSE 72696
// continue ;
72694: GO 72642
// if mc_miners [ i ] then
72696: LD_EXP 77
72700: PUSH
72701: LD_VAR 0 2
72705: ARRAY
72706: IFFALSE 73087
// begin for j = mc_miners [ i ] downto 1 do
72708: LD_ADDR_VAR 0 3
72712: PUSH
72713: DOUBLE
72714: LD_EXP 77
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: INC
72725: ST_TO_ADDR
72726: LD_INT 1
72728: PUSH
72729: FOR_DOWNTO
72730: IFFALSE 73085
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
72732: LD_EXP 77
72736: PUSH
72737: LD_VAR 0 2
72741: ARRAY
72742: PUSH
72743: LD_VAR 0 3
72747: ARRAY
72748: PPUSH
72749: CALL_OW 301
72753: PUSH
72754: LD_EXP 77
72758: PUSH
72759: LD_VAR 0 2
72763: ARRAY
72764: PUSH
72765: LD_VAR 0 3
72769: ARRAY
72770: PPUSH
72771: CALL_OW 257
72775: PUSH
72776: LD_INT 1
72778: NONEQUAL
72779: OR
72780: IFFALSE 72843
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
72782: LD_ADDR_VAR 0 5
72786: PUSH
72787: LD_EXP 77
72791: PUSH
72792: LD_VAR 0 2
72796: ARRAY
72797: PUSH
72798: LD_EXP 77
72802: PUSH
72803: LD_VAR 0 2
72807: ARRAY
72808: PUSH
72809: LD_VAR 0 3
72813: ARRAY
72814: DIFF
72815: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
72816: LD_ADDR_EXP 77
72820: PUSH
72821: LD_EXP 77
72825: PPUSH
72826: LD_VAR 0 2
72830: PPUSH
72831: LD_VAR 0 5
72835: PPUSH
72836: CALL_OW 1
72840: ST_TO_ADDR
// continue ;
72841: GO 72729
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
72843: LD_EXP 77
72847: PUSH
72848: LD_VAR 0 2
72852: ARRAY
72853: PUSH
72854: LD_VAR 0 3
72858: ARRAY
72859: PPUSH
72860: CALL_OW 257
72864: PUSH
72865: LD_INT 1
72867: EQUAL
72868: PUSH
72869: LD_EXP 77
72873: PUSH
72874: LD_VAR 0 2
72878: ARRAY
72879: PUSH
72880: LD_VAR 0 3
72884: ARRAY
72885: PPUSH
72886: CALL_OW 459
72890: NOT
72891: AND
72892: PUSH
72893: LD_EXP 77
72897: PUSH
72898: LD_VAR 0 2
72902: ARRAY
72903: PUSH
72904: LD_VAR 0 3
72908: ARRAY
72909: PPUSH
72910: CALL_OW 314
72914: NOT
72915: AND
72916: IFFALSE 73083
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72918: LD_EXP 77
72922: PUSH
72923: LD_VAR 0 2
72927: ARRAY
72928: PUSH
72929: LD_VAR 0 3
72933: ARRAY
72934: PPUSH
72935: CALL_OW 310
72939: IFFALSE 72962
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
72941: LD_EXP 77
72945: PUSH
72946: LD_VAR 0 2
72950: ARRAY
72951: PUSH
72952: LD_VAR 0 3
72956: ARRAY
72957: PPUSH
72958: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
72962: LD_EXP 77
72966: PUSH
72967: LD_VAR 0 2
72971: ARRAY
72972: PUSH
72973: LD_VAR 0 3
72977: ARRAY
72978: PPUSH
72979: CALL_OW 314
72983: NOT
72984: IFFALSE 73083
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
72986: LD_ADDR_VAR 0 7
72990: PUSH
72991: LD_VAR 0 3
72995: PUSH
72996: LD_EXP 76
73000: PUSH
73001: LD_VAR 0 2
73005: ARRAY
73006: PPUSH
73007: CALL 19399 0 1
73011: MOD
73012: PUSH
73013: LD_INT 1
73015: PLUS
73016: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73017: LD_EXP 77
73021: PUSH
73022: LD_VAR 0 2
73026: ARRAY
73027: PUSH
73028: LD_VAR 0 3
73032: ARRAY
73033: PPUSH
73034: LD_EXP 76
73038: PUSH
73039: LD_VAR 0 2
73043: ARRAY
73044: PUSH
73045: LD_VAR 0 7
73049: ARRAY
73050: PUSH
73051: LD_INT 1
73053: ARRAY
73054: PPUSH
73055: LD_EXP 76
73059: PUSH
73060: LD_VAR 0 2
73064: ARRAY
73065: PUSH
73066: LD_VAR 0 7
73070: ARRAY
73071: PUSH
73072: LD_INT 2
73074: ARRAY
73075: PPUSH
73076: LD_INT 0
73078: PPUSH
73079: CALL_OW 193
// end ; end ; end ;
73083: GO 72729
73085: POP
73086: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73087: LD_ADDR_VAR 0 5
73091: PUSH
73092: LD_EXP 63
73096: PUSH
73097: LD_VAR 0 2
73101: ARRAY
73102: PPUSH
73103: LD_INT 2
73105: PUSH
73106: LD_INT 30
73108: PUSH
73109: LD_INT 4
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 30
73118: PUSH
73119: LD_INT 5
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 30
73128: PUSH
73129: LD_INT 32
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: PPUSH
73142: CALL_OW 72
73146: ST_TO_ADDR
// if not tmp then
73147: LD_VAR 0 5
73151: NOT
73152: IFFALSE 73156
// continue ;
73154: GO 72642
// list := [ ] ;
73156: LD_ADDR_VAR 0 6
73160: PUSH
73161: EMPTY
73162: ST_TO_ADDR
// for j in tmp do
73163: LD_ADDR_VAR 0 3
73167: PUSH
73168: LD_VAR 0 5
73172: PUSH
73173: FOR_IN
73174: IFFALSE 73243
// begin for k in UnitsInside ( j ) do
73176: LD_ADDR_VAR 0 4
73180: PUSH
73181: LD_VAR 0 3
73185: PPUSH
73186: CALL_OW 313
73190: PUSH
73191: FOR_IN
73192: IFFALSE 73239
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
73194: LD_VAR 0 4
73198: PPUSH
73199: CALL_OW 257
73203: PUSH
73204: LD_INT 1
73206: EQUAL
73207: PUSH
73208: LD_VAR 0 4
73212: PPUSH
73213: CALL_OW 459
73217: NOT
73218: AND
73219: IFFALSE 73237
// list := list ^ k ;
73221: LD_ADDR_VAR 0 6
73225: PUSH
73226: LD_VAR 0 6
73230: PUSH
73231: LD_VAR 0 4
73235: ADD
73236: ST_TO_ADDR
73237: GO 73191
73239: POP
73240: POP
// end ;
73241: GO 73173
73243: POP
73244: POP
// list := list diff mc_miners [ i ] ;
73245: LD_ADDR_VAR 0 6
73249: PUSH
73250: LD_VAR 0 6
73254: PUSH
73255: LD_EXP 77
73259: PUSH
73260: LD_VAR 0 2
73264: ARRAY
73265: DIFF
73266: ST_TO_ADDR
// if not list then
73267: LD_VAR 0 6
73271: NOT
73272: IFFALSE 73276
// continue ;
73274: GO 72642
// k := mc_mines [ i ] - mc_miners [ i ] ;
73276: LD_ADDR_VAR 0 4
73280: PUSH
73281: LD_EXP 76
73285: PUSH
73286: LD_VAR 0 2
73290: ARRAY
73291: PUSH
73292: LD_EXP 77
73296: PUSH
73297: LD_VAR 0 2
73301: ARRAY
73302: MINUS
73303: ST_TO_ADDR
// if k > list then
73304: LD_VAR 0 4
73308: PUSH
73309: LD_VAR 0 6
73313: GREATER
73314: IFFALSE 73326
// k := list ;
73316: LD_ADDR_VAR 0 4
73320: PUSH
73321: LD_VAR 0 6
73325: ST_TO_ADDR
// for j = 1 to k do
73326: LD_ADDR_VAR 0 3
73330: PUSH
73331: DOUBLE
73332: LD_INT 1
73334: DEC
73335: ST_TO_ADDR
73336: LD_VAR 0 4
73340: PUSH
73341: FOR_TO
73342: IFFALSE 73396
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
73344: LD_ADDR_EXP 77
73348: PUSH
73349: LD_EXP 77
73353: PPUSH
73354: LD_VAR 0 2
73358: PUSH
73359: LD_EXP 77
73363: PUSH
73364: LD_VAR 0 2
73368: ARRAY
73369: PUSH
73370: LD_INT 1
73372: PLUS
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PPUSH
73378: LD_VAR 0 6
73382: PUSH
73383: LD_VAR 0 3
73387: ARRAY
73388: PPUSH
73389: CALL 22259 0 3
73393: ST_TO_ADDR
73394: GO 73341
73396: POP
73397: POP
// end ;
73398: GO 72642
73400: POP
73401: POP
// end ;
73402: LD_VAR 0 1
73406: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
73407: LD_INT 0
73409: PPUSH
73410: PPUSH
73411: PPUSH
73412: PPUSH
73413: PPUSH
73414: PPUSH
73415: PPUSH
73416: PPUSH
73417: PPUSH
73418: PPUSH
73419: PPUSH
// if not mc_bases then
73420: LD_EXP 63
73424: NOT
73425: IFFALSE 73429
// exit ;
73427: GO 75252
// for i = 1 to mc_bases do
73429: LD_ADDR_VAR 0 2
73433: PUSH
73434: DOUBLE
73435: LD_INT 1
73437: DEC
73438: ST_TO_ADDR
73439: LD_EXP 63
73443: PUSH
73444: FOR_TO
73445: IFFALSE 75250
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
73447: LD_EXP 63
73451: PUSH
73452: LD_VAR 0 2
73456: ARRAY
73457: NOT
73458: PUSH
73459: LD_EXP 70
73463: PUSH
73464: LD_VAR 0 2
73468: ARRAY
73469: OR
73470: IFFALSE 73474
// continue ;
73472: GO 73444
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
73474: LD_EXP 79
73478: PUSH
73479: LD_VAR 0 2
73483: ARRAY
73484: NOT
73485: PUSH
73486: LD_EXP 80
73490: PUSH
73491: LD_VAR 0 2
73495: ARRAY
73496: AND
73497: IFFALSE 73535
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
73499: LD_ADDR_EXP 80
73503: PUSH
73504: LD_EXP 80
73508: PPUSH
73509: LD_VAR 0 2
73513: PPUSH
73514: EMPTY
73515: PPUSH
73516: CALL_OW 1
73520: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
73521: LD_VAR 0 2
73525: PPUSH
73526: LD_INT 107
73528: PPUSH
73529: CALL 64261 0 2
// continue ;
73533: GO 73444
// end ; target := [ ] ;
73535: LD_ADDR_VAR 0 7
73539: PUSH
73540: EMPTY
73541: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73542: LD_ADDR_VAR 0 6
73546: PUSH
73547: LD_EXP 63
73551: PUSH
73552: LD_VAR 0 2
73556: ARRAY
73557: PUSH
73558: LD_INT 1
73560: ARRAY
73561: PPUSH
73562: CALL_OW 255
73566: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73567: LD_ADDR_VAR 0 9
73571: PUSH
73572: LD_EXP 63
73576: PUSH
73577: LD_VAR 0 2
73581: ARRAY
73582: PPUSH
73583: LD_INT 2
73585: PUSH
73586: LD_INT 30
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 30
73598: PUSH
73599: LD_INT 1
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: LIST
73610: PPUSH
73611: CALL_OW 72
73615: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
73616: LD_ADDR_VAR 0 3
73620: PUSH
73621: DOUBLE
73622: LD_EXP 79
73626: PUSH
73627: LD_VAR 0 2
73631: ARRAY
73632: INC
73633: ST_TO_ADDR
73634: LD_INT 1
73636: PUSH
73637: FOR_DOWNTO
73638: IFFALSE 73883
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
73640: LD_EXP 79
73644: PUSH
73645: LD_VAR 0 2
73649: ARRAY
73650: PUSH
73651: LD_VAR 0 3
73655: ARRAY
73656: PUSH
73657: LD_INT 2
73659: ARRAY
73660: PPUSH
73661: LD_EXP 79
73665: PUSH
73666: LD_VAR 0 2
73670: ARRAY
73671: PUSH
73672: LD_VAR 0 3
73676: ARRAY
73677: PUSH
73678: LD_INT 3
73680: ARRAY
73681: PPUSH
73682: CALL_OW 488
73686: PUSH
73687: LD_EXP 79
73691: PUSH
73692: LD_VAR 0 2
73696: ARRAY
73697: PUSH
73698: LD_VAR 0 3
73702: ARRAY
73703: PUSH
73704: LD_INT 2
73706: ARRAY
73707: PPUSH
73708: LD_EXP 79
73712: PUSH
73713: LD_VAR 0 2
73717: ARRAY
73718: PUSH
73719: LD_VAR 0 3
73723: ARRAY
73724: PUSH
73725: LD_INT 3
73727: ARRAY
73728: PPUSH
73729: CALL_OW 284
73733: PUSH
73734: LD_INT 0
73736: EQUAL
73737: AND
73738: IFFALSE 73793
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
73740: LD_ADDR_VAR 0 5
73744: PUSH
73745: LD_EXP 79
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: PPUSH
73756: LD_VAR 0 3
73760: PPUSH
73761: CALL_OW 3
73765: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
73766: LD_ADDR_EXP 79
73770: PUSH
73771: LD_EXP 79
73775: PPUSH
73776: LD_VAR 0 2
73780: PPUSH
73781: LD_VAR 0 5
73785: PPUSH
73786: CALL_OW 1
73790: ST_TO_ADDR
// continue ;
73791: GO 73637
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
73793: LD_VAR 0 6
73797: PPUSH
73798: LD_EXP 79
73802: PUSH
73803: LD_VAR 0 2
73807: ARRAY
73808: PUSH
73809: LD_VAR 0 3
73813: ARRAY
73814: PUSH
73815: LD_INT 2
73817: ARRAY
73818: PPUSH
73819: LD_EXP 79
73823: PUSH
73824: LD_VAR 0 2
73828: ARRAY
73829: PUSH
73830: LD_VAR 0 3
73834: ARRAY
73835: PUSH
73836: LD_INT 3
73838: ARRAY
73839: PPUSH
73840: LD_INT 30
73842: PPUSH
73843: CALL 23523 0 4
73847: PUSH
73848: LD_INT 4
73850: ARRAY
73851: PUSH
73852: LD_INT 0
73854: EQUAL
73855: IFFALSE 73881
// begin target := mc_crates [ i ] [ j ] ;
73857: LD_ADDR_VAR 0 7
73861: PUSH
73862: LD_EXP 79
73866: PUSH
73867: LD_VAR 0 2
73871: ARRAY
73872: PUSH
73873: LD_VAR 0 3
73877: ARRAY
73878: ST_TO_ADDR
// break ;
73879: GO 73883
// end ; end ;
73881: GO 73637
73883: POP
73884: POP
// if not target then
73885: LD_VAR 0 7
73889: NOT
73890: IFFALSE 73894
// continue ;
73892: GO 73444
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73894: LD_ADDR_VAR 0 8
73898: PUSH
73899: LD_EXP 82
73903: PUSH
73904: LD_VAR 0 2
73908: ARRAY
73909: PPUSH
73910: LD_INT 2
73912: PUSH
73913: LD_INT 3
73915: PUSH
73916: LD_INT 58
73918: PUSH
73919: EMPTY
73920: LIST
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: PUSH
73926: LD_INT 61
73928: PUSH
73929: EMPTY
73930: LIST
73931: PUSH
73932: LD_INT 33
73934: PUSH
73935: LD_INT 5
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 33
73944: PUSH
73945: LD_INT 3
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 2
73961: PUSH
73962: LD_INT 34
73964: PUSH
73965: LD_INT 32
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 34
73974: PUSH
73975: LD_INT 51
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 34
73984: PUSH
73985: LD_INT 12
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PPUSH
74002: CALL_OW 72
74006: ST_TO_ADDR
// if not cargo then
74007: LD_VAR 0 8
74011: NOT
74012: IFFALSE 74718
// begin if mc_crates_collector [ i ] < 5 then
74014: LD_EXP 80
74018: PUSH
74019: LD_VAR 0 2
74023: ARRAY
74024: PUSH
74025: LD_INT 5
74027: LESS
74028: IFFALSE 74394
// begin if mc_ape [ i ] then
74030: LD_EXP 92
74034: PUSH
74035: LD_VAR 0 2
74039: ARRAY
74040: IFFALSE 74087
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74042: LD_ADDR_VAR 0 5
74046: PUSH
74047: LD_EXP 92
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: PPUSH
74058: LD_INT 25
74060: PUSH
74061: LD_INT 16
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 24
74070: PUSH
74071: LD_INT 750
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PPUSH
74082: CALL_OW 72
74086: ST_TO_ADDR
// if not tmp then
74087: LD_VAR 0 5
74091: NOT
74092: IFFALSE 74139
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
74094: LD_ADDR_VAR 0 5
74098: PUSH
74099: LD_EXP 63
74103: PUSH
74104: LD_VAR 0 2
74108: ARRAY
74109: PPUSH
74110: LD_INT 25
74112: PUSH
74113: LD_INT 2
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 24
74122: PUSH
74123: LD_INT 750
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PPUSH
74134: CALL_OW 72
74138: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
74139: LD_EXP 92
74143: PUSH
74144: LD_VAR 0 2
74148: ARRAY
74149: PUSH
74150: LD_EXP 63
74154: PUSH
74155: LD_VAR 0 2
74159: ARRAY
74160: PPUSH
74161: LD_INT 25
74163: PUSH
74164: LD_INT 2
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 24
74173: PUSH
74174: LD_INT 750
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PPUSH
74185: CALL_OW 72
74189: AND
74190: PUSH
74191: LD_VAR 0 5
74195: PUSH
74196: LD_INT 5
74198: LESS
74199: AND
74200: IFFALSE 74282
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
74202: LD_ADDR_VAR 0 3
74206: PUSH
74207: LD_EXP 63
74211: PUSH
74212: LD_VAR 0 2
74216: ARRAY
74217: PPUSH
74218: LD_INT 25
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 24
74230: PUSH
74231: LD_INT 750
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PPUSH
74242: CALL_OW 72
74246: PUSH
74247: FOR_IN
74248: IFFALSE 74280
// begin tmp := tmp union j ;
74250: LD_ADDR_VAR 0 5
74254: PUSH
74255: LD_VAR 0 5
74259: PUSH
74260: LD_VAR 0 3
74264: UNION
74265: ST_TO_ADDR
// if tmp >= 5 then
74266: LD_VAR 0 5
74270: PUSH
74271: LD_INT 5
74273: GREATEREQUAL
74274: IFFALSE 74278
// break ;
74276: GO 74280
// end ;
74278: GO 74247
74280: POP
74281: POP
// end ; if not tmp then
74282: LD_VAR 0 5
74286: NOT
74287: IFFALSE 74291
// continue ;
74289: GO 73444
// for j in tmp do
74291: LD_ADDR_VAR 0 3
74295: PUSH
74296: LD_VAR 0 5
74300: PUSH
74301: FOR_IN
74302: IFFALSE 74392
// if not GetTag ( j ) then
74304: LD_VAR 0 3
74308: PPUSH
74309: CALL_OW 110
74313: NOT
74314: IFFALSE 74390
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
74316: LD_ADDR_EXP 80
74320: PUSH
74321: LD_EXP 80
74325: PPUSH
74326: LD_VAR 0 2
74330: PUSH
74331: LD_EXP 80
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: PUSH
74342: LD_INT 1
74344: PLUS
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PPUSH
74350: LD_VAR 0 3
74354: PPUSH
74355: CALL 22259 0 3
74359: ST_TO_ADDR
// SetTag ( j , 107 ) ;
74360: LD_VAR 0 3
74364: PPUSH
74365: LD_INT 107
74367: PPUSH
74368: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
74372: LD_EXP 80
74376: PUSH
74377: LD_VAR 0 2
74381: ARRAY
74382: PUSH
74383: LD_INT 5
74385: GREATEREQUAL
74386: IFFALSE 74390
// break ;
74388: GO 74392
// end ;
74390: GO 74301
74392: POP
74393: POP
// end ; if mc_crates_collector [ i ] and target then
74394: LD_EXP 80
74398: PUSH
74399: LD_VAR 0 2
74403: ARRAY
74404: PUSH
74405: LD_VAR 0 7
74409: AND
74410: IFFALSE 74716
// begin if mc_crates_collector [ i ] < target [ 1 ] then
74412: LD_EXP 80
74416: PUSH
74417: LD_VAR 0 2
74421: ARRAY
74422: PUSH
74423: LD_VAR 0 7
74427: PUSH
74428: LD_INT 1
74430: ARRAY
74431: LESS
74432: IFFALSE 74452
// tmp := mc_crates_collector [ i ] else
74434: LD_ADDR_VAR 0 5
74438: PUSH
74439: LD_EXP 80
74443: PUSH
74444: LD_VAR 0 2
74448: ARRAY
74449: ST_TO_ADDR
74450: GO 74466
// tmp := target [ 1 ] ;
74452: LD_ADDR_VAR 0 5
74456: PUSH
74457: LD_VAR 0 7
74461: PUSH
74462: LD_INT 1
74464: ARRAY
74465: ST_TO_ADDR
// k := 0 ;
74466: LD_ADDR_VAR 0 4
74470: PUSH
74471: LD_INT 0
74473: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
74474: LD_ADDR_VAR 0 3
74478: PUSH
74479: LD_EXP 80
74483: PUSH
74484: LD_VAR 0 2
74488: ARRAY
74489: PUSH
74490: FOR_IN
74491: IFFALSE 74714
// begin k := k + 1 ;
74493: LD_ADDR_VAR 0 4
74497: PUSH
74498: LD_VAR 0 4
74502: PUSH
74503: LD_INT 1
74505: PLUS
74506: ST_TO_ADDR
// if k > tmp then
74507: LD_VAR 0 4
74511: PUSH
74512: LD_VAR 0 5
74516: GREATER
74517: IFFALSE 74521
// break ;
74519: GO 74714
// if not GetClass ( j ) in [ 2 , 16 ] then
74521: LD_VAR 0 3
74525: PPUSH
74526: CALL_OW 257
74530: PUSH
74531: LD_INT 2
74533: PUSH
74534: LD_INT 16
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: IN
74541: NOT
74542: IFFALSE 74595
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
74544: LD_ADDR_EXP 80
74548: PUSH
74549: LD_EXP 80
74553: PPUSH
74554: LD_VAR 0 2
74558: PPUSH
74559: LD_EXP 80
74563: PUSH
74564: LD_VAR 0 2
74568: ARRAY
74569: PUSH
74570: LD_VAR 0 3
74574: DIFF
74575: PPUSH
74576: CALL_OW 1
74580: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74581: LD_VAR 0 3
74585: PPUSH
74586: LD_INT 0
74588: PPUSH
74589: CALL_OW 109
// continue ;
74593: GO 74490
// end ; if IsInUnit ( j ) then
74595: LD_VAR 0 3
74599: PPUSH
74600: CALL_OW 310
74604: IFFALSE 74615
// ComExitBuilding ( j ) ;
74606: LD_VAR 0 3
74610: PPUSH
74611: CALL_OW 122
// wait ( 3 ) ;
74615: LD_INT 3
74617: PPUSH
74618: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
74622: LD_VAR 0 3
74626: PPUSH
74627: CALL_OW 314
74631: PUSH
74632: LD_VAR 0 6
74636: PPUSH
74637: LD_VAR 0 7
74641: PUSH
74642: LD_INT 2
74644: ARRAY
74645: PPUSH
74646: LD_VAR 0 7
74650: PUSH
74651: LD_INT 3
74653: ARRAY
74654: PPUSH
74655: LD_INT 30
74657: PPUSH
74658: CALL 23523 0 4
74662: PUSH
74663: LD_INT 4
74665: ARRAY
74666: AND
74667: IFFALSE 74685
// ComStandNearbyBuilding ( j , depot ) else
74669: LD_VAR 0 3
74673: PPUSH
74674: LD_VAR 0 9
74678: PPUSH
74679: CALL 18861 0 2
74683: GO 74712
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74685: LD_VAR 0 3
74689: PPUSH
74690: LD_VAR 0 7
74694: PUSH
74695: LD_INT 2
74697: ARRAY
74698: PPUSH
74699: LD_VAR 0 7
74703: PUSH
74704: LD_INT 3
74706: ARRAY
74707: PPUSH
74708: CALL_OW 117
// end ;
74712: GO 74490
74714: POP
74715: POP
// end ; end else
74716: GO 75248
// begin for j in cargo do
74718: LD_ADDR_VAR 0 3
74722: PUSH
74723: LD_VAR 0 8
74727: PUSH
74728: FOR_IN
74729: IFFALSE 75246
// begin if GetTag ( j ) <> 0 then
74731: LD_VAR 0 3
74735: PPUSH
74736: CALL_OW 110
74740: PUSH
74741: LD_INT 0
74743: NONEQUAL
74744: IFFALSE 74748
// continue ;
74746: GO 74728
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
74748: LD_VAR 0 3
74752: PPUSH
74753: CALL_OW 256
74757: PUSH
74758: LD_INT 1000
74760: LESS
74761: PUSH
74762: LD_VAR 0 3
74766: PPUSH
74767: LD_EXP 87
74771: PUSH
74772: LD_VAR 0 2
74776: ARRAY
74777: PPUSH
74778: CALL_OW 308
74782: NOT
74783: AND
74784: IFFALSE 74806
// ComMoveToArea ( j , mc_parking [ i ] ) ;
74786: LD_VAR 0 3
74790: PPUSH
74791: LD_EXP 87
74795: PUSH
74796: LD_VAR 0 2
74800: ARRAY
74801: PPUSH
74802: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
74806: LD_VAR 0 3
74810: PPUSH
74811: CALL_OW 256
74815: PUSH
74816: LD_INT 1000
74818: LESS
74819: PUSH
74820: LD_VAR 0 3
74824: PPUSH
74825: LD_EXP 87
74829: PUSH
74830: LD_VAR 0 2
74834: ARRAY
74835: PPUSH
74836: CALL_OW 308
74840: AND
74841: IFFALSE 74845
// continue ;
74843: GO 74728
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
74845: LD_VAR 0 3
74849: PPUSH
74850: CALL_OW 262
74854: PUSH
74855: LD_INT 2
74857: EQUAL
74858: PUSH
74859: LD_VAR 0 3
74863: PPUSH
74864: CALL_OW 261
74868: PUSH
74869: LD_INT 15
74871: LESS
74872: AND
74873: IFFALSE 74877
// continue ;
74875: GO 74728
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74877: LD_VAR 0 3
74881: PPUSH
74882: CALL_OW 262
74886: PUSH
74887: LD_INT 1
74889: EQUAL
74890: PUSH
74891: LD_VAR 0 3
74895: PPUSH
74896: CALL_OW 261
74900: PUSH
74901: LD_INT 10
74903: LESS
74904: AND
74905: IFFALSE 75185
// begin if not depot then
74907: LD_VAR 0 9
74911: NOT
74912: IFFALSE 74916
// continue ;
74914: GO 74728
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74916: LD_VAR 0 3
74920: PPUSH
74921: LD_VAR 0 9
74925: PPUSH
74926: LD_VAR 0 3
74930: PPUSH
74931: CALL_OW 74
74935: PPUSH
74936: CALL_OW 296
74940: PUSH
74941: LD_INT 6
74943: LESS
74944: IFFALSE 74960
// SetFuel ( j , 100 ) else
74946: LD_VAR 0 3
74950: PPUSH
74951: LD_INT 100
74953: PPUSH
74954: CALL_OW 240
74958: GO 75185
// if GetFuel ( j ) = 0 then
74960: LD_VAR 0 3
74964: PPUSH
74965: CALL_OW 261
74969: PUSH
74970: LD_INT 0
74972: EQUAL
74973: IFFALSE 75185
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
74975: LD_ADDR_EXP 82
74979: PUSH
74980: LD_EXP 82
74984: PPUSH
74985: LD_VAR 0 2
74989: PPUSH
74990: LD_EXP 82
74994: PUSH
74995: LD_VAR 0 2
74999: ARRAY
75000: PUSH
75001: LD_VAR 0 3
75005: DIFF
75006: PPUSH
75007: CALL_OW 1
75011: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75012: LD_VAR 0 3
75016: PPUSH
75017: CALL_OW 263
75021: PUSH
75022: LD_INT 1
75024: EQUAL
75025: IFFALSE 75041
// ComExitVehicle ( IsInUnit ( j ) ) ;
75027: LD_VAR 0 3
75031: PPUSH
75032: CALL_OW 310
75036: PPUSH
75037: CALL_OW 121
// if GetControl ( j ) = control_remote then
75041: LD_VAR 0 3
75045: PPUSH
75046: CALL_OW 263
75050: PUSH
75051: LD_INT 2
75053: EQUAL
75054: IFFALSE 75065
// ComUnlink ( j ) ;
75056: LD_VAR 0 3
75060: PPUSH
75061: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75065: LD_ADDR_VAR 0 10
75069: PUSH
75070: LD_VAR 0 2
75074: PPUSH
75075: LD_INT 3
75077: PPUSH
75078: CALL 84829 0 2
75082: ST_TO_ADDR
// if fac then
75083: LD_VAR 0 10
75087: IFFALSE 75183
// begin for k in fac do
75089: LD_ADDR_VAR 0 4
75093: PUSH
75094: LD_VAR 0 10
75098: PUSH
75099: FOR_IN
75100: IFFALSE 75181
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
75102: LD_ADDR_VAR 0 11
75106: PUSH
75107: LD_VAR 0 10
75111: PPUSH
75112: LD_VAR 0 3
75116: PPUSH
75117: CALL_OW 265
75121: PPUSH
75122: LD_VAR 0 3
75126: PPUSH
75127: CALL_OW 262
75131: PPUSH
75132: LD_VAR 0 3
75136: PPUSH
75137: CALL_OW 263
75141: PPUSH
75142: LD_VAR 0 3
75146: PPUSH
75147: CALL_OW 264
75151: PPUSH
75152: CALL 19757 0 5
75156: ST_TO_ADDR
// if components then
75157: LD_VAR 0 11
75161: IFFALSE 75179
// begin MC_InsertProduceList ( i , components ) ;
75163: LD_VAR 0 2
75167: PPUSH
75168: LD_VAR 0 11
75172: PPUSH
75173: CALL 84374 0 2
// break ;
75177: GO 75181
// end ; end ;
75179: GO 75099
75181: POP
75182: POP
// end ; continue ;
75183: GO 74728
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
75185: LD_VAR 0 3
75189: PPUSH
75190: LD_INT 1
75192: PPUSH
75193: CALL_OW 289
75197: PUSH
75198: LD_INT 100
75200: LESS
75201: PUSH
75202: LD_VAR 0 3
75206: PPUSH
75207: CALL_OW 314
75211: NOT
75212: AND
75213: IFFALSE 75242
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75215: LD_VAR 0 3
75219: PPUSH
75220: LD_VAR 0 7
75224: PUSH
75225: LD_INT 2
75227: ARRAY
75228: PPUSH
75229: LD_VAR 0 7
75233: PUSH
75234: LD_INT 3
75236: ARRAY
75237: PPUSH
75238: CALL_OW 117
// break ;
75242: GO 75246
// end ;
75244: GO 74728
75246: POP
75247: POP
// end ; end ;
75248: GO 73444
75250: POP
75251: POP
// end ;
75252: LD_VAR 0 1
75256: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
75257: LD_INT 0
75259: PPUSH
75260: PPUSH
75261: PPUSH
75262: PPUSH
// if not mc_bases then
75263: LD_EXP 63
75267: NOT
75268: IFFALSE 75272
// exit ;
75270: GO 75433
// for i = 1 to mc_bases do
75272: LD_ADDR_VAR 0 2
75276: PUSH
75277: DOUBLE
75278: LD_INT 1
75280: DEC
75281: ST_TO_ADDR
75282: LD_EXP 63
75286: PUSH
75287: FOR_TO
75288: IFFALSE 75431
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
75290: LD_ADDR_VAR 0 4
75294: PUSH
75295: LD_EXP 82
75299: PUSH
75300: LD_VAR 0 2
75304: ARRAY
75305: PUSH
75306: LD_EXP 85
75310: PUSH
75311: LD_VAR 0 2
75315: ARRAY
75316: UNION
75317: PPUSH
75318: LD_INT 33
75320: PUSH
75321: LD_INT 2
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PPUSH
75328: CALL_OW 72
75332: ST_TO_ADDR
// if tmp then
75333: LD_VAR 0 4
75337: IFFALSE 75429
// for j in tmp do
75339: LD_ADDR_VAR 0 3
75343: PUSH
75344: LD_VAR 0 4
75348: PUSH
75349: FOR_IN
75350: IFFALSE 75427
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
75352: LD_VAR 0 3
75356: PPUSH
75357: CALL_OW 312
75361: NOT
75362: PUSH
75363: LD_VAR 0 3
75367: PPUSH
75368: CALL_OW 256
75372: PUSH
75373: LD_INT 250
75375: GREATEREQUAL
75376: AND
75377: IFFALSE 75390
// Connect ( j ) else
75379: LD_VAR 0 3
75383: PPUSH
75384: CALL 25605 0 1
75388: GO 75425
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
75390: LD_VAR 0 3
75394: PPUSH
75395: CALL_OW 256
75399: PUSH
75400: LD_INT 250
75402: LESS
75403: PUSH
75404: LD_VAR 0 3
75408: PPUSH
75409: CALL_OW 312
75413: AND
75414: IFFALSE 75425
// ComUnlink ( j ) ;
75416: LD_VAR 0 3
75420: PPUSH
75421: CALL_OW 136
75425: GO 75349
75427: POP
75428: POP
// end ;
75429: GO 75287
75431: POP
75432: POP
// end ;
75433: LD_VAR 0 1
75437: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
75438: LD_INT 0
75440: PPUSH
75441: PPUSH
75442: PPUSH
75443: PPUSH
75444: PPUSH
// if not mc_bases then
75445: LD_EXP 63
75449: NOT
75450: IFFALSE 75454
// exit ;
75452: GO 75899
// for i = 1 to mc_bases do
75454: LD_ADDR_VAR 0 2
75458: PUSH
75459: DOUBLE
75460: LD_INT 1
75462: DEC
75463: ST_TO_ADDR
75464: LD_EXP 63
75468: PUSH
75469: FOR_TO
75470: IFFALSE 75897
// begin if not mc_produce [ i ] then
75472: LD_EXP 84
75476: PUSH
75477: LD_VAR 0 2
75481: ARRAY
75482: NOT
75483: IFFALSE 75487
// continue ;
75485: GO 75469
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75487: LD_ADDR_VAR 0 5
75491: PUSH
75492: LD_EXP 63
75496: PUSH
75497: LD_VAR 0 2
75501: ARRAY
75502: PPUSH
75503: LD_INT 30
75505: PUSH
75506: LD_INT 3
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PPUSH
75513: CALL_OW 72
75517: ST_TO_ADDR
// if not fac then
75518: LD_VAR 0 5
75522: NOT
75523: IFFALSE 75527
// continue ;
75525: GO 75469
// for j in fac do
75527: LD_ADDR_VAR 0 3
75531: PUSH
75532: LD_VAR 0 5
75536: PUSH
75537: FOR_IN
75538: IFFALSE 75893
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
75540: LD_VAR 0 3
75544: PPUSH
75545: CALL_OW 461
75549: PUSH
75550: LD_INT 2
75552: NONEQUAL
75553: PUSH
75554: LD_VAR 0 3
75558: PPUSH
75559: LD_INT 15
75561: PPUSH
75562: CALL 25224 0 2
75566: PUSH
75567: LD_INT 4
75569: ARRAY
75570: OR
75571: IFFALSE 75575
// continue ;
75573: GO 75537
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
75575: LD_VAR 0 3
75579: PPUSH
75580: LD_EXP 84
75584: PUSH
75585: LD_VAR 0 2
75589: ARRAY
75590: PUSH
75591: LD_INT 1
75593: ARRAY
75594: PUSH
75595: LD_INT 1
75597: ARRAY
75598: PPUSH
75599: LD_EXP 84
75603: PUSH
75604: LD_VAR 0 2
75608: ARRAY
75609: PUSH
75610: LD_INT 1
75612: ARRAY
75613: PUSH
75614: LD_INT 2
75616: ARRAY
75617: PPUSH
75618: LD_EXP 84
75622: PUSH
75623: LD_VAR 0 2
75627: ARRAY
75628: PUSH
75629: LD_INT 1
75631: ARRAY
75632: PUSH
75633: LD_INT 3
75635: ARRAY
75636: PPUSH
75637: LD_EXP 84
75641: PUSH
75642: LD_VAR 0 2
75646: ARRAY
75647: PUSH
75648: LD_INT 1
75650: ARRAY
75651: PUSH
75652: LD_INT 4
75654: ARRAY
75655: PPUSH
75656: CALL_OW 448
75660: PUSH
75661: LD_VAR 0 3
75665: PPUSH
75666: LD_EXP 84
75670: PUSH
75671: LD_VAR 0 2
75675: ARRAY
75676: PUSH
75677: LD_INT 1
75679: ARRAY
75680: PUSH
75681: LD_INT 1
75683: ARRAY
75684: PUSH
75685: LD_EXP 84
75689: PUSH
75690: LD_VAR 0 2
75694: ARRAY
75695: PUSH
75696: LD_INT 1
75698: ARRAY
75699: PUSH
75700: LD_INT 2
75702: ARRAY
75703: PUSH
75704: LD_EXP 84
75708: PUSH
75709: LD_VAR 0 2
75713: ARRAY
75714: PUSH
75715: LD_INT 1
75717: ARRAY
75718: PUSH
75719: LD_INT 3
75721: ARRAY
75722: PUSH
75723: LD_EXP 84
75727: PUSH
75728: LD_VAR 0 2
75732: ARRAY
75733: PUSH
75734: LD_INT 1
75736: ARRAY
75737: PUSH
75738: LD_INT 4
75740: ARRAY
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: PPUSH
75748: CALL 29000 0 2
75752: AND
75753: IFFALSE 75891
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
75755: LD_VAR 0 3
75759: PPUSH
75760: LD_EXP 84
75764: PUSH
75765: LD_VAR 0 2
75769: ARRAY
75770: PUSH
75771: LD_INT 1
75773: ARRAY
75774: PUSH
75775: LD_INT 1
75777: ARRAY
75778: PPUSH
75779: LD_EXP 84
75783: PUSH
75784: LD_VAR 0 2
75788: ARRAY
75789: PUSH
75790: LD_INT 1
75792: ARRAY
75793: PUSH
75794: LD_INT 2
75796: ARRAY
75797: PPUSH
75798: LD_EXP 84
75802: PUSH
75803: LD_VAR 0 2
75807: ARRAY
75808: PUSH
75809: LD_INT 1
75811: ARRAY
75812: PUSH
75813: LD_INT 3
75815: ARRAY
75816: PPUSH
75817: LD_EXP 84
75821: PUSH
75822: LD_VAR 0 2
75826: ARRAY
75827: PUSH
75828: LD_INT 1
75830: ARRAY
75831: PUSH
75832: LD_INT 4
75834: ARRAY
75835: PPUSH
75836: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
75840: LD_ADDR_VAR 0 4
75844: PUSH
75845: LD_EXP 84
75849: PUSH
75850: LD_VAR 0 2
75854: ARRAY
75855: PPUSH
75856: LD_INT 1
75858: PPUSH
75859: CALL_OW 3
75863: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75864: LD_ADDR_EXP 84
75868: PUSH
75869: LD_EXP 84
75873: PPUSH
75874: LD_VAR 0 2
75878: PPUSH
75879: LD_VAR 0 4
75883: PPUSH
75884: CALL_OW 1
75888: ST_TO_ADDR
// break ;
75889: GO 75893
// end ; end ;
75891: GO 75537
75893: POP
75894: POP
// end ;
75895: GO 75469
75897: POP
75898: POP
// end ;
75899: LD_VAR 0 1
75903: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75904: LD_INT 0
75906: PPUSH
75907: PPUSH
75908: PPUSH
// if not mc_bases then
75909: LD_EXP 63
75913: NOT
75914: IFFALSE 75918
// exit ;
75916: GO 76007
// for i = 1 to mc_bases do
75918: LD_ADDR_VAR 0 2
75922: PUSH
75923: DOUBLE
75924: LD_INT 1
75926: DEC
75927: ST_TO_ADDR
75928: LD_EXP 63
75932: PUSH
75933: FOR_TO
75934: IFFALSE 76005
// begin if mc_attack [ i ] then
75936: LD_EXP 83
75940: PUSH
75941: LD_VAR 0 2
75945: ARRAY
75946: IFFALSE 76003
// begin tmp := mc_attack [ i ] [ 1 ] ;
75948: LD_ADDR_VAR 0 3
75952: PUSH
75953: LD_EXP 83
75957: PUSH
75958: LD_VAR 0 2
75962: ARRAY
75963: PUSH
75964: LD_INT 1
75966: ARRAY
75967: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
75968: LD_ADDR_EXP 83
75972: PUSH
75973: LD_EXP 83
75977: PPUSH
75978: LD_VAR 0 2
75982: PPUSH
75983: EMPTY
75984: PPUSH
75985: CALL_OW 1
75989: ST_TO_ADDR
// Attack ( tmp ) ;
75990: LD_VAR 0 3
75994: PPUSH
75995: CALL 112031 0 1
// exit ;
75999: POP
76000: POP
76001: GO 76007
// end ; end ;
76003: GO 75933
76005: POP
76006: POP
// end ;
76007: LD_VAR 0 1
76011: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
76012: LD_INT 0
76014: PPUSH
76015: PPUSH
76016: PPUSH
76017: PPUSH
76018: PPUSH
76019: PPUSH
76020: PPUSH
// if not mc_bases then
76021: LD_EXP 63
76025: NOT
76026: IFFALSE 76030
// exit ;
76028: GO 76887
// for i = 1 to mc_bases do
76030: LD_ADDR_VAR 0 2
76034: PUSH
76035: DOUBLE
76036: LD_INT 1
76038: DEC
76039: ST_TO_ADDR
76040: LD_EXP 63
76044: PUSH
76045: FOR_TO
76046: IFFALSE 76885
// begin if not mc_bases [ i ] then
76048: LD_EXP 63
76052: PUSH
76053: LD_VAR 0 2
76057: ARRAY
76058: NOT
76059: IFFALSE 76063
// continue ;
76061: GO 76045
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76063: LD_ADDR_VAR 0 7
76067: PUSH
76068: LD_EXP 63
76072: PUSH
76073: LD_VAR 0 2
76077: ARRAY
76078: PUSH
76079: LD_INT 1
76081: ARRAY
76082: PPUSH
76083: CALL 19083 0 1
76087: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
76088: LD_ADDR_EXP 86
76092: PUSH
76093: LD_EXP 86
76097: PPUSH
76098: LD_VAR 0 2
76102: PPUSH
76103: LD_EXP 63
76107: PUSH
76108: LD_VAR 0 2
76112: ARRAY
76113: PUSH
76114: LD_INT 1
76116: ARRAY
76117: PPUSH
76118: CALL_OW 255
76122: PPUSH
76123: LD_EXP 88
76127: PUSH
76128: LD_VAR 0 2
76132: ARRAY
76133: PPUSH
76134: CALL 19048 0 2
76138: PPUSH
76139: CALL_OW 1
76143: ST_TO_ADDR
// if not mc_scan [ i ] then
76144: LD_EXP 86
76148: PUSH
76149: LD_VAR 0 2
76153: ARRAY
76154: NOT
76155: IFFALSE 76333
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
76157: LD_ADDR_EXP 106
76161: PUSH
76162: LD_EXP 106
76166: PPUSH
76167: LD_VAR 0 2
76171: PPUSH
76172: LD_INT 0
76174: PPUSH
76175: CALL_OW 1
76179: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76180: LD_ADDR_VAR 0 4
76184: PUSH
76185: LD_EXP 63
76189: PUSH
76190: LD_VAR 0 2
76194: ARRAY
76195: PPUSH
76196: LD_INT 2
76198: PUSH
76199: LD_INT 25
76201: PUSH
76202: LD_INT 5
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 25
76211: PUSH
76212: LD_INT 8
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 25
76221: PUSH
76222: LD_INT 9
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: LIST
76233: LIST
76234: PPUSH
76235: CALL_OW 72
76239: ST_TO_ADDR
// if not tmp then
76240: LD_VAR 0 4
76244: NOT
76245: IFFALSE 76249
// continue ;
76247: GO 76045
// for j in tmp do
76249: LD_ADDR_VAR 0 3
76253: PUSH
76254: LD_VAR 0 4
76258: PUSH
76259: FOR_IN
76260: IFFALSE 76331
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
76262: LD_VAR 0 3
76266: PPUSH
76267: CALL_OW 310
76271: PPUSH
76272: CALL_OW 266
76276: PUSH
76277: LD_INT 5
76279: EQUAL
76280: PUSH
76281: LD_VAR 0 3
76285: PPUSH
76286: CALL_OW 257
76290: PUSH
76291: LD_INT 1
76293: EQUAL
76294: AND
76295: PUSH
76296: LD_VAR 0 3
76300: PPUSH
76301: CALL_OW 459
76305: NOT
76306: AND
76307: PUSH
76308: LD_VAR 0 7
76312: AND
76313: IFFALSE 76329
// ComChangeProfession ( j , class ) ;
76315: LD_VAR 0 3
76319: PPUSH
76320: LD_VAR 0 7
76324: PPUSH
76325: CALL_OW 123
76329: GO 76259
76331: POP
76332: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
76333: LD_EXP 86
76337: PUSH
76338: LD_VAR 0 2
76342: ARRAY
76343: PUSH
76344: LD_EXP 106
76348: PUSH
76349: LD_VAR 0 2
76353: ARRAY
76354: NOT
76355: AND
76356: PUSH
76357: LD_EXP 85
76361: PUSH
76362: LD_VAR 0 2
76366: ARRAY
76367: NOT
76368: AND
76369: PUSH
76370: LD_EXP 63
76374: PUSH
76375: LD_VAR 0 2
76379: ARRAY
76380: PPUSH
76381: LD_INT 50
76383: PUSH
76384: EMPTY
76385: LIST
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: LD_INT 30
76392: PUSH
76393: LD_INT 32
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 30
76402: PUSH
76403: LD_INT 33
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 30
76412: PUSH
76413: LD_INT 4
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 30
76422: PUSH
76423: LD_INT 5
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PPUSH
76441: CALL_OW 72
76445: PUSH
76446: LD_INT 4
76448: LESS
76449: PUSH
76450: LD_EXP 63
76454: PUSH
76455: LD_VAR 0 2
76459: ARRAY
76460: PPUSH
76461: LD_INT 3
76463: PUSH
76464: LD_INT 24
76466: PUSH
76467: LD_INT 1000
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 2
76480: PUSH
76481: LD_INT 30
76483: PUSH
76484: LD_INT 0
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: LD_INT 30
76493: PUSH
76494: LD_INT 1
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: LIST
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PPUSH
76510: CALL_OW 72
76514: OR
76515: AND
76516: IFFALSE 76767
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76518: LD_ADDR_EXP 106
76522: PUSH
76523: LD_EXP 106
76527: PPUSH
76528: LD_VAR 0 2
76532: PPUSH
76533: LD_INT 1
76535: PPUSH
76536: CALL_OW 1
76540: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76541: LD_ADDR_VAR 0 4
76545: PUSH
76546: LD_EXP 63
76550: PUSH
76551: LD_VAR 0 2
76555: ARRAY
76556: PPUSH
76557: LD_INT 2
76559: PUSH
76560: LD_INT 25
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 25
76572: PUSH
76573: LD_INT 5
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 25
76582: PUSH
76583: LD_INT 8
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 25
76592: PUSH
76593: LD_INT 9
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: PPUSH
76607: CALL_OW 72
76611: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
76612: LD_ADDR_VAR 0 4
76616: PUSH
76617: LD_VAR 0 4
76621: PUSH
76622: LD_VAR 0 4
76626: PPUSH
76627: LD_INT 18
76629: PPUSH
76630: CALL 52577 0 2
76634: DIFF
76635: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
76636: LD_VAR 0 4
76640: NOT
76641: PUSH
76642: LD_EXP 63
76646: PUSH
76647: LD_VAR 0 2
76651: ARRAY
76652: PPUSH
76653: LD_INT 2
76655: PUSH
76656: LD_INT 30
76658: PUSH
76659: LD_INT 4
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 30
76668: PUSH
76669: LD_INT 5
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: LIST
76680: PPUSH
76681: CALL_OW 72
76685: NOT
76686: AND
76687: IFFALSE 76749
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
76689: LD_ADDR_VAR 0 4
76693: PUSH
76694: LD_EXP 63
76698: PUSH
76699: LD_VAR 0 2
76703: ARRAY
76704: PPUSH
76705: LD_INT 2
76707: PUSH
76708: LD_INT 25
76710: PUSH
76711: LD_INT 2
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 25
76720: PUSH
76721: LD_INT 3
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 25
76730: PUSH
76731: LD_INT 4
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: PPUSH
76744: CALL_OW 72
76748: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
76749: LD_VAR 0 2
76753: PPUSH
76754: LD_VAR 0 4
76758: PPUSH
76759: CALL 116740 0 2
// exit ;
76763: POP
76764: POP
76765: GO 76887
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
76767: LD_EXP 86
76771: PUSH
76772: LD_VAR 0 2
76776: ARRAY
76777: PUSH
76778: LD_EXP 106
76782: PUSH
76783: LD_VAR 0 2
76787: ARRAY
76788: NOT
76789: AND
76790: PUSH
76791: LD_EXP 85
76795: PUSH
76796: LD_VAR 0 2
76800: ARRAY
76801: AND
76802: IFFALSE 76883
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76804: LD_ADDR_EXP 106
76808: PUSH
76809: LD_EXP 106
76813: PPUSH
76814: LD_VAR 0 2
76818: PPUSH
76819: LD_INT 1
76821: PPUSH
76822: CALL_OW 1
76826: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
76827: LD_ADDR_VAR 0 4
76831: PUSH
76832: LD_EXP 85
76836: PUSH
76837: LD_VAR 0 2
76841: ARRAY
76842: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
76843: LD_ADDR_EXP 85
76847: PUSH
76848: LD_EXP 85
76852: PPUSH
76853: LD_VAR 0 2
76857: PPUSH
76858: EMPTY
76859: PPUSH
76860: CALL_OW 1
76864: ST_TO_ADDR
// Defend ( i , tmp ) ;
76865: LD_VAR 0 2
76869: PPUSH
76870: LD_VAR 0 4
76874: PPUSH
76875: CALL 117336 0 2
// exit ;
76879: POP
76880: POP
76881: GO 76887
// end ; end ;
76883: GO 76045
76885: POP
76886: POP
// end ;
76887: LD_VAR 0 1
76891: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76892: LD_INT 0
76894: PPUSH
76895: PPUSH
76896: PPUSH
76897: PPUSH
76898: PPUSH
76899: PPUSH
76900: PPUSH
76901: PPUSH
76902: PPUSH
76903: PPUSH
76904: PPUSH
// if not mc_bases then
76905: LD_EXP 63
76909: NOT
76910: IFFALSE 76914
// exit ;
76912: GO 78001
// for i = 1 to mc_bases do
76914: LD_ADDR_VAR 0 2
76918: PUSH
76919: DOUBLE
76920: LD_INT 1
76922: DEC
76923: ST_TO_ADDR
76924: LD_EXP 63
76928: PUSH
76929: FOR_TO
76930: IFFALSE 77999
// begin tmp := mc_lab [ i ] ;
76932: LD_ADDR_VAR 0 6
76936: PUSH
76937: LD_EXP 96
76941: PUSH
76942: LD_VAR 0 2
76946: ARRAY
76947: ST_TO_ADDR
// if not tmp then
76948: LD_VAR 0 6
76952: NOT
76953: IFFALSE 76957
// continue ;
76955: GO 76929
// idle_lab := 0 ;
76957: LD_ADDR_VAR 0 11
76961: PUSH
76962: LD_INT 0
76964: ST_TO_ADDR
// for j in tmp do
76965: LD_ADDR_VAR 0 3
76969: PUSH
76970: LD_VAR 0 6
76974: PUSH
76975: FOR_IN
76976: IFFALSE 77995
// begin researching := false ;
76978: LD_ADDR_VAR 0 10
76982: PUSH
76983: LD_INT 0
76985: ST_TO_ADDR
// side := GetSide ( j ) ;
76986: LD_ADDR_VAR 0 4
76990: PUSH
76991: LD_VAR 0 3
76995: PPUSH
76996: CALL_OW 255
77000: ST_TO_ADDR
// if not mc_tech [ side ] then
77001: LD_EXP 90
77005: PUSH
77006: LD_VAR 0 4
77010: ARRAY
77011: NOT
77012: IFFALSE 77016
// continue ;
77014: GO 76975
// if BuildingStatus ( j ) = bs_idle then
77016: LD_VAR 0 3
77020: PPUSH
77021: CALL_OW 461
77025: PUSH
77026: LD_INT 2
77028: EQUAL
77029: IFFALSE 77217
// begin if idle_lab and UnitsInside ( j ) < 6 then
77031: LD_VAR 0 11
77035: PUSH
77036: LD_VAR 0 3
77040: PPUSH
77041: CALL_OW 313
77045: PUSH
77046: LD_INT 6
77048: LESS
77049: AND
77050: IFFALSE 77121
// begin tmp2 := UnitsInside ( idle_lab ) ;
77052: LD_ADDR_VAR 0 9
77056: PUSH
77057: LD_VAR 0 11
77061: PPUSH
77062: CALL_OW 313
77066: ST_TO_ADDR
// if tmp2 then
77067: LD_VAR 0 9
77071: IFFALSE 77113
// for x in tmp2 do
77073: LD_ADDR_VAR 0 7
77077: PUSH
77078: LD_VAR 0 9
77082: PUSH
77083: FOR_IN
77084: IFFALSE 77111
// begin ComExitBuilding ( x ) ;
77086: LD_VAR 0 7
77090: PPUSH
77091: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77095: LD_VAR 0 7
77099: PPUSH
77100: LD_VAR 0 3
77104: PPUSH
77105: CALL_OW 180
// end ;
77109: GO 77083
77111: POP
77112: POP
// idle_lab := 0 ;
77113: LD_ADDR_VAR 0 11
77117: PUSH
77118: LD_INT 0
77120: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
77121: LD_ADDR_VAR 0 5
77125: PUSH
77126: LD_EXP 90
77130: PUSH
77131: LD_VAR 0 4
77135: ARRAY
77136: PUSH
77137: FOR_IN
77138: IFFALSE 77198
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
77140: LD_VAR 0 3
77144: PPUSH
77145: LD_VAR 0 5
77149: PPUSH
77150: CALL_OW 430
77154: PUSH
77155: LD_VAR 0 4
77159: PPUSH
77160: LD_VAR 0 5
77164: PPUSH
77165: CALL 18153 0 2
77169: AND
77170: IFFALSE 77196
// begin researching := true ;
77172: LD_ADDR_VAR 0 10
77176: PUSH
77177: LD_INT 1
77179: ST_TO_ADDR
// ComResearch ( j , t ) ;
77180: LD_VAR 0 3
77184: PPUSH
77185: LD_VAR 0 5
77189: PPUSH
77190: CALL_OW 124
// break ;
77194: GO 77198
// end ;
77196: GO 77137
77198: POP
77199: POP
// if not researching then
77200: LD_VAR 0 10
77204: NOT
77205: IFFALSE 77217
// idle_lab := j ;
77207: LD_ADDR_VAR 0 11
77211: PUSH
77212: LD_VAR 0 3
77216: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
77217: LD_VAR 0 3
77221: PPUSH
77222: CALL_OW 461
77226: PUSH
77227: LD_INT 10
77229: EQUAL
77230: IFFALSE 77818
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
77232: LD_EXP 92
77236: PUSH
77237: LD_VAR 0 2
77241: ARRAY
77242: NOT
77243: PUSH
77244: LD_EXP 93
77248: PUSH
77249: LD_VAR 0 2
77253: ARRAY
77254: NOT
77255: AND
77256: PUSH
77257: LD_EXP 90
77261: PUSH
77262: LD_VAR 0 4
77266: ARRAY
77267: PUSH
77268: LD_INT 1
77270: GREATER
77271: AND
77272: IFFALSE 77403
// begin ComCancel ( j ) ;
77274: LD_VAR 0 3
77278: PPUSH
77279: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
77283: LD_ADDR_EXP 90
77287: PUSH
77288: LD_EXP 90
77292: PPUSH
77293: LD_VAR 0 4
77297: PPUSH
77298: LD_EXP 90
77302: PUSH
77303: LD_VAR 0 4
77307: ARRAY
77308: PPUSH
77309: LD_EXP 90
77313: PUSH
77314: LD_VAR 0 4
77318: ARRAY
77319: PUSH
77320: LD_INT 1
77322: MINUS
77323: PPUSH
77324: LD_EXP 90
77328: PUSH
77329: LD_VAR 0 4
77333: ARRAY
77334: PPUSH
77335: LD_INT 0
77337: PPUSH
77338: CALL 21677 0 4
77342: PPUSH
77343: CALL_OW 1
77347: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
77348: LD_ADDR_EXP 90
77352: PUSH
77353: LD_EXP 90
77357: PPUSH
77358: LD_VAR 0 4
77362: PPUSH
77363: LD_EXP 90
77367: PUSH
77368: LD_VAR 0 4
77372: ARRAY
77373: PPUSH
77374: LD_EXP 90
77378: PUSH
77379: LD_VAR 0 4
77383: ARRAY
77384: PPUSH
77385: LD_INT 1
77387: PPUSH
77388: LD_INT 0
77390: PPUSH
77391: CALL 21677 0 4
77395: PPUSH
77396: CALL_OW 1
77400: ST_TO_ADDR
// continue ;
77401: GO 76975
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
77403: LD_EXP 92
77407: PUSH
77408: LD_VAR 0 2
77412: ARRAY
77413: PUSH
77414: LD_EXP 93
77418: PUSH
77419: LD_VAR 0 2
77423: ARRAY
77424: NOT
77425: AND
77426: IFFALSE 77553
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
77428: LD_ADDR_EXP 93
77432: PUSH
77433: LD_EXP 93
77437: PPUSH
77438: LD_VAR 0 2
77442: PUSH
77443: LD_EXP 93
77447: PUSH
77448: LD_VAR 0 2
77452: ARRAY
77453: PUSH
77454: LD_INT 1
77456: PLUS
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PPUSH
77462: LD_EXP 92
77466: PUSH
77467: LD_VAR 0 2
77471: ARRAY
77472: PUSH
77473: LD_INT 1
77475: ARRAY
77476: PPUSH
77477: CALL 22259 0 3
77481: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
77482: LD_EXP 92
77486: PUSH
77487: LD_VAR 0 2
77491: ARRAY
77492: PUSH
77493: LD_INT 1
77495: ARRAY
77496: PPUSH
77497: LD_INT 112
77499: PPUSH
77500: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
77504: LD_ADDR_VAR 0 9
77508: PUSH
77509: LD_EXP 92
77513: PUSH
77514: LD_VAR 0 2
77518: ARRAY
77519: PPUSH
77520: LD_INT 1
77522: PPUSH
77523: CALL_OW 3
77527: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
77528: LD_ADDR_EXP 92
77532: PUSH
77533: LD_EXP 92
77537: PPUSH
77538: LD_VAR 0 2
77542: PPUSH
77543: LD_VAR 0 9
77547: PPUSH
77548: CALL_OW 1
77552: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
77553: LD_EXP 92
77557: PUSH
77558: LD_VAR 0 2
77562: ARRAY
77563: PUSH
77564: LD_EXP 93
77568: PUSH
77569: LD_VAR 0 2
77573: ARRAY
77574: AND
77575: PUSH
77576: LD_EXP 93
77580: PUSH
77581: LD_VAR 0 2
77585: ARRAY
77586: PUSH
77587: LD_INT 1
77589: ARRAY
77590: PPUSH
77591: CALL_OW 310
77595: NOT
77596: AND
77597: PUSH
77598: LD_VAR 0 3
77602: PPUSH
77603: CALL_OW 313
77607: PUSH
77608: LD_INT 6
77610: EQUAL
77611: AND
77612: IFFALSE 77668
// begin tmp2 := UnitsInside ( j ) ;
77614: LD_ADDR_VAR 0 9
77618: PUSH
77619: LD_VAR 0 3
77623: PPUSH
77624: CALL_OW 313
77628: ST_TO_ADDR
// if tmp2 = 6 then
77629: LD_VAR 0 9
77633: PUSH
77634: LD_INT 6
77636: EQUAL
77637: IFFALSE 77668
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
77639: LD_VAR 0 9
77643: PUSH
77644: LD_INT 1
77646: ARRAY
77647: PPUSH
77648: LD_INT 112
77650: PPUSH
77651: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
77655: LD_VAR 0 9
77659: PUSH
77660: LD_INT 1
77662: ARRAY
77663: PPUSH
77664: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
77668: LD_EXP 93
77672: PUSH
77673: LD_VAR 0 2
77677: ARRAY
77678: PUSH
77679: LD_EXP 93
77683: PUSH
77684: LD_VAR 0 2
77688: ARRAY
77689: PUSH
77690: LD_INT 1
77692: ARRAY
77693: PPUSH
77694: CALL_OW 314
77698: NOT
77699: AND
77700: PUSH
77701: LD_EXP 93
77705: PUSH
77706: LD_VAR 0 2
77710: ARRAY
77711: PUSH
77712: LD_INT 1
77714: ARRAY
77715: PPUSH
77716: CALL_OW 310
77720: NOT
77721: AND
77722: IFFALSE 77748
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
77724: LD_EXP 93
77728: PUSH
77729: LD_VAR 0 2
77733: ARRAY
77734: PUSH
77735: LD_INT 1
77737: ARRAY
77738: PPUSH
77739: LD_VAR 0 3
77743: PPUSH
77744: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
77748: LD_EXP 93
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PUSH
77759: LD_INT 1
77761: ARRAY
77762: PPUSH
77763: CALL_OW 310
77767: PUSH
77768: LD_EXP 93
77772: PUSH
77773: LD_VAR 0 2
77777: ARRAY
77778: PUSH
77779: LD_INT 1
77781: ARRAY
77782: PPUSH
77783: CALL_OW 310
77787: PPUSH
77788: CALL_OW 461
77792: PUSH
77793: LD_INT 3
77795: NONEQUAL
77796: AND
77797: IFFALSE 77818
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
77799: LD_EXP 93
77803: PUSH
77804: LD_VAR 0 2
77808: ARRAY
77809: PUSH
77810: LD_INT 1
77812: ARRAY
77813: PPUSH
77814: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
77818: LD_VAR 0 3
77822: PPUSH
77823: CALL_OW 461
77827: PUSH
77828: LD_INT 6
77830: EQUAL
77831: PUSH
77832: LD_VAR 0 6
77836: PUSH
77837: LD_INT 1
77839: GREATER
77840: AND
77841: IFFALSE 77993
// begin sci := [ ] ;
77843: LD_ADDR_VAR 0 8
77847: PUSH
77848: EMPTY
77849: ST_TO_ADDR
// for x in ( tmp diff j ) do
77850: LD_ADDR_VAR 0 7
77854: PUSH
77855: LD_VAR 0 6
77859: PUSH
77860: LD_VAR 0 3
77864: DIFF
77865: PUSH
77866: FOR_IN
77867: IFFALSE 77919
// begin if sci = 6 then
77869: LD_VAR 0 8
77873: PUSH
77874: LD_INT 6
77876: EQUAL
77877: IFFALSE 77881
// break ;
77879: GO 77919
// if BuildingStatus ( x ) = bs_idle then
77881: LD_VAR 0 7
77885: PPUSH
77886: CALL_OW 461
77890: PUSH
77891: LD_INT 2
77893: EQUAL
77894: IFFALSE 77917
// sci := sci ^ UnitsInside ( x ) ;
77896: LD_ADDR_VAR 0 8
77900: PUSH
77901: LD_VAR 0 8
77905: PUSH
77906: LD_VAR 0 7
77910: PPUSH
77911: CALL_OW 313
77915: ADD
77916: ST_TO_ADDR
// end ;
77917: GO 77866
77919: POP
77920: POP
// if not sci then
77921: LD_VAR 0 8
77925: NOT
77926: IFFALSE 77930
// continue ;
77928: GO 76975
// for x in sci do
77930: LD_ADDR_VAR 0 7
77934: PUSH
77935: LD_VAR 0 8
77939: PUSH
77940: FOR_IN
77941: IFFALSE 77991
// if IsInUnit ( x ) and not HasTask ( x ) then
77943: LD_VAR 0 7
77947: PPUSH
77948: CALL_OW 310
77952: PUSH
77953: LD_VAR 0 7
77957: PPUSH
77958: CALL_OW 314
77962: NOT
77963: AND
77964: IFFALSE 77989
// begin ComExitBuilding ( x ) ;
77966: LD_VAR 0 7
77970: PPUSH
77971: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77975: LD_VAR 0 7
77979: PPUSH
77980: LD_VAR 0 3
77984: PPUSH
77985: CALL_OW 180
// end ;
77989: GO 77940
77991: POP
77992: POP
// end ; end ;
77993: GO 76975
77995: POP
77996: POP
// end ;
77997: GO 76929
77999: POP
78000: POP
// end ;
78001: LD_VAR 0 1
78005: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
78006: LD_INT 0
78008: PPUSH
78009: PPUSH
// if not mc_bases then
78010: LD_EXP 63
78014: NOT
78015: IFFALSE 78019
// exit ;
78017: GO 78100
// for i = 1 to mc_bases do
78019: LD_ADDR_VAR 0 2
78023: PUSH
78024: DOUBLE
78025: LD_INT 1
78027: DEC
78028: ST_TO_ADDR
78029: LD_EXP 63
78033: PUSH
78034: FOR_TO
78035: IFFALSE 78098
// if mc_mines [ i ] and mc_miners [ i ] then
78037: LD_EXP 76
78041: PUSH
78042: LD_VAR 0 2
78046: ARRAY
78047: PUSH
78048: LD_EXP 77
78052: PUSH
78053: LD_VAR 0 2
78057: ARRAY
78058: AND
78059: IFFALSE 78096
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
78061: LD_EXP 77
78065: PUSH
78066: LD_VAR 0 2
78070: ARRAY
78071: PUSH
78072: LD_INT 1
78074: ARRAY
78075: PPUSH
78076: CALL_OW 255
78080: PPUSH
78081: LD_EXP 76
78085: PUSH
78086: LD_VAR 0 2
78090: ARRAY
78091: PPUSH
78092: CALL 19236 0 2
78096: GO 78034
78098: POP
78099: POP
// end ;
78100: LD_VAR 0 1
78104: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
78105: LD_INT 0
78107: PPUSH
78108: PPUSH
78109: PPUSH
78110: PPUSH
78111: PPUSH
78112: PPUSH
78113: PPUSH
78114: PPUSH
// if not mc_bases or not mc_parking then
78115: LD_EXP 63
78119: NOT
78120: PUSH
78121: LD_EXP 87
78125: NOT
78126: OR
78127: IFFALSE 78131
// exit ;
78129: GO 78869
// for i = 1 to mc_bases do
78131: LD_ADDR_VAR 0 2
78135: PUSH
78136: DOUBLE
78137: LD_INT 1
78139: DEC
78140: ST_TO_ADDR
78141: LD_EXP 63
78145: PUSH
78146: FOR_TO
78147: IFFALSE 78867
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
78149: LD_EXP 63
78153: PUSH
78154: LD_VAR 0 2
78158: ARRAY
78159: NOT
78160: PUSH
78161: LD_EXP 87
78165: PUSH
78166: LD_VAR 0 2
78170: ARRAY
78171: NOT
78172: OR
78173: IFFALSE 78177
// continue ;
78175: GO 78146
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
78177: LD_ADDR_VAR 0 5
78181: PUSH
78182: LD_EXP 63
78186: PUSH
78187: LD_VAR 0 2
78191: ARRAY
78192: PUSH
78193: LD_INT 1
78195: ARRAY
78196: PPUSH
78197: CALL_OW 255
78201: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78202: LD_ADDR_VAR 0 6
78206: PUSH
78207: LD_EXP 63
78211: PUSH
78212: LD_VAR 0 2
78216: ARRAY
78217: PPUSH
78218: LD_INT 30
78220: PUSH
78221: LD_INT 3
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PPUSH
78228: CALL_OW 72
78232: ST_TO_ADDR
// if not fac then
78233: LD_VAR 0 6
78237: NOT
78238: IFFALSE 78289
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78240: LD_ADDR_VAR 0 6
78244: PUSH
78245: LD_EXP 63
78249: PUSH
78250: LD_VAR 0 2
78254: ARRAY
78255: PPUSH
78256: LD_INT 2
78258: PUSH
78259: LD_INT 30
78261: PUSH
78262: LD_INT 0
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 30
78271: PUSH
78272: LD_INT 1
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: LIST
78283: PPUSH
78284: CALL_OW 72
78288: ST_TO_ADDR
// if not fac then
78289: LD_VAR 0 6
78293: NOT
78294: IFFALSE 78298
// continue ;
78296: GO 78146
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78298: LD_ADDR_VAR 0 7
78302: PUSH
78303: LD_EXP 87
78307: PUSH
78308: LD_VAR 0 2
78312: ARRAY
78313: PPUSH
78314: LD_INT 22
78316: PUSH
78317: LD_VAR 0 5
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 21
78328: PUSH
78329: LD_INT 2
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 3
78338: PUSH
78339: LD_INT 60
78341: PUSH
78342: EMPTY
78343: LIST
78344: PUSH
78345: EMPTY
78346: LIST
78347: LIST
78348: PUSH
78349: LD_INT 3
78351: PUSH
78352: LD_INT 24
78354: PUSH
78355: LD_INT 1000
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: PPUSH
78372: CALL_OW 70
78376: ST_TO_ADDR
// for j in fac do
78377: LD_ADDR_VAR 0 3
78381: PUSH
78382: LD_VAR 0 6
78386: PUSH
78387: FOR_IN
78388: IFFALSE 78483
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78390: LD_ADDR_VAR 0 7
78394: PUSH
78395: LD_VAR 0 7
78399: PUSH
78400: LD_INT 22
78402: PUSH
78403: LD_VAR 0 5
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 91
78414: PUSH
78415: LD_VAR 0 3
78419: PUSH
78420: LD_INT 15
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: LIST
78427: PUSH
78428: LD_INT 21
78430: PUSH
78431: LD_INT 2
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 3
78440: PUSH
78441: LD_INT 60
78443: PUSH
78444: EMPTY
78445: LIST
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 3
78453: PUSH
78454: LD_INT 24
78456: PUSH
78457: LD_INT 1000
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: PPUSH
78475: CALL_OW 69
78479: UNION
78480: ST_TO_ADDR
78481: GO 78387
78483: POP
78484: POP
// if not vehs then
78485: LD_VAR 0 7
78489: NOT
78490: IFFALSE 78516
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
78492: LD_ADDR_EXP 75
78496: PUSH
78497: LD_EXP 75
78501: PPUSH
78502: LD_VAR 0 2
78506: PPUSH
78507: EMPTY
78508: PPUSH
78509: CALL_OW 1
78513: ST_TO_ADDR
// continue ;
78514: GO 78146
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78516: LD_ADDR_VAR 0 8
78520: PUSH
78521: LD_EXP 63
78525: PUSH
78526: LD_VAR 0 2
78530: ARRAY
78531: PPUSH
78532: LD_INT 30
78534: PUSH
78535: LD_INT 3
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PPUSH
78542: CALL_OW 72
78546: ST_TO_ADDR
// if tmp then
78547: LD_VAR 0 8
78551: IFFALSE 78654
// begin for j in tmp do
78553: LD_ADDR_VAR 0 3
78557: PUSH
78558: LD_VAR 0 8
78562: PUSH
78563: FOR_IN
78564: IFFALSE 78652
// for k in UnitsInside ( j ) do
78566: LD_ADDR_VAR 0 4
78570: PUSH
78571: LD_VAR 0 3
78575: PPUSH
78576: CALL_OW 313
78580: PUSH
78581: FOR_IN
78582: IFFALSE 78648
// if k then
78584: LD_VAR 0 4
78588: IFFALSE 78646
// if not k in mc_repair_vehicle [ i ] then
78590: LD_VAR 0 4
78594: PUSH
78595: LD_EXP 75
78599: PUSH
78600: LD_VAR 0 2
78604: ARRAY
78605: IN
78606: NOT
78607: IFFALSE 78646
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
78609: LD_ADDR_EXP 75
78613: PUSH
78614: LD_EXP 75
78618: PPUSH
78619: LD_VAR 0 2
78623: PPUSH
78624: LD_EXP 75
78628: PUSH
78629: LD_VAR 0 2
78633: ARRAY
78634: PUSH
78635: LD_VAR 0 4
78639: UNION
78640: PPUSH
78641: CALL_OW 1
78645: ST_TO_ADDR
78646: GO 78581
78648: POP
78649: POP
78650: GO 78563
78652: POP
78653: POP
// end ; if not mc_repair_vehicle [ i ] then
78654: LD_EXP 75
78658: PUSH
78659: LD_VAR 0 2
78663: ARRAY
78664: NOT
78665: IFFALSE 78669
// continue ;
78667: GO 78146
// for j in mc_repair_vehicle [ i ] do
78669: LD_ADDR_VAR 0 3
78673: PUSH
78674: LD_EXP 75
78678: PUSH
78679: LD_VAR 0 2
78683: ARRAY
78684: PUSH
78685: FOR_IN
78686: IFFALSE 78863
// begin if GetClass ( j ) <> 3 then
78688: LD_VAR 0 3
78692: PPUSH
78693: CALL_OW 257
78697: PUSH
78698: LD_INT 3
78700: NONEQUAL
78701: IFFALSE 78742
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
78703: LD_ADDR_EXP 75
78707: PUSH
78708: LD_EXP 75
78712: PPUSH
78713: LD_VAR 0 2
78717: PPUSH
78718: LD_EXP 75
78722: PUSH
78723: LD_VAR 0 2
78727: ARRAY
78728: PUSH
78729: LD_VAR 0 3
78733: DIFF
78734: PPUSH
78735: CALL_OW 1
78739: ST_TO_ADDR
// continue ;
78740: GO 78685
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
78742: LD_VAR 0 3
78746: PPUSH
78747: CALL_OW 311
78751: NOT
78752: PUSH
78753: LD_VAR 0 3
78757: PUSH
78758: LD_EXP 66
78762: PUSH
78763: LD_VAR 0 2
78767: ARRAY
78768: PUSH
78769: LD_INT 1
78771: ARRAY
78772: IN
78773: NOT
78774: AND
78775: PUSH
78776: LD_VAR 0 3
78780: PUSH
78781: LD_EXP 66
78785: PUSH
78786: LD_VAR 0 2
78790: ARRAY
78791: PUSH
78792: LD_INT 2
78794: ARRAY
78795: IN
78796: NOT
78797: AND
78798: IFFALSE 78861
// begin if IsInUnit ( j ) then
78800: LD_VAR 0 3
78804: PPUSH
78805: CALL_OW 310
78809: IFFALSE 78822
// ComExitBuilding ( j ) else
78811: LD_VAR 0 3
78815: PPUSH
78816: CALL_OW 122
78820: GO 78861
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
78822: LD_VAR 0 3
78826: PPUSH
78827: LD_VAR 0 7
78831: PUSH
78832: LD_INT 1
78834: ARRAY
78835: PPUSH
78836: CALL 57073 0 2
78840: NOT
78841: IFFALSE 78861
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
78843: LD_VAR 0 3
78847: PPUSH
78848: LD_VAR 0 7
78852: PUSH
78853: LD_INT 1
78855: ARRAY
78856: PPUSH
78857: CALL_OW 129
// end ; end ;
78861: GO 78685
78863: POP
78864: POP
// end ;
78865: GO 78146
78867: POP
78868: POP
// end ;
78869: LD_VAR 0 1
78873: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
78874: LD_INT 0
78876: PPUSH
78877: PPUSH
78878: PPUSH
78879: PPUSH
78880: PPUSH
78881: PPUSH
78882: PPUSH
78883: PPUSH
78884: PPUSH
78885: PPUSH
78886: PPUSH
// if not mc_bases then
78887: LD_EXP 63
78891: NOT
78892: IFFALSE 78896
// exit ;
78894: GO 79698
// for i = 1 to mc_bases do
78896: LD_ADDR_VAR 0 2
78900: PUSH
78901: DOUBLE
78902: LD_INT 1
78904: DEC
78905: ST_TO_ADDR
78906: LD_EXP 63
78910: PUSH
78911: FOR_TO
78912: IFFALSE 79696
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78914: LD_EXP 91
78918: PUSH
78919: LD_VAR 0 2
78923: ARRAY
78924: NOT
78925: PUSH
78926: LD_EXP 66
78930: PUSH
78931: LD_VAR 0 2
78935: ARRAY
78936: PUSH
78937: LD_INT 1
78939: ARRAY
78940: OR
78941: PUSH
78942: LD_EXP 66
78946: PUSH
78947: LD_VAR 0 2
78951: ARRAY
78952: PUSH
78953: LD_INT 2
78955: ARRAY
78956: OR
78957: PUSH
78958: LD_EXP 89
78962: PUSH
78963: LD_VAR 0 2
78967: ARRAY
78968: PPUSH
78969: LD_INT 1
78971: PPUSH
78972: CALL_OW 325
78976: NOT
78977: OR
78978: PUSH
78979: LD_EXP 86
78983: PUSH
78984: LD_VAR 0 2
78988: ARRAY
78989: OR
78990: IFFALSE 78994
// continue ;
78992: GO 78911
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
78994: LD_ADDR_VAR 0 8
78998: PUSH
78999: LD_EXP 63
79003: PUSH
79004: LD_VAR 0 2
79008: ARRAY
79009: PPUSH
79010: LD_INT 25
79012: PUSH
79013: LD_INT 4
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 50
79022: PUSH
79023: EMPTY
79024: LIST
79025: PUSH
79026: LD_INT 3
79028: PUSH
79029: LD_INT 60
79031: PUSH
79032: EMPTY
79033: LIST
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: LIST
79043: PPUSH
79044: CALL_OW 72
79048: PUSH
79049: LD_EXP 67
79053: PUSH
79054: LD_VAR 0 2
79058: ARRAY
79059: DIFF
79060: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79061: LD_ADDR_VAR 0 9
79065: PUSH
79066: LD_EXP 63
79070: PUSH
79071: LD_VAR 0 2
79075: ARRAY
79076: PPUSH
79077: LD_INT 2
79079: PUSH
79080: LD_INT 30
79082: PUSH
79083: LD_INT 0
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 30
79092: PUSH
79093: LD_INT 1
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: LIST
79104: PPUSH
79105: CALL_OW 72
79109: ST_TO_ADDR
// if not tmp or not dep then
79110: LD_VAR 0 8
79114: NOT
79115: PUSH
79116: LD_VAR 0 9
79120: NOT
79121: OR
79122: IFFALSE 79126
// continue ;
79124: GO 78911
// side := GetSide ( tmp [ 1 ] ) ;
79126: LD_ADDR_VAR 0 11
79130: PUSH
79131: LD_VAR 0 8
79135: PUSH
79136: LD_INT 1
79138: ARRAY
79139: PPUSH
79140: CALL_OW 255
79144: ST_TO_ADDR
// dep := dep [ 1 ] ;
79145: LD_ADDR_VAR 0 9
79149: PUSH
79150: LD_VAR 0 9
79154: PUSH
79155: LD_INT 1
79157: ARRAY
79158: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
79159: LD_ADDR_VAR 0 7
79163: PUSH
79164: LD_EXP 91
79168: PUSH
79169: LD_VAR 0 2
79173: ARRAY
79174: PPUSH
79175: LD_INT 22
79177: PUSH
79178: LD_INT 0
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 25
79187: PUSH
79188: LD_INT 12
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PPUSH
79199: CALL_OW 70
79203: PUSH
79204: LD_INT 22
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 25
79216: PUSH
79217: LD_INT 12
79219: PUSH
79220: EMPTY
79221: LIST
79222: LIST
79223: PUSH
79224: LD_INT 91
79226: PUSH
79227: LD_VAR 0 9
79231: PUSH
79232: LD_INT 20
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: LIST
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: LIST
79244: PPUSH
79245: CALL_OW 69
79249: UNION
79250: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
79251: LD_ADDR_VAR 0 10
79255: PUSH
79256: LD_EXP 91
79260: PUSH
79261: LD_VAR 0 2
79265: ARRAY
79266: PPUSH
79267: LD_INT 81
79269: PUSH
79270: LD_VAR 0 11
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PPUSH
79279: CALL_OW 70
79283: ST_TO_ADDR
// if not apes or danger_at_area then
79284: LD_VAR 0 7
79288: NOT
79289: PUSH
79290: LD_VAR 0 10
79294: OR
79295: IFFALSE 79345
// begin if mc_taming [ i ] then
79297: LD_EXP 94
79301: PUSH
79302: LD_VAR 0 2
79306: ARRAY
79307: IFFALSE 79343
// begin MC_Reset ( i , 121 ) ;
79309: LD_VAR 0 2
79313: PPUSH
79314: LD_INT 121
79316: PPUSH
79317: CALL 64261 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
79321: LD_ADDR_EXP 94
79325: PUSH
79326: LD_EXP 94
79330: PPUSH
79331: LD_VAR 0 2
79335: PPUSH
79336: EMPTY
79337: PPUSH
79338: CALL_OW 1
79342: ST_TO_ADDR
// end ; continue ;
79343: GO 78911
// end ; for j in tmp do
79345: LD_ADDR_VAR 0 3
79349: PUSH
79350: LD_VAR 0 8
79354: PUSH
79355: FOR_IN
79356: IFFALSE 79692
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
79358: LD_VAR 0 3
79362: PUSH
79363: LD_EXP 94
79367: PUSH
79368: LD_VAR 0 2
79372: ARRAY
79373: IN
79374: NOT
79375: PUSH
79376: LD_EXP 94
79380: PUSH
79381: LD_VAR 0 2
79385: ARRAY
79386: PUSH
79387: LD_INT 3
79389: LESS
79390: AND
79391: IFFALSE 79449
// begin SetTag ( j , 121 ) ;
79393: LD_VAR 0 3
79397: PPUSH
79398: LD_INT 121
79400: PPUSH
79401: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
79405: LD_ADDR_EXP 94
79409: PUSH
79410: LD_EXP 94
79414: PPUSH
79415: LD_VAR 0 2
79419: PUSH
79420: LD_EXP 94
79424: PUSH
79425: LD_VAR 0 2
79429: ARRAY
79430: PUSH
79431: LD_INT 1
79433: PLUS
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PPUSH
79439: LD_VAR 0 3
79443: PPUSH
79444: CALL 22259 0 3
79448: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
79449: LD_VAR 0 3
79453: PUSH
79454: LD_EXP 94
79458: PUSH
79459: LD_VAR 0 2
79463: ARRAY
79464: IN
79465: IFFALSE 79690
// begin if GetClass ( j ) <> 4 then
79467: LD_VAR 0 3
79471: PPUSH
79472: CALL_OW 257
79476: PUSH
79477: LD_INT 4
79479: NONEQUAL
79480: IFFALSE 79533
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
79482: LD_ADDR_EXP 94
79486: PUSH
79487: LD_EXP 94
79491: PPUSH
79492: LD_VAR 0 2
79496: PPUSH
79497: LD_EXP 94
79501: PUSH
79502: LD_VAR 0 2
79506: ARRAY
79507: PUSH
79508: LD_VAR 0 3
79512: DIFF
79513: PPUSH
79514: CALL_OW 1
79518: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79519: LD_VAR 0 3
79523: PPUSH
79524: LD_INT 0
79526: PPUSH
79527: CALL_OW 109
// continue ;
79531: GO 79355
// end ; if IsInUnit ( j ) then
79533: LD_VAR 0 3
79537: PPUSH
79538: CALL_OW 310
79542: IFFALSE 79553
// ComExitBuilding ( j ) ;
79544: LD_VAR 0 3
79548: PPUSH
79549: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
79553: LD_ADDR_VAR 0 6
79557: PUSH
79558: LD_VAR 0 7
79562: PPUSH
79563: LD_VAR 0 3
79567: PPUSH
79568: CALL_OW 74
79572: ST_TO_ADDR
// if not ape then
79573: LD_VAR 0 6
79577: NOT
79578: IFFALSE 79582
// break ;
79580: GO 79692
// x := GetX ( ape ) ;
79582: LD_ADDR_VAR 0 4
79586: PUSH
79587: LD_VAR 0 6
79591: PPUSH
79592: CALL_OW 250
79596: ST_TO_ADDR
// y := GetY ( ape ) ;
79597: LD_ADDR_VAR 0 5
79601: PUSH
79602: LD_VAR 0 6
79606: PPUSH
79607: CALL_OW 251
79611: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79612: LD_VAR 0 4
79616: PPUSH
79617: LD_VAR 0 5
79621: PPUSH
79622: CALL_OW 488
79626: NOT
79627: PUSH
79628: LD_VAR 0 11
79632: PPUSH
79633: LD_VAR 0 4
79637: PPUSH
79638: LD_VAR 0 5
79642: PPUSH
79643: LD_INT 20
79645: PPUSH
79646: CALL 23523 0 4
79650: PUSH
79651: LD_INT 4
79653: ARRAY
79654: OR
79655: IFFALSE 79659
// break ;
79657: GO 79692
// if not HasTask ( j ) then
79659: LD_VAR 0 3
79663: PPUSH
79664: CALL_OW 314
79668: NOT
79669: IFFALSE 79690
// ComTameXY ( j , x , y ) ;
79671: LD_VAR 0 3
79675: PPUSH
79676: LD_VAR 0 4
79680: PPUSH
79681: LD_VAR 0 5
79685: PPUSH
79686: CALL_OW 131
// end ; end ;
79690: GO 79355
79692: POP
79693: POP
// end ;
79694: GO 78911
79696: POP
79697: POP
// end ;
79698: LD_VAR 0 1
79702: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
79703: LD_INT 0
79705: PPUSH
79706: PPUSH
79707: PPUSH
79708: PPUSH
79709: PPUSH
79710: PPUSH
79711: PPUSH
79712: PPUSH
// if not mc_bases then
79713: LD_EXP 63
79717: NOT
79718: IFFALSE 79722
// exit ;
79720: GO 80348
// for i = 1 to mc_bases do
79722: LD_ADDR_VAR 0 2
79726: PUSH
79727: DOUBLE
79728: LD_INT 1
79730: DEC
79731: ST_TO_ADDR
79732: LD_EXP 63
79736: PUSH
79737: FOR_TO
79738: IFFALSE 80346
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
79740: LD_EXP 92
79744: PUSH
79745: LD_VAR 0 2
79749: ARRAY
79750: NOT
79751: PUSH
79752: LD_EXP 92
79756: PUSH
79757: LD_VAR 0 2
79761: ARRAY
79762: PPUSH
79763: LD_INT 25
79765: PUSH
79766: LD_INT 12
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PPUSH
79773: CALL_OW 72
79777: NOT
79778: OR
79779: IFFALSE 79783
// continue ;
79781: GO 79737
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
79783: LD_ADDR_VAR 0 5
79787: PUSH
79788: LD_EXP 92
79792: PUSH
79793: LD_VAR 0 2
79797: ARRAY
79798: PUSH
79799: LD_INT 1
79801: ARRAY
79802: PPUSH
79803: CALL_OW 255
79807: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
79808: LD_VAR 0 5
79812: PPUSH
79813: LD_INT 2
79815: PPUSH
79816: CALL_OW 325
79820: IFFALSE 80073
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79822: LD_ADDR_VAR 0 4
79826: PUSH
79827: LD_EXP 92
79831: PUSH
79832: LD_VAR 0 2
79836: ARRAY
79837: PPUSH
79838: LD_INT 25
79840: PUSH
79841: LD_INT 16
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PPUSH
79848: CALL_OW 72
79852: ST_TO_ADDR
// if tmp < 6 then
79853: LD_VAR 0 4
79857: PUSH
79858: LD_INT 6
79860: LESS
79861: IFFALSE 80073
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79863: LD_ADDR_VAR 0 6
79867: PUSH
79868: LD_EXP 63
79872: PUSH
79873: LD_VAR 0 2
79877: ARRAY
79878: PPUSH
79879: LD_INT 2
79881: PUSH
79882: LD_INT 30
79884: PUSH
79885: LD_INT 0
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 30
79894: PUSH
79895: LD_INT 1
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: LIST
79906: PPUSH
79907: CALL_OW 72
79911: ST_TO_ADDR
// if depot then
79912: LD_VAR 0 6
79916: IFFALSE 80073
// begin selected := 0 ;
79918: LD_ADDR_VAR 0 7
79922: PUSH
79923: LD_INT 0
79925: ST_TO_ADDR
// for j in depot do
79926: LD_ADDR_VAR 0 3
79930: PUSH
79931: LD_VAR 0 6
79935: PUSH
79936: FOR_IN
79937: IFFALSE 79968
// begin if UnitsInside ( j ) < 6 then
79939: LD_VAR 0 3
79943: PPUSH
79944: CALL_OW 313
79948: PUSH
79949: LD_INT 6
79951: LESS
79952: IFFALSE 79966
// begin selected := j ;
79954: LD_ADDR_VAR 0 7
79958: PUSH
79959: LD_VAR 0 3
79963: ST_TO_ADDR
// break ;
79964: GO 79968
// end ; end ;
79966: GO 79936
79968: POP
79969: POP
// if selected then
79970: LD_VAR 0 7
79974: IFFALSE 80073
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
79976: LD_ADDR_VAR 0 3
79980: PUSH
79981: LD_EXP 92
79985: PUSH
79986: LD_VAR 0 2
79990: ARRAY
79991: PPUSH
79992: LD_INT 25
79994: PUSH
79995: LD_INT 12
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PPUSH
80002: CALL_OW 72
80006: PUSH
80007: FOR_IN
80008: IFFALSE 80071
// if not HasTask ( j ) then
80010: LD_VAR 0 3
80014: PPUSH
80015: CALL_OW 314
80019: NOT
80020: IFFALSE 80069
// begin if not IsInUnit ( j ) then
80022: LD_VAR 0 3
80026: PPUSH
80027: CALL_OW 310
80031: NOT
80032: IFFALSE 80048
// ComEnterUnit ( j , selected ) ;
80034: LD_VAR 0 3
80038: PPUSH
80039: LD_VAR 0 7
80043: PPUSH
80044: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
80048: LD_VAR 0 3
80052: PPUSH
80053: LD_INT 16
80055: PPUSH
80056: CALL_OW 183
// AddComExitBuilding ( j ) ;
80060: LD_VAR 0 3
80064: PPUSH
80065: CALL_OW 182
// end ;
80069: GO 80007
80071: POP
80072: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
80073: LD_VAR 0 5
80077: PPUSH
80078: LD_INT 11
80080: PPUSH
80081: CALL_OW 325
80085: IFFALSE 80344
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80087: LD_ADDR_VAR 0 4
80091: PUSH
80092: LD_EXP 92
80096: PUSH
80097: LD_VAR 0 2
80101: ARRAY
80102: PPUSH
80103: LD_INT 25
80105: PUSH
80106: LD_INT 16
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PPUSH
80113: CALL_OW 72
80117: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
80118: LD_VAR 0 4
80122: PUSH
80123: LD_INT 6
80125: GREATEREQUAL
80126: PUSH
80127: LD_VAR 0 5
80131: PPUSH
80132: LD_INT 2
80134: PPUSH
80135: CALL_OW 325
80139: NOT
80140: OR
80141: IFFALSE 80344
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80143: LD_ADDR_VAR 0 8
80147: PUSH
80148: LD_EXP 63
80152: PUSH
80153: LD_VAR 0 2
80157: ARRAY
80158: PPUSH
80159: LD_INT 2
80161: PUSH
80162: LD_INT 30
80164: PUSH
80165: LD_INT 4
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 30
80174: PUSH
80175: LD_INT 5
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: LIST
80186: PPUSH
80187: CALL_OW 72
80191: ST_TO_ADDR
// if barracks then
80192: LD_VAR 0 8
80196: IFFALSE 80344
// begin selected := 0 ;
80198: LD_ADDR_VAR 0 7
80202: PUSH
80203: LD_INT 0
80205: ST_TO_ADDR
// for j in barracks do
80206: LD_ADDR_VAR 0 3
80210: PUSH
80211: LD_VAR 0 8
80215: PUSH
80216: FOR_IN
80217: IFFALSE 80248
// begin if UnitsInside ( j ) < 6 then
80219: LD_VAR 0 3
80223: PPUSH
80224: CALL_OW 313
80228: PUSH
80229: LD_INT 6
80231: LESS
80232: IFFALSE 80246
// begin selected := j ;
80234: LD_ADDR_VAR 0 7
80238: PUSH
80239: LD_VAR 0 3
80243: ST_TO_ADDR
// break ;
80244: GO 80248
// end ; end ;
80246: GO 80216
80248: POP
80249: POP
// if selected then
80250: LD_VAR 0 7
80254: IFFALSE 80344
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80256: LD_ADDR_VAR 0 3
80260: PUSH
80261: LD_EXP 92
80265: PUSH
80266: LD_VAR 0 2
80270: ARRAY
80271: PPUSH
80272: LD_INT 25
80274: PUSH
80275: LD_INT 12
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PPUSH
80282: CALL_OW 72
80286: PUSH
80287: FOR_IN
80288: IFFALSE 80342
// if not IsInUnit ( j ) and not HasTask ( j ) then
80290: LD_VAR 0 3
80294: PPUSH
80295: CALL_OW 310
80299: NOT
80300: PUSH
80301: LD_VAR 0 3
80305: PPUSH
80306: CALL_OW 314
80310: NOT
80311: AND
80312: IFFALSE 80340
// begin ComEnterUnit ( j , selected ) ;
80314: LD_VAR 0 3
80318: PPUSH
80319: LD_VAR 0 7
80323: PPUSH
80324: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
80328: LD_VAR 0 3
80332: PPUSH
80333: LD_INT 15
80335: PPUSH
80336: CALL_OW 183
// end ;
80340: GO 80287
80342: POP
80343: POP
// end ; end ; end ; end ; end ;
80344: GO 79737
80346: POP
80347: POP
// end ;
80348: LD_VAR 0 1
80352: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
80353: LD_INT 0
80355: PPUSH
80356: PPUSH
80357: PPUSH
80358: PPUSH
// if not mc_bases then
80359: LD_EXP 63
80363: NOT
80364: IFFALSE 80368
// exit ;
80366: GO 80546
// for i = 1 to mc_bases do
80368: LD_ADDR_VAR 0 2
80372: PUSH
80373: DOUBLE
80374: LD_INT 1
80376: DEC
80377: ST_TO_ADDR
80378: LD_EXP 63
80382: PUSH
80383: FOR_TO
80384: IFFALSE 80544
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
80386: LD_ADDR_VAR 0 4
80390: PUSH
80391: LD_EXP 63
80395: PUSH
80396: LD_VAR 0 2
80400: ARRAY
80401: PPUSH
80402: LD_INT 25
80404: PUSH
80405: LD_INT 9
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PPUSH
80412: CALL_OW 72
80416: ST_TO_ADDR
// if not tmp then
80417: LD_VAR 0 4
80421: NOT
80422: IFFALSE 80426
// continue ;
80424: GO 80383
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
80426: LD_EXP 89
80430: PUSH
80431: LD_VAR 0 2
80435: ARRAY
80436: PPUSH
80437: LD_INT 29
80439: PPUSH
80440: CALL_OW 325
80444: NOT
80445: PUSH
80446: LD_EXP 89
80450: PUSH
80451: LD_VAR 0 2
80455: ARRAY
80456: PPUSH
80457: LD_INT 28
80459: PPUSH
80460: CALL_OW 325
80464: NOT
80465: AND
80466: IFFALSE 80470
// continue ;
80468: GO 80383
// for j in tmp do
80470: LD_ADDR_VAR 0 3
80474: PUSH
80475: LD_VAR 0 4
80479: PUSH
80480: FOR_IN
80481: IFFALSE 80540
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80483: LD_VAR 0 3
80487: PUSH
80488: LD_EXP 66
80492: PUSH
80493: LD_VAR 0 2
80497: ARRAY
80498: PUSH
80499: LD_INT 1
80501: ARRAY
80502: IN
80503: NOT
80504: PUSH
80505: LD_VAR 0 3
80509: PUSH
80510: LD_EXP 66
80514: PUSH
80515: LD_VAR 0 2
80519: ARRAY
80520: PUSH
80521: LD_INT 2
80523: ARRAY
80524: IN
80525: NOT
80526: AND
80527: IFFALSE 80538
// ComSpaceTimeShoot ( j ) ;
80529: LD_VAR 0 3
80533: PPUSH
80534: CALL 18244 0 1
80538: GO 80480
80540: POP
80541: POP
// end ;
80542: GO 80383
80544: POP
80545: POP
// end ;
80546: LD_VAR 0 1
80550: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
80551: LD_INT 0
80553: PPUSH
80554: PPUSH
80555: PPUSH
80556: PPUSH
80557: PPUSH
80558: PPUSH
80559: PPUSH
80560: PPUSH
80561: PPUSH
// if not mc_bases then
80562: LD_EXP 63
80566: NOT
80567: IFFALSE 80571
// exit ;
80569: GO 81193
// for i = 1 to mc_bases do
80571: LD_ADDR_VAR 0 2
80575: PUSH
80576: DOUBLE
80577: LD_INT 1
80579: DEC
80580: ST_TO_ADDR
80581: LD_EXP 63
80585: PUSH
80586: FOR_TO
80587: IFFALSE 81191
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
80589: LD_EXP 98
80593: PUSH
80594: LD_VAR 0 2
80598: ARRAY
80599: NOT
80600: PUSH
80601: LD_INT 38
80603: PPUSH
80604: LD_EXP 89
80608: PUSH
80609: LD_VAR 0 2
80613: ARRAY
80614: PPUSH
80615: CALL_OW 321
80619: PUSH
80620: LD_INT 2
80622: NONEQUAL
80623: OR
80624: IFFALSE 80628
// continue ;
80626: GO 80586
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
80628: LD_ADDR_VAR 0 8
80632: PUSH
80633: LD_EXP 63
80637: PUSH
80638: LD_VAR 0 2
80642: ARRAY
80643: PPUSH
80644: LD_INT 30
80646: PUSH
80647: LD_INT 34
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PPUSH
80654: CALL_OW 72
80658: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
80659: LD_ADDR_VAR 0 9
80663: PUSH
80664: LD_EXP 63
80668: PUSH
80669: LD_VAR 0 2
80673: ARRAY
80674: PPUSH
80675: LD_INT 25
80677: PUSH
80678: LD_INT 4
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PPUSH
80685: CALL_OW 72
80689: PPUSH
80690: LD_INT 0
80692: PPUSH
80693: CALL 52577 0 2
80697: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
80698: LD_VAR 0 9
80702: NOT
80703: PUSH
80704: LD_VAR 0 8
80708: NOT
80709: OR
80710: PUSH
80711: LD_EXP 63
80715: PUSH
80716: LD_VAR 0 2
80720: ARRAY
80721: PPUSH
80722: LD_INT 124
80724: PPUSH
80725: CALL 52577 0 2
80729: OR
80730: IFFALSE 80734
// continue ;
80732: GO 80586
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
80734: LD_EXP 99
80738: PUSH
80739: LD_VAR 0 2
80743: ARRAY
80744: PUSH
80745: LD_EXP 98
80749: PUSH
80750: LD_VAR 0 2
80754: ARRAY
80755: LESS
80756: PUSH
80757: LD_EXP 99
80761: PUSH
80762: LD_VAR 0 2
80766: ARRAY
80767: PUSH
80768: LD_VAR 0 8
80772: LESS
80773: AND
80774: IFFALSE 81189
// begin tmp := sci [ 1 ] ;
80776: LD_ADDR_VAR 0 7
80780: PUSH
80781: LD_VAR 0 9
80785: PUSH
80786: LD_INT 1
80788: ARRAY
80789: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
80790: LD_VAR 0 7
80794: PPUSH
80795: LD_INT 124
80797: PPUSH
80798: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
80802: LD_ADDR_VAR 0 3
80806: PUSH
80807: DOUBLE
80808: LD_EXP 98
80812: PUSH
80813: LD_VAR 0 2
80817: ARRAY
80818: INC
80819: ST_TO_ADDR
80820: LD_EXP 98
80824: PUSH
80825: LD_VAR 0 2
80829: ARRAY
80830: PUSH
80831: FOR_DOWNTO
80832: IFFALSE 81175
// begin if IsInUnit ( tmp ) then
80834: LD_VAR 0 7
80838: PPUSH
80839: CALL_OW 310
80843: IFFALSE 80854
// ComExitBuilding ( tmp ) ;
80845: LD_VAR 0 7
80849: PPUSH
80850: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
80854: LD_INT 35
80856: PPUSH
80857: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
80861: LD_VAR 0 7
80865: PPUSH
80866: CALL_OW 310
80870: NOT
80871: PUSH
80872: LD_VAR 0 7
80876: PPUSH
80877: CALL_OW 314
80881: NOT
80882: AND
80883: IFFALSE 80854
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80885: LD_ADDR_VAR 0 6
80889: PUSH
80890: LD_VAR 0 7
80894: PPUSH
80895: CALL_OW 250
80899: PUSH
80900: LD_VAR 0 7
80904: PPUSH
80905: CALL_OW 251
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80914: LD_INT 35
80916: PPUSH
80917: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80921: LD_ADDR_VAR 0 4
80925: PUSH
80926: LD_EXP 98
80930: PUSH
80931: LD_VAR 0 2
80935: ARRAY
80936: PUSH
80937: LD_VAR 0 3
80941: ARRAY
80942: PUSH
80943: LD_INT 1
80945: ARRAY
80946: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
80947: LD_ADDR_VAR 0 5
80951: PUSH
80952: LD_EXP 98
80956: PUSH
80957: LD_VAR 0 2
80961: ARRAY
80962: PUSH
80963: LD_VAR 0 3
80967: ARRAY
80968: PUSH
80969: LD_INT 2
80971: ARRAY
80972: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
80973: LD_VAR 0 7
80977: PPUSH
80978: LD_INT 10
80980: PPUSH
80981: CALL 25224 0 2
80985: PUSH
80986: LD_INT 4
80988: ARRAY
80989: IFFALSE 81027
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
80991: LD_VAR 0 7
80995: PPUSH
80996: LD_VAR 0 6
81000: PUSH
81001: LD_INT 1
81003: ARRAY
81004: PPUSH
81005: LD_VAR 0 6
81009: PUSH
81010: LD_INT 2
81012: ARRAY
81013: PPUSH
81014: CALL_OW 111
// wait ( 0 0$10 ) ;
81018: LD_INT 350
81020: PPUSH
81021: CALL_OW 67
// end else
81025: GO 81053
// begin ComMoveXY ( tmp , x , y ) ;
81027: LD_VAR 0 7
81031: PPUSH
81032: LD_VAR 0 4
81036: PPUSH
81037: LD_VAR 0 5
81041: PPUSH
81042: CALL_OW 111
// wait ( 0 0$3 ) ;
81046: LD_INT 105
81048: PPUSH
81049: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
81053: LD_VAR 0 7
81057: PPUSH
81058: LD_VAR 0 4
81062: PPUSH
81063: LD_VAR 0 5
81067: PPUSH
81068: CALL_OW 307
81072: IFFALSE 80914
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
81074: LD_VAR 0 7
81078: PPUSH
81079: LD_VAR 0 4
81083: PPUSH
81084: LD_VAR 0 5
81088: PPUSH
81089: LD_VAR 0 8
81093: PUSH
81094: LD_VAR 0 3
81098: ARRAY
81099: PPUSH
81100: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
81104: LD_INT 35
81106: PPUSH
81107: CALL_OW 67
// until not HasTask ( tmp ) ;
81111: LD_VAR 0 7
81115: PPUSH
81116: CALL_OW 314
81120: NOT
81121: IFFALSE 81104
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
81123: LD_ADDR_EXP 99
81127: PUSH
81128: LD_EXP 99
81132: PPUSH
81133: LD_VAR 0 2
81137: PUSH
81138: LD_EXP 99
81142: PUSH
81143: LD_VAR 0 2
81147: ARRAY
81148: PUSH
81149: LD_INT 1
81151: PLUS
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PPUSH
81157: LD_VAR 0 8
81161: PUSH
81162: LD_VAR 0 3
81166: ARRAY
81167: PPUSH
81168: CALL 22259 0 3
81172: ST_TO_ADDR
// end ;
81173: GO 80831
81175: POP
81176: POP
// MC_Reset ( i , 124 ) ;
81177: LD_VAR 0 2
81181: PPUSH
81182: LD_INT 124
81184: PPUSH
81185: CALL 64261 0 2
// end ; end ;
81189: GO 80586
81191: POP
81192: POP
// end ;
81193: LD_VAR 0 1
81197: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
81198: LD_INT 0
81200: PPUSH
81201: PPUSH
81202: PPUSH
// if not mc_bases then
81203: LD_EXP 63
81207: NOT
81208: IFFALSE 81212
// exit ;
81210: GO 81818
// for i = 1 to mc_bases do
81212: LD_ADDR_VAR 0 2
81216: PUSH
81217: DOUBLE
81218: LD_INT 1
81220: DEC
81221: ST_TO_ADDR
81222: LD_EXP 63
81226: PUSH
81227: FOR_TO
81228: IFFALSE 81816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
81230: LD_ADDR_VAR 0 3
81234: PUSH
81235: LD_EXP 63
81239: PUSH
81240: LD_VAR 0 2
81244: ARRAY
81245: PPUSH
81246: LD_INT 25
81248: PUSH
81249: LD_INT 4
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PPUSH
81256: CALL_OW 72
81260: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81261: LD_VAR 0 3
81265: NOT
81266: PUSH
81267: LD_EXP 100
81271: PUSH
81272: LD_VAR 0 2
81276: ARRAY
81277: NOT
81278: OR
81279: PUSH
81280: LD_EXP 63
81284: PUSH
81285: LD_VAR 0 2
81289: ARRAY
81290: PPUSH
81291: LD_INT 2
81293: PUSH
81294: LD_INT 30
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 30
81306: PUSH
81307: LD_INT 1
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: LIST
81318: PPUSH
81319: CALL_OW 72
81323: NOT
81324: OR
81325: IFFALSE 81375
// begin if mc_deposits_finder [ i ] then
81327: LD_EXP 101
81331: PUSH
81332: LD_VAR 0 2
81336: ARRAY
81337: IFFALSE 81373
// begin MC_Reset ( i , 125 ) ;
81339: LD_VAR 0 2
81343: PPUSH
81344: LD_INT 125
81346: PPUSH
81347: CALL 64261 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81351: LD_ADDR_EXP 101
81355: PUSH
81356: LD_EXP 101
81360: PPUSH
81361: LD_VAR 0 2
81365: PPUSH
81366: EMPTY
81367: PPUSH
81368: CALL_OW 1
81372: ST_TO_ADDR
// end ; continue ;
81373: GO 81227
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
81375: LD_EXP 100
81379: PUSH
81380: LD_VAR 0 2
81384: ARRAY
81385: PUSH
81386: LD_INT 1
81388: ARRAY
81389: PUSH
81390: LD_INT 3
81392: ARRAY
81393: PUSH
81394: LD_INT 1
81396: EQUAL
81397: PUSH
81398: LD_INT 20
81400: PPUSH
81401: LD_EXP 89
81405: PUSH
81406: LD_VAR 0 2
81410: ARRAY
81411: PPUSH
81412: CALL_OW 321
81416: PUSH
81417: LD_INT 2
81419: NONEQUAL
81420: AND
81421: IFFALSE 81471
// begin if mc_deposits_finder [ i ] then
81423: LD_EXP 101
81427: PUSH
81428: LD_VAR 0 2
81432: ARRAY
81433: IFFALSE 81469
// begin MC_Reset ( i , 125 ) ;
81435: LD_VAR 0 2
81439: PPUSH
81440: LD_INT 125
81442: PPUSH
81443: CALL 64261 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81447: LD_ADDR_EXP 101
81451: PUSH
81452: LD_EXP 101
81456: PPUSH
81457: LD_VAR 0 2
81461: PPUSH
81462: EMPTY
81463: PPUSH
81464: CALL_OW 1
81468: ST_TO_ADDR
// end ; continue ;
81469: GO 81227
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
81471: LD_EXP 100
81475: PUSH
81476: LD_VAR 0 2
81480: ARRAY
81481: PUSH
81482: LD_INT 1
81484: ARRAY
81485: PUSH
81486: LD_INT 1
81488: ARRAY
81489: PPUSH
81490: LD_EXP 100
81494: PUSH
81495: LD_VAR 0 2
81499: ARRAY
81500: PUSH
81501: LD_INT 1
81503: ARRAY
81504: PUSH
81505: LD_INT 2
81507: ARRAY
81508: PPUSH
81509: LD_EXP 89
81513: PUSH
81514: LD_VAR 0 2
81518: ARRAY
81519: PPUSH
81520: CALL_OW 440
81524: IFFALSE 81567
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
81526: LD_ADDR_EXP 100
81530: PUSH
81531: LD_EXP 100
81535: PPUSH
81536: LD_VAR 0 2
81540: PPUSH
81541: LD_EXP 100
81545: PUSH
81546: LD_VAR 0 2
81550: ARRAY
81551: PPUSH
81552: LD_INT 1
81554: PPUSH
81555: CALL_OW 3
81559: PPUSH
81560: CALL_OW 1
81564: ST_TO_ADDR
81565: GO 81814
// begin if not mc_deposits_finder [ i ] then
81567: LD_EXP 101
81571: PUSH
81572: LD_VAR 0 2
81576: ARRAY
81577: NOT
81578: IFFALSE 81630
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
81580: LD_ADDR_EXP 101
81584: PUSH
81585: LD_EXP 101
81589: PPUSH
81590: LD_VAR 0 2
81594: PPUSH
81595: LD_VAR 0 3
81599: PUSH
81600: LD_INT 1
81602: ARRAY
81603: PUSH
81604: EMPTY
81605: LIST
81606: PPUSH
81607: CALL_OW 1
81611: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
81612: LD_VAR 0 3
81616: PUSH
81617: LD_INT 1
81619: ARRAY
81620: PPUSH
81621: LD_INT 125
81623: PPUSH
81624: CALL_OW 109
// end else
81628: GO 81814
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
81630: LD_EXP 101
81634: PUSH
81635: LD_VAR 0 2
81639: ARRAY
81640: PUSH
81641: LD_INT 1
81643: ARRAY
81644: PPUSH
81645: CALL_OW 310
81649: IFFALSE 81672
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
81651: LD_EXP 101
81655: PUSH
81656: LD_VAR 0 2
81660: ARRAY
81661: PUSH
81662: LD_INT 1
81664: ARRAY
81665: PPUSH
81666: CALL_OW 122
81670: GO 81814
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
81672: LD_EXP 101
81676: PUSH
81677: LD_VAR 0 2
81681: ARRAY
81682: PUSH
81683: LD_INT 1
81685: ARRAY
81686: PPUSH
81687: CALL_OW 314
81691: NOT
81692: PUSH
81693: LD_EXP 101
81697: PUSH
81698: LD_VAR 0 2
81702: ARRAY
81703: PUSH
81704: LD_INT 1
81706: ARRAY
81707: PPUSH
81708: LD_EXP 100
81712: PUSH
81713: LD_VAR 0 2
81717: ARRAY
81718: PUSH
81719: LD_INT 1
81721: ARRAY
81722: PUSH
81723: LD_INT 1
81725: ARRAY
81726: PPUSH
81727: LD_EXP 100
81731: PUSH
81732: LD_VAR 0 2
81736: ARRAY
81737: PUSH
81738: LD_INT 1
81740: ARRAY
81741: PUSH
81742: LD_INT 2
81744: ARRAY
81745: PPUSH
81746: CALL_OW 297
81750: PUSH
81751: LD_INT 6
81753: GREATER
81754: AND
81755: IFFALSE 81814
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
81757: LD_EXP 101
81761: PUSH
81762: LD_VAR 0 2
81766: ARRAY
81767: PUSH
81768: LD_INT 1
81770: ARRAY
81771: PPUSH
81772: LD_EXP 100
81776: PUSH
81777: LD_VAR 0 2
81781: ARRAY
81782: PUSH
81783: LD_INT 1
81785: ARRAY
81786: PUSH
81787: LD_INT 1
81789: ARRAY
81790: PPUSH
81791: LD_EXP 100
81795: PUSH
81796: LD_VAR 0 2
81800: ARRAY
81801: PUSH
81802: LD_INT 1
81804: ARRAY
81805: PUSH
81806: LD_INT 2
81808: ARRAY
81809: PPUSH
81810: CALL_OW 111
// end ; end ; end ;
81814: GO 81227
81816: POP
81817: POP
// end ;
81818: LD_VAR 0 1
81822: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
81823: LD_INT 0
81825: PPUSH
81826: PPUSH
81827: PPUSH
81828: PPUSH
81829: PPUSH
81830: PPUSH
81831: PPUSH
81832: PPUSH
81833: PPUSH
81834: PPUSH
81835: PPUSH
// if not mc_bases then
81836: LD_EXP 63
81840: NOT
81841: IFFALSE 81845
// exit ;
81843: GO 82785
// for i = 1 to mc_bases do
81845: LD_ADDR_VAR 0 2
81849: PUSH
81850: DOUBLE
81851: LD_INT 1
81853: DEC
81854: ST_TO_ADDR
81855: LD_EXP 63
81859: PUSH
81860: FOR_TO
81861: IFFALSE 82783
// begin if not mc_bases [ i ] or mc_scan [ i ] then
81863: LD_EXP 63
81867: PUSH
81868: LD_VAR 0 2
81872: ARRAY
81873: NOT
81874: PUSH
81875: LD_EXP 86
81879: PUSH
81880: LD_VAR 0 2
81884: ARRAY
81885: OR
81886: IFFALSE 81890
// continue ;
81888: GO 81860
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81890: LD_ADDR_VAR 0 7
81894: PUSH
81895: LD_EXP 63
81899: PUSH
81900: LD_VAR 0 2
81904: ARRAY
81905: PUSH
81906: LD_INT 1
81908: ARRAY
81909: PPUSH
81910: CALL_OW 248
81914: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81915: LD_VAR 0 7
81919: PUSH
81920: LD_INT 3
81922: EQUAL
81923: PUSH
81924: LD_EXP 82
81928: PUSH
81929: LD_VAR 0 2
81933: ARRAY
81934: PUSH
81935: LD_EXP 85
81939: PUSH
81940: LD_VAR 0 2
81944: ARRAY
81945: UNION
81946: PPUSH
81947: LD_INT 33
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PPUSH
81957: CALL_OW 72
81961: NOT
81962: OR
81963: IFFALSE 81967
// continue ;
81965: GO 81860
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
81967: LD_ADDR_VAR 0 9
81971: PUSH
81972: LD_EXP 63
81976: PUSH
81977: LD_VAR 0 2
81981: ARRAY
81982: PPUSH
81983: LD_INT 30
81985: PUSH
81986: LD_INT 36
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PPUSH
81993: CALL_OW 72
81997: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
81998: LD_ADDR_VAR 0 10
82002: PUSH
82003: LD_EXP 82
82007: PUSH
82008: LD_VAR 0 2
82012: ARRAY
82013: PPUSH
82014: LD_INT 34
82016: PUSH
82017: LD_INT 31
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PPUSH
82024: CALL_OW 72
82028: ST_TO_ADDR
// if not cts and not mcts then
82029: LD_VAR 0 9
82033: NOT
82034: PUSH
82035: LD_VAR 0 10
82039: NOT
82040: AND
82041: IFFALSE 82045
// continue ;
82043: GO 81860
// x := cts ;
82045: LD_ADDR_VAR 0 11
82049: PUSH
82050: LD_VAR 0 9
82054: ST_TO_ADDR
// if not x then
82055: LD_VAR 0 11
82059: NOT
82060: IFFALSE 82072
// x := mcts ;
82062: LD_ADDR_VAR 0 11
82066: PUSH
82067: LD_VAR 0 10
82071: ST_TO_ADDR
// if not x then
82072: LD_VAR 0 11
82076: NOT
82077: IFFALSE 82081
// continue ;
82079: GO 81860
// if mc_remote_driver [ i ] then
82081: LD_EXP 103
82085: PUSH
82086: LD_VAR 0 2
82090: ARRAY
82091: IFFALSE 82478
// for j in mc_remote_driver [ i ] do
82093: LD_ADDR_VAR 0 3
82097: PUSH
82098: LD_EXP 103
82102: PUSH
82103: LD_VAR 0 2
82107: ARRAY
82108: PUSH
82109: FOR_IN
82110: IFFALSE 82476
// begin if GetClass ( j ) <> 3 then
82112: LD_VAR 0 3
82116: PPUSH
82117: CALL_OW 257
82121: PUSH
82122: LD_INT 3
82124: NONEQUAL
82125: IFFALSE 82178
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
82127: LD_ADDR_EXP 103
82131: PUSH
82132: LD_EXP 103
82136: PPUSH
82137: LD_VAR 0 2
82141: PPUSH
82142: LD_EXP 103
82146: PUSH
82147: LD_VAR 0 2
82151: ARRAY
82152: PUSH
82153: LD_VAR 0 3
82157: DIFF
82158: PPUSH
82159: CALL_OW 1
82163: ST_TO_ADDR
// SetTag ( j , 0 ) ;
82164: LD_VAR 0 3
82168: PPUSH
82169: LD_INT 0
82171: PPUSH
82172: CALL_OW 109
// continue ;
82176: GO 82109
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
82178: LD_EXP 82
82182: PUSH
82183: LD_VAR 0 2
82187: ARRAY
82188: PPUSH
82189: LD_INT 34
82191: PUSH
82192: LD_INT 31
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 58
82201: PUSH
82202: EMPTY
82203: LIST
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PPUSH
82209: CALL_OW 72
82213: PUSH
82214: LD_VAR 0 3
82218: PPUSH
82219: CALL 52612 0 1
82223: NOT
82224: AND
82225: IFFALSE 82296
// begin if IsInUnit ( j ) then
82227: LD_VAR 0 3
82231: PPUSH
82232: CALL_OW 310
82236: IFFALSE 82247
// ComExitBuilding ( j ) ;
82238: LD_VAR 0 3
82242: PPUSH
82243: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
82247: LD_VAR 0 3
82251: PPUSH
82252: LD_EXP 82
82256: PUSH
82257: LD_VAR 0 2
82261: ARRAY
82262: PPUSH
82263: LD_INT 34
82265: PUSH
82266: LD_INT 31
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 58
82275: PUSH
82276: EMPTY
82277: LIST
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PPUSH
82283: CALL_OW 72
82287: PUSH
82288: LD_INT 1
82290: ARRAY
82291: PPUSH
82292: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
82296: LD_VAR 0 3
82300: PPUSH
82301: CALL_OW 310
82305: NOT
82306: PUSH
82307: LD_VAR 0 3
82311: PPUSH
82312: CALL_OW 310
82316: PPUSH
82317: CALL_OW 266
82321: PUSH
82322: LD_INT 36
82324: NONEQUAL
82325: PUSH
82326: LD_VAR 0 3
82330: PPUSH
82331: CALL 52612 0 1
82335: NOT
82336: AND
82337: OR
82338: IFFALSE 82474
// begin if IsInUnit ( j ) then
82340: LD_VAR 0 3
82344: PPUSH
82345: CALL_OW 310
82349: IFFALSE 82360
// ComExitBuilding ( j ) ;
82351: LD_VAR 0 3
82355: PPUSH
82356: CALL_OW 122
// ct := 0 ;
82360: LD_ADDR_VAR 0 8
82364: PUSH
82365: LD_INT 0
82367: ST_TO_ADDR
// for k in x do
82368: LD_ADDR_VAR 0 4
82372: PUSH
82373: LD_VAR 0 11
82377: PUSH
82378: FOR_IN
82379: IFFALSE 82452
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
82381: LD_VAR 0 4
82385: PPUSH
82386: CALL_OW 264
82390: PUSH
82391: LD_INT 31
82393: EQUAL
82394: PUSH
82395: LD_VAR 0 4
82399: PPUSH
82400: CALL_OW 311
82404: NOT
82405: AND
82406: PUSH
82407: LD_VAR 0 4
82411: PPUSH
82412: CALL_OW 266
82416: PUSH
82417: LD_INT 36
82419: EQUAL
82420: PUSH
82421: LD_VAR 0 4
82425: PPUSH
82426: CALL_OW 313
82430: PUSH
82431: LD_INT 3
82433: LESS
82434: AND
82435: OR
82436: IFFALSE 82450
// begin ct := k ;
82438: LD_ADDR_VAR 0 8
82442: PUSH
82443: LD_VAR 0 4
82447: ST_TO_ADDR
// break ;
82448: GO 82452
// end ;
82450: GO 82378
82452: POP
82453: POP
// if ct then
82454: LD_VAR 0 8
82458: IFFALSE 82474
// ComEnterUnit ( j , ct ) ;
82460: LD_VAR 0 3
82464: PPUSH
82465: LD_VAR 0 8
82469: PPUSH
82470: CALL_OW 120
// end ; end ;
82474: GO 82109
82476: POP
82477: POP
// places := 0 ;
82478: LD_ADDR_VAR 0 5
82482: PUSH
82483: LD_INT 0
82485: ST_TO_ADDR
// for j = 1 to x do
82486: LD_ADDR_VAR 0 3
82490: PUSH
82491: DOUBLE
82492: LD_INT 1
82494: DEC
82495: ST_TO_ADDR
82496: LD_VAR 0 11
82500: PUSH
82501: FOR_TO
82502: IFFALSE 82578
// if GetWeapon ( x [ j ] ) = ar_control_tower then
82504: LD_VAR 0 11
82508: PUSH
82509: LD_VAR 0 3
82513: ARRAY
82514: PPUSH
82515: CALL_OW 264
82519: PUSH
82520: LD_INT 31
82522: EQUAL
82523: IFFALSE 82541
// places := places + 1 else
82525: LD_ADDR_VAR 0 5
82529: PUSH
82530: LD_VAR 0 5
82534: PUSH
82535: LD_INT 1
82537: PLUS
82538: ST_TO_ADDR
82539: GO 82576
// if GetBType ( x [ j ] ) = b_control_tower then
82541: LD_VAR 0 11
82545: PUSH
82546: LD_VAR 0 3
82550: ARRAY
82551: PPUSH
82552: CALL_OW 266
82556: PUSH
82557: LD_INT 36
82559: EQUAL
82560: IFFALSE 82576
// places := places + 3 ;
82562: LD_ADDR_VAR 0 5
82566: PUSH
82567: LD_VAR 0 5
82571: PUSH
82572: LD_INT 3
82574: PLUS
82575: ST_TO_ADDR
82576: GO 82501
82578: POP
82579: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
82580: LD_VAR 0 5
82584: PUSH
82585: LD_INT 0
82587: EQUAL
82588: PUSH
82589: LD_VAR 0 5
82593: PUSH
82594: LD_EXP 103
82598: PUSH
82599: LD_VAR 0 2
82603: ARRAY
82604: LESSEQUAL
82605: OR
82606: IFFALSE 82610
// continue ;
82608: GO 81860
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
82610: LD_ADDR_VAR 0 6
82614: PUSH
82615: LD_EXP 63
82619: PUSH
82620: LD_VAR 0 2
82624: ARRAY
82625: PPUSH
82626: LD_INT 25
82628: PUSH
82629: LD_INT 3
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PPUSH
82636: CALL_OW 72
82640: PUSH
82641: LD_EXP 103
82645: PUSH
82646: LD_VAR 0 2
82650: ARRAY
82651: DIFF
82652: PPUSH
82653: LD_INT 3
82655: PPUSH
82656: CALL 53512 0 2
82660: ST_TO_ADDR
// for j in tmp do
82661: LD_ADDR_VAR 0 3
82665: PUSH
82666: LD_VAR 0 6
82670: PUSH
82671: FOR_IN
82672: IFFALSE 82707
// if GetTag ( j ) > 0 then
82674: LD_VAR 0 3
82678: PPUSH
82679: CALL_OW 110
82683: PUSH
82684: LD_INT 0
82686: GREATER
82687: IFFALSE 82705
// tmp := tmp diff j ;
82689: LD_ADDR_VAR 0 6
82693: PUSH
82694: LD_VAR 0 6
82698: PUSH
82699: LD_VAR 0 3
82703: DIFF
82704: ST_TO_ADDR
82705: GO 82671
82707: POP
82708: POP
// if not tmp then
82709: LD_VAR 0 6
82713: NOT
82714: IFFALSE 82718
// continue ;
82716: GO 81860
// if places then
82718: LD_VAR 0 5
82722: IFFALSE 82781
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
82724: LD_ADDR_EXP 103
82728: PUSH
82729: LD_EXP 103
82733: PPUSH
82734: LD_VAR 0 2
82738: PPUSH
82739: LD_EXP 103
82743: PUSH
82744: LD_VAR 0 2
82748: ARRAY
82749: PUSH
82750: LD_VAR 0 6
82754: PUSH
82755: LD_INT 1
82757: ARRAY
82758: UNION
82759: PPUSH
82760: CALL_OW 1
82764: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
82765: LD_VAR 0 6
82769: PUSH
82770: LD_INT 1
82772: ARRAY
82773: PPUSH
82774: LD_INT 126
82776: PPUSH
82777: CALL_OW 109
// end ; end ;
82781: GO 81860
82783: POP
82784: POP
// end ;
82785: LD_VAR 0 1
82789: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
82790: LD_INT 0
82792: PPUSH
82793: PPUSH
82794: PPUSH
82795: PPUSH
82796: PPUSH
82797: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
82798: LD_VAR 0 1
82802: NOT
82803: PUSH
82804: LD_VAR 0 2
82808: NOT
82809: OR
82810: PUSH
82811: LD_VAR 0 3
82815: NOT
82816: OR
82817: PUSH
82818: LD_VAR 0 4
82822: PUSH
82823: LD_INT 1
82825: PUSH
82826: LD_INT 2
82828: PUSH
82829: LD_INT 3
82831: PUSH
82832: LD_INT 4
82834: PUSH
82835: LD_INT 5
82837: PUSH
82838: LD_INT 8
82840: PUSH
82841: LD_INT 9
82843: PUSH
82844: LD_INT 15
82846: PUSH
82847: LD_INT 16
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: IN
82861: NOT
82862: OR
82863: IFFALSE 82867
// exit ;
82865: GO 83725
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
82867: LD_ADDR_VAR 0 2
82871: PUSH
82872: LD_VAR 0 2
82876: PPUSH
82877: LD_INT 21
82879: PUSH
82880: LD_INT 3
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 24
82889: PUSH
82890: LD_INT 250
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PPUSH
82901: CALL_OW 72
82905: ST_TO_ADDR
// case class of 1 , 15 :
82906: LD_VAR 0 4
82910: PUSH
82911: LD_INT 1
82913: DOUBLE
82914: EQUAL
82915: IFTRUE 82925
82917: LD_INT 15
82919: DOUBLE
82920: EQUAL
82921: IFTRUE 82925
82923: GO 83010
82925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82926: LD_ADDR_VAR 0 8
82930: PUSH
82931: LD_VAR 0 2
82935: PPUSH
82936: LD_INT 2
82938: PUSH
82939: LD_INT 30
82941: PUSH
82942: LD_INT 32
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 30
82951: PUSH
82952: LD_INT 31
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: LIST
82963: PPUSH
82964: CALL_OW 72
82968: PUSH
82969: LD_VAR 0 2
82973: PPUSH
82974: LD_INT 2
82976: PUSH
82977: LD_INT 30
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 30
82989: PUSH
82990: LD_INT 5
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: LIST
83001: PPUSH
83002: CALL_OW 72
83006: ADD
83007: ST_TO_ADDR
83008: GO 83256
83010: LD_INT 2
83012: DOUBLE
83013: EQUAL
83014: IFTRUE 83024
83016: LD_INT 16
83018: DOUBLE
83019: EQUAL
83020: IFTRUE 83024
83022: GO 83070
83024: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
83025: LD_ADDR_VAR 0 8
83029: PUSH
83030: LD_VAR 0 2
83034: PPUSH
83035: LD_INT 2
83037: PUSH
83038: LD_INT 30
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 30
83050: PUSH
83051: LD_INT 1
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: LIST
83062: PPUSH
83063: CALL_OW 72
83067: ST_TO_ADDR
83068: GO 83256
83070: LD_INT 3
83072: DOUBLE
83073: EQUAL
83074: IFTRUE 83078
83076: GO 83124
83078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
83079: LD_ADDR_VAR 0 8
83083: PUSH
83084: LD_VAR 0 2
83088: PPUSH
83089: LD_INT 2
83091: PUSH
83092: LD_INT 30
83094: PUSH
83095: LD_INT 2
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 30
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: LIST
83116: PPUSH
83117: CALL_OW 72
83121: ST_TO_ADDR
83122: GO 83256
83124: LD_INT 4
83126: DOUBLE
83127: EQUAL
83128: IFTRUE 83132
83130: GO 83189
83132: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
83133: LD_ADDR_VAR 0 8
83137: PUSH
83138: LD_VAR 0 2
83142: PPUSH
83143: LD_INT 2
83145: PUSH
83146: LD_INT 30
83148: PUSH
83149: LD_INT 6
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 30
83158: PUSH
83159: LD_INT 7
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 30
83168: PUSH
83169: LD_INT 8
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: PPUSH
83182: CALL_OW 72
83186: ST_TO_ADDR
83187: GO 83256
83189: LD_INT 5
83191: DOUBLE
83192: EQUAL
83193: IFTRUE 83209
83195: LD_INT 8
83197: DOUBLE
83198: EQUAL
83199: IFTRUE 83209
83201: LD_INT 9
83203: DOUBLE
83204: EQUAL
83205: IFTRUE 83209
83207: GO 83255
83209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
83210: LD_ADDR_VAR 0 8
83214: PUSH
83215: LD_VAR 0 2
83219: PPUSH
83220: LD_INT 2
83222: PUSH
83223: LD_INT 30
83225: PUSH
83226: LD_INT 4
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 30
83235: PUSH
83236: LD_INT 5
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: LIST
83247: PPUSH
83248: CALL_OW 72
83252: ST_TO_ADDR
83253: GO 83256
83255: POP
// if not tmp then
83256: LD_VAR 0 8
83260: NOT
83261: IFFALSE 83265
// exit ;
83263: GO 83725
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
83265: LD_VAR 0 4
83269: PUSH
83270: LD_INT 1
83272: PUSH
83273: LD_INT 15
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: IN
83280: PUSH
83281: LD_EXP 72
83285: PUSH
83286: LD_VAR 0 1
83290: ARRAY
83291: AND
83292: IFFALSE 83448
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
83294: LD_ADDR_VAR 0 9
83298: PUSH
83299: LD_EXP 72
83303: PUSH
83304: LD_VAR 0 1
83308: ARRAY
83309: PUSH
83310: LD_INT 1
83312: ARRAY
83313: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
83314: LD_VAR 0 9
83318: PUSH
83319: LD_EXP 73
83323: PUSH
83324: LD_VAR 0 1
83328: ARRAY
83329: IN
83330: NOT
83331: IFFALSE 83446
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
83333: LD_ADDR_EXP 73
83337: PUSH
83338: LD_EXP 73
83342: PPUSH
83343: LD_VAR 0 1
83347: PUSH
83348: LD_EXP 73
83352: PUSH
83353: LD_VAR 0 1
83357: ARRAY
83358: PUSH
83359: LD_INT 1
83361: PLUS
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PPUSH
83367: LD_VAR 0 9
83371: PPUSH
83372: CALL 22259 0 3
83376: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
83377: LD_ADDR_EXP 72
83381: PUSH
83382: LD_EXP 72
83386: PPUSH
83387: LD_VAR 0 1
83391: PPUSH
83392: LD_EXP 72
83396: PUSH
83397: LD_VAR 0 1
83401: ARRAY
83402: PUSH
83403: LD_VAR 0 9
83407: DIFF
83408: PPUSH
83409: CALL_OW 1
83413: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
83414: LD_VAR 0 3
83418: PPUSH
83419: LD_EXP 73
83423: PUSH
83424: LD_VAR 0 1
83428: ARRAY
83429: PUSH
83430: LD_EXP 73
83434: PUSH
83435: LD_VAR 0 1
83439: ARRAY
83440: ARRAY
83441: PPUSH
83442: CALL_OW 120
// end ; exit ;
83446: GO 83725
// end ; if tmp > 1 then
83448: LD_VAR 0 8
83452: PUSH
83453: LD_INT 1
83455: GREATER
83456: IFFALSE 83560
// for i = 2 to tmp do
83458: LD_ADDR_VAR 0 6
83462: PUSH
83463: DOUBLE
83464: LD_INT 2
83466: DEC
83467: ST_TO_ADDR
83468: LD_VAR 0 8
83472: PUSH
83473: FOR_TO
83474: IFFALSE 83558
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
83476: LD_VAR 0 8
83480: PUSH
83481: LD_VAR 0 6
83485: ARRAY
83486: PPUSH
83487: CALL_OW 461
83491: PUSH
83492: LD_INT 6
83494: EQUAL
83495: IFFALSE 83556
// begin x := tmp [ i ] ;
83497: LD_ADDR_VAR 0 9
83501: PUSH
83502: LD_VAR 0 8
83506: PUSH
83507: LD_VAR 0 6
83511: ARRAY
83512: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
83513: LD_ADDR_VAR 0 8
83517: PUSH
83518: LD_VAR 0 8
83522: PPUSH
83523: LD_VAR 0 6
83527: PPUSH
83528: CALL_OW 3
83532: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
83533: LD_ADDR_VAR 0 8
83537: PUSH
83538: LD_VAR 0 8
83542: PPUSH
83543: LD_INT 1
83545: PPUSH
83546: LD_VAR 0 9
83550: PPUSH
83551: CALL_OW 2
83555: ST_TO_ADDR
// end ;
83556: GO 83473
83558: POP
83559: POP
// for i in tmp do
83560: LD_ADDR_VAR 0 6
83564: PUSH
83565: LD_VAR 0 8
83569: PUSH
83570: FOR_IN
83571: IFFALSE 83598
// begin if IsNotFull ( i ) then
83573: LD_VAR 0 6
83577: PPUSH
83578: CALL 19481 0 1
83582: IFFALSE 83596
// begin j := i ;
83584: LD_ADDR_VAR 0 7
83588: PUSH
83589: LD_VAR 0 6
83593: ST_TO_ADDR
// break ;
83594: GO 83598
// end ; end ;
83596: GO 83570
83598: POP
83599: POP
// if j then
83600: LD_VAR 0 7
83604: IFFALSE 83622
// ComEnterUnit ( unit , j ) else
83606: LD_VAR 0 3
83610: PPUSH
83611: LD_VAR 0 7
83615: PPUSH
83616: CALL_OW 120
83620: GO 83725
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83622: LD_ADDR_VAR 0 10
83626: PUSH
83627: LD_VAR 0 2
83631: PPUSH
83632: LD_INT 2
83634: PUSH
83635: LD_INT 30
83637: PUSH
83638: LD_INT 0
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 30
83647: PUSH
83648: LD_INT 1
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: LIST
83659: PPUSH
83660: CALL_OW 72
83664: ST_TO_ADDR
// if depot then
83665: LD_VAR 0 10
83669: IFFALSE 83725
// begin depot := NearestUnitToUnit ( depot , unit ) ;
83671: LD_ADDR_VAR 0 10
83675: PUSH
83676: LD_VAR 0 10
83680: PPUSH
83681: LD_VAR 0 3
83685: PPUSH
83686: CALL_OW 74
83690: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
83691: LD_VAR 0 3
83695: PPUSH
83696: LD_VAR 0 10
83700: PPUSH
83701: CALL_OW 296
83705: PUSH
83706: LD_INT 10
83708: GREATER
83709: IFFALSE 83725
// ComStandNearbyBuilding ( unit , depot ) ;
83711: LD_VAR 0 3
83715: PPUSH
83716: LD_VAR 0 10
83720: PPUSH
83721: CALL 18861 0 2
// end ; end ; end ;
83725: LD_VAR 0 5
83729: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
83730: LD_INT 0
83732: PPUSH
83733: PPUSH
83734: PPUSH
83735: PPUSH
// if not mc_bases then
83736: LD_EXP 63
83740: NOT
83741: IFFALSE 83745
// exit ;
83743: GO 83984
// for i = 1 to mc_bases do
83745: LD_ADDR_VAR 0 2
83749: PUSH
83750: DOUBLE
83751: LD_INT 1
83753: DEC
83754: ST_TO_ADDR
83755: LD_EXP 63
83759: PUSH
83760: FOR_TO
83761: IFFALSE 83982
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
83763: LD_ADDR_VAR 0 4
83767: PUSH
83768: LD_EXP 63
83772: PUSH
83773: LD_VAR 0 2
83777: ARRAY
83778: PPUSH
83779: LD_INT 21
83781: PUSH
83782: LD_INT 1
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PPUSH
83789: CALL_OW 72
83793: PUSH
83794: LD_EXP 92
83798: PUSH
83799: LD_VAR 0 2
83803: ARRAY
83804: UNION
83805: ST_TO_ADDR
// if not tmp then
83806: LD_VAR 0 4
83810: NOT
83811: IFFALSE 83815
// continue ;
83813: GO 83760
// for j in tmp do
83815: LD_ADDR_VAR 0 3
83819: PUSH
83820: LD_VAR 0 4
83824: PUSH
83825: FOR_IN
83826: IFFALSE 83978
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
83828: LD_VAR 0 3
83832: PPUSH
83833: CALL_OW 110
83837: NOT
83838: PUSH
83839: LD_VAR 0 3
83843: PPUSH
83844: CALL_OW 314
83848: NOT
83849: AND
83850: PUSH
83851: LD_VAR 0 3
83855: PPUSH
83856: CALL_OW 311
83860: NOT
83861: AND
83862: PUSH
83863: LD_VAR 0 3
83867: PPUSH
83868: CALL_OW 310
83872: NOT
83873: AND
83874: PUSH
83875: LD_VAR 0 3
83879: PUSH
83880: LD_EXP 66
83884: PUSH
83885: LD_VAR 0 2
83889: ARRAY
83890: PUSH
83891: LD_INT 1
83893: ARRAY
83894: IN
83895: NOT
83896: AND
83897: PUSH
83898: LD_VAR 0 3
83902: PUSH
83903: LD_EXP 66
83907: PUSH
83908: LD_VAR 0 2
83912: ARRAY
83913: PUSH
83914: LD_INT 2
83916: ARRAY
83917: IN
83918: NOT
83919: AND
83920: PUSH
83921: LD_VAR 0 3
83925: PUSH
83926: LD_EXP 75
83930: PUSH
83931: LD_VAR 0 2
83935: ARRAY
83936: IN
83937: NOT
83938: AND
83939: IFFALSE 83976
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
83941: LD_VAR 0 2
83945: PPUSH
83946: LD_EXP 63
83950: PUSH
83951: LD_VAR 0 2
83955: ARRAY
83956: PPUSH
83957: LD_VAR 0 3
83961: PPUSH
83962: LD_VAR 0 3
83966: PPUSH
83967: CALL_OW 257
83971: PPUSH
83972: CALL 82790 0 4
// end ;
83976: GO 83825
83978: POP
83979: POP
// end ;
83980: GO 83760
83982: POP
83983: POP
// end ;
83984: LD_VAR 0 1
83988: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
83989: LD_INT 0
83991: PPUSH
83992: PPUSH
83993: PPUSH
83994: PPUSH
83995: PPUSH
83996: PPUSH
// if not mc_bases [ base ] then
83997: LD_EXP 63
84001: PUSH
84002: LD_VAR 0 1
84006: ARRAY
84007: NOT
84008: IFFALSE 84012
// exit ;
84010: GO 84213
// tmp := [ ] ;
84012: LD_ADDR_VAR 0 6
84016: PUSH
84017: EMPTY
84018: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
84019: LD_ADDR_VAR 0 7
84023: PUSH
84024: LD_VAR 0 3
84028: PPUSH
84029: LD_INT 0
84031: PPUSH
84032: CALL_OW 517
84036: ST_TO_ADDR
// if not list then
84037: LD_VAR 0 7
84041: NOT
84042: IFFALSE 84046
// exit ;
84044: GO 84213
// c := Count ( list [ 1 ] ) ;
84046: LD_ADDR_VAR 0 9
84050: PUSH
84051: LD_VAR 0 7
84055: PUSH
84056: LD_INT 1
84058: ARRAY
84059: PPUSH
84060: CALL 19399 0 1
84064: ST_TO_ADDR
// if amount > c then
84065: LD_VAR 0 2
84069: PUSH
84070: LD_VAR 0 9
84074: GREATER
84075: IFFALSE 84087
// amount := c ;
84077: LD_ADDR_VAR 0 2
84081: PUSH
84082: LD_VAR 0 9
84086: ST_TO_ADDR
// for i := 1 to amount do
84087: LD_ADDR_VAR 0 5
84091: PUSH
84092: DOUBLE
84093: LD_INT 1
84095: DEC
84096: ST_TO_ADDR
84097: LD_VAR 0 2
84101: PUSH
84102: FOR_TO
84103: IFFALSE 84161
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
84105: LD_ADDR_VAR 0 6
84109: PUSH
84110: LD_VAR 0 6
84114: PPUSH
84115: LD_VAR 0 5
84119: PPUSH
84120: LD_VAR 0 7
84124: PUSH
84125: LD_INT 1
84127: ARRAY
84128: PUSH
84129: LD_VAR 0 5
84133: ARRAY
84134: PUSH
84135: LD_VAR 0 7
84139: PUSH
84140: LD_INT 2
84142: ARRAY
84143: PUSH
84144: LD_VAR 0 5
84148: ARRAY
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PPUSH
84154: CALL_OW 1
84158: ST_TO_ADDR
84159: GO 84102
84161: POP
84162: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
84163: LD_ADDR_EXP 76
84167: PUSH
84168: LD_EXP 76
84172: PPUSH
84173: LD_VAR 0 1
84177: PPUSH
84178: LD_VAR 0 6
84182: PPUSH
84183: CALL_OW 1
84187: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
84188: LD_ADDR_EXP 78
84192: PUSH
84193: LD_EXP 78
84197: PPUSH
84198: LD_VAR 0 1
84202: PPUSH
84203: LD_VAR 0 3
84207: PPUSH
84208: CALL_OW 1
84212: ST_TO_ADDR
// end ;
84213: LD_VAR 0 4
84217: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
84218: LD_INT 0
84220: PPUSH
// if not mc_bases [ base ] then
84221: LD_EXP 63
84225: PUSH
84226: LD_VAR 0 1
84230: ARRAY
84231: NOT
84232: IFFALSE 84236
// exit ;
84234: GO 84261
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
84236: LD_ADDR_EXP 68
84240: PUSH
84241: LD_EXP 68
84245: PPUSH
84246: LD_VAR 0 1
84250: PPUSH
84251: LD_VAR 0 2
84255: PPUSH
84256: CALL_OW 1
84260: ST_TO_ADDR
// end ;
84261: LD_VAR 0 3
84265: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
84266: LD_INT 0
84268: PPUSH
// if not mc_bases [ base ] then
84269: LD_EXP 63
84273: PUSH
84274: LD_VAR 0 1
84278: ARRAY
84279: NOT
84280: IFFALSE 84284
// exit ;
84282: GO 84321
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
84284: LD_ADDR_EXP 68
84288: PUSH
84289: LD_EXP 68
84293: PPUSH
84294: LD_VAR 0 1
84298: PPUSH
84299: LD_EXP 68
84303: PUSH
84304: LD_VAR 0 1
84308: ARRAY
84309: PUSH
84310: LD_VAR 0 2
84314: UNION
84315: PPUSH
84316: CALL_OW 1
84320: ST_TO_ADDR
// end ;
84321: LD_VAR 0 3
84325: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
84326: LD_INT 0
84328: PPUSH
// if not mc_bases [ base ] then
84329: LD_EXP 63
84333: PUSH
84334: LD_VAR 0 1
84338: ARRAY
84339: NOT
84340: IFFALSE 84344
// exit ;
84342: GO 84369
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
84344: LD_ADDR_EXP 84
84348: PUSH
84349: LD_EXP 84
84353: PPUSH
84354: LD_VAR 0 1
84358: PPUSH
84359: LD_VAR 0 2
84363: PPUSH
84364: CALL_OW 1
84368: ST_TO_ADDR
// end ;
84369: LD_VAR 0 3
84373: RET
// export function MC_InsertProduceList ( base , components ) ; begin
84374: LD_INT 0
84376: PPUSH
// if not mc_bases [ base ] then
84377: LD_EXP 63
84381: PUSH
84382: LD_VAR 0 1
84386: ARRAY
84387: NOT
84388: IFFALSE 84392
// exit ;
84390: GO 84429
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
84392: LD_ADDR_EXP 84
84396: PUSH
84397: LD_EXP 84
84401: PPUSH
84402: LD_VAR 0 1
84406: PPUSH
84407: LD_EXP 84
84411: PUSH
84412: LD_VAR 0 1
84416: ARRAY
84417: PUSH
84418: LD_VAR 0 2
84422: ADD
84423: PPUSH
84424: CALL_OW 1
84428: ST_TO_ADDR
// end ;
84429: LD_VAR 0 3
84433: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
84434: LD_INT 0
84436: PPUSH
// if not mc_bases [ base ] then
84437: LD_EXP 63
84441: PUSH
84442: LD_VAR 0 1
84446: ARRAY
84447: NOT
84448: IFFALSE 84452
// exit ;
84450: GO 84506
// mc_defender := Replace ( mc_defender , base , deflist ) ;
84452: LD_ADDR_EXP 85
84456: PUSH
84457: LD_EXP 85
84461: PPUSH
84462: LD_VAR 0 1
84466: PPUSH
84467: LD_VAR 0 2
84471: PPUSH
84472: CALL_OW 1
84476: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
84477: LD_ADDR_EXP 74
84481: PUSH
84482: LD_EXP 74
84486: PPUSH
84487: LD_VAR 0 1
84491: PPUSH
84492: LD_VAR 0 2
84496: PUSH
84497: LD_INT 0
84499: PLUS
84500: PPUSH
84501: CALL_OW 1
84505: ST_TO_ADDR
// end ;
84506: LD_VAR 0 3
84510: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
84511: LD_INT 0
84513: PPUSH
// if not mc_bases [ base ] then
84514: LD_EXP 63
84518: PUSH
84519: LD_VAR 0 1
84523: ARRAY
84524: NOT
84525: IFFALSE 84529
// exit ;
84527: GO 84554
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
84529: LD_ADDR_EXP 74
84533: PUSH
84534: LD_EXP 74
84538: PPUSH
84539: LD_VAR 0 1
84543: PPUSH
84544: LD_VAR 0 2
84548: PPUSH
84549: CALL_OW 1
84553: ST_TO_ADDR
// end ;
84554: LD_VAR 0 3
84558: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
84559: LD_INT 0
84561: PPUSH
84562: PPUSH
84563: PPUSH
84564: PPUSH
// if not mc_bases [ base ] then
84565: LD_EXP 63
84569: PUSH
84570: LD_VAR 0 1
84574: ARRAY
84575: NOT
84576: IFFALSE 84580
// exit ;
84578: GO 84645
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
84580: LD_ADDR_EXP 83
84584: PUSH
84585: LD_EXP 83
84589: PPUSH
84590: LD_VAR 0 1
84594: PUSH
84595: LD_EXP 83
84599: PUSH
84600: LD_VAR 0 1
84604: ARRAY
84605: PUSH
84606: LD_INT 1
84608: PLUS
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PPUSH
84614: LD_VAR 0 1
84618: PUSH
84619: LD_VAR 0 2
84623: PUSH
84624: LD_VAR 0 3
84628: PUSH
84629: LD_VAR 0 4
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: PPUSH
84640: CALL 22259 0 3
84644: ST_TO_ADDR
// end ;
84645: LD_VAR 0 5
84649: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
84650: LD_INT 0
84652: PPUSH
// if not mc_bases [ base ] then
84653: LD_EXP 63
84657: PUSH
84658: LD_VAR 0 1
84662: ARRAY
84663: NOT
84664: IFFALSE 84668
// exit ;
84666: GO 84693
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
84668: LD_ADDR_EXP 100
84672: PUSH
84673: LD_EXP 100
84677: PPUSH
84678: LD_VAR 0 1
84682: PPUSH
84683: LD_VAR 0 2
84687: PPUSH
84688: CALL_OW 1
84692: ST_TO_ADDR
// end ;
84693: LD_VAR 0 3
84697: RET
// export function MC_GetMinesField ( base ) ; begin
84698: LD_INT 0
84700: PPUSH
// result := mc_mines [ base ] ;
84701: LD_ADDR_VAR 0 2
84705: PUSH
84706: LD_EXP 76
84710: PUSH
84711: LD_VAR 0 1
84715: ARRAY
84716: ST_TO_ADDR
// end ;
84717: LD_VAR 0 2
84721: RET
// export function MC_GetProduceList ( base ) ; begin
84722: LD_INT 0
84724: PPUSH
// result := mc_produce [ base ] ;
84725: LD_ADDR_VAR 0 2
84729: PUSH
84730: LD_EXP 84
84734: PUSH
84735: LD_VAR 0 1
84739: ARRAY
84740: ST_TO_ADDR
// end ;
84741: LD_VAR 0 2
84745: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
84746: LD_INT 0
84748: PPUSH
84749: PPUSH
// if not mc_bases then
84750: LD_EXP 63
84754: NOT
84755: IFFALSE 84759
// exit ;
84757: GO 84824
// if mc_bases [ base ] then
84759: LD_EXP 63
84763: PUSH
84764: LD_VAR 0 1
84768: ARRAY
84769: IFFALSE 84824
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84771: LD_ADDR_VAR 0 3
84775: PUSH
84776: LD_EXP 63
84780: PUSH
84781: LD_VAR 0 1
84785: ARRAY
84786: PPUSH
84787: LD_INT 30
84789: PUSH
84790: LD_VAR 0 2
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PPUSH
84799: CALL_OW 72
84803: ST_TO_ADDR
// if result then
84804: LD_VAR 0 3
84808: IFFALSE 84824
// result := result [ 1 ] ;
84810: LD_ADDR_VAR 0 3
84814: PUSH
84815: LD_VAR 0 3
84819: PUSH
84820: LD_INT 1
84822: ARRAY
84823: ST_TO_ADDR
// end ; end ;
84824: LD_VAR 0 3
84828: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
84829: LD_INT 0
84831: PPUSH
84832: PPUSH
// if not mc_bases then
84833: LD_EXP 63
84837: NOT
84838: IFFALSE 84842
// exit ;
84840: GO 84887
// if mc_bases [ base ] then
84842: LD_EXP 63
84846: PUSH
84847: LD_VAR 0 1
84851: ARRAY
84852: IFFALSE 84887
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84854: LD_ADDR_VAR 0 3
84858: PUSH
84859: LD_EXP 63
84863: PUSH
84864: LD_VAR 0 1
84868: ARRAY
84869: PPUSH
84870: LD_INT 30
84872: PUSH
84873: LD_VAR 0 2
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PPUSH
84882: CALL_OW 72
84886: ST_TO_ADDR
// end ;
84887: LD_VAR 0 3
84891: RET
// export function MC_SetTame ( base , area ) ; begin
84892: LD_INT 0
84894: PPUSH
// if not mc_bases or not base then
84895: LD_EXP 63
84899: NOT
84900: PUSH
84901: LD_VAR 0 1
84905: NOT
84906: OR
84907: IFFALSE 84911
// exit ;
84909: GO 84936
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84911: LD_ADDR_EXP 91
84915: PUSH
84916: LD_EXP 91
84920: PPUSH
84921: LD_VAR 0 1
84925: PPUSH
84926: LD_VAR 0 2
84930: PPUSH
84931: CALL_OW 1
84935: ST_TO_ADDR
// end ;
84936: LD_VAR 0 3
84940: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
84941: LD_INT 0
84943: PPUSH
84944: PPUSH
// if not mc_bases or not base then
84945: LD_EXP 63
84949: NOT
84950: PUSH
84951: LD_VAR 0 1
84955: NOT
84956: OR
84957: IFFALSE 84961
// exit ;
84959: GO 85063
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84961: LD_ADDR_VAR 0 4
84965: PUSH
84966: LD_EXP 63
84970: PUSH
84971: LD_VAR 0 1
84975: ARRAY
84976: PPUSH
84977: LD_INT 30
84979: PUSH
84980: LD_VAR 0 2
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PPUSH
84989: CALL_OW 72
84993: ST_TO_ADDR
// if not tmp then
84994: LD_VAR 0 4
84998: NOT
84999: IFFALSE 85003
// exit ;
85001: GO 85063
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
85003: LD_ADDR_EXP 95
85007: PUSH
85008: LD_EXP 95
85012: PPUSH
85013: LD_VAR 0 1
85017: PPUSH
85018: LD_EXP 95
85022: PUSH
85023: LD_VAR 0 1
85027: ARRAY
85028: PPUSH
85029: LD_EXP 95
85033: PUSH
85034: LD_VAR 0 1
85038: ARRAY
85039: PUSH
85040: LD_INT 1
85042: PLUS
85043: PPUSH
85044: LD_VAR 0 4
85048: PUSH
85049: LD_INT 1
85051: ARRAY
85052: PPUSH
85053: CALL_OW 2
85057: PPUSH
85058: CALL_OW 1
85062: ST_TO_ADDR
// end ;
85063: LD_VAR 0 3
85067: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
85068: LD_INT 0
85070: PPUSH
85071: PPUSH
// if not mc_bases or not base or not kinds then
85072: LD_EXP 63
85076: NOT
85077: PUSH
85078: LD_VAR 0 1
85082: NOT
85083: OR
85084: PUSH
85085: LD_VAR 0 2
85089: NOT
85090: OR
85091: IFFALSE 85095
// exit ;
85093: GO 85156
// for i in kinds do
85095: LD_ADDR_VAR 0 4
85099: PUSH
85100: LD_VAR 0 2
85104: PUSH
85105: FOR_IN
85106: IFFALSE 85154
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
85108: LD_ADDR_EXP 97
85112: PUSH
85113: LD_EXP 97
85117: PPUSH
85118: LD_VAR 0 1
85122: PUSH
85123: LD_EXP 97
85127: PUSH
85128: LD_VAR 0 1
85132: ARRAY
85133: PUSH
85134: LD_INT 1
85136: PLUS
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PPUSH
85142: LD_VAR 0 4
85146: PPUSH
85147: CALL 22259 0 3
85151: ST_TO_ADDR
85152: GO 85105
85154: POP
85155: POP
// end ;
85156: LD_VAR 0 3
85160: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
85161: LD_INT 0
85163: PPUSH
// if not mc_bases or not base or not areas then
85164: LD_EXP 63
85168: NOT
85169: PUSH
85170: LD_VAR 0 1
85174: NOT
85175: OR
85176: PUSH
85177: LD_VAR 0 2
85181: NOT
85182: OR
85183: IFFALSE 85187
// exit ;
85185: GO 85212
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
85187: LD_ADDR_EXP 81
85191: PUSH
85192: LD_EXP 81
85196: PPUSH
85197: LD_VAR 0 1
85201: PPUSH
85202: LD_VAR 0 2
85206: PPUSH
85207: CALL_OW 1
85211: ST_TO_ADDR
// end ;
85212: LD_VAR 0 3
85216: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
85217: LD_INT 0
85219: PPUSH
// if not mc_bases or not base or not teleports_exit then
85220: LD_EXP 63
85224: NOT
85225: PUSH
85226: LD_VAR 0 1
85230: NOT
85231: OR
85232: PUSH
85233: LD_VAR 0 2
85237: NOT
85238: OR
85239: IFFALSE 85243
// exit ;
85241: GO 85268
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
85243: LD_ADDR_EXP 98
85247: PUSH
85248: LD_EXP 98
85252: PPUSH
85253: LD_VAR 0 1
85257: PPUSH
85258: LD_VAR 0 2
85262: PPUSH
85263: CALL_OW 1
85267: ST_TO_ADDR
// end ;
85268: LD_VAR 0 3
85272: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
85273: LD_INT 0
85275: PPUSH
85276: PPUSH
85277: PPUSH
// if not mc_bases or not base or not ext_list then
85278: LD_EXP 63
85282: NOT
85283: PUSH
85284: LD_VAR 0 1
85288: NOT
85289: OR
85290: PUSH
85291: LD_VAR 0 5
85295: NOT
85296: OR
85297: IFFALSE 85301
// exit ;
85299: GO 85474
// tmp := GetFacExtXYD ( x , y , d ) ;
85301: LD_ADDR_VAR 0 8
85305: PUSH
85306: LD_VAR 0 2
85310: PPUSH
85311: LD_VAR 0 3
85315: PPUSH
85316: LD_VAR 0 4
85320: PPUSH
85321: CALL 52642 0 3
85325: ST_TO_ADDR
// if not tmp then
85326: LD_VAR 0 8
85330: NOT
85331: IFFALSE 85335
// exit ;
85333: GO 85474
// for i in tmp do
85335: LD_ADDR_VAR 0 7
85339: PUSH
85340: LD_VAR 0 8
85344: PUSH
85345: FOR_IN
85346: IFFALSE 85472
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
85348: LD_ADDR_EXP 68
85352: PUSH
85353: LD_EXP 68
85357: PPUSH
85358: LD_VAR 0 1
85362: PPUSH
85363: LD_EXP 68
85367: PUSH
85368: LD_VAR 0 1
85372: ARRAY
85373: PPUSH
85374: LD_EXP 68
85378: PUSH
85379: LD_VAR 0 1
85383: ARRAY
85384: PUSH
85385: LD_INT 1
85387: PLUS
85388: PPUSH
85389: LD_VAR 0 5
85393: PUSH
85394: LD_INT 1
85396: ARRAY
85397: PUSH
85398: LD_VAR 0 7
85402: PUSH
85403: LD_INT 1
85405: ARRAY
85406: PUSH
85407: LD_VAR 0 7
85411: PUSH
85412: LD_INT 2
85414: ARRAY
85415: PUSH
85416: LD_VAR 0 7
85420: PUSH
85421: LD_INT 3
85423: ARRAY
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: PPUSH
85431: CALL_OW 2
85435: PPUSH
85436: CALL_OW 1
85440: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
85441: LD_ADDR_VAR 0 5
85445: PUSH
85446: LD_VAR 0 5
85450: PPUSH
85451: LD_INT 1
85453: PPUSH
85454: CALL_OW 3
85458: ST_TO_ADDR
// if not ext_list then
85459: LD_VAR 0 5
85463: NOT
85464: IFFALSE 85470
// exit ;
85466: POP
85467: POP
85468: GO 85474
// end ;
85470: GO 85345
85472: POP
85473: POP
// end ;
85474: LD_VAR 0 6
85478: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
85479: LD_INT 0
85481: PPUSH
// if not mc_bases or not base or not weapon_list then
85482: LD_EXP 63
85486: NOT
85487: PUSH
85488: LD_VAR 0 1
85492: NOT
85493: OR
85494: PUSH
85495: LD_VAR 0 2
85499: NOT
85500: OR
85501: IFFALSE 85505
// exit ;
85503: GO 85530
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
85505: LD_ADDR_EXP 102
85509: PUSH
85510: LD_EXP 102
85514: PPUSH
85515: LD_VAR 0 1
85519: PPUSH
85520: LD_VAR 0 2
85524: PPUSH
85525: CALL_OW 1
85529: ST_TO_ADDR
// end ;
85530: LD_VAR 0 3
85534: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
85535: LD_INT 0
85537: PPUSH
// if not mc_bases or not base or not tech_list then
85538: LD_EXP 63
85542: NOT
85543: PUSH
85544: LD_VAR 0 1
85548: NOT
85549: OR
85550: PUSH
85551: LD_VAR 0 2
85555: NOT
85556: OR
85557: IFFALSE 85561
// exit ;
85559: GO 85586
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
85561: LD_ADDR_EXP 90
85565: PUSH
85566: LD_EXP 90
85570: PPUSH
85571: LD_VAR 0 1
85575: PPUSH
85576: LD_VAR 0 2
85580: PPUSH
85581: CALL_OW 1
85585: ST_TO_ADDR
// end ;
85586: LD_VAR 0 3
85590: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
85591: LD_INT 0
85593: PPUSH
// if not mc_bases or not parking_area or not base then
85594: LD_EXP 63
85598: NOT
85599: PUSH
85600: LD_VAR 0 2
85604: NOT
85605: OR
85606: PUSH
85607: LD_VAR 0 1
85611: NOT
85612: OR
85613: IFFALSE 85617
// exit ;
85615: GO 85642
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
85617: LD_ADDR_EXP 87
85621: PUSH
85622: LD_EXP 87
85626: PPUSH
85627: LD_VAR 0 1
85631: PPUSH
85632: LD_VAR 0 2
85636: PPUSH
85637: CALL_OW 1
85641: ST_TO_ADDR
// end ;
85642: LD_VAR 0 3
85646: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
85647: LD_INT 0
85649: PPUSH
// if not mc_bases or not base or not scan_area then
85650: LD_EXP 63
85654: NOT
85655: PUSH
85656: LD_VAR 0 1
85660: NOT
85661: OR
85662: PUSH
85663: LD_VAR 0 2
85667: NOT
85668: OR
85669: IFFALSE 85673
// exit ;
85671: GO 85698
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
85673: LD_ADDR_EXP 88
85677: PUSH
85678: LD_EXP 88
85682: PPUSH
85683: LD_VAR 0 1
85687: PPUSH
85688: LD_VAR 0 2
85692: PPUSH
85693: CALL_OW 1
85697: ST_TO_ADDR
// end ;
85698: LD_VAR 0 3
85702: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
85703: LD_INT 0
85705: PPUSH
85706: PPUSH
// if not mc_bases or not base then
85707: LD_EXP 63
85711: NOT
85712: PUSH
85713: LD_VAR 0 1
85717: NOT
85718: OR
85719: IFFALSE 85723
// exit ;
85721: GO 85787
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
85723: LD_ADDR_VAR 0 3
85727: PUSH
85728: LD_INT 1
85730: PUSH
85731: LD_INT 2
85733: PUSH
85734: LD_INT 3
85736: PUSH
85737: LD_INT 4
85739: PUSH
85740: LD_INT 11
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
85750: LD_ADDR_EXP 90
85754: PUSH
85755: LD_EXP 90
85759: PPUSH
85760: LD_VAR 0 1
85764: PPUSH
85765: LD_EXP 90
85769: PUSH
85770: LD_VAR 0 1
85774: ARRAY
85775: PUSH
85776: LD_VAR 0 3
85780: DIFF
85781: PPUSH
85782: CALL_OW 1
85786: ST_TO_ADDR
// end ;
85787: LD_VAR 0 2
85791: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
85792: LD_INT 0
85794: PPUSH
// result := mc_vehicles [ base ] ;
85795: LD_ADDR_VAR 0 3
85799: PUSH
85800: LD_EXP 82
85804: PUSH
85805: LD_VAR 0 1
85809: ARRAY
85810: ST_TO_ADDR
// if onlyCombat then
85811: LD_VAR 0 2
85815: IFFALSE 85987
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
85817: LD_ADDR_VAR 0 3
85821: PUSH
85822: LD_VAR 0 3
85826: PUSH
85827: LD_VAR 0 3
85831: PPUSH
85832: LD_INT 2
85834: PUSH
85835: LD_INT 34
85837: PUSH
85838: LD_INT 12
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 34
85847: PUSH
85848: LD_INT 51
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 34
85857: PUSH
85858: LD_INT 89
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 34
85867: PUSH
85868: LD_INT 32
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 34
85877: PUSH
85878: LD_INT 13
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 34
85887: PUSH
85888: LD_INT 52
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 34
85897: PUSH
85898: LD_INT 88
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 34
85907: PUSH
85908: LD_INT 14
85910: PUSH
85911: EMPTY
85912: LIST
85913: LIST
85914: PUSH
85915: LD_INT 34
85917: PUSH
85918: LD_INT 53
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 34
85927: PUSH
85928: LD_INT 98
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 34
85937: PUSH
85938: LD_INT 31
85940: PUSH
85941: EMPTY
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 34
85947: PUSH
85948: LD_INT 48
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 34
85957: PUSH
85958: LD_INT 8
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: EMPTY
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: LIST
85979: LIST
85980: PPUSH
85981: CALL_OW 72
85985: DIFF
85986: ST_TO_ADDR
// end ; end_of_file
85987: LD_VAR 0 3
85991: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
85992: LD_INT 0
85994: PPUSH
85995: PPUSH
85996: PPUSH
// if not mc_bases or not skirmish then
85997: LD_EXP 63
86001: NOT
86002: PUSH
86003: LD_EXP 61
86007: NOT
86008: OR
86009: IFFALSE 86013
// exit ;
86011: GO 86178
// for i = 1 to mc_bases do
86013: LD_ADDR_VAR 0 4
86017: PUSH
86018: DOUBLE
86019: LD_INT 1
86021: DEC
86022: ST_TO_ADDR
86023: LD_EXP 63
86027: PUSH
86028: FOR_TO
86029: IFFALSE 86176
// begin if sci in mc_bases [ i ] then
86031: LD_VAR 0 2
86035: PUSH
86036: LD_EXP 63
86040: PUSH
86041: LD_VAR 0 4
86045: ARRAY
86046: IN
86047: IFFALSE 86174
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
86049: LD_ADDR_EXP 92
86053: PUSH
86054: LD_EXP 92
86058: PPUSH
86059: LD_VAR 0 4
86063: PUSH
86064: LD_EXP 92
86068: PUSH
86069: LD_VAR 0 4
86073: ARRAY
86074: PUSH
86075: LD_INT 1
86077: PLUS
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PPUSH
86083: LD_VAR 0 1
86087: PPUSH
86088: CALL 22259 0 3
86092: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
86093: LD_ADDR_VAR 0 5
86097: PUSH
86098: LD_EXP 63
86102: PUSH
86103: LD_VAR 0 4
86107: ARRAY
86108: PPUSH
86109: LD_INT 2
86111: PUSH
86112: LD_INT 30
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 30
86124: PUSH
86125: LD_INT 1
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: LIST
86136: PPUSH
86137: CALL_OW 72
86141: PPUSH
86142: LD_VAR 0 1
86146: PPUSH
86147: CALL_OW 74
86151: ST_TO_ADDR
// if tmp then
86152: LD_VAR 0 5
86156: IFFALSE 86172
// ComStandNearbyBuilding ( ape , tmp ) ;
86158: LD_VAR 0 1
86162: PPUSH
86163: LD_VAR 0 5
86167: PPUSH
86168: CALL 18861 0 2
// break ;
86172: GO 86176
// end ; end ;
86174: GO 86028
86176: POP
86177: POP
// end ;
86178: LD_VAR 0 3
86182: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
86183: LD_INT 0
86185: PPUSH
86186: PPUSH
86187: PPUSH
// if not mc_bases or not skirmish then
86188: LD_EXP 63
86192: NOT
86193: PUSH
86194: LD_EXP 61
86198: NOT
86199: OR
86200: IFFALSE 86204
// exit ;
86202: GO 86293
// for i = 1 to mc_bases do
86204: LD_ADDR_VAR 0 4
86208: PUSH
86209: DOUBLE
86210: LD_INT 1
86212: DEC
86213: ST_TO_ADDR
86214: LD_EXP 63
86218: PUSH
86219: FOR_TO
86220: IFFALSE 86291
// begin if building in mc_busy_turret_list [ i ] then
86222: LD_VAR 0 1
86226: PUSH
86227: LD_EXP 73
86231: PUSH
86232: LD_VAR 0 4
86236: ARRAY
86237: IN
86238: IFFALSE 86289
// begin tmp := mc_busy_turret_list [ i ] diff building ;
86240: LD_ADDR_VAR 0 5
86244: PUSH
86245: LD_EXP 73
86249: PUSH
86250: LD_VAR 0 4
86254: ARRAY
86255: PUSH
86256: LD_VAR 0 1
86260: DIFF
86261: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
86262: LD_ADDR_EXP 73
86266: PUSH
86267: LD_EXP 73
86271: PPUSH
86272: LD_VAR 0 4
86276: PPUSH
86277: LD_VAR 0 5
86281: PPUSH
86282: CALL_OW 1
86286: ST_TO_ADDR
// break ;
86287: GO 86291
// end ; end ;
86289: GO 86219
86291: POP
86292: POP
// end ;
86293: LD_VAR 0 3
86297: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
86298: LD_INT 0
86300: PPUSH
86301: PPUSH
86302: PPUSH
// if not mc_bases or not skirmish then
86303: LD_EXP 63
86307: NOT
86308: PUSH
86309: LD_EXP 61
86313: NOT
86314: OR
86315: IFFALSE 86319
// exit ;
86317: GO 86518
// for i = 1 to mc_bases do
86319: LD_ADDR_VAR 0 5
86323: PUSH
86324: DOUBLE
86325: LD_INT 1
86327: DEC
86328: ST_TO_ADDR
86329: LD_EXP 63
86333: PUSH
86334: FOR_TO
86335: IFFALSE 86516
// if building in mc_bases [ i ] then
86337: LD_VAR 0 1
86341: PUSH
86342: LD_EXP 63
86346: PUSH
86347: LD_VAR 0 5
86351: ARRAY
86352: IN
86353: IFFALSE 86514
// begin tmp := mc_bases [ i ] diff building ;
86355: LD_ADDR_VAR 0 6
86359: PUSH
86360: LD_EXP 63
86364: PUSH
86365: LD_VAR 0 5
86369: ARRAY
86370: PUSH
86371: LD_VAR 0 1
86375: DIFF
86376: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
86377: LD_ADDR_EXP 63
86381: PUSH
86382: LD_EXP 63
86386: PPUSH
86387: LD_VAR 0 5
86391: PPUSH
86392: LD_VAR 0 6
86396: PPUSH
86397: CALL_OW 1
86401: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
86402: LD_VAR 0 1
86406: PUSH
86407: LD_EXP 71
86411: PUSH
86412: LD_VAR 0 5
86416: ARRAY
86417: IN
86418: IFFALSE 86457
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
86420: LD_ADDR_EXP 71
86424: PUSH
86425: LD_EXP 71
86429: PPUSH
86430: LD_VAR 0 5
86434: PPUSH
86435: LD_EXP 71
86439: PUSH
86440: LD_VAR 0 5
86444: ARRAY
86445: PUSH
86446: LD_VAR 0 1
86450: DIFF
86451: PPUSH
86452: CALL_OW 1
86456: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
86457: LD_VAR 0 1
86461: PUSH
86462: LD_EXP 72
86466: PUSH
86467: LD_VAR 0 5
86471: ARRAY
86472: IN
86473: IFFALSE 86512
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
86475: LD_ADDR_EXP 72
86479: PUSH
86480: LD_EXP 72
86484: PPUSH
86485: LD_VAR 0 5
86489: PPUSH
86490: LD_EXP 72
86494: PUSH
86495: LD_VAR 0 5
86499: ARRAY
86500: PUSH
86501: LD_VAR 0 1
86505: DIFF
86506: PPUSH
86507: CALL_OW 1
86511: ST_TO_ADDR
// break ;
86512: GO 86516
// end ;
86514: GO 86334
86516: POP
86517: POP
// end ;
86518: LD_VAR 0 4
86522: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
86523: LD_INT 0
86525: PPUSH
86526: PPUSH
86527: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
86528: LD_EXP 63
86532: NOT
86533: PUSH
86534: LD_EXP 61
86538: NOT
86539: OR
86540: PUSH
86541: LD_VAR 0 3
86545: PUSH
86546: LD_EXP 89
86550: IN
86551: NOT
86552: OR
86553: IFFALSE 86557
// exit ;
86555: GO 86680
// for i = 1 to mc_vehicles do
86557: LD_ADDR_VAR 0 6
86561: PUSH
86562: DOUBLE
86563: LD_INT 1
86565: DEC
86566: ST_TO_ADDR
86567: LD_EXP 82
86571: PUSH
86572: FOR_TO
86573: IFFALSE 86678
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
86575: LD_VAR 0 2
86579: PUSH
86580: LD_EXP 82
86584: PUSH
86585: LD_VAR 0 6
86589: ARRAY
86590: IN
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_EXP 82
86601: PUSH
86602: LD_VAR 0 6
86606: ARRAY
86607: IN
86608: OR
86609: IFFALSE 86676
// begin tmp := mc_vehicles [ i ] diff old ;
86611: LD_ADDR_VAR 0 7
86615: PUSH
86616: LD_EXP 82
86620: PUSH
86621: LD_VAR 0 6
86625: ARRAY
86626: PUSH
86627: LD_VAR 0 2
86631: DIFF
86632: ST_TO_ADDR
// tmp := tmp diff new ;
86633: LD_ADDR_VAR 0 7
86637: PUSH
86638: LD_VAR 0 7
86642: PUSH
86643: LD_VAR 0 1
86647: DIFF
86648: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
86649: LD_ADDR_EXP 82
86653: PUSH
86654: LD_EXP 82
86658: PPUSH
86659: LD_VAR 0 6
86663: PPUSH
86664: LD_VAR 0 7
86668: PPUSH
86669: CALL_OW 1
86673: ST_TO_ADDR
// break ;
86674: GO 86678
// end ;
86676: GO 86572
86678: POP
86679: POP
// end ;
86680: LD_VAR 0 5
86684: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
86685: LD_INT 0
86687: PPUSH
86688: PPUSH
86689: PPUSH
86690: PPUSH
// if not mc_bases or not skirmish then
86691: LD_EXP 63
86695: NOT
86696: PUSH
86697: LD_EXP 61
86701: NOT
86702: OR
86703: IFFALSE 86707
// exit ;
86705: GO 87127
// repeat wait ( 0 0$1 ) ;
86707: LD_INT 35
86709: PPUSH
86710: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
86714: LD_EXP 107
86718: NOT
86719: IFFALSE 86707
// mc_block_vehicle_constructed_thread := true ;
86721: LD_ADDR_EXP 107
86725: PUSH
86726: LD_INT 1
86728: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
86729: LD_ADDR_VAR 0 5
86733: PUSH
86734: LD_VAR 0 1
86738: PPUSH
86739: CALL_OW 255
86743: ST_TO_ADDR
// for i = 1 to mc_bases do
86744: LD_ADDR_VAR 0 4
86748: PUSH
86749: DOUBLE
86750: LD_INT 1
86752: DEC
86753: ST_TO_ADDR
86754: LD_EXP 63
86758: PUSH
86759: FOR_TO
86760: IFFALSE 87117
// begin if factory in mc_bases [ i ] then
86762: LD_VAR 0 2
86766: PUSH
86767: LD_EXP 63
86771: PUSH
86772: LD_VAR 0 4
86776: ARRAY
86777: IN
86778: IFFALSE 87115
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
86780: LD_EXP 85
86784: PUSH
86785: LD_VAR 0 4
86789: ARRAY
86790: PUSH
86791: LD_EXP 74
86795: PUSH
86796: LD_VAR 0 4
86800: ARRAY
86801: LESS
86802: PUSH
86803: LD_VAR 0 1
86807: PPUSH
86808: CALL_OW 264
86812: PUSH
86813: LD_INT 31
86815: PUSH
86816: LD_INT 32
86818: PUSH
86819: LD_INT 51
86821: PUSH
86822: LD_INT 89
86824: PUSH
86825: LD_INT 12
86827: PUSH
86828: LD_INT 30
86830: PUSH
86831: LD_INT 98
86833: PUSH
86834: LD_INT 11
86836: PUSH
86837: LD_INT 53
86839: PUSH
86840: LD_INT 14
86842: PUSH
86843: LD_INT 91
86845: PUSH
86846: LD_INT 29
86848: PUSH
86849: LD_INT 99
86851: PUSH
86852: LD_INT 13
86854: PUSH
86855: LD_INT 52
86857: PUSH
86858: LD_INT 88
86860: PUSH
86861: LD_INT 48
86863: PUSH
86864: LD_INT 8
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: IN
86887: NOT
86888: AND
86889: IFFALSE 86937
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86891: LD_ADDR_EXP 85
86895: PUSH
86896: LD_EXP 85
86900: PPUSH
86901: LD_VAR 0 4
86905: PUSH
86906: LD_EXP 85
86910: PUSH
86911: LD_VAR 0 4
86915: ARRAY
86916: PUSH
86917: LD_INT 1
86919: PLUS
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PPUSH
86925: LD_VAR 0 1
86929: PPUSH
86930: CALL 22259 0 3
86934: ST_TO_ADDR
86935: GO 86981
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
86937: LD_ADDR_EXP 82
86941: PUSH
86942: LD_EXP 82
86946: PPUSH
86947: LD_VAR 0 4
86951: PUSH
86952: LD_EXP 82
86956: PUSH
86957: LD_VAR 0 4
86961: ARRAY
86962: PUSH
86963: LD_INT 1
86965: PLUS
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PPUSH
86971: LD_VAR 0 1
86975: PPUSH
86976: CALL 22259 0 3
86980: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
86981: LD_ADDR_EXP 107
86985: PUSH
86986: LD_INT 0
86988: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
86989: LD_VAR 0 1
86993: PPUSH
86994: CALL_OW 263
86998: PUSH
86999: LD_INT 2
87001: EQUAL
87002: IFFALSE 87031
// begin repeat wait ( 0 0$3 ) ;
87004: LD_INT 105
87006: PPUSH
87007: CALL_OW 67
// Connect ( vehicle ) ;
87011: LD_VAR 0 1
87015: PPUSH
87016: CALL 25605 0 1
// until IsControledBy ( vehicle ) ;
87020: LD_VAR 0 1
87024: PPUSH
87025: CALL_OW 312
87029: IFFALSE 87004
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
87031: LD_VAR 0 1
87035: PPUSH
87036: LD_EXP 87
87040: PUSH
87041: LD_VAR 0 4
87045: ARRAY
87046: PPUSH
87047: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
87051: LD_VAR 0 1
87055: PPUSH
87056: CALL_OW 263
87060: PUSH
87061: LD_INT 1
87063: NONEQUAL
87064: IFFALSE 87068
// break ;
87066: GO 87117
// repeat wait ( 0 0$1 ) ;
87068: LD_INT 35
87070: PPUSH
87071: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
87075: LD_VAR 0 1
87079: PPUSH
87080: LD_EXP 87
87084: PUSH
87085: LD_VAR 0 4
87089: ARRAY
87090: PPUSH
87091: CALL_OW 308
87095: IFFALSE 87068
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
87097: LD_VAR 0 1
87101: PPUSH
87102: CALL_OW 311
87106: PPUSH
87107: CALL_OW 121
// exit ;
87111: POP
87112: POP
87113: GO 87127
// end ; end ;
87115: GO 86759
87117: POP
87118: POP
// mc_block_vehicle_constructed_thread := false ;
87119: LD_ADDR_EXP 107
87123: PUSH
87124: LD_INT 0
87126: ST_TO_ADDR
// end ;
87127: LD_VAR 0 3
87131: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
87132: LD_INT 0
87134: PPUSH
87135: PPUSH
87136: PPUSH
87137: PPUSH
// if not mc_bases or not skirmish then
87138: LD_EXP 63
87142: NOT
87143: PUSH
87144: LD_EXP 61
87148: NOT
87149: OR
87150: IFFALSE 87154
// exit ;
87152: GO 87507
// repeat wait ( 0 0$1 ) ;
87154: LD_INT 35
87156: PPUSH
87157: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
87161: LD_VAR 0 2
87165: PPUSH
87166: LD_VAR 0 3
87170: PPUSH
87171: CALL_OW 284
87175: IFFALSE 87154
// if GetResourceTypeXY ( x , y ) = mat_artefact then
87177: LD_VAR 0 2
87181: PPUSH
87182: LD_VAR 0 3
87186: PPUSH
87187: CALL_OW 283
87191: PUSH
87192: LD_INT 4
87194: EQUAL
87195: IFFALSE 87199
// exit ;
87197: GO 87507
// for i = 1 to mc_bases do
87199: LD_ADDR_VAR 0 7
87203: PUSH
87204: DOUBLE
87205: LD_INT 1
87207: DEC
87208: ST_TO_ADDR
87209: LD_EXP 63
87213: PUSH
87214: FOR_TO
87215: IFFALSE 87505
// begin if mc_crates_area [ i ] then
87217: LD_EXP 81
87221: PUSH
87222: LD_VAR 0 7
87226: ARRAY
87227: IFFALSE 87338
// for j in mc_crates_area [ i ] do
87229: LD_ADDR_VAR 0 8
87233: PUSH
87234: LD_EXP 81
87238: PUSH
87239: LD_VAR 0 7
87243: ARRAY
87244: PUSH
87245: FOR_IN
87246: IFFALSE 87336
// if InArea ( x , y , j ) then
87248: LD_VAR 0 2
87252: PPUSH
87253: LD_VAR 0 3
87257: PPUSH
87258: LD_VAR 0 8
87262: PPUSH
87263: CALL_OW 309
87267: IFFALSE 87334
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87269: LD_ADDR_EXP 79
87273: PUSH
87274: LD_EXP 79
87278: PPUSH
87279: LD_VAR 0 7
87283: PUSH
87284: LD_EXP 79
87288: PUSH
87289: LD_VAR 0 7
87293: ARRAY
87294: PUSH
87295: LD_INT 1
87297: PLUS
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PPUSH
87303: LD_VAR 0 4
87307: PUSH
87308: LD_VAR 0 2
87312: PUSH
87313: LD_VAR 0 3
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: LIST
87322: PPUSH
87323: CALL 22259 0 3
87327: ST_TO_ADDR
// exit ;
87328: POP
87329: POP
87330: POP
87331: POP
87332: GO 87507
// end ;
87334: GO 87245
87336: POP
87337: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87338: LD_ADDR_VAR 0 9
87342: PUSH
87343: LD_EXP 63
87347: PUSH
87348: LD_VAR 0 7
87352: ARRAY
87353: PPUSH
87354: LD_INT 2
87356: PUSH
87357: LD_INT 30
87359: PUSH
87360: LD_INT 0
87362: PUSH
87363: EMPTY
87364: LIST
87365: LIST
87366: PUSH
87367: LD_INT 30
87369: PUSH
87370: LD_INT 1
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: LIST
87381: PPUSH
87382: CALL_OW 72
87386: ST_TO_ADDR
// if not depot then
87387: LD_VAR 0 9
87391: NOT
87392: IFFALSE 87396
// continue ;
87394: GO 87214
// for j in depot do
87396: LD_ADDR_VAR 0 8
87400: PUSH
87401: LD_VAR 0 9
87405: PUSH
87406: FOR_IN
87407: IFFALSE 87501
// if GetDistUnitXY ( j , x , y ) < 30 then
87409: LD_VAR 0 8
87413: PPUSH
87414: LD_VAR 0 2
87418: PPUSH
87419: LD_VAR 0 3
87423: PPUSH
87424: CALL_OW 297
87428: PUSH
87429: LD_INT 30
87431: LESS
87432: IFFALSE 87499
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87434: LD_ADDR_EXP 79
87438: PUSH
87439: LD_EXP 79
87443: PPUSH
87444: LD_VAR 0 7
87448: PUSH
87449: LD_EXP 79
87453: PUSH
87454: LD_VAR 0 7
87458: ARRAY
87459: PUSH
87460: LD_INT 1
87462: PLUS
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PPUSH
87468: LD_VAR 0 4
87472: PUSH
87473: LD_VAR 0 2
87477: PUSH
87478: LD_VAR 0 3
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: LIST
87487: PPUSH
87488: CALL 22259 0 3
87492: ST_TO_ADDR
// exit ;
87493: POP
87494: POP
87495: POP
87496: POP
87497: GO 87507
// end ;
87499: GO 87406
87501: POP
87502: POP
// end ;
87503: GO 87214
87505: POP
87506: POP
// end ;
87507: LD_VAR 0 6
87511: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
87512: LD_INT 0
87514: PPUSH
87515: PPUSH
87516: PPUSH
87517: PPUSH
// if not mc_bases or not skirmish then
87518: LD_EXP 63
87522: NOT
87523: PUSH
87524: LD_EXP 61
87528: NOT
87529: OR
87530: IFFALSE 87534
// exit ;
87532: GO 87811
// side := GetSide ( lab ) ;
87534: LD_ADDR_VAR 0 4
87538: PUSH
87539: LD_VAR 0 2
87543: PPUSH
87544: CALL_OW 255
87548: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
87549: LD_VAR 0 4
87553: PUSH
87554: LD_EXP 89
87558: IN
87559: NOT
87560: PUSH
87561: LD_EXP 90
87565: NOT
87566: OR
87567: PUSH
87568: LD_EXP 63
87572: NOT
87573: OR
87574: IFFALSE 87578
// exit ;
87576: GO 87811
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
87578: LD_ADDR_EXP 90
87582: PUSH
87583: LD_EXP 90
87587: PPUSH
87588: LD_VAR 0 4
87592: PPUSH
87593: LD_EXP 90
87597: PUSH
87598: LD_VAR 0 4
87602: ARRAY
87603: PUSH
87604: LD_VAR 0 1
87608: DIFF
87609: PPUSH
87610: CALL_OW 1
87614: ST_TO_ADDR
// for i = 1 to mc_bases do
87615: LD_ADDR_VAR 0 5
87619: PUSH
87620: DOUBLE
87621: LD_INT 1
87623: DEC
87624: ST_TO_ADDR
87625: LD_EXP 63
87629: PUSH
87630: FOR_TO
87631: IFFALSE 87809
// begin if lab in mc_bases [ i ] then
87633: LD_VAR 0 2
87637: PUSH
87638: LD_EXP 63
87642: PUSH
87643: LD_VAR 0 5
87647: ARRAY
87648: IN
87649: IFFALSE 87807
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
87651: LD_VAR 0 1
87655: PUSH
87656: LD_INT 11
87658: PUSH
87659: LD_INT 4
87661: PUSH
87662: LD_INT 3
87664: PUSH
87665: LD_INT 2
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: IN
87674: PUSH
87675: LD_EXP 93
87679: PUSH
87680: LD_VAR 0 5
87684: ARRAY
87685: AND
87686: IFFALSE 87807
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
87688: LD_ADDR_VAR 0 6
87692: PUSH
87693: LD_EXP 93
87697: PUSH
87698: LD_VAR 0 5
87702: ARRAY
87703: PUSH
87704: LD_INT 1
87706: ARRAY
87707: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87708: LD_ADDR_EXP 93
87712: PUSH
87713: LD_EXP 93
87717: PPUSH
87718: LD_VAR 0 5
87722: PPUSH
87723: EMPTY
87724: PPUSH
87725: CALL_OW 1
87729: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
87730: LD_VAR 0 6
87734: PPUSH
87735: LD_INT 0
87737: PPUSH
87738: CALL_OW 109
// ComExitBuilding ( tmp ) ;
87742: LD_VAR 0 6
87746: PPUSH
87747: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
87751: LD_ADDR_EXP 92
87755: PUSH
87756: LD_EXP 92
87760: PPUSH
87761: LD_VAR 0 5
87765: PPUSH
87766: LD_EXP 92
87770: PUSH
87771: LD_VAR 0 5
87775: ARRAY
87776: PPUSH
87777: LD_INT 1
87779: PPUSH
87780: LD_VAR 0 6
87784: PPUSH
87785: CALL_OW 2
87789: PPUSH
87790: CALL_OW 1
87794: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
87795: LD_VAR 0 5
87799: PPUSH
87800: LD_INT 112
87802: PPUSH
87803: CALL 64261 0 2
// end ; end ; end ;
87807: GO 87630
87809: POP
87810: POP
// end ;
87811: LD_VAR 0 3
87815: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
87816: LD_INT 0
87818: PPUSH
87819: PPUSH
87820: PPUSH
87821: PPUSH
87822: PPUSH
87823: PPUSH
87824: PPUSH
87825: PPUSH
// if not mc_bases or not skirmish then
87826: LD_EXP 63
87830: NOT
87831: PUSH
87832: LD_EXP 61
87836: NOT
87837: OR
87838: IFFALSE 87842
// exit ;
87840: GO 89211
// for i = 1 to mc_bases do
87842: LD_ADDR_VAR 0 3
87846: PUSH
87847: DOUBLE
87848: LD_INT 1
87850: DEC
87851: ST_TO_ADDR
87852: LD_EXP 63
87856: PUSH
87857: FOR_TO
87858: IFFALSE 89209
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
87860: LD_VAR 0 1
87864: PUSH
87865: LD_EXP 63
87869: PUSH
87870: LD_VAR 0 3
87874: ARRAY
87875: IN
87876: PUSH
87877: LD_VAR 0 1
87881: PUSH
87882: LD_EXP 70
87886: PUSH
87887: LD_VAR 0 3
87891: ARRAY
87892: IN
87893: OR
87894: PUSH
87895: LD_VAR 0 1
87899: PUSH
87900: LD_EXP 85
87904: PUSH
87905: LD_VAR 0 3
87909: ARRAY
87910: IN
87911: OR
87912: PUSH
87913: LD_VAR 0 1
87917: PUSH
87918: LD_EXP 82
87922: PUSH
87923: LD_VAR 0 3
87927: ARRAY
87928: IN
87929: OR
87930: PUSH
87931: LD_VAR 0 1
87935: PUSH
87936: LD_EXP 92
87940: PUSH
87941: LD_VAR 0 3
87945: ARRAY
87946: IN
87947: OR
87948: PUSH
87949: LD_VAR 0 1
87953: PUSH
87954: LD_EXP 93
87958: PUSH
87959: LD_VAR 0 3
87963: ARRAY
87964: IN
87965: OR
87966: IFFALSE 89207
// begin if un in mc_ape [ i ] then
87968: LD_VAR 0 1
87972: PUSH
87973: LD_EXP 92
87977: PUSH
87978: LD_VAR 0 3
87982: ARRAY
87983: IN
87984: IFFALSE 88023
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
87986: LD_ADDR_EXP 92
87990: PUSH
87991: LD_EXP 92
87995: PPUSH
87996: LD_VAR 0 3
88000: PPUSH
88001: LD_EXP 92
88005: PUSH
88006: LD_VAR 0 3
88010: ARRAY
88011: PUSH
88012: LD_VAR 0 1
88016: DIFF
88017: PPUSH
88018: CALL_OW 1
88022: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
88023: LD_VAR 0 1
88027: PUSH
88028: LD_EXP 93
88032: PUSH
88033: LD_VAR 0 3
88037: ARRAY
88038: IN
88039: IFFALSE 88063
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88041: LD_ADDR_EXP 93
88045: PUSH
88046: LD_EXP 93
88050: PPUSH
88051: LD_VAR 0 3
88055: PPUSH
88056: EMPTY
88057: PPUSH
88058: CALL_OW 1
88062: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
88063: LD_VAR 0 1
88067: PPUSH
88068: CALL_OW 247
88072: PUSH
88073: LD_INT 2
88075: EQUAL
88076: PUSH
88077: LD_VAR 0 1
88081: PPUSH
88082: CALL_OW 110
88086: PUSH
88087: LD_INT 20
88089: EQUAL
88090: PUSH
88091: LD_VAR 0 1
88095: PUSH
88096: LD_EXP 85
88100: PUSH
88101: LD_VAR 0 3
88105: ARRAY
88106: IN
88107: OR
88108: PUSH
88109: LD_VAR 0 1
88113: PPUSH
88114: CALL_OW 264
88118: PUSH
88119: LD_INT 12
88121: PUSH
88122: LD_INT 51
88124: PUSH
88125: LD_INT 89
88127: PUSH
88128: LD_INT 32
88130: PUSH
88131: LD_INT 13
88133: PUSH
88134: LD_INT 52
88136: PUSH
88137: LD_INT 31
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: IN
88149: OR
88150: AND
88151: IFFALSE 88459
// begin if un in mc_defender [ i ] then
88153: LD_VAR 0 1
88157: PUSH
88158: LD_EXP 85
88162: PUSH
88163: LD_VAR 0 3
88167: ARRAY
88168: IN
88169: IFFALSE 88208
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88171: LD_ADDR_EXP 85
88175: PUSH
88176: LD_EXP 85
88180: PPUSH
88181: LD_VAR 0 3
88185: PPUSH
88186: LD_EXP 85
88190: PUSH
88191: LD_VAR 0 3
88195: ARRAY
88196: PUSH
88197: LD_VAR 0 1
88201: DIFF
88202: PPUSH
88203: CALL_OW 1
88207: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
88208: LD_ADDR_VAR 0 8
88212: PUSH
88213: LD_VAR 0 3
88217: PPUSH
88218: LD_INT 3
88220: PPUSH
88221: CALL 84829 0 2
88225: ST_TO_ADDR
// if fac then
88226: LD_VAR 0 8
88230: IFFALSE 88459
// begin for j in fac do
88232: LD_ADDR_VAR 0 4
88236: PUSH
88237: LD_VAR 0 8
88241: PUSH
88242: FOR_IN
88243: IFFALSE 88457
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
88245: LD_ADDR_VAR 0 9
88249: PUSH
88250: LD_VAR 0 8
88254: PPUSH
88255: LD_VAR 0 1
88259: PPUSH
88260: CALL_OW 265
88264: PPUSH
88265: LD_VAR 0 1
88269: PPUSH
88270: CALL_OW 262
88274: PPUSH
88275: LD_VAR 0 1
88279: PPUSH
88280: CALL_OW 263
88284: PPUSH
88285: LD_VAR 0 1
88289: PPUSH
88290: CALL_OW 264
88294: PPUSH
88295: CALL 19757 0 5
88299: ST_TO_ADDR
// if components then
88300: LD_VAR 0 9
88304: IFFALSE 88455
// begin if GetWeapon ( un ) = ar_control_tower then
88306: LD_VAR 0 1
88310: PPUSH
88311: CALL_OW 264
88315: PUSH
88316: LD_INT 31
88318: EQUAL
88319: IFFALSE 88436
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
88321: LD_VAR 0 1
88325: PPUSH
88326: CALL_OW 311
88330: PPUSH
88331: LD_INT 0
88333: PPUSH
88334: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
88338: LD_ADDR_EXP 103
88342: PUSH
88343: LD_EXP 103
88347: PPUSH
88348: LD_VAR 0 3
88352: PPUSH
88353: LD_EXP 103
88357: PUSH
88358: LD_VAR 0 3
88362: ARRAY
88363: PUSH
88364: LD_VAR 0 1
88368: PPUSH
88369: CALL_OW 311
88373: DIFF
88374: PPUSH
88375: CALL_OW 1
88379: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
88380: LD_ADDR_VAR 0 7
88384: PUSH
88385: LD_EXP 84
88389: PUSH
88390: LD_VAR 0 3
88394: ARRAY
88395: PPUSH
88396: LD_INT 1
88398: PPUSH
88399: LD_VAR 0 9
88403: PPUSH
88404: CALL_OW 2
88408: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
88409: LD_ADDR_EXP 84
88413: PUSH
88414: LD_EXP 84
88418: PPUSH
88419: LD_VAR 0 3
88423: PPUSH
88424: LD_VAR 0 7
88428: PPUSH
88429: CALL_OW 1
88433: ST_TO_ADDR
// end else
88434: GO 88453
// MC_InsertProduceList ( i , [ components ] ) ;
88436: LD_VAR 0 3
88440: PPUSH
88441: LD_VAR 0 9
88445: PUSH
88446: EMPTY
88447: LIST
88448: PPUSH
88449: CALL 84374 0 2
// break ;
88453: GO 88457
// end ; end ;
88455: GO 88242
88457: POP
88458: POP
// end ; end ; if GetType ( un ) = unit_building then
88459: LD_VAR 0 1
88463: PPUSH
88464: CALL_OW 247
88468: PUSH
88469: LD_INT 3
88471: EQUAL
88472: IFFALSE 88875
// begin btype := GetBType ( un ) ;
88474: LD_ADDR_VAR 0 5
88478: PUSH
88479: LD_VAR 0 1
88483: PPUSH
88484: CALL_OW 266
88488: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
88489: LD_VAR 0 5
88493: PUSH
88494: LD_INT 29
88496: PUSH
88497: LD_INT 30
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: IN
88504: IFFALSE 88577
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
88506: LD_VAR 0 1
88510: PPUSH
88511: CALL_OW 250
88515: PPUSH
88516: LD_VAR 0 1
88520: PPUSH
88521: CALL_OW 251
88525: PPUSH
88526: LD_VAR 0 1
88530: PPUSH
88531: CALL_OW 255
88535: PPUSH
88536: CALL_OW 440
88540: NOT
88541: IFFALSE 88577
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
88543: LD_VAR 0 1
88547: PPUSH
88548: CALL_OW 250
88552: PPUSH
88553: LD_VAR 0 1
88557: PPUSH
88558: CALL_OW 251
88562: PPUSH
88563: LD_VAR 0 1
88567: PPUSH
88568: CALL_OW 255
88572: PPUSH
88573: CALL_OW 441
// end ; if btype = b_warehouse then
88577: LD_VAR 0 5
88581: PUSH
88582: LD_INT 1
88584: EQUAL
88585: IFFALSE 88603
// begin btype := b_depot ;
88587: LD_ADDR_VAR 0 5
88591: PUSH
88592: LD_INT 0
88594: ST_TO_ADDR
// pos := 1 ;
88595: LD_ADDR_VAR 0 6
88599: PUSH
88600: LD_INT 1
88602: ST_TO_ADDR
// end ; if btype = b_factory then
88603: LD_VAR 0 5
88607: PUSH
88608: LD_INT 3
88610: EQUAL
88611: IFFALSE 88629
// begin btype := b_workshop ;
88613: LD_ADDR_VAR 0 5
88617: PUSH
88618: LD_INT 2
88620: ST_TO_ADDR
// pos := 1 ;
88621: LD_ADDR_VAR 0 6
88625: PUSH
88626: LD_INT 1
88628: ST_TO_ADDR
// end ; if btype = b_barracks then
88629: LD_VAR 0 5
88633: PUSH
88634: LD_INT 5
88636: EQUAL
88637: IFFALSE 88647
// btype := b_armoury ;
88639: LD_ADDR_VAR 0 5
88643: PUSH
88644: LD_INT 4
88646: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
88647: LD_VAR 0 5
88651: PUSH
88652: LD_INT 7
88654: PUSH
88655: LD_INT 8
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: IN
88662: IFFALSE 88672
// btype := b_lab ;
88664: LD_ADDR_VAR 0 5
88668: PUSH
88669: LD_INT 6
88671: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
88672: LD_ADDR_EXP 68
88676: PUSH
88677: LD_EXP 68
88681: PPUSH
88682: LD_VAR 0 3
88686: PUSH
88687: LD_EXP 68
88691: PUSH
88692: LD_VAR 0 3
88696: ARRAY
88697: PUSH
88698: LD_INT 1
88700: PLUS
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PPUSH
88706: LD_VAR 0 5
88710: PUSH
88711: LD_VAR 0 1
88715: PPUSH
88716: CALL_OW 250
88720: PUSH
88721: LD_VAR 0 1
88725: PPUSH
88726: CALL_OW 251
88730: PUSH
88731: LD_VAR 0 1
88735: PPUSH
88736: CALL_OW 254
88740: PUSH
88741: EMPTY
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: PPUSH
88747: CALL 22259 0 3
88751: ST_TO_ADDR
// if pos = 1 then
88752: LD_VAR 0 6
88756: PUSH
88757: LD_INT 1
88759: EQUAL
88760: IFFALSE 88875
// begin tmp := mc_build_list [ i ] ;
88762: LD_ADDR_VAR 0 7
88766: PUSH
88767: LD_EXP 68
88771: PUSH
88772: LD_VAR 0 3
88776: ARRAY
88777: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88778: LD_VAR 0 7
88782: PPUSH
88783: LD_INT 2
88785: PUSH
88786: LD_INT 30
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 30
88798: PUSH
88799: LD_INT 1
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: LIST
88810: PPUSH
88811: CALL_OW 72
88815: IFFALSE 88825
// pos := 2 ;
88817: LD_ADDR_VAR 0 6
88821: PUSH
88822: LD_INT 2
88824: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
88825: LD_ADDR_VAR 0 7
88829: PUSH
88830: LD_VAR 0 7
88834: PPUSH
88835: LD_VAR 0 6
88839: PPUSH
88840: LD_VAR 0 7
88844: PPUSH
88845: CALL 22585 0 3
88849: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
88850: LD_ADDR_EXP 68
88854: PUSH
88855: LD_EXP 68
88859: PPUSH
88860: LD_VAR 0 3
88864: PPUSH
88865: LD_VAR 0 7
88869: PPUSH
88870: CALL_OW 1
88874: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
88875: LD_VAR 0 1
88879: PUSH
88880: LD_EXP 63
88884: PUSH
88885: LD_VAR 0 3
88889: ARRAY
88890: IN
88891: IFFALSE 88930
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88893: LD_ADDR_EXP 63
88897: PUSH
88898: LD_EXP 63
88902: PPUSH
88903: LD_VAR 0 3
88907: PPUSH
88908: LD_EXP 63
88912: PUSH
88913: LD_VAR 0 3
88917: ARRAY
88918: PUSH
88919: LD_VAR 0 1
88923: DIFF
88924: PPUSH
88925: CALL_OW 1
88929: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88930: LD_VAR 0 1
88934: PUSH
88935: LD_EXP 70
88939: PUSH
88940: LD_VAR 0 3
88944: ARRAY
88945: IN
88946: IFFALSE 88985
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
88948: LD_ADDR_EXP 70
88952: PUSH
88953: LD_EXP 70
88957: PPUSH
88958: LD_VAR 0 3
88962: PPUSH
88963: LD_EXP 70
88967: PUSH
88968: LD_VAR 0 3
88972: ARRAY
88973: PUSH
88974: LD_VAR 0 1
88978: DIFF
88979: PPUSH
88980: CALL_OW 1
88984: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
88985: LD_VAR 0 1
88989: PUSH
88990: LD_EXP 82
88994: PUSH
88995: LD_VAR 0 3
88999: ARRAY
89000: IN
89001: IFFALSE 89040
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
89003: LD_ADDR_EXP 82
89007: PUSH
89008: LD_EXP 82
89012: PPUSH
89013: LD_VAR 0 3
89017: PPUSH
89018: LD_EXP 82
89022: PUSH
89023: LD_VAR 0 3
89027: ARRAY
89028: PUSH
89029: LD_VAR 0 1
89033: DIFF
89034: PPUSH
89035: CALL_OW 1
89039: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
89040: LD_VAR 0 1
89044: PUSH
89045: LD_EXP 85
89049: PUSH
89050: LD_VAR 0 3
89054: ARRAY
89055: IN
89056: IFFALSE 89095
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89058: LD_ADDR_EXP 85
89062: PUSH
89063: LD_EXP 85
89067: PPUSH
89068: LD_VAR 0 3
89072: PPUSH
89073: LD_EXP 85
89077: PUSH
89078: LD_VAR 0 3
89082: ARRAY
89083: PUSH
89084: LD_VAR 0 1
89088: DIFF
89089: PPUSH
89090: CALL_OW 1
89094: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
89095: LD_VAR 0 1
89099: PUSH
89100: LD_EXP 72
89104: PUSH
89105: LD_VAR 0 3
89109: ARRAY
89110: IN
89111: IFFALSE 89150
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
89113: LD_ADDR_EXP 72
89117: PUSH
89118: LD_EXP 72
89122: PPUSH
89123: LD_VAR 0 3
89127: PPUSH
89128: LD_EXP 72
89132: PUSH
89133: LD_VAR 0 3
89137: ARRAY
89138: PUSH
89139: LD_VAR 0 1
89143: DIFF
89144: PPUSH
89145: CALL_OW 1
89149: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
89150: LD_VAR 0 1
89154: PUSH
89155: LD_EXP 71
89159: PUSH
89160: LD_VAR 0 3
89164: ARRAY
89165: IN
89166: IFFALSE 89205
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
89168: LD_ADDR_EXP 71
89172: PUSH
89173: LD_EXP 71
89177: PPUSH
89178: LD_VAR 0 3
89182: PPUSH
89183: LD_EXP 71
89187: PUSH
89188: LD_VAR 0 3
89192: ARRAY
89193: PUSH
89194: LD_VAR 0 1
89198: DIFF
89199: PPUSH
89200: CALL_OW 1
89204: ST_TO_ADDR
// end ; break ;
89205: GO 89209
// end ;
89207: GO 87857
89209: POP
89210: POP
// end ;
89211: LD_VAR 0 2
89215: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
89216: LD_INT 0
89218: PPUSH
89219: PPUSH
89220: PPUSH
// if not mc_bases or not skirmish then
89221: LD_EXP 63
89225: NOT
89226: PUSH
89227: LD_EXP 61
89231: NOT
89232: OR
89233: IFFALSE 89237
// exit ;
89235: GO 89452
// for i = 1 to mc_bases do
89237: LD_ADDR_VAR 0 3
89241: PUSH
89242: DOUBLE
89243: LD_INT 1
89245: DEC
89246: ST_TO_ADDR
89247: LD_EXP 63
89251: PUSH
89252: FOR_TO
89253: IFFALSE 89450
// begin if building in mc_construct_list [ i ] then
89255: LD_VAR 0 1
89259: PUSH
89260: LD_EXP 70
89264: PUSH
89265: LD_VAR 0 3
89269: ARRAY
89270: IN
89271: IFFALSE 89448
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89273: LD_ADDR_EXP 70
89277: PUSH
89278: LD_EXP 70
89282: PPUSH
89283: LD_VAR 0 3
89287: PPUSH
89288: LD_EXP 70
89292: PUSH
89293: LD_VAR 0 3
89297: ARRAY
89298: PUSH
89299: LD_VAR 0 1
89303: DIFF
89304: PPUSH
89305: CALL_OW 1
89309: ST_TO_ADDR
// if building in mc_lab [ i ] then
89310: LD_VAR 0 1
89314: PUSH
89315: LD_EXP 96
89319: PUSH
89320: LD_VAR 0 3
89324: ARRAY
89325: IN
89326: IFFALSE 89381
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
89328: LD_ADDR_EXP 97
89332: PUSH
89333: LD_EXP 97
89337: PPUSH
89338: LD_VAR 0 3
89342: PPUSH
89343: LD_EXP 97
89347: PUSH
89348: LD_VAR 0 3
89352: ARRAY
89353: PPUSH
89354: LD_INT 1
89356: PPUSH
89357: LD_EXP 97
89361: PUSH
89362: LD_VAR 0 3
89366: ARRAY
89367: PPUSH
89368: LD_INT 0
89370: PPUSH
89371: CALL 21677 0 4
89375: PPUSH
89376: CALL_OW 1
89380: ST_TO_ADDR
// if not building in mc_bases [ i ] then
89381: LD_VAR 0 1
89385: PUSH
89386: LD_EXP 63
89390: PUSH
89391: LD_VAR 0 3
89395: ARRAY
89396: IN
89397: NOT
89398: IFFALSE 89444
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89400: LD_ADDR_EXP 63
89404: PUSH
89405: LD_EXP 63
89409: PPUSH
89410: LD_VAR 0 3
89414: PUSH
89415: LD_EXP 63
89419: PUSH
89420: LD_VAR 0 3
89424: ARRAY
89425: PUSH
89426: LD_INT 1
89428: PLUS
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PPUSH
89434: LD_VAR 0 1
89438: PPUSH
89439: CALL 22259 0 3
89443: ST_TO_ADDR
// exit ;
89444: POP
89445: POP
89446: GO 89452
// end ; end ;
89448: GO 89252
89450: POP
89451: POP
// end ;
89452: LD_VAR 0 2
89456: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
89457: LD_INT 0
89459: PPUSH
89460: PPUSH
89461: PPUSH
89462: PPUSH
89463: PPUSH
89464: PPUSH
89465: PPUSH
// if not mc_bases or not skirmish then
89466: LD_EXP 63
89470: NOT
89471: PUSH
89472: LD_EXP 61
89476: NOT
89477: OR
89478: IFFALSE 89482
// exit ;
89480: GO 90143
// for i = 1 to mc_bases do
89482: LD_ADDR_VAR 0 3
89486: PUSH
89487: DOUBLE
89488: LD_INT 1
89490: DEC
89491: ST_TO_ADDR
89492: LD_EXP 63
89496: PUSH
89497: FOR_TO
89498: IFFALSE 90141
// begin if building in mc_construct_list [ i ] then
89500: LD_VAR 0 1
89504: PUSH
89505: LD_EXP 70
89509: PUSH
89510: LD_VAR 0 3
89514: ARRAY
89515: IN
89516: IFFALSE 90139
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89518: LD_ADDR_EXP 70
89522: PUSH
89523: LD_EXP 70
89527: PPUSH
89528: LD_VAR 0 3
89532: PPUSH
89533: LD_EXP 70
89537: PUSH
89538: LD_VAR 0 3
89542: ARRAY
89543: PUSH
89544: LD_VAR 0 1
89548: DIFF
89549: PPUSH
89550: CALL_OW 1
89554: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89555: LD_ADDR_EXP 63
89559: PUSH
89560: LD_EXP 63
89564: PPUSH
89565: LD_VAR 0 3
89569: PUSH
89570: LD_EXP 63
89574: PUSH
89575: LD_VAR 0 3
89579: ARRAY
89580: PUSH
89581: LD_INT 1
89583: PLUS
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PPUSH
89589: LD_VAR 0 1
89593: PPUSH
89594: CALL 22259 0 3
89598: ST_TO_ADDR
// btype := GetBType ( building ) ;
89599: LD_ADDR_VAR 0 5
89603: PUSH
89604: LD_VAR 0 1
89608: PPUSH
89609: CALL_OW 266
89613: ST_TO_ADDR
// side := GetSide ( building ) ;
89614: LD_ADDR_VAR 0 8
89618: PUSH
89619: LD_VAR 0 1
89623: PPUSH
89624: CALL_OW 255
89628: ST_TO_ADDR
// if btype = b_lab then
89629: LD_VAR 0 5
89633: PUSH
89634: LD_INT 6
89636: EQUAL
89637: IFFALSE 89687
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
89639: LD_ADDR_EXP 96
89643: PUSH
89644: LD_EXP 96
89648: PPUSH
89649: LD_VAR 0 3
89653: PUSH
89654: LD_EXP 96
89658: PUSH
89659: LD_VAR 0 3
89663: ARRAY
89664: PUSH
89665: LD_INT 1
89667: PLUS
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PPUSH
89673: LD_VAR 0 1
89677: PPUSH
89678: CALL 22259 0 3
89682: ST_TO_ADDR
// exit ;
89683: POP
89684: POP
89685: GO 90143
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
89687: LD_VAR 0 5
89691: PUSH
89692: LD_INT 0
89694: PUSH
89695: LD_INT 2
89697: PUSH
89698: LD_INT 4
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: LIST
89705: IN
89706: IFFALSE 89830
// begin if btype = b_armoury then
89708: LD_VAR 0 5
89712: PUSH
89713: LD_INT 4
89715: EQUAL
89716: IFFALSE 89726
// btype := b_barracks ;
89718: LD_ADDR_VAR 0 5
89722: PUSH
89723: LD_INT 5
89725: ST_TO_ADDR
// if btype = b_depot then
89726: LD_VAR 0 5
89730: PUSH
89731: LD_INT 0
89733: EQUAL
89734: IFFALSE 89744
// btype := b_warehouse ;
89736: LD_ADDR_VAR 0 5
89740: PUSH
89741: LD_INT 1
89743: ST_TO_ADDR
// if btype = b_workshop then
89744: LD_VAR 0 5
89748: PUSH
89749: LD_INT 2
89751: EQUAL
89752: IFFALSE 89762
// btype := b_factory ;
89754: LD_ADDR_VAR 0 5
89758: PUSH
89759: LD_INT 3
89761: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
89762: LD_VAR 0 5
89766: PPUSH
89767: LD_VAR 0 8
89771: PPUSH
89772: CALL_OW 323
89776: PUSH
89777: LD_INT 1
89779: EQUAL
89780: IFFALSE 89826
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
89782: LD_ADDR_EXP 95
89786: PUSH
89787: LD_EXP 95
89791: PPUSH
89792: LD_VAR 0 3
89796: PUSH
89797: LD_EXP 95
89801: PUSH
89802: LD_VAR 0 3
89806: ARRAY
89807: PUSH
89808: LD_INT 1
89810: PLUS
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PPUSH
89816: LD_VAR 0 1
89820: PPUSH
89821: CALL 22259 0 3
89825: ST_TO_ADDR
// exit ;
89826: POP
89827: POP
89828: GO 90143
// end ; if btype in [ b_bunker , b_turret ] then
89830: LD_VAR 0 5
89834: PUSH
89835: LD_INT 32
89837: PUSH
89838: LD_INT 33
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: IN
89845: IFFALSE 90135
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
89847: LD_ADDR_EXP 71
89851: PUSH
89852: LD_EXP 71
89856: PPUSH
89857: LD_VAR 0 3
89861: PUSH
89862: LD_EXP 71
89866: PUSH
89867: LD_VAR 0 3
89871: ARRAY
89872: PUSH
89873: LD_INT 1
89875: PLUS
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PPUSH
89881: LD_VAR 0 1
89885: PPUSH
89886: CALL 22259 0 3
89890: ST_TO_ADDR
// if btype = b_bunker then
89891: LD_VAR 0 5
89895: PUSH
89896: LD_INT 32
89898: EQUAL
89899: IFFALSE 90135
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89901: LD_ADDR_EXP 72
89905: PUSH
89906: LD_EXP 72
89910: PPUSH
89911: LD_VAR 0 3
89915: PUSH
89916: LD_EXP 72
89920: PUSH
89921: LD_VAR 0 3
89925: ARRAY
89926: PUSH
89927: LD_INT 1
89929: PLUS
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PPUSH
89935: LD_VAR 0 1
89939: PPUSH
89940: CALL 22259 0 3
89944: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
89945: LD_ADDR_VAR 0 6
89949: PUSH
89950: LD_EXP 63
89954: PUSH
89955: LD_VAR 0 3
89959: ARRAY
89960: PPUSH
89961: LD_INT 25
89963: PUSH
89964: LD_INT 1
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 3
89973: PUSH
89974: LD_INT 54
89976: PUSH
89977: EMPTY
89978: LIST
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PPUSH
89988: CALL_OW 72
89992: ST_TO_ADDR
// if tmp then
89993: LD_VAR 0 6
89997: IFFALSE 90003
// exit ;
89999: POP
90000: POP
90001: GO 90143
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
90003: LD_ADDR_VAR 0 6
90007: PUSH
90008: LD_EXP 63
90012: PUSH
90013: LD_VAR 0 3
90017: ARRAY
90018: PPUSH
90019: LD_INT 2
90021: PUSH
90022: LD_INT 30
90024: PUSH
90025: LD_INT 4
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: LD_INT 30
90034: PUSH
90035: LD_INT 5
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: LIST
90046: PPUSH
90047: CALL_OW 72
90051: ST_TO_ADDR
// if not tmp then
90052: LD_VAR 0 6
90056: NOT
90057: IFFALSE 90063
// exit ;
90059: POP
90060: POP
90061: GO 90143
// for j in tmp do
90063: LD_ADDR_VAR 0 4
90067: PUSH
90068: LD_VAR 0 6
90072: PUSH
90073: FOR_IN
90074: IFFALSE 90133
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
90076: LD_ADDR_VAR 0 7
90080: PUSH
90081: LD_VAR 0 4
90085: PPUSH
90086: CALL_OW 313
90090: PPUSH
90091: LD_INT 25
90093: PUSH
90094: LD_INT 1
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PPUSH
90101: CALL_OW 72
90105: ST_TO_ADDR
// if units then
90106: LD_VAR 0 7
90110: IFFALSE 90131
// begin ComExitBuilding ( units [ 1 ] ) ;
90112: LD_VAR 0 7
90116: PUSH
90117: LD_INT 1
90119: ARRAY
90120: PPUSH
90121: CALL_OW 122
// exit ;
90125: POP
90126: POP
90127: POP
90128: POP
90129: GO 90143
// end ; end ;
90131: GO 90073
90133: POP
90134: POP
// end ; end ; exit ;
90135: POP
90136: POP
90137: GO 90143
// end ; end ;
90139: GO 89497
90141: POP
90142: POP
// end ;
90143: LD_VAR 0 2
90147: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
90148: LD_INT 0
90150: PPUSH
90151: PPUSH
90152: PPUSH
90153: PPUSH
90154: PPUSH
90155: PPUSH
90156: PPUSH
// if not mc_bases or not skirmish then
90157: LD_EXP 63
90161: NOT
90162: PUSH
90163: LD_EXP 61
90167: NOT
90168: OR
90169: IFFALSE 90173
// exit ;
90171: GO 90438
// btype := GetBType ( building ) ;
90173: LD_ADDR_VAR 0 6
90177: PUSH
90178: LD_VAR 0 1
90182: PPUSH
90183: CALL_OW 266
90187: ST_TO_ADDR
// x := GetX ( building ) ;
90188: LD_ADDR_VAR 0 7
90192: PUSH
90193: LD_VAR 0 1
90197: PPUSH
90198: CALL_OW 250
90202: ST_TO_ADDR
// y := GetY ( building ) ;
90203: LD_ADDR_VAR 0 8
90207: PUSH
90208: LD_VAR 0 1
90212: PPUSH
90213: CALL_OW 251
90217: ST_TO_ADDR
// d := GetDir ( building ) ;
90218: LD_ADDR_VAR 0 9
90222: PUSH
90223: LD_VAR 0 1
90227: PPUSH
90228: CALL_OW 254
90232: ST_TO_ADDR
// for i = 1 to mc_bases do
90233: LD_ADDR_VAR 0 4
90237: PUSH
90238: DOUBLE
90239: LD_INT 1
90241: DEC
90242: ST_TO_ADDR
90243: LD_EXP 63
90247: PUSH
90248: FOR_TO
90249: IFFALSE 90436
// begin if not mc_build_list [ i ] then
90251: LD_EXP 68
90255: PUSH
90256: LD_VAR 0 4
90260: ARRAY
90261: NOT
90262: IFFALSE 90266
// continue ;
90264: GO 90248
// for j := 1 to mc_build_list [ i ] do
90266: LD_ADDR_VAR 0 5
90270: PUSH
90271: DOUBLE
90272: LD_INT 1
90274: DEC
90275: ST_TO_ADDR
90276: LD_EXP 68
90280: PUSH
90281: LD_VAR 0 4
90285: ARRAY
90286: PUSH
90287: FOR_TO
90288: IFFALSE 90432
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
90290: LD_VAR 0 6
90294: PUSH
90295: LD_VAR 0 7
90299: PUSH
90300: LD_VAR 0 8
90304: PUSH
90305: LD_VAR 0 9
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: PPUSH
90316: LD_EXP 68
90320: PUSH
90321: LD_VAR 0 4
90325: ARRAY
90326: PUSH
90327: LD_VAR 0 5
90331: ARRAY
90332: PPUSH
90333: CALL 28816 0 2
90337: IFFALSE 90430
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
90339: LD_ADDR_EXP 68
90343: PUSH
90344: LD_EXP 68
90348: PPUSH
90349: LD_VAR 0 4
90353: PPUSH
90354: LD_EXP 68
90358: PUSH
90359: LD_VAR 0 4
90363: ARRAY
90364: PPUSH
90365: LD_VAR 0 5
90369: PPUSH
90370: CALL_OW 3
90374: PPUSH
90375: CALL_OW 1
90379: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
90380: LD_ADDR_EXP 70
90384: PUSH
90385: LD_EXP 70
90389: PPUSH
90390: LD_VAR 0 4
90394: PUSH
90395: LD_EXP 70
90399: PUSH
90400: LD_VAR 0 4
90404: ARRAY
90405: PUSH
90406: LD_INT 1
90408: PLUS
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PPUSH
90414: LD_VAR 0 1
90418: PPUSH
90419: CALL 22259 0 3
90423: ST_TO_ADDR
// exit ;
90424: POP
90425: POP
90426: POP
90427: POP
90428: GO 90438
// end ;
90430: GO 90287
90432: POP
90433: POP
// end ;
90434: GO 90248
90436: POP
90437: POP
// end ;
90438: LD_VAR 0 3
90442: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
90443: LD_INT 0
90445: PPUSH
90446: PPUSH
90447: PPUSH
// if not mc_bases or not skirmish then
90448: LD_EXP 63
90452: NOT
90453: PUSH
90454: LD_EXP 61
90458: NOT
90459: OR
90460: IFFALSE 90464
// exit ;
90462: GO 90654
// for i = 1 to mc_bases do
90464: LD_ADDR_VAR 0 4
90468: PUSH
90469: DOUBLE
90470: LD_INT 1
90472: DEC
90473: ST_TO_ADDR
90474: LD_EXP 63
90478: PUSH
90479: FOR_TO
90480: IFFALSE 90567
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
90482: LD_VAR 0 1
90486: PUSH
90487: LD_EXP 71
90491: PUSH
90492: LD_VAR 0 4
90496: ARRAY
90497: IN
90498: PUSH
90499: LD_VAR 0 1
90503: PUSH
90504: LD_EXP 72
90508: PUSH
90509: LD_VAR 0 4
90513: ARRAY
90514: IN
90515: NOT
90516: AND
90517: IFFALSE 90565
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90519: LD_ADDR_EXP 72
90523: PUSH
90524: LD_EXP 72
90528: PPUSH
90529: LD_VAR 0 4
90533: PUSH
90534: LD_EXP 72
90538: PUSH
90539: LD_VAR 0 4
90543: ARRAY
90544: PUSH
90545: LD_INT 1
90547: PLUS
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PPUSH
90553: LD_VAR 0 1
90557: PPUSH
90558: CALL 22259 0 3
90562: ST_TO_ADDR
// break ;
90563: GO 90567
// end ; end ;
90565: GO 90479
90567: POP
90568: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
90569: LD_VAR 0 1
90573: PPUSH
90574: CALL_OW 257
90578: PUSH
90579: LD_EXP 89
90583: IN
90584: PUSH
90585: LD_VAR 0 1
90589: PPUSH
90590: CALL_OW 266
90594: PUSH
90595: LD_INT 5
90597: EQUAL
90598: AND
90599: PUSH
90600: LD_VAR 0 2
90604: PPUSH
90605: CALL_OW 110
90609: PUSH
90610: LD_INT 18
90612: NONEQUAL
90613: AND
90614: IFFALSE 90654
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
90616: LD_VAR 0 2
90620: PPUSH
90621: CALL_OW 257
90625: PUSH
90626: LD_INT 5
90628: PUSH
90629: LD_INT 8
90631: PUSH
90632: LD_INT 9
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: LIST
90639: IN
90640: IFFALSE 90654
// SetClass ( unit , 1 ) ;
90642: LD_VAR 0 2
90646: PPUSH
90647: LD_INT 1
90649: PPUSH
90650: CALL_OW 336
// end ;
90654: LD_VAR 0 3
90658: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
90659: LD_INT 0
90661: PPUSH
90662: PPUSH
// if not mc_bases or not skirmish then
90663: LD_EXP 63
90667: NOT
90668: PUSH
90669: LD_EXP 61
90673: NOT
90674: OR
90675: IFFALSE 90679
// exit ;
90677: GO 90795
// if GetLives ( abandoned_vehicle ) > 250 then
90679: LD_VAR 0 2
90683: PPUSH
90684: CALL_OW 256
90688: PUSH
90689: LD_INT 250
90691: GREATER
90692: IFFALSE 90696
// exit ;
90694: GO 90795
// for i = 1 to mc_bases do
90696: LD_ADDR_VAR 0 6
90700: PUSH
90701: DOUBLE
90702: LD_INT 1
90704: DEC
90705: ST_TO_ADDR
90706: LD_EXP 63
90710: PUSH
90711: FOR_TO
90712: IFFALSE 90793
// begin if driver in mc_bases [ i ] then
90714: LD_VAR 0 1
90718: PUSH
90719: LD_EXP 63
90723: PUSH
90724: LD_VAR 0 6
90728: ARRAY
90729: IN
90730: IFFALSE 90791
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
90732: LD_VAR 0 1
90736: PPUSH
90737: LD_EXP 63
90741: PUSH
90742: LD_VAR 0 6
90746: ARRAY
90747: PPUSH
90748: LD_INT 2
90750: PUSH
90751: LD_INT 30
90753: PUSH
90754: LD_INT 0
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 30
90763: PUSH
90764: LD_INT 1
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: LIST
90775: PPUSH
90776: CALL_OW 72
90780: PUSH
90781: LD_INT 1
90783: ARRAY
90784: PPUSH
90785: CALL 55885 0 2
// break ;
90789: GO 90793
// end ; end ;
90791: GO 90711
90793: POP
90794: POP
// end ; end_of_file end_of_file
90795: LD_VAR 0 5
90799: RET
// export globalGameSaveCounter ; every 0 0$1 do
90800: GO 90802
90802: DISABLE
// begin enable ;
90803: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90804: LD_STRING updateTimer(
90806: PUSH
90807: LD_OWVAR 1
90811: STR
90812: PUSH
90813: LD_STRING );
90815: STR
90816: PPUSH
90817: CALL_OW 559
// end ;
90821: END
// every 0 0$1 do
90822: GO 90824
90824: DISABLE
// begin globalGameSaveCounter := 0 ;
90825: LD_ADDR_EXP 108
90829: PUSH
90830: LD_INT 0
90832: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90833: LD_STRING setGameSaveCounter(0)
90835: PPUSH
90836: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90840: LD_STRING initStreamRollete();
90842: PPUSH
90843: CALL_OW 559
// InitStreamMode ;
90847: CALL 92190 0 0
// DefineStreamItems ( false ) ;
90851: LD_INT 0
90853: PPUSH
90854: CALL 92654 0 1
// end ;
90858: END
// export function SOS_MapStart ( ) ; begin
90859: LD_INT 0
90861: PPUSH
// if streamModeActive then
90862: LD_EXP 109
90866: IFFALSE 90875
// DefineStreamItems ( true ) ;
90868: LD_INT 1
90870: PPUSH
90871: CALL 92654 0 1
// UpdateLuaVariables ( ) ;
90875: CALL 90892 0 0
// UpdateFactoryWaypoints ( ) ;
90879: CALL 105656 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90883: CALL 105908 0 0
// end ;
90887: LD_VAR 0 1
90891: RET
// function UpdateLuaVariables ( ) ; begin
90892: LD_INT 0
90894: PPUSH
// if globalGameSaveCounter then
90895: LD_EXP 108
90899: IFFALSE 90933
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90901: LD_ADDR_EXP 108
90905: PUSH
90906: LD_EXP 108
90910: PPUSH
90911: CALL 56369 0 1
90915: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90916: LD_STRING setGameSaveCounter(
90918: PUSH
90919: LD_EXP 108
90923: STR
90924: PUSH
90925: LD_STRING )
90927: STR
90928: PPUSH
90929: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90933: LD_STRING setGameDifficulty(
90935: PUSH
90936: LD_OWVAR 67
90940: STR
90941: PUSH
90942: LD_STRING )
90944: STR
90945: PPUSH
90946: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
90950: LD_STRING displayDifficulty(
90952: PUSH
90953: LD_OWVAR 67
90957: STR
90958: PUSH
90959: LD_STRING )
90961: STR
90962: PPUSH
90963: CALL_OW 559
// end ;
90967: LD_VAR 0 1
90971: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90972: LD_INT 0
90974: PPUSH
// if p2 = stream_mode then
90975: LD_VAR 0 2
90979: PUSH
90980: LD_INT 100
90982: EQUAL
90983: IFFALSE 91986
// begin if not StreamModeActive then
90985: LD_EXP 109
90989: NOT
90990: IFFALSE 91000
// StreamModeActive := true ;
90992: LD_ADDR_EXP 109
90996: PUSH
90997: LD_INT 1
90999: ST_TO_ADDR
// if p3 = 0 then
91000: LD_VAR 0 3
91004: PUSH
91005: LD_INT 0
91007: EQUAL
91008: IFFALSE 91014
// InitStreamMode ;
91010: CALL 92190 0 0
// if p3 = 1 then
91014: LD_VAR 0 3
91018: PUSH
91019: LD_INT 1
91021: EQUAL
91022: IFFALSE 91032
// sRocket := true ;
91024: LD_ADDR_EXP 114
91028: PUSH
91029: LD_INT 1
91031: ST_TO_ADDR
// if p3 = 2 then
91032: LD_VAR 0 3
91036: PUSH
91037: LD_INT 2
91039: EQUAL
91040: IFFALSE 91050
// sSpeed := true ;
91042: LD_ADDR_EXP 113
91046: PUSH
91047: LD_INT 1
91049: ST_TO_ADDR
// if p3 = 3 then
91050: LD_VAR 0 3
91054: PUSH
91055: LD_INT 3
91057: EQUAL
91058: IFFALSE 91068
// sEngine := true ;
91060: LD_ADDR_EXP 115
91064: PUSH
91065: LD_INT 1
91067: ST_TO_ADDR
// if p3 = 4 then
91068: LD_VAR 0 3
91072: PUSH
91073: LD_INT 4
91075: EQUAL
91076: IFFALSE 91086
// sSpec := true ;
91078: LD_ADDR_EXP 112
91082: PUSH
91083: LD_INT 1
91085: ST_TO_ADDR
// if p3 = 5 then
91086: LD_VAR 0 3
91090: PUSH
91091: LD_INT 5
91093: EQUAL
91094: IFFALSE 91104
// sLevel := true ;
91096: LD_ADDR_EXP 116
91100: PUSH
91101: LD_INT 1
91103: ST_TO_ADDR
// if p3 = 6 then
91104: LD_VAR 0 3
91108: PUSH
91109: LD_INT 6
91111: EQUAL
91112: IFFALSE 91122
// sArmoury := true ;
91114: LD_ADDR_EXP 117
91118: PUSH
91119: LD_INT 1
91121: ST_TO_ADDR
// if p3 = 7 then
91122: LD_VAR 0 3
91126: PUSH
91127: LD_INT 7
91129: EQUAL
91130: IFFALSE 91140
// sRadar := true ;
91132: LD_ADDR_EXP 118
91136: PUSH
91137: LD_INT 1
91139: ST_TO_ADDR
// if p3 = 8 then
91140: LD_VAR 0 3
91144: PUSH
91145: LD_INT 8
91147: EQUAL
91148: IFFALSE 91158
// sBunker := true ;
91150: LD_ADDR_EXP 119
91154: PUSH
91155: LD_INT 1
91157: ST_TO_ADDR
// if p3 = 9 then
91158: LD_VAR 0 3
91162: PUSH
91163: LD_INT 9
91165: EQUAL
91166: IFFALSE 91176
// sHack := true ;
91168: LD_ADDR_EXP 120
91172: PUSH
91173: LD_INT 1
91175: ST_TO_ADDR
// if p3 = 10 then
91176: LD_VAR 0 3
91180: PUSH
91181: LD_INT 10
91183: EQUAL
91184: IFFALSE 91194
// sFire := true ;
91186: LD_ADDR_EXP 121
91190: PUSH
91191: LD_INT 1
91193: ST_TO_ADDR
// if p3 = 11 then
91194: LD_VAR 0 3
91198: PUSH
91199: LD_INT 11
91201: EQUAL
91202: IFFALSE 91212
// sRefresh := true ;
91204: LD_ADDR_EXP 122
91208: PUSH
91209: LD_INT 1
91211: ST_TO_ADDR
// if p3 = 12 then
91212: LD_VAR 0 3
91216: PUSH
91217: LD_INT 12
91219: EQUAL
91220: IFFALSE 91230
// sExp := true ;
91222: LD_ADDR_EXP 123
91226: PUSH
91227: LD_INT 1
91229: ST_TO_ADDR
// if p3 = 13 then
91230: LD_VAR 0 3
91234: PUSH
91235: LD_INT 13
91237: EQUAL
91238: IFFALSE 91248
// sDepot := true ;
91240: LD_ADDR_EXP 124
91244: PUSH
91245: LD_INT 1
91247: ST_TO_ADDR
// if p3 = 14 then
91248: LD_VAR 0 3
91252: PUSH
91253: LD_INT 14
91255: EQUAL
91256: IFFALSE 91266
// sFlag := true ;
91258: LD_ADDR_EXP 125
91262: PUSH
91263: LD_INT 1
91265: ST_TO_ADDR
// if p3 = 15 then
91266: LD_VAR 0 3
91270: PUSH
91271: LD_INT 15
91273: EQUAL
91274: IFFALSE 91284
// sKamikadze := true ;
91276: LD_ADDR_EXP 133
91280: PUSH
91281: LD_INT 1
91283: ST_TO_ADDR
// if p3 = 16 then
91284: LD_VAR 0 3
91288: PUSH
91289: LD_INT 16
91291: EQUAL
91292: IFFALSE 91302
// sTroll := true ;
91294: LD_ADDR_EXP 134
91298: PUSH
91299: LD_INT 1
91301: ST_TO_ADDR
// if p3 = 17 then
91302: LD_VAR 0 3
91306: PUSH
91307: LD_INT 17
91309: EQUAL
91310: IFFALSE 91320
// sSlow := true ;
91312: LD_ADDR_EXP 135
91316: PUSH
91317: LD_INT 1
91319: ST_TO_ADDR
// if p3 = 18 then
91320: LD_VAR 0 3
91324: PUSH
91325: LD_INT 18
91327: EQUAL
91328: IFFALSE 91338
// sLack := true ;
91330: LD_ADDR_EXP 136
91334: PUSH
91335: LD_INT 1
91337: ST_TO_ADDR
// if p3 = 19 then
91338: LD_VAR 0 3
91342: PUSH
91343: LD_INT 19
91345: EQUAL
91346: IFFALSE 91356
// sTank := true ;
91348: LD_ADDR_EXP 138
91352: PUSH
91353: LD_INT 1
91355: ST_TO_ADDR
// if p3 = 20 then
91356: LD_VAR 0 3
91360: PUSH
91361: LD_INT 20
91363: EQUAL
91364: IFFALSE 91374
// sRemote := true ;
91366: LD_ADDR_EXP 139
91370: PUSH
91371: LD_INT 1
91373: ST_TO_ADDR
// if p3 = 21 then
91374: LD_VAR 0 3
91378: PUSH
91379: LD_INT 21
91381: EQUAL
91382: IFFALSE 91392
// sPowell := true ;
91384: LD_ADDR_EXP 140
91388: PUSH
91389: LD_INT 1
91391: ST_TO_ADDR
// if p3 = 22 then
91392: LD_VAR 0 3
91396: PUSH
91397: LD_INT 22
91399: EQUAL
91400: IFFALSE 91410
// sTeleport := true ;
91402: LD_ADDR_EXP 143
91406: PUSH
91407: LD_INT 1
91409: ST_TO_ADDR
// if p3 = 23 then
91410: LD_VAR 0 3
91414: PUSH
91415: LD_INT 23
91417: EQUAL
91418: IFFALSE 91428
// sOilTower := true ;
91420: LD_ADDR_EXP 145
91424: PUSH
91425: LD_INT 1
91427: ST_TO_ADDR
// if p3 = 24 then
91428: LD_VAR 0 3
91432: PUSH
91433: LD_INT 24
91435: EQUAL
91436: IFFALSE 91446
// sShovel := true ;
91438: LD_ADDR_EXP 146
91442: PUSH
91443: LD_INT 1
91445: ST_TO_ADDR
// if p3 = 25 then
91446: LD_VAR 0 3
91450: PUSH
91451: LD_INT 25
91453: EQUAL
91454: IFFALSE 91464
// sSheik := true ;
91456: LD_ADDR_EXP 147
91460: PUSH
91461: LD_INT 1
91463: ST_TO_ADDR
// if p3 = 26 then
91464: LD_VAR 0 3
91468: PUSH
91469: LD_INT 26
91471: EQUAL
91472: IFFALSE 91482
// sEarthquake := true ;
91474: LD_ADDR_EXP 149
91478: PUSH
91479: LD_INT 1
91481: ST_TO_ADDR
// if p3 = 27 then
91482: LD_VAR 0 3
91486: PUSH
91487: LD_INT 27
91489: EQUAL
91490: IFFALSE 91500
// sAI := true ;
91492: LD_ADDR_EXP 150
91496: PUSH
91497: LD_INT 1
91499: ST_TO_ADDR
// if p3 = 28 then
91500: LD_VAR 0 3
91504: PUSH
91505: LD_INT 28
91507: EQUAL
91508: IFFALSE 91518
// sCargo := true ;
91510: LD_ADDR_EXP 153
91514: PUSH
91515: LD_INT 1
91517: ST_TO_ADDR
// if p3 = 29 then
91518: LD_VAR 0 3
91522: PUSH
91523: LD_INT 29
91525: EQUAL
91526: IFFALSE 91536
// sDLaser := true ;
91528: LD_ADDR_EXP 154
91532: PUSH
91533: LD_INT 1
91535: ST_TO_ADDR
// if p3 = 30 then
91536: LD_VAR 0 3
91540: PUSH
91541: LD_INT 30
91543: EQUAL
91544: IFFALSE 91554
// sExchange := true ;
91546: LD_ADDR_EXP 155
91550: PUSH
91551: LD_INT 1
91553: ST_TO_ADDR
// if p3 = 31 then
91554: LD_VAR 0 3
91558: PUSH
91559: LD_INT 31
91561: EQUAL
91562: IFFALSE 91572
// sFac := true ;
91564: LD_ADDR_EXP 156
91568: PUSH
91569: LD_INT 1
91571: ST_TO_ADDR
// if p3 = 32 then
91572: LD_VAR 0 3
91576: PUSH
91577: LD_INT 32
91579: EQUAL
91580: IFFALSE 91590
// sPower := true ;
91582: LD_ADDR_EXP 157
91586: PUSH
91587: LD_INT 1
91589: ST_TO_ADDR
// if p3 = 33 then
91590: LD_VAR 0 3
91594: PUSH
91595: LD_INT 33
91597: EQUAL
91598: IFFALSE 91608
// sRandom := true ;
91600: LD_ADDR_EXP 158
91604: PUSH
91605: LD_INT 1
91607: ST_TO_ADDR
// if p3 = 34 then
91608: LD_VAR 0 3
91612: PUSH
91613: LD_INT 34
91615: EQUAL
91616: IFFALSE 91626
// sShield := true ;
91618: LD_ADDR_EXP 159
91622: PUSH
91623: LD_INT 1
91625: ST_TO_ADDR
// if p3 = 35 then
91626: LD_VAR 0 3
91630: PUSH
91631: LD_INT 35
91633: EQUAL
91634: IFFALSE 91644
// sTime := true ;
91636: LD_ADDR_EXP 160
91640: PUSH
91641: LD_INT 1
91643: ST_TO_ADDR
// if p3 = 36 then
91644: LD_VAR 0 3
91648: PUSH
91649: LD_INT 36
91651: EQUAL
91652: IFFALSE 91662
// sTools := true ;
91654: LD_ADDR_EXP 161
91658: PUSH
91659: LD_INT 1
91661: ST_TO_ADDR
// if p3 = 101 then
91662: LD_VAR 0 3
91666: PUSH
91667: LD_INT 101
91669: EQUAL
91670: IFFALSE 91680
// sSold := true ;
91672: LD_ADDR_EXP 126
91676: PUSH
91677: LD_INT 1
91679: ST_TO_ADDR
// if p3 = 102 then
91680: LD_VAR 0 3
91684: PUSH
91685: LD_INT 102
91687: EQUAL
91688: IFFALSE 91698
// sDiff := true ;
91690: LD_ADDR_EXP 127
91694: PUSH
91695: LD_INT 1
91697: ST_TO_ADDR
// if p3 = 103 then
91698: LD_VAR 0 3
91702: PUSH
91703: LD_INT 103
91705: EQUAL
91706: IFFALSE 91716
// sFog := true ;
91708: LD_ADDR_EXP 130
91712: PUSH
91713: LD_INT 1
91715: ST_TO_ADDR
// if p3 = 104 then
91716: LD_VAR 0 3
91720: PUSH
91721: LD_INT 104
91723: EQUAL
91724: IFFALSE 91734
// sReset := true ;
91726: LD_ADDR_EXP 131
91730: PUSH
91731: LD_INT 1
91733: ST_TO_ADDR
// if p3 = 105 then
91734: LD_VAR 0 3
91738: PUSH
91739: LD_INT 105
91741: EQUAL
91742: IFFALSE 91752
// sSun := true ;
91744: LD_ADDR_EXP 132
91748: PUSH
91749: LD_INT 1
91751: ST_TO_ADDR
// if p3 = 106 then
91752: LD_VAR 0 3
91756: PUSH
91757: LD_INT 106
91759: EQUAL
91760: IFFALSE 91770
// sTiger := true ;
91762: LD_ADDR_EXP 128
91766: PUSH
91767: LD_INT 1
91769: ST_TO_ADDR
// if p3 = 107 then
91770: LD_VAR 0 3
91774: PUSH
91775: LD_INT 107
91777: EQUAL
91778: IFFALSE 91788
// sBomb := true ;
91780: LD_ADDR_EXP 129
91784: PUSH
91785: LD_INT 1
91787: ST_TO_ADDR
// if p3 = 108 then
91788: LD_VAR 0 3
91792: PUSH
91793: LD_INT 108
91795: EQUAL
91796: IFFALSE 91806
// sWound := true ;
91798: LD_ADDR_EXP 137
91802: PUSH
91803: LD_INT 1
91805: ST_TO_ADDR
// if p3 = 109 then
91806: LD_VAR 0 3
91810: PUSH
91811: LD_INT 109
91813: EQUAL
91814: IFFALSE 91824
// sBetray := true ;
91816: LD_ADDR_EXP 141
91820: PUSH
91821: LD_INT 1
91823: ST_TO_ADDR
// if p3 = 110 then
91824: LD_VAR 0 3
91828: PUSH
91829: LD_INT 110
91831: EQUAL
91832: IFFALSE 91842
// sContamin := true ;
91834: LD_ADDR_EXP 142
91838: PUSH
91839: LD_INT 1
91841: ST_TO_ADDR
// if p3 = 111 then
91842: LD_VAR 0 3
91846: PUSH
91847: LD_INT 111
91849: EQUAL
91850: IFFALSE 91860
// sOil := true ;
91852: LD_ADDR_EXP 144
91856: PUSH
91857: LD_INT 1
91859: ST_TO_ADDR
// if p3 = 112 then
91860: LD_VAR 0 3
91864: PUSH
91865: LD_INT 112
91867: EQUAL
91868: IFFALSE 91878
// sStu := true ;
91870: LD_ADDR_EXP 148
91874: PUSH
91875: LD_INT 1
91877: ST_TO_ADDR
// if p3 = 113 then
91878: LD_VAR 0 3
91882: PUSH
91883: LD_INT 113
91885: EQUAL
91886: IFFALSE 91896
// sBazooka := true ;
91888: LD_ADDR_EXP 151
91892: PUSH
91893: LD_INT 1
91895: ST_TO_ADDR
// if p3 = 114 then
91896: LD_VAR 0 3
91900: PUSH
91901: LD_INT 114
91903: EQUAL
91904: IFFALSE 91914
// sMortar := true ;
91906: LD_ADDR_EXP 152
91910: PUSH
91911: LD_INT 1
91913: ST_TO_ADDR
// if p3 = 115 then
91914: LD_VAR 0 3
91918: PUSH
91919: LD_INT 115
91921: EQUAL
91922: IFFALSE 91932
// sRanger := true ;
91924: LD_ADDR_EXP 162
91928: PUSH
91929: LD_INT 1
91931: ST_TO_ADDR
// if p3 = 116 then
91932: LD_VAR 0 3
91936: PUSH
91937: LD_INT 116
91939: EQUAL
91940: IFFALSE 91950
// sComputer := true ;
91942: LD_ADDR_EXP 163
91946: PUSH
91947: LD_INT 1
91949: ST_TO_ADDR
// if p3 = 117 then
91950: LD_VAR 0 3
91954: PUSH
91955: LD_INT 117
91957: EQUAL
91958: IFFALSE 91968
// s30 := true ;
91960: LD_ADDR_EXP 164
91964: PUSH
91965: LD_INT 1
91967: ST_TO_ADDR
// if p3 = 118 then
91968: LD_VAR 0 3
91972: PUSH
91973: LD_INT 118
91975: EQUAL
91976: IFFALSE 91986
// s60 := true ;
91978: LD_ADDR_EXP 165
91982: PUSH
91983: LD_INT 1
91985: ST_TO_ADDR
// end ; if p2 = hack_mode then
91986: LD_VAR 0 2
91990: PUSH
91991: LD_INT 101
91993: EQUAL
91994: IFFALSE 92122
// begin case p3 of 1 :
91996: LD_VAR 0 3
92000: PUSH
92001: LD_INT 1
92003: DOUBLE
92004: EQUAL
92005: IFTRUE 92009
92007: GO 92016
92009: POP
// hHackUnlimitedResources ; 2 :
92010: CALL 104269 0 0
92014: GO 92122
92016: LD_INT 2
92018: DOUBLE
92019: EQUAL
92020: IFTRUE 92024
92022: GO 92031
92024: POP
// hHackSetLevel10 ; 3 :
92025: CALL 104402 0 0
92029: GO 92122
92031: LD_INT 3
92033: DOUBLE
92034: EQUAL
92035: IFTRUE 92039
92037: GO 92046
92039: POP
// hHackSetLevel10YourUnits ; 4 :
92040: CALL 104487 0 0
92044: GO 92122
92046: LD_INT 4
92048: DOUBLE
92049: EQUAL
92050: IFTRUE 92054
92052: GO 92061
92054: POP
// hHackInvincible ; 5 :
92055: CALL 104935 0 0
92059: GO 92122
92061: LD_INT 5
92063: DOUBLE
92064: EQUAL
92065: IFTRUE 92069
92067: GO 92076
92069: POP
// hHackInvisible ; 6 :
92070: CALL 105046 0 0
92074: GO 92122
92076: LD_INT 6
92078: DOUBLE
92079: EQUAL
92080: IFTRUE 92084
92082: GO 92091
92084: POP
// hHackChangeYourSide ; 7 :
92085: CALL 105103 0 0
92089: GO 92122
92091: LD_INT 7
92093: DOUBLE
92094: EQUAL
92095: IFTRUE 92099
92097: GO 92106
92099: POP
// hHackChangeUnitSide ; 8 :
92100: CALL 105145 0 0
92104: GO 92122
92106: LD_INT 8
92108: DOUBLE
92109: EQUAL
92110: IFTRUE 92114
92112: GO 92121
92114: POP
// hHackFog ; end ;
92115: CALL 105246 0 0
92119: GO 92122
92121: POP
// end ; if p2 = game_save_mode then
92122: LD_VAR 0 2
92126: PUSH
92127: LD_INT 102
92129: EQUAL
92130: IFFALSE 92185
// begin if p3 = 1 then
92132: LD_VAR 0 3
92136: PUSH
92137: LD_INT 1
92139: EQUAL
92140: IFFALSE 92152
// globalGameSaveCounter := p4 ;
92142: LD_ADDR_EXP 108
92146: PUSH
92147: LD_VAR 0 4
92151: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92152: LD_VAR 0 3
92156: PUSH
92157: LD_INT 2
92159: EQUAL
92160: PUSH
92161: LD_EXP 108
92165: AND
92166: IFFALSE 92185
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92168: LD_STRING setGameSaveCounter(
92170: PUSH
92171: LD_EXP 108
92175: STR
92176: PUSH
92177: LD_STRING )
92179: STR
92180: PPUSH
92181: CALL_OW 559
// end ; end ;
92185: LD_VAR 0 7
92189: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92190: LD_INT 0
92192: PPUSH
// streamModeActive := false ;
92193: LD_ADDR_EXP 109
92197: PUSH
92198: LD_INT 0
92200: ST_TO_ADDR
// normalCounter := 36 ;
92201: LD_ADDR_EXP 110
92205: PUSH
92206: LD_INT 36
92208: ST_TO_ADDR
// hardcoreCounter := 18 ;
92209: LD_ADDR_EXP 111
92213: PUSH
92214: LD_INT 18
92216: ST_TO_ADDR
// sRocket := false ;
92217: LD_ADDR_EXP 114
92221: PUSH
92222: LD_INT 0
92224: ST_TO_ADDR
// sSpeed := false ;
92225: LD_ADDR_EXP 113
92229: PUSH
92230: LD_INT 0
92232: ST_TO_ADDR
// sEngine := false ;
92233: LD_ADDR_EXP 115
92237: PUSH
92238: LD_INT 0
92240: ST_TO_ADDR
// sSpec := false ;
92241: LD_ADDR_EXP 112
92245: PUSH
92246: LD_INT 0
92248: ST_TO_ADDR
// sLevel := false ;
92249: LD_ADDR_EXP 116
92253: PUSH
92254: LD_INT 0
92256: ST_TO_ADDR
// sArmoury := false ;
92257: LD_ADDR_EXP 117
92261: PUSH
92262: LD_INT 0
92264: ST_TO_ADDR
// sRadar := false ;
92265: LD_ADDR_EXP 118
92269: PUSH
92270: LD_INT 0
92272: ST_TO_ADDR
// sBunker := false ;
92273: LD_ADDR_EXP 119
92277: PUSH
92278: LD_INT 0
92280: ST_TO_ADDR
// sHack := false ;
92281: LD_ADDR_EXP 120
92285: PUSH
92286: LD_INT 0
92288: ST_TO_ADDR
// sFire := false ;
92289: LD_ADDR_EXP 121
92293: PUSH
92294: LD_INT 0
92296: ST_TO_ADDR
// sRefresh := false ;
92297: LD_ADDR_EXP 122
92301: PUSH
92302: LD_INT 0
92304: ST_TO_ADDR
// sExp := false ;
92305: LD_ADDR_EXP 123
92309: PUSH
92310: LD_INT 0
92312: ST_TO_ADDR
// sDepot := false ;
92313: LD_ADDR_EXP 124
92317: PUSH
92318: LD_INT 0
92320: ST_TO_ADDR
// sFlag := false ;
92321: LD_ADDR_EXP 125
92325: PUSH
92326: LD_INT 0
92328: ST_TO_ADDR
// sKamikadze := false ;
92329: LD_ADDR_EXP 133
92333: PUSH
92334: LD_INT 0
92336: ST_TO_ADDR
// sTroll := false ;
92337: LD_ADDR_EXP 134
92341: PUSH
92342: LD_INT 0
92344: ST_TO_ADDR
// sSlow := false ;
92345: LD_ADDR_EXP 135
92349: PUSH
92350: LD_INT 0
92352: ST_TO_ADDR
// sLack := false ;
92353: LD_ADDR_EXP 136
92357: PUSH
92358: LD_INT 0
92360: ST_TO_ADDR
// sTank := false ;
92361: LD_ADDR_EXP 138
92365: PUSH
92366: LD_INT 0
92368: ST_TO_ADDR
// sRemote := false ;
92369: LD_ADDR_EXP 139
92373: PUSH
92374: LD_INT 0
92376: ST_TO_ADDR
// sPowell := false ;
92377: LD_ADDR_EXP 140
92381: PUSH
92382: LD_INT 0
92384: ST_TO_ADDR
// sTeleport := false ;
92385: LD_ADDR_EXP 143
92389: PUSH
92390: LD_INT 0
92392: ST_TO_ADDR
// sOilTower := false ;
92393: LD_ADDR_EXP 145
92397: PUSH
92398: LD_INT 0
92400: ST_TO_ADDR
// sShovel := false ;
92401: LD_ADDR_EXP 146
92405: PUSH
92406: LD_INT 0
92408: ST_TO_ADDR
// sSheik := false ;
92409: LD_ADDR_EXP 147
92413: PUSH
92414: LD_INT 0
92416: ST_TO_ADDR
// sEarthquake := false ;
92417: LD_ADDR_EXP 149
92421: PUSH
92422: LD_INT 0
92424: ST_TO_ADDR
// sAI := false ;
92425: LD_ADDR_EXP 150
92429: PUSH
92430: LD_INT 0
92432: ST_TO_ADDR
// sCargo := false ;
92433: LD_ADDR_EXP 153
92437: PUSH
92438: LD_INT 0
92440: ST_TO_ADDR
// sDLaser := false ;
92441: LD_ADDR_EXP 154
92445: PUSH
92446: LD_INT 0
92448: ST_TO_ADDR
// sExchange := false ;
92449: LD_ADDR_EXP 155
92453: PUSH
92454: LD_INT 0
92456: ST_TO_ADDR
// sFac := false ;
92457: LD_ADDR_EXP 156
92461: PUSH
92462: LD_INT 0
92464: ST_TO_ADDR
// sPower := false ;
92465: LD_ADDR_EXP 157
92469: PUSH
92470: LD_INT 0
92472: ST_TO_ADDR
// sRandom := false ;
92473: LD_ADDR_EXP 158
92477: PUSH
92478: LD_INT 0
92480: ST_TO_ADDR
// sShield := false ;
92481: LD_ADDR_EXP 159
92485: PUSH
92486: LD_INT 0
92488: ST_TO_ADDR
// sTime := false ;
92489: LD_ADDR_EXP 160
92493: PUSH
92494: LD_INT 0
92496: ST_TO_ADDR
// sTools := false ;
92497: LD_ADDR_EXP 161
92501: PUSH
92502: LD_INT 0
92504: ST_TO_ADDR
// sSold := false ;
92505: LD_ADDR_EXP 126
92509: PUSH
92510: LD_INT 0
92512: ST_TO_ADDR
// sDiff := false ;
92513: LD_ADDR_EXP 127
92517: PUSH
92518: LD_INT 0
92520: ST_TO_ADDR
// sFog := false ;
92521: LD_ADDR_EXP 130
92525: PUSH
92526: LD_INT 0
92528: ST_TO_ADDR
// sReset := false ;
92529: LD_ADDR_EXP 131
92533: PUSH
92534: LD_INT 0
92536: ST_TO_ADDR
// sSun := false ;
92537: LD_ADDR_EXP 132
92541: PUSH
92542: LD_INT 0
92544: ST_TO_ADDR
// sTiger := false ;
92545: LD_ADDR_EXP 128
92549: PUSH
92550: LD_INT 0
92552: ST_TO_ADDR
// sBomb := false ;
92553: LD_ADDR_EXP 129
92557: PUSH
92558: LD_INT 0
92560: ST_TO_ADDR
// sWound := false ;
92561: LD_ADDR_EXP 137
92565: PUSH
92566: LD_INT 0
92568: ST_TO_ADDR
// sBetray := false ;
92569: LD_ADDR_EXP 141
92573: PUSH
92574: LD_INT 0
92576: ST_TO_ADDR
// sContamin := false ;
92577: LD_ADDR_EXP 142
92581: PUSH
92582: LD_INT 0
92584: ST_TO_ADDR
// sOil := false ;
92585: LD_ADDR_EXP 144
92589: PUSH
92590: LD_INT 0
92592: ST_TO_ADDR
// sStu := false ;
92593: LD_ADDR_EXP 148
92597: PUSH
92598: LD_INT 0
92600: ST_TO_ADDR
// sBazooka := false ;
92601: LD_ADDR_EXP 151
92605: PUSH
92606: LD_INT 0
92608: ST_TO_ADDR
// sMortar := false ;
92609: LD_ADDR_EXP 152
92613: PUSH
92614: LD_INT 0
92616: ST_TO_ADDR
// sRanger := false ;
92617: LD_ADDR_EXP 162
92621: PUSH
92622: LD_INT 0
92624: ST_TO_ADDR
// sComputer := false ;
92625: LD_ADDR_EXP 163
92629: PUSH
92630: LD_INT 0
92632: ST_TO_ADDR
// s30 := false ;
92633: LD_ADDR_EXP 164
92637: PUSH
92638: LD_INT 0
92640: ST_TO_ADDR
// s60 := false ;
92641: LD_ADDR_EXP 165
92645: PUSH
92646: LD_INT 0
92648: ST_TO_ADDR
// end ;
92649: LD_VAR 0 1
92653: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92654: LD_INT 0
92656: PPUSH
92657: PPUSH
92658: PPUSH
92659: PPUSH
92660: PPUSH
92661: PPUSH
92662: PPUSH
// result := [ ] ;
92663: LD_ADDR_VAR 0 2
92667: PUSH
92668: EMPTY
92669: ST_TO_ADDR
// if campaign_id = 1 then
92670: LD_OWVAR 69
92674: PUSH
92675: LD_INT 1
92677: EQUAL
92678: IFFALSE 95844
// begin case mission_number of 1 :
92680: LD_OWVAR 70
92684: PUSH
92685: LD_INT 1
92687: DOUBLE
92688: EQUAL
92689: IFTRUE 92693
92691: GO 92769
92693: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92694: LD_ADDR_VAR 0 2
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 4
92704: PUSH
92705: LD_INT 11
92707: PUSH
92708: LD_INT 12
92710: PUSH
92711: LD_INT 15
92713: PUSH
92714: LD_INT 16
92716: PUSH
92717: LD_INT 22
92719: PUSH
92720: LD_INT 23
92722: PUSH
92723: LD_INT 26
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 101
92739: PUSH
92740: LD_INT 102
92742: PUSH
92743: LD_INT 106
92745: PUSH
92746: LD_INT 116
92748: PUSH
92749: LD_INT 117
92751: PUSH
92752: LD_INT 118
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: ST_TO_ADDR
92767: GO 95842
92769: LD_INT 2
92771: DOUBLE
92772: EQUAL
92773: IFTRUE 92777
92775: GO 92861
92777: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92778: LD_ADDR_VAR 0 2
92782: PUSH
92783: LD_INT 2
92785: PUSH
92786: LD_INT 4
92788: PUSH
92789: LD_INT 11
92791: PUSH
92792: LD_INT 12
92794: PUSH
92795: LD_INT 15
92797: PUSH
92798: LD_INT 16
92800: PUSH
92801: LD_INT 22
92803: PUSH
92804: LD_INT 23
92806: PUSH
92807: LD_INT 26
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 101
92823: PUSH
92824: LD_INT 102
92826: PUSH
92827: LD_INT 105
92829: PUSH
92830: LD_INT 106
92832: PUSH
92833: LD_INT 108
92835: PUSH
92836: LD_INT 116
92838: PUSH
92839: LD_INT 117
92841: PUSH
92842: LD_INT 118
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: ST_TO_ADDR
92859: GO 95842
92861: LD_INT 3
92863: DOUBLE
92864: EQUAL
92865: IFTRUE 92869
92867: GO 92957
92869: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92870: LD_ADDR_VAR 0 2
92874: PUSH
92875: LD_INT 2
92877: PUSH
92878: LD_INT 4
92880: PUSH
92881: LD_INT 5
92883: PUSH
92884: LD_INT 11
92886: PUSH
92887: LD_INT 12
92889: PUSH
92890: LD_INT 15
92892: PUSH
92893: LD_INT 16
92895: PUSH
92896: LD_INT 22
92898: PUSH
92899: LD_INT 26
92901: PUSH
92902: LD_INT 36
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 101
92919: PUSH
92920: LD_INT 102
92922: PUSH
92923: LD_INT 105
92925: PUSH
92926: LD_INT 106
92928: PUSH
92929: LD_INT 108
92931: PUSH
92932: LD_INT 116
92934: PUSH
92935: LD_INT 117
92937: PUSH
92938: LD_INT 118
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: ST_TO_ADDR
92955: GO 95842
92957: LD_INT 4
92959: DOUBLE
92960: EQUAL
92961: IFTRUE 92965
92963: GO 93061
92965: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92966: LD_ADDR_VAR 0 2
92970: PUSH
92971: LD_INT 2
92973: PUSH
92974: LD_INT 4
92976: PUSH
92977: LD_INT 5
92979: PUSH
92980: LD_INT 8
92982: PUSH
92983: LD_INT 11
92985: PUSH
92986: LD_INT 12
92988: PUSH
92989: LD_INT 15
92991: PUSH
92992: LD_INT 16
92994: PUSH
92995: LD_INT 22
92997: PUSH
92998: LD_INT 23
93000: PUSH
93001: LD_INT 26
93003: PUSH
93004: LD_INT 36
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 101
93023: PUSH
93024: LD_INT 102
93026: PUSH
93027: LD_INT 105
93029: PUSH
93030: LD_INT 106
93032: PUSH
93033: LD_INT 108
93035: PUSH
93036: LD_INT 116
93038: PUSH
93039: LD_INT 117
93041: PUSH
93042: LD_INT 118
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: ST_TO_ADDR
93059: GO 95842
93061: LD_INT 5
93063: DOUBLE
93064: EQUAL
93065: IFTRUE 93069
93067: GO 93181
93069: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93070: LD_ADDR_VAR 0 2
93074: PUSH
93075: LD_INT 2
93077: PUSH
93078: LD_INT 4
93080: PUSH
93081: LD_INT 5
93083: PUSH
93084: LD_INT 6
93086: PUSH
93087: LD_INT 8
93089: PUSH
93090: LD_INT 11
93092: PUSH
93093: LD_INT 12
93095: PUSH
93096: LD_INT 15
93098: PUSH
93099: LD_INT 16
93101: PUSH
93102: LD_INT 22
93104: PUSH
93105: LD_INT 23
93107: PUSH
93108: LD_INT 25
93110: PUSH
93111: LD_INT 26
93113: PUSH
93114: LD_INT 36
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: PUSH
93133: LD_INT 101
93135: PUSH
93136: LD_INT 102
93138: PUSH
93139: LD_INT 105
93141: PUSH
93142: LD_INT 106
93144: PUSH
93145: LD_INT 108
93147: PUSH
93148: LD_INT 109
93150: PUSH
93151: LD_INT 112
93153: PUSH
93154: LD_INT 116
93156: PUSH
93157: LD_INT 117
93159: PUSH
93160: LD_INT 118
93162: PUSH
93163: EMPTY
93164: LIST
93165: LIST
93166: LIST
93167: LIST
93168: LIST
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: ST_TO_ADDR
93179: GO 95842
93181: LD_INT 6
93183: DOUBLE
93184: EQUAL
93185: IFTRUE 93189
93187: GO 93321
93189: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93190: LD_ADDR_VAR 0 2
93194: PUSH
93195: LD_INT 2
93197: PUSH
93198: LD_INT 4
93200: PUSH
93201: LD_INT 5
93203: PUSH
93204: LD_INT 6
93206: PUSH
93207: LD_INT 8
93209: PUSH
93210: LD_INT 11
93212: PUSH
93213: LD_INT 12
93215: PUSH
93216: LD_INT 15
93218: PUSH
93219: LD_INT 16
93221: PUSH
93222: LD_INT 20
93224: PUSH
93225: LD_INT 21
93227: PUSH
93228: LD_INT 22
93230: PUSH
93231: LD_INT 23
93233: PUSH
93234: LD_INT 25
93236: PUSH
93237: LD_INT 26
93239: PUSH
93240: LD_INT 30
93242: PUSH
93243: LD_INT 31
93245: PUSH
93246: LD_INT 32
93248: PUSH
93249: LD_INT 36
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 101
93275: PUSH
93276: LD_INT 102
93278: PUSH
93279: LD_INT 105
93281: PUSH
93282: LD_INT 106
93284: PUSH
93285: LD_INT 108
93287: PUSH
93288: LD_INT 109
93290: PUSH
93291: LD_INT 112
93293: PUSH
93294: LD_INT 116
93296: PUSH
93297: LD_INT 117
93299: PUSH
93300: LD_INT 118
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: ST_TO_ADDR
93319: GO 95842
93321: LD_INT 7
93323: DOUBLE
93324: EQUAL
93325: IFTRUE 93329
93327: GO 93441
93329: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93330: LD_ADDR_VAR 0 2
93334: PUSH
93335: LD_INT 2
93337: PUSH
93338: LD_INT 4
93340: PUSH
93341: LD_INT 5
93343: PUSH
93344: LD_INT 7
93346: PUSH
93347: LD_INT 11
93349: PUSH
93350: LD_INT 12
93352: PUSH
93353: LD_INT 15
93355: PUSH
93356: LD_INT 16
93358: PUSH
93359: LD_INT 20
93361: PUSH
93362: LD_INT 21
93364: PUSH
93365: LD_INT 22
93367: PUSH
93368: LD_INT 23
93370: PUSH
93371: LD_INT 25
93373: PUSH
93374: LD_INT 26
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 101
93395: PUSH
93396: LD_INT 102
93398: PUSH
93399: LD_INT 103
93401: PUSH
93402: LD_INT 105
93404: PUSH
93405: LD_INT 106
93407: PUSH
93408: LD_INT 108
93410: PUSH
93411: LD_INT 112
93413: PUSH
93414: LD_INT 116
93416: PUSH
93417: LD_INT 117
93419: PUSH
93420: LD_INT 118
93422: PUSH
93423: EMPTY
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: ST_TO_ADDR
93439: GO 95842
93441: LD_INT 8
93443: DOUBLE
93444: EQUAL
93445: IFTRUE 93449
93447: GO 93589
93449: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93450: LD_ADDR_VAR 0 2
93454: PUSH
93455: LD_INT 2
93457: PUSH
93458: LD_INT 4
93460: PUSH
93461: LD_INT 5
93463: PUSH
93464: LD_INT 6
93466: PUSH
93467: LD_INT 7
93469: PUSH
93470: LD_INT 8
93472: PUSH
93473: LD_INT 11
93475: PUSH
93476: LD_INT 12
93478: PUSH
93479: LD_INT 15
93481: PUSH
93482: LD_INT 16
93484: PUSH
93485: LD_INT 20
93487: PUSH
93488: LD_INT 21
93490: PUSH
93491: LD_INT 22
93493: PUSH
93494: LD_INT 23
93496: PUSH
93497: LD_INT 25
93499: PUSH
93500: LD_INT 26
93502: PUSH
93503: LD_INT 30
93505: PUSH
93506: LD_INT 31
93508: PUSH
93509: LD_INT 32
93511: PUSH
93512: LD_INT 36
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 101
93539: PUSH
93540: LD_INT 102
93542: PUSH
93543: LD_INT 103
93545: PUSH
93546: LD_INT 105
93548: PUSH
93549: LD_INT 106
93551: PUSH
93552: LD_INT 108
93554: PUSH
93555: LD_INT 109
93557: PUSH
93558: LD_INT 112
93560: PUSH
93561: LD_INT 116
93563: PUSH
93564: LD_INT 117
93566: PUSH
93567: LD_INT 118
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: ST_TO_ADDR
93587: GO 95842
93589: LD_INT 9
93591: DOUBLE
93592: EQUAL
93593: IFTRUE 93597
93595: GO 93745
93597: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93598: LD_ADDR_VAR 0 2
93602: PUSH
93603: LD_INT 2
93605: PUSH
93606: LD_INT 4
93608: PUSH
93609: LD_INT 5
93611: PUSH
93612: LD_INT 6
93614: PUSH
93615: LD_INT 7
93617: PUSH
93618: LD_INT 8
93620: PUSH
93621: LD_INT 11
93623: PUSH
93624: LD_INT 12
93626: PUSH
93627: LD_INT 15
93629: PUSH
93630: LD_INT 16
93632: PUSH
93633: LD_INT 20
93635: PUSH
93636: LD_INT 21
93638: PUSH
93639: LD_INT 22
93641: PUSH
93642: LD_INT 23
93644: PUSH
93645: LD_INT 25
93647: PUSH
93648: LD_INT 26
93650: PUSH
93651: LD_INT 28
93653: PUSH
93654: LD_INT 30
93656: PUSH
93657: LD_INT 31
93659: PUSH
93660: LD_INT 32
93662: PUSH
93663: LD_INT 36
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 101
93691: PUSH
93692: LD_INT 102
93694: PUSH
93695: LD_INT 103
93697: PUSH
93698: LD_INT 105
93700: PUSH
93701: LD_INT 106
93703: PUSH
93704: LD_INT 108
93706: PUSH
93707: LD_INT 109
93709: PUSH
93710: LD_INT 112
93712: PUSH
93713: LD_INT 114
93715: PUSH
93716: LD_INT 116
93718: PUSH
93719: LD_INT 117
93721: PUSH
93722: LD_INT 118
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: ST_TO_ADDR
93743: GO 95842
93745: LD_INT 10
93747: DOUBLE
93748: EQUAL
93749: IFTRUE 93753
93751: GO 93949
93753: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93754: LD_ADDR_VAR 0 2
93758: PUSH
93759: LD_INT 2
93761: PUSH
93762: LD_INT 4
93764: PUSH
93765: LD_INT 5
93767: PUSH
93768: LD_INT 6
93770: PUSH
93771: LD_INT 7
93773: PUSH
93774: LD_INT 8
93776: PUSH
93777: LD_INT 9
93779: PUSH
93780: LD_INT 10
93782: PUSH
93783: LD_INT 11
93785: PUSH
93786: LD_INT 12
93788: PUSH
93789: LD_INT 13
93791: PUSH
93792: LD_INT 14
93794: PUSH
93795: LD_INT 15
93797: PUSH
93798: LD_INT 16
93800: PUSH
93801: LD_INT 17
93803: PUSH
93804: LD_INT 18
93806: PUSH
93807: LD_INT 19
93809: PUSH
93810: LD_INT 20
93812: PUSH
93813: LD_INT 21
93815: PUSH
93816: LD_INT 22
93818: PUSH
93819: LD_INT 23
93821: PUSH
93822: LD_INT 24
93824: PUSH
93825: LD_INT 25
93827: PUSH
93828: LD_INT 26
93830: PUSH
93831: LD_INT 28
93833: PUSH
93834: LD_INT 30
93836: PUSH
93837: LD_INT 31
93839: PUSH
93840: LD_INT 32
93842: PUSH
93843: LD_INT 36
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 101
93879: PUSH
93880: LD_INT 102
93882: PUSH
93883: LD_INT 103
93885: PUSH
93886: LD_INT 104
93888: PUSH
93889: LD_INT 105
93891: PUSH
93892: LD_INT 106
93894: PUSH
93895: LD_INT 107
93897: PUSH
93898: LD_INT 108
93900: PUSH
93901: LD_INT 109
93903: PUSH
93904: LD_INT 110
93906: PUSH
93907: LD_INT 111
93909: PUSH
93910: LD_INT 112
93912: PUSH
93913: LD_INT 114
93915: PUSH
93916: LD_INT 116
93918: PUSH
93919: LD_INT 117
93921: PUSH
93922: LD_INT 118
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: PUSH
93943: EMPTY
93944: LIST
93945: LIST
93946: ST_TO_ADDR
93947: GO 95842
93949: LD_INT 11
93951: DOUBLE
93952: EQUAL
93953: IFTRUE 93957
93955: GO 94161
93957: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93958: LD_ADDR_VAR 0 2
93962: PUSH
93963: LD_INT 2
93965: PUSH
93966: LD_INT 3
93968: PUSH
93969: LD_INT 4
93971: PUSH
93972: LD_INT 5
93974: PUSH
93975: LD_INT 6
93977: PUSH
93978: LD_INT 7
93980: PUSH
93981: LD_INT 8
93983: PUSH
93984: LD_INT 9
93986: PUSH
93987: LD_INT 10
93989: PUSH
93990: LD_INT 11
93992: PUSH
93993: LD_INT 12
93995: PUSH
93996: LD_INT 13
93998: PUSH
93999: LD_INT 14
94001: PUSH
94002: LD_INT 15
94004: PUSH
94005: LD_INT 16
94007: PUSH
94008: LD_INT 17
94010: PUSH
94011: LD_INT 18
94013: PUSH
94014: LD_INT 19
94016: PUSH
94017: LD_INT 20
94019: PUSH
94020: LD_INT 21
94022: PUSH
94023: LD_INT 22
94025: PUSH
94026: LD_INT 23
94028: PUSH
94029: LD_INT 24
94031: PUSH
94032: LD_INT 25
94034: PUSH
94035: LD_INT 26
94037: PUSH
94038: LD_INT 28
94040: PUSH
94041: LD_INT 30
94043: PUSH
94044: LD_INT 31
94046: PUSH
94047: LD_INT 32
94049: PUSH
94050: LD_INT 34
94052: PUSH
94053: LD_INT 36
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 101
94091: PUSH
94092: LD_INT 102
94094: PUSH
94095: LD_INT 103
94097: PUSH
94098: LD_INT 104
94100: PUSH
94101: LD_INT 105
94103: PUSH
94104: LD_INT 106
94106: PUSH
94107: LD_INT 107
94109: PUSH
94110: LD_INT 108
94112: PUSH
94113: LD_INT 109
94115: PUSH
94116: LD_INT 110
94118: PUSH
94119: LD_INT 111
94121: PUSH
94122: LD_INT 112
94124: PUSH
94125: LD_INT 114
94127: PUSH
94128: LD_INT 116
94130: PUSH
94131: LD_INT 117
94133: PUSH
94134: LD_INT 118
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: ST_TO_ADDR
94159: GO 95842
94161: LD_INT 12
94163: DOUBLE
94164: EQUAL
94165: IFTRUE 94169
94167: GO 94389
94169: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: LD_INT 2
94180: PUSH
94181: LD_INT 3
94183: PUSH
94184: LD_INT 4
94186: PUSH
94187: LD_INT 5
94189: PUSH
94190: LD_INT 6
94192: PUSH
94193: LD_INT 7
94195: PUSH
94196: LD_INT 8
94198: PUSH
94199: LD_INT 9
94201: PUSH
94202: LD_INT 10
94204: PUSH
94205: LD_INT 11
94207: PUSH
94208: LD_INT 12
94210: PUSH
94211: LD_INT 13
94213: PUSH
94214: LD_INT 14
94216: PUSH
94217: LD_INT 15
94219: PUSH
94220: LD_INT 16
94222: PUSH
94223: LD_INT 17
94225: PUSH
94226: LD_INT 18
94228: PUSH
94229: LD_INT 19
94231: PUSH
94232: LD_INT 20
94234: PUSH
94235: LD_INT 21
94237: PUSH
94238: LD_INT 22
94240: PUSH
94241: LD_INT 23
94243: PUSH
94244: LD_INT 24
94246: PUSH
94247: LD_INT 25
94249: PUSH
94250: LD_INT 26
94252: PUSH
94253: LD_INT 27
94255: PUSH
94256: LD_INT 28
94258: PUSH
94259: LD_INT 30
94261: PUSH
94262: LD_INT 31
94264: PUSH
94265: LD_INT 32
94267: PUSH
94268: LD_INT 33
94270: PUSH
94271: LD_INT 34
94273: PUSH
94274: LD_INT 36
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 101
94315: PUSH
94316: LD_INT 102
94318: PUSH
94319: LD_INT 103
94321: PUSH
94322: LD_INT 104
94324: PUSH
94325: LD_INT 105
94327: PUSH
94328: LD_INT 106
94330: PUSH
94331: LD_INT 107
94333: PUSH
94334: LD_INT 108
94336: PUSH
94337: LD_INT 109
94339: PUSH
94340: LD_INT 110
94342: PUSH
94343: LD_INT 111
94345: PUSH
94346: LD_INT 112
94348: PUSH
94349: LD_INT 113
94351: PUSH
94352: LD_INT 114
94354: PUSH
94355: LD_INT 116
94357: PUSH
94358: LD_INT 117
94360: PUSH
94361: LD_INT 118
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: ST_TO_ADDR
94387: GO 95842
94389: LD_INT 13
94391: DOUBLE
94392: EQUAL
94393: IFTRUE 94397
94395: GO 94605
94397: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94398: LD_ADDR_VAR 0 2
94402: PUSH
94403: LD_INT 1
94405: PUSH
94406: LD_INT 2
94408: PUSH
94409: LD_INT 3
94411: PUSH
94412: LD_INT 4
94414: PUSH
94415: LD_INT 5
94417: PUSH
94418: LD_INT 8
94420: PUSH
94421: LD_INT 9
94423: PUSH
94424: LD_INT 10
94426: PUSH
94427: LD_INT 11
94429: PUSH
94430: LD_INT 12
94432: PUSH
94433: LD_INT 14
94435: PUSH
94436: LD_INT 15
94438: PUSH
94439: LD_INT 16
94441: PUSH
94442: LD_INT 17
94444: PUSH
94445: LD_INT 18
94447: PUSH
94448: LD_INT 19
94450: PUSH
94451: LD_INT 20
94453: PUSH
94454: LD_INT 21
94456: PUSH
94457: LD_INT 22
94459: PUSH
94460: LD_INT 23
94462: PUSH
94463: LD_INT 24
94465: PUSH
94466: LD_INT 25
94468: PUSH
94469: LD_INT 26
94471: PUSH
94472: LD_INT 27
94474: PUSH
94475: LD_INT 28
94477: PUSH
94478: LD_INT 30
94480: PUSH
94481: LD_INT 31
94483: PUSH
94484: LD_INT 32
94486: PUSH
94487: LD_INT 33
94489: PUSH
94490: LD_INT 34
94492: PUSH
94493: LD_INT 36
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 101
94531: PUSH
94532: LD_INT 102
94534: PUSH
94535: LD_INT 103
94537: PUSH
94538: LD_INT 104
94540: PUSH
94541: LD_INT 105
94543: PUSH
94544: LD_INT 106
94546: PUSH
94547: LD_INT 107
94549: PUSH
94550: LD_INT 108
94552: PUSH
94553: LD_INT 109
94555: PUSH
94556: LD_INT 110
94558: PUSH
94559: LD_INT 111
94561: PUSH
94562: LD_INT 112
94564: PUSH
94565: LD_INT 113
94567: PUSH
94568: LD_INT 114
94570: PUSH
94571: LD_INT 116
94573: PUSH
94574: LD_INT 117
94576: PUSH
94577: LD_INT 118
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: ST_TO_ADDR
94603: GO 95842
94605: LD_INT 14
94607: DOUBLE
94608: EQUAL
94609: IFTRUE 94613
94611: GO 94837
94613: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94614: LD_ADDR_VAR 0 2
94618: PUSH
94619: LD_INT 1
94621: PUSH
94622: LD_INT 2
94624: PUSH
94625: LD_INT 3
94627: PUSH
94628: LD_INT 4
94630: PUSH
94631: LD_INT 5
94633: PUSH
94634: LD_INT 6
94636: PUSH
94637: LD_INT 7
94639: PUSH
94640: LD_INT 8
94642: PUSH
94643: LD_INT 9
94645: PUSH
94646: LD_INT 10
94648: PUSH
94649: LD_INT 11
94651: PUSH
94652: LD_INT 12
94654: PUSH
94655: LD_INT 13
94657: PUSH
94658: LD_INT 14
94660: PUSH
94661: LD_INT 15
94663: PUSH
94664: LD_INT 16
94666: PUSH
94667: LD_INT 17
94669: PUSH
94670: LD_INT 18
94672: PUSH
94673: LD_INT 19
94675: PUSH
94676: LD_INT 20
94678: PUSH
94679: LD_INT 21
94681: PUSH
94682: LD_INT 22
94684: PUSH
94685: LD_INT 23
94687: PUSH
94688: LD_INT 24
94690: PUSH
94691: LD_INT 25
94693: PUSH
94694: LD_INT 26
94696: PUSH
94697: LD_INT 27
94699: PUSH
94700: LD_INT 28
94702: PUSH
94703: LD_INT 29
94705: PUSH
94706: LD_INT 30
94708: PUSH
94709: LD_INT 31
94711: PUSH
94712: LD_INT 32
94714: PUSH
94715: LD_INT 33
94717: PUSH
94718: LD_INT 34
94720: PUSH
94721: LD_INT 36
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: PUSH
94761: LD_INT 101
94763: PUSH
94764: LD_INT 102
94766: PUSH
94767: LD_INT 103
94769: PUSH
94770: LD_INT 104
94772: PUSH
94773: LD_INT 105
94775: PUSH
94776: LD_INT 106
94778: PUSH
94779: LD_INT 107
94781: PUSH
94782: LD_INT 108
94784: PUSH
94785: LD_INT 109
94787: PUSH
94788: LD_INT 110
94790: PUSH
94791: LD_INT 111
94793: PUSH
94794: LD_INT 112
94796: PUSH
94797: LD_INT 113
94799: PUSH
94800: LD_INT 114
94802: PUSH
94803: LD_INT 116
94805: PUSH
94806: LD_INT 117
94808: PUSH
94809: LD_INT 118
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: ST_TO_ADDR
94835: GO 95842
94837: LD_INT 15
94839: DOUBLE
94840: EQUAL
94841: IFTRUE 94845
94843: GO 95069
94845: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94846: LD_ADDR_VAR 0 2
94850: PUSH
94851: LD_INT 1
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: LD_INT 3
94859: PUSH
94860: LD_INT 4
94862: PUSH
94863: LD_INT 5
94865: PUSH
94866: LD_INT 6
94868: PUSH
94869: LD_INT 7
94871: PUSH
94872: LD_INT 8
94874: PUSH
94875: LD_INT 9
94877: PUSH
94878: LD_INT 10
94880: PUSH
94881: LD_INT 11
94883: PUSH
94884: LD_INT 12
94886: PUSH
94887: LD_INT 13
94889: PUSH
94890: LD_INT 14
94892: PUSH
94893: LD_INT 15
94895: PUSH
94896: LD_INT 16
94898: PUSH
94899: LD_INT 17
94901: PUSH
94902: LD_INT 18
94904: PUSH
94905: LD_INT 19
94907: PUSH
94908: LD_INT 20
94910: PUSH
94911: LD_INT 21
94913: PUSH
94914: LD_INT 22
94916: PUSH
94917: LD_INT 23
94919: PUSH
94920: LD_INT 24
94922: PUSH
94923: LD_INT 25
94925: PUSH
94926: LD_INT 26
94928: PUSH
94929: LD_INT 27
94931: PUSH
94932: LD_INT 28
94934: PUSH
94935: LD_INT 29
94937: PUSH
94938: LD_INT 30
94940: PUSH
94941: LD_INT 31
94943: PUSH
94944: LD_INT 32
94946: PUSH
94947: LD_INT 33
94949: PUSH
94950: LD_INT 34
94952: PUSH
94953: LD_INT 36
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 101
94995: PUSH
94996: LD_INT 102
94998: PUSH
94999: LD_INT 103
95001: PUSH
95002: LD_INT 104
95004: PUSH
95005: LD_INT 105
95007: PUSH
95008: LD_INT 106
95010: PUSH
95011: LD_INT 107
95013: PUSH
95014: LD_INT 108
95016: PUSH
95017: LD_INT 109
95019: PUSH
95020: LD_INT 110
95022: PUSH
95023: LD_INT 111
95025: PUSH
95026: LD_INT 112
95028: PUSH
95029: LD_INT 113
95031: PUSH
95032: LD_INT 114
95034: PUSH
95035: LD_INT 116
95037: PUSH
95038: LD_INT 117
95040: PUSH
95041: LD_INT 118
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: ST_TO_ADDR
95067: GO 95842
95069: LD_INT 16
95071: DOUBLE
95072: EQUAL
95073: IFTRUE 95077
95075: GO 95213
95077: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95078: LD_ADDR_VAR 0 2
95082: PUSH
95083: LD_INT 2
95085: PUSH
95086: LD_INT 4
95088: PUSH
95089: LD_INT 5
95091: PUSH
95092: LD_INT 7
95094: PUSH
95095: LD_INT 11
95097: PUSH
95098: LD_INT 12
95100: PUSH
95101: LD_INT 15
95103: PUSH
95104: LD_INT 16
95106: PUSH
95107: LD_INT 20
95109: PUSH
95110: LD_INT 21
95112: PUSH
95113: LD_INT 22
95115: PUSH
95116: LD_INT 23
95118: PUSH
95119: LD_INT 25
95121: PUSH
95122: LD_INT 26
95124: PUSH
95125: LD_INT 30
95127: PUSH
95128: LD_INT 31
95130: PUSH
95131: LD_INT 32
95133: PUSH
95134: LD_INT 33
95136: PUSH
95137: LD_INT 34
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 101
95163: PUSH
95164: LD_INT 102
95166: PUSH
95167: LD_INT 103
95169: PUSH
95170: LD_INT 106
95172: PUSH
95173: LD_INT 108
95175: PUSH
95176: LD_INT 112
95178: PUSH
95179: LD_INT 113
95181: PUSH
95182: LD_INT 114
95184: PUSH
95185: LD_INT 116
95187: PUSH
95188: LD_INT 117
95190: PUSH
95191: LD_INT 118
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: ST_TO_ADDR
95211: GO 95842
95213: LD_INT 17
95215: DOUBLE
95216: EQUAL
95217: IFTRUE 95221
95219: GO 95445
95221: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95222: LD_ADDR_VAR 0 2
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: LD_INT 2
95232: PUSH
95233: LD_INT 3
95235: PUSH
95236: LD_INT 4
95238: PUSH
95239: LD_INT 5
95241: PUSH
95242: LD_INT 6
95244: PUSH
95245: LD_INT 7
95247: PUSH
95248: LD_INT 8
95250: PUSH
95251: LD_INT 9
95253: PUSH
95254: LD_INT 10
95256: PUSH
95257: LD_INT 11
95259: PUSH
95260: LD_INT 12
95262: PUSH
95263: LD_INT 13
95265: PUSH
95266: LD_INT 14
95268: PUSH
95269: LD_INT 15
95271: PUSH
95272: LD_INT 16
95274: PUSH
95275: LD_INT 17
95277: PUSH
95278: LD_INT 18
95280: PUSH
95281: LD_INT 19
95283: PUSH
95284: LD_INT 20
95286: PUSH
95287: LD_INT 21
95289: PUSH
95290: LD_INT 22
95292: PUSH
95293: LD_INT 23
95295: PUSH
95296: LD_INT 24
95298: PUSH
95299: LD_INT 25
95301: PUSH
95302: LD_INT 26
95304: PUSH
95305: LD_INT 27
95307: PUSH
95308: LD_INT 28
95310: PUSH
95311: LD_INT 29
95313: PUSH
95314: LD_INT 30
95316: PUSH
95317: LD_INT 31
95319: PUSH
95320: LD_INT 32
95322: PUSH
95323: LD_INT 33
95325: PUSH
95326: LD_INT 34
95328: PUSH
95329: LD_INT 36
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 101
95371: PUSH
95372: LD_INT 102
95374: PUSH
95375: LD_INT 103
95377: PUSH
95378: LD_INT 104
95380: PUSH
95381: LD_INT 105
95383: PUSH
95384: LD_INT 106
95386: PUSH
95387: LD_INT 107
95389: PUSH
95390: LD_INT 108
95392: PUSH
95393: LD_INT 109
95395: PUSH
95396: LD_INT 110
95398: PUSH
95399: LD_INT 111
95401: PUSH
95402: LD_INT 112
95404: PUSH
95405: LD_INT 113
95407: PUSH
95408: LD_INT 114
95410: PUSH
95411: LD_INT 116
95413: PUSH
95414: LD_INT 117
95416: PUSH
95417: LD_INT 118
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: ST_TO_ADDR
95443: GO 95842
95445: LD_INT 18
95447: DOUBLE
95448: EQUAL
95449: IFTRUE 95453
95451: GO 95601
95453: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95454: LD_ADDR_VAR 0 2
95458: PUSH
95459: LD_INT 2
95461: PUSH
95462: LD_INT 4
95464: PUSH
95465: LD_INT 5
95467: PUSH
95468: LD_INT 7
95470: PUSH
95471: LD_INT 11
95473: PUSH
95474: LD_INT 12
95476: PUSH
95477: LD_INT 15
95479: PUSH
95480: LD_INT 16
95482: PUSH
95483: LD_INT 20
95485: PUSH
95486: LD_INT 21
95488: PUSH
95489: LD_INT 22
95491: PUSH
95492: LD_INT 23
95494: PUSH
95495: LD_INT 25
95497: PUSH
95498: LD_INT 26
95500: PUSH
95501: LD_INT 30
95503: PUSH
95504: LD_INT 31
95506: PUSH
95507: LD_INT 32
95509: PUSH
95510: LD_INT 33
95512: PUSH
95513: LD_INT 34
95515: PUSH
95516: LD_INT 35
95518: PUSH
95519: LD_INT 36
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 101
95547: PUSH
95548: LD_INT 102
95550: PUSH
95551: LD_INT 103
95553: PUSH
95554: LD_INT 106
95556: PUSH
95557: LD_INT 108
95559: PUSH
95560: LD_INT 112
95562: PUSH
95563: LD_INT 113
95565: PUSH
95566: LD_INT 114
95568: PUSH
95569: LD_INT 115
95571: PUSH
95572: LD_INT 116
95574: PUSH
95575: LD_INT 117
95577: PUSH
95578: LD_INT 118
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: ST_TO_ADDR
95599: GO 95842
95601: LD_INT 19
95603: DOUBLE
95604: EQUAL
95605: IFTRUE 95609
95607: GO 95841
95609: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95610: LD_ADDR_VAR 0 2
95614: PUSH
95615: LD_INT 1
95617: PUSH
95618: LD_INT 2
95620: PUSH
95621: LD_INT 3
95623: PUSH
95624: LD_INT 4
95626: PUSH
95627: LD_INT 5
95629: PUSH
95630: LD_INT 6
95632: PUSH
95633: LD_INT 7
95635: PUSH
95636: LD_INT 8
95638: PUSH
95639: LD_INT 9
95641: PUSH
95642: LD_INT 10
95644: PUSH
95645: LD_INT 11
95647: PUSH
95648: LD_INT 12
95650: PUSH
95651: LD_INT 13
95653: PUSH
95654: LD_INT 14
95656: PUSH
95657: LD_INT 15
95659: PUSH
95660: LD_INT 16
95662: PUSH
95663: LD_INT 17
95665: PUSH
95666: LD_INT 18
95668: PUSH
95669: LD_INT 19
95671: PUSH
95672: LD_INT 20
95674: PUSH
95675: LD_INT 21
95677: PUSH
95678: LD_INT 22
95680: PUSH
95681: LD_INT 23
95683: PUSH
95684: LD_INT 24
95686: PUSH
95687: LD_INT 25
95689: PUSH
95690: LD_INT 26
95692: PUSH
95693: LD_INT 27
95695: PUSH
95696: LD_INT 28
95698: PUSH
95699: LD_INT 29
95701: PUSH
95702: LD_INT 30
95704: PUSH
95705: LD_INT 31
95707: PUSH
95708: LD_INT 32
95710: PUSH
95711: LD_INT 33
95713: PUSH
95714: LD_INT 34
95716: PUSH
95717: LD_INT 35
95719: PUSH
95720: LD_INT 36
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 101
95763: PUSH
95764: LD_INT 102
95766: PUSH
95767: LD_INT 103
95769: PUSH
95770: LD_INT 104
95772: PUSH
95773: LD_INT 105
95775: PUSH
95776: LD_INT 106
95778: PUSH
95779: LD_INT 107
95781: PUSH
95782: LD_INT 108
95784: PUSH
95785: LD_INT 109
95787: PUSH
95788: LD_INT 110
95790: PUSH
95791: LD_INT 111
95793: PUSH
95794: LD_INT 112
95796: PUSH
95797: LD_INT 113
95799: PUSH
95800: LD_INT 114
95802: PUSH
95803: LD_INT 115
95805: PUSH
95806: LD_INT 116
95808: PUSH
95809: LD_INT 117
95811: PUSH
95812: LD_INT 118
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: ST_TO_ADDR
95839: GO 95842
95841: POP
// end else
95842: GO 96073
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95844: LD_ADDR_VAR 0 2
95848: PUSH
95849: LD_INT 1
95851: PUSH
95852: LD_INT 2
95854: PUSH
95855: LD_INT 3
95857: PUSH
95858: LD_INT 4
95860: PUSH
95861: LD_INT 5
95863: PUSH
95864: LD_INT 6
95866: PUSH
95867: LD_INT 7
95869: PUSH
95870: LD_INT 8
95872: PUSH
95873: LD_INT 9
95875: PUSH
95876: LD_INT 10
95878: PUSH
95879: LD_INT 11
95881: PUSH
95882: LD_INT 12
95884: PUSH
95885: LD_INT 13
95887: PUSH
95888: LD_INT 14
95890: PUSH
95891: LD_INT 15
95893: PUSH
95894: LD_INT 16
95896: PUSH
95897: LD_INT 17
95899: PUSH
95900: LD_INT 18
95902: PUSH
95903: LD_INT 19
95905: PUSH
95906: LD_INT 20
95908: PUSH
95909: LD_INT 21
95911: PUSH
95912: LD_INT 22
95914: PUSH
95915: LD_INT 23
95917: PUSH
95918: LD_INT 24
95920: PUSH
95921: LD_INT 25
95923: PUSH
95924: LD_INT 26
95926: PUSH
95927: LD_INT 27
95929: PUSH
95930: LD_INT 28
95932: PUSH
95933: LD_INT 29
95935: PUSH
95936: LD_INT 30
95938: PUSH
95939: LD_INT 31
95941: PUSH
95942: LD_INT 32
95944: PUSH
95945: LD_INT 33
95947: PUSH
95948: LD_INT 34
95950: PUSH
95951: LD_INT 35
95953: PUSH
95954: LD_INT 36
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: PUSH
95995: LD_INT 101
95997: PUSH
95998: LD_INT 102
96000: PUSH
96001: LD_INT 103
96003: PUSH
96004: LD_INT 104
96006: PUSH
96007: LD_INT 105
96009: PUSH
96010: LD_INT 106
96012: PUSH
96013: LD_INT 107
96015: PUSH
96016: LD_INT 108
96018: PUSH
96019: LD_INT 109
96021: PUSH
96022: LD_INT 110
96024: PUSH
96025: LD_INT 111
96027: PUSH
96028: LD_INT 112
96030: PUSH
96031: LD_INT 113
96033: PUSH
96034: LD_INT 114
96036: PUSH
96037: LD_INT 115
96039: PUSH
96040: LD_INT 116
96042: PUSH
96043: LD_INT 117
96045: PUSH
96046: LD_INT 118
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: ST_TO_ADDR
// if result then
96073: LD_VAR 0 2
96077: IFFALSE 96863
// begin normal :=  ;
96079: LD_ADDR_VAR 0 5
96083: PUSH
96084: LD_STRING 
96086: ST_TO_ADDR
// hardcore :=  ;
96087: LD_ADDR_VAR 0 6
96091: PUSH
96092: LD_STRING 
96094: ST_TO_ADDR
// active :=  ;
96095: LD_ADDR_VAR 0 7
96099: PUSH
96100: LD_STRING 
96102: ST_TO_ADDR
// for i = 1 to normalCounter do
96103: LD_ADDR_VAR 0 8
96107: PUSH
96108: DOUBLE
96109: LD_INT 1
96111: DEC
96112: ST_TO_ADDR
96113: LD_EXP 110
96117: PUSH
96118: FOR_TO
96119: IFFALSE 96220
// begin tmp := 0 ;
96121: LD_ADDR_VAR 0 3
96125: PUSH
96126: LD_STRING 0
96128: ST_TO_ADDR
// if result [ 1 ] then
96129: LD_VAR 0 2
96133: PUSH
96134: LD_INT 1
96136: ARRAY
96137: IFFALSE 96202
// if result [ 1 ] [ 1 ] = i then
96139: LD_VAR 0 2
96143: PUSH
96144: LD_INT 1
96146: ARRAY
96147: PUSH
96148: LD_INT 1
96150: ARRAY
96151: PUSH
96152: LD_VAR 0 8
96156: EQUAL
96157: IFFALSE 96202
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96159: LD_ADDR_VAR 0 2
96163: PUSH
96164: LD_VAR 0 2
96168: PPUSH
96169: LD_INT 1
96171: PPUSH
96172: LD_VAR 0 2
96176: PUSH
96177: LD_INT 1
96179: ARRAY
96180: PPUSH
96181: LD_INT 1
96183: PPUSH
96184: CALL_OW 3
96188: PPUSH
96189: CALL_OW 1
96193: ST_TO_ADDR
// tmp := 1 ;
96194: LD_ADDR_VAR 0 3
96198: PUSH
96199: LD_STRING 1
96201: ST_TO_ADDR
// end ; normal := normal & tmp ;
96202: LD_ADDR_VAR 0 5
96206: PUSH
96207: LD_VAR 0 5
96211: PUSH
96212: LD_VAR 0 3
96216: STR
96217: ST_TO_ADDR
// end ;
96218: GO 96118
96220: POP
96221: POP
// for i = 1 to hardcoreCounter do
96222: LD_ADDR_VAR 0 8
96226: PUSH
96227: DOUBLE
96228: LD_INT 1
96230: DEC
96231: ST_TO_ADDR
96232: LD_EXP 111
96236: PUSH
96237: FOR_TO
96238: IFFALSE 96343
// begin tmp := 0 ;
96240: LD_ADDR_VAR 0 3
96244: PUSH
96245: LD_STRING 0
96247: ST_TO_ADDR
// if result [ 2 ] then
96248: LD_VAR 0 2
96252: PUSH
96253: LD_INT 2
96255: ARRAY
96256: IFFALSE 96325
// if result [ 2 ] [ 1 ] = 100 + i then
96258: LD_VAR 0 2
96262: PUSH
96263: LD_INT 2
96265: ARRAY
96266: PUSH
96267: LD_INT 1
96269: ARRAY
96270: PUSH
96271: LD_INT 100
96273: PUSH
96274: LD_VAR 0 8
96278: PLUS
96279: EQUAL
96280: IFFALSE 96325
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96282: LD_ADDR_VAR 0 2
96286: PUSH
96287: LD_VAR 0 2
96291: PPUSH
96292: LD_INT 2
96294: PPUSH
96295: LD_VAR 0 2
96299: PUSH
96300: LD_INT 2
96302: ARRAY
96303: PPUSH
96304: LD_INT 1
96306: PPUSH
96307: CALL_OW 3
96311: PPUSH
96312: CALL_OW 1
96316: ST_TO_ADDR
// tmp := 1 ;
96317: LD_ADDR_VAR 0 3
96321: PUSH
96322: LD_STRING 1
96324: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96325: LD_ADDR_VAR 0 6
96329: PUSH
96330: LD_VAR 0 6
96334: PUSH
96335: LD_VAR 0 3
96339: STR
96340: ST_TO_ADDR
// end ;
96341: GO 96237
96343: POP
96344: POP
// if isGameLoad then
96345: LD_VAR 0 1
96349: IFFALSE 96824
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96351: LD_ADDR_VAR 0 4
96355: PUSH
96356: LD_EXP 114
96360: PUSH
96361: LD_EXP 113
96365: PUSH
96366: LD_EXP 115
96370: PUSH
96371: LD_EXP 112
96375: PUSH
96376: LD_EXP 116
96380: PUSH
96381: LD_EXP 117
96385: PUSH
96386: LD_EXP 118
96390: PUSH
96391: LD_EXP 119
96395: PUSH
96396: LD_EXP 120
96400: PUSH
96401: LD_EXP 121
96405: PUSH
96406: LD_EXP 122
96410: PUSH
96411: LD_EXP 123
96415: PUSH
96416: LD_EXP 124
96420: PUSH
96421: LD_EXP 125
96425: PUSH
96426: LD_EXP 133
96430: PUSH
96431: LD_EXP 134
96435: PUSH
96436: LD_EXP 135
96440: PUSH
96441: LD_EXP 136
96445: PUSH
96446: LD_EXP 138
96450: PUSH
96451: LD_EXP 139
96455: PUSH
96456: LD_EXP 140
96460: PUSH
96461: LD_EXP 143
96465: PUSH
96466: LD_EXP 145
96470: PUSH
96471: LD_EXP 146
96475: PUSH
96476: LD_EXP 147
96480: PUSH
96481: LD_EXP 149
96485: PUSH
96486: LD_EXP 150
96490: PUSH
96491: LD_EXP 153
96495: PUSH
96496: LD_EXP 154
96500: PUSH
96501: LD_EXP 155
96505: PUSH
96506: LD_EXP 156
96510: PUSH
96511: LD_EXP 157
96515: PUSH
96516: LD_EXP 158
96520: PUSH
96521: LD_EXP 159
96525: PUSH
96526: LD_EXP 160
96530: PUSH
96531: LD_EXP 161
96535: PUSH
96536: LD_EXP 126
96540: PUSH
96541: LD_EXP 127
96545: PUSH
96546: LD_EXP 130
96550: PUSH
96551: LD_EXP 131
96555: PUSH
96556: LD_EXP 132
96560: PUSH
96561: LD_EXP 128
96565: PUSH
96566: LD_EXP 129
96570: PUSH
96571: LD_EXP 137
96575: PUSH
96576: LD_EXP 141
96580: PUSH
96581: LD_EXP 142
96585: PUSH
96586: LD_EXP 144
96590: PUSH
96591: LD_EXP 148
96595: PUSH
96596: LD_EXP 151
96600: PUSH
96601: LD_EXP 152
96605: PUSH
96606: LD_EXP 162
96610: PUSH
96611: LD_EXP 163
96615: PUSH
96616: LD_EXP 164
96620: PUSH
96621: LD_EXP 165
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: ST_TO_ADDR
// tmp :=  ;
96682: LD_ADDR_VAR 0 3
96686: PUSH
96687: LD_STRING 
96689: ST_TO_ADDR
// for i = 1 to normalCounter do
96690: LD_ADDR_VAR 0 8
96694: PUSH
96695: DOUBLE
96696: LD_INT 1
96698: DEC
96699: ST_TO_ADDR
96700: LD_EXP 110
96704: PUSH
96705: FOR_TO
96706: IFFALSE 96742
// begin if flags [ i ] then
96708: LD_VAR 0 4
96712: PUSH
96713: LD_VAR 0 8
96717: ARRAY
96718: IFFALSE 96740
// tmp := tmp & i & ; ;
96720: LD_ADDR_VAR 0 3
96724: PUSH
96725: LD_VAR 0 3
96729: PUSH
96730: LD_VAR 0 8
96734: STR
96735: PUSH
96736: LD_STRING ;
96738: STR
96739: ST_TO_ADDR
// end ;
96740: GO 96705
96742: POP
96743: POP
// for i = 1 to hardcoreCounter do
96744: LD_ADDR_VAR 0 8
96748: PUSH
96749: DOUBLE
96750: LD_INT 1
96752: DEC
96753: ST_TO_ADDR
96754: LD_EXP 111
96758: PUSH
96759: FOR_TO
96760: IFFALSE 96806
// begin if flags [ normalCounter + i ] then
96762: LD_VAR 0 4
96766: PUSH
96767: LD_EXP 110
96771: PUSH
96772: LD_VAR 0 8
96776: PLUS
96777: ARRAY
96778: IFFALSE 96804
// tmp := tmp & ( 100 + i ) & ; ;
96780: LD_ADDR_VAR 0 3
96784: PUSH
96785: LD_VAR 0 3
96789: PUSH
96790: LD_INT 100
96792: PUSH
96793: LD_VAR 0 8
96797: PLUS
96798: STR
96799: PUSH
96800: LD_STRING ;
96802: STR
96803: ST_TO_ADDR
// end ;
96804: GO 96759
96806: POP
96807: POP
// if tmp then
96808: LD_VAR 0 3
96812: IFFALSE 96824
// active := tmp ;
96814: LD_ADDR_VAR 0 7
96818: PUSH
96819: LD_VAR 0 3
96823: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96824: LD_STRING getStreamItemsFromMission("
96826: PUSH
96827: LD_VAR 0 5
96831: STR
96832: PUSH
96833: LD_STRING ","
96835: STR
96836: PUSH
96837: LD_VAR 0 6
96841: STR
96842: PUSH
96843: LD_STRING ","
96845: STR
96846: PUSH
96847: LD_VAR 0 7
96851: STR
96852: PUSH
96853: LD_STRING ")
96855: STR
96856: PPUSH
96857: CALL_OW 559
// end else
96861: GO 96870
// ToLua ( getStreamItemsFromMission("","","") ) ;
96863: LD_STRING getStreamItemsFromMission("","","")
96865: PPUSH
96866: CALL_OW 559
// end ;
96870: LD_VAR 0 2
96874: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96875: LD_EXP 109
96879: PUSH
96880: LD_EXP 114
96884: AND
96885: IFFALSE 97009
96887: GO 96889
96889: DISABLE
96890: LD_INT 0
96892: PPUSH
96893: PPUSH
// begin enable ;
96894: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96895: LD_ADDR_VAR 0 2
96899: PUSH
96900: LD_INT 22
96902: PUSH
96903: LD_OWVAR 2
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: PUSH
96912: LD_INT 2
96914: PUSH
96915: LD_INT 34
96917: PUSH
96918: LD_INT 7
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: LD_INT 34
96927: PUSH
96928: LD_INT 45
96930: PUSH
96931: EMPTY
96932: LIST
96933: LIST
96934: PUSH
96935: LD_INT 34
96937: PUSH
96938: LD_INT 28
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 34
96947: PUSH
96948: LD_INT 47
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: EMPTY
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: PUSH
96962: EMPTY
96963: LIST
96964: LIST
96965: PPUSH
96966: CALL_OW 69
96970: ST_TO_ADDR
// if not tmp then
96971: LD_VAR 0 2
96975: NOT
96976: IFFALSE 96980
// exit ;
96978: GO 97009
// for i in tmp do
96980: LD_ADDR_VAR 0 1
96984: PUSH
96985: LD_VAR 0 2
96989: PUSH
96990: FOR_IN
96991: IFFALSE 97007
// begin SetLives ( i , 0 ) ;
96993: LD_VAR 0 1
96997: PPUSH
96998: LD_INT 0
97000: PPUSH
97001: CALL_OW 234
// end ;
97005: GO 96990
97007: POP
97008: POP
// end ;
97009: PPOPN 2
97011: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97012: LD_EXP 109
97016: PUSH
97017: LD_EXP 115
97021: AND
97022: IFFALSE 97106
97024: GO 97026
97026: DISABLE
97027: LD_INT 0
97029: PPUSH
97030: PPUSH
// begin enable ;
97031: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97032: LD_ADDR_VAR 0 2
97036: PUSH
97037: LD_INT 22
97039: PUSH
97040: LD_OWVAR 2
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: LD_INT 32
97051: PUSH
97052: LD_INT 3
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PPUSH
97063: CALL_OW 69
97067: ST_TO_ADDR
// if not tmp then
97068: LD_VAR 0 2
97072: NOT
97073: IFFALSE 97077
// exit ;
97075: GO 97106
// for i in tmp do
97077: LD_ADDR_VAR 0 1
97081: PUSH
97082: LD_VAR 0 2
97086: PUSH
97087: FOR_IN
97088: IFFALSE 97104
// begin SetLives ( i , 0 ) ;
97090: LD_VAR 0 1
97094: PPUSH
97095: LD_INT 0
97097: PPUSH
97098: CALL_OW 234
// end ;
97102: GO 97087
97104: POP
97105: POP
// end ;
97106: PPOPN 2
97108: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97109: LD_EXP 109
97113: PUSH
97114: LD_EXP 112
97118: AND
97119: IFFALSE 97212
97121: GO 97123
97123: DISABLE
97124: LD_INT 0
97126: PPUSH
// begin enable ;
97127: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97128: LD_ADDR_VAR 0 1
97132: PUSH
97133: LD_INT 22
97135: PUSH
97136: LD_OWVAR 2
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 2
97147: PUSH
97148: LD_INT 25
97150: PUSH
97151: LD_INT 5
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 25
97160: PUSH
97161: LD_INT 9
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 25
97170: PUSH
97171: LD_INT 8
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PPUSH
97188: CALL_OW 69
97192: PUSH
97193: FOR_IN
97194: IFFALSE 97210
// begin SetClass ( i , 1 ) ;
97196: LD_VAR 0 1
97200: PPUSH
97201: LD_INT 1
97203: PPUSH
97204: CALL_OW 336
// end ;
97208: GO 97193
97210: POP
97211: POP
// end ;
97212: PPOPN 1
97214: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97215: LD_EXP 109
97219: PUSH
97220: LD_EXP 113
97224: AND
97225: PUSH
97226: LD_OWVAR 65
97230: PUSH
97231: LD_INT 7
97233: LESS
97234: AND
97235: IFFALSE 97249
97237: GO 97239
97239: DISABLE
// begin enable ;
97240: ENABLE
// game_speed := 7 ;
97241: LD_ADDR_OWVAR 65
97245: PUSH
97246: LD_INT 7
97248: ST_TO_ADDR
// end ;
97249: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97250: LD_EXP 109
97254: PUSH
97255: LD_EXP 116
97259: AND
97260: IFFALSE 97462
97262: GO 97264
97264: DISABLE
97265: LD_INT 0
97267: PPUSH
97268: PPUSH
97269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97270: LD_ADDR_VAR 0 3
97274: PUSH
97275: LD_INT 81
97277: PUSH
97278: LD_OWVAR 2
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 21
97289: PUSH
97290: LD_INT 1
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PPUSH
97301: CALL_OW 69
97305: ST_TO_ADDR
// if not tmp then
97306: LD_VAR 0 3
97310: NOT
97311: IFFALSE 97315
// exit ;
97313: GO 97462
// if tmp > 5 then
97315: LD_VAR 0 3
97319: PUSH
97320: LD_INT 5
97322: GREATER
97323: IFFALSE 97335
// k := 5 else
97325: LD_ADDR_VAR 0 2
97329: PUSH
97330: LD_INT 5
97332: ST_TO_ADDR
97333: GO 97345
// k := tmp ;
97335: LD_ADDR_VAR 0 2
97339: PUSH
97340: LD_VAR 0 3
97344: ST_TO_ADDR
// for i := 1 to k do
97345: LD_ADDR_VAR 0 1
97349: PUSH
97350: DOUBLE
97351: LD_INT 1
97353: DEC
97354: ST_TO_ADDR
97355: LD_VAR 0 2
97359: PUSH
97360: FOR_TO
97361: IFFALSE 97460
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97363: LD_VAR 0 3
97367: PUSH
97368: LD_VAR 0 1
97372: ARRAY
97373: PPUSH
97374: LD_VAR 0 1
97378: PUSH
97379: LD_INT 4
97381: MOD
97382: PUSH
97383: LD_INT 1
97385: PLUS
97386: PPUSH
97387: CALL_OW 259
97391: PUSH
97392: LD_INT 10
97394: LESS
97395: IFFALSE 97458
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97397: LD_VAR 0 3
97401: PUSH
97402: LD_VAR 0 1
97406: ARRAY
97407: PPUSH
97408: LD_VAR 0 1
97412: PUSH
97413: LD_INT 4
97415: MOD
97416: PUSH
97417: LD_INT 1
97419: PLUS
97420: PPUSH
97421: LD_VAR 0 3
97425: PUSH
97426: LD_VAR 0 1
97430: ARRAY
97431: PPUSH
97432: LD_VAR 0 1
97436: PUSH
97437: LD_INT 4
97439: MOD
97440: PUSH
97441: LD_INT 1
97443: PLUS
97444: PPUSH
97445: CALL_OW 259
97449: PUSH
97450: LD_INT 1
97452: PLUS
97453: PPUSH
97454: CALL_OW 237
97458: GO 97360
97460: POP
97461: POP
// end ;
97462: PPOPN 3
97464: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97465: LD_EXP 109
97469: PUSH
97470: LD_EXP 117
97474: AND
97475: IFFALSE 97495
97477: GO 97479
97479: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97480: LD_INT 4
97482: PPUSH
97483: LD_OWVAR 2
97487: PPUSH
97488: LD_INT 0
97490: PPUSH
97491: CALL_OW 324
97495: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97496: LD_EXP 109
97500: PUSH
97501: LD_EXP 146
97505: AND
97506: IFFALSE 97526
97508: GO 97510
97510: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97511: LD_INT 19
97513: PPUSH
97514: LD_OWVAR 2
97518: PPUSH
97519: LD_INT 0
97521: PPUSH
97522: CALL_OW 324
97526: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97527: LD_EXP 109
97531: PUSH
97532: LD_EXP 118
97536: AND
97537: IFFALSE 97639
97539: GO 97541
97541: DISABLE
97542: LD_INT 0
97544: PPUSH
97545: PPUSH
// begin enable ;
97546: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97547: LD_ADDR_VAR 0 2
97551: PUSH
97552: LD_INT 22
97554: PUSH
97555: LD_OWVAR 2
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 2
97566: PUSH
97567: LD_INT 34
97569: PUSH
97570: LD_INT 11
97572: PUSH
97573: EMPTY
97574: LIST
97575: LIST
97576: PUSH
97577: LD_INT 34
97579: PUSH
97580: LD_INT 30
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: LIST
97591: PUSH
97592: EMPTY
97593: LIST
97594: LIST
97595: PPUSH
97596: CALL_OW 69
97600: ST_TO_ADDR
// if not tmp then
97601: LD_VAR 0 2
97605: NOT
97606: IFFALSE 97610
// exit ;
97608: GO 97639
// for i in tmp do
97610: LD_ADDR_VAR 0 1
97614: PUSH
97615: LD_VAR 0 2
97619: PUSH
97620: FOR_IN
97621: IFFALSE 97637
// begin SetLives ( i , 0 ) ;
97623: LD_VAR 0 1
97627: PPUSH
97628: LD_INT 0
97630: PPUSH
97631: CALL_OW 234
// end ;
97635: GO 97620
97637: POP
97638: POP
// end ;
97639: PPOPN 2
97641: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97642: LD_EXP 109
97646: PUSH
97647: LD_EXP 119
97651: AND
97652: IFFALSE 97672
97654: GO 97656
97656: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97657: LD_INT 32
97659: PPUSH
97660: LD_OWVAR 2
97664: PPUSH
97665: LD_INT 0
97667: PPUSH
97668: CALL_OW 324
97672: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97673: LD_EXP 109
97677: PUSH
97678: LD_EXP 120
97682: AND
97683: IFFALSE 97864
97685: GO 97687
97687: DISABLE
97688: LD_INT 0
97690: PPUSH
97691: PPUSH
97692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97693: LD_ADDR_VAR 0 2
97697: PUSH
97698: LD_INT 22
97700: PUSH
97701: LD_OWVAR 2
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: LD_INT 33
97712: PUSH
97713: LD_INT 3
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PPUSH
97724: CALL_OW 69
97728: ST_TO_ADDR
// if not tmp then
97729: LD_VAR 0 2
97733: NOT
97734: IFFALSE 97738
// exit ;
97736: GO 97864
// side := 0 ;
97738: LD_ADDR_VAR 0 3
97742: PUSH
97743: LD_INT 0
97745: ST_TO_ADDR
// for i := 1 to 8 do
97746: LD_ADDR_VAR 0 1
97750: PUSH
97751: DOUBLE
97752: LD_INT 1
97754: DEC
97755: ST_TO_ADDR
97756: LD_INT 8
97758: PUSH
97759: FOR_TO
97760: IFFALSE 97808
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97762: LD_OWVAR 2
97766: PUSH
97767: LD_VAR 0 1
97771: NONEQUAL
97772: PUSH
97773: LD_OWVAR 2
97777: PPUSH
97778: LD_VAR 0 1
97782: PPUSH
97783: CALL_OW 81
97787: PUSH
97788: LD_INT 2
97790: EQUAL
97791: AND
97792: IFFALSE 97806
// begin side := i ;
97794: LD_ADDR_VAR 0 3
97798: PUSH
97799: LD_VAR 0 1
97803: ST_TO_ADDR
// break ;
97804: GO 97808
// end ;
97806: GO 97759
97808: POP
97809: POP
// if not side then
97810: LD_VAR 0 3
97814: NOT
97815: IFFALSE 97819
// exit ;
97817: GO 97864
// for i := 1 to tmp do
97819: LD_ADDR_VAR 0 1
97823: PUSH
97824: DOUBLE
97825: LD_INT 1
97827: DEC
97828: ST_TO_ADDR
97829: LD_VAR 0 2
97833: PUSH
97834: FOR_TO
97835: IFFALSE 97862
// if Prob ( 60 ) then
97837: LD_INT 60
97839: PPUSH
97840: CALL_OW 13
97844: IFFALSE 97860
// SetSide ( i , side ) ;
97846: LD_VAR 0 1
97850: PPUSH
97851: LD_VAR 0 3
97855: PPUSH
97856: CALL_OW 235
97860: GO 97834
97862: POP
97863: POP
// end ;
97864: PPOPN 3
97866: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97867: LD_EXP 109
97871: PUSH
97872: LD_EXP 122
97876: AND
97877: IFFALSE 97996
97879: GO 97881
97881: DISABLE
97882: LD_INT 0
97884: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97885: LD_ADDR_VAR 0 1
97889: PUSH
97890: LD_INT 22
97892: PUSH
97893: LD_OWVAR 2
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 21
97904: PUSH
97905: LD_INT 1
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 3
97914: PUSH
97915: LD_INT 23
97917: PUSH
97918: LD_INT 0
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: LIST
97933: PPUSH
97934: CALL_OW 69
97938: PUSH
97939: FOR_IN
97940: IFFALSE 97994
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97942: LD_VAR 0 1
97946: PPUSH
97947: CALL_OW 257
97951: PUSH
97952: LD_INT 1
97954: PUSH
97955: LD_INT 2
97957: PUSH
97958: LD_INT 3
97960: PUSH
97961: LD_INT 4
97963: PUSH
97964: EMPTY
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: IN
97970: IFFALSE 97992
// SetClass ( un , rand ( 1 , 4 ) ) ;
97972: LD_VAR 0 1
97976: PPUSH
97977: LD_INT 1
97979: PPUSH
97980: LD_INT 4
97982: PPUSH
97983: CALL_OW 12
97987: PPUSH
97988: CALL_OW 336
97992: GO 97939
97994: POP
97995: POP
// end ;
97996: PPOPN 1
97998: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97999: LD_EXP 109
98003: PUSH
98004: LD_EXP 121
98008: AND
98009: IFFALSE 98088
98011: GO 98013
98013: DISABLE
98014: LD_INT 0
98016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98017: LD_ADDR_VAR 0 1
98021: PUSH
98022: LD_INT 22
98024: PUSH
98025: LD_OWVAR 2
98029: PUSH
98030: EMPTY
98031: LIST
98032: LIST
98033: PUSH
98034: LD_INT 21
98036: PUSH
98037: LD_INT 3
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: EMPTY
98045: LIST
98046: LIST
98047: PPUSH
98048: CALL_OW 69
98052: ST_TO_ADDR
// if not tmp then
98053: LD_VAR 0 1
98057: NOT
98058: IFFALSE 98062
// exit ;
98060: GO 98088
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98062: LD_VAR 0 1
98066: PUSH
98067: LD_INT 1
98069: PPUSH
98070: LD_VAR 0 1
98074: PPUSH
98075: CALL_OW 12
98079: ARRAY
98080: PPUSH
98081: LD_INT 100
98083: PPUSH
98084: CALL_OW 234
// end ;
98088: PPOPN 1
98090: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98091: LD_EXP 109
98095: PUSH
98096: LD_EXP 123
98100: AND
98101: IFFALSE 98199
98103: GO 98105
98105: DISABLE
98106: LD_INT 0
98108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98109: LD_ADDR_VAR 0 1
98113: PUSH
98114: LD_INT 22
98116: PUSH
98117: LD_OWVAR 2
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 21
98128: PUSH
98129: LD_INT 1
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PPUSH
98140: CALL_OW 69
98144: ST_TO_ADDR
// if not tmp then
98145: LD_VAR 0 1
98149: NOT
98150: IFFALSE 98154
// exit ;
98152: GO 98199
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98154: LD_VAR 0 1
98158: PUSH
98159: LD_INT 1
98161: PPUSH
98162: LD_VAR 0 1
98166: PPUSH
98167: CALL_OW 12
98171: ARRAY
98172: PPUSH
98173: LD_INT 1
98175: PPUSH
98176: LD_INT 4
98178: PPUSH
98179: CALL_OW 12
98183: PPUSH
98184: LD_INT 3000
98186: PPUSH
98187: LD_INT 9000
98189: PPUSH
98190: CALL_OW 12
98194: PPUSH
98195: CALL_OW 492
// end ;
98199: PPOPN 1
98201: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98202: LD_EXP 109
98206: PUSH
98207: LD_EXP 124
98211: AND
98212: IFFALSE 98232
98214: GO 98216
98216: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98217: LD_INT 1
98219: PPUSH
98220: LD_OWVAR 2
98224: PPUSH
98225: LD_INT 0
98227: PPUSH
98228: CALL_OW 324
98232: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98233: LD_EXP 109
98237: PUSH
98238: LD_EXP 125
98242: AND
98243: IFFALSE 98326
98245: GO 98247
98247: DISABLE
98248: LD_INT 0
98250: PPUSH
98251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98252: LD_ADDR_VAR 0 2
98256: PUSH
98257: LD_INT 22
98259: PUSH
98260: LD_OWVAR 2
98264: PUSH
98265: EMPTY
98266: LIST
98267: LIST
98268: PUSH
98269: LD_INT 21
98271: PUSH
98272: LD_INT 3
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PPUSH
98283: CALL_OW 69
98287: ST_TO_ADDR
// if not tmp then
98288: LD_VAR 0 2
98292: NOT
98293: IFFALSE 98297
// exit ;
98295: GO 98326
// for i in tmp do
98297: LD_ADDR_VAR 0 1
98301: PUSH
98302: LD_VAR 0 2
98306: PUSH
98307: FOR_IN
98308: IFFALSE 98324
// SetBLevel ( i , 10 ) ;
98310: LD_VAR 0 1
98314: PPUSH
98315: LD_INT 10
98317: PPUSH
98318: CALL_OW 241
98322: GO 98307
98324: POP
98325: POP
// end ;
98326: PPOPN 2
98328: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98329: LD_EXP 109
98333: PUSH
98334: LD_EXP 126
98338: AND
98339: IFFALSE 98450
98341: GO 98343
98343: DISABLE
98344: LD_INT 0
98346: PPUSH
98347: PPUSH
98348: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98349: LD_ADDR_VAR 0 3
98353: PUSH
98354: LD_INT 22
98356: PUSH
98357: LD_OWVAR 2
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PUSH
98366: LD_INT 25
98368: PUSH
98369: LD_INT 1
98371: PUSH
98372: EMPTY
98373: LIST
98374: LIST
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PPUSH
98380: CALL_OW 69
98384: ST_TO_ADDR
// if not tmp then
98385: LD_VAR 0 3
98389: NOT
98390: IFFALSE 98394
// exit ;
98392: GO 98450
// un := tmp [ rand ( 1 , tmp ) ] ;
98394: LD_ADDR_VAR 0 2
98398: PUSH
98399: LD_VAR 0 3
98403: PUSH
98404: LD_INT 1
98406: PPUSH
98407: LD_VAR 0 3
98411: PPUSH
98412: CALL_OW 12
98416: ARRAY
98417: ST_TO_ADDR
// if Crawls ( un ) then
98418: LD_VAR 0 2
98422: PPUSH
98423: CALL_OW 318
98427: IFFALSE 98438
// ComWalk ( un ) ;
98429: LD_VAR 0 2
98433: PPUSH
98434: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98438: LD_VAR 0 2
98442: PPUSH
98443: LD_INT 5
98445: PPUSH
98446: CALL_OW 336
// end ;
98450: PPOPN 3
98452: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98453: LD_EXP 109
98457: PUSH
98458: LD_EXP 127
98462: AND
98463: PUSH
98464: LD_OWVAR 67
98468: PUSH
98469: LD_INT 4
98471: LESS
98472: AND
98473: IFFALSE 98492
98475: GO 98477
98477: DISABLE
// begin Difficulty := Difficulty + 1 ;
98478: LD_ADDR_OWVAR 67
98482: PUSH
98483: LD_OWVAR 67
98487: PUSH
98488: LD_INT 1
98490: PLUS
98491: ST_TO_ADDR
// end ;
98492: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98493: LD_EXP 109
98497: PUSH
98498: LD_EXP 128
98502: AND
98503: IFFALSE 98606
98505: GO 98507
98507: DISABLE
98508: LD_INT 0
98510: PPUSH
// begin for i := 1 to 5 do
98511: LD_ADDR_VAR 0 1
98515: PUSH
98516: DOUBLE
98517: LD_INT 1
98519: DEC
98520: ST_TO_ADDR
98521: LD_INT 5
98523: PUSH
98524: FOR_TO
98525: IFFALSE 98604
// begin uc_nation := nation_nature ;
98527: LD_ADDR_OWVAR 21
98531: PUSH
98532: LD_INT 0
98534: ST_TO_ADDR
// uc_side := 0 ;
98535: LD_ADDR_OWVAR 20
98539: PUSH
98540: LD_INT 0
98542: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98543: LD_ADDR_OWVAR 29
98547: PUSH
98548: LD_INT 12
98550: PUSH
98551: LD_INT 12
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: ST_TO_ADDR
// hc_agressivity := 20 ;
98558: LD_ADDR_OWVAR 35
98562: PUSH
98563: LD_INT 20
98565: ST_TO_ADDR
// hc_class := class_tiger ;
98566: LD_ADDR_OWVAR 28
98570: PUSH
98571: LD_INT 14
98573: ST_TO_ADDR
// hc_gallery :=  ;
98574: LD_ADDR_OWVAR 33
98578: PUSH
98579: LD_STRING 
98581: ST_TO_ADDR
// hc_name :=  ;
98582: LD_ADDR_OWVAR 26
98586: PUSH
98587: LD_STRING 
98589: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98590: CALL_OW 44
98594: PPUSH
98595: LD_INT 0
98597: PPUSH
98598: CALL_OW 51
// end ;
98602: GO 98524
98604: POP
98605: POP
// end ;
98606: PPOPN 1
98608: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98609: LD_EXP 109
98613: PUSH
98614: LD_EXP 129
98618: AND
98619: IFFALSE 98628
98621: GO 98623
98623: DISABLE
// StreamSibBomb ;
98624: CALL 98629 0 0
98628: END
// export function StreamSibBomb ; var i , x , y ; begin
98629: LD_INT 0
98631: PPUSH
98632: PPUSH
98633: PPUSH
98634: PPUSH
// result := false ;
98635: LD_ADDR_VAR 0 1
98639: PUSH
98640: LD_INT 0
98642: ST_TO_ADDR
// for i := 1 to 16 do
98643: LD_ADDR_VAR 0 2
98647: PUSH
98648: DOUBLE
98649: LD_INT 1
98651: DEC
98652: ST_TO_ADDR
98653: LD_INT 16
98655: PUSH
98656: FOR_TO
98657: IFFALSE 98856
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98659: LD_ADDR_VAR 0 3
98663: PUSH
98664: LD_INT 10
98666: PUSH
98667: LD_INT 20
98669: PUSH
98670: LD_INT 30
98672: PUSH
98673: LD_INT 40
98675: PUSH
98676: LD_INT 50
98678: PUSH
98679: LD_INT 60
98681: PUSH
98682: LD_INT 70
98684: PUSH
98685: LD_INT 80
98687: PUSH
98688: LD_INT 90
98690: PUSH
98691: LD_INT 100
98693: PUSH
98694: LD_INT 110
98696: PUSH
98697: LD_INT 120
98699: PUSH
98700: LD_INT 130
98702: PUSH
98703: LD_INT 140
98705: PUSH
98706: LD_INT 150
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 1
98728: PPUSH
98729: LD_INT 15
98731: PPUSH
98732: CALL_OW 12
98736: ARRAY
98737: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98738: LD_ADDR_VAR 0 4
98742: PUSH
98743: LD_INT 10
98745: PUSH
98746: LD_INT 20
98748: PUSH
98749: LD_INT 30
98751: PUSH
98752: LD_INT 40
98754: PUSH
98755: LD_INT 50
98757: PUSH
98758: LD_INT 60
98760: PUSH
98761: LD_INT 70
98763: PUSH
98764: LD_INT 80
98766: PUSH
98767: LD_INT 90
98769: PUSH
98770: LD_INT 100
98772: PUSH
98773: LD_INT 110
98775: PUSH
98776: LD_INT 120
98778: PUSH
98779: LD_INT 130
98781: PUSH
98782: LD_INT 140
98784: PUSH
98785: LD_INT 150
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: PUSH
98805: LD_INT 1
98807: PPUSH
98808: LD_INT 15
98810: PPUSH
98811: CALL_OW 12
98815: ARRAY
98816: ST_TO_ADDR
// if ValidHex ( x , y ) then
98817: LD_VAR 0 3
98821: PPUSH
98822: LD_VAR 0 4
98826: PPUSH
98827: CALL_OW 488
98831: IFFALSE 98854
// begin result := [ x , y ] ;
98833: LD_ADDR_VAR 0 1
98837: PUSH
98838: LD_VAR 0 3
98842: PUSH
98843: LD_VAR 0 4
98847: PUSH
98848: EMPTY
98849: LIST
98850: LIST
98851: ST_TO_ADDR
// break ;
98852: GO 98856
// end ; end ;
98854: GO 98656
98856: POP
98857: POP
// if result then
98858: LD_VAR 0 1
98862: IFFALSE 98922
// begin ToLua ( playSibBomb() ) ;
98864: LD_STRING playSibBomb()
98866: PPUSH
98867: CALL_OW 559
// wait ( 0 0$14 ) ;
98871: LD_INT 490
98873: PPUSH
98874: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98878: LD_VAR 0 1
98882: PUSH
98883: LD_INT 1
98885: ARRAY
98886: PPUSH
98887: LD_VAR 0 1
98891: PUSH
98892: LD_INT 2
98894: ARRAY
98895: PPUSH
98896: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98900: LD_VAR 0 1
98904: PUSH
98905: LD_INT 1
98907: ARRAY
98908: PPUSH
98909: LD_VAR 0 1
98913: PUSH
98914: LD_INT 2
98916: ARRAY
98917: PPUSH
98918: CALL_OW 429
// end ; end ;
98922: LD_VAR 0 1
98926: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98927: LD_EXP 109
98931: PUSH
98932: LD_EXP 131
98936: AND
98937: IFFALSE 98949
98939: GO 98941
98941: DISABLE
// YouLost (  ) ;
98942: LD_STRING 
98944: PPUSH
98945: CALL_OW 104
98949: END
// every 0 0$1 trigger StreamModeActive and sFog do
98950: LD_EXP 109
98954: PUSH
98955: LD_EXP 130
98959: AND
98960: IFFALSE 98974
98962: GO 98964
98964: DISABLE
// FogOff ( your_side ) ;
98965: LD_OWVAR 2
98969: PPUSH
98970: CALL_OW 344
98974: END
// every 0 0$1 trigger StreamModeActive and sSun do
98975: LD_EXP 109
98979: PUSH
98980: LD_EXP 132
98984: AND
98985: IFFALSE 99013
98987: GO 98989
98989: DISABLE
// begin solar_recharge_percent := 0 ;
98990: LD_ADDR_OWVAR 79
98994: PUSH
98995: LD_INT 0
98997: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98998: LD_INT 10500
99000: PPUSH
99001: CALL_OW 67
// solar_recharge_percent := 100 ;
99005: LD_ADDR_OWVAR 79
99009: PUSH
99010: LD_INT 100
99012: ST_TO_ADDR
// end ;
99013: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99014: LD_EXP 109
99018: PUSH
99019: LD_EXP 133
99023: AND
99024: IFFALSE 99263
99026: GO 99028
99028: DISABLE
99029: LD_INT 0
99031: PPUSH
99032: PPUSH
99033: PPUSH
// begin tmp := [ ] ;
99034: LD_ADDR_VAR 0 3
99038: PUSH
99039: EMPTY
99040: ST_TO_ADDR
// for i := 1 to 6 do
99041: LD_ADDR_VAR 0 1
99045: PUSH
99046: DOUBLE
99047: LD_INT 1
99049: DEC
99050: ST_TO_ADDR
99051: LD_INT 6
99053: PUSH
99054: FOR_TO
99055: IFFALSE 99160
// begin uc_nation := nation_nature ;
99057: LD_ADDR_OWVAR 21
99061: PUSH
99062: LD_INT 0
99064: ST_TO_ADDR
// uc_side := 0 ;
99065: LD_ADDR_OWVAR 20
99069: PUSH
99070: LD_INT 0
99072: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99073: LD_ADDR_OWVAR 29
99077: PUSH
99078: LD_INT 12
99080: PUSH
99081: LD_INT 12
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: ST_TO_ADDR
// hc_agressivity := 20 ;
99088: LD_ADDR_OWVAR 35
99092: PUSH
99093: LD_INT 20
99095: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99096: LD_ADDR_OWVAR 28
99100: PUSH
99101: LD_INT 17
99103: ST_TO_ADDR
// hc_gallery :=  ;
99104: LD_ADDR_OWVAR 33
99108: PUSH
99109: LD_STRING 
99111: ST_TO_ADDR
// hc_name :=  ;
99112: LD_ADDR_OWVAR 26
99116: PUSH
99117: LD_STRING 
99119: ST_TO_ADDR
// un := CreateHuman ;
99120: LD_ADDR_VAR 0 2
99124: PUSH
99125: CALL_OW 44
99129: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99130: LD_VAR 0 2
99134: PPUSH
99135: LD_INT 1
99137: PPUSH
99138: CALL_OW 51
// tmp := tmp ^ un ;
99142: LD_ADDR_VAR 0 3
99146: PUSH
99147: LD_VAR 0 3
99151: PUSH
99152: LD_VAR 0 2
99156: ADD
99157: ST_TO_ADDR
// end ;
99158: GO 99054
99160: POP
99161: POP
// repeat wait ( 0 0$1 ) ;
99162: LD_INT 35
99164: PPUSH
99165: CALL_OW 67
// for un in tmp do
99169: LD_ADDR_VAR 0 2
99173: PUSH
99174: LD_VAR 0 3
99178: PUSH
99179: FOR_IN
99180: IFFALSE 99254
// begin if IsDead ( un ) then
99182: LD_VAR 0 2
99186: PPUSH
99187: CALL_OW 301
99191: IFFALSE 99211
// begin tmp := tmp diff un ;
99193: LD_ADDR_VAR 0 3
99197: PUSH
99198: LD_VAR 0 3
99202: PUSH
99203: LD_VAR 0 2
99207: DIFF
99208: ST_TO_ADDR
// continue ;
99209: GO 99179
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99211: LD_VAR 0 2
99215: PPUSH
99216: LD_INT 3
99218: PUSH
99219: LD_INT 22
99221: PUSH
99222: LD_INT 0
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PPUSH
99233: CALL_OW 69
99237: PPUSH
99238: LD_VAR 0 2
99242: PPUSH
99243: CALL_OW 74
99247: PPUSH
99248: CALL_OW 115
// end ;
99252: GO 99179
99254: POP
99255: POP
// until not tmp ;
99256: LD_VAR 0 3
99260: NOT
99261: IFFALSE 99162
// end ;
99263: PPOPN 3
99265: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99266: LD_EXP 109
99270: PUSH
99271: LD_EXP 134
99275: AND
99276: IFFALSE 99330
99278: GO 99280
99280: DISABLE
// begin ToLua ( displayTroll(); ) ;
99281: LD_STRING displayTroll();
99283: PPUSH
99284: CALL_OW 559
// wait ( 3 3$00 ) ;
99288: LD_INT 6300
99290: PPUSH
99291: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99295: LD_STRING hideTroll();
99297: PPUSH
99298: CALL_OW 559
// wait ( 1 1$00 ) ;
99302: LD_INT 2100
99304: PPUSH
99305: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99309: LD_STRING displayTroll();
99311: PPUSH
99312: CALL_OW 559
// wait ( 1 1$00 ) ;
99316: LD_INT 2100
99318: PPUSH
99319: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99323: LD_STRING hideTroll();
99325: PPUSH
99326: CALL_OW 559
// end ;
99330: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99331: LD_EXP 109
99335: PUSH
99336: LD_EXP 135
99340: AND
99341: IFFALSE 99404
99343: GO 99345
99345: DISABLE
99346: LD_INT 0
99348: PPUSH
// begin p := 0 ;
99349: LD_ADDR_VAR 0 1
99353: PUSH
99354: LD_INT 0
99356: ST_TO_ADDR
// repeat game_speed := 1 ;
99357: LD_ADDR_OWVAR 65
99361: PUSH
99362: LD_INT 1
99364: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99365: LD_INT 35
99367: PPUSH
99368: CALL_OW 67
// p := p + 1 ;
99372: LD_ADDR_VAR 0 1
99376: PUSH
99377: LD_VAR 0 1
99381: PUSH
99382: LD_INT 1
99384: PLUS
99385: ST_TO_ADDR
// until p >= 60 ;
99386: LD_VAR 0 1
99390: PUSH
99391: LD_INT 60
99393: GREATEREQUAL
99394: IFFALSE 99357
// game_speed := 4 ;
99396: LD_ADDR_OWVAR 65
99400: PUSH
99401: LD_INT 4
99403: ST_TO_ADDR
// end ;
99404: PPOPN 1
99406: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99407: LD_EXP 109
99411: PUSH
99412: LD_EXP 136
99416: AND
99417: IFFALSE 99563
99419: GO 99421
99421: DISABLE
99422: LD_INT 0
99424: PPUSH
99425: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99426: LD_ADDR_VAR 0 1
99430: PUSH
99431: LD_INT 22
99433: PUSH
99434: LD_OWVAR 2
99438: PUSH
99439: EMPTY
99440: LIST
99441: LIST
99442: PUSH
99443: LD_INT 2
99445: PUSH
99446: LD_INT 30
99448: PUSH
99449: LD_INT 0
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: PUSH
99456: LD_INT 30
99458: PUSH
99459: LD_INT 1
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: LIST
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: PPUSH
99475: CALL_OW 69
99479: ST_TO_ADDR
// if not depot then
99480: LD_VAR 0 1
99484: NOT
99485: IFFALSE 99489
// exit ;
99487: GO 99563
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99489: LD_ADDR_VAR 0 2
99493: PUSH
99494: LD_VAR 0 1
99498: PUSH
99499: LD_INT 1
99501: PPUSH
99502: LD_VAR 0 1
99506: PPUSH
99507: CALL_OW 12
99511: ARRAY
99512: PPUSH
99513: CALL_OW 274
99517: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99518: LD_VAR 0 2
99522: PPUSH
99523: LD_INT 1
99525: PPUSH
99526: LD_INT 0
99528: PPUSH
99529: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99533: LD_VAR 0 2
99537: PPUSH
99538: LD_INT 2
99540: PPUSH
99541: LD_INT 0
99543: PPUSH
99544: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99548: LD_VAR 0 2
99552: PPUSH
99553: LD_INT 3
99555: PPUSH
99556: LD_INT 0
99558: PPUSH
99559: CALL_OW 277
// end ;
99563: PPOPN 2
99565: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99566: LD_EXP 109
99570: PUSH
99571: LD_EXP 137
99575: AND
99576: IFFALSE 99673
99578: GO 99580
99580: DISABLE
99581: LD_INT 0
99583: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99584: LD_ADDR_VAR 0 1
99588: PUSH
99589: LD_INT 22
99591: PUSH
99592: LD_OWVAR 2
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: LD_INT 21
99603: PUSH
99604: LD_INT 1
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: PUSH
99611: LD_INT 3
99613: PUSH
99614: LD_INT 23
99616: PUSH
99617: LD_INT 0
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: EMPTY
99629: LIST
99630: LIST
99631: LIST
99632: PPUSH
99633: CALL_OW 69
99637: ST_TO_ADDR
// if not tmp then
99638: LD_VAR 0 1
99642: NOT
99643: IFFALSE 99647
// exit ;
99645: GO 99673
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99647: LD_VAR 0 1
99651: PUSH
99652: LD_INT 1
99654: PPUSH
99655: LD_VAR 0 1
99659: PPUSH
99660: CALL_OW 12
99664: ARRAY
99665: PPUSH
99666: LD_INT 200
99668: PPUSH
99669: CALL_OW 234
// end ;
99673: PPOPN 1
99675: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99676: LD_EXP 109
99680: PUSH
99681: LD_EXP 138
99685: AND
99686: IFFALSE 99765
99688: GO 99690
99690: DISABLE
99691: LD_INT 0
99693: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99694: LD_ADDR_VAR 0 1
99698: PUSH
99699: LD_INT 22
99701: PUSH
99702: LD_OWVAR 2
99706: PUSH
99707: EMPTY
99708: LIST
99709: LIST
99710: PUSH
99711: LD_INT 21
99713: PUSH
99714: LD_INT 2
99716: PUSH
99717: EMPTY
99718: LIST
99719: LIST
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PPUSH
99725: CALL_OW 69
99729: ST_TO_ADDR
// if not tmp then
99730: LD_VAR 0 1
99734: NOT
99735: IFFALSE 99739
// exit ;
99737: GO 99765
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99739: LD_VAR 0 1
99743: PUSH
99744: LD_INT 1
99746: PPUSH
99747: LD_VAR 0 1
99751: PPUSH
99752: CALL_OW 12
99756: ARRAY
99757: PPUSH
99758: LD_INT 60
99760: PPUSH
99761: CALL_OW 234
// end ;
99765: PPOPN 1
99767: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99768: LD_EXP 109
99772: PUSH
99773: LD_EXP 139
99777: AND
99778: IFFALSE 99877
99780: GO 99782
99782: DISABLE
99783: LD_INT 0
99785: PPUSH
99786: PPUSH
// begin enable ;
99787: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99788: LD_ADDR_VAR 0 1
99792: PUSH
99793: LD_INT 22
99795: PUSH
99796: LD_OWVAR 2
99800: PUSH
99801: EMPTY
99802: LIST
99803: LIST
99804: PUSH
99805: LD_INT 61
99807: PUSH
99808: EMPTY
99809: LIST
99810: PUSH
99811: LD_INT 33
99813: PUSH
99814: LD_INT 2
99816: PUSH
99817: EMPTY
99818: LIST
99819: LIST
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: LIST
99825: PPUSH
99826: CALL_OW 69
99830: ST_TO_ADDR
// if not tmp then
99831: LD_VAR 0 1
99835: NOT
99836: IFFALSE 99840
// exit ;
99838: GO 99877
// for i in tmp do
99840: LD_ADDR_VAR 0 2
99844: PUSH
99845: LD_VAR 0 1
99849: PUSH
99850: FOR_IN
99851: IFFALSE 99875
// if IsControledBy ( i ) then
99853: LD_VAR 0 2
99857: PPUSH
99858: CALL_OW 312
99862: IFFALSE 99873
// ComUnlink ( i ) ;
99864: LD_VAR 0 2
99868: PPUSH
99869: CALL_OW 136
99873: GO 99850
99875: POP
99876: POP
// end ;
99877: PPOPN 2
99879: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99880: LD_EXP 109
99884: PUSH
99885: LD_EXP 140
99889: AND
99890: IFFALSE 100030
99892: GO 99894
99894: DISABLE
99895: LD_INT 0
99897: PPUSH
99898: PPUSH
// begin ToLua ( displayPowell(); ) ;
99899: LD_STRING displayPowell();
99901: PPUSH
99902: CALL_OW 559
// uc_side := 0 ;
99906: LD_ADDR_OWVAR 20
99910: PUSH
99911: LD_INT 0
99913: ST_TO_ADDR
// uc_nation := 2 ;
99914: LD_ADDR_OWVAR 21
99918: PUSH
99919: LD_INT 2
99921: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99922: LD_ADDR_OWVAR 37
99926: PUSH
99927: LD_INT 14
99929: ST_TO_ADDR
// vc_engine := engine_siberite ;
99930: LD_ADDR_OWVAR 39
99934: PUSH
99935: LD_INT 3
99937: ST_TO_ADDR
// vc_control := control_apeman ;
99938: LD_ADDR_OWVAR 38
99942: PUSH
99943: LD_INT 5
99945: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99946: LD_ADDR_OWVAR 40
99950: PUSH
99951: LD_INT 29
99953: ST_TO_ADDR
// un := CreateVehicle ;
99954: LD_ADDR_VAR 0 2
99958: PUSH
99959: CALL_OW 45
99963: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99964: LD_VAR 0 2
99968: PPUSH
99969: LD_INT 1
99971: PPUSH
99972: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99976: LD_INT 35
99978: PPUSH
99979: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99983: LD_VAR 0 2
99987: PPUSH
99988: LD_INT 22
99990: PUSH
99991: LD_OWVAR 2
99995: PUSH
99996: EMPTY
99997: LIST
99998: LIST
99999: PPUSH
100000: CALL_OW 69
100004: PPUSH
100005: LD_VAR 0 2
100009: PPUSH
100010: CALL_OW 74
100014: PPUSH
100015: CALL_OW 115
// until IsDead ( un ) ;
100019: LD_VAR 0 2
100023: PPUSH
100024: CALL_OW 301
100028: IFFALSE 99976
// end ;
100030: PPOPN 2
100032: END
// every 0 0$1 trigger StreamModeActive and sStu do
100033: LD_EXP 109
100037: PUSH
100038: LD_EXP 148
100042: AND
100043: IFFALSE 100059
100045: GO 100047
100047: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100048: LD_STRING displayStucuk();
100050: PPUSH
100051: CALL_OW 559
// ResetFog ;
100055: CALL_OW 335
// end ;
100059: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100060: LD_EXP 109
100064: PUSH
100065: LD_EXP 141
100069: AND
100070: IFFALSE 100211
100072: GO 100074
100074: DISABLE
100075: LD_INT 0
100077: PPUSH
100078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100079: LD_ADDR_VAR 0 2
100083: PUSH
100084: LD_INT 22
100086: PUSH
100087: LD_OWVAR 2
100091: PUSH
100092: EMPTY
100093: LIST
100094: LIST
100095: PUSH
100096: LD_INT 21
100098: PUSH
100099: LD_INT 1
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PUSH
100106: EMPTY
100107: LIST
100108: LIST
100109: PPUSH
100110: CALL_OW 69
100114: ST_TO_ADDR
// if not tmp then
100115: LD_VAR 0 2
100119: NOT
100120: IFFALSE 100124
// exit ;
100122: GO 100211
// un := tmp [ rand ( 1 , tmp ) ] ;
100124: LD_ADDR_VAR 0 1
100128: PUSH
100129: LD_VAR 0 2
100133: PUSH
100134: LD_INT 1
100136: PPUSH
100137: LD_VAR 0 2
100141: PPUSH
100142: CALL_OW 12
100146: ARRAY
100147: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100148: LD_VAR 0 1
100152: PPUSH
100153: LD_INT 0
100155: PPUSH
100156: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100160: LD_VAR 0 1
100164: PPUSH
100165: LD_OWVAR 3
100169: PUSH
100170: LD_VAR 0 1
100174: DIFF
100175: PPUSH
100176: LD_VAR 0 1
100180: PPUSH
100181: CALL_OW 74
100185: PPUSH
100186: CALL_OW 115
// wait ( 0 0$20 ) ;
100190: LD_INT 700
100192: PPUSH
100193: CALL_OW 67
// SetSide ( un , your_side ) ;
100197: LD_VAR 0 1
100201: PPUSH
100202: LD_OWVAR 2
100206: PPUSH
100207: CALL_OW 235
// end ;
100211: PPOPN 2
100213: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100214: LD_EXP 109
100218: PUSH
100219: LD_EXP 142
100223: AND
100224: IFFALSE 100330
100226: GO 100228
100228: DISABLE
100229: LD_INT 0
100231: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100232: LD_ADDR_VAR 0 1
100236: PUSH
100237: LD_INT 22
100239: PUSH
100240: LD_OWVAR 2
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PUSH
100249: LD_INT 2
100251: PUSH
100252: LD_INT 30
100254: PUSH
100255: LD_INT 0
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PUSH
100262: LD_INT 30
100264: PUSH
100265: LD_INT 1
100267: PUSH
100268: EMPTY
100269: LIST
100270: LIST
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: LIST
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PPUSH
100281: CALL_OW 69
100285: ST_TO_ADDR
// if not depot then
100286: LD_VAR 0 1
100290: NOT
100291: IFFALSE 100295
// exit ;
100293: GO 100330
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100295: LD_VAR 0 1
100299: PUSH
100300: LD_INT 1
100302: ARRAY
100303: PPUSH
100304: CALL_OW 250
100308: PPUSH
100309: LD_VAR 0 1
100313: PUSH
100314: LD_INT 1
100316: ARRAY
100317: PPUSH
100318: CALL_OW 251
100322: PPUSH
100323: LD_INT 70
100325: PPUSH
100326: CALL_OW 495
// end ;
100330: PPOPN 1
100332: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100333: LD_EXP 109
100337: PUSH
100338: LD_EXP 143
100342: AND
100343: IFFALSE 100554
100345: GO 100347
100347: DISABLE
100348: LD_INT 0
100350: PPUSH
100351: PPUSH
100352: PPUSH
100353: PPUSH
100354: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100355: LD_ADDR_VAR 0 5
100359: PUSH
100360: LD_INT 22
100362: PUSH
100363: LD_OWVAR 2
100367: PUSH
100368: EMPTY
100369: LIST
100370: LIST
100371: PUSH
100372: LD_INT 21
100374: PUSH
100375: LD_INT 1
100377: PUSH
100378: EMPTY
100379: LIST
100380: LIST
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PPUSH
100386: CALL_OW 69
100390: ST_TO_ADDR
// if not tmp then
100391: LD_VAR 0 5
100395: NOT
100396: IFFALSE 100400
// exit ;
100398: GO 100554
// for i in tmp do
100400: LD_ADDR_VAR 0 1
100404: PUSH
100405: LD_VAR 0 5
100409: PUSH
100410: FOR_IN
100411: IFFALSE 100552
// begin d := rand ( 0 , 5 ) ;
100413: LD_ADDR_VAR 0 4
100417: PUSH
100418: LD_INT 0
100420: PPUSH
100421: LD_INT 5
100423: PPUSH
100424: CALL_OW 12
100428: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100429: LD_ADDR_VAR 0 2
100433: PUSH
100434: LD_VAR 0 1
100438: PPUSH
100439: CALL_OW 250
100443: PPUSH
100444: LD_VAR 0 4
100448: PPUSH
100449: LD_INT 3
100451: PPUSH
100452: LD_INT 12
100454: PPUSH
100455: CALL_OW 12
100459: PPUSH
100460: CALL_OW 272
100464: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100465: LD_ADDR_VAR 0 3
100469: PUSH
100470: LD_VAR 0 1
100474: PPUSH
100475: CALL_OW 251
100479: PPUSH
100480: LD_VAR 0 4
100484: PPUSH
100485: LD_INT 3
100487: PPUSH
100488: LD_INT 12
100490: PPUSH
100491: CALL_OW 12
100495: PPUSH
100496: CALL_OW 273
100500: ST_TO_ADDR
// if ValidHex ( x , y ) then
100501: LD_VAR 0 2
100505: PPUSH
100506: LD_VAR 0 3
100510: PPUSH
100511: CALL_OW 488
100515: IFFALSE 100550
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100517: LD_VAR 0 1
100521: PPUSH
100522: LD_VAR 0 2
100526: PPUSH
100527: LD_VAR 0 3
100531: PPUSH
100532: LD_INT 3
100534: PPUSH
100535: LD_INT 6
100537: PPUSH
100538: CALL_OW 12
100542: PPUSH
100543: LD_INT 1
100545: PPUSH
100546: CALL_OW 483
// end ;
100550: GO 100410
100552: POP
100553: POP
// end ;
100554: PPOPN 5
100556: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100557: LD_EXP 109
100561: PUSH
100562: LD_EXP 144
100566: AND
100567: IFFALSE 100661
100569: GO 100571
100571: DISABLE
100572: LD_INT 0
100574: PPUSH
100575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100576: LD_ADDR_VAR 0 2
100580: PUSH
100581: LD_INT 22
100583: PUSH
100584: LD_OWVAR 2
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: PUSH
100593: LD_INT 32
100595: PUSH
100596: LD_INT 1
100598: PUSH
100599: EMPTY
100600: LIST
100601: LIST
100602: PUSH
100603: LD_INT 21
100605: PUSH
100606: LD_INT 2
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: PUSH
100613: EMPTY
100614: LIST
100615: LIST
100616: LIST
100617: PPUSH
100618: CALL_OW 69
100622: ST_TO_ADDR
// if not tmp then
100623: LD_VAR 0 2
100627: NOT
100628: IFFALSE 100632
// exit ;
100630: GO 100661
// for i in tmp do
100632: LD_ADDR_VAR 0 1
100636: PUSH
100637: LD_VAR 0 2
100641: PUSH
100642: FOR_IN
100643: IFFALSE 100659
// SetFuel ( i , 0 ) ;
100645: LD_VAR 0 1
100649: PPUSH
100650: LD_INT 0
100652: PPUSH
100653: CALL_OW 240
100657: GO 100642
100659: POP
100660: POP
// end ;
100661: PPOPN 2
100663: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100664: LD_EXP 109
100668: PUSH
100669: LD_EXP 145
100673: AND
100674: IFFALSE 100740
100676: GO 100678
100678: DISABLE
100679: LD_INT 0
100681: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100682: LD_ADDR_VAR 0 1
100686: PUSH
100687: LD_INT 22
100689: PUSH
100690: LD_OWVAR 2
100694: PUSH
100695: EMPTY
100696: LIST
100697: LIST
100698: PUSH
100699: LD_INT 30
100701: PUSH
100702: LD_INT 29
100704: PUSH
100705: EMPTY
100706: LIST
100707: LIST
100708: PUSH
100709: EMPTY
100710: LIST
100711: LIST
100712: PPUSH
100713: CALL_OW 69
100717: ST_TO_ADDR
// if not tmp then
100718: LD_VAR 0 1
100722: NOT
100723: IFFALSE 100727
// exit ;
100725: GO 100740
// DestroyUnit ( tmp [ 1 ] ) ;
100727: LD_VAR 0 1
100731: PUSH
100732: LD_INT 1
100734: ARRAY
100735: PPUSH
100736: CALL_OW 65
// end ;
100740: PPOPN 1
100742: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100743: LD_EXP 109
100747: PUSH
100748: LD_EXP 147
100752: AND
100753: IFFALSE 100882
100755: GO 100757
100757: DISABLE
100758: LD_INT 0
100760: PPUSH
// begin uc_side := 0 ;
100761: LD_ADDR_OWVAR 20
100765: PUSH
100766: LD_INT 0
100768: ST_TO_ADDR
// uc_nation := nation_arabian ;
100769: LD_ADDR_OWVAR 21
100773: PUSH
100774: LD_INT 2
100776: ST_TO_ADDR
// hc_gallery :=  ;
100777: LD_ADDR_OWVAR 33
100781: PUSH
100782: LD_STRING 
100784: ST_TO_ADDR
// hc_name :=  ;
100785: LD_ADDR_OWVAR 26
100789: PUSH
100790: LD_STRING 
100792: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100793: LD_INT 1
100795: PPUSH
100796: LD_INT 11
100798: PPUSH
100799: LD_INT 10
100801: PPUSH
100802: CALL_OW 380
// un := CreateHuman ;
100806: LD_ADDR_VAR 0 1
100810: PUSH
100811: CALL_OW 44
100815: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100816: LD_VAR 0 1
100820: PPUSH
100821: LD_INT 1
100823: PPUSH
100824: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100828: LD_INT 35
100830: PPUSH
100831: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100835: LD_VAR 0 1
100839: PPUSH
100840: LD_INT 22
100842: PUSH
100843: LD_OWVAR 2
100847: PUSH
100848: EMPTY
100849: LIST
100850: LIST
100851: PPUSH
100852: CALL_OW 69
100856: PPUSH
100857: LD_VAR 0 1
100861: PPUSH
100862: CALL_OW 74
100866: PPUSH
100867: CALL_OW 115
// until IsDead ( un ) ;
100871: LD_VAR 0 1
100875: PPUSH
100876: CALL_OW 301
100880: IFFALSE 100828
// end ;
100882: PPOPN 1
100884: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100885: LD_EXP 109
100889: PUSH
100890: LD_EXP 149
100894: AND
100895: IFFALSE 100907
100897: GO 100899
100899: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100900: LD_STRING earthquake(getX(game), 0, 32)
100902: PPUSH
100903: CALL_OW 559
100907: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100908: LD_EXP 109
100912: PUSH
100913: LD_EXP 150
100917: AND
100918: IFFALSE 101009
100920: GO 100922
100922: DISABLE
100923: LD_INT 0
100925: PPUSH
// begin enable ;
100926: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100927: LD_ADDR_VAR 0 1
100931: PUSH
100932: LD_INT 22
100934: PUSH
100935: LD_OWVAR 2
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: PUSH
100944: LD_INT 21
100946: PUSH
100947: LD_INT 2
100949: PUSH
100950: EMPTY
100951: LIST
100952: LIST
100953: PUSH
100954: LD_INT 33
100956: PUSH
100957: LD_INT 3
100959: PUSH
100960: EMPTY
100961: LIST
100962: LIST
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: LIST
100968: PPUSH
100969: CALL_OW 69
100973: ST_TO_ADDR
// if not tmp then
100974: LD_VAR 0 1
100978: NOT
100979: IFFALSE 100983
// exit ;
100981: GO 101009
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100983: LD_VAR 0 1
100987: PUSH
100988: LD_INT 1
100990: PPUSH
100991: LD_VAR 0 1
100995: PPUSH
100996: CALL_OW 12
101000: ARRAY
101001: PPUSH
101002: LD_INT 1
101004: PPUSH
101005: CALL_OW 234
// end ;
101009: PPOPN 1
101011: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101012: LD_EXP 109
101016: PUSH
101017: LD_EXP 151
101021: AND
101022: IFFALSE 101163
101024: GO 101026
101026: DISABLE
101027: LD_INT 0
101029: PPUSH
101030: PPUSH
101031: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101032: LD_ADDR_VAR 0 3
101036: PUSH
101037: LD_INT 22
101039: PUSH
101040: LD_OWVAR 2
101044: PUSH
101045: EMPTY
101046: LIST
101047: LIST
101048: PUSH
101049: LD_INT 25
101051: PUSH
101052: LD_INT 1
101054: PUSH
101055: EMPTY
101056: LIST
101057: LIST
101058: PUSH
101059: EMPTY
101060: LIST
101061: LIST
101062: PPUSH
101063: CALL_OW 69
101067: ST_TO_ADDR
// if not tmp then
101068: LD_VAR 0 3
101072: NOT
101073: IFFALSE 101077
// exit ;
101075: GO 101163
// un := tmp [ rand ( 1 , tmp ) ] ;
101077: LD_ADDR_VAR 0 2
101081: PUSH
101082: LD_VAR 0 3
101086: PUSH
101087: LD_INT 1
101089: PPUSH
101090: LD_VAR 0 3
101094: PPUSH
101095: CALL_OW 12
101099: ARRAY
101100: ST_TO_ADDR
// if Crawls ( un ) then
101101: LD_VAR 0 2
101105: PPUSH
101106: CALL_OW 318
101110: IFFALSE 101121
// ComWalk ( un ) ;
101112: LD_VAR 0 2
101116: PPUSH
101117: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101121: LD_VAR 0 2
101125: PPUSH
101126: LD_INT 9
101128: PPUSH
101129: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101133: LD_INT 28
101135: PPUSH
101136: LD_OWVAR 2
101140: PPUSH
101141: LD_INT 2
101143: PPUSH
101144: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101148: LD_INT 29
101150: PPUSH
101151: LD_OWVAR 2
101155: PPUSH
101156: LD_INT 2
101158: PPUSH
101159: CALL_OW 322
// end ;
101163: PPOPN 3
101165: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101166: LD_EXP 109
101170: PUSH
101171: LD_EXP 152
101175: AND
101176: IFFALSE 101287
101178: GO 101180
101180: DISABLE
101181: LD_INT 0
101183: PPUSH
101184: PPUSH
101185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101186: LD_ADDR_VAR 0 3
101190: PUSH
101191: LD_INT 22
101193: PUSH
101194: LD_OWVAR 2
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 25
101205: PUSH
101206: LD_INT 1
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: PPUSH
101217: CALL_OW 69
101221: ST_TO_ADDR
// if not tmp then
101222: LD_VAR 0 3
101226: NOT
101227: IFFALSE 101231
// exit ;
101229: GO 101287
// un := tmp [ rand ( 1 , tmp ) ] ;
101231: LD_ADDR_VAR 0 2
101235: PUSH
101236: LD_VAR 0 3
101240: PUSH
101241: LD_INT 1
101243: PPUSH
101244: LD_VAR 0 3
101248: PPUSH
101249: CALL_OW 12
101253: ARRAY
101254: ST_TO_ADDR
// if Crawls ( un ) then
101255: LD_VAR 0 2
101259: PPUSH
101260: CALL_OW 318
101264: IFFALSE 101275
// ComWalk ( un ) ;
101266: LD_VAR 0 2
101270: PPUSH
101271: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101275: LD_VAR 0 2
101279: PPUSH
101280: LD_INT 8
101282: PPUSH
101283: CALL_OW 336
// end ;
101287: PPOPN 3
101289: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101290: LD_EXP 109
101294: PUSH
101295: LD_EXP 153
101299: AND
101300: IFFALSE 101444
101302: GO 101304
101304: DISABLE
101305: LD_INT 0
101307: PPUSH
101308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101309: LD_ADDR_VAR 0 2
101313: PUSH
101314: LD_INT 22
101316: PUSH
101317: LD_OWVAR 2
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 21
101328: PUSH
101329: LD_INT 2
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: LD_INT 2
101338: PUSH
101339: LD_INT 34
101341: PUSH
101342: LD_INT 12
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PUSH
101349: LD_INT 34
101351: PUSH
101352: LD_INT 51
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: PUSH
101359: LD_INT 34
101361: PUSH
101362: LD_INT 32
101364: PUSH
101365: EMPTY
101366: LIST
101367: LIST
101368: PUSH
101369: EMPTY
101370: LIST
101371: LIST
101372: LIST
101373: LIST
101374: PUSH
101375: EMPTY
101376: LIST
101377: LIST
101378: LIST
101379: PPUSH
101380: CALL_OW 69
101384: ST_TO_ADDR
// if not tmp then
101385: LD_VAR 0 2
101389: NOT
101390: IFFALSE 101394
// exit ;
101392: GO 101444
// for i in tmp do
101394: LD_ADDR_VAR 0 1
101398: PUSH
101399: LD_VAR 0 2
101403: PUSH
101404: FOR_IN
101405: IFFALSE 101442
// if GetCargo ( i , mat_artifact ) = 0 then
101407: LD_VAR 0 1
101411: PPUSH
101412: LD_INT 4
101414: PPUSH
101415: CALL_OW 289
101419: PUSH
101420: LD_INT 0
101422: EQUAL
101423: IFFALSE 101440
// SetCargo ( i , mat_siberit , 100 ) ;
101425: LD_VAR 0 1
101429: PPUSH
101430: LD_INT 3
101432: PPUSH
101433: LD_INT 100
101435: PPUSH
101436: CALL_OW 290
101440: GO 101404
101442: POP
101443: POP
// end ;
101444: PPOPN 2
101446: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101447: LD_EXP 109
101451: PUSH
101452: LD_EXP 154
101456: AND
101457: IFFALSE 101640
101459: GO 101461
101461: DISABLE
101462: LD_INT 0
101464: PPUSH
101465: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101466: LD_ADDR_VAR 0 2
101470: PUSH
101471: LD_INT 22
101473: PUSH
101474: LD_OWVAR 2
101478: PUSH
101479: EMPTY
101480: LIST
101481: LIST
101482: PPUSH
101483: CALL_OW 69
101487: ST_TO_ADDR
// if not tmp then
101488: LD_VAR 0 2
101492: NOT
101493: IFFALSE 101497
// exit ;
101495: GO 101640
// for i := 1 to 2 do
101497: LD_ADDR_VAR 0 1
101501: PUSH
101502: DOUBLE
101503: LD_INT 1
101505: DEC
101506: ST_TO_ADDR
101507: LD_INT 2
101509: PUSH
101510: FOR_TO
101511: IFFALSE 101638
// begin uc_side := your_side ;
101513: LD_ADDR_OWVAR 20
101517: PUSH
101518: LD_OWVAR 2
101522: ST_TO_ADDR
// uc_nation := nation_american ;
101523: LD_ADDR_OWVAR 21
101527: PUSH
101528: LD_INT 1
101530: ST_TO_ADDR
// vc_chassis := us_morphling ;
101531: LD_ADDR_OWVAR 37
101535: PUSH
101536: LD_INT 5
101538: ST_TO_ADDR
// vc_engine := engine_siberite ;
101539: LD_ADDR_OWVAR 39
101543: PUSH
101544: LD_INT 3
101546: ST_TO_ADDR
// vc_control := control_computer ;
101547: LD_ADDR_OWVAR 38
101551: PUSH
101552: LD_INT 3
101554: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101555: LD_ADDR_OWVAR 40
101559: PUSH
101560: LD_INT 10
101562: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101563: LD_VAR 0 2
101567: PUSH
101568: LD_INT 1
101570: ARRAY
101571: PPUSH
101572: CALL_OW 310
101576: NOT
101577: IFFALSE 101624
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101579: CALL_OW 45
101583: PPUSH
101584: LD_VAR 0 2
101588: PUSH
101589: LD_INT 1
101591: ARRAY
101592: PPUSH
101593: CALL_OW 250
101597: PPUSH
101598: LD_VAR 0 2
101602: PUSH
101603: LD_INT 1
101605: ARRAY
101606: PPUSH
101607: CALL_OW 251
101611: PPUSH
101612: LD_INT 12
101614: PPUSH
101615: LD_INT 1
101617: PPUSH
101618: CALL_OW 50
101622: GO 101636
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101624: CALL_OW 45
101628: PPUSH
101629: LD_INT 1
101631: PPUSH
101632: CALL_OW 51
// end ;
101636: GO 101510
101638: POP
101639: POP
// end ;
101640: PPOPN 2
101642: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101643: LD_EXP 109
101647: PUSH
101648: LD_EXP 155
101652: AND
101653: IFFALSE 101875
101655: GO 101657
101657: DISABLE
101658: LD_INT 0
101660: PPUSH
101661: PPUSH
101662: PPUSH
101663: PPUSH
101664: PPUSH
101665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101666: LD_ADDR_VAR 0 6
101670: PUSH
101671: LD_INT 22
101673: PUSH
101674: LD_OWVAR 2
101678: PUSH
101679: EMPTY
101680: LIST
101681: LIST
101682: PUSH
101683: LD_INT 21
101685: PUSH
101686: LD_INT 1
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PUSH
101693: LD_INT 3
101695: PUSH
101696: LD_INT 23
101698: PUSH
101699: LD_INT 0
101701: PUSH
101702: EMPTY
101703: LIST
101704: LIST
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: LIST
101714: PPUSH
101715: CALL_OW 69
101719: ST_TO_ADDR
// if not tmp then
101720: LD_VAR 0 6
101724: NOT
101725: IFFALSE 101729
// exit ;
101727: GO 101875
// s1 := rand ( 1 , 4 ) ;
101729: LD_ADDR_VAR 0 2
101733: PUSH
101734: LD_INT 1
101736: PPUSH
101737: LD_INT 4
101739: PPUSH
101740: CALL_OW 12
101744: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101745: LD_ADDR_VAR 0 4
101749: PUSH
101750: LD_VAR 0 6
101754: PUSH
101755: LD_INT 1
101757: ARRAY
101758: PPUSH
101759: LD_VAR 0 2
101763: PPUSH
101764: CALL_OW 259
101768: ST_TO_ADDR
// if s1 = 1 then
101769: LD_VAR 0 2
101773: PUSH
101774: LD_INT 1
101776: EQUAL
101777: IFFALSE 101797
// s2 := rand ( 2 , 4 ) else
101779: LD_ADDR_VAR 0 3
101783: PUSH
101784: LD_INT 2
101786: PPUSH
101787: LD_INT 4
101789: PPUSH
101790: CALL_OW 12
101794: ST_TO_ADDR
101795: GO 101805
// s2 := 1 ;
101797: LD_ADDR_VAR 0 3
101801: PUSH
101802: LD_INT 1
101804: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101805: LD_ADDR_VAR 0 5
101809: PUSH
101810: LD_VAR 0 6
101814: PUSH
101815: LD_INT 1
101817: ARRAY
101818: PPUSH
101819: LD_VAR 0 3
101823: PPUSH
101824: CALL_OW 259
101828: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101829: LD_VAR 0 6
101833: PUSH
101834: LD_INT 1
101836: ARRAY
101837: PPUSH
101838: LD_VAR 0 2
101842: PPUSH
101843: LD_VAR 0 5
101847: PPUSH
101848: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101852: LD_VAR 0 6
101856: PUSH
101857: LD_INT 1
101859: ARRAY
101860: PPUSH
101861: LD_VAR 0 3
101865: PPUSH
101866: LD_VAR 0 4
101870: PPUSH
101871: CALL_OW 237
// end ;
101875: PPOPN 6
101877: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101878: LD_EXP 109
101882: PUSH
101883: LD_EXP 156
101887: AND
101888: IFFALSE 101967
101890: GO 101892
101892: DISABLE
101893: LD_INT 0
101895: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101896: LD_ADDR_VAR 0 1
101900: PUSH
101901: LD_INT 22
101903: PUSH
101904: LD_OWVAR 2
101908: PUSH
101909: EMPTY
101910: LIST
101911: LIST
101912: PUSH
101913: LD_INT 30
101915: PUSH
101916: LD_INT 3
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: PUSH
101923: EMPTY
101924: LIST
101925: LIST
101926: PPUSH
101927: CALL_OW 69
101931: ST_TO_ADDR
// if not tmp then
101932: LD_VAR 0 1
101936: NOT
101937: IFFALSE 101941
// exit ;
101939: GO 101967
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101941: LD_VAR 0 1
101945: PUSH
101946: LD_INT 1
101948: PPUSH
101949: LD_VAR 0 1
101953: PPUSH
101954: CALL_OW 12
101958: ARRAY
101959: PPUSH
101960: LD_INT 1
101962: PPUSH
101963: CALL_OW 234
// end ;
101967: PPOPN 1
101969: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101970: LD_EXP 109
101974: PUSH
101975: LD_EXP 157
101979: AND
101980: IFFALSE 102092
101982: GO 101984
101984: DISABLE
101985: LD_INT 0
101987: PPUSH
101988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101989: LD_ADDR_VAR 0 2
101993: PUSH
101994: LD_INT 22
101996: PUSH
101997: LD_OWVAR 2
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PUSH
102006: LD_INT 2
102008: PUSH
102009: LD_INT 30
102011: PUSH
102012: LD_INT 27
102014: PUSH
102015: EMPTY
102016: LIST
102017: LIST
102018: PUSH
102019: LD_INT 30
102021: PUSH
102022: LD_INT 26
102024: PUSH
102025: EMPTY
102026: LIST
102027: LIST
102028: PUSH
102029: LD_INT 30
102031: PUSH
102032: LD_INT 28
102034: PUSH
102035: EMPTY
102036: LIST
102037: LIST
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: LIST
102043: LIST
102044: PUSH
102045: EMPTY
102046: LIST
102047: LIST
102048: PPUSH
102049: CALL_OW 69
102053: ST_TO_ADDR
// if not tmp then
102054: LD_VAR 0 2
102058: NOT
102059: IFFALSE 102063
// exit ;
102061: GO 102092
// for i in tmp do
102063: LD_ADDR_VAR 0 1
102067: PUSH
102068: LD_VAR 0 2
102072: PUSH
102073: FOR_IN
102074: IFFALSE 102090
// SetLives ( i , 1 ) ;
102076: LD_VAR 0 1
102080: PPUSH
102081: LD_INT 1
102083: PPUSH
102084: CALL_OW 234
102088: GO 102073
102090: POP
102091: POP
// end ;
102092: PPOPN 2
102094: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102095: LD_EXP 109
102099: PUSH
102100: LD_EXP 158
102104: AND
102105: IFFALSE 102392
102107: GO 102109
102109: DISABLE
102110: LD_INT 0
102112: PPUSH
102113: PPUSH
102114: PPUSH
// begin i := rand ( 1 , 7 ) ;
102115: LD_ADDR_VAR 0 1
102119: PUSH
102120: LD_INT 1
102122: PPUSH
102123: LD_INT 7
102125: PPUSH
102126: CALL_OW 12
102130: ST_TO_ADDR
// case i of 1 :
102131: LD_VAR 0 1
102135: PUSH
102136: LD_INT 1
102138: DOUBLE
102139: EQUAL
102140: IFTRUE 102144
102142: GO 102154
102144: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102145: LD_STRING earthquake(getX(game), 0, 32)
102147: PPUSH
102148: CALL_OW 559
102152: GO 102392
102154: LD_INT 2
102156: DOUBLE
102157: EQUAL
102158: IFTRUE 102162
102160: GO 102176
102162: POP
// begin ToLua ( displayStucuk(); ) ;
102163: LD_STRING displayStucuk();
102165: PPUSH
102166: CALL_OW 559
// ResetFog ;
102170: CALL_OW 335
// end ; 3 :
102174: GO 102392
102176: LD_INT 3
102178: DOUBLE
102179: EQUAL
102180: IFTRUE 102184
102182: GO 102288
102184: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102185: LD_ADDR_VAR 0 2
102189: PUSH
102190: LD_INT 22
102192: PUSH
102193: LD_OWVAR 2
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 25
102204: PUSH
102205: LD_INT 1
102207: PUSH
102208: EMPTY
102209: LIST
102210: LIST
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PPUSH
102216: CALL_OW 69
102220: ST_TO_ADDR
// if not tmp then
102221: LD_VAR 0 2
102225: NOT
102226: IFFALSE 102230
// exit ;
102228: GO 102392
// un := tmp [ rand ( 1 , tmp ) ] ;
102230: LD_ADDR_VAR 0 3
102234: PUSH
102235: LD_VAR 0 2
102239: PUSH
102240: LD_INT 1
102242: PPUSH
102243: LD_VAR 0 2
102247: PPUSH
102248: CALL_OW 12
102252: ARRAY
102253: ST_TO_ADDR
// if Crawls ( un ) then
102254: LD_VAR 0 3
102258: PPUSH
102259: CALL_OW 318
102263: IFFALSE 102274
// ComWalk ( un ) ;
102265: LD_VAR 0 3
102269: PPUSH
102270: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102274: LD_VAR 0 3
102278: PPUSH
102279: LD_INT 8
102281: PPUSH
102282: CALL_OW 336
// end ; 4 :
102286: GO 102392
102288: LD_INT 4
102290: DOUBLE
102291: EQUAL
102292: IFTRUE 102296
102294: GO 102370
102296: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102297: LD_ADDR_VAR 0 2
102301: PUSH
102302: LD_INT 22
102304: PUSH
102305: LD_OWVAR 2
102309: PUSH
102310: EMPTY
102311: LIST
102312: LIST
102313: PUSH
102314: LD_INT 30
102316: PUSH
102317: LD_INT 29
102319: PUSH
102320: EMPTY
102321: LIST
102322: LIST
102323: PUSH
102324: EMPTY
102325: LIST
102326: LIST
102327: PPUSH
102328: CALL_OW 69
102332: ST_TO_ADDR
// if not tmp then
102333: LD_VAR 0 2
102337: NOT
102338: IFFALSE 102342
// exit ;
102340: GO 102392
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102342: LD_VAR 0 2
102346: PUSH
102347: LD_INT 1
102349: ARRAY
102350: PPUSH
102351: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102355: LD_VAR 0 2
102359: PUSH
102360: LD_INT 1
102362: ARRAY
102363: PPUSH
102364: CALL_OW 65
// end ; 5 .. 7 :
102368: GO 102392
102370: LD_INT 5
102372: DOUBLE
102373: GREATEREQUAL
102374: IFFALSE 102382
102376: LD_INT 7
102378: DOUBLE
102379: LESSEQUAL
102380: IFTRUE 102384
102382: GO 102391
102384: POP
// StreamSibBomb ; end ;
102385: CALL 98629 0 0
102389: GO 102392
102391: POP
// end ;
102392: PPOPN 3
102394: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102395: LD_EXP 109
102399: PUSH
102400: LD_EXP 159
102404: AND
102405: IFFALSE 102561
102407: GO 102409
102409: DISABLE
102410: LD_INT 0
102412: PPUSH
102413: PPUSH
102414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102415: LD_ADDR_VAR 0 2
102419: PUSH
102420: LD_INT 81
102422: PUSH
102423: LD_OWVAR 2
102427: PUSH
102428: EMPTY
102429: LIST
102430: LIST
102431: PUSH
102432: LD_INT 2
102434: PUSH
102435: LD_INT 21
102437: PUSH
102438: LD_INT 1
102440: PUSH
102441: EMPTY
102442: LIST
102443: LIST
102444: PUSH
102445: LD_INT 21
102447: PUSH
102448: LD_INT 2
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: LIST
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: PPUSH
102464: CALL_OW 69
102468: ST_TO_ADDR
// if not tmp then
102469: LD_VAR 0 2
102473: NOT
102474: IFFALSE 102478
// exit ;
102476: GO 102561
// p := 0 ;
102478: LD_ADDR_VAR 0 3
102482: PUSH
102483: LD_INT 0
102485: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102486: LD_INT 35
102488: PPUSH
102489: CALL_OW 67
// p := p + 1 ;
102493: LD_ADDR_VAR 0 3
102497: PUSH
102498: LD_VAR 0 3
102502: PUSH
102503: LD_INT 1
102505: PLUS
102506: ST_TO_ADDR
// for i in tmp do
102507: LD_ADDR_VAR 0 1
102511: PUSH
102512: LD_VAR 0 2
102516: PUSH
102517: FOR_IN
102518: IFFALSE 102549
// if GetLives ( i ) < 1000 then
102520: LD_VAR 0 1
102524: PPUSH
102525: CALL_OW 256
102529: PUSH
102530: LD_INT 1000
102532: LESS
102533: IFFALSE 102547
// SetLives ( i , 1000 ) ;
102535: LD_VAR 0 1
102539: PPUSH
102540: LD_INT 1000
102542: PPUSH
102543: CALL_OW 234
102547: GO 102517
102549: POP
102550: POP
// until p > 20 ;
102551: LD_VAR 0 3
102555: PUSH
102556: LD_INT 20
102558: GREATER
102559: IFFALSE 102486
// end ;
102561: PPOPN 3
102563: END
// every 0 0$1 trigger StreamModeActive and sTime do
102564: LD_EXP 109
102568: PUSH
102569: LD_EXP 160
102573: AND
102574: IFFALSE 102609
102576: GO 102578
102578: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102579: LD_INT 28
102581: PPUSH
102582: LD_OWVAR 2
102586: PPUSH
102587: LD_INT 2
102589: PPUSH
102590: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102594: LD_INT 30
102596: PPUSH
102597: LD_OWVAR 2
102601: PPUSH
102602: LD_INT 2
102604: PPUSH
102605: CALL_OW 322
// end ;
102609: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102610: LD_EXP 109
102614: PUSH
102615: LD_EXP 161
102619: AND
102620: IFFALSE 102741
102622: GO 102624
102624: DISABLE
102625: LD_INT 0
102627: PPUSH
102628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102629: LD_ADDR_VAR 0 2
102633: PUSH
102634: LD_INT 22
102636: PUSH
102637: LD_OWVAR 2
102641: PUSH
102642: EMPTY
102643: LIST
102644: LIST
102645: PUSH
102646: LD_INT 21
102648: PUSH
102649: LD_INT 1
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: PUSH
102656: LD_INT 3
102658: PUSH
102659: LD_INT 23
102661: PUSH
102662: LD_INT 0
102664: PUSH
102665: EMPTY
102666: LIST
102667: LIST
102668: PUSH
102669: EMPTY
102670: LIST
102671: LIST
102672: PUSH
102673: EMPTY
102674: LIST
102675: LIST
102676: LIST
102677: PPUSH
102678: CALL_OW 69
102682: ST_TO_ADDR
// if not tmp then
102683: LD_VAR 0 2
102687: NOT
102688: IFFALSE 102692
// exit ;
102690: GO 102741
// for i in tmp do
102692: LD_ADDR_VAR 0 1
102696: PUSH
102697: LD_VAR 0 2
102701: PUSH
102702: FOR_IN
102703: IFFALSE 102739
// begin if Crawls ( i ) then
102705: LD_VAR 0 1
102709: PPUSH
102710: CALL_OW 318
102714: IFFALSE 102725
// ComWalk ( i ) ;
102716: LD_VAR 0 1
102720: PPUSH
102721: CALL_OW 138
// SetClass ( i , 2 ) ;
102725: LD_VAR 0 1
102729: PPUSH
102730: LD_INT 2
102732: PPUSH
102733: CALL_OW 336
// end ;
102737: GO 102702
102739: POP
102740: POP
// end ;
102741: PPOPN 2
102743: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102744: LD_EXP 109
102748: PUSH
102749: LD_EXP 162
102753: AND
102754: IFFALSE 103042
102756: GO 102758
102758: DISABLE
102759: LD_INT 0
102761: PPUSH
102762: PPUSH
102763: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102764: LD_OWVAR 2
102768: PPUSH
102769: LD_INT 9
102771: PPUSH
102772: LD_INT 1
102774: PPUSH
102775: LD_INT 1
102777: PPUSH
102778: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102782: LD_INT 9
102784: PPUSH
102785: LD_OWVAR 2
102789: PPUSH
102790: CALL_OW 343
// uc_side := 9 ;
102794: LD_ADDR_OWVAR 20
102798: PUSH
102799: LD_INT 9
102801: ST_TO_ADDR
// uc_nation := 2 ;
102802: LD_ADDR_OWVAR 21
102806: PUSH
102807: LD_INT 2
102809: ST_TO_ADDR
// hc_name := Dark Warrior ;
102810: LD_ADDR_OWVAR 26
102814: PUSH
102815: LD_STRING Dark Warrior
102817: ST_TO_ADDR
// hc_gallery :=  ;
102818: LD_ADDR_OWVAR 33
102822: PUSH
102823: LD_STRING 
102825: ST_TO_ADDR
// hc_noskilllimit := true ;
102826: LD_ADDR_OWVAR 76
102830: PUSH
102831: LD_INT 1
102833: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102834: LD_ADDR_OWVAR 31
102838: PUSH
102839: LD_INT 30
102841: PUSH
102842: LD_INT 30
102844: PUSH
102845: LD_INT 30
102847: PUSH
102848: LD_INT 30
102850: PUSH
102851: EMPTY
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: ST_TO_ADDR
// un := CreateHuman ;
102857: LD_ADDR_VAR 0 3
102861: PUSH
102862: CALL_OW 44
102866: ST_TO_ADDR
// hc_noskilllimit := false ;
102867: LD_ADDR_OWVAR 76
102871: PUSH
102872: LD_INT 0
102874: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102875: LD_VAR 0 3
102879: PPUSH
102880: LD_INT 1
102882: PPUSH
102883: CALL_OW 51
// ToLua ( playRanger() ) ;
102887: LD_STRING playRanger()
102889: PPUSH
102890: CALL_OW 559
// p := 0 ;
102894: LD_ADDR_VAR 0 2
102898: PUSH
102899: LD_INT 0
102901: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102902: LD_INT 35
102904: PPUSH
102905: CALL_OW 67
// p := p + 1 ;
102909: LD_ADDR_VAR 0 2
102913: PUSH
102914: LD_VAR 0 2
102918: PUSH
102919: LD_INT 1
102921: PLUS
102922: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102923: LD_VAR 0 3
102927: PPUSH
102928: CALL_OW 256
102932: PUSH
102933: LD_INT 1000
102935: LESS
102936: IFFALSE 102950
// SetLives ( un , 1000 ) ;
102938: LD_VAR 0 3
102942: PPUSH
102943: LD_INT 1000
102945: PPUSH
102946: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102950: LD_VAR 0 3
102954: PPUSH
102955: LD_INT 81
102957: PUSH
102958: LD_OWVAR 2
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: PUSH
102967: LD_INT 91
102969: PUSH
102970: LD_VAR 0 3
102974: PUSH
102975: LD_INT 30
102977: PUSH
102978: EMPTY
102979: LIST
102980: LIST
102981: LIST
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: PPUSH
102987: CALL_OW 69
102991: PPUSH
102992: LD_VAR 0 3
102996: PPUSH
102997: CALL_OW 74
103001: PPUSH
103002: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103006: LD_VAR 0 2
103010: PUSH
103011: LD_INT 80
103013: GREATER
103014: PUSH
103015: LD_VAR 0 3
103019: PPUSH
103020: CALL_OW 301
103024: OR
103025: IFFALSE 102902
// if un then
103027: LD_VAR 0 3
103031: IFFALSE 103042
// RemoveUnit ( un ) ;
103033: LD_VAR 0 3
103037: PPUSH
103038: CALL_OW 64
// end ;
103042: PPOPN 3
103044: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103045: LD_EXP 163
103049: IFFALSE 103165
103051: GO 103053
103053: DISABLE
103054: LD_INT 0
103056: PPUSH
103057: PPUSH
103058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103059: LD_ADDR_VAR 0 2
103063: PUSH
103064: LD_INT 81
103066: PUSH
103067: LD_OWVAR 2
103071: PUSH
103072: EMPTY
103073: LIST
103074: LIST
103075: PUSH
103076: LD_INT 21
103078: PUSH
103079: LD_INT 1
103081: PUSH
103082: EMPTY
103083: LIST
103084: LIST
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: PPUSH
103090: CALL_OW 69
103094: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103095: LD_STRING playComputer()
103097: PPUSH
103098: CALL_OW 559
// if not tmp then
103102: LD_VAR 0 2
103106: NOT
103107: IFFALSE 103111
// exit ;
103109: GO 103165
// for i in tmp do
103111: LD_ADDR_VAR 0 1
103115: PUSH
103116: LD_VAR 0 2
103120: PUSH
103121: FOR_IN
103122: IFFALSE 103163
// for j := 1 to 4 do
103124: LD_ADDR_VAR 0 3
103128: PUSH
103129: DOUBLE
103130: LD_INT 1
103132: DEC
103133: ST_TO_ADDR
103134: LD_INT 4
103136: PUSH
103137: FOR_TO
103138: IFFALSE 103159
// SetSkill ( i , j , 10 ) ;
103140: LD_VAR 0 1
103144: PPUSH
103145: LD_VAR 0 3
103149: PPUSH
103150: LD_INT 10
103152: PPUSH
103153: CALL_OW 237
103157: GO 103137
103159: POP
103160: POP
103161: GO 103121
103163: POP
103164: POP
// end ;
103165: PPOPN 3
103167: END
// every 0 0$1 trigger s30 do var i , tmp ;
103168: LD_EXP 164
103172: IFFALSE 103241
103174: GO 103176
103176: DISABLE
103177: LD_INT 0
103179: PPUSH
103180: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103181: LD_ADDR_VAR 0 2
103185: PUSH
103186: LD_INT 22
103188: PUSH
103189: LD_OWVAR 2
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: PPUSH
103198: CALL_OW 69
103202: ST_TO_ADDR
// if not tmp then
103203: LD_VAR 0 2
103207: NOT
103208: IFFALSE 103212
// exit ;
103210: GO 103241
// for i in tmp do
103212: LD_ADDR_VAR 0 1
103216: PUSH
103217: LD_VAR 0 2
103221: PUSH
103222: FOR_IN
103223: IFFALSE 103239
// SetLives ( i , 300 ) ;
103225: LD_VAR 0 1
103229: PPUSH
103230: LD_INT 300
103232: PPUSH
103233: CALL_OW 234
103237: GO 103222
103239: POP
103240: POP
// end ;
103241: PPOPN 2
103243: END
// every 0 0$1 trigger s60 do var i , tmp ;
103244: LD_EXP 165
103248: IFFALSE 103317
103250: GO 103252
103252: DISABLE
103253: LD_INT 0
103255: PPUSH
103256: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103257: LD_ADDR_VAR 0 2
103261: PUSH
103262: LD_INT 22
103264: PUSH
103265: LD_OWVAR 2
103269: PUSH
103270: EMPTY
103271: LIST
103272: LIST
103273: PPUSH
103274: CALL_OW 69
103278: ST_TO_ADDR
// if not tmp then
103279: LD_VAR 0 2
103283: NOT
103284: IFFALSE 103288
// exit ;
103286: GO 103317
// for i in tmp do
103288: LD_ADDR_VAR 0 1
103292: PUSH
103293: LD_VAR 0 2
103297: PUSH
103298: FOR_IN
103299: IFFALSE 103315
// SetLives ( i , 600 ) ;
103301: LD_VAR 0 1
103305: PPUSH
103306: LD_INT 600
103308: PPUSH
103309: CALL_OW 234
103313: GO 103298
103315: POP
103316: POP
// end ;
103317: PPOPN 2
103319: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103320: LD_INT 0
103322: PPUSH
// case cmd of 301 :
103323: LD_VAR 0 1
103327: PUSH
103328: LD_INT 301
103330: DOUBLE
103331: EQUAL
103332: IFTRUE 103336
103334: GO 103368
103336: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103337: LD_VAR 0 6
103341: PPUSH
103342: LD_VAR 0 7
103346: PPUSH
103347: LD_VAR 0 8
103351: PPUSH
103352: LD_VAR 0 4
103356: PPUSH
103357: LD_VAR 0 5
103361: PPUSH
103362: CALL 104577 0 5
103366: GO 103489
103368: LD_INT 302
103370: DOUBLE
103371: EQUAL
103372: IFTRUE 103376
103374: GO 103413
103376: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103377: LD_VAR 0 6
103381: PPUSH
103382: LD_VAR 0 7
103386: PPUSH
103387: LD_VAR 0 8
103391: PPUSH
103392: LD_VAR 0 9
103396: PPUSH
103397: LD_VAR 0 4
103401: PPUSH
103402: LD_VAR 0 5
103406: PPUSH
103407: CALL 104668 0 6
103411: GO 103489
103413: LD_INT 303
103415: DOUBLE
103416: EQUAL
103417: IFTRUE 103421
103419: GO 103458
103421: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103422: LD_VAR 0 6
103426: PPUSH
103427: LD_VAR 0 7
103431: PPUSH
103432: LD_VAR 0 8
103436: PPUSH
103437: LD_VAR 0 9
103441: PPUSH
103442: LD_VAR 0 4
103446: PPUSH
103447: LD_VAR 0 5
103451: PPUSH
103452: CALL 103494 0 6
103456: GO 103489
103458: LD_INT 304
103460: DOUBLE
103461: EQUAL
103462: IFTRUE 103466
103464: GO 103488
103466: POP
// hHackTeleport ( unit , x , y ) ; end ;
103467: LD_VAR 0 2
103471: PPUSH
103472: LD_VAR 0 4
103476: PPUSH
103477: LD_VAR 0 5
103481: PPUSH
103482: CALL 105261 0 3
103486: GO 103489
103488: POP
// end ;
103489: LD_VAR 0 12
103493: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103494: LD_INT 0
103496: PPUSH
103497: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103498: LD_VAR 0 1
103502: PUSH
103503: LD_INT 1
103505: LESS
103506: PUSH
103507: LD_VAR 0 1
103511: PUSH
103512: LD_INT 3
103514: GREATER
103515: OR
103516: PUSH
103517: LD_VAR 0 5
103521: PPUSH
103522: LD_VAR 0 6
103526: PPUSH
103527: CALL_OW 428
103531: OR
103532: IFFALSE 103536
// exit ;
103534: GO 104264
// uc_side := your_side ;
103536: LD_ADDR_OWVAR 20
103540: PUSH
103541: LD_OWVAR 2
103545: ST_TO_ADDR
// uc_nation := nation ;
103546: LD_ADDR_OWVAR 21
103550: PUSH
103551: LD_VAR 0 1
103555: ST_TO_ADDR
// bc_level = 1 ;
103556: LD_ADDR_OWVAR 43
103560: PUSH
103561: LD_INT 1
103563: ST_TO_ADDR
// case btype of 1 :
103564: LD_VAR 0 2
103568: PUSH
103569: LD_INT 1
103571: DOUBLE
103572: EQUAL
103573: IFTRUE 103577
103575: GO 103588
103577: POP
// bc_type := b_depot ; 2 :
103578: LD_ADDR_OWVAR 42
103582: PUSH
103583: LD_INT 0
103585: ST_TO_ADDR
103586: GO 104208
103588: LD_INT 2
103590: DOUBLE
103591: EQUAL
103592: IFTRUE 103596
103594: GO 103607
103596: POP
// bc_type := b_warehouse ; 3 :
103597: LD_ADDR_OWVAR 42
103601: PUSH
103602: LD_INT 1
103604: ST_TO_ADDR
103605: GO 104208
103607: LD_INT 3
103609: DOUBLE
103610: EQUAL
103611: IFTRUE 103615
103613: GO 103626
103615: POP
// bc_type := b_lab ; 4 .. 9 :
103616: LD_ADDR_OWVAR 42
103620: PUSH
103621: LD_INT 6
103623: ST_TO_ADDR
103624: GO 104208
103626: LD_INT 4
103628: DOUBLE
103629: GREATEREQUAL
103630: IFFALSE 103638
103632: LD_INT 9
103634: DOUBLE
103635: LESSEQUAL
103636: IFTRUE 103640
103638: GO 103700
103640: POP
// begin bc_type := b_lab_half ;
103641: LD_ADDR_OWVAR 42
103645: PUSH
103646: LD_INT 7
103648: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103649: LD_ADDR_OWVAR 44
103653: PUSH
103654: LD_INT 10
103656: PUSH
103657: LD_INT 11
103659: PUSH
103660: LD_INT 12
103662: PUSH
103663: LD_INT 15
103665: PUSH
103666: LD_INT 14
103668: PUSH
103669: LD_INT 13
103671: PUSH
103672: EMPTY
103673: LIST
103674: LIST
103675: LIST
103676: LIST
103677: LIST
103678: LIST
103679: PUSH
103680: LD_VAR 0 2
103684: PUSH
103685: LD_INT 3
103687: MINUS
103688: ARRAY
103689: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103690: LD_ADDR_OWVAR 45
103694: PUSH
103695: LD_INT 9
103697: ST_TO_ADDR
// end ; 10 .. 13 :
103698: GO 104208
103700: LD_INT 10
103702: DOUBLE
103703: GREATEREQUAL
103704: IFFALSE 103712
103706: LD_INT 13
103708: DOUBLE
103709: LESSEQUAL
103710: IFTRUE 103714
103712: GO 103791
103714: POP
// begin bc_type := b_lab_full ;
103715: LD_ADDR_OWVAR 42
103719: PUSH
103720: LD_INT 8
103722: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103723: LD_ADDR_OWVAR 44
103727: PUSH
103728: LD_INT 10
103730: PUSH
103731: LD_INT 12
103733: PUSH
103734: LD_INT 14
103736: PUSH
103737: LD_INT 13
103739: PUSH
103740: EMPTY
103741: LIST
103742: LIST
103743: LIST
103744: LIST
103745: PUSH
103746: LD_VAR 0 2
103750: PUSH
103751: LD_INT 9
103753: MINUS
103754: ARRAY
103755: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103756: LD_ADDR_OWVAR 45
103760: PUSH
103761: LD_INT 11
103763: PUSH
103764: LD_INT 15
103766: PUSH
103767: LD_INT 12
103769: PUSH
103770: LD_INT 15
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: LIST
103777: LIST
103778: PUSH
103779: LD_VAR 0 2
103783: PUSH
103784: LD_INT 9
103786: MINUS
103787: ARRAY
103788: ST_TO_ADDR
// end ; 14 :
103789: GO 104208
103791: LD_INT 14
103793: DOUBLE
103794: EQUAL
103795: IFTRUE 103799
103797: GO 103810
103799: POP
// bc_type := b_workshop ; 15 :
103800: LD_ADDR_OWVAR 42
103804: PUSH
103805: LD_INT 2
103807: ST_TO_ADDR
103808: GO 104208
103810: LD_INT 15
103812: DOUBLE
103813: EQUAL
103814: IFTRUE 103818
103816: GO 103829
103818: POP
// bc_type := b_factory ; 16 :
103819: LD_ADDR_OWVAR 42
103823: PUSH
103824: LD_INT 3
103826: ST_TO_ADDR
103827: GO 104208
103829: LD_INT 16
103831: DOUBLE
103832: EQUAL
103833: IFTRUE 103837
103835: GO 103848
103837: POP
// bc_type := b_ext_gun ; 17 :
103838: LD_ADDR_OWVAR 42
103842: PUSH
103843: LD_INT 17
103845: ST_TO_ADDR
103846: GO 104208
103848: LD_INT 17
103850: DOUBLE
103851: EQUAL
103852: IFTRUE 103856
103854: GO 103884
103856: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103857: LD_ADDR_OWVAR 42
103861: PUSH
103862: LD_INT 19
103864: PUSH
103865: LD_INT 23
103867: PUSH
103868: LD_INT 19
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: LIST
103875: PUSH
103876: LD_VAR 0 1
103880: ARRAY
103881: ST_TO_ADDR
103882: GO 104208
103884: LD_INT 18
103886: DOUBLE
103887: EQUAL
103888: IFTRUE 103892
103890: GO 103903
103892: POP
// bc_type := b_ext_radar ; 19 :
103893: LD_ADDR_OWVAR 42
103897: PUSH
103898: LD_INT 20
103900: ST_TO_ADDR
103901: GO 104208
103903: LD_INT 19
103905: DOUBLE
103906: EQUAL
103907: IFTRUE 103911
103909: GO 103922
103911: POP
// bc_type := b_ext_radio ; 20 :
103912: LD_ADDR_OWVAR 42
103916: PUSH
103917: LD_INT 22
103919: ST_TO_ADDR
103920: GO 104208
103922: LD_INT 20
103924: DOUBLE
103925: EQUAL
103926: IFTRUE 103930
103928: GO 103941
103930: POP
// bc_type := b_ext_siberium ; 21 :
103931: LD_ADDR_OWVAR 42
103935: PUSH
103936: LD_INT 21
103938: ST_TO_ADDR
103939: GO 104208
103941: LD_INT 21
103943: DOUBLE
103944: EQUAL
103945: IFTRUE 103949
103947: GO 103960
103949: POP
// bc_type := b_ext_computer ; 22 :
103950: LD_ADDR_OWVAR 42
103954: PUSH
103955: LD_INT 24
103957: ST_TO_ADDR
103958: GO 104208
103960: LD_INT 22
103962: DOUBLE
103963: EQUAL
103964: IFTRUE 103968
103966: GO 103979
103968: POP
// bc_type := b_ext_track ; 23 :
103969: LD_ADDR_OWVAR 42
103973: PUSH
103974: LD_INT 16
103976: ST_TO_ADDR
103977: GO 104208
103979: LD_INT 23
103981: DOUBLE
103982: EQUAL
103983: IFTRUE 103987
103985: GO 103998
103987: POP
// bc_type := b_ext_laser ; 24 :
103988: LD_ADDR_OWVAR 42
103992: PUSH
103993: LD_INT 25
103995: ST_TO_ADDR
103996: GO 104208
103998: LD_INT 24
104000: DOUBLE
104001: EQUAL
104002: IFTRUE 104006
104004: GO 104017
104006: POP
// bc_type := b_control_tower ; 25 :
104007: LD_ADDR_OWVAR 42
104011: PUSH
104012: LD_INT 36
104014: ST_TO_ADDR
104015: GO 104208
104017: LD_INT 25
104019: DOUBLE
104020: EQUAL
104021: IFTRUE 104025
104023: GO 104036
104025: POP
// bc_type := b_breastwork ; 26 :
104026: LD_ADDR_OWVAR 42
104030: PUSH
104031: LD_INT 31
104033: ST_TO_ADDR
104034: GO 104208
104036: LD_INT 26
104038: DOUBLE
104039: EQUAL
104040: IFTRUE 104044
104042: GO 104055
104044: POP
// bc_type := b_bunker ; 27 :
104045: LD_ADDR_OWVAR 42
104049: PUSH
104050: LD_INT 32
104052: ST_TO_ADDR
104053: GO 104208
104055: LD_INT 27
104057: DOUBLE
104058: EQUAL
104059: IFTRUE 104063
104061: GO 104074
104063: POP
// bc_type := b_turret ; 28 :
104064: LD_ADDR_OWVAR 42
104068: PUSH
104069: LD_INT 33
104071: ST_TO_ADDR
104072: GO 104208
104074: LD_INT 28
104076: DOUBLE
104077: EQUAL
104078: IFTRUE 104082
104080: GO 104093
104082: POP
// bc_type := b_armoury ; 29 :
104083: LD_ADDR_OWVAR 42
104087: PUSH
104088: LD_INT 4
104090: ST_TO_ADDR
104091: GO 104208
104093: LD_INT 29
104095: DOUBLE
104096: EQUAL
104097: IFTRUE 104101
104099: GO 104112
104101: POP
// bc_type := b_barracks ; 30 :
104102: LD_ADDR_OWVAR 42
104106: PUSH
104107: LD_INT 5
104109: ST_TO_ADDR
104110: GO 104208
104112: LD_INT 30
104114: DOUBLE
104115: EQUAL
104116: IFTRUE 104120
104118: GO 104131
104120: POP
// bc_type := b_solar_power ; 31 :
104121: LD_ADDR_OWVAR 42
104125: PUSH
104126: LD_INT 27
104128: ST_TO_ADDR
104129: GO 104208
104131: LD_INT 31
104133: DOUBLE
104134: EQUAL
104135: IFTRUE 104139
104137: GO 104150
104139: POP
// bc_type := b_oil_power ; 32 :
104140: LD_ADDR_OWVAR 42
104144: PUSH
104145: LD_INT 26
104147: ST_TO_ADDR
104148: GO 104208
104150: LD_INT 32
104152: DOUBLE
104153: EQUAL
104154: IFTRUE 104158
104156: GO 104169
104158: POP
// bc_type := b_siberite_power ; 33 :
104159: LD_ADDR_OWVAR 42
104163: PUSH
104164: LD_INT 28
104166: ST_TO_ADDR
104167: GO 104208
104169: LD_INT 33
104171: DOUBLE
104172: EQUAL
104173: IFTRUE 104177
104175: GO 104188
104177: POP
// bc_type := b_oil_mine ; 34 :
104178: LD_ADDR_OWVAR 42
104182: PUSH
104183: LD_INT 29
104185: ST_TO_ADDR
104186: GO 104208
104188: LD_INT 34
104190: DOUBLE
104191: EQUAL
104192: IFTRUE 104196
104194: GO 104207
104196: POP
// bc_type := b_siberite_mine ; end ;
104197: LD_ADDR_OWVAR 42
104201: PUSH
104202: LD_INT 30
104204: ST_TO_ADDR
104205: GO 104208
104207: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104208: LD_ADDR_VAR 0 8
104212: PUSH
104213: LD_VAR 0 5
104217: PPUSH
104218: LD_VAR 0 6
104222: PPUSH
104223: LD_VAR 0 3
104227: PPUSH
104228: CALL_OW 47
104232: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104233: LD_OWVAR 42
104237: PUSH
104238: LD_INT 32
104240: PUSH
104241: LD_INT 33
104243: PUSH
104244: EMPTY
104245: LIST
104246: LIST
104247: IN
104248: IFFALSE 104264
// PlaceWeaponTurret ( b , weapon ) ;
104250: LD_VAR 0 8
104254: PPUSH
104255: LD_VAR 0 4
104259: PPUSH
104260: CALL_OW 431
// end ;
104264: LD_VAR 0 7
104268: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104269: LD_INT 0
104271: PPUSH
104272: PPUSH
104273: PPUSH
104274: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104275: LD_ADDR_VAR 0 4
104279: PUSH
104280: LD_INT 22
104282: PUSH
104283: LD_OWVAR 2
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: PUSH
104292: LD_INT 2
104294: PUSH
104295: LD_INT 30
104297: PUSH
104298: LD_INT 0
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: PUSH
104305: LD_INT 30
104307: PUSH
104308: LD_INT 1
104310: PUSH
104311: EMPTY
104312: LIST
104313: LIST
104314: PUSH
104315: EMPTY
104316: LIST
104317: LIST
104318: LIST
104319: PUSH
104320: EMPTY
104321: LIST
104322: LIST
104323: PPUSH
104324: CALL_OW 69
104328: ST_TO_ADDR
// if not tmp then
104329: LD_VAR 0 4
104333: NOT
104334: IFFALSE 104338
// exit ;
104336: GO 104397
// for i in tmp do
104338: LD_ADDR_VAR 0 2
104342: PUSH
104343: LD_VAR 0 4
104347: PUSH
104348: FOR_IN
104349: IFFALSE 104395
// for j = 1 to 3 do
104351: LD_ADDR_VAR 0 3
104355: PUSH
104356: DOUBLE
104357: LD_INT 1
104359: DEC
104360: ST_TO_ADDR
104361: LD_INT 3
104363: PUSH
104364: FOR_TO
104365: IFFALSE 104391
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104367: LD_VAR 0 2
104371: PPUSH
104372: CALL_OW 274
104376: PPUSH
104377: LD_VAR 0 3
104381: PPUSH
104382: LD_INT 99999
104384: PPUSH
104385: CALL_OW 277
104389: GO 104364
104391: POP
104392: POP
104393: GO 104348
104395: POP
104396: POP
// end ;
104397: LD_VAR 0 1
104401: RET
// export function hHackSetLevel10 ; var i , j ; begin
104402: LD_INT 0
104404: PPUSH
104405: PPUSH
104406: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104407: LD_ADDR_VAR 0 2
104411: PUSH
104412: LD_INT 21
104414: PUSH
104415: LD_INT 1
104417: PUSH
104418: EMPTY
104419: LIST
104420: LIST
104421: PPUSH
104422: CALL_OW 69
104426: PUSH
104427: FOR_IN
104428: IFFALSE 104480
// if IsSelected ( i ) then
104430: LD_VAR 0 2
104434: PPUSH
104435: CALL_OW 306
104439: IFFALSE 104478
// begin for j := 1 to 4 do
104441: LD_ADDR_VAR 0 3
104445: PUSH
104446: DOUBLE
104447: LD_INT 1
104449: DEC
104450: ST_TO_ADDR
104451: LD_INT 4
104453: PUSH
104454: FOR_TO
104455: IFFALSE 104476
// SetSkill ( i , j , 10 ) ;
104457: LD_VAR 0 2
104461: PPUSH
104462: LD_VAR 0 3
104466: PPUSH
104467: LD_INT 10
104469: PPUSH
104470: CALL_OW 237
104474: GO 104454
104476: POP
104477: POP
// end ;
104478: GO 104427
104480: POP
104481: POP
// end ;
104482: LD_VAR 0 1
104486: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104487: LD_INT 0
104489: PPUSH
104490: PPUSH
104491: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104492: LD_ADDR_VAR 0 2
104496: PUSH
104497: LD_INT 22
104499: PUSH
104500: LD_OWVAR 2
104504: PUSH
104505: EMPTY
104506: LIST
104507: LIST
104508: PUSH
104509: LD_INT 21
104511: PUSH
104512: LD_INT 1
104514: PUSH
104515: EMPTY
104516: LIST
104517: LIST
104518: PUSH
104519: EMPTY
104520: LIST
104521: LIST
104522: PPUSH
104523: CALL_OW 69
104527: PUSH
104528: FOR_IN
104529: IFFALSE 104570
// begin for j := 1 to 4 do
104531: LD_ADDR_VAR 0 3
104535: PUSH
104536: DOUBLE
104537: LD_INT 1
104539: DEC
104540: ST_TO_ADDR
104541: LD_INT 4
104543: PUSH
104544: FOR_TO
104545: IFFALSE 104566
// SetSkill ( i , j , 10 ) ;
104547: LD_VAR 0 2
104551: PPUSH
104552: LD_VAR 0 3
104556: PPUSH
104557: LD_INT 10
104559: PPUSH
104560: CALL_OW 237
104564: GO 104544
104566: POP
104567: POP
// end ;
104568: GO 104528
104570: POP
104571: POP
// end ;
104572: LD_VAR 0 1
104576: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104577: LD_INT 0
104579: PPUSH
// uc_side := your_side ;
104580: LD_ADDR_OWVAR 20
104584: PUSH
104585: LD_OWVAR 2
104589: ST_TO_ADDR
// uc_nation := nation ;
104590: LD_ADDR_OWVAR 21
104594: PUSH
104595: LD_VAR 0 1
104599: ST_TO_ADDR
// InitHc ;
104600: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104604: LD_INT 0
104606: PPUSH
104607: LD_VAR 0 2
104611: PPUSH
104612: LD_VAR 0 3
104616: PPUSH
104617: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104621: LD_VAR 0 4
104625: PPUSH
104626: LD_VAR 0 5
104630: PPUSH
104631: CALL_OW 428
104635: PUSH
104636: LD_INT 0
104638: EQUAL
104639: IFFALSE 104663
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104641: CALL_OW 44
104645: PPUSH
104646: LD_VAR 0 4
104650: PPUSH
104651: LD_VAR 0 5
104655: PPUSH
104656: LD_INT 1
104658: PPUSH
104659: CALL_OW 48
// end ;
104663: LD_VAR 0 6
104667: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104668: LD_INT 0
104670: PPUSH
104671: PPUSH
// uc_side := your_side ;
104672: LD_ADDR_OWVAR 20
104676: PUSH
104677: LD_OWVAR 2
104681: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104682: LD_VAR 0 1
104686: PUSH
104687: LD_INT 1
104689: PUSH
104690: LD_INT 2
104692: PUSH
104693: LD_INT 3
104695: PUSH
104696: LD_INT 4
104698: PUSH
104699: LD_INT 5
104701: PUSH
104702: EMPTY
104703: LIST
104704: LIST
104705: LIST
104706: LIST
104707: LIST
104708: IN
104709: IFFALSE 104721
// uc_nation := nation_american else
104711: LD_ADDR_OWVAR 21
104715: PUSH
104716: LD_INT 1
104718: ST_TO_ADDR
104719: GO 104764
// if chassis in [ 11 , 12 , 13 , 14 ] then
104721: LD_VAR 0 1
104725: PUSH
104726: LD_INT 11
104728: PUSH
104729: LD_INT 12
104731: PUSH
104732: LD_INT 13
104734: PUSH
104735: LD_INT 14
104737: PUSH
104738: EMPTY
104739: LIST
104740: LIST
104741: LIST
104742: LIST
104743: IN
104744: IFFALSE 104756
// uc_nation := nation_arabian else
104746: LD_ADDR_OWVAR 21
104750: PUSH
104751: LD_INT 2
104753: ST_TO_ADDR
104754: GO 104764
// uc_nation := nation_russian ;
104756: LD_ADDR_OWVAR 21
104760: PUSH
104761: LD_INT 3
104763: ST_TO_ADDR
// vc_chassis := chassis ;
104764: LD_ADDR_OWVAR 37
104768: PUSH
104769: LD_VAR 0 1
104773: ST_TO_ADDR
// vc_engine := engine ;
104774: LD_ADDR_OWVAR 39
104778: PUSH
104779: LD_VAR 0 2
104783: ST_TO_ADDR
// vc_control := control ;
104784: LD_ADDR_OWVAR 38
104788: PUSH
104789: LD_VAR 0 3
104793: ST_TO_ADDR
// vc_weapon := weapon ;
104794: LD_ADDR_OWVAR 40
104798: PUSH
104799: LD_VAR 0 4
104803: ST_TO_ADDR
// un := CreateVehicle ;
104804: LD_ADDR_VAR 0 8
104808: PUSH
104809: CALL_OW 45
104813: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104814: LD_VAR 0 8
104818: PPUSH
104819: LD_INT 0
104821: PPUSH
104822: LD_INT 5
104824: PPUSH
104825: CALL_OW 12
104829: PPUSH
104830: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104834: LD_VAR 0 8
104838: PPUSH
104839: LD_VAR 0 5
104843: PPUSH
104844: LD_VAR 0 6
104848: PPUSH
104849: LD_INT 1
104851: PPUSH
104852: CALL_OW 48
// end ;
104856: LD_VAR 0 7
104860: RET
// export hInvincible ; every 1 do
104861: GO 104863
104863: DISABLE
// hInvincible := [ ] ;
104864: LD_ADDR_EXP 166
104868: PUSH
104869: EMPTY
104870: ST_TO_ADDR
104871: END
// every 10 do var i ;
104872: GO 104874
104874: DISABLE
104875: LD_INT 0
104877: PPUSH
// begin enable ;
104878: ENABLE
// if not hInvincible then
104879: LD_EXP 166
104883: NOT
104884: IFFALSE 104888
// exit ;
104886: GO 104932
// for i in hInvincible do
104888: LD_ADDR_VAR 0 1
104892: PUSH
104893: LD_EXP 166
104897: PUSH
104898: FOR_IN
104899: IFFALSE 104930
// if GetLives ( i ) < 1000 then
104901: LD_VAR 0 1
104905: PPUSH
104906: CALL_OW 256
104910: PUSH
104911: LD_INT 1000
104913: LESS
104914: IFFALSE 104928
// SetLives ( i , 1000 ) ;
104916: LD_VAR 0 1
104920: PPUSH
104921: LD_INT 1000
104923: PPUSH
104924: CALL_OW 234
104928: GO 104898
104930: POP
104931: POP
// end ;
104932: PPOPN 1
104934: END
// export function hHackInvincible ; var i ; begin
104935: LD_INT 0
104937: PPUSH
104938: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104939: LD_ADDR_VAR 0 2
104943: PUSH
104944: LD_INT 2
104946: PUSH
104947: LD_INT 21
104949: PUSH
104950: LD_INT 1
104952: PUSH
104953: EMPTY
104954: LIST
104955: LIST
104956: PUSH
104957: LD_INT 21
104959: PUSH
104960: LD_INT 2
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: PUSH
104967: EMPTY
104968: LIST
104969: LIST
104970: LIST
104971: PPUSH
104972: CALL_OW 69
104976: PUSH
104977: FOR_IN
104978: IFFALSE 105039
// if IsSelected ( i ) then
104980: LD_VAR 0 2
104984: PPUSH
104985: CALL_OW 306
104989: IFFALSE 105037
// begin if i in hInvincible then
104991: LD_VAR 0 2
104995: PUSH
104996: LD_EXP 166
105000: IN
105001: IFFALSE 105021
// hInvincible := hInvincible diff i else
105003: LD_ADDR_EXP 166
105007: PUSH
105008: LD_EXP 166
105012: PUSH
105013: LD_VAR 0 2
105017: DIFF
105018: ST_TO_ADDR
105019: GO 105037
// hInvincible := hInvincible union i ;
105021: LD_ADDR_EXP 166
105025: PUSH
105026: LD_EXP 166
105030: PUSH
105031: LD_VAR 0 2
105035: UNION
105036: ST_TO_ADDR
// end ;
105037: GO 104977
105039: POP
105040: POP
// end ;
105041: LD_VAR 0 1
105045: RET
// export function hHackInvisible ; var i , j ; begin
105046: LD_INT 0
105048: PPUSH
105049: PPUSH
105050: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105051: LD_ADDR_VAR 0 2
105055: PUSH
105056: LD_INT 21
105058: PUSH
105059: LD_INT 1
105061: PUSH
105062: EMPTY
105063: LIST
105064: LIST
105065: PPUSH
105066: CALL_OW 69
105070: PUSH
105071: FOR_IN
105072: IFFALSE 105096
// if IsSelected ( i ) then
105074: LD_VAR 0 2
105078: PPUSH
105079: CALL_OW 306
105083: IFFALSE 105094
// ComForceInvisible ( i ) ;
105085: LD_VAR 0 2
105089: PPUSH
105090: CALL_OW 496
105094: GO 105071
105096: POP
105097: POP
// end ;
105098: LD_VAR 0 1
105102: RET
// export function hHackChangeYourSide ; begin
105103: LD_INT 0
105105: PPUSH
// if your_side = 8 then
105106: LD_OWVAR 2
105110: PUSH
105111: LD_INT 8
105113: EQUAL
105114: IFFALSE 105126
// your_side := 0 else
105116: LD_ADDR_OWVAR 2
105120: PUSH
105121: LD_INT 0
105123: ST_TO_ADDR
105124: GO 105140
// your_side := your_side + 1 ;
105126: LD_ADDR_OWVAR 2
105130: PUSH
105131: LD_OWVAR 2
105135: PUSH
105136: LD_INT 1
105138: PLUS
105139: ST_TO_ADDR
// end ;
105140: LD_VAR 0 1
105144: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105145: LD_INT 0
105147: PPUSH
105148: PPUSH
105149: PPUSH
// for i in all_units do
105150: LD_ADDR_VAR 0 2
105154: PUSH
105155: LD_OWVAR 3
105159: PUSH
105160: FOR_IN
105161: IFFALSE 105239
// if IsSelected ( i ) then
105163: LD_VAR 0 2
105167: PPUSH
105168: CALL_OW 306
105172: IFFALSE 105237
// begin j := GetSide ( i ) ;
105174: LD_ADDR_VAR 0 3
105178: PUSH
105179: LD_VAR 0 2
105183: PPUSH
105184: CALL_OW 255
105188: ST_TO_ADDR
// if j = 8 then
105189: LD_VAR 0 3
105193: PUSH
105194: LD_INT 8
105196: EQUAL
105197: IFFALSE 105209
// j := 0 else
105199: LD_ADDR_VAR 0 3
105203: PUSH
105204: LD_INT 0
105206: ST_TO_ADDR
105207: GO 105223
// j := j + 1 ;
105209: LD_ADDR_VAR 0 3
105213: PUSH
105214: LD_VAR 0 3
105218: PUSH
105219: LD_INT 1
105221: PLUS
105222: ST_TO_ADDR
// SetSide ( i , j ) ;
105223: LD_VAR 0 2
105227: PPUSH
105228: LD_VAR 0 3
105232: PPUSH
105233: CALL_OW 235
// end ;
105237: GO 105160
105239: POP
105240: POP
// end ;
105241: LD_VAR 0 1
105245: RET
// export function hHackFog ; begin
105246: LD_INT 0
105248: PPUSH
// FogOff ( true ) ;
105249: LD_INT 1
105251: PPUSH
105252: CALL_OW 344
// end ;
105256: LD_VAR 0 1
105260: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105261: LD_INT 0
105263: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105264: LD_VAR 0 1
105268: PPUSH
105269: LD_VAR 0 2
105273: PPUSH
105274: LD_VAR 0 3
105278: PPUSH
105279: LD_INT 1
105281: PPUSH
105282: LD_INT 1
105284: PPUSH
105285: CALL_OW 483
// CenterOnXY ( x , y ) ;
105289: LD_VAR 0 2
105293: PPUSH
105294: LD_VAR 0 3
105298: PPUSH
105299: CALL_OW 84
// end ;
105303: LD_VAR 0 4
105307: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105308: LD_INT 0
105310: PPUSH
105311: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105312: LD_VAR 0 1
105316: NOT
105317: PUSH
105318: LD_VAR 0 2
105322: PPUSH
105323: LD_VAR 0 3
105327: PPUSH
105328: CALL_OW 488
105332: NOT
105333: OR
105334: PUSH
105335: LD_VAR 0 1
105339: PPUSH
105340: CALL_OW 266
105344: PUSH
105345: LD_INT 3
105347: NONEQUAL
105348: PUSH
105349: LD_VAR 0 1
105353: PPUSH
105354: CALL_OW 247
105358: PUSH
105359: LD_INT 1
105361: EQUAL
105362: NOT
105363: AND
105364: OR
105365: IFFALSE 105369
// exit ;
105367: GO 105651
// if GetType ( factory ) = unit_human then
105369: LD_VAR 0 1
105373: PPUSH
105374: CALL_OW 247
105378: PUSH
105379: LD_INT 1
105381: EQUAL
105382: IFFALSE 105399
// factory := IsInUnit ( factory ) ;
105384: LD_ADDR_VAR 0 1
105388: PUSH
105389: LD_VAR 0 1
105393: PPUSH
105394: CALL_OW 310
105398: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105399: LD_VAR 0 1
105403: PPUSH
105404: CALL_OW 266
105408: PUSH
105409: LD_INT 3
105411: NONEQUAL
105412: IFFALSE 105416
// exit ;
105414: GO 105651
// for i := 1 to Count ( factoryWaypoints ) do
105416: LD_ADDR_VAR 0 5
105420: PUSH
105421: DOUBLE
105422: LD_INT 1
105424: DEC
105425: ST_TO_ADDR
105426: LD_EXP 167
105430: PPUSH
105431: CALL 19399 0 1
105435: PUSH
105436: FOR_TO
105437: IFFALSE 105599
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
105439: LD_VAR 0 2
105443: PPUSH
105444: LD_VAR 0 3
105448: PPUSH
105449: CALL_OW 428
105453: PUSH
105454: LD_EXP 167
105458: PUSH
105459: LD_VAR 0 5
105463: ARRAY
105464: PUSH
105465: LD_INT 2
105467: ARRAY
105468: EQUAL
105469: IFFALSE 105501
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
105471: LD_ADDR_EXP 167
105475: PUSH
105476: LD_EXP 167
105480: PPUSH
105481: LD_VAR 0 5
105485: PPUSH
105486: CALL_OW 3
105490: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105491: CALL 105656 0 0
// exit ;
105495: POP
105496: POP
105497: GO 105651
// end else
105499: GO 105597
// if factory = factoryWaypoints [ i ] [ 2 ] then
105501: LD_VAR 0 1
105505: PUSH
105506: LD_EXP 167
105510: PUSH
105511: LD_VAR 0 5
105515: ARRAY
105516: PUSH
105517: LD_INT 2
105519: ARRAY
105520: EQUAL
105521: IFFALSE 105597
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
105523: LD_ADDR_EXP 167
105527: PUSH
105528: LD_EXP 167
105532: PPUSH
105533: LD_VAR 0 5
105537: PPUSH
105538: CALL_OW 3
105542: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
105543: LD_ADDR_EXP 167
105547: PUSH
105548: LD_EXP 167
105552: PPUSH
105553: LD_VAR 0 1
105557: PPUSH
105558: CALL_OW 255
105562: PUSH
105563: LD_VAR 0 1
105567: PUSH
105568: LD_VAR 0 2
105572: PUSH
105573: LD_VAR 0 3
105577: PUSH
105578: EMPTY
105579: LIST
105580: LIST
105581: LIST
105582: LIST
105583: PPUSH
105584: CALL 55008 0 2
105588: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105589: CALL 105656 0 0
// exit ;
105593: POP
105594: POP
105595: GO 105651
// end ; end ;
105597: GO 105436
105599: POP
105600: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
105601: LD_ADDR_EXP 167
105605: PUSH
105606: LD_EXP 167
105610: PPUSH
105611: LD_VAR 0 1
105615: PPUSH
105616: CALL_OW 255
105620: PUSH
105621: LD_VAR 0 1
105625: PUSH
105626: LD_VAR 0 2
105630: PUSH
105631: LD_VAR 0 3
105635: PUSH
105636: EMPTY
105637: LIST
105638: LIST
105639: LIST
105640: LIST
105641: PPUSH
105642: CALL 55008 0 2
105646: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105647: CALL 105656 0 0
// end ;
105651: LD_VAR 0 4
105655: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105656: LD_INT 0
105658: PPUSH
105659: PPUSH
105660: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105661: LD_STRING resetFactoryWaypoint();
105663: PPUSH
105664: CALL_OW 559
// if factoryWaypoints then
105668: LD_EXP 167
105672: IFFALSE 105793
// begin list := factoryWaypoints ;
105674: LD_ADDR_VAR 0 3
105678: PUSH
105679: LD_EXP 167
105683: ST_TO_ADDR
// for i := 1 to list do
105684: LD_ADDR_VAR 0 2
105688: PUSH
105689: DOUBLE
105690: LD_INT 1
105692: DEC
105693: ST_TO_ADDR
105694: LD_VAR 0 3
105698: PUSH
105699: FOR_TO
105700: IFFALSE 105791
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105702: LD_STRING setFactoryWaypointXY(
105704: PUSH
105705: LD_VAR 0 3
105709: PUSH
105710: LD_VAR 0 2
105714: ARRAY
105715: PUSH
105716: LD_INT 1
105718: ARRAY
105719: STR
105720: PUSH
105721: LD_STRING ,
105723: STR
105724: PUSH
105725: LD_VAR 0 3
105729: PUSH
105730: LD_VAR 0 2
105734: ARRAY
105735: PUSH
105736: LD_INT 2
105738: ARRAY
105739: STR
105740: PUSH
105741: LD_STRING ,
105743: STR
105744: PUSH
105745: LD_VAR 0 3
105749: PUSH
105750: LD_VAR 0 2
105754: ARRAY
105755: PUSH
105756: LD_INT 3
105758: ARRAY
105759: STR
105760: PUSH
105761: LD_STRING ,
105763: STR
105764: PUSH
105765: LD_VAR 0 3
105769: PUSH
105770: LD_VAR 0 2
105774: ARRAY
105775: PUSH
105776: LD_INT 4
105778: ARRAY
105779: STR
105780: PUSH
105781: LD_STRING )
105783: STR
105784: PPUSH
105785: CALL_OW 559
105789: GO 105699
105791: POP
105792: POP
// end ; end ;
105793: LD_VAR 0 1
105797: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105798: LD_INT 0
105800: PPUSH
// if HexInfo ( x , y ) = warehouse then
105801: LD_VAR 0 2
105805: PPUSH
105806: LD_VAR 0 3
105810: PPUSH
105811: CALL_OW 428
105815: PUSH
105816: LD_VAR 0 1
105820: EQUAL
105821: IFFALSE 105848
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105823: LD_ADDR_EXP 168
105827: PUSH
105828: LD_EXP 168
105832: PPUSH
105833: LD_VAR 0 1
105837: PPUSH
105838: LD_INT 0
105840: PPUSH
105841: CALL_OW 1
105845: ST_TO_ADDR
105846: GO 105899
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105848: LD_ADDR_EXP 168
105852: PUSH
105853: LD_EXP 168
105857: PPUSH
105858: LD_VAR 0 1
105862: PPUSH
105863: LD_VAR 0 1
105867: PPUSH
105868: CALL_OW 255
105872: PUSH
105873: LD_VAR 0 1
105877: PUSH
105878: LD_VAR 0 2
105882: PUSH
105883: LD_VAR 0 3
105887: PUSH
105888: EMPTY
105889: LIST
105890: LIST
105891: LIST
105892: LIST
105893: PPUSH
105894: CALL_OW 1
105898: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105899: CALL 105908 0 0
// end ;
105903: LD_VAR 0 4
105907: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105908: LD_INT 0
105910: PPUSH
105911: PPUSH
105912: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105913: LD_STRING resetWarehouseGatheringPoints();
105915: PPUSH
105916: CALL_OW 559
// if warehouseGatheringPoints then
105920: LD_EXP 168
105924: IFFALSE 106050
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105926: LD_ADDR_VAR 0 3
105930: PUSH
105931: LD_EXP 168
105935: PPUSH
105936: CALL 58770 0 1
105940: ST_TO_ADDR
// for i := 1 to list do
105941: LD_ADDR_VAR 0 2
105945: PUSH
105946: DOUBLE
105947: LD_INT 1
105949: DEC
105950: ST_TO_ADDR
105951: LD_VAR 0 3
105955: PUSH
105956: FOR_TO
105957: IFFALSE 106048
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105959: LD_STRING setWarehouseGatheringPointXY(
105961: PUSH
105962: LD_VAR 0 3
105966: PUSH
105967: LD_VAR 0 2
105971: ARRAY
105972: PUSH
105973: LD_INT 1
105975: ARRAY
105976: STR
105977: PUSH
105978: LD_STRING ,
105980: STR
105981: PUSH
105982: LD_VAR 0 3
105986: PUSH
105987: LD_VAR 0 2
105991: ARRAY
105992: PUSH
105993: LD_INT 2
105995: ARRAY
105996: STR
105997: PUSH
105998: LD_STRING ,
106000: STR
106001: PUSH
106002: LD_VAR 0 3
106006: PUSH
106007: LD_VAR 0 2
106011: ARRAY
106012: PUSH
106013: LD_INT 3
106015: ARRAY
106016: STR
106017: PUSH
106018: LD_STRING ,
106020: STR
106021: PUSH
106022: LD_VAR 0 3
106026: PUSH
106027: LD_VAR 0 2
106031: ARRAY
106032: PUSH
106033: LD_INT 4
106035: ARRAY
106036: STR
106037: PUSH
106038: LD_STRING )
106040: STR
106041: PPUSH
106042: CALL_OW 559
106046: GO 105956
106048: POP
106049: POP
// end ; end ;
106050: LD_VAR 0 1
106054: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106055: LD_EXP 168
106059: IFFALSE 106744
106061: GO 106063
106063: DISABLE
106064: LD_INT 0
106066: PPUSH
106067: PPUSH
106068: PPUSH
106069: PPUSH
106070: PPUSH
106071: PPUSH
106072: PPUSH
106073: PPUSH
106074: PPUSH
// begin enable ;
106075: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106076: LD_ADDR_VAR 0 3
106080: PUSH
106081: LD_EXP 168
106085: PPUSH
106086: CALL 58770 0 1
106090: ST_TO_ADDR
// if not list then
106091: LD_VAR 0 3
106095: NOT
106096: IFFALSE 106100
// exit ;
106098: GO 106744
// for i := 1 to list do
106100: LD_ADDR_VAR 0 1
106104: PUSH
106105: DOUBLE
106106: LD_INT 1
106108: DEC
106109: ST_TO_ADDR
106110: LD_VAR 0 3
106114: PUSH
106115: FOR_TO
106116: IFFALSE 106742
// begin depot := list [ i ] [ 2 ] ;
106118: LD_ADDR_VAR 0 8
106122: PUSH
106123: LD_VAR 0 3
106127: PUSH
106128: LD_VAR 0 1
106132: ARRAY
106133: PUSH
106134: LD_INT 2
106136: ARRAY
106137: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106138: LD_ADDR_VAR 0 5
106142: PUSH
106143: LD_VAR 0 3
106147: PUSH
106148: LD_VAR 0 1
106152: ARRAY
106153: PUSH
106154: LD_INT 1
106156: ARRAY
106157: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106158: LD_VAR 0 8
106162: PPUSH
106163: CALL_OW 301
106167: PUSH
106168: LD_VAR 0 5
106172: PUSH
106173: LD_VAR 0 8
106177: PPUSH
106178: CALL_OW 255
106182: NONEQUAL
106183: OR
106184: IFFALSE 106213
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106186: LD_ADDR_EXP 168
106190: PUSH
106191: LD_EXP 168
106195: PPUSH
106196: LD_VAR 0 8
106200: PPUSH
106201: LD_INT 0
106203: PPUSH
106204: CALL_OW 1
106208: ST_TO_ADDR
// exit ;
106209: POP
106210: POP
106211: GO 106744
// end ; x := list [ i ] [ 3 ] ;
106213: LD_ADDR_VAR 0 6
106217: PUSH
106218: LD_VAR 0 3
106222: PUSH
106223: LD_VAR 0 1
106227: ARRAY
106228: PUSH
106229: LD_INT 3
106231: ARRAY
106232: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106233: LD_ADDR_VAR 0 7
106237: PUSH
106238: LD_VAR 0 3
106242: PUSH
106243: LD_VAR 0 1
106247: ARRAY
106248: PUSH
106249: LD_INT 4
106251: ARRAY
106252: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106253: LD_ADDR_VAR 0 9
106257: PUSH
106258: LD_VAR 0 6
106262: PPUSH
106263: LD_VAR 0 7
106267: PPUSH
106268: LD_INT 16
106270: PPUSH
106271: CALL 57354 0 3
106275: ST_TO_ADDR
// if not cratesNearbyPoint then
106276: LD_VAR 0 9
106280: NOT
106281: IFFALSE 106287
// exit ;
106283: POP
106284: POP
106285: GO 106744
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106287: LD_ADDR_VAR 0 4
106291: PUSH
106292: LD_INT 22
106294: PUSH
106295: LD_VAR 0 5
106299: PUSH
106300: EMPTY
106301: LIST
106302: LIST
106303: PUSH
106304: LD_INT 3
106306: PUSH
106307: LD_INT 60
106309: PUSH
106310: EMPTY
106311: LIST
106312: PUSH
106313: EMPTY
106314: LIST
106315: LIST
106316: PUSH
106317: LD_INT 91
106319: PUSH
106320: LD_VAR 0 8
106324: PUSH
106325: LD_INT 6
106327: PUSH
106328: EMPTY
106329: LIST
106330: LIST
106331: LIST
106332: PUSH
106333: LD_INT 2
106335: PUSH
106336: LD_INT 25
106338: PUSH
106339: LD_INT 2
106341: PUSH
106342: EMPTY
106343: LIST
106344: LIST
106345: PUSH
106346: LD_INT 25
106348: PUSH
106349: LD_INT 16
106351: PUSH
106352: EMPTY
106353: LIST
106354: LIST
106355: PUSH
106356: EMPTY
106357: LIST
106358: LIST
106359: LIST
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: LIST
106365: LIST
106366: PPUSH
106367: CALL_OW 69
106371: PUSH
106372: LD_VAR 0 8
106376: PPUSH
106377: CALL_OW 313
106381: PPUSH
106382: LD_INT 3
106384: PUSH
106385: LD_INT 60
106387: PUSH
106388: EMPTY
106389: LIST
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: PUSH
106395: LD_INT 2
106397: PUSH
106398: LD_INT 25
106400: PUSH
106401: LD_INT 2
106403: PUSH
106404: EMPTY
106405: LIST
106406: LIST
106407: PUSH
106408: LD_INT 25
106410: PUSH
106411: LD_INT 16
106413: PUSH
106414: EMPTY
106415: LIST
106416: LIST
106417: PUSH
106418: EMPTY
106419: LIST
106420: LIST
106421: LIST
106422: PUSH
106423: EMPTY
106424: LIST
106425: LIST
106426: PPUSH
106427: CALL_OW 72
106431: UNION
106432: ST_TO_ADDR
// if tmp then
106433: LD_VAR 0 4
106437: IFFALSE 106517
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106439: LD_ADDR_VAR 0 4
106443: PUSH
106444: LD_VAR 0 4
106448: PPUSH
106449: LD_INT 3
106451: PPUSH
106452: CALL 55323 0 2
106456: ST_TO_ADDR
// for j in tmp do
106457: LD_ADDR_VAR 0 2
106461: PUSH
106462: LD_VAR 0 4
106466: PUSH
106467: FOR_IN
106468: IFFALSE 106511
// begin if IsInUnit ( j ) then
106470: LD_VAR 0 2
106474: PPUSH
106475: CALL_OW 310
106479: IFFALSE 106490
// ComExit ( j ) ;
106481: LD_VAR 0 2
106485: PPUSH
106486: CALL 55406 0 1
// AddComCollect ( j , x , y ) ;
106490: LD_VAR 0 2
106494: PPUSH
106495: LD_VAR 0 6
106499: PPUSH
106500: LD_VAR 0 7
106504: PPUSH
106505: CALL_OW 177
// end ;
106509: GO 106467
106511: POP
106512: POP
// exit ;
106513: POP
106514: POP
106515: GO 106744
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106517: LD_ADDR_VAR 0 4
106521: PUSH
106522: LD_INT 22
106524: PUSH
106525: LD_VAR 0 5
106529: PUSH
106530: EMPTY
106531: LIST
106532: LIST
106533: PUSH
106534: LD_INT 91
106536: PUSH
106537: LD_VAR 0 8
106541: PUSH
106542: LD_INT 8
106544: PUSH
106545: EMPTY
106546: LIST
106547: LIST
106548: LIST
106549: PUSH
106550: LD_INT 2
106552: PUSH
106553: LD_INT 34
106555: PUSH
106556: LD_INT 12
106558: PUSH
106559: EMPTY
106560: LIST
106561: LIST
106562: PUSH
106563: LD_INT 34
106565: PUSH
106566: LD_INT 51
106568: PUSH
106569: EMPTY
106570: LIST
106571: LIST
106572: PUSH
106573: LD_INT 34
106575: PUSH
106576: LD_INT 32
106578: PUSH
106579: EMPTY
106580: LIST
106581: LIST
106582: PUSH
106583: LD_INT 34
106585: PUSH
106586: LD_INT 89
106588: PUSH
106589: EMPTY
106590: LIST
106591: LIST
106592: PUSH
106593: EMPTY
106594: LIST
106595: LIST
106596: LIST
106597: LIST
106598: LIST
106599: PUSH
106600: EMPTY
106601: LIST
106602: LIST
106603: LIST
106604: PPUSH
106605: CALL_OW 69
106609: ST_TO_ADDR
// if tmp then
106610: LD_VAR 0 4
106614: IFFALSE 106740
// begin for j in tmp do
106616: LD_ADDR_VAR 0 2
106620: PUSH
106621: LD_VAR 0 4
106625: PUSH
106626: FOR_IN
106627: IFFALSE 106738
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106629: LD_VAR 0 2
106633: PPUSH
106634: CALL_OW 262
106638: PUSH
106639: LD_INT 3
106641: EQUAL
106642: PUSH
106643: LD_VAR 0 2
106647: PPUSH
106648: CALL_OW 261
106652: PUSH
106653: LD_INT 20
106655: GREATER
106656: OR
106657: PUSH
106658: LD_VAR 0 2
106662: PPUSH
106663: CALL_OW 314
106667: NOT
106668: AND
106669: PUSH
106670: LD_VAR 0 2
106674: PPUSH
106675: CALL_OW 263
106679: PUSH
106680: LD_INT 1
106682: NONEQUAL
106683: PUSH
106684: LD_VAR 0 2
106688: PPUSH
106689: CALL_OW 311
106693: OR
106694: AND
106695: IFFALSE 106736
// begin ComCollect ( j , x , y ) ;
106697: LD_VAR 0 2
106701: PPUSH
106702: LD_VAR 0 6
106706: PPUSH
106707: LD_VAR 0 7
106711: PPUSH
106712: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106716: LD_VAR 0 2
106720: PPUSH
106721: LD_VAR 0 8
106725: PPUSH
106726: CALL_OW 172
// exit ;
106730: POP
106731: POP
106732: POP
106733: POP
106734: GO 106744
// end ;
106736: GO 106626
106738: POP
106739: POP
// end ; end ;
106740: GO 106115
106742: POP
106743: POP
// end ; end_of_file
106744: PPOPN 9
106746: END
// export function SOS_UnitDestroyed ( un ) ; begin
106747: LD_INT 0
106749: PPUSH
// ComRadiation ( un ) ;
106750: LD_VAR 0 1
106754: PPUSH
106755: CALL 107736 0 1
// end ;
106759: LD_VAR 0 2
106763: RET
// export function SOS_UnitKamikazed ( un ) ; begin
106764: LD_INT 0
106766: PPUSH
// ComRadiation ( un ) ;
106767: LD_VAR 0 1
106771: PPUSH
106772: CALL 107736 0 1
// end ;
106776: LD_VAR 0 2
106780: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106781: LD_INT 0
106783: PPUSH
// end ;
106784: LD_VAR 0 4
106788: RET
// export function SOS_Command ( cmd ) ; begin
106789: LD_INT 0
106791: PPUSH
// end ;
106792: LD_VAR 0 2
106796: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106797: LD_INT 0
106799: PPUSH
// end ;
106800: LD_VAR 0 6
106804: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , tag , driver , hex ; begin
106805: LD_INT 0
106807: PPUSH
106808: PPUSH
106809: PPUSH
106810: PPUSH
106811: PPUSH
// if not vehicle or not factory then
106812: LD_VAR 0 1
106816: NOT
106817: PUSH
106818: LD_VAR 0 2
106822: NOT
106823: OR
106824: IFFALSE 106828
// exit ;
106826: GO 107327
// if not factoryWaypoints then
106828: LD_EXP 167
106832: NOT
106833: IFFALSE 106837
// exit ;
106835: GO 107327
// for i := 1 to Count ( factoryWaypoints ) do
106837: LD_ADDR_VAR 0 4
106841: PUSH
106842: DOUBLE
106843: LD_INT 1
106845: DEC
106846: ST_TO_ADDR
106847: LD_EXP 167
106851: PPUSH
106852: CALL 19399 0 1
106856: PUSH
106857: FOR_TO
106858: IFFALSE 107325
// if factoryWaypoints [ i ] [ 2 ] = factory then
106860: LD_EXP 167
106864: PUSH
106865: LD_VAR 0 4
106869: ARRAY
106870: PUSH
106871: LD_INT 2
106873: ARRAY
106874: PUSH
106875: LD_VAR 0 2
106879: EQUAL
106880: IFFALSE 107323
// begin if GetControl ( vehicle ) = control_manual then
106882: LD_VAR 0 1
106886: PPUSH
106887: CALL_OW 263
106891: PUSH
106892: LD_INT 1
106894: EQUAL
106895: IFFALSE 107206
// begin driver := IsDrivenBy ( vehicle ) ;
106897: LD_ADDR_VAR 0 6
106901: PUSH
106902: LD_VAR 0 1
106906: PPUSH
106907: CALL_OW 311
106911: ST_TO_ADDR
// tag := GetTag ( driver ) ;
106912: LD_ADDR_VAR 0 5
106916: PUSH
106917: LD_VAR 0 6
106921: PPUSH
106922: CALL_OW 110
106926: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
106927: LD_VAR 0 5
106931: PUSH
106932: LD_INT 501
106934: EQUAL
106935: PUSH
106936: LD_VAR 0 1
106940: PPUSH
106941: CALL_OW 110
106945: PUSH
106946: LD_INT 501
106948: EQUAL
106949: OR
106950: IFFALSE 106956
// exit ;
106952: POP
106953: POP
106954: GO 107327
// if not HasTask ( driver ) then
106956: LD_VAR 0 6
106960: PPUSH
106961: CALL_OW 314
106965: NOT
106966: IFFALSE 107204
// begin SetTag ( driver , tDriver ) ;
106968: LD_VAR 0 6
106972: PPUSH
106973: LD_INT 501
106975: PPUSH
106976: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
106980: LD_VAR 0 1
106984: PPUSH
106985: LD_INT 501
106987: PPUSH
106988: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
106992: LD_ADDR_VAR 0 7
106996: PUSH
106997: LD_EXP 167
107001: PUSH
107002: LD_VAR 0 4
107006: ARRAY
107007: PUSH
107008: LD_INT 3
107010: ARRAY
107011: PPUSH
107012: LD_EXP 167
107016: PUSH
107017: LD_VAR 0 4
107021: ARRAY
107022: PUSH
107023: LD_INT 4
107025: ARRAY
107026: PPUSH
107027: CALL_OW 428
107031: ST_TO_ADDR
// if hex then
107032: LD_VAR 0 7
107036: IFFALSE 107054
// ComMoveUnit ( driver , hex ) else
107038: LD_VAR 0 6
107042: PPUSH
107043: LD_VAR 0 7
107047: PPUSH
107048: CALL_OW 112
107052: GO 107093
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107054: LD_VAR 0 6
107058: PPUSH
107059: LD_EXP 167
107063: PUSH
107064: LD_VAR 0 4
107068: ARRAY
107069: PUSH
107070: LD_INT 3
107072: ARRAY
107073: PPUSH
107074: LD_EXP 167
107078: PUSH
107079: LD_VAR 0 4
107083: ARRAY
107084: PUSH
107085: LD_INT 4
107087: ARRAY
107088: PPUSH
107089: CALL_OW 111
// AddComExitVehicle ( driver ) ;
107093: LD_VAR 0 6
107097: PPUSH
107098: CALL_OW 181
// if Multiplayer then
107102: LD_OWVAR 4
107106: IFFALSE 107155
// begin repeat wait ( 10 ) ;
107108: LD_INT 10
107110: PPUSH
107111: CALL_OW 67
// until not IsInUnit ( driver ) ;
107115: LD_VAR 0 6
107119: PPUSH
107120: CALL_OW 310
107124: NOT
107125: IFFALSE 107108
// if not HasTask ( driver ) then
107127: LD_VAR 0 6
107131: PPUSH
107132: CALL_OW 314
107136: NOT
107137: IFFALSE 107153
// ComEnterUnit ( driver , factory ) ;
107139: LD_VAR 0 6
107143: PPUSH
107144: LD_VAR 0 2
107148: PPUSH
107149: CALL_OW 120
// end else
107153: GO 107169
// AddComEnterUnit ( driver , factory ) ;
107155: LD_VAR 0 6
107159: PPUSH
107160: LD_VAR 0 2
107164: PPUSH
107165: CALL_OW 180
// wait ( 0 0$1 ) ;
107169: LD_INT 35
107171: PPUSH
107172: CALL_OW 67
// SetTag ( driver , tag ) ;
107176: LD_VAR 0 6
107180: PPUSH
107181: LD_VAR 0 5
107185: PPUSH
107186: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
107190: LD_VAR 0 1
107194: PPUSH
107195: LD_INT 0
107197: PPUSH
107198: CALL_OW 109
// break ;
107202: GO 107325
// end ; end else
107204: GO 107323
// if GetControl ( vehicle ) = control_remote then
107206: LD_VAR 0 1
107210: PPUSH
107211: CALL_OW 263
107215: PUSH
107216: LD_INT 2
107218: EQUAL
107219: IFFALSE 107282
// begin wait ( 0 0$2 ) ;
107221: LD_INT 70
107223: PPUSH
107224: CALL_OW 67
// if Connect ( vehicle ) then
107228: LD_VAR 0 1
107232: PPUSH
107233: CALL 25605 0 1
107237: IFFALSE 107278
// AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107239: LD_VAR 0 1
107243: PPUSH
107244: LD_EXP 167
107248: PUSH
107249: LD_VAR 0 4
107253: ARRAY
107254: PUSH
107255: LD_INT 3
107257: ARRAY
107258: PPUSH
107259: LD_EXP 167
107263: PUSH
107264: LD_VAR 0 4
107268: ARRAY
107269: PUSH
107270: LD_INT 4
107272: ARRAY
107273: PPUSH
107274: CALL_OW 171
// break ;
107278: GO 107325
// end else
107280: GO 107323
// begin AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107282: LD_VAR 0 1
107286: PPUSH
107287: LD_EXP 167
107291: PUSH
107292: LD_VAR 0 4
107296: ARRAY
107297: PUSH
107298: LD_INT 3
107300: ARRAY
107301: PPUSH
107302: LD_EXP 167
107306: PUSH
107307: LD_VAR 0 4
107311: ARRAY
107312: PUSH
107313: LD_INT 4
107315: ARRAY
107316: PPUSH
107317: CALL_OW 171
// break ;
107321: GO 107325
// end ; end ;
107323: GO 106857
107325: POP
107326: POP
// end ;
107327: LD_VAR 0 3
107331: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107332: LD_INT 0
107334: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107335: LD_VAR 0 1
107339: PUSH
107340: LD_INT 250
107342: EQUAL
107343: PUSH
107344: LD_VAR 0 2
107348: PPUSH
107349: CALL_OW 264
107353: PUSH
107354: LD_INT 81
107356: EQUAL
107357: AND
107358: IFFALSE 107379
// MinerPlaceMine ( unit , x , y ) ;
107360: LD_VAR 0 2
107364: PPUSH
107365: LD_VAR 0 4
107369: PPUSH
107370: LD_VAR 0 5
107374: PPUSH
107375: CALL 110471 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107379: LD_VAR 0 1
107383: PUSH
107384: LD_INT 251
107386: EQUAL
107387: PUSH
107388: LD_VAR 0 2
107392: PPUSH
107393: CALL_OW 264
107397: PUSH
107398: LD_INT 81
107400: EQUAL
107401: AND
107402: IFFALSE 107423
// MinerDetonateMine ( unit , x , y ) ;
107404: LD_VAR 0 2
107408: PPUSH
107409: LD_VAR 0 4
107413: PPUSH
107414: LD_VAR 0 5
107418: PPUSH
107419: CALL 110746 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107423: LD_VAR 0 1
107427: PUSH
107428: LD_INT 252
107430: EQUAL
107431: PUSH
107432: LD_VAR 0 2
107436: PPUSH
107437: CALL_OW 264
107441: PUSH
107442: LD_INT 81
107444: EQUAL
107445: AND
107446: IFFALSE 107467
// MinerCreateMinefield ( unit , x , y ) ;
107448: LD_VAR 0 2
107452: PPUSH
107453: LD_VAR 0 4
107457: PPUSH
107458: LD_VAR 0 5
107462: PPUSH
107463: CALL 111163 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107467: LD_VAR 0 1
107471: PUSH
107472: LD_INT 253
107474: EQUAL
107475: PUSH
107476: LD_VAR 0 2
107480: PPUSH
107481: CALL_OW 257
107485: PUSH
107486: LD_INT 5
107488: EQUAL
107489: AND
107490: IFFALSE 107511
// ComBinocular ( unit , x , y ) ;
107492: LD_VAR 0 2
107496: PPUSH
107497: LD_VAR 0 4
107501: PPUSH
107502: LD_VAR 0 5
107506: PPUSH
107507: CALL 111532 0 3
// if selectedUnit then
107511: LD_VAR 0 3
107515: IFFALSE 107571
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107517: LD_VAR 0 1
107521: PUSH
107522: LD_INT 254
107524: EQUAL
107525: PUSH
107526: LD_VAR 0 2
107530: PPUSH
107531: CALL_OW 264
107535: PUSH
107536: LD_INT 99
107538: EQUAL
107539: AND
107540: PUSH
107541: LD_VAR 0 3
107545: PPUSH
107546: CALL_OW 263
107550: PUSH
107551: LD_INT 3
107553: EQUAL
107554: AND
107555: IFFALSE 107571
// HackDestroyVehicle ( unit , selectedUnit ) ;
107557: LD_VAR 0 2
107561: PPUSH
107562: LD_VAR 0 3
107566: PPUSH
107567: CALL 109835 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107571: LD_VAR 0 1
107575: PUSH
107576: LD_INT 255
107578: EQUAL
107579: PUSH
107580: LD_VAR 0 2
107584: PPUSH
107585: CALL_OW 264
107589: PUSH
107590: LD_INT 14
107592: PUSH
107593: LD_INT 53
107595: PUSH
107596: EMPTY
107597: LIST
107598: LIST
107599: IN
107600: AND
107601: PUSH
107602: LD_VAR 0 4
107606: PPUSH
107607: LD_VAR 0 5
107611: PPUSH
107612: CALL_OW 488
107616: AND
107617: IFFALSE 107641
// CutTreeXYR ( unit , x , y , 12 ) ;
107619: LD_VAR 0 2
107623: PPUSH
107624: LD_VAR 0 4
107628: PPUSH
107629: LD_VAR 0 5
107633: PPUSH
107634: LD_INT 12
107636: PPUSH
107637: CALL 107832 0 4
// if cmd = 256 then
107641: LD_VAR 0 1
107645: PUSH
107646: LD_INT 256
107648: EQUAL
107649: IFFALSE 107670
// SetFactoryWaypoint ( unit , x , y ) ;
107651: LD_VAR 0 2
107655: PPUSH
107656: LD_VAR 0 4
107660: PPUSH
107661: LD_VAR 0 5
107665: PPUSH
107666: CALL 105308 0 3
// if cmd = 257 then
107670: LD_VAR 0 1
107674: PUSH
107675: LD_INT 257
107677: EQUAL
107678: IFFALSE 107699
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107680: LD_VAR 0 2
107684: PPUSH
107685: LD_VAR 0 4
107689: PPUSH
107690: LD_VAR 0 5
107694: PPUSH
107695: CALL 105798 0 3
// if cmd = 258 then
107699: LD_VAR 0 1
107703: PUSH
107704: LD_INT 258
107706: EQUAL
107707: IFFALSE 107731
// BurnTreeXYR ( unit , x , y , 8 ) ;
107709: LD_VAR 0 2
107713: PPUSH
107714: LD_VAR 0 4
107718: PPUSH
107719: LD_VAR 0 5
107723: PPUSH
107724: LD_INT 8
107726: PPUSH
107727: CALL 108226 0 4
// end ;
107731: LD_VAR 0 6
107735: RET
// export function ComRadiation ( un ) ; var eff ; begin
107736: LD_INT 0
107738: PPUSH
107739: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
107740: LD_VAR 0 1
107744: PPUSH
107745: CALL_OW 264
107749: PUSH
107750: LD_INT 91
107752: NONEQUAL
107753: IFFALSE 107757
// exit ;
107755: GO 107827
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107757: LD_INT 68
107759: PPUSH
107760: LD_VAR 0 1
107764: PPUSH
107765: CALL_OW 255
107769: PPUSH
107770: CALL_OW 321
107774: PUSH
107775: LD_INT 2
107777: EQUAL
107778: IFFALSE 107790
// eff := 70 else
107780: LD_ADDR_VAR 0 3
107784: PUSH
107785: LD_INT 70
107787: ST_TO_ADDR
107788: GO 107798
// eff := 30 ;
107790: LD_ADDR_VAR 0 3
107794: PUSH
107795: LD_INT 30
107797: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107798: LD_VAR 0 1
107802: PPUSH
107803: CALL_OW 250
107807: PPUSH
107808: LD_VAR 0 1
107812: PPUSH
107813: CALL_OW 251
107817: PPUSH
107818: LD_VAR 0 3
107822: PPUSH
107823: CALL_OW 495
// end ;
107827: LD_VAR 0 2
107831: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107832: LD_INT 0
107834: PPUSH
107835: PPUSH
107836: PPUSH
107837: PPUSH
107838: PPUSH
107839: PPUSH
107840: PPUSH
107841: PPUSH
107842: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107843: LD_VAR 0 1
107847: PPUSH
107848: CALL_OW 302
107852: NOT
107853: PUSH
107854: LD_VAR 0 2
107858: PPUSH
107859: LD_VAR 0 3
107863: PPUSH
107864: CALL_OW 488
107868: NOT
107869: OR
107870: PUSH
107871: LD_VAR 0 4
107875: NOT
107876: OR
107877: IFFALSE 107881
// exit ;
107879: GO 108221
// list := [ ] ;
107881: LD_ADDR_VAR 0 13
107885: PUSH
107886: EMPTY
107887: ST_TO_ADDR
// if x - r < 0 then
107888: LD_VAR 0 2
107892: PUSH
107893: LD_VAR 0 4
107897: MINUS
107898: PUSH
107899: LD_INT 0
107901: LESS
107902: IFFALSE 107914
// min_x := 0 else
107904: LD_ADDR_VAR 0 7
107908: PUSH
107909: LD_INT 0
107911: ST_TO_ADDR
107912: GO 107930
// min_x := x - r ;
107914: LD_ADDR_VAR 0 7
107918: PUSH
107919: LD_VAR 0 2
107923: PUSH
107924: LD_VAR 0 4
107928: MINUS
107929: ST_TO_ADDR
// if y - r < 0 then
107930: LD_VAR 0 3
107934: PUSH
107935: LD_VAR 0 4
107939: MINUS
107940: PUSH
107941: LD_INT 0
107943: LESS
107944: IFFALSE 107956
// min_y := 0 else
107946: LD_ADDR_VAR 0 8
107950: PUSH
107951: LD_INT 0
107953: ST_TO_ADDR
107954: GO 107972
// min_y := y - r ;
107956: LD_ADDR_VAR 0 8
107960: PUSH
107961: LD_VAR 0 3
107965: PUSH
107966: LD_VAR 0 4
107970: MINUS
107971: ST_TO_ADDR
// max_x := x + r ;
107972: LD_ADDR_VAR 0 9
107976: PUSH
107977: LD_VAR 0 2
107981: PUSH
107982: LD_VAR 0 4
107986: PLUS
107987: ST_TO_ADDR
// max_y := y + r ;
107988: LD_ADDR_VAR 0 10
107992: PUSH
107993: LD_VAR 0 3
107997: PUSH
107998: LD_VAR 0 4
108002: PLUS
108003: ST_TO_ADDR
// for _x = min_x to max_x do
108004: LD_ADDR_VAR 0 11
108008: PUSH
108009: DOUBLE
108010: LD_VAR 0 7
108014: DEC
108015: ST_TO_ADDR
108016: LD_VAR 0 9
108020: PUSH
108021: FOR_TO
108022: IFFALSE 108139
// for _y = min_y to max_y do
108024: LD_ADDR_VAR 0 12
108028: PUSH
108029: DOUBLE
108030: LD_VAR 0 8
108034: DEC
108035: ST_TO_ADDR
108036: LD_VAR 0 10
108040: PUSH
108041: FOR_TO
108042: IFFALSE 108135
// begin if not ValidHex ( _x , _y ) then
108044: LD_VAR 0 11
108048: PPUSH
108049: LD_VAR 0 12
108053: PPUSH
108054: CALL_OW 488
108058: NOT
108059: IFFALSE 108063
// continue ;
108061: GO 108041
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108063: LD_VAR 0 11
108067: PPUSH
108068: LD_VAR 0 12
108072: PPUSH
108073: CALL_OW 351
108077: PUSH
108078: LD_VAR 0 11
108082: PPUSH
108083: LD_VAR 0 12
108087: PPUSH
108088: CALL_OW 554
108092: AND
108093: IFFALSE 108133
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108095: LD_ADDR_VAR 0 13
108099: PUSH
108100: LD_VAR 0 13
108104: PPUSH
108105: LD_VAR 0 13
108109: PUSH
108110: LD_INT 1
108112: PLUS
108113: PPUSH
108114: LD_VAR 0 11
108118: PUSH
108119: LD_VAR 0 12
108123: PUSH
108124: EMPTY
108125: LIST
108126: LIST
108127: PPUSH
108128: CALL_OW 2
108132: ST_TO_ADDR
// end ;
108133: GO 108041
108135: POP
108136: POP
108137: GO 108021
108139: POP
108140: POP
// if not list then
108141: LD_VAR 0 13
108145: NOT
108146: IFFALSE 108150
// exit ;
108148: GO 108221
// for i in list do
108150: LD_ADDR_VAR 0 6
108154: PUSH
108155: LD_VAR 0 13
108159: PUSH
108160: FOR_IN
108161: IFFALSE 108219
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108163: LD_VAR 0 1
108167: PPUSH
108168: LD_STRING M
108170: PUSH
108171: LD_VAR 0 6
108175: PUSH
108176: LD_INT 1
108178: ARRAY
108179: PUSH
108180: LD_VAR 0 6
108184: PUSH
108185: LD_INT 2
108187: ARRAY
108188: PUSH
108189: LD_INT 0
108191: PUSH
108192: LD_INT 0
108194: PUSH
108195: LD_INT 0
108197: PUSH
108198: LD_INT 0
108200: PUSH
108201: EMPTY
108202: LIST
108203: LIST
108204: LIST
108205: LIST
108206: LIST
108207: LIST
108208: LIST
108209: PUSH
108210: EMPTY
108211: LIST
108212: PPUSH
108213: CALL_OW 447
108217: GO 108160
108219: POP
108220: POP
// end ;
108221: LD_VAR 0 5
108225: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
108226: LD_INT 0
108228: PPUSH
108229: PPUSH
108230: PPUSH
108231: PPUSH
108232: PPUSH
108233: PPUSH
108234: PPUSH
108235: PPUSH
108236: PPUSH
108237: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108238: LD_VAR 0 1
108242: PPUSH
108243: CALL_OW 302
108247: NOT
108248: PUSH
108249: LD_VAR 0 2
108253: PPUSH
108254: LD_VAR 0 3
108258: PPUSH
108259: CALL_OW 488
108263: NOT
108264: OR
108265: PUSH
108266: LD_VAR 0 4
108270: NOT
108271: OR
108272: IFFALSE 108276
// exit ;
108274: GO 108789
// list := [ ] ;
108276: LD_ADDR_VAR 0 13
108280: PUSH
108281: EMPTY
108282: ST_TO_ADDR
// if x - r < 0 then
108283: LD_VAR 0 2
108287: PUSH
108288: LD_VAR 0 4
108292: MINUS
108293: PUSH
108294: LD_INT 0
108296: LESS
108297: IFFALSE 108309
// min_x := 0 else
108299: LD_ADDR_VAR 0 7
108303: PUSH
108304: LD_INT 0
108306: ST_TO_ADDR
108307: GO 108325
// min_x := x - r ;
108309: LD_ADDR_VAR 0 7
108313: PUSH
108314: LD_VAR 0 2
108318: PUSH
108319: LD_VAR 0 4
108323: MINUS
108324: ST_TO_ADDR
// if y - r < 0 then
108325: LD_VAR 0 3
108329: PUSH
108330: LD_VAR 0 4
108334: MINUS
108335: PUSH
108336: LD_INT 0
108338: LESS
108339: IFFALSE 108351
// min_y := 0 else
108341: LD_ADDR_VAR 0 8
108345: PUSH
108346: LD_INT 0
108348: ST_TO_ADDR
108349: GO 108367
// min_y := y - r ;
108351: LD_ADDR_VAR 0 8
108355: PUSH
108356: LD_VAR 0 3
108360: PUSH
108361: LD_VAR 0 4
108365: MINUS
108366: ST_TO_ADDR
// max_x := x + r ;
108367: LD_ADDR_VAR 0 9
108371: PUSH
108372: LD_VAR 0 2
108376: PUSH
108377: LD_VAR 0 4
108381: PLUS
108382: ST_TO_ADDR
// max_y := y + r ;
108383: LD_ADDR_VAR 0 10
108387: PUSH
108388: LD_VAR 0 3
108392: PUSH
108393: LD_VAR 0 4
108397: PLUS
108398: ST_TO_ADDR
// for _x = min_x to max_x do
108399: LD_ADDR_VAR 0 11
108403: PUSH
108404: DOUBLE
108405: LD_VAR 0 7
108409: DEC
108410: ST_TO_ADDR
108411: LD_VAR 0 9
108415: PUSH
108416: FOR_TO
108417: IFFALSE 108534
// for _y = min_y to max_y do
108419: LD_ADDR_VAR 0 12
108423: PUSH
108424: DOUBLE
108425: LD_VAR 0 8
108429: DEC
108430: ST_TO_ADDR
108431: LD_VAR 0 10
108435: PUSH
108436: FOR_TO
108437: IFFALSE 108530
// begin if not ValidHex ( _x , _y ) then
108439: LD_VAR 0 11
108443: PPUSH
108444: LD_VAR 0 12
108448: PPUSH
108449: CALL_OW 488
108453: NOT
108454: IFFALSE 108458
// continue ;
108456: GO 108436
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108458: LD_VAR 0 11
108462: PPUSH
108463: LD_VAR 0 12
108467: PPUSH
108468: CALL_OW 351
108472: PUSH
108473: LD_VAR 0 11
108477: PPUSH
108478: LD_VAR 0 12
108482: PPUSH
108483: CALL_OW 554
108487: AND
108488: IFFALSE 108528
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108490: LD_ADDR_VAR 0 13
108494: PUSH
108495: LD_VAR 0 13
108499: PPUSH
108500: LD_VAR 0 13
108504: PUSH
108505: LD_INT 1
108507: PLUS
108508: PPUSH
108509: LD_VAR 0 11
108513: PUSH
108514: LD_VAR 0 12
108518: PUSH
108519: EMPTY
108520: LIST
108521: LIST
108522: PPUSH
108523: CALL_OW 2
108527: ST_TO_ADDR
// end ;
108528: GO 108436
108530: POP
108531: POP
108532: GO 108416
108534: POP
108535: POP
// if not list then
108536: LD_VAR 0 13
108540: NOT
108541: IFFALSE 108545
// exit ;
108543: GO 108789
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108545: LD_ADDR_VAR 0 13
108549: PUSH
108550: LD_VAR 0 1
108554: PPUSH
108555: LD_VAR 0 13
108559: PPUSH
108560: LD_INT 1
108562: PPUSH
108563: LD_INT 1
108565: PPUSH
108566: CALL 22747 0 4
108570: ST_TO_ADDR
// ComStop ( flame ) ;
108571: LD_VAR 0 1
108575: PPUSH
108576: CALL_OW 141
// for i in list do
108580: LD_ADDR_VAR 0 6
108584: PUSH
108585: LD_VAR 0 13
108589: PUSH
108590: FOR_IN
108591: IFFALSE 108622
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108593: LD_VAR 0 1
108597: PPUSH
108598: LD_VAR 0 6
108602: PUSH
108603: LD_INT 1
108605: ARRAY
108606: PPUSH
108607: LD_VAR 0 6
108611: PUSH
108612: LD_INT 2
108614: ARRAY
108615: PPUSH
108616: CALL_OW 176
108620: GO 108590
108622: POP
108623: POP
// repeat wait ( 0 0$1 ) ;
108624: LD_INT 35
108626: PPUSH
108627: CALL_OW 67
// task := GetTaskList ( flame ) ;
108631: LD_ADDR_VAR 0 14
108635: PUSH
108636: LD_VAR 0 1
108640: PPUSH
108641: CALL_OW 437
108645: ST_TO_ADDR
// if not task then
108646: LD_VAR 0 14
108650: NOT
108651: IFFALSE 108655
// exit ;
108653: GO 108789
// if task [ 1 ] [ 1 ] <> | then
108655: LD_VAR 0 14
108659: PUSH
108660: LD_INT 1
108662: ARRAY
108663: PUSH
108664: LD_INT 1
108666: ARRAY
108667: PUSH
108668: LD_STRING |
108670: NONEQUAL
108671: IFFALSE 108675
// exit ;
108673: GO 108789
// _x := task [ 1 ] [ 2 ] ;
108675: LD_ADDR_VAR 0 11
108679: PUSH
108680: LD_VAR 0 14
108684: PUSH
108685: LD_INT 1
108687: ARRAY
108688: PUSH
108689: LD_INT 2
108691: ARRAY
108692: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
108693: LD_ADDR_VAR 0 12
108697: PUSH
108698: LD_VAR 0 14
108702: PUSH
108703: LD_INT 1
108705: ARRAY
108706: PUSH
108707: LD_INT 3
108709: ARRAY
108710: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
108711: LD_VAR 0 11
108715: PPUSH
108716: LD_VAR 0 12
108720: PPUSH
108721: CALL_OW 351
108725: NOT
108726: PUSH
108727: LD_VAR 0 11
108731: PPUSH
108732: LD_VAR 0 12
108736: PPUSH
108737: CALL_OW 554
108741: NOT
108742: OR
108743: IFFALSE 108777
// begin task := Delete ( task , 1 ) ;
108745: LD_ADDR_VAR 0 14
108749: PUSH
108750: LD_VAR 0 14
108754: PPUSH
108755: LD_INT 1
108757: PPUSH
108758: CALL_OW 3
108762: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
108763: LD_VAR 0 1
108767: PPUSH
108768: LD_VAR 0 14
108772: PPUSH
108773: CALL_OW 446
// end ; until not HasTask ( flame ) ;
108777: LD_VAR 0 1
108781: PPUSH
108782: CALL_OW 314
108786: NOT
108787: IFFALSE 108624
// end ;
108789: LD_VAR 0 5
108793: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108794: LD_EXP 170
108798: NOT
108799: IFFALSE 108849
108801: GO 108803
108803: DISABLE
// begin initHack := true ;
108804: LD_ADDR_EXP 170
108808: PUSH
108809: LD_INT 1
108811: ST_TO_ADDR
// hackTanks := [ ] ;
108812: LD_ADDR_EXP 171
108816: PUSH
108817: EMPTY
108818: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108819: LD_ADDR_EXP 172
108823: PUSH
108824: EMPTY
108825: ST_TO_ADDR
// hackLimit := 3 ;
108826: LD_ADDR_EXP 173
108830: PUSH
108831: LD_INT 3
108833: ST_TO_ADDR
// hackDist := 12 ;
108834: LD_ADDR_EXP 174
108838: PUSH
108839: LD_INT 12
108841: ST_TO_ADDR
// hackCounter := [ ] ;
108842: LD_ADDR_EXP 175
108846: PUSH
108847: EMPTY
108848: ST_TO_ADDR
// end ;
108849: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108850: LD_EXP 170
108854: PUSH
108855: LD_INT 34
108857: PUSH
108858: LD_INT 99
108860: PUSH
108861: EMPTY
108862: LIST
108863: LIST
108864: PPUSH
108865: CALL_OW 69
108869: AND
108870: IFFALSE 109123
108872: GO 108874
108874: DISABLE
108875: LD_INT 0
108877: PPUSH
108878: PPUSH
// begin enable ;
108879: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108880: LD_ADDR_VAR 0 1
108884: PUSH
108885: LD_INT 34
108887: PUSH
108888: LD_INT 99
108890: PUSH
108891: EMPTY
108892: LIST
108893: LIST
108894: PPUSH
108895: CALL_OW 69
108899: PUSH
108900: FOR_IN
108901: IFFALSE 109121
// begin if not i in hackTanks then
108903: LD_VAR 0 1
108907: PUSH
108908: LD_EXP 171
108912: IN
108913: NOT
108914: IFFALSE 108997
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108916: LD_ADDR_EXP 171
108920: PUSH
108921: LD_EXP 171
108925: PPUSH
108926: LD_EXP 171
108930: PUSH
108931: LD_INT 1
108933: PLUS
108934: PPUSH
108935: LD_VAR 0 1
108939: PPUSH
108940: CALL_OW 1
108944: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108945: LD_ADDR_EXP 172
108949: PUSH
108950: LD_EXP 172
108954: PPUSH
108955: LD_EXP 172
108959: PUSH
108960: LD_INT 1
108962: PLUS
108963: PPUSH
108964: EMPTY
108965: PPUSH
108966: CALL_OW 1
108970: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108971: LD_ADDR_EXP 175
108975: PUSH
108976: LD_EXP 175
108980: PPUSH
108981: LD_EXP 175
108985: PUSH
108986: LD_INT 1
108988: PLUS
108989: PPUSH
108990: EMPTY
108991: PPUSH
108992: CALL_OW 1
108996: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108997: LD_VAR 0 1
109001: PPUSH
109002: CALL_OW 302
109006: NOT
109007: IFFALSE 109020
// begin HackUnlinkAll ( i ) ;
109009: LD_VAR 0 1
109013: PPUSH
109014: CALL 109126 0 1
// continue ;
109018: GO 108900
// end ; HackCheckCapturedStatus ( i ) ;
109020: LD_VAR 0 1
109024: PPUSH
109025: CALL 109569 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109029: LD_ADDR_VAR 0 2
109033: PUSH
109034: LD_INT 81
109036: PUSH
109037: LD_VAR 0 1
109041: PPUSH
109042: CALL_OW 255
109046: PUSH
109047: EMPTY
109048: LIST
109049: LIST
109050: PUSH
109051: LD_INT 33
109053: PUSH
109054: LD_INT 3
109056: PUSH
109057: EMPTY
109058: LIST
109059: LIST
109060: PUSH
109061: LD_INT 91
109063: PUSH
109064: LD_VAR 0 1
109068: PUSH
109069: LD_EXP 174
109073: PUSH
109074: EMPTY
109075: LIST
109076: LIST
109077: LIST
109078: PUSH
109079: LD_INT 50
109081: PUSH
109082: EMPTY
109083: LIST
109084: PUSH
109085: EMPTY
109086: LIST
109087: LIST
109088: LIST
109089: LIST
109090: PPUSH
109091: CALL_OW 69
109095: ST_TO_ADDR
// if not tmp then
109096: LD_VAR 0 2
109100: NOT
109101: IFFALSE 109105
// continue ;
109103: GO 108900
// HackLink ( i , tmp ) ;
109105: LD_VAR 0 1
109109: PPUSH
109110: LD_VAR 0 2
109114: PPUSH
109115: CALL 109262 0 2
// end ;
109119: GO 108900
109121: POP
109122: POP
// end ;
109123: PPOPN 2
109125: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109126: LD_INT 0
109128: PPUSH
109129: PPUSH
109130: PPUSH
// if not hack in hackTanks then
109131: LD_VAR 0 1
109135: PUSH
109136: LD_EXP 171
109140: IN
109141: NOT
109142: IFFALSE 109146
// exit ;
109144: GO 109257
// index := GetElementIndex ( hackTanks , hack ) ;
109146: LD_ADDR_VAR 0 4
109150: PUSH
109151: LD_EXP 171
109155: PPUSH
109156: LD_VAR 0 1
109160: PPUSH
109161: CALL 22044 0 2
109165: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109166: LD_EXP 172
109170: PUSH
109171: LD_VAR 0 4
109175: ARRAY
109176: IFFALSE 109257
// begin for i in hackTanksCaptured [ index ] do
109178: LD_ADDR_VAR 0 3
109182: PUSH
109183: LD_EXP 172
109187: PUSH
109188: LD_VAR 0 4
109192: ARRAY
109193: PUSH
109194: FOR_IN
109195: IFFALSE 109221
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109197: LD_VAR 0 3
109201: PUSH
109202: LD_INT 1
109204: ARRAY
109205: PPUSH
109206: LD_VAR 0 3
109210: PUSH
109211: LD_INT 2
109213: ARRAY
109214: PPUSH
109215: CALL_OW 235
109219: GO 109194
109221: POP
109222: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109223: LD_ADDR_EXP 172
109227: PUSH
109228: LD_EXP 172
109232: PPUSH
109233: LD_VAR 0 4
109237: PPUSH
109238: EMPTY
109239: PPUSH
109240: CALL_OW 1
109244: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109245: LD_VAR 0 1
109249: PPUSH
109250: LD_INT 0
109252: PPUSH
109253: CALL_OW 505
// end ; end ;
109257: LD_VAR 0 2
109261: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109262: LD_INT 0
109264: PPUSH
109265: PPUSH
109266: PPUSH
// if not hack in hackTanks or not vehicles then
109267: LD_VAR 0 1
109271: PUSH
109272: LD_EXP 171
109276: IN
109277: NOT
109278: PUSH
109279: LD_VAR 0 2
109283: NOT
109284: OR
109285: IFFALSE 109289
// exit ;
109287: GO 109564
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109289: LD_ADDR_VAR 0 2
109293: PUSH
109294: LD_VAR 0 1
109298: PPUSH
109299: LD_VAR 0 2
109303: PPUSH
109304: LD_INT 1
109306: PPUSH
109307: LD_INT 1
109309: PPUSH
109310: CALL 22694 0 4
109314: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109315: LD_ADDR_VAR 0 5
109319: PUSH
109320: LD_EXP 171
109324: PPUSH
109325: LD_VAR 0 1
109329: PPUSH
109330: CALL 22044 0 2
109334: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109335: LD_EXP 172
109339: PUSH
109340: LD_VAR 0 5
109344: ARRAY
109345: PUSH
109346: LD_EXP 173
109350: LESS
109351: IFFALSE 109540
// begin for i := 1 to vehicles do
109353: LD_ADDR_VAR 0 4
109357: PUSH
109358: DOUBLE
109359: LD_INT 1
109361: DEC
109362: ST_TO_ADDR
109363: LD_VAR 0 2
109367: PUSH
109368: FOR_TO
109369: IFFALSE 109538
// begin if hackTanksCaptured [ index ] = hackLimit then
109371: LD_EXP 172
109375: PUSH
109376: LD_VAR 0 5
109380: ARRAY
109381: PUSH
109382: LD_EXP 173
109386: EQUAL
109387: IFFALSE 109391
// break ;
109389: GO 109538
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109391: LD_ADDR_EXP 175
109395: PUSH
109396: LD_EXP 175
109400: PPUSH
109401: LD_VAR 0 5
109405: PPUSH
109406: LD_EXP 175
109410: PUSH
109411: LD_VAR 0 5
109415: ARRAY
109416: PUSH
109417: LD_INT 1
109419: PLUS
109420: PPUSH
109421: CALL_OW 1
109425: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109426: LD_ADDR_EXP 172
109430: PUSH
109431: LD_EXP 172
109435: PPUSH
109436: LD_VAR 0 5
109440: PUSH
109441: LD_EXP 172
109445: PUSH
109446: LD_VAR 0 5
109450: ARRAY
109451: PUSH
109452: LD_INT 1
109454: PLUS
109455: PUSH
109456: EMPTY
109457: LIST
109458: LIST
109459: PPUSH
109460: LD_VAR 0 2
109464: PUSH
109465: LD_VAR 0 4
109469: ARRAY
109470: PUSH
109471: LD_VAR 0 2
109475: PUSH
109476: LD_VAR 0 4
109480: ARRAY
109481: PPUSH
109482: CALL_OW 255
109486: PUSH
109487: EMPTY
109488: LIST
109489: LIST
109490: PPUSH
109491: CALL 22259 0 3
109495: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109496: LD_VAR 0 2
109500: PUSH
109501: LD_VAR 0 4
109505: ARRAY
109506: PPUSH
109507: LD_VAR 0 1
109511: PPUSH
109512: CALL_OW 255
109516: PPUSH
109517: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109521: LD_VAR 0 2
109525: PUSH
109526: LD_VAR 0 4
109530: ARRAY
109531: PPUSH
109532: CALL_OW 141
// end ;
109536: GO 109368
109538: POP
109539: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109540: LD_VAR 0 1
109544: PPUSH
109545: LD_EXP 172
109549: PUSH
109550: LD_VAR 0 5
109554: ARRAY
109555: PUSH
109556: LD_INT 0
109558: PLUS
109559: PPUSH
109560: CALL_OW 505
// end ;
109564: LD_VAR 0 3
109568: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109569: LD_INT 0
109571: PPUSH
109572: PPUSH
109573: PPUSH
109574: PPUSH
// if not hack in hackTanks then
109575: LD_VAR 0 1
109579: PUSH
109580: LD_EXP 171
109584: IN
109585: NOT
109586: IFFALSE 109590
// exit ;
109588: GO 109830
// index := GetElementIndex ( hackTanks , hack ) ;
109590: LD_ADDR_VAR 0 4
109594: PUSH
109595: LD_EXP 171
109599: PPUSH
109600: LD_VAR 0 1
109604: PPUSH
109605: CALL 22044 0 2
109609: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109610: LD_ADDR_VAR 0 3
109614: PUSH
109615: DOUBLE
109616: LD_EXP 172
109620: PUSH
109621: LD_VAR 0 4
109625: ARRAY
109626: INC
109627: ST_TO_ADDR
109628: LD_INT 1
109630: PUSH
109631: FOR_DOWNTO
109632: IFFALSE 109804
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109634: LD_ADDR_VAR 0 5
109638: PUSH
109639: LD_EXP 172
109643: PUSH
109644: LD_VAR 0 4
109648: ARRAY
109649: PUSH
109650: LD_VAR 0 3
109654: ARRAY
109655: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109656: LD_VAR 0 5
109660: PUSH
109661: LD_INT 1
109663: ARRAY
109664: PPUSH
109665: CALL_OW 302
109669: NOT
109670: PUSH
109671: LD_VAR 0 5
109675: PUSH
109676: LD_INT 1
109678: ARRAY
109679: PPUSH
109680: CALL_OW 255
109684: PUSH
109685: LD_VAR 0 1
109689: PPUSH
109690: CALL_OW 255
109694: NONEQUAL
109695: OR
109696: IFFALSE 109802
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109698: LD_VAR 0 5
109702: PUSH
109703: LD_INT 1
109705: ARRAY
109706: PPUSH
109707: CALL_OW 305
109711: PUSH
109712: LD_VAR 0 5
109716: PUSH
109717: LD_INT 1
109719: ARRAY
109720: PPUSH
109721: CALL_OW 255
109725: PUSH
109726: LD_VAR 0 1
109730: PPUSH
109731: CALL_OW 255
109735: EQUAL
109736: AND
109737: IFFALSE 109761
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109739: LD_VAR 0 5
109743: PUSH
109744: LD_INT 1
109746: ARRAY
109747: PPUSH
109748: LD_VAR 0 5
109752: PUSH
109753: LD_INT 2
109755: ARRAY
109756: PPUSH
109757: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109761: LD_ADDR_EXP 172
109765: PUSH
109766: LD_EXP 172
109770: PPUSH
109771: LD_VAR 0 4
109775: PPUSH
109776: LD_EXP 172
109780: PUSH
109781: LD_VAR 0 4
109785: ARRAY
109786: PPUSH
109787: LD_VAR 0 3
109791: PPUSH
109792: CALL_OW 3
109796: PPUSH
109797: CALL_OW 1
109801: ST_TO_ADDR
// end ; end ;
109802: GO 109631
109804: POP
109805: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109806: LD_VAR 0 1
109810: PPUSH
109811: LD_EXP 172
109815: PUSH
109816: LD_VAR 0 4
109820: ARRAY
109821: PUSH
109822: LD_INT 0
109824: PLUS
109825: PPUSH
109826: CALL_OW 505
// end ;
109830: LD_VAR 0 2
109834: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109835: LD_INT 0
109837: PPUSH
109838: PPUSH
109839: PPUSH
109840: PPUSH
// if not hack in hackTanks then
109841: LD_VAR 0 1
109845: PUSH
109846: LD_EXP 171
109850: IN
109851: NOT
109852: IFFALSE 109856
// exit ;
109854: GO 109941
// index := GetElementIndex ( hackTanks , hack ) ;
109856: LD_ADDR_VAR 0 5
109860: PUSH
109861: LD_EXP 171
109865: PPUSH
109866: LD_VAR 0 1
109870: PPUSH
109871: CALL 22044 0 2
109875: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109876: LD_ADDR_VAR 0 4
109880: PUSH
109881: DOUBLE
109882: LD_INT 1
109884: DEC
109885: ST_TO_ADDR
109886: LD_EXP 172
109890: PUSH
109891: LD_VAR 0 5
109895: ARRAY
109896: PUSH
109897: FOR_TO
109898: IFFALSE 109939
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109900: LD_EXP 172
109904: PUSH
109905: LD_VAR 0 5
109909: ARRAY
109910: PUSH
109911: LD_VAR 0 4
109915: ARRAY
109916: PUSH
109917: LD_INT 1
109919: ARRAY
109920: PUSH
109921: LD_VAR 0 2
109925: EQUAL
109926: IFFALSE 109937
// KillUnit ( vehicle ) ;
109928: LD_VAR 0 2
109932: PPUSH
109933: CALL_OW 66
109937: GO 109897
109939: POP
109940: POP
// end ;
109941: LD_VAR 0 3
109945: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109946: LD_EXP 176
109950: NOT
109951: IFFALSE 109986
109953: GO 109955
109955: DISABLE
// begin initMiner := true ;
109956: LD_ADDR_EXP 176
109960: PUSH
109961: LD_INT 1
109963: ST_TO_ADDR
// minersList := [ ] ;
109964: LD_ADDR_EXP 177
109968: PUSH
109969: EMPTY
109970: ST_TO_ADDR
// minerMinesList := [ ] ;
109971: LD_ADDR_EXP 178
109975: PUSH
109976: EMPTY
109977: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109978: LD_ADDR_EXP 179
109982: PUSH
109983: LD_INT 5
109985: ST_TO_ADDR
// end ;
109986: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109987: LD_EXP 176
109991: PUSH
109992: LD_INT 34
109994: PUSH
109995: LD_INT 81
109997: PUSH
109998: EMPTY
109999: LIST
110000: LIST
110001: PPUSH
110002: CALL_OW 69
110006: AND
110007: IFFALSE 110468
110009: GO 110011
110011: DISABLE
110012: LD_INT 0
110014: PPUSH
110015: PPUSH
110016: PPUSH
110017: PPUSH
// begin enable ;
110018: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110019: LD_ADDR_VAR 0 1
110023: PUSH
110024: LD_INT 34
110026: PUSH
110027: LD_INT 81
110029: PUSH
110030: EMPTY
110031: LIST
110032: LIST
110033: PPUSH
110034: CALL_OW 69
110038: PUSH
110039: FOR_IN
110040: IFFALSE 110112
// begin if not i in minersList then
110042: LD_VAR 0 1
110046: PUSH
110047: LD_EXP 177
110051: IN
110052: NOT
110053: IFFALSE 110110
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110055: LD_ADDR_EXP 177
110059: PUSH
110060: LD_EXP 177
110064: PPUSH
110065: LD_EXP 177
110069: PUSH
110070: LD_INT 1
110072: PLUS
110073: PPUSH
110074: LD_VAR 0 1
110078: PPUSH
110079: CALL_OW 1
110083: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110084: LD_ADDR_EXP 178
110088: PUSH
110089: LD_EXP 178
110093: PPUSH
110094: LD_EXP 178
110098: PUSH
110099: LD_INT 1
110101: PLUS
110102: PPUSH
110103: EMPTY
110104: PPUSH
110105: CALL_OW 1
110109: ST_TO_ADDR
// end end ;
110110: GO 110039
110112: POP
110113: POP
// for i := minerMinesList downto 1 do
110114: LD_ADDR_VAR 0 1
110118: PUSH
110119: DOUBLE
110120: LD_EXP 178
110124: INC
110125: ST_TO_ADDR
110126: LD_INT 1
110128: PUSH
110129: FOR_DOWNTO
110130: IFFALSE 110466
// begin if IsLive ( minersList [ i ] ) then
110132: LD_EXP 177
110136: PUSH
110137: LD_VAR 0 1
110141: ARRAY
110142: PPUSH
110143: CALL_OW 300
110147: IFFALSE 110175
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110149: LD_EXP 177
110153: PUSH
110154: LD_VAR 0 1
110158: ARRAY
110159: PPUSH
110160: LD_EXP 178
110164: PUSH
110165: LD_VAR 0 1
110169: ARRAY
110170: PPUSH
110171: CALL_OW 505
// if not minerMinesList [ i ] then
110175: LD_EXP 178
110179: PUSH
110180: LD_VAR 0 1
110184: ARRAY
110185: NOT
110186: IFFALSE 110190
// continue ;
110188: GO 110129
// for j := minerMinesList [ i ] downto 1 do
110190: LD_ADDR_VAR 0 2
110194: PUSH
110195: DOUBLE
110196: LD_EXP 178
110200: PUSH
110201: LD_VAR 0 1
110205: ARRAY
110206: INC
110207: ST_TO_ADDR
110208: LD_INT 1
110210: PUSH
110211: FOR_DOWNTO
110212: IFFALSE 110462
// begin side := GetSide ( minersList [ i ] ) ;
110214: LD_ADDR_VAR 0 3
110218: PUSH
110219: LD_EXP 177
110223: PUSH
110224: LD_VAR 0 1
110228: ARRAY
110229: PPUSH
110230: CALL_OW 255
110234: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110235: LD_ADDR_VAR 0 4
110239: PUSH
110240: LD_EXP 178
110244: PUSH
110245: LD_VAR 0 1
110249: ARRAY
110250: PUSH
110251: LD_VAR 0 2
110255: ARRAY
110256: PUSH
110257: LD_INT 1
110259: ARRAY
110260: PPUSH
110261: LD_EXP 178
110265: PUSH
110266: LD_VAR 0 1
110270: ARRAY
110271: PUSH
110272: LD_VAR 0 2
110276: ARRAY
110277: PUSH
110278: LD_INT 2
110280: ARRAY
110281: PPUSH
110282: CALL_OW 428
110286: ST_TO_ADDR
// if not tmp then
110287: LD_VAR 0 4
110291: NOT
110292: IFFALSE 110296
// continue ;
110294: GO 110211
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110296: LD_VAR 0 4
110300: PUSH
110301: LD_INT 81
110303: PUSH
110304: LD_VAR 0 3
110308: PUSH
110309: EMPTY
110310: LIST
110311: LIST
110312: PPUSH
110313: CALL_OW 69
110317: IN
110318: PUSH
110319: LD_EXP 178
110323: PUSH
110324: LD_VAR 0 1
110328: ARRAY
110329: PUSH
110330: LD_VAR 0 2
110334: ARRAY
110335: PUSH
110336: LD_INT 1
110338: ARRAY
110339: PPUSH
110340: LD_EXP 178
110344: PUSH
110345: LD_VAR 0 1
110349: ARRAY
110350: PUSH
110351: LD_VAR 0 2
110355: ARRAY
110356: PUSH
110357: LD_INT 2
110359: ARRAY
110360: PPUSH
110361: CALL_OW 458
110365: AND
110366: IFFALSE 110460
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110368: LD_EXP 178
110372: PUSH
110373: LD_VAR 0 1
110377: ARRAY
110378: PUSH
110379: LD_VAR 0 2
110383: ARRAY
110384: PUSH
110385: LD_INT 1
110387: ARRAY
110388: PPUSH
110389: LD_EXP 178
110393: PUSH
110394: LD_VAR 0 1
110398: ARRAY
110399: PUSH
110400: LD_VAR 0 2
110404: ARRAY
110405: PUSH
110406: LD_INT 2
110408: ARRAY
110409: PPUSH
110410: LD_VAR 0 3
110414: PPUSH
110415: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110419: LD_ADDR_EXP 178
110423: PUSH
110424: LD_EXP 178
110428: PPUSH
110429: LD_VAR 0 1
110433: PPUSH
110434: LD_EXP 178
110438: PUSH
110439: LD_VAR 0 1
110443: ARRAY
110444: PPUSH
110445: LD_VAR 0 2
110449: PPUSH
110450: CALL_OW 3
110454: PPUSH
110455: CALL_OW 1
110459: ST_TO_ADDR
// end ; end ;
110460: GO 110211
110462: POP
110463: POP
// end ;
110464: GO 110129
110466: POP
110467: POP
// end ;
110468: PPOPN 4
110470: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110471: LD_INT 0
110473: PPUSH
110474: PPUSH
// result := false ;
110475: LD_ADDR_VAR 0 4
110479: PUSH
110480: LD_INT 0
110482: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110483: LD_VAR 0 1
110487: PPUSH
110488: CALL_OW 264
110492: PUSH
110493: LD_INT 81
110495: EQUAL
110496: NOT
110497: IFFALSE 110501
// exit ;
110499: GO 110741
// index := GetElementIndex ( minersList , unit ) ;
110501: LD_ADDR_VAR 0 5
110505: PUSH
110506: LD_EXP 177
110510: PPUSH
110511: LD_VAR 0 1
110515: PPUSH
110516: CALL 22044 0 2
110520: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110521: LD_EXP 178
110525: PUSH
110526: LD_VAR 0 5
110530: ARRAY
110531: PUSH
110532: LD_EXP 179
110536: GREATEREQUAL
110537: IFFALSE 110541
// exit ;
110539: GO 110741
// ComMoveXY ( unit , x , y ) ;
110541: LD_VAR 0 1
110545: PPUSH
110546: LD_VAR 0 2
110550: PPUSH
110551: LD_VAR 0 3
110555: PPUSH
110556: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110560: LD_INT 35
110562: PPUSH
110563: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110567: LD_VAR 0 1
110571: PPUSH
110572: LD_VAR 0 2
110576: PPUSH
110577: LD_VAR 0 3
110581: PPUSH
110582: CALL 53805 0 3
110586: NOT
110587: PUSH
110588: LD_VAR 0 1
110592: PPUSH
110593: CALL_OW 314
110597: AND
110598: IFFALSE 110602
// exit ;
110600: GO 110741
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110602: LD_VAR 0 2
110606: PPUSH
110607: LD_VAR 0 3
110611: PPUSH
110612: CALL_OW 428
110616: PUSH
110617: LD_VAR 0 1
110621: EQUAL
110622: PUSH
110623: LD_VAR 0 1
110627: PPUSH
110628: CALL_OW 314
110632: NOT
110633: AND
110634: IFFALSE 110560
// PlaySoundXY ( x , y , PlantMine ) ;
110636: LD_VAR 0 2
110640: PPUSH
110641: LD_VAR 0 3
110645: PPUSH
110646: LD_STRING PlantMine
110648: PPUSH
110649: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110653: LD_VAR 0 2
110657: PPUSH
110658: LD_VAR 0 3
110662: PPUSH
110663: LD_VAR 0 1
110667: PPUSH
110668: CALL_OW 255
110672: PPUSH
110673: LD_INT 0
110675: PPUSH
110676: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110680: LD_ADDR_EXP 178
110684: PUSH
110685: LD_EXP 178
110689: PPUSH
110690: LD_VAR 0 5
110694: PUSH
110695: LD_EXP 178
110699: PUSH
110700: LD_VAR 0 5
110704: ARRAY
110705: PUSH
110706: LD_INT 1
110708: PLUS
110709: PUSH
110710: EMPTY
110711: LIST
110712: LIST
110713: PPUSH
110714: LD_VAR 0 2
110718: PUSH
110719: LD_VAR 0 3
110723: PUSH
110724: EMPTY
110725: LIST
110726: LIST
110727: PPUSH
110728: CALL 22259 0 3
110732: ST_TO_ADDR
// result := true ;
110733: LD_ADDR_VAR 0 4
110737: PUSH
110738: LD_INT 1
110740: ST_TO_ADDR
// end ;
110741: LD_VAR 0 4
110745: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110746: LD_INT 0
110748: PPUSH
110749: PPUSH
110750: PPUSH
// if not unit in minersList then
110751: LD_VAR 0 1
110755: PUSH
110756: LD_EXP 177
110760: IN
110761: NOT
110762: IFFALSE 110766
// exit ;
110764: GO 111158
// index := GetElementIndex ( minersList , unit ) ;
110766: LD_ADDR_VAR 0 6
110770: PUSH
110771: LD_EXP 177
110775: PPUSH
110776: LD_VAR 0 1
110780: PPUSH
110781: CALL 22044 0 2
110785: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110786: LD_ADDR_VAR 0 5
110790: PUSH
110791: DOUBLE
110792: LD_EXP 178
110796: PUSH
110797: LD_VAR 0 6
110801: ARRAY
110802: INC
110803: ST_TO_ADDR
110804: LD_INT 1
110806: PUSH
110807: FOR_DOWNTO
110808: IFFALSE 110969
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110810: LD_EXP 178
110814: PUSH
110815: LD_VAR 0 6
110819: ARRAY
110820: PUSH
110821: LD_VAR 0 5
110825: ARRAY
110826: PUSH
110827: LD_INT 1
110829: ARRAY
110830: PUSH
110831: LD_VAR 0 2
110835: EQUAL
110836: PUSH
110837: LD_EXP 178
110841: PUSH
110842: LD_VAR 0 6
110846: ARRAY
110847: PUSH
110848: LD_VAR 0 5
110852: ARRAY
110853: PUSH
110854: LD_INT 2
110856: ARRAY
110857: PUSH
110858: LD_VAR 0 3
110862: EQUAL
110863: AND
110864: IFFALSE 110967
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110866: LD_EXP 178
110870: PUSH
110871: LD_VAR 0 6
110875: ARRAY
110876: PUSH
110877: LD_VAR 0 5
110881: ARRAY
110882: PUSH
110883: LD_INT 1
110885: ARRAY
110886: PPUSH
110887: LD_EXP 178
110891: PUSH
110892: LD_VAR 0 6
110896: ARRAY
110897: PUSH
110898: LD_VAR 0 5
110902: ARRAY
110903: PUSH
110904: LD_INT 2
110906: ARRAY
110907: PPUSH
110908: LD_VAR 0 1
110912: PPUSH
110913: CALL_OW 255
110917: PPUSH
110918: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110922: LD_ADDR_EXP 178
110926: PUSH
110927: LD_EXP 178
110931: PPUSH
110932: LD_VAR 0 6
110936: PPUSH
110937: LD_EXP 178
110941: PUSH
110942: LD_VAR 0 6
110946: ARRAY
110947: PPUSH
110948: LD_VAR 0 5
110952: PPUSH
110953: CALL_OW 3
110957: PPUSH
110958: CALL_OW 1
110962: ST_TO_ADDR
// exit ;
110963: POP
110964: POP
110965: GO 111158
// end ; end ;
110967: GO 110807
110969: POP
110970: POP
// for i := minerMinesList [ index ] downto 1 do
110971: LD_ADDR_VAR 0 5
110975: PUSH
110976: DOUBLE
110977: LD_EXP 178
110981: PUSH
110982: LD_VAR 0 6
110986: ARRAY
110987: INC
110988: ST_TO_ADDR
110989: LD_INT 1
110991: PUSH
110992: FOR_DOWNTO
110993: IFFALSE 111156
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110995: LD_EXP 178
110999: PUSH
111000: LD_VAR 0 6
111004: ARRAY
111005: PUSH
111006: LD_VAR 0 5
111010: ARRAY
111011: PUSH
111012: LD_INT 1
111014: ARRAY
111015: PPUSH
111016: LD_EXP 178
111020: PUSH
111021: LD_VAR 0 6
111025: ARRAY
111026: PUSH
111027: LD_VAR 0 5
111031: ARRAY
111032: PUSH
111033: LD_INT 2
111035: ARRAY
111036: PPUSH
111037: LD_VAR 0 2
111041: PPUSH
111042: LD_VAR 0 3
111046: PPUSH
111047: CALL_OW 298
111051: PUSH
111052: LD_INT 6
111054: LESS
111055: IFFALSE 111154
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111057: LD_EXP 178
111061: PUSH
111062: LD_VAR 0 6
111066: ARRAY
111067: PUSH
111068: LD_VAR 0 5
111072: ARRAY
111073: PUSH
111074: LD_INT 1
111076: ARRAY
111077: PPUSH
111078: LD_EXP 178
111082: PUSH
111083: LD_VAR 0 6
111087: ARRAY
111088: PUSH
111089: LD_VAR 0 5
111093: ARRAY
111094: PUSH
111095: LD_INT 2
111097: ARRAY
111098: PPUSH
111099: LD_VAR 0 1
111103: PPUSH
111104: CALL_OW 255
111108: PPUSH
111109: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111113: LD_ADDR_EXP 178
111117: PUSH
111118: LD_EXP 178
111122: PPUSH
111123: LD_VAR 0 6
111127: PPUSH
111128: LD_EXP 178
111132: PUSH
111133: LD_VAR 0 6
111137: ARRAY
111138: PPUSH
111139: LD_VAR 0 5
111143: PPUSH
111144: CALL_OW 3
111148: PPUSH
111149: CALL_OW 1
111153: ST_TO_ADDR
// end ; end ;
111154: GO 110992
111156: POP
111157: POP
// end ;
111158: LD_VAR 0 4
111162: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111163: LD_INT 0
111165: PPUSH
111166: PPUSH
111167: PPUSH
111168: PPUSH
111169: PPUSH
111170: PPUSH
111171: PPUSH
111172: PPUSH
111173: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111174: LD_VAR 0 1
111178: PPUSH
111179: CALL_OW 264
111183: PUSH
111184: LD_INT 81
111186: EQUAL
111187: NOT
111188: PUSH
111189: LD_VAR 0 1
111193: PUSH
111194: LD_EXP 177
111198: IN
111199: NOT
111200: OR
111201: IFFALSE 111205
// exit ;
111203: GO 111527
// index := GetElementIndex ( minersList , unit ) ;
111205: LD_ADDR_VAR 0 6
111209: PUSH
111210: LD_EXP 177
111214: PPUSH
111215: LD_VAR 0 1
111219: PPUSH
111220: CALL 22044 0 2
111224: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111225: LD_ADDR_VAR 0 8
111229: PUSH
111230: LD_EXP 179
111234: PUSH
111235: LD_EXP 178
111239: PUSH
111240: LD_VAR 0 6
111244: ARRAY
111245: MINUS
111246: ST_TO_ADDR
// if not minesFreeAmount then
111247: LD_VAR 0 8
111251: NOT
111252: IFFALSE 111256
// exit ;
111254: GO 111527
// tmp := [ ] ;
111256: LD_ADDR_VAR 0 7
111260: PUSH
111261: EMPTY
111262: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111263: LD_ADDR_VAR 0 5
111267: PUSH
111268: DOUBLE
111269: LD_INT 1
111271: DEC
111272: ST_TO_ADDR
111273: LD_VAR 0 8
111277: PUSH
111278: FOR_TO
111279: IFFALSE 111474
// begin _d := rand ( 0 , 5 ) ;
111281: LD_ADDR_VAR 0 11
111285: PUSH
111286: LD_INT 0
111288: PPUSH
111289: LD_INT 5
111291: PPUSH
111292: CALL_OW 12
111296: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111297: LD_ADDR_VAR 0 12
111301: PUSH
111302: LD_INT 2
111304: PPUSH
111305: LD_INT 6
111307: PPUSH
111308: CALL_OW 12
111312: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111313: LD_ADDR_VAR 0 9
111317: PUSH
111318: LD_VAR 0 2
111322: PPUSH
111323: LD_VAR 0 11
111327: PPUSH
111328: LD_VAR 0 12
111332: PPUSH
111333: CALL_OW 272
111337: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111338: LD_ADDR_VAR 0 10
111342: PUSH
111343: LD_VAR 0 3
111347: PPUSH
111348: LD_VAR 0 11
111352: PPUSH
111353: LD_VAR 0 12
111357: PPUSH
111358: CALL_OW 273
111362: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111363: LD_VAR 0 9
111367: PPUSH
111368: LD_VAR 0 10
111372: PPUSH
111373: CALL_OW 488
111377: PUSH
111378: LD_VAR 0 9
111382: PUSH
111383: LD_VAR 0 10
111387: PUSH
111388: EMPTY
111389: LIST
111390: LIST
111391: PUSH
111392: LD_VAR 0 7
111396: IN
111397: NOT
111398: AND
111399: PUSH
111400: LD_VAR 0 9
111404: PPUSH
111405: LD_VAR 0 10
111409: PPUSH
111410: CALL_OW 458
111414: NOT
111415: AND
111416: IFFALSE 111458
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111418: LD_ADDR_VAR 0 7
111422: PUSH
111423: LD_VAR 0 7
111427: PPUSH
111428: LD_VAR 0 7
111432: PUSH
111433: LD_INT 1
111435: PLUS
111436: PPUSH
111437: LD_VAR 0 9
111441: PUSH
111442: LD_VAR 0 10
111446: PUSH
111447: EMPTY
111448: LIST
111449: LIST
111450: PPUSH
111451: CALL_OW 1
111455: ST_TO_ADDR
111456: GO 111472
// i := i - 1 ;
111458: LD_ADDR_VAR 0 5
111462: PUSH
111463: LD_VAR 0 5
111467: PUSH
111468: LD_INT 1
111470: MINUS
111471: ST_TO_ADDR
// end ;
111472: GO 111278
111474: POP
111475: POP
// for i in tmp do
111476: LD_ADDR_VAR 0 5
111480: PUSH
111481: LD_VAR 0 7
111485: PUSH
111486: FOR_IN
111487: IFFALSE 111525
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111489: LD_VAR 0 1
111493: PPUSH
111494: LD_VAR 0 5
111498: PUSH
111499: LD_INT 1
111501: ARRAY
111502: PPUSH
111503: LD_VAR 0 5
111507: PUSH
111508: LD_INT 2
111510: ARRAY
111511: PPUSH
111512: CALL 110471 0 3
111516: NOT
111517: IFFALSE 111523
// exit ;
111519: POP
111520: POP
111521: GO 111527
111523: GO 111486
111525: POP
111526: POP
// end ;
111527: LD_VAR 0 4
111531: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
111532: LD_INT 0
111534: PPUSH
111535: PPUSH
111536: PPUSH
111537: PPUSH
111538: PPUSH
111539: PPUSH
111540: PPUSH
111541: PPUSH
111542: PPUSH
// if GetClass ( unit ) <> class_sniper then
111543: LD_VAR 0 1
111547: PPUSH
111548: CALL_OW 257
111552: PUSH
111553: LD_INT 5
111555: NONEQUAL
111556: IFFALSE 111560
// exit ;
111558: GO 112026
// dist := 8 ;
111560: LD_ADDR_VAR 0 5
111564: PUSH
111565: LD_INT 8
111567: ST_TO_ADDR
// viewRange := 12 ;
111568: LD_ADDR_VAR 0 8
111572: PUSH
111573: LD_INT 12
111575: ST_TO_ADDR
// side := GetSide ( unit ) ;
111576: LD_ADDR_VAR 0 6
111580: PUSH
111581: LD_VAR 0 1
111585: PPUSH
111586: CALL_OW 255
111590: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111591: LD_INT 61
111593: PPUSH
111594: LD_VAR 0 6
111598: PPUSH
111599: CALL_OW 321
111603: PUSH
111604: LD_INT 2
111606: EQUAL
111607: IFFALSE 111617
// viewRange := 16 ;
111609: LD_ADDR_VAR 0 8
111613: PUSH
111614: LD_INT 16
111616: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111617: LD_VAR 0 1
111621: PPUSH
111622: LD_VAR 0 2
111626: PPUSH
111627: LD_VAR 0 3
111631: PPUSH
111632: CALL_OW 297
111636: PUSH
111637: LD_VAR 0 5
111641: GREATER
111642: IFFALSE 111721
// begin ComMoveXY ( unit , x , y ) ;
111644: LD_VAR 0 1
111648: PPUSH
111649: LD_VAR 0 2
111653: PPUSH
111654: LD_VAR 0 3
111658: PPUSH
111659: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111663: LD_INT 35
111665: PPUSH
111666: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111670: LD_VAR 0 1
111674: PPUSH
111675: LD_VAR 0 2
111679: PPUSH
111680: LD_VAR 0 3
111684: PPUSH
111685: CALL 53805 0 3
111689: NOT
111690: IFFALSE 111694
// exit ;
111692: GO 112026
// until GetDistUnitXY ( unit , x , y ) < dist ;
111694: LD_VAR 0 1
111698: PPUSH
111699: LD_VAR 0 2
111703: PPUSH
111704: LD_VAR 0 3
111708: PPUSH
111709: CALL_OW 297
111713: PUSH
111714: LD_VAR 0 5
111718: LESS
111719: IFFALSE 111663
// end ; ComTurnXY ( unit , x , y ) ;
111721: LD_VAR 0 1
111725: PPUSH
111726: LD_VAR 0 2
111730: PPUSH
111731: LD_VAR 0 3
111735: PPUSH
111736: CALL_OW 118
// repeat if Multiplayer then
111740: LD_OWVAR 4
111744: IFFALSE 111755
// wait ( 35 ) else
111746: LD_INT 35
111748: PPUSH
111749: CALL_OW 67
111753: GO 111762
// wait ( 5 ) ;
111755: LD_INT 5
111757: PPUSH
111758: CALL_OW 67
// _d := GetDir ( unit ) ;
111762: LD_ADDR_VAR 0 11
111766: PUSH
111767: LD_VAR 0 1
111771: PPUSH
111772: CALL_OW 254
111776: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
111777: LD_ADDR_VAR 0 7
111781: PUSH
111782: LD_VAR 0 1
111786: PPUSH
111787: CALL_OW 250
111791: PPUSH
111792: LD_VAR 0 1
111796: PPUSH
111797: CALL_OW 251
111801: PPUSH
111802: LD_VAR 0 2
111806: PPUSH
111807: LD_VAR 0 3
111811: PPUSH
111812: CALL 56413 0 4
111816: ST_TO_ADDR
// until dir = _d ;
111817: LD_VAR 0 7
111821: PUSH
111822: LD_VAR 0 11
111826: EQUAL
111827: IFFALSE 111740
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
111829: LD_ADDR_VAR 0 9
111833: PUSH
111834: LD_VAR 0 1
111838: PPUSH
111839: CALL_OW 250
111843: PPUSH
111844: LD_VAR 0 7
111848: PPUSH
111849: LD_VAR 0 5
111853: PPUSH
111854: CALL_OW 272
111858: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
111859: LD_ADDR_VAR 0 10
111863: PUSH
111864: LD_VAR 0 1
111868: PPUSH
111869: CALL_OW 251
111873: PPUSH
111874: LD_VAR 0 7
111878: PPUSH
111879: LD_VAR 0 5
111883: PPUSH
111884: CALL_OW 273
111888: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
111889: LD_VAR 0 9
111893: PPUSH
111894: LD_VAR 0 10
111898: PPUSH
111899: CALL_OW 488
111903: NOT
111904: IFFALSE 111908
// exit ;
111906: GO 112026
// ComAnimCustom ( unit , 1 ) ;
111908: LD_VAR 0 1
111912: PPUSH
111913: LD_INT 1
111915: PPUSH
111916: CALL_OW 592
// p := 0 ;
111920: LD_ADDR_VAR 0 12
111924: PUSH
111925: LD_INT 0
111927: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
111928: LD_VAR 0 9
111932: PPUSH
111933: LD_VAR 0 10
111937: PPUSH
111938: LD_VAR 0 6
111942: PPUSH
111943: LD_VAR 0 8
111947: PPUSH
111948: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
111952: LD_INT 35
111954: PPUSH
111955: CALL_OW 67
// p := Inc ( p ) ;
111959: LD_ADDR_VAR 0 12
111963: PUSH
111964: LD_VAR 0 12
111968: PPUSH
111969: CALL 56369 0 1
111973: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
111974: LD_VAR 0 12
111978: PUSH
111979: LD_INT 3
111981: EQUAL
111982: PUSH
111983: LD_VAR 0 1
111987: PPUSH
111988: CALL_OW 302
111992: NOT
111993: OR
111994: PUSH
111995: LD_VAR 0 1
111999: PPUSH
112000: CALL_OW 301
112004: OR
112005: IFFALSE 111952
// RemoveSeeing ( _x , _y , side ) ;
112007: LD_VAR 0 9
112011: PPUSH
112012: LD_VAR 0 10
112016: PPUSH
112017: LD_VAR 0 6
112021: PPUSH
112022: CALL_OW 331
// end ; end_of_file
112026: LD_VAR 0 4
112030: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112031: LD_INT 0
112033: PPUSH
112034: PPUSH
112035: PPUSH
112036: PPUSH
112037: PPUSH
112038: PPUSH
112039: PPUSH
112040: PPUSH
112041: PPUSH
112042: PPUSH
112043: PPUSH
112044: PPUSH
112045: PPUSH
112046: PPUSH
112047: PPUSH
112048: PPUSH
112049: PPUSH
112050: PPUSH
112051: PPUSH
112052: PPUSH
112053: PPUSH
112054: PPUSH
112055: PPUSH
112056: PPUSH
112057: PPUSH
112058: PPUSH
112059: PPUSH
112060: PPUSH
112061: PPUSH
112062: PPUSH
112063: PPUSH
112064: PPUSH
112065: PPUSH
112066: PPUSH
// if not list then
112067: LD_VAR 0 1
112071: NOT
112072: IFFALSE 112076
// exit ;
112074: GO 116735
// base := list [ 1 ] ;
112076: LD_ADDR_VAR 0 3
112080: PUSH
112081: LD_VAR 0 1
112085: PUSH
112086: LD_INT 1
112088: ARRAY
112089: ST_TO_ADDR
// group := list [ 2 ] ;
112090: LD_ADDR_VAR 0 4
112094: PUSH
112095: LD_VAR 0 1
112099: PUSH
112100: LD_INT 2
112102: ARRAY
112103: ST_TO_ADDR
// path := list [ 3 ] ;
112104: LD_ADDR_VAR 0 5
112108: PUSH
112109: LD_VAR 0 1
112113: PUSH
112114: LD_INT 3
112116: ARRAY
112117: ST_TO_ADDR
// flags := list [ 4 ] ;
112118: LD_ADDR_VAR 0 6
112122: PUSH
112123: LD_VAR 0 1
112127: PUSH
112128: LD_INT 4
112130: ARRAY
112131: ST_TO_ADDR
// mined := [ ] ;
112132: LD_ADDR_VAR 0 27
112136: PUSH
112137: EMPTY
112138: ST_TO_ADDR
// bombed := [ ] ;
112139: LD_ADDR_VAR 0 28
112143: PUSH
112144: EMPTY
112145: ST_TO_ADDR
// healers := [ ] ;
112146: LD_ADDR_VAR 0 31
112150: PUSH
112151: EMPTY
112152: ST_TO_ADDR
// to_heal := [ ] ;
112153: LD_ADDR_VAR 0 30
112157: PUSH
112158: EMPTY
112159: ST_TO_ADDR
// repairs := [ ] ;
112160: LD_ADDR_VAR 0 33
112164: PUSH
112165: EMPTY
112166: ST_TO_ADDR
// to_repair := [ ] ;
112167: LD_ADDR_VAR 0 32
112171: PUSH
112172: EMPTY
112173: ST_TO_ADDR
// if not group or not path then
112174: LD_VAR 0 4
112178: NOT
112179: PUSH
112180: LD_VAR 0 5
112184: NOT
112185: OR
112186: IFFALSE 112190
// exit ;
112188: GO 116735
// side := GetSide ( group [ 1 ] ) ;
112190: LD_ADDR_VAR 0 35
112194: PUSH
112195: LD_VAR 0 4
112199: PUSH
112200: LD_INT 1
112202: ARRAY
112203: PPUSH
112204: CALL_OW 255
112208: ST_TO_ADDR
// if flags then
112209: LD_VAR 0 6
112213: IFFALSE 112357
// begin f_ignore_area := flags [ 1 ] ;
112215: LD_ADDR_VAR 0 17
112219: PUSH
112220: LD_VAR 0 6
112224: PUSH
112225: LD_INT 1
112227: ARRAY
112228: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112229: LD_ADDR_VAR 0 18
112233: PUSH
112234: LD_VAR 0 6
112238: PUSH
112239: LD_INT 2
112241: ARRAY
112242: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112243: LD_ADDR_VAR 0 19
112247: PUSH
112248: LD_VAR 0 6
112252: PUSH
112253: LD_INT 3
112255: ARRAY
112256: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112257: LD_ADDR_VAR 0 20
112261: PUSH
112262: LD_VAR 0 6
112266: PUSH
112267: LD_INT 4
112269: ARRAY
112270: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112271: LD_ADDR_VAR 0 21
112275: PUSH
112276: LD_VAR 0 6
112280: PUSH
112281: LD_INT 5
112283: ARRAY
112284: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112285: LD_ADDR_VAR 0 22
112289: PUSH
112290: LD_VAR 0 6
112294: PUSH
112295: LD_INT 6
112297: ARRAY
112298: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112299: LD_ADDR_VAR 0 23
112303: PUSH
112304: LD_VAR 0 6
112308: PUSH
112309: LD_INT 7
112311: ARRAY
112312: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112313: LD_ADDR_VAR 0 24
112317: PUSH
112318: LD_VAR 0 6
112322: PUSH
112323: LD_INT 8
112325: ARRAY
112326: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112327: LD_ADDR_VAR 0 25
112331: PUSH
112332: LD_VAR 0 6
112336: PUSH
112337: LD_INT 9
112339: ARRAY
112340: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112341: LD_ADDR_VAR 0 26
112345: PUSH
112346: LD_VAR 0 6
112350: PUSH
112351: LD_INT 10
112353: ARRAY
112354: ST_TO_ADDR
// end else
112355: GO 112437
// begin f_ignore_area := false ;
112357: LD_ADDR_VAR 0 17
112361: PUSH
112362: LD_INT 0
112364: ST_TO_ADDR
// f_capture := false ;
112365: LD_ADDR_VAR 0 18
112369: PUSH
112370: LD_INT 0
112372: ST_TO_ADDR
// f_ignore_civ := false ;
112373: LD_ADDR_VAR 0 19
112377: PUSH
112378: LD_INT 0
112380: ST_TO_ADDR
// f_murder := false ;
112381: LD_ADDR_VAR 0 20
112385: PUSH
112386: LD_INT 0
112388: ST_TO_ADDR
// f_mines := false ;
112389: LD_ADDR_VAR 0 21
112393: PUSH
112394: LD_INT 0
112396: ST_TO_ADDR
// f_repair := false ;
112397: LD_ADDR_VAR 0 22
112401: PUSH
112402: LD_INT 0
112404: ST_TO_ADDR
// f_heal := false ;
112405: LD_ADDR_VAR 0 23
112409: PUSH
112410: LD_INT 0
112412: ST_TO_ADDR
// f_spacetime := false ;
112413: LD_ADDR_VAR 0 24
112417: PUSH
112418: LD_INT 0
112420: ST_TO_ADDR
// f_attack_depot := false ;
112421: LD_ADDR_VAR 0 25
112425: PUSH
112426: LD_INT 0
112428: ST_TO_ADDR
// f_crawl := false ;
112429: LD_ADDR_VAR 0 26
112433: PUSH
112434: LD_INT 0
112436: ST_TO_ADDR
// end ; if f_heal then
112437: LD_VAR 0 23
112441: IFFALSE 112468
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112443: LD_ADDR_VAR 0 31
112447: PUSH
112448: LD_VAR 0 4
112452: PPUSH
112453: LD_INT 25
112455: PUSH
112456: LD_INT 4
112458: PUSH
112459: EMPTY
112460: LIST
112461: LIST
112462: PPUSH
112463: CALL_OW 72
112467: ST_TO_ADDR
// if f_repair then
112468: LD_VAR 0 22
112472: IFFALSE 112499
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112474: LD_ADDR_VAR 0 33
112478: PUSH
112479: LD_VAR 0 4
112483: PPUSH
112484: LD_INT 25
112486: PUSH
112487: LD_INT 3
112489: PUSH
112490: EMPTY
112491: LIST
112492: LIST
112493: PPUSH
112494: CALL_OW 72
112498: ST_TO_ADDR
// units_path := [ ] ;
112499: LD_ADDR_VAR 0 16
112503: PUSH
112504: EMPTY
112505: ST_TO_ADDR
// for i = 1 to group do
112506: LD_ADDR_VAR 0 7
112510: PUSH
112511: DOUBLE
112512: LD_INT 1
112514: DEC
112515: ST_TO_ADDR
112516: LD_VAR 0 4
112520: PUSH
112521: FOR_TO
112522: IFFALSE 112551
// units_path := Replace ( units_path , i , path ) ;
112524: LD_ADDR_VAR 0 16
112528: PUSH
112529: LD_VAR 0 16
112533: PPUSH
112534: LD_VAR 0 7
112538: PPUSH
112539: LD_VAR 0 5
112543: PPUSH
112544: CALL_OW 1
112548: ST_TO_ADDR
112549: GO 112521
112551: POP
112552: POP
// repeat for i = group downto 1 do
112553: LD_ADDR_VAR 0 7
112557: PUSH
112558: DOUBLE
112559: LD_VAR 0 4
112563: INC
112564: ST_TO_ADDR
112565: LD_INT 1
112567: PUSH
112568: FOR_DOWNTO
112569: IFFALSE 116691
// begin wait ( 5 ) ;
112571: LD_INT 5
112573: PPUSH
112574: CALL_OW 67
// tmp := [ ] ;
112578: LD_ADDR_VAR 0 14
112582: PUSH
112583: EMPTY
112584: ST_TO_ADDR
// attacking := false ;
112585: LD_ADDR_VAR 0 29
112589: PUSH
112590: LD_INT 0
112592: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112593: LD_VAR 0 4
112597: PUSH
112598: LD_VAR 0 7
112602: ARRAY
112603: PPUSH
112604: CALL_OW 301
112608: PUSH
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: NOT
112620: OR
112621: IFFALSE 112730
// begin if GetType ( group [ i ] ) = unit_human then
112623: LD_VAR 0 4
112627: PUSH
112628: LD_VAR 0 7
112632: ARRAY
112633: PPUSH
112634: CALL_OW 247
112638: PUSH
112639: LD_INT 1
112641: EQUAL
112642: IFFALSE 112688
// begin to_heal := to_heal diff group [ i ] ;
112644: LD_ADDR_VAR 0 30
112648: PUSH
112649: LD_VAR 0 30
112653: PUSH
112654: LD_VAR 0 4
112658: PUSH
112659: LD_VAR 0 7
112663: ARRAY
112664: DIFF
112665: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112666: LD_ADDR_VAR 0 31
112670: PUSH
112671: LD_VAR 0 31
112675: PUSH
112676: LD_VAR 0 4
112680: PUSH
112681: LD_VAR 0 7
112685: ARRAY
112686: DIFF
112687: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112688: LD_ADDR_VAR 0 4
112692: PUSH
112693: LD_VAR 0 4
112697: PPUSH
112698: LD_VAR 0 7
112702: PPUSH
112703: CALL_OW 3
112707: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112708: LD_ADDR_VAR 0 16
112712: PUSH
112713: LD_VAR 0 16
112717: PPUSH
112718: LD_VAR 0 7
112722: PPUSH
112723: CALL_OW 3
112727: ST_TO_ADDR
// continue ;
112728: GO 112568
// end ; if f_repair then
112730: LD_VAR 0 22
112734: IFFALSE 113223
// begin if GetType ( group [ i ] ) = unit_vehicle then
112736: LD_VAR 0 4
112740: PUSH
112741: LD_VAR 0 7
112745: ARRAY
112746: PPUSH
112747: CALL_OW 247
112751: PUSH
112752: LD_INT 2
112754: EQUAL
112755: IFFALSE 112945
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112757: LD_VAR 0 4
112761: PUSH
112762: LD_VAR 0 7
112766: ARRAY
112767: PPUSH
112768: CALL_OW 256
112772: PUSH
112773: LD_INT 700
112775: LESS
112776: PUSH
112777: LD_VAR 0 4
112781: PUSH
112782: LD_VAR 0 7
112786: ARRAY
112787: PUSH
112788: LD_VAR 0 32
112792: IN
112793: NOT
112794: AND
112795: IFFALSE 112819
// to_repair := to_repair union group [ i ] ;
112797: LD_ADDR_VAR 0 32
112801: PUSH
112802: LD_VAR 0 32
112806: PUSH
112807: LD_VAR 0 4
112811: PUSH
112812: LD_VAR 0 7
112816: ARRAY
112817: UNION
112818: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112819: LD_VAR 0 4
112823: PUSH
112824: LD_VAR 0 7
112828: ARRAY
112829: PPUSH
112830: CALL_OW 256
112834: PUSH
112835: LD_INT 1000
112837: EQUAL
112838: PUSH
112839: LD_VAR 0 4
112843: PUSH
112844: LD_VAR 0 7
112848: ARRAY
112849: PUSH
112850: LD_VAR 0 32
112854: IN
112855: AND
112856: IFFALSE 112880
// to_repair := to_repair diff group [ i ] ;
112858: LD_ADDR_VAR 0 32
112862: PUSH
112863: LD_VAR 0 32
112867: PUSH
112868: LD_VAR 0 4
112872: PUSH
112873: LD_VAR 0 7
112877: ARRAY
112878: DIFF
112879: ST_TO_ADDR
// if group [ i ] in to_repair then
112880: LD_VAR 0 4
112884: PUSH
112885: LD_VAR 0 7
112889: ARRAY
112890: PUSH
112891: LD_VAR 0 32
112895: IN
112896: IFFALSE 112943
// begin if not IsInArea ( group [ i ] , f_repair ) then
112898: LD_VAR 0 4
112902: PUSH
112903: LD_VAR 0 7
112907: ARRAY
112908: PPUSH
112909: LD_VAR 0 22
112913: PPUSH
112914: CALL_OW 308
112918: NOT
112919: IFFALSE 112941
// ComMoveToArea ( group [ i ] , f_repair ) ;
112921: LD_VAR 0 4
112925: PUSH
112926: LD_VAR 0 7
112930: ARRAY
112931: PPUSH
112932: LD_VAR 0 22
112936: PPUSH
112937: CALL_OW 113
// continue ;
112941: GO 112568
// end ; end else
112943: GO 113223
// if group [ i ] in repairs then
112945: LD_VAR 0 4
112949: PUSH
112950: LD_VAR 0 7
112954: ARRAY
112955: PUSH
112956: LD_VAR 0 33
112960: IN
112961: IFFALSE 113223
// begin if IsInUnit ( group [ i ] ) then
112963: LD_VAR 0 4
112967: PUSH
112968: LD_VAR 0 7
112972: ARRAY
112973: PPUSH
112974: CALL_OW 310
112978: IFFALSE 113046
// begin z := IsInUnit ( group [ i ] ) ;
112980: LD_ADDR_VAR 0 13
112984: PUSH
112985: LD_VAR 0 4
112989: PUSH
112990: LD_VAR 0 7
112994: ARRAY
112995: PPUSH
112996: CALL_OW 310
113000: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113001: LD_VAR 0 13
113005: PUSH
113006: LD_VAR 0 32
113010: IN
113011: PUSH
113012: LD_VAR 0 13
113016: PPUSH
113017: LD_VAR 0 22
113021: PPUSH
113022: CALL_OW 308
113026: AND
113027: IFFALSE 113044
// ComExitVehicle ( group [ i ] ) ;
113029: LD_VAR 0 4
113033: PUSH
113034: LD_VAR 0 7
113038: ARRAY
113039: PPUSH
113040: CALL_OW 121
// end else
113044: GO 113223
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113046: LD_ADDR_VAR 0 13
113050: PUSH
113051: LD_VAR 0 4
113055: PPUSH
113056: LD_INT 95
113058: PUSH
113059: LD_VAR 0 22
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: PUSH
113068: LD_INT 58
113070: PUSH
113071: EMPTY
113072: LIST
113073: PUSH
113074: EMPTY
113075: LIST
113076: LIST
113077: PPUSH
113078: CALL_OW 72
113082: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113083: LD_VAR 0 4
113087: PUSH
113088: LD_VAR 0 7
113092: ARRAY
113093: PPUSH
113094: CALL_OW 314
113098: NOT
113099: IFFALSE 113221
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113101: LD_ADDR_VAR 0 10
113105: PUSH
113106: LD_VAR 0 13
113110: PPUSH
113111: LD_VAR 0 4
113115: PUSH
113116: LD_VAR 0 7
113120: ARRAY
113121: PPUSH
113122: CALL_OW 74
113126: ST_TO_ADDR
// if not x then
113127: LD_VAR 0 10
113131: NOT
113132: IFFALSE 113136
// continue ;
113134: GO 112568
// if GetLives ( x ) < 1000 then
113136: LD_VAR 0 10
113140: PPUSH
113141: CALL_OW 256
113145: PUSH
113146: LD_INT 1000
113148: LESS
113149: IFFALSE 113173
// ComRepairVehicle ( group [ i ] , x ) else
113151: LD_VAR 0 4
113155: PUSH
113156: LD_VAR 0 7
113160: ARRAY
113161: PPUSH
113162: LD_VAR 0 10
113166: PPUSH
113167: CALL_OW 129
113171: GO 113221
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113173: LD_VAR 0 23
113177: PUSH
113178: LD_VAR 0 4
113182: PUSH
113183: LD_VAR 0 7
113187: ARRAY
113188: PPUSH
113189: CALL_OW 256
113193: PUSH
113194: LD_INT 1000
113196: LESS
113197: AND
113198: NOT
113199: IFFALSE 113221
// ComEnterUnit ( group [ i ] , x ) ;
113201: LD_VAR 0 4
113205: PUSH
113206: LD_VAR 0 7
113210: ARRAY
113211: PPUSH
113212: LD_VAR 0 10
113216: PPUSH
113217: CALL_OW 120
// end ; continue ;
113221: GO 112568
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113223: LD_VAR 0 23
113227: PUSH
113228: LD_VAR 0 4
113232: PUSH
113233: LD_VAR 0 7
113237: ARRAY
113238: PPUSH
113239: CALL_OW 247
113243: PUSH
113244: LD_INT 1
113246: EQUAL
113247: AND
113248: IFFALSE 113726
// begin if group [ i ] in healers then
113250: LD_VAR 0 4
113254: PUSH
113255: LD_VAR 0 7
113259: ARRAY
113260: PUSH
113261: LD_VAR 0 31
113265: IN
113266: IFFALSE 113539
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113268: LD_VAR 0 4
113272: PUSH
113273: LD_VAR 0 7
113277: ARRAY
113278: PPUSH
113279: LD_VAR 0 23
113283: PPUSH
113284: CALL_OW 308
113288: NOT
113289: PUSH
113290: LD_VAR 0 4
113294: PUSH
113295: LD_VAR 0 7
113299: ARRAY
113300: PPUSH
113301: CALL_OW 314
113305: NOT
113306: AND
113307: IFFALSE 113331
// ComMoveToArea ( group [ i ] , f_heal ) else
113309: LD_VAR 0 4
113313: PUSH
113314: LD_VAR 0 7
113318: ARRAY
113319: PPUSH
113320: LD_VAR 0 23
113324: PPUSH
113325: CALL_OW 113
113329: GO 113537
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113331: LD_VAR 0 4
113335: PUSH
113336: LD_VAR 0 7
113340: ARRAY
113341: PPUSH
113342: CALL 52388 0 1
113346: PPUSH
113347: CALL_OW 256
113351: PUSH
113352: LD_INT 1000
113354: EQUAL
113355: IFFALSE 113374
// ComStop ( group [ i ] ) else
113357: LD_VAR 0 4
113361: PUSH
113362: LD_VAR 0 7
113366: ARRAY
113367: PPUSH
113368: CALL_OW 141
113372: GO 113537
// if not HasTask ( group [ i ] ) and to_heal then
113374: LD_VAR 0 4
113378: PUSH
113379: LD_VAR 0 7
113383: ARRAY
113384: PPUSH
113385: CALL_OW 314
113389: NOT
113390: PUSH
113391: LD_VAR 0 30
113395: AND
113396: IFFALSE 113537
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113398: LD_ADDR_VAR 0 13
113402: PUSH
113403: LD_VAR 0 30
113407: PPUSH
113408: LD_INT 3
113410: PUSH
113411: LD_INT 54
113413: PUSH
113414: EMPTY
113415: LIST
113416: PUSH
113417: EMPTY
113418: LIST
113419: LIST
113420: PPUSH
113421: CALL_OW 72
113425: PPUSH
113426: LD_VAR 0 4
113430: PUSH
113431: LD_VAR 0 7
113435: ARRAY
113436: PPUSH
113437: CALL_OW 74
113441: ST_TO_ADDR
// if z then
113442: LD_VAR 0 13
113446: IFFALSE 113537
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113448: LD_INT 91
113450: PUSH
113451: LD_VAR 0 13
113455: PUSH
113456: LD_INT 10
113458: PUSH
113459: EMPTY
113460: LIST
113461: LIST
113462: LIST
113463: PUSH
113464: LD_INT 81
113466: PUSH
113467: LD_VAR 0 13
113471: PPUSH
113472: CALL_OW 255
113476: PUSH
113477: EMPTY
113478: LIST
113479: LIST
113480: PUSH
113481: EMPTY
113482: LIST
113483: LIST
113484: PPUSH
113485: CALL_OW 69
113489: PUSH
113490: LD_INT 0
113492: EQUAL
113493: IFFALSE 113517
// ComHeal ( group [ i ] , z ) else
113495: LD_VAR 0 4
113499: PUSH
113500: LD_VAR 0 7
113504: ARRAY
113505: PPUSH
113506: LD_VAR 0 13
113510: PPUSH
113511: CALL_OW 128
113515: GO 113537
// ComMoveToArea ( group [ i ] , f_heal ) ;
113517: LD_VAR 0 4
113521: PUSH
113522: LD_VAR 0 7
113526: ARRAY
113527: PPUSH
113528: LD_VAR 0 23
113532: PPUSH
113533: CALL_OW 113
// end ; continue ;
113537: GO 112568
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113539: LD_VAR 0 4
113543: PUSH
113544: LD_VAR 0 7
113548: ARRAY
113549: PPUSH
113550: CALL_OW 256
113554: PUSH
113555: LD_INT 700
113557: LESS
113558: PUSH
113559: LD_VAR 0 4
113563: PUSH
113564: LD_VAR 0 7
113568: ARRAY
113569: PUSH
113570: LD_VAR 0 30
113574: IN
113575: NOT
113576: AND
113577: IFFALSE 113601
// to_heal := to_heal union group [ i ] ;
113579: LD_ADDR_VAR 0 30
113583: PUSH
113584: LD_VAR 0 30
113588: PUSH
113589: LD_VAR 0 4
113593: PUSH
113594: LD_VAR 0 7
113598: ARRAY
113599: UNION
113600: ST_TO_ADDR
// if group [ i ] in to_heal then
113601: LD_VAR 0 4
113605: PUSH
113606: LD_VAR 0 7
113610: ARRAY
113611: PUSH
113612: LD_VAR 0 30
113616: IN
113617: IFFALSE 113726
// begin if GetLives ( group [ i ] ) = 1000 then
113619: LD_VAR 0 4
113623: PUSH
113624: LD_VAR 0 7
113628: ARRAY
113629: PPUSH
113630: CALL_OW 256
113634: PUSH
113635: LD_INT 1000
113637: EQUAL
113638: IFFALSE 113664
// to_heal := to_heal diff group [ i ] else
113640: LD_ADDR_VAR 0 30
113644: PUSH
113645: LD_VAR 0 30
113649: PUSH
113650: LD_VAR 0 4
113654: PUSH
113655: LD_VAR 0 7
113659: ARRAY
113660: DIFF
113661: ST_TO_ADDR
113662: GO 113726
// begin if not IsInArea ( group [ i ] , to_heal ) then
113664: LD_VAR 0 4
113668: PUSH
113669: LD_VAR 0 7
113673: ARRAY
113674: PPUSH
113675: LD_VAR 0 30
113679: PPUSH
113680: CALL_OW 308
113684: NOT
113685: IFFALSE 113709
// ComMoveToArea ( group [ i ] , f_heal ) else
113687: LD_VAR 0 4
113691: PUSH
113692: LD_VAR 0 7
113696: ARRAY
113697: PPUSH
113698: LD_VAR 0 23
113702: PPUSH
113703: CALL_OW 113
113707: GO 113724
// ComHold ( group [ i ] ) ;
113709: LD_VAR 0 4
113713: PUSH
113714: LD_VAR 0 7
113718: ARRAY
113719: PPUSH
113720: CALL_OW 140
// continue ;
113724: GO 112568
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113726: LD_VAR 0 4
113730: PUSH
113731: LD_VAR 0 7
113735: ARRAY
113736: PPUSH
113737: LD_INT 10
113739: PPUSH
113740: CALL 50150 0 2
113744: NOT
113745: PUSH
113746: LD_VAR 0 16
113750: PUSH
113751: LD_VAR 0 7
113755: ARRAY
113756: PUSH
113757: EMPTY
113758: EQUAL
113759: NOT
113760: AND
113761: IFFALSE 114027
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113763: LD_VAR 0 4
113767: PUSH
113768: LD_VAR 0 7
113772: ARRAY
113773: PPUSH
113774: CALL_OW 262
113778: PUSH
113779: LD_INT 1
113781: PUSH
113782: LD_INT 2
113784: PUSH
113785: EMPTY
113786: LIST
113787: LIST
113788: IN
113789: IFFALSE 113830
// if GetFuel ( group [ i ] ) < 10 then
113791: LD_VAR 0 4
113795: PUSH
113796: LD_VAR 0 7
113800: ARRAY
113801: PPUSH
113802: CALL_OW 261
113806: PUSH
113807: LD_INT 10
113809: LESS
113810: IFFALSE 113830
// SetFuel ( group [ i ] , 12 ) ;
113812: LD_VAR 0 4
113816: PUSH
113817: LD_VAR 0 7
113821: ARRAY
113822: PPUSH
113823: LD_INT 12
113825: PPUSH
113826: CALL_OW 240
// if units_path [ i ] then
113830: LD_VAR 0 16
113834: PUSH
113835: LD_VAR 0 7
113839: ARRAY
113840: IFFALSE 114025
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113842: LD_VAR 0 4
113846: PUSH
113847: LD_VAR 0 7
113851: ARRAY
113852: PPUSH
113853: LD_VAR 0 16
113857: PUSH
113858: LD_VAR 0 7
113862: ARRAY
113863: PUSH
113864: LD_INT 1
113866: ARRAY
113867: PUSH
113868: LD_INT 1
113870: ARRAY
113871: PPUSH
113872: LD_VAR 0 16
113876: PUSH
113877: LD_VAR 0 7
113881: ARRAY
113882: PUSH
113883: LD_INT 1
113885: ARRAY
113886: PUSH
113887: LD_INT 2
113889: ARRAY
113890: PPUSH
113891: CALL_OW 297
113895: PUSH
113896: LD_INT 6
113898: GREATER
113899: IFFALSE 113974
// begin if not HasTask ( group [ i ] ) then
113901: LD_VAR 0 4
113905: PUSH
113906: LD_VAR 0 7
113910: ARRAY
113911: PPUSH
113912: CALL_OW 314
113916: NOT
113917: IFFALSE 113972
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
113919: LD_VAR 0 4
113923: PUSH
113924: LD_VAR 0 7
113928: ARRAY
113929: PPUSH
113930: LD_VAR 0 16
113934: PUSH
113935: LD_VAR 0 7
113939: ARRAY
113940: PUSH
113941: LD_INT 1
113943: ARRAY
113944: PUSH
113945: LD_INT 1
113947: ARRAY
113948: PPUSH
113949: LD_VAR 0 16
113953: PUSH
113954: LD_VAR 0 7
113958: ARRAY
113959: PUSH
113960: LD_INT 1
113962: ARRAY
113963: PUSH
113964: LD_INT 2
113966: ARRAY
113967: PPUSH
113968: CALL_OW 114
// end else
113972: GO 114025
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113974: LD_ADDR_VAR 0 15
113978: PUSH
113979: LD_VAR 0 16
113983: PUSH
113984: LD_VAR 0 7
113988: ARRAY
113989: PPUSH
113990: LD_INT 1
113992: PPUSH
113993: CALL_OW 3
113997: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113998: LD_ADDR_VAR 0 16
114002: PUSH
114003: LD_VAR 0 16
114007: PPUSH
114008: LD_VAR 0 7
114012: PPUSH
114013: LD_VAR 0 15
114017: PPUSH
114018: CALL_OW 1
114022: ST_TO_ADDR
// continue ;
114023: GO 112568
// end ; end ; end else
114025: GO 116689
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114027: LD_ADDR_VAR 0 14
114031: PUSH
114032: LD_INT 81
114034: PUSH
114035: LD_VAR 0 4
114039: PUSH
114040: LD_VAR 0 7
114044: ARRAY
114045: PPUSH
114046: CALL_OW 255
114050: PUSH
114051: EMPTY
114052: LIST
114053: LIST
114054: PPUSH
114055: CALL_OW 69
114059: ST_TO_ADDR
// if not tmp then
114060: LD_VAR 0 14
114064: NOT
114065: IFFALSE 114069
// continue ;
114067: GO 112568
// if f_ignore_area then
114069: LD_VAR 0 17
114073: IFFALSE 114161
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114075: LD_ADDR_VAR 0 15
114079: PUSH
114080: LD_VAR 0 14
114084: PPUSH
114085: LD_INT 3
114087: PUSH
114088: LD_INT 92
114090: PUSH
114091: LD_VAR 0 17
114095: PUSH
114096: LD_INT 1
114098: ARRAY
114099: PUSH
114100: LD_VAR 0 17
114104: PUSH
114105: LD_INT 2
114107: ARRAY
114108: PUSH
114109: LD_VAR 0 17
114113: PUSH
114114: LD_INT 3
114116: ARRAY
114117: PUSH
114118: EMPTY
114119: LIST
114120: LIST
114121: LIST
114122: LIST
114123: PUSH
114124: EMPTY
114125: LIST
114126: LIST
114127: PPUSH
114128: CALL_OW 72
114132: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114133: LD_VAR 0 14
114137: PUSH
114138: LD_VAR 0 15
114142: DIFF
114143: IFFALSE 114161
// tmp := tmp diff tmp2 ;
114145: LD_ADDR_VAR 0 14
114149: PUSH
114150: LD_VAR 0 14
114154: PUSH
114155: LD_VAR 0 15
114159: DIFF
114160: ST_TO_ADDR
// end ; if not f_murder then
114161: LD_VAR 0 20
114165: NOT
114166: IFFALSE 114224
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114168: LD_ADDR_VAR 0 15
114172: PUSH
114173: LD_VAR 0 14
114177: PPUSH
114178: LD_INT 3
114180: PUSH
114181: LD_INT 50
114183: PUSH
114184: EMPTY
114185: LIST
114186: PUSH
114187: EMPTY
114188: LIST
114189: LIST
114190: PPUSH
114191: CALL_OW 72
114195: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114196: LD_VAR 0 14
114200: PUSH
114201: LD_VAR 0 15
114205: DIFF
114206: IFFALSE 114224
// tmp := tmp diff tmp2 ;
114208: LD_ADDR_VAR 0 14
114212: PUSH
114213: LD_VAR 0 14
114217: PUSH
114218: LD_VAR 0 15
114222: DIFF
114223: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114224: LD_ADDR_VAR 0 14
114228: PUSH
114229: LD_VAR 0 4
114233: PUSH
114234: LD_VAR 0 7
114238: ARRAY
114239: PPUSH
114240: LD_VAR 0 14
114244: PPUSH
114245: LD_INT 1
114247: PPUSH
114248: LD_INT 1
114250: PPUSH
114251: CALL 22694 0 4
114255: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114256: LD_VAR 0 4
114260: PUSH
114261: LD_VAR 0 7
114265: ARRAY
114266: PPUSH
114267: CALL_OW 257
114271: PUSH
114272: LD_INT 1
114274: EQUAL
114275: IFFALSE 114723
// begin if WantPlant ( group [ i ] ) then
114277: LD_VAR 0 4
114281: PUSH
114282: LD_VAR 0 7
114286: ARRAY
114287: PPUSH
114288: CALL 22195 0 1
114292: IFFALSE 114296
// continue ;
114294: GO 112568
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114296: LD_VAR 0 18
114300: PUSH
114301: LD_VAR 0 4
114305: PUSH
114306: LD_VAR 0 7
114310: ARRAY
114311: PPUSH
114312: CALL_OW 310
114316: NOT
114317: AND
114318: PUSH
114319: LD_VAR 0 14
114323: PUSH
114324: LD_INT 1
114326: ARRAY
114327: PUSH
114328: LD_VAR 0 14
114332: PPUSH
114333: LD_INT 21
114335: PUSH
114336: LD_INT 2
114338: PUSH
114339: EMPTY
114340: LIST
114341: LIST
114342: PUSH
114343: LD_INT 58
114345: PUSH
114346: EMPTY
114347: LIST
114348: PUSH
114349: EMPTY
114350: LIST
114351: LIST
114352: PPUSH
114353: CALL_OW 72
114357: IN
114358: AND
114359: IFFALSE 114395
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114361: LD_VAR 0 4
114365: PUSH
114366: LD_VAR 0 7
114370: ARRAY
114371: PPUSH
114372: LD_VAR 0 14
114376: PUSH
114377: LD_INT 1
114379: ARRAY
114380: PPUSH
114381: CALL_OW 120
// attacking := true ;
114385: LD_ADDR_VAR 0 29
114389: PUSH
114390: LD_INT 1
114392: ST_TO_ADDR
// continue ;
114393: GO 112568
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114395: LD_VAR 0 26
114399: PUSH
114400: LD_VAR 0 4
114404: PUSH
114405: LD_VAR 0 7
114409: ARRAY
114410: PPUSH
114411: CALL_OW 257
114415: PUSH
114416: LD_INT 1
114418: EQUAL
114419: AND
114420: PUSH
114421: LD_VAR 0 4
114425: PUSH
114426: LD_VAR 0 7
114430: ARRAY
114431: PPUSH
114432: CALL_OW 256
114436: PUSH
114437: LD_INT 800
114439: LESS
114440: AND
114441: PUSH
114442: LD_VAR 0 4
114446: PUSH
114447: LD_VAR 0 7
114451: ARRAY
114452: PPUSH
114453: CALL_OW 318
114457: NOT
114458: AND
114459: IFFALSE 114476
// ComCrawl ( group [ i ] ) ;
114461: LD_VAR 0 4
114465: PUSH
114466: LD_VAR 0 7
114470: ARRAY
114471: PPUSH
114472: CALL_OW 137
// if f_mines then
114476: LD_VAR 0 21
114480: IFFALSE 114723
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114482: LD_VAR 0 14
114486: PUSH
114487: LD_INT 1
114489: ARRAY
114490: PPUSH
114491: CALL_OW 247
114495: PUSH
114496: LD_INT 3
114498: EQUAL
114499: PUSH
114500: LD_VAR 0 14
114504: PUSH
114505: LD_INT 1
114507: ARRAY
114508: PUSH
114509: LD_VAR 0 27
114513: IN
114514: NOT
114515: AND
114516: IFFALSE 114723
// begin x := GetX ( tmp [ 1 ] ) ;
114518: LD_ADDR_VAR 0 10
114522: PUSH
114523: LD_VAR 0 14
114527: PUSH
114528: LD_INT 1
114530: ARRAY
114531: PPUSH
114532: CALL_OW 250
114536: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114537: LD_ADDR_VAR 0 11
114541: PUSH
114542: LD_VAR 0 14
114546: PUSH
114547: LD_INT 1
114549: ARRAY
114550: PPUSH
114551: CALL_OW 251
114555: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114556: LD_ADDR_VAR 0 12
114560: PUSH
114561: LD_VAR 0 4
114565: PUSH
114566: LD_VAR 0 7
114570: ARRAY
114571: PPUSH
114572: CALL 50235 0 1
114576: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114577: LD_VAR 0 4
114581: PUSH
114582: LD_VAR 0 7
114586: ARRAY
114587: PPUSH
114588: LD_VAR 0 10
114592: PPUSH
114593: LD_VAR 0 11
114597: PPUSH
114598: LD_VAR 0 14
114602: PUSH
114603: LD_INT 1
114605: ARRAY
114606: PPUSH
114607: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114611: LD_VAR 0 4
114615: PUSH
114616: LD_VAR 0 7
114620: ARRAY
114621: PPUSH
114622: LD_VAR 0 10
114626: PPUSH
114627: LD_VAR 0 12
114631: PPUSH
114632: LD_INT 7
114634: PPUSH
114635: CALL_OW 272
114639: PPUSH
114640: LD_VAR 0 11
114644: PPUSH
114645: LD_VAR 0 12
114649: PPUSH
114650: LD_INT 7
114652: PPUSH
114653: CALL_OW 273
114657: PPUSH
114658: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114662: LD_VAR 0 4
114666: PUSH
114667: LD_VAR 0 7
114671: ARRAY
114672: PPUSH
114673: LD_INT 71
114675: PPUSH
114676: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114680: LD_ADDR_VAR 0 27
114684: PUSH
114685: LD_VAR 0 27
114689: PPUSH
114690: LD_VAR 0 27
114694: PUSH
114695: LD_INT 1
114697: PLUS
114698: PPUSH
114699: LD_VAR 0 14
114703: PUSH
114704: LD_INT 1
114706: ARRAY
114707: PPUSH
114708: CALL_OW 1
114712: ST_TO_ADDR
// attacking := true ;
114713: LD_ADDR_VAR 0 29
114717: PUSH
114718: LD_INT 1
114720: ST_TO_ADDR
// continue ;
114721: GO 112568
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114723: LD_VAR 0 4
114727: PUSH
114728: LD_VAR 0 7
114732: ARRAY
114733: PPUSH
114734: CALL_OW 257
114738: PUSH
114739: LD_INT 17
114741: EQUAL
114742: PUSH
114743: LD_VAR 0 4
114747: PUSH
114748: LD_VAR 0 7
114752: ARRAY
114753: PPUSH
114754: CALL_OW 110
114758: PUSH
114759: LD_INT 71
114761: EQUAL
114762: NOT
114763: AND
114764: IFFALSE 114910
// begin attacking := false ;
114766: LD_ADDR_VAR 0 29
114770: PUSH
114771: LD_INT 0
114773: ST_TO_ADDR
// k := 5 ;
114774: LD_ADDR_VAR 0 9
114778: PUSH
114779: LD_INT 5
114781: ST_TO_ADDR
// if tmp < k then
114782: LD_VAR 0 14
114786: PUSH
114787: LD_VAR 0 9
114791: LESS
114792: IFFALSE 114804
// k := tmp ;
114794: LD_ADDR_VAR 0 9
114798: PUSH
114799: LD_VAR 0 14
114803: ST_TO_ADDR
// for j = 1 to k do
114804: LD_ADDR_VAR 0 8
114808: PUSH
114809: DOUBLE
114810: LD_INT 1
114812: DEC
114813: ST_TO_ADDR
114814: LD_VAR 0 9
114818: PUSH
114819: FOR_TO
114820: IFFALSE 114908
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114822: LD_VAR 0 14
114826: PUSH
114827: LD_VAR 0 8
114831: ARRAY
114832: PUSH
114833: LD_VAR 0 14
114837: PPUSH
114838: LD_INT 58
114840: PUSH
114841: EMPTY
114842: LIST
114843: PPUSH
114844: CALL_OW 72
114848: IN
114849: NOT
114850: IFFALSE 114906
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114852: LD_VAR 0 4
114856: PUSH
114857: LD_VAR 0 7
114861: ARRAY
114862: PPUSH
114863: LD_VAR 0 14
114867: PUSH
114868: LD_VAR 0 8
114872: ARRAY
114873: PPUSH
114874: CALL_OW 115
// attacking := true ;
114878: LD_ADDR_VAR 0 29
114882: PUSH
114883: LD_INT 1
114885: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
114886: LD_VAR 0 4
114890: PUSH
114891: LD_VAR 0 7
114895: ARRAY
114896: PPUSH
114897: LD_INT 71
114899: PPUSH
114900: CALL_OW 109
// continue ;
114904: GO 114819
// end ; end ;
114906: GO 114819
114908: POP
114909: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
114910: LD_VAR 0 4
114914: PUSH
114915: LD_VAR 0 7
114919: ARRAY
114920: PPUSH
114921: CALL_OW 257
114925: PUSH
114926: LD_INT 8
114928: EQUAL
114929: PUSH
114930: LD_VAR 0 4
114934: PUSH
114935: LD_VAR 0 7
114939: ARRAY
114940: PPUSH
114941: CALL_OW 264
114945: PUSH
114946: LD_INT 28
114948: PUSH
114949: LD_INT 45
114951: PUSH
114952: LD_INT 7
114954: PUSH
114955: LD_INT 47
114957: PUSH
114958: EMPTY
114959: LIST
114960: LIST
114961: LIST
114962: LIST
114963: IN
114964: OR
114965: IFFALSE 115221
// begin attacking := false ;
114967: LD_ADDR_VAR 0 29
114971: PUSH
114972: LD_INT 0
114974: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114975: LD_VAR 0 14
114979: PUSH
114980: LD_INT 1
114982: ARRAY
114983: PPUSH
114984: CALL_OW 266
114988: PUSH
114989: LD_INT 32
114991: PUSH
114992: LD_INT 31
114994: PUSH
114995: LD_INT 33
114997: PUSH
114998: LD_INT 4
115000: PUSH
115001: LD_INT 5
115003: PUSH
115004: EMPTY
115005: LIST
115006: LIST
115007: LIST
115008: LIST
115009: LIST
115010: IN
115011: IFFALSE 115197
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115013: LD_ADDR_VAR 0 9
115017: PUSH
115018: LD_VAR 0 14
115022: PUSH
115023: LD_INT 1
115025: ARRAY
115026: PPUSH
115027: CALL_OW 266
115031: PPUSH
115032: LD_VAR 0 14
115036: PUSH
115037: LD_INT 1
115039: ARRAY
115040: PPUSH
115041: CALL_OW 250
115045: PPUSH
115046: LD_VAR 0 14
115050: PUSH
115051: LD_INT 1
115053: ARRAY
115054: PPUSH
115055: CALL_OW 251
115059: PPUSH
115060: LD_VAR 0 14
115064: PUSH
115065: LD_INT 1
115067: ARRAY
115068: PPUSH
115069: CALL_OW 254
115073: PPUSH
115074: LD_VAR 0 14
115078: PUSH
115079: LD_INT 1
115081: ARRAY
115082: PPUSH
115083: CALL_OW 248
115087: PPUSH
115088: LD_INT 0
115090: PPUSH
115091: CALL 31605 0 6
115095: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115096: LD_ADDR_VAR 0 8
115100: PUSH
115101: LD_VAR 0 4
115105: PUSH
115106: LD_VAR 0 7
115110: ARRAY
115111: PPUSH
115112: LD_VAR 0 9
115116: PPUSH
115117: CALL 50348 0 2
115121: ST_TO_ADDR
// if j then
115122: LD_VAR 0 8
115126: IFFALSE 115195
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115128: LD_VAR 0 8
115132: PUSH
115133: LD_INT 1
115135: ARRAY
115136: PPUSH
115137: LD_VAR 0 8
115141: PUSH
115142: LD_INT 2
115144: ARRAY
115145: PPUSH
115146: CALL_OW 488
115150: IFFALSE 115195
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115152: LD_VAR 0 4
115156: PUSH
115157: LD_VAR 0 7
115161: ARRAY
115162: PPUSH
115163: LD_VAR 0 8
115167: PUSH
115168: LD_INT 1
115170: ARRAY
115171: PPUSH
115172: LD_VAR 0 8
115176: PUSH
115177: LD_INT 2
115179: ARRAY
115180: PPUSH
115181: CALL_OW 116
// attacking := true ;
115185: LD_ADDR_VAR 0 29
115189: PUSH
115190: LD_INT 1
115192: ST_TO_ADDR
// continue ;
115193: GO 112568
// end ; end else
115195: GO 115221
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115197: LD_VAR 0 4
115201: PUSH
115202: LD_VAR 0 7
115206: ARRAY
115207: PPUSH
115208: LD_VAR 0 14
115212: PUSH
115213: LD_INT 1
115215: ARRAY
115216: PPUSH
115217: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115221: LD_VAR 0 4
115225: PUSH
115226: LD_VAR 0 7
115230: ARRAY
115231: PPUSH
115232: CALL_OW 265
115236: PUSH
115237: LD_INT 11
115239: EQUAL
115240: IFFALSE 115518
// begin k := 10 ;
115242: LD_ADDR_VAR 0 9
115246: PUSH
115247: LD_INT 10
115249: ST_TO_ADDR
// x := 0 ;
115250: LD_ADDR_VAR 0 10
115254: PUSH
115255: LD_INT 0
115257: ST_TO_ADDR
// if tmp < k then
115258: LD_VAR 0 14
115262: PUSH
115263: LD_VAR 0 9
115267: LESS
115268: IFFALSE 115280
// k := tmp ;
115270: LD_ADDR_VAR 0 9
115274: PUSH
115275: LD_VAR 0 14
115279: ST_TO_ADDR
// for j = k downto 1 do
115280: LD_ADDR_VAR 0 8
115284: PUSH
115285: DOUBLE
115286: LD_VAR 0 9
115290: INC
115291: ST_TO_ADDR
115292: LD_INT 1
115294: PUSH
115295: FOR_DOWNTO
115296: IFFALSE 115371
// begin if GetType ( tmp [ j ] ) = unit_human then
115298: LD_VAR 0 14
115302: PUSH
115303: LD_VAR 0 8
115307: ARRAY
115308: PPUSH
115309: CALL_OW 247
115313: PUSH
115314: LD_INT 1
115316: EQUAL
115317: IFFALSE 115369
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115319: LD_VAR 0 4
115323: PUSH
115324: LD_VAR 0 7
115328: ARRAY
115329: PPUSH
115330: LD_VAR 0 14
115334: PUSH
115335: LD_VAR 0 8
115339: ARRAY
115340: PPUSH
115341: CALL 50602 0 2
// x := tmp [ j ] ;
115345: LD_ADDR_VAR 0 10
115349: PUSH
115350: LD_VAR 0 14
115354: PUSH
115355: LD_VAR 0 8
115359: ARRAY
115360: ST_TO_ADDR
// attacking := true ;
115361: LD_ADDR_VAR 0 29
115365: PUSH
115366: LD_INT 1
115368: ST_TO_ADDR
// end ; end ;
115369: GO 115295
115371: POP
115372: POP
// if not x then
115373: LD_VAR 0 10
115377: NOT
115378: IFFALSE 115518
// begin attacking := true ;
115380: LD_ADDR_VAR 0 29
115384: PUSH
115385: LD_INT 1
115387: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115388: LD_VAR 0 4
115392: PUSH
115393: LD_VAR 0 7
115397: ARRAY
115398: PPUSH
115399: CALL_OW 250
115403: PPUSH
115404: LD_VAR 0 4
115408: PUSH
115409: LD_VAR 0 7
115413: ARRAY
115414: PPUSH
115415: CALL_OW 251
115419: PPUSH
115420: CALL_OW 546
115424: PUSH
115425: LD_INT 2
115427: ARRAY
115428: PUSH
115429: LD_VAR 0 14
115433: PUSH
115434: LD_INT 1
115436: ARRAY
115437: PPUSH
115438: CALL_OW 250
115442: PPUSH
115443: LD_VAR 0 14
115447: PUSH
115448: LD_INT 1
115450: ARRAY
115451: PPUSH
115452: CALL_OW 251
115456: PPUSH
115457: CALL_OW 546
115461: PUSH
115462: LD_INT 2
115464: ARRAY
115465: EQUAL
115466: IFFALSE 115494
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115468: LD_VAR 0 4
115472: PUSH
115473: LD_VAR 0 7
115477: ARRAY
115478: PPUSH
115479: LD_VAR 0 14
115483: PUSH
115484: LD_INT 1
115486: ARRAY
115487: PPUSH
115488: CALL 50602 0 2
115492: GO 115518
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115494: LD_VAR 0 4
115498: PUSH
115499: LD_VAR 0 7
115503: ARRAY
115504: PPUSH
115505: LD_VAR 0 14
115509: PUSH
115510: LD_INT 1
115512: ARRAY
115513: PPUSH
115514: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115518: LD_VAR 0 4
115522: PUSH
115523: LD_VAR 0 7
115527: ARRAY
115528: PPUSH
115529: CALL_OW 264
115533: PUSH
115534: LD_INT 29
115536: EQUAL
115537: IFFALSE 115903
// begin if WantsToAttack ( group [ i ] ) in bombed then
115539: LD_VAR 0 4
115543: PUSH
115544: LD_VAR 0 7
115548: ARRAY
115549: PPUSH
115550: CALL_OW 319
115554: PUSH
115555: LD_VAR 0 28
115559: IN
115560: IFFALSE 115564
// continue ;
115562: GO 112568
// k := 8 ;
115564: LD_ADDR_VAR 0 9
115568: PUSH
115569: LD_INT 8
115571: ST_TO_ADDR
// x := 0 ;
115572: LD_ADDR_VAR 0 10
115576: PUSH
115577: LD_INT 0
115579: ST_TO_ADDR
// if tmp < k then
115580: LD_VAR 0 14
115584: PUSH
115585: LD_VAR 0 9
115589: LESS
115590: IFFALSE 115602
// k := tmp ;
115592: LD_ADDR_VAR 0 9
115596: PUSH
115597: LD_VAR 0 14
115601: ST_TO_ADDR
// for j = 1 to k do
115602: LD_ADDR_VAR 0 8
115606: PUSH
115607: DOUBLE
115608: LD_INT 1
115610: DEC
115611: ST_TO_ADDR
115612: LD_VAR 0 9
115616: PUSH
115617: FOR_TO
115618: IFFALSE 115750
// begin if GetType ( tmp [ j ] ) = unit_building then
115620: LD_VAR 0 14
115624: PUSH
115625: LD_VAR 0 8
115629: ARRAY
115630: PPUSH
115631: CALL_OW 247
115635: PUSH
115636: LD_INT 3
115638: EQUAL
115639: IFFALSE 115748
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115641: LD_VAR 0 14
115645: PUSH
115646: LD_VAR 0 8
115650: ARRAY
115651: PUSH
115652: LD_VAR 0 28
115656: IN
115657: NOT
115658: PUSH
115659: LD_VAR 0 14
115663: PUSH
115664: LD_VAR 0 8
115668: ARRAY
115669: PPUSH
115670: CALL_OW 313
115674: AND
115675: IFFALSE 115748
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115677: LD_VAR 0 4
115681: PUSH
115682: LD_VAR 0 7
115686: ARRAY
115687: PPUSH
115688: LD_VAR 0 14
115692: PUSH
115693: LD_VAR 0 8
115697: ARRAY
115698: PPUSH
115699: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115703: LD_ADDR_VAR 0 28
115707: PUSH
115708: LD_VAR 0 28
115712: PPUSH
115713: LD_VAR 0 28
115717: PUSH
115718: LD_INT 1
115720: PLUS
115721: PPUSH
115722: LD_VAR 0 14
115726: PUSH
115727: LD_VAR 0 8
115731: ARRAY
115732: PPUSH
115733: CALL_OW 1
115737: ST_TO_ADDR
// attacking := true ;
115738: LD_ADDR_VAR 0 29
115742: PUSH
115743: LD_INT 1
115745: ST_TO_ADDR
// break ;
115746: GO 115750
// end ; end ;
115748: GO 115617
115750: POP
115751: POP
// if not attacking and f_attack_depot then
115752: LD_VAR 0 29
115756: NOT
115757: PUSH
115758: LD_VAR 0 25
115762: AND
115763: IFFALSE 115858
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115765: LD_ADDR_VAR 0 13
115769: PUSH
115770: LD_VAR 0 14
115774: PPUSH
115775: LD_INT 2
115777: PUSH
115778: LD_INT 30
115780: PUSH
115781: LD_INT 0
115783: PUSH
115784: EMPTY
115785: LIST
115786: LIST
115787: PUSH
115788: LD_INT 30
115790: PUSH
115791: LD_INT 1
115793: PUSH
115794: EMPTY
115795: LIST
115796: LIST
115797: PUSH
115798: EMPTY
115799: LIST
115800: LIST
115801: LIST
115802: PPUSH
115803: CALL_OW 72
115807: ST_TO_ADDR
// if z then
115808: LD_VAR 0 13
115812: IFFALSE 115858
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115814: LD_VAR 0 4
115818: PUSH
115819: LD_VAR 0 7
115823: ARRAY
115824: PPUSH
115825: LD_VAR 0 13
115829: PPUSH
115830: LD_VAR 0 4
115834: PUSH
115835: LD_VAR 0 7
115839: ARRAY
115840: PPUSH
115841: CALL_OW 74
115845: PPUSH
115846: CALL_OW 115
// attacking := true ;
115850: LD_ADDR_VAR 0 29
115854: PUSH
115855: LD_INT 1
115857: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
115858: LD_VAR 0 4
115862: PUSH
115863: LD_VAR 0 7
115867: ARRAY
115868: PPUSH
115869: CALL_OW 256
115873: PUSH
115874: LD_INT 500
115876: LESS
115877: IFFALSE 115903
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115879: LD_VAR 0 4
115883: PUSH
115884: LD_VAR 0 7
115888: ARRAY
115889: PPUSH
115890: LD_VAR 0 14
115894: PUSH
115895: LD_INT 1
115897: ARRAY
115898: PPUSH
115899: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
115903: LD_VAR 0 4
115907: PUSH
115908: LD_VAR 0 7
115912: ARRAY
115913: PPUSH
115914: CALL_OW 264
115918: PUSH
115919: LD_INT 49
115921: EQUAL
115922: IFFALSE 116043
// begin if not HasTask ( group [ i ] ) then
115924: LD_VAR 0 4
115928: PUSH
115929: LD_VAR 0 7
115933: ARRAY
115934: PPUSH
115935: CALL_OW 314
115939: NOT
115940: IFFALSE 116043
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
115942: LD_ADDR_VAR 0 9
115946: PUSH
115947: LD_INT 81
115949: PUSH
115950: LD_VAR 0 4
115954: PUSH
115955: LD_VAR 0 7
115959: ARRAY
115960: PPUSH
115961: CALL_OW 255
115965: PUSH
115966: EMPTY
115967: LIST
115968: LIST
115969: PPUSH
115970: CALL_OW 69
115974: PPUSH
115975: LD_VAR 0 4
115979: PUSH
115980: LD_VAR 0 7
115984: ARRAY
115985: PPUSH
115986: CALL_OW 74
115990: ST_TO_ADDR
// if k then
115991: LD_VAR 0 9
115995: IFFALSE 116043
// if GetDistUnits ( group [ i ] , k ) > 10 then
115997: LD_VAR 0 4
116001: PUSH
116002: LD_VAR 0 7
116006: ARRAY
116007: PPUSH
116008: LD_VAR 0 9
116012: PPUSH
116013: CALL_OW 296
116017: PUSH
116018: LD_INT 10
116020: GREATER
116021: IFFALSE 116043
// ComMoveUnit ( group [ i ] , k ) ;
116023: LD_VAR 0 4
116027: PUSH
116028: LD_VAR 0 7
116032: ARRAY
116033: PPUSH
116034: LD_VAR 0 9
116038: PPUSH
116039: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116043: LD_VAR 0 4
116047: PUSH
116048: LD_VAR 0 7
116052: ARRAY
116053: PPUSH
116054: CALL_OW 256
116058: PUSH
116059: LD_INT 250
116061: LESS
116062: PUSH
116063: LD_VAR 0 4
116067: PUSH
116068: LD_VAR 0 7
116072: ARRAY
116073: PUSH
116074: LD_INT 21
116076: PUSH
116077: LD_INT 2
116079: PUSH
116080: EMPTY
116081: LIST
116082: LIST
116083: PUSH
116084: LD_INT 23
116086: PUSH
116087: LD_INT 2
116089: PUSH
116090: EMPTY
116091: LIST
116092: LIST
116093: PUSH
116094: EMPTY
116095: LIST
116096: LIST
116097: PPUSH
116098: CALL_OW 69
116102: IN
116103: AND
116104: IFFALSE 116229
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116106: LD_ADDR_VAR 0 9
116110: PUSH
116111: LD_OWVAR 3
116115: PUSH
116116: LD_VAR 0 4
116120: PUSH
116121: LD_VAR 0 7
116125: ARRAY
116126: DIFF
116127: PPUSH
116128: LD_VAR 0 4
116132: PUSH
116133: LD_VAR 0 7
116137: ARRAY
116138: PPUSH
116139: CALL_OW 74
116143: ST_TO_ADDR
// if not k then
116144: LD_VAR 0 9
116148: NOT
116149: IFFALSE 116153
// continue ;
116151: GO 112568
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116153: LD_VAR 0 9
116157: PUSH
116158: LD_INT 81
116160: PUSH
116161: LD_VAR 0 4
116165: PUSH
116166: LD_VAR 0 7
116170: ARRAY
116171: PPUSH
116172: CALL_OW 255
116176: PUSH
116177: EMPTY
116178: LIST
116179: LIST
116180: PPUSH
116181: CALL_OW 69
116185: IN
116186: PUSH
116187: LD_VAR 0 9
116191: PPUSH
116192: LD_VAR 0 4
116196: PUSH
116197: LD_VAR 0 7
116201: ARRAY
116202: PPUSH
116203: CALL_OW 296
116207: PUSH
116208: LD_INT 5
116210: LESS
116211: AND
116212: IFFALSE 116229
// ComAutodestruct ( group [ i ] ) ;
116214: LD_VAR 0 4
116218: PUSH
116219: LD_VAR 0 7
116223: ARRAY
116224: PPUSH
116225: CALL 50500 0 1
// end ; if f_attack_depot then
116229: LD_VAR 0 25
116233: IFFALSE 116345
// begin k := 6 ;
116235: LD_ADDR_VAR 0 9
116239: PUSH
116240: LD_INT 6
116242: ST_TO_ADDR
// if tmp < k then
116243: LD_VAR 0 14
116247: PUSH
116248: LD_VAR 0 9
116252: LESS
116253: IFFALSE 116265
// k := tmp ;
116255: LD_ADDR_VAR 0 9
116259: PUSH
116260: LD_VAR 0 14
116264: ST_TO_ADDR
// for j = 1 to k do
116265: LD_ADDR_VAR 0 8
116269: PUSH
116270: DOUBLE
116271: LD_INT 1
116273: DEC
116274: ST_TO_ADDR
116275: LD_VAR 0 9
116279: PUSH
116280: FOR_TO
116281: IFFALSE 116343
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116283: LD_VAR 0 8
116287: PPUSH
116288: CALL_OW 266
116292: PUSH
116293: LD_INT 0
116295: PUSH
116296: LD_INT 1
116298: PUSH
116299: EMPTY
116300: LIST
116301: LIST
116302: IN
116303: IFFALSE 116341
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116305: LD_VAR 0 4
116309: PUSH
116310: LD_VAR 0 7
116314: ARRAY
116315: PPUSH
116316: LD_VAR 0 14
116320: PUSH
116321: LD_VAR 0 8
116325: ARRAY
116326: PPUSH
116327: CALL_OW 115
// attacking := true ;
116331: LD_ADDR_VAR 0 29
116335: PUSH
116336: LD_INT 1
116338: ST_TO_ADDR
// break ;
116339: GO 116343
// end ;
116341: GO 116280
116343: POP
116344: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116345: LD_VAR 0 4
116349: PUSH
116350: LD_VAR 0 7
116354: ARRAY
116355: PPUSH
116356: CALL_OW 302
116360: PUSH
116361: LD_VAR 0 29
116365: NOT
116366: AND
116367: IFFALSE 116689
// begin if GetTag ( group [ i ] ) = 71 then
116369: LD_VAR 0 4
116373: PUSH
116374: LD_VAR 0 7
116378: ARRAY
116379: PPUSH
116380: CALL_OW 110
116384: PUSH
116385: LD_INT 71
116387: EQUAL
116388: IFFALSE 116429
// begin if HasTask ( group [ i ] ) then
116390: LD_VAR 0 4
116394: PUSH
116395: LD_VAR 0 7
116399: ARRAY
116400: PPUSH
116401: CALL_OW 314
116405: IFFALSE 116411
// continue else
116407: GO 112568
116409: GO 116429
// SetTag ( group [ i ] , 0 ) ;
116411: LD_VAR 0 4
116415: PUSH
116416: LD_VAR 0 7
116420: ARRAY
116421: PPUSH
116422: LD_INT 0
116424: PPUSH
116425: CALL_OW 109
// end ; k := 8 ;
116429: LD_ADDR_VAR 0 9
116433: PUSH
116434: LD_INT 8
116436: ST_TO_ADDR
// x := 0 ;
116437: LD_ADDR_VAR 0 10
116441: PUSH
116442: LD_INT 0
116444: ST_TO_ADDR
// if tmp < k then
116445: LD_VAR 0 14
116449: PUSH
116450: LD_VAR 0 9
116454: LESS
116455: IFFALSE 116467
// k := tmp ;
116457: LD_ADDR_VAR 0 9
116461: PUSH
116462: LD_VAR 0 14
116466: ST_TO_ADDR
// for j = 1 to k do
116467: LD_ADDR_VAR 0 8
116471: PUSH
116472: DOUBLE
116473: LD_INT 1
116475: DEC
116476: ST_TO_ADDR
116477: LD_VAR 0 9
116481: PUSH
116482: FOR_TO
116483: IFFALSE 116581
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116485: LD_VAR 0 14
116489: PUSH
116490: LD_VAR 0 8
116494: ARRAY
116495: PPUSH
116496: CALL_OW 247
116500: PUSH
116501: LD_INT 1
116503: EQUAL
116504: PUSH
116505: LD_VAR 0 14
116509: PUSH
116510: LD_VAR 0 8
116514: ARRAY
116515: PPUSH
116516: CALL_OW 256
116520: PUSH
116521: LD_INT 250
116523: LESS
116524: PUSH
116525: LD_VAR 0 20
116529: AND
116530: PUSH
116531: LD_VAR 0 20
116535: NOT
116536: PUSH
116537: LD_VAR 0 14
116541: PUSH
116542: LD_VAR 0 8
116546: ARRAY
116547: PPUSH
116548: CALL_OW 256
116552: PUSH
116553: LD_INT 250
116555: GREATEREQUAL
116556: AND
116557: OR
116558: AND
116559: IFFALSE 116579
// begin x := tmp [ j ] ;
116561: LD_ADDR_VAR 0 10
116565: PUSH
116566: LD_VAR 0 14
116570: PUSH
116571: LD_VAR 0 8
116575: ARRAY
116576: ST_TO_ADDR
// break ;
116577: GO 116581
// end ;
116579: GO 116482
116581: POP
116582: POP
// if x then
116583: LD_VAR 0 10
116587: IFFALSE 116611
// ComAttackUnit ( group [ i ] , x ) else
116589: LD_VAR 0 4
116593: PUSH
116594: LD_VAR 0 7
116598: ARRAY
116599: PPUSH
116600: LD_VAR 0 10
116604: PPUSH
116605: CALL_OW 115
116609: GO 116635
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116611: LD_VAR 0 4
116615: PUSH
116616: LD_VAR 0 7
116620: ARRAY
116621: PPUSH
116622: LD_VAR 0 14
116626: PUSH
116627: LD_INT 1
116629: ARRAY
116630: PPUSH
116631: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116635: LD_VAR 0 4
116639: PUSH
116640: LD_VAR 0 7
116644: ARRAY
116645: PPUSH
116646: CALL_OW 314
116650: NOT
116651: IFFALSE 116689
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116653: LD_VAR 0 4
116657: PUSH
116658: LD_VAR 0 7
116662: ARRAY
116663: PPUSH
116664: LD_VAR 0 14
116668: PPUSH
116669: LD_VAR 0 4
116673: PUSH
116674: LD_VAR 0 7
116678: ARRAY
116679: PPUSH
116680: CALL_OW 74
116684: PPUSH
116685: CALL_OW 115
// end ; end ; end ;
116689: GO 112568
116691: POP
116692: POP
// wait ( 0 0$2 ) ;
116693: LD_INT 70
116695: PPUSH
116696: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116700: LD_VAR 0 4
116704: NOT
116705: PUSH
116706: LD_VAR 0 4
116710: PUSH
116711: EMPTY
116712: EQUAL
116713: OR
116714: PUSH
116715: LD_INT 81
116717: PUSH
116718: LD_VAR 0 35
116722: PUSH
116723: EMPTY
116724: LIST
116725: LIST
116726: PPUSH
116727: CALL_OW 69
116731: NOT
116732: OR
116733: IFFALSE 112553
// end ;
116735: LD_VAR 0 2
116739: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116740: LD_INT 0
116742: PPUSH
116743: PPUSH
116744: PPUSH
116745: PPUSH
116746: PPUSH
116747: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116748: LD_VAR 0 1
116752: NOT
116753: PUSH
116754: LD_EXP 63
116758: PUSH
116759: LD_VAR 0 1
116763: ARRAY
116764: NOT
116765: OR
116766: PUSH
116767: LD_VAR 0 2
116771: NOT
116772: OR
116773: IFFALSE 116777
// exit ;
116775: GO 117331
// side := mc_sides [ base ] ;
116777: LD_ADDR_VAR 0 6
116781: PUSH
116782: LD_EXP 89
116786: PUSH
116787: LD_VAR 0 1
116791: ARRAY
116792: ST_TO_ADDR
// if not side then
116793: LD_VAR 0 6
116797: NOT
116798: IFFALSE 116802
// exit ;
116800: GO 117331
// for i in solds do
116802: LD_ADDR_VAR 0 7
116806: PUSH
116807: LD_VAR 0 2
116811: PUSH
116812: FOR_IN
116813: IFFALSE 116874
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116815: LD_VAR 0 7
116819: PPUSH
116820: CALL_OW 310
116824: PPUSH
116825: CALL_OW 266
116829: PUSH
116830: LD_INT 32
116832: PUSH
116833: LD_INT 31
116835: PUSH
116836: EMPTY
116837: LIST
116838: LIST
116839: IN
116840: IFFALSE 116860
// solds := solds diff i else
116842: LD_ADDR_VAR 0 2
116846: PUSH
116847: LD_VAR 0 2
116851: PUSH
116852: LD_VAR 0 7
116856: DIFF
116857: ST_TO_ADDR
116858: GO 116872
// SetTag ( i , 18 ) ;
116860: LD_VAR 0 7
116864: PPUSH
116865: LD_INT 18
116867: PPUSH
116868: CALL_OW 109
116872: GO 116812
116874: POP
116875: POP
// if not solds then
116876: LD_VAR 0 2
116880: NOT
116881: IFFALSE 116885
// exit ;
116883: GO 117331
// repeat wait ( 0 0$2 ) ;
116885: LD_INT 70
116887: PPUSH
116888: CALL_OW 67
// enemy := mc_scan [ base ] ;
116892: LD_ADDR_VAR 0 4
116896: PUSH
116897: LD_EXP 86
116901: PUSH
116902: LD_VAR 0 1
116906: ARRAY
116907: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116908: LD_EXP 63
116912: PUSH
116913: LD_VAR 0 1
116917: ARRAY
116918: NOT
116919: PUSH
116920: LD_EXP 63
116924: PUSH
116925: LD_VAR 0 1
116929: ARRAY
116930: PUSH
116931: EMPTY
116932: EQUAL
116933: OR
116934: IFFALSE 116971
// begin for i in solds do
116936: LD_ADDR_VAR 0 7
116940: PUSH
116941: LD_VAR 0 2
116945: PUSH
116946: FOR_IN
116947: IFFALSE 116960
// ComStop ( i ) ;
116949: LD_VAR 0 7
116953: PPUSH
116954: CALL_OW 141
116958: GO 116946
116960: POP
116961: POP
// solds := [ ] ;
116962: LD_ADDR_VAR 0 2
116966: PUSH
116967: EMPTY
116968: ST_TO_ADDR
// exit ;
116969: GO 117331
// end ; for i in solds do
116971: LD_ADDR_VAR 0 7
116975: PUSH
116976: LD_VAR 0 2
116980: PUSH
116981: FOR_IN
116982: IFFALSE 117303
// begin if IsInUnit ( i ) then
116984: LD_VAR 0 7
116988: PPUSH
116989: CALL_OW 310
116993: IFFALSE 117004
// ComExitBuilding ( i ) ;
116995: LD_VAR 0 7
116999: PPUSH
117000: CALL_OW 122
// if GetLives ( i ) > 500 then
117004: LD_VAR 0 7
117008: PPUSH
117009: CALL_OW 256
117013: PUSH
117014: LD_INT 500
117016: GREATER
117017: IFFALSE 117070
// begin e := NearestUnitToUnit ( enemy , i ) ;
117019: LD_ADDR_VAR 0 5
117023: PUSH
117024: LD_VAR 0 4
117028: PPUSH
117029: LD_VAR 0 7
117033: PPUSH
117034: CALL_OW 74
117038: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117039: LD_VAR 0 7
117043: PPUSH
117044: LD_VAR 0 5
117048: PPUSH
117049: CALL_OW 250
117053: PPUSH
117054: LD_VAR 0 5
117058: PPUSH
117059: CALL_OW 251
117063: PPUSH
117064: CALL_OW 114
// end else
117068: GO 117301
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117070: LD_VAR 0 7
117074: PPUSH
117075: LD_EXP 63
117079: PUSH
117080: LD_VAR 0 1
117084: ARRAY
117085: PPUSH
117086: LD_INT 2
117088: PUSH
117089: LD_INT 30
117091: PUSH
117092: LD_INT 0
117094: PUSH
117095: EMPTY
117096: LIST
117097: LIST
117098: PUSH
117099: LD_INT 30
117101: PUSH
117102: LD_INT 1
117104: PUSH
117105: EMPTY
117106: LIST
117107: LIST
117108: PUSH
117109: LD_INT 30
117111: PUSH
117112: LD_INT 6
117114: PUSH
117115: EMPTY
117116: LIST
117117: LIST
117118: PUSH
117119: EMPTY
117120: LIST
117121: LIST
117122: LIST
117123: LIST
117124: PPUSH
117125: CALL_OW 72
117129: PPUSH
117130: LD_VAR 0 7
117134: PPUSH
117135: CALL_OW 74
117139: PPUSH
117140: CALL_OW 296
117144: PUSH
117145: LD_INT 10
117147: GREATER
117148: IFFALSE 117301
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117150: LD_ADDR_VAR 0 8
117154: PUSH
117155: LD_EXP 63
117159: PUSH
117160: LD_VAR 0 1
117164: ARRAY
117165: PPUSH
117166: LD_INT 2
117168: PUSH
117169: LD_INT 30
117171: PUSH
117172: LD_INT 0
117174: PUSH
117175: EMPTY
117176: LIST
117177: LIST
117178: PUSH
117179: LD_INT 30
117181: PUSH
117182: LD_INT 1
117184: PUSH
117185: EMPTY
117186: LIST
117187: LIST
117188: PUSH
117189: LD_INT 30
117191: PUSH
117192: LD_INT 6
117194: PUSH
117195: EMPTY
117196: LIST
117197: LIST
117198: PUSH
117199: EMPTY
117200: LIST
117201: LIST
117202: LIST
117203: LIST
117204: PPUSH
117205: CALL_OW 72
117209: PPUSH
117210: LD_VAR 0 7
117214: PPUSH
117215: CALL_OW 74
117219: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117220: LD_VAR 0 7
117224: PPUSH
117225: LD_VAR 0 8
117229: PPUSH
117230: CALL_OW 250
117234: PPUSH
117235: LD_INT 3
117237: PPUSH
117238: LD_INT 5
117240: PPUSH
117241: CALL_OW 272
117245: PPUSH
117246: LD_VAR 0 8
117250: PPUSH
117251: CALL_OW 251
117255: PPUSH
117256: LD_INT 3
117258: PPUSH
117259: LD_INT 5
117261: PPUSH
117262: CALL_OW 273
117266: PPUSH
117267: CALL_OW 111
// SetTag ( i , 0 ) ;
117271: LD_VAR 0 7
117275: PPUSH
117276: LD_INT 0
117278: PPUSH
117279: CALL_OW 109
// solds := solds diff i ;
117283: LD_ADDR_VAR 0 2
117287: PUSH
117288: LD_VAR 0 2
117292: PUSH
117293: LD_VAR 0 7
117297: DIFF
117298: ST_TO_ADDR
// continue ;
117299: GO 116981
// end ; end ;
117301: GO 116981
117303: POP
117304: POP
// until not solds or not enemy ;
117305: LD_VAR 0 2
117309: NOT
117310: PUSH
117311: LD_VAR 0 4
117315: NOT
117316: OR
117317: IFFALSE 116885
// MC_Reset ( base , 18 ) ;
117319: LD_VAR 0 1
117323: PPUSH
117324: LD_INT 18
117326: PPUSH
117327: CALL 64261 0 2
// end ;
117331: LD_VAR 0 3
117335: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117336: LD_INT 0
117338: PPUSH
117339: PPUSH
117340: PPUSH
117341: PPUSH
117342: PPUSH
117343: PPUSH
117344: PPUSH
117345: PPUSH
117346: PPUSH
117347: PPUSH
117348: PPUSH
117349: PPUSH
117350: PPUSH
117351: PPUSH
117352: PPUSH
117353: PPUSH
117354: PPUSH
117355: PPUSH
117356: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117357: LD_ADDR_VAR 0 12
117361: PUSH
117362: LD_EXP 63
117366: PUSH
117367: LD_VAR 0 1
117371: ARRAY
117372: PPUSH
117373: LD_INT 25
117375: PUSH
117376: LD_INT 3
117378: PUSH
117379: EMPTY
117380: LIST
117381: LIST
117382: PPUSH
117383: CALL_OW 72
117387: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117388: LD_EXP 103
117392: PUSH
117393: LD_VAR 0 1
117397: ARRAY
117398: IFFALSE 117422
// mechs := mechs diff mc_remote_driver [ base ] ;
117400: LD_ADDR_VAR 0 12
117404: PUSH
117405: LD_VAR 0 12
117409: PUSH
117410: LD_EXP 103
117414: PUSH
117415: LD_VAR 0 1
117419: ARRAY
117420: DIFF
117421: ST_TO_ADDR
// for i in mechs do
117422: LD_ADDR_VAR 0 4
117426: PUSH
117427: LD_VAR 0 12
117431: PUSH
117432: FOR_IN
117433: IFFALSE 117468
// if GetTag ( i ) > 0 then
117435: LD_VAR 0 4
117439: PPUSH
117440: CALL_OW 110
117444: PUSH
117445: LD_INT 0
117447: GREATER
117448: IFFALSE 117466
// mechs := mechs diff i ;
117450: LD_ADDR_VAR 0 12
117454: PUSH
117455: LD_VAR 0 12
117459: PUSH
117460: LD_VAR 0 4
117464: DIFF
117465: ST_TO_ADDR
117466: GO 117432
117468: POP
117469: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117470: LD_ADDR_VAR 0 8
117474: PUSH
117475: LD_EXP 63
117479: PUSH
117480: LD_VAR 0 1
117484: ARRAY
117485: PPUSH
117486: LD_INT 2
117488: PUSH
117489: LD_INT 25
117491: PUSH
117492: LD_INT 1
117494: PUSH
117495: EMPTY
117496: LIST
117497: LIST
117498: PUSH
117499: LD_INT 25
117501: PUSH
117502: LD_INT 5
117504: PUSH
117505: EMPTY
117506: LIST
117507: LIST
117508: PUSH
117509: LD_INT 25
117511: PUSH
117512: LD_INT 8
117514: PUSH
117515: EMPTY
117516: LIST
117517: LIST
117518: PUSH
117519: LD_INT 25
117521: PUSH
117522: LD_INT 9
117524: PUSH
117525: EMPTY
117526: LIST
117527: LIST
117528: PUSH
117529: EMPTY
117530: LIST
117531: LIST
117532: LIST
117533: LIST
117534: LIST
117535: PPUSH
117536: CALL_OW 72
117540: ST_TO_ADDR
// if not defenders and not solds then
117541: LD_VAR 0 2
117545: NOT
117546: PUSH
117547: LD_VAR 0 8
117551: NOT
117552: AND
117553: IFFALSE 117557
// exit ;
117555: GO 119327
// depot_under_attack := false ;
117557: LD_ADDR_VAR 0 16
117561: PUSH
117562: LD_INT 0
117564: ST_TO_ADDR
// sold_defenders := [ ] ;
117565: LD_ADDR_VAR 0 17
117569: PUSH
117570: EMPTY
117571: ST_TO_ADDR
// if mechs then
117572: LD_VAR 0 12
117576: IFFALSE 117729
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117578: LD_ADDR_VAR 0 4
117582: PUSH
117583: LD_VAR 0 2
117587: PPUSH
117588: LD_INT 21
117590: PUSH
117591: LD_INT 2
117593: PUSH
117594: EMPTY
117595: LIST
117596: LIST
117597: PPUSH
117598: CALL_OW 72
117602: PUSH
117603: FOR_IN
117604: IFFALSE 117727
// begin if GetTag ( i ) <> 20 then
117606: LD_VAR 0 4
117610: PPUSH
117611: CALL_OW 110
117615: PUSH
117616: LD_INT 20
117618: NONEQUAL
117619: IFFALSE 117633
// SetTag ( i , 20 ) ;
117621: LD_VAR 0 4
117625: PPUSH
117626: LD_INT 20
117628: PPUSH
117629: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117633: LD_VAR 0 4
117637: PPUSH
117638: CALL_OW 263
117642: PUSH
117643: LD_INT 1
117645: EQUAL
117646: PUSH
117647: LD_VAR 0 4
117651: PPUSH
117652: CALL_OW 311
117656: NOT
117657: AND
117658: IFFALSE 117725
// begin un := mechs [ 1 ] ;
117660: LD_ADDR_VAR 0 10
117664: PUSH
117665: LD_VAR 0 12
117669: PUSH
117670: LD_INT 1
117672: ARRAY
117673: ST_TO_ADDR
// ComExit ( un ) ;
117674: LD_VAR 0 10
117678: PPUSH
117679: CALL 55406 0 1
// AddComEnterUnit ( un , i ) ;
117683: LD_VAR 0 10
117687: PPUSH
117688: LD_VAR 0 4
117692: PPUSH
117693: CALL_OW 180
// SetTag ( un , 19 ) ;
117697: LD_VAR 0 10
117701: PPUSH
117702: LD_INT 19
117704: PPUSH
117705: CALL_OW 109
// mechs := mechs diff un ;
117709: LD_ADDR_VAR 0 12
117713: PUSH
117714: LD_VAR 0 12
117718: PUSH
117719: LD_VAR 0 10
117723: DIFF
117724: ST_TO_ADDR
// end ; end ;
117725: GO 117603
117727: POP
117728: POP
// if solds then
117729: LD_VAR 0 8
117733: IFFALSE 117792
// for i in solds do
117735: LD_ADDR_VAR 0 4
117739: PUSH
117740: LD_VAR 0 8
117744: PUSH
117745: FOR_IN
117746: IFFALSE 117790
// if not GetTag ( i ) then
117748: LD_VAR 0 4
117752: PPUSH
117753: CALL_OW 110
117757: NOT
117758: IFFALSE 117788
// begin defenders := defenders union i ;
117760: LD_ADDR_VAR 0 2
117764: PUSH
117765: LD_VAR 0 2
117769: PUSH
117770: LD_VAR 0 4
117774: UNION
117775: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117776: LD_VAR 0 4
117780: PPUSH
117781: LD_INT 18
117783: PPUSH
117784: CALL_OW 109
// end ;
117788: GO 117745
117790: POP
117791: POP
// repeat wait ( 0 0$2 ) ;
117792: LD_INT 70
117794: PPUSH
117795: CALL_OW 67
// enemy := mc_scan [ base ] ;
117799: LD_ADDR_VAR 0 21
117803: PUSH
117804: LD_EXP 86
117808: PUSH
117809: LD_VAR 0 1
117813: ARRAY
117814: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117815: LD_EXP 63
117819: PUSH
117820: LD_VAR 0 1
117824: ARRAY
117825: NOT
117826: PUSH
117827: LD_EXP 63
117831: PUSH
117832: LD_VAR 0 1
117836: ARRAY
117837: PUSH
117838: EMPTY
117839: EQUAL
117840: OR
117841: IFFALSE 117878
// begin for i in defenders do
117843: LD_ADDR_VAR 0 4
117847: PUSH
117848: LD_VAR 0 2
117852: PUSH
117853: FOR_IN
117854: IFFALSE 117867
// ComStop ( i ) ;
117856: LD_VAR 0 4
117860: PPUSH
117861: CALL_OW 141
117865: GO 117853
117867: POP
117868: POP
// defenders := [ ] ;
117869: LD_ADDR_VAR 0 2
117873: PUSH
117874: EMPTY
117875: ST_TO_ADDR
// exit ;
117876: GO 119327
// end ; for i in defenders do
117878: LD_ADDR_VAR 0 4
117882: PUSH
117883: LD_VAR 0 2
117887: PUSH
117888: FOR_IN
117889: IFFALSE 118787
// begin e := NearestUnitToUnit ( enemy , i ) ;
117891: LD_ADDR_VAR 0 13
117895: PUSH
117896: LD_VAR 0 21
117900: PPUSH
117901: LD_VAR 0 4
117905: PPUSH
117906: CALL_OW 74
117910: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117911: LD_ADDR_VAR 0 7
117915: PUSH
117916: LD_EXP 63
117920: PUSH
117921: LD_VAR 0 1
117925: ARRAY
117926: PPUSH
117927: LD_INT 2
117929: PUSH
117930: LD_INT 30
117932: PUSH
117933: LD_INT 0
117935: PUSH
117936: EMPTY
117937: LIST
117938: LIST
117939: PUSH
117940: LD_INT 30
117942: PUSH
117943: LD_INT 1
117945: PUSH
117946: EMPTY
117947: LIST
117948: LIST
117949: PUSH
117950: EMPTY
117951: LIST
117952: LIST
117953: LIST
117954: PPUSH
117955: CALL_OW 72
117959: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117960: LD_ADDR_VAR 0 16
117964: PUSH
117965: LD_VAR 0 7
117969: NOT
117970: PUSH
117971: LD_VAR 0 7
117975: PPUSH
117976: LD_INT 3
117978: PUSH
117979: LD_INT 24
117981: PUSH
117982: LD_INT 600
117984: PUSH
117985: EMPTY
117986: LIST
117987: LIST
117988: PUSH
117989: EMPTY
117990: LIST
117991: LIST
117992: PPUSH
117993: CALL_OW 72
117997: OR
117998: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117999: LD_VAR 0 4
118003: PPUSH
118004: CALL_OW 247
118008: PUSH
118009: LD_INT 2
118011: DOUBLE
118012: EQUAL
118013: IFTRUE 118017
118015: GO 118413
118017: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118018: LD_VAR 0 4
118022: PPUSH
118023: CALL_OW 256
118027: PUSH
118028: LD_INT 1000
118030: EQUAL
118031: PUSH
118032: LD_VAR 0 4
118036: PPUSH
118037: LD_VAR 0 13
118041: PPUSH
118042: CALL_OW 296
118046: PUSH
118047: LD_INT 40
118049: LESS
118050: PUSH
118051: LD_VAR 0 13
118055: PPUSH
118056: LD_EXP 88
118060: PUSH
118061: LD_VAR 0 1
118065: ARRAY
118066: PPUSH
118067: CALL_OW 308
118071: OR
118072: AND
118073: IFFALSE 118195
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118075: LD_VAR 0 4
118079: PPUSH
118080: CALL_OW 262
118084: PUSH
118085: LD_INT 1
118087: EQUAL
118088: PUSH
118089: LD_VAR 0 4
118093: PPUSH
118094: CALL_OW 261
118098: PUSH
118099: LD_INT 30
118101: LESS
118102: AND
118103: PUSH
118104: LD_VAR 0 7
118108: AND
118109: IFFALSE 118179
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118111: LD_VAR 0 4
118115: PPUSH
118116: LD_VAR 0 7
118120: PPUSH
118121: LD_VAR 0 4
118125: PPUSH
118126: CALL_OW 74
118130: PPUSH
118131: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118135: LD_VAR 0 4
118139: PPUSH
118140: LD_VAR 0 7
118144: PPUSH
118145: LD_VAR 0 4
118149: PPUSH
118150: CALL_OW 74
118154: PPUSH
118155: CALL_OW 296
118159: PUSH
118160: LD_INT 6
118162: LESS
118163: IFFALSE 118177
// SetFuel ( i , 100 ) ;
118165: LD_VAR 0 4
118169: PPUSH
118170: LD_INT 100
118172: PPUSH
118173: CALL_OW 240
// end else
118177: GO 118193
// ComAttackUnit ( i , e ) ;
118179: LD_VAR 0 4
118183: PPUSH
118184: LD_VAR 0 13
118188: PPUSH
118189: CALL_OW 115
// end else
118193: GO 118296
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118195: LD_VAR 0 13
118199: PPUSH
118200: LD_EXP 88
118204: PUSH
118205: LD_VAR 0 1
118209: ARRAY
118210: PPUSH
118211: CALL_OW 308
118215: NOT
118216: PUSH
118217: LD_VAR 0 4
118221: PPUSH
118222: LD_VAR 0 13
118226: PPUSH
118227: CALL_OW 296
118231: PUSH
118232: LD_INT 40
118234: GREATEREQUAL
118235: AND
118236: PUSH
118237: LD_VAR 0 4
118241: PPUSH
118242: CALL_OW 256
118246: PUSH
118247: LD_INT 650
118249: LESSEQUAL
118250: OR
118251: PUSH
118252: LD_VAR 0 4
118256: PPUSH
118257: LD_EXP 87
118261: PUSH
118262: LD_VAR 0 1
118266: ARRAY
118267: PPUSH
118268: CALL_OW 308
118272: NOT
118273: AND
118274: IFFALSE 118296
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118276: LD_VAR 0 4
118280: PPUSH
118281: LD_EXP 87
118285: PUSH
118286: LD_VAR 0 1
118290: ARRAY
118291: PPUSH
118292: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118296: LD_VAR 0 4
118300: PPUSH
118301: CALL_OW 256
118305: PUSH
118306: LD_INT 1000
118308: LESS
118309: PUSH
118310: LD_VAR 0 4
118314: PPUSH
118315: CALL_OW 263
118319: PUSH
118320: LD_INT 1
118322: EQUAL
118323: AND
118324: PUSH
118325: LD_VAR 0 4
118329: PPUSH
118330: CALL_OW 311
118334: AND
118335: PUSH
118336: LD_VAR 0 4
118340: PPUSH
118341: LD_EXP 87
118345: PUSH
118346: LD_VAR 0 1
118350: ARRAY
118351: PPUSH
118352: CALL_OW 308
118356: AND
118357: IFFALSE 118411
// begin mech := IsDrivenBy ( i ) ;
118359: LD_ADDR_VAR 0 9
118363: PUSH
118364: LD_VAR 0 4
118368: PPUSH
118369: CALL_OW 311
118373: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118374: LD_VAR 0 9
118378: PPUSH
118379: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118383: LD_VAR 0 9
118387: PPUSH
118388: LD_VAR 0 4
118392: PPUSH
118393: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118397: LD_VAR 0 9
118401: PPUSH
118402: LD_VAR 0 4
118406: PPUSH
118407: CALL_OW 180
// end ; end ; unit_human :
118411: GO 118758
118413: LD_INT 1
118415: DOUBLE
118416: EQUAL
118417: IFTRUE 118421
118419: GO 118757
118421: POP
// begin b := IsInUnit ( i ) ;
118422: LD_ADDR_VAR 0 18
118426: PUSH
118427: LD_VAR 0 4
118431: PPUSH
118432: CALL_OW 310
118436: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118437: LD_ADDR_VAR 0 19
118441: PUSH
118442: LD_VAR 0 18
118446: NOT
118447: PUSH
118448: LD_VAR 0 18
118452: PPUSH
118453: CALL_OW 266
118457: PUSH
118458: LD_INT 32
118460: PUSH
118461: LD_INT 31
118463: PUSH
118464: EMPTY
118465: LIST
118466: LIST
118467: IN
118468: OR
118469: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118470: LD_VAR 0 18
118474: PPUSH
118475: CALL_OW 266
118479: PUSH
118480: LD_INT 5
118482: EQUAL
118483: PUSH
118484: LD_VAR 0 4
118488: PPUSH
118489: CALL_OW 257
118493: PUSH
118494: LD_INT 1
118496: PUSH
118497: LD_INT 2
118499: PUSH
118500: LD_INT 3
118502: PUSH
118503: LD_INT 4
118505: PUSH
118506: EMPTY
118507: LIST
118508: LIST
118509: LIST
118510: LIST
118511: IN
118512: AND
118513: IFFALSE 118550
// begin class := AllowSpecClass ( i ) ;
118515: LD_ADDR_VAR 0 20
118519: PUSH
118520: LD_VAR 0 4
118524: PPUSH
118525: CALL 19083 0 1
118529: ST_TO_ADDR
// if class then
118530: LD_VAR 0 20
118534: IFFALSE 118550
// ComChangeProfession ( i , class ) ;
118536: LD_VAR 0 4
118540: PPUSH
118541: LD_VAR 0 20
118545: PPUSH
118546: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118550: LD_VAR 0 16
118554: PUSH
118555: LD_VAR 0 2
118559: PPUSH
118560: LD_INT 21
118562: PUSH
118563: LD_INT 2
118565: PUSH
118566: EMPTY
118567: LIST
118568: LIST
118569: PPUSH
118570: CALL_OW 72
118574: PUSH
118575: LD_INT 1
118577: LESSEQUAL
118578: OR
118579: PUSH
118580: LD_VAR 0 19
118584: AND
118585: PUSH
118586: LD_VAR 0 4
118590: PUSH
118591: LD_VAR 0 17
118595: IN
118596: NOT
118597: AND
118598: IFFALSE 118691
// begin if b then
118600: LD_VAR 0 18
118604: IFFALSE 118653
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118606: LD_VAR 0 18
118610: PPUSH
118611: LD_VAR 0 21
118615: PPUSH
118616: LD_VAR 0 18
118620: PPUSH
118621: CALL_OW 74
118625: PPUSH
118626: CALL_OW 296
118630: PUSH
118631: LD_INT 10
118633: LESS
118634: PUSH
118635: LD_VAR 0 18
118639: PPUSH
118640: CALL_OW 461
118644: PUSH
118645: LD_INT 7
118647: NONEQUAL
118648: AND
118649: IFFALSE 118653
// continue ;
118651: GO 117888
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118653: LD_ADDR_VAR 0 17
118657: PUSH
118658: LD_VAR 0 17
118662: PPUSH
118663: LD_VAR 0 17
118667: PUSH
118668: LD_INT 1
118670: PLUS
118671: PPUSH
118672: LD_VAR 0 4
118676: PPUSH
118677: CALL_OW 1
118681: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118682: LD_VAR 0 4
118686: PPUSH
118687: CALL_OW 122
// end ; if sold_defenders then
118691: LD_VAR 0 17
118695: IFFALSE 118755
// if i in sold_defenders then
118697: LD_VAR 0 4
118701: PUSH
118702: LD_VAR 0 17
118706: IN
118707: IFFALSE 118755
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118709: LD_VAR 0 4
118713: PPUSH
118714: CALL_OW 314
118718: NOT
118719: PUSH
118720: LD_VAR 0 4
118724: PPUSH
118725: LD_VAR 0 13
118729: PPUSH
118730: CALL_OW 296
118734: PUSH
118735: LD_INT 30
118737: LESS
118738: AND
118739: IFFALSE 118755
// ComAttackUnit ( i , e ) ;
118741: LD_VAR 0 4
118745: PPUSH
118746: LD_VAR 0 13
118750: PPUSH
118751: CALL_OW 115
// end ; end ; end ;
118755: GO 118758
118757: POP
// if IsDead ( i ) then
118758: LD_VAR 0 4
118762: PPUSH
118763: CALL_OW 301
118767: IFFALSE 118785
// defenders := defenders diff i ;
118769: LD_ADDR_VAR 0 2
118773: PUSH
118774: LD_VAR 0 2
118778: PUSH
118779: LD_VAR 0 4
118783: DIFF
118784: ST_TO_ADDR
// end ;
118785: GO 117888
118787: POP
118788: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118789: LD_VAR 0 21
118793: NOT
118794: PUSH
118795: LD_VAR 0 2
118799: NOT
118800: OR
118801: PUSH
118802: LD_EXP 63
118806: PUSH
118807: LD_VAR 0 1
118811: ARRAY
118812: NOT
118813: OR
118814: IFFALSE 117792
// MC_Reset ( base , 18 ) ;
118816: LD_VAR 0 1
118820: PPUSH
118821: LD_INT 18
118823: PPUSH
118824: CALL 64261 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118828: LD_ADDR_VAR 0 2
118832: PUSH
118833: LD_VAR 0 2
118837: PUSH
118838: LD_VAR 0 2
118842: PPUSH
118843: LD_INT 2
118845: PUSH
118846: LD_INT 25
118848: PUSH
118849: LD_INT 1
118851: PUSH
118852: EMPTY
118853: LIST
118854: LIST
118855: PUSH
118856: LD_INT 25
118858: PUSH
118859: LD_INT 5
118861: PUSH
118862: EMPTY
118863: LIST
118864: LIST
118865: PUSH
118866: LD_INT 25
118868: PUSH
118869: LD_INT 8
118871: PUSH
118872: EMPTY
118873: LIST
118874: LIST
118875: PUSH
118876: LD_INT 25
118878: PUSH
118879: LD_INT 9
118881: PUSH
118882: EMPTY
118883: LIST
118884: LIST
118885: PUSH
118886: EMPTY
118887: LIST
118888: LIST
118889: LIST
118890: LIST
118891: LIST
118892: PPUSH
118893: CALL_OW 72
118897: DIFF
118898: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
118899: LD_VAR 0 21
118903: NOT
118904: PUSH
118905: LD_VAR 0 2
118909: PPUSH
118910: LD_INT 21
118912: PUSH
118913: LD_INT 2
118915: PUSH
118916: EMPTY
118917: LIST
118918: LIST
118919: PPUSH
118920: CALL_OW 72
118924: AND
118925: IFFALSE 119263
// begin tmp := FilterByTag ( defenders , 19 ) ;
118927: LD_ADDR_VAR 0 11
118931: PUSH
118932: LD_VAR 0 2
118936: PPUSH
118937: LD_INT 19
118939: PPUSH
118940: CALL 52577 0 2
118944: ST_TO_ADDR
// if tmp then
118945: LD_VAR 0 11
118949: IFFALSE 119019
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118951: LD_ADDR_VAR 0 11
118955: PUSH
118956: LD_VAR 0 11
118960: PPUSH
118961: LD_INT 25
118963: PUSH
118964: LD_INT 3
118966: PUSH
118967: EMPTY
118968: LIST
118969: LIST
118970: PPUSH
118971: CALL_OW 72
118975: ST_TO_ADDR
// if tmp then
118976: LD_VAR 0 11
118980: IFFALSE 119019
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118982: LD_ADDR_EXP 75
118986: PUSH
118987: LD_EXP 75
118991: PPUSH
118992: LD_VAR 0 1
118996: PPUSH
118997: LD_EXP 75
119001: PUSH
119002: LD_VAR 0 1
119006: ARRAY
119007: PUSH
119008: LD_VAR 0 11
119012: UNION
119013: PPUSH
119014: CALL_OW 1
119018: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119019: LD_VAR 0 1
119023: PPUSH
119024: LD_INT 19
119026: PPUSH
119027: CALL 64261 0 2
// repeat wait ( 0 0$1 ) ;
119031: LD_INT 35
119033: PPUSH
119034: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119038: LD_EXP 63
119042: PUSH
119043: LD_VAR 0 1
119047: ARRAY
119048: NOT
119049: PUSH
119050: LD_EXP 63
119054: PUSH
119055: LD_VAR 0 1
119059: ARRAY
119060: PUSH
119061: EMPTY
119062: EQUAL
119063: OR
119064: IFFALSE 119101
// begin for i in defenders do
119066: LD_ADDR_VAR 0 4
119070: PUSH
119071: LD_VAR 0 2
119075: PUSH
119076: FOR_IN
119077: IFFALSE 119090
// ComStop ( i ) ;
119079: LD_VAR 0 4
119083: PPUSH
119084: CALL_OW 141
119088: GO 119076
119090: POP
119091: POP
// defenders := [ ] ;
119092: LD_ADDR_VAR 0 2
119096: PUSH
119097: EMPTY
119098: ST_TO_ADDR
// exit ;
119099: GO 119327
// end ; for i in defenders do
119101: LD_ADDR_VAR 0 4
119105: PUSH
119106: LD_VAR 0 2
119110: PUSH
119111: FOR_IN
119112: IFFALSE 119201
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119114: LD_VAR 0 4
119118: PPUSH
119119: LD_EXP 87
119123: PUSH
119124: LD_VAR 0 1
119128: ARRAY
119129: PPUSH
119130: CALL_OW 308
119134: NOT
119135: IFFALSE 119159
// ComMoveToArea ( i , mc_parking [ base ] ) else
119137: LD_VAR 0 4
119141: PPUSH
119142: LD_EXP 87
119146: PUSH
119147: LD_VAR 0 1
119151: ARRAY
119152: PPUSH
119153: CALL_OW 113
119157: GO 119199
// if GetControl ( i ) = control_manual then
119159: LD_VAR 0 4
119163: PPUSH
119164: CALL_OW 263
119168: PUSH
119169: LD_INT 1
119171: EQUAL
119172: IFFALSE 119199
// if IsDrivenBy ( i ) then
119174: LD_VAR 0 4
119178: PPUSH
119179: CALL_OW 311
119183: IFFALSE 119199
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119185: LD_VAR 0 4
119189: PPUSH
119190: CALL_OW 311
119194: PPUSH
119195: CALL_OW 121
// end ;
119199: GO 119111
119201: POP
119202: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119203: LD_VAR 0 2
119207: PPUSH
119208: LD_INT 95
119210: PUSH
119211: LD_EXP 87
119215: PUSH
119216: LD_VAR 0 1
119220: ARRAY
119221: PUSH
119222: EMPTY
119223: LIST
119224: LIST
119225: PPUSH
119226: CALL_OW 72
119230: PUSH
119231: LD_VAR 0 2
119235: EQUAL
119236: PUSH
119237: LD_EXP 86
119241: PUSH
119242: LD_VAR 0 1
119246: ARRAY
119247: OR
119248: PUSH
119249: LD_EXP 63
119253: PUSH
119254: LD_VAR 0 1
119258: ARRAY
119259: NOT
119260: OR
119261: IFFALSE 119031
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119263: LD_ADDR_EXP 85
119267: PUSH
119268: LD_EXP 85
119272: PPUSH
119273: LD_VAR 0 1
119277: PPUSH
119278: LD_VAR 0 2
119282: PPUSH
119283: LD_INT 21
119285: PUSH
119286: LD_INT 2
119288: PUSH
119289: EMPTY
119290: LIST
119291: LIST
119292: PPUSH
119293: CALL_OW 72
119297: PPUSH
119298: CALL_OW 1
119302: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119303: LD_VAR 0 1
119307: PPUSH
119308: LD_INT 19
119310: PPUSH
119311: CALL 64261 0 2
// MC_Reset ( base , 20 ) ;
119315: LD_VAR 0 1
119319: PPUSH
119320: LD_INT 20
119322: PPUSH
119323: CALL 64261 0 2
// end ; end_of_file
119327: LD_VAR 0 3
119331: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119332: LD_VAR 0 1
119336: PUSH
119337: LD_INT 200
119339: DOUBLE
119340: GREATEREQUAL
119341: IFFALSE 119349
119343: LD_INT 299
119345: DOUBLE
119346: LESSEQUAL
119347: IFTRUE 119351
119349: GO 119383
119351: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119352: LD_VAR 0 1
119356: PPUSH
119357: LD_VAR 0 2
119361: PPUSH
119362: LD_VAR 0 3
119366: PPUSH
119367: LD_VAR 0 4
119371: PPUSH
119372: LD_VAR 0 5
119376: PPUSH
119377: CALL 107332 0 5
119381: GO 119460
119383: LD_INT 300
119385: DOUBLE
119386: GREATEREQUAL
119387: IFFALSE 119395
119389: LD_INT 399
119391: DOUBLE
119392: LESSEQUAL
119393: IFTRUE 119397
119395: GO 119459
119397: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119398: LD_VAR 0 1
119402: PPUSH
119403: LD_VAR 0 2
119407: PPUSH
119408: LD_VAR 0 3
119412: PPUSH
119413: LD_VAR 0 4
119417: PPUSH
119418: LD_VAR 0 5
119422: PPUSH
119423: LD_VAR 0 6
119427: PPUSH
119428: LD_VAR 0 7
119432: PPUSH
119433: LD_VAR 0 8
119437: PPUSH
119438: LD_VAR 0 9
119442: PPUSH
119443: LD_VAR 0 10
119447: PPUSH
119448: LD_VAR 0 11
119452: PPUSH
119453: CALL 103320 0 11
119457: GO 119460
119459: POP
// end ;
119460: PPOPN 11
119462: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119463: LD_VAR 0 1
119467: PPUSH
119468: LD_VAR 0 2
119472: PPUSH
119473: LD_VAR 0 3
119477: PPUSH
119478: LD_VAR 0 4
119482: PPUSH
119483: LD_VAR 0 5
119487: PPUSH
119488: CALL 106797 0 5
// end ; end_of_file
119492: PPOPN 5
119494: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119495: LD_VAR 0 1
119499: PPUSH
119500: LD_VAR 0 2
119504: PPUSH
119505: LD_VAR 0 3
119509: PPUSH
119510: LD_VAR 0 4
119514: PPUSH
119515: LD_VAR 0 5
119519: PPUSH
119520: LD_VAR 0 6
119524: PPUSH
119525: CALL 90972 0 6
// end ;
119529: PPOPN 6
119531: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119532: LD_INT 0
119534: PPUSH
// begin if not units then
119535: LD_VAR 0 1
119539: NOT
119540: IFFALSE 119544
// exit ;
119542: GO 119544
// end ;
119544: PPOPN 7
119546: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119547: CALL 90859 0 0
// end ;
119551: PPOPN 1
119553: END
